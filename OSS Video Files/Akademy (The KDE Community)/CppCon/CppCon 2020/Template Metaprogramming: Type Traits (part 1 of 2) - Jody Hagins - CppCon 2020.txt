Title: Template Metaprogramming: Type Traits (part 1 of 2) - Jody Hagins - CppCon 2020
Publication date: 2020-09-22
Playlist: CppCon 2020
Description: 
	PART 2: https://youtu.be/dLZcocFOb5Q

https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/template_metaprogramming_type_traits/template_metaprogramming_type_traits__jody_hagins__cppcon_2020.pdf
---
Template metaprogramming is a vast subject, but there are a small number of basic fundamental idioms that are used over and over. Mastery of these idioms will help in reading, writing, and using modern C++ code. The type traits that come as part of the standard library are incredibly useful, but at times can be thought of as some form of dark magic.

In this tutorial, we will explore some of the fundamental idioms of template metaprogramming by implementing a good portion of the type traits from the standard library. In so doing, attendees will come away with a solid understanding of how to apply the fundamental template metaprogramming idioms to solve problems including, but not limited to, standard type traits.

---
Jody Hagins first compiled "C++" code in 1984, and wrote a specialized LisP editor using Zortech C++ for senior project in 1988. However, he didn't truly start programming in C++ until 1992, when he read The Greatest C++ Book Ever Written, "Advanced C++ Programming Styles and Idioms" by Jim Coplien. That book, combined with cfront, which generated C code from C++ source, gave him the joyful task of writing SVr4 Streams drivers in C++. Ever since, he has been hooked on writing C++ code for kernel modules, large telephony applications, and, since the late 1990s, applications in what is now known as the high frequency trading industry.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,840 --> 00:00:13,040
hi

00:00:10,320 --> 00:00:14,160
i'm jody hagans welcome to template meta

00:00:13,040 --> 00:00:16,480
programming with an

00:00:14,160 --> 00:00:17,440
emphasis on type traits part one of a

00:00:16,480 --> 00:00:20,400
two-part

00:00:17,440 --> 00:00:20,400
uh tutorial

00:00:20,880 --> 00:00:27,680
so first intended audience basically is

00:00:24,640 --> 00:00:29,920
a beginner to intermediate um

00:00:27,680 --> 00:00:31,519
hopefully this will be a general entry

00:00:29,920 --> 00:00:34,480
kind of like a swimming pool

00:00:31,519 --> 00:00:35,520
you know going into a river where you'll

00:00:34,480 --> 00:00:37,840
walk in

00:00:35,520 --> 00:00:39,440
you know get your toes wet then you get

00:00:37,840 --> 00:00:41,120
your knees wet eventually you'll get to

00:00:39,440 --> 00:00:41,520
that little rope at the swimming pool

00:00:41,120 --> 00:00:43,280
and

00:00:41,520 --> 00:00:44,800
get into the deep end and there might

00:00:43,280 --> 00:00:47,039
even be a river at the end

00:00:44,800 --> 00:00:47,840
that uh we get into and might take us

00:00:47,039 --> 00:00:51,039
down the

00:00:47,840 --> 00:00:52,000
a little bit but uh it hopefully it'll

00:00:51,039 --> 00:00:54,559
be able to

00:00:52,000 --> 00:00:55,920
give a beginning introduction to just

00:00:54,559 --> 00:00:59,359
about anybody

00:00:55,920 --> 00:01:02,160
um and uh

00:00:59,359 --> 00:01:04,320
um and and with enough stuff later on

00:01:02,160 --> 00:01:07,840
for some experienced people around

00:01:04,320 --> 00:01:10,720
it's not necessarily a talk geared for

00:01:07,840 --> 00:01:11,360
beginners to c plus plus though novices

00:01:10,720 --> 00:01:13,040
to c

00:01:11,360 --> 00:01:14,560
plus i i worked hard to try and make

00:01:13,040 --> 00:01:17,680
sure that novices would

00:01:14,560 --> 00:01:20,479
be able to follow along uh because

00:01:17,680 --> 00:01:21,840
um there's not a whole lot of stuff um

00:01:20,479 --> 00:01:24,159
available

00:01:21,840 --> 00:01:26,000
on this type of forum for um

00:01:24,159 --> 00:01:27,520
introductions to this stuff you know one

00:01:26,000 --> 00:01:28,560
of the motivations is i was speaking

00:01:27,520 --> 00:01:29,439
with several people who've been

00:01:28,560 --> 00:01:32,159
programming

00:01:29,439 --> 00:01:34,159
in c plus plus for 20 plus years but yet

00:01:32,159 --> 00:01:35,920
because of their work environment either

00:01:34,159 --> 00:01:38,479
through doing defense contracting

00:01:35,920 --> 00:01:39,280
or because of the compilers that their

00:01:38,479 --> 00:01:41,360
um their

00:01:39,280 --> 00:01:43,119
employers are mandating that they use

00:01:41,360 --> 00:01:44,720
they really haven't used much of

00:01:43,119 --> 00:01:46,320
the meta programming techniques at all

00:01:44,720 --> 00:01:47,520
and now it just seems like such a big

00:01:46,320 --> 00:01:49,840
barrier to entry

00:01:47,520 --> 00:01:51,439
because the techniques have advanced so

00:01:49,840 --> 00:01:52,799
much in the past 20 years and just in

00:01:51,439 --> 00:01:53,280
the past five years have advanced so

00:01:52,799 --> 00:01:55,920
much

00:01:53,280 --> 00:01:57,600
that it seems like it's so steep so this

00:01:55,920 --> 00:02:00,880
is intended to be

00:01:57,600 --> 00:02:02,399
um to to be an introduction for that

00:02:00,880 --> 00:02:04,240
you know the type traits have been

00:02:02,399 --> 00:02:05,040
around part of the standard library for

00:02:04,240 --> 00:02:06,399
10 years

00:02:05,040 --> 00:02:08,879
but the fundamentals have been in use

00:02:06,399 --> 00:02:11,440
for about 20 years

00:02:08,879 --> 00:02:13,680
you know some have avoided more modern

00:02:11,440 --> 00:02:16,560
techniques because of a perceived large

00:02:13,680 --> 00:02:17,760
barrier to entry um and part two will be

00:02:16,560 --> 00:02:19,760
a continuation

00:02:17,760 --> 00:02:21,200
but uh you know a little bit more depth

00:02:19,760 --> 00:02:24,080
with hopefully a

00:02:21,200 --> 00:02:24,080
swifter current

00:02:24,640 --> 00:02:31,519
so this talk is

00:02:29,200 --> 00:02:33,040
basically going to fill some gaps if you

00:02:31,519 --> 00:02:35,920
remember back in 2014

00:02:33,040 --> 00:02:36,800
we had a talk by dr brown sorry not that

00:02:35,920 --> 00:02:40,160
dr brown

00:02:36,800 --> 00:02:41,840
uh this dr brown um and uh he gave a

00:02:40,160 --> 00:02:45,120
great tutorial talk on c

00:02:41,840 --> 00:02:48,080
plus plus template meta programming uh

00:02:45,120 --> 00:02:50,080
a compendium and actually if you only

00:02:48,080 --> 00:02:53,040
have two hours of your life to spend

00:02:50,080 --> 00:02:55,040
on c plus template related stuff then

00:02:53,040 --> 00:02:56,959
you should go ahead and log off and go

00:02:55,040 --> 00:02:59,519
watch those two hours because they're

00:02:56,959 --> 00:03:01,760
great talks in fact i've i've considered

00:02:59,519 --> 00:03:03,840
them mandatory viewing for anybody that

00:03:01,760 --> 00:03:05,440
uh that i work with or anybody that

00:03:03,840 --> 00:03:09,280
really wants to take uh

00:03:05,440 --> 00:03:11,120
c plus plus seriously at all um

00:03:09,280 --> 00:03:13,519
but uh so this is supposed to be a

00:03:11,120 --> 00:03:14,879
tutorial uh he uh dr brown explicitly

00:03:13,519 --> 00:03:16,480
said he wasn't really

00:03:14,879 --> 00:03:18,080
um that it was probably gonna be over

00:03:16,480 --> 00:03:20,480
for

00:03:18,080 --> 00:03:22,560
novices and i hope to i hope to be able

00:03:20,480 --> 00:03:24,319
to bring novices along at some speed you

00:03:22,560 --> 00:03:27,519
still have to understand

00:03:24,319 --> 00:03:29,519
some templates uh syntax but hopefully

00:03:27,519 --> 00:03:32,560
we'll have a lower barrier to entry

00:03:29,519 --> 00:03:33,040
and learn how to implement and how to

00:03:32,560 --> 00:03:35,360
use

00:03:33,040 --> 00:03:36,799
uh the type traits in particular um so

00:03:35,360 --> 00:03:38,400
we'll explore those

00:03:36,799 --> 00:03:40,640
and uh focus on techniques for

00:03:38,400 --> 00:03:41,840
implementing them uh hopefully remove

00:03:40,640 --> 00:03:43,599
some of the mystique that still

00:03:41,840 --> 00:03:47,280
surrounds template meta programming

00:03:43,599 --> 00:03:47,840
um and uh um get some practical advice

00:03:47,280 --> 00:03:49,760
from

00:03:47,840 --> 00:03:51,120
what i consider a regular user i'm just

00:03:49,760 --> 00:03:53,360
you know a regular joe

00:03:51,120 --> 00:03:54,640
or maybe a regular jody but you know i'm

00:03:53,360 --> 00:03:56,799
just a regular user

00:03:54,640 --> 00:03:58,959
and uh but i've been using for a long

00:03:56,799 --> 00:04:00,319
time and i've been and i've worked with

00:03:58,959 --> 00:04:03,680
people for a long time

00:04:00,319 --> 00:04:05,439
using these techniques so

00:04:03,680 --> 00:04:07,200
hopefully we can readily use the

00:04:05,439 --> 00:04:07,760
standard set and maybe even implement

00:04:07,200 --> 00:04:10,239
your own

00:04:07,760 --> 00:04:12,000
when the time comes so amount of

00:04:10,239 --> 00:04:12,400
programming in general is when programs

00:04:12,000 --> 00:04:15,920
treat

00:04:12,400 --> 00:04:18,000
other programs as data it could be

00:04:15,920 --> 00:04:20,160
other programs or it could be their own

00:04:18,000 --> 00:04:21,919
program it could be a compile time or it

00:04:20,160 --> 00:04:23,919
could be at run time

00:04:21,919 --> 00:04:25,040
now i know i know you might not consider

00:04:23,919 --> 00:04:27,120
this meta programming

00:04:25,040 --> 00:04:28,160
but this was the very first book that i

00:04:27,120 --> 00:04:30,000
ever had

00:04:28,160 --> 00:04:31,520
that i did something that i considered

00:04:30,000 --> 00:04:33,199
meta programming okay

00:04:31,520 --> 00:04:36,680
this is jim copeland's advanced c plus

00:04:33,199 --> 00:04:39,040
plus idioms from back in

00:04:36,680 --> 00:04:42,560
1992 i believe

00:04:39,040 --> 00:04:43,440
um and that in that book i learned how

00:04:42,560 --> 00:04:47,199
to

00:04:43,440 --> 00:04:48,960
okay dynamically load shared objects

00:04:47,199 --> 00:04:49,520
that have been compiled with new virtual

00:04:48,960 --> 00:04:52,639
tables

00:04:49,520 --> 00:04:54,560
and replace the virtual tables

00:04:52,639 --> 00:04:55,840
from active objects while the system was

00:04:54,560 --> 00:04:56,800
running because we were supposed to have

00:04:55,840 --> 00:05:00,400
a 99

00:04:56,800 --> 00:05:02,880
up time and so to me i was using

00:05:00,400 --> 00:05:04,800
program as data it's not really matter

00:05:02,880 --> 00:05:06,479
programming but i wanted to give copelan

00:05:04,800 --> 00:05:08,479
a shout out there because i love his

00:05:06,479 --> 00:05:11,840
book that that was it's a great book

00:05:08,479 --> 00:05:13,280
um and and that technique even way back

00:05:11,840 --> 00:05:16,560
then it's kind of like a run

00:05:13,280 --> 00:05:21,120
thing um so what we'll do here

00:05:16,560 --> 00:05:25,280
is um is get more compile-time stuff

00:05:21,120 --> 00:05:27,759
for example andre alexandrescu blew my

00:05:25,280 --> 00:05:31,120
mind back in 2001.

00:05:27,759 --> 00:05:34,240
um then we had this book

00:05:31,120 --> 00:05:35,919
in 2002 i believe and then this one in

00:05:34,240 --> 00:05:39,280
00:05:35,919 --> 00:05:41,120
okay now the thing is

00:05:39,280 --> 00:05:42,639
is that these are all older type

00:05:41,120 --> 00:05:43,280
techniques but there's a lot of people

00:05:42,639 --> 00:05:45,120
that still

00:05:43,280 --> 00:05:47,039
don't understand them and this and the

00:05:45,120 --> 00:05:50,000
type traits themselves are focused quite

00:05:47,039 --> 00:05:50,000
heavily upon them

00:05:50,840 --> 00:05:55,680
um

00:05:52,560 --> 00:05:56,880
so uh what uh i see a question here what

00:05:55,680 --> 00:05:59,520
do i think is the most

00:05:56,880 --> 00:06:01,840
steep barrier to entry in tmp i think

00:05:59,520 --> 00:06:05,199
the hardest thing to grasp in general

00:06:01,840 --> 00:06:08,319
um for newer people is that it's a

00:06:05,199 --> 00:06:09,680
it's kind of a paradigm shift um there's

00:06:08,319 --> 00:06:11,360
been a lot of work lately to try and

00:06:09,680 --> 00:06:13,600
make meta programming more

00:06:11,360 --> 00:06:15,520
look like regular functional programming

00:06:13,600 --> 00:06:17,280
um and louis dion has done some great

00:06:15,520 --> 00:06:17,919
work in that in that regards of other

00:06:17,280 --> 00:06:19,680
people

00:06:17,919 --> 00:06:22,080
but in general when you start dealing

00:06:19,680 --> 00:06:24,560
with types and using types as data

00:06:22,080 --> 00:06:25,520
that's just a new paradigm for people um

00:06:24,560 --> 00:06:27,840
lisp had

00:06:25,520 --> 00:06:29,759
uh meta programming built in as a as you

00:06:27,840 --> 00:06:30,319
know first priority as as part of the

00:06:29,759 --> 00:06:33,039
language

00:06:30,319 --> 00:06:34,000
but c plus uh really didn't and uh

00:06:33,039 --> 00:06:36,000
people coming to it really

00:06:34,000 --> 00:06:38,080
have a hard time with just that concept

00:06:36,000 --> 00:06:38,880
in general and so they tend to shy away

00:06:38,080 --> 00:06:42,240
from that

00:06:38,880 --> 00:06:44,400
um that that i found

00:06:42,240 --> 00:06:45,520
so we'll discuss a wide array of

00:06:44,400 --> 00:06:48,400
techniques

00:06:45,520 --> 00:06:50,080
um and uh in this tutorial hopefully

00:06:48,400 --> 00:06:51,039
i'll shed some light on some of these uh

00:06:50,080 --> 00:06:52,800
idioms

00:06:51,039 --> 00:06:55,120
so why should we care about this in

00:06:52,800 --> 00:06:58,080
general and type traits in particular

00:06:55,120 --> 00:06:59,840
uh look at this right here in 2000 is

00:06:58,080 --> 00:07:01,199
when type traits came about so

00:06:59,840 --> 00:07:03,039
it's not like i'm going to be even

00:07:01,199 --> 00:07:03,759
talking about new whizzy banging things

00:07:03,039 --> 00:07:06,319
today

00:07:03,759 --> 00:07:07,199
um if you're new to c plus or if you're

00:07:06,319 --> 00:07:08,560
new to

00:07:07,199 --> 00:07:10,560
meta programming or if you're new to

00:07:08,560 --> 00:07:12,160
type trades then this will be a great

00:07:10,560 --> 00:07:13,919
introduction for you but

00:07:12,160 --> 00:07:15,120
um if you've been around for a while

00:07:13,919 --> 00:07:15,680
you've probably used these things

00:07:15,120 --> 00:07:19,360
because

00:07:15,680 --> 00:07:19,360
they've been around since 2000

00:07:19,520 --> 00:07:22,960
but each new standard library employs

00:07:21,680 --> 00:07:24,560
more and more meta programming

00:07:22,960 --> 00:07:26,160
techniques

00:07:24,560 --> 00:07:27,520
and some requirements are impossible

00:07:26,160 --> 00:07:28,319
without some advanced techniques for

00:07:27,520 --> 00:07:30,160
example

00:07:28,319 --> 00:07:32,319
the overload set selection explicit

00:07:30,160 --> 00:07:33,919
versus implicit construction triviality

00:07:32,319 --> 00:07:35,919
those types of things instead optional

00:07:33,919 --> 00:07:36,720
be impossible uh without these uh

00:07:35,919 --> 00:07:38,560
techniques

00:07:36,720 --> 00:07:39,919
um furthermore like the tools have

00:07:38,560 --> 00:07:42,720
advanced um

00:07:39,919 --> 00:07:44,080
meta programming have become so good so

00:07:42,720 --> 00:07:45,520
easy to understand

00:07:44,080 --> 00:07:48,240
that they're no longer limited to the

00:07:45,520 --> 00:07:51,039
realms of stl and boost developers

00:07:48,240 --> 00:07:51,520
um and they've advanced to the point

00:07:51,039 --> 00:07:53,280
where

00:07:51,520 --> 00:07:55,039
all c plus programmers should at least

00:07:53,280 --> 00:07:56,879
understand the basics and if you're

00:07:55,039 --> 00:07:57,840
developing a library that other people

00:07:56,879 --> 00:07:59,199
are going to use even if it's just

00:07:57,840 --> 00:08:00,639
internal to your company

00:07:59,199 --> 00:08:02,879
then you should understand probably a

00:08:00,639 --> 00:08:05,039
good bit more c plus plus 20

00:08:02,879 --> 00:08:06,560
has concepts and independent requires

00:08:05,039 --> 00:08:08,000
expressions and when you start looking

00:08:06,560 --> 00:08:09,840
at those you'll see that

00:08:08,000 --> 00:08:11,680
the that even those basic require

00:08:09,840 --> 00:08:13,840
clauses are built upon

00:08:11,680 --> 00:08:15,280
the basic concepts are built upon the

00:08:13,840 --> 00:08:18,479
ideas from the

00:08:15,280 --> 00:08:21,120
the type traits themselves um

00:08:18,479 --> 00:08:22,000
so they'll have two talks intended as a

00:08:21,120 --> 00:08:24,400
tutorial

00:08:22,000 --> 00:08:26,160
um hopefully focused on techniques

00:08:24,400 --> 00:08:26,560
related to standard type trick classes

00:08:26,160 --> 00:08:29,280
not

00:08:26,560 --> 00:08:30,720
necessarily general and not necessarily

00:08:29,280 --> 00:08:34,399
the general population

00:08:30,720 --> 00:08:35,279
um and uh um it's a beginner kind of

00:08:34,399 --> 00:08:37,200
tutorial

00:08:35,279 --> 00:08:39,120
uh there's a lot of templates for

00:08:37,200 --> 00:08:39,680
beginners at this talk i encourage you

00:08:39,120 --> 00:08:42,719
to

00:08:39,680 --> 00:08:44,399
look at andre's talk tomorrow um he has

00:08:42,719 --> 00:08:45,440
two talks on templates in the back to

00:08:44,399 --> 00:08:47,760
basics

00:08:45,440 --> 00:08:48,800
program and there will be lots of small

00:08:47,760 --> 00:08:50,399
code examples

00:08:48,800 --> 00:08:52,160
uh i tried to make the fonts big enough

00:08:50,399 --> 00:08:54,560
hopefully you'll see them

00:08:52,160 --> 00:08:56,399
a number of special considerations um

00:08:54,560 --> 00:08:59,440
about types

00:08:56,399 --> 00:09:01,360
um to write programs where your data is

00:08:59,440 --> 00:09:02,320
tight you need to consider a lot about

00:09:01,360 --> 00:09:04,240
the type system

00:09:02,320 --> 00:09:06,320
the type system is a little bit finicky

00:09:04,240 --> 00:09:08,560
and so you or

00:09:06,320 --> 00:09:10,320
our mental model of the type system can

00:09:08,560 --> 00:09:13,279
be finicky the type system actually is

00:09:10,320 --> 00:09:14,320
is quite robust um and i'll try to

00:09:13,279 --> 00:09:16,240
answer periodically

00:09:14,320 --> 00:09:17,839
uh questions periodically um so the

00:09:16,240 --> 00:09:21,519
first thing we want to talk about is

00:09:17,839 --> 00:09:22,480
meta functions um a traditional meta

00:09:21,519 --> 00:09:24,480
functions

00:09:22,480 --> 00:09:25,839
ha our traditional functions have zero

00:09:24,480 --> 00:09:29,040
parameters

00:09:25,839 --> 00:09:31,200
um or more and they have a return value

00:09:29,040 --> 00:09:32,399
or void similar to what we see right

00:09:31,200 --> 00:09:34,880
here

00:09:32,399 --> 00:09:36,240
um now the mechanism for returning a

00:09:34,880 --> 00:09:38,800
value from a function

00:09:36,240 --> 00:09:40,480
is the return statement the compiler can

00:09:38,800 --> 00:09:42,160
actually enforce this

00:09:40,480 --> 00:09:43,680
uh the compiler can enforce how you

00:09:42,160 --> 00:09:45,200
return what you return and whether

00:09:43,680 --> 00:09:46,399
you've returned or not when you said you

00:09:45,200 --> 00:09:48,880
were going to

00:09:46,399 --> 00:09:50,399
um there's really no alternative we have

00:09:48,880 --> 00:09:53,440
out parameters but other than that

00:09:50,399 --> 00:09:56,480
there's really no alternative to returns

00:09:53,440 --> 00:10:00,080
a meta function is not a function

00:09:56,480 --> 00:10:01,760
it's a class a struct i'll probably use

00:10:00,080 --> 00:10:02,399
those two interchangeably understanding

00:10:01,760 --> 00:10:05,760
that there's

00:10:02,399 --> 00:10:07,519
actually a subtle difference and

00:10:05,760 --> 00:10:09,680
since meta functions are not part of the

00:10:07,519 --> 00:10:11,279
language themselves they have no formal

00:10:09,680 --> 00:10:14,399
language support

00:10:11,279 --> 00:10:18,640
they exist purely as an idiomatic use

00:10:14,399 --> 00:10:20,959
of the existing language features now

00:10:18,640 --> 00:10:22,160
they're since their use is not enforced

00:10:20,959 --> 00:10:23,839
by the language

00:10:22,160 --> 00:10:25,279
their use has to be dictated by

00:10:23,839 --> 00:10:28,560
something and that dick

00:10:25,279 --> 00:10:30,000
that that something is our conventions

00:10:28,560 --> 00:10:31,920
now over the years the c plus plus

00:10:30,000 --> 00:10:33,920
community has created a common set of

00:10:31,920 --> 00:10:37,040
standard conventions

00:10:33,920 --> 00:10:38,959
and actually those conventions really um

00:10:37,040 --> 00:10:40,160
hearken back to the work that the guys

00:10:38,959 --> 00:10:42,480
did on the boost

00:10:40,160 --> 00:10:43,600
type traits most of the conventions that

00:10:42,480 --> 00:10:46,240
we have now

00:10:43,600 --> 00:10:46,640
come pretty much directly from from from

00:10:46,240 --> 00:10:49,120
the

00:10:46,640 --> 00:10:49,120
that work

00:10:51,200 --> 00:10:58,320
now meta functions are

00:10:54,959 --> 00:11:00,079
not functions they're classes um

00:10:58,320 --> 00:11:02,000
and technically a class with zero or

00:11:00,079 --> 00:11:03,360
more template parameters and zero or

00:11:02,000 --> 00:11:06,640
more return types

00:11:03,360 --> 00:11:08,320
and values um the convention is that a

00:11:06,640 --> 00:11:09,040
meta function should return just one

00:11:08,320 --> 00:11:12,160
thing

00:11:09,040 --> 00:11:13,680
uh just like a regular function um

00:11:12,160 --> 00:11:15,360
and the convention was developed over

00:11:13,680 --> 00:11:16,480
time so there's there's plenty of things

00:11:15,360 --> 00:11:18,399
that you'll see

00:11:16,480 --> 00:11:19,760
uh in the wild and in the standard

00:11:18,399 --> 00:11:20,880
library and there's plenty of type

00:11:19,760 --> 00:11:22,240
traits and things that you'll see that

00:11:20,880 --> 00:11:23,680
you'll wonder about these meta function

00:11:22,240 --> 00:11:24,320
things that don't necessarily follow

00:11:23,680 --> 00:11:25,920
this convention

00:11:24,320 --> 00:11:28,079
a lot of times it's because it was

00:11:25,920 --> 00:11:29,680
before the convention was formalized

00:11:28,079 --> 00:11:31,440
and so there was a lot of competing

00:11:29,680 --> 00:11:32,560
things just like there's competing

00:11:31,440 --> 00:11:35,440
standards

00:11:32,560 --> 00:11:37,120
um more modern meta functions do follow

00:11:35,440 --> 00:11:38,240
this convention however

00:11:37,120 --> 00:11:40,560
and we're going to follow that

00:11:38,240 --> 00:11:41,680
convention so how do we return from a

00:11:40,560 --> 00:11:44,079
meta function

00:11:41,680 --> 00:11:45,200
well if you're going to return a value

00:11:44,079 --> 00:11:48,640
basically we're going to

00:11:45,200 --> 00:11:52,160
expose a public value named

00:11:48,640 --> 00:11:54,560
value and if we're going to

00:11:52,160 --> 00:11:56,000
have a type based meta function we're

00:11:54,560 --> 00:11:59,440
going to expose a public

00:11:56,000 --> 00:12:01,519
type named type now here's where we get

00:11:59,440 --> 00:12:03,839
kind of a difference between the

00:12:01,519 --> 00:12:06,320
concepts of regular functions and

00:12:03,839 --> 00:12:07,200
meta functions a regular function always

00:12:06,320 --> 00:12:09,680
works in c

00:12:07,200 --> 00:12:11,279
plus on some form of data and it's

00:12:09,680 --> 00:12:12,800
always going to return to you some piece

00:12:11,279 --> 00:12:14,720
of data

00:12:12,800 --> 00:12:16,880
um these meta functions we have value

00:12:14,720 --> 00:12:19,120
meta functions that have

00:12:16,880 --> 00:12:21,120
values like you similar to what you're

00:12:19,120 --> 00:12:21,680
used to and then we have meta functions

00:12:21,120 --> 00:12:24,720
that

00:12:21,680 --> 00:12:25,279
work entirely on types and they yield

00:12:24,720 --> 00:12:28,399
back

00:12:25,279 --> 00:12:29,440
some type to you and so both of those

00:12:28,399 --> 00:12:31,760
are returned through

00:12:29,440 --> 00:12:34,240
exposing these public uh public members

00:12:31,760 --> 00:12:36,720
of a class

00:12:34,240 --> 00:12:38,079
so a value meta function is kind of like

00:12:36,720 --> 00:12:40,720
a simple regular function

00:12:38,079 --> 00:12:41,839
let's look at that one the integer

00:12:40,720 --> 00:12:43,600
identity function

00:12:41,839 --> 00:12:44,880
it's a very simple regular function you

00:12:43,600 --> 00:12:45,680
pass in an integer and it's going to

00:12:44,880 --> 00:12:48,320
spit back

00:12:45,680 --> 00:12:50,160
what you gave it um and a simple meta

00:12:48,320 --> 00:12:50,480
function for identity we'll call this

00:12:50,160 --> 00:12:53,839
the

00:12:50,480 --> 00:12:53,839
int identity meta function

00:12:54,320 --> 00:12:58,480
and we'll see that it's not that much

00:12:57,360 --> 00:13:02,880
different

00:12:58,480 --> 00:13:06,160
you return a value by having a

00:13:02,880 --> 00:13:06,560
static data member called value and it

00:13:06,160 --> 00:13:09,680
has

00:13:06,560 --> 00:13:11,200
its return value you can see with the

00:13:09,680 --> 00:13:13,200
red squares that's where

00:13:11,200 --> 00:13:14,800
the function or the meta function is

00:13:13,200 --> 00:13:17,360
returning its value

00:13:14,800 --> 00:13:19,040
and in the purple is where we are

00:13:17,360 --> 00:13:22,160
getting that value is where we're

00:13:19,040 --> 00:13:22,959
calling the meta function now this

00:13:22,160 --> 00:13:25,040
convention

00:13:22,959 --> 00:13:27,360
needs to be adhered to because if you

00:13:25,040 --> 00:13:29,519
give your meta function some other name

00:13:27,360 --> 00:13:30,959
like my value or you decide to make it

00:13:29,519 --> 00:13:32,959
value with a capital v

00:13:30,959 --> 00:13:34,480
it's not going to work well um with

00:13:32,959 --> 00:13:36,160
others

00:13:34,480 --> 00:13:37,519
so let's look at the generic identity

00:13:36,160 --> 00:13:39,519
function

00:13:37,519 --> 00:13:41,600
this is a just a function that will be

00:13:39,519 --> 00:13:43,519
an identity for any type

00:13:41,600 --> 00:13:46,839
you give me a value of any type and i

00:13:43,519 --> 00:13:49,440
will give you that value back

00:13:46,839 --> 00:13:53,120
um we can create a generic

00:13:49,440 --> 00:13:53,120
identity meta function as well

00:13:58,000 --> 00:14:02,480
um and will well in the generic identity

00:14:01,600 --> 00:14:05,760
meta function

00:14:02,480 --> 00:14:09,120
we see that the value identity

00:14:05,760 --> 00:14:12,160
um is going to return a particular

00:14:09,120 --> 00:14:14,800
type of data now

00:14:12,160 --> 00:14:16,160
this is a little peculiar because we

00:14:14,800 --> 00:14:19,440
have to tell it what

00:14:16,160 --> 00:14:21,519
type we're using this is going to be a

00:14:19,440 --> 00:14:23,519
value identity it's a generic meta

00:14:21,519 --> 00:14:26,160
function but we have to feed it the type

00:14:23,519 --> 00:14:28,240
int and then the value 42 or unsigned

00:14:26,160 --> 00:14:31,199
long long and the value 42.

00:14:28,240 --> 00:14:33,279
it's a bit cumbersome but it's not too

00:14:31,199 --> 00:14:36,880
bad once you get used to it

00:14:33,279 --> 00:14:38,480
now in c plus 17 we get a little bit

00:14:36,880 --> 00:14:40,480
easier value meta functions

00:14:38,480 --> 00:14:41,600
because we have this cool word called

00:14:40,480 --> 00:14:42,800
auto now

00:14:41,600 --> 00:14:44,639
we're not going to discuss all the

00:14:42,800 --> 00:14:46,320
details of auto in this

00:14:44,639 --> 00:14:48,000
uh that's in this template parameter

00:14:46,320 --> 00:14:50,000
this time for now

00:14:48,000 --> 00:14:52,480
it's sufficient to understand that it

00:14:50,000 --> 00:14:56,519
basically means that the template

00:14:52,480 --> 00:14:57,680
will accept and deduce the type of any

00:14:56,519 --> 00:15:00,639
non-type

00:14:57,680 --> 00:15:00,639
template parameter

00:15:00,800 --> 00:15:04,240
yeah i'm squishing a little bit there

00:15:02,880 --> 00:15:04,720
but that's kind of you can kind of think

00:15:04,240 --> 00:15:07,600
of it

00:15:04,720 --> 00:15:08,639
that way and now we have our our value

00:15:07,600 --> 00:15:11,519
meta function

00:15:08,639 --> 00:15:12,240
that is a generic identity function for

00:15:11,519 --> 00:15:14,399
anything

00:15:12,240 --> 00:15:16,160
so there's a question that i saw that

00:15:14,399 --> 00:15:18,000
said can't we consider template aliases

00:15:16,160 --> 00:15:20,240
and variables to be meta functions

00:15:18,000 --> 00:15:21,279
and yes we can and we'll get into that

00:15:20,240 --> 00:15:25,040
in a little later

00:15:21,279 --> 00:15:27,120
um but especially with template aliases

00:15:25,040 --> 00:15:28,160
they always see straight through to

00:15:27,120 --> 00:15:31,120
whatever's there

00:15:28,160 --> 00:15:32,880
so even though it's a template alias to

00:15:31,120 --> 00:15:34,959
us at the language level

00:15:32,880 --> 00:15:36,880
um it's designed specifically to see

00:15:34,959 --> 00:15:38,720
completely through to the very end

00:15:36,880 --> 00:15:41,519
and so whatever it resolves to is going

00:15:38,720 --> 00:15:44,320
to be that so a template a template a

00:15:41,519 --> 00:15:45,600
an alias template is going to end up

00:15:44,320 --> 00:15:48,399
eventually invoking

00:15:45,600 --> 00:15:50,079
a meta function itself i don't know that

00:15:48,399 --> 00:15:54,480
i would consider

00:15:50,079 --> 00:15:56,880
um value of variable templates to be

00:15:54,480 --> 00:15:57,600
uh meta functions themselves some people

00:15:56,880 --> 00:16:01,680
do

00:15:57,600 --> 00:16:03,040
but the variable template um itself

00:16:01,680 --> 00:16:04,880
with the meta function there are certain

00:16:03,040 --> 00:16:06,720
things that you can do because you can

00:16:04,880 --> 00:16:08,399
um with its instantiation and call

00:16:06,720 --> 00:16:09,440
ability and with the variable meta

00:16:08,399 --> 00:16:11,680
function it's kind of like

00:16:09,440 --> 00:16:13,279
caching the result of a called meta

00:16:11,680 --> 00:16:16,959
function

00:16:13,279 --> 00:16:19,440
um so let's look at a sep another value

00:16:16,959 --> 00:16:20,560
regular value function we have sum

00:16:19,440 --> 00:16:23,839
summing two numbers

00:16:20,560 --> 00:16:23,839
here we go x plus y

00:16:24,079 --> 00:16:28,560
we can do this in a regular function and

00:16:26,240 --> 00:16:30,480
we can do it in a reg in a

00:16:28,560 --> 00:16:32,160
value meta function as well we just

00:16:30,480 --> 00:16:32,800
create our struct our template that

00:16:32,160 --> 00:16:34,959
takes two

00:16:32,800 --> 00:16:37,040
integers and we're going to have a value

00:16:34,959 --> 00:16:38,160
that is equal to the sum of those two

00:16:37,040 --> 00:16:40,160
values

00:16:38,160 --> 00:16:41,279
and it's going to have its proper type

00:16:40,160 --> 00:16:42,880
it's going to compute them

00:16:41,279 --> 00:16:44,320
and then we'll be able to grab the value

00:16:42,880 --> 00:16:44,880
just like we do with the regular

00:16:44,320 --> 00:16:50,320
function

00:16:44,880 --> 00:16:52,160
it just looks a little bit different

00:16:50,320 --> 00:16:53,440
so we can also create a generic version

00:16:52,160 --> 00:16:56,320
of this

00:16:53,440 --> 00:16:58,079
um you know we can create we can create

00:16:56,320 --> 00:16:58,399
we have two different types x and y in

00:16:58,079 --> 00:17:00,480
our

00:16:58,399 --> 00:17:02,079
template our function template and it

00:17:00,480 --> 00:17:03,040
can take any of those two types and it

00:17:02,079 --> 00:17:05,439
will add them up

00:17:03,040 --> 00:17:06,640
as long as the the plus operator is

00:17:05,439 --> 00:17:08,640
valid for those two types

00:17:06,640 --> 00:17:10,319
if not then we'll get a compiler error

00:17:08,640 --> 00:17:12,480
similar to the sum

00:17:10,319 --> 00:17:14,000
uh meta function here it takes two

00:17:12,480 --> 00:17:16,720
separate non-type

00:17:14,000 --> 00:17:17,919
template parameters they they can they

00:17:16,720 --> 00:17:18,480
can be different types they can be the

00:17:17,919 --> 00:17:20,720
same

00:17:18,480 --> 00:17:22,480
it'll automatically deduce the return

00:17:20,720 --> 00:17:24,160
type value based on the

00:17:22,480 --> 00:17:25,919
operation that you've that you've

00:17:24,160 --> 00:17:27,360
assigned it now

00:17:25,919 --> 00:17:29,360
it's a good time to note that i use a

00:17:27,360 --> 00:17:31,919
number of very simple examples

00:17:29,360 --> 00:17:33,600
purely for pedagogical reasons um and as

00:17:31,919 --> 00:17:35,120
such there may be

00:17:33,600 --> 00:17:36,720
much better code alternatives in

00:17:35,120 --> 00:17:37,760
production code and in many examples you

00:17:36,720 --> 00:17:40,480
may find other

00:17:37,760 --> 00:17:41,120
other alternatives for example even

00:17:40,480 --> 00:17:44,160
right here

00:17:41,120 --> 00:17:45,360
we could make a context for function and

00:17:44,160 --> 00:17:46,480
that function could be constant

00:17:45,360 --> 00:17:47,919
experience we could just use that

00:17:46,480 --> 00:17:48,480
instead of using the meta function at

00:17:47,919 --> 00:17:51,200
all

00:17:48,480 --> 00:17:53,440
and if constexpr was around many years

00:17:51,200 --> 00:17:55,039
ago we might not have the same

00:17:53,440 --> 00:17:56,799
we probably wouldn't have the same stuff

00:17:55,039 --> 00:17:58,080
that we have now but we do have these

00:17:56,799 --> 00:17:59,360
meta functions and

00:17:58,080 --> 00:18:01,520
and the meta the value amount of

00:17:59,360 --> 00:18:04,000
functions as classes do have their place

00:18:01,520 --> 00:18:06,160
just like in your code you write regular

00:18:04,000 --> 00:18:09,600
functions and you write function objects

00:18:06,160 --> 00:18:10,720
that um that you use to curry other

00:18:09,600 --> 00:18:13,280
information or

00:18:10,720 --> 00:18:13,840
for other whatever reasons you have so

00:18:13,280 --> 00:18:15,840
even though

00:18:13,840 --> 00:18:17,440
even the even with constexpr the value

00:18:15,840 --> 00:18:18,240
meta functions do have do still have

00:18:17,440 --> 00:18:21,360
their place

00:18:18,240 --> 00:18:22,000
um in our in our design now as i said

00:18:21,360 --> 00:18:23,520
the type

00:18:22,000 --> 00:18:25,840
meta functions though is kind of the

00:18:23,520 --> 00:18:28,400
workhorse um

00:18:25,840 --> 00:18:29,520
of of doing data of doing uh type

00:18:28,400 --> 00:18:31,760
manipulation

00:18:29,520 --> 00:18:34,240
um you can you can you can manipulate

00:18:31,760 --> 00:18:37,280
types with regular functions through

00:18:34,240 --> 00:18:38,480
um proxy objects and especially with all

00:18:37,280 --> 00:18:40,240
the context for stuff

00:18:38,480 --> 00:18:41,679
but in general type meta functions are

00:18:40,240 --> 00:18:44,480
going to just return

00:18:41,679 --> 00:18:45,200
a type here's our type identity just

00:18:44,480 --> 00:18:48,080
like we had

00:18:45,200 --> 00:18:50,080
our value identity we had a value

00:18:48,080 --> 00:18:51,520
identity that you feed it a value

00:18:50,080 --> 00:18:53,200
give it any value it's going to give you

00:18:51,520 --> 00:18:54,640
that value back well this one you give

00:18:53,200 --> 00:18:55,280
it any type and it's going to give you

00:18:54,640 --> 00:18:59,280
that type

00:18:55,280 --> 00:19:01,280
back c plus 20 actually introduces

00:18:59,280 --> 00:19:03,039
um stood type identity which is pretty

00:19:01,280 --> 00:19:03,520
much uh what you see on your screen

00:19:03,039 --> 00:19:06,559
there

00:19:03,520 --> 00:19:09,440
except for the uh the spelling of

00:19:06,559 --> 00:19:09,440
camel case and stuff

00:19:09,600 --> 00:19:15,840
so calling type meta functions

00:19:13,440 --> 00:19:16,960
when we call a value meta function we

00:19:15,840 --> 00:19:19,919
can easily

00:19:16,960 --> 00:19:20,559
just call the function i'm going to try

00:19:19,919 --> 00:19:22,320
this here

00:19:20,559 --> 00:19:24,000
we can easily just call the there's the

00:19:22,320 --> 00:19:26,240
function there's the meta

00:19:24,000 --> 00:19:27,200
function there's its parameters consider

00:19:26,240 --> 00:19:29,600
it just like the

00:19:27,200 --> 00:19:31,440
light parentheses there's the meta

00:19:29,600 --> 00:19:34,720
function there's its parameters

00:19:31,440 --> 00:19:38,320
and here's how i get its value back when

00:19:34,720 --> 00:19:40,559
i call one with a type it's the same way

00:19:38,320 --> 00:19:43,039
there's my function there's my meta

00:19:40,559 --> 00:19:45,520
function there's my parameters

00:19:43,039 --> 00:19:46,799
and this is how i get my result now this

00:19:45,520 --> 00:19:50,720
is kind of clunky

00:19:46,799 --> 00:19:52,400
um but it's it's it's not too bad

00:19:50,720 --> 00:19:54,160
until you start getting into what we

00:19:52,400 --> 00:19:56,320
call dependent types

00:19:54,160 --> 00:19:58,400
and then we have to do what i call the

00:19:56,320 --> 00:20:01,200
type name dance

00:19:58,400 --> 00:20:01,760
so in this case and i'm not going to get

00:20:01,200 --> 00:20:05,760
into it

00:20:01,760 --> 00:20:08,880
entirely here but that t

00:20:05,760 --> 00:20:10,720
if that is not an explicitly known and

00:20:08,880 --> 00:20:14,400
bound type

00:20:10,720 --> 00:20:17,760
then the value of type

00:20:14,400 --> 00:20:20,880
is going to be dependent upon what

00:20:17,760 --> 00:20:23,039
t is remember these are templates

00:20:20,880 --> 00:20:25,440
you could specialize it somebody could

00:20:23,039 --> 00:20:27,120
have a variable that is named type

00:20:25,440 --> 00:20:28,640
they could have an enum that's named

00:20:27,120 --> 00:20:29,440
type they could have anything that's

00:20:28,640 --> 00:20:31,360
named type

00:20:29,440 --> 00:20:32,799
and the compiler doesn't know yet what

00:20:31,360 --> 00:20:36,480
it's going to see

00:20:32,799 --> 00:20:39,679
so when it comes across this expression

00:20:36,480 --> 00:20:40,960
and the and the type is dependent upon

00:20:39,679 --> 00:20:43,120
the template parameter

00:20:40,960 --> 00:20:44,640
and it can't determine what's there it

00:20:43,120 --> 00:20:47,760
has to make a guess

00:20:44,640 --> 00:20:48,000
and the rules say that if the compiler

00:20:47,760 --> 00:20:50,240
does

00:20:48,000 --> 00:20:52,000
not know exactly what colon colon type

00:20:50,240 --> 00:20:55,360
will be

00:20:52,000 --> 00:20:56,799
then it in order to have the compiler

00:20:55,360 --> 00:21:00,080
treated as a type you

00:20:56,799 --> 00:21:02,640
must give it type name so

00:21:00,080 --> 00:21:04,720
anytime the compiler does not know what

00:21:02,640 --> 00:21:06,880
colon colon type is

00:21:04,720 --> 00:21:07,919
you must give it type name if you want

00:21:06,880 --> 00:21:09,520
it treated as a type

00:21:07,919 --> 00:21:11,120
otherwise the compiler will not treat it

00:21:09,520 --> 00:21:11,679
as a type and we're doing type meta

00:21:11,120 --> 00:21:14,720
functions

00:21:11,679 --> 00:21:17,200
so we want to treat these as types well

00:21:14,720 --> 00:21:17,760
we end up with some calling convenience

00:21:17,200 --> 00:21:21,120
uh

00:21:17,760 --> 00:21:23,840
uh things here so for example

00:21:21,120 --> 00:21:24,559
our value meta functions use variable

00:21:23,840 --> 00:21:27,520
templates

00:21:24,559 --> 00:21:28,559
ending with an underscore v so for

00:21:27,520 --> 00:21:34,400
example

00:21:28,559 --> 00:21:36,320
um we have a value identity

00:21:34,400 --> 00:21:37,679
in order to call this meta function

00:21:36,320 --> 00:21:39,600
value identity

00:21:37,679 --> 00:21:42,640
i'm going to call value identity with a

00:21:39,600 --> 00:21:46,960
42 and i'm going to get its value back

00:21:42,640 --> 00:21:49,440
well i can do the exact same thing by

00:21:46,960 --> 00:21:51,440
invoking this variable template this

00:21:49,440 --> 00:21:52,799
variable template value identity

00:21:51,440 --> 00:21:56,159
underscore v

00:21:52,799 --> 00:21:58,559
is means this exact same thing

00:21:56,159 --> 00:21:59,600
because it's taking the value identity

00:21:58,559 --> 00:22:01,840
meta function

00:21:59,600 --> 00:22:03,200
calling it with the parameter x and

00:22:01,840 --> 00:22:05,840
grabbing its value

00:22:03,200 --> 00:22:07,280
and it's storing it into this variable

00:22:05,840 --> 00:22:09,280
this variable template

00:22:07,280 --> 00:22:10,559
i mean storing it means it's going to be

00:22:09,280 --> 00:22:11,520
available at runtime which isn't

00:22:10,559 --> 00:22:14,720
necessarily true

00:22:11,520 --> 00:22:16,320
but you get one of you get the idea so

00:22:14,720 --> 00:22:18,240
this is a convenient way of calling

00:22:16,320 --> 00:22:20,640
value meta functions

00:22:18,240 --> 00:22:21,440
it does require you to instantiate an

00:22:20,640 --> 00:22:24,799
extra

00:22:21,440 --> 00:22:26,640
variable template now

00:22:24,799 --> 00:22:28,240
it's really helpful when we start using

00:22:26,640 --> 00:22:30,320
it with types because we use

00:22:28,240 --> 00:22:32,159
underscore t and it helps us get rid of

00:22:30,320 --> 00:22:34,159
the whole entire type name dance

00:22:32,159 --> 00:22:35,200
because you can see instead of doing

00:22:34,159 --> 00:22:36,640
this

00:22:35,200 --> 00:22:38,480
calling the meta calling the meta

00:22:36,640 --> 00:22:39,600
function with its parameter to get its

00:22:38,480 --> 00:22:42,320
value

00:22:39,600 --> 00:22:44,640
and adding the type name i can just call

00:22:42,320 --> 00:22:47,840
them at a function with underscore t

00:22:44,640 --> 00:22:47,840
and with its parameters

00:22:48,559 --> 00:22:52,720
these calling conventions are easier to

00:22:50,799 --> 00:22:55,120
use

00:22:52,720 --> 00:22:55,919
but each one must be explicitly

00:22:55,120 --> 00:22:59,200
handwritten

00:22:55,919 --> 00:23:02,159
so every time you write a meta function

00:22:59,200 --> 00:23:02,720
if you want to provide the convenience

00:23:02,159 --> 00:23:05,919
uh

00:23:02,720 --> 00:23:09,280
capabilities you also have to write

00:23:05,919 --> 00:23:10,320
the convenience alias template or

00:23:09,280 --> 00:23:12,080
variable template

00:23:10,320 --> 00:23:13,440
there's a meta convention to get around

00:23:12,080 --> 00:23:16,480
that which i may get to

00:23:13,440 --> 00:23:18,159
later but it depends on template

00:23:16,480 --> 00:23:19,760
parameter template template parameters

00:23:18,159 --> 00:23:22,799
which is probably a little bit

00:23:19,760 --> 00:23:24,320
advanced for this minute

00:23:22,799 --> 00:23:26,559
um let me see what we have questions

00:23:24,320 --> 00:23:26,559
here

00:23:26,799 --> 00:23:30,480
how can we combine meta functions and

00:23:28,799 --> 00:23:33,440
concepts that's interesting

00:23:30,480 --> 00:23:35,440
they combine very well in fact a lot of

00:23:33,440 --> 00:23:36,000
the core concepts are just simply

00:23:35,440 --> 00:23:39,440
defined

00:23:36,000 --> 00:23:42,799
as um concept integral

00:23:39,440 --> 00:23:44,960
equals stood is integral type

00:23:42,799 --> 00:23:46,320
right um so a lot of them are actually

00:23:44,960 --> 00:23:49,440
defined as

00:23:46,320 --> 00:23:51,679
as the the the types themselves

00:23:49,440 --> 00:23:52,559
um if colon colon type is not treated as

00:23:51,679 --> 00:23:55,600
a type

00:23:52,559 --> 00:23:57,919
what can it be treated as anything

00:23:55,600 --> 00:23:59,600
um it's it says it doesn't know what it

00:23:57,919 --> 00:24:01,200
is and so it's not going to treat it as

00:23:59,600 --> 00:24:02,159
a type because it doesn't know and so

00:24:01,200 --> 00:24:03,679
you're going to get in you're going to

00:24:02,159 --> 00:24:05,679
get a compiler error

00:24:03,679 --> 00:24:06,799
because it doesn't know what's there and

00:24:05,679 --> 00:24:08,960
it will actually and now

00:24:06,799 --> 00:24:10,720
back in the old days it the compiler

00:24:08,960 --> 00:24:12,000
just you know groked on you and you had

00:24:10,720 --> 00:24:13,679
to figure out what's going on and now

00:24:12,000 --> 00:24:15,840
the compiler error messages are so much

00:24:13,679 --> 00:24:16,880
better in just about every compiler and

00:24:15,840 --> 00:24:18,880
it'll tell you

00:24:16,880 --> 00:24:20,240
you know hey maybe you need to put maybe

00:24:18,880 --> 00:24:21,679
you're missing a type name there

00:24:20,240 --> 00:24:24,640
if you put a type name there then i'll

00:24:21,679 --> 00:24:26,000
interpret it as a type

00:24:24,640 --> 00:24:28,400
how is using auto in the template

00:24:26,000 --> 00:24:30,880
parameter list different from using

00:24:28,400 --> 00:24:33,279
type name with class template argument

00:24:30,880 --> 00:24:37,039
deduction

00:24:33,279 --> 00:24:40,080
template parameter list type name class

00:24:37,039 --> 00:24:42,240
induction um yeah so

00:24:40,080 --> 00:24:43,919
so i i really don't want to get into too

00:24:42,240 --> 00:24:44,559
many of those details there because it's

00:24:43,919 --> 00:24:47,919
kind of

00:24:44,559 --> 00:24:50,400
but the auto in the template parameter

00:24:47,919 --> 00:24:51,919
is telling it's a non-type template

00:24:50,400 --> 00:24:53,360
parameter and it's telling it if you

00:24:51,919 --> 00:24:56,559
pass me a non-type

00:24:53,360 --> 00:24:58,880
a bool or an int or a long or or

00:24:56,559 --> 00:25:00,400
an enum you pass me one of those i'm

00:24:58,880 --> 00:25:01,919
going to automatically determine which

00:25:00,400 --> 00:25:03,919
one it is and i'm going to know what

00:25:01,919 --> 00:25:07,120
that what the type of that data value

00:25:03,919 --> 00:25:08,720
is and that way it'll automatically

00:25:07,120 --> 00:25:09,360
it'll automatically determine that for

00:25:08,720 --> 00:25:11,279
you

00:25:09,360 --> 00:25:14,320
um and you don't have to you don't have

00:25:11,279 --> 00:25:17,440
to specify that

00:25:14,320 --> 00:25:19,919
okay that was actually a good place that

00:25:17,440 --> 00:25:22,960
was actually a good place to do those

00:25:19,919 --> 00:25:25,200
because now we're going to get into um a

00:25:22,960 --> 00:25:27,120
very useful meta function probably the

00:25:25,200 --> 00:25:32,480
most useful meta function

00:25:27,120 --> 00:25:34,080
um integral constant

00:25:32,480 --> 00:25:36,960
now this is what integral constant looks

00:25:34,080 --> 00:25:39,279
like so take it it's bigger than

00:25:36,960 --> 00:25:42,159
anything we've seen so far but take a

00:25:39,279 --> 00:25:44,720
look at it and

00:25:42,159 --> 00:25:46,559
we'll see it's got a value so it's a

00:25:44,720 --> 00:25:48,799
value meta function which kind of makes

00:25:46,559 --> 00:25:50,880
sense it says it's an integral constant

00:25:48,799 --> 00:25:52,720
and we see up top that we've got the

00:25:50,880 --> 00:25:54,720
class t and the tv

00:25:52,720 --> 00:25:56,480
i mean i copied this directly out of the

00:25:54,720 --> 00:25:59,120
out of the standard i believe

00:25:56,480 --> 00:26:00,400
i copied it directly out of i copied it

00:25:59,120 --> 00:26:02,640
directly from somewhere because i wanted

00:26:00,400 --> 00:26:04,960
didn't want to get it wrong but it's got

00:26:02,640 --> 00:26:08,720
a value

00:26:04,960 --> 00:26:11,440
but it also has type so it's actually

00:26:08,720 --> 00:26:11,760
it's it's a it's a value meta function

00:26:11,440 --> 00:26:13,919
but

00:26:11,760 --> 00:26:15,840
having it be a type meta function as

00:26:13,919 --> 00:26:18,000
well in fact it's a type

00:26:15,840 --> 00:26:20,400
meta function that is an identity meta

00:26:18,000 --> 00:26:22,320
function it'll tell you exactly what the

00:26:20,400 --> 00:26:27,120
integral constant thing is

00:26:22,320 --> 00:26:27,120
and then it also has the value type

00:26:27,440 --> 00:26:32,400
the type of the value that's there and

00:26:30,240 --> 00:26:35,200
this right here is an implicit cast

00:26:32,400 --> 00:26:37,039
so if i have an instance of an integral

00:26:35,200 --> 00:26:37,679
constant i mean an intercom it's just a

00:26:37,039 --> 00:26:39,679
class

00:26:37,679 --> 00:26:41,760
it has no data you can create these

00:26:39,679 --> 00:26:42,559
things and pass them around and do math

00:26:41,760 --> 00:26:45,360
with them

00:26:42,559 --> 00:26:46,720
um i compile you can do all kinds of

00:26:45,360 --> 00:26:46,960
stuff with them but this right here is

00:26:46,720 --> 00:26:50,240
an

00:26:46,960 --> 00:26:52,080
integral cast so if you want

00:26:50,240 --> 00:26:53,360
instead of calling colon colon value you

00:26:52,080 --> 00:26:55,679
could call you could do

00:26:53,360 --> 00:26:57,279
squiggle squiggle and that'll create an

00:26:55,679 --> 00:26:59,360
instance of it and then you can pass it

00:26:57,279 --> 00:27:00,640
to a function or an evaluation of some

00:26:59,360 --> 00:27:02,080
context of some type

00:27:00,640 --> 00:27:04,480
and it'll automatically convert it to

00:27:02,080 --> 00:27:05,120
that type and this one down here allows

00:27:04,480 --> 00:27:07,760
to be

00:27:05,120 --> 00:27:10,320
created as a functor so it has a call

00:27:07,760 --> 00:27:10,320
operator

00:27:11,679 --> 00:27:16,159
um so integral constant is very very

00:27:14,559 --> 00:27:19,200
useful because it allows us to

00:27:16,159 --> 00:27:22,559
wrap a constant with its type

00:27:19,200 --> 00:27:23,919
and auto came around after this

00:27:22,559 --> 00:27:26,320
otherwise we wouldn't need the first

00:27:23,919 --> 00:27:28,559
parameter that tells us what the type is

00:27:26,320 --> 00:27:31,440
but it came around before that and so it

00:27:28,559 --> 00:27:31,440
still has the type

00:27:31,760 --> 00:27:36,159
um so there's some convenient helpers

00:27:33,919 --> 00:27:39,200
that are really useful

00:27:36,159 --> 00:27:42,399
and these are these are new as well um

00:27:39,200 --> 00:27:44,480
bull constant is the same as an integral

00:27:42,399 --> 00:27:47,279
constant that takes a boolean

00:27:44,480 --> 00:27:49,279
yeah i like that and truetype is the

00:27:47,279 --> 00:27:50,960
same as a bull constant that takes true

00:27:49,279 --> 00:27:55,360
the false type is a bull constant takes

00:27:50,960 --> 00:27:55,360
false now notice that these are aliases

00:27:55,760 --> 00:27:59,440
the bull constant is a template alias so

00:27:57,919 --> 00:28:02,720
it's actually going to be

00:27:59,440 --> 00:28:05,200
integral constant bull and whatever

00:28:02,720 --> 00:28:06,960
value you pass in true type is going to

00:28:05,200 --> 00:28:08,880
be integral constant

00:28:06,960 --> 00:28:11,279
bull true false type is going to be

00:28:08,880 --> 00:28:14,799
integral constant

00:28:11,279 --> 00:28:17,840
bull false now

00:28:14,799 --> 00:28:20,559
false type and true type are going to be

00:28:17,840 --> 00:28:20,559
meta functions

00:28:20,640 --> 00:28:24,080
they're called nullery meta functions

00:28:22,640 --> 00:28:27,120
because they don't have any parameters

00:28:24,080 --> 00:28:28,960
we can just explicitly grab their value

00:28:27,120 --> 00:28:32,000
but they are still meta functions and

00:28:28,960 --> 00:28:34,159
very useful ones at that

00:28:32,000 --> 00:28:36,159
so let's look at the standard type trait

00:28:34,159 --> 00:28:39,200
requirements

00:28:36,159 --> 00:28:39,679
um in the c plus 20 standard it says the

00:28:39,200 --> 00:28:42,080
c

00:28:39,679 --> 00:28:45,520
cpp 17 unary type traits it makes me

00:28:42,080 --> 00:28:47,600
chuckle every time i see it um

00:28:45,520 --> 00:28:49,760
i i don't i don't i don't know why it

00:28:47,600 --> 00:28:51,520
just it's kind of funny that in the c

00:28:49,760 --> 00:28:53,679
plus 20 standard that's what it's called

00:28:51,520 --> 00:28:55,679
but that's because

00:28:53,679 --> 00:28:56,960
the direction that things are going is

00:28:55,679 --> 00:28:58,960
very very different from c

00:28:56,960 --> 00:29:00,720
for c plus plus 20 and going and going

00:28:58,960 --> 00:29:02,240
forward um

00:29:00,720 --> 00:29:03,840
but it should be a clear indication that

00:29:02,240 --> 00:29:05,279
c plus 20 introduces some

00:29:03,840 --> 00:29:07,919
very different meta programming

00:29:05,279 --> 00:29:11,919
techniques and um

00:29:07,919 --> 00:29:13,520
um so for a unary type trait in the

00:29:11,919 --> 00:29:15,200
standard library which is what we're get

00:29:13,520 --> 00:29:16,720
which is what we're talking about

00:29:15,200 --> 00:29:19,039
unary type traits in the standard

00:29:16,720 --> 00:29:21,520
library it ha it's a class template

00:29:19,039 --> 00:29:22,320
of one template type argument now

00:29:21,520 --> 00:29:24,559
there's an

00:29:22,320 --> 00:29:26,320
asterisk there and that's because

00:29:24,559 --> 00:29:27,760
there's optional additional arguments

00:29:26,320 --> 00:29:28,880
that help define the type being

00:29:27,760 --> 00:29:32,559
described

00:29:28,880 --> 00:29:34,320
they're allowed but in in

00:29:32,559 --> 00:29:37,039
reality there's one template type

00:29:34,320 --> 00:29:38,640
argument for these unary type traits

00:29:37,039 --> 00:29:40,640
they have to be default constructable

00:29:38,640 --> 00:29:43,360
and they have to be copy constructable

00:29:40,640 --> 00:29:44,320
they have to publicly and unambiguously

00:29:43,360 --> 00:29:45,679
derive from

00:29:44,320 --> 00:29:47,520
enteral constant there's an error

00:29:45,679 --> 00:29:50,799
constant it's very important

00:29:47,520 --> 00:29:53,440
all of the unary type traits have to

00:29:50,799 --> 00:29:55,440
derive from integral constant

00:29:53,440 --> 00:29:56,960
the member names and the base

00:29:55,440 --> 00:29:58,720
characteristics shall not be hidden and

00:29:56,960 --> 00:30:01,120
shall be unambiguously available

00:29:58,720 --> 00:30:03,039
basically this means if you inherit from

00:30:01,120 --> 00:30:06,720
it you can't hide any of that stuff you

00:30:03,039 --> 00:30:06,720
got to let all that stuff be available

00:30:06,840 --> 00:30:10,159
publicly

00:30:08,559 --> 00:30:12,080
for the for the standard for for the

00:30:10,159 --> 00:30:13,760
standard traits so they have also this

00:30:12,080 --> 00:30:15,279
binary type trade which is the exact

00:30:13,760 --> 00:30:18,559
same as the unity type trade except it

00:30:15,279 --> 00:30:19,840
has two template parameters

00:30:18,559 --> 00:30:22,480
and then there's these transformation

00:30:19,840 --> 00:30:23,279
traits which take a template type

00:30:22,480 --> 00:30:25,360
argument

00:30:23,279 --> 00:30:27,279
and again it could have extra ones that

00:30:25,360 --> 00:30:29,600
help define the type

00:30:27,279 --> 00:30:32,640
it's got a publicly accessible nested

00:30:29,600 --> 00:30:34,960
type named type

00:30:32,640 --> 00:30:36,000
this means that there's going to be a

00:30:34,960 --> 00:30:37,919
you have to have a type

00:30:36,000 --> 00:30:39,440
name type so this is kind of the

00:30:37,919 --> 00:30:41,760
remember i said these were conventions

00:30:39,440 --> 00:30:43,840
that were generated by the community

00:30:41,760 --> 00:30:45,840
these are stan now these conventions

00:30:43,840 --> 00:30:47,760
have become standardized

00:30:45,840 --> 00:30:49,039
at least for the type traits that are in

00:30:47,760 --> 00:30:50,640
the standard library

00:30:49,039 --> 00:30:53,279
you can write your traits however you

00:30:50,640 --> 00:30:55,120
want but i advise you to write them

00:30:53,279 --> 00:30:56,880
in the same manner that way all user

00:30:55,120 --> 00:31:00,240
code can use them in the same

00:30:56,880 --> 00:31:02,799
in the same way but there's no default

00:31:00,240 --> 00:31:04,559
copy constructable requirement

00:31:02,799 --> 00:31:06,880
there's no inheritance requirement

00:31:04,559 --> 00:31:07,519
basically it's a class template takes an

00:31:06,880 --> 00:31:08,799
argument

00:31:07,519 --> 00:31:10,880
and it's going to have a type that's

00:31:08,799 --> 00:31:14,080
really all you can assume about

00:31:10,880 --> 00:31:16,799
those traits i want to say something

00:31:14,080 --> 00:31:18,880
about undefined behavior

00:31:16,799 --> 00:31:20,799
partly because what's a cpp con without

00:31:18,880 --> 00:31:22,240
talk uh cppcon talk without talking

00:31:20,799 --> 00:31:26,320
about undefined behavior

00:31:22,240 --> 00:31:27,679
um but really the standard is pretty

00:31:26,320 --> 00:31:30,960
clear

00:31:27,679 --> 00:31:31,760
it says do not specialize any of these

00:31:30,960 --> 00:31:33,760
templates

00:31:31,760 --> 00:31:35,760
now in previous standards the wording

00:31:33,760 --> 00:31:38,480
was according to some people

00:31:35,760 --> 00:31:39,279
a little bit vague but it's always been

00:31:38,480 --> 00:31:40,880
pretty clear

00:31:39,279 --> 00:31:43,200
that unless they tell you you can

00:31:40,880 --> 00:31:45,679
specialize something don't do it

00:31:43,200 --> 00:31:47,360
and they explicitly come out and say

00:31:45,679 --> 00:31:49,200
that your program is going to have

00:31:47,360 --> 00:31:50,799
undefined behavior if you add any

00:31:49,200 --> 00:31:51,760
specialization for any of these

00:31:50,799 --> 00:31:54,799
templates

00:31:51,760 --> 00:31:57,519
unless it's explicitly

00:31:54,799 --> 00:31:58,880
told that you can do so the only one i

00:31:57,519 --> 00:32:00,640
know of that you're allowed to do that

00:31:58,880 --> 00:32:02,640
for is common type

00:32:00,640 --> 00:32:04,799
and all the rest of them don't do it

00:32:02,640 --> 00:32:05,760
there's reasons but number one yeah okay

00:32:04,799 --> 00:32:07,039
it's undefined behavior you don't want

00:32:05,760 --> 00:32:07,519
to mess with undefined behavior to begin

00:32:07,039 --> 00:32:09,279
with

00:32:07,519 --> 00:32:11,039
but people are depending on the

00:32:09,279 --> 00:32:13,600
definitions of these types

00:32:11,039 --> 00:32:14,720
in order for them to be the same as what

00:32:13,600 --> 00:32:16,640
the standard

00:32:14,720 --> 00:32:17,840
uh requires because third-party

00:32:16,640 --> 00:32:19,600
libraries your code

00:32:17,840 --> 00:32:22,159
they're going to be depending upon these

00:32:19,600 --> 00:32:23,440
types to behave in the exact same manner

00:32:22,159 --> 00:32:26,559
that they behave in

00:32:23,440 --> 00:32:28,960
um if you go and and start specializing

00:32:26,559 --> 00:32:30,799
is integral you're going to break stuff

00:32:28,960 --> 00:32:33,120
because the definition and standard says

00:32:30,799 --> 00:32:35,360
that there's 14 specific type

00:32:33,120 --> 00:32:36,559
type traits that every class belongs to

00:32:35,360 --> 00:32:38,240
exactly one of those

00:32:36,559 --> 00:32:39,519
and if you add one to it it's probably

00:32:38,240 --> 00:32:40,559
also going to be part of class and

00:32:39,519 --> 00:32:41,440
you're going to you're going to break

00:32:40,559 --> 00:32:43,840
something

00:32:41,440 --> 00:32:43,840
um

00:32:44,880 --> 00:32:47,200
okay

00:32:47,919 --> 00:32:51,120
other sets undefined behavior be careful

00:32:49,840 --> 00:32:54,240
when using

00:32:51,120 --> 00:32:56,080
incomplete types now

00:32:54,240 --> 00:32:57,519
these type traits they allow you to use

00:32:56,080 --> 00:33:00,320
an incomplete type but

00:32:57,519 --> 00:33:02,240
only if when you use an incomplete type

00:33:00,320 --> 00:33:03,279
and you use the complete type you'll end

00:33:02,240 --> 00:33:06,240
up with the same result

00:33:03,279 --> 00:33:07,279
if you ever could could instantiate a

00:33:06,240 --> 00:33:10,320
type trait

00:33:07,279 --> 00:33:11,120
with an incomplete type and instantiate

00:33:10,320 --> 00:33:13,039
the type trade

00:33:11,120 --> 00:33:14,559
with the complete type and they would

00:33:13,039 --> 00:33:15,840
ever give you different results then

00:33:14,559 --> 00:33:16,559
that's going to lead to undefined

00:33:15,840 --> 00:33:18,320
behavior

00:33:16,559 --> 00:33:20,480
now you have to understand that the

00:33:18,320 --> 00:33:22,399
compiler is allowed to memoize

00:33:20,480 --> 00:33:24,080
these instantiations so the very first

00:33:22,399 --> 00:33:25,519
time it sees an instantiation it can

00:33:24,080 --> 00:33:26,000
record that and keep it forever and ever

00:33:25,519 --> 00:33:27,360
and ever

00:33:26,000 --> 00:33:29,120
so if you have something that is

00:33:27,360 --> 00:33:31,760
different when it's uh

00:33:29,120 --> 00:33:33,120
when it's um incomplete and then later

00:33:31,760 --> 00:33:35,200
it sees the complete version

00:33:33,120 --> 00:33:36,399
then you're gonna have who knows what

00:33:35,200 --> 00:33:38,080
that's why it says it's completely

00:33:36,399 --> 00:33:40,799
undefined behavior

00:33:38,080 --> 00:33:42,320
um okay so this is a good place to i

00:33:40,799 --> 00:33:46,080
thought there was another question

00:33:42,320 --> 00:33:50,000
but i guess it went away all right

00:33:46,080 --> 00:33:50,000
so let's talk about specialization

00:33:51,279 --> 00:33:55,840
and we're going to do this by attacking

00:33:53,600 --> 00:33:57,840
some of the type traits themselves

00:33:55,840 --> 00:33:58,960
the the default one this is kind of like

00:33:57,840 --> 00:34:02,399
hello world right

00:33:58,960 --> 00:34:03,760
is void it's going to be a value meta

00:34:02,399 --> 00:34:07,200
function

00:34:03,760 --> 00:34:07,840
and is the is the to see is the type

00:34:07,200 --> 00:34:10,079
void

00:34:07,840 --> 00:34:11,200
and it's either going to yield true type

00:34:10,079 --> 00:34:13,679
or it's going to yield

00:34:11,200 --> 00:34:14,639
false type and the way we're going to do

00:34:13,679 --> 00:34:18,800
this is we're going to

00:34:14,639 --> 00:34:21,119
do this through specialization

00:34:18,800 --> 00:34:22,639
now maybe you've seen specialization

00:34:21,119 --> 00:34:24,159
before maybe you haven't

00:34:22,639 --> 00:34:25,919
uh maybe it's one of those things that

00:34:24,159 --> 00:34:28,240
kind of you know makes you go grok in

00:34:25,919 --> 00:34:28,240
the night

00:34:28,879 --> 00:34:32,399
but we're going to look at we're going

00:34:30,399 --> 00:34:33,760
to look at specialization in depth today

00:34:32,399 --> 00:34:36,240
in a lot of different areas because

00:34:33,760 --> 00:34:39,280
there's a lot of different subtleties

00:34:36,240 --> 00:34:40,480
but in general every time you're gonna

00:34:39,280 --> 00:34:41,760
you're you're gonna have a

00:34:40,480 --> 00:34:43,440
specialization you're gonna have a

00:34:41,760 --> 00:34:45,200
general case

00:34:43,440 --> 00:34:46,879
your primary what's called your primary

00:34:45,200 --> 00:34:48,960
template and in our case

00:34:46,879 --> 00:34:50,480
we're looking to see is something void

00:34:48,960 --> 00:34:52,320
well

00:34:50,480 --> 00:34:53,919
most of the things aren't void so we're

00:34:52,320 --> 00:34:56,159
going to create is void

00:34:53,919 --> 00:34:58,160
and it's going to return false type and

00:34:56,159 --> 00:35:00,880
if this were a test

00:34:58,160 --> 00:35:03,040
we could implement is void as false type

00:35:00,880 --> 00:35:05,280
and as long as we were okay with getting

00:35:03,040 --> 00:35:07,040
90 something percent of the time correct

00:35:05,280 --> 00:35:08,640
then uh we could just leave it like this

00:35:07,040 --> 00:35:09,599
because almost all the types aren't

00:35:08,640 --> 00:35:11,119
going to be void

00:35:09,599 --> 00:35:12,960
but that's not what we're trying to do

00:35:11,119 --> 00:35:14,960
we really want to catch uh

00:35:12,960 --> 00:35:16,160
the specific cases so we're going to

00:35:14,960 --> 00:35:19,200
have a an explicit

00:35:16,160 --> 00:35:22,960
specialization for our special case now

00:35:19,200 --> 00:35:24,320
our special case is when the type is

00:35:22,960 --> 00:35:27,440
void

00:35:24,320 --> 00:35:29,040
now if you look here

00:35:27,440 --> 00:35:31,280
right beside the template you see the

00:35:29,040 --> 00:35:32,720
angle brackets the angle brackets are

00:35:31,280 --> 00:35:36,000
empty

00:35:32,720 --> 00:35:37,920
that means that this is a full or an

00:35:36,000 --> 00:35:40,079
explicit specialization

00:35:37,920 --> 00:35:41,920
we're going to specialize this template

00:35:40,079 --> 00:35:42,960
remember a template is just a it's a

00:35:41,920 --> 00:35:46,720
cookie cutter

00:35:42,960 --> 00:35:50,320
for stamping out types or functions or

00:35:46,720 --> 00:35:50,320
aliases or variables

00:35:50,560 --> 00:35:54,160
and what we're doing is we're saying

00:35:52,000 --> 00:35:56,960
whenever you see a special type

00:35:54,160 --> 00:35:57,599
in this case void don't use the general

00:35:56,960 --> 00:35:59,280
one

00:35:57,599 --> 00:36:00,720
because that's the that's the one for

00:35:59,280 --> 00:36:03,520
everybody else

00:36:00,720 --> 00:36:05,440
but when you see this special type void

00:36:03,520 --> 00:36:07,440
i want you to do something

00:36:05,440 --> 00:36:08,640
else and that's what this specialization

00:36:07,440 --> 00:36:10,560
is saying

00:36:08,640 --> 00:36:13,280
the empty angle brackets mean it's an

00:36:10,560 --> 00:36:14,960
explicit full specialization

00:36:13,280 --> 00:36:16,320
and then we take the type that we're

00:36:14,960 --> 00:36:19,359
specializing for

00:36:16,320 --> 00:36:21,440
and we put it right there the void and

00:36:19,359 --> 00:36:24,160
in this case we're going to return true

00:36:21,440 --> 00:36:25,200
and so these static asserts will be fine

00:36:24,160 --> 00:36:28,480
static assert

00:36:25,200 --> 00:36:30,800
is void of void and static gifts are not

00:36:28,480 --> 00:36:32,560
is void of an int and you notice here i

00:36:30,800 --> 00:36:32,960
used the curly brace the curly brackets

00:36:32,560 --> 00:36:35,200
here

00:36:32,960 --> 00:36:36,160
i did that specifically to to show you

00:36:35,200 --> 00:36:39,040
how

00:36:36,160 --> 00:36:39,520
how it's how the implicit conversion

00:36:39,040 --> 00:36:41,680
works

00:36:39,520 --> 00:36:43,440
so i'm i'm i'm calling is void it's

00:36:41,680 --> 00:36:43,760
returning to me a type it's returning to

00:36:43,440 --> 00:36:46,640
me

00:36:43,760 --> 00:36:47,280
and and um an instance of a value meta

00:36:46,640 --> 00:36:49,119
function

00:36:47,280 --> 00:36:51,280
i'm instantiating it and then it's being

00:36:49,119 --> 00:36:56,480
implicitly converted to a bull

00:36:51,280 --> 00:36:56,480
in which static assert is using okay

00:36:59,040 --> 00:37:03,599
why does is void return true type false

00:37:02,000 --> 00:37:06,400
type instead of the true

00:37:03,599 --> 00:37:08,560
false values oh that's actually that's

00:37:06,400 --> 00:37:12,560
actually a great question um

00:37:08,560 --> 00:37:16,160
and the reason is because

00:37:12,560 --> 00:37:19,119
it's a the reason is because it's a

00:37:16,160 --> 00:37:20,000
meta function and it's going and we're

00:37:19,119 --> 00:37:23,440
returning

00:37:20,000 --> 00:37:24,079
the true type the the actual type of it

00:37:23,440 --> 00:37:27,440
so

00:37:24,079 --> 00:37:30,560
let me back up here so is void um

00:37:27,440 --> 00:37:31,280
first off if you remember the standard

00:37:30,560 --> 00:37:34,560
said that

00:37:31,280 --> 00:37:35,599
every single unary meta function had to

00:37:34,560 --> 00:37:38,640
inherit

00:37:35,599 --> 00:37:41,359
from a

00:37:38,640 --> 00:37:42,000
integral constant and false type and

00:37:41,359 --> 00:37:44,240
true type

00:37:42,000 --> 00:37:46,320
are integral constants false type is

00:37:44,240 --> 00:37:49,520
just integral constant bull false

00:37:46,320 --> 00:37:52,800
true type is just integral constant

00:37:49,520 --> 00:37:55,760
bull true now so

00:37:52,800 --> 00:37:57,599
the standard says that these this these

00:37:55,760 --> 00:37:58,320
meta functions must inherit from one of

00:37:57,599 --> 00:38:01,040
those

00:37:58,320 --> 00:38:02,880
and the reason is because if all we did

00:38:01,040 --> 00:38:06,000
was just return a truth

00:38:02,880 --> 00:38:07,599
value where is your type you don't

00:38:06,000 --> 00:38:08,880
really have a type to manipulate at

00:38:07,599 --> 00:38:11,839
compile time

00:38:08,880 --> 00:38:13,359
you can have a context per variable that

00:38:11,839 --> 00:38:16,640
has a value of true

00:38:13,359 --> 00:38:18,560
or a value of false but what we're

00:38:16,640 --> 00:38:21,599
trying to do is these are

00:38:18,560 --> 00:38:25,440
meta functions right so the

00:38:21,599 --> 00:38:27,760
it's is void is not returning

00:38:25,440 --> 00:38:29,119
is is void is not returning this true

00:38:27,760 --> 00:38:31,920
type is void

00:38:29,119 --> 00:38:32,880
is inheriting from true type and

00:38:31,920 --> 00:38:37,599
truetype

00:38:32,880 --> 00:38:37,599
already has i wonder if i can go back

00:38:43,680 --> 00:38:49,119
there we go

00:38:47,520 --> 00:38:50,720
remember true type is an integral

00:38:49,119 --> 00:38:54,640
constant of bull

00:38:50,720 --> 00:38:58,240
true and it has this value right there

00:38:54,640 --> 00:39:00,079
okay so when we inherit when we inherit

00:38:58,240 --> 00:39:02,880
from true type we're inheriting from

00:39:00,079 --> 00:39:04,240
integral constant bull true that has

00:39:02,880 --> 00:39:07,200
this value member

00:39:04,240 --> 00:39:07,760
that is going to be set to true it's

00:39:07,200 --> 00:39:08,800
right

00:39:07,760 --> 00:39:10,800
it's and then you're going to know its

00:39:08,800 --> 00:39:12,079
value type is going to be bull and that

00:39:10,800 --> 00:39:13,599
its internal type is going to be the

00:39:12,079 --> 00:39:14,800
inner constant but that's where you get

00:39:13,599 --> 00:39:18,000
the value

00:39:14,800 --> 00:39:19,440
um and because we're inheriting from one

00:39:18,000 --> 00:39:20,720
of these integral constants

00:39:19,440 --> 00:39:22,640
and that's what all of these meta

00:39:20,720 --> 00:39:23,359
functions all these unary type trait

00:39:22,640 --> 00:39:26,480
meta functions

00:39:23,359 --> 00:39:29,680
inherit from um either

00:39:26,480 --> 00:39:32,400
true type or false type so i can get

00:39:29,680 --> 00:39:32,400
back to where i was

00:39:32,640 --> 00:39:38,320
yeah so is void it's not returning

00:39:35,839 --> 00:39:40,000
true type it's inheriting from true type

00:39:38,320 --> 00:39:43,040
and then when it gets called

00:39:40,000 --> 00:39:43,839
with colon colon value then that's the

00:39:43,040 --> 00:39:46,079
return

00:39:43,839 --> 00:39:47,920
so when you want to call it even like

00:39:46,079 --> 00:39:50,640
here with is void

00:39:47,920 --> 00:39:52,800
angle void curly brackets that's

00:39:50,640 --> 00:39:54,640
instantiating one of those things

00:39:52,800 --> 00:39:56,480
and it's auto and it's using the

00:39:54,640 --> 00:39:59,119
implicit conversion operator to turn it

00:39:56,480 --> 00:39:59,119
into a true

00:40:04,319 --> 00:40:07,839
why is inheriting from standard true

00:40:06,000 --> 00:40:08,640
type equivalent to returning standard

00:40:07,839 --> 00:40:13,599
true type

00:40:08,640 --> 00:40:16,720
okay well it's equivalent to it because

00:40:13,599 --> 00:40:19,839
when the integer or constant

00:40:16,720 --> 00:40:22,560
has a nested member called type

00:40:19,839 --> 00:40:23,599
that is an integral constant so if you

00:40:22,560 --> 00:40:25,359
inherit from

00:40:23,599 --> 00:40:27,119
if you inherit from true type you're

00:40:25,359 --> 00:40:28,400
going to inherit from integral constant

00:40:27,119 --> 00:40:30,079
bull true

00:40:28,400 --> 00:40:31,680
and the integral constant bull true is

00:40:30,079 --> 00:40:33,440
going to have a value

00:40:31,680 --> 00:40:35,680
that is a a static value that's a

00:40:33,440 --> 00:40:38,880
boolean and it evaluates to true

00:40:35,680 --> 00:40:41,280
it's also going to have a type member

00:40:38,880 --> 00:40:42,720
and that type member is going to be you

00:40:41,280 --> 00:40:43,839
know let me back up i probably should

00:40:42,720 --> 00:40:44,800
have spent more time on that or i

00:40:43,839 --> 00:40:47,200
probably should have put it somewhere

00:40:44,800 --> 00:40:50,839
where i can

00:40:47,200 --> 00:40:53,839
um where i can get to it easier

00:40:50,839 --> 00:40:53,839
uh

00:40:54,240 --> 00:40:57,760
okay here we go so

00:40:58,319 --> 00:41:01,839
bull bull and this and i'm fine going

00:41:00,400 --> 00:41:03,359
through this because because this is

00:41:01,839 --> 00:41:06,560
important understand

00:41:03,359 --> 00:41:09,680
so true type is the same as

00:41:06,560 --> 00:41:13,440
integral constant bull true

00:41:09,680 --> 00:41:16,560
it has a nested value a

00:41:13,440 --> 00:41:19,599
static constexpr boolean value

00:41:16,560 --> 00:41:21,040
member a data member and its value is

00:41:19,599 --> 00:41:24,319
going to be true

00:41:21,040 --> 00:41:26,800
it also has a type

00:41:24,319 --> 00:41:28,319
with the name of type and that type is

00:41:26,800 --> 00:41:31,760
integral constant

00:41:28,319 --> 00:41:33,920
of bull true so when we have

00:41:31,760 --> 00:41:35,119
a type trait that inherits from true

00:41:33,920 --> 00:41:37,599
type

00:41:35,119 --> 00:41:38,480
it's true to say that it inherits from

00:41:37,599 --> 00:41:41,040
true type

00:41:38,480 --> 00:41:42,079
it's also true to say that it returns

00:41:41,040 --> 00:41:44,160
true type

00:41:42,079 --> 00:41:46,319
it's also true to say that it returns

00:41:44,160 --> 00:41:48,160
true because if you invoke it as a value

00:41:46,319 --> 00:41:50,480
meta function by calling colon colon

00:41:48,160 --> 00:41:52,480
value then you'll get back true if you

00:41:50,480 --> 00:41:53,920
invoke it as a type meta function by

00:41:52,480 --> 00:41:56,640
calling colon colon type

00:41:53,920 --> 00:41:59,440
then you'll get back integral constant

00:41:56,640 --> 00:42:03,839
bull true which is the same as true type

00:41:59,440 --> 00:42:05,920
okay so that's why they are equivalent

00:42:03,839 --> 00:42:07,280
hopefully hopefully that clears up a lot

00:42:05,920 --> 00:42:09,359
for you if not

00:42:07,280 --> 00:42:11,040
um feel free to ask some more questions

00:42:09,359 --> 00:42:14,079
and uh maybe we'll uh

00:42:11,040 --> 00:42:14,960
meet together in the room afterwards and

00:42:14,079 --> 00:42:17,440
go over it

00:42:14,960 --> 00:42:19,119
but this is a tutorial um i have a ton

00:42:17,440 --> 00:42:19,520
of stuff to get to but if i don't get to

00:42:19,119 --> 00:42:21,280
it all

00:42:19,520 --> 00:42:22,880
nobody's going to be you know nobody's

00:42:21,280 --> 00:42:23,920
going to know because it's not like i'm

00:42:22,880 --> 00:42:26,319
trying to

00:42:23,920 --> 00:42:28,640
reveal some you know great revelation at

00:42:26,319 --> 00:42:32,560
the end that nobody's seen before

00:42:28,640 --> 00:42:36,240
um so is void

00:42:32,560 --> 00:42:38,800
is void const void

00:42:36,240 --> 00:42:40,880
what about void volatile what do you

00:42:38,800 --> 00:42:44,000
think is that void

00:42:40,880 --> 00:42:45,839
um so is void is listed

00:42:44,000 --> 00:42:48,240
in what the standard calls its primary

00:42:45,839 --> 00:42:51,040
type categories

00:42:48,240 --> 00:42:52,880
and so this is what it says it says for

00:42:51,040 --> 00:42:55,119
any given type t

00:42:52,880 --> 00:42:57,040
the result of applying one of these

00:42:55,119 --> 00:42:58,000
templates so any of them in that type

00:42:57,040 --> 00:43:01,680
category not just

00:42:58,000 --> 00:43:03,440
is void the result of applying one of

00:43:01,680 --> 00:43:07,119
these templates to t

00:43:03,440 --> 00:43:10,160
and to cvt shall yield the same result

00:43:07,119 --> 00:43:10,800
so that means that yes no matter your

00:43:10,160 --> 00:43:13,359
opinion

00:43:10,800 --> 00:43:14,160
whether you think void const is void or

00:43:13,359 --> 00:43:17,200
not

00:43:14,160 --> 00:43:20,319
the standard says that void is void

00:43:17,200 --> 00:43:22,800
void const is void void volatile is void

00:43:20,319 --> 00:43:24,640
void kant's volatile is void because it

00:43:22,800 --> 00:43:27,920
says that this cv thing

00:43:24,640 --> 00:43:30,240
it stands for const volatile and cv

00:43:27,920 --> 00:43:31,119
are those const volatile qualifiers that

00:43:30,240 --> 00:43:33,280
you can add

00:43:31,119 --> 00:43:34,560
to these types and it's saying that for

00:43:33,280 --> 00:43:36,880
any type you give it

00:43:34,560 --> 00:43:37,599
if you give it a type and then you give

00:43:36,880 --> 00:43:39,839
it any of those

00:43:37,599 --> 00:43:39,839
other

00:43:40,880 --> 00:43:44,640
together then the result should be the

00:43:43,119 --> 00:43:47,839
exact same

00:43:44,640 --> 00:43:52,160
for all of for all those permutations

00:43:47,839 --> 00:43:52,160
so let's look at is void again

00:43:52,800 --> 00:43:58,800
this is the primary

00:43:56,160 --> 00:43:58,800
uh template

00:44:00,079 --> 00:44:04,720
there's a specialization for void note

00:44:02,800 --> 00:44:05,599
the angle break the angle brackets to

00:44:04,720 --> 00:44:09,119
the left

00:44:05,599 --> 00:44:11,280
are completely the

00:44:09,119 --> 00:44:13,040
angle break these angle brackets there's

00:44:11,280 --> 00:44:15,680
nothing inside of them

00:44:13,040 --> 00:44:17,520
so this is saying this is void whenever

00:44:15,680 --> 00:44:21,040
is void is called with this type

00:44:17,520 --> 00:44:23,839
void i want true

00:44:21,040 --> 00:44:24,880
whenever is void is called an explicit

00:44:23,839 --> 00:44:28,000
specialization

00:44:24,880 --> 00:44:30,720
with void with a const qualifier

00:44:28,000 --> 00:44:32,800
i want to return true if ever i have an

00:44:30,720 --> 00:44:34,800
explicit specialization

00:44:32,800 --> 00:44:37,440
or this is an explicit specialization

00:44:34,800 --> 00:44:40,160
saying that anytime i have is void

00:44:37,440 --> 00:44:40,880
with void that also has a volatile

00:44:40,160 --> 00:44:43,359
qualifier

00:44:40,880 --> 00:44:44,960
i'm going to return true an explicit

00:44:43,359 --> 00:44:45,839
specialization i'm doing this over and

00:44:44,960 --> 00:44:48,720
over again to try and

00:44:45,839 --> 00:44:50,960
hopefully get this in your empty angle

00:44:48,720 --> 00:44:53,920
brackets explicit specialization

00:44:50,960 --> 00:44:54,720
is void void with both const and

00:44:53,920 --> 00:44:59,200
volatile

00:44:54,720 --> 00:45:02,960
is going to yield true type okay

00:44:59,200 --> 00:45:04,400
now let's look at a transformation trait

00:45:02,960 --> 00:45:06,240
remember that i showed you the rules for

00:45:04,400 --> 00:45:08,240
unity traits binary traits

00:45:06,240 --> 00:45:09,280
and transformation traits transformation

00:45:08,240 --> 00:45:11,680
traits are what they call

00:45:09,280 --> 00:45:12,480
their type meta functions so the formal

00:45:11,680 --> 00:45:15,680
definition

00:45:12,480 --> 00:45:16,079
for remove const is that the member type

00:45:15,680 --> 00:45:19,359
def

00:45:16,079 --> 00:45:21,440
type so in the meta function it has a

00:45:19,359 --> 00:45:22,880
it has an internal type it says that's

00:45:21,440 --> 00:45:25,599
going to be the same type as

00:45:22,880 --> 00:45:26,079
t except that with any top-level cons

00:45:25,599 --> 00:45:28,640
quality

00:45:26,079 --> 00:45:29,359
qualifier been removed so that means

00:45:28,640 --> 00:45:32,000
that if you

00:45:29,359 --> 00:45:32,960
feed remove const avoid const you're

00:45:32,000 --> 00:45:34,319
going to get back void

00:45:32,960 --> 00:45:36,319
if you feed it void you're going to get

00:45:34,319 --> 00:45:38,400
back void if you feed it void

00:45:36,319 --> 00:45:40,000
volatile you'll get back void volatile

00:45:38,400 --> 00:45:40,720
if you feed it void volatile const

00:45:40,000 --> 00:45:43,200
you'll get back

00:45:40,720 --> 00:45:44,240
void volatile right uh probably should

00:45:43,200 --> 00:45:46,800
have just done this

00:45:44,240 --> 00:45:48,400
remove constant is an end remove kant's

00:45:46,800 --> 00:45:50,480
constant is an end

00:45:48,400 --> 00:45:52,079
remove const kant's volatile ant is a

00:45:50,480 --> 00:45:55,280
volatile end

00:45:52,079 --> 00:45:58,640
uh remove const in star is an inch star

00:45:55,280 --> 00:46:00,720
remove const constant star isn't it star

00:45:58,640 --> 00:46:02,480
uh no not really because it's just a

00:46:00,720 --> 00:46:05,520
top-level qualifier

00:46:02,480 --> 00:46:06,240
um and unfortunately having our const on

00:46:05,520 --> 00:46:08,480
the left

00:46:06,240 --> 00:46:09,599
kind of is misleading here because that

00:46:08,480 --> 00:46:13,200
doesn't mean top

00:46:09,599 --> 00:46:16,000
top is on the right um

00:46:13,200 --> 00:46:17,520
so really this is what it is remove

00:46:16,000 --> 00:46:19,839
const of constant star

00:46:17,520 --> 00:46:22,880
because it's a pointer so it's a pointer

00:46:19,839 --> 00:46:24,720
to a constant it's not a const pointer

00:46:22,880 --> 00:46:27,040
right and so you have to understand this

00:46:24,720 --> 00:46:30,160
when you're dealing with types

00:46:27,040 --> 00:46:33,200
the this is a pointer type so

00:46:30,160 --> 00:46:34,319
the top level qualifiers the const and

00:46:33,200 --> 00:46:38,560
the volatile

00:46:34,319 --> 00:46:40,319
those are attached to the type itself

00:46:38,560 --> 00:46:42,079
and if it's a pointer then they should

00:46:40,319 --> 00:46:45,200
be attached to the pointer

00:46:42,079 --> 00:46:48,560
so in this case we've got a pointer to

00:46:45,200 --> 00:46:51,200
a int const or a pointer to a constant

00:46:48,560 --> 00:46:52,560
n so there's no top-level const to

00:46:51,200 --> 00:46:55,680
remove

00:46:52,560 --> 00:46:56,319
if we write it on what they call east

00:46:55,680 --> 00:46:58,880
const

00:46:56,319 --> 00:46:59,920
with the const on the right then it's a

00:46:58,880 --> 00:47:03,040
little bit more clear

00:46:59,920 --> 00:47:05,599
on how those work because the

00:47:03,040 --> 00:47:07,119
you read these types from right to left

00:47:05,599 --> 00:47:09,920
so

00:47:07,119 --> 00:47:10,960
it can't star const that one is ant

00:47:09,920 --> 00:47:12,800
const star

00:47:10,960 --> 00:47:15,760
right because the con the top level

00:47:12,800 --> 00:47:17,760
const now modifies the pointer

00:47:15,760 --> 00:47:19,520
and so it gets removed and so now we

00:47:17,760 --> 00:47:21,920
have it const star

00:47:19,520 --> 00:47:23,599
or if it's in if it's it's star const

00:47:21,920 --> 00:47:24,160
the top level const gets removed and

00:47:23,599 --> 00:47:29,119
we've got

00:47:24,160 --> 00:47:29,119
n star okay

00:47:30,000 --> 00:47:36,160
so the um

00:47:34,000 --> 00:47:38,000
the member type def names the same type

00:47:36,160 --> 00:47:42,000
as any top level cons qualifier

00:47:38,000 --> 00:47:45,359
with being removed so

00:47:42,000 --> 00:47:47,040
here's our primary template do nothing

00:47:45,359 --> 00:47:48,559
if there's no const this is basically

00:47:47,040 --> 00:47:51,119
we're going to try and implement this

00:47:48,559 --> 00:47:52,559
okay so we're going to do specialization

00:47:51,119 --> 00:47:56,160
and our primary template says

00:47:52,559 --> 00:47:56,160
do nothing if there's no const

00:47:58,640 --> 00:48:02,720
our partial specialization and i'm going

00:48:00,880 --> 00:48:06,240
to

00:48:02,720 --> 00:48:08,400
bring this up so our

00:48:06,240 --> 00:48:09,359
primary our primary specialization our

00:48:08,400 --> 00:48:12,960
primary template

00:48:09,359 --> 00:48:12,960
says do nothing if there's no const

00:48:14,000 --> 00:48:18,960
right because if there's no const there

00:48:16,880 --> 00:48:21,680
i don't have to remove it

00:48:18,960 --> 00:48:23,119
our and remember we're inheriting here

00:48:21,680 --> 00:48:25,040
from type identity

00:48:23,119 --> 00:48:26,319
this is not a value meta function and

00:48:25,040 --> 00:48:27,920
this is not a requirement

00:48:26,319 --> 00:48:30,000
this is just something i'm doing to kind

00:48:27,920 --> 00:48:32,400
of show you um

00:48:30,000 --> 00:48:34,000
um about the about how these this

00:48:32,400 --> 00:48:36,319
inheritance works from these types

00:48:34,000 --> 00:48:38,559
but according to the standard all you

00:48:36,319 --> 00:48:40,240
have to do is expose a type

00:48:38,559 --> 00:48:42,160
which we are we're exposing we're

00:48:40,240 --> 00:48:44,400
exposing a type here

00:48:42,160 --> 00:48:47,200
because there's the type here we're

00:48:44,400 --> 00:48:50,400
inheriting from type identity t

00:48:47,200 --> 00:48:51,119
which has a type t and so it's being

00:48:50,400 --> 00:48:52,559
exposed

00:48:51,119 --> 00:48:54,240
and that's really all the standard all

00:48:52,559 --> 00:48:56,079
the standard requires

00:48:54,240 --> 00:48:57,280
so the standard can implement these

00:48:56,079 --> 00:48:58,559
through inheritance or they can

00:48:57,280 --> 00:49:00,079
implement them through

00:48:58,559 --> 00:49:03,680
saying that a type is there that's all

00:49:00,079 --> 00:49:06,800
you really need

00:49:03,680 --> 00:49:08,800
the partial specialization and note

00:49:06,800 --> 00:49:09,839
i spent all that time last time harping

00:49:08,800 --> 00:49:11,839
on the fact that

00:49:09,839 --> 00:49:13,680
the angle brackets were empty it meant a

00:49:11,839 --> 00:49:15,280
an explicit specialization

00:49:13,680 --> 00:49:17,440
this time the angle brackets are not

00:49:15,280 --> 00:49:18,960
empty so we know this is going to be a

00:49:17,440 --> 00:49:22,319
partial specialization

00:49:18,960 --> 00:49:24,960
it's not giving the full exact type a

00:49:22,319 --> 00:49:25,520
full explicit specialization means that

00:49:24,960 --> 00:49:27,119
you're going to

00:49:25,520 --> 00:49:29,040
you're going to tell them exactly

00:49:27,119 --> 00:49:30,319
everything that's in between these

00:49:29,040 --> 00:49:32,880
brackets

00:49:30,319 --> 00:49:33,760
but a partial specialization means that

00:49:32,880 --> 00:49:35,599
what's in this

00:49:33,760 --> 00:49:37,359
in these brackets you're going to tell

00:49:35,599 --> 00:49:38,559
it part of it but then it's going to

00:49:37,359 --> 00:49:41,520
deduce the rest

00:49:38,559 --> 00:49:43,520
based on the type that's passed in and

00:49:41,520 --> 00:49:45,040
so in this case

00:49:43,520 --> 00:49:46,640
we end up with the partial

00:49:45,040 --> 00:49:49,599
specialization being

00:49:46,640 --> 00:49:50,960
any type t we'll take anything anything

00:49:49,599 --> 00:49:53,119
you want to give us give us

00:49:50,960 --> 00:49:54,960
give us whatever you want if it has a

00:49:53,119 --> 00:49:57,520
const amongst its mix

00:49:54,960 --> 00:50:00,480
it's going to match this specialization

00:49:57,520 --> 00:50:03,040
now the way that specializations match

00:50:00,480 --> 00:50:03,760
is that the compiler looks and it says

00:50:03,040 --> 00:50:06,800
hey

00:50:03,760 --> 00:50:09,599
which one matches the best

00:50:06,800 --> 00:50:11,359
which one had which one is the closest

00:50:09,599 --> 00:50:14,640
to what i'm looking for

00:50:11,359 --> 00:50:17,119
and in this case it has a const so

00:50:14,640 --> 00:50:18,000
it would actually match the primary

00:50:17,119 --> 00:50:20,079
template

00:50:18,000 --> 00:50:21,119
and it would match this one but because

00:50:20,079 --> 00:50:23,359
this one is more

00:50:21,119 --> 00:50:24,960
specialized this is the one that it's

00:50:23,359 --> 00:50:27,839
going to return

00:50:24,960 --> 00:50:29,839
okay so it has it's a partial

00:50:27,839 --> 00:50:31,040
specialization it tries to match all the

00:50:29,839 --> 00:50:33,119
stuff in there

00:50:31,040 --> 00:50:34,079
and it's just gonna say if it has a

00:50:33,119 --> 00:50:36,400
const at all

00:50:34,079 --> 00:50:37,680
then it's going to match that one the

00:50:36,400 --> 00:50:39,200
other one will be matched

00:50:37,680 --> 00:50:41,359
but the compiler will choose the one

00:50:39,200 --> 00:50:44,720
that has the best match

00:50:41,359 --> 00:50:45,119
so in this case if we look we see that

00:50:44,720 --> 00:50:47,040
the t

00:50:45,119 --> 00:50:49,280
const that's where we that's where we

00:50:47,040 --> 00:50:51,119
are the constant's gonna match and the t

00:50:49,280 --> 00:50:53,040
part is gonna get pulled out

00:50:51,119 --> 00:50:55,200
and then the t is gonna be passed to the

00:50:53,040 --> 00:50:56,240
type identity so if this were int

00:50:55,200 --> 00:50:58,880
volatile const

00:50:56,240 --> 00:50:59,520
or just say it const the const would get

00:50:58,880 --> 00:51:02,079
pulled out

00:50:59,520 --> 00:51:03,839
and the int would be left into t so it's

00:51:02,079 --> 00:51:04,960
not exactly the right way to think about

00:51:03,839 --> 00:51:06,880
it but it's it's

00:51:04,960 --> 00:51:08,640
it's good enough for just about most

00:51:06,880 --> 00:51:10,400
things you'll ever do

00:51:08,640 --> 00:51:12,319
this partial specialization it's going

00:51:10,400 --> 00:51:14,319
to take the whole entire thing think

00:51:12,319 --> 00:51:16,480
and it's going to match the const part

00:51:14,319 --> 00:51:18,400
and it's going to pull that piece out

00:51:16,480 --> 00:51:19,680
and whatever's left is going to is going

00:51:18,400 --> 00:51:20,960
to be the t

00:51:19,680 --> 00:51:24,480
and so that's what we're going to put

00:51:20,960 --> 00:51:24,480
into the type identity

00:51:25,680 --> 00:51:32,000
so here's an example

00:51:28,720 --> 00:51:33,760
remove const int volatile const

00:51:32,000 --> 00:51:37,839
it contains const so the partial

00:51:33,760 --> 00:51:37,839
specialization will match

00:51:38,880 --> 00:51:42,160
remove const there it is the partial

00:51:40,960 --> 00:51:45,440
specialization

00:51:42,160 --> 00:51:47,839
the full match is removed const in

00:51:45,440 --> 00:51:50,319
volatile cost right that's the full

00:51:47,839 --> 00:51:53,359
entire the full entire match

00:51:50,319 --> 00:51:54,880
because whenever it matches it's got the

00:51:53,359 --> 00:51:59,440
whole entire type

00:51:54,880 --> 00:51:59,440
so the whole entire type is int volatile

00:52:02,839 --> 00:52:07,760
const

00:52:04,559 --> 00:52:10,800
can i remove the pointer from the slides

00:52:07,760 --> 00:52:12,000
i i don't know what that means oh oh my

00:52:10,800 --> 00:52:15,440
pointer was in the middle of it

00:52:12,000 --> 00:52:17,200
sorry about that i didn't even see it

00:52:15,440 --> 00:52:21,680
there sorry

00:52:17,200 --> 00:52:24,240
okay um so the full match is remove

00:52:21,680 --> 00:52:24,800
const int volatile const that's the

00:52:24,240 --> 00:52:26,240
whole type

00:52:24,800 --> 00:52:27,920
in volatile const and that's what's

00:52:26,240 --> 00:52:29,119
going to match inside that inside that

00:52:27,920 --> 00:52:32,640
box

00:52:29,119 --> 00:52:34,960
now the const is explicitly matched

00:52:32,640 --> 00:52:35,680
so the part remaining to match with the

00:52:34,960 --> 00:52:39,359
t

00:52:35,680 --> 00:52:42,559
is the int volatile piece right so

00:52:39,359 --> 00:52:43,839
the blue part is going to turn into the

00:52:42,559 --> 00:52:46,800
green part which is just

00:52:43,839 --> 00:52:48,000
the t and so we inherit from type

00:52:46,800 --> 00:52:51,200
identity

00:52:48,000 --> 00:52:54,240
int volatile okay

00:52:51,200 --> 00:52:54,720
and that means that the return type will

00:52:54,240 --> 00:53:00,400
be

00:52:54,720 --> 00:53:02,160
int volatile

00:53:00,400 --> 00:53:03,440
okay uh this is probably i see a

00:53:02,160 --> 00:53:05,520
question this would be a good

00:53:03,440 --> 00:53:06,960
ticket his explicit specialization a

00:53:05,520 --> 00:53:07,920
synonym for full specification or full

00:53:06,960 --> 00:53:11,119
specification

00:53:07,920 --> 00:53:12,640
um i use those two interchangeably to be

00:53:11,119 --> 00:53:14,720
honest with you i don't know

00:53:12,640 --> 00:53:15,839
i don't know that the standard uses them

00:53:14,720 --> 00:53:19,119
interchangeably but i

00:53:15,839 --> 00:53:19,440
i can't imagine that it doesn't um or i

00:53:19,119 --> 00:53:21,760
can't

00:53:19,440 --> 00:53:22,960
i or maybe it uses one or the other and

00:53:21,760 --> 00:53:24,240
i've i've

00:53:22,960 --> 00:53:26,160
i can't remember which one the standard

00:53:24,240 --> 00:53:29,839
uses which one i use but yes i

00:53:26,160 --> 00:53:29,839
i'm using them interchangeably

00:53:30,880 --> 00:53:37,280
okay so this is my this is my favorite

00:53:34,960 --> 00:53:38,640
um type meta function so we just looked

00:53:37,280 --> 00:53:41,359
at specializations right

00:53:38,640 --> 00:53:44,000
at partial specializations this one oh i

00:53:41,359 --> 00:53:44,000
shouldn't have done that

00:53:45,359 --> 00:53:53,200
um so this is conditional now

00:53:49,520 --> 00:53:54,960
this is going to transform a type

00:53:53,200 --> 00:53:57,040
and you're going to get one or the other

00:53:54,960 --> 00:53:59,760
it's basically think of it as like an

00:53:57,040 --> 00:54:02,160
if statement in regular programming you

00:53:59,760 --> 00:54:04,079
have an if statement if some condition

00:54:02,160 --> 00:54:05,839
you know if some condition is true then

00:54:04,079 --> 00:54:09,119
return x

00:54:05,839 --> 00:54:10,160
other else return y in this you can read

00:54:09,119 --> 00:54:13,520
it as

00:54:10,160 --> 00:54:16,559
if this if the condition is true

00:54:13,520 --> 00:54:18,000
if the condition is true if this bull

00:54:16,559 --> 00:54:21,359
condition is true

00:54:18,000 --> 00:54:23,119
return the first type else return

00:54:21,359 --> 00:54:25,920
the second type it's kind of how you can

00:54:23,119 --> 00:54:28,480
read it with stood conditional

00:54:25,920 --> 00:54:29,040
so if this is true i want to return that

00:54:28,480 --> 00:54:31,119
one

00:54:29,040 --> 00:54:32,640
otherwise i'm going to return that one

00:54:31,119 --> 00:54:33,119
and so what we're going to do is we're

00:54:32,640 --> 00:54:38,480
going to

00:54:33,119 --> 00:54:41,760
we're going to specialize

00:54:38,480 --> 00:54:44,319
so there we have there we have our

00:54:41,760 --> 00:54:45,839
our template with the condition and true

00:54:44,319 --> 00:54:47,359
and false and we have our partial

00:54:45,839 --> 00:54:52,960
specialization

00:54:47,359 --> 00:54:56,880
for just t and f note

00:54:52,960 --> 00:54:56,880
oops note right here

00:55:02,079 --> 00:55:05,839
sorry about that i hit the wrong button

00:55:04,160 --> 00:55:08,720
um note right here

00:55:05,839 --> 00:55:09,920
that this partial specialization has it

00:55:08,720 --> 00:55:13,040
still has a t and a f

00:55:09,920 --> 00:55:14,799
because it's taking any two types it'll

00:55:13,040 --> 00:55:16,480
match with any two types it's not

00:55:14,799 --> 00:55:17,599
matching one type now it's matching

00:55:16,480 --> 00:55:20,480
three types

00:55:17,599 --> 00:55:22,240
it's gonna it's gonna actually match one

00:55:20,480 --> 00:55:22,880
non-type template parameter which is a

00:55:22,240 --> 00:55:26,240
bull

00:55:22,880 --> 00:55:30,000
and it's going to match two types

00:55:26,240 --> 00:55:32,799
our general case says for anything i

00:55:30,000 --> 00:55:34,240
for anything i'm going to return true so

00:55:32,799 --> 00:55:35,280
it's assuming that it's going to return

00:55:34,240 --> 00:55:37,440
true

00:55:35,280 --> 00:55:38,880
right it's returning this one so it's

00:55:37,440 --> 00:55:40,559
going to assume that conditional is

00:55:38,880 --> 00:55:43,359
going to return true

00:55:40,559 --> 00:55:45,760
the specialization is when it's false

00:55:43,359 --> 00:55:49,040
and that's why we explicitly say

00:55:45,760 --> 00:55:50,799
when this type is false i want to return

00:55:49,040 --> 00:55:51,040
the second type that you give me which

00:55:50,799 --> 00:55:54,079
is

00:55:51,040 --> 00:55:57,200
f so in here conditional

00:55:54,079 --> 00:55:59,760
if is void i should return int

00:55:57,200 --> 00:56:01,200
and that's what this is saying int

00:55:59,760 --> 00:56:04,400
should be what's returned

00:56:01,200 --> 00:56:06,640
if this is not is void which it's a char

00:56:04,400 --> 00:56:07,440
so this one's going to be false so it's

00:56:06,640 --> 00:56:10,480
going to have

00:56:07,440 --> 00:56:10,480
that specialization

00:56:12,319 --> 00:56:19,040
okay so it's a way of returning a type

00:56:16,079 --> 00:56:20,480
based on a value i don't see any more

00:56:19,040 --> 00:56:23,520
questions

00:56:20,480 --> 00:56:31,760
um let's start on the primary

00:56:23,520 --> 00:56:33,920
uh type categories um

00:56:31,760 --> 00:56:37,200
do i have uh look and see if i had any

00:56:33,920 --> 00:56:37,200
questions it's a good time to take them

00:56:41,760 --> 00:56:44,880
i think i think i'm on it like a

00:56:43,599 --> 00:56:46,160
20-second delay or something so i'm

00:56:44,880 --> 00:56:47,359
going to wait for a few seconds to see

00:56:46,160 --> 00:56:48,559
if i have any questions

00:56:47,359 --> 00:56:50,400
because if i have them this would be a

00:56:48,559 --> 00:56:51,599
good time to take them and then we can

00:56:50,400 --> 00:56:52,720
start here on the next

00:56:51,599 --> 00:56:55,440
on the next go round because it's

00:56:52,720 --> 00:56:58,480
already close to time

00:56:55,440 --> 00:57:00,960
can all type traits and type trades

00:56:58,480 --> 00:57:02,000
be implemented using standard c plus or

00:57:00,960 --> 00:57:03,680
do some of them

00:57:02,000 --> 00:57:05,520
maybe niche ones require compiler

00:57:03,680 --> 00:57:07,280
intrinsics that's a good question and

00:57:05,520 --> 00:57:10,319
we'll actually get to that but yes

00:57:07,280 --> 00:57:12,799
the answer is that

00:57:10,319 --> 00:57:13,680
not all of them can be implemented with

00:57:12,799 --> 00:57:17,599
straight c

00:57:13,680 --> 00:57:20,720
plus the the compiler has

00:57:17,599 --> 00:57:22,960
way more information about

00:57:20,720 --> 00:57:25,200
the type system and about what's going

00:57:22,960 --> 00:57:27,920
on than is exposed

00:57:25,200 --> 00:57:29,440
to the programmer through the language

00:57:27,920 --> 00:57:33,200
though it's gotten much much

00:57:29,440 --> 00:57:36,799
better actually we'll see an example

00:57:33,200 --> 00:57:37,359
later on where we must have compiler

00:57:36,799 --> 00:57:38,960
support

00:57:37,359 --> 00:57:40,319
i own and i really i only put it in

00:57:38,960 --> 00:57:41,760
there for this reason so maybe i'll just

00:57:40,319 --> 00:57:45,119
skip right through the slide

00:57:41,760 --> 00:57:48,000
um um in that

00:57:45,119 --> 00:57:48,880
so is union you need compiler support

00:57:48,000 --> 00:57:51,200
and uh

00:57:48,880 --> 00:57:51,920
um i put it in like as a slide just to

00:57:51,200 --> 00:57:53,200
mention that

00:57:51,920 --> 00:57:55,359
there are some things you have to have

00:57:53,200 --> 00:57:56,480
compiler support for now what's happened

00:57:55,359 --> 00:57:58,160
is that nowadays

00:57:56,480 --> 00:57:59,680
just about every type trait is

00:57:58,160 --> 00:58:01,359
implemented with an intrinsic

00:57:59,680 --> 00:58:03,280
because it's much more efficient for the

00:58:01,359 --> 00:58:04,400
compilers to implement the type traits

00:58:03,280 --> 00:58:06,480
with these intrinsics

00:58:04,400 --> 00:58:07,839
but it's but they're still older

00:58:06,480 --> 00:58:08,799
compilers and depending on which

00:58:07,839 --> 00:58:10,400
compiler you have

00:58:08,799 --> 00:58:12,400
that actually still implement them

00:58:10,400 --> 00:58:14,160
traditional ways and they only implement

00:58:12,400 --> 00:58:15,760
the three or four or five

00:58:14,160 --> 00:58:17,359
i think there's probably four or five

00:58:15,760 --> 00:58:19,440
things that must be implemented by the

00:58:17,359 --> 00:58:21,680
compiler

00:58:19,440 --> 00:58:22,720
and and everything else everything else

00:58:21,680 --> 00:58:26,319
can be implemented

00:58:22,720 --> 00:58:29,440
um within the construct of language

00:58:26,319 --> 00:58:31,520
um will you be covering good and bad use

00:58:29,440 --> 00:58:35,680
cases for template meta programming

00:58:31,520 --> 00:58:37,839
um maybe

00:58:35,680 --> 00:58:39,599
depending on what you mean by that um

00:58:37,839 --> 00:58:40,480
there are there are some obvious bad

00:58:39,599 --> 00:58:42,319
cases

00:58:40,480 --> 00:58:43,440
in that if you're not following the if

00:58:42,319 --> 00:58:44,319
you're not following the conventions

00:58:43,440 --> 00:58:46,079
then that's bad

00:58:44,319 --> 00:58:47,359
i think what you mean are probably like

00:58:46,079 --> 00:58:50,480
uh

00:58:47,359 --> 00:58:52,079
maybe just willy-nilly things and maybe

00:58:50,480 --> 00:58:53,520
you can

00:58:52,079 --> 00:58:55,359
give me a little more example on that

00:58:53,520 --> 00:58:57,839
about good and bad um

00:58:55,359 --> 00:58:58,880
i will be covering good use cases i will

00:58:57,839 --> 00:59:00,960
be showing you

00:58:58,880 --> 00:59:02,640
you know kind of the convention norm of

00:59:00,960 --> 00:59:04,160
how to do things

00:59:02,640 --> 00:59:06,400
i'm not gonna spend too much time

00:59:04,160 --> 00:59:09,440
showing you wrong things

00:59:06,400 --> 00:59:10,079
um uh typically when you do that people

00:59:09,440 --> 00:59:12,319
start

00:59:10,079 --> 00:59:14,079
they learn even more wrong things that

00:59:12,319 --> 00:59:15,440
they could do but if you have specific

00:59:14,079 --> 00:59:18,400
questions about what

00:59:15,440 --> 00:59:20,079
may or may not be good or bad then ask

00:59:18,400 --> 00:59:20,799
them in between the break and i will be

00:59:20,079 --> 00:59:22,799
glad to

00:59:20,799 --> 00:59:25,680
work on that i will be glad to answer

00:59:22,799 --> 00:59:27,359
them in the next session

00:59:25,680 --> 00:59:29,440
so i think i think i think that's it

00:59:27,359 --> 00:59:31,119
unless there's any other questions

00:59:29,440 --> 00:59:32,960
that's the last question on there so i

00:59:31,119 --> 00:59:34,720
think that's it uh thank you very much i

00:59:32,960 --> 00:59:36,640
apologize for the mouse pointer

00:59:34,720 --> 00:59:38,319
and i apologize for uh going backwards

00:59:36,640 --> 00:59:40,079
in the slide several times uh

00:59:38,319 --> 00:59:47,839
hopefully next time we'll be better

00:59:40,079 --> 00:59:47,839
thank you

01:00:00,319 --> 01:00:02,400

YouTube URL: https://www.youtube.com/watch?v=tiAVWcjIF6o


