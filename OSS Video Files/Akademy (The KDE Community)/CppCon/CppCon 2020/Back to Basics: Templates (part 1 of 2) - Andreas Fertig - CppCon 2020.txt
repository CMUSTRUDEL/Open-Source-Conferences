Title: Back to Basics: Templates (part 1 of 2) - Andreas Fertig - CppCon 2020
Publication date: 2020-09-24
Playlist: CppCon 2020
Description: 
	PART 2: https://youtu.be/0dtjDTEE0hQ

https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_templates_part_1/back_to_basics_templates_part_1__andreas_fertig__cppcon_2020.pdf
---

Template Basics
This talk is a two-parter. In the first part we start with the question what is generic programming. I then will introduce the different kinds of templates: function, class and method templates. We will walk through how to write and apply. Along with that we distinguish the different types of template parameters type, and non-type using std::array as an illustration. This is accompanied by a peak behind the scenes by using C++ Insights. This should also give you a valuable tool where you can checkout details for yourself.

At this point we look at alias templates and how they can help us.

Once we covered the basics, we take care that our templates do not bloat the code. For that we use an example of passing an array and a length and optimize this. While on that, we consider at type_traits and incorporate them in our solution. With type_traits we use constexpr if for conditional compile-time code paths.
This session is for developers with C++ experience who have avoided templates so far. After attending this talk, attendees have learned to think in types rather than in values and can write their own templates.

---
Andreas Fertig
Unique Code

Andreas Fertig is the CEO of Unique Code GmbH, which offers training and consulting for C++ specialized in embedded systems. He worked for Philips Medizin Systeme GmbH for ten years as a C++ software developer and architect focusing on embedded systems.

Andreas is involved in the C ++ standardization committee. He is a regular speaker at conferences internationally. Textbooks and articles by Andreas are available in German and English.

Andreas has a passion for teaching people how C++ works, which is why he created C++ Insights (cppinsights.io).

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,519 --> 00:00:14,639
all right everybody

00:00:11,040 --> 00:00:17,680
welcome to this b2b talk

00:00:14,639 --> 00:00:18,240
c plus plus templates it comes in two

00:00:17,680 --> 00:00:21,199
parts

00:00:18,240 --> 00:00:22,400
where now at the first part and directly

00:00:21,199 --> 00:00:25,519
after that

00:00:22,400 --> 00:00:27,519
we will have the second part my name is

00:00:25,519 --> 00:00:31,039
andreas fertig

00:00:27,519 --> 00:00:35,040
i work as a trainer and consultant for

00:00:31,039 --> 00:00:35,280
c plus plus and i'm also the creator of

00:00:35,040 --> 00:00:37,120
c

00:00:35,280 --> 00:00:39,120
plus plus insights if you haven't heard

00:00:37,120 --> 00:00:42,640
about that um

00:00:39,120 --> 00:00:44,800
go and head over to cppinsights.io

00:00:42,640 --> 00:00:46,239
and have a brief look on it or simply

00:00:44,800 --> 00:00:50,640
wait until i use the

00:00:46,239 --> 00:00:50,640
tool during my talk myself

00:00:50,960 --> 00:00:58,000
this is a live virtual conference

00:00:54,559 --> 00:01:00,640
which i think is incredibly great

00:00:58,000 --> 00:01:01,280
that we can have these and john and all

00:01:00,640 --> 00:01:04,320
the crew

00:01:01,280 --> 00:01:05,439
put so much effort into trying to

00:01:04,320 --> 00:01:08,400
recreate

00:01:05,439 --> 00:01:10,400
what we used to have in life or in

00:01:08,400 --> 00:01:13,600
person conferences

00:01:10,400 --> 00:01:16,159
um yet some things are missing so

00:01:13,600 --> 00:01:17,280
for example you cannot see all the

00:01:16,159 --> 00:01:19,119
volunteers

00:01:17,280 --> 00:01:21,200
which are helping behind the scenes

00:01:19,119 --> 00:01:21,680
because now they are completely gone to

00:01:21,200 --> 00:01:23,600
you

00:01:21,680 --> 00:01:25,360
but in fact they are managing all this

00:01:23,600 --> 00:01:28,960
streaming out stuff for me

00:01:25,360 --> 00:01:31,119
such that this live stream can occur

00:01:28,960 --> 00:01:32,400
and you also do not see what john and

00:01:31,119 --> 00:01:34,320
the others do

00:01:32,400 --> 00:01:36,079
to get this thing or keep that thing

00:01:34,320 --> 00:01:38,560
running

00:01:36,079 --> 00:01:39,600
and asking for a round of applause

00:01:38,560 --> 00:01:42,399
wouldn't be

00:01:39,600 --> 00:01:43,119
that much helpful because the people who

00:01:42,399 --> 00:01:45,840
should hear it

00:01:43,119 --> 00:01:46,720
cannot hear it um sadly due to this

00:01:45,840 --> 00:01:49,520
setup

00:01:46,720 --> 00:01:50,479
so the basic idea is what you can do is

00:01:49,520 --> 00:01:53,280
at least one of you

00:01:50,479 --> 00:01:54,079
can start creating one of these

00:01:53,280 --> 00:01:56,640
questions

00:01:54,079 --> 00:01:57,520
and answers and write something in there

00:01:56,640 --> 00:02:01,119
like

00:01:57,520 --> 00:02:02,880
a hand of applause for all the cppcon

00:02:01,119 --> 00:02:05,280
stuff and all the volunteers

00:02:02,880 --> 00:02:06,799
and everybody who likes to jump in there

00:02:05,280 --> 00:02:09,440
just avoided

00:02:06,799 --> 00:02:10,800
to show your appreciation for having the

00:02:09,440 --> 00:02:13,920
opportunity

00:02:10,800 --> 00:02:13,920
about this event

00:02:14,720 --> 00:02:19,440
thank you for that so as i said my name

00:02:18,080 --> 00:02:23,040
is andreas fartik

00:02:19,440 --> 00:02:25,360
and my last name has a meaning in german

00:02:23,040 --> 00:02:27,520
it's an adjective and if you translate

00:02:25,360 --> 00:02:29,840
it into english it comes with

00:02:27,520 --> 00:02:30,560
quite a few meanings attached like

00:02:29,840 --> 00:02:33,599
finished

00:02:30,560 --> 00:02:35,840
ready complete or completed

00:02:33,599 --> 00:02:37,920
keep that in mind i will refer to that

00:02:35,840 --> 00:02:40,560
later

00:02:37,920 --> 00:02:42,879
there's another thing because it's an

00:02:40,560 --> 00:02:43,920
adjective adjectives in german are

00:02:42,879 --> 00:02:47,280
spelled with a

00:02:43,920 --> 00:02:48,800
lower first letter usually so the spell

00:02:47,280 --> 00:02:51,200
checker always

00:02:48,800 --> 00:02:52,959
most of the time at least assumes that

00:02:51,200 --> 00:02:54,879
i'm referring to an adjective when i

00:02:52,959 --> 00:02:56,800
type my own last name

00:02:54,879 --> 00:02:59,040
but the last name goes with the capital

00:02:56,800 --> 00:03:01,040
f as the first letter so i constantly

00:02:59,040 --> 00:03:02,640
fight with the spell checker who's right

00:03:01,040 --> 00:03:05,920
in which situation

00:03:02,640 --> 00:03:07,440
and um you're even here so he catches a

00:03:05,920 --> 00:03:12,239
few of my bugs and

00:03:07,440 --> 00:03:12,239
i am right at the other times

00:03:13,040 --> 00:03:17,360
but today we are here to talk about

00:03:15,360 --> 00:03:18,879
templates and the idea of what is

00:03:17,360 --> 00:03:21,760
generic programming

00:03:18,879 --> 00:03:22,959
and genetic programming i have here a

00:03:21,760 --> 00:03:25,200
couple of phrases

00:03:22,959 --> 00:03:27,840
to describe it there's a method to

00:03:25,200 --> 00:03:30,720
implement algorithms and data structures

00:03:27,840 --> 00:03:31,200
in the most general but still sensible

00:03:30,720 --> 00:03:34,159
way

00:03:31,200 --> 00:03:34,799
so it's a way of abstraction algorithms

00:03:34,159 --> 00:03:37,440
are written

00:03:34,799 --> 00:03:38,000
in terms of types which is specified

00:03:37,440 --> 00:03:39,519
later

00:03:38,000 --> 00:03:41,440
and this is a very interesting thing

00:03:39,519 --> 00:03:43,680
because we are essentially writing

00:03:41,440 --> 00:03:46,400
templates and algorithms for them

00:03:43,680 --> 00:03:49,200
without knowing the exact type

00:03:46,400 --> 00:03:51,040
we have in mind and we use a couple of

00:03:49,200 --> 00:03:53,519
properties of the type

00:03:51,040 --> 00:03:54,959
we may call member functions if we

00:03:53,519 --> 00:03:58,640
expect an object to pass

00:03:54,959 --> 00:04:00,959
in and if that object we are passing in

00:03:58,640 --> 00:04:02,319
sadly doesn't have this member functions

00:04:00,959 --> 00:04:05,920
then we get one of these

00:04:02,319 --> 00:04:07,840
nasty page long or longer compile errors

00:04:05,920 --> 00:04:10,319
resulting from a template instantiation

00:04:07,840 --> 00:04:12,159
but we will talk about this later

00:04:10,319 --> 00:04:14,720
the term generic programming was

00:04:12,159 --> 00:04:16,639
originally coined by david musser and

00:04:14,720 --> 00:04:18,880
alexander stefanov there's a paper

00:04:16,639 --> 00:04:21,199
attached to my slides i will upload them

00:04:18,880 --> 00:04:22,560
after this talk is done or two talks are

00:04:21,199 --> 00:04:25,520
done um

00:04:22,560 --> 00:04:26,080
it's a good read so have a look at it

00:04:25,520 --> 00:04:28,639
and

00:04:26,080 --> 00:04:30,639
generic programming in general helps us

00:04:28,639 --> 00:04:32,800
to reduce redundancy

00:04:30,639 --> 00:04:34,800
and with that programming our thought

00:04:32,800 --> 00:04:36,320
simply because we have to write an

00:04:34,800 --> 00:04:38,800
algorithm only once

00:04:36,320 --> 00:04:40,080
because the types are flexible and we

00:04:38,800 --> 00:04:43,280
can reuse it

00:04:40,080 --> 00:04:46,240
for a set of types which come with the

00:04:43,280 --> 00:04:48,400
same requirements or the same properties

00:04:46,240 --> 00:04:49,199
so this gives us more flexibility and of

00:04:48,400 --> 00:04:51,759
course

00:04:49,199 --> 00:04:53,120
if we happen to catch a bug there we

00:04:51,759 --> 00:04:56,080
have to fix that bug

00:04:53,120 --> 00:04:58,720
only once so that's a another really

00:04:56,080 --> 00:05:01,759
nice thing

00:04:58,720 --> 00:05:04,240
so what are templates templates are a

00:05:01,759 --> 00:05:06,400
kind of pattern for the compiler which

00:05:04,240 --> 00:05:08,880
the compiler fills out

00:05:06,400 --> 00:05:10,000
this process is called instantiation and

00:05:08,880 --> 00:05:12,639
it's a process

00:05:10,000 --> 00:05:14,160
you know very well because without

00:05:12,639 --> 00:05:16,639
filling out a template

00:05:14,160 --> 00:05:17,440
nobody of you would listen to this talk

00:05:16,639 --> 00:05:20,960
because

00:05:17,440 --> 00:05:23,600
to be here even if that may be your home

00:05:20,960 --> 00:05:24,160
but in this live stream or in remo you

00:05:23,600 --> 00:05:28,160
had

00:05:24,160 --> 00:05:31,360
to fill out a disorder form

00:05:28,160 --> 00:05:35,039
for the cpp conference itself

00:05:31,360 --> 00:05:38,400
so this was a template it helps

00:05:35,039 --> 00:05:41,360
the organizers to give to get your data

00:05:38,400 --> 00:05:42,880
in a structured way and it provides you

00:05:41,360 --> 00:05:45,440
with the structure

00:05:42,880 --> 00:05:46,000
of what they need from what they want

00:05:45,440 --> 00:05:49,280
from you

00:05:46,000 --> 00:05:52,000
and so on so templates are

00:05:49,280 --> 00:05:52,880
much like this we can instantiate them

00:05:52,000 --> 00:05:55,280
that's like

00:05:52,880 --> 00:05:57,360
when you fill them out with different

00:05:55,280 --> 00:05:59,680
types of different values so if i

00:05:57,360 --> 00:06:01,520
sign up for the conference i will fill

00:05:59,680 --> 00:06:03,600
in different values than you but

00:06:01,520 --> 00:06:06,160
you can be free to offer me your bank

00:06:03,600 --> 00:06:08,479
account number i can use that of course

00:06:06,160 --> 00:06:09,919
that would be great so each

00:06:08,479 --> 00:06:12,960
instantiation

00:06:09,919 --> 00:06:16,720
of a template comes with a new type

00:06:12,960 --> 00:06:17,520
or a new value if the combination is

00:06:16,720 --> 00:06:20,639
different

00:06:17,520 --> 00:06:23,680
and that will result in

00:06:20,639 --> 00:06:23,680
additional code

00:06:24,080 --> 00:06:27,440
and that sometimes is referred to code

00:06:26,720 --> 00:06:30,080
bloating

00:06:27,440 --> 00:06:30,560
because people see that they have

00:06:30,080 --> 00:06:33,280
written

00:06:30,560 --> 00:06:35,120
only one template and now they are

00:06:33,280 --> 00:06:37,280
getting three

00:06:35,120 --> 00:06:39,360
different versions of a function out and

00:06:37,280 --> 00:06:41,440
they often overlook the fact that this

00:06:39,360 --> 00:06:43,120
is similar to what they have done

00:06:41,440 --> 00:06:45,759
if they would have written the code

00:06:43,120 --> 00:06:49,039
themselves three times but

00:06:45,759 --> 00:06:50,000
with three different types so we will

00:06:49,039 --> 00:06:53,599
also look in

00:06:50,000 --> 00:06:56,560
to this and templates reduce

00:06:53,599 --> 00:06:57,039
a lot of writer's work because of what

00:06:56,560 --> 00:06:59,360
was

00:06:57,039 --> 00:07:00,080
what i have said previously they help us

00:06:59,360 --> 00:07:02,160
to implement

00:07:00,080 --> 00:07:03,520
functions only once but use them

00:07:02,160 --> 00:07:06,160
multiple times

00:07:03,520 --> 00:07:07,440
but with a slightly different type and

00:07:06,160 --> 00:07:09,280
we will see that

00:07:07,440 --> 00:07:10,800
when we are talking about types because

00:07:09,280 --> 00:07:12,800
they are known to the compiler at

00:07:10,800 --> 00:07:15,360
compile time

00:07:12,800 --> 00:07:16,639
we can even query properties of these

00:07:15,360 --> 00:07:20,160
type and if we have

00:07:16,639 --> 00:07:22,720
only a slider version then we can

00:07:20,160 --> 00:07:24,160
even in one function say okay we do an

00:07:22,720 --> 00:07:26,000
exception for that type

00:07:24,160 --> 00:07:28,080
we call the different member functions

00:07:26,000 --> 00:07:31,039
or function or whatsoever so

00:07:28,080 --> 00:07:33,039
we can do a lot of these things because

00:07:31,039 --> 00:07:36,479
types are known at compile time

00:07:33,039 --> 00:07:38,639
which is very helpful here then there

00:07:36,479 --> 00:07:40,160
we have three different types of

00:07:38,639 --> 00:07:42,080
templates roughly

00:07:40,160 --> 00:07:44,960
we have function templates we have class

00:07:42,080 --> 00:07:48,000
templates and we have cincy plus plus

00:07:44,960 --> 00:07:50,479
14 variable templates

00:07:48,000 --> 00:07:51,199
the key thing here if you're talking to

00:07:50,479 --> 00:07:54,560
someone

00:07:51,199 --> 00:07:56,960
is it always starts with type and this

00:07:54,560 --> 00:07:58,479
followed by template okay we have

00:07:56,960 --> 00:07:59,280
function templates we have class

00:07:58,479 --> 00:08:01,759
templates

00:07:59,280 --> 00:08:03,039
we don't have template functions or

00:08:01,759 --> 00:08:05,599
template classes

00:08:03,039 --> 00:08:08,080
there's no such thing like this walter

00:08:05,599 --> 00:08:11,680
brown gave a good talk um

00:08:08,080 --> 00:08:12,080
i don't remember a few years ago at cpp

00:08:11,680 --> 00:08:14,080
con

00:08:12,080 --> 00:08:16,400
it may have been a lightning talk where

00:08:14,080 --> 00:08:17,120
i teased into that and compared it with

00:08:16,400 --> 00:08:18,960
some

00:08:17,120 --> 00:08:20,400
chocolate milk and milk chocolate the

00:08:18,960 --> 00:08:22,720
one thing we have the other thing we

00:08:20,400 --> 00:08:22,720
don't

00:08:23,840 --> 00:08:27,360
templates in general are always

00:08:25,599 --> 00:08:30,639
initiated by the keyword

00:08:27,360 --> 00:08:31,840
template you can spot them easily there

00:08:30,639 --> 00:08:34,640
because they all the time

00:08:31,840 --> 00:08:36,719
need to start with that keyword followed

00:08:34,640 --> 00:08:39,680
by ankle brackets

00:08:36,719 --> 00:08:42,399
so don't get scared away by that it's

00:08:39,680 --> 00:08:42,399
fairly easy

00:08:43,440 --> 00:08:46,640
aside from the different types of

00:08:45,120 --> 00:08:49,279
templates we have

00:08:46,640 --> 00:08:50,800
different kinds of template parameters

00:08:49,279 --> 00:08:51,839
and to be precise we have three

00:08:50,800 --> 00:08:54,959
different types

00:08:51,839 --> 00:08:55,440
we have type parameters which may be the

00:08:54,959 --> 00:08:58,959
most

00:08:55,440 --> 00:09:02,800
commonly used type at least in my daily

00:08:58,959 --> 00:09:05,360
use and that's the case whenever we are

00:09:02,800 --> 00:09:06,160
trying to substitute a concrete type

00:09:05,360 --> 00:09:09,440
like a jar

00:09:06,160 --> 00:09:11,279
an end or even our own class

00:09:09,440 --> 00:09:13,040
then we are talking about the type

00:09:11,279 --> 00:09:14,320
parameter because essentially we are

00:09:13,040 --> 00:09:17,040
passing in a type

00:09:14,320 --> 00:09:18,240
and we will work with that type later in

00:09:17,040 --> 00:09:21,600
the class or

00:09:18,240 --> 00:09:22,959
function then we have non-type template

00:09:21,600 --> 00:09:26,480
parameters

00:09:22,959 --> 00:09:30,080
there are often values like 3

00:09:26,480 --> 00:09:33,120
42 something like this

00:09:30,080 --> 00:09:36,000
a few things are excluded so we

00:09:33,120 --> 00:09:38,000
cannot pass in floating point numbers or

00:09:36,000 --> 00:09:41,360
strings in terms of

00:09:38,000 --> 00:09:43,839
c style strings or c arrays and

00:09:41,360 --> 00:09:45,040
some of these restrictions are lifted

00:09:43,839 --> 00:09:47,360
since we have c

00:09:45,040 --> 00:09:48,959
plus plus 20 which if you shouldn't know

00:09:47,360 --> 00:09:50,959
that we have since

00:09:48,959 --> 00:09:52,320
a week ago or something like that

00:09:50,959 --> 00:09:55,760
officially now

00:09:52,320 --> 00:09:57,760
and they make a lot of this or

00:09:55,760 --> 00:09:58,800
at least some of these limitations go

00:09:57,760 --> 00:10:01,040
away

00:09:58,800 --> 00:10:02,800
and then we have a certain type of

00:10:01,040 --> 00:10:05,440
template parameters and

00:10:02,800 --> 00:10:06,640
if you happen to not use that type for a

00:10:05,440 --> 00:10:08,720
long time or

00:10:06,640 --> 00:10:10,240
never stumbled over it i think that's

00:10:08,720 --> 00:10:14,399
all right it's a template

00:10:10,240 --> 00:10:18,240
template parameter and require that

00:10:14,399 --> 00:10:20,959
every time you're passing a template

00:10:18,240 --> 00:10:21,760
to a parameter of a template itself so

00:10:20,959 --> 00:10:23,440
it's it's like

00:10:21,760 --> 00:10:26,079
passing a template to a template

00:10:23,440 --> 00:10:29,200
essentially and then we need to prefix

00:10:26,079 --> 00:10:33,839
that thing with another template we will

00:10:29,200 --> 00:10:33,839
see that in the second part of the talk

00:10:39,200 --> 00:10:42,480
so after all that introduction here's a

00:10:41,519 --> 00:10:46,160
first

00:10:42,480 --> 00:10:49,120
sample of how templates look

00:10:46,160 --> 00:10:51,040
it all starts with the template head as

00:10:49,120 --> 00:10:53,040
it's shown here in a

00:10:51,040 --> 00:10:55,120
it's introduced by the template keyword

00:10:53,040 --> 00:10:57,279
followed by the opening enter bracket

00:10:55,120 --> 00:11:00,720
and closed by the ankle bracket

00:10:57,279 --> 00:11:04,560
in line number three inside

00:11:00,720 --> 00:11:07,200
these ankle brackets we now can specify

00:11:04,560 --> 00:11:08,640
type parameters non-type parameters or

00:11:07,200 --> 00:11:10,959
template

00:11:08,640 --> 00:11:12,959
template parameters in this case here

00:11:10,959 --> 00:11:15,760
i'm using a type parameter

00:11:12,959 --> 00:11:17,760
i give that thing a name it's t and i

00:11:15,760 --> 00:11:18,640
have a non-type template parameter as

00:11:17,760 --> 00:11:22,000
you can see in

00:11:18,640 --> 00:11:25,440
c which is of type size t

00:11:22,000 --> 00:11:27,920
and i give that the name n and then next

00:11:25,440 --> 00:11:28,800
we can see i'm creating a function

00:11:27,920 --> 00:11:31,360
template here

00:11:28,800 --> 00:11:32,240
it's name is size it's constexpr and

00:11:31,360 --> 00:11:35,519
returns

00:11:32,240 --> 00:11:36,800
auto and what it takes is it takes

00:11:35,519 --> 00:11:40,800
something special

00:11:36,800 --> 00:11:43,440
it takes a const t so my t is the one i

00:11:40,800 --> 00:11:45,360
declared in b above in the template so

00:11:43,440 --> 00:11:47,680
this is deduced by the compiler

00:11:45,360 --> 00:11:50,000
and then it takes essentially an unnamed

00:11:47,680 --> 00:11:52,720
variable on a parameter here

00:11:50,000 --> 00:11:53,279
by reference and it expects that that

00:11:52,720 --> 00:11:56,800
thing

00:11:53,279 --> 00:11:58,720
is an array this is the syntax here and

00:11:56,800 --> 00:12:01,200
the size of this array is deduced by the

00:11:58,720 --> 00:12:04,320
compiler which

00:12:01,200 --> 00:12:05,519
you can see because i'm using n here the

00:12:04,320 --> 00:12:07,519
size t variable

00:12:05,519 --> 00:12:08,959
which the compiler is able to deduce for

00:12:07,519 --> 00:12:12,639
me this is a way

00:12:08,959 --> 00:12:14,959
how we can manage to maintain

00:12:12,639 --> 00:12:17,200
the arrayness of an array while passing

00:12:14,959 --> 00:12:19,680
it to a function and not let it decay

00:12:17,200 --> 00:12:20,399
to a pointer what this function next

00:12:19,680 --> 00:12:23,200
then does

00:12:20,399 --> 00:12:24,480
is simply return n so the size of this

00:12:23,200 --> 00:12:27,040
array is the reason

00:12:24,480 --> 00:12:29,040
why the parameter has no name here i i

00:12:27,040 --> 00:12:31,440
don't actually need to refer to that

00:12:29,040 --> 00:12:33,760
i only need to size and what i can do

00:12:31,440 --> 00:12:36,000
then is i can use this

00:12:33,760 --> 00:12:39,279
in conjunction with this jar buffer in

00:12:36,000 --> 00:12:42,000
line 12 and 15 in this raw for loop

00:12:39,279 --> 00:12:44,240
and i can query the size of these

00:12:42,000 --> 00:12:45,839
buffers of this char array

00:12:44,240 --> 00:12:47,680
and let the compiler do the heavy

00:12:45,839 --> 00:12:49,920
lifting so there are no size offs

00:12:47,680 --> 00:12:50,800
involved no size of divided by another

00:12:49,920 --> 00:12:52,720
size of

00:12:50,800 --> 00:12:54,160
which then goes awfully is still wrong

00:12:52,720 --> 00:12:55,040
if you're passing in an array of

00:12:54,160 --> 00:12:58,399
pointers

00:12:55,040 --> 00:12:59,200
things like that so this is a very good

00:12:58,399 --> 00:13:02,240
way

00:12:59,200 --> 00:13:05,360
of handling this

00:13:02,240 --> 00:13:07,839
but part me for using a range space or a

00:13:05,360 --> 00:13:10,639
regular for loop here you should refer

00:13:07,839 --> 00:13:13,120
to a range base for loop usually i say

00:13:10,639 --> 00:13:14,800
don't do that at work only do it at home

00:13:13,120 --> 00:13:17,519
but as these times

00:13:14,800 --> 00:13:18,079
home is work don't even try it out at

00:13:17,519 --> 00:13:20,320
home

00:13:18,079 --> 00:13:22,639
use the range base for loop as long as

00:13:20,320 --> 00:13:26,560
you can this is for some special cases

00:13:22,639 --> 00:13:26,560
but it shows the power of templates

00:13:30,480 --> 00:13:33,680
so we already see in the function

00:13:32,240 --> 00:13:35,519
template

00:13:33,680 --> 00:13:37,360
here's another version of a function

00:13:35,519 --> 00:13:38,959
template at the right we have this code

00:13:37,360 --> 00:13:40,399
example where i'm creating a function

00:13:38,959 --> 00:13:43,600
template called min

00:13:40,399 --> 00:13:46,000
it takes a type name t single t

00:13:43,600 --> 00:13:47,199
and this arguments for this function it

00:13:46,000 --> 00:13:50,800
takes a and b

00:13:47,199 --> 00:13:52,720
both are of type const t ref so both are

00:13:50,800 --> 00:13:54,959
references of this type t

00:13:52,720 --> 00:13:56,320
i'm instantiating this template with or

00:13:54,959 --> 00:13:58,800
i'm calling it with

00:13:56,320 --> 00:13:59,920
and internally what it does then is it

00:13:58,800 --> 00:14:02,240
compares a and b

00:13:59,920 --> 00:14:02,959
and figures out which one is a smaller

00:14:02,240 --> 00:14:06,079
value

00:14:02,959 --> 00:14:07,199
and returns that one down the return

00:14:06,079 --> 00:14:09,839
type of min

00:14:07,199 --> 00:14:12,480
is t as well so everything depends on

00:14:09,839 --> 00:14:12,480
that type

00:14:12,560 --> 00:14:16,320
looking down here how i'm using it from

00:14:15,680 --> 00:14:19,040
the

00:14:16,320 --> 00:14:20,480
user's perspective side in line 12 i can

00:14:19,040 --> 00:14:23,360
simply call min

00:14:20,480 --> 00:14:25,360
parsing the variables a and b to it and

00:14:23,360 --> 00:14:28,639
nobody will notice that i just

00:14:25,360 --> 00:14:30,320
invoked or called the template

00:14:28,639 --> 00:14:33,199
as long as you're passing in the right

00:14:30,320 --> 00:14:35,279
parameter combination

00:14:33,199 --> 00:14:37,199
there are now a few specialties involved

00:14:35,279 --> 00:14:39,760
when it comes to templates

00:14:37,199 --> 00:14:40,480
because this thing here only compiles

00:14:39,760 --> 00:14:43,920
with

00:14:40,480 --> 00:14:45,360
a set of integers because i said that my

00:14:43,920 --> 00:14:48,320
function template takes

00:14:45,360 --> 00:14:50,240
two t's and if it comes to templates

00:14:48,320 --> 00:14:52,959
there are no implicit conversions

00:14:50,240 --> 00:14:53,440
so the compiler expects that both a and

00:14:52,959 --> 00:14:55,760
b

00:14:53,440 --> 00:14:57,199
are of the same type and a is the

00:14:55,760 --> 00:15:00,399
leading one here

00:14:57,199 --> 00:15:01,839
so if a is of type and b as of has to be

00:15:00,399 --> 00:15:05,120
of type int as well

00:15:01,839 --> 00:15:06,880
and so has to return value or the return

00:15:05,120 --> 00:15:08,639
type

00:15:06,880 --> 00:15:10,160
i will now switch over to c plus

00:15:08,639 --> 00:15:12,959
insights well now

00:15:10,160 --> 00:15:16,880
let's do the next thing first this is

00:15:12,959 --> 00:15:18,560
how a template instantiation looks like

00:15:16,880 --> 00:15:20,480
and this is what c plus plus insights

00:15:18,560 --> 00:15:22,000
shows you and what we will see in a

00:15:20,480 --> 00:15:25,040
minute live

00:15:22,000 --> 00:15:26,959
so from the former example i know look

00:15:25,040 --> 00:15:29,279
behind the scenes what happens if i

00:15:26,959 --> 00:15:31,360
instantiate such a template

00:15:29,279 --> 00:15:33,680
and what we can see is that essentially

00:15:31,360 --> 00:15:36,160
the compiler makes up

00:15:33,680 --> 00:15:36,959
the template function which we provided

00:15:36,160 --> 00:15:40,560
it with

00:15:36,959 --> 00:15:42,639
and fills in the types in my case

00:15:40,560 --> 00:15:43,600
int all over the place we can see in

00:15:42,639 --> 00:15:47,440
line number 10

00:15:43,600 --> 00:15:50,320
return value is in a return type is in

00:15:47,440 --> 00:15:52,639
the two parameters a and b are of type

00:15:50,320 --> 00:15:55,440
const in draft because we are calling it

00:15:52,639 --> 00:15:57,279
within it

00:15:55,440 --> 00:15:58,720
and if you look at this in c plus plus

00:15:57,279 --> 00:16:02,160
insides

00:15:58,720 --> 00:16:03,519
which we have here and i don't want to

00:16:02,160 --> 00:16:05,440
update

00:16:03,519 --> 00:16:06,560
and if i do the transformation here then

00:16:05,440 --> 00:16:08,959
we can in fact see

00:16:06,560 --> 00:16:09,680
that's the very same thing as we saw

00:16:08,959 --> 00:16:12,160
before

00:16:09,680 --> 00:16:14,320
c plus plus insides in that case even

00:16:12,160 --> 00:16:16,639
tells us where this instantiation comes

00:16:14,320 --> 00:16:18,800
from but it seems to be awfully wrong

00:16:16,639 --> 00:16:20,000
if you're looking at the right you have

00:16:18,800 --> 00:16:23,040
to

00:16:20,000 --> 00:16:25,680
i have to remove that here

00:16:23,040 --> 00:16:25,680
it gets better

00:16:26,160 --> 00:16:30,160
we do the transformation once again but

00:16:27,920 --> 00:16:31,920
without providing the specialization

00:16:30,160 --> 00:16:34,240
then now we can see it comes from line

00:16:31,920 --> 00:16:35,600
number 16 and line number 16 here is my

00:16:34,240 --> 00:16:37,440
printf

00:16:35,600 --> 00:16:39,279
and what i told you before is if i

00:16:37,440 --> 00:16:42,399
change types here even if i

00:16:39,279 --> 00:16:45,040
simply make that a short which usually

00:16:42,399 --> 00:16:46,800
would result in an integer promotion

00:16:45,040 --> 00:16:48,800
then the compiler will say oh no

00:16:46,800 --> 00:16:50,000
there is no matching function to call

00:16:48,800 --> 00:16:52,639
min because

00:16:50,000 --> 00:16:53,839
you provided me with an internet short

00:16:52,639 --> 00:16:56,880
but you're claiming

00:16:53,839 --> 00:16:59,759
that both have to fit in t and

00:16:56,880 --> 00:17:01,519
t is initially deduced as in so your

00:16:59,759 --> 00:17:04,000
short doesn't match here

00:17:01,519 --> 00:17:07,039
there are no implicit conversions when

00:17:04,000 --> 00:17:10,160
you're calling templates like this

00:17:07,039 --> 00:17:19,839
all right are there any questions

00:17:10,160 --> 00:17:19,839
so far

00:17:20,880 --> 00:17:26,240
all right none so far let's continue

00:17:28,720 --> 00:17:32,960
so we halfway saw this what c plus plus

00:17:32,400 --> 00:17:35,840
inside

00:17:32,960 --> 00:17:38,320
shows us here for an instantiation we

00:17:35,840 --> 00:17:40,160
can also call a specialization because

00:17:38,320 --> 00:17:41,919
there's a special case for an int the

00:17:40,160 --> 00:17:42,720
compiler makes up here because we are

00:17:41,919 --> 00:17:46,240
requesting

00:17:42,720 --> 00:17:49,600
it we can provide specializations

00:17:46,240 --> 00:17:52,160
on our own and that's for another good

00:17:49,600 --> 00:17:53,679
here i have a different example i have a

00:17:52,160 --> 00:17:55,840
function called equal

00:17:53,679 --> 00:17:57,120
which returns a bool it's a function

00:17:55,840 --> 00:17:59,600
template taking

00:17:57,120 --> 00:18:00,480
once again two template parameters or

00:17:59,600 --> 00:18:03,919
two

00:18:00,480 --> 00:18:07,520
parameters one template parameters

00:18:03,919 --> 00:18:10,400
and there are

00:18:07,520 --> 00:18:12,960
once again const traff what a function

00:18:10,400 --> 00:18:16,000
does is it

00:18:12,960 --> 00:18:18,480
just compares a and b for equality

00:18:16,000 --> 00:18:20,080
and returns that result so that function

00:18:18,480 --> 00:18:21,360
template essentially works with

00:18:20,080 --> 00:18:23,520
everything that provides

00:18:21,360 --> 00:18:24,799
an equal operator so even for a stood

00:18:23,520 --> 00:18:29,679
string

00:18:24,799 --> 00:18:32,720
below i'm using it first with an end

00:18:29,679 --> 00:18:35,360
in lines number 15 and 16.

00:18:32,720 --> 00:18:37,360
but there is also a specialization and

00:18:35,360 --> 00:18:38,320
that specialization you can see in line

00:18:37,360 --> 00:18:40,720
number eight

00:18:38,320 --> 00:18:41,840
and there i'm providing a specialization

00:18:40,720 --> 00:18:43,360
for double

00:18:41,840 --> 00:18:44,960
because you all might have heard that

00:18:43,360 --> 00:18:46,960
they'll learn that in your computer

00:18:44,960 --> 00:18:49,039
science class

00:18:46,960 --> 00:18:51,440
floating point numbers have to be

00:18:49,039 --> 00:18:55,200
treated a little bit different because

00:18:51,440 --> 00:18:56,720
of their um way there they are modeled

00:18:55,200 --> 00:19:00,080
internally

00:18:56,720 --> 00:19:01,440
they may only slightly and a few bytes

00:19:00,080 --> 00:19:05,120
behind our bits

00:19:01,440 --> 00:19:08,240
differ and it may be enough for your

00:19:05,120 --> 00:19:10,720
um purpose but you all

00:19:08,240 --> 00:19:12,080
most of the time don't need to be floats

00:19:10,720 --> 00:19:14,160
exactly the same

00:19:12,080 --> 00:19:15,679
bit pattern so when you're asking

00:19:14,160 --> 00:19:18,720
whether two floats are

00:19:15,679 --> 00:19:20,240
equal or two doubles then usually you're

00:19:18,720 --> 00:19:23,280
referring to a k

00:19:20,240 --> 00:19:25,440
up to to a certain quantity the rest i

00:19:23,280 --> 00:19:26,480
i don't really care about this and this

00:19:25,440 --> 00:19:28,080
is what this

00:19:26,480 --> 00:19:30,880
second equal function does this

00:19:28,080 --> 00:19:33,679
specialization here it's a special case

00:19:30,880 --> 00:19:35,200
for when we are having a double then we

00:19:33,679 --> 00:19:37,360
are doing this

00:19:35,200 --> 00:19:39,280
a minus b and building the absolute

00:19:37,360 --> 00:19:40,400
value of it so keeping it positive and

00:19:39,280 --> 00:19:43,280
then comparing

00:19:40,400 --> 00:19:44,720
whether the result of this is still less

00:19:43,280 --> 00:19:48,480
than a certain threshold

00:19:44,720 --> 00:19:49,120
and if so then we simply return that

00:19:48,480 --> 00:19:51,120
result

00:19:49,120 --> 00:19:52,240
it's either true or false even if it's

00:19:51,120 --> 00:19:55,679
not the case

00:19:52,240 --> 00:19:58,880
and by that i'm making this

00:19:55,679 --> 00:20:01,520
equal function work even for doubles

00:19:58,880 --> 00:20:01,520
correctly

00:20:04,159 --> 00:20:08,559
so now i see we have one question here

00:20:06,720 --> 00:20:10,000
and the question is are there special

00:20:08,559 --> 00:20:13,120
conditions for

00:20:10,000 --> 00:20:15,679
custom types and that would be a

00:20:13,120 --> 00:20:18,159
good question where i would like a live

00:20:15,679 --> 00:20:22,799
audience because then i can ask back

00:20:18,159 --> 00:20:25,679
what exactly do you mean by that um

00:20:22,799 --> 00:20:26,799
maybe whoever asked that question can

00:20:25,679 --> 00:20:30,640
provide a little bit of

00:20:26,799 --> 00:20:33,760
more context to which slide it refers

00:20:30,640 --> 00:20:34,640
or what special conditions you are

00:20:33,760 --> 00:20:36,720
meaning or

00:20:34,640 --> 00:20:38,559
simply come after the second torque to

00:20:36,720 --> 00:20:41,120
the q a i think i will be

00:20:38,559 --> 00:20:41,840
there at some remote table and you can

00:20:41,120 --> 00:20:44,799
ask me

00:20:41,840 --> 00:20:44,799
live directly

00:20:46,400 --> 00:20:51,960
all right

00:20:49,520 --> 00:20:54,960
this is so far about our template

00:20:51,960 --> 00:20:54,960
specializations

00:20:55,440 --> 00:21:02,799
and aside from function templates we

00:20:59,440 --> 00:21:03,600
can also have class templates this here

00:21:02,799 --> 00:21:07,919
is a

00:21:03,600 --> 00:21:09,840
example of a class template and

00:21:07,919 --> 00:21:11,280
class templates are more or less like

00:21:09,840 --> 00:21:13,200
function templates so

00:21:11,280 --> 00:21:16,880
a lot of rules from function templates

00:21:13,200 --> 00:21:19,360
apply to class templates as well

00:21:16,880 --> 00:21:21,520
there are a few differences so class

00:21:19,360 --> 00:21:23,600
templates are introduced by the keyword

00:21:21,520 --> 00:21:26,320
template and the angle brackets as every

00:21:23,600 --> 00:21:26,320
other template

00:21:27,360 --> 00:21:31,600
the special case where one of the

00:21:29,840 --> 00:21:36,480
special cases at least

00:21:31,600 --> 00:21:39,919
kicks in if you're talking about

00:21:36,480 --> 00:21:44,240
what methods of a class in

00:21:39,919 --> 00:21:46,080
this term methods of a class template

00:21:44,240 --> 00:21:47,440
what i mean and how they are implemented

00:21:46,080 --> 00:21:48,320
so if you're looking at function

00:21:47,440 --> 00:21:50,559
templates

00:21:48,320 --> 00:21:52,080
you can only implement function

00:21:50,559 --> 00:21:55,039
templates

00:21:52,080 --> 00:21:56,400
at global scope we can put it in a

00:21:55,039 --> 00:22:00,000
namespace but

00:21:56,400 --> 00:22:01,520
that's it if we have a class template

00:22:00,000 --> 00:22:03,600
and methods in there

00:22:01,520 --> 00:22:05,679
for a regular class we can choose

00:22:03,600 --> 00:22:08,320
whether we like to implement

00:22:05,679 --> 00:22:10,000
that method in lines or in the class or

00:22:08,320 --> 00:22:11,919
outside of the class

00:22:10,000 --> 00:22:13,520
and we can of course do the same thing

00:22:11,919 --> 00:22:16,720
or we have the same choice

00:22:13,520 --> 00:22:20,080
if you're talking about class templates

00:22:16,720 --> 00:22:22,799
and if we are deciding to

00:22:20,080 --> 00:22:24,000
provide the implementation inline for a

00:22:22,799 --> 00:22:27,200
class template

00:22:24,000 --> 00:22:30,880
then things are still fairly triple

00:22:27,200 --> 00:22:33,760
like for a usual non-template class

00:22:30,880 --> 00:22:34,799
so in my case here i have this array

00:22:33,760 --> 00:22:37,280
struct

00:22:34,799 --> 00:22:39,280
it is a class template it takes two

00:22:37,280 --> 00:22:42,880
parameters the type name t

00:22:39,280 --> 00:22:45,120
and a size t called size

00:22:42,880 --> 00:22:47,520
so first one is once again a type

00:22:45,120 --> 00:22:50,480
parameter second one is a num type

00:22:47,520 --> 00:22:50,960
template parameter and what is thing

00:22:50,480 --> 00:22:52,880
here

00:22:50,960 --> 00:22:54,080
models is what you're finding in the

00:22:52,880 --> 00:22:56,880
standard

00:22:54,080 --> 00:22:58,880
which is called study rate there it's

00:22:56,880 --> 00:23:01,679
just a downstripped version of it

00:22:58,880 --> 00:23:04,559
but it roughly does the same thing it

00:23:01,679 --> 00:23:06,799
for example has the two methods data

00:23:04,559 --> 00:23:08,320
one is cons the other one is non-const

00:23:06,799 --> 00:23:10,240
and what they are doing

00:23:08,320 --> 00:23:11,760
is they are returning a pointer to the

00:23:10,240 --> 00:23:14,400
first element of the

00:23:11,760 --> 00:23:15,679
m data field which you find below in

00:23:14,400 --> 00:23:18,159
line number 15

00:23:15,679 --> 00:23:20,080
that's the member of this array or field

00:23:18,159 --> 00:23:21,039
of this array it's of size size so the

00:23:20,080 --> 00:23:23,440
compiler

00:23:21,039 --> 00:23:24,080
fills in the size we are specifying for

00:23:23,440 --> 00:23:26,320
it and

00:23:24,080 --> 00:23:27,280
it's of type t that's another thing we

00:23:26,320 --> 00:23:30,720
are specifying

00:23:27,280 --> 00:23:32,799
for this class template and then it has

00:23:30,720 --> 00:23:35,039
a couple of other helper functions

00:23:32,799 --> 00:23:36,320
like size so we can ask it for the size

00:23:35,039 --> 00:23:38,559
and as you can see

00:23:36,320 --> 00:23:39,919
this once again refers to the non-type

00:23:38,559 --> 00:23:43,440
template parameter

00:23:39,919 --> 00:23:44,159
so there is no way that we can mess that

00:23:43,440 --> 00:23:47,520
up and

00:23:44,159 --> 00:23:49,520
have the same size to the array so there

00:23:47,520 --> 00:23:50,320
are no risks of a buffer over buffer

00:23:49,520 --> 00:23:52,799
underflow

00:23:50,320 --> 00:23:54,559
as long as your respect to size that is

00:23:52,799 --> 00:23:57,279
returned by this

00:23:54,559 --> 00:23:58,799
array class then we have the two other

00:23:57,279 --> 00:24:02,000
methods begin and end

00:23:58,799 --> 00:24:05,600
and of course an index operator to get a

00:24:02,000 --> 00:24:08,320
single element out of this array

00:24:05,600 --> 00:24:10,880
if you're looking closely i do different

00:24:08,320 --> 00:24:13,760
things for the two data methods

00:24:10,880 --> 00:24:16,080
so one of the data methods the one for

00:24:13,760 --> 00:24:16,559
the non-const case is implemented out of

00:24:16,080 --> 00:24:19,039
line

00:24:16,559 --> 00:24:19,840
it's implemented below the class while

00:24:19,039 --> 00:24:22,159
the one

00:24:19,840 --> 00:24:23,360
using the const version is implemented

00:24:22,159 --> 00:24:25,039
directly in the class

00:24:23,360 --> 00:24:26,559
and as you can see in line number six

00:24:25,039 --> 00:24:28,400
for the const version

00:24:26,559 --> 00:24:31,360
this is straightforward you implement

00:24:28,400 --> 00:24:34,159
the method like you would always do it

00:24:31,360 --> 00:24:34,880
the slightly special case kicks in for

00:24:34,159 --> 00:24:37,600
the

00:24:34,880 --> 00:24:39,279
implementation of the out-of-line data

00:24:37,600 --> 00:24:41,360
method in line number five

00:24:39,279 --> 00:24:42,320
because this is shown below in line

00:24:41,360 --> 00:24:45,600
number 18

00:24:42,320 --> 00:24:48,640
to 22. and what we have to do

00:24:45,600 --> 00:24:51,200
there is we have to tell the compiler

00:24:48,640 --> 00:24:52,960
for which class exactly this is because

00:24:51,200 --> 00:24:53,679
we are now talking about the class

00:24:52,960 --> 00:24:56,320
template

00:24:53,679 --> 00:24:57,200
so we have once again say okay this is a

00:24:56,320 --> 00:25:01,520
template

00:24:57,200 --> 00:25:03,600
and we have to reiterate over the

00:25:01,520 --> 00:25:06,159
parameters or the arguments this

00:25:03,600 --> 00:25:10,080
template takes so we say type name t

00:25:06,159 --> 00:25:12,640
size t size and then it returns the t

00:25:10,080 --> 00:25:13,120
star that would be the same as we would

00:25:12,640 --> 00:25:16,880
write

00:25:13,120 --> 00:25:17,520
for a non-class for a non-class template

00:25:16,880 --> 00:25:20,640
yes

00:25:17,520 --> 00:25:22,640
and then we have to specify the name

00:25:20,640 --> 00:25:23,919
space again so that's the scope of the

00:25:22,640 --> 00:25:26,480
class we say array

00:25:23,919 --> 00:25:28,720
but this time we have to be specific and

00:25:26,480 --> 00:25:30,880
say in the anchor brackets that it's for

00:25:28,720 --> 00:25:31,840
t and size such that the compiler can

00:25:30,880 --> 00:25:35,440
map this

00:25:31,840 --> 00:25:39,760
and create the appropriate function or

00:25:35,440 --> 00:25:43,120
class method for us i'm seeing

00:25:39,760 --> 00:25:47,520
a couple of other questions dropping in

00:25:43,120 --> 00:25:48,880
so are there requirements that are

00:25:47,520 --> 00:25:51,919
placed on custom

00:25:48,880 --> 00:25:54,559
types say a dot h

00:25:51,919 --> 00:25:57,840
if instead of an indoor string or a

00:25:54,559 --> 00:25:57,840
string primitive type

00:25:58,799 --> 00:26:02,000
i'm not sure if i'm getting this

00:26:00,480 --> 00:26:04,080
question right so i think it's a

00:26:02,000 --> 00:26:06,080
clarification for the formal questions

00:26:04,080 --> 00:26:06,960
are there special conditions for custom

00:26:06,080 --> 00:26:10,000
types

00:26:06,960 --> 00:26:14,240
and there are no special conditions for

00:26:10,000 --> 00:26:16,640
custom types i can think of the only

00:26:14,240 --> 00:26:18,720
special thing but that's the same for

00:26:16,640 --> 00:26:23,440
your standard library

00:26:18,720 --> 00:26:25,679
is that you have to

00:26:23,440 --> 00:26:28,559
provide the com compiler the full

00:26:25,679 --> 00:26:30,159
picture so the compiler needs to see

00:26:28,559 --> 00:26:31,919
that entire template it needs to

00:26:30,159 --> 00:26:34,000
instantiate because

00:26:31,919 --> 00:26:34,960
it needs to instantiate it so you cannot

00:26:34,000 --> 00:26:37,919
hide

00:26:34,960 --> 00:26:39,520
some parts in the cpp file and have the

00:26:37,919 --> 00:26:41,279
other parts in a header file

00:26:39,520 --> 00:26:43,039
so usually when it comes to templates

00:26:41,279 --> 00:26:43,679
you either have everything in the header

00:26:43,039 --> 00:26:46,000
file

00:26:43,679 --> 00:26:47,919
because you have multiple users or you

00:26:46,000 --> 00:26:50,559
only have it in the cpp file

00:26:47,919 --> 00:26:52,080
because you have only users in that cvp

00:26:50,559 --> 00:26:57,039
file so in that single translation

00:26:52,080 --> 00:26:57,039
unit i hope that answers the question

00:26:59,760 --> 00:27:05,440
we can now look at this

00:27:03,039 --> 00:27:08,320
class template example in c plus plus

00:27:05,440 --> 00:27:08,320
insides as well

00:27:09,520 --> 00:27:14,799
and you suggested that i should increase

00:27:12,080 --> 00:27:17,520
the font size so let's try that

00:27:14,799 --> 00:27:18,559
um i hope that's better now so this is

00:27:17,520 --> 00:27:20,640
the

00:27:18,559 --> 00:27:22,080
code from the slide it's my class

00:27:20,640 --> 00:27:25,440
template array

00:27:22,080 --> 00:27:28,640
i have this out of line definition here

00:27:25,440 --> 00:27:31,600
for my data method and if i do the

00:27:28,640 --> 00:27:31,600
transformation now

00:27:32,399 --> 00:27:35,840
then we can see

00:27:39,600 --> 00:27:43,039
but i still have here the primary

00:27:41,520 --> 00:27:45,279
template so this is the

00:27:43,039 --> 00:27:46,799
version i wrote which with all the

00:27:45,279 --> 00:27:50,080
planks to fill out

00:27:46,799 --> 00:27:51,840
and here we have what the compiler makes

00:27:50,080 --> 00:27:54,960
up for us because

00:27:51,840 --> 00:27:57,039
if i go below oh no let's

00:27:54,960 --> 00:27:58,640
stay here and look at the other side so

00:27:57,039 --> 00:27:59,600
what i'm requesting here from the

00:27:58,640 --> 00:28:02,640
compiler

00:27:59,600 --> 00:28:04,480
is an array of type in comma two so this

00:28:02,640 --> 00:28:05,520
is the first thing the compiler makes up

00:28:04,480 --> 00:28:08,159
for us

00:28:05,520 --> 00:28:09,679
it's from line number 29 and that

00:28:08,159 --> 00:28:11,679
matches that one here

00:28:09,679 --> 00:28:13,760
and then i have now this data method

00:28:11,679 --> 00:28:14,960
which returns an end you have the const

00:28:13,760 --> 00:28:18,159
version which returns

00:28:14,960 --> 00:28:21,039
in and my begin and end functions

00:28:18,159 --> 00:28:21,039
do the same thing

00:28:21,360 --> 00:28:25,039
and below here i do have the second

00:28:24,159 --> 00:28:28,640
version

00:28:25,039 --> 00:28:30,960
because i asked for double comma two

00:28:28,640 --> 00:28:34,640
so the compiler does instantiate a

00:28:30,960 --> 00:28:36,559
version for double comma 2.

00:28:34,640 --> 00:28:38,000
and then below here i have the final

00:28:36,559 --> 00:28:41,279
version which

00:28:38,000 --> 00:28:44,640
is for char2 so this time

00:28:41,279 --> 00:28:46,640
data returns jar star and

00:28:44,640 --> 00:28:48,000
we can see one interesting difference

00:28:46,640 --> 00:28:49,840
here

00:28:48,000 --> 00:28:52,000
because compilers when it comes to

00:28:49,840 --> 00:28:55,360
templates

00:28:52,000 --> 00:28:57,840
have the ability to not create code if

00:28:55,360 --> 00:28:58,399
there is no use for it and if you're

00:28:57,840 --> 00:29:02,000
looking

00:28:58,399 --> 00:29:02,720
at it i'm creating these two instances

00:29:02,000 --> 00:29:05,919
of

00:29:02,720 --> 00:29:09,039
array here for the combination in

00:29:05,919 --> 00:29:11,760
two and double two called ai and ad

00:29:09,039 --> 00:29:13,360
but i don't use them below so none of

00:29:11,760 --> 00:29:15,440
the methods are really used

00:29:13,360 --> 00:29:16,480
that's the reason why you do not see

00:29:15,440 --> 00:29:19,760
here

00:29:16,480 --> 00:29:22,720
any code any function body for

00:29:19,760 --> 00:29:23,600
any of these methods and this was the

00:29:22,720 --> 00:29:25,840
same for

00:29:23,600 --> 00:29:28,080
intent if you're going down to the chart

00:29:25,840 --> 00:29:31,440
case because this jar

00:29:28,080 --> 00:29:32,799
array i'm creating here called a is used

00:29:31,440 --> 00:29:35,360
in range base for loop

00:29:32,799 --> 00:29:36,480
now we are seeing that data places a

00:29:35,360 --> 00:29:40,399
curl

00:29:36,480 --> 00:29:43,679
call to stood address off getting the

00:29:40,399 --> 00:29:45,760
pointer to the first element in my array

00:29:43,679 --> 00:29:47,039
and we can now also see the compiler

00:29:45,760 --> 00:29:49,520
fills in the two

00:29:47,039 --> 00:29:50,240
because i requested that array of size

00:29:49,520 --> 00:29:55,039
two

00:29:50,240 --> 00:29:58,799
would i have done this with size three

00:29:55,039 --> 00:30:02,640
again in a moment we can see this this 2

00:29:58,799 --> 00:30:08,720
simply changes to 3 and

00:30:02,640 --> 00:30:12,000
the code still stays correct

00:30:08,720 --> 00:30:12,960
where we are looking at this it doesn't

00:30:12,000 --> 00:30:16,159
work

00:30:12,960 --> 00:30:23,200
it worked as expected

00:30:16,159 --> 00:30:26,480
i have to say five here for example

00:30:23,200 --> 00:30:26,480
does this make things better

00:30:34,080 --> 00:30:41,200
no but that may be my setup so it should

00:30:37,120 --> 00:30:45,279
work in reality i'm sorry about that

00:30:41,200 --> 00:30:46,880
so we have a few other questions

00:30:45,279 --> 00:30:48,480
are there circumstances where the

00:30:46,880 --> 00:30:51,120
compiler can do

00:30:48,480 --> 00:30:52,880
an implicit conversion for templates no

00:30:51,120 --> 00:30:55,679
there are no circumstances

00:30:52,880 --> 00:30:56,880
where it can do that except if you are

00:30:55,679 --> 00:30:59,039
asking for it

00:30:56,880 --> 00:31:02,799
so once you're starting providing the

00:30:59,039 --> 00:31:02,799
types with a specialization

00:31:02,840 --> 00:31:05,840
um

00:31:06,000 --> 00:31:11,039
now um come to the art later after the

00:31:08,960 --> 00:31:12,559
talk it takes too much time now to to

00:31:11,039 --> 00:31:14,799
come up with an example

00:31:12,559 --> 00:31:16,880
there are ways how you um can tamper

00:31:14,799 --> 00:31:18,000
with that but the compiler itself if

00:31:16,880 --> 00:31:19,919
you're

00:31:18,000 --> 00:31:21,360
not calling for a specific template

00:31:19,919 --> 00:31:23,360
instantiation

00:31:21,360 --> 00:31:25,919
has no way to enable implicit

00:31:23,360 --> 00:31:25,919
conversions

00:31:26,240 --> 00:31:33,440
and the fonts are readable now

00:31:29,760 --> 00:31:36,240
excellent all right so then let's

00:31:33,440 --> 00:31:36,240
continue here

00:31:37,600 --> 00:31:42,240
so we already looked a little bit in

00:31:39,200 --> 00:31:45,039
this class template instantiation

00:31:42,240 --> 00:31:46,880
you could see that it's very the same

00:31:45,039 --> 00:31:47,760
very much the same as for function

00:31:46,880 --> 00:31:50,399
templates

00:31:47,760 --> 00:31:51,039
there's one important exception and

00:31:50,399 --> 00:31:52,559
that's

00:31:51,039 --> 00:31:55,279
that class templates cannot

00:31:52,559 --> 00:31:58,240
automatically deduce or derive

00:31:55,279 --> 00:32:00,000
their arguments that's why i have to say

00:31:58,240 --> 00:32:03,600
in the sample i showed

00:32:00,000 --> 00:32:05,519
array of and comma 2.

00:32:03,600 --> 00:32:07,440
so each template argument must be

00:32:05,519 --> 00:32:09,120
specific explicitly

00:32:07,440 --> 00:32:11,600
and if you're looking back at function

00:32:09,120 --> 00:32:13,519
templates that's one of the cool things

00:32:11,600 --> 00:32:16,159
or one of the helpful things

00:32:13,519 --> 00:32:16,720
that we do not have to tell the compiler

00:32:16,159 --> 00:32:20,080
to type

00:32:16,720 --> 00:32:22,640
other than passing in that type

00:32:20,080 --> 00:32:24,159
and there are good reasons why it's a

00:32:22,640 --> 00:32:27,279
little bit different for function

00:32:24,159 --> 00:32:30,399
for class templates but if you

00:32:27,279 --> 00:32:32,240
like your class templates to work

00:32:30,399 --> 00:32:34,480
more or less similar to function

00:32:32,240 --> 00:32:37,039
templates and do not have to

00:32:34,480 --> 00:32:39,279
rename the types or the non-type

00:32:37,039 --> 00:32:42,159
template parameters once again

00:32:39,279 --> 00:32:42,880
then there is the c plus 17 exception

00:32:42,159 --> 00:32:45,600
for you

00:32:42,880 --> 00:32:48,799
with c plus plus 17 we got what's called

00:32:45,600 --> 00:32:52,880
class template argument deduction ctat

00:32:48,799 --> 00:32:54,799
and that works with a single parameter

00:32:52,880 --> 00:32:56,960
out of the box so if your class template

00:32:54,799 --> 00:32:58,640
takes only one parameter regardless

00:32:56,960 --> 00:32:59,760
whether it's a type or a non-type

00:32:58,640 --> 00:33:01,919
template parameter

00:32:59,760 --> 00:33:02,799
then the compiler is able to deduce that

00:33:01,919 --> 00:33:06,000
and to map it

00:33:02,799 --> 00:33:08,559
and if you have more than one parameter

00:33:06,000 --> 00:33:09,039
then you need to write some deduction

00:33:08,559 --> 00:33:13,919
guide

00:33:09,039 --> 00:33:13,919
but that's not topic of this talk today

00:33:15,919 --> 00:33:21,760
so i see another question popping in how

00:33:18,240 --> 00:33:24,720
can the array class be initialized

00:33:21,760 --> 00:33:27,840
with the string initial sh initializer

00:33:24,720 --> 00:33:33,760
if there is no constructor here

00:33:27,840 --> 00:33:33,760
so let me see probably half the time

00:33:34,320 --> 00:33:39,840
so if you're looking back at my array

00:33:36,240 --> 00:33:39,840
class i'm i'm happier

00:33:40,159 --> 00:33:44,080
the reason why that whole thing works is

00:33:42,799 --> 00:33:47,200
because i chose it

00:33:44,080 --> 00:33:50,960
to be struck here and not a class

00:33:47,200 --> 00:33:53,279
my data field is in fact public

00:33:50,960 --> 00:33:54,399
and so this behaves like an aggregate

00:33:53,279 --> 00:33:57,200
initialization

00:33:54,399 --> 00:33:57,919
and that's why i do not need to provide

00:33:57,200 --> 00:34:01,200
a

00:33:57,919 --> 00:34:02,000
constructor on my own not even a default

00:34:01,200 --> 00:34:03,519
one

00:34:02,000 --> 00:34:05,760
because the elements of this array

00:34:03,519 --> 00:34:06,240
simply get initialized we can see that i

00:34:05,760 --> 00:34:08,079
believe

00:34:06,240 --> 00:34:09,359
in the output of c plus plus insides

00:34:08,079 --> 00:34:11,839
below here

00:34:09,359 --> 00:34:12,720
here we can see um if you know the

00:34:11,839 --> 00:34:15,520
syntax

00:34:12,720 --> 00:34:16,399
that we are initializing here not just

00:34:15,520 --> 00:34:19,440
that array

00:34:16,399 --> 00:34:22,560
but in the second pair of curlies

00:34:19,440 --> 00:34:25,839
we are passing that values to an array

00:34:22,560 --> 00:34:28,240
in that class and this version is in

00:34:25,839 --> 00:34:31,679
fact what um stood array at least

00:34:28,240 --> 00:34:33,040
in lip c plus plus does because it's

00:34:31,679 --> 00:34:37,679
very efficient

00:34:33,040 --> 00:34:40,800
and you get practically no overhead so

00:34:37,679 --> 00:34:40,800
that's the way to do that

00:34:42,720 --> 00:34:46,320
and there's another question if you

00:34:44,240 --> 00:34:47,599
create arrays with the same type but

00:34:46,320 --> 00:34:50,800
different size

00:34:47,599 --> 00:34:51,359
um for example array in comma two and

00:34:50,800 --> 00:34:53,919
the

00:34:51,359 --> 00:34:56,480
array in comma three does it generate

00:34:53,919 --> 00:34:59,119
code for the class

00:34:56,480 --> 00:35:01,599
or for each of those separately does it

00:34:59,119 --> 00:35:04,800
have implications on size and speed

00:35:01,599 --> 00:35:06,480
so if you change only one of these

00:35:04,800 --> 00:35:08,480
parameters or if you change the

00:35:06,480 --> 00:35:10,720
combination

00:35:08,480 --> 00:35:12,960
as its whole the compiler needs to

00:35:10,720 --> 00:35:18,000
generate a new version of this class

00:35:12,960 --> 00:35:18,000
this is i believe what we are seeing um

00:35:18,240 --> 00:35:26,320
above here so i have this

00:35:22,160 --> 00:35:28,640
um jar of 2 so here we have it

00:35:26,320 --> 00:35:31,200
that's what i was looking for before so

00:35:28,640 --> 00:35:32,000
here i have from the compiler made for

00:35:31,200 --> 00:35:34,720
us

00:35:32,000 --> 00:35:35,119
an array instantiation of psi of type

00:35:34,720 --> 00:35:38,240
jar

00:35:35,119 --> 00:35:38,560
and size three and below here i have one

00:35:38,240 --> 00:35:41,680
for

00:35:38,560 --> 00:35:42,480
jar comma two and here i have char comma

00:35:41,680 --> 00:35:46,240
three

00:35:42,480 --> 00:35:49,200
and below here we have jar comma 2. so

00:35:46,240 --> 00:35:51,280
if you change only a single parameter

00:35:49,200 --> 00:35:53,200
here change its type change the value

00:35:51,280 --> 00:35:56,160
you get a new instantiation

00:35:53,200 --> 00:35:58,160
there is no common thing around them

00:35:56,160 --> 00:35:59,760
except that they are all have the name

00:35:58,160 --> 00:36:03,440
array

00:35:59,760 --> 00:36:05,280
so it will affect your um your size or

00:36:03,440 --> 00:36:06,800
your binary cross larger

00:36:05,280 --> 00:36:08,800
but then in the last step you have a

00:36:06,800 --> 00:36:10,880
good chance that linker jumps in and you

00:36:08,800 --> 00:36:13,280
get some link to an optimization

00:36:10,880 --> 00:36:14,240
such that duplications which are the

00:36:13,280 --> 00:36:17,760
same for

00:36:14,240 --> 00:36:19,280
all the types are thrown out once again

00:36:17,760 --> 00:36:21,200
but this is something you definitely

00:36:19,280 --> 00:36:23,040
have to watch out for and

00:36:21,200 --> 00:36:25,440
you need to control but as i said

00:36:23,040 --> 00:36:26,160
initially if you would write the type

00:36:25,440 --> 00:36:28,480
yourself

00:36:26,160 --> 00:36:29,839
and you would write the two different

00:36:28,480 --> 00:36:35,119
versions of that type

00:36:29,839 --> 00:36:37,359
it would be the same code increase so

00:36:35,119 --> 00:36:39,280
it's nothing different just that you

00:36:37,359 --> 00:36:40,800
have to write it only once and maintain

00:36:39,280 --> 00:36:44,079
it only once

00:36:40,800 --> 00:36:44,079
if you're using a template

00:36:46,240 --> 00:36:49,520
we can have another special thing if we

00:36:48,160 --> 00:36:53,040
are looking into

00:36:49,520 --> 00:36:55,040
class templates they not necessarily

00:36:53,040 --> 00:36:56,640
to be class templates to be there

00:36:55,040 --> 00:36:59,839
because we can also have

00:36:56,640 --> 00:37:04,240
method templates a method template is

00:36:59,839 --> 00:37:07,359
what's shown in line 10 to 15 here

00:37:04,240 --> 00:37:09,200
when i'm having another template in my

00:37:07,359 --> 00:37:11,599
class template in this case

00:37:09,200 --> 00:37:12,480
a method template it's once again

00:37:11,599 --> 00:37:14,960
introduced

00:37:12,480 --> 00:37:16,720
by the keyword template and because in

00:37:14,960 --> 00:37:19,200
this particular case we are looking

00:37:16,720 --> 00:37:20,160
already at a class template which

00:37:19,200 --> 00:37:23,280
defines

00:37:20,160 --> 00:37:25,920
the type name t the name t is chosen

00:37:23,280 --> 00:37:26,320
so it's like creating a variable and

00:37:25,920 --> 00:37:29,839
then

00:37:26,320 --> 00:37:31,040
in the inner scope this a new variable

00:37:29,839 --> 00:37:33,920
with the same name

00:37:31,040 --> 00:37:36,320
that's shadowing it works for variables

00:37:33,920 --> 00:37:37,839
it doesn't work so well here so i have

00:37:36,320 --> 00:37:39,599
to pick a different name

00:37:37,839 --> 00:37:41,119
and the convention is often that the

00:37:39,599 --> 00:37:43,520
first parameter is two

00:37:41,119 --> 00:37:44,960
the second one is you but you are

00:37:43,520 --> 00:37:46,800
absolutely free to

00:37:44,960 --> 00:37:49,359
make up every name that follows the

00:37:46,800 --> 00:37:52,720
usual variable naming roots

00:37:49,359 --> 00:37:56,079
so here i have this method template

00:37:52,720 --> 00:37:59,520
and it defines me an operator equals

00:37:56,079 --> 00:38:01,440
which returns reference to such a food

00:37:59,520 --> 00:38:05,680
type which this class template

00:38:01,440 --> 00:38:09,119
is off and it takes a const u ref

00:38:05,680 --> 00:38:12,320
and internally there's a static cast on

00:38:09,119 --> 00:38:15,440
that passed in parameter u to

00:38:12,320 --> 00:38:18,560
my class class templates type

00:38:15,440 --> 00:38:20,800
t and then returns a copy of this or

00:38:18,560 --> 00:38:22,880
dereference this

00:38:20,800 --> 00:38:24,640
and what this is essentially a

00:38:22,880 --> 00:38:27,359
conversion operator

00:38:24,640 --> 00:38:29,119
and it converts everything that responds

00:38:27,359 --> 00:38:32,560
of course to static cost

00:38:29,119 --> 00:38:32,960
from u to t and what you can do with

00:38:32,560 --> 00:38:36,480
that

00:38:32,960 --> 00:38:40,640
is some probably not so saying saying

00:38:36,480 --> 00:38:42,160
i can inline 23 create an instantiation

00:38:40,640 --> 00:38:45,359
of type 4ind

00:38:42,160 --> 00:38:47,520
for my class quality fi assign the value

00:38:45,359 --> 00:38:48,640
3 to it because i also happen to have a

00:38:47,520 --> 00:38:51,680
constructor

00:38:48,640 --> 00:38:54,000
taking a single argument and then in

00:38:51,680 --> 00:38:58,400
line 24 i can say

00:38:54,000 --> 00:39:02,400
fe equals 2.5 with that

00:38:58,400 --> 00:39:05,839
the conversion operator here kicks in

00:39:02,400 --> 00:39:09,599
and this 2.5 gets down casted

00:39:05,839 --> 00:39:12,960
to an end so just two in the end

00:39:09,599 --> 00:39:14,800
and that is assigned to mx the internal

00:39:12,960 --> 00:39:16,720
variable

00:39:14,800 --> 00:39:19,839
you can have a look at this in c plus

00:39:16,720 --> 00:39:19,839
plus and sides as well

00:39:21,599 --> 00:39:25,200
and usually the transformation is a

00:39:23,839 --> 00:39:27,359
little bit faster

00:39:25,200 --> 00:39:29,280
but because my laptop is doing so much

00:39:27,359 --> 00:39:31,920
with all the streaming thing

00:39:29,280 --> 00:39:33,680
it's slowed down so here once again we

00:39:31,920 --> 00:39:34,320
have the primary template which we

00:39:33,680 --> 00:39:37,839
declared

00:39:34,320 --> 00:39:40,880
compiler leaves that as it is and

00:39:37,839 --> 00:39:41,680
then we have the instantiation for end

00:39:40,880 --> 00:39:43,839
here

00:39:41,680 --> 00:39:46,000
this is from a class template food

00:39:43,839 --> 00:39:47,200
instantiation we can see once again here

00:39:46,000 --> 00:39:49,440
the constructor

00:39:47,200 --> 00:39:50,880
which we request that is filled with the

00:39:49,440 --> 00:39:54,000
appropriate type

00:39:50,880 --> 00:39:57,520
and then here i have the instantiation

00:39:54,000 --> 00:40:00,400
for my requested conversion operator

00:39:57,520 --> 00:40:02,400
and in this case it's a double so that

00:40:00,400 --> 00:40:03,680
thing takes a double and then it static

00:40:02,400 --> 00:40:06,480
casts the double

00:40:03,680 --> 00:40:09,119
to an end and because that works that

00:40:06,480 --> 00:40:12,079
entire code compiles

00:40:09,119 --> 00:40:13,920
so these are things that can help you if

00:40:12,079 --> 00:40:17,760
you have um

00:40:13,920 --> 00:40:21,040
some class which needs to take in

00:40:17,760 --> 00:40:23,440
a bunch of different other types and

00:40:21,040 --> 00:40:25,359
you don't want to come up with a

00:40:23,440 --> 00:40:27,200
conversion or assignment operator

00:40:25,359 --> 00:40:28,560
for all of them because we're talking

00:40:27,200 --> 00:40:31,280
about 20 or

00:40:28,560 --> 00:40:32,960
30 of these types but they all share the

00:40:31,280 --> 00:40:35,680
same properties and they are all

00:40:32,960 --> 00:40:36,480
convertible to that thing with static

00:40:35,680 --> 00:40:38,720
cost

00:40:36,480 --> 00:40:40,160
then you can use a pattern like this you

00:40:38,720 --> 00:40:42,160
don't need necessarily a

00:40:40,160 --> 00:40:43,280
class template on the outside it works

00:40:42,160 --> 00:40:45,680
with the regular

00:40:43,280 --> 00:40:46,800
class as well the only thing you have to

00:40:45,680 --> 00:40:49,760
watch out for

00:40:46,800 --> 00:40:51,440
if that steady cost fails then you get

00:40:49,760 --> 00:40:53,839
this multi-pages long

00:40:51,440 --> 00:40:55,680
template errors probably where the

00:40:53,839 --> 00:40:59,280
compiler tells you that during the

00:40:55,680 --> 00:41:01,520
instantiation it failed badly

00:40:59,280 --> 00:41:07,839
but you will learn to handle them once

00:41:01,520 --> 00:41:07,839
you've seen them long enough

00:41:10,160 --> 00:41:15,920
so there's another question sorry if i

00:41:12,000 --> 00:41:18,839
got the explicit specially sage

00:41:15,920 --> 00:41:20,240
if i got to explicitly specialize

00:41:18,839 --> 00:41:22,720
specialists

00:41:20,240 --> 00:41:24,480
specialized class sorry for that for

00:41:22,720 --> 00:41:27,839
every single combination of t

00:41:24,480 --> 00:41:30,720
and u if you

00:41:27,839 --> 00:41:32,640
got to explicitly specialize the class

00:41:30,720 --> 00:41:36,319
for every single combination of t

00:41:32,640 --> 00:41:39,119
and u um

00:41:36,319 --> 00:41:40,240
yeah then i feel probably sorry for you

00:41:39,119 --> 00:41:43,359
um

00:41:40,240 --> 00:41:47,440
then the question is if you really need

00:41:43,359 --> 00:41:49,440
the templates that could be because you

00:41:47,440 --> 00:41:51,280
like to have the same type there not the

00:41:49,440 --> 00:41:53,920
same name

00:41:51,280 --> 00:41:56,720
maybe you also find out that there is

00:41:53,920 --> 00:42:00,640
some common functionality between them

00:41:56,720 --> 00:42:03,119
which you can share so

00:42:00,640 --> 00:42:05,599
how to answer with just that single

00:42:03,119 --> 00:42:05,599
sentence

00:42:06,720 --> 00:42:10,400
and there is another thing i always

00:42:08,480 --> 00:42:11,839
found it pretty difficult to digest

00:42:10,400 --> 00:42:14,480
templates and code

00:42:11,839 --> 00:42:15,440
the talk definitely gives me a good

00:42:14,480 --> 00:42:17,359
overview

00:42:15,440 --> 00:42:18,880
could you please share some good

00:42:17,359 --> 00:42:21,920
textbook references oh okay

00:42:18,880 --> 00:42:23,520
we talk about this later so let's um

00:42:21,920 --> 00:42:24,720
continue here with class templates

00:42:23,520 --> 00:42:26,160
inheritance but thank you for that

00:42:24,720 --> 00:42:30,160
compliment i'm happy about that

00:42:26,160 --> 00:42:32,160
that's the mission so what we can do is

00:42:30,160 --> 00:42:32,880
because we are talking about classes and

00:42:32,160 --> 00:42:35,280
whether we

00:42:32,880 --> 00:42:36,480
um suffix that with templates or not

00:42:35,280 --> 00:42:39,440
doesn't matter so

00:42:36,480 --> 00:42:41,520
the class template behaves like a class

00:42:39,440 --> 00:42:44,000
that means that we can derive

00:42:41,520 --> 00:42:45,680
from a class template either with a

00:42:44,000 --> 00:42:46,319
regular template or with a class

00:42:45,680 --> 00:42:48,240
template

00:42:46,319 --> 00:42:50,160
in this example here i'm showing you the

00:42:48,240 --> 00:42:53,359
version where i derive

00:42:50,160 --> 00:42:55,839
from class template and

00:42:53,359 --> 00:42:58,400
the class that derives from is also a

00:42:55,839 --> 00:43:01,520
class template itself and

00:42:58,400 --> 00:43:04,720
then a couple of questions occur so

00:43:01,520 --> 00:43:07,920
you have to say to tell the compiler

00:43:04,720 --> 00:43:10,400
for which type you are instantiating

00:43:07,920 --> 00:43:12,240
this base class because this base class

00:43:10,400 --> 00:43:15,040
now is a template so

00:43:12,240 --> 00:43:15,440
the template itself needs the parameters

00:43:15,040 --> 00:43:18,560
to be

00:43:15,440 --> 00:43:22,000
filled in and in my case i'm showing

00:43:18,560 --> 00:43:24,079
here my class foo and my glass bar both

00:43:22,000 --> 00:43:26,720
take only a single type name t

00:43:24,079 --> 00:43:27,599
so i decided to just pass that to my

00:43:26,720 --> 00:43:30,000
base class

00:43:27,599 --> 00:43:31,599
but in fact i could also chose to say

00:43:30,000 --> 00:43:35,200
that i'd like to publicly

00:43:31,599 --> 00:43:38,880
derive from for example a short or

00:43:35,200 --> 00:43:41,280
um double whatsoever

00:43:38,880 --> 00:43:42,720
that's the first thing you can leave out

00:43:41,280 --> 00:43:44,560
parameters here so

00:43:42,720 --> 00:43:45,920
class bar would take more parameters

00:43:44,560 --> 00:43:48,079
than foo

00:43:45,920 --> 00:43:48,960
then that's not a problem all you have

00:43:48,079 --> 00:43:51,520
to

00:43:48,960 --> 00:43:52,319
care about is that foo needs some

00:43:51,520 --> 00:43:55,200
indication

00:43:52,319 --> 00:43:55,920
how or for which type it's going to be

00:43:55,200 --> 00:43:58,720
used and

00:43:55,920 --> 00:44:00,400
by that instantiated so you have to be

00:43:58,720 --> 00:44:02,000
specific there

00:44:00,400 --> 00:44:03,440
there's another thing if you're looking

00:44:02,000 --> 00:44:06,560
at my

00:44:03,440 --> 00:44:09,680
function bar func and line number 12

00:44:06,560 --> 00:44:11,040
class bar it tries to call the function

00:44:09,680 --> 00:44:14,079
of the base class

00:44:11,040 --> 00:44:14,880
func there as you can see in line number

00:44:14,079 --> 00:44:17,280
five

00:44:14,880 --> 00:44:19,119
my class foo comes through the function

00:44:17,280 --> 00:44:20,400
func it doesn't do anything but that's

00:44:19,119 --> 00:44:23,119
not a

00:44:20,400 --> 00:44:24,720
thing here i try to call this function

00:44:23,119 --> 00:44:27,280
in my derived class so

00:44:24,720 --> 00:44:30,240
this is the usual thing calling the base

00:44:27,280 --> 00:44:33,440
class function in the derived class

00:44:30,240 --> 00:44:34,160
usually i advise my students to do it

00:44:33,440 --> 00:44:36,720
like in line

00:44:34,160 --> 00:44:37,680
number 14 for regular classes because i

00:44:36,720 --> 00:44:41,119
don't like

00:44:37,680 --> 00:44:42,560
the noise that this this error operator

00:44:41,119 --> 00:44:46,160
all the time grades

00:44:42,560 --> 00:44:46,880
so i like just calling the naked

00:44:46,160 --> 00:44:49,520
function

00:44:46,880 --> 00:44:51,440
but this doesn't work if you're deriving

00:44:49,520 --> 00:44:53,119
or if you're inheriting from a class

00:44:51,440 --> 00:44:55,359
template

00:44:53,119 --> 00:44:57,440
and the simple nature of that is because

00:44:55,359 --> 00:45:00,640
there is not necessarily only

00:44:57,440 --> 00:45:02,880
one of this foos you can

00:45:00,640 --> 00:45:04,240
publicly or privately derive multiple

00:45:02,880 --> 00:45:07,520
times from foo

00:45:04,240 --> 00:45:07,920
just with a different type so we can yes

00:45:07,520 --> 00:45:11,760
here

00:45:07,920 --> 00:45:15,839
shown derive public foo of t

00:45:11,760 --> 00:45:18,560
comma foo public foo if you like

00:45:15,839 --> 00:45:19,520
foo of double that would work and then

00:45:18,560 --> 00:45:22,800
there are two

00:45:19,520 --> 00:45:26,240
different functions called func so

00:45:22,800 --> 00:45:28,880
one case uh one way you can solve this

00:45:26,240 --> 00:45:29,760
is like in line number 14 for the single

00:45:28,880 --> 00:45:32,960
case here

00:45:29,760 --> 00:45:35,760
be specific say this arrow

00:45:32,960 --> 00:45:38,079
and then the name of the function in the

00:45:35,760 --> 00:45:41,119
base class in my case foo

00:45:38,079 --> 00:45:44,720
the more general way probably is like

00:45:41,119 --> 00:45:48,240
in line 16 provide the full

00:45:44,720 --> 00:45:51,359
namespace so i like here to refer to foo

00:45:48,240 --> 00:45:52,720
of type t colon colon and then the

00:45:51,359 --> 00:45:55,280
member function func

00:45:52,720 --> 00:45:56,640
that way i could also call different

00:45:55,280 --> 00:45:59,280
versions of foo

00:45:56,640 --> 00:46:02,640
if i have derived from that multiple

00:45:59,280 --> 00:46:02,640
times as i showed before

00:46:09,839 --> 00:46:14,400
we also have alias templates alias

00:46:12,640 --> 00:46:19,119
templates allow us to create

00:46:14,400 --> 00:46:19,119
synonyms for templates if you like

00:46:19,200 --> 00:46:24,240
and there's another question popping in

00:46:21,200 --> 00:46:28,160
must bar also be a template class

00:46:24,240 --> 00:46:31,359
or a spar colon public foo and

00:46:28,160 --> 00:46:32,560
also okay yes bar doesn't need to be a

00:46:31,359 --> 00:46:35,280
template

00:46:32,560 --> 00:46:36,880
it can just be a regular class that's

00:46:35,280 --> 00:46:39,599
fine

00:46:36,880 --> 00:46:40,839
so alias templates here they once again

00:46:39,599 --> 00:46:43,760
start with the keyboard

00:46:40,839 --> 00:46:44,640
template and the anchor brackets and now

00:46:43,760 --> 00:46:47,119
i can

00:46:44,640 --> 00:46:48,640
once again use type name non-type

00:46:47,119 --> 00:46:51,200
template parameters

00:46:48,640 --> 00:46:52,640
like in every other template and this

00:46:51,200 --> 00:46:55,839
goes together with using

00:46:52,640 --> 00:46:56,400
now i say template size tn using char

00:46:55,839 --> 00:46:58,880
array

00:46:56,400 --> 00:47:00,960
and jar array is the name for that thing

00:46:58,880 --> 00:47:03,040
which i can use to refer to it later

00:47:00,960 --> 00:47:04,640
and then i say that's equal to stood

00:47:03,040 --> 00:47:08,000
array of type

00:47:04,640 --> 00:47:08,800
jar but with size n so the size is

00:47:08,000 --> 00:47:11,440
unknown

00:47:08,800 --> 00:47:12,400
now i can build or can use this like in

00:47:11,440 --> 00:47:16,079
line number eight

00:47:12,400 --> 00:47:18,160
i can say char array of size 24.

00:47:16,079 --> 00:47:20,720
this is pretty useful if you have code

00:47:18,160 --> 00:47:24,079
where you're making up char arrays

00:47:20,720 --> 00:47:26,160
a lot of the time and you can simply

00:47:24,079 --> 00:47:27,599
make it easier for your users dropping

00:47:26,160 --> 00:47:30,240
that single

00:47:27,599 --> 00:47:32,319
um type there and it's more meaningful

00:47:30,240 --> 00:47:35,760
because everybody can share the same

00:47:32,319 --> 00:47:38,720
same type because now it's typed jar ray

00:47:35,760 --> 00:47:40,400
and there's more to it if you happen to

00:47:38,720 --> 00:47:41,920
have a product which compiles for

00:47:40,400 --> 00:47:44,480
multiple platforms

00:47:41,920 --> 00:47:46,319
and there you have slide variations

00:47:44,480 --> 00:47:47,440
because sometimes you're using the

00:47:46,319 --> 00:47:50,079
student array

00:47:47,440 --> 00:47:51,200
and for the other platform you're using

00:47:50,079 --> 00:47:53,440
something like the

00:47:51,200 --> 00:47:55,839
array implementation i showed you before

00:47:53,440 --> 00:47:58,079
they are more or less compatible but

00:47:55,839 --> 00:47:59,839
due to some circumstances you have to

00:47:58,079 --> 00:48:02,319
use the different types here

00:47:59,839 --> 00:48:04,079
then you can abstract that sorry you

00:48:02,319 --> 00:48:07,200
have to use a macro here

00:48:04,079 --> 00:48:07,839
but then you can say okay if there's a

00:48:07,200 --> 00:48:10,880
certain

00:48:07,839 --> 00:48:11,920
define on like product a then my char

00:48:10,880 --> 00:48:14,480
array refers

00:48:11,920 --> 00:48:15,200
simply to my array type and if not it

00:48:14,480 --> 00:48:18,160
refers to

00:48:15,200 --> 00:48:18,720
the array both type this array with type

00:48:18,160 --> 00:48:21,760
jar

00:48:18,720 --> 00:48:22,559
and leave the size open to specified by

00:48:21,760 --> 00:48:25,040
user

00:48:22,559 --> 00:48:25,839
and as you can see in line number 13 for

00:48:25,040 --> 00:48:27,920
user code

00:48:25,839 --> 00:48:30,400
it doesn't make a difference as long as

00:48:27,920 --> 00:48:33,520
the api of these both types

00:48:30,400 --> 00:48:34,000
are the same then you can simply

00:48:33,520 --> 00:48:37,839
abstract

00:48:34,000 --> 00:48:40,079
this and do not have to have this um

00:48:37,839 --> 00:48:43,760
if there's in your code all over the

00:48:40,079 --> 00:48:43,760
place so this is really helpful

00:48:47,760 --> 00:48:52,319
now let's because the time is slightly

00:48:51,599 --> 00:48:54,559
running up

00:48:52,319 --> 00:48:56,160
let's talk about guidelines for

00:48:54,559 --> 00:48:59,040
efficient use of templates

00:48:56,160 --> 00:49:00,880
templates generate code for us so it's

00:48:59,040 --> 00:49:01,599
the same as we are copying and pasting

00:49:00,880 --> 00:49:04,559
our

00:49:01,599 --> 00:49:05,599
implementation and just changing types

00:49:04,559 --> 00:49:08,400
or values

00:49:05,599 --> 00:49:08,800
and that means that the resulting binary

00:49:08,400 --> 00:49:11,760
can

00:49:08,800 --> 00:49:13,599
get larger of course maybe the optimizer

00:49:11,760 --> 00:49:17,040
throws away a couple of these

00:49:13,599 --> 00:49:17,839
floats but it doesn't have to sometimes

00:49:17,040 --> 00:49:21,040
we

00:49:17,839 --> 00:49:22,960
overlook this fact and then people refer

00:49:21,040 --> 00:49:24,640
to it to code load when it comes to

00:49:22,960 --> 00:49:26,079
templates because for templates the

00:49:24,640 --> 00:49:27,599
compiler does this for us but

00:49:26,079 --> 00:49:29,920
essentially it's the same as

00:49:27,599 --> 00:49:31,200
we could have done it by ourselves and

00:49:29,920 --> 00:49:33,520
we probably would have

00:49:31,200 --> 00:49:35,359
without templates because we need the

00:49:33,520 --> 00:49:37,520
types right

00:49:35,359 --> 00:49:38,800
this is in our control we can control

00:49:37,520 --> 00:49:41,520
this

00:49:38,800 --> 00:49:42,319
and here's an example and this is a

00:49:41,520 --> 00:49:45,280
example of

00:49:42,319 --> 00:49:46,160
passing value and the length so it's a

00:49:45,280 --> 00:49:49,440
typical c

00:49:46,160 --> 00:49:50,720
or posix api if you like it's very error

00:49:49,440 --> 00:49:52,800
prone

00:49:50,720 --> 00:49:55,599
because as you can see below and then

00:49:52,800 --> 00:49:55,599
line number

00:49:56,839 --> 00:50:01,760
19. yeah

00:49:58,400 --> 00:50:02,960
to 25 i'm creating two different buffers

00:50:01,760 --> 00:50:05,040
here and calling

00:50:02,960 --> 00:50:07,280
read and sound and i all the time have

00:50:05,040 --> 00:50:09,359
to say buffer and then size of buffers

00:50:07,280 --> 00:50:11,680
or what's the size of this buffer

00:50:09,359 --> 00:50:13,040
and i'm not sure if you're quick enough

00:50:11,680 --> 00:50:16,640
to spot this

00:50:13,040 --> 00:50:17,920
but i got it wrong for line number 24

00:50:16,640 --> 00:50:20,240
and 25.

00:50:17,920 --> 00:50:21,680
sadly i'm passing in buffer instead of

00:50:20,240 --> 00:50:24,240
probably buffer 2

00:50:21,680 --> 00:50:26,559
but i'm passing the size of buffer 2. so

00:50:24,240 --> 00:50:29,599
with that i created myself a

00:50:26,559 --> 00:50:31,440
nice beautiful buffer overflow

00:50:29,599 --> 00:50:33,119
which is probably not so good for your

00:50:31,440 --> 00:50:35,440
customers it may be

00:50:33,119 --> 00:50:37,200
a good case for job security so if

00:50:35,440 --> 00:50:39,839
you're the one who can fix that

00:50:37,200 --> 00:50:40,319
quickly after customers complain then

00:50:39,839 --> 00:50:42,240
that's

00:50:40,319 --> 00:50:44,559
probably a good thing but other than

00:50:42,240 --> 00:50:46,000
that it's really nasty to have to deal

00:50:44,559 --> 00:50:48,960
with such problems

00:50:46,000 --> 00:50:50,000
it's it's more to read and to write and

00:50:48,960 --> 00:50:53,359
you can get it wrong

00:50:50,000 --> 00:50:54,000
i got it wrong a couple of times so what

00:50:53,359 --> 00:50:57,040
can we do about

00:50:54,000 --> 00:50:58,960
this well we can plug in um standard

00:50:57,040 --> 00:51:01,839
library containers like stood array

00:50:58,960 --> 00:51:03,880
we use a stud array as shown of type jar

00:51:01,839 --> 00:51:08,640
and say it's of size

00:51:03,880 --> 00:51:12,000
1024 for read and set here

00:51:08,640 --> 00:51:12,559
certainly is that then doesn't compile

00:51:12,000 --> 00:51:15,760
anymore

00:51:12,559 --> 00:51:17,599
because line 20 and 21 will result in a

00:51:15,760 --> 00:51:19,680
compile error we only have a function

00:51:17,599 --> 00:51:23,520
that takes a stud array of psi of

00:51:19,680 --> 00:51:26,640
char and 1024 it cannot pass in their

00:51:23,520 --> 00:51:28,640
stood array of char in 2048 what would

00:51:26,640 --> 00:51:31,760
that mean anyway

00:51:28,640 --> 00:51:34,960
so that doesn't help

00:51:31,760 --> 00:51:37,200
what you can do good solution here

00:51:34,960 --> 00:51:38,960
for starters would be we're making there

00:51:37,200 --> 00:51:41,040
the function template

00:51:38,960 --> 00:51:42,800
we are keeping the standard library

00:51:41,040 --> 00:51:45,520
container stood array

00:51:42,800 --> 00:51:47,280
the keeping the type to jar because that

00:51:45,520 --> 00:51:48,880
we need but we saw that trick that the

00:51:47,280 --> 00:51:52,000
compiler can derived

00:51:48,880 --> 00:51:54,400
size on its own so we say okay let the

00:51:52,000 --> 00:51:57,040
compiler deduce the size of that thing

00:51:54,400 --> 00:51:58,319
we do that for read and write often for

00:51:57,040 --> 00:52:01,920
send and read

00:51:58,319 --> 00:52:05,040
and now our code compiles we are happy

00:52:01,920 --> 00:52:08,079
that's good we used an sdl container

00:52:05,040 --> 00:52:09,440
we have a template in place that's quite

00:52:08,079 --> 00:52:12,720
good we have to write this

00:52:09,440 --> 00:52:16,720
code only once excellent

00:52:12,720 --> 00:52:17,680
but now we have the danger to create

00:52:16,720 --> 00:52:20,160
code plot

00:52:17,680 --> 00:52:21,440
as soon as the example is here i'm

00:52:20,160 --> 00:52:24,800
showing you

00:52:21,440 --> 00:52:27,920
the risk is near zero if not zero

00:52:24,800 --> 00:52:28,960
because sand will be result in an inline

00:52:27,920 --> 00:52:31,440
function so

00:52:28,960 --> 00:52:32,480
it doesn't matter how many versions

00:52:31,440 --> 00:52:34,720
you're creating there

00:52:32,480 --> 00:52:35,920
it's essentially the same as calling

00:52:34,720 --> 00:52:39,119
right directly

00:52:35,920 --> 00:52:39,520
except that the users can't drop them

00:52:39,119 --> 00:52:41,760
saying

00:52:39,520 --> 00:52:43,359
what the size of this thing is because

00:52:41,760 --> 00:52:45,280
as you can see below

00:52:43,359 --> 00:52:46,960
we now only have to pass in the buffer

00:52:45,280 --> 00:52:49,520
which is the key here

00:52:46,960 --> 00:52:51,599
but my read function maybe is bigger

00:52:49,520 --> 00:52:52,400
maybe my send function grows so at some

00:52:51,599 --> 00:52:55,680
point

00:52:52,400 --> 00:52:57,440
it could start to matter that we are

00:52:55,680 --> 00:52:59,760
creating multiple instances

00:52:57,440 --> 00:53:00,960
because we have a lot of different sized

00:52:59,760 --> 00:53:05,680
buffers there

00:53:00,960 --> 00:53:09,680
so it's a danger how can we avoid this

00:53:05,680 --> 00:53:12,079
we can avoid it by using another

00:53:09,680 --> 00:53:13,680
type of standard library which comes

00:53:12,079 --> 00:53:16,800
with c plus plus 20 it's

00:53:13,680 --> 00:53:17,599
span let's do span and as you can see

00:53:16,800 --> 00:53:20,000
above it's

00:53:17,599 --> 00:53:21,599
you're simply now saying in sand con

00:53:20,000 --> 00:53:24,960
span of char

00:53:21,599 --> 00:53:28,000
by reference and if that's in the name

00:53:24,960 --> 00:53:31,440
data and the

00:53:28,000 --> 00:53:32,160
key thing here is we got the template

00:53:31,440 --> 00:53:34,640
removed

00:53:32,160 --> 00:53:36,319
just talk about templates so it may be

00:53:34,640 --> 00:53:37,119
um suspicious why i'm removing the

00:53:36,319 --> 00:53:38,880
template here

00:53:37,119 --> 00:53:40,240
but we are talking about code load and

00:53:38,880 --> 00:53:43,599
how to control it

00:53:40,240 --> 00:53:46,240
so making send and read a template

00:53:43,599 --> 00:53:46,960
can result in code blood if we are using

00:53:46,240 --> 00:53:50,079
that spam

00:53:46,960 --> 00:53:51,920
type which we have to type only for type

00:53:50,079 --> 00:53:55,040
jar and we are assuming that's all that

00:53:51,920 --> 00:53:55,040
function needs to take

00:53:55,520 --> 00:53:58,559
then this danger is gone and the good

00:53:58,160 --> 00:54:03,599
thing

00:53:58,559 --> 00:54:06,960
is we have a chance here

00:54:03,599 --> 00:54:07,440
to use despair even backwards combat

00:54:06,960 --> 00:54:08,480
table

00:54:07,440 --> 00:54:10,800
because i will show you an

00:54:08,480 --> 00:54:13,839
implementation in a minute

00:54:10,800 --> 00:54:15,359
what spam does is it stores a pointer in

00:54:13,839 --> 00:54:17,520
the legs

00:54:15,359 --> 00:54:19,760
and the key here is that it stores a

00:54:17,520 --> 00:54:22,480
length because it stores the length

00:54:19,760 --> 00:54:24,240
the length doesn't need to be specified

00:54:22,480 --> 00:54:26,559
for the template

00:54:24,240 --> 00:54:28,160
that's why span only takes a single

00:54:26,559 --> 00:54:30,880
argument as its template

00:54:28,160 --> 00:54:32,079
parameter and that's the abstraction we

00:54:30,880 --> 00:54:36,880
often need

00:54:32,079 --> 00:54:40,480
because having the size specified

00:54:36,880 --> 00:54:41,200
isn't necessarily vital here it's not

00:54:40,480 --> 00:54:44,000
key

00:54:41,200 --> 00:54:45,440
we are spending a couple of bytes more

00:54:44,000 --> 00:54:47,520
to store the links

00:54:45,440 --> 00:54:49,760
in favor of creating a bunch of

00:54:47,520 --> 00:54:52,000
different instantiations of our function

00:54:49,760 --> 00:54:54,160
and this here is spam it fits on certain

00:54:52,000 --> 00:54:56,559
lines of code if you omit a little bit

00:54:54,160 --> 00:54:57,280
of extra things so the standard library

00:54:56,559 --> 00:54:59,920
version is

00:54:57,280 --> 00:55:00,640
a lot bigger but this does the essential

00:54:59,920 --> 00:55:03,280
parts it

00:55:00,640 --> 00:55:05,280
works with the code as shown before so i

00:55:03,280 --> 00:55:06,880
have a default constructor from above we

00:55:05,280 --> 00:55:09,040
can see it's a class template

00:55:06,880 --> 00:55:10,960
taking a tape num t and then i have a

00:55:09,040 --> 00:55:14,319
bunch of other constructors

00:55:10,960 --> 00:55:16,400
which essentially convert from an array

00:55:14,319 --> 00:55:17,920
as we saw before in line number nine and

00:55:16,400 --> 00:55:20,720
line number 13

00:55:17,920 --> 00:55:21,440
to a combination of a pointer and the

00:55:20,720 --> 00:55:24,480
size

00:55:21,440 --> 00:55:25,359
and the line number 16 17 i have a

00:55:24,480 --> 00:55:28,640
version

00:55:25,359 --> 00:55:31,599
which converts from a stud array to

00:55:28,640 --> 00:55:34,400
a spell and the more constructors you

00:55:31,599 --> 00:55:36,559
add the more flexible the span gets and

00:55:34,400 --> 00:55:38,000
from more types you can't create it and

00:55:36,559 --> 00:55:40,400
then we have size function

00:55:38,000 --> 00:55:42,480
which refers to the internal number size

00:55:40,400 --> 00:55:44,960
you can see in line number 29

00:55:42,480 --> 00:55:48,720
and of course a data function which

00:55:44,960 --> 00:55:50,799
refers to my data member on line 28.

00:55:48,720 --> 00:55:51,920
and then empty and the begin and end and

00:55:50,799 --> 00:55:54,720
we are down

00:55:51,920 --> 00:55:55,920
we have span where we can iterate over

00:55:54,720 --> 00:55:58,960
in

00:55:55,920 --> 00:56:00,720
a range-based for loop we can query the

00:55:58,960 --> 00:56:04,640
size to compile it it uses all that

00:56:00,720 --> 00:56:04,640
stuff for us we are fine

00:56:04,880 --> 00:56:08,240
so the guidelines for efficient use of

00:56:06,720 --> 00:56:10,400
templates would be

00:56:08,240 --> 00:56:12,720
move code which stays the same for all

00:56:10,400 --> 00:56:14,640
instantiations in a base class if we're

00:56:12,720 --> 00:56:16,799
talking about class templates

00:56:14,640 --> 00:56:18,720
wait if storing an additional type of

00:56:16,799 --> 00:56:20,640
value like in span

00:56:18,720 --> 00:56:22,240
is better than storing it in the

00:56:20,640 --> 00:56:24,000
template parameter because

00:56:22,240 --> 00:56:26,000
it reduces the number of different

00:56:24,000 --> 00:56:28,559
instantiations but

00:56:26,000 --> 00:56:30,079
you spend ram essentially and for

00:56:28,559 --> 00:56:33,760
function templates we can

00:56:30,079 --> 00:56:35,920
say check if we can use them as an api

00:56:33,760 --> 00:56:38,720
only so the function template is only in

00:56:35,920 --> 00:56:40,079
wrapper which redirects to our internal

00:56:38,720 --> 00:56:41,920
non-template version

00:56:40,079 --> 00:56:44,079
like in the send example where call the

00:56:41,920 --> 00:56:46,880
posix right to unfold it

00:56:44,079 --> 00:56:47,280
to provide a user with a safe api with

00:56:46,880 --> 00:56:51,760
less

00:56:47,280 --> 00:56:54,319
type and still have the benefits of

00:56:51,760 --> 00:56:55,359
not loading so much to code because we

00:56:54,319 --> 00:56:57,520
are using

00:56:55,359 --> 00:56:59,359
internally a different version so the

00:56:57,520 --> 00:57:01,359
layer of the template is very similar

00:56:59,359 --> 00:57:04,960
compiler probably inlines it

00:57:01,359 --> 00:57:07,760
and everything is nice

00:57:04,960 --> 00:57:09,280
we talked a lot about types you may not

00:57:07,760 --> 00:57:11,520
have noticed that but

00:57:09,280 --> 00:57:13,200
most of the things was about types how

00:57:11,520 --> 00:57:16,000
we instantiate a template

00:57:13,200 --> 00:57:17,040
it's about types sometimes it's about

00:57:16,000 --> 00:57:21,280
values

00:57:17,040 --> 00:57:23,599
but they are known at compile time and

00:57:21,280 --> 00:57:25,839
thinking types can be the following

00:57:23,599 --> 00:57:26,480
because we know the type at compile time

00:57:25,839 --> 00:57:29,280
we can

00:57:26,480 --> 00:57:31,680
do things to it at compile time we can

00:57:29,280 --> 00:57:35,280
modify it we can query its properties

00:57:31,680 --> 00:57:37,440
and the example here is that i can

00:57:35,280 --> 00:57:38,480
check whether a certain type is a

00:57:37,440 --> 00:57:40,960
pointer

00:57:38,480 --> 00:57:43,680
how do i do that this is a short version

00:57:40,960 --> 00:57:47,119
of what's in the type traits header

00:57:43,680 --> 00:57:49,599
it starts at a here with a struct

00:57:47,119 --> 00:57:50,160
template struct integral constant takes

00:57:49,599 --> 00:57:53,200
a class

00:57:50,160 --> 00:57:55,599
t and it uses that deduced type

00:57:53,200 --> 00:57:56,319
to create a non-type template parameter

00:57:55,599 --> 00:57:58,640
v

00:57:56,319 --> 00:58:01,040
internally it has a static const expert

00:57:58,640 --> 00:58:02,079
t named value where it assigns this

00:58:01,040 --> 00:58:04,960
value to

00:58:02,079 --> 00:58:06,960
and then in b and line number 9 and 10 i

00:58:04,960 --> 00:58:08,079
can create an integral constant of type

00:58:06,960 --> 00:58:11,359
bool true

00:58:08,079 --> 00:58:14,480
and type bool false i assign that to

00:58:11,359 --> 00:58:19,200
a using type called true and false

00:58:14,480 --> 00:58:22,960
type and then in c i'm creating another

00:58:19,200 --> 00:58:24,240
struct template which takes once again a

00:58:22,960 --> 00:58:26,319
signal type name t

00:58:24,240 --> 00:58:27,680
it's called is pointer and it derives

00:58:26,319 --> 00:58:29,920
from false type

00:58:27,680 --> 00:58:31,040
so this is my primary template and then

00:58:29,920 --> 00:58:34,000
i'm providing in d

00:58:31,040 --> 00:58:34,880
a specialization for that template is

00:58:34,000 --> 00:58:36,640
pointer

00:58:34,880 --> 00:58:38,160
and now if you're looking closely at

00:58:36,640 --> 00:58:40,559
nine number 20

00:58:38,160 --> 00:58:42,480
it says is point and angled brackets t

00:58:40,559 --> 00:58:45,760
so this is a specialization

00:58:42,480 --> 00:58:47,040
for t star and this one where this time

00:58:45,760 --> 00:58:50,960
we are deriving from

00:58:47,040 --> 00:58:52,079
true type and if we now used it in the

00:58:50,960 --> 00:58:54,000
code below

00:58:52,079 --> 00:58:55,440
with this point there are ankle brackets

00:58:54,000 --> 00:58:57,839
in star

00:58:55,440 --> 00:58:59,760
colon colon value this yields to true

00:58:57,839 --> 00:59:03,359
because the specialization

00:58:59,760 --> 00:59:06,160
for pointer is chosen and this yields to

00:59:03,359 --> 00:59:06,480
the internal value of material constant

00:59:06,160 --> 00:59:09,119
of

00:59:06,480 --> 00:59:10,400
true and it's the other way around if we

00:59:09,119 --> 00:59:12,720
are calling it with the

00:59:10,400 --> 00:59:13,599
northern pointer as a type then it

00:59:12,720 --> 00:59:16,839
yields to no

00:59:13,599 --> 00:59:18,880
so these are the two static asserts

00:59:16,839 --> 00:59:20,799
below

00:59:18,880 --> 00:59:23,280
and now i see we are running out of time

00:59:20,799 --> 00:59:23,280
slightly

00:59:23,440 --> 00:59:30,960
so here i have my

00:59:27,680 --> 00:59:33,520
class array class template array

00:59:30,960 --> 00:59:35,119
we've seen before and the goal is now

00:59:33,520 --> 00:59:38,720
that we are applying this

00:59:35,119 --> 00:59:40,880
student's pointer to this class because

00:59:38,720 --> 00:59:44,000
we are saying we want to limit it

00:59:40,880 --> 00:59:46,480
to not be able to be instantiable

00:59:44,000 --> 00:59:47,760
with an array of points or so for an

00:59:46,480 --> 00:59:49,920
array of pointers

00:59:47,760 --> 00:59:50,960
and we created this this pointer type

00:59:49,920 --> 00:59:52,559
trade before

00:59:50,960 --> 00:59:54,160
there's a version in the standard

00:59:52,559 --> 00:59:55,200
library in the type trade center and i'm

00:59:54,160 --> 00:59:58,400
using that in

00:59:55,200 --> 01:00:01,440
line number five here at a and

00:59:58,400 --> 01:00:03,200
the code in b low in line 24

01:00:01,440 --> 01:00:05,680
will no longer compile because the

01:00:03,200 --> 01:00:09,200
static assert is triggered

01:00:05,680 --> 01:00:11,680
it will give you a bunch of lines of

01:00:09,200 --> 01:00:14,480
error output but in the end it will say

01:00:11,680 --> 01:00:18,079
that your static assert has failed

01:00:14,480 --> 01:00:20,319
you can do better using c plus plus 20

01:00:18,079 --> 01:00:22,480
and using concepts there the key

01:00:20,319 --> 01:00:24,640
difference is that we have line 20

01:00:22,480 --> 01:00:26,640
where we have this requires clause where

01:00:24,640 --> 01:00:29,599
we put in our typed rate

01:00:26,640 --> 01:00:30,240
now we say it's not stop stood is point

01:00:29,599 --> 01:00:33,040
or we

01:00:30,240 --> 01:00:34,640
of t and the error message is much

01:00:33,040 --> 01:00:36,960
shorter and more precise because the

01:00:34,640 --> 01:00:40,079
compiler now exactly knows

01:00:36,960 --> 01:00:42,640
what is going on and what's wrong and

01:00:40,079 --> 01:00:44,640
line 22 will still not compile

01:00:42,640 --> 01:00:47,040
but this time with a much nicer error

01:00:44,640 --> 01:00:47,040
message

01:00:47,200 --> 01:00:51,040
on the final thing we have here is a we

01:00:49,520 --> 01:00:53,680
have a constexpr f

01:00:51,040 --> 01:00:55,359
and the key is that it's written

01:00:53,680 --> 01:00:57,680
differently than it's spelled

01:00:55,359 --> 01:01:00,640
so we say it's a context brief but it's

01:00:57,680 --> 01:01:03,359
written if constants were in code

01:01:00,640 --> 01:01:05,280
and that thing is an if which is

01:01:03,359 --> 01:01:07,520
evaluated at compile time

01:01:05,280 --> 01:01:08,640
so only one of the many branches you can

01:01:07,520 --> 01:01:12,079
have in that

01:01:08,640 --> 01:01:13,920
if will survive adds or will live in

01:01:12,079 --> 01:01:14,720
your binary all the other branches go

01:01:13,920 --> 01:01:17,119
away

01:01:14,720 --> 01:01:18,640
assuming that you're not instantiating

01:01:17,119 --> 01:01:20,559
this function template

01:01:18,640 --> 01:01:22,240
for different types then you will have

01:01:20,559 --> 01:01:24,559
the different branches in there for the

01:01:22,240 --> 01:01:27,280
different template instantiations

01:01:24,559 --> 01:01:27,920
and what i can do with this context per

01:01:27,280 --> 01:01:29,520
if

01:01:27,920 --> 01:01:31,520
is for example i have a function

01:01:29,520 --> 01:01:33,599
template called getvalue here

01:01:31,520 --> 01:01:34,720
and it's supposed to always return me a

01:01:33,599 --> 01:01:36,400
value

01:01:34,720 --> 01:01:38,799
because i do not want to check whether

01:01:36,400 --> 01:01:42,400
that thing is a pointer or

01:01:38,799 --> 01:01:42,960
just a regular type i call get value

01:01:42,400 --> 01:01:44,799
there and

01:01:42,960 --> 01:01:46,799
in the context where if i apply once

01:01:44,799 --> 01:01:49,200
again my studious pointer on this

01:01:46,799 --> 01:01:49,839
type t to figure out oh yes that's a

01:01:49,200 --> 01:01:51,680
pointer

01:01:49,839 --> 01:01:53,839
then i first assert whether it's a null

01:01:51,680 --> 01:01:57,599
point or not and otherwise i return

01:01:53,839 --> 01:02:00,960
to the the dereferenced version

01:01:57,599 --> 01:02:01,440
of t if it's not a pointer then i simply

01:02:00,960 --> 01:02:04,240
return

01:02:01,440 --> 01:02:06,960
t and that allows me to place all these

01:02:04,240 --> 01:02:10,160
calls below to get value

01:02:06,960 --> 01:02:12,079
once for a regular end as an i and once

01:02:10,160 --> 01:02:16,000
for a pointer as an ip

01:02:12,079 --> 01:02:18,799
and i can also pair some integer like 43

01:02:16,000 --> 01:02:19,599
there's a variation to it i can also use

01:02:18,799 --> 01:02:22,240
that

01:02:19,599 --> 01:02:24,000
to say okay i like to have a function

01:02:22,240 --> 01:02:25,039
template which converts me everything

01:02:24,000 --> 01:02:27,039
into a string

01:02:25,039 --> 01:02:29,760
a stud string i named this function

01:02:27,039 --> 01:02:30,160
stude and i use a const experience this

01:02:29,760 --> 01:02:31,680
time

01:02:30,160 --> 01:02:34,640
with another type trade from the

01:02:31,680 --> 01:02:38,160
standard library called is convertible

01:02:34,640 --> 01:02:40,640
and this checks whether there is a way

01:02:38,160 --> 01:02:42,480
for stored string to convert this t i'm

01:02:40,640 --> 01:02:45,599
passing in to a stored string

01:02:42,480 --> 01:02:47,440
if so i'm simply returning t because the

01:02:45,599 --> 01:02:49,440
constructors of stood string will kick

01:02:47,440 --> 01:02:50,240
in there and then convert it to a stood

01:02:49,440 --> 01:02:53,520
string

01:02:50,240 --> 01:02:56,960
and otherwise i will call the method

01:02:53,520 --> 01:02:59,680
tostring for stood string which converts

01:02:56,960 --> 01:03:02,240
for example numbers into a stoop string

01:02:59,680 --> 01:03:04,480
and this allows me to call it or to use

01:03:02,240 --> 01:03:06,559
it in line 13 and 14

01:03:04,480 --> 01:03:07,520
once passing a stood string it's not

01:03:06,559 --> 01:03:09,920
efficient

01:03:07,520 --> 01:03:10,559
we can do better here if you listen to

01:03:09,920 --> 01:03:13,039
nico's

01:03:10,559 --> 01:03:14,640
talk yesterday about move semantics we

01:03:13,039 --> 01:03:17,119
can improve a lot here but

01:03:14,640 --> 01:03:19,760
it's to focus only on templates and i

01:03:17,119 --> 01:03:25,280
can pass in and line up 40 in here

01:03:19,760 --> 01:03:26,880
my 42 and that simply works

01:03:25,280 --> 01:03:29,119
and i'm sorry that i'm not able to

01:03:26,880 --> 01:03:32,559
answer any more questions here i think

01:03:29,119 --> 01:03:35,280
we are out of time essentially

01:03:32,559 --> 01:03:36,319
as i said we can talk about this later

01:03:35,280 --> 01:03:38,559
in the q a

01:03:36,319 --> 01:03:40,400
or if you reach me at the remote table

01:03:38,559 --> 01:03:42,839
at this point for the first talk i can

01:03:40,400 --> 01:03:45,359
say i am feltish if you tuned in for the

01:03:42,839 --> 01:03:48,319
first couple of slides

01:03:45,359 --> 01:03:50,319
you know the translation i throw the or

01:03:48,319 --> 01:03:52,240
i'm into progress to finish that

01:03:50,319 --> 01:03:54,160
book notebook c plus plus tips and

01:03:52,240 --> 01:03:56,079
tricks with templates

01:03:54,160 --> 01:03:57,680
you can get the discounted version here

01:03:56,079 --> 01:04:00,000
it's on lean pub and

01:03:57,680 --> 01:04:02,079
hopefully it will be soon be in the

01:04:00,000 --> 01:04:05,200
printed version available as well

01:04:02,079 --> 01:04:07,200
so remember the applause q a so if you

01:04:05,200 --> 01:04:08,319
like to applause for john or for all the

01:04:07,200 --> 01:04:12,000
volunteers

01:04:08,319 --> 01:04:14,880
there's time to do this right now

01:04:12,000 --> 01:04:16,240
other than that i hope to see you or you

01:04:14,880 --> 01:04:18,640
listen to me

01:04:16,240 --> 01:04:19,440
for the second part in roughly 30

01:04:18,640 --> 01:04:21,599
minutes

01:04:19,440 --> 01:04:22,559
thanks for tuning in thanks for watching

01:04:21,599 --> 01:04:27,839
stay safe

01:04:22,559 --> 01:04:27,839
and see you later bye

01:04:44,640 --> 01:04:46,720

YouTube URL: https://www.youtube.com/watch?v=VNJ4wiuxJM4


