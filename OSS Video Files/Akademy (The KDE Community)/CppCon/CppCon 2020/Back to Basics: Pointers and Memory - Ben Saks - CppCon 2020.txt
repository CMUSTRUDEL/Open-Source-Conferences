Title: Back to Basics: Pointers and Memory - Ben Saks - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---

The prevailing wisdom in Modern C++ is to favor smart pointers and container classes over raw pointers and built-in arrays -- there are too many traps and pitfalls that come with using those more-primitive types. However, many C++ programmers can’t avoid using them because they’re still so prevalent in legacy C++ code and C libraries. If you have to use raw pointers and built-in arrays, then you should learn to use them safely and effectively.

This session explains the true nature of built-in pointers and arrays, and why they’re so easily confused despite actually being distinct types. It covers the rules for pointer and array type conversions, along with the mechanics of pointer arithmetic and array subscripting. It compares and contrasts pointers with references and iterators, as well as the pointer and reference member types in the STL, to help you make more informed choices about what to use when. This session also explains the origins of the types size_t and ptrdiff_t, and their relationship to size and difference types in the STL.

You’ll leave with a clearer understanding of how pointer operations behave, whether you’re using raw pointers and built-in arrays or smart pointers and container classes.

---
Ben Saks
Chief Engineer, Saks & Associates

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,200 --> 00:00:13,280
all right

00:00:10,160 --> 00:00:15,360
hello everyone on cppcon uh i'm ben sax

00:00:13,280 --> 00:00:17,600
for those of you who don't know me

00:00:15,360 --> 00:00:19,119
uh my company saks associates does

00:00:17,600 --> 00:00:21,680
professional level training

00:00:19,119 --> 00:00:22,320
in cnc plus plus programming for

00:00:21,680 --> 00:00:25,519
companies

00:00:22,320 --> 00:00:27,199
all over the world and uh let's

00:00:25,519 --> 00:00:29,119
i'm here to talk about pointers in

00:00:27,199 --> 00:00:32,960
memory there's a fair bit to say

00:00:29,119 --> 00:00:34,079
so let's get to it oh uh before i get

00:00:32,960 --> 00:00:37,680
started let me say

00:00:34,079 --> 00:00:40,960
uh feel free to ask questions

00:00:37,680 --> 00:00:45,280
in the chat or in the using the q a

00:00:40,960 --> 00:00:47,920
uh in remo i have someone relaying those

00:00:45,280 --> 00:00:48,640
questions to me but please understand

00:00:47,920 --> 00:00:52,559
we're on

00:00:48,640 --> 00:00:54,239
about a 10 to 15 second delay so

00:00:52,559 --> 00:00:55,600
if i if you type in a question and it

00:00:54,239 --> 00:00:56,800
doesn't look like i'm responding

00:00:55,600 --> 00:00:59,280
immediately

00:00:56,800 --> 00:01:00,320
i'm not necessarily ignoring you i might

00:00:59,280 --> 00:01:03,600
just be

00:01:00,320 --> 00:01:07,360
receiving it a little bit later on

00:01:03,600 --> 00:01:10,240
okay with that let's get started so

00:01:07,360 --> 00:01:11,520
c plus has had language support for

00:01:10,240 --> 00:01:12,960
pointers and arrays

00:01:11,520 --> 00:01:14,720
all along it was something that it

00:01:12,960 --> 00:01:17,360
inherited from c

00:01:14,720 --> 00:01:18,960
so from the very earliest days of c plus

00:01:17,360 --> 00:01:21,600
plus we could write

00:01:18,960 --> 00:01:22,560
pointer objects like this or array

00:01:21,600 --> 00:01:25,600
objects

00:01:22,560 --> 00:01:27,920
like this now

00:01:25,600 --> 00:01:29,920
in modern c plus plus we usually prefer

00:01:27,920 --> 00:01:32,320
to avoid doing using these

00:01:29,920 --> 00:01:34,159
what i'm going to call raw pointers and

00:01:32,320 --> 00:01:37,439
arrays

00:01:34,159 --> 00:01:40,159
in favor of other more

00:01:37,439 --> 00:01:43,200
recent developments like smart pointers

00:01:40,159 --> 00:01:46,399
such as unique pointer or shared pointer

00:01:43,200 --> 00:01:49,280
container classes like vector or list

00:01:46,399 --> 00:01:51,360
because those types offer a lot of

00:01:49,280 --> 00:01:53,520
advantages they have

00:01:51,360 --> 00:01:55,360
using the smart pointers and container

00:01:53,520 --> 00:01:57,759
classes provides

00:01:55,360 --> 00:01:58,640
a clearer indication of the author's

00:01:57,759 --> 00:02:00,960
intent

00:01:58,640 --> 00:02:01,680
both in terms of the functions you have

00:02:00,960 --> 00:02:04,880
available

00:02:01,680 --> 00:02:05,439
and just in terms of the name of the

00:02:04,880 --> 00:02:07,920
type

00:02:05,439 --> 00:02:09,520
gives you a clear sense of ownership in

00:02:07,920 --> 00:02:12,560
the case of smart pointers

00:02:09,520 --> 00:02:14,319
or the kinds of

00:02:12,560 --> 00:02:16,080
operations you'll be doing with the type

00:02:14,319 --> 00:02:17,440
in the case of container classes

00:02:16,080 --> 00:02:19,599
and we don't need to worry about

00:02:17,440 --> 00:02:22,239
releasing resources

00:02:19,599 --> 00:02:23,520
so why are we talking about raw pointers

00:02:22,239 --> 00:02:26,319
and arrays

00:02:23,520 --> 00:02:27,680
well you might need to use them in some

00:02:26,319 --> 00:02:31,519
situations

00:02:27,680 --> 00:02:33,760
for example you might have a library

00:02:31,519 --> 00:02:36,080
that has an interface that's based on

00:02:33,760 --> 00:02:39,200
raw pointers this is often the case

00:02:36,080 --> 00:02:42,400
when we are using a c library

00:02:39,200 --> 00:02:44,319
but using it in a c plus plus project

00:02:42,400 --> 00:02:45,920
this also happens when you're accessing

00:02:44,319 --> 00:02:49,040
hardware at a low level

00:02:45,920 --> 00:02:50,800
if you saw dan sax's talk on

00:02:49,040 --> 00:02:52,720
representing memory mapped objects as

00:02:50,800 --> 00:02:55,360
devices yesterday

00:02:52,720 --> 00:02:56,400
uh you will you would have seen some of

00:02:55,360 --> 00:02:59,599
that

00:02:56,400 --> 00:03:01,840
uh it also happens if you're actually

00:02:59,599 --> 00:03:03,760
implementing a container class or a

00:03:01,840 --> 00:03:06,400
smart pointer yourself

00:03:03,760 --> 00:03:07,840
because it's very difficult to create a

00:03:06,400 --> 00:03:09,760
smart pointer with different

00:03:07,840 --> 00:03:11,760
characteristics from the smart pointers

00:03:09,760 --> 00:03:15,360
we already have

00:03:11,760 --> 00:03:17,040
using the smart pointers we already have

00:03:15,360 --> 00:03:18,800
and even if none of those things apply

00:03:17,040 --> 00:03:20,879
there's a good chance that you just have

00:03:18,800 --> 00:03:21,920
some older code in your project that

00:03:20,879 --> 00:03:24,799
will use

00:03:21,920 --> 00:03:25,360
raw pointers and arrays so even if

00:03:24,799 --> 00:03:26,959
you're not

00:03:25,360 --> 00:03:29,680
programming with them it's a good idea

00:03:26,959 --> 00:03:33,440
to be able to understand them

00:03:29,680 --> 00:03:34,640
okay so um here is the basic outline for

00:03:33,440 --> 00:03:37,200
the talk

00:03:34,640 --> 00:03:38,319
i'm going to be starting just with some

00:03:37,200 --> 00:03:40,720
overview of

00:03:38,319 --> 00:03:41,519
pointers to objects in general we will

00:03:40,720 --> 00:03:43,680
get into

00:03:41,519 --> 00:03:44,799
array arithmetic array and pointer

00:03:43,680 --> 00:03:46,799
arithmetic

00:03:44,799 --> 00:03:48,239
some related topics like size t and

00:03:46,799 --> 00:03:51,040
putter diff t

00:03:48,239 --> 00:03:51,760
we'll start we will go into pointer type

00:03:51,040 --> 00:03:54,400
conversions

00:03:51,760 --> 00:03:56,080
first involving const and then other

00:03:54,400 --> 00:03:58,319
types of conversions

00:03:56,080 --> 00:03:59,120
and close out with a comparison to

00:03:58,319 --> 00:04:01,760
references

00:03:59,120 --> 00:04:03,120
and what you might use pointers for

00:04:01,760 --> 00:04:06,080
versus what you might use

00:04:03,120 --> 00:04:06,080
references for

00:04:06,400 --> 00:04:09,680
okay i suspect that a lot of this is

00:04:08,879 --> 00:04:11,840
going to be

00:04:09,680 --> 00:04:14,319
material that's familiar to you so i'm

00:04:11,840 --> 00:04:17,199
going to go through it rather quickly

00:04:14,319 --> 00:04:17,680
but feel free to stop and ask questions

00:04:17,199 --> 00:04:21,600
uh

00:04:17,680 --> 00:04:23,120
this is meant to be if you have uh

00:04:21,600 --> 00:04:25,120
to make sure that we're all on the same

00:04:23,120 --> 00:04:27,840
page and just in case i say anything

00:04:25,120 --> 00:04:28,720
in the details here that's surprising

00:04:27,840 --> 00:04:31,600
feel free to

00:04:28,720 --> 00:04:31,600
jump in and ask

00:04:32,400 --> 00:04:36,479
okay so a pointer is an object that

00:04:35,840 --> 00:04:39,919
holds

00:04:36,479 --> 00:04:41,919
the address of another object and

00:04:39,919 --> 00:04:44,400
every pointer has a specific type that

00:04:41,919 --> 00:04:47,280
it points to so here we're creating

00:04:44,400 --> 00:04:49,759
a pointer to an integer or a pointer to

00:04:47,280 --> 00:04:53,360
an unsigned long and as we'll see

00:04:49,759 --> 00:04:57,360
these objects will only point to

00:04:53,360 --> 00:05:00,080
integers or unsigned longs respectively

00:04:57,360 --> 00:05:01,120
so when i have an object and i want to

00:05:00,080 --> 00:05:03,680
get the address

00:05:01,120 --> 00:05:06,080
of that object i take its address using

00:05:03,680 --> 00:05:09,360
the ampersand operator here

00:05:06,080 --> 00:05:13,120
so for any object that's a pipe t

00:05:09,360 --> 00:05:17,039
ampersand x uh any object x of type t

00:05:13,120 --> 00:05:19,759
ampersand x has type pointer to p

00:05:17,039 --> 00:05:20,080
so here when i want to i have an integer

00:05:19,759 --> 00:05:22,639
and an

00:05:20,080 --> 00:05:24,000
unsigned long i want to assign their

00:05:22,639 --> 00:05:26,240
addresses to

00:05:24,000 --> 00:05:27,039
the pointers that i created on the last

00:05:26,240 --> 00:05:30,240
slide

00:05:27,039 --> 00:05:35,360
i can do that by assigning ampersand i

00:05:30,240 --> 00:05:35,360
or ampersand ul to those pointers

00:05:35,840 --> 00:05:40,080
in general you can modify what a pointer

00:05:38,800 --> 00:05:42,479
points to

00:05:40,080 --> 00:05:44,240
after it's been created we'll talk a

00:05:42,479 --> 00:05:46,000
little bit later about some situations

00:05:44,240 --> 00:05:49,120
where that doesn't apply

00:05:46,000 --> 00:05:50,240
but in many cases a pointer can be made

00:05:49,120 --> 00:05:52,639
to point to

00:05:50,240 --> 00:05:54,720
something else at different times in its

00:05:52,639 --> 00:05:57,360
life and this is often what we're using

00:05:54,720 --> 00:05:58,400
pointers for uh we want to be able to

00:05:57,360 --> 00:06:01,440
operate on

00:05:58,400 --> 00:06:02,400
the pointer p and expect that sometimes

00:06:01,440 --> 00:06:05,199
it's pointing to

00:06:02,400 --> 00:06:06,720
object a here and sometimes it's

00:06:05,199 --> 00:06:10,720
pointing to object b

00:06:06,720 --> 00:06:11,919
here so i can set up my pointer to point

00:06:10,720 --> 00:06:14,000
to a initially

00:06:11,919 --> 00:06:15,280
at some later point i can change it to

00:06:14,000 --> 00:06:19,440
point to b by just

00:06:15,280 --> 00:06:21,039
by assigning the address of b to p

00:06:19,440 --> 00:06:23,039
i can also have a pointer that doesn't

00:06:21,039 --> 00:06:23,919
point to anything that has a what we

00:06:23,039 --> 00:06:25,919
call a null

00:06:23,919 --> 00:06:27,440
value and there are a few different ways

00:06:25,919 --> 00:06:30,960
that we can do this

00:06:27,440 --> 00:06:34,080
uh there's the capital null

00:06:30,960 --> 00:06:34,960
constant there's 0 counts as a null

00:06:34,080 --> 00:06:37,680
value

00:06:34,960 --> 00:06:39,360
and there's also null putter in lower

00:06:37,680 --> 00:06:41,680
case

00:06:39,360 --> 00:06:43,440
uh and no putter is generally the

00:06:41,680 --> 00:06:44,400
preferred way for reasons i'm about to

00:06:43,440 --> 00:06:46,319
talk about

00:06:44,400 --> 00:06:47,600
but all three of these will work they're

00:06:46,319 --> 00:06:52,080
all equivalent

00:06:47,600 --> 00:06:55,280
in terms of setting p1 p2 and p3 to

00:06:52,080 --> 00:06:56,560
null values the reason we generally

00:06:55,280 --> 00:06:59,840
prefer to use

00:06:56,560 --> 00:07:02,560
null putter in lowercase is

00:06:59,840 --> 00:07:04,479
null is a constant that came from c and

00:07:02,560 --> 00:07:07,680
it turns out it's actually

00:07:04,479 --> 00:07:11,759
defined as either 0

00:07:07,680 --> 00:07:12,880
or 0 as a long but either way it's an

00:07:11,759 --> 00:07:15,280
integer type

00:07:12,880 --> 00:07:16,400
it doesn't actually have a pointer type

00:07:15,280 --> 00:07:19,520
even though

00:07:16,400 --> 00:07:22,720
null was created to

00:07:19,520 --> 00:07:25,280
be a value for pointers that don't point

00:07:22,720 --> 00:07:27,680
to anything else

00:07:25,280 --> 00:07:28,479
and so this had the surprising effect

00:07:27,680 --> 00:07:32,080
when we got to c

00:07:28,479 --> 00:07:34,720
plus plus and had overloaded functions

00:07:32,080 --> 00:07:35,520
that if we had a set of overloaded

00:07:34,720 --> 00:07:38,400
functions

00:07:35,520 --> 00:07:39,039
some of which took integers and some of

00:07:38,400 --> 00:07:42,400
which took

00:07:39,039 --> 00:07:45,440
pointers the caller could

00:07:42,400 --> 00:07:48,080
call f passing null

00:07:45,440 --> 00:07:48,800
to that function and they're probably

00:07:48,080 --> 00:07:51,840
thinking of

00:07:48,800 --> 00:07:52,479
null as a pointer constant the author of

00:07:51,840 --> 00:07:56,000
this code

00:07:52,479 --> 00:07:56,400
probably intended to call the point of

00:07:56,000 --> 00:07:58,720
the

00:07:56,400 --> 00:08:00,240
f that takes a pointer to a character

00:07:58,720 --> 00:08:02,960
but what actually happens

00:08:00,240 --> 00:08:03,759
is it calls the f that takes an integer

00:08:02,960 --> 00:08:06,800
because null

00:08:03,759 --> 00:08:09,199
is actually a closer match for that

00:08:06,800 --> 00:08:12,240
version of f

00:08:09,199 --> 00:08:15,599
so to prevent that c 11 added this

00:08:12,240 --> 00:08:18,400
null putter keyword uh

00:08:15,599 --> 00:08:19,520
null putter is actually a unique type

00:08:18,400 --> 00:08:22,720
that

00:08:19,520 --> 00:08:25,599
has conversions to any pointer type

00:08:22,720 --> 00:08:26,000
but it never converts to an integer type

00:08:25,599 --> 00:08:29,039
so the

00:08:26,000 --> 00:08:32,479
result of that is that now we can call f

00:08:29,039 --> 00:08:35,200
pass it null putter and this will

00:08:32,479 --> 00:08:38,320
convert to any type of pointer

00:08:35,200 --> 00:08:39,039
that f might take but it'll never

00:08:38,320 --> 00:08:42,719
convert to an

00:08:39,039 --> 00:08:43,279
integer value so there's no well maybe i

00:08:42,719 --> 00:08:47,200
should say

00:08:43,279 --> 00:08:47,200
less possibility of confusion

00:08:47,279 --> 00:08:51,760
in terms of which function might

00:08:49,760 --> 00:08:52,959
actually be called when i pass a null

00:08:51,760 --> 00:08:55,440
pointer to it

00:08:52,959 --> 00:08:56,320
that's what makes this the preferred way

00:08:55,440 --> 00:08:58,880
to represent

00:08:56,320 --> 00:09:00,399
null pointer values in modern c plus

00:08:58,880 --> 00:09:03,200
plus

00:09:00,399 --> 00:09:05,440
right when i have a pointer i can

00:09:03,200 --> 00:09:07,760
dereference the pointer using the star

00:09:05,440 --> 00:09:09,040
operator to get to the object that that

00:09:07,760 --> 00:09:12,320
pointer actually

00:09:09,040 --> 00:09:13,360
points to so here i have an integer and

00:09:12,320 --> 00:09:15,279
unsigned long

00:09:13,360 --> 00:09:16,399
i set up pointers that point to those

00:09:15,279 --> 00:09:19,519
things

00:09:16,399 --> 00:09:23,040
when i access star pi or star

00:09:19,519 --> 00:09:24,640
pul i'm accessing the integer or the

00:09:23,040 --> 00:09:27,360
unsigned long

00:09:24,640 --> 00:09:28,000
through those pointers so this first

00:09:27,360 --> 00:09:31,839
statement

00:09:28,000 --> 00:09:34,560
stores a 14 into

00:09:31,839 --> 00:09:37,120
into this pointer or sorry into the

00:09:34,560 --> 00:09:39,600
object that pi points to

00:09:37,120 --> 00:09:40,480
this statement adds two to whatever

00:09:39,600 --> 00:09:45,279
value

00:09:40,480 --> 00:09:46,959
ul points to your pul points to

00:09:45,279 --> 00:09:48,959
now if you're dealing with a null

00:09:46,959 --> 00:09:50,000
pointer dereferencing it is something

00:09:48,959 --> 00:09:52,560
you want to avoid

00:09:50,000 --> 00:09:54,320
doing you want to be careful not to

00:09:52,560 --> 00:09:54,880
dereference a null pointer because the

00:09:54,320 --> 00:09:57,279
result

00:09:54,880 --> 00:09:58,399
is undefined behavior we don't know

00:09:57,279 --> 00:10:00,959
exactly

00:09:58,399 --> 00:10:01,600
what bad thing will happen but it may

00:10:00,959 --> 00:10:04,640
very well

00:10:01,600 --> 00:10:06,800
be a bad thing and we should watch out

00:10:04,640 --> 00:10:09,680
for that

00:10:06,800 --> 00:10:12,240
okay uh a pointer often doesn't have the

00:10:09,680 --> 00:10:13,760
same lifetime as the object that it

00:10:12,240 --> 00:10:16,640
points to

00:10:13,760 --> 00:10:19,120
so here we have a function f that has a

00:10:16,640 --> 00:10:23,360
parameter of type pointer to integer

00:10:19,120 --> 00:10:25,600
so each time we call f this parameter

00:10:23,360 --> 00:10:27,279
starts a new version of this parameter

00:10:25,600 --> 00:10:29,360
is created

00:10:27,279 --> 00:10:30,800
uh it starts its lifetime when the

00:10:29,360 --> 00:10:32,320
function is called

00:10:30,800 --> 00:10:34,240
and its lifetime goes throughout the

00:10:32,320 --> 00:10:35,120
function and ends when we reach the

00:10:34,240 --> 00:10:39,200
closing curve

00:10:35,120 --> 00:10:41,519
breaks so here when i call f

00:10:39,200 --> 00:10:43,519
and i pass it the address of an of an

00:10:41,519 --> 00:10:45,920
integer i

00:10:43,519 --> 00:10:47,120
each pointer only lasts for the duration

00:10:45,920 --> 00:10:50,800
of a single call to

00:10:47,120 --> 00:10:53,519
f but i existed before the call to f

00:10:50,800 --> 00:10:56,880
it'll continue to exist after f it has a

00:10:53,519 --> 00:10:56,880
completely different lifetime

00:10:58,480 --> 00:11:02,320
done in this direction there's no real

00:11:00,160 --> 00:11:03,440
danger here where things get a little

00:11:02,320 --> 00:11:07,440
more complicated

00:11:03,440 --> 00:11:08,640
is when the pointer outlives the object

00:11:07,440 --> 00:11:10,160
to which it points

00:11:08,640 --> 00:11:11,760
so here's a situation where this

00:11:10,160 --> 00:11:15,120
function g

00:11:11,760 --> 00:11:18,800
creates an object an integer internally

00:11:15,120 --> 00:11:22,160
into i here this i is a local value

00:11:18,800 --> 00:11:24,959
it will die when we reach the closing

00:11:22,160 --> 00:11:27,760
curly brace of this function

00:11:24,959 --> 00:11:28,800
but g is written to return a pointer to

00:11:27,760 --> 00:11:31,680
i

00:11:28,800 --> 00:11:32,079
which means that when we've returned

00:11:31,680 --> 00:11:35,760
from

00:11:32,079 --> 00:11:37,600
g where this pointer that was returned

00:11:35,760 --> 00:11:38,880
is pointing to something that no longer

00:11:37,600 --> 00:11:42,480
exists

00:11:38,880 --> 00:11:43,839
and so pi gets is now pointing to a dead

00:11:42,480 --> 00:11:46,320
object

00:11:43,839 --> 00:11:47,600
we call this a dangling pointer and just

00:11:46,320 --> 00:11:50,399
like with null pointers

00:11:47,600 --> 00:11:52,560
accessing star pi at this point would

00:11:50,399 --> 00:11:54,959
produce undefined behavior

00:11:52,560 --> 00:11:56,000
and we want to watch out for that that

00:11:54,959 --> 00:11:57,920
happens because

00:11:56,000 --> 00:11:59,279
there's not really an object there

00:11:57,920 --> 00:12:02,399
anymore there's just

00:11:59,279 --> 00:12:05,839
the ghost of an object

00:12:02,399 --> 00:12:09,360
all right so moving on to arrays

00:12:05,839 --> 00:12:11,839
and pointer arithmetic uh arrays in c

00:12:09,360 --> 00:12:13,040
plus plus on the surface aren't that

00:12:11,839 --> 00:12:14,639
much different from the

00:12:13,040 --> 00:12:16,880
from the way that they are in other

00:12:14,639 --> 00:12:19,440
languages um

00:12:16,880 --> 00:12:20,160
i suppose a lot of languages that we use

00:12:19,440 --> 00:12:23,440
today are

00:12:20,160 --> 00:12:26,079
interpreted so one difference is that

00:12:23,440 --> 00:12:27,440
when you dimension an array in c plus

00:12:26,079 --> 00:12:30,480
plus the array has to

00:12:27,440 --> 00:12:32,800
the dimension of the array the n here

00:12:30,480 --> 00:12:34,079
has to be an integer constant expression

00:12:32,800 --> 00:12:37,200
something that can be

00:12:34,079 --> 00:12:39,920
evaluated at compile time

00:12:37,200 --> 00:12:42,320
uh but otherwise it behaves a lot like

00:12:39,920 --> 00:12:44,560
arrays in other languages

00:12:42,320 --> 00:12:45,519
um the elements are all numbered from

00:12:44,560 --> 00:12:48,320
zero to

00:12:45,519 --> 00:12:48,320
n minus one

00:12:48,720 --> 00:12:54,399
uh oh no i wasn't actually referencing

00:12:52,480 --> 00:12:56,959
the life of pi there i just happened to

00:12:54,399 --> 00:13:00,399
type in pi as the pointer

00:12:56,959 --> 00:13:04,480
and uh that happens to be pi

00:13:00,399 --> 00:13:04,880
so uh but no uh i didn't really realize

00:13:04,480 --> 00:13:08,000
that

00:13:04,880 --> 00:13:10,000
particular pun okay um

00:13:08,000 --> 00:13:11,200
so the number the elements are numbered

00:13:10,000 --> 00:13:13,839
zero through n

00:13:11,200 --> 00:13:14,480
minus one so the nth element is the

00:13:13,839 --> 00:13:17,519
first one

00:13:14,480 --> 00:13:19,040
it is the first element beyond the end

00:13:17,519 --> 00:13:21,920
of the array

00:13:19,040 --> 00:13:22,320
i can access the zeroth element with the

00:13:21,920 --> 00:13:26,399
with

00:13:22,320 --> 00:13:29,600
x square bracket zero i can access

00:13:26,399 --> 00:13:33,600
any element the k element

00:13:29,600 --> 00:13:33,600
but with x square bracket k

00:13:33,760 --> 00:13:38,000
now i can also access the elements of an

00:13:36,000 --> 00:13:38,880
array through pointers i can set up a

00:13:38,000 --> 00:13:42,240
pointer

00:13:38,880 --> 00:13:44,800
that points to an element in the array

00:13:42,240 --> 00:13:46,800
like this and then i can modify the

00:13:44,800 --> 00:13:49,199
value of that element

00:13:46,800 --> 00:13:51,040
through that pointer so here i set up a

00:13:49,199 --> 00:13:52,399
pointer to a character that points to

00:13:51,040 --> 00:13:56,399
the first element of

00:13:52,399 --> 00:14:00,160
x if i write to the character

00:13:56,399 --> 00:14:01,600
that pc points to it's the same as if

00:14:00,160 --> 00:14:06,320
i'd written to

00:14:01,600 --> 00:14:08,959
x sub zero and i can adjust that pointer

00:14:06,320 --> 00:14:09,360
by incrementing it so that it points to

00:14:08,959 --> 00:14:12,160
other

00:14:09,360 --> 00:14:14,320
objects in the array as well if i add

00:14:12,160 --> 00:14:17,199
one to the pointer

00:14:14,320 --> 00:14:17,760
that has the effect of moving us to the

00:14:17,199 --> 00:14:21,199
next

00:14:17,760 --> 00:14:22,160
element in the array so now after this

00:14:21,199 --> 00:14:27,600
statement pc

00:14:22,160 --> 00:14:30,720
points to x sub one and assigning to it

00:14:27,600 --> 00:14:36,240
uh has the effect of writing a c

00:14:30,720 --> 00:14:36,240
to x sub one rather than x sub zero

00:14:36,800 --> 00:14:40,880
so in general plus plus p causes p to

00:14:39,839 --> 00:14:43,040
point to the next

00:14:40,880 --> 00:14:44,959
array element and it doesn't matter what

00:14:43,040 --> 00:14:47,120
the size of the array elements

00:14:44,959 --> 00:14:49,360
are so the example i was just showing

00:14:47,120 --> 00:14:52,160
you used pointers to characters

00:14:49,360 --> 00:14:54,160
characters are always size one so plus

00:14:52,160 --> 00:14:55,600
plus p in that situation actually would

00:14:54,160 --> 00:14:58,959
literally add

00:14:55,600 --> 00:14:59,920
one to the underlying value but if p

00:14:58,959 --> 00:15:03,120
were a pointer to an

00:14:59,920 --> 00:15:05,440
integer then size of

00:15:03,120 --> 00:15:08,160
int is typically greater than one it's

00:15:05,440 --> 00:15:10,560
often four on a lot of modern platforms

00:15:08,160 --> 00:15:11,519
in which case plus plus p would actually

00:15:10,560 --> 00:15:14,880
have the effect

00:15:11,519 --> 00:15:15,920
of increasing the underlying value of

00:15:14,880 --> 00:15:19,519
the pointer by

00:15:15,920 --> 00:15:22,800
four so that

00:15:19,519 --> 00:15:26,959
it really points to the next

00:15:22,800 --> 00:15:28,880
integer element in the array so

00:15:26,959 --> 00:15:31,120
it's not uncommon to see people use

00:15:28,880 --> 00:15:32,800
pointers to step through the elements of

00:15:31,120 --> 00:15:34,560
an array like this so we

00:15:32,800 --> 00:15:36,800
start out first time through the loop

00:15:34,560 --> 00:15:38,639
this pointer points to

00:15:36,800 --> 00:15:40,399
points the first element the one with

00:15:38,639 --> 00:15:43,360
value one

00:15:40,399 --> 00:15:45,040
uh we increment the pointer each time

00:15:43,360 --> 00:15:46,720
through the loop so that after that it

00:15:45,040 --> 00:15:48,160
points to the next element and then the

00:15:46,720 --> 00:15:52,639
next one after that

00:15:48,160 --> 00:15:54,560
so forth and we stop when we reach

00:15:52,639 --> 00:15:56,480
the point where the pointer points to

00:15:54,560 --> 00:15:59,920
the element one beyond

00:15:56,480 --> 00:16:03,199
the end of the array

00:15:59,920 --> 00:16:06,399
oh uh yes someone's asking about the

00:16:03,199 --> 00:16:09,440
question of using plus plus p

00:16:06,399 --> 00:16:11,440
versus p plus plus

00:16:09,440 --> 00:16:13,360
for built-in point for pointers of

00:16:11,440 --> 00:16:15,120
built-in types like pointer to character

00:16:13,360 --> 00:16:18,079
and pointer to integer

00:16:15,120 --> 00:16:19,839
it generally you won't see much of a

00:16:18,079 --> 00:16:21,040
difference in performance in almost

00:16:19,839 --> 00:16:24,160
every case

00:16:21,040 --> 00:16:28,639
um they have a slightly different

00:16:24,160 --> 00:16:31,759
meaning um the res plus plus p

00:16:28,639 --> 00:16:33,519
has effectively has a return value you

00:16:31,759 --> 00:16:36,240
can assign

00:16:33,519 --> 00:16:38,000
the value of plus plus p to something

00:16:36,240 --> 00:16:41,040
and what you get is the value of

00:16:38,000 --> 00:16:43,680
p after doing the increment

00:16:41,040 --> 00:16:45,279
if you assign the value of p plus plus

00:16:43,680 --> 00:16:47,839
to something

00:16:45,279 --> 00:16:49,279
what you get is what is assigned is the

00:16:47,839 --> 00:16:52,800
value of p

00:16:49,279 --> 00:16:53,920
before the increments that's the key

00:16:52,800 --> 00:16:57,600
difference

00:16:53,920 --> 00:16:58,320
uh which for some class types that have

00:16:57,600 --> 00:17:01,759
plus plus

00:16:58,320 --> 00:17:03,680
operators means that uh plus plus p

00:17:01,759 --> 00:17:04,880
is a little bit more efficient than p

00:17:03,680 --> 00:17:06,799
plus plus

00:17:04,880 --> 00:17:08,720
or objects of built-in types you

00:17:06,799 --> 00:17:10,160
generally won't notice a difference

00:17:08,720 --> 00:17:11,919
but i think it's just a good habit to

00:17:10,160 --> 00:17:15,360
get into using the prefix

00:17:11,919 --> 00:17:18,640
plus plus for that reason

00:17:15,360 --> 00:17:21,919
so uh this loop goes

00:17:18,640 --> 00:17:24,160
until we point to the first element

00:17:21,919 --> 00:17:25,280
after the end of the array this sort of

00:17:24,160 --> 00:17:28,480
imaginary

00:17:25,280 --> 00:17:32,400
phantom element one beyond the

00:17:28,480 --> 00:17:35,919
end and we can safely point

00:17:32,400 --> 00:17:40,160
to this element or take the address of

00:17:35,919 --> 00:17:41,760
the equival of x sub n in the array

00:17:40,160 --> 00:17:43,360
for the purposes of figuring out if

00:17:41,760 --> 00:17:43,919
we've actually reached the end of the

00:17:43,360 --> 00:17:46,320
array

00:17:43,919 --> 00:17:47,440
or for doing pointer arithmetic

00:17:46,320 --> 00:17:50,640
involving

00:17:47,440 --> 00:17:53,440
elements inside the array but we can't

00:17:50,640 --> 00:17:53,919
actually read from or write to that

00:17:53,440 --> 00:17:56,160
element

00:17:53,919 --> 00:17:57,120
if we wanted to do one of those things

00:17:56,160 --> 00:18:00,160
the result would be

00:17:57,120 --> 00:18:03,280
undefined behavior

00:18:00,160 --> 00:18:06,240
okay i can also in general

00:18:03,280 --> 00:18:09,120
adding integers two pointers yields

00:18:06,240 --> 00:18:09,120
another pointer

00:18:09,840 --> 00:18:16,160
so here i have a pointer p

00:18:13,679 --> 00:18:17,039
i can get a different pointer q that

00:18:16,160 --> 00:18:20,320
points

00:18:17,039 --> 00:18:21,120
k elements later than p in whatever

00:18:20,320 --> 00:18:25,039
array p

00:18:21,120 --> 00:18:28,240
points to and assign that to q by l

00:18:25,039 --> 00:18:32,799
by writing p plus k

00:18:28,240 --> 00:18:35,200
so here i say it results in an integer

00:18:32,799 --> 00:18:37,120
uh i'll be more specific about what kind

00:18:35,200 --> 00:18:39,360
of integer i'm talking about right now

00:18:37,120 --> 00:18:40,960
i'm just using integer as a generic term

00:18:39,360 --> 00:18:44,559
don't think specifically int

00:18:40,960 --> 00:18:44,559
or long or something else

00:18:44,799 --> 00:18:50,559
similarly i can subtract two pointers

00:18:47,919 --> 00:18:54,000
that point to the same array

00:18:50,559 --> 00:18:57,360
so here i have p and q both pointing to

00:18:54,000 --> 00:19:00,640
the ith and j elements of

00:18:57,360 --> 00:19:04,160
array x respectively

00:19:00,640 --> 00:19:07,200
if i subtract p q from or p from

00:19:04,160 --> 00:19:09,840
q here

00:19:07,200 --> 00:19:10,559
i get the same result as if i subtracted

00:19:09,840 --> 00:19:13,200
i from

00:19:10,559 --> 00:19:14,559
j it's the difference between the two

00:19:13,200 --> 00:19:17,919
indices

00:19:14,559 --> 00:19:20,799
so here if i calculate m

00:19:17,919 --> 00:19:21,440
using the pointers one way i calculate n

00:19:20,799 --> 00:19:23,919
using

00:19:21,440 --> 00:19:25,919
the indices the other way these two will

00:19:23,919 --> 00:19:29,679
always be equal

00:19:25,919 --> 00:19:31,520
same result now

00:19:29,679 --> 00:19:33,679
subtracting two pointers is actually

00:19:31,520 --> 00:19:35,600
only valid if they both point to

00:19:33,679 --> 00:19:37,840
elements of the same array

00:19:35,600 --> 00:19:40,320
or to that phantom element one beyond

00:19:37,840 --> 00:19:42,080
the end of the array

00:19:40,320 --> 00:19:43,679
if you're subtracting two pointers that

00:19:42,080 --> 00:19:47,280
point to unrelated

00:19:43,679 --> 00:19:49,679
objects the result is undefined behavior

00:19:47,280 --> 00:19:51,520
now you rarely run into this because

00:19:49,679 --> 00:19:53,360
almost always you're doing

00:19:51,520 --> 00:19:54,720
pointer subtraction because you're

00:19:53,360 --> 00:19:57,679
trying to adjust

00:19:54,720 --> 00:19:58,640
the position of a pointer in the array

00:19:57,679 --> 00:20:01,120
but

00:19:58,640 --> 00:20:01,919
this is something to be aware of that it

00:20:01,120 --> 00:20:04,720
really is

00:20:01,919 --> 00:20:07,840
only pointers within the same array that

00:20:04,720 --> 00:20:07,840
can be subtracted

00:20:08,240 --> 00:20:11,280
interestingly we can also treat the

00:20:10,159 --> 00:20:14,240
array x

00:20:11,280 --> 00:20:15,760
as if it were a pointer itself so i

00:20:14,240 --> 00:20:18,799
don't actually have to refer

00:20:15,760 --> 00:20:22,000
to address of x sub zero

00:20:18,799 --> 00:20:26,000
i can use x directly and it behaves

00:20:22,000 --> 00:20:28,159
as if i had written address of x sub 0

00:20:26,000 --> 00:20:29,039
for the purposes of initializing a

00:20:28,159 --> 00:20:32,400
pointer like

00:20:29,039 --> 00:20:35,600
p i here and not only can i do that

00:20:32,400 --> 00:20:36,799
i can treat object x as if it were a

00:20:35,600 --> 00:20:40,480
pointer itself and

00:20:36,799 --> 00:20:42,720
assigned to star x and it has the same

00:20:40,480 --> 00:20:43,520
result as assigning to the zeroth

00:20:42,720 --> 00:20:46,960
element

00:20:43,520 --> 00:20:49,760
of x and so

00:20:46,960 --> 00:20:51,440
and in fact subscripting the square

00:20:49,760 --> 00:20:54,559
bracket operator

00:20:51,440 --> 00:20:56,000
that's actually described as a pointer

00:20:54,559 --> 00:20:58,559
operation in the standard

00:20:56,000 --> 00:20:59,280
not an array operation so while we

00:20:58,559 --> 00:21:02,640
typically

00:20:59,280 --> 00:21:03,760
think of this as being something that we

00:21:02,640 --> 00:21:06,159
do with arrays

00:21:03,760 --> 00:21:08,320
the subscript operator it's really just

00:21:06,159 --> 00:21:11,360
a shorthand for this

00:21:08,320 --> 00:21:14,240
these two pieces of code are equivalent

00:21:11,360 --> 00:21:15,360
now you'll generally be understood

00:21:14,240 --> 00:21:17,440
better i think

00:21:15,360 --> 00:21:20,640
using the subscript operator is a

00:21:17,440 --> 00:21:22,960
clearer way of expressing yourself

00:21:20,640 --> 00:21:23,840
but both of these will generate

00:21:22,960 --> 00:21:26,960
identical

00:21:23,840 --> 00:21:30,640
code whether i write it as x sub i or

00:21:26,960 --> 00:21:33,600
star x plus i

00:21:30,640 --> 00:21:36,880
okay i recommend this one but you won't

00:21:33,600 --> 00:21:40,000
actually see a difference in the code

00:21:36,880 --> 00:21:42,840
so this raises the question of is an

00:21:40,000 --> 00:21:45,679
array really just a pointer

00:21:42,840 --> 00:21:47,600
and it it's not

00:21:45,679 --> 00:21:49,120
but we often get fooled into thinking it

00:21:47,600 --> 00:21:52,320
is because

00:21:49,120 --> 00:21:54,960
it behaves so much like a pointer so

00:21:52,320 --> 00:21:58,080
here's the distinction

00:21:54,960 --> 00:22:00,880
this object x defined with the square

00:21:58,080 --> 00:22:02,400
brackets that's really an array it's not

00:22:00,880 --> 00:22:05,679
a pointer type

00:22:02,400 --> 00:22:08,000
not the same way that this p here is a

00:22:05,679 --> 00:22:08,559
pointer type when it's declared with the

00:22:08,000 --> 00:22:11,679
star

00:22:08,559 --> 00:22:14,159
operator so

00:22:11,679 --> 00:22:14,880
then why does this actually work why

00:22:14,159 --> 00:22:18,159
does

00:22:14,880 --> 00:22:21,200
why can i assign it directly from x to

00:22:18,159 --> 00:22:27,840
p and that has the result of making p

00:22:21,200 --> 00:22:27,840
point to x x's zero element

00:22:29,360 --> 00:22:35,919
so um

00:22:33,039 --> 00:22:36,480
a the reason that this compiles is

00:22:35,919 --> 00:22:39,600
because

00:22:36,480 --> 00:22:42,640
an array we say an array can decay

00:22:39,600 --> 00:22:43,200
into a pointer decay is a colorful term

00:22:42,640 --> 00:22:46,080
for what's

00:22:43,200 --> 00:22:47,360
technically referred to as an array to

00:22:46,080 --> 00:22:51,200
pointer conversion

00:22:47,360 --> 00:22:53,360
in the standard the idea is

00:22:51,200 --> 00:22:55,200
when that when the compiler sees this

00:22:53,360 --> 00:22:59,440
expression

00:22:55,200 --> 00:23:02,400
it knows that x is the kind of thing

00:22:59,440 --> 00:23:03,919
x is an array type arrays are the kind

00:23:02,400 --> 00:23:07,440
of things that can decay

00:23:03,919 --> 00:23:10,880
into pointers so it will treat

00:23:07,440 --> 00:23:12,799
x as a pointer value for the purpose of

00:23:10,880 --> 00:23:14,960
doing this assignment

00:23:12,799 --> 00:23:16,880
now the decay doesn't last very long

00:23:14,960 --> 00:23:20,080
it's only momentary

00:23:16,880 --> 00:23:21,760
just long enough to do the assignment x

00:23:20,080 --> 00:23:24,880
really remains an array

00:23:21,760 --> 00:23:28,240
and it's the same as what's going on in

00:23:24,880 --> 00:23:30,880
this situation here so

00:23:28,240 --> 00:23:31,679
if i have a double and an int two

00:23:30,880 --> 00:23:34,480
objects

00:23:31,679 --> 00:23:34,960
i want to type double one of type end

00:23:34,480 --> 00:23:38,240
and i

00:23:34,960 --> 00:23:39,360
try to add the integer value to the

00:23:38,240 --> 00:23:42,640
double

00:23:39,360 --> 00:23:43,120
this will work it will compile what we

00:23:42,640 --> 00:23:46,320
often

00:23:43,120 --> 00:23:50,159
say is that this expression converts

00:23:46,320 --> 00:23:51,520
i to a double but that's a little bit of

00:23:50,159 --> 00:23:54,640
an oversimplification

00:23:51,520 --> 00:23:56,400
because we know that afterwards i is

00:23:54,640 --> 00:23:58,080
still an integer

00:23:56,400 --> 00:23:59,919
what's really happening is something

00:23:58,080 --> 00:24:02,640
that looks like this where

00:23:59,919 --> 00:24:04,159
the compiler creates a temporary object

00:24:02,640 --> 00:24:07,600
of type double

00:24:04,159 --> 00:24:12,320
t here stands for temp by converting

00:24:07,600 --> 00:24:14,960
up the value of i into a double value

00:24:12,320 --> 00:24:16,000
then it adds the value of that temporary

00:24:14,960 --> 00:24:18,640
to d

00:24:16,000 --> 00:24:19,279
and then it throws away the temporary so

00:24:18,640 --> 00:24:22,400
i

00:24:19,279 --> 00:24:25,440
is always an integer it's just but

00:24:22,400 --> 00:24:28,320
we extract the value of i into

00:24:25,440 --> 00:24:28,640
an object of type double temporarily to

00:24:28,320 --> 00:24:33,840
do

00:24:28,640 --> 00:24:33,840
this assignment

00:24:35,600 --> 00:24:39,840
so how can what is how can we show that

00:24:38,559 --> 00:24:42,720
an array really isn't

00:24:39,840 --> 00:24:43,279
a pointer well for one thing when we

00:24:42,720 --> 00:24:45,919
assign

00:24:43,279 --> 00:24:47,120
we can assign an array to a pointer like

00:24:45,919 --> 00:24:50,559
this

00:24:47,120 --> 00:24:51,039
if i write p equals x that works just

00:24:50,559 --> 00:24:54,799
fine

00:24:51,039 --> 00:24:58,880
x will decay into an into a pointer

00:24:54,799 --> 00:25:00,320
and be a suitable for assigning to p

00:24:58,880 --> 00:25:02,640
but i can't write this the other way

00:25:00,320 --> 00:25:05,919
around i can't assign

00:25:02,640 --> 00:25:07,440
to an array and i can't assign anything

00:25:05,919 --> 00:25:09,600
to an array it doesn't matter whether

00:25:07,440 --> 00:25:12,799
it's a pointer or something else

00:25:09,600 --> 00:25:15,520
any putting in an entire array on the

00:25:12,799 --> 00:25:18,480
left hand side of an assignment operator

00:25:15,520 --> 00:25:18,480
just doesn't work

00:25:18,960 --> 00:25:22,159
the size of an alignment of operators

00:25:21,679 --> 00:25:24,720
also

00:25:22,159 --> 00:25:25,919
produce different results when they're

00:25:24,720 --> 00:25:29,039
applied to

00:25:25,919 --> 00:25:29,919
pointers versus arrays so the size of an

00:25:29,039 --> 00:25:33,520
array

00:25:29,919 --> 00:25:36,799
is the size of all the combined

00:25:33,520 --> 00:25:39,840
total of all of the objects in the array

00:25:36,799 --> 00:25:41,440
so size of x here where x is an array of

00:25:39,840 --> 00:25:45,200
32 characters

00:25:41,440 --> 00:25:48,000
is 32 times the size of a character

00:25:45,200 --> 00:25:48,960
which is 32 because because size of char

00:25:48,000 --> 00:25:52,480
is always defined to be

00:25:48,960 --> 00:25:53,760
one meanwhile the size of a pointer to a

00:25:52,480 --> 00:25:55,840
character

00:25:53,760 --> 00:25:56,880
is something else depending on what

00:25:55,840 --> 00:25:59,520
platform you're on

00:25:56,880 --> 00:26:00,159
it could be two bytes four bytes eight

00:25:59,520 --> 00:26:02,559
bytes

00:26:00,159 --> 00:26:04,080
four or eight or more likely on on most

00:26:02,559 --> 00:26:08,080
modern machines

00:26:04,080 --> 00:26:10,720
but uh it's going to be

00:26:08,080 --> 00:26:12,240
some it's not going to be 32 by all

00:26:10,720 --> 00:26:15,600
likelihood

00:26:12,240 --> 00:26:16,799
similarly uh a line of this gives you

00:26:15,600 --> 00:26:19,200
the alignment of us

00:26:16,799 --> 00:26:19,919
that a single character is required to

00:26:19,200 --> 00:26:23,120
have

00:26:19,919 --> 00:26:26,480
which is almost certainly one

00:26:23,120 --> 00:26:28,159
but the alignment of a pointer could be

00:26:26,480 --> 00:26:30,000
two or four or eight it's probably the

00:26:28,159 --> 00:26:33,120
same as the size of the pointer

00:26:30,000 --> 00:26:34,640
up here um so

00:26:33,120 --> 00:26:36,159
this is another way that you can tell

00:26:34,640 --> 00:26:40,320
that arrays

00:26:36,159 --> 00:26:40,320
aren't really pointer objects

00:26:41,360 --> 00:26:49,279
all right except when they are

00:26:45,679 --> 00:26:52,640
array parameters really are pointers

00:26:49,279 --> 00:26:55,679
that is to say if i write these function

00:26:52,640 --> 00:26:58,880
declarations all

00:26:55,679 --> 00:27:00,559
x is really a pointer in all three of

00:26:58,880 --> 00:27:03,840
these cases

00:27:00,559 --> 00:27:06,880
even though it appears to be an array

00:27:03,840 --> 00:27:09,679
in the like in the later two

00:27:06,880 --> 00:27:10,240
uh if you look at the size of x doesn't

00:27:09,679 --> 00:27:12,960
matter

00:27:10,240 --> 00:27:15,600
how i write this function the size of x

00:27:12,960 --> 00:27:19,039
is always the size of a pointer

00:27:15,600 --> 00:27:21,760
not the size of an array all other

00:27:19,039 --> 00:27:25,919
arrays arrays that aren't parameters

00:27:21,760 --> 00:27:29,760
are really arrays but but

00:27:25,919 --> 00:27:31,600
in c they tried to make a simplification

00:27:29,760 --> 00:27:34,320
by they tried to make something more

00:27:31,600 --> 00:27:37,679
intuitive by allowing you to

00:27:34,320 --> 00:27:40,960
pass arrays as parameters and

00:27:37,679 --> 00:27:40,960
it kind of backfired

00:27:41,760 --> 00:27:48,720
so uh now let's talk about size t

00:27:44,799 --> 00:27:50,399
and putter diff t so

00:27:48,720 --> 00:27:51,919
there are a number of functions in the

00:27:50,399 --> 00:27:54,720
standard library

00:27:51,919 --> 00:27:56,080
that take parameters that represent the

00:27:54,720 --> 00:27:59,840
size of an object

00:27:56,080 --> 00:28:01,919
in bytes uh so malloc

00:27:59,840 --> 00:28:03,360
when i call malloc i pass it the number

00:28:01,919 --> 00:28:04,159
of bytes of memory that i want to

00:28:03,360 --> 00:28:07,039
allocate

00:28:04,159 --> 00:28:07,360
and it returns back a pointer to an out

00:28:07,039 --> 00:28:10,720
of

00:28:07,360 --> 00:28:14,559
chunk of memory of that size uh

00:28:10,720 --> 00:28:16,000
in mem copy i tell it how many bytes to

00:28:14,559 --> 00:28:18,799
copy from the source

00:28:16,000 --> 00:28:19,520
to the destination uh with this third

00:28:18,799 --> 00:28:23,840
parameter

00:28:19,520 --> 00:28:26,320
n now and i'd like to be able to call

00:28:23,840 --> 00:28:26,960
mallow or mem copy and give it the size

00:28:26,320 --> 00:28:30,000
of

00:28:26,960 --> 00:28:33,279
any object i might want so

00:28:30,000 --> 00:28:36,240
whatever type n has but however

00:28:33,279 --> 00:28:36,799
mem copy and malloc are declared the

00:28:36,240 --> 00:28:39,039
type of

00:28:36,799 --> 00:28:39,840
n should be something that can represent

00:28:39,039 --> 00:28:44,159
the size

00:28:39,840 --> 00:28:47,039
of any object i might create

00:28:44,159 --> 00:28:47,440
that type exists and it's called size t

00:28:47,039 --> 00:28:49,520
uh

00:28:47,440 --> 00:28:51,279
it's defined to be the result of the

00:28:49,520 --> 00:28:54,799
sizeof operator

00:28:51,279 --> 00:28:57,120
so it's literally uh size t

00:28:54,799 --> 00:28:58,000
is defined to be something that can hold

00:28:57,120 --> 00:29:01,120
any possible

00:28:58,000 --> 00:29:02,880
result of the size of now

00:29:01,120 --> 00:29:04,799
that might be different sizes on

00:29:02,880 --> 00:29:05,919
different platforms because different

00:29:04,799 --> 00:29:08,880
platforms

00:29:05,919 --> 00:29:10,840
may have different amounts of memory and

00:29:08,880 --> 00:29:13,679
therefore have different

00:29:10,840 --> 00:29:16,480
spaces uh

00:29:13,679 --> 00:29:18,480
yeah i will so to pass an array to a

00:29:16,480 --> 00:29:22,000
method you need to compute its size

00:29:18,480 --> 00:29:26,320
too uh is a question that came up yes

00:29:22,000 --> 00:29:29,600
i will uh

00:29:26,320 --> 00:29:33,360
yes typically what you do to pass

00:29:29,600 --> 00:29:37,120
if you really want to pass an array to

00:29:33,360 --> 00:29:38,240
a function you pass you pass it as a

00:29:37,120 --> 00:29:41,919
pointer

00:29:38,240 --> 00:29:45,039
plus a size often a size t

00:29:41,919 --> 00:29:45,840
but we'll talk about that we'll get into

00:29:45,039 --> 00:29:49,200
that

00:29:45,840 --> 00:29:50,559
in just a bit but yes you you

00:29:49,200 --> 00:29:53,120
almost always when you're when you're

00:29:50,559 --> 00:29:57,039
intending to pass an array to a

00:29:53,120 --> 00:30:00,880
function you need two parameters

00:29:57,039 --> 00:30:02,640
so uh size t might be different sizes on

00:30:00,880 --> 00:30:04,000
different platforms because different

00:30:02,640 --> 00:30:07,120
platforms have

00:30:04,000 --> 00:30:11,279
different sizes of memory and therefore

00:30:07,120 --> 00:30:13,760
different maximum sizes for objects

00:30:11,279 --> 00:30:15,679
but it's always an unsigned type because

00:30:13,760 --> 00:30:17,520
sizes are never negative

00:30:15,679 --> 00:30:20,159
no such thing as an object that takes up

00:30:17,520 --> 00:30:23,440
minus three bytes

00:30:20,159 --> 00:30:23,840
it could be long it might be a long long

00:30:23,440 --> 00:30:26,559
long

00:30:23,840 --> 00:30:27,440
something like that but the idea is it's

00:30:26,559 --> 00:30:30,320
supposed to be

00:30:27,440 --> 00:30:32,240
no larger than it has to be to represent

00:30:30,320 --> 00:30:32,960
the size of the largest object that the

00:30:32,240 --> 00:30:37,840
machine

00:30:32,960 --> 00:30:37,840
can that can be exist on that machine

00:30:39,919 --> 00:30:43,840
so malok and mem copy if you look at

00:30:42,640 --> 00:30:48,080
their definitions

00:30:43,840 --> 00:30:50,080
that parameter has type size t

00:30:48,080 --> 00:30:52,159
now but you'll notice if you look at

00:30:50,080 --> 00:30:55,200
other places in the standard library

00:30:52,159 --> 00:30:58,080
they also use size t to represent

00:30:55,200 --> 00:30:59,840
array sizes as well size t is the type

00:30:58,080 --> 00:31:03,120
of value that's returned by

00:30:59,840 --> 00:31:05,360
sterling which is really the length of

00:31:03,120 --> 00:31:08,799
an array

00:31:05,360 --> 00:31:11,360
uh so the size of an array

00:31:08,799 --> 00:31:12,960
is measured in bytes if i take size of

00:31:11,360 --> 00:31:15,760
array

00:31:12,960 --> 00:31:17,279
that's the size of the array in bytes

00:31:15,760 --> 00:31:19,200
which is not necessarily

00:31:17,279 --> 00:31:20,799
the same thing as the number of elements

00:31:19,200 --> 00:31:21,919
in the array if i have an array of

00:31:20,799 --> 00:31:24,559
integers

00:31:21,919 --> 00:31:25,440
it's going to occupy a lot more bytes

00:31:24,559 --> 00:31:28,799
than it has

00:31:25,440 --> 00:31:32,000
elements but

00:31:28,799 --> 00:31:34,480
the idea here is that the

00:31:32,000 --> 00:31:35,519
largest possible array is going to be

00:31:34,480 --> 00:31:39,039
limited by

00:31:35,519 --> 00:31:41,679
the maximum value of size t so

00:31:39,039 --> 00:31:44,399
if we want sterling to be able to return

00:31:41,679 --> 00:31:47,600
a value that's always going to be

00:31:44,399 --> 00:31:51,600
within the right range uh that

00:31:47,600 --> 00:31:54,480
that is on the same scale as the maximum

00:31:51,600 --> 00:31:56,720
size in bytes of an array size t is a

00:31:54,480 --> 00:31:59,360
good way of representing that

00:31:56,720 --> 00:32:00,640
so technically it represents a size in

00:31:59,360 --> 00:32:04,960
bytes but it can also

00:32:00,640 --> 00:32:08,399
be used for other kinds of sizes

00:32:04,960 --> 00:32:11,679
now uh what that means

00:32:08,399 --> 00:32:14,000
so size t is always an unsigned value

00:32:11,679 --> 00:32:15,519
so size t is off what that means is that

00:32:14,000 --> 00:32:18,640
size t is often used

00:32:15,519 --> 00:32:20,000
as the type of a value to index into an

00:32:18,640 --> 00:32:22,000
array

00:32:20,000 --> 00:32:23,440
as we saw earlier we can access array

00:32:22,000 --> 00:32:27,919
elements using either

00:32:23,440 --> 00:32:29,200
indices or pointers as i'm showing here

00:32:27,919 --> 00:32:30,960
the thing is though

00:32:29,200 --> 00:32:32,880
pointer arithmetic doesn't have to

00:32:30,960 --> 00:32:35,919
produce a positive value when i

00:32:32,880 --> 00:32:37,519
subtract two pointers that both point to

00:32:35,919 --> 00:32:40,720
the same array

00:32:37,519 --> 00:32:41,679
if i subtract p from q the result is the

00:32:40,720 --> 00:32:43,600
difference between

00:32:41,679 --> 00:32:44,799
the index of this five and the index of

00:32:43,600 --> 00:32:48,159
this two so

00:32:44,799 --> 00:32:51,360
four and one the result is three

00:32:48,159 --> 00:32:55,120
but i can also subtract q from p

00:32:51,360 --> 00:32:58,399
and get the result minus three

00:32:55,120 --> 00:33:01,600
pointer subtraction yields a value of a

00:32:58,399 --> 00:33:02,720
similar but not quite the same type uh

00:33:01,600 --> 00:33:05,519
as size t

00:33:02,720 --> 00:33:08,000
called putter diff t difference between

00:33:05,519 --> 00:33:10,000
two pointers

00:33:08,000 --> 00:33:11,440
so putter diff t is designed to be

00:33:10,000 --> 00:33:13,840
something that can

00:33:11,440 --> 00:33:16,159
represent any result that you could get

00:33:13,840 --> 00:33:17,039
by subtracting two pointers that point

00:33:16,159 --> 00:33:20,559
to the same

00:33:17,039 --> 00:33:21,120
array uh another way of saying that

00:33:20,559 --> 00:33:23,919
would be

00:33:21,120 --> 00:33:25,360
the maximum distance between any two

00:33:23,919 --> 00:33:27,519
elements in an array

00:33:25,360 --> 00:33:29,679
in either direction that should be

00:33:27,519 --> 00:33:33,440
something that can be represented as

00:33:29,679 --> 00:33:34,320
put or diff t it's always a signed value

00:33:33,440 --> 00:33:36,720
because

00:33:34,320 --> 00:33:37,440
the direct the distance can be either

00:33:36,720 --> 00:33:41,200
positive or

00:33:37,440 --> 00:33:43,600
negative again like size t

00:33:41,200 --> 00:33:45,600
the the intent here is that it'd be no

00:33:43,600 --> 00:33:48,159
larger than necessary

00:33:45,600 --> 00:33:50,960
and it's almost always the equivalent of

00:33:48,159 --> 00:33:52,720
the signed version of size t

00:33:50,960 --> 00:33:54,240
in fact it's not entirely clear from the

00:33:52,720 --> 00:33:55,840
standard that it actually can be

00:33:54,240 --> 00:33:58,320
anything else although

00:33:55,840 --> 00:34:00,960
the standard doesn't come right out and

00:33:58,320 --> 00:34:00,960
say that

00:34:01,120 --> 00:34:07,679
so uh this has led to an

00:34:04,559 --> 00:34:09,760
odd result over time that

00:34:07,679 --> 00:34:11,440
because putter diff t is signed in size

00:34:09,760 --> 00:34:14,320
t is unsigned

00:34:11,440 --> 00:34:16,480
but they're both clearly related

00:34:14,320 --> 00:34:18,720
concepts

00:34:16,480 --> 00:34:20,000
it's not uncommon to want to mix them

00:34:18,720 --> 00:34:23,200
and you need to be careful about

00:34:20,000 --> 00:34:23,919
doing that because when you use putter

00:34:23,200 --> 00:34:26,960
diff t

00:34:23,919 --> 00:34:27,440
and size t together it's quite possible

00:34:26,960 --> 00:34:29,359
to get

00:34:27,440 --> 00:34:30,879
accidental signed to unsigned

00:34:29,359 --> 00:34:33,839
comparisons

00:34:30,879 --> 00:34:36,159
and this is a problem because if you try

00:34:33,839 --> 00:34:39,119
to compare a signed value to an

00:34:36,159 --> 00:34:40,159
unsigned value of the same size in c

00:34:39,119 --> 00:34:41,919
plus

00:34:40,159 --> 00:34:43,520
the compiler does another one of those

00:34:41,919 --> 00:34:46,320
temporary conversions

00:34:43,520 --> 00:34:48,639
it turns the signed value into an

00:34:46,320 --> 00:34:51,280
unsigned value

00:34:48,639 --> 00:34:52,480
and then compares the two unsigned

00:34:51,280 --> 00:34:54,399
values

00:34:52,480 --> 00:34:57,680
which means that if the signed value

00:34:54,399 --> 00:35:01,119
actually had a negative value in it

00:34:57,680 --> 00:35:05,280
uh the result is that you

00:35:01,119 --> 00:35:08,079
it effectively underflows the

00:35:05,280 --> 00:35:09,040
the negative or the unsigned value and

00:35:08,079 --> 00:35:12,079
you get

00:35:09,040 --> 00:35:15,680
a very large positive integer which is

00:35:12,079 --> 00:35:18,800
probably not what you were expecting

00:35:15,680 --> 00:35:20,880
so here here's an example of a situation

00:35:18,800 --> 00:35:23,920
where this might come up i have

00:35:20,880 --> 00:35:26,960
an array of characters i'm

00:35:23,920 --> 00:35:30,640
i'm reading a field

00:35:26,960 --> 00:35:32,960
from imagine that i'm parsing some a

00:35:30,640 --> 00:35:33,839
a text document that contains fields

00:35:32,960 --> 00:35:37,920
separated by

00:35:33,839 --> 00:35:40,320
commas here so i find the

00:35:37,920 --> 00:35:43,119
the for the next comma which indicates

00:35:40,320 --> 00:35:46,720
the end of the field

00:35:43,119 --> 00:35:50,960
i subtract field from field end

00:35:46,720 --> 00:35:54,640
to get the length of that one field

00:35:50,960 --> 00:35:57,520
uh the number of elements in the array

00:35:54,640 --> 00:35:59,200
if i compare that length to the size of

00:35:57,520 --> 00:36:01,280
the buffer

00:35:59,200 --> 00:36:03,200
this winds up being an unassigned to

00:36:01,280 --> 00:36:06,560
unsigned comparison because

00:36:03,200 --> 00:36:08,240
length is assigned type 15 sizeof

00:36:06,560 --> 00:36:12,000
returns a size t

00:36:08,240 --> 00:36:15,040
which is a an unsigned

00:36:12,000 --> 00:36:15,359
type it's possible that i could get this

00:36:15,040 --> 00:36:18,640
kind

00:36:15,359 --> 00:36:22,160
that kind of underflow

00:36:18,640 --> 00:36:27,839
there and wind up with code that does

00:36:22,160 --> 00:36:29,680
something surprising

00:36:27,839 --> 00:36:32,240
and one way that this is particularly

00:36:29,680 --> 00:36:36,240
insidious is that sometimes

00:36:32,240 --> 00:36:37,040
if you use auto with expressions that

00:36:36,240 --> 00:36:39,760
could yield

00:36:37,040 --> 00:36:41,040
size t's or putter diff keys you want to

00:36:39,760 --> 00:36:43,599
be careful to keep an eye

00:36:41,040 --> 00:36:44,640
on which ones are signed and which ones

00:36:43,599 --> 00:36:48,000
are unsigned

00:36:44,640 --> 00:36:48,880
because it's not where even if you

00:36:48,000 --> 00:36:53,119
remember

00:36:48,880 --> 00:36:55,359
that putter def t here is always sign

00:36:53,119 --> 00:36:56,960
it's not immediately obvious in this

00:36:55,359 --> 00:37:00,320
case that

00:36:56,960 --> 00:37:00,960
the type deduced for a length is signed

00:37:00,320 --> 00:37:04,880
as well

00:37:00,960 --> 00:37:08,880
even though it it is also a putter div t

00:37:04,880 --> 00:37:10,720
uh so that's something to keep an eye on

00:37:08,880 --> 00:37:12,560
now a lot of compilers will warn you

00:37:10,720 --> 00:37:15,119
about these types of conversions

00:37:12,560 --> 00:37:16,240
but they're just warnings they're still

00:37:15,119 --> 00:37:18,079
the kind of thing that can go

00:37:16,240 --> 00:37:20,240
unheeded and you want to watch out for

00:37:18,079 --> 00:37:20,240
that

00:37:20,720 --> 00:37:25,599
okay the uh the cbos plus community

00:37:24,400 --> 00:37:28,160
seems to be moving

00:37:25,599 --> 00:37:30,000
in the direction of representing sizes

00:37:28,160 --> 00:37:33,280
with signed values

00:37:30,000 --> 00:37:34,480
as a way of protecting against this kind

00:37:33,280 --> 00:37:38,000
of mistake

00:37:34,480 --> 00:37:38,480
so in c plus 20 uh you will see that

00:37:38,000 --> 00:37:41,520
there's

00:37:38,480 --> 00:37:43,599
a an s size function that returns the

00:37:41,520 --> 00:37:46,400
size of the container as a signed

00:37:43,599 --> 00:37:48,800
value it can open instead of as an

00:37:46,400 --> 00:37:51,040
unsigned value

00:37:48,800 --> 00:37:52,079
and if you look at c plus plus 20 ranges

00:37:51,040 --> 00:37:55,119
you'll see that

00:37:52,079 --> 00:37:58,079
they have methods for getting both

00:37:55,119 --> 00:37:59,119
the size as both assigned and unsigned

00:37:58,079 --> 00:38:02,400
value

00:37:59,119 --> 00:38:04,560
depending on which one you want

00:38:02,400 --> 00:38:06,720
so that's we're kind of moving in that

00:38:04,560 --> 00:38:09,200
direction to avoid this

00:38:06,720 --> 00:38:11,520
but it's still something that you need

00:38:09,200 --> 00:38:14,880
to watch out for

00:38:11,520 --> 00:38:17,359
all right so uh moving on to

00:38:14,880 --> 00:38:20,480
type conversions and the meaning of

00:38:17,359 --> 00:38:24,480
const in pointers

00:38:20,480 --> 00:38:27,680
so if i have a basic pointer declaration

00:38:24,480 --> 00:38:30,839
p is a pointer to a t i can add

00:38:27,680 --> 00:38:33,920
const to it in any of these places

00:38:30,839 --> 00:38:37,200
and that will produce

00:38:33,920 --> 00:38:39,200
some kind of pointer to constant pointer

00:38:37,200 --> 00:38:40,640
to constant something

00:38:39,200 --> 00:38:42,960
here's what each of them means now i'm

00:38:40,640 --> 00:38:45,760
just going to go through this quickly

00:38:42,960 --> 00:38:46,560
uh there's a for a much deeper

00:38:45,760 --> 00:38:50,000
discussion

00:38:46,560 --> 00:38:50,880
of how const affects pointers and

00:38:50,000 --> 00:38:53,599
references and

00:38:50,880 --> 00:38:54,480
other types like that uh you can see

00:38:53,599 --> 00:38:58,400
last year's

00:38:54,480 --> 00:38:59,680
back to basics um const as a promised

00:38:58,400 --> 00:39:01,119
talk

00:38:59,680 --> 00:39:03,599
and that covers this in a lot more

00:39:01,119 --> 00:39:03,599
detail

00:39:03,920 --> 00:39:11,680
if i if the const is over here

00:39:07,680 --> 00:39:14,400
on the left hand side of the star

00:39:11,680 --> 00:39:16,720
it repre it means that p is a pointer to

00:39:14,400 --> 00:39:19,200
a constant t

00:39:16,720 --> 00:39:21,280
he can i can change which object p

00:39:19,200 --> 00:39:24,560
points to

00:39:21,280 --> 00:39:28,320
but i can't change but i can't

00:39:24,560 --> 00:39:30,960
write through p and change the object

00:39:28,320 --> 00:39:33,359
that p points to i can make it point to

00:39:30,960 --> 00:39:36,400
something else

00:39:33,359 --> 00:39:39,920
but i can't change the use it to change

00:39:36,400 --> 00:39:39,920
the value that it points to

00:39:40,640 --> 00:39:44,240
when the const is on the right side of

00:39:43,040 --> 00:39:47,440
the star

00:39:44,240 --> 00:39:50,800
here this means p is a constant

00:39:47,440 --> 00:39:54,079
pointer to a t now it's the

00:39:50,800 --> 00:39:57,520
it's the object that is pointed to

00:39:54,079 --> 00:40:00,800
that is that remains constant we can't

00:39:57,520 --> 00:40:02,160
p will always point to the same object

00:40:00,800 --> 00:40:05,760
of type t

00:40:02,160 --> 00:40:08,800
we if we try and assign to it

00:40:05,760 --> 00:40:10,880
uh take the address of some other object

00:40:08,800 --> 00:40:12,079
and make that the new value that p

00:40:10,880 --> 00:40:13,599
points to

00:40:12,079 --> 00:40:15,760
that won't work we'll get a compile

00:40:13,599 --> 00:40:18,240
error but we can run

00:40:15,760 --> 00:40:20,000
through the pointer and modify the thing

00:40:18,240 --> 00:40:24,400
that it points to

00:40:20,000 --> 00:40:26,640
star p is modifiable p is not

00:40:24,400 --> 00:40:27,920
and unsurprisingly if you have const in

00:40:26,640 --> 00:40:30,560
both places

00:40:27,920 --> 00:40:31,599
you have a const pointer to a constant t

00:40:30,560 --> 00:40:34,000
which means

00:40:31,599 --> 00:40:35,599
you can't change the thing what which

00:40:34,000 --> 00:40:38,400
object it points to

00:40:35,599 --> 00:40:39,359
and you can't use it to change star p

00:40:38,400 --> 00:40:41,599
either you can't

00:40:39,359 --> 00:40:44,160
write through the pointer you can only

00:40:41,599 --> 00:40:47,599
read from it

00:40:44,160 --> 00:40:50,240
so i've mentioned const here

00:40:47,599 --> 00:40:51,200
uh anywhere that you can use const you

00:40:50,240 --> 00:40:54,560
can actually

00:40:51,200 --> 00:40:57,599
uh use volatile as well in general

00:40:54,560 --> 00:40:59,200
uh in general so you can use const or

00:40:57,599 --> 00:41:02,480
volatile or both

00:40:59,200 --> 00:41:04,800
uh we collectively refer to them as cv

00:41:02,480 --> 00:41:06,319
qualifiers and so i'm going to be

00:41:04,800 --> 00:41:08,319
talking about const but the

00:41:06,319 --> 00:41:10,560
same rules regarding type conversions

00:41:08,319 --> 00:41:12,319
also apply to volatile

00:41:10,560 --> 00:41:13,760
uh otherwise i'm not going to talk very

00:41:12,319 --> 00:41:15,680
much about volatile

00:41:13,760 --> 00:41:18,079
proper use of that is really outside the

00:41:15,680 --> 00:41:21,040
scope of this session

00:41:18,079 --> 00:41:22,960
interestingly enough const expert is not

00:41:21,040 --> 00:41:26,880
a cv qualifier

00:41:22,960 --> 00:41:29,599
uh const expert is used in diff

00:41:26,880 --> 00:41:30,160
is not always used in places that you

00:41:29,599 --> 00:41:31,680
could use

00:41:30,160 --> 00:41:34,480
cons there are places where you can use

00:41:31,680 --> 00:41:36,079
const expert that you can't use const

00:41:34,480 --> 00:41:39,839
there are places that you can use const

00:41:36,079 --> 00:41:39,839
where you can't use constexpr

00:41:40,079 --> 00:41:44,880
uh so we refer qualification conversions

00:41:44,079 --> 00:41:48,560
are a kind of

00:41:44,880 --> 00:41:51,760
safe pointer conversion that adds a cv

00:41:48,560 --> 00:41:55,920
qualifier to a pointer type so

00:41:51,760 --> 00:41:58,640
if i have a pointer to a t

00:41:55,920 --> 00:42:00,040
which which is qualified by cv

00:41:58,640 --> 00:42:04,400
qualifiers

00:42:00,040 --> 00:42:07,440
cb1 i can turn that into a pointer to it

00:42:04,400 --> 00:42:12,160
to a cv qualified t

00:42:07,440 --> 00:42:15,280
where it with cv2 as long as

00:42:12,160 --> 00:42:18,400
every qualifier that's in cv one

00:42:15,280 --> 00:42:22,319
is in cv2 that is to say

00:42:18,400 --> 00:42:23,119
i can't i can add pawn store volatile

00:42:22,319 --> 00:42:26,480
but i can't

00:42:23,119 --> 00:42:27,200
remove them so here i have a pointer to

00:42:26,480 --> 00:42:29,839
a

00:42:27,200 --> 00:42:31,280
pointer to a regular plain old t pointer

00:42:29,839 --> 00:42:35,280
to a constant t

00:42:31,280 --> 00:42:38,480
pointer to a volatile t i can take the

00:42:35,280 --> 00:42:38,720
i can make p c point to the same object

00:42:38,480 --> 00:42:41,839
as

00:42:38,720 --> 00:42:43,280
p because this is a conversion that adds

00:42:41,839 --> 00:42:45,119
const

00:42:43,280 --> 00:42:47,200
uh it's perfectly safe to take a pointer

00:42:45,119 --> 00:42:49,920
to non-const and convert it into a

00:42:47,200 --> 00:42:52,000
pointer to a const object

00:42:49,920 --> 00:42:53,599
i can't go the other direction though i

00:42:52,000 --> 00:42:56,960
can't turn a pointer

00:42:53,599 --> 00:42:59,119
to a constant object into an into a

00:42:56,960 --> 00:43:03,280
pointer to a non-constant object

00:42:59,119 --> 00:43:03,280
because that throws away a const

00:43:03,680 --> 00:43:09,040
by the same token i can convert in the

00:43:07,040 --> 00:43:11,200
direction that adds volatile

00:43:09,040 --> 00:43:12,560
but not in the direction that removes

00:43:11,200 --> 00:43:14,240
volatile

00:43:12,560 --> 00:43:16,000
and if i try and convert between the

00:43:14,240 --> 00:43:18,000
const pointer or and the volatile

00:43:16,000 --> 00:43:20,000
pointer in either direction

00:43:18,000 --> 00:43:22,079
neither one of those will work because

00:43:20,000 --> 00:43:23,680
in either case i'm losing either the

00:43:22,079 --> 00:43:25,440
volatile or the const

00:43:23,680 --> 00:43:26,800
i'm adding the other one but that

00:43:25,440 --> 00:43:30,560
doesn't change the fact that i'm

00:43:26,800 --> 00:43:33,599
losing one of them as well now

00:43:30,560 --> 00:43:35,280
interestingly const expert when applied

00:43:33,599 --> 00:43:36,480
to a pointer doesn't actually mean the

00:43:35,280 --> 00:43:40,800
same thing

00:43:36,480 --> 00:43:42,960
as const in the same place so

00:43:40,800 --> 00:43:44,960
these two declarations don't have the

00:43:42,960 --> 00:43:47,839
same effect

00:43:44,960 --> 00:43:49,040
the const expert pointer actually

00:43:47,839 --> 00:43:52,800
behaves like a

00:43:49,040 --> 00:43:56,240
const pointer not a

00:43:52,800 --> 00:43:57,920
uh not a pointer to const so this is

00:43:56,240 --> 00:43:58,880
what i mean when i say that const expert

00:43:57,920 --> 00:44:02,160
is not a

00:43:58,880 --> 00:44:05,839
cd qualifier it has different semantics

00:44:02,160 --> 00:44:09,359
and and as a result a

00:44:05,839 --> 00:44:10,160
const expert an object of a pointer type

00:44:09,359 --> 00:44:14,079
that is declared

00:44:10,160 --> 00:44:17,680
const expert is really more similar to a

00:44:14,079 --> 00:44:21,520
to a pointer to a constant

00:44:17,680 --> 00:44:22,000
pointer to something not a pointer to a

00:44:21,520 --> 00:44:25,680
constant

00:44:22,000 --> 00:44:28,160
something all right

00:44:25,680 --> 00:44:30,000
uh moving on to other types of pointer

00:44:28,160 --> 00:44:33,040
conversions

00:44:30,000 --> 00:44:33,680
so accidental pointer conversions were

00:44:33,040 --> 00:44:36,960
common

00:44:33,680 --> 00:44:39,760
in early c programs over time

00:44:36,960 --> 00:44:40,720
people discover programmers discovered

00:44:39,760 --> 00:44:43,200
that

00:44:40,720 --> 00:44:44,880
uh these kinds of pointer that

00:44:43,200 --> 00:44:46,079
conversions between different pointer

00:44:44,880 --> 00:44:48,880
types

00:44:46,079 --> 00:44:50,000
would lead to could lead to surprising

00:44:48,880 --> 00:44:53,200
behavior

00:44:50,000 --> 00:44:55,040
so even in c many of the conversions

00:44:53,200 --> 00:44:58,160
that i'm about to show you are

00:44:55,040 --> 00:44:58,640
warnings uh but c plus plus actually

00:44:58,160 --> 00:45:00,960
treats

00:44:58,640 --> 00:45:03,119
pointer conversions between pointers of

00:45:00,960 --> 00:45:04,880
incompatible types as errors

00:45:03,119 --> 00:45:06,720
so here i have a pointer to an object a

00:45:04,880 --> 00:45:08,480
type gadget a pointer to an object to

00:45:06,720 --> 00:45:10,720
type widget

00:45:08,480 --> 00:45:12,000
i can't i can't take the object the

00:45:10,720 --> 00:45:14,400
pointer to a widget

00:45:12,000 --> 00:45:16,000
and treat it as a pointer to a gadget i

00:45:14,400 --> 00:45:19,280
can't take the pointer to the gadget

00:45:16,000 --> 00:45:23,680
treat it as an object to pipe widget uh

00:45:19,280 --> 00:45:27,520
both of these are errors in c plus plus

00:45:23,680 --> 00:45:31,119
now i can make the compiler do it anyway

00:45:27,520 --> 00:45:34,000
by casting using a reinterpret cast here

00:45:31,119 --> 00:45:35,680
but this doesn't actually make it safe i

00:45:34,000 --> 00:45:38,640
mean what i'm effectively doing

00:45:35,680 --> 00:45:39,920
here is telling the compiler the

00:45:38,640 --> 00:45:42,880
compiler is saying

00:45:39,920 --> 00:45:44,240
was saying back here i don't know looks

00:45:42,880 --> 00:45:46,240
pretty strange there

00:45:44,240 --> 00:45:47,520
a pointer to a widget isn't pointing to

00:45:46,240 --> 00:45:50,720
a gadget

00:45:47,520 --> 00:45:53,200
so are you sure you want to do that

00:45:50,720 --> 00:45:55,920
reinterpret cast is your way of saying

00:45:53,200 --> 00:45:58,800
yes i'm sure i want to do that

00:45:55,920 --> 00:46:00,400
uh let me do it anyway even though i

00:45:58,800 --> 00:46:03,119
know that it's

00:46:00,400 --> 00:46:04,240
strange that it's a strange thing to do

00:46:03,119 --> 00:46:06,800
and

00:46:04,240 --> 00:46:08,240
if you're doing if you're careful that

00:46:06,800 --> 00:46:11,440
can work

00:46:08,240 --> 00:46:14,560
but if but this can also result

00:46:11,440 --> 00:46:15,839
in undefined behavior because what we're

00:46:14,560 --> 00:46:17,839
doing with the cast is making the

00:46:15,839 --> 00:46:21,599
compiler shut up about

00:46:17,839 --> 00:46:24,720
this complaint so

00:46:21,599 --> 00:46:27,440
a pointer to a derived class object

00:46:24,720 --> 00:46:28,400
will safely convert to a pointer to a

00:46:27,440 --> 00:46:31,200
base class

00:46:28,400 --> 00:46:32,000
object if i have an object of type

00:46:31,200 --> 00:46:35,200
derived

00:46:32,000 --> 00:46:38,079
and i take its address i can assign that

00:46:35,200 --> 00:46:40,079
the resulting pointer to a pointer to

00:46:38,079 --> 00:46:41,520
the base class type

00:46:40,079 --> 00:46:43,200
i can't go in the other direction a

00:46:41,520 --> 00:46:44,960
pointer to base doesn't convert into a

00:46:43,200 --> 00:46:46,640
pointer to derived

00:46:44,960 --> 00:46:49,760
but a pointer to derives will convert

00:46:46,640 --> 00:46:49,760
into a pointer to base

00:46:50,160 --> 00:46:54,000
otherwise if i try and access an object

00:46:52,800 --> 00:46:57,359
through a pointer to some

00:46:54,000 --> 00:47:00,079
unrelated type the result is usually

00:46:57,359 --> 00:47:01,280
undefined behavior so here if i have an

00:47:00,079 --> 00:47:03,839
integer

00:47:01,280 --> 00:47:05,359
i take its address and cast that into a

00:47:03,839 --> 00:47:08,079
pointer to a double

00:47:05,359 --> 00:47:08,880
and then i try to write to the to the

00:47:08,079 --> 00:47:11,440
double

00:47:08,880 --> 00:47:14,640
that that thing points to the result

00:47:11,440 --> 00:47:16,480
that i get is undefined behavior

00:47:14,640 --> 00:47:17,760
because there isn't really a double

00:47:16,480 --> 00:47:22,400
object

00:47:17,760 --> 00:47:22,400
there there's really an int object

00:47:23,200 --> 00:47:28,640
uh now some c functions like

00:47:26,480 --> 00:47:29,680
malloc and free were designed to work

00:47:28,640 --> 00:47:33,040
with pointers

00:47:29,680 --> 00:47:36,800
to objects of any type and this type

00:47:33,040 --> 00:47:39,680
and so c provided the type void star

00:47:36,800 --> 00:47:40,880
pointer to void as a kind of generic

00:47:39,680 --> 00:47:43,520
pointer type

00:47:40,880 --> 00:47:44,240
that could represent a pointer to any

00:47:43,520 --> 00:47:46,640
kind of

00:47:44,240 --> 00:47:48,640
object so that's the return value of

00:47:46,640 --> 00:47:50,079
mellow then it's what the free function

00:47:48,640 --> 00:47:53,359
takes

00:47:50,079 --> 00:47:54,319
and a pointer to avoid can theoretically

00:47:53,359 --> 00:47:58,079
point to

00:47:54,319 --> 00:48:01,359
any kind of object uh now

00:47:58,079 --> 00:48:04,559
a c program is happy to convert to or

00:48:01,359 --> 00:48:06,480
from pointer to void with or with or

00:48:04,559 --> 00:48:11,440
without a cast

00:48:06,480 --> 00:48:13,359
so uh that's useful but it also has this

00:48:11,440 --> 00:48:16,720
side effect which means that

00:48:13,359 --> 00:48:19,520
if i start with a pointer to a gadget

00:48:16,720 --> 00:48:21,200
i can assign that to a pointer to void

00:48:19,520 --> 00:48:22,079
and then i can assign that pointer to a

00:48:21,200 --> 00:48:24,640
void

00:48:22,079 --> 00:48:26,319
to a pointer to a widget and that has

00:48:24,640 --> 00:48:28,319
the effect of converting

00:48:26,319 --> 00:48:31,280
a pointer to a gadget into a pointer to

00:48:28,319 --> 00:48:34,240
a widget without a cast

00:48:31,280 --> 00:48:36,240
and this still yields undefined behavior

00:48:34,240 --> 00:48:39,359
even though

00:48:36,240 --> 00:48:41,680
there were no castes involved

00:48:39,359 --> 00:48:43,760
cpos plus tries to protect you against

00:48:41,680 --> 00:48:46,720
this kind of mistake

00:48:43,760 --> 00:48:48,960
only allowing you to convert towards

00:48:46,720 --> 00:48:52,559
void star not to convert

00:48:48,960 --> 00:48:56,000
away from it in other words

00:48:52,559 --> 00:48:58,640
i can take a pointer to

00:48:56,000 --> 00:48:59,760
to a gadget and convert it into a

00:48:58,640 --> 00:49:01,520
pointer to avoid

00:48:59,760 --> 00:49:02,880
z plus plus will let me do this without

00:49:01,520 --> 00:49:05,200
complaint

00:49:02,880 --> 00:49:07,280
if i try and take the pointer to void

00:49:05,200 --> 00:49:08,319
and assign it to a pointer to a widget

00:49:07,280 --> 00:49:11,760
though

00:49:08,319 --> 00:49:14,319
this is an error in c plus plus c won't

00:49:11,760 --> 00:49:16,079
complain but c plus plus will

00:49:14,319 --> 00:49:18,000
in c plus plus i would have to use a

00:49:16,079 --> 00:49:21,280
cast to

00:49:18,000 --> 00:49:23,839
force the compiler to accept this uh

00:49:21,280 --> 00:49:24,640
to do this conversion the idea being

00:49:23,839 --> 00:49:27,280
that

00:49:24,640 --> 00:49:29,040
when i convert from a pointer to a t to

00:49:27,280 --> 00:49:31,040
a pointer to a void

00:49:29,040 --> 00:49:33,040
that's a relatively safe thing to do

00:49:31,040 --> 00:49:35,760
because it turns out you can't actually

00:49:33,040 --> 00:49:37,280
do very much with a plain old pointer to

00:49:35,760 --> 00:49:39,040
avoid

00:49:37,280 --> 00:49:41,280
an objective type void doesn't have a

00:49:39,040 --> 00:49:44,240
size you can't

00:49:41,280 --> 00:49:45,680
uh you can't increment the pointer to

00:49:44,240 --> 00:49:47,440
make it point to the next

00:49:45,680 --> 00:49:49,440
void because the compiler doesn't know

00:49:47,440 --> 00:49:51,839
how big a void is

00:49:49,440 --> 00:49:52,880
you can't dereference a pointer to void

00:49:51,839 --> 00:49:56,160
because

00:49:52,880 --> 00:49:56,640
objects of type void aren't really a

00:49:56,160 --> 00:49:58,960
thing

00:49:56,640 --> 00:49:59,920
void is just a placeholder type in that

00:49:58,960 --> 00:50:03,440
sense

00:49:59,920 --> 00:50:04,000
um and this is actually true void is

00:50:03,440 --> 00:50:06,720
actually

00:50:04,000 --> 00:50:07,040
an incomplete type and so if you have

00:50:06,720 --> 00:50:08,800
other

00:50:07,040 --> 00:50:10,319
incomplete types that is types that

00:50:08,800 --> 00:50:13,119
you've declared

00:50:10,319 --> 00:50:14,079
but not defined the same thing is also

00:50:13,119 --> 00:50:15,680
true you can't

00:50:14,079 --> 00:50:18,960
write any of these expressions for a

00:50:15,680 --> 00:50:21,280
pointer to that type either

00:50:18,960 --> 00:50:22,480
on the other hand if i convert a pointer

00:50:21,280 --> 00:50:25,440
to void

00:50:22,480 --> 00:50:27,200
into a pointer to some other type of

00:50:25,440 --> 00:50:30,240
object

00:50:27,200 --> 00:50:33,520
here this is a dangerous thing to do

00:50:30,240 --> 00:50:35,839
because now i'm adding information to

00:50:33,520 --> 00:50:37,920
this pointer i'm saying

00:50:35,839 --> 00:50:40,880
you should be able to use this pointer

00:50:37,920 --> 00:50:44,960
as if it were a pointer to a t

00:50:40,880 --> 00:50:46,720
and if it isn't really a pointer to a t

00:50:44,960 --> 00:50:49,040
we could get undefined behavior as a

00:50:46,720 --> 00:50:49,040
result

00:50:49,520 --> 00:50:55,440
that's the that's why this direction you

00:50:52,559 --> 00:50:58,800
need to cast

00:50:55,440 --> 00:51:03,119
all right do we need any cast

00:50:58,800 --> 00:51:06,480
to convert from a type from a

00:51:03,119 --> 00:51:07,280
pointer to constant t to pointer to

00:51:06,480 --> 00:51:10,640
constant

00:51:07,280 --> 00:51:13,920
void if you're converting

00:51:10,640 --> 00:51:16,960
from pointer to constant t

00:51:13,920 --> 00:51:21,280
to pointer to constant void

00:51:16,960 --> 00:51:24,319
that's a that's this kind of conversion

00:51:21,280 --> 00:51:25,599
converting from a pointer to a t into a

00:51:24,319 --> 00:51:27,839
pointer to a void

00:51:25,599 --> 00:51:29,359
you're preserving the const and

00:51:27,839 --> 00:51:29,680
otherwise the only thing that's changing

00:51:29,359 --> 00:51:33,280
is

00:51:29,680 --> 00:51:34,079
t is becoming void that's a safe

00:51:33,280 --> 00:51:37,359
conversion

00:51:34,079 --> 00:51:38,880
that doesn't require a cast going in the

00:51:37,359 --> 00:51:42,319
other direction

00:51:38,880 --> 00:51:44,160
pointer to constant void to pointer to

00:51:42,319 --> 00:51:47,520
constant t

00:51:44,160 --> 00:51:49,599
that requires a reinterpret cast because

00:51:47,520 --> 00:51:51,359
that's the same the danger is the same

00:51:49,599 --> 00:51:52,800
as converting a pointer to a

00:51:51,359 --> 00:51:56,000
non-constant void

00:51:52,800 --> 00:51:59,200
into a pointer to a non-constant t

00:51:56,000 --> 00:52:01,920
the d there is um

00:51:59,200 --> 00:52:03,440
you can do things with a pointer to a t

00:52:01,920 --> 00:52:05,839
that you can't do with a pointer to

00:52:03,440 --> 00:52:05,839
avoid

00:52:06,880 --> 00:52:13,680
okay so um

00:52:10,240 --> 00:52:14,000
references are another way of referring

00:52:13,680 --> 00:52:17,599
to

00:52:14,000 --> 00:52:20,480
objects through an alias

00:52:17,599 --> 00:52:21,280
aside from pointers so i declare

00:52:20,480 --> 00:52:24,800
references

00:52:21,280 --> 00:52:27,440
using the ampersand operator here

00:52:24,800 --> 00:52:28,960
and this defines ri to be a reference to

00:52:27,440 --> 00:52:32,400
an integer

00:52:28,960 --> 00:52:35,920
that is referring to object i here

00:52:32,400 --> 00:52:38,480
after this point any time i use ri

00:52:35,920 --> 00:52:40,480
in an expression it's as if i'd written

00:52:38,480 --> 00:52:42,240
i there

00:52:40,480 --> 00:52:43,680
so it's effectively you can think of a

00:52:42,240 --> 00:52:46,240
reference as

00:52:43,680 --> 00:52:47,119
a kind of a constant pointer it's

00:52:46,240 --> 00:52:49,760
effectively

00:52:47,119 --> 00:52:50,880
a a pointer that always points to the

00:52:49,760 --> 00:52:53,119
same thing

00:52:50,880 --> 00:52:54,480
and always has a star in front of it

00:52:53,119 --> 00:52:56,800
whenever you use it

00:52:54,480 --> 00:52:58,640
later on so anything that you could

00:52:56,800 --> 00:53:01,280
write using references

00:52:58,640 --> 00:53:03,599
you could also write using constant

00:53:01,280 --> 00:53:05,760
pointers

00:53:03,599 --> 00:53:07,200
once you create a reference you can't

00:53:05,760 --> 00:53:10,480
change to anything else

00:53:07,200 --> 00:53:13,520
change it to anything else is it

00:53:10,480 --> 00:53:14,319
really undefined behavior or will it

00:53:13,520 --> 00:53:16,960
treat

00:53:14,319 --> 00:53:17,520
it as if the memory was laid out for the

00:53:16,960 --> 00:53:20,559
target

00:53:17,520 --> 00:53:20,559
type um

00:53:22,960 --> 00:53:29,920
it's really undefined behavior uh

00:53:27,440 --> 00:53:31,200
uh you might get away with undefined

00:53:29,920 --> 00:53:33,760
behavior

00:53:31,200 --> 00:53:34,480
most platforms will try and treat it as

00:53:33,760 --> 00:53:38,240
if it's

00:53:34,480 --> 00:53:40,160
a pointer to the target type

00:53:38,240 --> 00:53:42,000
the reason it's undefined behavior is

00:53:40,160 --> 00:53:45,440
because if there isn't actually an

00:53:42,000 --> 00:53:49,200
objective type t there then

00:53:45,440 --> 00:53:54,240
uh so whatever treating something

00:53:49,200 --> 00:53:56,480
as a t could give you strange results

00:53:54,240 --> 00:53:57,760
are these unsafe casts effectively the

00:53:56,480 --> 00:54:01,040
same as a union

00:53:57,760 --> 00:54:04,880
with different members yes often that's

00:54:01,040 --> 00:54:08,880
that's the case converting if you

00:54:04,880 --> 00:54:11,359
assign to one member of a union and then

00:54:08,880 --> 00:54:12,319
try to access a different member of the

00:54:11,359 --> 00:54:14,800
union

00:54:12,319 --> 00:54:17,040
yes you will get you'll generally get

00:54:14,800 --> 00:54:18,880
similar behavior to trying to access an

00:54:17,040 --> 00:54:20,640
object through a pointer to the wrong

00:54:18,880 --> 00:54:24,800
type

00:54:20,640 --> 00:54:26,160
uh so once you create a reference

00:54:24,800 --> 00:54:28,000
you can't change it to refer to

00:54:26,160 --> 00:54:31,040
something else because

00:54:28,000 --> 00:54:34,240
this statement binds i

00:54:31,040 --> 00:54:38,079
binds the object ri to i

00:54:34,240 --> 00:54:40,799
but any later use of ri

00:54:38,079 --> 00:54:41,839
is actually as if i had written i so

00:54:40,799 --> 00:54:44,720
this is not

00:54:41,839 --> 00:54:46,480
us not changing what ri refers to it's

00:54:44,720 --> 00:54:50,000
assigning

00:54:46,480 --> 00:54:53,040
j to the object that ri refers to

00:54:50,000 --> 00:54:56,079
namely i

00:54:53,040 --> 00:55:00,240
but you didn't indicate that even a

00:54:56,079 --> 00:55:02,559
right is unsafe um

00:55:00,240 --> 00:55:05,119
which is normal with unions oh didn't i

00:55:02,559 --> 00:55:09,359
indicate that even a right is unsafe

00:55:05,119 --> 00:55:09,359
ah um

00:55:12,240 --> 00:55:15,920
the the use of a of a union there

00:55:14,720 --> 00:55:18,319
different members of a union

00:55:15,920 --> 00:55:19,119
is it's similar it's not the same thing

00:55:18,319 --> 00:55:21,599
the way that you

00:55:19,119 --> 00:55:22,160
change which member of a union you're

00:55:21,599 --> 00:55:25,200
using

00:55:22,160 --> 00:55:27,680
is by assigning to it is by assigning to

00:55:25,200 --> 00:55:30,640
one of the members of a union so that

00:55:27,680 --> 00:55:33,680
effectively changes what kind of object

00:55:30,640 --> 00:55:37,920
lives at that at the

00:55:33,680 --> 00:55:39,920
address of that union object um

00:55:37,920 --> 00:55:41,280
if you have more questions about this uh

00:55:39,920 --> 00:55:44,480
i will be around

00:55:41,280 --> 00:55:46,319
after the talk in remo but

00:55:44,480 --> 00:55:48,000
uh i'd like to move on and finish out

00:55:46,319 --> 00:55:51,040
this discussion of

00:55:48,000 --> 00:55:53,200
references okay

00:55:51,040 --> 00:55:55,200
um since you can't change what a

00:55:53,200 --> 00:55:57,280
reference refers to later on

00:55:55,200 --> 00:56:00,799
you have to say what it refers to at the

00:55:57,280 --> 00:56:00,799
time that you create the reference

00:56:00,960 --> 00:56:04,559
there's no there's no reference

00:56:02,559 --> 00:56:06,559
equivalent of a null pointer

00:56:04,559 --> 00:56:08,319
because you can't change what a

00:56:06,559 --> 00:56:11,119
reference refers to

00:56:08,319 --> 00:56:12,640
a pointer that currently points to null

00:56:11,119 --> 00:56:13,760
could point to something else in the

00:56:12,640 --> 00:56:15,520
future

00:56:13,760 --> 00:56:17,520
but a reference always refers to the

00:56:15,520 --> 00:56:19,760
same object

00:56:17,520 --> 00:56:20,559
so a reference that started out as null

00:56:19,760 --> 00:56:23,839
would always be

00:56:20,559 --> 00:56:26,160
null that said

00:56:23,839 --> 00:56:27,200
the same way that you can get a dangling

00:56:26,160 --> 00:56:30,319
pointer

00:56:27,200 --> 00:56:33,440
you can also create a dangling reference

00:56:30,319 --> 00:56:36,319
so same way you want to be careful about

00:56:33,440 --> 00:56:38,720
returning a reference to a local

00:56:36,319 --> 00:56:42,640
variable like this this will be a

00:56:38,720 --> 00:56:45,760
this f will produce a dangling reference

00:56:42,640 --> 00:56:47,200
so given that i can write code that uses

00:56:45,760 --> 00:56:50,319
references

00:56:47,200 --> 00:56:53,119
as code that uses pointers

00:56:50,319 --> 00:56:55,119
why did c plus plus c fit to introduce

00:56:53,119 --> 00:56:57,040
references

00:56:55,119 --> 00:56:58,799
it's really for the purposes of operator

00:56:57,040 --> 00:57:01,760
overloading its

00:56:58,799 --> 00:57:02,319
references are designed to provide

00:57:01,760 --> 00:57:05,440
function

00:57:02,319 --> 00:57:07,119
interfaces that look more like

00:57:05,440 --> 00:57:09,920
the function interfaces that you could

00:57:07,119 --> 00:57:11,599
write that we get for built-in types

00:57:09,920 --> 00:57:12,960
specifically in the case of overloaded

00:57:11,599 --> 00:57:16,079
operators

00:57:12,960 --> 00:57:17,839
so here i have an enumeration month

00:57:16,079 --> 00:57:19,760
where values represent different months

00:57:17,839 --> 00:57:21,839
of the year

00:57:19,760 --> 00:57:23,599
i might want to be able to write a loop

00:57:21,839 --> 00:57:26,559
like this where i step through

00:57:23,599 --> 00:57:26,960
each month in the year and do something

00:57:26,559 --> 00:57:30,319
and

00:57:26,960 --> 00:57:33,760
do something for each month now in

00:57:30,319 --> 00:57:36,559
c this code just works because in c

00:57:33,760 --> 00:57:36,960
enumerations are just integers c plus

00:57:36,559 --> 00:57:39,520
plus

00:57:36,960 --> 00:57:41,599
doesn't treat enumerations that way it

00:57:39,520 --> 00:57:44,559
treats them as

00:57:41,599 --> 00:57:46,319
user-defined types so this doesn't

00:57:44,559 --> 00:57:48,720
compile

00:57:46,319 --> 00:57:49,760
um the built-in plus plus won't accept

00:57:48,720 --> 00:57:53,200
an operation of

00:57:49,760 --> 00:57:54,480
enumeration type but we can overload

00:57:53,200 --> 00:57:57,680
plus plus

00:57:54,480 --> 00:57:59,920
to make it work for month

00:57:57,680 --> 00:58:00,880
now if we try and just pass the month by

00:57:59,920 --> 00:58:04,240
value

00:58:00,880 --> 00:58:07,280
it's not going to work because

00:58:04,240 --> 00:58:08,000
i can write plus plus m but the result

00:58:07,280 --> 00:58:10,960
isn't the value

00:58:08,000 --> 00:58:11,520
of m changes the result is we copy the

00:58:10,960 --> 00:58:14,640
value of

00:58:11,520 --> 00:58:15,119
m into x and then we change the value of

00:58:14,640 --> 00:58:18,559
x

00:58:15,119 --> 00:58:18,559
and throw away x

00:58:19,440 --> 00:58:25,599
okay let's try pass it and try an

00:58:21,440 --> 00:58:28,960
operator plus plus that uses a pointer

00:58:25,599 --> 00:58:30,160
uh here it turns out this actually won't

00:58:28,960 --> 00:58:32,799
compile

00:58:30,160 --> 00:58:33,920
the reason it plus plus has a pr already

00:58:32,799 --> 00:58:36,079
has a meaning for

00:58:33,920 --> 00:58:38,000
a pointer to a month same way as a

00:58:36,079 --> 00:58:40,960
pointer to an int can be incremented you

00:58:38,000 --> 00:58:44,480
can also increment a pointer to a month

00:58:40,960 --> 00:58:46,319
uh we can't change that meaning by

00:58:44,480 --> 00:58:48,000
defining an overloaded operator for a

00:58:46,319 --> 00:58:50,400
pointer

00:58:48,000 --> 00:58:51,599
but even if it did compile it wouldn't

00:58:50,400 --> 00:58:55,760
work correctly

00:58:51,599 --> 00:58:57,040
because we want to be able to write this

00:58:55,760 --> 00:58:59,359
but that's not what we would have to

00:58:57,040 --> 00:59:02,720
write we'd have to pass the address of

00:58:59,359 --> 00:59:05,599
m into this thing which is

00:59:02,720 --> 00:59:07,280
so that we would wind up with something

00:59:05,599 --> 00:59:10,400
that doesn't really look like a typical

00:59:07,280 --> 00:59:10,400
plus plus operator

00:59:11,200 --> 00:59:15,440
so if we want to write our plus plus

00:59:13,280 --> 00:59:17,920
operator that can modify a month

00:59:15,440 --> 00:59:19,920
object we really need to pass it in by

00:59:17,920 --> 00:59:22,559
reference

00:59:19,920 --> 00:59:24,400
this version looks right compiles does

00:59:22,559 --> 00:59:26,799
the right thing

00:59:24,400 --> 00:59:28,960
and by the way uh a plus plus operator

00:59:26,799 --> 00:59:30,880
doesn't actually return

00:59:28,960 --> 00:59:32,720
uh void i've been showing you that just

00:59:30,880 --> 00:59:33,440
as a simplification but really it

00:59:32,720 --> 00:59:34,880
returns

00:59:33,440 --> 00:59:37,440
a reference to the thing that was

00:59:34,880 --> 00:59:37,440
incremented

00:59:37,599 --> 00:59:42,880
um so in conclusion

00:59:40,960 --> 00:59:44,720
you can't use because you can't use

00:59:42,880 --> 00:59:46,079
references to you can't change what a

00:59:44,720 --> 00:59:49,440
reference refers to

00:59:46,079 --> 00:59:51,280
after it's been created you can't really

00:59:49,440 --> 00:59:52,880
use a reference to step through the

00:59:51,280 --> 00:59:56,319
elements of an array or

00:59:52,880 --> 00:59:59,200
implement a data structure very easily

00:59:56,319 --> 01:00:00,000
that's what we use pointers for pointers

00:59:59,200 --> 01:00:01,839
are designed for

01:00:00,000 --> 01:00:04,400
iteration for implementing data

01:00:01,839 --> 01:00:06,960
structures things like that

01:00:04,400 --> 01:00:08,960
references are really in c plus so that

01:00:06,960 --> 01:00:10,799
overloaded operators

01:00:08,960 --> 01:00:12,319
can look and feel like built-in

01:00:10,799 --> 01:00:14,240
operators

01:00:12,319 --> 01:00:16,960
references are for writing function

01:00:14,240 --> 01:00:16,960
interfaces

01:00:17,760 --> 01:00:23,440
okay that brings me to the end um

01:00:21,359 --> 01:00:24,640
as i said i'll be around to answer

01:00:23,440 --> 01:00:28,079
questions for a little bit

01:00:24,640 --> 01:00:31,520
in remo otherwise thank you for coming

01:00:28,079 --> 01:00:34,000
for coming given to this virtual talk

01:00:31,520 --> 01:00:43,839
uh i hope you find it useful enjoy the

01:00:34,000 --> 01:00:43,839
rest of cppcon

01:00:55,119 --> 01:00:57,200

YouTube URL: https://www.youtube.com/watch?v=rqVWj0aVSxg


