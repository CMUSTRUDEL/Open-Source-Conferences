Title: Embedded: Customizing Dynamic Memory Management in C++ - Ben Saks - CppCon 2020
Publication date: 2020-09-25
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Dynamic memory allocation is a natural solution for many common programming problems. In C++, new-expressions allocate dynamic memory through a function called operator new. Unfortunately, the compiler-provided implementation of operator new is often expensive to run, non-deterministic, and risks fragmenting memory over time. As a result, too many resource-constrained systems (e.g., embedded, real-time, or high-performance applications) avoid using new-expressions altogether. This is unfortunate because C++ new-expressions were designed to be highly customizable for such purposes.

This session shows how to implement customized dynamic memory managers for use in resource-constrained systems. It presents multiple forms of operator new and operator delete and explains the language mechanisms behind them. It shows how you can replace the compiler-provided operator new and operator delete with your own implementation, either globally or for individual classes. Youâ€™ll leave with a clearer understanding of how new and delete work and how you can tailor them to meet the demands of many resource-constrained applications.

---
Ben Saks
Chief Engineer, Saks & Associates

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,240 --> 00:00:14,160
all right

00:00:10,880 --> 00:00:16,160
hello cbp con 2020 uh i'm ben

00:00:14,160 --> 00:00:18,480
sacks for those of you who don't know me

00:00:16,160 --> 00:00:21,359
my company saxon associates

00:00:18,480 --> 00:00:23,279
offers training in cnc plus plus for

00:00:21,359 --> 00:00:25,359
companies all over the world

00:00:23,279 --> 00:00:27,279
uh and i'm going to be talking today

00:00:25,359 --> 00:00:28,080
about customizing dynamic memory

00:00:27,279 --> 00:00:31,199
management

00:00:28,080 --> 00:00:32,000
in c plus plus in particular uh but not

00:00:31,199 --> 00:00:35,520
exclusively

00:00:32,000 --> 00:00:39,280
for embedded systems programming uh

00:00:35,520 --> 00:00:43,200
feel free to ask questions during the

00:00:39,280 --> 00:00:45,440
during the talk um

00:00:43,200 --> 00:00:47,200
but please understand we're on a

00:00:45,440 --> 00:00:50,559
something like a 10 to 15 second

00:00:47,200 --> 00:00:51,360
delay so if it doesn't sound like i get

00:00:50,559 --> 00:00:53,360
to your question

00:00:51,360 --> 00:00:54,640
right away that might just be because it

00:00:53,360 --> 00:00:58,640
hasn't appeared

00:00:54,640 --> 00:01:01,600
in my uh on my screen yet

00:00:58,640 --> 00:01:02,800
so yeah just give me a moment i will but

00:01:01,600 --> 00:01:06,000
i will do my best to

00:01:02,800 --> 00:01:08,080
answer questions as they come up anyway

00:01:06,000 --> 00:01:09,119
so let's get ahead and go ahead and get

00:01:08,080 --> 00:01:11,680
started

00:01:09,119 --> 00:01:13,360
i mean your first question might be

00:01:11,680 --> 00:01:16,880
dynamic memory management

00:01:13,360 --> 00:01:19,840
in embedded systems i just don't do that

00:01:16,880 --> 00:01:21,119
my system is not uh doesn't use any

00:01:19,840 --> 00:01:23,759
dynamic memory

00:01:21,119 --> 00:01:24,720
and for a lot of embedded systems that's

00:01:23,759 --> 00:01:27,119
true

00:01:24,720 --> 00:01:27,759
and there are reasons why that's the

00:01:27,119 --> 00:01:30,720
case

00:01:27,759 --> 00:01:31,759
because the default dynamic memory

00:01:30,720 --> 00:01:35,280
allocator in

00:01:31,759 --> 00:01:37,680
cnc plus plus is often has

00:01:35,280 --> 00:01:39,119
some characteristics that don't make it

00:01:37,680 --> 00:01:42,960
well suited to use

00:01:39,119 --> 00:01:46,320
in embedded systems uh it can be slow

00:01:42,960 --> 00:01:47,960
or and more importantly it can be

00:01:46,320 --> 00:01:49,600
how long it takes can be

00:01:47,960 --> 00:01:52,000
non-deterministic

00:01:49,600 --> 00:01:53,520
uh so in some in some cases you want to

00:01:52,000 --> 00:01:55,920
get an answer within a certain amount of

00:01:53,520 --> 00:01:57,920
time whether it's yes or no

00:01:55,920 --> 00:01:59,119
and also they also run the risk of

00:01:57,920 --> 00:02:02,880
fragmenting memory

00:01:59,119 --> 00:02:04,719
over time uh where

00:02:02,880 --> 00:02:06,079
the longer the program goes on the

00:02:04,719 --> 00:02:09,759
harder it is to find

00:02:06,079 --> 00:02:13,520
suitable pieces of memory for different

00:02:09,759 --> 00:02:14,400
size objects and for embedded devices

00:02:13,520 --> 00:02:17,840
which are designed

00:02:14,400 --> 00:02:20,000
to run for indefinite periods of time in

00:02:17,840 --> 00:02:22,319
a lot of cases

00:02:20,000 --> 00:02:24,080
something that degrades over time is not

00:02:22,319 --> 00:02:25,840
good

00:02:24,080 --> 00:02:28,000
so there are a lot of embedded systems

00:02:25,840 --> 00:02:30,800
that just avoid using dynamic memory

00:02:28,000 --> 00:02:31,599
altogether but what i'm going to show

00:02:30,800 --> 00:02:34,000
you here is

00:02:31,599 --> 00:02:36,400
you don't necessarily have to forego all

00:02:34,000 --> 00:02:38,080
use of dynamic memory

00:02:36,400 --> 00:02:40,480
you just don't necessarily want to be

00:02:38,080 --> 00:02:41,920
using the default dynamic memory

00:02:40,480 --> 00:02:44,160
allocator to do it

00:02:41,920 --> 00:02:46,319
if you write your own memory allocator

00:02:44,160 --> 00:02:49,760
if you customize how

00:02:46,319 --> 00:02:51,840
how the allocation system works

00:02:49,760 --> 00:02:53,360
you might be able to get something with

00:02:51,840 --> 00:02:54,959
performance characteristics that are

00:02:53,360 --> 00:02:58,000
more suited for your

00:02:54,959 --> 00:02:59,920
application okay

00:02:58,000 --> 00:03:03,280
so first off let me start off just make

00:02:59,920 --> 00:03:06,640
sure we're on the same page

00:03:03,280 --> 00:03:07,760
when i talk about objects the objects in

00:03:06,640 --> 00:03:10,720
c plus plus have a

00:03:07,760 --> 00:03:12,560
storage duration which is the lifetime

00:03:10,720 --> 00:03:14,959
of the storage that fiat

00:03:12,560 --> 00:03:16,000
that contains the object and it comes in

00:03:14,959 --> 00:03:19,760
three flavors

00:03:16,000 --> 00:03:23,120
uh static automatic and dynamic

00:03:19,760 --> 00:03:24,159
static storage duration is for objects

00:03:23,120 --> 00:03:27,040
that are

00:03:24,159 --> 00:03:27,519
created when the program starts up and

00:03:27,040 --> 00:03:30,400
lasts

00:03:27,519 --> 00:03:30,959
for the duration of the entire program

00:03:30,400 --> 00:03:32,640
which

00:03:30,959 --> 00:03:34,959
for a lot of embedded systems is going

00:03:32,640 --> 00:03:37,280
to be just indefinitely

00:03:34,959 --> 00:03:38,560
a lot of embedded systems don't shut

00:03:37,280 --> 00:03:42,720
down the same way that you

00:03:38,560 --> 00:03:45,599
close microsoft word um

00:03:42,720 --> 00:03:47,200
so so for embedded systems static

00:03:45,599 --> 00:03:49,200
storage duration is often essentially

00:03:47,200 --> 00:03:53,280
the entire life of the program

00:03:49,200 --> 00:03:56,000
uh the essentially indefinite

00:03:53,280 --> 00:03:57,599
uh for objects with automatic storage

00:03:56,000 --> 00:04:00,560
duration this is what we think of when

00:03:57,599 --> 00:04:04,239
we think of objects created on the stack

00:04:00,560 --> 00:04:05,920
uh function parameters

00:04:04,239 --> 00:04:08,319
variables that are local to functions

00:04:05,920 --> 00:04:10,640
things like that where

00:04:08,319 --> 00:04:11,599
the memory for them is allocated on the

00:04:10,640 --> 00:04:14,159
stack

00:04:11,599 --> 00:04:15,519
at the point when control enters the

00:04:14,159 --> 00:04:18,479
function call

00:04:15,519 --> 00:04:19,840
and it lasts until control leaves that

00:04:18,479 --> 00:04:23,440
function call

00:04:19,840 --> 00:04:25,840
so those objects are created they stay

00:04:23,440 --> 00:04:27,759
around for however long they're needed

00:04:25,840 --> 00:04:29,199
to for that function and then they go

00:04:27,759 --> 00:04:30,960
away

00:04:29,199 --> 00:04:32,560
and the third category which is what

00:04:30,960 --> 00:04:35,759
we're going to be mostly mostly talking

00:04:32,560 --> 00:04:38,400
about today is dynamic storage duration

00:04:35,759 --> 00:04:39,840
where an object the storage for an

00:04:38,400 --> 00:04:43,040
object is allocated

00:04:39,840 --> 00:04:45,360
when you ask for it you manually do

00:04:43,040 --> 00:04:46,320
something to request the memory for an

00:04:45,360 --> 00:04:48,080
object

00:04:46,320 --> 00:04:51,840
and you have that memory available to

00:04:48,080 --> 00:04:55,440
you until you say i'm done using it

00:04:51,840 --> 00:04:56,080
and you d out you call a d allocate

00:04:55,440 --> 00:04:58,880
function

00:04:56,080 --> 00:05:01,280
to return that memory to the general

00:04:58,880 --> 00:05:01,280
store

00:05:01,600 --> 00:05:09,039
so in c we would typically allocate

00:05:04,720 --> 00:05:12,400
memory dynamically using malloc and free

00:05:09,039 --> 00:05:14,160
so you would out you would call mello

00:05:12,400 --> 00:05:16,240
you'd pass it the size of the

00:05:14,160 --> 00:05:18,000
object that you tried that you're trying

00:05:16,240 --> 00:05:20,960
to allocate memory for

00:05:18,000 --> 00:05:23,600
it would return back to you a pointer to

00:05:20,960 --> 00:05:27,039
a dynamically allocated block of memory

00:05:23,600 --> 00:05:27,360
that you could then use uh to store your

00:05:27,039 --> 00:05:29,919
t

00:05:27,360 --> 00:05:31,120
object and you'd use that until you were

00:05:29,919 --> 00:05:33,039
done with it

00:05:31,120 --> 00:05:34,960
and when you were finished you'd call

00:05:33,039 --> 00:05:36,479
three pass it the pointer that you

00:05:34,960 --> 00:05:39,120
received from mellow

00:05:36,479 --> 00:05:41,680
and that would release the memory back

00:05:39,120 --> 00:05:45,280
into the system

00:05:41,680 --> 00:05:47,039
in c plus plus uh we do dynamic memory

00:05:45,280 --> 00:05:48,240
allocation a little differently we

00:05:47,039 --> 00:05:51,360
typically use

00:05:48,240 --> 00:05:54,160
new expressions and delete expressions

00:05:51,360 --> 00:05:55,919
so instead of calling mellow we write

00:05:54,160 --> 00:05:58,080
new t

00:05:55,919 --> 00:06:00,639
like this and that returns back a

00:05:58,080 --> 00:06:03,440
pointer to a t object

00:06:00,639 --> 00:06:04,639
and again we can continue to use that t

00:06:03,440 --> 00:06:06,479
object

00:06:04,639 --> 00:06:08,080
until at some point we say we're done

00:06:06,479 --> 00:06:11,520
using that memory

00:06:08,080 --> 00:06:14,160
we write delete p and that

00:06:11,520 --> 00:06:15,840
frees up the memory for use by some

00:06:14,160 --> 00:06:18,479
other object

00:06:15,840 --> 00:06:21,199
and this doesn't look that different

00:06:18,479 --> 00:06:23,680
from malloc and free so you might ask

00:06:21,199 --> 00:06:24,800
why did c plus plus need to introduce

00:06:23,680 --> 00:06:27,919
new and delete

00:06:24,800 --> 00:06:29,840
given that c already had mal open free

00:06:27,919 --> 00:06:31,440
and it turns out it it has to do with

00:06:29,840 --> 00:06:33,680
constructors

00:06:31,440 --> 00:06:34,639
mal oak is a one step process all it

00:06:33,680 --> 00:06:37,280
does is

00:06:34,639 --> 00:06:39,440
dynamically allocate memory and then

00:06:37,280 --> 00:06:42,000
return a pointer to it it hasn't

00:06:39,440 --> 00:06:43,680
done anything to the contents of that

00:06:42,000 --> 00:06:46,800
memory

00:06:43,680 --> 00:06:48,639
new is a two-step process

00:06:46,800 --> 00:06:51,520
first it allocates memory just like

00:06:48,639 --> 00:06:53,520
malok does that's the first step

00:06:51,520 --> 00:06:55,759
but it has a second step that malok

00:06:53,520 --> 00:06:59,280
doesn't have which is

00:06:55,759 --> 00:07:01,360
to call a constructor for

00:06:59,280 --> 00:07:02,319
the object that you're trying to create

00:07:01,360 --> 00:07:04,880
in that memory

00:07:02,319 --> 00:07:05,440
make sure that any that an object of

00:07:04,880 --> 00:07:09,120
type t

00:07:05,440 --> 00:07:12,160
is actually created there appropriately

00:07:09,120 --> 00:07:15,039
so if you were to break down

00:07:12,160 --> 00:07:16,000
a new expression look inside look at

00:07:15,039 --> 00:07:19,280
what the compiler

00:07:16,000 --> 00:07:21,919
actually generates behind the scenes

00:07:19,280 --> 00:07:22,400
for a new expression what you would see

00:07:21,919 --> 00:07:25,840
is that

00:07:22,400 --> 00:07:27,919
this new new expression would translate

00:07:25,840 --> 00:07:30,080
into something that looks internally

00:07:27,919 --> 00:07:33,520
kind of like this

00:07:30,080 --> 00:07:34,479
so this is step one where we call this

00:07:33,520 --> 00:07:37,360
function called

00:07:34,479 --> 00:07:38,479
operator new we pass it the size of the

00:07:37,360 --> 00:07:41,840
object we want to

00:07:38,479 --> 00:07:44,639
allocate just like we we did with malloc

00:07:41,840 --> 00:07:46,240
and the compiler will automatically

00:07:44,639 --> 00:07:49,520
generate code to

00:07:46,240 --> 00:07:52,160
convert that to a pointer to a t

00:07:49,520 --> 00:07:54,000
and assign that to p that's basically

00:07:52,160 --> 00:07:56,720
the same as what mallow did

00:07:54,000 --> 00:07:59,360
just a little bit uh using slightly

00:07:56,720 --> 00:08:03,199
different words the second step here

00:07:59,360 --> 00:08:05,520
is to essentially call a constructor

00:08:03,199 --> 00:08:07,120
on that object that we've just allocated

00:08:05,520 --> 00:08:10,000
to initialize it

00:08:07,120 --> 00:08:11,440
now you can't actually write code like

00:08:10,000 --> 00:08:12,240
this you're not allowed to just

00:08:11,440 --> 00:08:15,280
explicitly

00:08:12,240 --> 00:08:18,160
call a constructor at

00:08:15,280 --> 00:08:18,879
on the object that the pointer points to

00:08:18,160 --> 00:08:22,560
so

00:08:18,879 --> 00:08:24,319
this is just an imaginary notation for

00:08:22,560 --> 00:08:27,840
the sort of thing that the compiler is

00:08:24,319 --> 00:08:27,840
doing internally

00:08:28,240 --> 00:08:33,279
by the same token a delete expression

00:08:31,440 --> 00:08:34,640
really translates into something that

00:08:33,279 --> 00:08:37,279
looks kind of like this

00:08:34,640 --> 00:08:39,039
it checks to see is the pointer a null

00:08:37,279 --> 00:08:39,440
pointer deleting a pointer is always

00:08:39,039 --> 00:08:41,919
safe

00:08:39,440 --> 00:08:42,800
or deleting a null pointer is always

00:08:41,919 --> 00:08:46,480
safe

00:08:42,800 --> 00:08:48,160
it just does nothing but if it's not a

00:08:46,480 --> 00:08:50,320
null pointer

00:08:48,160 --> 00:08:52,000
if p actually points to something first

00:08:50,320 --> 00:08:53,120
we have to call the destructor for that

00:08:52,000 --> 00:08:55,920
object to clean

00:08:53,120 --> 00:08:56,959
up any resources associated with that

00:08:55,920 --> 00:08:59,040
object

00:08:56,959 --> 00:09:01,040
then we can call operator delete and

00:08:59,040 --> 00:09:03,440
actually release the memory

00:09:01,040 --> 00:09:05,279
that was used to create that object to

00:09:03,440 --> 00:09:08,480
store that object

00:09:05,279 --> 00:09:09,920
now unlike the previous slide you can

00:09:08,480 --> 00:09:12,800
actually write

00:09:09,920 --> 00:09:13,600
an explicit destructor call like this

00:09:12,800 --> 00:09:17,440
you almost

00:09:13,600 --> 00:09:20,560
never want to because

00:09:17,440 --> 00:09:22,720
usually if you just write this well the

00:09:20,560 --> 00:09:24,720
compiler is already

00:09:22,720 --> 00:09:26,560
planting calls to destructors

00:09:24,720 --> 00:09:28,000
automatically for you

00:09:26,560 --> 00:09:30,000
and what will wind up happening is that

00:09:28,000 --> 00:09:33,519
the destructor gets run twice

00:09:30,000 --> 00:09:36,399
which is usually not what you want so

00:09:33,519 --> 00:09:37,600
outside of some very rare circumstances

00:09:36,399 --> 00:09:41,519
you don't actually need to

00:09:37,600 --> 00:09:43,440
call the destructor like this okay

00:09:41,519 --> 00:09:44,880
question how can you observe what the

00:09:43,440 --> 00:09:47,120
compiler is doing

00:09:44,880 --> 00:09:49,200
is there some compiler flag or similar

00:09:47,120 --> 00:09:51,680
to output to the

00:09:49,200 --> 00:09:52,240
intermediate code yeah when i'm talking

00:09:51,680 --> 00:09:55,360
about this

00:09:52,240 --> 00:09:56,080
what i'm saying is when i say what the

00:09:55,360 --> 00:09:59,120
compiler

00:09:56,080 --> 00:10:02,240
is doing i'm referring to

00:09:59,120 --> 00:10:04,560
the assembly code that gets generated

00:10:02,240 --> 00:10:06,480
that is then loaded to the device that

00:10:04,560 --> 00:10:09,360
the device would actually

00:10:06,480 --> 00:10:10,640
execute so when you compile a c plus

00:10:09,360 --> 00:10:13,600
plus program it

00:10:10,640 --> 00:10:14,399
uh that the compiler turns that source

00:10:13,600 --> 00:10:17,680
code

00:10:14,399 --> 00:10:20,240
into uh object code

00:10:17,680 --> 00:10:21,360
that that object code is then linked

00:10:20,240 --> 00:10:23,200
together

00:10:21,360 --> 00:10:24,399
across your several different source

00:10:23,200 --> 00:10:27,200
files to form your

00:10:24,399 --> 00:10:29,680
executable and that's what is actually

00:10:27,200 --> 00:10:32,320
running on the device side

00:10:29,680 --> 00:10:33,279
if you look at what's generated there

00:10:32,320 --> 00:10:35,839
what you would

00:10:33,279 --> 00:10:37,120
what you would see is instructions that

00:10:35,839 --> 00:10:39,760
are doing

00:10:37,120 --> 00:10:40,720
the equivalent of this i've rendered it

00:10:39,760 --> 00:10:43,360
in

00:10:40,720 --> 00:10:45,120
a c plus syntax to make it a little

00:10:43,360 --> 00:10:48,240
easier to read

00:10:45,120 --> 00:10:51,279
but you would but uh

00:10:48,240 --> 00:10:53,440
often the generated assembly code has

00:10:51,279 --> 00:10:54,399
comments in it that the compiler just

00:10:53,440 --> 00:10:56,720
plants there

00:10:54,399 --> 00:10:57,519
and so you would see that at this point

00:10:56,720 --> 00:11:01,120
it would

00:10:57,519 --> 00:11:01,839
call a function and you would that would

00:11:01,120 --> 00:11:04,000
have some

00:11:01,839 --> 00:11:05,360
numeric address for it and then off to

00:11:04,000 --> 00:11:07,519
the side there might be a little comment

00:11:05,360 --> 00:11:11,360
that says

00:11:07,519 --> 00:11:12,880
t colon colon tilde t

00:11:11,360 --> 00:11:14,640
and that that's what i'm referring to

00:11:12,880 --> 00:11:16,320
when i talk about

00:11:14,640 --> 00:11:19,839
what i would look at to see what the

00:11:16,320 --> 00:11:19,839
compiler is actually doing here

00:11:20,640 --> 00:11:26,959
is p not equal to to

00:11:24,079 --> 00:11:28,880
no putter generated is that p not equal

00:11:26,959 --> 00:11:31,760
to standard node footer

00:11:28,880 --> 00:11:33,200
generated yeah the idea is this delete

00:11:31,760 --> 00:11:35,680
expression

00:11:33,200 --> 00:11:37,200
translates into something under the hood

00:11:35,680 --> 00:11:40,160
that looks like this

00:11:37,200 --> 00:11:41,440
you write this code and what the

00:11:40,160 --> 00:11:43,680
compiler does

00:11:41,440 --> 00:11:45,839
is it takes care of checking to see

00:11:43,680 --> 00:11:48,000
whether the pointer is null for you

00:11:45,839 --> 00:11:50,000
if the pointer isn't null there's some

00:11:48,000 --> 00:11:50,880
then it has work to do to delete the

00:11:50,000 --> 00:11:53,839
object

00:11:50,880 --> 00:11:54,639
sorry to call the destructor on the

00:11:53,839 --> 00:11:57,680
object that p

00:11:54,639 --> 00:12:00,240
points to and then the last step

00:11:57,680 --> 00:12:02,399
is to release the memory associated with

00:12:00,240 --> 00:12:02,399
p

00:12:03,839 --> 00:12:10,079
so a new expression as

00:12:08,160 --> 00:12:12,240
i showed you a little bit ago a new

00:12:10,079 --> 00:12:15,120
expression allocates memory that

00:12:12,240 --> 00:12:16,240
first step of the allocation process by

00:12:15,120 --> 00:12:18,800
calling a function

00:12:16,240 --> 00:12:21,040
called operator new it's literally the

00:12:18,800 --> 00:12:23,600
name of the function

00:12:21,040 --> 00:12:24,639
now c plus provides a default

00:12:23,600 --> 00:12:28,320
implementation

00:12:24,639 --> 00:12:30,320
for operator new uh but

00:12:28,320 --> 00:12:32,160
and it looks like this it's a function

00:12:30,320 --> 00:12:34,399
named operator new that takes a single

00:12:32,160 --> 00:12:36,959
parameter of type size t

00:12:34,399 --> 00:12:37,680
and returns a pointer to void and n is

00:12:36,959 --> 00:12:40,720
just

00:12:37,680 --> 00:12:41,680
the size of the amount of storage being

00:12:40,720 --> 00:12:45,839
requested

00:12:41,680 --> 00:12:49,120
in bytes a delete expression

00:12:45,839 --> 00:12:52,160
also has a corresponding operator delete

00:12:49,120 --> 00:12:53,839
function that looks like this

00:12:52,160 --> 00:12:55,279
uh that also has a default

00:12:53,839 --> 00:12:57,680
implementation in c

00:12:55,279 --> 00:12:59,680
plus plus so it looks like opera the

00:12:57,680 --> 00:13:02,560
function's called operator delete

00:12:59,680 --> 00:13:03,839
it takes a pointer to void returns

00:13:02,560 --> 00:13:05,519
nothing

00:13:03,839 --> 00:13:07,440
uh and the function is declared no

00:13:05,519 --> 00:13:10,639
except because delete

00:13:07,440 --> 00:13:12,639
can't throw exceptions uh there won't

00:13:10,639 --> 00:13:14,240
you'll you will never see an exception

00:13:12,639 --> 00:13:17,760
thrown from a

00:13:14,240 --> 00:13:17,760
delete expression

00:13:18,839 --> 00:13:24,399
so uh now in a lot of

00:13:22,240 --> 00:13:25,600
implementations of c plus plus operator

00:13:24,399 --> 00:13:28,240
new will actually call

00:13:25,600 --> 00:13:28,800
malloc and similarly operator delete may

00:13:28,240 --> 00:13:32,880
very well

00:13:28,800 --> 00:13:34,880
call free uh which means that

00:13:32,880 --> 00:13:37,920
their their performance characteristics

00:13:34,880 --> 00:13:41,040
are going to be similar in many cases

00:13:37,920 --> 00:13:42,560
those default implementations are the

00:13:41,040 --> 00:13:45,800
ones that we were

00:13:42,560 --> 00:13:47,199
concerned about being too slow being too

00:13:45,800 --> 00:13:51,440
non-deterministic

00:13:47,199 --> 00:13:53,600
or causing too much memory fragmentation

00:13:51,440 --> 00:13:55,920
that might not be well suited to an

00:13:53,600 --> 00:13:58,240
embedded application

00:13:55,920 --> 00:13:59,199
but what we can do in c plus plus is

00:13:58,240 --> 00:14:02,160
that we can

00:13:59,199 --> 00:14:04,079
cpos plus lets us replace the

00:14:02,160 --> 00:14:05,519
implementations of operator new and

00:14:04,079 --> 00:14:08,000
operator delete

00:14:05,519 --> 00:14:09,120
with our own implementations for those

00:14:08,000 --> 00:14:11,040
functions

00:14:09,120 --> 00:14:12,560
this is something you can't do in c

00:14:11,040 --> 00:14:15,680
you're not allowed to replace

00:14:12,560 --> 00:14:16,560
mallow and free but you are allowed to

00:14:15,680 --> 00:14:20,000
replace what

00:14:16,560 --> 00:14:22,320
operator new and operator delete do

00:14:20,000 --> 00:14:23,839
now the replacement functions look

00:14:22,320 --> 00:14:26,320
exactly like

00:14:23,839 --> 00:14:28,000
the functions that they're replacing

00:14:26,320 --> 00:14:30,800
you're just writing them yourself

00:14:28,000 --> 00:14:31,519
instead of relying on one prov on an

00:14:30,800 --> 00:14:35,440
implementation

00:14:31,519 --> 00:14:38,000
provided by the tool chain vendor

00:14:35,440 --> 00:14:40,720
now there are some restrictions on what

00:14:38,000 --> 00:14:44,000
these replacement functions can do

00:14:40,720 --> 00:14:45,440
so here is the operator new function

00:14:44,000 --> 00:14:48,160
that you would write would look like

00:14:45,440 --> 00:14:51,120
this and the required behavior

00:14:48,160 --> 00:14:53,680
is it either returns a non-null pointer

00:14:51,120 --> 00:14:57,040
to suitably aligned storage

00:14:53,680 --> 00:14:59,839
or it throws a bad alloy exception now

00:14:57,040 --> 00:15:00,959
i realize wait it throws a bad alloy

00:14:59,839 --> 00:15:04,160
exception i

00:15:00,959 --> 00:15:05,440
i don't use exceptions in my embedded

00:15:04,160 --> 00:15:08,560
software i

00:15:05,440 --> 00:15:09,360
that's not gonna work for me i i realize

00:15:08,560 --> 00:15:10,880
that

00:15:09,360 --> 00:15:13,120
that question is gonna come to your

00:15:10,880 --> 00:15:14,240
minds quickly hold that thought we'll

00:15:13,120 --> 00:15:15,519
get there

00:15:14,240 --> 00:15:17,920
but for right now i want to just show

00:15:15,519 --> 00:15:20,880
them put that to the side

00:15:17,920 --> 00:15:21,680
i want to just show the mechanics of how

00:15:20,880 --> 00:15:24,399
replacing

00:15:21,680 --> 00:15:26,079
operator new works and then we'll talk

00:15:24,399 --> 00:15:28,079
about how to make sure that it fails in

00:15:26,079 --> 00:15:31,040
some other way that's more acceptable

00:15:28,079 --> 00:15:33,519
for an embedded system

00:15:31,040 --> 00:15:34,399
all right so if i were to write an

00:15:33,519 --> 00:15:37,440
operator new

00:15:34,399 --> 00:15:38,880
the basic structure for replacing

00:15:37,440 --> 00:15:40,079
operator new is going to look something

00:15:38,880 --> 00:15:42,240
like this

00:15:40,079 --> 00:15:44,720
you're going to have your function

00:15:42,240 --> 00:15:48,000
operator new that you write

00:15:44,720 --> 00:15:50,800
you'll go through some process to

00:15:48,000 --> 00:15:51,920
find out to find a suitable piece of

00:15:50,800 --> 00:15:55,600
memory

00:15:51,920 --> 00:15:59,199
for an object of size n

00:15:55,600 --> 00:16:01,279
you'll and this my allocator function

00:15:59,199 --> 00:16:03,120
this just finds memory in whatever form

00:16:01,279 --> 00:16:05,199
is appropriate and we'll talk about

00:16:03,120 --> 00:16:07,600
uh some algorithms that you could use

00:16:05,199 --> 00:16:10,079
for this in a little bit

00:16:07,600 --> 00:16:11,920
but tries to find memory for the object

00:16:10,079 --> 00:16:13,440
if it wasn't able to find memory it

00:16:11,920 --> 00:16:15,839
returns a null pointer

00:16:13,440 --> 00:16:17,759
in which case operator new in this case

00:16:15,839 --> 00:16:19,920
throws badaloke

00:16:17,759 --> 00:16:21,680
to report the failure otherwise it

00:16:19,920 --> 00:16:26,079
returns back the pointer that

00:16:21,680 --> 00:16:26,079
that the allocation function provided

00:16:26,560 --> 00:16:30,639
by the same token an operator delete

00:16:28,959 --> 00:16:33,360
replacement generally looks

00:16:30,639 --> 00:16:34,560
simply like this there isn't as much

00:16:33,360 --> 00:16:36,880
work to do because

00:16:34,560 --> 00:16:38,720
delete doesn't report failures it

00:16:36,880 --> 00:16:41,759
doesn't have any way of

00:16:38,720 --> 00:16:44,079
a delete should never fail so

00:16:41,759 --> 00:16:46,800
it just calls whatever function is

00:16:44,079 --> 00:16:50,000
necessary to de-allocate the memory

00:16:46,800 --> 00:16:52,320
and then it's done

00:16:50,000 --> 00:16:53,440
so here are some very simple

00:16:52,320 --> 00:16:55,680
replacements that i

00:16:53,440 --> 00:16:57,440
could write for operator new and

00:16:55,680 --> 00:16:58,079
operator of the week that are designed

00:16:57,440 --> 00:17:01,040
to

00:16:58,079 --> 00:17:01,839
track the number of allocations that

00:17:01,040 --> 00:17:04,880
haven't been

00:17:01,839 --> 00:17:08,000
deallocated yet gives me a running count

00:17:04,880 --> 00:17:08,400
of how much memory has been allocated in

00:17:08,000 --> 00:17:09,760
a

00:17:08,400 --> 00:17:11,760
rough sense because objects are

00:17:09,760 --> 00:17:15,199
different sizes uh

00:17:11,760 --> 00:17:16,880
over the lifetime of the program so that

00:17:15,199 --> 00:17:18,720
well if i reach the end of the program

00:17:16,880 --> 00:17:20,079
and that number isn't zero

00:17:18,720 --> 00:17:21,600
that's a pretty good indication that

00:17:20,079 --> 00:17:22,319
there's a memory leak somewhere for

00:17:21,600 --> 00:17:25,280
example

00:17:22,319 --> 00:17:26,240
i realize that in an embedded system you

00:17:25,280 --> 00:17:29,120
often don't reach

00:17:26,240 --> 00:17:30,559
the end of a program but you can still

00:17:29,120 --> 00:17:31,600
have a situation where what you see is

00:17:30,559 --> 00:17:36,160
that the

00:17:31,600 --> 00:17:39,200
trend is just going up like this and

00:17:36,160 --> 00:17:40,960
that's often a bad sign

00:17:39,200 --> 00:17:42,480
usually you'd expect it to level off

00:17:40,960 --> 00:17:44,640
after a while

00:17:42,480 --> 00:17:46,080
so here's a this is what the

00:17:44,640 --> 00:17:49,520
implementation looks like we have

00:17:46,080 --> 00:17:50,559
a uh static global counter just deletes

00:17:49,520 --> 00:17:53,520
left to do

00:17:50,559 --> 00:17:53,840
starts out at zero each time we call new

00:17:53,520 --> 00:17:56,960
we

00:17:53,840 --> 00:17:59,280
increment that number of deletions left

00:17:56,960 --> 00:17:59,280
to do

00:17:59,360 --> 00:18:06,000
um and then we uh

00:18:03,520 --> 00:18:07,520
and then when delete gets called we

00:18:06,000 --> 00:18:11,120
decrement that number

00:18:07,520 --> 00:18:13,840
of deletions so each time we

00:18:11,120 --> 00:18:14,559
we call new we add one each time we call

00:18:13,840 --> 00:18:17,039
delete

00:18:14,559 --> 00:18:19,760
we subtract one that gives us our

00:18:17,039 --> 00:18:19,760
running count

00:18:20,640 --> 00:18:25,440
now it turns out actually that replacing

00:18:23,919 --> 00:18:27,679
new and delete is a little bit more

00:18:25,440 --> 00:18:28,000
complicated than i just showed you

00:18:27,679 --> 00:18:31,039
because

00:18:28,000 --> 00:18:34,160
there are actually multiple versions

00:18:31,039 --> 00:18:35,039
of operator new and delete that the

00:18:34,160 --> 00:18:37,520
compiler

00:18:35,039 --> 00:18:38,799
might use so there's one version that

00:18:37,520 --> 00:18:42,080
looks like what i just showed you that

00:18:38,799 --> 00:18:45,039
takes a single parameter of type size t

00:18:42,080 --> 00:18:45,600
there's a second version that takes a

00:18:45,039 --> 00:18:49,120
size

00:18:45,600 --> 00:18:52,559
t and an align vowel t that represents

00:18:49,120 --> 00:18:54,480
the alignment requirement of the memory

00:18:52,559 --> 00:18:56,559
being allocated

00:18:54,480 --> 00:18:58,240
and so behind the scenes the compiler

00:18:56,559 --> 00:19:01,440
might translate

00:18:58,240 --> 00:19:03,840
uh this into a call to either the one

00:19:01,440 --> 00:19:04,960
argument operator new or the two

00:19:03,840 --> 00:19:08,400
argument operator

00:19:04,960 --> 00:19:10,320
nu and so what that means is

00:19:08,400 --> 00:19:12,400
if you replace one you almost certainly

00:19:10,320 --> 00:19:14,720
want to replace the other one as well

00:19:12,400 --> 00:19:16,799
and in many cases you'll replace them by

00:19:14,720 --> 00:19:19,120
both having them call the same

00:19:16,799 --> 00:19:20,400
implementation function there's not much

00:19:19,120 --> 00:19:21,919
work involved

00:19:20,400 --> 00:19:24,240
it's just something you have to remember

00:19:21,919 --> 00:19:26,080
to do uh

00:19:24,240 --> 00:19:28,160
there are actually four versions of

00:19:26,080 --> 00:19:29,360
operator delete that a typical delete

00:19:28,160 --> 00:19:32,559
expression might use

00:19:29,360 --> 00:19:34,640
so there's uh

00:19:32,559 --> 00:19:35,760
there's a delete that takes a pointer to

00:19:34,640 --> 00:19:37,520
void

00:19:35,760 --> 00:19:39,440
a delete that takes a pointer to void

00:19:37,520 --> 00:19:41,679
and a size

00:19:39,440 --> 00:19:43,840
a delete that takes a point a pointer to

00:19:41,679 --> 00:19:45,919
avoid and an alignment

00:19:43,840 --> 00:19:48,960
and then one that takes pointer to avoid

00:19:45,919 --> 00:19:50,840
size and alignment

00:19:48,960 --> 00:19:52,880
and again the compile a delete

00:19:50,840 --> 00:19:55,200
expression depending on which tool

00:19:52,880 --> 00:19:56,080
chain you're using but the lead

00:19:55,200 --> 00:20:00,720
expression might

00:19:56,080 --> 00:20:03,760
invoke different ones of these functions

00:20:00,720 --> 00:20:06,960
uh because and

00:20:03,760 --> 00:20:09,760
you need to want to just

00:20:06,960 --> 00:20:10,720
be prepared for that so for example the

00:20:09,760 --> 00:20:12,640
default

00:20:10,720 --> 00:20:14,960
upper the operator delete that gets

00:20:12,640 --> 00:20:18,240
called by a delete expression

00:20:14,960 --> 00:20:20,320
uh in general on gc on current versions

00:20:18,240 --> 00:20:21,840
of gcc i've found to be different from

00:20:20,320 --> 00:20:25,840
the one that gets called

00:20:21,840 --> 00:20:29,600
by uh visual c plus plus

00:20:25,840 --> 00:20:31,280
by default uh so if you replace

00:20:29,600 --> 00:20:34,720
any of your operator deletes you

00:20:31,280 --> 00:20:38,000
probably want to replace them all

00:20:34,720 --> 00:20:41,120
yeah uh question uh yes there was

00:20:38,000 --> 00:20:42,960
a uh good point

00:20:41,120 --> 00:20:44,480
this this increment should actually be

00:20:42,960 --> 00:20:46,880
done down here

00:20:44,480 --> 00:20:48,799
uh it's true that we should be doing

00:20:46,880 --> 00:20:51,120
that increment after we've already

00:20:48,799 --> 00:20:54,240
determined that the function is going to

00:20:51,120 --> 00:20:56,799
uh be is going to successfully

00:20:54,240 --> 00:20:57,840
allocate memory because there's no more

00:20:56,799 --> 00:21:00,840
memory to delete

00:20:57,840 --> 00:21:02,640
if we actually wind up throwing that out

00:21:00,840 --> 00:21:05,440
instead thank you for

00:21:02,640 --> 00:21:07,200
catching that i will uh i'll have that

00:21:05,440 --> 00:21:12,400
changed in the

00:21:07,200 --> 00:21:12,400
uh in the

00:21:13,200 --> 00:21:16,880
uh the official slides that get posted

00:21:14,960 --> 00:21:20,799
for this shouldn't the

00:21:16,880 --> 00:21:24,080
argument to new go before t

00:21:20,799 --> 00:21:27,919
uh okay so what you're seeing here

00:21:24,080 --> 00:21:31,200
is not an argument to new exactly

00:21:27,919 --> 00:21:32,080
uh this this v here the argument is

00:21:31,200 --> 00:21:36,000
being passed

00:21:32,080 --> 00:21:38,880
to the constructor for the t object

00:21:36,000 --> 00:21:41,280
so that's a constructor argument not an

00:21:38,880 --> 00:21:44,159
argument to operator new

00:21:41,280 --> 00:21:45,440
these values the size and the alignment

00:21:44,159 --> 00:21:48,240
are being supplied

00:21:45,440 --> 00:21:50,000
automatically by the compiler when you

00:21:48,240 --> 00:21:52,400
write a new expression

00:21:50,000 --> 00:21:53,919
like this if the compiler knows

00:21:52,400 --> 00:21:56,159
internally what the size of t

00:21:53,919 --> 00:21:56,960
is what the alignment requirement of t

00:21:56,159 --> 00:22:00,000
is

00:21:56,960 --> 00:22:01,840
it fills those values in automatically

00:22:00,000 --> 00:22:03,360
now in a little while we're going to see

00:22:01,840 --> 00:22:04,320
that there is actually a way to pass

00:22:03,360 --> 00:22:07,039
parameters

00:22:04,320 --> 00:22:09,840
to operator new but it looks a little

00:22:07,039 --> 00:22:09,840
different than that

00:22:11,120 --> 00:22:16,640
okay so um

00:22:15,200 --> 00:22:18,080
those are the steps that you would need

00:22:16,640 --> 00:22:19,360
to go through if you were going to

00:22:18,080 --> 00:22:23,520
replace the global

00:22:19,360 --> 00:22:27,360
operator new and operator delete um

00:22:23,520 --> 00:22:29,600
the now actually doing that

00:22:27,360 --> 00:22:30,720
shouldn't the overload resolution cover

00:22:29,600 --> 00:22:33,600
not changing the

00:22:30,720 --> 00:22:34,000
other new and delete types assuming you

00:22:33,600 --> 00:22:37,440
don't

00:22:34,000 --> 00:22:38,640
use the other new and delete yeah i can

00:22:37,440 --> 00:22:41,679
see why you would

00:22:38,640 --> 00:22:44,720
think that the the rules of uh

00:22:41,679 --> 00:22:47,280
cpus say that effectively these it's as

00:22:44,720 --> 00:22:51,280
if these functions are always declared

00:22:47,280 --> 00:22:54,240
all four of them uh in which case

00:22:51,280 --> 00:22:55,840
whereas so normally overload resolution

00:22:54,240 --> 00:22:59,600
would say if you only declare

00:22:55,840 --> 00:23:00,720
one of them uh you would only there'd

00:22:59,600 --> 00:23:04,240
only be that one

00:23:00,720 --> 00:23:06,320
version but in fact uh

00:23:04,240 --> 00:23:07,919
the way that operator knew an operator

00:23:06,320 --> 00:23:08,960
delete or specify it is a little

00:23:07,919 --> 00:23:11,360
different

00:23:08,960 --> 00:23:12,400
the standard says it's as if these

00:23:11,360 --> 00:23:16,159
declarations

00:23:12,400 --> 00:23:16,720
always exist so overload resolution

00:23:16,159 --> 00:23:20,880
wouldn't

00:23:16,720 --> 00:23:22,720
do the job by itself in this situation

00:23:20,880 --> 00:23:24,880
i actually i discovered that this was

00:23:22,720 --> 00:23:28,000
necessary to do because i had

00:23:24,880 --> 00:23:30,000
i had the same thought at one point and

00:23:28,000 --> 00:23:31,360
i went to write the code and i was

00:23:30,000 --> 00:23:34,960
surprised when it didn't call the

00:23:31,360 --> 00:23:34,960
function i expected it to call

00:23:35,679 --> 00:23:41,360
all right so uh replacing those global

00:23:39,440 --> 00:23:42,799
operator new and operator delete is what

00:23:41,360 --> 00:23:43,600
you would need to do if you wanted to

00:23:42,799 --> 00:23:45,440
write a

00:23:43,600 --> 00:23:48,000
general purpose memory manager that

00:23:45,440 --> 00:23:49,520
could handle memory requests across the

00:23:48,000 --> 00:23:52,559
whole program

00:23:49,520 --> 00:23:54,640
you can do that but that is kind of a

00:23:52,559 --> 00:23:57,919
challenging thing to do

00:23:54,640 --> 00:23:59,679
and also have it fit within the

00:23:57,919 --> 00:24:01,520
performance requirements that we have

00:23:59,679 --> 00:24:03,520
for embedded systems

00:24:01,520 --> 00:24:04,960
because it needs to be able to handle

00:24:03,520 --> 00:24:08,159
memory requests of all the

00:24:04,960 --> 00:24:10,000
all kinds of different sizes and one of

00:24:08,159 --> 00:24:11,600
the reasons that the default

00:24:10,000 --> 00:24:13,200
they didn't choose to make the default

00:24:11,600 --> 00:24:16,640
memory allocator

00:24:13,200 --> 00:24:19,679
slow just because they wound up

00:24:16,640 --> 00:24:20,159
the algorithm that's used for the global

00:24:19,679 --> 00:24:23,600
memory

00:24:20,159 --> 00:24:25,840
for the default memory allocator is slow

00:24:23,600 --> 00:24:27,039
because it has to take into account the

00:24:25,840 --> 00:24:30,840
possibility

00:24:27,039 --> 00:24:32,000
that it could be allocating any size of

00:24:30,840 --> 00:24:34,960
object

00:24:32,000 --> 00:24:37,120
can you mark some of the delete new

00:24:34,960 --> 00:24:39,279
operators with equal delete to prevent

00:24:37,120 --> 00:24:43,039
the compiler from using them

00:24:39,279 --> 00:24:48,240
and force the versions that you like

00:24:43,039 --> 00:24:51,279
uh i believe when i tried that

00:24:48,240 --> 00:24:52,720
i found the compiler generated code that

00:24:51,279 --> 00:24:54,000
the compiler would generate complaints

00:24:52,720 --> 00:24:55,760
that said

00:24:54,000 --> 00:24:57,279
the operator delete i'm trying to call

00:24:55,760 --> 00:25:00,480
here is deleted

00:24:57,279 --> 00:25:01,520
not oh i noticed that that operator

00:25:00,480 --> 00:25:03,440
delete is

00:25:01,520 --> 00:25:05,440
is a deleted function and i'll call a

00:25:03,440 --> 00:25:08,720
different form of delete

00:25:05,440 --> 00:25:09,760
um but i'll admit that i did this some

00:25:08,720 --> 00:25:14,880
time ago

00:25:09,760 --> 00:25:19,039
my memory is a little worried about that

00:25:14,880 --> 00:25:21,200
all right so if you are going to

00:25:19,039 --> 00:25:22,960
try and get a global memory manager

00:25:21,200 --> 00:25:23,600
suitable for embedded systems up and

00:25:22,960 --> 00:25:25,279
running

00:25:23,600 --> 00:25:26,960
there are people who make these things

00:25:25,279 --> 00:25:27,840
professionally and that's something you

00:25:26,960 --> 00:25:30,320
might want to look

00:25:27,840 --> 00:25:31,600
into before you actually go ahead and

00:25:30,320 --> 00:25:34,960
write your own

00:25:31,600 --> 00:25:36,320
because they are quite complex things to

00:25:34,960 --> 00:25:39,679
write

00:25:36,320 --> 00:25:41,440
that said you might not actually need

00:25:39,679 --> 00:25:44,159
a global memory manager and here's what

00:25:41,440 --> 00:25:44,159
i mean by that

00:25:45,520 --> 00:25:50,880
in a lot of applications the dynamic

00:25:48,480 --> 00:25:52,080
memory mall locations are focused on

00:25:50,880 --> 00:25:55,279
just a few types

00:25:52,080 --> 00:25:56,159
that is you might have you might be

00:25:55,279 --> 00:25:59,279
allocating

00:25:56,159 --> 00:26:02,320
a lot of different kinds of objects

00:25:59,279 --> 00:26:05,279
but what you would see is you have

00:26:02,320 --> 00:26:06,559
two or three of type a two or three of

00:26:05,279 --> 00:26:10,080
type b

00:26:06,559 --> 00:26:10,640
and then a million of type c that's not

00:26:10,080 --> 00:26:13,760
it's not

00:26:10,640 --> 00:26:16,159
uncommon for to see that

00:26:13,760 --> 00:26:17,520
in an application most of the dynamic

00:26:16,159 --> 00:26:21,520
allocations are done

00:26:17,520 --> 00:26:24,240
for just a few types and so

00:26:21,520 --> 00:26:24,720
if you can write a memory allocator that

00:26:24,240 --> 00:26:27,840
just

00:26:24,720 --> 00:26:28,640
works for those specific types that you

00:26:27,840 --> 00:26:33,039
allocate

00:26:28,640 --> 00:26:35,679
frequently you can get a lot of the

00:26:33,039 --> 00:26:36,840
benefits that you would that you would

00:26:35,679 --> 00:26:40,240
get out of

00:26:36,840 --> 00:26:42,000
a global member out of replacing

00:26:40,240 --> 00:26:44,000
a global memory allocator but without

00:26:42,000 --> 00:26:45,840
the complexity of necessarily having to

00:26:44,000 --> 00:26:49,039
handle requests for

00:26:45,840 --> 00:26:51,200
memory of any size things like that

00:26:49,039 --> 00:26:52,400
and you can either and then for the

00:26:51,200 --> 00:26:54,400
other types that you're not worried

00:26:52,400 --> 00:26:56,159
about you could either

00:26:54,400 --> 00:26:58,080
fall back on the default memory

00:26:56,159 --> 00:27:00,320
allocator or

00:26:58,080 --> 00:27:01,520
you if you're writing an embedded system

00:27:00,320 --> 00:27:03,120
you could just

00:27:01,520 --> 00:27:05,360
deal with those the same way that we

00:27:03,120 --> 00:27:07,679
typically deal with objects that we

00:27:05,360 --> 00:27:08,559
would like to dynamically allocate but

00:27:07,679 --> 00:27:10,960
can't

00:27:08,559 --> 00:27:12,080
in an embedded system and make them

00:27:10,960 --> 00:27:14,559
global

00:27:12,080 --> 00:27:16,320
uh allocate them statically somehow

00:27:14,559 --> 00:27:18,159
things like that

00:27:16,320 --> 00:27:19,760
and turns out there's actually a really

00:27:18,159 --> 00:27:23,360
nice simple way in c

00:27:19,760 --> 00:27:26,320
plus plus to replace the app

00:27:23,360 --> 00:27:28,399
new and delete for specific types

00:27:26,320 --> 00:27:31,039
without doing anything to affect how new

00:27:28,399 --> 00:27:33,840
and delayed work for other types

00:27:31,039 --> 00:27:35,760
you can declare new and delete as

00:27:33,840 --> 00:27:38,880
members of a class

00:27:35,760 --> 00:27:42,480
like this is the type

00:27:38,880 --> 00:27:45,760
of object or the size of object

00:27:42,480 --> 00:27:47,520
uh that is of concern is it the type of

00:27:45,760 --> 00:27:49,679
object or the size of the object that's

00:27:47,520 --> 00:27:54,159
of concern

00:27:49,679 --> 00:27:57,919
um it depends on what you mean

00:27:54,159 --> 00:28:00,480
i'm not entirely sure so

00:27:57,919 --> 00:28:01,919
when you replace operator new and delete

00:28:00,480 --> 00:28:03,120
when you write them as class members

00:28:01,919 --> 00:28:06,799
you're writing them

00:28:03,120 --> 00:28:09,679
for a specific class so

00:28:06,799 --> 00:28:11,520
they really will work only on that one

00:28:09,679 --> 00:28:14,880
class type

00:28:11,520 --> 00:28:17,600
now they're the objects of

00:28:14,880 --> 00:28:18,880
type t are always going to be the same

00:28:17,600 --> 00:28:22,559
size

00:28:18,880 --> 00:28:25,440
so what you could do is that

00:28:22,559 --> 00:28:26,799
you could if you have if it turns out

00:28:25,440 --> 00:28:29,200
that objects of type t

00:28:26,799 --> 00:28:30,080
and type u and type v are all of the

00:28:29,200 --> 00:28:34,000
same

00:28:30,080 --> 00:28:37,520
the same size you could write it so that

00:28:34,000 --> 00:28:41,600
the class specific new and delete

00:28:37,520 --> 00:28:44,480
for t and u and v all pull from the same

00:28:41,600 --> 00:28:48,240
memory source on the back end

00:28:44,480 --> 00:28:51,279
but um so that that is

00:28:48,240 --> 00:28:53,440
a technique that you can use

00:28:51,279 --> 00:28:54,799
um i'm just going to show it to you for

00:28:53,440 --> 00:28:57,840
one type and

00:28:54,799 --> 00:28:58,480
but it's relatively easy to generalize

00:28:57,840 --> 00:29:01,760
for

00:28:58,480 --> 00:29:03,760
other to use the same pool for several

00:29:01,760 --> 00:29:06,080
types

00:29:03,760 --> 00:29:06,080
okay

00:29:07,440 --> 00:29:10,960
jay malloy could tc mount implement new

00:29:10,240 --> 00:29:14,640
with a

00:29:10,960 --> 00:29:16,640
hierarchy of memory pools to minimize

00:29:14,640 --> 00:29:19,760
fragmentation and improved allocation

00:29:16,640 --> 00:29:23,200
speed are there gotchas that render them

00:29:19,760 --> 00:29:26,559
inappropriate for embedded systems uh

00:29:23,200 --> 00:29:27,600
i'm not familiar with those specific

00:29:26,559 --> 00:29:31,440
functions

00:29:27,600 --> 00:29:34,880
um so i have not

00:29:31,440 --> 00:29:34,880
seen them uh

00:29:35,279 --> 00:29:38,399
i haven't tried using them in embedded

00:29:36,960 --> 00:29:41,840
systems so i'm not sure

00:29:38,399 --> 00:29:41,840
how they would perform

00:29:42,559 --> 00:29:47,279
in general my understanding is that if

00:29:45,120 --> 00:29:47,279
you

00:29:47,600 --> 00:29:51,360
is that when you are allocating from

00:29:49,039 --> 00:29:54,720
multiple different pools

00:29:51,360 --> 00:29:56,880
not avoiding all fragmentation is

00:29:54,720 --> 00:29:59,679
tends to be very difficult but i'd have

00:29:56,880 --> 00:30:03,760
to look at the specific algorithm here

00:29:59,679 --> 00:30:05,360
uh if you were to derive a class from t

00:30:03,760 --> 00:30:07,440
should the derived class implement

00:30:05,360 --> 00:30:11,120
operator new and upgrade

00:30:07,440 --> 00:30:14,320
delete um it doesn't

00:30:11,120 --> 00:30:17,039
need to but it can uh

00:30:14,320 --> 00:30:17,600
if you and often i think it would it

00:30:17,039 --> 00:30:21,039
would

00:30:17,600 --> 00:30:24,640
usually when i create a derived class

00:30:21,039 --> 00:30:25,679
from something i almost always find that

00:30:24,640 --> 00:30:28,320
i'm adding

00:30:25,679 --> 00:30:30,000
data members in the leaf classes of the

00:30:28,320 --> 00:30:31,919
hierarchy that is the

00:30:30,000 --> 00:30:35,440
derived classes that don't themselves

00:30:31,919 --> 00:30:35,440
have any other derived classes

00:30:35,600 --> 00:30:39,360
usually that's where i find i put my

00:30:37,200 --> 00:30:41,120
data members which means that the size

00:30:39,360 --> 00:30:43,679
of a derived object is not going to be

00:30:41,120 --> 00:30:46,799
the same as the size of a base object

00:30:43,679 --> 00:30:49,520
in which case uh yeah

00:30:46,799 --> 00:30:51,760
the amount of memory you would need for

00:30:49,520 --> 00:30:53,760
a derived object would be different from

00:30:51,760 --> 00:30:55,279
the amount of memory that you need for a

00:30:53,760 --> 00:30:58,000
base class object

00:30:55,279 --> 00:30:59,360
but you could write the the operator new

00:30:58,000 --> 00:31:02,000
for a base class

00:30:59,360 --> 00:31:02,799
to simply allocate a size that's

00:31:02,000 --> 00:31:05,200
suitable for

00:31:02,799 --> 00:31:07,120
any of its derived class types for

00:31:05,200 --> 00:31:10,320
example

00:31:07,120 --> 00:31:12,080
all right uh so you can write

00:31:10,320 --> 00:31:14,080
operator new and operator delete as

00:31:12,080 --> 00:31:15,600
class members like this these have the

00:31:14,080 --> 00:31:17,919
same signatures as

00:31:15,600 --> 00:31:19,760
the global operator new and delete we

00:31:17,919 --> 00:31:22,880
saw before

00:31:19,760 --> 00:31:25,919
and what this does is

00:31:22,880 --> 00:31:29,360
when you write new t

00:31:25,919 --> 00:31:34,000
the compiler first checks to c

00:31:29,360 --> 00:31:37,039
is ta class type that has

00:31:34,000 --> 00:31:37,760
a overloaded operator new and operator

00:31:37,039 --> 00:31:40,799
delete

00:31:37,760 --> 00:31:43,919
specific for that class type

00:31:40,799 --> 00:31:46,720
if it is use the class specific

00:31:43,919 --> 00:31:49,120
versions of new and delete rather than

00:31:46,720 --> 00:31:50,880
the global versions

00:31:49,120 --> 00:31:52,640
for all other types that don't have

00:31:50,880 --> 00:31:56,399
class specific new and delete

00:31:52,640 --> 00:32:01,519
operators just use the global ones

00:31:56,399 --> 00:32:04,799
the rest of it's unaffected okay um

00:32:01,519 --> 00:32:05,519
yeah is there a way to defragment the

00:32:04,799 --> 00:32:09,039
existing

00:32:05,519 --> 00:32:09,039
objects on the heap

00:32:10,320 --> 00:32:14,240
my understanding is that that's

00:32:12,960 --> 00:32:17,519
complicated

00:32:14,240 --> 00:32:19,440
because it's tricky

00:32:17,519 --> 00:32:20,880
in most situations because you can't

00:32:19,440 --> 00:32:22,240
move any of the objects

00:32:20,880 --> 00:32:25,519
any of the memory that's actually being

00:32:22,240 --> 00:32:29,279
used um i can explain that a little bit

00:32:25,519 --> 00:32:32,320
more uh at the end uh but

00:32:29,279 --> 00:32:33,120
yeah that's i'm not gonna say it's

00:32:32,320 --> 00:32:37,519
impossible

00:32:33,120 --> 00:32:40,840
but i haven't seen it done

00:32:37,519 --> 00:32:44,320
um if custom operator knew

00:32:40,840 --> 00:32:47,519
received arena allocator

00:32:44,320 --> 00:32:50,399
as argument how can i

00:32:47,519 --> 00:32:53,120
pass the same allocator to corresponding

00:32:50,399 --> 00:32:53,120
delete

00:32:53,279 --> 00:32:59,760
i'm sorry i'm not i'm not sure what

00:32:56,320 --> 00:33:01,440
arena allocator means

00:32:59,760 --> 00:33:02,880
i think that this that the answer to

00:33:01,440 --> 00:33:06,080
this question may come up

00:33:02,880 --> 00:33:09,919
a little later though so um

00:33:06,080 --> 00:33:12,159
i'm gonna proceed on for right now and

00:33:09,919 --> 00:33:12,159
uh

00:33:12,480 --> 00:33:17,519
and maybe that question will come

00:33:15,840 --> 00:33:19,600
does does the polymorphic memory

00:33:17,519 --> 00:33:22,880
allocator help with any of this

00:33:19,600 --> 00:33:24,559
uh the or the standard polymorphic

00:33:22,880 --> 00:33:26,799
memory resource

00:33:24,559 --> 00:33:26,799
um

00:33:28,080 --> 00:33:35,279
let me think uh the polymorphic

00:33:32,640 --> 00:33:36,640
memory resource i believe that that's

00:33:35,279 --> 00:33:39,760
actually a different

00:33:36,640 --> 00:33:43,120
level i want to say that

00:33:39,760 --> 00:33:46,799
uh that you could use the pmr stuff to

00:33:43,120 --> 00:33:48,799
implement uh

00:33:46,799 --> 00:33:50,000
new and delete but let me think about

00:33:48,799 --> 00:33:51,600
that

00:33:50,000 --> 00:33:53,120
it's been a while since i've i've done

00:33:51,600 --> 00:33:56,640
anything looking at

00:33:53,120 --> 00:34:01,120
the the pmr resources so

00:33:56,640 --> 00:34:03,200
i would have to think about that uh

00:34:01,120 --> 00:34:04,159
but my understanding is that that's

00:34:03,200 --> 00:34:07,519
designed

00:34:04,159 --> 00:34:11,440
to solve a somewhat different problem

00:34:07,519 --> 00:34:14,960
of i want to have

00:34:11,440 --> 00:34:17,280
many objects of the same class type

00:34:14,960 --> 00:34:19,440
and i want to be able to use different

00:34:17,280 --> 00:34:22,639
kinds of allocators with them

00:34:19,440 --> 00:34:24,240
as opposed to baking the allocator into

00:34:22,639 --> 00:34:27,839
the type the way that we do for

00:34:24,240 --> 00:34:27,839
stl container classes

00:34:28,720 --> 00:34:36,320
okay so when you declare

00:34:32,399 --> 00:34:38,079
operator new and delete as class members

00:34:36,320 --> 00:34:39,839
they automatically become static member

00:34:38,079 --> 00:34:40,639
functions doesn't matter whether you use

00:34:39,839 --> 00:34:43,919
the keyword

00:34:40,639 --> 00:34:46,159
static to declare them or not

00:34:43,919 --> 00:34:48,560
they're just they are static member

00:34:46,159 --> 00:34:50,320
functions they have to be

00:34:48,560 --> 00:34:51,760
which means they can't be virtual

00:34:50,320 --> 00:34:53,679
functions because

00:34:51,760 --> 00:34:55,359
as static member functions they haven't

00:34:53,679 --> 00:34:57,760
know this pointer

00:34:55,359 --> 00:34:59,280
and the this pointer is how a virtual

00:34:57,760 --> 00:35:03,119
function knows

00:34:59,280 --> 00:35:05,200
what type it's actually being invoked on

00:35:03,119 --> 00:35:06,480
in relation to my previous question of

00:35:05,200 --> 00:35:10,320
derived class

00:35:06,480 --> 00:35:11,119
from class t if the derived class has

00:35:10,320 --> 00:35:13,839
its own

00:35:11,119 --> 00:35:14,160
new and delete should they in turn call

00:35:13,839 --> 00:35:18,240
the

00:35:14,160 --> 00:35:20,720
base class t is new and delete

00:35:18,240 --> 00:35:23,440
i wouldn't think so because i would

00:35:20,720 --> 00:35:23,440
think that the

00:35:24,640 --> 00:35:29,200
the memory for an object before a

00:35:27,359 --> 00:35:30,000
derived class object is typically going

00:35:29,200 --> 00:35:33,200
to be allocated

00:35:30,000 --> 00:35:34,800
in one chunk that would include the base

00:35:33,200 --> 00:35:37,280
class sub-object

00:35:34,800 --> 00:35:39,760
as well as all of the other data members

00:35:37,280 --> 00:35:42,160
added by the derived class

00:35:39,760 --> 00:35:42,880
so i would think that you would just be

00:35:42,160 --> 00:35:45,280
allocating

00:35:42,880 --> 00:35:46,400
one chunk of memory for both the base

00:35:45,280 --> 00:35:49,599
class sub-object

00:35:46,400 --> 00:35:52,160
and the additional data members

00:35:49,599 --> 00:35:54,079
rather than calling the base classes

00:35:52,160 --> 00:35:58,000
operator new

00:35:54,079 --> 00:35:59,599
but not to say that you absolutely

00:35:58,000 --> 00:36:02,160
couldn't just i can't think of a reason

00:35:59,599 --> 00:36:05,280
why you would

00:36:02,160 --> 00:36:07,599
all right so what do we actually do

00:36:05,280 --> 00:36:09,040
with those operator new induits we can't

00:36:07,599 --> 00:36:11,760
now that i've told you that we can

00:36:09,040 --> 00:36:14,720
provide them on a class specific basis

00:36:11,760 --> 00:36:15,680
how do we write class specific operator

00:36:14,720 --> 00:36:17,760
new and delete

00:36:15,680 --> 00:36:19,280
in a way that are suitable for use in

00:36:17,760 --> 00:36:23,040
embedded systems

00:36:19,280 --> 00:36:23,839
so uh the basic strategy that you often

00:36:23,040 --> 00:36:27,200
see employed

00:36:23,839 --> 00:36:29,359
is to reserve a number of

00:36:27,200 --> 00:36:30,960
memory blocks ahead of time essentially

00:36:29,359 --> 00:36:34,640
at compile time

00:36:30,960 --> 00:36:38,079
uh so at uh static memory

00:36:34,640 --> 00:36:39,920
uh or static allocation each memory

00:36:38,079 --> 00:36:42,640
block is suitable to hold a single

00:36:39,920 --> 00:36:45,839
object of type t

00:36:42,640 --> 00:36:48,800
um and then those blocks are

00:36:45,839 --> 00:36:50,160
organized into a linked list i'll show

00:36:48,800 --> 00:36:50,960
you exactly how this is done in just a

00:36:50,160 --> 00:36:54,160
moment but

00:36:50,960 --> 00:36:56,320
the idea is that operator new takes the

00:36:54,160 --> 00:36:59,040
the first block of memory off of that

00:36:56,320 --> 00:37:01,440
list and uses that as the memory

00:36:59,040 --> 00:37:03,680
to hold the to hold a t object that you

00:37:01,440 --> 00:37:06,240
just allocated memory for

00:37:03,680 --> 00:37:08,320
and then delete just takes that block of

00:37:06,240 --> 00:37:09,359
memory and returns it onto the front of

00:37:08,320 --> 00:37:13,040
the list

00:37:09,359 --> 00:37:17,520
and now it becomes and now it's again

00:37:13,040 --> 00:37:20,400
free for use by uh

00:37:17,520 --> 00:37:23,280
by any other t object t object that

00:37:20,400 --> 00:37:25,680
needs to allocate memory

00:37:23,280 --> 00:37:27,359
so the way that this works it actually

00:37:25,680 --> 00:37:28,800
solves a lot of the problems i talked

00:37:27,359 --> 00:37:30,960
about earlier with the

00:37:28,800 --> 00:37:31,839
general dynamic memory management it

00:37:30,960 --> 00:37:34,160
winds up being

00:37:31,839 --> 00:37:36,480
fast because allocation and

00:37:34,160 --> 00:37:38,000
de-allocation are basically linked list

00:37:36,480 --> 00:37:40,800
operations they both

00:37:38,000 --> 00:37:42,079
involve only a small number of pointer

00:37:40,800 --> 00:37:44,400
operations to

00:37:42,079 --> 00:37:47,440
take a block off the list or move a

00:37:44,400 --> 00:37:50,800
block back onto the list

00:37:47,440 --> 00:37:52,400
it's deterministic because the the worst

00:37:50,800 --> 00:37:53,520
case run time is constant there are only

00:37:52,400 --> 00:37:56,240
two cases

00:37:53,520 --> 00:37:58,079
uh either there's memory available in

00:37:56,240 --> 00:38:00,640
which case you take the first block

00:37:58,079 --> 00:38:01,119
because all the blocks of the same size

00:38:00,640 --> 00:38:03,520
they're all

00:38:01,119 --> 00:38:05,280
equally good matches for the size of

00:38:03,520 --> 00:38:07,440
memory you're being asked for

00:38:05,280 --> 00:38:08,320
or there's no memory available in which

00:38:07,440 --> 00:38:11,839
case you've

00:38:08,320 --> 00:38:14,800
returned false return failure

00:38:11,839 --> 00:38:16,320
uh memory fragmentation isn't a problem

00:38:14,800 --> 00:38:20,720
because the blocks are all the same

00:38:16,320 --> 00:38:22,880
size so uh

00:38:20,720 --> 00:38:24,560
there's no risk that you that by pulling

00:38:22,880 --> 00:38:26,079
a little bit here and a little bit here

00:38:24,560 --> 00:38:27,280
and a little bit here you'll wind up

00:38:26,079 --> 00:38:29,520
with

00:38:27,280 --> 00:38:31,280
memory broken into small chunks that

00:38:29,520 --> 00:38:35,520
none of which can actually hold a t

00:38:31,280 --> 00:38:38,880
object okay

00:38:35,520 --> 00:38:42,800
um so we would implement it in

00:38:38,880 --> 00:38:46,000
a way like this where we'd use uh

00:38:42,800 --> 00:38:49,040
this union type available block

00:38:46,000 --> 00:38:51,839
where each available block has two mem

00:38:49,040 --> 00:38:54,160
has well one of two members either a

00:38:51,839 --> 00:38:58,160
pointer to the next available block

00:38:54,160 --> 00:38:58,800
or an amount of memory that is the size

00:38:58,160 --> 00:39:02,720
of that

00:38:58,800 --> 00:39:05,520
block and really the the memory

00:39:02,720 --> 00:39:08,240
is what we're going is only there to

00:39:05,520 --> 00:39:09,920
ensure that each block is large enough

00:39:08,240 --> 00:39:12,000
basically when when the block is

00:39:09,920 --> 00:39:15,040
available we care about the

00:39:12,000 --> 00:39:16,960
next pointer when the block is in use we

00:39:15,040 --> 00:39:17,760
care about the size of this memory being

00:39:16,960 --> 00:39:21,680
large enough

00:39:17,760 --> 00:39:25,680
to hold a t object so

00:39:21,680 --> 00:39:28,000
um we want to once we've created

00:39:25,680 --> 00:39:29,359
that block type we then need to set up

00:39:28,000 --> 00:39:32,560
all the blocks of the bay

00:39:29,359 --> 00:39:35,599
formal linked list and

00:39:32,560 --> 00:39:39,040
we can do that by placing those blocks

00:39:35,599 --> 00:39:40,400
in this struct avail list and writing a

00:39:39,040 --> 00:39:42,480
constructor

00:39:40,400 --> 00:39:44,400
that assembles all that causes each

00:39:42,480 --> 00:39:47,920
block to point to the next block

00:39:44,400 --> 00:39:52,240
so inside the availalist constructor

00:39:47,920 --> 00:39:54,240
it just goes through the list of blocks

00:39:52,240 --> 00:39:55,280
makes each block point to the next block

00:39:54,240 --> 00:39:58,320
the i plus

00:39:55,280 --> 00:40:01,440
one block and then

00:39:58,320 --> 00:40:04,319
at the very end there's the last block

00:40:01,440 --> 00:40:07,680
points to null at that point we're out

00:40:04,319 --> 00:40:09,839
of memory blocks to align

00:40:07,680 --> 00:40:10,800
and so we would if we use this to

00:40:09,839 --> 00:40:12,960
allocate

00:40:10,800 --> 00:40:13,920
or to implement an operator new for a

00:40:12,960 --> 00:40:16,240
type t

00:40:13,920 --> 00:40:18,960
it might look something like this we'd

00:40:16,240 --> 00:40:20,240
have the avail list declared as a static

00:40:18,960 --> 00:40:23,520
object

00:40:20,240 --> 00:40:25,920
it's called t list here

00:40:23,520 --> 00:40:26,960
what operator new would do is pull the

00:40:25,920 --> 00:40:29,359
fir is

00:40:26,960 --> 00:40:31,119
look at the head of the list of

00:40:29,359 --> 00:40:33,440
available blocks

00:40:31,119 --> 00:40:35,920
find it is if that pointer is null

00:40:33,440 --> 00:40:38,240
meaning there are no available blocks

00:40:35,920 --> 00:40:39,359
or and this is just a safety check to

00:40:38,240 --> 00:40:41,920
make sure

00:40:39,359 --> 00:40:42,480
that we're not allocating an object of

00:40:41,920 --> 00:40:46,000
the wrong

00:40:42,480 --> 00:40:47,760
size somehow uh the compiler should

00:40:46,000 --> 00:40:48,560
protect us against this but this is just

00:40:47,760 --> 00:40:51,359
a

00:40:48,560 --> 00:40:52,400
a safety check that we can't have in

00:40:51,359 --> 00:40:54,480
here

00:40:52,400 --> 00:40:56,240
if either of those conditions isn't met

00:40:54,480 --> 00:40:56,560
throw bad aloe and again we'll talk

00:40:56,240 --> 00:41:00,640
about

00:40:56,560 --> 00:41:04,319
other forms of failure that could

00:41:00,640 --> 00:41:06,960
come up later on uh

00:41:04,319 --> 00:41:08,720
but if not if these aren't the case then

00:41:06,960 --> 00:41:09,440
we can successfully allocate the memory

00:41:08,720 --> 00:41:12,800
so

00:41:09,440 --> 00:41:16,800
take the head pointer off of the

00:41:12,800 --> 00:41:19,359
uh remove the head of the list and

00:41:16,800 --> 00:41:20,240
go back to it and return the pointer

00:41:19,359 --> 00:41:23,520
that we just got

00:41:20,240 --> 00:41:26,079
the first block off the list as

00:41:23,520 --> 00:41:28,000
the place to construct the object of

00:41:26,079 --> 00:41:29,520
type t

00:41:28,000 --> 00:41:32,160
and then the corresponding operator

00:41:29,520 --> 00:41:35,440
delete first checks to see

00:41:32,160 --> 00:41:39,200
is the pointer null if so just return

00:41:35,440 --> 00:41:40,880
deleting null does nothing otherwise

00:41:39,200 --> 00:41:42,319
convert the pointer that we got the

00:41:40,880 --> 00:41:47,520
pointer to void

00:41:42,319 --> 00:41:51,280
into a pointer to an available lock here

00:41:47,520 --> 00:41:54,319
and put it back on the front of the list

00:41:51,280 --> 00:41:55,520
uh set it up so that it points to the

00:41:54,319 --> 00:41:59,119
it points to the current head of the

00:41:55,520 --> 00:41:59,119
list and then it becomes the new head

00:42:00,480 --> 00:42:05,280
now on paper that whole that

00:42:04,000 --> 00:42:06,319
implementation there looks like it

00:42:05,280 --> 00:42:08,000
should work

00:42:06,319 --> 00:42:09,599
but it's actually more complicated than

00:42:08,000 --> 00:42:12,560
that because we need to consider

00:42:09,599 --> 00:42:14,640
the problem of storage alignment so

00:42:12,560 --> 00:42:17,599
types in c and c plus plus have

00:42:14,640 --> 00:42:19,040
alignment restrictions that require them

00:42:17,599 --> 00:42:23,440
to be allocated on

00:42:19,040 --> 00:42:26,079
certain memory boundaries so

00:42:23,440 --> 00:42:27,359
uh a lot of platforms ants have to be

00:42:26,079 --> 00:42:29,839
allocated on

00:42:27,359 --> 00:42:30,560
four byte boundaries doubles have to be

00:42:29,839 --> 00:42:34,000
allocated

00:42:30,560 --> 00:42:36,079
on eight byte boundaries these alignment

00:42:34,000 --> 00:42:40,960
restrictions depend on your specific

00:42:36,079 --> 00:42:44,640
platform so um

00:42:40,960 --> 00:42:46,480
so you don't

00:42:44,640 --> 00:42:48,240
these aren't guaranteed and it might

00:42:46,480 --> 00:42:49,920
have on it might require eight byte

00:42:48,240 --> 00:42:50,720
alignment it might require only two byte

00:42:49,920 --> 00:42:53,280
alignment

00:42:50,720 --> 00:42:55,119
depends on the platform but what but

00:42:53,280 --> 00:42:58,079
your platform very likely has

00:42:55,119 --> 00:42:58,800
some restrictions on the on these and if

00:42:58,079 --> 00:43:01,520
you

00:42:58,800 --> 00:43:03,280
create an object allocated without the

00:43:01,520 --> 00:43:05,040
proper alignment

00:43:03,280 --> 00:43:08,079
the result is generally under is

00:43:05,040 --> 00:43:08,079
undefined behavior

00:43:10,079 --> 00:43:13,839
all right

00:43:15,760 --> 00:43:21,119
come on so

00:43:19,040 --> 00:43:22,560
uh before modern c plus plus there

00:43:21,119 --> 00:43:24,960
wasn't really a portable

00:43:22,560 --> 00:43:26,079
way to determine the alignment

00:43:24,960 --> 00:43:30,160
restriction of a type

00:43:26,079 --> 00:43:32,160
so usually the solution to this was to

00:43:30,160 --> 00:43:33,280
play it was to include types with very

00:43:32,160 --> 00:43:35,359
strict alignments

00:43:33,280 --> 00:43:37,119
in the union that represented an

00:43:35,359 --> 00:43:40,560
individual memory block

00:43:37,119 --> 00:43:44,240
the idea was this union then has to have

00:43:40,560 --> 00:43:46,880
alignment as strict as those types

00:43:44,240 --> 00:43:48,560
so we'll throw in the types that we can

00:43:46,880 --> 00:43:50,000
think of with fault with the most strict

00:43:48,560 --> 00:43:53,040
alignment and

00:43:50,000 --> 00:43:56,400
that'll probably work and usually it did

00:43:53,040 --> 00:43:56,400
but it wasn't guaranteed

00:44:00,720 --> 00:44:07,520
now in modern c plus we

00:44:04,880 --> 00:44:08,079
the expression a line of t can be used

00:44:07,520 --> 00:44:12,160
to determine

00:44:08,079 --> 00:44:16,000
the alignment restriction of

00:44:12,160 --> 00:44:19,359
uh of the type t of a type t

00:44:16,000 --> 00:44:22,400
as a number of bytes so a line

00:44:19,359 --> 00:44:22,800
so you can also you can use this a line

00:44:22,400 --> 00:44:24,480
of t

00:44:22,800 --> 00:44:26,319
to get to get the number of bytes of

00:44:24,480 --> 00:44:28,160
alignment that something needs

00:44:26,319 --> 00:44:30,079
and then you can declare an object with

00:44:28,160 --> 00:44:33,839
a line as

00:44:30,079 --> 00:44:37,359
to say align this value so that it

00:44:33,839 --> 00:44:38,960
is as so that it has this alignment

00:44:37,359 --> 00:44:40,720
restriction

00:44:38,960 --> 00:44:43,760
the same alignment restriction as an

00:44:40,720 --> 00:44:46,400
object of type t here in this case

00:44:43,760 --> 00:44:48,640
this makes sure that our available list

00:44:46,400 --> 00:44:51,200
blocks are always aligned in such a way

00:44:48,640 --> 00:44:55,359
that they will work for type t

00:44:51,200 --> 00:44:58,560
so um question is overriding

00:44:55,359 --> 00:44:59,839
the member function new hostile to the

00:44:58,560 --> 00:45:04,240
standard library

00:44:59,839 --> 00:45:07,520
allocator model uh

00:45:04,240 --> 00:45:10,800
the standard library a locator

00:45:07,520 --> 00:45:10,800
is uh

00:45:13,050 --> 00:45:19,839
[Music]

00:45:14,480 --> 00:45:19,839
i'm trying to so

00:45:20,240 --> 00:45:26,800
if you wanted to use this system

00:45:23,760 --> 00:45:28,720
with the stl containers

00:45:26,800 --> 00:45:30,800
uh i would expect that you'd have to

00:45:28,720 --> 00:45:32,640
write not just the operator new and

00:45:30,800 --> 00:45:35,760
operator delete but also

00:45:32,640 --> 00:45:39,680
uh a an

00:45:35,760 --> 00:45:41,359
allocator that specifically used

00:45:39,680 --> 00:45:44,160
that could specifically deal with those

00:45:41,359 --> 00:45:47,119
types uh i believe when i've looked

00:45:44,160 --> 00:45:48,079
at the general purpose default allocator

00:45:47,119 --> 00:45:52,079
before

00:45:48,079 --> 00:45:52,079
it was um

00:45:54,400 --> 00:45:58,079
i believe it uses member functions

00:45:56,480 --> 00:45:59,359
internally to do with names like

00:45:58,079 --> 00:46:02,400
construct

00:45:59,359 --> 00:46:06,160
and allocate instead of

00:46:02,400 --> 00:46:08,240
new uh so i don't think it would cause a

00:46:06,160 --> 00:46:12,160
problem with that

00:46:08,240 --> 00:46:12,880
but uh i will try and check on that for

00:46:12,160 --> 00:46:15,520
you if you

00:46:12,880 --> 00:46:16,319
if you come and see me after the talk

00:46:15,520 --> 00:46:20,560
should that be a

00:46:16,319 --> 00:46:24,000
reinterpret cast on slide 35 rather than

00:46:20,560 --> 00:46:26,160
a a static cast

00:46:24,000 --> 00:46:29,040
usually converting between pointer types

00:46:26,160 --> 00:46:31,680
is a reinterpret cast but you can turn

00:46:29,040 --> 00:46:32,079
a pointer to a void into a pointer to

00:46:31,680 --> 00:46:35,599
some

00:46:32,079 --> 00:46:37,520
other uh pointer type using a static

00:46:35,599 --> 00:46:41,119
cast

00:46:37,520 --> 00:46:43,839
that has that has a slightly different

00:46:41,119 --> 00:46:43,839
uh rule

00:46:44,880 --> 00:46:49,839
okay uh so you can we can use this

00:46:48,400 --> 00:46:51,599
approach to

00:46:49,839 --> 00:46:53,520
make sure that our memory is properly

00:46:51,599 --> 00:46:55,200
aligned for objects of type t

00:46:53,520 --> 00:46:56,640
or actually we can just you can just

00:46:55,200 --> 00:47:00,240
give a line as

00:46:56,640 --> 00:47:03,359
the name of a type and

00:47:00,240 --> 00:47:04,800
write it this way instead either way our

00:47:03,359 --> 00:47:07,599
available blocks should now

00:47:04,800 --> 00:47:09,119
be aligned in such a way that we can

00:47:07,599 --> 00:47:13,119
that they can properly store t

00:47:09,119 --> 00:47:16,160
objects so

00:47:13,119 --> 00:47:18,160
there's also operator new

00:47:16,160 --> 00:47:19,599
and operator delete are actually not

00:47:18,160 --> 00:47:22,160
used when you allocate

00:47:19,599 --> 00:47:22,640
arrays like this there's a separate

00:47:22,160 --> 00:47:25,119
function

00:47:22,640 --> 00:47:25,920
operator new square bracket and a

00:47:25,119 --> 00:47:28,800
corresponding

00:47:25,920 --> 00:47:29,200
operator delete square bracket that get

00:47:28,800 --> 00:47:32,800
called

00:47:29,200 --> 00:47:34,160
in this case instead so

00:47:32,800 --> 00:47:35,760
this expression is actually going to

00:47:34,160 --> 00:47:36,720
translate into something like this where

00:47:35,760 --> 00:47:39,920
it calls

00:47:36,720 --> 00:47:40,880
operator new square bracket under the

00:47:39,920 --> 00:47:43,760
hood

00:47:40,880 --> 00:47:44,160
and then goes through each element in

00:47:43,760 --> 00:47:48,079
the

00:47:44,160 --> 00:47:48,880
newly allocated array and constructs an

00:47:48,079 --> 00:47:50,800
object

00:47:48,880 --> 00:47:52,400
in that memory again this syntax

00:47:50,800 --> 00:47:53,280
wouldn't actually work if you tried to

00:47:52,400 --> 00:47:55,599
write it

00:47:53,280 --> 00:47:56,400
but this is just an imaginary notation

00:47:55,599 --> 00:47:59,119
for

00:47:56,400 --> 00:48:00,000
what the c c plus plus compiler might be

00:47:59,119 --> 00:48:02,640
doing

00:48:00,000 --> 00:48:02,640
under the hood

00:48:03,040 --> 00:48:07,280
by the same token an array delete

00:48:05,359 --> 00:48:09,440
expression

00:48:07,280 --> 00:48:11,040
delete square bracket p translates into

00:48:09,440 --> 00:48:14,160
something that looks like this

00:48:11,040 --> 00:48:16,319
checks to c is the pointer null if not

00:48:14,160 --> 00:48:19,520
go through the entire array in reverse

00:48:16,319 --> 00:48:21,839
order destroying each element

00:48:19,520 --> 00:48:23,440
and then release the memory associated

00:48:21,839 --> 00:48:26,160
with the entire array by calling

00:48:23,440 --> 00:48:30,079
operator delete square bracket

00:48:26,160 --> 00:48:31,920
so you can also make operator new square

00:48:30,079 --> 00:48:33,520
bracket and operator delete square

00:48:31,920 --> 00:48:36,400
bracket class members

00:48:33,520 --> 00:48:39,119
just like you can make operator new and

00:48:36,400 --> 00:48:41,119
operator delete class members

00:48:39,119 --> 00:48:43,920
this is something you are allowed to do

00:48:41,119 --> 00:48:46,319
in which case an array of type t

00:48:43,920 --> 00:48:47,839
would be allocated using this operator

00:48:46,319 --> 00:48:51,200
new square bracket

00:48:47,839 --> 00:48:54,640
rather than the global one that said

00:48:51,200 --> 00:48:57,680
this is a little trickier because

00:48:54,640 --> 00:48:59,280
it's hard to this pool allocation system

00:48:57,680 --> 00:49:02,319
that i showed you

00:48:59,280 --> 00:49:05,440
works well for single objects of type t

00:49:02,319 --> 00:49:07,760
it doesn't work well for arrays

00:49:05,440 --> 00:49:08,480
because the entire array needs to fit

00:49:07,760 --> 00:49:12,800
within

00:49:08,480 --> 00:49:15,520
whatever block you choose to allocate

00:49:12,800 --> 00:49:16,960
and the standard doesn't give us any way

00:49:15,520 --> 00:49:19,440
of saying

00:49:16,960 --> 00:49:21,760
do this but only let me allocate up to

00:49:19,440 --> 00:49:24,079
10 of these things at once

00:49:21,760 --> 00:49:26,240
you have to be prepared to deal with any

00:49:24,079 --> 00:49:29,440
possible size array

00:49:26,240 --> 00:49:30,960
so it's difficult to bound operator new

00:49:29,440 --> 00:49:33,599
square bracket and operator delete

00:49:30,960 --> 00:49:35,760
square bracket for this kind of type

00:49:33,599 --> 00:49:37,680
now that said there are a lot of types

00:49:35,760 --> 00:49:38,640
that you're probably not going to

00:49:37,680 --> 00:49:42,800
allocate

00:49:38,640 --> 00:49:45,119
in arrays so for many cases what you can

00:49:42,800 --> 00:49:46,880
do is uh you can protect yourself

00:49:45,119 --> 00:49:48,559
against that by declaring

00:49:46,880 --> 00:49:49,920
operator new square bracket and operator

00:49:48,559 --> 00:49:53,359
delete square bracket as

00:49:49,920 --> 00:49:56,800
deleted functions for a type and then

00:49:53,359 --> 00:49:57,119
you won't accidentally call the operator

00:49:56,800 --> 00:49:59,839
new

00:49:57,119 --> 00:50:01,280
the global operator knew square bracket

00:49:59,839 --> 00:50:03,119
for this type

00:50:01,280 --> 00:50:04,800
when what you thought you were getting

00:50:03,119 --> 00:50:09,520
was the class specific

00:50:04,800 --> 00:50:11,599
new this should protect you against that

00:50:09,520 --> 00:50:12,559
wouldn't operator delete need to be

00:50:11,599 --> 00:50:17,280
declared

00:50:12,559 --> 00:50:17,280
virtual or is that implicit uh

00:50:18,000 --> 00:50:24,839
the the fact that your destructor is

00:50:22,559 --> 00:50:28,240
virtual takes care of that

00:50:24,839 --> 00:50:28,720
essentially um the destructor figures

00:50:28,240 --> 00:50:30,960
out

00:50:28,720 --> 00:50:31,760
which type it's it's being called on and

00:50:30,960 --> 00:50:35,839
then

00:50:31,760 --> 00:50:40,880
um behind the scenes that delete it

00:50:35,839 --> 00:50:42,720
uh it's taking care of the uh

00:50:40,880 --> 00:50:44,960
the delete according to the dynamic type

00:50:42,720 --> 00:50:48,160
of the object

00:50:44,960 --> 00:50:49,200
so uh now to go back to that earlier

00:50:48,160 --> 00:50:51,440
problem that i mentioned

00:50:49,200 --> 00:50:52,880
where we don't want to throw a bad aloe

00:50:51,440 --> 00:50:54,160
exception on an embedded system

00:50:52,880 --> 00:50:56,400
generally

00:50:54,160 --> 00:50:58,160
we want to fail in some other way

00:50:56,400 --> 00:51:01,040
because exception handling

00:50:58,160 --> 00:51:03,599
often raises significant performance

00:51:01,040 --> 00:51:07,359
concerns on embedded systems

00:51:03,599 --> 00:51:08,800
so the standard also provides us with

00:51:07,359 --> 00:51:11,839
another version of new

00:51:08,800 --> 00:51:13,280
called no throw new which is a version

00:51:11,839 --> 00:51:16,559
of operator new that takes

00:51:13,280 --> 00:51:20,559
a size t and then this object of type

00:51:16,559 --> 00:51:23,839
no throw t reference to const note pro t

00:51:20,559 --> 00:51:25,680
what's a no throw t it's a made up type

00:51:23,839 --> 00:51:27,040
of object that only exists to

00:51:25,680 --> 00:51:30,000
differentiate

00:51:27,040 --> 00:51:31,599
this operator new from the operator new

00:51:30,000 --> 00:51:35,040
that can throw

00:51:31,599 --> 00:51:36,880
and this version of new is also

00:51:35,040 --> 00:51:38,880
replaceable and it has a different

00:51:36,880 --> 00:51:40,800
required behavior

00:51:38,880 --> 00:51:42,319
return a non-null pointer to suitably

00:51:40,800 --> 00:51:46,079
aligned storage

00:51:42,319 --> 00:51:47,920
or return a null pointer so this

00:51:46,079 --> 00:51:49,599
is something that we can generally use

00:51:47,920 --> 00:51:53,359
on embedded systems a little bit

00:51:49,599 --> 00:51:55,520
more easily

00:51:53,359 --> 00:51:59,200
so the non-throwing version of operator

00:51:55,520 --> 00:52:02,319
new you write the call to it like this

00:51:59,200 --> 00:52:05,920
when i said earlier that you can pass uh

00:52:02,319 --> 00:52:08,000
arguments to operator new yourself

00:52:05,920 --> 00:52:10,000
this is what i was talking about so here

00:52:08,000 --> 00:52:13,200
this expression looks a bit odd

00:52:10,000 --> 00:52:14,480
because what's happening is we're using

00:52:13,200 --> 00:52:17,040
new

00:52:14,480 --> 00:52:19,359
stood no throw here isn't is a

00:52:17,040 --> 00:52:19,599
objective-type no-throw being passed as

00:52:19,359 --> 00:52:23,760
an

00:52:19,599 --> 00:52:26,240
argument to operator new

00:52:23,760 --> 00:52:27,760
then create a t object in the memory

00:52:26,240 --> 00:52:29,520
that we allocate

00:52:27,760 --> 00:52:30,880
and construct it by calling the

00:52:29,520 --> 00:52:33,920
constructor that takes

00:52:30,880 --> 00:52:34,559
a v the t constructor that accepts an

00:52:33,920 --> 00:52:38,400
object

00:52:34,559 --> 00:52:40,240
of whatever type v is then you just use

00:52:38,400 --> 00:52:42,160
that memory as you would and then

00:52:40,240 --> 00:52:43,920
delete the pointer when you're done with

00:52:42,160 --> 00:52:47,119
it um

00:52:43,920 --> 00:52:48,720
this version of delete is essentially

00:52:47,119 --> 00:52:50,319
is actually the same version of the

00:52:48,720 --> 00:52:51,280
doesn't have an extra argument it's the

00:52:50,319 --> 00:52:52,400
same version

00:52:51,280 --> 00:52:55,359
that we would have used with the

00:52:52,400 --> 00:52:57,520
throwing version of new and

00:52:55,359 --> 00:52:59,359
that's generally not a problem basically

00:52:57,520 --> 00:53:01,359
operator new delete needs to be written

00:52:59,359 --> 00:53:02,400
to clean up after both versions in many

00:53:01,359 --> 00:53:04,880
cases

00:53:02,400 --> 00:53:05,680
um but usually that's not a problem

00:53:04,880 --> 00:53:07,920
because

00:53:05,680 --> 00:53:09,200
the two operator news the only

00:53:07,920 --> 00:53:10,880
difference between them

00:53:09,200 --> 00:53:12,720
is the fact that they one reports

00:53:10,880 --> 00:53:15,359
failure by throwing an exception

00:53:12,720 --> 00:53:17,440
the other reports failure by returning a

00:53:15,359 --> 00:53:19,839
null pointer

00:53:17,440 --> 00:53:21,760
uh so they often have basically the same

00:53:19,839 --> 00:53:22,720
implementation underneath they both pull

00:53:21,760 --> 00:53:25,920
from the same

00:53:22,720 --> 00:53:28,480
memory pool that said it turns

00:53:25,920 --> 00:53:30,079
out there is actually a version of

00:53:28,480 --> 00:53:33,920
operator of the wheat that does

00:53:30,079 --> 00:53:36,319
take an objective type no throw t

00:53:33,920 --> 00:53:38,400
now that's a little weird because even

00:53:36,319 --> 00:53:39,920
the the version of operator delete that

00:53:38,400 --> 00:53:41,520
we had before

00:53:39,920 --> 00:53:44,079
never threw exceptions it was already

00:53:41,520 --> 00:53:46,559
declared no except

00:53:44,079 --> 00:53:48,480
so why does the standard feel the need

00:53:46,559 --> 00:53:51,760
to add this one

00:53:48,480 --> 00:53:55,040
here's what's going on so i mentioned

00:53:51,760 --> 00:53:55,839
before that a new expression translates

00:53:55,040 --> 00:53:58,160
into something

00:53:55,839 --> 00:54:00,640
like this two-step process where we call

00:53:58,160 --> 00:54:04,240
operator new to allocate the memory

00:54:00,640 --> 00:54:08,240
and then we construct an object in that

00:54:04,240 --> 00:54:13,599
memory that was allocated using the no

00:54:08,240 --> 00:54:13,599
throw operator new like we do back here

00:54:13,680 --> 00:54:18,319
that ensures that step one here can't

00:54:16,720 --> 00:54:20,400
throw exception

00:54:18,319 --> 00:54:21,760
being out of memory doesn't cause us to

00:54:20,400 --> 00:54:24,160
throw an exception it just returns a

00:54:21,760 --> 00:54:28,160
null pointer

00:54:24,160 --> 00:54:30,960
uh step two on the other hand

00:54:28,160 --> 00:54:31,680
a constructor could still fail by

00:54:30,960 --> 00:54:36,000
throwing

00:54:31,680 --> 00:54:37,359
exceptions if that if that happens

00:54:36,000 --> 00:54:41,280
there's this interesting problem because

00:54:37,359 --> 00:54:41,280
we've just allocated memory here

00:54:42,000 --> 00:54:47,440
this constructor throws where do we get

00:54:45,359 --> 00:54:49,119
the chance to delete that memory and

00:54:47,440 --> 00:54:51,760
clean it up

00:54:49,119 --> 00:54:52,799
um i'll get to your question in just a

00:54:51,760 --> 00:54:56,240
moment

00:54:52,799 --> 00:54:58,319
uh the purpose this is what the

00:54:56,240 --> 00:55:00,720
no throw operator delete is designed to

00:54:58,319 --> 00:55:02,880
solve so

00:55:00,720 --> 00:55:04,240
a no throw new expression if you really

00:55:02,880 --> 00:55:05,440
look into it it would translate into

00:55:04,240 --> 00:55:08,640
something that looked like this

00:55:05,440 --> 00:55:10,240
first call operator new

00:55:08,640 --> 00:55:11,920
check to see if we got back a null

00:55:10,240 --> 00:55:14,720
pointer

00:55:11,920 --> 00:55:17,040
if so the allocation failed we're done

00:55:14,720 --> 00:55:19,839
otherwise

00:55:17,040 --> 00:55:21,520
go ahead try and call the constructor on

00:55:19,839 --> 00:55:25,280
that object

00:55:21,520 --> 00:55:28,319
if we fail by throwing an exception

00:55:25,280 --> 00:55:30,640
catch that exception delete the memory

00:55:28,319 --> 00:55:33,760
that was allocated up here

00:55:30,640 --> 00:55:37,359
and then rethrow

00:55:33,760 --> 00:55:37,839
so the there is this intermediate step

00:55:37,359 --> 00:55:40,559
of

00:55:37,839 --> 00:55:41,839
the compiler takes care of making sure

00:55:40,559 --> 00:55:45,200
that in the event of an

00:55:41,839 --> 00:55:47,440
of no throw new being used

00:55:45,200 --> 00:55:50,640
even if an exception is thrown elsewhere

00:55:47,440 --> 00:55:54,559
it'll still be cleaned up automatically

00:55:50,640 --> 00:55:56,559
so what that means is

00:55:54,559 --> 00:55:57,760
operator new and deleter always paired

00:55:56,559 --> 00:55:59,760
like this

00:55:57,760 --> 00:56:01,599
if you have an operator new that takes a

00:55:59,760 --> 00:56:04,319
certain set of arguments

00:56:01,599 --> 00:56:05,760
it will find the operator delete that

00:56:04,319 --> 00:56:07,359
the compiler will find the operator

00:56:05,760 --> 00:56:08,799
delete that takes the same set of

00:56:07,359 --> 00:56:12,480
arguments

00:56:08,799 --> 00:56:14,319
and pair them up in this situation so

00:56:12,480 --> 00:56:16,559
that if the constructor fails by

00:56:14,319 --> 00:56:17,839
throwing an exception the pair to

00:56:16,559 --> 00:56:20,720
operator delete gets

00:56:17,839 --> 00:56:22,960
called to clean up whatever the original

00:56:20,720 --> 00:56:24,720
operator knew did

00:56:22,960 --> 00:56:27,040
what that means is that anytime you

00:56:24,720 --> 00:56:29,119
write a version of operator new

00:56:27,040 --> 00:56:32,079
you should you want to write an operator

00:56:29,119 --> 00:56:33,839
a matching version of operator delete

00:56:32,079 --> 00:56:37,359
that's paired with it that takes the

00:56:33,839 --> 00:56:39,839
same set of arguments after the first

00:56:37,359 --> 00:56:40,640
that can deal with exceptions thrown by

00:56:39,839 --> 00:56:42,720
that is

00:56:40,640 --> 00:56:44,799
meant to clean up memory in case your

00:56:42,720 --> 00:56:46,240
constructors throw exceptions

00:56:44,799 --> 00:56:48,559
now i realize on a lot of embedded

00:56:46,240 --> 00:56:50,559
systems your constructors won't throw

00:56:48,559 --> 00:56:52,640
exceptions

00:56:50,559 --> 00:56:54,880
but it's generally it's not that hard to

00:56:52,640 --> 00:56:55,680
write it's often only a few small lines

00:56:54,880 --> 00:56:57,520
of code

00:56:55,680 --> 00:56:58,880
and i generally think it's better to be

00:56:57,520 --> 00:57:01,359
safe than sorry in this sort of

00:56:58,880 --> 00:57:03,920
situation

00:57:01,359 --> 00:57:04,960
so what i want you to take away from

00:57:03,920 --> 00:57:07,280
this is

00:57:04,960 --> 00:57:08,559
you can you can implement dynamic memory

00:57:07,280 --> 00:57:11,359
management systems that

00:57:08,559 --> 00:57:12,319
are well suited for use in embedded

00:57:11,359 --> 00:57:14,960
systems the

00:57:12,319 --> 00:57:15,599
available list system is one place that

00:57:14,960 --> 00:57:18,079
i often

00:57:15,599 --> 00:57:19,839
that i see a lot of systems use often a

00:57:18,079 --> 00:57:21,680
good place to start

00:57:19,839 --> 00:57:23,040
not necessarily the only solution you

00:57:21,680 --> 00:57:25,680
can use

00:57:23,040 --> 00:57:27,200
you can use the class specific operator

00:57:25,680 --> 00:57:31,040
to an operator delete

00:57:27,200 --> 00:57:31,359
to customize dynamic memory allocation

00:57:31,040 --> 00:57:34,400
for

00:57:31,359 --> 00:57:37,680
specific types and optimize the

00:57:34,400 --> 00:57:39,760
allocation of those types specifically

00:57:37,680 --> 00:57:41,040
but when you do when you replace

00:57:39,760 --> 00:57:42,480
operator new and weed

00:57:41,040 --> 00:57:44,319
remember that there are certain

00:57:42,480 --> 00:57:46,720
requirements that the replacements have

00:57:44,319 --> 00:57:46,720
to meet

00:57:46,960 --> 00:57:54,400
okay that brings me to the end uh

00:57:51,119 --> 00:57:56,319
there is i will stick around to answer

00:57:54,400 --> 00:57:57,440
questions i'll i'll answer a question in

00:57:56,319 --> 00:58:00,799
my remaining time

00:57:57,440 --> 00:58:03,599
and then i will be available in remo

00:58:00,799 --> 00:58:04,960
briefly to answer questions i say

00:58:03,599 --> 00:58:06,400
briefly because

00:58:04,960 --> 00:58:08,000
i have another thing happening in the

00:58:06,400 --> 00:58:11,920
next time slot

00:58:08,000 --> 00:58:12,480
um but feel free to come and ask me

00:58:11,920 --> 00:58:15,599
questions

00:58:12,480 --> 00:58:17,760
outside if the outside of this session

00:58:15,599 --> 00:58:18,960
uh if there are any that i wasn't able

00:58:17,760 --> 00:58:22,240
to get to

00:58:18,960 --> 00:58:23,839
and uh otherwise

00:58:22,240 --> 00:58:25,839
thank you for coming i hope you enjoyed

00:58:23,839 --> 00:58:29,280
it hope you find it useful

00:58:25,839 --> 00:58:29,280
enjoy the rest of cdpcon

00:58:33,760 --> 00:58:40,400
okay the question

00:58:37,119 --> 00:58:44,720
isn't a union taking care of the

00:58:40,400 --> 00:58:51,839
alignment requirements um

00:58:44,720 --> 00:58:51,839
what i was showing back here

00:58:52,480 --> 00:58:59,920
this is including these elements

00:58:56,640 --> 00:59:02,960
in the union the double and the size t

00:58:59,920 --> 00:59:04,799
makes sure that this available block is

00:59:02,960 --> 00:59:07,359
aligned in such a way that it

00:59:04,799 --> 00:59:10,079
has alignment suitable for a double or

00:59:07,359 --> 00:59:13,440
suitable for a size t

00:59:10,079 --> 00:59:14,000
that's a way that ensures that that

00:59:13,440 --> 00:59:17,040
alignment

00:59:14,000 --> 00:59:18,559
up to whatever require alignment is

00:59:17,040 --> 00:59:22,160
required by a double

00:59:18,559 --> 00:59:23,520
or a size t is there but it's not

00:59:22,160 --> 00:59:26,160
guaranteed that that's

00:59:23,520 --> 00:59:27,200
the strictest possible alignment you

00:59:26,160 --> 00:59:30,400
could have

00:59:27,200 --> 00:59:32,720
in your system it might be

00:59:30,400 --> 00:59:33,599
that there's some type in your system

00:59:32,720 --> 00:59:36,720
that has us

00:59:33,599 --> 00:59:39,440
that has a more restrictive alignment

00:59:36,720 --> 00:59:40,880
than a double maybe a long double for

00:59:39,440 --> 00:59:45,520
example

00:59:40,880 --> 00:59:47,359
in which case um

00:59:45,520 --> 00:59:48,720
this block would not necessarily be

00:59:47,359 --> 00:59:49,599
aligned in such a way that you could

00:59:48,720 --> 00:59:54,319
allocate a

00:59:49,599 --> 00:59:57,839
long double safely so

00:59:54,319 --> 00:59:59,520
this often this would work often

00:59:57,839 --> 01:00:01,680
for most of the objects that you would

00:59:59,520 --> 01:00:04,640
allocate this approach of

01:00:01,680 --> 01:00:05,920
including extra types in the union would

01:00:04,640 --> 01:00:07,599
generally work but it

01:00:05,920 --> 01:00:09,280
it wasn't guaranteed if you wanted to

01:00:07,599 --> 01:00:13,440
make sure that the object

01:00:09,280 --> 01:00:15,920
was aligned as it was

01:00:13,440 --> 01:00:17,359
had definitely had whatever alignment t

01:00:15,920 --> 01:00:20,160
required

01:00:17,359 --> 01:00:22,160
you could use this approach this also

01:00:20,160 --> 01:00:25,520
has a nice other benefit

01:00:22,160 --> 01:00:28,559
that uh it means that you're no

01:00:25,520 --> 01:00:30,880
more strictly aligned than a t requires

01:00:28,559 --> 01:00:32,240
so it may very well be that a double has

01:00:30,880 --> 01:00:34,799
eight byte alignment

01:00:32,240 --> 01:00:35,680
but a t only has only needs four byte

01:00:34,799 --> 01:00:37,200
alignment

01:00:35,680 --> 01:00:40,559
you might be able to use memory a little

01:00:37,200 --> 01:00:40,559
bit more efficiently that way

01:00:41,359 --> 01:00:44,559
question the stood no throw t seems like

01:00:44,000 --> 01:00:46,880
a tag

01:00:44,559 --> 01:00:48,079
type yeah it's very much like that yeah

01:00:46,880 --> 01:00:51,839
it doesn't really mean

01:00:48,079 --> 01:00:52,559
anything other than i'm specifically

01:00:51,839 --> 01:00:55,040
trying to

01:00:52,559 --> 01:00:57,520
call the version of operator new here

01:00:55,040 --> 01:00:59,359
that doesn't threat

01:00:57,520 --> 01:01:00,559
yeah so in that case in that sense it's

01:00:59,359 --> 01:01:03,760
very similar

01:01:00,559 --> 01:01:05,440
to the the tag types that you sometimes

01:01:03,760 --> 01:01:08,240
see used in

01:01:05,440 --> 01:01:08,799
certain uh container types i see this

01:01:08,240 --> 01:01:10,640
used in

01:01:08,799 --> 01:01:12,480
the i believe the most intrusive

01:01:10,640 --> 01:01:15,599
containers do this

01:01:12,480 --> 01:01:19,599
uh you also see this done

01:01:15,599 --> 01:01:22,880
for implementing

01:01:19,599 --> 01:01:24,160
the algorithm the stl algorithms in such

01:01:22,880 --> 01:01:26,160
a way that they are

01:01:24,160 --> 01:01:27,839
more or less efficient for different

01:01:26,160 --> 01:01:29,760
types of iterators

01:01:27,839 --> 01:01:33,520
that they're as efficient as they can be

01:01:29,760 --> 01:01:33,520
for the appropriate type of iterator

01:01:34,160 --> 01:01:38,000
if you compile with with exceptions

01:01:36,720 --> 01:01:41,040
turned off

01:01:38,000 --> 01:01:43,200
will the compiler then call the no throw

01:01:41,040 --> 01:01:45,520
operator new without using stood no

01:01:43,200 --> 01:01:45,520
throw

01:01:45,920 --> 01:01:51,920
i believe that's what most platforms do

01:01:48,960 --> 01:01:53,520
but the stan so the standard doesn't

01:01:51,920 --> 01:01:54,160
actually say that you're allowed to turn

01:01:53,520 --> 01:01:56,160
exceptions

01:01:54,160 --> 01:01:57,280
off that's an option that a lot of

01:01:56,160 --> 01:02:00,960
compiler vendors

01:01:57,280 --> 01:02:02,079
provide but as far as the standard is

01:02:00,960 --> 01:02:04,480
concerned

01:02:02,079 --> 01:02:06,960
exceptions are mandatory they have to be

01:02:04,480 --> 01:02:08,480
in the language so as soon as you turn

01:02:06,960 --> 01:02:10,480
that flag on

01:02:08,480 --> 01:02:11,599
you've kind of stepped out of outside of

01:02:10,480 --> 01:02:14,799
the bounds

01:02:11,599 --> 01:02:17,200
of what the standard guarantees and

01:02:14,799 --> 01:02:17,920
then it's just up to whatever your

01:02:17,200 --> 01:02:21,119
specific

01:02:17,920 --> 01:02:21,599
tool chain vendor chose to to do so i

01:02:21,119 --> 01:02:24,720
believe

01:02:21,599 --> 01:02:27,119
most of them translate

01:02:24,720 --> 01:02:28,160
operator new into the no throw version

01:02:27,119 --> 01:02:30,880
of new

01:02:28,160 --> 01:02:31,520
but there could be implementations out

01:02:30,880 --> 01:02:34,720
there

01:02:31,520 --> 01:02:37,760
that would simply disable this version

01:02:34,720 --> 01:02:40,880
of new create like a deleted function

01:02:37,760 --> 01:02:43,200
and instead force you to call this

01:02:40,880 --> 01:02:45,440
if you really want the no throw version

01:02:43,200 --> 01:02:45,440
new

01:02:46,400 --> 01:02:49,760
okay uh i'm gonna end here at this point

01:02:49,359 --> 01:02:51,520
again

01:02:49,760 --> 01:02:53,200
thank you for coming uh i hope you

01:02:51,520 --> 01:02:55,520
enjoyed it uh i will

01:02:53,200 --> 01:02:56,880
try and answer a few questions in remo

01:02:55,520 --> 01:03:01,920
either now or

01:02:56,880 --> 01:03:05,119
after uh this or after my next session

01:03:01,920 --> 01:03:08,400
but for uh but otherwise

01:03:05,119 --> 01:03:08,400
thank you for coming enjoy the rest of

01:03:14,839 --> 01:03:17,839
cppcon

01:03:27,039 --> 01:03:29,119

YouTube URL: https://www.youtube.com/watch?v=gzqLScDUlDI


