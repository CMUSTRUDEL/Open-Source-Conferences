Title: Closing the Gap between Rust and C++ Using Principles of Static Analysis - Sunny Chatterjee - CppCon
Publication date: 2020-09-23
Playlist: CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Did you know that 70% of serious security bugs are a result of memory safety issues? As a C++ developer, you may have heard about the safety benefits of Rust language. Although both Rust and C++ are high-performing system programming languages, we are increasingly hearing from customers and security researchers to have stronger safety and correctness guarantees in C++. Safety and correctness are no longer viewed as an opt-in behavior. The new adage is – if it compiles, it works. Static analysis has proved to be a valuable tool in empowering developers write modern C++. In this talk, I will share some ideas on how we can use the same principles in modern C++ code to provide strong statically-checked guarantees out-of-the-box. I will demonstrate some of these techniques live using MSVC’s code analysis tool.

---
Sunny leads a team responsible for developing the core C++ static analysis engines in Visual Studio productivity experience as well as the traditional security tooling scenarios used widely within Microsoft. He has many years of experience in static analysis and enjoys delivering new productivity benefits to customers. His current focus is to lead efforts towards making C++ a safer systems programming language.
---

Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,800 --> 00:00:12,080
hello everyone

00:00:09,840 --> 00:00:13,360
my name is sunny chatterjee i am an

00:00:12,080 --> 00:00:16,640
engineering manager

00:00:13,360 --> 00:00:18,800
in the c plus team at microsoft and for

00:00:16,640 --> 00:00:20,960
the past few years i have been working

00:00:18,800 --> 00:00:23,439
on static analysis

00:00:20,960 --> 00:00:25,439
so today unsurprisingly i'm going to be

00:00:23,439 --> 00:00:28,160
talking about how we used

00:00:25,439 --> 00:00:29,679
static analysis principles to close the

00:00:28,160 --> 00:00:32,560
gap between rust

00:00:29,679 --> 00:00:32,560
and c-plus plus

00:00:35,040 --> 00:00:40,079
before i move on to my talk i would like

00:00:37,040 --> 00:00:42,399
to welcome all of you to cppcon

00:00:40,079 --> 00:00:44,160
we have a table at the expo hall where

00:00:42,399 --> 00:00:47,600
you could leave the microsoft c

00:00:44,160 --> 00:00:49,039
plus team and ask questions on the demos

00:00:47,600 --> 00:00:51,199
and the new features that we have

00:00:49,039 --> 00:00:53,120
announced and interact with us

00:00:51,199 --> 00:00:54,879
there's also a chance for you to win a

00:00:53,120 --> 00:00:57,520
microsoft flight simulator

00:00:54,879 --> 00:00:58,160
by filling in a survey i have a link for

00:00:57,520 --> 00:01:01,760
it at the

00:00:58,160 --> 00:01:03,359
end of this slide so in this talk i'm

00:01:01,760 --> 00:01:04,080
going to be talking about static

00:01:03,359 --> 00:01:06,799
analysis

00:01:04,080 --> 00:01:07,920
and rust i'll share my first learnings

00:01:06,799 --> 00:01:10,640
on brust

00:01:07,920 --> 00:01:12,000
then i'll share the challenges of

00:01:10,640 --> 00:01:15,119
bridging the gap between

00:01:12,000 --> 00:01:17,439
the two languages i'll talk about the

00:01:15,119 --> 00:01:18,320
data from microsoft reduction code we

00:01:17,439 --> 00:01:20,479
have been using

00:01:18,320 --> 00:01:23,119
static analysis in microsoft microsoft

00:01:20,479 --> 00:01:25,280
reduction software for a number of years

00:01:23,119 --> 00:01:27,520
it's used to analyze millions of lines

00:01:25,280 --> 00:01:29,119
of code so it's always fun to talk about

00:01:27,520 --> 00:01:30,720
some of the bugs that we see in

00:01:29,119 --> 00:01:32,960
production

00:01:30,720 --> 00:01:34,320
next i'll cover where we are today in

00:01:32,960 --> 00:01:36,799
terms of our tooling

00:01:34,320 --> 00:01:38,799
and what's next for the microsoft c plus

00:01:36,799 --> 00:01:40,720
plus static analysis

00:01:38,799 --> 00:01:42,560
in the end i leave you with some helpful

00:01:40,720 --> 00:01:45,040
links that you can refer back to

00:01:42,560 --> 00:01:47,759
after my talk to dig deeper into any of

00:01:45,040 --> 00:01:47,759
these topics

00:01:49,600 --> 00:01:54,079
so let's look at what static analysis is

00:01:51,920 --> 00:01:56,719
well static analysis is a technique

00:01:54,079 --> 00:01:57,840
which reads in c plus code and it

00:01:56,719 --> 00:02:00,079
applies some logic

00:01:57,840 --> 00:02:02,000
to look for defects and reports these

00:02:00,079 --> 00:02:04,240
defects at compile time

00:02:02,000 --> 00:02:06,560
so the interesting thing to note here is

00:02:04,240 --> 00:02:08,160
that we find defects that compile time

00:02:06,560 --> 00:02:11,599
without the need to

00:02:08,160 --> 00:02:13,360
execute the code and our focus today is

00:02:11,599 --> 00:02:16,000
primarily going to be on

00:02:13,360 --> 00:02:17,760
local static analysis where a local

00:02:16,000 --> 00:02:18,959
static analysis tool doesn't have

00:02:17,760 --> 00:02:20,959
visibility across

00:02:18,959 --> 00:02:22,160
function boundaries and it considers

00:02:20,959 --> 00:02:25,360
each function

00:02:22,160 --> 00:02:26,879
in the translation unit in isolation and

00:02:25,360 --> 00:02:29,920
there is a reason why

00:02:26,879 --> 00:02:31,519
uh we'll be focusing on local static

00:02:29,920 --> 00:02:34,080
analysis tools today

00:02:31,519 --> 00:02:34,640
one is that local static analysis is

00:02:34,080 --> 00:02:37,200
fast

00:02:34,640 --> 00:02:38,959
and we can apply this technique at scale

00:02:37,200 --> 00:02:39,840
what it means is that we are able to

00:02:38,959 --> 00:02:42,560
provide uh

00:02:39,840 --> 00:02:43,840
defects to the user as he's typing his

00:02:42,560 --> 00:02:47,200
code or saving his

00:02:43,840 --> 00:02:48,800
work or even building so

00:02:47,200 --> 00:02:51,920
there's a lot of value that we can

00:02:48,800 --> 00:02:54,560
provide before bugs gets checked in

00:02:51,920 --> 00:02:55,680
the second reason is that over the past

00:02:54,560 --> 00:02:59,040
few years

00:02:55,680 --> 00:03:01,200
we have applied a few techniques to make

00:02:59,040 --> 00:03:03,440
local static analysis scale

00:03:01,200 --> 00:03:04,720
so for example we can look at the

00:03:03,440 --> 00:03:06,400
function boundaries

00:03:04,720 --> 00:03:08,480
we can look at the signatures on the

00:03:06,400 --> 00:03:10,080
functions and infer a lot about what the

00:03:08,480 --> 00:03:12,800
function is trying to do

00:03:10,080 --> 00:03:13,840
we can look at uh the attributes uh we

00:03:12,800 --> 00:03:15,840
can also

00:03:13,840 --> 00:03:18,080
uh look at things like standard wind

00:03:15,840 --> 00:03:19,760
city to apis whose behavior can be

00:03:18,080 --> 00:03:20,879
taught to the local static analysis

00:03:19,760 --> 00:03:22,640
tools and

00:03:20,879 --> 00:03:24,080
using these heuristics we can really

00:03:22,640 --> 00:03:27,280
make it an effective tool

00:03:24,080 --> 00:03:28,159
and we can bridge the gap for example

00:03:27,280 --> 00:03:30,799
with a global

00:03:28,159 --> 00:03:31,360
analysis tool now why that is important

00:03:30,799 --> 00:03:33,920
is

00:03:31,360 --> 00:03:36,000
our objective is to find and fix defects

00:03:33,920 --> 00:03:36,959
at the earliest point in the development

00:03:36,000 --> 00:03:39,040
cycle

00:03:36,959 --> 00:03:40,640
uh if you can do that then you can save

00:03:39,040 --> 00:03:42,720
a bunch of dollars for the company

00:03:40,640 --> 00:03:44,080
because bugs are cheapest to fix before

00:03:42,720 --> 00:03:46,319
they are checked in

00:03:44,080 --> 00:03:47,360
it's also an alignment with one of our

00:03:46,319 --> 00:03:49,760
company values

00:03:47,360 --> 00:03:51,840
we want to be committed to quality and

00:03:49,760 --> 00:03:53,840
static analysis definitely helps play a

00:03:51,840 --> 00:03:56,480
role in our commitment to quality for

00:03:53,840 --> 00:03:56,480
our customers

00:03:57,040 --> 00:04:00,080
next i'll talk a little bit about rust

00:03:59,680 --> 00:04:02,640
so

00:04:00,080 --> 00:04:04,959
before i move on to this i was curious

00:04:02,640 --> 00:04:05,760
to learn how many of you have used rust

00:04:04,959 --> 00:04:08,799
either

00:04:05,760 --> 00:04:11,040
as a programming language to play around

00:04:08,799 --> 00:04:12,799
or in real production software

00:04:11,040 --> 00:04:14,080
unfortunately i cannot make it very

00:04:12,799 --> 00:04:16,079
interactive so if you can

00:04:14,080 --> 00:04:17,120
share your experiences in the chat

00:04:16,079 --> 00:04:19,280
window i

00:04:17,120 --> 00:04:20,479
i would love to you the read about them

00:04:19,280 --> 00:04:24,000
and

00:04:20,479 --> 00:04:25,600
learn about them after my talk so

00:04:24,000 --> 00:04:27,600
rust is essentially a programming

00:04:25,600 --> 00:04:28,720
language that empowers everybody to

00:04:27,600 --> 00:04:30,400
build reliable

00:04:28,720 --> 00:04:32,800
and efficient software that's the

00:04:30,400 --> 00:04:34,400
definition you would find in rust land

00:04:32,800 --> 00:04:36,160
it's a great resource if you want to

00:04:34,400 --> 00:04:38,000
start looking into rust

00:04:36,160 --> 00:04:40,000
so the question is why we looked into

00:04:38,000 --> 00:04:42,320
rust well i've been doing static

00:04:40,000 --> 00:04:44,960
analysis for a number of years and

00:04:42,320 --> 00:04:47,120
for tickets i found that c plus is

00:04:44,960 --> 00:04:49,520
primarily focused on performance

00:04:47,120 --> 00:04:50,720
performance is a big reason why people

00:04:49,520 --> 00:04:52,560
would choose to use c

00:04:50,720 --> 00:04:54,479
plus plus in their performance intensive

00:04:52,560 --> 00:04:56,240
applications however

00:04:54,479 --> 00:04:58,800
we have seen the shift over the last few

00:04:56,240 --> 00:05:01,120
years where we have been stressing more

00:04:58,800 --> 00:05:02,240
on how people should be writing modern

00:05:01,120 --> 00:05:04,240
safe c plus

00:05:02,240 --> 00:05:06,560
code we have been working with the c

00:05:04,240 --> 00:05:08,400
plus plus core guideline editors uh and

00:05:06,560 --> 00:05:10,160
implementing some of the guidelines in

00:05:08,400 --> 00:05:12,160
our c plus plus code check

00:05:10,160 --> 00:05:13,759
so essentially customers and security

00:05:12,160 --> 00:05:14,080
researchers in our company they have

00:05:13,759 --> 00:05:15,600
been

00:05:14,080 --> 00:05:17,919
telling me that they want to see

00:05:15,600 --> 00:05:20,400
stronger safety guarantees in c

00:05:17,919 --> 00:05:22,400
plus so there was an internal survey

00:05:20,400 --> 00:05:25,039
done at microsoft for teams that were

00:05:22,400 --> 00:05:26,639
adopting rust and as pilot projects

00:05:25,039 --> 00:05:28,320
and one of the key reasons for its

00:05:26,639 --> 00:05:30,080
adoption was correctness

00:05:28,320 --> 00:05:32,639
so it's not just about performance and

00:05:30,080 --> 00:05:35,039
safety it's also about correctness

00:05:32,639 --> 00:05:37,120
people are increasingly expecting high

00:05:35,039 --> 00:05:38,720
fidelity from your compiled codes if a

00:05:37,120 --> 00:05:39,440
code is compiling correctly they would

00:05:38,720 --> 00:05:42,800
expect

00:05:39,440 --> 00:05:43,440
it to execute as desired there is a

00:05:42,800 --> 00:05:45,680
block

00:05:43,440 --> 00:05:47,199
from microsoft security research center

00:05:45,680 --> 00:05:49,280
i have on this slide

00:05:47,199 --> 00:05:50,960
that you can refer back to after my talk

00:05:49,280 --> 00:05:53,199
that goes into

00:05:50,960 --> 00:05:55,280
provides a high level summary of why

00:05:53,199 --> 00:05:57,759
rust is a safe language for

00:05:55,280 --> 00:05:59,600
systems programming so the challenge for

00:05:57,759 --> 00:06:02,319
us was to see if we could use

00:05:59,600 --> 00:06:04,479
the power of static analysis tools to

00:06:02,319 --> 00:06:07,759
bring some of the safety guarantees of

00:06:04,479 --> 00:06:09,919
rust into c plus plus

00:06:07,759 --> 00:06:12,319
so rust compiler does a lot of his

00:06:09,919 --> 00:06:13,919
checking at compile time and it's very

00:06:12,319 --> 00:06:15,600
similar to what we do with static

00:06:13,919 --> 00:06:16,639
analysis where we do these checkings at

00:06:15,600 --> 00:06:18,639
compile time

00:06:16,639 --> 00:06:19,680
it seemed like a natural fit so it was

00:06:18,639 --> 00:06:21,360
interesting to

00:06:19,680 --> 00:06:24,000
explore this territory and share the

00:06:21,360 --> 00:06:26,000
learnings with you all

00:06:24,000 --> 00:06:27,919
so let me go into my first learning so

00:06:26,000 --> 00:06:30,960
that i started looking into rust

00:06:27,919 --> 00:06:31,840
last winter so in draft safety features

00:06:30,960 --> 00:06:33,520
are built in

00:06:31,840 --> 00:06:35,440
what it means is if you're going to be

00:06:33,520 --> 00:06:38,319
breaking any of the safety features

00:06:35,440 --> 00:06:40,240
your code will not compile you cannot be

00:06:38,319 --> 00:06:42,160
uh cannot run that code you cannot ship

00:06:40,240 --> 00:06:44,639
that code to your customers

00:06:42,160 --> 00:06:45,759
now what i've seen is in c plus we have

00:06:44,639 --> 00:06:48,800
these checks uh

00:06:45,759 --> 00:06:50,720
it's spread across the tool chain in the

00:06:48,800 --> 00:06:52,479
tool chain does offer these checks but

00:06:50,720 --> 00:06:53,360
first these are not enforced by the

00:06:52,479 --> 00:06:55,120
compiler

00:06:53,360 --> 00:06:56,880
and second even if you have configured

00:06:55,120 --> 00:06:58,880
configure them for your project

00:06:56,880 --> 00:07:00,000
it's easy for you to turn these features

00:06:58,880 --> 00:07:01,759
off

00:07:00,000 --> 00:07:03,520
and your code would still compile and

00:07:01,759 --> 00:07:05,599
run just fine

00:07:03,520 --> 00:07:07,199
and the second learning for me was uh

00:07:05,599 --> 00:07:09,599
there isn't necessarily a one

00:07:07,199 --> 00:07:10,240
to one mapping between every rust safety

00:07:09,599 --> 00:07:12,880
feature

00:07:10,240 --> 00:07:14,000
and c plus score guidelines and that's

00:07:12,880 --> 00:07:16,400
by design

00:07:14,000 --> 00:07:17,280
several rust rules are restrictive for

00:07:16,400 --> 00:07:20,000
existing c

00:07:17,280 --> 00:07:21,360
plus coding practices and our objective

00:07:20,000 --> 00:07:24,080
was not uh to just

00:07:21,360 --> 00:07:26,000
copy every rust rule in c plus plus

00:07:24,080 --> 00:07:28,000
however we wanted to look at a

00:07:26,000 --> 00:07:30,400
broader picture we wanted to look at the

00:07:28,000 --> 00:07:33,759
big buckets of safety and correctness

00:07:30,400 --> 00:07:35,520
and uh we wanted to bring over uh what

00:07:33,759 --> 00:07:37,759
made sense in the landscape of c

00:07:35,520 --> 00:07:39,680
plus plus so this isn't an exercise to

00:07:37,759 --> 00:07:39,919
take every rust rule and bring that into

00:07:39,680 --> 00:07:43,759
c

00:07:39,919 --> 00:07:46,080
plus plus so the challenge for

00:07:43,759 --> 00:07:48,160
for us was obviously to bridge this gap

00:07:46,080 --> 00:07:50,639
uh so we started identifying

00:07:48,160 --> 00:07:52,160
actionable safety differences that could

00:07:50,639 --> 00:07:55,360
be statically checked

00:07:52,160 --> 00:07:57,280
we also wanted to uh see if the our

00:07:55,360 --> 00:07:58,000
static analysis framework the engine

00:07:57,280 --> 00:08:00,400
that we use

00:07:58,000 --> 00:08:01,840
to power the code analysis checks in

00:08:00,400 --> 00:08:04,000
visual studio the c

00:08:01,840 --> 00:08:06,000
plus plus code check rules if the engine

00:08:04,000 --> 00:08:07,759
could be used to to

00:08:06,000 --> 00:08:09,199
write some of these missing safety

00:08:07,759 --> 00:08:12,240
checks

00:08:09,199 --> 00:08:14,400
and uh lastly we also wanted to keep an

00:08:12,240 --> 00:08:16,080
eye out or on the c plus plus core

00:08:14,400 --> 00:08:17,680
guidelines there a lot of thought has

00:08:16,080 --> 00:08:19,680
gone into these guidelines

00:08:17,680 --> 00:08:22,240
so obviously it was a very interesting

00:08:19,680 --> 00:08:23,680
uh finding for us to figure out how much

00:08:22,240 --> 00:08:25,120
of the rust rules are covered in the

00:08:23,680 --> 00:08:27,599
core guidelines

00:08:25,120 --> 00:08:29,280
so the exercise we did was to go over

00:08:27,599 --> 00:08:31,440
the big buckets of safety and

00:08:29,280 --> 00:08:33,680
correctness rules in rust

00:08:31,440 --> 00:08:35,440
and when we tried finding uh

00:08:33,680 --> 00:08:37,360
corresponding rules in c

00:08:35,440 --> 00:08:38,959
plus whether they are in the standard or

00:08:37,360 --> 00:08:41,039
the core guidelines

00:08:38,959 --> 00:08:42,159
and lastly we wanted to see how much of

00:08:41,039 --> 00:08:45,040
these are available

00:08:42,159 --> 00:08:46,640
in visual studio today and if not what

00:08:45,040 --> 00:08:48,959
it will take to implement these missing

00:08:46,640 --> 00:08:48,959
checks

00:08:49,760 --> 00:08:53,839
so next i'll talk about some of the big

00:08:51,920 --> 00:08:56,399
buckets we looked at

00:08:53,839 --> 00:08:57,839
so we looked at casting we looked at

00:08:56,399 --> 00:09:00,320
switch statements

00:08:57,839 --> 00:09:01,600
we looked at smarter loops we looked at

00:09:00,320 --> 00:09:04,480
smarter copying

00:09:01,600 --> 00:09:06,640
lifetimes mutability so i'll first talk

00:09:04,480 --> 00:09:08,640
about casting

00:09:06,640 --> 00:09:10,880
so grass does not allow implicit casting

00:09:08,640 --> 00:09:12,240
among primitive types what this means is

00:09:10,880 --> 00:09:13,519
if you take a function that takes a

00:09:12,240 --> 00:09:15,680
32-bit integer

00:09:13,519 --> 00:09:16,880
and tries to convert it into an unsigned

00:09:15,680 --> 00:09:18,640
number uh

00:09:16,880 --> 00:09:20,240
rust compiler would error out saying

00:09:18,640 --> 00:09:21,680
you've attempted a conversion from sine

00:09:20,240 --> 00:09:23,519
to unsigned

00:09:21,680 --> 00:09:25,839
similarly if you have a function that

00:09:23,519 --> 00:09:27,600
takes a float and tries to pass it to a

00:09:25,839 --> 00:09:29,360
function which expects an integer

00:09:27,600 --> 00:09:31,279
that conversion is not allowed by the

00:09:29,360 --> 00:09:33,200
rust compiler

00:09:31,279 --> 00:09:35,920
it's interesting to note that c style

00:09:33,200 --> 00:09:37,760
casting is allowed for some of the types

00:09:35,920 --> 00:09:40,080
and as you can see in this example you

00:09:37,760 --> 00:09:42,399
have a c style cast that converts this

00:09:40,080 --> 00:09:43,200
eight bit uh the 32-bit integer to an

00:09:42,399 --> 00:09:45,360
eight bit

00:09:43,200 --> 00:09:46,880
and it has the usual problems of c-style

00:09:45,360 --> 00:09:49,200
casting where you can wrap

00:09:46,880 --> 00:09:51,279
wrap around if you can change the sinus

00:09:49,200 --> 00:09:52,640
however no conversion is allowed from an

00:09:51,279 --> 00:09:54,240
integer to a bull

00:09:52,640 --> 00:09:56,480
so here's an example when you're trying

00:09:54,240 --> 00:09:56,959
to use the conversion from integer to a

00:09:56,480 --> 00:09:58,880
pull

00:09:56,959 --> 00:10:00,320
and the rust compiler does not like it

00:09:58,880 --> 00:10:02,480
so it will not allow you to convert an

00:10:00,320 --> 00:10:04,560
integer to

00:10:02,480 --> 00:10:06,880
similar you can't use this as a boolean

00:10:04,560 --> 00:10:09,600
expression you have to convert that uh

00:10:06,880 --> 00:10:10,720
a which is like a integer not equal zero

00:10:09,600 --> 00:10:12,480
to convert the

00:10:10,720 --> 00:10:14,320
integer expression to a boolean if you

00:10:12,480 --> 00:10:18,000
can before you can use that in an if

00:10:14,320 --> 00:10:20,560
conditional block safe casting in

00:10:18,000 --> 00:10:21,200
rest can be achieved using the try from

00:10:20,560 --> 00:10:23,680
and the try

00:10:21,200 --> 00:10:25,519
into trades so here is an example where

00:10:23,680 --> 00:10:27,440
you have a try from trade where you're

00:10:25,519 --> 00:10:29,839
trying to convert a 32-bit integer

00:10:27,440 --> 00:10:31,200
into an 8-bit value and if the value

00:10:29,839 --> 00:10:33,279
fits into that range

00:10:31,200 --> 00:10:34,800
you will assign that to your variable b

00:10:33,279 --> 00:10:36,800
otherwise you are assigning the default

00:10:34,800 --> 00:10:40,560
value of 42. so you're using these trays

00:10:36,800 --> 00:10:44,560
to essentially perform save casting

00:10:40,560 --> 00:10:46,640
next we looked at the casting rules in c

00:10:44,560 --> 00:10:47,680
plus and we have this type safety

00:10:46,640 --> 00:10:49,519
profile in the c

00:10:47,680 --> 00:10:51,600
plus plus code check which is built upon

00:10:49,519 --> 00:10:53,519
the c plus plus core guidelines

00:10:51,600 --> 00:10:55,519
which does provide a whole bunch of

00:10:53,519 --> 00:10:56,399
rules around how you could do casting

00:10:55,519 --> 00:10:58,640
safely

00:10:56,399 --> 00:11:00,560
if you know for bits using reinterpret

00:10:58,640 --> 00:11:03,120
casts by which you can

00:11:00,560 --> 00:11:05,040
convert any integer to a pointer it

00:11:03,120 --> 00:11:07,040
doesn't want you to use a static cache

00:11:05,040 --> 00:11:09,360
for doing downcasts because

00:11:07,040 --> 00:11:10,959
you know you can actually uh you know

00:11:09,360 --> 00:11:13,680
there can be a data loss so

00:11:10,959 --> 00:11:15,519
we have created these types in the gsl

00:11:13,680 --> 00:11:16,720
guideline support library called narrow

00:11:15,519 --> 00:11:18,880
and narrow cache that you should be

00:11:16,720 --> 00:11:19,600
using for downcasting similarly it says

00:11:18,880 --> 00:11:22,240
don't cons

00:11:19,600 --> 00:11:23,680
use a const cast to cast a response so

00:11:22,240 --> 00:11:25,760
there are these whole bunch of rules

00:11:23,680 --> 00:11:26,480
that if you go to visual studio and try

00:11:25,760 --> 00:11:28,480
the c

00:11:26,480 --> 00:11:30,320
plus code check type safety profile

00:11:28,480 --> 00:11:33,920
today that would lead you

00:11:30,320 --> 00:11:35,680
to use casting in a safe and correct way

00:11:33,920 --> 00:11:37,760
so we were pretty happy to see where we

00:11:35,680 --> 00:11:40,880
were in terms of the casting rules in c

00:11:37,760 --> 00:11:44,399
plus so the next packet we looked at was

00:11:40,880 --> 00:11:46,240
switch statements so in rest it has a

00:11:44,399 --> 00:11:47,839
pattern matching construct that covers

00:11:46,240 --> 00:11:50,399
similar functionality to c

00:11:47,839 --> 00:11:51,839
plus plus switch and and more it's a

00:11:50,399 --> 00:11:53,440
it's a math statement where

00:11:51,839 --> 00:11:55,600
in this example you see you have a

00:11:53,440 --> 00:11:57,360
32-bit integer and you're trying to

00:11:55,600 --> 00:11:59,680
match the values one and two

00:11:57,360 --> 00:12:01,279
and if you omit this third statement

00:11:59,680 --> 00:12:03,600
which is like the equivalence of c

00:12:01,279 --> 00:12:05,279
plus plus default then the rust compiler

00:12:03,600 --> 00:12:06,959
will not compile this code because it

00:12:05,279 --> 00:12:09,279
wants you to check for every possible

00:12:06,959 --> 00:12:11,120
value of that integer

00:12:09,279 --> 00:12:12,399
similarly you have an nm here which has

00:12:11,120 --> 00:12:14,800
three values a b

00:12:12,399 --> 00:12:16,639
and c and you have to explicitly check

00:12:14,800 --> 00:12:18,399
all three values of that nm

00:12:16,639 --> 00:12:20,480
otherwise your code and rust will not

00:12:18,399 --> 00:12:22,800
compile

00:12:20,480 --> 00:12:23,600
so in c plus plus core guidelines we did

00:12:22,800 --> 00:12:25,200
find a

00:12:23,600 --> 00:12:27,040
number of rules that would leave the

00:12:25,200 --> 00:12:28,160
programmer to use three statements in a

00:12:27,040 --> 00:12:30,480
safe way

00:12:28,160 --> 00:12:32,320
for example uh there is a rule that

00:12:30,480 --> 00:12:34,320
states with statements over a non-num

00:12:32,320 --> 00:12:36,160
type should have a default

00:12:34,320 --> 00:12:38,320
switch statements over an nm type should

00:12:36,160 --> 00:12:41,519
either have a default or it should cover

00:12:38,320 --> 00:12:42,639
all possible cases and similarly it

00:12:41,519 --> 00:12:44,560
wants you to mark

00:12:42,639 --> 00:12:46,560
all the implicit false rules with the c

00:12:44,560 --> 00:12:48,560
plus plus 17 false to attribute

00:12:46,560 --> 00:12:51,120
it's interesting to note that russ does

00:12:48,560 --> 00:12:53,279
not have the false truth in matchers

00:12:51,120 --> 00:12:54,959
but in c plus plus we do but our intent

00:12:53,279 --> 00:12:58,079
should be clear we should be using the c

00:12:54,959 --> 00:13:00,800
plus 17 attributes so

00:12:58,079 --> 00:13:02,639
next i'll uh do a demo of this uh of

00:13:00,800 --> 00:13:04,720
these checks in visual studio we just

00:13:02,639 --> 00:13:07,680
built some of that that we're missing

00:13:04,720 --> 00:13:09,600
so here is a code that where we have a

00:13:07,680 --> 00:13:12,000
function that takes an integer

00:13:09,600 --> 00:13:12,880
and uh it has a switch on that it has

00:13:12,000 --> 00:13:15,279
two cases

00:13:12,880 --> 00:13:17,360
uh it doesn't cover anything other than

00:13:15,279 --> 00:13:18,800
the value of zero and one so here you

00:13:17,360 --> 00:13:20,720
will see a green squiggle

00:13:18,800 --> 00:13:22,560
as you are saving your work you will

00:13:20,720 --> 00:13:23,760
find a warning that says the switch

00:13:22,560 --> 00:13:26,000
statement does not cover

00:13:23,760 --> 00:13:27,279
all cases consider adding a default

00:13:26,000 --> 00:13:31,120
level

00:13:27,279 --> 00:13:32,880
similarly here is another example where

00:13:31,120 --> 00:13:34,959
you would find here the function foo

00:13:32,880 --> 00:13:37,680
that covers a few cases

00:13:34,959 --> 00:13:38,560
for an integer it also has a default so

00:13:37,680 --> 00:13:40,639
that's great

00:13:38,560 --> 00:13:41,920
however case one here is interesting it

00:13:40,639 --> 00:13:44,240
has an if condition

00:13:41,920 --> 00:13:45,920
and an else part so in the else part we

00:13:44,240 --> 00:13:47,839
have an explicit fall through

00:13:45,920 --> 00:13:49,920
however in the if part we do call the

00:13:47,839 --> 00:13:50,639
function but there isn't an explicit

00:13:49,920 --> 00:13:51,839
false true

00:13:50,639 --> 00:13:54,079
there is an implicit false true

00:13:51,839 --> 00:13:56,240
happening from here to case two

00:13:54,079 --> 00:13:57,839
so we don't know uh whether this is

00:13:56,240 --> 00:14:00,079
intentional or it's a

00:13:57,839 --> 00:14:02,320
simple programming logical error so we

00:14:00,079 --> 00:14:04,240
have a green squiggle here

00:14:02,320 --> 00:14:06,320
that's provided by the background code

00:14:04,240 --> 00:14:07,680
analysis run if you hover over it it

00:14:06,320 --> 00:14:09,279
will tell you that hey this is an

00:14:07,680 --> 00:14:11,279
unannotated fall through between the

00:14:09,279 --> 00:14:11,760
switch levels so what you want to do

00:14:11,279 --> 00:14:14,560
here

00:14:11,760 --> 00:14:16,160
is either uh to add an explicit c plus

00:14:14,560 --> 00:14:19,440
17 attribute

00:14:16,160 --> 00:14:19,440
so it could be something like

00:14:24,320 --> 00:14:30,399
and then you save your work and

00:14:28,480 --> 00:14:33,839
what happens is once we make it explicit

00:14:30,399 --> 00:14:33,839
that prince wiggles disappears

00:14:38,399 --> 00:14:42,160
so we looked at casting and switch

00:14:40,000 --> 00:14:43,600
statements we'll look into smarter loops

00:14:42,160 --> 00:14:46,560
next

00:14:43,600 --> 00:14:47,440
so in rust we do not have c-style for

00:14:46,560 --> 00:14:49,519
loops

00:14:47,440 --> 00:14:52,480
because you all know that in c-style for

00:14:49,519 --> 00:14:55,120
loops it's error-prone it's complicated

00:14:52,480 --> 00:14:56,800
uh we can re-pass the bounds of the

00:14:55,120 --> 00:14:58,720
container

00:14:56,800 --> 00:15:00,000
so what rust wants you to do is it wants

00:14:58,720 --> 00:15:02,959
you to use a

00:15:00,000 --> 00:15:04,639
ranged checked iterator pattern and it

00:15:02,959 --> 00:15:07,040
wants to force loop variables to the

00:15:04,639 --> 00:15:09,519
loop itself so it's very similar to

00:15:07,040 --> 00:15:11,199
the range for loops in c plus plus so

00:15:09,519 --> 00:15:12,880
here's an example from the rust book

00:15:11,199 --> 00:15:14,880
where you are basically going through

00:15:12,880 --> 00:15:16,079
the elements of this array but the

00:15:14,880 --> 00:15:17,920
syntax is very

00:15:16,079 --> 00:15:20,399
for those of you that are familiar with

00:15:17,920 --> 00:15:22,880
uh c plus plus uh

00:15:20,399 --> 00:15:24,000
range for loop you can see that this is

00:15:22,880 --> 00:15:25,600
a

00:15:24,000 --> 00:15:27,600
simple c plus plus range for loop

00:15:25,600 --> 00:15:29,440
similarly you can do more complex

00:15:27,600 --> 00:15:31,040
operations you have a sequence from 1 to

00:15:29,440 --> 00:15:33,040
less than 11 you can reverse that

00:15:31,040 --> 00:15:34,160
sequence and step down by two and all of

00:15:33,040 --> 00:15:40,560
that can be done

00:15:34,160 --> 00:15:42,240
in a way where it is range checked

00:15:40,560 --> 00:15:43,920
so i've got a comment here saying that

00:15:42,240 --> 00:15:44,959
uh i should be zooming into visual

00:15:43,920 --> 00:15:48,480
studio i'll be

00:15:44,959 --> 00:15:50,320
doing that for my next demo so in c

00:15:48,480 --> 00:15:51,600
plus plus we do have a number of rules

00:15:50,320 --> 00:15:53,360
around loop safety

00:15:51,600 --> 00:15:55,279
so it says that we should be flagging

00:15:53,360 --> 00:15:56,079
loop variables that are declared outside

00:15:55,279 --> 00:15:57,920
the loop

00:15:56,079 --> 00:15:59,920
so here's an example where you have a

00:15:57,920 --> 00:16:01,600
c-style for loop with the loop variable

00:15:59,920 --> 00:16:03,440
declared inside the loop

00:16:01,600 --> 00:16:05,199
and what we really want to see here is

00:16:03,440 --> 00:16:06,800
that loop variable should move into the

00:16:05,199 --> 00:16:07,519
loop it should be scoped within the loop

00:16:06,800 --> 00:16:09,600
body

00:16:07,519 --> 00:16:11,839
and shouldn't be used after the loop

00:16:09,600 --> 00:16:14,000
similarly you have an if statement where

00:16:11,839 --> 00:16:15,920
the condition of the if is computed

00:16:14,000 --> 00:16:18,560
outside the if and we want to see that

00:16:15,920 --> 00:16:21,440
moved inside the if

00:16:18,560 --> 00:16:22,000
similarly there is a rule in c plus uh

00:16:21,440 --> 00:16:24,399
where

00:16:22,000 --> 00:16:26,000
it's it it wants us to flag reuse of

00:16:24,399 --> 00:16:27,440
loop index variable so you have a loop

00:16:26,000 --> 00:16:29,360
index variable i here

00:16:27,440 --> 00:16:31,199
which is used in two loops and it's

00:16:29,360 --> 00:16:32,560
reset in the second loop and it's not

00:16:31,199 --> 00:16:33,759
used in between the two loops and

00:16:32,560 --> 00:16:36,160
there's no reason why

00:16:33,759 --> 00:16:37,600
that shouldn't move inside the loop body

00:16:36,160 --> 00:16:40,240
so we do have these rules in the

00:16:37,600 --> 00:16:42,240
guideline to use loop safely

00:16:40,240 --> 00:16:44,800
so the other example that's interesting

00:16:42,240 --> 00:16:46,560
is uh we want to convert c style for

00:16:44,800 --> 00:16:48,480
loops into four range loops so here is a

00:16:46,560 --> 00:16:50,720
typical c style for loop example

00:16:48,480 --> 00:16:52,240
where basically going from zero it's

00:16:50,720 --> 00:16:53,040
less than the size of the vector and

00:16:52,240 --> 00:16:55,920
then you're

00:16:53,040 --> 00:16:57,600
indexing it by that uh variable i in the

00:16:55,920 --> 00:16:59,839
second pattern it's more predictable

00:16:57,600 --> 00:17:01,600
where we have the begin and end so we

00:16:59,839 --> 00:17:03,519
are still using naked iterators

00:17:01,600 --> 00:17:04,880
and it's still possible to read past the

00:17:03,519 --> 00:17:06,799
end of the collection

00:17:04,880 --> 00:17:08,559
if you're using naked iterators it's not

00:17:06,799 --> 00:17:10,400
rain checked the third

00:17:08,559 --> 00:17:12,480
format is what we would recommend where

00:17:10,400 --> 00:17:13,679
you're using a range for loop and it's

00:17:12,480 --> 00:17:16,720
impossible for you

00:17:13,679 --> 00:17:18,799
to read past the range of the vector so

00:17:16,720 --> 00:17:20,559
in this particular case we want to issue

00:17:18,799 --> 00:17:23,199
a warning that says hey don't use

00:17:20,559 --> 00:17:25,280
c-style for loop use for range instead

00:17:23,199 --> 00:17:27,520
so here i wanted to spend some time on

00:17:25,280 --> 00:17:29,440
this example to show you how a static

00:17:27,520 --> 00:17:31,200
analysis tool would reason about

00:17:29,440 --> 00:17:33,120
code and then come up with these

00:17:31,200 --> 00:17:35,039
warnings

00:17:33,120 --> 00:17:36,799
so what the tool will first see is okay

00:17:35,039 --> 00:17:38,640
you'll note that this loop has the first

00:17:36,799 --> 00:17:40,480
uh it has a loop variable i

00:17:38,640 --> 00:17:43,039
it's just one loop variable it needs to

00:17:40,480 --> 00:17:45,120
track and the condition of the

00:17:43,039 --> 00:17:46,799
loop variable is bound by the size of

00:17:45,120 --> 00:17:48,880
the collection so it's less than the

00:17:46,799 --> 00:17:50,400
size of the vector here

00:17:48,880 --> 00:17:53,600
next if you see that the instrument

00:17:50,400 --> 00:17:56,799
expression is a simple increment by one

00:17:53,600 --> 00:17:57,520
and next it'll check that there is the

00:17:56,799 --> 00:17:59,440
only way

00:17:57,520 --> 00:18:01,280
the loop index variable is used is for a

00:17:59,440 --> 00:18:03,360
simple access there is no funny things

00:18:01,280 --> 00:18:06,640
happening like pointed arithmetic

00:18:03,360 --> 00:18:08,640
it's not used to access uh with a plus

00:18:06,640 --> 00:18:10,000
one or plus two there is no assignment

00:18:08,640 --> 00:18:11,919
happening to it

00:18:10,000 --> 00:18:13,679
and lastly it will also make sure that

00:18:11,919 --> 00:18:15,120
we are not uh

00:18:13,679 --> 00:18:17,039
doing any side effects on that

00:18:15,120 --> 00:18:17,760
collection so for example if in the loop

00:18:17,039 --> 00:18:20,080
body we

00:18:17,760 --> 00:18:21,520
had a push back operation on the vector

00:18:20,080 --> 00:18:22,880
that would cause interesting side

00:18:21,520 --> 00:18:23,679
effects so if none of these are

00:18:22,880 --> 00:18:25,600
happening

00:18:23,679 --> 00:18:27,440
then the tool can pretty reasonable

00:18:25,600 --> 00:18:29,600
confidence one that hey

00:18:27,440 --> 00:18:31,280
you really need to change this c style

00:18:29,600 --> 00:18:34,720
for loop into a range for

00:18:31,280 --> 00:18:34,720
style for loop

00:18:34,960 --> 00:18:38,400
so we covered casting switch statements

00:18:37,200 --> 00:18:40,840
smarter loops

00:18:38,400 --> 00:18:42,080
next i'll be talking about smarter

00:18:40,840 --> 00:18:44,240
copying

00:18:42,080 --> 00:18:45,520
so the interesting thing about rust is

00:18:44,240 --> 00:18:48,240
it's moved by default

00:18:45,520 --> 00:18:48,960
and copying semantics must be explicit

00:18:48,240 --> 00:18:51,600
so this is

00:18:48,960 --> 00:18:53,679
very different than c plus where in c

00:18:51,600 --> 00:18:55,200
plus we have a language which is copy by

00:18:53,679 --> 00:18:57,600
default and move semantics

00:18:55,200 --> 00:19:00,160
has to be specified explicitly and move

00:18:57,600 --> 00:19:02,480
by default is indeed a big part of

00:19:00,160 --> 00:19:03,360
rust's memory management techniques like

00:19:02,480 --> 00:19:06,000
lifetimes

00:19:03,360 --> 00:19:07,440
ownerships borrowing and it helps us

00:19:06,000 --> 00:19:09,440
prevent memory leaks

00:19:07,440 --> 00:19:11,039
so here's an example where you have a

00:19:09,440 --> 00:19:12,080
big structure that you're assigning to

00:19:11,039 --> 00:19:14,320
an object a

00:19:12,080 --> 00:19:16,320
and then you're assigning a to b so what

00:19:14,320 --> 00:19:18,960
happens after this statement is that

00:19:16,320 --> 00:19:21,039
a can no longer be used in brust because

00:19:18,960 --> 00:19:22,559
the contents of a has been moved into b

00:19:21,039 --> 00:19:24,799
and that would result in a compiler

00:19:22,559 --> 00:19:26,400
error if you want to copy explicitly

00:19:24,799 --> 00:19:27,440
what you want to do is you want to use a

00:19:26,400 --> 00:19:29,200
clone here

00:19:27,440 --> 00:19:32,320
and that would clone the that would copy

00:19:29,200 --> 00:19:35,760
the contents of a into b

00:19:32,320 --> 00:19:38,080
so in c plus we wanted to uh see what

00:19:35,760 --> 00:19:38,400
the side effects of this copy are and

00:19:38,080 --> 00:19:40,559
one

00:19:38,400 --> 00:19:42,559
interesting thing that came up was uh

00:19:40,559 --> 00:19:43,120
the inadvertent copies that happened in

00:19:42,559 --> 00:19:45,440
the for

00:19:43,120 --> 00:19:47,760
a range for loop so we wanted to flag

00:19:45,440 --> 00:19:49,760
range for loops that do unnecessary copy

00:19:47,760 --> 00:19:51,679
so here is an example where

00:19:49,760 --> 00:19:53,360
you have a vector which has a complex

00:19:51,679 --> 00:19:55,200
type and that complex type

00:19:53,360 --> 00:19:58,000
imagine it's like an expensive type it

00:19:55,200 --> 00:20:00,000
has uh then you are iterating over that

00:19:58,000 --> 00:20:02,559
type in a range for loop in c

00:20:00,000 --> 00:20:03,280
plus however inside the body of the loop

00:20:02,559 --> 00:20:06,080
you are not

00:20:03,280 --> 00:20:07,760
mutating x it's never written into so

00:20:06,080 --> 00:20:08,960
what we really want this code to look

00:20:07,760 --> 00:20:11,440
like is something like

00:20:08,960 --> 00:20:13,280
here below where we want to change this

00:20:11,440 --> 00:20:15,039
x to be a const ref

00:20:13,280 --> 00:20:17,039
because it's never mutated and there is

00:20:15,039 --> 00:20:19,679
no reason why we should be doing that

00:20:17,039 --> 00:20:21,360
expensive copy so in this particular

00:20:19,679 --> 00:20:23,280
case the static analysis tool would

00:20:21,360 --> 00:20:24,960
first look for that expensive copy

00:20:23,280 --> 00:20:27,919
in the range for and then it would

00:20:24,960 --> 00:20:29,600
suggest that it be marked as a reference

00:20:27,919 --> 00:20:31,520
it also wants to make sure that the copy

00:20:29,600 --> 00:20:33,760
the data type is expensive

00:20:31,520 --> 00:20:35,600
so it doesn't uh warrant if the object

00:20:33,760 --> 00:20:36,320
is just a view or a smart pointer

00:20:35,600 --> 00:20:38,400
because those

00:20:36,320 --> 00:20:40,240
are you know passing them by value

00:20:38,400 --> 00:20:41,520
making a copy is just fine for views and

00:20:40,240 --> 00:20:43,280
smart pointers

00:20:41,520 --> 00:20:45,520
it also wants to make sure that the loop

00:20:43,280 --> 00:20:46,880
variable is not mutated inside the loop

00:20:45,520 --> 00:20:50,240
body because if it were

00:20:46,880 --> 00:20:53,200
then you couldn't suggest a constraint

00:20:50,240 --> 00:20:54,640
i'm gonna demo a check that we wrote in

00:20:53,200 --> 00:20:57,280
visual studio for

00:20:54,640 --> 00:20:58,080
this particular check so you have a

00:20:57,280 --> 00:20:59,840
range for

00:20:58,080 --> 00:21:01,360
here you have a large truck and you have

00:20:59,840 --> 00:21:05,760
a small struct uh

00:21:01,360 --> 00:21:05,760
let me enlarge the funds a little bit

00:21:06,799 --> 00:21:10,960
so you have a large truck and you have a

00:21:08,559 --> 00:21:13,120
small strut and then you have a function

00:21:10,960 --> 00:21:14,960
that takes a construct to a vector of

00:21:13,120 --> 00:21:18,799
large truck and it takes

00:21:14,960 --> 00:21:21,440
a const bref to a vector of small struct

00:21:18,799 --> 00:21:22,320
so the very first range for that you see

00:21:21,440 --> 00:21:24,400
here

00:21:22,320 --> 00:21:25,919
is where we are iterating over that

00:21:24,400 --> 00:21:28,159
large collection

00:21:25,919 --> 00:21:30,080
however we are calling a function that

00:21:28,159 --> 00:21:32,799
does not mutate that data

00:21:30,080 --> 00:21:34,720
so this copy that is happening here is

00:21:32,799 --> 00:21:36,880
completely unnecessary so we

00:21:34,720 --> 00:21:38,559
get a green squiggle here that says hey

00:21:36,880 --> 00:21:39,840
you're getting a potentially expensive

00:21:38,559 --> 00:21:41,679
copy of variable

00:21:39,840 --> 00:21:43,440
in the range for loop consider marking

00:21:41,679 --> 00:21:45,520
it as a const reference

00:21:43,440 --> 00:21:47,760
so what it really wants the user to do

00:21:45,520 --> 00:21:47,760
is

00:21:48,000 --> 00:21:53,120
mark this data as a trans reference and

00:21:51,039 --> 00:21:55,600
then once you save your work

00:21:53,120 --> 00:21:57,120
then background code analysis should run

00:21:55,600 --> 00:21:58,240
in the background and you should see

00:21:57,120 --> 00:21:59,919
that this green squiggle should

00:21:58,240 --> 00:22:02,799
disappear

00:21:59,919 --> 00:22:04,720
however in the next uh for loop we are

00:22:02,799 --> 00:22:06,799
iterating over the collection of small

00:22:04,720 --> 00:22:08,480
structs and we don't want

00:22:06,799 --> 00:22:10,080
uh we don't ask you to mark this as a

00:22:08,480 --> 00:22:11,600
const reference because there is this is

00:22:10,080 --> 00:22:14,559
really not an expensive copy

00:22:11,600 --> 00:22:16,640
so you should be good there similarly in

00:22:14,559 --> 00:22:18,880
the next example you have an example

00:22:16,640 --> 00:22:20,320
you have a for range for loop where

00:22:18,880 --> 00:22:21,120
you're iterating over that large

00:22:20,320 --> 00:22:22,559
collection

00:22:21,120 --> 00:22:24,880
but you're actually writing into each

00:22:22,559 --> 00:22:25,360
element and because it's mutating you

00:22:24,880 --> 00:22:27,280
need to

00:22:25,360 --> 00:22:28,880
take this as a copy and we would we

00:22:27,280 --> 00:22:30,559
wouldn't be warning here

00:22:28,880 --> 00:22:32,080
similarly when you are passing it to a

00:22:30,559 --> 00:22:34,080
function like taken

00:22:32,080 --> 00:22:36,640
mute which takes the element by

00:22:34,080 --> 00:22:38,400
reference uh the static analysis tools

00:22:36,640 --> 00:22:40,080
would conclude that because that data is

00:22:38,400 --> 00:22:41,120
passed as a reference there is a write

00:22:40,080 --> 00:22:43,039
happening to it

00:22:41,120 --> 00:22:46,480
and it would not ask you to mark this

00:22:43,039 --> 00:22:46,480
element as a const reference

00:22:51,200 --> 00:22:55,360
so the next rule we looked at was

00:22:53,200 --> 00:22:57,679
suggesting using const auto

00:22:55,360 --> 00:22:58,720
instead of auto when signing from a

00:22:57,679 --> 00:23:01,280
reference

00:22:58,720 --> 00:23:03,120
let's look at an example the rust copy

00:23:01,280 --> 00:23:04,880
semantics are explicit so if you have a

00:23:03,120 --> 00:23:07,039
function that returns a reference and if

00:23:04,880 --> 00:23:08,720
you assign that to a variable a

00:23:07,039 --> 00:23:11,760
then the type of that variable is a

00:23:08,720 --> 00:23:14,240
reference and no copy happens in draft

00:23:11,760 --> 00:23:15,120
however in c plus if you use an auto

00:23:14,240 --> 00:23:18,159
keyword

00:23:15,120 --> 00:23:20,159
on a value and if you assign it to a

00:23:18,159 --> 00:23:22,320
function that returns a reference

00:23:20,159 --> 00:23:24,640
then there is an implicit copy happening

00:23:22,320 --> 00:23:26,159
from that reference to that object type

00:23:24,640 --> 00:23:27,760
this is different than if the function

00:23:26,159 --> 00:23:29,360
returns a pointer where the auto

00:23:27,760 --> 00:23:30,799
variable does get the type of the

00:23:29,360 --> 00:23:33,120
pointer

00:23:30,799 --> 00:23:35,120
so some of the ramifications of this is

00:23:33,120 --> 00:23:36,159
it can be confusing to new c plus plus

00:23:35,120 --> 00:23:38,880
users it's

00:23:36,159 --> 00:23:41,120
arguably inconsistent with pointers and

00:23:38,880 --> 00:23:44,480
it's easy to make an expensive copy by

00:23:41,120 --> 00:23:46,559
forgetting the reference on the auto

00:23:44,480 --> 00:23:48,559
so i'm going to demo you a check that we

00:23:46,559 --> 00:23:51,600
uh wrote in visual studio to

00:23:48,559 --> 00:23:52,880
find these views so here you have a

00:23:51,600 --> 00:23:54,559
large truck

00:23:52,880 --> 00:23:56,159
and then you have some struct which

00:23:54,559 --> 00:23:59,200
encapsulates the large truck

00:23:56,159 --> 00:24:02,080
it has a member function that returns

00:23:59,200 --> 00:24:04,320
advanced reference to that large truck

00:24:02,080 --> 00:24:06,480
so in fu what you have is a const

00:24:04,320 --> 00:24:09,679
reference to that sumstruct

00:24:06,480 --> 00:24:11,360
and you're basically calling that a

00:24:09,679 --> 00:24:13,120
member function get large track which

00:24:11,360 --> 00:24:14,559
returns a const reference

00:24:13,120 --> 00:24:16,320
and you're assigning that to a large

00:24:14,559 --> 00:24:17,679
truck and there is an implicit copy

00:24:16,320 --> 00:24:19,679
happening here

00:24:17,679 --> 00:24:21,520
however you're not writing to the large

00:24:19,679 --> 00:24:23,120
truck in the body of the function so our

00:24:21,520 --> 00:24:24,080
analysis tools would flag this as a

00:24:23,120 --> 00:24:26,080
green squiggle

00:24:24,080 --> 00:24:28,240
and it would say hey you're assigning by

00:24:26,080 --> 00:24:29,120
value when a const reference would

00:24:28,240 --> 00:24:31,039
suffice

00:24:29,120 --> 00:24:33,200
use a const autoreference instead so

00:24:31,039 --> 00:24:37,840
what it really wants you to do is

00:24:33,200 --> 00:24:40,320
add a cross here and add a ref here

00:24:37,840 --> 00:24:42,159
and then you should be able to save this

00:24:40,320 --> 00:24:45,200
and you should find that your screen

00:24:42,159 --> 00:24:47,520
squiggles should disappear

00:24:45,200 --> 00:24:48,320
uh this is uh again interesting the next

00:24:47,520 --> 00:24:50,720
case is where

00:24:48,320 --> 00:24:52,720
we have a large struct uh where we are

00:24:50,720 --> 00:24:54,320
passing a reference and there is a copy

00:24:52,720 --> 00:24:56,400
happening implicitly

00:24:54,320 --> 00:24:58,799
uh however you will find that we are

00:24:56,400 --> 00:25:00,720
writing to the field of that struct

00:24:58,799 --> 00:25:02,720
so we are not warning here because we

00:25:00,720 --> 00:25:04,080
are in fact mutating it and the copy is

00:25:02,720 --> 00:25:06,799
necessary

00:25:04,080 --> 00:25:08,320
uh the last example is around lifetimes

00:25:06,799 --> 00:25:08,960
where you have you are calling some

00:25:08,320 --> 00:25:11,520
struct

00:25:08,960 --> 00:25:12,400
which returns a temporary object of type

00:25:11,520 --> 00:25:14,480
some struct

00:25:12,400 --> 00:25:17,039
however it's interesting to note that we

00:25:14,480 --> 00:25:18,400
are not binding this temporary object to

00:25:17,039 --> 00:25:20,000
anything on the left

00:25:18,400 --> 00:25:22,159
what we are instead doing is we are

00:25:20,000 --> 00:25:23,600
calling this member function on that

00:25:22,159 --> 00:25:26,080
temporary object

00:25:23,600 --> 00:25:28,000
get large truck which returns returns a

00:25:26,080 --> 00:25:30,960
const reference to a data

00:25:28,000 --> 00:25:33,200
member of that temporary object and in

00:25:30,960 --> 00:25:35,600
this case a copy is necessary because if

00:25:33,200 --> 00:25:37,039
you mark this as a const reference

00:25:35,600 --> 00:25:38,799
then you are basically going to be

00:25:37,039 --> 00:25:41,279
referring to a

00:25:38,799 --> 00:25:43,600
data member of a temporary object which

00:25:41,279 --> 00:25:44,480
would not be valid after the statement

00:25:43,600 --> 00:25:47,200
is executed

00:25:44,480 --> 00:25:49,440
and that's going to be bad so in this

00:25:47,200 --> 00:25:51,200
case the tool recognizes this pattern

00:25:49,440 --> 00:25:56,000
and it would not ask you to mark this as

00:25:51,200 --> 00:25:57,919
a const reference

00:25:56,000 --> 00:25:59,279
we looked into casting swiss statements

00:25:57,919 --> 00:26:01,039
smarter loops smarter

00:25:59,279 --> 00:26:03,679
copying next we will talk a little bit

00:26:01,039 --> 00:26:06,000
about lifetimes

00:26:03,679 --> 00:26:08,240
the rust memory model makes it hard to

00:26:06,000 --> 00:26:12,480
accidentally leak memory

00:26:08,240 --> 00:26:15,520
uh in uh c plus plus however we have a

00:26:12,480 --> 00:26:18,159
set of rules on the lifetimes profile

00:26:15,520 --> 00:26:20,080
that statically checks as against

00:26:18,159 --> 00:26:21,840
invalidated iterators so if you go to

00:26:20,080 --> 00:26:23,919
the visual studio today

00:26:21,840 --> 00:26:24,880
and if you select the c plus plus code

00:26:23,919 --> 00:26:27,600
check lifetime

00:26:24,880 --> 00:26:29,279
profile from the code analysis you would

00:26:27,600 --> 00:26:31,360
be able to find these errors

00:26:29,279 --> 00:26:32,640
errors in your code however it's

00:26:31,360 --> 00:26:35,039
interesting to note that

00:26:32,640 --> 00:26:36,559
when we when we dug a little deeper into

00:26:35,039 --> 00:26:38,640
what sort of lifetime checks are

00:26:36,559 --> 00:26:40,559
available today across the tool chain

00:26:38,640 --> 00:26:42,159
here is one particular rule where we

00:26:40,559 --> 00:26:43,200
didn't find a check from any of the

00:26:42,159 --> 00:26:46,000
tools like

00:26:43,200 --> 00:26:47,440
here's a guideline that says uh you know

00:26:46,000 --> 00:26:49,039
no checks for never

00:26:47,440 --> 00:26:50,799
there are no checks for never returning

00:26:49,039 --> 00:26:52,000
a pointer to a local so here is an

00:26:50,799 --> 00:26:55,039
example where you're trying to

00:26:52,000 --> 00:26:56,480
build up the contents of this vector and

00:26:55,039 --> 00:26:58,559
what you're doing is you're

00:26:56,480 --> 00:27:00,480
pushing in the address of a local on

00:26:58,559 --> 00:27:02,080
this collection so obviously after this

00:27:00,480 --> 00:27:03,919
function returns this address would

00:27:02,080 --> 00:27:06,159
point to invalid memory

00:27:03,919 --> 00:27:07,919
and none of the existing lifetime

00:27:06,159 --> 00:27:09,520
checkers were able to find this pattern

00:27:07,919 --> 00:27:11,840
so there's definitely scope for

00:27:09,520 --> 00:27:12,799
improvement uh where we would need to

00:27:11,840 --> 00:27:15,120
detect these

00:27:12,799 --> 00:27:17,039
kinds of needs in in the static analysis

00:27:15,120 --> 00:27:20,320
tools

00:27:17,039 --> 00:27:23,520
so i would like to demo you a lifetime

00:27:20,320 --> 00:27:25,679
of check for invalid iterators so here

00:27:23,520 --> 00:27:26,480
is a dangling iterator pattern where you

00:27:25,679 --> 00:27:29,600
have a vector

00:27:26,480 --> 00:27:29,840
it has three elements and you are taking

00:27:29,600 --> 00:27:31,679
an

00:27:29,840 --> 00:27:33,440
iterator on this which is pointing to

00:27:31,679 --> 00:27:34,799
the beginning of the vector

00:27:33,440 --> 00:27:37,200
and what you're doing is you're trying

00:27:34,799 --> 00:27:40,000
to dereference the iterator and write

00:27:37,200 --> 00:27:40,640
write write to it via the iterator and

00:27:40,000 --> 00:27:42,880
this

00:27:40,640 --> 00:27:43,679
is fine because the memory is still

00:27:42,880 --> 00:27:45,840
valid

00:27:43,679 --> 00:27:48,000
however on line eight you would see that

00:27:45,840 --> 00:27:49,200
you are doing a push back operation on

00:27:48,000 --> 00:27:51,039
that vector

00:27:49,200 --> 00:27:52,559
and when you do the push back the memory

00:27:51,039 --> 00:27:54,559
layout changes

00:27:52,559 --> 00:27:56,000
so what it means is that iterator is no

00:27:54,559 --> 00:27:58,399
longer

00:27:56,000 --> 00:28:00,080
pointing to a valid piece of memory so

00:27:58,399 --> 00:28:01,679
when you're trying to dereference that

00:28:00,080 --> 00:28:03,200
iterator and write through it

00:28:01,679 --> 00:28:05,120
you'll get a green squiggle that says

00:28:03,200 --> 00:28:06,320
hey don't dereference a pointer that may

00:28:05,120 --> 00:28:08,640
be invalid

00:28:06,320 --> 00:28:11,520
and it will tell you that in line eight

00:28:08,640 --> 00:28:14,080
uh this result may have been invalidated

00:28:11,520 --> 00:28:16,480
so what you really need to do here is

00:28:14,080 --> 00:28:19,679
you have to uh

00:28:16,480 --> 00:28:20,960
assign this iterator to the begin block

00:28:19,679 --> 00:28:22,960
again

00:28:20,960 --> 00:28:24,320
and that way it will point to a valid

00:28:22,960 --> 00:28:26,480
piece of memory again

00:28:24,320 --> 00:28:28,000
and so when you save your work you

00:28:26,480 --> 00:28:30,320
should be able to see that

00:28:28,000 --> 00:28:32,640
this warning from the live types profile

00:28:30,320 --> 00:28:34,559
should disappear

00:28:32,640 --> 00:28:36,399
these checks are already available in

00:28:34,559 --> 00:28:37,679
visual studio today so you can go to

00:28:36,399 --> 00:28:40,880
your project

00:28:37,679 --> 00:28:43,600
you can go to properties

00:28:40,880 --> 00:28:45,360
and you can select the c plus score

00:28:43,600 --> 00:28:48,240
check lifetime rules from

00:28:45,360 --> 00:28:48,240
code analysis

00:28:53,279 --> 00:28:59,760
all right so we covered lifetimes next

00:28:55,279 --> 00:29:02,640
we'll talk a little bit about mutability

00:28:59,760 --> 00:29:04,159
so rust is immutable by default what it

00:29:02,640 --> 00:29:05,919
means is that if you have a variable

00:29:04,159 --> 00:29:07,520
that's a size that has assigned a value

00:29:05,919 --> 00:29:10,159
of three and if you're trying to do

00:29:07,520 --> 00:29:11,679
a assigned class on that same variable

00:29:10,159 --> 00:29:15,039
that's an error in rust

00:29:11,679 --> 00:29:16,960
because a is immutable by default uh

00:29:15,039 --> 00:29:20,000
if you want to mark it as mutable you

00:29:16,960 --> 00:29:22,240
have to use an explicit keyboard in rust

00:29:20,000 --> 00:29:24,240
the second interesting thing i noticed

00:29:22,240 --> 00:29:25,360
about rust is it forbids having a

00:29:24,240 --> 00:29:28,159
mutable and an

00:29:25,360 --> 00:29:29,679
immutable reference to the same object

00:29:28,159 --> 00:29:32,000
in the same scope

00:29:29,679 --> 00:29:33,600
and by avoiding a mutable and immutable

00:29:32,000 --> 00:29:35,520
reference rust can help

00:29:33,600 --> 00:29:36,799
make certain guarantees around data

00:29:35,520 --> 00:29:38,480
ray's safety

00:29:36,799 --> 00:29:40,000
so here's an example where you have a

00:29:38,480 --> 00:29:42,799
variable which has a value 3

00:29:40,000 --> 00:29:44,960
you have a immutable reference to it and

00:29:42,799 --> 00:29:46,640
then you have a mutable reference to it

00:29:44,960 --> 00:29:48,880
and then you're incrementing its value

00:29:46,640 --> 00:29:51,919
via the mutable reference

00:29:48,880 --> 00:29:53,679
next when you try to pass the

00:29:51,919 --> 00:29:55,919
immutable reference the const reference

00:29:53,679 --> 00:29:57,679
to your function a rough compiler would

00:29:55,919 --> 00:29:59,120
complain saying hey you're borrowing an

00:29:57,679 --> 00:30:01,120
immutable version

00:29:59,120 --> 00:30:05,120
while it's mutated above and that's

00:30:01,120 --> 00:30:08,159
invalid it does not allow you to do that

00:30:05,120 --> 00:30:10,080
in c plus marking an immutable data as

00:30:08,159 --> 00:30:11,279
const is viewed as a good programming

00:30:10,080 --> 00:30:13,600
practice

00:30:11,279 --> 00:30:14,559
a few years back we rolled out a series

00:30:13,600 --> 00:30:16,720
of checks for

00:30:14,559 --> 00:30:18,399
const correctness so all those tricks

00:30:16,720 --> 00:30:20,320
are part of the c plus plus core check

00:30:18,399 --> 00:30:22,000
rules in visual studio

00:30:20,320 --> 00:30:24,000
an example would be like you're

00:30:22,000 --> 00:30:25,679
assigning to a variable only once in

00:30:24,000 --> 00:30:26,320
your function if you're doing that we

00:30:25,679 --> 00:30:28,240
would

00:30:26,320 --> 00:30:29,360
encourage you to mark that variable as a

00:30:28,240 --> 00:30:31,520
const

00:30:29,360 --> 00:30:32,480
uh however i wanted to revisit this

00:30:31,520 --> 00:30:34,640
example from

00:30:32,480 --> 00:30:36,399
uh rust where we're trying to access

00:30:34,640 --> 00:30:37,200
mutable and immutable reference in the

00:30:36,399 --> 00:30:39,440
same scope

00:30:37,200 --> 00:30:41,440
a same code written in c plus clauses

00:30:39,440 --> 00:30:43,520
variable assigned to value three

00:30:41,440 --> 00:30:45,039
you have a mutable reference and a const

00:30:43,520 --> 00:30:46,880
reference to that variable

00:30:45,039 --> 00:30:48,320
you're incrementing its value via the

00:30:46,880 --> 00:30:50,080
mutable reference and then you're

00:30:48,320 --> 00:30:51,360
printing its value via the cost

00:30:50,080 --> 00:30:53,520
reference so

00:30:51,360 --> 00:30:55,600
um a question remains do you really

00:30:53,520 --> 00:30:58,320
expect to see a four here

00:30:55,600 --> 00:31:00,320
and uh it can be argued that that may be

00:30:58,320 --> 00:31:02,080
your reasonable addition to the checks

00:31:00,320 --> 00:31:04,320
where you see this pattern

00:31:02,080 --> 00:31:05,120
you may be you want to highlight this

00:31:04,320 --> 00:31:07,279
and uh

00:31:05,120 --> 00:31:09,039
say that hey did you really mean that so

00:31:07,279 --> 00:31:10,480
that's a check again that does not exist

00:31:09,039 --> 00:31:12,640
today but that's something worth

00:31:10,480 --> 00:31:15,039
exploring

00:31:12,640 --> 00:31:16,480
so i wanted to summarize uh the exercise

00:31:15,039 --> 00:31:18,559
that we just did here

00:31:16,480 --> 00:31:20,960
so we tried bridging the graph the gap

00:31:18,559 --> 00:31:21,360
between the two languages we identified

00:31:20,960 --> 00:31:24,080
the

00:31:21,360 --> 00:31:26,240
actionable safety differences uh we

00:31:24,080 --> 00:31:27,519
covered the big buckets of safety and

00:31:26,240 --> 00:31:30,559
correctness

00:31:27,519 --> 00:31:32,559
uh we also explored rules from c plus

00:31:30,559 --> 00:31:35,840
plus core guidelines that cover

00:31:32,559 --> 00:31:37,760
many of the big buckets we looked at

00:31:35,840 --> 00:31:39,519
we looked what exists in visual studio

00:31:37,760 --> 00:31:41,760
code analysis today and for

00:31:39,519 --> 00:31:44,559
missing uh checks we tried adding them

00:31:41,760 --> 00:31:46,559
in in the latest preview

00:31:44,559 --> 00:31:48,480
obviously we also identified more work

00:31:46,559 --> 00:31:49,279
that is needed in the tool chain so we

00:31:48,480 --> 00:31:51,679
could be

00:31:49,279 --> 00:31:52,640
uh doing more checks in the loops like

00:31:51,679 --> 00:31:55,039
we could identify

00:31:52,640 --> 00:31:56,720
for example loop in variance and suggest

00:31:55,039 --> 00:31:58,960
moving them out of loops

00:31:56,720 --> 00:32:00,399
we could be improving our lifetime

00:31:58,960 --> 00:32:03,519
checks that we have in the c

00:32:00,399 --> 00:32:03,919
plus uh lifetime profile uh similarly we

00:32:03,519 --> 00:32:06,159
could

00:32:03,919 --> 00:32:07,600
add checks around borrowing whenever c

00:32:06,159 --> 00:32:10,960
or borrowing semantics in c

00:32:07,600 --> 00:32:13,200
plus and lastly i also wanted to uh

00:32:10,960 --> 00:32:15,200
talk about this where uh you know we

00:32:13,200 --> 00:32:16,080
really what we are missing today is a

00:32:15,200 --> 00:32:18,640
strict mode

00:32:16,080 --> 00:32:19,440
in the compiler uh that would enforce

00:32:18,640 --> 00:32:21,760
some sort of

00:32:19,440 --> 00:32:23,679
safety guarantees that compile time like

00:32:21,760 --> 00:32:24,880
you have all these checks spread across

00:32:23,679 --> 00:32:27,600
the tool chin

00:32:24,880 --> 00:32:28,000
however it's also easy for a developer

00:32:27,600 --> 00:32:30,080
to go

00:32:28,000 --> 00:32:31,600
and turn these rules off so the code

00:32:30,080 --> 00:32:33,039
that you run and you ship

00:32:31,600 --> 00:32:34,880
doesn't have any sort of safety

00:32:33,039 --> 00:32:36,559
guarantees it depends on

00:32:34,880 --> 00:32:37,919
what checks you run your income file

00:32:36,559 --> 00:32:39,760
time so

00:32:37,919 --> 00:32:41,279
it's interesting to think about a strict

00:32:39,760 --> 00:32:43,120
mode in the compiler

00:32:41,279 --> 00:32:44,480
where you would not be able to turn some

00:32:43,120 --> 00:32:46,880
of these rules

00:32:44,480 --> 00:32:50,240
off however what you get as a result of

00:32:46,880 --> 00:32:52,880
that is you get some safety guarantees

00:32:50,240 --> 00:32:54,880
next i wanted to share some data from

00:32:52,880 --> 00:32:57,039
microsoft production code

00:32:54,880 --> 00:32:58,159
we run the static analysis tools in

00:32:57,039 --> 00:33:01,039
microsoft uh

00:32:58,159 --> 00:33:03,120
on millions of lines of shipping cc plus

00:33:01,039 --> 00:33:05,320
plus code and from time to time

00:33:03,120 --> 00:33:07,200
we find interesting bug patterns

00:33:05,320 --> 00:33:09,679
vulnerabilities uh

00:33:07,200 --> 00:33:12,960
logical errors so it's always fun to

00:33:09,679 --> 00:33:15,200
come back and talk about these patterns

00:33:12,960 --> 00:33:16,960
so next i'm going to share a security

00:33:15,200 --> 00:33:19,120
vulnerability we

00:33:16,960 --> 00:33:20,720
found in one of the production software

00:33:19,120 --> 00:33:22,720
at microsoft recently

00:33:20,720 --> 00:33:24,399
so you have a message handling function

00:33:22,720 --> 00:33:26,559
that receives memory

00:33:24,399 --> 00:33:27,760
and you have two parameters speed data

00:33:26,559 --> 00:33:30,320
and cv data

00:33:27,760 --> 00:33:32,399
which are like the destination buffer uh

00:33:30,320 --> 00:33:33,600
receiving the memory and cp data would

00:33:32,399 --> 00:33:35,200
be the count of

00:33:33,600 --> 00:33:36,720
bytes of data copied into the

00:33:35,200 --> 00:33:40,080
destination buffer

00:33:36,720 --> 00:33:42,960
and you have here uh two variables p

00:33:40,080 --> 00:33:43,840
name data and cd name data which are the

00:33:42,960 --> 00:33:45,760
source buffer

00:33:43,840 --> 00:33:48,320
and the count of bytes on that source

00:33:45,760 --> 00:33:51,039
buffer you have a call to this

00:33:48,320 --> 00:33:52,960
api called get memory and get memory

00:33:51,039 --> 00:33:56,720
fills in your source buffer

00:33:52,960 --> 00:33:59,039
with uh the count of bytes of uh

00:33:56,720 --> 00:33:59,760
elements of data that is copied into the

00:33:59,039 --> 00:34:01,440
source

00:33:59,760 --> 00:34:03,279
and then you're trying to use the v32

00:34:01,440 --> 00:34:06,080
api to copy

00:34:03,279 --> 00:34:07,279
uh memory data from the source buffer

00:34:06,080 --> 00:34:10,480
into the destination

00:34:07,279 --> 00:34:12,320
and you're copying cb data and you are

00:34:10,480 --> 00:34:13,599
actually copying it from an offset which

00:34:12,320 --> 00:34:14,879
is current pen position

00:34:13,599 --> 00:34:17,040
and you're incrementing that current

00:34:14,879 --> 00:34:18,800
main position here you get a static

00:34:17,040 --> 00:34:20,560
analysis spawning that says

00:34:18,800 --> 00:34:22,079
hey you have a potential read overflow

00:34:20,560 --> 00:34:24,159
using team data

00:34:22,079 --> 00:34:25,280
the buffer is apparently unbounded by

00:34:24,159 --> 00:34:27,919
buffer size why

00:34:25,280 --> 00:34:28,720
because premium data has cd mem data

00:34:27,919 --> 00:34:31,200
elements

00:34:28,720 --> 00:34:32,240
however you're copying cb data here from

00:34:31,200 --> 00:34:34,560
an offset

00:34:32,240 --> 00:34:37,200
and you don't know whether uh you can

00:34:34,560 --> 00:34:38,879
copy cv data elements from this offset

00:34:37,200 --> 00:34:41,200
whether that's within the bounds of cd

00:34:38,879 --> 00:34:43,040
mem data so what you in fact have is

00:34:41,200 --> 00:34:45,359
we added a check to check for that

00:34:43,040 --> 00:34:47,599
bounce and then this static analysis

00:34:45,359 --> 00:34:49,200
warning should disappear

00:34:47,599 --> 00:34:51,040
this function still has a problem which

00:34:49,200 --> 00:34:53,440
is the main vulnerability here

00:34:51,040 --> 00:34:55,440
the copy memory is not checking the

00:34:53,440 --> 00:34:57,839
bounds of the destination buffer

00:34:55,440 --> 00:34:59,119
so what you result in is a missing

00:34:57,839 --> 00:35:01,040
bounce check here

00:34:59,119 --> 00:35:02,960
before the call to copy memory has

00:35:01,040 --> 00:35:04,079
resulted in a remote code execution

00:35:02,960 --> 00:35:06,960
vulnerability

00:35:04,079 --> 00:35:08,079
so how did we mitigate that it turns out

00:35:06,960 --> 00:35:10,400
if you're using uh

00:35:08,079 --> 00:35:11,359
c plus plus modern types if you're using

00:35:10,400 --> 00:35:13,760
safe types

00:35:11,359 --> 00:35:15,359
you can mitigate that even even without

00:35:13,760 --> 00:35:16,960
fixing the actual problem

00:35:15,359 --> 00:35:18,960
which is what i'll show you in my next

00:35:16,960 --> 00:35:21,520
slide so if you look at

00:35:18,960 --> 00:35:22,400
the security vulnerability mitigation

00:35:21,520 --> 00:35:25,839
you will find

00:35:22,400 --> 00:35:26,560
that in this new function i receive

00:35:25,839 --> 00:35:28,160
memory

00:35:26,560 --> 00:35:30,880
we have first changed the destination

00:35:28,160 --> 00:35:32,880
buffer to be your span this is a span

00:35:30,880 --> 00:35:35,920
for those of you that are not familiar

00:35:32,880 --> 00:35:39,359
is uh it basically is a pointer

00:35:35,920 --> 00:35:42,079
and a length into a sequence of bytes

00:35:39,359 --> 00:35:44,960
so by making it a span we can always

00:35:42,079 --> 00:35:47,839
know what the length of this data is

00:35:44,960 --> 00:35:49,839
next we changed the type of the source

00:35:47,839 --> 00:35:51,839
buffer to be a span as well

00:35:49,839 --> 00:35:53,599
then we did the usual stuff we got

00:35:51,839 --> 00:35:56,400
memory on that mem data

00:35:53,599 --> 00:35:57,359
we asserted that the memory we got was

00:35:56,400 --> 00:35:59,520
actually

00:35:57,359 --> 00:36:01,200
valid then we tried to check for the

00:35:59,520 --> 00:36:03,920
readable length we made sure

00:36:01,200 --> 00:36:04,640
that you can beat from here successfully

00:36:03,920 --> 00:36:07,119
and then

00:36:04,640 --> 00:36:08,079
we created a subspan from the source

00:36:07,119 --> 00:36:10,079
buffer

00:36:08,079 --> 00:36:11,200
where we wanted to create this substrate

00:36:10,079 --> 00:36:13,119
from the offset

00:36:11,200 --> 00:36:14,560
and we wanted to create this span of

00:36:13,119 --> 00:36:16,240
lens cb data

00:36:14,560 --> 00:36:17,920
and then we passed this to a function

00:36:16,240 --> 00:36:20,560
called gsl copy

00:36:17,920 --> 00:36:20,960
and what this function does is it tries

00:36:20,560 --> 00:36:23,599
to

00:36:20,960 --> 00:36:25,280
check that the size of the buffer

00:36:23,599 --> 00:36:27,280
pointed to by data

00:36:25,280 --> 00:36:29,119
is greater than or equal to the size of

00:36:27,280 --> 00:36:29,920
the source buffer and if the size is

00:36:29,119 --> 00:36:32,160
smaller

00:36:29,920 --> 00:36:34,160
then it would terminate the program so

00:36:32,160 --> 00:36:35,200
if you're using these types safely what

00:36:34,160 --> 00:36:37,599
you can do is

00:36:35,200 --> 00:36:38,880
by moving to the gsl types we now

00:36:37,599 --> 00:36:41,520
mitigated this

00:36:38,880 --> 00:36:43,359
security vulnerability change that from

00:36:41,520 --> 00:36:46,720
a remote code execution

00:36:43,359 --> 00:36:50,160
to a denial of service which is a lot

00:36:46,720 --> 00:36:53,680
more preferred state to be

00:36:50,160 --> 00:36:54,160
for our software so the second example i

00:36:53,680 --> 00:36:57,760
have

00:36:54,160 --> 00:36:58,480
here is uh for performance so here is an

00:36:57,760 --> 00:37:01,599
example

00:36:58,480 --> 00:37:03,920
uh again where you had this common table

00:37:01,599 --> 00:37:04,880
it's a really expensive type it has lots

00:37:03,920 --> 00:37:07,760
of

00:37:04,880 --> 00:37:09,040
fields in it and you're iterating using

00:37:07,760 --> 00:37:11,520
a range for loop

00:37:09,040 --> 00:37:12,400
and if you inspect the body of the loop

00:37:11,520 --> 00:37:14,720
you would find

00:37:12,400 --> 00:37:15,920
that the only thing that you are doing

00:37:14,720 --> 00:37:18,640
here is

00:37:15,920 --> 00:37:19,520
you're accessing uh some elements from

00:37:18,640 --> 00:37:22,320
item

00:37:19,520 --> 00:37:23,920
and you are then uh manipulating that

00:37:22,320 --> 00:37:26,880
data and returning the value

00:37:23,920 --> 00:37:29,520
there is no mutation happening here on

00:37:26,880 --> 00:37:31,200
the item so this is an expensive copy

00:37:29,520 --> 00:37:33,359
which would result in less performant

00:37:31,200 --> 00:37:35,119
code so static analysis would come in

00:37:33,359 --> 00:37:36,000
here and it would say hey you really

00:37:35,119 --> 00:37:40,079
ought to mark this

00:37:36,000 --> 00:37:40,079
item as a const auto ref

00:37:40,320 --> 00:37:44,880
so i wanted to talk about where we are

00:37:42,400 --> 00:37:47,760
today uh in terms of our tooling

00:37:44,880 --> 00:37:49,200
so static analysis tools have been in

00:37:47,760 --> 00:37:51,760
use at microsoft for

00:37:49,200 --> 00:37:54,240
close to two decades it's used to

00:37:51,760 --> 00:37:57,599
validate millions of lines of production

00:37:54,240 --> 00:37:59,760
c plus code day in and day out and

00:37:57,599 --> 00:38:00,880
uh some of the checks uh in fact all of

00:37:59,760 --> 00:38:03,440
the checks that i demo

00:38:00,880 --> 00:38:06,079
today uh are available in the latest

00:38:03,440 --> 00:38:08,960
version of visual studio 2019

00:38:06,079 --> 00:38:10,720
uh you can run these tools by uh using

00:38:08,960 --> 00:38:13,040
visual studio ide

00:38:10,720 --> 00:38:14,800
uh the checks will run in the background

00:38:13,040 --> 00:38:15,760
as you're working on your project and

00:38:14,800 --> 00:38:18,400
they would show up as

00:38:15,760 --> 00:38:20,400
green squiggles and it'll point to the

00:38:18,400 --> 00:38:21,920
problem in your code

00:38:20,400 --> 00:38:23,599
and once you fix the code the green

00:38:21,920 --> 00:38:25,760
squiggles should disappear

00:38:23,599 --> 00:38:26,960
we also have a limited number of uh

00:38:25,760 --> 00:38:29,599
fixits uh

00:38:26,960 --> 00:38:31,520
for a limited number of checks uh if we

00:38:29,599 --> 00:38:32,000
get good feedback that's also something

00:38:31,520 --> 00:38:35,520
we are

00:38:32,000 --> 00:38:37,680
open to adding in the ide experience

00:38:35,520 --> 00:38:38,640
you can also run code analysis as an

00:38:37,680 --> 00:38:41,200
explicit task

00:38:38,640 --> 00:38:41,760
so you can run it on file or on a

00:38:41,200 --> 00:38:44,320
project

00:38:41,760 --> 00:38:46,480
or on your solution similarly you can

00:38:44,320 --> 00:38:47,760
also configure code analysis to run in

00:38:46,480 --> 00:38:50,240
your build system whether

00:38:47,760 --> 00:38:51,839
you're using cmake or ms build or n

00:38:50,240 --> 00:38:53,839
makes time projects

00:38:51,839 --> 00:38:55,760
ultimately code analysis takes in a

00:38:53,839 --> 00:38:58,079
bunch of additional options to your

00:38:55,760 --> 00:39:00,240
compiler command line so you can always

00:38:58,079 --> 00:39:03,040
configure your build systems to run code

00:39:00,240 --> 00:39:05,359
analysis as you're building your project

00:39:03,040 --> 00:39:07,200
now in terms of how we uh do these

00:39:05,359 --> 00:39:09,599
checks uh simple checks are

00:39:07,200 --> 00:39:10,880
built upon an abstract syntax tree or an

00:39:09,599 --> 00:39:13,200
asd layer

00:39:10,880 --> 00:39:14,800
and we have a plug-in model for writing

00:39:13,200 --> 00:39:18,000
checks that consume the

00:39:14,800 --> 00:39:20,079
data from your program that's compiled

00:39:18,000 --> 00:39:22,640
by the cc plus plus front end

00:39:20,079 --> 00:39:24,160
right now this plug-in model is not

00:39:22,640 --> 00:39:26,480
exposed externally

00:39:24,160 --> 00:39:28,079
but i have uh i'll be talking more about

00:39:26,480 --> 00:39:29,520
this in my next slide

00:39:28,079 --> 00:39:30,880
if there is enough interest in the

00:39:29,520 --> 00:39:32,880
community that's something we can

00:39:30,880 --> 00:39:34,960
definitely look into

00:39:32,880 --> 00:39:37,200
and some of the checks require uh data

00:39:34,960 --> 00:39:39,520
flow and path sensitive analysis

00:39:37,200 --> 00:39:42,000
again the this for path sensitive we

00:39:39,520 --> 00:39:44,800
have a cfg or a control slow class there

00:39:42,000 --> 00:39:46,800
on top of the asds and we have a lot of

00:39:44,800 --> 00:39:47,599
libraries doing things like alias

00:39:46,800 --> 00:39:50,079
analysis

00:39:47,599 --> 00:39:51,760
uh we have a constraint solver to do

00:39:50,079 --> 00:39:53,920
part simulation correctly

00:39:51,760 --> 00:39:55,599
and there's been like 10 plus years of

00:39:53,920 --> 00:39:56,400
research that has gone into this

00:39:55,599 --> 00:39:58,079
framework

00:39:56,400 --> 00:39:59,839
again it's not something that's uh

00:39:58,079 --> 00:40:02,640
available to you

00:39:59,839 --> 00:40:04,240
as an uh today but that's something i

00:40:02,640 --> 00:40:05,520
would love to get some feedback on if

00:40:04,240 --> 00:40:06,560
there is enough interest we can

00:40:05,520 --> 00:40:08,960
definitely

00:40:06,560 --> 00:40:10,160
uh talk to the lawyers and and make it

00:40:08,960 --> 00:40:13,280
available uh

00:40:10,160 --> 00:40:15,680
for the community uh so what's next for

00:40:13,280 --> 00:40:18,000
microsoft c plus plus static analysis

00:40:15,680 --> 00:40:20,000
we definitely want to drive uh more safe

00:40:18,000 --> 00:40:21,119
c plus plus policies using static

00:40:20,000 --> 00:40:23,920
analysis

00:40:21,119 --> 00:40:25,760
uh there are a whole bunch of security

00:40:23,920 --> 00:40:27,520
rules that will be coming out uh

00:40:25,760 --> 00:40:29,680
in the next review that would catch

00:40:27,520 --> 00:40:32,240
misuses of variance

00:40:29,680 --> 00:40:34,560
enums h result value types so those

00:40:32,240 --> 00:40:36,960
checks are already in the pipeline

00:40:34,560 --> 00:40:38,720
uh we also want to roll out high

00:40:36,960 --> 00:40:41,599
fidelity rules for

00:40:38,720 --> 00:40:42,800
uh detecting uh memory errors so

00:40:41,599 --> 00:40:45,200
anything we can do for

00:40:42,800 --> 00:40:46,000
bound safety we would be adding those

00:40:45,200 --> 00:40:48,079
checks if

00:40:46,000 --> 00:40:50,079
you see a pattern in code where you have

00:40:48,079 --> 00:40:52,240
a raw pointer and a length

00:40:50,079 --> 00:40:54,240
and if you can if you can safely replace

00:40:52,240 --> 00:40:56,400
that with esl spam we would have rules

00:40:54,240 --> 00:40:59,119
that will suggest you to move to a spam

00:40:56,400 --> 00:41:01,040
or for those kinds of code we also want

00:40:59,119 --> 00:41:02,720
to improve our lifetime checking we've

00:41:01,040 --> 00:41:04,400
got feedback where there

00:41:02,720 --> 00:41:06,000
are certain classes of false positives

00:41:04,400 --> 00:41:09,680
that we need to fix and

00:41:06,000 --> 00:41:11,839
like i said uh rust has a lot of cases

00:41:09,680 --> 00:41:14,079
on lifetimes and borrowing that we could

00:41:11,839 --> 00:41:15,839
build into the c plus lifetime profile

00:41:14,079 --> 00:41:17,040
so we'll definitely be investing in that

00:41:15,839 --> 00:41:19,200
going forward

00:41:17,040 --> 00:41:21,520
the other objective for us is to meet

00:41:19,200 --> 00:41:23,599
the tuning needs of the community

00:41:21,520 --> 00:41:24,960
uh as the language evolves so for

00:41:23,599 --> 00:41:28,240
example with c

00:41:24,960 --> 00:41:28,800
plus plus 20 we re-implemented the gsl

00:41:28,240 --> 00:41:31,200
span

00:41:28,800 --> 00:41:33,359
in our guideline support library so that

00:41:31,200 --> 00:41:37,040
it's compliant with the standard span

00:41:33,359 --> 00:41:38,800
uh we also rolled out a bunch of rules

00:41:37,040 --> 00:41:41,359
when you're using code routines which is

00:41:38,800 --> 00:41:43,280
another c plus plus 20 features because

00:41:41,359 --> 00:41:45,440
turns out when you use code routines you

00:41:43,280 --> 00:41:47,119
can run into interesting problems around

00:41:45,440 --> 00:41:49,359
concurrency errors

00:41:47,119 --> 00:41:51,040
around lifetimes and we've added a bunch

00:41:49,359 --> 00:41:53,200
of checks in visual studio

00:41:51,040 --> 00:41:55,440
that would find these issues for you

00:41:53,200 --> 00:41:57,200
when you're using a new language feature

00:41:55,440 --> 00:41:58,560
so as the language evolves we want to

00:41:57,200 --> 00:42:01,119
make sure that

00:41:58,560 --> 00:42:02,560
we can detect any misuses of any new

00:42:01,119 --> 00:42:03,200
features that get rolled into the

00:42:02,560 --> 00:42:05,040
language

00:42:03,200 --> 00:42:06,480
and will continue investing there going

00:42:05,040 --> 00:42:08,720
forward

00:42:06,480 --> 00:42:10,319
the other library we care deeply about

00:42:08,720 --> 00:42:12,400
is the microsoft guideline support

00:42:10,319 --> 00:42:14,720
library so this library had the initial

00:42:12,400 --> 00:42:15,839
implementation of gsl span which played

00:42:14,720 --> 00:42:18,160
a big part

00:42:15,839 --> 00:42:19,040
in the standardization of span this

00:42:18,160 --> 00:42:21,839
library has

00:42:19,040 --> 00:42:22,560
types that allow you to mark uh types is

00:42:21,839 --> 00:42:24,800
not null

00:42:22,560 --> 00:42:26,240
and if you are then uh seeing a null

00:42:24,800 --> 00:42:28,480
value we would error

00:42:26,240 --> 00:42:30,480
through an error at runtime it allows

00:42:28,480 --> 00:42:31,680
you to use narrow and narrow cast it

00:42:30,480 --> 00:42:34,240
allows you to uh

00:42:31,680 --> 00:42:36,800
use finally constructs where it's a

00:42:34,240 --> 00:42:38,640
typical rei pattern of error handling

00:42:36,800 --> 00:42:40,319
where you can do the cleanup in the

00:42:38,640 --> 00:42:41,440
finally so it already provides a whole

00:42:40,319 --> 00:42:43,520
bunch of types

00:42:41,440 --> 00:42:44,480
and you're also looking into uh adding

00:42:43,520 --> 00:42:47,119
new types that

00:42:44,480 --> 00:42:48,960
people uh talk about we have a pretty

00:42:47,119 --> 00:42:49,920
active github community so recently

00:42:48,960 --> 00:42:52,000
there have been

00:42:49,920 --> 00:42:52,960
conversations about stack arrays and

00:42:52,000 --> 00:42:54,720
dying arrays

00:42:52,960 --> 00:42:56,400
so we are considering uh writing

00:42:54,720 --> 00:42:57,839
proposals and

00:42:56,400 --> 00:43:00,720
if we do come up with that it will show

00:42:57,839 --> 00:43:02,480
up in the microsoft gsl library so

00:43:00,720 --> 00:43:03,839
that's another thing we would invest we

00:43:02,480 --> 00:43:06,079
will be investing in

00:43:03,839 --> 00:43:06,880
and finally uh we are investigating

00:43:06,079 --> 00:43:08,720
opening up the

00:43:06,880 --> 00:43:10,400
cloud analysis architecture to third

00:43:08,720 --> 00:43:12,240
party plugins again

00:43:10,400 --> 00:43:13,680
please reach out to us and share your

00:43:12,240 --> 00:43:15,839
feedback on this

00:43:13,680 --> 00:43:17,440
uh we would uh build this framework on

00:43:15,839 --> 00:43:19,200
top of modern asd api

00:43:17,440 --> 00:43:21,200
you will have libraries that would allow

00:43:19,200 --> 00:43:22,319
you to write pattern matching or tree

00:43:21,200 --> 00:43:24,400
walking

00:43:22,319 --> 00:43:25,359
and uh if it deserves value in having

00:43:24,400 --> 00:43:28,240
this platform

00:43:25,359 --> 00:43:29,920
accessible to the community i would

00:43:28,240 --> 00:43:31,680
encourage you to provide us with that

00:43:29,920 --> 00:43:32,880
feedback so that it can help with the

00:43:31,680 --> 00:43:34,640
prioritization

00:43:32,880 --> 00:43:38,240
as we are working on the next set of

00:43:34,640 --> 00:43:38,240
tooling for static analysis

00:43:38,720 --> 00:43:42,880
and finally i would uh you know request

00:43:41,119 --> 00:43:45,359
all of you to join the fun

00:43:42,880 --> 00:43:46,000
give us feedback give us suggestions we

00:43:45,359 --> 00:43:48,560
take the

00:43:46,000 --> 00:43:50,319
feedback that comes through in the you

00:43:48,560 --> 00:43:51,280
know visual studio developer community

00:43:50,319 --> 00:43:54,480
very seriously

00:43:51,280 --> 00:43:55,520
so anything uh that you don't like let

00:43:54,480 --> 00:43:57,920
us know

00:43:55,520 --> 00:44:00,079
also you can reach out reach out to us

00:43:57,920 --> 00:44:01,839
uh via twitter we have a pretty active

00:44:00,079 --> 00:44:04,960
twitter handle for visual c

00:44:01,839 --> 00:44:05,680
plus and i'll be available in the slack

00:44:04,960 --> 00:44:07,839
to answer

00:44:05,680 --> 00:44:09,520
any questions that you have on my talk

00:44:07,839 --> 00:44:12,079
so feel free to reach out to me

00:44:09,520 --> 00:44:13,200
and also i would request all of you to

00:44:12,079 --> 00:44:15,520
contribute

00:44:13,200 --> 00:44:18,000
uh it can be an idea on a check or it

00:44:15,520 --> 00:44:19,920
can be some bug reports uh some fixes in

00:44:18,000 --> 00:44:21,920
our gsl library it could be

00:44:19,920 --> 00:44:24,000
you know missing test frameworks are any

00:44:21,920 --> 00:44:26,319
ideas you have on how we can make

00:44:24,000 --> 00:44:28,560
uh you know checking of code better at

00:44:26,319 --> 00:44:30,319
compile time i would be very interested

00:44:28,560 --> 00:44:32,319
in listening to those ideas so

00:44:30,319 --> 00:44:33,520
uh my request to all of you would be to

00:44:32,319 --> 00:44:36,319
uh give us that

00:44:33,520 --> 00:44:38,160
feedback to contribute and i've also

00:44:36,319 --> 00:44:39,440
provided a bunch of resources here that

00:44:38,160 --> 00:44:42,240
you can refer back to

00:44:39,440 --> 00:44:43,839
after my talk uh c plus plus team blog

00:44:42,240 --> 00:44:45,040
is definitely the big one where

00:44:43,839 --> 00:44:46,880
everything that we do

00:44:45,040 --> 00:44:48,160
all the announcements get made here in

00:44:46,880 --> 00:44:50,560
the blog so

00:44:48,160 --> 00:44:52,720
uh stay tuned for you know more safety

00:44:50,560 --> 00:44:55,119
rules that show up in our team blog

00:44:52,720 --> 00:44:56,000
uh c plus plus four guidelines has been

00:44:55,119 --> 00:44:59,119
a pretty

00:44:56,000 --> 00:45:00,640
uh effective guiding principle for us to

00:44:59,119 --> 00:45:02,400
improve the code hygiene within the

00:45:00,640 --> 00:45:04,240
company so we would urge all of you to

00:45:02,400 --> 00:45:07,680
take a look at the guidelines

00:45:04,240 --> 00:45:10,720
uh take a look at our gsl library uh

00:45:07,680 --> 00:45:12,960
where we have a a lot of interesting

00:45:10,720 --> 00:45:15,920
discussions on how we can make this

00:45:12,960 --> 00:45:17,119
guideline you know support library more

00:45:15,920 --> 00:45:18,880
more effective

00:45:17,119 --> 00:45:20,319
in helping people write modern and

00:45:18,880 --> 00:45:23,760
safety plus plus

00:45:20,319 --> 00:45:26,160
and uh finally i would uh like to

00:45:23,760 --> 00:45:27,599
thank uh the amazing contributors that

00:45:26,160 --> 00:45:29,440
worked on these projects

00:45:27,599 --> 00:45:31,040
definitely thankful to the core

00:45:29,440 --> 00:45:33,119
guideline editors i've had

00:45:31,040 --> 00:45:34,640
a great set of interns working on the

00:45:33,119 --> 00:45:37,839
team in the past winter

00:45:34,640 --> 00:45:40,240
and this summer and also

00:45:37,839 --> 00:45:41,680
i would like to thank my team for

00:45:40,240 --> 00:45:45,200
implementing a lot of the checks that

00:45:41,680 --> 00:45:48,400
you saw today in visual studio

00:45:45,200 --> 00:45:51,440
and with that uh i would like to

00:45:48,400 --> 00:45:53,280
uh uh end my talk but enjoy the rest of

00:45:51,440 --> 00:45:55,040
the conference again you have a table

00:45:53,280 --> 00:45:57,440
at the expo hall where you can meet the

00:45:55,040 --> 00:45:59,200
c plus plus team and ask questions

00:45:57,440 --> 00:46:01,680
and there is a survey at the end that

00:45:59,200 --> 00:46:05,359
you can take and it allows you to win a

00:46:01,680 --> 00:46:05,359
copy of the flight simulator

00:46:05,760 --> 00:46:09,040
and we have a few more sessions lined up

00:46:08,000 --> 00:46:12,000
uh for

00:46:09,040 --> 00:46:13,680
today we have uh the c plus plus 20 stl

00:46:12,000 --> 00:46:16,000
features feisty fun

00:46:13,680 --> 00:46:17,839
tomorrow we have a talk uh on dynamic

00:46:16,000 --> 00:46:20,720
polymorphism with meta classes

00:46:17,839 --> 00:46:22,720
uh by sci we have a cross-platform talk

00:46:20,720 --> 00:46:23,359
by erica we have effective remote

00:46:22,720 --> 00:46:26,319
seating

00:46:23,359 --> 00:46:26,880
development by nick and on friday uh

00:46:26,319 --> 00:46:30,000
justin

00:46:26,880 --> 00:46:30,880
and michael will be talking about uh a

00:46:30,000 --> 00:46:32,560
new open source

00:46:30,880 --> 00:46:35,040
budgeting platform that microsoft has

00:46:32,560 --> 00:46:38,720
built so stay tuned for those sessions

00:46:35,040 --> 00:46:40,640
and uh enjoy the rest of the conference

00:46:38,720 --> 00:46:43,839
if you have questions i i would love to

00:46:40,640 --> 00:46:43,839
take those at this point

00:46:47,200 --> 00:46:51,760
so i have a question here that says uh

00:46:49,359 --> 00:46:54,960
do any of these checks uh

00:46:51,760 --> 00:46:56,800
provide client id like fixes uh that is

00:46:54,960 --> 00:46:57,920
automatically fix the code to align with

00:46:56,800 --> 00:47:00,079
the guidelines

00:46:57,920 --> 00:47:01,280
that's a great question so when we think

00:47:00,079 --> 00:47:03,440
of static analysis

00:47:01,280 --> 00:47:04,720
uh we have a few options in the visual

00:47:03,440 --> 00:47:06,720
studio ide

00:47:04,720 --> 00:47:08,720
so first we have introduced something

00:47:06,720 --> 00:47:10,560
called the c plus plus code linters and

00:47:08,720 --> 00:47:13,040
those are the then style checks

00:47:10,560 --> 00:47:15,040
that does not require uh any sort of

00:47:13,040 --> 00:47:15,760
data flow or control flow or complex

00:47:15,040 --> 00:47:17,839
logic

00:47:15,760 --> 00:47:20,319
and those c plus plus code linters are

00:47:17,839 --> 00:47:23,839
built on top of our intellisense engine

00:47:20,319 --> 00:47:25,359
and that allows you to do a lot of the

00:47:23,839 --> 00:47:27,440
fixes that you're talking about here

00:47:25,359 --> 00:47:30,160
which you would find in client id

00:47:27,440 --> 00:47:32,000
second we also have clan tidy integrated

00:47:30,160 --> 00:47:33,680
as part of the visual studio

00:47:32,000 --> 00:47:35,440
uh code analysis experience so you

00:47:33,680 --> 00:47:36,640
should be able to find length id tools

00:47:35,440 --> 00:47:38,880
integrated

00:47:36,640 --> 00:47:40,640
and lastly for the more involved checks

00:47:38,880 --> 00:47:43,119
that require control flow

00:47:40,640 --> 00:47:44,960
uh data flow or path simulation all

00:47:43,119 --> 00:47:46,079
those checks the full power is available

00:47:44,960 --> 00:47:48,240
with uh traditional

00:47:46,079 --> 00:47:50,240
msvc code analysis that you're familiar

00:47:48,240 --> 00:47:52,079
with so we have a

00:47:50,240 --> 00:47:54,079
a bunch of options that you can choose

00:47:52,079 --> 00:47:56,000
for and you will definitely

00:47:54,079 --> 00:47:59,760
i believe enjoy the fixes that come with

00:47:56,000 --> 00:47:59,760
the c-plus plus lint experience

00:48:04,240 --> 00:48:07,680
there is a next question that says is

00:48:06,559 --> 00:48:09,520
there working done

00:48:07,680 --> 00:48:11,760
or planned work to be done to bring

00:48:09,520 --> 00:48:14,960
these checks into other compilers or

00:48:11,760 --> 00:48:17,520
separate static analysis tools

00:48:14,960 --> 00:48:18,400
so it's a great question so uh one of

00:48:17,520 --> 00:48:21,920
the things

00:48:18,400 --> 00:48:22,640
we are doing internally is our asds

00:48:21,920 --> 00:48:25,119
right now

00:48:22,640 --> 00:48:26,720
are kind of uh they are reaching the end

00:48:25,119 --> 00:48:27,920
of life they have been in place for the

00:48:26,720 --> 00:48:29,280
last 10 years

00:48:27,920 --> 00:48:31,359
what we want to do is we want to

00:48:29,280 --> 00:48:33,839
modernize the asts because

00:48:31,359 --> 00:48:35,280
the asds are the building blocks for

00:48:33,839 --> 00:48:37,760
code analysis

00:48:35,280 --> 00:48:39,839
and as we are working on it we are

00:48:37,760 --> 00:48:42,319
trying to choose a representation

00:48:39,839 --> 00:48:43,599
where uh potentially this can work

00:48:42,319 --> 00:48:46,400
across two chains

00:48:43,599 --> 00:48:48,240
what it means is the analysis we write

00:48:46,400 --> 00:48:50,400
on top of these modern asts

00:48:48,240 --> 00:48:52,079
can be leveraged across other other

00:48:50,400 --> 00:48:54,559
compilers and tools

00:48:52,079 --> 00:48:55,119
but uh we are into early stages for that

00:48:54,559 --> 00:48:58,079
uh

00:48:55,119 --> 00:48:59,760
and uh i can maybe give you an update uh

00:48:58,079 --> 00:49:01,359
next year on where we are with that

00:48:59,760 --> 00:49:02,319
effort but there's definitely work

00:49:01,359 --> 00:49:04,880
happening

00:49:02,319 --> 00:49:08,640
uh to modernize our asts in a way that

00:49:04,880 --> 00:49:08,640
can be used across platforms

00:49:11,119 --> 00:49:15,520
can these tools be easily integrated

00:49:13,200 --> 00:49:17,359
into the cicid pipelines

00:49:15,520 --> 00:49:19,359
that's a great question i think if you

00:49:17,359 --> 00:49:20,160
cannot integrate these tools into the ci

00:49:19,359 --> 00:49:21,920
pipeline

00:49:20,160 --> 00:49:24,480
it kind of defeats the purpose because

00:49:21,920 --> 00:49:26,400
like i said static analysis its job is

00:49:24,480 --> 00:49:28,000
to prevent bugs from getting checked in

00:49:26,400 --> 00:49:29,280
so i think there are a class of checks

00:49:28,000 --> 00:49:30,880
you would want to run

00:49:29,280 --> 00:49:32,559
as you are typing and those would be

00:49:30,880 --> 00:49:34,960
lint style checks then you would like

00:49:32,559 --> 00:49:36,720
run slightly uh more involved checks

00:49:34,960 --> 00:49:37,839
when you're saving your work or when

00:49:36,720 --> 00:49:39,920
you're building

00:49:37,839 --> 00:49:41,760
that will happen on your machine but

00:49:39,920 --> 00:49:43,520
also it's imperative that you have

00:49:41,760 --> 00:49:44,800
static analysis checks running in your

00:49:43,520 --> 00:49:46,800
ci pipeline

00:49:44,800 --> 00:49:48,079
that prevents your code from getting

00:49:46,800 --> 00:49:50,720
merged think of it like

00:49:48,079 --> 00:49:52,559
a auto code reviewer like a bot that

00:49:50,720 --> 00:49:54,160
comes back and says that hey

00:49:52,559 --> 00:49:55,920
here is an error in your function that

00:49:54,160 --> 00:49:56,960
you just wrote in this vr and you want

00:49:55,920 --> 00:49:59,040
to fix it

00:49:56,960 --> 00:50:01,280
and from interacting with people across

00:49:59,040 --> 00:50:03,200
microsoft what we have learned is

00:50:01,280 --> 00:50:05,359
we get a lot better reception when we

00:50:03,200 --> 00:50:06,960
can flag issues uh when people are

00:50:05,359 --> 00:50:09,200
working on it imagine

00:50:06,960 --> 00:50:10,720
as opposed to that the code gets checked

00:50:09,200 --> 00:50:12,640
in and you run these

00:50:10,720 --> 00:50:14,240
tools and the results come back to you

00:50:12,640 --> 00:50:16,400
as bugs after a month

00:50:14,240 --> 00:50:18,079
by that time the issue has really gone

00:50:16,400 --> 00:50:20,000
out of your mind and you are not

00:50:18,079 --> 00:50:21,359
less likely to fix that issue so

00:50:20,000 --> 00:50:23,119
definitely we are looking

00:50:21,359 --> 00:50:24,640
at least internally we've started a

00:50:23,119 --> 00:50:27,839
pilot where

00:50:24,640 --> 00:50:28,559
we are creating uh a plugin for visual

00:50:27,839 --> 00:50:30,400
studio

00:50:28,559 --> 00:50:31,760
code where you would be able to run

00:50:30,400 --> 00:50:33,680
these tools on the

00:50:31,760 --> 00:50:35,040
uh if you're typing your code and we are

00:50:33,680 --> 00:50:36,720
using a viewer to show you

00:50:35,040 --> 00:50:39,440
these warnings no matter what editor you

00:50:36,720 --> 00:50:41,359
use and we also have plans to have a

00:50:39,440 --> 00:50:42,720
check in the ci pipeline that would

00:50:41,359 --> 00:50:44,240
prevent you from

00:50:42,720 --> 00:50:45,760
checking in your code if you have static

00:50:44,240 --> 00:50:47,839
analysis defects because

00:50:45,760 --> 00:50:49,680
you believe that that's when we'll get

00:50:47,839 --> 00:50:51,280
the maximum engagement from the

00:50:49,680 --> 00:50:52,640
developers because they're just working

00:50:51,280 --> 00:50:53,839
on that code so that's definitely

00:50:52,640 --> 00:50:56,800
something

00:50:53,839 --> 00:50:56,800
in the horizon for us

00:50:57,760 --> 00:51:01,440
uh okay uh the next question is are

00:51:00,240 --> 00:51:04,559
these tools available

00:51:01,440 --> 00:51:07,200
in vs code so the short answer to that

00:51:04,559 --> 00:51:08,160
is right not right now they are not

00:51:07,200 --> 00:51:10,640
available

00:51:08,160 --> 00:51:11,280
uh but this is something we will

00:51:10,640 --> 00:51:13,520
consider

00:51:11,280 --> 00:51:15,200
uh going forward again if you want to

00:51:13,520 --> 00:51:17,359
see these tools in vs code

00:51:15,200 --> 00:51:19,920
keep the feedback coming that just helps

00:51:17,359 --> 00:51:22,240
us with our privatization like i said

00:51:19,920 --> 00:51:24,480
we're already internally working on a vs

00:51:22,240 --> 00:51:26,160
code plugin a vs code extension

00:51:24,480 --> 00:51:28,079
that allows you to run these checks

00:51:26,160 --> 00:51:29,440
inside of vs code so

00:51:28,079 --> 00:51:31,599
if that's something you would want to

00:51:29,440 --> 00:51:32,319
see in the community i would appreciate

00:51:31,599 --> 00:51:34,000
if you can

00:51:32,319 --> 00:51:35,119
send that sort of feedback to our team

00:51:34,000 --> 00:51:37,920
and that just would help with the

00:51:35,119 --> 00:51:37,920
prioritization

00:51:41,119 --> 00:51:45,359
okay the next question is uh seems like

00:51:43,760 --> 00:51:47,119
static analysis becomes a lot more

00:51:45,359 --> 00:51:48,800
complicated with templates

00:51:47,119 --> 00:51:50,720
that analysis could return different

00:51:48,800 --> 00:51:52,480
results for different specializations

00:51:50,720 --> 00:51:54,559
how would you deal with that

00:51:52,480 --> 00:51:57,119
that's an excellent question and if you

00:51:54,559 --> 00:51:59,359
look at the existing analysis that we do

00:51:57,119 --> 00:52:01,520
some of the analysis does suffer from

00:51:59,359 --> 00:52:02,559
from from this exact limitation that you

00:52:01,520 --> 00:52:04,960
just mentioned

00:52:02,559 --> 00:52:07,440
so imagine you have a template function

00:52:04,960 --> 00:52:10,160
which has a non-type template parameter

00:52:07,440 --> 00:52:11,359
and you are looping uh on the loop

00:52:10,160 --> 00:52:12,880
you're using the

00:52:11,359 --> 00:52:14,800
non-type template parameter as the

00:52:12,880 --> 00:52:16,960
bounds of that loop so when you

00:52:14,800 --> 00:52:18,720
specialize that template with a value of

00:52:16,960 --> 00:52:20,400
zero or one which means that loop is

00:52:18,720 --> 00:52:22,480
never going to be executed

00:52:20,400 --> 00:52:24,400
we end up with a warning that says hey

00:52:22,480 --> 00:52:26,079
this is a specialization

00:52:24,400 --> 00:52:27,760
where you're never going to be executing

00:52:26,079 --> 00:52:29,760
that loop that's dead code

00:52:27,760 --> 00:52:31,119
however there are other specializations

00:52:29,760 --> 00:52:33,119
where you are in fact passing a

00:52:31,119 --> 00:52:35,280
different value than a zero or one

00:52:33,119 --> 00:52:36,880
and that loop is going to be executed in

00:52:35,280 --> 00:52:39,520
those specializations

00:52:36,880 --> 00:52:40,319
where uh it's not an easy way to fix it

00:52:39,520 --> 00:52:43,040
and uh

00:52:40,319 --> 00:52:44,160
it creates some sort of uh interesting

00:52:43,040 --> 00:52:46,000
concept there

00:52:44,160 --> 00:52:47,839
so right now i think the inherent

00:52:46,000 --> 00:52:48,480
limitations that we have with template

00:52:47,839 --> 00:52:50,960
is that

00:52:48,480 --> 00:52:51,760
we only look at specializations and we

00:52:50,960 --> 00:52:55,119
don't look

00:52:51,760 --> 00:52:56,480
when the templates are declared so we

00:52:55,119 --> 00:52:57,680
all the analysis that happens

00:52:56,480 --> 00:52:58,880
essentially happens on the

00:52:57,680 --> 00:53:00,960
specialization

00:52:58,880 --> 00:53:04,160
so one of the things we are trying to do

00:53:00,960 --> 00:53:06,319
is as we move to the modern ast apis

00:53:04,160 --> 00:53:08,559
is we are trying to say that hey can we

00:53:06,319 --> 00:53:10,640
have a syntactic information when you

00:53:08,559 --> 00:53:12,640
are declaring these uh templates

00:53:10,640 --> 00:53:14,720
uh and when we have the synthetic

00:53:12,640 --> 00:53:16,240
declaration a lot of these rules can

00:53:14,720 --> 00:53:17,839
move inside uh

00:53:16,240 --> 00:53:20,000
to be built on top of that syntactic

00:53:17,839 --> 00:53:20,880
declaration so the forward example i

00:53:20,000 --> 00:53:22,240
just mentioned

00:53:20,880 --> 00:53:24,079
we would not be building that on

00:53:22,240 --> 00:53:25,680
specialization but we would build that

00:53:24,079 --> 00:53:28,079
when the template is declared

00:53:25,680 --> 00:53:29,760
and it would eliminate those class of

00:53:28,079 --> 00:53:30,160
conflicts that you see with templates

00:53:29,760 --> 00:53:32,400
today

00:53:30,160 --> 00:53:34,400
so i think you're right that there are

00:53:32,400 --> 00:53:37,920
some challenges with templates but we

00:53:34,400 --> 00:53:37,920
are trying to make it better for

00:53:40,839 --> 00:53:45,040
everybody

00:53:43,440 --> 00:53:46,880
all right the next question is are there

00:53:45,040 --> 00:53:48,800
plans to enable fall through checking in

00:53:46,880 --> 00:53:51,520
the actual msvc compiler

00:53:48,800 --> 00:53:52,160
an opt-in would be great so right now i

00:53:51,520 --> 00:53:54,960
don't know

00:53:52,160 --> 00:53:56,160
of any plans to uh enforce fall through

00:53:54,960 --> 00:53:57,520
within the compiler

00:53:56,160 --> 00:53:59,359
again if that is something you would

00:53:57,520 --> 00:54:02,000
want to see in the compiler

00:53:59,359 --> 00:54:03,119
as an opt-in uh uh i'll take that as a

00:54:02,000 --> 00:54:05,359
feedback to the

00:54:03,119 --> 00:54:07,280
compiler uh team my friends there would

00:54:05,359 --> 00:54:08,720
definitely put that on their list of

00:54:07,280 --> 00:54:10,559
priorities and

00:54:08,720 --> 00:54:12,079
again feedback like this helps us

00:54:10,559 --> 00:54:13,040
prioritize what you want to see in the

00:54:12,079 --> 00:54:14,880
compiler

00:54:13,040 --> 00:54:16,880
and we can make it happen based on that

00:54:14,880 --> 00:54:18,000
feedback but right now there aren't any

00:54:16,880 --> 00:54:25,839
plans

00:54:18,000 --> 00:54:25,839
for having this in the compiler

00:54:26,800 --> 00:54:29,839
okay the next question is uh do the

00:54:28,640 --> 00:54:31,599
caveats to these c

00:54:29,839 --> 00:54:34,800
plus plus checks make them less

00:54:31,599 --> 00:54:38,400
effective than the safety checks in rust

00:54:34,800 --> 00:54:41,599
uh well i think uh in my experience uh

00:54:38,400 --> 00:54:43,520
uh you know yes there are caveats but i

00:54:41,599 --> 00:54:44,240
don't think caveats are the limiting

00:54:43,520 --> 00:54:46,559
factor

00:54:44,240 --> 00:54:47,280
i think the limiting factor is twofold

00:54:46,559 --> 00:54:50,240
first is

00:54:47,280 --> 00:54:51,200
uh the implementation of these checks

00:54:50,240 --> 00:54:52,880
they are not

00:54:51,200 --> 00:54:54,880
these checks are not in the compiler you

00:54:52,880 --> 00:54:56,720
can look across the tool chain so

00:54:54,880 --> 00:54:59,280
i think the inheritance limitation there

00:54:56,720 --> 00:55:00,960
is it depends on what kind of tools you

00:54:59,280 --> 00:55:02,480
are using and you can convince your

00:55:00,960 --> 00:55:05,200
developers to use

00:55:02,480 --> 00:55:06,559
and the second thing is that uh these

00:55:05,200 --> 00:55:08,400
rules don't uh

00:55:06,559 --> 00:55:10,319
prevent your code from compiling they're

00:55:08,400 --> 00:55:11,359
easy to turn off they're easy to be

00:55:10,319 --> 00:55:13,920
ignored and your

00:55:11,359 --> 00:55:15,920
code will still compile fine so i think

00:55:13,920 --> 00:55:18,160
we need to move to a world where

00:55:15,920 --> 00:55:20,000
we can get more mind share for people

00:55:18,160 --> 00:55:22,160
believing in the fact that yes there'll

00:55:20,000 --> 00:55:23,839
be a stricter mode that you can opt into

00:55:22,160 --> 00:55:26,000
and if you opt into that mode you will

00:55:23,839 --> 00:55:27,920
be restricted in things that you can do

00:55:26,000 --> 00:55:29,280
but at the same time you get something

00:55:27,920 --> 00:55:32,079
in return which is

00:55:29,280 --> 00:55:34,000
the code that you generate has certain

00:55:32,079 --> 00:55:36,400
uh compile time guarantees like

00:55:34,000 --> 00:55:37,680
rust so i think that's the direction we

00:55:36,400 --> 00:55:41,119
are pursuing

00:55:37,680 --> 00:55:41,760
uh so i believe uh that that's the world

00:55:41,119 --> 00:55:43,280
where

00:55:41,760 --> 00:55:45,280
where instead of you know finding these

00:55:43,280 --> 00:55:46,880
defects where a rule could find it and

00:55:45,280 --> 00:55:47,599
they were turned off we are in a world

00:55:46,880 --> 00:55:49,760
where

00:55:47,599 --> 00:55:51,760
uh okay because this code is compiled

00:55:49,760 --> 00:55:54,480
with a strict mode in the compiler

00:55:51,760 --> 00:55:56,559
i would like to uh you know show these

00:55:54,480 --> 00:55:57,119
warnings to you preemptively rather than

00:55:56,559 --> 00:55:59,520
as i

00:55:57,119 --> 00:56:01,200
was doing a in a postmortem on some

00:55:59,520 --> 00:56:03,839
security bug that happened out in the

00:56:01,200 --> 00:56:03,839
field

00:56:11,920 --> 00:56:15,920
all right the next question is i expect

00:56:13,839 --> 00:56:17,760
for loops with mutation are more often

00:56:15,920 --> 00:56:19,520
intended to mutate the source code than

00:56:17,760 --> 00:56:22,160
a copy

00:56:19,520 --> 00:56:23,760
replace auto with auto reference instead

00:56:22,160 --> 00:56:26,960
of const auto reference

00:56:23,760 --> 00:56:28,960
may be worn based on no discard yes

00:56:26,960 --> 00:56:30,000
that's an interesting so the first this

00:56:28,960 --> 00:56:32,000
question has uh two

00:56:30,000 --> 00:56:34,160
parts the first part is suggesting to

00:56:32,000 --> 00:56:35,040
use an auto ref instead of a constructor

00:56:34,160 --> 00:56:36,640
f because

00:56:35,040 --> 00:56:39,440
sometimes you are going to be mutating

00:56:36,640 --> 00:56:42,079
uh uh the data inside the loop

00:56:39,440 --> 00:56:43,359
uh and we do have a name check that it's

00:56:42,079 --> 00:56:44,799
a suggestion

00:56:43,359 --> 00:56:47,280
and if you look at the latest class

00:56:44,799 --> 00:56:49,839
class linda it would look at

00:56:47,280 --> 00:56:52,480
all range for loops and suggest you use

00:56:49,839 --> 00:56:55,680
a auto reference for

00:56:52,480 --> 00:56:58,000
variables that you are taking a copy

00:56:55,680 --> 00:56:59,760
so there is a c plus linter check which

00:56:58,000 --> 00:57:01,920
is already available today in visual

00:56:59,760 --> 00:57:03,680
studio for that which i didn't show

00:57:01,920 --> 00:57:06,000
and the second part of this question is

00:57:03,680 --> 00:57:07,760
maybe one based on no discard

00:57:06,000 --> 00:57:09,839
again this is a great question before we

00:57:07,760 --> 00:57:11,280
had no discard in the language

00:57:09,839 --> 00:57:13,599
i i don't know how many of you are

00:57:11,280 --> 00:57:15,839
familiar with uh we had something here

00:57:13,599 --> 00:57:17,839
in microsoft called microsoft uh

00:57:15,839 --> 00:57:19,839
cell annotation language it was

00:57:17,839 --> 00:57:22,079
microsoft's own way of annotating

00:57:19,839 --> 00:57:24,640
function signatures to talk about

00:57:22,079 --> 00:57:25,839
contracts on how those functions behave

00:57:24,640 --> 00:57:29,040
and so there was an

00:57:25,839 --> 00:57:31,599
annotation called uh must inspect result

00:57:29,040 --> 00:57:33,200
or check return which were similar in

00:57:31,599 --> 00:57:35,040
spirit to no discard

00:57:33,200 --> 00:57:36,640
and that's definitely a great suggestion

00:57:35,040 --> 00:57:37,440
now that we have known this card in the

00:57:36,640 --> 00:57:39,119
language

00:57:37,440 --> 00:57:41,119
we should be checking that if you're

00:57:39,119 --> 00:57:41,839
ignoring the notice card we should force

00:57:41,119 --> 00:57:45,599
you to

00:57:41,839 --> 00:57:47,920
kind of uh not not not do that

00:57:45,599 --> 00:57:48,640
so that's definitely something we could

00:57:47,920 --> 00:57:55,839
add to the

00:57:48,640 --> 00:57:55,839
to the set of checks we have today

00:58:00,559 --> 00:58:04,640
so the next question is what kind of

00:58:02,400 --> 00:58:06,000
work would need to be done to implement

00:58:04,640 --> 00:58:08,480
some form of rust

00:58:06,000 --> 00:58:09,200
borrow checking rules exactly one

00:58:08,480 --> 00:58:12,160
mutable

00:58:09,200 --> 00:58:14,799
reference sorry invitable reference

00:58:12,160 --> 00:58:17,359
either statically or dynamically

00:58:14,799 --> 00:58:19,599
well uh to be honest i have not uh

00:58:17,359 --> 00:58:21,119
looked into what it will take for us

00:58:19,599 --> 00:58:23,200
to implement the borrow checking

00:58:21,119 --> 00:58:24,000
interest or like i said our immediate

00:58:23,200 --> 00:58:26,240
focus is

00:58:24,000 --> 00:58:27,119
uh first fix the lifetime profiles that

00:58:26,240 --> 00:58:29,280
we have

00:58:27,119 --> 00:58:30,559
uh there are missing cases in a basic

00:58:29,280 --> 00:58:32,400
lifetime checking

00:58:30,559 --> 00:58:33,839
and borrow is something we would look

00:58:32,400 --> 00:58:36,000
into next and

00:58:33,839 --> 00:58:36,960
uh i would be able to answer this

00:58:36,000 --> 00:58:38,559
question uh

00:58:36,960 --> 00:58:40,000
in the coming months as we look into the

00:58:38,559 --> 00:58:41,440
borrower checking but right now

00:58:40,000 --> 00:58:43,200
i haven't looked into the existing

00:58:41,440 --> 00:58:45,040
static analysis framework to figure out

00:58:43,200 --> 00:58:46,640
what exactly it will take to

00:58:45,040 --> 00:58:51,839
build this sort of a borrower checking

00:58:46,640 --> 00:58:51,839
that rust has from the language

00:58:54,079 --> 00:58:58,559
all right um does it might warrant

00:58:56,640 --> 00:59:00,240
sometimes a false positive so i believe

00:58:58,559 --> 00:59:03,280
the question there is uh

00:59:00,240 --> 00:59:04,079
do these tools have false positives and

00:59:03,280 --> 00:59:07,680
the answer is

00:59:04,079 --> 00:59:09,440
yes uh if you look at static analysis uh

00:59:07,680 --> 00:59:11,280
there is always going to be false

00:59:09,440 --> 00:59:13,680
positives because we are inherently

00:59:11,280 --> 00:59:15,359
trying to walk past through the program

00:59:13,680 --> 00:59:18,000
and look for changing properties

00:59:15,359 --> 00:59:20,000
and trying to make inferences so there

00:59:18,000 --> 00:59:22,160
is going to be false positives in the in

00:59:20,000 --> 00:59:24,000
any static analysis tool but we are

00:59:22,160 --> 00:59:25,359
very conscious of the fact that if we

00:59:24,000 --> 00:59:27,599
are going to be uh

00:59:25,359 --> 00:59:29,920
shipping a check we want the false

00:59:27,599 --> 00:59:32,000
positives to be low to a point where the

00:59:29,920 --> 00:59:32,960
developers find value in them we use a

00:59:32,000 --> 00:59:35,280
pretty high bar

00:59:32,960 --> 00:59:36,400
internally as well to tune down false

00:59:35,280 --> 00:59:39,119
positives

00:59:36,400 --> 00:59:39,680
uh so yes there are false positives but

00:59:39,119 --> 00:59:41,440
we are

00:59:39,680 --> 00:59:43,520
very open to hearing about your

00:59:41,440 --> 00:59:46,240
experience on these checks and

00:59:43,520 --> 00:59:46,799
if you uh report false positives to us

00:59:46,240 --> 00:59:49,760
then

00:59:46,799 --> 00:59:50,400
we will prioritize that and fix that for

00:59:49,760 --> 00:59:52,240
you

00:59:50,400 --> 00:59:53,680
and you can reach out to us in the

00:59:52,240 --> 00:59:56,960
developer community

00:59:53,680 --> 01:00:00,160
uh we go through every issue reported in

00:59:56,960 --> 01:00:01,760
that community and prioritize our fixes

01:00:00,160 --> 01:00:04,640
the second part to this question is have

01:00:01,760 --> 01:00:07,680
you heard about uh

01:00:04,640 --> 01:00:11,040
space no i have not heard about that

01:00:07,680 --> 01:00:14,079
and i believe that was the last question

01:00:11,040 --> 01:00:16,640
uh thank you everybody for joining me in

01:00:14,079 --> 01:00:29,839
today's talk and hope you enjoy the rest

01:00:16,640 --> 01:00:29,839
of the sessions

01:00:38,079 --> 01:00:40,160

YouTube URL: https://www.youtube.com/watch?v=_pQGRr4P16w


