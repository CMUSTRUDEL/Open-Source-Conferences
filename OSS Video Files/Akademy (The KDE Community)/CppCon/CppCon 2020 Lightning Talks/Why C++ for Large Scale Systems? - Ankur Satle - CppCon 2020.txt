Title: Why C++ for Large Scale Systems? - Ankur Satle - CppCon 2020
Publication date: 2020-10-15
Playlist: CppCon 2020 Lightning Talks
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
At cppindia.co.in, we got asked this question: "Why use C++ for Large Scale Systems?" 
The talk goes through the Whys.

---
Ankur Satle
EXFO
Architect
Pune, India

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,880 --> 00:00:13,840
hello world

00:00:10,639 --> 00:00:16,800
so uh this is a talk about why c

00:00:13,840 --> 00:00:17,600
plus for large large-scale systems we

00:00:16,800 --> 00:00:19,920
have this

00:00:17,600 --> 00:00:21,439
cpp india user group where this question

00:00:19,920 --> 00:00:23,199
was raised

00:00:21,439 --> 00:00:24,640
what is it about three plus that makes

00:00:23,199 --> 00:00:26,640
it possible

00:00:24,640 --> 00:00:28,240
to write large scale systems well i

00:00:26,640 --> 00:00:31,279
wouldn't say possible

00:00:28,240 --> 00:00:32,160
because you could do a bad job in any

00:00:31,279 --> 00:00:35,600
language

00:00:32,160 --> 00:00:36,399
but to do it well you've come to the

00:00:35,600 --> 00:00:38,160
right one

00:00:36,399 --> 00:00:40,239
so what after all is a large scale

00:00:38,160 --> 00:00:44,719
system is a system

00:00:40,239 --> 00:00:49,120
it has a scale which looks like this

00:00:44,719 --> 00:00:49,120
i'm sorry it should be like this

00:00:49,200 --> 00:00:53,360
i just didn't want to pull up the wiki

00:00:51,199 --> 00:00:55,280
definition of it

00:00:53,360 --> 00:00:57,120
so they are everywhere these large-scale

00:00:55,280 --> 00:01:00,000
systems are in banking

00:00:57,120 --> 00:01:01,120
telecom data centers government

00:01:00,000 --> 00:01:03,840
scientific research

00:01:01,120 --> 00:01:04,879
all kinds of largeness is there out

00:01:03,840 --> 00:01:08,240
there

00:01:04,879 --> 00:01:13,760
so up for the challenge is our

00:01:08,240 --> 00:01:17,040
dear see us and why yes i do love it

00:01:13,760 --> 00:01:19,680
but because it's proven it works

00:01:17,040 --> 00:01:20,960
everywhere from space in other planets

00:01:19,680 --> 00:01:24,320
to lhc to

00:01:20,960 --> 00:01:29,040
data centers everywhere and telecom

00:01:24,320 --> 00:01:33,360
for sure so c plus plus for expressivity

00:01:29,040 --> 00:01:36,560
and static type system well of course uh

00:01:33,360 --> 00:01:37,759
equal support for built-in types uh and

00:01:36,560 --> 00:01:40,159
user-defined types

00:01:37,759 --> 00:01:41,680
you know you just can use it just like

00:01:40,159 --> 00:01:44,479
you use an inch

00:01:41,680 --> 00:01:46,240
and overload meta programming these

00:01:44,479 --> 00:01:48,079
mechanisms make it possible

00:01:46,240 --> 00:01:50,479
you don't have to be enforced by the

00:01:48,079 --> 00:01:53,200
language on a particular paradigm

00:01:50,479 --> 00:01:56,159
you take a pic you want a style data

00:01:53,200 --> 00:02:00,479
oriented declarative you can go for it

00:01:56,159 --> 00:02:02,960
so just no restriction strong types

00:02:00,479 --> 00:02:04,320
we have strong types automatic

00:02:02,960 --> 00:02:07,360
conversions

00:02:04,320 --> 00:02:09,360
you know value types

00:02:07,360 --> 00:02:11,039
help you keep you know not have to

00:02:09,360 --> 00:02:12,720
manage lifetimes etc

00:02:11,039 --> 00:02:14,800
conversions are automatically managed

00:02:12,720 --> 00:02:16,160
like you see in this example

00:02:14,800 --> 00:02:18,239
seconds easily converts into

00:02:16,160 --> 00:02:21,680
microseconds no problem

00:02:18,239 --> 00:02:23,520
and it's always going to be correct

00:02:21,680 --> 00:02:26,560
uh compact memory layout you would have

00:02:23,520 --> 00:02:28,879
seen piano present that kind of a slide

00:02:26,560 --> 00:02:31,280
objects are contiguous in memory

00:02:28,879 --> 00:02:33,280
maximizing cache locality

00:02:31,280 --> 00:02:35,360
objects placed on the stack no

00:02:33,280 --> 00:02:37,200
contention for the global heap

00:02:35,360 --> 00:02:39,760
you know you're not fighting some global

00:02:37,200 --> 00:02:42,879
locks to get memory etc

00:02:39,760 --> 00:02:43,840
automatic resource management oh well we

00:02:42,879 --> 00:02:46,080
have our favorite

00:02:43,840 --> 00:02:46,959
closing brace unique pointer shared

00:02:46,080 --> 00:02:49,760
pointer

00:02:46,959 --> 00:02:50,800
name a resource and it can be managed

00:02:49,760 --> 00:02:54,560
pretty well

00:02:50,800 --> 00:02:56,879
and in a deterministic fashion

00:02:54,560 --> 00:02:57,760
when the cleanup happens etc no waiting

00:02:56,879 --> 00:03:00,959
for garbage

00:02:57,760 --> 00:03:02,560
to collect it and so we have value

00:03:00,959 --> 00:03:05,680
semantics rule of zero

00:03:02,560 --> 00:03:07,440
helps you get there exploit hardware uh

00:03:05,680 --> 00:03:08,720
you have platform specific instructions

00:03:07,440 --> 00:03:11,360
which you can exploit

00:03:08,720 --> 00:03:12,400
heterogeneous computing pneuma you name

00:03:11,360 --> 00:03:14,879
it

00:03:12,400 --> 00:03:15,599
concurrency and parallelism good support

00:03:14,879 --> 00:03:18,959
for that

00:03:15,599 --> 00:03:22,319
go async you have futures continuations

00:03:18,959 --> 00:03:25,760
core routines also with c plus 20.

00:03:22,319 --> 00:03:28,799
and exploit the hardware board go for

00:03:25,760 --> 00:03:28,799
parallel algorithms

00:03:29,440 --> 00:03:32,560
zero overhead of course this is your

00:03:31,200 --> 00:03:34,000
best friend

00:03:32,560 --> 00:03:36,799
optimizations allow for better

00:03:34,000 --> 00:03:38,480
performance high level constructs don't

00:03:36,799 --> 00:03:40,400
come in the way

00:03:38,480 --> 00:03:43,440
they don't translate into runtime costs

00:03:40,400 --> 00:03:46,879
as far as possible

00:03:43,440 --> 00:03:48,799
and stable and portable api makes sure

00:03:46,879 --> 00:03:51,519
that code runs for a very long time your

00:03:48,799 --> 00:03:54,560
large system can get larger user

00:03:51,519 --> 00:03:57,760
and you don't have to think about it

00:03:54,560 --> 00:03:58,959
also write once and deploy and compile

00:03:57,760 --> 00:04:01,920
compile and deploy in

00:03:58,959 --> 00:04:04,000
any os it's standard just say to stay

00:04:01,920 --> 00:04:06,400
with the standard series

00:04:04,000 --> 00:04:08,319
just one thing to help yourself be

00:04:06,400 --> 00:04:11,280
responsible

00:04:08,319 --> 00:04:12,400
use modern c plus don't go to just

00:04:11,280 --> 00:04:15,519
because it works

00:04:12,400 --> 00:04:18,720
don't go back so the short

00:04:15,519 --> 00:04:22,000
answer given in a long way is

00:04:18,720 --> 00:04:25,040
just use c plus plus and

00:04:22,000 --> 00:04:26,800
a bonus slide tony vannard asks how many

00:04:25,040 --> 00:04:27,520
times should you attend a cpp bond to do

00:04:26,800 --> 00:04:30,639
a talk

00:04:27,520 --> 00:04:30,639
and what's the answer guys

00:04:31,680 --> 00:04:34,160
one

00:04:34,720 --> 00:04:43,840
there we go thank you very much this is

00:04:58,560 --> 00:05:00,639

YouTube URL: https://www.youtube.com/watch?v=5ji9iRq7JoE


