Title: Reasoning with function signatures - Gabriel Aubut-Lussier - CppCon 2020
Publication date: 2020-10-14
Playlist: CppCon 2020 Lightning Talks
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Complex problems can often be simplified into a function signature. It seems to be a great way to convey the essence of a problem without delving into implementation details! We'll see how to model an existing problem into a function signature.

---
Gabriel Aubut-Lussier
Druide Informatique inc.
Project Lead
MontrÃ©al

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,720 --> 00:00:12,320
all right

00:00:09,760 --> 00:00:13,679
so i want to talk to you today about uh

00:00:12,320 --> 00:00:17,199
reasoning with function

00:00:13,679 --> 00:00:21,359
signatures so um

00:00:17,199 --> 00:00:24,240
why well first of all assuming we have

00:00:21,359 --> 00:00:25,039
pure functions which means that we can

00:00:24,240 --> 00:00:26,960
assume the

00:00:25,039 --> 00:00:28,960
absence of side effects that there's no

00:00:26,960 --> 00:00:30,800
invisible dependencies then

00:00:28,960 --> 00:00:33,440
that is going to make our functions

00:00:30,800 --> 00:00:36,880
predictable reproducible

00:00:33,440 --> 00:00:38,320
testable and it favors local reasoning

00:00:36,880 --> 00:00:39,280
which means that it's going to be much

00:00:38,320 --> 00:00:42,960
easier to

00:00:39,280 --> 00:00:43,280
be confident in the the correctness of

00:00:42,960 --> 00:00:46,399
our

00:00:43,280 --> 00:00:48,879
our function and so if we have

00:00:46,399 --> 00:00:49,760
pure functions then uh we're going to be

00:00:48,879 --> 00:00:52,960
able to

00:00:49,760 --> 00:00:54,559
uh reason based on function signatures

00:00:52,960 --> 00:00:56,800
uh without necessarily looking at the

00:00:54,559 --> 00:00:59,039
implementation details of the function

00:00:56,800 --> 00:01:00,559
so in order to build that recently i'm

00:00:59,039 --> 00:01:02,480
just going to step through an example

00:01:00,559 --> 00:01:04,559
step by step to show

00:01:02,480 --> 00:01:06,080
how i believe we can reason like this so

00:01:04,559 --> 00:01:08,320
let's take a problem that

00:01:06,080 --> 00:01:10,320
i think everyone here is going to be

00:01:08,320 --> 00:01:10,799
familiar with because it's a tool we use

00:01:10,320 --> 00:01:14,080
and

00:01:10,799 --> 00:01:16,320
the question is what is a compiler so

00:01:14,080 --> 00:01:18,640
the first answer i would give to that is

00:01:16,320 --> 00:01:21,439
basically it's a function like this that

00:01:18,640 --> 00:01:23,280
uh you provide a string view to you

00:01:21,439 --> 00:01:25,280
invoke it and then you're getting a

00:01:23,280 --> 00:01:26,320
vector of bytes back and that vector of

00:01:25,280 --> 00:01:29,520
bytes

00:01:26,320 --> 00:01:30,880
represents executable code and so

00:01:29,520 --> 00:01:33,200
we're already going to refine our

00:01:30,880 --> 00:01:35,680
signature here by using this

00:01:33,200 --> 00:01:36,640
uh more cementing return type so

00:01:35,680 --> 00:01:38,479
basically we're

00:01:36,640 --> 00:01:39,840
invoking compile we're providing a

00:01:38,479 --> 00:01:40,400
string view that is code and we're

00:01:39,840 --> 00:01:44,000
getting back

00:01:40,400 --> 00:01:45,520
executable code so okay

00:01:44,000 --> 00:01:47,759
this is kind of a simplistic view of

00:01:45,520 --> 00:01:50,399
what a compiler is uh

00:01:47,759 --> 00:01:52,399
but it is useful because yes most of the

00:01:50,399 --> 00:01:54,479
time when we invoke the compiler

00:01:52,399 --> 00:01:56,159
what we'd like to have is a meaningful

00:01:54,479 --> 00:01:59,759
program come out of it

00:01:56,159 --> 00:02:03,200
uh but then uh let's see what we can do

00:01:59,759 --> 00:02:04,560
first uh we can uh consider the

00:02:03,200 --> 00:02:06,479
that the result of our program is

00:02:04,560 --> 00:02:07,439
actually not the program itself but it's

00:02:06,479 --> 00:02:10,319
more like a

00:02:07,439 --> 00:02:10,800
the result of the compilation so part of

00:02:10,319 --> 00:02:13,280
that

00:02:10,800 --> 00:02:14,319
is the executable code so once again

00:02:13,280 --> 00:02:17,040
we're going to refine

00:02:14,319 --> 00:02:17,440
uh the function signature here and just

00:02:17,040 --> 00:02:20,000
uh

00:02:17,440 --> 00:02:21,440
replace the result type with compilation

00:02:20,000 --> 00:02:25,040
result here and it's going to

00:02:21,440 --> 00:02:26,080
make it possible for us to go more into

00:02:25,040 --> 00:02:29,200
details about

00:02:26,080 --> 00:02:30,959
what is the result of the execution of

00:02:29,200 --> 00:02:33,519
our compiler

00:02:30,959 --> 00:02:34,959
so what is the other thing that our

00:02:33,519 --> 00:02:37,920
compiler can produce

00:02:34,959 --> 00:02:39,440
well it is a vector of strings which we

00:02:37,920 --> 00:02:42,239
can call diagnostics

00:02:39,440 --> 00:02:44,239
so assuming i did some mistakes and my

00:02:42,239 --> 00:02:48,080
source code is ill-formed

00:02:44,239 --> 00:02:49,120
then i should get a non-empty vector

00:02:48,080 --> 00:02:51,920
back

00:02:49,120 --> 00:02:53,680
as far as diagnostics are concerned and

00:02:51,920 --> 00:02:56,160
at this point you may have noticed that

00:02:53,680 --> 00:02:56,640
uh well if i do get diagnostics back

00:02:56,160 --> 00:02:59,599
then i

00:02:56,640 --> 00:03:00,720
should not be getting an output program

00:02:59,599 --> 00:03:02,640
or maybe i do

00:03:00,720 --> 00:03:05,200
because uh maybe i'm just getting

00:03:02,640 --> 00:03:07,760
warnings and not errors

00:03:05,200 --> 00:03:08,720
so it is true that we could rewrite here

00:03:07,760 --> 00:03:11,200
like this

00:03:08,720 --> 00:03:11,920
our output program is actually an

00:03:11,200 --> 00:03:14,159
optional

00:03:11,920 --> 00:03:15,680
part of the result here uh it doesn't

00:03:14,159 --> 00:03:17,120
mean we're actually going to get an

00:03:15,680 --> 00:03:19,040
output program if the program is

00:03:17,120 --> 00:03:20,000
informed the compiler doesn't have to

00:03:19,040 --> 00:03:23,519
provide us with

00:03:20,000 --> 00:03:26,799
uh bytes executable bytes in this case

00:03:23,519 --> 00:03:28,159
um then there are also

00:03:26,799 --> 00:03:30,560
other things that we could do with a

00:03:28,159 --> 00:03:33,360
compiler let's say we are providing some

00:03:30,560 --> 00:03:34,319
options so here we're going to introduce

00:03:33,360 --> 00:03:36,640
a new structure

00:03:34,319 --> 00:03:38,239
we'll call that compilation options and

00:03:36,640 --> 00:03:39,760
the option we're going to be interested

00:03:38,239 --> 00:03:41,519
in here is to

00:03:39,760 --> 00:03:43,360
we're going to ask the compiler to

00:03:41,519 --> 00:03:44,640
output the dependencies of the

00:03:43,360 --> 00:03:48,239
translation unit

00:03:44,640 --> 00:03:51,200
so by default uh we uh set this pull

00:03:48,239 --> 00:03:52,159
this goal to false but uh here we're

00:03:51,200 --> 00:03:53,920
going to rewrite

00:03:52,159 --> 00:03:55,200
the function signature to pass an

00:03:53,920 --> 00:03:58,000
additional argument

00:03:55,200 --> 00:03:59,200
in order to parameterize our compile

00:03:58,000 --> 00:04:02,080
function

00:03:59,200 --> 00:04:03,280
and because of this additional function

00:04:02,080 --> 00:04:05,280
then we can rewrite

00:04:03,280 --> 00:04:07,040
and improve on our compilation result

00:04:05,280 --> 00:04:08,640
again by providing

00:04:07,040 --> 00:04:10,400
a new part of the result which is a

00:04:08,640 --> 00:04:13,439
vector of file system paths

00:04:10,400 --> 00:04:15,439
that point to the different dependencies

00:04:13,439 --> 00:04:16,799
uh once again because a vector can be

00:04:15,439 --> 00:04:18,639
empty even if we're

00:04:16,799 --> 00:04:20,160
if we're not asking for dependencies we

00:04:18,639 --> 00:04:22,560
can still have this vector be part of

00:04:20,160 --> 00:04:25,520
the results it's just gonna be empty

00:04:22,560 --> 00:04:27,360
and so um there's a lot of ways like

00:04:25,520 --> 00:04:30,160
this that we could strive and

00:04:27,360 --> 00:04:30,800
really create a very comp well a more

00:04:30,160 --> 00:04:33,919
complex

00:04:30,800 --> 00:04:36,080
interface to what are the inputs to

00:04:33,919 --> 00:04:37,840
our compile function and what is the

00:04:36,080 --> 00:04:38,560
structure of the compilation result we

00:04:37,840 --> 00:04:41,919
get

00:04:38,560 --> 00:04:42,240
uh but the the sense of a compiler is

00:04:41,919 --> 00:04:45,440
that

00:04:42,240 --> 00:04:48,479
you can run this single function and

00:04:45,440 --> 00:04:49,120
uh you can basically abstract away a lot

00:04:48,479 --> 00:04:51,520
of the

00:04:49,120 --> 00:04:53,120
complexity of the compiler by just going

00:04:51,520 --> 00:04:54,880
with a simplified

00:04:53,120 --> 00:04:57,199
function signature such as the first one

00:04:54,880 --> 00:04:59,040
i showed early on where you provide

00:04:57,199 --> 00:05:00,400
a string with source code a string view

00:04:59,040 --> 00:05:03,280
with source code and then

00:05:00,400 --> 00:05:04,160
get a vector of bytes back as a result

00:05:03,280 --> 00:05:06,960
so

00:05:04,160 --> 00:05:07,759
uh the reason i think this is

00:05:06,960 --> 00:05:09,919
interesting

00:05:07,759 --> 00:05:11,680
for reasoning is that when you strive

00:05:09,919 --> 00:05:13,840
for function purity then you can

00:05:11,680 --> 00:05:15,360
introduce complex ids with a simplified

00:05:13,840 --> 00:05:18,240
function signature

00:05:15,360 --> 00:05:20,880
and then slowly you can go to more

00:05:18,240 --> 00:05:22,800
complex ideas by going

00:05:20,880 --> 00:05:24,400
forward and moving towards the complete

00:05:22,800 --> 00:05:27,440
function signature

00:05:24,400 --> 00:05:28,639
it can make exchanges between teams much

00:05:27,440 --> 00:05:30,240
easier

00:05:28,639 --> 00:05:31,680
to talk about and also when you're

00:05:30,240 --> 00:05:34,240
asking co-workers for

00:05:31,680 --> 00:05:36,080
help on a problem introducing them to

00:05:34,240 --> 00:05:37,759
your complex setup with a very

00:05:36,080 --> 00:05:39,440
simplified function signature that

00:05:37,759 --> 00:05:41,919
captures the essence of your problem is

00:05:39,440 --> 00:05:45,039
a very efficient way to communicate

00:05:41,919 --> 00:05:48,000
so thank you for your attention and i

00:05:45,039 --> 00:05:48,000
hope you have a great conference

00:05:50,840 --> 00:05:53,840
everyone

00:06:05,520 --> 00:06:07,600

YouTube URL: https://www.youtube.com/watch?v=8rU6eEiRV5k


