Title: CppCon 2015: Piotr Padlewski "C++ WAT"
Publication date: 2015-10-21
Playlist: CppCon 2015 Lightning Talks
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:07,189
so hi my name is filter Lipsky and today

00:00:03,419 --> 00:00:12,179
I'm gonna talk about see what's what so

00:00:07,189 --> 00:00:14,250
let's serve something easy so when you

00:00:12,179 --> 00:00:17,070
as you can see this code you probably

00:00:14,250 --> 00:00:17,880
think that the type of a map it's some

00:00:17,070 --> 00:00:21,119
kind of map

00:00:17,880 --> 00:00:24,119
right but in fact it's not it's integer

00:00:21,119 --> 00:00:28,170
and this is of course because you can

00:00:24,119 --> 00:00:32,219
you can use this operator the square

00:00:28,170 --> 00:00:35,790
bracket operator and it's just a pointer

00:00:32,219 --> 00:00:39,480
arithmetic right that's of course if you

00:00:35,790 --> 00:00:50,700
will see 42 of T that that then it will

00:00:39,480 --> 00:00:53,850
be what right okay yeah so the first

00:00:50,700 --> 00:00:56,430
question of course is does it disgust

00:00:53,850 --> 00:01:00,780
compiled and the answer is of course yes

00:00:56,430 --> 00:01:08,390
and to answer the question what does it

00:01:00,780 --> 00:01:08,390
do I will firstly invent this code and

00:01:08,930 --> 00:01:14,670
this code is equivalent to this code

00:01:11,460 --> 00:01:17,070
which is empty lambda call inside lambda

00:01:14,670 --> 00:01:19,909
inside lambda so it does nothing

00:01:17,070 --> 00:01:25,100
and this compiles because we have

00:01:19,909 --> 00:01:25,100
diagraphs in C++ what

00:01:29,280 --> 00:01:37,810
okay so Cephas plus has a very nice

00:01:33,760 --> 00:01:42,840
feature and you can put URLs inside the

00:01:37,810 --> 00:01:42,840
codes like this without any comments but

00:01:42,930 --> 00:01:50,850
in fact there is some kind of bug and

00:01:46,630 --> 00:01:50,850
you can put only one URL in your code so

00:01:52,350 --> 00:01:59,710
let me bring some what and Silva's also

00:01:57,040 --> 00:02:00,520
have some very nice operator that do

00:01:59,710 --> 00:02:05,760
something like this

00:02:00,520 --> 00:02:09,580
and goes to zero right and it works and

00:02:05,760 --> 00:02:10,720
of course many times you hear something

00:02:09,580 --> 00:02:13,030
many times you hear about

00:02:10,720 --> 00:02:16,570
self-documenting code and guess what

00:02:13,030 --> 00:02:18,670
seahorses have has the way to document

00:02:16,570 --> 00:02:29,260
code without comments you can do it like

00:02:18,670 --> 00:02:31,170
this right doc and the thing is that you

00:02:29,260 --> 00:02:35,320
probably think that this pink will print

00:02:31,170 --> 00:02:38,290
what and some question marks but in fact

00:02:35,320 --> 00:02:44,040
will print what and line because we have

00:02:38,290 --> 00:02:48,040
three graphs in C++ okay

00:02:44,040 --> 00:02:50,320
did you know that you can put every you

00:02:48,040 --> 00:02:52,390
can start every broke with a try-catch

00:02:50,320 --> 00:02:56,739
block so you can do something like this

00:02:52,390 --> 00:02:59,050
right so this looks madness but in fact

00:02:56,739 --> 00:03:03,040
this is the only way to catch exceptions

00:02:59,050 --> 00:03:04,600
from initializing list so in fact this

00:03:03,040 --> 00:03:07,750
is not one this is like this is very

00:03:04,600 --> 00:03:10,150
nice feature right but of course if you

00:03:07,750 --> 00:03:12,690
will see the first time then this is

00:03:10,150 --> 00:03:12,690
probably what

00:03:16,650 --> 00:03:23,680
okay so in this example we have a type

00:03:21,489 --> 00:03:25,989
def long alcohol we have two functions

00:03:23,680 --> 00:03:28,150
first that takes on e-bay and sign ll

00:03:25,989 --> 00:03:30,760
and second that's safe assignment long

00:03:28,150 --> 00:03:33,700
and then we call function with two euro

00:03:30,760 --> 00:03:36,880
and you will probably think that this

00:03:33,700 --> 00:03:39,489
function this thing will not compile

00:03:36,880 --> 00:03:42,519
because we have the same signatures

00:03:39,489 --> 00:03:44,260
right and the fact is that it will call

00:03:42,519 --> 00:03:46,330
the second function at everything will

00:03:44,260 --> 00:03:50,290
compile and this is because you cannot

00:03:46,330 --> 00:03:56,489
below types like this after unsign dll

00:03:50,290 --> 00:03:56,489
is it's only a variable name so what

00:03:59,790 --> 00:04:08,170
okay does anyone knows how to call

00:04:02,799 --> 00:04:09,549
destructor explicitly nobody okay so of

00:04:08,170 --> 00:04:10,120
course you cannot do something like this

00:04:09,549 --> 00:04:14,739
right

00:04:10,120 --> 00:04:16,630
because it won't compile the integer tcp

00:04:14,739 --> 00:04:18,640
of these so you can it doesn't have any

00:04:16,630 --> 00:04:21,310
memory functions but in fact you can do

00:04:18,640 --> 00:04:23,919
something like this so as you can see

00:04:21,310 --> 00:04:25,900
we're using using and then we can call

00:04:23,919 --> 00:04:29,520
this structure on it and this is totally

00:04:25,900 --> 00:04:29,520
fine what

00:04:39,180 --> 00:04:45,820
okay so let me tell you a story about

00:04:43,800 --> 00:04:47,830
Nick Levitt TV Alec

00:04:45,820 --> 00:04:50,260
so there was a contest called undefined

00:04:47,830 --> 00:04:55,960
behaviour consents consequences contest

00:04:50,260 --> 00:04:59,650
and Nick was working LVM clonk team in

00:04:55,960 --> 00:05:03,490
Google and he found out this code which

00:04:59,650 --> 00:05:04,990
has undefined behavior but it's you can

00:05:03,490 --> 00:05:08,200
probably not see it on the first time

00:05:04,990 --> 00:05:10,420
and what he did is he wrote special I

00:05:08,200 --> 00:05:13,180
think to the compiler so it will compile

00:05:10,420 --> 00:05:14,740
it in a funny way so you can see this

00:05:13,180 --> 00:05:17,050
code is very easy right we are calling

00:05:14,740 --> 00:05:19,390
malloc then we are calling realloc on

00:05:17,050 --> 00:05:22,120
the same pointer which will return the

00:05:19,390 --> 00:05:25,080
same the same pointer then we are

00:05:22,120 --> 00:05:28,060
putting one to this pointer then too and

00:05:25,080 --> 00:05:31,000
just to make sure we are checking if P

00:05:28,060 --> 00:05:33,700
equals Q Q and if you will compile with

00:05:31,000 --> 00:05:35,800
Clank you'll be like yes so I have these

00:05:33,700 --> 00:05:39,190
two pointers that puts the same value

00:05:35,800 --> 00:05:43,760
which is one and two right this is like

00:05:39,190 --> 00:05:47,340
and I'm not even mad about this

00:05:43,760 --> 00:05:48,990
this is amazing and in fact the

00:05:47,340 --> 00:05:53,730
undefined undefined undefined behavior

00:05:48,990 --> 00:05:55,620
here is it's when you use pointer P

00:05:53,730 --> 00:05:58,410
because you cannot see use pointers

00:05:55,620 --> 00:05:59,790
after after reorge and this is this is

00:05:58,410 --> 00:06:08,100
not something that's everyone knows

00:05:59,790 --> 00:06:12,300
right okay what will happen and you know

00:06:08,100 --> 00:06:13,800
of course in C++ this thing you would

00:06:12,300 --> 00:06:18,870
probably feel like okay this thing will

00:06:13,800 --> 00:06:19,740
either clear or it will it will do

00:06:18,870 --> 00:06:21,270
nothing right

00:06:19,740 --> 00:06:23,100
and in fact Civitas is some kind of

00:06:21,270 --> 00:06:24,840
quantum language and both things can

00:06:23,100 --> 00:06:27,570
happen right because this undefined

00:06:24,840 --> 00:06:30,360
behavior and you know I didn't have an

00:06:27,570 --> 00:06:37,020
even comment for this so I will just put

00:06:30,360 --> 00:06:40,470
this cat okay so this function calls

00:06:37,020 --> 00:06:42,900
looks perfectly fine right and in fact

00:06:40,470 --> 00:06:45,600
the second line will not compile because

00:06:42,900 --> 00:06:52,080
we are calling my I mean within an login

00:06:45,600 --> 00:06:54,210
right this is obvious and for example if

00:06:52,080 --> 00:06:57,570
we have a function that takes one

00:06:54,210 --> 00:06:59,310
integer and we'll put extra parenthesis

00:06:57,570 --> 00:07:03,380
then of course we will call this

00:06:59,310 --> 00:07:07,560
function with five right this is obvious

00:07:03,380 --> 00:07:13,260
okay so let's see some cool

00:07:07,560 --> 00:07:15,600
optimizations so this this function of

00:07:13,260 --> 00:07:16,980
course has undefined behavior because we

00:07:15,600 --> 00:07:20,070
are trying to access the fifth element

00:07:16,980 --> 00:07:22,170
of the of the table and if you compile

00:07:20,070 --> 00:07:26,160
with Clank it will produce something

00:07:22,170 --> 00:07:28,530
like this return true and you will be

00:07:26,160 --> 00:07:29,130
probably like excuse me what are you

00:07:28,530 --> 00:07:33,750
doing

00:07:29,130 --> 00:07:35,010
and in fact the client is doing a very

00:07:33,750 --> 00:07:36,930
good job

00:07:35,010 --> 00:07:39,030
it would probably ask like okay what why

00:07:36,930 --> 00:07:41,580
does it it doesn't return false or

00:07:39,030 --> 00:07:44,610
something so in fact Danny finally

00:07:41,580 --> 00:07:49,200
behaviors only triggers when you hit the

00:07:44,610 --> 00:07:51,870
fifth element so clunk assumes that will

00:07:49,200 --> 00:07:53,639
not get to the undefined behavior and if

00:07:51,870 --> 00:07:55,319
will not get to the any behavior

00:07:53,639 --> 00:08:01,800
which means that we'll find the thing in

00:07:55,319 --> 00:08:06,389
the table so just return true what okay

00:08:01,800 --> 00:08:10,469
so this code has so we'll check if

00:08:06,389 --> 00:08:13,949
Fermat loss applies so we have with

00:08:10,469 --> 00:08:14,669
three integers we have we have loop that

00:08:13,949 --> 00:08:18,270
will never end

00:08:14,669 --> 00:08:20,939
right if of course if if the law and it

00:08:18,270 --> 00:08:22,460
works and this code doesn't have any

00:08:20,939 --> 00:08:25,439
undefined behaviors

00:08:22,460 --> 00:08:28,770
there is no integer overflow anything

00:08:25,439 --> 00:08:31,979
like this and if we will call this

00:08:28,770 --> 00:08:34,409
function and say like okay permit us if

00:08:31,979 --> 00:08:36,769
will return one that means that the

00:08:34,409 --> 00:08:39,240
afirma doesn't doesn't work right and

00:08:36,769 --> 00:08:43,769
we'll probably never return zero because

00:08:39,240 --> 00:08:46,279
this is a infinite loop so it will

00:08:43,769 --> 00:08:48,360
compile with Clank what you will get is

00:08:46,279 --> 00:08:52,470
Fermat's Last Theorem has been

00:08:48,360 --> 00:08:55,440
disapproved it doesn't work and you will

00:08:52,470 --> 00:08:57,470
be like what's going on right the

00:08:55,440 --> 00:09:00,779
comparison is not smart enough to

00:08:57,470 --> 00:09:05,100
disapprove laws or something and in fact

00:09:00,779 --> 00:09:07,860
this is 100% standard compliance because

00:09:05,100 --> 00:09:11,130
if we have infinite loop or something

00:09:07,860 --> 00:09:15,420
like this and it doesn't have it doesn't

00:09:11,130 --> 00:09:17,820
modify any by our integers or something

00:09:15,420 --> 00:09:19,920
like this it doesn't change it doesn't

00:09:17,820 --> 00:09:22,890
have side effects then we can optimize

00:09:19,920 --> 00:09:24,680
it away right like this we don't have to

00:09:22,890 --> 00:09:30,269
prove that this this loop will ever end

00:09:24,680 --> 00:09:32,310
so we can just return one okay

00:09:30,269 --> 00:09:36,959
so many times we have something like

00:09:32,310 --> 00:09:38,820
this we construct another set and then

00:09:36,959 --> 00:09:42,180
we want to want to copy everything to

00:09:38,820 --> 00:09:46,230
vector and sort it and this this codes

00:09:42,180 --> 00:09:47,970
if you if you write it and you run it it

00:09:46,230 --> 00:09:51,570
will probably seg fault and this is

00:09:47,970 --> 00:09:53,640
because we are trying to build good

00:09:51,570 --> 00:09:56,390
visitors then the vector good visitors

00:09:53,640 --> 00:09:59,100
with itself and you're probably like

00:09:56,390 --> 00:10:02,069
what's going on but why does it even

00:09:59,100 --> 00:10:03,820
compile if it's obvious this is this is

00:10:02,069 --> 00:10:08,140
wrong right

00:10:03,820 --> 00:10:10,870
and in fact Zbyszko standards have a

00:10:08,140 --> 00:10:12,910
rule that if you declare a value if you

00:10:10,870 --> 00:10:15,700
declare some object you can just use it

00:10:12,910 --> 00:10:18,430
whatever you want and in fact this is

00:10:15,700 --> 00:10:22,390
the park this is very useful feature so

00:10:18,430 --> 00:10:25,750
I guess all of us ever have ever used as

00:10:22,390 --> 00:10:30,850
camp scanf right and all of us forget to

00:10:25,750 --> 00:10:32,950
put the ampersand into in before the the

00:10:30,850 --> 00:10:35,530
thing that we want to put the value

00:10:32,950 --> 00:10:38,170
inside so guess what I have solutions

00:10:35,530 --> 00:10:41,320
for this okay but firstly I will show

00:10:38,170 --> 00:10:44,350
you that what what error will get if you

00:10:41,320 --> 00:10:47,320
will run gdb it's like segmentation poll

00:10:44,350 --> 00:10:52,210
no such file or directory so useful

00:10:47,320 --> 00:10:56,770
right so I kept solution for this kind

00:10:52,210 --> 00:11:00,430
of thing let's just assign value to the

00:10:56,770 --> 00:11:03,550
rest of the of itself right and now if

00:11:00,430 --> 00:11:11,140
we call scanf everything works we just

00:11:03,550 --> 00:11:15,910
put the address okay

00:11:11,140 --> 00:11:18,970
so let's talk about braces so in C

00:11:15,910 --> 00:11:22,780
versus 11 we have something called a new

00:11:18,970 --> 00:11:25,690
syntax right to initialize variables and

00:11:22,780 --> 00:11:28,390
this is a brace in initialization so in

00:11:25,690 --> 00:11:30,850
this in this example we are trying to

00:11:28,390 --> 00:11:33,550
build a vector with one string inside

00:11:30,850 --> 00:11:37,300
right and of course this thing will

00:11:33,550 --> 00:11:39,520
produce one and and print the element

00:11:37,300 --> 00:11:41,800
with cific on and of course if we will

00:11:39,520 --> 00:11:43,570
put the three variables the same thing

00:11:41,800 --> 00:11:45,250
will happen right will have three

00:11:43,570 --> 00:11:49,210
elements and each of them will be C

00:11:45,250 --> 00:11:52,150
become and in fact it will put two

00:11:49,210 --> 00:11:54,510
variables then of course this thing will

00:11:52,150 --> 00:11:54,510
happen

00:11:56,670 --> 00:12:05,200
and the the most funny thing is that if

00:12:00,970 --> 00:12:10,000
you put the two other variables then it

00:12:05,200 --> 00:12:12,070
will crush and so of course what

00:12:10,000 --> 00:12:21,430
programmer meant and you know this is

00:12:12,070 --> 00:12:23,829
supporters right so so of course what

00:12:21,430 --> 00:12:26,170
what program meant is I want to do

00:12:23,829 --> 00:12:28,300
something like this right instead of

00:12:26,170 --> 00:12:32,740
putting these Disney syntax I want to

00:12:28,300 --> 00:12:35,680
put just construct Iraq this or I want

00:12:32,740 --> 00:12:39,459
to do it like this right and what

00:12:35,680 --> 00:12:41,230
compiler did is that okay so let's build

00:12:39,459 --> 00:12:44,139
the vector from initializing list which

00:12:41,230 --> 00:12:47,290
is which is okay but then hmm let's

00:12:44,139 --> 00:12:58,470
build this roof to iterators what can go

00:12:47,290 --> 00:12:58,470
wrong right okay thank you

00:13:02,610 --> 00:13:14,009
and in fact I have one minute more so I

00:13:08,069 --> 00:13:16,079
can I can show you one thing so I would

00:13:14,009 --> 00:13:18,720
just only have time to ask you one

00:13:16,079 --> 00:13:22,139
question so how to define a function

00:13:18,720 --> 00:13:24,779
that you will not be possible to call in

00:13:22,139 --> 00:13:27,119
any way and what I mean is we will not

00:13:24,779 --> 00:13:30,299
be able we will not have any syntax to

00:13:27,119 --> 00:13:31,920
call this function so I will give you 30

00:13:30,299 --> 00:13:36,989
seconds to think about it and I will

00:13:31,920 --> 00:13:44,670
give you the answer oh okay wait 30

00:13:36,989 --> 00:13:47,579
seconds of course I'm I'm not I'm not

00:13:44,670 --> 00:13:49,199
talking about things like marking

00:13:47,579 --> 00:13:51,119
function as delete or something

00:13:49,199 --> 00:13:54,239
everything has to compile we just we

00:13:51,119 --> 00:14:00,749
just don't have any syntax or way to

00:13:54,239 --> 00:14:13,079
call some function okay so who knows we

00:14:00,749 --> 00:14:20,220
have two people free maybe okay no I you

00:14:13,079 --> 00:14:22,230
can call the main right why no I mean

00:14:20,220 --> 00:14:34,829
you can define some other function that

00:14:22,230 --> 00:14:38,600
will call main right why okay I have

00:14:34,829 --> 00:14:38,600
other solution which is much smarter

00:14:39,910 --> 00:14:47,810
so if you do something like this this is

00:14:45,079 --> 00:14:49,430
just inside destruct or class then we

00:14:47,810 --> 00:14:52,550
will not be able to call either this

00:14:49,430 --> 00:14:55,009
constructor or this operator because the

00:14:52,550 --> 00:14:56,380
type of the tea will not be the compiler

00:14:55,009 --> 00:14:59,750
will not be able to deduce the type

00:14:56,380 --> 00:15:01,610
right and because those two function

00:14:59,750 --> 00:15:04,670
doesn't have any name we cannot specify

00:15:01,610 --> 00:15:08,209
the type right this is very smart all

00:15:04,670 --> 00:15:10,360
right okay okay that's all I got thank

00:15:08,209 --> 00:15:10,360

YouTube URL: https://www.youtube.com/watch?v=rNNnPrMHsAA


