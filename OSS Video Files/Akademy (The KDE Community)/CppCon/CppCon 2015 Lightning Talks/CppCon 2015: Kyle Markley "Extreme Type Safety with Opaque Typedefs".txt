Title: CppCon 2015: Kyle Markley "Extreme Type Safety with Opaque Typedefs"
Publication date: 2015-10-21
Playlist: CppCon 2015 Lightning Talks
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Talk Description
— 
Person Bio
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,609
hi my name is Kyle mark Lee I work at

00:00:02,429 --> 00:00:08,220
Intel on microprocessor debug software

00:00:05,609 --> 00:00:09,540
they debug technologies and I want to

00:00:08,220 --> 00:00:14,370
talk to you a little bit about some neat

00:00:09,540 --> 00:00:15,900
stuff you can do with the type system so

00:00:14,370 --> 00:00:18,119
I'll motivate with an example for my

00:00:15,900 --> 00:00:19,920
domain microprocessors have a lot of

00:00:18,119 --> 00:00:21,810
different kinds of address internally

00:00:19,920 --> 00:00:23,820
there's virtual addresses and linear

00:00:21,810 --> 00:00:25,949
addresses and guest and host physical

00:00:23,820 --> 00:00:27,300
addresses and DDR addresses and control

00:00:25,949 --> 00:00:30,060
register addresses and there's a whole

00:00:27,300 --> 00:00:32,460
plethora of these things so if I want to

00:00:30,060 --> 00:00:34,170
model some aspects of what my processor

00:00:32,460 --> 00:00:37,500
is doing in software I need to have

00:00:34,170 --> 00:00:39,180
software that uses addresses well if I

00:00:37,500 --> 00:00:41,520
have an interface that has a function

00:00:39,180 --> 00:00:44,280
that takes an address this is a recipe

00:00:41,520 --> 00:00:45,960
for confusion because I don't know here

00:00:44,280 --> 00:00:48,450
what kind of address I'm talking about

00:00:45,960 --> 00:00:50,879
and the same problem happens in numerous

00:00:48,450 --> 00:00:53,010
other contexts if I have a size for

00:00:50,879 --> 00:00:55,260
instance if I'm talking about the size

00:00:53,010 --> 00:00:57,690
of a control register field the most

00:00:55,260 --> 00:00:59,309
natural unit is bits but if I'm talking

00:00:57,690 --> 00:01:02,309
about the size of some data structure in

00:00:59,309 --> 00:01:05,400
memory then I want bytes and it isn't

00:01:02,309 --> 00:01:06,750
obvious from just the API what kind of

00:01:05,400 --> 00:01:10,920
thing I'm talking about in all of these

00:01:06,750 --> 00:01:12,750
cases but it should be so what do we

00:01:10,920 --> 00:01:14,820
commonly do to try to mitigate problems

00:01:12,750 --> 00:01:16,710
like this well lots of people may put

00:01:14,820 --> 00:01:19,500
the documentation about the intent in a

00:01:16,710 --> 00:01:21,060
comment however people are like the

00:01:19,500 --> 00:01:23,189
preprocessor and that they tend to just

00:01:21,060 --> 00:01:25,920
ignore the comments that's not a very

00:01:23,189 --> 00:01:28,229
good solution you can document what your

00:01:25,920 --> 00:01:29,850
intent was in the parameter name if you

00:01:28,229 --> 00:01:33,299
do this very consistently you wind up

00:01:29,850 --> 00:01:35,100
with absent garyun which is fine but

00:01:33,299 --> 00:01:37,380
what we're trying to provide here is

00:01:35,100 --> 00:01:38,880
information about the kind of stuff

00:01:37,380 --> 00:01:40,890
we're dealing with this is really

00:01:38,880 --> 00:01:42,720
fundamentally type information it

00:01:40,890 --> 00:01:45,750
belongs with the parameter type not with

00:01:42,720 --> 00:01:48,180
the parameter name so you can say great

00:01:45,750 --> 00:01:49,590
let's do a type def and this is good

00:01:48,180 --> 00:01:50,729
this is better it puts the information

00:01:49,590 --> 00:01:53,729
where it belongs

00:01:50,729 --> 00:01:56,990
but type def SAR only good they're not

00:01:53,729 --> 00:01:58,829
great we're nowhere near slice bread

00:01:56,990 --> 00:02:01,079
it's good because you have a

00:01:58,829 --> 00:02:02,790
semantically meaningful type name now it

00:02:01,079 --> 00:02:04,950
communicates your intent and that was

00:02:02,790 --> 00:02:07,110
the number one goal and it's easy to

00:02:04,950 --> 00:02:08,849
make comprehensive type changes now it's

00:02:07,110 --> 00:02:10,140
all in one place so if you want to

00:02:08,849 --> 00:02:11,400
substitute your type out for something

00:02:10,140 --> 00:02:13,440
else there's only one place you have to

00:02:11,400 --> 00:02:15,200
edit and that's much better than doing a

00:02:13,440 --> 00:02:18,090
search and replace all across your code

00:02:15,200 --> 00:02:21,239
the problem of the type def is it's just

00:02:18,090 --> 00:02:23,459
an alias it's not actually a new type so

00:02:21,239 --> 00:02:25,500
your function which now you may have

00:02:23,459 --> 00:02:29,459
declared you take al in a dirty will

00:02:25,500 --> 00:02:30,870
accept any un 60-40 and you can't

00:02:29,459 --> 00:02:32,670
overload it for different kinds of

00:02:30,870 --> 00:02:34,260
address if you wanted different

00:02:32,670 --> 00:02:36,300
functions for different kinds of address

00:02:34,260 --> 00:02:38,250
you have to put the type name back in

00:02:36,300 --> 00:02:40,019
the function name again and have totally

00:02:38,250 --> 00:02:43,560
independent functions this is not what

00:02:40,019 --> 00:02:45,660
we really want and unintentionally we

00:02:43,560 --> 00:02:47,550
have some bad interoperability going on

00:02:45,660 --> 00:02:49,739
here because all these addresses are

00:02:47,550 --> 00:02:52,230
just integers you can do crazy things

00:02:49,739 --> 00:02:54,150
like add them together when if you look

00:02:52,230 --> 00:02:55,980
at the domain of these things a linear

00:02:54,150 --> 00:02:57,959
address and a host physical address

00:02:55,980 --> 00:03:00,030
these things should never meet you

00:02:57,959 --> 00:03:03,900
shouldn't be able to add them it's an

00:03:00,030 --> 00:03:06,269
error so there is an idea called an

00:03:03,900 --> 00:03:08,489
opaque type def that is a separate type

00:03:06,269 --> 00:03:11,129
based on an existing type but is not

00:03:08,489 --> 00:03:13,050
simply an alias for that type it's been

00:03:11,129 --> 00:03:15,330
proposed as a language feature for a

00:03:13,050 --> 00:03:17,819
long time but we don't have it yet

00:03:15,330 --> 00:03:19,440
and what I wanted to come here today to

00:03:17,819 --> 00:03:21,540
talk about is that you don't need to

00:03:19,440 --> 00:03:24,360
wait for it it turns out that you can

00:03:21,540 --> 00:03:27,150
get most of the value probably 80% plus

00:03:24,360 --> 00:03:29,640
of this language feature proposal from a

00:03:27,150 --> 00:03:32,540
library implementation and I have done

00:03:29,640 --> 00:03:34,980
one I want to tell you about it

00:03:32,540 --> 00:03:37,110
so the basic notion here is I want to

00:03:34,980 --> 00:03:38,819
take a variable of some type and I want

00:03:37,110 --> 00:03:40,860
to wrap it up in a brand new type and

00:03:38,819 --> 00:03:42,780
I'll mimic the interface from the

00:03:40,860 --> 00:03:45,000
original type so I can use it like I

00:03:42,780 --> 00:03:47,209
would have before but all in terms of

00:03:45,000 --> 00:03:50,310
the new type because I want to avoid

00:03:47,209 --> 00:03:53,159
implicit conversions and accidental

00:03:50,310 --> 00:03:54,930
interoperability with other types so

00:03:53,159 --> 00:03:57,689
here's an example using the library I'm

00:03:54,930 --> 00:04:00,959
making a linear address type it's based

00:03:57,689 --> 00:04:02,670
on a UN 6040 and I can get basically the

00:04:00,959 --> 00:04:05,069
entire interface just through

00:04:02,670 --> 00:04:06,810
inheritance and I also have to pull in

00:04:05,069 --> 00:04:08,640
the constructor because my constructor

00:04:06,810 --> 00:04:11,159
is explicit and I want to inherit that

00:04:08,640 --> 00:04:13,200
but that's it it doesn't take very much

00:04:11,159 --> 00:04:14,390
and now I have a new type that I cannot

00:04:13,200 --> 00:04:17,900
accidentally can

00:04:14,390 --> 00:04:19,700
Jews for the old type so pretty good

00:04:17,900 --> 00:04:22,190
we're getting a little bit closer to

00:04:19,700 --> 00:04:24,380
sliced bread it only costs a few lines

00:04:22,190 --> 00:04:26,660
to create an America Pig type def and

00:04:24,380 --> 00:04:29,240
now I have safer interfaces because

00:04:26,660 --> 00:04:31,520
there's no implicit convertibility and I

00:04:29,240 --> 00:04:33,320
can overload my functions based upon

00:04:31,520 --> 00:04:34,550
this new type this becomes possible now

00:04:33,320 --> 00:04:37,520
yay

00:04:34,550 --> 00:04:39,440
pretty happy and I was also pleased that

00:04:37,520 --> 00:04:42,110
the very first time I tried to do this I

00:04:39,440 --> 00:04:44,960
found a bug in my software I had a piece

00:04:42,110 --> 00:04:47,210
of code that was using the type def so I

00:04:44,960 --> 00:04:49,610
could have easy change ability of my

00:04:47,210 --> 00:04:51,890
types so I changed the type and I put

00:04:49,610 --> 00:04:54,680
the opaque type death in and bam

00:04:51,890 --> 00:04:56,780
compiler finds bug turns out I was

00:04:54,680 --> 00:04:59,330
assigning to an integer of the wrong

00:04:56,780 --> 00:05:01,000
width and this was crossing type

00:04:59,330 --> 00:05:03,169
boundaries where I didn't intend to

00:05:01,000 --> 00:05:05,900
something that had escaped compiler

00:05:03,169 --> 00:05:08,330
warnings became a compile time error and

00:05:05,900 --> 00:05:11,660
my code would no longer compile yippee

00:05:08,330 --> 00:05:14,240
that's great but we can build on this as

00:05:11,660 --> 00:05:16,880
a foundation for more for some really

00:05:14,240 --> 00:05:18,680
neat stuff you don't need to adhere to

00:05:16,880 --> 00:05:20,419
the interface of your original type you

00:05:18,680 --> 00:05:22,460
can make changes if there are things

00:05:20,419 --> 00:05:23,960
that don't make sense to do get rid of

00:05:22,460 --> 00:05:26,060
them right you shouldn't be able to

00:05:23,960 --> 00:05:27,890
multiply two addresses that doesn't make

00:05:26,060 --> 00:05:30,140
sense so delete it and make it a

00:05:27,890 --> 00:05:32,000
compiler error you can add

00:05:30,140 --> 00:05:34,040
interoperability with other types and

00:05:32,000 --> 00:05:35,900
deliberately so you can have exactly the

00:05:34,040 --> 00:05:37,880
interactions that you want and not the

00:05:35,900 --> 00:05:40,040
ones that you don't so if you have an

00:05:37,880 --> 00:05:41,930
address or a family of address types and

00:05:40,040 --> 00:05:44,600
you want to interoperate with an off set

00:05:41,930 --> 00:05:46,220
you can do so and you can enforce the

00:05:44,600 --> 00:05:48,860
semantics you want by controlling the

00:05:46,220 --> 00:05:51,350
binary operators so you can make it an

00:05:48,860 --> 00:05:52,880
error to add two addresses but you want

00:05:51,350 --> 00:05:54,800
to be able to add an address and offset

00:05:52,880 --> 00:05:57,400
either way it's commutative and those

00:05:54,800 --> 00:06:00,229
should return address is not offsets on

00:05:57,400 --> 00:06:02,210
the other side you don't want to

00:06:00,229 --> 00:06:03,800
subtract two addresses and get an

00:06:02,210 --> 00:06:05,930
address you really want the difference

00:06:03,800 --> 00:06:08,600
of two addresses to yield and offset a

00:06:05,930 --> 00:06:09,800
different type and you want to be able

00:06:08,600 --> 00:06:11,390
to subtract an offset from an address

00:06:09,800 --> 00:06:13,880
and get an address but it should be an

00:06:11,390 --> 00:06:16,039
error to subtract an address from an

00:06:13,880 --> 00:06:17,780
offset when you're not dealing with just

00:06:16,039 --> 00:06:19,640
plain integers anymore you can do stuff

00:06:17,780 --> 00:06:24,140
like this and this is better because it

00:06:19,640 --> 00:06:26,060
catches your errors so in the library

00:06:24,140 --> 00:06:27,770
that I developed we're getting all the

00:06:26,060 --> 00:06:28,210
behavior from all the operators through

00:06:27,770 --> 00:06:30,430
in herre

00:06:28,210 --> 00:06:32,230
and it turns out that some operator is

00:06:30,430 --> 00:06:34,510
more interesting than others the ones

00:06:32,230 --> 00:06:36,820
that have an operator at and at equals

00:06:34,510 --> 00:06:40,300
pair are the really interesting ones we

00:06:36,820 --> 00:06:43,390
want those to do cool things so if the

00:06:40,300 --> 00:06:44,710
user provides operator at equals for all

00:06:43,390 --> 00:06:47,170
the types you want to interoperate with

00:06:44,710 --> 00:06:50,170
then the library can provide the

00:06:47,170 --> 00:06:52,900
operator app in terms of your operator

00:06:50,170 --> 00:06:54,400
add equals and you as the user specify

00:06:52,900 --> 00:06:56,470
whether you want it to be commutative or

00:06:54,400 --> 00:06:59,650
not if it's commutative then you only

00:06:56,470 --> 00:07:01,840
have to put the operator at equals in

00:06:59,650 --> 00:07:04,210
one of your classes not both you can get

00:07:01,840 --> 00:07:06,760
a bit of a savings that way and you as

00:07:04,210 --> 00:07:09,160
the user can specify the return type the

00:07:06,760 --> 00:07:11,170
parameter types and optionally parameter

00:07:09,160 --> 00:07:12,730
conversions sometimes you need to do

00:07:11,170 --> 00:07:14,500
this if you want to pierce the veil and

00:07:12,730 --> 00:07:16,360
go back to integers to do an operation

00:07:14,500 --> 00:07:20,020
that would normally be pre-written like

00:07:16,360 --> 00:07:22,090
subtracting two addresses so as a user I

00:07:20,020 --> 00:07:24,310
can say I want to have commutative

00:07:22,090 --> 00:07:26,590
addition of an address and offset and

00:07:24,310 --> 00:07:28,600
maternal address and how can you get

00:07:26,590 --> 00:07:31,300
that will you inherit two things and

00:07:28,600 --> 00:07:33,190
this says it's a double it returns an

00:07:31,300 --> 00:07:36,040
address these are commutative and here

00:07:33,190 --> 00:07:38,860
are both types address offset and offset

00:07:36,040 --> 00:07:40,420
address two lines to get those special

00:07:38,860 --> 00:07:42,760
behaviors and you can specify exactly

00:07:40,420 --> 00:07:46,420
how you want your type to interact with

00:07:42,760 --> 00:07:47,860
others so it's very straightforward to

00:07:46,420 --> 00:07:49,750
take an opaque type def and make

00:07:47,860 --> 00:07:52,510
extensions customize the default

00:07:49,750 --> 00:07:54,340
interface to add delete operations to

00:07:52,510 --> 00:07:57,700
fit the way that you want to use your

00:07:54,340 --> 00:07:59,530
type don't make everything integer like

00:07:57,700 --> 00:08:01,870
because that's what it started out as

00:07:59,530 --> 00:08:03,670
you can make these refinements if you

00:08:01,870 --> 00:08:05,800
want implicit conversions for example

00:08:03,670 --> 00:08:07,120
you can provide them my library doesn't

00:08:05,800 --> 00:08:09,370
put them in by default because I've

00:08:07,120 --> 00:08:11,770
found them to be very dangerous but if

00:08:09,370 --> 00:08:14,020
you want to put them in and if it's

00:08:11,770 --> 00:08:16,150
often just one line per binary operation

00:08:14,020 --> 00:08:18,250
involving some other type so it's very

00:08:16,150 --> 00:08:19,410
easy to do this and have the very strong

00:08:18,250 --> 00:08:21,910
type safety

00:08:19,410 --> 00:08:24,640
currently I do have an ugly thing that

00:08:21,910 --> 00:08:26,080
if I want to remove a binary operator

00:08:24,640 --> 00:08:27,640
that was provided by default by the

00:08:26,080 --> 00:08:29,590
library I have to do a template

00:08:27,640 --> 00:08:31,900
specialization and maybe a forward

00:08:29,590 --> 00:08:33,430
declaration it's kind of ugly I think

00:08:31,900 --> 00:08:35,920
what I'll do is I'll add another base

00:08:33,430 --> 00:08:37,120
that doesn't provide those by default

00:08:35,920 --> 00:08:39,340
and then you'll have something cleaner

00:08:37,120 --> 00:08:41,479
to inherit from

00:08:39,340 --> 00:08:43,099
so hopefully by this time you're

00:08:41,479 --> 00:08:45,320
thinking this is actually pretty cool I

00:08:43,099 --> 00:08:47,690
can make a type and refine the interface

00:08:45,320 --> 00:08:49,730
very easily a very short amount of code

00:08:47,690 --> 00:08:51,710
to make this happen that will turn my

00:08:49,730 --> 00:08:53,540
semantic bugs into compile time errors

00:08:51,710 --> 00:08:55,850
catching bugs that you don't want to

00:08:53,540 --> 00:08:58,280
have to catch later it gives you richer

00:08:55,850 --> 00:09:00,140
safer use of types and the refinements

00:08:58,280 --> 00:09:03,020
as I keep saying are very easy to make

00:09:00,140 --> 00:09:05,150
this is cheap stuff and also there's no

00:09:03,020 --> 00:09:08,930
runtime penalty all the thing goes away

00:09:05,150 --> 00:09:11,630
at just oh one and I want you to start

00:09:08,930 --> 00:09:13,970
thinking this technique is general don't

00:09:11,630 --> 00:09:16,340
limit yourself to numeric types you can

00:09:13,970 --> 00:09:17,990
use this for Strings too and the

00:09:16,340 --> 00:09:19,700
security guys are probably thinking hmmm

00:09:17,990 --> 00:09:21,860
what can I do if I had a string type

00:09:19,700 --> 00:09:24,290
that I knew was safe that came out of my

00:09:21,860 --> 00:09:26,660
application versus a string type that I

00:09:24,290 --> 00:09:29,090
know came from user input and these two

00:09:26,660 --> 00:09:31,520
types will not interoperate unless I

00:09:29,090 --> 00:09:33,830
have deliberately allowed them to you

00:09:31,520 --> 00:09:38,510
can catch bugs with this I think it's a

00:09:33,830 --> 00:09:40,100
great technique so as I said I want to

00:09:38,510 --> 00:09:42,560
make this available I'll do it under a

00:09:40,100 --> 00:09:44,990
three clause BSD license so it's free

00:09:42,560 --> 00:09:47,450
free it's actually pretty short only

00:09:44,990 --> 00:09:50,120
about 1,400 lines and the vast majority

00:09:47,450 --> 00:09:52,190
of that is dealing with the automatic

00:09:50,120 --> 00:09:55,280
creation of the binary operators through

00:09:52,190 --> 00:09:57,050
inheritance I've been able to try it on

00:09:55,280 --> 00:09:59,750
GCC and clang they're both happy with it

00:09:57,050 --> 00:10:02,330
and modern versions Visual Studio 2015

00:09:59,750 --> 00:10:04,040
was not but it might be a problem that I

00:10:02,330 --> 00:10:05,720
still have it might not be a compiler

00:10:04,040 --> 00:10:07,370
issue I only tried for a few minutes

00:10:05,720 --> 00:10:10,100
before I gave up so it do may be an easy

00:10:07,370 --> 00:10:11,990
way to fix this and ironically I did not

00:10:10,100 --> 00:10:13,520
have at my fingertips a modern version

00:10:11,990 --> 00:10:15,680
of the in chocolate powder to try with

00:10:13,520 --> 00:10:16,450
so I don't know whether it works there

00:10:15,680 --> 00:10:19,040
or not

00:10:16,450 --> 00:10:20,330
so I don't have everything packaged up

00:10:19,040 --> 00:10:21,830
ready I couldn't get that done before

00:10:20,330 --> 00:10:23,990
the conference but here's my email

00:10:21,830 --> 00:10:25,670
address you can write to me at home or

00:10:23,990 --> 00:10:27,410
at work and when I have it available

00:10:25,670 --> 00:10:30,140
then I'll let you know you can start

00:10:27,410 --> 00:10:31,730
playing with it and I probably should be

00:10:30,140 --> 00:10:33,170
submitting this to boost at some point

00:10:31,730 --> 00:10:35,120
if there's anyone out there who'd like

00:10:33,170 --> 00:10:38,450
to take my hand and guide me through

00:10:35,120 --> 00:10:40,310
that I'd appreciate that help now if I

00:10:38,450 --> 00:10:42,860
still have a moment I want to add that I

00:10:40,310 --> 00:10:44,480
ran into one thing during the

00:10:42,860 --> 00:10:47,750
implementation that I wasn't too happy

00:10:44,480 --> 00:10:49,270
about so since I have an audience of C++

00:10:47,750 --> 00:10:50,530
experts and Stan

00:10:49,270 --> 00:10:54,640
it's committee folks I thought I'd just

00:10:50,530 --> 00:10:56,860
put in a plug I really wish I had I know

00:10:54,640 --> 00:11:00,040
except Otto because I hate repeating

00:10:56,860 --> 00:11:03,010
myself and I wanted my type to provide

00:11:00,040 --> 00:11:04,960
no except nests if the basic type it was

00:11:03,010 --> 00:11:06,700
driving from was and from normal

00:11:04,960 --> 00:11:09,100
integers that almost all the operations

00:11:06,700 --> 00:11:11,320
are no except but it fits the

00:11:09,100 --> 00:11:12,850
user-defined integral like type I wanted

00:11:11,320 --> 00:11:15,100
to be able to support that too and it

00:11:12,850 --> 00:11:16,960
might not be no accept but what I wound

00:11:15,100 --> 00:11:18,340
up doing then is I repeat the body of my

00:11:16,960 --> 00:11:20,050
function in the null except clause all

00:11:18,340 --> 00:11:22,230
the time I shouldn't have to do this

00:11:20,050 --> 00:11:24,340
please make the compiler do it for me

00:11:22,230 --> 00:11:27,180
that's what I like to have an exchange

00:11:24,340 --> 00:11:27,180

YouTube URL: https://www.youtube.com/watch?v=jLdSjh8oqmE


