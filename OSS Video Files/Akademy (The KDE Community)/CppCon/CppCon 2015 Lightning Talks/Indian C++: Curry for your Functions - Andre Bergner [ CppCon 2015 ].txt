Title: Indian C++: Curry for your Functions - Andre Bergner [ CppCon 2015 ]
Publication date: 2015-10-21
Playlist: CppCon 2015 Lightning Talks
Description: 
	http://www.Cppcon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/cppcon/cppcon2015
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,030 --> 00:00:06,810
okay the topic is here Indian C++ curry

00:00:02,429 --> 00:00:11,700
for your functions so what do I mean by

00:00:06,810 --> 00:00:15,020
curry so it's actually not again so it's

00:00:11,700 --> 00:00:16,980
not it is somehow spicy C++ maybe but

00:00:15,020 --> 00:00:19,800
not curry as you see in the background

00:00:16,980 --> 00:00:23,789
it's like really it's named after this

00:00:19,800 --> 00:00:27,090
guy SK Brooks curry so he's quite

00:00:23,789 --> 00:00:28,529
impressive so here's like three names so

00:00:27,090 --> 00:00:30,689
I mean as many Americans have three

00:00:28,529 --> 00:00:32,790
names he's an American mathematician and

00:00:30,689 --> 00:00:34,770
logician and he has actually three

00:00:32,790 --> 00:00:36,390
programming languages named after him

00:00:34,770 --> 00:00:38,489
most famous one is Hesketh and there's

00:00:36,390 --> 00:00:42,270
also another one curry and even Brooks

00:00:38,489 --> 00:00:43,860
is a there's a program in English and he

00:00:42,270 --> 00:00:47,700
worked in the field of community logic

00:00:43,860 --> 00:00:49,110
and lambda calculus and in that field he

00:00:47,700 --> 00:00:50,850
invented a technique where he extended

00:00:49,110 --> 00:00:53,719
actually a technique called currying so

00:00:50,850 --> 00:00:56,789
he even made it up to the level where he

00:00:53,719 --> 00:00:59,910
he is not just a thing is named after

00:00:56,789 --> 00:01:01,890
his name like with a noun even got the

00:00:59,910 --> 00:01:04,619
verb so really currying so this is like

00:01:01,890 --> 00:01:08,220
really impressive so not many people are

00:01:04,619 --> 00:01:12,689
able to do that it's a name maybe Taylor

00:01:08,220 --> 00:01:15,150
did it so what is currying so I'm

00:01:12,689 --> 00:01:17,729
currently functional program is pretty

00:01:15,150 --> 00:01:20,040
hot so a lot of people are jumping on it

00:01:17,729 --> 00:01:21,710
so everybody is excited about everybody

00:01:20,040 --> 00:01:24,630
but a lot of people are excited about it

00:01:21,710 --> 00:01:26,670
some simply because I love esoteric

00:01:24,630 --> 00:01:28,710
stuff others simply because they know

00:01:26,670 --> 00:01:31,290
it's important for the future when

00:01:28,710 --> 00:01:32,820
everything gets paralyzed you need you

00:01:31,290 --> 00:01:36,119
need a functional paradigm in order to

00:01:32,820 --> 00:01:37,500
get to get control over your logic so

00:01:36,119 --> 00:01:40,710
because you lose it in the imperative

00:01:37,500 --> 00:01:42,390
paradigm so what is Korean so occurring

00:01:40,710 --> 00:01:44,220
is an essential part of yeah all

00:01:42,390 --> 00:01:45,840
functional programming languages and it

00:01:44,220 --> 00:01:49,079
basically looks like this so here's an

00:01:45,840 --> 00:01:52,829
example from Hesco so the explanation is

00:01:49,079 --> 00:01:55,049
basically this currying splits a

00:01:52,829 --> 00:01:58,340
function of n arguments so usually so

00:01:55,049 --> 00:02:02,219
you have a function of let's say F X Y Z

00:01:58,340 --> 00:02:04,350
into n functions of each one argument so

00:02:02,219 --> 00:02:05,939
it kind of does some magic with the

00:02:04,350 --> 00:02:09,149
functions and it does it by a technique

00:02:05,939 --> 00:02:10,860
called partial function evaluation so

00:02:09,149 --> 00:02:12,120
Haskell has that built in or all

00:02:10,860 --> 00:02:14,180
functional programming languages have

00:02:12,120 --> 00:02:16,220
that built in into there

00:02:14,180 --> 00:02:17,720
into the language so for instance in

00:02:16,220 --> 00:02:19,610
this Haskell example I define a

00:02:17,720 --> 00:02:21,650
functions or a translate that for you

00:02:19,610 --> 00:02:23,750
I define a function Plus that takes two

00:02:21,650 --> 00:02:26,629
arguments apparently takes two arguments

00:02:23,750 --> 00:02:28,340
X and Y and I say this function the

00:02:26,629 --> 00:02:30,260
evaluation of that function is simply it

00:02:28,340 --> 00:02:32,629
just adds South to argument so that what

00:02:30,260 --> 00:02:35,569
it says but then I can create a function

00:02:32,629 --> 00:02:37,340
plus three X so this is no function the

00:02:35,569 --> 00:02:41,659
name of the function is plus three and

00:02:37,340 --> 00:02:43,700
it takes one argument X and it sorry

00:02:41,659 --> 00:02:46,310
that there's a typo that should be plus

00:02:43,700 --> 00:02:49,069
renamed that in between so it should be

00:02:46,310 --> 00:02:53,810
plus x3 so this function calls the other

00:02:49,069 --> 00:02:55,129
function and and puts one one where

00:02:53,810 --> 00:02:56,480
you're already in it so there this is a

00:02:55,129 --> 00:02:59,329
this is one step where the partial

00:02:56,480 --> 00:03:02,269
evaluation happens already and so you

00:02:59,329 --> 00:03:05,780
can define one function by calling half

00:03:02,269 --> 00:03:08,239
of another function basically and then I

00:03:05,780 --> 00:03:11,209
use it so map that's like the Haskell

00:03:08,239 --> 00:03:13,549
counterpart for transform in C++ so I

00:03:11,209 --> 00:03:15,709
say map this function plus three onto an

00:03:13,549 --> 00:03:19,069
area of integers and this will print out

00:03:15,709 --> 00:03:21,290
four five six obviously and but I can

00:03:19,069 --> 00:03:24,440
also just put any front a partial

00:03:21,290 --> 00:03:26,329
function directly at the place so this

00:03:24,440 --> 00:03:28,730
would be an anonymous partial function

00:03:26,329 --> 00:03:31,549
so if I say map plus three so now I take

00:03:28,730 --> 00:03:33,709
the plus from the first line and just

00:03:31,549 --> 00:03:35,180
put one argument in it I mean the

00:03:33,709 --> 00:03:38,480
function would take two arguments I just

00:03:35,180 --> 00:03:41,540
put one in so basically the result of

00:03:38,480 --> 00:03:43,459
plus 3 is a anonymous function which

00:03:41,540 --> 00:03:45,440
takes one argument and has the three

00:03:43,459 --> 00:03:46,909
bound already and then this function

00:03:45,440 --> 00:03:50,959
gets applied to each argument in the

00:03:46,909 --> 00:03:54,650
early list so that's our you work in

00:03:50,959 --> 00:03:56,180
Haskell and this is basically the the

00:03:54,650 --> 00:03:57,979
fundamentals of all functional

00:03:56,180 --> 00:03:59,150
programming because you have a lot of

00:03:57,979 --> 00:04:01,370
higher-order functions that means

00:03:59,150 --> 00:04:02,989
functions that take are that functions

00:04:01,370 --> 00:04:04,760
that take functions as arguments and

00:04:02,989 --> 00:04:07,220
functions that return functions so I

00:04:04,760 --> 00:04:09,470
mean this is already each function

00:04:07,220 --> 00:04:11,840
inherently has the capability to return

00:04:09,470 --> 00:04:15,500
it safe partially bound as a new

00:04:11,840 --> 00:04:19,220
function and so this is the core of the

00:04:15,500 --> 00:04:23,180
idea and so now it would be I think

00:04:19,220 --> 00:04:25,219
everybody has come to that point at

00:04:23,180 --> 00:04:25,550
least useless there are algorithms and

00:04:25,219 --> 00:04:27,409
they

00:04:25,550 --> 00:04:29,090
it actually would be a would have to be

00:04:27,409 --> 00:04:31,819
nice if you have the same feature in C++

00:04:29,090 --> 00:04:33,620
so let me give you an example so I'm I

00:04:31,819 --> 00:04:35,870
already shortened that a little bit by

00:04:33,620 --> 00:04:37,520
using some kind of range syntax as its

00:04:35,870 --> 00:04:40,310
proper as he evident booze or the

00:04:37,520 --> 00:04:43,370
proposed for the standard I just put it

00:04:40,310 --> 00:04:46,610
into an artificial range namespace so

00:04:43,370 --> 00:04:49,490
make it clear so I have now a I saying

00:04:46,610 --> 00:04:52,280
if I want to do the same thing in C++

00:04:49,490 --> 00:04:53,930
with the current the way of doing it I

00:04:52,280 --> 00:04:56,389
would need to call I could use alumna of

00:04:53,930 --> 00:05:01,099
course but she I didn't use it in the 98

00:04:56,389 --> 00:05:03,590
stars then I say I bind to a source

00:05:01,099 --> 00:05:05,150
state pint of state plus which comes

00:05:03,590 --> 00:05:07,729
from the standards from actually the

00:05:05,150 --> 00:05:11,599
head of functional and I bind the

00:05:07,729 --> 00:05:13,759
argument 3 to plus 2 state plus so I

00:05:11,599 --> 00:05:15,080
mean this is all I mean the earlier of a

00:05:13,759 --> 00:05:15,710
lot of boilerplate if you compare that

00:05:15,080 --> 00:05:18,259
with Haskell

00:05:15,710 --> 00:05:19,789
so you have to specify the type of plus

00:05:18,259 --> 00:05:21,409
of course ok the namespace you get

00:05:19,789 --> 00:05:23,180
ripped off but then you have to call

00:05:21,409 --> 00:05:25,819
that bind and then you can actually

00:05:23,180 --> 00:05:28,599
apply it I mean at least I could put it

00:05:25,819 --> 00:05:32,360
into this argument for the transform but

00:05:28,599 --> 00:05:35,840
this is pretty awkward so what I would

00:05:32,360 --> 00:05:37,699
like to have is that so I would just do

00:05:35,840 --> 00:05:40,069
the same as I can do and had a scherzo I

00:05:37,699 --> 00:05:42,949
mean this would be the wishful thinking

00:05:40,069 --> 00:05:45,380
and C++ way so I say if a transform of a

00:05:42,949 --> 00:05:47,659
range so in that case it's an

00:05:45,380 --> 00:05:50,509
initializer list and then I call my

00:05:47,659 --> 00:05:53,110
function plus in that case and plus

00:05:50,509 --> 00:05:55,789
inherently has the capability of

00:05:53,110 --> 00:05:57,620
returning if it's applied just with one

00:05:55,789 --> 00:05:59,090
argument it returns a new function they

00:05:57,620 --> 00:06:03,319
take the other argument which is now

00:05:59,090 --> 00:06:04,879
expected by the transform algorithm so

00:06:03,319 --> 00:06:06,710
when I set down and then thought a

00:06:04,879 --> 00:06:09,020
little bit about it and found a way to

00:06:06,710 --> 00:06:11,120
actually implement it in C++ so I mean

00:06:09,020 --> 00:06:13,370
it could be in language feature but you

00:06:11,120 --> 00:06:17,629
can still write a library code that does

00:06:13,370 --> 00:06:19,940
that so here's some client code that

00:06:17,629 --> 00:06:21,469
demonstrates how to how does it work so

00:06:19,940 --> 00:06:24,379
this basically my unit tests in my

00:06:21,469 --> 00:06:27,379
little example which I have online so I

00:06:24,379 --> 00:06:30,680
writes up is my my curried function so I

00:06:27,379 --> 00:06:33,820
have a function career and this curry

00:06:30,680 --> 00:06:36,919
function takes a function and returns a

00:06:33,820 --> 00:06:38,790
new function that is inherently variable

00:06:36,919 --> 00:06:42,360
so a function that has

00:06:38,790 --> 00:06:45,390
capability so in that case I take the

00:06:42,360 --> 00:06:48,120
C++ 14 numbness so I say curry of my

00:06:45,390 --> 00:06:50,490
lambda are taking two arguments in that

00:06:48,120 --> 00:06:54,270
case it's a subtract subtraction

00:06:50,490 --> 00:06:56,430
X minus y and the other example is M XOR

00:06:54,270 --> 00:06:58,800
multiply accumulate so the common

00:06:56,430 --> 00:07:00,960
operation in like all kind of linear

00:06:58,800 --> 00:07:03,180
transform so that takes point since

00:07:00,960 --> 00:07:06,390
three arguments and which is defined as

00:07:03,180 --> 00:07:08,040
X plus y times Z and then down there you

00:07:06,390 --> 00:07:10,890
see a lot of examples how you can use it

00:07:08,040 --> 00:07:13,020
so I came to find a new partial function

00:07:10,890 --> 00:07:15,320
so sup from eight would be simply sub

00:07:13,020 --> 00:07:19,350
eight so this is now a new function that

00:07:15,320 --> 00:07:22,680
subtracts the argument from eight I can

00:07:19,350 --> 00:07:25,110
use that I can just call sup with two

00:07:22,680 --> 00:07:26,940
times an argument because that's obvious

00:07:25,110 --> 00:07:28,560
so because it's the first argument call

00:07:26,940 --> 00:07:31,020
returns a function and then I can't call

00:07:28,560 --> 00:07:32,730
again a function argument evaluation on

00:07:31,020 --> 00:07:34,620
that one or I just can call it a

00:07:32,730 --> 00:07:36,120
standard way by just putting in two

00:07:34,620 --> 00:07:37,920
arguments and each time it will always

00:07:36,120 --> 00:07:40,230
return the correct result five in that

00:07:37,920 --> 00:07:41,490
case same for the other one so that one

00:07:40,230 --> 00:07:44,100
takes three arguments you I was also

00:07:41,490 --> 00:07:46,470
playing a little bit with and in theory

00:07:44,100 --> 00:07:48,720
I could forbid that but you can also

00:07:46,470 --> 00:07:50,700
import the function with no arguments

00:07:48,720 --> 00:07:51,750
which should be recalls and returns a

00:07:50,700 --> 00:07:54,360
function is safe again

00:07:51,750 --> 00:07:55,860
so the last example you see like I

00:07:54,360 --> 00:07:57,720
called with no argument and this one

00:07:55,860 --> 00:08:00,180
there's no argument and so on so this or

00:07:57,720 --> 00:08:03,750
Burks and now I'll show you the

00:08:00,180 --> 00:08:05,460
implementation so unfortunately color

00:08:03,750 --> 00:08:07,920
highlighting doesn't work highlights is

00:08:05,460 --> 00:08:10,680
doesn't use doesn't like deca type so

00:08:07,920 --> 00:08:14,160
but this is all the code and now I go

00:08:10,680 --> 00:08:18,270
through it step by step so now it let's

00:08:14,160 --> 00:08:20,640
show one first step M first just the

00:08:18,270 --> 00:08:23,330
first example is a this function I was

00:08:20,640 --> 00:08:25,950
calling curry is a function that takes a

00:08:23,330 --> 00:08:28,650
function so the function which I want to

00:08:25,950 --> 00:08:30,480
curry and potentially some arguments you

00:08:28,650 --> 00:08:33,000
you understand a moment why I need that

00:08:30,480 --> 00:08:36,150
and it returns a currying binder which

00:08:33,000 --> 00:08:39,840
is a struct I show you in a minute it

00:08:36,150 --> 00:08:44,520
does magic it just stores the function

00:08:39,840 --> 00:08:46,500
and those arguments in that binder so

00:08:44,520 --> 00:08:49,200
how does it look like so this is the

00:08:46,500 --> 00:08:51,600
first part of the destruct so you see

00:08:49,200 --> 00:08:54,509
the public interface to it and

00:08:51,600 --> 00:08:56,730
private members so the private members

00:08:54,509 --> 00:09:00,120
is where a function that should be

00:08:56,730 --> 00:09:03,029
stored and a couple of all the arguments

00:09:00,120 --> 00:09:05,579
that should be bound into into that

00:09:03,029 --> 00:09:07,380
binder and then the public interface

00:09:05,579 --> 00:09:10,139
where it's a constructor so you can

00:09:07,380 --> 00:09:10,500
that's this thing it simply stores this

00:09:10,139 --> 00:09:12,660
stuff

00:09:10,500 --> 00:09:14,970
and then it has a call operator that

00:09:12,660 --> 00:09:18,990
takes a list of other arguments so they

00:09:14,970 --> 00:09:21,360
are the bound arguments arguments so two

00:09:18,990 --> 00:09:23,130
two bound arguments are the one that are

00:09:21,360 --> 00:09:24,930
stored internally and others which are

00:09:23,130 --> 00:09:29,639
the one I always can call the thingis

00:09:24,930 --> 00:09:31,829
and internally it does so this is now

00:09:29,639 --> 00:09:35,250
the internal cord so this is where the

00:09:31,829 --> 00:09:36,690
magic happens so it calls so I don't

00:09:35,250 --> 00:09:42,509
know who has ever used to make index

00:09:36,690 --> 00:09:45,269
sequence you and okay so this is a thing

00:09:42,509 --> 00:09:46,829
that came with C++ 14 and that's the

00:09:45,269 --> 00:09:49,199
thing you need whenever you have

00:09:46,829 --> 00:09:51,779
arguments in a tuple and you want to

00:09:49,199 --> 00:09:54,300
apply all those arguments that are

00:09:51,779 --> 00:09:56,790
stored in a tuple into a function so

00:09:54,300 --> 00:10:00,990
then the problem is you can't just do

00:09:56,790 --> 00:10:03,540
the the tester that the type expansion

00:10:00,990 --> 00:10:05,699
on on a topic you have to magically

00:10:03,540 --> 00:10:09,449
force the compiler with that little

00:10:05,699 --> 00:10:11,279
trick to get to get the argument out of

00:10:09,449 --> 00:10:13,949
the tablet and put it into a function so

00:10:11,279 --> 00:10:16,920
make index sequence size of bound arcs

00:10:13,949 --> 00:10:21,180
simply creates a empty template type

00:10:16,920 --> 00:10:24,630
that has a non type list of integers

00:10:21,180 --> 00:10:28,110
just going from 0 to n minus 1 so it's

00:10:24,630 --> 00:10:31,889
just index into some some some topic in

00:10:28,110 --> 00:10:33,990
that case so it's just a helper struct

00:10:31,889 --> 00:10:37,470
that meter programming hyper structure

00:10:33,990 --> 00:10:38,910
came with C++ 14 in the STA and then the

00:10:37,470 --> 00:10:41,579
second part is obvious I just forward

00:10:38,910 --> 00:10:43,709
other arguments into that core function

00:10:41,579 --> 00:10:45,360
so now how does that one look like so

00:10:43,709 --> 00:10:49,560
story here the color highlighting is

00:10:45,360 --> 00:10:52,319
broken so it's a little bit messy okay

00:10:49,560 --> 00:10:56,850
down here you see the that's a function

00:10:52,319 --> 00:10:58,649
I call so this function gets now okay

00:10:56,850 --> 00:11:02,910
three means this function gets the index

00:10:58,649 --> 00:11:05,040
equals index sequence of what the

00:11:02,910 --> 00:11:08,820
integers are a list of integers

00:11:05,040 --> 00:11:11,430
the other arguments and so this is not

00:11:08,820 --> 00:11:12,750
how you get how you get the index into

00:11:11,430 --> 00:11:16,200
the top layer because you let the

00:11:12,750 --> 00:11:19,020
compiler deduce the the integer numbers

00:11:16,200 --> 00:11:21,870
from the individualist and that's just 0

00:11:19,020 --> 00:11:25,830
up to n minus 1 where n minus 1 or n is

00:11:21,870 --> 00:11:30,180
a number of the bound arguments so the

00:11:25,830 --> 00:11:33,540
basically the size of the topic and so

00:11:30,180 --> 00:11:35,610
it it calls get with the expansion of

00:11:33,540 --> 00:11:37,170
the ends and then it called simply

00:11:35,610 --> 00:11:38,910
forward with the expansion of the other

00:11:37,170 --> 00:11:40,740
arguments so there are two lists of so

00:11:38,910 --> 00:11:42,510
the one that's actually arguments and

00:11:40,740 --> 00:11:45,330
the other is an index into the store

00:11:42,510 --> 00:11:48,410
topple so two lists two and Vario em

00:11:45,330 --> 00:11:50,640
variadic templates gets extended here

00:11:48,410 --> 00:11:52,440
and now there's the second magic

00:11:50,640 --> 00:11:55,530
happenings we just try to invoke

00:11:52,440 --> 00:11:57,330
functions so I'm using shoes who has

00:11:55,530 --> 00:11:59,670
used expressions fine a or who knows

00:11:57,330 --> 00:12:03,660
what expressions fine is what so just if

00:11:59,670 --> 00:12:06,420
you want so so expressions finite is a

00:12:03,660 --> 00:12:11,520
technique so spiny in general n states

00:12:06,420 --> 00:12:14,220
that if the compiler and it's a compiler

00:12:11,520 --> 00:12:15,810
tries to find so you have a template

00:12:14,220 --> 00:12:18,120
function that the compiler tries to

00:12:15,810 --> 00:12:20,700
deduce the arguments of the other type

00:12:18,120 --> 00:12:24,330
of their template from the given

00:12:20,700 --> 00:12:26,100
arguments of that function there's a

00:12:24,330 --> 00:12:29,130
rule that if it fails for whatever

00:12:26,100 --> 00:12:30,600
reason it it just drops that function

00:12:29,130 --> 00:12:33,300
and tries to find another function with

00:12:30,600 --> 00:12:35,640
the same name that also might fit for

00:12:33,300 --> 00:12:37,650
the arguments so but there as always it

00:12:35,640 --> 00:12:39,450
tries first try it's a perfect fit and

00:12:37,650 --> 00:12:41,220
then it tries to next best fit and if it

00:12:39,450 --> 00:12:43,770
doesn't find any functions and then it

00:12:41,220 --> 00:12:46,400
actually creates a compiler error so

00:12:43,770 --> 00:12:48,510
what this technique is always used for

00:12:46,400 --> 00:12:50,550
creating this kind of reflection

00:12:48,510 --> 00:12:52,890
mechanisms which is missing in C++ so

00:12:50,550 --> 00:12:57,630
the same thing is happening here so I

00:12:52,890 --> 00:12:59,520
have two structs one is the basically is

00:12:57,630 --> 00:13:01,970
a more general one curry which is called

00:12:59,520 --> 00:13:05,280
curry arguments and the second struct is

00:13:01,970 --> 00:13:06,750
is a inherits from curry arguments on

00:13:05,280 --> 00:13:09,000
which is called try to invoke functions

00:13:06,750 --> 00:13:12,390
so and now I call my dispatch function

00:13:09,000 --> 00:13:13,650
with specialized struct which is called

00:13:12,390 --> 00:13:18,050
try to invoke function so that's the

00:13:13,650 --> 00:13:21,350
first one up here this one has echo type

00:13:18,050 --> 00:13:23,450
of the function which is thought applied

00:13:21,350 --> 00:13:26,750
with the argument list supply to the

00:13:23,450 --> 00:13:29,540
function so that means the compiler now

00:13:26,750 --> 00:13:30,950
tries to deduce the type the return type

00:13:29,540 --> 00:13:33,500
of that function if it would be called

00:13:30,950 --> 00:13:35,660
with those arguments if it succeeded if

00:13:33,500 --> 00:13:37,010
it succeeds it simply evaluates a

00:13:35,660 --> 00:13:38,209
function and returns the arguments

00:13:37,010 --> 00:13:41,120
that's basically the end of our

00:13:38,209 --> 00:13:43,370
occurring if it doesn't succeed it drops

00:13:41,120 --> 00:13:45,380
this function overload and goes to the

00:13:43,370 --> 00:13:47,149
second one so the the Curie arguments

00:13:45,380 --> 00:13:48,920
version because curry arguments derives

00:13:47,149 --> 00:13:50,420
from the other class so it is a it's

00:13:48,920 --> 00:13:53,899
implicitly convertible to the other

00:13:50,420 --> 00:13:56,690
structure and what what this one does it

00:13:53,899 --> 00:13:58,790
simply again calls curry with the

00:13:56,690 --> 00:14:00,500
arguments given enter function so it

00:13:58,790 --> 00:14:03,380
creates a new version of itself with a

00:14:00,500 --> 00:14:05,029
new argument list and and the function

00:14:03,380 --> 00:14:08,450
again so basically forwards that into a

00:14:05,029 --> 00:14:10,970
new bound list so I think time is almost

00:14:08,450 --> 00:14:15,550
up and yeah and that's how it works so

00:14:10,970 --> 00:14:15,550

YouTube URL: https://www.youtube.com/watch?v=zVLLdGlbCSw


