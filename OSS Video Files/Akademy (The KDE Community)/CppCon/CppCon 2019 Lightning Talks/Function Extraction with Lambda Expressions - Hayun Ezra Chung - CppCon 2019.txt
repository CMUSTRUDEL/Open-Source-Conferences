Title: Function Extraction with Lambda Expressions - Hayun Ezra Chung - CppCon 2019
Publication date: 2019-10-23
Playlist: CppCon 2019 Lightning Talks
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,280 --> 00:00:14,040
hello my name is Ezra I'm also known as

00:00:11,010 --> 00:00:17,460
eres EPP on slack and discord as the

00:00:14,040 --> 00:00:19,770
title implies lambda expressions is used

00:00:17,460 --> 00:00:22,140
in this talk if you wish to learn about

00:00:19,770 --> 00:00:24,570
them I highly recommend Arthur CPP Con

00:00:22,140 --> 00:00:27,510
2015 talk lambdas from first principles

00:00:24,570 --> 00:00:29,730
a whirlwind tour of C++ a few months ago

00:00:27,510 --> 00:00:31,800
I came across this document on github

00:00:29,730 --> 00:00:33,989
called a guy primer it has a section

00:00:31,800 --> 00:00:36,330
named code refactoring which begins with

00:00:33,989 --> 00:00:38,460
this paragraph all code begins its life

00:00:36,330 --> 00:00:40,950
in some kind of code block before moving

00:00:38,460 --> 00:00:42,840
on to be used in more general cases Jai

00:00:40,950 --> 00:00:44,670
a programming language has some special

00:00:42,840 --> 00:00:46,800
syntax that can assist the programmer in

00:00:44,670 --> 00:00:48,899
moving code from specific cases out into

00:00:46,800 --> 00:00:51,719
general cases to facilitate code reuse

00:00:48,899 --> 00:00:53,610
in other words function extraction it

00:00:51,719 --> 00:00:55,739
turns out that although C++ doesn't have

00:00:53,610 --> 00:00:57,809
the convenient syntax Jai has the

00:00:55,739 --> 00:01:00,690
technique this section describes is

00:00:57,809 --> 00:01:02,850
possible in C++ and just as effective I

00:01:00,690 --> 00:01:04,739
wanted to demonstrate it here today I

00:01:02,850 --> 00:01:06,420
suppose we have this function named

00:01:04,739 --> 00:01:11,520
update it gets a map

00:01:06,420 --> 00:01:13,680
well map a key and a value and if the

00:01:11,520 --> 00:01:16,080
key exists in the map it updates like 16

00:01:13,680 --> 00:01:17,700
value if it does not exist it inserts a

00:01:16,080 --> 00:01:19,710
key value pair and returns whether or

00:01:17,700 --> 00:01:21,900
not it got inserted pretty standard

00:01:19,710 --> 00:01:23,670
stuff as currently written there's

00:01:21,900 --> 00:01:26,340
clearly two parts to this function it

00:01:23,670 --> 00:01:28,979
has the fine step and it has the update

00:01:26,340 --> 00:01:31,650
value step suppose we want to extract

00:01:28,979 --> 00:01:34,220
this find step out of this function into

00:01:31,650 --> 00:01:37,229
its own function sounds reasonable

00:01:34,220 --> 00:01:39,920
according to J primer we can we have a

00:01:37,229 --> 00:01:44,430
series of step by step process to

00:01:39,920 --> 00:01:45,810
accomplish this first step is to wrap it

00:01:44,430 --> 00:01:48,509
in and immediately invoked at lambda

00:01:45,810 --> 00:01:51,090
expression note the capture by reference

00:01:48,509 --> 00:01:53,130
what this does is it makes the compiler

00:01:51,090 --> 00:01:55,560
assist you it tells you through

00:01:53,130 --> 00:01:58,649
compilation errors what the return type

00:01:55,560 --> 00:02:02,909
should be in this case we have to return

00:01:58,649 --> 00:02:07,049
the value of left so let's go ahead and

00:02:02,909 --> 00:02:08,399
do that if we stopped right here this is

00:02:07,049 --> 00:02:11,910
we already have two significant

00:02:08,399 --> 00:02:14,280
improvements first the code used to

00:02:11,910 --> 00:02:16,440
initialize the result in value which we

00:02:14,280 --> 00:02:20,220
have named it err is isolated from the

00:02:16,440 --> 00:02:22,050
rest of the context and second this

00:02:20,220 --> 00:02:23,940
bought us the ability to cause

00:02:22,050 --> 00:02:25,380
qualified the result meaning that the

00:02:23,940 --> 00:02:27,330
entire bottom half of this vid

00:02:25,380 --> 00:02:29,960
we can simply ignore it for the rest of

00:02:27,330 --> 00:02:33,270
the talk because Const is awesome

00:02:29,960 --> 00:02:33,750
next step that capture by reference get

00:02:33,270 --> 00:02:36,180
rid of it

00:02:33,750 --> 00:02:38,760
this time the compiler will assist us in

00:02:36,180 --> 00:02:41,370
identifying the arguments to the TV

00:02:38,760 --> 00:02:43,200
function in this case it says Matt that

00:02:41,370 --> 00:02:45,780
cannot be implicitly captured so let's

00:02:43,200 --> 00:02:47,520
capture that and now it says key cannot

00:02:45,780 --> 00:02:49,860
be imposed to be captured let's capture

00:02:47,520 --> 00:02:52,200
that as well and what we end up with is

00:02:49,860 --> 00:02:55,670
the exact set of values we have to pass

00:02:52,200 --> 00:02:58,800
to this code block in when we're trouble

00:02:55,670 --> 00:03:00,510
words the exact set of values we have to

00:02:58,800 --> 00:03:03,180
pass into this code block as function

00:03:00,510 --> 00:03:05,100
parameters and so we can move that into

00:03:03,180 --> 00:03:07,350
function parameters and here we can

00:03:05,100 --> 00:03:09,630
decide whether we want to pass by value

00:03:07,350 --> 00:03:12,270
or by reference or even add Const

00:03:09,630 --> 00:03:16,380
qualifiers and what this bought us is

00:03:12,270 --> 00:03:19,080
the ability to take this highlighted

00:03:16,380 --> 00:03:23,580
section of code and literally copy and

00:03:19,080 --> 00:03:26,160
paste it into an external function fix

00:03:23,580 --> 00:03:29,070
the syntax and that is function

00:03:26,160 --> 00:03:33,270
extraction with lambda expressions thank

00:03:29,070 --> 00:03:34,350
you oh yes there's a lot of cases I've

00:03:33,270 --> 00:03:35,940
done I cover it like if you were to

00:03:34,350 --> 00:03:37,050
extracting a member function or if we

00:03:35,940 --> 00:03:38,730
want to extract it as a function

00:03:37,050 --> 00:03:41,040
template if you're interested please ask

00:03:38,730 --> 00:03:43,720
me for details thank you

00:03:41,040 --> 00:03:43,720

YouTube URL: https://www.youtube.com/watch?v=VBZwzox3650


