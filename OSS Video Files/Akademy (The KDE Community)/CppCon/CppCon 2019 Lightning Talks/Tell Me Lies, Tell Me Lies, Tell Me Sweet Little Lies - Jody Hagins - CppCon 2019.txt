Title: Tell Me Lies, Tell Me Lies, Tell Me Sweet Little Lies - Jody Hagins - CppCon 2019
Publication date: 2019-10-23
Playlist: CppCon 2019 Lightning Talks
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,800 --> 00:00:19,670
go ahead start alright so tell me lies

00:00:15,620 --> 00:00:25,619
tell me sweet little eyes why do we lie

00:00:19,670 --> 00:00:28,500
well the bottom line is because it's

00:00:25,619 --> 00:00:32,460
easier than telling the truth and and

00:00:28,500 --> 00:00:33,870
C++ makes it very easy to lie in fact

00:00:32,460 --> 00:00:37,700
sometimes you don't even have to do

00:00:33,870 --> 00:00:42,120
anything to tell lies line number one

00:00:37,700 --> 00:00:44,039
here's this code I have a this static

00:00:42,120 --> 00:00:46,079
assert at the bottom tells me that I can

00:00:44,039 --> 00:00:50,789
construct this with a reference to that

00:00:46,079 --> 00:00:58,500
type so I go and construct one because

00:00:50,789 --> 00:01:00,210
I've been told I could do so oh I can't

00:00:58,500 --> 00:01:02,969
I can't even though even though I was

00:01:00,210 --> 00:01:05,070
told I asked the class I queried it I

00:01:02,969 --> 00:01:07,980
said can i construct you and it said yes

00:01:05,070 --> 00:01:10,950
and I tried and failed so I have to go

00:01:07,980 --> 00:01:12,750
and fix it so I have to add this little

00:01:10,950 --> 00:01:15,240
piece of magic in there basically say

00:01:12,750 --> 00:01:17,130
I'm not the same the reasons it would in

00:01:15,240 --> 00:01:18,630
a five minute lightning talk I can't go

00:01:17,130 --> 00:01:21,570
into all the reasons behind these little

00:01:18,630 --> 00:01:23,549
lies but ask me later I'll be glad to do

00:01:21,570 --> 00:01:25,619
that or if the talk doesn't totally suck

00:01:23,549 --> 00:01:27,509
maybe I'll try and create a longer one

00:01:25,619 --> 00:01:29,220
that goes into all these details but so

00:01:27,509 --> 00:01:31,409
now I'm not telling a lie anymore

00:01:29,220 --> 00:01:33,329
but look at how what I had to do I had

00:01:31,409 --> 00:01:34,680
to try and do some stuff so that it

00:01:33,329 --> 00:01:37,680
wouldn't be telling lies anymore

00:01:34,680 --> 00:01:40,409
flight number two this is the exact same

00:01:37,680 --> 00:01:41,640
code earlier except that the tell me

00:01:40,409 --> 00:01:44,579
lies function there's a little bit

00:01:41,640 --> 00:01:46,110
different I asked it can i construct you

00:01:44,579 --> 00:01:49,649
with a couple events and it says sure

00:01:46,110 --> 00:01:55,799
you can so i construct with a couple

00:01:49,649 --> 00:01:57,210
events and i have another lie because i

00:01:55,799 --> 00:01:59,850
can't construct it with a couple events

00:01:57,210 --> 00:02:01,829
the compiler i was told at compile time

00:01:59,850 --> 00:02:04,110
when I queried it that I could and then

00:02:01,829 --> 00:02:07,530
I really can't so now I have to go in

00:02:04,110 --> 00:02:09,509
and add some more magic and now in my

00:02:07,530 --> 00:02:12,380
truth I can assert that I can't

00:02:09,509 --> 00:02:17,100
construct it and it tells me the truth

00:02:12,380 --> 00:02:18,450
so line number three this is similar to

00:02:17,100 --> 00:02:21,090
the other one but so I have a call

00:02:18,450 --> 00:02:23,849
operator and I

00:02:21,090 --> 00:02:26,220
that it's in vocable right this new nice

00:02:23,849 --> 00:02:28,140
thing can I invoke this function sure

00:02:26,220 --> 00:02:30,000
you can invoke the function then let me

00:02:28,140 --> 00:02:38,489
go and VOC the function I create one and

00:02:30,000 --> 00:02:41,250
invoke it and no I can't so I have to go

00:02:38,489 --> 00:02:43,349
and fix it and now I add a deco type

00:02:41,250 --> 00:02:45,180
telling me whether I can actually invoke

00:02:43,349 --> 00:02:46,890
it and now I can assert and say no you

00:02:45,180 --> 00:02:50,660
can't invoke this thing and now I

00:02:46,890 --> 00:02:52,340
finally get to the truth line immersive

00:02:50,660 --> 00:02:58,890
this one's a little bit different

00:02:52,340 --> 00:03:01,319
different because the lie here is that I

00:02:58,890 --> 00:03:03,510
should be able to assert that calling

00:03:01,319 --> 00:03:05,340
with a temporary I live you can see that

00:03:03,510 --> 00:03:07,080
but I the first do something is calling

00:03:05,340 --> 00:03:09,720
there's a temporary there calling with

00:03:07,080 --> 00:03:11,970
two ents that should return one calling

00:03:09,720 --> 00:03:14,280
with a temporary with a 1 and a 1 dot 0

00:03:11,970 --> 00:03:23,760
which is a double that should basically

00:03:14,280 --> 00:03:28,260
return to right no it actually returns

00:03:23,760 --> 00:03:30,600
one why well because I have an r-value

00:03:28,260 --> 00:03:33,150
qualifier BAR value qualified the int

00:03:30,600 --> 00:03:37,109
double and that do something function is

00:03:33,150 --> 00:03:42,470
taking the function by value and so I

00:03:37,109 --> 00:03:42,470
know how to fix that there we go Oh

00:03:46,790 --> 00:03:51,720
still a problem it still doesn't work

00:03:48,959 --> 00:03:54,930
because I need to perfectly forward it

00:03:51,720 --> 00:03:57,720
so now I can actually get the truth

00:03:54,930 --> 00:03:59,430
because now one equals when I pass it

00:03:57,720 --> 00:04:01,290
with the temporary and two is passing

00:03:59,430 --> 00:04:04,380
without the temporary now this one is

00:04:01,290 --> 00:04:06,060
one of my favorite ones because I we see

00:04:04,380 --> 00:04:07,319
a lot of code where we pass function

00:04:06,060 --> 00:04:08,819
objects around because they're

00:04:07,319 --> 00:04:11,459
lightweight and we can just pass them

00:04:08,819 --> 00:04:12,870
and copy them into interfaces I've come

00:04:11,459 --> 00:04:14,670
to the conclusion that for me personally

00:04:12,870 --> 00:04:16,560
if I'm passing an object that is

00:04:14,670 --> 00:04:18,870
supposed to act like a callable I will

00:04:16,560 --> 00:04:21,120
always pass it by a a forwarding

00:04:18,870 --> 00:04:23,220
reference and always call forward and

00:04:21,120 --> 00:04:26,460
the exact reason is because this bug bit

00:04:23,220 --> 00:04:28,800
me we're how many times do you ever RFI

00:04:26,460 --> 00:04:30,570
you qualify operators hardly ever but

00:04:28,800 --> 00:04:33,520
the one time you do you will get bitten

00:04:30,570 --> 00:04:36,250
by it and this actually makes sure

00:04:33,520 --> 00:04:37,629
that not only are you not copying what

00:04:36,250 --> 00:04:39,250
you've passed in and paying a

00:04:37,629 --> 00:04:40,629
performance of copy but you're also

00:04:39,250 --> 00:04:42,819
going to make sure you call the right

00:04:40,629 --> 00:04:47,560
call operator if somebody happens to

00:04:42,819 --> 00:04:48,039
decorate it but there's more but I am

00:04:47,560 --> 00:04:50,650
out of time

00:04:48,039 --> 00:04:54,430
and I've just sucked away a year of your

00:04:50,650 --> 00:04:56,770
life because there are more lies and

00:04:54,430 --> 00:04:59,409
Safina friendliness is not just always a

00:04:56,770 --> 00:05:00,759
suggestion because your classes are

00:04:59,409 --> 00:05:02,050
going to be used from the standard

00:05:00,759 --> 00:05:03,849
library or if you're using third-party

00:05:02,050 --> 00:05:05,740
libraries and you don't want to lie to

00:05:03,849 --> 00:05:07,349
them about your classes you want to make

00:05:05,740 --> 00:05:10,060
sure you're telling the truth and

00:05:07,349 --> 00:05:11,919
concepts should ease the pain of telling

00:05:10,060 --> 00:05:15,780
the truth but it will always be easier

00:05:11,919 --> 00:05:21,390
to lie than tell the truth in C++

00:05:15,780 --> 00:05:21,390

YouTube URL: https://www.youtube.com/watch?v=R0VasaMFi_E


