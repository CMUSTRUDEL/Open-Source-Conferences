Title: Detecting Programs That Rely on Undefined Behavior - Geoffrey L. Viola - CppCon 2019
Publication date: 2019-10-23
Playlist: CppCon 2019 Lightning Talks
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,929 --> 00:00:15,350
yeah so we get into detecting programs

00:00:13,980 --> 00:00:18,260
that rely on

00:00:15,350 --> 00:00:23,510
undefined behavior so I start off with

00:00:18,260 --> 00:00:25,550
ya start with this beam so undefined

00:00:23,510 --> 00:00:27,890
behavior isn't bad there's a lot of

00:00:25,550 --> 00:00:30,800
reasons why it exists in standard but

00:00:27,890 --> 00:00:32,330
there's an issue in that it has no

00:00:30,800 --> 00:00:35,780
restrictions on the programs that are

00:00:32,330 --> 00:00:39,140
made but programs that start to rely on

00:00:35,780 --> 00:00:43,570
undefined behavior I'm gonna say our bed

00:00:39,140 --> 00:00:46,220
and it's a certain class of bug and

00:00:43,570 --> 00:00:48,489
there's a reason undefined behavior is

00:00:46,220 --> 00:00:51,230
there and some of these things are

00:00:48,489 --> 00:00:54,080
undecidable and you cannot prove Leda

00:00:51,230 --> 00:00:56,150
TechEd them in all instances so I'm just

00:00:54,080 --> 00:00:58,280
gonna get into the true positive cases

00:00:56,150 --> 00:01:01,879
I'm just gonna talk about a couple of

00:00:58,280 --> 00:01:03,140
tools all freely available I didn't work

00:01:01,879 --> 00:01:06,590
on them at all

00:01:03,140 --> 00:01:10,040
some of them open source and it's just

00:01:06,590 --> 00:01:14,710
about understanding tools more so here's

00:01:10,040 --> 00:01:17,510
a first example just two lines of code

00:01:14,710 --> 00:01:21,409
we got a center array it's a nice and

00:01:17,510 --> 00:01:23,090
modern arbitrary type nonzero size but

00:01:21,409 --> 00:01:25,240
we were using C out and we're

00:01:23,090 --> 00:01:27,229
dereferencing outside of the boundaries

00:01:25,240 --> 00:01:31,579
surprisingly enough

00:01:27,229 --> 00:01:33,409
there's no warnings on this this exact

00:01:31,579 --> 00:01:37,280
kind of program is not a complete

00:01:33,409 --> 00:01:39,350
program but it snippet and it is relying

00:01:37,280 --> 00:01:42,229
on it in the sense that it is observable

00:01:39,350 --> 00:01:45,859
in the fact that this the output of

00:01:42,229 --> 00:01:47,600
something that would need to be computed

00:01:45,859 --> 00:01:53,179
would then make it to the i/o of the sea

00:01:47,600 --> 00:01:53,960
out so if we follow the coding guy for

00:01:53,179 --> 00:01:56,509
guidelines

00:01:53,960 --> 00:01:59,450
we're gonna end up having to fill this

00:01:56,509 --> 00:02:02,869
array and if you do follow that you will

00:01:59,450 --> 00:02:06,740
get a warning in release mode but I

00:02:02,869 --> 00:02:08,210
think for some people the the static

00:02:06,740 --> 00:02:10,700
analysis may not be enough and there's a

00:02:08,210 --> 00:02:14,000
lot of cases where it'll have a boundary

00:02:10,700 --> 00:02:17,420
and it just won't report an error so

00:02:14,000 --> 00:02:19,940
here's some tools that do detect it at

00:02:17,420 --> 00:02:23,230
least this kind of toy problem so

00:02:19,940 --> 00:02:26,540
clinked ID gives a nice error message

00:02:23,230 --> 00:02:28,610
and that's like a good tool in general

00:02:26,540 --> 00:02:29,180
but then we get into some of the dynamic

00:02:28,610 --> 00:02:31,519
analysis

00:02:29,180 --> 00:02:34,700
so we run this if you run in a debug

00:02:31,519 --> 00:02:37,909
mode a SAN will catch this and if you

00:02:34,700 --> 00:02:39,110
run it in release mode UV sand will

00:02:37,909 --> 00:02:42,980
catch it and if you put them both

00:02:39,110 --> 00:02:44,000
together both cases will be cut and then

00:02:42,980 --> 00:02:46,989
individual Street you just have to check

00:02:44,000 --> 00:02:50,239
in this in there sto which is nice so

00:02:46,989 --> 00:02:54,379
I'll give you another case so a bit of a

00:02:50,239 --> 00:02:58,129
toy problem here's some code I found at

00:02:54,379 --> 00:03:02,079
work so this is a little bit more

00:02:58,129 --> 00:03:04,760
complicated just a bit so the destruct

00:03:02,079 --> 00:03:09,049
we go from a string we put the string

00:03:04,760 --> 00:03:11,750
into this TM destruct it's a nice Lennox

00:03:09,049 --> 00:03:14,720
call so the proper way to initialize is

00:03:11,750 --> 00:03:16,659
the commented out bits they would call

00:03:14,720 --> 00:03:19,489
it make time which is a nice C call and

00:03:16,659 --> 00:03:22,129
just get an arithmetic type and then we

00:03:19,489 --> 00:03:25,730
we convert that type ID again we just do

00:03:22,129 --> 00:03:27,519
a C out so this is pretty tricky if you

00:03:25,730 --> 00:03:31,010
read the documentation documentation

00:03:27,519 --> 00:03:32,659
which no one does you know what to do

00:03:31,010 --> 00:03:34,310
and I think it's this kind of problem

00:03:32,659 --> 00:03:35,919
it's listed it's actually it's in stack

00:03:34,310 --> 00:03:39,260
overflow as well

00:03:35,919 --> 00:03:43,250
but people still make this mistake as to

00:03:39,260 --> 00:03:45,290
after a syrupy time the object isn't

00:03:43,250 --> 00:03:48,859
fully initialized so what ends up

00:03:45,290 --> 00:03:51,349
happening is that you call make time

00:03:48,859 --> 00:03:54,650
make time reads it it's across a link

00:03:51,349 --> 00:03:58,790
boundary and very few tools end up

00:03:54,650 --> 00:04:00,919
catching it but there are a few so

00:03:58,790 --> 00:04:03,409
clanked ID will help you here

00:04:00,919 --> 00:04:04,729
the nice thing are it's a little bit of

00:04:03,409 --> 00:04:06,739
a gray area so it doesn't really give

00:04:04,729 --> 00:04:11,389
you the right warning it just tells you

00:04:06,739 --> 00:04:12,409
to follow the core guidelines which is

00:04:11,389 --> 00:04:15,349
it which is definitely the right thing

00:04:12,409 --> 00:04:18,289
to do so you Nishal eyes Tim time you

00:04:15,349 --> 00:04:21,380
won't get UV but you do have the problem

00:04:18,289 --> 00:04:23,090
then you're going to be wrong half the

00:04:21,380 --> 00:04:25,250
time because you're supposed to say

00:04:23,090 --> 00:04:27,229
daylight savings time this is one of

00:04:25,250 --> 00:04:29,180
those interesting cases where you don't

00:04:27,229 --> 00:04:31,909
follow this the guidelines that you

00:04:29,180 --> 00:04:33,830
might get more information because then

00:04:31,909 --> 00:04:36,199
you start learning that well why is make

00:04:33,830 --> 00:04:39,200
time reading the data it's because of

00:04:36,199 --> 00:04:41,240
this DST thing and then it turns out

00:04:39,200 --> 00:04:42,830
valgrind is pretty good at detecting

00:04:41,240 --> 00:04:44,419
uninitialized memory

00:04:42,830 --> 00:04:48,289
so I'll just leave you with some

00:04:44,419 --> 00:04:51,289
conclusions you want to do as many

00:04:48,289 --> 00:04:53,960
checks warnings as well as your static

00:04:51,289 --> 00:04:56,180
analysis or dynamic analysis different

00:04:53,960 --> 00:04:59,419
optimization levels clanked ideas just

00:04:56,180 --> 00:05:01,009
great overall visual studios is good out

00:04:59,419 --> 00:05:03,229
of the bat but your you probably just

00:05:01,009 --> 00:05:05,030
need to learn how did all the flags

00:05:03,229 --> 00:05:07,729
involved and if you need any more

00:05:05,030 --> 00:05:09,030
information just go to this website it's

00:05:07,729 --> 00:05:12,090
all up there thank you

00:05:09,030 --> 00:05:12,090

YouTube URL: https://www.youtube.com/watch?v=EkZLN_D1BwU


