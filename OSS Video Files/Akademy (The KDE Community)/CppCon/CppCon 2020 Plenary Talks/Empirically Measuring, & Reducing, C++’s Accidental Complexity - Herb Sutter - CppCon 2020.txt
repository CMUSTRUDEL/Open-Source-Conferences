Title: Empirically Measuring, & Reducing, C++’s Accidental Complexity - Herb Sutter - CppCon 2020
Publication date: 2020-10-10
Playlist: CppCon 2020 Plenary Talks
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/empirically_measuring_and_reducing_cpp_accidental_complexity/empirically_measuring_and_reducing_cpp_accidental_complexity__herb_sutter__cppcon_2020.pdf
---
We often hear “C++ is more complex than it needs to be,” typically demonstrated using anecdotes and “gotcha” examples. Those can be valid and demonstrate real pain points, but it would be nice to have more quantifiable data that we could analyze to measure sources of complexity. This talk reports work to systematically catalog and measure C++’s unneeded complexity, how some current evolution proposals may address its major sources, and presents specific suggestions on what we might be able to do about it in the context of a future-evolution proposal to simplify parameter passing and provide meaningful initialization guarantees in C++.

---
Herb is the chair of the ISO C++ standards committee, a programming language architect at Microsoft, and the author of over 200 articles and 4 books about C++ and related topics.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,800 --> 00:00:14,799
welcome everyone to the final session of

00:00:11,200 --> 00:00:16,480
this all new all virtual cppcon 2020.

00:00:14,799 --> 00:00:18,160
i hope you've enjoyed the program as

00:00:16,480 --> 00:00:20,960
much as i have and we're now

00:00:18,160 --> 00:00:22,800
in our final set of talks so here's what

00:00:20,960 --> 00:00:24,960
to expect most of it's happening right

00:00:22,800 --> 00:00:26,240
here in this all of room or equivalently

00:00:24,960 --> 00:00:27,519
if you're in the overflow room you'll

00:00:26,240 --> 00:00:29,920
see the same thing

00:00:27,519 --> 00:00:31,359
for the next hour or so i'll be giving

00:00:29,920 --> 00:00:34,640
this talk

00:00:31,359 --> 00:00:36,880
and then right here stay right here for

00:00:34,640 --> 00:00:38,960
john cal who'll come in and he'll give

00:00:36,880 --> 00:00:40,480
us the conference wrap up including some

00:00:38,960 --> 00:00:41,600
interesting tidbits about next year and

00:00:40,480 --> 00:00:43,280
things you may not have known what you

00:00:41,600 --> 00:00:44,719
can do with this conference still and

00:00:43,280 --> 00:00:46,800
what to expect

00:00:44,719 --> 00:00:48,800
and then we're going to come back and

00:00:46,800 --> 00:00:51,920
use the rest of this half hour

00:00:48,800 --> 00:00:54,960
here for q a for my talk

00:00:51,920 --> 00:00:56,000
so this talk will have q a but and it'll

00:00:54,960 --> 00:00:58,320
be all in this room

00:00:56,000 --> 00:00:59,840
so stick around and after john we're

00:00:58,320 --> 00:01:02,879
going to go up to the hour

00:00:59,840 --> 00:01:04,159
to do q a after that

00:01:02,879 --> 00:01:05,840
you could either hang out here and

00:01:04,159 --> 00:01:08,159
listen to the final set from the jim

00:01:05,840 --> 00:01:10,080
bass night band the cppcon house band

00:01:08,159 --> 00:01:10,960
thanks again to them for playing for us

00:01:10,080 --> 00:01:14,400
this week

00:01:10,960 --> 00:01:15,920
from the seattle area or you can go to a

00:01:14,400 --> 00:01:17,840
zoom meeting if you're interested in

00:01:15,920 --> 00:01:20,080
planning or maybe interested in wanting

00:01:17,840 --> 00:01:20,880
to contribute to cppcon or just see the

00:01:20,080 --> 00:01:22,960
ideas

00:01:20,880 --> 00:01:25,200
that are going around or give feedback

00:01:22,960 --> 00:01:27,840
you can find the zoom meeting on sked

00:01:25,200 --> 00:01:28,320
that will be happening at 1 500 denver

00:01:27,840 --> 00:01:30,000
time

00:01:28,320 --> 00:01:32,000
so that's what's going to happen for the

00:01:30,000 --> 00:01:34,720
next hour let's talk about

00:01:32,000 --> 00:01:36,159
actually measuring stuff because every

00:01:34,720 --> 00:01:40,560
single one of us knows c

00:01:36,159 --> 00:01:43,680
plus plus is too complex that's a given

00:01:40,560 --> 00:01:46,240
but that's qualitative it's not

00:01:43,680 --> 00:01:47,119
quantitative and yes we can all give

00:01:46,240 --> 00:01:49,040
examples

00:01:47,119 --> 00:01:50,479
and experiences but that's also not

00:01:49,040 --> 00:01:53,439
quantitative i can't

00:01:50,479 --> 00:01:55,439
count those directly wouldn't it be nice

00:01:53,439 --> 00:01:56,880
if we could count it and also see how

00:01:55,439 --> 00:01:59,280
much is accidental

00:01:56,880 --> 00:02:00,719
that is non-essential complexity so

00:01:59,280 --> 00:02:04,159
let's define some terms and

00:02:00,719 --> 00:02:04,640
give some motivation complexity matters

00:02:04,159 --> 00:02:07,439
because

00:02:04,640 --> 00:02:08,800
as long as any system is more complex

00:02:07,439 --> 00:02:11,520
than we need it to be

00:02:08,800 --> 00:02:13,760
we are paying taxes using it and it may

00:02:11,520 --> 00:02:17,120
not seem like a huge tax on one day

00:02:13,760 --> 00:02:17,920
or on one week but as we keep paying it

00:02:17,120 --> 00:02:20,080
it's going to

00:02:17,920 --> 00:02:22,480
keep on costing us as we read and write

00:02:20,080 --> 00:02:25,120
code as we deal with bug reports

00:02:22,480 --> 00:02:26,239
and outages and even vulnerabilities and

00:02:25,120 --> 00:02:28,640
exploits

00:02:26,239 --> 00:02:30,560
as we wait for our tools as we have to

00:02:28,640 --> 00:02:33,120
teach people

00:02:30,560 --> 00:02:34,160
so we can benefit from reducing

00:02:33,120 --> 00:02:36,720
complexity in

00:02:34,160 --> 00:02:38,560
these and other ways so for the first

00:02:36,720 --> 00:02:40,800
part of this talk i'd like to give a

00:02:38,560 --> 00:02:42,560
shout out to barbara mcclintock

00:02:40,800 --> 00:02:44,080
she is a famous scientist a nobel

00:02:42,560 --> 00:02:46,879
laureate who

00:02:44,080 --> 00:02:48,879
was famous for actually looking to see

00:02:46,879 --> 00:02:50,879
what happens in dna

00:02:48,879 --> 00:02:52,000
and showed dna transposition and how

00:02:50,879 --> 00:02:54,720
that worked by

00:02:52,000 --> 00:02:56,239
empirically measuring so let's do what

00:02:54,720 --> 00:02:59,680
dr mcclintock did

00:02:56,239 --> 00:03:03,040
and empirically catalog classify

00:02:59,680 --> 00:03:06,879
and count c pluses complexity

00:03:03,040 --> 00:03:08,720
well how are we going to do that first

00:03:06,879 --> 00:03:10,720
let's remember what fred brooks

00:03:08,720 --> 00:03:14,080
distinguished as essential

00:03:10,720 --> 00:03:16,159
versus accidental complexity

00:03:14,080 --> 00:03:17,200
essential complexity is inherent in the

00:03:16,159 --> 00:03:19,040
problem domain

00:03:17,200 --> 00:03:21,040
so if you build a systems programming

00:03:19,040 --> 00:03:22,720
language say that values efficiency and

00:03:21,040 --> 00:03:25,760
it wants to give modern abstractions

00:03:22,720 --> 00:03:28,080
like the kind we're used to

00:03:25,760 --> 00:03:29,280
any language regardless of the syntax or

00:03:28,080 --> 00:03:31,440
the details

00:03:29,280 --> 00:03:34,000
is going to have to expose something

00:03:31,440 --> 00:03:36,560
like compel-time polymorphism

00:03:34,000 --> 00:03:38,239
something like virtual function dispatch

00:03:36,560 --> 00:03:40,000
so there are certain essential things or

00:03:38,239 --> 00:03:42,480
encapsulated types

00:03:40,000 --> 00:03:43,519
and the details can vary from one to the

00:03:42,480 --> 00:03:45,200
other

00:03:43,519 --> 00:03:46,799
but there's going to be some essential

00:03:45,200 --> 00:03:49,840
kind of abstraction

00:03:46,799 --> 00:03:51,360
in solving a given problem that no

00:03:49,840 --> 00:03:52,720
matter what the detailed solution is

00:03:51,360 --> 00:03:55,040
you're going to find it

00:03:52,720 --> 00:03:55,760
where we all trip up and every language

00:03:55,040 --> 00:03:58,239
does this

00:03:55,760 --> 00:04:00,480
is the accidental complexity it's where

00:03:58,239 --> 00:04:02,640
this particular solution

00:04:00,480 --> 00:04:04,319
boy it sure has more knobs or it falls

00:04:02,640 --> 00:04:06,400
over or the knobs come off at our hand

00:04:04,319 --> 00:04:07,040
sometimes we have to jam it back in more

00:04:06,400 --> 00:04:09,280
than

00:04:07,040 --> 00:04:10,400
we would like it to and more than it

00:04:09,280 --> 00:04:12,400
needs to

00:04:10,400 --> 00:04:14,080
and we'll call that fred calls that

00:04:12,400 --> 00:04:16,959
accidental complexity and it's an

00:04:14,080 --> 00:04:20,400
artifact of this specific solution

00:04:16,959 --> 00:04:23,280
and i'm giving you the picture of a

00:04:20,400 --> 00:04:23,919
push sign when you see a push sign on a

00:04:23,280 --> 00:04:26,800
door

00:04:23,919 --> 00:04:30,160
when you see a sign on almost anything

00:04:26,800 --> 00:04:31,840
that tells you how to use it

00:04:30,160 --> 00:04:33,280
almost certainly there is accidental

00:04:31,840 --> 00:04:35,600
complexity and there's a ux

00:04:33,280 --> 00:04:36,560
problem as well but there's something

00:04:35,600 --> 00:04:39,040
that doesn't work

00:04:36,560 --> 00:04:40,400
like is is easy to learn like you would

00:04:39,040 --> 00:04:42,400
expect it to

00:04:40,400 --> 00:04:44,639
and often is more complex and then

00:04:42,400 --> 00:04:47,199
accidental complexity enters the picture

00:04:44,639 --> 00:04:49,120
now the reason i mention signs is

00:04:47,199 --> 00:04:50,960
because signs often tell us where the

00:04:49,120 --> 00:04:54,240
accidental complexity is

00:04:50,960 --> 00:04:57,759
so if we could count the signs

00:04:54,240 --> 00:04:59,440
for c plus plus maybe we could count

00:04:57,759 --> 00:05:00,880
the accidental complexity in an

00:04:59,440 --> 00:05:03,680
empirical

00:05:00,880 --> 00:05:03,680
measurable way

00:05:04,080 --> 00:05:07,919
so i have bad news and really good news

00:05:06,320 --> 00:05:11,440
and they're the same thing

00:05:07,919 --> 00:05:12,320
c plus plus has probably the largest the

00:05:11,440 --> 00:05:14,479
richest

00:05:12,320 --> 00:05:15,600
body of coding standards and guidance on

00:05:14,479 --> 00:05:17,280
how to use

00:05:15,600 --> 00:05:18,479
of any programming language i haven't

00:05:17,280 --> 00:05:19,840
actually counted compared to other

00:05:18,479 --> 00:05:22,800
programming languages

00:05:19,840 --> 00:05:23,199
but it's popular and it's complicated

00:05:22,800 --> 00:05:25,840
and

00:05:23,199 --> 00:05:27,680
it shows in all the stuff that we've

00:05:25,840 --> 00:05:29,039
written down to teach and learn

00:05:27,680 --> 00:05:31,199
so i've actually gone through and

00:05:29,039 --> 00:05:32,960
counted so far in what's on the left

00:05:31,199 --> 00:05:34,320
hand side and i'll continue on the right

00:05:32,960 --> 00:05:37,680
hand side

00:05:34,320 --> 00:05:38,320
to actually for in each book and this

00:05:37,680 --> 00:05:40,080
has taken

00:05:38,320 --> 00:05:42,720
months and months of work spread over

00:05:40,080 --> 00:05:44,479
years to catalog what is each piece of

00:05:42,720 --> 00:05:45,199
advice so in scott meyer's items it's

00:05:44,479 --> 00:05:46,960
not just per

00:05:45,199 --> 00:05:48,800
item each item may have several

00:05:46,960 --> 00:05:52,240
guidelines to do this don't do that or

00:05:48,800 --> 00:05:55,280
do this a certain way

00:05:52,240 --> 00:05:56,880
and now by getting a list of rules

00:05:55,280 --> 00:05:59,440
we can now make a spreadsheet which i

00:05:56,880 --> 00:06:01,919
did thank you excel and start to

00:05:59,440 --> 00:06:04,000
quantify it and to classify it so the

00:06:01,919 --> 00:06:06,240
first thing i did was to classify

00:06:04,000 --> 00:06:08,639
this these catalogued rules the first

00:06:06,240 --> 00:06:10,560
granular level of classification was

00:06:08,639 --> 00:06:11,840
are they language or library rules most

00:06:10,560 --> 00:06:12,960
of them were about the language but

00:06:11,840 --> 00:06:14,400
there were some about the standard

00:06:12,960 --> 00:06:17,600
library we'll focus on

00:06:14,400 --> 00:06:19,039
the language rules here i also found a

00:06:17,600 --> 00:06:20,960
few that i'm going to discard

00:06:19,039 --> 00:06:23,600
because they're general rules like for

00:06:20,960 --> 00:06:25,919
instance use a version control system

00:06:23,600 --> 00:06:26,720
okay that's good advice but it's not

00:06:25,919 --> 00:06:29,280
specific to c

00:06:26,720 --> 00:06:31,199
plus plus or programming languages in

00:06:29,280 --> 00:06:33,440
any way not even programming you want to

00:06:31,199 --> 00:06:36,639
do that for word documents so

00:06:33,440 --> 00:06:36,960
i'm admitting those and 10 were even in

00:06:36,639 --> 00:06:40,479
my

00:06:36,960 --> 00:06:42,800
opinion you may differ just wrong rules

00:06:40,479 --> 00:06:44,720
and but even them i found informative

00:06:42,800 --> 00:06:45,520
because often they arose because the

00:06:44,720 --> 00:06:48,560
language

00:06:45,520 --> 00:06:50,240
created a pitfall or a confusion or an

00:06:48,560 --> 00:06:51,759
ambiguity

00:06:50,240 --> 00:06:53,599
that somebody resolved in a way that i

00:06:51,759 --> 00:06:56,400
happen to disagree with

00:06:53,599 --> 00:07:00,080
but it wasn't only their fault it was

00:06:56,400 --> 00:07:00,080
because there was a complexity

00:07:00,240 --> 00:07:04,880
so let's look at the language rules of

00:07:02,080 --> 00:07:05,919
the 533 individual language rules i

00:07:04,880 --> 00:07:07,759
classified

00:07:05,919 --> 00:07:09,599
i then went to see which ones are

00:07:07,759 --> 00:07:10,319
accidental versus essential and also

00:07:09,599 --> 00:07:12,240
which ones

00:07:10,319 --> 00:07:14,319
can we improve on because even essential

00:07:12,240 --> 00:07:17,840
ones we can improve on

00:07:14,319 --> 00:07:21,039
i found that over 360 were accidental

00:07:17,840 --> 00:07:24,240
complexity that another language like c

00:07:21,039 --> 00:07:25,840
plus that solves the same feature

00:07:24,240 --> 00:07:27,759
could do in a simpler way that didn't

00:07:25,840 --> 00:07:30,560
have this problem that c plus has that

00:07:27,759 --> 00:07:31,680
we have to teach and that we're

00:07:30,560 --> 00:07:33,360
improvable because

00:07:31,680 --> 00:07:36,080
look here's how it could be done in an

00:07:33,360 --> 00:07:39,280
existing or hypothetical other language

00:07:36,080 --> 00:07:42,479
there was a way to do better

00:07:39,280 --> 00:07:43,039
i found that almost 150 were essential

00:07:42,479 --> 00:07:44,800
that is

00:07:43,039 --> 00:07:46,479
you're going to have something like this

00:07:44,800 --> 00:07:47,840
in any language that solves this kind of

00:07:46,479 --> 00:07:49,360
problem

00:07:47,840 --> 00:07:51,840
but we can still do better it was

00:07:49,360 --> 00:07:53,360
needlessly complex the the knobs were

00:07:51,840 --> 00:07:54,400
too ornate or there were too many of

00:07:53,360 --> 00:07:57,199
them

00:07:54,400 --> 00:07:58,400
and finally i found 25 that were yes you

00:07:57,199 --> 00:08:00,479
would pretty much have to take

00:07:58,400 --> 00:08:02,240
this guideline out of this c plus plus

00:08:00,479 --> 00:08:04,080
book change c plus us to c

00:08:02,240 --> 00:08:06,479
sharp or something like that and you

00:08:04,080 --> 00:08:09,599
teach it almost verbatim

00:08:06,479 --> 00:08:12,319
with just minor changes like that

00:08:09,599 --> 00:08:14,400
and c pulses does in fact have such

00:08:12,319 --> 00:08:16,479
beautifully designed features

00:08:14,400 --> 00:08:18,720
at least those 25 rules fall in that

00:08:16,479 --> 00:08:20,800
category

00:08:18,720 --> 00:08:23,199
now the first thing i want to point out

00:08:20,800 --> 00:08:26,400
just from the shape of that

00:08:23,199 --> 00:08:28,400
pie chart and its proportions fred

00:08:26,400 --> 00:08:30,000
brooks also famously concluded there was

00:08:28,400 --> 00:08:33,279
no silver bullet there was no

00:08:30,000 --> 00:08:33,599
single thing we could do in technology

00:08:33,279 --> 00:08:35,919
or

00:08:33,599 --> 00:08:36,880
he also included management techniques

00:08:35,919 --> 00:08:38,800
that by itself

00:08:36,880 --> 00:08:41,360
could give you an order of magnitude a

00:08:38,800 --> 00:08:43,200
10x improvement

00:08:41,360 --> 00:08:45,120
so we often quote that but it's worth

00:08:43,200 --> 00:08:47,040
looking at why he said that that's the

00:08:45,120 --> 00:08:50,000
conclusion but he also states

00:08:47,040 --> 00:08:52,880
like a good scientist his premise and

00:08:50,000 --> 00:08:55,600
his premise right before that was

00:08:52,880 --> 00:08:56,080
how much of what software engineers do

00:08:55,600 --> 00:08:59,120
now

00:08:56,080 --> 00:09:01,839
is still devoted to the accidental as

00:08:59,120 --> 00:09:04,560
opposed to the essential

00:09:01,839 --> 00:09:06,839
unless that's ninety percent you can

00:09:04,560 --> 00:09:09,760
drive it to zero and you won't get a 10x

00:09:06,839 --> 00:09:11,360
improvement

00:09:09,760 --> 00:09:13,120
but if you remember the slide we just

00:09:11,360 --> 00:09:16,320
saw

00:09:13,120 --> 00:09:18,000
if you do have 90 improveable accidental

00:09:16,320 --> 00:09:20,560
or improvable complexity

00:09:18,000 --> 00:09:21,600
then you have a big problem but you also

00:09:20,560 --> 00:09:24,800
have a big

00:09:21,600 --> 00:09:27,920
opportunity and that is where we are

00:09:24,800 --> 00:09:29,279
we have such an opportunity where by

00:09:27,920 --> 00:09:32,399
evolving the language

00:09:29,279 --> 00:09:34,000
we could in principle address this much

00:09:32,399 --> 00:09:36,080
just because by cataloging we've

00:09:34,000 --> 00:09:40,080
measured this much is accidental

00:09:36,080 --> 00:09:40,080
or improvable essential

00:09:40,560 --> 00:09:45,360
bjarnus truestrip has famously said for

00:09:43,200 --> 00:09:46,160
some at least 16 years now since design

00:09:45,360 --> 00:09:48,560
and evolution of c

00:09:46,160 --> 00:09:49,440
plus plus that in fact this is could be

00:09:48,560 --> 00:09:52,480
possible

00:09:49,440 --> 00:09:54,560
an equivalently powerful language

00:09:52,480 --> 00:09:56,880
that is good at all the things c plus is

00:09:54,560 --> 00:10:00,720
good at

00:09:56,880 --> 00:10:02,880
but is simpler could be done about 10x

00:10:00,720 --> 00:10:04,720
smaller and notice what he says it would

00:10:02,880 --> 00:10:05,839
be through generalization which is

00:10:04,720 --> 00:10:08,320
absolutely true

00:10:05,839 --> 00:10:09,120
and i would expand on that a little bit

00:10:08,320 --> 00:10:11,279
by

00:10:09,120 --> 00:10:12,959
making general orthogonal features that

00:10:11,279 --> 00:10:14,640
compose well so you get

00:10:12,959 --> 00:10:16,399
maybe fewer simpler features but a

00:10:14,640 --> 00:10:17,839
combinatorial explosion of

00:10:16,399 --> 00:10:19,920
things you can express and that's where

00:10:17,839 --> 00:10:22,079
your expressive power is retained

00:10:19,920 --> 00:10:23,839
and it's also by making those orthogonal

00:10:22,079 --> 00:10:25,200
things directly express what you're

00:10:23,839 --> 00:10:27,279
trying to do

00:10:25,200 --> 00:10:30,079
usually instead of how to do it which is

00:10:27,279 --> 00:10:32,800
usually a messier recipe

00:10:30,079 --> 00:10:34,640
so let's pursue that thought and when i

00:10:32,800 --> 00:10:37,360
went through and i took a first cut

00:10:34,640 --> 00:10:40,079
classification into major categories

00:10:37,360 --> 00:10:41,600
of these different sources of complexity

00:10:40,079 --> 00:10:45,040
that we could improve

00:10:41,600 --> 00:10:47,519
by far the biggest one the category was

00:10:45,040 --> 00:10:48,079
multiple ways to say the same thing so c

00:10:47,519 --> 00:10:52,000
plus

00:10:48,079 --> 00:10:53,440
is famous for this kind of thing

00:10:52,000 --> 00:10:55,519
but then as we go through there are a

00:10:53,440 --> 00:10:58,000
few other large buckets

00:10:55,519 --> 00:10:58,800
that we can address the one at the

00:10:58,000 --> 00:11:00,480
bottom right

00:10:58,800 --> 00:11:01,839
kind of class authoring convention so

00:11:00,480 --> 00:11:03,680
that's the subject of a different talk

00:11:01,839 --> 00:11:05,680
i've already given at cppcon

00:11:03,680 --> 00:11:06,959
and the meta classes paper directly

00:11:05,680 --> 00:11:10,000
expressed in the intent for

00:11:06,959 --> 00:11:12,079
how we write a class but we're going to

00:11:10,000 --> 00:11:15,040
focus on different ones today

00:11:12,079 --> 00:11:16,720
so with that breakdown we commonly hear

00:11:15,040 --> 00:11:18,480
siphos is too complex

00:11:16,720 --> 00:11:20,480
and what i've tried to do is to

00:11:18,480 --> 00:11:22,560
empirically catalog

00:11:20,480 --> 00:11:24,959
classify and count so it's no longer

00:11:22,560 --> 00:11:27,600
anecdata or just anecdotes

00:11:24,959 --> 00:11:29,440
but we can actually say okay c plus is

00:11:27,600 --> 00:11:31,760
this much more complex and i think

00:11:29,440 --> 00:11:33,279
that we could empirically make the case

00:11:31,760 --> 00:11:36,800
that bjarna was correct

00:11:33,279 --> 00:11:39,040
and is correct when he says that c plus

00:11:36,800 --> 00:11:40,399
is about 10 times as complex as it needs

00:11:39,040 --> 00:11:41,760
to be

00:11:40,399 --> 00:11:44,079
for various reasons backwards

00:11:41,760 --> 00:11:46,000
compatibility and other things

00:11:44,079 --> 00:11:48,079
but that's a statement that bjorn has

00:11:46,000 --> 00:11:48,880
made qualitatively based on his deep

00:11:48,079 --> 00:11:50,720
experience

00:11:48,880 --> 00:11:52,639
and that i think is directly supported

00:11:50,720 --> 00:11:55,120
in the empirical cataloging

00:11:52,639 --> 00:11:56,160
that i've been doing so now we're going

00:11:55,120 --> 00:11:57,279
to switch to a different kind of

00:11:56,160 --> 00:11:59,760
scientist

00:11:57,279 --> 00:12:01,440
and the nice thing about mad scientists

00:11:59,760 --> 00:12:03,839
is they have crazy ideas

00:12:01,440 --> 00:12:04,480
and every so often at least in the

00:12:03,839 --> 00:12:06,720
movies

00:12:04,480 --> 00:12:08,959
they can build a flying time machine

00:12:06,720 --> 00:12:11,920
that looks like a delorean

00:12:08,959 --> 00:12:14,079
so we are in this mode where as c plus

00:12:11,920 --> 00:12:15,920
developers so often we say well

00:12:14,079 --> 00:12:17,519
yes but we can't really do anything

00:12:15,920 --> 00:12:18,480
about it we can only make incremental

00:12:17,519 --> 00:12:20,639
improvements

00:12:18,480 --> 00:12:22,399
so let me in the rest of this talk try

00:12:20,639 --> 00:12:24,720
to demonstrate

00:12:22,399 --> 00:12:25,920
a 23 and then when you add it to meta

00:12:24,720 --> 00:12:27,680
classes a 30

00:12:25,920 --> 00:12:29,440
reduction which actually gets us one

00:12:27,680 --> 00:12:32,480
third of the way roughly

00:12:29,440 --> 00:12:34,880
to a 10x improvement

00:12:32,480 --> 00:12:37,200
and what i'm about to show is

00:12:34,880 --> 00:12:40,720
experimental but we're also going to see

00:12:37,200 --> 00:12:40,720
prototypes in godbolt

00:12:41,519 --> 00:12:46,560
so when we look at this picture that we

00:12:43,760 --> 00:12:50,720
just discussed and we focus on these two

00:12:46,560 --> 00:12:52,959
wedges of the pie about 23 percent

00:12:50,720 --> 00:12:54,079
of all the guidance that i've cataloged

00:12:52,959 --> 00:12:55,839
so far have been

00:12:54,079 --> 00:12:58,000
about how to pass parameters sixteen

00:12:55,839 --> 00:12:59,519
percent and how to initialize variables

00:12:58,000 --> 00:13:01,600
seven percent

00:12:59,519 --> 00:13:03,680
now some of it's repetitive because it

00:13:01,600 --> 00:13:05,760
turns out that multiple books

00:13:03,680 --> 00:13:06,880
talk about how to pass parameters but

00:13:05,760 --> 00:13:09,120
that in itself

00:13:06,880 --> 00:13:10,399
is an indicator because we don't have to

00:13:09,120 --> 00:13:12,720
dedupe these rules

00:13:10,399 --> 00:13:13,760
the mere fact that other books continue

00:13:12,720 --> 00:13:16,399
to give the advice

00:13:13,760 --> 00:13:18,399
even though it's already in print and

00:13:16,399 --> 00:13:20,880
they often don't give the same advice

00:13:18,399 --> 00:13:22,160
but they give divergent or incompatible

00:13:20,880 --> 00:13:25,200
advice

00:13:22,160 --> 00:13:26,959
then we haven't we have a measure that

00:13:25,200 --> 00:13:29,680
this is something that the community

00:13:26,959 --> 00:13:31,120
has voted with its feet to say here is

00:13:29,680 --> 00:13:34,880
what is important to teach

00:13:31,120 --> 00:13:37,680
about c plus so let's talk about

00:13:34,880 --> 00:13:40,399
first how to pass parameters here is

00:13:37,680 --> 00:13:42,720
what we teach today

00:13:40,399 --> 00:13:44,160
i i it's it's too much to go into it i'm

00:13:42,720 --> 00:13:45,279
not going to spend a lot of time on it

00:13:44,160 --> 00:13:48,079
we'll see it sort of

00:13:45,279 --> 00:13:49,760
as we go with the today examples but i'm

00:13:48,079 --> 00:13:50,560
going to focus on the simpler thing that

00:13:49,760 --> 00:13:52,480
we can do

00:13:50,560 --> 00:13:54,320
in the future but this is roughly what

00:13:52,480 --> 00:13:56,399
we teach today and it is not

00:13:54,320 --> 00:13:57,680
complete if you want examples of where

00:13:56,399 --> 00:13:59,760
it's not complete

00:13:57,680 --> 00:14:01,680
i have a link to a github repo that i've

00:13:59,760 --> 00:14:02,240
just published that contains a draft

00:14:01,680 --> 00:14:05,279
paper

00:14:02,240 --> 00:14:07,680
about this material and

00:14:05,279 --> 00:14:09,440
compilable links to examples you can try

00:14:07,680 --> 00:14:11,920
on the working implementation

00:14:09,440 --> 00:14:15,120
but if the paper explains more about why

00:14:11,920 --> 00:14:15,120
even this is not complete

00:14:15,360 --> 00:14:19,440
that's because we are saying how to pass

00:14:17,600 --> 00:14:20,160
parameters i'll pass this one by value

00:14:19,440 --> 00:14:22,399
pass this one

00:14:20,160 --> 00:14:23,360
by reference so what kind of reference

00:14:22,399 --> 00:14:26,000
should we use

00:14:23,360 --> 00:14:27,519
we're we're specifying the recipe not

00:14:26,000 --> 00:14:30,399
the intent

00:14:27,519 --> 00:14:33,279
if we could enable expressing the intent

00:14:30,399 --> 00:14:37,920
what do i want to use this parameter for

00:14:33,279 --> 00:14:40,720
then i could teach i believe just this

00:14:37,920 --> 00:14:41,199
and if this were added to c plus then i

00:14:40,720 --> 00:14:43,120
believe

00:14:41,199 --> 00:14:44,959
that this is fully expressive and fully

00:14:43,120 --> 00:14:48,079
subsumes what we do today

00:14:44,959 --> 00:14:49,519
in the use cases i've seen so far and i

00:14:48,079 --> 00:14:50,160
would never have to teach anything more

00:14:49,519 --> 00:14:52,800
than this

00:14:50,160 --> 00:14:54,959
now there will be more code than this in

00:14:52,800 --> 00:14:56,880
the rest of the talk

00:14:54,959 --> 00:14:58,000
but most of what comes up in these next

00:14:56,880 --> 00:15:00,079
slides

00:14:58,000 --> 00:15:01,120
is about explaining the complicated

00:15:00,079 --> 00:15:02,639
thing we have today

00:15:01,120 --> 00:15:04,480
because that's what we all know and are

00:15:02,639 --> 00:15:07,440
used to and

00:15:04,480 --> 00:15:09,199
to help see how does that relate to this

00:15:07,440 --> 00:15:11,519
proposal

00:15:09,199 --> 00:15:13,120
the this proposal parts the code will

00:15:11,519 --> 00:15:14,959
always be simple

00:15:13,120 --> 00:15:17,120
the what we do today that's equivalent

00:15:14,959 --> 00:15:18,639
is more complex

00:15:17,120 --> 00:15:20,880
but i think i can teach parameter

00:15:18,639 --> 00:15:21,839
passing in this slide by what's shown

00:15:20,880 --> 00:15:24,480
here

00:15:21,839 --> 00:15:25,360
and get rid of roughly 23 of today's

00:15:24,480 --> 00:15:27,600
literature

00:15:25,360 --> 00:15:29,680
if only we could do that but let's dig

00:15:27,600 --> 00:15:32,320
in and see well yeah this is too simple

00:15:29,680 --> 00:15:32,720
and in just says give me an x i can read

00:15:32,320 --> 00:15:35,759
from

00:15:32,720 --> 00:15:37,839
in out and x i can read and write

00:15:35,759 --> 00:15:39,440
out is an object i will write to

00:15:37,839 --> 00:15:41,199
specifically i'll assign

00:15:39,440 --> 00:15:44,160
every that's how we say assignment is to

00:15:41,199 --> 00:15:45,920
set all the salient values of

00:15:44,160 --> 00:15:47,920
or one i'll move from or one that i'll

00:15:45,920 --> 00:15:50,480
forward to other code and that's it

00:15:47,920 --> 00:15:51,360
and one question i've received is ah is

00:15:50,480 --> 00:15:54,399
this exposing

00:15:51,360 --> 00:15:56,720
implementation detail

00:15:54,399 --> 00:15:58,560
no except what's necessary for the

00:15:56,720 --> 00:15:59,680
contract with the caller because this is

00:15:58,560 --> 00:16:03,440
information

00:15:59,680 --> 00:16:05,120
both the caller and the callee need

00:16:03,440 --> 00:16:06,480
to know for instance of the call site

00:16:05,120 --> 00:16:07,199
will there be a side effect on my

00:16:06,480 --> 00:16:09,040
argument

00:16:07,199 --> 00:16:10,720
oh i'm passing it to an in parameter

00:16:09,040 --> 00:16:11,440
it's going to only read there will be no

00:16:10,720 --> 00:16:15,680
side effect

00:16:11,440 --> 00:16:15,680
through that use of my argument

00:16:16,079 --> 00:16:21,120
i'm going to use some terms definite

00:16:19,279 --> 00:16:22,959
first use of definite last use

00:16:21,120 --> 00:16:24,880
through the rest of this talk here is

00:16:22,959 --> 00:16:26,639
explaining them in one slide

00:16:24,880 --> 00:16:28,959
let's say i have a local variable

00:16:26,639 --> 00:16:31,360
parameter includes a parameter

00:16:28,959 --> 00:16:32,480
and i want to say what's the first use

00:16:31,360 --> 00:16:34,639
of x on

00:16:32,480 --> 00:16:36,240
any execution path through this function

00:16:34,639 --> 00:16:38,160
what is definitely

00:16:36,240 --> 00:16:39,279
going to always be the first use of x

00:16:38,160 --> 00:16:40,959
and that's easy

00:16:39,279 --> 00:16:42,399
it's in the very first line you can't

00:16:40,959 --> 00:16:44,639
execute

00:16:42,399 --> 00:16:46,240
non-exceptionally through this function

00:16:44,639 --> 00:16:47,759
without going your path going through

00:16:46,240 --> 00:16:50,000
that line of code first

00:16:47,759 --> 00:16:53,199
and seeing that as its first use of x so

00:16:50,000 --> 00:16:55,600
that's a definite first use of x

00:16:53,199 --> 00:16:57,040
where's the definite last use of x well

00:16:55,600 --> 00:16:59,839
there are two

00:16:57,040 --> 00:17:01,440
and that's okay because any execution of

00:16:59,839 --> 00:17:04,160
this function will take one branch

00:17:01,440 --> 00:17:06,559
or the other and if it takes the first

00:17:04,160 --> 00:17:07,839
one then x dot hold is the last use of x

00:17:06,559 --> 00:17:09,760
that it will encounter

00:17:07,839 --> 00:17:10,959
in this function and if it takes the

00:17:09,760 --> 00:17:13,600
else then the c out

00:17:10,959 --> 00:17:14,959
x is the last use in that function

00:17:13,600 --> 00:17:17,039
definitely

00:17:14,959 --> 00:17:19,919
if you get to that line it's the last

00:17:17,039 --> 00:17:22,799
use of x there are no more

00:17:19,919 --> 00:17:24,640
what about y y doesn't have a definite

00:17:22,799 --> 00:17:26,559
first use because

00:17:24,640 --> 00:17:28,319
if you process y well you might do that

00:17:26,559 --> 00:17:30,320
on some paths and then it is at first

00:17:28,319 --> 00:17:33,120
use on that path but it's not definitely

00:17:30,320 --> 00:17:34,160
always going to be a first use it does

00:17:33,120 --> 00:17:38,080
have a definite

00:17:34,160 --> 00:17:40,320
last use and that is transfer

00:17:38,080 --> 00:17:40,320
y

00:17:41,360 --> 00:17:44,400
with that in hand let's start defining

00:17:43,600 --> 00:17:47,600
in in

00:17:44,400 --> 00:17:49,280
out out move and forward

00:17:47,600 --> 00:17:51,039
the five things i think you need to know

00:17:49,280 --> 00:17:53,440
to do all parameter passing in c

00:17:51,039 --> 00:17:54,320
plus plus the most complicated as it

00:17:53,440 --> 00:17:57,280
turns out

00:17:54,320 --> 00:17:57,760
and we'll demo at the end is in so what

00:17:57,280 --> 00:18:00,960
we teach

00:17:57,760 --> 00:18:04,480
today and what is automated here

00:18:00,960 --> 00:18:07,760
in this abstraction in the language

00:18:04,480 --> 00:18:10,160
is if the type is cheap to copy

00:18:07,760 --> 00:18:11,919
like an int then pass by copy that's

00:18:10,160 --> 00:18:15,440
what we already teach people today

00:18:11,919 --> 00:18:18,559
we just say in do that all the time

00:18:15,440 --> 00:18:20,400
otherwise pass it through an indirection

00:18:18,559 --> 00:18:21,919
as if by pointer or reference so that's

00:18:20,400 --> 00:18:23,039
the calling convention if you cracked

00:18:21,919 --> 00:18:25,280
open the assembly

00:18:23,039 --> 00:18:26,480
you would see a value or essentially a

00:18:25,280 --> 00:18:29,520
pointer an address

00:18:26,480 --> 00:18:32,880
on the stack what can i pass

00:18:29,520 --> 00:18:34,880
to the in parameter

00:18:32,880 --> 00:18:37,520
any initialized object can be an l value

00:18:34,880 --> 00:18:40,720
or an r value

00:18:37,520 --> 00:18:42,960
inside the kali i can

00:18:40,720 --> 00:18:44,080
treat it as a const l value because it

00:18:42,960 --> 00:18:45,600
could be

00:18:44,080 --> 00:18:47,280
it could be constant on cons the

00:18:45,600 --> 00:18:49,120
argument but in says i'm only going to

00:18:47,280 --> 00:18:49,919
read from it so i treat it as a constant

00:18:49,120 --> 00:18:53,200
value

00:18:49,919 --> 00:18:57,679
as const for my purposes that's implicit

00:18:53,200 --> 00:19:00,720
except that if you passed me an r value

00:18:57,679 --> 00:19:02,880
then any definite last use that tries to

00:19:00,720 --> 00:19:03,440
copy from it will treat it as an r value

00:19:02,880 --> 00:19:06,160
in other words

00:19:03,440 --> 00:19:06,160
can move from it

00:19:06,480 --> 00:19:10,240
let's see how that works so today we

00:19:09,440 --> 00:19:11,679
would pass in

00:19:10,240 --> 00:19:14,000
by value this is what we teach people

00:19:11,679 --> 00:19:16,799
today f1 takes an int

00:19:14,000 --> 00:19:17,840
an in end pass it by value oh it takes

00:19:16,799 --> 00:19:20,160
an in

00:19:17,840 --> 00:19:21,760
stood string or something else that's

00:19:20,160 --> 00:19:23,600
more complex oh well then take it by

00:19:21,760 --> 00:19:26,160
const reference and if you're going to

00:19:23,600 --> 00:19:28,880
take a copy

00:19:26,160 --> 00:19:30,559
and move is cheaper for that type you

00:19:28,880 --> 00:19:32,000
want to optimize for our values that

00:19:30,559 --> 00:19:34,080
also overload

00:19:32,000 --> 00:19:36,240
for our value reference and by the way

00:19:34,080 --> 00:19:38,480
remember to write stood move on that and

00:19:36,240 --> 00:19:42,480
remember to write student move only

00:19:38,480 --> 00:19:44,640
once on the definite last use

00:19:42,480 --> 00:19:46,799
of the parameter so that's what we teach

00:19:44,640 --> 00:19:48,720
people to write ad hoc today

00:19:46,799 --> 00:19:50,320
if you write a template it's harder i'll

00:19:48,720 --> 00:19:51,120
show you what you what you could do and

00:19:50,320 --> 00:19:52,960
what's a

00:19:51,120 --> 00:19:54,960
very a very small number of people like

00:19:52,960 --> 00:19:56,799
standard library implementers do

00:19:54,960 --> 00:19:59,200
to follow the advice oh ift is small

00:19:56,799 --> 00:20:01,919
passive by value et cetera

00:19:59,200 --> 00:20:02,640
mostly we just say hey template yeah

00:20:01,919 --> 00:20:05,679
cons

00:20:02,640 --> 00:20:07,200
construct sure let's do that there are a

00:20:05,679 --> 00:20:08,480
few who say by value and that's a

00:20:07,200 --> 00:20:10,559
discussion you'll see

00:20:08,480 --> 00:20:12,080
um senior address in my very first

00:20:10,559 --> 00:20:14,640
cppcon keynote

00:20:12,080 --> 00:20:16,000
2014 so you can find that on youtube but

00:20:14,640 --> 00:20:18,799
mostly they just say ah

00:20:16,000 --> 00:20:20,640
construct because it's hard to overload

00:20:18,799 --> 00:20:22,159
to pass by value you have to enable it

00:20:20,640 --> 00:20:24,559
for requires to do that

00:20:22,159 --> 00:20:26,640
and it's even harder to overload for r

00:20:24,559 --> 00:20:29,840
values but i'll show you how you can

00:20:26,640 --> 00:20:32,159
pretty much do it all of these

00:20:29,840 --> 00:20:34,480
equivalently

00:20:32,159 --> 00:20:36,000
in this proposal you would just write in

00:20:34,480 --> 00:20:37,600
in int

00:20:36,000 --> 00:20:39,280
is all you write and it automatically

00:20:37,600 --> 00:20:41,679
passes by value in

00:20:39,280 --> 00:20:42,880
x if x is not cheap to copy

00:20:41,679 --> 00:20:45,919
automatically

00:20:42,880 --> 00:20:49,120
passes by as if by constraint

00:20:45,919 --> 00:20:50,480
and if you give it an r value argument

00:20:49,120 --> 00:20:53,760
at a given call site

00:20:50,480 --> 00:20:55,360
we'll move when it calls g

00:20:53,760 --> 00:20:56,880
and the same thing is true of a template

00:20:55,360 --> 00:20:58,240
i don't have to worry about if it's a

00:20:56,880 --> 00:20:59,760
template i don't have to specialize i

00:20:58,240 --> 00:21:00,720
don't have to enable if it requires

00:20:59,760 --> 00:21:02,960
anything

00:21:00,720 --> 00:21:04,880
whatever the type is this is what in

00:21:02,960 --> 00:21:06,720
will do

00:21:04,880 --> 00:21:09,200
so it's efficient we're always going to

00:21:06,720 --> 00:21:09,919
copy values when that's cheap and we're

00:21:09,200 --> 00:21:11,919
going to move from

00:21:09,919 --> 00:21:14,640
our values and it's easy to write and

00:21:11,919 --> 00:21:14,640
get that effect

00:21:15,440 --> 00:21:19,520
so that was in now let's talk about in

00:21:17,520 --> 00:21:21,360
out this one's actually pretty simple

00:21:19,520 --> 00:21:22,720
for in-n-out we just pass basically the

00:21:21,360 --> 00:21:24,559
address of the object

00:21:22,720 --> 00:21:28,159
so that we can read from it and write to

00:21:24,559 --> 00:21:28,159
the original object in c2

00:21:28,240 --> 00:21:32,480
there we could actually and we're

00:21:29,760 --> 00:21:35,039
contemplating pass in and out by value

00:21:32,480 --> 00:21:36,799
as well for this as an optimization

00:21:35,039 --> 00:21:38,320
you'll see that mentioned in the paper

00:21:36,799 --> 00:21:40,720
that's a possible extension but right

00:21:38,320 --> 00:21:41,679
now the paper says that we pass by

00:21:40,720 --> 00:21:43,520
pointer

00:21:41,679 --> 00:21:44,799
you have to pass an initialized

00:21:43,520 --> 00:21:48,080
non-const

00:21:44,799 --> 00:21:50,960
object so that we can write to it and

00:21:48,080 --> 00:21:52,400
then we actually will treat it as that

00:21:50,960 --> 00:21:54,080
non-const object

00:21:52,400 --> 00:21:55,760
you just use it as you would normally

00:21:54,080 --> 00:21:57,840
but we can also give you a rule because

00:21:55,760 --> 00:21:58,480
you said i want an in-out parameter we

00:21:57,840 --> 00:22:00,880
can now

00:21:58,480 --> 00:22:03,520
tell you if there's no path in the

00:22:00,880 --> 00:22:05,360
function that ever writes to it

00:22:03,520 --> 00:22:07,200
that's not what you said you wanted and

00:22:05,360 --> 00:22:09,200
we can give a diagnostic

00:22:07,200 --> 00:22:10,880
so that because you've expressed your

00:22:09,200 --> 00:22:11,520
intent we can give you a higher quality

00:22:10,880 --> 00:22:13,360
of code

00:22:11,520 --> 00:22:15,200
where if it compiles it does what you

00:22:13,360 --> 00:22:16,320
said which is the holy grail of

00:22:15,200 --> 00:22:20,480
programming languages

00:22:16,320 --> 00:22:22,880
if it compiles it meets my expectations

00:22:20,480 --> 00:22:24,960
so today we write in out as basically x

00:22:22,880 --> 00:22:28,240
ref sometimes x star

00:22:24,960 --> 00:22:30,000
and in f1 we're fine we read the value

00:22:28,240 --> 00:22:32,159
that's fine we write the value that's

00:22:30,000 --> 00:22:33,600
fine but in f2 we forgot to write to x

00:22:32,159 --> 00:22:36,000
and today we don't get an error maybe

00:22:33,600 --> 00:22:37,919
your static analysis tool will give that

00:22:36,000 --> 00:22:39,280
and turns out you'll see on the next

00:22:37,919 --> 00:22:41,919
slide you spell

00:22:39,280 --> 00:22:43,840
it at the out parameter exactly the same

00:22:41,919 --> 00:22:47,120
way so we can't distinguish between in

00:22:43,840 --> 00:22:48,799
out and out unless you're using static

00:22:47,120 --> 00:22:50,960
analysis extensions that

00:22:48,799 --> 00:22:53,039
put annotations like in out and out and

00:22:50,960 --> 00:22:54,880
these exist and are used

00:22:53,039 --> 00:22:57,039
to disambiguate this that the language

00:22:54,880 --> 00:22:57,919
does not but in out this is what you

00:22:57,039 --> 00:22:59,919
would write

00:22:57,919 --> 00:23:01,280
and this is the simple case where the

00:22:59,919 --> 00:23:03,039
proposed equivalent is just

00:23:01,280 --> 00:23:04,880
a instead of that ampersand just write

00:23:03,039 --> 00:23:08,159
in out

00:23:04,880 --> 00:23:10,000
but it gives you more than just

00:23:08,159 --> 00:23:12,720
a nicer syntax if you don't like

00:23:10,000 --> 00:23:13,120
ampersands it also makes sure that you

00:23:12,720 --> 00:23:16,240
do

00:23:13,120 --> 00:23:18,000
assign to the value

00:23:16,240 --> 00:23:19,360
and it's simple and clear because now i

00:23:18,000 --> 00:23:21,919
can distinguish this from

00:23:19,360 --> 00:23:23,520
out so that's really all to say about in

00:23:21,919 --> 00:23:27,120
out as i can read and write from

00:23:23,520 --> 00:23:29,600
acts but what if it's only out

00:23:27,120 --> 00:23:30,559
pretty much the same except that i

00:23:29,600 --> 00:23:33,039
require that

00:23:30,559 --> 00:23:34,559
every path must have a definite first

00:23:33,039 --> 00:23:36,960
use

00:23:34,559 --> 00:23:37,760
that assigns a value to x and remember

00:23:36,960 --> 00:23:40,720
assignment and c

00:23:37,760 --> 00:23:43,440
plus plus is our typical way of saying

00:23:40,720 --> 00:23:45,279
right to all the salient parts of

00:23:43,440 --> 00:23:47,120
or passes it to another out param

00:23:45,279 --> 00:23:49,279
because this will compose and that will

00:23:47,120 --> 00:23:52,720
do the same thing

00:23:49,279 --> 00:23:53,760
so today we can we can't say out except

00:23:52,720 --> 00:23:56,640
as a comment

00:23:53,760 --> 00:23:57,120
if we in the first line g of x happen to

00:23:56,640 --> 00:23:59,440
read

00:23:57,120 --> 00:24:01,679
from the input value uh that kind of

00:23:59,440 --> 00:24:04,880
works even if the input value is garbage

00:24:01,679 --> 00:24:06,960
or sensitive data somebody's password

00:24:04,880 --> 00:24:08,720
we can do that even because we can't say

00:24:06,960 --> 00:24:10,799
out only directly

00:24:08,720 --> 00:24:12,480
and we can't flag that we've failed to

00:24:10,799 --> 00:24:14,320
actually do the out part either

00:24:12,480 --> 00:24:15,679
to write to something unless we have a

00:24:14,320 --> 00:24:17,760
tool that gives a warning

00:24:15,679 --> 00:24:19,600
because and that's non-portable because

00:24:17,760 --> 00:24:20,559
we have to have a non-standard out

00:24:19,600 --> 00:24:22,240
annotation

00:24:20,559 --> 00:24:24,080
and a tool that knows what we mean

00:24:22,240 --> 00:24:26,320
because in the language we can't express

00:24:24,080 --> 00:24:28,960
this

00:24:26,320 --> 00:24:30,480
the proposed equivalent is just to say

00:24:28,960 --> 00:24:32,320
out

00:24:30,480 --> 00:24:34,400
it would be a compile time error

00:24:32,320 --> 00:24:36,320
therefore green green isn't

00:24:34,400 --> 00:24:37,520
is for errors when the errors are good

00:24:36,320 --> 00:24:39,039
and desired

00:24:37,520 --> 00:24:40,799
you would get an error if you try to

00:24:39,039 --> 00:24:44,000
read from

00:24:40,799 --> 00:24:45,279
x before writing to it you are required

00:24:44,000 --> 00:24:46,320
to write to it and then it's okay to

00:24:45,279 --> 00:24:48,400
read from it because you're reading a

00:24:46,320 --> 00:24:50,960
value you set you're not using

00:24:48,400 --> 00:24:53,200
the the in value which you said you

00:24:50,960 --> 00:24:57,039
weren't going to use

00:24:53,200 --> 00:24:57,039
simple and safe and clear

00:24:58,640 --> 00:25:04,159
move also passes by indirection

00:25:02,240 --> 00:25:06,640
actually in the implementation this one

00:25:04,159 --> 00:25:08,960
has already been optimized to also pass

00:25:06,640 --> 00:25:11,279
in say by value so if you say move int

00:25:08,960 --> 00:25:13,679
it will actually do it into by value

00:25:11,279 --> 00:25:15,279
under the covers

00:25:13,679 --> 00:25:17,200
and which is an optimization of what we

00:25:15,279 --> 00:25:20,320
do in c plus today

00:25:17,200 --> 00:25:22,159
for for move templates and what we're

00:25:20,320 --> 00:25:25,039
going to do is require that

00:25:22,159 --> 00:25:27,039
this r value we accept only our values

00:25:25,039 --> 00:25:30,559
and that we pass them to

00:25:27,039 --> 00:25:32,320
another move or our value use

00:25:30,559 --> 00:25:33,760
so today the way we write this in a

00:25:32,320 --> 00:25:37,760
non-template

00:25:33,760 --> 00:25:40,159
is to say oh we use a

00:25:37,760 --> 00:25:41,600
r value reference which is spell double

00:25:40,159 --> 00:25:43,919
ampersand

00:25:41,600 --> 00:25:46,000
when the type is not a template

00:25:43,919 --> 00:25:47,760
parameter type it's a concrete type

00:25:46,000 --> 00:25:49,919
then it's an r value reference and then

00:25:47,760 --> 00:25:52,799
we remember to write sub move

00:25:49,919 --> 00:25:54,480
if you want to move a template parameter

00:25:52,799 --> 00:25:55,840
type well you can't just write t

00:25:54,480 --> 00:25:56,799
reference because that actually means

00:25:55,840 --> 00:26:00,559
something different than c

00:25:56,799 --> 00:26:00,559
plus plus sorry

00:26:00,960 --> 00:26:04,960
so what you do i won't go in the details

00:26:02,960 --> 00:26:07,360
of why but thank you nico yosudas for

00:26:04,960 --> 00:26:09,360
teaching me this incantation

00:26:07,360 --> 00:26:10,960
it turns out that the incantation stood

00:26:09,360 --> 00:26:13,039
is reference v

00:26:10,960 --> 00:26:14,320
happens to be the right thing for you

00:26:13,039 --> 00:26:17,360
here to say

00:26:14,320 --> 00:26:19,679
accept only our values

00:26:17,360 --> 00:26:20,400
just trust it and then instead of to

00:26:19,679 --> 00:26:21,760
move yeah

00:26:20,400 --> 00:26:23,279
you really should be saying stood

00:26:21,760 --> 00:26:24,480
forward and then you have to explain why

00:26:23,279 --> 00:26:25,919
you wrote that instead of

00:26:24,480 --> 00:26:28,240
move because you're really doing stood

00:26:25,919 --> 00:26:29,360
move but this is pretty close it's not

00:26:28,240 --> 00:26:32,799
exact

00:26:29,360 --> 00:26:33,679
an exact way to write a move templated

00:26:32,799 --> 00:26:35,520
parameter in c

00:26:33,679 --> 00:26:37,760
plus plus because you didn't actually

00:26:35,520 --> 00:26:39,679
write move but it's very close and i

00:26:37,760 --> 00:26:41,440
believe this is correct today but i

00:26:39,679 --> 00:26:42,799
don't want to teach that

00:26:41,440 --> 00:26:45,760
i just want to teach template

00:26:42,799 --> 00:26:48,320
non-template don't care

00:26:45,760 --> 00:26:48,960
big type small type int don't care just

00:26:48,320 --> 00:26:53,760
write

00:26:48,960 --> 00:26:56,960
move and they all work the same

00:26:53,760 --> 00:26:59,200
finally forward

00:26:56,960 --> 00:27:00,960
again take this one takes any object

00:26:59,200 --> 00:27:02,559
just like a perfect forwarder today but

00:27:00,960 --> 00:27:04,159
is much easier to use than a perfect

00:27:02,559 --> 00:27:05,600
forwarder

00:27:04,159 --> 00:27:07,200
we're allowed to look at the value if we

00:27:05,600 --> 00:27:07,520
want to read from it say because maybe

00:27:07,200 --> 00:27:09,039
if

00:27:07,520 --> 00:27:10,720
the forwarding function we're writing

00:27:09,039 --> 00:27:12,480
code that's that's in the middle between

00:27:10,720 --> 00:27:13,039
a caller and kali it just passes things

00:27:12,480 --> 00:27:15,440
along

00:27:13,039 --> 00:27:16,159
but it may want to look at it say to log

00:27:15,440 --> 00:27:17,840
the value

00:27:16,159 --> 00:27:19,200
that's what we commonly do in forwarding

00:27:17,840 --> 00:27:21,919
situations

00:27:19,200 --> 00:27:23,919
so we can read from it const uses but

00:27:21,919 --> 00:27:25,520
every definite last use

00:27:23,919 --> 00:27:27,360
is going to like today's perfect

00:27:25,520 --> 00:27:29,679
forwarding pattern preserve

00:27:27,360 --> 00:27:30,640
the const-ness and whether it's an lr

00:27:29,679 --> 00:27:34,000
value whether it's

00:27:30,640 --> 00:27:35,679
a temporary or not basically

00:27:34,000 --> 00:27:38,159
so today the way we write that is the

00:27:35,679 --> 00:27:39,840
forwarding pattern which looks like this

00:27:38,159 --> 00:27:41,440
for a templated type that's fine now if

00:27:39,840 --> 00:27:44,000
you want to do this for a non-templated

00:27:41,440 --> 00:27:45,279
type you still have to write a template

00:27:44,000 --> 00:27:47,200
because that's the way you write a

00:27:45,279 --> 00:27:49,520
forwarder in c plus plus

00:27:47,200 --> 00:27:50,399
and then you say through requires or

00:27:49,520 --> 00:27:52,640
enable if

00:27:50,399 --> 00:27:54,320
you say well it's got to be an x and

00:27:52,640 --> 00:27:56,240
there are different tradeoffs to say

00:27:54,320 --> 00:27:58,159
whether you say is convertible or

00:27:56,240 --> 00:28:00,159
is same and if you say the same you have

00:27:58,159 --> 00:28:03,039
to say remove cbref

00:28:00,159 --> 00:28:05,840
because you just do but this is how you

00:28:03,039 --> 00:28:07,840
would write it for a concrete type which

00:28:05,840 --> 00:28:09,120
as far as i can tell nobody does uh

00:28:07,840 --> 00:28:12,320
nobody uses this to

00:28:09,120 --> 00:28:13,120
forward concrete types it's difficult

00:28:12,320 --> 00:28:16,880
but it's

00:28:13,120 --> 00:28:17,760
just possible here in this proposal it's

00:28:16,880 --> 00:28:20,159
easy i just say

00:28:17,760 --> 00:28:21,919
forward the type it doesn't matter

00:28:20,159 --> 00:28:24,480
whether it's a template parameter type

00:28:21,919 --> 00:28:25,919
a concrete name type and i don't have to

00:28:24,480 --> 00:28:27,600
make it a template just to forward

00:28:25,919 --> 00:28:29,520
something if i'm forwarding a concrete

00:28:27,600 --> 00:28:31,120
type

00:28:29,520 --> 00:28:33,039
this is by the way really important

00:28:31,120 --> 00:28:35,120
because you'll have noticed that

00:28:33,039 --> 00:28:36,880
several times now with move especially

00:28:35,120 --> 00:28:38,720
and before but also within when we

00:28:36,880 --> 00:28:40,480
overload it with move

00:28:38,720 --> 00:28:42,080
i've said today we have to write a

00:28:40,480 --> 00:28:44,240
template sometimes or get out of a

00:28:42,080 --> 00:28:46,080
template sometimes

00:28:44,240 --> 00:28:47,360
instead of writing the code normally and

00:28:46,080 --> 00:28:50,880
bjornis truster has

00:28:47,360 --> 00:28:53,279
long made the the the important

00:28:50,880 --> 00:28:54,640
stake in the ground that he would like

00:28:53,279 --> 00:28:57,039
to see

00:28:54,640 --> 00:28:58,960
less divergence and a convergence in

00:28:57,039 --> 00:29:02,159
regular code and templated code

00:28:58,960 --> 00:29:03,919
and to remove the differences this helps

00:29:02,159 --> 00:29:05,679
directly to remove the differences

00:29:03,919 --> 00:29:07,840
between writing a template

00:29:05,679 --> 00:29:08,960
and writing a non-template code and

00:29:07,840 --> 00:29:12,399
makes them the same

00:29:08,960 --> 00:29:13,840
so i do agree with that that's important

00:29:12,399 --> 00:29:15,520
so now having looked at those let's look

00:29:13,840 --> 00:29:17,840
at some examples and you can find these

00:29:15,520 --> 00:29:19,760
at cppx.godbolt.org

00:29:17,840 --> 00:29:20,880
which is graciously made available by

00:29:19,760 --> 00:29:23,440
matt godbolt

00:29:20,880 --> 00:29:24,960
thank you very much matt and the person

00:29:23,440 --> 00:29:25,360
who's done the hard work of implementing

00:29:24,960 --> 00:29:26,880
this

00:29:25,360 --> 00:29:28,559
as well as several other of the

00:29:26,880 --> 00:29:30,080
proposals i've spoken about here at

00:29:28,559 --> 00:29:33,120
cppcon

00:29:30,080 --> 00:29:35,440
you can find thanks to andrew sutton

00:29:33,120 --> 00:29:37,520
and who has done the implementation of

00:29:35,440 --> 00:29:40,559
these parameters in particular

00:29:37,520 --> 00:29:43,600
so let's now switch to these

00:29:40,559 --> 00:29:45,360
examples and as we do that

00:29:43,600 --> 00:29:46,880
i wanted to show you a couple of helpers

00:29:45,360 --> 00:29:48,480
first so

00:29:46,880 --> 00:29:50,640
the first helper you're going to see me

00:29:48,480 --> 00:29:52,559
use sometimes in the body i'll want to

00:29:50,640 --> 00:29:54,480
say and let's say we copy from

00:29:52,559 --> 00:29:56,720
this parameter so i'll just call copy

00:29:54,480 --> 00:29:57,200
from here's a really simple way to write

00:29:56,720 --> 00:30:00,000
in c

00:29:57,200 --> 00:30:01,919
plus 20 write a function that just takes

00:30:00,000 --> 00:30:03,440
any number of parameters and just

00:30:01,919 --> 00:30:05,520
copy constructs attempts to copy

00:30:03,440 --> 00:30:06,880
construct each one and of course if it

00:30:05,520 --> 00:30:11,760
gets an r value it will

00:30:06,880 --> 00:30:14,880
move instead just take a variati

00:30:11,760 --> 00:30:17,039
generic set of variables by value that's

00:30:14,880 --> 00:30:18,799
all that does auto dot dot dot

00:30:17,039 --> 00:30:20,720
each variable each parameter can be a

00:30:18,799 --> 00:30:22,320
different type it's auto and it's passed

00:30:20,720 --> 00:30:24,960
by value

00:30:22,320 --> 00:30:24,960
kind of nice

00:30:25,679 --> 00:30:29,520
i want to see what's going on i want to

00:30:27,760 --> 00:30:32,240
see where the copy constructors and

00:30:29,520 --> 00:30:33,919
the move assignments are in particular

00:30:32,240 --> 00:30:37,120
so what i've just put together

00:30:33,919 --> 00:30:39,600
as just enough to get the testing done

00:30:37,120 --> 00:30:41,360
is i've got this global history string

00:30:39,600 --> 00:30:42,080
just for the purposes of the sandbox

00:30:41,360 --> 00:30:43,919
testing

00:30:42,080 --> 00:30:46,159
and i've got a function which will again

00:30:43,919 --> 00:30:48,480
it's using c plus 20 code

00:30:46,159 --> 00:30:50,159
it will take any functor any invokable

00:30:48,480 --> 00:30:53,200
thing by value and it will run it

00:30:50,159 --> 00:30:54,399
but first it will clear the history and

00:30:53,200 --> 00:30:56,960
then it will

00:30:54,399 --> 00:30:57,440
this thing will as a side effect write

00:30:56,960 --> 00:31:00,000
things

00:30:57,440 --> 00:31:01,440
into the history and then we'll return

00:31:00,000 --> 00:31:03,440
for convenience the history that was

00:31:01,440 --> 00:31:05,600
generated from running

00:31:03,440 --> 00:31:07,600
that f if you haven't seen this syntax

00:31:05,600 --> 00:31:09,519
before history equals brace brace

00:31:07,600 --> 00:31:10,720
that's the a modern way to say default

00:31:09,519 --> 00:31:13,600
initialization

00:31:10,720 --> 00:31:16,080
because well that's how it works so i

00:31:13,600 --> 00:31:17,840
find that very useful

00:31:16,080 --> 00:31:19,360
so that just clears out the string runs

00:31:17,840 --> 00:31:20,720
it and returns the history that was

00:31:19,360 --> 00:31:24,080
generated by that

00:31:20,720 --> 00:31:25,679
execution and now in order to see the

00:31:24,080 --> 00:31:28,720
copying and so forth

00:31:25,679 --> 00:31:31,279
i've got this noisy helper which

00:31:28,720 --> 00:31:32,000
just basically writes out to the history

00:31:31,279 --> 00:31:33,440
string

00:31:32,000 --> 00:31:36,080
when you call the default constructor

00:31:33,440 --> 00:31:37,679
destructor copy move copy move

00:31:36,080 --> 00:31:39,440
and otherwise just delegates to the

00:31:37,679 --> 00:31:40,960
thing you wrap so

00:31:39,440 --> 00:31:42,960
that way i've instrumented the special

00:31:40,960 --> 00:31:45,919
member functions so i can see

00:31:42,960 --> 00:31:47,039
what they're doing and i can then write

00:31:45,919 --> 00:31:48,640
test cases

00:31:47,039 --> 00:31:50,960
which you can find in the github repo

00:31:48,640 --> 00:31:52,399
you'll see the link out at the end

00:31:50,960 --> 00:31:54,799
so here's the first demo this is the

00:31:52,399 --> 00:31:57,360
really simple one we hope that there is

00:31:54,799 --> 00:31:58,159
nothing magical to see here all it's

00:31:57,360 --> 00:32:01,760
saying is

00:31:58,159 --> 00:32:03,840
today old we say pass an individual in

00:32:01,760 --> 00:32:05,519
oh you passed that by value and then

00:32:03,840 --> 00:32:06,000
when in this new proposed way you would

00:32:05,519 --> 00:32:09,279
say

00:32:06,000 --> 00:32:10,240
in int i we would hope the code gen is

00:32:09,279 --> 00:32:12,559
the same

00:32:10,240 --> 00:32:14,960
so let's take a look and here if we look

00:32:12,559 --> 00:32:17,760
in god bolt

00:32:14,960 --> 00:32:18,080
there's our copy from helper here is old

00:32:17,760 --> 00:32:19,679
in

00:32:18,080 --> 00:32:21,039
it takes an int by value just the way we

00:32:19,679 --> 00:32:22,000
teach people to write it today and

00:32:21,039 --> 00:32:26,080
you'll see here

00:32:22,000 --> 00:32:26,080
is the code gem push call pop

00:32:26,320 --> 00:32:29,360
new in which differs because it's using

00:32:28,320 --> 00:32:32,240
this new in

00:32:29,360 --> 00:32:34,799
implementation now it's an in in so it

00:32:32,240 --> 00:32:37,919
ought to pass it by value

00:32:34,799 --> 00:32:40,960
the code gen in this case is the same

00:32:37,919 --> 00:32:43,519
push call pop so

00:32:40,960 --> 00:32:44,080
that's a good thing that's the first

00:32:43,519 --> 00:32:46,559
demo

00:32:44,080 --> 00:32:47,519
so you've written in but now you might

00:32:46,559 --> 00:32:48,880
be saying ah look

00:32:47,519 --> 00:32:50,799
that's more verbose i had to write two

00:32:48,880 --> 00:32:53,440
more characters in a space

00:32:50,799 --> 00:32:54,240
true all the other examples will be

00:32:53,440 --> 00:32:57,679
increasingly

00:32:54,240 --> 00:33:00,320
in the other direction

00:32:57,679 --> 00:33:00,880
let's now instead of an int pass a

00:33:00,320 --> 00:33:02,960
string

00:33:00,880 --> 00:33:03,919
and in this case capital s string is

00:33:02,960 --> 00:33:08,080
just a

00:33:03,919 --> 00:33:10,159
noisy of stood string that's all it is

00:33:08,080 --> 00:33:12,080
so the current way i would write this is

00:33:10,159 --> 00:33:15,360
i would overload on construff

00:33:12,080 --> 00:33:17,120
and r value reference and in the first

00:33:15,360 --> 00:33:18,640
case i would copy from

00:33:17,120 --> 00:33:20,559
s and then the second one i would copy

00:33:18,640 --> 00:33:21,600
from stood move of x that's what we

00:33:20,559 --> 00:33:23,120
teach people

00:33:21,600 --> 00:33:24,880
and now we'll compare that to the new

00:33:23,120 --> 00:33:27,919
way of saying just in

00:33:24,880 --> 00:33:31,760
string s

00:33:27,919 --> 00:33:34,559
so let's take a look at that example

00:33:31,760 --> 00:33:36,159
so here we have old in which is the

00:33:34,559 --> 00:33:38,000
overload set

00:33:36,159 --> 00:33:40,240
i've got new in and the way i've been

00:33:38,000 --> 00:33:41,919
testing these is to say okay i've got

00:33:40,240 --> 00:33:43,600
here's where i call my run history

00:33:41,919 --> 00:33:44,559
function where i'm just going to run the

00:33:43,600 --> 00:33:46,159
history of

00:33:44,559 --> 00:33:48,240
two things the old thing and the new

00:33:46,159 --> 00:33:50,000
thing and then print their histories and

00:33:48,240 --> 00:33:52,000
compare them side by side

00:33:50,000 --> 00:33:53,440
and so what i'm going to do is for three

00:33:52,000 --> 00:33:55,519
different cases starting with a

00:33:53,440 --> 00:33:57,440
non-trivial l value so look there it is

00:33:55,519 --> 00:33:59,679
there's an l value x it's a named

00:33:57,440 --> 00:34:03,120
variable that's a an l value

00:33:59,679 --> 00:34:05,519
i'm going to do the same call old in

00:34:03,120 --> 00:34:07,279
in express the current way and new in

00:34:05,519 --> 00:34:10,159
the new way with the same argument

00:34:07,279 --> 00:34:11,119
x and see what they do then i'm going to

00:34:10,159 --> 00:34:14,320
do it with

00:34:11,119 --> 00:34:15,040
a stood move of x and then finally with

00:34:14,320 --> 00:34:18,399
a real

00:34:15,040 --> 00:34:21,839
fully pure r value a real temporary

00:34:18,399 --> 00:34:23,359
temporary string on the right hand side

00:34:21,839 --> 00:34:24,079
you'll see that for a non-trivial l

00:34:23,359 --> 00:34:26,800
value

00:34:24,079 --> 00:34:27,359
we in fact are doing what we expect

00:34:26,800 --> 00:34:30,480
we're writing

00:34:27,359 --> 00:34:32,240
the copy constructor in both doing the

00:34:30,480 --> 00:34:33,520
copy in both cases because we pass the

00:34:32,240 --> 00:34:35,440
string by value

00:34:33,520 --> 00:34:36,560
it's a name string so we're going to

00:34:35,440 --> 00:34:41,119
copy it

00:34:36,560 --> 00:34:43,200
into the the copy from function

00:34:41,119 --> 00:34:44,639
but for the other two you'll notice that

00:34:43,200 --> 00:34:46,399
we correctly

00:34:44,639 --> 00:34:48,720
do a move in both cases so what this

00:34:46,399 --> 00:34:51,280
means is that

00:34:48,720 --> 00:34:53,040
in both cases including in the in string

00:34:51,280 --> 00:34:55,919
case we see oh this is an r value

00:34:53,040 --> 00:34:58,160
argument both of these are our values

00:34:55,919 --> 00:34:59,040
that means at this definite last use

00:34:58,160 --> 00:35:00,480
we're going to cop

00:34:59,040 --> 00:35:02,320
we're going to move rather instead of

00:35:00,480 --> 00:35:03,359
copy but i didn't have to write an

00:35:02,320 --> 00:35:04,960
overload to say that

00:35:03,359 --> 00:35:07,280
i didn't have to write stood move

00:35:04,960 --> 00:35:08,960
anywhere i just wrote a function

00:35:07,280 --> 00:35:10,960
which now i can take the address of

00:35:08,960 --> 00:35:14,320
because it's on an overload set

00:35:10,960 --> 00:35:17,280
i just wrote a function that says oh

00:35:14,320 --> 00:35:19,280
i haven't want an in string where if i

00:35:17,280 --> 00:35:22,560
copy it and you pass me an r value

00:35:19,280 --> 00:35:23,599
i'll just naturally move from it

00:35:22,560 --> 00:35:25,200
because that's what we've already

00:35:23,599 --> 00:35:26,640
learned is the right thing to do is what

00:35:25,200 --> 00:35:28,079
we teach people to do

00:35:26,640 --> 00:35:30,160
and so on the right you can see that

00:35:28,079 --> 00:35:33,200
that's in fact what this implementation

00:35:30,160 --> 00:35:34,640
does so that's demo number two and

00:35:33,200 --> 00:35:36,320
you'll notice that i'm putting bolt

00:35:34,640 --> 00:35:38,000
links on each of these so you can see

00:35:36,320 --> 00:35:39,839
and try each of these yourself and try

00:35:38,000 --> 00:35:41,359
variations

00:35:39,839 --> 00:35:43,520
but now let's do something a little

00:35:41,359 --> 00:35:45,760
harder two

00:35:43,520 --> 00:35:47,680
in parameters well two parameters it

00:35:45,760 --> 00:35:49,760
doesn't seem very hard but

00:35:47,680 --> 00:35:51,359
if we follow the advice in this case we

00:35:49,760 --> 00:35:52,800
take two in strings

00:35:51,359 --> 00:35:55,680
and we do what we tell people to do

00:35:52,800 --> 00:35:58,720
today if you copy from it

00:35:55,680 --> 00:36:00,079
you consider overloading for r values

00:35:58,720 --> 00:36:01,280
well then what's going to end up

00:36:00,079 --> 00:36:02,800
happening is that you write this

00:36:01,280 --> 00:36:06,560
combinatorial in this case

00:36:02,800 --> 00:36:07,040
four set of overloads one for string

00:36:06,560 --> 00:36:10,079
const

00:36:07,040 --> 00:36:12,400
graph constraint once for r value

00:36:10,079 --> 00:36:14,960
constraint once for construct r value

00:36:12,400 --> 00:36:17,440
and once for our value r value

00:36:14,960 --> 00:36:18,079
instead i would like to be able to just

00:36:17,440 --> 00:36:20,960
write

00:36:18,079 --> 00:36:23,839
i want two in strings please please do

00:36:20,960 --> 00:36:27,119
the right thing sir

00:36:23,839 --> 00:36:29,119
so this example looks like this

00:36:27,119 --> 00:36:32,000
and again the goblet link is there so

00:36:29,119 --> 00:36:33,839
here's the overload set we write today

00:36:32,000 --> 00:36:35,440
here's what i would like to write

00:36:33,839 --> 00:36:36,800
instead

00:36:35,440 --> 00:36:38,720
and here's what andrew sutton's

00:36:36,800 --> 00:36:40,320
prototype compiler does

00:36:38,720 --> 00:36:41,920
again i'm doing the same compare

00:36:40,320 --> 00:36:44,960
function just to get the histories

00:36:41,920 --> 00:36:48,880
of two calls and i'm going to do

00:36:44,960 --> 00:36:52,160
two l values l value and r value

00:36:48,880 --> 00:36:55,839
our value and l value and our value and

00:36:52,160 --> 00:36:58,560
r value all the combinations

00:36:55,839 --> 00:36:58,960
and old in does exactly what we think it

00:36:58,560 --> 00:37:02,480
does

00:36:58,960 --> 00:37:05,760
copy copy copy move move copy

00:37:02,480 --> 00:37:08,800
move move the nice thing is when you

00:37:05,760 --> 00:37:10,480
look at these let me try to use a

00:37:08,800 --> 00:37:14,720
different

00:37:10,480 --> 00:37:14,720
there we go when you look at these

00:37:14,880 --> 00:37:22,320
so does new in

00:37:17,920 --> 00:37:25,280
but all i had to do was write

00:37:22,320 --> 00:37:26,960
in string in string and when i copy from

00:37:25,280 --> 00:37:29,040
them in the body

00:37:26,960 --> 00:37:30,000
it automatically does the copy copy for

00:37:29,040 --> 00:37:32,880
two l values

00:37:30,000 --> 00:37:35,520
copy move for l value r value move move

00:37:32,880 --> 00:37:38,880
for two r values

00:37:35,520 --> 00:37:40,560
at these definite last uses of s1 and s2

00:37:38,880 --> 00:37:42,079
now it's more than just that it's

00:37:40,560 --> 00:37:43,359
simpler to write this code

00:37:42,079 --> 00:37:45,200
the fact that i'm writing all these

00:37:43,359 --> 00:37:47,760
overloads actually generates

00:37:45,200 --> 00:37:49,599
bigger binaries bigger object code and

00:37:47,760 --> 00:37:50,720
you can look at yourself and on godbolt

00:37:49,599 --> 00:37:51,520
and i was going to scroll through and

00:37:50,720 --> 00:37:53,680
show it to you

00:37:51,520 --> 00:37:55,119
you can do that yourself instead i took

00:37:53,680 --> 00:37:57,599
a screenshot

00:37:55,119 --> 00:37:58,320
and here is the actual assembly

00:37:57,599 --> 00:38:01,520
generated

00:37:58,320 --> 00:38:04,960
on godbolt for this example the

00:38:01,520 --> 00:38:06,079
larger piece of code here if you zoom in

00:38:04,960 --> 00:38:07,599
you might be able to see it

00:38:06,079 --> 00:38:09,520
or it might be pixelated in the slides

00:38:07,599 --> 00:38:11,520
but you can see it yourself online

00:38:09,520 --> 00:38:13,920
is for these four overloads it's about

00:38:11,520 --> 00:38:16,960
250 lines

00:38:13,920 --> 00:38:20,560
and for this function which does

00:38:16,960 --> 00:38:22,079
the same thing it's 120.

00:38:20,560 --> 00:38:24,400
so this is kind of nice because you

00:38:22,079 --> 00:38:26,480
remember that we already said

00:38:24,400 --> 00:38:28,640
we get the same optimization move from

00:38:26,480 --> 00:38:30,160
our values in any combination

00:38:28,640 --> 00:38:31,760
so they're equal on performance at

00:38:30,160 --> 00:38:35,440
runtime

00:38:31,760 --> 00:38:36,160
they're new in wins on being easier to

00:38:35,440 --> 00:38:39,280
write

00:38:36,160 --> 00:38:39,920
for programmers so on simplicity and it

00:38:39,280 --> 00:38:42,640
wins

00:38:39,920 --> 00:38:44,480
on executable size on the object file

00:38:42,640 --> 00:38:47,599
size

00:38:44,480 --> 00:38:48,240
try more examples yourself and see for

00:38:47,599 --> 00:38:51,520
yourself

00:38:48,240 --> 00:38:53,440
how the object code varies

00:38:51,520 --> 00:38:54,800
but to me this is a win-win-win because

00:38:53,440 --> 00:38:57,119
it's just as fast

00:38:54,800 --> 00:38:58,880
way simpler to write and gives me

00:38:57,119 --> 00:39:01,920
smaller object files

00:38:58,880 --> 00:39:04,079
which usually we like

00:39:01,920 --> 00:39:05,200
now you might say how often do people do

00:39:04,079 --> 00:39:07,280
this in fact i

00:39:05,200 --> 00:39:08,480
wondered how often do people really for

00:39:07,280 --> 00:39:10,720
two in parameters

00:39:08,480 --> 00:39:13,520
do this construff ruff-ruff ref ref

00:39:10,720 --> 00:39:16,000
construct ref ref ruff-ruff construct

00:39:13,520 --> 00:39:17,599
overloading so i asked twitter a few

00:39:16,000 --> 00:39:19,839
days ago

00:39:17,599 --> 00:39:21,359
i asked have you ever and so this is

00:39:19,839 --> 00:39:22,480
going to overcount it's going to because

00:39:21,359 --> 00:39:24,320
it's going to count

00:39:22,480 --> 00:39:26,480
anybody who's ever done it once in their

00:39:24,320 --> 00:39:27,680
careers but i was curious because i was

00:39:26,480 --> 00:39:28,400
thinking the answer might be like one

00:39:27,680 --> 00:39:30,320
out of ten

00:39:28,400 --> 00:39:32,079
have ever written overloads like this to

00:39:30,320 --> 00:39:33,760
optimize for our value arguments i mean

00:39:32,079 --> 00:39:34,560
i know standard library implementers do

00:39:33,760 --> 00:39:37,680
this

00:39:34,560 --> 00:39:39,200
but for my twitter followers and the

00:39:37,680 --> 00:39:39,920
people they forwarded to have you ever

00:39:39,200 --> 00:39:42,640
done this

00:39:39,920 --> 00:39:43,920
asking for a friend and for this talk i

00:39:42,640 --> 00:39:46,800
was kind of surprised that

00:39:43,920 --> 00:39:47,599
25 that to me that was high of people

00:39:46,800 --> 00:39:50,720
who've done that

00:39:47,599 --> 00:39:51,760
but in the comments that were that

00:39:50,720 --> 00:39:53,839
followed i

00:39:51,760 --> 00:39:56,400
i found some interesting information as

00:39:53,839 --> 00:39:57,839
well so just a few highlights

00:39:56,400 --> 00:40:00,400
one of them was don't remind me i've

00:39:57,839 --> 00:40:01,839
done it with four arguments

00:40:00,400 --> 00:40:03,599
and we know what two to the fourth looks

00:40:01,839 --> 00:40:06,720
like

00:40:03,599 --> 00:40:08,480
and other someone else said

00:40:06,720 --> 00:40:10,079
assuming x isn't templated i that's

00:40:08,480 --> 00:40:12,560
right because you can't actually do it

00:40:10,079 --> 00:40:14,480
this simply if x isn't the template it's

00:40:12,560 --> 00:40:18,000
harder as we already saw

00:40:14,480 --> 00:40:19,760
this is the easy version today

00:40:18,000 --> 00:40:22,480
assuming x isn't templated yeah i've had

00:40:19,760 --> 00:40:23,440
to do that i used a macro so this is an

00:40:22,480 --> 00:40:28,319
example of what

00:40:23,440 --> 00:40:28,319
complexity forces people to do instead

00:40:29,200 --> 00:40:32,800
another example of what people do

00:40:30,640 --> 00:40:34,319
instead is they say i'm not going to do

00:40:32,800 --> 00:40:35,760
that at all i'm just going to bail and

00:40:34,319 --> 00:40:38,400
use perfect forwarding

00:40:35,760 --> 00:40:38,880
which means writing a template it's less

00:40:38,400 --> 00:40:41,440
clear

00:40:38,880 --> 00:40:43,680
because perfect forwarding is an expert

00:40:41,440 --> 00:40:45,119
level feature

00:40:43,680 --> 00:40:46,800
and it's changing the problem because

00:40:45,119 --> 00:40:49,040
perfect forwarding doesn't express

00:40:46,800 --> 00:40:50,800
in this isn't actually saying the same

00:40:49,040 --> 00:40:52,880
thing anymore

00:40:50,800 --> 00:40:55,040
but macros and perfect forwarding is

00:40:52,880 --> 00:40:56,960
what this drives people toward even for

00:40:55,040 --> 00:40:58,240
when it's just two parameters or it

00:40:56,960 --> 00:41:02,800
drives people to quit c

00:40:58,240 --> 00:41:06,000
plus plus maybe not this specific thing

00:41:02,800 --> 00:41:07,280
but this being the last straw on the

00:41:06,000 --> 00:41:11,119
camel's back

00:41:07,280 --> 00:41:14,480
before they just break away from c plus

00:41:11,119 --> 00:41:16,720
however i have to say my very

00:41:14,480 --> 00:41:17,599
favorite answer which really surprised

00:41:16,720 --> 00:41:22,640
me

00:41:17,599 --> 00:41:22,640
was this one thank you marcelo

00:41:24,240 --> 00:41:27,280
i'm not even going to try to show you

00:41:25,839 --> 00:41:30,079
what this looks like with

00:41:27,280 --> 00:41:30,560
three in parameters of concrete types

00:41:30,079 --> 00:41:33,040
just

00:41:30,560 --> 00:41:34,480
press ctrl c ctrl v a few times make

00:41:33,040 --> 00:41:35,760
sure your rights to move in all the

00:41:34,480 --> 00:41:37,200
right places i had

00:41:35,760 --> 00:41:39,359
even for the two parameters i had to

00:41:37,200 --> 00:41:40,720
triple check my code to make sure i was

00:41:39,359 --> 00:41:42,240
writing it correctly

00:41:40,720 --> 00:41:43,839
instead i would just like to tack on the

00:41:42,240 --> 00:41:46,839
third in string parameter

00:41:43,839 --> 00:41:49,839
thank you very much and not have to

00:41:46,839 --> 00:41:49,839
overload

00:41:50,079 --> 00:41:55,280
but now let's look at templates

00:41:53,280 --> 00:41:57,359
let's go back to a simpler version of

00:41:55,280 --> 00:41:59,440
the example with just one in parameter

00:41:57,359 --> 00:42:01,920
but of a templated type

00:41:59,440 --> 00:42:03,040
turns out you have to write this nest of

00:42:01,920 --> 00:42:06,319
things

00:42:03,040 --> 00:42:08,160
basically you're saying if i should pass

00:42:06,319 --> 00:42:10,079
by value so i should pass by value if

00:42:08,160 --> 00:42:11,119
it's trivially copyable and the size is

00:42:10,079 --> 00:42:12,640
less than something

00:42:11,119 --> 00:42:15,280
let's just say you can make your own

00:42:12,640 --> 00:42:16,800
predicate here

00:42:15,280 --> 00:42:19,119
if i should pass by value so i'm going

00:42:16,800 --> 00:42:21,520
to use where c plus 20 requires or if

00:42:19,119 --> 00:42:24,480
you don't have that use enable if

00:42:21,520 --> 00:42:25,680
to use this overloaded template which

00:42:24,480 --> 00:42:28,960
passes by value

00:42:25,680 --> 00:42:30,000
great otherwise if i shouldn't pass by

00:42:28,960 --> 00:42:33,040
value i'll pass by

00:42:30,000 --> 00:42:34,960
constraint great and here's the fun one

00:42:33,040 --> 00:42:36,319
remember overloading for r values and

00:42:34,960 --> 00:42:39,200
especially in templates you may want to

00:42:36,319 --> 00:42:41,440
do that because i'm going to copy

00:42:39,200 --> 00:42:42,880
and t could very easily be cheaper to

00:42:41,440 --> 00:42:45,599
move than to copy so i really

00:42:42,880 --> 00:42:47,119
am incentivized to always write this one

00:42:45,599 --> 00:42:49,680
for templates the copy and

00:42:47,119 --> 00:42:51,520
in parameter i then additionally write

00:42:49,680 --> 00:42:52,800
this incantation that niko yosudas

00:42:51,520 --> 00:42:54,480
taught me

00:42:52,800 --> 00:42:56,160
and it happens to be the right thing

00:42:54,480 --> 00:42:57,760
here to turn this into a move

00:42:56,160 --> 00:43:01,119
and i still write forward instead of

00:42:57,760 --> 00:43:03,040
move but we'll call this close enough

00:43:01,119 --> 00:43:04,400
instead i would like to just write in

00:43:03,040 --> 00:43:06,720
auto t now

00:43:04,400 --> 00:43:07,680
let me for a moment defend this because

00:43:06,720 --> 00:43:09,119
one of the first things you're going to

00:43:07,680 --> 00:43:10,480
say is hey shouldn't this be have at

00:43:09,119 --> 00:43:13,680
least one extra line

00:43:10,480 --> 00:43:14,800
template type name t in tt yeah that

00:43:13,680 --> 00:43:18,160
works too

00:43:14,800 --> 00:43:19,119
it's still way better but i can actually

00:43:18,160 --> 00:43:22,240
use

00:43:19,119 --> 00:43:23,119
auto here where i can't in today's

00:43:22,240 --> 00:43:26,240
guidance

00:43:23,119 --> 00:43:29,359
so today this

00:43:26,240 --> 00:43:32,720
auto this it was just c plus 20 for a an

00:43:29,359 --> 00:43:32,720
implicit template parameter

00:43:32,960 --> 00:43:36,560
i could write this here it turns out

00:43:36,000 --> 00:43:38,640
that

00:43:36,560 --> 00:43:40,319
in fact i didn't know how exactly how to

00:43:38,640 --> 00:43:42,560
write it so i asked the world's experts

00:43:40,319 --> 00:43:45,040
so thank you again to villa votilaiden

00:43:42,560 --> 00:43:46,400
and to andrew sutton for over the course

00:43:45,040 --> 00:43:48,960
of several emails

00:43:46,400 --> 00:43:49,599
teaching me and learning how to write

00:43:48,960 --> 00:43:51,920
this

00:43:49,599 --> 00:43:52,800
using auto instead of template type name

00:43:51,920 --> 00:43:55,839
t

00:43:52,800 --> 00:43:57,520
it you do not just change angle t to

00:43:55,839 --> 00:44:00,160
angle decal type of little t

00:43:57,520 --> 00:44:01,040
that that is not correct and it's still

00:44:00,160 --> 00:44:04,079
more verbose

00:44:01,040 --> 00:44:05,680
so i think it's a fair comparison to say

00:44:04,079 --> 00:44:07,599
no i'm going to show this today's

00:44:05,680 --> 00:44:09,119
guidance with template type name t

00:44:07,599 --> 00:44:10,560
and i'm going to show this one with the

00:44:09,119 --> 00:44:11,680
natural way you could write it in c plus

00:44:10,560 --> 00:44:14,000
study because

00:44:11,680 --> 00:44:15,359
now it is natural to write and it is

00:44:14,000 --> 00:44:18,640
feasible to write

00:44:15,359 --> 00:44:20,720
with this new proposed in qualifier

00:44:18,640 --> 00:44:22,800
but if you still aren't convinced fine

00:44:20,720 --> 00:44:24,640
i'll take the comparison with this

00:44:22,800 --> 00:44:26,160
any day of the week and it still wins

00:44:24,640 --> 00:44:28,000
hands down

00:44:26,160 --> 00:44:29,200
we're going to again compare current

00:44:28,000 --> 00:44:32,160
with proposed we're going to do a

00:44:29,200 --> 00:44:34,319
trivial l value a non-trivial l value

00:44:32,160 --> 00:44:36,000
non-trivial r values of two flavors to

00:44:34,319 --> 00:44:38,480
make sure we move from them

00:44:36,000 --> 00:44:40,400
and again we see no history

00:44:38,480 --> 00:44:42,000
instrumentation for the int because

00:44:40,400 --> 00:44:44,640
i can't instrument an ins and keep it

00:44:42,000 --> 00:44:47,040
trivial but if you look at the cogen

00:44:44,640 --> 00:44:48,160
as we saw already it's the same passing

00:44:47,040 --> 00:44:52,720
in by value

00:44:48,160 --> 00:44:52,720
otherwise i copy from

00:44:52,960 --> 00:44:59,920
the l value and i move from the two

00:44:56,480 --> 00:45:02,400
flavors of our value cases but all i had

00:44:59,920 --> 00:45:06,400
to write

00:45:02,400 --> 00:45:08,720
was this not

00:45:06,400 --> 00:45:08,720
this

00:45:11,359 --> 00:45:15,119
i'm not going to demo how to do a

00:45:13,359 --> 00:45:16,800
templated version with say three

00:45:15,119 --> 00:45:19,040
parameters

00:45:16,800 --> 00:45:20,640
you can go and ahead and try it we know

00:45:19,040 --> 00:45:22,079
how to do it but cut and paste is your

00:45:20,640 --> 00:45:24,160
friend and make sure that you

00:45:22,079 --> 00:45:25,280
tweak everything correctly and i don't

00:45:24,160 --> 00:45:26,640
think anybody will complain it's

00:45:25,280 --> 00:45:30,079
maintainable

00:45:26,640 --> 00:45:32,400
but if i wanted to do that

00:45:30,079 --> 00:45:34,720
for this new style i would just say in

00:45:32,400 --> 00:45:37,760
auto in auto in auto and

00:45:34,720 --> 00:45:38,880
it would work in fact let's do not three

00:45:37,760 --> 00:45:42,160
parameters

00:45:38,880 --> 00:45:45,119
but six just cuz

00:45:42,160 --> 00:45:46,560
this will be our last demo and i'm not

00:45:45,119 --> 00:45:48,880
going to show today's way of doing it

00:45:46,560 --> 00:45:51,920
i'm just going to show here is

00:45:48,880 --> 00:45:54,160
a template with six generic parameters

00:45:51,920 --> 00:45:56,560
and i want to pass trivial ones by value

00:45:54,160 --> 00:45:59,040
the cheap to copy ones by value

00:45:56,560 --> 00:45:59,839
otherwise by effectively const reference

00:45:59,040 --> 00:46:02,240
and also

00:45:59,839 --> 00:46:03,520
effectively overload for but it's not

00:46:02,240 --> 00:46:06,480
really an overload here

00:46:03,520 --> 00:46:08,000
to move from our values and i'm going to

00:46:06,480 --> 00:46:09,440
put a few line breaks in the history

00:46:08,000 --> 00:46:11,280
just to make it easier to read

00:46:09,440 --> 00:46:12,640
and i'm going to copy from each of these

00:46:11,280 --> 00:46:13,119
variables i'm just going to group them

00:46:12,640 --> 00:46:16,400
just

00:46:13,119 --> 00:46:17,280
for yucks and now i've got an int a

00:46:16,400 --> 00:46:19,119
string

00:46:17,280 --> 00:46:21,440
and various strings and now we're going

00:46:19,119 --> 00:46:23,280
to have this call site new in

00:46:21,440 --> 00:46:27,520
we're going to pass an into string move

00:46:23,280 --> 00:46:29,920
s2 s3 42 and then a string temporary

00:46:27,520 --> 00:46:31,599
so the first thing we're going to do is

00:46:29,920 --> 00:46:32,480
as we pass these all by in is we're

00:46:31,599 --> 00:46:36,400
going to copy from

00:46:32,480 --> 00:46:38,720
a and b so first we see the default

00:46:36,400 --> 00:46:40,480
constructor outside the call that's

00:46:38,720 --> 00:46:42,960
creating this string temporary at the

00:46:40,480 --> 00:46:43,839
call site then we get inside the

00:46:42,960 --> 00:46:47,760
function

00:46:43,839 --> 00:46:51,119
and first thing we do is we

00:46:47,760 --> 00:46:53,839
execute copy from a comma b a and b

00:46:51,119 --> 00:46:55,119
in this case are i and s and int so we

00:46:53,839 --> 00:46:56,800
should see nothing in the history for

00:46:55,119 --> 00:46:58,720
that because we pass that by value and

00:46:56,800 --> 00:47:02,079
it's not instrumented

00:46:58,720 --> 00:47:04,319
and we should see uh s is a an l value

00:47:02,079 --> 00:47:06,079
so we should copy from that

00:47:04,319 --> 00:47:07,839
so we should see a copy and sure enough

00:47:06,079 --> 00:47:09,599
we do we see the

00:47:07,839 --> 00:47:11,520
in the copy from call we see the copy

00:47:09,599 --> 00:47:14,560
constructor and then

00:47:11,520 --> 00:47:16,480
the destructor of that object and that's

00:47:14,560 --> 00:47:19,520
in as we copy from

00:47:16,480 --> 00:47:21,760
b all right the next thing we do is we

00:47:19,520 --> 00:47:25,280
copy from c now let's see here

00:47:21,760 --> 00:47:27,680
in this case c is an x value

00:47:25,280 --> 00:47:28,720
it's an r value that's a move from l

00:47:27,680 --> 00:47:31,920
value i'm going to say

00:47:28,720 --> 00:47:35,119
or a stood move of an l value

00:47:31,920 --> 00:47:38,800
so this should say what it should say

00:47:35,119 --> 00:47:40,559
move as we copy from that particular c

00:47:38,800 --> 00:47:41,839
we should move from that because that's

00:47:40,559 --> 00:47:43,680
what the caller said

00:47:41,839 --> 00:47:45,839
and in fact that's what we see happen we

00:47:43,680 --> 00:47:47,280
have the move constructor done for c

00:47:45,839 --> 00:47:49,119
finally we're going to copy from all the

00:47:47,280 --> 00:47:52,160
others in one shot d

00:47:49,119 --> 00:47:53,119
e and f are a string that there's an l

00:47:52,160 --> 00:47:56,480
value so we should

00:47:53,119 --> 00:47:57,599
copy that one and in 42 which we just

00:47:56,480 --> 00:47:58,880
passed by value and there's no

00:47:57,599 --> 00:48:01,760
instrumentation

00:47:58,880 --> 00:48:03,520
and then a pure r value a real temporary

00:48:01,760 --> 00:48:04,319
object of a type string which we should

00:48:03,520 --> 00:48:07,760
move

00:48:04,319 --> 00:48:12,160
so we should see copy nothing move

00:48:07,760 --> 00:48:15,599
and that's exactly what we see

00:48:12,160 --> 00:48:17,040
so there's an example of in parameters

00:48:15,599 --> 00:48:18,240
and you can also try out we're still in

00:48:17,040 --> 00:48:20,880
the process of building

00:48:18,240 --> 00:48:22,000
the other kinds in out out moving

00:48:20,880 --> 00:48:23,359
forward

00:48:22,000 --> 00:48:25,599
they're in various stages of

00:48:23,359 --> 00:48:26,720
construction but hopefully that gives

00:48:25,599 --> 00:48:28,319
you a sense of

00:48:26,720 --> 00:48:30,880
what this is like and you can try all

00:48:28,319 --> 00:48:33,280
these online

00:48:30,880 --> 00:48:34,160
so we saw that about 23 of the measured

00:48:33,280 --> 00:48:36,880
guidance was

00:48:34,160 --> 00:48:38,559
passing parameters but another seven

00:48:36,880 --> 00:48:39,760
percent was about initialization and

00:48:38,559 --> 00:48:43,040
this is actually

00:48:39,760 --> 00:48:45,760
i believe directly related because of

00:48:43,040 --> 00:48:49,119
out parameters because out parameters

00:48:45,760 --> 00:48:51,760
reach back to the caller and set a value

00:48:49,119 --> 00:48:53,040
now today what do we teach we generally

00:48:51,760 --> 00:48:54,720
just bail in in c

00:48:53,040 --> 00:48:56,240
plus including in the core guidelines

00:48:54,720 --> 00:48:57,839
and say initialize

00:48:56,240 --> 00:49:00,240
at the point you declare a variable and

00:48:57,839 --> 00:49:02,720
that's fine most of the time

00:49:00,240 --> 00:49:04,480
if you have a sensible value then if you

00:49:02,720 --> 00:49:06,880
don't yet have a sensible value you have

00:49:04,480 --> 00:49:08,880
to put in a dummy value

00:49:06,880 --> 00:49:10,319
and because that's expensive for big

00:49:08,880 --> 00:49:12,800
pods and arrays

00:49:10,319 --> 00:49:14,559
we always tell people oh you know that

00:49:12,800 --> 00:49:16,079
thing we said about always initialize at

00:49:14,559 --> 00:49:19,280
declaration yeah except you know

00:49:16,079 --> 00:49:22,640
you don't do that for arrays for pods

00:49:19,280 --> 00:49:24,400
for stud array for example because that

00:49:22,640 --> 00:49:26,000
will just generate

00:49:24,400 --> 00:49:27,520
dummy rights that it turns out

00:49:26,000 --> 00:49:28,720
optimizers have a hard time getting rid

00:49:27,520 --> 00:49:30,800
of

00:49:28,720 --> 00:49:33,200
when you later put in program meaningful

00:49:30,800 --> 00:49:33,200
values

00:49:34,880 --> 00:49:38,720
putting in dummy values in these cases

00:49:36,880 --> 00:49:40,960
we already teach not to do that

00:49:38,720 --> 00:49:42,079
because they're not useful because we're

00:49:40,960 --> 00:49:43,760
going to overwrite them before we

00:49:42,079 --> 00:49:45,119
hopefully read from them

00:49:43,760 --> 00:49:46,480
they're expensive because compilers

00:49:45,119 --> 00:49:47,119
can't get rid of them very easily

00:49:46,480 --> 00:49:49,119
despite

00:49:47,119 --> 00:49:50,240
many years of trying and they're

00:49:49,119 --> 00:49:52,000
error-prone because

00:49:50,240 --> 00:49:53,280
if you have undefined behavior tools

00:49:52,000 --> 00:49:54,079
that check that you initialize your

00:49:53,280 --> 00:49:56,720
variables

00:49:54,079 --> 00:49:58,319
it will mask the bug because you're

00:49:56,720 --> 00:49:59,760
actually not initializing

00:49:58,319 --> 00:50:01,760
your variable when you give it a dummy

00:49:59,760 --> 00:50:02,800
value at declaration

00:50:01,760 --> 00:50:05,680
you're not giving it a program

00:50:02,800 --> 00:50:07,920
meaningful value and now the tool can't

00:50:05,680 --> 00:50:09,040
tell that well that wasn't a real value

00:50:07,920 --> 00:50:11,520
that you shouldn't be trying to read

00:50:09,040 --> 00:50:11,520
back from

00:50:11,680 --> 00:50:16,319
instead the holy grail is a visualize

00:50:14,400 --> 00:50:17,839
before you use a variable and for a

00:50:16,319 --> 00:50:19,680
local that just means

00:50:17,839 --> 00:50:22,319
that if you declare it and it's not yet

00:50:19,680 --> 00:50:24,240
initialized like an int on the stack

00:50:22,319 --> 00:50:25,599
that you assign to it before you read

00:50:24,240 --> 00:50:28,480
from it that's all

00:50:25,599 --> 00:50:29,680
and ada c sharp they do this millions of

00:50:28,480 --> 00:50:31,680
programmers live with these

00:50:29,680 --> 00:50:32,880
rules and they works for them and it

00:50:31,680 --> 00:50:34,880
finds bugs

00:50:32,880 --> 00:50:37,040
today that we're not finding in c-plus

00:50:34,880 --> 00:50:39,839
boss

00:50:37,040 --> 00:50:41,359
now earlier on i i said today and we

00:50:39,839 --> 00:50:43,599
can't really distinguish

00:50:41,359 --> 00:50:44,960
between in out and out only parameters

00:50:43,599 --> 00:50:45,920
because there's no such thing as an out

00:50:44,960 --> 00:50:48,079
only parameter

00:50:45,920 --> 00:50:54,559
expressible in c plus plus and that's

00:50:48,079 --> 00:50:57,680
true with one little exception

00:50:54,559 --> 00:50:59,280
this object in the constructor is

00:50:57,680 --> 00:51:01,440
effectively an out because

00:50:59,280 --> 00:51:03,040
the constructor takes a raw buffer of

00:51:01,440 --> 00:51:09,839
memory and turns it into

00:51:03,040 --> 00:51:11,760
a constructed object that is out

00:51:09,839 --> 00:51:13,040
so let's revisit the definition of out

00:51:11,760 --> 00:51:13,920
and we're going to make one little tweak

00:51:13,040 --> 00:51:17,119
instead of just saying

00:51:13,920 --> 00:51:22,640
any non-const l value we'll say that

00:51:17,119 --> 00:51:24,400
or an uninitialized object

00:51:22,640 --> 00:51:25,839
when you remember on every definite

00:51:24,400 --> 00:51:30,880
first use you have to

00:51:25,839 --> 00:51:33,599
assign to it if x is not initialized

00:51:30,880 --> 00:51:36,079
which we are told by the call site then

00:51:33,599 --> 00:51:39,200
that becomes a constructor

00:51:36,079 --> 00:51:41,680
which basically means spoiler alert

00:51:39,200 --> 00:51:43,520
every function that has an out parameter

00:51:41,680 --> 00:51:45,760
is in effect a constructor a named

00:51:43,520 --> 00:51:51,440
constructor

00:51:45,760 --> 00:51:54,400
when you pass it an uninitialized object

00:51:51,440 --> 00:51:55,839
so today we teach stood array of byte

00:51:54,400 --> 00:51:57,520
which could be hugely big

00:51:55,839 --> 00:51:58,960
by the way and this is not initialized

00:51:57,520 --> 00:52:01,200
today that's what the standard says and

00:51:58,960 --> 00:52:03,040
you want it to be that way

00:52:01,200 --> 00:52:05,599
then you call it in the loop to get next

00:52:03,040 --> 00:52:07,280
chunk and that may or may not fill it we

00:52:05,599 --> 00:52:09,520
we hope it does and we test for that

00:52:07,280 --> 00:52:12,319
then we process the data

00:52:09,520 --> 00:52:13,760
but get next chunk today maybe just take

00:52:12,319 --> 00:52:16,240
an array by reference

00:52:13,760 --> 00:52:18,240
we don't enforce in the language not to

00:52:16,240 --> 00:52:18,720
read from x's contents before writing to

00:52:18,240 --> 00:52:21,839
them

00:52:18,720 --> 00:52:23,680
we don't enforce that we write to it

00:52:21,839 --> 00:52:26,240
now we do those things and we test for

00:52:23,680 --> 00:52:28,880
them but the language doesn't say

00:52:26,240 --> 00:52:31,040
hey if it compiles you did those things

00:52:28,880 --> 00:52:34,400
instead the proposed equivalent

00:52:31,040 --> 00:52:37,280
is that i'd be able to say out on

00:52:34,400 --> 00:52:39,200
a get next chunk style api which

00:52:37,280 --> 00:52:40,160
enforces i don't read from the value

00:52:39,200 --> 00:52:42,240
before

00:52:40,160 --> 00:52:43,680
which knows whether i'm passing in an

00:52:42,240 --> 00:52:46,960
initialized

00:52:43,680 --> 00:52:47,839
variable or not and if it's if i write

00:52:46,960 --> 00:52:49,760
to it

00:52:47,839 --> 00:52:51,359
i will construct it i'll show you a

00:52:49,760 --> 00:52:53,440
specific example in a moment

00:52:51,359 --> 00:52:54,400
because for a ray of bite it's just a

00:52:53,440 --> 00:52:56,880
pod

00:52:54,400 --> 00:52:59,359
so it's just a trivially copyable type

00:52:56,880 --> 00:53:01,119
let's say trivially assignable

00:52:59,359 --> 00:53:02,960
cell constructor has a slightly less

00:53:01,119 --> 00:53:05,440
interesting meaning

00:53:02,960 --> 00:53:07,599
but i will guarantee that i write to it

00:53:05,440 --> 00:53:09,359
including initialize it the first time

00:53:07,599 --> 00:53:11,440
and that i won't read from it before i

00:53:09,359 --> 00:53:13,040
write

00:53:11,440 --> 00:53:16,079
and this should be the same if it's an

00:53:13,040 --> 00:53:18,319
array of byte of four

00:53:16,079 --> 00:53:20,319
not just a ray of byte of a million it

00:53:18,319 --> 00:53:23,040
should be the same for array byte

00:53:20,319 --> 00:53:24,480
four as for int which is the same size

00:53:23,040 --> 00:53:27,680
on most platforms

00:53:24,480 --> 00:53:31,359
and in this proposal all types

00:53:27,680 --> 00:53:33,520
big pods arrays ins have all these same

00:53:31,359 --> 00:53:36,880
rules

00:53:33,520 --> 00:53:39,040
now for types today that

00:53:36,880 --> 00:53:40,079
are initialized of declaration like say

00:53:39,040 --> 00:53:43,200
a vector event

00:53:40,079 --> 00:53:44,880
today we call the default constructor

00:53:43,200 --> 00:53:46,400
that may not do a whole lot for vector

00:53:44,880 --> 00:53:47,440
but it's an example of these dummy

00:53:46,400 --> 00:53:49,599
writes because

00:53:47,440 --> 00:53:50,720
we're now going to get value data that's

00:53:49,599 --> 00:53:54,079
going to fill

00:53:50,720 --> 00:53:54,640
the data but if we could just construct

00:53:54,079 --> 00:53:57,440
it

00:53:54,640 --> 00:53:59,359
on the first call to get value to fill

00:53:57,440 --> 00:54:00,960
the value into data

00:53:59,359 --> 00:54:03,359
then we could eliminate some dead writes

00:54:00,960 --> 00:54:05,520
already from that vector event

00:54:03,359 --> 00:54:06,960
so the way i'm proposing to opt in to

00:54:05,520 --> 00:54:09,119
say no i want to just

00:54:06,960 --> 00:54:10,000
allocate enough storage for a vector of

00:54:09,119 --> 00:54:13,040
in but not

00:54:10,000 --> 00:54:14,319
construct it yet the same as if i wrote

00:54:13,040 --> 00:54:16,640
into data there

00:54:14,319 --> 00:54:18,240
or byte data to write equals

00:54:16,640 --> 00:54:19,280
uninitialized and you'll remember on the

00:54:18,240 --> 00:54:22,480
previous slides

00:54:19,280 --> 00:54:23,839
i put in in in comments as if

00:54:22,480 --> 00:54:25,680
equivalently writing equals

00:54:23,839 --> 00:54:27,040
uninitialized but there it's already

00:54:25,680 --> 00:54:28,640
implicit in the language

00:54:27,040 --> 00:54:31,520
this would make it consistent throughout

00:54:28,640 --> 00:54:33,040
the language and i would enforce

00:54:31,520 --> 00:54:34,720
that i don't read from the existing

00:54:33,040 --> 00:54:36,240
value of v which is the first time

00:54:34,720 --> 00:54:39,280
through it's not constructed yet

00:54:36,240 --> 00:54:39,760
so that's good and then when i set it if

00:54:39,280 --> 00:54:42,319
v

00:54:39,760 --> 00:54:45,280
is not already constructed i will turn

00:54:42,319 --> 00:54:46,799
that into a constructor call

00:54:45,280 --> 00:54:49,200
if it was already constructed it will be

00:54:46,799 --> 00:54:52,559
an assignment and then i will make sure

00:54:49,200 --> 00:54:54,640
i do that before i read from it

00:54:52,559 --> 00:54:56,400
this allows you flexibility for the last

00:54:54,640 --> 00:54:56,799
example let's say it's some other type

00:54:56,400 --> 00:54:59,280
like

00:54:56,799 --> 00:55:00,640
database info and i might want to

00:54:59,280 --> 00:55:03,200
construct it

00:55:00,640 --> 00:55:04,799
two different ways i can't easily say

00:55:03,200 --> 00:55:06,000
that in c-pluses today i can write a

00:55:04,799 --> 00:55:08,319
lambda that does this and then

00:55:06,000 --> 00:55:09,599
kind of tries to move the result back

00:55:08,319 --> 00:55:10,480
but i can't write alternative

00:55:09,599 --> 00:55:12,799
constructors

00:55:10,480 --> 00:55:14,640
easily today but here i can i just

00:55:12,799 --> 00:55:15,760
declare it as uninitialized give me

00:55:14,640 --> 00:55:18,880
enough

00:55:15,760 --> 00:55:21,119
space on the stack for a db info and

00:55:18,880 --> 00:55:22,720
if the main site is there call one

00:55:21,119 --> 00:55:24,720
constructor it's just a function with an

00:55:22,720 --> 00:55:26,559
out parameter is a constructor

00:55:24,720 --> 00:55:28,079
otherwise call some other constructor

00:55:26,559 --> 00:55:28,640
which in this case just has a different

00:55:28,079 --> 00:55:29,839
argument

00:55:28,640 --> 00:55:31,920
but could be a completely different

00:55:29,839 --> 00:55:32,799
parameter list with 100 parameters if

00:55:31,920 --> 00:55:35,839
you wanted to

00:55:32,799 --> 00:55:35,839
and it would just work

00:55:36,480 --> 00:55:42,559
so here is the entire guidance

00:55:40,480 --> 00:55:44,559
to an implementer this is the

00:55:42,559 --> 00:55:47,440
implementer compiler writers cheat sheet

00:55:44,559 --> 00:55:49,040
for what they would have to do

00:55:47,440 --> 00:55:51,520
this is in much more detail than we

00:55:49,040 --> 00:55:55,119
actually teach have to teach programmers

00:55:51,520 --> 00:55:58,400
programmers is just declare the intent

00:55:55,119 --> 00:56:01,200
do i want an x i could read from in

00:55:58,400 --> 00:56:02,160
when i can read or write in out that i

00:56:01,200 --> 00:56:05,520
assign to

00:56:02,160 --> 00:56:06,480
out that i move from move and i pass

00:56:05,520 --> 00:56:10,000
along

00:56:06,480 --> 00:56:12,319
forward i would like to have that be

00:56:10,000 --> 00:56:13,760
in some future c plus maybe five or ten

00:56:12,319 --> 00:56:15,680
years from now

00:56:13,760 --> 00:56:17,920
that that's all i have to do to teach

00:56:15,680 --> 00:56:21,920
parameter passing in c plus plus or any

00:56:17,920 --> 00:56:21,920
equivalent language of equivalent power

00:56:22,319 --> 00:56:26,640
so empirically we've seen that parameter

00:56:24,079 --> 00:56:28,240
passing and initialization are about 23

00:56:26,640 --> 00:56:30,160
at least so far in the guidance i've

00:56:28,240 --> 00:56:32,960
cataloged and

00:56:30,160 --> 00:56:34,160
another 13 is in the kind of class you

00:56:32,960 --> 00:56:36,400
author am i writing

00:56:34,160 --> 00:56:38,079
a proxy am i writing a com class am i

00:56:36,400 --> 00:56:40,720
writing a value type am

00:56:38,079 --> 00:56:44,799
i writing something else am i writing a

00:56:40,720 --> 00:56:46,960
virtual interface or a base class

00:56:44,799 --> 00:56:48,720
with this proposal i talked about today

00:56:46,960 --> 00:56:49,520
which is numbered 708 when it gets

00:56:48,720 --> 00:56:51,280
published

00:56:49,520 --> 00:56:53,920
and the meta classes proposal which is

00:56:51,280 --> 00:56:56,720
numbered 707

00:56:53,920 --> 00:56:58,960
having actually looked at the rules and

00:56:56,720 --> 00:56:59,359
analyzed and cataloged and personally

00:56:58,960 --> 00:57:01,119
read

00:56:59,359 --> 00:57:02,960
the literature for months i believe that

00:57:01,119 --> 00:57:05,040
about 30

00:57:02,960 --> 00:57:08,240
of what we teach people about c plus was

00:57:05,040 --> 00:57:10,319
today we could stop teaching

00:57:08,240 --> 00:57:12,079
if we could have those features and then

00:57:10,319 --> 00:57:13,359
a mode that says don't use the old thing

00:57:12,079 --> 00:57:15,200
because as long as the old thing is

00:57:13,359 --> 00:57:16,160
around you still have to teach that but

00:57:15,200 --> 00:57:18,240
for new code

00:57:16,160 --> 00:57:19,839
that we could stop teaching about thirty

00:57:18,240 --> 00:57:22,960
percent of what we currently

00:57:19,839 --> 00:57:24,559
in fact teach empirically about c plus

00:57:22,960 --> 00:57:26,559
plus if we had

00:57:24,559 --> 00:57:27,839
intention based parameter passing

00:57:26,559 --> 00:57:30,720
initialization

00:57:27,839 --> 00:57:30,720
and meta classes

00:57:31,119 --> 00:57:35,520
so what i've tried to do is contribute

00:57:33,440 --> 00:57:38,640
an empirical attempt to catalog

00:57:35,520 --> 00:57:40,640
classify count what we teach

00:57:38,640 --> 00:57:43,040
in the complexity so we can measure the

00:57:40,640 --> 00:57:46,480
complexity of c plus also not just say

00:57:43,040 --> 00:57:47,200
it's complex but to be even more precise

00:57:46,480 --> 00:57:50,319
as to

00:57:47,200 --> 00:57:52,079
how much more 90 like bianna said and go

00:57:50,319 --> 00:57:54,880
well beyond that into exactly

00:57:52,079 --> 00:57:56,400
where are those sources and we've talked

00:57:54,880 --> 00:57:58,640
about how to address

00:57:56,400 --> 00:58:00,640
two or three of the larger categories

00:57:58,640 --> 00:58:03,520
two in particular in this talk

00:58:00,640 --> 00:58:05,200
that add up to a potential 30 reduction

00:58:03,520 --> 00:58:07,440
if you include meta classes in the other

00:58:05,200 --> 00:58:07,440
talk

00:58:07,680 --> 00:58:10,880
you could read more at my github repo h

00:58:10,160 --> 00:58:12,559
stutter

00:58:10,880 --> 00:58:14,079
708 that's going to be the paper number

00:58:12,559 --> 00:58:16,079
when it's published

00:58:14,079 --> 00:58:18,480
and it has some examples and test cases

00:58:16,079 --> 00:58:21,040
you can go to cppx.org

00:58:18,480 --> 00:58:22,160
and find out and try examples of your

00:58:21,040 --> 00:58:23,839
own there

00:58:22,160 --> 00:58:25,280
not all of them will work yet but many

00:58:23,839 --> 00:58:27,359
of them do

00:58:25,280 --> 00:58:29,280
by the way one last teaser answers are

00:58:27,359 --> 00:58:33,040
in the paper

00:58:29,280 --> 00:58:36,880
what would an out this mean

00:58:33,040 --> 00:58:39,520
hmm well every out parameter

00:58:36,880 --> 00:58:41,359
can both assign a value but also

00:58:39,520 --> 00:58:44,319
construct an uninitialized

00:58:41,359 --> 00:58:44,319
object hmm

00:58:45,200 --> 00:58:48,799
what would operator equal taking in x

00:58:47,359 --> 00:58:53,040
mean well

00:58:48,799 --> 00:58:55,520
n means an x i can read from and it

00:58:53,040 --> 00:58:56,960
if you copy it knows to copy from l

00:58:55,520 --> 00:59:00,720
values and automatically

00:58:56,960 --> 00:59:00,720
moves from r values

00:59:02,160 --> 00:59:05,680
so what would writing both mean think

00:59:04,799 --> 00:59:08,880
about it

00:59:05,680 --> 00:59:11,839
and compare your answer to the paper

00:59:08,880 --> 00:59:13,359
finally let me summarize many of the cpp

00:59:11,839 --> 00:59:15,359
contacts i've given over these last

00:59:13,359 --> 00:59:18,640
seven years since i started

00:59:15,359 --> 00:59:20,160
a systematic effort to look at

00:59:18,640 --> 00:59:22,160
what are the sources of c plus losses

00:59:20,160 --> 00:59:24,720
complexity and how can we

00:59:22,160 --> 00:59:27,440
simplify c plus plus this is talk seven

00:59:24,720 --> 00:59:27,440
in that series

00:59:27,920 --> 00:59:31,119
i talked about starting this is in

00:59:29,440 --> 00:59:32,799
roughly chronological order i'm going to

00:59:31,119 --> 00:59:33,920
skip the c false's core guidelines which

00:59:32,799 --> 00:59:36,240
is about how to use c

00:59:33,920 --> 00:59:38,400
sources in a simpler way today today's c

00:59:36,240 --> 00:59:39,920
plus in a simpler way

00:59:38,400 --> 00:59:41,599
the lifetime proposal and the paper

00:59:39,920 --> 00:59:43,440
number is 1179

00:59:41,599 --> 00:59:45,359
is about simplifying by directly

00:59:43,440 --> 00:59:47,520
supporting owners and pointers and

00:59:45,359 --> 00:59:48,400
eliminate classes of errors like use

00:59:47,520 --> 00:59:50,960
after free

00:59:48,400 --> 00:59:52,240
use after you invalidate an iterator to

00:59:50,960 --> 00:59:54,000
know those things and

00:59:52,240 --> 00:59:57,119
give you compile time warnings and

00:59:54,000 --> 00:59:58,240
errors to not make those mistakes

00:59:57,119 --> 01:00:00,400
those have been prototyped and

00:59:58,240 --> 01:00:02,559
implemented largely and

01:00:00,400 --> 01:00:04,400
next steps there is continue the

01:00:02,559 --> 01:00:07,599
upstreaming in clang which has

01:00:04,400 --> 01:00:09,599
just begun another

01:00:07,599 --> 01:00:11,359
part of this effort is simplifying

01:00:09,599 --> 01:00:12,960
comparisons to directly express

01:00:11,359 --> 01:00:14,880
the comparison intent to get rid of

01:00:12,960 --> 01:00:17,280
boilerplate and errors

01:00:14,880 --> 01:00:19,040
that has been adopted into c plus plus

01:00:17,280 --> 01:00:19,440
20 already so the next steps there is

01:00:19,040 --> 01:00:22,720
for

01:00:19,440 --> 01:00:22,720
implementers to implement it

01:00:22,880 --> 01:00:29,280
metaclasses itself relies on

01:00:26,240 --> 01:00:31,040
reflection const compel time programming

01:00:29,280 --> 01:00:32,960
consti val programming

01:00:31,040 --> 01:00:34,799
and code injection once you have those

01:00:32,960 --> 01:00:36,400
metaclasses themselves become a very

01:00:34,799 --> 01:00:38,000
thin veneer

01:00:36,400 --> 01:00:39,599
that is moving along well in fact

01:00:38,000 --> 01:00:41,520
reflection is advancing well in the

01:00:39,599 --> 01:00:43,440
committee and it is one of the very

01:00:41,520 --> 01:00:44,640
small the handful of priorities six or

01:00:43,440 --> 01:00:47,440
seven priorities

01:00:44,640 --> 01:00:49,440
that the committee has formally adopted

01:00:47,440 --> 01:00:52,240
to give priority to working on

01:00:49,440 --> 01:00:52,559
in the next three years so that's moving

01:00:52,240 --> 01:00:55,920
well

01:00:52,559 --> 01:00:57,520
and in fact c plus plus 20 const eval

01:00:55,920 --> 01:00:59,520
that feature

01:00:57,520 --> 01:01:00,880
came directly from the metaclass's

01:00:59,520 --> 01:01:03,520
prototype implementation

01:01:00,880 --> 01:01:05,119
and anderson thank you again so it we're

01:01:03,520 --> 01:01:07,520
making progress it's all coming into the

01:01:05,119 --> 01:01:09,200
standard and we're on track

01:01:07,520 --> 01:01:10,960
static exception handling i started

01:01:09,200 --> 01:01:13,440
talking about two years ago

01:01:10,960 --> 01:01:14,960
it is not yet prototyped we got initial

01:01:13,440 --> 01:01:16,160
feedback from the committee saying

01:01:14,960 --> 01:01:18,480
this could be a direction that we're

01:01:16,160 --> 01:01:20,319
interested in exploring please answer

01:01:18,480 --> 01:01:21,920
these hard questions which we're going

01:01:20,319 --> 01:01:24,000
to do and let's

01:01:21,920 --> 01:01:25,760
build a prototype and let's actually

01:01:24,000 --> 01:01:26,480
verify you can get these benefits and

01:01:25,760 --> 01:01:28,960
then it takes

01:01:26,480 --> 01:01:30,720
a language extension if it does so the

01:01:28,960 --> 01:01:32,319
next step is to say great we've now

01:01:30,720 --> 01:01:35,119
seen there's enough interest to justify

01:01:32,319 --> 01:01:37,520
doing a prototype so we'll do that next

01:01:35,119 --> 01:01:38,799
and then today i talked about directly

01:01:37,520 --> 01:01:40,880
expressing

01:01:38,799 --> 01:01:42,240
so and i should say by the way for why

01:01:40,880 --> 01:01:43,440
static exception handling that

01:01:42,240 --> 01:01:45,760
simplification

01:01:43,440 --> 01:01:46,799
because the greatest fracture point in c

01:01:45,760 --> 01:01:50,000
plus today

01:01:46,799 --> 01:01:51,359
is the huge rift between libraries and

01:01:50,000 --> 01:01:53,440
code that and projects

01:01:51,359 --> 01:01:56,240
that report errors using exceptions and

01:01:53,440 --> 01:01:58,160
those that disable exceptions

01:01:56,240 --> 01:02:00,240
this creates a rift at a fracture point

01:01:58,160 --> 01:02:01,920
in inconsistencies that i talked about

01:02:00,240 --> 01:02:03,760
a year or two ago here at this

01:02:01,920 --> 01:02:05,839
conference so

01:02:03,760 --> 01:02:07,680
check this out and you can see the more

01:02:05,839 --> 01:02:10,000
in paper 709

01:02:07,680 --> 01:02:11,200
and finally parameter passing directly

01:02:10,000 --> 01:02:14,400
express intent again

01:02:11,200 --> 01:02:16,799
like all of these simplify the way c

01:02:14,400 --> 01:02:19,119
plus s is actually used by directly

01:02:16,799 --> 01:02:20,400
expressing intent to get rid of this

01:02:19,119 --> 01:02:23,039
case boilerplate

01:02:20,400 --> 01:02:24,079
and unify initialization we are

01:02:23,039 --> 01:02:25,520
currently part way through

01:02:24,079 --> 01:02:27,119
prototyping that in clang all the

01:02:25,520 --> 01:02:29,920
prototypes are available

01:02:27,119 --> 01:02:31,920
at cppxgodbolt.org so the next steps

01:02:29,920 --> 01:02:35,280
there is to continue working on that

01:02:31,920 --> 01:02:37,200
now before the pandemic came

01:02:35,280 --> 01:02:39,280
i intended to bring this paper to the

01:02:37,200 --> 01:02:41,039
committee probably at this next upcoming

01:02:39,280 --> 01:02:42,559
meeting which would have been new york

01:02:41,039 --> 01:02:45,359
two months from now but that's been

01:02:42,559 --> 01:02:46,720
canceled we're not meeting face-to-face

01:02:45,359 --> 01:02:48,960
i'm not going to try to bring it right

01:02:46,720 --> 01:02:50,400
now because the committee's bandwidth is

01:02:48,960 --> 01:02:51,760
reduced we don't have our face-to-face

01:02:50,400 --> 01:02:53,200
meetings we're still making some

01:02:51,760 --> 01:02:55,200
progress

01:02:53,200 --> 01:02:57,680
but the committee needs to focus for now

01:02:55,200 --> 01:03:00,960
just on those six or seven priorities

01:02:57,680 --> 01:03:02,880
for this sequel 23 cycle

01:03:00,960 --> 01:03:04,400
not all of which will land in c plus 23

01:03:02,880 --> 01:03:07,599
even without the pandemic

01:03:04,400 --> 01:03:09,920
but finishing like the co-routine uh

01:03:07,599 --> 01:03:11,520
enabling the standard library a module

01:03:09,920 --> 01:03:11,839
enabling the standard library to finish

01:03:11,520 --> 01:03:15,680
c

01:03:11,839 --> 01:03:17,839
plus 20 reflection pattern matching

01:03:15,680 --> 01:03:19,760
this is not the time to bring a brand

01:03:17,839 --> 01:03:22,000
new big proposal to the committee

01:03:19,760 --> 01:03:23,760
so i'm going to publish it on github

01:03:22,000 --> 01:03:26,000
which i've done you can find it today

01:03:23,760 --> 01:03:26,799
it will be a committee paper but when

01:03:26,000 --> 01:03:28,640
the committee

01:03:26,799 --> 01:03:30,079
has more time again after this pandemic

01:03:28,640 --> 01:03:31,200
is over and we can have a more normal

01:03:30,079 --> 01:03:32,799
life

01:03:31,200 --> 01:03:34,319
then we'll also be able to make use of

01:03:32,799 --> 01:03:35,839
what we learned from the prototypes and

01:03:34,319 --> 01:03:36,799
any feedback that you may have so please

01:03:35,839 --> 01:03:42,000
open issues

01:03:36,799 --> 01:03:42,000
against that repo last thought

01:03:42,079 --> 01:03:45,440
c process has always been about

01:03:43,760 --> 01:03:46,160
efficient abstraction and i want to

01:03:45,440 --> 01:03:49,920
emphasize

01:03:46,160 --> 01:03:52,799
in that order too many languages

01:03:49,920 --> 01:03:53,920
design a great abstraction well-designed

01:03:52,799 --> 01:03:56,319
abstraction even

01:03:53,920 --> 01:03:56,960
and then try to make it efficient that's

01:03:56,319 --> 01:03:59,680
what made

01:03:56,960 --> 01:04:00,960
small talk slow with all its messages it

01:03:59,680 --> 01:04:02,640
was elegant

01:04:00,960 --> 01:04:04,799
but you couldn't make it fast compared

01:04:02,640 --> 01:04:06,319
to c plus plus that's what made c plus

01:04:04,799 --> 01:04:08,319
or so x concepts

01:04:06,319 --> 01:04:11,359
fail because it incurred overheads and

01:04:08,319 --> 01:04:13,280
then couldn't optimize them away

01:04:11,359 --> 01:04:14,960
instead learn from what we already do so

01:04:13,280 --> 01:04:16,960
i hope with all of the examples i just

01:04:14,960 --> 01:04:19,039
mentioned in the previous slide

01:04:16,960 --> 01:04:20,400
lifetime how we use owners owner types

01:04:19,039 --> 01:04:21,920
and iterators

01:04:20,400 --> 01:04:24,799
our pointer like types are already being

01:04:21,920 --> 01:04:26,160
used widely meta classes we already have

01:04:24,799 --> 01:04:28,799
guidance on how to write

01:04:26,160 --> 01:04:30,400
certain kinds of types parameter passing

01:04:28,799 --> 01:04:32,799
we have rich guidance on how to pass

01:04:30,400 --> 01:04:34,640
parameters

01:04:32,799 --> 01:04:36,480
learn from what we've already done and

01:04:34,640 --> 01:04:38,480
we've already learned the efficient way

01:04:36,480 --> 01:04:42,079
to do those things

01:04:38,480 --> 01:04:44,160
but by hand and then for the important

01:04:42,079 --> 01:04:46,400
ones of those abstractions

01:04:44,160 --> 01:04:47,200
we know the efficient way then make the

01:04:46,400 --> 01:04:48,960
abstraction

01:04:47,200 --> 01:04:50,880
build it into the standard library or

01:04:48,960 --> 01:04:52,559
even the language as appropriate

01:04:50,880 --> 01:04:54,000
so the programmer can directly express

01:04:52,559 --> 01:04:55,760
the intent

01:04:54,000 --> 01:04:57,920
and instead of writing it by hand it's

01:04:55,760 --> 01:04:59,440
automated this describes what i try to

01:04:57,920 --> 01:05:01,119
do with meta classes it

01:04:59,440 --> 01:05:03,039
describes exactly what we talked about

01:05:01,119 --> 01:05:05,200
today with parameter passing

01:05:03,039 --> 01:05:06,400
and by value exception handling express

01:05:05,200 --> 01:05:09,839
intent and then

01:05:06,400 --> 01:05:09,839
implement it in an efficient way

01:05:11,760 --> 01:05:15,440
welcome back so i've been looking at

01:05:13,599 --> 01:05:15,920
your questions and but first of all let

01:05:15,440 --> 01:05:18,079
me say

01:05:15,920 --> 01:05:19,039
the same thing as john and thank you

01:05:18,079 --> 01:05:21,839
john

01:05:19,039 --> 01:05:23,359
for helping us put on this conference

01:05:21,839 --> 01:05:24,799
without you this would not have been

01:05:23,359 --> 01:05:26,880
possible

01:05:24,799 --> 01:05:28,000
and with all of our supporters including

01:05:26,880 --> 01:05:29,599
all the volunteers

01:05:28,000 --> 01:05:31,280
a personal thank you for me and from the

01:05:29,599 --> 01:05:32,400
standard c fossils foundation who puts

01:05:31,280 --> 01:05:34,000
this on

01:05:32,400 --> 01:05:35,920
despite everything we were able to have

01:05:34,000 --> 01:05:38,400
cppcon this year in such a great way so

01:05:35,920 --> 01:05:40,799
i really appreciate that

01:05:38,400 --> 01:05:42,319
going to the questions i'm going to take

01:05:40,799 --> 01:05:44,160
them mostly in order from

01:05:42,319 --> 01:05:46,559
the upvoted ones so please feel free to

01:05:44,160 --> 01:05:48,640
hit up vote if you haven't already

01:05:46,559 --> 01:05:50,079
and the first question actually the

01:05:48,640 --> 01:05:54,000
first two are very

01:05:50,079 --> 01:05:56,240
similar wouldn't abi stability become

01:05:54,000 --> 01:05:57,920
even harder if an in parameter could

01:05:56,240 --> 01:05:59,520
change from pass by value to pass by

01:05:57,920 --> 01:06:02,000
reference

01:05:59,520 --> 01:06:03,200
at some point because of some small

01:06:02,000 --> 01:06:06,960
change

01:06:03,200 --> 01:06:09,920
the answer is yes that could be and so

01:06:06,960 --> 01:06:11,839
today you would be changing your pass by

01:06:09,920 --> 01:06:13,280
value to pass by reference manually so

01:06:11,839 --> 01:06:14,880
you can see that

01:06:13,280 --> 01:06:16,880
but this actually overlaps with the next

01:06:14,880 --> 01:06:17,599
question which is how would i tell the

01:06:16,880 --> 01:06:19,839
compiler

01:06:17,599 --> 01:06:20,720
that my type is cheap to copy or tell

01:06:19,839 --> 01:06:23,200
that i really want

01:06:20,720 --> 01:06:24,799
in parameters of it to be by value i

01:06:23,200 --> 01:06:26,319
think that both of these which i have

01:06:24,799 --> 01:06:28,720
not yet written in the paper but

01:06:26,319 --> 01:06:30,799
which is on my to-do list i think both

01:06:28,720 --> 01:06:32,880
of these can be addressed the same way

01:06:30,799 --> 01:06:34,720
and that is by how giving the type away

01:06:32,880 --> 01:06:35,440
to opt-in to how it would like to be

01:06:34,720 --> 01:06:37,119
passed

01:06:35,440 --> 01:06:38,960
and you probably wanted by default to

01:06:37,119 --> 01:06:40,799
enable the type author to do that

01:06:38,960 --> 01:06:42,079
i can imagine cases where you may want

01:06:40,799 --> 01:06:44,960
the owner of

01:06:42,079 --> 01:06:45,599
a system to be able to up that to make

01:06:44,960 --> 01:06:48,799
the

01:06:45,599 --> 01:06:49,680
choice one way to do that would simply

01:06:48,799 --> 01:06:52,559
be to have

01:06:49,680 --> 01:06:52,880
a trait which defaults in certain ways

01:06:52,559 --> 01:06:54,480
so

01:06:52,880 --> 01:06:56,160
you might in fact if you write it as a

01:06:54,480 --> 01:06:56,799
trait then we can simply provide the

01:06:56,160 --> 01:07:00,000
default

01:06:56,799 --> 01:07:01,920
uh the condition for should pass by

01:07:00,000 --> 01:07:03,119
value and then you can specialize it for

01:07:01,920 --> 01:07:05,119
your types

01:07:03,119 --> 01:07:07,039
of course anytime you hear traits i say

01:07:05,119 --> 01:07:08,319
that mostly for familiarity

01:07:07,039 --> 01:07:10,000
remember that these days we would

01:07:08,319 --> 01:07:11,839
normally spell those instead as

01:07:10,000 --> 01:07:13,119
constants for functions and overloads

01:07:11,839 --> 01:07:15,839
that kind of thing

01:07:13,119 --> 01:07:16,720
so those are ways that yes i think there

01:07:15,839 --> 01:07:19,920
if

01:07:16,720 --> 01:07:22,640
there is a way to opt-in then not only

01:07:19,920 --> 01:07:24,880
can it make it easy to say hey here i

01:07:22,640 --> 01:07:27,599
want my type to be passed by value

01:07:24,880 --> 01:07:28,400
or not but it can help address abi

01:07:27,599 --> 01:07:30,640
stability

01:07:28,400 --> 01:07:31,920
as well while still giving you that

01:07:30,640 --> 01:07:34,480
automatic

01:07:31,920 --> 01:07:35,920
optimization for all the many places

01:07:34,480 --> 01:07:37,200
that use your site if i have something

01:07:35,920 --> 01:07:39,599
where i can say it

01:07:37,200 --> 01:07:42,559
optionally once per type that's a great

01:07:39,599 --> 01:07:44,240
place to be

01:07:42,559 --> 01:07:46,400
the next question is how will the

01:07:44,240 --> 01:07:48,720
parameter description work with

01:07:46,400 --> 01:07:50,240
inheritance what if the base abstract

01:07:48,720 --> 01:07:52,079
method defines an in-out and the

01:07:50,240 --> 01:07:54,319
indentation does not write to

01:07:52,079 --> 01:07:55,119
the parameter so this was actually this

01:07:54,319 --> 01:07:57,599
is a very good

01:07:55,119 --> 01:07:58,160
example this was touched on in the talk

01:07:57,599 --> 01:08:00,480
so

01:07:58,160 --> 01:08:02,160
first of all they have to be consistent

01:08:00,480 --> 01:08:03,599
you can't say take an in-out parameter

01:08:02,160 --> 01:08:05,839
and a base virtual function

01:08:03,599 --> 01:08:07,520
and override it with an out so that they

01:08:05,839 --> 01:08:08,640
have to match the declarations have to

01:08:07,520 --> 01:08:11,039
match otherwise you're not

01:08:08,640 --> 01:08:12,720
overwriting the virtual function but if

01:08:11,039 --> 01:08:14,319
you recall in the talk or if you go back

01:08:12,720 --> 01:08:17,120
in the slides

01:08:14,319 --> 01:08:17,759
one of the things you'll see is that it

01:08:17,120 --> 01:08:21,839
says

01:08:17,759 --> 01:08:24,880
for for those for in-out the rule is

01:08:21,839 --> 01:08:27,679
if it's not a virtual function

01:08:24,880 --> 01:08:28,319
and you didn't write to it on any path

01:08:27,679 --> 01:08:31,040
then

01:08:28,319 --> 01:08:31,839
flag that because you wrote in out if

01:08:31,040 --> 01:08:33,679
you

01:08:31,839 --> 01:08:34,960
didn't won't ever write to it on any

01:08:33,679 --> 01:08:37,040
path then you meant in

01:08:34,960 --> 01:08:38,319
you should have written that but we

01:08:37,040 --> 01:08:41,600
specifically have car

01:08:38,319 --> 01:08:42,799
that uh that exception out if it's not a

01:08:41,600 --> 01:08:44,799
virtual function

01:08:42,799 --> 01:08:46,880
because the way that that i think is the

01:08:44,799 --> 01:08:49,759
right way to think of a virtual function

01:08:46,880 --> 01:08:50,319
is that the virtual function is its base

01:08:49,759 --> 01:08:53,600
version

01:08:50,319 --> 01:08:54,560
and all derived versions together is the

01:08:53,600 --> 01:08:56,319
function

01:08:54,560 --> 01:08:58,159
and of course that's an open set because

01:08:56,319 --> 01:08:59,839
unless you deliberately

01:08:58,159 --> 01:09:01,199
prevent people from further expanding

01:08:59,839 --> 01:09:03,120
and extending

01:09:01,199 --> 01:09:07,759
that can include functions in the future

01:09:03,120 --> 01:09:09,839
that aren't even written today

01:09:07,759 --> 01:09:11,600
if i can only see part of that set i

01:09:09,839 --> 01:09:14,080
can't verify in out

01:09:11,600 --> 01:09:15,839
so by saying in out it could be quite

01:09:14,080 --> 01:09:18,880
reasonable in a base

01:09:15,839 --> 01:09:21,359
virtual function to happen to

01:09:18,880 --> 01:09:23,359
have the default implementation not

01:09:21,359 --> 01:09:26,480
right to the parameter and use the out

01:09:23,359 --> 01:09:27,040
but by writing in out it leaves the

01:09:26,480 --> 01:09:30,239
option

01:09:27,040 --> 01:09:30,880
for derived overrides to be able to do

01:09:30,239 --> 01:09:33,359
that

01:09:30,880 --> 01:09:35,279
so we are declaring the intent and

01:09:33,359 --> 01:09:37,440
exactly what is allowed

01:09:35,279 --> 01:09:39,199
but because we can't see the whole body

01:09:37,440 --> 01:09:40,880
we're not going to flag hey you know you

01:09:39,199 --> 01:09:41,600
never wrote to this at this in-app

01:09:40,880 --> 01:09:44,640
parameter

01:09:41,600 --> 01:09:45,839
so why did you include the word out well

01:09:44,640 --> 01:09:47,279
you might have we just can't see the

01:09:45,839 --> 01:09:48,000
whole function because conceptually the

01:09:47,279 --> 01:09:50,719
whole function

01:09:48,000 --> 01:09:53,120
is all the overloads that are that work

01:09:50,719 --> 01:09:53,120
together

01:09:53,359 --> 01:09:56,960
the next question is do you have a

01:09:54,719 --> 01:09:58,640
conservative estimation

01:09:56,960 --> 01:10:00,239
of the time required for the language to

01:09:58,640 --> 01:10:02,000
evolve in this direction given the

01:10:00,239 --> 01:10:03,600
constraint of language teacher backwards

01:10:02,000 --> 01:10:05,199
compatibility or is this

01:10:03,600 --> 01:10:06,640
yet another way well there's a few

01:10:05,199 --> 01:10:08,960
things in here

01:10:06,640 --> 01:10:10,560
any standards proposal of this kind is

01:10:08,960 --> 01:10:13,120
going to take years

01:10:10,560 --> 01:10:14,320
so i i've been working on this and

01:10:13,120 --> 01:10:15,840
getting feedback as you'll see

01:10:14,320 --> 01:10:17,280
acknowledged in the paper from a lot of

01:10:15,840 --> 01:10:19,040
people already

01:10:17,280 --> 01:10:21,280
and this is actually i first started

01:10:19,040 --> 01:10:23,600
writing up about five years ago

01:10:21,280 --> 01:10:25,280
it is now at the point where i feel safe

01:10:23,600 --> 01:10:26,560
talking publicly about it because i was

01:10:25,280 --> 01:10:29,520
going to bring the paper

01:10:26,560 --> 01:10:30,320
to begin the standardization process but

01:10:29,520 --> 01:10:32,719
we're still

01:10:30,320 --> 01:10:33,679
at the point where the prototype is is

01:10:32,719 --> 01:10:35,440
being implemented

01:10:33,679 --> 01:10:37,120
it's pretty complete for in but we're

01:10:35,440 --> 01:10:38,400
still working on things like variatics

01:10:37,120 --> 01:10:39,520
and things like that and virtual

01:10:38,400 --> 01:10:42,159
functions

01:10:39,520 --> 01:10:43,840
so this is going to take some years and

01:10:42,159 --> 01:10:45,440
in the talk i said i hope that in the

01:10:43,840 --> 01:10:48,560
next five or ten years

01:10:45,440 --> 01:10:49,920
i'll be able to teach just this so i

01:10:48,560 --> 01:10:53,120
understand that that

01:10:49,920 --> 01:10:55,520
requires more patience than many have

01:10:53,120 --> 01:10:57,600
that's the the only way to work in the

01:10:55,520 --> 01:10:59,280
standards world is to have patience and

01:10:57,600 --> 01:11:01,600
be designing things that

01:10:59,280 --> 01:11:02,640
as you would like them to be a few years

01:11:01,600 --> 01:11:05,679
from now

01:11:02,640 --> 01:11:07,199
having said that this is something the

01:11:05,679 --> 01:11:08,159
other part of the question is a good one

01:11:07,199 --> 01:11:10,080
too which is

01:11:08,159 --> 01:11:12,000
is this adding complexity to the

01:11:10,080 --> 01:11:14,239
language absolutely it is

01:11:12,000 --> 01:11:16,239
so i bullet a simplification just like i

01:11:14,239 --> 01:11:19,199
have with some of my other proposals

01:11:16,239 --> 01:11:21,520
which it is but that's if you don't use

01:11:19,199 --> 01:11:24,159
the old thing anymore

01:11:21,520 --> 01:11:24,719
and there's a legitimate objection that

01:11:24,159 --> 01:11:26,880
says

01:11:24,719 --> 01:11:28,719
well but for the foreseeable future old

01:11:26,880 --> 01:11:30,320
thing code is going to exist so i

01:11:28,719 --> 01:11:32,000
will have to still teach that and learn

01:11:30,320 --> 01:11:34,719
that

01:11:32,000 --> 01:11:35,760
yes but so there's two answers to that

01:11:34,719 --> 01:11:37,760
first

01:11:35,760 --> 01:11:40,000
if we get a simplification like this

01:11:37,760 --> 01:11:42,080
that subsumes and is a replacement

01:11:40,000 --> 01:11:43,520
for an old thing just like the using

01:11:42,080 --> 01:11:46,480
alias completely

01:11:43,520 --> 01:11:47,360
uh subsumed all the uses of type deaths

01:11:46,480 --> 01:11:49,280
and we can

01:11:47,360 --> 01:11:51,040
ignore type tests and use only using in

01:11:49,280 --> 01:11:54,080
the future that kind of thing but

01:11:51,040 --> 01:11:57,440
more so then at least for

01:11:54,080 --> 01:11:58,880
new code we can teach people to only use

01:11:57,440 --> 01:12:00,560
the new thing if you have a c plus loss

01:11:58,880 --> 01:12:03,120
whatever compiler

01:12:00,560 --> 01:12:04,880
use only the new thing in new code and

01:12:03,120 --> 01:12:07,280
then the code that you're writing

01:12:04,880 --> 01:12:08,800
is simpler and we can actually provide

01:12:07,280 --> 01:12:10,640
compiler modes and

01:12:08,800 --> 01:12:12,159
static analysis checker modes that will

01:12:10,640 --> 01:12:13,040
warn you if you program outside that

01:12:12,159 --> 01:12:16,880
subset

01:12:13,040 --> 01:12:20,320
of the new language which is smaller

01:12:16,880 --> 01:12:22,239
but that's my convention i hope to have

01:12:20,320 --> 01:12:23,920
all of these things add up to

01:12:22,239 --> 01:12:26,320
a place where there's enough critical

01:12:23,920 --> 01:12:29,440
mass where we can start having a

01:12:26,320 --> 01:12:32,560
serious conversation about

01:12:29,440 --> 01:12:33,280
do we now have enough to subset the

01:12:32,560 --> 01:12:35,440
language

01:12:33,280 --> 01:12:38,400
now be very careful with that because

01:12:35,440 --> 01:12:40,159
subset does not mean

01:12:38,400 --> 01:12:41,600
it implicitly means answering the

01:12:40,159 --> 01:12:43,040
question are you creating a fracture of

01:12:41,600 --> 01:12:43,760
the community and nobody wants to do

01:12:43,040 --> 01:12:45,440
that

01:12:43,760 --> 01:12:47,280
but if you recall beyond this talk on

01:12:45,440 --> 01:12:48,080
monday one of the points that he made

01:12:47,280 --> 01:12:51,600
especially about

01:12:48,080 --> 01:12:54,800
the core guidelines in gsl was

01:12:51,600 --> 01:12:55,199
a super a subset of a super set if we

01:12:54,800 --> 01:12:57,280
see

01:12:55,199 --> 01:12:59,120
what's missing in today's c plus plus

01:12:57,280 --> 01:13:00,400
like gsl said span was missing which has

01:12:59,120 --> 01:13:04,400
now been standardized

01:13:00,400 --> 01:13:08,000
for bound safe access to arrays okay

01:13:04,400 --> 01:13:09,600
we add a few things then when we have

01:13:08,000 --> 01:13:11,440
the union of things that has all the

01:13:09,600 --> 01:13:14,800
things we want including safety and

01:13:11,440 --> 01:13:16,400
simplicity and performance then we can

01:13:14,800 --> 01:13:17,520
have the conversation about whether to

01:13:16,400 --> 01:13:19,360
subset and say

01:13:17,520 --> 01:13:20,880
well now if you look at all the new

01:13:19,360 --> 01:13:22,719
things and

01:13:20,880 --> 01:13:26,400
for the parts of the language that they

01:13:22,719 --> 01:13:29,840
are total replacements for

01:13:26,400 --> 01:13:33,360
what about having a mode where in my

01:13:29,840 --> 01:13:36,560
cpp next file or something

01:13:33,360 --> 01:13:38,239
i only program with the new things so

01:13:36,560 --> 01:13:40,640
that's a conversation we can begin to

01:13:38,239 --> 01:13:42,719
have perhaps in the next few years

01:13:40,640 --> 01:13:44,880
in the meantime yes we're adding and

01:13:42,719 --> 01:13:46,239
making the language say 110

01:13:44,880 --> 01:13:48,080
more complex instead of a hundred

01:13:46,239 --> 01:13:51,760
percent you're adding ten percent

01:13:48,080 --> 01:13:53,520
but at least in new code i'll be able to

01:13:51,760 --> 01:13:55,600
more to use the simpler language and

01:13:53,520 --> 01:13:58,320
maybe someday we can actually say we

01:13:55,600 --> 01:14:00,239
have enough of these general things

01:13:58,320 --> 01:14:01,679
but we can actually start saying what

01:14:00,239 --> 01:14:02,320
would it look like to have a world where

01:14:01,679 --> 01:14:05,840
i program

01:14:02,320 --> 01:14:05,840
only in the new mode

01:14:06,000 --> 01:14:10,000
the next question is what about when out

01:14:08,400 --> 01:14:11,679
is optional

01:14:10,000 --> 01:14:13,440
so we have a way of saying that if there

01:14:11,679 --> 01:14:14,640
is such a thing as optional now

01:14:13,440 --> 01:14:17,199
the standard but if we want to say

01:14:14,640 --> 01:14:20,159
something in the language

01:14:17,199 --> 01:14:21,840
um so titus winters calls that maybe out

01:14:20,159 --> 01:14:22,480
that's actually discussed in the paper

01:14:21,840 --> 01:14:24,320
so please

01:14:22,480 --> 01:14:26,159
look for the string maybe out maybe

01:14:24,320 --> 01:14:27,760
underscore out i think it is

01:14:26,159 --> 01:14:30,400
in the paper and i believe i put in

01:14:27,760 --> 01:14:32,640
discussion of that but basically

01:14:30,400 --> 01:14:33,760
that's okay you can say that within out

01:14:32,640 --> 01:14:35,760
because the rule is

01:14:33,760 --> 01:14:36,960
as long as there's some path that you

01:14:35,760 --> 01:14:39,360
write to

01:14:36,960 --> 01:14:41,280
that's sufficient for in out it's for

01:14:39,360 --> 01:14:42,880
you to satisfy that you really didn't

01:14:41,280 --> 01:14:43,280
mean an in parameter because you could

01:14:42,880 --> 01:14:45,760
do an

01:14:43,280 --> 01:14:47,199
out operation but not every path is

01:14:45,760 --> 01:14:48,239
required to do that

01:14:47,199 --> 01:14:50,239
and if you want to say something

01:14:48,239 --> 01:14:51,600
stronger of the form like out of

01:14:50,239 --> 01:14:53,040
optional you can actually

01:14:51,600 --> 01:14:54,560
say that directly because you can use

01:14:53,040 --> 01:14:57,840
the type if you want if that's the

01:14:54,560 --> 01:14:59,840
semantics you want to have

01:14:57,840 --> 01:15:01,120
next question does that mean retiring or

01:14:59,840 --> 01:15:03,440
deprecating

01:15:01,120 --> 01:15:05,280
single ref double ref construct syntax

01:15:03,440 --> 01:15:07,199
or will it add to just an already fat

01:15:05,280 --> 01:15:08,480
standard well of course it would add to

01:15:07,199 --> 01:15:11,520
an already fat standard

01:15:08,480 --> 01:15:14,080
yes but this is like my answer before

01:15:11,520 --> 01:15:15,120
once we have this so one of the things i

01:15:14,080 --> 01:15:17,199
don't remember whether i say in the

01:15:15,120 --> 01:15:18,800
paper but i'll go out and say it right

01:15:17,199 --> 01:15:21,679
now

01:15:18,800 --> 01:15:23,360
i personally from what i've seen so far

01:15:21,679 --> 01:15:24,000
in the last five years working on this

01:15:23,360 --> 01:15:25,360
proposal

01:15:24,000 --> 01:15:27,679
and in conversations with others and

01:15:25,360 --> 01:15:30,400
looking at the implementation

01:15:27,679 --> 01:15:32,400
i think this is a complete replacement

01:15:30,400 --> 01:15:34,960
for today's

01:15:32,400 --> 01:15:36,880
how way of describing parameter passing

01:15:34,960 --> 01:15:40,159
that you can use only this new way

01:15:36,880 --> 01:15:41,679
in in out out moving forward and express

01:15:40,159 --> 01:15:43,040
everything just as efficiently as today

01:15:41,679 --> 01:15:45,520
and much more simply in the smaller

01:15:43,040 --> 01:15:47,600
object code

01:15:45,520 --> 01:15:49,840
so it's a complete replacement and then

01:15:47,600 --> 01:15:52,239
remember that the only reason that we

01:15:49,840 --> 01:15:55,199
added references in the standard in in

01:15:52,239 --> 01:15:58,480
the language in the first place aspiana

01:15:55,199 --> 01:15:59,360
was for parameter passing i believe i

01:15:58,480 --> 01:16:02,640
mentioned this

01:15:59,360 --> 01:16:05,040
in the 708 document i definitely

01:16:02,640 --> 01:16:07,520
mentioned this in my blog post in from

01:16:05,040 --> 01:16:10,800
february of this year february 2020

01:16:07,520 --> 01:16:13,760
look for references comma simply

01:16:10,800 --> 01:16:14,239
where i make this point in uh hopefully

01:16:13,760 --> 01:16:17,600
fairly

01:16:14,239 --> 01:16:20,880
blunt uh detail so yes

01:16:17,600 --> 01:16:22,320
actually i think that that references

01:16:20,880 --> 01:16:23,760
should only be used largely for

01:16:22,320 --> 01:16:25,360
parameter passing

01:16:23,760 --> 01:16:27,600
we shouldn't be specializing templates

01:16:25,360 --> 01:16:29,920
on reference types for sure that's just

01:16:27,600 --> 01:16:32,000
awful as for the reasons i give in the

01:16:29,920 --> 01:16:33,600
paper

01:16:32,000 --> 01:16:34,880
and since with this new style of

01:16:33,600 --> 01:16:35,520
parameter passing we don't need

01:16:34,880 --> 01:16:37,679
references

01:16:35,520 --> 01:16:39,840
yes i do believe that this is a path

01:16:37,679 --> 01:16:40,960
where we don't need references at all in

01:16:39,840 --> 01:16:43,600
c plus plus

01:16:40,960 --> 01:16:45,679
that's controversial so go ahead and

01:16:43,600 --> 01:16:47,120
start sending the the hate mail and the

01:16:45,679 --> 01:16:49,920
angry pitchforks my way

01:16:47,120 --> 01:16:51,679
i'm ready for them but this is the kind

01:16:49,920 --> 01:16:54,480
of thing we have to think about

01:16:51,679 --> 01:16:56,320
if we are really going to be serious

01:16:54,480 --> 01:16:59,520
about simplifying c plus loss

01:16:56,320 --> 01:17:00,159
and not just moan about it every year on

01:16:59,520 --> 01:17:02,400
reddit

01:17:00,159 --> 01:17:03,679
and not just talk about it and then whoa

01:17:02,400 --> 01:17:05,440
how bad things are

01:17:03,679 --> 01:17:07,520
if we are going to be serious about

01:17:05,440 --> 01:17:09,600
simplifying c-class plus

01:17:07,520 --> 01:17:11,199
we should be looking for abstractions

01:17:09,600 --> 01:17:12,400
that directly express the intent of

01:17:11,199 --> 01:17:14,080
things we already do

01:17:12,400 --> 01:17:15,600
bake them the important things into the

01:17:14,080 --> 01:17:17,520
language so that they're automated

01:17:15,600 --> 01:17:20,800
instead of ad hoc

01:17:17,520 --> 01:17:21,040
and that as a result make other parts of

01:17:20,800 --> 01:17:23,040
c

01:17:21,040 --> 01:17:24,880
plus plus no longer needed and then we

01:17:23,040 --> 01:17:26,000
can have a discussion about having a

01:17:24,880 --> 01:17:29,199
subset that's

01:17:26,000 --> 01:17:30,800
as bjorn has said really is about ten

01:17:29,199 --> 01:17:33,760
percent the size of today's c

01:17:30,800 --> 01:17:35,120
plus plus and yes this is intentional

01:17:33,760 --> 01:17:36,719
it's why i've been working on these

01:17:35,120 --> 01:17:38,480
things in this way for the last five

01:17:36,719 --> 01:17:40,400
years

01:17:38,480 --> 01:17:42,159
what happens with unused parameters for

01:17:40,400 --> 01:17:44,159
example in an abstract based class i'm

01:17:42,159 --> 01:17:45,679
not sure exactly what you mean

01:17:44,159 --> 01:17:47,520
but unused parameters should work the

01:17:45,679 --> 01:17:49,440
same way if you

01:17:47,520 --> 01:17:50,800
if you declare a parameter and then

01:17:49,440 --> 01:17:52,239
parameter and don't read from it for

01:17:50,800 --> 01:17:53,520
example that's fine

01:17:52,239 --> 01:17:55,840
perhaps that's the kind of thing you

01:17:53,520 --> 01:17:57,360
have in mind of course if you declare an

01:17:55,840 --> 01:17:58,159
in-out parameter and don't write to it

01:17:57,360 --> 01:18:00,400
on any path

01:17:58,159 --> 01:18:01,920
then you would get an error and you may

01:18:00,400 --> 01:18:03,520
need to suppress that

01:18:01,920 --> 01:18:05,280
in order to say no i really didn't

01:18:03,520 --> 01:18:06,560
intend that which i think is a fair

01:18:05,280 --> 01:18:08,320
thing to do i think it's fine

01:18:06,560 --> 01:18:10,320
for people to be able to write something

01:18:08,320 --> 01:18:12,000
like attribute suppress

01:18:10,320 --> 01:18:14,560
this error to say no i really didn't

01:18:12,000 --> 01:18:17,120
mean it and deliberately opt out of a

01:18:14,560 --> 01:18:19,520
language rule or a static analyzer rule

01:18:17,120 --> 01:18:20,480
that's why the the c plus core

01:18:19,520 --> 01:18:23,920
guidelines do that

01:18:20,480 --> 01:18:26,080
in the gsl is we have the suppress

01:18:23,920 --> 01:18:28,000
for no i really mean to do this that way

01:18:26,080 --> 01:18:29,920
you can express anything you want

01:18:28,000 --> 01:18:31,280
and you can go outside the guardrails if

01:18:29,920 --> 01:18:32,960
you need to

01:18:31,280 --> 01:18:34,719
but now you can grab your code for the

01:18:32,960 --> 01:18:36,480
places you said trust me

01:18:34,719 --> 01:18:37,840
when there is a problem later and you

01:18:36,480 --> 01:18:39,440
can have a better time

01:18:37,840 --> 01:18:42,000
finding out okay here are the places i

01:18:39,440 --> 01:18:44,000
told the language not to help me

01:18:42,000 --> 01:18:46,400
and therefore those are the places i'll

01:18:44,000 --> 01:18:50,960
look first

01:18:46,400 --> 01:18:50,960
let's take one more question

01:18:51,600 --> 01:18:57,760
let's see i'll take this one

01:18:55,679 --> 01:18:58,800
with the uninitialized approach does the

01:18:57,760 --> 01:19:00,719
assignment now

01:18:58,800 --> 01:19:02,239
get all the problems of initialization

01:19:00,719 --> 01:19:03,040
think about the chaos of initializing a

01:19:02,239 --> 01:19:05,120
vector

01:19:03,040 --> 01:19:06,880
i think so so we'll have to see with

01:19:05,120 --> 01:19:09,520
with a usage case

01:19:06,880 --> 01:19:11,040
use cases but i believe by taking the

01:19:09,520 --> 01:19:11,840
definite assignment rules that we

01:19:11,040 --> 01:19:13,920
already have

01:19:11,840 --> 01:19:15,840
in ada and c-sharp in other languages

01:19:13,920 --> 01:19:17,840
where we've shown they work

01:19:15,840 --> 01:19:19,440
applying those to c plus plus and

01:19:17,840 --> 01:19:21,360
especially you need out parameters to do

01:19:19,440 --> 01:19:22,880
that you can't do it easily today you

01:19:21,360 --> 01:19:24,159
need out parameters

01:19:22,880 --> 01:19:26,480
so that you can then delegate

01:19:24,159 --> 01:19:28,080
construction to a callee

01:19:26,480 --> 01:19:29,520
the classic example why you need out

01:19:28,080 --> 01:19:30,159
parameters if anybody tells you you

01:19:29,520 --> 01:19:32,960
don't

01:19:30,159 --> 01:19:33,760
say how do you write get next chunk

01:19:32,960 --> 01:19:37,440
there's your

01:19:33,760 --> 01:19:40,000
your poster child example

01:19:37,440 --> 01:19:42,159
then yes you'll be able to address all

01:19:40,000 --> 01:19:44,080
the initialization issues i know of

01:19:42,159 --> 01:19:45,679
because you will be able to actually

01:19:44,080 --> 01:19:48,719
require in it

01:19:45,679 --> 01:19:51,600
before use you must construct an object

01:19:48,719 --> 01:19:52,560
before or right to say an end before you

01:19:51,600 --> 01:19:54,480
read from it

01:19:52,560 --> 01:19:56,880
and by saying you can do that separately

01:19:54,480 --> 01:19:59,600
from the declaration for local variables

01:19:56,880 --> 01:20:02,480
it lets you also say you can wait until

01:19:59,600 --> 01:20:03,920
you have a program meaningful value

01:20:02,480 --> 01:20:05,440
which most of the time you have at the

01:20:03,920 --> 01:20:06,880
time you declare the variable but

01:20:05,440 --> 01:20:10,400
sometimes you don't

01:20:06,880 --> 01:20:12,719
like get next chunk or filler a

01:20:10,400 --> 01:20:13,440
and for those cases which are common

01:20:12,719 --> 01:20:15,520
when you call c

01:20:13,440 --> 01:20:16,560
libraries for example and for those

01:20:15,520 --> 01:20:19,040
cases

01:20:16,560 --> 01:20:21,120
you will now be able to still get solid

01:20:19,040 --> 01:20:23,120
guarantees of initialization in it

01:20:21,120 --> 01:20:25,440
before use

01:20:23,120 --> 01:20:27,120
even when you're using those kinds of

01:20:25,440 --> 01:20:28,880
apis

01:20:27,120 --> 01:20:32,000
so thank you very much again for coming

01:20:28,880 --> 01:20:33,520
to this talk to cppcon in general

01:20:32,000 --> 01:20:35,120
it please stay here for a few more

01:20:33,520 --> 01:20:37,600
minutes and listen to the band

01:20:35,120 --> 01:20:39,440
or go to the set the session that's

01:20:37,600 --> 01:20:41,920
going to be taking place on zoom now

01:20:39,440 --> 01:20:43,679
for looking at cppcon 2021 to give any

01:20:41,920 --> 01:20:45,440
feedback you have about this week

01:20:43,679 --> 01:20:47,520
and if you are interested in being part

01:20:45,440 --> 01:20:48,880
of planning or maybe helping or at least

01:20:47,520 --> 01:20:51,120
being a fly on the wall

01:20:48,880 --> 01:20:53,040
for next year's event thank you again

01:20:51,120 --> 01:20:55,360
for coming right here we'll continue

01:20:53,040 --> 01:20:56,800
with the band safe travels back home

01:20:55,360 --> 01:20:58,960
which for many of you will be to your

01:20:56,800 --> 01:21:01,520
kitchens or bedrooms in your same house

01:20:58,960 --> 01:21:02,320
and may we all be safe until we meet

01:21:01,520 --> 01:21:15,840
again

01:21:02,320 --> 01:21:15,840
thank you

01:21:23,120 --> 01:21:25,199

YouTube URL: https://www.youtube.com/watch?v=6lurOCdaj0Y


