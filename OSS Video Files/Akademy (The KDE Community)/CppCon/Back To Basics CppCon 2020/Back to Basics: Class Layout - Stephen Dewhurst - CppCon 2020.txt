Title: Back to Basics: Class Layout - Stephen Dewhurst - CppCon 2020
Publication date: 2020-11-06
Playlist: Back To Basics CppCon 2020
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/back_to_basics_class_layout/back_to_basics_class_layout__steve_dewhurst__cppcon_2020.pdf
---
In C++, as in many other languages, classes are the key feature that supports data abstraction. A C++ class is essentially a C structure, but with added capabilities that support object-oriented programming as well as better type safety, resource management, and usability.

Although some of these added capabilities require additional storage allocation or run-time support, most do not. Thus, the storage layout for a C++ class can be as simple as the layout for a C structure. Unfortunately, too many programmers imagine that classes incur space and speed penalties that simply aren’t there.

This session offers a practical look “under the hood” to see how compilers typically implement the storage layout and member access for C++ classes. It also explains how compilers typically implement member function calls. You’ll come away with a better sense of what using classes actually costs in speed and space. You’ll gain insights that will help you with a variety of programming tasks, including debugging, performance tuning, and working with objects that have rigid layout requirements.

---
Steve Dewhurst is the co-founder and president of Semantics Consulting, Inc. Steve is the author of numerous technical articles on C++ programming techniques and compiler design, is the author of the critically acclaimed books C++ Common Knowledge and C++ Gotchas, and is the co-author of Programming in C++. He is a frequent speaker at industry conferences, where his presentations are consistently among the most popular and highest rated. He is also a member of the advisory board for The C++ Source, was programming track chair for the Embedded Systems Conference (ESC), and was a visiting scientist at the Software Engineering Institute (SEI) at Carnegie Mellon University. Steve has mentored and consulted with C++ projects ranging in size from 1 to over 100 developers, in areas ranging from compiler design to embedded telecommunications to ecommerce to derivative securities trading. As a Member of Technical Staff in the UNIX Development Laboratory at AT&T Bell Laboratories, Steve worked with Bjarne Stroustrup, the designer and first implementer of C++, on the first public release of the language and cfront C++ compiler, then served as the lead designer and implementer of the first non-cfront C++ compiler. As a compiler architect at Glockenspiel, Ltd., he designed and implemented a second C++ compiler. Steve was a contributing editor for The C/C++ User's Journal, a principal lecturer at The C++ Seminar, has served as a principal on the ANSI/ISO C++ standardization committee, was the C++ training series adviser for Technology Exchange Company (Addison-Wesley), was a member of the editorial board of and columnist for C++ Report, co-founder and member of the editorial board of The C++ Journal, and a Visiting Professor of Computer Science at Jackson State University. He has also written C, COBOL, and Pascal compilers, was a principal on the ANSI/IEEE Pascal Standardization Committee, and a reviewer for ACM Computing Reviews. Semantics Consulting, Inc. is located in the small New England town of Carver, Massachusetts. Like all small New England towns, Carver has a tradition of citizen involvement, and over the years Steve has been astonished to find himself harvesting cranberries, coaching the high school wrestling team, and serving on the town water commission, finance committee, and website committee.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,639 --> 00:00:12,639
well

00:00:09,040 --> 00:00:14,799
um hello everyone welcome to my garage

00:00:12,639 --> 00:00:15,679
um today we're talking about class

00:00:14,799 --> 00:00:17,440
layout

00:00:15,679 --> 00:00:19,199
it sounds like one of those things that

00:00:17,440 --> 00:00:19,760
you have to know but really don't want

00:00:19,199 --> 00:00:21,600
to

00:00:19,760 --> 00:00:23,760
it's kind of like tax law or something

00:00:21,600 --> 00:00:26,000
like that something that's useful but

00:00:23,760 --> 00:00:29,199
it's probably not that interesting

00:00:26,000 --> 00:00:30,400
um and when i started writing this talk

00:00:29,199 --> 00:00:31,840
i thought it was going to be short i

00:00:30,400 --> 00:00:33,280
thought you know maybe three or four

00:00:31,840 --> 00:00:35,280
slides would do it

00:00:33,280 --> 00:00:36,640
and as a result i have a more than 100

00:00:35,280 --> 00:00:39,280
slides here for you

00:00:36,640 --> 00:00:40,399
not all of which we'll get to so i'm not

00:00:39,280 --> 00:00:46,160
going to waste any

00:00:40,399 --> 00:00:46,160
time and i'll head right into it um

00:00:47,039 --> 00:00:49,920
why do we care about class layout well

00:00:48,800 --> 00:00:50,719
there are a lot of reasons one is

00:00:49,920 --> 00:00:53,600
efficiency

00:00:50,719 --> 00:00:54,960
one is we may write our algorithms our

00:00:53,600 --> 00:00:58,079
implementations of algorithms

00:00:54,960 --> 00:00:59,760
with a certain format in mind and if

00:00:58,079 --> 00:01:01,199
you're not aware of class layout issues

00:00:59,760 --> 00:01:03,120
you can actually write code that will

00:01:01,199 --> 00:01:03,840
work almost all the time and then will

00:01:03,120 --> 00:01:06,479
fail

00:01:03,840 --> 00:01:08,080
in spectacular ways at odd times in the

00:01:06,479 --> 00:01:09,119
future

00:01:08,080 --> 00:01:11,280
another reason you might care about

00:01:09,119 --> 00:01:13,119
class layout is if you're

00:01:11,280 --> 00:01:14,720
writing code for hardware you're using

00:01:13,119 --> 00:01:16,159
memory map devices

00:01:14,720 --> 00:01:18,159
and of course the layout of those

00:01:16,159 --> 00:01:19,680
classes has to correspond to the actual

00:01:18,159 --> 00:01:21,520
hardware it's being mapped to

00:01:19,680 --> 00:01:22,720
so it turns out to be quite an important

00:01:21,520 --> 00:01:26,479
area

00:01:22,720 --> 00:01:28,799
and of course c plus plus uh

00:01:26,479 --> 00:01:30,560
in its wisdom can take a simple area

00:01:28,799 --> 00:01:32,960
like that and make it

00:01:30,560 --> 00:01:34,640
somewhat complex so let's look at a very

00:01:32,960 --> 00:01:36,640
very simple class here's your human

00:01:34,640 --> 00:01:38,400
resources department

00:01:36,640 --> 00:01:40,000
they have a scary looking function

00:01:38,400 --> 00:01:41,439
called terminator

00:01:40,000 --> 00:01:43,119
it takes pointers to different types of

00:01:41,439 --> 00:01:44,799
employees

00:01:43,119 --> 00:01:46,560
and the implementation contains this

00:01:44,799 --> 00:01:49,439
enum

00:01:46,560 --> 00:01:50,640
a static data member and then some

00:01:49,439 --> 00:01:53,920
non-static

00:01:50,640 --> 00:01:54,240
data so how is this actually laid out

00:01:53,920 --> 00:01:56,320
what

00:01:54,240 --> 00:01:57,439
what occupy space in the class well it's

00:01:56,320 --> 00:02:00,799
pretty much the same thing

00:01:57,439 --> 00:02:03,040
as this c implementation

00:02:00,799 --> 00:02:04,880
uh in c actually the enum is at the same

00:02:03,040 --> 00:02:06,000
scope as the struct it's pulled out of

00:02:04,880 --> 00:02:09,200
the struct

00:02:06,000 --> 00:02:11,200
um but the static data member is

00:02:09,200 --> 00:02:12,319
has static lifetime and external linkage

00:02:11,200 --> 00:02:13,120
so it's pretty much the same

00:02:12,319 --> 00:02:17,040
implementation

00:02:13,120 --> 00:02:18,959
as a global variable um

00:02:17,040 --> 00:02:21,200
although it is in the scope of the class

00:02:18,959 --> 00:02:24,800
so the only

00:02:21,200 --> 00:02:26,080
members that cause the layout of the

00:02:24,800 --> 00:02:27,840
class to be affected are these

00:02:26,080 --> 00:02:30,160
non-static data members

00:02:27,840 --> 00:02:30,959
and of course storage for non-stat for

00:02:30,160 --> 00:02:34,400
non-virtual

00:02:30,959 --> 00:02:37,599
member functions um

00:02:34,400 --> 00:02:39,360
does not affect class layout either and

00:02:37,599 --> 00:02:41,040
the reason for that of course is they

00:02:39,360 --> 00:02:43,360
are implemented typically

00:02:41,040 --> 00:02:44,480
as in the same way that a regular member

00:02:43,360 --> 00:02:47,519
function would be

00:02:44,480 --> 00:02:50,879
but let's talk a little bit about them

00:02:47,519 --> 00:02:53,440
um i mentioned that uh

00:02:50,879 --> 00:02:54,480
i've been writing some embedded c plus

00:02:53,440 --> 00:02:56,480
plus code

00:02:54,480 --> 00:02:58,159
to to bare metal you know hardware that

00:02:56,480 --> 00:03:00,400
has no operating system whatever c

00:02:58,159 --> 00:03:02,720
plus is terrific for writing to bare

00:03:00,400 --> 00:03:02,720
metal

00:03:02,840 --> 00:03:07,920
um but

00:03:04,720 --> 00:03:10,239
the only negative is that a lot of

00:03:07,920 --> 00:03:11,680
uh people who work in that area don't

00:03:10,239 --> 00:03:13,040
trust c plus plus

00:03:11,680 --> 00:03:14,319
they're afraid it's going to bulk up

00:03:13,040 --> 00:03:14,959
their programs it's going to be hard to

00:03:14,319 --> 00:03:17,920
write

00:03:14,959 --> 00:03:19,840
efficient code as it turns out c plus is

00:03:17,920 --> 00:03:21,840
much easier to use to write very very

00:03:19,840 --> 00:03:24,080
efficient code for embedded systems

00:03:21,840 --> 00:03:25,519
but it is indeed more complex than c or

00:03:24,080 --> 00:03:26,560
perhaps some other language you might be

00:03:25,519 --> 00:03:28,720
using

00:03:26,560 --> 00:03:30,319
and so when you see simple code like

00:03:28,720 --> 00:03:31,840
this i'm calling a function called

00:03:30,319 --> 00:03:33,760
terminator that simply fires three

00:03:31,840 --> 00:03:38,720
people in different ways

00:03:33,760 --> 00:03:40,959
um i know i should find a better example

00:03:38,720 --> 00:03:42,159
um people worry well what's the overhead

00:03:40,959 --> 00:03:43,760
for doing this

00:03:42,159 --> 00:03:45,280
and why why shouldn't i just write a

00:03:43,760 --> 00:03:48,400
regular old

00:03:45,280 --> 00:03:51,360
non-member function like this

00:03:48,400 --> 00:03:52,879
and pass a pointer to the hr object to

00:03:51,360 --> 00:03:54,000
these various functions i'm invoking

00:03:52,879 --> 00:03:56,000
here

00:03:54,000 --> 00:03:57,360
well you could but then you're losing

00:03:56,000 --> 00:03:58,799
out an encapsulation and all those other

00:03:57,360 --> 00:04:01,519
nice language features

00:03:58,799 --> 00:04:03,200
and a point of fact if i compile these

00:04:01,519 --> 00:04:04,959
two different functions

00:04:03,200 --> 00:04:06,400
this being the member function and this

00:04:04,959 --> 00:04:08,799
being a non-member function

00:04:06,400 --> 00:04:11,040
they generate precisely the same code

00:04:08,799 --> 00:04:12,080
exactly the same code up to the names of

00:04:11,040 --> 00:04:13,840
the functions

00:04:12,080 --> 00:04:15,280
this function of course is in the scope

00:04:13,840 --> 00:04:18,560
of the hr class

00:04:15,280 --> 00:04:21,040
this one is not uh and so

00:04:18,560 --> 00:04:21,040
this is the

00:04:24,080 --> 00:04:28,000
well i don't know about you but i'm

00:04:26,639 --> 00:04:29,840
tired of seeing x86 code

00:04:28,000 --> 00:04:31,759
all the time so i'm using arm assembly

00:04:29,840 --> 00:04:32,479
here i find it much easier to read and

00:04:31,759 --> 00:04:33,840
deal with

00:04:32,479 --> 00:04:35,680
but the point is we get the same

00:04:33,840 --> 00:04:38,160
behavior there's no no penalty

00:04:35,680 --> 00:04:41,199
whatsoever

00:04:38,160 --> 00:04:42,720
okay so getting back to class layout

00:04:41,199 --> 00:04:45,040
what about the layout of these

00:04:42,720 --> 00:04:47,280
non-static data members

00:04:45,040 --> 00:04:48,960
and so here i've unnecessarily had some

00:04:47,280 --> 00:04:49,360
public followed by private followed by

00:04:48,960 --> 00:04:52,000
public

00:04:49,360 --> 00:04:54,320
followed by private members so how could

00:04:52,000 --> 00:04:57,919
these be laid out

00:04:54,320 --> 00:05:00,960
well in traditional c plus plus

00:04:57,919 --> 00:05:04,639
basically we were told and

00:05:00,960 --> 00:05:06,240
it was the case that the only guarantee

00:05:04,639 --> 00:05:10,560
we had

00:05:06,240 --> 00:05:14,080
is that non-static data members

00:05:10,560 --> 00:05:15,919
in the same section this public section

00:05:14,080 --> 00:05:17,440
would be laid out in increasing

00:05:15,919 --> 00:05:20,880
addresses so we know that b

00:05:17,440 --> 00:05:23,600
would follow a we know that d

00:05:20,880 --> 00:05:24,320
would follow c but any other any other

00:05:23,600 --> 00:05:26,800
ordering

00:05:24,320 --> 00:05:28,479
was quite legal so you could even though

00:05:26,800 --> 00:05:30,800
most compilers didn't do any reordering

00:05:28,479 --> 00:05:32,639
whatsoever

00:05:30,800 --> 00:05:34,960
a traditional c plus plus compiler could

00:05:32,639 --> 00:05:36,880
produce these two orderings

00:05:34,960 --> 00:05:38,080
which as it turns out are no longer

00:05:36,880 --> 00:05:42,400
legal in

00:05:38,080 --> 00:05:44,240
modern c plus plus in modern c plus plus

00:05:42,400 --> 00:05:45,600
we have a different guarantee it sounds

00:05:44,240 --> 00:05:47,759
similar but is

00:05:45,600 --> 00:05:49,199
quite significantly different that

00:05:47,759 --> 00:05:51,520
members with the same

00:05:49,199 --> 00:05:54,000
access have to be laid out in the same

00:05:51,520 --> 00:05:56,240
relative order

00:05:54,000 --> 00:05:57,360
so in this case there's no reordering

00:05:56,240 --> 00:05:59,759
this is correct

00:05:57,360 --> 00:06:00,560
a b and c were declared lexically in

00:05:59,759 --> 00:06:02,000
that order

00:06:00,560 --> 00:06:03,759
and their layout has to be in the same

00:06:02,000 --> 00:06:05,759
order

00:06:03,759 --> 00:06:07,360
but they could be reordered like this

00:06:05,759 --> 00:06:08,720
maybe have all the public data members

00:06:07,360 --> 00:06:10,880
first followed by the private

00:06:08,720 --> 00:06:11,759
or maybe have some sort of random

00:06:10,880 --> 00:06:13,600
ordering like this

00:06:11,759 --> 00:06:15,759
or have all the private members first

00:06:13,600 --> 00:06:17,680
followed by the public members

00:06:15,759 --> 00:06:19,360
um i did see somebody hack a compiler

00:06:17,680 --> 00:06:22,800
wants to do this

00:06:19,360 --> 00:06:24,160
and it was legal and

00:06:22,800 --> 00:06:25,840
it was done to do object level

00:06:24,160 --> 00:06:26,880
protection instead of type level

00:06:25,840 --> 00:06:30,080
protection

00:06:26,880 --> 00:06:32,800
so there is some variability in the

00:06:30,080 --> 00:06:36,479
possible layouts of your class

00:06:32,800 --> 00:06:38,479
well what about base classes well

00:06:36,479 --> 00:06:40,080
that's unspecified the order in which

00:06:38,479 --> 00:06:42,240
the base class sub-objects

00:06:40,080 --> 00:06:44,000
are laid out is completely unspecified

00:06:42,240 --> 00:06:45,600
it's typical that they're simply laid

00:06:44,000 --> 00:06:47,360
out in the order they appear on the base

00:06:45,600 --> 00:06:51,120
class list

00:06:47,360 --> 00:06:52,479
but in this case i do we do see

00:06:51,120 --> 00:06:54,080
different compilers behaving in

00:06:52,479 --> 00:06:55,599
different ways when they're trying to

00:06:54,080 --> 00:06:57,360
optimize storage use

00:06:55,599 --> 00:06:59,599
sometimes the compiler will permute the

00:06:57,360 --> 00:07:01,199
order of the base classes in storage

00:06:59,599 --> 00:07:03,840
in order to shrink the size of the

00:07:01,199 --> 00:07:03,840
object

00:07:06,240 --> 00:07:09,759
okay hope everybody's still with me

00:07:10,000 --> 00:07:16,080
so empty-based class members well

00:07:13,599 --> 00:07:18,000
we often have stateless objects you

00:07:16,080 --> 00:07:21,039
might have a closure

00:07:18,000 --> 00:07:22,400
of a lambda expression that has no data

00:07:21,039 --> 00:07:25,759
it doesn't do any captures

00:07:22,400 --> 00:07:27,919
it has no state types

00:07:25,759 --> 00:07:30,160
or objects can be stateless as well for

00:07:27,919 --> 00:07:32,960
example this empty class

00:07:30,160 --> 00:07:34,160
is a stateless class and this empty e is

00:07:32,960 --> 00:07:37,360
a stateless object

00:07:34,160 --> 00:07:40,639
nevertheless every object has to have

00:07:37,360 --> 00:07:44,479
some size the likely size of

00:07:40,639 --> 00:07:45,840
these two queries is probably one

00:07:44,479 --> 00:07:48,000
it might be four it might be some

00:07:45,840 --> 00:07:50,479
minimal size if there's an alignment

00:07:48,000 --> 00:07:52,720
requirement on this architecture

00:07:50,479 --> 00:07:54,400
but again even if i have three empty

00:07:52,720 --> 00:07:56,560
objects

00:07:54,400 --> 00:07:59,360
each of them will occupy at least one

00:07:56,560 --> 00:08:02,560
byte and so the size of this class

00:07:59,360 --> 00:08:02,560
is probably three bytes

00:08:03,280 --> 00:08:08,800
that's dispiriting but in c plus plus 20

00:08:07,280 --> 00:08:10,639
we're all looking forward to c plus plus

00:08:08,800 --> 00:08:12,479
20.

00:08:10,639 --> 00:08:14,080
we have an attribute called no unique

00:08:12,479 --> 00:08:17,840
address that

00:08:14,080 --> 00:08:20,240
allows a compiler to have these

00:08:17,840 --> 00:08:22,240
three data members share storage space

00:08:20,240 --> 00:08:25,120
so the size of this

00:08:22,240 --> 00:08:26,639
class object is now likely to be one if

00:08:25,120 --> 00:08:28,400
the compiler does

00:08:26,639 --> 00:08:32,800
collapse these three members into a

00:08:28,400 --> 00:08:32,800
single a single address location

00:08:33,200 --> 00:08:36,560
okay so that's that's a nice thing to

00:08:34,399 --> 00:08:39,599
look forward to this is actually great

00:08:36,560 --> 00:08:40,000
um if you've ever you know in your spare

00:08:39,599 --> 00:08:41,599
time

00:08:40,000 --> 00:08:43,039
looked at implementations of stl

00:08:41,599 --> 00:08:45,360
containers

00:08:43,039 --> 00:08:47,120
a lot of times a container is

00:08:45,360 --> 00:08:48,720
parameterized by things like in this

00:08:47,120 --> 00:08:49,839
case here we have a hash map of some

00:08:48,720 --> 00:08:52,480
sort

00:08:49,839 --> 00:08:54,800
um and again i stole this from the

00:08:52,480 --> 00:08:58,399
working draft for c plus plus 20.

00:08:54,800 --> 00:09:00,640
um sorry i borrowed it i leveraged it i

00:08:58,399 --> 00:09:04,399
don't know what the correct term is

00:09:00,640 --> 00:09:05,760
we often have parameterizations of these

00:09:04,399 --> 00:09:09,839
classes

00:09:05,760 --> 00:09:11,440
by stateless typically lambda functions

00:09:09,839 --> 00:09:13,519
or function objects

00:09:11,440 --> 00:09:14,880
like this hash function a predicate for

00:09:13,519 --> 00:09:17,040
comparing

00:09:14,880 --> 00:09:18,880
things in the hashmap and an allocator

00:09:17,040 --> 00:09:21,519
these are often stateless

00:09:18,880 --> 00:09:22,000
and in the past if you looked at a

00:09:21,519 --> 00:09:24,160
really high

00:09:22,000 --> 00:09:25,360
quality stl implementation you'd see

00:09:24,160 --> 00:09:27,040
some incredible

00:09:25,360 --> 00:09:29,440
template meta programming going on

00:09:27,040 --> 00:09:32,240
asking if this is stateless

00:09:29,440 --> 00:09:34,720
i'm instead of having a data member i'm

00:09:32,240 --> 00:09:36,880
going to have a base class

00:09:34,720 --> 00:09:38,959
of that type in order to potentially get

00:09:36,880 --> 00:09:40,720
the empty base class optimization

00:09:38,959 --> 00:09:42,000
so you'd see all this very very

00:09:40,720 --> 00:09:46,000
fine-grained

00:09:42,000 --> 00:09:46,720
uh complex code in place to shrink the

00:09:46,000 --> 00:09:50,000
size

00:09:46,720 --> 00:09:52,480
of these various typically stateless

00:09:50,000 --> 00:09:53,600
function objects well now we can simply

00:09:52,480 --> 00:09:56,640
say what we mean

00:09:53,600 --> 00:09:58,240
we can say this thing uh doesn't isn't

00:09:56,640 --> 00:09:59,839
required to have a unique address so

00:09:58,240 --> 00:10:01,600
that if this is an empty type

00:09:59,839 --> 00:10:05,839
it may share space with these other

00:10:01,600 --> 00:10:05,839
empty types as well

00:10:06,079 --> 00:10:09,920
that's nice have you noticed that c plus

00:10:08,160 --> 00:10:12,079
plus is getting easier and easier to

00:10:09,920 --> 00:10:13,440
program in over time

00:10:12,079 --> 00:10:15,279
we used to have to be actually really

00:10:13,440 --> 00:10:15,839
intelligent to write good c plus plus

00:10:15,279 --> 00:10:18,240
code

00:10:15,839 --> 00:10:19,279
and now you can kind of just i'm just

00:10:18,240 --> 00:10:22,399
kidding guys

00:10:19,279 --> 00:10:25,200
uh now it's a lot easier to take care of

00:10:22,399 --> 00:10:25,200
things like that

00:10:25,279 --> 00:10:28,880
but going back to the empty base class

00:10:27,120 --> 00:10:33,680
optimization

00:10:28,880 --> 00:10:34,800
um again a lot of times base classes are

00:10:33,680 --> 00:10:37,920
stateless

00:10:34,800 --> 00:10:39,120
they're just a bunch of type defs static

00:10:37,920 --> 00:10:42,079
members

00:10:39,120 --> 00:10:43,680
member functions whatever that don't

00:10:42,079 --> 00:10:44,320
actually occupy any space inside the

00:10:43,680 --> 00:10:46,480
class

00:10:44,320 --> 00:10:49,519
and so the point of this optimization is

00:10:46,480 --> 00:10:52,560
to allow the compiler to do precisely

00:10:49,519 --> 00:10:55,040
what the no unique address

00:10:52,560 --> 00:10:56,240
attribute does it says this base class

00:10:55,040 --> 00:10:59,360
can share space

00:10:56,240 --> 00:11:02,800
with other base classes

00:10:59,360 --> 00:11:04,240
so uh different compilers

00:11:02,800 --> 00:11:06,480
have different levels of success with

00:11:04,240 --> 00:11:06,480
this

00:11:08,320 --> 00:11:11,519
just just a minor point i mean who if

00:11:10,880 --> 00:11:15,839
you go back

00:11:11,519 --> 00:11:15,839
and look at this let's go back a few

00:11:16,640 --> 00:11:19,040
slides

00:11:21,279 --> 00:11:26,000
i got lost here we are what's so

00:11:24,079 --> 00:11:29,279
important about saving three bytes

00:11:26,000 --> 00:11:31,839
well it might be eight bytes it might be

00:11:29,279 --> 00:11:32,800
i don't know some uh some fair number of

00:11:31,839 --> 00:11:36,079
bytes

00:11:32,800 --> 00:11:36,079
the point is that most of these

00:11:36,480 --> 00:11:40,320
containers have

00:11:39,140 --> 00:11:42,240
[Music]

00:11:40,320 --> 00:11:44,000
used what's known as a handle body idiom

00:11:42,240 --> 00:11:47,040
or a pimple idiom or

00:11:44,000 --> 00:11:50,240
a bridge pattern to implement themselves

00:11:47,040 --> 00:11:52,399
we have a a small handle that points off

00:11:50,240 --> 00:11:56,560
to some potentially large implementation

00:11:52,399 --> 00:12:00,079
i don't know maybe this is a map

00:11:56,560 --> 00:12:01,680
so this is a a balanced binary tree um

00:12:00,079 --> 00:12:03,360
the thing is that we in modern c plus

00:12:01,680 --> 00:12:05,040
plus we're often uh

00:12:03,360 --> 00:12:06,959
using the return value optimization to

00:12:05,040 --> 00:12:08,320
return containers if we can't do a

00:12:06,959 --> 00:12:10,000
return value optimization

00:12:08,320 --> 00:12:12,320
the backup strategy is to try to do a

00:12:10,000 --> 00:12:13,040
move well if i want to move this

00:12:12,320 --> 00:12:15,440
enormous

00:12:13,040 --> 00:12:16,959
data structure if i want to return it

00:12:15,440 --> 00:12:18,720
from a function and i can't use the

00:12:16,959 --> 00:12:20,240
return value optimization for one reason

00:12:18,720 --> 00:12:23,279
or another

00:12:20,240 --> 00:12:24,639
if this is a really small handle if i

00:12:23,279 --> 00:12:27,600
can shrink it

00:12:24,639 --> 00:12:29,839
down to place maybe 16 bytes or so i can

00:12:27,600 --> 00:12:33,120
just return this in a pair of registers

00:12:29,839 --> 00:12:35,200
and overwrite this other handle

00:12:33,120 --> 00:12:37,120
and do a move operation so shrinking

00:12:35,200 --> 00:12:39,040
these these handle classes is a

00:12:37,120 --> 00:12:39,440
paramount importance if you're trying to

00:12:39,040 --> 00:12:41,839
have

00:12:39,440 --> 00:12:45,200
very very efficient copying and

00:12:41,839 --> 00:12:45,200
returning of these containers

00:12:46,240 --> 00:12:48,560
oops

00:12:50,720 --> 00:12:53,519
okay so this does turn out to be

00:12:51,839 --> 00:12:54,079
important and we would go to great

00:12:53,519 --> 00:12:57,920
lengths

00:12:54,079 --> 00:12:59,920
to uh to try to use this empty base

00:12:57,920 --> 00:13:03,360
class optimization

00:12:59,920 --> 00:13:04,880
um so

00:13:03,360 --> 00:13:08,720
without the optimization we may see

00:13:04,880 --> 00:13:08,720
something like this many compilers

00:13:08,880 --> 00:13:12,399
well compilers are increasingly doing

00:13:11,279 --> 00:13:14,240
better at this

00:13:12,399 --> 00:13:15,760
but historically a lot of compilers

00:13:14,240 --> 00:13:18,880
would only optimize

00:13:15,760 --> 00:13:21,360
the first base class if it was empty

00:13:18,880 --> 00:13:22,320
so by having a non-empty base class

00:13:21,360 --> 00:13:23,920
sub-object first

00:13:22,320 --> 00:13:25,519
followed by an empty one would give us

00:13:23,920 --> 00:13:27,600
no improvement this would this

00:13:25,519 --> 00:13:29,040
sub-object would still occupy space

00:13:27,600 --> 00:13:31,040
so we would sometimes do things like

00:13:29,040 --> 00:13:32,240
permute the base classes so the empty

00:13:31,040 --> 00:13:34,000
one was first

00:13:32,240 --> 00:13:35,839
so it would be it would it could share

00:13:34,000 --> 00:13:39,120
space with this non-empty

00:13:35,839 --> 00:13:40,720
and just looking at um various compilers

00:13:39,120 --> 00:13:42,639
in preparing this talk i noticed that

00:13:40,720 --> 00:13:49,440
there is still a large

00:13:42,639 --> 00:13:51,040
variety of of

00:13:49,440 --> 00:13:52,959
levels of ability to apply this

00:13:51,040 --> 00:13:54,800
optimization it varies quite widely

00:13:52,959 --> 00:13:58,000
among compilers

00:13:54,800 --> 00:14:00,639
um compilers are allowed to compress out

00:13:58,000 --> 00:14:00,639
a sequence

00:14:00,839 --> 00:14:06,000
of of empty optimizations

00:14:04,160 --> 00:14:08,160
some compilers even do a very aggressive

00:14:06,000 --> 00:14:11,600
optimization in one case

00:14:08,160 --> 00:14:14,320
one compiler uh actually moved

00:14:11,600 --> 00:14:14,800
the the storage for empty up to the

00:14:14,320 --> 00:14:16,560
front

00:14:14,800 --> 00:14:17,920
so it could share space with non-empty

00:14:16,560 --> 00:14:20,000
one

00:14:17,920 --> 00:14:21,600
so it actually permuted the order in

00:14:20,000 --> 00:14:25,120
which the storage occurred so i could do

00:14:21,600 --> 00:14:25,120
the empty base class optimization

00:14:26,560 --> 00:14:32,480
some compilers would not optimize away a

00:14:30,160 --> 00:14:34,959
sequence of empty-based classes

00:14:32,480 --> 00:14:35,760
others would optimize an arbitrary

00:14:34,959 --> 00:14:38,720
sequence of

00:14:35,760 --> 00:14:40,079
of uh base classes again so this is a

00:14:38,720 --> 00:14:44,160
very

00:14:40,079 --> 00:14:46,399
uh difficult to predict

00:14:44,160 --> 00:14:47,839
optimization and it's it's very

00:14:46,399 --> 00:14:49,680
difficult to predict in a in some

00:14:47,839 --> 00:14:52,800
portable way

00:14:49,680 --> 00:14:54,480
a complex c sequels plus class layout so

00:14:52,800 --> 00:14:55,920
if you're concerned about layout

00:14:54,480 --> 00:14:58,720
it really would be nice to have some

00:14:55,920 --> 00:15:00,880
sort of guarantees from the standard

00:14:58,720 --> 00:15:02,720
and we will be looking at that but

00:15:00,880 --> 00:15:05,760
before we go on

00:15:02,720 --> 00:15:08,079
there let's look at an important

00:15:05,760 --> 00:15:09,680
distinction between lexical and physical

00:15:08,079 --> 00:15:11,440
ordering

00:15:09,680 --> 00:15:12,800
a lot of the language is defined in

00:15:11,440 --> 00:15:16,079
terms of lexical

00:15:12,800 --> 00:15:17,120
ordering of class components a member

00:15:16,079 --> 00:15:20,320
initialization list

00:15:17,120 --> 00:15:23,279
initializes in the order of declaration

00:15:20,320 --> 00:15:25,279
no matter what order the actual storage

00:15:23,279 --> 00:15:27,040
is reorganized by the compiler

00:15:25,279 --> 00:15:29,360
it uses the lexical ordering of those

00:15:27,040 --> 00:15:30,959
members to initialize in that order

00:15:29,360 --> 00:15:32,480
base class sub-objects are initialized

00:15:30,959 --> 00:15:34,639
in the same way in the order they appear

00:15:32,480 --> 00:15:36,160
on the base class list

00:15:34,639 --> 00:15:37,920
and another example if you have a

00:15:36,160 --> 00:15:40,240
defaulted spaceship operator

00:15:37,920 --> 00:15:41,759
it compares members in their declared

00:15:40,240 --> 00:15:42,079
order and that's important because this

00:15:41,759 --> 00:15:42,959
is

00:15:42,079 --> 00:15:45,199
supposed to be some sort of

00:15:42,959 --> 00:15:47,199
lexicographic ordering based on the

00:15:45,199 --> 00:15:50,560
values of the members

00:15:47,199 --> 00:15:52,839
so again lexical ordering is guaranteed

00:15:50,560 --> 00:15:55,839
by the standard but physical ordering is

00:15:52,839 --> 00:15:58,560
not

00:15:55,839 --> 00:15:58,560
so here

00:16:01,440 --> 00:16:09,040
excuse me here

00:16:04,720 --> 00:16:10,959
is a simple class land

00:16:09,040 --> 00:16:12,240
z is of no importance in flatland

00:16:10,959 --> 00:16:14,959
apparently

00:16:12,240 --> 00:16:18,800
and i've decided to default the

00:16:14,959 --> 00:16:18,800
implementation of the spaceship operator

00:16:19,279 --> 00:16:24,000
so what do i get for free well i'll

00:16:21,279 --> 00:16:27,600
compare the x's first then the y

00:16:24,000 --> 00:16:30,800
then the z even if z is pushed up to

00:16:27,600 --> 00:16:33,600
a uh zero

00:16:30,800 --> 00:16:34,639
uh offset it'll still be compared less

00:16:33,600 --> 00:16:37,519
so i'll still get a correct

00:16:34,639 --> 00:16:40,800
lexicographic ordering

00:16:37,519 --> 00:16:42,880
here's where problems come maybe

00:16:40,800 --> 00:16:45,600
you're trying to heavily optimize this

00:16:42,880 --> 00:16:48,160
and you feel that doing a mem comparison

00:16:45,600 --> 00:16:48,880
instead of a member by member comparison

00:16:48,160 --> 00:16:51,839
will give you

00:16:48,880 --> 00:16:51,839
better behavior

00:16:52,560 --> 00:16:56,160
well this should ruin the rest of your

00:16:54,880 --> 00:16:57,519
day looking at this

00:16:56,160 --> 00:16:59,600
wondering if this is appearing in your

00:16:57,519 --> 00:17:00,560
code somewhere not that you would write

00:16:59,600 --> 00:17:03,519
something like this but

00:17:00,560 --> 00:17:04,720
someone else um what could possibly go

00:17:03,519 --> 00:17:07,520
wrong

00:17:04,720 --> 00:17:08,799
well again this is supposed to be a

00:17:07,520 --> 00:17:11,199
lexical comparison

00:17:08,799 --> 00:17:13,360
if i move z if the compiler chooses to

00:17:11,199 --> 00:17:15,439
move z up here

00:17:13,360 --> 00:17:16,799
then i now have a broken comparison

00:17:15,439 --> 00:17:19,280
because it's going to compare

00:17:16,799 --> 00:17:21,120
z first then x then y and give an

00:17:19,280 --> 00:17:23,199
incorrect comparison

00:17:21,120 --> 00:17:24,799
so this is this is a really scary sort

00:17:23,199 --> 00:17:25,919
of thing to see in your code base

00:17:24,799 --> 00:17:27,520
because it may have been working for

00:17:25,919 --> 00:17:29,360
years and years and years

00:17:27,520 --> 00:17:30,559
and then maybe you get a better

00:17:29,360 --> 00:17:33,360
optimizing compiler

00:17:30,559 --> 00:17:35,520
and all of a sudden it fails that's too

00:17:33,360 --> 00:17:38,799
bad

00:17:35,520 --> 00:17:40,640
so as usual the solution here is to act

00:17:38,799 --> 00:17:42,880
like an actual person

00:17:40,640 --> 00:17:42,880
and

00:17:45,200 --> 00:17:48,240
put all of your data members in the

00:17:46,799 --> 00:17:51,039
private section of your class

00:17:48,240 --> 00:17:52,080
keep scott myers happy uh keep everybody

00:17:51,039 --> 00:17:54,880
else happy

00:17:52,080 --> 00:17:56,240
and then this might work but it's not

00:17:54,880 --> 00:17:59,120
guaranteed to work

00:17:56,240 --> 00:18:01,039
i'm still doing this mem comp this this

00:17:59,120 --> 00:18:02,799
bit by bit comparison

00:18:01,039 --> 00:18:06,799
i know that x y and z occur in that

00:18:02,799 --> 00:18:06,799
order but this could still fail

00:18:08,160 --> 00:18:13,440
that's scary why could it fail

00:18:11,200 --> 00:18:14,720
well we'll come back to that in a minute

00:18:13,440 --> 00:18:18,559
but let's take a

00:18:14,720 --> 00:18:22,080
quick segue and look at

00:18:18,559 --> 00:18:23,360
a piece of hardware this is a uart

00:18:22,080 --> 00:18:25,600
universal asynchronous receiver

00:18:23,360 --> 00:18:28,000
transmitter uh this is

00:18:25,600 --> 00:18:29,600
an actual piece of hardware from a very

00:18:28,000 --> 00:18:31,919
old board

00:18:29,600 --> 00:18:34,400
that's very instructive because it's

00:18:31,919 --> 00:18:36,720
such a complex

00:18:34,400 --> 00:18:40,240
set of memory map devices so this is a

00:18:36,720 --> 00:18:40,240
device from that particular board

00:18:40,400 --> 00:18:45,120
and we might try to do something like

00:18:42,559 --> 00:18:49,520
this we'll define special register

00:18:45,120 --> 00:18:49,520
to be a volatile 32-bit integer

00:18:49,919 --> 00:18:54,880
and then we hope that this

00:18:52,960 --> 00:18:57,360
layout is going to match that of the

00:18:54,880 --> 00:18:59,520
actual hardware

00:18:57,360 --> 00:19:01,280
and in fact it does unless you have a

00:18:59,520 --> 00:19:04,320
very unusual platform

00:19:01,280 --> 00:19:06,480
this should match pretty exactly but you

00:19:04,320 --> 00:19:08,799
don't want to take chances

00:19:06,480 --> 00:19:11,039
so what we'd like to do is have some

00:19:08,799 --> 00:19:12,559
actual guarantee

00:19:11,039 --> 00:19:14,720
and we want to make sure that each of

00:19:12,559 --> 00:19:15,600
these members has the proper offset the

00:19:14,720 --> 00:19:19,280
correct sizes

00:19:15,600 --> 00:19:22,240
and so on and so

00:19:19,280 --> 00:19:23,039
since c plus plus 11 we do have such a

00:19:22,240 --> 00:19:25,600
guarantee

00:19:23,039 --> 00:19:26,880
and that's a guarantee of a standard

00:19:25,600 --> 00:19:28,880
layout type

00:19:26,880 --> 00:19:30,240
a standalone type is basically a simple

00:19:28,880 --> 00:19:33,200
type

00:19:30,240 --> 00:19:34,559
or a standard layout class and a

00:19:33,200 --> 00:19:37,200
standard layout class

00:19:34,559 --> 00:19:39,760
has no virtual functions no virtual base

00:19:37,200 --> 00:19:41,600
classes

00:19:39,760 --> 00:19:43,120
it can have it can use multiple

00:19:41,600 --> 00:19:43,919
inheritance can have zero or more base

00:19:43,120 --> 00:19:46,320
classes

00:19:43,919 --> 00:19:48,320
of standard layout class types no two

00:19:46,320 --> 00:19:51,360
base classes of the same type

00:19:48,320 --> 00:19:53,760
that allows that optimization of

00:19:51,360 --> 00:19:54,799
collapsing base classes and the

00:19:53,760 --> 00:19:56,480
important thing is

00:19:54,799 --> 00:19:59,120
that all members of the same access

00:19:56,480 --> 00:20:00,640
control and all members are declared in

00:19:59,120 --> 00:20:04,000
the same class

00:20:00,640 --> 00:20:04,000
or the same base class

00:20:04,840 --> 00:20:10,080
now with this

00:20:07,360 --> 00:20:11,760
restriction we can say that uart is now

00:20:10,080 --> 00:20:13,440
a standard layout class and this is

00:20:11,760 --> 00:20:15,919
going to make reasoning about

00:20:13,440 --> 00:20:17,520
the layout much more tractable we've

00:20:15,919 --> 00:20:19,200
simplified things

00:20:17,520 --> 00:20:21,440
to the extent where we can now actually

00:20:19,200 --> 00:20:24,240
reason about this layout in a platform

00:20:21,440 --> 00:20:24,240
independent way

00:20:24,799 --> 00:20:27,520
just an aside

00:20:28,240 --> 00:20:30,960
there's an older

00:20:32,400 --> 00:20:37,760
type trait called pod for plain old data

00:20:35,600 --> 00:20:39,679
plain old data is very very restrictive

00:20:37,760 --> 00:20:40,880
and it really is not a very useful

00:20:39,679 --> 00:20:43,679
concept

00:20:40,880 --> 00:20:44,720
uh at least for most problem areas you

00:20:43,679 --> 00:20:46,799
don't really want to know if something

00:20:44,720 --> 00:20:49,120
is plain old data

00:20:46,799 --> 00:20:50,000
we want to know if it's layout is

00:20:49,120 --> 00:20:51,200
predictable

00:20:50,000 --> 00:20:53,200
we want to know if it's a standard

00:20:51,200 --> 00:20:55,280
layout class so in fact

00:20:53,200 --> 00:20:57,760
uh the is pod type trade is being

00:20:55,280 --> 00:20:59,919
deprecated in c plus plus 20

00:20:57,760 --> 00:21:00,799
and you're encouraged not to use this

00:20:59,919 --> 00:21:02,480
concept

00:21:00,799 --> 00:21:04,000
but instead use something more precise

00:21:02,480 --> 00:21:07,360
like a standard layout

00:21:04,000 --> 00:21:09,760
concept or something else like that

00:21:07,360 --> 00:21:12,320
and this is again what most hardware

00:21:09,760 --> 00:21:14,720
programs have been doing all along

00:21:12,320 --> 00:21:17,840
and this just makes it a legitimate

00:21:14,720 --> 00:21:17,840
guaranteed behavior

00:21:20,559 --> 00:21:26,720
here's a problem if i go back

00:21:24,080 --> 00:21:26,720
quite a while

00:21:27,679 --> 00:21:31,679
i say that this is still not perfectly

00:21:29,600 --> 00:21:32,559
safe even though i know the order of x y

00:21:31,679 --> 00:21:36,960
and z

00:21:32,559 --> 00:21:38,400
are the same the lexical and the actual

00:21:36,960 --> 00:21:40,240
physical ordering is the same

00:21:38,400 --> 00:21:42,840
this could still fail this bit wise

00:21:40,240 --> 00:21:45,840
comparison

00:21:42,840 --> 00:21:45,840
um

00:21:49,200 --> 00:21:53,520
and the reason for that has to do with

00:21:50,960 --> 00:21:57,039
padding bytes or slack bytes

00:21:53,520 --> 00:21:59,440
um so the only guarantee we have

00:21:57,039 --> 00:22:00,320
about standard layout classes is that

00:21:59,440 --> 00:22:03,360
the first

00:22:00,320 --> 00:22:05,919
data member is at offset zero

00:22:03,360 --> 00:22:07,120
and that the data and we know that the

00:22:05,919 --> 00:22:11,760
data members will occur

00:22:07,120 --> 00:22:14,320
in increasing address locations

00:22:11,760 --> 00:22:15,679
or non-decreasing address locations at

00:22:14,320 --> 00:22:18,000
least

00:22:15,679 --> 00:22:19,440
and this also means that you can

00:22:18,000 --> 00:22:23,679
legitimately reinterpret

00:22:19,440 --> 00:22:24,159
cast uh the address of a standard layout

00:22:23,679 --> 00:22:27,120
class

00:22:24,159 --> 00:22:28,559
to a pointer to its first non-static

00:22:27,120 --> 00:22:29,679
data member

00:22:28,559 --> 00:22:31,840
and that's about the only time

00:22:29,679 --> 00:22:35,520
reinterpret cast is

00:22:31,840 --> 00:22:35,520
guaranteed to give a certain result

00:22:35,720 --> 00:22:40,400
[Music]

00:22:37,919 --> 00:22:41,200
so basically we do know that the first

00:22:40,400 --> 00:22:45,280
register

00:22:41,200 --> 00:22:47,360
in our uart will be at offset zero

00:22:45,280 --> 00:22:49,039
but we can't really be sure about any

00:22:47,360 --> 00:22:51,120
other data member

00:22:49,039 --> 00:22:52,320
and so even a standalo class data member

00:22:51,120 --> 00:22:54,880
can have slack bytes

00:22:52,320 --> 00:22:56,720
or padding bites depending on the

00:22:54,880 --> 00:23:00,000
architecture in which you

00:22:56,720 --> 00:23:02,559
compile it and depending on things like

00:23:00,000 --> 00:23:02,559
pragmas

00:23:02,640 --> 00:23:07,840
so again pragmas are

00:23:05,679 --> 00:23:09,679
non-portable i'm not a big fan of using

00:23:07,840 --> 00:23:12,240
pragmas i want my code to work the same

00:23:09,679 --> 00:23:16,559
way on all platforms as possible

00:23:12,240 --> 00:23:16,559
but i can say i want to i want to pack

00:23:16,880 --> 00:23:20,960
on the and have and set the alignment to

00:23:19,200 --> 00:23:23,679
the four byte aligned

00:23:20,960 --> 00:23:25,120
where i might want to pack things

00:23:23,679 --> 00:23:26,960
maximally

00:23:25,120 --> 00:23:28,400
by doing something like this i've never

00:23:26,960 --> 00:23:30,799
actually used these in production code

00:23:28,400 --> 00:23:34,080
because they scare me

00:23:30,799 --> 00:23:35,919
the trouble is that

00:23:34,080 --> 00:23:37,440
they don't work uniformly so usually the

00:23:35,919 --> 00:23:39,200
best thing to do

00:23:37,440 --> 00:23:41,039
is to make your best effort and then

00:23:39,200 --> 00:23:44,640
confirm

00:23:41,039 --> 00:23:48,320
that it was correct static assert

00:23:44,640 --> 00:23:49,440
is your best friend whenever you want to

00:23:48,320 --> 00:23:51,279
have some certainty

00:23:49,440 --> 00:23:53,840
in your program especially about lower

00:23:51,279 --> 00:23:55,360
level things like class layouts

00:23:53,840 --> 00:23:57,760
so here we're doing a static assert

00:23:55,360 --> 00:24:00,320
saying i expect

00:23:57,760 --> 00:24:01,679
that the offset of the yukon member in

00:24:00,320 --> 00:24:05,120
the uart structure

00:24:01,679 --> 00:24:07,520
or class is 4. in other words it's

00:24:05,120 --> 00:24:09,600
uh this occupies four bytes and there is

00:24:07,520 --> 00:24:13,600
no slack bytes between the ul con

00:24:09,600 --> 00:24:14,559
and the yukon static assertions are

00:24:13,600 --> 00:24:17,440
wonderful

00:24:14,559 --> 00:24:19,520
i might be exaggerating but i may have

00:24:17,440 --> 00:24:20,559
as many static assertions as regular

00:24:19,520 --> 00:24:21,840
executable code

00:24:20,559 --> 00:24:24,080
whenever i'm writing to a piece of

00:24:21,840 --> 00:24:26,799
hardware

00:24:24,080 --> 00:24:28,960
offsetuf is a is an old-fashioned macro

00:24:26,799 --> 00:24:30,640
it works for standard layout types

00:24:28,960 --> 00:24:32,080
it may work for other types but it

00:24:30,640 --> 00:24:33,760
doesn't have to

00:24:32,080 --> 00:24:35,279
so if it doesn't work for other types of

00:24:33,760 --> 00:24:37,120
classes

00:24:35,279 --> 00:24:39,120
that has to be documented so

00:24:37,120 --> 00:24:41,600
conditionally supported means

00:24:39,120 --> 00:24:42,159
that offsetup may work for other classes

00:24:41,600 --> 00:24:44,000
and

00:24:42,159 --> 00:24:46,640
given implementation should document

00:24:44,000 --> 00:24:48,640
what it does support in my experience it

00:24:46,640 --> 00:24:51,039
works for almost everything

00:24:48,640 --> 00:24:52,400
a few outlier cases where it may not

00:24:51,039 --> 00:24:54,400
work

00:24:52,400 --> 00:24:56,640
so again this again is a compile time

00:24:54,400 --> 00:24:56,640
check

00:24:56,880 --> 00:25:01,039
and if you're like me it's you're a

00:24:59,279 --> 00:25:04,000
nervous person

00:25:01,039 --> 00:25:04,480
and i check everything because that it's

00:25:04,000 --> 00:25:06,000
not

00:25:04,480 --> 00:25:08,320
only that i don't trust myself and i

00:25:06,000 --> 00:25:10,960
don't trust hardware i don't trust

00:25:08,320 --> 00:25:12,400
people who maintain my code

00:25:10,960 --> 00:25:14,559
and actually this kind of normative

00:25:12,400 --> 00:25:17,600
distrust of yourself

00:25:14,559 --> 00:25:19,200
your maintainers of everybody leads to a

00:25:17,600 --> 00:25:21,760
very nice stable situation

00:25:19,200 --> 00:25:23,120
the more questions you ask the more the

00:25:21,760 --> 00:25:26,080
more

00:25:23,120 --> 00:25:27,039
you you make sure that you were correct

00:25:26,080 --> 00:25:28,720
the more stable

00:25:27,039 --> 00:25:30,640
things are so this kind of normative

00:25:28,720 --> 00:25:34,400
distrust of everything

00:25:30,640 --> 00:25:38,159
does lead to a nice stable environment

00:25:34,400 --> 00:25:38,159
that's actually a result from sociology

00:25:38,960 --> 00:25:42,400
which i wish we had time to discuss so

00:25:41,440 --> 00:25:44,159
here i'm checking

00:25:42,400 --> 00:25:46,320
the size of the special register the

00:25:44,159 --> 00:25:48,480
alignment special register

00:25:46,320 --> 00:25:49,679
i want to make sure it's unsigned and

00:25:48,480 --> 00:25:50,960
want to make sure that this is a

00:25:49,679 --> 00:25:52,880
standard layout class

00:25:50,960 --> 00:25:54,080
so there is a type trait that will tell

00:25:52,880 --> 00:25:56,080
me where the uart is

00:25:54,080 --> 00:25:57,200
standard layout so if somebody does

00:25:56,080 --> 00:26:00,320
something like

00:25:57,200 --> 00:26:00,559
make one of these functions virtual you

00:26:00,320 --> 00:26:03,279
are

00:26:00,559 --> 00:26:04,640
no longer be standard layout and i will

00:26:03,279 --> 00:26:07,520
find out

00:26:04,640 --> 00:26:07,520
at compile time

00:26:08,640 --> 00:26:12,320
here an even scarier

00:26:13,039 --> 00:26:17,600
memory map device here's a timer and

00:26:15,679 --> 00:26:19,279
it's scarier because here i have a

00:26:17,600 --> 00:26:23,919
character

00:26:19,279 --> 00:26:26,000
mode register and yet the data register

00:26:23,919 --> 00:26:29,120
has to be an offset four

00:26:26,000 --> 00:26:31,360
and if it isn't and this timer is in

00:26:29,120 --> 00:26:34,880
somebody's pacemaker

00:26:31,360 --> 00:26:36,960
people will die here's a count

00:26:34,880 --> 00:26:38,640
it has to be offset eight if it isn't

00:26:36,960 --> 00:26:40,080
your intelligent toaster won't work and

00:26:38,640 --> 00:26:42,640
people will have burning toast or

00:26:40,080 --> 00:26:46,159
whatever so this will actually affect

00:26:42,640 --> 00:26:47,200
real world things um so we do want to

00:26:46,159 --> 00:26:49,600
make sure that

00:26:47,200 --> 00:26:51,520
this data is indeed offset force so of

00:26:49,600 --> 00:26:53,120
course use a static assertion

00:26:51,520 --> 00:26:55,120
well what if it's not an offset for it

00:26:53,120 --> 00:26:57,600
but we want to force it to be

00:26:55,120 --> 00:26:58,880
well we can use an align as attribute

00:26:57,600 --> 00:27:02,000
and

00:26:58,880 --> 00:27:03,679
here we want to align this data to be

00:27:02,000 --> 00:27:06,799
four byte aligned

00:27:03,679 --> 00:27:09,440
and that should be all we have to do

00:27:06,799 --> 00:27:11,520
but i always check anyway just in case

00:27:09,440 --> 00:27:14,480
and we'll see why

00:27:11,520 --> 00:27:15,360
now i don't speak russian but this is

00:27:14,480 --> 00:27:18,399
trust

00:27:15,360 --> 00:27:21,600
but verify very popular phrase in the

00:27:18,399 --> 00:27:23,200
mid to late 1980s and it's a good piece

00:27:21,600 --> 00:27:25,120
of advice

00:27:23,200 --> 00:27:29,039
trust but i also want to verify it

00:27:25,120 --> 00:27:29,039
there's no cost for verification

00:27:30,480 --> 00:27:33,679
let's suppose you're a really nervous

00:27:31,840 --> 00:27:35,600
person and went ahead and aligned

00:27:33,679 --> 00:27:36,720
everything to four bytes

00:27:35,600 --> 00:27:39,039
okay that's not going to hurt it's

00:27:36,720 --> 00:27:39,919
probably overkill but i still want to

00:27:39,039 --> 00:27:41,840
check

00:27:39,919 --> 00:27:44,320
because here's what can happen if you

00:27:41,840 --> 00:27:44,320
don't check

00:27:46,840 --> 00:27:51,120
uh i shouldn't say this but

00:27:49,760 --> 00:27:54,640
have you ever noticed how your code

00:27:51,120 --> 00:27:58,559
starts to break in mid-may

00:27:54,640 --> 00:27:58,559
bugs start appearing why is that

00:27:58,799 --> 00:28:02,559
summer interns arrive and they'll do

00:28:01,520 --> 00:28:05,760
something like this

00:28:02,559 --> 00:28:08,559
they'll do a pragma pack i want single

00:28:05,760 --> 00:28:09,679
byte alignment if possible

00:28:08,559 --> 00:28:11,760
well i've observed that different

00:28:09,679 --> 00:28:14,240
compilers behave in different ways here

00:28:11,760 --> 00:28:16,720
i've aligned everything to four bytes

00:28:14,240 --> 00:28:18,399
compiler a does indeed do that alignment

00:28:16,720 --> 00:28:20,880
in spite of this fragment

00:28:18,399 --> 00:28:22,159
compiler b listened to the pragma over

00:28:20,880 --> 00:28:23,919
the illinois

00:28:22,159 --> 00:28:25,919
and gave me the following incorrect

00:28:23,919 --> 00:28:29,120
offsets

00:28:25,919 --> 00:28:31,360
so it really makes sense to use these

00:28:29,120 --> 00:28:33,039
static assertions no matter what

00:28:31,360 --> 00:28:35,120
even if you feel they're overkill in

00:28:33,039 --> 00:28:35,760
this case things can change in the

00:28:35,120 --> 00:28:37,039
future

00:28:35,760 --> 00:28:39,200
and you want to catch these things

00:28:37,039 --> 00:28:41,840
otherwise toast will burn

00:28:39,200 --> 00:28:43,360
so again i strongly strongly recommend

00:28:41,840 --> 00:28:45,120
using static assertions

00:28:43,360 --> 00:28:46,399
whenever you want to confirm something

00:28:45,120 --> 00:28:49,279
that can be stated

00:28:46,399 --> 00:28:49,279
at compile time

00:28:50,080 --> 00:28:53,840
so here is

00:28:54,720 --> 00:28:58,320
not quite a flatland class but a narrow

00:28:56,720 --> 00:29:01,679
land class

00:28:58,320 --> 00:29:05,039
so we have x y and z

00:29:01,679 --> 00:29:06,880
are the usual coordinate labels

00:29:05,039 --> 00:29:08,799
and i have a comparison operator that

00:29:06,880 --> 00:29:12,320
compares two narrow land

00:29:08,799 --> 00:29:14,640
objects and i've decided to optimize

00:29:12,320 --> 00:29:18,640
this again so here i'm going low level

00:29:14,640 --> 00:29:21,360
i'm doing a memcomp to compare these two

00:29:18,640 --> 00:29:22,960
objects of type narrowland and so it's

00:29:21,360 --> 00:29:26,320
just going to treat this as

00:29:22,960 --> 00:29:29,440
oh let's say this is 24 bytes

00:29:26,320 --> 00:29:29,840
it'll just look at these these 24 bytes

00:29:29,440 --> 00:29:32,640
as

00:29:29,840 --> 00:29:35,279
bits and confirm that the bits are the

00:29:32,640 --> 00:29:37,919
same in both cases

00:29:35,279 --> 00:29:41,520
well that makes me a little nervous but

00:29:37,919 --> 00:29:43,679
this makes me even more nervous

00:29:41,520 --> 00:29:45,919
because this is narrow land i don't need

00:29:43,679 --> 00:29:47,679
a long long for the x

00:29:45,919 --> 00:29:51,279
coordinate so i turn it into a character

00:29:47,679 --> 00:29:51,279
i use an unsigned character instead

00:29:51,520 --> 00:29:57,279
and now however this has not changed

00:29:55,039 --> 00:29:59,200
the size of narrow land so this

00:29:57,279 --> 00:30:01,600
comparison operator is still comparing

00:29:59,200 --> 00:30:03,919
all of this data including this padding

00:30:01,600 --> 00:30:03,919
data

00:30:05,840 --> 00:30:10,880
this can give us some really really

00:30:07,840 --> 00:30:10,880
unusual results

00:30:13,440 --> 00:30:17,679
things can act normal for quite a while

00:30:15,919 --> 00:30:21,760
so here i have a global variable

00:30:17,679 --> 00:30:25,039
i know it's just example code

00:30:21,760 --> 00:30:26,399
here's a global variable and then i

00:30:25,039 --> 00:30:29,919
enter the function g

00:30:26,399 --> 00:30:31,360
g as a local variable and i am comparing

00:30:29,919 --> 00:30:34,000
the local variable in the global

00:30:31,360 --> 00:30:34,880
variable and we expect these to compare

00:30:34,000 --> 00:30:36,480
equal

00:30:34,880 --> 00:30:39,120
they have the same values for the same

00:30:36,480 --> 00:30:42,799
members and in fact they do

00:30:39,120 --> 00:30:47,360
so if i execute main and i call g

00:30:42,799 --> 00:30:51,200
these will compare equal great

00:30:47,360 --> 00:30:53,919
and then some tiny change happens

00:30:51,200 --> 00:30:56,000
i decide to call f first now they don't

00:30:53,919 --> 00:30:58,640
compare equal anymore

00:30:56,000 --> 00:30:58,640
what happened

00:30:59,039 --> 00:31:04,880
well uh initially uh global was

00:31:02,640 --> 00:31:06,399
initialized to all zeros

00:31:04,880 --> 00:31:09,519
at the start of the process memory is

00:31:06,399 --> 00:31:12,000
zero it's as in all zeros initialization

00:31:09,519 --> 00:31:14,000
and then this is copied into it but also

00:31:12,000 --> 00:31:15,120
the runtime stack was initialized to all

00:31:14,000 --> 00:31:18,960
zeros

00:31:15,120 --> 00:31:22,480
so when i entered g for the first time

00:31:18,960 --> 00:31:24,559
this memory just happened to be zeroed

00:31:22,480 --> 00:31:26,320
and so these three slack bytes here

00:31:24,559 --> 00:31:28,559
compared to these three slack bytes here

00:31:26,320 --> 00:31:30,000
as equal they were both zero

00:31:28,559 --> 00:31:31,600
then i decided to call some other

00:31:30,000 --> 00:31:34,480
function f first

00:31:31,600 --> 00:31:35,519
f wrote something to the stack frame

00:31:34,480 --> 00:31:38,640
then returned

00:31:35,519 --> 00:31:40,480
g reused that stack frame and now

00:31:38,640 --> 00:31:42,080
these three bytes were no longer

00:31:40,480 --> 00:31:45,600
necessarily zeros

00:31:42,080 --> 00:31:47,519
and these no longer compare equal again

00:31:45,600 --> 00:31:48,799
this is the kind of thing you want to

00:31:47,519 --> 00:31:50,799
avoid

00:31:48,799 --> 00:31:52,640
uh so my usual recommendation would be

00:31:50,799 --> 00:31:54,960
you know just

00:31:52,640 --> 00:31:56,159
don't do this until you're sure that

00:31:54,960 --> 00:31:58,840
it's a really

00:31:56,159 --> 00:32:00,880
important optimization for you it's just

00:31:58,840 --> 00:32:05,840
too

00:32:00,880 --> 00:32:07,919
sketchy too touchy too easy to get wrong

00:32:05,840 --> 00:32:09,440
i suppose it really is important

00:32:07,919 --> 00:32:10,320
obviously the best fix is just to be a

00:32:09,440 --> 00:32:13,120
normal person

00:32:10,320 --> 00:32:14,960
and do the comparison that you intend

00:32:13,120 --> 00:32:16,480
but if this is important

00:32:14,960 --> 00:32:18,399
the nice thing is we now have type

00:32:16,480 --> 00:32:19,679
traits that can let us ask questions at

00:32:18,399 --> 00:32:21,519
compile time

00:32:19,679 --> 00:32:23,279
so here we can rewrite this operator to

00:32:21,519 --> 00:32:25,840
ask the question

00:32:23,279 --> 00:32:27,200
if narrow land has a unique object

00:32:25,840 --> 00:32:30,720
representation in other words there are

00:32:27,200 --> 00:32:30,720
no slack bytes sitting around

00:32:31,120 --> 00:32:35,440
then we can do our

00:32:35,919 --> 00:32:40,799
fancy memcomp implementation otherwise

00:32:39,120 --> 00:32:42,240
whoops

00:32:40,799 --> 00:32:44,240
otherwise if it doesn't have a unique

00:32:42,240 --> 00:32:47,039
object representation

00:32:44,240 --> 00:32:49,120
then we'll do a normal member by member

00:32:47,039 --> 00:32:51,279
comparison and get the correct result

00:32:49,120 --> 00:32:53,760
uh notice that i've used a const expert

00:32:51,279 --> 00:32:56,080
if here this probably wasn't necessary

00:32:53,760 --> 00:32:57,760
this is a compile time constant it's

00:32:56,080 --> 00:32:59,360
either true or false

00:32:57,760 --> 00:33:01,519
every compiler on the planet will

00:32:59,360 --> 00:33:03,919
properly optimize

00:33:01,519 --> 00:33:05,039
and do the code elimination for one or

00:33:03,919 --> 00:33:08,559
the other of these two

00:33:05,039 --> 00:33:10,640
alternatives but the context for if is

00:33:08,559 --> 00:33:12,960
it guarantees that the code will be

00:33:10,640 --> 00:33:15,760
eliminated so you won't have

00:33:12,960 --> 00:33:16,320
unusable unreachable code sitting around

00:33:15,760 --> 00:33:19,200
in your

00:33:16,320 --> 00:33:20,559
process okay so this asks the question

00:33:19,200 --> 00:33:22,880
that compile time

00:33:20,559 --> 00:33:24,399
and then makes the correct compile-time

00:33:22,880 --> 00:33:27,200
choice

00:33:24,399 --> 00:33:27,760
and retains either the memcomp or the

00:33:27,200 --> 00:33:30,399
normal

00:33:27,760 --> 00:33:30,399
implementation

00:33:31,840 --> 00:33:34,960
we didn't have time to talk about this

00:33:33,200 --> 00:33:37,039
but if you look at the type traits in c

00:33:34,960 --> 00:33:38,000
plus plus 20 there are all kinds of

00:33:37,039 --> 00:33:40,240
terrific new type

00:33:38,000 --> 00:33:42,159
traits that let you ask things like are

00:33:40,240 --> 00:33:44,799
these two classes layout compatible

00:33:42,159 --> 00:33:46,080
and uh and so on and so forth lots of

00:33:44,799 --> 00:33:49,120
nice information

00:33:46,080 --> 00:33:53,840
that can make an optimization like this

00:33:49,120 --> 00:33:53,840
actually safe to do

00:33:55,919 --> 00:33:58,159
okay

00:34:00,720 --> 00:34:04,559
i recognize recovering a lot of material

00:34:02,320 --> 00:34:06,399
pretty fast

00:34:04,559 --> 00:34:07,840
let's talk a little bit about single

00:34:06,399 --> 00:34:09,760
inheritance

00:34:07,840 --> 00:34:11,200
a lot of people have seen diagrams like

00:34:09,760 --> 00:34:14,800
this um

00:34:11,200 --> 00:34:17,839
it's still useful to to review it

00:34:14,800 --> 00:34:19,440
here's a base class of some sort has

00:34:17,839 --> 00:34:20,560
three virtual functions it has other

00:34:19,440 --> 00:34:22,480
stuff we're just going to think about

00:34:20,560 --> 00:34:24,879
the virtual functions

00:34:22,480 --> 00:34:26,800
and this base class is not an abstract

00:34:24,879 --> 00:34:29,359
base so we're actually pointing to a b

00:34:26,800 --> 00:34:30,960
object here now ordinarily if this were

00:34:29,359 --> 00:34:32,399
a polymorphic base class i'd like it to

00:34:30,960 --> 00:34:36,560
be abstract

00:34:32,399 --> 00:34:38,720
but in this case for purposes of um

00:34:36,560 --> 00:34:40,960
demonstration it's not abstract so i

00:34:38,720 --> 00:34:43,040
have a b object i'm pointing to it

00:34:40,960 --> 00:34:44,399
this code generates something like this

00:34:43,040 --> 00:34:47,440
the bp points to

00:34:44,399 --> 00:34:49,440
a b object the object is

00:34:47,440 --> 00:34:51,200
almost certain to have a v pointer a

00:34:49,440 --> 00:34:53,119
virtual function table pointer

00:34:51,200 --> 00:34:54,879
that points off to a virtual function

00:34:53,119 --> 00:34:58,960
table that contains an entry

00:34:54,879 --> 00:35:01,440
for each of these virtual functions

00:34:58,960 --> 00:35:04,720
it also has some other stuff here which

00:35:01,440 --> 00:35:04,720
turns out to be quite important

00:35:04,960 --> 00:35:09,599
so what is this other stuff well virtual

00:35:08,079 --> 00:35:10,880
tables over the years have become kind

00:35:09,599 --> 00:35:14,720
of a dumping ground

00:35:10,880 --> 00:35:15,599
for anything related to the type of a

00:35:14,720 --> 00:35:18,960
class

00:35:15,599 --> 00:35:18,960
so in addition to

00:35:20,560 --> 00:35:24,640
pointers to virtual functions there

00:35:22,880 --> 00:35:26,480
might be an offset to the start of the

00:35:24,640 --> 00:35:28,320
complete object

00:35:26,480 --> 00:35:30,240
what does that mean well this is a base

00:35:28,320 --> 00:35:32,480
class it meant it may not be a b

00:35:30,240 --> 00:35:33,680
object but maybe a base class sub-object

00:35:32,480 --> 00:35:36,560
or some other object

00:35:33,680 --> 00:35:38,160
so we might have instead a pointer to

00:35:36,560 --> 00:35:41,280
the start of the complete object

00:35:38,160 --> 00:35:43,119
which is otherwise unknown uh

00:35:41,280 --> 00:35:45,839
a pointer to the type info that's

00:35:43,119 --> 00:35:47,839
important for doing dynamic casts

00:35:45,839 --> 00:35:49,359
and offsets to virtual base class

00:35:47,839 --> 00:35:50,880
sub-objects which we'll talk about

00:35:49,359 --> 00:35:54,000
shortly

00:35:50,880 --> 00:35:57,599
very interesting stuff actually i think

00:35:54,000 --> 00:36:01,359
arthur dwyer gave a really nice talk on

00:35:57,599 --> 00:36:03,920
in cppcon 2017 where he talked about

00:36:01,359 --> 00:36:04,880
how how do you write dynamic cast from

00:36:03,920 --> 00:36:07,359
scratch

00:36:04,880 --> 00:36:09,680
and he and to do that talk he talks a

00:36:07,359 --> 00:36:12,560
lot about what this other stuff

00:36:09,680 --> 00:36:13,040
in the virtual function table is so it's

00:36:12,560 --> 00:36:16,079
a

00:36:13,040 --> 00:36:17,599
it's a good thing to watch um another

00:36:16,079 --> 00:36:19,440
side point is that

00:36:17,599 --> 00:36:20,800
if this were a proper polymorphic base

00:36:19,440 --> 00:36:22,000
class it would have a public virtual

00:36:20,800 --> 00:36:23,520
destructor

00:36:22,000 --> 00:36:24,839
i've decided to ignore those because

00:36:23,520 --> 00:36:26,000
they do make things a little more

00:36:24,839 --> 00:36:28,800
complex

00:36:26,000 --> 00:36:29,359
in particular a lot of implementations

00:36:28,800 --> 00:36:31,520
will have

00:36:29,359 --> 00:36:33,280
two entries in the virtual table for a

00:36:31,520 --> 00:36:35,520
single destructor

00:36:33,280 --> 00:36:36,800
one is a deleting destructor that frees

00:36:35,520 --> 00:36:38,880
the memory and one is simply a

00:36:36,800 --> 00:36:40,800
destroying destructor

00:36:38,880 --> 00:36:43,839
so i didn't that's not really important

00:36:40,800 --> 00:36:43,839
to the subject at hand

00:36:44,079 --> 00:36:47,839
okay uh what about the calling sequence

00:36:46,880 --> 00:36:49,920
well

00:36:47,839 --> 00:36:51,520
the calling sequence is pretty simple we

00:36:49,920 --> 00:36:54,720
grab the v pointer

00:36:51,520 --> 00:36:57,359
we indirect to it we access

00:36:54,720 --> 00:36:58,160
the function of interest at its proper

00:36:57,359 --> 00:37:00,640
index

00:36:58,160 --> 00:37:02,560
and then pass bp as the this pointer

00:37:00,640 --> 00:37:05,280
something like this

00:37:02,560 --> 00:37:06,400
it's very very efficient uh compared to

00:37:05,280 --> 00:37:10,240
many other languages

00:37:06,400 --> 00:37:12,480
or a lot more ornate but code like this

00:37:10,240 --> 00:37:14,720
can be rendered pretty quickly here's a

00:37:12,480 --> 00:37:17,119
you know simple arm assembler

00:37:14,720 --> 00:37:18,240
and again this is a this is a risk

00:37:17,119 --> 00:37:20,640
machine

00:37:18,240 --> 00:37:22,079
no complex instruction sets and yet we

00:37:20,640 --> 00:37:26,000
have a very very

00:37:22,079 --> 00:37:30,240
uh reasonable size implementation here

00:37:26,000 --> 00:37:30,240
very fast comparatively fast

00:37:31,520 --> 00:37:34,560
if you're not into reading assembly

00:37:32,800 --> 00:37:36,960
language where everybody is now

00:37:34,560 --> 00:37:37,599
everybody knows about compiler explorer

00:37:36,960 --> 00:37:39,760
and so

00:37:37,599 --> 00:37:41,440
it's it's a good idea when you're

00:37:39,760 --> 00:37:44,240
wondering how efficient something is

00:37:41,440 --> 00:37:44,960
just to you know say thank you to matt

00:37:44,240 --> 00:37:47,200
godbolt

00:37:44,960 --> 00:37:51,839
and go to compiler explorer and see what

00:37:47,200 --> 00:37:51,839
kind of code you're getting

00:37:52,160 --> 00:37:59,520
okay overriding well the derived class

00:37:55,680 --> 00:38:02,720
derived from this this public base class

00:37:59,520 --> 00:38:04,400
is going to choose some overrides here

00:38:02,720 --> 00:38:07,119
we're going to override f1 and f3 and

00:38:04,400 --> 00:38:09,920
add a new virtual function f4

00:38:07,119 --> 00:38:10,400
the effect of this is now that the base

00:38:09,920 --> 00:38:13,760
class

00:38:10,400 --> 00:38:15,920
sub-object of the complete object

00:38:13,760 --> 00:38:16,960
still is a v pointer but now it's

00:38:15,920 --> 00:38:19,839
pointing to a different

00:38:16,960 --> 00:38:19,839
v table

00:38:20,160 --> 00:38:23,839
and this v table is a little bit larger

00:38:22,480 --> 00:38:27,040
than the base class one because i've

00:38:23,839 --> 00:38:27,040
added a new virtual function

00:38:27,760 --> 00:38:33,760
and overriding is simply replacing

00:38:30,839 --> 00:38:35,280
the address of this of this function

00:38:33,760 --> 00:38:38,400
with a derived class version

00:38:35,280 --> 00:38:41,760
if overriding has taken place f1 and f3

00:38:38,400 --> 00:38:43,520
have overridden f2

00:38:41,760 --> 00:38:45,599
was not overridden and so this still

00:38:43,520 --> 00:38:49,599
refers to

00:38:45,599 --> 00:38:49,599
the base class version of this function

00:38:50,000 --> 00:38:54,880
but notice that the actual sequence

00:38:53,040 --> 00:38:57,280
now i have a base class pointer pointing

00:38:54,880 --> 00:38:58,880
to derived class object

00:38:57,280 --> 00:39:01,040
the sequence is still the same i still

00:38:58,880 --> 00:39:03,920
branch indirect through the v table

00:39:01,040 --> 00:39:05,839
go to the corresponding offset and

00:39:03,920 --> 00:39:07,920
whether this is a base class

00:39:05,839 --> 00:39:09,200
object or derived class object will get

00:39:07,920 --> 00:39:12,320
the correct behavior

00:39:09,200 --> 00:39:12,720
because the constructor for d has set

00:39:12,320 --> 00:39:15,599
the v

00:39:12,720 --> 00:39:16,640
pointer to the v table for d not the one

00:39:15,599 --> 00:39:20,079
for b

00:39:16,640 --> 00:39:21,119
so most people have seen code like this

00:39:20,079 --> 00:39:24,000
you know if you've been programming in

00:39:21,119 --> 00:39:24,000
python or something

00:39:24,400 --> 00:39:28,720
you may not be aware of this but a very

00:39:27,520 --> 00:39:33,359
very simple mechanism

00:39:28,720 --> 00:39:33,359
very fast and type safe

00:39:34,880 --> 00:39:39,680
i do want to point out that the standard

00:39:37,760 --> 00:39:41,359
does not require

00:39:39,680 --> 00:39:43,040
that virtual functions be implemented

00:39:41,359 --> 00:39:44,560
anything like this but i've never seen a

00:39:43,040 --> 00:39:46,640
compiler that didn't implement virtual

00:39:44,560 --> 00:39:49,920
functions like this

00:39:46,640 --> 00:39:53,200
earlier compiler cfront in particular

00:39:49,920 --> 00:39:55,280
would put the v pointer not at offset 0

00:39:53,200 --> 00:39:56,400
but at the end of the base class and so

00:39:55,280 --> 00:39:58,079
you'd have a structure that looks

00:39:56,400 --> 00:40:02,079
something like this

00:39:58,079 --> 00:40:04,079
and this difference

00:40:02,079 --> 00:40:06,400
led to some very dangerous dangerous

00:40:04,079 --> 00:40:06,400
code

00:40:07,040 --> 00:40:10,319
a lot of this was a lot of code that

00:40:09,119 --> 00:40:13,680
assumed that the v

00:40:10,319 --> 00:40:13,680
pointer was an offset zero

00:40:14,000 --> 00:40:19,119
and would actually do a reinterpret cast

00:40:16,960 --> 00:40:22,720
equivalent this was done some time ago

00:40:19,119 --> 00:40:26,319
to grab this v pointer and

00:40:22,720 --> 00:40:28,079
do something with it but unfortunately

00:40:26,319 --> 00:40:29,680
that code would not work very well in a

00:40:28,079 --> 00:40:31,599
situation like this it would grab

00:40:29,680 --> 00:40:33,599
this v pointer which of course is not

00:40:31,599 --> 00:40:36,720
there and do something

00:40:33,599 --> 00:40:39,040
really unfortunate so remember

00:40:36,720 --> 00:40:40,560
there is no guarantee that the class

00:40:39,040 --> 00:40:41,599
will be laid out in any particular way

00:40:40,560 --> 00:40:45,839
in this case or that

00:40:41,599 --> 00:40:47,599
there will even be a v pointer but um

00:40:45,839 --> 00:40:49,440
i think it's pretty universal now that

00:40:47,599 --> 00:40:54,800
the v pointers is generally

00:40:49,440 --> 00:40:56,319
offset zero um by default

00:40:54,800 --> 00:40:58,800
because you get better behavior that way

00:40:56,319 --> 00:40:58,800
and so on

00:41:00,960 --> 00:41:04,400
and then we have multiple inheritance

00:41:04,480 --> 00:41:07,680
very exciting so here we have an

00:41:06,800 --> 00:41:10,000
observed shape

00:41:07,680 --> 00:41:12,800
that is a shape and a subject so it's

00:41:10,000 --> 00:41:12,800
being observed

00:41:13,119 --> 00:41:16,400
in that case we have a layout something

00:41:14,720 --> 00:41:18,720
like this

00:41:16,400 --> 00:41:19,839
so an observed shape object has a shaped

00:41:18,720 --> 00:41:21,760
sub object

00:41:19,839 --> 00:41:23,440
perhaps followed by a subject sub-object

00:41:21,760 --> 00:41:25,119
then some derived class members

00:41:23,440 --> 00:41:26,880
this is a likely layout and not not a

00:41:25,119 --> 00:41:29,920
guaranteed layout but a likely one

00:41:26,880 --> 00:41:31,680
but notice if i have an observed shape

00:41:29,920 --> 00:41:33,200
and then i do a safe and predefined

00:41:31,680 --> 00:41:36,640
conversion to

00:41:33,200 --> 00:41:38,079
the base class sub-objects well both of

00:41:36,640 --> 00:41:39,680
these base classes

00:41:38,079 --> 00:41:41,680
if they're non-empty classes can't have

00:41:39,680 --> 00:41:43,920
the same address and so it'll wind up

00:41:41,680 --> 00:41:45,040
something like this this observed shape

00:41:43,920 --> 00:41:47,520
pointer points to

00:41:45,040 --> 00:41:48,800
the complete object the shape pointer

00:41:47,520 --> 00:41:51,839
points to

00:41:48,800 --> 00:41:54,319
the first sub-object and the subject

00:41:51,839 --> 00:41:57,119
pointer points to the subject sub-object

00:41:54,319 --> 00:42:00,319
but notice the pointers

00:41:57,119 --> 00:42:00,319
point to different locations

00:42:01,280 --> 00:42:06,960
so basically in c

00:42:04,400 --> 00:42:08,720
plus plus as an object can have more

00:42:06,960 --> 00:42:11,440
than one valid address

00:42:08,720 --> 00:42:12,240
this observed shape object has at least

00:42:11,440 --> 00:42:15,280
two valid

00:42:12,240 --> 00:42:17,200
addresses it could have more but it's

00:42:15,280 --> 00:42:18,880
likely to be something like this

00:42:17,200 --> 00:42:20,640
the nice thing about this though is that

00:42:18,880 --> 00:42:24,319
the compiler does know

00:42:20,640 --> 00:42:28,240
what this delta is it knows how to

00:42:24,319 --> 00:42:30,079
take this base class pointer and get to

00:42:28,240 --> 00:42:31,520
the complete object knows how to take

00:42:30,079 --> 00:42:32,400
the complete object pointer and get to

00:42:31,520 --> 00:42:35,599
the base class

00:42:32,400 --> 00:42:37,040
sub-object because this is information

00:42:35,599 --> 00:42:39,440
that's known at compile time to the

00:42:37,040 --> 00:42:41,760
compiler

00:42:39,440 --> 00:42:44,480
so what is this what does this mean for

00:42:41,760 --> 00:42:46,319
pointer comparison well in c

00:42:44,480 --> 00:42:48,079
plus plus when you compare two pointers

00:42:46,319 --> 00:42:50,400
we are not asking the question

00:42:48,079 --> 00:42:51,599
did these pointers point to the same

00:42:50,400 --> 00:42:53,760
location

00:42:51,599 --> 00:42:55,520
the question we're asking is do these

00:42:53,760 --> 00:42:58,560
pointers point to the same

00:42:55,520 --> 00:43:00,079
object that's quite a different question

00:42:58,560 --> 00:43:02,640
when you have multiple inheritance and

00:43:00,079 --> 00:43:05,680
even when you have single inheritance

00:43:02,640 --> 00:43:08,319
so in this case

00:43:05,680 --> 00:43:10,160
when we're comparing the observed shape

00:43:08,319 --> 00:43:11,680
to the shape

00:43:10,160 --> 00:43:13,440
there's not much to do here because they

00:43:11,680 --> 00:43:14,880
actually do have the same address

00:43:13,440 --> 00:43:18,160
but if i'm comparing an observed shape

00:43:14,880 --> 00:43:21,680
to a subject i have to do some

00:43:18,160 --> 00:43:24,880
arithmetic i have to the compiler has to

00:43:21,680 --> 00:43:27,599
add that delta to

00:43:24,880 --> 00:43:28,720
the drive class to get the address of

00:43:27,599 --> 00:43:30,000
the base class

00:43:28,720 --> 00:43:32,880
conditionally out of course because if

00:43:30,000 --> 00:43:34,880
this is a this is a null pointer

00:43:32,880 --> 00:43:37,359
i want to see if the subject is also

00:43:34,880 --> 00:43:38,960
null otherwise i'll add the delta and do

00:43:37,359 --> 00:43:41,520
the comparison

00:43:38,960 --> 00:43:42,880
so this turns out to be a pretty

00:43:41,520 --> 00:43:46,240
efficient

00:43:42,880 --> 00:43:47,200
operation so again the compiler knows

00:43:46,240 --> 00:43:50,960
okay

00:43:47,200 --> 00:43:54,319
uh subject is a non-first base class

00:43:50,960 --> 00:43:56,400
of this observed shape

00:43:54,319 --> 00:43:57,520
therefore i'll look up the delta in the

00:43:56,400 --> 00:43:59,520
symbol table

00:43:57,520 --> 00:44:02,079
i'll do this addition and then do the

00:43:59,520 --> 00:44:02,079
comparison

00:44:02,480 --> 00:44:06,560
and in the simple risk machine it's

00:44:04,960 --> 00:44:08,880
really really fast

00:44:06,560 --> 00:44:10,800
most of the deltas are fairly small and

00:44:08,880 --> 00:44:14,240
so they can often be immediate data

00:44:10,800 --> 00:44:16,319
and um this simple three

00:44:14,240 --> 00:44:18,160
instruction sequence does that addition

00:44:16,319 --> 00:44:19,760
and comparison and so on

00:44:18,160 --> 00:44:21,599
of course if no adjustment has to be

00:44:19,760 --> 00:44:27,119
made it's even faster

00:44:21,599 --> 00:44:27,119
but it's um it's not that much slower

00:44:27,920 --> 00:44:31,520
and this is of course also the way

00:44:29,359 --> 00:44:34,560
static casts will work as well

00:44:31,520 --> 00:44:36,800
if i were to cast say a subject to an

00:44:34,560 --> 00:44:38,880
observed shape

00:44:36,800 --> 00:44:40,560
well i did the same delta arithmetic of

00:44:38,880 --> 00:44:43,119
course

00:44:40,560 --> 00:44:44,720
if you want to be clear about this if i

00:44:43,119 --> 00:44:47,280
cast a subject

00:44:44,720 --> 00:44:48,480
to an observed shape i'll subtract this

00:44:47,280 --> 00:44:50,800
delta

00:44:48,480 --> 00:44:52,079
i had better be sure that this subject

00:44:50,800 --> 00:44:55,119
is indeed

00:44:52,079 --> 00:44:57,119
a sub a base class sub-object

00:44:55,119 --> 00:44:58,400
of an observed shape if it's a

00:44:57,119 --> 00:44:59,839
standalone subject

00:44:58,400 --> 00:45:04,800
well i'm going to have a bad address

00:44:59,839 --> 00:45:07,280
here so as always static cast is

00:45:04,800 --> 00:45:10,319
just dangerous enough to be fun when you

00:45:07,280 --> 00:45:10,319
use it in hierarchies

00:45:12,020 --> 00:45:16,839
[Music]

00:45:13,760 --> 00:45:19,839
so let's get a little more detailed here

00:45:16,839 --> 00:45:19,839
um

00:45:20,560 --> 00:45:23,760
and a little bit faster so here are a

00:45:22,720 --> 00:45:26,160
couple of bass classes

00:45:23,760 --> 00:45:26,880
i'm not going to stress this too much so

00:45:26,160 --> 00:45:29,440
they each have a v

00:45:26,880 --> 00:45:30,880
pointer in them what is the derived

00:45:29,440 --> 00:45:32,880
class that derives from these two

00:45:30,880 --> 00:45:34,079
base classes look like well it has two

00:45:32,880 --> 00:45:38,319
base class sub objects

00:45:34,079 --> 00:45:40,400
and therefore has two v pointers

00:45:38,319 --> 00:45:43,440
that's a little scary so now we have

00:45:40,400 --> 00:45:43,440
more than one v pointer

00:45:44,079 --> 00:45:47,119
and here's the problem with overriding

00:45:46,480 --> 00:45:49,119
if

00:45:47,119 --> 00:45:50,720
if the derived class object is

00:45:49,119 --> 00:45:53,280
overriding a non-first

00:45:50,720 --> 00:45:54,800
base class virtual function well it's

00:45:53,280 --> 00:45:58,079
something like this

00:45:54,800 --> 00:45:58,079
so say i overrode

00:45:58,319 --> 00:46:02,240
d over road f2 well it's going to

00:46:00,880 --> 00:46:05,839
override

00:46:02,240 --> 00:46:09,359
b1s f2 and

00:46:05,839 --> 00:46:12,640
b2's f2

00:46:09,359 --> 00:46:13,520
the trouble is this is a pointer to a b2

00:46:12,640 --> 00:46:15,359
sub-object

00:46:13,520 --> 00:46:16,640
but this function is expecting a pointer

00:46:15,359 --> 00:46:19,200
to a d object

00:46:16,640 --> 00:46:20,960
so i have to do that delta arithmetic on

00:46:19,200 --> 00:46:23,359
this pointer

00:46:20,960 --> 00:46:29,280
to get past a correct this pointer to

00:46:23,359 --> 00:46:31,520
this overriding derived class function

00:46:29,280 --> 00:46:33,280
so here is the first implementation and

00:46:31,520 --> 00:46:36,319
this was done intentionally

00:46:33,280 --> 00:46:37,680
for portability uh sake um

00:46:36,319 --> 00:46:40,000
the first implementation of multiple

00:46:37,680 --> 00:46:43,599
inheritance would actually have a delta

00:46:40,000 --> 00:46:45,920
in the virtual table and this delta was

00:46:43,599 --> 00:46:47,599
almost always zero but it would

00:46:45,920 --> 00:46:49,520
occasionally have to do

00:46:47,599 --> 00:46:51,359
some delta adjustment and so we'd have a

00:46:49,520 --> 00:46:53,359
non-zero delta

00:46:51,359 --> 00:46:55,520
in the virtual table and this is a

00:46:53,359 --> 00:46:58,000
little unfortunate because we always had

00:46:55,520 --> 00:47:01,200
to do that arithmetic

00:46:58,000 --> 00:47:03,839
whether we had a non-zero

00:47:01,200 --> 00:47:05,119
delta or not and again this was done

00:47:03,839 --> 00:47:07,359
intentionally

00:47:05,119 --> 00:47:09,200
uh jarna was aware of other

00:47:07,359 --> 00:47:10,079
implementations but for practical

00:47:09,200 --> 00:47:12,160
reasons

00:47:10,079 --> 00:47:14,720
he elected to do this in order to make

00:47:12,160 --> 00:47:16,800
sure that c plus plus could compile

00:47:14,720 --> 00:47:18,079
you know everywhere uh be translated

00:47:16,800 --> 00:47:19,839
into c without

00:47:18,079 --> 00:47:21,359
without forcing an assembly language

00:47:19,839 --> 00:47:23,440
approach

00:47:21,359 --> 00:47:25,200
later when that became less important we

00:47:23,440 --> 00:47:28,720
had a somewhat better approach called a

00:47:25,200 --> 00:47:30,960
thunk implementation um the term thunk

00:47:28,720 --> 00:47:34,319
actually comes from alcohol 60. it's a

00:47:30,960 --> 00:47:36,400
way to do pass by name uh but it's

00:47:34,319 --> 00:47:38,720
like i said it was misnamed i guess it's

00:47:36,400 --> 00:47:40,400
an extension of the concept of a thunk

00:47:38,720 --> 00:47:42,240
but it's just a little snippet of code

00:47:40,400 --> 00:47:45,520
that does that delta adjustment

00:47:42,240 --> 00:47:46,400
and then passes it on to the eventual

00:47:45,520 --> 00:47:48,079
receiver

00:47:46,400 --> 00:47:51,119
so in this case instead of storing the

00:47:48,079 --> 00:47:54,480
delta in the virtual function table

00:47:51,119 --> 00:47:55,440
i instead of putting df2 here i put the

00:47:54,480 --> 00:47:57,280
address of the thunk

00:47:55,440 --> 00:47:59,200
and what does the thunk do it forwards

00:47:57,280 --> 00:48:00,640
the call after doing that delta

00:47:59,200 --> 00:48:03,599
arithmetic

00:48:00,640 --> 00:48:04,400
and this is a fairly um uh very

00:48:03,599 --> 00:48:06,240
successful

00:48:04,400 --> 00:48:07,520
actually way of implementing multiple

00:48:06,240 --> 00:48:09,839
inheritance because this

00:48:07,520 --> 00:48:11,119
this delta adjustment is a relatively

00:48:09,839 --> 00:48:13,440
rare thing

00:48:11,119 --> 00:48:14,160
relatively rare so you don't want to

00:48:13,440 --> 00:48:15,599
penalize

00:48:14,160 --> 00:48:17,680
all virtual functions for that and this

00:48:15,599 --> 00:48:20,319
works very well

00:48:17,680 --> 00:48:21,760
we even see this manifest in other areas

00:48:20,319 --> 00:48:23,520
which i'd love to discuss but we don't

00:48:21,760 --> 00:48:26,559
have time to if you have a pointer

00:48:23,520 --> 00:48:28,400
to a member function

00:48:26,559 --> 00:48:30,800
there are two major ways of implementing

00:48:28,400 --> 00:48:33,119
that one of them actually uses a thunk

00:48:30,800 --> 00:48:35,119
to distinguish between a virtual member

00:48:33,119 --> 00:48:36,079
function and a non-virtual member

00:48:35,119 --> 00:48:39,359
function

00:48:36,079 --> 00:48:40,640
um so without penalizing the typical

00:48:39,359 --> 00:48:42,720
case where you're taking the address of

00:48:40,640 --> 00:48:46,079
a non-virtual

00:48:42,720 --> 00:48:47,839
so again very successful technique and

00:48:46,079 --> 00:48:49,280
some compilers that believe the solaris

00:48:47,839 --> 00:48:51,920
compiler did this

00:48:49,280 --> 00:48:52,880
would just have the thunk adjacent to

00:48:51,920 --> 00:48:54,800
the body

00:48:52,880 --> 00:48:57,119
of the overriding function so we simply

00:48:54,800 --> 00:48:58,800
branch a few bytes before

00:48:57,119 --> 00:49:00,839
the address of the function executes

00:48:58,800 --> 00:49:02,559
delta adjustment and then execute the

00:49:00,839 --> 00:49:07,200
function

00:49:02,559 --> 00:49:09,920
so again these are various ways

00:49:07,200 --> 00:49:10,800
of dealing with that what about single

00:49:09,920 --> 00:49:12,400
inheritance

00:49:10,800 --> 00:49:14,079
well you can actually get multiple

00:49:12,400 --> 00:49:15,280
addresses under single inheritance if

00:49:14,079 --> 00:49:16,960
you're not careful

00:49:15,280 --> 00:49:18,640
if i have a base class with no virtual

00:49:16,960 --> 00:49:20,319
functions and i have a derived class

00:49:18,640 --> 00:49:22,160
that has a virtual function

00:49:20,319 --> 00:49:23,680
that's not unheard of but it's a little

00:49:22,160 --> 00:49:26,720
unusual

00:49:23,680 --> 00:49:29,599
you might have a layout like this the d

00:49:26,720 --> 00:49:30,000
object contains a v pointer a b sub

00:49:29,599 --> 00:49:32,160
object

00:49:30,000 --> 00:49:33,040
and then the rest of the d members but

00:49:32,160 --> 00:49:36,720
the b

00:49:33,040 --> 00:49:38,480
sub object is not at offset zero

00:49:36,720 --> 00:49:40,960
it comes after the v pointer it's

00:49:38,480 --> 00:49:42,720
allocated in this location

00:49:40,960 --> 00:49:44,480
you can also get this if you have no

00:49:42,720 --> 00:49:46,559
virtual functions if i have a virtual

00:49:44,480 --> 00:49:49,280
base class

00:49:46,559 --> 00:49:50,079
the same thing can happen the virtual

00:49:49,280 --> 00:49:52,319
mechanism

00:49:50,079 --> 00:49:54,000
may is not guaranteed to but may be

00:49:52,319 --> 00:49:57,440
implemented with a virtual

00:49:54,000 --> 00:49:59,359
function table so even if you have no

00:49:57,440 --> 00:50:00,720
no virtual functions if you have a

00:49:59,359 --> 00:50:03,040
virtual base class

00:50:00,720 --> 00:50:04,480
you may find yourself with a virtual

00:50:03,040 --> 00:50:06,880
pointer and you can have the same

00:50:04,480 --> 00:50:12,240
situation here

00:50:06,880 --> 00:50:14,640
so just be aware just a warning this is

00:50:12,240 --> 00:50:14,640
a bug

00:50:15,280 --> 00:50:18,800
if you have a code base that has code

00:50:17,440 --> 00:50:20,400
that's 20 years old and

00:50:18,800 --> 00:50:22,000
this bug is in your code somewhere if

00:50:20,400 --> 00:50:24,880
you haven't found it yet

00:50:22,000 --> 00:50:26,000
this is a very very common bug we've

00:50:24,880 --> 00:50:28,160
seen that

00:50:26,000 --> 00:50:29,760
under multiple inheritance certainly but

00:50:28,160 --> 00:50:32,319
even under single inheritance

00:50:29,760 --> 00:50:33,280
sometimes we have to do delta arithmetic

00:50:32,319 --> 00:50:37,760
to get

00:50:33,280 --> 00:50:37,760
do the correct address transformations

00:50:38,880 --> 00:50:43,200
um and this delta arithmetic depends on

00:50:41,520 --> 00:50:45,760
the compiler knowing

00:50:43,200 --> 00:50:46,480
the exact types of the pointers that are

00:50:45,760 --> 00:50:50,800
being

00:50:46,480 --> 00:50:50,800
converted or casted um

00:50:51,680 --> 00:50:55,520
one thing to emphasize is that c plus

00:50:53,200 --> 00:50:58,160
plus is a strongly typed language

00:50:55,520 --> 00:50:59,359
and whenever you do something that

00:50:58,160 --> 00:51:01,680
reduces that

00:50:59,359 --> 00:51:02,880
that strongly type nature particularly

00:51:01,680 --> 00:51:05,440
by casting

00:51:02,880 --> 00:51:06,720
you're inviting disaster so you want to

00:51:05,440 --> 00:51:09,520
be very careful

00:51:06,720 --> 00:51:10,210
so here we have an observed blob of some

00:51:09,520 --> 00:51:11,920
sort

00:51:10,210 --> 00:51:15,119
[Music]

00:51:11,920 --> 00:51:16,160
and we can convert it to a pointer to a

00:51:15,119 --> 00:51:19,200
subject

00:51:16,160 --> 00:51:22,400
that's a safe conversion converting this

00:51:19,200 --> 00:51:23,680
address to this address is fine this is

00:51:22,400 --> 00:51:25,839
not a good idea

00:51:23,680 --> 00:51:26,800
here i'm converting a subject pointer to

00:51:25,839 --> 00:51:28,640
a void star

00:51:26,800 --> 00:51:30,720
this is a very dangerous conversion and

00:51:28,640 --> 00:51:32,960
one you wouldn't do lightly

00:51:30,720 --> 00:51:35,280
or unless you were you know trying to

00:51:32,960 --> 00:51:36,720
ruin your organization or something

00:51:35,280 --> 00:51:38,800
the trouble is that now these different

00:51:36,720 --> 00:51:40,720
addresses compare equal

00:51:38,800 --> 00:51:43,040
these different addresses don't compare

00:51:40,720 --> 00:51:43,040
equal

00:51:43,280 --> 00:51:46,319
because this is a void star pointer the

00:51:45,119 --> 00:51:46,640
compiler doesn't know what it's pointing

00:51:46,319 --> 00:51:48,880
to

00:51:46,640 --> 00:51:50,880
it can't perform this delta arithmetic

00:51:48,880 --> 00:51:53,040
well what's the problem

00:51:50,880 --> 00:51:54,880
the problem is that people would have

00:51:53,040 --> 00:51:56,720
interfaces like this they'd type def

00:51:54,880 --> 00:51:59,200
something to be a void star something

00:51:56,720 --> 00:52:00,240
you probably shouldn't do

00:51:59,200 --> 00:52:03,440
and then they have a nice looking

00:52:00,240 --> 00:52:05,280
interface a set widget and a get widget

00:52:03,440 --> 00:52:06,640
but this widget is really just a void

00:52:05,280 --> 00:52:08,640
star

00:52:06,640 --> 00:52:11,040
so people would set a widget with a

00:52:08,640 --> 00:52:13,119
drive class

00:52:11,040 --> 00:52:14,079
now if they get widget and cast that

00:52:13,119 --> 00:52:16,160
voicethread back

00:52:14,079 --> 00:52:17,599
to exactly the same type this is

00:52:16,160 --> 00:52:20,079
guaranteed to work it's guaranteed by

00:52:17,599 --> 00:52:21,680
the standard

00:52:20,079 --> 00:52:24,000
but what people did was this they

00:52:21,680 --> 00:52:26,559
assumed that base classes

00:52:24,000 --> 00:52:28,640
and derived classes had the same address

00:52:26,559 --> 00:52:30,640
a base class sub-object had at was an

00:52:28,640 --> 00:52:32,640
offset zero of the drive class that was

00:52:30,640 --> 00:52:33,599
never guaranteed it was just often the

00:52:32,640 --> 00:52:35,680
case

00:52:33,599 --> 00:52:37,200
so now when we set the widget this is a

00:52:35,680 --> 00:52:41,359
void star

00:52:37,200 --> 00:52:41,359
we cast it back to the base class

00:52:41,440 --> 00:52:45,599
well under multiple inheritance this is

00:52:43,200 --> 00:52:49,680
not going to work it's going to cast

00:52:45,599 --> 00:52:53,200
that void star 2 not

00:52:49,680 --> 00:52:56,400
a shape it's going to cast it to a

00:52:53,200 --> 00:52:58,559
subject but

00:52:56,400 --> 00:53:00,160
leave the compiler thinking that that

00:52:58,559 --> 00:53:02,559
pointer is a pointer to a shape and you

00:53:00,160 --> 00:53:04,559
can have some undefined behavior

00:53:02,559 --> 00:53:07,040
and if you're lucky you'll die horribly

00:53:04,559 --> 00:53:11,599
immediately if you're unlucky

00:53:07,040 --> 00:53:13,599
it's um well not pretty

00:53:11,599 --> 00:53:14,640
okay uh and what happened to people's

00:53:13,599 --> 00:53:18,000
code is

00:53:14,640 --> 00:53:19,440
uh code like that worked very well for a

00:53:18,000 --> 00:53:22,160
long long time

00:53:19,440 --> 00:53:23,760
and then somebody made a remote change

00:53:22,160 --> 00:53:24,800
when the code was recompiled even though

00:53:23,760 --> 00:53:26,720
it wasn't modified

00:53:24,800 --> 00:53:28,079
now it's going to break somebody decide

00:53:26,720 --> 00:53:30,000
to use multiple inheritance and that

00:53:28,079 --> 00:53:33,040
broke the entire framework

00:53:30,000 --> 00:53:35,520
so again you want to be a bit careful um

00:53:33,040 --> 00:53:38,160
i'm not going to emphasize this this can

00:53:35,520 --> 00:53:40,960
happen under single inheritance as well

00:53:38,160 --> 00:53:42,000
again we always obey the standard even

00:53:40,960 --> 00:53:45,200
if it seems like we don't have

00:53:42,000 --> 00:53:48,319
to their history

00:53:45,200 --> 00:53:48,319
at least history has

00:53:53,119 --> 00:53:56,480
ignored the standard and then got later

00:53:55,839 --> 00:53:59,440
problems

00:53:56,480 --> 00:54:01,359
a common example i see is it's okay to

00:53:59,440 --> 00:54:03,520
delete a null pointer that's fine but

00:54:01,359 --> 00:54:05,520
you can't delete it twice

00:54:03,520 --> 00:54:06,880
without resetting the value to some

00:54:05,520 --> 00:54:10,079
valid pointer value

00:54:06,880 --> 00:54:12,319
if i delete the same pointer twice uh

00:54:10,079 --> 00:54:13,359
if it's not null you'll get probably a

00:54:12,319 --> 00:54:15,680
seg fault

00:54:13,359 --> 00:54:17,520
if it is null it typically just happens

00:54:15,680 --> 00:54:19,040
to work

00:54:17,520 --> 00:54:20,559
but it's not guaranteed to work and

00:54:19,040 --> 00:54:22,400
there was actually one compiler in the

00:54:20,559 --> 00:54:24,319
1980s where it wouldn't work

00:54:22,400 --> 00:54:25,760
because when you deleted a pointer a new

00:54:24,319 --> 00:54:29,040
value is overwritten

00:54:25,760 --> 00:54:32,800
in the deleted pointer so again

00:54:29,040 --> 00:54:32,800
do follow the standard

00:54:33,119 --> 00:54:40,160
one last topic in record

00:54:36,839 --> 00:54:40,799
speed i want you to know that i was

00:54:40,160 --> 00:54:42,400
warned

00:54:40,799 --> 00:54:44,880
that this talk was too long and i

00:54:42,400 --> 00:54:46,559
ignored the warning as always

00:54:44,880 --> 00:54:48,640
so what happens if we have two

00:54:46,559 --> 00:54:51,440
sub-objects of the same type

00:54:48,640 --> 00:54:53,200
well uh two base classes of the same

00:54:51,440 --> 00:54:54,799
type in the in the class lattice

00:54:53,200 --> 00:54:57,040
we're going to have two sub objects of

00:54:54,799 --> 00:54:59,280
that same type this might be correct but

00:54:57,040 --> 00:55:01,760
it probably is not

00:54:59,280 --> 00:55:03,200
i'm just think if it's a reference count

00:55:01,760 --> 00:55:05,119
nothing good is going to come of this

00:55:03,200 --> 00:55:07,040
duplicated reference count for a single

00:55:05,119 --> 00:55:08,880
object

00:55:07,040 --> 00:55:11,280
so the best thing to do in a case like

00:55:08,880 --> 00:55:12,880
this is typically just to redesign

00:55:11,280 --> 00:55:14,960
get rid of that reference count and just

00:55:12,880 --> 00:55:16,960
do external reference counting use a

00:55:14,960 --> 00:55:19,839
shared pointer or something like that

00:55:16,960 --> 00:55:20,319
but for some reason you can't then we

00:55:19,839 --> 00:55:22,240
can use

00:55:20,319 --> 00:55:24,160
virtual base classes now virtual base

00:55:22,240 --> 00:55:27,680
classes in my opinion is always

00:55:24,160 --> 00:55:29,119
your your last choice uh but again

00:55:27,680 --> 00:55:31,119
sometimes it's the right choice it's

00:55:29,119 --> 00:55:33,440
just not the right choice very often

00:55:31,119 --> 00:55:35,119
because they do make a lot of things

00:55:33,440 --> 00:55:37,599
very complex

00:55:35,119 --> 00:55:40,079
and we'll see a couple of them right now

00:55:37,599 --> 00:55:42,160
so once i declare a virtual base class

00:55:40,079 --> 00:55:44,079
now i have a single a sub object where

00:55:42,160 --> 00:55:46,799
is the storage inside of a b

00:55:44,079 --> 00:55:50,079
inside of a c answer is typically pasted

00:55:46,799 --> 00:55:52,720
to the end of the complete object

00:55:50,079 --> 00:55:53,119
so a d object looks something like this

00:55:52,720 --> 00:55:55,599
is

00:55:53,119 --> 00:55:58,079
b and c sub objects and it has a single

00:55:55,599 --> 00:56:00,799
a sub object at the end of the storage

00:55:58,079 --> 00:56:02,000
a b object looks different it's a sub

00:56:00,799 --> 00:56:02,960
object is also at the end of the

00:56:02,000 --> 00:56:05,280
complete object

00:56:02,960 --> 00:56:07,760
but obviously at a different offset from

00:56:05,280 --> 00:56:07,760
the beginning

00:56:08,079 --> 00:56:11,440
well this is a bit scary

00:56:12,079 --> 00:56:17,440
so here is a non-virtual bass class

00:56:15,280 --> 00:56:18,960
very simple again it's not guaranteed to

00:56:17,440 --> 00:56:20,720
be here it could be here but the

00:56:18,960 --> 00:56:23,599
compiler knows where it is

00:56:20,720 --> 00:56:25,520
if i have a pointer to a db object the

00:56:23,599 --> 00:56:28,640
compiler knows where to find

00:56:25,520 --> 00:56:30,480
this base class sub-object and

00:56:28,640 --> 00:56:31,839
if i want to access the members the

00:56:30,480 --> 00:56:34,319
compiler knows okay

00:56:31,839 --> 00:56:35,599
i have a db pointer i know where that

00:56:34,319 --> 00:56:37,599
sub-object is

00:56:35,599 --> 00:56:40,160
so i can access it directly and

00:56:37,599 --> 00:56:40,160
efficiently

00:56:40,400 --> 00:56:47,920
that's good

00:56:44,720 --> 00:56:51,440
once i add a virtual base class

00:56:47,920 --> 00:56:54,240
now things get complex now

00:56:51,440 --> 00:56:54,799
assuming the compiler does this the

00:56:54,240 --> 00:56:57,520
shared

00:56:54,799 --> 00:56:58,640
sub sub object is pasted to the end of

00:56:57,520 --> 00:57:01,280
the complete object

00:56:58,640 --> 00:57:02,559
and now we have a v pointer to

00:57:01,280 --> 00:57:05,839
information that tells us

00:57:02,559 --> 00:57:05,839
where to find the subject

00:57:09,280 --> 00:57:14,160
so a db object looks something like this

00:57:12,160 --> 00:57:16,079
i have my db derived class members then

00:57:14,160 --> 00:57:18,079
my base class sub object here

00:57:16,079 --> 00:57:19,200
well what if this db object appears

00:57:18,079 --> 00:57:22,640
inside of another

00:57:19,200 --> 00:57:23,680
class in that case we'll have something

00:57:22,640 --> 00:57:25,680
like this

00:57:23,680 --> 00:57:27,200
the subject is still at the end of the

00:57:25,680 --> 00:57:28,160
complete object but is no longer

00:57:27,200 --> 00:57:30,880
adjacent

00:57:28,160 --> 00:57:32,720
to the db now it's at the end of this

00:57:30,880 --> 00:57:35,839
other object

00:57:32,720 --> 00:57:38,319
so the information that's stored here

00:57:35,839 --> 00:57:39,440
differs from the information here here's

00:57:38,319 --> 00:57:42,160
information that says

00:57:39,440 --> 00:57:43,119
you can find the subject sub-object so

00:57:42,160 --> 00:57:46,160
many bytes

00:57:43,119 --> 00:57:49,680
from this location this says

00:57:46,160 --> 00:57:52,079
same thing except it's a different value

00:57:49,680 --> 00:57:53,119
obviously it's going to be increased by

00:57:52,079 --> 00:57:56,880
however big

00:57:53,119 --> 00:57:59,920
this other part of this

00:57:56,880 --> 00:58:03,280
containing object is

00:57:59,920 --> 00:58:03,280
early implementation again

00:58:03,359 --> 00:58:07,280
worked fairly well and actually stored

00:58:04,960 --> 00:58:10,000
pointers to the sub-object

00:58:07,280 --> 00:58:11,440
it turned out this was uh problematic

00:58:10,000 --> 00:58:12,319
for a number of reasons for one reason

00:58:11,440 --> 00:58:14,400
one thing we couldn't

00:58:12,319 --> 00:58:15,839
bit wise copy an object of this type

00:58:14,400 --> 00:58:17,280
because that would result in bad

00:58:15,839 --> 00:58:20,240
addresses here

00:58:17,280 --> 00:58:20,960
so the the typical implementation is as

00:58:20,240 --> 00:58:23,440
you see here

00:58:20,960 --> 00:58:26,559
we have a virtual pointer even if we

00:58:23,440 --> 00:58:26,559
don't have virtual functions

00:58:26,799 --> 00:58:30,880
so again here's a picture of the

00:58:28,400 --> 00:58:34,640
situation i have a pointer to a db

00:58:30,880 --> 00:58:37,119
the compiler doesn't know statically

00:58:34,640 --> 00:58:38,079
where the sub-object is so it has to go

00:58:37,119 --> 00:58:39,839
over here

00:58:38,079 --> 00:58:42,400
grab the delta and do some delta

00:58:39,839 --> 00:58:42,400
arithmetic

00:58:43,040 --> 00:58:46,400
and things have gotten considerably

00:58:45,520 --> 00:58:49,599
worse

00:58:46,400 --> 00:58:51,440
this temple access is now it's

00:58:49,599 --> 00:58:53,920
looks pretty expensive relatively

00:58:51,440 --> 00:58:56,960
expensive formerly it was quite simple

00:58:53,920 --> 00:59:00,880
but now i have a lot of work to get that

00:58:56,960 --> 00:59:04,000
that delta and apply it

00:59:00,880 --> 00:59:06,640
correctly so

00:59:04,000 --> 00:59:08,960
again um i don't want a bad mouth

00:59:06,640 --> 00:59:10,799
virtual inheritance it does indeed solve

00:59:08,960 --> 00:59:13,040
problems and has been used very

00:59:10,799 --> 00:59:15,440
very effectively by a lot of people but

00:59:13,040 --> 00:59:18,640
it's not your first

00:59:15,440 --> 00:59:20,400
choice if you do use virtual inheritance

00:59:18,640 --> 00:59:21,040
i recommend use it with interface

00:59:20,400 --> 00:59:23,760
classes

00:59:21,040 --> 00:59:24,960
since an interface class doesn't have

00:59:23,760 --> 00:59:26,640
any

00:59:24,960 --> 00:59:29,839
any data except for a virtual function

00:59:26,640 --> 00:59:31,599
pointer um

00:59:29,839 --> 00:59:34,000
very little can go wrong here you won't

00:59:31,599 --> 00:59:35,280
be accessing any data in subject

00:59:34,000 --> 00:59:38,559
for the simple fact that subject does

00:59:35,280 --> 00:59:38,559
not have accessible data

00:59:39,599 --> 00:59:44,880
okay that's the end i was very

00:59:42,720 --> 00:59:47,839
optimistic

00:59:44,880 --> 00:59:48,960
but that's not going to happen uh so

00:59:47,839 --> 00:59:52,640
thank you for your

00:59:48,960 --> 00:59:54,559
your patience and um

00:59:52,640 --> 00:59:55,680
any questions i'd be happy to take them

00:59:54,559 --> 00:59:58,839
or

00:59:55,680 --> 01:00:00,480
um you should know where to find me i

00:59:58,839 --> 01:00:04,240
hope

01:00:00,480 --> 01:00:15,839
just write to me at steveduhurst.com

01:00:04,240 --> 01:00:15,839
you'll find my email address there

01:00:26,240 --> 01:00:28,319

YouTube URL: https://www.youtube.com/watch?v=SShSV_iV1Ko


