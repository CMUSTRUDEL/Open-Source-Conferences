Title: CppCon 2018: “The Landscape and Exciting New Future of Safe Reclamation for High Performance”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
__
Paul McKenney & Maged Michael “The Exciting New Future of Safe Reclamation for High Performance”
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Plans are underway to introduce a new chapter in the C++ standard on concurrency, both literally (in the Specification Chapters) and conceptually. One of the topic in this new chapter is Safe Reclamation, which includes sections on: 
- Atomic specialization for shared_ptr 
- RCU 
- Hazard Pointers 
- Cell 

There are several forms of Safe Reclamation that are now making their way through the C++ Standard Committee. The reference counting-based shared_ptr was introduced in C++11, and then Atomic Shared Pointer in Concurrency TS1. There are now proposals for Hazard Pointers, RCU, and Cell (an abstraction from Google that can build on top of all the other methods) have all advanced out of Study Group 1 (concurrency). Even better, all three proposals have accrued significant usage experience in production. 

Of course, both committee discussions and usage experience have resulted in fundamental changes to the proposals over the last two years. This talk will give an overview and the latest status of the proposals, then expand on the new aspects of hazard pointers and RCU. Some of these experiences are pointing to a bright future beyond lock-free programming towards fast and scalable essential concurrent data structures in demanding production environments. 

In this talk, we will dissect each of these important components and compare and contrast their qualitative features and performance profiles. We will cover the features that will be included in C++20, and those on track for inclusion in Concurrency TS2. We will discuss the important changes from the C++ standardization process and how they may impact your usage. We will demonstrate examples of use of these technique. 

Beyond the current proposals, there are possible interface additions based on user experience in production. We will present newly added features to the hazard pointer method that expand its applicability to general concurrent data structures. The new interface is based on novel algorithmic additions to the method that use reference counting judiciously, with zero reader overhead and minimal writer overheads. We will show the usage of these interface expansions in common data structures, with code examples from the hazard pointer implementation in the Folly open-source library.
— 
Paul McKenney, IBM Linux Technology Center, Beaverton
Distinguished Engineer

Paul E. McKenney is a Distinguished Engineer with the IBM Linux Technology Center, where he maintains the RCU implementation within the Linux kernel. He has been coding for four decades, more than half of that on parallel hardware. His prior lives include the DYNIX/ptx kernel at Sequent, networking protocols at SRI International, and work as a self-employed contract programmer on soft-realtime projects. His hobbies include what passes for running at his age and the usual house-wife-kids habit.


Maged Michael, Facebook
Engineer

Maged Michael is a software engineer at Facebook. He is the inventor of hazard pointers, lock-free malloc and several algorithms for concurrent data structures. He received a Ph.D. in computer science from the University of Rochester. He is an ACM Distinguished Scientist. He is an elected member of the Connecticut Academy of Science and Engineering. He received the 2014 ACM SIGPLAN Most Influential PLDI Paper Award for his paper on Scalable Lock-Free Dynamic Memory Allocation.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,460 --> 00:00:05,709
hello we originally planned to have

00:00:03,879 --> 00:00:08,410
three presenters today Michael Wang

00:00:05,709 --> 00:00:11,170
myself and Megan Michael unfortunately

00:00:08,410 --> 00:00:14,680
the airlines had other ideas and so I'll

00:00:11,170 --> 00:00:17,620
be doing my best to impersonate the in

00:00:14,680 --> 00:00:21,730
personable or a replicable or whatever

00:00:17,620 --> 00:00:23,980
Michael Wong or imitate the amendable

00:00:21,730 --> 00:00:25,210
and whichever in any case we're gonna be

00:00:23,980 --> 00:00:27,810
talking about the exciting new

00:00:25,210 --> 00:00:30,070
performance of safe memory reclamation

00:00:27,810 --> 00:00:31,630
obviously since we have Megan myself

00:00:30,070 --> 00:00:33,970
here we'll be focusing mainly on hazard

00:00:31,630 --> 00:00:37,060
pointers and RCU but we'll mention some

00:00:33,970 --> 00:00:41,559
other possibilities as well and this

00:00:37,060 --> 00:00:43,390
slide is for the usual disclaimer and

00:00:41,559 --> 00:00:44,800
I'll let you decide how the transiti

00:00:43,390 --> 00:00:46,750
works between them being mine or

00:00:44,800 --> 00:00:50,079
Michaels or Michaels then mine or

00:00:46,750 --> 00:00:53,770
whatever you want there we have code

00:00:50,079 --> 00:00:57,370
play legals team slide here and code

00:00:53,770 --> 00:00:59,140
plays slide and now an agenda so we'll

00:00:57,370 --> 00:01:02,079
start off on why we want this in the

00:00:59,140 --> 00:01:05,019
standard in the first place and the

00:01:02,079 --> 00:01:06,850
thing is we need to end in end atomicity

00:01:05,019 --> 00:01:08,799
in pieces we need the information to

00:01:06,850 --> 00:01:09,850
come in to actually be processed and

00:01:08,799 --> 00:01:11,920
come out the other side in some

00:01:09,850 --> 00:01:14,979
organized fashion that's the way of

00:01:11,920 --> 00:01:16,960
information processing and life can be

00:01:14,979 --> 00:01:20,890
uncertain some of you may have learned

00:01:16,960 --> 00:01:22,510
that more emphatically than others but I

00:01:20,890 --> 00:01:23,920
can assure you even for those who have

00:01:22,510 --> 00:01:27,040
learned that lesson fatica lee the life

00:01:23,920 --> 00:01:28,570
is uncertain and trading uncertainty

00:01:27,040 --> 00:01:30,460
accepting greater uncertainty for

00:01:28,570 --> 00:01:32,590
performance is a big part of life and of

00:01:30,460 --> 00:01:35,049
computing and that's primarily what

00:01:32,590 --> 00:01:38,110
we're talking about here so of course

00:01:35,049 --> 00:01:39,850
we've got Schrodinger's cat here being

00:01:38,110 --> 00:01:41,439
simultaneously dead and alive in the box

00:01:39,850 --> 00:01:42,790
gave me an incredible least perspective

00:01:41,439 --> 00:01:47,439
on the life the universe and everything

00:01:42,790 --> 00:01:49,030
and I'm here to tell it to the world the

00:01:47,439 --> 00:01:52,780
thing is even if you have a non

00:01:49,030 --> 00:01:55,140
Schrodinger's cat if the cat changes

00:01:52,780 --> 00:01:58,299
state perhaps less dramatically than

00:01:55,140 --> 00:02:00,610
becoming alive and becoming dead but if

00:01:58,299 --> 00:02:03,310
the cat changes state it takes time for

00:02:00,610 --> 00:02:07,540
that information to propagate from the

00:02:03,310 --> 00:02:09,279
cat to the computer system so whatever

00:02:07,540 --> 00:02:11,829
data you have reflected in the computer

00:02:09,279 --> 00:02:14,770
is out of date by the time it hits the

00:02:11,829 --> 00:02:18,310
computer's memory and we leverage that

00:02:14,770 --> 00:02:20,500
and have a slightly more out-of-date and

00:02:18,310 --> 00:02:22,150
get much better performance and that's

00:02:20,500 --> 00:02:26,410
again what has it pointed to our CR

00:02:22,150 --> 00:02:28,890
about and here's a common pattern that

00:02:26,410 --> 00:02:31,600
happens a lot okay we require a lock

00:02:28,890 --> 00:02:33,250
while holding that lock we've got the

00:02:31,600 --> 00:02:34,630
state pin down because people are

00:02:33,250 --> 00:02:36,280
playing nice and not messing with it

00:02:34,630 --> 00:02:37,960
unless they're holding the lock so we

00:02:36,280 --> 00:02:41,830
compute some property of data protected

00:02:37,960 --> 00:02:43,720
by that lock we then release the lock at

00:02:41,830 --> 00:02:45,070
which point anybody else anywhere in the

00:02:43,720 --> 00:02:47,670
system could acquire the lock and just

00:02:45,070 --> 00:02:50,770
totally change the data arbitrarily

00:02:47,670 --> 00:02:52,990
nevertheless for some period of time

00:02:50,770 --> 00:02:56,350
after releasing the lock we use the

00:02:52,990 --> 00:02:58,960
computed property now this pattern

00:02:56,350 --> 00:03:01,690
happens a lot in this instance I believe

00:02:58,960 --> 00:03:03,790
pikas mentioned this last year is one

00:03:01,690 --> 00:03:05,950
case we're using deferred reclamation

00:03:03,790 --> 00:03:09,910
makes sense you're using out-of-date

00:03:05,950 --> 00:03:11,020
information anyway so why not just go

00:03:09,910 --> 00:03:13,210
with that and get some increased

00:03:11,020 --> 00:03:15,700
performance as a result and these are

00:03:13,210 --> 00:03:16,990
some pro approaches to doing that you

00:03:15,700 --> 00:03:19,240
could also add garbage collectors if you

00:03:16,990 --> 00:03:20,590
wanted to again we'll be focusing on our

00:03:19,240 --> 00:03:23,230
Co and hazard pointers and I guess

00:03:20,590 --> 00:03:24,850
transitively on snapshot there's a

00:03:23,230 --> 00:03:26,470
gentleman over there that would be a

00:03:24,850 --> 00:03:27,930
great person asked about snapshot if you

00:03:26,470 --> 00:03:33,910
want more detail than I'm gonna give you

00:03:27,930 --> 00:03:36,250
Jeffery Romer okay we have a problem

00:03:33,910 --> 00:03:39,580
with fundamental physics here and that's

00:03:36,250 --> 00:03:41,070
the speed of light is finite and so thus

00:03:39,580 --> 00:03:42,730
far I mean there were some interesting

00:03:41,070 --> 00:03:44,290
excitement a few years ago about

00:03:42,730 --> 00:03:47,230
neutrinos that turned out to be a bad

00:03:44,290 --> 00:03:48,370
connector or something like that but as

00:03:47,230 --> 00:03:49,810
far as we know there's no way to

00:03:48,370 --> 00:03:51,520
propagate information from point A to

00:03:49,810 --> 00:03:54,670
point B any faster than the speed of

00:03:51,520 --> 00:03:56,500
light well okay that might be a problem

00:03:54,670 --> 00:03:58,150
but we can just make things smaller

00:03:56,500 --> 00:04:00,880
right I mean if we make an computing

00:03:58,150 --> 00:04:02,820
device B zero size then the speed of

00:04:00,880 --> 00:04:05,110
light is irrelevant

00:04:02,820 --> 00:04:08,350
unfortunately there's also something

00:04:05,110 --> 00:04:09,850
called the atomic nature of matter we

00:04:08,350 --> 00:04:11,380
can split atoms we've been able to do

00:04:09,850 --> 00:04:12,790
that for what seventy years now

00:04:11,380 --> 00:04:15,040
seventy-five years something like that

00:04:12,790 --> 00:04:16,690
the problem is that after you're done

00:04:15,040 --> 00:04:18,160
splitting them the atoms aren't really

00:04:16,690 --> 00:04:19,900
in any kind of shape to be used in

00:04:18,160 --> 00:04:22,479
electronics at least not electronics as

00:04:19,900 --> 00:04:25,270
we know it today and so we've got these

00:04:22,479 --> 00:04:27,880
two laws of physics that are really

00:04:25,270 --> 00:04:29,530
constraining us and

00:04:27,880 --> 00:04:31,480
there have been transistors like this

00:04:29,530 --> 00:04:33,130
with a single row of atoms actually

00:04:31,480 --> 00:04:35,680
produced and used in research

00:04:33,130 --> 00:04:37,270
environments and the last time I saw

00:04:35,680 --> 00:04:39,340
scanning electron microscope of a

00:04:37,270 --> 00:04:41,020
transistor was more than ten years ago

00:04:39,340 --> 00:04:43,630
and it had about that many atoms in the

00:04:41,020 --> 00:04:45,130
base so it's entirely possible that

00:04:43,630 --> 00:04:46,810
they're doing this in production is

00:04:45,130 --> 00:04:50,200
entirely possible this laptop is like

00:04:46,810 --> 00:04:54,310
that for all I know but it's close so we

00:04:50,200 --> 00:04:56,140
can only go so much smaller now Heim

00:04:54,310 --> 00:04:58,150
can't help noticing as I look out on the

00:04:56,140 --> 00:04:59,920
crowd that the average age of the age of

00:04:58,150 --> 00:05:02,320
the audience is somewhat younger than

00:04:59,920 --> 00:05:04,390
myself so perhaps some of you young

00:05:02,320 --> 00:05:06,040
energetic people can solve this problem

00:05:04,390 --> 00:05:07,810
and get something going faster and speed

00:05:06,040 --> 00:05:09,070
of light and smaller than atom and I

00:05:07,810 --> 00:05:11,230
would sleuth that that'd be really cool

00:05:09,070 --> 00:05:14,620
I'd like to know how you do that but

00:05:11,230 --> 00:05:16,300
until you do until you do I'm asserting

00:05:14,620 --> 00:05:18,420
that these things are limiting us and we

00:05:16,300 --> 00:05:20,500
have to live within those limits and

00:05:18,420 --> 00:05:23,680
this is one of the reasons we have

00:05:20,500 --> 00:05:25,060
things like deferred reclamation okay so

00:05:23,680 --> 00:05:26,770
let's take a look at what we have for

00:05:25,060 --> 00:05:29,940
deferred reclamation we'll just take a

00:05:26,770 --> 00:05:33,190
quick look at a few things

00:05:29,940 --> 00:05:34,690
atomic shared pointer in this case we

00:05:33,190 --> 00:05:35,980
can have reference counts essentially

00:05:34,690 --> 00:05:37,810
it's a it's an organized way to

00:05:35,980 --> 00:05:39,160
concurrently reference count in a safe

00:05:37,810 --> 00:05:41,470
way

00:05:39,160 --> 00:05:43,420
make guarantees atomic access they can

00:05:41,470 --> 00:05:45,730
be a implement more efficiently than

00:05:43,420 --> 00:05:48,160
that over there and in fact thanks to

00:05:45,730 --> 00:05:49,990
Anthony Williams we have some pretty

00:05:48,160 --> 00:05:51,460
nice implementations I'm not gonna say

00:05:49,990 --> 00:05:55,030
their optimal but they're better than

00:05:51,460 --> 00:05:56,950
we've had in the past so you can use

00:05:55,030 --> 00:05:59,110
locks if you want mutexes if you will

00:05:56,950 --> 00:06:00,490
there's a is lock free that checks

00:05:59,110 --> 00:06:02,290
things out you can if you have a double

00:06:00,490 --> 00:06:06,340
compare and swap you can do it lock free

00:06:02,290 --> 00:06:08,770
and that's wonderful thing is though if

00:06:06,340 --> 00:06:11,620
you're using this your readers are

00:06:08,770 --> 00:06:13,930
writing to shared memory every time they

00:06:11,620 --> 00:06:16,240
update the reference count and the

00:06:13,930 --> 00:06:17,530
resulting cache misses are really

00:06:16,240 --> 00:06:18,910
painful for your performance and your

00:06:17,530 --> 00:06:20,950
scalability don't get me wrong this is a

00:06:18,910 --> 00:06:22,330
wonderful thing there's a great place

00:06:20,950 --> 00:06:24,970
for it to be used I'm not saying don't

00:06:22,330 --> 00:06:27,460
use it but if you want the ultimate in

00:06:24,970 --> 00:06:31,600
performance for mostly readers this

00:06:27,460 --> 00:06:36,010
might not be your best choice a snapshot

00:06:31,600 --> 00:06:39,240
is kind of an interesting novice

00:06:36,010 --> 00:06:41,860
friendly for some definition of novice

00:06:39,240 --> 00:06:45,669
way of having information that

00:06:41,860 --> 00:06:46,960
at anytime but changes rarely and having

00:06:45,669 --> 00:06:50,229
it so you can get a snapshot at

00:06:46,960 --> 00:06:51,400
information and work on that and have it

00:06:50,229 --> 00:06:53,319
so that you don't have to worry about

00:06:51,400 --> 00:06:54,759
these horrible races between I'm getting

00:06:53,319 --> 00:06:56,500
a reference to this and somebody else is

00:06:54,759 --> 00:06:59,349
getting rid of it it takes care of that

00:06:56,500 --> 00:07:01,960
for you it's a standard differ a

00:06:59,349 --> 00:07:03,939
combination we based on arts you hazard

00:07:01,960 --> 00:07:05,680
pointers or reference count

00:07:03,939 --> 00:07:07,300
they prefer RC which of course I fully

00:07:05,680 --> 00:07:10,569
support other people who have other

00:07:07,300 --> 00:07:12,009
opinions but you use this when you're

00:07:10,569 --> 00:07:16,330
mostly reading and that's true of most

00:07:12,009 --> 00:07:18,460
of these sorts of approaches now we

00:07:16,330 --> 00:07:21,189
strongly discourage but we don't

00:07:18,460 --> 00:07:23,080
prohibit we strongly discourage but

00:07:21,189 --> 00:07:25,900
don't prohibit the trivial

00:07:23,080 --> 00:07:27,069
implementation where when you update you

00:07:25,900 --> 00:07:30,400
just throw the old thing on the floor

00:07:27,069 --> 00:07:32,650
you just leak it the reason we strongly

00:07:30,400 --> 00:07:34,090
discourage it is that having your system

00:07:32,650 --> 00:07:37,750
run out of memory after a while is kind

00:07:34,090 --> 00:07:39,370
of a bad form on the other hand if you

00:07:37,750 --> 00:07:41,289
know you're only gonna update once a

00:07:39,370 --> 00:07:42,969
month and you know that you're going to

00:07:41,289 --> 00:07:46,629
take the system down and reboot it every

00:07:42,969 --> 00:07:48,490
year it's really simple and

00:07:46,629 --> 00:07:51,039
straightforward and what's the problem

00:07:48,490 --> 00:07:53,020
right but again there's trade-offs

00:07:51,039 --> 00:07:55,779
question go ahead can i interject one

00:07:53,020 --> 00:07:59,020
small amendment it's not designed for

00:07:55,779 --> 00:08:00,789
novice users it's designed for users who

00:07:59,020 --> 00:08:02,889
aren't specifically concurrency experts

00:08:00,789 --> 00:08:04,509
okay for general programmers essentially

00:08:02,889 --> 00:08:06,129
very good thank you for your definition

00:08:04,509 --> 00:08:09,300
of novice that I for some definition

00:08:06,129 --> 00:08:11,680
novice there's your definition thank you

00:08:09,300 --> 00:08:14,289
so we don't we aren't talking people

00:08:11,680 --> 00:08:18,310
that well I've seen some very young

00:08:14,289 --> 00:08:19,750
people I mean you know a single-digit

00:08:18,310 --> 00:08:22,089
age that were really impressive with

00:08:19,750 --> 00:08:25,900
concurrency but I wouldn't count on all

00:08:22,089 --> 00:08:28,719
such people having that knowledge okay

00:08:25,900 --> 00:08:31,870
so there's the latest paper there might

00:08:28,719 --> 00:08:34,750
be an update out soon but I'll ask Jeff

00:08:31,870 --> 00:08:36,699
what's gonna be showing up there this is

00:08:34,750 --> 00:08:38,110
a snapshot of the API I'm not going to

00:08:36,699 --> 00:08:41,829
dwell on this but it gives you an idea

00:08:38,110 --> 00:08:44,730
of what's involved and then let's go

00:08:41,829 --> 00:08:46,839
ahead to a new concurrency chapter as

00:08:44,730 --> 00:08:48,760
opposed to a new chapter and concurrency

00:08:46,839 --> 00:08:50,339
although maybe we have that too who

00:08:48,760 --> 00:08:55,300
knows

00:08:50,339 --> 00:08:57,730
so concurrency tf1 was published in 2016

00:08:55,300 --> 00:08:59,529
didn't make the stuff didn't make c7c

00:08:57,730 --> 00:09:04,269
pulao 17 although some of maybe gets

00:08:59,529 --> 00:09:06,429
into c plus 20 and things have changed

00:09:04,269 --> 00:09:08,079
and that's kind of the purpose of a TS

00:09:06,429 --> 00:09:09,459
is to put stuff in there learn how

00:09:08,079 --> 00:09:12,100
people really use it and get something

00:09:09,459 --> 00:09:16,269
that's beaten upon and and actually is

00:09:12,100 --> 00:09:18,040
appropriate for the standard i suppose

00:09:16,269 --> 00:09:20,379
the executor guys might complain about

00:09:18,040 --> 00:09:22,540
having too much learning but

00:09:20,379 --> 00:09:24,670
nevertheless that's the purpose of it

00:09:22,540 --> 00:09:27,879
and that's that's and we've seen that

00:09:24,670 --> 00:09:29,110
happen now TS two will have a number of

00:09:27,879 --> 00:09:30,939
things in it i'm not going to go through

00:09:29,110 --> 00:09:33,220
this in detail new executives there but

00:09:30,939 --> 00:09:34,829
also at the end some of the deferred

00:09:33,220 --> 00:09:37,720
reclamation synchronization primitives

00:09:34,829 --> 00:09:39,429
in in particular we're gonna add a new

00:09:37,720 --> 00:09:40,839
section that's a thirty three point six

00:09:39,429 --> 00:09:44,230
down there in the lower right hand

00:09:40,839 --> 00:09:45,999
corner for you guys in it and we're

00:09:44,230 --> 00:09:47,860
gonna move the atomic specialization and

00:09:45,999 --> 00:09:50,800
shared pointer there we're gonna have

00:09:47,860 --> 00:09:52,569
snapshot jeff stuff will have RC you

00:09:50,800 --> 00:09:54,369
will have hazard pointers and so we'll

00:09:52,569 --> 00:09:57,129
have a TS to it'll have this in it and

00:09:54,369 --> 00:09:58,720
this will be a way for us to see people

00:09:57,129 --> 00:10:01,059
get implementations and see how things

00:09:58,720 --> 00:10:06,730
are used and see what we really need for

00:10:01,059 --> 00:10:07,839
a later is okay so we've got all these

00:10:06,730 --> 00:10:10,089
different ways of doing deferred

00:10:07,839 --> 00:10:15,100
reclamation which should use where

00:10:10,089 --> 00:10:16,600
what's what's going on okay well there's

00:10:15,100 --> 00:10:18,790
a bunch of things they have in common

00:10:16,600 --> 00:10:21,309
they've got a basic idea that similar as

00:10:18,790 --> 00:10:23,079
you can see they have a scope that's

00:10:21,309 --> 00:10:25,929
rather similar word for it word

00:10:23,079 --> 00:10:29,199
identical in fact there's different

00:10:25,929 --> 00:10:30,879
degrees of Cohoes ability they current

00:10:29,199 --> 00:10:35,850
hardware supports them all which is a

00:10:30,879 --> 00:10:38,799
nice thing we have existing API is the

00:10:35,850 --> 00:10:40,389
experience and all that so they're all

00:10:38,799 --> 00:10:42,579
the same so far so what's the point I

00:10:40,389 --> 00:10:46,569
guess and the point is that they do have

00:10:42,579 --> 00:10:48,029
somewhat different properties and I'm

00:10:46,569 --> 00:10:50,110
not gonna go through this in detail

00:10:48,029 --> 00:10:51,509
there's some places where are see you in

00:10:50,110 --> 00:10:54,100
hazard pointers shine very well

00:10:51,509 --> 00:10:57,069
reference County works very well and has

00:10:54,100 --> 00:11:01,480
for longer than I've been alive which is

00:10:57,069 --> 00:11:03,309
saying something in my case and the cool

00:11:01,480 --> 00:11:05,559
thing is that Magid in his section will

00:11:03,309 --> 00:11:06,910
be talking about changes these this

00:11:05,559 --> 00:11:08,920
table is not something that's set in

00:11:06,910 --> 00:11:10,480
stone it changes as things

00:11:08,920 --> 00:11:11,889
long and Megan is actually talking about

00:11:10,480 --> 00:11:14,889
some things that will change its table

00:11:11,889 --> 00:11:19,120
so please stay awake and stay here for

00:11:14,889 --> 00:11:20,709
that and now I'll take off my Michael

00:11:19,120 --> 00:11:22,120
Wong hat and I don't know whether I put

00:11:20,709 --> 00:11:23,560
on a Paul McKinney hat or that's what I

00:11:22,120 --> 00:11:26,199
get when I take off the like a long hat

00:11:23,560 --> 00:11:34,959
but either way I'll go forward to the

00:11:26,199 --> 00:11:36,459
next presentation here and see if I can

00:11:34,959 --> 00:11:39,100
make my mouse work here while looking

00:11:36,459 --> 00:11:42,399
backwards we'll do that and then we'll

00:11:39,100 --> 00:11:45,399
do that and then we'll do that

00:11:42,399 --> 00:11:47,160
ooh the technology worked don't worry it

00:11:45,399 --> 00:11:49,779
won't happen again

00:11:47,160 --> 00:11:52,209
so here we're talking about RC this is

00:11:49,779 --> 00:11:54,040
primarily talking about the state of the

00:11:52,209 --> 00:11:56,470
proposal 40s to the C floss floss

00:11:54,040 --> 00:11:58,060
bindings so we're talking about what the

00:11:56,470 --> 00:11:59,410
API looks like we're going to talk about

00:11:58,060 --> 00:12:01,180
some use cases some these use

00:11:59,410 --> 00:12:06,610
restrictions and if we have times and

00:12:01,180 --> 00:12:08,589
learning opportunities okay so it hasn't

00:12:06,610 --> 00:12:11,790
changed a whole lot

00:12:08,589 --> 00:12:11,790
we have RC you object

00:12:14,550 --> 00:12:20,980
and you use CRT P style inheritance and

00:12:17,890 --> 00:12:22,930
it adds this structure to your data

00:12:20,980 --> 00:12:25,089
structures to be protected there's a

00:12:22,930 --> 00:12:27,459
member function called retire when you

00:12:25,089 --> 00:12:30,220
know that you've removed the object from

00:12:27,459 --> 00:12:32,980
readers you can call that and then when

00:12:30,220 --> 00:12:34,600
it's safe it will delete it and you can

00:12:32,980 --> 00:12:37,180
supply a deleter or take the default as

00:12:34,600 --> 00:12:39,070
you choose we'll look at our C reader on

00:12:37,180 --> 00:12:42,070
the next slide it's a pretty standard ra

00:12:39,070 --> 00:12:43,990
íí- Thai style of thing are you

00:12:42,070 --> 00:12:46,120
synchronize used to be synchronized RC

00:12:43,990 --> 00:12:48,220
you but we've aligned it so we have our

00:12:46,120 --> 00:12:50,649
C u underbar in front of everything and

00:12:48,220 --> 00:12:52,779
it waits for the old Reser's so if you

00:12:50,649 --> 00:12:55,180
had a reader that was in effect when you

00:12:52,779 --> 00:12:57,610
started when you called RC synchronize

00:12:55,180 --> 00:13:01,690
that reader will have a completed before

00:12:57,610 --> 00:13:04,230
RC synchronize returns RC barrier is

00:13:01,690 --> 00:13:06,399
kind of the next stage it's for retires

00:13:04,230 --> 00:13:08,139
what can happen is you might hey you

00:13:06,399 --> 00:13:11,010
know if you just are using delete the

00:13:08,139 --> 00:13:13,060
system delete you don't care because

00:13:11,010 --> 00:13:15,310
whatever it gets to leave it when it

00:13:13,060 --> 00:13:17,500
wants to and everybody's happy but if

00:13:15,310 --> 00:13:19,930
you're using a custom allocator and you

00:13:17,500 --> 00:13:21,850
wanted to destruct that allocator it

00:13:19,930 --> 00:13:22,840
would be a really good thing if all the

00:13:21,850 --> 00:13:24,370
delete is for that out

00:13:22,840 --> 00:13:26,740
cater we're done before you destructed

00:13:24,370 --> 00:13:29,080
the allocator and that's what our shoe

00:13:26,740 --> 00:13:30,760
barrier is for you've got all your

00:13:29,080 --> 00:13:33,070
retires are out there they've executed

00:13:30,760 --> 00:13:34,960
that the leaders might not have yet but

00:13:33,070 --> 00:13:36,940
then you do an R shoe barrier and that

00:13:34,960 --> 00:13:39,100
waits until all the leaders are done and

00:13:36,940 --> 00:13:41,230
at that point it's safe to destruct your

00:13:39,100 --> 00:13:44,380
custom allocator and it can also be used

00:13:41,230 --> 00:13:46,810
for other shutdown style things if you

00:13:44,380 --> 00:13:48,270
don't like intrusive interfaces we have

00:13:46,810 --> 00:13:52,150
a non-intrusive version on the bottom

00:13:48,270 --> 00:13:55,210
you just a free function RC retire there

00:13:52,150 --> 00:13:57,220
of course is never a free lunch and the

00:13:55,210 --> 00:13:58,990
lunch you get to pay for and this one is

00:13:57,220 --> 00:14:01,330
that this might call the allocator a

00:13:58,990 --> 00:14:03,540
high-quality implementation will almost

00:14:01,330 --> 00:14:05,890
never call the allocator but it might

00:14:03,540 --> 00:14:09,760
whereas the top one is guaranteed never

00:14:05,890 --> 00:14:11,320
to call the allocator all right so let's

00:14:09,760 --> 00:14:12,610
look at the are I a reader I'm not gonna

00:14:11,320 --> 00:14:13,870
spend a whole lot of time on this this

00:14:12,610 --> 00:14:17,590
if you've seen lock guard and things

00:14:13,870 --> 00:14:19,960
like that this is very familiar you just

00:14:17,590 --> 00:14:22,840
declare it and it has a constructor it

00:14:19,960 --> 00:14:24,130
has a you can put a defer lock T so you

00:14:22,840 --> 00:14:26,380
can do the usual thing of assigning the

00:14:24,130 --> 00:14:29,110
back and forth in case you get one down

00:14:26,380 --> 00:14:31,560
the subroutine stack somewhere and get

00:14:29,110 --> 00:14:33,940
rid of them later all right

00:14:31,560 --> 00:14:36,550
this diagram shows how these things

00:14:33,940 --> 00:14:38,260
relate I'll go through this really

00:14:36,550 --> 00:14:40,120
quickly but if we'll the slides to be up

00:14:38,260 --> 00:14:41,440
at some point and if you haven't used

00:14:40,120 --> 00:14:43,060
these sorts of things before this is a

00:14:41,440 --> 00:14:46,840
good slide to kind of organize how it

00:14:43,060 --> 00:14:49,120
works and the key thing is if we had a

00:14:46,840 --> 00:14:51,520
reader up there in the upper left hand

00:14:49,120 --> 00:14:53,200
side and some part of that reader the

00:14:51,520 --> 00:14:56,560
constructor for example happened to be

00:14:53,200 --> 00:14:58,420
for a retire well that reader might see

00:14:56,560 --> 00:15:00,940
this state before something was removed

00:14:58,420 --> 00:15:02,470
from the data structure and so we need

00:15:00,940 --> 00:15:05,170
that reader to complete before the

00:15:02,470 --> 00:15:06,610
deletion happens because otherwise the

00:15:05,170 --> 00:15:08,620
reader could end up with a reference to

00:15:06,610 --> 00:15:11,830
something in the free list and that's

00:15:08,620 --> 00:15:15,820
bad form so this is a guarantee it makes

00:15:11,830 --> 00:15:18,790
if your if if your constructor happens

00:15:15,820 --> 00:15:21,580
before the retire RCU guarantees that

00:15:18,790 --> 00:15:23,400
your destructor your readers destructor

00:15:21,580 --> 00:15:25,750
will strongly happen before the deleter

00:15:23,400 --> 00:15:28,330
so if you have a chance of seeing the

00:15:25,750 --> 00:15:30,370
early old version your guarantee be done

00:15:28,330 --> 00:15:33,130
and gone before any destructive thing

00:15:30,370 --> 00:15:35,440
happens like a delete on the other hand

00:15:33,130 --> 00:15:36,400
if the deleter happens before your

00:15:35,440 --> 00:15:38,380
destructor

00:15:36,400 --> 00:15:42,430
that means you can see this thing go

00:15:38,380 --> 00:15:44,350
away then you're guaranteed that the

00:15:42,430 --> 00:15:46,210
retire the corresponding tire retire

00:15:44,350 --> 00:15:48,280
strongly happens before your constructor

00:15:46,210 --> 00:15:49,960
in other words if the lead if you might

00:15:48,280 --> 00:15:52,300
see the deleter the results of the

00:15:49,960 --> 00:15:54,820
deletion you're guaranteed not to see

00:15:52,300 --> 00:15:56,410
the early state where you might have

00:15:54,820 --> 00:15:59,020
been able to reference did the thing

00:15:56,410 --> 00:16:01,360
deleted so that's kind of the two ways

00:15:59,020 --> 00:16:07,000
that ordering happens for our su and

00:16:01,360 --> 00:16:10,570
readers okay so that's the readers we

00:16:07,000 --> 00:16:11,920
have barrier as well and that looks kind

00:16:10,570 --> 00:16:14,500
of like the bottom half but the arrows

00:16:11,920 --> 00:16:17,020
are the other way if a retire happens

00:16:14,500 --> 00:16:17,590
before the RC barrier call then the

00:16:17,020 --> 00:16:19,540
deleter

00:16:17,590 --> 00:16:21,400
is guaranteed is strongly happen before

00:16:19,540 --> 00:16:24,400
the return and this is again the thing

00:16:21,400 --> 00:16:26,860
we want if we have a custom allocator

00:16:24,400 --> 00:16:28,240
that we want to destruct we want to be

00:16:26,860 --> 00:16:30,100
able to wait for all the leaders to get

00:16:28,240 --> 00:16:34,750
done so that everybody's done with it

00:16:30,100 --> 00:16:37,080
and then we can instruct it safely okay

00:16:34,750 --> 00:16:39,970
use cases this is the one in the paper

00:16:37,080 --> 00:16:41,740
we have a name up there at the top and

00:16:39,970 --> 00:16:43,120
we want to be able to access this name

00:16:41,740 --> 00:16:44,710
maybe print it maybe put it somewhere

00:16:43,120 --> 00:16:48,070
whatever copy it hard whatever doing

00:16:44,710 --> 00:16:51,760
that and all we have to do is do an RSU

00:16:48,070 --> 00:16:54,010
reader there the RR that doesn't ra íí-

00:16:51,760 --> 00:16:57,640
which stays around until the close curly

00:16:54,010 --> 00:16:59,290
brace because bozo here hasn't gotten a

00:16:57,640 --> 00:17:00,700
memory over consumed that everybody

00:16:59,290 --> 00:17:03,460
likes and it works we still use them

00:17:00,700 --> 00:17:06,160
everywhere to require sorry or volatile

00:17:03,460 --> 00:17:07,810
if the in linux kernel and once we've

00:17:06,160 --> 00:17:10,480
done that we can use s freely knowing

00:17:07,810 --> 00:17:12,550
it's not going to go away until our r

00:17:10,480 --> 00:17:14,620
goes out of scope in which case anything

00:17:12,550 --> 00:17:17,350
might happen the updater is

00:17:14,620 --> 00:17:19,120
straightforward we do an exchange an

00:17:17,350 --> 00:17:21,870
atomic exchange that puts in the new

00:17:19,120 --> 00:17:24,670
name and returns the old name atomically

00:17:21,870 --> 00:17:27,220
so we have the old name we pass it to

00:17:24,670 --> 00:17:29,230
retire and then in the fullness of time

00:17:27,220 --> 00:17:31,270
it gets deleted when it's safe to do so

00:17:29,230 --> 00:17:35,290
once all the readers running right now

00:17:31,270 --> 00:17:39,700
are done okay so that's kind of the

00:17:35,290 --> 00:17:42,340
basic use case a simple use case we can

00:17:39,700 --> 00:17:44,440
also we may need to clean up so the

00:17:42,340 --> 00:17:46,480
first part all the way down is the same

00:17:44,440 --> 00:17:47,740
aside from comments being removed and

00:17:46,480 --> 00:17:49,900
we've got this new function on the

00:17:47,740 --> 00:17:53,770
bottom shutdown RCU cleanly

00:17:49,900 --> 00:17:55,750
and it evokes our CEO barrier so if we

00:17:53,770 --> 00:17:58,000
have our custom allocator that we've

00:17:55,750 --> 00:17:59,950
been using for all this stuff once we

00:17:58,000 --> 00:18:02,200
get done doing our last update we're not

00:17:59,950 --> 00:18:04,480
doing any readers anymore we can do shut

00:18:02,200 --> 00:18:05,980
down our CEO cleanly and when it comes

00:18:04,480 --> 00:18:07,840
back all the retires will have done

00:18:05,980 --> 00:18:09,250
their delete errs nobody sees in

00:18:07,840 --> 00:18:15,850
allocator anymore so we can safely

00:18:09,250 --> 00:18:17,289
destruct it and this next one is similar

00:18:15,850 --> 00:18:19,480
except we're using the synchronous

00:18:17,289 --> 00:18:21,669
primitive we're using our su synchronize

00:18:19,480 --> 00:18:25,419
in this case we don't have any

00:18:21,669 --> 00:18:27,070
behind-the-scenes action we do the arson

00:18:25,419 --> 00:18:28,330
you synchronize when it comes back all

00:18:27,070 --> 00:18:29,890
the readers are done that might have

00:18:28,330 --> 00:18:32,559
been using that object we can just

00:18:29,890 --> 00:18:34,179
delete it just in line the cool thing

00:18:32,559 --> 00:18:35,919
about this one for user space our CEO

00:18:34,179 --> 00:18:37,630
anyway this different implementation

00:18:35,919 --> 00:18:39,669
might do two different things if you

00:18:37,630 --> 00:18:43,570
only use RC synchronized and never use

00:18:39,669 --> 00:18:47,399
retire for user space RC you then you

00:18:43,570 --> 00:18:49,299
don't have any background threads okay

00:18:47,399 --> 00:18:53,559
we'll talk about that a little more

00:18:49,299 --> 00:18:55,960
later users and restrictions we've been

00:18:53,559 --> 00:18:57,340
having some fun with shutdown the Linux

00:18:55,960 --> 00:18:59,770
kernel is very straightforward at some

00:18:57,340 --> 00:19:02,830
point things just stop and then you

00:18:59,770 --> 00:19:05,620
reboot or something right that makes

00:19:02,830 --> 00:19:06,909
things quite simple on the other hand if

00:19:05,620 --> 00:19:08,590
you're doing this with an application

00:19:06,909 --> 00:19:10,960
and you have some memory leak detection

00:19:08,590 --> 00:19:12,610
tool you might see a whole bunch of

00:19:10,960 --> 00:19:14,380
stuff that looks like it leaked just

00:19:12,610 --> 00:19:17,409
because it hasn't got us the leader

00:19:14,380 --> 00:19:18,970
running yet and so one way of dealing

00:19:17,409 --> 00:19:20,830
with that is have a container wait for

00:19:18,970 --> 00:19:22,450
its context to destruct and defer free

00:19:20,830 --> 00:19:24,940
you can make each containers destructor

00:19:22,450 --> 00:19:26,260
do an RC barrier if you have a huge pile

00:19:24,940 --> 00:19:30,520
of containers and can't run they're

00:19:26,260 --> 00:19:32,950
there destructors concurrently this

00:19:30,520 --> 00:19:36,659
might be a bad idea another approach is

00:19:32,950 --> 00:19:39,190
a split the dist destructor so that

00:19:36,659 --> 00:19:40,899
before you retire you execute the

00:19:39,190 --> 00:19:42,549
destructor leaving just a bare chunk of

00:19:40,899 --> 00:19:45,100
memory and you pass the very chunky

00:19:42,549 --> 00:19:47,110
memory to retire and then at the

00:19:45,100 --> 00:19:49,210
deletion just frees memory it doesn't

00:19:47,110 --> 00:19:53,080
have any other action and can be safely

00:19:49,210 --> 00:19:55,000
deferred if you do this and the user has

00:19:53,080 --> 00:19:56,980
some reference for example an iterator

00:19:55,000 --> 00:19:59,919
then you also have to have the rule that

00:19:56,980 --> 00:20:01,870
those iterators or whatever are totally

00:19:59,919 --> 00:20:02,750
done and taken care of and deleted and

00:20:01,870 --> 00:20:04,970
instructed before

00:20:02,750 --> 00:20:08,150
the iterator before you destruct the

00:20:04,970 --> 00:20:10,280
whole structure there may be some other

00:20:08,150 --> 00:20:12,440
options and that's part of what we hope

00:20:10,280 --> 00:20:13,850
to find out in TS 2 was how else would

00:20:12,440 --> 00:20:16,340
you do this what would what would best

00:20:13,850 --> 00:20:18,260
work again the other approach you have

00:20:16,340 --> 00:20:19,870
is just to never use retire and always

00:20:18,260 --> 00:20:22,130
use our su synchronized in which case

00:20:19,870 --> 00:20:27,140
everything is synchronous and everything

00:20:22,130 --> 00:20:29,480
is there now one trick with this is that

00:20:27,140 --> 00:20:35,480
it is perfectly OK for a deleter itself

00:20:29,480 --> 00:20:38,000
to invoke retire in fact it's possible

00:20:35,480 --> 00:20:39,740
for a deleter to invoke retire which has

00:20:38,000 --> 00:20:43,010
the leader which invokes retire and so

00:20:39,740 --> 00:20:45,350
on forever the things like this actually

00:20:43,010 --> 00:20:47,570
happen in the Linux kernel at which

00:20:45,350 --> 00:20:50,060
point you're never going to ever be able

00:20:47,570 --> 00:20:52,520
to wait for all the leaders to get done

00:20:50,060 --> 00:20:53,870
because there's no end to them one way

00:20:52,520 --> 00:20:55,070
is to have some kind of a communication

00:20:53,870 --> 00:20:57,320
where you say look we're shutting down

00:20:55,070 --> 00:20:59,570
and don't call retire anymore

00:20:57,320 --> 00:21:01,880
another way is at some point maybe do a

00:20:59,570 --> 00:21:03,080
few RC barriers to let people get out of

00:21:01,880 --> 00:21:07,370
the way and then say alright we're done

00:21:03,080 --> 00:21:08,720
and shutdown uncleanly but that's one of

00:21:07,370 --> 00:21:10,130
the reasons this is one of the things

00:21:08,720 --> 00:21:16,160
we'd like to explore further and see

00:21:10,130 --> 00:21:18,650
what the TS says these are a list of

00:21:16,160 --> 00:21:20,600
things that we hope to learn I've got a

00:21:18,650 --> 00:21:22,880
I'm going to just go through a couple of

00:21:20,600 --> 00:21:26,990
them I take a bag of time to go through

00:21:22,880 --> 00:21:28,850
his examples the first one is RC domains

00:21:26,990 --> 00:21:29,930
and one of the things that comes up if

00:21:28,850 --> 00:21:31,610
you have any kind of object oriented

00:21:29,930 --> 00:21:34,130
thing is shouldn't this be object

00:21:31,610 --> 00:21:35,810
oriented omein separate chunks and in

00:21:34,130 --> 00:21:37,670
fact in Linux kernel we have something

00:21:35,810 --> 00:21:39,650
called sleep oval RC you SRC you which

00:21:37,670 --> 00:21:42,140
has domains the thing is you have a

00:21:39,650 --> 00:21:43,520
domain a ANDed vein be the thing that's

00:21:42,140 --> 00:21:45,830
nice about that is you have a

00:21:43,520 --> 00:21:49,010
long-running reader in domain a that

00:21:45,830 --> 00:21:51,950
doesn't delay the update is no main B so

00:21:49,010 --> 00:21:56,690
that's kind of a nice property again

00:21:51,950 --> 00:21:59,780
there's no free lunch and the downside

00:21:56,690 --> 00:22:02,090
of that is that you split the updaters

00:21:59,780 --> 00:22:04,910
and you've also reduced the amortization

00:22:02,090 --> 00:22:07,940
of the update machinery over the number

00:22:04,910 --> 00:22:10,940
of updates in the Linux kernel this is

00:22:07,940 --> 00:22:12,800
not a subtle effect it's not at all hard

00:22:10,940 --> 00:22:14,540
you can take a big tar ball and expand

00:22:12,800 --> 00:22:15,670
it and then delete all the files or I'm

00:22:14,540 --> 00:22:18,900
- our effort

00:22:15,670 --> 00:22:22,240
and you'll end up with thousands of

00:22:18,900 --> 00:22:23,230
updates per grace period and that means

00:22:22,240 --> 00:22:25,360
the overhead of the grace period

00:22:23,230 --> 00:22:28,060
computation is amortized almost nothing

00:22:25,360 --> 00:22:30,160
across those thousands of updates if you

00:22:28,060 --> 00:22:32,040
have lots and lots of domains you've

00:22:30,160 --> 00:22:36,370
reduced the effectiveness of that

00:22:32,040 --> 00:22:38,650
amortization which may be okay but it's

00:22:36,370 --> 00:22:40,300
something you should know it turns out

00:22:38,650 --> 00:22:42,790
SRC was and heavily used we'll look at

00:22:40,300 --> 00:22:44,830
that in the next slide and that's not

00:22:42,790 --> 00:22:48,220
because it came in late it showed up in

00:22:44,830 --> 00:22:49,840
2006 and normal or RC showed up in 2002

00:22:48,220 --> 00:22:52,180
so they've been in the kernel not that

00:22:49,840 --> 00:22:55,030
not that much difference in time both

00:22:52,180 --> 00:22:56,470
all the way over ten years however we

00:22:55,030 --> 00:22:57,930
may need to Bains it could be that

00:22:56,470 --> 00:23:00,520
there's some people who believe that

00:22:57,930 --> 00:23:02,680
gpgpu is you do our CEO and gpgpu is you

00:23:00,520 --> 00:23:04,210
have to have domains maybe they're right

00:23:02,680 --> 00:23:05,530
and there's some people that believe

00:23:04,210 --> 00:23:07,870
that if you're going to do portable

00:23:05,530 --> 00:23:09,460
libraries and generic code you and you

00:23:07,870 --> 00:23:10,750
want to work nicely you need separate

00:23:09,460 --> 00:23:12,880
domains and perhaps they're right too

00:23:10,750 --> 00:23:16,270
and hopefully experience with ts2 will

00:23:12,880 --> 00:23:18,220
give us good answers to these just to

00:23:16,270 --> 00:23:20,740
give you an idea in the Linux kernel if

00:23:18,220 --> 00:23:22,630
you look take all the instances of calls

00:23:20,740 --> 00:23:25,300
to the global RCU API there's almost

00:23:22,630 --> 00:23:27,790
8000 of them if you look at all the

00:23:25,300 --> 00:23:33,040
calls to the SRC API there's less than

00:23:27,790 --> 00:23:34,510
500 of them so that of course keep in

00:23:33,040 --> 00:23:38,140
mind that the Linux kernel is written as

00:23:34,510 --> 00:23:39,670
C not C++ so our mileage might vary if I

00:23:38,140 --> 00:23:42,130
was relying strictly on this kernel

00:23:39,670 --> 00:23:44,710
light on the Linux thing I say don't

00:23:42,130 --> 00:23:49,740
even think about it yet but maybe C++ or

00:23:44,710 --> 00:23:52,660
maybe GPGPU is needed deleter context

00:23:49,740 --> 00:23:54,310
well as we said earlier how the thing is

00:23:52,660 --> 00:23:57,580
is that you have to run the deleter

00:23:54,310 --> 00:23:59,080
somewhere something has to run it and we

00:23:57,580 --> 00:24:02,290
don't specify where that's up to the

00:23:59,080 --> 00:24:03,340
implementation some use cases get really

00:24:02,290 --> 00:24:04,450
bent out of shape if there are

00:24:03,340 --> 00:24:06,040
background threads created

00:24:04,450 --> 00:24:08,680
although the background thread is very

00:24:06,040 --> 00:24:10,870
convenient because you don't have to

00:24:08,680 --> 00:24:14,380
worry about deadlocks or conflicts if

00:24:10,870 --> 00:24:16,780
you are holding a lock across some

00:24:14,380 --> 00:24:17,800
recall to retire that's okay you have

00:24:16,780 --> 00:24:19,540
another thread somewhere that never

00:24:17,800 --> 00:24:21,400
acquires that lock runs as leaders if

00:24:19,540 --> 00:24:23,790
the deleter also acquires that lock no

00:24:21,400 --> 00:24:23,790
harm done

00:24:24,070 --> 00:24:28,240
however if we say we're not gonna have

00:24:26,230 --> 00:24:29,410
background threads we have to run the

00:24:28,240 --> 00:24:31,870
des leaders from somewhere

00:24:29,410 --> 00:24:34,000
that somewhere might be our sea barrier

00:24:31,870 --> 00:24:36,100
which would be it wouldn't any more

00:24:34,000 --> 00:24:37,720
restrictions but our shoe barrier is

00:24:36,100 --> 00:24:38,710
very rare it's normally called only

00:24:37,720 --> 00:24:40,690
during shutdownevents

00:24:38,710 --> 00:24:43,270
so maybe you want to call it from retire

00:24:40,690 --> 00:24:44,950
well at that point suddenly if you're

00:24:43,270 --> 00:24:46,330
holding a lock across a retire which is

00:24:44,950 --> 00:24:48,670
a very common pattern the linux kernel

00:24:46,330 --> 00:24:50,290
and you're acquiring that lock in the

00:24:48,670 --> 00:24:52,510
deleter which is again a common pattern

00:24:50,290 --> 00:24:57,880
in the linux kernel you got a deadlock

00:24:52,510 --> 00:24:59,530
problem so we may need to worry about

00:24:57,880 --> 00:25:01,030
that the other thing is that some

00:24:59,530 --> 00:25:02,530
environments that say we don't want any

00:25:01,030 --> 00:25:04,480
background threads period if you talked

00:25:02,530 --> 00:25:06,010
a little bit we'll say well okay if we

00:25:04,480 --> 00:25:07,810
have control over where and when the

00:25:06,010 --> 00:25:10,090
background threads run that's okay and

00:25:07,810 --> 00:25:14,140
so may be that there's a an approach

00:25:10,090 --> 00:25:16,030
there that works for people and again to

00:25:14,140 --> 00:25:17,560
repeat yet again if you just always use

00:25:16,030 --> 00:25:19,360
our obviously synchronized and never use

00:25:17,560 --> 00:25:26,710
a retire you don't need a background

00:25:19,360 --> 00:25:31,330
thread okay the other thing I'm going to

00:25:26,710 --> 00:25:32,590
skip just for just based on time and we

00:25:31,330 --> 00:25:36,610
went through the clean shutdown fairly

00:25:32,590 --> 00:25:38,890
well so we've got a c++ RCU API we've

00:25:36,610 --> 00:25:40,030
got the memory working well defined

00:25:38,890 --> 00:25:41,740
that's something happened over the last

00:25:40,030 --> 00:25:43,630
several months there was quite a bit of

00:25:41,740 --> 00:25:44,920
controversy over exactly what guarantees

00:25:43,630 --> 00:25:47,500
to be there I think we've got that laid

00:25:44,920 --> 00:25:49,270
out we have some sample use cases and

00:25:47,500 --> 00:25:51,100
I'm looking forward to learning

00:25:49,270 --> 00:25:53,080
experience from the concurrency ts2

00:25:51,100 --> 00:25:55,140
although perhaps not too much learning

00:25:53,080 --> 00:25:57,580
experience but we'll see how it goes

00:25:55,140 --> 00:25:59,860
anyway what we do now is we're gonna

00:25:57,580 --> 00:26:01,420
switch laptops I'm gonna disconnect mine

00:25:59,860 --> 00:26:04,990
we can take questions that people have

00:26:01,420 --> 00:26:11,230
them right now and you know if not talk

00:26:04,990 --> 00:26:13,870
among yourselves or whatever so

00:26:11,230 --> 00:26:19,560
questions comments thoughts Thanks

00:26:13,870 --> 00:26:19,560
guess I need that too yeah

00:26:24,559 --> 00:26:29,419
that is something I don't know for sure

00:26:26,200 --> 00:26:32,330
with something that the initial deadline

00:26:29,419 --> 00:26:35,270
for it I think is past and it's a matter

00:26:32,330 --> 00:26:36,470
of getting getting things set up it's a

00:26:35,270 --> 00:26:37,820
matter of getting all that things

00:26:36,470 --> 00:26:40,280
organized we have to get these proposals

00:26:37,820 --> 00:26:43,610
through the various committees to say

00:26:40,280 --> 00:26:45,950
okay 40s to so we need to talk to the

00:26:43,610 --> 00:26:47,600
library evolution and library and go to

00:26:45,950 --> 00:26:51,409
the next step hopefully this happens in

00:26:47,600 --> 00:26:52,730
San Diego and early November okay thank

00:26:51,409 --> 00:27:01,070
you all very much and I give you Meghan

00:26:52,730 --> 00:27:05,659
Michael Q so I'm gonna talk about that

00:27:01,070 --> 00:27:09,559
has a pointer part and very briefly I'll

00:27:05,659 --> 00:27:12,190
describe the basic algorithm so hazard

00:27:09,559 --> 00:27:16,460
pointer is a single writer multi reader

00:27:12,190 --> 00:27:18,950
pointer and the way what it when when a

00:27:16,460 --> 00:27:22,250
thread writes the address of an object

00:27:18,950 --> 00:27:25,280
to a hazard pointer what is doing it's

00:27:22,250 --> 00:27:28,460
announcing to other threads that if they

00:27:25,280 --> 00:27:33,080
remove that object after the has a

00:27:28,460 --> 00:27:37,309
pointer is set and then they cannot

00:27:33,080 --> 00:27:40,400
reclaim that object until as long as the

00:27:37,309 --> 00:27:42,230
hazard pointer continues to point to the

00:27:40,400 --> 00:27:45,770
object so that's kind of that's the

00:27:42,230 --> 00:27:48,020
central guarantee I have an example here

00:27:45,770 --> 00:27:50,590
of like you know yeah there's like a

00:27:48,020 --> 00:27:54,440
source pointer pointing to an object

00:27:50,590 --> 00:27:58,960
similar to that example using the in the

00:27:54,440 --> 00:28:01,880
proposal papers for the committee so

00:27:58,960 --> 00:28:04,390
from the protector side which is like

00:28:01,880 --> 00:28:08,780
the reader they are they're basically

00:28:04,390 --> 00:28:10,789
setting the has a pointer to the the

00:28:08,780 --> 00:28:13,309
address of the object that they want to

00:28:10,789 --> 00:28:15,260
protect and then they check the source

00:28:13,309 --> 00:28:17,000
that actually the source is still

00:28:15,260 --> 00:28:19,820
pointing to it it's like it's not

00:28:17,000 --> 00:28:23,559
removed the important thing it hasn't

00:28:19,820 --> 00:28:27,559
been removed yet or retired as Paul

00:28:23,559 --> 00:28:29,059
alluded to the API so from the from the

00:28:27,559 --> 00:28:31,250
other side that's that's the guarantee

00:28:29,059 --> 00:28:32,480
it's like okay they they they were able

00:28:31,250 --> 00:28:34,910
to set that point

00:28:32,480 --> 00:28:39,020
before just remove from the point of

00:28:34,910 --> 00:28:40,640
view of the remover they replace a with

00:28:39,020 --> 00:28:45,350
sorry yeah

00:28:40,640 --> 00:28:48,679
the riposte a would be and then if they

00:28:45,350 --> 00:28:50,330
want to reclaim object a they actually

00:28:48,679 --> 00:28:52,790
check are their hazard pointers

00:28:50,330 --> 00:28:54,620
protecting it or not as long as the

00:28:52,790 --> 00:28:55,730
reader is protecting the object then

00:28:54,620 --> 00:28:58,640
they cannot reclaim it

00:28:55,730 --> 00:29:01,520
once they the has appointed changes then

00:28:58,640 --> 00:29:03,010
they are free to reclaim it anyway that

00:29:01,520 --> 00:29:05,059
that's kind of like the basic algorithm

00:29:03,010 --> 00:29:08,750
now we're going to take a look at the

00:29:05,059 --> 00:29:10,610
API for concurrency ts2 and I'll spend

00:29:08,750 --> 00:29:12,410
like some time on that but most of the

00:29:10,610 --> 00:29:17,960
time I'm going to look forward beyond

00:29:12,410 --> 00:29:20,900
that so for the for the ts2 api the main

00:29:17,960 --> 00:29:23,000
like objectives there were we want to

00:29:20,900 --> 00:29:26,090
want something useful that actually

00:29:23,000 --> 00:29:30,080
supports you common use cases and also

00:29:26,090 --> 00:29:33,860
to have like API that actually will help

00:29:30,080 --> 00:29:36,940
us learn from the TS process to get

00:29:33,860 --> 00:29:39,380
feedback on implementation and usage in

00:29:36,940 --> 00:29:42,260
addition also we actually managed to put

00:29:39,380 --> 00:29:44,000
a complex memory model there so that

00:29:42,260 --> 00:29:44,360
session that was a good exercise to do

00:29:44,000 --> 00:29:48,260
that

00:29:44,360 --> 00:29:50,540
as part of this proposal and otherwise

00:29:48,260 --> 00:29:52,340
it's it's mainly minimalist because we

00:29:50,540 --> 00:29:54,320
don't want to put a lot of stuff that

00:29:52,340 --> 00:29:57,440
actually might not be useful and delay

00:29:54,320 --> 00:30:00,980
the process but beyond that we plan to

00:29:57,440 --> 00:30:04,850
add more more details if actually give

00:30:00,980 --> 00:30:08,210
the users more control for reference the

00:30:04,850 --> 00:30:10,790
latest paper is p0 566

00:30:08,210 --> 00:30:13,580
this one is r5 and we're not going to do

00:30:10,790 --> 00:30:16,549
more will add more to that code but then

00:30:13,580 --> 00:30:21,590
the next paper for San Diego meeting

00:30:16,549 --> 00:30:26,470
will be p1 121 so we're preparing that

00:30:21,590 --> 00:30:29,000
for for the mailing so here's the API

00:30:26,470 --> 00:30:30,530
the first thing is domain and I'm not

00:30:29,000 --> 00:30:36,440
going to spend too much time today on

00:30:30,530 --> 00:30:38,510
that basically it is for for for letting

00:30:36,440 --> 00:30:41,179
threads like not interfere with each

00:30:38,510 --> 00:30:44,570
other in cases where the usage pattern

00:30:41,179 --> 00:30:45,980
is actually you know like so different

00:30:44,570 --> 00:30:48,020
is good to have

00:30:45,980 --> 00:30:49,850
separate domains but if the user doesn't

00:30:48,020 --> 00:30:51,980
want to use domains at all they don't

00:30:49,850 --> 00:30:53,780
need to type the word domain so it

00:30:51,980 --> 00:30:57,799
there's a default domain that will be

00:30:53,780 --> 00:31:01,610
used by default cleanup is similar to

00:30:57,799 --> 00:31:04,549
bury our CEO barrier will say reclaim

00:31:01,610 --> 00:31:07,730
everything that is reclaimed that's not

00:31:04,549 --> 00:31:10,220
protected so it's come from not exactly

00:31:07,730 --> 00:31:13,520
the same as our CEO barrier but similar

00:31:10,220 --> 00:31:15,470
in that these are the main questions

00:31:13,520 --> 00:31:18,679
that I'll talk about more about is

00:31:15,470 --> 00:31:20,630
there's a a base class template for

00:31:18,679 --> 00:31:25,970
objects that are protectable by other

00:31:20,630 --> 00:31:28,669
pointers and then there is the the class

00:31:25,970 --> 00:31:31,700
for hazard pointer itself so I'll start

00:31:28,669 --> 00:31:35,600
with the object protectable objects it's

00:31:31,700 --> 00:31:39,620
an it says CRT P inheritance where the

00:31:35,600 --> 00:31:42,440
that ty that derived type is a template

00:31:39,620 --> 00:31:45,110
argument of the base template class

00:31:42,440 --> 00:31:49,280
template it allows us to call the

00:31:45,110 --> 00:31:53,240
functions of the of the the base

00:31:49,280 --> 00:31:55,070
template and to by default get the

00:31:53,240 --> 00:31:59,450
default deleter for the type that

00:31:55,070 --> 00:32:01,460
actually the drive type so here we have

00:31:59,450 --> 00:32:03,169
the customizable do we deliver if

00:32:01,460 --> 00:32:04,280
someone wants to use the default liquor

00:32:03,169 --> 00:32:07,130
then of course they don't need to

00:32:04,280 --> 00:32:10,970
specify that and the main function is

00:32:07,130 --> 00:32:13,610
usually retire saying okay never it you

00:32:10,970 --> 00:32:15,740
know we call return only when the object

00:32:13,610 --> 00:32:17,110
is already removed like nobody can

00:32:15,740 --> 00:32:20,960
protect it anymore

00:32:17,110 --> 00:32:23,570
and by calling retire we're passing the

00:32:20,960 --> 00:32:25,549
responsibility for reclaiming the object

00:32:23,570 --> 00:32:28,840
to the library to the hazard pointer

00:32:25,549 --> 00:32:31,460
library when when it becomes unprotected

00:32:28,840 --> 00:32:35,840
we're going to look at a usage example

00:32:31,460 --> 00:32:39,200
here where we can see here that the

00:32:35,840 --> 00:32:42,590
protected type AB is inheriting from a

00:32:39,200 --> 00:32:46,040
base and we see here that we have to

00:32:42,590 --> 00:32:48,740
remove the object that we want to retire

00:32:46,040 --> 00:32:52,040
we first we remove it and then we call

00:32:48,740 --> 00:32:55,100
the retire and pass it on to the library

00:32:52,040 --> 00:32:57,380
to take care of it for us so that's the

00:32:55,100 --> 00:33:00,020
that's basically interface for op space

00:32:57,380 --> 00:33:04,520
is quite simple and all you

00:33:00,020 --> 00:33:08,050
retire is the main interface the hazard

00:33:04,520 --> 00:33:10,550
pointer class is has a lot more detail

00:33:08,050 --> 00:33:14,630
not all only the highlighted partner

00:33:10,550 --> 00:33:18,620
actually the common case but this is

00:33:14,630 --> 00:33:20,480
kind of what we had that we we with we

00:33:18,620 --> 00:33:24,950
thought we needed like early this year

00:33:20,480 --> 00:33:27,170
in 2018 so there's an empty state and

00:33:24,950 --> 00:33:30,500
actually that's not the common case but

00:33:27,170 --> 00:33:32,840
the default constructor consistent MT

00:33:30,500 --> 00:33:37,130
has a pointer that's kind of like has

00:33:32,840 --> 00:33:40,610
appointed can you can move into so if

00:33:37,130 --> 00:33:43,270
you want to construct a usable has a

00:33:40,610 --> 00:33:47,000
pointer there's a free function for that

00:33:43,270 --> 00:33:50,690
too for a construction that's the one

00:33:47,000 --> 00:33:53,600
you can use to protect objects otherwise

00:33:50,690 --> 00:33:59,030
this this class is movable but not

00:33:53,600 --> 00:34:01,610
copyable and it's the main functions are

00:33:59,030 --> 00:34:04,850
try protect and basically you're giving

00:34:01,610 --> 00:34:06,800
it a pointer and a source and only a

00:34:04,850 --> 00:34:08,659
nature sensible whether it was

00:34:06,800 --> 00:34:12,679
successful or not in protecting the

00:34:08,659 --> 00:34:16,310
pointer and it succeeds if source is

00:34:12,679 --> 00:34:19,070
still pointing to the pointer there's no

00:34:16,310 --> 00:34:21,649
a be a problem here so even if the

00:34:19,070 --> 00:34:25,970
pointer was put again in source that's

00:34:21,649 --> 00:34:28,490
okay protect is simpler interface is

00:34:25,970 --> 00:34:31,190
basically it will return a pointer value

00:34:28,490 --> 00:34:35,690
and with that pointer value is not null

00:34:31,190 --> 00:34:39,530
then it is protected we can if we have

00:34:35,690 --> 00:34:41,750
other means of guaranteeing that an

00:34:39,530 --> 00:34:43,010
object is not removed let's say we have

00:34:41,750 --> 00:34:47,090
a lock

00:34:43,010 --> 00:34:48,560
we can just say reset protection and we

00:34:47,090 --> 00:34:50,390
don't even need to check a source or

00:34:48,560 --> 00:34:53,210
anything the library will listen to us

00:34:50,390 --> 00:34:57,440
that okay we we as users guaranteeing

00:34:53,210 --> 00:35:00,500
that the object is not removed or not

00:34:57,440 --> 00:35:03,950
retired yet and it will start an a

00:35:00,500 --> 00:35:06,770
protect protection epoch for that hazard

00:35:03,950 --> 00:35:10,460
pointer and and and what what it was

00:35:06,770 --> 00:35:13,580
protecting before that if when I enter

00:35:10,460 --> 00:35:19,700
sorry if you want to end protection we

00:35:13,580 --> 00:35:21,590
call it with the null null argument then

00:35:19,700 --> 00:35:26,410
it will just like stop protecting

00:35:21,590 --> 00:35:29,360
whatever it was the other functions are

00:35:26,410 --> 00:35:31,550
like empty and then you can swap to

00:35:29,360 --> 00:35:34,010
hazard pointers where they will continue

00:35:31,550 --> 00:35:38,260
protecting whatever they are protecting

00:35:34,010 --> 00:35:40,850
it's just the they will swap identity

00:35:38,260 --> 00:35:44,630
and if one of them is empty when it's

00:35:40,850 --> 00:35:46,910
not empty they'll swap let's look at the

00:35:44,630 --> 00:35:49,460
usage example with that interface so

00:35:46,910 --> 00:35:51,220
again we're going back to the example I

00:35:49,460 --> 00:35:54,830
showed in the beginning with pseudocode

00:35:51,220 --> 00:35:59,810
but in this case let's we're do we're

00:35:54,830 --> 00:36:02,060
implementing it using this API so the

00:35:59,810 --> 00:36:05,690
protected object as I mentioned it's

00:36:02,060 --> 00:36:11,210
derived from the obvious and it's giving

00:36:05,690 --> 00:36:14,330
the the type as a template argument we

00:36:11,210 --> 00:36:18,050
have that work this is the constructor

00:36:14,330 --> 00:36:22,480
for an active hazard pointer we use that

00:36:18,050 --> 00:36:26,330
as a pointer to put to get a protected

00:36:22,480 --> 00:36:28,550
pointer value from the source once you

00:36:26,330 --> 00:36:31,880
get that we know that that pointer is

00:36:28,550 --> 00:36:35,030
protected and we can use it I don't show

00:36:31,880 --> 00:36:39,110
it here but similar to our C you reader

00:36:35,030 --> 00:36:40,910
this is an array I interface where at

00:36:39,110 --> 00:36:43,700
the end of the scope that has a pointer

00:36:40,910 --> 00:36:48,920
will will really will end protection and

00:36:43,700 --> 00:36:54,140
it will be distracted from the remover

00:36:48,920 --> 00:36:57,050
side from the remover side they remove

00:36:54,140 --> 00:37:00,710
the object and then they call to retire

00:36:57,050 --> 00:37:08,630
so that's that's kind of a a complete

00:37:00,710 --> 00:37:10,880
usable case using this API okay so that

00:37:08,630 --> 00:37:14,180
that's it I mean that's the ts2

00:37:10,880 --> 00:37:17,410
api I wanted to spend more time on on

00:37:14,180 --> 00:37:20,080
the coming part where basically we are

00:37:17,410 --> 00:37:23,390
looking at what questions we want to ask

00:37:20,080 --> 00:37:26,390
for the TS to process the the technical

00:37:23,390 --> 00:37:27,500
specification process to learn from and

00:37:26,390 --> 00:37:30,470
also

00:37:27,500 --> 00:37:33,140
as we go like even in the last let's say

00:37:30,470 --> 00:37:35,120
six or so months we actually we learned

00:37:33,140 --> 00:37:37,850
a lot in that period and but we're we're

00:37:35,120 --> 00:37:41,900
not chasing that interface in in the TS

00:37:37,850 --> 00:37:45,260
proposal so one of the the biggest

00:37:41,900 --> 00:37:48,080
things like topics that actually we

00:37:45,260 --> 00:37:51,530
studied and added is link counting and

00:37:48,080 --> 00:37:54,350
integrating it with hazard pointers so

00:37:51,530 --> 00:37:56,180
here are some motivating examples there

00:37:54,350 --> 00:38:00,620
are current limitations of that

00:37:56,180 --> 00:38:03,470
interface that I showed already the we

00:38:00,620 --> 00:38:06,020
protect single objects we might be able

00:38:03,470 --> 00:38:08,240
to use hand over hand traverse them to

00:38:06,020 --> 00:38:10,730
protect two objects using two hazard

00:38:08,240 --> 00:38:13,640
pointers but we don't we don't protect a

00:38:10,730 --> 00:38:16,100
whole list and that that problem is we

00:38:13,640 --> 00:38:18,860
can get we will end up with conditional

00:38:16,100 --> 00:38:21,320
traversal where at some point say oh we

00:38:18,860 --> 00:38:23,120
cannot proceed let's go back to the head

00:38:21,320 --> 00:38:25,250
of the list and that works in some

00:38:23,120 --> 00:38:29,660
algorithms but what I'm gonna show now

00:38:25,250 --> 00:38:32,270
it doesn't work for this algorithm so in

00:38:29,660 --> 00:38:35,900
this case a thread wants to protect

00:38:32,270 --> 00:38:38,750
object a and it uses the source that the

00:38:35,900 --> 00:38:41,330
head pointer s source so it succeeded of

00:38:38,750 --> 00:38:44,540
course I mean as guaranteed by the API

00:38:41,330 --> 00:38:48,170
for I mean the specification for protect

00:38:44,540 --> 00:38:51,560
it will return a value so unless head is

00:38:48,170 --> 00:38:55,700
null it will protect an object so that's

00:38:51,560 --> 00:38:57,770
fine we protected a actually for for our

00:38:55,700 --> 00:39:01,630
operations for that thread it needs to

00:38:57,770 --> 00:39:04,160
access B specifically be there's no

00:39:01,630 --> 00:39:06,760
there's no wiggle room there we need to

00:39:04,160 --> 00:39:09,890
access B but then in the meantime

00:39:06,760 --> 00:39:11,870
actually a got removed and retired which

00:39:09,890 --> 00:39:15,140
is fine we're protecting it so that's

00:39:11,870 --> 00:39:17,570
fine for a but then also be gots removed

00:39:15,140 --> 00:39:20,590
and retired that's the problem we're not

00:39:17,570 --> 00:39:25,460
protecting a by that hazard pointer and

00:39:20,590 --> 00:39:28,070
now you know the other threads check

00:39:25,460 --> 00:39:31,160
hazard pointers and they find that B is

00:39:28,070 --> 00:39:34,930
unprotected so what do they do they

00:39:31,160 --> 00:39:39,470
reclaim B and the problem now is that

00:39:34,930 --> 00:39:41,000
the thread that needs to access B cannot

00:39:39,470 --> 00:39:42,980
start over from head

00:39:41,000 --> 00:39:46,490
the head pointer has just moved on

00:39:42,980 --> 00:39:49,190
beyond B & B is gone so that that's

00:39:46,490 --> 00:39:51,109
obviously not a good solution of course

00:39:49,190 --> 00:39:54,859
we can combine this with reference

00:39:51,109 --> 00:39:57,050
counting or atomic share pointer that

00:39:54,859 --> 00:39:59,720
sure will work but then that's there's a

00:39:57,050 --> 00:40:01,340
lot of overhead in that unnecessary

00:39:59,720 --> 00:40:04,520
overhead so what I'm gonna talk about

00:40:01,340 --> 00:40:07,609
would be like shortly will will actually

00:40:04,520 --> 00:40:10,130
integrate that in a third point also

00:40:07,609 --> 00:40:11,990
another thing that that can be solved

00:40:10,130 --> 00:40:13,220
with atomic short pointer but right now

00:40:11,990 --> 00:40:17,390
in the ts2

00:40:13,220 --> 00:40:19,820
interface not by hazard pointers is

00:40:17,390 --> 00:40:23,390
uncertain removal so now we have we have

00:40:19,820 --> 00:40:29,119
an and an object a that has two pointers

00:40:23,390 --> 00:40:33,940
to it source 1 and source 2 and some

00:40:29,119 --> 00:40:36,590
thread remove the link from source 1

00:40:33,940 --> 00:40:37,970
does it call retire it doesn't know

00:40:36,590 --> 00:40:41,349
because it doesn't know if there is a

00:40:37,970 --> 00:40:44,720
another concurrent thread that already

00:40:41,349 --> 00:40:47,510
removed the link from source 2 so in

00:40:44,720 --> 00:40:49,250
this case is uncertain removal and has a

00:40:47,510 --> 00:40:51,680
pointer doesn't doesn't have a way

00:40:49,250 --> 00:40:54,440
because we have the retire interface it

00:40:51,680 --> 00:40:56,599
doesn't have a way of knowing when to

00:40:54,440 --> 00:41:00,260
call retire in this case again we can

00:40:56,599 --> 00:41:02,660
use a reference counting it's just

00:41:00,260 --> 00:41:04,640
adding a burden on the on the user or

00:41:02,660 --> 00:41:07,130
overhead if they use atomic share

00:41:04,640 --> 00:41:12,200
pointer so we'd like to integrate that

00:41:07,130 --> 00:41:14,869
in the interface so now I'm going to go

00:41:12,200 --> 00:41:18,349
through an algorithm and and in Congo at

00:41:14,869 --> 00:41:20,750
a high level for dealing with with links

00:41:18,349 --> 00:41:24,740
so we're not doing reference counting as

00:41:20,750 --> 00:41:28,010
in readers counting reader references to

00:41:24,740 --> 00:41:30,140
the objects we're only counting links so

00:41:28,010 --> 00:41:32,560
readers will not be affected by this at

00:41:30,140 --> 00:41:36,020
all there's no overhead for readers

00:41:32,560 --> 00:41:40,210
we're going to manage to link counts one

00:41:36,020 --> 00:41:44,750
for immutable links and one for

00:41:40,210 --> 00:41:46,520
uncertain and/or mutable links and there

00:41:44,750 --> 00:41:49,820
are some exception case where actually

00:41:46,520 --> 00:41:51,830
we we could reason and say some metal

00:41:49,820 --> 00:41:53,469
buildings will not count so I'll mention

00:41:51,830 --> 00:41:55,749
that as we go

00:41:53,469 --> 00:42:03,329
but basically the distinction between

00:41:55,749 --> 00:42:05,920
like immutable links and the rest and

00:42:03,329 --> 00:42:08,140
one way to integrate I mean the way to

00:42:05,920 --> 00:42:09,640
integrate it with hazard point is we're

00:42:08,140 --> 00:42:13,900
gonna think of hazard pointers

00:42:09,640 --> 00:42:17,079
collectively as one link one immutable

00:42:13,900 --> 00:42:20,799
link so that's kind of it will allow us

00:42:17,079 --> 00:42:23,170
to like check hazard pointers in

00:42:20,799 --> 00:42:25,329
parallel without you know we don't care

00:42:23,170 --> 00:42:27,400
which link we decrement when we check

00:42:25,329 --> 00:42:33,039
has our pointers it justit will count as

00:42:27,400 --> 00:42:36,609
one immutable link so for example here

00:42:33,039 --> 00:42:39,849
is like we have a head pointer with a

00:42:36,609 --> 00:42:41,589
certain removal so we will will reason

00:42:39,849 --> 00:42:44,920
about that and say we will discount that

00:42:41,589 --> 00:42:46,660
link but then we have a let's say a FIFO

00:42:44,920 --> 00:42:47,880
list which means that the links are

00:42:46,660 --> 00:42:50,259
immutable

00:42:47,880 --> 00:42:54,219
so in that case like we can see that

00:42:50,259 --> 00:42:57,459
object a has it doesn't really have any

00:42:54,219 --> 00:42:59,890
in inbound immutable links so it will

00:42:57,459 --> 00:43:03,099
have count of one because that one that

00:42:59,890 --> 00:43:03,940
count of one represents hazard pointers

00:43:03,099 --> 00:43:06,309
collectively

00:43:03,940 --> 00:43:08,859
because you know someone might be

00:43:06,309 --> 00:43:11,859
protecting that object so we'll give it

00:43:08,859 --> 00:43:13,119
a count of one when it goes through that

00:43:11,859 --> 00:43:14,920
checking of the head of the pointer and

00:43:13,119 --> 00:43:16,539
we will find out that actually the

00:43:14,920 --> 00:43:18,640
object is doesn't match in over the head

00:43:16,539 --> 00:43:21,759
of pointers then we decrement that count

00:43:18,640 --> 00:43:25,359
of one whether we actually detriment or

00:43:21,759 --> 00:43:27,579
not that's an optimization but logically

00:43:25,359 --> 00:43:27,940
we as if we're we're documenting that

00:43:27,579 --> 00:43:31,449
cam

00:43:27,940 --> 00:43:33,519
well object B it has one inbound

00:43:31,449 --> 00:43:35,380
immutable link and hazard pointers

00:43:33,519 --> 00:43:39,579
counted another count so that that's

00:43:35,380 --> 00:43:44,619
what it has to the other kind of pattern

00:43:39,579 --> 00:43:48,670
is the objects that have inbound mutable

00:43:44,619 --> 00:43:52,059
or uncertain links in this case it will

00:43:48,670 --> 00:43:54,130
have a count of two for them the mutable

00:43:52,059 --> 00:43:55,959
links and account of one for the

00:43:54,130 --> 00:44:03,910
immutable links that is representing

00:43:55,959 --> 00:44:05,690
hazard pointers the we which when when

00:44:03,910 --> 00:44:10,700
we have an object that

00:44:05,690 --> 00:44:13,430
that has inbound inbound links that are

00:44:10,700 --> 00:44:17,390
descending from uncertain links we

00:44:13,430 --> 00:44:20,230
actually treat these links as uncertain

00:44:17,390 --> 00:44:23,990
so just like bear with this kind of

00:44:20,230 --> 00:44:28,310
trust me on that and that's kind of part

00:44:23,990 --> 00:44:31,820
of the algorithm if if we reach the

00:44:28,310 --> 00:44:35,090
point where actually decremented that

00:44:31,820 --> 00:44:37,460
the uncertain links to zero then we know

00:44:35,090 --> 00:44:39,440
that okay now we can retire the object

00:44:37,460 --> 00:44:41,030
but before we retired obviously we

00:44:39,440 --> 00:44:43,700
actually say okay if there are any

00:44:41,030 --> 00:44:46,460
descendant immutable links we're going

00:44:43,700 --> 00:44:53,390
to downgrade them from uncertain to

00:44:46,460 --> 00:44:55,460
being immutable so now so that's when we

00:44:53,390 --> 00:44:58,460
take the decision to actually retire an

00:44:55,460 --> 00:45:01,220
object of course we can retire object

00:44:58,460 --> 00:45:03,200
explicitly if we know for sure that

00:45:01,220 --> 00:45:06,710
there are there's no uncertainty about

00:45:03,200 --> 00:45:10,100
when it is being removed okay now if if

00:45:06,710 --> 00:45:11,720
we retire an object and we find that

00:45:10,100 --> 00:45:13,250
it's unfit it's not protected by any

00:45:11,720 --> 00:45:16,190
hazard pointer like we went through

00:45:13,250 --> 00:45:18,850
plans or pointers then we can we should

00:45:16,190 --> 00:45:22,820
decrement we will decrement the

00:45:18,850 --> 00:45:25,700
immutable link count by one and finally

00:45:22,820 --> 00:45:28,670
when we get to the link immutable link

00:45:25,700 --> 00:45:30,380
count goes to zero then we're going to

00:45:28,670 --> 00:45:33,560
reclaim the object but before we do that

00:45:30,380 --> 00:45:37,100
we're gonna iterate over its descendants

00:45:33,560 --> 00:45:41,810
and like decrement our immutable links

00:45:37,100 --> 00:45:45,250
if it goes to zero we will reclaim the

00:45:41,810 --> 00:45:48,680
descendant and also if they have

00:45:45,250 --> 00:45:51,860
uncertain mutable links I mean if they

00:45:48,680 --> 00:45:54,850
are outgoing uncertain mutable links

00:45:51,860 --> 00:45:58,070
then we unlink the children and that

00:45:54,850 --> 00:46:00,230
might trigger retirements and and so on

00:45:58,070 --> 00:46:02,810
so that's kind of outline of the

00:46:00,230 --> 00:46:06,430
algorithm and it's it's an open source

00:46:02,810 --> 00:46:10,520
code I'm gonna give the link at the end

00:46:06,430 --> 00:46:12,590
so that's like that's the API proposal

00:46:10,520 --> 00:46:15,020
it doesn't quite match the code but

00:46:12,590 --> 00:46:18,650
actually that would be a valid API for

00:46:15,020 --> 00:46:19,190
this for link counting basically will we

00:46:18,650 --> 00:46:20,810
have a base

00:46:19,190 --> 00:46:24,829
templates similar to object base but in

00:46:20,810 --> 00:46:26,690
this case it handles link counting we

00:46:24,829 --> 00:46:30,079
have and we have a function that

00:46:26,690 --> 00:46:32,800
actually increments accounts it takes a

00:46:30,079 --> 00:46:35,750
bool whether it's immutable or not and

00:46:32,800 --> 00:46:38,329
we takes a bool to say is it safe or not

00:46:35,750 --> 00:46:39,380
like do we need atomicity or not so we

00:46:38,329 --> 00:46:41,780
don't need that too misty we can

00:46:39,380 --> 00:46:43,400
actually save an atomic operation atomic

00:46:41,780 --> 00:46:46,310
instruction

00:46:43,400 --> 00:46:49,069
it has retired similar to the objects

00:46:46,310 --> 00:46:52,130
that I showed earlier for the ts2

00:46:49,069 --> 00:46:57,400
interface but also has a link which

00:46:52,130 --> 00:47:00,980
decrement the uncertain link count and

00:46:57,400 --> 00:47:02,780
that might trigger retirement so it's

00:47:00,980 --> 00:47:05,329
kind of implicit retirement as opposed

00:47:02,780 --> 00:47:07,250
to the explicit three time finally

00:47:05,329 --> 00:47:08,990
because of this kind of there are lots

00:47:07,250 --> 00:47:11,089
of decisions being taken inside the

00:47:08,990 --> 00:47:12,800
library so actually there might not be

00:47:11,089 --> 00:47:15,109
we might not have a chance to pass

00:47:12,800 --> 00:47:16,819
custom deleter to the function so

00:47:15,109 --> 00:47:17,270
actually we have a function to set the

00:47:16,819 --> 00:47:21,170
deleter

00:47:17,270 --> 00:47:22,520
before the object is removed so there

00:47:21,170 --> 00:47:25,540
before there's any uncertainty about

00:47:22,520 --> 00:47:29,990
whether the object is removed or not

00:47:25,540 --> 00:47:32,900
from the at the the user-defined part

00:47:29,990 --> 00:47:35,390
they actually have to define a function

00:47:32,900 --> 00:47:37,550
template called push links and that will

00:47:35,390 --> 00:47:39,980
take like will like the library will

00:47:37,550 --> 00:47:42,410
tell it we want you to give us immutable

00:47:39,980 --> 00:47:45,520
links or we're going to give us mutable

00:47:42,410 --> 00:47:48,079
links and it gives us a set that set is

00:47:45,520 --> 00:47:51,040
you know we define it in the

00:47:48,079 --> 00:47:54,290
implementation but then it's a template

00:47:51,040 --> 00:47:55,990
argument and although it needs it should

00:47:54,290 --> 00:48:00,859
support something that is the push

00:47:55,990 --> 00:48:03,200
pointer finally in some cases of like

00:48:00,859 --> 00:48:06,530
heterogeneous kind of like links from

00:48:03,200 --> 00:48:09,020
one type to a different I note of

00:48:06,530 --> 00:48:12,020
different type then we actually use this

00:48:09,020 --> 00:48:14,270
cover has a pointer source which it's

00:48:12,020 --> 00:48:19,160
main functionalities I mean it behaves

00:48:14,270 --> 00:48:24,290
like a link but also at destruction it

00:48:19,160 --> 00:48:26,150
unlinks the distance so we're going to

00:48:24,290 --> 00:48:29,720
look at a couple of examples here like

00:48:26,150 --> 00:48:33,069
these are real life examples like

00:48:29,720 --> 00:48:35,619
heavily you know use code

00:48:33,069 --> 00:48:41,429
one is an unbounded queue it's in the

00:48:35,619 --> 00:48:45,660
open source Facebook folly library and

00:48:41,429 --> 00:48:50,140
basically it's the FIFO queue is

00:48:45,660 --> 00:48:52,719
composed of a FIFO singly linked list of

00:48:50,140 --> 00:48:56,499
segments each segment like supports like

00:48:52,719 --> 00:48:58,869
some number of Q elements so the cost of

00:48:56,499 --> 00:49:02,410
construction destruction is amortized

00:48:58,869 --> 00:49:05,140
over like let's say hundreds of elements

00:49:02,410 --> 00:49:08,009
we're always appending to the tails so

00:49:05,140 --> 00:49:10,809
the links are immutable in this case

00:49:08,009 --> 00:49:14,169
head is mutable but it's certain so

00:49:10,809 --> 00:49:16,569
actually we can discount it but we we as

00:49:14,169 --> 00:49:18,789
users or like library writers in this

00:49:16,569 --> 00:49:20,769
case of the unbound to with it

00:49:18,789 --> 00:49:24,400
responsibility for calling retire

00:49:20,769 --> 00:49:28,150
explicitly so that will ignore the link

00:49:24,400 --> 00:49:31,089
account forehead and head never

00:49:28,150 --> 00:49:34,179
overtakes tails so we will we will not

00:49:31,089 --> 00:49:36,669
care about tails so doesn't matter in

00:49:34,179 --> 00:49:39,609
the count so now you can look at here

00:49:36,669 --> 00:49:43,209
like the first one has count of 1 the

00:49:39,609 --> 00:49:46,329
rest of the the Q has count of 2 because

00:49:43,209 --> 00:49:48,969
as I mentioned has a pointers count for

00:49:46,329 --> 00:49:54,519
the collectively count for one immutable

00:49:48,969 --> 00:49:56,829
link for each object we do the initial

00:49:54,519 --> 00:49:59,739
and final final increments and

00:49:56,829 --> 00:50:02,709
decrements not atomically so actually

00:49:59,739 --> 00:50:03,999
that saves a lot of atomic operations so

00:50:02,709 --> 00:50:05,799
actually all what we need in a lifetime

00:50:03,999 --> 00:50:08,859
of each segment is one atomic

00:50:05,799 --> 00:50:12,609
instruction in the common case in case

00:50:08,859 --> 00:50:16,509
like without I just be having contention

00:50:12,609 --> 00:50:20,799
at the time of decrementing accounts and

00:50:16,509 --> 00:50:23,799
we can reclaim many segments in one

00:50:20,799 --> 00:50:25,689
check of hazard pointers I'm gonna go

00:50:23,799 --> 00:50:31,390
through an example here of like what

00:50:25,689 --> 00:50:35,229
happens to this this Q it has like four

00:50:31,390 --> 00:50:37,839
elements we're gonna like remove three

00:50:35,229 --> 00:50:40,150
of these segments they are removed and

00:50:37,839 --> 00:50:42,219
retired we call retire explicitly so you

00:50:40,150 --> 00:50:45,349
can see that the counts are still you

00:50:42,219 --> 00:50:47,930
know as they we're now we

00:50:45,349 --> 00:50:49,700
check the hazard pointers and we know

00:50:47,930 --> 00:50:51,920
that we don't guarantee that we're gonna

00:50:49,700 --> 00:50:54,229
check them in the order ABC that's fine

00:50:51,920 --> 00:50:56,869
in whatever order so in this case we

00:50:54,229 --> 00:50:59,359
check B let's say B is checked first and

00:50:56,869 --> 00:51:01,960
we find that it's not protected so we

00:50:59,359 --> 00:51:04,339
decrement the count from 2 to 1 and

00:51:01,960 --> 00:51:07,249
because it's wha

00:51:04,339 --> 00:51:08,690
then now we check a a is is also

00:51:07,249 --> 00:51:12,619
unprotected

00:51:08,690 --> 00:51:16,130
but then the count is already 1 so we is

00:51:12,619 --> 00:51:17,630
is reclaim Irbil right away so when that

00:51:16,130 --> 00:51:20,509
happens as I mentioned in the algorithm

00:51:17,630 --> 00:51:22,460
we go through iteratively over its

00:51:20,509 --> 00:51:25,609
descendants and reclaim whatever is

00:51:22,460 --> 00:51:28,009
claimable or decrement accounts for for

00:51:25,609 --> 00:51:30,259
what has more count so in this case we

00:51:28,009 --> 00:51:32,869
find that ABC claimable

00:51:30,259 --> 00:51:36,200
will claim B right away when we reclaim

00:51:32,869 --> 00:51:39,049
B that triggers decrementing the count

00:51:36,200 --> 00:51:42,650
for c so it went from 2 to 1 now and

00:51:39,049 --> 00:51:45,079
finally we reclaim a 4 that's for a now

00:51:42,650 --> 00:51:48,739
we're checking C and we find that C is

00:51:45,079 --> 00:51:50,690
unprotected see is reclaim Abell so we

00:51:48,739 --> 00:51:53,450
look at its descendants with the crime

00:51:50,690 --> 00:51:58,009
and account for D it went from 2 to 1

00:51:53,450 --> 00:52:01,219
and finally we can reclaim C so it we

00:51:58,009 --> 00:52:03,049
were able to reclaim and you know I mean

00:52:01,219 --> 00:52:05,569
basically whatever is ready any number

00:52:03,049 --> 00:52:07,430
of segments in one check up has a

00:52:05,569 --> 00:52:09,319
pointer whereas if we used something

00:52:07,430 --> 00:52:13,989
like atomic share pointer we would have

00:52:09,319 --> 00:52:17,089
to wait for like one one at a time

00:52:13,989 --> 00:52:24,019
checking of hazard pointers to reclaim

00:52:17,089 --> 00:52:25,789
that segments in that queue ok that's so

00:52:24,019 --> 00:52:28,489
as I mentioned we take one atomic

00:52:25,789 --> 00:52:31,089
instruction per segment and we reclaim a

00:52:28,489 --> 00:52:33,229
large number of segments in one check

00:52:31,089 --> 00:52:35,359
now we look at a different example

00:52:33,229 --> 00:52:38,660
that's also from the fawley library it's

00:52:35,359 --> 00:52:40,940
the concurrent hash map and it's a hash

00:52:38,660 --> 00:52:43,249
table with chaining each bucket is a

00:52:40,940 --> 00:52:45,819
singly linked list so it will look like

00:52:43,249 --> 00:52:49,789
that and these are kind of the counts

00:52:45,819 --> 00:52:53,539
the bucket heads are uncertain mutable

00:52:49,789 --> 00:52:56,719
links so they count for one and then the

00:52:53,539 --> 00:52:58,030
has a pointer library in general I mean

00:52:56,719 --> 00:53:00,520
has a pointers in general count

00:52:58,030 --> 00:53:03,240
for one the links between the threads

00:53:00,520 --> 00:53:07,720
like from B to a between the nodes

00:53:03,240 --> 00:53:11,320
counts also as mutable links so that's

00:53:07,720 --> 00:53:15,880
why we have discounts one and one for B

00:53:11,320 --> 00:53:17,110
and a and discounts are like set non

00:53:15,880 --> 00:53:20,290
atomically they don't need to be a

00:53:17,110 --> 00:53:23,320
comment anyway nodes may be linked from

00:53:20,290 --> 00:53:25,450
multiple bucket arrays resizing so for

00:53:23,320 --> 00:53:28,330
example let's say we resize and change

00:53:25,450 --> 00:53:31,360
the bucket from X to Y and now we keep

00:53:28,330 --> 00:53:33,700
links so because we support iterators so

00:53:31,360 --> 00:53:35,770
actually we'll keep that bucket alive if

00:53:33,700 --> 00:53:38,800
there's an iterator that's protecting it

00:53:35,770 --> 00:53:41,320
it's by the way each has three hazard

00:53:38,800 --> 00:53:43,570
pointers I'll mention that so now we can

00:53:41,320 --> 00:53:47,100
see what happened here B has count of

00:53:43,570 --> 00:53:50,800
two there's two inbound on certain links

00:53:47,100 --> 00:53:53,620
the removal of body erases is certain so

00:53:50,800 --> 00:53:55,840
with it we don't use linked we just use

00:53:53,620 --> 00:53:59,380
the the objects the original one that is

00:53:55,840 --> 00:54:01,800
in th - but links to nodes are uncertain

00:53:59,380 --> 00:54:04,930
so we use the option based link and

00:54:01,800 --> 00:54:07,600
because bucket arrays and nodes are not

00:54:04,930 --> 00:54:09,340
the same type so actually we use the

00:54:07,600 --> 00:54:11,800
links from the bucket array to the nodes

00:54:09,340 --> 00:54:15,430
to the head of the node is a has a

00:54:11,800 --> 00:54:18,760
pointer source I mention for traversal

00:54:15,430 --> 00:54:21,160
we use three hazard pointers and the

00:54:18,760 --> 00:54:23,230
initial and final counts don't need

00:54:21,160 --> 00:54:26,500
atomicity so actually we could end up

00:54:23,230 --> 00:54:28,660
with in a common case doing zero atomic

00:54:26,500 --> 00:54:31,090
instructions for reference counting for

00:54:28,660 --> 00:54:35,740
link account and read only operations

00:54:31,090 --> 00:54:38,550
have zero overhead for link counting and

00:54:35,740 --> 00:54:41,200
no but but then this is a caveat is that

00:54:38,550 --> 00:54:42,670
nodes are are retired one at a time

00:54:41,200 --> 00:54:45,190
because of the uncertainty of the

00:54:42,670 --> 00:54:47,500
removal so actually we have to keep this

00:54:45,190 --> 00:54:49,690
link list short we cannot have like

00:54:47,500 --> 00:54:51,760
thousands of nodes in the so I mean

00:54:49,690 --> 00:54:53,400
which is a that's why it's a hashmap we

00:54:51,760 --> 00:54:56,080
actually want to have the load factor

00:54:53,400 --> 00:54:58,570
good enough that it doesn't have long

00:54:56,080 --> 00:55:00,550
lists I'm gonna go through an example

00:54:58,570 --> 00:55:03,490
which will demonstrate this come the

00:55:00,550 --> 00:55:05,580
lifetime of a bunch of operations so we

00:55:03,490 --> 00:55:11,859
start here with an empty bucket head X

00:55:05,580 --> 00:55:14,739
we insert a test count 1 1 as

00:55:11,859 --> 00:55:17,799
as expected now we we push be life--all

00:55:14,739 --> 00:55:22,299
and now it has one one now we do

00:55:17,799 --> 00:55:24,789
resizing so an A and B happen to be a

00:55:22,299 --> 00:55:28,930
rehash to the same bucket so now we have

00:55:24,789 --> 00:55:32,049
an uber bucket why that that is pointing

00:55:28,930 --> 00:55:34,210
to be an a but then X still points to

00:55:32,049 --> 00:55:37,269
them so that's why the the can four be

00:55:34,210 --> 00:55:39,819
increased there could be some iterator

00:55:37,269 --> 00:55:44,470
that's protecting X so X might be still

00:55:39,819 --> 00:55:46,089
alive and and traversable now let's

00:55:44,470 --> 00:55:48,489
let's continue from there the next

00:55:46,089 --> 00:55:50,920
operation let's say insert C so now we

00:55:48,489 --> 00:55:52,869
have C is pointing to be instead of the

00:55:50,920 --> 00:55:57,970
bucket head but still it goes with

00:55:52,869 --> 00:56:00,940
counts of 1 & 1 now we remove B and you

00:55:57,970 --> 00:56:03,849
notice that we can't really retire B

00:56:00,940 --> 00:56:09,339
because it has an uncertain sorry it has

00:56:03,849 --> 00:56:12,309
an uncertain link then then we take from

00:56:09,339 --> 00:56:15,460
there and actually remove a then it

00:56:12,309 --> 00:56:19,630
becomes also a is kind of removed but

00:56:15,460 --> 00:56:21,999
not retired now we check that has a

00:56:19,630 --> 00:56:24,970
pointers and find that X is not

00:56:21,999 --> 00:56:28,119
protected so we look at the descendants

00:56:24,970 --> 00:56:32,980
we unlink B and now B is completely

00:56:28,119 --> 00:56:35,289
retired and then we reclaim X now we

00:56:32,980 --> 00:56:38,559
check the has a pointer again and we

00:56:35,289 --> 00:56:40,480
find that B is reclaim Irbil so we

00:56:38,559 --> 00:56:42,430
reclaim it and unlink a and now a

00:56:40,480 --> 00:56:44,170
becomes retired and finally we do

00:56:42,430 --> 00:56:48,190
another check and find that a is

00:56:44,170 --> 00:56:50,380
reclaiming reclaim a ok so that this

00:56:48,190 --> 00:56:53,529
kind of like describes the the link

00:56:50,380 --> 00:56:56,319
counting algorithm and exact are real

00:56:53,529 --> 00:56:59,739
like complicated use cases that depend

00:56:56,319 --> 00:57:03,009
on it so that's a good extension of the

00:56:59,739 --> 00:57:04,720
tears to API these are I'm not going to

00:57:03,009 --> 00:57:07,089
go through this but this is kind of a

00:57:04,720 --> 00:57:09,940
list of questions a lot of them are in

00:57:07,089 --> 00:57:12,940
common with RCU that pull when went

00:57:09,940 --> 00:57:14,289
through and and some are not but but

00:57:12,940 --> 00:57:18,190
it's kind of these are these are

00:57:14,289 --> 00:57:20,890
questions as you want to learn in in the

00:57:18,190 --> 00:57:25,029
TS process finally these are references

00:57:20,890 --> 00:57:27,609
the paper numbers are 5 6 & 1 1 2 1

00:57:25,029 --> 00:57:29,949
and the fawley libraries on github and

00:57:27,609 --> 00:57:33,309
there's that the general has a pointer

00:57:29,949 --> 00:57:35,489
implementation and also the link the one

00:57:33,309 --> 00:57:37,929
with that supports link counting and

00:57:35,489 --> 00:57:40,809
examples of the unbounded queue and

00:57:37,929 --> 00:57:42,459
concurrent hash map there's also a test

00:57:40,809 --> 00:57:44,669
case that is kind of contrived but it's

00:57:42,459 --> 00:57:49,659
actually very interesting that it has

00:57:44,669 --> 00:57:53,349
uncertain links to in this predecessor

00:57:49,659 --> 00:57:57,130
of immutable links and actually we are

00:57:53,349 --> 00:57:59,409
able to retire a whole structure in one

00:57:57,130 --> 00:58:01,749
pass and also we can reclaim a whole

00:57:59,409 --> 00:58:06,419
structure in one path even even though

00:58:01,749 --> 00:58:08,859
even though it's uncertain remote and

00:58:06,419 --> 00:58:11,739
thank you I don't know if we have time

00:58:08,859 --> 00:58:13,829
for a question or two and Paul please if

00:58:11,739 --> 00:58:16,230
anybody has questions for me or Paul

00:58:13,829 --> 00:58:21,650
thanks

00:58:16,230 --> 00:58:21,650

YouTube URL: https://www.youtube.com/watch?v=nvfzQAUpunI


