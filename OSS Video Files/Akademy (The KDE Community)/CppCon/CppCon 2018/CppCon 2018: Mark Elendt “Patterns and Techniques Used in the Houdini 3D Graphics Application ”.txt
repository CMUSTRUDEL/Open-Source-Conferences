Title: CppCon 2018: Mark Elendt “Patterns and Techniques Used in the Houdini 3D Graphics Application ”
Publication date: 2018-09-26
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Earlier this year, Mark Elendt and SideFX were awarded the Scientific and Technical Award of Merit for their continued work and innovation on the Houdini Visual Effects software package. 

Not only has Houdini been used in all of the Visual Effects Academy Award winning films of the past 10 years, but it has also been used for television shows like Game of Thrones and Stranger Things as well as content creation for many AAA video games, and even for scientific visualization. 

Houdini artists are tasked with creating amazing, never before seen visual effects. They constantly push both performance and scale in the software. Since the early 1990's Houdini's C++ architecture has provided a flexible platform that has enabled artists from around the world to create their vision. 

Mark will discuss some of the patterns and approaches that have been used in Houdini to meet the demands of production, from the early days of dealing with c-front to embracing modern features provided by modern C++.
— 
Mark Elendt
SideFX

Mark Elendt has been an active practitioner at SideFX software for over 25 years. He works primarily on low level libraries for Houdini but also is the chief author of the mantra production rendering engine. He was honored to receive the Scientific and Technical Academy Award of Merit for his contributions to Houdini.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,670 --> 00:00:28,720
[Music]

00:00:24,090 --> 00:00:30,820
so mark has been working in C++ at side

00:00:28,720 --> 00:00:32,860
effects software for over 25 years he

00:00:30,820 --> 00:00:34,510
worked primarily on low-level libraries

00:00:32,860 --> 00:00:37,510
for the visual effects application

00:00:34,510 --> 00:00:39,550
Houdini he is also the chief author of

00:00:37,510 --> 00:00:43,530
the mantra production rendering engine

00:00:39,550 --> 00:00:43,530
so let's welcome mark on stage

00:00:48,180 --> 00:00:53,199
thank you very much price for the

00:00:50,260 --> 00:00:55,899
wonderful introduction and what I'd like

00:00:53,199 --> 00:00:58,510
to point out was that that was the

00:00:55,899 --> 00:01:01,480
scientific and technical Academy Awards

00:00:58,510 --> 00:01:03,910
what there weren't very many actors in

00:01:01,480 --> 00:01:06,430
the audience it was a bunch of film

00:01:03,910 --> 00:01:08,380
scientists and engineers there were two

00:01:06,430 --> 00:01:12,149
pieces of hardware that were recognized

00:01:08,380 --> 00:01:15,910
at the Shotover K one camera and the

00:01:12,149 --> 00:01:17,679
Chapman telescope Hydra scope camera

00:01:15,910 --> 00:01:20,979
crane and that's really cool because you

00:01:17,679 --> 00:01:24,039
can take that crane underwater I thought

00:01:20,979 --> 00:01:25,869
that was me but with those two pieces of

00:01:24,039 --> 00:01:28,810
hardware there were also a whole bunch

00:01:25,869 --> 00:01:31,060
of people software developers who were

00:01:28,810 --> 00:01:33,940
recognized so these six groups of people

00:01:31,060 --> 00:01:36,099
are all C++ programmers and that's sort

00:01:33,940 --> 00:01:37,720
of why they're that the audience reacted

00:01:36,099 --> 00:01:40,090
the way they did at the academy award

00:01:37,720 --> 00:01:44,619
speech so they they all recognized what

00:01:40,090 --> 00:01:48,729
the the C++ 11 actually how it changed

00:01:44,619 --> 00:01:53,289
our industry and so to talk a little bit

00:01:48,729 --> 00:01:56,550
about I'm Houdini has been around for a

00:01:53,289 --> 00:01:59,890
very long time it's always be in C++

00:01:56,550 --> 00:02:02,200
it's being used in over 700 films it's

00:01:59,890 --> 00:02:05,229
actually received five scientific and

00:02:02,200 --> 00:02:08,560
technical Academy Awards only one award

00:02:05,229 --> 00:02:10,869
of merit and it's been used in all the

00:02:08,560 --> 00:02:13,840
visual effects films that one of have

00:02:10,869 --> 00:02:16,569
won Oscars except for one year in the

00:02:13,840 --> 00:02:24,989
past how many years does it say they're

00:02:16,569 --> 00:02:27,390
20 years and so to to preface my talk

00:02:24,989 --> 00:02:29,640
this is a sort of overview of the talk

00:02:27,390 --> 00:02:32,620
I'm going to talk a little bit about

00:02:29,640 --> 00:02:34,930
side effects and our product I'm going

00:02:32,620 --> 00:02:36,730
to talk a little bit about

00:02:34,930 --> 00:02:40,720
the industry and then I'm going to get

00:02:36,730 --> 00:02:45,220
into the nitty-gritty of the C++ and how

00:02:40,720 --> 00:02:47,530
we abuse C++ and so to to begin my talk

00:02:45,220 --> 00:02:51,280
I have to go back to the beginning of

00:02:47,530 --> 00:02:53,439
the computer graphics industry and that

00:02:51,280 --> 00:02:54,970
that goes back before side-effects

00:02:53,439 --> 00:02:57,159
existed which is my company

00:02:54,970 --> 00:02:58,599
it goes back before I started as side

00:02:57,159 --> 00:02:59,140
effects back before side effects has

00:02:58,599 --> 00:03:02,890
started

00:02:59,140 --> 00:03:05,980
back to the 1980s the early 1980s in

00:03:02,890 --> 00:03:09,310
fact and some of you may be too young to

00:03:05,980 --> 00:03:11,290
remember the 1980s or or weren't even

00:03:09,310 --> 00:03:14,109
born yet and so just to let you know

00:03:11,290 --> 00:03:21,750
what people look like this is how people

00:03:14,109 --> 00:03:24,609
look like in the 1980s and in 1982

00:03:21,750 --> 00:03:26,769
Disney released a movie called Tron and

00:03:24,609 --> 00:03:29,260
it was sort of groundbreaking because it

00:03:26,769 --> 00:03:31,540
had a lot of computer graphics in it at

00:03:29,260 --> 00:03:33,549
the time this is these are all the

00:03:31,540 --> 00:03:35,799
computer graphics companies in the world

00:03:33,549 --> 00:03:37,629
at the time and every single one of them

00:03:35,799 --> 00:03:42,699
contributed to the computer graphics

00:03:37,629 --> 00:03:45,609
that was shown in Tron so at the time

00:03:42,699 --> 00:03:47,260
all those graphics companies built their

00:03:45,609 --> 00:03:49,030
own software so they all wrote their own

00:03:47,260 --> 00:03:51,069
software there was no off-the-shelf

00:03:49,030 --> 00:03:52,389
software that they could use in fact

00:03:51,069 --> 00:03:54,699
some of them actually built their own

00:03:52,389 --> 00:03:57,340
hardware as well a triple-i there built

00:03:54,699 --> 00:03:59,019
their own machines triple I was sort of

00:03:57,340 --> 00:04:01,150
the outlier and that group of companies

00:03:59,019 --> 00:04:03,190
because they used Lisp as their

00:04:01,150 --> 00:04:09,579
programming language all the others you

00:04:03,190 --> 00:04:11,829
see the important thing for in terms of

00:04:09,579 --> 00:04:15,489
side effects is history is the fact that

00:04:11,829 --> 00:04:18,099
omnibus was founded in 1982 omnibus was

00:04:15,489 --> 00:04:20,639
founded in Toronto where I'm from and

00:04:18,099 --> 00:04:24,610
where side-effects is is from and

00:04:20,639 --> 00:04:26,260
omnibus was very successful in the early

00:04:24,610 --> 00:04:28,810
days they were so successful that they

00:04:26,260 --> 00:04:30,280
actually bought out digital productions

00:04:28,810 --> 00:04:36,330
and they bought up Robert Abel and

00:04:30,280 --> 00:04:36,330
associates and they they with with those

00:04:40,999 --> 00:04:47,399
they were in the early days they had

00:04:44,219 --> 00:04:49,169
fantastic equipment like a VAX and that

00:04:47,399 --> 00:04:50,819
there's a cray over there and there's a

00:04:49,169 --> 00:04:53,519
hard disk platter that stores almost

00:04:50,819 --> 00:04:57,929
five megabytes of data very very

00:04:53,519 --> 00:05:01,319
impressive hardware at the time they did

00:04:57,929 --> 00:05:03,809
a lot of groundbreaking early computer

00:05:01,319 --> 00:05:06,479
graphics flight of the navigator flying

00:05:03,809 --> 00:05:08,939
logos early experiments into character

00:05:06,479 --> 00:05:11,099
animation with marilyn monroebot so this

00:05:08,939 --> 00:05:13,019
was all omnibus and omnibus grew and

00:05:11,099 --> 00:05:15,239
grew and grew and they were really

00:05:13,019 --> 00:05:18,149
successful until they declared

00:05:15,239 --> 00:05:22,069
bankruptcy and went out of business and

00:05:18,149 --> 00:05:26,789
that happened in the spring of 1987 and

00:05:22,069 --> 00:05:29,249
two of the developers at omnibus greg

00:05:26,789 --> 00:05:31,439
her manovich and kim davidson purchased

00:05:29,249 --> 00:05:34,800
the rights to use the source code that

00:05:31,439 --> 00:05:37,079
omnibus had built and so they they

00:05:34,800 --> 00:05:39,749
started off with a company called side

00:05:37,079 --> 00:05:45,300
effects and they founded it in fall of

00:05:39,749 --> 00:05:51,989
1987 and it was all C code and really

00:05:45,300 --> 00:05:54,809
gross and so in 1989 I joined the

00:05:51,989 --> 00:05:57,239
company that's actually a picture of the

00:05:54,809 --> 00:05:59,279
entire company at the time and the guy

00:05:57,239 --> 00:06:01,709
in the striped shirt is actually a

00:05:59,279 --> 00:06:04,889
client this is at our first trade show

00:06:01,709 --> 00:06:07,289
and our client actually helped us out

00:06:04,889 --> 00:06:14,360
he's actually still a customer which is

00:06:07,289 --> 00:06:17,909
pretty neat in the early days all the

00:06:14,360 --> 00:06:19,319
artists who used computer graphics a lot

00:06:17,909 --> 00:06:21,749
of the the tools that they had were

00:06:19,319 --> 00:06:24,209
command-line tools so for example they

00:06:21,749 --> 00:06:27,779
would take a program called G font which

00:06:24,209 --> 00:06:30,869
would generate some geometry using

00:06:27,779 --> 00:06:32,969
Helvetica and they would be able to

00:06:30,869 --> 00:06:36,059
display the geometry and see what it

00:06:32,969 --> 00:06:38,819
would look like there were other tools

00:06:36,059 --> 00:06:42,659
that would take the output of one tool

00:06:38,819 --> 00:06:45,539
and generate a new piece of geometry so

00:06:42,659 --> 00:06:47,849
for example the extrude program would

00:06:45,539 --> 00:06:50,129
take some parameters and the input

00:06:47,849 --> 00:06:52,169
geometry and generate new geometry and

00:06:50,129 --> 00:06:53,470
then you could color the geometry and

00:06:52,169 --> 00:06:57,760
then display the geometry and

00:06:53,470 --> 00:07:00,700
you'd have a flying logo right there the

00:06:57,760 --> 00:07:05,620
thing was that a lot of the artists of

00:07:00,700 --> 00:07:07,150
the time were also programmers so to be

00:07:05,620 --> 00:07:09,700
an artist at that time you had to be

00:07:07,150 --> 00:07:12,610
very technical so they would build make

00:07:09,700 --> 00:07:14,500
files you could also pipe geometry

00:07:12,610 --> 00:07:16,300
because it was all UNIX based so you

00:07:14,500 --> 00:07:18,940
could pipe from one program to another

00:07:16,300 --> 00:07:21,820
program and people would build make

00:07:18,940 --> 00:07:24,310
files and and write said scripts and hoc

00:07:21,820 --> 00:07:27,610
scripts to actually create animation for

00:07:24,310 --> 00:07:29,830
their geometry so it was it was like it

00:07:27,610 --> 00:07:35,050
was very hard to be an animator at that

00:07:29,830 --> 00:07:38,920
time but we looked at what artists were

00:07:35,050 --> 00:07:42,280
doing and a great romantic one of the

00:07:38,920 --> 00:07:45,100
founders was really inspired by analog

00:07:42,280 --> 00:07:47,470
synthesizers so this is a picture of

00:07:45,100 --> 00:07:49,090
Robert Moog and his analog synthesizer

00:07:47,470 --> 00:07:51,790
and the idea with the the Moog

00:07:49,090 --> 00:07:53,890
synthesizer is that you would take patch

00:07:51,790 --> 00:07:56,169
cords and hook them between different

00:07:53,890 --> 00:07:59,130
generators and be able to generate new

00:07:56,169 --> 00:08:01,870
sounds that you'd never heard before so

00:07:59,130 --> 00:08:04,990
when we took a look at the make files

00:08:01,870 --> 00:08:07,540
and the the the idea of patch cords we

00:08:04,990 --> 00:08:10,000
came up with a procedural way of

00:08:07,540 --> 00:08:12,850
generating geometry so this is this is

00:08:10,000 --> 00:08:15,640
what Houdini looks like down in the

00:08:12,850 --> 00:08:18,190
bottom right you'll see a node the font

00:08:15,640 --> 00:08:20,020
node above that font node are the

00:08:18,190 --> 00:08:23,080
parameters to the font nodes so this is

00:08:20,020 --> 00:08:24,910
very much like the the font command that

00:08:23,080 --> 00:08:27,310
the artist would write except it's in a

00:08:24,910 --> 00:08:30,780
graphical user interface and you'd see

00:08:27,310 --> 00:08:34,810
the result of the output there and then

00:08:30,780 --> 00:08:38,500
you could build a node Network which

00:08:34,810 --> 00:08:40,140
which just as lights the pipe commands

00:08:38,500 --> 00:08:43,270
that the artists would have to do and

00:08:40,140 --> 00:08:48,300
you've got all the parameters there the

00:08:43,270 --> 00:08:50,920
big difference with this is that that

00:08:48,300 --> 00:08:53,230
because it's a live application as you

00:08:50,920 --> 00:08:55,510
change the parameters you get immediate

00:08:53,230 --> 00:08:57,910
feedback so you don't have to wait for

00:08:55,510 --> 00:09:00,460
the the make file to run and for you to

00:08:57,910 --> 00:09:03,880
generate code so you can change things

00:09:00,460 --> 00:09:06,370
on the fly so we started looking at the

00:09:03,880 --> 00:09:10,120
nodes in Houdini as as a

00:09:06,370 --> 00:09:11,980
I mean language whoops so if you look at

00:09:10,120 --> 00:09:14,380
this node network this is a node network

00:09:11,980 --> 00:09:16,930
that takes a torus and fractures it into

00:09:14,380 --> 00:09:19,839
little pieces okay so the artist puts

00:09:16,930 --> 00:09:22,660
this together and they build what we

00:09:19,839 --> 00:09:24,520
call a procedure so there's a procedure

00:09:22,660 --> 00:09:27,670
it's very much like a C++ procedure

00:09:24,520 --> 00:09:29,470
where you have little nodes that do the

00:09:27,670 --> 00:09:33,279
little operations and then you have the

00:09:29,470 --> 00:09:35,200
result and just like with C++ if you

00:09:33,279 --> 00:09:38,200
have a procedure if you change the input

00:09:35,200 --> 00:09:41,050
you get different outputs so if you feed

00:09:38,200 --> 00:09:46,480
in a flip floaty toy it breaks up the

00:09:41,050 --> 00:09:49,120
floaty toy but we took a lot of the

00:09:46,480 --> 00:09:50,670
ideas from languages and applied them to

00:09:49,120 --> 00:09:54,910
our nodes as well so we have

00:09:50,670 --> 00:09:56,710
encapsulation so the on the upper right

00:09:54,910 --> 00:09:59,350
you'll see a small node Network where a

00:09:56,710 --> 00:10:02,110
great is fed into a mountain and the

00:09:59,350 --> 00:10:04,870
mountain deforms the the grid into

00:10:02,110 --> 00:10:07,170
looking like well not really like a

00:10:04,870 --> 00:10:09,820
mountain like a bumpy grid but

00:10:07,170 --> 00:10:11,650
underneath it is there's a big

00:10:09,820 --> 00:10:13,600
complicated node network which is

00:10:11,650 --> 00:10:15,820
actually the implementation of the

00:10:13,600 --> 00:10:17,860
mountain network the mountain node so

00:10:15,820 --> 00:10:21,420
we've encapsulated that the mountain

00:10:17,860 --> 00:10:24,400
procedure in its own procedure the other

00:10:21,420 --> 00:10:27,300
thing that you can that we realized is

00:10:24,400 --> 00:10:30,330
that you can take complicated

00:10:27,300 --> 00:10:33,040
expressions and factor them out into

00:10:30,330 --> 00:10:34,990
little pieces so this is the

00:10:33,040 --> 00:10:39,820
incompressible navier stokes equation

00:10:34,990 --> 00:10:42,670
and we we've broken it out into little

00:10:39,820 --> 00:10:46,570
parts so each node does a little bit of

00:10:42,670 --> 00:10:49,060
that that the the overall equation what

00:10:46,570 --> 00:10:51,790
this allows for is that you can isolate

00:10:49,060 --> 00:10:54,400
certain parts of the equation and

00:10:51,790 --> 00:10:55,990
optimize that rather than working on

00:10:54,400 --> 00:10:57,550
scalars though this is working on huge

00:10:55,990 --> 00:10:59,500
amounts of data that are being fed

00:10:57,550 --> 00:11:03,900
through those node graphs that node

00:10:59,500 --> 00:11:07,209
graph so you can take you can do

00:11:03,900 --> 00:11:10,540
parallelization and threading and and a

00:11:07,209 --> 00:11:14,350
lot a lot of it buys you a lot by

00:11:10,540 --> 00:11:16,420
breaking that out also with programming

00:11:14,350 --> 00:11:17,800
you want to leave comments so we have

00:11:16,420 --> 00:11:21,149
sticky notes that you can put in your

00:11:17,800 --> 00:11:24,850
network when I write code

00:11:21,149 --> 00:11:27,100
and people come over and look over my

00:11:24,850 --> 00:11:29,049
shoulder I actually don't use syntax

00:11:27,100 --> 00:11:30,970
highlighting and people are just like

00:11:29,049 --> 00:11:33,279
their jaws drop I can't they can't

00:11:30,970 --> 00:11:36,999
understand how I can't use syntax

00:11:33,279 --> 00:11:39,189
highlighting but and so with nodes node

00:11:36,999 --> 00:11:41,079
graphs of course you also want to be

00:11:39,189 --> 00:11:44,109
able to color your node graphs so that

00:11:41,079 --> 00:11:46,779
you can impart information we also have

00:11:44,109 --> 00:11:49,509
tools to do layout you can take a very

00:11:46,779 --> 00:11:51,129
complicated Network and simplify it I

00:11:49,509 --> 00:11:53,229
know that I've spent a lot of time

00:11:51,129 --> 00:11:55,329
manually formatting code and now we have

00:11:53,229 --> 00:11:57,779
things like claying format which is

00:11:55,329 --> 00:12:01,720
great so we provide tools like that

00:11:57,779 --> 00:12:04,689
another tool we provide our kernel Inc

00:12:01,720 --> 00:12:08,589
we have some kernel languages in Houdini

00:12:04,689 --> 00:12:11,499
so we have a custom language called vex

00:12:08,589 --> 00:12:13,899
but we also have OpenCL where the artist

00:12:11,499 --> 00:12:17,289
can actually write OpenCL and feed that

00:12:13,899 --> 00:12:20,109
into a network and have OpenCL run on

00:12:17,289 --> 00:12:21,609
their geometry so this in a sense is

00:12:20,109 --> 00:12:24,399
like writing a functor that you pass

00:12:21,609 --> 00:12:26,649
into a procedure so a lot of the the

00:12:24,399 --> 00:12:31,480
ideas that we have in the node networks

00:12:26,649 --> 00:12:34,139
are taken from computer languages one

00:12:31,480 --> 00:12:36,730
sort of advantage that we didn't realize

00:12:34,139 --> 00:12:39,579
and I'm not sure it's an advantage but

00:12:36,730 --> 00:12:43,149
is dead branches so when you build a

00:12:39,579 --> 00:12:45,999
network the if you look over on the

00:12:43,149 --> 00:12:48,309
bottom right three nodes in you'll see a

00:12:45,999 --> 00:12:50,980
node that has a blue circle around it

00:12:48,309 --> 00:12:52,480
that's the output of this network but

00:12:50,980 --> 00:12:55,449
there are a lot of dead branches in here

00:12:52,480 --> 00:12:58,119
that aren't actually evaluated in the

00:12:55,449 --> 00:13:00,189
node Network in C++ you'd put if death

00:12:58,119 --> 00:13:02,079
surrounded or commented I would comment

00:13:00,189 --> 00:13:03,489
out that code but with a node network

00:13:02,079 --> 00:13:06,009
you don't have to so you can have

00:13:03,489 --> 00:13:09,549
experiments and you can have alternative

00:13:06,009 --> 00:13:11,949
paths that that don't get evaluated and

00:13:09,549 --> 00:13:14,379
don't aren't aren't and are basically

00:13:11,949 --> 00:13:17,079
dead branches without having to worry

00:13:14,379 --> 00:13:19,209
about cleaning up your mess so it allows

00:13:17,079 --> 00:13:20,829
you to go back and see what what the

00:13:19,209 --> 00:13:24,939
artist was trying to think of when they

00:13:20,829 --> 00:13:27,309
were doing that now our our node graphs

00:13:24,939 --> 00:13:29,499
are used in visual effects and visual

00:13:27,309 --> 00:13:32,230
effects artists are are really often

00:13:29,499 --> 00:13:33,910
tasks the producer will come and say you

00:13:32,230 --> 00:13:36,490
know I want to create this effect

00:13:33,910 --> 00:13:39,490
never ever been seen before so a

00:13:36,490 --> 00:13:42,520
procedural procedural paradigm like this

00:13:39,490 --> 00:13:43,930
is really flexible it doesn't lock them

00:13:42,520 --> 00:13:48,910
into a corner they don't have to do

00:13:43,930 --> 00:13:51,850
canned effects so it turns out that we

00:13:48,910 --> 00:13:54,040
we had to tweak a little bit but we've

00:13:51,850 --> 00:13:56,170
made our node graphs turing-complete

00:13:54,040 --> 00:13:59,560
so you should be able to do anything and

00:13:56,170 --> 00:14:01,630
in fact when you've got a lot of really

00:13:59,560 --> 00:14:03,460
creative artists out there using our

00:14:01,630 --> 00:14:05,830
software and you've got very flexible

00:14:03,460 --> 00:14:08,170
package you can get a lot of interesting

00:14:05,830 --> 00:14:10,660
things so for example someone wrote a

00:14:08,170 --> 00:14:12,880
ray tracer using our geometry operators

00:14:10,660 --> 00:14:14,950
so if you look really closely at the

00:14:12,880 --> 00:14:18,400
back wall of the Cornell box there

00:14:14,950 --> 00:14:21,610
that's actually a wireframe grid so this

00:14:18,400 --> 00:14:24,190
this geometry this is not an image this

00:14:21,610 --> 00:14:26,590
is geometry that's being colored each

00:14:24,190 --> 00:14:29,590
vertex is being colored with the width

00:14:26,590 --> 00:14:33,130
that the appropriate lighting and

00:14:29,590 --> 00:14:35,290
illumination that node network is up on

00:14:33,130 --> 00:14:37,270
does it come through yeah the no network

00:14:35,290 --> 00:14:39,190
comes up on the right side right hand

00:14:37,270 --> 00:14:41,770
side and you can see little parts that

00:14:39,190 --> 00:14:46,330
do global illumination recursion and all

00:14:41,770 --> 00:14:49,690
sorts of fun stuff photon maps we've

00:14:46,330 --> 00:14:51,460
also had users write games there's an

00:14:49,690 --> 00:14:57,310
example of someone playing Houdini

00:14:51,460 --> 00:14:59,770
against sin plain mercy but we of course

00:14:57,310 --> 00:15:01,960
don't stop at customized node networks

00:14:59,770 --> 00:15:05,320
we also make sure that our user

00:15:01,960 --> 00:15:08,740
interface is customizable and so you can

00:15:05,320 --> 00:15:12,720
go to a sort of meta state where users

00:15:08,740 --> 00:15:15,580
have created customized node network

00:15:12,720 --> 00:15:18,400
tiles where you can do a collision

00:15:15,580 --> 00:15:22,420
detection on your node no tiles you can

00:15:18,400 --> 00:15:24,970
build ik' simulations but underneath

00:15:22,420 --> 00:15:27,970
everything is still a Houdini nodes so

00:15:24,970 --> 00:15:30,340
you can select your node and you can

00:15:27,970 --> 00:15:33,430
pull up your syntax highlighting and

00:15:30,340 --> 00:15:35,200
color your node however you want in this

00:15:33,430 --> 00:15:38,380
one he actually somehow manages to

00:15:35,200 --> 00:15:40,360
select that node and change the name of

00:15:38,380 --> 00:15:42,760
the node and of course when you get

00:15:40,360 --> 00:15:45,089
something crazy like this the next step

00:15:42,760 --> 00:15:50,399
of course is to write a game using

00:15:45,089 --> 00:15:52,889
a note editor so if you zoom in each one

00:15:50,399 --> 00:15:59,670
of these shapes is actually a node in

00:15:52,889 --> 00:16:01,529
the Houdini graph I know I don't have

00:15:59,670 --> 00:16:03,949
time to actually do stuff like this but

00:16:01,529 --> 00:16:09,990
our users do apparently it's an amazing

00:16:03,949 --> 00:16:12,180
to understand how Houdini is used it's

00:16:09,990 --> 00:16:14,759
it's important to realize that you know

00:16:12,180 --> 00:16:16,139
it's not only geometry so this most of

00:16:14,759 --> 00:16:19,019
the examples that we've looked at have

00:16:16,139 --> 00:16:21,300
been geometry and so in the graphics

00:16:19,019 --> 00:16:24,209
pipeline the first first stage that

00:16:21,300 --> 00:16:28,290
usually happens is is modeling geometry

00:16:24,209 --> 00:16:30,600
and this is this is a sort of example of

00:16:28,290 --> 00:16:32,370
how someone would model in Houdini so

00:16:30,600 --> 00:16:33,899
though they've got the live viewport

00:16:32,370 --> 00:16:35,999
there and they can select some polygons

00:16:33,899 --> 00:16:38,100
and do some operations but if you look

00:16:35,999 --> 00:16:40,230
over on the right-hand side as they do

00:16:38,100 --> 00:16:42,329
these operations Houdini is actually

00:16:40,230 --> 00:16:44,189
building a node graph underneath so that

00:16:42,329 --> 00:16:47,550
means that the user can go back and

00:16:44,189 --> 00:16:50,790
change parameters or or edit their their

00:16:47,550 --> 00:16:52,709
construction history what's also kind of

00:16:50,790 --> 00:16:55,519
interesting to notice is as the user

00:16:52,709 --> 00:16:57,870
many place the geometry in the viewport

00:16:55,519 --> 00:17:00,540
sometimes they go over to the parameters

00:16:57,870 --> 00:17:02,730
and actually manually enter values so

00:17:00,540 --> 00:17:05,520
it's a sort of hybrid way of working

00:17:02,730 --> 00:17:08,010
where you can work interactively or work

00:17:05,520 --> 00:17:11,250
print parametrically and it's sort of up

00:17:08,010 --> 00:17:12,870
to the user to decide how once you once

00:17:11,250 --> 00:17:18,149
you've built a model the next stage of

00:17:12,870 --> 00:17:20,789
the pipeline is usually animation so the

00:17:18,149 --> 00:17:22,709
this is an example where the animators

00:17:20,789 --> 00:17:25,799
trying to change the the weight or the

00:17:22,709 --> 00:17:28,380
the motion of how a character interacts

00:17:25,799 --> 00:17:31,860
so they're changing the the power of the

00:17:28,380 --> 00:17:35,039
is an animated Minotaur they're changing

00:17:31,860 --> 00:17:38,940
how the arm comes down so that it's got

00:17:35,039 --> 00:17:41,429
a little more oomph other parts of the

00:17:38,940 --> 00:17:44,279
pipeline include shading where we take

00:17:41,429 --> 00:17:47,789
real-world physics and I do Monte Carlo

00:17:44,279 --> 00:17:54,210
evaluation of VR DFS and all sorts of

00:17:47,789 --> 00:17:56,100
fun stuff applying textures but the the

00:17:54,210 --> 00:17:58,630
sort of important thing to know is that

00:17:56,100 --> 00:18:01,060
in Houdini every one of these

00:17:58,630 --> 00:18:02,800
pipelines is still building and using

00:18:01,060 --> 00:18:06,130
procedural networks underneath so this

00:18:02,800 --> 00:18:08,470
is this is the node graph for the the

00:18:06,130 --> 00:18:09,730
simple shader that does gold and you can

00:18:08,470 --> 00:18:14,080
see it's actually a very complicated

00:18:09,730 --> 00:18:16,570
node graph it gets very complicated

00:18:14,080 --> 00:18:19,300
because even some of these operators are

00:18:16,570 --> 00:18:21,190
actually encapsulated and and they're

00:18:19,300 --> 00:18:25,750
even more complicated procedures

00:18:21,190 --> 00:18:29,590
underneath so once you've got shading

00:18:25,750 --> 00:18:33,480
done you go to layout you and then you

00:18:29,590 --> 00:18:37,300
go to effects and effects is sort of the

00:18:33,480 --> 00:18:39,610
the the strength of Houdini is it's the

00:18:37,300 --> 00:18:42,280
real Forte because there you never know

00:18:39,610 --> 00:18:44,500
what kind of effects people will need

00:18:42,280 --> 00:18:46,960
artists will need so it might be

00:18:44,500 --> 00:18:50,320
something like building muscle rig on

00:18:46,960 --> 00:18:53,440
the the minute or so that as the muscles

00:18:50,320 --> 00:18:55,720
we run an FIM simulation on the muscles

00:18:53,440 --> 00:18:58,420
and as the the muscles deform they

00:18:55,720 --> 00:19:01,510
adjust how the skin moves so you get

00:18:58,420 --> 00:19:03,070
nice secondary animation on on the skin

00:19:01,510 --> 00:19:05,980
I don't know if you it comes across in

00:19:03,070 --> 00:19:08,740
the slide but you might also take a

00:19:05,980 --> 00:19:11,380
model like the squab a giant squab and

00:19:08,740 --> 00:19:14,290
fractured into million pieces or

00:19:11,380 --> 00:19:16,360
thousands of pieces in this case and in

00:19:14,290 --> 00:19:18,370
this case you're running in a physics

00:19:16,360 --> 00:19:20,680
simulation where it's a rigid body

00:19:18,370 --> 00:19:22,570
dynamics underneath and each one of

00:19:20,680 --> 00:19:24,730
those little pieces has to interact with

00:19:22,570 --> 00:19:28,060
all the other little pieces so there's

00:19:24,730 --> 00:19:31,690
there's some some heavy well this is a

00:19:28,060 --> 00:19:33,190
little bit of heavy data if you run

00:19:31,690 --> 00:19:36,520
fluid simulations you get a lot more

00:19:33,190 --> 00:19:40,750
heavy data so this is just a simple

00:19:36,520 --> 00:19:45,370
particle simulation this in this this

00:19:40,750 --> 00:19:47,200
simulation here the where that the peak

00:19:45,370 --> 00:19:49,390
number of particles that come through is

00:19:47,200 --> 00:19:54,030
over 1.1 billion particles that were

00:19:49,390 --> 00:19:58,360
moving around but there's also a volume

00:19:54,030 --> 00:20:00,220
voxel grid that is is used to store the

00:19:58,360 --> 00:20:05,020
state of the simulation and that voxel

00:20:00,220 --> 00:20:10,060
grid is 1200 by 1200 by 300 at the the

00:20:05,020 --> 00:20:11,389
peak so that's like half a 500 million

00:20:10,060 --> 00:20:13,639
voxels

00:20:11,389 --> 00:20:18,409
and so we're dealing with some big data

00:20:13,639 --> 00:20:20,239
but the and here's a billion voxels it's

00:20:18,409 --> 00:20:24,950
it's an animation it just moves really

00:20:20,239 --> 00:20:27,499
really slowly so we're pushing a lot of

00:20:24,950 --> 00:20:30,139
data through in these simulations but

00:20:27,499 --> 00:20:32,329
the other side of this is that when the

00:20:30,139 --> 00:20:37,549
artist is setting up a simulation like

00:20:32,329 --> 00:20:39,379
this we can't actually just optimize for

00:20:37,549 --> 00:20:41,539
big data we also have to be able to

00:20:39,379 --> 00:20:43,279
optimize for a thousand particles going

00:20:41,539 --> 00:20:45,259
through or ten thousand particles going

00:20:43,279 --> 00:20:49,849
through so our data structures need to

00:20:45,259 --> 00:20:54,409
be both able to handle simple data and

00:20:49,849 --> 00:20:56,359
also be able to scale up and you

00:20:54,409 --> 00:20:58,639
probably all know AdWords law which is

00:20:56,359 --> 00:21:00,589
something that can be written in

00:20:58,639 --> 00:21:04,129
JavaScript will eventually be written in

00:21:00,589 --> 00:21:06,349
JavaScript this is not the kind of stuff

00:21:04,129 --> 00:21:10,789
that you can just cobble together with

00:21:06,349 --> 00:21:13,429
the JavaScript framework we also get to

00:21:10,789 --> 00:21:15,799
fun problems because sometimes even the

00:21:13,429 --> 00:21:18,440
the beefiest machines we have ka solve a

00:21:15,799 --> 00:21:19,999
simulation altogether so we'll

00:21:18,440 --> 00:21:23,359
distribute the simulation across

00:21:19,999 --> 00:21:26,149
multiple nodes so in this case each

00:21:23,359 --> 00:21:27,889
machine is transferring data back and

00:21:26,149 --> 00:21:31,849
forth between other machines so that the

00:21:27,889 --> 00:21:34,909
boundary conditions work out and you get

00:21:31,849 --> 00:21:36,469
smooth simulation you we also have to

00:21:34,909 --> 00:21:39,169
deal with load balancing and all sorts

00:21:36,469 --> 00:21:42,229
of fun problems so it's it's really fun

00:21:39,169 --> 00:21:43,269
working in our industry I can't

00:21:42,229 --> 00:21:48,259
recommend it enough

00:21:43,269 --> 00:21:51,139
like the the pipeline gets inordinately

00:21:48,259 --> 00:21:54,889
complex there's actually a lot of people

00:21:51,139 --> 00:21:59,509
doing research into pipelines that the

00:21:54,889 --> 00:22:02,269
cost of a pipeline can be it can be real

00:21:59,509 --> 00:22:05,570
in terms of dollars so this is actually

00:22:02,269 --> 00:22:06,919
pertinent to film in studios and so

00:22:05,570 --> 00:22:09,529
there's actually quite a bit of research

00:22:06,919 --> 00:22:10,759
going into pipelines and and optimizing

00:22:09,529 --> 00:22:15,079
pipelines and making sure they don't

00:22:10,759 --> 00:22:18,739
break but pipelines can also be cyclic

00:22:15,079 --> 00:22:19,940
so you can actually take data from part

00:22:18,739 --> 00:22:22,429
of the pipeline and feed it back into

00:22:19,940 --> 00:22:24,210
the other pipeline so for example here

00:22:22,429 --> 00:22:27,720
we're taking up

00:22:24,210 --> 00:22:30,000
an optical flow of a an image like a

00:22:27,720 --> 00:22:35,460
animation and using it to derive

00:22:30,000 --> 00:22:37,380
particle simulation so my the purpose

00:22:35,460 --> 00:22:41,100
for going through the the sort of

00:22:37,380 --> 00:22:43,520
pipeline of a typical studio is to point

00:22:41,100 --> 00:22:47,430
out that every part of the pipeline

00:22:43,520 --> 00:22:49,050
faces unique problems so when you're

00:22:47,430 --> 00:22:56,160
modeling geometry you need fast

00:22:49,050 --> 00:22:59,220
interaction you need a quick UI good UI

00:22:56,160 --> 00:23:01,410
fast interaction animation you also want

00:22:59,220 --> 00:23:03,240
fast feedback one of the studios out

00:23:01,410 --> 00:23:06,690
there did something really clever which

00:23:03,240 --> 00:23:08,850
is as the animator moves a character in

00:23:06,690 --> 00:23:10,980
one pose what the lose they'll start a

00:23:08,850 --> 00:23:14,190
lot of background threads and figure out

00:23:10,980 --> 00:23:16,230
what that change does for all the other

00:23:14,190 --> 00:23:18,330
frames so that when the animator wants

00:23:16,230 --> 00:23:20,760
to go and and see what the change is

00:23:18,330 --> 00:23:23,100
it's already baked and pre computed so

00:23:20,760 --> 00:23:25,860
there's a lot of efficiency we spend in

00:23:23,100 --> 00:23:27,360
in compositing one of the the people who

00:23:25,860 --> 00:23:30,270
was onstage at the Academy Awards

00:23:27,360 --> 00:23:32,850
presented a paper a few years back on

00:23:30,270 --> 00:23:36,000
the optimal way to convert floating

00:23:32,850 --> 00:23:39,860
point integer data because you would you

00:23:36,000 --> 00:23:42,450
think well that's it's really easy but

00:23:39,860 --> 00:23:43,920
when you're doing image compositing and

00:23:42,450 --> 00:23:45,960
you're working in floating point data

00:23:43,920 --> 00:23:48,390
you want to get every little ounce of

00:23:45,960 --> 00:23:51,210
the machine out of power out of the

00:23:48,390 --> 00:23:52,920
machine right so we'd spend an

00:23:51,210 --> 00:23:54,720
inordinate amount of time trying to

00:23:52,920 --> 00:23:59,880
optimize our code to make it fast for

00:23:54,720 --> 00:24:02,690
the user and a better user experience so

00:23:59,880 --> 00:24:07,650
I'm now actually going to get back to

00:24:02,690 --> 00:24:10,800
the C++ side of this talk so we started

00:24:07,650 --> 00:24:12,510
off with software called prisms which

00:24:10,800 --> 00:24:15,150
was all sea based and it had a little

00:24:12,510 --> 00:24:17,970
bit of procedural ISM in it and we

00:24:15,150 --> 00:24:19,890
wanted to get to we knew we wanted to

00:24:17,970 --> 00:24:22,530
get to Houdini which was gonna be all

00:24:19,890 --> 00:24:25,410
C++ based which involved a new UI

00:24:22,530 --> 00:24:28,890
library new geometry libraries new new

00:24:25,410 --> 00:24:31,560
everything but we were only a team of

00:24:28,890 --> 00:24:33,000
six or eight developers so the way we

00:24:31,560 --> 00:24:35,340
did this was we created a bunch of

00:24:33,000 --> 00:24:38,040
transitional applications as we

00:24:35,340 --> 00:24:39,990
transition from the old C code

00:24:38,040 --> 00:24:42,630
C++ we did this because we didn't want

00:24:39,990 --> 00:24:44,670
our clients the people using prisons to

00:24:42,630 --> 00:24:48,540
suffer because we were just stopping

00:24:44,670 --> 00:24:50,360
development on the C code so we had dual

00:24:48,540 --> 00:24:53,340
development going on at the same time

00:24:50,360 --> 00:24:58,980
now if you look at the timeline we

00:24:53,340 --> 00:25:01,920
started writing C++ in 1992 and our and

00:24:58,980 --> 00:25:04,950
Houdini was first released in 1996 and

00:25:01,920 --> 00:25:08,040
so if you weren't born in the 90s or

00:25:04,950 --> 00:25:09,840
have forgotten what the 90s were like I

00:25:08,040 --> 00:25:15,960
just want to let you know that people in

00:25:09,840 --> 00:25:18,030
the 90s looked like this but to put it

00:25:15,960 --> 00:25:20,760
more in perspective that people might

00:25:18,030 --> 00:25:24,120
understand here is that the draft STL

00:25:20,760 --> 00:25:28,440
came out in 1994 two years after we

00:25:24,120 --> 00:25:32,700
started working on our C++ code the

00:25:28,440 --> 00:25:36,810
first release of C++ of SQL for C++ on

00:25:32,700 --> 00:25:41,010
SGI's came out in 1997 1998 and boost

00:25:36,810 --> 00:25:43,650
wasn't even out yet so we'd been working

00:25:41,010 --> 00:25:47,640
on C++ a long time before a lot of the

00:25:43,650 --> 00:25:49,950
nice containers and and functions came

00:25:47,640 --> 00:25:53,460
around which of course meant that we had

00:25:49,950 --> 00:25:55,500
to write all our own classes so we spent

00:25:53,460 --> 00:25:57,750
a lot of time building our libraries we

00:25:55,500 --> 00:26:00,150
wrote lists we wrote string unordered

00:25:57,750 --> 00:26:02,790
map atomic ants

00:26:00,150 --> 00:26:04,680
of those things that you can take for

00:26:02,790 --> 00:26:06,960
granted these days we had to write from

00:26:04,680 --> 00:26:11,370
scratch and there were a lot of benefits

00:26:06,960 --> 00:26:16,020
to this we had cross-platform

00:26:11,370 --> 00:26:19,860
consistency because we were controlling

00:26:16,020 --> 00:26:21,930
how the classes behaved we had a lot of

00:26:19,860 --> 00:26:24,690
control over behavior and that was

00:26:21,930 --> 00:26:28,560
really important in the early days there

00:26:24,690 --> 00:26:30,720
was one platform where poster stream

00:26:28,560 --> 00:26:34,020
when you wrote to it one character at a

00:26:30,720 --> 00:26:36,030
time would reallocate the buffer copy

00:26:34,020 --> 00:26:38,970
over all the data and then append the

00:26:36,030 --> 00:26:41,070
new character so if you were it was a

00:26:38,970 --> 00:26:43,500
real fast way to write an order N

00:26:41,070 --> 00:26:46,530
squared algorithm by writing out data in

00:26:43,500 --> 00:26:49,230
a linear fashion was awful so we had to

00:26:46,530 --> 00:26:51,760
write our own stir screen to work around

00:26:49,230 --> 00:26:55,540
that store stream buff

00:26:51,760 --> 00:26:57,250
and I don't know people people here in

00:26:55,540 --> 00:27:00,850
this audience probably remember seafront

00:26:57,250 --> 00:27:03,460
some of them do you remember template

00:27:00,850 --> 00:27:06,220
repositories templates worked really

00:27:03,460 --> 00:27:07,809
well provided you were in a single

00:27:06,220 --> 00:27:11,110
library but when you had a large

00:27:07,809 --> 00:27:14,950
application the template repositories

00:27:11,110 --> 00:27:18,299
were a nightmare and so we got burned by

00:27:14,950 --> 00:27:21,880
trying to adopt templates too early and

00:27:18,299 --> 00:27:24,760
we avoided templates and and suffered

00:27:21,880 --> 00:27:26,620
because of that so we had a real bad

00:27:24,760 --> 00:27:29,620
taste in our mouths after about

00:27:26,620 --> 00:27:31,690
templates and so we we suffered for many

00:27:29,620 --> 00:27:35,640
years there were of course a lot of

00:27:31,690 --> 00:27:40,090
disadvantages we're not as smart as the

00:27:35,640 --> 00:27:42,160
standard library developers but learning

00:27:40,090 --> 00:27:45,790
curve for new developers coming in who

00:27:42,160 --> 00:27:47,350
were very familiar with the SQL it's a

00:27:45,790 --> 00:27:51,100
it's a cost for them to learn our new

00:27:47,350 --> 00:27:53,260
classes and we have to maintain them the

00:27:51,100 --> 00:27:55,840
there was actually turned out to be a

00:27:53,260 --> 00:27:59,679
real hidden cost hidden benefit pardon

00:27:55,840 --> 00:28:01,840
me to having our own classes and that

00:27:59,679 --> 00:28:03,850
was something we didn't sort of realize

00:28:01,840 --> 00:28:07,540
till later which is that Houdini is part

00:28:03,850 --> 00:28:10,210
of an ecosystem so all the studios like

00:28:07,540 --> 00:28:12,309
all the people up on stage wrote write

00:28:10,210 --> 00:28:14,559
their own code and they have to

00:28:12,309 --> 00:28:17,710
interface with our application and other

00:28:14,559 --> 00:28:19,960
vendors applications and so having our

00:28:17,710 --> 00:28:21,840
own classes meant that there were no

00:28:19,960 --> 00:28:25,480
namespace collisions there were no

00:28:21,840 --> 00:28:27,850
library version differences when we

00:28:25,480 --> 00:28:30,040
started using boost we tried to keep it

00:28:27,850 --> 00:28:31,480
header only boost but you know once

00:28:30,040 --> 00:28:32,860
you've tasted that forbidden fruit

00:28:31,480 --> 00:28:37,030
you've just got to go a little deeper

00:28:32,860 --> 00:28:39,610
and so as soon as we started doing that

00:28:37,030 --> 00:28:42,040
we noticed all our clients started

00:28:39,610 --> 00:28:45,970
complaining that oh we're using boost

00:28:42,040 --> 00:28:48,730
1.51 and you're using boost 1.52 and

00:28:45,970 --> 00:28:51,640
things crashing and so one of our

00:28:48,730 --> 00:28:52,720
engineers spent six months namespacing

00:28:51,640 --> 00:28:57,280
boost for Houdini

00:28:52,720 --> 00:29:00,480
and it got rid of the problem but it you

00:28:57,280 --> 00:29:03,600
know there there are all these costs to

00:29:00,480 --> 00:29:07,530
having to exist in an ecosystem

00:29:03,600 --> 00:29:12,570
so all these studios have their own code

00:29:07,530 --> 00:29:14,670
even more studios on top of that and we

00:29:12,570 --> 00:29:18,720
realized that what was needed was some

00:29:14,670 --> 00:29:21,810
kind of organization to help maintain

00:29:18,720 --> 00:29:24,240
the version itis that happens so side

00:29:21,810 --> 00:29:26,520
effects in Autodesk and we pulled in the

00:29:24,240 --> 00:29:28,410
visual effects society got together and

00:29:26,520 --> 00:29:30,960
came up with the visual effects

00:29:28,410 --> 00:29:33,450
reference platform and the idea with

00:29:30,960 --> 00:29:37,260
this is to specify a common set of

00:29:33,450 --> 00:29:39,750
libraries common set of language

00:29:37,260 --> 00:29:43,100
features that that can be used in the

00:29:39,750 --> 00:29:47,880
visual effects industry and so in 2015

00:29:43,100 --> 00:29:53,160
we were using GCC 4.8 boost 1.5 point x

00:29:47,880 --> 00:29:56,580
QT 4 8 6 4 8 X and Python 2.7 point X

00:29:53,160 --> 00:29:59,460
and a bunch of other libraries the next

00:29:56,580 --> 00:30:03,060
year well we stayed on GCC for a -

00:29:59,460 --> 00:30:04,140
because people don't want to advanced

00:30:03,060 --> 00:30:06,420
very fast

00:30:04,140 --> 00:30:10,320
if something's working they don't want

00:30:06,420 --> 00:30:12,390
to break it they they the visual effects

00:30:10,320 --> 00:30:15,840
reference platform changed that X into

00:30:12,390 --> 00:30:18,960
an 8 and the X at the bottom into a 5

00:30:15,840 --> 00:30:22,680
the big change here was jumping QT

00:30:18,960 --> 00:30:28,310
versions but the huge change was that in

00:30:22,680 --> 00:30:30,740
2016 we were allowed to use C++ 11 and

00:30:28,310 --> 00:30:33,540
believe it or not there was huge

00:30:30,740 --> 00:30:36,210
pushback from the studios there was one

00:30:33,540 --> 00:30:38,490
really really big studio at there that

00:30:36,210 --> 00:30:39,390
said you can't do that you can't use C++

00:30:38,490 --> 00:30:41,400
00:30:39,390 --> 00:30:46,770
we've got register all through our all

00:30:41,400 --> 00:30:49,650
our headers and so there was a lot of

00:30:46,770 --> 00:30:52,920
pushback what I also found out recently

00:30:49,650 --> 00:30:55,560
is that there's one really one

00:30:52,920 --> 00:30:56,850
application that's used everywhere in

00:30:55,560 --> 00:30:59,910
the world it's huge

00:30:56,850 --> 00:31:03,450
and until very recently it was actually

00:30:59,910 --> 00:31:06,720
seen 99 so they still compiled C 99 and

00:31:03,450 --> 00:31:08,670
eventually to use some of the the

00:31:06,720 --> 00:31:12,060
libraries that are in the VFX reference

00:31:08,670 --> 00:31:17,370
platform they had to jump their compiler

00:31:12,060 --> 00:31:19,470
to C++ for 2018 which is this year

00:31:17,370 --> 00:31:22,410
we we finally get to use some features

00:31:19,470 --> 00:31:26,040
from C++ 14 and we bumped the compiler

00:31:22,410 --> 00:31:28,170
all the way to GCC 6 a lot of the

00:31:26,040 --> 00:31:30,150
studios around the world the guys who

00:31:28,170 --> 00:31:34,070
are building this VFX reference platform

00:31:30,150 --> 00:31:40,370
are on Linux which is why GCC is

00:31:34,070 --> 00:31:43,710
specified but this is maybe changing so

00:31:40,370 --> 00:31:47,730
the VFX reference platform was all sort

00:31:43,710 --> 00:31:50,520
of run by volunteers and participation

00:31:47,730 --> 00:31:52,320
was voluntary and so there are some

00:31:50,520 --> 00:31:54,870
studios out there that don't purchase it

00:31:52,320 --> 00:31:58,350
or don't adhere to it some studios just

00:31:54,870 --> 00:32:00,600
go their own way but I want to point out

00:31:58,350 --> 00:32:03,390
that the the Academy those guys who give

00:32:00,600 --> 00:32:06,210
out the statues they do more than just

00:32:03,390 --> 00:32:09,450
giving out the statues so they have a

00:32:06,210 --> 00:32:11,640
real interest in the film industry so

00:32:09,450 --> 00:32:13,650
and there are a lot of people on the

00:32:11,640 --> 00:32:15,980
Academy who are actually scientists and

00:32:13,650 --> 00:32:20,179
mathematicians and computer scientists

00:32:15,980 --> 00:32:23,280
in fact the the scientific and technical

00:32:20,179 --> 00:32:26,670
award committee is broken into two parts

00:32:23,280 --> 00:32:29,429
and there's the the the engineer side

00:32:26,670 --> 00:32:32,790
and then there's the digital digital

00:32:29,429 --> 00:32:35,220
imaging technology section and that dit

00:32:32,790 --> 00:32:38,040
section is actually much bigger than the

00:32:35,220 --> 00:32:41,700
engineering side so the Academy came out

00:32:38,040 --> 00:32:44,850
with something called aces the academy

00:32:41,700 --> 00:32:47,460
color encoding system and it provided a

00:32:44,850 --> 00:32:51,420
standard for representing representing

00:32:47,460 --> 00:32:53,400
and converting colors so this this idea

00:32:51,420 --> 00:32:55,559
of a standard they send it to all the

00:32:53,400 --> 00:32:59,309
camera manufacturers to all the software

00:32:55,559 --> 00:33:02,580
vendors to all the projection makers so

00:32:59,309 --> 00:33:04,500
that the idea is that when a director

00:33:02,580 --> 00:33:07,500
has a vision of how that color should

00:33:04,500 --> 00:33:12,440
look when it comes on to your screen or

00:33:07,500 --> 00:33:15,120
your TV or your theater it it should

00:33:12,440 --> 00:33:17,580
represented the right way and so aces

00:33:15,120 --> 00:33:21,300
sort of transformed the industry and was

00:33:17,580 --> 00:33:24,300
a great step forward and just this year

00:33:21,300 --> 00:33:26,880
in August the Academy announced after

00:33:24,300 --> 00:33:29,640
two years of a lot of research and a lot

00:33:26,880 --> 00:33:31,110
of input from industry they announced

00:33:29,640 --> 00:33:33,840
the Academy Software Foundation

00:33:31,110 --> 00:33:35,909
and what this is the purpose of this is

00:33:33,840 --> 00:33:37,890
to look at all the packages and software

00:33:35,909 --> 00:33:39,750
that are relevant to the film industry

00:33:37,890 --> 00:33:43,140
and make sure that there are standards

00:33:39,750 --> 00:33:44,789
that are adhere to so we're really

00:33:43,140 --> 00:33:49,710
looking forward to seeing where that

00:33:44,789 --> 00:33:53,159
goes and so now to take you back we

00:33:49,710 --> 00:33:55,529
wrote a lot of C++ classes and we don't

00:33:53,159 --> 00:33:57,720
like that we don't like having our C++

00:33:55,529 --> 00:34:00,029
classes so we needed a way to be able to

00:33:57,720 --> 00:34:03,740
transition away from art classes so for

00:34:00,029 --> 00:34:08,879
example we wrote our own Yuki atomic int

00:34:03,740 --> 00:34:11,310
to go back to 1992 namespaces this

00:34:08,879 --> 00:34:13,919
history namespaces had just been

00:34:11,310 --> 00:34:16,260
announced in 1990 and so there wasn't

00:34:13,919 --> 00:34:18,149
really a lot of compiler support so that

00:34:16,260 --> 00:34:20,300
Yuki underscore is a poor man's

00:34:18,149 --> 00:34:23,960
namespace so that's our utility class

00:34:20,300 --> 00:34:26,429
library so we still use that and and

00:34:23,960 --> 00:34:28,760
suffer but so if you if you have

00:34:26,429 --> 00:34:31,230
problems with that just replace the

00:34:28,760 --> 00:34:34,139
underscore with a colon colon and you

00:34:31,230 --> 00:34:37,139
should be okay so we wrote our own UT

00:34:34,139 --> 00:34:40,619
atomic int and we'd like to transition

00:34:37,139 --> 00:34:44,040
to stubo Tomic of course but you'll

00:34:40,619 --> 00:34:47,089
notice that our method for add stead of

00:34:44,040 --> 00:34:50,129
Tomic is fetch add so our process for

00:34:47,089 --> 00:34:55,220
transitioning is to create a deprecated

00:34:50,129 --> 00:34:58,950
method for ADD and switch it to fetch ID

00:34:55,220 --> 00:35:01,980
so we do this because when we have our

00:34:58,950 --> 00:35:04,410
deprecated method we can easily find it

00:35:01,980 --> 00:35:06,930
in all our code but the thing is that we

00:35:04,410 --> 00:35:09,119
also send out our headers to all the

00:35:06,930 --> 00:35:13,290
studios who use our software and they

00:35:09,119 --> 00:35:15,780
may have code that depends on this class

00:35:13,290 --> 00:35:18,300
I hope they don't but they may have us

00:35:15,780 --> 00:35:20,130
code so this deprecated method actually

00:35:18,300 --> 00:35:22,710
has to live for a couple of years or a

00:35:20,130 --> 00:35:24,780
couple of versions of Houdini before we

00:35:22,710 --> 00:35:28,410
can actually clean it up and once we

00:35:24,780 --> 00:35:32,849
clean it up then we can just do using

00:35:28,410 --> 00:35:34,800
and create a type def for our UT atomic

00:35:32,849 --> 00:35:36,540
int and this way we don't actually have

00:35:34,800 --> 00:35:39,030
to change any of our code we still use

00:35:36,540 --> 00:35:42,210
atomic int but underneath it's using a

00:35:39,030 --> 00:35:43,710
steady Tomic and we like this because

00:35:42,210 --> 00:35:44,520
that means that we don't have to change

00:35:43,710 --> 00:35:46,200
our code we

00:35:44,520 --> 00:35:49,550
have to do all these passes through our

00:35:46,200 --> 00:35:53,100
code so we also do this when we pull in

00:35:49,550 --> 00:35:55,260
foreign classes so when we pull in boost

00:35:53,100 --> 00:35:57,360
unordered map actually if you look at it

00:35:55,260 --> 00:35:59,040
it's H boost unordered map that's

00:35:57,360 --> 00:36:02,400
because we went and spent six months

00:35:59,040 --> 00:36:04,200
doing a namespace change so we have H

00:36:02,400 --> 00:36:07,230
boost unordered map and so we create a

00:36:04,200 --> 00:36:10,620
little wrapper around H boost are the

00:36:07,230 --> 00:36:12,240
unordered map and so we use that as UT

00:36:10,620 --> 00:36:15,360
map in all our codes so we don't

00:36:12,240 --> 00:36:20,010
actually ever expose our higher level

00:36:15,360 --> 00:36:22,110
libraries to naked boost and that allows

00:36:20,010 --> 00:36:24,270
us in the future if we want to change

00:36:22,110 --> 00:36:26,430
that to stood on ordered map we can just

00:36:24,270 --> 00:36:31,020
do that and hopefully everything will

00:36:26,430 --> 00:36:35,310
just work fine so some of our classes

00:36:31,020 --> 00:36:37,710
are still around we wrote our UT array

00:36:35,310 --> 00:36:44,240
class which is very similar to Aston

00:36:37,710 --> 00:36:46,980
vector class and this is still around

00:36:44,240 --> 00:36:49,470
one of the things that happens with no

00:36:46,980 --> 00:36:51,390
vector or an array is that as you push

00:36:49,470 --> 00:36:53,640
back items on to the array eventually

00:36:51,390 --> 00:36:56,670
you have to regrow and resize the array

00:36:53,640 --> 00:36:59,760
and the way this is sort of done this is

00:36:56,670 --> 00:37:02,430
very simplified and not correct maybe in

00:36:59,760 --> 00:37:04,980
vector is that you create a temporary

00:37:02,430 --> 00:37:09,660
new array move the old array to the new

00:37:04,980 --> 00:37:11,790
array delete the array reset your reign

00:37:09,660 --> 00:37:13,140
reset your size of course this doesn't

00:37:11,790 --> 00:37:16,970
actually work if you're shrinking the

00:37:13,140 --> 00:37:20,040
array but that's that's another thing so

00:37:16,970 --> 00:37:23,520
and this is this is fine this works

00:37:20,040 --> 00:37:25,580
great but when we started off we were a

00:37:23,520 --> 00:37:30,420
bunch of C programmers who were learning

00:37:25,580 --> 00:37:33,210
C++ in the process and I know that

00:37:30,420 --> 00:37:35,070
there's a term for writing code in a

00:37:33,210 --> 00:37:38,820
pythonic way I don't know if there's a

00:37:35,070 --> 00:37:40,650
term for writing code in C++ way but

00:37:38,820 --> 00:37:44,220
when you get a bunch of C programmers

00:37:40,650 --> 00:37:47,490
transitioning over we we wrote our grow

00:37:44,220 --> 00:37:50,280
capacity like this so we use realloc

00:37:47,490 --> 00:37:54,260
instead of creating a new buffer and

00:37:50,280 --> 00:37:54,260
we'll and then

00:37:55,200 --> 00:38:07,050
just reset the size so there are two two

00:38:03,320 --> 00:38:09,839
artifacts of this one is really subtle

00:38:07,050 --> 00:38:14,070
and the other is really blatant so the

00:38:09,839 --> 00:38:17,520
subtle effect is that realloc doesn't

00:38:14,070 --> 00:38:20,579
actually have to allocate new memory and

00:38:17,520 --> 00:38:23,339
copy over the data if your memory

00:38:20,579 --> 00:38:25,530
allocation library underneath says oh I

00:38:23,339 --> 00:38:29,010
can just grow that buffer you don't have

00:38:25,530 --> 00:38:30,900
to do the reallocation you don't have to

00:38:29,010 --> 00:38:33,660
allocate a new memory new memory and

00:38:30,900 --> 00:38:37,849
copy over the data so there's a there's

00:38:33,660 --> 00:38:40,710
a performance benefit to this and in

00:38:37,849 --> 00:38:42,900
just to make sure that there was a

00:38:40,710 --> 00:38:45,420
performance benefit we did a little

00:38:42,900 --> 00:38:47,760
testing before I came down and we were

00:38:45,420 --> 00:38:51,750
unable to get in vector to ever match

00:38:47,760 --> 00:38:54,780
the performance that we get with our UT

00:38:51,750 --> 00:38:59,190
array in fact when you were compiling

00:38:54,780 --> 00:39:02,690
debug libraries stood the stood vector

00:38:59,190 --> 00:39:06,810
approach is actually twice as slow as

00:39:02,690 --> 00:39:08,520
realloc and you say well debug doesn't

00:39:06,810 --> 00:39:10,319
matter except that it's all developer

00:39:08,520 --> 00:39:12,480
time because if developers are running

00:39:10,319 --> 00:39:15,690
debug libraries then it's their time

00:39:12,480 --> 00:39:18,450
that you're wasting so we get a 2x

00:39:15,690 --> 00:39:21,329
performance by using realloc now the the

00:39:18,450 --> 00:39:24,900
blatant problem with this of course is

00:39:21,329 --> 00:39:27,359
that realloc does a blind copy of the

00:39:24,900 --> 00:39:33,390
memory so works just fine if you've got

00:39:27,359 --> 00:39:35,970
an UT array of double or any pod type it

00:39:33,390 --> 00:39:40,200
actually works on ut unique pointer as

00:39:35,970 --> 00:39:43,220
well which has complicated move

00:39:40,200 --> 00:39:47,460
constructors and and copy

00:39:43,220 --> 00:39:51,300
destructors so it magically works for

00:39:47,460 --> 00:39:53,640
that but of course it doesn't work in a

00:39:51,300 --> 00:39:56,400
lot of cases so for example LLVM small

00:39:53,640 --> 00:39:58,410
vector you've got some the way this is

00:39:56,400 --> 00:40:00,750
laid out is that there's some small

00:39:58,410 --> 00:40:02,849
buffer of storage inside and begin and

00:40:00,750 --> 00:40:05,010
end and when you initialize the vector

00:40:02,849 --> 00:40:07,560
you initialize you begin an end to point

00:40:05,010 --> 00:40:08,700
at the store to this inside so if this

00:40:07,560 --> 00:40:10,950
got

00:40:08,700 --> 00:40:13,500
allocated and blind copied while the

00:40:10,950 --> 00:40:15,799
storage would be copied fine but that

00:40:13,500 --> 00:40:18,630
begin an end pointer would actually be

00:40:15,799 --> 00:40:21,980
pointing to garbage memory the old

00:40:18,630 --> 00:40:25,410
memory that it that that it was using so

00:40:21,980 --> 00:40:28,079
that doesn't work and so you can't use

00:40:25,410 --> 00:40:30,569
aut array of stood string and you can't

00:40:28,079 --> 00:40:35,040
use aut array of small vectors the Dutch

00:40:30,569 --> 00:40:41,549
it just doesn't work boost function does

00:40:35,040 --> 00:40:46,020
work and so in our quest to minimize our

00:40:41,549 --> 00:40:48,030
dependence on boost we said so we had

00:40:46,020 --> 00:40:49,740
this this code that was using aut array

00:40:48,030 --> 00:40:51,809
of boost functions and we said let's

00:40:49,740 --> 00:40:54,660
change it over to aut array of state

00:40:51,809 --> 00:40:58,290
function and so now here's a pop quiz so

00:40:54,660 --> 00:41:02,150
how many people think that realloc will

00:40:58,290 --> 00:41:05,549
work with stood function hands up

00:41:02,150 --> 00:41:07,170
two people two people I see them how

00:41:05,549 --> 00:41:11,609
many people think that it's not going to

00:41:07,170 --> 00:41:14,099
work much larger percentage maybe 25%

00:41:11,609 --> 00:41:19,230
and how many people don't know or don't

00:41:14,099 --> 00:41:22,980
care okay so it turns out that everyone

00:41:19,230 --> 00:41:26,220
is right so on some platforms state

00:41:22,980 --> 00:41:28,200
function does work under reallocation on

00:41:26,220 --> 00:41:30,210
other platforms it doesn't on some

00:41:28,200 --> 00:41:35,280
platforms it has an introspective

00:41:30,210 --> 00:41:38,130
pointer and so we were fortunate this

00:41:35,280 --> 00:41:42,089
this code actually was only used in one

00:41:38,130 --> 00:41:43,980
place and we were able to figure out we

00:41:42,089 --> 00:41:46,589
were able to pre compute how big the

00:41:43,980 --> 00:41:49,980
array was so we actually didn't even

00:41:46,589 --> 00:41:51,869
need to grow the array so in in the long

00:41:49,980 --> 00:41:54,869
run we actually improved our code when

00:41:51,869 --> 00:41:58,170
we switched over because you never have

00:41:54,869 --> 00:42:01,980
to grow the buffers but we're very very

00:41:58,170 --> 00:42:04,049
very excited to see I can't pronounce it

00:42:01,980 --> 00:42:06,589
but we're excited to see trivially

00:42:04,049 --> 00:42:09,329
relocatable coming down the standard

00:42:06,589 --> 00:42:12,329
this is not just so that we can fix our

00:42:09,329 --> 00:42:15,180
code but it's also so that we can make

00:42:12,329 --> 00:42:18,000
our code better we can we can figure out

00:42:15,180 --> 00:42:19,680
why and where we want this kind of

00:42:18,000 --> 00:42:24,990
behavior

00:42:19,680 --> 00:42:28,780
so for the the next part of the talk I'm

00:42:24,990 --> 00:42:30,609
next C++ code you need to understand a

00:42:28,780 --> 00:42:35,050
little bit about how our geometry is

00:42:30,609 --> 00:42:37,119
stored in in Houdini so we have some

00:42:35,050 --> 00:42:40,030
specialized classes in Houdini that are

00:42:37,119 --> 00:42:44,109
specific for geometry but can be

00:42:40,030 --> 00:42:46,089
generalized so the way that who did the

00:42:44,109 --> 00:42:51,339
simplest piece of geometry and Houdini

00:42:46,089 --> 00:42:53,500
is a point just like in Euclid so a

00:42:51,339 --> 00:42:55,839
point in Houdini can have a whole bunch

00:42:53,500 --> 00:42:57,940
of attributes or properties to it so it

00:42:55,839 --> 00:43:02,770
could have a position a velocity

00:42:57,940 --> 00:43:04,990
temperature color what whatever the user

00:43:02,770 --> 00:43:08,829
needs to have on the point can be on

00:43:04,990 --> 00:43:11,710
that point if you've got a cloud points

00:43:08,829 --> 00:43:16,180
every point in Houdini will have the

00:43:11,710 --> 00:43:19,150
same set of attributes when you connect

00:43:16,180 --> 00:43:22,030
the points you create a primitive and so

00:43:19,150 --> 00:43:24,130
that face can also have attributes on it

00:43:22,030 --> 00:43:26,530
so you can have one of the attributes is

00:43:24,130 --> 00:43:28,780
a vector of the points that are being

00:43:26,530 --> 00:43:30,520
referenced another could be a string

00:43:28,780 --> 00:43:32,829
representing the shader that's going to

00:43:30,520 --> 00:43:35,170
be applied to that face and so if you

00:43:32,829 --> 00:43:38,170
have two primitives you end up with the

00:43:35,170 --> 00:43:41,730
same properties their attributes on each

00:43:38,170 --> 00:43:45,640
primitive so you can represent this as

00:43:41,730 --> 00:43:48,730
an array of struts which would kind of

00:43:45,640 --> 00:43:51,160
look like this or you could represent it

00:43:48,730 --> 00:43:53,559
the way we do which is a struct of

00:43:51,160 --> 00:43:56,020
arrays which is allows us to have a lot

00:43:53,559 --> 00:43:58,900
more efficiency so we have a struct of

00:43:56,020 --> 00:44:02,680
arrays where you end up with a different

00:43:58,900 --> 00:44:05,140
layout in memory but the same data so if

00:44:02,680 --> 00:44:08,559
we look at that that original node

00:44:05,140 --> 00:44:11,890
network of the the fonts if we look at

00:44:08,559 --> 00:44:13,390
how the the data is stored each node in

00:44:11,890 --> 00:44:16,690
that graph we want to be able to keep

00:44:13,390 --> 00:44:18,130
caches so that has as parameters change

00:44:16,690 --> 00:44:20,799
you don't have to re-evaluate the whole

00:44:18,130 --> 00:44:23,920
graph every time a parameter changes so

00:44:20,799 --> 00:44:28,619
we have we have caches and so each cache

00:44:23,920 --> 00:44:32,200
will store a copy of the geometry in the

00:44:28,619 --> 00:44:32,940
top geometry you've only got 740 points

00:44:32,200 --> 00:44:35,819
and 10

00:44:32,940 --> 00:44:38,190
faces but after you extrude it you get a

00:44:35,819 --> 00:44:40,770
lot more faces and a lot more vertices

00:44:38,190 --> 00:44:48,359
so you're up to almost 3000 positions

00:44:40,770 --> 00:44:51,450
and then 768 vertices per in the 760

00:44:48,359 --> 00:44:55,290
faces pardon me and then when you add

00:44:51,450 --> 00:44:57,540
color to it we add a new color array so

00:44:55,290 --> 00:45:00,240
in Houdini when you're passing geometry

00:44:57,540 --> 00:45:03,270
down from node to node there's a lot of

00:45:00,240 --> 00:45:05,760
data that's being copied so when you

00:45:03,270 --> 00:45:08,760
look at that that colored geometry

00:45:05,760 --> 00:45:10,619
you've got that the position points to a

00:45:08,760 --> 00:45:12,050
blue block of memory and the color

00:45:10,619 --> 00:45:17,150
points to the orange block of memory

00:45:12,050 --> 00:45:21,240
each is a size of float three times the

00:45:17,150 --> 00:45:24,569
3,000 so it's about 36 K it's not bad

00:45:21,240 --> 00:45:27,839
color is about the same so 36 K and then

00:45:24,569 --> 00:45:30,359
the naive approach would be to just copy

00:45:27,839 --> 00:45:34,230
that memory copy those vectors over and

00:45:30,359 --> 00:45:35,849
then work on the new vectors but you

00:45:34,230 --> 00:45:38,730
know we're computer scientists we know

00:45:35,849 --> 00:45:42,329
better than that we can use Cal and if

00:45:38,730 --> 00:45:46,710
you think that I'm going to avoid the

00:45:42,329 --> 00:45:48,300
opportunity to use a fancy pun like this

00:45:46,710 --> 00:45:52,859
you're mistaken

00:45:48,300 --> 00:45:55,650
it's not that cow it's copy on right so

00:45:52,859 --> 00:45:59,130
the way that Houdini works is we use

00:45:55,650 --> 00:46:01,079
copy-on-write we have pointers to the

00:45:59,130 --> 00:46:04,589
original geometry and if you need to

00:46:01,079 --> 00:46:07,680
modify something well you make it

00:46:04,589 --> 00:46:11,490
duplicate when you when you go to write

00:46:07,680 --> 00:46:14,400
it and so to understand sort of how this

00:46:11,490 --> 00:46:17,790
affects your Dini geometry let's take a

00:46:14,400 --> 00:46:19,470
look at some standard geometry so the

00:46:17,790 --> 00:46:22,579
the Stanford Bunny is seven hundred

00:46:19,470 --> 00:46:26,369
thousand triangles 360 thousand points

00:46:22,579 --> 00:46:28,410
so this can save a ton of memory when

00:46:26,369 --> 00:46:30,060
you're copying that around the Stanford

00:46:28,410 --> 00:46:36,750
Dragon is five point five million

00:46:30,060 --> 00:46:38,130
triangles I've got some custom movie

00:46:36,750 --> 00:46:40,890
character which I can't show you the

00:46:38,130 --> 00:46:44,609
picture it comes in at about 20 million

00:46:40,890 --> 00:46:46,350
polygons 20 million points the movie

00:46:44,609 --> 00:46:48,270
modelers tend to make

00:46:46,350 --> 00:46:51,210
quadrilateral meshes rather than

00:46:48,270 --> 00:46:54,510
triangle meshes so when we're looking at

00:46:51,210 --> 00:46:56,820
when we look at a piece of geometry

00:46:54,510 --> 00:47:00,630
you're now looking for the the P array

00:46:56,820 --> 00:47:03,720
you're looking at 240 ma so when you

00:47:00,630 --> 00:47:06,420
copy that 240 Meg or when you push a

00:47:03,720 --> 00:47:10,230
push back a new point on to that that's

00:47:06,420 --> 00:47:12,420
that can be a big cost so UT array for

00:47:10,230 --> 00:47:17,550
example gives us a little benefit when

00:47:12,420 --> 00:47:20,670
we're doing that but if you only want to

00:47:17,550 --> 00:47:22,530
change one point in that array cow

00:47:20,670 --> 00:47:24,960
doesn't help because you still have to

00:47:22,530 --> 00:47:28,020
copy that entire array just to move one

00:47:24,960 --> 00:47:32,430
point so I know this is being covered in

00:47:28,020 --> 00:47:35,520
other cpp contacts but we have a page to

00:47:32,430 --> 00:47:38,880
Ray so rather than representing our

00:47:35,520 --> 00:47:41,790
entire geometry arrays as a flat array

00:47:38,880 --> 00:47:43,530
we actually have pages of data what's

00:47:41,790 --> 00:47:46,340
what's nice about this is that if you

00:47:43,530 --> 00:47:49,020
push back a bunch of items on this array

00:47:46,340 --> 00:47:51,720
you don't have to copy over those other

00:47:49,020 --> 00:47:53,460
pages they're immutable so you can

00:47:51,720 --> 00:47:57,000
actually just allocate a new page and

00:47:53,460 --> 00:47:59,640
write data to that so there there's a

00:47:57,000 --> 00:48:02,130
lot of benefits to this is it adds a

00:47:59,640 --> 00:48:05,220
little complexity but if you want to

00:48:02,130 --> 00:48:12,000
move that one point there you only have

00:48:05,220 --> 00:48:14,010
to copy that one page so there's a huge

00:48:12,000 --> 00:48:15,930
huge memory benefit if you're only doing

00:48:14,010 --> 00:48:18,060
a little manipulation so if someone if

00:48:15,930 --> 00:48:20,940
in modeler is just playing with the the

00:48:18,060 --> 00:48:23,060
shape of the mouth then you don't have

00:48:20,940 --> 00:48:26,100
to copy over a ton of data all the time

00:48:23,060 --> 00:48:29,190
so our page array looks kind of like

00:48:26,100 --> 00:48:32,880
this where the square bracket operator

00:48:29,190 --> 00:48:34,650
just splits the offset into a page and

00:48:32,880 --> 00:48:39,660
offset within the page and does that

00:48:34,650 --> 00:48:42,480
look out but we after a lot of analysis

00:48:39,660 --> 00:48:43,800
of the the pages of data that we get we

00:48:42,480 --> 00:48:45,990
actually found that there were other

00:48:43,800 --> 00:48:48,420
things that we could do so a lot of

00:48:45,990 --> 00:48:50,940
times let's say you apply color to piece

00:48:48,420 --> 00:48:53,550
of geometry a lot of times the color is

00:48:50,940 --> 00:48:56,820
constant over a page so what we'll do is

00:48:53,550 --> 00:48:59,360
we'll when once we can do that once

00:48:56,820 --> 00:49:01,040
we've got pages we can analyze each page

00:48:59,360 --> 00:49:03,230
and if the value is constant over the

00:49:01,040 --> 00:49:05,900
page then we just represent that as a

00:49:03,230 --> 00:49:08,000
single value so that saves even more

00:49:05,900 --> 00:49:10,370
memory but it also allows us to do

00:49:08,000 --> 00:49:12,110
operations across the geometry where we

00:49:10,370 --> 00:49:14,240
only have to change one value so if we

00:49:12,110 --> 00:49:16,310
wanted to change the color from red to

00:49:14,240 --> 00:49:18,020
blue well we would only have to change

00:49:16,310 --> 00:49:21,410
it in one place rather than changing it

00:49:18,020 --> 00:49:24,830
on in millions of places so we can work

00:49:21,410 --> 00:49:28,190
a little more efficiently that way the

00:49:24,830 --> 00:49:31,100
the constant page compression or any

00:49:28,190 --> 00:49:32,720
page compression adds cost to the square

00:49:31,100 --> 00:49:36,260
bracket operator on the page shaded

00:49:32,720 --> 00:49:37,760
class but it's a small small price to

00:49:36,260 --> 00:49:39,770
pay when you're dealing with like a

00:49:37,760 --> 00:49:41,410
billion particles trying to move them

00:49:39,770 --> 00:49:46,760
around and only some of them are moving

00:49:41,410 --> 00:49:51,200
you get a lot of benefit and that brings

00:49:46,760 --> 00:49:53,930
us to strings so as you saw with the two

00:49:51,200 --> 00:49:56,480
triangles the strings the the triangles

00:49:53,930 --> 00:49:59,780
can store its string attributes on on as

00:49:56,480 --> 00:50:03,470
their data so that means that you can

00:49:59,780 --> 00:50:06,110
have the user and we don't control what

00:50:03,470 --> 00:50:09,350
goes into the strings the user control

00:50:06,110 --> 00:50:12,020
can add string data to every polygon in

00:50:09,350 --> 00:50:15,050
the model if they want and often those

00:50:12,020 --> 00:50:18,740
strings are repeated or the the same

00:50:15,050 --> 00:50:21,800
thing so one of the types of data that

00:50:18,740 --> 00:50:24,710
they have that we have is a style sheet

00:50:21,800 --> 00:50:26,690
so just like cascading style sheets we

00:50:24,710 --> 00:50:29,800
have a little snippet of Jason which

00:50:26,690 --> 00:50:32,990
determines how materials get applied to

00:50:29,800 --> 00:50:38,270
primitives so there's a nice little

00:50:32,990 --> 00:50:40,340
simple style sheet and we never expected

00:50:38,270 --> 00:50:43,190
users to create a 15 megabyte style

00:50:40,340 --> 00:50:45,260
sheet so there was a user out there who

00:50:43,190 --> 00:50:47,090
created a 15 megabyte style sheet and

00:50:45,260 --> 00:50:50,300
then copied that style sheet to a

00:50:47,090 --> 00:50:52,550
thousand primitives and so just very

00:50:50,300 --> 00:50:56,450
quickly you get up to 15 gigabytes of

00:50:52,550 --> 00:51:00,290
string data so we wanted something that

00:50:56,450 --> 00:51:02,750
would would be able to deal with that

00:51:00,290 --> 00:51:07,460
like cow like that the way we deal with

00:51:02,750 --> 00:51:10,100
cow on geometry so we said well stead

00:51:07,460 --> 00:51:12,650
string used to be like that on GCC until

00:51:10,100 --> 00:51:13,160
they put the SSO in and the reason that

00:51:12,650 --> 00:51:17,750
it was

00:51:13,160 --> 00:51:19,430
not is not like that now is that the

00:51:17,750 --> 00:51:21,470
square bracket operator allows you to

00:51:19,430 --> 00:51:23,780
modify the string so you need so it

00:51:21,470 --> 00:51:27,980
needs to do cow and and it gets very

00:51:23,780 --> 00:51:29,569
complicated with threads but we said we

00:51:27,980 --> 00:51:31,280
don't actually want a string to

00:51:29,569 --> 00:51:34,069
manipulate the string we just want a

00:51:31,280 --> 00:51:38,059
string to store the string so we came up

00:51:34,069 --> 00:51:39,980
with a string holder class so there's a

00:51:38,059 --> 00:51:41,960
nested class in there called holder

00:51:39,980 --> 00:51:44,630
which actually stores the strings

00:51:41,960 --> 00:51:46,760
towards this length stores a hash and a

00:51:44,630 --> 00:51:49,970
rough town we could have done this with

00:51:46,760 --> 00:51:51,650
like an intrusive pointer but the

00:51:49,970 --> 00:51:55,430
intrusive pointer doesn't have see stir

00:51:51,650 --> 00:51:58,190
or length so being able to have a little

00:51:55,430 --> 00:52:00,319
wrapper class around that is is a we

00:51:58,190 --> 00:52:02,750
found a nice thing so the idea is that

00:52:00,319 --> 00:52:04,760
you have a string holder it's reference

00:52:02,750 --> 00:52:06,890
counted that same string can be used

00:52:04,760 --> 00:52:09,859
thousands or millions of times in your

00:52:06,890 --> 00:52:14,539
in your data and it's it's not there's

00:52:09,859 --> 00:52:17,240
almost no cost the atomic cost and then

00:52:14,539 --> 00:52:19,880
we started looking at our code and there

00:52:17,240 --> 00:52:25,910
were a lot of places where we had static

00:52:19,880 --> 00:52:29,990
data so static data adds to your startup

00:52:25,910 --> 00:52:34,099
time and we constantly try to minimize

00:52:29,990 --> 00:52:36,440
our startup time it costs developer time

00:52:34,099 --> 00:52:38,420
it cost user time if your application

00:52:36,440 --> 00:52:41,270
takes a long time to start out so

00:52:38,420 --> 00:52:45,490
there's this this class this case where

00:52:41,270 --> 00:52:48,559
you've got a static string holder which

00:52:45,490 --> 00:52:50,869
at startup time is going to do an

00:52:48,559 --> 00:52:55,010
allocation and a memory copy of that

00:52:50,869 --> 00:52:59,420
literal into the the object and that's

00:52:55,010 --> 00:53:02,839
no good so we wanted something that was

00:52:59,420 --> 00:53:05,510
like a UT string reference so it

00:53:02,839 --> 00:53:08,059
referred to the string instead of

00:53:05,510 --> 00:53:10,190
actually holding it so we modified our

00:53:08,059 --> 00:53:13,400
string holder to be a string reference

00:53:10,190 --> 00:53:16,369
and if you look there's a union of a

00:53:13,400 --> 00:53:19,069
pointer to the literal or a pointer to

00:53:16,369 --> 00:53:21,619
the holder and we used the length of the

00:53:19,069 --> 00:53:25,400
string that's stored in the string

00:53:21,619 --> 00:53:26,430
holder as or the string ref as a flag to

00:53:25,400 --> 00:53:29,150
switch

00:53:26,430 --> 00:53:34,470
whether it's actually a holder or

00:53:29,150 --> 00:53:36,450
reference to literal so if it's a if

00:53:34,470 --> 00:53:39,380
it's a holder we can actually store the

00:53:36,450 --> 00:53:41,579
length with the holder object if it's a

00:53:39,380 --> 00:53:44,970
literal we actually store the length

00:53:41,579 --> 00:53:46,950
with the string and so the constructor

00:53:44,970 --> 00:53:51,569
for the string ref looks kind of like

00:53:46,950 --> 00:53:53,910
this if the string fits has a string

00:53:51,569 --> 00:53:56,190
literal then we actually just keep a

00:53:53,910 --> 00:53:58,079
pointer to the string literal and set

00:53:56,190 --> 00:54:00,329
the length to the length if it's

00:53:58,079 --> 00:54:02,549
otherwise if it's a null string this

00:54:00,329 --> 00:54:05,369
passed in or an empty string what we'll

00:54:02,549 --> 00:54:08,640
do is we'll store point at the holder to

00:54:05,369 --> 00:54:11,130
a singleton empty string holder and if

00:54:08,640 --> 00:54:14,579
it's if the literal is actually bigger

00:54:11,130 --> 00:54:15,359
than unsigned int max will allocate a

00:54:14,579 --> 00:54:18,000
holder for it

00:54:15,359 --> 00:54:20,910
so our holders will actually store very

00:54:18,000 --> 00:54:22,589
very large strings and if it's a small

00:54:20,910 --> 00:54:25,589
string and it's a literal we can

00:54:22,589 --> 00:54:29,549
actually store it quite nicely so the

00:54:25,589 --> 00:54:32,010
the copy constructor just copies over

00:54:29,549 --> 00:54:35,039
the member data but then it says if it

00:54:32,010 --> 00:54:38,010
is a holder we've got to make sure to

00:54:35,039 --> 00:54:40,380
reference the holder and if and the

00:54:38,010 --> 00:54:47,849
destructor if if it is a holder we

00:54:40,380 --> 00:54:50,700
dereference the holder so this is a sort

00:54:47,849 --> 00:54:53,490
of I think it's a fairly unique pattern

00:54:50,700 --> 00:54:56,339
I haven't seen it anywhere else is what

00:54:53,490 --> 00:54:59,549
we do is we subclass strengths holder

00:54:56,339 --> 00:55:02,160
from string ref so there's no data on a

00:54:59,549 --> 00:55:04,710
string holder they are identically in

00:55:02,160 --> 00:55:06,270
memory the same object but they have

00:55:04,710 --> 00:55:10,289
different behavior on their constructor

00:55:06,270 --> 00:55:12,859
and same behavior on the destructor so

00:55:10,289 --> 00:55:16,920
the constructor of a ut string holder

00:55:12,859 --> 00:55:20,250
will always make a copy of the data so

00:55:16,920 --> 00:55:21,839
if you pass in a car it's gonna it's

00:55:20,250 --> 00:55:24,049
going to duplicate that cost card this

00:55:21,839 --> 00:55:27,869
is sort of they listed string behavior

00:55:24,049 --> 00:55:29,700
except that its reference counted the

00:55:27,869 --> 00:55:33,599
copy constructor when it takes a ut

00:55:29,700 --> 00:55:36,089
string ref it if there is a hold or if

00:55:33,599 --> 00:55:38,279
there's no holder it will duplicate

00:55:36,089 --> 00:55:40,230
whatever the data coming in is because

00:55:38,279 --> 00:55:41,670
the string refs are cause chars and

00:55:40,230 --> 00:55:44,010
short lived you don't know about their

00:55:41,670 --> 00:55:45,840
lifetime so the string holder you're

00:55:44,010 --> 00:55:49,050
guaranteed that the string will always

00:55:45,840 --> 00:55:51,210
be held around otherwise if it is a

00:55:49,050 --> 00:55:52,920
holder we actually just do the the same

00:55:51,210 --> 00:55:57,600
thing as what was done in the string

00:55:52,920 --> 00:55:59,730
breath copier and for the holder we

00:55:57,600 --> 00:56:04,260
always set the length to zero to

00:55:59,730 --> 00:56:05,910
indicate that there's a holder so what's

00:56:04,260 --> 00:56:08,730
kind of nice about this is that we have

00:56:05,910 --> 00:56:11,369
the same object but we can look at it in

00:56:08,730 --> 00:56:14,190
different ways so if we have a clasp

00:56:11,369 --> 00:56:17,070
string set the fine method takes a

00:56:14,190 --> 00:56:19,380
string ref because we know that we're

00:56:17,070 --> 00:56:21,690
never gonna hold that string inside the

00:56:19,380 --> 00:56:24,000
string wrap and inside the the string

00:56:21,690 --> 00:56:27,630
set the insert method on the other hand

00:56:24,000 --> 00:56:29,340
takes a string holder and because it

00:56:27,630 --> 00:56:30,840
will make a copy of that string holder

00:56:29,340 --> 00:56:34,040
will reference that string holder inside

00:56:30,840 --> 00:56:36,660
itself so if you write code like this

00:56:34,040 --> 00:56:39,840
where you pass in a literal hello in a

00:56:36,660 --> 00:56:42,390
literal world to insert we actually

00:56:39,840 --> 00:56:45,390
duplicate those hello in the world when

00:56:42,390 --> 00:56:49,950
they're inserted but when we call find

00:56:45,390 --> 00:56:52,020
we don't create a duplication so it just

00:56:49,950 --> 00:56:55,260
creates a temporary short-lived string

00:56:52,020 --> 00:56:57,300
ref object and then if you pull

00:56:55,260 --> 00:56:59,160
something out you get a string holder

00:56:57,300 --> 00:57:04,640
which you can just reference with the

00:56:59,160 --> 00:57:08,670
anatomic an intrusive reference count so

00:57:04,640 --> 00:57:10,320
one we had a developer come in who

00:57:08,670 --> 00:57:13,530
worked on a sort of side project and

00:57:10,320 --> 00:57:16,560
they wrote it all using good strength

00:57:13,530 --> 00:57:22,260
and we got them to change over to UT

00:57:16,560 --> 00:57:24,690
string holder and there was a so there

00:57:22,260 --> 00:57:27,690
was a huge drop in the number of calls

00:57:24,690 --> 00:57:29,640
to malloc and malloc is one of those

00:57:27,690 --> 00:57:31,560
things that is it's like a death of a

00:57:29,640 --> 00:57:32,910
thousand cuts you can never get rid of

00:57:31,560 --> 00:57:36,060
those calls to malloc because

00:57:32,910 --> 00:57:38,820
everybody's doing something with it but

00:57:36,060 --> 00:57:41,250
by switching over to a reference counted

00:57:38,820 --> 00:57:44,640
string we we were able to cut the calls

00:57:41,250 --> 00:57:49,460
to malloc 20x which is huge

00:57:44,640 --> 00:57:49,460
and it's it's those kind of small little

00:57:50,030 --> 00:57:53,880
optimizations that are really hard to

00:57:52,260 --> 00:57:57,580
find sometimes

00:57:53,880 --> 00:57:59,610
so because you T string ref and you T

00:57:57,580 --> 00:58:04,210
string holder are the exact same object

00:57:59,610 --> 00:58:07,600
we can use this pattern which is to you

00:58:04,210 --> 00:58:10,450
team a gun safe unsafe Roth so given a

00:58:07,600 --> 00:58:15,730
reference we can reinterpret cast that

00:58:10,450 --> 00:58:17,980
to a holder you think well that's really

00:58:15,730 --> 00:58:19,930
dangerous and it sort of is except that

00:58:17,980 --> 00:58:23,170
the string ref actually handles the

00:58:19,930 --> 00:58:28,080
string holder case just fine so we can

00:58:23,170 --> 00:58:30,670
now make a const UT string holder that

00:58:28,080 --> 00:58:34,720
doesn't do any allocation at startup

00:58:30,670 --> 00:58:37,330
time which is good so of course what

00:58:34,720 --> 00:58:40,420
we'd like to do with this is to make a

00:58:37,330 --> 00:58:45,910
user-defined literal and just do this

00:58:40,420 --> 00:58:48,100
instead and with C++ 11 we had a little

00:58:45,910 --> 00:58:52,150
fun trying to get the hash function

00:58:48,100 --> 00:58:55,150
context per we managed to do it and this

00:58:52,150 --> 00:58:57,790
was this was all working and we were so

00:58:55,150 --> 00:58:59,650
happy the first time we did this in

00:58:57,790 --> 00:59:01,660
working right out of the box the hash

00:58:59,650 --> 00:59:03,730
was computed at runtime the length was

00:59:01,660 --> 00:59:05,740
computed in runtime the data was stored

00:59:03,730 --> 00:59:07,330
it was all just beautiful and then we

00:59:05,740 --> 00:59:07,960
tried it on another compiler and it

00:59:07,330 --> 00:59:11,710
didn't work

00:59:07,960 --> 00:59:13,930
so the first compiler we had lied to us

00:59:11,710 --> 00:59:17,260
saying that you know this was the right

00:59:13,930 --> 00:59:20,170
thing to do it was we're very happy that

00:59:17,260 --> 00:59:26,650
it did that but in general we can't

00:59:20,170 --> 00:59:28,240
really rely on it and we we never found

00:59:26,650 --> 00:59:30,910
a solution we tried seven ways till

00:59:28,240 --> 00:59:32,980
Sunday to try to figure out a way to

00:59:30,910 --> 00:59:34,930
have this user-defined literal do what

00:59:32,980 --> 00:59:37,060
we wanted and we actually ended up

00:59:34,930 --> 00:59:40,530
having to create a new class in the

00:59:37,060 --> 00:59:43,900
hierarchy ut string literal which is

00:59:40,530 --> 00:59:47,290
just it allows us to have the context

00:59:43,900 --> 00:59:49,450
for a compile time eventually we'd like

00:59:47,290 --> 00:59:53,380
to go to the user to find the literal

00:59:49,450 --> 00:59:55,180
and we're very happy than in C++ 20 we

00:59:53,380 --> 00:59:56,500
should be able to if we read it right we

00:59:55,180 --> 00:59:59,590
should be able to do something like this

00:59:56,500 --> 01:00:03,010
and there was a great talk on reg X

00:59:59,590 --> 01:00:05,720
earlier that also is looking forward to

01:00:03,010 --> 01:00:08,450
this and with

01:00:05,720 --> 01:00:11,960
VFX reference platform we should be able

01:00:08,450 --> 01:00:16,190
to do this in like 2027 or 2028 looking

01:00:11,960 --> 01:00:19,609
forward to it and so now we've been

01:00:16,190 --> 01:00:23,599
writing C++ code for over 25 years and

01:00:19,609 --> 01:00:29,090
so to close off I'd like to have a few

01:00:23,599 --> 01:00:32,720
reflections the first thing is that

01:00:29,090 --> 01:00:34,730
we've sort of learned is don't jump on

01:00:32,720 --> 01:00:38,530
the bandwagon before the bandwagon is

01:00:34,730 --> 01:00:41,030
ready when we started using templates in

01:00:38,530 --> 01:00:44,450
1992 we tried to do the right thing we

01:00:41,030 --> 01:00:48,200
tried to do it but the compiler hurt us

01:00:44,450 --> 01:00:51,349
it chewed us up and spit us out and it

01:00:48,200 --> 01:00:54,140
burned us and so if you tried to jump on

01:00:51,349 --> 01:00:57,130
the bandwagon before it's ready and you

01:00:54,140 --> 01:00:57,130
can sometimes get burned

01:00:57,200 --> 01:01:02,630
number two don't jump on the run wrong

01:00:59,930 --> 01:01:05,390
bandwagon back in 1992 we thought

01:01:02,630 --> 01:01:08,300
inheritance was the way to go so we are

01:01:05,390 --> 01:01:11,690
struggling now with you wouldn't believe

01:01:08,300 --> 01:01:13,430
how deep the inheritance goes in some of

01:01:11,690 --> 01:01:15,740
our class hierarchies is awful it's

01:01:13,430 --> 01:01:18,290
nobody cannot comprehend it it's it's

01:01:15,740 --> 01:01:25,010
terrible inheritance of course has a

01:01:18,290 --> 01:01:28,880
place but don't overuse it the next

01:01:25,010 --> 01:01:31,940
thing we will of course continue to

01:01:28,880 --> 01:01:36,280
transition to more SQL classes getting

01:01:31,940 --> 01:01:40,040
rid of our all our obsolete classes

01:01:36,280 --> 01:01:42,589
because standards are a good thing but I

01:01:40,040 --> 01:01:47,990
think there's always going to be places

01:01:42,589 --> 01:01:52,280
for custom classes and and custom

01:01:47,990 --> 01:01:53,839
patterns that you t string rough pattern

01:01:52,280 --> 01:01:55,820
that we have there are other classes

01:01:53,839 --> 01:01:58,280
that we can apply that to some of our UI

01:01:55,820 --> 01:02:00,530
classes could really use the idea of

01:01:58,280 --> 01:02:02,540
something that's not construct doesn't

01:02:00,530 --> 01:02:06,290
have the expensive construction costed

01:02:02,540 --> 01:02:11,830
at startup time and then but has a way

01:02:06,290 --> 01:02:11,830
to be a safe version where ownership is

01:02:13,599 --> 01:02:21,230
performance is hard to retrofit so

01:02:17,000 --> 01:02:23,570
everyone and I will also tell you stay

01:02:21,230 --> 01:02:26,750
away from early optimization premature

01:02:23,570 --> 01:02:30,410
optimization but when you're designing

01:02:26,750 --> 01:02:33,859
code make sure to have performance in

01:02:30,410 --> 01:02:35,450
mind because if you say oh I can worry

01:02:33,859 --> 01:02:35,869
about this later and come back to it

01:02:35,450 --> 01:02:38,690
later

01:02:35,869 --> 01:02:40,910
well when you come back to it later it's

01:02:38,690 --> 01:02:42,710
gonna be I it's going to be a big

01:02:40,910 --> 01:02:45,260
rewrite and you don't want to have to do

01:02:42,710 --> 01:02:47,920
that so always have performance in the

01:02:45,260 --> 01:02:47,920
back of your mind

01:02:50,050 --> 01:02:56,240
be aware of template abuse so templates

01:02:53,420 --> 01:02:59,180
we stayed away from and now we embrace

01:02:56,240 --> 01:03:02,960
them as we should generic program is

01:02:59,180 --> 01:03:06,349
great but beware of template abuse I

01:03:02,960 --> 01:03:09,470
debated with myself whether to to call

01:03:06,349 --> 01:03:11,450
out open VT be my name that's a library

01:03:09,470 --> 01:03:17,690
that all of the visual effects industry

01:03:11,450 --> 01:03:23,119
uses when we were using GCC 5 and other

01:03:17,690 --> 01:03:26,720
compilers while GCC was using 3.5 gig

01:03:23,119 --> 01:03:30,670
per source file to compile the code in

01:03:26,720 --> 01:03:35,089
open V DB and when we moved to GCC 6.3

01:03:30,670 --> 01:03:37,820
it's using 6.5 gig to compile those

01:03:35,089 --> 01:03:40,820
source files so compiler writers out

01:03:37,820 --> 01:03:43,760
there please I encourage you to download

01:03:40,820 --> 01:03:48,080
open V DB and see what's going on

01:03:43,760 --> 01:03:50,810
please we have some beefy machines at

01:03:48,080 --> 01:03:53,180
side effects right my machines got 64

01:03:50,810 --> 01:03:56,000
gig and 32 cores it's it's great it's

01:03:53,180 --> 01:03:58,760
fun to compile on but we had to change

01:03:56,000 --> 01:04:01,790
our build process for open V DB because

01:03:58,760 --> 01:04:03,619
when you get 32 instances of a compiler

01:04:01,790 --> 01:04:08,800
running and each of them is taking over

01:04:03,619 --> 01:04:13,040
6 gig that pushes all machines right and

01:04:08,800 --> 01:04:17,599
the last one is is gonna sound a little

01:04:13,040 --> 01:04:19,910
bit jaded but you know we've been burned

01:04:17,599 --> 01:04:22,100
by standard libraries we've been burned

01:04:19,910 --> 01:04:23,920
by operating systems we've been burned

01:04:22,100 --> 01:04:26,950
by compilers

01:04:23,920 --> 01:04:29,800
so trust no one don't trust the

01:04:26,950 --> 01:04:31,990
operating system don't trust compilers

01:04:29,800 --> 01:04:34,870
and most importantly don't trust your

01:04:31,990 --> 01:04:37,380
own code okay thank you if there are any

01:04:34,870 --> 01:04:37,380
questions

01:04:47,320 --> 01:04:52,520
one of the points you made in the

01:04:50,030 --> 01:04:55,250
reflections was to not jump on the wrong

01:04:52,520 --> 01:04:57,230
bandwagon and I think that's very easy

01:04:55,250 --> 01:05:00,260
to say in hindsight so do you have some

01:04:57,230 --> 01:05:02,450
tips for identifying the wrong bandwagon

01:05:00,260 --> 01:05:05,960
or conversely the right bandwagon that's

01:05:02,450 --> 01:05:10,910
that's a really hard question I think

01:05:05,960 --> 01:05:13,750
that yeah so we still jump on the wrong

01:05:10,910 --> 01:05:17,270
bandwagon every once in a while I

01:05:13,750 --> 01:05:18,800
personally have overused Auto I think

01:05:17,270 --> 01:05:22,160
that there are certain rules of thumb

01:05:18,800 --> 01:05:24,320
that you sort of pick up as you go along

01:05:22,160 --> 01:05:26,480
the good patterns and the bad patterns

01:05:24,320 --> 01:05:29,240
and so it's it's constantly in a

01:05:26,480 --> 01:05:32,030
learning experience sometimes though the

01:05:29,240 --> 01:05:34,940
run the bandwagons can be really really

01:05:32,030 --> 01:05:37,550
big and in those cases like generic

01:05:34,940 --> 01:05:40,160
programming you probably want to give it

01:05:37,550 --> 01:05:43,190
a little time to set in I'm sorry Barney

01:05:40,160 --> 01:05:45,080
but concepts I'm gonna wait just a

01:05:43,190 --> 01:05:53,420
little bit to see how how it works

01:05:45,080 --> 01:05:56,840
oh hey Marc good talk what do you think

01:05:53,420 --> 01:05:58,400
about adding geometry types to the

01:05:56,840 --> 01:05:59,870
standard library do you think that's

01:05:58,400 --> 01:06:02,240
something that you guys would use if we

01:05:59,870 --> 01:06:06,710
had some standard geometry types and

01:06:02,240 --> 01:06:09,920
primitives and I think we would probably

01:06:06,710 --> 01:06:12,470
shy away from that but that's just me I

01:06:09,920 --> 01:06:14,480
I think that when you look at geometry

01:06:12,470 --> 01:06:16,910
the the different ways of representing

01:06:14,480 --> 01:06:18,650
geometry a real time engine is going to

01:06:16,910 --> 01:06:21,910
have to represent it very differently

01:06:18,650 --> 01:06:26,060
than a DCC the digital content creation

01:06:21,910 --> 01:06:29,000
so I think that finding a standard way

01:06:26,060 --> 01:06:35,900
of representing geometry might be a very

01:06:29,000 --> 01:06:38,570
very difficult problem yeah okay hi

01:06:35,900 --> 01:06:42,500
great talk by the way good question why

01:06:38,570 --> 01:06:44,840
is atomic in the template class in the

01:06:42,500 --> 01:06:47,630
examples showed you had the atomic int

01:06:44,840 --> 01:06:50,000
the gas in class and it was a templated

01:06:47,630 --> 01:06:52,160
class with a parameter because you you

01:06:50,000 --> 01:06:55,910
want to be able to have a 32-bit atomic

01:06:52,160 --> 01:06:57,509
end you want 64-bit atomic end so so

01:06:55,910 --> 01:06:59,339
when you're counting memory

01:06:57,509 --> 01:07:01,439
you need an atomic and to be able to

01:06:59,339 --> 01:07:03,599
count memory but of course all

01:07:01,439 --> 01:07:05,519
applications are 64-bit now so you need

01:07:03,599 --> 01:07:08,579
to be able to have a 64-bit atomic as

01:07:05,519 --> 01:07:09,779
well I think the standard also has

01:07:08,579 --> 01:07:12,749
atomic pool

01:07:09,779 --> 01:07:17,179
we don't have atomic pool so switching

01:07:12,749 --> 01:07:17,179
to the standard atomic would bias that

01:07:17,539 --> 01:07:24,959
high ignoring shaders for a moment do

01:07:21,899 --> 01:07:29,029
you run much of your C++ core engine on

01:07:24,959 --> 01:07:35,939
the GPU and if not make a wish

01:07:29,029 --> 01:07:39,719
so all of the the GPU stuff we use is

01:07:35,939 --> 01:07:42,809
all through OpenCL and we do that

01:07:39,719 --> 01:07:45,749
through our node graphs so we write the

01:07:42,809 --> 01:07:49,409
OpenCL functors that get passed to

01:07:45,749 --> 01:07:52,589
through the node graph so all the OpenCL

01:07:49,409 --> 01:07:55,019
we write is is is through our procedural

01:07:52,589 --> 01:07:58,019
networks so we don't are we have

01:07:55,019 --> 01:08:00,179
underlying libraries for OpenCL we use

01:07:58,019 --> 01:08:03,269
OpenCL to make sure there were graphics

01:08:00,179 --> 01:08:05,579
card agnostic but there's nothing

01:08:03,269 --> 01:08:08,029
preventing us from adding CUDA operators

01:08:05,579 --> 01:08:10,919
or something like that as well just

01:08:08,029 --> 01:08:12,630
making a wish yeah I was what would you

01:08:10,919 --> 01:08:18,509
like from CUDA what would help you from

01:08:12,630 --> 01:08:21,659
CUDA I'm not sure I'd have to think

01:08:18,509 --> 01:08:24,809
about that one all right no sure

01:08:21,659 --> 01:08:27,029
I so having a C++ 11 there should be as

01:08:24,809 --> 01:08:28,589
simple as adding a compiler option to

01:08:27,029 --> 01:08:30,089
have it but I'm pre shooting it was more

01:08:28,589 --> 01:08:31,559
complicated and that's I was wondering

01:08:30,089 --> 01:08:33,719
how long does it take it took you to

01:08:31,559 --> 01:08:35,909
have a c-plus a working C++ 11 been

01:08:33,719 --> 01:08:39,479
built and what kind of issues did you

01:08:35,909 --> 01:08:42,119
faced sorry sorry the question was the

01:08:39,479 --> 01:08:43,859
question was having a C++ 11 build

01:08:42,119 --> 01:08:46,409
should be as simple as adding a flag

01:08:43,859 --> 01:08:47,759
right yes it was it was so you had your

01:08:46,409 --> 01:08:49,049
build and you've you added a flag and

01:08:47,759 --> 01:08:52,709
you have no issue whatsoever with the

01:08:49,049 --> 01:08:55,139
C++ 11 bill that's right Austin the the

01:08:52,709 --> 01:08:57,929
problem was when clients tried to use

01:08:55,139 --> 01:09:00,479
our code and the headers had C++ 11

01:08:57,929 --> 01:09:04,079
features in them we actually used C++ 11

01:09:00,479 --> 01:09:06,959
al a lot before the visual effects

01:09:04,079 --> 01:09:08,459
reference standard allowed us to but

01:09:06,959 --> 01:09:11,579
what we did was we made sure that it was

01:09:08,459 --> 01:09:16,439
all in C C code so it was all compiled

01:09:11,579 --> 01:09:23,699
C++ 11 header files were still a prior

01:09:16,439 --> 01:09:25,619
to C + C L 3 or whatever looked at

01:09:23,699 --> 01:09:27,539
string view yes

01:09:25,619 --> 01:09:28,949
so that actually came up what's the

01:09:27,539 --> 01:09:31,229
difference between a string reference in

01:09:28,949 --> 01:09:34,289
a string view right the the big

01:09:31,229 --> 01:09:38,009
difference is 4 so a string holder and a

01:09:34,289 --> 01:09:39,779
string ref are the same object so we can

01:09:38,009 --> 01:09:41,279
pass them around interchangeably and

01:09:39,779 --> 01:09:43,709
they actually have memory of what they

01:09:41,279 --> 01:09:45,989
were so if we pass a string holder into

01:09:43,709 --> 01:09:47,849
a string ref that gets passed into

01:09:45,989 --> 01:09:49,919
something that goes to a string holder

01:09:47,849 --> 01:09:53,849
it actually knows that it was a holder

01:09:49,919 --> 01:09:56,429
well a string view it doesn't work so we

01:09:53,849 --> 01:09:59,039
also use that pattern for our small

01:09:56,429 --> 01:10:01,800
array for example so our small array is

01:09:59,039 --> 01:10:04,229
exactly a UT array but with other stuff

01:10:01,800 --> 01:10:06,239
on it so that when we pass a small array

01:10:04,229 --> 01:10:08,459
into some into something that only takes

01:10:06,239 --> 01:10:11,519
a UT array we don't have to worry about

01:10:08,459 --> 01:10:13,679
it it actually converts just fine so

01:10:11,519 --> 01:10:18,989
there's no conversion cost when you do

01:10:13,679 --> 01:10:21,659
that it seems like you guys profile at

01:10:18,989 --> 01:10:25,590
scale can you share how you do the

01:10:21,659 --> 01:10:28,019
profiling so every developer at

01:10:25,590 --> 01:10:32,639
side-effects has their own preferred way

01:10:28,019 --> 01:10:35,699
of profiling I like cash grind

01:10:32,639 --> 01:10:38,340
though I will sometimes use the Google

01:10:35,699 --> 01:10:41,130
perf tools I think they're called now it

01:10:38,340 --> 01:10:49,050
used to be old profile some people run

01:10:41,130 --> 01:10:51,330
vtune it depends on the the developer do

01:10:49,050 --> 01:10:54,360
you build in something into the product

01:10:51,330 --> 01:10:58,739
to know how it does like malach counting

01:10:54,360 --> 01:11:01,619
and so on so we do have some libraries

01:10:58,739 --> 01:11:05,520
that do the malla counting we have also

01:11:01,619 --> 01:11:08,130
have performance tools for Houdini

01:11:05,520 --> 01:11:11,159
itself so you can profile the cookie

01:11:08,130 --> 01:11:13,170
graph of your of your network and that

01:11:11,159 --> 01:11:18,800
allows us to zero in on code that we

01:11:13,170 --> 01:11:21,389
actually want to tune in profile so

01:11:18,800 --> 01:11:23,790
obviously the performance is the key

01:11:21,389 --> 01:11:25,860
issue in your work are you satisfied

01:11:23,790 --> 01:11:29,250
with the current state of the compiler

01:11:25,860 --> 01:11:32,159
optimizations do you often have to fight

01:11:29,250 --> 01:11:37,020
the compiler or does it do well enough

01:11:32,159 --> 01:11:39,409
for you where we're usually pretty happy

01:11:37,020 --> 01:11:43,170
with the compiler a lot of our code

01:11:39,409 --> 01:11:45,900
where it's very very performance

01:11:43,170 --> 01:11:49,710
critical will sometimes use compiler

01:11:45,900 --> 01:11:54,330
intrinsics to generate code for a B X or

01:11:49,710 --> 01:11:55,800
SSE okay thank you but the compilers are

01:11:54,330 --> 01:11:58,190
actually doing a really really good job

01:11:55,800 --> 01:11:58,190
these days

01:11:59,000 --> 01:12:05,639
all right great talk thank you so I'm

01:12:03,090 --> 01:12:07,350
working on something somewhere code base

01:12:05,639 --> 01:12:09,150
where it's like five plus years older

01:12:07,350 --> 01:12:10,949
than I am and we have the same thing

01:12:09,150 --> 01:12:13,230
whereas before standard library we have

01:12:10,949 --> 01:12:17,239
our own custom stuff we haven't done I

01:12:13,230 --> 01:12:19,830
thought I was the only one yeah but

01:12:17,239 --> 01:12:23,570
we're about to do our jump we haven't

01:12:19,830 --> 01:12:27,030
yet to like C++ 11 we were doing like 98

01:12:23,570 --> 01:12:29,340
11 or 14 you said moving to Levin was a

01:12:27,030 --> 01:12:31,800
huge boon for you could you a lot more

01:12:29,340 --> 01:12:34,469
on Taiwan so so with a boon as a

01:12:31,800 --> 01:12:37,949
developer so a lot of the things that

01:12:34,469 --> 01:12:39,420
are in C++ 11 that we used were they

01:12:37,949 --> 01:12:41,699
simplified our code and made it much

01:12:39,420 --> 01:12:43,919
more comprehensible the the fact that

01:12:41,699 --> 01:12:47,639
you can use lambdas now

01:12:43,919 --> 01:12:53,159
a huge huge thing the auto keyword is

01:12:47,639 --> 01:12:55,559
great a lot of a lot of the benefits of

01:12:53,159 --> 01:12:57,449
C++ eleven were really as developers to

01:12:55,559 --> 01:13:00,089
simplify our code and make it much more

01:12:57,449 --> 01:13:01,919
comprehensible thank you I don't think

01:13:00,089 --> 01:13:03,059
the users ever saw and you benefit but

01:13:01,919 --> 01:13:07,859
for us it was great

01:13:03,059 --> 01:13:10,309
yeah development yeah I you mentioned

01:13:07,859 --> 01:13:13,079
some memory optimizations you made in

01:13:10,309 --> 01:13:14,760
custom classes like the string I'm

01:13:13,079 --> 01:13:16,469
wondering if you've done if you do need

01:13:14,760 --> 01:13:18,059
to be like more systematic memory

01:13:16,469 --> 01:13:20,849
optimization with things like custom

01:13:18,059 --> 01:13:26,579
alligators or custom memory managers or

01:13:20,849 --> 01:13:28,949
we we we have a lot of our art we do

01:13:26,579 --> 01:13:31,859
have some custom in-memory allocators

01:13:28,949 --> 01:13:37,260
and we've actually got rid of a lot of

01:13:31,859 --> 01:13:39,329
them recently we find first we use je

01:13:37,260 --> 01:13:42,839
malloc underneath as our memory

01:13:39,329 --> 01:13:47,219
allocator except on windows on windows

01:13:42,839 --> 01:13:49,050
we use TBB malloc some time and we were

01:13:47,219 --> 01:13:51,359
constantly investigating the system

01:13:49,050 --> 01:13:54,719
Malick's it's it's something that we

01:13:51,359 --> 01:13:57,209
always you know battle against but we do

01:13:54,719 --> 01:13:59,219
have a small object allocator and we

01:13:57,209 --> 01:14:01,679
actually just use TBB we switched over

01:13:59,219 --> 01:14:04,709
to the TBB malloc for for that because

01:14:01,679 --> 01:14:08,059
it had better thread performance better

01:14:04,709 --> 01:14:11,129
performance over threading thank you

01:14:08,059 --> 01:14:13,739
sorry one one other object we have is a

01:14:11,129 --> 01:14:15,419
stack buffer so we have a templated

01:14:13,739 --> 01:14:17,909
stack buffer that allows us to create a

01:14:15,419 --> 01:14:22,849
buffer on the stack of whatever we need

01:14:17,909 --> 01:14:25,169
and that's that's really handy sometimes

01:14:22,849 --> 01:14:26,129
you talked about your node networks

01:14:25,169 --> 01:14:28,739
being turing-complete

01:14:26,129 --> 01:14:31,289
yes so and people writing those games

01:14:28,739 --> 01:14:35,099
and stuff so do you do any optimization

01:14:31,289 --> 01:14:37,530
passes on the node network itself we've

01:14:35,099 --> 01:14:41,309
actually considered running LLVM over

01:14:37,530 --> 01:14:44,629
our known networks to to do analysis of

01:14:41,309 --> 01:14:47,309
the graph we don't at the current time

01:14:44,629 --> 01:14:53,369
internally our cook engine does a lot of

01:14:47,309 --> 01:14:55,319
dependency dependency tracking so very

01:14:53,369 --> 01:14:57,780
early on our expression language that we

01:14:55,319 --> 01:15:00,420
used in Houdini allowed you to ref

01:14:57,780 --> 01:15:02,970
any node and any data anywhere in the

01:15:00,420 --> 01:15:05,250
graph and so there are all these sort of

01:15:02,970 --> 01:15:08,150
implicit pads that are very hard to

01:15:05,250 --> 01:15:12,890
track explicitly and so running

01:15:08,150 --> 01:15:15,990
additional graph analysis tools is

01:15:12,890 --> 01:15:17,790
tricky it's definitely something we

01:15:15,990 --> 01:15:19,620
wanted to investigate though there

01:15:17,790 --> 01:15:21,540
they're certainly even even certain sub

01:15:19,620 --> 01:15:27,900
graphs that where we where we could take

01:15:21,540 --> 01:15:32,330
advantage of that thank you regarding

01:15:27,900 --> 01:15:36,960
the interaction and the interfacing with

01:15:32,330 --> 01:15:40,290
others that comply to this VFX standard

01:15:36,960 --> 01:15:42,870
yes as I understood from the

01:15:40,290 --> 01:15:45,900
presentation cute is part of it wouldn't

01:15:42,870 --> 01:15:48,600
it make sense to at least use in the

01:15:45,900 --> 01:15:53,250
public address exclusively cute instead

01:15:48,600 --> 01:15:56,550
of your own we would love to switch over

01:15:53,250 --> 01:15:57,800
to QT exclusively just a note we have

01:15:56,550 --> 01:16:01,770
ten minutes left

01:15:57,800 --> 01:16:05,370
we'd love to switch over however we're

01:16:01,770 --> 01:16:08,480
still a small team we have I think 20 25

01:16:05,370 --> 01:16:11,670
developers and two for us to transition

01:16:08,480 --> 01:16:14,220
we're actually in the progress of

01:16:11,670 --> 01:16:16,470
transitioning over to cute entirely so

01:16:14,220 --> 01:16:18,480
you can now have cute panels inside

01:16:16,470 --> 01:16:21,300
Houdini and eventually we'd like to

01:16:18,480 --> 01:16:24,180
switch all of our our pains to be over

01:16:21,300 --> 01:16:27,150
to use cute and so but it's a it's a

01:16:24,180 --> 01:16:32,180
staged process just similar to the

01:16:27,150 --> 01:16:32,180
process we move from C to C++ I mean it

01:16:32,420 --> 01:16:40,290
thank you hi you mentioned the finite

01:16:37,530 --> 01:16:42,960
element method for simulating the muscle

01:16:40,290 --> 01:16:45,570
mass and the navier-stokes equations yes

01:16:42,960 --> 01:16:47,820
so I was my question is what were the

01:16:45,570 --> 01:16:50,220
main challenges that you had over the

01:16:47,820 --> 01:16:52,590
years for a physics simulation in

01:16:50,220 --> 01:16:55,760
general so I don't actually work a lot

01:16:52,590 --> 01:17:00,960
on the physics engines I know that

01:16:55,760 --> 01:17:03,690
dealing with that the amount of data

01:17:00,960 --> 01:17:06,060
that comes in and and processing that

01:17:03,690 --> 01:17:08,730
data is always challenging

01:17:06,060 --> 01:17:10,590
interfacing to OpenCL and getting the

01:17:08,730 --> 01:17:16,260
data over and doing enough work on the

01:17:10,590 --> 01:17:18,090
GPU that's challenging but again I'm

01:17:16,260 --> 01:17:25,800
sorry I don't do a lot of work on the

01:17:18,090 --> 01:17:29,160
physics side thank you hi you use a

01:17:25,800 --> 01:17:31,410
graph for processing right so processing

01:17:29,160 --> 01:17:34,110
graph and it's the way you how you

01:17:31,410 --> 01:17:36,150
organize the computations and you give

01:17:34,110 --> 01:17:39,630
us the idea what there's a low-level

01:17:36,150 --> 01:17:41,250
data structure like go and wage it but

01:17:39,630 --> 01:17:45,030
what is high-level data structure for

01:17:41,250 --> 01:17:47,430
your scene so the high-level data

01:17:45,030 --> 01:17:49,950
structure would be something like a node

01:17:47,430 --> 01:17:53,190
graph so when the user puts together a

01:17:49,950 --> 01:17:56,370
bunch of nodes that in fact is is part

01:17:53,190 --> 01:17:59,160
of Houdini so when we ship Houdini a lot

01:17:56,370 --> 01:18:01,200
of our nodes are our really high level

01:17:59,160 --> 01:18:08,040
in that they're made of other nodes

01:18:01,200 --> 01:18:11,700
inside Houdini so that we do have our

01:18:08,040 --> 01:18:15,090
art I don't know if that would say like

01:18:11,700 --> 01:18:18,540
your array of points and triangles

01:18:15,090 --> 01:18:20,670
your colors your also we have a geometry

01:18:18,540 --> 01:18:22,800
container that contains all the arrays

01:18:20,670 --> 01:18:26,370
of points and all the page to raise in

01:18:22,800 --> 01:18:28,050
Direction arrays there but the but you

01:18:26,370 --> 01:18:30,180
can look at it as a piece of geometry

01:18:28,050 --> 01:18:33,420
we've got classes like a texture map

01:18:30,180 --> 01:18:36,660
that underneath have a bunch of other

01:18:33,420 --> 01:18:39,360
classes that are involved do you

01:18:36,660 --> 01:18:44,430
organize your geometrical objects into

01:18:39,360 --> 01:18:47,580
the tree as well so our geometry objects

01:18:44,430 --> 01:18:50,280
are actually very flat so we don't we do

01:18:47,580 --> 01:18:54,060
have custom primitives where you can

01:18:50,280 --> 01:18:56,040
represent complicated geometry and we

01:18:54,060 --> 01:18:57,630
call them packed primitives where you

01:18:56,040 --> 01:19:02,370
can pack to Yama tree away and store

01:18:57,630 --> 01:19:03,870
that as a Cal reference or or duplicate

01:19:02,370 --> 01:19:07,800
it that way so there are ways to

01:19:03,870 --> 01:19:11,310
represent complicated hierarchies inside

01:19:07,800 --> 01:19:13,369
our geometry but that's fairly new and

01:19:11,310 --> 01:19:18,080
and gets more complicated

01:19:13,369 --> 01:19:21,290
do you use some space some open data

01:19:18,080 --> 01:19:24,020
format to serialize your scene so there

01:19:21,290 --> 01:19:27,170
is there are a couple of open data

01:19:24,020 --> 01:19:30,409
formats there's Alembic which is was

01:19:27,170 --> 01:19:31,760
released by Sony and ILM and that's a

01:19:30,409 --> 01:19:34,250
way of storing the animation and

01:19:31,760 --> 01:19:37,250
geometry and coming down the pipe is

01:19:34,250 --> 01:19:39,170
something called USD which is being

01:19:37,250 --> 01:19:41,780
released by Pixar Universal scene

01:19:39,170 --> 01:19:47,239
description not US dollars it's very

01:19:41,780 --> 01:19:50,389
similar hacker names thank you hi

01:19:47,239 --> 01:19:53,599
I want to ask about your coding

01:19:50,389 --> 01:19:56,210
guidelines since you have quite specific

01:19:53,599 --> 01:19:59,380
specific requirements on your code do

01:19:56,210 --> 01:20:02,810
you use some custom coding guidelines we

01:19:59,380 --> 01:20:05,900
our coding guidelines go back a long way

01:20:02,810 --> 01:20:07,969
and some developers adhere to them and

01:20:05,900 --> 01:20:11,270
some developers we're a bit loose with

01:20:07,969 --> 01:20:14,630
our coding guidelines so not everybody

01:20:11,270 --> 01:20:18,699
adheres to the same coding guidelines so

01:20:14,630 --> 01:20:22,250
we have a lot of very very talented very

01:20:18,699 --> 01:20:24,980
passionate developers and sometimes it's

01:20:22,250 --> 01:20:26,929
a little constraining to make them work

01:20:24,980 --> 01:20:28,699
with within a certain guideline if

01:20:26,929 --> 01:20:31,340
they're more comfortable working in a

01:20:28,699 --> 01:20:34,520
different way and as long as the code

01:20:31,340 --> 01:20:39,250
works that's mostly what happens that's

01:20:34,520 --> 01:20:43,969
perfect thank you hi you mentioned

01:20:39,250 --> 01:20:48,429
initialization time yes and I was

01:20:43,969 --> 01:20:52,730
wondering if conscious conscious acts

01:20:48,429 --> 01:20:58,190
helped helps or did you make any

01:20:52,730 --> 01:21:00,889
investigation on that so it would it

01:20:58,190 --> 01:21:04,000
would definitely help but the the trick

01:21:00,889 --> 01:21:07,369
is to make sure that the compilers that

01:21:04,000 --> 01:21:10,670
we can use contacts for in all the

01:21:07,369 --> 01:21:13,849
places we want to write so yes contacts

01:21:10,670 --> 01:21:17,590
where does help but a lot of the the

01:21:13,849 --> 01:21:20,090
startup time is actually matlock and and

01:21:17,590 --> 01:21:23,179
things that aren't can't be done

01:21:20,090 --> 01:21:27,489
constant expert so we're battling those

01:21:23,179 --> 01:21:27,489
more than the static initialization

01:21:27,690 --> 01:21:36,040
what's your approach on error-handling

01:21:30,910 --> 01:21:39,400
oh that was one bandwagon we didn't jump

01:21:36,040 --> 01:21:44,590
on so we didn't jump on the exception

01:21:39,400 --> 01:21:47,260
handling so we we our error handling has

01:21:44,590 --> 01:21:49,240
got to be the worst in the industry we

01:21:47,260 --> 01:21:51,280
have a global error manager and

01:21:49,240 --> 01:21:51,910
everybody can add to that go that's

01:21:51,280 --> 01:21:54,460
awful

01:21:51,910 --> 01:21:56,740
you don't want to know what we use it's

01:21:54,460 --> 01:21:58,240
it's one of those things that's that's

01:21:56,740 --> 01:22:01,090
definitely due for a rewrite or a

01:21:58,240 --> 01:22:07,570
transition I looking forward to the

01:22:01,090 --> 01:22:09,430
expected ah I saw that talk yesterday it

01:22:07,570 --> 01:22:11,860
certainly holds a lot of promise yes

01:22:09,430 --> 01:22:13,660
it's got to be a lot better than what we

01:22:11,860 --> 01:22:16,570
have one of the the problems that we

01:22:13,660 --> 01:22:19,450
have though is that sometimes the error

01:22:16,570 --> 01:22:21,160
actually occurs in an event handler so

01:22:19,450 --> 01:22:25,300
we don't actually have the stacked from

01:22:21,160 --> 01:22:27,940
the guy who's doing that that try the

01:22:25,300 --> 01:22:30,220
the air gets thrown in some separate

01:22:27,940 --> 01:22:34,120
thread and some totally separate call

01:22:30,220 --> 01:22:36,310
stop so it gets it gets tricky for us in

01:22:34,120 --> 01:22:39,700
our UI library I have to think about how

01:22:36,310 --> 01:22:45,460
that would work with our some are awful

01:22:39,700 --> 01:22:47,490
code thank you thank you did you three

01:22:45,460 --> 01:22:50,950
minutes did you come up with any other

01:22:47,490 --> 01:22:55,830
idioms for dealing with mostly immutable

01:22:50,950 --> 01:22:59,620
data and occasionally changing let's say

01:22:55,830 --> 01:23:01,110
just like the page based data

01:22:59,620 --> 01:23:03,640
modification that you are talked about

01:23:01,110 --> 01:23:06,400
but in the context of multiple threads

01:23:03,640 --> 01:23:10,060
so one something like a concurrent cube

01:23:06,400 --> 01:23:14,020
but largely immutable data but

01:23:10,060 --> 01:23:17,890
occasionally one thread might be so we

01:23:14,020 --> 01:23:21,460
do use TBB vector a concurrent vector

01:23:17,890 --> 01:23:24,540
sometimes which has that property but we

01:23:21,460 --> 01:23:27,100
haven't spent a lot of time

01:23:24,540 --> 01:23:29,250
investigating those kind of algorithms

01:23:27,100 --> 01:23:32,700
ourselves

01:23:29,250 --> 01:23:34,470
the the pages also have a small side

01:23:32,700 --> 01:23:38,250
benefit with when it comes to threading

01:23:34,470 --> 01:23:40,350
is that you can easily assign a thread

01:23:38,250 --> 01:23:42,840
to each page and have them work

01:23:40,350 --> 01:23:45,480
independently if the the page needs to

01:23:42,840 --> 01:23:49,470
be compressed it's one threads job not

01:23:45,480 --> 01:23:51,420
not the global program so there are a

01:23:49,470 --> 01:23:55,080
lot of lot of advantages you get with

01:23:51,420 --> 01:23:57,990
the page rate high nothing to do with

01:23:55,080 --> 01:23:59,760
C++ this most of your node networks as

01:23:57,990 --> 01:24:03,570
you said is cheering complete it is code

01:23:59,760 --> 01:24:05,160
how the hell do you manage that and how

01:24:03,570 --> 01:24:09,510
do you do dips on it on a big node

01:24:05,160 --> 01:24:12,180
network so tips on big known networks is

01:24:09,510 --> 01:24:14,910
a real problem that we actually only

01:24:12,180 --> 01:24:18,540
finally got around to addressing last

01:24:14,910 --> 01:24:22,350
release of our software like 20 however

01:24:18,540 --> 01:24:24,300
many years into it so because the node

01:24:22,350 --> 01:24:27,240
networks can get inordinately complex

01:24:24,300 --> 01:24:28,890
you can we now are able to expand them

01:24:27,240 --> 01:24:31,500
and serialize them and then you can do

01:24:28,890 --> 01:24:33,060
the diff on the C relized code so you

01:24:31,500 --> 01:24:36,330
can represent all the node networks as

01:24:33,060 --> 01:24:38,250
text as well so there are underlying

01:24:36,330 --> 01:24:40,200
commands just like that the old days

01:24:38,250 --> 01:24:42,660
where you had stand-alone commands to do

01:24:40,200 --> 01:24:46,550
that so you can run the diff on that and

01:24:42,660 --> 01:24:46,550
see what's changed okay thank you

01:24:47,960 --> 01:24:53,520
software we test our software with our

01:24:52,020 --> 01:24:55,200
software so we have a bunch of

01:24:53,520 --> 01:24:57,150
regression tests

01:24:55,200 --> 01:24:59,190
aside from unit tests we also have

01:24:57,150 --> 01:25:02,550
regression tests that will take

01:24:59,190 --> 01:25:06,270
animation files and render images or

01:25:02,550 --> 01:25:10,590
create geometry and so we also validate

01:25:06,270 --> 01:25:13,230
that the process of creating geometry is

01:25:10,590 --> 01:25:16,800
also the same so we use our software to

01:25:13,230 --> 01:25:19,200
test our software do you mock and

01:25:16,800 --> 01:25:21,800
automate testing a lot or you're still

01:25:19,200 --> 01:25:24,180
decent amount of my note testing we

01:25:21,800 --> 01:25:25,920
every developer does a certain amount of

01:25:24,180 --> 01:25:29,640
manual testing obviously before they

01:25:25,920 --> 01:25:31,950
commit but we also on every build we

01:25:29,640 --> 01:25:34,440
have machines that run our regression

01:25:31,950 --> 01:25:36,000
test so after every build they run a

01:25:34,440 --> 01:25:39,120
regression test and it allows us to

01:25:36,000 --> 01:25:39,680
bisect and easily sort of zero in on

01:25:39,120 --> 01:25:43,610
what

01:25:39,680 --> 01:25:45,590
might be problematic so regression is

01:25:43,610 --> 01:25:48,440
okay but what about the new features and

01:25:45,590 --> 01:25:51,260
functional tests when you add a new

01:25:48,440 --> 01:25:53,930
feature you add of a test to make sure

01:25:51,260 --> 01:25:56,000
that it keeps working that way kind of a

01:25:53,930 --> 01:26:01,700
kind of unit test or something high

01:25:56,000 --> 01:26:05,150
level so the way we'll will build a unit

01:26:01,700 --> 01:26:06,080
tests for for low level structures but

01:26:05,150 --> 01:26:08,450
for the some of the high level

01:26:06,080 --> 01:26:10,940
structures because how do you test when

01:26:08,450 --> 01:26:12,710
you've got a network of nodes that is

01:26:10,940 --> 01:26:15,350
hooked together how do you test whether

01:26:12,710 --> 01:26:17,240
that works right the best way to do that

01:26:15,350 --> 01:26:18,920
is to actually run that network of nodes

01:26:17,240 --> 01:26:21,170
on some input data and make sure that

01:26:18,920 --> 01:26:22,910
the output data is correct we don't have

01:26:21,170 --> 01:26:25,520
full coverage testing there's there's

01:26:22,910 --> 01:26:29,360
almost no way to do that but at least we

01:26:25,520 --> 01:26:31,310
have unit tests that test whether the

01:26:29,360 --> 01:26:34,250
output geometry is sort of what we

01:26:31,310 --> 01:26:37,220
expect and sometimes we have actually

01:26:34,250 --> 01:26:40,760
found bugs where it's that the original

01:26:37,220 --> 01:26:42,910
test data was incorrect and so the

01:26:40,760 --> 01:26:46,970
developer didn't do their due diligence

01:26:42,910 --> 01:26:51,290
so about the input data so you can use

01:26:46,970 --> 01:26:53,420
historical data or mérida made at do you

01:26:51,290 --> 01:26:57,370
all some walk the data like particular

01:26:53,420 --> 01:27:01,850
course of course yes we mark data I

01:26:57,370 --> 01:27:04,520
think that's it so thank you very much

01:27:01,850 --> 01:27:04,970
if you want just come up to me and talk

01:27:04,520 --> 01:27:09,169
to me

01:27:04,970 --> 01:27:09,169

YouTube URL: https://www.youtube.com/watch?v=2YXwg0n9e7E


