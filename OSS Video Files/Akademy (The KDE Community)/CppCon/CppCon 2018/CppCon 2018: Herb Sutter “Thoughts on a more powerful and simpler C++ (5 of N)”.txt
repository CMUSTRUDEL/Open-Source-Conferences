Title: CppCon 2018: Herb Sutter “Thoughts on a more powerful and simpler C++ (5 of N)”
Publication date: 2018-09-28
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Perhaps the most important thing we can do for C++ at this point in its evolution is to make sure we preserve its core strengths while also directing its evolution in ways that make it simpler to use. That is my own opinion at least, so this talk starts with a perspective question: What “is C++,” really? The language continues to evolve and change; as it does so, how can we be sure we’re picking C++ evolutionary improvements that not only don’t lose its “C++-ic” qualities, but make it a better C++ than ever?

At recent CppCons, I’ve spoken about several of my own personal C++ evolution efforts and experiments, and why I think they’re potentially important directions to explore for making C++ both more powerful and also simpler to use. The bulk of the talk is updates on two of these:

1. Lifetime and dangling: At CppCon 2015, Bjarne Stroustrup and I launched The C++ Core Guidelines in our plenary talks. In my part starting at 29:06, I gave an early look at my work on the Guidelines “Lifetime” profile, an approach for diagnosing many common cases of pointer/iterator dangling at compile time, with demos in an early MSVC-based prototype. For this year’s CppCon, I’ll cover what’s new, including:
    • use-after-move diagnoses
    • better support for the standard library out of the box without annotation
    • more complete implementations in two compilers: in MSVC as a static analysis extension, and in a Clang-based implementation that is efficient enough to run during normal compilation
    • the complete 1.0 Lifetime specification being released on the Guidelines’ GitHub repo this month

I’ll summarize the highlights but focus on what’s new, so I recommend rewatching that talk video as a refresher for background for this year’s session.

2. Metaclasses: In my CppCon 2017 talk, I gave an early look at my “metaclasses” proposal to use compile-time reflection and compile-time generation to make authoring classes both more powerful and also simpler. In this case, “simpler” means not only eliminating a lot of tedious boilerplate, but also eliminating many common sources of errors and bugs. For this year, we’ll cover what’s new, including:
    • an update on the Clang-based implementation, which now supports more use cases including function parameter lists
    • new examples, including from domains like concurrency
    • an updated P0707 paper, with more links to working examples live on Godbolt, being posted in the next few weeks for the pre-San Diego committee mailing
— 
Herb Sutter
Microsoft
Author, and chair of the ISO C++ committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,460 --> 00:00:04,460
baby

00:00:04,690 --> 00:00:15,660
[Music]

00:00:13,820 --> 00:00:23,809
[Applause]

00:00:15,660 --> 00:00:23,809
[Music]

00:00:25,530 --> 00:00:31,740
if I may just have a quick show of hands

00:00:28,060 --> 00:00:34,210
how many of you in your heart of hearts

00:00:31,740 --> 00:00:38,489
sometimes are inclined to think of a

00:00:34,210 --> 00:00:42,370
talk title like that as a pipe dream

00:00:38,489 --> 00:00:43,750
good we feel feel relaxed and free to be

00:00:42,370 --> 00:00:47,050
honest that was about a quarter of the

00:00:43,750 --> 00:00:49,330
audience I hope to get that down zero be

00:00:47,050 --> 00:00:54,640
too much to ask maybe to an eight by the

00:00:49,330 --> 00:00:57,760
end let's talk about how we can make C++

00:00:54,640 --> 00:01:00,519
evolve in a way that makes it both more

00:00:57,760 --> 00:01:02,230
powerful because we want that we don't

00:01:00,519 --> 00:01:03,730
want to give up anything we want to

00:01:02,230 --> 00:01:08,950
increase the power and control we have

00:01:03,730 --> 00:01:09,280
but make using C++ simpler than it is

00:01:08,950 --> 00:01:12,130
today

00:01:09,280 --> 00:01:14,590
and there is a proof that we can do it

00:01:12,130 --> 00:01:17,320
because we've already been doing it this

00:01:14,590 --> 00:01:19,720
is how to be intentional along that same

00:01:17,320 --> 00:01:22,090
path and double down and do it even

00:01:19,720 --> 00:01:23,560
better in the future so I'm going to

00:01:22,090 --> 00:01:25,320
talk for most of the talk on the last

00:01:23,560 --> 00:01:28,840
two things an update on the lifetime

00:01:25,320 --> 00:01:31,330
profile for simplifying C++ so that we

00:01:28,840 --> 00:01:33,280
can detect dangling problems many common

00:01:31,330 --> 00:01:36,130
sources of dangling iterators pointers

00:01:33,280 --> 00:01:37,570
string views in our code which makes our

00:01:36,130 --> 00:01:39,250
code simpler then we don't have to teach

00:01:37,570 --> 00:01:41,740
and learn many of those common things

00:01:39,250 --> 00:01:43,930
you have to teach today and then on

00:01:41,740 --> 00:01:47,380
metaclasses which makes authoring

00:01:43,930 --> 00:01:48,970
classes simpler but first before I get

00:01:47,380 --> 00:01:51,690
into those two which are the bulk of the

00:01:48,970 --> 00:01:53,950
talk but there the what and the how

00:01:51,690 --> 00:01:56,860
let's take a few minutes to talk about

00:01:53,950 --> 00:02:00,120
the why because that's much more

00:01:56,860 --> 00:02:02,530
important than diving into solutions

00:02:00,120 --> 00:02:04,500
probably the most common reaction I get

00:02:02,530 --> 00:02:07,120
including a few minutes ago about

00:02:04,500 --> 00:02:08,709
simplifying by adding stuff is so let me

00:02:07,120 --> 00:02:12,069
get this straight you want to add stuff

00:02:08,709 --> 00:02:15,010
to this already huge language to make it

00:02:12,069 --> 00:02:19,300
simpler yep right I need I have a coffee

00:02:15,010 --> 00:02:23,860
I need to get but it's not adding things

00:02:19,300 --> 00:02:27,940
to the language in itself it's to make

00:02:23,860 --> 00:02:30,290
C++ coding simpler easier to teach learn

00:02:27,940 --> 00:02:33,750
debug maintain

00:02:30,290 --> 00:02:35,670
so yes we can do this if the thing we

00:02:33,750 --> 00:02:37,290
add to the language does one of three

00:02:35,670 --> 00:02:39,750
things and there are others but here are

00:02:37,290 --> 00:02:42,989
three main ones if it makes user code

00:02:39,750 --> 00:02:44,700
simpler for instance range four we added

00:02:42,989 --> 00:02:48,450
to the language so we made the language

00:02:44,700 --> 00:02:51,239
a page bigger but we made a lot of C++

00:02:48,450 --> 00:02:54,720
code simpler because they could directly

00:02:51,239 --> 00:02:57,660
express their intent if we can remove

00:02:54,720 --> 00:03:00,959
special cases and sharp edges if we can

00:02:57,660 --> 00:03:04,620
even discourage maybe even deprecated

00:03:00,959 --> 00:03:07,410
some existing hard features that make

00:03:04,620 --> 00:03:09,840
working with C pose less difficult then

00:03:07,410 --> 00:03:11,700
we have simplified C++ by adding

00:03:09,840 --> 00:03:13,769
something now we do want to also take

00:03:11,700 --> 00:03:17,519
away we'll get to that now let's dig

00:03:13,769 --> 00:03:20,430
into that first bubble because there are

00:03:17,519 --> 00:03:22,349
three major categories of ways that we

00:03:20,430 --> 00:03:24,930
can add a feature that makes user code

00:03:22,349 --> 00:03:26,730
simpler the way you always do this add

00:03:24,930 --> 00:03:29,670
something that makes things simpler is

00:03:26,730 --> 00:03:31,560
by adding an abstraction of some sort

00:03:29,670 --> 00:03:36,359
because that lets programmers express

00:03:31,560 --> 00:03:38,940
their intent more directly the first

00:03:36,359 --> 00:03:41,639
bucket which I'll call say a K or

00:03:38,940 --> 00:03:43,650
constant factor gain is when we add

00:03:41,639 --> 00:03:45,420
something like range for think of it as

00:03:43,650 --> 00:03:47,010
I'm adding a fixed name into the

00:03:45,420 --> 00:03:49,109
language in that case it's four with a

00:03:47,010 --> 00:03:51,030
colon sometimes it's actually a word

00:03:49,109 --> 00:03:52,980
like override but some specific syntax

00:03:51,030 --> 00:03:56,940
which you can think of as a name and

00:03:52,980 --> 00:03:59,400
then the user can invoke that name as a

00:03:56,940 --> 00:04:00,930
built-in word of power and express their

00:03:59,400 --> 00:04:02,459
intent more directly their code just got

00:04:00,930 --> 00:04:04,019
simpler because now you can look at

00:04:02,459 --> 00:04:06,090
range for you look at just that first

00:04:04,019 --> 00:04:08,250
line and without looking at the body you

00:04:06,090 --> 00:04:11,940
know it's going to traverse visiting

00:04:08,250 --> 00:04:13,760
each element once in order until them

00:04:11,940 --> 00:04:17,940
exceptions thrown or they get to the end

00:04:13,760 --> 00:04:21,810
by construction that's simpler the

00:04:17,940 --> 00:04:24,780
second bucket is if you let users make a

00:04:21,810 --> 00:04:27,630
name a word of power this is why

00:04:24,780 --> 00:04:30,810
concepts are so powerful because we are

00:04:27,630 --> 00:04:34,440
letting the user write a name like

00:04:30,810 --> 00:04:36,000
sortable and then use it and the

00:04:34,440 --> 00:04:37,830
language helps them by letting you

00:04:36,000 --> 00:04:40,469
overload on it and do other things like

00:04:37,830 --> 00:04:42,659
that and I'll call that an n-fold

00:04:40,469 --> 00:04:43,740
improvement because now you've not just

00:04:42,659 --> 00:04:45,840
given one feature

00:04:43,740 --> 00:04:49,230
you've given users the ability to write

00:04:45,840 --> 00:04:50,970
small features and the third bucket

00:04:49,230 --> 00:04:52,380
which is the most powerful thing you can

00:04:50,970 --> 00:04:54,120
do in a programming language and you

00:04:52,380 --> 00:04:57,120
have to be careful here because it's

00:04:54,120 --> 00:04:59,880
easy to give too much power in an

00:04:57,120 --> 00:05:04,650
undisciplined way if you need convincing

00:04:59,880 --> 00:05:06,870
recall lisp deafened effing if you don't

00:05:04,650 --> 00:05:09,990
know what that means google it and shut

00:05:06,870 --> 00:05:12,510
it what you want to do in the third

00:05:09,990 --> 00:05:13,920
bucket is give the user a way to make

00:05:12,510 --> 00:05:17,840
their own word of power make their own

00:05:13,920 --> 00:05:20,100
name that has not just a name but also

00:05:17,840 --> 00:05:22,710
encapsulated behavior that's got a

00:05:20,100 --> 00:05:24,810
hidden part and today we have exactly

00:05:22,710 --> 00:05:27,660
three such things in the entire C++

00:05:24,810 --> 00:05:30,120
language the variable the function and

00:05:27,660 --> 00:05:31,530
the class yeah templates are great but

00:05:30,120 --> 00:05:34,620
they're just parameterizations of those

00:05:31,530 --> 00:05:39,020
three exceptions are great but they're

00:05:34,620 --> 00:05:40,830
more in category 1 we have user-defined

00:05:39,020 --> 00:05:42,330
encapsulated abstractions in the

00:05:40,830 --> 00:05:43,500
variable the function the class now

00:05:42,330 --> 00:05:46,140
let's start with class that's the easy

00:05:43,500 --> 00:05:48,180
one the definition for this encapsulated

00:05:46,140 --> 00:05:51,510
abstraction is I can give it a name ok I

00:05:48,180 --> 00:05:53,220
could give a class a name and there's an

00:05:51,510 --> 00:05:55,500
exposed part in the hidden part

00:05:53,220 --> 00:05:58,460
what's the exposed part of a class yell

00:05:55,500 --> 00:06:02,250
it out public interface what's the

00:05:58,460 --> 00:06:03,600
hidden part private and then there's

00:06:02,250 --> 00:06:04,830
protected which means public to a

00:06:03,600 --> 00:06:07,110
smaller audience so it's in between

00:06:04,830 --> 00:06:09,300
we're getting granularity but there's

00:06:07,110 --> 00:06:10,950
that separation now you can go and look

00:06:09,300 --> 00:06:13,110
at inline functions in the class body

00:06:10,950 --> 00:06:15,210
member variables they're visible in the

00:06:13,110 --> 00:06:17,310
source code the compiler uses that for

00:06:15,210 --> 00:06:20,970
optimization the calling code can't use

00:06:17,310 --> 00:06:25,020
those they're hidden for a function what

00:06:20,970 --> 00:06:29,000
is the exposed part the declaration

00:06:25,020 --> 00:06:31,890
what's the hidden part function body

00:06:29,000 --> 00:06:34,830
again even if it's inline the caller

00:06:31,890 --> 00:06:40,650
just uses the declaration for a variable

00:06:34,830 --> 00:06:43,470
what is the exposed part yes the answers

00:06:40,650 --> 00:06:46,350
are getting slower type and name exactly

00:06:43,470 --> 00:06:49,850
right and what's the hidden part the

00:06:46,350 --> 00:06:52,830
current value and we have accessors to

00:06:49,850 --> 00:06:54,780
to read and write the current value but

00:06:52,830 --> 00:06:56,790
you can easily write a function that

00:06:54,780 --> 00:06:57,660
uses a variable and never looks at its

00:06:56,790 --> 00:06:59,940
value

00:06:57,660 --> 00:07:04,350
at all for instance a times two function

00:06:59,940 --> 00:07:06,510
says variable star equals two never

00:07:04,350 --> 00:07:09,960
reads its value it just doubles it so

00:07:06,510 --> 00:07:11,790
it's an abstraction of all the features

00:07:09,960 --> 00:07:14,130
that are currently in the pipeline in

00:07:11,790 --> 00:07:15,660
the actual core groups or in the

00:07:14,130 --> 00:07:17,820
standard or on the way to the standard

00:07:15,660 --> 00:07:20,580
in the CSS committee today the only

00:07:17,820 --> 00:07:22,230
other such feature is the module it is

00:07:20,580 --> 00:07:24,330
an encapsulation boundary and that is

00:07:22,230 --> 00:07:26,310
what makes it so powerful and so

00:07:24,330 --> 00:07:28,440
important because you can talk about the

00:07:26,310 --> 00:07:31,200
exported and the non exported or hidden

00:07:28,440 --> 00:07:35,490
parts of a new user-defined abstraction

00:07:31,200 --> 00:07:38,070
and that gives you combinatorial compose

00:07:35,490 --> 00:07:40,800
willpower I'm gonna talk about two

00:07:38,070 --> 00:07:42,660
things when I talk about lifetime rules

00:07:40,800 --> 00:07:45,480
to diagnose common cases of dangling

00:07:42,660 --> 00:07:47,070
that's in the lower-left bucket because

00:07:45,480 --> 00:07:48,330
we're removing special cases and sharp

00:07:47,070 --> 00:07:50,370
edges so we don't have to teach them

00:07:48,330 --> 00:07:53,580
that simplifies the language as it's

00:07:50,370 --> 00:07:56,880
used and Mehta classes are in the lower

00:07:53,580 --> 00:07:58,800
right because they would be as they are

00:07:56,880 --> 00:08:00,660
very earliest olam experiments in

00:07:58,800 --> 00:08:03,720
progress but we're about a year or two

00:08:00,660 --> 00:08:06,150
into it and if they progress if it works

00:08:03,720 --> 00:08:08,010
out they would be another one of those

00:08:06,150 --> 00:08:11,520
very few things in the bottom right

00:08:08,010 --> 00:08:13,830
bucket that let you in can't a new word

00:08:11,520 --> 00:08:17,610
of power that's an encapsulated behavior

00:08:13,830 --> 00:08:19,910
and that's very powerful in fact it

00:08:17,610 --> 00:08:25,830
addresses both of those two other

00:08:19,910 --> 00:08:28,350
bubbles on the left so pop quiz I've

00:08:25,830 --> 00:08:30,810
shown this slide before with the titled

00:08:28,350 --> 00:08:33,570
not your father's C++ on the left is C

00:08:30,810 --> 00:08:36,120
plus 98 code today is modern c plus 11

00:08:33,570 --> 00:08:37,770
code there are more modern things since

00:08:36,120 --> 00:08:41,729
this but I've been showing this slide

00:08:37,770 --> 00:08:44,420
for about eight years to the point where

00:08:41,729 --> 00:08:46,940
C plus 11 feels like a new language as

00:08:44,420 --> 00:08:49,110
yarn is Troost have correctly said and

00:08:46,940 --> 00:08:51,870
we've been doing this all over the place

00:08:49,110 --> 00:08:53,910
on the left is former standard code that

00:08:51,870 --> 00:08:55,980
still works still compiles but now we

00:08:53,910 --> 00:08:58,260
have simpler ways how many of you found

00:08:55,980 --> 00:09:01,200
the trailing return type syntax jarring

00:08:58,260 --> 00:09:04,290
the first time you saw it how many of

00:09:01,200 --> 00:09:07,100
you still find it jarring a few a

00:09:04,290 --> 00:09:09,240
smaller number so we we learn it and

00:09:07,100 --> 00:09:11,240
soon perhaps we can do the

00:09:09,240 --> 00:09:14,010
simplification at the bottom

00:09:11,240 --> 00:09:15,480
one of the next two meetings we already

00:09:14,010 --> 00:09:17,940
have concepts in the language and if we

00:09:15,480 --> 00:09:19,560
have the terse syntax the notation then

00:09:17,940 --> 00:09:21,600
we can do something like the

00:09:19,560 --> 00:09:23,220
bottom-right but here's a serious

00:09:21,600 --> 00:09:25,550
question of all of these things we just

00:09:23,220 --> 00:09:30,800
looked at on this slide on in this slide

00:09:25,550 --> 00:09:33,330
which are C++ and which are not C++

00:09:30,800 --> 00:09:34,260
they're all C++ but they look very

00:09:33,330 --> 00:09:37,530
different

00:09:34,260 --> 00:09:40,590
all of them are C++ SiC we might say in

00:09:37,530 --> 00:09:43,170
the spirit of C++ even though they look

00:09:40,590 --> 00:09:45,540
different superficially so when we talk

00:09:43,170 --> 00:09:47,580
about what is C++ we talk about usually

00:09:45,540 --> 00:09:48,780
three things two things but I'm going to

00:09:47,580 --> 00:09:51,530
add a third because it doesn't get

00:09:48,780 --> 00:09:53,700
mentioned a lot but it's very important

00:09:51,530 --> 00:09:55,470
the first is of course zero overhead

00:09:53,700 --> 00:09:58,740
abstraction don't pay for what you don't

00:09:55,470 --> 00:10:00,270
use the other half of that the second

00:09:58,740 --> 00:10:02,160
line in that bullet is important and

00:10:00,270 --> 00:10:04,170
often people don't talk about it when

00:10:02,160 --> 00:10:06,360
they say zero overhead abstraction some

00:10:04,170 --> 00:10:08,040
people say oh but your feature cost

00:10:06,360 --> 00:10:09,870
something if you use it that's not zero

00:10:08,040 --> 00:10:11,850
overhead that that's not what zero

00:10:09,870 --> 00:10:14,880
overhead means zero overhead means you

00:10:11,850 --> 00:10:17,400
don't pay for it if you don't use it but

00:10:14,880 --> 00:10:19,230
if you do use it it's gonna cost you

00:10:17,400 --> 00:10:21,600
something you're opting into it but it's

00:10:19,230 --> 00:10:25,410
going to be as efficient as you could

00:10:21,600 --> 00:10:28,050
reasonably write by hand it's gonna cost

00:10:25,410 --> 00:10:29,280
something but it's gonna be as efficient

00:10:28,050 --> 00:10:32,100
as you could reasonably write by hand

00:10:29,280 --> 00:10:34,140
that's a zero overhead abstraction we

00:10:32,100 --> 00:10:36,000
also like determinism and control and

00:10:34,140 --> 00:10:37,530
this comes in various flavors but I

00:10:36,000 --> 00:10:39,510
think the right way to summarize it is

00:10:37,530 --> 00:10:42,480
determinism a control control over time

00:10:39,510 --> 00:10:44,190
and space bounded execution time space

00:10:42,480 --> 00:10:46,890
layout knowing where your data lives

00:10:44,190 --> 00:10:48,780
this includes leaving no room for a

00:10:46,890 --> 00:10:50,880
lower language than C++ other than

00:10:48,780 --> 00:10:53,940
assembler it means trust the programmer

00:10:50,880 --> 00:10:56,370
all that fits in this bucket and then we

00:10:53,940 --> 00:10:58,740
have great link compatibility so we can

00:10:56,370 --> 00:11:01,440
use old C++ and new c plus calls in the

00:10:58,740 --> 00:11:05,550
same project and link it together and it

00:11:01,440 --> 00:11:07,830
works a historical strength that has let

00:11:05,550 --> 00:11:10,260
us achieve the zero overhead principle

00:11:07,830 --> 00:11:13,830
and determinism is that so much in C++

00:11:10,260 --> 00:11:17,490
has emphasized static behavior static

00:11:13,830 --> 00:11:19,560
typing static compilation usually static

00:11:17,490 --> 00:11:20,970
linking in the standard and one of the

00:11:19,560 --> 00:11:22,980
major current trends is if you look at

00:11:20,970 --> 00:11:24,600
concepts context per and so many of

00:11:22,980 --> 00:11:27,150
these other things we're doing

00:11:24,600 --> 00:11:28,680
most of them are static or enabling us

00:11:27,150 --> 00:11:31,290
to do things in a static way that we

00:11:28,680 --> 00:11:33,000
used to do in our dynamic way I'll tell

00:11:31,290 --> 00:11:35,100
you right now as soon as we get static

00:11:33,000 --> 00:11:37,020
compile-time reflection I will be

00:11:35,100 --> 00:11:38,460
leading the charge to remove type ID

00:11:37,020 --> 00:11:40,410
from the language because there ain't no

00:11:38,460 --> 00:11:42,150
reason we need it and that we currently

00:11:40,410 --> 00:11:44,580
pay for what we don't use with type ID

00:11:42,150 --> 00:11:46,080
all the time and the moment we do that

00:11:44,580 --> 00:11:48,510
are actually few tools will get smaller

00:11:46,080 --> 00:11:51,120
by removing a feature almost nobody uses

00:11:48,510 --> 00:11:53,160
but replacing that dynamic feature which

00:11:51,120 --> 00:11:56,640
is one reason they don't use it with a

00:11:53,160 --> 00:11:58,470
static feature so that's the core I

00:11:56,640 --> 00:11:59,930
would say of C++ but let's use the

00:11:58,470 --> 00:12:04,080
bottom half of the slide to talk about

00:11:59,930 --> 00:12:08,310
non core things so this is not core but

00:12:04,080 --> 00:12:09,990
it's very useful pragmatically backwards

00:12:08,310 --> 00:12:12,120
source compatibility now when it's

00:12:09,990 --> 00:12:13,860
backward source compat with see it's

00:12:12,120 --> 00:12:15,810
pretty much read-only the idea is we can

00:12:13,860 --> 00:12:17,180
easily inhale a C header so we can call

00:12:15,810 --> 00:12:20,040
the function so it's about using

00:12:17,180 --> 00:12:21,170
existing libraries it's not about

00:12:20,040 --> 00:12:23,370
writing new code

00:12:21,170 --> 00:12:25,050
remember the artist rusev has been

00:12:23,370 --> 00:12:29,040
telling people since the start of this

00:12:25,050 --> 00:12:32,790
project C with classes in 1979 it's C

00:12:29,040 --> 00:12:34,980
yes that compiles with classes use those

00:12:32,790 --> 00:12:36,690
instead right so backward source

00:12:34,980 --> 00:12:39,840
compatibility isn't so you can write

00:12:36,690 --> 00:12:40,980
code that old way forever it's so you

00:12:39,840 --> 00:12:42,540
have a new way to write it but the

00:12:40,980 --> 00:12:43,950
backward source compatibility is there

00:12:42,540 --> 00:12:45,990
when you need it specifically to call

00:12:43,950 --> 00:12:49,080
existing libraries and that's true also

00:12:45,990 --> 00:12:51,960
for existing C++ code we have a great

00:12:49,080 --> 00:12:54,600
backward compatibility story so what is

00:12:51,960 --> 00:12:56,250
not core to C++ well we already

00:12:54,600 --> 00:12:57,600
mentioned specific syntax we're adding

00:12:56,250 --> 00:13:00,840
new syntax is all the time

00:12:57,600 --> 00:13:02,730
as soon as BR de added classes it was a

00:13:00,840 --> 00:13:04,500
different language from C but we liked

00:13:02,730 --> 00:13:06,150
it and the class has fueled the

00:13:04,500 --> 00:13:11,460
generation of languages it's very

00:13:06,150 --> 00:13:15,320
powerful tedium is not core to C++ no

00:13:11,460 --> 00:13:15,320
matter how many people believe otherwise

00:13:15,740 --> 00:13:21,350
we can have range for and override and

00:13:18,930 --> 00:13:25,260
you know what they don't cost anything

00:13:21,350 --> 00:13:27,510
almost all major modern language

00:13:25,260 --> 00:13:30,000
features can be designed with zero

00:13:27,510 --> 00:13:32,390
overhead like always are on garbage

00:13:30,000 --> 00:13:35,280
collection no always on metadata no

00:13:32,390 --> 00:13:36,810
didn't garbage collection sure opt in

00:13:35,280 --> 00:13:38,200
metadata static reflection and they do

00:13:36,810 --> 00:13:42,220
save the ones you want

00:13:38,200 --> 00:13:44,380
only those totally zero overhead so this

00:13:42,220 --> 00:13:47,710
idea of having a nice language and

00:13:44,380 --> 00:13:49,270
having zero overhead is not intention

00:13:47,710 --> 00:13:51,930
nearly all of the time and we're

00:13:49,270 --> 00:13:53,980
improving C++ in exactly that way and

00:13:51,930 --> 00:13:57,490
getting good defaults you're moving

00:13:53,980 --> 00:13:58,960
sharp edges like dangling and maybe your

00:13:57,490 --> 00:14:01,030
code works maybe it'll fall over

00:13:58,960 --> 00:14:03,640
that's not core to C plus loss if we can

00:14:01,030 --> 00:14:04,930
solve that with zero overhead then we

00:14:03,640 --> 00:14:10,150
have a better language and that is still

00:14:04,930 --> 00:14:12,220
C++ so as people propose new language

00:14:10,150 --> 00:14:13,300
features or library features which we

00:14:12,220 --> 00:14:17,650
process evolution but especially

00:14:13,300 --> 00:14:22,330
language features I would ask you to

00:14:17,650 --> 00:14:24,790
please consider questions like these how

00:14:22,330 --> 00:14:27,600
does this feature let the programmer

00:14:24,790 --> 00:14:29,980
express their intent more directly if

00:14:27,600 --> 00:14:32,140
you can answer that you almost certainly

00:14:29,980 --> 00:14:33,460
have an abstraction and a good general

00:14:32,140 --> 00:14:35,170
one and then we can tweak about how

00:14:33,460 --> 00:14:39,750
general and how good and how to make it

00:14:35,170 --> 00:14:43,450
useful how does this simplify C++ code

00:14:39,750 --> 00:14:46,990
C++ as she is spoke so to say to read or

00:14:43,450 --> 00:14:49,240
write debug and maintain the code how

00:14:46,990 --> 00:14:52,930
does it remove gotchas or special cases

00:14:49,240 --> 00:14:55,570
or sharp edges foot guns from the

00:14:52,930 --> 00:14:57,640
language and that simplifies the

00:14:55,570 --> 00:15:01,000
language because we don't have to teach

00:14:57,640 --> 00:15:02,920
them anymore then or have them drain or

00:15:01,000 --> 00:15:06,580
mental overhead as we're using the

00:15:02,920 --> 00:15:09,250
language here's an interesting one how

00:15:06,580 --> 00:15:11,920
does this feature remove a place where

00:15:09,250 --> 00:15:13,420
C++ today does not meet the zero

00:15:11,920 --> 00:15:15,670
overhead principle with its own features

00:15:13,420 --> 00:15:17,800
or determinism principle there are two

00:15:15,670 --> 00:15:20,320
such features exception handling and RT

00:15:17,800 --> 00:15:22,720
TI are not zero overhead newsflash

00:15:20,320 --> 00:15:24,550
they're the ones that are commonly

00:15:22,720 --> 00:15:26,950
turned off there are the only two

00:15:24,550 --> 00:15:29,340
standard c-plus features that every

00:15:26,950 --> 00:15:32,110
major compiler has a way to turn off

00:15:29,340 --> 00:15:33,670
that tells you people are voting with

00:15:32,110 --> 00:15:35,290
their feet but the reason is is because

00:15:33,670 --> 00:15:37,660
they're not zero overhead and not

00:15:35,290 --> 00:15:40,500
deterministic if we solve that which for

00:15:37,660 --> 00:15:44,530
example we are in fact already doing for

00:15:40,500 --> 00:15:46,120
our TTI for the type ID part with static

00:15:44,530 --> 00:15:47,650
reflection because once you got that you

00:15:46,120 --> 00:15:49,630
don't need type ID anymore you can just

00:15:47,650 --> 00:15:51,200
statically reflect at compile time and

00:15:49,630 --> 00:15:54,110
just save the stuff only the

00:15:51,200 --> 00:15:57,160
stuff you need in your binary totally

00:15:54,110 --> 00:16:00,620
zero overhead so how does this proposal

00:15:57,160 --> 00:16:03,410
help fix an outstanding problem like

00:16:00,620 --> 00:16:07,250
that which makes c++ even more C+

00:16:03,410 --> 00:16:10,450
classic than it already is how can this

00:16:07,250 --> 00:16:13,520
feature help us remove something someday

00:16:10,450 --> 00:16:15,380
to potentially even deprecated or at

00:16:13,520 --> 00:16:16,970
least write guidelines and linters rules

00:16:15,380 --> 00:16:22,630
that say don't do that and give you

00:16:16,970 --> 00:16:24,770
errors in clean new code like macros an

00:16:22,630 --> 00:16:26,780
example and I could give many examples

00:16:24,770 --> 00:16:30,170
where we've done this but a using alias

00:16:26,780 --> 00:16:32,150
is a good one instead of template izing

00:16:30,170 --> 00:16:34,220
type def which i initially proposed

00:16:32,150 --> 00:16:35,600
because we needed that and I didn't

00:16:34,220 --> 00:16:37,550
think the committee had appetite for

00:16:35,600 --> 00:16:39,590
more than that imagine how surprised I

00:16:37,550 --> 00:16:41,660
was when the response to that paper was

00:16:39,590 --> 00:16:45,020
at the next meeting paper saying no

00:16:41,660 --> 00:16:46,850
let's have a using alias that is

00:16:45,020 --> 00:16:48,710
left-to-right and clean like we would

00:16:46,850 --> 00:16:50,210
want it and template eyes that and just

00:16:48,710 --> 00:16:53,510
leave type def alone for when you need

00:16:50,210 --> 00:16:54,830
it for existing code I was pleasantly

00:16:53,510 --> 00:16:57,830
surprised to see the committee have

00:16:54,830 --> 00:16:59,810
appetite for that and today we are in a

00:16:57,830 --> 00:17:04,130
world where we can teach people and the

00:16:59,810 --> 00:17:06,680
core guidelines say this don't use type

00:17:04,130 --> 00:17:08,240
def in new code usually using alias it

00:17:06,680 --> 00:17:10,310
can do everything a type def can do and

00:17:08,240 --> 00:17:12,050
more but type def is still here in this

00:17:10,310 --> 00:17:15,199
bucket now we can have a separate bucket

00:17:12,050 --> 00:17:17,650
for compatibility mode and think of it

00:17:15,199 --> 00:17:20,440
that way our modern language and

00:17:17,650 --> 00:17:23,420
compatibility mode and the more we add

00:17:20,440 --> 00:17:26,180
superseding features on this side the

00:17:23,420 --> 00:17:27,920
more we can move croft into

00:17:26,180 --> 00:17:30,170
compatibility mode and there's a lot of

00:17:27,920 --> 00:17:31,880
good we can retain here but we end up

00:17:30,170 --> 00:17:34,880
with a simpler language to teach and

00:17:31,880 --> 00:17:36,950
learn so please think of this explicitly

00:17:34,880 --> 00:17:39,100
we've already been doing it but let's

00:17:36,950 --> 00:17:41,570
start viewing backward source

00:17:39,100 --> 00:17:44,570
compatibility as a zero overhead feature

00:17:41,570 --> 00:17:46,460
in the sense of today we pay for it in

00:17:44,570 --> 00:17:48,080
the language in the standard because we

00:17:46,460 --> 00:17:50,180
have perfect backward source compat and

00:17:48,080 --> 00:17:52,580
we pay for it in complexity of the spec

00:17:50,180 --> 00:17:55,280
whether we need it or not and not

00:17:52,580 --> 00:17:56,600
everybody needs it all the time so let's

00:17:55,280 --> 00:17:59,610
look for ways to keep doing what we're

00:17:56,600 --> 00:18:02,460
already doing and to make

00:17:59,610 --> 00:18:04,770
new code used the shiny new things and

00:18:02,460 --> 00:18:06,870
distinguish between the latest the

00:18:04,770 --> 00:18:09,929
current modern C++ which is simpler

00:18:06,870 --> 00:18:11,280
already and compatibility mode and if we

00:18:09,929 --> 00:18:12,809
think of this compatibility mode

00:18:11,280 --> 00:18:15,200
separately that will help us to think

00:18:12,809 --> 00:18:18,450
about how C plus s is already evolving

00:18:15,200 --> 00:18:20,309
so with that context let's talk about

00:18:18,450 --> 00:18:23,150
the first of the two main topics which

00:18:20,309 --> 00:18:27,690
is the lifetime extensions for

00:18:23,150 --> 00:18:29,910
simplifying dangling problems so the

00:18:27,690 --> 00:18:32,130
goal here is that to validate the

00:18:29,910 --> 00:18:36,540
approach that I presented here 3 years

00:18:32,130 --> 00:18:37,980
ago and the approach you're gonna see

00:18:36,540 --> 00:18:40,559
today and that you see in the paper that

00:18:37,980 --> 00:18:42,900
was posted last week on the core

00:18:40,559 --> 00:18:45,030
guidelines repo is still the same model

00:18:42,900 --> 00:18:47,760
the main change that we've done besides

00:18:45,030 --> 00:18:51,090
a few minor tweaks is to shift emphasis

00:18:47,760 --> 00:18:54,900
from whole program guarantees perfection

00:18:51,090 --> 00:18:56,490
to diagnosing common cases the 8090

00:18:54,900 --> 00:19:00,299
percent value and we're gonna see

00:18:56,490 --> 00:19:01,980
examples of that now we actually have

00:19:00,299 --> 00:19:03,929
two implementations the last time I was

00:19:01,980 --> 00:19:06,360
on this stage we had a very early rough

00:19:03,929 --> 00:19:08,760
prototype that wasn't shippable in

00:19:06,360 --> 00:19:11,940
visual c++ and since then we've

00:19:08,760 --> 00:19:13,950
gradually shipped more of it today we

00:19:11,940 --> 00:19:16,440
have two partial implementations in

00:19:13,950 --> 00:19:19,350
progress one based on clang and one in

00:19:16,440 --> 00:19:21,600
visual C++ so thank you to Neil and to

00:19:19,350 --> 00:19:23,130
Kyle who aren't here today but Neil was

00:19:21,600 --> 00:19:25,020
from stage with me three years ago and

00:19:23,130 --> 00:19:28,380
Kyle did a lot of the redoing of that

00:19:25,020 --> 00:19:31,350
analysis and thank you also to Mattias

00:19:28,380 --> 00:19:33,210
and Gabor who will see on stage here in

00:19:31,350 --> 00:19:37,740
just a moment for their clang

00:19:33,210 --> 00:19:40,230
implementation one of the goals of this

00:19:37,740 --> 00:19:42,150
analysis is I would like to see if we

00:19:40,230 --> 00:19:43,740
could make it efficient enough to run

00:19:42,150 --> 00:19:45,929
during regular compilation during

00:19:43,740 --> 00:19:48,299
regular ID use and I believe we

00:19:45,929 --> 00:19:51,390
validated that this year we can say yes

00:19:48,299 --> 00:19:55,110
that's been validated the visual C++

00:19:51,390 --> 00:19:57,260
implementation runs in the IDE in a

00:19:55,110 --> 00:20:00,000
static analysis framework extension and

00:19:57,260 --> 00:20:01,919
it runs with real time squiggles the

00:20:00,000 --> 00:20:03,630
performances is sufficient for real-time

00:20:01,919 --> 00:20:04,590
squiggling of dangling hairs and your

00:20:03,630 --> 00:20:07,110
code we'll see a couple of examples

00:20:04,590 --> 00:20:09,990
screenshots and then the clang

00:20:07,110 --> 00:20:11,580
implementation is totally up to Mize

00:20:09,990 --> 00:20:13,590
because the these folks have been

00:20:11,580 --> 00:20:17,790
working on getting the features in

00:20:13,590 --> 00:20:20,700
totally on building reasonably large

00:20:17,790 --> 00:20:24,630
LLVM translation units it's about 5%

00:20:20,700 --> 00:20:26,520
compilation overhead so these are rules

00:20:24,630 --> 00:20:27,570
which we can be confident can be are

00:20:26,520 --> 00:20:28,860
efficient enough because they run

00:20:27,570 --> 00:20:30,750
locally there's no whole program

00:20:28,860 --> 00:20:33,090
analysis there's no data flow analysis

00:20:30,750 --> 00:20:36,090
the only control flow analysis that we

00:20:33,090 --> 00:20:39,180
can run regularly and this is important

00:20:36,090 --> 00:20:43,350
because as soon as you can say all major

00:20:39,180 --> 00:20:45,600
compilers have warning X you can stop

00:20:43,350 --> 00:20:47,340
teaching X because when you write coding

00:20:45,600 --> 00:20:50,130
guidelines when you write books like

00:20:47,340 --> 00:20:52,320
Scott and I and others are done you

00:20:50,130 --> 00:20:54,270
don't need to write items or guidelines

00:20:52,320 --> 00:20:56,490
about things that all compilers warn on

00:20:54,270 --> 00:20:59,250
today dangling at not one of those

00:20:56,490 --> 00:21:02,850
things so we have to have whole items in

00:20:59,250 --> 00:21:05,430
books on these problems if we can detect

00:21:02,850 --> 00:21:07,110
those reliably during compilation and

00:21:05,430 --> 00:21:09,480
just expect compilers to do that a few

00:21:07,110 --> 00:21:11,760
years from now we can stop teaching

00:21:09,480 --> 00:21:13,650
quite a bit of what we teach now so

00:21:11,760 --> 00:21:15,870
let's see some an overview of the

00:21:13,650 --> 00:21:17,640
approach and then some examples the idea

00:21:15,870 --> 00:21:20,010
is we're gonna look at look local flow

00:21:17,640 --> 00:21:21,450
control paths we're going to enforce it

00:21:20,010 --> 00:21:23,670
statically so again this is totally

00:21:21,450 --> 00:21:26,370
compile time this is not a sanitizer it

00:21:23,670 --> 00:21:29,570
is has zero runtime overhead zero impact

00:21:26,370 --> 00:21:31,890
on your binary image the idea is look

00:21:29,570 --> 00:21:34,680
there's basically three kinds of types

00:21:31,890 --> 00:21:38,040
in the world there is just plain old

00:21:34,680 --> 00:21:42,030
types that set their values then like a

00:21:38,040 --> 00:21:45,420
point X int X Y then there are pointers

00:21:42,030 --> 00:21:48,000
with a capital P that refer to somebody

00:21:45,420 --> 00:21:50,040
else's storage but do not own it that's

00:21:48,000 --> 00:21:52,170
a raw pointer or reference it's a string

00:21:50,040 --> 00:21:54,060
view it's a span it's an iterator it's a

00:21:52,170 --> 00:21:56,490
range it's a filter view from their ages

00:21:54,060 --> 00:21:58,170
TS they're all just that thing and we

00:21:56,490 --> 00:22:00,660
just we don't worry about the details of

00:21:58,170 --> 00:22:03,450
the all those types we just say there

00:22:00,660 --> 00:22:05,760
are pointers they point to something

00:22:03,450 --> 00:22:09,210
they don't own and the third category is

00:22:05,760 --> 00:22:12,480
owners they somehow store something they

00:22:09,210 --> 00:22:15,990
do own that's string vector smart

00:22:12,480 --> 00:22:19,350
pointers a regular any owning containers

00:22:15,990 --> 00:22:21,440
that you have and once we have that we

00:22:19,350 --> 00:22:24,390
can have a single set of rules that

00:22:21,440 --> 00:22:25,800
knows only about values pointers and

00:22:24,390 --> 00:22:26,680
owners it's the only kinds of types that

00:22:25,800 --> 00:22:29,760
knows about

00:22:26,680 --> 00:22:32,590
and can know when things get invalidated

00:22:29,760 --> 00:22:33,790
here's a simple example by the way the

00:22:32,590 --> 00:22:35,620
next here's the next four slides

00:22:33,790 --> 00:22:38,890
side-by-side I'm gonna show them to you

00:22:35,620 --> 00:22:43,570
just to show these are basically all the

00:22:38,890 --> 00:22:46,240
same example here's a simple one with an

00:22:43,570 --> 00:22:47,700
int star we set to null so what we're

00:22:46,240 --> 00:22:50,380
going to do is we're going to record

00:22:47,700 --> 00:22:53,320
statically at any given point in the

00:22:50,380 --> 00:22:56,620
source code as we analyze each function

00:22:53,320 --> 00:22:59,140
by itself in isolation what does this

00:22:56,620 --> 00:23:00,850
local pointer point to in this case P

00:22:59,140 --> 00:23:03,540
when declared points to null so we say

00:23:00,850 --> 00:23:06,490
it's P set its points to set is no

00:23:03,540 --> 00:23:08,560
that's what it points to then we open a

00:23:06,490 --> 00:23:10,570
scope we declare an int X there's a

00:23:08,560 --> 00:23:13,600
value that's that third category of type

00:23:10,570 --> 00:23:16,600
then we take the address of X the result

00:23:13,600 --> 00:23:19,530
of the address of X expression is a raw

00:23:16,600 --> 00:23:24,490
pointer which is a capital P pointer and

00:23:19,530 --> 00:23:26,950
it's points to set is X I just took the

00:23:24,490 --> 00:23:29,290
address of X so it points to X when I

00:23:26,950 --> 00:23:32,080
copy the pointer and I put it into P I

00:23:29,290 --> 00:23:35,800
just copy its points to set so now P

00:23:32,080 --> 00:23:37,510
points to X that's its points to set and

00:23:35,800 --> 00:23:41,830
now I can say see out star P and that's

00:23:37,510 --> 00:23:45,220
fine when you do the star P I know that

00:23:41,830 --> 00:23:47,590
ah what is P's P set points to X that's

00:23:45,220 --> 00:23:50,410
still in scope wonderful I won't give

00:23:47,590 --> 00:23:53,230
you an error star P is fine but now

00:23:50,410 --> 00:23:56,770
close that brace and repeat that exact

00:23:53,230 --> 00:23:59,350
same expression see out star P from line

00:23:56,770 --> 00:24:02,500
B where it's green to line D where it's

00:23:59,350 --> 00:24:05,380
red and what happened at that close

00:24:02,500 --> 00:24:07,330
brace line see X was destroyed so the

00:24:05,380 --> 00:24:09,820
rule is when the variable goes out of

00:24:07,330 --> 00:24:12,040
scope what a variable is destroyed in

00:24:09,820 --> 00:24:14,740
any piece sets there are all the P sets

00:24:12,040 --> 00:24:16,870
you've got going locally anytime X is

00:24:14,740 --> 00:24:18,460
mentioned in one of those P sets replace

00:24:16,870 --> 00:24:21,640
it with invalid so in this case we

00:24:18,460 --> 00:24:23,320
change the P set of P to invalid and now

00:24:21,640 --> 00:24:26,140
when we try to dereference p we get an

00:24:23,320 --> 00:24:27,730
error because P set P contains invalid

00:24:26,140 --> 00:24:29,560
and we could even say exactly which line

00:24:27,730 --> 00:24:31,570
invalidated it and what it was pointing

00:24:29,560 --> 00:24:33,100
to at the time and if a pointer can

00:24:31,570 --> 00:24:35,050
point to more than one thing the P set

00:24:33,100 --> 00:24:36,910
can have more than one entry and so you

00:24:35,050 --> 00:24:38,680
can get false positives because it's

00:24:36,910 --> 00:24:40,120
going to be conservative but it shows

00:24:38,680 --> 00:24:42,400
you when a pointer could have

00:24:40,120 --> 00:24:45,430
been invalidated which usually is a bug

00:24:42,400 --> 00:24:49,090
in your code now this is a simple

00:24:45,430 --> 00:24:51,370
example we can generalize this as I

00:24:49,090 --> 00:24:53,170
mentioned to user-defined pointer types

00:24:51,370 --> 00:24:54,580
and we recognize a lot of them out of

00:24:53,170 --> 00:24:57,580
the blocks for example anything that

00:24:54,580 --> 00:24:59,830
looks like an iterator or satisfies the

00:24:57,580 --> 00:25:01,840
ranges TS range requirements is just

00:24:59,830 --> 00:25:03,100
Auto detected as a pointer type you

00:25:01,840 --> 00:25:04,960
don't have to annotate it there is an

00:25:03,100 --> 00:25:07,000
annotation but you don't need to use it

00:25:04,960 --> 00:25:08,620
very often and if you do it's you write

00:25:07,000 --> 00:25:10,450
your own type that has a different

00:25:08,620 --> 00:25:12,790
interface you can say I am a pointer and

00:25:10,450 --> 00:25:15,130
then that unlocks all those analysis for

00:25:12,790 --> 00:25:17,110
users of your type but a string view we

00:25:15,130 --> 00:25:18,730
do that by default and you can see the

00:25:17,110 --> 00:25:20,380
goggles example live there if you'd like

00:25:18,730 --> 00:25:23,410
to run it please not now

00:25:20,380 --> 00:25:25,660
but it's available afterwards so the

00:25:23,410 --> 00:25:28,270
string of us when we default construct

00:25:25,660 --> 00:25:30,310
it we say okay a default constructed

00:25:28,270 --> 00:25:32,410
pointer by default is normal points to

00:25:30,310 --> 00:25:34,960
null then I enter a scope I have a

00:25:32,410 --> 00:25:37,600
character array I say s equals a so I've

00:25:34,960 --> 00:25:40,750
got now a string view to that array so P

00:25:37,600 --> 00:25:43,570
set s is a string view points to array a

00:25:40,750 --> 00:25:46,030
and I can use the string view s sub 0

00:25:43,570 --> 00:25:48,700
but at line C when a is destroyed I go

00:25:46,030 --> 00:25:52,780
and I replace a in all P sets with

00:25:48,700 --> 00:25:56,140
invalid so now P points to or s via the

00:25:52,780 --> 00:25:58,000
string of us points to invalid and now

00:25:56,140 --> 00:26:00,640
when I try to use it on the last line I

00:25:58,000 --> 00:26:03,070
get an error it's the same expression as

00:26:00,640 --> 00:26:05,500
it was earlier in the function on line B

00:26:03,070 --> 00:26:07,780
but it was valid on line B and it's not

00:26:05,500 --> 00:26:09,630
valid on line D and again there's no

00:26:07,780 --> 00:26:12,490
data flow analysis we're not tracking

00:26:09,630 --> 00:26:14,020
values of anything all we're doing is

00:26:12,490 --> 00:26:15,940
following the control flow passed

00:26:14,020 --> 00:26:19,480
through the function it's a single pass

00:26:15,940 --> 00:26:23,620
algorithm very efficient and we can

00:26:19,480 --> 00:26:25,360
compute these answers so just as we

00:26:23,620 --> 00:26:28,180
generalized to pointers let's generalize

00:26:25,360 --> 00:26:32,740
to owner types same example now but this

00:26:28,180 --> 00:26:35,380
time with a string a string is an owner

00:26:32,740 --> 00:26:38,650
it owns some data in this case a

00:26:35,380 --> 00:26:41,500
character array now when I say s equals

00:26:38,650 --> 00:26:45,070
name on line a we set the points to set

00:26:41,500 --> 00:26:46,990
of s to name Prime so if you point if

00:26:45,070 --> 00:26:49,120
you get a pointer to an owner storage

00:26:46,990 --> 00:26:50,560
it's to owner Prime and that's just our

00:26:49,120 --> 00:26:52,640
convention for it you're not pointing to

00:26:50,560 --> 00:26:54,080
owner which you could also do

00:26:52,640 --> 00:26:56,060
but in this case you're pointing to the

00:26:54,080 --> 00:26:59,120
thing owned by owner and now there's

00:26:56,060 --> 00:27:03,080
another rule now you invalidate owner

00:26:59,120 --> 00:27:07,580
prime not just if owner is destroyed but

00:27:03,080 --> 00:27:10,070
also if it is used in a non-constant

00:27:07,580 --> 00:27:11,810
and there are a few cases where you need

00:27:10,070 --> 00:27:13,940
to annotate yeah this non constitutes is

00:27:11,810 --> 00:27:15,860
actually not invalidating and you can do

00:27:13,940 --> 00:27:18,830
that but most of the time that works

00:27:15,860 --> 00:27:20,570
great including that if I say name

00:27:18,830 --> 00:27:23,720
equals frou Boz so I'm assigning to

00:27:20,570 --> 00:27:26,200
string I say ah any piece set that has

00:27:23,720 --> 00:27:29,240
name prime because I modified the owner

00:27:26,200 --> 00:27:31,490
set it to invalid because modifying the

00:27:29,240 --> 00:27:34,850
owner could and in this case may well

00:27:31,490 --> 00:27:37,280
have moved the memory and then I can

00:27:34,850 --> 00:27:42,200
diagnose that that string D was dangling

00:27:37,280 --> 00:27:43,910
on line D but not on line B and you can

00:27:42,200 --> 00:27:46,370
do this in general here's a completely

00:27:43,910 --> 00:27:47,690
different set that when one of the

00:27:46,370 --> 00:27:50,870
influencers first looked at this they

00:27:47,690 --> 00:27:52,880
said oh no really C++ does this so some

00:27:50,870 --> 00:27:55,040
of you have known about this for a lot

00:27:52,880 --> 00:27:58,910
longer vector bool what does this

00:27:55,040 --> 00:28:00,650
operate or subscript return a proxy not

00:27:58,910 --> 00:28:03,620
a bool ref because it can't because it

00:28:00,650 --> 00:28:06,110
is supposed to cram them into bits that

00:28:03,620 --> 00:28:09,140
proxy can dangle an if you use Auto

00:28:06,110 --> 00:28:11,240
proxy equals V B sub zero your code will

00:28:09,140 --> 00:28:13,130
work but could dangle if you reassign or

00:28:11,240 --> 00:28:15,980
if you invalidate the vector by pushback

00:28:13,130 --> 00:28:17,750
reserved such as on line C and we can

00:28:15,980 --> 00:28:20,260
detect that just fine exactly the same

00:28:17,750 --> 00:28:23,510
rules as before

00:28:20,260 --> 00:28:25,880
finally function calls since we're

00:28:23,510 --> 00:28:27,800
analyzing each function in isolation

00:28:25,880 --> 00:28:29,660
when you call a function we just assume

00:28:27,800 --> 00:28:31,790
that the any pointers that you get out

00:28:29,660 --> 00:28:33,260
of it are derived from its inputs I mean

00:28:31,790 --> 00:28:36,020
that's what functions almost always do

00:28:33,260 --> 00:28:38,840
is they return stuff that you gave them

00:28:36,020 --> 00:28:40,550
and if it's an a pointer we assumed that

00:28:38,840 --> 00:28:42,500
it could be a copy of that pointer that

00:28:40,550 --> 00:28:44,810
you gave it if it's an owner we assumed

00:28:42,500 --> 00:28:48,860
it could be owner prime derived from

00:28:44,810 --> 00:28:50,480
owner that you gave it the here this can

00:28:48,860 --> 00:28:52,010
be totally heuristic because you can

00:28:50,480 --> 00:28:53,660
override this with annotation the whole

00:28:52,010 --> 00:28:55,810
point of this heuristic is to make

00:28:53,660 --> 00:28:58,250
annotation not needed most of the time

00:28:55,810 --> 00:29:00,260
the heuristic is that hey you know what

00:28:58,250 --> 00:29:02,810
if you have a Const reference parameter

00:29:00,260 --> 00:29:04,910
that combined to our values people keep

00:29:02,810 --> 00:29:06,370
forgetting that so by default we're

00:29:04,910 --> 00:29:08,020
going to assume that any points are

00:29:06,370 --> 00:29:10,330
you get back didn't come from a const

00:29:08,020 --> 00:29:11,920
reference owner parameter unless that's

00:29:10,330 --> 00:29:14,080
all you got if that's all you got okay

00:29:11,920 --> 00:29:17,920
you probably got it from that turns out

00:29:14,080 --> 00:29:20,650
this finds bugs when the implementation

00:29:17,920 --> 00:29:22,360
returned a pointer derived from its

00:29:20,650 --> 00:29:27,309
constructor and wasn't thinking about oh

00:29:22,360 --> 00:29:29,200
that could be a temporary or when the

00:29:27,309 --> 00:29:31,960
caller was doing it and didn't realize

00:29:29,200 --> 00:29:33,670
what was going on so let's take a look

00:29:31,960 --> 00:29:35,500
at some examples and I have this cute

00:29:33,670 --> 00:29:38,290
little video that is showing three

00:29:35,500 --> 00:29:39,850
phases of dangling and I want you to see

00:29:38,290 --> 00:29:41,170
these three phases the first is notice

00:29:39,850 --> 00:29:45,550
he's dangling but everything's okay so

00:29:41,170 --> 00:29:47,170
far there is the dereference and and

00:29:45,550 --> 00:29:49,720
there's the third state did you see the

00:29:47,170 --> 00:29:51,640
undefined behavior dangling dereference

00:29:49,720 --> 00:29:57,910
and then sometime later undefined

00:29:51,640 --> 00:30:00,990
behavior can we say it all together if

00:29:57,910 --> 00:30:06,429
you'll humor me so it's three phases

00:30:00,990 --> 00:30:10,120
dangling dereference undefined behavior

00:30:06,429 --> 00:30:12,429
thank you and with and that's actually

00:30:10,120 --> 00:30:14,380
pretty much what happens sometime later

00:30:12,429 --> 00:30:16,300
that's what you get please welcome to

00:30:14,380 --> 00:30:18,580
the stage matias guerra and Gabor

00:30:16,300 --> 00:30:20,500
Horvath who are the implementers of The

00:30:18,580 --> 00:30:23,520
Crying based implementation and we'll do

00:30:20,500 --> 00:30:23,520
some examples together

00:30:30,460 --> 00:30:34,970
so thank you very much first thank you

00:30:32,720 --> 00:30:36,590
for doing the hard work to implement

00:30:34,970 --> 00:30:38,750
this I know you've come a long way from

00:30:36,590 --> 00:30:41,270
Europe as well so thank you for being at

00:30:38,750 --> 00:30:43,340
see if you pecan and by the way these

00:30:41,270 --> 00:30:46,370
gentlemen will have a talk later today

00:30:43,340 --> 00:30:47,810
on implementing this lifetime profile

00:30:46,370 --> 00:30:50,750
we're talking about in this section of

00:30:47,810 --> 00:30:52,010
this talk in clang so you can find them

00:30:50,750 --> 00:30:54,260
there to ask questions and see a

00:30:52,010 --> 00:30:57,020
presentation about more details of the

00:30:54,260 --> 00:30:58,370
clang specific implementation but now

00:30:57,020 --> 00:31:00,200
here's an example which I'm going to use

00:30:58,370 --> 00:31:02,600
screen shots because conference Wi-Fi

00:31:00,200 --> 00:31:04,190
and because it's a more convenient so

00:31:02,600 --> 00:31:06,740
here's a screenshot from the visual c

00:31:04,190 --> 00:31:09,250
plus implementation but it's one I know

00:31:06,740 --> 00:31:11,510
that that resonates with you mattias

00:31:09,250 --> 00:31:15,860
what's going on here with this min

00:31:11,510 --> 00:31:18,470
example sure so simple we start with

00:31:15,860 --> 00:31:20,720
declaring two variables x and y they did

00:31:18,470 --> 00:31:24,140
use to end even though they are Auto and

00:31:20,720 --> 00:31:26,690
then we use good old statement to find

00:31:24,140 --> 00:31:30,080
the minimum of pose and we take actually

00:31:26,690 --> 00:31:33,290
reference as a return so good will point

00:31:30,080 --> 00:31:36,590
to why obviously and then we can print

00:31:33,290 --> 00:31:38,840
good and everything will be okay but

00:31:36,590 --> 00:31:40,190
turns out sometimes later someone comes

00:31:38,840 --> 00:31:42,200
and say oh that's not actually the

00:31:40,190 --> 00:31:44,480
business logic anymore I don't want to

00:31:42,200 --> 00:31:47,600
have the minimum at x and y I need Y

00:31:44,480 --> 00:31:50,750
plus 1 so we just add one what can

00:31:47,600 --> 00:31:53,090
happen its minimum and it turns out that

00:31:50,750 --> 00:31:55,490
now bad still binds to the second

00:31:53,090 --> 00:31:58,660
argument because y plus 1 turns out to

00:31:55,490 --> 00:32:01,730
be smaller but y plus 1 is a temporary

00:31:58,660 --> 00:32:03,980
so bad will initially bind to y plus 1

00:32:01,730 --> 00:32:05,930
but the temporary will be destroyed at n

00:32:03,980 --> 00:32:08,330
or full expression where at end of line

00:32:05,930 --> 00:32:10,370
14 and now if we do the dereference

00:32:08,330 --> 00:32:12,500
things will happen like we just saw and

00:32:10,370 --> 00:32:14,270
so this actually uses those default

00:32:12,500 --> 00:32:16,010
function call rules I just said turns

00:32:14,270 --> 00:32:18,530
out stood min needed no annotation

00:32:16,010 --> 00:32:19,970
because it takes two references it's

00:32:18,530 --> 00:32:22,520
perfect always forget its reference not

00:32:19,970 --> 00:32:25,070
value which is efficient except when you

00:32:22,520 --> 00:32:26,420
dangle it takes two references and

00:32:25,070 --> 00:32:29,480
returns a reference lower references

00:32:26,420 --> 00:32:32,120
pointers by default we assume that the

00:32:29,480 --> 00:32:33,860
pointer that's returned is derived from

00:32:32,120 --> 00:32:36,860
the inputs which is two pointers so we

00:32:33,860 --> 00:32:38,210
assume it's one of those so the points

00:32:36,860 --> 00:32:40,790
to sent you get back is

00:32:38,210 --> 00:32:44,540
for bad is going to be the points to set

00:32:40,790 --> 00:32:46,310
of X comma temp where temp is y plus 1

00:32:44,540 --> 00:32:48,500
and then when temp is destroyed boom

00:32:46,310 --> 00:32:49,240
this does your clang implementation and

00:32:48,500 --> 00:32:52,010
handle this

00:32:49,240 --> 00:32:54,200
exactly well let's take a look so here's

00:32:52,010 --> 00:32:57,080
the clang implementation on God bolt in

00:32:54,200 --> 00:32:58,730
the CPP X God bolt org and you can find

00:32:57,080 --> 00:33:00,290
links to these examples in the lifetime

00:32:58,730 --> 00:33:02,330
paper there's over 30 links and here's

00:33:00,290 --> 00:33:04,250
just a few of them and so here we see

00:33:02,330 --> 00:33:07,010
exactly the same thing and I like how

00:33:04,250 --> 00:33:08,660
you've got two messages here yes you

00:33:07,010 --> 00:33:11,330
will get the warning on the difference

00:33:08,660 --> 00:33:13,130
in line 12 the squiggle it's bad and it

00:33:11,330 --> 00:33:15,740
says oh dear referencing a dangling

00:33:13,130 --> 00:33:18,770
pointer which here's a reference it's in

00:33:15,740 --> 00:33:21,530
generalized pointer and it also gives a

00:33:18,770 --> 00:33:23,210
note to find out where this reference

00:33:21,530 --> 00:33:25,810
started dangling and that's at the end

00:33:23,210 --> 00:33:27,890
of line 11 you see a squiggle under the

00:33:25,810 --> 00:33:31,690
semicolon and the note says yes

00:33:27,890 --> 00:33:33,890
temporary was destroyed here great now

00:33:31,690 --> 00:33:35,480
gabor you had mentioned to me that you

00:33:33,890 --> 00:33:36,950
were sitting in one of the Jason Turner

00:33:35,480 --> 00:33:37,400
starters Jason Turner here yell if

00:33:36,950 --> 00:33:39,380
you're here

00:33:37,400 --> 00:33:43,730
there is Jason thank you for providing

00:33:39,380 --> 00:33:46,010
us examples so we all can do this here's

00:33:43,730 --> 00:33:48,830
an example from Jason's talk that you

00:33:46,010 --> 00:33:50,240
had mentioned and so we put it into the

00:33:48,830 --> 00:33:53,240
compiler what's going on here and what

00:33:50,240 --> 00:33:56,090
do we diagnose right so here we have a

00:33:53,240 --> 00:33:58,400
local variable and we will return a

00:33:56,090 --> 00:34:01,220
reference wrapper which refers to this

00:33:58,400 --> 00:34:03,470
local variable and of course after the

00:34:01,220 --> 00:34:06,590
function is returned the local variable

00:34:03,470 --> 00:34:09,590
is no longer available so this reference

00:34:06,590 --> 00:34:11,810
wrapper will dangle and as Jason pointed

00:34:09,590 --> 00:34:14,780
out that is really interesting about

00:34:11,810 --> 00:34:16,910
this example if we use row pointers or

00:34:14,780 --> 00:34:18,980
references the compiler would issue a

00:34:16,910 --> 00:34:20,930
warning for that but if we use a

00:34:18,980 --> 00:34:23,270
reference wrapper none of the major

00:34:20,930 --> 00:34:25,880
compiler warns and the reason is that

00:34:23,270 --> 00:34:29,660
the major compiler the compiler doesn't

00:34:25,880 --> 00:34:33,680
know what the reference vector actually

00:34:29,660 --> 00:34:36,500
is but if we would show the interface of

00:34:33,680 --> 00:34:39,110
this class to a developer then she could

00:34:36,500 --> 00:34:42,680
infer that it's something like a pointer

00:34:39,110 --> 00:34:45,440
that is that is its type row and this is

00:34:42,680 --> 00:34:47,780
exactly what this analysis does it can

00:34:45,440 --> 00:34:50,790
infer that this is likely to be

00:34:47,780 --> 00:34:53,480
something that acts as a pointer

00:34:50,790 --> 00:34:56,220
this HAP says that acting is this issue

00:34:53,480 --> 00:34:57,900
so this particular one we never tested

00:34:56,220 --> 00:34:59,820
reference rapper but because it made

00:34:57,900 --> 00:35:02,220
matches the pointer heuristics we didn't

00:34:59,820 --> 00:35:03,600
require annotation and it just

00:35:02,220 --> 00:35:05,850
recognized it out of the box and

00:35:03,600 --> 00:35:07,320
happened to get it so thank you now

00:35:05,850 --> 00:35:09,300
here's another one that was also in

00:35:07,320 --> 00:35:11,910
Jason's talk but it was also in an

00:35:09,300 --> 00:35:13,770
article in a standards paper this summer

00:35:11,910 --> 00:35:14,460
at our last Anders meeting by Niko

00:35:13,770 --> 00:35:18,150
Yasuda

00:35:14,460 --> 00:35:19,680
and Richard Smith of Google and so

00:35:18,150 --> 00:35:21,690
everybody comes across this kind of

00:35:19,680 --> 00:35:25,140
example so we had it in the talk in a

00:35:21,690 --> 00:35:27,420
paper what's going on here yes so maybe

00:35:25,140 --> 00:35:30,570
you heard a lot of puns about how string

00:35:27,420 --> 00:35:32,730
view makes the language more unsafe so

00:35:30,570 --> 00:35:35,940
what is happening here we have a string

00:35:32,730 --> 00:35:38,550
literal that we are converting into a

00:35:35,940 --> 00:35:42,570
stud string and during this conversion

00:35:38,550 --> 00:35:45,630
we will create a temporary and stood

00:35:42,570 --> 00:35:48,030
string will convert into string view

00:35:45,630 --> 00:35:50,370
because there is an implicit conversion

00:35:48,030 --> 00:35:53,010
and this string view will refer to this

00:35:50,370 --> 00:35:55,830
temporary which will be gone by the end

00:35:53,010 --> 00:36:00,180
of the full expression so in the next

00:35:55,830 --> 00:36:03,090
line the string view will dangle so even

00:36:00,180 --> 00:36:05,100
though this behavior is kind of

00:36:03,090 --> 00:36:08,130
dangerous in this language but if we

00:36:05,100 --> 00:36:11,670
have the right tools it will not cause

00:36:08,130 --> 00:36:13,800
any headache yes so interestingly do you

00:36:11,670 --> 00:36:15,840
notice the error is on line seven not on

00:36:13,800 --> 00:36:17,430
line six so remember our animation it

00:36:15,840 --> 00:36:18,990
wasn't just a gratuitous animation to

00:36:17,430 --> 00:36:21,960
see somebody smack their head like there

00:36:18,990 --> 00:36:25,640
actually was a teaching value there

00:36:21,960 --> 00:36:27,300
because dangling is one thing it's

00:36:25,640 --> 00:36:29,610
dereferencing it's where you hit your

00:36:27,300 --> 00:36:31,470
head and then sometime after that you'll

00:36:29,610 --> 00:36:32,850
get the actual bug manifest as undefined

00:36:31,470 --> 00:36:36,750
behavior as the swing comes back in

00:36:32,850 --> 00:36:38,820
conquer line six is perfectly fine in

00:36:36,750 --> 00:36:40,710
fact we want to be able to write

00:36:38,820 --> 00:36:43,200
dangling pointers as long as we don't

00:36:40,710 --> 00:36:44,970
rear-ends them because you do that every

00:36:43,200 --> 00:36:46,500
time you reuse a pointer variable in a

00:36:44,970 --> 00:36:48,390
loop and you set it on the next trip

00:36:46,500 --> 00:36:50,370
through the loop to something else and

00:36:48,390 --> 00:36:51,900
then you use it and then it's that

00:36:50,370 --> 00:36:53,430
entangles that's okay you don't use it

00:36:51,900 --> 00:36:55,560
till your next trip through the loop and

00:36:53,430 --> 00:36:58,020
you want to reuse variables like that I

00:36:55,560 --> 00:37:00,450
actually don't like the choice certain

00:36:58,020 --> 00:37:03,440
other languages have made that diagnose

00:37:00,450 --> 00:37:04,780
as soon as you invalidate because

00:37:03,440 --> 00:37:07,360
invalidating a point

00:37:04,780 --> 00:37:10,840
not a bug and I it prohibits reusing

00:37:07,360 --> 00:37:12,640
variables it's dereferencing or using an

00:37:10,840 --> 00:37:13,810
invalidated pointer that's a bug so I

00:37:12,640 --> 00:37:16,810
really like that the errors on line

00:37:13,810 --> 00:37:19,360
seven not on line six but now this next

00:37:16,810 --> 00:37:21,280
example of month yes this example first

00:37:19,360 --> 00:37:24,460
of all thank you to the 30 people who

00:37:21,280 --> 00:37:25,450
replied to the SCM challenge puzzle

00:37:24,460 --> 00:37:26,920
where I asked you to come up with

00:37:25,450 --> 00:37:30,430
examples we're gonna have three winners

00:37:26,920 --> 00:37:33,610
in a moment a quarter of you gave

00:37:30,430 --> 00:37:37,450
variants of this example most of those

00:37:33,610 --> 00:37:40,000
said vector erase how bad is this book

00:37:37,450 --> 00:37:42,100
at what's going on here so let's first

00:37:40,000 --> 00:37:43,750
look at what's going on we have a vector

00:37:42,100 --> 00:37:45,880
declared in F so there were some

00:37:43,750 --> 00:37:48,520
elements we do them iteration over the

00:37:45,880 --> 00:37:51,610
vector and when we find an interesting

00:37:48,520 --> 00:37:54,940
element say two we say oh that shouldn't

00:37:51,610 --> 00:37:58,480
be here so we erase it but of course

00:37:54,940 --> 00:38:02,200
that makes our vector change size and so

00:37:58,480 --> 00:38:04,870
if we don't update our point our iterate

00:38:02,200 --> 00:38:07,600
or do something to I then I will not be

00:38:04,870 --> 00:38:09,580
what we expect to be in the case we see

00:38:07,600 --> 00:38:11,410
on the screen we will not even find that

00:38:09,580 --> 00:38:13,870
in testing because I will just point to

00:38:11,410 --> 00:38:16,300
the next element we will skip one which

00:38:13,870 --> 00:38:19,590
we didn't intend but it would kind of

00:38:16,300 --> 00:38:22,480
run fine but then in production we might

00:38:19,590 --> 00:38:26,590
actually remove the last element and

00:38:22,480 --> 00:38:28,360
then by skipping and incrementing the

00:38:26,590 --> 00:38:31,090
iterate on next iteration you'll

00:38:28,360 --> 00:38:33,250
actually skip past the end and then we

00:38:31,090 --> 00:38:36,340
will start looping over uninitialized

00:38:33,250 --> 00:38:39,790
memory so this is an error in all cases

00:38:36,340 --> 00:38:42,610
and the analysis finds this because has

00:38:39,790 --> 00:38:45,790
a notion of where I point to I points in

00:38:42,610 --> 00:38:48,370
to V and when we call a non construction

00:38:45,790 --> 00:38:49,900
on V which is erase then all iterator

00:38:48,370 --> 00:38:51,720
said pointed to V get invalidated

00:38:49,900 --> 00:38:54,310
because you should get a new one

00:38:51,720 --> 00:38:56,680
so I one very interesting thing about

00:38:54,310 --> 00:39:00,910
this example there's two lines mentioned

00:38:56,680 --> 00:39:04,450
six and eight which one is the error so

00:39:00,910 --> 00:39:06,640
the error happens on line 6 where the

00:39:04,450 --> 00:39:09,460
warning is because there we do increment

00:39:06,640 --> 00:39:12,850
some iterator but the dangling happens

00:39:09,460 --> 00:39:15,040
on line 8 and that seems to be wrong

00:39:12,850 --> 00:39:17,119
order because usually your first tango

00:39:15,040 --> 00:39:19,130
and UDF but

00:39:17,119 --> 00:39:23,329
cut the loop I mean that's the audibly

00:39:19,130 --> 00:39:25,069
how we observe it in one iteration where

00:39:23,329 --> 00:39:26,779
you see the two you race and then in the

00:39:25,069 --> 00:39:28,910
next iteration when incrementing the

00:39:26,779 --> 00:39:30,950
iterator when you do some operation to

00:39:28,910 --> 00:39:33,789
an iterator which is dangling and that's

00:39:30,950 --> 00:39:38,029
why you see logically the dangling

00:39:33,789 --> 00:39:39,380
happen after the dereference and if you

00:39:38,029 --> 00:39:41,869
look in the paper you'll see how this is

00:39:39,380 --> 00:39:43,309
described basically we take a one pass

00:39:41,869 --> 00:39:44,769
through the function if there is an

00:39:43,309 --> 00:39:47,960
if-else those are basically just

00:39:44,769 --> 00:39:50,150
divergent and then for conjoined control

00:39:47,960 --> 00:39:52,539
flows in the control flow graph for a

00:39:50,150 --> 00:39:55,220
loop we treated just like an if-else

00:39:52,539 --> 00:39:57,769
except we do it twice once for the first

00:39:55,220 --> 00:40:00,230
iteration and once for every non first

00:39:57,769 --> 00:40:03,109
iteration only once not n just two

00:40:00,230 --> 00:40:05,869
iterations the first and then one to all

00:40:03,109 --> 00:40:07,430
the others to catch any invalidations in

00:40:05,869 --> 00:40:09,349
the body of the loop which would affect

00:40:07,430 --> 00:40:12,230
subsequent iterations so our first on

00:40:09,349 --> 00:40:14,059
and on first and now we teach people to

00:40:12,230 --> 00:40:16,460
right at the bottom way you have this as

00:40:14,059 --> 00:40:18,099
an interview question don't you yes and

00:40:16,460 --> 00:40:21,170
it works pretty well

00:40:18,099 --> 00:40:23,930
so for reference you can see on the

00:40:21,170 --> 00:40:26,390
lower part how you can do it to avoid

00:40:23,930 --> 00:40:28,400
tangling and that will also work in the

00:40:26,390 --> 00:40:30,859
end the checker so we'll make the

00:40:28,400 --> 00:40:33,859
checker happy and to interviewer because

00:40:30,859 --> 00:40:36,559
we will use the iterator that's returned

00:40:33,859 --> 00:40:39,619
from arrays and even though erase itself

00:40:36,559 --> 00:40:41,509
invalidated to vector we know that the

00:40:39,619 --> 00:40:43,519
function will return something valid I

00:40:41,509 --> 00:40:45,559
mean we don't assume that functions

00:40:43,519 --> 00:40:47,809
return invalid state we will check that

00:40:45,559 --> 00:40:49,640
in the function body but here we both

00:40:47,809 --> 00:40:51,289
assumed it had call side and that's also

00:40:49,640 --> 00:40:53,480
the correct thing to do so the fresh

00:40:51,289 --> 00:40:55,849
iterator we get out of the race will be

00:40:53,480 --> 00:40:56,839
perfectly valid and in fact one reason

00:40:55,849 --> 00:40:59,630
you have this as an interview question

00:40:56,839 --> 00:41:02,180
is because scott Meyers has basically an

00:40:59,630 --> 00:41:04,009
item on this ineffective STL so it tests

00:41:02,180 --> 00:41:07,759
whether people read the book and know

00:41:04,009 --> 00:41:11,029
that so sad news is that now we don't

00:41:07,759 --> 00:41:13,670
need that item anymore if if every major

00:41:11,029 --> 00:41:15,140
compiler gave this warning because you

00:41:13,670 --> 00:41:16,999
were just worn out all the time you

00:41:15,140 --> 00:41:18,769
might need just a very shorter item

00:41:16,999 --> 00:41:20,930
saying when you get this warning right

00:41:18,769 --> 00:41:22,549
this pattern but you wouldn't need to

00:41:20,930 --> 00:41:24,950
explain the whole thing or how to watch

00:41:22,549 --> 00:41:27,230
out for it but now let's talk about no

00:41:24,950 --> 00:41:28,940
and and gob where you had some examples

00:41:27,230 --> 00:41:29,640
that interested you what's going on in

00:41:28,940 --> 00:41:32,039
f1

00:41:29,640 --> 00:41:36,089
right so if we look at the first

00:41:32,039 --> 00:41:39,210
function the interface doesn't tell us a

00:41:36,089 --> 00:41:42,450
lot for example we cannot know whether P

00:41:39,210 --> 00:41:44,940
might be now or not so in this case we

00:41:42,450 --> 00:41:46,859
assume that this value might be now if

00:41:44,940 --> 00:41:49,380
that's not the case maybe it is better

00:41:46,859 --> 00:41:52,650
to use references or some kind of

00:41:49,380 --> 00:41:54,690
annotation and I like your your note on

00:41:52,650 --> 00:41:56,369
line one saying here are the things that

00:41:54,690 --> 00:41:57,930
you could write this as to silence the

00:41:56,369 --> 00:42:01,289
warning right which actually improve the

00:41:57,930 --> 00:42:04,529
code right if we look at the second

00:42:01,289 --> 00:42:06,359
function we will see if we insert a null

00:42:04,529 --> 00:42:09,210
check in the function we will no longer

00:42:06,359 --> 00:42:13,289
warn for the potentional dereference

00:42:09,210 --> 00:42:16,019
this not only makes the code safer but

00:42:13,289 --> 00:42:19,470
also clearer because this way we can see

00:42:16,019 --> 00:42:22,230
that the user expects p to be now in

00:42:19,470 --> 00:42:24,720
some cases and if you look at the third

00:42:22,230 --> 00:42:27,809
example you can see that we do not

00:42:24,720 --> 00:42:29,730
constrain you how to write this not

00:42:27,809 --> 00:42:32,130
check because in both of the cases we

00:42:29,730 --> 00:42:34,349
have two branches on one branch the

00:42:32,130 --> 00:42:38,339
pointer is null on the other it is not

00:42:34,349 --> 00:42:41,640
now so it's that easy and if we look at

00:42:38,339 --> 00:42:44,609
the next function it's a bit trickier we

00:42:41,640 --> 00:42:47,069
still detect that there is an assert

00:42:44,609 --> 00:42:49,980
which is a basically a precondition

00:42:47,069 --> 00:42:52,559
check in the current C++ so we will

00:42:49,980 --> 00:42:54,930
recognize that and we will not warn on

00:42:52,559 --> 00:42:57,269
the next line does if there is a caveat

00:42:54,930 --> 00:43:00,630
to this because if you are compiling

00:42:57,269 --> 00:43:02,849
your code in a release mode the assert

00:43:00,630 --> 00:43:05,279
might disappear because it is a macro

00:43:02,849 --> 00:43:07,710
and it doesn't just disappear from their

00:43:05,279 --> 00:43:09,450
code it disappears from the control flow

00:43:07,710 --> 00:43:10,200
graph the client gives you so you can't

00:43:09,450 --> 00:43:14,099
see it anymore

00:43:10,200 --> 00:43:16,309
exactly so unfortunately in release

00:43:14,099 --> 00:43:19,140
builds you might see a warning there

00:43:16,309 --> 00:43:21,599
fortunately in the upcoming standard we

00:43:19,140 --> 00:43:24,839
will hopefully have a solution to that

00:43:21,599 --> 00:43:27,119
with contracts yes which were just voted

00:43:24,839 --> 00:43:28,470
in in June just three four months ago in

00:43:27,119 --> 00:43:31,519
rapperswil so we're very glad to have

00:43:28,470 --> 00:43:33,980
that and then you can write line 17 as

00:43:31,519 --> 00:43:38,190
learning tool of square brackets

00:43:33,980 --> 00:43:41,309
attribute assert : P or write it as an

00:43:38,190 --> 00:43:43,460
expects precondition on f4 but now what

00:43:41,309 --> 00:43:47,310
about function f5

00:43:43,460 --> 00:43:49,650
see right in function of five we have a

00:43:47,310 --> 00:43:53,100
math check but the NA check is not

00:43:49,650 --> 00:43:58,440
correct even if P is not now but Q is

00:43:53,100 --> 00:44:00,510
now we can still so if P is null and Q

00:43:58,440 --> 00:44:04,200
is not now we can still the reference in

00:44:00,510 --> 00:44:06,420
our pointer and this check will see this

00:44:04,200 --> 00:44:09,270
and in order to fix this error we need

00:44:06,420 --> 00:44:11,240
to check the Guardian condition you need

00:44:09,270 --> 00:44:14,010
to fix the Guardian condition and

00:44:11,240 --> 00:44:18,720
finally what about this pointer chasing

00:44:14,010 --> 00:44:21,450
node function on line 33 yes in the last

00:44:18,720 --> 00:44:25,200
function we can see that when we have a

00:44:21,450 --> 00:44:28,640
loop basically we have branches and we

00:44:25,200 --> 00:44:32,280
can handle this in a very similar way so

00:44:28,640 --> 00:44:34,590
after the loop reader exited the loop or

00:44:32,280 --> 00:44:38,160
didn't take it in the first place and in

00:44:34,590 --> 00:44:42,359
both cases the N must be now so we will

00:44:38,160 --> 00:44:44,940
be able to find an RD reference and this

00:44:42,359 --> 00:44:47,070
is actually a hard unknown difficult

00:44:44,940 --> 00:44:49,050
problem in static analysis theory and

00:44:47,070 --> 00:44:51,300
one of the reasons is is because if you

00:44:49,050 --> 00:44:52,920
do data flow analysis you do something

00:44:51,300 --> 00:44:55,230
more than local control flow analysis

00:44:52,920 --> 00:44:56,609
then you have to start dealing with this

00:44:55,230 --> 00:44:58,500
loop and who knows how far it goes

00:44:56,609 --> 00:45:01,080
because it's dynamic you can only do so

00:44:58,500 --> 00:45:02,850
much statically there is no data flow

00:45:01,080 --> 00:45:04,950
analysis going on here we're simply

00:45:02,850 --> 00:45:06,720
saying look there's a fork in the

00:45:04,950 --> 00:45:09,210
control flow graph and then a join and

00:45:06,720 --> 00:45:11,790
along one of those it's going to be null

00:45:09,210 --> 00:45:14,190
or can still be oh this case is going to

00:45:11,790 --> 00:45:16,560
be null so thank you now the next the

00:45:14,190 --> 00:45:19,980
last three examples are taken from that

00:45:16,560 --> 00:45:21,960
rapperswil paper by Susan Smith on all

00:45:19,980 --> 00:45:25,050
the air the evils of dangling and

00:45:21,960 --> 00:45:27,780
incidentally this lifetime profile

00:45:25,050 --> 00:45:28,980
catches all those errors all or almost

00:45:27,780 --> 00:45:31,020
all are caught by the clang

00:45:28,980 --> 00:45:33,090
implementation today that we're in that

00:45:31,020 --> 00:45:34,890
rapperswil paper and here's another one

00:45:33,090 --> 00:45:36,270
from there this is the visual c++ the

00:45:34,890 --> 00:45:38,250
screenshot just so we show that

00:45:36,270 --> 00:45:40,950
implementation as well what's going on

00:45:38,250 --> 00:45:44,160
here about yes so we have a function

00:45:40,950 --> 00:45:45,900
find or default which probably many of

00:45:44,160 --> 00:45:48,480
us have written in one another way and

00:45:45,900 --> 00:45:51,330
had to wish it wasn't a standard and it

00:45:48,480 --> 00:45:53,130
takes a map and the key looks up the key

00:45:51,330 --> 00:45:54,930
in the map and if the key is not there

00:45:53,130 --> 00:45:55,150
it returns the default value that we

00:45:54,930 --> 00:45:57,850
have

00:45:55,150 --> 00:45:59,890
last parameter and because we don't

00:45:57,850 --> 00:46:01,390
intend to mutate the map of the key of

00:45:59,890 --> 00:46:03,040
the default value everything can be

00:46:01,390 --> 00:46:05,560
Const and B of course put references

00:46:03,040 --> 00:46:08,380
because we don't want to have copies so

00:46:05,560 --> 00:46:09,910
that's how we go went to our design and

00:46:08,380 --> 00:46:12,010
then we call it

00:46:09,910 --> 00:46:14,020
so we have our example function we

00:46:12,010 --> 00:46:16,870
declare map it's empty so we will not

00:46:14,020 --> 00:46:18,700
find the key at all we have a key which

00:46:16,870 --> 00:46:22,540
is obviously not in the map and then we

00:46:18,700 --> 00:46:24,550
kind all find our default and as a

00:46:22,540 --> 00:46:27,940
default value with some string that will

00:46:24,550 --> 00:46:30,940
non so we hope that s at the end will

00:46:27,940 --> 00:46:33,220
point to none but what actually happens

00:46:30,940 --> 00:46:36,490
is like in the previous example none

00:46:33,220 --> 00:46:38,350
will be constructing a temporary string

00:46:36,490 --> 00:46:40,090
and that will go into the function and

00:46:38,350 --> 00:46:42,640
the function will return the temporary

00:46:40,090 --> 00:46:44,770
string so s will bind to the temporary

00:46:42,640 --> 00:46:46,540
that contains none but then the

00:46:44,770 --> 00:46:48,660
temporary will be destroyed at end of

00:46:46,540 --> 00:46:51,580
expression and we have a dangling string

00:46:48,660 --> 00:46:53,590
so what we do here is we don't actually

00:46:51,580 --> 00:46:56,260
need to know how the implementation of

00:46:53,590 --> 00:46:57,970
find or default works because that would

00:46:56,260 --> 00:46:59,740
need like inter program analysis and we

00:46:57,970 --> 00:47:02,320
don't do that we just look at the

00:46:59,740 --> 00:47:04,960
argument types and return types and have

00:47:02,320 --> 00:47:08,350
a heuristic that tells us what will the

00:47:04,960 --> 00:47:09,970
return type probably point at and what

00:47:08,350 --> 00:47:14,130
our heuristic tells us in this case that

00:47:09,970 --> 00:47:17,140
the returned thing so what s binds to is

00:47:14,130 --> 00:47:20,440
key or death value it's one of those

00:47:17,140 --> 00:47:21,910
because I have matching types and when

00:47:20,440 --> 00:47:23,920
we now do the analysis locally in the

00:47:21,910 --> 00:47:26,380
call we see s will either point to key

00:47:23,920 --> 00:47:30,010
which is a local variable or to this

00:47:26,380 --> 00:47:32,350
temporary that was passed that it got

00:47:30,010 --> 00:47:34,210
constructed from none and because it is

00:47:32,350 --> 00:47:36,940
one of those and the temporary leaf

00:47:34,210 --> 00:47:39,010
scope as gets invalidated and then we

00:47:36,940 --> 00:47:42,160
will see the error when we dereference

00:47:39,010 --> 00:47:43,750
it excellent thank you for time we'll

00:47:42,160 --> 00:47:45,970
skip over the next couple of examples

00:47:43,750 --> 00:47:47,380
you will find many more in the paper but

00:47:45,970 --> 00:47:49,630
we also want to acknowledge three

00:47:47,380 --> 00:47:51,400
examples that were submitted in the SEM

00:47:49,630 --> 00:47:53,740
challenge so these three folks if you're

00:47:51,400 --> 00:47:55,230
in the room can you please stand up can

00:47:53,740 --> 00:47:59,050
we see you and can you come to the front

00:47:55,230 --> 00:48:02,800
Hyuna Ezra Chung Stefan ghee or guy and

00:47:59,050 --> 00:48:06,110
Isabella Huerta and who's here all right

00:48:02,800 --> 00:48:18,290
run run it's such a long room

00:48:06,110 --> 00:48:21,500
give them a half no I UN yes thank you

00:48:18,290 --> 00:48:25,070
for this example here is the the summary

00:48:21,500 --> 00:48:26,480
where we're calling a function and even

00:48:25,070 --> 00:48:28,280
though we're going through all sorts of

00:48:26,480 --> 00:48:30,440
callback forwarding interfaces with

00:48:28,280 --> 00:48:32,000
references and generic lambdas the

00:48:30,440 --> 00:48:34,640
analysis is simple it sees through all

00:48:32,000 --> 00:48:37,850
that and points out that we're in the

00:48:34,640 --> 00:48:40,400
line 12 we're getting a a pointer to a

00:48:37,850 --> 00:48:42,230
temporary back and gives a nice a nice

00:48:40,400 --> 00:48:45,290
answer so thank you very much for that

00:48:42,230 --> 00:48:47,840
our second answer was Stefan is a gear

00:48:45,290 --> 00:48:50,510
guy key I was right the first time

00:48:47,840 --> 00:48:52,670
thank you and this is from titus winters

00:48:50,510 --> 00:48:54,560
talk so thank you for forgiving it an

00:48:52,670 --> 00:48:57,110
example from another talk earlier at the

00:48:54,560 --> 00:48:59,480
same conference this week again showing

00:48:57,110 --> 00:49:01,340
in this case a directory name that takes

00:48:59,480 --> 00:49:02,690
a string view returns a string view we

00:49:01,340 --> 00:49:05,930
see through all that we see the

00:49:02,690 --> 00:49:09,350
temporary and diagnose the dangling and

00:49:05,930 --> 00:49:12,020
then Isabella this was a classic and

00:49:09,350 --> 00:49:14,720
very famous example a variation of it so

00:49:12,020 --> 00:49:15,500
that made it a unique one so I enjoyed

00:49:14,720 --> 00:49:17,870
that thank you

00:49:15,500 --> 00:49:20,420
which is actually just tweeted by John

00:49:17,870 --> 00:49:23,900
Regehr recently and also discussed by

00:49:20,420 --> 00:49:26,630
Brian Kearney had and again notice that

00:49:23,900 --> 00:49:28,850
you could think in line 13 through 15

00:49:26,630 --> 00:49:33,110
hey this is just returning a part or two

00:49:28,850 --> 00:49:35,090
local yes except that current

00:49:33,110 --> 00:49:35,690
implementations aren't don't see it that

00:49:35,090 --> 00:49:38,120
way

00:49:35,690 --> 00:49:39,920
this analysis does and we get a nice

00:49:38,120 --> 00:49:42,230
error so thank you to all three of these

00:49:39,920 --> 00:49:43,760
thank you also to the people who

00:49:42,230 --> 00:49:46,010
assisted with our demo for remember

00:49:43,760 --> 00:49:47,720
dangling there's the problem the

00:49:46,010 --> 00:49:49,790
dereference and then the undefined

00:49:47,720 --> 00:49:52,930
behavior and thank you to Mattias and

00:49:49,790 --> 00:49:52,930
Gabor let's give them all a hand

00:50:00,440 --> 00:50:06,690
and you can see their talk later today

00:50:03,740 --> 00:50:10,619
so when remember this checklist when

00:50:06,690 --> 00:50:13,170
proposing a new C++ feature what are the

00:50:10,619 --> 00:50:15,390
things we should ask well I think I hope

00:50:13,170 --> 00:50:16,260
that the lifetime profile addresses two

00:50:15,390 --> 00:50:19,500
of those things

00:50:16,260 --> 00:50:21,630
pretty directly how does it simplify C+

00:50:19,500 --> 00:50:25,140
code this code to make it easier to read

00:50:21,630 --> 00:50:26,910
write debug maintain well this analysis

00:50:25,140 --> 00:50:29,579
gets rid of a whole item and effective

00:50:26,910 --> 00:50:32,519
STL and it gets rid of classes of errors

00:50:29,579 --> 00:50:35,430
that if we just could assume that people

00:50:32,519 --> 00:50:37,980
didn't had on by default in their

00:50:35,430 --> 00:50:40,319
compilers as warnings we wouldn't need

00:50:37,980 --> 00:50:41,849
to teach her document we would most need

00:50:40,319 --> 00:50:44,670
to teach what you write instead when

00:50:41,849 --> 00:50:47,730
it's not obvious and by removing gotcha

00:50:44,670 --> 00:50:49,140
special cases classes of errors even

00:50:47,730 --> 00:50:51,420
though it's not trying to get all

00:50:49,140 --> 00:50:53,010
dangling errors but common classes of

00:50:51,420 --> 00:50:55,710
errors that we get over and over again

00:50:53,010 --> 00:50:57,329
in articles talks at this conference in

00:50:55,710 --> 00:51:00,059
code and Standards Committee mailings

00:50:57,329 --> 00:51:01,230
and just diagnose them we'll have so

00:51:00,059 --> 00:51:03,480
much more time to talk about better

00:51:01,230 --> 00:51:08,759
stuff and to move the language forward

00:51:03,480 --> 00:51:10,410
and to deliver solid code so for the

00:51:08,759 --> 00:51:12,450
rest of this talk let's talk about meta

00:51:10,410 --> 00:51:13,680
classes and this is a different kind of

00:51:12,450 --> 00:51:15,569
simplification we're going to switch

00:51:13,680 --> 00:51:17,250
gears and talk about simplifying class

00:51:15,569 --> 00:51:19,740
authoring and I first introduced that

00:51:17,250 --> 00:51:22,319
last year I talked about it here at CQ

00:51:19,740 --> 00:51:24,299
pecan and I want to thank Andrew Sutton

00:51:22,319 --> 00:51:26,759
and her are you around please stand up

00:51:24,299 --> 00:51:30,769
and wave who did the implementation in

00:51:26,759 --> 00:51:30,769
clang together with Jennifer and Wyatt

00:51:31,160 --> 00:51:35,099
like to thank Jennifer and Wyatt -

00:51:33,480 --> 00:51:37,049
they're not in the room today but we

00:51:35,099 --> 00:51:41,579
thank them very much also is matt god

00:51:37,049 --> 00:51:44,940
bolt in the room where are you Matt here

00:51:41,579 --> 00:51:48,710
Matt don't weeks keep standing don't we

00:51:44,940 --> 00:51:48,710
all want to thank Matt God Bowl

00:51:49,990 --> 00:51:57,050
and in particular for hosting this

00:51:54,920 --> 00:51:59,090
implementation for us that CPX dodd

00:51:57,050 --> 00:52:01,990
vault or the metaclasses implementation

00:51:59,090 --> 00:52:04,280
for the past year-plus so thank you so

00:52:01,990 --> 00:52:06,290
one of our goals over the past year this

00:52:04,280 --> 00:52:07,760
is a progress report this is a long lead

00:52:06,290 --> 00:52:09,920
item it's still in experiments and

00:52:07,760 --> 00:52:11,120
effort that could fail I sure hope it

00:52:09,920 --> 00:52:14,420
doesn't because I see a lot of promise

00:52:11,120 --> 00:52:17,450
and here's the progress so far it has

00:52:14,420 --> 00:52:20,300
gotten into sg7 for several reviews in

00:52:17,450 --> 00:52:21,920
the committee in the study group sg7 on

00:52:20,300 --> 00:52:24,350
compile time programming and reflection

00:52:21,920 --> 00:52:25,850
and generation and I'll show you the

00:52:24,350 --> 00:52:29,330
feedback on the next slide it was

00:52:25,850 --> 00:52:30,830
largely syntactic but it had it helped

00:52:29,330 --> 00:52:33,760
us think about what we were doing better

00:52:30,830 --> 00:52:36,320
but the structure is still the same and

00:52:33,760 --> 00:52:38,180
the prototype now handles more of the

00:52:36,320 --> 00:52:40,310
examples last year handled about four of

00:52:38,180 --> 00:52:43,910
the examples in the paper now it handles

00:52:40,310 --> 00:52:46,280
more and I'll show a few but first in a

00:52:43,910 --> 00:52:50,540
nutshell remember the idea is the C++

00:52:46,280 --> 00:52:52,730
class this big Apple already is flexible

00:52:50,540 --> 00:52:55,430
enough to Express iterators traits

00:52:52,730 --> 00:52:58,660
properties flag enums base classes

00:52:55,430 --> 00:53:00,890
values irregular types of variants and

00:52:58,660 --> 00:53:04,730
they're all expressed with this

00:53:00,890 --> 00:53:06,260
wonderfully powerful class concept that

00:53:04,730 --> 00:53:09,470
is so powerful and flexible it can

00:53:06,260 --> 00:53:12,320
express all that the trouble is because

00:53:09,470 --> 00:53:14,570
we can't give a name to a subset of

00:53:12,320 --> 00:53:18,410
those that universe of classes we can't

00:53:14,570 --> 00:53:19,880
give a name to an iterator concepts help

00:53:18,410 --> 00:53:22,670
it helps us detect them it doesn't help

00:53:19,880 --> 00:53:24,890
us author them we don't get as much

00:53:22,670 --> 00:53:26,390
support for writing them making sure we

00:53:24,890 --> 00:53:27,740
wrote them correctly and so it tends to

00:53:26,390 --> 00:53:31,400
be brittle there tends to be TV is

00:53:27,740 --> 00:53:32,870
boilerplate we need to remember rules

00:53:31,400 --> 00:53:34,880
because the compiler doesn't enforce

00:53:32,870 --> 00:53:37,880
them we need to write functions that

00:53:34,880 --> 00:53:40,490
aren't generated the idea of meta

00:53:37,880 --> 00:53:42,350
classes is that many language features

00:53:40,490 --> 00:53:45,860
not all language features that we could

00:53:42,350 --> 00:53:49,490
imagine adding to C++ but the ones that

00:53:45,860 --> 00:53:52,190
are about kinds of classes those future

00:53:49,490 --> 00:53:53,840
language features I hope that we never

00:53:52,190 --> 00:53:55,010
need to standardized because I would

00:53:53,840 --> 00:53:59,750
like to be able to write them as

00:53:55,010 --> 00:54:01,700
libraries that is the very high goal

00:53:59,750 --> 00:54:04,420
that we're going for here

00:54:01,700 --> 00:54:07,010
and with no loss of usability

00:54:04,420 --> 00:54:09,260
expressiveness diagnostic quality or

00:54:07,010 --> 00:54:11,000
performance compared even to other

00:54:09,260 --> 00:54:12,440
languages who wired them right into

00:54:11,000 --> 00:54:14,630
their language and I gave some demos

00:54:12,440 --> 00:54:16,520
last year to support that if you think

00:54:14,630 --> 00:54:18,589
that's a high bar please watch the demos

00:54:16,520 --> 00:54:20,059
from last year but I'm going to give you

00:54:18,589 --> 00:54:23,780
a quick update and then show you new

00:54:20,059 --> 00:54:26,299
examples when you're writing a meta

00:54:23,780 --> 00:54:27,920
class the left-hand side was last year

00:54:26,299 --> 00:54:30,200
syntax the right-hand side is this

00:54:27,920 --> 00:54:34,010
year's syntax and the main difference is

00:54:30,200 --> 00:54:36,319
in the wrapping so the body is still the

00:54:34,010 --> 00:54:38,960
same so the concept is still the same

00:54:36,319 --> 00:54:41,630
the structure but instead of the idea of

00:54:38,960 --> 00:54:44,180
oh I'm sort of mentally inside the class

00:54:41,630 --> 00:54:48,559
I'm writing and I'm reading my own

00:54:44,180 --> 00:54:50,990
definitions and modifying them now the

00:54:48,559 --> 00:54:53,180
view is no I take a fully-formed

00:54:50,990 --> 00:54:56,359
class whatever the user wrote in source

00:54:53,180 --> 00:54:58,640
code as input and I generate wherever I

00:54:56,359 --> 00:55:00,829
am things from that and that could be I

00:54:58,640 --> 00:55:03,079
copy each item it could be I do some

00:55:00,829 --> 00:55:04,819
validations but the main thing is that

00:55:03,079 --> 00:55:06,140
you'll notice that at the bottom of the

00:55:04,819 --> 00:55:09,530
right hand side that we might now

00:55:06,140 --> 00:55:11,299
generate explicitly generate things that

00:55:09,530 --> 00:55:13,069
were implicit before I think this is an

00:55:11,299 --> 00:55:14,599
improvement but the structure is still

00:55:13,069 --> 00:55:16,790
the same but that's the new syntax to

00:55:14,599 --> 00:55:19,099
get used to and little probably tweak

00:55:16,790 --> 00:55:22,190
again but that was the commitee syntax

00:55:19,099 --> 00:55:24,109
feedback that and I appreciated it the

00:55:22,190 --> 00:55:26,869
other was when using a matter class to

00:55:24,109 --> 00:55:28,760
define your own type so on the left hand

00:55:26,869 --> 00:55:32,059
side was last year the right hand side

00:55:28,760 --> 00:55:34,220
is this year the committee really really

00:55:32,059 --> 00:55:36,319
wanted to see the keyword class up front

00:55:34,220 --> 00:55:37,730
and there are parsing benefits to that

00:55:36,319 --> 00:55:39,260
we could still parse the other one but

00:55:37,730 --> 00:55:41,660
there are definitely parsing benefits

00:55:39,260 --> 00:55:43,640
and also by having interface and parens

00:55:41,660 --> 00:55:45,380
you can have a comma list and have more

00:55:43,640 --> 00:55:48,829
things there it becomes easier to

00:55:45,380 --> 00:55:52,130
express multiple meta classes but that's

00:55:48,829 --> 00:55:55,220
the change to applying a meta class so

00:55:52,130 --> 00:55:56,809
now let's see some examples in each case

00:55:55,220 --> 00:55:58,190
I'm going to show the example the way I

00:55:56,809 --> 00:56:00,410
teach you today every single one of

00:55:58,190 --> 00:56:01,490
these as examples I already teach and

00:56:00,410 --> 00:56:03,980
you might have been in a course where

00:56:01,490 --> 00:56:06,020
I've taught it so I will very quickly

00:56:03,980 --> 00:56:07,549
give you a condensed version of what it

00:56:06,020 --> 00:56:08,059
is we're trying to accomplish how we do

00:56:07,549 --> 00:56:09,950
it today

00:56:08,059 --> 00:56:13,309
and then we'll look at how the meta

00:56:09,950 --> 00:56:15,080
classes help us associating data with

00:56:13,309 --> 00:56:19,250
logs how many of you have ever

00:56:15,080 --> 00:56:21,500
in a race condition so we forget to take

00:56:19,250 --> 00:56:22,250
a lock or we took a lock but oh it was

00:56:21,500 --> 00:56:25,040
the wrong one

00:56:22,250 --> 00:56:28,550
oopsie that one passes code review more

00:56:25,040 --> 00:56:30,140
often so here is the pattern and I'm

00:56:28,550 --> 00:56:32,330
gonna blow through this fairly quickly

00:56:30,140 --> 00:56:34,580
but the main thing is to get this sense

00:56:32,330 --> 00:56:37,730
of what we're asking people to do if we

00:56:34,580 --> 00:56:39,500
knew if we grouped the mutex at the

00:56:37,730 --> 00:56:44,420
bottom and the data it protects together

00:56:39,500 --> 00:56:46,130
in the same class or struct now we could

00:56:44,420 --> 00:56:48,350
give instrumentation to figure out oh I

00:56:46,130 --> 00:56:51,290
now know that mutex goes with that data

00:56:48,350 --> 00:56:53,420
I could do things like assert the mutex

00:56:51,290 --> 00:56:55,160
is held before I access the data right

00:56:53,420 --> 00:56:58,400
an access er around the data and assert

00:56:55,160 --> 00:57:00,740
the mutex is held the middle three lines

00:56:58,400 --> 00:57:03,170
are boilerplate because they follow the

00:57:00,740 --> 00:57:04,370
locking the concept or the mutex concept

00:57:03,170 --> 00:57:06,170
in the standard library just like the

00:57:04,370 --> 00:57:09,170
container concept is you have begin and

00:57:06,170 --> 00:57:12,080
value type the mutex concept is you have

00:57:09,170 --> 00:57:14,480
lock try lock unlock so we write those

00:57:12,080 --> 00:57:16,430
two just so that the user can then take

00:57:14,480 --> 00:57:20,210
a my data object and do a lot guard on

00:57:16,430 --> 00:57:21,860
it directly so this works fine but man

00:57:20,210 --> 00:57:26,240
that's a lot of boilerplate to write by

00:57:21,860 --> 00:57:27,980
hand now if I was going to automate this

00:57:26,240 --> 00:57:30,260
the first thing I need to do notice I

00:57:27,980 --> 00:57:32,300
assert the mutex is held

00:57:30,260 --> 00:57:35,690
turns out the standard mutex doesn't

00:57:32,300 --> 00:57:38,090
have that function so we could wrap if

00:57:35,690 --> 00:57:40,130
we want to make a mutex testable

00:57:38,090 --> 00:57:42,830
basically what you do is you put a mutex

00:57:40,130 --> 00:57:44,990
and a thread ID together and then you

00:57:42,830 --> 00:57:47,120
can provide your lock try lock unlock

00:57:44,990 --> 00:57:49,370
every time you lock you record the

00:57:47,120 --> 00:57:51,950
thread that held it and when you unlock

00:57:49,370 --> 00:57:54,980
you reset it to the default and then you

00:57:51,950 --> 00:57:56,450
can say is held so this is a helper I'm

00:57:54,980 --> 00:57:58,700
going to use it's a little wrapper you

00:57:56,450 --> 00:58:02,690
write if your mutex doesn't already have

00:57:58,700 --> 00:58:06,200
and is held function and then I always

00:58:02,690 --> 00:58:09,740
have to apologize for the next slide

00:58:06,200 --> 00:58:12,200
I apologize for very few things in C++

00:58:09,740 --> 00:58:13,580
because I love this language but what's

00:58:12,200 --> 00:58:19,069
the thing we always have to apologize

00:58:13,580 --> 00:58:23,809
for starts with M

00:58:19,069 --> 00:58:26,509
macros so I always start with sorry for

00:58:23,809 --> 00:58:28,519
the macros but and yes there are ways

00:58:26,509 --> 00:58:30,469
you could write this in a different way

00:58:28,519 --> 00:58:31,809
that could avoid the macros but I don't

00:58:30,469 --> 00:58:34,819
believe you can write it and

00:58:31,809 --> 00:58:37,069
conveniently without macros because in

00:58:34,819 --> 00:58:38,509
in this way because I want to write the

00:58:37,069 --> 00:58:40,999
code at bottom I wanted right here's my

00:58:38,509 --> 00:58:42,979
struct my data it's guarded with mutex

00:58:40,999 --> 00:58:45,680
type it has a guarded member vector int

00:58:42,979 --> 00:58:49,880
a type vector in named V and so forth

00:58:45,680 --> 00:58:51,709
and in that guarded member I have to

00:58:49,880 --> 00:58:53,209
refer to I first of all I have to use

00:58:51,709 --> 00:58:56,059
token pasting to make a different member

00:58:53,209 --> 00:58:57,380
name for the private member then for the

00:58:56,059 --> 00:58:59,269
access or otherwise I got to have the

00:58:57,380 --> 00:59:00,890
user at the bottom was specify two names

00:58:59,269 --> 00:59:02,180
just so that one is the public name and

00:59:00,890 --> 00:59:04,880
one's the private name which is a key

00:59:02,180 --> 00:59:08,089
but also inside the macro I have to then

00:59:04,880 --> 00:59:11,269
refer to the mutex that I declared

00:59:08,089 --> 00:59:13,459
earlier so this is what we do today it's

00:59:11,269 --> 00:59:15,619
what I've been teaching after the class

00:59:13,459 --> 00:59:17,150
half the time people somebody comes up

00:59:15,619 --> 00:59:19,160
and says here's how I think you could

00:59:17,150 --> 00:59:20,749
write this without the macro but it's a

00:59:19,160 --> 00:59:23,509
different design that's also a decent

00:59:20,749 --> 00:59:26,150
design but it's not this one I really

00:59:23,509 --> 00:59:28,069
would like not to write the macro but

00:59:26,150 --> 00:59:31,160
let me motivate why it's still worth it

00:59:28,069 --> 00:59:32,509
today and by the way we're never likely

00:59:31,160 --> 00:59:34,759
to standardize a special-purpose

00:59:32,509 --> 00:59:38,630
language feature here in the standard so

00:59:34,759 --> 00:59:40,789
this is today's status quo here's why

00:59:38,630 --> 00:59:45,019
it's good now imagine I have a my data

00:59:40,789 --> 00:59:48,709
object two of them data 1 data 2 when I

00:59:45,019 --> 00:59:50,509
call data 1 dot V dot push back soon as

00:59:48,709 --> 00:59:52,430
I call data 1 dot V what's the very

00:59:50,509 --> 00:59:55,849
first thing that happens in the body of

00:59:52,430 --> 00:59:58,430
that access or function a certain mutex

00:59:55,849 --> 01:00:00,170
is held here I didn't lock it so I

00:59:58,430 --> 01:00:02,180
getting a green line because it will

01:00:00,170 --> 01:00:04,519
fail that's green because failure here

01:00:02,180 --> 01:00:07,400
is good that's exactly what I wanted at

01:00:04,519 --> 01:00:09,799
test time the first time I ever

01:00:07,400 --> 01:00:13,459
exercised that line of code in a unit

01:00:09,799 --> 01:00:15,529
test I will get an assertion that is way

01:00:13,459 --> 01:00:18,709
better than a random hard to reproduce

01:00:15,529 --> 01:00:20,209
bug report from a customer site very

01:00:18,709 --> 01:00:22,699
first time I go through that first green

01:00:20,209 --> 01:00:25,729
line at test time I will get the

01:00:22,699 --> 01:00:27,829
assertion same thing on data 2w first

01:00:25,729 --> 01:00:31,130
thing it does is isn't that mutex health

01:00:27,829 --> 01:00:31,900
data two's mutex answer is no I assert

01:00:31,130 --> 01:00:34,779
great

01:00:31,900 --> 01:00:36,460
just caught 2 race conditions so let's

01:00:34,779 --> 01:00:38,020
say I comment those lines out and I go

01:00:36,460 --> 01:00:40,630
into the block and now I have that nice

01:00:38,020 --> 01:00:42,700
yellow lock guard line notice I'm using

01:00:40,630 --> 01:00:47,109
a lock guard on my data because it has

01:00:42,700 --> 01:00:52,270
locked tri lock unlock now I say data 1

01:00:47,109 --> 01:00:55,180
dot V very first thing it does is his

01:00:52,270 --> 01:00:58,059
data one's mutex held the answer is true

01:00:55,180 --> 01:01:01,869
off we go and the pushback is is

01:00:58,059 --> 01:01:05,109
perfectly fine then I say data 2w the

01:01:01,869 --> 01:01:09,809
very first thing it asks is is data

01:01:05,109 --> 01:01:13,450
two's mutex held now I have taken a lock

01:01:09,809 --> 01:01:16,569
but not on that new tax that assertion

01:01:13,450 --> 01:01:18,329
will correctly fire and again that green

01:01:16,569 --> 01:01:21,010
line will get an assertion

01:01:18,329 --> 01:01:23,980
deterministically at test time the first

01:01:21,010 --> 01:01:26,079
time I exercise that code and I cannot

01:01:23,980 --> 01:01:29,710
say how much better that is that a

01:01:26,079 --> 01:01:31,690
timing dependent race the one thing you

01:01:29,710 --> 01:01:33,520
shouldn't do is take that sneaky pointer

01:01:31,690 --> 01:01:36,160
while you've got the lock access it

01:01:33,520 --> 01:01:37,599
store a pointer to it release the lock

01:01:36,160 --> 01:01:44,049
and then use the pointer I can't detect

01:01:37,599 --> 01:01:47,319
that fire that person but I can detect

01:01:44,049 --> 01:01:49,000
Murphy maybe not Machiavelli but I can

01:01:47,319 --> 01:01:52,270
detect Murphy so this is a valuable

01:01:49,000 --> 01:01:53,020
idiom but it makes me cry because it is

01:01:52,270 --> 01:01:54,490
so valuable

01:01:53,020 --> 01:01:56,109
I teach back rows even though I need

01:01:54,490 --> 01:01:59,099
macro I show it even though I need

01:01:56,109 --> 01:02:01,359
macros to teach it which is embarrassing

01:01:59,099 --> 01:02:03,190
so on the left hand side is what we

01:02:01,359 --> 01:02:05,619
write either by hand or at the bottom

01:02:03,190 --> 01:02:07,480
with macros with the metaclasses

01:02:05,619 --> 01:02:10,180
proposal you can wrap all this up and

01:02:07,480 --> 01:02:11,859
there's a live god bolt example that I'm

01:02:10,180 --> 01:02:13,569
going to post in the paper when it gets

01:02:11,859 --> 01:02:15,789
updated for the standard for the next

01:02:13,569 --> 01:02:17,890
mailing and it'll also show these

01:02:15,789 --> 01:02:20,109
examples on my blog over the coming a

01:02:17,890 --> 01:02:22,990
few weeks and months but I'll show you

01:02:20,109 --> 01:02:26,260
the code today it's a class it's guarded

01:02:22,990 --> 01:02:28,359
with mutex type and I just say what the

01:02:26,260 --> 01:02:30,099
members are I use natural syntax not

01:02:28,359 --> 01:02:32,020
like the macros which are macros plus

01:02:30,099 --> 01:02:34,359
they don't let us use natural syntax and

01:02:32,020 --> 01:02:38,049
I just generate what's on the left hand

01:02:34,359 --> 01:02:41,770
side I can directly express intent and

01:02:38,049 --> 01:02:44,680
that makes their code simpler because

01:02:41,770 --> 01:02:45,670
they can utter a word of power and we

01:02:44,680 --> 01:02:47,319
have enabled them with net

01:02:45,670 --> 01:02:49,150
classes to write the word of power

01:02:47,319 --> 01:02:53,190
guarded by the way did you notice this

01:02:49,150 --> 01:02:56,650
is a templatized meta class let's see

01:02:53,190 --> 01:02:59,470
so today the meta class is defined as

01:02:56,650 --> 01:03:01,390
template type tt source but here there's

01:02:59,470 --> 01:03:03,430
an additional template parameter M which

01:03:01,390 --> 01:03:04,960
is the mutex type so what I'm going to

01:03:03,430 --> 01:03:06,700
do and I'm showing part of the code

01:03:04,960 --> 01:03:07,839
there's a couple of other concepts for

01:03:06,700 --> 01:03:09,700
functions it calls that do similar

01:03:07,839 --> 01:03:12,790
things up above and you'll see that in

01:03:09,700 --> 01:03:16,299
the online example I first call a line

01:03:12,790 --> 01:03:18,309
51 guarded with M and what that does is

01:03:16,299 --> 01:03:23,520
it generates lock try lock unlock and

01:03:18,309 --> 01:03:27,309
the mutex of type m then for every

01:03:23,520 --> 01:03:28,869
member variable i do a guarded member of

01:03:27,309 --> 01:03:31,569
its type and its name that is not a

01:03:28,869 --> 01:03:34,510
macro anymore rather guarded member

01:03:31,569 --> 01:03:37,089
creates an accessor and a private

01:03:34,510 --> 01:03:39,790
variable with a suffix name which I can

01:03:37,089 --> 01:03:42,460
do without macros now with generation

01:03:39,790 --> 01:03:44,200
and I create one of those for every

01:03:42,460 --> 01:03:45,250
member that creates the accessors and

01:03:44,200 --> 01:03:47,619
you see them on the right-hand side

01:03:45,250 --> 01:03:50,410
where I create the accessor for V and

01:03:47,619 --> 01:03:54,700
for W and the private members and I even

01:03:50,410 --> 01:03:56,380
have a compiler diagnostic which at

01:03:54,700 --> 01:03:59,680
compile time if somebody tries to make a

01:03:56,380 --> 01:04:02,130
guarded class that has no data members I

01:03:59,680 --> 01:04:04,089
can give them a high quality diagnostic

01:04:02,130 --> 01:04:07,480
because why did you guard something

01:04:04,089 --> 01:04:09,339
that's empty and then I use it in line

01:04:07,480 --> 01:04:12,099
70 at the bottom all I write is class

01:04:09,339 --> 01:04:12,549
guarded stood mutex the same code I just

01:04:12,099 --> 01:04:16,869
showed you

01:04:12,549 --> 01:04:18,700
compiles to that today this works and I

01:04:16,869 --> 01:04:20,950
didn't need a language feature to do it

01:04:18,700 --> 01:04:23,410
reflection and generation is powerful

01:04:20,950 --> 01:04:25,450
what's even more powerful is with the

01:04:23,410 --> 01:04:28,540
metaclass being able to give a name to a

01:04:25,450 --> 01:04:32,200
bundle of those things and reuse them

01:04:28,540 --> 01:04:34,869
and so here's what we use so I would say

01:04:32,200 --> 01:04:36,640
if you hate macros you have a good

01:04:34,869 --> 01:04:39,010
reason to love metaclasses and I hope

01:04:36,640 --> 01:04:41,500
you do and if we're serious about

01:04:39,010 --> 01:04:43,240
whether people happen to like meta

01:04:41,500 --> 01:04:45,309
classes immediately today or not if

01:04:43,240 --> 01:04:47,710
you're serious about getting rid of the

01:04:45,309 --> 01:04:50,710
remaining reasonable use of macros and I

01:04:47,710 --> 01:04:52,599
am then you are going to love modules

01:04:50,710 --> 01:04:53,859
you're going to love contacts fur and

01:04:52,599 --> 01:04:57,099
you're going to love reflection and

01:04:53,859 --> 01:04:59,170
generation at least I happen to think

01:04:57,099 --> 01:05:01,000
that you will

01:04:59,170 --> 01:05:02,890
already if not soon also love

01:05:01,000 --> 01:05:04,000
metaclasses to be able to do this kind

01:05:02,890 --> 01:05:06,490
of thing because now I don't need to

01:05:04,000 --> 01:05:10,569
teach that macro anymore if we have a

01:05:06,490 --> 01:05:12,400
standard way of doing this and you might

01:05:10,569 --> 01:05:13,960
have noticed that today when we talk

01:05:12,400 --> 01:05:16,589
about patterns we talk about cookbooks

01:05:13,960 --> 01:05:18,700
that you apply by hand

01:05:16,589 --> 01:05:21,730
people have long said yeah patterns you

01:05:18,700 --> 01:05:26,020
can't make those to be libraries oh yes

01:05:21,730 --> 01:05:29,530
you can let's talk about another pattern

01:05:26,020 --> 01:05:31,359
and make it a library active objects

01:05:29,530 --> 01:05:35,819
first let me give you the motivation how

01:05:31,359 --> 01:05:38,890
we teach it today threads are our

01:05:35,819 --> 01:05:40,359
low-level way of doing concurrency is

01:05:38,890 --> 01:05:42,790
the only way in the standard really

01:05:40,359 --> 01:05:44,619
right now but threads are too low-level

01:05:42,790 --> 01:05:46,630
there are no guardrails they can do just

01:05:44,619 --> 01:05:48,369
anything in their execution and their

01:05:46,630 --> 01:05:51,250
communication is with shared state by

01:05:48,369 --> 01:05:55,420
default and that's just terrible so we

01:05:51,250 --> 01:05:57,309
teach discipline your threads make when

01:05:55,420 --> 01:05:58,720
you write a thread this isn't for every

01:05:57,309 --> 01:06:02,049
use case but it's for the vast majority

01:05:58,720 --> 01:06:03,670
of them right your thread main line is a

01:06:02,049 --> 01:06:05,589
message pump that just accepts

01:06:03,670 --> 01:06:08,160
asynchronous messages and does them one

01:06:05,589 --> 01:06:10,030
at a time which means it needs no other

01:06:08,160 --> 01:06:11,260
synchronization on its internal shared

01:06:10,030 --> 01:06:14,680
state because it's only pumping

01:06:11,260 --> 01:06:17,140
executing one message at a time and then

01:06:14,680 --> 01:06:20,170
communicate by sending it async messages

01:06:17,140 --> 01:06:21,849
and make them well formatted hint we'd

01:06:20,170 --> 01:06:24,819
love to use the type system such as say

01:06:21,849 --> 01:06:27,160
a function signature that's statically a

01:06:24,819 --> 01:06:29,230
well formatted message a member function

01:06:27,160 --> 01:06:32,470
signature is a statically well formatted

01:06:29,230 --> 01:06:33,940
type safe message and there are various

01:06:32,470 --> 01:06:36,160
options here I'm just going to show a

01:06:33,940 --> 01:06:38,440
very basic option you could do this with

01:06:36,160 --> 01:06:41,200
co-routines you could use a series of

01:06:38,440 --> 01:06:43,240
tasks on a thread pool you can use a

01:06:41,200 --> 01:06:44,859
priority queue multiple channels I'm

01:06:43,240 --> 01:06:47,890
just going to show an actual thread with

01:06:44,859 --> 01:06:50,140
one queue and I'm pretty sure that most

01:06:47,890 --> 01:06:51,670
people here is seeing that can then

01:06:50,140 --> 01:06:56,109
write the advanced examples pretty

01:06:51,670 --> 01:06:59,079
quickly by ourselves but let's see how

01:06:56,109 --> 01:07:01,059
to do the basic example and understand

01:06:59,079 --> 01:07:03,849
that in C++ we were never going to

01:07:01,059 --> 01:07:06,520
standardize something as narrow as an

01:07:03,849 --> 01:07:10,240
active async class I don't see that ever

01:07:06,520 --> 01:07:12,130
happening like somebody proposes a class

01:07:10,240 --> 01:07:12,920
where every member function call is

01:07:12,130 --> 01:07:15,140
asynchronous and

01:07:12,920 --> 01:07:16,900
automatically returns a future it's

01:07:15,140 --> 01:07:19,130
useful but it's too narrow or feature

01:07:16,900 --> 01:07:22,940
this isn't the language we would do that

01:07:19,130 --> 01:07:24,500
in we like general features so we

01:07:22,940 --> 01:07:27,230
encapsulate a thread in the message

01:07:24,500 --> 01:07:28,880
queue we want to write code like this

01:07:27,230 --> 01:07:31,760
where we have a class worker that's

01:07:28,880 --> 01:07:34,790
coded specially somehow and when in the

01:07:31,760 --> 01:07:37,490
bottom that we invoke it a function we

01:07:34,790 --> 01:07:39,020
actually get a future and then we can do

01:07:37,490 --> 01:07:40,970
other work concurrently while we wait on

01:07:39,020 --> 01:07:45,830
it so every member function call is

01:07:40,970 --> 01:07:47,630
asynchronous in returns immediately we

01:07:45,830 --> 01:07:49,340
want to directly Express all these

01:07:47,630 --> 01:07:51,590
different kinds of things long-running

01:07:49,340 --> 01:07:53,270
workers like a GUI thread decoupled

01:07:51,590 --> 01:07:57,560
independent work like will see pipeline

01:07:53,270 --> 01:07:59,660
stages in a moment so here's the key

01:07:57,560 --> 01:08:02,780
thing we want to do we want to attach

01:07:59,660 --> 01:08:05,690
thread lifetime to object lifetime

01:08:02,780 --> 01:08:09,020
because C++ knows all about object

01:08:05,690 --> 01:08:12,230
lifetimes the way we do it is we teach

01:08:09,020 --> 01:08:13,850
it the way C++ knows knows it which is

01:08:12,230 --> 01:08:16,490
hook the constructor and the destructor

01:08:13,850 --> 01:08:18,830
so the constructor starts the thread and

01:08:16,490 --> 01:08:21,290
the message pump the destructor sends a

01:08:18,830 --> 01:08:25,670
done signal and then waits for the cue

01:08:21,290 --> 01:08:28,090
to drain and then joins you'll see in a

01:08:25,670 --> 01:08:30,890
moment how that directly lets us Express

01:08:28,090 --> 01:08:32,990
object lifetimes in a clean way in the

01:08:30,890 --> 01:08:36,410
real code but here's a starter example

01:08:32,990 --> 01:08:39,200
if once I've done that I can have a

01:08:36,410 --> 01:08:41,330
nested class inside so two active

01:08:39,200 --> 01:08:43,610
classes one nested inside the other and

01:08:41,330 --> 01:08:45,590
then when I instantiate the outer one

01:08:43,610 --> 01:08:47,660
and when I destroy it I naturally by

01:08:45,590 --> 01:08:49,310
construction wait for the inner one to

01:08:47,660 --> 01:08:50,810
destroy first because I automatically

01:08:49,310 --> 01:08:53,570
destroy it the language gives me that

01:08:50,810 --> 01:08:55,490
thank you PR on it it sends the done

01:08:53,570 --> 01:08:58,520
message for the internal active thread

01:08:55,490 --> 01:09:00,710
two waits for it to drain its queue then

01:08:58,520 --> 01:09:02,390
returns and then I do the destructor for

01:09:00,710 --> 01:09:05,750
the enclosing object which sends the

01:09:02,390 --> 01:09:08,810
done signal for it and so I've expressed

01:09:05,750 --> 01:09:10,610
nested concurrency really simply using

01:09:08,810 --> 01:09:13,520
existing concepts in the language and

01:09:10,610 --> 01:09:16,220
this is really powerful so how do I

01:09:13,520 --> 01:09:19,340
write this pattern or make it easy for

01:09:16,220 --> 01:09:21,710
people to write it here's a helper class

01:09:19,340 --> 01:09:23,930
so a message is just a function that

01:09:21,710 --> 01:09:26,210
takes in returns boy just something

01:09:23,930 --> 01:09:30,130
executable

01:09:26,210 --> 01:09:33,080
my constructor starts the message queue

01:09:30,130 --> 01:09:36,680
and it starts the starts the message

01:09:33,080 --> 01:09:38,630
pump while not done MQ receive paren

01:09:36,680 --> 01:09:41,030
paren get the next message

01:09:38,630 --> 01:09:43,460
and then notice paren paren immediately

01:09:41,030 --> 01:09:46,640
invoke it there's two sets of friends

01:09:43,460 --> 01:09:49,430
there that's not a typo and that's it

01:09:46,640 --> 01:09:53,540
that's the message pump the destructor

01:09:49,430 --> 01:09:56,180
sends done equals true as a message so

01:09:53,540 --> 01:09:57,950
when that message is executed on the

01:09:56,180 --> 01:09:59,420
third on that thread it says done equals

01:09:57,950 --> 01:10:00,800
true and then on its next trip through

01:09:59,420 --> 01:10:04,430
the loop it says oh look that is true

01:10:00,800 --> 01:10:06,950
and exits so we're sending the message

01:10:04,430 --> 01:10:10,520
that will cause the thread the worker

01:10:06,950 --> 01:10:12,200
thread the message pump to finish in

01:10:10,520 --> 01:10:14,900
order once it's drained all previous

01:10:12,200 --> 01:10:17,240
messages first then we just join and

01:10:14,900 --> 01:10:20,600
wait for that to happen and send is just

01:10:17,240 --> 01:10:22,940
a wrapper for and queuing a message so

01:10:20,600 --> 01:10:25,790
that's the basic model now let's say we

01:10:22,940 --> 01:10:29,630
use that too on the right hand side

01:10:25,790 --> 01:10:31,820
right a logger class that's thread safe

01:10:29,630 --> 01:10:34,730
it's safe to call externally without

01:10:31,820 --> 01:10:36,290
external synchronization whereas on the

01:10:34,730 --> 01:10:39,080
left-hand side the old way we would do

01:10:36,290 --> 01:10:41,810
it would be with a mutex and we take a

01:10:39,080 --> 01:10:43,430
lock inside every call to the print line

01:10:41,810 --> 01:10:45,770
function so the calling code is

01:10:43,430 --> 01:10:49,960
identical the the calling code is my log

01:10:45,770 --> 01:10:51,830
dot print line hello present one name

01:10:49,960 --> 01:10:53,780
what's the difference between those two

01:10:51,830 --> 01:10:58,420
just shout out any differences that you

01:10:53,780 --> 01:11:01,190
see and how they work

01:10:58,420 --> 01:11:02,350
left ones synchronous yes so what's the

01:11:01,190 --> 01:11:07,780
right one

01:11:02,350 --> 01:11:07,780
asynchronous which is more scalable

01:11:07,810 --> 01:11:14,540
right hand one why well because on the

01:11:12,950 --> 01:11:15,940
on the right hand one does the caller

01:11:14,540 --> 01:11:18,440
ever block

01:11:15,940 --> 01:11:20,740
no caller never blocks now what are we

01:11:18,440 --> 01:11:23,000
doing we're trading off space for time

01:11:20,740 --> 01:11:24,950
but couldn't queue up messages who are

01:11:23,000 --> 01:11:27,170
going to use space in order to get that

01:11:24,950 --> 01:11:31,040
concurrency but the right-hand side is

01:11:27,170 --> 01:11:34,790
non blocking and so it'll scale better

01:11:31,040 --> 01:11:37,250
and the the left-hand side works fine

01:11:34,790 --> 01:11:38,780
but it also does all the work on the

01:11:37,250 --> 01:11:39,019
callers thread the other thing that nice

01:11:38,780 --> 01:11:41,510
thing

01:11:39,019 --> 01:11:43,249
about the right hand side is all the

01:11:41,510 --> 01:11:45,109
work has done inside the active object

01:11:43,249 --> 01:11:48,379
worker threat so not only is the caller

01:11:45,109 --> 01:11:50,959
not blocked they're also pushing more

01:11:48,379 --> 01:11:53,329
work off their thread because the actual

01:11:50,959 --> 01:11:55,849
formatting in the right hand side is

01:11:53,329 --> 01:11:58,969
done on the worker thread and so then

01:11:55,849 --> 01:11:59,809
you need to to to load-balanced this and

01:11:58,969 --> 01:12:01,969
make sure you're doing the right thing

01:11:59,809 --> 01:12:03,739
for throttling and everything but in

01:12:01,969 --> 01:12:06,289
general there's a lot of things a lot to

01:12:03,739 --> 01:12:08,029
like about the right-hand side and we

01:12:06,289 --> 01:12:11,029
can write this today and notice the

01:12:08,029 --> 01:12:13,359
pattern you make active your last member

01:12:11,029 --> 01:12:17,169
and then you write every member function

01:12:13,359 --> 01:12:19,849
you wrap its body in an a dot send lamda

01:12:17,169 --> 01:12:23,329
that's what we teach people today as the

01:12:19,849 --> 01:12:27,079
convenient way to write this now let's

01:12:23,329 --> 01:12:28,549
say that we have a typical pipeline so

01:12:27,079 --> 01:12:29,959
here's an example I give a class and

01:12:28,549 --> 01:12:31,579
basically what they have to do is they

01:12:29,959 --> 01:12:34,879
have to create a decorate thread a

01:12:31,579 --> 01:12:37,369
compress thread and an encrypted the

01:12:34,879 --> 01:12:39,079
decorator decorates a buffer puts it in

01:12:37,369 --> 01:12:42,109
a queue for the encrypt for the

01:12:39,079 --> 01:12:44,659
compressor which takes it compresses it

01:12:42,109 --> 01:12:47,029
and so forth so it's three pipeline

01:12:44,659 --> 01:12:49,909
stages each a thread connected by queues

01:12:47,029 --> 01:12:51,889
and so people take about a half an hour

01:12:49,909 --> 01:12:54,949
and they come up with a solution maybe

01:12:51,889 --> 01:12:56,749
20 minutes then I say now write it

01:12:54,949 --> 01:12:59,389
generically using active objects and

01:12:56,749 --> 01:13:02,049
then I show them this answer you just

01:12:59,389 --> 01:13:06,589
write a stage so here's a generic stage

01:13:02,049 --> 01:13:08,719
it's just going to take a function some

01:13:06,589 --> 01:13:10,399
function that takes a buffer star and

01:13:08,719 --> 01:13:11,959
does something with it I don't know what

01:13:10,399 --> 01:13:15,109
it does just so the thing that can take

01:13:11,959 --> 01:13:17,359
a buffer star and stores it then it has

01:13:15,109 --> 01:13:20,719
a process function which notice follows

01:13:17,359 --> 01:13:23,449
this asynchronous pattern and this is

01:13:20,719 --> 01:13:26,059
the message it's an asynchronous message

01:13:23,449 --> 01:13:28,699
that does whatever that work is on this

01:13:26,059 --> 01:13:30,649
buffer and then the private state is

01:13:28,699 --> 01:13:32,209
just it's stored its buffer that is

01:13:30,649 --> 01:13:33,799
stored its work function it's supposed

01:13:32,209 --> 01:13:35,599
to do and an active object at the end

01:13:33,799 --> 01:13:37,489
remember to put that one last if you

01:13:35,599 --> 01:13:40,129
don't put it last then the active

01:13:37,489 --> 01:13:43,309
threads main line starts before the

01:13:40,129 --> 01:13:44,809
function is constructed that you really

01:13:43,309 --> 01:13:46,939
really want to put that active object

01:13:44,809 --> 01:13:48,480
last always remember that with this

01:13:46,939 --> 01:13:51,190
pattern by hand

01:13:48,480 --> 01:13:52,600
as soon as I have this I construct it

01:13:51,190 --> 01:13:54,610
with a piece of work to do I have an

01:13:52,600 --> 01:13:57,070
async process message there just does it

01:13:54,610 --> 01:13:59,050
asynchronously and pumps the process

01:13:57,070 --> 01:14:01,300
message for everything every buffer

01:13:59,050 --> 01:14:03,190
pointer that it's given now I can write

01:14:01,300 --> 01:14:06,640
the whole solution in a few lines like

01:14:03,190 --> 01:14:08,980
this it's very clean I create a stage

01:14:06,640 --> 01:14:11,080
named and krypter and I give it a

01:14:08,980 --> 01:14:12,880
process function which simply says for

01:14:11,080 --> 01:14:15,700
any buffer you're given just encrypt it

01:14:12,880 --> 01:14:17,470
that's it I'm done pretty much no

01:14:15,700 --> 01:14:19,090
boilerplate there that's pretty much the

01:14:17,470 --> 01:14:23,620
exact statement of what the encrypter

01:14:19,090 --> 01:14:25,750
does the compressor takes a buffer

01:14:23,620 --> 01:14:27,730
pointer it compresses it and then sends

01:14:25,750 --> 01:14:29,860
it to the encrypter which it captured by

01:14:27,730 --> 01:14:30,970
reference and that's fine because these

01:14:29,860 --> 01:14:33,600
are nested lifetimes

01:14:30,970 --> 01:14:37,660
there's no dangling possible here and

01:14:33,600 --> 01:14:39,250
notice by construction i had to

01:14:37,660 --> 01:14:41,200
construct the objects in the right order

01:14:39,250 --> 01:14:42,880
i had to create the encrypter first

01:14:41,200 --> 01:14:44,160
because the compressor refers to it i

01:14:42,880 --> 01:14:46,930
can't write the code the wrong way

01:14:44,160 --> 01:14:48,430
because the compressor refers to the

01:14:46,930 --> 01:14:50,680
encrypter so of course i write at first

01:14:48,430 --> 01:14:53,530
that i do the same with a decorator the

01:14:50,680 --> 01:14:55,480
decorator is a stage which for each

01:14:53,530 --> 01:14:57,490
buffer decorates it and hands it to the

01:14:55,480 --> 01:14:59,170
compressor and then i simply called the

01:14:57,490 --> 01:15:01,990
decorator and send it the process

01:14:59,170 --> 01:15:03,610
message to fill up its queue and I've

01:15:01,990 --> 01:15:07,000
got this three-stage pipeline that runs

01:15:03,610 --> 01:15:11,650
and the cool part is at the end what do

01:15:07,000 --> 01:15:14,080
I destroy first decorator what does the

01:15:11,650 --> 01:15:16,780
destructor of decorator do it sends it

01:15:14,080 --> 01:15:19,660
in queues a done message for the

01:15:16,780 --> 01:15:21,250
decorator waits for the queue to drain

01:15:19,660 --> 01:15:22,750
so any decorations it was doing it waits

01:15:21,250 --> 01:15:24,700
for it to finish then it sees the done

01:15:22,750 --> 01:15:27,070
message joins and returns decorators

01:15:24,700 --> 01:15:28,810
done then it destroys compressor same

01:15:27,070 --> 01:15:31,210
thing sends that the done message waits

01:15:28,810 --> 01:15:32,650
for the queue to drain we're draining

01:15:31,210 --> 01:15:34,960
the pipeline in the right order

01:15:32,650 --> 01:15:37,210
naturally because reverse order of

01:15:34,960 --> 01:15:39,040
construction is what BR Ana saw was the

01:15:37,210 --> 01:15:39,460
right thing and has given us for 39

01:15:39,040 --> 01:15:43,150
years

01:15:39,460 --> 01:15:44,860
thank you bianna and then we join and

01:15:43,150 --> 01:15:46,270
then we destroy the encrypter we send it

01:15:44,860 --> 01:15:50,620
the done message wait for his queue to

01:15:46,270 --> 01:15:52,870
drain join and return and I have managed

01:15:50,620 --> 01:15:56,290
three worker thread lifetimes I've done

01:15:52,870 --> 01:15:58,570
orderly orderly setup and teardown I

01:15:56,290 --> 01:15:59,330
could not write it the wrong way to get

01:15:58,570 --> 01:16:02,260
in the wrong

01:15:59,330 --> 01:16:06,290
it's everything is clear by default I

01:16:02,260 --> 01:16:08,840
love C++ if you wrote this in Java you

01:16:06,290 --> 01:16:10,640
can do it but you are likely going to

01:16:08,840 --> 01:16:12,050
write the bug at the bottom where

01:16:10,640 --> 01:16:14,500
because you still have to setup the

01:16:12,050 --> 01:16:17,120
stages in order because the the

01:16:14,500 --> 01:16:20,600
encrypter has to refer to the compressor

01:16:17,120 --> 01:16:22,190
apps refer to the encrypter but you

01:16:20,600 --> 01:16:23,570
typically copy code and then destroy

01:16:22,190 --> 01:16:25,160
them in the same order which is wrong

01:16:23,570 --> 01:16:28,610
you have to destroy them in the opposite

01:16:25,160 --> 01:16:30,170
order Java fix this in 2014 with the try

01:16:28,610 --> 01:16:32,720
with resources statement which lets you

01:16:30,170 --> 01:16:37,250
approximate what C++ does with nested

01:16:32,720 --> 01:16:40,100
local lifetimes but just compare what we

01:16:37,250 --> 01:16:42,590
write in C++ this is just so clean and

01:16:40,100 --> 01:16:44,780
I've managed three thread lifetimes and

01:16:42,590 --> 01:16:47,840
set up a multi-stage queue and drained

01:16:44,780 --> 01:16:49,190
it cleanly and I can easily add

01:16:47,840 --> 01:16:51,560
flexibility what if I want to add

01:16:49,190 --> 01:16:53,000
another end stage archiver and the

01:16:51,560 --> 01:16:54,650
compressor sends some things to the

01:16:53,000 --> 01:16:57,050
encrypter some things to the archiver

01:16:54,650 --> 01:17:02,330
it's easy it's like three more lines of

01:16:57,050 --> 01:17:04,820
code very general very clean and correct

01:17:02,330 --> 01:17:07,160
by construction the only glitch is that

01:17:04,820 --> 01:17:09,320
today I have to write it by hand with an

01:17:07,160 --> 01:17:13,040
active metaclass I can just say class

01:17:09,320 --> 01:17:14,600
active stage and I can automatically

01:17:13,040 --> 01:17:16,940
make every non constructor non

01:17:14,600 --> 01:17:19,550
destructor be an asynchronous function

01:17:16,940 --> 01:17:21,680
now for process it returns void so it's

01:17:19,550 --> 01:17:23,300
actually pretty easy but I at least I

01:17:21,680 --> 01:17:24,920
already see a benefit here where I don't

01:17:23,300 --> 01:17:26,180
have to cut declare the active member I

01:17:24,920 --> 01:17:28,880
don't have to remember to declare it

01:17:26,180 --> 01:17:32,870
last I don't have to wrap every body in

01:17:28,880 --> 01:17:35,000
a member function and with the logger

01:17:32,870 --> 01:17:38,300
same thing we saw the logging example I

01:17:35,000 --> 01:17:40,580
can write that as an active class but

01:17:38,300 --> 01:17:45,860
how do I do this well let's walk through

01:17:40,580 --> 01:17:47,570
it briefly async says first of all echo

01:17:45,860 --> 01:17:49,880
all the data members for every data

01:17:47,570 --> 01:17:51,770
member there is generated because

01:17:49,880 --> 01:17:54,380
whatever the user wrote that's their

01:17:51,770 --> 01:17:57,230
data then for every member function

01:17:54,380 --> 01:17:59,500
remember it's return type if it's not a

01:17:57,230 --> 01:18:01,700
constructor and it's not a destructor

01:17:59,500 --> 01:18:03,140
we're gonna want to make it asynchronous

01:18:01,700 --> 01:18:06,590
because constructors and destructors are

01:18:03,140 --> 01:18:08,060
still synchronous so first thing we do

01:18:06,590 --> 01:18:12,599
is we make the one that the user wrote

01:18:08,060 --> 01:18:14,039
private then we generate a wrapper that

01:18:12,599 --> 01:18:17,609
notice at the bottom it creates a

01:18:14,039 --> 01:18:20,579
promise extracts a future and calls the

01:18:17,609 --> 01:18:23,129
original and does all that for you and

01:18:20,579 --> 01:18:25,590
then we generate the actual function

01:18:23,129 --> 01:18:28,469
itself and then I could write at the

01:18:25,590 --> 01:18:30,209
bottom class async test and there's my

01:18:28,469 --> 01:18:31,559
one function H and if we go back up

01:18:30,209 --> 01:18:32,939
you'll see all the stuff that was

01:18:31,559 --> 01:18:35,189
generated including the wrapper that

01:18:32,939 --> 01:18:37,019
takes the promise and this also

01:18:35,189 --> 01:18:39,719
illustrates so that's the whole code so

01:18:37,019 --> 01:18:41,280
far and that also illustrates how hard

01:18:39,719 --> 01:18:43,079
this is by hand because what I usually

01:18:41,280 --> 01:18:45,419
don't teach right up front in the talk

01:18:43,079 --> 01:18:47,879
and when I teach this class the active

01:18:45,419 --> 01:18:49,229
object method today I do teach it but I

01:18:47,879 --> 01:18:50,909
leave it at the end saying yeah and then

01:18:49,229 --> 01:18:54,090
what if you have to return a value oh

01:18:50,909 --> 01:18:55,979
yeah okay let's talk about promises and

01:18:54,090 --> 01:18:58,169
futures and how do how do you stood

01:18:55,979 --> 01:18:59,849
promise and here's how you do it and so

01:18:58,169 --> 01:19:01,889
you actually have to write all of the

01:18:59,849 --> 01:19:05,209
stuff on the left today for this pattern

01:19:01,889 --> 01:19:07,320
if you want to actually return something

01:19:05,209 --> 01:19:09,059
with the metaclass I just showed you you

01:19:07,320 --> 01:19:10,949
write class active and I'll just take

01:19:09,059 --> 01:19:12,889
that and that double get result just

01:19:10,949 --> 01:19:15,419
automatically returns a future and

01:19:12,889 --> 01:19:18,149
anybody who calls it Auto whatever

01:19:15,419 --> 01:19:19,679
equals get resolved gets a future it's

01:19:18,149 --> 01:19:22,649
just much cleaner and correct by

01:19:19,679 --> 01:19:24,300
destruction by construction haha and by

01:19:22,649 --> 01:19:27,780
the way we've been talking about this

01:19:24,300 --> 01:19:30,090
member data of active types that's

01:19:27,780 --> 01:19:32,429
really thread-local storage except with

01:19:30,090 --> 01:19:33,989
none of the overhead it's it's by

01:19:32,429 --> 01:19:36,959
construction thread-local but it's just

01:19:33,989 --> 01:19:38,849
normal allocation I kind of like that

01:19:36,959 --> 01:19:40,739
yeah joining threads for the wind

01:19:38,849 --> 01:19:42,389
thread-local storage by construction for

01:19:40,739 --> 01:19:48,179
the wind don't need special language

01:19:42,389 --> 01:19:51,079
features finally property how many you

01:19:48,179 --> 01:19:53,909
use properties in C++

01:19:51,079 --> 01:19:56,489
yeah a few hands even though they're not

01:19:53,909 --> 01:19:59,070
standard you are likely using a compiler

01:19:56,489 --> 01:20:01,439
that supports them it's been men

01:19:59,070 --> 01:20:03,989
invented many times and cute and

01:20:01,439 --> 01:20:05,849
Microsoft Borland even and clang because

01:20:03,989 --> 01:20:08,219
it has a microsoft mode and it also has

01:20:05,849 --> 01:20:10,919
support for other languages inside clang

01:20:08,219 --> 01:20:12,689
that do have properties and they're

01:20:10,919 --> 01:20:14,760
useful in practice and generally liked

01:20:12,689 --> 01:20:16,349
but every time they've been proposed for

01:20:14,760 --> 01:20:18,989
Standardization they've failed because

01:20:16,349 --> 01:20:20,849
it's a narrow language feature and the

01:20:18,989 --> 01:20:22,979
reality is this committee is just never

01:20:20,849 --> 01:20:24,869
going to standardize property as a

01:20:22,979 --> 01:20:26,550
language feature there's just too much

01:20:24,869 --> 01:20:28,929
debate about as a desire

01:20:26,550 --> 01:20:30,880
our language is already big enough do we

01:20:28,929 --> 01:20:32,800
really need that language feature does

01:20:30,880 --> 01:20:35,500
it carry its way which are reasonable

01:20:32,800 --> 01:20:37,710
things to ask the reality is we're just

01:20:35,500 --> 01:20:41,250
never going to get it in the language

01:20:37,710 --> 01:20:44,920
but what if we could write class like

01:20:41,250 --> 01:20:47,469
language features as libraries if we

01:20:44,920 --> 01:20:50,800
have generation and meta classes well

01:20:47,469 --> 01:20:52,270
today in c-sharp I can write this pardon

01:20:50,800 --> 01:20:54,520
for the c-sharp but it's just an example

01:20:52,270 --> 01:20:57,820
of another language with properties this

01:20:54,520 --> 01:21:00,010
is sort of a default version of a

01:20:57,820 --> 01:21:02,469
property where if you just write get and

01:21:00,010 --> 01:21:05,739
set forward declared it generates a data

01:21:02,469 --> 01:21:08,290
member of that type and and it a trivial

01:21:05,739 --> 01:21:10,060
get returned that member set set that

01:21:08,290 --> 01:21:14,440
member accessors for you because it's so

01:21:10,060 --> 01:21:15,670
common and you can with the

01:21:14,440 --> 01:21:19,060
implementation I'm about to show you

01:21:15,670 --> 01:21:20,739
right this today a very close to that

01:21:19,060 --> 01:21:22,300
syntax I have to put one extra word in

01:21:20,739 --> 01:21:25,270
but I think I can get rid of that next

01:21:22,300 --> 01:21:29,080
week thank you Andrew you can write

01:21:25,270 --> 01:21:31,030
class property of string empty braces so

01:21:29,080 --> 01:21:32,620
I'm I want all the defaults and I want

01:21:31,030 --> 01:21:35,440
to call it name I'll show you how that

01:21:32,620 --> 01:21:37,989
works in a moment but if in c-sharp you

01:21:35,440 --> 01:21:39,520
want to or in cute you want to have a

01:21:37,989 --> 01:21:41,199
non-trivial property you want to

01:21:39,520 --> 01:21:42,850
actually say what your data type is

01:21:41,199 --> 01:21:44,710
because maybe it's a compound data type

01:21:42,850 --> 01:21:47,110
and you want to write your own getting

01:21:44,710 --> 01:21:48,760
set function you can still do that we

01:21:47,110 --> 01:21:50,560
just won't generate the defaults for you

01:21:48,760 --> 01:21:53,320
if you actually wrote them so that's the

01:21:50,560 --> 01:21:55,989
model that we want to achieve here's how

01:21:53,320 --> 01:21:57,340
we do it so the property metaclass the

01:21:55,989 --> 01:21:58,960
very first thing it does is we're gonna

01:21:57,340 --> 01:22:01,600
say okay I need to remember whether

01:21:58,960 --> 01:22:04,360
there's a value member because I mean

01:22:01,600 --> 01:22:07,000
I'm going to use that later first thing

01:22:04,360 --> 01:22:10,719
in my for loop I'm going to go through

01:22:07,000 --> 01:22:12,969
all of the member variables here and I'm

01:22:10,719 --> 01:22:16,260
going to say is there name value if it

01:22:12,969 --> 01:22:20,110
is I'll set has value equals true and

01:22:16,260 --> 01:22:22,449
then I'm going to generate that so I'm

01:22:20,110 --> 01:22:23,530
going to echo whatever the data members

01:22:22,449 --> 01:22:26,219
are because there might be more than one

01:22:23,530 --> 01:22:29,530
if they wrote their own data members

01:22:26,219 --> 01:22:31,870
then for every member function I'm going

01:22:29,530 --> 01:22:33,670
to say was it get or was it set just

01:22:31,870 --> 01:22:35,230
because I'm now going to use that to

01:22:33,670 --> 01:22:36,760
give you them if you didn't write them

01:22:35,230 --> 01:22:39,030
yourself so I'll remember that but

01:22:36,760 --> 01:22:43,140
mostly I'm just going to generate

01:22:39,030 --> 01:22:44,580
myself and so I've been echo the

01:22:43,140 --> 01:22:47,520
functions that you wrote if you wrote

01:22:44,580 --> 01:22:49,530
them now in the case if there are no

01:22:47,520 --> 01:22:53,600
data members and there's no get function

01:22:49,530 --> 01:22:55,950
then I'm going to generate a value of

01:22:53,600 --> 01:22:58,500
that type so that's this handles the

01:22:55,950 --> 01:23:00,210
empty property case but this is just a

01:22:58,500 --> 01:23:02,250
compile time code right with reflection

01:23:00,210 --> 01:23:04,800
and generation I can write this if I

01:23:02,250 --> 01:23:07,440
reflect and I see there's no value I

01:23:04,800 --> 01:23:12,450
will generate a value and I'll remember

01:23:07,440 --> 01:23:14,070
has value equals true so so far I have

01:23:12,450 --> 01:23:16,440
echoed any functions and data they've

01:23:14,070 --> 01:23:17,400
got I have generated a value member if

01:23:16,440 --> 01:23:20,040
there wasn't one

01:23:17,400 --> 01:23:21,780
now I'm gonna say if there's no get

01:23:20,040 --> 01:23:25,290
function every property has to have a

01:23:21,780 --> 01:23:25,650
get function right cost properties need

01:23:25,290 --> 01:23:27,720
it

01:23:25,650 --> 01:23:29,670
non-constant may not have it but

01:23:27,720 --> 01:23:32,340
constantly need it otherwise why have

01:23:29,670 --> 01:23:34,530
the property now I'm gonna say if there

01:23:32,340 --> 01:23:36,750
is a value member either generated or

01:23:34,530 --> 01:23:38,850
the one I just that I just created or

01:23:36,750 --> 01:23:42,450
the one the user wrote I'm going to now

01:23:38,850 --> 01:23:43,710
generate might get access err if the

01:23:42,450 --> 01:23:46,050
user didn't write when themselves this

01:23:43,710 --> 01:23:47,130
is the trivial one they get and I'm also

01:23:46,050 --> 01:23:50,730
getting to give a nice high-quality

01:23:47,130 --> 01:23:54,390
compiler error if they didn't write a

01:23:50,730 --> 01:23:56,220
default member a value member they wrote

01:23:54,390 --> 01:23:57,810
something else and it expected us to

01:23:56,220 --> 01:23:59,880
write together you can't do that you'd

01:23:57,810 --> 01:24:01,500
have to either give us a value or write

01:23:59,880 --> 01:24:04,170
your get or you can't do you can't leave

01:24:01,500 --> 01:24:06,750
both to us well we'll do both well we'll

01:24:04,170 --> 01:24:08,760
do both of them but you can't just have

01:24:06,750 --> 01:24:11,370
some members but not a value and expect

01:24:08,760 --> 01:24:13,230
us to know how to write together so that

01:24:11,370 --> 01:24:17,640
gives us a nice high quality air right

01:24:13,230 --> 01:24:21,090
there now what about the setter not

01:24:17,640 --> 01:24:25,440
every property is writable well in C++

01:24:21,090 --> 01:24:27,660
we have Const and we have in C++ already

01:24:25,440 --> 01:24:29,400
stood is constant so I'll just use that

01:24:27,660 --> 01:24:31,290
here stood as constant V because I like

01:24:29,400 --> 01:24:36,150
C plus a 17 and I hate writing colon

01:24:31,290 --> 01:24:39,030
colon value so if T is Const and we

01:24:36,150 --> 01:24:44,310
don't already have a setter and we have

01:24:39,030 --> 01:24:46,560
a value member member named value then

01:24:44,310 --> 01:24:49,140
I'll generate a set function and just

01:24:46,560 --> 01:24:50,790
because I can all over loaded on cost

01:24:49,140 --> 01:24:52,029
RAF and ref ref to it to be maximally

01:24:50,790 --> 01:24:53,709
efficient for our values

01:24:52,029 --> 01:24:55,839
because you're not gonna see this code

01:24:53,709 --> 01:25:02,249
anyway let's do the efficient thing it's

01:24:55,839 --> 01:25:05,559
only one more line then finally I

01:25:02,249 --> 01:25:08,769
provide a conversion operator that

01:25:05,559 --> 01:25:14,169
returns the value I'm gonna of this type

01:25:08,769 --> 01:25:16,659
and then I'm going to generate the the

01:25:14,169 --> 01:25:17,859
vet ways to set this value because what

01:25:16,659 --> 01:25:21,339
I'm going to do is I've created this

01:25:17,859 --> 01:25:22,529
class and I'm just gonna make one value

01:25:21,339 --> 01:25:24,729
of this class that's it

01:25:22,529 --> 01:25:27,429
link timecode gen is really good at a

01:25:24,729 --> 01:25:28,479
leap time optimization and fold combat

01:25:27,429 --> 01:25:30,399
folding is really good at removing

01:25:28,479 --> 01:25:32,799
duplicates so I'm just gonna generate a

01:25:30,399 --> 01:25:34,829
class for this property and instantiate

01:25:32,799 --> 01:25:37,479
one variable for all time from it and

01:25:34,829 --> 01:25:41,019
these are how you construct and access

01:25:37,479 --> 01:25:44,979
it and then finally today I have to

01:25:41,019 --> 01:25:47,559
write this and this this code works

01:25:44,979 --> 01:25:49,629
today I really would like to write this

01:25:47,559 --> 01:25:51,669
but I'm so close to it already I can

01:25:49,629 --> 01:25:53,919
smell it and I know this one's going to

01:25:51,669 --> 01:25:57,159
be going away soon and the committee

01:25:53,919 --> 01:25:58,629
wants class brackets so okay we'll give

01:25:57,159 --> 01:26:01,209
them class bracket that's close enough

01:25:58,629 --> 01:26:02,769
for me but that works today and I'll be

01:26:01,209 --> 01:26:06,579
blogging about it in the next few weeks

01:26:02,769 --> 01:26:08,769
with a live example you can try so the

01:26:06,579 --> 01:26:11,109
goal of meta classes is to expand the

01:26:08,769 --> 01:26:14,889
abstraction vocabulary we have in C++

01:26:11,109 --> 01:26:16,779
and beyond just the built-in meta

01:26:14,889 --> 01:26:22,029
classes you might say of class struct

01:26:16,779 --> 01:26:24,309
Union Inu we can generate defaults at

01:26:22,029 --> 01:26:26,589
force requirements on classes and give a

01:26:24,309 --> 01:26:29,229
name as a word of power to this group of

01:26:26,589 --> 01:26:30,489
behavior this kind of class that has

01:26:29,229 --> 01:26:32,949
these characteristics out of the

01:26:30,489 --> 01:26:35,409
universe of classes and get rid of lots

01:26:32,949 --> 01:26:38,829
of side compilers I hope such as cute

01:26:35,409 --> 01:26:40,749
mock comm it'll see plus CX which I

01:26:38,829 --> 01:26:41,979
designed and part of my goal here is so

01:26:40,749 --> 01:26:45,069
I never have to design that again

01:26:41,979 --> 01:26:47,529
because I want to write it in C++ we did

01:26:45,069 --> 01:26:49,599
see Coco Co I and C X because we

01:26:47,529 --> 01:26:51,269
couldn't write the information in C++ it

01:26:49,599 --> 01:26:53,589
wasn't there wasn't enough there I

01:26:51,269 --> 01:26:55,569
believe this gets us the rest of the way

01:26:53,589 --> 01:26:58,419
so I can write it in a potentially

01:26:55,569 --> 01:27:02,619
future if this goes well standard C++

01:26:58,419 --> 01:27:05,079
somewhere down the road if we can do

01:27:02,619 --> 01:27:05,770
this then you would not have to wait for

01:27:05,079 --> 01:27:07,690
the

01:27:05,770 --> 01:27:09,430
Standards Committee to agree to add

01:27:07,690 --> 01:27:11,980
property to the language you could write

01:27:09,430 --> 01:27:13,210
it as a short library and share it you

01:27:11,980 --> 01:27:14,530
could actually do it we could add it to

01:27:13,210 --> 01:27:16,210
the standard library that's way easier

01:27:14,530 --> 01:27:18,160
than plumbing it through the language

01:27:16,210 --> 01:27:20,830
which would take men centuries of work

01:27:18,160 --> 01:27:23,280
probably and who has time for person

01:27:20,830 --> 01:27:25,720
centuries of work per language feature

01:27:23,280 --> 01:27:28,420
the benefits for Standardization is if

01:27:25,720 --> 01:27:30,640
we can get more work into short clear

01:27:28,420 --> 01:27:32,170
libraries which are testable then as

01:27:30,640 --> 01:27:34,720
language features which have to be wired

01:27:32,170 --> 01:27:36,400
into a language specification and aren't

01:27:34,720 --> 01:27:37,840
testable easily you have to pay somebody

01:27:36,400 --> 01:27:41,200
a lot of money to write test cases

01:27:37,840 --> 01:27:43,360
I like code code is great code is

01:27:41,200 --> 01:27:45,430
testable and being able to write that

01:27:43,360 --> 01:27:47,640
feature property as code that I can test

01:27:45,430 --> 01:27:49,810
is just a wonderful thing for me so

01:27:47,640 --> 01:27:51,790
here's the checklist of things I said

01:27:49,810 --> 01:27:54,280
earlier I think it hits all of them it

01:27:51,790 --> 01:27:56,230
doesn't quite let us remove help

01:27:54,280 --> 01:27:58,210
exceptions in our TTI but it does pretty

01:27:56,230 --> 01:28:00,550
much all the others including the last

01:27:58,210 --> 01:28:02,680
because I as I showed with the guarded

01:28:00,550 --> 01:28:05,050
case metaclasses

01:28:02,680 --> 01:28:07,480
and generation remove some of the

01:28:05,050 --> 01:28:10,420
reasons we need macros today this is a

01:28:07,480 --> 01:28:12,760
direct step on putting the nail in the

01:28:10,420 --> 01:28:15,610
coffin of macros in new code by

01:28:12,760 --> 01:28:17,620
systematically in this and with other

01:28:15,610 --> 01:28:20,860
features removing the reasons that

01:28:17,620 --> 01:28:22,690
remain to write them so we talked about

01:28:20,860 --> 01:28:24,430
more powerful and simpler we talked

01:28:22,690 --> 01:28:32,590
about lifetime and we talked about meta

01:28:24,430 --> 01:28:37,120
classes and it's time for xkcd Randall

01:28:32,590 --> 01:28:39,420
wrote it I didn't the reason I mention

01:28:37,120 --> 01:28:42,550
this is because how many of you noticed

01:28:39,420 --> 01:28:46,360
that the lifetime rules compiler and the

01:28:42,550 --> 01:28:50,710
med classes compiler were both in cpp x

01:28:46,360 --> 01:28:53,620
god Bolcom oh only a few of you noticed

01:28:50,710 --> 01:28:56,860
that let's have a couple of slides of

01:28:53,620 --> 01:28:59,890
fun here is one more simple meta class I

01:28:56,860 --> 01:29:01,390
met a class called pointer and it's just

01:28:59,890 --> 01:29:03,370
a toy matter class but it still does

01:29:01,390 --> 01:29:04,840
something useful every time you write a

01:29:03,370 --> 01:29:08,350
pointer like type whether it's a

01:29:04,840 --> 01:29:10,690
observer pointer or an iterator what do

01:29:08,350 --> 01:29:13,060
we have to teach people oh yeah overload

01:29:10,690 --> 01:29:16,990
operator star and operator arrow and

01:29:13,060 --> 01:29:18,340
make them do the same thing well here's

01:29:16,990 --> 01:29:19,550
a little meta class where you just write

01:29:18,340 --> 01:29:21,500
operator star

01:29:19,550 --> 01:29:23,540
make sure you wrote it so you can't make

01:29:21,500 --> 01:29:26,840
the mistake of forgetting it and we just

01:29:23,540 --> 01:29:29,929
generate operator arrow for you so what

01:29:26,840 --> 01:29:31,369
it does is we're going to say we're

01:29:29,929 --> 01:29:33,260
gonna echo all the source of area all

01:29:31,369 --> 01:29:35,090
the variables that might have we're

01:29:33,260 --> 01:29:37,880
going to just check whether it has an

01:29:35,090 --> 01:29:39,559
operator star if it doesn't we're going

01:29:37,880 --> 01:29:43,150
to complain and then we're going to

01:29:39,559 --> 01:29:46,309
generate operator arrow that returns

01:29:43,150 --> 01:29:49,820
address of star star this just calls the

01:29:46,309 --> 01:29:52,760
star operator and once we do that we can

01:29:49,820 --> 01:29:54,889
simply write our own pointer type we

01:29:52,760 --> 01:29:56,809
write only operator star and if we

01:29:54,889 --> 01:29:58,250
forget we get an error and we get

01:29:56,809 --> 01:30:00,320
operator arrow for free

01:29:58,250 --> 01:30:02,449
okay so there's a cute little toy

01:30:00,320 --> 01:30:05,059
metaclass but this still does something

01:30:02,449 --> 01:30:07,489
useful and here's what it generates I

01:30:05,059 --> 01:30:09,320
wrote Mike my data member is my

01:30:07,489 --> 01:30:11,239
constructor those get echoed I wrote my

01:30:09,320 --> 01:30:14,719
operator star that gets validated and

01:30:11,239 --> 01:30:17,780
then I generate the arrow operator and

01:30:14,719 --> 01:30:20,030
everything is fine and then when I use

01:30:17,780 --> 01:30:23,239
it I can create one this default

01:30:20,030 --> 01:30:25,670
constructed and I can dereference it and

01:30:23,239 --> 01:30:30,219
you might have noticed it has a squiggle

01:30:25,670 --> 01:30:30,219
what do you suppose that squiggle means

01:30:30,639 --> 01:30:36,440
if I take away the blackout you will see

01:30:34,219 --> 01:30:38,389
the first part of the compiler output is

01:30:36,440 --> 01:30:40,429
the generation of the pointer class

01:30:38,389 --> 01:30:42,230
using the metaclass and the second then

01:30:40,429 --> 01:30:44,420
says you're using that pointer type but

01:30:42,230 --> 01:30:46,130
and you're doing an oldy ref set it to

01:30:44,420 --> 01:30:48,679
something before you dereference it and

01:30:46,130 --> 01:30:50,090
i have one piece of code and i get both

01:30:48,679 --> 01:30:52,699
of those together

01:30:50,090 --> 01:30:55,400
I like features that work well together

01:30:52,699 --> 01:30:58,449
and this is an example of how these

01:30:55,400 --> 01:31:01,790
simplifications add up and combine well

01:30:58,449 --> 01:31:03,409
so let's try to pursue c+ evolution that

01:31:01,790 --> 01:31:05,869
makes user code simpler through

01:31:03,409 --> 01:31:08,329
abstraction remove special cases and

01:31:05,869 --> 01:31:10,010
sharp edges and let's start to get rid

01:31:08,329 --> 01:31:12,230
of things to deprecate or at least

01:31:10,010 --> 01:31:15,530
discourage older features that are less

01:31:12,230 --> 01:31:16,730
good like macros and lifetime targets

01:31:15,530 --> 01:31:18,739
that I've talked about targets the

01:31:16,730 --> 01:31:21,739
lower-left metaclasses target the other

01:31:18,739 --> 01:31:24,530
two and hopefully these are ways that

01:31:21,739 --> 01:31:27,290
with these and other features we can

01:31:24,530 --> 01:31:29,989
continue making c++ a simpler language

01:31:27,290 --> 01:31:31,489
for us all in the coming years and I

01:31:29,989 --> 01:31:33,720
think that would be great for the

01:31:31,489 --> 01:31:35,280
industry for all of us and forever

01:31:33,720 --> 01:31:37,140
and we'd have a lot more fun in the

01:31:35,280 --> 01:31:39,720
language to that we already enjoy so

01:31:37,140 --> 01:31:41,010
much we have time for just a couple of

01:31:39,720 --> 01:31:42,930
questions if you'd like to come up to a

01:31:41,010 --> 01:31:44,190
mic I'll take one or two and then be

01:31:42,930 --> 01:31:47,750
happy to talk with you down at the

01:31:44,190 --> 01:31:47,750
bottom yes

01:31:54,370 --> 01:32:00,110
hi thank you this metaclasses seems to

01:31:57,800 --> 01:32:03,130
be really powerful feature but how it's

01:32:00,110 --> 01:32:05,239
supposed to dip back and test them

01:32:03,130 --> 01:32:07,310
excellent question how do you debug and

01:32:05,239 --> 01:32:08,900
test them so I talked about that last

01:32:07,310 --> 01:32:11,270
year so definitely watch the longer

01:32:08,900 --> 01:32:13,960
answer in that video this is one of the

01:32:11,270 --> 01:32:16,340
reasons I show that compiler dot debug

01:32:13,960 --> 01:32:18,350
the reflect on the metaclass so you can

01:32:16,340 --> 01:32:20,900
see what's outputted that is the kind of

01:32:18,350 --> 01:32:22,820
information that what is generated that

01:32:20,900 --> 01:32:24,380
tools would expose so that you would be

01:32:22,820 --> 01:32:26,480
able to step into and do things like

01:32:24,380 --> 01:32:29,350
that and see what you're generating but

01:32:26,480 --> 01:32:33,230
let's just write that a lot more cleanly

01:32:29,350 --> 01:32:47,120
is there somebody at this mic okay the

01:32:33,230 --> 01:32:49,670
next one here how do you control where

01:32:47,120 --> 01:32:51,140
you're generating to in some of the

01:32:49,670 --> 01:32:53,030
examples I'm guessing you're generating

01:32:51,140 --> 01:32:54,890
internal structure and things but can

01:32:53,030 --> 01:32:56,690
you generate outside the class and how

01:32:54,890 --> 01:32:59,360
do you control where that goes

01:32:56,690 --> 01:33:00,950
so currently generation is where you are

01:32:59,360 --> 01:33:03,680
in place so as you're defining class

01:33:00,950 --> 01:33:05,239
active say is you're in that scope

01:33:03,680 --> 01:33:07,340
you're defining the contents of that

01:33:05,239 --> 01:33:08,900
class what one of the things that we're

01:33:07,340 --> 01:33:10,940
extending is being able to write

01:33:08,900 --> 01:33:12,380
non-member functions so today you can

01:33:10,940 --> 01:33:14,510
write member functions you can write

01:33:12,380 --> 01:33:16,070
static member functions and free

01:33:14,510 --> 01:33:19,220
functions that are declared in the class

01:33:16,070 --> 01:33:21,440
and we're also providing ways that to be

01:33:19,220 --> 01:33:23,720
able to declare things in enclosing

01:33:21,440 --> 01:33:25,730
namespaces and places like that so

01:33:23,720 --> 01:33:27,290
that's coming I don't have any examples

01:33:25,730 --> 01:33:33,080
that compile yet but that's that will be

01:33:27,290 --> 01:33:35,350
coming in the coming months oh yes

01:33:33,080 --> 01:33:38,930
please

01:33:35,350 --> 01:33:41,960
so how would this mesh with say concepts

01:33:38,930 --> 01:33:44,840
can you say like oh I have my pointer

01:33:41,960 --> 01:33:46,070
metaclass I would expect this algorithm

01:33:44,840 --> 01:33:50,000
to expand have

01:33:46,070 --> 01:33:51,409
concept is a pointer metaclass so one

01:33:50,000 --> 01:33:55,940
way to think about it and I'm using be

01:33:51,409 --> 01:33:58,130
Arnaz words here B aren't a bad example

01:33:55,940 --> 01:34:01,280
but that's okay iterator anything like

01:33:58,130 --> 01:34:03,590
that so metaclasses are for constructing

01:34:01,280 --> 01:34:05,329
for defining new types concepts are for

01:34:03,590 --> 01:34:06,860
querying them so they're read-only now

01:34:05,329 --> 01:34:09,050
every metaclass also comes with thought

01:34:06,860 --> 01:34:12,349
is so you can say whether it matches

01:34:09,050 --> 01:34:14,630
just like a concept so think of them as

01:34:12,349 --> 01:34:15,590
constructive concepts that's the term BR

01:34:14,630 --> 01:34:17,360
and it came up with and I think it's

01:34:15,590 --> 01:34:19,310
apropos because it's you're not just

01:34:17,360 --> 01:34:21,199
reading something you're defining it to

01:34:19,310 --> 01:34:22,840
be this kind of thing so you get

01:34:21,199 --> 01:34:25,849
generated defaults and things like that

01:34:22,840 --> 01:34:28,159
the one thing the concepts does that's

01:34:25,849 --> 01:34:29,510
that this doesn't and that's useful we

01:34:28,159 --> 01:34:32,560
can just we could add the feature or we

01:34:29,510 --> 01:34:34,940
can just use concepts here is concepts

01:34:32,560 --> 01:34:36,290
whereas here you iterate through the

01:34:34,940 --> 01:34:39,170
member functions and say oh it does it

01:34:36,290 --> 01:34:42,889
have food as it have bar concepts you

01:34:39,170 --> 01:34:45,170
can say does is foo of X a valid

01:34:42,889 --> 01:34:47,360
expression you can do a use case based

01:34:45,170 --> 01:34:48,889
query and that's still useful so I think

01:34:47,360 --> 01:34:50,750
these are very complementary features

01:34:48,889 --> 01:34:53,869
you'll find some examples in the paper

01:34:50,750 --> 01:34:56,739
that use concepts in the implementations

01:34:53,869 --> 01:34:59,150
of metaclasses to query oh is this type

01:34:56,739 --> 01:35:01,460
assignable if it's not I'll generate

01:34:59,150 --> 01:35:03,409
something but it's just the it can just

01:35:01,460 --> 01:35:06,739
Joe check for assignment or equality

01:35:03,409 --> 01:35:09,980
comparison using concepts use case style

01:35:06,739 --> 01:35:11,869
syntax and then generate using the

01:35:09,980 --> 01:35:12,429
syntax you saw so I think they go well

01:35:11,869 --> 01:35:14,210
together

01:35:12,429 --> 01:35:21,020
Thanks there's a very interesting

01:35:14,210 --> 01:35:24,050
feature I'm very excited by the lifetime

01:35:21,020 --> 01:35:26,900
checking features and I curious to know

01:35:24,050 --> 01:35:29,090
that if you have sufficient annotation

01:35:26,900 --> 01:35:31,760
is it possible that we can say

01:35:29,090 --> 01:35:35,329
mathematically that all dangling

01:35:31,760 --> 01:35:37,520
dereferences will be cut and if so what

01:35:35,329 --> 01:35:39,199
was the motivation for keeping this in

01:35:37,520 --> 01:35:42,079
tooling rather than as part of the

01:35:39,199 --> 01:35:43,369
language itself well so there's a couple

01:35:42,079 --> 01:35:44,719
of questions there so first of all this

01:35:43,369 --> 01:35:46,579
is designed to be implemented in the

01:35:44,719 --> 01:35:48,650
compiler the client implementation is in

01:35:46,579 --> 01:35:50,960
a compiler so it runs at compile time

01:35:48,650 --> 01:35:52,969
it's a compile time diagnostic so it's

01:35:50,960 --> 01:35:55,250
that's the kind of thing that is in

01:35:52,969 --> 01:35:57,020
candy in the language if we wanted to

01:35:55,250 --> 01:35:59,780
standardize something like that so it

01:35:57,020 --> 01:36:01,610
can totally do that as for hope

01:35:59,780 --> 01:36:03,170
program guarantees it's possible that we

01:36:01,610 --> 01:36:06,650
could approach those or even get them

01:36:03,170 --> 01:36:08,599
I'm a big fan of the 80/20 rule I'm a

01:36:06,650 --> 01:36:10,969
big fan of the the dangling problems I

01:36:08,599 --> 01:36:12,590
see and see classes are not because it's

01:36:10,969 --> 01:36:14,750
not formally type safe and memory safe

01:36:12,590 --> 01:36:16,820
it's because I have regular patterns

01:36:14,750 --> 01:36:19,309
that people trip over all the time and I

01:36:16,820 --> 01:36:21,170
can get those then we can see well how

01:36:19,309 --> 01:36:24,079
much is the other 20 percent or two

01:36:21,170 --> 01:36:26,300
percent more likely worth it's worth

01:36:24,079 --> 01:36:28,369
noting that to get a formal guarantee of

01:36:26,300 --> 01:36:30,559
anything like it's a cost benefit we're

01:36:28,369 --> 01:36:32,960
taking a cost like a design time cost

01:36:30,559 --> 01:36:35,000
possibly runtime instrumentation to get

01:36:32,960 --> 01:36:37,250
a guarantee how valuable is that

01:36:35,000 --> 01:36:38,929
guarantee compared to the cost so for

01:36:37,250 --> 01:36:42,230
example type safe languages like Java

01:36:38,929 --> 01:36:44,270
and c-sharp aren't type safe that's

01:36:42,230 --> 01:36:46,309
heresy but it depends on your definition

01:36:44,270 --> 01:36:48,829
of type safety they implement the type

01:36:46,309 --> 01:36:51,050
safety they specify they don't detect

01:36:48,829 --> 01:36:52,940
use after dispose for example they have

01:36:51,050 --> 01:36:54,920
Resurrection instead and get to teach

01:36:52,940 --> 01:36:56,840
that so it all depends on how you define

01:36:54,920 --> 01:37:00,020
it I believe you can get a very

01:36:56,840 --> 01:37:02,000
practical level of leak freedom and

01:37:00,020 --> 01:37:04,250
angle freedom rather and by being able

01:37:02,000 --> 01:37:06,289
to handle many common cases that we

01:37:04,250 --> 01:37:07,730
already know our real cases because

01:37:06,289 --> 01:37:10,460
we've been teaching people about them

01:37:07,730 --> 01:37:11,960
for 10 20 years so I'm optimistic that

01:37:10,460 --> 01:37:14,809
we will be able to handle the important

01:37:11,960 --> 01:37:17,840
ones then we'll see if we get to any

01:37:14,809 --> 01:37:20,150
whole program guarantees yeah one more

01:37:17,840 --> 01:37:22,039
please so at the beginning of the talk

01:37:20,150 --> 01:37:24,079
you talked about features in the

01:37:22,039 --> 01:37:26,360
language that basically have been

01:37:24,079 --> 01:37:28,820
completely overtaken by newer features

01:37:26,360 --> 01:37:30,500
so are there for compatibility like

01:37:28,820 --> 01:37:32,360
OpenGL expressed as a core versus

01:37:30,500 --> 01:37:33,710
compatibility profile

01:37:32,360 --> 01:37:35,300
what are your quick thoughts on

01:37:33,710 --> 01:37:39,980
expressing the standard in such a way

01:37:35,300 --> 01:37:41,840
that is exactly what I had in mind and

01:37:39,980 --> 01:37:44,360
tried to recommend we start thinking

01:37:41,840 --> 01:37:46,400
about in the first part of this talk I

01:37:44,360 --> 01:37:48,650
think we are already effectively doing

01:37:46,400 --> 01:37:50,840
that in practice in particular the whole

01:37:48,650 --> 01:37:52,820
reason BR Anna created the core

01:37:50,840 --> 01:37:55,250
guidelines and yarn and I created the

01:37:52,820 --> 01:37:57,020
core guidelines was to be able to create

01:37:55,250 --> 01:37:59,599
a set of rules where you don't do this

01:37:57,020 --> 01:38:01,550
in new code that's for old code only new

01:37:59,599 --> 01:38:04,760
code is we set up guardrails and rules

01:38:01,550 --> 01:38:06,619
for here's the subset of C plus that is

01:38:04,760 --> 01:38:07,940
recommended today and that we can keep

01:38:06,619 --> 01:38:12,400
moving forward

01:38:07,940 --> 01:38:14,230
so that is implicitly creating such a

01:38:12,400 --> 01:38:18,100
stinking so we're already partway down

01:38:14,230 --> 01:38:20,350
that road I am specifically including a

01:38:18,100 --> 01:38:24,670
call to action to start seriously

01:38:20,350 --> 01:38:27,489
thinking about a future someday where we

01:38:24,670 --> 01:38:29,290
actually have here our compatibility

01:38:27,489 --> 01:38:31,929
mode features with a fence around them

01:38:29,290 --> 01:38:34,570
that we only need when we're in

01:38:31,929 --> 01:38:37,630
compatibility mode and consider having a

01:38:34,570 --> 01:38:39,489
mode that is a subset that is new code

01:38:37,630 --> 01:38:41,530
only that doesn't think that fires would

01:38:39,489 --> 01:38:43,540
then agree on what that is yes so that's

01:38:41,530 --> 01:38:45,310
I'm certainly I'm certainly speaking

01:38:43,540 --> 01:38:46,510
only for myself I'm not speaking for BR

01:38:45,310 --> 01:38:47,920
and I'm not speaking for the Standards

01:38:46,510 --> 01:38:49,929
Committee I'm just observing we're

01:38:47,920 --> 01:38:52,090
already doing some of this I happen to

01:38:49,929 --> 01:38:54,190
think it's desirable to start thinking

01:38:52,090 --> 01:38:56,469
about is it worth standardizing such a

01:38:54,190 --> 01:38:58,120
subset we'll see where it goes I think

01:38:56,469 --> 01:39:00,010
it's going to be some years off but it's

01:38:58,120 --> 01:39:02,290
worth thinking about now in order to

01:39:00,010 --> 01:39:03,550
plan for them very good yeah so thank

01:39:02,290 --> 01:39:04,780
you thank you all for coming

01:39:03,550 --> 01:39:06,960
enjoy your lunch in the rest of the

01:39:04,780 --> 01:39:06,960

YouTube URL: https://www.youtube.com/watch?v=80BZxujhY38


