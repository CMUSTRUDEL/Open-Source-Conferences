Title: CppCon 2018: Louis Dionne “Compile-time programming and reflection in C++20 and beyond”
Publication date: 2018-10-09
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Compile-time programming and reflection have been getting a lot of attention recently. Indeed, from Herb Sutter's well-known Metaclasses proposal to the newly created Reflection TS, a lot of effort is being put into solving the general problem of programmatic code generation and program introspection. More recently, the C++ Standards Committee has also been evaluating and adopting proposals that vastly expand the realm of constructs available at compile-time, in constexpr functions: new-expressions, try-catch blocks, virtual functions, some standard containers, and more. 

For most people, it is unclear how all these features, whether exploratory or voted into the Draft International Standard, relate together. Without being active in the Committee, it can be difficult to see the big picture, the unifying vision driving all these changes. Fortunately, there is one, and this is what this talk is about. 

We will go over these features and explain how they might interact with each other by boiling them down to their essential parts. We will present how different use cases for compile-time programming will be solved in C++20, and how even more use cases can be unlocked in the future. Attendees will leave this talk with an understanding of the improvements to constexpr planned for C++20, of what's needed to unlock more advanced use cases and an unifying vision for how to get there.
— 
Louis Dionne, Apple, C++ Standard Library Engineer
Louis is a math and computer science enthusiast who got swallowed by the C++ monster when he was a naive, unsuspecting student. He now works for Apple, where he is responsible for libc++, the Standard Library shipped with LLVM/Clang. He is a member of the C++ Standards Committee and of the Boost community, where he authored the Boost.Hana metaprogramming library.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,060 --> 00:00:03,620
- All right, folks, thanks for being here.

00:00:03,620 --> 00:00:06,230
My name is Louis Dionne, I work at Apple.

00:00:06,230 --> 00:00:08,660
I work on the standard library there,

00:00:08,660 --> 00:00:12,140
so lib C++, which is the standard library ship with Cling.

00:00:12,140 --> 00:00:15,473
And in a past life, I was a crazy template meta-programmer.

00:00:16,379 --> 00:00:17,212
(audience laughing)

00:00:17,212 --> 00:00:20,890
And as part of my duties on the C++ standards committee,

00:00:20,890 --> 00:00:23,130
I'm quite interested in reflection,

00:00:23,130 --> 00:00:25,360
compile-time programming,

00:00:25,360 --> 00:00:28,213
code generation, meta-classes, these kind of topics,

00:00:29,130 --> 00:00:30,513
also like lambdas.

00:00:31,950 --> 00:00:36,410
And so the goal of this talk here is really to

00:00:36,410 --> 00:00:39,460
kind of clear up some misconceptions

00:00:39,460 --> 00:00:43,390
or rather some confusion about our plans

00:00:43,390 --> 00:00:44,690
for compile-time programming.

00:00:44,690 --> 00:00:47,840
So, I wanna give you a bird's eye view of what's

00:00:47,840 --> 00:00:49,770
what we expect is going to happen in the future

00:00:49,770 --> 00:00:52,440
for compile-time programming in reflection.

00:00:52,440 --> 00:00:54,110
That's kind of the goal of the talk.

00:00:54,110 --> 00:00:58,680
Hopefully if I succeed, you'll leave this room less confused

00:00:58,680 --> 00:01:00,220
than you are right now, with respect to

00:01:00,220 --> 00:01:02,963
what we're gonna do in C++20 and beyond.

00:01:05,260 --> 00:01:09,300
So, before we start getting into the nitty gritty details,

00:01:09,300 --> 00:01:10,900
I think it's important to ask ourselves

00:01:10,900 --> 00:01:12,541
why do we even care about that,

00:01:12,541 --> 00:01:15,130
'cause C++ is already a complex language,

00:01:15,130 --> 00:01:18,540
and if we're gonna solve problems, we

00:01:18,540 --> 00:01:20,300
if we're gonna increase the complexity of the language

00:01:20,300 --> 00:01:22,270
by adding stuff to it we need to have

00:01:22,270 --> 00:01:23,730
some good reasons to do that.

00:01:27,170 --> 00:01:29,570
For compile-time programming, one of the biggest

00:01:31,508 --> 00:01:33,330
used cases is constant initialization,

00:01:33,330 --> 00:01:37,966
where we have basically data that we know compiled.

00:01:37,966 --> 00:01:40,900
I'm gonna have information that we know at compile time.

00:01:40,900 --> 00:01:45,290
And we wanna perform some kind of computation on that data,

00:01:45,290 --> 00:01:47,490
and have that computation perform

00:01:48,330 --> 00:01:50,780
exclusively at compile time, nothing at run time.

00:01:51,720 --> 00:01:55,250
And then somehow have the compiler store that information

00:01:55,250 --> 00:01:56,350
for us somewhere in the program,

00:01:56,350 --> 00:01:59,660
such that we can then use it at run time.

00:01:59,660 --> 00:02:02,100
So for example, here I'm generating

00:02:03,884 --> 00:02:07,570
exponentials from zero to a thousand,

00:02:07,570 --> 00:02:10,540
and I'm storing that in an array

00:02:10,540 --> 00:02:12,290
that I can then access at run time.

00:02:13,490 --> 00:02:15,630
If compute_exp is

00:02:17,110 --> 00:02:19,660
is constexpr, then in principle there is

00:02:19,660 --> 00:02:21,660
absolutely nothing happening at run time

00:02:22,530 --> 00:02:23,780
to initialize that array.

00:02:26,640 --> 00:02:28,470
So there is no static initialization,

00:02:28,470 --> 00:02:30,510
there is nothing happening when the program starts up.

00:02:30,510 --> 00:02:32,900
It's just hard-coded in the data segment,

00:02:32,900 --> 00:02:34,070
which is what we want.

00:02:34,070 --> 00:02:36,610
So that's one used case for compile-time programming.

00:02:36,610 --> 00:02:38,980
Another thing is boilerplate reduction.

00:02:38,980 --> 00:02:42,080
There are many cases in C++ where even to do simple things,

00:02:42,080 --> 00:02:44,310
we need to tediously repeat

00:02:45,860 --> 00:02:47,130
patterns like that.

00:02:47,130 --> 00:02:50,650
I mean, I'm pretty sure everybody has one of these

00:02:50,650 --> 00:02:51,550
in their codebases.

00:02:51,550 --> 00:02:54,600
And sometimes, they're generated using macros.

00:02:54,600 --> 00:02:57,230
And sometimes, they're just generated by hand,

00:02:57,230 --> 00:03:00,250
or sometimes you even have a Python script

00:03:00,250 --> 00:03:02,600
or something like that that generates them.

00:03:02,600 --> 00:03:04,030
We've all seen that.

00:03:04,030 --> 00:03:06,450
And actually Cling is full of that kind of stuff,

00:03:06,450 --> 00:03:10,810
where we generate AST nodes and stuff like that,

00:03:10,810 --> 00:03:14,040
then it's very, very, very annoying to

00:03:14,920 --> 00:03:16,680
not to be able to rely

00:03:16,680 --> 00:03:19,260
on the compiler itself, which has this information,

00:03:19,260 --> 00:03:22,010
because the compiler knows the enumerators.

00:03:22,010 --> 00:03:25,300
It's really annoying the fact that we can't rely

00:03:25,300 --> 00:03:26,773
on that knowledge.

00:03:29,620 --> 00:03:31,670
Solving these topics, these problems,

00:03:31,670 --> 00:03:33,030
you used to be super nerdy,

00:03:33,030 --> 00:03:35,600
like given amongst a C++ crowd, which is

00:03:37,217 --> 00:03:38,817
which is quite something to say.

00:03:40,070 --> 00:03:42,340
But it turns out that recently

00:03:42,340 --> 00:03:44,870
recently everybody is on it.

00:03:44,870 --> 00:03:49,610
Everybody is producing papers, talking about that.

00:03:49,610 --> 00:03:52,590
I mean, the direction group even

00:03:52,590 --> 00:03:56,900
the direction group even included reflection

00:03:56,900 --> 00:04:01,470
as one of the major work items for the future revisions

00:04:01,470 --> 00:04:03,890
of the language, which is quite something.

00:04:03,890 --> 00:04:06,360
I mean, I never expected that this would happen.

00:04:06,360 --> 00:04:09,430
But it is a very hot topic right now.

00:04:09,430 --> 00:04:12,840
And so as a result, it's super exciting.

00:04:12,840 --> 00:04:16,000
We see a lot of different proposals,

00:04:16,000 --> 00:04:17,690
but it's also very confusing,

00:04:17,690 --> 00:04:20,520
because not all proposals are

00:04:20,520 --> 00:04:24,720
I mean, it's really hard to see how proposals fit together,

00:04:24,720 --> 00:04:27,140
and sometimes they don't, and some ideas are good,

00:04:27,140 --> 00:04:30,643
some ideas are not so good, and it's very difficult.

00:04:32,680 --> 00:04:35,730
It's not reasonable to expect that someone with a day job is

00:04:35,730 --> 00:04:38,270
actually gonna keep on top of all that.

00:04:38,270 --> 00:04:40,340
So what I'm gonna try to do today is put

00:04:40,340 --> 00:04:42,900
some order in there and try to give you a little bit

00:04:42,900 --> 00:04:44,820
of a bird's eye view of what's coming

00:04:44,820 --> 00:04:47,370
and how it fits together essentially,

00:04:47,370 --> 00:04:50,270
'cause my job is somewhat to do that summary for you guys.

00:04:54,770 --> 00:04:57,033
And so what's the plan?

00:04:58,190 --> 00:05:00,882
Even though this is C++, we do have a plan.

00:05:00,882 --> 00:05:03,800
(audience laughing)

00:05:03,800 --> 00:05:04,633
first,

00:05:05,860 --> 00:05:08,460
we're gonna try to make almost everything constexpr.

00:05:09,570 --> 00:05:13,550
So, we want to expand constexpr such that it can

00:05:14,770 --> 00:05:17,470
basically anything that you can write in normal C++

00:05:17,470 --> 00:05:20,680
you can write in constexpr and run it at compile time,

00:05:20,680 --> 00:05:23,420
not everything but we wanna expand the language

00:05:24,690 --> 00:05:28,620
well, constexpr as much as we can to close that gap.

00:05:28,620 --> 00:05:29,870
So that's the first step.

00:05:31,170 --> 00:05:34,400
Then we wanna add an API,

00:05:34,400 --> 00:05:36,670
that allows you to speak to the compiler,

00:05:36,670 --> 00:05:38,477
to query things from the compiler.

00:05:38,477 --> 00:05:41,564
The compiler has a representation of your program.

00:05:41,564 --> 00:05:44,670
It parses it, does analysis and so on.

00:05:44,670 --> 00:05:47,173
And so it knows everything about your program.

00:05:48,140 --> 00:05:51,330
What we want is simply a way to programmatically query

00:05:51,330 --> 00:05:54,103
the compiler for the information that it already has.

00:05:57,760 --> 00:05:59,120
So the first one is just constexpr.

00:05:59,120 --> 00:06:01,940
The second one is really

00:06:01,940 --> 00:06:04,250
what we call reflection.

00:06:04,250 --> 00:06:07,503
It's the ability to reflect on your program.

00:06:09,000 --> 00:06:12,710
And then as the last step is the ability to

00:06:12,710 --> 00:06:14,840
actually influence the AST,

00:06:14,840 --> 00:06:16,980
influence your program programmatically,

00:06:16,980 --> 00:06:19,750
meaning you extract some information,

00:06:19,750 --> 00:06:22,630
you ask the compiler give me the list of numbers

00:06:22,630 --> 00:06:27,020
of that type, for example, then using constexpr you go and

00:06:27,020 --> 00:06:30,250
maybe modify these numbers or create new declarations

00:06:30,250 --> 00:06:32,020
or whatnot, and then you wanna be able

00:06:32,020 --> 00:06:34,060
to go back to the compiler and say, hey,

00:06:34,060 --> 00:06:36,720
I want to re-inject that basically

00:06:36,720 --> 00:06:39,933
into my program programmatically, that's kind of the idea.

00:06:41,920 --> 00:06:44,630
And so we've got features to enable one,

00:06:44,630 --> 00:06:46,080
we've got features to enable two,

00:06:46,080 --> 00:06:48,660
and we've got features to enable three.

00:06:48,660 --> 00:06:51,290
And these three things are pretty much disjointed.

00:06:51,290 --> 00:06:52,910
They kind of build on top of each other,

00:06:52,910 --> 00:06:55,560
but in some way they are orthogonal,

00:06:55,560 --> 00:06:58,343
so there's not one feature that sells all of this.

00:06:59,930 --> 00:07:02,400
And it's really important to keep that in mind.

00:07:02,400 --> 00:07:04,970
So the first step is expanding constexpr.

00:07:04,970 --> 00:07:07,900
And so doing that is necessary if we wanna have

00:07:07,900 --> 00:07:11,250
a computationally complete mechanism,

00:07:11,250 --> 00:07:15,380
with complex data structures at compile time,

00:07:15,380 --> 00:07:16,620
which is what we want, 'cause we wanna

00:07:16,620 --> 00:07:17,900
run non-trivial algorithms.

00:07:17,900 --> 00:07:21,860
We wanna be able to manipulate data and store it in

00:07:21,860 --> 00:07:23,260
not only in a std::array.

00:07:23,260 --> 00:07:25,170
We really wanna be able to do that and

00:07:25,170 --> 00:07:27,970
maybe have a vector or maybe have a map at compile time.

00:07:28,880 --> 00:07:30,794
So we need to expand constexpr.

00:07:30,794 --> 00:07:34,050
And so in C++11, constexpr was really, really limited.

00:07:34,050 --> 00:07:38,980
Basically, we only had a single return statement,

00:07:38,980 --> 00:07:41,750
no mutation, no control flow really,

00:07:41,750 --> 00:07:45,120
so we basically turned into functional programmers

00:07:45,120 --> 00:07:46,410
for better or worse, and

00:07:48,300 --> 00:07:49,573
that's what it was.

00:07:49,573 --> 00:07:53,050
In C++14, we unblocked many, many used cases

00:07:53,050 --> 00:07:57,240
by allowing control flow, for loops, mutation,

00:07:57,240 --> 00:07:59,190
and things like that, inside constexpr.

00:08:00,940 --> 00:08:02,140
But we're still limited.

00:08:03,130 --> 00:08:05,030
There's still many things we can't do.

00:08:05,920 --> 00:08:08,473
And I don't have a lot of love for reinterpret_cast.

00:08:08,473 --> 00:08:11,210
That is still something we can't do there.

00:08:11,210 --> 00:08:13,640
And so we can't allocate, we can't have try-catch,

00:08:13,640 --> 00:08:15,450
we can't throw exceptions,

00:08:15,450 --> 00:08:17,520
we can't do virtual calls,

00:08:17,520 --> 00:08:22,250
and there is a bunch of stuff like that that we can't do.

00:08:22,250 --> 00:08:25,680
And it's a problem, especially allocations,

00:08:25,680 --> 00:08:28,700
because it means we can't have variable-size containers.

00:08:28,700 --> 00:08:30,660
We're stuck with std::array

00:08:30,660 --> 00:08:33,520
or stack-allocated things basically.

00:08:33,520 --> 00:08:36,670
So if I wanna implement a keep_if algorithm, for example.

00:08:36,670 --> 00:08:38,270
It's basically standard copy if,

00:08:40,850 --> 00:08:43,650
which basically takes a range of

00:08:45,230 --> 00:08:47,210
integers and then keeps

00:08:47,210 --> 00:08:50,050
everything that satisfies the predicate, pretty simple.

00:08:50,050 --> 00:08:52,400
So, I might be tempted to just store the results

00:08:52,400 --> 00:08:53,233
in a vector.

00:08:55,000 --> 00:08:58,020
But I can't do that if my algorithm needs to be constexpr,

00:08:58,020 --> 00:09:00,560
because vector doesn't work at compile time, basically.

00:09:00,560 --> 00:09:03,140
It's not the literal type so the compiler's gonna tell me

00:09:03,140 --> 00:09:06,263
that can't call this function as a constant expression.

00:09:08,730 --> 00:09:13,220
So we have to use a fixed-size array, that's really painful.

00:09:13,220 --> 00:09:16,650
It is painful because it cannot be resized,

00:09:16,650 --> 00:09:18,800
which means that for anything where you don't know

00:09:18,800 --> 00:09:22,440
the final size of you container, you're in a bad place.

00:09:22,440 --> 00:09:24,280
So what I have to do here,

00:09:24,280 --> 00:09:27,960
I have to have my keep_if algorithm

00:09:27,960 --> 00:09:31,560
receive the end-size of the array that I'm gonna produce,

00:09:31,560 --> 00:09:33,720
which means that before I even execute my algorithm,

00:09:33,720 --> 00:09:35,390
I have to know part of the answer.

00:09:35,390 --> 00:09:38,203
I have to know how many things am I gonna keep.

00:09:39,810 --> 00:09:42,680
And so here I made the choice to actually just pass it

00:09:42,680 --> 00:09:45,280
manually, so I basically ran the algorithm in my head.

00:09:45,280 --> 00:09:46,370
I was like, all right, I'm gonna keep

00:09:46,370 --> 00:09:47,930
three things in my array.

00:09:47,930 --> 00:09:51,320
So I passed it on line 16 here.

00:09:51,320 --> 00:09:53,280
I passed it to the function,

00:09:53,280 --> 00:09:55,023
but that does not compose at all.

00:09:56,090 --> 00:10:00,880
So it's really, really hard to actually build

00:10:00,880 --> 00:10:05,810
complex, compile-time applications using constexpr today,

00:10:05,810 --> 00:10:09,680
because of this inability to actually resize containers.

00:10:09,680 --> 00:10:13,250
And so that's why we see, for example, in Ben Deane's talk

00:10:13,250 --> 00:10:16,570
where he did the compile-time parsing.

00:10:16,570 --> 00:10:19,350
I mean, it was really, really, really difficult,

00:10:19,350 --> 00:10:22,480
because you don't know the size of everything

00:10:22,480 --> 00:10:24,300
beforehand, so you need to basically duplicate

00:10:24,300 --> 00:10:27,260
all your code and go make sure that you have enough

00:10:27,260 --> 00:10:29,310
that you allocate enough size in advance.

00:10:31,050 --> 00:10:34,020
And so one thing that we're working on is actually making

00:10:35,150 --> 00:10:37,600
bringing allocation to compile time.

00:10:37,600 --> 00:10:40,323
So we wanna allow new expressions inside constexpr,

00:10:42,760 --> 00:10:45,490
and we also need to make standard allocator work

00:10:45,490 --> 00:10:47,400
at compile time, because that is

00:10:47,400 --> 00:10:49,410
what the standard containers use.

00:10:49,410 --> 00:10:51,860
And another thing that this paper does is

00:10:51,860 --> 00:10:54,690
what we call the promotion to static storage,

00:10:54,690 --> 00:10:56,090
which I'll talk about later.

00:10:57,310 --> 00:11:00,760
So the idea basically is to make the following valid.

00:11:00,760 --> 00:11:05,300
So if you look on line three, here, I'm allocating an array.

00:11:05,300 --> 00:11:07,370
And I don't recommend doing that.

00:11:07,370 --> 00:11:08,520
You should be using std::vector,

00:11:08,520 --> 00:11:11,930
but I'm just trying to illustrate, so

00:11:11,930 --> 00:11:13,270
so the idea here is that you can

00:11:13,270 --> 00:11:16,160
actually allocate at compile time, and on line 13 you can

00:11:16,160 --> 00:11:18,750
also de-allocate at compile time.

00:11:18,750 --> 00:11:22,260
So what the compiler does there is pretty simple, actually.

00:11:22,260 --> 00:11:23,760
You have to remember that when

00:11:23,760 --> 00:11:26,120
you're executing a constexpr function,

00:11:26,120 --> 00:11:28,060
you're really running inside the compiler.

00:11:28,060 --> 00:11:30,310
It's an interpreter for the C++ language,

00:11:30,310 --> 00:11:32,410
actually for a subset of the C++ language.

00:11:33,600 --> 00:11:37,590
And so what happens there is you request memory

00:11:37,590 --> 00:11:41,140
and the compiler is not gonna an array of ints, of course.

00:11:41,140 --> 00:11:44,520
It's gonna allocate a data structure inside the compiler,

00:11:44,520 --> 00:11:47,455
interpreter, that represents an array of ints,

00:11:47,455 --> 00:11:49,263
that's what it's gonna give back to you.

00:11:52,450 --> 00:11:56,010
So what we're saying basically is we're just expanding

00:11:56,010 --> 00:11:58,520
the subset of the language that the interpreter

00:11:58,520 --> 00:12:01,190
that exists inside the compiler,

00:12:01,190 --> 00:12:02,820
the subset that it supports.

00:12:02,820 --> 00:12:04,470
We're just expanding that subset.

00:12:06,750 --> 00:12:09,280
And so once we've got that and this is

00:12:10,680 --> 00:12:14,860
this is gonna be in C++20, unless things go really wrong.

00:12:14,860 --> 00:12:18,003
This is making progress inside the committee.

00:12:19,090 --> 00:12:21,020
And so once we've got that, obviously

00:12:21,020 --> 00:12:23,320
we should be making standard vector constexpr.

00:12:24,190 --> 00:12:25,740
So let's go and try to do that.

00:12:27,126 --> 00:12:30,670
Problems is it doesn't work because vector uses try-catch

00:12:31,670 --> 00:12:33,490
for exception

00:12:35,600 --> 00:12:38,420
to give the exception guarantees in push_back

00:12:38,420 --> 00:12:40,120
and other functions like that.

00:12:40,120 --> 00:12:43,410
And so if you try to actually just make vector constexpr,

00:12:43,410 --> 00:12:46,167
even with the rest of the paper,

00:12:46,167 --> 00:12:47,883
you realize that it doesn't work.

00:12:48,770 --> 00:12:50,970
And so it's turtles all the way down.

00:12:50,970 --> 00:12:55,103
You go and you allow try-catch blocks inside constexpr.

00:12:56,160 --> 00:12:57,570
And so this is what we're doing.

00:12:57,570 --> 00:13:00,960
We're also allowing, enabling, try-catch blocks

00:13:00,960 --> 00:13:02,363
inside constexpr functions.

00:13:06,560 --> 00:13:09,480
The idea here is that currently

00:13:10,800 --> 00:13:14,023
even if you don't throw, if you have a try-catch block,

00:13:15,480 --> 00:13:16,920
it's not gonna be a constexpr function.

00:13:16,920 --> 00:13:19,040
If syntactically there is try-catch block,

00:13:19,040 --> 00:13:21,478
it can't be a constexpr function,

00:13:21,478 --> 00:13:25,640
so this kind of restriction is quite bad, actually,

00:13:25,640 --> 00:13:27,660
because it prevents us from

00:13:27,660 --> 00:13:29,300
well, in this case, it prevents us

00:13:29,300 --> 00:13:31,370
from making vector constexpr, but

00:13:34,730 --> 00:13:36,630
but the idea is that

00:13:40,440 --> 00:13:41,290
the idea is that

00:13:43,160 --> 00:13:43,993
sorry

00:13:46,220 --> 00:13:49,320
we're not actually making throw statements valid

00:13:49,320 --> 00:13:50,483
inside constexpr, here.

00:13:51,640 --> 00:13:53,860
So, it's not quite as cool as you think.

00:13:53,860 --> 00:13:57,400
You can't throw, so we're just making try-catch blocks valid

00:13:57,400 --> 00:13:59,470
but not throw statements.

00:13:59,470 --> 00:14:02,463
And so let me explain what happens here.

00:14:03,620 --> 00:14:05,810
What happens here is on line 14

00:14:05,810 --> 00:14:09,090
well, okay, so what here is I'm just querying a sub-range

00:14:09,090 --> 00:14:12,395
of an array, and I'm using array.at.

00:14:12,395 --> 00:14:15,880
An array.at can throw, if I reach out of range.

00:14:15,880 --> 00:14:18,600
So that's why I'm using a try-catch block here.

00:14:18,600 --> 00:14:23,180
And on line 14, I'm not reaching outside of the range,

00:14:23,180 --> 00:14:25,763
outside of the bounds, so it's all good.

00:14:26,800 --> 00:14:31,300
On line 15 though, I'm accessing the array outside

00:14:31,300 --> 00:14:32,850
of the bounds, so I'm throwing.

00:14:33,740 --> 00:14:37,790
And this is where it fails.

00:14:37,790 --> 00:14:39,740
It doesn't fail in the try-catch,

00:14:39,740 --> 00:14:44,500
it actually fails when I throw inside array at,

00:14:44,500 --> 00:14:47,820
because I haven't allowed throw expressions

00:14:47,820 --> 00:14:48,833
inside constexpr.

00:14:52,040 --> 00:14:55,870
And the reason why we're not doing that right now is because

00:14:55,870 --> 00:14:59,200
it would require the constexpr evaluator

00:14:59,200 --> 00:15:02,850
to actually support exception handling properly,

00:15:02,850 --> 00:15:06,090
which includes stack unwinding and other things like that.

00:15:06,090 --> 00:15:09,510
And doing that at compile time is crazy.

00:15:09,510 --> 00:15:12,980
I'm way, way, way too scared of being stabbed in my sleep

00:15:12,980 --> 00:15:15,590
by a compiler implementer to actually propose that.

00:15:15,590 --> 00:15:17,960
So instead what we're doing is we're just saying,

00:15:17,960 --> 00:15:19,993
okay, you can have a try-catch block,

00:15:20,950 --> 00:15:22,140
but you can never throw.

00:15:22,140 --> 00:15:23,220
Throw, right?

00:15:23,220 --> 00:15:27,700
So if you throw, the expression as a whole is gonna be

00:15:27,700 --> 00:15:30,830
not a constant expression, which means that if you try to

00:15:32,000 --> 00:15:33,790
initialize a constexpr variable from that,

00:15:33,790 --> 00:15:36,400
you get a compile-time error, which is what you get today.

00:15:36,400 --> 00:15:41,400
So in the future, we can absolutely extend that.

00:15:41,530 --> 00:15:43,330
I don't think I'm gonna be the one writing that paper,

00:15:43,330 --> 00:15:45,150
because like I said, I'm a little scared.

00:15:45,150 --> 00:15:49,770
But it is technically possible to allow throwing exceptions

00:15:49,770 --> 00:15:52,490
and catching them, and doing all that kind of stuff.

00:15:52,490 --> 00:15:54,250
But for now what we're doing is we're just

00:15:54,250 --> 00:15:57,640
syntactically allowing try-catch blocks,

00:15:57,640 --> 00:15:58,830
but there are basically no ops,

00:15:58,830 --> 00:16:00,780
because you can never throw.

00:16:00,780 --> 00:16:02,353
Does that make sense for everyone?

00:16:04,590 --> 00:16:06,100
So that way we can

00:16:06,100 --> 00:16:07,250
this is like the shortest path

00:16:07,250 --> 00:16:10,220
towards making vector constexpr, basically.

00:16:10,220 --> 00:16:12,530
And so if we go back to standard vector,

00:16:12,530 --> 00:16:14,203
in C++20 this should just work.

00:16:15,110 --> 00:16:17,680
So you can just have a standard vector inside constexpr,

00:16:17,680 --> 00:16:19,920
so you can push_back, everything's nice.

00:16:19,920 --> 00:16:21,120
If you get

00:16:21,120 --> 00:16:23,750
if push_back throws for some reason,

00:16:23,750 --> 00:16:26,770
even though there's a try-catch somewhere in there,

00:16:26,770 --> 00:16:28,620
or even if you try to actually catch it,

00:16:28,620 --> 00:16:32,090
like catch bad alloc at compile time, it's not gonna work.

00:16:32,090 --> 00:16:34,460
You're gonna get a hard error, basically.

00:16:34,460 --> 00:16:36,610
The compiler is gonna say, you can't throw.

00:16:37,960 --> 00:16:38,793
Make sense?

00:16:42,120 --> 00:16:43,630
And so one thing that I mentioned

00:16:43,630 --> 00:16:46,430
but didn't explain is promotion to static storage,

00:16:46,430 --> 00:16:51,430
which we also call non-transient allocation, for standard

00:16:51,560 --> 00:16:55,093
for people that like the core working group.

00:16:56,350 --> 00:16:58,880
So, promotion to static storage essentially is

00:17:01,920 --> 00:17:03,760
answers the question of what happens

00:17:03,760 --> 00:17:07,710
when a constexpr object is used at run time.

00:17:07,710 --> 00:17:11,283
What happens when it leaks to the run-time contexts.

00:17:13,095 --> 00:17:14,193
So imagine this.

00:17:17,470 --> 00:17:20,770
Imagine this here, where I have a constexpr vector

00:17:20,770 --> 00:17:22,810
with a lookup table, which is a lookup table,

00:17:22,810 --> 00:17:27,680
and everything is filled up at compile time.

00:17:27,680 --> 00:17:29,180
But then I use it at run time.

00:17:30,060 --> 00:17:32,640
I use it by accessing

00:17:34,520 --> 00:17:37,740
accessing the table at indices that are only known

00:17:37,740 --> 00:17:40,530
at run time, so I don't in advance which parts

00:17:40,530 --> 00:17:43,033
of my lookup table I'm gonna be accessing.

00:17:44,200 --> 00:17:47,760
And because I don't know that in advance,

00:17:47,760 --> 00:17:49,570
it means that the compiler somehow has

00:17:49,570 --> 00:17:52,510
to store the full table in the program.

00:17:52,510 --> 00:17:54,300
It has to be all there, because I could be accessing

00:17:54,300 --> 00:17:55,700
any parts of it at run time.

00:17:57,210 --> 00:17:58,860
So we need to make that possible.

00:17:59,910 --> 00:18:01,680
So how does that work?

00:18:01,680 --> 00:18:04,473
Well, it's actually pretty simple.

00:18:06,010 --> 00:18:07,860
There are a couple of rules here.

00:18:07,860 --> 00:18:12,860
So if a constexpr allocation leaks to the run time,

00:18:13,200 --> 00:18:17,273
if you use it basically beyond constexpr.

00:18:18,230 --> 00:18:22,260
And if the destructor would clean up the allocation,

00:18:22,260 --> 00:18:26,110
if it were called, because here the vector

00:18:26,110 --> 00:18:27,640
it's a constexpr vector, the destructor is

00:18:27,640 --> 00:18:28,733
never really called.

00:18:30,650 --> 00:18:32,760
So if running the destructor would

00:18:32,760 --> 00:18:35,070
actually clean up the allocation,

00:18:35,070 --> 00:18:37,530
then we promote it to static storage.

00:18:37,530 --> 00:18:39,383
That's kind of the idea, here.

00:18:40,650 --> 00:18:44,390
So that's actually nothing new if you think about this,

00:18:44,390 --> 00:18:45,930
because if I turn this into a std::array

00:18:45,930 --> 00:18:47,653
instead of a std::vector,

00:18:49,248 --> 00:18:52,830
I'm already putting that in the data segment.

00:18:52,830 --> 00:18:55,180
I'm already promoting to static storage, today.

00:18:56,030 --> 00:18:57,480
So this is nothing new.

00:18:57,480 --> 00:18:59,100
The main difference is that here

00:18:59,100 --> 00:19:02,800
you have a contiguous chunk of the data segment,

00:19:02,800 --> 00:19:04,010
which represents your array.

00:19:04,010 --> 00:19:06,830
Whereas in the standard vector case,

00:19:06,830 --> 00:19:09,190
you have a little place in your data segment,

00:19:09,190 --> 00:19:11,130
which is the three pointers,

00:19:11,130 --> 00:19:13,480
which point somewhere else in your data segment

00:19:14,810 --> 00:19:18,000
to a contiguous block of memory that represents the vector.

00:19:18,000 --> 00:19:21,060
So basically we're making it possible to serialize

00:19:21,060 --> 00:19:23,940
a little more complex data structures to the data segment,

00:19:23,940 --> 00:19:25,623
that's kind of a way to see that.

00:19:26,940 --> 00:19:28,180
Sure.

00:19:28,180 --> 00:19:29,990
Can you go to the mic, please.

00:19:33,720 --> 00:19:35,780
- [Audience Member] If you have the vector

00:19:36,930 --> 00:19:40,980
and during run time, you expand that vector

00:19:42,050 --> 00:19:44,220
what-- - And you what at run time?

00:19:44,220 --> 00:19:46,250
- [Audience Member] Expand the vector.

00:19:46,250 --> 00:19:49,250
- All right, so you can't expand the vector at run time,

00:19:49,250 --> 00:19:52,930
because it's a constexpr vector.

00:19:52,930 --> 00:19:55,500
So you cannot call any non-const methods on it.

00:19:55,500 --> 00:19:57,603
And actually I'm gonna delay questions to the end,

00:19:57,603 --> 00:19:59,830
just because I wanna make sure I don't run out of time.

00:19:59,830 --> 00:20:01,793
But you can note the slide number.

00:20:03,095 --> 00:20:05,960
So it's a constexpr variable, which means that you can't

00:20:05,960 --> 00:20:07,250
actually modify, you cannot call

00:20:07,250 --> 00:20:08,450
any non-const methods on it.

00:20:08,450 --> 00:20:13,450
So you compute the data structure, and then you burn it

00:20:14,520 --> 00:20:17,250
into the data segment, and it doesn't change anymore.

00:20:17,250 --> 00:20:19,570
But you are free to look up in the data structure,

00:20:19,570 --> 00:20:21,270
you're free to use it as you wish.

00:20:24,680 --> 00:20:27,700
And so one interesting thing here

00:20:27,700 --> 00:20:30,480
in the way we're wording these changes is that

00:20:30,480 --> 00:20:32,190
if executing the destructor would

00:20:32,190 --> 00:20:36,690
not clean up the allocations that are leaking to run time,

00:20:36,690 --> 00:20:38,500
then it is not a constant expression.

00:20:38,500 --> 00:20:40,740
So you get a compiler error, because you're trying

00:20:40,740 --> 00:20:42,940
to basically assign something that is

00:20:42,940 --> 00:20:46,623
not a constant expression to a constexpr variable.

00:20:49,450 --> 00:20:51,580
Take a minute to think about that.

00:20:51,580 --> 00:20:52,413
This means

00:20:54,430 --> 00:20:55,623
that has a corollary,

00:20:56,560 --> 00:20:59,383
if you can call a function at compile time,

00:21:01,100 --> 00:21:03,040
it means that it is leak-free for the set of inputs

00:21:03,040 --> 00:21:04,040
that you provide it.

00:21:05,670 --> 00:21:06,670
This is pretty cool.

00:21:07,530 --> 00:21:09,772
We're putting Valogran out of business.

00:21:09,772 --> 00:21:12,850
(audience laughing)

00:21:12,850 --> 00:21:16,270
So, you actually have a leak checker inside your compiler,

00:21:16,270 --> 00:21:18,320
that way, which is really cool.

00:21:18,320 --> 00:21:21,860
I would not rely on that only to check your leaks,

00:21:21,860 --> 00:21:24,610
because you're not actually using systems_malloc,

00:21:24,610 --> 00:21:26,980
and you're running basically inside an interpreter,

00:21:26,980 --> 00:21:28,600
which is not quite the real thing.

00:21:28,600 --> 00:21:31,850
But it's still pretty impressive.

00:21:31,850 --> 00:21:35,080
And actually if you have a friend or coworker

00:21:35,080 --> 00:21:37,210
that's a compiler engineer, buy them drink,

00:21:37,210 --> 00:21:39,130
because this like

00:21:39,130 --> 00:21:40,090
this is huge.

00:21:40,090 --> 00:21:42,840
I mean, the complexity of C++ compilers now is

00:21:42,840 --> 00:21:46,453
such that we have a leak detector at compile time,

00:21:47,500 --> 00:21:48,450
that's pretty cool.

00:21:52,090 --> 00:21:54,560
And so we've got other things that we

00:21:54,560 --> 00:21:56,857
in the pipeline for constexpr,

00:21:58,600 --> 00:22:01,920
like basically library-level additions.

00:22:01,920 --> 00:22:04,110
And so one of them is standard string,

00:22:04,110 --> 00:22:05,840
which is quite obvious.

00:22:05,840 --> 00:22:08,390
Once you can allocate, why not have standard string work

00:22:08,390 --> 00:22:09,223
at compile time?

00:22:10,120 --> 00:22:11,810
So there are some challenges to that,

00:22:11,810 --> 00:22:13,760
which I can explain a little bit later,

00:22:13,760 --> 00:22:15,530
but this is in the pipeline.

00:22:15,530 --> 00:22:17,390
The paper is like half-written,

00:22:17,390 --> 00:22:19,970
so I'm gonna try to get this one for San Diego

00:22:21,210 --> 00:22:23,150
in a couple of weeks.

00:22:23,150 --> 00:22:24,950
And so standard string should work at compile time.

00:22:24,950 --> 00:22:26,560
There's no reason not to.

00:22:26,560 --> 00:22:28,820
And then standard map, unordered_map.

00:22:28,820 --> 00:22:30,853
Set and an unordered set, why not?

00:22:31,770 --> 00:22:32,910
Why stop anywhere?

00:22:32,910 --> 00:22:34,510
Where do we have to stop, right?

00:22:38,080 --> 00:22:39,480
All these data structures, I don't see

00:22:39,480 --> 00:22:43,143
any reason why they wouldn't be constexpr-friendly, really,

00:22:43,143 --> 00:22:45,113
with the new allocation changes.

00:22:46,440 --> 00:22:47,543
Optional variant.

00:22:48,420 --> 00:22:50,683
Everybody likes them, expected.

00:22:52,230 --> 00:22:55,080
All of these helper classes should

00:22:55,080 --> 00:22:57,650
it should be possible to make most of them constexpr.

00:22:57,650 --> 00:22:59,880
Some of them might use dirty tricks,

00:22:59,880 --> 00:23:02,360
like reinterpret cast and things like that, internally.

00:23:02,360 --> 00:23:05,120
So, we're gonna have to be really careful about that.

00:23:05,120 --> 00:23:06,900
So, we still need to survey some of them,

00:23:06,900 --> 00:23:10,070
but at least for standard string and standard map and set,

00:23:10,070 --> 00:23:13,540
maybe not the unordered variants but

00:23:13,540 --> 00:23:16,320
for map and set, I'm pretty sure we should be able

00:23:16,320 --> 00:23:17,633
to have them constexpr.

00:23:18,840 --> 00:23:21,253
Maybe by '20 or '23, depending.

00:23:23,900 --> 00:23:26,210
And the math functions, I know there is a lot

00:23:26,210 --> 00:23:27,500
of people that want that, because then

00:23:27,500 --> 00:23:32,150
you could precompute tables that include

00:23:32,150 --> 00:23:35,100
that use the math functions, so that would be quite useful.

00:23:35,100 --> 00:23:37,393
Another thing is standard thread.

00:23:38,500 --> 00:23:39,386
I'm just kidding.

00:23:39,386 --> 00:23:41,900
(audience laughing)

00:23:41,900 --> 00:23:44,420
That's the way to solve the compile time problem,

00:23:44,420 --> 00:23:47,630
just compile multi-threaded, everything's fine.

00:23:47,630 --> 00:23:48,900
So the little smiley there is me

00:23:48,900 --> 00:23:49,970
after getting punched in the face

00:23:49,970 --> 00:23:51,250
by a compiler implementer.

00:23:51,250 --> 00:23:53,350
(audience laughing)

00:23:53,350 --> 00:23:55,460
And so honestly there's almost no limit

00:23:55,460 --> 00:23:57,590
to what we can do there, I think.

00:23:57,590 --> 00:23:59,460
It's just about surveying

00:23:59,460 --> 00:24:01,850
the standard library implementation.

00:24:01,850 --> 00:24:03,330
So you go there, you look at it,

00:24:03,330 --> 00:24:04,700
and you're like, all right, what do I need

00:24:04,700 --> 00:24:06,880
in the language in order to just throw

00:24:06,880 --> 00:24:08,613
like to span constexpr everywhere.

00:24:09,499 --> 00:24:13,350
And usually there's not a lot missing.

00:24:13,350 --> 00:24:15,360
With the few papers that we've added,

00:24:15,360 --> 00:24:17,270
usually there's not gonna be a lot of stuff missing.

00:24:17,270 --> 00:24:21,020
So if you have your personal preference

00:24:21,020 --> 00:24:24,080
for having something constexpr, just go and produce a paper,

00:24:24,080 --> 00:24:25,740
I think that that

00:24:25,740 --> 00:24:28,140
if you survey the implementation and your confident

00:24:28,140 --> 00:24:30,030
that we can make it happen,

00:24:30,030 --> 00:24:31,180
and then you can defend your case,

00:24:31,180 --> 00:24:33,380
I don't see any reason not to do it, really.

00:24:34,500 --> 00:24:36,640
However, there are some challenges.

00:24:36,640 --> 00:24:40,270
So, if you do survey one of the implementations,

00:24:40,270 --> 00:24:42,950
which is what I did for vector and string,

00:24:42,950 --> 00:24:46,450
you run into a few problems like reinterpret_cast

00:24:46,450 --> 00:24:48,913
or any kind of dirty trick like that.

00:24:49,800 --> 00:24:52,160
For example, we used some dirty tricks when implementing

00:24:52,160 --> 00:24:55,630
the small string optimization for std::string,

00:24:55,630 --> 00:24:57,860
so we have to work around these things.

00:24:57,860 --> 00:25:00,830
Sometimes, we use built-ins that are not constexpr-friendly

00:25:00,830 --> 00:25:02,703
as well, so we need to work on those.

00:25:04,020 --> 00:25:05,910
And there are some things we can't do,

00:25:05,910 --> 00:25:07,870
like raw memory allocation.

00:25:07,870 --> 00:25:09,380
There's just no way we can do that.

00:25:09,380 --> 00:25:12,240
So, allocating with new is fine,

00:25:12,240 --> 00:25:15,120
because you tell the compiler which type you're allocating.

00:25:15,120 --> 00:25:17,340
Allocating malloc is not, because you're not telling

00:25:17,340 --> 00:25:19,210
the compiler which type you're allocating.

00:25:19,210 --> 00:25:22,060
And actually, I wanna pause on that, and really

00:25:23,170 --> 00:25:24,770
something needs to sink in here.

00:25:25,750 --> 00:25:27,200
At compile time, we need to catch

00:25:27,200 --> 00:25:30,260
all the undefined behavior, it's super important.

00:25:30,260 --> 00:25:32,920
If the compiler can't catch all the undefined behavior

00:25:32,920 --> 00:25:37,340
at compile time, it means that it can run.

00:25:37,340 --> 00:25:40,240
If we can induce a compiler into UB,

00:25:40,240 --> 00:25:42,500
it means that the result of running the compiler,

00:25:42,500 --> 00:25:45,050
your compilation, is whatever.

00:25:45,050 --> 00:25:46,367
So, you could crash the compiler,

00:25:46,367 --> 00:25:48,610
but you could also produce an invalid program,

00:25:48,610 --> 00:25:51,290
or you could produce a program that is valid

00:25:51,290 --> 00:25:53,080
but doesn't do what you want.

00:25:53,080 --> 00:25:55,853
So at that point, it's super scary.

00:25:57,010 --> 00:25:59,800
So, the compiler has to catch all the UB at compile time.

00:25:59,800 --> 00:26:01,860
It has to track everything,

00:26:01,860 --> 00:26:03,820
which is why we have some limitations, so

00:26:03,820 --> 00:26:06,783
like reinterpret_cast and raw memory allocation, like that.

00:26:08,040 --> 00:26:09,490
There is almost no way we can do that,

00:26:09,490 --> 00:26:11,440
because the compiler would have to track

00:26:11,440 --> 00:26:13,258
every single thing you do with a chunk of memory.

00:26:13,258 --> 00:26:15,790
It just ended you to make sure

00:26:15,790 --> 00:26:17,953
that you're never shooting yourself in the foot,

00:26:20,330 --> 00:26:22,100
which is very, very difficult.

00:26:22,100 --> 00:26:26,033
And that's something that scares implementers a lot.

00:26:28,930 --> 00:26:31,760
So raw memory allocation, we probably will

00:26:31,760 --> 00:26:34,110
it's not clear that we're gonna do it ever.

00:26:34,110 --> 00:26:36,270
And there is other annotations if you look

00:26:36,270 --> 00:26:38,270
at your C++ standard library.

00:26:38,270 --> 00:26:40,910
There's other added annotations like UBSan

00:26:40,910 --> 00:26:42,910
or ASAN or things like that

00:26:44,738 --> 00:26:46,100
that are used, and we

00:26:46,100 --> 00:26:49,070
they're inherently not constexpr-friendly,

00:26:49,070 --> 00:26:50,770
so we need to work around as well.

00:26:52,110 --> 00:26:57,110
And so this is where actually P0595 Enter comes into play,

00:26:57,520 --> 00:26:59,980
so this paper adds a way to detect

00:26:59,980 --> 00:27:04,633
whether the current evaluation is a constexpr evaluation.

00:27:05,678 --> 00:27:08,970
And this is a expert-friendly

00:27:08,970 --> 00:27:12,340
I would say even expert-only feature.

00:27:12,340 --> 00:27:14,740
It seems like

00:27:14,740 --> 00:27:16,580
it looks like a simple feature but it's not.

00:27:16,580 --> 00:27:17,780
It's really, really not.

00:27:19,140 --> 00:27:21,470
It has a lot of pitfalls, but it's really necessary

00:27:21,470 --> 00:27:23,830
if you wanna implement any non-trivial thing,

00:27:23,830 --> 00:27:27,000
non-trivial standard container at compile time.

00:27:27,000 --> 00:27:30,790
So what this does, like I said, is basically it allows you

00:27:30,790 --> 00:27:35,590
to detect whether the current function is being evaluated

00:27:35,590 --> 00:27:38,210
as part as a constant initializer.

00:27:38,210 --> 00:27:42,700
And so for example, if you wanna make vector clear constexpr

00:27:44,980 --> 00:27:47,470
you run into the problem that we have ASAN annotations

00:27:47,470 --> 00:27:50,460
and debug mode annotations, like I said earlier.

00:27:50,460 --> 00:27:53,170
And these annotations are inherently non-constexpr-friendly.

00:27:53,170 --> 00:27:54,520
There's no way, they don't make sense

00:27:54,520 --> 00:27:56,590
at all at compile time.

00:27:56,590 --> 00:27:58,033
So, we can't execute them.

00:27:59,255 --> 00:28:03,460
You have basically like three options here.

00:28:03,460 --> 00:28:05,930
Either you give up, and you just say, all right,

00:28:05,930 --> 00:28:08,720
too bad, vector clear is never gonna be constexpr.

00:28:08,720 --> 00:28:11,960
Or you remove the annotations, but then you're pessimizing.

00:28:11,960 --> 00:28:13,900
Well, you're not in that case, you're not pessimizing,

00:28:13,900 --> 00:28:17,880
but you're making your implementation worse at run time,

00:28:17,880 --> 00:28:20,480
which is the case that we almost always care about.

00:28:20,480 --> 00:28:25,415
So we don't wanna prevent implementations

00:28:25,415 --> 00:28:29,310
from having nice features, just because

00:28:29,310 --> 00:28:31,490
we need to restrict ourselves to this set,

00:28:31,490 --> 00:28:35,360
that constexpr support, so that's not really good.

00:28:35,360 --> 00:28:37,840
Or you do what we're about to do,

00:28:37,840 --> 00:28:39,820
which is you basically switch

00:28:39,820 --> 00:28:42,790
on whether you're being evaluated at compile time.

00:28:42,790 --> 00:28:46,670
So it's not pretty, it's not great,

00:28:46,670 --> 00:28:50,500
but this is why I said it's an expert-only feature,

00:28:50,500 --> 00:28:52,707
where expect your standard library implementer to use

00:28:52,707 --> 00:28:57,707
that kind of stuff to give you the ability to not care

00:28:58,170 --> 00:29:01,300
about whether you're in constexpr context or not.

00:29:01,300 --> 00:29:05,790
So in standard vector, if we are in a

00:29:05,790 --> 00:29:08,550
in a constant evaluation,

00:29:08,550 --> 00:29:10,833
then we're just gonna skip all these annotations.

00:29:10,833 --> 00:29:13,083
They're not gonna be enabled at compile time.

00:29:14,310 --> 00:29:17,173
And so the way this works is a little bit tricky.

00:29:18,060 --> 00:29:20,190
It's a little bit tricky, so

00:29:21,470 --> 00:29:23,560
on line eight here,

00:29:23,560 --> 00:29:27,160
I call F, and then F will call vector v.clear,

00:29:27,160 --> 00:29:30,000
so vector.clear, and inside vector.clear there is

00:29:30,000 --> 00:29:32,103
this is_constant_evaluated

00:29:33,770 --> 00:29:34,603
call being made.

00:29:36,160 --> 00:29:41,160
And the idea is because X is a constexpr variable,

00:29:41,620 --> 00:29:46,620
the right-hand side has to be a constant initializer, and

00:29:48,670 --> 00:29:49,503
and because of that

00:29:49,503 --> 00:29:51,250
because it has to be a constant initializer,

00:29:51,250 --> 00:29:53,380
the magic function is_constant_evaluated

00:29:53,380 --> 00:29:54,623
is gonna return true,

00:29:55,510 --> 00:30:00,143
and then we're gonna skip the ASAN annotations right here,

00:30:01,120 --> 00:30:04,590
which means that we're not be running anything

00:30:04,590 --> 00:30:06,350
that is not constexpr-friendly.

00:30:06,350 --> 00:30:09,250
And so the expression as a whole is a constant expression.

00:30:10,490 --> 00:30:14,520
In the case of line 11, Y does not require

00:30:14,520 --> 00:30:17,010
a constant initializer.

00:30:17,010 --> 00:30:19,300
I mean, surely the compiler can figure out

00:30:19,300 --> 00:30:20,960
that all of this stuff is

00:30:20,960 --> 00:30:23,860
it sees everything, all this stuff is it could be folded,

00:30:23,860 --> 00:30:27,640
but the core language does not require the right-hand side

00:30:27,640 --> 00:30:30,250
there to be a constant expression.

00:30:30,250 --> 00:30:34,923
And because of that is_constant_evaluated will return false.

00:30:36,010 --> 00:30:39,410
And so we're gonna have the normal run-time code there.

00:30:39,410 --> 00:30:41,230
So this is kind of tricky, because at first

00:30:41,230 --> 00:30:43,300
when I was shown that, I was like, well,

00:30:43,300 --> 00:30:46,290
F in both cases is called the same way,

00:30:46,290 --> 00:30:50,490
and I mean it seems like clearly the compiler should fold

00:30:50,490 --> 00:30:52,040
both of them, but this is

00:30:52,040 --> 00:30:55,193
not how is_constant_evaluated works.

00:30:58,340 --> 00:31:00,960
So another common problem that we have is that constexpr

00:31:00,960 --> 00:31:03,010
does not actually require compile-time evaluation.

00:31:03,010 --> 00:31:05,650
So raise your hand if you've ran into that situation

00:31:05,650 --> 00:31:07,680
where you're not quite sure whether it's being done

00:31:07,680 --> 00:31:09,000
at compile time or not.

00:31:09,000 --> 00:31:10,100
Yes, right.

00:31:10,100 --> 00:31:11,650
So, it's a very common problem.

00:31:12,920 --> 00:31:15,960
And it actually extends way beyond just like,

00:31:15,960 --> 00:31:18,230
oh, I wish I knew whether it was done

00:31:18,230 --> 00:31:19,630
at compile time or run time.

00:31:19,630 --> 00:31:21,660
Sometimes, it's like if it

00:31:21,660 --> 00:31:23,850
for some things that we wanna do with reflection,

00:31:23,850 --> 00:31:26,540
which I'll get to later, it does not make sense.

00:31:26,540 --> 00:31:30,693
It would be dangerous if anything leaked to the run time.

00:31:31,560 --> 00:31:32,760
I'll explain that later.

00:31:34,120 --> 00:31:36,320
So what we wanna do is have basically a function,

00:31:36,320 --> 00:31:39,010
which is exclusively a compile-time function.

00:31:39,010 --> 00:31:41,910
There can't be any code generated for that function, ever.

00:31:44,430 --> 00:31:45,670
And so we're adding

00:31:46,960 --> 00:31:48,890
a new

00:31:48,890 --> 00:31:53,890
keyword, which means please constexpr, this, do it.

00:31:54,890 --> 00:31:56,900
It's not a suggestion, it's not, maybe constexpr.

00:31:56,900 --> 00:31:58,850
It's like, no, no, seriously constexpr.

00:32:00,020 --> 00:32:02,550
And so the way these functions

00:32:02,550 --> 00:32:05,160
we call them immediate functions.

00:32:05,160 --> 00:32:08,790
And the way to think about them is sort of as being a

00:32:11,748 --> 00:32:14,300
a kind of like a Unimacro kind of.

00:32:14,300 --> 00:32:18,160
Basically, when the compiler sees square of three

00:32:18,160 --> 00:32:20,700
on line five here, it just says, all right,

00:32:20,700 --> 00:32:22,010
that's an immediate function.

00:32:22,010 --> 00:32:24,390
Let me go and evaluate that right away.

00:32:24,390 --> 00:32:27,170
So, it folds everything, it just does constexpr evaluation

00:32:27,170 --> 00:32:30,030
and then it evaluates the function right there.

00:32:30,030 --> 00:32:32,880
There is never ever any code generated.

00:32:32,880 --> 00:32:35,700
And actually, if you try to call it with something

00:32:35,700 --> 00:32:37,400
that is not a constant expression,

00:32:38,510 --> 00:32:41,840
it's gonna say, oh, this is an immediate function.

00:32:41,840 --> 00:32:43,470
I can't generate code for that.

00:32:43,470 --> 00:32:46,883
I can't evaluate that at run time, that's a hard error.

00:32:48,603 --> 00:32:50,713
- [Audience Member] What linkage do these functions have?

00:32:50,713 --> 00:32:53,500
- What linkage do these functions have?

00:32:53,500 --> 00:32:54,950
You can't take their address.

00:32:56,270 --> 00:32:58,330
They don't exist at run time at all.

00:32:58,330 --> 00:33:01,370
They absolutely don't exist at run time.

00:33:01,370 --> 00:33:04,340
So this actually has some very nice benefits.

00:33:04,340 --> 00:33:06,360
I think we expect those to

00:33:08,320 --> 00:33:11,640
to have some very large compile-time benefits,

00:33:11,640 --> 00:33:15,040
because there's no code gen, they're much simpler.

00:33:15,040 --> 00:33:17,220
But they're also more limited, you can't take their address,

00:33:17,220 --> 00:33:18,820
you can't do that kind of stuff.

00:33:21,262 --> 00:33:24,560
(audience member applauding)

00:33:24,560 --> 00:33:27,490
I'm seeing some support there, that's great.

00:33:27,490 --> 00:33:31,360
And so to summarize the constexpr changes,

00:33:31,360 --> 00:33:34,250
so basically what we wanna do here is expand constexpr

00:33:34,250 --> 00:33:37,370
to support more use cases, that's the general trend.

00:33:37,370 --> 00:33:39,950
And we wanna allow persisting data structures

00:33:39,950 --> 00:33:41,063
to the data segment.

00:33:42,570 --> 00:33:44,310
And we also wanna allow

00:33:44,310 --> 00:33:46,930
well, we don't really want to actually, we kind of have to.

00:33:46,930 --> 00:33:49,710
But we have to make it possible to sometimes say,

00:33:49,710 --> 00:33:52,150
all right, constexpr is failing me,

00:33:52,150 --> 00:33:55,290
so I'm just gonna say if I'm running inside constexpr,

00:33:55,290 --> 00:33:56,910
then do something else.

00:33:56,910 --> 00:33:59,533
So, that's also something that we're allowing.

00:34:01,420 --> 00:34:03,430
Even though we don't really like doing that.

00:34:03,430 --> 00:34:06,930
And then we also allow requiring compile time evaluation,

00:34:06,930 --> 00:34:08,313
using constexpr-bang.

00:34:09,380 --> 00:34:10,520
Not exactly sure that's the keyword

00:34:10,520 --> 00:34:12,170
that's gonna stay, but we'll see.

00:34:13,690 --> 00:34:14,523
So do I have any

00:34:14,523 --> 00:34:17,670
do you have any questions on kind of this section?

00:34:17,670 --> 00:34:18,503
Yeah.

00:34:20,020 --> 00:34:22,450
I'll take just one or two.

00:34:22,450 --> 00:34:25,680
- [Audience Member] So constexpr-exclamation-mark

00:34:25,680 --> 00:34:28,130
forces functions to be evaluated at compile time.

00:34:29,583 --> 00:34:33,500
I wonder why this design choice, except of an annotation

00:34:33,500 --> 00:34:35,500
at the call site of the constexpr function,

00:34:35,500 --> 00:34:38,280
to say that it should be evaluated at compile time?

00:34:38,960 --> 00:34:39,800
- Right.

00:34:41,020 --> 00:34:42,360
- [Audience Member] Why would I need to write the functions

00:34:42,360 --> 00:34:46,850
twice, the same function twice to give this contract

00:34:46,850 --> 00:34:48,540
instead of just specifying at the call site

00:34:48,540 --> 00:34:50,490
that I want this function to be evaluated.

00:34:50,490 --> 00:34:52,760
- Okay, so if you wanna allow a function to be called

00:34:52,760 --> 00:34:54,260
both at compile time and at run time,

00:34:54,260 --> 00:34:56,710
then you have a way of doing that, use constexpr.

00:34:57,700 --> 00:34:59,400
That's already what it means.

00:34:59,400 --> 00:35:03,940
This is for functions where you must absolutely

00:35:05,830 --> 00:35:08,030
evaluate them at compile time.

00:35:08,030 --> 00:35:10,930
And the reason why there is no annotation at call site

00:35:10,930 --> 00:35:13,650
is because the compiler needs to know that

00:35:13,650 --> 00:35:15,500
that kind of function is special, and

00:35:18,101 --> 00:35:22,190
it can't know that if it's not part of the declaration

00:35:22,190 --> 00:35:25,060
of the function, so we need that specifier

00:35:25,060 --> 00:35:26,590
to be part of the declaration of the function.

00:35:26,590 --> 00:35:28,630
Nico, and then I'll keep going.

00:35:28,630 --> 00:35:30,213
- [Audience Member] Louis, thank you.

00:35:31,057 --> 00:35:34,810
I'm a little bit confused, because when evaluating

00:35:34,810 --> 00:35:37,080
the new trait to find out whether

00:35:37,080 --> 00:35:41,380
this is a compile-time issue, you use a run-time if,

00:35:41,380 --> 00:35:45,200
so it seems that the run-time if is evaluated now

00:35:45,200 --> 00:35:47,050
at compile time,

00:35:47,050 --> 00:35:49,740
if the content is special,

00:35:49,740 --> 00:35:52,460
the expression is special inside this.

00:35:52,460 --> 00:35:54,840
That sounds like a contradiction to me.

00:35:54,840 --> 00:35:56,600
This here? - Yeah, yes.

00:35:56,600 --> 00:35:58,250
- Okay, actually, this is tricky.

00:36:00,700 --> 00:36:05,700
If you use a if-constexpr, you're gonna introduce a bug.

00:36:05,810 --> 00:36:08,360
This is why I said it's an expert-only feature.

00:36:08,360 --> 00:36:10,640
If you use if-constexpr, suddenly

00:36:12,216 --> 00:36:15,660
is_constant_evaluated is used in a place

00:36:15,660 --> 00:36:17,650
where a constant expression is required,

00:36:17,650 --> 00:36:18,650
so it's always true.

00:36:19,730 --> 00:36:22,880
So, you need to use a run-time if,

00:36:22,880 --> 00:36:25,830
because then the compiler is gonna check,

00:36:25,830 --> 00:36:29,090
am I as a whole, am I a part

00:36:29,090 --> 00:36:33,410
basically is there a root of the evaluation that is

00:36:33,410 --> 00:36:36,023
that requires a constant initializer.

00:36:36,910 --> 00:36:38,140
If you do that in

00:36:38,140 --> 00:36:40,410
so for example, if you use is_constant_evaluated

00:36:40,410 --> 00:36:43,690
in a if-constexpr or to initialize a constexpr-variable

00:36:43,690 --> 00:36:46,330
in that function, or as an array bound

00:36:46,330 --> 00:36:47,780
or something like that, anywhere

00:36:47,780 --> 00:36:52,140
where a constant expression is required, it's always true.

00:36:52,140 --> 00:36:53,580
So that's why I need to use a run-time if.

00:36:53,580 --> 00:36:56,540
So the way to think about this is like, I might be

00:36:56,540 --> 00:36:59,340
like vector clear might be running at run time

00:36:59,340 --> 00:37:02,480
or it might be running at compile time, I don't know.

00:37:02,480 --> 00:37:04,810
I'm gonna use the run-time if here,

00:37:04,810 --> 00:37:07,850
which might actually be running at run time,

00:37:07,850 --> 00:37:10,883
at compile-time rather, if I'm in a constant expression.

00:37:12,020 --> 00:37:13,850
And so you just use a normal run-time if.

00:37:13,850 --> 00:37:15,457
You don't use if-constexpr.

00:37:16,520 --> 00:37:17,800
Really quick.

00:37:17,800 --> 00:37:20,870
- [Audience Member] So, my question is C++ is already known

00:37:20,870 --> 00:37:24,660
to be slow to compile, and now we are

00:37:24,660 --> 00:37:28,080
embedding an interpreter for managed language

00:37:28,080 --> 00:37:30,610
that appears to be very similar to C++.

00:37:30,610 --> 00:37:34,753
So do you foresee any performance impacts on compilation?

00:37:36,090 --> 00:37:36,923
- Okay, so

00:37:39,580 --> 00:37:41,870
this is actually gonna improve compilation times

00:37:41,870 --> 00:37:44,110
tremendously, because instead of

00:37:44,110 --> 00:37:47,450
using template meta-programming to achieve these goals,

00:37:47,450 --> 00:37:50,830
we're gonna use basically a constexpr, which is much better.

00:37:50,830 --> 00:37:54,290
So, template instantiation is a much worse interpreter

00:37:54,290 --> 00:37:56,680
than the actual constexpr interpreter.

00:37:56,680 --> 00:37:57,890
I'm gonna have to keep going.

00:37:57,890 --> 00:38:00,611
You can ask the questions at the end.

00:38:00,611 --> 00:38:02,694
- [Audience Member] Okay.

00:38:04,330 --> 00:38:07,700
- And so now that we have a bunch of stuff

00:38:07,700 --> 00:38:10,350
to do constexpr computations,

00:38:10,350 --> 00:38:12,190
we wanna be able to speak to the compiler.

00:38:12,190 --> 00:38:15,570
We wanna be able to query information from the compiler.

00:38:15,570 --> 00:38:17,560
And so basically what this means is

00:38:17,560 --> 00:38:20,490
just extracting information about types.

00:38:20,490 --> 00:38:22,940
We can already do that, even though we don't

00:38:22,940 --> 00:38:24,650
often think of it that way.

00:38:24,650 --> 00:38:26,910
We already have some reflection.

00:38:26,910 --> 00:38:27,927
We have sizeof.

00:38:29,140 --> 00:38:31,410
It's not fancy reflection,

00:38:31,410 --> 00:38:32,810
but it is some kind of reflection.

00:38:32,810 --> 00:38:34,300
You have a type, and then you query

00:38:34,300 --> 00:38:37,410
some information about it, what's the size.

00:38:37,410 --> 00:38:39,710
We can also ask for things like the alignment.

00:38:41,074 --> 00:38:43,470
In C++11, we have type traits, so you can ask things

00:38:43,470 --> 00:38:46,380
like, are you an aggregate, are you a POD,

00:38:46,380 --> 00:38:48,840
are you a pointer, things like that.

00:38:48,840 --> 00:38:53,840
So we do have some level of reflection here, already.

00:38:53,850 --> 00:38:57,440
But we're limited, and the way we're limited specifically is

00:38:57,440 --> 00:39:00,890
in what kind of answers we can retrieve.

00:39:00,890 --> 00:39:03,160
We can only retrieve

00:39:03,160 --> 00:39:06,080
we can only ask questions where the answer is

00:39:06,080 --> 00:39:07,430
basically a primitive type.

00:39:09,100 --> 00:39:10,180
And if you think about it,

00:39:10,180 --> 00:39:12,000
the reason is because we don't have a way

00:39:12,000 --> 00:39:15,660
I mean, before these constexpr improvements,

00:39:15,660 --> 00:39:17,570
we didn't have a way of representing that.

00:39:17,570 --> 00:39:19,837
So if somebody came to the committee and said,

00:39:19,837 --> 00:39:22,577
"Hey, I wanna add a type trait that returns a list

00:39:22,577 --> 00:39:26,150
"of the members of a struct."

00:39:26,150 --> 00:39:28,740
Immediately, the question would've been like,

00:39:28,740 --> 00:39:33,260
all right, I'm interested, but how do you represent it?

00:39:33,260 --> 00:39:36,260
And before now, we didn't have a really good story for that.

00:39:39,740 --> 00:39:44,310
Obviously, with the changes that we're making to constexpr,

00:39:44,310 --> 00:39:47,030
this answer is gonna be different now.

00:39:47,030 --> 00:39:49,840
And so let's talk about reflection a little bit.

00:39:49,840 --> 00:39:51,460
So the Reflection TS.

00:39:51,460 --> 00:39:54,380
And first of all, a TS is a technical specification.

00:39:54,380 --> 00:39:57,370
The way to think about it is basically a feature branch

00:39:57,370 --> 00:39:59,420
for the standard, so we have the main trunk

00:39:59,420 --> 00:40:01,960
for the standard, which progresses, and then we

00:40:01,960 --> 00:40:04,460
fork off feature branches basically,

00:40:04,460 --> 00:40:07,090
and we work on features, and eventually we merge them

00:40:07,090 --> 00:40:08,270
if everybody is happy.

00:40:08,270 --> 00:40:10,860
That's kind of the way to think about this.

00:40:10,860 --> 00:40:12,630
And so we've been working on a Reflection TS

00:40:12,630 --> 00:40:13,810
for a couple of years.

00:40:13,810 --> 00:40:15,660
And the purpose of the TS is to figure out

00:40:15,660 --> 00:40:17,563
what the query API should be.

00:40:18,940 --> 00:40:21,740
What shouldn't we be able to ask the compiler?

00:40:21,740 --> 00:40:24,520
We don't wanna figure out the specific implementation

00:40:24,520 --> 00:40:26,790
of that API, we just wanna figure out

00:40:26,790 --> 00:40:29,870
what the API is, not really the nitty gritty details

00:40:29,870 --> 00:40:31,370
of what the implementation is.

00:40:32,450 --> 00:40:35,480
And because the TS started several years ago,

00:40:35,480 --> 00:40:38,330
when we didn't have any plans to

00:40:38,330 --> 00:40:41,120
we didn't know that we were gonna go the constexpr way.

00:40:41,120 --> 00:40:43,300
Everything is based on top of template meta-programming

00:40:43,300 --> 00:40:44,133
for now.

00:40:45,160 --> 00:40:49,050
And so an example of using the Reflection TS, here.

00:40:49,050 --> 00:40:53,140
We're extracting members, so I used this new keyword

00:40:53,140 --> 00:40:57,350
called reflexpr to extract a type that represent

00:40:57,350 --> 00:41:02,170
a meta-type that represents basically the type of Foo here.

00:41:02,170 --> 00:41:07,170
So this MetaFoo on line six here is a magic type

00:41:07,520 --> 00:41:10,080
that is essentially implemented as a pointer

00:41:10,080 --> 00:41:13,100
inside the compiler's AST.

00:41:13,100 --> 00:41:15,460
So it's basically a pointer to the AST node

00:41:15,460 --> 00:41:17,730
that represents Foo inside the compiler.

00:41:17,730 --> 00:41:22,113
But it's a magic type, you can't name it really.

00:41:23,590 --> 00:41:26,370
However, that magic type has some meta-functions

00:41:26,370 --> 00:41:28,490
that can be applied to it.

00:41:28,490 --> 00:41:31,500
Here, for example, I'm using get_data_members_t,

00:41:31,500 --> 00:41:33,540
and that returns another magic type.

00:41:33,540 --> 00:41:35,330
There is a lot of magic here.

00:41:35,330 --> 00:41:36,560
It returns another magic type,

00:41:36,560 --> 00:41:38,500
which represents a sequence

00:41:38,500 --> 00:41:41,013
of meta-types representing each member.

00:41:42,220 --> 00:41:44,170
So, it's a little bit like a tuple under the hood.

00:41:44,170 --> 00:41:45,540
You can think of it as a tuple

00:41:45,540 --> 00:41:47,870
basically containing meta-information

00:41:47,870 --> 00:41:49,693
for the members of the struct.

00:41:51,480 --> 00:41:54,490
And so just like a tuple, I have some meta-functions

00:41:54,490 --> 00:41:56,810
that I can use to extract individual elements,

00:41:56,810 --> 00:41:59,350
so get element here, I get the first element.

00:41:59,350 --> 00:42:01,061
And I get back a MetaX,

00:42:01,061 --> 00:42:04,720
which is essentially a meta-type representing

00:42:04,720 --> 00:42:06,970
the first member of a Foo.

00:42:06,970 --> 00:42:10,200
And that is not int, that is some magic pointer

00:42:10,200 --> 00:42:13,643
into the AST, that represents the int, that specific int.

00:42:15,330 --> 00:42:17,900
And then I can query that meta-type,

00:42:17,900 --> 00:42:21,170
extract some information, and finally I can

00:42:21,170 --> 00:42:23,290
actually get the underlying type that it represents,

00:42:23,290 --> 00:42:24,590
which is an int, actually.

00:42:25,960 --> 00:42:27,160
That's a little bit how it works.

00:42:27,160 --> 00:42:31,483
And so if we wanna print an enum here, we can do that.

00:42:31,483 --> 00:42:33,730
It's a little bit tedious because

00:42:33,730 --> 00:42:37,870
it's template meta-programming, but it's totally doable.

00:42:37,870 --> 00:42:41,530
So, I'm not gonna go into much details here, but basically

00:42:41,530 --> 00:42:45,600
I reflect on my color enumeration on line four,

00:42:45,600 --> 00:42:48,593
and I get back a magic sequence of enumerators.

00:42:49,570 --> 00:42:52,150
And then I create some fancy helper lambda,

00:42:52,150 --> 00:42:54,380
using template lambdas here.

00:42:54,380 --> 00:42:58,460
And what this lambda does is it basically calls

00:42:58,460 --> 00:43:01,300
another lambda, I said I loved lambda, didn't I?

00:43:01,300 --> 00:43:03,500
And so it calls another lambda inside

00:43:03,500 --> 00:43:08,380
with each index in order, so I'm using basically

00:43:08,380 --> 00:43:10,440
I'm calling the lambda inside a fold expression,

00:43:10,440 --> 00:43:13,060
with the comma operator, on line 11.

00:43:13,060 --> 00:43:16,840
And so this expands basically to a bunch of ifs,

00:43:16,840 --> 00:43:18,910
one after the other, with each

00:43:19,971 --> 00:43:22,730
for i, starting from zero to N,

00:43:22,730 --> 00:43:25,020
where N is the number of enumerators.

00:43:25,020 --> 00:43:27,490
So I'm expanding ifs, basically that's what I'm doing here.

00:43:27,490 --> 00:43:29,540
It's a really fancy way of expanding ifs.

00:43:31,110 --> 00:43:33,430
And then I call this helper function with the number

00:43:33,430 --> 00:43:35,610
of enumerators, like creating an index sequence

00:43:35,610 --> 00:43:37,460
with the right number of enumerators.

00:43:39,120 --> 00:43:41,420
So it's a little bit fancy but it can be done.

00:43:42,410 --> 00:43:44,180
And so there is a bunch of other features,

00:43:44,180 --> 00:43:47,950
like you can get the location where a type

00:43:47,950 --> 00:43:49,300
or an entity was defined.

00:43:49,300 --> 00:43:53,350
You can get, like I said, the member types,

00:43:53,350 --> 00:43:55,680
the base classes and such information.

00:43:55,680 --> 00:44:00,370
So we're also thinking about adding reflection on functions,

00:44:00,370 --> 00:44:02,900
like you can get the parameters,

00:44:02,900 --> 00:44:05,503
and the return type and things like that.

00:44:06,750 --> 00:44:09,070
There's also plans apparently to add reflection

00:44:09,070 --> 00:44:11,570
on arbitrary expressions, which is cool but scary.

00:44:12,420 --> 00:44:14,320
So, you could, for example, have an expression

00:44:14,320 --> 00:44:15,840
and then you say, reflexpr of that,

00:44:15,840 --> 00:44:17,810
and it gives you the AST of that expression,

00:44:17,810 --> 00:44:19,910
and then you can walk and do crazy things.

00:44:22,708 --> 00:44:25,460
I'm not exactly sure when or whether it's

00:44:25,460 --> 00:44:27,960
actually gonna happen, but I've heard some plans

00:44:27,960 --> 00:44:29,370
to do that eventually.

00:44:29,370 --> 00:44:31,223
For sure, it's not in the NBB.

00:44:33,160 --> 00:44:35,260
And the important part here is that syntax is

00:44:35,260 --> 00:44:36,460
actually not settled yet.

00:44:36,460 --> 00:44:39,860
So, what we plan to do with the Reflection TS is rebase it

00:44:39,860 --> 00:44:41,523
on top of the constexpr syntax.

00:44:42,520 --> 00:44:44,970
So, what we wanna do is instead of having reflexpr

00:44:44,970 --> 00:44:47,870
return a type, we want to have it return an object,

00:44:47,870 --> 00:44:49,003
a constexpr object.

00:44:50,370 --> 00:44:52,250
That constexpr object under the hood is

00:44:52,250 --> 00:44:54,443
just the same pointer to the AST node,

00:44:55,290 --> 00:44:57,370
but it's represented as a constexpr object.

00:44:57,370 --> 00:45:00,560
And once you have an object, you're good.

00:45:00,560 --> 00:45:02,530
You can use a normal C++ syntax,

00:45:02,530 --> 00:45:05,350
which is much better than template meta-programming.

00:45:05,350 --> 00:45:09,150
So, for example here I can get the list

00:45:09,150 --> 00:45:11,440
of data members as a vector.

00:45:11,440 --> 00:45:14,290
I'm using a constructor-template argument deduction here,

00:45:15,400 --> 00:45:18,603
so I don't have to type the type inside my vector.

00:45:19,529 --> 00:45:23,720
So I get a vector of my members, and then I can index

00:45:23,720 --> 00:45:25,720
my vector just like I'm used to,

00:45:25,720 --> 00:45:30,220
so I get back the meta-information for that member.

00:45:30,220 --> 00:45:32,140
And then I can use normal methods

00:45:32,140 --> 00:45:34,630
just to query properties about it.

00:45:34,630 --> 00:45:36,280
This is like type traits 2.0.

00:45:38,880 --> 00:45:41,510
And then if I actually want to go back to redefine.

00:45:41,510 --> 00:45:43,420
If I wanna go back from the conceptual world,

00:45:43,420 --> 00:45:46,420
back into the type system, I need another keyword

00:45:46,420 --> 00:45:49,450
to do that, that's why we need to introduce unreflexpr,

00:45:49,450 --> 00:45:53,180
which is another keyword that brings basically redefines

00:45:53,180 --> 00:45:55,480
the meta-information represented

00:45:55,480 --> 00:45:58,093
as a constexpr object back into the type system.

00:45:59,010 --> 00:46:00,390
So, you lift it down

00:46:00,390 --> 00:46:03,760
you pull it down into constexpr, do calculations,

00:46:03,760 --> 00:46:04,850
and then you lift it up

00:46:04,850 --> 00:46:07,150
back up into the type system, with unreflexpr.

00:46:08,720 --> 00:46:11,620
So with this syntax, printing an enum becomes much better.

00:46:12,670 --> 00:46:15,053
Your out of template meta-programming there.

00:46:16,510 --> 00:46:19,740
So I get the set of enumerators,

00:46:19,740 --> 00:46:21,680
by reflecting on my enumeration.

00:46:21,680 --> 00:46:23,670
And then I can iterate using a range-based for loop,

00:46:23,670 --> 00:46:25,300
a little bit of a fancy range-based for loop.

00:46:25,300 --> 00:46:26,600
I'll explain what this is.

00:46:27,810 --> 00:46:28,643
And that's it.

00:46:30,230 --> 00:46:34,363
And so this for, that thing here is not a normal for loop.

00:46:35,870 --> 00:46:37,540
It's basically

00:46:37,540 --> 00:46:40,690
it's basically a spanning for loop.

00:46:40,690 --> 00:46:43,497
It spans out, it unrolls itself essentially, and

00:46:46,270 --> 00:46:50,870
and the interesting part is that at each step in the

00:46:50,870 --> 00:46:54,810
each buddy that gets spanned out can have a different type,

00:46:54,810 --> 00:46:56,580
if you want, for the

00:46:57,560 --> 00:47:00,050
for the loop variable, which means

00:47:00,050 --> 00:47:02,550
that you could actually use a tuple in that place.

00:47:04,260 --> 00:47:08,380
And this is actually quite important to realize that

00:47:08,380 --> 00:47:12,230
this is not a normal for loop, because it's closer

00:47:12,230 --> 00:47:15,280
to template instantiation than it is to actual

00:47:15,280 --> 00:47:18,720
a normal run-time for loop, because you could have

00:47:18,720 --> 00:47:21,990
a different at each step in your for loop.

00:47:27,934 --> 00:47:30,260
So the status of reflection right now is, like I said,

00:47:30,260 --> 00:47:32,050
that basically the

00:47:32,050 --> 00:47:35,920
we're trying to figure out what the compiler query API

00:47:35,920 --> 00:47:36,753
should be.

00:47:36,753 --> 00:47:38,660
We're trying to figure out

00:47:38,660 --> 00:47:41,370
what happens, for example, when you have a function

00:47:41,370 --> 00:47:43,210
which is really re-declared and your asking

00:47:43,210 --> 00:47:45,170
for the parameter names.

00:47:45,170 --> 00:47:47,740
Which ones do you get, these kinds of questions,

00:47:47,740 --> 00:47:50,540
which are very important to get right.

00:47:50,540 --> 00:47:53,750
But we're not so concerned at this very moment

00:47:53,750 --> 00:47:57,820
with the exact syntax that we're gonna end up with.

00:47:57,820 --> 00:48:00,120
We expect that we will rebase on top

00:48:00,120 --> 00:48:02,300
of the constexpr work, when it is ready.

00:48:02,300 --> 00:48:06,480
So, don't go crazy if you see the Reflection TS and you're

00:48:06,480 --> 00:48:08,130
like, what is this template meta-programming syntax.

00:48:08,130 --> 00:48:09,300
I want none of this.

00:48:10,574 --> 00:48:12,720
We're just making progress at this point,

00:48:12,720 --> 00:48:14,410
and we will rebase on top of the syntax

00:48:14,410 --> 00:48:16,780
that makes a little more sense.

00:48:16,780 --> 00:48:19,580
And the goal again is to write normal-looking C++ code,

00:48:19,580 --> 00:48:21,250
which runs at compile time efficiently,

00:48:21,250 --> 00:48:22,990
without templates and instantiations.

00:48:22,990 --> 00:48:26,720
Actually, this is driven a lot by compiler implementers,

00:48:26,720 --> 00:48:28,520
that are tired of

00:48:30,170 --> 00:48:32,513
me basically abusing their compiler,

00:48:33,375 --> 00:48:35,363
to do template meta-programming.

00:48:36,420 --> 00:48:40,540
They wanna put me out of business, so that's what that

00:48:40,540 --> 00:48:43,330
the design here is really aimed

00:48:43,330 --> 00:48:48,293
to produce an efficient model to do compile-time evaluation.

00:48:50,950 --> 00:48:52,953
So now unto code injection.

00:48:54,990 --> 00:48:57,680
We considered a bunch of alternatives,

00:48:57,680 --> 00:48:59,050
like raw string injection,

00:48:59,050 --> 00:49:01,340
programmatic API to kind of

00:49:03,640 --> 00:49:05,190
bring back the

00:49:06,710 --> 00:49:09,597
to inject basically code back into the compiler's AST.

00:49:10,749 --> 00:49:12,283
And then we basically settled on something

00:49:12,283 --> 00:49:15,060
that we call token-sequence injection.

00:49:15,060 --> 00:49:17,700
What I mean by that here is that you extract information

00:49:17,700 --> 00:49:19,213
from the compiler,

00:49:20,370 --> 00:49:23,790
using the query API, so using reflection essentially.

00:49:23,790 --> 00:49:26,800
And then you use constexpr to perform calculations,

00:49:26,800 --> 00:49:29,120
computations, algorithms on

00:49:30,510 --> 00:49:34,640
involving that data, and then what you wanna do is basically

00:49:36,350 --> 00:49:39,900
influence the compiler's AST using the result

00:49:39,900 --> 00:49:41,053
of these computations.

00:49:41,930 --> 00:49:44,080
And to do that, like I said, we're settling

00:49:44,080 --> 00:49:45,460
on token-sequence injection.

00:49:45,460 --> 00:49:48,360
And I'm gonna be a huge tease right now.

00:49:48,360 --> 00:49:51,170
I'm just gonna say go to Herb's keynote.

00:49:51,170 --> 00:49:53,270
I apologize but I can't steal his thunder.

00:49:55,753 --> 00:49:58,550
I believe he's gonna explain that in much more details.

00:49:59,420 --> 00:50:02,410
Unfortunately, I'm not gonna talk about that.

00:50:02,410 --> 00:50:04,890
I'm also kind of out of time soon, so.

00:50:04,890 --> 00:50:09,250
So to wrap up, I'd like to kind of give a bird's eye view

00:50:09,250 --> 00:50:13,443
of what I think the timeline is for this stuff.

00:50:14,590 --> 00:50:19,210
And I wanna say this is not a commitment.

00:50:19,210 --> 00:50:22,640
This is just me, saying what I think is gonna happen,

00:50:22,640 --> 00:50:24,380
but I'm being very optimistic.

00:50:24,380 --> 00:50:27,562
This is absolutely not a commitment from me

00:50:27,562 --> 00:50:30,250
or from the committee or from anything else.

00:50:30,250 --> 00:50:31,620
Just to be clear here.

00:50:31,620 --> 00:50:35,290
It's just I think it is reasonable to expect that

00:50:35,290 --> 00:50:38,400
that kind of timeline is gonna be respected, we'll see.

00:50:38,400 --> 00:50:42,080
So I think in C++20 we're gonna see more constexpr,

00:50:42,080 --> 00:50:45,230
because most of the papers that I presented today,

00:50:45,230 --> 00:50:47,820
actually they're well

00:50:47,820 --> 00:50:49,930
they're pretty advanced in the committee anyway,

00:50:49,930 --> 00:50:51,580
or some of them have been merged already.

00:50:51,580 --> 00:50:53,990
And we don't foresee a lot of problems with them,

00:50:53,990 --> 00:50:56,140
so we think they're gonna make it.

00:50:56,140 --> 00:50:58,470
So I think standard vector, standard string,

00:50:58,470 --> 00:51:01,040
maybe standard map if we get the time,

00:51:01,040 --> 00:51:04,003
they're probably gonna be constexpr in C++20, hopefully.

00:51:05,250 --> 00:51:07,210
And the language features that are required

00:51:07,210 --> 00:51:09,270
to make these containers constexpr as well,

00:51:09,270 --> 00:51:12,350
so like I said, try-catch, allocations,

00:51:12,350 --> 00:51:13,950
the promotion to static storage.

00:51:14,840 --> 00:51:17,763
We've got virtual calls now too, a few things like that.

00:51:18,937 --> 00:51:21,270
And so I think we're gonna see those in C++20,

00:51:21,270 --> 00:51:23,340
that's pretty safe to expect that.

00:51:23,340 --> 00:51:25,630
Then we might see an experiment

00:51:25,630 --> 00:51:30,380
like we might see an experimental reflection facility,

00:51:30,380 --> 00:51:32,940
which I'm not exactly sure whether it's gonna be built

00:51:32,940 --> 00:51:35,230
on top of the template meta-programming syntax

00:51:35,230 --> 00:51:37,210
at that point, or whether it's gonna be rebased already,

00:51:37,210 --> 00:51:40,563
but we might be able to provide that kind of stuff for '20.

00:51:41,640 --> 00:51:44,390
That's not too sure, but we might.

00:51:44,390 --> 00:51:45,973
In C++23, however,

00:51:48,250 --> 00:51:51,870
we should be able to have a reflect

00:51:51,870 --> 00:51:53,900
a proper reflection facility that is based

00:51:53,900 --> 00:51:55,860
on top of constexpr.

00:51:55,860 --> 00:51:57,620
Again, not a hard commitment.

00:51:57,620 --> 00:52:00,190
I'm just expecting, looking at how things are progressing

00:52:00,190 --> 00:52:02,390
that we might be able to make it, we'll see.

00:52:04,690 --> 00:52:07,280
And we might have some code injection mechanism,

00:52:07,280 --> 00:52:11,200
although that is kind of a little more complicated.

00:52:11,200 --> 00:52:14,160
So go to Herb's keynote, like I said.

00:52:14,160 --> 00:52:16,920
This one I'm not sure we're gonna land for '23.

00:52:16,920 --> 00:52:19,130
But for sure for '23, there is no reason

00:52:19,130 --> 00:52:20,980
why we couldn't have a big, big chunk

00:52:20,980 --> 00:52:22,830
of the standard library be constexpr.

00:52:25,300 --> 00:52:27,070
Well, I think this is gonna change the face of C++,

00:52:27,070 --> 00:52:29,793
really, I mean, this is huge.

00:52:30,900 --> 00:52:33,730
This opens a lot of possibilities.

00:52:33,730 --> 00:52:36,690
We can write really, really cool libraries with that.

00:52:36,690 --> 00:52:40,570
Imagine JSON libraries that just spit out JSON

00:52:40,570 --> 00:52:43,810
without you having to do anything at all, that's super cool.

00:52:43,810 --> 00:52:46,480
Or like serialization, de-serialization,

00:52:46,480 --> 00:52:49,513
all these things are gonna be much simpler.

00:52:50,645 --> 00:52:53,370
We can increase code reuse a lot, I think.

00:52:53,370 --> 00:52:55,763
We can stop writing boilerplate all the time.

00:52:56,810 --> 00:52:59,270
We can also make interoperating

00:52:59,270 --> 00:53:01,193
with other languages much easier.

00:53:02,320 --> 00:53:06,570
Imagine what it would look like to generate Python bindings,

00:53:06,570 --> 00:53:09,300
for example, using that kind of facility would be

00:53:09,300 --> 00:53:10,750
much easier than it is today.

00:53:12,710 --> 00:53:16,620
However, it also opens up really, really nice possibilities

00:53:16,620 --> 00:53:20,160
for shooting your foot, and that's kind of bad.

00:53:20,160 --> 00:53:22,010
But we're C++ programmers so we like to think

00:53:22,010 --> 00:53:23,000
that we have control.

00:53:23,000 --> 00:53:27,076
And never forget that with great power comes a lot of fun.

00:53:27,076 --> 00:53:28,900
(audience laughing)

00:53:28,900 --> 00:53:30,980
So anyway, none of this work would be possible

00:53:30,980 --> 00:53:33,100
without a bunch of people, and this is

00:53:33,100 --> 00:53:36,280
really just a subset of the people that are working on that.

00:53:36,280 --> 00:53:38,330
There's a lot of people involved.

00:53:38,330 --> 00:53:40,430
And we're really doing our best

00:53:40,430 --> 00:53:43,680
to bring that kind of facility to you folks, and

00:53:45,040 --> 00:53:47,827
I think we can make something good with C++, thank you.

00:53:47,827 --> 00:53:50,994
(audience applauding)

00:53:54,980 --> 00:53:55,970
So I'll be taking questions.

00:53:55,970 --> 00:53:57,640
Please come with the mics.

00:54:01,770 --> 00:54:03,730
- [Audience Member] Will constexpr-exclamation-mark

00:54:03,730 --> 00:54:07,003
work on constexpr variables, as well as functions?

00:54:08,290 --> 00:54:11,689
So that you don't have to say inline or define them.

00:54:11,689 --> 00:54:15,270
- Constexpr variables, like constexpr-bang, some variable.

00:54:15,270 --> 00:54:17,122
So we thought about that, there are

00:54:17,122 --> 00:54:20,730
some pretty nasty difficulties with that having

00:54:20,730 --> 00:54:23,983
to do with, I think, they're linkage.

00:54:25,296 --> 00:54:28,170
That story is not really easy to figure out,

00:54:28,170 --> 00:54:30,270
so for now we're leaving them out.

00:54:30,270 --> 00:54:31,520
This is covered in the paper actually,

00:54:31,520 --> 00:54:35,080
but we thought about that, and it's just not

00:54:35,080 --> 00:54:36,770
it opens up a can of worms,

00:54:36,770 --> 00:54:39,360
so we're kind of skipping that for now.

00:54:39,360 --> 00:54:40,303
- [Audience Member] Thanks.

00:54:42,070 --> 00:54:43,810
- [Attendee] So today in some of the talks

00:54:43,810 --> 00:54:45,760
we were recommended to like--

00:54:45,760 --> 00:54:47,003
- Can you speak closer to the mic, please?

00:54:47,003 --> 00:54:49,100
- [Attendee] Make everything constant,

00:54:49,100 --> 00:54:52,150
like everything kind of moves into constexpr.

00:54:52,150 --> 00:54:55,597
Should we consider making everything const by default

00:54:55,597 --> 00:55:00,597
and making stuff mutable only when it's needed, mutable.

00:55:01,060 --> 00:55:02,690
- Right, should we switch to default?

00:55:02,690 --> 00:55:05,390
Well, C++ is the language that gets the default wrong.

00:55:07,603 --> 00:55:09,300
Should we make everything constexpr by default?

00:55:09,300 --> 00:55:10,360
I don't think so.

00:55:10,360 --> 00:55:12,050
Constexpr is actually a

00:55:13,100 --> 00:55:14,070
constexpr is

00:55:14,070 --> 00:55:15,960
when you say constexpr in front of something,

00:55:15,960 --> 00:55:20,250
you're putting a barrier on the implementation.

00:55:20,250 --> 00:55:23,090
You're saying, I will never implement that function

00:55:23,090 --> 00:55:25,840
or that functionality in a way that can't be evaluated

00:55:25,840 --> 00:55:27,600
at compile time, so it's actually some

00:55:27,600 --> 00:55:29,270
you're actually stating a contract,

00:55:29,270 --> 00:55:31,542
which is why I would personally

00:55:31,542 --> 00:55:36,220
I think I would oppose to, for example, having constexpr

00:55:36,220 --> 00:55:40,280
constexpr-ness be deduced automatically by the compiler,

00:55:40,280 --> 00:55:42,045
that kind of stuff, because suddenly

00:55:42,045 --> 00:55:47,045
you would be promising way more to your users,

00:55:47,200 --> 00:55:49,840
say if you're writing a library than you are currently.

00:55:49,840 --> 00:55:51,060
So, I think saying

00:55:51,060 --> 00:55:53,860
I think white-listing things as being this is good

00:55:53,860 --> 00:55:55,700
at compile time, this is good, this is not.

00:55:55,700 --> 00:55:57,280
I think it's still a good thing, at least for now.

00:55:57,280 --> 00:56:00,170
We'll see whether that changes in the future,

00:56:00,170 --> 00:56:03,930
but I think for now it's safer to go that way.

00:56:03,930 --> 00:56:04,955
Yeah.

00:56:04,955 --> 00:56:06,848
- [Attendee] I think this will be a short thing, given

00:56:06,848 --> 00:56:08,280
the question that was just asked.

00:56:08,280 --> 00:56:11,290
Kate Gregory earlier mentioned a method

00:56:11,290 --> 00:56:14,240
of finding correct constness in your codebase

00:56:14,240 --> 00:56:15,770
by adding const to everything,

00:56:15,770 --> 00:56:16,980
and then starting to leak things.

00:56:16,980 --> 00:56:19,900
Should we now be doing that for constexpr also?

00:56:19,900 --> 00:56:23,010
I think you're just gonna say the same thing.

00:56:23,010 --> 00:56:25,680
- Yeah, I don't think it's a good idea.

00:56:25,680 --> 00:56:28,600
I think it's better to selectively enable constexpr,

00:56:28,600 --> 00:56:29,593
but you know,

00:56:33,040 --> 00:56:34,340
at that point.

00:56:34,340 --> 00:56:36,970
Honestly, I think that the kind of stuff you do

00:56:36,970 --> 00:56:38,820
with constexpr today is too limited

00:56:38,820 --> 00:56:41,700
for us to have a really, really clear

00:56:41,700 --> 00:56:44,680
we don't have a lot of experience with what it would be like

00:56:44,680 --> 00:56:45,920
to take a whole codebase and be like,

00:56:45,920 --> 00:56:48,390
actually, how about I run my whole application

00:56:48,390 --> 00:56:49,320
at compile time?

00:56:49,320 --> 00:56:51,110
We can't really do that today,

00:56:51,110 --> 00:56:53,800
so we might get closer to that, and in that case,

00:56:53,800 --> 00:56:56,240
we'll get some experience and we'll know whether

00:56:56,240 --> 00:56:58,840
it makes sense to span constexpr literally everywhere.

00:56:58,840 --> 00:57:00,980
For now, I think it's much better not to do that.

00:57:00,980 --> 00:57:01,813
Yeah.

00:57:01,813 --> 00:57:03,770
- [Attendee] Hi, this idea came to mind

00:57:03,770 --> 00:57:06,130
when you had your slide on challenges with reinterpret cast,

00:57:06,130 --> 00:57:08,600
with the small buffer optimization, nested string.

00:57:08,600 --> 00:57:11,163
For a string being constexpr or not,

00:57:12,410 --> 00:57:16,260
and so would it be reasonable to consider having

00:57:16,260 --> 00:57:20,640
an overloaded class set based on if it's constexpr or not,

00:57:20,640 --> 00:57:22,550
so you could have different behaviors, if you're operating

00:57:22,550 --> 00:57:24,990
with that class in constexpr versus not,

00:57:24,990 --> 00:57:27,560
versus saying there's only one implementation

00:57:27,560 --> 00:57:29,310
that can be used in both contexts.

00:57:29,310 --> 00:57:30,440
Does that make sense?

00:57:30,440 --> 00:57:31,273
- You mean different types--

00:57:31,273 --> 00:57:33,680
- [Attendee] 'Cause small buffer optimization makes sense

00:57:33,680 --> 00:57:37,020
for run time reasons when you have performance reasons

00:57:37,020 --> 00:57:39,460
at run time, versus at maybe compile time

00:57:39,460 --> 00:57:41,820
I have different things I wanna optimize for.

00:57:41,820 --> 00:57:43,780
Still have to be the same class, same name,

00:57:43,780 --> 00:57:46,370
because in a constexpr function that maybe is run time

00:57:46,370 --> 00:57:48,207
versus maybe used at constexpr,

00:57:49,090 --> 00:57:51,520
I wanna use the same class, same interface,

00:57:51,520 --> 00:57:52,540
but have different implementation--

00:57:52,540 --> 00:57:55,370
- Yes, so actually this what we plan on doing,

00:57:55,370 --> 00:57:56,750
for strings specifically

00:57:56,750 --> 00:57:58,486
we're not gonna give you constexpr string.

00:57:58,486 --> 00:58:00,330
We're just gonna give you std::string.

00:58:00,330 --> 00:58:02,880
It's just gonna work magically in both cases.

00:58:02,880 --> 00:58:05,630
And the way we're gonna do that is we're gonna say, oh,

00:58:06,870 --> 00:58:08,790
I'm being run in a constexpr context.

00:58:08,790 --> 00:58:10,380
I think this string does not fit

00:58:10,380 --> 00:58:11,690
in my small buffer optimization.

00:58:11,690 --> 00:58:13,000
So, you just never use the small buffer optimization.

00:58:13,000 --> 00:58:15,180
- [Attendee] But then what about types I implement?

00:58:15,180 --> 00:58:17,940
Like if I wanted a class, my class,

00:58:17,940 --> 00:58:20,330
and then a constexpr class, my class,

00:58:20,330 --> 00:58:21,890
and do that all myself, and have it

00:58:21,890 --> 00:58:25,790
not be inside the compiler, for only standard library types.

00:58:25,790 --> 00:58:26,850
- I don't think that would work,

00:58:26,850 --> 00:58:30,060
because you can't change the type based on

00:58:30,060 --> 00:58:31,820
whether you are evaluating--

00:58:31,820 --> 00:58:33,440
- [Attendee] The question is what's your opinion

00:58:33,440 --> 00:58:34,580
of such a proposal?

00:58:34,580 --> 00:58:37,580
Is that a worthy proposal they could at least even consider?

00:58:38,660 --> 00:58:40,360
- I think I would need to sit down.

00:58:40,360 --> 00:58:43,960
I think I would need to sit down and talk about this

00:58:43,960 --> 00:58:45,390
more concretely to really understand

00:58:45,390 --> 00:58:46,310
what the implications are,

00:58:46,310 --> 00:58:47,257
that's what I think. - You should totally do that.

00:58:47,257 --> 00:58:49,730
- I think it's not necessarily a bad idea,

00:58:49,730 --> 00:58:51,440
because I can see some uses for it,

00:58:51,440 --> 00:58:54,180
but I think it would kind of break the model

00:58:54,180 --> 00:58:57,010
of the C++ type system, basically.

00:58:57,010 --> 00:59:00,313
So I think it's something worth considering, but yeah.

00:59:01,680 --> 00:59:03,880
- [Attendee] So, a related question

00:59:03,880 --> 00:59:06,920
but for functions, same way I can overload a function

00:59:06,920 --> 00:59:09,524
on const versus non-const.

00:59:09,524 --> 00:59:11,610
You can't do that with a type but you--

00:59:11,610 --> 00:59:13,780
Closer to the mic, sir. - You're on constexpr

00:59:13,780 --> 00:59:15,813
for a function versus non-constexpr?

00:59:16,895 --> 00:59:18,260
- Can you repeat that, I missed that?

00:59:18,260 --> 00:59:19,825
- [Attendee] Can you overload a function

00:59:19,825 --> 00:59:21,674
for constexpr versus non

00:59:21,674 --> 00:59:23,820
constexpr-bang versus non-constexpr-bang?

00:59:23,820 --> 00:59:25,317
- We can't, no you can't.

00:59:25,317 --> 00:59:27,620
But what you can do, however, like I said,

00:59:27,620 --> 00:59:29,550
is basically say, oh, am I being evaluated

00:59:29,550 --> 00:59:31,490
at compile time or not, and then act differently.

00:59:31,490 --> 00:59:33,087
Although, you should try not to do that.

00:59:33,087 --> 00:59:34,823
You should let me do that.

00:59:35,820 --> 00:59:38,777
- [Attendee] And for the is_constant_evaluated,

00:59:39,930 --> 00:59:41,180
what about in a

00:59:42,330 --> 00:59:45,470
constexpr constructor that is not used

00:59:45,470 --> 00:59:48,990
to construct constexpr variables, like std::mutex,

00:59:48,990 --> 00:59:52,930
would is constexpr evaluated be?

00:59:52,930 --> 00:59:55,240
- What about a constexpr constructor

00:59:55,240 --> 00:59:58,145
that is used to construct non-constexpr variables,

00:59:58,145 --> 00:59:59,978
is that what you said?

01:00:01,580 --> 01:00:02,980
Yeah, I mean, but that work is varied.

01:00:02,980 --> 01:00:04,090
You can have a--

01:00:04,090 --> 01:00:05,090
- [Attendee] But what would the value

01:00:05,090 --> 01:00:07,577
of the is_constant_evaluated?

01:00:08,950 --> 01:00:10,280
- Oh, I see what you mean.

01:00:10,280 --> 01:00:14,500
It would not be true, because

01:00:14,500 --> 01:00:17,010
what you're initializing is not constexpr.

01:00:17,010 --> 01:00:18,107
- [Attendee] Thank you.

01:00:20,007 --> 01:00:21,090
- [Audience Member] Hey there.

01:00:21,090 --> 01:00:25,110
So my question is when we're talking about doing

01:00:25,110 --> 01:00:27,730
a lot more computation at compile time

01:00:27,730 --> 01:00:30,920
as we expand constexpr, do we expect

01:00:30,920 --> 01:00:33,750
that if we're doing really, really heavy

01:00:33,750 --> 01:00:36,880
sort of pre-computations and stuff at compile time,

01:00:36,880 --> 01:00:40,760
do we expect compilers to be able to somehow cache

01:00:40,760 --> 01:00:42,700
those values in a way that it doesn't really,

01:00:42,700 --> 01:00:46,960
really slow down our builds, tests, write cycle.

01:00:46,960 --> 01:00:48,310
- Yeah, so there is kind of

01:00:49,560 --> 01:00:51,190
today this is what happens with instantiation

01:00:51,190 --> 01:00:52,023
with template instantiation,

01:00:52,023 --> 01:00:55,820
everything is memorized, everything is kind of cached.

01:00:55,820 --> 01:00:58,970
And that's actually a problem, because it means

01:00:58,970 --> 01:01:02,163
that we use a lot of memory when we compile,

01:01:03,070 --> 01:01:05,030
so I think

01:01:06,250 --> 01:01:08,400
talking to some compiler implementers,

01:01:08,400 --> 01:01:10,170
actually there is a big

01:01:10,170 --> 01:01:11,280
they wanna step away from that.

01:01:11,280 --> 01:01:13,323
They wanna be able to discard values

01:01:14,490 --> 01:01:16,696
after they've used them.

01:01:16,696 --> 01:01:18,860
They basically don't want things

01:01:18,860 --> 01:01:20,440
to live forever in the compiler.

01:01:20,440 --> 01:01:22,670
So I would say it's actually undesirable

01:01:22,670 --> 01:01:24,914
to cache all, everything.

01:01:24,914 --> 01:01:26,990
- [Audience Member] But what I mean isn't in one run.

01:01:26,990 --> 01:01:29,780
What I mean is I run my compiler.

01:01:29,780 --> 01:01:32,090
It does some computation, something else breaks,

01:01:32,090 --> 01:01:34,740
I fix it, I run it again, and I don't wanna do

01:01:34,740 --> 01:01:37,010
that same big pre-computation that I did the first time,

01:01:37,010 --> 01:01:38,250
'cause I didn't change any of that,

01:01:38,250 --> 01:01:40,077
just the code that I didn't change.

01:01:40,077 --> 01:01:43,120
Is that something that's reasonable for us to expect?

01:01:43,120 --> 01:01:44,570
- I see what you mean.

01:01:44,570 --> 01:01:48,303
This is definitely not something that we have thought about.

01:01:49,790 --> 01:01:51,090
It's kind of

01:01:52,280 --> 01:01:55,400
this question applies to what we're doing today.

01:01:55,400 --> 01:01:57,010
I would say we don't really have a solution

01:01:57,010 --> 01:01:58,041
for that right now.

01:01:58,041 --> 01:02:01,100
If this is something you can do, then you could hoist

01:02:01,100 --> 01:02:02,150
everything into a separate TU,

01:02:02,150 --> 01:02:05,340
and then you just compile that TU once.

01:02:05,340 --> 01:02:07,060
But obviously if it's in a header,

01:02:07,060 --> 01:02:09,320
then you need to redo the whole computation every time,

01:02:09,320 --> 01:02:11,100
which is true today with constexpr.

01:02:11,100 --> 01:02:15,340
And I mean, the solution for that would be really cool.

01:02:15,340 --> 01:02:17,570
I clearly don't have one right now.

01:02:17,570 --> 01:02:18,470
- [Audience Member] Cool, thank you.

01:02:18,470 --> 01:02:19,303
- Sure.

01:02:20,600 --> 01:02:22,530
- [Audience Member] I'm not sure that I entirely follow

01:02:22,530 --> 01:02:25,640
the purpose of allowing try-catch within constexpr.

01:02:25,640 --> 01:02:27,560
If throw generates a compile-time error,

01:02:27,560 --> 01:02:29,550
then that would mean your try-catch is

01:02:29,550 --> 01:02:32,000
inherently unreachable code, which you would want

01:02:32,000 --> 01:02:33,030
to discourage, right?

01:02:33,030 --> 01:02:34,540
- That's exactly the point.

01:02:34,540 --> 01:02:35,940
The point-- - You allow it.

01:02:36,990 --> 01:02:40,550
- Because I wanna make standard vector push_back work

01:02:40,550 --> 01:02:42,650
at compile time, so the thing is

01:02:42,650 --> 01:02:45,487
I'm fine if there was a hard error, a compile-time error.

01:02:45,487 --> 01:02:48,787
If you actually throw something from within your push_back,

01:02:48,787 --> 01:02:52,110
but for the majority of cases where you're not gonna throw

01:02:52,110 --> 01:02:54,920
anything, I want it to be a valid constant expression.

01:02:54,920 --> 01:02:59,890
So, as of this paper, basically try-catch is equivalent

01:02:59,890 --> 01:03:03,000
to just a brace, just you're entering a scope,

01:03:03,000 --> 01:03:04,010
that's what you're doing,

01:03:04,010 --> 01:03:06,790
because it's impossible to get into the catch block anyway.

01:03:06,790 --> 01:03:07,900
It's kind of a no-op.

01:03:07,900 --> 01:03:09,230
Does that answer your question?

01:03:09,230 --> 01:03:10,340
- [Audience Member] Well, yeah, I mean, my point is

01:03:10,340 --> 01:03:11,750
because it's a no-op, then why not

01:03:11,750 --> 01:03:13,070
just take out the try-catch.

01:03:13,070 --> 01:03:14,980
What's the point of having it at all?

01:03:14,980 --> 01:03:17,273
- Right, because it might not be a no-op at run time.

01:03:18,470 --> 01:03:20,640
- [Audience Member] Oh, because the second proposal's

01:03:20,640 --> 01:03:21,690
not included yet.

01:03:21,690 --> 01:03:25,240
- Well, because if you call that constexpr function

01:03:25,240 --> 01:03:26,370
at run time,

01:03:26,370 --> 01:03:29,130
which you can, and then you run out of memory,

01:03:29,130 --> 01:03:30,420
you want the bad alloc to

01:03:30,420 --> 01:03:32,170
or you want the out-of-bounds error, for example, to be--

01:03:32,170 --> 01:03:33,190
- [Audience Member] Okay, okay.

01:03:33,190 --> 01:03:34,870
So then if you add the second proposal

01:03:34,870 --> 01:03:36,660
to make a decision based on whether

01:03:36,660 --> 01:03:38,210
your running is constexpr or not,

01:03:38,210 --> 01:03:39,670
then you could actually

01:03:39,670 --> 01:03:41,164
you could actually have logic in one case

01:03:41,164 --> 01:03:42,914
and not in the other.

01:03:43,943 --> 01:03:46,350
- I'm not sure I followed that.

01:03:46,350 --> 01:03:47,630
- [Audience Member] Within the implementation then

01:03:47,630 --> 01:03:50,680
of the standard vector, if later you add the ability

01:03:50,680 --> 01:03:52,810
to say, hey, am I running within constexpr,

01:03:52,810 --> 01:03:55,160
you could then choose to remove the logic

01:03:55,160 --> 01:03:57,407
in the constexpr case, and not even bother with the--

01:03:57,407 --> 01:03:58,460
- Right, yeah.

01:03:58,460 --> 01:03:59,393
- [Audience Member] Okay.

01:04:00,270 --> 01:04:01,760
- Yeah.

01:04:01,760 --> 01:04:05,010
- [Attendee] For the C++ modules, do you expect actually

01:04:05,935 --> 01:04:09,000
constexpr expressions to evaluated

01:04:09,000 --> 01:04:11,200
when module is compiled or when

01:04:11,200 --> 01:04:13,523
in the phrases interpreted by another module?

01:04:15,582 --> 01:04:18,360
- That's a good question.

01:04:18,360 --> 01:04:20,150
That's a really good question.

01:04:20,150 --> 01:04:23,773
I believe it would be when the module is compiled.

01:04:26,520 --> 01:04:27,353
Hmm.

01:04:28,660 --> 01:04:30,333
Let me come back to you on that.

01:04:32,730 --> 01:04:34,410
- [Attendee] So I'm gonna ask something

01:04:34,410 --> 01:04:36,880
about the injection part. (snickering)

01:04:36,880 --> 01:04:38,400
You're probably gonna slap my face all the way

01:04:38,400 --> 01:04:40,603
up to the next keynote.

01:04:45,768 --> 01:04:48,380
You mentioned up there some options and we seemed

01:04:48,380 --> 01:04:50,250
to be going with tokens.

01:04:50,250 --> 01:04:51,270
- What?

01:04:51,270 --> 01:04:53,020
- [Attendee] For injection.

01:04:53,020 --> 01:04:54,070
- Yeah.

01:04:54,070 --> 01:04:55,300
- [Attendee] I don't know, the first thought that came

01:04:55,300 --> 01:04:58,813
to my mind is wouldn't something, unreflexpr--

01:04:58,813 --> 01:05:00,530
- Can you just speak closer to the mic, please?

01:05:00,530 --> 01:05:01,363
- [Attendee] What?

01:05:01,363 --> 01:05:02,430
- Can you speak closer to the mic?

01:05:02,430 --> 01:05:03,838
It's really hard to hear from here.

01:05:03,838 --> 01:05:05,303
- [Attendee] For injection.

01:05:06,260 --> 01:05:11,260
Wouldn't something, unreflexpr, the natural way to do it.

01:05:11,440 --> 01:05:14,490
Same as you can take real types and functions

01:05:14,490 --> 01:05:18,130
and what not into a representation of an object,

01:05:18,130 --> 01:05:19,423
taken just the other way.

01:05:20,620 --> 01:05:22,660
- The problem of code injection is actually quite tricky,

01:05:22,660 --> 01:05:24,730
because you have to generate new declarations

01:05:24,730 --> 01:05:26,820
and then somehow find a way to inject them

01:05:26,820 --> 01:05:28,470
into an existing declaration.

01:05:28,470 --> 01:05:31,273
So unreflexpr is not sufficient for that.

01:05:33,100 --> 01:05:34,000
- [Attendee] Okay.

01:05:37,310 --> 01:05:40,620
- [Audience Member] So with all of this compile-time code,

01:05:40,620 --> 01:05:42,320
how do I debug it?

01:05:42,320 --> 01:05:43,683
- Right, big question.

01:05:45,860 --> 01:05:47,830
How do you debug that?

01:05:47,830 --> 01:05:50,682
You run it at run time, I don't know, I mean.

01:05:50,682 --> 01:05:52,030
(audience laughing)

01:05:52,030 --> 01:05:53,400
Honestly, I think we're

01:05:53,400 --> 01:05:55,940
the tooling for C++ is gonna have

01:05:55,940 --> 01:05:57,330
to kind of follow these changes.

01:05:57,330 --> 01:05:59,820
It's kind of the same answer as for

01:05:59,820 --> 01:06:03,500
when Herb is asked questions about meta-classes,

01:06:03,500 --> 01:06:05,000
for example.

01:06:05,000 --> 01:06:06,250
We're adding new stuff to the language,

01:06:06,250 --> 01:06:07,920
and we have to be responsible.

01:06:07,920 --> 01:06:10,000
But also the tooling has to follow.

01:06:10,000 --> 01:06:13,180
So I mean, there are some tools that allow you to,

01:06:13,180 --> 01:06:15,220
for example, step through template instantiations.

01:06:15,220 --> 01:06:17,263
One of them is called templite.

01:06:18,210 --> 01:06:21,084
And so I think it's about tooling there, really.

01:06:21,084 --> 01:06:23,291
- [Audience Member] Okay.

01:06:23,291 --> 01:06:26,860
- [Attendee] In the case of the constexpr new.

01:06:26,860 --> 01:06:27,693
- Can you speak closer?

01:06:27,693 --> 01:06:30,350
- [Attendee] In the case of constexpr new,

01:06:30,350 --> 01:06:32,960
what does a delete do, is it a no-op

01:06:32,960 --> 01:06:35,720
or does it actually do something in the compiler?

01:06:35,720 --> 01:06:37,100
- In the case of constexpr what?

01:06:37,100 --> 01:06:39,923
- [Attendee] Constexpr new.

01:06:39,923 --> 01:06:40,980
- New.

01:06:40,980 --> 01:06:43,520
- [Attendee] Yeah, memory allocation in constexpr,

01:06:43,520 --> 01:06:44,780
which you need to make.

01:06:44,780 --> 01:06:46,164
- It actually allocates

01:06:46,164 --> 01:06:48,000
the compiler is actually gonna allocate memory for you.

01:06:48,000 --> 01:06:50,010
- [Attendee] For delete, does it actually delete

01:06:50,010 --> 01:06:53,580
the memory or is it a no-op, or--

01:06:53,580 --> 01:06:55,990
- That's gonna depend on your compiler implementation.

01:06:55,990 --> 01:06:58,160
I expect some compilers might say,

01:06:58,160 --> 01:07:01,400
I'm not even deleting stuff because I'm just gonna free

01:07:01,400 --> 01:07:04,210
all of my pool of memory when I shut down,

01:07:04,210 --> 01:07:05,610
but some other compilers might decide

01:07:05,610 --> 01:07:06,800
to actually free the memory.

01:07:06,800 --> 01:07:09,360
- [Attendee] So could you potentially

01:07:09,360 --> 01:07:12,150
would array be able to do the same thing

01:07:12,150 --> 01:07:14,140
in place of the new?

01:07:14,140 --> 01:07:16,170
So you could just use an array.

01:07:16,170 --> 01:07:17,070
- In place, new.

01:07:17,070 --> 01:07:18,420
- [Attendee] Instead of a new.

01:07:18,420 --> 01:07:20,720
Instead of using a new,

01:07:20,720 --> 01:07:22,700
could you use array, because an array is

01:07:22,700 --> 01:07:24,610
just allocating memory, it's usually on the stack

01:07:24,610 --> 01:07:25,970
at run time, but--

01:07:25,970 --> 01:07:28,286
- The problem is you can't use

01:07:28,286 --> 01:07:30,500
you can't just allocate memory like that.

01:07:30,500 --> 01:07:31,960
You can't

01:07:31,960 --> 01:07:34,180
the one thing we wanna avoid, like I said earlier,

01:07:34,180 --> 01:07:37,110
is to give you the ability to shoot yourself in the foot,

01:07:37,110 --> 01:07:39,280
in terms of like, oh, allocate for that type

01:07:39,280 --> 01:07:41,710
but in place newing with a different type,

01:07:41,710 --> 01:07:44,430
that kind of stuff, this can't happen.

01:07:44,430 --> 01:07:46,000
I think I'm gonna have to cut it here,

01:07:46,000 --> 01:07:48,210
because the next session is

01:07:48,210 --> 01:07:50,740
we can talk offline after.

01:07:50,740 --> 01:07:53,370
- [Attendee] Just to follow up the previous question

01:07:53,370 --> 01:07:54,483
that was made here.

01:07:55,360 --> 01:08:00,070
Is there any proposal for ability to

01:08:00,070 --> 01:08:00,903
to have

01:08:00,903 --> 01:08:03,840
I don't know, emit warnings or wait till

01:08:03,840 --> 01:08:06,410
actually get outputs off the constexpr?

01:08:06,410 --> 01:08:07,530
- I'm sorry, I can't hear you.

01:08:07,530 --> 01:08:08,380
It's really hard.

01:08:10,420 --> 01:08:13,515
- [Attendee] Is there any proposal for emitting warnings

01:08:13,515 --> 01:08:16,150
or getting any kind of log

01:08:16,150 --> 01:08:17,887
out of the constexpr?

01:08:19,420 --> 01:08:22,080
- No, no, the committee usually doesn't

01:08:23,280 --> 01:08:26,430
we usually don't standardize that kind of stuff.

01:08:26,430 --> 01:08:28,330
This is gonna be implementation dependent.

01:08:28,330 --> 01:08:31,660
So your compiler is probably gonna try to be helpful there,

01:08:31,660 --> 01:08:35,503

YouTube URL: https://www.youtube.com/watch?v=CRDNPwXDVp0


