Title: CppCon 2018: Ben Deane “Operator Overloading: History, Principles and Practice”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Your code would benefit from greater use of operators. Really. 

Operator overloading is such an unloved part of C++. It's not new, it's not 
glamorous, it's frequently maligned for "syntax abuse", and often avoided due to 
performance or implementation concerns. But operators deserve more 
consideration! If you're designing types and interfaces, operators have the 
potential to offer concision, clarity, and flexibility, and foster intuition in 
a way that functions can't. 

In this talk we'll look at past, current and likely future practices, from the 
humble old operator+ on arithmetic types to new uses like operator/ to 
concatenate paths, and beyond. We'll cover concrete guidelines for principled 
operator usage and the implementation concerns involved. 
— 
Ben Deane
Ben was in the game industry for 23 years, at companies like EA and Blizzard. He's always looking for useful new techniques in C++, and he | geeks out on algorithms, APIs, types and functional programming.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,210 --> 00:00:07,350
good afternoon welcome to my talk on

00:00:03,750 --> 00:00:13,010
operator overloading little bit history

00:00:07,350 --> 00:00:13,010
a lot of principles some practice I

00:00:13,880 --> 00:00:16,680
wanted to do a talk on operator

00:00:15,630 --> 00:00:21,630
overloading because it seemed to me a

00:00:16,680 --> 00:00:24,480
particularly unloved part of C++ I'm

00:00:21,630 --> 00:00:28,109
sensing that in the crowd so here's what

00:00:24,480 --> 00:00:31,470
I won't be talking about because because

00:00:28,109 --> 00:00:33,230
it could cover a lot of things so I'm

00:00:31,470 --> 00:00:36,000
pretty much going to be talking about

00:00:33,230 --> 00:00:38,460
why we should embrace operator

00:00:36,000 --> 00:00:40,350
overloading and and why we should do it

00:00:38,460 --> 00:00:42,809
with sort of regular operators that we

00:00:40,350 --> 00:00:44,399
think of when we think of operators so

00:00:42,809 --> 00:00:46,739
the arithmetic operators the bitwise

00:00:44,399 --> 00:00:48,239
operators equality operators you know a

00:00:46,739 --> 00:00:50,550
lot of things fall into the category of

00:00:48,239 --> 00:00:51,840
operators in C++ I'm not gonna be

00:00:50,550 --> 00:00:56,030
talking about the kind of esoteric

00:00:51,840 --> 00:01:00,390
things so operator over overloading is

00:00:56,030 --> 00:01:05,640
unloved and it's because it's just not

00:01:00,390 --> 00:01:08,400
that good in C++ operators in C++ were

00:01:05,640 --> 00:01:12,600
fixed to a large extent in about 1969

00:01:08,400 --> 00:01:15,090
when Ken Thompson invented B things we

00:01:12,600 --> 00:01:17,790
can't control include the names of

00:01:15,090 --> 00:01:19,439
operators we have a fixed syntactic set

00:01:17,790 --> 00:01:21,990
we don't get introduced new operators

00:01:19,439 --> 00:01:25,439
for example a power or operator might be

00:01:21,990 --> 00:01:27,780
nice but we can't do that we get fixed

00:01:25,439 --> 00:01:29,670
precedence and that often gives us a

00:01:27,780 --> 00:01:32,759
very short list of operators to choose

00:01:29,670 --> 00:01:36,600
from if you want to overload sometimes

00:01:32,759 --> 00:01:38,430
associativity is a problem and we'll

00:01:36,600 --> 00:01:40,350
come to that we don't get any choice in

00:01:38,430 --> 00:01:43,740
arity you might think that's a strange

00:01:40,350 --> 00:01:46,649
thing to want to vary if you read

00:01:43,740 --> 00:01:50,100
can-can Iverson's Turing Award lecture

00:01:46,649 --> 00:01:51,360
of 1979 all about APL that might change

00:01:50,100 --> 00:01:55,710
your mind about wanting to overload

00:01:51,360 --> 00:01:57,420
parity and operators or change arity we

00:01:55,710 --> 00:01:59,790
don't get the choice of whether to make

00:01:57,420 --> 00:02:04,350
operators in fixed prefix or postfix and

00:01:59,790 --> 00:02:06,060
we don't get a choice over evaluation

00:02:04,350 --> 00:02:07,860
semantics some operators short-circuit

00:02:06,060 --> 00:02:10,709
we don't get to we don't get to control

00:02:07,860 --> 00:02:13,360
that but what in theory all of these

00:02:10,709 --> 00:02:14,950
things are rules that the compiler knows

00:02:13,360 --> 00:02:18,460
it's just that they aren't exposed to us

00:02:14,950 --> 00:02:20,380
in the language okay so why do we care

00:02:18,460 --> 00:02:23,440
about operators and what can we do with

00:02:20,380 --> 00:02:24,940
the power that we do have the obvious

00:02:23,440 --> 00:02:27,160
first question is why should we use

00:02:24,940 --> 00:02:29,200
operators at all why should we prefer

00:02:27,160 --> 00:02:32,920
them over named functions for certain

00:02:29,200 --> 00:02:36,100
use cases so if I were to ask you why

00:02:32,920 --> 00:02:38,410
you might say well they offer a

00:02:36,100 --> 00:02:40,930
concision they express our code

00:02:38,410 --> 00:02:43,660
concisely sometimes some people might

00:02:40,930 --> 00:02:46,150
say for performance maybe or it may be

00:02:43,660 --> 00:02:51,280
something we think about take advantage

00:02:46,150 --> 00:02:52,840
of ADL maybe because we can or sometimes

00:02:51,280 --> 00:02:54,850
because we have to if we're putting

00:02:52,840 --> 00:02:58,690
things in a set for example we require

00:02:54,850 --> 00:03:01,990
things to have ordering or equality for

00:02:58,690 --> 00:03:05,380
other for other uses so for some or all

00:03:01,990 --> 00:03:07,180
these reasons maybe but one big reason I

00:03:05,380 --> 00:03:11,290
think is because when we use an operator

00:03:07,180 --> 00:03:15,610
it conveys meaning about our types that

00:03:11,290 --> 00:03:18,280
name functions can't so a grade school

00:03:15,610 --> 00:03:20,590
child can Intuit properties of addition

00:03:18,280 --> 00:03:21,730
right before we know the names of these

00:03:20,590 --> 00:03:23,620
properties before we know about

00:03:21,730 --> 00:03:26,050
commutativity and associativity and what

00:03:23,620 --> 00:03:27,850
to call these things we can Intuit these

00:03:26,050 --> 00:03:31,810
things when when we're six or seven and

00:03:27,850 --> 00:03:34,870
we learn this notation to go with it so

00:03:31,810 --> 00:03:38,400
when we use operators in C++ it tells

00:03:34,870 --> 00:03:41,860
our users it taps into this intuition

00:03:38,400 --> 00:03:44,350
that we have and addition is perhaps the

00:03:41,860 --> 00:03:46,900
canonical operator for this reason so

00:03:44,350 --> 00:03:49,660
saying that another way as it's been

00:03:46,900 --> 00:03:53,740
said by bianna it's probably wise to

00:03:49,660 --> 00:03:57,190
mimic primarily conventional use so that

00:03:53,740 --> 00:03:59,140
raises the question what is conventional

00:03:57,190 --> 00:04:02,040
right we're if we better be conventional

00:03:59,140 --> 00:04:04,560
what is conventional a counterpoint to

00:04:02,040 --> 00:04:07,630
you know thinking Commission is

00:04:04,560 --> 00:04:09,790
conventions change sometimes convention

00:04:07,630 --> 00:04:13,090
means just what I'm used to it might

00:04:09,790 --> 00:04:17,940
mean the only thing I've experienced so

00:04:13,090 --> 00:04:20,410
how many of you recognize this this item

00:04:17,940 --> 00:04:22,330
probably a little oh yeah a lot of

00:04:20,410 --> 00:04:24,040
people okay so this is the Canon did

00:04:22,330 --> 00:04:26,440
still exist solar elf I think it was

00:04:24,040 --> 00:04:27,160
called in the US it's it's 18 years old

00:04:26,440 --> 00:04:28,600
we

00:04:27,160 --> 00:04:32,080
pedia tells me so it's an adult this

00:04:28,600 --> 00:04:34,600
year it was it was a really good point

00:04:32,080 --> 00:04:35,890
and shoot digital camera right but even

00:04:34,600 --> 00:04:38,170
today when I say to you it's a digital

00:04:35,890 --> 00:04:39,940
camera that's kind of an anachronism

00:04:38,170 --> 00:04:41,740
because what what cameras aren't digital

00:04:39,940 --> 00:04:43,420
now you know really high-end

00:04:41,740 --> 00:04:45,880
professional photographers use film

00:04:43,420 --> 00:04:47,110
cameras but they also use digital the

00:04:45,880 --> 00:04:48,910
only reason to have a camera like this

00:04:47,110 --> 00:04:50,800
today when we all have a camera in our

00:04:48,910 --> 00:04:55,090
pocket anyway is that you want to save

00:04:50,800 --> 00:04:56,740
your phone battery so conventions change

00:04:55,090 --> 00:05:02,950
here's another good example of a changed

00:04:56,740 --> 00:05:10,600
convention so what we think of as kind

00:05:02,950 --> 00:05:13,510
of Marshall you have a you have one what

00:05:10,600 --> 00:05:16,420
we think of as axiomatic ie mathematical

00:05:13,510 --> 00:05:18,810
notation actually has changed a fair

00:05:16,420 --> 00:05:21,190
amount over history and even recently

00:05:18,810 --> 00:05:24,130
these these four names in particular are

00:05:21,190 --> 00:05:25,390
famous for inventing and or popularizing

00:05:24,130 --> 00:05:28,150
different elements of mathematical

00:05:25,390 --> 00:05:29,410
notation over the years now you look at

00:05:28,150 --> 00:05:32,110
this list and you say well that's fine

00:05:29,410 --> 00:05:38,560
but you know three hand that's 300 years

00:05:32,110 --> 00:05:41,310
old or so okay they say so so so what's

00:05:38,560 --> 00:05:41,310
the answer to this

00:05:41,940 --> 00:05:47,830
it depends okay so so three three okay

00:05:46,390 --> 00:05:49,540
this is a well-known approximation to PI

00:05:47,830 --> 00:05:51,960
right if we took my integers yes it's

00:05:49,540 --> 00:05:55,300
three well are you sure about that

00:05:51,960 --> 00:05:59,650
because until the turn of the 20th

00:05:55,300 --> 00:06:01,120
century this / symbol I mean when we

00:05:59,650 --> 00:06:04,750
want to say division it was much more

00:06:01,120 --> 00:06:05,830
common to say a colon and that notation

00:06:04,750 --> 00:06:09,130
is still used today when we talk about

00:06:05,830 --> 00:06:10,600
ratios even today a mathematician

00:06:09,130 --> 00:06:12,430
wouldn't normally write this they'd

00:06:10,600 --> 00:06:15,250
write a regular like two dimensional

00:06:12,430 --> 00:06:17,770
fraction as far as I can tell

00:06:15,250 --> 00:06:21,070
using slash for division is probably an

00:06:17,770 --> 00:06:24,340
artifact of computer terminals and if I

00:06:21,070 --> 00:06:25,750
ask you about what these mean well

00:06:24,340 --> 00:06:28,270
they're even more arbitrary really they

00:06:25,750 --> 00:06:30,400
were made up in about nineteen late 60s

00:06:28,270 --> 00:06:34,240
as I say these so these are only

00:06:30,400 --> 00:06:35,050
slightly older than me so so yes we want

00:06:34,240 --> 00:06:39,729
to be conventional

00:06:35,050 --> 00:06:40,960
but convention can change so where

00:06:39,729 --> 00:06:42,460
convention exists

00:06:40,960 --> 00:06:44,979
and sometimes where it exists outside

00:06:42,460 --> 00:06:49,360
the mathematics is an important source

00:06:44,979 --> 00:06:51,610
for for following it okay

00:06:49,360 --> 00:06:55,210
so some other operator overloading

00:06:51,610 --> 00:06:58,509
advice we might take from from Scott

00:06:55,210 --> 00:07:00,789
Myers so Scott Myers said in his book

00:06:58,509 --> 00:07:02,350
more effective C++ when in doubt do is

00:07:00,789 --> 00:07:04,930
the Institute so this is advice for

00:07:02,350 --> 00:07:09,310
designing our types in is well

00:07:04,930 --> 00:07:13,990
understood in is fast we could perhaps

00:07:09,310 --> 00:07:17,070
try and find an operator which act like

00:07:13,990 --> 00:07:20,440
int do in the sense of being canonical

00:07:17,070 --> 00:07:21,910
so I might ask the question how about we

00:07:20,440 --> 00:07:24,370
look at when in doubt do operate the

00:07:21,910 --> 00:07:27,070
plus does let's try and find the most

00:07:24,370 --> 00:07:29,080
normal operator in the sense and and see

00:07:27,070 --> 00:07:32,560
if we can devise some guidelines for

00:07:29,080 --> 00:07:35,050
overloading it so I want to ask you what

00:07:32,560 --> 00:07:40,539
are some properties of a plus in

00:07:35,050 --> 00:07:45,099
mathematics it's commutative its

00:07:40,539 --> 00:07:47,289
associative it's closed and somebody

00:07:45,099 --> 00:07:48,909
said it has a zero right it's closed

00:07:47,289 --> 00:07:51,159
it's associative is commutative it has

00:07:48,909 --> 00:07:55,720
an identity we'd call it a monoid right

00:07:51,159 --> 00:07:59,139
so now in C++ do we have those same

00:07:55,720 --> 00:08:01,419
properties if we're talking about

00:07:59,139 --> 00:08:03,310
closeness I mean so for unsigned int

00:08:01,419 --> 00:08:07,570
maybe all these things but that's not

00:08:03,310 --> 00:08:09,310
typically how we think of addition okay

00:08:07,570 --> 00:08:14,470
so we've got overflow so it's not really

00:08:09,310 --> 00:08:15,400
closed is it associative not always

00:08:14,470 --> 00:08:25,060
right

00:08:15,400 --> 00:08:28,949
is it commutative again no does it have

00:08:25,060 --> 00:08:32,550
an identity at least I would say yes

00:08:28,949 --> 00:08:32,550
sometimes it has more than one

00:08:32,970 --> 00:08:38,430
so we try to follow mathematical

00:08:36,060 --> 00:08:42,380
conventions but they're not always what

00:08:38,430 --> 00:08:44,520
we want to stick to dogmatically so

00:08:42,380 --> 00:08:47,760
operators are important though so in

00:08:44,520 --> 00:08:49,290
1956 the IT compiler the internal

00:08:47,760 --> 00:08:51,500
translator was a compiler for the IBM

00:08:49,290 --> 00:08:53,730
650 and it was perhaps the first

00:08:51,500 --> 00:08:55,860
compiler that we would recognize as a

00:08:53,730 --> 00:08:58,260
compiler in the modern sense ie

00:08:55,860 --> 00:09:00,690
translating human readable code into

00:08:58,260 --> 00:09:02,400
machine code prior to that there had

00:09:00,690 --> 00:09:04,440
been some of translators and things but

00:09:02,400 --> 00:09:06,930
this was the first sort of thing we'd

00:09:04,440 --> 00:09:09,270
recognize as a modern compiler but it

00:09:06,930 --> 00:09:12,180
had one downfall it didn't have operator

00:09:09,270 --> 00:09:16,080
precedence as we know it today and as a

00:09:12,180 --> 00:09:18,720
result of that it was very difficult to

00:09:16,080 --> 00:09:20,220
use for programmers it was the lack of

00:09:18,720 --> 00:09:22,890
operator precedence was the single

00:09:20,220 --> 00:09:26,460
greatest cause of errors so I think this

00:09:22,890 --> 00:09:32,550
tells us something about how operators

00:09:26,460 --> 00:09:34,650
convey meaning so I hope I've given a

00:09:32,550 --> 00:09:36,810
pretty good answer as to why we should

00:09:34,650 --> 00:09:38,340
use operators they convey meaning not

00:09:36,810 --> 00:09:40,380
just about the operations in the way

00:09:38,340 --> 00:09:44,160
that function names do but about the

00:09:40,380 --> 00:09:46,140
types that we act upon and because well

00:09:44,160 --> 00:09:48,900
use operators are readability through

00:09:46,140 --> 00:09:52,440
concision and because operators are at

00:09:48,900 --> 00:09:55,440
the heart of expressions and expressions

00:09:52,440 --> 00:09:56,610
allow manipulation to give us better

00:09:55,440 --> 00:10:01,410
readability and perhaps better

00:09:56,610 --> 00:10:04,790
performance all right so that's kind of

00:10:01,410 --> 00:10:09,900
a motivation now if we're talking about

00:10:04,790 --> 00:10:12,000
mathematical principles they're not all

00:10:09,900 --> 00:10:13,680
created equal which which one should we

00:10:12,000 --> 00:10:16,500
follow and I sort of thought about this

00:10:13,680 --> 00:10:18,240
and I so I have a selection of

00:10:16,500 --> 00:10:20,490
principles in order of importance

00:10:18,240 --> 00:10:22,830
approximately that I think are important

00:10:20,490 --> 00:10:26,910
to follow the first one the first one is

00:10:22,830 --> 00:10:30,150
is this if you if you break the opposite

00:10:26,910 --> 00:10:31,320
nurse of equality and inequality you

00:10:30,150 --> 00:10:32,880
certainly wouldn't pass a code review

00:10:31,320 --> 00:10:35,820
for me and I would hope from your peers

00:10:32,880 --> 00:10:40,080
so equality had better mean the opposite

00:10:35,820 --> 00:10:42,750
of inequality another very important one

00:10:40,080 --> 00:10:45,390
actually is associativity most of the

00:10:42,750 --> 00:10:46,890
things we do most of the types we use

00:10:45,390 --> 00:10:50,010
most of the operations we use

00:10:46,890 --> 00:10:51,390
our associative and the Scioscia Tiffa

00:10:50,010 --> 00:10:55,740
tea is one of the key properties that

00:10:51,390 --> 00:10:58,110
allows us to manipulate expressions now

00:10:55,740 --> 00:11:01,530
unfortunately in C++ we don't yet have

00:10:58,110 --> 00:11:04,170
the machinery to take advantage really

00:11:01,530 --> 00:11:08,700
of associativity fully or complete a

00:11:04,170 --> 00:11:09,870
couple of slides time this is this is

00:11:08,700 --> 00:11:11,520
kind of an important one if you can

00:11:09,870 --> 00:11:13,560
provide it the law of the excluded

00:11:11,520 --> 00:11:15,450
middle

00:11:13,560 --> 00:11:17,150
this makes thinking about ordering a

00:11:15,450 --> 00:11:19,710
whole lot easier

00:11:17,150 --> 00:11:21,660
so either either a proposition is true

00:11:19,710 --> 00:11:23,460
or its inverse is true and this is again

00:11:21,660 --> 00:11:25,700
this is mostly true notably not for

00:11:23,460 --> 00:11:28,590
float we'll come back to that in a bit

00:11:25,700 --> 00:11:31,650
but if you can if you can provide this

00:11:28,590 --> 00:11:34,170
this guarantee it makes thinking about

00:11:31,650 --> 00:11:36,450
ordering a lot a lot more easy and it

00:11:34,170 --> 00:11:39,840
makes writing your lesson operators kind

00:11:36,450 --> 00:11:43,020
of easier to think about and then we get

00:11:39,840 --> 00:11:45,170
on to the nice-to-haves so commutativity

00:11:43,020 --> 00:11:48,690
of plus is actually really nice to have

00:11:45,170 --> 00:11:54,810
and it's probably too late to fix stood

00:11:48,690 --> 00:11:57,060
string now also did reduce is sort of

00:11:54,810 --> 00:12:00,420
annoying to me because it requires

00:11:57,060 --> 00:12:01,860
commutativity where mathematically it

00:12:00,420 --> 00:12:03,090
might only require soceity

00:12:01,860 --> 00:12:05,060
i understand that it requires

00:12:03,090 --> 00:12:08,160
commutativity for efficient

00:12:05,060 --> 00:12:10,940
implementation and vectorization but

00:12:08,160 --> 00:12:17,190
it's sort of unfortunate that reduce

00:12:10,940 --> 00:12:19,220
requires commutativity price it ok

00:12:17,190 --> 00:12:20,820
all right

00:12:19,220 --> 00:12:22,470
apparently it doesn't require

00:12:20,820 --> 00:12:27,300
commutativity if you're prepared to live

00:12:22,470 --> 00:12:29,370
with undefined behavior alright but but

00:12:27,300 --> 00:12:31,140
I I would like us Bryce to get something

00:12:29,370 --> 00:12:35,000
in the standard that only requires

00:12:31,140 --> 00:12:38,880
associativity in a reduce like algorithm

00:12:35,000 --> 00:12:40,290
how about accumulate it's yes but

00:12:38,880 --> 00:12:42,480
accumulate that gives you the strict

00:12:40,290 --> 00:12:46,110
linear like a point of associative T is

00:12:42,480 --> 00:12:49,080
be able to group terms you do have to

00:12:46,110 --> 00:12:52,830
make tough choices alright well I won't

00:12:49,080 --> 00:12:55,710
get everything I want okay here's

00:12:52,830 --> 00:12:57,300
another nice to have a distributive law

00:12:55,710 --> 00:12:59,880
right this is something we learn in in

00:12:57,300 --> 00:13:02,030
middle school or something like that I

00:12:59,880 --> 00:13:04,400
didn't go to school in the u.s. so it

00:13:02,030 --> 00:13:07,230
but but anyway we learn it in school

00:13:04,400 --> 00:13:09,420
this is something that that allows us to

00:13:07,230 --> 00:13:11,190
manipulate expressions at these

00:13:09,420 --> 00:13:13,350
properties these last two properties I

00:13:11,190 --> 00:13:15,240
mentioned allude to a mathematical

00:13:13,350 --> 00:13:18,150
structure called a ring you could also

00:13:15,240 --> 00:13:21,210
say you know where plus plus and

00:13:18,150 --> 00:13:22,680
multiplication form a ring and an XOR

00:13:21,210 --> 00:13:24,290
also form a ring there are lots of

00:13:22,680 --> 00:13:26,310
things in mathematics that do this and

00:13:24,290 --> 00:13:29,250
you know we can think about things like

00:13:26,310 --> 00:13:30,750
de Morgan's laws and manipulations of

00:13:29,250 --> 00:13:33,540
expressions identities that we know from

00:13:30,750 --> 00:13:36,060
school if we make our types and our

00:13:33,540 --> 00:13:39,000
operators adhere to this kind of

00:13:36,060 --> 00:13:40,590
structure it gives our users the ability

00:13:39,000 --> 00:13:44,490
to apply those things that they already

00:13:40,590 --> 00:13:48,740
know so it behooves us to follow user

00:13:44,490 --> 00:13:51,960
expectations in designing our operators

00:13:48,740 --> 00:13:54,810
now this one more thing I have here is

00:13:51,960 --> 00:13:57,290
it's nice to have closeness to MIT and

00:13:54,810 --> 00:14:01,200
but to me this is an interesting sort of

00:13:57,290 --> 00:14:03,360
lever an interesting choice to make over

00:14:01,200 --> 00:14:05,190
your your types and your operators the

00:14:03,360 --> 00:14:10,230
important things to know whether or not

00:14:05,190 --> 00:14:12,900
you have closure over your time so you

00:14:10,230 --> 00:14:16,110
know in C++ even the division operator

00:14:12,900 --> 00:14:17,640
is closed over integral types which is a

00:14:16,110 --> 00:14:20,700
little strange but mathematically

00:14:17,640 --> 00:14:22,920
speaking but when we relaxed this rule

00:14:20,700 --> 00:14:26,880
of closeness it can lead to good design

00:14:22,920 --> 00:14:30,730
if we divide our types and that leads me

00:14:26,880 --> 00:14:34,340
to talking about a fine spaces

00:14:30,730 --> 00:14:36,770
so an a fine space is a basically a

00:14:34,340 --> 00:14:40,100
vector space where a distinction is made

00:14:36,770 --> 00:14:43,040
between a point type position and a

00:14:40,100 --> 00:14:44,960
vector type or a translation and it's

00:14:43,040 --> 00:14:47,000
quite possible even likely that in a

00:14:44,960 --> 00:14:50,810
given vector space those two things

00:14:47,000 --> 00:14:52,130
could be representational e the same and

00:14:50,810 --> 00:14:54,290
if it's likely although it's not

00:14:52,130 --> 00:14:58,490
required for a finds basis that your

00:14:54,290 --> 00:14:59,960
space has an origin so although the

00:14:58,490 --> 00:15:02,150
things are representational e the same

00:14:59,960 --> 00:15:04,160
vectors and points if we make them

00:15:02,150 --> 00:15:06,800
different types that leads us down an

00:15:04,160 --> 00:15:10,460
interesting path as designers of

00:15:06,800 --> 00:15:12,650
operators and designers of types so a

00:15:10,460 --> 00:15:15,650
fine spaces are types and operators

00:15:12,650 --> 00:15:17,560
working together as a team you have you

00:15:15,650 --> 00:15:20,360
have as I've said points are type 1

00:15:17,560 --> 00:15:22,640
vectors are type 2 and then you have

00:15:20,360 --> 00:15:23,960
operations that relate vectors to each

00:15:22,640 --> 00:15:26,600
other and relate point to the vectors

00:15:23,960 --> 00:15:28,040
and there's no need for an origin now

00:15:26,600 --> 00:15:32,120
there's a couple of good examples of a

00:15:28,040 --> 00:15:34,190
fine spaces in the standard the one I

00:15:32,120 --> 00:15:36,740
really like is chrono time point and

00:15:34,190 --> 00:15:38,600
duration now it's only a one dimensional

00:15:36,740 --> 00:15:44,120
a fine space but it's still an a fine

00:15:38,600 --> 00:15:47,480
space and by looking at it that way it

00:15:44,120 --> 00:15:51,590
tells us it helps us define the space of

00:15:47,480 --> 00:15:53,660
operations that we can use and the ones

00:15:51,590 --> 00:15:55,610
that makes sense so chrono defines these

00:15:53,660 --> 00:15:59,600
operations it might define a few more

00:15:55,610 --> 00:16:01,640
but but I've you know slide where so we

00:15:59,600 --> 00:16:03,380
know that addition and you know

00:16:01,640 --> 00:16:06,200
subtraction therefore is closed over

00:16:03,380 --> 00:16:07,610
vectors ie durations and we know that

00:16:06,200 --> 00:16:11,720
when we take away one point for another

00:16:07,610 --> 00:16:14,240
we get a vector iteration but we can

00:16:11,720 --> 00:16:17,210
also think about scaling vectors that's

00:16:14,240 --> 00:16:21,890
why we have the operator star and

00:16:17,210 --> 00:16:23,660
operator slash since we're in a one

00:16:21,890 --> 00:16:26,840
dimensional affine space it makes sense

00:16:23,660 --> 00:16:29,840
to have a modulus operation dividing one

00:16:26,840 --> 00:16:31,820
duration by another if we were in a two

00:16:29,840 --> 00:16:33,560
dimensional affine space it might make

00:16:31,820 --> 00:16:35,120
sense to have a dot product we could

00:16:33,560 --> 00:16:37,850
think about you know when we think about

00:16:35,120 --> 00:16:40,700
things in a find space terms we get to

00:16:37,850 --> 00:16:42,950
leverage all of the knowledge of

00:16:40,700 --> 00:16:44,270
mathematics to sort of help us flesh out

00:16:42,950 --> 00:16:46,880
the design space

00:16:44,270 --> 00:16:52,010
of our types and our operations and

00:16:46,880 --> 00:16:53,810
that's that's really useful so and

00:16:52,010 --> 00:16:56,420
answer the question why should we

00:16:53,810 --> 00:16:59,150
overload conventionally because it helps

00:16:56,420 --> 00:17:01,670
users with intuition manipulation and

00:16:59,150 --> 00:17:05,589
properties of types but also because it

00:17:01,670 --> 00:17:09,440
helps us as type designers and opera and

00:17:05,589 --> 00:17:11,300
implementers it helps us identify what

00:17:09,440 --> 00:17:13,970
is a complete basis for our type

00:17:11,300 --> 00:17:16,339
what is minimality versus convenience

00:17:13,970 --> 00:17:18,860
functions which functions are likely to

00:17:16,339 --> 00:17:21,920
be efficient or otherwise and in general

00:17:18,860 --> 00:17:28,400
it helps us explore the type and

00:17:21,920 --> 00:17:29,900
operation space that we're going for now

00:17:28,400 --> 00:17:31,430
the other reason to be conventional is

00:17:29,900 --> 00:17:34,790
of course it helps us leverage outside

00:17:31,430 --> 00:17:36,530
users leverage compositionality aspects

00:17:34,790 --> 00:17:40,100
that are built into the language and the

00:17:36,530 --> 00:17:42,290
library in terms of stood accumulate and

00:17:40,100 --> 00:17:44,330
reduce in the library and and you know

00:17:42,290 --> 00:17:46,550
all of the I forget all of the names of

00:17:44,330 --> 00:17:47,960
the algorithms like the reduced the

00:17:46,550 --> 00:17:50,020
reduction type algorithms there are

00:17:47,960 --> 00:17:53,420
there are four or five of them I think

00:17:50,020 --> 00:17:58,850
and of course in the language in super /

00:17:53,420 --> 00:18:01,460
17 we got fold expressions so let's talk

00:17:58,850 --> 00:18:04,610
a little bit about what came new in C +

00:18:01,460 --> 00:18:09,820
17 and how that influences what we might

00:18:04,610 --> 00:18:12,590
do with operators so fold expressions

00:18:09,820 --> 00:18:15,080
fold or reduce a parameter pack over a

00:18:12,590 --> 00:18:16,820
binary operator this is a binary left

00:18:15,080 --> 00:18:19,040
fold and it acts like it's left

00:18:16,820 --> 00:18:22,850
associative so things are grouping to

00:18:19,040 --> 00:18:25,190
the left which is sort of obvious if you

00:18:22,850 --> 00:18:28,700
look at this example because C out

00:18:25,190 --> 00:18:30,970
the type of C out is such that it kind

00:18:28,700 --> 00:18:33,950
of this can only group to the left right

00:18:30,970 --> 00:18:36,610
most of the operators we use are left

00:18:33,950 --> 00:18:39,650
associative things like plus multiply

00:18:36,610 --> 00:18:40,880
and so most of time if you don't if you

00:18:39,650 --> 00:18:42,680
don't care if you know if it's not

00:18:40,880 --> 00:18:46,160
important to you this left to right

00:18:42,680 --> 00:18:49,130
grouping is just fine but if you have an

00:18:46,160 --> 00:18:50,150
operator which is not commutative fold

00:18:49,130 --> 00:18:52,280
expression has become even more

00:18:50,150 --> 00:18:55,380
important if you have let's say matrix

00:18:52,280 --> 00:18:57,150
multiply because

00:18:55,380 --> 00:18:58,980
fold expressions allow you to choose

00:18:57,150 --> 00:19:00,950
left fold or right fold and if you have

00:18:58,980 --> 00:19:04,980
an expression which is not commutative

00:19:00,950 --> 00:19:07,440
that becomes an important choice the

00:19:04,980 --> 00:19:08,940
operation is usually associative so it

00:19:07,440 --> 00:19:11,550
doesn't matter which way the pack is

00:19:08,940 --> 00:19:16,770
folded except in that application to the

00:19:11,550 --> 00:19:18,860
ignition to the initial argument now so

00:19:16,770 --> 00:19:22,020
if you have a non commutative operation

00:19:18,860 --> 00:19:24,120
fold expressions are easy you can write

00:19:22,020 --> 00:19:25,710
them either one way around or the other

00:19:24,120 --> 00:19:28,850
way around

00:19:25,710 --> 00:19:32,000
accumulate is much less easy to write I

00:19:28,850 --> 00:19:34,560
think I have there in a couple of slides

00:19:32,000 --> 00:19:35,730
talking about fold expressions I just

00:19:34,560 --> 00:19:39,030
wanted to touch on unary fold

00:19:35,730 --> 00:19:41,690
expressions they are they are defined

00:19:39,030 --> 00:19:44,520
for logical and logical law and comma

00:19:41,690 --> 00:19:46,350
I'm going to tell you in the like you

00:19:44,520 --> 00:19:53,070
shouldn't probably still overload those

00:19:46,350 --> 00:19:54,720
operators because so what happened was

00:19:53,070 --> 00:19:57,000
with super per 17 we got these

00:19:54,720 --> 00:19:59,370
evaluation or the guarantees with po4

00:19:57,000 --> 00:20:03,140
were a 1 4 5 and it changed things

00:19:59,370 --> 00:20:06,570
slightly for these three operators so

00:20:03,140 --> 00:20:11,190
prior to c++ 17 if you overload let's

00:20:06,570 --> 00:20:13,890
say logical and you don't get you don't

00:20:11,190 --> 00:20:16,560
get the sequencing of the evaluation and

00:20:13,890 --> 00:20:20,370
you don't get the short-circuiting after

00:20:16,560 --> 00:20:23,310
c++ 17 you do get the sequencing but you

00:20:20,370 --> 00:20:25,320
still don't get the short-circuiting so

00:20:23,310 --> 00:20:32,370
i would still stay away from overloading

00:20:25,320 --> 00:20:37,470
these operators but they are really a so

00:20:32,370 --> 00:20:39,510
in Super 17 to recap associativity

00:20:37,470 --> 00:20:41,670
really important for fold expressions if

00:20:39,510 --> 00:20:43,050
you have a non commutative operator even

00:20:41,670 --> 00:20:45,660
more important or a non commutative

00:20:43,050 --> 00:20:48,690
function overloading an operator for it

00:20:45,660 --> 00:20:50,460
allows you to use fold expressions and

00:20:48,690 --> 00:20:54,030
you probably still don't want to mess

00:20:50,460 --> 00:20:57,870
with those other operators so just just

00:20:54,030 --> 00:21:00,920
to kind of drive home the point about if

00:20:57,870 --> 00:21:03,990
you have non commutativity to use

00:21:00,920 --> 00:21:06,690
accumulate is it is a pain to make it do

00:21:03,990 --> 00:21:08,940
a write fold you have to do something

00:21:06,690 --> 00:21:12,270
like this so

00:21:08,940 --> 00:21:14,490
have this right multiplies struct note

00:21:12,270 --> 00:21:18,000
that the order of operate the order of

00:21:14,490 --> 00:21:19,430
operands to that is flipped around on

00:21:18,000 --> 00:21:21,800
line four

00:21:19,430 --> 00:21:25,620
where I call operation there and

00:21:21,800 --> 00:21:27,930
accumulate users reverse iterators to

00:21:25,620 --> 00:21:29,550
write this and and this isn't even fully

00:21:27,930 --> 00:21:32,370
generic but to write this in a generic

00:21:29,550 --> 00:21:35,810
way to apply something on the right is

00:21:32,370 --> 00:21:39,540
as you can see a lot more work than

00:21:35,810 --> 00:21:43,290
doing just a right fold with with a

00:21:39,540 --> 00:21:46,680
folder praetor this is much nicer much

00:21:43,290 --> 00:21:48,120
clearer in intent and your users get

00:21:46,680 --> 00:21:50,450
this for free without having to go

00:21:48,120 --> 00:21:54,480
through jump through the hoops of

00:21:50,450 --> 00:21:58,670
writing that accumulate right fold so

00:21:54,480 --> 00:22:00,840
that was kind of what's new in c-plus 17

00:21:58,670 --> 00:22:07,110
let's look a little bit about what's

00:22:00,840 --> 00:22:11,820
coming in C++ 20 we got a whole new

00:22:07,110 --> 00:22:15,690
operator and it's officially called the

00:22:11,820 --> 00:22:17,190
3 way comparison operator and this

00:22:15,690 --> 00:22:18,750
quality colloquially called the

00:22:17,190 --> 00:22:20,780
spaceship operator it's even called that

00:22:18,750 --> 00:22:22,980
under standard expert spaceship

00:22:20,780 --> 00:22:26,370
you've probably heard something about it

00:22:22,980 --> 00:22:28,590
it's designed to be a 3-way comparison

00:22:26,370 --> 00:22:32,490
on its top brands X&Y something like

00:22:28,590 --> 00:22:35,070
struck amp so informally it's if X is

00:22:32,490 --> 00:22:36,870
less than Y return sort of negative 1 if

00:22:35,070 --> 00:22:39,980
X is equal to Y return 0 if it is

00:22:36,870 --> 00:22:42,900
greater than Y returned greater than 0

00:22:39,980 --> 00:22:46,020
informally so I've got this flamer for

00:22:42,900 --> 00:22:48,300
this section everything's really new so

00:22:46,020 --> 00:22:50,280
new that it's not yet implemented in

00:22:48,300 --> 00:22:52,380
some cases so I'm going to try to tell

00:22:50,280 --> 00:22:54,810
you about what I think I know so far

00:22:52,380 --> 00:22:58,170
well I think we know I've talked to a

00:22:54,810 --> 00:23:02,090
few people about this so when you

00:22:58,170 --> 00:23:07,680
include compare that's the new header

00:23:02,090 --> 00:23:12,500
you get these five types and these types

00:23:07,680 --> 00:23:12,500
are comparison categories

00:23:13,020 --> 00:23:17,190
they're strong equality and weak

00:23:14,490 --> 00:23:20,040
equality strong ordering weak ordering

00:23:17,190 --> 00:23:21,900
and partial ordering so when you

00:23:20,040 --> 00:23:26,250
overload the spaceship operator for your

00:23:21,900 --> 00:23:28,590
type it returns it returns one of these

00:23:26,250 --> 00:23:32,220
types right and which type it returns

00:23:28,590 --> 00:23:36,120
depends on what you want for your for

00:23:32,220 --> 00:23:38,220
your for your type now this difference

00:23:36,120 --> 00:23:40,470
between strong versus weak here is what

00:23:38,220 --> 00:23:43,020
the standard calls substitutability and

00:23:40,470 --> 00:23:48,300
it's the idea that if I have two values

00:23:43,020 --> 00:23:52,650
x and y let's say they compare equal if

00:23:48,300 --> 00:23:54,420
that's strong equality then I can't tell

00:23:52,650 --> 00:23:57,420
the difference between them by anything

00:23:54,420 --> 00:24:00,300
that that their public interface exposes

00:23:57,420 --> 00:24:03,420
so so strong equality means if X is

00:24:00,300 --> 00:24:05,809
equal to Y then f of X for some function

00:24:03,420 --> 00:24:09,120
is equal to F of Y there's substitutable

00:24:05,809 --> 00:24:10,679
weak equality doesn't have that and

00:24:09,120 --> 00:24:13,080
similarly for strong ordering a weak

00:24:10,679 --> 00:24:16,500
ordering it's the same distinction and

00:24:13,080 --> 00:24:18,720
we'll get to partial ordering so I've

00:24:16,500 --> 00:24:20,580
got some examples of things that I think

00:24:18,720 --> 00:24:27,210
could fall into each category don't

00:24:20,580 --> 00:24:28,860
understand this price you're gonna what

00:24:27,210 --> 00:24:39,390
if you write the spaceship operator and

00:24:28,860 --> 00:24:43,740
you don't include the header if are you

00:24:39,390 --> 00:24:45,030
allowed to I wouldn't recommend it I

00:24:43,740 --> 00:24:47,100
would recommend including the header

00:24:45,030 --> 00:24:50,690
will you tell me you probably have more

00:24:47,100 --> 00:24:50,690
information about this than I do right

00:24:52,730 --> 00:24:58,080
so if you if you implement the operator

00:24:55,559 --> 00:25:16,440
and return literally negative 1 0 or 1

00:24:58,080 --> 00:25:19,680
does that work yes yes

00:25:16,440 --> 00:25:22,050
so don't overload operators and have the

00:25:19,680 --> 00:25:28,320
return things but the standard doesn't

00:25:22,050 --> 00:25:30,120
cover so again that disclaimer on this

00:25:28,320 --> 00:25:34,010
part it's very new the code I'm going to

00:25:30,120 --> 00:25:37,230
show you in a couple of slides works on

00:25:34,010 --> 00:25:39,450
like clang trunk or GCC trunk or

00:25:37,230 --> 00:25:41,790
something on God Bob but but sort of

00:25:39,450 --> 00:25:43,640
partially works so the idea is that if

00:25:41,790 --> 00:25:46,350
you give if you provide this operator

00:25:43,640 --> 00:25:48,210
you get all of the comparison operators

00:25:46,350 --> 00:25:53,960
for your type and that isn't necessarily

00:25:48,210 --> 00:25:56,760
true of compilers today alright so so I

00:25:53,960 --> 00:25:58,110
think and again these things I'm going

00:25:56,760 --> 00:25:59,790
to show you some of them have stood in

00:25:58,110 --> 00:26:00,750
front of them these aren't all defined

00:25:59,790 --> 00:26:03,180
for the standard yet but these are

00:26:00,750 --> 00:26:05,820
examples of just illustrative examples

00:26:03,180 --> 00:26:07,470
of things I think would fall into each

00:26:05,820 --> 00:26:10,560
category just to help you understand the

00:26:07,470 --> 00:26:11,640
categories strong equality note that

00:26:10,560 --> 00:26:14,130
we're not talking about ordering yet

00:26:11,640 --> 00:26:15,300
strong equality means means I can't tell

00:26:14,130 --> 00:26:16,860
the difference between two things that

00:26:15,300 --> 00:26:18,150
are equal if I have two things are equal

00:26:16,860 --> 00:26:20,490
there's no function I could call them to

00:26:18,150 --> 00:26:23,730
distinguish them so something that might

00:26:20,490 --> 00:26:25,170
fall into that category is type info you

00:26:23,730 --> 00:26:26,460
have to type impose they're equal if you

00:26:25,170 --> 00:26:30,540
call function on them what you get out

00:26:26,460 --> 00:26:32,640
should still be equal it's actually

00:26:30,540 --> 00:26:34,620
quite hard to find examples of weak

00:26:32,640 --> 00:26:38,970
equality in the standard but I think

00:26:34,620 --> 00:26:41,280
file system path is a candidate you can

00:26:38,970 --> 00:26:43,200
think about having a relative path at an

00:26:41,280 --> 00:26:45,540
absolute path that refer to the same

00:26:43,200 --> 00:26:47,700
thing the same object on disk they're

00:26:45,540 --> 00:26:50,400
equivalent but they might not be equal

00:26:47,700 --> 00:26:52,650
in representation right so you might be

00:26:50,400 --> 00:26:54,900
able to tell the difference between them

00:26:52,650 --> 00:26:56,970
through their public interfaces but they

00:26:54,900 --> 00:26:59,670
are in some sense equivalent and and

00:26:56,970 --> 00:27:04,350
weak equality gives that notion of

00:26:59,670 --> 00:27:08,010
equivalence now when this gets when an

00:27:04,350 --> 00:27:10,560
if file system path is actually given an

00:27:08,010 --> 00:27:12,240
operator spaceship in the standard I

00:27:10,560 --> 00:27:13,590
don't know whether it will be with

00:27:12,240 --> 00:27:15,350
equivalence or whether it we might

00:27:13,590 --> 00:27:19,140
decide to give it some ordering as well

00:27:15,350 --> 00:27:22,100
that's possible but but we it's a good

00:27:19,140 --> 00:27:24,180
illustrative example of weak equivalence

00:27:22,100 --> 00:27:28,830
all right so let's let's look at

00:27:24,180 --> 00:27:30,300
ordering so both strong ordering and

00:27:28,830 --> 00:27:32,910
weak ordering are

00:27:30,300 --> 00:27:34,530
examples of a total ordering which means

00:27:32,910 --> 00:27:36,840
that exactly one of the following is

00:27:34,530 --> 00:27:41,160
true either either a is less than B a is

00:27:36,840 --> 00:27:43,500
greater than B or they're equal victor

00:27:41,160 --> 00:27:45,210
iterators or iterators into add a

00:27:43,500 --> 00:27:47,880
structure in general or a good example

00:27:45,210 --> 00:27:49,380
of a strong ordering which is to say

00:27:47,880 --> 00:27:53,610
that the remember the strong property

00:27:49,380 --> 00:27:56,370
has the substitutability so you'll

00:27:53,610 --> 00:27:58,050
always be able to compare vector

00:27:56,370 --> 00:27:59,790
iterators let's say so

00:27:58,050 --> 00:28:00,960
notice that there's still a precondition

00:27:59,790 --> 00:28:06,300
there they still actually have to be

00:28:00,960 --> 00:28:07,770
into the same vector and again weak

00:28:06,300 --> 00:28:09,750
ordering is another one these things

00:28:07,770 --> 00:28:11,250
where it's actually hard to find types

00:28:09,750 --> 00:28:15,000
in the standard that might fit into this

00:28:11,250 --> 00:28:16,800
category case insensitive strings which

00:28:15,000 --> 00:28:18,270
admittedly under standard but but they

00:28:16,800 --> 00:28:20,820
are a good example of weak ordering

00:28:18,270 --> 00:28:22,470
right because they would again compared

00:28:20,820 --> 00:28:24,380
always be able to compare them greater

00:28:22,470 --> 00:28:27,900
than less than or equal to in some sense

00:28:24,380 --> 00:28:30,170
but they wouldn't be strongly equal to

00:28:27,900 --> 00:28:30,170
each other

00:28:30,680 --> 00:28:36,150
now welcome to partial ordering it's the

00:28:34,470 --> 00:28:38,460
case that none of these things may be

00:28:36,150 --> 00:28:39,960
true so that's it I've seen total

00:28:38,460 --> 00:28:41,820
ordering and partial ordering there are

00:28:39,960 --> 00:28:43,170
some things which aren't orderable is

00:28:41,820 --> 00:28:45,330
what partial ordering says and the

00:28:43,170 --> 00:28:49,350
famous example of that is it's floats

00:28:45,330 --> 00:28:52,500
because we have not number all right so

00:28:49,350 --> 00:28:54,390
that's a quick quick rundown of the

00:28:52,500 --> 00:28:55,920
spaceship operator remembering all this

00:28:54,390 --> 00:28:57,270
is new but I thought you know I take

00:28:55,920 --> 00:28:57,830
this frisbee and I take it for a test

00:28:57,270 --> 00:29:02,310
drive

00:28:57,830 --> 00:29:05,940
last year's SCM challenge and well this

00:29:02,310 --> 00:29:07,500
sitting right in the middle here this so

00:29:05,940 --> 00:29:08,940
this was a challenge at last year's seat

00:29:07,500 --> 00:29:12,300
become one the coding challenges and

00:29:08,940 --> 00:29:13,890
that and it was to write a write

00:29:12,300 --> 00:29:18,210
comparison operators for this case

00:29:13,890 --> 00:29:19,830
insensitive string class CI string and I

00:29:18,210 --> 00:29:21,120
came up with a solution Manuel came up

00:29:19,830 --> 00:29:27,350
with a solution I think I think they

00:29:21,120 --> 00:29:29,760
were pretty much equivalent weekly equal

00:29:27,350 --> 00:29:32,550
so so here's how I solved it and here's

00:29:29,760 --> 00:29:34,740
how you might solve it right so we need

00:29:32,550 --> 00:29:36,510
to come we need let we need equality and

00:29:34,740 --> 00:29:40,440
ordering on the case insensitive string

00:29:36,510 --> 00:29:44,160
so prior to C++ 17 or 20 let's say we

00:29:40,440 --> 00:29:47,430
write a case insensitive comparison

00:29:44,160 --> 00:29:50,610
functor for for equality and one for

00:29:47,430 --> 00:29:52,620
less than and we're not dealing with

00:29:50,610 --> 00:29:56,760
like unicode characters here so we're

00:29:52,620 --> 00:29:58,950
just calling to upper and then we write

00:29:56,760 --> 00:30:01,490
the quality operator and operator less

00:29:58,950 --> 00:30:03,990
than and in terms of that operator

00:30:01,490 --> 00:30:08,010
calling stood equal and then calling

00:30:03,990 --> 00:30:11,150
stood lexicographical pair okay

00:30:08,010 --> 00:30:14,070
everyone happy with that so once we have

00:30:11,150 --> 00:30:15,900
those two operators then we implement

00:30:14,070 --> 00:30:19,560
then we can implement that rep the rest

00:30:15,900 --> 00:30:22,020
and the way they get implemented is

00:30:19,560 --> 00:30:24,150
pretty much always the same this you can

00:30:22,020 --> 00:30:26,700
substitute almost any type for CI string

00:30:24,150 --> 00:30:29,160
here once you have that equality and

00:30:26,700 --> 00:30:31,350
less than these functions don't change

00:30:29,160 --> 00:30:34,580
this is kind of the canonical way to

00:30:31,350 --> 00:30:39,480
implement the comparison operators

00:30:34,580 --> 00:30:41,880
notice that we never do we flip around

00:30:39,480 --> 00:30:44,880
the operands so that we always do

00:30:41,880 --> 00:30:47,160
exactly one operation here sometimes or

00:30:44,880 --> 00:30:50,070
not but we basically don't in particular

00:30:47,160 --> 00:30:53,480
to do less than or equal to we don't do

00:30:50,070 --> 00:30:56,670
the naive thing of less than or equal to

00:30:53,480 --> 00:30:57,990
so this is this is the sort of canonical

00:30:56,670 --> 00:31:00,750
and efficient way to implement these

00:30:57,990 --> 00:31:04,950
operators there are also free functions

00:31:00,750 --> 00:31:07,470
as you can note and free functions are

00:31:04,950 --> 00:31:09,590
in general a little bit better than

00:31:07,470 --> 00:31:13,080
member functions I prefer them because

00:31:09,590 --> 00:31:14,940
well for two reasons one they increase

00:31:13,080 --> 00:31:16,790
encapsulation if you're working in terms

00:31:14,940 --> 00:31:20,880
of the public interface of your type

00:31:16,790 --> 00:31:22,500
that's generally a good thing the

00:31:20,880 --> 00:31:26,570
slightly more nuanced reason is that it

00:31:22,500 --> 00:31:31,950
puts both operands on equal footing

00:31:26,570 --> 00:31:37,260
which is somehow easier to think about

00:31:31,950 --> 00:31:39,750
in terms of the mathematics of it so and

00:31:37,260 --> 00:31:41,730
if you can possibly make operate the the

00:31:39,750 --> 00:31:45,060
equality operator and the less than

00:31:41,730 --> 00:31:46,890
operator be free as well so much the

00:31:45,060 --> 00:31:49,080
better sometimes they need to be friends

00:31:46,890 --> 00:31:53,340
but if they can be if they can be free

00:31:49,080 --> 00:31:58,740
that's great all right so

00:31:53,340 --> 00:32:02,690
that is the pre C++ 20 picture Manuel I

00:31:58,740 --> 00:32:02,690
right and yours looked very similar yes

00:32:03,169 --> 00:32:12,269
you used a macro okay so this is slide

00:32:10,139 --> 00:32:14,820
where that the full thing last year was

00:32:12,269 --> 00:32:17,009
comparison with contrast are and strings

00:32:14,820 --> 00:32:21,899
and string views and thing Claire but

00:32:17,009 --> 00:32:22,889
but basically basically this this is

00:32:21,899 --> 00:32:26,820
this is how you do it

00:32:22,889 --> 00:32:29,820
so with C++ 20 what does the spaceship

00:32:26,820 --> 00:32:32,970
operator give us over how it so I should

00:32:29,820 --> 00:32:35,519
say that in order to do this for const

00:32:32,970 --> 00:32:38,490
char star string the amount of code was

00:32:35,519 --> 00:32:39,929
a lot and it was all pretty much all

00:32:38,490 --> 00:32:43,980
boilerplate as you can see like I said

00:32:39,929 --> 00:32:46,049
this these dozen lines they never change

00:32:43,980 --> 00:32:47,159
you can just copy replace your type in

00:32:46,049 --> 00:32:50,759
there

00:32:47,159 --> 00:32:52,289
copy paste your type and these never

00:32:50,759 --> 00:32:53,879
change so this is boilerplate and for

00:32:52,289 --> 00:32:58,919
having many types you need to stamp this

00:32:53,879 --> 00:33:01,169
out for you had to do this before c++ 20

00:32:58,919 --> 00:33:03,289
well well you could use stood rel ops

00:33:01,169 --> 00:33:05,820
but i think there are other reasons

00:33:03,289 --> 00:33:06,929
marshall saying though that I shouldn't

00:33:05,820 --> 00:33:12,419
have mentioned that strike that from the

00:33:06,929 --> 00:33:16,369
record police okay so how does that

00:33:12,419 --> 00:33:20,580
change with 20 well you can write this

00:33:16,369 --> 00:33:22,769
so this is operator spaceship operator

00:33:20,580 --> 00:33:24,360
the three-way comparison operator it

00:33:22,769 --> 00:33:27,409
returns a weak ordering because remember

00:33:24,360 --> 00:33:30,779
this is our case insensitive string and

00:33:27,409 --> 00:33:35,369
there's a new algorithm lexicographical

00:33:30,779 --> 00:33:37,139
compare three-way and what that takes as

00:33:35,369 --> 00:33:38,009
its comparison that compares the

00:33:37,139 --> 00:33:44,429
underlying chars

00:33:38,009 --> 00:33:47,129
is itself a three-way comparison so if

00:33:44,429 --> 00:33:51,480
you look at that lambda we are we are

00:33:47,129 --> 00:33:53,879
returning one of a thing of type stood

00:33:51,480 --> 00:33:56,299
we'd week ordering and those are

00:33:53,879 --> 00:33:58,860
basically enumerations

00:33:56,299 --> 00:34:02,960
so we return one of one of the

00:33:58,860 --> 00:34:02,960
appropriate the appropriate enumeration

00:34:02,990 --> 00:34:09,570
and and with another nod to c++ 20 here

00:34:07,230 --> 00:34:11,369
we don't have to write a functor anymore

00:34:09,570 --> 00:34:13,589
we can now pass a lambda indirectly

00:34:11,369 --> 00:34:20,970
because non capturing lambdas are

00:34:13,589 --> 00:34:25,859
default constructible in c++ 20 everyone

00:34:20,970 --> 00:34:30,510
good with this slide so in the previous

00:34:25,859 --> 00:34:33,270
slide here I defined focus struct CI

00:34:30,510 --> 00:34:37,079
compare equal and CI compare less with

00:34:33,270 --> 00:34:39,839
operator paren now in C++ 20 and I and I

00:34:37,079 --> 00:34:43,530
passed them in here too to the to the

00:34:39,839 --> 00:34:47,250
algorithms in C++ 20 I can pass a lambda

00:34:43,530 --> 00:34:48,720
directly to the algorithm and it's it's

00:34:47,250 --> 00:34:51,210
type is inferred obviously we can't we

00:34:48,720 --> 00:34:53,099
can't say the type of the lambda and but

00:34:51,210 --> 00:34:58,140
the algorithm knows how to if the lambda

00:34:53,099 --> 00:34:59,460
doesn't capture anything in C++ 20 non

00:34:58,140 --> 00:35:01,349
capturing lambdas are now default

00:34:59,460 --> 00:35:02,700
constructible so just by knowing the

00:35:01,349 --> 00:35:05,750
type the algorithm knows that it can

00:35:02,700 --> 00:35:05,750
construct all when it needs to

00:35:18,490 --> 00:35:23,660
that's right no okay so that's not

00:35:21,470 --> 00:35:25,220
what's happening here is the comment non

00:35:23,660 --> 00:35:26,150
capturing lambdas decay defunct pointer

00:35:25,220 --> 00:35:30,140
that's true

00:35:26,150 --> 00:35:49,250
so okay but this doesn't compile prior

00:35:30,140 --> 00:35:51,380
to C++ 20 okay so so I could so I could

00:35:49,250 --> 00:35:53,960
define the lambda out of outside the

00:35:51,380 --> 00:35:56,020
function call and just deckle type it as

00:35:53,960 --> 00:35:58,940
a template pro as a template argument

00:35:56,020 --> 00:36:02,050
right okay sorry

00:35:58,940 --> 00:36:04,640
slide where the point stands though that

00:36:02,050 --> 00:36:08,170
lambdas that don't capture our default

00:36:04,640 --> 00:36:11,630
constructor poncey plus 20 so you can

00:36:08,170 --> 00:36:15,080
say if you can use them much more nicely

00:36:11,630 --> 00:36:21,860
with things like this so I ask again is

00:36:15,080 --> 00:36:28,280
everyone cool with this approach some

00:36:21,860 --> 00:36:31,970
people say yes in general with so

00:36:28,280 --> 00:36:34,490
there's a problem with this slide the

00:36:31,970 --> 00:36:35,000
problem is well so this this absolutely

00:36:34,490 --> 00:36:36,260
works

00:36:35,000 --> 00:36:37,610
this function does ever I mean assuming

00:36:36,260 --> 00:36:42,470
compiler support and everything this

00:36:37,610 --> 00:36:45,380
this works the problem is what if we

00:36:42,470 --> 00:36:47,060
just wanted to check equality what this

00:36:45,380 --> 00:36:49,250
this function is doing a lot more work

00:36:47,060 --> 00:36:52,220
than it needs to do to check the quality

00:36:49,250 --> 00:36:54,950
of case-insensitive strings because when

00:36:52,220 --> 00:36:56,600
we call stood equal before there's like

00:36:54,950 --> 00:36:58,910
early outs for different length strings

00:36:56,600 --> 00:37:01,040
and things like that I don't want to

00:36:58,910 --> 00:37:03,380
incur a lexicographical compare

00:37:01,040 --> 00:37:06,650
three-way on to strings where I could

00:37:03,380 --> 00:37:13,370
just early out if I'm just wanting

00:37:06,650 --> 00:37:15,560
equality so yes this works but this

00:37:13,370 --> 00:37:18,350
tells me that library support isn't

00:37:15,560 --> 00:37:19,060
quite there yet for for the spaceship

00:37:18,350 --> 00:37:23,360
operator

00:37:19,060 --> 00:37:25,460
there's no stood equal three-way yet now

00:37:23,360 --> 00:37:27,860
now I could write this function and I

00:37:25,460 --> 00:37:29,840
believe that I could also overload my

00:37:27,860 --> 00:37:31,880
equal equal operator for this type and

00:37:29,840 --> 00:37:36,800
get back that performance

00:37:31,880 --> 00:37:38,900
I think that's that's true but but

00:37:36,800 --> 00:37:40,520
jumping on the bandwagon of the space

00:37:38,900 --> 00:37:43,190
your friends and this is perfectly like

00:37:40,520 --> 00:37:44,840
fair a fair observation because I mean

00:37:43,190 --> 00:37:45,380
see four plus 20 is still two years away

00:37:44,840 --> 00:37:48,230
right

00:37:45,380 --> 00:38:01,190
we've got time to work this out we're

00:37:48,230 --> 00:38:03,200
still working on this but so so so the

00:38:01,190 --> 00:38:06,110
question is couldn't it return now it

00:38:03,200 --> 00:38:07,490
doesn't know whether you want it whether

00:38:06,110 --> 00:38:10,880
you want it wanting to test for equality

00:38:07,490 --> 00:38:12,460
or less then it's only saying when you

00:38:10,880 --> 00:38:14,900
call lexicographical compare three-way

00:38:12,460 --> 00:38:15,680
it's giving you back that minus one zero

00:38:14,900 --> 00:38:16,820
or one

00:38:15,680 --> 00:38:20,510
it doesn't know whether you actually

00:38:16,820 --> 00:38:37,270
want zero or other it has to give you

00:38:20,510 --> 00:38:40,280
one of the three and it has to yes so so

00:38:37,270 --> 00:38:43,940
as soon as there is a difference it can

00:38:40,280 --> 00:38:45,410
it can return yes but you don't get the

00:38:43,940 --> 00:38:47,720
early out behavior that you get was

00:38:45,410 --> 00:38:49,310
stood equal where you can very cheaply

00:38:47,720 --> 00:38:50,930
upfront check the length of the strings

00:38:49,310 --> 00:38:52,670
they can never be equal if they're

00:38:50,930 --> 00:38:54,440
different lengths right so if all I

00:38:52,670 --> 00:38:56,270
wanted was equality I'm leaving

00:38:54,440 --> 00:38:58,040
performance on the table with less

00:38:56,270 --> 00:39:01,880
correct lexicographical compare

00:38:58,040 --> 00:39:03,650
three-way Marshall right that was the

00:39:01,880 --> 00:39:05,840
point Marshall with goods make okay so

00:39:03,650 --> 00:39:09,560
perhaps this room in the standard for

00:39:05,840 --> 00:39:12,080
stood equal three-way and you know if I

00:39:09,560 --> 00:39:13,340
wanted so there is I know some some

00:39:12,080 --> 00:39:15,860
thoughts going on some discussion about

00:39:13,340 --> 00:39:20,150
how to apply the spaceship operator to

00:39:15,860 --> 00:39:22,790
containers like string and maybe we need

00:39:20,150 --> 00:39:25,220
to do the equal three way maybe in in

00:39:22,790 --> 00:39:26,660
the future when we do have this in the

00:39:25,220 --> 00:39:28,370
in language in your compiler does

00:39:26,660 --> 00:39:31,310
support it maybe there would still be

00:39:28,370 --> 00:39:35,620
reasons to overload both this and the

00:39:31,310 --> 00:39:35,620
equality operators yeah

00:39:38,839 --> 00:39:44,309
if you were to overload spaceship and

00:39:41,819 --> 00:39:48,569
equal equals would you have to write not

00:39:44,309 --> 00:39:50,069
equals I think I mean bear in mind that

00:39:48,569 --> 00:39:52,410
we're two years away from C plus 20 I

00:39:50,069 --> 00:39:54,930
think the answer is yes if so if you

00:39:52,410 --> 00:39:57,239
overload it equal equal I would expect

00:39:54,930 --> 00:40:03,539
you to overload not equal just in the

00:39:57,239 --> 00:40:05,640
canonical way correct the IDs if you

00:40:03,539 --> 00:40:07,079
write only spaceship the idea is that

00:40:05,640 --> 00:40:10,049
you don't need to write any of the other

00:40:07,079 --> 00:40:12,390
operators they just work but if you want

00:40:10,049 --> 00:40:15,869
to get the performance that this is

00:40:12,390 --> 00:40:18,180
leaving on the table then you would you

00:40:15,869 --> 00:40:27,329
should and could overload selected

00:40:18,180 --> 00:40:27,720
operators at your choice okay so where

00:40:27,329 --> 00:40:30,720
are we

00:40:27,720 --> 00:40:34,259
yes so operator spaceship guidelines

00:40:30,720 --> 00:40:38,579
then obviously it's too early to adopt

00:40:34,259 --> 00:40:41,160
it it's C 4 plus 20 library supports

00:40:38,579 --> 00:40:43,529
still being figured out that it has good

00:40:41,160 --> 00:40:46,289
promise there's no you can play with it

00:40:43,529 --> 00:40:48,299
on God board org but the implementations

00:40:46,289 --> 00:40:50,519
aren't quite there yet for instance at

00:40:48,299 --> 00:40:52,499
the moment you do not get be generated

00:40:50,519 --> 00:40:53,969
all of the generated operations as far

00:40:52,499 --> 00:40:57,930
as I know in any compiled that's at

00:40:53,969 --> 00:41:01,380
least live on God BOTS dog and so there

00:40:57,930 --> 00:41:03,660
are library functions is equal and is

00:41:01,380 --> 00:41:06,299
any and and a few other things in

00:41:03,660 --> 00:41:09,989
compare that come along to help you get

00:41:06,299 --> 00:41:11,609
around that a bit as I said there are

00:41:09,989 --> 00:41:13,410
there are some issues and performance

00:41:11,609 --> 00:41:15,239
with with containers with generic code

00:41:13,410 --> 00:41:18,749
the composition that I think still have

00:41:15,239 --> 00:41:20,999
to work out so we've got some way to go

00:41:18,749 --> 00:41:23,910
yet figuring out this operator it's got

00:41:20,999 --> 00:41:25,049
a few rough edges it's very very new but

00:41:23,910 --> 00:41:29,539
I thought I thought there was a good

00:41:25,049 --> 00:41:31,650
thing to cover okay so much for

00:41:29,539 --> 00:41:33,749
convention and kind of state of the art

00:41:31,650 --> 00:41:36,109
and all of that what about if we choose

00:41:33,749 --> 00:41:38,729
to stray from convention with operators

00:41:36,109 --> 00:41:41,670
what could we gain from from breaking

00:41:38,729 --> 00:41:45,779
the mold so let's have some fun this

00:41:41,670 --> 00:41:47,789
it's one of my favorite quotes Alice in

00:41:45,779 --> 00:41:49,769
Wonderland or an Android look and or

00:41:47,789 --> 00:41:50,270
three looking-glass is the best the best

00:41:49,769 --> 00:41:51,860
book

00:41:50,270 --> 00:41:53,119
computer science for the layman it is

00:41:51,860 --> 00:41:57,860
said but that's because it's the best

00:41:53,119 --> 00:42:00,440
book on anything for the layman what we

00:41:57,860 --> 00:42:06,080
get when we break from convention a lot

00:42:00,440 --> 00:42:09,380
that time is D s l's either either your

00:42:06,080 --> 00:42:12,200
large or small and why we might want D s

00:42:09,380 --> 00:42:13,520
l's the main specific languages EDS ELLs

00:42:12,200 --> 00:42:15,890
in the census was they're embedded in

00:42:13,520 --> 00:42:18,410
C++

00:42:15,890 --> 00:42:20,060
they D s l's of where types and

00:42:18,410 --> 00:42:22,850
operators work together to make code

00:42:20,060 --> 00:42:25,610
easier to understand especially they

00:42:22,850 --> 00:42:28,700
shine where the objects in classes you

00:42:25,610 --> 00:42:30,590
want to construct are difficult to

00:42:28,700 --> 00:42:33,020
understand or even maybe explain the

00:42:30,590 --> 00:42:35,000
sentence but it's prohibitively worthy

00:42:33,020 --> 00:42:36,619
in the language to construct them

00:42:35,000 --> 00:42:41,450
because what we're trying to achieve

00:42:36,619 --> 00:42:43,220
with DSL its readability here's an

00:42:41,450 --> 00:42:51,520
example of a DSL that we have in the

00:42:43,220 --> 00:42:54,260
language the the curly brace operator so

00:42:51,520 --> 00:42:55,609
we have a square bracket operator we

00:42:54,260 --> 00:42:57,859
have the paren operator everyone's

00:42:55,609 --> 00:43:00,619
familiar with those initialize a list is

00:42:57,859 --> 00:43:03,020
really a DSL for initialization using

00:43:00,619 --> 00:43:06,560
the curly the curly bracket operator in

00:43:03,020 --> 00:43:08,720
a sense and this is this is why we want

00:43:06,560 --> 00:43:10,700
the s l's because they give us the

00:43:08,720 --> 00:43:13,490
clarity of code they give us easier to

00:43:10,700 --> 00:43:16,580
read code we allow the users of our

00:43:13,490 --> 00:43:18,770
library to form expressions rather than

00:43:16,580 --> 00:43:23,780
having to sequence all these statements

00:43:18,770 --> 00:43:25,340
to build up their objects so that's a

00:43:23,780 --> 00:43:28,580
sort of an example of a DSL there's

00:43:25,340 --> 00:43:32,000
another more overt example of DSL in the

00:43:28,580 --> 00:43:34,369
standard and that is Colonel there's a

00:43:32,000 --> 00:43:36,980
couple actually one is chrono dates so

00:43:34,369 --> 00:43:39,230
this is an example of where an operator

00:43:36,980 --> 00:43:43,570
interacts with a user-defined literal a

00:43:39,230 --> 00:43:46,130
couple of user-defined literals and you

00:43:43,570 --> 00:43:48,440
know to good effect because what we're

00:43:46,130 --> 00:43:52,190
using here is not mathematical

00:43:48,440 --> 00:43:54,650
convention but but date convention to to

00:43:52,190 --> 00:43:58,250
have a DSL with one operator and a

00:43:54,650 --> 00:44:00,380
couple of used to find literals and as I

00:43:58,250 --> 00:44:03,200
was writing this I realized this is the

00:44:00,380 --> 00:44:03,950
only possible defense of using the u.s.

00:44:03,200 --> 00:44:07,370
system for

00:44:03,950 --> 00:44:12,350
acting dates it's it's one character

00:44:07,370 --> 00:44:18,100
fewer so I'll give you that of course

00:44:12,350 --> 00:44:20,420
the bottom one is the correct way so

00:44:18,100 --> 00:44:22,400
this is this is interesting because when

00:44:20,420 --> 00:44:24,530
we think of DSL we might think of you

00:44:22,400 --> 00:44:26,990
know lots of different operators working

00:44:24,530 --> 00:44:29,590
together this is a one operator DSL but

00:44:26,990 --> 00:44:32,330
but just using one operator even

00:44:29,590 --> 00:44:33,910
improves readability so much if you

00:44:32,330 --> 00:44:37,490
think about what it would take to

00:44:33,910 --> 00:44:41,150
construct today's date without that

00:44:37,490 --> 00:44:44,390
slash operator well what would you do

00:44:41,150 --> 00:44:46,940
you you might end up you probably end up

00:44:44,390 --> 00:44:49,610
using the plus operator which which

00:44:46,940 --> 00:44:52,970
would work but it wouldn't be nearly as

00:44:49,610 --> 00:44:54,230
readable so this isn't although this is

00:44:52,970 --> 00:44:56,000
a mathematically conventional we're not

00:44:54,230 --> 00:45:00,260
dividing these things this is date wise

00:44:56,000 --> 00:45:04,310
conventional here's another example of a

00:45:00,260 --> 00:45:06,710
one operator DSL that people some people

00:45:04,310 --> 00:45:08,380
on reddit don't seem to like but but I'm

00:45:06,710 --> 00:45:10,970
going to speak up in this defense

00:45:08,380 --> 00:45:13,490
it's non-conventional but it works

00:45:10,970 --> 00:45:15,740
brilliantly it's taking what we already

00:45:13,490 --> 00:45:17,510
fundamentally do with strings we can

00:45:15,740 --> 00:45:19,910
catenate them and it's just giving us an

00:45:17,510 --> 00:45:22,220
easier way to do it and I've spent far

00:45:19,910 --> 00:45:23,870
too much of my life checking to see

00:45:22,220 --> 00:45:27,530
where the strings were terminated with a

00:45:23,870 --> 00:45:30,790
trailing directory separator

00:45:27,530 --> 00:45:32,930
I'm sensing somewhere you have two

00:45:30,790 --> 00:45:34,640
operators slash does that just does the

00:45:32,930 --> 00:45:36,050
right thing and it doesn't matter

00:45:34,640 --> 00:45:37,640
whether there's a trailing slash there

00:45:36,050 --> 00:45:40,280
or not it will do the right thing so

00:45:37,640 --> 00:45:44,590
this is an example of a of a one

00:45:40,280 --> 00:45:47,480
operator DSL which works brilliantly so

00:45:44,590 --> 00:45:51,980
here's an example of a multi operator

00:45:47,480 --> 00:45:55,040
DSL now there's a lot going on here just

00:45:51,980 --> 00:45:56,630
take a look at it this is this is

00:45:55,040 --> 00:45:58,160
confusingly this is called boost SML

00:45:56,630 --> 00:46:02,150
it's not it's actually not the boost

00:45:58,160 --> 00:46:05,300
library is I don't think I see Chris in

00:46:02,150 --> 00:46:11,900
the audience so there's a lot going on

00:46:05,300 --> 00:46:13,670
here but oh hi Chris there's a lot going

00:46:11,900 --> 00:46:17,240
on here but even if you've never seen

00:46:13,670 --> 00:46:17,540
this before I hope that you can see so

00:46:17,240 --> 00:46:20,240
this

00:46:17,540 --> 00:46:24,590
is a very concise definition of a state

00:46:20,240 --> 00:46:26,540
machine and this is a essentially a

00:46:24,590 --> 00:46:30,860
declaration of a state machine it's one

00:46:26,540 --> 00:46:35,180
return statement here and what we've got

00:46:30,860 --> 00:46:39,530
is a series of states on the on the left

00:46:35,180 --> 00:46:42,410
the star marks the starting state so

00:46:39,530 --> 00:46:45,800
we're in a state we get an event with

00:46:42,410 --> 00:46:48,890
the plus operator there's possibly a

00:46:45,800 --> 00:46:52,240
condition or a guard as to what what you

00:46:48,890 --> 00:46:55,220
know that what that event has to satisfy

00:46:52,240 --> 00:46:58,340
with the square brackets then then

00:46:55,220 --> 00:47:01,250
there's an action after the slash and

00:46:58,340 --> 00:47:05,270
then finally we may go to a new state

00:47:01,250 --> 00:47:07,460
and X is the terminating state and this

00:47:05,270 --> 00:47:08,930
follows not again not mathematical

00:47:07,460 --> 00:47:14,060
convention but this follows some of the

00:47:08,930 --> 00:47:17,210
happily the UML state spec I guess state

00:47:14,060 --> 00:47:21,020
diagrams in UML use some things which

00:47:17,210 --> 00:47:23,060
are translatable into C++ operators so

00:47:21,020 --> 00:47:25,940
you can look at a piece of code like

00:47:23,060 --> 00:47:27,950
this and you can see the flow of the

00:47:25,940 --> 00:47:30,560
state machine and what the operators

00:47:27,950 --> 00:47:32,890
have given you is that concision that

00:47:30,560 --> 00:47:36,500
ability to view it all in one place and

00:47:32,890 --> 00:47:39,140
and to have a chance of understanding it

00:47:36,500 --> 00:47:41,180
like if this were not using operator

00:47:39,140 --> 00:47:43,820
overloads I think it would be very very

00:47:41,180 --> 00:47:55,820
difficult to see exactly how the state

00:47:43,820 --> 00:47:59,260
machine flow happens titus how critical

00:47:55,820 --> 00:47:59,260
do I feel the user-defined literals are

00:48:02,270 --> 00:48:10,760
I think they fulfill a really good role

00:48:05,119 --> 00:48:14,060
it so if they weren't there they would

00:48:10,760 --> 00:48:16,310
probably need to be types that they

00:48:14,060 --> 00:48:18,410
would need to define as say tag types

00:48:16,310 --> 00:48:20,869
somewhere else and pause and I think I

00:48:18,410 --> 00:48:22,880
could actually do that but the usual way

00:48:20,869 --> 00:48:24,619
to you know to animate this state

00:48:22,880 --> 00:48:26,330
machine to make this work is to use the

00:48:24,619 --> 00:48:28,670
user-defined literals

00:48:26,330 --> 00:48:30,470
yeah the underscore s is so what that

00:48:28,670 --> 00:48:35,930
does is turn the string into a type

00:48:30,470 --> 00:48:38,599
which becomes that state and I think

00:48:35,930 --> 00:48:41,780
that's really nice here so so UDL is

00:48:38,599 --> 00:48:44,599
working in concert with with operators

00:48:41,780 --> 00:48:50,810
works really well both in the bait

00:48:44,599 --> 00:48:53,690
library and in this case so yeah tie

00:48:50,810 --> 00:48:54,440
this shrugging I think it's important I

00:48:53,690 --> 00:49:13,700
think it's a blonde for readability

00:48:54,440 --> 00:49:17,690
Brice yes Titus is concerned about

00:49:13,700 --> 00:49:20,240
clashing UDL so underscore s is a

00:49:17,690 --> 00:49:22,820
somewhat popular choice for a

00:49:20,240 --> 00:49:24,740
user-defined literal perhaps this this

00:49:22,820 --> 00:49:26,480
underscore S comes from the the boost

00:49:24,740 --> 00:49:35,390
SML at the SML database so I've got

00:49:26,480 --> 00:49:37,640
using namespace SML up there okay so

00:49:35,390 --> 00:49:40,040
maybe is there is there a standing

00:49:37,640 --> 00:50:01,580
document somewhere that maybe in future

00:49:40,040 --> 00:50:03,090
will give us guidance on this right good

00:50:01,580 --> 00:50:10,620
observation

00:50:03,090 --> 00:50:13,320
the the NIV yeah you near the available

00:50:10,620 --> 00:50:16,200
space of user-defined literals outside

00:50:13,320 --> 00:50:20,600
of the standard is fairly free-for-all

00:50:16,200 --> 00:50:20,600
that's a good observation to make maybe

00:50:24,500 --> 00:50:31,140
right yes the underscore s here is

00:50:27,960 --> 00:50:37,560
turning the string into a type to make

00:50:31,140 --> 00:50:40,920
it that state okay so monads come up a

00:50:37,560 --> 00:50:42,900
lot lately that we see me thinking about

00:50:40,920 --> 00:50:46,110
magnetic things in terms of stood option

00:50:42,900 --> 00:50:47,850
also expected that future what's the

00:50:46,110 --> 00:50:50,250
biggest problem with monads is it

00:50:47,850 --> 00:50:52,050
understanding what is it understanding

00:50:50,250 --> 00:50:54,330
them is it explaining them is it

00:50:52,050 --> 00:50:57,440
category theory is it the Southerners

00:50:54,330 --> 00:51:01,350
who tried to make everything monadic

00:50:57,440 --> 00:51:03,560
well this is an operator's talk this is

00:51:01,350 --> 00:51:05,610
the biggest problem with monnet the

00:51:03,560 --> 00:51:11,850
Haskell's bind operator has the wrong

00:51:05,610 --> 00:51:14,130
associativity in c++ and the wrong

00:51:11,850 --> 00:51:16,440
precedence in in all probability yes

00:51:14,130 --> 00:51:17,460
this comes back to the twice at the top

00:51:16,440 --> 00:51:22,260
of the talk there aren't that many good

00:51:17,460 --> 00:51:24,750
choices for operators in C++ so this is

00:51:22,260 --> 00:51:26,970
what I would like so let's say I have

00:51:24,750 --> 00:51:29,250
this is futures right this is I'm not

00:51:26,970 --> 00:51:30,840
making any assumptions about how the

00:51:29,250 --> 00:51:32,880
futures are implemented just that we

00:51:30,840 --> 00:51:35,280
would want to compose asynchronous

00:51:32,880 --> 00:51:37,170
operations manically in some way so

00:51:35,280 --> 00:51:39,390
we've got functions that return futures

00:51:37,170 --> 00:51:41,250
and we could chain them together in this

00:51:39,390 --> 00:51:44,190
way so we want to call F the result of

00:51:41,250 --> 00:51:48,870
that split to g1 g2 bring those back

00:51:44,190 --> 00:51:52,650
together to college we might write that

00:51:48,870 --> 00:51:53,820
today in in some hypothetical futures

00:51:52,650 --> 00:51:55,290
library or some code that looks

00:51:53,820 --> 00:51:59,400
something like this and this would be

00:51:55,290 --> 00:52:01,830
considered pretty nice today we've got a

00:51:59,400 --> 00:52:04,860
future that can split and we we call

00:52:01,830 --> 00:52:07,110
then on g1 and g2 and then we call when

00:52:04,860 --> 00:52:08,580
all these are familiar things to anyone

00:52:07,110 --> 00:52:10,080
who's attended the talk on futures or

00:52:08,580 --> 00:52:11,370
read papers or anything like this and

00:52:10,080 --> 00:52:13,560
again this is not really saying anything

00:52:11,370 --> 00:52:15,770
about how the future is implemented hi

00:52:13,560 --> 00:52:15,770
Bruce

00:52:15,800 --> 00:52:23,070
now what I would like to be able to do

00:52:19,110 --> 00:52:25,950
is something like this and you can see I

00:52:23,070 --> 00:52:28,740
think when they use operators to compose

00:52:25,950 --> 00:52:32,340
these we get that intuition this is what

00:52:28,740 --> 00:52:35,420
operators give us we I I can rearrange

00:52:32,340 --> 00:52:37,590
this computation very much more easily

00:52:35,420 --> 00:52:39,540
when I fused operators to put together

00:52:37,590 --> 00:52:42,330
in a single expression so I'm running F

00:52:39,540 --> 00:52:43,800
F and then I'm gonna split g1 the g2

00:52:42,330 --> 00:52:48,210
over and those are parallel and then I'm

00:52:43,800 --> 00:52:49,620
gonna forward that into H now I don't

00:52:48,210 --> 00:52:52,170
have a good sense of what will become

00:52:49,620 --> 00:52:54,450
conventional if anything in monadic

00:52:52,170 --> 00:52:58,800
operations and an operator overloading

00:52:54,450 --> 00:53:03,780
but you know as far as c++ goes this is

00:52:58,800 --> 00:53:05,430
a reasonable way to go maybe we might

00:53:03,780 --> 00:53:08,640
get something like this with with

00:53:05,430 --> 00:53:11,910
continuations I'm told with co-routines

00:53:08,640 --> 00:53:12,270
sorry I'm not sure how it's going to go

00:53:11,910 --> 00:53:16,140
yet

00:53:12,270 --> 00:53:18,450
but the point here is that when we use a

00:53:16,140 --> 00:53:21,600
operator overloading it can clarify the

00:53:18,450 --> 00:53:23,850
computational structure it allows me to

00:53:21,600 --> 00:53:28,680
think about separating my business logic

00:53:23,850 --> 00:53:35,040
from my strategy of parallelism for this

00:53:28,680 --> 00:53:37,260
thing alright let's go quickly now so a

00:53:35,040 --> 00:53:39,150
few mechanics of writing up or operator

00:53:37,260 --> 00:53:43,590
of loads choices and preferences we

00:53:39,150 --> 00:53:46,320
could make one choice is a free function

00:53:43,590 --> 00:53:48,330
or not a free function I would say

00:53:46,320 --> 00:53:50,580
normal rules apply here prefer a free

00:53:48,330 --> 00:53:52,710
function where you can as I said they

00:53:50,580 --> 00:53:54,210
promote encapsulation they help you to

00:53:52,710 --> 00:53:58,460
keep the basis functions of your class

00:53:54,210 --> 00:54:00,540
minimal minimal complete and stable

00:53:58,460 --> 00:54:01,620
building convenience functions in

00:54:00,540 --> 00:54:03,480
particularly with free functions

00:54:01,620 --> 00:54:05,610
promotes encapsulation where you're

00:54:03,480 --> 00:54:08,790
relying on the class interface and not

00:54:05,610 --> 00:54:10,020
the class implementation and free

00:54:08,790 --> 00:54:11,550
functions have this slightly more

00:54:10,020 --> 00:54:13,200
nuanced advantage that they put their

00:54:11,550 --> 00:54:15,840
operands on an equal footing

00:54:13,200 --> 00:54:18,360
an equal footing mentally if you like

00:54:15,840 --> 00:54:19,980
and it to me it's more natural to think

00:54:18,360 --> 00:54:22,640
about it that way especially if the

00:54:19,980 --> 00:54:22,640
operation is commutative

00:54:24,720 --> 00:54:29,460
binary operators generally should be

00:54:27,300 --> 00:54:33,200
implemented in terms of their assignment

00:54:29,460 --> 00:54:35,820
counterparts this is part of providing a

00:54:33,200 --> 00:54:37,080
complete set of operators when you

00:54:35,820 --> 00:54:38,850
overload operators you should always

00:54:37,080 --> 00:54:41,550
think about providing the complete set

00:54:38,850 --> 00:54:43,560
so that you do provide your users with

00:54:41,550 --> 00:54:47,850
that ability to manipulate things and do

00:54:43,560 --> 00:54:49,260
what they would expect a curious thing

00:54:47,850 --> 00:54:52,200
about assignment operates is that the

00:54:49,260 --> 00:54:55,290
the regular assignment operator has to

00:54:52,200 --> 00:54:56,730
be a member function but the the plus

00:54:55,290 --> 00:54:58,920
equals the minus equal all the other

00:54:56,730 --> 00:55:01,160
assignment operators don't have to be a

00:54:58,920 --> 00:55:07,700
member functions and I'm not sure why

00:55:01,160 --> 00:55:10,700
does anyone know why I'm seeing Oh

00:55:07,700 --> 00:55:10,700
Augustine

00:55:16,710 --> 00:55:21,790
right okay so the compiler will generate

00:55:19,750 --> 00:55:23,580
an assignment operator for you that's

00:55:21,790 --> 00:55:25,840
why it needs to be a member function

00:55:23,580 --> 00:55:27,130
okay well I get the rationale for it

00:55:25,840 --> 00:55:30,190
being a member function I'm not sure why

00:55:27,130 --> 00:55:33,190
the plus equals and they they don't have

00:55:30,190 --> 00:55:34,840
me generated but it seems out to me that

00:55:33,190 --> 00:55:36,910
one because they both they have to

00:55:34,840 --> 00:55:39,780
return the L value references they're

00:55:36,910 --> 00:55:45,400
effectively on the same same page but

00:55:39,780 --> 00:55:48,370
anyway so when you're writing operators

00:55:45,400 --> 00:55:49,960
of course they are functions so

00:55:48,370 --> 00:55:51,970
everything that applies to normal

00:55:49,960 --> 00:55:55,510
functions are plies to writing operators

00:55:51,970 --> 00:55:58,770
don't forget all the qualifiers we get a

00:55:55,510 --> 00:56:00,970
new qualifier every standard with C++

00:55:58,770 --> 00:56:03,100
think about your parameter types think

00:56:00,970 --> 00:56:04,870
about your return types hopefully this

00:56:03,100 --> 00:56:07,330
is all obvious this entire slide is like

00:56:04,870 --> 00:56:10,690
one talk in its own right so I'm not

00:56:07,330 --> 00:56:13,180
gonna dwell too much on it so let's

00:56:10,690 --> 00:56:15,190
recap on some operator guidelines when

00:56:13,180 --> 00:56:17,710
to use operator overloading in my

00:56:15,190 --> 00:56:21,270
opinion so when you have a natural

00:56:17,710 --> 00:56:23,890
binary function that combines your types

00:56:21,270 --> 00:56:26,980
it's a good choice to think of an

00:56:23,890 --> 00:56:29,110
operator to do that when your types of

00:56:26,980 --> 00:56:31,570
Bay any kind of mathematical principles

00:56:29,110 --> 00:56:34,210
that that your users will into it

00:56:31,570 --> 00:56:35,530
particularly associativity and when you

00:56:34,210 --> 00:56:39,880
want to give them the opportunity to

00:56:35,530 --> 00:56:42,370
manipulate expressions when you want to

00:56:39,880 --> 00:56:44,050
make complex construction of objects

00:56:42,370 --> 00:56:47,380
easier and this is where you can combine

00:56:44,050 --> 00:56:51,580
it with UD else and when you want users

00:56:47,380 --> 00:56:53,200
to Intuit properties of your types so

00:56:51,580 --> 00:56:56,260
that's when you should use operator

00:56:53,200 --> 00:56:58,720
overloading now when when shouldn't you

00:56:56,260 --> 00:57:02,680
use them well one important thing I've

00:56:58,720 --> 00:57:04,180
sort of no quite touched on this I said

00:57:02,680 --> 00:57:07,750
when you have a natural binary operation

00:57:04,180 --> 00:57:09,640
if you have an if that operation could

00:57:07,750 --> 00:57:12,100
be extended to an NRI function and you

00:57:09,640 --> 00:57:15,400
can provide better performance by

00:57:12,100 --> 00:57:16,990
writing an NRI function and not forcing

00:57:15,400 --> 00:57:19,330
your users to combine things with the

00:57:16,990 --> 00:57:22,120
binary function that's an important use

00:57:19,330 --> 00:57:24,220
case to consider and you shouldn't be

00:57:22,120 --> 00:57:26,920
constraining your users to only using

00:57:24,220 --> 00:57:28,520
operators and the other reason when you

00:57:26,920 --> 00:57:30,619
shouldn't use operators is just

00:57:28,520 --> 00:57:31,790
when they aren't you know ready for

00:57:30,619 --> 00:57:33,500
primetime yet so we shouldn't we

00:57:31,790 --> 00:57:39,859
shouldn't do dogmatic operator

00:57:33,500 --> 00:57:43,000
overloading okay some don'ts don't do

00:57:39,859 --> 00:57:45,770
that really really really don't do that

00:57:43,000 --> 00:57:47,990
try not to break associativity again

00:57:45,770 --> 00:57:50,470
most things are associative things that

00:57:47,990 --> 00:57:53,990
aren't associative rapidly become very

00:57:50,470 --> 00:57:56,390
unusable really don't be afraid to just

00:57:53,990 --> 00:57:59,089
overload one operator if it makes sense

00:57:56,390 --> 00:58:00,200
we saw some great examples of single

00:57:59,089 --> 00:58:03,820
operator DSL

00:58:00,200 --> 00:58:05,660
it can really help with readability

00:58:03,820 --> 00:58:08,630
probably still stay away from

00:58:05,660 --> 00:58:10,010
overloading these operators even with

00:58:08,630 --> 00:58:13,310
Pio one four five

00:58:10,010 --> 00:58:17,630
even though comm Reiter is now safe to

00:58:13,310 --> 00:58:20,450
overload probably better and don't don't

00:58:17,630 --> 00:58:22,310
pick don't pick weird operators if

00:58:20,450 --> 00:58:25,310
you're typing is mathematical just just

00:58:22,310 --> 00:58:27,500
try to stick with convention

00:58:25,310 --> 00:58:31,730
there's no good convention for the comma

00:58:27,500 --> 00:58:34,570
operator that I know of sir do use

00:58:31,730 --> 00:58:38,300
conventions other than mathematical ones

00:58:34,570 --> 00:58:39,770
do consider this idea of an affine space

00:58:38,300 --> 00:58:41,720
if you look at your types you can see

00:58:39,770 --> 00:58:44,000
they're separating them and that will

00:58:41,720 --> 00:58:46,490
help you explore the design space for

00:58:44,000 --> 00:58:50,599
operators it's worth trying to separate

00:58:46,490 --> 00:58:52,310
your type to see where it leads do use

00:58:50,599 --> 00:58:54,980
operators especially you have if you

00:58:52,310 --> 00:58:57,290
have non commutative functions and that

00:58:54,980 --> 00:58:59,200
will allow people to leverage fold

00:58:57,290 --> 00:59:03,770
expressions to put together their

00:58:59,200 --> 00:59:06,500
objects and do use user-defined literals

00:59:03,770 --> 00:59:11,150
as a counterpart to operators to help

00:59:06,500 --> 00:59:13,849
with construction and if you provide one

00:59:11,150 --> 00:59:16,599
Operator think about providing all of

00:59:13,849 --> 00:59:22,010
the operators that that go with it and

00:59:16,599 --> 00:59:24,430
with that I'm about on time so thank you

00:59:22,010 --> 00:59:24,430
very much

00:59:29,690 --> 00:59:36,060
hello vice you didn't talk about the

00:59:32,400 --> 00:59:38,010
call operator or the index I didn't so

00:59:36,060 --> 00:59:39,540
it was the first operator the court

00:59:38,010 --> 00:59:40,680
that's right I didn't talk about the

00:59:39,540 --> 00:59:43,560
call operator or the end listening

00:59:40,680 --> 00:59:46,109
operator well yeah what are you I'm

00:59:43,560 --> 00:59:53,820
sorry was that a question that was a

00:59:46,109 --> 00:59:56,430
comment that's guys the question one of

00:59:53,820 --> 01:00:03,329
my thoughts on when you should overload

00:59:56,430 --> 01:00:05,160
them far too complicated to answer in

01:00:03,329 --> 01:00:07,890
three seconds which is when I have left

01:00:05,160 --> 01:00:09,420
but yeah I'm happy to talk about

01:00:07,890 --> 01:00:20,190
operators to anyone that catches me

01:00:09,420 --> 01:00:22,859
afterwards it's a complex subject my

01:00:20,190 --> 01:00:26,310
bill so my opinion on adding new

01:00:22,859 --> 01:00:28,140
operators C++ has this strange dichotomy

01:00:26,310 --> 01:00:29,970
between functions and operators which I

01:00:28,140 --> 01:00:33,240
don't quite understand and I would like

01:00:29,970 --> 01:00:35,240
to be able to unify them I'd like I

01:00:33,240 --> 01:00:38,280
don't know how realistic that is really

01:00:35,240 --> 01:00:41,630
and when I set the table took all those

01:00:38,280 --> 01:00:45,089
things we can't change our in theory

01:00:41,630 --> 01:00:48,480
right for a meta operators paper from

01:00:45,089 --> 01:00:53,210
herb right to give us those rules in the

01:00:48,480 --> 01:00:53,210
language that's pie in the sky of course

01:00:58,970 --> 01:01:24,930
okay yes yes that's a good comment thank

01:01:24,420 --> 01:01:27,210
you guys

01:01:24,930 --> 01:01:37,650
I assume that was recorded sensors on

01:01:27,210 --> 01:01:39,450
the mic functions is when you start

01:01:37,650 --> 01:01:42,030
doing mixed type comparisons you

01:01:39,450 --> 01:01:45,089
suddenly have twice as many or four

01:01:42,030 --> 01:01:48,119
times yes operators as free functions

01:01:45,089 --> 01:01:50,180
can lead to combinatorial things that's

01:01:48,119 --> 01:01:52,250
that's true

01:01:50,180 --> 01:01:57,530
thank you very much

01:01:52,250 --> 01:01:57,530

YouTube URL: https://www.youtube.com/watch?v=zh4EgO13Etg


