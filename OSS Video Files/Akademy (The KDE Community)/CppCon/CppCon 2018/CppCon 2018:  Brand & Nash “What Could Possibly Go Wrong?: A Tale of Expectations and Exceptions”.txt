Title: CppCon 2018:  Brand & Nash “What Could Possibly Go Wrong?: A Tale of Expectations and Exceptions”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
--
Simon Brand & Phil Nash “What Could Possibly Go Wrong?: A Tale of Expectations and Exceptions”
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
In software things can go wrong. Sometimes we might expect them to go wrong. Sometimes it’s a surprise. In most cases we want to build in some way of handling these disappointments.

In some cases we can use exceptions. But there are many cases where the overhead of exceptions is more than we want or can afford - and some are so constrained that exceptions are not even possible. Alternatives now include std::optional, or the proposed std::expected - but these come with a lot of code overhead

What we really want is a way to concisely produce and handle disappointments in our code in a performant manner. This talk will evaluate a few approaches to solving this, including monads, syntactic sugar for error handling, and we'll even look at an intriguing possibility that promises to unify these worlds.
— 
Simon Brand, Microsoft
C++ Developer Advocate

Simon is a C++ Developer Advocate at Microsoft. He turns into a metaprogramming fiend every full moon, when he can be found bringing compilers to their knees with template errors and debating undefined behaviour online. He co-organises the Edinburgh C++ user group and contributes to various programming standards bodies.

Outside of programming, he enjoys experimental films, homebrewing, and board games.

Phil Nash, JetBrains
Developer Advocate

Phil is the author of the test frameworks, Catch - for C++ and Objective-C, and Swordfish for Swift. As Developer Advocate at JetBrains he's involved with CLion, AppCode and ReSharper C++. More generally he's an advocate for good testing practices, TDD and using the type system and functional techniques to reduce complexity and increase correctness. He's previously worked in Finance and Mobile as well as an independent consultant and coach specialising in TDD on iOS.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,720 --> 00:00:04,620
thank you all for coming I'm Phil Nash

00:00:03,060 --> 00:00:07,080
developer advocate JetBrains

00:00:04,620 --> 00:00:09,929
and I'm Simon brand developer advocate

00:00:07,080 --> 00:00:12,450
Microsoft and today we're going to talk

00:00:09,929 --> 00:00:15,859
to you about error handling in C++ the

00:00:12,450 --> 00:00:17,760
cars what could possibly go wrong

00:00:15,859 --> 00:00:19,560
actually there is one thing just to

00:00:17,760 --> 00:00:22,080
address the elephant in the room first

00:00:19,560 --> 00:00:24,539
of all who here went to Andre

00:00:22,080 --> 00:00:27,269
Alexander who's talked yesterday quite a

00:00:24,539 --> 00:00:29,640
few ports so because definitely similar

00:00:27,269 --> 00:00:31,679
subject matter and we are going to cover

00:00:29,640 --> 00:00:32,790
some of the same ground so don't get put

00:00:31,679 --> 00:00:34,680
off because we're going an office in

00:00:32,790 --> 00:00:37,020
different directions and you could say

00:00:34,680 --> 00:00:39,000
we're gonna go quite a bit beyond what

00:00:37,020 --> 00:00:39,739
sir what andre talked about so what's

00:00:39,000 --> 00:00:43,590
the got a slightly different

00:00:39,739 --> 00:00:48,629
presentation styles so expectations

00:00:43,590 --> 00:00:50,879
exactly okay so what is an error very

00:00:48,629 --> 00:00:53,550
philosophical question for us all if my

00:00:50,879 --> 00:00:56,609
clicker decides to work

00:00:53,550 --> 00:00:58,800
why is my clicker not working Phil this

00:00:56,609 --> 00:01:00,059
is why we should have used my laptop no

00:00:58,800 --> 00:01:02,940
if we've done that it would have all

00:01:00,059 --> 00:01:04,920
been okay this is why we call the talk

00:01:02,940 --> 00:01:08,040
what could possibly go wrong everything

00:01:04,920 --> 00:01:12,750
can go wrong in a technical talk now my

00:01:08,040 --> 00:01:16,950
clicker is working what is an error so

00:01:12,750 --> 00:01:18,870
an error could be number of things it

00:01:16,950 --> 00:01:23,610
could be something like this something

00:01:18,870 --> 00:01:27,630
went wrong what is something well maybe

00:01:23,610 --> 00:01:30,710
something like this beam creation not

00:01:27,630 --> 00:01:34,890
allowed exception something to do with

00:01:30,710 --> 00:01:36,510
destroying factories maybe some of us

00:01:34,890 --> 00:01:39,270
kind of get an idea of what this might

00:01:36,510 --> 00:01:42,260
be but if you're not the target audience

00:01:39,270 --> 00:01:45,480
for this error maybe you're just a

00:01:42,260 --> 00:01:48,680
non-technical user of this tool then

00:01:45,480 --> 00:01:52,390
maybe you reaction something like this

00:01:48,680 --> 00:01:54,670
no I try and use your tool and currently

00:01:52,390 --> 00:01:58,690
saying I'm destroying bean factories

00:01:54,670 --> 00:02:01,180
what's this about so if we don't craft

00:01:58,690 --> 00:02:03,730
our errors and our messages correctly we

00:02:01,180 --> 00:02:06,850
get misunderstandings we want our error

00:02:03,730 --> 00:02:10,270
messages to be correct for the audience

00:02:06,850 --> 00:02:12,910
they're designed for there's also

00:02:10,270 --> 00:02:16,570
problems some bugs would be really hard

00:02:12,910 --> 00:02:18,850
to see some errors can be hard to see

00:02:16,570 --> 00:02:21,190
sometimes we just throw away our errors

00:02:18,850 --> 00:02:24,430
without ever looking at them and this

00:02:21,190 --> 00:02:28,300
causes problems some more issues with

00:02:24,430 --> 00:02:30,670
errors sometimes we're disappointed you

00:02:28,300 --> 00:02:33,160
know it's not an error nothing like when

00:02:30,670 --> 00:02:35,440
cause catastrophic ly wrong but

00:02:33,160 --> 00:02:37,330
something like we maybe planned for but

00:02:35,440 --> 00:02:39,130
we're just a bit disappointed when it

00:02:37,330 --> 00:02:40,840
goes wrong you know I couldn't find this

00:02:39,130 --> 00:02:46,240
file it's not the end of the world but

00:02:40,840 --> 00:02:49,930
yeah I'm just a bit disappointed so the

00:02:46,240 --> 00:02:51,940
happy path something goes right you know

00:02:49,930 --> 00:02:55,150
fantastic you know we've got this lovely

00:02:51,940 --> 00:02:59,500
sunshine it's in stroll down it's all

00:02:55,150 --> 00:03:02,170
great Welbeck something goes wrong yeah

00:02:59,500 --> 00:03:03,130
what's the opposite at the happy path so

00:03:02,170 --> 00:03:05,680
I would I would have thought the

00:03:03,130 --> 00:03:09,610
opposite of happy is sad so maybe the

00:03:05,680 --> 00:03:13,030
sad path what do you think I know it's a

00:03:09,610 --> 00:03:14,769
bit morbid and they may be a bit more

00:03:13,030 --> 00:03:18,519
descriptive would just be call it the

00:03:14,769 --> 00:03:20,500
error path okay all right like that but

00:03:18,519 --> 00:03:22,440
we're talking about errors it's the

00:03:20,500 --> 00:03:24,430
subject of the talk and of course

00:03:22,440 --> 00:03:25,989
there's all sorts of different types of

00:03:24,430 --> 00:03:29,680
errors we could be dealing with I'm sure

00:03:25,989 --> 00:03:31,099
you've seen plenty of these I want to

00:03:29,680 --> 00:03:36,230
start

00:03:31,099 --> 00:03:37,879
by looking at few different types here's

00:03:36,230 --> 00:03:40,969
one the TV you've probably seen plenty

00:03:37,879 --> 00:03:42,439
of times although you shouldn't I know

00:03:40,969 --> 00:03:44,420
I've written this so many many times

00:03:42,439 --> 00:03:46,609
from my users have seen it they

00:03:44,420 --> 00:03:48,739
shouldn't do because sometime gonna

00:03:46,609 --> 00:03:51,290
think shouldn't happen if everything is

00:03:48,739 --> 00:03:53,000
going correctly but they do anyway we

00:03:51,290 --> 00:03:56,299
need to have a strategy for dealing with

00:03:53,000 --> 00:03:58,459
that that's the first of fact before we

00:03:56,299 --> 00:04:00,139
go home to that the beautiful moment of

00:03:58,459 --> 00:04:01,609
irony when others have originally

00:04:00,139 --> 00:04:03,950
preparing these slides exactly this

00:04:01,609 --> 00:04:08,000
point keynote crashed on me and gave me

00:04:03,950 --> 00:04:10,549
to stack them fortunately start it up

00:04:08,000 --> 00:04:11,810
again and got my slides back but so yeah

00:04:10,549 --> 00:04:13,730
these things happen we all we have to

00:04:11,810 --> 00:04:16,130
deal with them but as to other

00:04:13,730 --> 00:04:18,410
categories of errors as well as well as

00:04:16,130 --> 00:04:20,329
the this should never happen type we've

00:04:18,410 --> 00:04:22,550
got things that shouldn't usually happen

00:04:20,329 --> 00:04:24,919
but you know they cuz I can genuinely

00:04:22,550 --> 00:04:27,470
occur and we do need to allow for them

00:04:24,919 --> 00:04:29,720
and in the final category is the things

00:04:27,470 --> 00:04:31,099
that that might happen but if they do

00:04:29,720 --> 00:04:34,460
they're gonna be a bit disappointing as

00:04:31,099 --> 00:04:36,470
Simon Says prefer if they didn't but we

00:04:34,460 --> 00:04:38,720
definitely have to allow for them let's

00:04:36,470 --> 00:04:39,919
put some examples to this and this

00:04:38,720 --> 00:04:42,199
should never happen character grieve

00:04:39,919 --> 00:04:45,650
about the null dereference out of range

00:04:42,199 --> 00:04:48,440
access use after free you know the type

00:04:45,650 --> 00:04:50,860
that they're definitely things that

00:04:48,440 --> 00:04:53,300
should never happen in well-written code

00:04:50,860 --> 00:04:55,759
what's interesting is they should never

00:04:53,300 --> 00:04:59,300
happen category as there's one great

00:04:55,759 --> 00:05:03,500
example for this one that's out of feed

00:04:59,300 --> 00:05:05,690
memory new or manic return to failure

00:05:03,500 --> 00:05:09,039
you know very rarely happens in practice

00:05:05,690 --> 00:05:11,659
but it's a genuine thing that can happen

00:05:09,039 --> 00:05:13,340
then the final category some examples

00:05:11,659 --> 00:05:16,159
there and if you can read that down

00:05:13,340 --> 00:05:18,520
there far not found can't convert from a

00:05:16,159 --> 00:05:20,539
string couldn't look up a key in a map

00:05:18,520 --> 00:05:23,210
lots of examples I'm sure you can think

00:05:20,539 --> 00:05:24,650
of of things that but they could

00:05:23,210 --> 00:05:26,150
definitely file and would be

00:05:24,650 --> 00:05:27,620
disappointed they did but you know we

00:05:26,150 --> 00:05:30,560
can carry on we can we can work around

00:05:27,620 --> 00:05:33,320
that and in fact that's what leads us on

00:05:30,560 --> 00:05:35,300
to another way of looking at these group

00:05:33,320 --> 00:05:38,449
them into some different buckets so

00:05:35,300 --> 00:05:40,699
we've got logic errors they should never

00:05:38,449 --> 00:05:42,380
happen category their logic errors

00:05:40,699 --> 00:05:44,130
because the errors are coming from the

00:05:42,380 --> 00:05:46,320
code itself new in the code

00:05:44,130 --> 00:05:49,320
the bugs the only thing we could say

00:05:46,320 --> 00:05:51,240
about them as well as errors that come

00:05:49,320 --> 00:05:52,590
from within the code but therefore get

00:05:51,240 --> 00:05:54,840
errors that come from outside the code

00:05:52,590 --> 00:05:58,440
that must be caused by IO or

00:05:54,840 --> 00:06:00,420
side-effects really that must be the

00:05:58,440 --> 00:06:02,370
only two ways that we can we can look at

00:06:00,420 --> 00:06:05,340
errors from within the code or from

00:06:02,370 --> 00:06:07,980
outside the code the how does the repeat

00:06:05,340 --> 00:06:10,530
memory fit into that you know I'm glad

00:06:07,980 --> 00:06:11,670
you asked that because it it doesn't

00:06:10,530 --> 00:06:14,610
really fit into the I for those

00:06:11,670 --> 00:06:16,410
categories it's not a bug as such but

00:06:14,610 --> 00:06:18,720
it's not really caused by IO in the

00:06:16,410 --> 00:06:19,650
sense that we normally think of it and I

00:06:18,720 --> 00:06:23,760
think there's a really good case for

00:06:19,650 --> 00:06:24,840
treating out of heap memory errors as a

00:06:23,760 --> 00:06:27,090
special case

00:06:24,840 --> 00:06:28,650
something that we don't really deal with

00:06:27,090 --> 00:06:31,580
with their normal error hearing handling

00:06:28,650 --> 00:06:34,140
strategies but I think it's often the

00:06:31,580 --> 00:06:35,940
the whole problem when we're dealing

00:06:34,140 --> 00:06:37,980
with errors is we're trying to work

00:06:35,940 --> 00:06:41,250
around dealing with out of memory when

00:06:37,980 --> 00:06:43,500
we practice it very rarely happens so if

00:06:41,250 --> 00:06:45,210
we took that out of the picture it's for

00:06:43,500 --> 00:06:47,910
the moment we're just left with logic

00:06:45,210 --> 00:06:50,820
errors and i/o errors and another way we

00:06:47,910 --> 00:06:53,370
can think about those is that logic

00:06:50,820 --> 00:06:55,590
errors are not recoverable because your

00:06:53,370 --> 00:06:57,810
program is in a corrupt state it's

00:06:55,590 --> 00:07:00,330
something you didn't anticipate all bets

00:06:57,810 --> 00:07:03,150
are off so if you carry on at this point

00:07:00,330 --> 00:07:06,720
then you know just as likely to to crop

00:07:03,150 --> 00:07:07,890
the filesystem or do anything that's the

00:07:06,720 --> 00:07:10,110
point you don't know what state you're

00:07:07,890 --> 00:07:11,460
in anymore anything you can really do is

00:07:10,110 --> 00:07:13,280
to stop at that point and give as much

00:07:11,460 --> 00:07:17,100
information as you can

00:07:13,280 --> 00:07:17,940
by contrast recoverable errors are

00:07:17,100 --> 00:07:19,980
recoverable

00:07:17,940 --> 00:07:22,590
do you anticipate them you know they can

00:07:19,980 --> 00:07:24,090
happen you gravity didn't but you can

00:07:22,590 --> 00:07:26,820
work you can work with that you can

00:07:24,090 --> 00:07:28,260
carry on so don't really the two

00:07:26,820 --> 00:07:31,170
categories that we're we're going to

00:07:28,260 --> 00:07:34,050
look at so what actually should we use

00:07:31,170 --> 00:07:36,840
to deal with non recoverable errors and

00:07:34,050 --> 00:07:39,390
have a great question so there's a

00:07:36,840 --> 00:07:41,340
proposal in flight for a support for

00:07:39,390 --> 00:07:43,050
contract based programming your so plus

00:07:41,340 --> 00:07:45,540
bus and ice exactly what this is all

00:07:43,050 --> 00:07:52,860
about so I encourage you to go and read

00:07:45,540 --> 00:07:54,450
this p0 3/8 R 1 at the moment it's a

00:07:52,860 --> 00:07:57,479
great paper it's I think it's already

00:07:54,450 --> 00:07:58,389
been accepted into superfast 20 just in

00:07:57,479 --> 00:08:01,030
details twine

00:07:58,389 --> 00:08:03,400
now if you don't have access to say fast

00:08:01,030 --> 00:08:06,189
fast 20 yet we can achieve most of the

00:08:03,400 --> 00:08:07,810
same things just by using assert that's

00:08:06,189 --> 00:08:09,960
really all it is or you can build your

00:08:07,810 --> 00:08:12,189
own system that does something similar

00:08:09,960 --> 00:08:14,139
really the important thing is that we

00:08:12,189 --> 00:08:16,150
just want to stop execution of the

00:08:14,139 --> 00:08:18,069
program when we when we hit one of these

00:08:16,150 --> 00:08:19,990
errors and give as much information as

00:08:18,069 --> 00:08:21,340
you can about what happened well then I

00:08:19,990 --> 00:08:25,120
send a debug build or even in production

00:08:21,340 --> 00:08:26,680
because as we said at that point there's

00:08:25,120 --> 00:08:28,240
no point in continuing not even no point

00:08:26,680 --> 00:08:31,449
but it'd be detrimental to continue

00:08:28,240 --> 00:08:33,399
because we can cause more damage that's

00:08:31,449 --> 00:08:35,320
all we're gonna say about contracts I

00:08:33,399 --> 00:08:36,459
think at this point yes so if that's how

00:08:35,320 --> 00:08:38,680
we should deal with non recoverable

00:08:36,459 --> 00:08:40,120
errors I've heard there's a lot of

00:08:38,680 --> 00:08:42,190
different ways that we can handle

00:08:40,120 --> 00:08:44,980
recoverable errors so right how should

00:08:42,190 --> 00:08:46,480
we do that exactly so we're gonna talk

00:08:44,980 --> 00:08:48,160
about recoverable errors and this is

00:08:46,480 --> 00:08:50,470
really going to be the main subject of

00:08:48,160 --> 00:08:51,700
the rest of this talk because there are

00:08:50,470 --> 00:08:53,800
plenty of ways that we can deal with

00:08:51,700 --> 00:08:56,440
recoverable errors and we're gonna go

00:08:53,800 --> 00:08:58,300
through all of them one by one more or

00:08:56,440 --> 00:09:00,399
less now sure that there's a direction

00:08:58,300 --> 00:09:03,850
I'm going with this so what I want to do

00:09:00,399 --> 00:09:05,649
is give you some code examples and we're

00:09:03,850 --> 00:09:07,540
gonna have a look at how they suck up

00:09:05,649 --> 00:09:11,500
okay so can you come up with those

00:09:07,540 --> 00:09:13,199
examples I'll give you some scores okay

00:09:11,500 --> 00:09:14,440
tell you if your solutions are good

00:09:13,199 --> 00:09:16,300
great

00:09:14,440 --> 00:09:18,100
not so great and we'll go from there

00:09:16,300 --> 00:09:18,670
okay that sounds fair why not make it

00:09:18,100 --> 00:09:21,730
more interesting

00:09:18,670 --> 00:09:23,350
all right so how you gonna do that okay

00:09:21,730 --> 00:09:25,980
so come up with a bunch of criteria to

00:09:23,350 --> 00:09:28,839
score different error handling

00:09:25,980 --> 00:09:31,480
methodologies so the first thing which

00:09:28,839 --> 00:09:35,380
as C++ developers we hopefully all care

00:09:31,480 --> 00:09:38,380
about is overhead performing less we

00:09:35,380 --> 00:09:41,399
don't want our error handling to cost us

00:09:38,380 --> 00:09:43,630
more than it needs to that sound okay

00:09:41,399 --> 00:09:45,730
yeah we're definitely interested in the

00:09:43,630 --> 00:09:48,010
performance but what we're talking about

00:09:45,730 --> 00:09:51,579
the be overhead on the happy path for

00:09:48,010 --> 00:09:55,570
the error path to us we probably want

00:09:51,579 --> 00:09:58,060
both because it might be that the happy

00:09:55,570 --> 00:09:59,769
path is cheap and the error path is

00:09:58,060 --> 00:10:01,540
expensive or the other way around

00:09:59,769 --> 00:10:03,040
maybe they're the same so yeah you're

00:10:01,540 --> 00:10:05,170
right we should probably split things up

00:10:03,040 --> 00:10:09,160
so we'll have overhead in the happy path

00:10:05,170 --> 00:10:11,430
overhead on the error path okay that's

00:10:09,160 --> 00:10:14,430
good safety

00:10:11,430 --> 00:10:17,670
so although I may not like to admit it

00:10:14,430 --> 00:10:21,180
sometimes I make mistakes in my code and

00:10:17,670 --> 00:10:24,210
if my error handling systems can help me

00:10:21,180 --> 00:10:26,760
not make those mistakes then that's

00:10:24,210 --> 00:10:28,800
great so I want safety I want it to be

00:10:26,760 --> 00:10:33,150
hard to make a mistake

00:10:28,800 --> 00:10:35,310
always be safe yes noise I like clean

00:10:33,150 --> 00:10:37,830
code I want to be concise

00:10:35,310 --> 00:10:40,470
not so much syntactic overhead that we

00:10:37,830 --> 00:10:42,300
don't really need so if you have a high

00:10:40,470 --> 00:10:45,360
noise score does that mean it's gonna be

00:10:42,300 --> 00:10:46,830
very noisy no if I score you high on

00:10:45,360 --> 00:10:48,690
noise that means your code is good nice

00:10:46,830 --> 00:10:52,470
and clean okay okay so Clara climb up

00:10:48,690 --> 00:10:53,760
yeah separate paths I mean by that is if

00:10:52,470 --> 00:10:55,470
you look at the code you can see okay

00:10:53,760 --> 00:10:58,080
right here's the code dealing with the

00:10:55,470 --> 00:11:00,780
happy path and here's the code dealing

00:10:58,080 --> 00:11:02,910
with the error path they're not all like

00:11:00,780 --> 00:11:08,990
mixed in with each other and hard to

00:11:02,910 --> 00:11:11,100
tell apart okay next is reasonability

00:11:08,990 --> 00:11:13,740
kind of similar in some ways to separate

00:11:11,100 --> 00:11:15,990
paths but more generally just can I look

00:11:13,740 --> 00:11:19,440
at this code and understand what it's

00:11:15,990 --> 00:11:20,940
doing is the error handling just so

00:11:19,440 --> 00:11:23,370
mixed in with the business logic that I

00:11:20,940 --> 00:11:25,290
have no idea what's going on I want to

00:11:23,370 --> 00:11:25,890
be able to reason about my code sounds

00:11:25,290 --> 00:11:32,160
reasonable

00:11:25,890 --> 00:11:34,530
oh dear composability composing

00:11:32,160 --> 00:11:37,110
functions is some people say the essence

00:11:34,530 --> 00:11:39,240
of all programming I think bartosh he

00:11:37,110 --> 00:11:41,820
says that so we want to be able to

00:11:39,240 --> 00:11:43,950
compose our functions with just normal

00:11:41,820 --> 00:11:47,070
functions we can often compose them call

00:11:43,950 --> 00:11:49,260
F call G call H so I want people to do

00:11:47,070 --> 00:11:51,510
that even when I'm handling all my

00:11:49,260 --> 00:11:53,520
errors so you've got the compose ability

00:11:51,510 --> 00:11:54,750
of the functions themselves although

00:11:53,520 --> 00:11:56,940
that the compose ability of the error

00:11:54,750 --> 00:11:59,100
handling yeah we want to think about

00:11:56,940 --> 00:12:01,350
that as well because maybe our error is

00:11:59,100 --> 00:12:03,540
like a string and we want to like build

00:12:01,350 --> 00:12:06,030
up a big log of what happened maybe we

00:12:03,540 --> 00:12:08,880
want to do like handle some errors now

00:12:06,030 --> 00:12:11,910
handle some later or catch and we throw

00:12:08,880 --> 00:12:14,310
something so yeah composability of error

00:12:11,910 --> 00:12:18,030
handling as well of the kind of business

00:12:14,310 --> 00:12:19,650
logic functionality okay finally I care

00:12:18,030 --> 00:12:22,850
about the message just like we saw

00:12:19,650 --> 00:12:25,910
earlier with the bean factor

00:12:22,850 --> 00:12:28,639
destruction we want our messages to give

00:12:25,910 --> 00:12:32,050
us enough information to deal with our

00:12:28,639 --> 00:12:34,310
error but also messages which are

00:12:32,050 --> 00:12:37,399
designed for the people who are going to

00:12:34,310 --> 00:12:38,990
be getting them so this is my last bit

00:12:37,399 --> 00:12:40,670
of criteria does that one sound okay

00:12:38,990 --> 00:12:43,880
yeah it's gonna be a tough call but

00:12:40,670 --> 00:12:45,740
let's see how it goes alright so we'll

00:12:43,880 --> 00:12:47,720
start with error codes

00:12:45,740 --> 00:12:51,410
everyone understands error codes just

00:12:47,720 --> 00:12:52,459
about every language can can do this and

00:12:51,410 --> 00:12:55,040
there's a few different ways we can do

00:12:52,459 --> 00:12:57,949
them so let's have a look a simple

00:12:55,040 --> 00:12:59,540
example so here we got a function that

00:12:57,949 --> 00:13:01,250
will create a directory in the file

00:12:59,540 --> 00:13:04,250
system so this takes the name of

00:13:01,250 --> 00:13:07,399
directory returns a boolean doesn't

00:13:04,250 --> 00:13:08,449
really say what boolean is for but most

00:13:07,399 --> 00:13:09,860
people when they look at that they're

00:13:08,449 --> 00:13:11,899
going to infer that the boolean just

00:13:09,860 --> 00:13:13,130
tells us whether it succeeded on up just

00:13:11,899 --> 00:13:15,470
by convention that's what we're used to

00:13:13,130 --> 00:13:19,190
so I think it's fairly clear that that's

00:13:15,470 --> 00:13:21,649
that's our error channel and to use that

00:13:19,190 --> 00:13:23,899
code no surprises here we're just going

00:13:21,649 --> 00:13:26,360
to call it and do some sort of if

00:13:23,899 --> 00:13:28,850
statement to handle the error so happy

00:13:26,360 --> 00:13:30,050
path one if and the else is the airport

00:13:28,850 --> 00:13:35,389
what could be simpler than that

00:13:30,050 --> 00:13:37,699
how does that stack up it's okay I like

00:13:35,389 --> 00:13:40,250
that this is marked like you look at the

00:13:37,699 --> 00:13:41,660
Declaration of this function and as long

00:13:40,250 --> 00:13:43,339
as you work out what that bool is doing

00:13:41,660 --> 00:13:45,500
and you kind of know that there's some

00:13:43,339 --> 00:13:47,000
kind of error handling going on here so

00:13:45,500 --> 00:13:52,040
this is something I like about this

00:13:47,000 --> 00:13:54,069
approach you're my scores okay so the

00:13:52,040 --> 00:13:56,899
overhead is nice like we're we're just

00:13:54,069 --> 00:13:59,509
returning boobs we're doing some

00:13:56,899 --> 00:14:01,550
branching maybe if we could chew in the

00:13:59,509 --> 00:14:03,230
branch prediction maybe that would help

00:14:01,550 --> 00:14:05,029
use some compiler intrinsic store

00:14:03,230 --> 00:14:07,639
something like that yep

00:14:05,029 --> 00:14:09,709
but in general it's pretty good it's

00:14:07,639 --> 00:14:11,180
also easy to reason about we're used to

00:14:09,709 --> 00:14:13,579
dealing with rules and if statements

00:14:11,180 --> 00:14:16,550
else clauses we know how this all works

00:14:13,579 --> 00:14:19,310
so we can read the code and understand

00:14:16,550 --> 00:14:23,180
what it's doing quite easily I do have

00:14:19,310 --> 00:14:26,990
some pretty strong objections about this

00:14:23,180 --> 00:14:29,089
though Paul you might yeah so one thing

00:14:26,990 --> 00:14:33,019
is a separate paths you look at this

00:14:29,089 --> 00:14:35,269
code and phil is very nicely put in some

00:14:33,019 --> 00:14:36,080
some comments for us so oh this is the

00:14:35,269 --> 00:14:38,300
happy path and the

00:14:36,080 --> 00:14:40,580
the error path if we don't have these

00:14:38,300 --> 00:14:42,590
comments then we just see oh there's an

00:14:40,580 --> 00:14:43,670
if clause and else clause is this like

00:14:42,590 --> 00:14:46,570
are we checking something in our

00:14:43,670 --> 00:14:48,530
business logic are we handling an error

00:14:46,570 --> 00:14:51,020
we don't know unless we actually

00:14:48,530 --> 00:14:52,820
understand what's going on so separate

00:14:51,020 --> 00:14:55,310
pather are not great

00:14:52,820 --> 00:14:58,730
there's also composability issue here I

00:14:55,310 --> 00:15:00,230
mean because we're returning a pool like

00:14:58,730 --> 00:15:01,970
if we want to actually return something

00:15:00,230 --> 00:15:04,220
from this function we'd have to use an

00:15:01,970 --> 00:15:07,210
out parameter or or something else so we

00:15:04,220 --> 00:15:09,740
can't just kind of pass objects down

00:15:07,210 --> 00:15:13,220
through a chain of calls so we can't

00:15:09,740 --> 00:15:17,570
really compose these functions that's

00:15:13,220 --> 00:15:20,360
unfair yeah one thing I really do not

00:15:17,570 --> 00:15:22,340
like is the message you know if you get

00:15:20,360 --> 00:15:26,630
this you get a rule you say okay I

00:15:22,340 --> 00:15:31,180
succeeded yes got why I wanted I failed

00:15:26,630 --> 00:15:33,320
okay why I don't know could be anything

00:15:31,180 --> 00:15:36,170
the last thing I wouldn't pick up on his

00:15:33,320 --> 00:15:38,360
safety so it's very easy for me to just

00:15:36,170 --> 00:15:40,190
you know they've returned a bool I

00:15:38,360 --> 00:15:41,990
forget about it I just call the function

00:15:40,190 --> 00:15:44,540
and I forget to sign the bool I forget

00:15:41,990 --> 00:15:46,750
to check it so easy to do look you think

00:15:44,540 --> 00:15:50,960
of a way to solve at least that problem

00:15:46,750 --> 00:15:54,140
well pretty tough cool I've got a few

00:15:50,960 --> 00:15:56,150
tricks up my sleeve so yeah the safety I

00:15:54,140 --> 00:15:58,370
think we can increase if we just use the

00:15:56,150 --> 00:15:59,450
no discard attribute we stick that on

00:15:58,370 --> 00:16:01,730
there then that's going to force us to

00:15:59,450 --> 00:16:03,110
at least look at the return value and in

00:16:01,730 --> 00:16:05,030
doing so we're probably going to handle

00:16:03,110 --> 00:16:06,950
it then so I think that should increase

00:16:05,030 --> 00:16:08,570
the safety should not yeah you're right

00:16:06,950 --> 00:16:12,500
those better I mean it's quite simple

00:16:08,570 --> 00:16:13,910
change as well makes it clearer a lot

00:16:12,500 --> 00:16:16,070
safer to use because now we can't forget

00:16:13,910 --> 00:16:18,200
about the return so you're right that

00:16:16,070 --> 00:16:19,010
does improve safety but not really

00:16:18,200 --> 00:16:21,860
anything else

00:16:19,010 --> 00:16:23,150
so you have any other ideas yeah okay

00:16:21,860 --> 00:16:25,190
well let's let's pick off the message

00:16:23,150 --> 00:16:27,260
then it's gonna be easy easy enough to

00:16:25,190 --> 00:16:29,630
improve that instead of returning a ball

00:16:27,260 --> 00:16:31,100
how about we return an integer and that

00:16:29,630 --> 00:16:33,650
way we can communicate different types

00:16:31,100 --> 00:16:36,640
of error codes that any better well I

00:16:33,650 --> 00:16:36,640
see some people like it

00:16:39,629 --> 00:16:44,620
we're said integer here but this could

00:16:41,829 --> 00:16:46,449
be any sort of into integral type like

00:16:44,620 --> 00:16:48,870
an enum it could be quite descriptive as

00:16:46,449 --> 00:16:52,120
well yeah I mean I'm not soaking myself

00:16:48,870 --> 00:16:55,000
here my score is so you're right the

00:16:52,120 --> 00:16:57,730
message has improved we can get more

00:16:55,000 --> 00:16:59,170
information about why we failed now that

00:16:57,730 --> 00:17:00,610
I look at my scorecard again I kind of

00:16:59,170 --> 00:17:04,750
want to mark you down on reasonability

00:17:00,610 --> 00:17:06,250
because it's looking at this in it's not

00:17:04,750 --> 00:17:08,319
clear that this is for error handling

00:17:06,250 --> 00:17:10,870
unless we look at the documentation or

00:17:08,319 --> 00:17:13,620
something so I think I may have been a

00:17:10,870 --> 00:17:16,059
little bit are nice to you on that eight

00:17:13,620 --> 00:17:19,780
well okay but there's one other thing we

00:17:16,059 --> 00:17:22,120
can do here now that we've got an extra

00:17:19,780 --> 00:17:23,500
means to communicate what happened we

00:17:22,120 --> 00:17:25,659
can respond to that differently so in

00:17:23,500 --> 00:17:27,939
the case of Crete directory if the

00:17:25,659 --> 00:17:30,130
directory already exists then it

00:17:27,939 --> 00:17:31,960
couldn't create it but that's still the

00:17:30,130 --> 00:17:34,059
happy path so we can cope with that now

00:17:31,960 --> 00:17:36,039
we can just stick another jack in there

00:17:34,059 --> 00:17:37,929
and we can direct everything to the

00:17:36,039 --> 00:17:53,470
happy path so that's another advantage

00:17:37,929 --> 00:17:55,299
to this one yeah yeah so there there are

00:17:53,470 --> 00:17:58,480
some issues with this mikhail was

00:17:55,299 --> 00:18:01,450
pointed out as pointed out one and it's

00:17:58,480 --> 00:18:03,070
also many it's getting more noisy again

00:18:01,450 --> 00:18:04,539
we're still just dealing with in so I

00:18:03,070 --> 00:18:11,340
think we have to look elsewhere fair I'm

00:18:04,539 --> 00:18:11,340
sorry alright okay well how about if we

00:18:11,550 --> 00:18:16,120
pastor bath result with an out well that

00:18:14,560 --> 00:18:21,690
that frees up the return channel now to

00:18:16,120 --> 00:18:21,690
to address your composability knees yeah

00:18:23,000 --> 00:18:29,570
come on okay sorry I just don't like our

00:18:27,320 --> 00:18:31,520
parameters so I mean okay I'll give you

00:18:29,570 --> 00:18:33,140
right you can look at this it still has

00:18:31,520 --> 00:18:34,520
that thing where it's marked so there's

00:18:33,140 --> 00:18:37,970
something in the declaration schools

00:18:34,520 --> 00:18:41,960
yeah I'm gonna put your safety time

00:18:37,970 --> 00:18:44,840
because we lost that notice card that's

00:18:41,960 --> 00:18:47,510
important it's also harder to reason

00:18:44,840 --> 00:18:49,159
about it now I'm you know our parameters

00:18:47,510 --> 00:18:51,409
are sometimes weird we don't know

00:18:49,159 --> 00:18:53,090
necessarily what this is doing with

00:18:51,409 --> 00:18:55,840
result unless we look at the

00:18:53,090 --> 00:18:58,580
documentation or make a wild guess

00:18:55,840 --> 00:19:01,250
composability fine okay we have the

00:18:58,580 --> 00:19:03,169
return type now that we can can actually

00:19:01,250 --> 00:19:05,059
return something for them so I'll mark

00:19:03,169 --> 00:19:09,230
you up on that date that you really have

00:19:05,059 --> 00:19:12,380
to do better okay well if you wanna make

00:19:09,230 --> 00:19:14,230
it safer how about we return the ball no

00:19:12,380 --> 00:19:17,120
don't do that

00:19:14,230 --> 00:19:18,610
and we have an out parameter now we only

00:19:17,120 --> 00:19:20,690
have to check whether an error occurs

00:19:18,610 --> 00:19:26,179
and if we want to know more we can check

00:19:20,690 --> 00:19:28,610
the out parameter no Shirley okay i'll

00:19:26,179 --> 00:19:30,679
be i'll be i'll be fair i'll be trying

00:19:28,610 --> 00:19:32,090
to be objective okay fine you get your

00:19:30,679 --> 00:19:34,460
safety up again you have the bill no

00:19:32,090 --> 00:19:36,770
discard very well done thank you

00:19:34,460 --> 00:19:38,950
reasonability sure we have the bill we

00:19:36,770 --> 00:19:41,450
can see what it's doing a bit more

00:19:38,950 --> 00:19:47,809
composability you lost your return

00:19:41,450 --> 00:19:50,480
channel again okay well if you want

00:19:47,809 --> 00:19:54,179
composability how about we just get rid

00:19:50,480 --> 00:19:56,099
of the error returns all together

00:19:54,179 --> 00:19:59,369
and we're sticking in the global

00:19:56,099 --> 00:20:06,869
variable you want composability you got

00:19:59,369 --> 00:20:09,959
it okay okay okay ernõ right overhead

00:20:06,869 --> 00:20:12,719
Darren using oh sorry there we go right

00:20:09,959 --> 00:20:14,339
it's unmarked marking you down for that

00:20:12,719 --> 00:20:16,829
like we can't look at this declaration

00:20:14,339 --> 00:20:18,809
and say we're returning an error using

00:20:16,829 --> 00:20:22,049
air no gonna be using like thread-local

00:20:18,809 --> 00:20:25,679
storage or something so overhead safety

00:20:22,049 --> 00:20:28,249
way down can check forget to check our

00:20:25,679 --> 00:20:32,159
know sooo easily this is now looking

00:20:28,249 --> 00:20:35,729
noisy it's hard to reason about and okay

00:20:32,159 --> 00:20:37,289
fine we got our return back still so I

00:20:35,729 --> 00:20:39,329
feel like we're just going back and

00:20:37,289 --> 00:20:41,279
forth and we're not really getting

00:20:39,329 --> 00:20:43,559
anywhere no pleasing some people is

00:20:41,279 --> 00:20:46,709
there oh if you want that safety back we

00:20:43,559 --> 00:20:49,189
can put the ball back on and then still

00:20:46,709 --> 00:20:50,999
set oh no

00:20:49,189 --> 00:20:55,429
see this plenty of times

00:20:50,999 --> 00:20:58,129
yep yep yep and I'm not even gonna know

00:20:55,429 --> 00:21:01,919
look let's not do that please

00:20:58,129 --> 00:21:03,809
well you know we live with all of these

00:21:01,919 --> 00:21:06,419
things for a long time and then in the

00:21:03,809 --> 00:21:07,969
90s we came up with something better so

00:21:06,419 --> 00:21:09,929
was all of these problems than that

00:21:07,969 --> 00:21:11,999
we've got exceptions everyone loves

00:21:09,929 --> 00:21:13,949
exceptions but they've got to be they're

00:21:11,999 --> 00:21:16,679
gonna be better let's have a look at the

00:21:13,949 --> 00:21:19,079
same example using exceptions so so

00:21:16,679 --> 00:21:20,369
example crate der but don't need

00:21:19,079 --> 00:21:24,329
anything in the signature to indicate

00:21:20,369 --> 00:21:25,979
exceptions from but in the usage code we

00:21:24,329 --> 00:21:27,809
can clearly see we've got a try-catch

00:21:25,979 --> 00:21:30,479
there we can see what's going on that's

00:21:27,809 --> 00:21:31,739
got to be better how does that score yes

00:21:30,479 --> 00:21:34,049
it's got to be

00:21:31,739 --> 00:21:37,199
well okay right you got there though

00:21:34,049 --> 00:21:39,719
this is unmarked right I mean we can't

00:21:37,199 --> 00:21:40,979
see by looking at this unless we look at

00:21:39,719 --> 00:21:42,569
the documentation I assume you would

00:21:40,979 --> 00:21:45,350
have this documented in real code right

00:21:42,569 --> 00:21:47,899
of course

00:21:45,350 --> 00:21:50,149
and you could technically use dynamics

00:21:47,899 --> 00:21:53,389
exception specifiers who likes it

00:21:50,149 --> 00:21:59,120
dynamic exception specifiers zero hands

00:21:53,389 --> 00:22:00,559
one hand that person flying if you're

00:21:59,120 --> 00:22:03,950
not lying I'm sorry I don't really mean

00:22:00,559 --> 00:22:05,149
it but if the general consensus is a

00:22:03,950 --> 00:22:08,120
dynamic expression

00:22:05,149 --> 00:22:10,549
exception specifiers are not great we

00:22:08,120 --> 00:22:12,320
have to do more overhead for very little

00:22:10,549 --> 00:22:17,419
benefit friends don't let friends use

00:22:12,320 --> 00:22:19,460
fros yes okay so the overhead on the

00:22:17,419 --> 00:22:24,769
happy path and in assuming we're using

00:22:19,460 --> 00:22:29,110
table based exceptions who doesn't many

00:22:24,769 --> 00:22:31,549
people but okay so these are tuned

00:22:29,110 --> 00:22:33,590
specifically for the happy path so if we

00:22:31,549 --> 00:22:36,139
don't for an exception this is gonna be

00:22:33,590 --> 00:22:40,309
fast so I'll give you good points that

00:22:36,139 --> 00:22:41,779
only for exceptional cases yes so this

00:22:40,309 --> 00:22:45,200
yeah you're right this is an important

00:22:41,779 --> 00:22:49,370
consideration because I've give you no

00:22:45,200 --> 00:22:50,870
one on overhead for the error path so if

00:22:49,370 --> 00:22:53,480
you throw an exception this is going to

00:22:50,870 --> 00:22:55,460
be super expensive comparatively because

00:22:53,480 --> 00:22:58,039
the compiler has to I put a whole load

00:22:55,460 --> 00:23:01,519
of code to let you throw things of any

00:22:58,039 --> 00:23:04,190
type for it up as far as you can as far

00:23:01,519 --> 00:23:06,620
as you can unwind the stack this cost

00:23:04,190 --> 00:23:09,379
something so yeah we do not want to be

00:23:06,620 --> 00:23:13,090
doing this when we're essentially doing

00:23:09,379 --> 00:23:13,090
control flow we don't want to do that

00:23:13,240 --> 00:23:18,740
safety and I'll technically put it up

00:23:16,850 --> 00:23:23,990
but one thing I really do not like about

00:23:18,740 --> 00:23:26,210
exceptions in C++ either it's very hard

00:23:23,990 --> 00:23:28,340
to write exception safe code we have to

00:23:26,210 --> 00:23:30,320
be very aware of what can throw and what

00:23:28,340 --> 00:23:31,909
is not going to throw and this can make

00:23:30,320 --> 00:23:33,980
things difficult so I'm gonna go through

00:23:31,909 --> 00:23:37,399
I'm gonna give you six on safety for now

00:23:33,980 --> 00:23:39,590
at least the noise okay it's it's okay

00:23:37,399 --> 00:23:42,259
yeah but you actually do like the

00:23:39,590 --> 00:23:44,120
separate pass here so yeah compared to

00:23:42,259 --> 00:23:46,100
what we had earlier we had if-then-else

00:23:44,120 --> 00:23:49,009
statements and it's hard to see what's

00:23:46,100 --> 00:23:51,950
good what's bad in this case you know

00:23:49,009 --> 00:23:54,889
try block and catch block have very

00:23:51,950 --> 00:23:56,269
well-defined semantics so we look at

00:23:54,889 --> 00:23:58,820
this code and we say okay well the try

00:23:56,269 --> 00:24:01,340
block is for when everything went okay

00:23:58,820 --> 00:24:03,769
and this is when we had an exception

00:24:01,340 --> 00:24:05,840
firm right so that's very good that's

00:24:03,769 --> 00:24:09,019
very good we also I mean we can serve

00:24:05,840 --> 00:24:11,480
things of any type we can put strings in

00:24:09,019 --> 00:24:15,110
them so we can have essentially any

00:24:11,480 --> 00:24:16,789
message we want which is nice and then

00:24:15,110 --> 00:24:19,070
we can compose these functions because

00:24:16,789 --> 00:24:21,200
we're not we can have our return type

00:24:19,070 --> 00:24:22,850
back we can also compose the error

00:24:21,200 --> 00:24:25,009
handling because you know we can we

00:24:22,850 --> 00:24:27,909
throw things we can have like a pattern

00:24:25,009 --> 00:24:31,669
matching on our on our exception types

00:24:27,909 --> 00:24:33,440
so that's that's okay it is a bit hard

00:24:31,669 --> 00:24:37,129
to reason about for the same thing they

00:24:33,440 --> 00:24:40,730
said about safety so yeah any ideas to

00:24:37,129 --> 00:24:43,220
make it better well you mentioned the

00:24:40,730 --> 00:24:45,200
overhead on the error path but that only

00:24:43,220 --> 00:24:47,000
really comes into play if you're using

00:24:45,200 --> 00:24:50,389
exceptions for control flow doesn't it

00:24:47,000 --> 00:24:52,009
no one would do that would they although

00:24:50,389 --> 00:24:54,019
how we're going to handle the all exists

00:24:52,009 --> 00:24:55,850
already exists case we just use

00:24:54,019 --> 00:24:57,529
exceptions for this then we are

00:24:55,850 --> 00:24:59,059
literally using exceptions for control

00:24:57,529 --> 00:25:00,769
flow we don't want to do that obviously

00:24:59,059 --> 00:25:02,870
in this case we could do it a different

00:25:00,769 --> 00:25:04,220
way we could mix it with return values

00:25:02,870 --> 00:25:05,929
or we could just take a different

00:25:04,220 --> 00:25:07,759
approach altogether but it's it's

00:25:05,929 --> 00:25:10,460
definitely a consideration so that's

00:25:07,759 --> 00:25:14,049
another problem with this approach so

00:25:10,460 --> 00:25:18,289
what the we mentioned the the overhead

00:25:14,049 --> 00:25:20,299
on the mirror path and I understand

00:25:18,289 --> 00:25:21,730
everything they're saying but be nice to

00:25:20,299 --> 00:25:24,289
actually put some numbers to it

00:25:21,730 --> 00:25:26,809
unfortunately they're quite difficult to

00:25:24,289 --> 00:25:28,429
to come by quite a few people have done

00:25:26,809 --> 00:25:28,909
different metrics which tell a different

00:25:28,429 --> 00:25:30,559
story

00:25:28,909 --> 00:25:32,389
no one's really come up with something

00:25:30,559 --> 00:25:34,009
across the board yet so I'm just going

00:25:32,389 --> 00:25:35,870
to pull out one that I stole from no

00:25:34,009 --> 00:25:38,659
Douglas from his talk last year at

00:25:35,870 --> 00:25:40,490
meeting C++ where he came up with this

00:25:38,659 --> 00:25:42,500
this chart just from his own benchmarks

00:25:40,490 --> 00:25:44,799
so don't read too much into it but I

00:25:42,500 --> 00:25:46,879
think it's it at least tells a story

00:25:44,799 --> 00:25:50,419
what's interesting here is that the

00:25:46,879 --> 00:25:52,669
yellow bars are the the performance of

00:25:50,419 --> 00:25:54,919
throwing an exception up ten stack

00:25:52,669 --> 00:25:58,070
frames and the other bars are different

00:25:54,919 --> 00:26:00,110
types of return code type type error

00:25:58,070 --> 00:26:03,110
handling again not the same ten ten

00:26:00,110 --> 00:26:06,769
stack frames but the y-axis is

00:26:03,110 --> 00:26:09,260
exponential so that overhead is several

00:26:06,769 --> 00:26:12,260
orders of magnitude over their return

00:26:09,260 --> 00:26:12,710
value passing approach so no matter how

00:26:12,260 --> 00:26:14,899
you look at

00:26:12,710 --> 00:26:16,520
that is pretty significant and other

00:26:14,899 --> 00:26:18,799
people's benchmarks and to bear this out

00:26:16,520 --> 00:26:20,899
just in different ways so it's

00:26:18,799 --> 00:26:23,990
definitely a real problem so much so

00:26:20,899 --> 00:26:28,520
that in this year's su class bust

00:26:23,990 --> 00:26:30,590
Foundation survey 52 percent C++

00:26:28,520 --> 00:26:32,600
programmers surveyed said that at least

00:26:30,590 --> 00:26:35,090
in part of their code bases sometimes in

00:26:32,600 --> 00:26:36,950
all of them exceptions are banned you've

00:26:35,090 --> 00:26:39,620
got any experience with that Simon yeah

00:26:36,950 --> 00:26:42,529
so I previously worked in compilers with

00:26:39,620 --> 00:26:44,480
LLVM for about five years and no

00:26:42,529 --> 00:26:46,159
exceptions anywhere so I mean even if I

00:26:44,480 --> 00:26:48,289
thought all this stuff was a a good idea

00:26:46,159 --> 00:26:50,090
then I wouldn't be able to use it yeah

00:26:48,289 --> 00:26:52,429
the implications of that are actually

00:26:50,090 --> 00:26:54,320
pretty big means that more than a half

00:26:52,429 --> 00:26:56,539
of developers are not really able to use

00:26:54,320 --> 00:26:58,309
full standard C++ because they're not

00:26:56,539 --> 00:27:00,529
able to use exceptions which is the

00:26:58,309 --> 00:27:05,090
primary mechanism for error handling in

00:27:00,529 --> 00:27:06,830
C++ so it's quite a serious situation so

00:27:05,090 --> 00:27:07,970
what's the next step what can we do

00:27:06,830 --> 00:27:10,279
instead there's got to be a better way

00:27:07,970 --> 00:27:12,559
isn't there yeah did you mind if I have

00:27:10,279 --> 00:27:14,059
a shot yeah can I take the podium

00:27:12,559 --> 00:27:18,860
actually take the fall okay what could

00:27:14,059 --> 00:27:20,230
go wrong exactly okay so see we have a

00:27:18,860 --> 00:27:23,419
new example okay

00:27:20,230 --> 00:27:25,909
say we have this this - int function and

00:27:23,419 --> 00:27:27,679
this is gonna take a string and we're

00:27:25,909 --> 00:27:30,980
gonna try and parse an inter in this

00:27:27,679 --> 00:27:35,270
string hopefully it contains like 42

00:27:30,980 --> 00:27:36,440
rather than cheese that's it okay good

00:27:35,270 --> 00:27:38,450
example because this is something you

00:27:36,440 --> 00:27:39,350
might want to do speculatively you don't

00:27:38,450 --> 00:27:41,809
really want to pay the cost of

00:27:39,350 --> 00:27:44,120
exceptions if he fails yeah exactly we

00:27:41,809 --> 00:27:45,440
might want to read ahead or try and do

00:27:44,120 --> 00:27:46,880
something with this string and then

00:27:45,440 --> 00:27:49,279
realize oh it's not an end it's actually

00:27:46,880 --> 00:27:51,649
cheese so do something else

00:27:49,279 --> 00:27:55,429
so if throwing here is essentially using

00:27:51,649 --> 00:27:57,770
exceptions for control-flow bad see what

00:27:55,429 --> 00:27:59,450
I love people who may be sick of me

00:27:57,770 --> 00:28:02,450
talking about this but I love optional

00:27:59,450 --> 00:28:05,029
it's great so if you're not familiar

00:28:02,450 --> 00:28:07,840
with optional it's essentially an

00:28:05,029 --> 00:28:14,090
optional int says I'm either an int or

00:28:07,840 --> 00:28:16,070
I'm nothing empty so in this case if we

00:28:14,090 --> 00:28:17,570
get our end we just return it and this

00:28:16,070 --> 00:28:20,990
is going to be the value of our optional

00:28:17,570 --> 00:28:23,240
and if we cannot find an INT it's an

00:28:20,990 --> 00:28:25,100
empty string or it's cheese then we

00:28:23,240 --> 00:28:26,090
return an empty optional this is still

00:28:25,100 --> 00:28:30,920
now up

00:28:26,090 --> 00:28:32,690
okay okay how's that look I like the

00:28:30,920 --> 00:28:35,710
direction this is going in it's got some

00:28:32,690 --> 00:28:37,970
promise what about the other usage

00:28:35,710 --> 00:28:40,430
you're right I didn't cover this but the

00:28:37,970 --> 00:28:42,830
the usage looks kind of like this we

00:28:40,430 --> 00:28:45,710
could call this function get an option

00:28:42,830 --> 00:28:47,690
without and then we can check whether we

00:28:45,710 --> 00:28:51,530
got value and do something with it if we

00:28:47,690 --> 00:28:51,980
didn't we print out not an in or log to

00:28:51,530 --> 00:28:55,420
a file

00:28:51,980 --> 00:28:58,340
something like that it seemed reasonable

00:28:55,420 --> 00:29:00,500
yeah well let's take you through step by

00:28:58,340 --> 00:29:03,410
step then so the overheads pretty good

00:29:00,500 --> 00:29:06,050
what's Asus slight overhead over return

00:29:03,410 --> 00:29:07,630
codes but the same sort of ballpark it's

00:29:06,050 --> 00:29:10,730
doing the same sort of thing

00:29:07,630 --> 00:29:13,160
safety is pretty good because no it's

00:29:10,730 --> 00:29:15,920
much clearer that the return type is

00:29:13,160 --> 00:29:17,900
expressing either that the value or the

00:29:15,920 --> 00:29:20,300
absence of a value it's literally built

00:29:17,900 --> 00:29:22,040
into the type so safety is pretty good

00:29:20,300 --> 00:29:23,630
although it's not perfect because you

00:29:22,040 --> 00:29:24,830
could still dereference your the

00:29:23,630 --> 00:29:27,110
optional without checking and they enter

00:29:24,830 --> 00:29:29,240
into undefined behavior so still shoot

00:29:27,110 --> 00:29:31,760
yourself in the foot but it's still

00:29:29,240 --> 00:29:34,790
quite noisy as well as well as the

00:29:31,760 --> 00:29:36,740
sector of wrapper type you've got the

00:29:34,790 --> 00:29:38,840
the control flow to handle the the error

00:29:36,740 --> 00:29:40,670
condition at the call sites he's still

00:29:38,840 --> 00:29:41,780
mixing in standard control flow with

00:29:40,670 --> 00:29:43,750
we're very handling

00:29:41,780 --> 00:29:46,400
unfortunately plus all the dereferencing

00:29:43,750 --> 00:29:47,720
so you pay a bit there and you don't

00:29:46,400 --> 00:29:50,330
really have a separate parser error

00:29:47,720 --> 00:29:52,670
handling but it's much easier to reason

00:29:50,330 --> 00:29:55,190
about again because we use an expressive

00:29:52,670 --> 00:29:56,960
type so represent what is we're doing

00:29:55,190 --> 00:29:59,060
and we're not blocking the return

00:29:56,960 --> 00:30:01,130
channel so we've got reasonable

00:29:59,060 --> 00:30:02,270
composability although we do have to do

00:30:01,130 --> 00:30:05,120
a bit of extra work so it's not a

00:30:02,270 --> 00:30:06,620
perfect score but really optional in

00:30:05,120 --> 00:30:08,930
this case is like a glorified boolean

00:30:06,620 --> 00:30:11,210
very saying whether the thing was there

00:30:08,930 --> 00:30:14,320
or not but not why so is there anything

00:30:11,210 --> 00:30:17,000
you do to improve that yeah you're right

00:30:14,320 --> 00:30:19,700
as may be optional just not quite the

00:30:17,000 --> 00:30:22,250
right type for this so if we really want

00:30:19,700 --> 00:30:24,200
to have a reason why something didn't

00:30:22,250 --> 00:30:28,310
return anything maybe we need something

00:30:24,200 --> 00:30:31,520
like variant so we could return a

00:30:28,310 --> 00:30:34,580
variant event instead string and then

00:30:31,520 --> 00:30:36,380
our in is what we return if we actually

00:30:34,580 --> 00:30:38,990
find something and are stood string is

00:30:36,380 --> 00:30:39,530
like a error report if we didn't find

00:30:38,990 --> 00:30:43,310
anything

00:30:39,530 --> 00:30:47,450
as well I like the use of a if

00:30:43,310 --> 00:30:49,460
initializer this is this is better in

00:30:47,450 --> 00:30:52,840
some ways yeah I'll give you that you

00:30:49,460 --> 00:30:56,420
can now tell me why the error occurred

00:30:52,840 --> 00:30:58,580
but you know I'm really gonna have to

00:30:56,420 --> 00:31:01,100
mark it down on safety and noise because

00:30:58,580 --> 00:31:05,840
I really really don't like this this

00:31:01,100 --> 00:31:08,200
usage code yeah really - yeah see what's

00:31:05,840 --> 00:31:10,730
going on there it's just much too noisy

00:31:08,200 --> 00:31:12,740
it doesn't even say anything about error

00:31:10,730 --> 00:31:14,540
handling let alone the happy path that's

00:31:12,740 --> 00:31:17,660
an e now you've still got a wrapper type

00:31:14,540 --> 00:31:19,730
in there and it's it's no longer obvious

00:31:17,660 --> 00:31:22,370
even that the best what the semantics

00:31:19,730 --> 00:31:24,440
are no that the string is representing

00:31:22,370 --> 00:31:27,920
an error it doesn't doesn't say anything

00:31:24,440 --> 00:31:29,960
about error there so like you can't put

00:31:27,920 --> 00:31:31,820
any message you like so so there is that

00:31:29,960 --> 00:31:33,310
it's going in the right direction but I

00:31:31,820 --> 00:31:36,410
think we've got a bit more work to do

00:31:33,310 --> 00:31:39,110
okay and maybe even variant isn't the

00:31:36,410 --> 00:31:41,750
right type maybe we want something which

00:31:39,110 --> 00:31:44,870
more clearly expresses we have two types

00:31:41,750 --> 00:31:46,400
one of them is hold on before you get

00:31:44,870 --> 00:31:48,440
there I think we can do a little bit

00:31:46,400 --> 00:31:50,210
better with the usage code maybe you're

00:31:48,440 --> 00:31:52,190
right actually should we use we could

00:31:50,210 --> 00:31:54,770
use I mean we could use a visit but that

00:31:52,190 --> 00:31:57,680
would look really weird and do that yeah

00:31:54,770 --> 00:32:01,610
so we could use get if I guess that does

00:31:57,680 --> 00:32:03,620
clean up a bit yeah yeah slightly better

00:32:01,610 --> 00:32:04,790
noise score but that's about it so I

00:32:03,620 --> 00:32:07,340
think you're right we do need to look

00:32:04,790 --> 00:32:09,050
elsewhere so you carry on okay yes we

00:32:07,340 --> 00:32:12,050
want something which clearly expresses

00:32:09,050 --> 00:32:14,720
we have the expected type and the

00:32:12,050 --> 00:32:16,640
unexpected type so anyone who is in

00:32:14,720 --> 00:32:19,670
Andres talk now knows exactly what I'm

00:32:16,640 --> 00:32:22,210
going to say it's dead expected no

00:32:19,670 --> 00:32:27,140
wasn't expecting that

00:32:22,210 --> 00:32:30,410
thanks though okay so this is very

00:32:27,140 --> 00:32:33,110
similar but expected is kind of designed

00:32:30,410 --> 00:32:36,110
so the returning the expected type is

00:32:33,110 --> 00:32:38,150
very easy we just return the int and

00:32:36,110 --> 00:32:40,100
returning the unexpected type you need

00:32:38,150 --> 00:32:42,350
to really you need to try you need to

00:32:40,100 --> 00:32:44,630
make it obvious so that's how we would

00:32:42,350 --> 00:32:48,110
write our to int function and then our

00:32:44,630 --> 00:32:51,410
usage code down here is way better so

00:32:48,110 --> 00:32:52,220
are we are we done well it's amazing how

00:32:51,410 --> 00:32:55,520
much difference

00:32:52,220 --> 00:32:57,650
using a slightly better align type makes

00:32:55,520 --> 00:32:59,330
this it's doing basically the same thing

00:32:57,650 --> 00:33:02,299
but now I can I can read about this much

00:32:59,330 --> 00:33:04,460
much better so yeah I'd put the safety

00:33:02,299 --> 00:33:07,549
up it's much safer to use for that

00:33:04,460 --> 00:33:08,419
reason it's a bit less noisy I mean yeah

00:33:07,549 --> 00:33:11,470
we've still got some of the same

00:33:08,419 --> 00:33:14,000
problems it doesn't solve the the

00:33:11,470 --> 00:33:15,730
separate paths issues still mixing the

00:33:14,000 --> 00:33:18,409
happy path from the amira path together

00:33:15,730 --> 00:33:21,260
but it's a big step in the right

00:33:18,409 --> 00:33:24,679
direction I can live with this I think

00:33:21,260 --> 00:33:26,120
you got any more well maybe we need to

00:33:24,679 --> 00:33:28,090
think more about the composability in

00:33:26,120 --> 00:33:29,960
separate paths these are things you've

00:33:28,090 --> 00:33:32,210
crating strongly marked me down that

00:33:29,960 --> 00:33:35,990
said that's harsh that well you did it

00:33:32,210 --> 00:33:40,130
to me sorry ok maybe we can look for

00:33:35,990 --> 00:33:43,010
influence elsewhere so let's say instead

00:33:40,130 --> 00:33:43,640
of having just one function we have two

00:33:43,010 --> 00:33:45,650
functions

00:33:43,640 --> 00:33:50,440
I want to go hard on this composability

00:33:45,650 --> 00:33:54,530
now so we have our two int function and

00:33:50,440 --> 00:33:56,240
we have our divide function this torrent

00:33:54,530 --> 00:33:58,760
is the same as before essentially divide

00:33:56,240 --> 00:34:00,620
is new and it's like a safe integer

00:33:58,760 --> 00:34:02,720
division function so it checks that the

00:34:00,620 --> 00:34:06,470
denominator is zero so we don't end off

00:34:02,720 --> 00:34:08,510
an undefined behavior land so we don't

00:34:06,470 --> 00:34:12,560
like being on phase on behind behavior

00:34:08,510 --> 00:34:12,980
land so relatively simple yeah looks

00:34:12,560 --> 00:34:16,520
good to me

00:34:12,980 --> 00:34:19,490
yeah okay so we can look at what our

00:34:16,520 --> 00:34:22,490
codes would be if we just used it

00:34:19,490 --> 00:34:25,339
expected and if and else statements this

00:34:22,490 --> 00:34:26,510
is starting to look all right I'll take

00:34:25,339 --> 00:34:26,690
that back when I said I could live with

00:34:26,510 --> 00:34:32,000
that

00:34:26,690 --> 00:34:34,089
yeah not sure I could so we could look

00:34:32,000 --> 00:34:38,290
to functional programming languages

00:34:34,089 --> 00:34:41,300
which often have this concept of a map

00:34:38,290 --> 00:34:45,710
so what map does is you gave it your

00:34:41,300 --> 00:34:47,359
expected you give it a function and it

00:34:45,710 --> 00:34:51,349
will call that function on the contain

00:34:47,359 --> 00:34:54,200
value only if it exists so here we're

00:34:51,349 --> 00:34:55,550
trying to multiply by two so if there is

00:34:54,200 --> 00:34:57,980
a value it will get multiplied by two

00:34:55,550 --> 00:34:59,900
and returned wrapped in and expected and

00:34:57,980 --> 00:35:04,010
if there wasn't a value then we just

00:34:59,900 --> 00:35:06,070
push through the error so this deals

00:35:04,010 --> 00:35:07,390
with the case where we want to just

00:35:06,070 --> 00:35:10,540
have a function which operates on the

00:35:07,390 --> 00:35:13,720
values the if we have things which

00:35:10,540 --> 00:35:15,450
return expected themselves that we have

00:35:13,720 --> 00:35:18,900
a bunch of functions which we want to

00:35:15,450 --> 00:35:21,040
just chain together and they all return

00:35:18,900 --> 00:35:23,980
expecting so they could all have some

00:35:21,040 --> 00:35:27,160
kind of disappointment then we need a

00:35:23,980 --> 00:35:28,630
way of composing these as well so what

00:35:27,160 --> 00:35:32,500
we usually have is something like and

00:35:28,630 --> 00:35:34,510
then sometimes called bind and so what

00:35:32,500 --> 00:35:37,330
this essentially does is just it's like

00:35:34,510 --> 00:35:40,360
a map but we'll we're gonna end up with

00:35:37,330 --> 00:35:43,300
like an expected of expected and if we

00:35:40,360 --> 00:35:45,070
if we have five functions which we want

00:35:43,300 --> 00:35:47,130
to compose we're gonna have an expected

00:35:45,070 --> 00:35:50,500
of expected expect of this text reject

00:35:47,130 --> 00:35:52,830
so this and then just joins them all

00:35:50,500 --> 00:35:56,220
together flattens our all into one

00:35:52,830 --> 00:35:59,470
expected object so in the end once we've

00:35:56,220 --> 00:36:03,010
done our division we just end up with a

00:35:59,470 --> 00:36:05,650
single level so this is really nice for

00:36:03,010 --> 00:36:09,730
composability so let's just expect the

00:36:05,650 --> 00:36:14,230
expected yes so now this is the code we

00:36:09,730 --> 00:36:20,440
had before and if we now use map and

00:36:14,230 --> 00:36:22,660
then it looks like this how's that okay

00:36:20,440 --> 00:36:27,850
that's definitely less code I'll give

00:36:22,660 --> 00:36:31,330
you that looking at the scores well it's

00:36:27,850 --> 00:36:34,750
safer because instead of having to

00:36:31,330 --> 00:36:36,400
manually unwrap the expected which you

00:36:34,750 --> 00:36:38,650
could do without checking that's now

00:36:36,400 --> 00:36:40,360
done for you by your helper functions so

00:36:38,650 --> 00:36:42,700
we're only ever dealing with the

00:36:40,360 --> 00:36:46,060
unwrapped values when they exist so yeah

00:36:42,700 --> 00:36:47,740
that's good safer and where she's

00:36:46,060 --> 00:36:49,630
starting to see a separation of powers

00:36:47,740 --> 00:36:51,550
emerging here we've got all the happy

00:36:49,630 --> 00:36:53,350
part at the top and the error handling

00:36:51,550 --> 00:36:55,600
at the bottom so that's going in the

00:36:53,350 --> 00:36:57,460
right direction there see them

00:36:55,600 --> 00:36:59,920
composable because now we're separating

00:36:57,460 --> 00:37:01,060
the error handling out your functions

00:36:59,920 --> 00:37:03,940
can compose and the error handling

00:37:01,060 --> 00:37:07,300
itself can compose so yeah top marks

00:37:03,940 --> 00:37:09,970
there but it's still noisy it's not just

00:37:07,300 --> 00:37:11,350
noisy but you have to contort the way

00:37:09,970 --> 00:37:13,750
you even think about this because now

00:37:11,350 --> 00:37:15,940
the the initial values are going in in

00:37:13,750 --> 00:37:18,530
the middle and then the flow is sort of

00:37:15,940 --> 00:37:20,930
spiraling out and you have to

00:37:18,530 --> 00:37:23,420
awkwardly mess the functions and I'm not

00:37:20,930 --> 00:37:25,040
even sure I had to format this so yeah I

00:37:23,420 --> 00:37:26,780
can't really say I like it on that on

00:37:25,040 --> 00:37:28,820
that grounds so yeah you can do about

00:37:26,780 --> 00:37:31,340
that yeah and I guess it's even worse

00:37:28,820 --> 00:37:33,740
like if you have a bunch of things

00:37:31,340 --> 00:37:35,030
you're gonna be doing calling map and

00:37:33,740 --> 00:37:37,160
and then on then this is just gonna

00:37:35,030 --> 00:37:40,430
eventually span the entirety of this

00:37:37,160 --> 00:37:42,440
screen right it's a big screen yeah it's

00:37:40,430 --> 00:37:45,890
a big screen so guess what we'd like to

00:37:42,440 --> 00:37:49,490
do is just take all this inside our it

00:37:45,890 --> 00:37:53,060
nested nonsense flatten out and make it

00:37:49,490 --> 00:37:54,680
just a nice clean line of function calls

00:37:53,060 --> 00:37:57,740
neat trick if you can do it

00:37:54,680 --> 00:38:01,820
yeah so we could take a leaf out of

00:37:57,740 --> 00:38:04,900
Ranger's book ranges likes to compose

00:38:01,820 --> 00:38:07,310
things and they use operator overloading

00:38:04,900 --> 00:38:10,190
so if we have don't worry too much about

00:38:07,310 --> 00:38:13,010
the implementation at the top that we

00:38:10,190 --> 00:38:16,570
essentially have types called mapping

00:38:13,010 --> 00:38:21,440
and then which do over all the work in

00:38:16,570 --> 00:38:24,620
this operator overload so you can then

00:38:21,440 --> 00:38:27,680
just see to int and then do this map

00:38:24,620 --> 00:38:35,270
this and all it just goes nicely down

00:38:27,680 --> 00:38:37,130
the line that is a lot better yeah a lot

00:38:35,270 --> 00:38:38,810
less noisy so I'll put that up this not

00:38:37,130 --> 00:38:41,570
perfect because we've still got a lot of

00:38:38,810 --> 00:38:42,890
the boilerplate there although all the

00:38:41,570 --> 00:38:44,660
lender stuff it's not really anything to

00:38:42,890 --> 00:38:46,040
do with a happy path but with you know I

00:38:44,660 --> 00:38:48,290
can look at that that's um

00:38:46,040 --> 00:38:50,240
it's a much nicer control flow we could

00:38:48,290 --> 00:38:51,980
see the values going in at the top and

00:38:50,240 --> 00:38:56,290
we can see it so flowing step by step

00:38:51,980 --> 00:38:59,690
through a like a pipeline of of course

00:38:56,290 --> 00:39:01,640
one problem though is that this this

00:38:59,690 --> 00:39:04,190
pipe operators we're really sort of

00:39:01,640 --> 00:39:07,280
abusing the operator a bit and we might

00:39:04,190 --> 00:39:08,960
run into president's issues so although

00:39:07,280 --> 00:39:10,160
we haven't put it there maybe even put

00:39:08,960 --> 00:39:14,600
the safety down a bit because of that

00:39:10,160 --> 00:39:17,300
yeah there's actually a proposal in the

00:39:14,600 --> 00:39:18,830
works at the moment anyone who's in here

00:39:17,300 --> 00:39:20,720
the last panel

00:39:18,830 --> 00:39:24,020
azeema where t is working on the

00:39:20,720 --> 00:39:26,690
proposal for a workflow operator which

00:39:24,020 --> 00:39:29,600
has correct precedence so it makes all

00:39:26,690 --> 00:39:31,280
of this work nicely and it means you

00:39:29,600 --> 00:39:32,040
essentially have the same code but it

00:39:31,280 --> 00:39:34,230
means that some

00:39:32,040 --> 00:39:37,470
cases do the right thing so that's

00:39:34,230 --> 00:39:38,820
pretty cool yeah I think that's that's

00:39:37,470 --> 00:39:40,430
really getting there now we're getting

00:39:38,820 --> 00:39:43,530
some pretty high scores across the board

00:39:40,430 --> 00:39:47,130
there's just a bit of noise left to deal

00:39:43,530 --> 00:39:48,840
with so I think doing it better than

00:39:47,130 --> 00:39:51,560
this we're gonna have to start sort of

00:39:48,840 --> 00:39:53,670
thinking outside of C++ a bit because

00:39:51,560 --> 00:39:55,770
you know what we what we actually have

00:39:53,670 --> 00:39:58,770
here what we're dealing with technically

00:39:55,770 --> 00:40:00,480
speaking is a monad because we've got a

00:39:58,770 --> 00:40:02,670
value that we're putting inside a box

00:40:00,480 --> 00:40:04,080
and we've got operations for putting in

00:40:02,670 --> 00:40:05,190
and out of the box and binding those

00:40:04,080 --> 00:40:07,350
fingers together and that's really all

00:40:05,190 --> 00:40:09,570
on my own ideas now we've invoked the

00:40:07,350 --> 00:40:10,830
monad word or we can look at ways we can

00:40:09,570 --> 00:40:12,930
deal with that because functional

00:40:10,830 --> 00:40:14,760
programming languages do this all the

00:40:12,930 --> 00:40:16,980
time it's their bread and butter so

00:40:14,760 --> 00:40:20,010
let's go right to the top look at

00:40:16,980 --> 00:40:20,760
Haskell okay right you're gonna have to

00:40:20,010 --> 00:40:25,440
say podium again

00:40:20,760 --> 00:40:28,200
okay so Haskell has this thing called do

00:40:25,440 --> 00:40:30,600
notation and it really is just syntactic

00:40:28,200 --> 00:40:32,820
sugar as it says here in the house

00:40:30,600 --> 00:40:39,150
called wiki let's see if I can get this

00:40:32,820 --> 00:40:40,880
thing to work oh here we go so the

00:40:39,150 --> 00:40:44,160
important bit is these semicolons here

00:40:40,880 --> 00:40:45,260
they're not like C++ semicolons and you

00:40:44,160 --> 00:40:48,090
may have heard the expression

00:40:45,260 --> 00:40:50,370
programmable semicolons this is what it

00:40:48,090 --> 00:40:52,680
means what this signifies to the

00:40:50,370 --> 00:40:56,310
compiler is ways to the semicolon we're

00:40:52,680 --> 00:40:58,860
going to do expression is rewrite it to

00:40:56,310 --> 00:41:00,270
use the these map and bind operators

00:40:58,860 --> 00:41:01,320
it's the same as the things we were just

00:41:00,270 --> 00:41:03,270
looking at it just feels slightly

00:41:01,320 --> 00:41:04,680
differently so it can just directly

00:41:03,270 --> 00:41:06,690
translate what's at the top to what's at

00:41:04,680 --> 00:41:08,910
the bottom you can get rid of all the

00:41:06,690 --> 00:41:10,680
the lander craft and just write what

00:41:08,910 --> 00:41:12,060
looks like imperative code but it's

00:41:10,680 --> 00:41:15,000
still going to sprinkle through that all

00:41:12,060 --> 00:41:17,430
the the the logic for binding and get

00:41:15,000 --> 00:41:21,360
moving in and out of something like

00:41:17,430 --> 00:41:23,760
expected in this case so I think that

00:41:21,360 --> 00:41:26,190
would help a lot yeah I guess but I

00:41:23,760 --> 00:41:30,210
don't really see how we would actually

00:41:26,190 --> 00:41:31,710
do this in C++ you have any ideas well

00:41:30,210 --> 00:41:34,140
also we don't have languages for free at

00:41:31,710 --> 00:41:35,940
the moment let's have a just a little

00:41:34,140 --> 00:41:37,020
thought experiment if we put silently

00:41:35,940 --> 00:41:39,630
this into the language what would

00:41:37,020 --> 00:41:42,210
actually look like so here's the example

00:41:39,630 --> 00:41:44,190
that you know with with the using the

00:41:42,210 --> 00:41:46,110
pipe operator so sticking to what we

00:41:44,190 --> 00:41:48,510
have now

00:41:46,110 --> 00:41:50,640
if we heard something like do notation

00:41:48,510 --> 00:41:53,610
and set aside for a moment that du is

00:41:50,640 --> 00:41:56,370
already a keyword so imagine this is a

00:41:53,610 --> 00:41:58,980
Haskell like blue block now it looks

00:41:56,370 --> 00:42:01,170
much more like regular code it's much

00:41:58,980 --> 00:42:03,900
easier to think and reason about this

00:42:01,170 --> 00:42:05,610
I think the semicolons are 2 c++

00:42:03,900 --> 00:42:07,860
semicolons but imagine that's that's the

00:42:05,610 --> 00:42:10,740
point that we're going to insert those

00:42:07,860 --> 00:42:13,740
operators now what's interesting is

00:42:10,740 --> 00:42:15,510
having done that we already got a good

00:42:13,740 --> 00:42:17,430
separation here between the the happy

00:42:15,510 --> 00:42:18,570
path linear path it's just a little bit

00:42:17,430 --> 00:42:22,170
of a happy path stuck at the bottom

00:42:18,570 --> 00:42:24,900
there but if our do block returned an

00:42:22,170 --> 00:42:28,530
object that we could call a method on it

00:42:24,900 --> 00:42:31,440
took a lambda let's call it catch the

00:42:28,530 --> 00:42:33,090
lambda returns the error so only called

00:42:31,440 --> 00:42:36,300
in the case of an error we could stick

00:42:33,090 --> 00:42:37,910
our error path there and this is

00:42:36,300 --> 00:42:42,420
starting to look familiar isn't it

00:42:37,910 --> 00:42:44,970
so where we're getting getting somewhere

00:42:42,420 --> 00:42:48,380
but we've still got that do keyword yeah

00:42:44,970 --> 00:42:51,420
I mean I do like it I really do but

00:42:48,380 --> 00:42:53,670
you're right do is already a word so can

00:42:51,420 --> 00:42:58,950
you come up with a better one well I'll

00:42:53,670 --> 00:43:00,630
try let's just make it right because

00:42:58,950 --> 00:43:02,430
that completes the symmetry doesn't it

00:43:00,630 --> 00:43:04,650
but I've got something that looks very

00:43:02,430 --> 00:43:07,740
similar to what we have in C++

00:43:04,650 --> 00:43:10,140
exceptions right now except they'd be

00:43:07,740 --> 00:43:14,100
the same this translates back directly

00:43:10,140 --> 00:43:16,590
to where Simon got to with the the sit

00:43:14,100 --> 00:43:18,510
expected based error handling with all

00:43:16,590 --> 00:43:19,890
of the good properties of that had and

00:43:18,510 --> 00:43:22,590
none of the bad properties that

00:43:19,890 --> 00:43:23,760
exceptions have currently since we've

00:43:22,590 --> 00:43:25,950
got getting the compiler to rewrite

00:43:23,760 --> 00:43:29,310
sufferest we've may as well go all the

00:43:25,950 --> 00:43:32,190
way with the with the catch keyword make

00:43:29,310 --> 00:43:33,920
that a fully-fledged keyword so that's

00:43:32,190 --> 00:43:37,110
pretty good and I hope what about the

00:43:33,920 --> 00:43:39,330
the functions that we're calling so

00:43:37,110 --> 00:43:42,420
we're currently returning static spected

00:43:39,330 --> 00:43:45,150
or something like it and using student

00:43:42,420 --> 00:43:46,560
make it unexpected again we're getting

00:43:45,150 --> 00:43:48,420
the compiler to do the transformations

00:43:46,560 --> 00:43:51,300
for us so let's make it a bit more

00:43:48,420 --> 00:43:53,970
customized set of returning stood

00:43:51,300 --> 00:43:56,270
expected will say it froze that's not

00:43:53,970 --> 00:43:58,710
the old style froze this is a new thing

00:43:56,270 --> 00:43:59,579
and then it just looks like it returns a

00:43:58,710 --> 00:44:02,459
double so it's much

00:43:59,579 --> 00:44:05,009
here're which things are the normal

00:44:02,459 --> 00:44:07,349
values and which bits are to do with

00:44:05,009 --> 00:44:11,069
error handling and likewise instead of

00:44:07,349 --> 00:44:12,599
returning an unexpected but just throw

00:44:11,069 --> 00:44:14,190
it and because we're in a function mark

00:44:12,599 --> 00:44:16,859
just froze the compiler knows just to

00:44:14,190 --> 00:44:21,089
rewrite that to return make unexpected

00:44:16,859 --> 00:44:22,440
or something similar so I think we're

00:44:21,089 --> 00:44:25,049
we're really going somewhere here what

00:44:22,440 --> 00:44:26,400
do you think Simon I think we are yeah

00:44:25,049 --> 00:44:29,729
this is looking good

00:44:26,400 --> 00:44:31,829
I'll bring my scores up so I mean the

00:44:29,729 --> 00:44:33,809
overhead is really good here because as

00:44:31,829 --> 00:44:35,219
you said we're just like passing values

00:44:33,809 --> 00:44:37,650
around under the covers

00:44:35,219 --> 00:44:39,989
looks like we're throwing things but

00:44:37,650 --> 00:44:41,819
really it's just mapped to what's going

00:44:39,989 --> 00:44:44,119
to be really fast code under the covers

00:44:41,819 --> 00:44:48,029
so the overheads gonna be good here

00:44:44,119 --> 00:44:49,859
safety I brought this up before when we

00:44:48,029 --> 00:44:51,690
talked about exceptions it's hard to

00:44:49,859 --> 00:44:53,849
reason about which of these expressions

00:44:51,690 --> 00:44:55,769
could throw or not without looking at

00:44:53,849 --> 00:44:58,259
every declaration for every function you

00:44:55,769 --> 00:45:00,719
stick in a try block and so I'm gonna

00:44:58,259 --> 00:45:03,979
mark you down on safety there yep did

00:45:00,719 --> 00:45:03,979
have that it was unmarked up there

00:45:05,119 --> 00:45:11,489
speaker but the noise this is looking

00:45:07,709 --> 00:45:15,119
good like we're just right normal C++

00:45:11,489 --> 00:45:17,549
code and it's just being mapped to

00:45:15,119 --> 00:45:19,380
something which is doing more I really

00:45:17,549 --> 00:45:21,619
like that the separate paths are very

00:45:19,380 --> 00:45:25,199
clear you know try-catch just like with

00:45:21,619 --> 00:45:27,660
today's exceptions again reasonability

00:45:25,199 --> 00:45:29,519
for the same reasons as as the the

00:45:27,660 --> 00:45:31,650
safety it's hard to reason about what's

00:45:29,519 --> 00:45:34,199
gonna throw but I will give you full

00:45:31,650 --> 00:45:37,019
marks for composability and and message

00:45:34,199 --> 00:45:38,910
because we can put any string up there

00:45:37,019 --> 00:45:41,309
that we like I guess can we throw

00:45:38,910 --> 00:45:43,680
anything we like well almost I though I

00:45:41,309 --> 00:45:45,269
put a string there in practice we're

00:45:43,680 --> 00:45:47,009
going to do someone like stood error it

00:45:45,269 --> 00:45:50,009
would have to return something of fixed

00:45:47,009 --> 00:45:52,019
size so that we can disturb that the

00:45:50,009 --> 00:45:54,569
value is propagating so really it would

00:45:52,019 --> 00:45:55,769
just be an error code and there may be a

00:45:54,569 --> 00:45:57,209
pointer to something that would cover

00:45:55,769 --> 00:46:01,739
that something dynamic and if we needed

00:45:57,209 --> 00:46:03,299
it okay so I mean yeah my one issue with

00:46:01,739 --> 00:46:08,369
this is the safety and the reasonability

00:46:03,299 --> 00:46:11,160
I try something just really small simple

00:46:08,369 --> 00:46:13,240
change okay go for it we just add try

00:46:11,160 --> 00:46:16,780
and here

00:46:13,240 --> 00:46:19,420
right if we have to mark these function

00:46:16,780 --> 00:46:21,400
calls with try make your function says

00:46:19,420 --> 00:46:23,710
it throws and you have to mark the call

00:46:21,400 --> 00:46:26,610
with try then the compiler can check

00:46:23,710 --> 00:46:31,600
this and make sure you've done it right

00:46:26,610 --> 00:46:33,250
so now if I forget to say oh look this

00:46:31,600 --> 00:46:35,740
function could throw something the

00:46:33,250 --> 00:46:38,380
compiler says no you need to think about

00:46:35,740 --> 00:46:40,750
this I'm not gonna let you forget and

00:46:38,380 --> 00:46:43,810
that's really nice for reasonability and

00:46:40,750 --> 00:46:46,810
safety I guess even I mean if this is

00:46:43,810 --> 00:46:49,090
built into the compiler could there's be

00:46:46,810 --> 00:46:51,100
even faster than just using if an else

00:46:49,090 --> 00:46:53,350
well I think it could because although

00:46:51,100 --> 00:46:55,090
we talked about it mapping to something

00:46:53,350 --> 00:46:56,440
like stood expected now the compiler

00:46:55,090 --> 00:46:59,220
knows about it and it can do more

00:46:56,440 --> 00:47:01,930
optimizations so in fact there's a

00:46:59,220 --> 00:47:03,280
single bit in the in the return channel

00:47:01,930 --> 00:47:05,380
that's in a register that's not

00:47:03,280 --> 00:47:07,360
currently used it could be used to

00:47:05,380 --> 00:47:09,460
indicate whether it's an error or not

00:47:07,360 --> 00:47:12,880
and you're gonna get that basically for

00:47:09,460 --> 00:47:14,830
free almost and even the the if involved

00:47:12,880 --> 00:47:16,810
will often be optimized away by the

00:47:14,830 --> 00:47:19,900
branch predictor so I would say we could

00:47:16,810 --> 00:47:21,340
even put the overhead up to a ten you

00:47:19,900 --> 00:47:23,170
might argue maybe it's a nine and a half

00:47:21,340 --> 00:47:25,660
but I think that's pretty good

00:47:23,170 --> 00:47:27,850
we've got almost 10 10 out of 10 across

00:47:25,660 --> 00:47:29,530
the board with that I would really love

00:47:27,850 --> 00:47:31,450
to test so I like this in the language

00:47:29,530 --> 00:47:33,430
about making you Simon yeah definitely

00:47:31,450 --> 00:47:36,670
actually should we just start writing a

00:47:33,430 --> 00:47:39,550
paper on it well you know what it's

00:47:36,670 --> 00:47:42,430
already been done yeah this is basically

00:47:39,550 --> 00:47:44,620
what hope Sutter's zero overhead

00:47:42,430 --> 00:47:49,990
deterministic exceptions is all about

00:47:44,620 --> 00:47:51,670
aka static exceptions aka perceptions if

00:47:49,990 --> 00:47:53,320
you haven't read this paper you really

00:47:51,670 --> 00:47:54,880
should because it goes for all of the

00:47:53,320 --> 00:47:57,160
things that we've been talking about and

00:47:54,880 --> 00:47:59,410
much more in a lot more depth it's

00:47:57,160 --> 00:48:02,250
really compelling what we really wanted

00:47:59,410 --> 00:48:03,880
to convey here is that this is not just

00:48:02,250 --> 00:48:05,920
exceptions done a bit better

00:48:03,880 --> 00:48:07,750
this is rethinking it from scratch

00:48:05,920 --> 00:48:10,150
looking at where we got to with

00:48:07,750 --> 00:48:12,010
something like stood expected or boost

00:48:10,150 --> 00:48:14,050
outcome and how would we make that

00:48:12,010 --> 00:48:16,030
easier to use in the language without

00:48:14,050 --> 00:48:18,370
getting without losing any of the

00:48:16,030 --> 00:48:21,700
benefits so we've ended up with some of

00:48:18,370 --> 00:48:23,320
the looks somewhat similar to exceptions

00:48:21,700 --> 00:48:25,540
that we have now but we're done are the

00:48:23,320 --> 00:48:27,070
downsides and all of the upsides at

00:48:25,540 --> 00:48:29,680
least said that's what we think so

00:48:27,070 --> 00:48:31,660
we'll leave it up to you to decide yeah

00:48:29,680 --> 00:48:33,160
so I think we should definitely be

00:48:31,660 --> 00:48:36,550
looking to put something like this in

00:48:33,160 --> 00:48:39,100
C++ i think the try part that i just

00:48:36,550 --> 00:48:40,600
added is like an optional part to the

00:48:39,100 --> 00:48:42,130
paper but i think that's definitely the

00:48:40,600 --> 00:48:44,470
right way to go yeah i agree with you

00:48:42,130 --> 00:48:46,600
that yep so i think we should be

00:48:44,470 --> 00:48:49,120
thinking about this and accepting it

00:48:46,600 --> 00:48:49,900
into the standard because what could

00:48:49,120 --> 00:48:52,530
possibly go wrong

00:48:49,900 --> 00:48:52,530
thank you

00:49:00,730 --> 00:49:12,560
okay well any questions now yes

00:49:04,070 --> 00:49:16,840
microphone will be great thank you oh we

00:49:12,560 --> 00:49:47,150
have them AV down here please if anyone

00:49:16,840 --> 00:49:50,290
okay just speak we'll repeat so I think

00:49:47,150 --> 00:49:52,760
the question was referring back to

00:49:50,290 --> 00:49:55,220
Andrey said yesterday that sometimes you

00:49:52,760 --> 00:49:57,020
want low Clara handling that then rather

00:49:55,220 --> 00:49:58,640
than it branching out to a catch block

00:49:57,020 --> 00:49:59,930
you want to handle it there and then at

00:49:58,640 --> 00:50:01,790
the return site like you would with a

00:49:59,930 --> 00:50:04,099
return value which is a it's an

00:50:01,790 --> 00:50:06,200
excellent point and this proposal

00:50:04,099 --> 00:50:08,869
doesn't preclude that because as we said

00:50:06,200 --> 00:50:10,820
it Maps directly back to returning

00:50:08,869 --> 00:50:13,070
something and I think it's an optional

00:50:10,820 --> 00:50:16,040
part of the proposal if I remember

00:50:13,070 --> 00:50:17,390
rightly that you have a facility to to

00:50:16,040 --> 00:50:19,190
map it back to that and deal with

00:50:17,390 --> 00:50:21,380
they're in there but don't don't think

00:50:19,190 --> 00:50:22,849
it's actually an optional part of the

00:50:21,380 --> 00:50:25,940
proposal but that's something I'll be

00:50:22,849 --> 00:50:27,830
supportive of yeah you definitely design

00:50:25,940 --> 00:50:30,050
it such that like if you don't want to

00:50:27,830 --> 00:50:32,180
use the try and clash with the try

00:50:30,050 --> 00:50:34,640
expressions then maybe there's a way to

00:50:32,180 --> 00:50:36,770
say okay I want to explicitly like get

00:50:34,640 --> 00:50:38,060
the expected like object from this thing

00:50:36,770 --> 00:50:40,910
and then handle it right there and then

00:50:38,060 --> 00:50:44,060
so yes it's a design point yeah

00:50:40,910 --> 00:50:49,690
thank you your next question I think the

00:50:44,060 --> 00:50:53,089
mic is on now actually yep

00:50:49,690 --> 00:50:54,619
so still expected and static exceptions

00:50:53,089 --> 00:50:56,570
are wonderful and they're awesome but

00:50:54,619 --> 00:50:59,660
they still fall into this error handling

00:50:56,570 --> 00:51:01,820
paradigm of I either compute a result or

00:50:59,660 --> 00:51:03,560
I have an error right there very much a

00:51:01,820 --> 00:51:06,619
maybe type from functional programming

00:51:03,560 --> 00:51:08,300
but there are still corner cases where

00:51:06,619 --> 00:51:10,250
that doesn't cover everything we need

00:51:08,300 --> 00:51:11,780
all right in particular this has come up

00:51:10,250 --> 00:51:13,100
in some discussions around like the

00:51:11,780 --> 00:51:16,370
networking TS

00:51:13,100 --> 00:51:18,800
with composed i/o operations where I'm

00:51:16,370 --> 00:51:21,760
making say repeated calls to say like

00:51:18,800 --> 00:51:25,100
read or write system calls to either

00:51:21,760 --> 00:51:27,830
fill buffers or drain a series of

00:51:25,100 --> 00:51:30,530
buffers and it might fail in the middle

00:51:27,830 --> 00:51:31,880
right except to make repeated calls to

00:51:30,530 --> 00:51:34,130
actually complete the whole operation

00:51:31,880 --> 00:51:36,650
and in that case there's code that's um

00:51:34,130 --> 00:51:39,920
that's a particularly correctness

00:51:36,650 --> 00:51:42,890
sensitive we're communicating both the

00:51:39,920 --> 00:51:45,110
failure reason and the total number of

00:51:42,890 --> 00:51:47,360
bytes transferred so far is absolutely

00:51:45,110 --> 00:51:49,130
necessary right and it seems right now

00:51:47,360 --> 00:51:51,170
the discussion is that we're still

00:51:49,130 --> 00:51:52,790
falling into this world of a dual API

00:51:51,170 --> 00:51:54,320
where we have a stood error code output

00:51:52,790 --> 00:51:57,770
parameter and wondering what your

00:51:54,320 --> 00:52:00,080
thoughts are on that and my suspicion is

00:51:57,770 --> 00:52:01,910
that there's another library type hiding

00:52:00,080 --> 00:52:04,670
out there for us to discover like stood

00:52:01,910 --> 00:52:06,800
expected yes we haven't been clever

00:52:04,670 --> 00:52:10,400
enough to come up with it yeah yeah it

00:52:06,800 --> 00:52:12,260
just seemed like what you're thinking

00:52:10,400 --> 00:52:14,210
about it something like you have an

00:52:12,260 --> 00:52:16,520
expected type and an unexpected type

00:52:14,210 --> 00:52:19,130
some kind of audit trail like an

00:52:16,520 --> 00:52:20,960
something which is accumulating

00:52:19,130 --> 00:52:22,910
information about how we got to this

00:52:20,960 --> 00:52:25,640
current writer monad yeah exactly

00:52:22,910 --> 00:52:29,000
exactly yes you're trying to essentially

00:52:25,640 --> 00:52:32,600
compose the either monad with the writer

00:52:29,000 --> 00:52:34,400
monad and yes I think there's there's

00:52:32,600 --> 00:52:36,290
definitely some library design stuff you

00:52:34,400 --> 00:52:40,600
could do to solve that problem it would

00:52:36,290 --> 00:52:45,200
be like a very specific library solution

00:52:40,600 --> 00:52:47,840
to that thing if we had there is a paper

00:52:45,200 --> 00:52:51,710
for kind of generalized magnetic

00:52:47,840 --> 00:52:53,570
framework for C++ I guess that would

00:52:51,710 --> 00:52:56,000
help in some ways because then you could

00:52:53,570 --> 00:52:57,830
just nest these monads together and then

00:52:56,000 --> 00:52:59,240
have everything just work so long as you

00:52:57,830 --> 00:53:02,870
kind of understood what you were doing

00:52:59,240 --> 00:53:06,070
right and so that might help but yeah

00:53:02,870 --> 00:53:08,480
that's a lot of that's a long way away

00:53:06,070 --> 00:53:11,300
so yeah I understand people have these

00:53:08,480 --> 00:53:13,850
problems like today yeah and yeah right

00:53:11,300 --> 00:53:15,140
now we have two crap library solutions

00:53:13,850 --> 00:53:17,960
for these things so yeah I think there's

00:53:15,140 --> 00:53:19,490
a really good point and that if we build

00:53:17,960 --> 00:53:21,530
this into the language this is solving

00:53:19,490 --> 00:53:23,930
this problem and not necessarily

00:53:21,530 --> 00:53:26,510
everyone's problem mm-hmm yeah thank you

00:53:23,930 --> 00:53:26,960
for that Thanks plus my hot take on that

00:53:26,510 --> 00:53:28,490
is

00:53:26,960 --> 00:53:32,420
what we're talking about here is error

00:53:28,490 --> 00:53:34,520
handling and you can imagine something

00:53:32,420 --> 00:53:36,590
like I'm talking about decaying to a

00:53:34,520 --> 00:53:38,270
stood expected right if you yep let's

00:53:36,590 --> 00:53:39,890
say at the top level I really only care

00:53:38,270 --> 00:53:42,470
about success or failure but maybe

00:53:39,890 --> 00:53:44,780
intermediately I really do need to care

00:53:42,470 --> 00:53:46,340
about all the fine details but yeah yeah

00:53:44,780 --> 00:53:47,750
we have care routines which is slightly

00:53:46,340 --> 00:53:49,160
more generalized approach to a similar

00:53:47,750 --> 00:53:53,180
set of problems about that was a man

00:53:49,160 --> 00:53:55,850
named Yannick any next question could

00:53:53,180 --> 00:53:59,150
you go to try to in Taiji right slide

00:53:55,850 --> 00:54:01,240
which one time this one yes it does

00:53:59,150 --> 00:54:03,640
divide function with this definition

00:54:01,240 --> 00:54:18,130
support

00:54:03,640 --> 00:54:21,800
denominator I don't see mean if to int

00:54:18,130 --> 00:54:24,050
returns a assisted string like it had

00:54:21,800 --> 00:54:27,140
the error path what does divide do yes

00:54:24,050 --> 00:54:29,450
and that case divides never called it's

00:54:27,140 --> 00:54:31,790
essentially like an early exit type

00:54:29,450 --> 00:54:35,780
thing so when you're if you think about

00:54:31,790 --> 00:54:38,750
if we go back to the pipeline code there

00:54:35,780 --> 00:54:42,680
might be clearer here we go

00:54:38,750 --> 00:54:46,400
right so these these calls here like if

00:54:42,680 --> 00:54:49,670
this if this and then returns a an

00:54:46,400 --> 00:54:53,030
unexpected value then this map is no op

00:54:49,670 --> 00:54:57,350
it just returns what it was given so

00:54:53,030 --> 00:55:00,130
this when we map it back to to this

00:54:57,350 --> 00:55:03,740
example and it's doing the same thing

00:55:00,130 --> 00:55:05,600
that this divide is just a I mean that

00:55:03,740 --> 00:55:07,490
this is a different order than that

00:55:05,600 --> 00:55:08,900
example but is the same kind of thing if

00:55:07,490 --> 00:55:12,410
one of these fails and the rest is just

00:55:08,900 --> 00:55:16,940
to know what okay thanks next question

00:55:12,410 --> 00:55:19,100
was first sorry thanks one comment and

00:55:16,940 --> 00:55:22,520
one question the comments is that the

00:55:19,100 --> 00:55:25,880
examples and therefore I suspect I'm not

00:55:22,520 --> 00:55:28,160
sure whether the testing is fair with

00:55:25,880 --> 00:55:30,770
regards to exceptions as they are today

00:55:28,160 --> 00:55:32,360
and it's the other forms because we have

00:55:30,770 --> 00:55:35,600
all these things surrounding stack of

00:55:32,360 --> 00:55:38,930
winding which most of the other cases

00:55:35,600 --> 00:55:40,830
seem to kind of ignore like how do you

00:55:38,930 --> 00:55:43,890
jump out of this scope

00:55:40,830 --> 00:55:46,830
it's not really apples to apples and the

00:55:43,890 --> 00:55:51,450
question with regards to one of your

00:55:46,830 --> 00:55:55,880
later slides I'm guessing the one say

00:55:51,450 --> 00:56:00,060
stop one of the last points probably is

00:55:55,880 --> 00:56:06,530
whether the the throws point the source

00:56:00,060 --> 00:56:10,830
one yes but when we write throws in the

00:56:06,530 --> 00:56:13,920
declaration yes is it this one yes

00:56:10,830 --> 00:56:16,370
so this is kind of like the start of it

00:56:13,920 --> 00:56:21,510
but the question really is is this

00:56:16,370 --> 00:56:23,070
function implicitly no except that's a

00:56:21,510 --> 00:56:25,230
very interesting question and I think

00:56:23,070 --> 00:56:28,550
we've debated on SP 14 when this this

00:56:25,230 --> 00:56:31,500
came up if I remember rightly I think

00:56:28,550 --> 00:56:34,500
that were roughly divided on whatever

00:56:31,500 --> 00:56:36,300
should imply that or not because it

00:56:34,500 --> 00:56:38,340
would seem a bit redundant but froggies

00:56:36,300 --> 00:56:39,570
are no except in a bit odd but on the

00:56:38,340 --> 00:56:40,830
other hand it sort of makes some some

00:56:39,570 --> 00:56:43,680
logical sense as well I can't remember

00:56:40,830 --> 00:56:46,350
where they ended up yeah and there's a

00:56:43,680 --> 00:56:50,610
lot of stuff in the the paper about you

00:56:46,350 --> 00:56:52,410
know transformations between static and

00:56:50,610 --> 00:56:55,140
dynamic exceptions like what happens if

00:56:52,410 --> 00:56:58,620
you if you have a function which is

00:56:55,140 --> 00:57:00,270
marked throws and dynamic exception

00:56:58,620 --> 00:57:02,430
tries to exit that like can you convert

00:57:00,270 --> 00:57:04,050
it to a static exception maybe in some

00:57:02,430 --> 00:57:06,660
cases do you have to go the other way

00:57:04,050 --> 00:57:07,920
sometimes maybe so there's there's extra

00:57:06,660 --> 00:57:10,110
stuff in the paper about that as well

00:57:07,920 --> 00:57:12,110
yeah they should in to operate and we

00:57:10,110 --> 00:57:14,460
wouldn't really cover that but yeah

00:57:12,110 --> 00:57:17,760
whether you whether that's specifically

00:57:14,460 --> 00:57:19,140
like making froze implies no except I

00:57:17,760 --> 00:57:21,120
think we're leaning towards yes but I

00:57:19,140 --> 00:57:23,550
don't agree is conclusive but it may

00:57:21,120 --> 00:57:24,870
have I haven't been you know on the

00:57:23,550 --> 00:57:26,610
course in since I'm not sure if that's

00:57:24,870 --> 00:57:33,180
been clarified

00:57:26,610 --> 00:57:36,570
yeah next question does this cover

00:57:33,180 --> 00:57:39,620
constructors as well akin constructors

00:57:36,570 --> 00:57:42,210
throw and this new way constructors and

00:57:39,620 --> 00:57:46,290
operators yes so you couldn't do that

00:57:42,210 --> 00:57:47,820
with the suit expected based the return

00:57:46,290 --> 00:57:49,410
we don't have that return channel yeah

00:57:47,820 --> 00:57:51,650
but because the compiler knows about

00:57:49,410 --> 00:57:54,119
this yes it can do that it's as if it's

00:57:51,650 --> 00:57:55,529
greater than you return channel for you

00:57:54,119 --> 00:57:58,740
yeah and another quick question you

00:57:55,529 --> 00:58:04,529
mentioned heap exhaustion is kind of a

00:57:58,740 --> 00:58:05,759
separate topic yeah but the way this

00:58:04,529 --> 00:58:07,049
evolved we didn't really come back to

00:58:05,759 --> 00:58:09,630
that but that the whole reason that

00:58:07,049 --> 00:58:11,180
significant is because if you think

00:58:09,630 --> 00:58:13,710
about it

00:58:11,180 --> 00:58:15,869
majority of uses of exceptions are to do

00:58:13,710 --> 00:58:18,180
with a hip exhaustion or the majority of

00:58:15,869 --> 00:58:20,009
defensive coding against it if you take

00:58:18,180 --> 00:58:22,650
that out of the picture then most of

00:58:20,009 --> 00:58:25,289
what's left either will be a contract

00:58:22,650 --> 00:58:28,200
it's why we talked about that or it'd be

00:58:25,289 --> 00:58:30,539
well suited to aesthetic exceptions that

00:58:28,200 --> 00:58:32,309
the bill missed no reason left to to

00:58:30,539 --> 00:58:34,980
need dynamic exceptions that they would

00:58:32,309 --> 00:58:38,400
still happen that could possibly be the

00:58:34,980 --> 00:58:40,890
only youth would have left for them the

00:58:38,400 --> 00:58:44,490
significance is that we did adopt this

00:58:40,890 --> 00:58:47,339
and the standard library made most of

00:58:44,490 --> 00:58:50,309
its logic errors into contracts then

00:58:47,339 --> 00:58:51,900
there'd be no dynamic exceptions left in

00:58:50,309 --> 00:58:53,609
the standard library which would be

00:58:51,900 --> 00:58:55,200
quite a nice place to be because they

00:58:53,609 --> 00:58:58,079
know that those 52 percent of people

00:58:55,200 --> 00:58:59,940
that I can't currently say that they're

00:58:58,079 --> 00:59:01,319
using standard suit bus bus will be able

00:58:59,940 --> 00:59:03,089
to use down a seat bus possibly there's

00:59:01,319 --> 00:59:05,700
no exceptions and they're just a Bourdon

00:59:03,089 --> 00:59:08,640
bad alec sorry and then just a board on

00:59:05,700 --> 00:59:11,519
that bad Alec I guess right well for

00:59:08,640 --> 00:59:12,749
those people it's not going to matter if

00:59:11,519 --> 00:59:15,809
by default

00:59:12,749 --> 00:59:21,380
bad Alec actually terminates but you you

00:59:15,809 --> 00:59:21,380
can still use the version of knew that

00:59:23,900 --> 00:59:29,130
then most people that care can use that

00:59:27,150 --> 00:59:33,869
and those people that don't don't

00:59:29,130 --> 00:59:38,720
they'll be fine thanks thanks yes maybe

00:59:33,869 --> 00:59:42,749
time for one more last question yet okay

00:59:38,720 --> 00:59:45,239
do in this model do I have to put the

00:59:42,749 --> 00:59:48,960
trike age for every function but might

00:59:45,239 --> 00:59:51,450
potentially Pro or is it it will be just

00:59:48,960 --> 00:59:54,749
like with dynamic exceptions that it

00:59:51,450 --> 00:59:59,210
will propagate up the stack yes this

00:59:54,749 --> 01:00:01,349
comes back to the like and

00:59:59,210 --> 01:00:03,450
transformations between static and

01:00:01,349 --> 01:00:07,440
dynamic exceptions there's a lot of

01:00:03,450 --> 01:00:07,980
wording around that to fully answer that

01:00:07,440 --> 01:00:10,950
question

01:00:07,980 --> 01:00:12,780
would take longer than time we have who

01:00:10,950 --> 01:00:14,790
didn't try catch every function that

01:00:12,780 --> 01:00:17,460
might potentially fall I think the

01:00:14,790 --> 01:00:19,320
simple answer is terms a try/catch it's

01:00:17,460 --> 01:00:21,480
pretty much the same as dynamic

01:00:19,320 --> 01:00:23,190
exceptions if you miss them the area

01:00:21,480 --> 01:00:24,660
will propagate through to the next level

01:00:23,190 --> 01:00:27,660
which means your function has to be much

01:00:24,660 --> 01:00:30,240
frozen but that's the requirement okay

01:00:27,660 --> 01:00:33,619
so for example if you have a contract

01:00:30,240 --> 01:00:36,780
that I pass on int and they use it as

01:00:33,619 --> 01:00:39,090
denominator for divide and I've a

01:00:36,780 --> 01:00:42,180
contract in my function that it's not a

01:00:39,090 --> 01:00:44,400
zero but I pass it to divide where it

01:00:42,180 --> 01:00:48,650
might throw so I have to throw but I

01:00:44,400 --> 01:00:52,500
know that I will never fro can I like

01:00:48,650 --> 01:00:53,760
how do I like tell a compiler that it

01:00:52,500 --> 01:00:55,380
will never happen because I have a

01:00:53,760 --> 01:00:59,310
contract how they connect these two

01:00:55,380 --> 01:01:00,630
strategies of error handling I'm getting

01:00:59,310 --> 01:01:03,750
me right I think you would have to wrap

01:01:00,630 --> 01:01:08,310
that in a try-catch and the the catch

01:01:03,750 --> 01:01:13,590
would abort or something yeah but I know

01:01:08,310 --> 01:01:15,450
from never zero yes I understand imagine

01:01:13,590 --> 01:01:17,570
because because it's translates back to

01:01:15,450 --> 01:01:20,880
you know imagine it's to returning a

01:01:17,570 --> 01:01:22,920
instead expected well if you're calling

01:01:20,880 --> 01:01:26,310
a function that you know will never

01:01:22,920 --> 01:01:28,230
return an unexpected but it returns

01:01:26,310 --> 01:01:30,869
still expected or something you've still

01:01:28,230 --> 01:01:32,820
got to unwrap it yeah yeah so it's the

01:01:30,869 --> 01:01:35,130
same thing the try catch is just doing

01:01:32,820 --> 01:01:38,910
the unwrapping for you but that's really

01:01:35,130 --> 01:01:41,609
all thank you thank you yeah it's

01:01:38,910 --> 01:01:44,160
lightning fast is sg1 for sorry is as

01:01:41,609 --> 01:01:51,450
314 done with this paper and can when

01:01:44,160 --> 01:01:53,760
can evolution start taking it apart like

01:01:51,450 --> 01:01:56,810
asking asking somebody from a pollution

01:01:53,760 --> 01:02:00,990
so that I can start taking it apart huh

01:01:56,810 --> 01:02:03,300
yeah I think s 314 very strongly in

01:02:00,990 --> 01:02:04,830
support of the paper in general there's

01:02:03,300 --> 01:02:06,240
definitely some two-bike shedding over

01:02:04,830 --> 01:02:09,090
the details which is why summit of the

01:02:06,240 --> 01:02:12,810
paper is optional yeah that's right

01:02:09,090 --> 01:02:18,210
because because like as a general note

01:02:12,810 --> 01:02:19,710
at 314 shouldn't be very shouldn't care

01:02:18,210 --> 01:02:21,590
about the bike sitting too much because

01:02:19,710 --> 01:02:23,960
evolution is going to that that

01:02:21,590 --> 01:02:25,130
by shedding again so maybe bike shedding

01:02:23,960 --> 01:02:26,480
is the wrong word this is the high level

01:02:25,130 --> 01:02:30,110
it's it's more about yeah should I make

01:02:26,480 --> 01:02:32,360
this major feature or not right so just

01:02:30,110 --> 01:02:34,310
it just mean dunce but spent too much

01:02:32,360 --> 01:02:38,840
time and details because they are going

01:02:34,310 --> 01:02:42,789
to change okay thank you very much

01:02:38,840 --> 01:02:42,789

YouTube URL: https://www.youtube.com/watch?v=GC4cp4U2f2E


