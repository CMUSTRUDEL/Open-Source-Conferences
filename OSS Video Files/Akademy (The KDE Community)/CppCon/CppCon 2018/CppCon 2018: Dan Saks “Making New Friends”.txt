Title: CppCon 2018: Dan Saks “Making New Friends”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
A friend of a class is a function or class that is not a member of that class, but nonetheless has access to all members of that class. The conventional wisdom is that granting friendship is something you do should sparingly. This lecture introduces a distinctive use for friend function declarations in class templates that's not about granting access to non-public members. Rather, it's about using a template as a 
factory for "making" new friends. Along the way, this session explains various subtleties about operator overloading, overload resolution, 
template instantiation, and name lookup for friend functions. 
— 

Dan Saks, Saks & Associates
President

Dan Saks is the president of Saks & Associates, which offers training and consulting in C and C++ and their use in developing embedded systems. Dan used to write the “Programming Pointers” column for embedded.com online. He has also written columns for numerous print publications including The C/C++ Users Journal, The C++ Report, Software Development, and Embedded Systems Design. With Thomas Plum, he wrote C++ Programming Guidelines, which won a 1992 Computer Language Magazine Productivity Award. Dan has taught C and C++ to thousands of programmers around the world. He has presented at conferences such as Software Development, Embedded Systems, and C++ World. He has served on the advisory boards of the Embedded Systems and Software Development conferences. Dan served as secretary of the ANSI and ISO C++ Standards committees and as a member of the ANSI C Standards committee. More recently, he contributed to the CERT Secure C Coding Standard and the CERT Secure C++ Coding Standard.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,189 --> 00:00:09,990
I'm dance acts and there's my topic

00:00:03,960 --> 00:00:11,790
let's just do it this is really the

00:00:09,990 --> 00:00:14,730
whole thing is focused on a particular

00:00:11,790 --> 00:00:16,349
use of the keyword friend that I think

00:00:14,730 --> 00:00:19,980
is it's an interesting little corner

00:00:16,349 --> 00:00:21,989
case and so we're really going to do is

00:00:19,980 --> 00:00:23,999
give you is show you the technique but

00:00:21,989 --> 00:00:25,529
but I think is really interesting is all

00:00:23,999 --> 00:00:29,309
the little bits and pieces that go into

00:00:25,529 --> 00:00:32,780
the backstory the the interest is in the

00:00:29,309 --> 00:00:35,340
details is a very code intensive and so

00:00:32,780 --> 00:00:37,019
I'll just alert you they're gonna be

00:00:35,340 --> 00:00:38,640
pieces where I'll show you this you know

00:00:37,019 --> 00:00:40,500
and your attitude will be come on show

00:00:38,640 --> 00:00:42,329
me something I don't know about my

00:00:40,500 --> 00:00:44,339
experience is if I leap ahead on this

00:00:42,329 --> 00:00:47,129
and all of a sudden dive in the middle

00:00:44,339 --> 00:00:48,870
you'll how did you get here so just let

00:00:47,129 --> 00:00:52,199
me just sail through it and but don't

00:00:48,870 --> 00:00:53,760
hesitate to stop and ask me a question

00:00:52,199 --> 00:00:55,800
of clarification if there's anything

00:00:53,760 --> 00:00:57,329
that you would like me I prefer to be

00:00:55,800 --> 00:00:59,730
interrupted while I'm talking rather

00:00:57,329 --> 00:01:03,179
than do all this stuff at the end so

00:00:59,730 --> 00:01:05,100
anyway what's friendship about in C++

00:01:03,179 --> 00:01:08,189
it's a key word you can put it in a

00:01:05,100 --> 00:01:11,610
class associated with a function or a

00:01:08,189 --> 00:01:16,049
another class and what its primary role

00:01:11,610 --> 00:01:17,790
is is to grant access to the class

00:01:16,049 --> 00:01:20,210
granting the friendship to something

00:01:17,790 --> 00:01:23,969
that normally wouldn't have that access

00:01:20,210 --> 00:01:26,969
and but it and you use it judiciously

00:01:23,969 --> 00:01:28,920
because you don't want to access control

00:01:26,969 --> 00:01:32,070
is a big deal in C++ you don't want to

00:01:28,920 --> 00:01:33,780
give it away unnecessarily but they're

00:01:32,070 --> 00:01:36,180
clearly Plitt times in places that you

00:01:33,780 --> 00:01:37,770
need to do this but what I'm gonna do is

00:01:36,180 --> 00:01:39,930
show you a use for the keyword friend

00:01:37,770 --> 00:01:42,930
that's actually not about granting

00:01:39,930 --> 00:01:47,609
access it's about making something else

00:01:42,930 --> 00:01:50,640
click and in this example I hope you'll

00:01:47,609 --> 00:01:51,840
be able to see that what it does is it

00:01:50,640 --> 00:01:54,390
actually simplifies the implementation

00:01:51,840 --> 00:01:57,090
of certain aspects of a class and it

00:01:54,390 --> 00:02:01,590
also produces a better interface as a as

00:01:57,090 --> 00:02:03,899
benefit so what I'm going to use as my

00:02:01,590 --> 00:02:05,850
example is a class for rational numbers

00:02:03,899 --> 00:02:07,920
I think it's it's a nice easy to

00:02:05,850 --> 00:02:09,600
understand example because I most of us

00:02:07,920 --> 00:02:10,950
know how to do fractional arithmetic we

00:02:09,600 --> 00:02:13,410
know what the purpose of something like

00:02:10,950 --> 00:02:18,000
this would be

00:02:13,410 --> 00:02:20,310
and and and what example use cases would

00:02:18,000 --> 00:02:23,940
look like now in order to keep the

00:02:20,310 --> 00:02:25,290
examples readable I've left out certain

00:02:23,940 --> 00:02:28,050
details like there is an ample

00:02:25,290 --> 00:02:29,820
opportunity to use context burr in the

00:02:28,050 --> 00:02:32,430
code you're about to see I'm not doing

00:02:29,820 --> 00:02:36,120
that just because it adds verbiage and

00:02:32,430 --> 00:02:40,110
clutter to the slides but just remember

00:02:36,120 --> 00:02:41,880
there's uses for it I most also you

00:02:40,110 --> 00:02:43,800
could say the same thing about in lining

00:02:41,880 --> 00:02:46,560
I will throw the keyword inline in a few

00:02:43,800 --> 00:02:49,350
places but not in every opportunity just

00:02:46,560 --> 00:02:51,750
again to minimize clutter in there in

00:02:49,350 --> 00:02:55,470
the code so here is a first cut at a

00:02:51,750 --> 00:02:57,390
class for rational numbers in this

00:02:55,470 --> 00:03:00,210
particular case my starting version it's

00:02:57,390 --> 00:03:01,560
not a template it's just a class that

00:03:00,210 --> 00:03:04,770
implements the numerator and denominator

00:03:01,560 --> 00:03:08,520
of the rational numbers as long side

00:03:04,770 --> 00:03:10,440
long integers and as you might expect it

00:03:08,520 --> 00:03:12,660
has a small assortment of constructors

00:03:10,440 --> 00:03:14,970
that let you do things like make me a

00:03:12,660 --> 00:03:18,390
rational with a reasonable default value

00:03:14,970 --> 00:03:20,550
make me a rational number whose initial

00:03:18,390 --> 00:03:22,770
value is the same as some integer so for

00:03:20,550 --> 00:03:25,020
example not surprisingly if you say make

00:03:22,770 --> 00:03:30,300
me a rational whose value is 3 you get 3

00:03:25,020 --> 00:03:31,920
over 1 that sort of thing and it has the

00:03:30,300 --> 00:03:33,840
default implementations for the copy

00:03:31,920 --> 00:03:36,410
constructor and copy assignment because

00:03:33,840 --> 00:03:38,790
this is a data type that has a shallow

00:03:36,410 --> 00:03:41,520
implementation the compiler generated

00:03:38,790 --> 00:03:43,200
copy operations work just fine and it

00:03:41,520 --> 00:03:45,630
has no move semantics so we don't have

00:03:43,200 --> 00:03:50,940
to worry about our value references on

00:03:45,630 --> 00:03:53,100
the move operations and it also is going

00:03:50,940 --> 00:03:56,090
to have there's just one teaser there a

00:03:53,100 --> 00:03:58,110
plus equals operator it's one of many

00:03:56,090 --> 00:04:02,459
arithmetic operations that you would

00:03:58,110 --> 00:04:04,230
provide for a class like this but I've

00:04:02,459 --> 00:04:06,720
drawing your attention to the converting

00:04:04,230 --> 00:04:09,500
constructor and now what makes it a

00:04:06,720 --> 00:04:11,700
converting constructor is well but

00:04:09,500 --> 00:04:13,470
there's a little disclaimer here this is

00:04:11,700 --> 00:04:17,190
the old definition it's good enough for

00:04:13,470 --> 00:04:18,959
our purposes in C++ O 3 you would simply

00:04:17,190 --> 00:04:21,540
say a converting constructor is any

00:04:18,959 --> 00:04:25,560
constructor that takes can be invoked

00:04:21,540 --> 00:04:26,790
with a single argument now it could

00:04:25,560 --> 00:04:28,980
actually be

00:04:26,790 --> 00:04:31,710
a constructor with more than one

00:04:28,980 --> 00:04:34,290
parameter if the parameters have default

00:04:31,710 --> 00:04:36,690
values the key thing is you can call it

00:04:34,290 --> 00:04:38,810
passing it one thing and it's not

00:04:36,690 --> 00:04:42,300
declared with the keyword explicit

00:04:38,810 --> 00:04:44,760
because the keyword explicit is they are

00:04:42,300 --> 00:04:47,430
to turn off the property of a converting

00:04:44,760 --> 00:04:49,620
constructor and in an arithmetic data

00:04:47,430 --> 00:04:50,850
type like rational turns out the

00:04:49,620 --> 00:04:53,790
converting constructor is a really

00:04:50,850 --> 00:04:56,910
powerful tool for providing an interface

00:04:53,790 --> 00:04:58,890
which makes this arithmetic type behave

00:04:56,910 --> 00:05:00,780
like the built-in arithmetic types in

00:04:58,890 --> 00:05:04,770
particular you can do things like that

00:05:00,780 --> 00:05:08,610
r1 plus equals 42 where you're adding an

00:05:04,770 --> 00:05:12,240
integer to a rational number seems like

00:05:08,610 --> 00:05:14,010
a happy make sure I don't use the word

00:05:12,240 --> 00:05:16,350
rational you know it seems like a

00:05:14,010 --> 00:05:20,700
rational thing to do it seems like a

00:05:16,350 --> 00:05:22,170
fairly intuitive thing to do the

00:05:20,700 --> 00:05:24,750
understanding is though that when you

00:05:22,170 --> 00:05:26,990
write that r1 plus equals 42 the

00:05:24,750 --> 00:05:29,520
compiler steps in and says I don't see a

00:05:26,990 --> 00:05:31,470
function whose signature exactly matches

00:05:29,520 --> 00:05:34,740
that a but if I apply the converting

00:05:31,470 --> 00:05:37,080
constructor there I will get an argument

00:05:34,740 --> 00:05:39,180
match so it will on-the-fly manufacture

00:05:37,080 --> 00:05:42,830
a temporary object of type rational

00:05:39,180 --> 00:05:45,150
initialized with the value 42 as if

00:05:42,830 --> 00:05:49,110
what's shown on the bottom of the slide

00:05:45,150 --> 00:05:50,640
is really good what gets done it's that

00:05:49,110 --> 00:05:52,110
we're creating a temporary object and

00:05:50,640 --> 00:05:55,080
then using it and then throwing it away

00:05:52,110 --> 00:05:56,700
that's the as if model and compilers are

00:05:55,080 --> 00:06:00,780
pretty good at optimizing this stuff but

00:05:56,700 --> 00:06:03,360
conceptually that's what's happening now

00:06:00,780 --> 00:06:06,270
in addition to the assignment operators

00:06:03,360 --> 00:06:09,450
like plus equals minus equals the class

00:06:06,270 --> 00:06:11,910
ought to have binary operations like

00:06:09,450 --> 00:06:15,480
just plus minus times and divide where

00:06:11,910 --> 00:06:18,570
you could say r1 plus r2 something like

00:06:15,480 --> 00:06:20,970
that now here's where we run into an

00:06:18,570 --> 00:06:23,460
interface problem which is not too hard

00:06:20,970 --> 00:06:24,690
to solve but we wonder if we want this

00:06:23,460 --> 00:06:26,340
thing to really look like a built-in

00:06:24,690 --> 00:06:29,190
type we should be able to say not only

00:06:26,340 --> 00:06:31,560
are two times two but two times are two

00:06:29,190 --> 00:06:33,930
it should be symmetric in that you don't

00:06:31,560 --> 00:06:35,730
have to have both rational as the left

00:06:33,930 --> 00:06:37,160
and right argument you can use mixed

00:06:35,730 --> 00:06:40,800
arithmetic just like you can with

00:06:37,160 --> 00:06:44,340
integers and floating values

00:06:40,800 --> 00:06:46,919
and based on what I showed you this

00:06:44,340 --> 00:06:49,830
doesn't work and the reason is that the

00:06:46,919 --> 00:06:52,169
second one has an non-rational

00:06:49,830 --> 00:06:56,130
as the left operand of the multiply and

00:06:52,169 --> 00:06:58,530
when the on the previous slide noticed

00:06:56,130 --> 00:07:01,169
that these operators are all implemented

00:06:58,530 --> 00:07:03,569
as members which have an implied

00:07:01,169 --> 00:07:06,150
parameter this which is the left operand

00:07:03,569 --> 00:07:08,280
of those arithmetic operations the

00:07:06,150 --> 00:07:11,849
compiler will not employ those member

00:07:08,280 --> 00:07:15,210
functions when the arguments are an int

00:07:11,849 --> 00:07:16,830
and rational it won't do a conversion on

00:07:15,210 --> 00:07:19,229
the left operand and so this is the

00:07:16,830 --> 00:07:21,120
conventional reason for implementing

00:07:19,229 --> 00:07:24,270
these things as non-member functions

00:07:21,120 --> 00:07:27,360
rather than as members it's so that the

00:07:24,270 --> 00:07:30,150
compiler during overload resolution will

00:07:27,360 --> 00:07:33,090
try to do a conversion either on the

00:07:30,150 --> 00:07:35,069
left operand or on the right operator if

00:07:33,090 --> 00:07:36,419
it's if those operations are implemented

00:07:35,069 --> 00:07:40,199
as members it will only try the

00:07:36,419 --> 00:07:42,360
conversion on the right operand that's

00:07:40,199 --> 00:07:44,460
sort of like the canonical one of the

00:07:42,360 --> 00:07:48,030
canonical examples for why we would use

00:07:44,460 --> 00:07:49,590
non-member operators now the

00:07:48,030 --> 00:07:50,430
implementation is fairly simple and

00:07:49,590 --> 00:07:54,930
straightforward

00:07:50,430 --> 00:07:56,580
it's just return a rational rational

00:07:54,930 --> 00:07:57,930
constructed by multiplying the

00:07:56,580 --> 00:08:01,080
numerators and multiplying the

00:07:57,930 --> 00:08:03,780
denominators implementation is really

00:08:01,080 --> 00:08:06,509
pretty trivial but the little twist here

00:08:03,780 --> 00:08:10,289
is in this is now a non-member function

00:08:06,509 --> 00:08:13,680
and it's implemented by referring to

00:08:10,289 --> 00:08:17,960
private data in the class and that's an

00:08:13,680 --> 00:08:20,370
access problem so what do you do well

00:08:17,960 --> 00:08:23,310
one way to do it is to grant friendship

00:08:20,370 --> 00:08:25,770
this is what a lot of people think of as

00:08:23,310 --> 00:08:28,560
a legitimate use for friendship and it

00:08:25,770 --> 00:08:31,289
arguably is and now you can go ahead and

00:08:28,560 --> 00:08:34,050
implement all of the operators multiply

00:08:31,289 --> 00:08:36,990
divide add subtract as friend functions

00:08:34,050 --> 00:08:38,459
like this and the bodies are all just

00:08:36,990 --> 00:08:42,539
the straightforward operations that I

00:08:38,459 --> 00:08:44,670
just showed you now but there's a an

00:08:42,539 --> 00:08:47,040
arguably a better way to do this which

00:08:44,670 --> 00:08:50,040
is that one of the properties that you

00:08:47,040 --> 00:08:51,839
would expect based on your experience

00:08:50,040 --> 00:08:54,030
with the built-in types there is a

00:08:51,839 --> 00:08:57,090
relationship between the multiple

00:08:54,030 --> 00:08:59,070
and the multiply equals between ad and

00:08:57,090 --> 00:09:02,120
ad equals you would hope they would

00:08:59,070 --> 00:09:04,530
produce the same arithmetic result and

00:09:02,120 --> 00:09:05,700
during a code review that's one of the

00:09:04,530 --> 00:09:09,720
things that you might want to assure

00:09:05,700 --> 00:09:11,520
yourself of that hey if I use star

00:09:09,720 --> 00:09:13,650
equals or star I'm going to get the same

00:09:11,520 --> 00:09:15,750
result it's just delivered to me in a

00:09:13,650 --> 00:09:17,790
slightly different way but it's the same

00:09:15,750 --> 00:09:19,380
numerical result one of the ways to

00:09:17,790 --> 00:09:23,000
assure that is why don't you just

00:09:19,380 --> 00:09:25,680
implement one in terms of the other and

00:09:23,000 --> 00:09:27,480
it turns out to be very natural to do it

00:09:25,680 --> 00:09:31,800
this way to simply implement the

00:09:27,480 --> 00:09:37,320
non-member operators star by calling the

00:09:31,800 --> 00:09:40,020
star equals to do the math okay the the

00:09:37,320 --> 00:09:42,450
hitch in this particular packaging

00:09:40,020 --> 00:09:44,730
though is notice that the operands of

00:09:42,450 --> 00:09:50,280
the operator star are both passed by

00:09:44,730 --> 00:09:52,440
reference to Const and we do that where

00:09:50,280 --> 00:09:55,620
this is an example of using pass by

00:09:52,440 --> 00:09:58,980
reference to Const to mimic the behavior

00:09:55,620 --> 00:10:00,660
of pass by value and in this case the

00:09:58,980 --> 00:10:02,670
fact that the left operand is by

00:10:00,660 --> 00:10:04,589
reference to Const means that you can't

00:10:02,670 --> 00:10:08,010
use either the left or the right operand

00:10:04,589 --> 00:10:11,280
to accumulate the result you know if you

00:10:08,010 --> 00:10:13,170
say x times y you don't expect to change

00:10:11,280 --> 00:10:14,730
X and you don't expect to change Y you

00:10:13,170 --> 00:10:18,330
expect the answer to go somewhere else

00:10:14,730 --> 00:10:20,940
so you have to have a local object to

00:10:18,330 --> 00:10:23,520
hold that result and then you use the

00:10:20,940 --> 00:10:26,820
star equals operator there but in fact

00:10:23,520 --> 00:10:28,680
there's a clever way to avoid having to

00:10:26,820 --> 00:10:33,089
declare that local object and that is to

00:10:28,680 --> 00:10:36,330
do it this way like that it just cuts

00:10:33,089 --> 00:10:39,870
out a lot of code is that weird spacing

00:10:36,330 --> 00:10:41,640
there just so you can see the difference

00:10:39,870 --> 00:10:44,130
and the difference is on making the left

00:10:41,640 --> 00:10:46,260
operand passed by value so in it in

00:10:44,130 --> 00:10:48,270
effect is the local object that

00:10:46,260 --> 00:10:50,010
accumulates the result and because it's

00:10:48,270 --> 00:10:52,110
not declared constants just passed by

00:10:50,010 --> 00:10:54,120
value you can you still have the

00:10:52,110 --> 00:10:57,770
assurance that the actual call doesn't

00:10:54,120 --> 00:11:01,440
modify the left or the right operand and

00:10:57,770 --> 00:11:04,020
it just and I I didn't really examine

00:11:01,440 --> 00:11:05,910
this carefully but I suspect that modern

00:11:04,020 --> 00:11:07,470
compilers will do a pretty good job of

00:11:05,910 --> 00:11:09,930
optimizing both of these

00:11:07,470 --> 00:11:14,220
- the same thing but if one is going to

00:11:09,930 --> 00:11:19,260
win this one might be more conducive to

00:11:14,220 --> 00:11:23,820
optimization and this avoids granting

00:11:19,260 --> 00:11:25,500
friendship now in this particular case

00:11:23,820 --> 00:11:27,300
we have an obvious relationship between

00:11:25,500 --> 00:11:30,960
the multiply and the multiply equals

00:11:27,300 --> 00:11:33,840
operator that it's very natural to want

00:11:30,960 --> 00:11:35,880
to implement multiply in terms of

00:11:33,840 --> 00:11:38,670
multiplied equal and that's true for

00:11:35,880 --> 00:11:39,870
adds subtract divide it's not true for

00:11:38,670 --> 00:11:42,380
every one of the operators for example

00:11:39,870 --> 00:11:44,700
there isn't this relationship between

00:11:42,380 --> 00:11:49,680
greater than and greater than or equal

00:11:44,700 --> 00:11:51,480
to right it's not the same natural fit

00:11:49,680 --> 00:11:53,970
that one is obviously a member and the

00:11:51,480 --> 00:11:55,620
other one is not so in in the case of

00:11:53,970 --> 00:11:58,170
something like a greater than operator I

00:11:55,620 --> 00:12:00,000
don't it's not obvious that there's some

00:11:58,170 --> 00:12:02,040
member that you can call on you might

00:12:00,000 --> 00:12:05,370
just be inclined to just make the

00:12:02,040 --> 00:12:08,490
greater than a non-member and make it a

00:12:05,370 --> 00:12:11,790
friend and it accesses the numerator and

00:12:08,490 --> 00:12:13,640
denominator directly so in this case

00:12:11,790 --> 00:12:17,940
grant and friendship might be simpler

00:12:13,640 --> 00:12:20,490
here's the other sort of canonical

00:12:17,940 --> 00:12:22,110
example for why you use non-member

00:12:20,490 --> 00:12:24,000
functions instead of member functions

00:12:22,110 --> 00:12:27,570
and that is if I want to implement an

00:12:24,000 --> 00:12:29,850
output operator use the shift operator

00:12:27,570 --> 00:12:32,430
in the conventional way that it's used

00:12:29,850 --> 00:12:34,020
with the stream operations now in order

00:12:32,430 --> 00:12:36,420
to be able to output a rational number

00:12:34,020 --> 00:12:37,920
again you need access to the numerator

00:12:36,420 --> 00:12:41,070
and denominator you need to be able to

00:12:37,920 --> 00:12:42,990
display those and so it seems a blood

00:12:41,070 --> 00:12:46,050
first blush that what we want to do is

00:12:42,990 --> 00:12:49,950
declare the output operator as a member

00:12:46,050 --> 00:12:53,670
of the rational class now clearly we

00:12:49,950 --> 00:12:56,820
don't you will not be very popular if

00:12:53,670 --> 00:12:59,520
you go and start editing iostream to

00:12:56,820 --> 00:13:02,970
change the stream class to include a

00:12:59,520 --> 00:13:04,470
rational operator output operator that's

00:13:02,970 --> 00:13:07,050
not the way you go about it you go about

00:13:04,470 --> 00:13:10,500
doing it like augmenting the rational

00:13:07,050 --> 00:13:12,480
class to provide the output operation so

00:13:10,500 --> 00:13:14,610
you make it a member the problem is if

00:13:12,480 --> 00:13:17,010
it's a member of the class the rational

00:13:14,610 --> 00:13:19,590
number is going to be on the left and

00:13:17,010 --> 00:13:20,970
the stream will be on the right because

00:13:19,590 --> 00:13:24,269
once again that's

00:13:20,970 --> 00:13:26,970
where the expected placement of the

00:13:24,269 --> 00:13:29,519
class object is and a member function is

00:13:26,970 --> 00:13:32,040
it's on the left and this doesn't mesh

00:13:29,519 --> 00:13:34,589
well with all of the other stream

00:13:32,040 --> 00:13:37,740
operations where the stream is on the

00:13:34,589 --> 00:13:39,990
left so how do you fix that well that's

00:13:37,740 --> 00:13:43,670
another use for a non-member function

00:13:39,990 --> 00:13:46,709
now in this case the non-member function

00:13:43,670 --> 00:13:48,899
is not being used because we want to

00:13:46,709 --> 00:13:50,519
permit conversions on either the left or

00:13:48,899 --> 00:13:54,029
the right operator we just want to

00:13:50,519 --> 00:13:57,060
control the order in which we declared

00:13:54,029 --> 00:14:00,000
the arguments to the operator we want

00:13:57,060 --> 00:14:02,750
the stream to be on the Left if we make

00:14:00,000 --> 00:14:05,009
yet if we make the output operator a

00:14:02,750 --> 00:14:06,240
member of the rational number class

00:14:05,009 --> 00:14:07,529
we're going to wind up with a stream on

00:14:06,240 --> 00:14:12,779
the right and we don't have any choice

00:14:07,529 --> 00:14:15,329
this gives us a choice so you make it a

00:14:12,779 --> 00:14:17,189
non-member but it still needs access to

00:14:15,329 --> 00:14:19,829
the numerator and denominator of the

00:14:17,189 --> 00:14:25,019
rational number so it looks like it

00:14:19,829 --> 00:14:26,759
needs friendship right there's the

00:14:25,019 --> 00:14:32,550
implementation it needs to be a friend

00:14:26,759 --> 00:14:35,629
but a common idiom is to go ahead and

00:14:32,550 --> 00:14:40,470
declare a member function called put

00:14:35,629 --> 00:14:42,329
where you the invocation looks like the

00:14:40,470 --> 00:14:44,970
last line just before the curly brace

00:14:42,329 --> 00:14:47,550
where you say Oh F the output stream dot

00:14:44,970 --> 00:14:51,930
put rational number it doesn't look very

00:14:47,550 --> 00:14:55,620
pretty but it does the job well and then

00:14:51,930 --> 00:14:58,319
you implement the output operator is a

00:14:55,620 --> 00:15:03,420
as I describe it a paper-thin wrapper

00:14:58,319 --> 00:15:07,550
around a call on that not so attractive

00:15:03,420 --> 00:15:10,470
output operator the put function and

00:15:07,550 --> 00:15:13,050
again you always have to stop and think

00:15:10,470 --> 00:15:16,379
is it worth my while to create in a

00:15:13,050 --> 00:15:19,110
sense this member function that I'm not

00:15:16,379 --> 00:15:21,689
going to ask anybody to use and create

00:15:19,110 --> 00:15:23,069
it as a public member function just so

00:15:21,689 --> 00:15:25,220
that I don't have to grant friendship

00:15:23,069 --> 00:15:27,870
here that's a call that you have to make

00:15:25,220 --> 00:15:29,910
but one way that you can tip the balance

00:15:27,870 --> 00:15:32,579
in favor of that function is that

00:15:29,910 --> 00:15:34,970
sometimes you wind up implementing that

00:15:32,579 --> 00:15:37,370
put function as a member of a

00:15:34,970 --> 00:15:38,839
class and hierarchy you have a base in a

00:15:37,370 --> 00:15:40,490
derived class and you put the put

00:15:38,839 --> 00:15:42,800
function in the base class and make it a

00:15:40,490 --> 00:15:44,689
virtual function so that you can

00:15:42,800 --> 00:15:47,800
override it in the derived classes it

00:15:44,689 --> 00:15:51,279
then turns out that using this idiom

00:15:47,800 --> 00:15:53,569
actually gives the output operator

00:15:51,279 --> 00:15:55,879
polymorphic behavior if it's

00:15:53,569 --> 00:16:07,730
implementing in terms of a polymorphic

00:15:55,879 --> 00:16:09,889
put function oh yes that probably is yes

00:16:07,730 --> 00:16:14,360
that is a typo thank you for catching

00:16:09,889 --> 00:16:17,899
that let's let's just fix that just so

00:16:14,360 --> 00:16:21,019
that everybody sees clearly what it is

00:16:17,899 --> 00:16:24,019
think it's very nice to know you know in

00:16:21,019 --> 00:16:25,970
fact that that's a reason to plant typos

00:16:24,019 --> 00:16:28,610
is it's the way you can find out if

00:16:25,970 --> 00:16:30,250
people are actually listening to you and

00:16:28,610 --> 00:16:32,600
paying attention to what you're saying

00:16:30,250 --> 00:16:35,779
yes that's right so I did that on

00:16:32,600 --> 00:16:41,899
purpose thank you thank you very much

00:16:35,779 --> 00:16:44,990
okay alright so now I'm going to show

00:16:41,899 --> 00:16:48,620
you a slightly more elaborate example

00:16:44,990 --> 00:16:49,970
just to illustrate some of the issues

00:16:48,620 --> 00:16:52,639
that are involved so here is a

00:16:49,970 --> 00:16:54,860
rudimentary function that computes the

00:16:52,639 --> 00:16:58,639
mean for a collection of rational

00:16:54,860 --> 00:17:00,769
numbers in an array and so basically I'm

00:16:58,639 --> 00:17:03,709
just summing up all of the elements in

00:17:00,769 --> 00:17:06,520
the array using the plus equals operator

00:17:03,709 --> 00:17:09,260
from the class and when I get done I

00:17:06,520 --> 00:17:11,539
divide that sum by the number of

00:17:09,260 --> 00:17:15,370
elements in the collection and that

00:17:11,539 --> 00:17:15,370
should give me the arithmetic mean and

00:17:15,520 --> 00:17:22,689
were I to replace all those uses of

00:17:18,949 --> 00:17:25,760
rational with some built-in type like an

00:17:22,689 --> 00:17:28,339
integer type or a floating type the code

00:17:25,760 --> 00:17:30,470
would be the same and that's the triumph

00:17:28,339 --> 00:17:32,210
of operator overloading is that's what

00:17:30,470 --> 00:17:34,490
it's supposed to be able to do is give

00:17:32,210 --> 00:17:35,870
you those capabilities and once again I

00:17:34,490 --> 00:17:38,150
want to draw your attention to the fact

00:17:35,870 --> 00:17:42,289
that that return statement sum divided

00:17:38,150 --> 00:17:44,090
by divide equals n that's mixed type

00:17:42,289 --> 00:17:46,399
arithmetic you've got a rational on the

00:17:44,090 --> 00:17:50,120
left and an integer on the right the

00:17:46,399 --> 00:17:52,159
compiler silently invokes the converting

00:17:50,120 --> 00:17:53,659
constructor to make that work

00:17:52,159 --> 00:17:59,450
you can converting constructors are

00:17:53,659 --> 00:18:01,159
wonderful for this this purpose that's

00:17:59,450 --> 00:18:04,309
right if you declared the converting

00:18:01,159 --> 00:18:07,220
constructor explicit then you would have

00:18:04,309 --> 00:18:11,720
to explicitly write what is on that last

00:18:07,220 --> 00:18:15,770
line in the slide okay see because there

00:18:11,720 --> 00:18:17,750
are there are ample examples of classes

00:18:15,770 --> 00:18:19,940
which have an art a constructor that can

00:18:17,750 --> 00:18:22,580
be invoked with one argument where you

00:18:19,940 --> 00:18:24,950
don't want that implicit conversion it

00:18:22,580 --> 00:18:26,659
in fact any like it's not uncommon to

00:18:24,950 --> 00:18:28,669
find a container class where you can do

00:18:26,659 --> 00:18:32,419
something like say make me a container

00:18:28,669 --> 00:18:34,970
of initialized with an where n is the

00:18:32,419 --> 00:18:36,350
number of default constructed elements

00:18:34,970 --> 00:18:38,450
in the container you don't want that to

00:18:36,350 --> 00:18:43,880
be an implicit conversion from n into a

00:18:38,450 --> 00:18:45,890
container type things like that but in

00:18:43,880 --> 00:18:52,220
this particular case it works just well

00:18:45,890 --> 00:18:54,590
really well here's another example which

00:18:52,220 --> 00:18:57,200
is that in the return statement they are

00:18:54,590 --> 00:18:59,990
what I've got it this is computing the

00:18:57,200 --> 00:19:01,730
median of a presumably ordered

00:18:59,990 --> 00:19:03,590
collection of rational numbers so

00:19:01,730 --> 00:19:06,620
assuming the rationals are already in

00:19:03,590 --> 00:19:08,809
ascending or descending order if I want

00:19:06,620 --> 00:19:10,700
to compute the median value and the

00:19:08,809 --> 00:19:13,700
number of elements in the collection is

00:19:10,700 --> 00:19:15,799
even the way you do that is you add you

00:19:13,700 --> 00:19:17,960
compute the arithmetic mean of the two

00:19:15,799 --> 00:19:20,000
middle elements so that's what that's

00:19:17,960 --> 00:19:22,059
doing it's adding the two middle

00:19:20,000 --> 00:19:25,190
elements and then dividing by two

00:19:22,059 --> 00:19:28,399
once again it's mixed type arithmetic

00:19:25,190 --> 00:19:32,330
and so the compiler is going to

00:19:28,399 --> 00:19:35,510
implicitly convert that to that integer

00:19:32,330 --> 00:19:37,340
into a rational so that will use the

00:19:35,510 --> 00:19:40,100
operator divide that's the non-member

00:19:37,340 --> 00:19:44,770
function associated with the class and

00:19:40,100 --> 00:19:44,770
this is all very much expected behavior

00:19:50,710 --> 00:19:55,730
so once again here it is in more

00:19:53,000 --> 00:19:57,830
elaborate detail that if you write that

00:19:55,730 --> 00:20:00,860
the compiler is actually manufacturing a

00:19:57,830 --> 00:20:02,990
temporary object initialized with the

00:20:00,860 --> 00:20:06,830
sum of those two middle elements and

00:20:02,990 --> 00:20:10,460
then it's returning the result of that

00:20:06,830 --> 00:20:12,140
temporary / - okay now here's where it

00:20:10,460 --> 00:20:16,310
gets interesting is that rational

00:20:12,140 --> 00:20:18,950
numbers are a candidate a good candidate

00:20:16,310 --> 00:20:21,020
for turning into a template because it's

00:20:18,950 --> 00:20:23,090
easy to imagine that people are going to

00:20:21,020 --> 00:20:25,220
say I like what you've done there but I

00:20:23,090 --> 00:20:28,640
don't want to be obligated to do all my

00:20:25,220 --> 00:20:31,880
arithmetic as long precision and I have

00:20:28,640 --> 00:20:35,000
long long or something even bigger or if

00:20:31,880 --> 00:20:36,710
I need if I'm pressed for space maybe I

00:20:35,000 --> 00:20:38,420
want to represent it with less precision

00:20:36,710 --> 00:20:40,610
precision so we'll turn it into it and

00:20:38,420 --> 00:20:45,410
this is when all the conversion rules

00:20:40,610 --> 00:20:48,100
get really interesting so turning the

00:20:45,410 --> 00:20:50,480
rationale class into a template is not

00:20:48,100 --> 00:20:52,370
exceedingly there's a little bit of

00:20:50,480 --> 00:20:54,620
tedium involved in throwing template

00:20:52,370 --> 00:20:57,050
type name in all the right places and

00:20:54,620 --> 00:21:01,280
tracking down the use of long and

00:20:57,050 --> 00:21:05,180
replacing it with T like that it's not

00:21:01,280 --> 00:21:07,490
too much but just got to be careful and

00:21:05,180 --> 00:21:09,590
so here is a sketch of the rational

00:21:07,490 --> 00:21:12,350
class as a template and once again it's

00:21:09,590 --> 00:21:16,340
got an assortment of constructors it has

00:21:12,350 --> 00:21:18,590
the default defaulted copy operations

00:21:16,340 --> 00:21:20,990
and then it has the assortment of plus

00:21:18,590 --> 00:21:26,180
equals minus the assignment equals the

00:21:20,990 --> 00:21:28,790
up op equals functions and then in order

00:21:26,180 --> 00:21:32,000
to implement the non-member binary

00:21:28,790 --> 00:21:35,360
operations we're going to need a whole

00:21:32,000 --> 00:21:37,280
set of additional function templates see

00:21:35,360 --> 00:21:41,440
each one of these function templates is

00:21:37,280 --> 00:21:44,650
implementing plus and divide etcetera

00:21:41,440 --> 00:21:47,180
now you know this is this is outside the

00:21:44,650 --> 00:21:50,870
rational class itself because we want

00:21:47,180 --> 00:21:53,450
these operator pluses operator minus etc

00:21:50,870 --> 00:21:55,250
to be non-member functions once again

00:21:53,450 --> 00:21:57,140
because we want the conversions to apply

00:21:55,250 --> 00:22:01,410
on both either the left or the right

00:21:57,140 --> 00:22:02,540
operator and so but

00:22:01,410 --> 00:22:05,160
they don't have to be friends but

00:22:02,540 --> 00:22:10,770
they're good candidates for inlining as

00:22:05,160 --> 00:22:13,230
well maybe even Const expert and so

00:22:10,770 --> 00:22:15,600
having transformed our rational class

00:22:13,230 --> 00:22:17,040
into a class template things still hey

00:22:15,600 --> 00:22:19,680
it looks like things are humming along

00:22:17,040 --> 00:22:21,900
if it's behaving in the way we would

00:22:19,680 --> 00:22:24,750
like it to behave I can write R 1 equals

00:22:21,900 --> 00:22:29,100
R 2 plus R 3 and it compiles and

00:22:24,750 --> 00:22:32,310
produces credible results now let's go

00:22:29,100 --> 00:22:35,070
back and look at our functions that

00:22:32,310 --> 00:22:38,820
compute meaning do they still work well

00:22:35,070 --> 00:22:41,220
it turns out that this one it still

00:22:38,820 --> 00:22:43,560
works great with what we've done is

00:22:41,220 --> 00:22:48,240
we've turned mean into itself a function

00:22:43,560 --> 00:22:50,730
template where the the the type of the

00:22:48,240 --> 00:22:54,870
elements in the collection is now a

00:22:50,730 --> 00:22:56,640
parameterised type so that we could

00:22:54,870 --> 00:22:59,610
compute the mean of a collection of

00:22:56,640 --> 00:23:02,070
Ensor the mean of a collection of floats

00:22:59,610 --> 00:23:07,830
or the mean of a collection of rational

00:23:02,070 --> 00:23:10,830
numbers for some precision and it works

00:23:07,830 --> 00:23:15,210
so looks like everything is great until

00:23:10,830 --> 00:23:19,290
we get to here this one it turns out is

00:23:15,210 --> 00:23:21,450
a bump in the road and the bump occurs

00:23:19,290 --> 00:23:23,790
once again on that return expression

00:23:21,450 --> 00:23:26,040
which has mixed type arithmetic what

00:23:23,790 --> 00:23:28,560
we're doing is we're adding two in this

00:23:26,040 --> 00:23:31,110
case presumably you know by the way if

00:23:28,560 --> 00:23:33,210
we instantiate this function where type

00:23:31,110 --> 00:23:35,520
tia is a built-in type this is just

00:23:33,210 --> 00:23:37,020
works great and all those operators in

00:23:35,520 --> 00:23:39,750
there turn out to be invocations of the

00:23:37,020 --> 00:23:43,080
built-in operators but if we instantiate

00:23:39,750 --> 00:23:45,510
this type this function we invoke it for

00:23:43,080 --> 00:23:48,300
a type like a collection of rational

00:23:45,510 --> 00:23:52,980
Long's turns out the last line doesn't

00:23:48,300 --> 00:23:56,850
compile now that the compiler is unable

00:23:52,980 --> 00:23:59,100
to recognize what's going on and here's

00:23:56,850 --> 00:24:04,260
the details of what's going on is that

00:23:59,100 --> 00:24:07,400
in the case of the this expression we

00:24:04,260 --> 00:24:10,260
have two objects of the same type

00:24:07,400 --> 00:24:15,149
essentially a sum M minus 1 and a sum

00:24:10,260 --> 00:24:18,599
added together that is invoking one of

00:24:15,149 --> 00:24:22,219
the function templates the operator plus

00:24:18,599 --> 00:24:25,200
function template which takes two

00:24:22,219 --> 00:24:27,299
rational objects of type T this is an

00:24:25,200 --> 00:24:30,809
exact match and the compiler says cool

00:24:27,299 --> 00:24:34,830
like I can fund figure out that you're

00:24:30,809 --> 00:24:38,309
invoking that function template operator

00:24:34,830 --> 00:24:41,729
plus here but then it sees the divide

00:24:38,309 --> 00:24:46,679
and it and that's a rational of some

00:24:41,729 --> 00:24:49,440
type T divided by an int and whereas

00:24:46,679 --> 00:24:52,469
when we were not using a template the

00:24:49,440 --> 00:24:54,839
compiler is able to do that now that the

00:24:52,469 --> 00:24:57,320
type of those elements is the

00:24:54,839 --> 00:25:00,809
specialization of some rational type

00:24:57,320 --> 00:25:04,729
compiler gets lost it cannot recognize

00:25:00,809 --> 00:25:08,999
which divide operator were referring to

00:25:04,729 --> 00:25:10,469
and you can test that out by saying well

00:25:08,999 --> 00:25:13,159
maybe if I force it in the direction

00:25:10,469 --> 00:25:16,739
that I wanted to go I say not to but to

00:25:13,159 --> 00:25:19,349
explicitly converted to type T now the

00:25:16,739 --> 00:25:21,239
compiler says ah okay I can see how to

00:25:19,349 --> 00:25:27,029
do that and it does it and produces the

00:25:21,239 --> 00:25:29,159
expected result and it has to do with

00:25:27,029 --> 00:25:32,759
the difference between the overload

00:25:29,159 --> 00:25:36,359
resolution and template argument

00:25:32,759 --> 00:25:39,469
deduction is that the extent to which

00:25:36,359 --> 00:25:43,229
the compiler is willing to apply

00:25:39,469 --> 00:25:46,919
conversions to operands in order to find

00:25:43,229 --> 00:25:48,749
out to find a match when it comes to

00:25:46,919 --> 00:25:51,389
overload resolution where you're not

00:25:48,749 --> 00:25:53,460
dealing with templatized functions the

00:25:51,389 --> 00:25:55,499
compiler does not require that the

00:25:53,460 --> 00:25:59,039
arguments to an overloaded function be

00:25:55,499 --> 00:26:03,149
an exact match it will try a conversion

00:25:59,039 --> 00:26:05,519
sequence in order to to the operands in

00:26:03,149 --> 00:26:07,529
order to say can I if it's not an exact

00:26:05,519 --> 00:26:10,499
match can I convert this thing into

00:26:07,529 --> 00:26:12,239
something that will match and this is

00:26:10,499 --> 00:26:15,589
wellfest specified in a standard there

00:26:12,239 --> 00:26:17,719
are things known as these user built-ins

00:26:15,589 --> 00:26:20,489
conversion sequences and user defined

00:26:17,719 --> 00:26:22,469
conversion sequences and without getting

00:26:20,489 --> 00:26:24,299
too much into the details basically the

00:26:22,469 --> 00:26:26,909
compiler will try a sequence of up to

00:26:24,299 --> 00:26:28,160
three conversions in order to get from

00:26:26,909 --> 00:26:31,280
the argument type into the

00:26:28,160 --> 00:26:33,740
Amador type to make a match but when the

00:26:31,280 --> 00:26:35,450
compiler is saying oh I've recognized

00:26:33,740 --> 00:26:38,570
that you're trying to apply a template

00:26:35,450 --> 00:26:42,830
here all of a sudden it becomes really

00:26:38,570 --> 00:26:44,360
stingy about applying conversions to the

00:26:42,830 --> 00:26:47,690
arguments in order to make a match and

00:26:44,360 --> 00:26:50,390
that's what happened here was that it

00:26:47,690 --> 00:26:52,760
wasn't willing to apply automatically

00:26:50,390 --> 00:26:56,000
imply that that converting constructor

00:26:52,760 --> 00:26:59,330
in order to figure out ah if I convert

00:26:56,000 --> 00:27:03,070
that now I can do a template

00:26:59,330 --> 00:27:11,930
specialization of the appropriate

00:27:03,070 --> 00:27:13,880
operator and that is you know that's an

00:27:11,930 --> 00:27:16,910
unfortunate consequence having the

00:27:13,880 --> 00:27:19,550
template is really nice because it makes

00:27:16,910 --> 00:27:21,650
the rational class much more flexible in

00:27:19,550 --> 00:27:24,320
fact there's ample practice of this for

00:27:21,650 --> 00:27:27,650
example the standard libraries complex

00:27:24,320 --> 00:27:29,270
data type there's a template which you

00:27:27,650 --> 00:27:31,580
can specialized for different floating

00:27:29,270 --> 00:27:33,650
types well for rational it seems like

00:27:31,580 --> 00:27:36,650
that's what you want to do too but the

00:27:33,650 --> 00:27:38,480
downside is you lose some implicit

00:27:36,650 --> 00:27:41,660
conversions which seem like they're the

00:27:38,480 --> 00:27:48,050
natural thing to do if you lose a little

00:27:41,660 --> 00:27:51,980
usability so one way to do it is just

00:27:48,050 --> 00:27:54,050
take your lumps say okay it's a good

00:27:51,980 --> 00:27:55,610
trade-off as far as I'm concerned I like

00:27:54,050 --> 00:27:58,070
the flexibility of the rational number

00:27:55,610 --> 00:28:01,100
class as a template I'm willing to

00:27:58,070 --> 00:28:05,180
tolerate that I have to do an explicit

00:28:01,100 --> 00:28:07,160
conversion now and then but here's an

00:28:05,180 --> 00:28:09,920
alternative is that you could go ahead

00:28:07,160 --> 00:28:14,030
and say why don't I in addition to

00:28:09,920 --> 00:28:18,200
implementing a divide operator that

00:28:14,030 --> 00:28:20,420
takes two rationals of specialized for

00:28:18,200 --> 00:28:23,630
tight tea overload it with a couple

00:28:20,420 --> 00:28:25,790
other functions that will be more

00:28:23,630 --> 00:28:28,160
flexible in their matching notice the

00:28:25,790 --> 00:28:30,950
differences this is a template with a

00:28:28,160 --> 00:28:33,350
single type parameter T which is the

00:28:30,950 --> 00:28:36,590
precision type of both the left and the

00:28:33,350 --> 00:28:38,930
right rational number these two

00:28:36,590 --> 00:28:41,630
templates have two type parameters

00:28:38,930 --> 00:28:44,330
capital L and capital R

00:28:41,630 --> 00:28:47,480
and what they're doing is they are

00:28:44,330 --> 00:28:49,880
saying I'm going to give you a way to

00:28:47,480 --> 00:28:53,870
divide a rational by something that's

00:28:49,880 --> 00:28:57,429
not irrational or to divide something

00:28:53,870 --> 00:28:57,429
that's not irrational by a rational

00:28:57,490 --> 00:29:03,440
now the presumption is that whatever

00:29:01,250 --> 00:29:07,700
that the type of R is it's a type that's

00:29:03,440 --> 00:29:10,580
convertible to the type of rational of L

00:29:07,700 --> 00:29:12,260
for example and that if they're

00:29:10,580 --> 00:29:15,190
conversion doesn't exist you'll get a

00:29:12,260 --> 00:29:18,230
failure inside the template

00:29:15,190 --> 00:29:19,640
instantiation but on the presumption

00:29:18,230 --> 00:29:21,919
that that conversion exists

00:29:19,640 --> 00:29:26,240
turns out this works this will allow you

00:29:21,919 --> 00:29:28,549
to go ahead and write this original

00:29:26,240 --> 00:29:31,460
expression back they are the one that's

00:29:28,549 --> 00:29:34,539
marked at the top of the there you can

00:29:31,460 --> 00:29:38,409
do it but it causes an explosion of code

00:29:34,539 --> 00:29:40,850
you have to do essentially a trio of

00:29:38,409 --> 00:29:45,559
function templates for every one of your

00:29:40,850 --> 00:29:49,039
binary operators and it's it's tedious

00:29:45,559 --> 00:29:54,080
and error-prone not a really preferred

00:29:49,039 --> 00:29:58,760
solution to this problem it's not clear

00:29:54,080 --> 00:30:03,919
it's worth it so anyway by the way this

00:29:58,760 --> 00:30:07,760
I did all this work like 15 18 years ago

00:30:03,919 --> 00:30:10,159
I was a lot of this was inspired by it

00:30:07,760 --> 00:30:13,669
I do training for a living and I use

00:30:10,159 --> 00:30:17,090
this rational number class in some of my

00:30:13,669 --> 00:30:18,620
training materials to illustrate a lot

00:30:17,090 --> 00:30:19,490
of the principles which I was just

00:30:18,620 --> 00:30:22,940
talking about about how these

00:30:19,490 --> 00:30:25,360
conversions work and and how converting

00:30:22,940 --> 00:30:28,580
constructors play a role in all this and

00:30:25,360 --> 00:30:30,590
in my line of work because I am NOT I

00:30:28,580 --> 00:30:33,260
want to cater to my clients and my

00:30:30,590 --> 00:30:35,600
different clients will use different

00:30:33,260 --> 00:30:38,059
that's a can we use your examples with

00:30:35,600 --> 00:30:40,580
this compiler and I want the answer to

00:30:38,059 --> 00:30:44,090
be yes you know I don't want to come in

00:30:40,580 --> 00:30:46,909
and say you must use it it only works

00:30:44,090 --> 00:30:48,590
for the new compiler toolchain I haven't

00:30:46,909 --> 00:30:49,640
tested it with anything else that

00:30:48,590 --> 00:30:51,950
usually doesn't go over well

00:30:49,640 --> 00:30:53,559
commercially so I was pretty

00:30:51,950 --> 00:30:55,580
conscientious about testing this stuff

00:30:53,559 --> 00:30:57,170
and what I found at the

00:30:55,580 --> 00:30:58,910
was I was actually bopping back and

00:30:57,170 --> 00:31:01,790
forth between five different compilers

00:30:58,910 --> 00:31:04,730
and two of them were perfectly happy

00:31:01,790 --> 00:31:08,360
with the code that I just showed you the

00:31:04,730 --> 00:31:11,780
compiled linked and executed but then I

00:31:08,360 --> 00:31:13,790
was doing some work and found that two

00:31:11,780 --> 00:31:16,160
of them would accept the compiled but

00:31:13,790 --> 00:31:18,470
they failed to link and then there was

00:31:16,160 --> 00:31:21,380
one other that I'll get to shortly that

00:31:18,470 --> 00:31:24,440
was giving me interesting feedback which

00:31:21,380 --> 00:31:29,480
actually prompted the rest of this

00:31:24,440 --> 00:31:32,990
lecture and so here was the version that

00:31:29,480 --> 00:31:35,750
I was using in particular that triggered

00:31:32,990 --> 00:31:38,120
this analysis was so I have you know the

00:31:35,750 --> 00:31:40,490
rational constructors as before I have

00:31:38,120 --> 00:31:45,440
the member plus equals minus equals and

00:31:40,490 --> 00:31:47,780
I had implemented all of the non-member

00:31:45,440 --> 00:31:50,030
operators plus minus times and divide as

00:31:47,780 --> 00:31:51,200
separate templates and I hadn't

00:31:50,030 --> 00:31:52,910
implemented the trio

00:31:51,200 --> 00:31:55,220
I just implemented one function which

00:31:52,910 --> 00:31:57,020
takes two rationals and I was explicit I

00:31:55,220 --> 00:32:00,860
was living with the fact that we had to

00:31:57,020 --> 00:32:03,380
do the explicit conversion sometimes but

00:32:00,860 --> 00:32:05,360
in this version I also had an operator

00:32:03,380 --> 00:32:07,160
greater than which allowed me to compare

00:32:05,360 --> 00:32:09,410
one rational greater than another

00:32:07,160 --> 00:32:11,780
rational and I also had the output

00:32:09,410 --> 00:32:15,290
operator and those two functions were

00:32:11,780 --> 00:32:18,650
not implemented as non-member they were

00:32:15,290 --> 00:32:20,780
implemented as non-member friends that

00:32:18,650 --> 00:32:23,000
had direct access to the data members

00:32:20,780 --> 00:32:25,850
they weren't implemented the way plus

00:32:23,000 --> 00:32:31,670
was through the intermediary of plus

00:32:25,850 --> 00:32:33,500
equals and I did that and I compilers

00:32:31,670 --> 00:32:35,090
were all over the map as to whether or

00:32:33,500 --> 00:32:38,300
not they were willing to accept this

00:32:35,090 --> 00:32:42,170
some did some gave link errors it turned

00:32:38,300 --> 00:32:45,530
out that one gave me a compiler which

00:32:42,170 --> 00:32:47,660
I'll show you in just a moment so anyway

00:32:45,530 --> 00:32:50,390
the curious what really piqued my

00:32:47,660 --> 00:32:51,770
interest at first was that the ones that

00:32:50,390 --> 00:32:54,020
were telling me that there were link

00:32:51,770 --> 00:32:56,300
errors you know there it is there's the

00:32:54,020 --> 00:33:00,590
friend declaration for operator greater

00:32:56,300 --> 00:33:02,990
than and right there in the same header

00:33:00,590 --> 00:33:04,880
file right below it was the template

00:33:02,990 --> 00:33:08,060
operator greater than that takes two

00:33:04,880 --> 00:33:09,080
rationals of type T see that one takes

00:33:08,060 --> 00:33:12,020
two rationals

00:33:09,080 --> 00:33:15,740
and this one this operator greater then

00:33:12,020 --> 00:33:20,180
takes two rationals what's your problem

00:33:15,740 --> 00:33:22,040
come later it's right there same thing

00:33:20,180 --> 00:33:27,350
with the output operator getting the

00:33:22,040 --> 00:33:29,270
same link errors now just by way of

00:33:27,350 --> 00:33:32,060
background before I do any further

00:33:29,270 --> 00:33:34,970
analysis I just want to point out that

00:33:32,060 --> 00:33:37,550
there's a little syntactic quirk in C++

00:33:34,970 --> 00:33:41,230
which is that when you're inside the

00:33:37,550 --> 00:33:43,730
body of a class template like rational T

00:33:41,230 --> 00:33:47,150
you can mention either rational or

00:33:43,730 --> 00:33:50,750
rational angle bracket T and either of

00:33:47,150 --> 00:33:55,310
those will work in other words this is

00:33:50,750 --> 00:33:58,070
the same as this and if you wish you can

00:33:55,310 --> 00:34:00,560
toss a coin on every usage and randomly

00:33:58,070 --> 00:34:03,740
leave out the T's or add them at your

00:34:00,560 --> 00:34:09,310
wish and and upset your colleagues in a

00:34:03,740 --> 00:34:09,310
code review but these are equivalent

00:34:09,399 --> 00:34:14,060
okay so with that little bit of

00:34:11,840 --> 00:34:17,840
background here's what I thought was

00:34:14,060 --> 00:34:19,790
happening before I knew better is that

00:34:17,840 --> 00:34:23,840
when I wrote the friend declaration for

00:34:19,790 --> 00:34:26,960
the output operator that since this

00:34:23,840 --> 00:34:29,000
friend declaration appeared inside the

00:34:26,960 --> 00:34:32,149
scope of the rational class template

00:34:29,000 --> 00:34:36,320
that occurrence of rational right there

00:34:32,149 --> 00:34:38,510
was as if I had written rational T in

00:34:36,320 --> 00:34:43,070
other words that if I instantiate

00:34:38,510 --> 00:34:44,750
rational int I was granting friendship

00:34:43,070 --> 00:34:48,260
to an output operator took that also

00:34:44,750 --> 00:34:51,380
took a rational int that's what I

00:34:48,260 --> 00:34:56,540
thought would happen and similarly since

00:34:51,380 --> 00:35:00,920
oh and the other the other issue was

00:34:56,540 --> 00:35:05,210
that when I declared the output operator

00:35:00,920 --> 00:35:07,910
as a non-member function template since

00:35:05,210 --> 00:35:13,400
this was not inside the scope of the

00:35:07,910 --> 00:35:15,230
class rational T the T there in the

00:35:13,400 --> 00:35:18,610
argument in the parameter list was not

00:35:15,230 --> 00:35:18,610
an optional T

00:35:19,560 --> 00:35:24,340
okaythat's and it turns out I was I had

00:35:22,630 --> 00:35:27,220
a misunderstanding of what was going on

00:35:24,340 --> 00:35:29,440
and let me show you what is really

00:35:27,220 --> 00:35:31,420
happening and and the here's here's the

00:35:29,440 --> 00:35:33,760
hint that I got is that the good new

00:35:31,420 --> 00:35:36,010
compiler was the one that would not

00:35:33,760 --> 00:35:39,250
compile my code it rejected it with this

00:35:36,010 --> 00:35:41,170
error message and it said friend

00:35:39,250 --> 00:35:44,320
declaration declares a non template

00:35:41,170 --> 00:35:46,810
function and then by the way this is

00:35:44,320 --> 00:35:49,020
literally what the error said okay I'm

00:35:46,810 --> 00:35:51,580
not making it up it and then that long

00:35:49,020 --> 00:35:55,450
parenthetical remark and I think it's

00:35:51,580 --> 00:35:57,850
kind of hard to read so actually what I

00:35:55,450 --> 00:36:00,100
should say is it didn't give me an error

00:35:57,850 --> 00:36:02,680
that was a warning yeah it was a warning

00:36:00,100 --> 00:36:04,840
so I broken it up onto bulleted points

00:36:02,680 --> 00:36:07,120
to make it a little easier to read that

00:36:04,840 --> 00:36:10,360
same thing let's read it carefully it

00:36:07,120 --> 00:36:12,280
says it was complaining on both the

00:36:10,360 --> 00:36:14,530
friend declaration for the greater-than

00:36:12,280 --> 00:36:17,320
and the friend declaration for the

00:36:14,530 --> 00:36:19,840
output operator inside the scope of the

00:36:17,320 --> 00:36:22,630
class and it said the friend declaration

00:36:19,840 --> 00:36:24,910
declares a non template function it was

00:36:22,630 --> 00:36:27,760
saying that both of the C conceptually

00:36:24,910 --> 00:36:30,850
what I was expecting was I have this

00:36:27,760 --> 00:36:33,160
class template rational T every time I

00:36:30,850 --> 00:36:35,770
instantiate rational into rational long

00:36:33,160 --> 00:36:37,690
or rational long long I should get a

00:36:35,770 --> 00:36:38,980
greater than operator that operates on

00:36:37,690 --> 00:36:42,730
that type I should get an output

00:36:38,980 --> 00:36:45,040
operator that operates on that type and

00:36:42,730 --> 00:36:47,500
it was telling me but that thing itself

00:36:45,040 --> 00:36:49,900
those greater than operators and those

00:36:47,500 --> 00:36:53,260
output operators they weren't templates

00:36:49,900 --> 00:36:56,310
they're non template functions and it

00:36:53,260 --> 00:36:58,720
said if this is not what you intended

00:36:56,310 --> 00:37:00,220
then make sure that the function

00:36:58,720 --> 00:37:01,990
template has already you know in other

00:37:00,220 --> 00:37:04,660
words if I intended them to be templates

00:37:01,990 --> 00:37:05,890
and not non templates then what I should

00:37:04,660 --> 00:37:08,700
have done was made sure that they were

00:37:05,890 --> 00:37:12,610
previously declared as templates and

00:37:08,700 --> 00:37:14,320
make sure I use the angle brackets in

00:37:12,610 --> 00:37:18,760
the function name of the friend

00:37:14,320 --> 00:37:20,620
declarations which I didn't do so by the

00:37:18,760 --> 00:37:22,690
way I checked the C++ standard and I

00:37:20,620 --> 00:37:24,730
actually found hey good new wasn't

00:37:22,690 --> 00:37:28,330
making this up it's actually in the

00:37:24,730 --> 00:37:30,220
language and they this example I've

00:37:28,330 --> 00:37:32,440
reformatted a little bit to make it a

00:37:30,220 --> 00:37:32,920
little easier to read but this comes

00:37:32,440 --> 00:37:37,060
right out

00:37:32,920 --> 00:37:39,940
the C++ standard it's still there and so

00:37:37,060 --> 00:37:43,330
what we have is at the bottom a class

00:37:39,940 --> 00:37:45,730
template called task and notice that it

00:37:43,330 --> 00:37:47,800
has two friend declarations in it the

00:37:45,730 --> 00:37:49,660
first of those friend declarations is

00:37:47,800 --> 00:37:51,850
for something called process and the

00:37:49,660 --> 00:37:55,750
second one is called preempt angle

00:37:51,850 --> 00:37:59,710
bracket and T and what it's saying is

00:37:55,750 --> 00:38:02,470
that tat the second friend declaration

00:37:59,710 --> 00:38:04,960
is actually granting friendship to the

00:38:02,470 --> 00:38:06,640
specialization of a template and it and

00:38:04,960 --> 00:38:09,700
it comes to that conclusion because of

00:38:06,640 --> 00:38:13,990
the presence of the angle bracketed T in

00:38:09,700 --> 00:38:15,910
the name after the name pre out but if

00:38:13,990 --> 00:38:18,610
you compare that with the treatment of

00:38:15,910 --> 00:38:22,540
process process doesn't have the angle

00:38:18,610 --> 00:38:24,670
bracketed take and so what happens is

00:38:22,540 --> 00:38:28,270
each time you instantiate tasks with a

00:38:24,670 --> 00:38:30,700
different argument type it grants

00:38:28,270 --> 00:38:33,490
friendship to a function called process

00:38:30,700 --> 00:38:35,860
which happens to take a pointer to a

00:38:33,490 --> 00:38:40,780
task of the right type but that process

00:38:35,860 --> 00:38:42,190
function itself is not a template that's

00:38:40,780 --> 00:38:43,450
right in other words I granted

00:38:42,190 --> 00:38:47,340
friendship to something that wasn't

00:38:43,450 --> 00:38:58,180
defined anywhere that's what's happening

00:38:47,340 --> 00:39:00,580
kind of curious so yeah so what happened

00:38:58,180 --> 00:39:02,560
was that friend right right there that

00:39:00,580 --> 00:39:04,360
opera at that output operator was not a

00:39:02,560 --> 00:39:07,210
template it was granting friendship to a

00:39:04,360 --> 00:39:09,160
function that wasn't too fine so what

00:39:07,210 --> 00:39:10,660
what this is being more explicit about

00:39:09,160 --> 00:39:16,060
it so if you were to instantiate

00:39:10,660 --> 00:39:18,160
rational with type int then that class

00:39:16,060 --> 00:39:19,810
template instantiation would be granting

00:39:18,160 --> 00:39:22,240
friendship to an output operator that

00:39:19,810 --> 00:39:24,700
takes a rational int and again if you

00:39:22,240 --> 00:39:26,110
instantiate it with you in 6040 it

00:39:24,700 --> 00:39:28,000
grants friendship to that but neither

00:39:26,110 --> 00:39:37,450
are those output operators as a template

00:39:28,000 --> 00:39:41,760
oh you want to go back is they you're

00:39:37,450 --> 00:39:41,760
talking about this the fact that yes

00:39:43,370 --> 00:39:48,120
it's it's a trap yeah it's a syntactic

00:39:46,290 --> 00:39:49,520
trap that you could fall into if that's

00:39:48,120 --> 00:39:54,810
what you're suggesting

00:39:49,520 --> 00:39:56,880
yeah yeah but by the way I didn't

00:39:54,810 --> 00:39:59,160
mention but I'll come I'll say here that

00:39:56,880 --> 00:40:01,650
I prefer to do it that way I leave it

00:39:59,160 --> 00:40:08,670
out I think it's less cluttered and it's

00:40:01,650 --> 00:40:10,320
it's clearer it well no it's the special

00:40:08,670 --> 00:40:15,000
case of the friends which let me just

00:40:10,320 --> 00:40:22,740
let's work through these friends see so

00:40:15,000 --> 00:40:24,750
what here's what I think that yes so so

00:40:22,740 --> 00:40:26,610
this is now what where we are from the

00:40:24,750 --> 00:40:29,310
users perspective with what I've given

00:40:26,610 --> 00:40:31,320
you which is as a user I want to be able

00:40:29,310 --> 00:40:33,360
to use the rational class template and

00:40:31,320 --> 00:40:35,730
instantiate it for some type like int

00:40:33,360 --> 00:40:37,290
there just create an object are of type

00:40:35,730 --> 00:40:41,610
rational and I want to be able to write

00:40:37,290 --> 00:40:44,730
it out the problem is that when I

00:40:41,610 --> 00:40:47,910
instantiate rational with type int as

00:40:44,730 --> 00:40:49,710
its type argument it it will grant

00:40:47,910 --> 00:40:51,270
friendship to a function that's an

00:40:49,710 --> 00:40:53,940
output operator that takes a rational

00:40:51,270 --> 00:40:57,720
int but it never produced a definition

00:40:53,940 --> 00:41:00,330
for it and so what happens is I then

00:40:57,720 --> 00:41:02,160
become responsible to implement that

00:41:00,330 --> 00:41:07,440
output operator if I want like code to

00:41:02,160 --> 00:41:10,380
link and and and this is what's known as

00:41:07,440 --> 00:41:13,350
an unfriendly user interface right I

00:41:10,380 --> 00:41:15,060
just you would not use this class if

00:41:13,350 --> 00:41:16,920
this was your responsibility to

00:41:15,060 --> 00:41:18,480
implement those functions you expect

00:41:16,920 --> 00:41:24,060
them to be generated somehow by the

00:41:18,480 --> 00:41:25,950
template so so following the error

00:41:24,060 --> 00:41:27,960
message or the warning that I got from

00:41:25,950 --> 00:41:32,280
the gnu compiler i said okay let's try

00:41:27,960 --> 00:41:34,800
this it looks like what you want me to

00:41:32,280 --> 00:41:36,720
do you being the Ganu compiler is throw

00:41:34,800 --> 00:41:41,120
those ankle bracketed t's in there so

00:41:36,720 --> 00:41:41,120
that i'm granting friendship to

00:41:41,390 --> 00:41:45,750
specializations of those functions in

00:41:44,700 --> 00:41:47,460
other words i'm assuming that the

00:41:45,750 --> 00:41:49,260
greater than operator and the shift

00:41:47,460 --> 00:41:51,720
operator are themselves function

00:41:49,260 --> 00:41:54,030
templates and that somehow another day

00:41:51,720 --> 00:41:57,760
will be instantiated upon you

00:41:54,030 --> 00:42:01,410
right makes sense okay by the way just

00:41:57,760 --> 00:42:03,880
as a lexical issue the spacing there is

00:42:01,410 --> 00:42:06,670
you don't need it so you get these

00:42:03,880 --> 00:42:09,640
curious looking things like the bowtie

00:42:06,670 --> 00:42:11,830
operator or the few turn it sideways

00:42:09,640 --> 00:42:17,470
it's a sergeant this three chevrons for

00:42:11,830 --> 00:42:19,150
a sergeant now here this was adding to

00:42:17,470 --> 00:42:22,510
the puzzlement by weight you know I was

00:42:19,150 --> 00:42:24,460
doing this quite some years ago and this

00:42:22,510 --> 00:42:26,830
stuff has since been fixed but it's it

00:42:24,460 --> 00:42:31,660
was interesting to me to see how this

00:42:26,830 --> 00:42:33,670
chain of quirks among the compilers

00:42:31,660 --> 00:42:35,440
ultimately led me to a solution that

00:42:33,670 --> 00:42:38,620
actually still works and holds up well

00:42:35,440 --> 00:42:40,240
which is that the genuki pilar accepted

00:42:38,620 --> 00:42:42,370
it just i just put in those angle

00:42:40,240 --> 00:42:43,840
bracket and T's and it said I'm cool

00:42:42,370 --> 00:42:46,690
with that it compiled and linked the

00:42:43,840 --> 00:42:49,620
code and I step back and said hold it a

00:42:46,690 --> 00:42:54,070
second that shouldn't have compiled

00:42:49,620 --> 00:42:58,000
because in order for the the compiler to

00:42:54,070 --> 00:43:01,590
recognize for example greater than as a

00:42:58,000 --> 00:43:03,820
template you have to declare angle

00:43:01,590 --> 00:43:06,970
operator greater than as a template

00:43:03,820 --> 00:43:09,130
first in other words this is just using

00:43:06,970 --> 00:43:10,870
the name putting angle brackets and a T

00:43:09,130 --> 00:43:12,700
after it and saying treat it like it's a

00:43:10,870 --> 00:43:15,520
template it was never declared as such

00:43:12,700 --> 00:43:18,430
and in fact the air the warning that

00:43:15,520 --> 00:43:19,810
came from g plus plus said make sure the

00:43:18,430 --> 00:43:21,550
function template has already been

00:43:19,810 --> 00:43:25,480
declared and add the angle brackets

00:43:21,550 --> 00:43:27,640
after the function name and despite the

00:43:25,480 --> 00:43:32,770
warning the good new compiler compiled

00:43:27,640 --> 00:43:35,050
it anyway said this is what i think they

00:43:32,770 --> 00:43:36,730
were telling me to do is if i want the

00:43:35,050 --> 00:43:38,560
angle bracket on the operator greater

00:43:36,730 --> 00:43:41,830
than i have to proceed the whole class

00:43:38,560 --> 00:43:45,430
definition with a declaration of the

00:43:41,830 --> 00:43:47,020
function template right i have to

00:43:45,430 --> 00:43:52,750
announce the greater than is a template

00:43:47,020 --> 00:43:55,330
before i use it as such okay but now

00:43:52,750 --> 00:43:57,670
look at the part in in the teal or green

00:43:55,330 --> 00:43:59,910
whatever you want to call that that is

00:43:57,670 --> 00:44:05,670
referring to rationale angle bracket t

00:43:59,910 --> 00:44:05,670
before it was declared as a template

00:44:06,040 --> 00:44:13,540
how do what do we do well it turns out

00:44:07,990 --> 00:44:15,120
you need to precede the declaration of

00:44:13,540 --> 00:44:17,320
the operator you greater than by a

00:44:15,120 --> 00:44:19,360
declaration not a definition of the

00:44:17,320 --> 00:44:21,430
class template and so when you're all

00:44:19,360 --> 00:44:24,370
done you have to have to have that chain

00:44:21,430 --> 00:44:25,900
of declarations and that operator

00:44:24,370 --> 00:44:28,420
greater than in the middle is a

00:44:25,900 --> 00:44:30,730
placeholder for every one of the front

00:44:28,420 --> 00:44:32,260
the functions that is a function

00:44:30,730 --> 00:44:37,630
template that you're granting friendship

00:44:32,260 --> 00:44:40,090
to right so you know if you want this to

00:44:37,630 --> 00:44:44,050
work this way you got to get all these

00:44:40,090 --> 00:44:50,680
pieces in place kind of hard hard to do

00:44:44,050 --> 00:44:53,170
it's kind of tedious okay by the way so

00:44:50,680 --> 00:44:54,460
at this point I went back and I said

00:44:53,170 --> 00:44:56,620
okay let's check this with all of my

00:44:54,460 --> 00:44:58,090
compilers and four out of five ain't bad

00:44:56,620 --> 00:45:02,260
but it turned out the fifth one was

00:44:58,090 --> 00:45:04,180
Visual Studio and I was not prepared to

00:45:02,260 --> 00:45:06,160
say oh you know just tell my clients you

00:45:04,180 --> 00:45:08,880
can't use that tool with my examples

00:45:06,160 --> 00:45:11,980
that's just not gonna go over well and

00:45:08,880 --> 00:45:14,170
Microsoft their compiler at the time

00:45:11,980 --> 00:45:16,540
looked at that angle bracket and T

00:45:14,170 --> 00:45:17,800
Theron they said whatever that I don't

00:45:16,540 --> 00:45:21,850
know what that is whatever it is that's

00:45:17,800 --> 00:45:25,330
a syntax error it just wouldn't accept

00:45:21,850 --> 00:45:29,530
that at that spot and I said oh what do

00:45:25,330 --> 00:45:31,600
I do and I had a flashback it took me a

00:45:29,530 --> 00:45:33,910
little while but I remembered that you

00:45:31,600 --> 00:45:36,280
know this was I was doing this work in

00:45:33,910 --> 00:45:39,670
the late 90s early part of the

00:45:36,280 --> 00:45:41,500
millennium and compilers were still not

00:45:39,670 --> 00:45:47,710
in agreement about a lot of these corner

00:45:41,500 --> 00:45:49,900
cases and so and I remembered that early

00:45:47,710 --> 00:45:52,360
versions of the Microsoft compiler had

00:45:49,900 --> 00:45:56,560
this as a chronic problem the inability

00:45:52,360 --> 00:45:58,420
to associate a friend function with a

00:45:56,560 --> 00:46:01,660
definition that appeared outside the

00:45:58,420 --> 00:46:04,120
class and I almost invariably solved the

00:46:01,660 --> 00:46:05,980
problem by saying oh just take the

00:46:04,120 --> 00:46:08,710
function definition and put it in the

00:46:05,980 --> 00:46:10,720
class now the declaration of the

00:46:08,710 --> 00:46:13,240
definition are all in the same spot and

00:46:10,720 --> 00:46:15,550
it turned out that the compiler wasn't

00:46:13,240 --> 00:46:17,260
confused anymore you didn't have to

00:46:15,550 --> 00:46:19,290
struggle to match up the declaration

00:46:17,260 --> 00:46:23,880
with the definition

00:46:19,290 --> 00:46:25,560
so I refer to this this is not a widely

00:46:23,880 --> 00:46:27,540
accepted term but I think it's a useful

00:46:25,560 --> 00:46:31,110
term is you know there are two ways that

00:46:27,540 --> 00:46:33,120
you can it have a function have the

00:46:31,110 --> 00:46:35,430
attribute of being in line a class

00:46:33,120 --> 00:46:36,750
member function one is to explicitly

00:46:35,430 --> 00:46:38,760
declare it with the keyword in line the

00:46:36,750 --> 00:46:41,130
other one is to place its definition

00:46:38,760 --> 00:46:42,600
inside the class and people will say

00:46:41,130 --> 00:46:43,920
well that's an in line definition but

00:46:42,600 --> 00:46:46,590
how do you distinguish that from one

00:46:43,920 --> 00:46:48,810
that uses the keyword in line and I pros

00:46:46,590 --> 00:46:51,990
the Latin phrase in situ meaning in

00:46:48,810 --> 00:47:00,570
place or in position and so this is an

00:46:51,990 --> 00:47:02,760
in situ definition yes yes is that is

00:47:00,570 --> 00:47:05,310
that how you like to refer to it or you

00:47:02,760 --> 00:47:25,890
just made that one up a friend with

00:47:05,310 --> 00:47:28,640
benefits okay I'm sorry run that by me

00:47:25,890 --> 00:47:28,640
one more time please

00:47:36,240 --> 00:47:44,610
how is that different from what I have

00:47:37,950 --> 00:47:46,170
done here oh oh yeah actually you use

00:47:44,610 --> 00:47:52,170
the word templating you actually make a

00:47:46,170 --> 00:47:55,500
member template yeah I haven't tried

00:47:52,170 --> 00:47:57,060
that so I haven't I can't say off the

00:47:55,500 --> 00:48:00,390
top my head but why would if it's a

00:47:57,060 --> 00:48:02,130
member template why would you all

00:48:00,390 --> 00:48:04,140
putting you're talking about putting a

00:48:02,130 --> 00:48:06,600
member template definition physically

00:48:04,140 --> 00:48:11,100
inside I think you can I think the

00:48:06,600 --> 00:48:14,190
syntax permits that yeah but what what I

00:48:11,100 --> 00:48:16,230
in this case I didn't need it to be a

00:48:14,190 --> 00:48:20,010
member template it turns out that just

00:48:16,230 --> 00:48:24,420
making it a friend function defined

00:48:20,010 --> 00:48:28,500
inside its class worked in other words

00:48:24,420 --> 00:48:30,960
the effect of this is that you know said

00:48:28,500 --> 00:48:34,469
this compiled link but what's going on

00:48:30,960 --> 00:48:37,589
let's actually look at this is that

00:48:34,469 --> 00:48:39,869
that when you place not just the

00:48:37,589 --> 00:48:42,869
Declaration but the definition of a

00:48:39,869 --> 00:48:44,489
friend function that itself is not a

00:48:42,869 --> 00:48:46,829
template but you place it inside a

00:48:44,489 --> 00:48:49,199
template like that every time you

00:48:46,829 --> 00:48:50,539
instantiate the class rationale for a

00:48:49,199 --> 00:48:53,309
different type

00:48:50,539 --> 00:48:55,140
it not only grants friendship to a

00:48:53,309 --> 00:48:58,189
function but it manufactures the

00:48:55,140 --> 00:49:00,659
function that is granting friendship to

00:48:58,189 --> 00:49:02,489
that's where this idiom gets its name

00:49:00,659 --> 00:49:04,949
that's you're actually the class

00:49:02,489 --> 00:49:10,319
template instantiation is making its own

00:49:04,949 --> 00:49:14,699
friend and that function though itself

00:49:10,319 --> 00:49:17,939
is not a template it's a non template

00:49:14,699 --> 00:49:19,199
function that is manufactured as a

00:49:17,939 --> 00:49:23,459
side-effect of the template

00:49:19,199 --> 00:49:25,769
instantiation which is as good as it

00:49:23,459 --> 00:49:27,659
being a template in fact as you'll see

00:49:25,769 --> 00:49:36,749
in just a moment it's actually better

00:49:27,659 --> 00:49:40,859
than if it were a template well yeah I

00:49:36,749 --> 00:49:42,479
called it a it's that this is something

00:49:40,859 --> 00:49:44,239
that you do often but it doesn't

00:49:42,479 --> 00:49:52,979
leverage itself to a lot of other

00:49:44,239 --> 00:50:04,880
different use cases it's almost yeah

00:49:52,979 --> 00:50:07,499
that's right yeah so if you're taking

00:50:04,880 --> 00:50:10,489
issue with my having call this a corner

00:50:07,499 --> 00:50:13,289
case I'll I'll easily relent on that

00:50:10,489 --> 00:50:21,079
okay there the judgment of how widely

00:50:13,289 --> 00:50:21,079
you use this this is a real thing

00:50:27,460 --> 00:50:31,840
take the definition this operator and

00:50:34,150 --> 00:50:38,540
you want to just put a declaration for

00:50:37,010 --> 00:50:41,120
the operator greater than here but not

00:50:38,540 --> 00:50:44,150
the definition the problem is if the

00:50:41,120 --> 00:50:46,730
definition isn't here it grants funk

00:50:44,150 --> 00:50:49,120
friendship to a function which is not

00:50:46,730 --> 00:50:51,320
automatically manufactured the

00:50:49,120 --> 00:50:54,470
responsibility of manufacturing that

00:50:51,320 --> 00:50:56,900
definition falls on the user of the

00:50:54,470 --> 00:50:59,780
rational class not the author of the

00:50:56,900 --> 00:51:03,470
class and that's where the usability

00:50:59,780 --> 00:51:06,230
issue comes in but by putting the

00:51:03,470 --> 00:51:07,760
definition in the class you not only get

00:51:06,230 --> 00:51:09,850
the granting of friendship but you get

00:51:07,760 --> 00:51:19,490
the manufacturing of the function that

00:51:09,850 --> 00:51:21,140
you want to grant friendship to will

00:51:19,490 --> 00:51:22,820
actually hold that thought just I have

00:51:21,140 --> 00:51:27,980
some examples that I think will address

00:51:22,820 --> 00:51:29,780
your concern you're doing it but yeah I

00:51:27,980 --> 00:51:32,000
think people do this but they don't

00:51:29,780 --> 00:51:34,870
realize what's what's happening it's the

00:51:32,000 --> 00:51:37,880
back story that's interesting here they

00:51:34,870 --> 00:51:42,500
it doesn't compile that's right thank

00:51:37,880 --> 00:51:44,780
you okay by the way there's a book by

00:51:42,500 --> 00:51:48,220
Barton & Nachman engineering and

00:51:44,780 --> 00:51:51,850
scientific programming in C++ it was a

00:51:48,220 --> 00:51:54,920
popular book back in the late 90s and

00:51:51,850 --> 00:51:56,540
after I did all this work and I gave a

00:51:54,920 --> 00:51:59,000
talk on this many years ago somebody

00:51:56,540 --> 00:52:02,030
came up and I own a copy of Barton

00:51:59,000 --> 00:52:03,620
enactment and I didn't notice that they

00:52:02,030 --> 00:52:07,970
were used I hadn't read the whole book

00:52:03,620 --> 00:52:09,560
and if you look through the book they

00:52:07,970 --> 00:52:11,870
never mentioned there's nothing in the

00:52:09,560 --> 00:52:13,250
index that points out this technique

00:52:11,870 --> 00:52:14,930
they just sort of in one of their

00:52:13,250 --> 00:52:18,470
examples they just threw it in without

00:52:14,930 --> 00:52:22,130
comment as if you know what else do you

00:52:18,470 --> 00:52:24,560
do without appreciating its significance

00:52:22,130 --> 00:52:25,880
so it's not like I invented this

00:52:24,560 --> 00:52:28,280
originally I think the first written

00:52:25,880 --> 00:52:31,310
reference usage of this technique was in

00:52:28,280 --> 00:52:33,470
that Barton enactment book but but it

00:52:31,310 --> 00:52:36,290
was that I don't think they appreciated

00:52:33,470 --> 00:52:37,700
that hey this is actually a find they

00:52:36,290 --> 00:52:39,560
didn't that they didn't really explain

00:52:37,700 --> 00:52:41,710
what was going on it was a throwaway

00:52:39,560 --> 00:52:44,690
line in the

00:52:41,710 --> 00:52:47,930
so now by the way let's revisit this one

00:52:44,690 --> 00:52:51,260
which is this problem we had with the

00:52:47,930 --> 00:52:53,060
compilers inability to recognize what

00:52:51,260 --> 00:52:56,420
was going on with this mixed type

00:52:53,060 --> 00:52:59,530
arithmetic and that we as a concession

00:52:56,420 --> 00:53:03,020
we wound up having to explicitly cast

00:52:59,530 --> 00:53:06,140
operand that integer operand to into an

00:53:03,020 --> 00:53:09,890
object of type T and the reason why I

00:53:06,140 --> 00:53:13,280
tolerated it was that the cost of fixing

00:53:09,890 --> 00:53:15,770
it was writing turning a whole bunch of

00:53:13,280 --> 00:53:17,780
single templates into into a trio of

00:53:15,770 --> 00:53:19,850
templates and doing that umpteen times

00:53:17,780 --> 00:53:25,670
for all the different math operators I

00:53:19,850 --> 00:53:27,590
said life is too short but and so as a

00:53:25,670 --> 00:53:30,740
reminder here the fundamental difference

00:53:27,590 --> 00:53:32,150
between what happened why it worked when

00:53:30,740 --> 00:53:34,640
we weren't dealing with templates was

00:53:32,150 --> 00:53:37,010
when you're dealing with non template

00:53:34,640 --> 00:53:40,040
functions when rational was not a

00:53:37,010 --> 00:53:42,670
template it was using type I'm sorry

00:53:40,040 --> 00:53:46,460
it was using overload resolution an

00:53:42,670 --> 00:53:50,420
overload resolution who uses a fairly

00:53:46,460 --> 00:53:52,610
generous set of user-defined conversions

00:53:50,420 --> 00:53:54,080
in an effort to make a match and it

00:53:52,610 --> 00:53:56,570
includes the use of converting

00:53:54,080 --> 00:53:58,550
constructors but when we switched

00:53:56,570 --> 00:54:01,520
turning rationale and all of its

00:53:58,550 --> 00:54:05,350
operators into templates a lot of those

00:54:01,520 --> 00:54:08,090
conversions were now not available

00:54:05,350 --> 00:54:10,970
during template argument deduction to

00:54:08,090 --> 00:54:14,210
figure out if we could make a match and

00:54:10,970 --> 00:54:17,210
so one of the nice properties of this

00:54:14,210 --> 00:54:20,540
making new friends idiom is that if you

00:54:17,210 --> 00:54:25,060
turn all of the operators like divide

00:54:20,540 --> 00:54:27,680
and multiply and add and subtract you

00:54:25,060 --> 00:54:31,270
instead of making them non-member

00:54:27,680 --> 00:54:35,510
function templates you make them friends

00:54:31,270 --> 00:54:38,090
you actually move the definition of all

00:54:35,510 --> 00:54:41,180
of those binary operators into the class

00:54:38,090 --> 00:54:44,120
and make them friend functions that are

00:54:41,180 --> 00:54:45,890
defined there now you're no longer using

00:54:44,120 --> 00:54:48,770
template argument deduction you're back

00:54:45,890 --> 00:54:52,300
to using overload resolution and the

00:54:48,770 --> 00:54:54,080
compiler will use a richer assortment of

00:54:52,300 --> 00:54:56,630
implicit conversion

00:54:54,080 --> 00:54:59,590
in order to make the match in other

00:54:56,630 --> 00:55:02,120
words we simply take the rational

00:54:59,590 --> 00:55:04,100
operator divide which was a non-member

00:55:02,120 --> 00:55:07,430
function template you've move it in

00:55:04,100 --> 00:55:11,900
there it's no longer a template it's a

00:55:07,430 --> 00:55:14,690
an overloaded function it's in a

00:55:11,900 --> 00:55:18,950
template yeah and but now what happens

00:55:14,690 --> 00:55:21,430
is you do this even for a function like

00:55:18,950 --> 00:55:24,890
that which doesn't need to be a friend

00:55:21,430 --> 00:55:28,750
you put it in there and then what

00:55:24,890 --> 00:55:31,120
happens is now that divided by two

00:55:28,750 --> 00:55:36,110
compiles without the explicit conversion

00:55:31,120 --> 00:55:40,310
which is very nice that's right I didn't

00:55:36,110 --> 00:55:42,380
have to write the trio of things so that

00:55:40,310 --> 00:55:47,030
raises some questions you know it said

00:55:42,380 --> 00:55:48,530
that oh by the way yeah that notice that

00:55:47,030 --> 00:55:50,150
the implementation of the divide

00:55:48,530 --> 00:55:52,640
operator is it's in terms of divide

00:55:50,150 --> 00:55:55,000
equals divide equals is already a public

00:55:52,640 --> 00:55:57,290
member function that does the work

00:55:55,000 --> 00:55:59,630
there's nothing in the body of that

00:55:57,290 --> 00:56:02,830
operator divide that mentions num and n

00:55:59,630 --> 00:56:05,420
directly it doesn't need to be a friend

00:56:02,830 --> 00:56:08,270
so why do we have to throw the keyword

00:56:05,420 --> 00:56:11,840
friend there because if you take the

00:56:08,270 --> 00:56:15,290
word friend off now that declaration

00:56:11,840 --> 00:56:18,770
doesn't compile because when you put an

00:56:15,290 --> 00:56:20,240
operator inside a class like that the

00:56:18,770 --> 00:56:23,630
compiler assumes it's a member function

00:56:20,240 --> 00:56:26,240
it has a this pointer and that divide

00:56:23,630 --> 00:56:30,530
operator becomes a three argument divide

00:56:26,240 --> 00:56:33,020
and there ain't no such thing it'll say

00:56:30,530 --> 00:56:35,960
okay then get rid of one of those and so

00:56:33,020 --> 00:56:37,760
you have it as a member and with one

00:56:35,960 --> 00:56:38,990
argument but now we're back to the very

00:56:37,760 --> 00:56:41,240
beginning where we can't have

00:56:38,990 --> 00:56:43,190
conversions on the Left argument you

00:56:41,240 --> 00:56:44,750
need it to be a non-member so you can

00:56:43,190 --> 00:56:50,900
have conversions on either the left or

00:56:44,750 --> 00:56:53,590
the right and it can't be a member has

00:56:50,900 --> 00:56:53,590
to be a non-member

00:56:54,259 --> 00:57:02,459
so yeah so the question is is the

00:57:00,599 --> 00:57:05,489
friendship necessary the answer is in a

00:57:02,459 --> 00:57:08,819
sense no but if you don't make it a

00:57:05,489 --> 00:57:10,140
friend then it becomes a member what oh

00:57:08,819 --> 00:57:12,869
but maybe there's a possibility why

00:57:10,140 --> 00:57:14,430
can't we make it the static why'd it

00:57:12,869 --> 00:57:16,890
because that's the other way to get rid

00:57:14,430 --> 00:57:19,229
of this pointer make it a static member

00:57:16,890 --> 00:57:22,289
function why can't you do that well

00:57:19,229 --> 00:57:24,329
because you can't there's simply a

00:57:22,289 --> 00:57:28,109
flat-out statement in the standard that

00:57:24,329 --> 00:57:31,619
says operators cannot be static members

00:57:28,109 --> 00:57:34,709
of a class and because it again it

00:57:31,619 --> 00:57:37,109
drives overload resolution crazy with

00:57:34,709 --> 00:57:41,670
creating ambiguities so they it's just a

00:57:37,109 --> 00:57:43,859
flat-out rule you can't do it and so in

00:57:41,670 --> 00:57:46,680
a sense what we're doing here is we're

00:57:43,859 --> 00:57:50,039
using friend in a somewhat sneaky

00:57:46,680 --> 00:57:51,539
fashion it's it's a way of turning what

00:57:50,039 --> 00:57:54,509
would have been a member function into a

00:57:51,539 --> 00:57:57,089
non-member helper function by getting

00:57:54,509 --> 00:57:59,640
rid of the this pointer and so you could

00:57:57,089 --> 00:58:01,979
argue that conceptually static might be

00:57:59,640 --> 00:58:03,180
the better way to declare it but you

00:58:01,979 --> 00:58:06,599
can't do it that way so we're

00:58:03,180 --> 00:58:08,849
essentially leveraging the behavior of

00:58:06,599 --> 00:58:10,589
friends so this is granting friendship

00:58:08,849 --> 00:58:13,259
when you really don't need to grant

00:58:10,589 --> 00:58:16,680
friendship it's really it's it's to deny

00:58:13,259 --> 00:58:20,549
membership that's what's really

00:58:16,680 --> 00:58:22,019
happening here now just one one little

00:58:20,549 --> 00:58:23,880
last thing that I want to point out

00:58:22,019 --> 00:58:27,209
which i think is interesting is so the

00:58:23,880 --> 00:58:30,509
compiler when you instantiate rational

00:58:27,209 --> 00:58:33,479
for a tight t its manufacturing this

00:58:30,509 --> 00:58:35,670
friend function where's it putting it in

00:58:33,479 --> 00:58:37,349
what scope does it resign and friends

00:58:35,670 --> 00:58:39,690
have a very interesting behavior which

00:58:37,349 --> 00:58:41,849
is by the way drive the point home I've

00:58:39,690 --> 00:58:45,119
now wrapped the rational class inside

00:58:41,849 --> 00:58:48,599
this namespace called Sachs and if you

00:58:45,119 --> 00:58:52,019
try to refer to the operator divide

00:58:48,599 --> 00:58:55,259
outside the class like that this is a

00:58:52,019 --> 00:58:57,119
use I didn't I wanted a single line used

00:58:55,259 --> 00:58:59,369
I'm trying to take the address of that

00:58:57,119 --> 00:59:01,289
function find out if I can point to it

00:58:59,369 --> 00:59:03,839
and it turns out that it's in the

00:59:01,289 --> 00:59:05,380
namespace X I just say sax colon colon

00:59:03,839 --> 00:59:08,590
operator divide

00:59:05,380 --> 00:59:11,950
can't find it and the reason is it's

00:59:08,590 --> 00:59:14,380
using ordinary name lookup and friends

00:59:11,950 --> 00:59:17,440
that are introduced in a class scope

00:59:14,380 --> 00:59:22,720
like that are not visible by normal

00:59:17,440 --> 00:59:24,310
lookup and so but it turns out it can be

00:59:22,720 --> 00:59:26,890
found by something called argument

00:59:24,310 --> 00:59:28,990
dependent lookup which it relies on

00:59:26,890 --> 00:59:30,760
looking at the argument types to say

00:59:28,990 --> 00:59:32,770
what class should I go look in or what

00:59:30,760 --> 00:59:35,350
namespace should I go looking to find it

00:59:32,770 --> 00:59:37,120
but here's an interesting little demo

00:59:35,350 --> 00:59:40,510
that you can do to prove to demonstrate

00:59:37,120 --> 00:59:45,670
what's happening is that if you go ahead

00:59:40,510 --> 00:59:48,880
and explicitly declare a rational int

00:59:45,670 --> 00:59:51,160
operator divided like that so that you

00:59:48,880 --> 00:59:55,900
actually make the declaration visible by

00:59:51,160 --> 00:59:58,330
lookup that access on the bottom line is

00:59:55,900 --> 01:00:00,490
found in other words you've actually

00:59:58,330 --> 01:00:03,640
introduced a declaration into a scope

01:00:00,490 --> 01:00:05,500
and and it does exist and moreover if

01:00:03,640 --> 01:00:09,460
you actually turn that into a definition

01:00:05,500 --> 01:00:11,290
and you use the rational in type you get

01:00:09,460 --> 01:00:13,240
a multiply defined symbol so you can

01:00:11,290 --> 01:00:17,170
actually find the spot where the

01:00:13,240 --> 01:00:20,560
compiler put those friends into a

01:00:17,170 --> 01:00:22,630
particular scope so they are being

01:00:20,560 --> 01:00:24,910
manufactured you can hunt them down

01:00:22,630 --> 01:00:33,640
what you normally don't you just let

01:00:24,910 --> 01:00:35,110
argument dependent lookup find them no

01:00:33,640 --> 01:00:37,570
because it's not a member of class

01:00:35,110 --> 01:00:39,730
rational you can't say sex colon colon

01:00:37,570 --> 01:00:42,030
rational colon colon operator because

01:00:39,730 --> 01:00:44,380
it's not a member of the rational class

01:00:42,030 --> 01:00:49,450
yeah even though it's there it's not

01:00:44,380 --> 01:00:51,190
there okay so anyway Scott Myers

01:00:49,450 --> 01:00:53,890
actually has a little bit of advice in

01:00:51,190 --> 01:00:55,390
his book he says the reason the

01:00:53,890 --> 01:00:57,400
rationale for doing this is it says

01:00:55,390 --> 01:00:59,020
define non-member functions inside

01:00:57,400 --> 01:01:03,130
templates when type conversions are

01:00:59,020 --> 01:01:06,040
desired I think that's a little bit too

01:01:03,130 --> 01:01:08,470
vague from my taste I prefer a wordier

01:01:06,040 --> 01:01:10,390
but more precise statement which is when

01:01:08,470 --> 01:01:12,400
a class template defines a type with an

01:01:10,390 --> 01:01:14,770
Associated binary operator that allows

01:01:12,400 --> 01:01:17,470
user-defined conversions on its left

01:01:14,770 --> 01:01:19,119
operand then you should define not just

01:01:17,470 --> 01:01:20,950
declare that operator inside

01:01:19,119 --> 01:01:24,910
class template as a non-member friend

01:01:20,950 --> 01:01:27,880
that's really the specific use case okay

01:01:24,910 --> 01:01:29,490
and that's it there were the references

01:01:27,880 --> 01:01:33,090
and thank you very much

01:01:29,490 --> 01:01:33,090

YouTube URL: https://www.youtube.com/watch?v=POa_V15je8Y


