Title: CppCon 2018: Jon Cohen “Ensuring Exception Safety Through Testing"
Publication date: 2018-10-11
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Are your APIs exception safe? How do you know? What about legacy interfaces written ten years ago? What about the code you will write next week? Are your dependencies exception safe? 

Best practices for writing exception-safe code have long been established, but tests for exception safety remain rare even though the seminal work on the topic was written nearly twenty years ago. We will discuss the fundamentals of exception safety and how you can ensure the exception safety of your APIs using new features in Googletest. This will include examples of how we used these features to find bugs in Abseil, bugs in standard libraries, and even bugs in the standard itself! By the end of this talk you will have the tools to ensure that your codebase is exception-safe both now and into the future.
— 
Jon Cohen
Software Engineer, Google
Jon Cohen is an engineer at Google, maintaining our core common C++ libraries. He spends most of his days directing Google's robot army to rewrite its own source code to be more readable and efficient, and has so far managed to do so without accidentally creating Skynet.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,589 --> 00:00:07,439
morning everyone I'm John Cohen from the

00:00:03,750 --> 00:00:09,059
abseil team at Google and I'm gonna talk

00:00:07,439 --> 00:00:11,759
about and sharing exception safety

00:00:09,059 --> 00:00:13,080
through testing although like it's kind

00:00:11,759 --> 00:00:16,020
of a crappy name right it was kind of

00:00:13,080 --> 00:00:17,640
clunky it was a little bit too late for

00:00:16,020 --> 00:00:19,440
me to change the title like when I

00:00:17,640 --> 00:00:21,150
realized it wasn't any good but I get to

00:00:19,440 --> 00:00:23,100
change it now so actually we're gonna

00:00:21,150 --> 00:00:26,820
talk about unit test your exception

00:00:23,100 --> 00:00:30,870
safety so it's gonna be a great little

00:00:26,820 --> 00:00:32,880
testing party so a couple questions for

00:00:30,870 --> 00:00:37,280
people in the audience before I get

00:00:32,880 --> 00:00:39,240
started who here works with exceptions

00:00:37,280 --> 00:00:40,560
all right I figured it'd be a lot of

00:00:39,240 --> 00:00:45,090
people given the nature of this talk

00:00:40,560 --> 00:00:46,860
awesome who here has had to debug or

00:00:45,090 --> 00:00:49,020
been bitten by or somehow had to

00:00:46,860 --> 00:00:52,020
interact with a bug dealing with that

00:00:49,020 --> 00:00:53,700
came from exception safety most people

00:00:52,020 --> 00:00:56,370
who raised their hands before great ok

00:00:53,700 --> 00:00:58,940
and who here thinks that they're really

00:00:56,370 --> 00:01:01,590
good at writing exception safe code a

00:00:58,940 --> 00:01:03,540
couple a couple hands came up that's

00:01:01,590 --> 00:01:08,100
alright we'll see by the end of the talk

00:01:03,540 --> 00:01:09,509
if your hands say wrists well for most

00:01:08,100 --> 00:01:13,649
people I would think we would say that

00:01:09,509 --> 00:01:17,539
exception safety is hard and in that

00:01:13,649 --> 00:01:20,520
note I'm gonna start off with a story

00:01:17,539 --> 00:01:22,920
except in Safety's hard it's very subtle

00:01:20,520 --> 00:01:25,229
you have to deal with we all know what's

00:01:22,920 --> 00:01:28,409
hard about exceptions hidden control

00:01:25,229 --> 00:01:29,490
flow just weird you know you do things

00:01:28,409 --> 00:01:31,289
in the wrong order and everything's

00:01:29,490 --> 00:01:33,539
screwed up there's just mostly best

00:01:31,289 --> 00:01:35,279
practices there's a lot of like staring

00:01:33,539 --> 00:01:37,560
really hard at your computer screen and

00:01:35,279 --> 00:01:41,700
trying to figure out like what's going

00:01:37,560 --> 00:01:45,090
on exception safety is hard and nobody

00:01:41,700 --> 00:01:47,369
tests for it more or less I am a clang

00:01:45,090 --> 00:01:49,619
tests for it kind of but like it's not

00:01:47,369 --> 00:01:52,380
very widespread to test for exception

00:01:49,619 --> 00:01:54,240
safety which is kind of crazy like if

00:01:52,380 --> 00:01:56,639
there is anything else that was as

00:01:54,240 --> 00:01:58,439
subtle or it's difficult as making your

00:01:56,639 --> 00:01:59,999
code exception safe you would want to

00:01:58,439 --> 00:02:01,919
write unit tests for it you'd want to

00:01:59,999 --> 00:02:03,479
make sure like I probably didn't get

00:02:01,919 --> 00:02:05,459
this right let me write a test to make

00:02:03,479 --> 00:02:06,400
sure that I actually got this right and

00:02:05,459 --> 00:02:07,840
then if it

00:02:06,400 --> 00:02:12,820
asses the first time you wonder where

00:02:07,840 --> 00:02:16,270
the bug in your test is so last year we

00:02:12,820 --> 00:02:18,910
released absol and its really great I

00:02:16,270 --> 00:02:21,130
suggest everybody look at it if if you

00:02:18,910 --> 00:02:24,100
haven't seen it it's got a lot of code

00:02:21,130 --> 00:02:26,290
and one of the big features of abseil is

00:02:24,100 --> 00:02:29,080
all of our types are really battle

00:02:26,290 --> 00:02:31,600
tested they are dependent on by hundreds

00:02:29,080 --> 00:02:33,820
of millions of lines of code and are the

00:02:31,600 --> 00:02:36,670
foundations for basically all the

00:02:33,820 --> 00:02:39,670
products at Google puts out but there's

00:02:36,670 --> 00:02:42,310
a big asterisk there because as many

00:02:39,670 --> 00:02:45,640
people know we don't use exceptions at

00:02:42,310 --> 00:02:47,110
Google at all and so it's not even we

00:02:45,640 --> 00:02:47,500
didn't know if our code is exception

00:02:47,110 --> 00:02:49,900
safe

00:02:47,500 --> 00:02:51,970
we knew our code is not exception safe

00:02:49,900 --> 00:02:59,350
at all so we were kind of in this

00:02:51,970 --> 00:03:00,910
situation and and so I decided that we

00:02:59,350 --> 00:03:03,370
needed to go and figure out how to make

00:03:00,910 --> 00:03:04,959
our code exception safe but without

00:03:03,370 --> 00:03:07,450
tests it's really hard to actually

00:03:04,959 --> 00:03:09,130
verify this thing like it just as with

00:03:07,450 --> 00:03:12,220
anything like we can make some changes

00:03:09,130 --> 00:03:16,410
to try and make our code exception safe

00:03:12,220 --> 00:03:18,220
but you never know without a test so

00:03:16,410 --> 00:03:20,860
ideally I wanted to be able to write

00:03:18,220 --> 00:03:22,840
something like this this is for those

00:03:20,860 --> 00:03:24,220
this isn't a Google test style for those

00:03:22,840 --> 00:03:25,900
who don't know a Google test regime in

00:03:24,220 --> 00:03:27,519
it I'll use those names interchangeably

00:03:25,900 --> 00:03:28,570
one of them's the internal name one of

00:03:27,519 --> 00:03:31,450
them is the external name and I can

00:03:28,570 --> 00:03:33,310
never remember which one is which but

00:03:31,450 --> 00:03:35,620
we're making a little test case and

00:03:33,310 --> 00:03:38,110
expect that takes some kind of match or

00:03:35,620 --> 00:03:39,820
something returns a bowl or whatever so

00:03:38,110 --> 00:03:41,440
it kind of reads like English expected

00:03:39,820 --> 00:03:43,480
that this function is exception say

00:03:41,440 --> 00:03:46,540
expect expect that that function is

00:03:43,480 --> 00:03:48,760
exception safe and I'm gonna use vector

00:03:46,540 --> 00:03:50,799
pushback a lot so this is just kind of

00:03:48,760 --> 00:03:53,200
setting up the rest of the talk so this

00:03:50,799 --> 00:03:57,040
is what I wanted to be able to write so

00:03:53,200 --> 00:03:59,140
I did some research and as it turns out

00:03:57,040 --> 00:04:02,920
I found something that was pretty

00:03:59,140 --> 00:04:05,950
surprising at least I mean we've known

00:04:02,920 --> 00:04:08,610
how to do this for like 20 years not a -

00:04:05,950 --> 00:04:10,900
for like 20 years

00:04:08,610 --> 00:04:13,600
exception safety testing predates

00:04:10,900 --> 00:04:15,040
standard C++ the earliest work I was

00:04:13,600 --> 00:04:18,260
able to find on this was from Dave

00:04:15,040 --> 00:04:20,269
Abraham's which he wrote as

00:04:18,260 --> 00:04:23,930
from his experiences writing the

00:04:20,269 --> 00:04:25,670
original STL implementation so this he

00:04:23,930 --> 00:04:27,320
has a paper a little article it's still

00:04:25,670 --> 00:04:29,450
up on boost work I have a link to it at

00:04:27,320 --> 00:04:31,580
the end of the talk which is really

00:04:29,450 --> 00:04:34,940
great and everyone should read it but

00:04:31,580 --> 00:04:36,080
Dave Abraham's only was concerned with

00:04:34,940 --> 00:04:38,960
testing a standard library

00:04:36,080 --> 00:04:40,820
implementation so he didn't release any

00:04:38,960 --> 00:04:44,720
library he just released some binaries

00:04:40,820 --> 00:04:46,670
that if you were writing a C++ 98

00:04:44,720 --> 00:04:49,040
standard library implementation you

00:04:46,670 --> 00:04:51,650
could use to test that your code is

00:04:49,040 --> 00:04:53,330
exception safe but it doesn't do

00:04:51,650 --> 00:04:55,580
anything else you can't use it to test

00:04:53,330 --> 00:04:58,070
anything else except the C++ 98 standard

00:04:55,580 --> 00:05:02,390
library implementation so it was kind of

00:04:58,070 --> 00:05:04,490
useful but not really what I needed so I

00:05:02,390 --> 00:05:07,130
started trying to test and fix our

00:05:04,490 --> 00:05:09,790
exception safety using the code and the

00:05:07,130 --> 00:05:11,990
ideas from Dave Abraham's paper and

00:05:09,790 --> 00:05:14,240
learned a lot of lessons along the way

00:05:11,990 --> 00:05:16,130
this is all still very much open we're

00:05:14,240 --> 00:05:17,630
still wearing a lot some of the stuff

00:05:16,130 --> 00:05:19,940
that's on these slides still hasn't even

00:05:17,630 --> 00:05:22,120
been like committed yet to code I'm

00:05:19,940 --> 00:05:25,070
still in the middle of writing it so

00:05:22,120 --> 00:05:27,229
very much this is gonna be I'm gonna be

00:05:25,070 --> 00:05:29,330
taking you along the journey that we

00:05:27,229 --> 00:05:31,310
took last year of learning how to do

00:05:29,330 --> 00:05:33,440
this stuff

00:05:31,310 --> 00:05:35,990
I can proud to report after a year that

00:05:33,440 --> 00:05:38,030
I still have no idea what I'm doing but

00:05:35,990 --> 00:05:40,360
I have a little bit more of an idea what

00:05:38,030 --> 00:05:44,990
I was doing then I did a year ago so

00:05:40,360 --> 00:05:46,729
we're on the right track so here's what

00:05:44,990 --> 00:05:49,970
we're gonna do I just want to take a

00:05:46,729 --> 00:05:51,470
second to say if anyone has any

00:05:49,970 --> 00:05:53,510
questions at any point if you need

00:05:51,470 --> 00:05:55,490
clarification on anything don't be shy

00:05:53,510 --> 00:05:57,200
please ask because someone else probably

00:05:55,490 --> 00:06:01,330
has the same question either here in the

00:05:57,200 --> 00:06:04,550
audience or in the future on YouTube so

00:06:01,330 --> 00:06:05,900
yeah feel free there's a microphone

00:06:04,550 --> 00:06:07,250
right there there's there's not a

00:06:05,900 --> 00:06:08,479
microphone in the other aisle but if

00:06:07,250 --> 00:06:12,110
you're on that side of the room just

00:06:08,479 --> 00:06:13,520
shout or something and that's great for

00:06:12,110 --> 00:06:15,590
everyone it's great for me because then

00:06:13,520 --> 00:06:17,670
I can make sure that I can

00:06:15,590 --> 00:06:19,910
informative talk it's great for everyone

00:06:17,670 --> 00:06:22,350
else because now they get clarification

00:06:19,910 --> 00:06:24,540
so on that note I'm gonna start with

00:06:22,350 --> 00:06:26,010
just like really high level fundamentals

00:06:24,540 --> 00:06:28,050
of exception safety I'm kind of coming

00:06:26,010 --> 00:06:30,390
from the idea that most of you know what

00:06:28,050 --> 00:06:32,610
exception safety is I'm just setting up

00:06:30,390 --> 00:06:35,010
a perspective on exception safety that

00:06:32,610 --> 00:06:36,480
I'm going to use and the rest of the

00:06:35,010 --> 00:06:38,580
talk if you want to learn everything

00:06:36,480 --> 00:06:41,250
there ever was to know about exception

00:06:38,580 --> 00:06:44,190
safety watch John calls talk from cpp

00:06:41,250 --> 00:06:47,250
con 2014 it's a three-part talk and he

00:06:44,190 --> 00:06:49,440
talks about everything there is to know

00:06:47,250 --> 00:06:52,080
about exception safety and exceptions

00:06:49,440 --> 00:06:54,300
and then you will leave it's a great

00:06:52,080 --> 00:06:56,940
talk it's it's really entertaining go

00:06:54,300 --> 00:06:58,320
watch it then I'll talk about testing

00:06:56,940 --> 00:07:00,660
exception safety so I'm going to start

00:06:58,320 --> 00:07:03,390
with basically Dave Abraham's ideas from

00:07:00,660 --> 00:07:05,910
20 years ago and go through the process

00:07:03,390 --> 00:07:08,100
of the issues we found when generalizing

00:07:05,910 --> 00:07:12,000
these ideas and build up the algorithm

00:07:08,100 --> 00:07:14,460
that we have today then I'll go on tour

00:07:12,000 --> 00:07:16,200
to talk about best practices how should

00:07:14,460 --> 00:07:17,430
we actually write these exception safety

00:07:16,200 --> 00:07:19,140
tests which we think about when we're

00:07:17,430 --> 00:07:22,440
writing them what should we test all of

00:07:19,140 --> 00:07:24,720
these questions will be answered finally

00:07:22,440 --> 00:07:26,250
I will draw some conclusions talk about

00:07:24,720 --> 00:07:28,590
future directions of work that we're

00:07:26,250 --> 00:07:31,200
trying to do and then we'll go do the

00:07:28,590 --> 00:07:33,090
rest of cpp con and then go home and

00:07:31,200 --> 00:07:34,770
maybe like watching football on Sunday

00:07:33,090 --> 00:07:36,690
or something and then on Monday we can

00:07:34,770 --> 00:07:40,370
come to work and start making our code

00:07:36,690 --> 00:07:44,490
exception safe verified by unit tests

00:07:40,370 --> 00:07:49,500
awesome so any questions concerns before

00:07:44,490 --> 00:07:53,700
we get going awesome let's do it

00:07:49,500 --> 00:07:55,110
exception safety fundamentals so how are

00:07:53,700 --> 00:07:58,320
we looking at exception safety at a

00:07:55,110 --> 00:08:00,240
really high level it's just a set of

00:07:58,320 --> 00:08:02,460
specifications on an operation and this

00:08:00,240 --> 00:08:04,740
is purposefully really obtuse and vague

00:08:02,460 --> 00:08:05,850
there are two parts to this definition

00:08:04,740 --> 00:08:07,980
that are important one it's a

00:08:05,850 --> 00:08:10,770
specification we're treating exception

00:08:07,980 --> 00:08:12,690
safety on the same level as of an API as

00:08:10,770 --> 00:08:15,230
what are the inputs what is it output

00:08:12,690 --> 00:08:18,480
what does it do its exact same

00:08:15,230 --> 00:08:19,980
importance of specification also we're

00:08:18,480 --> 00:08:22,440
talking about an operation not a

00:08:19,980 --> 00:08:24,120
function this could be a series of

00:08:22,440 --> 00:08:25,720
behaviors a sequence of function calls

00:08:24,120 --> 00:08:27,300
it's just any behavior

00:08:25,720 --> 00:08:30,100
wrapping up and calling it operation

00:08:27,300 --> 00:08:31,750
typically is an operation on an object

00:08:30,100 --> 00:08:33,520
and then we'll talk about the state of

00:08:31,750 --> 00:08:36,130
that object but it doesn't have to be it

00:08:33,520 --> 00:08:38,500
could be an input range something like

00:08:36,130 --> 00:08:41,200
that it is just a generally an operation

00:08:38,500 --> 00:08:44,380
on some stuff and that's all we really

00:08:41,200 --> 00:08:46,330
need to think about we define it as

00:08:44,380 --> 00:08:48,250
reasonable behavior when an exception

00:08:46,330 --> 00:08:51,850
propagates so two important parts in

00:08:48,250 --> 00:08:53,800
this in this sentence two we're talking

00:08:51,850 --> 00:08:55,810
about exceptions propagating so if

00:08:53,800 --> 00:08:57,700
you're writing the code that throws the

00:08:55,810 --> 00:08:59,980
exception you don't have to worry about

00:08:57,700 --> 00:09:01,840
this so much like vector at which you

00:08:59,980 --> 00:09:04,810
know takes an index throws and out of

00:09:01,840 --> 00:09:08,110
range exception if the index is too big

00:09:04,810 --> 00:09:09,280
or too small they don't have to we don't

00:09:08,110 --> 00:09:10,510
really have to worry about exception

00:09:09,280 --> 00:09:12,280
safety because you know where the

00:09:10,510 --> 00:09:15,690
exception comes from it's the people who

00:09:12,280 --> 00:09:19,210
consume the api's that throw exceptions

00:09:15,690 --> 00:09:21,370
that we're concerned about today and

00:09:19,210 --> 00:09:22,780
also we have this notion of reasonable

00:09:21,370 --> 00:09:25,060
behavior and really what I mean by

00:09:22,780 --> 00:09:26,320
reasonable behavior is just like there's

00:09:25,060 --> 00:09:27,850
no one to find behavior there's no leaks

00:09:26,320 --> 00:09:29,710
I'll talk about this later but like

00:09:27,850 --> 00:09:31,750
something happens where the program

00:09:29,710 --> 00:09:34,900
isn't completely destroyed because an

00:09:31,750 --> 00:09:36,520
exception happened and specifically we

00:09:34,900 --> 00:09:38,080
like to talk about a hierarchy of

00:09:36,520 --> 00:09:39,190
specific contracts when talking about

00:09:38,080 --> 00:09:40,660
exception safety there's some

00:09:39,190 --> 00:09:42,640
long-established vocabulary and I'm

00:09:40,660 --> 00:09:44,080
gonna go over it really quick just to

00:09:42,640 --> 00:09:47,860
make sure that we're all on the same

00:09:44,080 --> 00:09:50,620
footing so first one's no guarantee it

00:09:47,860 --> 00:09:52,450
looks a little bit like this it doesn't

00:09:50,620 --> 00:09:54,580
necessarily mean that everything is

00:09:52,450 --> 00:09:57,460
blowing up like the dog is about to say

00:09:54,580 --> 00:09:58,630
this is fine and mean it and so no

00:09:57,460 --> 00:09:59,920
guarantee doesn't mean everything's

00:09:58,630 --> 00:10:02,530
broken it just means that no one's

00:09:59,920 --> 00:10:03,310
bothered to specify it yet it could be

00:10:02,530 --> 00:10:06,970
completely broken

00:10:03,310 --> 00:10:09,160
it could be fine but you have no idea so

00:10:06,970 --> 00:10:11,170
you need the check basic guarantee is

00:10:09,160 --> 00:10:12,940
more useful it just says that the

00:10:11,170 --> 00:10:15,070
operation maintains invariants doesn't

00:10:12,940 --> 00:10:17,620
have undefined behavior things like that

00:10:15,070 --> 00:10:19,180
in practice what it means is that if you

00:10:17,620 --> 00:10:22,150
have some operation with a basic

00:10:19,180 --> 00:10:24,400
guarantee and it throws the very least

00:10:22,150 --> 00:10:26,260
you can do is take your object and reset

00:10:24,400 --> 00:10:27,910
it to a known state and once you're at a

00:10:26,260 --> 00:10:32,080
known state then you actually have a

00:10:27,910 --> 00:10:35,470
chance of recovering from this error you

00:10:32,080 --> 00:10:36,010
can start over again do whatever the

00:10:35,470 --> 00:10:38,440
stronger

00:10:36,010 --> 00:10:39,880
is obviously stronger than the basic

00:10:38,440 --> 00:10:41,230
guarantee and it's assumes the basic

00:10:39,880 --> 00:10:42,550
guarantee so we still have everything

00:10:41,230 --> 00:10:44,500
about no one to find behavior and it

00:10:42,550 --> 00:10:46,870
leaks everything like that but also

00:10:44,500 --> 00:10:49,090
gives rollback semantics specifically

00:10:46,870 --> 00:10:51,430
all of the observable properties of the

00:10:49,090 --> 00:10:53,770
object are maintained and I'm very

00:10:51,430 --> 00:10:56,290
careful not to say that this has to do

00:10:53,770 --> 00:10:57,820
with operator equals equals because it

00:10:56,290 --> 00:11:00,040
might not be the case that the object

00:10:57,820 --> 00:11:02,440
even has operator equals equals but yet

00:11:00,040 --> 00:11:05,650
we can still have some notion of

00:11:02,440 --> 00:11:08,110
unchanged and as an example I'll talk

00:11:05,650 --> 00:11:11,170
about a defect in the standard that I

00:11:08,110 --> 00:11:14,070
reported in the course of of doing this

00:11:11,170 --> 00:11:16,210
work so this is uninitialized move

00:11:14,070 --> 00:11:17,740
there's a whole bunch of these sorts of

00:11:16,210 --> 00:11:19,390
functions in the standard initialize

00:11:17,740 --> 00:11:23,020
copy and initialized fill and initialize

00:11:19,390 --> 00:11:25,360
move and their basic building blocks for

00:11:23,020 --> 00:11:29,080
containers you give it a range into

00:11:25,360 --> 00:11:30,820
uninitialized memory and it will copy or

00:11:29,080 --> 00:11:33,490
move or do whatever and they have the

00:11:30,820 --> 00:11:36,220
strong guarantee up through c++ 17 and

00:11:33,490 --> 00:11:38,860
says any it says that there are no

00:11:36,220 --> 00:11:41,050
effects if this throws an exception

00:11:38,860 --> 00:11:48,940
which is a very strong statement

00:11:41,050 --> 00:11:53,920
Tidus and go back one slide ok so the

00:11:48,940 --> 00:11:57,430
problem of course is what if you have my

00:11:53,920 --> 00:11:59,170
mouth slit what if you have this what if

00:11:57,430 --> 00:12:01,360
you have an object where the move

00:11:59,170 --> 00:12:02,890
constructor throws well uninitialized

00:12:01,360 --> 00:12:04,930
move can't say there are no effects

00:12:02,890 --> 00:12:06,880
because if you move something in to your

00:12:04,930 --> 00:12:08,110
destination range and it throws you have

00:12:06,880 --> 00:12:11,380
no guarantee that you can move it back

00:12:08,110 --> 00:12:13,450
because it might throw again so this is

00:12:11,380 --> 00:12:16,120
actually an impossible you can't say

00:12:13,450 --> 00:12:18,160
there are no effects but instead in C++

00:12:16,120 --> 00:12:19,660
20 now it will say that everything which

00:12:18,160 --> 00:12:22,180
was constructed by placement knew was

00:12:19,660 --> 00:12:23,350
destroyed which is ultimately the effect

00:12:22,180 --> 00:12:24,610
that you care about that things are

00:12:23,350 --> 00:12:27,370
constructed or not so the strong

00:12:24,610 --> 00:12:29,830
guarantee can be specified in other ways

00:12:27,370 --> 00:12:33,160
besides this object would you know

00:12:29,830 --> 00:12:34,960
compare equal before and after tennis so

00:12:33,160 --> 00:12:37,270
when you say all of the observable

00:12:34,960 --> 00:12:43,060
properties the object and you tried to

00:12:37,270 --> 00:12:45,410
dodge equals equals there for vector for

00:12:43,060 --> 00:12:48,259
instance capacity is observable but not

00:12:45,410 --> 00:12:52,069
of its logical state yeah you include

00:12:48,259 --> 00:12:55,129
capacity the the answer is whatever the

00:12:52,069 --> 00:12:55,790
type author says is the state that

00:12:55,129 --> 00:12:58,190
matters

00:12:55,790 --> 00:12:59,870
basically so so observable properties is

00:12:58,190 --> 00:13:01,339
also not the right word probably it's

00:12:59,870 --> 00:13:03,680
kind of this is like a kind of soft

00:13:01,339 --> 00:13:05,449
concept where it's like we decide what

00:13:03,680 --> 00:13:08,329
is the state that is salient like a

00:13:05,449 --> 00:13:09,560
capacity doesn't have two vectors with

00:13:08,329 --> 00:13:11,060
different capacities but the same

00:13:09,560 --> 00:13:13,819
elements when most people would say or

00:13:11,060 --> 00:13:15,410
are equal right so you it's primarily a

00:13:13,819 --> 00:13:20,060
property of the logical state the

00:13:15,410 --> 00:13:21,740
logical state yeah yeah okay where was

00:13:20,060 --> 00:13:24,110
it great so the notes no guarantee is

00:13:21,740 --> 00:13:25,730
the the strongest it is subtly different

00:13:24,110 --> 00:13:27,589
from no except it's not the most

00:13:25,730 --> 00:13:29,240
practical thing in the world but this

00:13:27,589 --> 00:13:31,879
function is no accept and doesn't have

00:13:29,240 --> 00:13:34,250
the no throw guarantee it throws a slide

00:13:31,879 --> 00:13:36,199
show example exception before the Senate

00:13:34,250 --> 00:13:38,689
I am very smart exception but I didn't

00:13:36,199 --> 00:13:40,639
feel like this should be so snarky but

00:13:38,689 --> 00:13:43,279
ya know accept means if an exception

00:13:40,639 --> 00:13:45,980
propagates kill the program no throw

00:13:43,279 --> 00:13:48,050
guarantee means I'm not gonna throw so

00:13:45,980 --> 00:13:50,569
this is going back to how exceptions

00:13:48,050 --> 00:13:52,250
safety is an API specification it's a

00:13:50,569 --> 00:13:53,300
property of the specification and also

00:13:52,250 --> 00:13:56,829
it can be a property of the

00:13:53,300 --> 00:13:59,449
implementation but that's accidental

00:13:56,829 --> 00:14:00,949
great so just like anything else where

00:13:59,449 --> 00:14:03,589
we have some basic building blocks we

00:14:00,949 --> 00:14:05,089
can build up hybrid guarantees typically

00:14:03,589 --> 00:14:06,889
these have to do with different traits

00:14:05,089 --> 00:14:08,529
of a type so that you can write more

00:14:06,889 --> 00:14:10,970
optimized code for certain cases

00:14:08,529 --> 00:14:13,279
pushback is a really classic example if

00:14:10,970 --> 00:14:15,110
your vector has things in it which have

00:14:13,279 --> 00:14:18,110
no throw move constructors which most

00:14:15,110 --> 00:14:20,509
should be in most cases then it will

00:14:18,110 --> 00:14:22,310
move into the new allocation and it has

00:14:20,509 --> 00:14:23,839
the strong guarantee because it had all

00:14:22,310 --> 00:14:27,380
the types are no throw movable so it

00:14:23,839 --> 00:14:29,720
just it knows that it will work just the

00:14:27,380 --> 00:14:31,699
same and your type has a throwing move

00:14:29,720 --> 00:14:34,240
constructor but has a non throwing copy

00:14:31,699 --> 00:14:38,209
constructor then it will copy everything

00:14:34,240 --> 00:14:39,709
into into the source range sorry it

00:14:38,209 --> 00:14:40,880
doesn't have to have an I can have a

00:14:39,709 --> 00:14:42,410
throwing copy constructor because if I

00:14:40,880 --> 00:14:43,939
copy stuff into the range and something

00:14:42,410 --> 00:14:45,470
throws it just gets rid of all the stuff

00:14:43,939 --> 00:14:47,959
and you never took anything out of the

00:14:45,470 --> 00:14:50,360
first range you're fine and finally if

00:14:47,959 --> 00:14:51,949
you have something which has a throwing

00:14:50,360 --> 00:14:54,070
loop constructor and isn't copyable

00:14:51,949 --> 00:14:56,139
it will try and move into the new

00:14:54,070 --> 00:14:57,850
the new allocation but it can only give

00:14:56,139 --> 00:14:59,440
the basic guarantee because it doesn't

00:14:57,850 --> 00:15:02,050
know that it's able to move back into

00:14:59,440 --> 00:15:04,029
the original allocation so this is kind

00:15:02,050 --> 00:15:06,310
of a basic hybrid guarantee we're just

00:15:04,029 --> 00:15:08,860
the properties of the type

00:15:06,310 --> 00:15:10,300
sort of indicate a need for something a

00:15:08,860 --> 00:15:13,089
little more complex but we can build

00:15:10,300 --> 00:15:15,699
arbitrarily complex specifications if we

00:15:13,089 --> 00:15:17,589
want to in practice we I've found that

00:15:15,699 --> 00:15:20,230
just making really complex

00:15:17,589 --> 00:15:21,759
specifications often just isn't really

00:15:20,230 --> 00:15:23,440
that much worth the effort unless you

00:15:21,759 --> 00:15:24,880
have a big optimization when like we

00:15:23,440 --> 00:15:29,829
have with vector being able to move

00:15:24,880 --> 00:15:31,480
sometimes great so at the end of the day

00:15:29,829 --> 00:15:33,579
exception safety is really about when

00:15:31,480 --> 00:15:35,019
you're in a room that is completely

00:15:33,579 --> 00:15:36,579
burning and filled with smoke and fire

00:15:35,019 --> 00:15:38,470
you can drink your coffee and say this

00:15:36,579 --> 00:15:44,470
is fine because I know how to deal with

00:15:38,470 --> 00:15:46,600
the problem okay so this is the end of

00:15:44,470 --> 00:15:48,100
the intro about to put a lot of code on

00:15:46,600 --> 00:15:49,569
the slides I don't normally like

00:15:48,100 --> 00:15:51,069
throwing a bunch of code on slides it's

00:15:49,569 --> 00:15:52,810
hard to read but I think it's important

00:15:51,069 --> 00:15:56,620
to show how this algorithm is built up

00:15:52,810 --> 00:15:58,360
so before I move on it's still early in

00:15:56,620 --> 00:16:00,160
the morning but saw-like gather

00:15:58,360 --> 00:16:03,579
ourselves get ready to use our brains

00:16:00,160 --> 00:16:05,709
first time today once again like if

00:16:03,579 --> 00:16:07,510
anything is hard to follow if there's

00:16:05,709 --> 00:16:10,389
like you can't remember what's going on

00:16:07,510 --> 00:16:11,589
please ask just like Titus did because

00:16:10,389 --> 00:16:12,130
someone else is probably wondering the

00:16:11,589 --> 00:16:17,069
same thing

00:16:12,130 --> 00:16:21,279
so let's do it

00:16:17,069 --> 00:16:23,889
testing exception safety everything I'm

00:16:21,279 --> 00:16:25,959
about to tell you is a lie really

00:16:23,889 --> 00:16:28,029
they're more like n percent truths where

00:16:25,959 --> 00:16:31,209
the limit as the slide number goes to

00:16:28,029 --> 00:16:33,339
infinity is like 90 or so this is slide

00:16:31,209 --> 00:16:35,860
code don't crucify me I'm not gonna

00:16:33,339 --> 00:16:38,040
qualify namespaces some things are gonna

00:16:35,860 --> 00:16:40,959
be subtly wrong I'm gonna omit details

00:16:38,040 --> 00:16:42,310
you can look at the code and abseil

00:16:40,959 --> 00:16:44,709
internals if you really want all the

00:16:42,310 --> 00:16:47,230
nitty-gritty but I'm just focusing on

00:16:44,709 --> 00:16:49,899
the most salient important details at

00:16:47,230 --> 00:16:51,910
least from my perspective so what's the

00:16:49,899 --> 00:16:55,319
idea the idea is you have some kind of

00:16:51,910 --> 00:16:58,150
global counter that lets you

00:16:55,319 --> 00:17:00,970
deterministically throw the N except

00:16:58,150 --> 00:17:02,740
from an operation and you do this with a

00:17:00,970 --> 00:17:05,010
sort of maybe throw function like this

00:17:02,740 --> 00:17:07,030
this is basically what Abraham's wrote

00:17:05,010 --> 00:17:09,730
decrement the count on if it's zero

00:17:07,030 --> 00:17:11,020
throw and then someone else outside can

00:17:09,730 --> 00:17:13,360
set the counter to whatever they want

00:17:11,020 --> 00:17:17,740
and if I set the counter to ten I'll get

00:17:13,360 --> 00:17:19,930
the the eleventh exception so this is

00:17:17,740 --> 00:17:21,970
great this worked really well for Dave

00:17:19,930 --> 00:17:22,770
Abraham's but let's see what we can do

00:17:21,970 --> 00:17:25,030
with it

00:17:22,770 --> 00:17:27,460
something that might stick out to you

00:17:25,030 --> 00:17:29,740
immediately is that we're throwing an

00:17:27,460 --> 00:17:31,510
INT which i think is weird that you can

00:17:29,740 --> 00:17:33,220
even do but sure you can throw it in and

00:17:31,510 --> 00:17:36,190
that's like it doesn't really tell us

00:17:33,220 --> 00:17:37,660
much and very specifically if we want to

00:17:36,190 --> 00:17:39,370
test something like an alligator which

00:17:37,660 --> 00:17:41,410
is specified to throw bad a lock this

00:17:39,370 --> 00:17:43,600
doesn't help we still want this thing to

00:17:41,410 --> 00:17:48,310
be able to throw whatever exception is

00:17:43,600 --> 00:17:50,260
mandated by our interface so this is a

00:17:48,310 --> 00:17:52,000
really easy change to make make it a

00:17:50,260 --> 00:17:53,800
template so now you can specify what

00:17:52,000 --> 00:17:55,780
kind of exception you want to throw this

00:17:53,800 --> 00:17:57,970
is really useful for testing alligators

00:17:55,780 --> 00:17:58,530
for testing containers anything like

00:17:57,970 --> 00:18:02,110
that

00:17:58,530 --> 00:18:03,220
great what if we want to give good test

00:18:02,110 --> 00:18:05,500
output and maybe this is something

00:18:03,220 --> 00:18:08,230
strange to think about so early but this

00:18:05,500 --> 00:18:10,630
is always a really important thing that

00:18:08,230 --> 00:18:13,600
I was thinking about as I was working on

00:18:10,630 --> 00:18:17,290
this because exception safety is hard

00:18:13,600 --> 00:18:20,170
and like debugging exception safety bugs

00:18:17,290 --> 00:18:21,760
is hard it's annoying you have to trace

00:18:20,170 --> 00:18:23,140
them all over the place there it's just

00:18:21,760 --> 00:18:25,720
really difficult to figure out what's

00:18:23,140 --> 00:18:28,630
going on so we want to make sure that we

00:18:25,720 --> 00:18:31,000
are able to give maximal information to

00:18:28,630 --> 00:18:33,220
the user of our test code when their

00:18:31,000 --> 00:18:35,670
test fails to be actually able to see

00:18:33,220 --> 00:18:37,810
what's going on and thankfully we can

00:18:35,670 --> 00:18:40,000
pretty easily start to get some

00:18:37,810 --> 00:18:41,890
information out specifically the real

00:18:40,000 --> 00:18:43,270
interface is a macro and the only reason

00:18:41,890 --> 00:18:46,630
you use a macro is now you can get

00:18:43,270 --> 00:18:48,220
function and line information you know

00:18:46,630 --> 00:18:50,080
you can use like pretty function or

00:18:48,220 --> 00:18:52,150
whatever and in different compilers to

00:18:50,080 --> 00:18:55,060
get a more complete signature but this

00:18:52,150 --> 00:18:57,820
at least will tell you what function

00:18:55,060 --> 00:18:59,620
through and that's that's at least a

00:18:57,820 --> 00:19:01,230
start now you can at least eliminate all

00:18:59,620 --> 00:19:04,620
the code that isn't that function

00:19:01,230 --> 00:19:06,179
code base from being a problem awesome

00:19:04,620 --> 00:19:08,190
so there's another half to this and

00:19:06,179 --> 00:19:10,679
that's test fake so we need a test fake

00:19:08,190 --> 00:19:13,830
that actually uses maybe throw and talks

00:19:10,679 --> 00:19:15,480
to the global that global end so this is

00:19:13,830 --> 00:19:17,730
pretty much again what Abraham's wrote

00:19:15,480 --> 00:19:19,290
we have a throwing value it's a value

00:19:17,730 --> 00:19:20,460
type that has all the value semantics

00:19:19,290 --> 00:19:21,840
you would have so it has all the special

00:19:20,460 --> 00:19:23,610
member functions it has all the

00:19:21,840 --> 00:19:25,679
comparison functions it has arithmetic

00:19:23,610 --> 00:19:27,990
functions it has you know anything that

00:19:25,679 --> 00:19:29,730
you would expect from a type that you're

00:19:27,990 --> 00:19:32,309
using in generic code this thing

00:19:29,730 --> 00:19:34,590
implements and basically everything

00:19:32,309 --> 00:19:36,510
calls may be throw before it actually

00:19:34,590 --> 00:19:39,150
does the thing you wanted it to do so

00:19:36,510 --> 00:19:41,520
that way you can use this in generic

00:19:39,150 --> 00:19:43,919
code to send you to be able to find

00:19:41,520 --> 00:19:45,960
every single possible exception that

00:19:43,919 --> 00:19:49,620
could possibly be thrown in this

00:19:45,960 --> 00:19:52,830
function something you might have

00:19:49,620 --> 00:19:55,740
noticed is that we have a pointer as our

00:19:52,830 --> 00:19:57,150
state this gets to one of the really

00:19:55,740 --> 00:19:59,070
important techniques we're going to be

00:19:57,150 --> 00:20:02,390
using for exception safety testing which

00:19:59,070 --> 00:20:05,820
is we're going to lean on our tooling

00:20:02,390 --> 00:20:07,559
exception safety bugs are almost always

00:20:05,820 --> 00:20:09,750
some kind of undefined behavior not

00:20:07,559 --> 00:20:13,650
always but they are either undefined

00:20:09,750 --> 00:20:15,270
behavior or really close to it so it's

00:20:13,650 --> 00:20:18,330
really important for us to be able to

00:20:15,270 --> 00:20:19,830
leverage our tooling in a way to help us

00:20:18,330 --> 00:20:22,559
to deal with us on the fun behavior so

00:20:19,830 --> 00:20:24,419
in this way we every time we create a

00:20:22,559 --> 00:20:26,070
throwing value we allocate this end and

00:20:24,419 --> 00:20:28,169
then if a throwing value is ever not

00:20:26,070 --> 00:20:29,850
destroyed and not cleaned up we have

00:20:28,169 --> 00:20:31,410
this heap allocation sitting around that

00:20:29,850 --> 00:20:33,030
valgrind or else in or any of those

00:20:31,410 --> 00:20:35,010
sorts of tools can yellow doesn't say

00:20:33,030 --> 00:20:37,799
hey you'll each this thing something

00:20:35,010 --> 00:20:40,020
went wrong as it turns out this doesn't

00:20:37,799 --> 00:20:41,880
actually work I was able to defeat all

00:20:40,020 --> 00:20:43,620
sorts of sanitizers when using this sort

00:20:41,880 --> 00:20:45,299
of strategy because undefined behavior

00:20:43,620 --> 00:20:47,030
is weird different optimization settings

00:20:45,299 --> 00:20:50,070
cause different things to be destroyed

00:20:47,030 --> 00:20:52,440
but thankfully we can do a little bit

00:20:50,070 --> 00:20:54,299
better than this I'm not going to go

00:20:52,440 --> 00:20:56,910
into too much detail but you have this

00:20:54,299 --> 00:20:59,130
tracked object that basically means that

00:20:56,910 --> 00:21:01,230
when you construct a throwing value you

00:20:59,130 --> 00:21:02,880
have a global set that says hey I

00:21:01,230 --> 00:21:05,130
constructed a throwing value at this

00:21:02,880 --> 00:21:07,140
address from this function you give all

00:21:05,130 --> 00:21:09,090
this information in the set about

00:21:07,140 --> 00:21:11,340
in the set entry about how was this

00:21:09,090 --> 00:21:13,050
thing made and then you just have this

00:21:11,340 --> 00:21:14,040
you know this local int state and you

00:21:13,050 --> 00:21:18,210
don't have any undefined behavior

00:21:14,040 --> 00:21:19,980
anymore so now you have slowly reduced

00:21:18,210 --> 00:21:22,680
your reliance on tools you can't get rid

00:21:19,980 --> 00:21:25,020
of your reliance on tools but avoiding

00:21:22,680 --> 00:21:27,710
undefined behavior as much as possible

00:21:25,020 --> 00:21:29,880
you can't do it 100% really important

00:21:27,710 --> 00:21:32,540
all right so now this is the actual

00:21:29,880 --> 00:21:34,680
algorithm we use and it's kind of I

00:21:32,540 --> 00:21:36,030
think some people might have seen where

00:21:34,680 --> 00:21:39,000
we're going with it but we have we just

00:21:36,030 --> 00:21:41,700
start with the first exception try to

00:21:39,000 --> 00:21:43,410
call the up and if it's successful we're

00:21:41,700 --> 00:21:45,330
done we're out of exceptions if it fails

00:21:43,410 --> 00:21:46,710
then we take all of these contracts

00:21:45,330 --> 00:21:49,110
these predicates so that we get passed

00:21:46,710 --> 00:21:50,430
in and these contracts basically test

00:21:49,110 --> 00:21:52,530
the different invariants of the type

00:21:50,430 --> 00:21:54,840
they test function post conditions

00:21:52,530 --> 00:21:55,950
anything that you want to be true you

00:21:54,840 --> 00:21:58,110
can they can test for the strong

00:21:55,950 --> 00:22:00,600
guarantee anything you want to be true

00:21:58,110 --> 00:22:02,820
after an exception was propagated you

00:22:00,600 --> 00:22:05,490
can test and if any of them fail you

00:22:02,820 --> 00:22:06,840
it's false and I'm deliberately being

00:22:05,490 --> 00:22:09,840
vague about what these look like because

00:22:06,840 --> 00:22:12,210
I'm going to talk about that later and

00:22:09,840 --> 00:22:13,860
there's this little dance between the

00:22:12,210 --> 00:22:15,810
global count and the local count that's

00:22:13,860 --> 00:22:17,190
kind of like it I feel like it takes

00:22:15,810 --> 00:22:18,690
like a little double take to actually

00:22:17,190 --> 00:22:20,250
figure out what's going on at least I

00:22:18,690 --> 00:22:21,740
had so like sit and think about it for a

00:22:20,250 --> 00:22:23,880
couple of minutes when I first saw this

00:22:21,740 --> 00:22:26,370
but as everyone kind of understand

00:22:23,880 --> 00:22:27,990
what's going on here we're sitting first

00:22:26,370 --> 00:22:32,130
second third exception that's what we're

00:22:27,990 --> 00:22:34,050
doing okay so what about nested try

00:22:32,130 --> 00:22:36,420
catch this is one of the first issues

00:22:34,050 --> 00:22:40,710
that came up is if you have an operation

00:22:36,420 --> 00:22:42,330
that catches exceptions internally this

00:22:40,710 --> 00:22:44,160
doesn't actually help us test it and

00:22:42,330 --> 00:22:46,350
this is a really important thing to note

00:22:44,160 --> 00:22:49,740
you have to test your error handling

00:22:46,350 --> 00:22:51,240
code even if a propagation doesn't it

00:22:49,740 --> 00:22:52,710
enough an exception doesn't propagate

00:22:51,240 --> 00:22:54,270
out of the interface doesn't mean that

00:22:52,710 --> 00:22:56,850
your error handling codes still can't

00:22:54,270 --> 00:22:59,880
mess everything up so what we've really

00:22:56,850 --> 00:23:02,430
done here the the really salient part of

00:22:59,880 --> 00:23:04,230
this whole idea is deterministic error

00:23:02,430 --> 00:23:06,330
injection we can say hey I want these

00:23:04,230 --> 00:23:08,360
errors right now right now right now

00:23:06,330 --> 00:23:11,220
right now and you can actually

00:23:08,360 --> 00:23:12,660
deterministically and easily test your

00:23:11,220 --> 00:23:14,130
error handling code and make sure that

00:23:12,660 --> 00:23:14,759
you're actually getting back to a state

00:23:14,130 --> 00:23:17,879
that you want

00:23:14,759 --> 00:23:20,339
to be in but we can't do that if up has

00:23:17,879 --> 00:23:21,389
an internal try-catch in order to fix

00:23:20,339 --> 00:23:23,369
this I'm going to have to go back to

00:23:21,389 --> 00:23:24,989
maybe throw so this is what maybe throat

00:23:23,369 --> 00:23:31,489
looks like there's no changes on this

00:23:24,989 --> 00:23:34,649
slide this is what we had before so now

00:23:31,489 --> 00:23:36,989
we do this instead of actually relying

00:23:34,649 --> 00:23:38,579
on the exception that we throw we have

00:23:36,989 --> 00:23:40,709
another global which we just like a

00:23:38,579 --> 00:23:42,389
singleton that we can notify hey an

00:23:40,709 --> 00:23:44,999
error went wrong here's what happened

00:23:42,389 --> 00:23:46,619
and again we take the opportunity to put

00:23:44,999 --> 00:23:48,929
the message in there so that we get as

00:23:46,619 --> 00:23:51,389
rich of test failure output as possible

00:23:48,929 --> 00:23:52,799
now we still need to throw the exception

00:23:51,389 --> 00:23:54,149
so we can satisfy our interface we have

00:23:52,799 --> 00:23:56,339
an alligator and used to throw bad a

00:23:54,149 --> 00:23:59,190
lock whatever but we don't actually rely

00:23:56,339 --> 00:24:01,229
on that for the exit condition of our

00:23:59,190 --> 00:24:03,389
loop so now we go back to the loop this

00:24:01,229 --> 00:24:05,339
is what it looks like before and now it

00:24:03,389 --> 00:24:07,109
looks like this our try catch block is

00:24:05,339 --> 00:24:08,309
basically just empty we just have to

00:24:07,109 --> 00:24:10,440
wrap it and try catch so we don't

00:24:08,309 --> 00:24:12,169
accidentally like propagate an exception

00:24:10,440 --> 00:24:15,269
all the way up and kill our test and

00:24:12,169 --> 00:24:17,639
then we just you know ask our error

00:24:15,269 --> 00:24:19,469
tracker I did anything happen yeah say

00:24:17,639 --> 00:24:21,479
okay let's test our contracts no all

00:24:19,469 --> 00:24:23,579
right we're done our operation was

00:24:21,479 --> 00:24:25,349
successful there were no internal

00:24:23,579 --> 00:24:26,959
exceptions that were caught and this

00:24:25,349 --> 00:24:31,940
deals with nested try catch really well

00:24:26,959 --> 00:24:31,940
awesome so let's see what else we can do

00:24:32,719 --> 00:24:37,199
what about the basic guarantee remember

00:24:35,279 --> 00:24:39,839
I said about the basic guarantee that

00:24:37,199 --> 00:24:44,219
the most salient point is that you can

00:24:39,839 --> 00:24:49,799
call reset on the object and get back to

00:24:44,219 --> 00:24:52,709
a known state so look at test safety now

00:24:49,799 --> 00:24:54,389
we are running all of these contracts

00:24:52,709 --> 00:24:56,669
all in a row on the same tea that we

00:24:54,389 --> 00:24:58,319
were testing and the problem is one of

00:24:56,669 --> 00:25:02,599
these contracts is probably going to

00:24:58,319 --> 00:25:05,579
want to take that thing and reset it and

00:25:02,599 --> 00:25:07,049
check to make sure that you're in a

00:25:05,579 --> 00:25:08,639
known state and you definitely don't

00:25:07,049 --> 00:25:10,199
want to impose some kind of ordering

00:25:08,639 --> 00:25:13,379
restriction on what contracts are passed

00:25:10,199 --> 00:25:15,929
also important to note you can't take

00:25:13,379 --> 00:25:17,639
this by value and copy it because you

00:25:15,929 --> 00:25:18,090
don't know if that thing is even in a

00:25:17,639 --> 00:25:20,549
Val

00:25:18,090 --> 00:25:22,950
state to be able to be copied so this

00:25:20,549 --> 00:25:27,270
has to actually be taking by mutable

00:25:22,950 --> 00:25:29,820
reference so once one of these contracts

00:25:27,270 --> 00:25:31,650
modifies your thing and sets it to a

00:25:29,820 --> 00:25:33,059
known state every other predicate you're

00:25:31,650 --> 00:25:34,890
passing to it is useless because you're

00:25:33,059 --> 00:25:36,210
just like oh you're testing the default

00:25:34,890 --> 00:25:40,980
constructed state but that's not what

00:25:36,210 --> 00:25:44,549
we're trying to do so instead we for

00:25:40,980 --> 00:25:46,710
every predicate for every contract we

00:25:44,549 --> 00:25:49,830
make a new copy of our thing that was

00:25:46,710 --> 00:25:52,200
passed in and run our exception safety

00:25:49,830 --> 00:25:55,110
test on that so now the are we're doing

00:25:52,200 --> 00:25:57,950
one test for every predicate for every

00:25:55,110 --> 00:26:01,380
exception it's important to note that

00:25:57,950 --> 00:26:02,789
efficiency like speed is not the goal at

00:26:01,380 --> 00:26:04,919
all with this we're talking about

00:26:02,789 --> 00:26:07,620
correctness and exhaustive Ness

00:26:04,919 --> 00:26:09,870
not speed these things these tests will

00:26:07,620 --> 00:26:16,470
commonly throw like tens of thousands of

00:26:09,870 --> 00:26:19,140
exceptions yeah question yeah that is a

00:26:16,470 --> 00:26:20,580
typo in the slide and that is I thought

00:26:19,140 --> 00:26:24,120
I fixed that yesterday but apparently

00:26:20,580 --> 00:26:26,549
not sorry so the question is shouldn't I

00:26:24,120 --> 00:26:28,020
run the operation on the copy and the

00:26:26,549 --> 00:26:29,730
answer is yes I should and that's a typo

00:26:28,020 --> 00:26:30,270
on the slide so thank you very much for

00:26:29,730 --> 00:26:33,090
pointing that out

00:26:30,270 --> 00:26:35,159
that should say op of copy in fact it

00:26:33,090 --> 00:26:37,140
says T get which isn't even which is

00:26:35,159 --> 00:26:54,000
kind of betraying where I'm going in the

00:26:37,140 --> 00:26:56,250
next slide but yeah another question yes

00:26:54,000 --> 00:26:57,480
so good question the question was at the

00:26:56,250 --> 00:26:59,940
point where we make the copy

00:26:57,480 --> 00:27:01,380
are we running the risk of trip of

00:26:59,940 --> 00:27:04,470
tripping up maybe throw and the answer

00:27:01,380 --> 00:27:06,030
is no because we don't actually set the

00:27:04,470 --> 00:27:07,590
global throw count until right when

00:27:06,030 --> 00:27:09,990
we're about to call the operation after

00:27:07,590 --> 00:27:12,240
the operation either the throw count is

00:27:09,990 --> 00:27:13,770
negative because we threw or the

00:27:12,240 --> 00:27:15,990
operation was successful in which case

00:27:13,770 --> 00:27:18,060
we don't repeat the loop so actually

00:27:15,990 --> 00:27:19,320
this is safe and it's a really subtlety

00:27:18,060 --> 00:27:22,320
and implementing this is making sure

00:27:19,320 --> 00:27:24,240
that you don't do anything like the very

00:27:22,320 --> 00:27:26,640
last thing you do before you call up is

00:27:24,240 --> 00:27:29,340
to set the global counter so you do as a

00:27:26,640 --> 00:27:32,250
minimum work as possible under the under

00:27:29,340 --> 00:27:33,270
this maybe throw mechanism thank you

00:27:32,250 --> 00:27:37,800
thank you for the question

00:27:33,270 --> 00:27:39,780
thank you as well great so now we're

00:27:37,800 --> 00:27:41,250
doing each contract and notice the

00:27:39,780 --> 00:27:43,020
Google style here we're passing by

00:27:41,250 --> 00:27:46,200
pointer to indicate that the contract

00:27:43,020 --> 00:27:48,900
may may mutate the input argument so

00:27:46,200 --> 00:27:50,430
that's what that's all about great so

00:27:48,900 --> 00:27:52,230
now we can actually test the basic

00:27:50,430 --> 00:27:54,930
guarantee we couldn't before because we

00:27:52,230 --> 00:27:56,840
couldn't reset and check against a known

00:27:54,930 --> 00:27:59,060
state that would have been terrible

00:27:56,840 --> 00:28:01,530
great so what else

00:27:59,060 --> 00:28:03,510
what about move only types what about

00:28:01,530 --> 00:28:06,120
types that aren't copyable we're just

00:28:03,510 --> 00:28:08,220
making a copy of our T well what if T is

00:28:06,120 --> 00:28:09,780
a unique pointer what if T is a thing

00:28:08,220 --> 00:28:12,150
that can't be copied what if we want to

00:28:09,780 --> 00:28:14,210
test like some server or singleton or

00:28:12,150 --> 00:28:16,170
something that can't logically be copied

00:28:14,210 --> 00:28:19,160
this is pretty easy to deal with

00:28:16,170 --> 00:28:21,720
we just operate in terms of factories a

00:28:19,160 --> 00:28:24,330
factory you know we like to have it spit

00:28:21,720 --> 00:28:25,890
out a unique pointer so that way if you

00:28:24,330 --> 00:28:26,940
know we can just move it around and not

00:28:25,890 --> 00:28:28,890
have to worry about the actual

00:28:26,940 --> 00:28:31,560
properties at the type and then unwrap

00:28:28,890 --> 00:28:33,300
it when we check the contracts and you

00:28:31,560 --> 00:28:35,430
can imagine a little wrapper function

00:28:33,300 --> 00:28:37,020
around this that takes a T and you know

00:28:35,430 --> 00:28:39,240
makes a little lambda that spits out a

00:28:37,020 --> 00:28:41,940
unique pointer with the teeth to make it

00:28:39,240 --> 00:28:43,920
a little easier to use at this point

00:28:41,940 --> 00:28:45,840
this is this is basically algorithm this

00:28:43,920 --> 00:28:47,430
is this is where we're at right now and

00:28:45,840 --> 00:28:49,350
this is like I said this isn't even this

00:28:47,430 --> 00:28:51,300
error tracker stuff is still not even

00:28:49,350 --> 00:28:53,700
implemented like we're still learning

00:28:51,300 --> 00:28:55,290
about all of this so there are very

00:28:53,700 --> 00:28:57,600
likely things that we haven't thought

00:28:55,290 --> 00:28:59,900
about in all of this this is the state

00:28:57,600 --> 00:29:02,080
of where we are right now

00:28:59,900 --> 00:29:05,360
great

00:29:02,080 --> 00:29:09,440
we're doing with that part that has a

00:29:05,360 --> 00:29:11,120
lot of code and it seems like everyone

00:29:09,440 --> 00:29:13,789
has some kind of handles what's going on

00:29:11,120 --> 00:29:15,770
I'm happy the questions are being asked

00:29:13,789 --> 00:29:18,110
is anybody have any more questions about

00:29:15,770 --> 00:29:28,250
that before I keep going yeah here's

00:29:18,110 --> 00:29:29,899
question well um so the question is why

00:29:28,250 --> 00:29:33,529
do we only check the contract after the

00:29:29,899 --> 00:29:35,270
failure and the answer is that you

00:29:33,529 --> 00:29:37,429
should already have other unit tests

00:29:35,270 --> 00:29:46,130
that deal with the post conditions of a

00:29:37,429 --> 00:29:48,049
successful operation so that the

00:29:46,130 --> 00:29:50,090
question is about internal try/catch and

00:29:48,049 --> 00:29:51,289
that is what about internal try-catch

00:29:50,090 --> 00:29:54,260
and that's why we have that error

00:29:51,289 --> 00:29:55,940
tracker we don't actually branch on

00:29:54,260 --> 00:29:57,409
whether the operation was a successful

00:29:55,940 --> 00:30:00,409
we branch on whether or not the error

00:29:57,409 --> 00:30:02,059
tracker saw anything so even if there is

00:30:00,409 --> 00:30:03,830
a maybe throw that is internally caught

00:30:02,059 --> 00:30:06,679
by the operation it'll still notify our

00:30:03,830 --> 00:30:09,049
error tracker and that way we know that

00:30:06,679 --> 00:30:16,429
we need to run the operation again cool

00:30:09,049 --> 00:30:18,140
um you had a question ok so here so so

00:30:16,429 --> 00:30:19,669
let me go through so the question is can

00:30:18,140 --> 00:30:21,500
you explain the mechanism of throw count

00:30:19,669 --> 00:30:23,210
let me can if I go through like one

00:30:21,500 --> 00:30:27,080
iteration of this would that help like

00:30:23,210 --> 00:30:28,730
kind of step by step great ok so so one

00:30:27,080 --> 00:30:31,520
iteration of this so the first iteration

00:30:28,730 --> 00:30:34,520
we set throw count to zero

00:30:31,520 --> 00:30:36,350
because that's what our that's what our

00:30:34,520 --> 00:30:41,600
for loop says and we go back to a slide

00:30:36,350 --> 00:30:46,789
that has maybe thrown it great but this

00:30:41,600 --> 00:30:51,200
can throw small small slide problems so

00:30:46,789 --> 00:30:54,770
so throw count is zero so now our test

00:30:51,200 --> 00:30:57,110
fake will be copied or something the

00:30:54,770 --> 00:31:00,980
operation will do something to our test

00:30:57,110 --> 00:31:03,169
fake T is is typically here this T will

00:31:00,980 --> 00:31:05,059
be like a vector where we have our test

00:31:03,169 --> 00:31:07,100
fakes in it or it will be the test fake

00:31:05,059 --> 00:31:08,600
itself or something where it's using the

00:31:07,100 --> 00:31:09,809
test fake in order to hook into all of

00:31:08,600 --> 00:31:11,370
this

00:31:09,809 --> 00:31:13,350
so we do our operation maybe our

00:31:11,370 --> 00:31:15,419
operation is pushed back push back is

00:31:13,350 --> 00:31:18,380
going to want to copy Artie and the copy

00:31:15,419 --> 00:31:22,140
constructor of the test fake will call

00:31:18,380 --> 00:31:24,090
maybe throw I wasn't expecting to link

00:31:22,140 --> 00:31:26,370
dance around the slides like this yeah

00:31:24,090 --> 00:31:28,650
so the copy constructor will call maybe

00:31:26,370 --> 00:31:31,100
throw before it does the copy and checks

00:31:28,650 --> 00:31:33,870
the throw count which is at zero and

00:31:31,100 --> 00:31:35,760
says oh alright it's time to throw so I

00:31:33,870 --> 00:31:37,860
notify my error tracker something went

00:31:35,760 --> 00:31:43,350
wrong and then I throw the exception and

00:31:37,860 --> 00:31:46,799
then now and I test safety function we

00:31:43,350 --> 00:31:48,840
we check did error occur and it did we

00:31:46,799 --> 00:31:50,460
notified our tracker so now we go and

00:31:48,840 --> 00:31:52,650
check all of our contract or check our

00:31:50,460 --> 00:31:54,299
contracts and make sure that whatever

00:31:52,650 --> 00:31:55,710
precondition we were testing or

00:31:54,299 --> 00:31:58,860
invariant or whatever we were testing

00:31:55,710 --> 00:32:01,020
holds true so we do that for each

00:31:58,860 --> 00:32:03,539
contract we specified in turn and once

00:32:01,020 --> 00:32:06,809
that's done we bump up the throw count

00:32:03,539 --> 00:32:08,549
so what and so then we sent our internal

00:32:06,809 --> 00:32:09,929
count to one and now we do this all for

00:32:08,549 --> 00:32:11,909
the second exception which could be

00:32:09,929 --> 00:32:14,789
thrown and up and so on and so forth

00:32:11,909 --> 00:32:20,190
until no exceptions are thrown does that

00:32:14,789 --> 00:32:24,390
help awesome great do you do anything to

00:32:20,190 --> 00:32:27,380
ensure that for for all loops around

00:32:24,390 --> 00:32:29,850
contracts you actually get an exception

00:32:27,380 --> 00:32:33,750
because it seems like if count through

00:32:29,850 --> 00:32:35,850
at step zero it must have it that's good

00:32:33,750 --> 00:32:37,470
for the first contract and I really want

00:32:35,850 --> 00:32:39,240
it to throw it step zero again when I

00:32:37,470 --> 00:32:40,980
try to leave yeah throw count is set

00:32:39,240 --> 00:32:42,510
right before we do up so for the next

00:32:40,980 --> 00:32:44,669
contract we presented what if I'm

00:32:42,510 --> 00:32:48,780
non-deterministic in some way will this

00:32:44,669 --> 00:32:50,909
catch me in the contract so so if you

00:32:48,780 --> 00:32:52,590
not if you're non-deterministic in some

00:32:50,909 --> 00:32:55,020
way in your operation so this this

00:32:52,590 --> 00:32:56,340
framework doesn't protect you like

00:32:55,020 --> 00:32:58,500
doesn't magically solve the code

00:32:56,340 --> 00:33:00,330
coverage problem all it does is it

00:32:58,500 --> 00:33:02,250
allows you to deterministically inject

00:33:00,330 --> 00:33:04,980
errors you're still in charge of

00:33:02,250 --> 00:33:07,230
figuring out what operations to do to

00:33:04,980 --> 00:33:10,770
make sure that you cover all of the

00:33:07,230 --> 00:33:13,049
logical branches in your code no more

00:33:10,770 --> 00:33:15,470
questions yeah yeah you haven't asked a

00:33:13,049 --> 00:33:15,470
question yet

00:33:21,129 --> 00:33:25,399
well I mean the container could be the

00:33:23,570 --> 00:33:27,499
value and you could you you can do this

00:33:25,399 --> 00:33:28,940
this framework actually works even for

00:33:27,499 --> 00:33:31,009
non generic code that the question is

00:33:28,940 --> 00:33:32,389
this is only for throwing from things

00:33:31,009 --> 00:33:33,979
throwing from values what about

00:33:32,389 --> 00:33:36,440
containers data structures and the

00:33:33,979 --> 00:33:38,539
answer is yeah totally you can use maybe

00:33:36,440 --> 00:33:42,169
throw to build whatever test fake you

00:33:38,539 --> 00:33:43,999
want you can you can fake out you know a

00:33:42,169 --> 00:33:47,209
server that throws if it can't connect

00:33:43,999 --> 00:33:52,070
to the network or something like that so

00:33:47,209 --> 00:33:53,359
yeah this works for testing anything and

00:33:52,070 --> 00:33:55,309
I'll talk a little bit more about that

00:33:53,359 --> 00:33:56,529
later it's still a little bit of a pain

00:33:55,309 --> 00:34:03,289
point but we're working on it

00:33:56,529 --> 00:34:04,669
question over here yeah yes so it's a

00:34:03,289 --> 00:34:07,549
little bit of a weird dance so we have

00:34:04,669 --> 00:34:14,419
two counters we have throw count which

00:34:07,549 --> 00:34:19,909
is our global why you need to do many

00:34:14,419 --> 00:34:24,079
counts can-can you like like why are we

00:34:19,909 --> 00:34:27,440
doing the for loop okay so the reason is

00:34:24,079 --> 00:34:28,940
that we basically the the for loop

00:34:27,440 --> 00:34:31,309
counter is saying okay here's what we

00:34:28,940 --> 00:34:33,109
need to set our global counter to but

00:34:31,309 --> 00:34:35,990
that global counter we're constantly

00:34:33,109 --> 00:34:38,869
count decrementing downwards so we have

00:34:35,990 --> 00:34:40,970
to just save which and exception we're

00:34:38,869 --> 00:34:42,470
going to be throwing so this for loop is

00:34:40,970 --> 00:34:44,629
which exception number do I want to

00:34:42,470 --> 00:34:48,230
throw and then the implementation of

00:34:44,629 --> 00:34:51,200
that is okay set the global counter to n

00:34:48,230 --> 00:34:53,029
minus one and then and then run the

00:34:51,200 --> 00:34:55,490
operation and eventually the end maybe

00:34:53,029 --> 00:35:00,829
throw will trigger and throw an

00:34:55,490 --> 00:35:02,510
exception oh well let's say so you

00:35:00,829 --> 00:35:03,680
wouldn't actually as the user interact

00:35:02,510 --> 00:35:06,109
with count at all it's just an

00:35:03,680 --> 00:35:08,869
implementation detail all you do is

00:35:06,109 --> 00:35:11,900
provide a factory or a type and an

00:35:08,869 --> 00:35:13,549
operation and some contracts and the the

00:35:11,900 --> 00:35:15,829
global counter is just an implementation

00:35:13,549 --> 00:35:21,309
detail you you don't ever set that as

00:35:15,829 --> 00:35:21,309
the user of this does that make sense

00:35:22,930 --> 00:35:28,430
can I help

00:35:25,090 --> 00:35:31,250
Titus yeah I think from not being on

00:35:28,430 --> 00:35:33,650
stage I can read this one the issue is

00:35:31,250 --> 00:35:37,940
like for an operation like pushback that

00:35:33,650 --> 00:35:40,120
you might be testing there's n things

00:35:37,940 --> 00:35:43,460
that it does that could throw and you

00:35:40,120 --> 00:35:46,100
want to be sure that for each of those n

00:35:43,460 --> 00:35:48,650
things that it does that might throw we

00:35:46,100 --> 00:35:51,550
have tested that all of the invariants

00:35:48,650 --> 00:35:56,210
still hold and count there is

00:35:51,550 --> 00:35:59,390
effectively zero to n and we infer n by

00:35:56,210 --> 00:36:00,860
updating account continuously until we

00:35:59,390 --> 00:36:10,040
get through the operation with no

00:36:00,860 --> 00:36:11,870
exception ever throwing this will get

00:36:10,040 --> 00:36:14,420
you a hundred percent of the operations

00:36:11,870 --> 00:36:15,770
that can possibly throw yeah this will

00:36:14,420 --> 00:36:17,990
get you this will get you all of them

00:36:15,770 --> 00:36:19,700
with the caveat that Matt pointed out

00:36:17,990 --> 00:36:21,140
that you're still responsible for

00:36:19,700 --> 00:36:22,610
dealing with branches in your code this

00:36:21,140 --> 00:36:24,710
doesn't solve your code coverage issue

00:36:22,610 --> 00:36:26,450
it just solves the for the particular

00:36:24,710 --> 00:36:29,480
set of branches that this operation

00:36:26,450 --> 00:36:34,400
takes we will hit every single exception

00:36:29,480 --> 00:36:35,840
that could possibly be drawn alright any

00:36:34,400 --> 00:36:39,410
other questions okay

00:36:35,840 --> 00:36:41,870
thank you do you have any thoughts on

00:36:39,410 --> 00:36:43,880
how to catch problems that only occur

00:36:41,870 --> 00:36:46,970
when an exception is thrown while

00:36:43,880 --> 00:36:49,250
already handling another exception well

00:36:46,970 --> 00:36:52,550
so this is definitely in the vein of

00:36:49,250 --> 00:36:54,260
testing your error handling code so

00:36:52,550 --> 00:36:55,550
you're so you're talking about like if

00:36:54,260 --> 00:36:58,880
your catch block does something that

00:36:55,550 --> 00:37:02,120
throws an exception yeah so if your

00:36:58,880 --> 00:37:04,280
catch block also throws like a maybe

00:37:02,120 --> 00:37:07,370
throw and it won't ever deal with maybe

00:37:04,280 --> 00:37:10,430
throws so we can't set that up directly

00:37:07,370 --> 00:37:12,320
right now you can still test like post

00:37:10,430 --> 00:37:15,590
conditions on your error handling and I

00:37:12,320 --> 00:37:18,910
would imagine that we could possibly do

00:37:15,590 --> 00:37:21,280
something like having you know like a

00:37:18,910 --> 00:37:22,720
counters or something where we could do

00:37:21,280 --> 00:37:24,250
this recursively but that isn't

00:37:22,720 --> 00:37:35,049
something that I've explicitly dealt

00:37:24,250 --> 00:37:36,700
with you thanks all right one way yeah

00:37:35,049 --> 00:37:39,910
there were well so it doesn't right if

00:37:36,700 --> 00:37:41,049
all of the con we only return false I'm

00:37:39,910 --> 00:37:42,700
sorry the question is does a loop

00:37:41,049 --> 00:37:44,230
actually run more than one time because

00:37:42,700 --> 00:37:46,930
we have return false and a return true

00:37:44,230 --> 00:37:48,910
and we only return false if our pre if

00:37:46,930 --> 00:37:51,510
we had a contract that returned false

00:37:48,910 --> 00:37:54,970
otherwise if that contract returns true

00:37:51,510 --> 00:37:59,559
that's then we just go to the next

00:37:54,970 --> 00:38:01,480
iteration of the inner loop cool so is

00:37:59,559 --> 00:38:03,460
everyone any more questions I know this

00:38:01,480 --> 00:38:06,130
is like kind of there's a lot going on

00:38:03,460 --> 00:38:09,760
here going once

00:38:06,130 --> 00:38:13,420
Buhler all right cool

00:38:09,760 --> 00:38:15,039
so let's move on thank you for all the

00:38:13,420 --> 00:38:16,510
questions I'm actually really happy that

00:38:15,039 --> 00:38:21,880
a lot of questions are being asked great

00:38:16,510 --> 00:38:24,069
for me so now let's talk about actually

00:38:21,880 --> 00:38:25,869
writing exception safety tests this is

00:38:24,069 --> 00:38:28,270
we have an algorithm but now we need

00:38:25,869 --> 00:38:29,650
sets of best practices and sets of

00:38:28,270 --> 00:38:32,529
considerations for what we're thinking

00:38:29,650 --> 00:38:33,640
about writing these tests so what do I

00:38:32,529 --> 00:38:35,859
test this is a really reasonable

00:38:33,640 --> 00:38:38,440
question to ask right you don't need to

00:38:35,859 --> 00:38:40,420
test everything in your code base for

00:38:38,440 --> 00:38:42,010
exception safety like no except function

00:38:40,420 --> 00:38:43,990
probably don't not forget what that

00:38:42,010 --> 00:38:45,460
tests those like stuff that's doing

00:38:43,990 --> 00:38:47,230
simple arithmetic like there's there's a

00:38:45,460 --> 00:38:48,789
lot of stuff that you just don't need to

00:38:47,230 --> 00:38:51,069
test for exception safety which is good

00:38:48,789 --> 00:38:52,089
news but anything which allocates you

00:38:51,069 --> 00:38:55,359
might want to think about testing for

00:38:52,089 --> 00:38:57,700
exception safety you know you're just

00:38:55,359 --> 00:38:59,619
one you know weird you know signed

00:38:57,700 --> 00:39:03,029
integer under flow away from trying to

00:38:59,619 --> 00:39:03,029
allocate billions of bytes of memory

00:39:03,060 --> 00:39:07,300
anything which calls a user-defined

00:39:05,260 --> 00:39:09,160
callback is a really good candidate for

00:39:07,300 --> 00:39:10,990
exception safety testing because unless

00:39:09,160 --> 00:39:14,530
you have it specified either by a no

00:39:10,990 --> 00:39:17,500
accept function pointer or by just

00:39:14,530 --> 00:39:19,329
implicit contract and your comment that

00:39:17,500 --> 00:39:21,460
hey this callable that you're passing me

00:39:19,329 --> 00:39:22,839
can't throw you need to deal with the

00:39:21,460 --> 00:39:25,750
possibility that the thing that you're

00:39:22,839 --> 00:39:27,940
being passed could just be throw I hate

00:39:25,750 --> 00:39:32,320
you exception and that's the whole body

00:39:27,940 --> 00:39:33,670
of the function and just generally

00:39:32,320 --> 00:39:44,260
anything which calls it potentially

00:39:33,670 --> 00:39:45,910
throwing out question in the audience so

00:39:44,260 --> 00:39:47,589
the question is you still might want to

00:39:45,910 --> 00:39:48,970
test know accept functions because the

00:39:47,589 --> 00:39:51,579
compiler doesn't verify and that's

00:39:48,970 --> 00:39:52,780
correct I really said no except

00:39:51,579 --> 00:39:54,400
functions because like if you've marked

00:39:52,780 --> 00:39:56,560
a thing no except normally you're you're

00:39:54,400 --> 00:39:59,109
pretty confident about it you know and

00:39:56,560 --> 00:40:00,670
and so there's like a hierarchy right

00:39:59,109 --> 00:40:02,440
like there are some things which you

00:40:00,670 --> 00:40:03,910
definitely want to test for exception

00:40:02,440 --> 00:40:06,010
safety like if you have your own vector

00:40:03,910 --> 00:40:08,170
class you should definitely test push

00:40:06,010 --> 00:40:09,849
back for exception safety you know if

00:40:08,170 --> 00:40:11,410
you have a no accept function that like

00:40:09,849 --> 00:40:13,359
you know maybe something's weird

00:40:11,410 --> 00:40:17,020
you know it's engineered discretion just

00:40:13,359 --> 00:40:18,250
like everything else awesome thanks so

00:40:17,020 --> 00:40:19,900
yeah anything which posed a potentially

00:40:18,250 --> 00:40:22,030
throwing function copy constructor is on

00:40:19,900 --> 00:40:23,800
generics anything like that you might

00:40:22,030 --> 00:40:25,569
want to consider testing and you again

00:40:23,800 --> 00:40:29,050
like I was saying you don't necessarily

00:40:25,569 --> 00:40:33,400
have to test everything but use your

00:40:29,050 --> 00:40:35,770
best judgment the other big deal is how

00:40:33,400 --> 00:40:38,200
do we write contracts in code I promised

00:40:35,770 --> 00:40:41,380
I would talk about this some contracts

00:40:38,200 --> 00:40:43,300
are really easy if you know if your

00:40:41,380 --> 00:40:45,069
pushback thing is actually there or not

00:40:43,300 --> 00:40:46,900
like that's really easy to test and in

00:40:45,069 --> 00:40:48,849
general anything which is assertable a

00:40:46,900 --> 00:40:50,859
type invariant these are really easy to

00:40:48,849 --> 00:40:53,589
write so like if you have a vector you

00:40:50,859 --> 00:40:55,930
know begin is less than end capacity is

00:40:53,589 --> 00:41:00,550
greater than or equal to size just basic

00:40:55,930 --> 00:41:02,890
sanity checks also we can attempt to

00:41:00,550 --> 00:41:04,750
reset or assign to a known value of

00:41:02,890 --> 00:41:07,390
hammer that's a bunch of times you know

00:41:04,750 --> 00:41:09,270
call dot reset assigned to a default

00:41:07,390 --> 00:41:10,560
constructed value and then

00:41:09,270 --> 00:41:13,200
make sure that your thing isn't

00:41:10,560 --> 00:41:15,000
completely borked contracts can of

00:41:13,200 --> 00:41:17,840
course also be friend functions if you

00:41:15,000 --> 00:41:21,000
want to test some sort of internal state

00:41:17,840 --> 00:41:22,680
the hard part is when you have some kind

00:41:21,000 --> 00:41:25,560
of external state something like a

00:41:22,680 --> 00:41:29,040
handle to an allocated resource anything

00:41:25,560 --> 00:41:30,570
which is like a span is our string view

00:41:29,040 --> 00:41:33,360
was a really great example where there's

00:41:30,570 --> 00:41:35,820
this implicit contract that the range of

00:41:33,360 --> 00:41:38,820
values that are pointed to are actually

00:41:35,820 --> 00:41:41,550
valid memory and there's no way to test

00:41:38,820 --> 00:41:43,830
this in c++ to say is this address valid

00:41:41,550 --> 00:41:45,300
memory that you can't do that I'm really

00:41:43,830 --> 00:41:48,300
hoping that that can be a thing if any

00:41:45,300 --> 00:41:50,070
of you didn't watch kostas arab Yanni's

00:41:48,300 --> 00:41:52,620
talk on memory tagging yesterday is

00:41:50,070 --> 00:41:54,820
really really cool and i suggest it to

00:41:52,620 --> 00:41:55,910
everybody and when it's on youtube

00:41:54,820 --> 00:41:58,350
[Music]

00:41:55,910 --> 00:42:00,720
otherwise though we have to rely on our

00:41:58,350 --> 00:42:04,590
tools a SAN is a particularly good tool

00:42:00,720 --> 00:42:06,180
for us it is basically gives us kind of

00:42:04,590 --> 00:42:08,040
a way to say hey check this memory and

00:42:06,180 --> 00:42:10,980
yell at me if it's wrong and I'll put up

00:42:08,040 --> 00:42:12,930
an example of this so here is a function

00:42:10,980 --> 00:42:15,420
called iterate and if you look at it you

00:42:12,930 --> 00:42:17,490
might be a little bit confused because

00:42:15,420 --> 00:42:22,170
it doesn't actually do anything it just

00:42:17,490 --> 00:42:25,140
loops over a sequence and returns true

00:42:22,170 --> 00:42:27,720
but the salient point is that we form a

00:42:25,140 --> 00:42:30,240
reference to potentially invalid memory

00:42:27,720 --> 00:42:31,980
the whole idea is that this vector might

00:42:30,240 --> 00:42:35,070
be in some state where we accidentally

00:42:31,980 --> 00:42:37,320
gained access to invalid memory because

00:42:35,070 --> 00:42:39,480
maybe we updated size before we actually

00:42:37,320 --> 00:42:40,860
added an element to the back and but

00:42:39,480 --> 00:42:42,630
then that through but we have ever moved

00:42:40,860 --> 00:42:45,090
size back so now we get one extra thing

00:42:42,630 --> 00:42:46,800
at the end of garbage memory so we form

00:42:45,090 --> 00:42:49,590
a reference to potentially invalid

00:42:46,800 --> 00:42:52,110
memory and then we read from it and we

00:42:49,590 --> 00:42:53,760
have this testing do not optimize line

00:42:52,110 --> 00:42:55,590
at the top this is from Google test

00:42:53,760 --> 00:42:57,150
which basically says compiler don't

00:42:55,590 --> 00:42:59,280
optimize this away you have to actually

00:42:57,150 --> 00:43:02,010
you can't say I'm not using some and

00:42:59,280 --> 00:43:04,290
then ignore all of this so you just read

00:43:02,010 --> 00:43:06,450
from the memory just do something with

00:43:04,290 --> 00:43:09,990
it to give and then you run this loop in

00:43:06,450 --> 00:43:12,090
your binary under a sin so that way if

00:43:09,990 --> 00:43:12,470
you ever end up trying to read from in

00:43:12,090 --> 00:43:14,690
Val

00:43:12,470 --> 00:43:16,340
memory Aysen yells at you and says hey

00:43:14,690 --> 00:43:18,500
right there that's bad kills your

00:43:16,340 --> 00:43:21,170
process and you have a really loud

00:43:18,500 --> 00:43:23,030
message of what was going on so is this

00:43:21,170 --> 00:43:26,240
as nice as a you know pretty little test

00:43:23,030 --> 00:43:30,230
failure no is it better than a runtime

00:43:26,240 --> 00:43:31,340
error in production definitely so then

00:43:30,230 --> 00:43:34,910
you would use it like this this is a

00:43:31,340 --> 00:43:37,099
sample like invariance contract for a

00:43:34,910 --> 00:43:39,830
vector class this is all type invariance

00:43:37,099 --> 00:43:42,140
so size less than capacity you know

00:43:39,830 --> 00:43:44,930
begin and end is size is equal to size

00:43:42,140 --> 00:43:46,790
and now you establish that you're

00:43:44,930 --> 00:43:47,869
iterating your iterator isn't the way

00:43:46,790 --> 00:43:50,180
you iterate through this thing is

00:43:47,869 --> 00:43:51,800
somehow legit so you do this so you're

00:43:50,180 --> 00:43:53,930
now able to call or iterate function

00:43:51,800 --> 00:43:56,060
from the last slide check that all of

00:43:53,930 --> 00:43:58,520
the memory is you can't you don't have

00:43:56,060 --> 00:44:02,230
access to an initialized memory and then

00:43:58,520 --> 00:44:04,640
do the last thing reset and compare to a

00:44:02,230 --> 00:44:06,710
to a default constructed state and if

00:44:04,640 --> 00:44:10,340
all of those things pass then you're

00:44:06,710 --> 00:44:12,140
pretty sure that you are in a good state

00:44:10,340 --> 00:44:14,780
you obviously can't always be a hundred

00:44:12,140 --> 00:44:16,490
percent certain because there's there's

00:44:14,780 --> 00:44:20,030
potentially undefined behavior in this

00:44:16,490 --> 00:44:23,599
code and so you we again need to rely on

00:44:20,030 --> 00:44:25,430
our tooling to give a sensible behavior

00:44:23,599 --> 00:44:27,320
and undefined behavior that works for us

00:44:25,430 --> 00:44:29,780
and if your tooling doesn't do the thing

00:44:27,320 --> 00:44:31,880
you want it to do then the right next

00:44:29,780 --> 00:44:34,220
step is to file a bug against your tool

00:44:31,880 --> 00:44:34,970
maintainer and help everybody come up

00:44:34,220 --> 00:44:40,790
with better

00:44:34,970 --> 00:44:44,510
have-have better tooling better tests so

00:44:40,790 --> 00:44:47,869
John you might ask me this is all really

00:44:44,510 --> 00:44:50,180
great but you promised that I would you

00:44:47,869 --> 00:44:53,089
said that the goal of this talk would be

00:44:50,180 --> 00:44:55,580
that I can go home on my home go to work

00:44:53,089 --> 00:44:57,800
on Monday and say hey I'm gonna write an

00:44:55,580 --> 00:44:59,300
exception safety test but no one here

00:44:57,800 --> 00:45:00,680
wants to actually write that algorithm

00:44:59,300 --> 00:45:03,530
right like it's kind of hairy no one

00:45:00,680 --> 00:45:04,970
wants to write this well I've got good

00:45:03,530 --> 00:45:08,119
news because this is all gonna be in

00:45:04,970 --> 00:45:10,010
Google test it's currently in abseil

00:45:08,119 --> 00:45:11,570
internals it's not quite there yet but

00:45:10,010 --> 00:45:13,090
it will be in Google test very soon a

00:45:11,570 --> 00:45:15,220
couple of notes about that later

00:45:13,090 --> 00:45:17,170
so we have a bunch of test fakes which

00:45:15,220 --> 00:45:18,700
I'll talk about they're configurable to

00:45:17,170 --> 00:45:20,590
have different kind of type trade-serve

00:45:18,700 --> 00:45:22,660
dacotahs compile-time branching on type

00:45:20,590 --> 00:45:24,640
traits you can easily create an evil

00:45:22,660 --> 00:45:27,010
test fake that has the trait you mean we

00:45:24,640 --> 00:45:29,470
have value types we have evil allocators

00:45:27,010 --> 00:45:31,270
we even have an evil thing which is

00:45:29,470 --> 00:45:35,800
contextually convertible to bowl in the

00:45:31,270 --> 00:45:39,700
conversion of bowl froze never says you

00:45:35,800 --> 00:45:41,260
can't we also have testing facilities

00:45:39,700 --> 00:45:43,000
for most a member and free functions

00:45:41,260 --> 00:45:45,550
free functions also have concerns of

00:45:43,000 --> 00:45:47,320
acceptance safety typically functions

00:45:45,550 --> 00:45:48,760
which take an input range or like

00:45:47,320 --> 00:45:51,610
constructors which aren't free functions

00:45:48,760 --> 00:45:54,910
but are also a little weird we also can

00:45:51,610 --> 00:45:56,620
test those sorts of things so this is

00:45:54,910 --> 00:45:58,630
what we wanted in the beginning this

00:45:56,620 --> 00:46:00,430
isn't what it looks like this was the

00:45:58,630 --> 00:46:06,160
goal that I wanted in the very beginning

00:46:00,430 --> 00:46:08,050
of the talk so no let's see what we

00:46:06,160 --> 00:46:09,910
actually got I'm gonna give a test case

00:46:08,050 --> 00:46:11,800
the test cases in line vector pushback

00:46:09,910 --> 00:46:13,330
and line vector is a vector and app sale

00:46:11,800 --> 00:46:16,210
it's just like stood vector except it

00:46:13,330 --> 00:46:18,430
has a small buffer optimization push

00:46:16,210 --> 00:46:19,060
back has the strong guarantee if the

00:46:18,430 --> 00:46:21,250
type in it

00:46:19,060 --> 00:46:23,080
is no removable and otherwise gives the

00:46:21,250 --> 00:46:24,790
basic guarantee so this is what we're

00:46:23,080 --> 00:46:26,200
going for everyone kind of feel like

00:46:24,790 --> 00:46:31,450
this is pretty easy everyone know what

00:46:26,200 --> 00:46:34,960
we're doing here cool okay so let's talk

00:46:31,450 --> 00:46:37,900
about our test fakes first this is

00:46:34,960 --> 00:46:39,910
throwing value it is configurable at

00:46:37,900 --> 00:46:41,950
compiled time by this a new type spec

00:46:39,910 --> 00:46:43,360
which lets you say hey my thing is noth

00:46:41,950 --> 00:46:45,400
removable hey my thing is no throw

00:46:43,360 --> 00:46:47,830
copyable hey every operation on this

00:46:45,400 --> 00:46:49,120
throws throwing value has all the

00:46:47,830 --> 00:46:50,920
special member functions all the

00:46:49,120 --> 00:46:52,990
comparison functions all the arithmetic

00:46:50,920 --> 00:46:55,870
functions it has swap which is no except

00:46:52,990 --> 00:46:57,100
it also deletes operator ampersand &

00:46:55,870 --> 00:46:58,690
operator comma because if you're using

00:46:57,100 --> 00:47:03,030
ampersand & comma on generic types

00:46:58,690 --> 00:47:08,920
you're wrong anyways you just are okay

00:47:03,030 --> 00:47:11,020
Thank You Dennis and we have throwing

00:47:08,920 --> 00:47:12,850
Alec this is again a very evil allocator

00:47:11,020 --> 00:47:14,650
you can say is my allocator throwing or

00:47:12,850 --> 00:47:16,300
not so now you can test allocator aware

00:47:14,650 --> 00:47:17,590
containers and make sure that they're

00:47:16,300 --> 00:47:19,270
dealing with a potentially evil

00:47:17,590 --> 00:47:21,490
alligator and this is really important

00:47:19,270 --> 00:47:24,220
because at google our alligator doesn't

00:47:21,490 --> 00:47:24,730
throw but we still use alligator aware

00:47:24,220 --> 00:47:27,280
can

00:47:24,730 --> 00:47:28,810
so this allows us to actually deal with

00:47:27,280 --> 00:47:31,599
that without doing some weird like

00:47:28,810 --> 00:47:34,680
instrumenting malloc and weirdness that

00:47:31,599 --> 00:47:37,450
would be terrible and also throwing bull

00:47:34,680 --> 00:47:39,910
notice all of these inherent from

00:47:37,450 --> 00:47:41,440
tracked so all of these we actually test

00:47:39,910 --> 00:47:42,670
for weeks if you get to the end of your

00:47:41,440 --> 00:47:44,349
test and one of these things wasn't

00:47:42,670 --> 00:47:46,000
destroyed they'll get a helpful little

00:47:44,349 --> 00:47:47,349
error message saying hey the thing and

00:47:46,000 --> 00:47:52,869
address this that was constructed from

00:47:47,349 --> 00:47:54,849
this function was not destroyed testers

00:47:52,869 --> 00:47:56,530
so this is kind of the basic thing the

00:47:54,849 --> 00:47:58,150
basic building block of our exception

00:47:56,530 --> 00:48:00,040
safety testing these are basically

00:47:58,150 --> 00:48:01,030
provide a builder interface this is I'm

00:48:00,040 --> 00:48:02,290
not going to talk too much about this

00:48:01,030 --> 00:48:04,300
example cuz it's not really what it

00:48:02,290 --> 00:48:06,220
looks like but the idea is you create

00:48:04,300 --> 00:48:08,470
one tester which has the basics it has

00:48:06,220 --> 00:48:10,540
like your operation and like the type

00:48:08,470 --> 00:48:13,210
invariance and then from there you can

00:48:10,540 --> 00:48:15,700
customize a tester for each specific

00:48:13,210 --> 00:48:17,560
assertion and these are immutable so you

00:48:15,700 --> 00:48:19,570
never have to go through the test and

00:48:17,560 --> 00:48:21,160
say like what where that this that I did

00:48:19,570 --> 00:48:23,530
that that I did that these are immutable

00:48:21,160 --> 00:48:25,780
every operation on the tester returns a

00:48:23,530 --> 00:48:28,599
new tester that is identical except for

00:48:25,780 --> 00:48:30,339
some small change that you specified and

00:48:28,599 --> 00:48:32,140
so we'll look at how this looks now

00:48:30,339 --> 00:48:34,180
operations are the first thing that you

00:48:32,140 --> 00:48:36,010
can pass to a tester they are callable

00:48:34,180 --> 00:48:38,589
with the signature taking a t-star

00:48:36,010 --> 00:48:40,420
returning void where t is your type

00:48:38,589 --> 00:48:42,609
under test or you know a vector where

00:48:40,420 --> 00:48:44,550
the test fake or whatever typically

00:48:42,609 --> 00:48:48,880
they're lambdas or function pointers

00:48:44,550 --> 00:48:50,560
something some easy callable and you

00:48:48,880 --> 00:48:52,569
tell the tester that you're testing this

00:48:50,560 --> 00:48:54,550
operation with the tester with operation

00:48:52,569 --> 00:48:56,260
this returns a new tester with that

00:48:54,550 --> 00:48:58,690
operation in place and there's a nice

00:48:56,260 --> 00:49:00,430
little syntactic nicety where if you

00:48:58,690 --> 00:49:02,170
just want to test an op well like want

00:49:00,430 --> 00:49:03,609
to put one off your tester doesn't have

00:49:02,170 --> 00:49:06,280
an operation in it yet you just say dot

00:49:03,609 --> 00:49:07,569
test up if your tester has an operation

00:49:06,280 --> 00:49:09,099
in it already this will replace this

00:49:07,569 --> 00:49:12,250
will return a new one with the operation

00:49:09,099 --> 00:49:13,630
replaced this is so if you so it's so

00:49:12,250 --> 00:49:16,119
that at the calls that you use it you

00:49:13,630 --> 00:49:17,859
know what operation you have next we

00:49:16,119 --> 00:49:19,359
have initial values this is the t that

00:49:17,859 --> 00:49:21,400
would be passed in in our loop before

00:49:19,359 --> 00:49:22,780
you need to have somewhere to start this

00:49:21,400 --> 00:49:24,190
is also important if you want to test

00:49:22,780 --> 00:49:27,099
the strong guarantee because you need

00:49:24,190 --> 00:49:28,210
something to compare to at the end so

00:49:27,099 --> 00:49:30,099
there's two ways to do this you can

00:49:28,210 --> 00:49:32,319
either pass a t in directly with dot

00:49:30,099 --> 00:49:34,210
with initial value or if you have a type

00:49:32,319 --> 00:49:35,830
that isn't copyable or is move only or

00:49:34,210 --> 00:49:38,830
is somehow weird you

00:49:35,830 --> 00:49:42,010
can provide us a factory directly that

00:49:38,830 --> 00:49:44,020
returns a unique pointer of T and we'll

00:49:42,010 --> 00:49:46,090
just spit out the same thing every time

00:49:44,020 --> 00:49:47,890
and internally with initial value just

00:49:46,090 --> 00:49:49,510
creates a little factory and we don't

00:49:47,890 --> 00:49:53,880
ever work with values we only work with

00:49:49,510 --> 00:49:56,560
factories internally finally contracts

00:49:53,880 --> 00:49:58,630
contracts are cobbles that take a t-star

00:49:56,560 --> 00:50:00,220
and return an assertion result assertion

00:49:58,630 --> 00:50:02,140
result is a bull with an error message

00:50:00,220 --> 00:50:04,630
it's just a type that's built into

00:50:02,140 --> 00:50:06,190
Google tests so this is basically the

00:50:04,630 --> 00:50:08,770
version of the vector invariants that we

00:50:06,190 --> 00:50:11,020
had before but the big thing to notice

00:50:08,770 --> 00:50:13,270
is with using a certian result no we can

00:50:11,020 --> 00:50:19,620
stream in error messages and get back

00:50:13,270 --> 00:50:22,180
nice logs when we have a test failure so

00:50:19,620 --> 00:50:23,590
finally then we can use dot with

00:50:22,180 --> 00:50:25,420
contracts and this is a little bit

00:50:23,590 --> 00:50:27,970
different on a tester that take you can

00:50:25,420 --> 00:50:29,650
pass any number of contracts in one

00:50:27,970 --> 00:50:30,910
function call and this will give you

00:50:29,650 --> 00:50:34,720
back a new tester that has those

00:50:30,910 --> 00:50:36,130
contracts appended at the end and so now

00:50:34,720 --> 00:50:37,480
I'll show an actual example and this

00:50:36,130 --> 00:50:39,970
might answer any questions people have

00:50:37,480 --> 00:50:42,430
and then I'll take some questions so

00:50:39,970 --> 00:50:44,110
this is what we wanted this was what we

00:50:42,430 --> 00:50:45,400
wanted at the beginning I think what we

00:50:44,110 --> 00:50:47,680
ended up with is actually a lot better

00:50:45,400 --> 00:50:50,260
there's a lot less magic so this is the

00:50:47,680 --> 00:50:52,240
first the first half of the test for

00:50:50,260 --> 00:50:54,400
vector pushback so this is just pushed

00:50:52,240 --> 00:50:55,990
testing the basic guarantee for in line

00:50:54,400 --> 00:50:58,210
vector pushback we have our little

00:50:55,990 --> 00:50:59,230
pushback lambda we didn't have to use

00:50:58,210 --> 00:51:01,060
that we could use like a pointer to

00:50:59,230 --> 00:51:03,540
member push back but pointer to members

00:51:01,060 --> 00:51:07,030
or gross and weird if lambdas are easy

00:51:03,540 --> 00:51:08,830
so we just make a tester put in our

00:51:07,030 --> 00:51:11,140
vector and variants contract this is the

00:51:08,830 --> 00:51:13,240
invariance function from before load in

00:51:11,140 --> 00:51:15,280
with operation push back and call test

00:51:13,240 --> 00:51:16,840
it's right there easily read at the call

00:51:15,280 --> 00:51:19,600
site and it'll run the algorithm that I

00:51:16,840 --> 00:51:21,430
showed and then give you back a test

00:51:19,600 --> 00:51:23,200
pass if everything passed or a test

00:51:21,430 --> 00:51:25,050
failure with some nice output showing

00:51:23,200 --> 00:51:27,730
where you had an exception safety bug

00:51:25,050 --> 00:51:30,580
and we wanted to test that vector has

00:51:27,730 --> 00:51:33,490
the strong guarantee when our type is

00:51:30,580 --> 00:51:35,770
noth removable then we can now save a

00:51:33,490 --> 00:51:37,360
tester as a local variable we know that

00:51:35,770 --> 00:51:38,650
we want to always test the vector

00:51:37,360 --> 00:51:40,660
invariance and we know that we're always

00:51:38,650 --> 00:51:42,610
calling pushback so we load that into

00:51:40,660 --> 00:51:44,260
our tester and know we can reuse it for

00:51:42,610 --> 00:51:46,800
the first call that's what we had before

00:51:44,260 --> 00:51:48,510
we're just testing the basic

00:51:46,800 --> 00:51:51,540
give it an initial value with a vector

00:51:48,510 --> 00:51:53,070
of things or everything throws but now

00:51:51,540 --> 00:51:56,369
when we have a vector of things that has

00:51:53,070 --> 00:51:58,050
a no throw move we reuse the tester but

00:51:56,369 --> 00:51:59,520
give it an initial value of a vector

00:51:58,050 --> 00:52:01,410
with things that have no throw move and

00:51:59,520 --> 00:52:03,420
then put in an additional contract

00:52:01,410 --> 00:52:05,850
testing strong guarantee which is a

00:52:03,420 --> 00:52:07,710
little tag type that's built into the

00:52:05,850 --> 00:52:08,880
library and we'll just take care of all

00:52:07,710 --> 00:52:09,810
the mechanics of doing the strong

00:52:08,880 --> 00:52:12,330
guarantee for you

00:52:09,810 --> 00:52:13,500
turns out it's a little bit weird so

00:52:12,330 --> 00:52:15,150
this is it this is what it looks like

00:52:13,500 --> 00:52:16,950
this is how you write Google test we

00:52:15,150 --> 00:52:19,800
have a bunch of exception safety tests

00:52:16,950 --> 00:52:21,900
in absol ready you can go look at them

00:52:19,800 --> 00:52:24,869
they'll be named blah exception safety

00:52:21,900 --> 00:52:27,180
tests you see and you can see this in

00:52:24,869 --> 00:52:30,320
practice so are there any questions

00:52:27,180 --> 00:52:47,250
about this what this code is doing

00:52:30,320 --> 00:52:48,869
question right here yes yes so so so

00:52:47,250 --> 00:52:51,030
testing strong guarantee we'll use

00:52:48,869 --> 00:52:52,619
operator equals equals but the question

00:52:51,030 --> 00:52:53,850
is what about strong guarantee I said

00:52:52,619 --> 00:52:54,930
it's about the observable properties of

00:52:53,850 --> 00:52:56,940
the type and that's different for every

00:52:54,930 --> 00:52:59,850
test testing strong guarantee we'll use

00:52:56,940 --> 00:53:01,290
operator equals equals if you want to if

00:52:59,850 --> 00:53:03,240
you have a test that has a different

00:53:01,290 --> 00:53:04,859
logical state you want to test then you

00:53:03,240 --> 00:53:07,020
can just create a local in your test

00:53:04,859 --> 00:53:10,320
capture it by reference in your lambda

00:53:07,020 --> 00:53:12,060
and then compare however way you want to

00:53:10,320 --> 00:53:20,190
this thing that's your like you know

00:53:12,060 --> 00:53:22,770
Golden State yeah question over here we

00:53:20,190 --> 00:53:24,600
found a bunch in in so we have inline

00:53:22,770 --> 00:53:25,859
vector and a fixed array which is like

00:53:24,600 --> 00:53:27,359
inline vector with a small buffer

00:53:25,859 --> 00:53:29,369
optimization but it's the dynamically

00:53:27,359 --> 00:53:30,780
size and not resizable array CJ up here

00:53:29,369 --> 00:53:32,310
is basically rewritten the entire

00:53:30,780 --> 00:53:36,330
classes to get rid of all of our bugs

00:53:32,310 --> 00:53:39,270
and those we also found bugs in Lib

00:53:36,330 --> 00:53:41,250
stand C++ as stood any we also found a

00:53:39,270 --> 00:53:43,800
bunch of bugs and Lib stood C++ is two

00:53:41,250 --> 00:53:49,410
variant nothing in Lib C++ so awesome

00:53:43,800 --> 00:53:51,810
job module yeah right

00:53:49,410 --> 00:53:53,910
so yeah we found a bunch of real things

00:53:51,810 --> 00:53:56,340
we've also run into a bunch of defects

00:53:53,910 --> 00:53:57,140
in the standard just from like going

00:53:56,340 --> 00:53:58,940
through the

00:53:57,140 --> 00:54:00,619
around allocators and exceptions with a

00:53:58,940 --> 00:54:04,369
really fine-tooth comb

00:54:00,619 --> 00:54:10,069
so we've found real bugs with this any

00:54:04,369 --> 00:54:11,779
more questions cool great so a caveat

00:54:10,069 --> 00:54:14,059
this isn't a Google test yet Google test

00:54:11,779 --> 00:54:17,930
still has not dropped C++ 98 before it

00:54:14,059 --> 00:54:20,750
will very very soon and this library

00:54:17,930 --> 00:54:23,000
very much needs at least C++ 11 so once

00:54:20,750 --> 00:54:24,950
we have C++ 11 and are allowed to use it

00:54:23,000 --> 00:54:26,660
in Google tests this will come currently

00:54:24,950 --> 00:54:29,930
it's an app see internals that's a link

00:54:26,660 --> 00:54:32,390
to where this whole thing - where the

00:54:29,930 --> 00:54:33,859
actual the implementation is so once

00:54:32,390 --> 00:54:35,510
these slides go up on github you'll be

00:54:33,859 --> 00:54:36,829
able to then you'll be able to go and

00:54:35,510 --> 00:54:39,980
find it and take a look at the code

00:54:36,829 --> 00:54:41,500
yourself further work some further

00:54:39,980 --> 00:54:44,150
directions of work that we want to do

00:54:41,500 --> 00:54:45,589
okay I thought I said 11 seconds not 5

00:54:44,150 --> 00:54:49,190
minutes and 11 seconds that started to

00:54:45,589 --> 00:54:50,660
panic so further work using Google Mach

00:54:49,190 --> 00:54:52,130
to create test fakes I talked a little

00:54:50,660 --> 00:54:55,339
bit about how you can create your own

00:54:52,130 --> 00:54:58,579
test fakes using maybe throw we have

00:54:55,339 --> 00:55:00,289
that maybe throw macro in Google in this

00:54:58,579 --> 00:55:01,670
library so you could create your own

00:55:00,289 --> 00:55:03,380
test fix if you want but there's a lot

00:55:01,670 --> 00:55:05,809
of boilerplate to it it's kind of

00:55:03,380 --> 00:55:08,990
annoying to write we already have Gmail

00:55:05,809 --> 00:55:10,609
Google MA which will create do all the

00:55:08,990 --> 00:55:13,369
boilerplate for creating nice mocks for

00:55:10,609 --> 00:55:15,259
you so we'd like to be able to have jima

00:55:13,369 --> 00:55:16,849
also be able to create nice exception

00:55:15,259 --> 00:55:19,009
safety fakes for you without you having

00:55:16,849 --> 00:55:21,019
to write all the boilerplate

00:55:19,009 --> 00:55:23,569
we'd also like to test error code api's

00:55:21,019 --> 00:55:26,269
the really important part of this is

00:55:23,569 --> 00:55:29,480
that we're creating deterministic errors

00:55:26,269 --> 00:55:31,279
if you code to error code api's you

00:55:29,480 --> 00:55:32,630
still have error handling code and you

00:55:31,279 --> 00:55:34,579
still want to test that error handling

00:55:32,630 --> 00:55:36,079
code in a deterministic way so there's

00:55:34,579 --> 00:55:38,599
no reason where we couldn't use this

00:55:36,079 --> 00:55:41,180
same algorithm to test for code that

00:55:38,599 --> 00:55:46,069
uses expected or error codes or in even

00:55:41,180 --> 00:55:48,019
err know if you're so sadistic making

00:55:46,069 --> 00:55:49,700
built-in test fakes more exhaustive so

00:55:48,019 --> 00:55:50,990
those in configuration the Newman's we

00:55:49,700 --> 00:55:53,029
have for throwing value and throwing a

00:55:50,990 --> 00:55:55,279
lock are not exhaustive they only have

00:55:53,029 --> 00:55:56,599
the values that we needed to test abseil

00:55:55,279 --> 00:56:00,230
but there's no reason that we couldn't

00:55:56,599 --> 00:56:01,849
add everything else we need I also want

00:56:00,230 --> 00:56:03,980
to look at a fuzz testing like approach

00:56:01,849 --> 00:56:05,019
as you use something like a server like

00:56:03,980 --> 00:56:07,869
as you know

00:56:05,019 --> 00:56:10,599
throw can even be put into production

00:56:07,869 --> 00:56:12,249
code and turned on and off with with

00:56:10,599 --> 00:56:14,369
command-line switches if you need to

00:56:12,249 --> 00:56:18,429
actually test your real implementations

00:56:14,369 --> 00:56:19,869
and but if you have a big hierarchy of

00:56:18,429 --> 00:56:21,609
exception safety test they can take a

00:56:19,869 --> 00:56:23,559
long time our Android tests for things

00:56:21,609 --> 00:56:27,399
like optional and any will sometimes

00:56:23,559 --> 00:56:28,809
take a couple minutes to run so a fuzz

00:56:27,399 --> 00:56:31,479
testing like a pro tour instead of

00:56:28,809 --> 00:56:34,630
exhaustively taking every single error

00:56:31,479 --> 00:56:36,069
we somehow intelligently decide which

00:56:34,630 --> 00:56:39,339
ones do we want to take or even just

00:56:36,069 --> 00:56:42,159
randomly pick which error to report to

00:56:39,339 --> 00:56:43,719
make things not take so slow is another

00:56:42,159 --> 00:56:44,799
approach we'd like to look at and all

00:56:43,719 --> 00:56:46,419
that being said we're looking for

00:56:44,799 --> 00:56:47,589
contributors if you think this is really

00:56:46,419 --> 00:56:49,479
cool and you'd like to use it and we

00:56:47,589 --> 00:56:52,630
don't have a thing you'd like to have my

00:56:49,479 --> 00:56:54,699
emails on here hit me up make a PR on

00:56:52,630 --> 00:56:56,619
Google test we'd love to have other

00:56:54,699 --> 00:56:59,529
people come and thinking in this space

00:56:56,619 --> 00:57:02,409
we still have a lot to learn about it so

00:56:59,529 --> 00:57:06,849
please if you have ideas we want them we

00:57:02,409 --> 00:57:08,739
want them bring them on so the big point

00:57:06,849 --> 00:57:10,809
is that exception safety is a testable

00:57:08,739 --> 00:57:13,269
part of an API it's no different from

00:57:10,809 --> 00:57:15,099
your inputs your outputs anything else

00:57:13,269 --> 00:57:17,049
that you would specify that you would

00:57:15,099 --> 00:57:20,289
test you should do the same for your

00:57:17,049 --> 00:57:22,749
exception safety special thanks to Sam

00:57:20,289 --> 00:57:25,419
Ben zackin jelly jank CJ Johnson and NAT

00:57:22,749 --> 00:57:27,699
Calabrese in particular for all of their

00:57:25,419 --> 00:57:29,619
inspiration and perspiration with a lot

00:57:27,699 --> 00:57:31,719
of good ideas a lot of elbow grease a

00:57:29,619 --> 00:57:33,189
lot of work this would absolutely not

00:57:31,719 --> 00:57:36,069
have happened without them and also

00:57:33,189 --> 00:57:37,779
thanks to abseil and google for paying

00:57:36,069 --> 00:57:40,889
me a living to be a professional mad

00:57:37,779 --> 00:57:44,339
scientist and work on this for a year

00:57:40,889 --> 00:57:44,339
any more questions

00:57:47,890 --> 00:57:59,750
thank you we actually had one more

00:57:50,480 --> 00:58:01,310
question in the back yeah the motivation

00:57:59,750 --> 00:58:02,690
was releasing the question is what was

00:58:01,310 --> 00:58:04,610
the motivation for this the the

00:58:02,690 --> 00:58:06,500
motivation was because we don't use

00:58:04,610 --> 00:58:08,390
exceptions but we release tab so we want

00:58:06,500 --> 00:58:11,030
absolute to be usable in projects that

00:58:08,390 --> 00:58:13,010
do use exceptions so this is to help us

00:58:11,030 --> 00:58:15,890
actually like test and change our code

00:58:13,010 --> 00:58:18,010
in that way all right thank you very

00:58:15,890 --> 00:58:18,010
much

00:58:18,040 --> 00:58:22,820

YouTube URL: https://www.youtube.com/watch?v=XPzHNSUnTc4


