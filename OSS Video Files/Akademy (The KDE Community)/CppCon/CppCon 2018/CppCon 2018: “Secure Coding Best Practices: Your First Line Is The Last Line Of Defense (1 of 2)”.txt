Title: CppCon 2018: “Secure Coding Best Practices: Your First Line Is The Last Line Of Defense (1 of 2)”
Publication date: 2018-10-19
Playlist: CppCon 2018
Description: 
	http://CppCon.org

Matthew Butler “Secure Coding Best Practices: Your First Line Is The Last Line Of Defense (part 1 of 2)”
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Computer systems are under siege 24 hours a day, day in and day out. The critical security infrastructure designed to protect those systems, won't: 

* Perimeter security won't protect you. 
* Network analytics won't protect you. 
* Virus scanners won't protect you. 
* Even the users who should know better than to click on that too-good-to-be-true offer won't protect you. 

The other side has the best security hardware and software systems other people's money can buy and they have all the time in the world to find creative ways to defeat them. Meltdown and Spectre are prime examples of security vulnerabilities that have lurked dormant for decades. Or have they? If your systems are in any way connected to the outside world, the other side will get inside the wire on you. Know that going in. 

Whether you write applications, libraries or work in kernel code, the line of code you write today may very well be the vulnerability someone else finds tomorrow. By nature every code base contains hundreds of attack surfaces and it only takes one serious vulnerability to compromise your system. 

While Modern C++ is designed to be secure, the ways we use it often aren't. 


In part one of this talk we'll see: 

* How hackers think and how they identify weaknesses in our systems. 
* How to identify hidden attack surfaces, attack vectors and vulnerabilities in critical systems. 
* Where the most common vulnerabilities in Modern and classic C++ are and how to avoid them. 
* Why avoiding parts of the language doesn't help. 
* Where we can trade off security for performance. 

At the end of part one, we'll do a walkthrough of a classic buffer overflow exploit to see how it works and what we've added to the operating systems and compilers to protect against them. Then we'll use it live to run a privilege escalation exploit and gain admin access on a system. 


In part two, we'll see: 

* Why common guidelines and static analysis tools often fail to find vulnerabilities. 
* How to use Threat Modeling to analyze complex systems and build security into our systems at design time. 
* How to use Trust Boundaries to protect critical infrastructure. 
* Why open source and third-party libraries are fast becoming hidden liabilities in our software and how to protect ourselves against their vulnerabilities. 
* What the best practices for protecting our code from attack are. 

At the end of part two, we'll do a walkthrough of an exploit that can be successful today in spite of the safe guards built into our operating systems and compilers. Then, as before, we'll use it live to penetrate a system. 


The critical security infrastructure designed to protect your systems is largely out of your control. The one thing you can control is the next line of code you write. This talk is for anyone that uses C++ or Modern C++ for kernel, applications or libraries that run in the real-world and that face real-world attacks. 

In today's world, that's all of us.
— 
Matthew Butler

Matthew Butler has spent the last three decades as a systems architect and software engineer developing systems for network security, law enforcement and the military. He primarily works in signals intelligence using C, C++ and Modern C++ to build systems running on hardware platforms ranging from embedded micro-controllers to FPGAs to large-scale airborne platforms. Much of his experience has come in either building systems that defend against attackers or building highly sensitive systems that are targets. He is actively involved in the C++ community and is on various planning committees for C++Now and CppCon as well as being a speaker at both.

Over the past thirty years, he has learned the harsh lessons on how we often write systems that fail, not because they don't scale, but because they aren't designed to be secure.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,990
okay so I thought it would start this

00:00:01,680 --> 00:00:06,089
out by a story something that happened

00:00:03,990 --> 00:00:07,529
to me when I was a senior software

00:00:06,089 --> 00:00:10,080
engineer and I was also managing a

00:00:07,529 --> 00:00:11,160
network and we wound up getting

00:00:10,080 --> 00:00:12,030
penetrated by two different

00:00:11,160 --> 00:00:14,009
nation-states

00:00:12,030 --> 00:00:15,780
one at the top end of the month one at

00:00:14,009 --> 00:00:17,520
the bottom end of the month strange

00:00:15,780 --> 00:00:19,500
enough it was actually the same engineer

00:00:17,520 --> 00:00:21,449
that God has penetrated I could never

00:00:19,500 --> 00:00:23,279
get it convince him that going to places

00:00:21,449 --> 00:00:26,220
since we're a defense contractor there

00:00:23,279 --> 00:00:27,960
are some places you don't want to go so

00:00:26,220 --> 00:00:30,539
the FBI was very understanding for the

00:00:27,960 --> 00:00:32,640
first time the second time I called the

00:00:30,539 --> 00:00:34,410
FBI there was this moment of pause Allah

00:00:32,640 --> 00:00:37,620
are you trying to win the award for the

00:00:34,410 --> 00:00:41,059
most hack small business ever and my

00:00:37,620 --> 00:00:44,219
response at the time was you have that

00:00:41,059 --> 00:00:51,530
which was not the right answer for the

00:00:44,219 --> 00:00:54,750
FBI that was unfiltered thoughts you can

00:00:51,530 --> 00:00:56,219
read that or not you've been staring at

00:00:54,750 --> 00:00:58,109
my name for half an hour one of the

00:00:56,219 --> 00:01:00,449
things I want to ask and I always asked

00:00:58,109 --> 00:01:02,239
at the beginning this how many of you

00:01:00,449 --> 00:01:04,890
have some sort of secure coding

00:01:02,239 --> 00:01:10,290
standards secure programming penetration

00:01:04,890 --> 00:01:14,400
something okay some yeah usually most of

00:01:10,290 --> 00:01:23,430
most of people don't so this is I think

00:01:14,400 --> 00:01:24,780
our problem we have a tendency to sort

00:01:23,430 --> 00:01:26,009
of look at security is one of those

00:01:24,780 --> 00:01:27,270
things that we really can't sell as a

00:01:26,009 --> 00:01:29,090
feature which is for the most part

00:01:27,270 --> 00:01:31,560
straight you can't sell it as a feature

00:01:29,090 --> 00:01:33,720
but we also have a tendency to sort of

00:01:31,560 --> 00:01:38,909
ignore the implications of not being it

00:01:33,720 --> 00:01:39,930
not putting that into our systems and to

00:01:38,909 --> 00:01:42,740
the today what we're going to talk about

00:01:39,930 --> 00:01:44,520
is one is how we got where we are and

00:01:42,740 --> 00:01:46,140
the second thing we're going to talk

00:01:44,520 --> 00:01:49,439
about is how do we get out of where we

00:01:46,140 --> 00:01:51,240
are to someplace better and I mean while

00:01:49,439 --> 00:01:53,040
we're on our path we'll do a couple of

00:01:51,240 --> 00:01:55,439
exploits the classic buffer overflow and

00:01:53,040 --> 00:01:57,630
then we'll do an exploit that is

00:01:55,439 --> 00:02:00,840
actually in the Linux kernel up into a

00:01:57,630 --> 00:02:04,020
couple of years ago so the most

00:02:00,840 --> 00:02:07,409
dangerous place on earth is not a

00:02:04,020 --> 00:02:09,750
war-torn country it's not Syria it's not

00:02:07,409 --> 00:02:11,819
the Korean Peninsula it's not anyplace

00:02:09,750 --> 00:02:13,810
that you would think it is the most

00:02:11,819 --> 00:02:17,050
dangerous place on earth today

00:02:13,810 --> 00:02:22,599
is the internet we have gone just in my

00:02:17,050 --> 00:02:24,190
lifetime from 300 baud modems with BBS's

00:02:22,599 --> 00:02:26,500
to now we have cars that drive

00:02:24,190 --> 00:02:28,510
themselves we have everything talking to

00:02:26,500 --> 00:02:30,160
everything we have all of these

00:02:28,510 --> 00:02:32,050
heterogeneous systems that really don't

00:02:30,160 --> 00:02:35,860
need to talk to each other talking to

00:02:32,050 --> 00:02:37,930
each other and what we're finding out in

00:02:35,860 --> 00:02:40,090
the InfoSec world is the perimeter

00:02:37,930 --> 00:02:41,680
security is not going to protect you if

00:02:40,090 --> 00:02:43,180
it was going to protect you it would be

00:02:41,680 --> 00:02:43,630
doing a great job at this point but it's

00:02:43,180 --> 00:02:45,880
not

00:02:43,630 --> 00:02:48,819
there's too many ways pass it it's too

00:02:45,880 --> 00:02:51,340
porous there are easy ways to get beyond

00:02:48,819 --> 00:02:52,810
the the security networks that we

00:02:51,340 --> 00:02:54,910
because we always had this idea that

00:02:52,810 --> 00:02:57,970
everything inside is trusted everything

00:02:54,910 --> 00:03:01,450
outside is untrusted and that as long as

00:02:57,970 --> 00:03:01,840
you have your perimeter security you're

00:03:01,450 --> 00:03:03,130
good

00:03:01,840 --> 00:03:07,569
the problem is this doesn't work out

00:03:03,130 --> 00:03:10,180
that way what we're finding out in

00:03:07,569 --> 00:03:11,769
what's sort of becoming the the mainstay

00:03:10,180 --> 00:03:13,930
is this concept of zero trust

00:03:11,769 --> 00:03:15,519
environments and that is the environment

00:03:13,930 --> 00:03:17,290
inside your network is everybody's

00:03:15,519 --> 00:03:19,720
dangerous is the network the environment

00:03:17,290 --> 00:03:22,150
outside your network it's too easy for a

00:03:19,720 --> 00:03:24,280
phishing exploit to get people into your

00:03:22,150 --> 00:03:25,570
network and in this case I had a network

00:03:24,280 --> 00:03:27,519
that somebody was able to penetrate

00:03:25,570 --> 00:03:28,750
twice in the same month simply because

00:03:27,519 --> 00:03:34,959
somebody did something they shouldn't

00:03:28,750 --> 00:03:37,359
have been doing the most disturbing part

00:03:34,959 --> 00:03:38,980
of though is when I was coming up he was

00:03:37,359 --> 00:03:42,010
Matthew Broderick I want to change my

00:03:38,980 --> 00:03:44,260
grades I want to play games yes I may

00:03:42,010 --> 00:03:45,459
have destroyed the world getting into

00:03:44,260 --> 00:03:48,040
the wrong computer to play the wrong

00:03:45,459 --> 00:03:50,769
game but he was mainly about people just

00:03:48,040 --> 00:03:53,350
hacking into systems now it's big and

00:03:50,769 --> 00:03:54,670
then it migrated from well now it's

00:03:53,350 --> 00:03:56,200
about money I can get into your bank

00:03:54,670 --> 00:03:57,519
account I can get into your financial

00:03:56,200 --> 00:04:00,540
records I can get into anything that I

00:03:57,519 --> 00:04:02,889
need in order to make money off of you

00:04:00,540 --> 00:04:04,959
where we're going now and probably the

00:04:02,889 --> 00:04:06,310
most disturbing part of it is and why

00:04:04,959 --> 00:04:07,900
all of these linkages and all these

00:04:06,310 --> 00:04:10,030
systems talking to each other is such a

00:04:07,900 --> 00:04:11,799
problem is because we're starting to see

00:04:10,030 --> 00:04:13,989
hacks going after things like critical

00:04:11,799 --> 00:04:16,090
infrastructure going after things like

00:04:13,989 --> 00:04:17,769
our power grid so if you've ever looked

00:04:16,090 --> 00:04:19,510
at how the power grid works it's all

00:04:17,769 --> 00:04:20,919
connected in fact from the northern

00:04:19,510 --> 00:04:22,780
hemisphere of the United States and

00:04:20,919 --> 00:04:24,940
Canada it's all connected you take down

00:04:22,780 --> 00:04:26,660
one power grid it puts strain on the

00:04:24,940 --> 00:04:28,100
rest of the power

00:04:26,660 --> 00:04:29,510
and in this case we're seeing people

00:04:28,100 --> 00:04:30,920
going after power grids and they're not

00:04:29,510 --> 00:04:33,320
in there to get money they're in there

00:04:30,920 --> 00:04:36,500
to destroy equipment which means if you

00:04:33,320 --> 00:04:38,540
can imagine what would happen if the

00:04:36,500 --> 00:04:40,340
East Coast went down which is actually

00:04:38,540 --> 00:04:41,600
there's a major prior great especially

00:04:40,340 --> 00:04:44,120
in New York what does it do to our

00:04:41,600 --> 00:04:47,120
financial institutions how are you going

00:04:44,120 --> 00:04:48,470
to do your banking when we've taken down

00:04:47,120 --> 00:04:50,600
someone who's taken down the power grid

00:04:48,470 --> 00:04:53,540
and it's days or weeks to get the power

00:04:50,600 --> 00:04:55,910
grid back up then you're talking about

00:04:53,540 --> 00:04:58,550
loss of human life because hospitals can

00:04:55,910 --> 00:05:00,880
only run without power for so long then

00:04:58,550 --> 00:05:04,940
there are the things that we are putting

00:05:00,880 --> 00:05:06,740
for example the air aircraft are now in

00:05:04,940 --> 00:05:08,090
the air they're fully automated and

00:05:06,740 --> 00:05:11,870
they're talking to an upstream server

00:05:08,090 --> 00:05:15,860
all the time we have cars that drive

00:05:11,870 --> 00:05:18,230
themselves and are constantly talking to

00:05:15,860 --> 00:05:20,930
an upstream server so we have all of

00:05:18,230 --> 00:05:22,670
these pieces going together and Elon

00:05:20,930 --> 00:05:24,620
Musk even admits that's one of his

00:05:22,670 --> 00:05:27,710
biggest concerns besides the SEC and all

00:05:24,620 --> 00:05:30,380
the other stuff he's got going on he's

00:05:27,710 --> 00:05:35,150
concerned about a fleet-wide hack it's

00:05:30,380 --> 00:05:37,310
not unthinkable in 2007 DHS managed to

00:05:35,150 --> 00:05:38,810
penetrate a 757 they got into the flight

00:05:37,310 --> 00:05:40,610
controls just with it sitting on the

00:05:38,810 --> 00:05:41,960
ground it wasn't in flight but they

00:05:40,610 --> 00:05:44,630
still got in they should have boasted an

00:05:41,960 --> 00:05:46,370
air gap those systems should the systems

00:05:44,630 --> 00:05:47,720
they came in and on and the systems that

00:05:46,370 --> 00:05:49,370
fly planes should never have any

00:05:47,720 --> 00:05:53,120
conversations at all yet they managed to

00:05:49,370 --> 00:05:54,590
do it if you have a breach like that

00:05:53,120 --> 00:05:55,700
what you're talking about is having

00:05:54,590 --> 00:05:57,980
people being able to control aircraft

00:05:55,700 --> 00:06:04,340
cars things that can do serious damage

00:05:57,980 --> 00:06:06,650
to human beings so one of the things we

00:06:04,340 --> 00:06:07,850
find especially when I talk to CEO is we

00:06:06,650 --> 00:06:10,070
tend to have these three lives we tell

00:06:07,850 --> 00:06:12,890
each other tell ourselves really is

00:06:10,070 --> 00:06:14,090
we're behind firewalls great every

00:06:12,890 --> 00:06:16,160
coming again spin up recent last ten

00:06:14,090 --> 00:06:18,350
years head firewall that's just the way

00:06:16,160 --> 00:06:20,000
it is the firewalls didn't keep them out

00:06:18,350 --> 00:06:22,130
and it's not it'll slow them down but it

00:06:20,000 --> 00:06:23,630
won't keep them out we talk about

00:06:22,130 --> 00:06:25,640
welcoming code reviewed it's been tested

00:06:23,630 --> 00:06:26,900
you know there is this sort of moment of

00:06:25,640 --> 00:06:28,010
well how could this possibly have

00:06:26,900 --> 00:06:29,000
happened look at all the testing that

00:06:28,010 --> 00:06:30,440
we're done the problems we're not

00:06:29,000 --> 00:06:32,030
testing it correctly and we're not code

00:06:30,440 --> 00:06:33,830
reviewing it correctly the things you

00:06:32,030 --> 00:06:35,360
look for in a vulnerability are going to

00:06:33,830 --> 00:06:36,430
be very different than the things you're

00:06:35,360 --> 00:06:38,530
gonna look for in

00:06:36,430 --> 00:06:39,669
it's it's just a different set of

00:06:38,530 --> 00:06:42,160
patterns that you're gonna be looking

00:06:39,669 --> 00:06:43,300
for and then of course there's the we're

00:06:42,160 --> 00:06:45,070
to fill in the blank

00:06:43,300 --> 00:06:46,360
we're too small work too large we don't

00:06:45,070 --> 00:06:47,919
have anything anybody who wants the

00:06:46,360 --> 00:06:51,960
bottom line is everybody's got money and

00:06:47,919 --> 00:06:54,400
software scales really well the same

00:06:51,960 --> 00:06:56,199
zero day exploit that I can run against

00:06:54,400 --> 00:06:58,449
this company is the same I can run

00:06:56,199 --> 00:06:59,710
against any other company and once I'm

00:06:58,449 --> 00:07:03,699
inside I can do pretty much anything

00:06:59,710 --> 00:07:06,580
that I want with that company so let's

00:07:03,699 --> 00:07:08,590
talk about who they are that we that we

00:07:06,580 --> 00:07:10,199
deal with first is it started out as

00:07:08,590 --> 00:07:13,389
script kiddies back in the 70s and 80s

00:07:10,199 --> 00:07:15,160
and you did have some state actors but

00:07:13,389 --> 00:07:17,919
now nation states actually have

00:07:15,160 --> 00:07:19,810
offensive teams that do nothing more

00:07:17,919 --> 00:07:20,830
than to take an operating system tear it

00:07:19,810 --> 00:07:23,650
apart whether they've got the source

00:07:20,830 --> 00:07:24,850
code or not find the vulnerabilities and

00:07:23,650 --> 00:07:26,199
create what are known as zero to

00:07:24,850 --> 00:07:29,289
exploits those are exploits and nobody's

00:07:26,199 --> 00:07:33,280
seen we we call those equities so if

00:07:29,289 --> 00:07:34,780
they find 20 equities and they save them

00:07:33,280 --> 00:07:37,000
back for a rainy day and unfortunately

00:07:34,780 --> 00:07:38,620
it always seems to be raining because we

00:07:37,000 --> 00:07:41,740
see a lot of these coming out of

00:07:38,620 --> 00:07:43,030
nation-states that filters down to the

00:07:41,740 --> 00:07:45,639
next group which is the group that are

00:07:43,030 --> 00:07:48,039
the criminal organizations which take

00:07:45,639 --> 00:07:50,349
those weaponize them put them out on the

00:07:48,039 --> 00:07:54,460
dark web or the dark net whatever it is

00:07:50,349 --> 00:07:56,020
that you call it and those become and if

00:07:54,460 --> 00:07:57,610
you've ever gone to anything like dream

00:07:56,020 --> 00:07:59,949
markets you can find an exploit for

00:07:57,610 --> 00:08:01,000
almost anything and they're really cheap

00:07:59,949 --> 00:08:03,190
to them and they're really inexpensive

00:08:01,000 --> 00:08:06,130
they're like 300 bucks and if you want

00:08:03,190 --> 00:08:13,090
to spend more and get support you could

00:08:06,130 --> 00:08:14,830
do that so we take the we take what a

00:08:13,090 --> 00:08:17,889
nation-state can give us which is scale

00:08:14,830 --> 00:08:20,020
and money and then that begins to filter

00:08:17,889 --> 00:08:21,909
down the criminal enterprises and then

00:08:20,020 --> 00:08:24,550
that comes down to corporations who

00:08:21,909 --> 00:08:27,599
corporate spying now is rampant one of

00:08:24,550 --> 00:08:30,099
the probably one of the most notable

00:08:27,599 --> 00:08:31,750
what we call advanced persistent threats

00:08:30,099 --> 00:08:34,479
which is somebody who was penetrated for

00:08:31,750 --> 00:08:36,719
a long time and they didn't know it was

00:08:34,479 --> 00:08:39,099
Nortel Networks and Nortel Networks

00:08:36,719 --> 00:08:40,390
wound up being penetrated for almost a

00:08:39,099 --> 00:08:42,190
decade and they could never figure out

00:08:40,390 --> 00:08:42,860
why it is they would lose bid after bid

00:08:42,190 --> 00:08:44,720
after

00:08:42,860 --> 00:08:46,160
to this one particular company well the

00:08:44,720 --> 00:08:48,910
reason why is as they were working with

00:08:46,160 --> 00:08:51,920
a nation-state which penetrated their

00:08:48,910 --> 00:08:53,450
systems they were into the email their

00:08:51,920 --> 00:08:54,920
bidding strategies the contracts

00:08:53,450 --> 00:08:56,089
everything they knew everything that was

00:08:54,920 --> 00:08:59,810
going on in north all networks and they

00:08:56,089 --> 00:09:01,790
know exactly how to react to that in the

00:08:59,810 --> 00:09:05,029
marketplace so they wound up declaring

00:09:01,790 --> 00:09:08,180
bankruptcy so we have companies that are

00:09:05,029 --> 00:09:10,070
now taking what comes down from the

00:09:08,180 --> 00:09:12,740
higher levels and start have started

00:09:10,070 --> 00:09:17,180
using oddly enough insiders are actually

00:09:12,740 --> 00:09:20,540
still the largest in in terms of just

00:09:17,180 --> 00:09:23,000
exfiltration of data insiders are still

00:09:20,540 --> 00:09:24,920
our biggest threat I was talking to a

00:09:23,000 --> 00:09:28,190
gentleman the other day who said that he

00:09:24,920 --> 00:09:31,310
had had engineers take source code out

00:09:28,190 --> 00:09:32,810
of their environment twice so that's

00:09:31,310 --> 00:09:35,450
twice the code base walked out the door

00:09:32,810 --> 00:09:37,010
and these were insiders one of the

00:09:35,450 --> 00:09:38,060
things we find a lot those the weakest

00:09:37,010 --> 00:09:39,320
point insecurity is not just the

00:09:38,060 --> 00:09:41,269
insiders but it's also the people who

00:09:39,320 --> 00:09:43,279
don't patch boxes Equifax is a perfect

00:09:41,269 --> 00:09:45,110
example this was a case of a contractor

00:09:43,279 --> 00:09:47,120
that they dismissed we don't need you

00:09:45,110 --> 00:09:48,410
anymore he hadn't patched the boxes so

00:09:47,120 --> 00:09:50,000
they were penetrated by known

00:09:48,410 --> 00:09:51,649
vulnerabilities that had been out there

00:09:50,000 --> 00:09:53,570
for at least a couple of months and then

00:09:51,649 --> 00:09:56,959
he was a couple month apathy find out

00:09:53,570 --> 00:09:59,420
that they had been penetrated so in

00:09:56,959 --> 00:10:00,980
order to talk about software security we

00:09:59,420 --> 00:10:02,839
need to talk about what is a critical

00:10:00,980 --> 00:10:07,010
system so there's some terminology we're

00:10:02,839 --> 00:10:09,380
going to use the first thing is what's a

00:10:07,010 --> 00:10:10,940
critical system now we tend to think of

00:10:09,380 --> 00:10:13,310
critical systems as just simply being

00:10:10,940 --> 00:10:14,930
the system that we own it's the thing

00:10:13,310 --> 00:10:18,110
holding our snowflake whether it's data

00:10:14,930 --> 00:10:21,500
or some other capability but that's what

00:10:18,110 --> 00:10:23,420
we what we own the problem is that it's

00:10:21,500 --> 00:10:24,800
not just that so minimally it's the

00:10:23,420 --> 00:10:26,630
system itself but it's anything else

00:10:24,800 --> 00:10:28,100
that can interact with it and I actually

00:10:26,630 --> 00:10:31,100
had personal experience with this one

00:10:28,100 --> 00:10:33,199
time I had my wife call me she had been

00:10:31,100 --> 00:10:35,449
in research at a university wasn't

00:10:33,199 --> 00:10:37,399
sketchy it was a normal University and

00:10:35,449 --> 00:10:39,070
suddenly the printer was acting up so I

00:10:37,399 --> 00:10:42,100
didn't think anything of it I came home

00:10:39,070 --> 00:10:45,019
the printer wasn't acting correctly so

00:10:42,100 --> 00:10:46,399
when I did some I checked her machine I

00:10:45,019 --> 00:10:48,140
found that there was all sorts of

00:10:46,399 --> 00:10:50,990
redirects going out to a proxy server

00:10:48,140 --> 00:10:53,180
that that later found out was for a

00:10:50,990 --> 00:10:55,279
nation-state somebody had run a

00:10:53,180 --> 00:10:56,080
water-holding attack against this

00:10:55,279 --> 00:10:58,120
University

00:10:56,080 --> 00:10:59,800
you went the university it came down it

00:10:58,120 --> 00:11:01,120
actually wound of installing firmware on

00:10:59,800 --> 00:11:03,880
the printer because it got out of the

00:11:01,120 --> 00:11:06,010
stand box and when I turned the printer

00:11:03,880 --> 00:11:07,390
off all the redirect stopped turn it

00:11:06,010 --> 00:11:09,460
back on the redirects start right back

00:11:07,390 --> 00:11:11,920
up again so somebody had managed to get

00:11:09,460 --> 00:11:14,770
to a low priority system which is a

00:11:11,920 --> 00:11:16,060
printer to go after a high priority

00:11:14,770 --> 00:11:20,980
system which was the data that was on

00:11:16,060 --> 00:11:24,160
her PC so one of the things we talked

00:11:20,980 --> 00:11:26,950
about is attack vectors attack vectors

00:11:24,160 --> 00:11:29,740
are what we do it's it's a buffer

00:11:26,950 --> 00:11:32,050
overflow it's some sort of a denial of

00:11:29,740 --> 00:11:34,090
service so and denial of service tends

00:11:32,050 --> 00:11:35,650
to be things where we're making use

00:11:34,090 --> 00:11:37,870
especially in C++ we're making use of

00:11:35,650 --> 00:11:40,210
undefined behavior I send you something

00:11:37,870 --> 00:11:42,040
into your system you choke on it the

00:11:40,210 --> 00:11:45,070
system crashes you have a denial of

00:11:42,040 --> 00:11:46,420
service we also have privilege

00:11:45,070 --> 00:11:47,920
escalation which we're going to do today

00:11:46,420 --> 00:11:49,690
and then some others are things like

00:11:47,920 --> 00:11:52,210
sequel injection which we won't cover

00:11:49,690 --> 00:11:55,330
today but if you've ever seen the old

00:11:52,210 --> 00:11:58,240
loss top 20 the sequel injection has

00:11:55,330 --> 00:12:00,580
been at the top of Oz top 20 for 15

00:11:58,240 --> 00:12:02,620
years and they're sort of this moment of

00:12:00,580 --> 00:12:04,300
why can't we solve this problem and it's

00:12:02,620 --> 00:12:05,500
because of the bad programming habits

00:12:04,300 --> 00:12:08,140
that we get into with sequel injection

00:12:05,500 --> 00:12:10,120
where you're not using you're not

00:12:08,140 --> 00:12:12,250
validating the data you're not using

00:12:10,120 --> 00:12:16,750
stored procedures and things that allow

00:12:12,250 --> 00:12:19,750
you to filter out bad code so attack

00:12:16,750 --> 00:12:21,580
surfaces are really any surface that I

00:12:19,750 --> 00:12:23,830
can get to if you're listening on a port

00:12:21,580 --> 00:12:26,410
if you've got a website anything that I

00:12:23,830 --> 00:12:28,510
can get to from the outside is an attack

00:12:26,410 --> 00:12:29,320
service but attack services are also the

00:12:28,510 --> 00:12:31,990
inside

00:12:29,320 --> 00:12:33,430
how many people have IPC mechanisms

00:12:31,990 --> 00:12:35,140
because you have multiple processes and

00:12:33,430 --> 00:12:38,290
you're talking across different

00:12:35,140 --> 00:12:39,400
processes yeah so if you work in the

00:12:38,290 --> 00:12:40,750
embedded world you probably have a lot

00:12:39,400 --> 00:12:41,860
of that and there across the die which

00:12:40,750 --> 00:12:45,070
means you're probably using something

00:12:41,860 --> 00:12:49,330
like sockets we don't secure those we

00:12:45,070 --> 00:12:50,800
don't secure CL eyes for example so I've

00:12:49,330 --> 00:12:52,330
worked for companies where we produce

00:12:50,800 --> 00:12:54,520
hardware and one of the things we do is

00:12:52,330 --> 00:12:56,110
we drop a series of CL eyes on there to

00:12:54,520 --> 00:12:58,060
make it easier for the field engineers

00:12:56,110 --> 00:12:59,860
to be able to access the software but we

00:12:58,060 --> 00:13:01,480
do nothing to authenticate what those

00:12:59,860 --> 00:13:03,730
see like so if I'm inside the wire if

00:13:01,480 --> 00:13:05,620
I've gotten to the box I can use those

00:13:03,730 --> 00:13:07,300
things and look what's the first thing

00:13:05,620 --> 00:13:08,220
you do when you type a command line near

00:13:07,300 --> 00:13:10,230
face

00:13:08,220 --> 00:13:11,640
what gives you a nice readout of all the

00:13:10,230 --> 00:13:13,770
options that you have and say oh I

00:13:11,640 --> 00:13:15,810
didn't know that I could go and use this

00:13:13,770 --> 00:13:23,040
to reset the system so now I have an

00:13:15,810 --> 00:13:24,270
incident denial of service so I picked

00:13:23,040 --> 00:13:26,760
the title very specifically for this

00:13:24,270 --> 00:13:28,500
talk because when I talk about your

00:13:26,760 --> 00:13:31,290
first line of code is the last line of

00:13:28,500 --> 00:13:33,600
defense the reality is it is the last

00:13:31,290 --> 00:13:36,270
line of defense every system that we

00:13:33,600 --> 00:13:40,380
write is going to wind up being on the

00:13:36,270 --> 00:13:42,120
front lines of this undeclared war that

00:13:40,380 --> 00:13:44,880
we that has been on that is on our

00:13:42,120 --> 00:13:45,780
system so I picked some examples and I

00:13:44,880 --> 00:13:47,430
didn't pick them they're not meant to be

00:13:45,780 --> 00:13:48,660
hard they're just they're examples that

00:13:47,430 --> 00:13:51,890
I picked out of the vulnerability

00:13:48,660 --> 00:13:57,050
databases that I wanted to be able to

00:13:51,890 --> 00:14:00,720
tell a story with so let's start here

00:13:57,050 --> 00:14:08,460
what's wrong with this code and don't

00:14:00,720 --> 00:14:19,200
ratio and just shout it out how can it

00:14:08,460 --> 00:14:22,920
be able to look it might be an old

00:14:19,200 --> 00:14:25,440
farmer terminated the problem is exactly

00:14:22,920 --> 00:14:27,270
you're not checking that length it may

00:14:25,440 --> 00:14:29,070
be null terminated everything may be

00:14:27,270 --> 00:14:30,870
fine with the advice we tell everybody

00:14:29,070 --> 00:14:32,340
is don't you string copy okay I'm not

00:14:30,870 --> 00:14:34,800
using string copy I'm using string and

00:14:32,340 --> 00:14:36,690
copy the problem is is that stringing

00:14:34,800 --> 00:14:38,160
copy has almost the same vulnerabilities

00:14:36,690 --> 00:14:39,720
to string copy except that we don't ever

00:14:38,160 --> 00:14:42,900
talk about it so in this case I've sent

00:14:39,720 --> 00:14:44,730
in a file name with some arbitrary

00:14:42,900 --> 00:14:46,050
length that may or may not be right

00:14:44,730 --> 00:14:48,750
that's going into a buffer that's a

00:14:46,050 --> 00:14:51,390
fixed size so this is a classic buffer

00:14:48,750 --> 00:14:57,450
overflow the panel on the right actually

00:14:51,390 --> 00:15:00,180
comes from cert the top one is how bad

00:14:57,450 --> 00:15:02,190
is this vulnerability the middle box is

00:15:00,180 --> 00:15:04,440
how likely are you to make it to do

00:15:02,190 --> 00:15:06,120
something like this and the bottom is

00:15:04,440 --> 00:15:08,550
what are the remediation cost now I

00:15:06,120 --> 00:15:10,020
don't really always agree with them but

00:15:08,550 --> 00:15:12,120
I put what's in there simply because

00:15:10,020 --> 00:15:14,330
when I it makes it for a standard

00:15:12,120 --> 00:15:14,330
language

00:15:14,360 --> 00:15:21,610
so we fix this standard shrink good

00:15:19,009 --> 00:15:27,199
problem solved

00:15:21,610 --> 00:15:29,629
do what ya see that's the problem the

00:15:27,199 --> 00:15:31,279
advice that gets given to people is

00:15:29,629 --> 00:15:32,509
we'll just use standard string it makes

00:15:31,279 --> 00:15:33,739
it all good well you have a couple of

00:15:32,509 --> 00:15:36,619
problems that one is standard string

00:15:33,739 --> 00:15:38,119
performs very poorly anything over on a

00:15:36,619 --> 00:15:39,739
64-bit machine I think it's 24

00:15:38,119 --> 00:15:40,790
characters becomes heap-allocated so if

00:15:39,739 --> 00:15:42,350
you've got all these heap allocated

00:15:40,790 --> 00:15:44,149
strings you're gonna have disastrous

00:15:42,350 --> 00:15:45,379
performance but the other thing is

00:15:44,149 --> 00:15:47,239
you're not doing anything to verify or

00:15:45,379 --> 00:15:49,459
validate this data who sent it to you

00:15:47,239 --> 00:15:51,829
how big is the data what you're doing is

00:15:49,459 --> 00:15:53,149
just using a buffer in order to hold it

00:15:51,829 --> 00:15:55,040
and then you're sending that buffer

00:15:53,149 --> 00:15:56,360
you're actually sending the raw string

00:15:55,040 --> 00:16:00,679
into another function call because

00:15:56,360 --> 00:16:02,660
that's what it takes so the simple

00:16:00,679 --> 00:16:05,089
solution to this is just check the

00:16:02,660 --> 00:16:06,499
length it's very simple that's why I

00:16:05,089 --> 00:16:08,089
don't really agree that this is medium

00:16:06,499 --> 00:16:10,189
this is actually pretty trivial if you

00:16:08,089 --> 00:16:13,699
check the link and make sure that that

00:16:10,189 --> 00:16:15,410
length is appropriate for the buffer

00:16:13,699 --> 00:16:16,369
you're done you you've solved the

00:16:15,410 --> 00:16:17,600
problem you don't have to change

00:16:16,369 --> 00:16:18,709
technology the other problem using

00:16:17,600 --> 00:16:20,689
standard strings there's a lot of things

00:16:18,709 --> 00:16:23,149
you can't do a standard string if

00:16:20,689 --> 00:16:24,919
anybody here uses Google v8 so I tend to

00:16:23,149 --> 00:16:26,449
do JavaScript and C++ I'm forever

00:16:24,919 --> 00:16:28,519
sending things back and forth you cannot

00:16:26,449 --> 00:16:30,319
use standard string for that so you're

00:16:28,519 --> 00:16:31,759
down to you know the first thing you may

00:16:30,319 --> 00:16:33,589
send in a string the first thing happens

00:16:31,759 --> 00:16:34,339
it rips the guts out of it and converts

00:16:33,589 --> 00:16:36,589
it to something else

00:16:34,339 --> 00:16:38,209
same things like you're doing utf-8 to

00:16:36,589 --> 00:16:39,980
you have 32 conversions you cannot do

00:16:38,209 --> 00:16:42,949
that with standard string so getting

00:16:39,980 --> 00:16:44,389
people out of a habit of using a piece

00:16:42,949 --> 00:16:46,279
of technology means when they come back

00:16:44,389 --> 00:16:49,189
to using that they've sort of forgotten

00:16:46,279 --> 00:16:50,419
how it is that they should be using this

00:16:49,189 --> 00:16:53,660
in this case it's very simple just

00:16:50,419 --> 00:16:55,850
chickling and this is probably one of

00:16:53,660 --> 00:16:57,470
the things that will get that gets us to

00:16:55,850 --> 00:16:59,209
both if there is one thing that you do

00:16:57,470 --> 00:17:02,269
nothing else after today is that you

00:16:59,209 --> 00:17:03,589
verify and validate every piece of data

00:17:02,269 --> 00:17:05,870
that comes into your system through the

00:17:03,589 --> 00:17:07,250
external interfaces or wherever you will

00:17:05,870 --> 00:17:10,039
talk about trust boundaries here and all

00:17:07,250 --> 00:17:12,829
that maintain situational awareness on

00:17:10,039 --> 00:17:14,630
your data that right there is the

00:17:12,829 --> 00:17:19,070
biggest problem we face when it comes to

00:17:14,630 --> 00:17:30,290
our soft level how about this one

00:17:19,070 --> 00:17:33,620
that different so sort of the same deal

00:17:30,290 --> 00:17:36,140
the problems here I'm taking in

00:17:33,620 --> 00:17:38,030
something and I'm just static casting it

00:17:36,140 --> 00:17:39,230
directly into an enumeration what if

00:17:38,030 --> 00:17:44,120
that is not in balance for that

00:17:39,230 --> 00:17:46,520
enumeration in C postal 14 and before

00:17:44,120 --> 00:17:50,900
that that was an undefined earth

00:17:46,520 --> 00:17:53,270
basically it's a invalid value so you go

00:17:50,900 --> 00:17:55,460
okay with that maybe you have you check

00:17:53,270 --> 00:17:56,750
it later so you check it afterwards the

00:17:55,460 --> 00:17:57,980
problem is the C post was 17 that

00:17:56,750 --> 00:17:59,990
becomes an undefined behavior an

00:17:57,980 --> 00:18:02,450
undefined behavior is the point at which

00:17:59,990 --> 00:18:05,600
we talk about denial of service software

00:18:02,450 --> 00:18:07,580
crashing the kinds of things that make

00:18:05,600 --> 00:18:11,000
you incredibly vulnerable so the

00:18:07,580 --> 00:18:12,770
solution to this comes from the language

00:18:11,000 --> 00:18:14,840
itself we have strongly typed

00:18:12,770 --> 00:18:16,340
enumerations and the reason why we have

00:18:14,840 --> 00:18:18,950
these is as long as you've got the types

00:18:16,340 --> 00:18:22,250
correct once you static cast that in

00:18:18,950 --> 00:18:23,330
there it may be out of range but what

00:18:22,250 --> 00:18:24,620
you're not gonna get because the two's

00:18:23,330 --> 00:18:26,030
complement is you're not going to get

00:18:24,620 --> 00:18:32,090
undefined behavior and crash your

00:18:26,030 --> 00:18:33,860
application so look at the standard

00:18:32,090 --> 00:18:35,600
I've tried reading the standard I'm not

00:18:33,860 --> 00:18:39,500
a lawyer apparently it's written by one

00:18:35,600 --> 00:18:42,080
because there is a lot of very dense

00:18:39,500 --> 00:18:43,220
text there but I just did a sweep

00:18:42,080 --> 00:18:45,200
through the standard and I found

00:18:43,220 --> 00:18:48,140
something on the order of 269 places

00:18:45,200 --> 00:18:49,910
where we have undefined something those

00:18:48,140 --> 00:18:51,200
are the sharp edges of the language if

00:18:49,910 --> 00:18:52,790
you don't know where the sharp edges the

00:18:51,200 --> 00:18:54,260
language are you're going to wind up

00:18:52,790 --> 00:18:57,320
running into one of those sharp images

00:18:54,260 --> 00:18:58,760
at a time you really don't so I think

00:18:57,320 --> 00:19:00,740
for the standards to be there's got to

00:18:58,760 --> 00:19:02,510
be a way to do something besides 1500

00:19:00,740 --> 00:19:04,550
pages of legalese there's got to be a

00:19:02,510 --> 00:19:06,080
way that we can go and do something that

00:19:04,550 --> 00:19:08,000
gives people the ability to understand

00:19:06,080 --> 00:19:10,570
this without having to become the

00:19:08,000 --> 00:19:10,570
language lawyer

00:19:29,470 --> 00:19:34,190
yeah so I'm hearing different variations

00:19:32,030 --> 00:19:37,040
of the same theme standard copy does not

00:19:34,190 --> 00:19:40,730
allocate memory standard copy will just

00:19:37,040 --> 00:19:42,230
simply take the place you started the

00:19:40,730 --> 00:19:44,660
place you're gonna want to copy to and

00:19:42,230 --> 00:19:50,000
it's just going to copy it so this is a

00:19:44,660 --> 00:19:51,740
heap overflow so I didn't know that

00:19:50,000 --> 00:19:53,810
until I actually ran across this and

00:19:51,740 --> 00:19:55,250
there are some other ones like I think

00:19:53,810 --> 00:19:58,520
translate there's there's at least two

00:19:55,250 --> 00:19:59,930
others that have this problem but you

00:19:58,520 --> 00:20:01,790
won't know that unless you've really

00:19:59,930 --> 00:20:03,050
studied what standard copy does and in

00:20:01,790 --> 00:20:05,660
this case standard copy doesn't allocate

00:20:03,050 --> 00:20:08,750
memory so the solution for this one is

00:20:05,660 --> 00:20:10,010
just used back insert so each time you

00:20:08,750 --> 00:20:11,360
do a back insert it's going to wind up

00:20:10,010 --> 00:20:13,930
allocating the memory needs copy

00:20:11,360 --> 00:20:16,280
everything over and everything is fine

00:20:13,930 --> 00:20:18,260
probably a little simpler way is just

00:20:16,280 --> 00:20:21,410
use direct instruction just pass it to

00:20:18,260 --> 00:20:22,730
the constructor and let the the standard

00:20:21,410 --> 00:20:28,610
template libraries do what the standard

00:20:22,730 --> 00:20:29,900
cover libraries do correctly so one of

00:20:28,610 --> 00:20:32,300
the things you probably won't see on

00:20:29,900 --> 00:20:33,740
there in this case I don't think it

00:20:32,300 --> 00:20:35,060
throws I don't even think it warns you

00:20:33,740 --> 00:20:36,740
but that's a problem because it doesn't

00:20:35,060 --> 00:20:38,450
really know it but warnings are errors

00:20:36,740 --> 00:20:40,730
in the same way that pain in our body

00:20:38,450 --> 00:20:42,050
tells us something is wrong warnings in

00:20:40,730 --> 00:20:46,430
our code tell us that something is

00:20:42,050 --> 00:20:49,160
inconsistent it may be okay to ignore

00:20:46,430 --> 00:20:51,680
that warning but in reality is probably

00:20:49,160 --> 00:20:53,440
not going to be okay so one of the

00:20:51,680 --> 00:20:56,090
things we need to strive for is

00:20:53,440 --> 00:20:57,440
eliminating warnings from our code you

00:20:56,090 --> 00:20:59,240
cannot going to do this overnight I mean

00:20:57,440 --> 00:21:00,380
I've seen products where I've got 1,500

00:20:59,240 --> 00:21:02,330
warnings and we're not going to get them

00:21:00,380 --> 00:21:03,770
out in the next release but as you begin

00:21:02,330 --> 00:21:05,090
to get rid of those warnings those

00:21:03,770 --> 00:21:08,900
warnings are there to tell you something

00:21:05,090 --> 00:21:23,720
and we need to listen to them let's try

00:21:08,900 --> 00:21:26,260
this why is why is it going to give me a

00:21:23,720 --> 00:21:26,260
warning the wild

00:21:33,330 --> 00:21:36,330
yeah

00:21:39,929 --> 00:21:49,599
when does this loop exit exactly well

00:21:45,219 --> 00:21:51,820
not not exactly but there you go

00:21:49,599 --> 00:21:53,649
there's no guarantee that we're ever

00:21:51,820 --> 00:21:55,269
going to pass a zero into this which

00:21:53,649 --> 00:21:57,659
means this could go on forever and ever

00:21:55,269 --> 00:22:01,029
and ever and it just simply keeps going

00:21:57,659 --> 00:22:02,499
so there's a couple of ways to solve is

00:22:01,029 --> 00:22:04,359
one is very attic templates which I

00:22:02,499 --> 00:22:07,739
don't know about the rest of you but I

00:22:04,359 --> 00:22:11,429
find these a little difficult to read

00:22:07,739 --> 00:22:13,690
but this basically does the same thing

00:22:11,429 --> 00:22:14,979
one of the other things we can do is

00:22:13,690 --> 00:22:18,190
brace the initializer list

00:22:14,979 --> 00:22:20,019
so using this allows you to ensure that

00:22:18,190 --> 00:22:25,599
you're only consuming the data that's

00:22:20,019 --> 00:22:27,460
being passed in and that leads to the

00:22:25,599 --> 00:22:30,999
fourth best practices complexity is the

00:22:27,460 --> 00:22:32,109
enemy if you've ever studied metallurgy

00:22:30,999 --> 00:22:33,429
especially when it comes to airline

00:22:32,109 --> 00:22:34,779
crashes the reason why we have fatigue

00:22:33,429 --> 00:22:36,570
cracking is because when you put the

00:22:34,779 --> 00:22:41,080
system under stress the energy will all

00:22:36,570 --> 00:22:43,389
begin to coalesce around weaknesses in

00:22:41,080 --> 00:22:47,080
the middle the same thing goes on with

00:22:43,389 --> 00:22:49,149
complexity in our code when you you will

00:22:47,080 --> 00:22:51,339
find the easy ones the ones in the non

00:22:49,149 --> 00:22:52,779
complex parts of the code but bug but

00:22:51,339 --> 00:22:55,659
vulnerabilities within our send button

00:22:52,779 --> 00:22:58,239
abilities inside our code will begin to

00:22:55,659 --> 00:22:59,469
migrate to the complex areas of our code

00:22:58,239 --> 00:23:01,269
simply because it's hard to reason about

00:22:59,469 --> 00:23:03,609
those pieces of code that's where we

00:23:01,269 --> 00:23:04,899
begin to miss these things so one of the

00:23:03,609 --> 00:23:09,029
things we need to do is begin

00:23:04,899 --> 00:23:09,029
eliminating complexity out of our code

00:23:10,529 --> 00:23:13,679
last one

00:23:25,650 --> 00:23:35,760
which part yep

00:23:32,670 --> 00:23:38,010
so we don't know when that's actually

00:23:35,760 --> 00:23:39,540
gonna be used so we're passing something

00:23:38,010 --> 00:23:41,900
in by reference which may not ever get

00:23:39,540 --> 00:23:48,870
called until after what was being

00:23:41,900 --> 00:23:50,580
referenced is now out of scope so simple

00:23:48,870 --> 00:23:51,660
way to do it is capture by value make it

00:23:50,580 --> 00:23:53,460
mutable in this case it really doesn't

00:23:51,660 --> 00:23:55,500
matter the this is a trivial example

00:23:53,460 --> 00:24:01,320
which we really don't care if it's not

00:23:55,500 --> 00:24:04,679
going to return anything so Grove bug

00:24:01,320 --> 00:24:07,380
bug bounty hunters and this is a has

00:24:04,679 --> 00:24:10,470
anybody ever doesn't bug bounty hen you

00:24:07,380 --> 00:24:11,850
have actually couple few - so large

00:24:10,470 --> 00:24:13,290
companies will create bug bounty

00:24:11,850 --> 00:24:15,059
programs and that is you can go and you

00:24:13,290 --> 00:24:16,710
can earn anywhere from you know a few

00:24:15,059 --> 00:24:19,440
hundred dollars to a few thousand by

00:24:16,710 --> 00:24:20,100
finding a defect in their code so Apple

00:24:19,440 --> 00:24:22,770
does it

00:24:20,100 --> 00:24:24,390
Microsoft does it there's a lot of this

00:24:22,770 --> 00:24:25,950
is penetration testing from the outside

00:24:24,390 --> 00:24:27,630
it's especially popular with websites

00:24:25,950 --> 00:24:32,610
these websites tend to be the most

00:24:27,630 --> 00:24:34,290
heavily targeted systems that we see in

00:24:32,610 --> 00:24:38,280
the industry they're just they're easy

00:24:34,290 --> 00:24:40,140
prey so bug bounty hunters a bug bounty

00:24:38,280 --> 00:24:43,740
hunter program would simply look like

00:24:40,140 --> 00:24:46,780
this is that if you are a developer and

00:24:43,740 --> 00:24:47,900
you find a vulnerability that is

00:24:46,780 --> 00:24:51,390
[Music]

00:24:47,900 --> 00:24:55,110
exploitable something you can get from

00:24:51,390 --> 00:24:56,460
the outside you wind up getting paid by

00:24:55,110 --> 00:24:57,929
your company now if it's your bug okay

00:24:56,460 --> 00:25:00,420
you wrote the bug you find the bug you

00:24:57,929 --> 00:25:02,580
fix the bug it's not it's not something

00:25:00,420 --> 00:25:04,890
that we wind up getting paid for the

00:25:02,580 --> 00:25:07,559
same code twice but a bug bounty hunter

00:25:04,890 --> 00:25:10,530
program does a couple of things one is

00:25:07,559 --> 00:25:11,429
it teaches you and your engineers if

00:25:10,530 --> 00:25:12,450
there's money on the table your

00:25:11,429 --> 00:25:14,220
engineers are gonna go out and they're

00:25:12,450 --> 00:25:15,630
gonna figure out how to find these kind

00:25:14,220 --> 00:25:17,700
of vulnerabilities they'll take training

00:25:15,630 --> 00:25:20,070
like this they'll go other places get

00:25:17,700 --> 00:25:21,330
training they will figure out what the

00:25:20,070 --> 00:25:24,240
patterns are because one of the things

00:25:21,330 --> 00:25:28,230
as you saw in all of these examples

00:25:24,240 --> 00:25:30,090
there is a pattern to the way defects

00:25:28,230 --> 00:25:32,450
get put into our code they're little

00:25:30,090 --> 00:25:34,730
tiny mistakes one of the things that

00:25:32,450 --> 00:25:38,090
that vulnerabilities have and that being

00:25:34,730 --> 00:25:39,190
able to breach a company has with

00:25:38,090 --> 00:25:41,540
[Music]

00:25:39,190 --> 00:25:43,040
airline disastrous roads we always say

00:25:41,540 --> 00:25:45,140
in an airline disasters that's never one

00:25:43,040 --> 00:25:48,200
thing that brings the jet down so it's

00:25:45,140 --> 00:25:50,000
always a series of mistakes and you have

00:25:48,200 --> 00:25:52,010
a chain of events that if you break the

00:25:50,000 --> 00:25:55,760
chain you avert the disaster

00:25:52,010 --> 00:25:58,520
so in software it's the same thing

00:25:55,760 --> 00:26:00,470
there's there's rarely ever one thing

00:25:58,520 --> 00:26:02,960
it's going to be a combination of I

00:26:00,470 --> 00:26:05,000
didn't patch a system I have a zero-day

00:26:02,960 --> 00:26:07,820
I didn't realize was there I've got weak

00:26:05,000 --> 00:26:10,070
security controls around the software

00:26:07,820 --> 00:26:13,340
that should be protecting my little

00:26:10,070 --> 00:26:15,530
snowflake but bounty programs are there

00:26:13,340 --> 00:26:17,780
are designed internal programs are

00:26:15,530 --> 00:26:19,370
designed to teach people how to be able

00:26:17,780 --> 00:26:21,710
to go and find these and then when they

00:26:19,370 --> 00:26:24,080
do find them they get rewarded for it so

00:26:21,710 --> 00:26:26,480
it does a couple things one is you will

00:26:24,080 --> 00:26:28,010
ship with fewer vulnerabilities the

00:26:26,480 --> 00:26:29,840
second thing is you will wind up

00:26:28,010 --> 00:26:31,610
learning how to do this so you're going

00:26:29,840 --> 00:26:32,600
to write fewer vulnerabilities yourself

00:26:31,610 --> 00:26:34,550
and then the third thing is you're gonna

00:26:32,600 --> 00:26:36,860
find more in code reviews and we'll talk

00:26:34,550 --> 00:26:40,070
about code reviews in the next session

00:26:36,860 --> 00:26:41,990
but in this case you know a lot of

00:26:40,070 --> 00:26:43,730
companies Liam I advocate when I talk to

00:26:41,990 --> 00:26:45,290
CEOs you know put a ten thousand dollar

00:26:43,730 --> 00:26:47,510
check on the table somebody finds a

00:26:45,290 --> 00:26:48,980
verifiable exploit that they can be

00:26:47,510 --> 00:26:51,560
exploited in your code and their family

00:26:48,980 --> 00:26:53,060
you know ten grand it's huge yes but the

00:26:51,560 --> 00:26:54,680
over-and-under on your stock drop when

00:26:53,060 --> 00:26:57,020
you do get breached is gonna make that

00:26:54,680 --> 00:27:00,170
look cheap and yes unfortunately most

00:26:57,020 --> 00:27:02,090
companies do their stock will recover so

00:27:00,170 --> 00:27:04,100
you know maybe the CEO gets fired the

00:27:02,090 --> 00:27:06,320
CTO gets fired there there are people

00:27:04,100 --> 00:27:08,420
but bug bounty programs begins to bring

00:27:06,320 --> 00:27:09,710
that in-house we tend to see a lot of

00:27:08,420 --> 00:27:12,500
people coming and doing penetration

00:27:09,710 --> 00:27:14,930
testing from the outside but nobody that

00:27:12,500 --> 00:27:19,010
really does a lot of bringing that

00:27:14,930 --> 00:27:20,420
in-house in those skill sets in-house so

00:27:19,010 --> 00:27:23,930
what do I look for when I penetrate a

00:27:20,420 --> 00:27:26,540
system the first thing is anytime you

00:27:23,930 --> 00:27:28,040
copy memory because you're likely to get

00:27:26,540 --> 00:27:31,040
it wrong my first example it was a good

00:27:28,040 --> 00:27:33,530
example of getting it wrong anytime you

00:27:31,040 --> 00:27:35,600
don't validate and verify who you're

00:27:33,530 --> 00:27:37,430
getting your data from that that is the

00:27:35,600 --> 00:27:39,190
easiest way to penetrate the system is

00:27:37,430 --> 00:27:41,630
me being able to send you information

00:27:39,190 --> 00:27:43,580
that you're not expecting you haven't

00:27:41,630 --> 00:27:45,860
decided you haven't figured out who I am

00:27:43,580 --> 00:27:47,630
so you don't even know if I'm

00:27:45,860 --> 00:27:49,940
a threat actor or I'm somebody who

00:27:47,630 --> 00:27:52,490
should be sending you data you just

00:27:49,940 --> 00:27:56,510
simply process the data so denial of

00:27:52,490 --> 00:27:58,280
services are or an DDoS which is dynamic

00:27:56,510 --> 00:28:00,350
Annihilus services are usually where you

00:27:58,280 --> 00:28:02,059
have you're getting data from somebody

00:28:00,350 --> 00:28:03,770
but you haven't verified that it's

00:28:02,059 --> 00:28:07,760
somebody that you care about giving data

00:28:03,770 --> 00:28:10,520
to open source libraries their

00:28:07,760 --> 00:28:11,870
weaknesses are yours when you use an

00:28:10,520 --> 00:28:13,429
open source library one of the things

00:28:11,870 --> 00:28:16,400
that I always coach people do is is

00:28:13,429 --> 00:28:18,200
prefer libraries to where you have the

00:28:16,400 --> 00:28:22,520
source code and they're going through a

00:28:18,200 --> 00:28:25,130
continuing set of security the checks so

00:28:22,520 --> 00:28:27,740
when we get into the next hour we're

00:28:25,130 --> 00:28:30,080
gonna look at something that was fixed

00:28:27,740 --> 00:28:32,510
then it was broken when they went to fix

00:28:30,080 --> 00:28:35,780
a different bug and then it got fixed

00:28:32,510 --> 00:28:37,490
again nine years later so what you don't

00:28:35,780 --> 00:28:39,260
want is to just say okay we we've

00:28:37,490 --> 00:28:40,850
blessed this this is this is good

00:28:39,260 --> 00:28:42,410
because then every time you change the

00:28:40,850 --> 00:28:44,150
code you may be introducing some other

00:28:42,410 --> 00:28:48,890
vulnerability that you don't realize is

00:28:44,150 --> 00:28:51,440
their internal fear interfaces IPC

00:28:48,890 --> 00:28:53,240
interfaces USB interfaces if I can get

00:28:51,440 --> 00:28:55,790
you to let me put something into your

00:28:53,240 --> 00:28:58,460
system if I can get you to if you're not

00:28:55,790 --> 00:29:01,190
if you if you're expecting that what is

00:28:58,460 --> 00:29:05,270
inside is safe and what is outside is

00:29:01,190 --> 00:29:07,040
not it's not what is inside is just as

00:29:05,270 --> 00:29:09,650
dangerous because once that once I'm

00:29:07,040 --> 00:29:11,120
inside I can now go after all man

00:29:09,650 --> 00:29:12,980
anything that I want and if you're

00:29:11,120 --> 00:29:15,380
expecting the perimeter security to

00:29:12,980 --> 00:29:17,030
protect you it won't

00:29:15,380 --> 00:29:18,350
and then again any place I find

00:29:17,030 --> 00:29:19,610
complexity and design and I'm gonna come

00:29:18,350 --> 00:29:21,140
back to us over and over in because I

00:29:19,610 --> 00:29:22,820
see so many times where we have

00:29:21,140 --> 00:29:25,340
vulnerabilities in code that has nothing

00:29:22,820 --> 00:29:27,830
to do with people making mistake it's

00:29:25,340 --> 00:29:29,780
just it is so complex that they wind up

00:29:27,830 --> 00:29:33,320
not seeing the bugs that because you

00:29:29,780 --> 00:29:35,120
can't see the forest for the trees so

00:29:33,320 --> 00:29:40,429
how many people have ever run a buffer

00:29:35,120 --> 00:29:41,929
flow exploit a few people everybody does

00:29:40,429 --> 00:29:44,830
anybody not know what they are because

00:29:41,929 --> 00:29:44,830
that's what we're gonna do

00:29:45,169 --> 00:29:52,080
so buffer overflow exploit this is sort

00:29:48,179 --> 00:29:55,410
of where it all began back in the 90s

00:29:52,080 --> 00:29:58,320
and the 2000s when people began to find

00:29:55,410 --> 00:30:01,530
ways to penetrate systems so this code

00:29:58,320 --> 00:30:04,950
is actually the same code we use we saw

00:30:01,530 --> 00:30:06,390
this just video we have a buffer flow

00:30:04,950 --> 00:30:07,470
exploit we're using string and copy

00:30:06,390 --> 00:30:11,549
we're passing in a length or not

00:30:07,470 --> 00:30:13,320
validate so there's a couple things we

00:30:11,549 --> 00:30:15,150
can do this one is I can crash the

00:30:13,320 --> 00:30:17,610
application just by writing a ton of

00:30:15,150 --> 00:30:20,929
data in there or I can do something that

00:30:17,610 --> 00:30:25,500
will be a little more helpful in that is

00:30:20,929 --> 00:30:27,510
execute arbitrary code so this is one of

00:30:25,500 --> 00:30:32,850
the things we would want to echo the

00:30:27,510 --> 00:30:35,130
execute up there on the top of left this

00:30:32,850 --> 00:30:38,520
is for a Linux system I just want to run

00:30:35,130 --> 00:30:39,870
a shell you can do the same thing with

00:30:38,520 --> 00:30:43,290
Windows you're just gonna run a command

00:30:39,870 --> 00:30:47,280
over here on the right hand side that's

00:30:43,290 --> 00:30:49,830
just the assembly code for that it's

00:30:47,280 --> 00:30:51,179
just a few registers and then a call so

00:30:49,830 --> 00:30:55,590
it's very simple this is a very trivial

00:30:51,179 --> 00:30:59,070
piece of code so here we have the model

00:30:55,590 --> 00:31:00,870
for an x86 you've got program space on

00:30:59,070 --> 00:31:02,700
the bottom of the kernels on the top the

00:31:00,870 --> 00:31:04,440
data heap is on the bottom which grows

00:31:02,700 --> 00:31:06,990
upwards the stack is when the top and

00:31:04,440 --> 00:31:09,270
grows downwards no matter what memory

00:31:06,990 --> 00:31:11,640
you're accessing it you always access it

00:31:09,270 --> 00:31:13,830
from low to high so I pulled out a piece

00:31:11,640 --> 00:31:16,650
of of what a stack would look like so

00:31:13,830 --> 00:31:19,020
the the gold on the right hand side is

00:31:16,650 --> 00:31:20,400
the stack frame that's above and I

00:31:19,020 --> 00:31:22,970
removed some of the things we don't need

00:31:20,400 --> 00:31:26,190
there's actually more in here the return

00:31:22,970 --> 00:31:29,100
that is just the when you make a

00:31:26,190 --> 00:31:30,419
function call that return value is going

00:31:29,100 --> 00:31:31,830
to be where the function comes to the

00:31:30,419 --> 00:31:33,929
next instruction comes when you return

00:31:31,830 --> 00:31:36,270
for that function call so every time you

00:31:33,929 --> 00:31:38,100
hit you create a new stack frame you

00:31:36,270 --> 00:31:41,549
need a way to go back to the line of the

00:31:38,100 --> 00:31:44,750
line of code that Ecology so EBP RPP

00:31:41,549 --> 00:31:47,910
that is just the stack frame pointer and

00:31:44,750 --> 00:31:51,140
then we have our buffer loop so what if

00:31:47,910 --> 00:31:55,169
what we have here that's useful to us is

00:31:51,140 --> 00:31:56,730
the return and the buffer so we have two

00:31:55,169 --> 00:31:58,000
pieces that we can play with and what it

00:31:56,730 --> 00:32:00,910
would be really nice is

00:31:58,000 --> 00:32:02,230
that of that return going back to where

00:32:00,910 --> 00:32:08,890
it's supposed to go be nice if I could

00:32:02,230 --> 00:32:14,140
put it into some place that I control so

00:32:08,890 --> 00:32:16,300
what we do is we do what's known as a no

00:32:14,140 --> 00:32:17,680
op slip now there's a couple of

00:32:16,300 --> 00:32:19,180
different no op codes there's the long

00:32:17,680 --> 00:32:20,650
version which nobody uses in the short

00:32:19,180 --> 00:32:23,620
version which is the hex 90 as you see

00:32:20,650 --> 00:32:25,930
here what we want to do is we want to

00:32:23,620 --> 00:32:27,520
take that return and replace it with a

00:32:25,930 --> 00:32:29,530
return that goes back into our buffer

00:32:27,520 --> 00:32:31,570
that's the overflow we're overflowing

00:32:29,530 --> 00:32:33,340
the buffer we don't care about the frame

00:32:31,570 --> 00:32:35,590
quarter by the time the frame pointer

00:32:33,340 --> 00:32:39,940
figures out it's bad we're going to have

00:32:35,590 --> 00:32:41,620
it will be all over so what we want here

00:32:39,940 --> 00:32:43,240
is we don't want to have to be precise

00:32:41,620 --> 00:32:45,460
about this we want to be able to cover

00:32:43,240 --> 00:32:47,740
that return code to come somewhere back

00:32:45,460 --> 00:32:49,660
into our buffer hit a nice big landing

00:32:47,740 --> 00:32:52,360
pad and then have the no-ops

00:32:49,660 --> 00:32:55,120
then they lob slide bring it down to our

00:32:52,360 --> 00:32:57,190
code so you see this code here which is

00:32:55,120 --> 00:32:58,930
what it would look like what the payload

00:32:57,190 --> 00:33:02,410
would look like you see it's got all

00:32:58,930 --> 00:33:05,290
those hex and ID's that's the slide then

00:33:02,410 --> 00:33:06,760
you get down here to line about 190 and

00:33:05,290 --> 00:33:09,010
you see some more hex 90s but then you

00:33:06,760 --> 00:33:11,770
begin to see some what looks like code

00:33:09,010 --> 00:33:14,020
and then a couple lines down you see the

00:33:11,770 --> 00:33:16,120
same address repeated over and over and

00:33:14,020 --> 00:33:18,100
over again what you're trying to do here

00:33:16,120 --> 00:33:20,170
is you're trying to be able to take that

00:33:18,100 --> 00:33:21,700
return address and sort of slide it over

00:33:20,170 --> 00:33:23,370
the top of the return that return

00:33:21,700 --> 00:33:25,840
address can be somewhere in your buffer

00:33:23,370 --> 00:33:30,730
hit the knob slide to down execute your

00:33:25,840 --> 00:33:32,620
code so we're going to do one and what

00:33:30,730 --> 00:33:36,610
we're going to do is we are going to

00:33:32,620 --> 00:33:40,150
start from a buffer that's in a small

00:33:36,610 --> 00:33:42,340
buffer will overflow our own stack space

00:33:40,150 --> 00:33:43,870
and then we'll overflow into the stack

00:33:42,340 --> 00:33:48,670
space above it so the the calling

00:33:43,870 --> 00:33:52,120
function then may have any questions at

00:33:48,670 --> 00:33:58,420
this point because I'm well I have a

00:33:52,120 --> 00:34:00,930
skiddo watch the video I'll have to work

00:33:58,420 --> 00:34:00,930
on the slides

00:34:01,930 --> 00:34:15,790
oh yeah the videos come out of about a

00:34:06,250 --> 00:34:18,610
month yeah absolutely so the question

00:34:15,790 --> 00:34:20,530
was is that your comment about libraries

00:34:18,610 --> 00:34:22,240
is true for any library not just open

00:34:20,530 --> 00:34:25,060
source it so here's the thing about open

00:34:22,240 --> 00:34:27,550
source libraries with an open source

00:34:25,060 --> 00:34:29,140
library I get the source code if I'm

00:34:27,550 --> 00:34:31,060
gonna hack into a system the thing I

00:34:29,140 --> 00:34:32,950
want is the source tape because that's

00:34:31,060 --> 00:34:34,360
where I'm gonna go find my

00:34:32,950 --> 00:34:36,730
vulnerabilities well talk about that in

00:34:34,360 --> 00:34:40,480
the second talk because there's this

00:34:36,730 --> 00:34:42,520
it's a linux vulnerability but it's open

00:34:40,480 --> 00:34:45,580
source so one of the things I always

00:34:42,520 --> 00:34:46,870
want in the source code is I want to go

00:34:45,580 --> 00:34:48,370
get some idea where I think the

00:34:46,870 --> 00:34:49,929
vulnerabilities are and then I can go

00:34:48,370 --> 00:34:51,550
ahead and start testing around that area

00:34:49,929 --> 00:34:53,940
and see if I can make something happen

00:34:51,550 --> 00:34:58,780
so you're right it's any library it's

00:34:53,940 --> 00:35:00,910
the libraries as a that I consume I want

00:34:58,780 --> 00:35:03,310
to know that they're undergoing periodic

00:35:00,910 --> 00:35:05,470
security reviews but I also want to know

00:35:03,310 --> 00:35:08,020
I'd like to have the source code so I

00:35:05,470 --> 00:35:10,360
can look but it becomes one of those

00:35:08,020 --> 00:35:11,590
things you do not want libraries that

00:35:10,360 --> 00:35:13,750
somebody has said okay I've put together

00:35:11,590 --> 00:35:17,410
my library it's never been reviewed it's

00:35:13,750 --> 00:35:19,360
not under ongoing review so just use it

00:35:17,410 --> 00:35:20,920
because the problem is you don't know

00:35:19,360 --> 00:35:22,090
where those vulnerabilities are because

00:35:20,920 --> 00:35:29,890
you don't have a source code you can't

00:35:22,090 --> 00:35:35,440
find those vulnerabilities is this what

00:35:29,890 --> 00:35:37,390
for a loan yeah so we're going to talk

00:35:35,440 --> 00:35:40,450
about a SLR here in just a minute this

00:35:37,390 --> 00:35:41,620
box has a SLR turned off and the reason

00:35:40,450 --> 00:35:43,300
why I terms of the question what does

00:35:41,620 --> 00:35:45,610
this have to do does this assume any

00:35:43,300 --> 00:35:47,290
Authority the reason why I turn a SLR

00:35:45,610 --> 00:35:50,200
off in this kind because if I had to do

00:35:47,290 --> 00:35:51,490
an exploit where a SLR is active it

00:35:50,200 --> 00:35:53,560
would take most of an hour just to

00:35:51,490 --> 00:35:55,210
explain the exploit because it is very

00:35:53,560 --> 00:35:56,500
complicated and it's not something

00:35:55,210 --> 00:35:58,300
that's going to fit in you're not going

00:35:56,500 --> 00:36:00,490
to get it to work the first time you've

00:35:58,300 --> 00:36:02,290
gotta have to work through some of the

00:36:00,490 --> 00:36:12,610
where the address shifts are and we'll

00:36:02,290 --> 00:36:14,230
talk about a SLR here in a minute so the

00:36:12,610 --> 00:36:15,340
question is the no op slide is there

00:36:14,230 --> 00:36:18,730
because you don't know the exact address

00:36:15,340 --> 00:36:21,670
that you need to hit the knob slide is

00:36:18,730 --> 00:36:24,910
there so I don't have to know the exact

00:36:21,670 --> 00:36:27,250
address I can just put it in an area of

00:36:24,910 --> 00:36:30,310
the code some index off of where it is

00:36:27,250 --> 00:36:32,350
and I don't have to be precise it makes

00:36:30,310 --> 00:36:44,290
it much easier to be able to do about

00:36:32,350 --> 00:36:46,000
for overflow buffer overflows so the

00:36:44,290 --> 00:36:49,420
question is how do you test for buffer

00:36:46,000 --> 00:36:52,360
overflows we're gonna talk a lot about

00:36:49,420 --> 00:36:56,830
testing in the second talk but minimally

00:36:52,360 --> 00:37:00,220
you're going to be doing code reviews so

00:36:56,830 --> 00:37:02,020
when engineers are young they go in they

00:37:00,220 --> 00:37:03,190
find out that the vigor they want to

00:37:02,020 --> 00:37:04,960
cook their lunch they find out that the

00:37:03,190 --> 00:37:07,420
microwave is broken they pull the

00:37:04,960 --> 00:37:08,560
microwave of apart they go in they fix

00:37:07,420 --> 00:37:09,700
it they put it back together cook their

00:37:08,560 --> 00:37:12,280
lunch and they go on about their day

00:37:09,700 --> 00:37:13,920
hackers are a little bit different they

00:37:12,280 --> 00:37:17,770
go in the microwave is working just fine

00:37:13,920 --> 00:37:19,180
cook their lunch and then they sit there

00:37:17,770 --> 00:37:20,440
watching the microwave thinking how can

00:37:19,180 --> 00:37:21,790
I make this microwave do something it's

00:37:20,440 --> 00:37:23,800
not supposed to how can I make it blow

00:37:21,790 --> 00:37:26,920
up I'm gonna make it do something other

00:37:23,800 --> 00:37:29,230
than what they expect it's a different

00:37:26,920 --> 00:37:31,270
train of thought we go and we look at

00:37:29,230 --> 00:37:32,950
how can I take these pieces and how can

00:37:31,270 --> 00:37:35,650
I build this beautiful algorithm how can

00:37:32,950 --> 00:37:39,340
I have this extremely excellent

00:37:35,650 --> 00:37:41,470
performing data structure hackers are

00:37:39,340 --> 00:37:43,450
how can I go and I take something that

00:37:41,470 --> 00:37:46,750
somebody's built and turn it inside out

00:37:43,450 --> 00:37:48,640
and turn it into a weapon that's it's

00:37:46,750 --> 00:37:51,490
just a very different way of thinking so

00:37:48,640 --> 00:37:53,320
when you find these things when you're

00:37:51,490 --> 00:37:55,270
looking for these things in source code

00:37:53,320 --> 00:37:57,250
what you want to do is you want to begin

00:37:55,270 --> 00:37:58,660
thinking about how can I break this and

00:37:57,250 --> 00:38:00,190
I know it's hard I've been doing this

00:37:58,660 --> 00:38:02,470
for 30 years as a professional but the

00:38:00,190 --> 00:38:05,890
bottom line is I don't I'm not a good

00:38:02,470 --> 00:38:08,080
tester for my code I want my tests I

00:38:05,890 --> 00:38:09,539
want my my code to perform I'm more

00:38:08,080 --> 00:38:11,249
about building it and more about it

00:38:09,539 --> 00:38:12,989
working well you don't want to find out

00:38:11,249 --> 00:38:16,109
your baby's ugly and you know you've

00:38:12,989 --> 00:38:17,429
dressed it funny one of the things that

00:38:16,109 --> 00:38:19,259
you have to begin doing though is

00:38:17,429 --> 00:38:20,519
looking at your code in a different way

00:38:19,259 --> 00:38:22,799
how can I break it

00:38:20,519 --> 00:38:25,289
what can I send into this code that's

00:38:22,799 --> 00:38:26,849
going to damage the code or make the

00:38:25,289 --> 00:38:28,649
code do something that's unexpected and

00:38:26,849 --> 00:38:29,729
that's where complexity if we when we

00:38:28,649 --> 00:38:31,319
talk about complex that we talked about

00:38:29,729 --> 00:38:33,779
emergent behavior we have those moments

00:38:31,319 --> 00:38:37,109
I didn't realize that was gonna work

00:38:33,779 --> 00:38:40,499
that way because it is very complex so

00:38:37,109 --> 00:38:42,779
how you view your code rather than once

00:38:40,499 --> 00:38:44,549
you've built it up and it's beautiful

00:38:42,779 --> 00:38:49,229
it's doing exactly what you want it to

00:38:44,549 --> 00:38:50,999
do is how can I destroy and so many

00:38:49,229 --> 00:38:52,559
times we don't get to that part and

00:38:50,999 --> 00:38:55,589
that's why these vulnerabilities tend to

00:38:52,559 --> 00:38:57,809
slip through our testing but we will

00:38:55,589 --> 00:38:59,309
talk a lot more about the types of

00:38:57,809 --> 00:39:01,469
testing we can do in order to be able to

00:38:59,309 --> 00:39:03,949
get catch these things before they go

00:39:01,469 --> 00:39:03,949
out the door yes

00:39:04,399 --> 00:39:10,169
I'm sorry in kitchen we will talk about

00:39:08,639 --> 00:39:12,359
stacking area so he's been reading ahead

00:39:10,169 --> 00:39:13,499
you're giving away the rest of this part

00:39:12,359 --> 00:39:14,909
of the talk yes we will talk about

00:39:13,499 --> 00:39:23,130
stacking areas and I'll explain how they

00:39:14,909 --> 00:39:25,619
work yeah as a breeding Henry

00:39:23,130 --> 00:39:27,029
so there's we'll talk I'll go ahead and

00:39:25,619 --> 00:39:28,199
talk to you about countermeasures since

00:39:27,029 --> 00:39:30,839
everybody's been bringing them up okay

00:39:28,199 --> 00:39:33,419
so ASL our outer space layout

00:39:30,839 --> 00:39:36,839
randomization what ASLR does is it just

00:39:33,419 --> 00:39:39,569
randomized in certain places no in in

00:39:36,839 --> 00:39:42,179
your address space so there's a hat call

00:39:39,569 --> 00:39:43,619
return to lib see so there's a system

00:39:42,179 --> 00:39:45,529
function in lib see and if I can know

00:39:43,619 --> 00:39:49,259
exactly where that system call is

00:39:45,529 --> 00:39:50,939
instead of going into my buffer I just

00:39:49,259 --> 00:39:52,169
point it back out to where that library

00:39:50,939 --> 00:39:54,209
starts on that system call it's the

00:39:52,169 --> 00:39:56,130
exact same thing I'm running in the

00:39:54,209 --> 00:39:59,389
context of whatever this application is

00:39:56,130 --> 00:40:02,429
running in I just simply go out I run it

00:39:59,389 --> 00:40:03,989
so randomizing where these things are

00:40:02,429 --> 00:40:07,699
means it's very makes it much harder

00:40:03,989 --> 00:40:07,699
much more of a challenge to hit

00:40:22,080 --> 00:40:27,160
okay so I've already got my coat there's

00:40:25,450 --> 00:40:28,780
no reason for us to compile all of this

00:40:27,160 --> 00:40:29,830
but if you look on here you'll notice

00:40:28,780 --> 00:40:33,630
that there is a function called

00:40:29,830 --> 00:40:36,490
vulnerability or just bone so Vaughn a

00:40:33,630 --> 00:40:37,870
this is just my code that has got the

00:40:36,490 --> 00:40:39,430
vulnerability amp the reason why this is

00:40:37,870 --> 00:40:41,320
read analytic system for those either

00:40:39,430 --> 00:40:43,660
not really developers it's because the

00:40:41,320 --> 00:40:44,980
set you it is set on so when you run

00:40:43,660 --> 00:40:46,450
this you're going to run it as root and

00:40:44,980 --> 00:40:49,450
there are a lot of things that you can

00:40:46,450 --> 00:40:53,440
run in Linux like su you can run ping

00:40:49,450 --> 00:40:55,150
which is a which is owned by root so we

00:40:53,440 --> 00:40:57,790
don't run in the context of root which

00:40:55,150 --> 00:41:01,530
is analogous to running things as an

00:40:57,790 --> 00:41:05,890
administrator on Windows so I have my

00:41:01,530 --> 00:41:14,320
shell code which we which we looked here

00:41:05,890 --> 00:41:16,060
first look at the so there's my payload

00:41:14,320 --> 00:41:17,320
it looks a little bit different in what

00:41:16,060 --> 00:41:24,490
we covered because what I'm going to do

00:41:17,320 --> 00:41:28,480
is I'm going to overflow that buffer so

00:41:24,490 --> 00:41:30,340
my addressing is first so I'm at the

00:41:28,480 --> 00:41:32,050
bottom of my buffer the address is gonna

00:41:30,340 --> 00:41:35,350
point up into the stack frame above me

00:41:32,050 --> 00:41:39,420
with nice big buffer and run my payload

00:41:35,350 --> 00:41:39,420
out of that the code

00:41:47,170 --> 00:41:51,290
it's very simple I'm just gonna go open

00:41:50,510 --> 00:41:53,510
the file

00:41:51,290 --> 00:41:56,210
I'm gonna read in however much data

00:41:53,510 --> 00:41:58,910
happens to be there in this case it's

00:41:56,210 --> 00:42:01,670
going to be going into that buffer

00:41:58,910 --> 00:42:04,520
called STR then I'm gonna make my

00:42:01,670 --> 00:42:06,800
function call then it's going to go into

00:42:04,520 --> 00:42:11,690
bag copy and that's where the overflow

00:42:06,800 --> 00:42:18,410
happens so if we look at my account I'm

00:42:11,690 --> 00:42:19,430
just a regular user the shadow file for

00:42:18,410 --> 00:42:20,570
those of you there aren't Linux

00:42:19,430 --> 00:42:22,100
developers that's where all the

00:42:20,570 --> 00:42:31,490
passwords are I should not be able to

00:42:22,100 --> 00:42:33,800
view that if I'm just a normal user so

00:42:31,490 --> 00:42:39,200
I've run my vulnerability and now I have

00:42:33,800 --> 00:42:42,369
this strange hash mark here so the

00:42:39,200 --> 00:42:45,050
vulnerability has pulled in the data its

00:42:42,369 --> 00:42:53,840
overflowed the buffer it's now run my

00:42:45,050 --> 00:43:04,820
exploit and now I have root access so if

00:42:53,840 --> 00:43:12,380
I want to look at the problem of live

00:43:04,820 --> 00:43:13,880
code I can now see the passwords on the

00:43:12,380 --> 00:43:15,350
file which I should not be able to see

00:43:13,880 --> 00:43:19,119
this now that I have root access I can

00:43:15,350 --> 00:43:22,810
do anything that I want in this system

00:43:19,119 --> 00:43:24,920
so now that we've done this once let's

00:43:22,810 --> 00:43:26,780
find out what a failure looks like

00:43:24,920 --> 00:43:28,130
because in buffer overflows so if

00:43:26,780 --> 00:43:29,660
somebody's trying to run some sort of

00:43:28,130 --> 00:43:30,859
exploit like this against you where

00:43:29,660 --> 00:43:32,030
you're overflowing whether it's heap or

00:43:30,859 --> 00:43:35,410
something you're gonna see memory that's

00:43:32,030 --> 00:43:35,410
gonna be corrupt in a very specific way

00:43:36,460 --> 00:43:43,869
so let us I'm going to change my file so

00:43:40,910 --> 00:43:43,869
that this is a failure

00:43:49,360 --> 00:43:57,640
right now if you look at bad file it's

00:43:51,450 --> 00:44:00,220
517 errors so we're going to see now

00:43:57,640 --> 00:44:02,200
it's 200 this is gonna fail we in fact

00:44:00,220 --> 00:44:05,380
we want this to fail so if we were on

00:44:02,200 --> 00:44:08,200
our vulnerability again we get a cordon

00:44:05,380 --> 00:44:09,490
so the you have the same analog in

00:44:08,200 --> 00:44:20,050
Windows you're going to get some sort of

00:44:09,490 --> 00:44:25,800
memory dump of the failure so what I

00:44:20,050 --> 00:44:25,800
want to look at is at the core file I

00:44:29,760 --> 00:44:33,660
made out a dump the core file

00:45:13,200 --> 00:45:19,870
so now we wind up having a stack that's

00:45:16,060 --> 00:45:23,860
got to stack frames in it so if we go to

00:45:19,870 --> 00:45:33,610
frame 1 and we want to see what is in

00:45:23,860 --> 00:45:34,810
that it looks pretty normal which I just

00:45:33,610 --> 00:45:36,760
like regular memory there's really

00:45:34,810 --> 00:45:38,170
nothing there but that's because we we

00:45:36,760 --> 00:45:40,510
overflowed this buffer but that's not

00:45:38,170 --> 00:45:42,100
where we put the payload this was a

00:45:40,510 --> 00:45:45,660
small buffer in one we actually

00:45:42,100 --> 00:45:49,690
overflowed into the stack frame above it

00:45:45,660 --> 00:45:51,220
so let's go look at that one now all of

00:45:49,690 --> 00:45:53,710
a sudden we begin to see at the top

00:45:51,220 --> 00:45:56,560
we've got what looks like a repeating

00:45:53,710 --> 00:45:58,120
address we've got a bunch of hex 90s

00:45:56,560 --> 00:45:59,860
we've got other things these are sort of

00:45:58,120 --> 00:46:02,410
the telltale marks that when you have a

00:45:59,860 --> 00:46:04,600
piece of code that has been running just

00:46:02,410 --> 00:46:08,410
fine in production it suddenly begins

00:46:04,600 --> 00:46:10,060
failing for for no explainable reason go

00:46:08,410 --> 00:46:11,680
and look at the memory go and look at

00:46:10,060 --> 00:46:13,600
when you have a crash to look at this

00:46:11,680 --> 00:46:16,150
the stack dumps go look at the memory

00:46:13,600 --> 00:46:17,830
dump see if you begin seeing strange

00:46:16,150 --> 00:46:20,170
behavior like this where you've got tons

00:46:17,830 --> 00:46:21,580
and you'll see hex and IDs that's I mean

00:46:20,170 --> 00:46:23,560
that we have no ops in there and it's

00:46:21,580 --> 00:46:26,110
mainly used for padding but if you begin

00:46:23,560 --> 00:46:27,730
seeing this kind of behavior what it

00:46:26,110 --> 00:46:29,380
means is somebody is trying to whether

00:46:27,730 --> 00:46:30,700
successful or not they're trying to run

00:46:29,380 --> 00:46:39,070
something against your system and it

00:46:30,700 --> 00:46:42,370
tells you somebody's out there also

00:46:39,070 --> 00:46:44,050
tells you have a bug so I always tell

00:46:42,370 --> 00:46:45,610
people all vulnerable these are bugs but

00:46:44,050 --> 00:46:46,960
not all bugs are vulnerabilities you can

00:46:45,610 --> 00:46:47,950
have these things failed for reasons

00:46:46,960 --> 00:46:49,090
that have nothing to do with someone

00:46:47,950 --> 00:46:50,320
from penetrating it but at least it

00:46:49,090 --> 00:46:52,090
gives you a clue as to where you're

00:46:50,320 --> 00:46:56,620
going why you're having this particular

00:46:52,090 --> 00:46:58,480
problem so let's talk about some of the

00:46:56,620 --> 00:47:01,270
countermeasures and these

00:46:58,480 --> 00:47:03,280
countermeasures came into effect in the

00:47:01,270 --> 00:47:07,030
early 2000s every operating system has

00:47:03,280 --> 00:47:09,640
them address space layout randomization

00:47:07,030 --> 00:47:11,110
what we're doing is is the the stack and

00:47:09,640 --> 00:47:12,940
the heap are basically where they

00:47:11,110 --> 00:47:13,359
normally are but we're moving programs

00:47:12,940 --> 00:47:16,329
around

00:47:13,359 --> 00:47:18,279
moving libraries around this the Lib C

00:47:16,329 --> 00:47:20,980
attack where I want to call system if

00:47:18,279 --> 00:47:24,009
the if the library code is moving around

00:47:20,980 --> 00:47:25,329
I suddenly don't have a reliable place

00:47:24,009 --> 00:47:27,940
to find it now there are ways you can

00:47:25,329 --> 00:47:30,039
get around this address bills are one

00:47:27,940 --> 00:47:32,259
particular way of getting around you can

00:47:30,039 --> 00:47:34,119
also try brute-forcing it just by going

00:47:32,259 --> 00:47:35,859
through a range of places it becomes

00:47:34,119 --> 00:47:37,450
worse on the 64 bit machine because of

00:47:35,859 --> 00:47:41,069
the address spaces enormous compared to

00:47:37,450 --> 00:47:43,930
32 bit but what these do is is these

00:47:41,069 --> 00:47:46,660
change the where things are located so

00:47:43,930 --> 00:47:50,170
that you can't get to them easily and

00:47:46,660 --> 00:47:51,910
this is handled by the OS so this isn't

00:47:50,170 --> 00:47:53,470
anything you can do now the one thing

00:47:51,910 --> 00:47:55,420
you can do is you can believe in out you

00:47:53,470 --> 00:47:57,519
could turn this off and I've seen people

00:47:55,420 --> 00:47:59,170
they didn't really realize what a SLR

00:47:57,519 --> 00:47:59,920
was so they turned it off because they

00:47:59,170 --> 00:48:01,150
thought it was going to give him a

00:47:59,920 --> 00:48:02,650
performance misty will not give you a

00:48:01,150 --> 00:48:04,569
performance boost by sending by turning

00:48:02,650 --> 00:48:08,380
it off it just it doesn't there it's not

00:48:04,569 --> 00:48:09,549
you're not paying a penalty for it one

00:48:08,380 --> 00:48:10,839
of the other ones just a canary is

00:48:09,549 --> 00:48:14,769
somebody brought up with a stacking area

00:48:10,839 --> 00:48:17,650
so we started doing these ourselves

00:48:14,769 --> 00:48:20,499
which is I just put some known bit

00:48:17,650 --> 00:48:22,239
pattern right below the address so the

00:48:20,499 --> 00:48:23,710
AEV PRP view would be right above the

00:48:22,239 --> 00:48:25,690
canary and I took that out to make it

00:48:23,710 --> 00:48:28,089
easier to see but I'm gonna write some

00:48:25,690 --> 00:48:29,739
known bit pattern in there then right

00:48:28,089 --> 00:48:31,299
before I do a return I'm gonna go find

00:48:29,739 --> 00:48:33,299
out that bit pattern has changed if it

00:48:31,299 --> 00:48:35,829
has somebody's overflow the buffer and

00:48:33,299 --> 00:48:37,269
then I abort at that point in fact

00:48:35,829 --> 00:48:39,180
that's what a lot of these will do is if

00:48:37,269 --> 00:48:42,789
they find these things they will abort

00:48:39,180 --> 00:48:45,519
it is turned on by default in every

00:48:42,789 --> 00:48:47,170
compiler so make sure somebody didn't

00:48:45,519 --> 00:48:49,690
accidentally put in the wrong compiler

00:48:47,170 --> 00:48:52,989
flag and go and turn this off because it

00:48:49,690 --> 00:48:54,759
is useful it is also not fill per there

00:48:52,989 --> 00:48:57,039
are ways to prove or sit there are ways

00:48:54,759 --> 00:48:58,989
to guess it there's there's a million

00:48:57,039 --> 00:49:02,019
ways to get around it this is this is an

00:48:58,989 --> 00:49:03,160
arms race I mean there's just we come up

00:49:02,019 --> 00:49:04,390
with things to protect the system

00:49:03,160 --> 00:49:11,279
somebody's going to come up with a way

00:49:04,390 --> 00:49:11,279
to penetrate the system so questions

00:49:21,520 --> 00:49:26,390
yes in fact the entire next talk is

00:49:24,380 --> 00:49:27,530
gonna be around things so the question

00:49:26,390 --> 00:49:29,570
is do you recommend tools like

00:49:27,530 --> 00:49:31,820
sanitizers and absolutely we'll talk

00:49:29,570 --> 00:49:34,130
about some of the best ones out there

00:49:31,820 --> 00:49:36,200
and when do you use them so there is a I

00:49:34,130 --> 00:49:37,970
have a tendency to hear people say oh

00:49:36,200 --> 00:49:39,079
you know I just use static analyzers and

00:49:37,970 --> 00:49:40,250
it's all good I mean the static

00:49:39,079 --> 00:49:41,750
knowledge is gonna catch everything in

00:49:40,250 --> 00:49:44,359
static analyzers are not going to catch

00:49:41,750 --> 00:49:45,950
everything static lies analyzers are

00:49:44,359 --> 00:49:47,510
good for what they do but they are not

00:49:45,950 --> 00:49:49,339
good for everything and so we'll go

00:49:47,510 --> 00:49:51,170
through all of the different things that

00:49:49,339 --> 00:49:53,180
we use to test our systems to make sure

00:49:51,170 --> 00:49:54,859
that when that system goes out the door

00:49:53,180 --> 00:49:56,180
we have gotten vulnerabilities and we'll

00:49:54,859 --> 00:50:07,160
do things like threat modeling and we'll

00:49:56,180 --> 00:50:11,660
do a quick exercise on that yes okay so

00:50:07,160 --> 00:50:15,079
what happened was is is I when I did it

00:50:11,660 --> 00:50:17,030
correctly I had an actual address that

00:50:15,079 --> 00:50:19,040
went back to a region so when it tried

00:50:17,030 --> 00:50:20,150
to go back to that it found executable

00:50:19,040 --> 00:50:22,490
code in there in this case there was a

00:50:20,150 --> 00:50:24,230
bunch of hex 90s the one that failed

00:50:22,490 --> 00:50:27,950
though is I overflowed the buffer

00:50:24,230 --> 00:50:30,530
I blew away the address but I didn't put

00:50:27,950 --> 00:50:34,430
a valid address in it and the system

00:50:30,530 --> 00:50:36,319
recognized it and so it crashed you'll

00:50:34,430 --> 00:50:38,810
get the same kind of core dumps if you

00:50:36,319 --> 00:50:40,730
have a SLR turned on and if you've got

00:50:38,810 --> 00:50:42,050
stacking areas in place it'll when it

00:50:40,730 --> 00:50:43,130
finds that there's a problem somebody's

00:50:42,050 --> 00:50:44,480
been playing with the cat it's just

00:50:43,130 --> 00:50:59,000
going to abort at that point in time so

00:50:44,480 --> 00:51:04,369
you at a core dump okay yeah so the

00:50:59,000 --> 00:51:07,339
quick so the question was how big is the

00:51:04,369 --> 00:51:10,579
arsenal of attacks we're really creative

00:51:07,339 --> 00:51:14,960
people we can find ways to get into

00:51:10,579 --> 00:51:17,270
almost anything what it does is so we

00:51:14,960 --> 00:51:19,040
find out that there's an attack of a

00:51:17,270 --> 00:51:20,420
particular vulnerability we patch it

00:51:19,040 --> 00:51:25,190
they come back they look for a different

00:51:20,420 --> 00:51:26,510
way in there is there's no balance and

00:51:25,190 --> 00:51:28,700
and here's the thing a lot of people

00:51:26,510 --> 00:51:30,140
will say well yeah I mean you know once

00:51:28,700 --> 00:51:31,880
you've sort of figured these out the

00:51:30,140 --> 00:51:32,859
problem is is that the technology keeps

00:51:31,880 --> 00:51:37,989
changing

00:51:32,859 --> 00:51:42,789
and you wind up having we write new

00:51:37,989 --> 00:51:45,789
exploitable code every day so in that in

00:51:42,789 --> 00:51:47,200
there are classes so buffer overflows

00:51:45,789 --> 00:51:48,579
are one particular clock then there's

00:51:47,200 --> 00:51:50,349
code pointer exploits then there's

00:51:48,579 --> 00:51:52,390
sequel injection then there's what we're

00:51:50,349 --> 00:51:53,680
gonna do here at the end of the next

00:51:52,390 --> 00:51:55,779
talk which is going to be something

00:51:53,680 --> 00:51:57,160
quite a bit different and there's

00:51:55,779 --> 00:51:59,410
nothing in the OS that will protect you

00:51:57,160 --> 00:52:01,089
from that that's just a code that

00:51:59,410 --> 00:52:05,229
misbehaves that I can take advantage of

00:52:01,089 --> 00:52:06,839
so in terms of what are there what there

00:52:05,229 --> 00:52:09,519
are is there discrete number of patterns

00:52:06,839 --> 00:52:11,170
so if you get used to seeing the

00:52:09,519 --> 00:52:12,670
particular patterns of how code gets

00:52:11,170 --> 00:52:15,249
exploited you'll know how not to write

00:52:12,670 --> 00:52:16,900
exploitable code but in terms of the

00:52:15,249 --> 00:52:21,630
Arsenal its infinitive because we're

00:52:16,900 --> 00:52:21,630
just really really creative people yeah

00:52:26,700 --> 00:52:30,729
yeah exactly

00:52:28,329 --> 00:52:32,380
the reason the question was is that if I

00:52:30,729 --> 00:52:33,729
said you had been hidden up in set then

00:52:32,380 --> 00:52:34,900
you're just running in the context of

00:52:33,729 --> 00:52:36,160
your own account you've really gained

00:52:34,900 --> 00:52:38,859
anything is you're already in there on

00:52:36,160 --> 00:52:40,869
that account the reason why and I'll I

00:52:38,859 --> 00:52:45,400
have actually a slide that deals with

00:52:40,869 --> 00:52:47,079
this in Linux and Windows you will have

00:52:45,400 --> 00:52:48,969
pieces of the operating systems that are

00:52:47,079 --> 00:52:50,799
running as a high privileged account

00:52:48,969 --> 00:52:53,019
which is why we call this a privilege

00:52:50,799 --> 00:52:55,239
escalation we're getting extra

00:52:53,019 --> 00:52:58,599
privileges by taking advantage of a

00:52:55,239 --> 00:53:00,759
vulnerability so in the case of this one

00:52:58,599 --> 00:53:02,349
it's running as root and there are

00:53:00,759 --> 00:53:05,109
things like ping that will run as root

00:53:02,349 --> 00:53:06,640
and that's the way the operating system

00:53:05,109 --> 00:53:08,259
designed there's things in Windows that

00:53:06,640 --> 00:53:10,989
will run a system or things that will

00:53:08,259 --> 00:53:13,449
run as a an elevated privilege because

00:53:10,989 --> 00:53:15,400
their autonomic to the operating system

00:53:13,449 --> 00:53:17,829
and they need those privileges it used

00:53:15,400 --> 00:53:19,690
to be much worse in Windows because back

00:53:17,829 --> 00:53:21,940
before Windows 7 everything was an

00:53:19,690 --> 00:53:23,890
administrator and so any it was really

00:53:21,940 --> 00:53:24,999
easy to take advantage of privilege X so

00:53:23,890 --> 00:53:27,839
as soon as everything ran as an

00:53:24,999 --> 00:53:27,839
escalator privilege

00:53:35,530 --> 00:53:39,050
so the question was have it do I see a

00:53:37,640 --> 00:53:40,640
lot of return oriented programming which

00:53:39,050 --> 00:53:41,930
is that this is actually a case of

00:53:40,640 --> 00:53:43,579
return already in program he's talking

00:53:41,930 --> 00:53:45,920
about a class of vulnerabilities that I

00:53:43,579 --> 00:53:47,180
just talked about with you are we seeing

00:53:45,920 --> 00:53:50,000
it yes and we're getting really creative

00:53:47,180 --> 00:53:53,270
because it's died down and that the easy

00:53:50,000 --> 00:53:54,650
stuff is gone what we're still seeing

00:53:53,270 --> 00:53:56,690
though is is that people are finding

00:53:54,650 --> 00:53:58,190
other ways to get around aslr they're

00:53:56,690 --> 00:53:59,540
finding ways so you can do code pointer

00:53:58,190 --> 00:54:01,460
exploits well if that's on the heap and

00:53:59,540 --> 00:54:05,210
that's not covered by a stack that can't

00:54:01,460 --> 00:54:08,690
execute code out of so there are there

00:54:05,210 --> 00:54:10,670
is still a class of that what we're

00:54:08,690 --> 00:54:12,970
seeing more of a rise of at this point

00:54:10,670 --> 00:54:15,680
is we're seeing more phishing expert

00:54:12,970 --> 00:54:18,070
exploits where you're already inside the

00:54:15,680 --> 00:54:20,660
wire you're making use of a

00:54:18,070 --> 00:54:23,119
vulnerability that no one knew was there

00:54:20,660 --> 00:54:25,220
so this is sort of becoming a class that

00:54:23,119 --> 00:54:27,200
sort of is getting smaller but it's

00:54:25,220 --> 00:54:29,119
still there because there's if you

00:54:27,200 --> 00:54:33,109
especially if you have things like an

00:54:29,119 --> 00:54:34,760
address spill if you tell me where the

00:54:33,109 --> 00:54:37,069
address is he because it's in your logs

00:54:34,760 --> 00:54:38,869
or because you've made a mistake well

00:54:37,069 --> 00:54:40,790
now I can run that whole class again

00:54:38,869 --> 00:54:42,980
against your code simply because I know

00:54:40,790 --> 00:54:45,740
where the beginning of the like the Lib

00:54:42,980 --> 00:54:47,270
C is and I can know where that now I

00:54:45,740 --> 00:54:48,619
know where system is and now I can feed

00:54:47,270 --> 00:54:50,210
you the same data except instead of

00:54:48,619 --> 00:54:52,099
having to execute something on the stack

00:54:50,210 --> 00:55:05,329
I'm just going off to different places

00:54:52,099 --> 00:55:08,900
not on your stack yes the what that I'm

00:55:05,329 --> 00:55:10,520
talking about oh the stack Canaries

00:55:08,900 --> 00:55:12,619
stack Canaries are created by the

00:55:10,520 --> 00:55:14,119
compiler so you don't have to worry

00:55:12,619 --> 00:55:17,079
about creating your own you can if you

00:55:14,119 --> 00:55:20,390
want but it's redundant we started

00:55:17,079 --> 00:55:24,770
creating stack Canaries back in the

00:55:20,390 --> 00:55:27,440
early or late 1990s and early 2000s a

00:55:24,770 --> 00:55:28,880
defense against this until the compiler

00:55:27,440 --> 00:55:30,650
vendors began to catch up and that's

00:55:28,880 --> 00:55:33,020
when they put in LSAT ASLR they put in

00:55:30,650 --> 00:55:35,119
stacking areas they put in and and these

00:55:33,020 --> 00:55:36,560
are all progressions these were not one

00:55:35,119 --> 00:55:38,030
day we woke up and said okay here's the

00:55:36,560 --> 00:55:39,470
three technologies that are going to fix

00:55:38,030 --> 00:55:40,160
this what we do is we add one they get

00:55:39,470 --> 00:55:41,390
around

00:55:40,160 --> 00:55:43,580
know that they get around and we dad and

00:55:41,390 --> 00:55:45,620
third they get around it so what all

00:55:43,580 --> 00:55:49,070
that what we've talked about with is

00:55:45,620 --> 00:55:50,690
stack Canaries or a SLR is we've made it

00:55:49,070 --> 00:55:52,760
more of a challenge to it but we haven't

00:55:50,690 --> 00:55:54,050
eliminated it completely it's just and

00:55:52,760 --> 00:55:56,960
then the other part of that is we found

00:55:54,050 --> 00:55:59,750
easier exploit the one we'll do at the

00:55:56,960 --> 00:56:01,670
end of the next talk is actually really

00:55:59,750 --> 00:56:02,800
simple in fact it will take me longer to

00:56:01,670 --> 00:56:05,030
explain it to you in a way that

00:56:02,800 --> 00:56:07,420
everybody can consume it then it Realty

00:56:05,030 --> 00:56:14,290
to actually run it or code it on

00:56:07,420 --> 00:56:14,290
anything else oh yeah sorry

00:56:21,520 --> 00:56:26,320
Chandler is sitting here I love playing

00:56:27,700 --> 00:56:32,900
compiler vendors do an excellent job

00:56:30,370 --> 00:56:35,660
most of the difference between compiler

00:56:32,900 --> 00:56:37,490
vendors is how they optimize code we

00:56:35,660 --> 00:56:40,430
have not really found a lot of exploits

00:56:37,490 --> 00:56:42,170
that come from well I wrote the code

00:56:40,430 --> 00:56:44,390
this way the compiler exploited it that

00:56:42,170 --> 00:56:45,980
you know they they optimized it this way

00:56:44,390 --> 00:56:48,110
which generated the exploits so the

00:56:45,980 --> 00:56:50,690
compiler vendors are really good about

00:56:48,110 --> 00:56:52,190
making sure that they're not creating

00:56:50,690 --> 00:56:53,720
exploitable moments and the other thing

00:56:52,190 --> 00:56:56,150
we're doing as far as the language is

00:56:53,720 --> 00:57:00,740
concerned is if anybody is familiar with

00:56:56,150 --> 00:57:03,410
the standards sg-12 is there to look at

00:57:00,740 --> 00:57:07,460
each proposal that comes through and say

00:57:03,410 --> 00:57:09,290
where are we creating potential

00:57:07,460 --> 00:57:11,360
vulnerabilities in the code where are we

00:57:09,290 --> 00:57:12,740
creating these sharp edges that we

00:57:11,360 --> 00:57:14,840
talked about so we have undefined

00:57:12,740 --> 00:57:16,070
behavior and trying to get those out

00:57:14,840 --> 00:57:19,700
then going back and looking at old code

00:57:16,070 --> 00:57:21,050
and saying can we modify this or the at

00:57:19,700 --> 00:57:24,850
least going look at the standard can we

00:57:21,050 --> 00:57:27,050
change the standards so this becomes a

00:57:24,850 --> 00:57:28,730
something that is not undefined behavior

00:57:27,050 --> 00:57:32,260
and Chandler did a really great talk a

00:57:28,730 --> 00:57:35,960
few years ago on undefined behavior and

00:57:32,260 --> 00:57:37,940
and I think his point was well-taken is

00:57:35,960 --> 00:57:39,500
is we need to start removing undefined

00:57:37,940 --> 00:57:40,910
behavior for length we need to come to a

00:57:39,500 --> 00:57:42,590
pond where we can define the behavior

00:57:40,910 --> 00:57:44,450
for it it may not be correct behavior

00:57:42,590 --> 00:57:46,160
for the context of the application but

00:57:44,450 --> 00:57:51,850
at least we need to be able to define

00:57:46,160 --> 00:57:51,850
the behavior yeah

00:57:57,800 --> 00:58:02,340
yes so first testing is actually a good

00:58:00,990 --> 00:58:03,990
way to do this and we will talk more

00:58:02,340 --> 00:58:05,490
about those testing in the second half

00:58:03,990 --> 00:58:06,960
of this because I want what I wanted to

00:58:05,490 --> 00:58:09,360
do what I and what I did with the talk

00:58:06,960 --> 00:58:11,310
is I split it up I want to know okay how

00:58:09,360 --> 00:58:12,930
do we get to where we are right now and

00:58:11,310 --> 00:58:14,160
then the next talk is going to be what

00:58:12,930 --> 00:58:16,290
do we do about it

00:58:14,160 --> 00:58:20,790
and that's include a lot of things like

00:58:16,290 --> 00:58:22,800
threat modeling testing whole another

00:58:20,790 --> 00:58:24,720
group of best practices of things that

00:58:22,800 --> 00:58:40,650
you can do that will eliminate these

00:58:24,720 --> 00:58:43,970
problems in your code so the question is

00:58:40,650 --> 00:58:46,590
do I have any experience with specialty

00:58:43,970 --> 00:58:49,950
versions of Linux the for example on the

00:58:46,590 --> 00:58:53,220
Kali that says that it is a security I

00:58:49,950 --> 00:58:55,350
don't spend a lot of time thinking about

00:58:53,220 --> 00:58:57,480
whether or not this particular

00:58:55,350 --> 00:58:59,460
invitation is safer than that

00:58:57,480 --> 00:59:01,230
implementation because a lot of the

00:58:59,460 --> 00:59:02,280
really worst exploits and the one we're

00:59:01,230 --> 00:59:04,380
gonna do is actually built into the

00:59:02,280 --> 00:59:05,910
kernel so unless they're rewriting

00:59:04,380 --> 00:59:07,620
kernel code and we don't know about it

00:59:05,910 --> 00:59:09,150
they're using the same kernel that every

00:59:07,620 --> 00:59:11,220
other one is using so they've got the

00:59:09,150 --> 00:59:14,580
same liabilities that every kernel has

00:59:11,220 --> 00:59:16,590
infect the exploit and in the next talk

00:59:14,580 --> 00:59:18,180
is one that that hit every single

00:59:16,590 --> 00:59:22,920
implementation the Linux out there

00:59:18,180 --> 00:59:24,510
including Android so it's are there some

00:59:22,920 --> 00:59:27,120
there's like backtrack Linux which is I

00:59:24,510 --> 00:59:28,650
get really good Linux that you can use

00:59:27,120 --> 00:59:31,080
in order to be able to go and actually

00:59:28,650 --> 00:59:32,340
do penetration testing and it's got all

00:59:31,080 --> 00:59:35,040
sorts of tools built into it

00:59:32,340 --> 00:59:37,320
theoretically that's safer but I

00:59:35,040 --> 00:59:39,360
wouldn't go with a distro simply because

00:59:37,320 --> 00:59:40,830
you you know they advertise that it's

00:59:39,360 --> 00:59:42,660
safer unless they're unless it's

00:59:40,830 --> 00:59:46,620
demonstrably provable that they are

00:59:42,660 --> 00:59:50,130
safer probably have time for one more

00:59:46,620 --> 00:59:52,020
question okay take a break we'll come

00:59:50,130 --> 00:59:57,460
back for the second half thank you

00:59:52,020 --> 00:59:57,460

YouTube URL: https://www.youtube.com/watch?v=n4Yf2tBeAbE


