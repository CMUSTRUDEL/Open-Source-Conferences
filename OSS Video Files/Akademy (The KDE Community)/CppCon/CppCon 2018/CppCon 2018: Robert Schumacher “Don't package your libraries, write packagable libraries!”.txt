Title: CppCon 2018: Robert Schumacher “Don't package your libraries, write packagable libraries!”
Publication date: 2018-10-14
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Amid an avalanche of packaging solutions, who's side should you take? Trick question; you can support all of them! Discover the fundamental principles that make your library easy for _others_ to package so you don't have to! As a bonus, your builds will be faster, simpler, and more maintainable. 

This talk covers the lessons learned from packaging over 700 libraries in vcpkg, from the simplest single-header to the massive framework of Qt. We'll dissect the open source package maintainer's perspective and walk through the top library mistakes, supported by real-world examples from the vcpkg catalog.
— 
Robert Schumacher
Developer, Microsoft
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:06,060
okay well thanks everyone for coming on

00:00:03,210 --> 00:00:07,770
this beautiful Seattle day

00:00:06,060 --> 00:00:11,610
I'm Robert Shea marker I'm a lead

00:00:07,770 --> 00:00:14,790
developer on VC package at Microsoft and

00:00:11,610 --> 00:00:16,470
I'm here to talk about how you can write

00:00:14,790 --> 00:00:19,109
your libraries in such a way that you

00:00:16,470 --> 00:00:21,390
don't have to package them yourself so

00:00:19,109 --> 00:00:23,550
as you probably are aware there are an

00:00:21,390 --> 00:00:26,869
enormous number of package managers out

00:00:23,550 --> 00:00:29,970
there today that deal with C++ code and

00:00:26,869 --> 00:00:32,940
the number keeps getting bigger there is

00:00:29,970 --> 00:00:36,270
the ones that you've heard of there is

00:00:32,940 --> 00:00:39,329
apt there's brill there's the ones that

00:00:36,270 --> 00:00:43,680
you will have heard of VC package

00:00:39,329 --> 00:00:45,239
Coenen SPAC see you get hunter moore and

00:00:43,680 --> 00:00:48,360
then there's the ones that you don't

00:00:45,239 --> 00:00:49,649
think about like Conda Khan there's a

00:00:48,360 --> 00:00:52,649
Python package manager but it has to

00:00:49,649 --> 00:00:56,129
package C++ code chip and all of these

00:00:52,649 --> 00:00:57,300
systems if you insist on violating the

00:00:56,129 --> 00:00:58,620
rules that I'm gonna lay out for you

00:00:57,300 --> 00:00:59,879
you're gonna have to do all of that

00:00:58,620 --> 00:01:03,090
packaging work for all of those systems

00:00:59,879 --> 00:01:06,240
yourself but if you do if you follow

00:01:03,090 --> 00:01:09,119
these guides these points if you avoid

00:01:06,240 --> 00:01:11,700
these pitfalls then you can convince

00:01:09,119 --> 00:01:12,479
other people to do this work for you so

00:01:11,700 --> 00:01:15,780
that's what I'm gonna show you how to do

00:01:12,479 --> 00:01:17,009
today in this talk I'm going to be

00:01:15,780 --> 00:01:19,170
presenting things entirely from the

00:01:17,009 --> 00:01:20,460
maintainer point of view what this means

00:01:19,170 --> 00:01:22,619
is I'm gonna tell you don't do that

00:01:20,460 --> 00:01:24,780
that doesn't actually mean don't do that

00:01:22,619 --> 00:01:26,490
it means that if you do this it's harder

00:01:24,780 --> 00:01:28,320
to package your library it may still

00:01:26,490 --> 00:01:30,210
make sense for you you still need to

00:01:28,320 --> 00:01:31,229
think about the rest of your code you

00:01:30,210 --> 00:01:32,189
need to think of about the rest of your

00:01:31,229 --> 00:01:34,650
business you need to figure out what

00:01:32,189 --> 00:01:35,820
makes sense for you but my objective is

00:01:34,650 --> 00:01:37,650
that when you come away from this talk

00:01:35,820 --> 00:01:38,820
you'll have all of these points to think

00:01:37,650 --> 00:01:42,240
about in the future when you're making

00:01:38,820 --> 00:01:44,280
your own decisions additionally I'm

00:01:42,240 --> 00:01:45,869
going to use a lot of examples from

00:01:44,280 --> 00:01:48,240
real-world projects that are all

00:01:45,869 --> 00:01:50,880
packaged in VC package in this talk and

00:01:48,240 --> 00:01:52,380
I don't mean this as a hey this library

00:01:50,880 --> 00:01:52,590
is terrible they did something really

00:01:52,380 --> 00:01:55,890
bad

00:01:52,590 --> 00:01:57,240
what I mean by this is that hey there

00:01:55,890 --> 00:01:58,740
are real projects that make these

00:01:57,240 --> 00:02:00,920
mistakes that choose to do things

00:01:58,740 --> 00:02:04,130
differently than the way that I'm saying

00:02:00,920 --> 00:02:06,060
some of it can be enlightening but I

00:02:04,130 --> 00:02:07,619
really appreciate all the work that has

00:02:06,060 --> 00:02:09,959
gone into those libraries they're all

00:02:07,619 --> 00:02:10,979
awesome libraries and you should use

00:02:09,959 --> 00:02:12,930
them despite

00:02:10,979 --> 00:02:15,560
the fact that they may do some things

00:02:12,930 --> 00:02:20,340
that make my life more difficult

00:02:15,560 --> 00:02:21,840
so packaging the first and most common

00:02:20,340 --> 00:02:23,400
mistake that people make when they think

00:02:21,840 --> 00:02:26,250
about packaging is they only think about

00:02:23,400 --> 00:02:28,500
themselves and the user there's a lot

00:02:26,250 --> 00:02:31,200
more moving parts in a packaging system

00:02:28,500 --> 00:02:33,000
in most packaging systems in the way

00:02:31,200 --> 00:02:34,890
that I'm proposing it there is going to

00:02:33,000 --> 00:02:36,810
be a third party that acts as an

00:02:34,890 --> 00:02:39,420
intermediary between you and the user

00:02:36,810 --> 00:02:41,340
this maintainer who will take the stuff

00:02:39,420 --> 00:02:42,599
that you chose to do and they're going

00:02:41,340 --> 00:02:44,239
to make it work in a system that you

00:02:42,599 --> 00:02:49,049
didn't even know existed and that

00:02:44,239 --> 00:02:50,400
maintainer doesn't necessarily know how

00:02:49,049 --> 00:02:52,650
your code works they don't necessarily

00:02:50,400 --> 00:02:54,030
know how to even use your code they may

00:02:52,650 --> 00:02:55,860
not have even contributed to your

00:02:54,030 --> 00:02:58,200
project before and they are a human and

00:02:55,860 --> 00:02:59,940
they will make mistakes so a general

00:02:58,200 --> 00:03:02,340
theme for this talk is going to be how

00:02:59,940 --> 00:03:04,230
can you write your build system and your

00:03:02,340 --> 00:03:05,870
library in such a way that when the

00:03:04,230 --> 00:03:08,280
maintainer maintainer makes a mistake

00:03:05,870 --> 00:03:10,530
they'll see it and will fix it instead

00:03:08,280 --> 00:03:14,580
of it blowing up on some users machine

00:03:10,530 --> 00:03:19,410
some number of years down the line so

00:03:14,580 --> 00:03:23,100
first build systems rule number one use

00:03:19,410 --> 00:03:24,630
a popular build system if you use every

00:03:23,100 --> 00:03:25,829
build system is bad we know that every

00:03:24,630 --> 00:03:28,079
build system is terrible they all have

00:03:25,829 --> 00:03:29,880
their problems if you use a popular

00:03:28,079 --> 00:03:31,200
build system then you are bad in the

00:03:29,880 --> 00:03:32,940
same way that everyone else is bad and I

00:03:31,200 --> 00:03:35,430
know how to deal with that if you come

00:03:32,940 --> 00:03:37,799
up with your own new and clever ways to

00:03:35,430 --> 00:03:39,150
be bad now you're a problem you're a

00:03:37,799 --> 00:03:41,250
real problem because I have to figure

00:03:39,150 --> 00:03:42,989
out what you did differently that is

00:03:41,250 --> 00:03:44,640
different than everyone else so these

00:03:42,989 --> 00:03:47,579
are the three most common build systems

00:03:44,640 --> 00:03:51,840
we see today inside a VC package msbuild

00:03:47,579 --> 00:03:54,359
and C make by far dominate and the

00:03:51,840 --> 00:03:56,040
reward for choosing a package manager or

00:03:54,359 --> 00:03:58,170
sorry the reward for using a build

00:03:56,040 --> 00:04:00,930
system that isn't mainstream is not

00:03:58,170 --> 00:04:04,290
getting packaged there is no positive

00:04:00,930 --> 00:04:05,850
outcome of that now again as I said in

00:04:04,290 --> 00:04:07,410
the foreword this is all practiced with

00:04:05,850 --> 00:04:09,329
this is from the maintainer z--

00:04:07,410 --> 00:04:10,380
perspective certainly I don't mean to

00:04:09,329 --> 00:04:12,389
say that you should never make a new

00:04:10,380 --> 00:04:13,709
build system we need to keep involving

00:04:12,389 --> 00:04:14,670
in those areas but you need to

00:04:13,709 --> 00:04:18,389
acknowledge that it makes it more

00:04:14,670 --> 00:04:21,419
difficult to package here are some

00:04:18,389 --> 00:04:22,320
examples so everyone's aware of boos

00:04:21,419 --> 00:04:24,090
field

00:04:22,320 --> 00:04:26,190
but what you might not be aware is that

00:04:24,090 --> 00:04:30,390
OpenSSL is like thousands of lines of

00:04:26,190 --> 00:04:33,120
handwritten pearl psychic ffmpeg

00:04:30,390 --> 00:04:37,290
is this single massive seven and a half

00:04:33,120 --> 00:04:39,300
thousand line Bosch file it's an

00:04:37,290 --> 00:04:40,650
incredible piece of work they have they

00:04:39,300 --> 00:04:42,240
have their own reasons for doing it but

00:04:40,650 --> 00:04:44,130
it's a package maintainer this is this

00:04:42,240 --> 00:04:46,710
madman on Windows we have to download

00:04:44,130 --> 00:04:48,510
MSS to just to get a copy of bash then

00:04:46,710 --> 00:04:50,040
that we can run ffmpeg it still runs

00:04:48,510 --> 00:04:53,160
against CL but it's this weird hybrid

00:04:50,040 --> 00:04:55,440
thing it's crazy and then QT

00:04:53,160 --> 00:04:58,350
they have Q make there's approximately

00:04:55,440 --> 00:05:01,080
two libraries outside of QT that use Q

00:04:58,350 --> 00:05:05,070
make that I'm aware of so it makes life

00:05:01,080 --> 00:05:06,630
harder and to put yourselves in the

00:05:05,070 --> 00:05:08,250
shoes of a maintainer imagine that

00:05:06,630 --> 00:05:09,270
you're trying to package one of these

00:05:08,250 --> 00:05:11,070
libraries because they're awesome

00:05:09,270 --> 00:05:12,390
right you want to use it and one of them

00:05:11,070 --> 00:05:20,820
doesn't work if they're spaces in the

00:05:12,390 --> 00:05:23,730
path yeah next header only is not a

00:05:20,820 --> 00:05:25,440
panacea to all packaging woes we like to

00:05:23,730 --> 00:05:28,560
think that you know what forget this

00:05:25,440 --> 00:05:29,880
build thing build sucks so let's just do

00:05:28,560 --> 00:05:31,380
header online that doesn't really solve

00:05:29,880 --> 00:05:33,450
the problem there's still a lot of other

00:05:31,380 --> 00:05:34,590
issues you're gonna need to integrate

00:05:33,450 --> 00:05:36,120
with other people you're gonna need to

00:05:34,590 --> 00:05:37,890
provide ways for them to find you and

00:05:36,120 --> 00:05:41,190
use you in their bill and propagate

00:05:37,890 --> 00:05:44,850
flags and do all sorts of stuff a header

00:05:41,190 --> 00:05:46,680
only library can't do that I at least I

00:05:44,850 --> 00:05:49,650
haven't seen one do that I'm gonna need

00:05:46,680 --> 00:05:51,900
to run some kind of bill for you anyway

00:05:49,650 --> 00:05:53,460
even if your header only since I have to

00:05:51,900 --> 00:05:55,320
run your build system anyway and I

00:05:53,460 --> 00:05:58,290
already have a C++ compiler cuz I'm

00:05:55,320 --> 00:06:00,570
gonna use a C++ compiler to use you I'm

00:05:58,290 --> 00:06:02,580
going to use a C++ compiler to build

00:06:00,570 --> 00:06:04,260
your dependencies I'm gonna use a C++

00:06:02,580 --> 00:06:06,990
compiler to build the things that depend

00:06:04,260 --> 00:06:11,120
on you so you're not really saving much

00:06:06,990 --> 00:06:14,220
effort by avoiding the use of a compiler

00:06:11,120 --> 00:06:15,930
then you lose all of these other things

00:06:14,220 --> 00:06:17,010
you lose the ability to encapsulate

00:06:15,930 --> 00:06:19,770
we're gonna talk about encapsulation

00:06:17,010 --> 00:06:22,200
later on but if your header only you are

00:06:19,770 --> 00:06:23,850
forced to include everything in your

00:06:22,200 --> 00:06:26,610
headers of course that's all you have

00:06:23,850 --> 00:06:33,660
and that is a real problem it causes a

00:06:26,610 --> 00:06:36,360
lot of transitive issues boost

00:06:33,660 --> 00:06:38,130
is it's maybe well known at this point

00:06:36,360 --> 00:06:40,320
boost actually ended ends up with

00:06:38,130 --> 00:06:42,450
several circular dependencies inside of

00:06:40,320 --> 00:06:43,680
its own header libraries like ostensibly

00:06:42,450 --> 00:06:46,140
these individual libraries are

00:06:43,680 --> 00:06:47,940
independent but in practice because

00:06:46,140 --> 00:06:50,010
they're all header only and they're all

00:06:47,940 --> 00:06:52,290
in the same repo they've ended up with

00:06:50,010 --> 00:06:53,400
this header depends on that header from

00:06:52,290 --> 00:06:55,440
that guy which depends on that header

00:06:53,400 --> 00:06:57,240
from that guy which depends on another

00:06:55,440 --> 00:06:59,010
header from the first guy and around and

00:06:57,240 --> 00:07:00,510
around it goes and there's several of

00:06:59,010 --> 00:07:03,330
these uh Peter Deema

00:07:00,510 --> 00:07:04,770
I'd like to shout out to him he did an

00:07:03,330 --> 00:07:06,930
analysis of this it's available there

00:07:04,770 --> 00:07:10,650
you'll have the slides go take a look at

00:07:06,930 --> 00:07:14,580
it it's an interesting analysis it's a

00:07:10,650 --> 00:07:15,720
case study of modern software so if you

00:07:14,580 --> 00:07:19,940
were using a build system use your build

00:07:15,720 --> 00:07:23,760
system standard standard constructs so

00:07:19,940 --> 00:07:26,280
see make the build system that I'm

00:07:23,760 --> 00:07:28,470
familiar with here provides a mechanism

00:07:26,280 --> 00:07:29,880
for the user to choose whether they want

00:07:28,470 --> 00:07:32,010
a static library or a dynamic library

00:07:29,880 --> 00:07:32,310
you don't need to add a special flag for

00:07:32,010 --> 00:07:35,280
that

00:07:32,310 --> 00:07:37,020
it's build shared lives it influences

00:07:35,280 --> 00:07:38,190
what the default is in an add library

00:07:37,020 --> 00:07:39,540
call so and see make if you want to

00:07:38,190 --> 00:07:43,410
define a library you right add library

00:07:39,540 --> 00:07:44,700
foo sources you can optionally force it

00:07:43,410 --> 00:07:46,500
to be static or force it to be shared by

00:07:44,700 --> 00:07:48,570
putting a little keyword in there if you

00:07:46,500 --> 00:07:50,280
don't it will automatically inherit from

00:07:48,570 --> 00:07:51,630
build shared lives you don't have to do

00:07:50,280 --> 00:07:53,520
anything if you just don't do anything

00:07:51,630 --> 00:07:56,400
it will work great and it's when you try

00:07:53,520 --> 00:07:58,080
to circumvent these defaults things get

00:07:56,400 --> 00:07:59,640
a lot harder for the maintainer we know

00:07:58,080 --> 00:08:01,650
that if the user wants dynamic libraries

00:07:59,640 --> 00:08:03,210
for a CMake build we can just pass this

00:08:01,650 --> 00:08:04,560
flag and it will just work when you

00:08:03,210 --> 00:08:07,380
circumvent these and now I have to learn

00:08:04,560 --> 00:08:10,550
how you have decided to call building

00:08:07,380 --> 00:08:13,020
shared libraries there's a special

00:08:10,550 --> 00:08:15,180
subversion here in the same vein of

00:08:13,020 --> 00:08:20,070
trying to build static and dynamic in

00:08:15,180 --> 00:08:22,520
the same build so this is common and I

00:08:20,070 --> 00:08:24,810
would caution you against it because

00:08:22,520 --> 00:08:27,630
most users are going to want one of them

00:08:24,810 --> 00:08:29,940
they don't want hope and when you build

00:08:27,630 --> 00:08:32,130
both of them now you offer everyone

00:08:29,940 --> 00:08:33,719
downstream a choice and you have to

00:08:32,130 --> 00:08:35,669
offer them that choice and very often

00:08:33,719 --> 00:08:38,250
that choice has to be made at configure

00:08:35,669 --> 00:08:39,960
time of those libraries the user already

00:08:38,250 --> 00:08:42,089
knows what library they want they know

00:08:39,960 --> 00:08:43,919
that they want you to build a shared

00:08:42,089 --> 00:08:46,050
library but if you build both and

00:08:43,919 --> 00:08:48,740
someone depends on you what if they pick

00:08:46,050 --> 00:08:48,740
the static library

00:08:49,009 --> 00:08:52,009
great

00:08:52,399 --> 00:08:58,410
don't use header checks and this could

00:08:55,500 --> 00:08:59,970
be read as a has include considered

00:08:58,410 --> 00:09:03,870
harmful if you look further into the

00:08:59,970 --> 00:09:06,380
future the reasoning for this is that

00:09:03,870 --> 00:09:09,540
it's highly susceptible to contamination

00:09:06,380 --> 00:09:11,370
if you are using header checks to

00:09:09,540 --> 00:09:14,040
determine the existence of a library and

00:09:11,370 --> 00:09:16,139
then configuring yourself based on based

00:09:14,040 --> 00:09:17,639
on that so you you see oh this library

00:09:16,139 --> 00:09:18,839
this feature is available because the

00:09:17,639 --> 00:09:23,009
header is available so now I'm going to

00:09:18,839 --> 00:09:25,110
take a dependency on it when you do that

00:09:23,009 --> 00:09:26,940
you become incredibly susceptible to

00:09:25,110 --> 00:09:29,610
contamination if someone else happens to

00:09:26,940 --> 00:09:31,470
provide that header it is difficult to

00:09:29,610 --> 00:09:33,589
reserve a specific header for a specific

00:09:31,470 --> 00:09:37,050
purpose across the entire ecosystem and

00:09:33,589 --> 00:09:39,269
it is common to provide partial support

00:09:37,050 --> 00:09:41,040
so in the case of open SSL and library

00:09:39,269 --> 00:09:43,649
SSL for example libre SSL provides

00:09:41,040 --> 00:09:45,899
arguably partial support for open SSL

00:09:43,649 --> 00:09:47,819
open SSL that H will exist and it will

00:09:45,899 --> 00:09:50,220
have a subset of the api's that work in

00:09:47,819 --> 00:09:52,920
open SSL if you detect that header and

00:09:50,220 --> 00:09:54,329
you decide off I have open SSL I'm going

00:09:52,920 --> 00:09:57,660
to enable this optional dependency on

00:09:54,329 --> 00:10:00,959
open SSL and then your build fails that

00:09:57,660 --> 00:10:03,540
really sucks that really sucks what

00:10:00,959 --> 00:10:05,250
instead as a maintainer what I want is I

00:10:03,540 --> 00:10:07,410
just want to tell you hey don't build

00:10:05,250 --> 00:10:10,670
open SSL problem solved or do build open

00:10:07,410 --> 00:10:10,670
SSL and if you can't find it fail

00:10:11,449 --> 00:10:18,060
additionally header checks often ends up

00:10:13,769 --> 00:10:19,380
being incredibly fragile so live XML 294

00:10:18,060 --> 00:10:20,759
they fixed it in the master this is

00:10:19,380 --> 00:10:23,310
great but into u94

00:10:20,759 --> 00:10:24,839
they do this check for all of these this

00:10:23,310 --> 00:10:25,649
header and then these symbols and then

00:10:24,839 --> 00:10:27,600
they just don't do anything with them

00:10:25,649 --> 00:10:28,740
this is actually incredibly expensive on

00:10:27,600 --> 00:10:30,930
Windows I don't know if you've noticed

00:10:28,740 --> 00:10:32,279
but Auto can't file projects that do a

00:10:30,930 --> 00:10:33,990
lot of these configure checks end up

00:10:32,279 --> 00:10:36,209
being incredibly expensive to configure

00:10:33,990 --> 00:10:39,240
on Windows they can take many many

00:10:36,209 --> 00:10:41,279
minutes it can exceed the actual build

00:10:39,240 --> 00:10:44,880
time of the library just to do all of

00:10:41,279 --> 00:10:48,149
these header checks to decide hmm maybe

00:10:44,880 --> 00:10:51,829
today Windows has assists in maybe I

00:10:48,149 --> 00:10:51,829
should use that and then fail to build

00:10:53,560 --> 00:10:59,300
so I mentioned how you see OpenSSL and

00:10:58,160 --> 00:11:00,560
then you suddenly decide that hey I

00:10:59,300 --> 00:11:01,760
should build with this optional

00:11:00,560 --> 00:11:04,600
dependency because I found it and the

00:11:01,760 --> 00:11:06,800
user wants it that's awful

00:11:04,600 --> 00:11:09,440
auto-configuration is basically the

00:11:06,800 --> 00:11:12,230
worst enemy of a package manager of a

00:11:09,440 --> 00:11:14,720
package maintainer because I my job as a

00:11:12,230 --> 00:11:16,070
package maintainer is to make a robust

00:11:14,720 --> 00:11:18,380
build that will work the same way on

00:11:16,070 --> 00:11:19,970
every user's machine in the future we

00:11:18,380 --> 00:11:25,160
might have docker to solve this problem

00:11:19,970 --> 00:11:27,920
but today we don't and when you but so

00:11:25,160 --> 00:11:29,930
what this means is that as a baseline

00:11:27,920 --> 00:11:32,329
give me a way to turn off all of your

00:11:29,930 --> 00:11:34,579
auto detection machinery i want to

00:11:32,329 --> 00:11:36,800
explicitly specify every dependency that

00:11:34,579 --> 00:11:39,550
you have and if you don't find it fail

00:11:36,800 --> 00:11:43,279
to build tell me what's wrong do not

00:11:39,550 --> 00:11:45,290
decide that hmm I couldn't find open SSL

00:11:43,279 --> 00:11:46,760
you said you wanted open SSL explicitly

00:11:45,290 --> 00:11:48,920
on the command line with a - - build

00:11:46,760 --> 00:11:51,680
with SSL but I couldn't find it so I'm

00:11:48,920 --> 00:11:54,950
gonna just succeed and not build with it

00:11:51,680 --> 00:11:56,230
yeah don't do that don't just don't do

00:11:54,950 --> 00:11:59,390
that

00:11:56,230 --> 00:12:01,670
and just to show that this is an equal

00:11:59,390 --> 00:12:02,930
opportunity thing here I've been the CP

00:12:01,670 --> 00:12:05,300
rusticate maintainer for the last

00:12:02,930 --> 00:12:06,890
several years and we do this we do this

00:12:05,300 --> 00:12:08,810
incorrectly and there's a bug and we

00:12:06,890 --> 00:12:11,149
should fix it but we will fall back to

00:12:08,810 --> 00:12:12,620
an old embedded WebSocket + +

00:12:11,149 --> 00:12:14,750
implementation that we have checked into

00:12:12,620 --> 00:12:17,149
the repository if we can't find an

00:12:14,750 --> 00:12:18,860
external one this is terrible because

00:12:17,149 --> 00:12:21,950
I'm a maintainer I'm going to make

00:12:18,860 --> 00:12:23,600
mistakes right I'm going to I'm install

00:12:21,950 --> 00:12:25,310
WebSocket + + or maybe WebSocket + +

00:12:23,600 --> 00:12:26,540
it's going to they're gonna upgrade and

00:12:25,310 --> 00:12:28,100
they're gonna change their header paths

00:12:26,540 --> 00:12:29,899
and so you were searching for the header

00:12:28,100 --> 00:12:31,070
paths previously you no longer find them

00:12:29,899 --> 00:12:32,810
you determined that the libraries not

00:12:31,070 --> 00:12:34,760
installed but it's okay you silently

00:12:32,810 --> 00:12:38,180
fall back to your old implementer your

00:12:34,760 --> 00:12:39,980
old version that is checked in and now

00:12:38,180 --> 00:12:41,060
you've introduced ODR violations inside

00:12:39,980 --> 00:12:42,850
the users built because there's two

00:12:41,060 --> 00:12:45,350
definitions of all of those symbols and

00:12:42,850 --> 00:12:47,089
you can't tell that inside of your build

00:12:45,350 --> 00:12:49,070
I have to wait until someone actually

00:12:47,089 --> 00:12:51,470
tries to pull both of them in before I

00:12:49,070 --> 00:12:55,190
can tell and that's terrible so don't do

00:12:51,470 --> 00:12:57,380
that don't depend on having a host

00:12:55,190 --> 00:12:59,300
compiler so a host compiler is a concept

00:12:57,380 --> 00:13:02,510
inside cross compilation when you're say

00:12:59,300 --> 00:13:05,600
on a Linux x64 machine and your cross

00:13:02,510 --> 00:13:06,660
compiling for an embedded target so your

00:13:05,600 --> 00:13:11,430
cross compiling for

00:13:06,660 --> 00:13:13,230
say a Arduino in this scenario you have

00:13:11,430 --> 00:13:15,600
two compilers that are relevant there's

00:13:13,230 --> 00:13:16,949
a compiler that targets the Arduino and

00:13:15,600 --> 00:13:19,199
there is a compiler that targets

00:13:16,949 --> 00:13:20,759
yourself this compiler that targets

00:13:19,199 --> 00:13:22,980
yourself is relevant for a lot of

00:13:20,759 --> 00:13:23,939
projects which build code generators

00:13:22,980 --> 00:13:26,389
because they want to build their code

00:13:23,939 --> 00:13:28,529
generator written in C++ of course and

00:13:26,389 --> 00:13:30,120
that code generated then needs to run

00:13:28,529 --> 00:13:31,769
during a build in order to generate the

00:13:30,120 --> 00:13:34,670
code that you're then going to compile

00:13:31,769 --> 00:13:36,870
for the target platform this

00:13:34,670 --> 00:13:38,519
fundamentally means that you need two

00:13:36,870 --> 00:13:40,470
different tool chains but the problem

00:13:38,519 --> 00:13:42,480
with including both of them in the same

00:13:40,470 --> 00:13:44,220
build is that it is incredibly

00:13:42,480 --> 00:13:47,250
error-prone because you will mix flags

00:13:44,220 --> 00:13:48,810
between them cxx Flags right you have a

00:13:47,250 --> 00:13:50,040
CSX flight environment variable what

00:13:48,810 --> 00:13:51,629
does it apply to does it apply to the

00:13:50,040 --> 00:13:54,509
code generator or does it apply to the

00:13:51,629 --> 00:13:56,279
target is there another variable that I

00:13:54,509 --> 00:13:58,139
needed to find I have to go and learn

00:13:56,279 --> 00:13:59,790
what your conventions are for this

00:13:58,139 --> 00:14:02,160
particular thing there is an extremely

00:13:59,790 --> 00:14:04,500
easy solution to this problem allow me

00:14:02,160 --> 00:14:06,600
to invoke your build twice with the each

00:14:04,500 --> 00:14:09,209
toolset one at a time so there is no

00:14:06,600 --> 00:14:11,069
leakage across them and then import the

00:14:09,209 --> 00:14:13,290
pre-built binaries from the host build

00:14:11,069 --> 00:14:14,759
protobuf does this correctly and

00:14:13,290 --> 00:14:17,970
contrasts you most of the examples in

00:14:14,759 --> 00:14:19,980
this talk protobuf does this does this

00:14:17,970 --> 00:14:22,740
correctly so they get a gold star good

00:14:19,980 --> 00:14:24,300
job don't hard-code a single pack two

00:14:22,740 --> 00:14:25,589
miners so this includes the third-party

00:14:24,300 --> 00:14:29,189
directory where I just check in all my

00:14:25,589 --> 00:14:30,810
dependencies if you hard code a single

00:14:29,189 --> 00:14:32,069
package manager it becomes incredibly

00:14:30,810 --> 00:14:33,120
difficult for the maintainer to switch

00:14:32,069 --> 00:14:35,009
out the dependencies out from underneath

00:14:33,120 --> 00:14:37,439
you every major package manager this is

00:14:35,009 --> 00:14:39,449
their job their job is fundamentally to

00:14:37,439 --> 00:14:40,800
manage your dependencies and manage your

00:14:39,449 --> 00:14:42,689
dependencies dependencies and manages

00:14:40,800 --> 00:14:43,920
the things that depend on you and in

00:14:42,689 --> 00:14:46,230
order to do that I need to be able to

00:14:43,920 --> 00:14:47,939
intercept those dependencies when you

00:14:46,230 --> 00:14:49,620
make really deep hooks into one

00:14:47,939 --> 00:14:51,630
particular package manager that makes my

00:14:49,620 --> 00:14:53,269
job as a maintainer for some package

00:14:51,630 --> 00:14:57,240
system that you have never heard of it

00:14:53,269 --> 00:15:00,449
makes it extremely difficult so simply

00:14:57,240 --> 00:15:03,149
don't do that if you use your standard

00:15:00,449 --> 00:15:04,829
build system constructs and your build

00:15:03,149 --> 00:15:06,569
system has probably figured this out if

00:15:04,829 --> 00:15:09,089
you're using a popular one it knows how

00:15:06,569 --> 00:15:11,220
to write dependencies in a way that are

00:15:09,089 --> 00:15:12,839
easily intercepted and replaced at the

00:15:11,220 --> 00:15:14,610
very least we can figure out how to do

00:15:12,839 --> 00:15:16,620
it for common build systems if you have

00:15:14,610 --> 00:15:18,569
a bespoke build system and you hard code

00:15:16,620 --> 00:15:21,830
dependencies on the particular sub repo

00:15:18,569 --> 00:15:23,700
now things get really

00:15:21,830 --> 00:15:25,580
don't do plugins

00:15:23,700 --> 00:15:29,130
um plugins are really terrible for

00:15:25,580 --> 00:15:32,460
package management because we don't know

00:15:29,130 --> 00:15:35,520
what plugins precisely a user will want

00:15:32,460 --> 00:15:37,380
to use and they almost always come with

00:15:35,520 --> 00:15:39,720
some sort of build system complexity

00:15:37,380 --> 00:15:41,430
that propagates at every level it's not

00:15:39,720 --> 00:15:42,720
just a matter of your build system is

00:15:41,430 --> 00:15:44,160
complicated because you did plugins and

00:15:42,720 --> 00:15:46,470
your users build system is complicated

00:15:44,160 --> 00:15:48,420
because you did plugins every library

00:15:46,470 --> 00:15:49,890
between you and the user that wraps on

00:15:48,420 --> 00:15:51,870
top of you and on top of that and on top

00:15:49,890 --> 00:15:53,880
of that every one of those has to deal

00:15:51,870 --> 00:15:57,450
with this choice and that is why making

00:15:53,880 --> 00:16:02,370
plugins is an extremely problematic

00:15:57,450 --> 00:16:05,880
decision for package manager don't muck

00:16:02,370 --> 00:16:07,980
with my compiler flags so every major

00:16:05,880 --> 00:16:10,290
build system has a way for the builder

00:16:07,980 --> 00:16:13,650
the configure to specify additional

00:16:10,290 --> 00:16:15,930
flags to build with when you subvert

00:16:13,650 --> 00:16:17,250
those by say string replacing all

00:16:15,930 --> 00:16:18,900
instances of a particular flag with

00:16:17,250 --> 00:16:20,310
another thing you make it much more

00:16:18,900 --> 00:16:22,050
difficult for the maintainer if that

00:16:20,310 --> 00:16:23,670
thing is really what you want the

00:16:22,050 --> 00:16:25,980
canonical example here is people

00:16:23,670 --> 00:16:27,690
replacing MT with Md and not offering

00:16:25,980 --> 00:16:30,480
any way to suppress this behavior so

00:16:27,690 --> 00:16:34,950
they'll see the flights coming in the

00:16:30,480 --> 00:16:37,170
default flags are MD so they decide to

00:16:34,950 --> 00:16:39,030
string replace MD with MT because it's

00:16:37,170 --> 00:16:41,040
always MD and they always want MT and so

00:16:39,030 --> 00:16:43,260
that's that but it's very common for

00:16:41,040 --> 00:16:45,390
users to want to use static libs with MD

00:16:43,260 --> 00:16:49,140
that's the default and Visual Studio if

00:16:45,390 --> 00:16:51,810
you say file new static library so don't

00:16:49,140 --> 00:16:53,100
do this if you must do this because you

00:16:51,810 --> 00:16:55,020
decide that well you know my dev

00:16:53,100 --> 00:16:56,280
workflow I want my dev workflow to be

00:16:55,020 --> 00:16:57,900
convenient I want to replace these flags

00:16:56,280 --> 00:17:00,090
with the things that I want to build

00:16:57,900 --> 00:17:03,450
with make sure that you offer an escape

00:17:00,090 --> 00:17:06,140
hatch some sort of like - D don't muck

00:17:03,450 --> 00:17:13,589
with my settings what-have-you

00:17:06,140 --> 00:17:15,959
dependencies and talk right if you must

00:17:13,589 --> 00:17:18,240
have them hide them don't include

00:17:15,959 --> 00:17:19,589
windows out H in your headers for people

00:17:18,240 --> 00:17:22,680
who are on Linux you may not know the

00:17:19,589 --> 00:17:23,850
pain but it's very painful windows on a

00:17:22,680 --> 00:17:27,120
chain includes a bunch of macros and

00:17:23,850 --> 00:17:29,520
it's it's a whole mess in the wild open

00:17:27,120 --> 00:17:31,800
SSL did this in 1.0 they fixed it in one

00:17:29,520 --> 00:17:33,539
point one but 1.0 is still supported and

00:17:31,800 --> 00:17:36,629
so we have to still deal with it

00:17:33,539 --> 00:17:38,909
this is problematic because depending on

00:17:36,629 --> 00:17:40,559
the order of includes something can mean

00:17:38,909 --> 00:17:42,200
different windows RH can certainly mean

00:17:40,559 --> 00:17:46,710
different things and generally speaking

00:17:42,200 --> 00:17:49,259
as long as you one person hides it it

00:17:46,710 --> 00:17:50,429
solves the problem if everyone hides it

00:17:49,259 --> 00:17:52,799
so much the better

00:17:50,429 --> 00:17:56,159
if nobody hides it we have a problem so

00:17:52,799 --> 00:17:57,929
hide it don't have optional dependencies

00:17:56,159 --> 00:17:59,639
so this is incredibly common in C++

00:17:57,929 --> 00:18:03,090
projects especially older projects where

00:17:59,639 --> 00:18:04,259
they've accrued various like oh well we

00:18:03,090 --> 00:18:05,849
can implement this thing but it's gonna

00:18:04,259 --> 00:18:08,700
add a dependency dependency suck don't

00:18:05,849 --> 00:18:11,580
have them so let's give it let's give

00:18:08,700 --> 00:18:14,820
the user a way to not have it that's

00:18:11,580 --> 00:18:16,559
worse because now I don't now I have to

00:18:14,820 --> 00:18:17,549
offer the user multiple build options I

00:18:16,559 --> 00:18:18,479
have to say well oh do you want to build

00:18:17,549 --> 00:18:20,159
it this way do you want to build it this

00:18:18,479 --> 00:18:21,659
way I know we built it this way

00:18:20,159 --> 00:18:23,639
initially and we built a bunch of things

00:18:21,659 --> 00:18:25,440
on top of that and now you change your

00:18:23,639 --> 00:18:26,479
mind so now I have to go back and have

00:18:25,440 --> 00:18:28,769
to rebuild that but that might have

00:18:26,479 --> 00:18:29,970
propagating effects downstream to all of

00:18:28,769 --> 00:18:31,679
the people that were built on top of me

00:18:29,970 --> 00:18:32,909
so I have to totally rebuild this entire

00:18:31,679 --> 00:18:35,509
counter destruction it's like I changed

00:18:32,909 --> 00:18:40,379
the source code this is really terrible

00:18:35,509 --> 00:18:44,549
and it it also it explodes the

00:18:40,379 --> 00:18:45,869
configuration space so a general theme

00:18:44,549 --> 00:18:49,440
that you're getting by this point is

00:18:45,869 --> 00:18:51,690
that something that seems not terrible

00:18:49,440 --> 00:18:53,519
at a small scale when you start adding

00:18:51,690 --> 00:18:57,149
layers and layers and layers and layers

00:18:53,519 --> 00:18:59,869
things get really bad so say you have

00:18:57,149 --> 00:19:03,629
five options that's two to the five

00:18:59,869 --> 00:19:04,979
total configuration space if every level

00:19:03,629 --> 00:19:06,210
has two to the five configuration space

00:19:04,979 --> 00:19:10,379
and on five levels deep now I have two

00:19:06,210 --> 00:19:12,419
to the fifty configuration space yeah no

00:19:10,379 --> 00:19:14,099
nobody's gonna test that so that means

00:19:12,419 --> 00:19:15,570
that whenever you as a user choose

00:19:14,099 --> 00:19:17,129
something you don't know whether that's

00:19:15,570 --> 00:19:19,019
gonna work because you're probably pick

00:19:17,129 --> 00:19:21,059
you've probably stumbled upon some

00:19:19,019 --> 00:19:24,299
unique special build that no one else

00:19:21,059 --> 00:19:27,330
has ever built before so there's no no

00:19:24,299 --> 00:19:29,729
way to have tested that before so avoid

00:19:27,330 --> 00:19:31,529
optional dependencies there are choices

00:19:29,729 --> 00:19:33,509
that your there are designs that you can

00:19:31,529 --> 00:19:35,549
make that avoid them the easiest one is

00:19:33,509 --> 00:19:37,679
if you want you optionally have support

00:19:35,549 --> 00:19:39,389
for this extra thing that would add some

00:19:37,679 --> 00:19:41,070
extra api's add some extra headers add

00:19:39,389 --> 00:19:42,299
the ester dependencies make a separate

00:19:41,070 --> 00:19:43,799
library make another library that

00:19:42,299 --> 00:19:45,359
depends on you depends on the thing and

00:19:43,799 --> 00:19:45,750
the user can choose to build that or not

00:19:45,359 --> 00:19:49,230
and

00:19:45,750 --> 00:19:51,600
be simple very simple dependency

00:19:49,230 --> 00:19:57,720
injection here is your friend don't go

00:19:51,600 --> 00:19:59,640
crazy what is your friend I don't know

00:19:57,720 --> 00:20:01,380
if anyone here uses OpenCV but if you

00:19:59,640 --> 00:20:03,570
look at their configure file I swear

00:20:01,380 --> 00:20:05,220
they use every every graphics library

00:20:03,570 --> 00:20:07,200
that I've ever heard of and many more

00:20:05,220 --> 00:20:12,210
that I haven't and then you look at

00:20:07,200 --> 00:20:13,440
ffmpeg configure I it takes a good 10

00:20:12,210 --> 00:20:15,000
seconds to load on github when you might

00:20:13,440 --> 00:20:17,640
click that configure file that 7.5

00:20:15,000 --> 00:20:19,590
thousand line bash file and there's a

00:20:17,640 --> 00:20:20,760
good chunk of it that's just do you want

00:20:19,590 --> 00:20:21,780
to use this library do you want to not

00:20:20,760 --> 00:20:23,610
use that library you want to use this

00:20:21,780 --> 00:20:26,010
other library this one this one this one

00:20:23,610 --> 00:20:30,900
this one and it goes on for 200 lines of

00:20:26,010 --> 00:20:32,310
just options it's crazy and what's the

00:20:30,900 --> 00:20:37,440
chances that all of those options are

00:20:32,310 --> 00:20:39,270
gonna work adopt interdependencies

00:20:37,440 --> 00:20:40,800
quickly this is incredibly important and

00:20:39,270 --> 00:20:43,860
the reason why this is important is

00:20:40,800 --> 00:20:45,570
again scale if your dependency releases

00:20:43,860 --> 00:20:47,430
once a year and it takes you half a year

00:20:45,570 --> 00:20:49,380
to adopt their new version and someone

00:20:47,430 --> 00:20:52,490
who uses you takes three months to adopt

00:20:49,380 --> 00:20:56,790
you and one and a half to adopt them and

00:20:52,490 --> 00:21:01,980
have that to adopt them we finally get

00:20:56,790 --> 00:21:03,270
to use n minus 1 when n is released so

00:21:01,980 --> 00:21:03,990
you're permanently one version behind

00:21:03,270 --> 00:21:05,880
that sucks

00:21:03,990 --> 00:21:08,250
that's terrible you as a developer do

00:21:05,880 --> 00:21:09,810
you want your library to not be

00:21:08,250 --> 00:21:11,940
available until you release the next

00:21:09,810 --> 00:21:13,980
version of it it's crazy right you don't

00:21:11,940 --> 00:21:16,200
want that don't wish it upon your fellow

00:21:13,980 --> 00:21:18,060
developers this means that you need to

00:21:16,200 --> 00:21:19,590
adopt new versions of dependencies

00:21:18,060 --> 00:21:20,640
quickly your old versions will still

00:21:19,590 --> 00:21:21,840
support the old versions because that's

00:21:20,640 --> 00:21:23,250
what they did that time your new

00:21:21,840 --> 00:21:24,660
versions will support new versions right

00:21:23,250 --> 00:21:30,830
now you need to support there right now

00:21:24,660 --> 00:21:35,040
version don't replace API is when using

00:21:30,830 --> 00:21:37,710
17 versus 14 so this only applies if you

00:21:35,040 --> 00:21:42,870
are trying to support 14 and 17 at the

00:21:37,710 --> 00:21:44,220
same time so in 17 we added a bunch of

00:21:42,870 --> 00:21:45,690
very nice features to the standard and

00:21:44,220 --> 00:21:48,480
it's reasonable to want to make use of

00:21:45,690 --> 00:21:53,280
them however what I will caution you

00:21:48,480 --> 00:21:56,160
against is do not break your API when

00:21:53,280 --> 00:21:58,050
upgrading the compiler vendors in the

00:21:56,160 --> 00:21:59,299
STL maintained errs they go to enormous

00:21:58,050 --> 00:22:01,070
amounts of effort to

00:21:59,299 --> 00:22:02,149
make these things compatible that you

00:22:01,070 --> 00:22:03,230
can just upgrade your code and

00:22:02,149 --> 00:22:05,419
everything's great and you can do it

00:22:03,230 --> 00:22:07,399
incrementally because it's scale it's

00:22:05,419 --> 00:22:12,379
really hard to upgrade everyone 2:17 at

00:22:07,399 --> 00:22:14,840
once so in order to support this sort of

00:22:12,379 --> 00:22:16,759
vision this goal of our community you

00:22:14,840 --> 00:22:20,480
need to build a single binary that

00:22:16,759 --> 00:22:23,090
supports both and this one's for

00:22:20,480 --> 00:22:24,769
tightest most commonly this is for this

00:22:23,090 --> 00:22:26,360
is caused by polyfills so you will

00:22:24,769 --> 00:22:27,590
polyfill is a term that comes from the

00:22:26,360 --> 00:22:28,879
browser community basically they made a

00:22:27,590 --> 00:22:30,110
new javascript standards people wanted

00:22:28,879 --> 00:22:32,989
the new shiny they were on old and

00:22:30,110 --> 00:22:34,220
busted so then they made a filler that

00:22:32,989 --> 00:22:35,720
implements the new shiny on the old and

00:22:34,220 --> 00:22:37,580
busted almost calmly today that's a

00:22:35,720 --> 00:22:39,230
boost though boost is a little bit

00:22:37,580 --> 00:22:40,909
upside down because boost had it first

00:22:39,230 --> 00:22:42,619
often than the standard but it ends up

00:22:40,909 --> 00:22:45,139
being used as polyfill because you want

00:22:42,619 --> 00:22:49,399
stood thread you can't use 11 so you use

00:22:45,139 --> 00:22:53,149
this bit but when you switch between

00:22:49,399 --> 00:22:56,929
them in your headers this means that you

00:22:53,149 --> 00:22:58,309
cannot build a single binary that

00:22:56,929 --> 00:22:59,809
supports both at the same time which

00:22:58,309 --> 00:23:02,359
means that all of the people who consume

00:22:59,809 --> 00:23:04,999
you potentially transitively if you're

00:23:02,359 --> 00:23:06,950
publicly dependent upon all of them must

00:23:04,999 --> 00:23:08,269
be on the exact same C++ version and

00:23:06,950 --> 00:23:09,739
this is something that the compiler

00:23:08,269 --> 00:23:13,669
vendors have worked really hard to not

00:23:09,739 --> 00:23:16,070
require so there are easy relatively

00:23:13,669 --> 00:23:19,070
easy ways to solve this one is make your

00:23:16,070 --> 00:23:21,529
polyfill implicitly constructible from

00:23:19,070 --> 00:23:22,970
the standard one then you just make your

00:23:21,529 --> 00:23:24,649
polyfill api's always and it's

00:23:22,970 --> 00:23:27,950
implicitly convertible I'll get you at

00:23:24,649 --> 00:23:29,600
the end yeah you can you can make your

00:23:27,950 --> 00:23:31,190
your polyfills implicitly convertible

00:23:29,600 --> 00:23:33,799
that's one option or the other option is

00:23:31,190 --> 00:23:36,320
you can provide both a API sets and as

00:23:33,799 --> 00:23:38,509
long as your binary is built with 17 you

00:23:36,320 --> 00:23:41,629
will provide both api's and then

00:23:38,509 --> 00:23:43,220
consumers will only see the 14 api is if

00:23:41,629 --> 00:23:46,159
they're in 14 and if they're in 17

00:23:43,220 --> 00:23:47,419
they'll see both or just the 17 ones and

00:23:46,159 --> 00:23:52,009
this way you can have one binary that

00:23:47,419 --> 00:23:55,309
does support both both scenarios don't

00:23:52,009 --> 00:23:57,710
worry about ABI worry about API C++

00:23:55,309 --> 00:23:58,759
unfortunately the ABI ship has sailed

00:23:57,710 --> 00:24:00,409
we're trying to pull it back in the

00:23:58,759 --> 00:24:03,049
harbor a little bit but it's it's mostly

00:24:00,409 --> 00:24:04,279
out there so you should take all of that

00:24:03,049 --> 00:24:06,379
effort that you would normally spend on

00:24:04,279 --> 00:24:08,869
worrying about ABI and write really good

00:24:06,379 --> 00:24:10,879
api's it's really easy to recompile my

00:24:08,869 --> 00:24:13,170
code as long as you didn't break me so

00:24:10,879 --> 00:24:15,000
worried about making solid ap

00:24:13,170 --> 00:24:17,520
that you can update in the future take

00:24:15,000 --> 00:24:19,290
the extra steps to not break me when you

00:24:17,520 --> 00:24:20,790
go to upgrade and if you do need to

00:24:19,290 --> 00:24:22,230
break me provide me with some

00:24:20,790 --> 00:24:25,200
documentation that tells me how to deal

00:24:22,230 --> 00:24:27,240
with it if you decide to rename your API

00:24:25,200 --> 00:24:28,920
put a line in your change log that says

00:24:27,240 --> 00:24:30,990
hey I renamed this to that and that way

00:24:28,920 --> 00:24:32,610
when I grep for that old API in your

00:24:30,990 --> 00:24:33,780
codebase I'll see at once it'll be in

00:24:32,610 --> 00:24:35,790
your change log and it'll be a line that

00:24:33,780 --> 00:24:37,430
says hey this renamed to that and I can

00:24:35,790 --> 00:24:41,190
just go and apply that to your consumer

00:24:37,430 --> 00:24:42,330
easy-peasy if you do care about API

00:24:41,190 --> 00:24:44,280
because there are people that do care

00:24:42,330 --> 00:24:46,080
about API don't go halfway right if you

00:24:44,280 --> 00:24:47,790
don't don't do this half API thing if

00:24:46,080 --> 00:24:49,800
you care about API you care about ABI do

00:24:47,790 --> 00:24:51,810
the full API thing have a seam andrey

00:24:49,800 --> 00:24:52,530
don't ever like allocating free across

00:24:51,810 --> 00:24:56,190
dll's

00:24:52,530 --> 00:24:59,310
all the works but the middle ground is

00:24:56,190 --> 00:25:01,020
not a good place have a single clear

00:24:59,310 --> 00:25:03,360
supported version when you have multiple

00:25:01,020 --> 00:25:05,580
supported versions this means that your

00:25:03,360 --> 00:25:07,470
your the people who depend on you now

00:25:05,580 --> 00:25:09,030
have a very difficult choice because

00:25:07,470 --> 00:25:11,250
they say well you say that all of these

00:25:09,030 --> 00:25:12,360
are valid to use I want to use you as a

00:25:11,250 --> 00:25:14,640
dependency does that mean that I need to

00:25:12,360 --> 00:25:16,860
test all of them and you say well yes

00:25:14,640 --> 00:25:18,000
maybe and then they say well I have

00:25:16,860 --> 00:25:19,920
three supported versions and now the

00:25:18,000 --> 00:25:21,270
person who depends on me has to test

00:25:19,920 --> 00:25:22,230
nine different combinations because it's

00:25:21,270 --> 00:25:24,600
every version of me with every version

00:25:22,230 --> 00:25:26,580
of you and the guy next is twenty-seven

00:25:24,600 --> 00:25:28,800
versions and that just doesn't work if

00:25:26,580 --> 00:25:29,730
you have one clear supported version

00:25:28,800 --> 00:25:32,400
that you say this is what you should use

00:25:29,730 --> 00:25:33,420
go use that then everyone can agree okay

00:25:32,400 --> 00:25:35,940
that is the thing that we should target

00:25:33,420 --> 00:25:37,740
this is the corollary the other part of

00:25:35,940 --> 00:25:40,290
the social contract to the adopt

00:25:37,740 --> 00:25:41,880
dependencies quickly your dependency has

00:25:40,290 --> 00:25:42,210
a version that you should use use that

00:25:41,880 --> 00:25:48,570
version

00:25:42,210 --> 00:25:49,980
end of story yes the user standard

00:25:48,570 --> 00:25:50,760
license if you don't use the standard

00:25:49,980 --> 00:25:53,580
license this is actually really

00:25:50,760 --> 00:25:58,320
difficult for companies to adopt your

00:25:53,580 --> 00:25:59,850
code there are some cute licenses they

00:25:58,320 --> 00:26:03,660
make your library more difficult to

00:25:59,850 --> 00:26:06,180
packaging use embedding your license in

00:26:03,660 --> 00:26:07,710
your headers is fine but it needs most

00:26:06,180 --> 00:26:10,440
packaging systems wanted in a dedicated

00:26:07,710 --> 00:26:11,790
file so please do that even if it's

00:26:10,440 --> 00:26:13,020
available in your read me even if it's

00:26:11,790 --> 00:26:15,110
available your headers having a license

00:26:13,020 --> 00:26:17,700
about txt really does make a difference

00:26:15,110 --> 00:26:19,320
sequel like three which is something

00:26:17,700 --> 00:26:21,540
that everyone should have heard of it

00:26:19,320 --> 00:26:22,910
actually has this problem it has its

00:26:21,540 --> 00:26:24,510
claims that it's in the public domain

00:26:22,910 --> 00:26:26,010
unfortunately for a lot of businesses

00:26:24,510 --> 00:26:27,100
that's not very well defined they don't

00:26:26,010 --> 00:26:29,350
have a dedicated license file

00:26:27,100 --> 00:26:31,750
says it and so they have this whole blog

00:26:29,350 --> 00:26:33,340
or blurb on their copyright HTML where

00:26:31,750 --> 00:26:34,360
they basically say well if you want a

00:26:33,340 --> 00:26:36,130
license file you can pay us some money

00:26:34,360 --> 00:26:40,919
we'll give it to you under BSD I don't

00:26:36,130 --> 00:26:40,919
recommend that as a strategy but yeah

00:26:41,309 --> 00:26:48,640
and I'm going to skip the code section

00:26:46,539 --> 00:26:50,130
of this talk it'll be in the slide notes

00:26:48,640 --> 00:26:52,330
you can go look at the map words

00:26:50,130 --> 00:26:53,770
generally speaking there is a few major

00:26:52,330 --> 00:26:55,539
patterns that we've seen here one is

00:26:53,770 --> 00:26:58,840
maintainer czar gonna make mistakes you

00:26:55,539 --> 00:27:00,640
should design your system to be friendly

00:26:58,840 --> 00:27:01,929
to that notice when they're making

00:27:00,640 --> 00:27:03,909
mistakes and say hey you probably didn't

00:27:01,929 --> 00:27:07,720
want this do you want to turn back or do

00:27:03,909 --> 00:27:10,270
you really want that Packaging is more

00:27:07,720 --> 00:27:11,950
than just your library and your users so

00:27:10,270 --> 00:27:13,299
you really need to think about there are

00:27:11,950 --> 00:27:14,620
other libraries between you and the user

00:27:13,299 --> 00:27:16,570
there are diamonds

00:27:14,620 --> 00:27:18,159
there are things underneath you that may

00:27:16,570 --> 00:27:21,520
want to evolve faster than you evolve

00:27:18,159 --> 00:27:23,590
and some of these patterns that would be

00:27:21,520 --> 00:27:25,510
fine if it was just you and your users

00:27:23,590 --> 00:27:30,220
they really start to break down when you

00:27:25,510 --> 00:27:31,330
have more so all of the examples in this

00:27:30,220 --> 00:27:32,559
talk they are libraries that are

00:27:31,330 --> 00:27:33,580
packaged in PC package it's a

00:27:32,559 --> 00:27:36,820
cross-platform package manager by

00:27:33,580 --> 00:27:40,480
Microsoft for Mac Linux Windows we've

00:27:36,820 --> 00:27:42,820
got like 750 libraries and Counting our

00:27:40,480 --> 00:27:44,140
community of maintainer x' deals with

00:27:42,820 --> 00:27:47,980
all of the problems in this talk so that

00:27:44,140 --> 00:27:49,330
you don't have to and if you want to be

00:27:47,980 --> 00:27:51,669
a maintainer or you're an author that

00:27:49,330 --> 00:27:54,100
wants to help out send us a PR we would

00:27:51,669 --> 00:27:57,690
really appreciate it we're on github and

00:27:54,100 --> 00:27:57,690
Microsoft slash T scratch that's all

00:28:05,020 --> 00:28:43,669
so for Titus but Cabot like you super

00:28:41,960 --> 00:28:45,799
don't want to have to vocabulary types

00:28:43,669 --> 00:28:48,200
in the same ecosystem in the same

00:28:45,799 --> 00:28:50,780
codebase and the reason that we did what

00:28:48,200 --> 00:28:54,590
we did is specifically to avoid the

00:28:50,780 --> 00:28:57,470
issues of you can't have ambiguous

00:28:54,590 --> 00:29:02,290
conversions or multiple chains of

00:28:57,470 --> 00:29:07,580
implicit conversions or overload sets or

00:29:02,290 --> 00:29:09,890
specializations when those types don't

00:29:07,580 --> 00:29:12,410
both of this at the same time and I

00:29:09,890 --> 00:29:16,510
think the the fundamental answer is

00:29:12,410 --> 00:29:19,730
there's not a good solution here but

00:29:16,510 --> 00:29:22,690
yeah like I sorry

00:29:19,730 --> 00:29:25,130
you're making your life more difficult

00:29:22,690 --> 00:29:27,799
pretty sure that we have made the users

00:29:25,130 --> 00:29:31,010
lives easier um the there is a third

00:29:27,799 --> 00:29:32,179
option which was not listed well it was

00:29:31,010 --> 00:29:34,580
listed but it wasn't explicitly listed

00:29:32,179 --> 00:29:37,010
which is uh don't polyfill say you only

00:29:34,580 --> 00:29:38,299
require C++ 17 that's also a solution to

00:29:37,010 --> 00:29:47,090
the problem I just want to point that

00:29:38,299 --> 00:29:50,750
out but thank you very much nice I have

00:29:47,090 --> 00:29:52,549
a problem though I didn't quite catch a

00:29:50,750 --> 00:29:54,740
good solution to the dependencies

00:29:52,549 --> 00:29:57,590
problem say I write a library and it has

00:29:54,740 --> 00:30:03,260
a bunch of dependency nothin you first

00:29:57,590 --> 00:30:06,290
said that I shouldn't rely on a

00:30:03,260 --> 00:30:10,210
particular package manager and also that

00:30:06,290 --> 00:30:15,409
I shouldn't have dependencies and then

00:30:10,210 --> 00:30:17,340
what how can I make vegetable library

00:30:15,409 --> 00:30:19,740
with multiple dependencies

00:30:17,340 --> 00:30:21,749
and not rely on a single thank you

00:30:19,740 --> 00:30:23,249
manager absolutely so this talk is not

00:30:21,749 --> 00:30:25,230
necessarily meant to be a single

00:30:23,249 --> 00:30:26,730
prescriptive you should do this this

00:30:25,230 --> 00:30:29,820
this and you will be package' ball it's

00:30:26,730 --> 00:30:31,830
more of a if you do these things it's

00:30:29,820 --> 00:30:33,749
gonna be harder that's all

00:30:31,830 --> 00:30:34,860
so definitely if you have dependencies

00:30:33,749 --> 00:30:36,870
you need dependencies like I'm not

00:30:34,860 --> 00:30:38,700
saying don't use OpenSSL don't roll your

00:30:36,870 --> 00:30:41,850
own crypto right like definitely use

00:30:38,700 --> 00:30:43,139
open SSL okay but but that means that

00:30:41,850 --> 00:30:44,549
you need to deal with that and what that

00:30:43,139 --> 00:30:46,590
means is you need to follow your build

00:30:44,549 --> 00:30:48,929
systems best practices for how to depend

00:30:46,590 --> 00:30:50,399
on the thing ideally you only depend on

00:30:48,929 --> 00:30:51,869
what you really really need and so it's

00:30:50,399 --> 00:30:53,190
not optional if you want to have

00:30:51,869 --> 00:30:54,450
optional things make other libraries

00:30:53,190 --> 00:30:55,950
that people could optionally choose to

00:30:54,450 --> 00:30:57,840
use that library or not that's a whole

00:30:55,950 --> 00:30:58,919
separate thing right so if you have a

00:30:57,840 --> 00:31:00,419
set of dependencies and that's what you

00:30:58,919 --> 00:31:02,519
need then that's what you need

00:31:00,419 --> 00:31:04,350
adopting versions quickly you do all of

00:31:02,519 --> 00:31:06,240
the things that do apply right so this

00:31:04,350 --> 00:31:08,399
is not intended to be do all of these

00:31:06,240 --> 00:31:10,559
things it's a think about all of these

00:31:08,399 --> 00:31:12,210
things and do what applies to you and

00:31:10,559 --> 00:31:15,600
what makes sense in your situation but

00:31:12,210 --> 00:31:19,019
thank you for the question regarding the

00:31:15,600 --> 00:31:21,509
recommendation to not auto detect things

00:31:19,019 --> 00:31:24,570
I'm sorry the recommendations are not

00:31:21,509 --> 00:31:26,190
auto-detects yes things yes in your

00:31:24,570 --> 00:31:27,779
environment how far would you go that

00:31:26,190 --> 00:31:30,269
would you include figuring out which

00:31:27,779 --> 00:31:32,519
operating system you're on I would

00:31:30,269 --> 00:31:33,779
strongly recommend because most most

00:31:32,519 --> 00:31:36,090
developers most open-source projects

00:31:33,779 --> 00:31:38,490
that I've seen they will be much better

00:31:36,090 --> 00:31:40,289
served with simply checking macros in

00:31:38,490 --> 00:31:41,879
their header it's way easier to deal

00:31:40,289 --> 00:31:43,740
with headers than it is to deal with

00:31:41,879 --> 00:31:45,840
build systems because although the

00:31:43,740 --> 00:31:48,720
headers are C++ I know C++ I don't know

00:31:45,840 --> 00:31:50,100
your 5,000 line Perl script so if you

00:31:48,720 --> 00:31:51,389
ordered it if you detect inside of a

00:31:50,100 --> 00:31:53,850
header saying if windows do this if

00:31:51,389 --> 00:31:56,190
Linux do this if it fails to build on my

00:31:53,850 --> 00:31:57,389
crazy system that is unique it's really

00:31:56,190 --> 00:31:59,399
easy for me to just go in there and add

00:31:57,389 --> 00:32:01,259
an if-else for me right that's that's

00:31:59,399 --> 00:32:03,149
really easy for me to understand if it

00:32:01,259 --> 00:32:04,950
detects that I happen to have M map but

00:32:03,149 --> 00:32:06,450
an amount doesn't pull in this other

00:32:04,950 --> 00:32:07,590
header that you implicitly depended upon

00:32:06,450 --> 00:32:09,720
that you didn't know about like that's

00:32:07,590 --> 00:32:11,159
way harder for me to deal with so that

00:32:09,720 --> 00:32:14,220
is what I would recommend is if you

00:32:11,159 --> 00:32:17,159
can't if you need to do button stuff use

00:32:14,220 --> 00:32:19,769
the OS macros thank you very much for

00:32:17,159 --> 00:32:21,450
the question about your recommendation

00:32:19,769 --> 00:32:24,019
to switch to new versions of

00:32:21,450 --> 00:32:25,950
dependencies quickly support them

00:32:24,019 --> 00:32:26,669
support okay maybe that's actually

00:32:25,950 --> 00:32:29,250
already the answer

00:32:26,669 --> 00:32:31,049
so like the question is if I'm switching

00:32:29,250 --> 00:32:32,460
to new version like how am I gonna

00:32:31,049 --> 00:32:34,139
that work for like all the distributions

00:32:32,460 --> 00:32:37,009
of a bundle for example like I'm gonna

00:32:34,139 --> 00:32:40,440
make life for the picture hard right so

00:32:37,009 --> 00:32:42,899
if things don't work if we insist that

00:32:40,440 --> 00:32:44,309
every library needs to support a hundred

00:32:42,899 --> 00:32:46,379
versions of all of their dependencies

00:32:44,309 --> 00:32:50,549
right that totally just does not work at

00:32:46,379 --> 00:32:53,129
scale so the solution for this is you do

00:32:50,549 --> 00:32:56,009
need to decide what sorry huh in the

00:32:53,129 --> 00:32:58,080
half of the talk it is support the

00:32:56,009 --> 00:32:59,639
supported version that's it the author

00:32:58,080 --> 00:33:00,720
of the project will tell you what

00:32:59,639 --> 00:33:02,009
version you should use and you should

00:33:00,720 --> 00:33:03,029
use that version at any given point in

00:33:02,009 --> 00:33:05,249
time if you're doing development you

00:33:03,029 --> 00:33:05,580
should be targeting that version end of

00:33:05,249 --> 00:33:07,379
story

00:33:05,580 --> 00:33:08,549
because that works right everyone is

00:33:07,379 --> 00:33:10,679
using the supported versions and it

00:33:08,549 --> 00:33:12,359
works now taking that head off a little

00:33:10,679 --> 00:33:14,190
bit you do need to support a bunch of

00:33:12,359 --> 00:33:15,299
right so you may choose to support both

00:33:14,190 --> 00:33:18,720
of those versions the version in a bunch

00:33:15,299 --> 00:33:20,570
you in or the version that is latest oh

00:33:18,720 --> 00:33:22,679
I am so sorry

00:33:20,570 --> 00:33:25,559
thank you everyone for coming I really

00:33:22,679 --> 00:33:25,880
appreciate it it's it's great to see

00:33:25,559 --> 00:33:28,239
somebody

00:33:25,880 --> 00:33:28,239

YouTube URL: https://www.youtube.com/watch?v=sBP17HQAQjk


