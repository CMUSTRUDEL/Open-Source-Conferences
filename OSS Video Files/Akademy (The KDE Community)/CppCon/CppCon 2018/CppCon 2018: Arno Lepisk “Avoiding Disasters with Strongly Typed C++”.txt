Title: CppCon 2018: Arno Lepisk “Avoiding Disasters with Strongly Typed C++”
Publication date: 2018-10-12
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
C++ is often described as a type-safe language — the compiler will not allow the programmer to mix types freely. But do we really use C++ in a type-safe manner? When a programmer uses the same type to represent different quantities, one could argue that the compiler's type-checks are bypassed and errors due to mix-ups not only become possible, but frequent! In this session a solution to this problem will be presented — strong types. 

Strong types are a type-safe alternative to typedefs — but where typedefs only provide documentation and ease of writing, their strong counterparts are actually enforced by the compiler. We will explore how they work, and how using them can improve code quality. We will look at how one can implement a strong typedef by oneself, but also look at some of the readily available implementations which are available. 

Finally we will look at how we can handle some special cases, e.g. where we need to allow two different strong types to interact with each other in well defined ways. These could be types representing two different linked quantities like positions and offsets; or scaled versions of the same quantity like different units of length.
— 
Arno Lepisk, HiQ
Software engineer

Arno first came into contact with C++ in the late 90's. After getting a masters degree in engineering physics he has been programming professionally in C++ for over a decade, mostly for different embedded applications within industrial control, defense, gaming, and tele- and datacom.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,620 --> 00:00:07,710
good morning welcome to my talk on

00:00:04,850 --> 00:00:12,780
avoiding disasters would strongly type 2

00:00:07,710 --> 00:00:18,359
c plus plus let's start with putting

00:00:12,780 --> 00:00:21,510
this up in other words the sooner we

00:00:18,359 --> 00:00:26,250
find bugs or the later we find bugs the

00:00:21,510 --> 00:00:27,920
more expensive and hard it gets to fix

00:00:26,250 --> 00:00:31,830
them

00:00:27,920 --> 00:00:33,899
am I my name is Oren Lafitte I live in

00:00:31,830 --> 00:00:36,210
Stockholm Sweden where I work as a

00:00:33,899 --> 00:00:38,820
software engineering consultant for a

00:00:36,210 --> 00:00:42,570
company named hi cute I've been working

00:00:38,820 --> 00:00:44,430
with C++ for a little bit more than 12

00:00:42,570 --> 00:00:49,579
years in fields such as

00:00:44,430 --> 00:00:57,270
Defense datacom Telecom with your games

00:00:49,579 --> 00:00:59,300
industrial applications when do we want

00:00:57,270 --> 00:01:03,090
bugs to be found

00:00:59,300 --> 00:01:09,000
one could argue never because we never

00:01:03,090 --> 00:01:17,759
write bugs right as anyone never wrote a

00:01:09,000 --> 00:01:22,080
bug great sure the comment was that you

00:01:17,759 --> 00:01:27,869
don't write bugs they just appear what

00:01:22,080 --> 00:01:31,950
if we find bugs in production that's

00:01:27,869 --> 00:01:34,850
expensive right if you build embedded

00:01:31,950 --> 00:01:43,829
systems you may may have to do recalls

00:01:34,850 --> 00:01:47,670
or at least send out patches it it it

00:01:43,829 --> 00:01:50,790
affects your customer relations and such

00:01:47,670 --> 00:01:55,979
in extreme cases have you heard of the

00:01:50,790 --> 00:02:00,240
Mars orbiter that was a disaster in

00:01:55,979 --> 00:02:05,520
production ok we can't find bugs in

00:02:00,240 --> 00:02:07,439
quality assurance good system testing if

00:02:05,520 --> 00:02:10,649
you have automated system tests even

00:02:07,439 --> 00:02:16,379
better unit tests do

00:02:10,649 --> 00:02:20,780
everyone use unit tests what about if we

00:02:16,379 --> 00:02:28,400
could find bugs already at compile time

00:02:20,780 --> 00:02:28,400
so bugs never even get to actual code

00:02:29,390 --> 00:02:40,319
I'm going to talk today about a special

00:02:35,730 --> 00:02:45,530
kind of bugs that come from mixing up

00:02:40,319 --> 00:02:45,530
types and using types in the wrong way

00:02:46,190 --> 00:02:53,190
type safety

00:02:49,010 --> 00:02:56,250
what's type safety one definition is

00:02:53,190 --> 00:02:59,480
that the language is type safe if it's

00:02:56,250 --> 00:03:02,389
prevents type errors and by that we mean

00:02:59,480 --> 00:03:05,299
undesirable the behavior you to type

00:03:02,389 --> 00:03:12,260
incompatible in compete in

00:03:05,299 --> 00:03:12,260
compatibilities so is C++ type safe

00:03:13,010 --> 00:03:19,769
let's look at some example in that first

00:03:16,169 --> 00:03:26,480
example your function that sets a node

00:03:19,769 --> 00:03:32,150
name for a node identified by an int and

00:03:26,480 --> 00:03:36,150
if we call the method and mix up the

00:03:32,150 --> 00:03:39,680
operations so we try to set a name or a

00:03:36,150 --> 00:03:43,949
string where the method method accepts

00:03:39,680 --> 00:03:48,569
expects int or vice-versa

00:03:43,949 --> 00:03:55,729
we get a compiler great another method

00:03:48,569 --> 00:03:55,729
that takes two int disaster

00:03:57,959 --> 00:04:05,870
because even if we named our variables

00:04:01,790 --> 00:04:11,400
sighs an int the compiler doesn't care

00:04:05,870 --> 00:04:16,859
did you say that it's an int who has

00:04:11,400 --> 00:04:19,949
making mistakes like this okay what can

00:04:16,859 --> 00:04:26,660
we do first thought well let's use this

00:04:19,949 --> 00:04:31,020
type def or using clause does that work

00:04:26,660 --> 00:04:36,120
no and why it because the type def only

00:04:31,020 --> 00:04:41,039
creates an alias for the type so the

00:04:36,120 --> 00:04:45,020
compiler still sees in even if we my may

00:04:41,039 --> 00:04:45,020
even if we call it a different name

00:04:45,080 --> 00:04:59,580
let's put a rally's into structs now the

00:04:54,510 --> 00:05:03,030
types get our distinct types so the

00:04:59,580 --> 00:05:10,940
compiler can can one or even it gives us

00:05:03,030 --> 00:05:17,669
an error if we mix the types up great

00:05:10,940 --> 00:05:19,740
we're there as I see here these are

00:05:17,669 --> 00:05:22,470
structs so we have to use the curly

00:05:19,740 --> 00:05:29,639
brace initialization we can fix that we

00:05:22,470 --> 00:05:33,210
add the constructor and this is very

00:05:29,639 --> 00:05:36,510
much save the code or it actually

00:05:33,210 --> 00:05:40,430
compiles but if you do it for real you

00:05:36,510 --> 00:05:43,099
need you should add more stuff too

00:05:40,430 --> 00:05:46,669
actually

00:05:43,099 --> 00:05:48,990
yeah they make it behave sanely

00:05:46,669 --> 00:05:50,699
something Simon Brown make made an

00:05:48,990 --> 00:05:52,849
excellent talk yesterday about the type

00:05:50,699 --> 00:05:58,500
wrappers

00:05:52,849 --> 00:06:01,830
okay maybe now we have constructors

00:05:58,500 --> 00:06:05,490
maybe we want some other methods and it

00:06:01,830 --> 00:06:07,650
quickly becomes quite a lot to write if

00:06:05,490 --> 00:06:09,860
you have to do this for every single

00:06:07,650 --> 00:06:10,990
type we use in a program

00:06:09,860 --> 00:06:18,260
[Applause]

00:06:10,990 --> 00:06:20,270
enter templates if you look at it this

00:06:18,260 --> 00:06:23,300
template code you see that we have a

00:06:20,270 --> 00:06:29,990
type name tag that actually isn't used

00:06:23,300 --> 00:06:34,370
anywhere in the type so it is just what

00:06:29,990 --> 00:06:40,480
we call it it's a tag so we can make

00:06:34,370 --> 00:06:45,890
distinct types by having distinct tags

00:06:40,480 --> 00:06:47,990
this creates two identical or not

00:06:45,890 --> 00:06:53,050
identical creates two distinct types

00:06:47,990 --> 00:06:58,580
that for every other aspect is are

00:06:53,050 --> 00:07:01,640
identical I have a performance for this

00:06:58,580 --> 00:07:10,010
time we put it into the compiler drawer

00:07:01,640 --> 00:07:12,440
we have two methods that one takes an

00:07:10,010 --> 00:07:18,580
ordinary and one takes or wrapped int

00:07:12,440 --> 00:07:18,580
and generated assembly is the same

00:07:21,970 --> 00:07:29,080
provided that you put that you turn on

00:07:24,440 --> 00:07:34,160
some optimization and use a reset

00:07:29,080 --> 00:07:42,350
reasonably recent compiler and here's

00:07:34,160 --> 00:07:45,890
another example where we take in strong

00:07:42,350 --> 00:07:49,070
int and pass it on to a legacy function

00:07:45,890 --> 00:07:51,440
that takes an int and also because the

00:07:49,070 --> 00:07:53,360
representation of a track that only

00:07:51,440 --> 00:07:59,570
contains an int is the same as an

00:07:53,360 --> 00:08:02,590
anything great but say that we actually

00:07:59,570 --> 00:08:08,840
want something that behaves like in it

00:08:02,590 --> 00:08:13,750
that we can add subtract so let's create

00:08:08,840 --> 00:08:16,880
a new math new template coldest

00:08:13,750 --> 00:08:19,970
arithmetic strong int and why don't we

00:08:16,880 --> 00:08:22,610
just extend the first one well because

00:08:19,970 --> 00:08:26,960
sometimes you don't want a name

00:08:22,610 --> 00:08:31,639
and int like behavior how many have used

00:08:26,960 --> 00:08:35,659
the raw socket programming on a UNIX

00:08:31,639 --> 00:08:39,979
system or Linux system what represents a

00:08:35,659 --> 00:08:43,339
socket it's an int what's reasonable to

00:08:39,979 --> 00:08:45,640
do with that don't you pass it to the

00:08:43,339 --> 00:08:55,040
socket functions yes

00:08:45,640 --> 00:09:01,790
but adding to it so so for that you

00:08:55,040 --> 00:09:06,260
don't want so let's make these are the

00:09:01,790 --> 00:09:09,680
operators but this quickly starts to get

00:09:06,260 --> 00:09:13,190
rather much writing so someone must have

00:09:09,680 --> 00:09:17,329
thought about this before so quick

00:09:13,190 --> 00:09:21,050
google search for strong type depths you

00:09:17,329 --> 00:09:28,959
it turns out up quite a lot to results I

00:09:21,050 --> 00:09:32,720
picked I pick a young Safari sorry I

00:09:28,959 --> 00:09:36,050
picture your invoker is name type and

00:09:32,720 --> 00:09:38,480
your middle-earth type safe library and

00:09:36,050 --> 00:09:43,880
let's see how we can use those two

00:09:38,480 --> 00:09:48,920
libraries to do what we want they work

00:09:43,880 --> 00:09:54,050
in a bit different ways the name type

00:09:48,920 --> 00:10:01,790
library works like the one I showed

00:09:54,050 --> 00:10:05,750
recently you use a tag so for this we

00:10:01,790 --> 00:10:11,750
can use we we create an int this has a

00:10:05,750 --> 00:10:15,589
skill or called comparable so this adds

00:10:11,750 --> 00:10:19,370
the comparison comparison operators to

00:10:15,589 --> 00:10:24,290
this type and thank same for type safe

00:10:19,370 --> 00:10:26,980
that uses a bit other constructs there

00:10:24,290 --> 00:10:32,180
you create a new struct and inherit from

00:10:26,980 --> 00:10:35,030
the from a base type for all strong

00:10:32,180 --> 00:10:38,000
types what strong type def

00:10:35,030 --> 00:10:40,940
and then the you use CR TP as a

00:10:38,000 --> 00:10:44,020
curiously recurring template pattern to

00:10:40,940 --> 00:10:48,320
forward your own name down into the

00:10:44,020 --> 00:10:52,970
barber and then you have to use the

00:10:48,320 --> 00:10:57,820
using constructor to make sure that the

00:10:52,970 --> 00:11:05,980
constructor since the wall available

00:10:57,820 --> 00:11:05,980
crystal clear so let's make an it again

00:11:08,770 --> 00:11:17,720
for the name type library again we say

00:11:13,010 --> 00:11:22,760
we want an int we use the tag my type my

00:11:17,720 --> 00:11:27,380
int tag and specify which operations we

00:11:22,760 --> 00:11:30,740
want printable it's for making it

00:11:27,380 --> 00:11:32,750
possible to output it to an O stream add

00:11:30,740 --> 00:11:38,530
a little subtract ability political and

00:11:32,750 --> 00:11:41,420
comparable no division for some reason

00:11:38,530 --> 00:11:45,560
in the version that I checked out we'll

00:11:41,420 --> 00:11:50,000
come to back to that and for the strong

00:11:45,560 --> 00:11:52,670
type Lib we inherit from this drop first

00:11:50,000 --> 00:11:55,850
from the base strong type def and then

00:11:52,670 --> 00:11:57,860
from output operator into your

00:11:55,850 --> 00:12:03,250
arithmetic equality compression

00:11:57,860 --> 00:12:05,930
compression and relational operation and

00:12:03,250 --> 00:12:10,870
there we get something that more or less

00:12:05,930 --> 00:12:15,940
behaves like an int if we do normal

00:12:10,870 --> 00:12:20,000
arithmetic sum no bit operations or such

00:12:15,940 --> 00:12:23,200
and how do we use it if you define it in

00:12:20,000 --> 00:12:29,240
this way we can use both ends

00:12:23,200 --> 00:12:34,220
interchangeably so we can create two ins

00:12:29,240 --> 00:12:38,360
with values and we can add them and then

00:12:34,220 --> 00:12:40,310
we can use static assert to check that

00:12:38,360 --> 00:12:44,900
the type actually get we get the same

00:12:40,310 --> 00:12:47,860
type back and we cannot but if we try to

00:12:44,900 --> 00:12:51,439
add ordinary

00:12:47,860 --> 00:12:56,920
in the commented out code we get a

00:12:51,439 --> 00:12:56,920
compiler that's what we wanted right

00:12:57,910 --> 00:13:03,050
sometimes we need to get the underlying

00:13:00,379 --> 00:13:04,910
value out and they're the latest you

00:13:03,050 --> 00:13:08,209
libraries differ how we do it

00:13:04,910 --> 00:13:11,240
her name type you get a member operation

00:13:08,209 --> 00:13:14,329
called get then you get it out and for

00:13:11,240 --> 00:13:16,759
the types if you get there's a

00:13:14,329 --> 00:13:20,749
free-standing function get that you can

00:13:16,759 --> 00:13:22,639
use to get the value out this become

00:13:20,749 --> 00:13:28,970
comes a little bit important later when

00:13:22,639 --> 00:13:31,850
we do adoptions for it okay in sometimes

00:13:28,970 --> 00:13:34,309
we need to combine types here we showed

00:13:31,850 --> 00:13:39,100
we can add two of these millions but

00:13:34,309 --> 00:13:43,730
sometimes we want to interact between

00:13:39,100 --> 00:13:47,170
types say if we want to calculate a

00:13:43,730 --> 00:13:49,970
price from a base price and an amount

00:13:47,170 --> 00:13:53,149
then we need to multiply these two

00:13:49,970 --> 00:13:58,040
together and get a new price so how do

00:13:53,149 --> 00:14:01,879
you do this first the table of what what

00:13:58,040 --> 00:14:03,949
kind of operations we would like that's

00:14:01,879 --> 00:14:07,129
it we can add to prices get a price

00:14:03,949 --> 00:14:10,490
subtract two prices get a new price the

00:14:07,129 --> 00:14:14,029
same with the amount multiply price with

00:14:10,490 --> 00:14:17,720
price doesn't make sense right skip that

00:14:14,029 --> 00:14:21,470
and the same thing multiply an amount

00:14:17,720 --> 00:14:23,600
with an amount doesn't make sense but if

00:14:21,470 --> 00:14:26,029
you take a price times in an out or an

00:14:23,600 --> 00:14:29,059
amount times the price we should get a

00:14:26,029 --> 00:14:34,670
price so how do you accomplish that in

00:14:29,059 --> 00:14:40,279
typesafe it's it's already there we add

00:14:34,670 --> 00:14:44,149
a new skill mixed multiplication where

00:14:40,279 --> 00:14:46,459
we say that the price should be you

00:14:44,149 --> 00:14:52,129
should be able to mix it with an amount

00:14:46,459 --> 00:14:55,249
and then it renders a new price for name

00:14:52,129 --> 00:14:59,899
type direction isn't sub anything like

00:14:55,249 --> 00:15:02,889
this built-in but it's easy or for some

00:14:59,899 --> 00:15:02,889
value of easy

00:15:04,329 --> 00:15:15,679
so we add a mixed multiplicative scale

00:15:11,629 --> 00:15:18,949
and all of these skills for this are

00:15:15,679 --> 00:15:22,610
implemented like this here we have added

00:15:18,949 --> 00:15:25,610
an outer template so we say if we read

00:15:22,610 --> 00:15:33,499
this from the inside out we add an

00:15:25,610 --> 00:15:39,470
operator star with takes self and the

00:15:33,499 --> 00:15:42,110
template sized template M other gets the

00:15:39,470 --> 00:15:45,589
underlying value and multiplies them

00:15:42,110 --> 00:15:54,110
together and returns a T and T in this

00:15:45,589 --> 00:15:58,399
case is the the type we have and we have

00:15:54,110 --> 00:16:02,779
to do this twice because we want to be

00:15:58,399 --> 00:16:04,790
able to have the operators in both

00:16:02,779 --> 00:16:11,689
weight like price times amount and

00:16:04,790 --> 00:16:13,999
amount times price and yeah and that

00:16:11,689 --> 00:16:19,309
there's an added helper function called

00:16:13,999 --> 00:16:24,170
get value but actually that if you put

00:16:19,309 --> 00:16:26,929
in if you put in a name type it uses the

00:16:24,170 --> 00:16:31,129
dots get operation to get to type any

00:16:26,929 --> 00:16:35,329
for you but in a plane value it just

00:16:31,129 --> 00:16:39,079
returns the value we'll come back to why

00:16:35,329 --> 00:16:44,540
that's important soon and now we use the

00:16:39,079 --> 00:16:50,119
scale like this mix multiple equal

00:16:44,540 --> 00:16:53,470
amount cone cone type because the inner

00:16:50,119 --> 00:16:53,470
Clause is called type

00:16:59,449 --> 00:17:08,400
next we have an example of positions and

00:17:03,569 --> 00:17:12,059
offsets you have a position and then you

00:17:08,400 --> 00:17:16,949
have something else a bit away

00:17:12,059 --> 00:17:19,289
then there's offset between them one

00:17:16,949 --> 00:17:21,390
place this comes in into standard zero

00:17:19,289 --> 00:17:25,020
plasticity take pointers and pointer

00:17:21,390 --> 00:17:25,709
differences for example here is the

00:17:25,020 --> 00:17:29,039
tricky part

00:17:25,709 --> 00:17:31,350
in this case that we have to take two

00:17:29,039 --> 00:17:36,510
positions subtract them from each other

00:17:31,350 --> 00:17:40,590
and render another type the offset how

00:17:36,510 --> 00:17:46,460
do we do that name type we looked at

00:17:40,590 --> 00:17:50,640
eight types recently it's about the same

00:17:46,460 --> 00:17:54,900
same method we have a strike to subtract

00:17:50,640 --> 00:17:58,320
to type didn't come up with a better

00:17:54,900 --> 00:18:02,150
name there's two hard problems in

00:17:58,320 --> 00:18:09,150
computer engineering cache invalidation

00:18:02,150 --> 00:18:14,520
naming and off-by-one errors subject to

00:18:09,150 --> 00:18:17,100
type of flaw so here we subtract the two

00:18:14,520 --> 00:18:22,980
underlying values put them into the

00:18:17,100 --> 00:18:26,340
enclosing type and marina and then we

00:18:22,980 --> 00:18:30,750
reuse it in a manner very similar today

00:18:26,340 --> 00:18:37,710
to the way we did before and here we all

00:18:30,750 --> 00:18:40,919
see you we've added mixed edible in in a

00:18:37,710 --> 00:18:45,299
manner similar to all this code it will

00:18:40,919 --> 00:18:47,909
be available for you and here also you

00:18:45,299 --> 00:18:49,820
can see I use mixed multiplicative with

00:18:47,909 --> 00:18:54,830
a basic type so you can actually

00:18:49,820 --> 00:18:54,830
multiply offsets with planes

00:18:58,240 --> 00:19:13,559
typesafe it's about the same method it's

00:19:10,059 --> 00:19:20,410
just a bit like what you call it

00:19:13,559 --> 00:19:22,270
implementation details and I've cut away

00:19:20,410 --> 00:19:26,050
they know except stuff because it's just

00:19:22,270 --> 00:19:28,540
the same thing repeated once again and

00:19:26,050 --> 00:19:30,040
here we can use it again subtract to

00:19:28,540 --> 00:19:35,590
type you see there's no there next to

00:19:30,040 --> 00:19:41,340
lost long should have been hiding okay

00:19:35,590 --> 00:19:45,850
and then we can use this like this so we

00:19:41,340 --> 00:19:47,890
create the petition and then we can

00:19:45,850 --> 00:19:52,140
create them offset by subtracting

00:19:47,890 --> 00:19:56,140
another position from that position and

00:19:52,140 --> 00:20:05,100
if we try to add two positions we get a

00:19:56,140 --> 00:20:09,730
compiler nowhere is there and here I'm

00:20:05,100 --> 00:20:12,010
when I sat and developed this I after a

00:20:09,730 --> 00:20:13,870
while it got very tedious to see which

00:20:12,010 --> 00:20:17,550
files were supposed to compile which

00:20:13,870 --> 00:20:21,070
weren't supposed to compile so I wrote

00:20:17,550 --> 00:20:25,809
helper that actually checks if there is

00:20:21,070 --> 00:20:28,170
an operation plus between position

00:20:25,809 --> 00:20:30,610
pictures I can use static assertion is

00:20:28,170 --> 00:20:33,010
here I'm not going to go through this

00:20:30,610 --> 00:20:38,100
it's here look at the videos that later

00:20:33,010 --> 00:20:38,100
or check out my github links will come

00:20:38,220 --> 00:20:46,530
length this is what actually started my

00:20:41,559 --> 00:20:48,820
interest in this yes my background

00:20:46,530 --> 00:20:51,429
educational background at least isn't

00:20:48,820 --> 00:20:55,620
really computer science it's in

00:20:51,429 --> 00:21:01,090
engineering physics and there we often

00:20:55,620 --> 00:21:04,929
when we calculate stuff by hand

00:21:01,090 --> 00:21:08,740
the standard method to do Jackie this

00:21:04,929 --> 00:21:09,830
yeah dimensional analysis and from there

00:21:08,740 --> 00:21:12,169
we go

00:21:09,830 --> 00:21:21,950
okay what's the what's wrong with this

00:21:12,169 --> 00:21:29,509
method what do we mean by length meter

00:21:21,950 --> 00:21:32,600
what units is yeah precisely what unit

00:21:29,509 --> 00:21:39,590
is the is the length is it meters

00:21:32,600 --> 00:21:41,960
millimeters feet yards we could create

00:21:39,590 --> 00:21:48,039
the type like we did before saying it's

00:21:41,960 --> 00:21:51,169
meter T but then then maybe someone else

00:21:48,039 --> 00:21:55,190
it's more convenient it's more

00:21:51,169 --> 00:22:00,440
accustomed to counting in feet and then

00:21:55,190 --> 00:22:01,700
you have to start making conversion

00:22:00,440 --> 00:22:03,889
operations between them

00:22:01,700 --> 00:22:07,249
and then you have someone who wants

00:22:03,889 --> 00:22:10,549
millimeters then you have 2 to the third

00:22:07,249 --> 00:22:13,159
power and so on and so on certain number

00:22:10,549 --> 00:22:21,590
of conversion operations grow

00:22:13,159 --> 00:22:25,609
exponentially but let's think again what

00:22:21,590 --> 00:22:30,739
did we have in the C++ standard we have

00:22:25,609 --> 00:22:35,409
the corona library which does about this

00:22:30,739 --> 00:22:39,619
thing but with time you can create

00:22:35,409 --> 00:22:45,379
seconds and milliseconds and add them

00:22:39,619 --> 00:22:50,739
together and get correct results so in

00:22:45,379 --> 00:22:53,629
this example I create one variable with

00:22:50,739 --> 00:22:57,789
seconds and then convert it to

00:22:53,629 --> 00:22:59,210
milliseconds and that's the rate ratio

00:22:57,789 --> 00:23:03,460
1,000 the queendom

00:22:59,210 --> 00:23:07,009
so let's just hijacked it Crona lib

00:23:03,460 --> 00:23:14,169
define one meter has once second and so

00:23:07,009 --> 00:23:16,700
on that would

00:23:14,169 --> 00:23:20,839
take away all the types of people that

00:23:16,700 --> 00:23:23,959
because then we could add seconds to

00:23:20,839 --> 00:23:26,679
length or time to lengthen that just

00:23:23,959 --> 00:23:31,099
doesn't make any sense and that's how

00:23:26,679 --> 00:23:33,109
yeah bad things happen but we can look

00:23:31,099 --> 00:23:38,959
at how this duration Clause is

00:23:33,109 --> 00:23:44,329
implemented and maybe reuse it this is

00:23:38,959 --> 00:23:49,219
the Geist of the duration or the chrono

00:23:44,329 --> 00:23:52,099
duration defines you have seconds it's a

00:23:49,219 --> 00:23:54,889
current iteration of the standard

00:23:52,099 --> 00:23:56,989
doesn't actually say it has to be in 64

00:23:54,889 --> 00:23:59,899
it just says set some kind of lower

00:23:56,989 --> 00:24:04,789
bound some lower bounds on how many bits

00:23:59,899 --> 00:24:09,349
you have to use the two implementations

00:24:04,789 --> 00:24:12,049
I looked at both using 64 and then we

00:24:09,349 --> 00:24:20,599
have milliseconds that use something

00:24:12,049 --> 00:24:27,879
called merely what's that STD rates you

00:24:20,599 --> 00:24:31,129
how many of you have used STD ratio for

00:24:27,879 --> 00:24:35,539
everyone else it's it's a standardized

00:24:31,129 --> 00:24:40,759
way how to do rational arithmetic at

00:24:35,539 --> 00:24:43,999
compile time so what this means is that

00:24:40,759 --> 00:24:53,299
Millie is a ratio 1 through a thousand

00:24:43,999 --> 00:24:57,309
one top thousands so thousand and it

00:24:53,299 --> 00:25:01,419
also it shortens the ratio ratio the

00:24:57,309 --> 00:25:05,409
fractions automatically if you want and

00:25:01,419 --> 00:25:05,409
it defines different

00:25:05,559 --> 00:25:14,599
arithmetic operations on such fractions

00:25:09,909 --> 00:25:18,249
so how can we use this let's start our

00:25:14,599 --> 00:25:18,249
new own at length cloth

00:25:26,440 --> 00:25:35,210
with the final length we left the

00:25:33,049 --> 00:25:39,559
template take care of which underlying

00:25:35,210 --> 00:25:43,190
type we want insert doubles or vectors

00:25:39,559 --> 00:25:47,080
or whatever and then we use a scale with

00:25:43,190 --> 00:25:50,740
the full to scale to one and then

00:25:47,080 --> 00:25:55,279
there's lots and lots and lots of

00:25:50,740 --> 00:26:02,779
methods in in there then we can make

00:25:55,279 --> 00:26:06,169
some defines rule is say that a meter is

00:26:02,779 --> 00:26:09,679
the base type a millimeter is 10 1000

00:26:06,169 --> 00:26:14,750
and we use the standard provided

00:26:09,679 --> 00:26:17,960
prefixes melee kilo and so on and we can

00:26:14,750 --> 00:26:20,840
also define inch and foot a mile if we

00:26:17,960 --> 00:26:29,090
do if you start counting on them you see

00:26:20,840 --> 00:26:31,370
that one inch is 25.4 millimeters and if

00:26:29,090 --> 00:26:32,899
we put it in two whole numbers that

00:26:31,370 --> 00:26:40,580
becomes a so it's an exact

00:26:32,899 --> 00:26:46,970
representation of an inch in meters then

00:26:40,580 --> 00:26:51,320
we can add operations we can add this

00:26:46,970 --> 00:26:57,950
together and for the case when the ratio

00:26:51,320 --> 00:27:02,500
is the same in this example for plus it

00:26:57,950 --> 00:27:06,460
becomes the reason because the length

00:27:02,500 --> 00:27:08,539
one meter plus one meter is still meter

00:27:06,460 --> 00:27:12,200
what happens if you have different

00:27:08,539 --> 00:27:15,830
underlying types what type should that

00:27:12,200 --> 00:27:25,519
render if we take one meter in int and

00:27:15,830 --> 00:27:28,100
add one meter in double no but we can

00:27:25,519 --> 00:27:32,269
actually what happens if you take a

00:27:28,100 --> 00:27:35,679
basic int or built in in

00:27:32,269 --> 00:27:35,679
a built-in double and add them together

00:27:36,879 --> 00:27:43,039
precisely also this the hint is promoted

00:27:40,639 --> 00:27:48,739
to double and how can we do that if the

00:27:43,039 --> 00:27:57,709
deckle type so this will be a meter of

00:27:48,739 --> 00:27:59,869
double yeah but it behaves the comment

00:27:57,709 --> 00:28:03,320
was this can be type and safe in a way

00:27:59,869 --> 00:28:07,509
yes on the other hand it behaves like we

00:28:03,320 --> 00:28:11,359
expect it to be or at least as I expect

00:28:07,509 --> 00:28:21,259
if I am add an int to double expect the

00:28:11,359 --> 00:28:25,849
double it will be promoted to whatever a

00:28:21,259 --> 00:28:32,109
named plus a floatin comes thanks to the

00:28:25,849 --> 00:28:35,769
deckle type if you have different ratios

00:28:32,109 --> 00:28:40,129
then it becomes a bit more complicated

00:28:35,769 --> 00:28:42,429
because we have to bring the values to

00:28:40,129 --> 00:28:47,869
some kind of common if you remember from

00:28:42,429 --> 00:28:53,419
school how you add fractions you have to

00:28:47,869 --> 00:28:56,209
bring them to a common denominator in

00:28:53,419 --> 00:28:59,149
order to add them together then that we

00:28:56,209 --> 00:29:07,099
do by taking the greatest common divisor

00:28:59,149 --> 00:29:13,249
between the two fractions and that's

00:29:07,099 --> 00:29:17,089
that formula and then we can use add to

00:29:13,249 --> 00:29:23,479
meters to 3 feet and then we get a very

00:29:17,089 --> 00:29:29,889
strange value because put feet or it's

00:29:23,479 --> 00:29:35,329
expressed as 1/3 hand

00:29:29,889 --> 00:29:40,960
381 through 1,050 meters the common

00:29:35,329 --> 00:29:45,430
ratio between those is one through one

00:29:40,960 --> 00:29:51,400
1250 so we if we try to

00:29:45,430 --> 00:30:03,960
with this we get this straight rotten so

00:29:51,400 --> 00:30:03,960
how we use but we can convert it back to

00:30:04,110 --> 00:30:15,010
to something we actually know how to

00:30:09,780 --> 00:30:17,200
comprehend and why I use this a bit

00:30:15,010 --> 00:30:22,390
strange values is because it becomes

00:30:17,200 --> 00:30:24,070
exact five inches plus eight centimeters

00:30:22,390 --> 00:30:28,930
is exactly two hundred and seven

00:30:24,070 --> 00:30:31,540
millimeters and that's very convenient

00:30:28,930 --> 00:30:36,220
if you try to do shakes with static

00:30:31,540 --> 00:30:40,210
assert we can add some syntactic sugar

00:30:36,220 --> 00:30:43,380
to this literal type and then we can

00:30:40,210 --> 00:30:43,380
write things like this

00:30:45,630 --> 00:30:57,970
next thing dimensions I showed addition

00:30:51,480 --> 00:31:00,910
subtraction is the same but we might

00:30:57,970 --> 00:31:03,250
want to multiply two lengths together to

00:31:00,910 --> 00:31:07,960
get an area multiplied with our length

00:31:03,250 --> 00:31:10,390
again if you get the volume and even

00:31:07,960 --> 00:31:14,580
take a length through a length to get a

00:31:10,390 --> 00:31:21,010
scalar or some kind of scale in between

00:31:14,580 --> 00:31:32,800
how do we do that where the dimension in

00:31:21,010 --> 00:31:36,700
to or length and now we can addition

00:31:32,800 --> 00:31:39,160
between these this new length is still

00:31:36,700 --> 00:31:41,620
the same the dimension has to be the

00:31:39,160 --> 00:31:45,810
same because it doesn't make any sense

00:31:41,620 --> 00:31:51,760
to add a length to volume but if we

00:31:45,810 --> 00:31:55,570
multiply two lengths we get dimension

00:31:51,760 --> 00:31:58,080
length through the second power that we

00:31:55,570 --> 00:31:58,080
can do by

00:31:58,160 --> 00:32:06,140
second part of this slide and in the

00:32:03,860 --> 00:32:08,990
same time the scales are multiplied

00:32:06,140 --> 00:32:16,850
together with the recha multiplying

00:32:08,990 --> 00:32:19,570
method that I discussed before so then

00:32:16,850 --> 00:32:24,680
we can do something like this

00:32:19,570 --> 00:32:30,430
add some fancy output operations and we

00:32:24,680 --> 00:32:36,770
can multiply three times four feet

00:32:30,430 --> 00:32:45,350
becomes twelve feet squared or one point

00:32:36,770 --> 00:32:48,220
blah blah blah meter squared all

00:32:45,350 --> 00:32:48,220
transparent

00:32:51,920 --> 00:32:58,280
next step physical quantities in the

00:32:56,480 --> 00:33:02,060
same way we can tell length times length

00:32:58,280 --> 00:33:06,620
to get an area we can take length

00:33:02,060 --> 00:33:09,980
through time to get a velocity or

00:33:06,620 --> 00:33:18,680
velocity through time to get extra hey

00:33:09,980 --> 00:33:22,010
Shay oh and so on how do we do that we

00:33:18,680 --> 00:33:25,430
expand or table or or length and now I

00:33:22,010 --> 00:33:41,750
call it unit instead with three numbers

00:33:25,430 --> 00:33:47,260
for three numbers for dimension and we

00:33:41,750 --> 00:33:47,260
can in the same way with it with length

00:33:47,560 --> 00:33:58,790
we can make this and now we can define

00:33:53,480 --> 00:34:02,990
our types length like this it's a unit

00:33:58,790 --> 00:34:13,580
or beam length to the first power mass

00:34:02,990 --> 00:34:16,159
and time to the zeroth power and area we

00:34:13,580 --> 00:34:24,919
take the second power and then time in

00:34:16,159 --> 00:34:33,970
for velocity we get negative power you

00:34:24,919 --> 00:34:33,970
can also add constants this trick

00:34:36,580 --> 00:34:42,320
anything there's a pamphlet eyes

00:34:39,590 --> 00:34:45,020
destruct somewhere before this and I'll

00:34:42,320 --> 00:34:48,740
be specialized it for instant or doubles

00:34:45,020 --> 00:34:54,760
and then we can pick out G in this part

00:34:48,740 --> 00:34:54,760
this is acceleration acceleration X

00:34:55,899 --> 00:35:00,550
acceleration towards ya

00:35:03,340 --> 00:35:13,250
and then we can use this like this to to

00:35:08,950 --> 00:35:17,390
calculate this velocity and then there

00:35:13,250 --> 00:35:20,300
are other units if you just think about

00:35:17,390 --> 00:35:23,240
physical units we have like current for

00:35:20,300 --> 00:35:29,990
electric electricity but temperature

00:35:23,240 --> 00:35:32,680
temperature is tricky because it's zero

00:35:29,990 --> 00:35:36,410
temperature is different for different

00:35:32,680 --> 00:35:41,180
temperature scales so you have an offset

00:35:36,410 --> 00:35:47,510
and now things are getting complicated

00:35:41,180 --> 00:35:52,330
in whatever you done yeah

00:35:47,510 --> 00:35:52,330
boost units how many of you boost units

00:35:53,740 --> 00:36:03,230
we can't calculate yes I don't know what

00:36:00,170 --> 00:36:09,280
power like this take a voltage times

00:36:03,230 --> 00:36:09,280
current very nice

00:36:17,500 --> 00:36:22,480
you can do the same thing we did before

00:36:19,870 --> 00:36:27,750
with length it's a little bit more

00:36:22,480 --> 00:36:33,190
writing but the most unit you can also

00:36:27,750 --> 00:36:39,310
make your own unit one example you might

00:36:33,190 --> 00:36:42,930
remember my price example often you have

00:36:39,310 --> 00:36:48,130
crisis expressed in price per volume

00:36:42,930 --> 00:36:50,530
price per length or price per weight so

00:36:48,130 --> 00:36:52,590
there for example you could make your

00:36:50,530 --> 00:36:52,590
own

00:36:58,080 --> 00:37:05,050
the difference with with most units is

00:37:02,530 --> 00:37:07,960
that it doesn't do all this automatic

00:37:05,050 --> 00:37:12,790
conversion so you have to cost not cost

00:37:07,960 --> 00:37:16,150
it but you have to put it into if you

00:37:12,790 --> 00:37:19,180
want to convert foot to length you have

00:37:16,150 --> 00:37:28,210
to explicitly write the quantity length

00:37:19,180 --> 00:37:33,610
of the number of feet some links to the

00:37:28,210 --> 00:37:36,430
code I've shown and as I like many

00:37:33,610 --> 00:37:38,830
programmers like to reinvent the wheel I

00:37:36,430 --> 00:37:49,380
did my own save type implementation as

00:37:38,830 --> 00:37:54,880
well is there an S type some conclusions

00:37:49,380 --> 00:37:59,620
nothing I think that by using these

00:37:54,880 --> 00:38:04,450
strong types you can without actually

00:37:59,620 --> 00:38:07,240
any performance performance hit make

00:38:04,450 --> 00:38:09,640
your programs more safe if you find

00:38:07,240 --> 00:38:12,550
every support is performance it you

00:38:09,640 --> 00:38:15,280
could all always use the safe types in

00:38:12,550 --> 00:38:18,760
debug builds and then define them away

00:38:15,280 --> 00:38:20,800
and use the basic types in release means

00:38:18,760 --> 00:38:27,940
that shouldn't be possible it should not

00:38:20,800 --> 00:38:31,470
be necessary so please try them some you

00:38:27,940 --> 00:38:44,050
might avoid some disasters

00:38:31,470 --> 00:38:53,740
thank you any questions please let the

00:38:44,050 --> 00:38:56,350
microphone yeah I was just curious if

00:38:53,740 --> 00:38:59,260
there are any issues like a bi issues

00:38:56,350 --> 00:39:00,370
between debug and release on Windows I

00:38:59,260 --> 00:39:04,060
know Linux does usually have those

00:39:00,370 --> 00:39:11,200
problems but I don't I'm not familiar

00:39:04,060 --> 00:39:14,950
with Windows but if you do as I you

00:39:11,200 --> 00:39:16,480
define that differently for debug builds

00:39:14,950 --> 00:39:22,120
and release builds them yeah there will

00:39:16,480 --> 00:39:24,100
be ibi issues sure because yeah oh the

00:39:22,120 --> 00:39:27,340
orb I think you get all the other

00:39:24,100 --> 00:39:32,590
relations between because you would if

00:39:27,340 --> 00:39:36,850
you mix release and the ball game can

00:39:32,590 --> 00:39:41,110
you address like overflow of an int that

00:39:36,850 --> 00:39:46,930
kind of thing yeah this doesn't handle

00:39:41,110 --> 00:39:51,250
that per se if you want that you would

00:39:46,930 --> 00:39:52,840
need some kind of safe in the

00:39:51,250 --> 00:39:58,180
implementation what's called what's

00:39:52,840 --> 00:39:59,740
called safe more for something tight I

00:39:58,180 --> 00:40:08,670
know there's another talk about that

00:39:59,740 --> 00:40:11,470
later this week so this only handles

00:40:08,670 --> 00:40:13,870
conversion errors like that doesn't

00:40:11,470 --> 00:40:19,200
handle overflow that's the same as you

00:40:13,870 --> 00:40:19,200
would have had by using the plain types

00:40:23,610 --> 00:40:33,880
okay thank you for coming

00:40:27,130 --> 00:40:33,880

YouTube URL: https://www.youtube.com/watch?v=1fwbG5TyI18


