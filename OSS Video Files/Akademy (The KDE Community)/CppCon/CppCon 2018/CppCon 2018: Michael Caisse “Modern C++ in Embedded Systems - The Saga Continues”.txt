Title: CppCon 2018: Michael Caisse “Modern C++ in Embedded Systems - The Saga Continues”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
For nearly 35 years I have been working with small processors and there has always been deep divides between practitioners of languages. When writing assembly we ridiculed those using C and when I spent years microcoding we scoffed at everyone. However, nearly all groups continue to wag their heads at the shameful C++ programmers attempting to twist their tools toward the small. 

Recent language developments have made C++ the obvious choice for many embedded projects; nevertheless, the toxic environment extends past reddit roasts into poor vendor support of tools and nearly obstructionist chip manufacturers. 

At C++Now I introduced a bare-metal project started in 2018 for a Ciere client as a case study. The goal was to extract useful lessons ranging from tooling acrobatics to idioms, language features, and libraries for producing high quality embedded results. Like an Athenian youth navigating Minos’ labyrinth we were thwarted at every bend and could merely report on the first half of the quest. In this session we will complete the saga with a discussion of the recent language features that enable goals of size, speed, and expressiveness, the libraries employed, and debugging techniques to stave off the minotaur. 

While the examples will be based on a concrete project, the extracted lessons-learned should be applicable to many embedded projects (bare-metal and small-OS). Attendees will walk away with motivations to use C++ in embedded projects, hints and tips to making tools work, and a sampling of language features and idioms that improve the quality of a final product. 
— 

Michael Caisse
Ciere Consulting

Michael Caisse has been crafting code in C++ for 28-years. He is a regular speaker at various conferences and is passionate about teaching and training. Michael is the owner of Ciere Consulting which provides software consulting and contracting services, C++ training, and Project Recovery for failing multidisciplinary engineering projects. When he isn't fighting with compilers or robots, he enjoys fencing with a sabre. :: ciere.com
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,380 --> 00:00:07,970
welcome and so you know the speakers

00:00:05,160 --> 00:00:10,320
have names for each of the sessions and

00:00:07,970 --> 00:00:11,580
John doesn't like the fact that we name

00:00:10,320 --> 00:00:12,870
them you know it's like like the one

00:00:11,580 --> 00:00:15,509
right after lunch is the one that you're

00:00:12,870 --> 00:00:18,180
falling asleep and well and we'll give

00:00:15,509 --> 00:00:20,699
you all the names but you just got some

00:00:18,180 --> 00:00:24,410
energy so hopefully we're not gonna all

00:00:20,699 --> 00:00:26,789
just pass out before before dinner here

00:00:24,410 --> 00:00:29,820
we're gonna be talking about embedded

00:00:26,789 --> 00:00:32,399
today my name is michael case and I work

00:00:29,820 --> 00:00:35,489
for Kira consulting we do a variety of

00:00:32,399 --> 00:00:36,960
different systems or programming for

00:00:35,489 --> 00:00:39,450
different systems ranging from very

00:00:36,960 --> 00:00:41,070
small devices you know 2k of RAM no

00:00:39,450 --> 00:00:42,480
operating system just a little

00:00:41,070 --> 00:00:44,610
microcontroller to do something on our

00:00:42,480 --> 00:00:47,550
board all the way up to very large cloud

00:00:44,610 --> 00:00:50,100
distributed systems that are processing

00:00:47,550 --> 00:00:52,289
you know tens of thousands of requests

00:00:50,100 --> 00:00:54,030
every minute and you know have many

00:00:52,289 --> 00:00:57,270
terabytes of data each day going in and

00:00:54,030 --> 00:00:59,879
out and so we have a large span of

00:00:57,270 --> 00:01:01,980
things that we do and it's a lot of

00:00:59,879 --> 00:01:03,449
different hats and it's enjoyable the

00:01:01,980 --> 00:01:06,960
last year we've been doing a lot more

00:01:03,449 --> 00:01:08,280
work in embedded and I'm gonna talk

00:01:06,960 --> 00:01:09,869
about that I started working with

00:01:08,280 --> 00:01:12,720
smaller what we I think today would call

00:01:09,869 --> 00:01:17,909
smaller processors back in the mid-80s

00:01:12,720 --> 00:01:19,229
and somewhere around 92 or so decided

00:01:17,909 --> 00:01:23,369
that it'd be really fun to try to get

00:01:19,229 --> 00:01:24,930
that on to a an hour toss and it was not

00:01:23,369 --> 00:01:30,119
as much fun as I thought it would be

00:01:24,930 --> 00:01:33,869
initially and things have moved on since

00:01:30,119 --> 00:01:37,590
then this was the alternate name the

00:01:33,869 --> 00:01:39,750
contemporary C++ because John and I

00:01:37,590 --> 00:01:40,890
really you know have debates constantly

00:01:39,750 --> 00:01:43,470
about whether we should call things

00:01:40,890 --> 00:01:44,729
modern or not and I think contemporaries

00:01:43,470 --> 00:01:47,280
really what we're talking about when

00:01:44,729 --> 00:01:49,259
we're talking about C++ today modern is

00:01:47,280 --> 00:01:52,860
a style and we're talking about really

00:01:49,259 --> 00:01:55,710
you know the the the compilers of today

00:01:52,860 --> 00:01:56,700
and the only problem is it would not

00:01:55,710 --> 00:01:57,960
actually go through the program

00:01:56,700 --> 00:01:59,880
committee with that title so we're gonna

00:01:57,960 --> 00:02:02,520
actually use that as our working title

00:01:59,880 --> 00:02:03,810
throughout then the discussion but now

00:02:02,520 --> 00:02:09,640
sirs between us we know about the real

00:02:03,810 --> 00:02:13,230
title is all right so then

00:02:09,640 --> 00:02:16,810
is a continuation of a Sud the saga that

00:02:13,230 --> 00:02:19,150
began a talk that I gave earlier at CPP

00:02:16,810 --> 00:02:21,430
now and me it is not a prerequisite

00:02:19,150 --> 00:02:24,190
it's just discussing some of the things

00:02:21,430 --> 00:02:26,680
and things that we found along the way

00:02:24,190 --> 00:02:28,330
now what's interesting to me is that CPP

00:02:26,680 --> 00:02:31,750
now is not the type of talk that really

00:02:28,330 --> 00:02:35,850
has embedded type stuff yet

00:02:31,750 --> 00:02:39,430
I'd like you to notice the view count is

00:02:35,850 --> 00:02:41,020
huge for really a conference that's not

00:02:39,430 --> 00:02:44,890
about embedded and I think that's

00:02:41,020 --> 00:02:48,160
indicative of people trying to get C++

00:02:44,890 --> 00:02:51,640
or more modern idioms on smaller systems

00:02:48,160 --> 00:02:53,860
today when we're talking about embedded

00:02:51,640 --> 00:02:57,310
inside of this particular discussion I'm

00:02:53,860 --> 00:02:59,620
talking about it in realm of putting C++

00:02:57,310 --> 00:03:01,720
on bare metal so there's no operating

00:02:59,620 --> 00:03:03,310
system and the amount of memory and

00:03:01,720 --> 00:03:05,760
whatnot we'll talk about kind of a

00:03:03,310 --> 00:03:09,610
system that we're gonna use is that the

00:03:05,760 --> 00:03:12,220
standard for today I appreciate I want

00:03:09,610 --> 00:03:15,730
to make a public shout out to Xavier

00:03:12,220 --> 00:03:16,780
Thomas who followed the instructions and

00:03:15,730 --> 00:03:18,459
marked where the important parts from

00:03:16,780 --> 00:03:20,950
the previous video I suspect some you'll

00:03:18,459 --> 00:03:24,160
do the same so somewhere around if we're

00:03:20,950 --> 00:03:25,690
use this as a guide I guess maybe about

00:03:24,160 --> 00:03:27,459
halfway through this talk because I was

00:03:25,690 --> 00:03:29,530
an item you talk good stuff will happen

00:03:27,459 --> 00:03:31,930
all right so let's talk about the

00:03:29,530 --> 00:03:33,310
project um so this is based upon a

00:03:31,930 --> 00:03:36,850
project that we're doing for a client

00:03:33,310 --> 00:03:39,250
this particular talk and they are they

00:03:36,850 --> 00:03:40,989
are taking a hydraulic system and

00:03:39,250 --> 00:03:44,110
converting it into something that is

00:03:40,989 --> 00:03:46,120
basically brushless motor can brand so

00:03:44,110 --> 00:03:48,160
instead of what you normally have in a

00:03:46,120 --> 00:03:49,930
hydraulic system you've got some big

00:03:48,160 --> 00:03:51,239
diesel motor that's spinning at a rate

00:03:49,930 --> 00:03:55,570
pretty much all the time the same rate

00:03:51,239 --> 00:03:57,459
it's got a manifold that the oil gets

00:03:55,570 --> 00:03:58,840
pumped through there's valves that kind

00:03:57,459 --> 00:04:00,850
of change the direction that things are

00:03:58,840 --> 00:04:02,380
going through the different whatever's

00:04:00,850 --> 00:04:04,660
that you want to control in this case

00:04:02,380 --> 00:04:06,310
we've got different hydraulic actuators

00:04:04,660 --> 00:04:09,100
and motors and whatnot and then there's

00:04:06,310 --> 00:04:11,760
a cooling system all of this creates

00:04:09,100 --> 00:04:13,510
some amount of a fish in efficiency and

00:04:11,760 --> 00:04:15,660
one of the things that they're working

00:04:13,510 --> 00:04:18,250
on is how to make this more efficient

00:04:15,660 --> 00:04:20,019
their system is something that looks

00:04:18,250 --> 00:04:21,220
like this where each of the hydraulic

00:04:20,019 --> 00:04:23,620
things that need to be controlled or

00:04:21,220 --> 00:04:25,570
hooked up to what they call a hydro pole

00:04:23,620 --> 00:04:27,100
and these are the brushless motor

00:04:25,570 --> 00:04:33,729
systems and we're working on the

00:04:27,100 --> 00:04:35,320
controllers for those the the that's

00:04:33,729 --> 00:04:36,550
enough actually probably about that or

00:04:35,320 --> 00:04:38,260
run out time here's an application

00:04:36,550 --> 00:04:42,810
standard application for something like

00:04:38,260 --> 00:04:45,880
this this is a tree shaker so these are

00:04:42,810 --> 00:04:48,100
farm equipment that are completely

00:04:45,880 --> 00:04:50,620
hydraulic driven so they have a diesel

00:04:48,100 --> 00:04:53,220
engine merely to run the hydraulics so

00:04:50,620 --> 00:04:55,419
the wheels turn through hydraulics the

00:04:53,220 --> 00:04:57,940
extensions and actuators move through

00:04:55,419 --> 00:04:59,830
hydraulics that grab a tree to shake it

00:04:57,940 --> 00:05:01,960
so the nuts fall off they've got little

00:04:59,830 --> 00:05:05,400
sweepers that spin around collecting

00:05:01,960 --> 00:05:08,410
things the whole thing is hydraulic and

00:05:05,400 --> 00:05:11,320
in this particular case in the Central

00:05:08,410 --> 00:05:13,810
Valley of California where enormous

00:05:11,320 --> 00:05:15,460
amount of produce and and nuts and

00:05:13,810 --> 00:05:16,930
whatnot for example almonds like eighty

00:05:15,460 --> 00:05:18,880
percent of all the almonds in the world

00:05:16,930 --> 00:05:21,970
are produced there there's also a lot

00:05:18,880 --> 00:05:23,289
now of diesel emissions and they're

00:05:21,970 --> 00:05:25,270
trying to grow how to clean the air up

00:05:23,289 --> 00:05:27,610
one way would be to use something like

00:05:25,270 --> 00:05:30,789
this so you can kind of see what the

00:05:27,610 --> 00:05:33,280
application is what we have from just a

00:05:30,789 --> 00:05:37,380
very high point of view very looking

00:05:33,280 --> 00:05:40,150
from very tall down we have this mpu

00:05:37,380 --> 00:05:43,229
that is going to control a variety of

00:05:40,150 --> 00:05:45,160
different things it's looking at a

00:05:43,229 --> 00:05:47,200
couple different analog to digital

00:05:45,160 --> 00:05:48,580
converters with various speeds and

00:05:47,200 --> 00:05:51,520
various things connected to them

00:05:48,580 --> 00:05:54,430
near-field communication chip that's on

00:05:51,520 --> 00:05:56,410
it a variety of different memories lots

00:05:54,430 --> 00:05:58,389
of different pressure sensors there's an

00:05:56,410 --> 00:06:02,470
FPGA that we're responsible for doing

00:05:58,389 --> 00:06:03,760
some work with an encoder and then

00:06:02,470 --> 00:06:08,050
there's some different communication

00:06:03,760 --> 00:06:10,870
ways to talk to it can bus and EtherCAT

00:06:08,050 --> 00:06:12,130
and different different ways to talk to

00:06:10,870 --> 00:06:13,570
this thing all of it needs to be

00:06:12,130 --> 00:06:15,220
controlled by the MP you and MP use

00:06:13,570 --> 00:06:18,400
really just think of it as like an MCU

00:06:15,220 --> 00:06:22,240
but it doesn't have memory onboard this

00:06:18,400 --> 00:06:23,889
is a diagram to give you an idea of what

00:06:22,240 --> 00:06:27,099
the processor is that we're dealing with

00:06:23,889 --> 00:06:29,169
it is a renesis processor the the

00:06:27,099 --> 00:06:31,000
processor itself or the chip itself

00:06:29,169 --> 00:06:35,650
actually has two processors in it it has

00:06:31,000 --> 00:06:36,689
an r4 which is arm has three classes

00:06:35,650 --> 00:06:39,959
that's where the arm comes from

00:06:36,689 --> 00:06:42,330
a class processors or application base

00:06:39,959 --> 00:06:43,639
are based are real-time based means they

00:06:42,330 --> 00:06:48,659
have a different interrupt controller

00:06:43,639 --> 00:06:54,329
that does not do vectorized additional

00:06:48,659 --> 00:06:56,939
jumps the M and then M for her mobile

00:06:54,329 --> 00:07:00,089
low-power this particular processor or

00:06:56,939 --> 00:07:02,429
chip has actually an hour class and an M

00:07:00,089 --> 00:07:05,239
class in it and that actually ends up

00:07:02,429 --> 00:07:09,079
becoming a small problem for us because

00:07:05,239 --> 00:07:11,639
the vendor would like to use the M Class

00:07:09,079 --> 00:07:13,019
processor without you touching it to

00:07:11,639 --> 00:07:16,259
handle all kinds of communication things

00:07:13,019 --> 00:07:19,139
like the EtherCAT or or can bus and

00:07:16,259 --> 00:07:22,259
whatnot encoder and then you write your

00:07:19,139 --> 00:07:24,389
application on the r class the problem

00:07:22,259 --> 00:07:25,919
is is that somehow they're both in there

00:07:24,389 --> 00:07:27,689
and you need to work with them and the

00:07:25,919 --> 00:07:32,429
tool sets make it very complicated to do

00:07:27,689 --> 00:07:34,739
that this is kind of looking inside of

00:07:32,429 --> 00:07:36,749
the processor the important part for us

00:07:34,739 --> 00:07:41,309
to look at right now is that we've got

00:07:36,749 --> 00:07:43,589
this cortex r4 and it has these things

00:07:41,309 --> 00:07:44,999
called TCM this is just basically what's

00:07:43,589 --> 00:07:47,339
called tightly coupled memory it's

00:07:44,999 --> 00:07:49,259
memory that's directly attached to the

00:07:47,339 --> 00:07:50,550
processor you know if you're dealing

00:07:49,259 --> 00:07:52,139
with things that are larger you might

00:07:50,550 --> 00:07:53,909
think about them is like cache in

00:07:52,139 --> 00:07:56,669
essence but as you can see doesn't

00:07:53,909 --> 00:07:57,809
really go off somewhere else the tightly

00:07:56,669 --> 00:07:59,789
coupled memory is what's gonna get

00:07:57,809 --> 00:08:05,459
loaded up program's gonna run out of it

00:07:59,789 --> 00:08:07,169
and what not be the m3 processors way up

00:08:05,459 --> 00:08:08,789
here and it has what you would normally

00:08:07,169 --> 00:08:10,139
expect a bunch of bus architecture that

00:08:08,789 --> 00:08:15,239
needs to go through in order to do any

00:08:10,139 --> 00:08:16,889
work this application in addition to a

00:08:15,239 --> 00:08:19,019
variety of communication bits and pieces

00:08:16,889 --> 00:08:23,339
that has to do and management of you

00:08:19,019 --> 00:08:25,379
know whatnot it has a spinning motor and

00:08:23,339 --> 00:08:27,709
as this motor is spinning around it has

00:08:25,379 --> 00:08:30,360
to do some acquisition it has to do some

00:08:27,709 --> 00:08:33,209
processing and then it has to do some

00:08:30,360 --> 00:08:35,969
adjustment to something else right and

00:08:33,209 --> 00:08:37,800
as the motor spins it can't miss the

00:08:35,969 --> 00:08:40,199
time so it's a hard real-time system

00:08:37,800 --> 00:08:43,079
because if it misses the time everything

00:08:40,199 --> 00:08:45,089
just kind of falls apart right so this

00:08:43,079 --> 00:08:47,699
is what we're working in there is no

00:08:45,089 --> 00:08:48,990
operating system on this and the

00:08:47,699 --> 00:08:50,610
question of course is like why in the

00:08:48,990 --> 00:08:52,590
world would you want to use C++ on

00:08:50,610 --> 00:08:54,360
like what's the point and you know the

00:08:52,590 --> 00:08:57,030
first point on why you'd want to use C++

00:08:54,360 --> 00:08:59,580
is because you submit a talk about using

00:08:57,030 --> 00:09:01,950
C++ on an embedded system and as a

00:08:59,580 --> 00:09:05,280
result you now need a project with C++

00:09:01,950 --> 00:09:06,360
on it but the reality is C++ actually

00:09:05,280 --> 00:09:09,030
provides a variety of different

00:09:06,360 --> 00:09:11,790
abstractions that are useful those

00:09:09,030 --> 00:09:15,090
abstractions allow us to write better

00:09:11,790 --> 00:09:17,550
code faster code that we actually can

00:09:15,090 --> 00:09:19,290
feel confident about because we're going

00:09:17,550 --> 00:09:22,320
to assemble it in such a way that if it

00:09:19,290 --> 00:09:23,820
compiles our confidence goes up so it's

00:09:22,320 --> 00:09:25,140
good correct by assembly and we're gonna

00:09:23,820 --> 00:09:29,250
use the type system to help us out

00:09:25,140 --> 00:09:31,620
that's really key to why at least

00:09:29,250 --> 00:09:33,630
personally why I like to use C++ on

00:09:31,620 --> 00:09:35,220
projects that are very small processors

00:09:33,630 --> 00:09:39,590
it gives me a certain amount of

00:09:35,220 --> 00:09:39,590
confidence that the system is correct

00:09:40,190 --> 00:09:47,580
the the saga continuing the original

00:09:45,360 --> 00:09:49,770
saga that episode contained all kinds of

00:09:47,580 --> 00:09:52,050
interesting things like vendor tools

00:09:49,770 --> 00:09:53,520
from the vendor itself pointing to

00:09:52,050 --> 00:09:56,310
domains that were no longer actually

00:09:53,520 --> 00:09:59,070
owned by the vendor fun and games with

00:09:56,310 --> 00:10:00,690
tech support which included phrases like

00:09:59,070 --> 00:10:03,210
why in the world are you using C++

00:10:00,690 --> 00:10:04,830
please don't do that anymore and you

00:10:03,210 --> 00:10:06,930
know the good bad and ugly that comes

00:10:04,830 --> 00:10:09,690
from Twitter and reddit it also included

00:10:06,930 --> 00:10:11,970
a whole lot of information about Michael

00:10:09,690 --> 00:10:13,560
basically giving up at some point and

00:10:11,970 --> 00:10:15,630
realizing that the problem was going to

00:10:13,560 --> 00:10:18,180
be complicated and hard and giving it to

00:10:15,630 --> 00:10:20,400
somebody was like very senior named

00:10:18,180 --> 00:10:22,350
Sharon who had 30 years of experience

00:10:20,400 --> 00:10:25,020
and Sharon happens to be in the audience

00:10:22,350 --> 00:10:27,060
today so all that stuff I said about

00:10:25,020 --> 00:10:28,800
Sharon previously and just like sloth

00:10:27,060 --> 00:10:30,660
and work off to her we won't talk about

00:10:28,800 --> 00:10:31,860
today okay because then she'll know

00:10:30,660 --> 00:10:36,090
about it because I'm sure she hasn't

00:10:31,860 --> 00:10:39,810
watched that video previously even had

00:10:36,090 --> 00:10:42,120
clickbait oh it was wonderful but what I

00:10:39,810 --> 00:10:45,750
want us to think about one thing that we

00:10:42,120 --> 00:10:48,510
took away from it was ID ease that we

00:10:45,750 --> 00:10:51,540
get from vendors who are are selling

00:10:48,510 --> 00:10:54,030
chips basically they're there for one

00:10:51,540 --> 00:10:56,730
purpose it's time to hello world how

00:10:54,030 --> 00:10:59,610
fast can I show you something that works

00:10:56,730 --> 00:11:01,560
on a dev board because then I can sell

00:10:59,610 --> 00:11:04,370
the chip to you it appears to work well

00:11:01,560 --> 00:11:07,140
and it appears to work he's easily

00:11:04,370 --> 00:11:09,300
unfortunately time - hello world doesn't

00:11:07,140 --> 00:11:11,040
help us with a lot of things it has some

00:11:09,300 --> 00:11:13,350
good things to it which is we can

00:11:11,040 --> 00:11:15,420
actually get a dev board up and running

00:11:13,350 --> 00:11:18,060
and analyze whether or not the chip does

00:11:15,420 --> 00:11:20,670
what we want it to do um it has usually

00:11:18,060 --> 00:11:21,620
built-in target type information in it

00:11:20,670 --> 00:11:24,660
or excuse me

00:11:21,620 --> 00:11:27,180
facilities in it so we can easily hook

00:11:24,660 --> 00:11:28,589
up to the to the processor and upload

00:11:27,180 --> 00:11:31,410
whatever it is

00:11:28,589 --> 00:11:33,600
despite however complicated it needs to

00:11:31,410 --> 00:11:34,620
be it has you know the linker scripts

00:11:33,600 --> 00:11:38,220
come with it everything just kind of

00:11:34,620 --> 00:11:39,960
works for that first level and debugging

00:11:38,220 --> 00:11:42,390
is typically built-in without a hassle

00:11:39,960 --> 00:11:45,450
so that's kind of nice the bad side of

00:11:42,390 --> 00:11:47,640
it is that it's really geared toward

00:11:45,450 --> 00:11:50,670
single user development and if you have

00:11:47,640 --> 00:11:53,220
a team of people working on a project

00:11:50,670 --> 00:11:55,470
which I think most often we have a team

00:11:53,220 --> 00:11:57,330
of people working on projects then it's

00:11:55,470 --> 00:12:02,040
very complicated to use what we would

00:11:57,330 --> 00:12:03,779
consider typical best practices best

00:12:02,040 --> 00:12:05,520
practices kind of start falling apart

00:12:03,779 --> 00:12:07,140
when you have an IDE that really

00:12:05,520 --> 00:12:08,910
restricts the amount of things that you

00:12:07,140 --> 00:12:11,820
can do and expects all the files of you

00:12:08,910 --> 00:12:15,779
in a certain spot on your on your your

00:12:11,820 --> 00:12:17,640
personal machine right and so on that

00:12:15,779 --> 00:12:18,690
that doesn't really work well it's hard

00:12:17,640 --> 00:12:20,610
and agree with the team hard to

00:12:18,690 --> 00:12:23,880
integrate then I'm obviously also with

00:12:20,610 --> 00:12:26,670
some some type of a CI and it also hides

00:12:23,880 --> 00:12:28,820
a fair amount of magic and the magic

00:12:26,670 --> 00:12:31,770
part is actually very interesting

00:12:28,820 --> 00:12:34,260
because typically embedded developers

00:12:31,770 --> 00:12:37,350
don't like magic hidden which is why

00:12:34,260 --> 00:12:39,570
they don't like C++ but when their tools

00:12:37,350 --> 00:12:43,350
doing it it seems like it's okay and

00:12:39,570 --> 00:12:46,529
what I mean by magic as an example is we

00:12:43,350 --> 00:12:49,920
have the R for processor but we also had

00:12:46,529 --> 00:12:52,550
that cortex m3 processor and who knows

00:12:49,920 --> 00:12:56,279
how the code is generated for the m3

00:12:52,550 --> 00:12:58,230
it's like black magic you just kind of

00:12:56,279 --> 00:13:00,209
like click this button open this thing

00:12:58,230 --> 00:13:01,529
turn that panel on turn these little

00:13:00,209 --> 00:13:02,910
drivers on the next thing you know

00:13:01,529 --> 00:13:04,050
somehow it has code on it and it's

00:13:02,910 --> 00:13:05,610
running I don't know where it came from

00:13:04,050 --> 00:13:06,810
or went where it went

00:13:05,610 --> 00:13:08,730
unfortunately of course those are the

00:13:06,810 --> 00:13:12,870
things you have to tease out if you want

00:13:08,730 --> 00:13:15,390
to move to a system that has the whole

00:13:12,870 --> 00:13:18,390
CI and CD and the different parts that

00:13:15,390 --> 00:13:22,110
you want for well controlled software

00:13:18,390 --> 00:13:25,610
now I received actually a fair number of

00:13:22,110 --> 00:13:27,900
emails from people after my first talk

00:13:25,610 --> 00:13:29,580
that I received one just a couple of

00:13:27,900 --> 00:13:31,770
weeks ago followed up with a phone call

00:13:29,580 --> 00:13:35,490
and the individual said you know my team

00:13:31,770 --> 00:13:38,340
is kind of split at the moment half of

00:13:35,490 --> 00:13:40,200
the team says yeah see how hard it is

00:13:38,340 --> 00:13:41,790
why in the world should we do it and the

00:13:40,200 --> 00:13:44,340
other half the team's saying hey

00:13:41,790 --> 00:13:47,070
somebody else did it so lots of people

00:13:44,340 --> 00:13:50,010
do this and work through it and I'm

00:13:47,070 --> 00:13:51,930
hoping that you all will come away with

00:13:50,010 --> 00:13:55,740
thinking that it's actually worth the

00:13:51,930 --> 00:13:58,410
extra work my experience is that yes it

00:13:55,740 --> 00:14:02,460
is extra work to get going time to hello

00:13:58,410 --> 00:14:04,470
world stinks it's really horrible but

00:14:02,460 --> 00:14:06,540
once you get past that your ability to

00:14:04,470 --> 00:14:11,070
actually iterate and produce quality

00:14:06,540 --> 00:14:14,790
product after that is really high all

00:14:11,070 --> 00:14:17,250
right so we wanted basic tools we wanted

00:14:14,790 --> 00:14:20,310
actually the canoe tool set just from

00:14:17,250 --> 00:14:21,780
armes website we didn't want any special

00:14:20,310 --> 00:14:24,830
weird thing from the vendor the chip

00:14:21,780 --> 00:14:26,880
vendor we see make wasn't a necessary

00:14:24,830 --> 00:14:28,350
thing but it would have been interesting

00:14:26,880 --> 00:14:30,150
to see if we get to see make working we

00:14:28,350 --> 00:14:33,080
got see make working we want a normal

00:14:30,150 --> 00:14:35,820
static analysis we wanted all the normal

00:14:33,080 --> 00:14:37,170
analyzer tools we wanted to use a

00:14:35,820 --> 00:14:39,810
continuous integration system in a

00:14:37,170 --> 00:14:42,150
continuous deployment system so what did

00:14:39,810 --> 00:14:44,850
we do to get this all to work well it

00:14:42,150 --> 00:14:48,630
ends up that we have a heterogeneous

00:14:44,850 --> 00:14:50,250
system at work I guess that's my fault

00:14:48,630 --> 00:14:51,510
because I let anybody buy whatever

00:14:50,250 --> 00:14:54,150
computer they want to do their

00:14:51,510 --> 00:14:57,180
development and as an example Sharon has

00:14:54,150 --> 00:14:59,370
a Windows machine I have a Mac the build

00:14:57,180 --> 00:15:00,810
server is Linux and then we've got some

00:14:59,370 --> 00:15:02,640
Linux machines running around the office

00:15:00,810 --> 00:15:04,620
we've got a bunch of build machines that

00:15:02,640 --> 00:15:06,750
are in the cloud it's so like nothing is

00:15:04,620 --> 00:15:08,100
the same and it would be really nice to

00:15:06,750 --> 00:15:09,660
have the same tools running on

00:15:08,100 --> 00:15:11,990
everything and supposedly this is like

00:15:09,660 --> 00:15:14,430
this is what docker was built for now

00:15:11,990 --> 00:15:16,140
you can watch lots of talks about how to

00:15:14,430 --> 00:15:18,480
get darker running and whatnot but I

00:15:16,140 --> 00:15:20,160
want to mention this as a tool that is

00:15:18,480 --> 00:15:22,980
super useful if you're doing a lot of

00:15:20,160 --> 00:15:25,560
embedded work or work where you have a

00:15:22,980 --> 00:15:27,140
toolset that is important for your team

00:15:25,560 --> 00:15:29,940
to continue using over and over again

00:15:27,140 --> 00:15:31,329
one way that people use docker

00:15:29,940 --> 00:15:34,119
unfortunately

00:15:31,329 --> 00:15:36,160
is to have all the data and files copied

00:15:34,119 --> 00:15:37,509
into the image and then it does some

00:15:36,160 --> 00:15:41,319
work and then it copies the good stuff

00:15:37,509 --> 00:15:43,989
back out don't do that just fine dot

00:15:41,319 --> 00:15:45,759
cross go online find dot cross it's in

00:15:43,989 --> 00:15:47,829
github it's kind of the base to start

00:15:45,759 --> 00:15:50,170
now dot cross for us would not work

00:15:47,829 --> 00:15:52,269
because we have bare metal we don't

00:15:50,170 --> 00:15:54,220
we're not interested in an OS for the

00:15:52,269 --> 00:15:55,779
target but it can be a base layer and

00:15:54,220 --> 00:15:56,889
the nice thing about dot crosses it

00:15:55,779 --> 00:15:58,600
allows you to use whatever your normal

00:15:56,889 --> 00:16:02,079
tools are on your system you're

00:15:58,600 --> 00:16:03,639
modifying files inside of inside of your

00:16:02,079 --> 00:16:05,860
filesystem using git you're using

00:16:03,639 --> 00:16:07,660
whatever happens to be for your favorite

00:16:05,860 --> 00:16:11,199
editor and then when you invoke the

00:16:07,660 --> 00:16:13,540
command what you end up getting is like

00:16:11,199 --> 00:16:15,040
there's an additional launch and it's

00:16:13,540 --> 00:16:16,389
using the files that are on your

00:16:15,040 --> 00:16:17,879
filesystem it's leaving them there

00:16:16,389 --> 00:16:21,850
around your filesystem

00:16:17,879 --> 00:16:25,809
so that's kind of nice and it creates in

00:16:21,850 --> 00:16:27,879
a repeatable environment for us how many

00:16:25,809 --> 00:16:30,009
of you how many of you have ever had

00:16:27,879 --> 00:16:33,610
this problem where you have got cross

00:16:30,009 --> 00:16:36,179
compilers on multiple machines and they

00:16:33,610 --> 00:16:38,799
don't seem to produce the same result

00:16:36,179 --> 00:16:40,629
ok now the rest of you that are lying

00:16:38,799 --> 00:16:42,999
you can raise your hand if you want but

00:16:40,629 --> 00:16:46,019
I guess you don't have to know it's it

00:16:42,999 --> 00:16:48,399
sometimes is fairly hard to keep

00:16:46,019 --> 00:16:50,619
specially heterogeneous environments in

00:16:48,399 --> 00:16:54,369
sync with the tools and we're finding

00:16:50,619 --> 00:16:57,759
that this is working well for us so in

00:16:54,369 --> 00:17:01,480
theory dot cross you can find it on

00:16:57,759 --> 00:17:05,519
github this is the part of where we do a

00:17:01,480 --> 00:17:10,539
demo and we hope it works right so

00:17:05,519 --> 00:17:16,079
against my better judgement in theory

00:17:10,539 --> 00:17:18,490
what happens is okay so we don't have

00:17:16,079 --> 00:17:21,100
this is a project that's set up with

00:17:18,490 --> 00:17:28,720
this thing there is no build director or

00:17:21,100 --> 00:17:32,200
anything so let's go ahead and that okay

00:17:28,720 --> 00:17:35,080
so here is how you how you would run

00:17:32,200 --> 00:17:37,480
this with this dot cross environment it

00:17:35,080 --> 00:17:38,590
creates kind of a launcher and then you

00:17:37,480 --> 00:17:40,690
just give the commands that you would

00:17:38,590 --> 00:17:42,880
normally give at at that point on and it

00:17:40,690 --> 00:17:44,710
supports all kinds of different UNIX e

00:17:42,880 --> 00:17:45,140
commands and then installing new ones

00:17:44,710 --> 00:17:48,020
it's pretty

00:17:45,140 --> 00:17:51,410
pretty straightforward so we're gonna go

00:17:48,020 --> 00:17:56,870
ahead and just like run see make and bam

00:17:51,410 --> 00:17:58,760
it creates some stuff and so now we

00:17:56,870 --> 00:18:06,290
could see like we have our normal build

00:17:58,760 --> 00:18:10,000
directory with SEMA crud in it and now

00:18:06,290 --> 00:18:10,000
if I wanted to make it I could just say

00:18:13,600 --> 00:18:20,450
and now it's building using the tools

00:18:18,620 --> 00:18:22,850
that are inside the docker image and

00:18:20,450 --> 00:18:24,830
leaving the files local and so that's

00:18:22,850 --> 00:18:26,660
kind of a it's a nice setup we have

00:18:24,830 --> 00:18:31,130
clients who do a variety of different

00:18:26,660 --> 00:18:33,530
things using docker and the ones that

00:18:31,130 --> 00:18:35,450
don't use dot cross it's kind of like

00:18:33,530 --> 00:18:36,770
the stuff still exists inside of the

00:18:35,450 --> 00:18:38,270
docker image and you kind of have to

00:18:36,770 --> 00:18:40,070
pull it out sometimes as you want and

00:18:38,270 --> 00:18:41,960
there's like crazy other ways to do it

00:18:40,070 --> 00:18:55,520
people gone through some good work to

00:18:41,960 --> 00:18:59,150
get to get this working all right so

00:18:55,520 --> 00:19:01,070
this is oh this is where the cameraman

00:18:59,150 --> 00:19:02,840
hates me it don't really mean to be

00:19:01,070 --> 00:19:11,780
running offstage because I just forgot

00:19:02,840 --> 00:19:20,630
about so this type of setup is really

00:19:11,780 --> 00:19:24,710
convenient in fact I won't be loud this

00:19:20,630 --> 00:19:28,090
so this is a this is a little FPGA the

00:19:24,710 --> 00:19:31,810
specs are up behind me and this is a

00:19:28,090 --> 00:19:37,910
board called a tiny fpga loop does ease

00:19:31,810 --> 00:19:39,350
it's an open hardware project and you

00:19:37,910 --> 00:19:41,030
know it's not very interesting you may

00:19:39,350 --> 00:19:44,720
or may not be able to see the little LED

00:19:41,030 --> 00:19:46,310
blinking but what's happening is I've

00:19:44,720 --> 00:19:51,860
set up one of these dark across things

00:19:46,310 --> 00:19:58,960
that takes and it's Clifford Wolf's risk

00:19:51,860 --> 00:20:01,809
five core is being built and there's a

00:19:58,960 --> 00:20:05,590
a program that's also being compiled and

00:20:01,809 --> 00:20:07,390
loaded onto here and and the whole

00:20:05,590 --> 00:20:10,419
thing's just kind of running right so

00:20:07,390 --> 00:20:14,860
this is basically like a softcore write

00:20:10,419 --> 00:20:16,630
on an FPGA and and all that's just kind

00:20:14,860 --> 00:20:19,000
of set up with whatever and this is all

00:20:16,630 --> 00:20:28,299
using all open source tools ice storm is

00:20:19,000 --> 00:20:31,690
an open source FPGA setup - all right so

00:20:28,299 --> 00:20:33,250
we've got our standard tools and once

00:20:31,690 --> 00:20:34,330
you have your tools you have to you have

00:20:33,250 --> 00:20:36,580
to solve a whole bunch of different

00:20:34,330 --> 00:20:38,799
problems right you have to figure out

00:20:36,580 --> 00:20:41,559
what happens when you reset the chip how

00:20:38,799 --> 00:20:44,320
do you get that working what are the

00:20:41,559 --> 00:20:46,890
memory layouts what are the different

00:20:44,320 --> 00:20:50,409
startup needs of any particular device

00:20:46,890 --> 00:20:52,120
peripheral needs and then you know there

00:20:50,409 --> 00:20:53,730
are different languages that are

00:20:52,120 --> 00:20:57,029
appropriate for these different things

00:20:53,730 --> 00:21:01,510
when you're first starting something up

00:20:57,029 --> 00:21:04,720
you you probably have written your code

00:21:01,510 --> 00:21:07,990
in assembly right so you write your boot

00:21:04,720 --> 00:21:09,789
code and assembly some amount of it

00:21:07,990 --> 00:21:11,740
until you get tired of that and you want

00:21:09,789 --> 00:21:13,870
to slightly higher abstraction so you

00:21:11,740 --> 00:21:16,659
write just enough in assembly and then

00:21:13,870 --> 00:21:19,450
you switch over into C and you write the

00:21:16,659 --> 00:21:22,090
rest of your bootloader in C and a lot

00:21:19,450 --> 00:21:23,980
of people kind of stop there their

00:21:22,090 --> 00:21:27,279
application is also then written in C

00:21:23,980 --> 00:21:29,260
and this particular device how it boots

00:21:27,279 --> 00:21:31,600
up the bootloader is loaded inside of

00:21:29,260 --> 00:21:34,240
just tightly coupled memory the second

00:21:31,600 --> 00:21:36,909
one b1 which will later be used as

00:21:34,240 --> 00:21:39,460
actually the stack for the application

00:21:36,909 --> 00:21:41,140
it's loaded into there and then the

00:21:39,460 --> 00:21:43,120
bootloader runs and it loads inside the

00:21:41,140 --> 00:21:46,360
application until into the a tightly

00:21:43,120 --> 00:21:48,130
coupled memory the the thing that I want

00:21:46,360 --> 00:21:49,809
to be able to do is yes I have to write

00:21:48,130 --> 00:21:51,909
assembly to get the silly thing working

00:21:49,809 --> 00:21:53,169
and I have to write some amount of C I

00:21:51,909 --> 00:21:54,549
guess I could write it all in sembly but

00:21:53,169 --> 00:21:55,149
I prefer to write it and C for the rest

00:21:54,549 --> 00:21:57,130
of the bootloader

00:21:55,149 --> 00:22:00,190
but boy I sure want my application

00:21:57,130 --> 00:22:04,899
running in C++ I want to move one more

00:22:00,190 --> 00:22:07,809
layer up Jason Turner was on a podcast a

00:22:04,899 --> 00:22:11,590
couple months ago for embedded FM and

00:22:07,809 --> 00:22:14,400
you know one of the one of the

00:22:11,590 --> 00:22:18,940
blog posts on there is this which is

00:22:14,400 --> 00:22:22,150
switching from assembly to see so you

00:22:18,940 --> 00:22:23,770
know that whole idea of wanting to

00:22:22,150 --> 00:22:25,840
actually create abstractions and move

00:22:23,770 --> 00:22:27,970
further up it exists everywhere it's

00:22:25,840 --> 00:22:30,429
just how far people want to go it's

00:22:27,970 --> 00:22:32,860
actually a pretty good podcast if you'd

00:22:30,429 --> 00:22:34,779
like to listen to it oh it was

00:22:32,860 --> 00:22:37,659
insightful and remind it reminded me a

00:22:34,779 --> 00:22:39,779
lot of the struggle that people have and

00:22:37,659 --> 00:22:46,390
just understand why C++ might be useful

00:22:39,779 --> 00:22:48,340
on a small device so I think people want

00:22:46,390 --> 00:22:50,200
to go further and they want abstractions

00:22:48,340 --> 00:22:54,039
that are higher it's just that I want to

00:22:50,200 --> 00:22:56,529
go further than stopping at C so let's

00:22:54,039 --> 00:22:59,919
talk about some C++ things things that

00:22:56,529 --> 00:23:02,649
are important so zero zero costs

00:22:59,919 --> 00:23:04,480
abstractions are important Co cost

00:23:02,649 --> 00:23:06,580
abstractions generally are also scary

00:23:04,480 --> 00:23:09,730
for some people but but they're

00:23:06,580 --> 00:23:13,779
important host of bugging is important

00:23:09,730 --> 00:23:16,779
to me correctness and that's I'm going

00:23:13,779 --> 00:23:18,820
to be through types for us and again

00:23:16,779 --> 00:23:20,230
this idea of abstractions but slightly

00:23:18,820 --> 00:23:23,440
slightly different that we're gonna look

00:23:20,230 --> 00:23:27,220
at so first I want to talk about just

00:23:23,440 --> 00:23:31,000
the idea of wanting your code to become

00:23:27,220 --> 00:23:33,899
more declarative in nature you want to

00:23:31,000 --> 00:23:37,020
get to this place where you've begun to

00:23:33,899 --> 00:23:40,210
move the things that are low-level

00:23:37,020 --> 00:23:42,039
belong down in the guts they're the

00:23:40,210 --> 00:23:44,110
stuff that's just you know Hardware

00:23:42,039 --> 00:23:46,419
Pacific specific things you want to move

00:23:44,110 --> 00:23:50,289
that down as far as possible and you

00:23:46,419 --> 00:23:52,570
want to move the value up now when I say

00:23:50,289 --> 00:23:54,850
that it sounds obvious but when you look

00:23:52,570 --> 00:23:57,159
at standard embedded C code that's not

00:23:54,850 --> 00:24:01,000
what happens it's like hey I just need

00:23:57,159 --> 00:24:02,860
to twiddle a bit just this one right

00:24:01,000 --> 00:24:05,289
here and it doesn't really matter where

00:24:02,860 --> 00:24:07,809
you are in your code stack twiddling a

00:24:05,289 --> 00:24:09,730
bit is just like orange something over

00:24:07,809 --> 00:24:11,380
here or anding something inside some

00:24:09,730 --> 00:24:13,690
memory register and you just do it and

00:24:11,380 --> 00:24:16,600
the next thing you know you have like no

00:24:13,690 --> 00:24:20,799
no abstractions you have no layers at

00:24:16,600 --> 00:24:24,760
all why because it's expensive to create

00:24:20,799 --> 00:24:26,380
layers and see that's why

00:24:24,760 --> 00:24:28,210
it's not that people don't want to it

00:24:26,380 --> 00:24:30,760
just has a cost associated with it and

00:24:28,210 --> 00:24:33,370
so one of the nice things about C++ is

00:24:30,760 --> 00:24:35,880
we remove the cost of the abstractions

00:24:33,370 --> 00:24:40,660
we end up with something that's low cost

00:24:35,880 --> 00:24:42,700
this is a talk you should watch it talks

00:24:40,660 --> 00:24:47,350
a lot about how to actually create

00:24:42,700 --> 00:24:48,370
better abstractions so watch this this

00:24:47,350 --> 00:24:50,740
is a great talk

00:24:48,370 --> 00:24:52,150
it works for embedded just as well as it

00:24:50,740 --> 00:24:55,240
works for all kinds of other things

00:24:52,150 --> 00:25:01,299
talking about declarative do you like to

00:24:55,240 --> 00:25:03,280
talk pin oh my goodness

00:25:01,299 --> 00:25:06,100
bin liked to talk so much he's talking

00:25:03,280 --> 00:25:13,419
about it again on Friday here so you

00:25:06,100 --> 00:25:14,530
have a chance to see it good job all

00:25:13,419 --> 00:25:19,540
right so what is the zero cost

00:25:14,530 --> 00:25:22,179
abstraction all right we've got this

00:25:19,540 --> 00:25:27,790
piece of code the main is going to take

00:25:22,179 --> 00:25:29,559
in really a list of things from the user

00:25:27,790 --> 00:25:34,000
the users gonna be able to put bunch of

00:25:29,559 --> 00:25:36,429
numbers on the on the input and it's

00:25:34,000 --> 00:25:38,530
just gonna count up how many number

00:25:36,429 --> 00:25:40,299
eights are on the input okay that's all

00:25:38,530 --> 00:25:42,100
it's going to do so we're gonna call

00:25:40,299 --> 00:25:44,770
this thing called count value we're

00:25:42,100 --> 00:25:45,880
gonna pass in the range and the thing

00:25:44,770 --> 00:25:48,669
that we're searching for we're searching

00:25:45,880 --> 00:25:50,700
for the number eight the code looks like

00:25:48,669 --> 00:25:53,950
this it's a very simple version of it

00:25:50,700 --> 00:25:56,410
we've got this for loop while while

00:25:53,950 --> 00:25:59,110
length what's going through looking at a

00:25:56,410 --> 00:26:01,299
to I of the value it's comparing it to

00:25:59,110 --> 00:26:03,700
what was passed in it's incrementing it

00:26:01,299 --> 00:26:05,919
and returns the value pretty

00:26:03,700 --> 00:26:08,890
straightforward nothing surprising there

00:26:05,919 --> 00:26:15,250
now this is what it's going to create

00:26:08,890 --> 00:26:17,049
for for the code you can kind of just

00:26:15,250 --> 00:26:18,669
ignore the assembly it's not we're not

00:26:17,049 --> 00:26:21,070
going to dig into it but what we're

00:26:18,669 --> 00:26:23,650
going to notice is we've got first of

00:26:21,070 --> 00:26:25,990
all it looks like it's been in lined so

00:26:23,650 --> 00:26:29,429
the routine itself shows up in main and

00:26:25,990 --> 00:26:32,650
then hey the routine still also shows up

00:26:29,429 --> 00:26:38,660
so one thing that we're we can take away

00:26:32,650 --> 00:26:41,420
from this is when we see stuff like this

00:26:38,660 --> 00:26:43,190
for our small embedded things we want to

00:26:41,420 --> 00:26:45,710
make sure that link time optimizations

00:26:43,190 --> 00:26:48,100
turned on LTO is going to help us with

00:26:45,710 --> 00:26:50,330
producing smaller sizes and the binaries

00:26:48,100 --> 00:26:52,700
this is information we can't decide

00:26:50,330 --> 00:26:54,860
until link time and LTO is something you

00:26:52,700 --> 00:26:57,200
have to turn in both at the compiler and

00:26:54,860 --> 00:27:00,140
the linker it needs information from

00:26:57,200 --> 00:27:01,880
both pit for both bits in order to get

00:27:00,140 --> 00:27:03,230
the whole thing to work turn that on

00:27:01,880 --> 00:27:04,640
this would this would go away now the

00:27:03,230 --> 00:27:08,270
other thing is we could just say hey

00:27:04,640 --> 00:27:10,250
this is local nothing else is going to

00:27:08,270 --> 00:27:12,350
ever call this and we could actually

00:27:10,250 --> 00:27:14,780
just say hey namespace is the anonymous

00:27:12,350 --> 00:27:16,580
namespace and now the compiler realizes

00:27:14,780 --> 00:27:18,350
that if it's not called locally it's not

00:27:16,580 --> 00:27:21,110
used locally it can't be used externally

00:27:18,350 --> 00:27:23,660
and that would fall away if we wanted to

00:27:21,110 --> 00:27:26,480
do that so another takeaway from this is

00:27:23,660 --> 00:27:29,260
if we actually think about the

00:27:26,480 --> 00:27:32,330
namespaces of things if things are local

00:27:29,260 --> 00:27:35,270
we use name spacing anonymous namespaces

00:27:32,330 --> 00:27:37,700
- to do that we actually will just kind

00:27:35,270 --> 00:27:44,330
of end up with a better set of code

00:27:37,700 --> 00:27:45,860
going into the linker so the question is

00:27:44,330 --> 00:27:47,630
if I label the inline what I get the

00:27:45,860 --> 00:27:56,090
same effect in all cases no not in all

00:27:47,630 --> 00:28:00,080
cases yeah alright so that code bother

00:27:56,090 --> 00:28:02,300
anybody other than this person over here

00:28:00,080 --> 00:28:06,860
does it bother anyone else other than

00:28:02,300 --> 00:28:08,630
Marshall yeah ok there there are a few

00:28:06,860 --> 00:28:12,170
people what it was a bother you Wise's

00:28:08,630 --> 00:28:15,530
bother you I could use an algorithm okay

00:28:12,170 --> 00:28:16,340
now you know I'm an embedded programmers

00:28:15,530 --> 00:28:18,200
been doing this for a while and

00:28:16,340 --> 00:28:21,860
algorithms kind of worry me I don't know

00:28:18,200 --> 00:28:24,100
I just seem like like here I look at it

00:28:21,860 --> 00:28:26,120
it's really obvious what it does right I

00:28:24,100 --> 00:28:28,310
mean that's the whole idea right it's

00:28:26,120 --> 00:28:30,620
not obvious what it does that's why we

00:28:28,310 --> 00:28:33,170
want to use algorithms so let's go ahead

00:28:30,620 --> 00:28:36,410
and use an algorithm we have one it's

00:28:33,170 --> 00:28:38,900
called County F how nice right so let's

00:28:36,410 --> 00:28:40,580
just use the countif algorithm and the

00:28:38,900 --> 00:28:42,950
predicate we'll just go ahead and see if

00:28:40,580 --> 00:28:45,890
the thing passed in is a sound good

00:28:42,950 --> 00:28:50,420
enough all right now what would we

00:28:45,890 --> 00:28:51,980
expect the compiler to do with this not

00:28:50,420 --> 00:28:53,809
the peanut gallery

00:28:51,980 --> 00:28:58,070
so people who work on compilers you

00:28:53,809 --> 00:29:02,179
can't talk this is what we would expect

00:28:58,070 --> 00:29:03,830
and the raw loop and the the the

00:29:02,179 --> 00:29:05,510
algorithm basically produced the same

00:29:03,830 --> 00:29:08,269
output there are some minor differences

00:29:05,510 --> 00:29:12,019
but you know for all practical purposes

00:29:08,269 --> 00:29:13,760
it's basically the same output that is

00:29:12,019 --> 00:29:15,860
not intuitive to most embedded

00:29:13,760 --> 00:29:17,659
programmers who are coming from C and

00:29:15,860 --> 00:29:20,269
going into C++ the first thing to

00:29:17,659 --> 00:29:24,169
realize is that the abstractions have

00:29:20,269 --> 00:29:26,179
zero cost we can talk about things at a

00:29:24,169 --> 00:29:28,010
much higher level we can talk about

00:29:26,179 --> 00:29:29,450
things by saying count if when I say

00:29:28,010 --> 00:29:33,649
count if I know what it's going to do I

00:29:29,450 --> 00:29:35,750
don't have to analyze the loop and by by

00:29:33,649 --> 00:29:37,370
providing information not just to the

00:29:35,750 --> 00:29:39,440
compiler but to one another about what

00:29:37,370 --> 00:29:40,820
in the world this thing is it's so much

00:29:39,440 --> 00:29:43,610
easier to maintain and understand your

00:29:40,820 --> 00:29:45,590
code we can think at a higher level so

00:29:43,610 --> 00:29:47,240
we want to get to that point now we've

00:29:45,590 --> 00:29:50,750
kind of just changed it slightly I'm

00:29:47,240 --> 00:29:53,539
using a capture now so the idea is that

00:29:50,750 --> 00:29:55,309
we're capturing with eight and and

00:29:53,539 --> 00:29:56,929
there's really no reason to use the

00:29:55,309 --> 00:29:59,090
capture to capture it except just to

00:29:56,929 --> 00:30:01,340
demonstrate that the compiler does the

00:29:59,090 --> 00:30:02,870
same thing it's not like by adding

00:30:01,340 --> 00:30:04,850
captures and whatnot the compiler is not

00:30:02,870 --> 00:30:07,549
smart enough to to make that go away

00:30:04,850 --> 00:30:12,159
from me I can actually use the language

00:30:07,549 --> 00:30:17,510
fully and get get a good result from it

00:30:12,159 --> 00:30:19,220
all right so let's instead of taking the

00:30:17,510 --> 00:30:26,210
input from the command line let's just

00:30:19,220 --> 00:30:29,080
have some data in the system now I'll

00:30:26,210 --> 00:30:29,080
let you look at it for a moment

00:30:33,900 --> 00:30:41,070
I'd like to thank yen's who pointed out

00:30:39,240 --> 00:30:43,560
in the YouTube comments that there was

00:30:41,070 --> 00:30:47,510
an error on this slide and it's very

00:30:43,560 --> 00:30:50,880
embarrassing does anybody see the error

00:30:47,510 --> 00:30:51,840
my size of you know why this is so

00:30:50,880 --> 00:30:54,030
embarrassing

00:30:51,840 --> 00:30:55,950
is because I wrote beginning in

00:30:54,030 --> 00:30:58,710
originally when I gave this slide and I

00:30:55,950 --> 00:31:00,720
thought I'm gonna make it friendlier by

00:30:58,710 --> 00:31:02,280
removing beginning in so that there

00:31:00,720 --> 00:31:04,350
aren't so many things on it that

00:31:02,280 --> 00:31:07,020
somebody coming maybe from C would not

00:31:04,350 --> 00:31:09,750
would not be comfortable with and in

00:31:07,020 --> 00:31:14,420
doing that I created it like just a

00:31:09,750 --> 00:31:18,540
bonehead error right I'm off not by one

00:31:14,420 --> 00:31:22,020
by a lot so let's not do it that way

00:31:18,540 --> 00:31:23,580
let's use begin and end so begin and end

00:31:22,020 --> 00:31:25,260
that's really how we should actually

00:31:23,580 --> 00:31:28,890
talk about the begin in the end of

00:31:25,260 --> 00:31:30,750
ranges and something just so incredibly

00:31:28,890 --> 00:31:32,850
simple in which I probably was trying

00:31:30,750 --> 00:31:33,300
pretty hard not to make mistakes I made

00:31:32,850 --> 00:31:35,910
a mistake

00:31:33,300 --> 00:31:38,370
one in which by the way all slides

00:31:35,910 --> 00:31:39,720
worked out fine these things compile it

00:31:38,370 --> 00:31:41,430
gave me a results that seemed reasonable

00:31:39,720 --> 00:31:44,580
you know this would have been great

00:31:41,430 --> 00:31:46,020
until it shipped and something bad

00:31:44,580 --> 00:31:49,230
happened because that's when bad things

00:31:46,020 --> 00:31:51,600
happen by having a language in which we

00:31:49,230 --> 00:31:54,300
can we can talk about ideas at a higher

00:31:51,600 --> 00:31:56,040
level and get good and correct results

00:31:54,300 --> 00:31:57,810
that's a good thing and you know that

00:31:56,040 --> 00:32:00,300
wasn't even planned that was just like

00:31:57,810 --> 00:32:02,910
made a mistake beginning in so we should

00:32:00,300 --> 00:32:06,960
have used all right so we shoved this in

00:32:02,910 --> 00:32:10,110
what do we get all right so this has

00:32:06,960 --> 00:32:11,760
been compiled with OS that's the other

00:32:10,110 --> 00:32:13,950
thing with embedded things you typically

00:32:11,760 --> 00:32:15,990
are compiling for size that's what

00:32:13,950 --> 00:32:19,350
you're interested in and so we've got

00:32:15,990 --> 00:32:23,670
some amount of assembly on the left and

00:32:19,350 --> 00:32:27,690
we have on the right what is this you

00:32:23,670 --> 00:32:29,550
know the data now when I look at this it

00:32:27,690 --> 00:32:34,140
seems like it seems like shouldn't be

00:32:29,550 --> 00:32:36,650
too hard to count them so why is it hard

00:32:34,140 --> 00:32:36,650
to count them

00:32:38,779 --> 00:32:43,710
yeah they're they're not const them a

00:32:41,609 --> 00:32:47,159
change but you know the importance of

00:32:43,710 --> 00:32:49,289
const if we add const in because const

00:32:47,159 --> 00:32:52,109
is important then i end up with this

00:32:49,289 --> 00:32:58,259
that's the two lines at the bottom right

00:32:52,109 --> 00:32:59,340
so return to so we've got to the other

00:32:58,259 --> 00:33:02,549
thing we want to take away is

00:32:59,340 --> 00:33:05,330
abstractions not only don't have

00:33:02,549 --> 00:33:09,269
additional overhead but if we use

00:33:05,330 --> 00:33:12,570
constantly we end up with big gains like

00:33:09,269 --> 00:33:14,519
really large gains we can still put the

00:33:12,570 --> 00:33:16,499
data inside of the code like we want to

00:33:14,519 --> 00:33:17,940
but it's gonna calculate it the compiler

00:33:16,499 --> 00:33:20,989
is going to calculate the outcome for us

00:33:17,940 --> 00:33:26,909
we're gonna end up with something nice

00:33:20,989 --> 00:33:37,289
alright so let's talk about polymorphism

00:33:26,909 --> 00:33:38,669
for a moment what is polymorphism okay

00:33:37,289 --> 00:33:40,109
same code does something different

00:33:38,669 --> 00:33:42,869
depending upon condition we're gonna say

00:33:40,109 --> 00:33:46,559
for me at least at the moment that that

00:33:42,869 --> 00:33:50,129
a base class is able to use the behavior

00:33:46,559 --> 00:33:51,899
of a derived class as the derived

00:33:50,129 --> 00:33:53,279
classes change about right so it's

00:33:51,899 --> 00:33:55,529
easier the other way around right a

00:33:53,279 --> 00:33:58,019
derived class using the behavior of the

00:33:55,529 --> 00:34:00,479
base class that's very natural but for a

00:33:58,019 --> 00:34:02,460
base class to be able to utilize the

00:34:00,479 --> 00:34:04,379
behaviors of derived classes of the

00:34:02,460 --> 00:34:07,289
derived class changes something has to

00:34:04,379 --> 00:34:09,539
happen there and typically what happens

00:34:07,289 --> 00:34:11,369
there is we we write things like virtual

00:34:09,539 --> 00:34:14,480
so we're gonna have this main it's

00:34:11,369 --> 00:34:17,369
simply going to go through and iterate

00:34:14,480 --> 00:34:18,990
calling get point as it passes in one

00:34:17,369 --> 00:34:20,909
value it's going to get get the other

00:34:18,990 --> 00:34:26,520
value out as if it's passing an X

00:34:20,909 --> 00:34:27,750
getting a Y and let's just say it's

00:34:26,520 --> 00:34:31,139
going to inherit for in something called

00:34:27,750 --> 00:34:34,169
curve and we're gonna have a simple

00:34:31,139 --> 00:34:35,460
version which does nothing more no we're

00:34:34,169 --> 00:34:40,619
gonna look at the base class here of

00:34:35,460 --> 00:34:43,049
curve it has a virtual that calls get

00:34:40,619 --> 00:34:45,329
point or the soon the virtual function

00:34:43,049 --> 00:34:50,159
call get point and it's going to call

00:34:45,329 --> 00:34:51,990
adjust and adjust is a virtual method

00:34:50,159 --> 00:34:55,139
that the

00:34:51,990 --> 00:34:57,930
that the derive type will implement so

00:34:55,139 --> 00:35:00,600
the behavior the algorithm bit we stick

00:34:57,930 --> 00:35:02,850
inside the inside the base but it needs

00:35:00,600 --> 00:35:04,890
information from the derive type and so

00:35:02,850 --> 00:35:06,750
therefore we make it virtual why because

00:35:04,890 --> 00:35:08,760
there's going to be a V table for us the

00:35:06,750 --> 00:35:13,200
V table provides us level of indirection

00:35:08,760 --> 00:35:15,300
so that when it calls adjust it looks

00:35:13,200 --> 00:35:16,650
and says where do I need to call that

00:35:15,300 --> 00:35:20,090
and there's some jump table to call the

00:35:16,650 --> 00:35:24,060
correct version of the derived type so

00:35:20,090 --> 00:35:27,330
so that's our very simple simple now it

00:35:24,060 --> 00:35:29,970
produces some code quite a bit of code

00:35:27,330 --> 00:35:31,290
in fact and some of it is obvious when

00:35:29,970 --> 00:35:33,540
we start looking we're gonna see some

00:35:31,290 --> 00:35:36,180
our TTI some runtime types we're gonna

00:35:33,540 --> 00:35:38,550
see some jump codes that are inside

00:35:36,180 --> 00:35:40,350
there some indirection from the virtual

00:35:38,550 --> 00:35:43,500
tables are happening over and over again

00:35:40,350 --> 00:35:47,000
that's what the offsets are we've got a

00:35:43,500 --> 00:35:50,520
lot of code for a small bit of task

00:35:47,000 --> 00:35:52,410
virtual things are horrible in embedded

00:35:50,520 --> 00:35:53,670
systems for a whole lot of reasons

00:35:52,410 --> 00:35:55,230
typically don't want the additional

00:35:53,670 --> 00:35:57,000
indirection but more importantly you

00:35:55,230 --> 00:35:59,640
don't want all the overhead of the cruft

00:35:57,000 --> 00:36:01,760
that just comes in along the way well

00:35:59,640 --> 00:36:04,440
what's interesting to me mostly about

00:36:01,760 --> 00:36:07,740
about polymorphism is solve them do we

00:36:04,440 --> 00:36:10,200
really need runtime polymorphism most of

00:36:07,740 --> 00:36:12,390
the time what we care about is this

00:36:10,200 --> 00:36:14,070
behavior that chains on the derive type

00:36:12,390 --> 00:36:15,450
and we know what it's going to be we

00:36:14,070 --> 00:36:18,480
know the directory we've just put the

00:36:15,450 --> 00:36:21,930
algorithms into the base and so we

00:36:18,480 --> 00:36:24,570
really just need compile time so same

00:36:21,930 --> 00:36:25,800
thing compile time though looks like

00:36:24,570 --> 00:36:28,020
this and you've probably seen this

00:36:25,800 --> 00:36:29,850
pattern before it's a curiously

00:36:28,020 --> 00:36:31,560
reoccurring template pattern and see RTP

00:36:29,850 --> 00:36:33,510
because we're really bad at naming

00:36:31,560 --> 00:36:37,080
things things we're not good at as an

00:36:33,510 --> 00:36:40,800
industry so the CRT pattern looks like

00:36:37,080 --> 00:36:43,020
this where we've got what we're deriving

00:36:40,800 --> 00:36:45,330
from something and the template

00:36:43,020 --> 00:36:47,670
parameter is the name of the thing that

00:36:45,330 --> 00:36:49,500
we're creating so class simple is

00:36:47,670 --> 00:36:51,600
deriving from curve and it's passing and

00:36:49,500 --> 00:36:54,420
simple CRT P is used for two things

00:36:51,600 --> 00:36:56,640
either it's used for compile time

00:36:54,420 --> 00:36:58,590
polymorphism or it's using for injecting

00:36:56,640 --> 00:37:00,510
behavior if you've ever used enables

00:36:58,590 --> 00:37:02,119
shared from this it's injecting behavior

00:37:00,510 --> 00:37:04,730
that's what you're trying to do there

00:37:02,119 --> 00:37:07,190
all right so how do we use it

00:37:04,730 --> 00:37:10,099
here's our base class that we had before

00:37:07,190 --> 00:37:11,420
it has a template parameter of course

00:37:10,099 --> 00:37:14,839
because we're gonna be passing that on

00:37:11,420 --> 00:37:17,150
in and how should we use that well like

00:37:14,839 --> 00:37:20,030
this we're going to say instead of just

00:37:17,150 --> 00:37:22,339
calling a just now we're going to say

00:37:20,030 --> 00:37:23,180
the imple adjust now there's different

00:37:22,339 --> 00:37:25,339
ways to do this

00:37:23,180 --> 00:37:27,320
I mean diffusing imple a lot sometimes

00:37:25,339 --> 00:37:30,470
people use derived it has more letters I

00:37:27,320 --> 00:37:34,460
don't know what does imple Impuls

00:37:30,470 --> 00:37:37,640
nothing more than casting to casting the

00:37:34,460 --> 00:37:40,760
this pointer to the derived type and

00:37:37,640 --> 00:37:42,050
that's safe to do because it knows what

00:37:40,760 --> 00:37:43,760
type it is right that's how was

00:37:42,050 --> 00:37:45,500
instantiated it wasn't standard with the

00:37:43,760 --> 00:37:48,230
type so you're able to put the algorithm

00:37:45,500 --> 00:37:50,450
in there now what do we end up with well

00:37:48,230 --> 00:37:51,920
we end up with a much smaller piece of

00:37:50,450 --> 00:37:53,750
code and we still end up with

00:37:51,920 --> 00:37:56,450
polymorphism we still end up with a

00:37:53,750 --> 00:38:09,740
technique that we want but the code is

00:37:56,450 --> 00:38:11,750
smaller alright don't ruin my next

00:38:09,740 --> 00:38:13,339
slides I'm not gonna repeat it he's

00:38:11,750 --> 00:38:20,030
trying to he's gonna try to ruin my

00:38:13,339 --> 00:38:22,790
slide coming up stop all right so d

00:38:20,030 --> 00:38:24,410
virtualization so it ends up that the

00:38:22,790 --> 00:38:26,329
compiler was really hard to make it

00:38:24,410 --> 00:38:28,130
create all that bloat for me in that

00:38:26,329 --> 00:38:30,349
first couple slides because it wanted to

00:38:28,130 --> 00:38:32,180
Deaver july's this it knew that it

00:38:30,349 --> 00:38:34,730
wasn't needed and in a virtualized

00:38:32,180 --> 00:38:37,250
manner the compiler actually produced

00:38:34,730 --> 00:38:39,380
the same code for mobile work that I had

00:38:37,250 --> 00:38:41,210
gone through the virtualization though

00:38:39,380 --> 00:38:43,579
can fall apart as soon as a couple

00:38:41,210 --> 00:38:47,089
levels get confused or a variety of

00:38:43,579 --> 00:38:49,250
other things so you know if you're if

00:38:47,089 --> 00:38:51,640
you're needing to depend upon the fact

00:38:49,250 --> 00:38:55,130
that this happens you probably shouldn't

00:38:51,640 --> 00:39:02,050
but ya see RTP and the deep virtualized

00:38:55,130 --> 00:39:04,430
version are basically the same ok so a

00:39:02,050 --> 00:39:07,069
couple things that we take away in line

00:39:04,430 --> 00:39:11,119
functions don't look like the code that

00:39:07,069 --> 00:39:12,349
we wrote this can be scary you know this

00:39:11,119 --> 00:39:14,569
could be one of those things where I

00:39:12,349 --> 00:39:16,010
wrote some code I expected it to do

00:39:14,569 --> 00:39:17,630
something and it didn't do it in fact

00:39:16,010 --> 00:39:19,460
this is one of the arguments of why not

00:39:17,630 --> 00:39:22,140
to use C++

00:39:19,460 --> 00:39:23,730
it's because it in lines and it changes

00:39:22,140 --> 00:39:25,730
things and optimizes things and I don't

00:39:23,730 --> 00:39:29,029
really know what the code does anymore

00:39:25,730 --> 00:39:32,660
Const can allow the compiler to optimize

00:39:29,029 --> 00:39:40,819
a variety of line of codes a way for us

00:39:32,660 --> 00:39:45,749
static polymorphism it's it's good and

00:39:40,819 --> 00:39:47,339
the results they they can change with

00:39:45,749 --> 00:39:51,210
different debug in optimization flags

00:39:47,339 --> 00:39:53,369
our results can change now one thing at

00:39:51,210 --> 00:39:55,319
this point is we can say debugging might

00:39:53,369 --> 00:39:57,059
be hard have you ever met anybody in

00:39:55,319 --> 00:39:59,220
fact maybe it's you who's like a

00:39:57,059 --> 00:40:00,630
debugging C++ it's crazy

00:39:59,220 --> 00:40:02,130
as soon as I turned the debugger on my

00:40:00,630 --> 00:40:05,609
substance art stepping through I have no

00:40:02,130 --> 00:40:07,079
idea where I'm gonna ever be so this is

00:40:05,609 --> 00:40:10,950
what countif looks like under the hood

00:40:07,079 --> 00:40:12,839
right and I know you could talk to we

00:40:10,950 --> 00:40:14,339
have lots of implementers around this

00:40:12,839 --> 00:40:15,839
week you can talk to them why they can't

00:40:14,339 --> 00:40:17,970
just come up with names that make sense

00:40:15,839 --> 00:40:22,009
but they've got lots of decorations and

00:40:17,970 --> 00:40:24,660
they're long and they're crazy and

00:40:22,009 --> 00:40:26,190
eventually we get to that and yo yeah

00:40:24,660 --> 00:40:28,829
there's that other concept requirement

00:40:26,190 --> 00:40:30,359
stuff there and it it can look noisy if

00:40:28,829 --> 00:40:34,140
you're stepping into it first of all I'd

00:40:30,359 --> 00:40:40,079
say don't step into algorithms because

00:40:34,140 --> 00:40:40,650
that's probably not what's wrong so what

00:40:40,079 --> 00:40:42,599
does this look like without

00:40:40,650 --> 00:40:46,470
optimizations turned on well it's that

00:40:42,599 --> 00:40:48,749
and that and that and that and yeah okay

00:40:46,470 --> 00:40:51,180
so and that too I don't think I actually

00:40:48,749 --> 00:40:53,880
I want this code right I want the

00:40:51,180 --> 00:40:55,489
optimizer to do its job that's what I

00:40:53,880 --> 00:40:58,380
want

00:40:55,489 --> 00:40:59,430
so challenge is we want think about this

00:40:58,380 --> 00:41:01,769
there's gonna be some challenges in

00:40:59,430 --> 00:41:03,809
writing and debugging this thing and so

00:41:01,769 --> 00:41:07,049
often what happens in the embedded world

00:41:03,809 --> 00:41:09,089
is - OH zero why because if you do the

00:41:07,049 --> 00:41:12,349
man page and you look up - zero this is

00:41:09,089 --> 00:41:14,359
what it says reduce compilation time

00:41:12,349 --> 00:41:17,999
that looks great

00:41:14,359 --> 00:41:21,989
and make debugging produce the expected

00:41:17,999 --> 00:41:24,180
result two good things right except that

00:41:21,989 --> 00:41:29,819
I really don't want those things but

00:41:24,180 --> 00:41:30,450
this is why - O's eros used a lot all

00:41:29,819 --> 00:41:32,880
right

00:41:30,450 --> 00:41:37,440
let's just take a look for a moment at

00:41:32,880 --> 00:41:38,640
some C code we could be critical of the

00:41:37,440 --> 00:41:40,440
C code but we're not going to at the

00:41:38,640 --> 00:41:44,309
moment okay it's going to serve an

00:41:40,440 --> 00:41:45,869
illustration for us so very simple piece

00:41:44,309 --> 00:41:47,640
of code we're going to pass some values

00:41:45,869 --> 00:41:52,170
in we're hoping that they get order and

00:41:47,640 --> 00:41:56,970
we have a 32-bit value out this is what

00:41:52,170 --> 00:41:59,220
we get so this is compiler Explorer got

00:41:56,970 --> 00:42:01,260
bolt org is where you can find this on

00:41:59,220 --> 00:42:02,579
the left hand side we've got the source

00:42:01,260 --> 00:42:04,920
on the right hand side we have the

00:42:02,579 --> 00:42:09,180
assembly that came out and this is the

00:42:04,920 --> 00:42:11,220
assembly produced with 0 it appears to

00:42:09,180 --> 00:42:14,819
be doing a lot of work for what I've

00:42:11,220 --> 00:42:19,049
asked it to do and it's actually doing

00:42:14,819 --> 00:42:22,230
what - O's ero said it would do all the

00:42:19,049 --> 00:42:25,890
things you expect and if you think about

00:42:22,230 --> 00:42:27,180
it what do I expect I got a stack and

00:42:25,890 --> 00:42:28,290
I've got registers that have to get

00:42:27,180 --> 00:42:29,940
pushed and later they're gonna have to

00:42:28,290 --> 00:42:31,890
get popped and there's a lot of work

00:42:29,940 --> 00:42:37,859
that's going to occur to call a function

00:42:31,890 --> 00:42:43,500
right so now if I turn on optimization

00:42:37,859 --> 00:42:45,150
what would happen something else it

00:42:43,500 --> 00:42:46,980
doesn't have to worry about that why

00:42:45,150 --> 00:42:48,599
because it knows what's inside of the

00:42:46,980 --> 00:42:50,910
registers and what it's going to return

00:42:48,599 --> 00:42:52,980
I get something quite a bit more simple

00:42:50,910 --> 00:42:54,839
in fact it might even look at ficient at

00:42:52,980 --> 00:43:00,990
the moment right that doesn't look so

00:42:54,839 --> 00:43:03,480
bad but if I was a C programmer that's

00:43:00,990 --> 00:43:05,849
not what I would do I would create a

00:43:03,480 --> 00:43:09,750
macro that's going to do this for me

00:43:05,849 --> 00:43:12,660
why because somehow that's less scary to

00:43:09,750 --> 00:43:14,250
create an inline with a macro can

00:43:12,660 --> 00:43:25,140
anybody tell me why would have inline

00:43:14,250 --> 00:43:27,359
with a macro be scary maybe okay there

00:43:25,140 --> 00:43:29,339
might be scary because they're not type

00:43:27,359 --> 00:43:33,119
safe suddenly there's no type

00:43:29,339 --> 00:43:35,160
information about a macro right so well

00:43:33,119 --> 00:43:37,770
I'm going to get maybe this concept of

00:43:35,160 --> 00:43:42,030
like inlining it'll feel less scary

00:43:37,770 --> 00:43:43,559
just let the compiler do its job so here

00:43:42,030 --> 00:43:44,069
yeah here I'm just trying to actually

00:43:43,559 --> 00:43:46,019
call

00:43:44,069 --> 00:43:47,670
it from what we had before and we can

00:43:46,019 --> 00:43:50,279
see that it's like the same junk that we

00:43:47,670 --> 00:43:52,859
had before we turned the optimizer on we

00:43:50,279 --> 00:43:54,959
can see that it's small again

00:43:52,859 --> 00:43:56,880
in fact probably wouldn't really do it

00:43:54,959 --> 00:43:59,279
that way if I was a C programmer I just

00:43:56,880 --> 00:44:01,519
called the macro directly right okay and

00:43:59,279 --> 00:44:02,789
that's like that's not so bad there then

00:44:01,519 --> 00:44:06,479
yeah

00:44:02,789 --> 00:44:19,289
Oh only only if there's no error will I

00:44:06,479 --> 00:44:23,549
go back to I could make the function

00:44:19,289 --> 00:44:29,910
static yeah yep and then we eventually

00:44:23,549 --> 00:44:35,900
be here and that that gets me what I

00:44:29,910 --> 00:44:35,900
wanted now it gives me what I wanted but

00:44:36,529 --> 00:44:45,359
it's it almost to me looks like not what

00:44:42,479 --> 00:44:48,660
I had really desired as we as we look

00:44:45,359 --> 00:44:52,920
through the different iterations like

00:44:48,660 --> 00:44:54,719
this one I don't know what it's doing

00:44:52,920 --> 00:45:03,239
but there's some additional stuff in

00:44:54,719 --> 00:45:06,869
there that surprises me and while on one

00:45:03,239 --> 00:45:09,690
side I say I have - OH zero and I'm

00:45:06,869 --> 00:45:13,529
going to expect what I want that's not

00:45:09,690 --> 00:45:15,420
what I want I don't really want a zero

00:45:13,529 --> 00:45:16,859
because zero is not going to actually

00:45:15,420 --> 00:45:18,930
get me the benefit that I want and so I

00:45:16,859 --> 00:45:20,940
start making macros in order to get in

00:45:18,930 --> 00:45:23,549
lines and I start actually doing all

00:45:20,940 --> 00:45:26,339
these other things to get what I really

00:45:23,549 --> 00:45:27,479
want and what I really want is probably

00:45:26,339 --> 00:45:29,309
just to call a function turn the

00:45:27,479 --> 00:45:31,410
optimizer on that's probably what I want

00:45:29,309 --> 00:45:33,449
and the reason is at the end of the day

00:45:31,410 --> 00:45:36,329
I can't actually guess what the compiler

00:45:33,449 --> 00:45:37,499
might be doing nobody can really pretend

00:45:36,329 --> 00:45:40,529
that they know what the compiler is

00:45:37,499 --> 00:45:42,449
doing by the end of the day you're just

00:45:40,529 --> 00:45:45,630
you're just guessing right and so what

00:45:42,449 --> 00:45:47,130
you have to do is measure and test you

00:45:45,630 --> 00:45:48,269
in fact you always have to measure in

00:45:47,130 --> 00:45:49,529
tests if you think you can write

00:45:48,269 --> 00:45:52,109
software in such a way that you can just

00:45:49,529 --> 00:45:54,269
like noodle out what the compiler is

00:45:52,109 --> 00:45:55,829
going to do and what the the assembly

00:45:54,269 --> 00:45:57,450
looks like you're kind of like fooling

00:45:55,829 --> 00:46:00,540
yourself so

00:45:57,450 --> 00:46:01,920
instead just turn the optimizer on and

00:46:00,540 --> 00:46:03,810
measure and test which is what you have

00:46:01,920 --> 00:46:16,609
to do actually anyhow if you don't do

00:46:03,810 --> 00:46:16,609
that so the other thing is we'll move on

00:46:16,970 --> 00:46:27,000
so the the idea that that we we seem to

00:46:25,920 --> 00:46:31,619
be getting into this mode of operation

00:46:27,000 --> 00:46:34,230
in which we write software and as soon

00:46:31,619 --> 00:46:35,220
as I'm done writing it and want to run

00:46:34,230 --> 00:46:40,589
it in the debugger to see if it works

00:46:35,220 --> 00:46:43,380
right if you turn your debugger on you

00:46:40,589 --> 00:46:45,720
have a problem and I don't mean the code

00:46:43,380 --> 00:46:48,300
has a problem I mean you have a problem

00:46:45,720 --> 00:46:49,859
you shouldn't be turning your debugger

00:46:48,300 --> 00:46:51,839
on immediately to figure out what your

00:46:49,859 --> 00:46:53,790
code is doing like noodle through it

00:46:51,839 --> 00:46:56,339
think about it try to figure out in

00:46:53,790 --> 00:46:58,650
reason what did I write what's the

00:46:56,339 --> 00:47:01,650
answer supposed to be how is this

00:46:58,650 --> 00:47:03,150
supposed to work there are there are

00:47:01,650 --> 00:47:05,190
situations obviously where we turned

00:47:03,150 --> 00:47:06,540
debuggers on but it's not supposed to be

00:47:05,190 --> 00:47:08,339
the tool that we're constantly going to

00:47:06,540 --> 00:47:10,109
it ends up with really bad code that we

00:47:08,339 --> 00:47:11,099
write and we don't actually understand

00:47:10,109 --> 00:47:15,540
the problem anymore

00:47:11,099 --> 00:47:17,069
so one thing you don't step into countif

00:47:15,540 --> 00:47:18,480
to see how County is working you just

00:47:17,069 --> 00:47:21,180
like County if does what it's supposed

00:47:18,480 --> 00:47:22,770
to do if you've got a problem you kind

00:47:21,180 --> 00:47:25,410
of like think about what the problem is

00:47:22,770 --> 00:47:28,380
and maybe you're instrumenting at some

00:47:25,410 --> 00:47:29,700
point if it's pretty bad but running to

00:47:28,380 --> 00:47:32,640
the debugger all the time it's not a

00:47:29,700 --> 00:47:35,730
great great plan so let's talk about the

00:47:32,640 --> 00:47:39,270
value versus the hardware specific

00:47:35,730 --> 00:47:41,940
things value are things like algorithms

00:47:39,270 --> 00:47:43,800
business stuff that particular thing

00:47:41,940 --> 00:47:46,250
that we had that we're talking about

00:47:43,800 --> 00:47:48,810
earlier the motor controller it uses a

00:47:46,250 --> 00:47:50,760
some mathematical algorithm to determine

00:47:48,810 --> 00:47:52,680
and detect where it's going to be coming

00:47:50,760 --> 00:47:54,960
up measures a bunch of information about

00:47:52,680 --> 00:47:57,450
current coming from phases so that it

00:47:54,960 --> 00:47:59,550
can determine where the next iteration

00:47:57,450 --> 00:48:04,020
of the coils needs to be that is all

00:47:59,550 --> 00:48:05,910
business logic I can test that and know

00:48:04,020 --> 00:48:08,490
that the algorithm is rock-solid

00:48:05,910 --> 00:48:10,200
not on hardware but the only way I can

00:48:08,490 --> 00:48:11,250
do that is if I actually write my code

00:48:10,200 --> 00:48:14,340
in such a way where I've

00:48:11,250 --> 00:48:16,260
separated the value up and the hardware

00:48:14,340 --> 00:48:18,780
bits down so the other thing that I

00:48:16,260 --> 00:48:21,600
achieved by doing that isn't just this

00:48:18,780 --> 00:48:23,940
idea of layering and making me happy

00:48:21,600 --> 00:48:27,860
about abstractions the abstractions

00:48:23,940 --> 00:48:27,860
allow me to have a better tested system

00:48:32,210 --> 00:48:37,590
so sometimes what happens here is where

00:48:35,250 --> 00:48:39,330
we we do this because we're

00:48:37,590 --> 00:48:43,830
uncomfortable with knowing what's going

00:48:39,330 --> 00:48:48,930
to be executed here is here's some

00:48:43,830 --> 00:48:51,680
idiomatic C code and if you have written

00:48:48,930 --> 00:48:55,050
C code or in the bedded world doing that

00:48:51,680 --> 00:48:57,270
this is this is a typical way to solve a

00:48:55,050 --> 00:48:58,650
particular problem in fact it it's

00:48:57,270 --> 00:49:03,630
really the right way to solve this

00:48:58,650 --> 00:49:05,730
problem now if you're a C++ programmer

00:49:03,630 --> 00:49:07,980
you look at this and say we have a

00:49:05,730 --> 00:49:09,450
different way to solve this problem we

00:49:07,980 --> 00:49:11,220
have constructors and destructors that

00:49:09,450 --> 00:49:14,430
take care of cleanup at the proper time

00:49:11,220 --> 00:49:15,840
for us this is very manual but if you're

00:49:14,430 --> 00:49:18,480
coming from a world in which you believe

00:49:15,840 --> 00:49:20,610
that the compiler is you're like the

00:49:18,480 --> 00:49:23,100
evil thing in the back always trying to

00:49:20,610 --> 00:49:25,260
harm you then you're worried constantly

00:49:23,100 --> 00:49:26,550
what's going to be executed and then

00:49:25,260 --> 00:49:28,650
what's again when is it going to be

00:49:26,550 --> 00:49:30,180
executed when is when will there be

00:49:28,650 --> 00:49:31,740
instructions put in what does the

00:49:30,180 --> 00:49:32,580
compiler doing now it's actually not

00:49:31,740 --> 00:49:34,740
that hard right

00:49:32,580 --> 00:49:36,450
constructors construct destructors

00:49:34,740 --> 00:49:40,890
destruct if you don't write any code in

00:49:36,450 --> 00:49:43,260
them it's not doing anything so it looks

00:49:40,890 --> 00:49:45,660
like a struct basically right so this is

00:49:43,260 --> 00:49:47,130
this is error-prone anybody have code

00:49:45,660 --> 00:49:51,060
like this that there was ever an error

00:49:47,130 --> 00:49:53,670
in okay anybody have code like this that

00:49:51,060 --> 00:49:56,400
there wasn't an error in exactly nobody

00:49:53,670 --> 00:49:58,470
right because this is just hard to do

00:49:56,400 --> 00:50:00,840
right and so the idiomatic way to write

00:49:58,470 --> 00:50:04,770
C++ code is with constructors and

00:50:00,840 --> 00:50:08,930
destructors some of the other things

00:50:04,770 --> 00:50:13,530
that come out is that there's like this

00:50:08,930 --> 00:50:15,900
I think was artisanal was the comment

00:50:13,530 --> 00:50:18,000
that was made way to write when like

00:50:15,900 --> 00:50:20,700
when I look at C++ code it looks so

00:50:18,000 --> 00:50:23,160
sophisticated what's nice about it right

00:50:20,700 --> 00:50:24,480
they're just different idioms and so you

00:50:23,160 --> 00:50:25,019
need to get used to the idioms and one

00:50:24,480 --> 00:50:28,019
of the questions

00:50:25,019 --> 00:50:31,380
has seems to has has arisen quite a bit

00:50:28,019 --> 00:50:33,899
over the last few weeks was how do I

00:50:31,380 --> 00:50:35,009
learn these idioms and I think the best

00:50:33,899 --> 00:50:40,019
way to learn the idioms is not

00:50:35,009 --> 00:50:42,149
stackoverflow people so the best way to

00:50:40,019 --> 00:50:44,219
probably learn the idioms is finding

00:50:42,149 --> 00:50:47,249
like a blog post of somebody who blogs

00:50:44,219 --> 00:50:50,339
well and knows this stuff watching some

00:50:47,249 --> 00:50:53,009
YouTube videos Jason Turner has a like a

00:50:50,339 --> 00:50:54,769
weekly video that talks about all kinds

00:50:53,009 --> 00:50:56,489
of different things in different idioms

00:50:54,769 --> 00:50:58,289
different techniques things that he's

00:50:56,489 --> 00:50:59,579
learned as well as he's got these great

00:50:58,289 --> 00:51:05,279
blog posts there's lots of people who do

00:50:59,579 --> 00:51:08,699
these things alright correctness type

00:51:05,279 --> 00:51:10,799
system needs to enforce correctness and

00:51:08,699 --> 00:51:14,219
we want to move as much into compiled

00:51:10,799 --> 00:51:15,659
time so the good of separating is that

00:51:14,219 --> 00:51:18,599
we're going to be able to do that and

00:51:15,659 --> 00:51:20,429
the bad is that well some people say

00:51:18,599 --> 00:51:22,079
that the bad is that were we're too far

00:51:20,429 --> 00:51:24,539
removed but there's really not a bad so

00:51:22,079 --> 00:51:25,619
I'll just cross it out now all right so

00:51:24,539 --> 00:51:27,869
one of the things that we have to talk

00:51:25,619 --> 00:51:30,989
to is an FPGA and we do that through a

00:51:27,869 --> 00:51:32,549
spy bus and the spy bus has what's

00:51:30,989 --> 00:51:37,649
called master and slave out slave and

00:51:32,549 --> 00:51:41,609
master master and yeah that master in

00:51:37,649 --> 00:51:44,609
slave out and and and the other one

00:51:41,609 --> 00:51:47,130
master out slave and so it's just this

00:51:44,609 --> 00:51:48,869
like ring that goes around and the the

00:51:47,130 --> 00:51:50,789
master side is producing clocks and as

00:51:48,869 --> 00:51:53,009
clocks are going it's just clocking in

00:51:50,789 --> 00:51:57,479
through a register and clocking back out

00:51:53,009 --> 00:52:01,109
the other side this is some code that

00:51:57,479 --> 00:52:04,439
exists in a project that has had a bunch

00:52:01,109 --> 00:52:05,880
of things changed we read opted this it

00:52:04,439 --> 00:52:07,619
was talking to a motor controller a

00:52:05,880 --> 00:52:11,009
different motor controller um using a

00:52:07,619 --> 00:52:12,749
spy bus and this is what the code looked

00:52:11,009 --> 00:52:14,279
like the C code now the problem is is

00:52:12,749 --> 00:52:15,659
that if if we needed to add more

00:52:14,279 --> 00:52:17,399
commands which we needed to add a whole

00:52:15,659 --> 00:52:19,799
bunch of more commands we had to go and

00:52:17,399 --> 00:52:21,779
write something like this again so

00:52:19,799 --> 00:52:23,189
there's some code that's doing some very

00:52:21,779 --> 00:52:24,630
low-level things there's really no

00:52:23,189 --> 00:52:26,639
abstraction at all you know the

00:52:24,630 --> 00:52:28,529
abstractions the name of the method that

00:52:26,639 --> 00:52:29,969
I'm calling and then at that point I'm

00:52:28,529 --> 00:52:31,709
just kind of like banging bits right

00:52:29,969 --> 00:52:33,719
there's actually there's some

00:52:31,709 --> 00:52:35,599
lower-level bits parts that are actually

00:52:33,719 --> 00:52:38,360
singing the bits out for the stream but

00:52:35,599 --> 00:52:42,140
let me ask what do you see

00:52:38,360 --> 00:52:48,350
thing with oh well maybe this here that

00:52:42,140 --> 00:52:50,570
might cause some problems yeah we might

00:52:48,350 --> 00:52:53,630
swap them right by a mistake in fact

00:52:50,570 --> 00:52:57,110
actually somebody had swapped these by

00:52:53,630 --> 00:52:59,510
mistake and and it wasn't nice those two

00:52:57,110 --> 00:53:02,420
values to the motor controller meant

00:52:59,510 --> 00:53:05,330
something pretty important and the

00:53:02,420 --> 00:53:05,840
result was actually well we broke

00:53:05,330 --> 00:53:09,890
something

00:53:05,840 --> 00:53:11,810
so swapping things and getting

00:53:09,890 --> 00:53:14,900
mechanical stuff to break at the end

00:53:11,810 --> 00:53:16,670
isn't the result you want right you want

00:53:14,900 --> 00:53:20,540
your compile to break so how would we

00:53:16,670 --> 00:53:22,130
solve that types yeah we would actually

00:53:20,540 --> 00:53:23,480
have a type we would know that by

00:53:22,130 --> 00:53:24,770
construction the thing we were calling

00:53:23,480 --> 00:53:27,200
actually called the right thing and did

00:53:24,770 --> 00:53:29,720
the right stuff so we replaced it with

00:53:27,200 --> 00:53:32,120
something that looks more like this we

00:53:29,720 --> 00:53:35,150
have a protocol that's described by a

00:53:32,120 --> 00:53:38,570
series of classes they have unique types

00:53:35,150 --> 00:53:40,670
they are and those types are built up

00:53:38,570 --> 00:53:44,720
with other types right it's very type

00:53:40,670 --> 00:53:47,060
driven and as a result there's some

00:53:44,720 --> 00:53:49,220
other magic that happens the magic is we

00:53:47,060 --> 00:53:53,900
just adapt the structs so that we can

00:53:49,220 --> 00:53:57,470
understand its type later on we can then

00:53:53,900 --> 00:53:59,450
just use it though and by using it I

00:53:57,470 --> 00:54:02,210
mean we can just call for example send

00:53:59,450 --> 00:54:05,420
message and send a type and it knows how

00:54:02,210 --> 00:54:07,790
to serialize the type out the stream the

00:54:05,420 --> 00:54:09,530
advantage of this is now we become more

00:54:07,790 --> 00:54:11,270
declarative if I want to add a new

00:54:09,530 --> 00:54:13,310
message I literally just make a new

00:54:11,270 --> 00:54:15,710
struct and I adapt it I don't do

00:54:13,310 --> 00:54:17,180
anything else it's pretty easy to do I'm

00:54:15,710 --> 00:54:18,860
probably not going to make any mistakes

00:54:17,180 --> 00:54:22,460
even me I probably won't make any

00:54:18,860 --> 00:54:27,620
mistakes doing that so it's extensible

00:54:22,460 --> 00:54:30,110
it's also far fewer lines of code it

00:54:27,620 --> 00:54:32,300
also compiled down to quite a bit less

00:54:30,110 --> 00:54:36,620
code in the end the actual code itself

00:54:32,300 --> 00:54:40,490
so this was a better way to go about

00:54:36,620 --> 00:54:41,900
solving the problem state machines exist

00:54:40,490 --> 00:54:45,230
everywhere don't be afraid of state

00:54:41,900 --> 00:54:46,760
machines use and embrace state machines

00:54:45,230 --> 00:54:51,890
so here's a state machine it's written

00:54:46,760 --> 00:54:52,310
like UML diagram this is using Chris

00:54:51,890 --> 00:54:55,520
juice

00:54:52,310 --> 00:54:57,470
yaks a state machine library how many

00:54:55,520 --> 00:54:59,360
heard Chris earlier today speak yeah

00:54:57,470 --> 00:55:02,030
great library so we won't go over this a

00:54:59,360 --> 00:55:03,920
whole lot you can see it online but the

00:55:02,030 --> 00:55:06,190
idea is that we're using a

00:55:03,920 --> 00:55:09,320
domain-specific embedded language and

00:55:06,190 --> 00:55:11,620
the thing at the top is the state

00:55:09,320 --> 00:55:14,600
machine and it has things in it like

00:55:11,620 --> 00:55:18,130
states that have names and it says

00:55:14,600 --> 00:55:20,300
things like this is the event and slash

00:55:18,130 --> 00:55:23,360
this is going to be the action that's

00:55:20,300 --> 00:55:25,190
going to take here this is a guard this

00:55:23,360 --> 00:55:27,620
is all a notation that exists and that

00:55:25,190 --> 00:55:31,820
notation matches what goes inside the

00:55:27,620 --> 00:55:34,550
table the machine table that I'm writing

00:55:31,820 --> 00:55:36,080
in code looks like the diagram I'm

00:55:34,550 --> 00:55:37,760
probably not gonna mess these up I'll

00:55:36,080 --> 00:55:40,630
understand it when I go and look at it

00:55:37,760 --> 00:55:42,620
it's not a bunch of switch statements I

00:55:40,630 --> 00:55:43,700
have to believe it's going to do the

00:55:42,620 --> 00:55:45,020
right thing and that might be a little

00:55:43,700 --> 00:55:46,610
scary but you know what I can test that

00:55:45,020 --> 00:55:50,960
to make sure it didn't mess up along the

00:55:46,610 --> 00:55:55,550
way what does it produce oh and here's

00:55:50,960 --> 00:55:57,380
the other thing I guess the nope the

00:55:55,550 --> 00:55:59,690
other thing is how do we use it we use

00:55:57,380 --> 00:56:02,600
it by actually just calling on the

00:55:59,690 --> 00:56:04,550
machine process event and we pass in a

00:56:02,600 --> 00:56:07,310
type well that's interesting because

00:56:04,550 --> 00:56:09,860
I've already moved my stuff in two types

00:56:07,310 --> 00:56:11,510
what am I getting off my spy bus what am

00:56:09,860 --> 00:56:13,490
I getting off a fact off all of my

00:56:11,510 --> 00:56:16,400
communication devices on the CPU or the

00:56:13,490 --> 00:56:18,380
mpu types how do i drive my state

00:56:16,400 --> 00:56:20,810
machine with types i just shove them in

00:56:18,380 --> 00:56:23,090
I get types back out later I shove those

00:56:20,810 --> 00:56:24,950
out communication things I'm thinking at

00:56:23,090 --> 00:56:25,730
a much higher level and the type system

00:56:24,950 --> 00:56:29,570
will actually tell me if I've

00:56:25,730 --> 00:56:32,210
constructed it properly or not so a

00:56:29,570 --> 00:56:35,270
naive implementation takes three bytes

00:56:32,210 --> 00:56:37,760
of data of what we saw before the enum

00:56:35,270 --> 00:56:39,800
one and SML one that's going to compile

00:56:37,760 --> 00:56:43,600
down to something that's the same as if

00:56:39,800 --> 00:56:43,600
I hand coded it that's pretty impressive

00:56:47,890 --> 00:56:50,240
internally we use something called

00:56:49,490 --> 00:56:52,250
Loddon

00:56:50,240 --> 00:56:55,760
it's tries to move us up one level

00:56:52,250 --> 00:56:57,680
higher so now I have this one level

00:56:55,760 --> 00:56:59,270
higher of abstraction in which a port

00:56:57,680 --> 00:57:01,870
describes some things that's going to be

00:56:59,270 --> 00:57:05,470
able to be communicated across the port

00:57:01,870 --> 00:57:07,210
so as a protocol the protocol has in

00:57:05,470 --> 00:57:09,160
messages and out messages that it can

00:57:07,210 --> 00:57:11,650
receive and when I hooked those things

00:57:09,160 --> 00:57:14,859
up like this picture here they're hooked

00:57:11,650 --> 00:57:16,630
up these are state machines that appear

00:57:14,859 --> 00:57:18,040
to be distributed when I come up I can

00:57:16,630 --> 00:57:19,900
check to make sure that the in and out

00:57:18,040 --> 00:57:21,070
message is at compile-time are going to

00:57:19,900 --> 00:57:22,630
actually be compatible with one another

00:57:21,070 --> 00:57:23,619
they're going to do the right thing I'm

00:57:22,630 --> 00:57:27,609
not going to receive something that I

00:57:23,619 --> 00:57:29,830
don't understand what to do it and I

00:57:27,609 --> 00:57:31,270
simply describe that like this this is

00:57:29,830 --> 00:57:35,280
the protocol that I'm going to be

00:57:31,270 --> 00:57:37,840
speaking and ports again are just types

00:57:35,280 --> 00:57:40,830
so using the type system to help me out

00:57:37,840 --> 00:57:43,840
I'm able to then tell at compile time

00:57:40,830 --> 00:57:46,450
that the thing is assembled properly and

00:57:43,840 --> 00:57:49,060
correctly I'm not going to pass the

00:57:46,450 --> 00:57:53,920
wrong the wrong data to to something to

00:57:49,060 --> 00:57:56,980
have to have a bad result some other

00:57:53,920 --> 00:57:58,510
abstractions you can look at online Odin

00:57:56,980 --> 00:58:00,490
heads quite a few different things that

00:57:58,510 --> 00:58:03,570
he talks about with the special function

00:58:00,490 --> 00:58:06,730
registers everything inside of an MP you

00:58:03,570 --> 00:58:08,109
looks like memory and how to deal with

00:58:06,730 --> 00:58:11,560
that in such a way that makes sense

00:58:08,109 --> 00:58:13,869
there's a lot of work that that you can

00:58:11,560 --> 00:58:15,369
look online on better ways to think

00:58:13,869 --> 00:58:17,050
about it and do it that are again

00:58:15,369 --> 00:58:17,849
abstract it through types and at a

00:58:17,050 --> 00:58:23,230
higher level

00:58:17,849 --> 00:58:28,089
watch Odin's mixin talk from 2018 cpp

00:58:23,230 --> 00:58:29,530
now here are some features that that

00:58:28,089 --> 00:58:32,440
like right off the bat you can get going

00:58:29,530 --> 00:58:34,839
with and not have any problems lambda

00:58:32,440 --> 00:58:38,410
expressions algorithms range based for

00:58:34,839 --> 00:58:40,900
loop move semantics or awesome fold

00:58:38,410 --> 00:58:42,160
expressions are great and initialize

00:58:40,900 --> 00:58:44,380
your list believe it or not the thing

00:58:42,160 --> 00:58:45,760
that I'd like if some of you I recognize

00:58:44,380 --> 00:58:47,530
the faces you were in my pre conference

00:58:45,760 --> 00:58:49,390
class where I was bagging on an

00:58:47,530 --> 00:58:50,800
initializer list this is a great place

00:58:49,390 --> 00:58:54,220
for initializer list because there's so

00:58:50,800 --> 00:58:55,839
many places where we have constant lists

00:58:54,220 --> 00:58:58,780
of things that we need to actually pass

00:58:55,839 --> 00:59:00,430
around and initialize things with so

00:58:58,780 --> 00:59:02,950
it's a good place to know what the begin

00:59:00,430 --> 00:59:09,670
and end of something are some final

00:59:02,950 --> 00:59:13,900
thoughts tool vendors aren't friendly

00:59:09,670 --> 00:59:16,480
I don't want you to use C++ sometimes

00:59:13,900 --> 00:59:18,910
it'll just actually say that poor Sharon

00:59:16,480 --> 00:59:23,170
she found like this backdoor to get the

00:59:18,910 --> 00:59:25,809
C++ stuff to compile and then she called

00:59:23,170 --> 00:59:28,030
and had a bug or two and they said you

00:59:25,809 --> 00:59:31,420
should upgrade to the next version which

00:59:28,030 --> 00:59:33,910
had removed the backdoor so it's just

00:59:31,420 --> 00:59:36,309
it's just the way the environment is but

00:59:33,910 --> 00:59:38,109
it's actually worth it to get past that

00:59:36,309 --> 00:59:40,660
it's gonna take some amount of time of

00:59:38,109 --> 00:59:43,210
fighting to get past your tool setup but

00:59:40,660 --> 00:59:44,230
after that the project runs smoothly and

00:59:43,210 --> 00:59:46,920
you're able to actually put things

00:59:44,230 --> 00:59:50,290
together that you know are going to work

00:59:46,920 --> 00:59:51,549
use good tools you can't use good tools

00:59:50,290 --> 00:59:53,170
if you're stuck with the vendor tool

00:59:51,549 --> 00:59:54,549
that's just the way it is you you need

00:59:53,170 --> 00:59:55,930
to break out of that and use like all

00:59:54,549 --> 00:59:58,480
the normal things that we know that are

00:59:55,930 --> 01:00:01,359
good practices compile explore is

00:59:58,480 --> 01:00:02,589
wonderful measure and then test thank

01:00:01,359 --> 01:00:04,480
you for your attention

01:00:02,589 --> 01:00:08,130
if you have any questions I think we're

01:00:04,480 --> 01:00:08,130
out of time but I'm having taken apples

01:00:12,540 --> 01:00:25,839
yeah yeah so the the common is one of

01:00:24,190 --> 01:00:27,819
the problems in embed is that you don't

01:00:25,839 --> 01:00:29,799
have a standard library well that that's

01:00:27,819 --> 01:00:31,540
not entirely true you have certain

01:00:29,799 --> 01:00:33,400
amounts of a standard library that will

01:00:31,540 --> 01:00:36,460
work which is why I've been talking

01:00:33,400 --> 01:00:39,880
about the algorithms almost entirely all

01:00:36,460 --> 01:00:41,470
the algorithms are usable and they work

01:00:39,880 --> 01:00:43,359
with things that understand ranges

01:00:41,470 --> 01:00:46,000
begins and ends of things we can write

01:00:43,359 --> 01:00:47,829
types that work fine with all the

01:00:46,000 --> 01:00:54,190
algorithms and I can raise ourselves up

01:00:47,829 --> 01:00:56,799
out of the for loop disaster it it ships

01:00:54,190 --> 01:00:58,510
it just ships with the arm compiler you

01:00:56,799 --> 01:01:04,540
don't have to get a standard library

01:00:58,510 --> 01:01:07,930
from a part of me AV ours are supported

01:01:04,540 --> 01:01:09,849
by new tools you you can use again you

01:01:07,930 --> 01:01:11,559
can just use standard new tools to do

01:01:09,849 --> 01:01:14,020
this if you use your right if you use

01:01:11,559 --> 01:01:16,510
the bender tool you're severely

01:01:14,020 --> 01:01:19,059
restricted but you don't need to use the

01:01:16,510 --> 01:01:20,619
bender tool there are things in the

01:01:19,059 --> 01:01:22,780
vendor tool that you want to steal like

01:01:20,619 --> 01:01:23,360
linker scripts and that's a good

01:01:22,780 --> 01:01:25,550
starting point

01:01:23,360 --> 01:01:26,990
right they have startup code to start

01:01:25,550 --> 01:01:30,640
with their startup code fix it so that

01:01:26,990 --> 01:01:34,580
it works with with static types for

01:01:30,640 --> 01:01:37,820
constructors and destructors oh I'm

01:01:34,580 --> 01:01:42,230
sorry we have a mic you'll have to

01:01:37,820 --> 01:01:44,090
render the mic sir hi great talk I have

01:01:42,230 --> 01:01:45,470
a question regarding the vendor tools

01:01:44,090 --> 01:01:48,170
that you mentioned that all vendors

01:01:45,470 --> 01:01:50,780
generally don't want you to use C++ the

01:01:48,170 --> 01:01:52,520
problem that I've seen you know well

01:01:50,780 --> 01:01:55,190
I've been stumbling over and over again

01:01:52,520 --> 01:01:57,560
on is that embedded systems typically

01:01:55,190 --> 01:02:00,140
have designated memory areas like

01:01:57,560 --> 01:02:02,120
read-only memory and you know static Ram

01:02:00,140 --> 01:02:04,790
that you can use but static Ram uses you

01:02:02,120 --> 01:02:08,270
know is it well it's always too small

01:02:04,790 --> 01:02:11,420
right yeah and um what I learned the

01:02:08,270 --> 01:02:13,790
hard way is unless you control where

01:02:11,420 --> 01:02:16,460
your program is landing you put your

01:02:13,790 --> 01:02:18,770
algorithms more often than not start

01:02:16,460 --> 01:02:21,650
using of sort landing in a static Ram

01:02:18,770 --> 01:02:24,110
which well they of course they should be

01:02:21,650 --> 01:02:25,460
landing in read-only memory but the

01:02:24,110 --> 01:02:28,310
question here is how do you control

01:02:25,460 --> 01:02:32,150
where segments of your program land how

01:02:28,310 --> 01:02:34,490
can you how can you influence this or

01:02:32,150 --> 01:02:36,800
how frequently did you end up modifying

01:02:34,490 --> 01:02:38,690
the library the standard library that is

01:02:36,800 --> 01:02:41,420
shipped with your tool chain okay good

01:02:38,690 --> 01:02:44,450
question um so you you really need to

01:02:41,420 --> 01:02:47,030
take ownership of a linker script and of

01:02:44,450 --> 01:02:49,430
the startup code when you when you get

01:02:47,030 --> 01:02:51,050
going because all the magics startup

01:02:49,430 --> 01:02:53,930
code right and the linker script are

01:02:51,050 --> 01:02:55,610
really fine-tuned for not C++ and you're

01:02:53,930 --> 01:02:57,740
gonna do things like turn exceptions off

01:02:55,610 --> 01:03:00,380
great I've recovered all of those

01:02:57,740 --> 01:03:02,240
portions of those sections right inside

01:03:00,380 --> 01:03:03,650
of the linker script but you're gonna

01:03:02,240 --> 01:03:06,620
know where everything is for this

01:03:03,650 --> 01:03:08,420
particular device it's it's a 2,600 page

01:03:06,620 --> 01:03:09,830
manual right in order to know what all

01:03:08,420 --> 01:03:11,090
the registers and whatnot in memory maps

01:03:09,830 --> 01:03:13,640
are but you're gonna spend a lot of time

01:03:11,090 --> 01:03:17,120
in that to know where things are and

01:03:13,640 --> 01:03:19,610
then the other half is well analysis of

01:03:17,120 --> 01:03:21,080
the output by looking at a map file or

01:03:19,610 --> 01:03:22,460
having a tool that looks at the map file

01:03:21,080 --> 01:03:24,170
you'll know whether or not you're going

01:03:22,460 --> 01:03:26,660
to run into things you should not be

01:03:24,170 --> 01:03:30,380
running into so the follow up question

01:03:26,660 --> 01:03:31,760
here is this generally means the moment

01:03:30,380 --> 01:03:35,180
that you start using for example a CD

01:03:31,760 --> 01:03:36,620
vector you end up modifying like 3/4 of

01:03:35,180 --> 01:03:38,030
the standard library

01:03:36,620 --> 01:03:39,860
because well generally you have to

01:03:38,030 --> 01:03:42,500
annotate everything or you have to tell

01:03:39,860 --> 01:03:45,830
linker script somehow where you want the

01:03:42,500 --> 01:03:51,020
pieces of the STL to land yeah so yeah

01:03:45,830 --> 01:03:53,450
so I left this talk at bare-metal we

01:03:51,020 --> 01:03:54,440
don't actually use STD vector fact we

01:03:53,450 --> 01:03:55,820
don't use anything that requires

01:03:54,440 --> 01:03:57,050
allocations because we're gonna have an

01:03:55,820 --> 01:03:58,790
alligator we don't write an alligator

01:03:57,050 --> 01:04:01,780
for it and we don't use a library that

01:03:58,790 --> 01:04:04,760
has a pretend alligator right there so

01:04:01,780 --> 01:04:06,800
all the initialization happens at the

01:04:04,760 --> 01:04:08,930
beginning where we grabs you know static

01:04:06,800 --> 01:04:11,240
bits of pool and we create or own pool

01:04:08,930 --> 01:04:13,130
memory or whatnot but we're not we're

01:04:11,240 --> 01:04:16,550
not allocating memory anywhere else so

01:04:13,130 --> 01:04:19,130
we don't we don't use vector yeah we

01:04:16,550 --> 01:04:20,990
basically use an array like STD array

01:04:19,130 --> 01:04:25,370
but ste or a dependent on the library

01:04:20,990 --> 01:04:28,010
has its own problems so as a comment to

01:04:25,370 --> 01:04:31,700
this question earlier about using

01:04:28,010 --> 01:04:33,770
algorithms we found several bugs in

01:04:31,700 --> 01:04:36,770
algorithms delivered by the standard

01:04:33,770 --> 01:04:39,910
implementation of to to companies like

01:04:36,770 --> 01:04:42,050
for smaller tooling companies or

01:04:39,910 --> 01:04:45,020
companies that made tooling for their

01:04:42,050 --> 01:04:46,910
own CPUs okay so if you do use the

01:04:45,020 --> 01:04:49,160
native maybe add a unit test for the

01:04:46,910 --> 01:04:51,710
stuff you use so actually that's that

01:04:49,160 --> 01:04:54,710
yeah that's really sad and I mean

01:04:51,710 --> 01:04:57,410
obviously if you can use some general

01:04:54,710 --> 01:05:00,440
tooling sure do that but I mean it's not

01:04:57,410 --> 01:05:03,380
always possible no it's not so and when

01:05:00,440 --> 01:05:06,410
it's not possible right your write your

01:05:03,380 --> 01:05:09,140
own algorithm usually there's something

01:05:06,410 --> 01:05:10,940
there the algorithms you know you can go

01:05:09,140 --> 01:05:15,590
and look at Marshalls implementation of

01:05:10,940 --> 01:05:18,050
an algorithm you just pull it on in or

01:05:15,590 --> 01:05:19,220
how to write your own oh yeah so yeah

01:05:18,050 --> 01:05:20,450
that that would be better cuz you're not

01:05:19,220 --> 01:05:21,560
gonna use all the algorithms you're

01:05:20,450 --> 01:05:23,450
gonna have some subset that you'll use

01:05:21,560 --> 01:05:31,370
but use something that's already

01:05:23,450 --> 01:05:33,950
implemented it I'm here all day so our

01:05:31,370 --> 01:05:37,820
key Ti and exceptions where do they fit

01:05:33,950 --> 01:05:40,660
in this world return both are TTI and

01:05:37,820 --> 01:05:40,660
exceptions off immediately

01:05:41,619 --> 01:05:50,450
we don't exist could you buck-toothed

01:05:46,519 --> 01:05:54,079
right send a message just before state

01:05:50,450 --> 01:05:57,469
machine diagram so I'd like to ask type

01:05:54,079 --> 01:06:11,719
of state or machine type up send a

01:05:57,469 --> 01:06:13,749
message there no no no just maybe two or

01:06:11,719 --> 01:06:13,749
three

01:06:15,549 --> 01:06:23,930
so I mean send a message to some command

01:06:20,319 --> 01:06:29,619
so commander RA to you introduce a some

01:06:23,930 --> 01:06:34,609
type maybe two or three throw it back oh

01:06:29,619 --> 01:06:39,019
yeah yeah yeah the send a message what

01:06:34,609 --> 01:06:43,039
is the type of sentiments is so this you

01:06:39,019 --> 01:06:44,930
introduce three structures yes they have

01:06:43,039 --> 01:06:48,079
different types the send method type is

01:06:44,930 --> 01:06:50,329
template or some something in type you

01:06:48,079 --> 01:06:52,249
aged no okay good question so it's n

01:06:50,329 --> 01:06:57,410
type same message is actually a

01:06:52,249 --> 01:06:59,239
templated function okay and I've given a

01:06:57,410 --> 01:07:00,769
variety different talks in the past that

01:06:59,239 --> 01:07:02,869
talk about serialization techniques

01:07:00,769 --> 01:07:05,420
using structs and things like this with

01:07:02,869 --> 01:07:08,719
the send message you can find them like

01:07:05,420 --> 01:07:10,160
CPP now there is a talk on fusion where

01:07:08,719 --> 01:07:12,769
I talk about this technique it is also a

01:07:10,160 --> 01:07:15,019
talk on modern techniques which is a

01:07:12,769 --> 01:07:19,249
three hour talk where I talk about this

01:07:15,019 --> 01:07:21,170
technique but you only have to write you

01:07:19,249 --> 01:07:25,369
only have to write the serializers one

01:07:21,170 --> 01:07:30,709
time and and I don't mean like one time

01:07:25,369 --> 01:07:33,859
per message type but per atom type so so

01:07:30,709 --> 01:07:36,349
the question so if the send message

01:07:33,859 --> 01:07:41,509
maybe send a message sending the message

01:07:36,349 --> 01:07:44,569
immediately but if we need to message

01:07:41,509 --> 01:07:47,900
and cue the message some container it

01:07:44,569 --> 01:07:50,569
that works where oh yeah so the how to

01:07:47,900 --> 01:07:52,249
include easier genius

01:07:50,569 --> 01:07:54,199
yeah you have to you have to use type

01:07:52,249 --> 01:07:54,800
erasure okay and then pull it back out

01:07:54,199 --> 01:07:59,030
so

01:07:54,800 --> 01:08:04,010
I have one idea so you introduce a boost

01:07:59,030 --> 01:08:07,700
SMA perhaps differing we bent could help

01:08:04,010 --> 01:08:11,030
so you have to have an any type thing

01:08:07,700 --> 01:08:16,490
with that the diff are different message

01:08:11,030 --> 01:08:21,100
is not invoke message immediately so

01:08:16,490 --> 01:08:24,830
instead of sending message you can write

01:08:21,100 --> 01:08:27,260
define yeah so we don't so how we

01:08:24,830 --> 01:08:30,020
implement this is we actually don't

01:08:27,260 --> 01:08:32,450
defer the message we send the message

01:08:30,020 --> 01:08:34,760
and it goes through serialization again

01:08:32,450 --> 01:08:38,960
and there's some number of bits that are

01:08:34,760 --> 01:08:41,630
waiting on probably a DMA area for them

01:08:38,960 --> 01:08:44,810
to get sent out to the device and so we

01:08:41,630 --> 01:08:47,510
don't actually queue up not yes it's

01:08:44,810 --> 01:08:48,740
type of race types we actually at that

01:08:47,510 --> 01:08:50,480
moment when it gets called do the

01:08:48,740 --> 01:08:51,890
serialization so it's ready to go out

01:08:50,480 --> 01:08:55,810
and they're just saying this I have a

01:08:51,890 --> 01:08:55,810
DMA buffer somewhere okay thank you

01:08:56,560 --> 01:09:05,009
alright looks like we're done

01:08:59,149 --> 01:09:05,009

YouTube URL: https://www.youtube.com/watch?v=LfRLQ7IChtg


