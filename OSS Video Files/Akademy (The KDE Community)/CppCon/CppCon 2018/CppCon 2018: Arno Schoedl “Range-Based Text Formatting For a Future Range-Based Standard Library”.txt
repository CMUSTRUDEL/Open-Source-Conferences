Title: CppCon 2018: Arno Schoedl “Range-Based Text Formatting For a Future Range-Based Standard Library”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Text formatting has been a favorite problem of C++ library authors for a long time. The standard C++ iostreams have been criticized for being difficult to use due to their statefulness and slow due to runtime polymorphism. Despite its age, printf is still popular because of simplicity and speed. The Boost library offers two more alternatives, Boost.Format and Boost.LexicalCast. And finally, the P0645 standard proposal sponsored by Facebook is currently finding its way through the C++ committee. 

All these approaches are still firmly based on standard containers and iterators. But the Standard Library is changing radically with the advent of ranges, range adaptors and functional style programming in C++. Generating optimized code with metaprogramming is becoming standard fare. 

In this talk, I want to convince you that the combination of ranges with a bit of metaprogramming makes for a very elegant solution to the text formatting problem. We introduce a form of ranges with internal iteration, which are generating their elements one by one rather than exposing external iterators. We can use these generator ranges to represent the values to be formatted, conceptually turning them into lazily evaluated strings. These can be used just like regular strings are used today: in function returns; as standard algorithm input; embedded into other, equally lazily evaluated strings; and so on, before they are finally expanded for display. By choosing the right interfaces, we can optimize this expansion at compile-time, making it no less pretty to write, but more efficient to expand than any text formatting approaches that rely on format strings that must be parsed at runtime. 

I believe that this approach is the natural extension of a range-based future standard library to text formatting. 
— 

Arno Schoedl, think-cell
CTO

Arno is the CTO of think-cell Software GmbH. He is responsible for the design, architecture and development of all their software products, and the evolution of the company's open source C++ library. Before founding think-cell, Arno worked at Microsoft Research and McKinsey. Arno studied computer science and management and holds a Ph.D. from the Georgia Institute of Technology with a specialization in Computer Graphics.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:05,520
thank you very much for coming I'm

00:00:02,340 --> 00:00:07,890
Arnaud from thing cell and I'll be

00:00:05,520 --> 00:00:10,110
talking about how we do range formatting

00:00:07,890 --> 00:00:13,620
but how we do text formatting at think

00:00:10,110 --> 00:00:16,440
so and we have a range library so this

00:00:13,620 --> 00:00:18,570
could be potentially a way to do text

00:00:16,440 --> 00:00:19,199
formatting in a future range based

00:00:18,570 --> 00:00:21,420
library

00:00:19,199 --> 00:00:24,449
now of course text formatting is

00:00:21,420 --> 00:00:26,010
everywhere and has been tried many times

00:00:24,449 --> 00:00:28,500
before many different libraries many

00:00:26,010 --> 00:00:30,449
different approaches here is yet another

00:00:28,500 --> 00:00:32,700
one of course this one is very special

00:00:30,449 --> 00:00:34,469
because this is the very last one and

00:00:32,700 --> 00:00:40,620
the very best one and I'm sure you guys

00:00:34,469 --> 00:00:41,280
know the xkcd comic right okay so what

00:00:40,620 --> 00:00:43,559
is range

00:00:41,280 --> 00:00:45,629
what is text formatting you have a bunch

00:00:43,559 --> 00:00:47,760
of components in that you want to build

00:00:45,629 --> 00:00:49,770
a string off with their positions and

00:00:47,760 --> 00:00:51,420
for some of these components they may

00:00:49,770 --> 00:00:53,219
not already be strings they may be data

00:00:51,420 --> 00:00:55,020
and you have some parameters that

00:00:53,219 --> 00:00:58,260
control how they are converted into

00:00:55,020 --> 00:01:00,800
strings and they're all being formatted

00:00:58,260 --> 00:01:06,780
put together and the output is a string

00:01:00,800 --> 00:01:10,470
okay now pretty simple we have to pick

00:01:06,780 --> 00:01:15,060
one of the possible syntaxes for

00:01:10,470 --> 00:01:17,689
building our library and one option that

00:01:15,060 --> 00:01:21,990
is popular of course our format strings

00:01:17,689 --> 00:01:25,049
so printf has been doing it you have you

00:01:21,990 --> 00:01:26,790
all know the percent rotation and more

00:01:25,049 --> 00:01:31,290
modern libraries for example the abseil

00:01:26,790 --> 00:01:33,600
library of google they also have format

00:01:31,290 --> 00:01:36,500
strings and absolute library actually

00:01:33,600 --> 00:01:39,750
uses the printf syntax the percent X and

00:01:36,500 --> 00:01:41,100
there's also currently a string

00:01:39,750 --> 00:01:42,689
formatting library that finds its way

00:01:41,100 --> 00:01:45,479
through the standard committee so there

00:01:42,689 --> 00:01:49,070
is already something on its way to

00:01:45,479 --> 00:01:52,110
become a C++ standard the p 0 64 5 paper

00:01:49,070 --> 00:01:53,909
it uses the python syntax and it seems

00:01:52,110 --> 00:01:56,520
like the python syntax is is becoming

00:01:53,909 --> 00:01:58,860
more and more popular now that's one way

00:01:56,520 --> 00:02:00,930
to do it is format strings there we

00:01:58,860 --> 00:02:02,310
essentially assign a special meaning to

00:02:00,930 --> 00:02:05,820
the string literals

00:02:02,310 --> 00:02:08,910
now what else can you do well you can

00:02:05,820 --> 00:02:12,750
use not a format string or just C++ I

00:02:08,910 --> 00:02:13,650
want to call it the probably most well

00:02:12,750 --> 00:02:16,140
known

00:02:13,650 --> 00:02:19,680
way to do it without format strings is

00:02:16,140 --> 00:02:23,700
our the i/o streams the standard way to

00:02:19,680 --> 00:02:26,400
do it since C++ 98 or something but I

00:02:23,700 --> 00:02:28,740
also want to include just plain vanilla

00:02:26,400 --> 00:02:33,300
string concatenation that's also a way

00:02:28,740 --> 00:02:36,320
to format a string okay let's go through

00:02:33,300 --> 00:02:39,000
the options and see what we want to pick

00:02:36,320 --> 00:02:41,730
now let's go to the format string first

00:02:39,000 --> 00:02:44,550
what's good about format strings you

00:02:41,730 --> 00:02:46,200
have in the format string you get a

00:02:44,550 --> 00:02:52,440
pretty good idea of what the final

00:02:46,200 --> 00:02:54,750
string looks like there used to be the

00:02:52,440 --> 00:02:57,600
counter argument against format strings

00:02:54,750 --> 00:02:59,970
that they can't be validated that you

00:02:57,600 --> 00:03:01,920
cannot ensure that the actual percent

00:02:59,970 --> 00:03:03,780
thing that you have in your string

00:03:01,920 --> 00:03:06,570
matches the type well that's no longer

00:03:03,780 --> 00:03:08,400
the case with constant expert strings we

00:03:06,570 --> 00:03:10,860
can actually do compile time checking

00:03:08,400 --> 00:03:12,209
and the more modern libraries the apps

00:03:10,860 --> 00:03:13,560
our library and the the formatting

00:03:12,209 --> 00:03:16,230
library appear zero six four five

00:03:13,560 --> 00:03:18,480
they're actually doing it of course um

00:03:16,230 --> 00:03:20,340
with the format strings you have the

00:03:18,480 --> 00:03:22,050
option to actually pick it at runtime

00:03:20,340 --> 00:03:24,590
and then you cannot do the validation

00:03:22,050 --> 00:03:28,470
that's fine I guess it's to be expected

00:03:24,590 --> 00:03:32,550
but I have a few pet peeves with form

00:03:28,470 --> 00:03:35,970
strings first of all you have to escape

00:03:32,550 --> 00:03:40,290
your string okay so far so good you have

00:03:35,970 --> 00:03:43,290
to remember doing it hmm we also kind of

00:03:40,290 --> 00:03:45,900
have a special language for describing

00:03:43,290 --> 00:03:48,600
the parameters and we already have a

00:03:45,900 --> 00:03:51,989
language there's already C++ now you are

00:03:48,600 --> 00:03:53,820
putting that that formant notation into

00:03:51,989 --> 00:03:56,010
your literals which is yet another

00:03:53,820 --> 00:03:59,940
language it seems pretty straightforward

00:03:56,010 --> 00:04:01,620
to use C++ instead this is more

00:03:59,940 --> 00:04:04,769
problematic if you have user-defined

00:04:01,620 --> 00:04:07,410
types because if you are many times you

00:04:04,769 --> 00:04:09,959
want to ad hoc format some object in

00:04:07,410 --> 00:04:12,299
your application and if you want to

00:04:09,959 --> 00:04:14,580
control how it's being formatted through

00:04:12,299 --> 00:04:16,410
a format string you have to parse that

00:04:14,580 --> 00:04:17,760
little string snippet that you have in

00:04:16,410 --> 00:04:19,859
your format string which is a bit

00:04:17,760 --> 00:04:21,330
awkward I mean I'm just wanna you know

00:04:19,859 --> 00:04:25,140
do I work I don't want to write process

00:04:21,330 --> 00:04:26,139
right now here's what I think is the

00:04:25,140 --> 00:04:29,439
biggest problem

00:04:26,139 --> 00:04:32,139
now when you have a bunch of strengths

00:04:29,439 --> 00:04:34,150
that you want to concatenate it is very

00:04:32,139 --> 00:04:37,419
natural to just port one string after

00:04:34,150 --> 00:04:39,639
the other right you wouldn't write % s %

00:04:37,419 --> 00:04:41,110
s % s % s and then put all the strings

00:04:39,639 --> 00:04:44,169
there and then you count that the number

00:04:41,110 --> 00:04:47,319
actually match but what if you want to

00:04:44,169 --> 00:04:50,979
insert a single number in there you want

00:04:47,319 --> 00:04:53,650
to form it a little bit this would

00:04:50,979 --> 00:04:55,689
either require to do some hybrid thing

00:04:53,650 --> 00:04:57,009
you just have some some strings snippet

00:04:55,689 --> 00:04:59,050
in the middle that you format and

00:04:57,009 --> 00:05:03,550
everything else isn't formatted which is

00:04:59,050 --> 00:05:05,349
a bit weird or you make that non

00:05:03,550 --> 00:05:08,080
incremental change of turning everything

00:05:05,349 --> 00:05:10,599
into a for mr and that's that's my

00:05:08,080 --> 00:05:12,639
biggest problem and that bad one

00:05:10,599 --> 00:05:17,139
actually bugs us or bugged us when we

00:05:12,639 --> 00:05:19,839
were using fana strings now there are

00:05:17,139 --> 00:05:22,300
one area where you really can't do

00:05:19,839 --> 00:05:24,430
without format strings when you're

00:05:22,300 --> 00:05:26,499
translating a program as you do with

00:05:24,430 --> 00:05:27,099
every bigger project into different

00:05:26,499 --> 00:05:28,870
languages

00:05:27,099 --> 00:05:30,219
you're probably not going to have the

00:05:28,870 --> 00:05:32,409
resources in a house to do the

00:05:30,219 --> 00:05:34,449
translation usually give this out to a

00:05:32,409 --> 00:05:37,659
translation agency and you communicate

00:05:34,449 --> 00:05:39,310
with them using some form of excellence

00:05:37,659 --> 00:05:42,009
which is like the standard format that

00:05:39,310 --> 00:05:43,029
they use to basically you deliver the

00:05:42,009 --> 00:05:47,680
text to them they give you the

00:05:43,029 --> 00:05:49,899
translation back and of course your text

00:05:47,680 --> 00:05:51,629
actually may contain placeholders you

00:05:49,899 --> 00:05:53,979
may gonna write something like this and

00:05:51,629 --> 00:05:55,899
you have to pass it to them if you get

00:05:53,979 --> 00:06:00,279
back to you so there you must use format

00:05:55,899 --> 00:06:03,129
strings but it turns out in this case

00:06:00,279 --> 00:06:06,089
it's actually not a terribly good idea

00:06:03,129 --> 00:06:09,699
to include all the formatting parameters

00:06:06,089 --> 00:06:11,409
into your format string because the you

00:06:09,699 --> 00:06:14,259
basically only want the translation

00:06:11,409 --> 00:06:17,169
agency to mess with your code as much as

00:06:14,259 --> 00:06:18,969
needed which is they can resort the

00:06:17,169 --> 00:06:21,580
order of parameters this happens maybe

00:06:18,969 --> 00:06:23,770
in some languages that's fine but you

00:06:21,580 --> 00:06:25,899
don't want them to determine how your

00:06:23,770 --> 00:06:28,629
date is formatted or whether you use a

00:06:25,899 --> 00:06:30,039
comma or a period you get that kind of

00:06:28,629 --> 00:06:32,110
control from elsewhere you get it from

00:06:30,039 --> 00:06:33,879
the operating system settings or you

00:06:32,110 --> 00:06:34,959
maybe make up a database so the map

00:06:33,879 --> 00:06:36,190
where you say ok if you have this

00:06:34,959 --> 00:06:38,589
language we're gonna use these

00:06:36,190 --> 00:06:39,610
parameters or these these formats for

00:06:38,589 --> 00:06:41,710
say a date

00:06:39,610 --> 00:06:42,669
you don't want that leave that to the

00:06:41,710 --> 00:06:45,310
translation agency

00:06:42,669 --> 00:06:48,669
so really to dumb down your vomit string

00:06:45,310 --> 00:06:51,729
to just positional arguments it's

00:06:48,669 --> 00:06:54,340
probably a good idea let's go to the

00:06:51,729 --> 00:06:55,960
other choice no format strings and the

00:06:54,340 --> 00:06:59,409
first one I'm talking about this i/o

00:06:55,960 --> 00:07:03,930
streams of course no one likes IO

00:06:59,409 --> 00:07:06,250
streams they abuse the shift operator

00:07:03,930 --> 00:07:07,300
that's one thing maybe that's excusable

00:07:06,250 --> 00:07:10,020
because they didn't have very attic

00:07:07,300 --> 00:07:12,159
templates so that's okay but they also

00:07:10,020 --> 00:07:13,629
they when you want to control the

00:07:12,159 --> 00:07:15,430
formatting you have to insert these

00:07:13,629 --> 00:07:17,500
state for manipulators you have to say

00:07:15,430 --> 00:07:21,189
set precision something and then you

00:07:17,500 --> 00:07:23,590
actually give it the data okay well the

00:07:21,189 --> 00:07:25,870
problem is if you take that stream and

00:07:23,590 --> 00:07:28,629
then pass it around your program in

00:07:25,870 --> 00:07:31,000
function calls to successively just

00:07:28,629 --> 00:07:33,009
incrementally add to that stream you

00:07:31,000 --> 00:07:34,750
never know which state that thing is in

00:07:33,009 --> 00:07:36,849
and either you have a really strong

00:07:34,750 --> 00:07:39,279
discipline of making sure that whenever

00:07:36,849 --> 00:07:41,319
you passing it it has the right stage or

00:07:39,279 --> 00:07:44,529
you have to right reset the same all the

00:07:41,319 --> 00:07:46,419
time which is also clumsy and and also

00:07:44,529 --> 00:07:48,520
they gave you this extra headache that

00:07:46,419 --> 00:07:50,620
set precision for example applies to all

00:07:48,520 --> 00:07:52,900
the format's or all the objects that

00:07:50,620 --> 00:07:54,190
comes afterwards said whip doesn't it

00:07:52,900 --> 00:07:56,349
forgets it right after it's been used

00:07:54,190 --> 00:07:59,229
once it's there's a big head

00:07:56,349 --> 00:08:01,000
that didn't look like that it's also

00:07:59,229 --> 00:08:04,690
pretty slow because underneath that

00:08:01,000 --> 00:08:06,909
stream there is a buffer which is tied

00:08:04,690 --> 00:08:09,189
to the stream using virtual functions

00:08:06,909 --> 00:08:12,069
that's not great and then at the very

00:08:09,189 --> 00:08:14,080
end the stream just holds the string and

00:08:12,069 --> 00:08:15,729
sort of some maybe some some sequence of

00:08:14,080 --> 00:08:17,439
buffers and if you want to string out of

00:08:15,729 --> 00:08:19,300
it a consecutive piece of memory you

00:08:17,439 --> 00:08:21,639
have to copy everything again so the the

00:08:19,300 --> 00:08:26,589
string call will will copy everything

00:08:21,639 --> 00:08:29,589
again all not great let's go to the

00:08:26,589 --> 00:08:31,629
other option string concatenation okay

00:08:29,589 --> 00:08:34,000
here we have a different abuse of

00:08:31,629 --> 00:08:36,099
operator overloading I think the arm

00:08:34,000 --> 00:08:40,240
just mentioned it in his talk the the

00:08:36,099 --> 00:08:43,209
plus is not really a plus you don't have

00:08:40,240 --> 00:08:45,790
any formatting options well then so C++

00:08:43,209 --> 00:08:48,940
11 gave us these very simple to string

00:08:45,790 --> 00:08:50,800
functions but there there's nothing in

00:08:48,940 --> 00:08:52,670
terms of parameterizing how you want

00:08:50,800 --> 00:08:55,550
that to string to be done

00:08:52,670 --> 00:08:57,650
and they're awful slow because they are

00:08:55,550 --> 00:08:58,910
generating first little strings and then

00:08:57,650 --> 00:09:00,830
they copy the strings together so you're

00:08:58,910 --> 00:09:05,780
generating you're doing a lot of heap

00:09:00,830 --> 00:09:08,270
allocations but I actually like the

00:09:05,780 --> 00:09:10,450
syntax of it it's kind of the essence of

00:09:08,270 --> 00:09:13,070
formatting build little snippets and

00:09:10,450 --> 00:09:14,920
then you put them together into your

00:09:13,070 --> 00:09:19,490
string and these snippets may be

00:09:14,920 --> 00:09:20,990
formatted versions of your data do thing

00:09:19,490 --> 00:09:22,670
doing user extension which i think is

00:09:20,990 --> 00:09:24,890
very important it's very simple you

00:09:22,670 --> 00:09:26,300
simply do a function call it just puts

00:09:24,890 --> 00:09:28,040
together from substring and then you

00:09:26,300 --> 00:09:31,970
insert the substring into your bigger

00:09:28,040 --> 00:09:34,580
string so what we will do is try to kind

00:09:31,970 --> 00:09:37,220
of stick to that syntax and try to

00:09:34,580 --> 00:09:41,320
overcome all the weaknesses with ranges

00:09:37,220 --> 00:09:46,070
so we can actually program in that style

00:09:41,320 --> 00:09:50,320
first of all to see about ranges who

00:09:46,070 --> 00:09:55,450
knows the range based for loop everyone

00:09:50,320 --> 00:09:59,930
who knows ranges TS okay if you were

00:09:55,450 --> 00:10:03,590
needless library mm-hmm

00:09:59,930 --> 00:10:07,070
who uses ranges already every day oh my

00:10:03,590 --> 00:10:10,250
god you should you really should so I'm

00:10:07,070 --> 00:10:11,990
not going to ask what you're using you

00:10:10,250 --> 00:10:16,520
you really should consider using ranges

00:10:11,990 --> 00:10:18,710
so here's the essence of it iterators

00:10:16,520 --> 00:10:20,540
come usually in Paris you have a

00:10:18,710 --> 00:10:22,280
beginning an end and there's no good

00:10:20,540 --> 00:10:24,170
reason why this beginning ends are

00:10:22,280 --> 00:10:26,210
really two separate objects you've just

00:10:24,170 --> 00:10:28,550
got to mess it up so you want to put

00:10:26,210 --> 00:10:31,520
that into one object that's that's the

00:10:28,550 --> 00:10:33,560
goal so a range is going to be anything

00:10:31,520 --> 00:10:37,010
and your object that has begin at an end

00:10:33,560 --> 00:10:39,680
where you can iterate over so that maybe

00:10:37,010 --> 00:10:42,770
containers as a single object vectors or

00:10:39,680 --> 00:10:45,620
basic strings or whatever but that also

00:10:42,770 --> 00:10:48,230
may be just pairs of iterators and they

00:10:45,620 --> 00:10:49,580
are now called views for ranges views

00:10:48,230 --> 00:10:51,320
because they're not owning their

00:10:49,580 --> 00:10:55,000
elements they are just referencing them

00:10:51,320 --> 00:10:57,260
just like pairs of iterators did before

00:10:55,000 --> 00:10:58,880
ranges are a lot more interesting

00:10:57,260 --> 00:11:01,790
because they actually can do lazy

00:10:58,880 --> 00:11:03,740
calculations that means when i'm calling

00:11:01,790 --> 00:11:06,290
in our library TC filter with range on

00:11:03,740 --> 00:11:08,509
the predicate this cat

00:11:06,290 --> 00:11:10,339
the range and the predicate into an

00:11:08,509 --> 00:11:13,369
object but it doesn't do anything with

00:11:10,339 --> 00:11:16,309
yet it just captures the the arguments

00:11:13,369 --> 00:11:18,559
and only then when you are iterating

00:11:16,309 --> 00:11:21,049
over that object then the filter will

00:11:18,559 --> 00:11:23,629
actually start will skip the elements

00:11:21,049 --> 00:11:26,149
that don't satisfy the predicate so you

00:11:23,629 --> 00:11:27,229
do the work as when you need it and as

00:11:26,149 --> 00:11:28,759
much as you need it if you don't need

00:11:27,229 --> 00:11:30,729
the first element then you're only gonna

00:11:28,759 --> 00:11:33,019
do the work for the first element

00:11:30,729 --> 00:11:35,779
why do I think I know something about

00:11:33,019 --> 00:11:38,689
ranges we've been building a range

00:11:35,779 --> 00:11:40,759
library for a long time say oh my god

00:11:38,689 --> 00:11:43,939
12 years 13 years something like that

00:11:40,759 --> 00:11:45,709
and we have along with that library we

00:11:43,939 --> 00:11:49,369
have about 1 million lines of production

00:11:45,709 --> 00:11:50,449
code that use the library and usually

00:11:49,369 --> 00:11:52,429
when you build a library you have this

00:11:50,449 --> 00:11:54,439
chicken and egg problem you have to

00:11:52,429 --> 00:11:57,709
learn to learn a good design for your

00:11:54,439 --> 00:11:59,809
library you have to use the library now

00:11:57,709 --> 00:12:01,850
once you got a lot of use for your

00:11:59,809 --> 00:12:03,379
library then you can't change the

00:12:01,850 --> 00:12:04,639
library anymore because people are

00:12:03,379 --> 00:12:06,679
screaming when you change the library

00:12:04,639 --> 00:12:09,289
you have that in deep with it for the

00:12:06,679 --> 00:12:14,149
standard library if you have that in in

00:12:09,289 --> 00:12:16,189
large large scale this problem we are

00:12:14,149 --> 00:12:19,579
you have the luxurious position to avoid

00:12:16,189 --> 00:12:21,709
it because whenever we do change we

00:12:19,579 --> 00:12:23,439
change our range library we can actually

00:12:21,709 --> 00:12:26,600
change our production code with it and

00:12:23,439 --> 00:12:29,269
we actually have someone just dedicated

00:12:26,600 --> 00:12:30,859
to refactoring code so whenever we are

00:12:29,269 --> 00:12:32,629
changing the range libraries have some

00:12:30,859 --> 00:12:33,679
new idea of how to do it better then

00:12:32,629 --> 00:12:36,559
we're just going to change all our

00:12:33,679 --> 00:12:38,480
production code to reflect that new idea

00:12:36,559 --> 00:12:40,789
in the in the range library and I think

00:12:38,480 --> 00:12:43,220
that way over time we got a pretty good

00:12:40,789 --> 00:12:44,689
mature library and we have a lot of

00:12:43,220 --> 00:12:45,699
experience of what works and what

00:12:44,689 --> 00:12:48,739
doesn't

00:12:45,699 --> 00:12:51,259
now when you're starting to use ranges

00:12:48,739 --> 00:12:52,850
for text probably the first thing you

00:12:51,259 --> 00:12:55,159
want to do is you want to get rid of all

00:12:52,850 --> 00:12:57,379
these member function calls of basic

00:12:55,159 --> 00:12:59,659
string so basic string is the shadow

00:12:57,379 --> 00:13:03,139
world where everyone is doing it erases

00:12:59,659 --> 00:13:05,329
and except for basic string they are

00:13:03,139 --> 00:13:08,089
doing indices and member functions and

00:13:05,329 --> 00:13:09,649
the first thing we did was get rid of

00:13:08,089 --> 00:13:12,379
all that stuff you want to have a

00:13:09,649 --> 00:13:13,759
uniform way of treating ranges it

00:13:12,379 --> 00:13:15,529
doesn't really matter it whether it's a

00:13:13,759 --> 00:13:16,879
character range or whether it's a range

00:13:15,529 --> 00:13:18,830
of numbers you are using the same

00:13:16,879 --> 00:13:22,170
algorithms on either one

00:13:18,830 --> 00:13:24,060
this also allows you quite frequently if

00:13:22,170 --> 00:13:25,650
you're interacting with some operating

00:13:24,060 --> 00:13:28,200
system for example if you do windows on

00:13:25,650 --> 00:13:32,730
Comm it insists on a particular string

00:13:28,200 --> 00:13:34,620
type say BSC are now with ranges you can

00:13:32,730 --> 00:13:37,590
now wrap that string type into an

00:13:34,620 --> 00:13:39,150
interface that is just a range interface

00:13:37,590 --> 00:13:40,530
and you can again use the same

00:13:39,150 --> 00:13:42,980
algorithms that you want to use with

00:13:40,530 --> 00:13:42,980
everything else

00:13:43,520 --> 00:13:52,440
C++ 17 just introduced introduced basic

00:13:48,300 --> 00:13:55,140
string view now basic stream view goes

00:13:52,440 --> 00:13:58,770
exactly the opposite direction or at

00:13:55,140 --> 00:14:01,470
least parts of it so you have the design

00:13:58,770 --> 00:14:03,240
goal of basic string view was be

00:14:01,470 --> 00:14:05,250
compatible with basic string this thing

00:14:03,240 --> 00:14:08,220
must be a drop-in replacement for basic

00:14:05,250 --> 00:14:11,430
string and now everyone says C fast fast

00:14:08,220 --> 00:14:13,980
it's hard to teach well basically basic

00:14:11,430 --> 00:14:15,870
string view is fine just don't use all

00:14:13,980 --> 00:14:21,060
that member functions stuff would be my

00:14:15,870 --> 00:14:24,720
advice all right now let's start doing

00:14:21,060 --> 00:14:26,280
some text formatting with ranges every

00:14:24,720 --> 00:14:28,590
range library has some sort of

00:14:26,280 --> 00:14:31,800
concatenation so we'll just stick to

00:14:28,590 --> 00:14:34,320
that so we have a concat in range v3

00:14:31,800 --> 00:14:36,090
it's named the same we kind of make the

00:14:34,320 --> 00:14:39,150
may the names equal to minimize

00:14:36,090 --> 00:14:42,930
confusion and it's it's just

00:14:39,150 --> 00:14:45,860
concatenating these two strings and now

00:14:42,930 --> 00:14:50,520
of course you want to do some sort of

00:14:45,860 --> 00:14:53,310
formatting so what do you do well we

00:14:50,520 --> 00:14:55,500
just added a function that or functions

00:14:53,310 --> 00:14:58,080
that do the formatting you give the data

00:14:55,500 --> 00:15:00,150
to it and some parameters say here it's

00:14:58,080 --> 00:15:03,930
a double and you want two decimal digits

00:15:00,150 --> 00:15:06,690
and it will return a range of characters

00:15:03,930 --> 00:15:11,520
that is that number formatted in the way

00:15:06,690 --> 00:15:14,280
you want it just to keep in mind this is

00:15:11,520 --> 00:15:19,220
not like iostream you have to explicitly

00:15:14,280 --> 00:15:22,200
turn your data into strings because

00:15:19,220 --> 00:15:24,810
ranges can be anything the ranges could

00:15:22,200 --> 00:15:27,000
all be a range of bubbles so you don't

00:15:24,810 --> 00:15:30,030
want to be confused about what type of

00:15:27,000 --> 00:15:32,250
range you currently have so we make an

00:15:30,030 --> 00:15:34,260
explicit call to say okay

00:15:32,250 --> 00:15:38,370
this is no longer a double this is now a

00:15:34,260 --> 00:15:41,760
range of characters so they just put in

00:15:38,370 --> 00:15:43,590
an F in there one compile there's no

00:15:41,760 --> 00:15:48,000
need for a special file net function you

00:15:43,590 --> 00:15:51,030
just use concat extensive extending it

00:15:48,000 --> 00:15:53,370
with user-defined formats is trivial to

00:15:51,030 --> 00:15:58,890
just write a function that returns a

00:15:53,370 --> 00:16:01,410
range and all the range algorithms still

00:15:58,890 --> 00:16:03,660
work you can iterate over that stuff you

00:16:01,410 --> 00:16:09,860
can call any algorithms it all just

00:16:03,660 --> 00:16:12,600
works now I was so far pretty shy about

00:16:09,860 --> 00:16:14,460
say talking about the types that are

00:16:12,600 --> 00:16:16,770
being returned it was kind of hand

00:16:14,460 --> 00:16:19,920
waving it's you write that expression

00:16:16,770 --> 00:16:21,780
and it somehow works eventually you will

00:16:19,920 --> 00:16:25,230
want to put this stuff into a container

00:16:21,780 --> 00:16:26,610
so how do we do that well let's look

00:16:25,230 --> 00:16:28,920
what we already have from the standard

00:16:26,610 --> 00:16:30,480
library stirred string with an empty

00:16:28,920 --> 00:16:33,540
constructor of course given an empty

00:16:30,480 --> 00:16:36,180
string and if you put on the right hand

00:16:33,540 --> 00:16:40,020
side something that's literal or already

00:16:36,180 --> 00:16:41,580
acids train-car pointer and it will

00:16:40,020 --> 00:16:43,020
actually copy that car pointer so the

00:16:41,580 --> 00:16:44,610
idea start of the right as long as the

00:16:43,020 --> 00:16:47,010
right-hand side is something string like

00:16:44,610 --> 00:16:49,800
will construct a string from that well

00:16:47,010 --> 00:16:51,990
let's stick to that so we just say okay

00:16:49,800 --> 00:16:54,360
we just introduced new constructors in

00:16:51,990 --> 00:16:57,390
this dead string that on the right hand

00:16:54,360 --> 00:16:59,790
side take anything character range like

00:16:57,390 --> 00:17:01,560
so you can stick in a second there or

00:16:59,790 --> 00:17:03,810
the concat with multiple components both

00:17:01,560 --> 00:17:05,610
our character ranges and you construct a

00:17:03,810 --> 00:17:07,620
string from that and then mark it up

00:17:05,610 --> 00:17:11,640
with suggested just to indicate that it

00:17:07,620 --> 00:17:13,170
does not compile what we did and you you

00:17:11,640 --> 00:17:16,020
may or may not like it

00:17:13,170 --> 00:17:17,579
we added some tactic sugar so that you

00:17:16,020 --> 00:17:19,650
don't have to write the concat if you

00:17:17,579 --> 00:17:21,449
just have a very added constructor that

00:17:19,650 --> 00:17:24,569
takes multiple arguments it's kind of

00:17:21,449 --> 00:17:28,290
implied that you're going to concatenate

00:17:24,569 --> 00:17:30,360
all the all the arguments it's kind of

00:17:28,290 --> 00:17:32,970
like a like a linear extension of 0

00:17:30,360 --> 00:17:34,920
arguments is empty one argument is that

00:17:32,970 --> 00:17:37,430
string well two arguments what's that

00:17:34,920 --> 00:17:41,400
string one after the other

00:17:37,430 --> 00:17:43,110
now what about existing constructors of

00:17:41,400 --> 00:17:44,730
stood string right here was pretty

00:17:43,110 --> 00:17:45,840
liberal and saying oh where happens to

00:17:44,730 --> 00:17:48,210
element constructor on this

00:17:45,840 --> 00:17:50,070
that string I'm gonna use it again for

00:17:48,210 --> 00:17:55,020
something else but we already have

00:17:50,070 --> 00:17:55,669
constructors let's see so what do they

00:17:55,020 --> 00:17:58,919
do

00:17:55,669 --> 00:18:01,140
the first one is undefined behavior it

00:17:58,919 --> 00:18:04,590
because it says take the first three

00:18:01,140 --> 00:18:06,570
elements of the buffer the a buffer at

00:18:04,590 --> 00:18:09,510
the a buffer only has two elements a and

00:18:06,570 --> 00:18:13,740
a null terminator so that's if I behave

00:18:09,510 --> 00:18:16,140
about alright ah this actually because I

00:18:13,740 --> 00:18:20,399
got the number of the order of arguments

00:18:16,140 --> 00:18:22,470
wrong at 65 times control-c this may or

00:18:20,399 --> 00:18:26,700
may not be your con intent in this

00:18:22,470 --> 00:18:31,740
situation now okay this time this thing

00:18:26,700 --> 00:18:33,270
adds three times the a okay but to be

00:18:31,740 --> 00:18:35,880
honest I mean deprecated all that stuff

00:18:33,270 --> 00:18:38,490
you can describe what you want in your

00:18:35,880 --> 00:18:40,740
string in a much better way off by

00:18:38,490 --> 00:18:45,570
defining a range and then copying that

00:18:40,740 --> 00:18:47,610
range into the string of course we can't

00:18:45,570 --> 00:18:49,649
just go or we did not just go through

00:18:47,610 --> 00:18:51,929
the standard library and just hack out

00:18:49,649 --> 00:18:54,960
all the constructors right and you're

00:18:51,929 --> 00:18:57,059
not quite that brutal so what we did in

00:18:54,960 --> 00:19:00,090
the library is we kind of invent

00:18:57,059 --> 00:19:02,760
invented this explicit cast that is

00:19:00,090 --> 00:19:04,380
pretending as if we could influence what

00:19:02,760 --> 00:19:07,049
kind of explicit construct as a

00:19:04,380 --> 00:19:08,429
particular existing type has so what

00:19:07,049 --> 00:19:10,380
we're really writing is something like

00:19:08,429 --> 00:19:12,929
explicit casts its string and then

00:19:10,380 --> 00:19:16,049
whatever arguments you pass the stat

00:19:12,929 --> 00:19:18,120
string what we also have is a wrapper

00:19:16,049 --> 00:19:19,799
for employees back because you you want

00:19:18,120 --> 00:19:22,110
to do something like this where you have

00:19:19,799 --> 00:19:25,770
a vector of strings and now um place

00:19:22,110 --> 00:19:27,270
back a character range and this you you

00:19:25,770 --> 00:19:29,039
won't simply want to work you want us to

00:19:27,270 --> 00:19:31,289
convert this to string and it's gets

00:19:29,039 --> 00:19:33,240
pushed back onto the vector so we

00:19:31,289 --> 00:19:34,679
wrapped and place back and of course you

00:19:33,240 --> 00:19:36,720
also need an append if you already have

00:19:34,679 --> 00:19:39,029
a string you want to append stuff well

00:19:36,720 --> 00:19:41,010
that's not too hard again there's a very

00:19:39,029 --> 00:19:43,919
etic version for multiple for the

00:19:41,010 --> 00:19:47,159
automatic concat basically i also

00:19:43,919 --> 00:19:48,690
promised you format strings here's how

00:19:47,159 --> 00:19:50,700
our format strings look like it also

00:19:48,690 --> 00:19:52,260
shows a little bit of syntax of how this

00:19:50,700 --> 00:19:55,740
thing actually looks like when you when

00:19:52,260 --> 00:19:57,360
you put together a website a web page

00:19:55,740 --> 00:20:00,390
for example the

00:19:57,360 --> 00:20:02,880
is how basically works so the

00:20:00,390 --> 00:20:04,559
placeholders just just takes positional

00:20:02,880 --> 00:20:06,809
arguments anything that you want to add

00:20:04,559 --> 00:20:08,340
in terms of parameters is goes to the

00:20:06,809 --> 00:20:10,530
end where you are basically just

00:20:08,340 --> 00:20:11,880
sticking in string snippets and if you

00:20:10,530 --> 00:20:13,410
want to string sniff it building it out

00:20:11,880 --> 00:20:15,840
of a double you just use your edge deck

00:20:13,410 --> 00:20:18,120
function as usual we also have named

00:20:15,840 --> 00:20:19,980
arguments sometimes if you write a

00:20:18,120 --> 00:20:21,540
template and you're you're basically or

00:20:19,980 --> 00:20:22,950
your string doesn't come out of the cut

00:20:21,540 --> 00:20:24,780
does not come out of the code but it

00:20:22,950 --> 00:20:25,770
comes from from file on the disk you may

00:20:24,780 --> 00:20:29,780
want something that's a bit more

00:20:25,770 --> 00:20:33,210
descriptive in your in your strings and

00:20:29,780 --> 00:20:35,970
yeah there is an ISO 8601 format on

00:20:33,210 --> 00:20:39,150
there as well so these kind of stuff we

00:20:35,970 --> 00:20:43,230
have in the library now how would you

00:20:39,150 --> 00:20:46,200
implement that hmm so an easy way to

00:20:43,230 --> 00:20:48,440
implement it would be that each

00:20:46,200 --> 00:20:50,940
formatted just returns a string and

00:20:48,440 --> 00:20:54,590
concat just concatenate strings and the

00:20:50,940 --> 00:20:58,740
append just append strings

00:20:54,590 --> 00:21:00,540
well it's good because it's simple it's

00:20:58,740 --> 00:21:02,490
not so good because again we need to

00:21:00,540 --> 00:21:04,380
allocate all these strings so we don't

00:21:02,490 --> 00:21:07,250
want to do that and also the talk would

00:21:04,380 --> 00:21:10,440
be over and we're still just 20-7 talk

00:21:07,250 --> 00:21:12,750
okay so how do we do it

00:21:10,440 --> 00:21:14,820
the first thing we want to do is we

00:21:12,750 --> 00:21:16,590
don't want to have any heap allocations

00:21:14,820 --> 00:21:18,090
for the individual components before

00:21:16,590 --> 00:21:19,860
when I'm going to be actually allocating

00:21:18,090 --> 00:21:21,150
strings we have to actually go to the

00:21:19,860 --> 00:21:23,790
heap for each and every string

00:21:21,150 --> 00:21:26,400
potentially and and that's part costly

00:21:23,790 --> 00:21:29,460
and so you don't want to do it the thing

00:21:26,400 --> 00:21:31,590
is as long as these s Dec like for

00:21:29,460 --> 00:21:34,740
matters actually create their character

00:21:31,590 --> 00:21:37,020
range is lazy um they actually have a

00:21:34,740 --> 00:21:40,320
compile time determine size so this

00:21:37,020 --> 00:21:43,350
basically looks like this you have a an

00:21:40,320 --> 00:21:46,440
S deck which stores just the F and the

00:21:43,350 --> 00:21:49,169
two and then the concat stores whatever

00:21:46,440 --> 00:21:50,520
components it has and there we are

00:21:49,169 --> 00:21:54,480
actually a little bit different from

00:21:50,520 --> 00:21:55,919
range v3 it proved to be a good idea to

00:21:54,480 --> 00:21:56,549
just say okay anything that is an

00:21:55,919 --> 00:21:58,740
l-value

00:21:56,549 --> 00:22:02,190
is stored by reference and anything that

00:21:58,740 --> 00:22:04,980
you pass in by our value is stored by by

00:22:02,190 --> 00:22:07,410
a moving coffee worked well for us and

00:22:04,980 --> 00:22:08,490
we use it throughout the library what

00:22:07,410 --> 00:22:09,750
you're getting is a little bit something

00:22:08,490 --> 00:22:11,190
like expression 10 place you're

00:22:09,750 --> 00:22:13,380
basically built

00:22:11,190 --> 00:22:15,300
this big tree like data structure and

00:22:13,380 --> 00:22:16,920
when you then want to pass it into a

00:22:15,300 --> 00:22:19,050
string or when you want to iterate over

00:22:16,920 --> 00:22:22,770
it you execute that data structure and

00:22:19,050 --> 00:22:25,680
it generates the character range okay

00:22:22,770 --> 00:22:27,810
let's get that into containers how

00:22:25,680 --> 00:22:30,390
what's the perfect way to get stuff into

00:22:27,810 --> 00:22:33,870
the container well you kind of know the

00:22:30,390 --> 00:22:36,660
size in advance you allocate once then

00:22:33,870 --> 00:22:38,760
you write all the characters into the

00:22:36,660 --> 00:22:41,190
container you can't really be any faster

00:22:38,760 --> 00:22:44,280
than that so let's see how this goes

00:22:41,190 --> 00:22:46,290
the first attempt is just use the

00:22:44,280 --> 00:22:52,850
container constructor with four to

00:22:46,290 --> 00:22:57,120
iterators so you have begin and end and

00:22:52,850 --> 00:22:59,100
do it like like this in the standard now

00:22:57,120 --> 00:23:02,970
and I'm currently showing here the

00:22:59,100 --> 00:23:05,370
explicit cast that is for containers

00:23:02,970 --> 00:23:08,670
then other explicit cars it's a general

00:23:05,370 --> 00:23:10,050
facility to replace constructors but for

00:23:08,670 --> 00:23:13,230
the strong it's only gonna be about

00:23:10,050 --> 00:23:14,970
containers now the problem is the floor

00:23:13,230 --> 00:23:19,470
matters that we have the a stick is not

00:23:14,970 --> 00:23:21,600
range is not random access so the

00:23:19,470 --> 00:23:23,580
constructor what we'll actually do is we

00:23:21,600 --> 00:23:25,830
go over the range twice it will first

00:23:23,580 --> 00:23:28,560
measure the size then do the allocation

00:23:25,830 --> 00:23:33,030
and then run over it again to copy the

00:23:28,560 --> 00:23:38,250
characters not perfect so how do we

00:23:33,030 --> 00:23:41,370
avoid doing that we give the the

00:23:38,250 --> 00:23:44,610
character range and an opportunity to

00:23:41,370 --> 00:23:48,120
implement a more efficient size by just

00:23:44,610 --> 00:23:50,310
having a size number and now in order to

00:23:48,120 --> 00:23:52,230
ensure that we act this the size member

00:23:50,310 --> 00:23:54,720
is actually being used rewrite the

00:23:52,230 --> 00:23:56,730
explicit loop we just have an empty

00:23:54,720 --> 00:23:58,770
container then reserved the container

00:23:56,730 --> 00:24:02,280
and then have an explicit loop just

00:23:58,770 --> 00:24:04,440
copying the the characters into the

00:24:02,280 --> 00:24:08,310
container okay

00:24:04,440 --> 00:24:11,820
it's a bit better now we also have a pen

00:24:08,310 --> 00:24:14,550
and an append we kind of do in a similar

00:24:11,820 --> 00:24:18,480
way we reserved in this car in this case

00:24:14,550 --> 00:24:20,730
the size of the container plus the size

00:24:18,480 --> 00:24:23,789
of the addition range that we want to

00:24:20,730 --> 00:24:32,249
append and then we again have our loop

00:24:23,789 --> 00:24:35,729
oh good no not at all good reserve is

00:24:32,249 --> 00:24:38,070
evil when you do that then what happens

00:24:35,729 --> 00:24:41,789
if you what happens if you take your

00:24:38,070 --> 00:24:45,149
container and just happen to add ranges

00:24:41,789 --> 00:24:46,710
of size one one by one then every time

00:24:45,149 --> 00:24:48,899
you're going to do a reserve and cream

00:24:46,710 --> 00:24:51,419
in the size by one copy over the earth

00:24:48,899 --> 00:24:53,970
reallocate in one more copy over the old

00:24:51,419 --> 00:24:55,799
one implement one more copy over the old

00:24:53,970 --> 00:24:58,279
ones so this is going to be quadratic in

00:24:55,799 --> 00:24:59,580
its running time so not what you want

00:24:58,279 --> 00:25:02,970
now

00:24:59,580 --> 00:25:06,269
what we did is as always we just wrap

00:25:02,970 --> 00:25:08,159
reserve we write a proper reserve which

00:25:06,269 --> 00:25:09,859
in the case that you actually have to

00:25:08,159 --> 00:25:12,239
change the capacity of your container

00:25:09,859 --> 00:25:14,519
increases the size of the container at

00:25:12,239 --> 00:25:17,369
least by a constant factor there some

00:25:14,519 --> 00:25:20,220
that advocate the the golden ratio as

00:25:17,369 --> 00:25:22,440
that factor and if you then replace the

00:25:20,220 --> 00:25:27,809
don't reserve with the wrapper then you

00:25:22,440 --> 00:25:29,149
get decent performance hmm so are we

00:25:27,809 --> 00:25:34,970
done

00:25:29,149 --> 00:25:41,369
well not quite so the next bottleneck

00:25:34,970 --> 00:25:43,529
actually are iterative why is that let's

00:25:41,369 --> 00:25:45,179
look at how the Coquette is very

00:25:43,529 --> 00:25:47,840
frequent right there's kind of a bread

00:25:45,179 --> 00:25:51,119
and butter to to put things together and

00:25:47,840 --> 00:25:53,519
how do iterators of a concave look like

00:25:51,119 --> 00:25:56,159
if you have a con cat and multiple

00:25:53,519 --> 00:25:59,519
component components in your concat then

00:25:56,159 --> 00:26:01,830
the iterator may be any one of the

00:25:59,519 --> 00:26:05,190
iterators that are contained in your

00:26:01,830 --> 00:26:07,499
pocket so your iterator of the con head

00:26:05,190 --> 00:26:10,559
is a variant really of the iterator

00:26:07,499 --> 00:26:12,989
types of all the components you have now

00:26:10,559 --> 00:26:17,809
each time you're doing an operation on

00:26:12,989 --> 00:26:21,029
the iterator you have to branch on the

00:26:17,809 --> 00:26:24,210
current current component that you are

00:26:21,029 --> 00:26:27,269
in so if you are for example here I

00:26:24,210 --> 00:26:30,239
showed it for for the increment if you

00:26:27,269 --> 00:26:31,859
have the increment and you are at the

00:26:30,239 --> 00:26:33,869
component one you have an iterator of

00:26:31,859 --> 00:26:35,520
type one then you increment that

00:26:33,869 --> 00:26:37,500
iterator of type one which may

00:26:35,520 --> 00:26:39,510
very different code from Israel

00:26:37,500 --> 00:26:41,250
incrementing the iterator of type 2 and

00:26:39,510 --> 00:26:44,160
then you have to check whether you reach

00:26:41,250 --> 00:26:46,200
the end of type 1 and if if you did then

00:26:44,160 --> 00:26:48,690
you just switch over to your component 2

00:26:46,200 --> 00:26:50,880
and for the component will you come do a

00:26:48,690 --> 00:26:52,620
blind increment if someone overruns they

00:26:50,880 --> 00:26:58,050
enter to write off your con ket that's

00:26:52,620 --> 00:27:00,210
their own fault ok with s dag actually

00:26:58,050 --> 00:27:01,890
we have similar problems because s tag

00:27:00,210 --> 00:27:03,840
also will have some internal state of

00:27:01,890 --> 00:27:07,500
which character which digit is currently

00:27:03,840 --> 00:27:09,420
producing and if you have to restore

00:27:07,500 --> 00:27:11,490
that state each and every time your your

00:27:09,420 --> 00:27:15,210
accessing the iterator that's going to

00:27:11,490 --> 00:27:17,790
be also costly performance what's the

00:27:15,210 --> 00:27:21,050
fundamental problem here fundamental

00:27:17,790 --> 00:27:23,670
problem is that C++ iterators do

00:27:21,050 --> 00:27:26,520
external iteration what does that mean

00:27:23,670 --> 00:27:30,420
well it basically means the consumer of

00:27:26,520 --> 00:27:32,850
the of the data runs in a single

00:27:30,420 --> 00:27:36,390
contiguous code path at the bottom of

00:27:32,850 --> 00:27:38,760
your stack and every time is needing

00:27:36,390 --> 00:27:41,060
some new character is just going to call

00:27:38,760 --> 00:27:44,970
into the iterator and get a character

00:27:41,060 --> 00:27:46,500
now this is great for the consumer so

00:27:44,970 --> 00:27:48,510
the consumer when you are at the bottom

00:27:46,500 --> 00:27:50,610
of the stack you have a contiguous code

00:27:48,510 --> 00:27:52,890
path you never need to restore any state

00:27:50,610 --> 00:27:54,870
you can store anything to your liking on

00:27:52,890 --> 00:27:57,540
the local stack the stacks not going to

00:27:54,870 --> 00:27:59,250
go away so you get good performance and

00:27:57,540 --> 00:28:00,810
at the end they are also easier to write

00:27:59,250 --> 00:28:03,060
because this is kind of the way we think

00:28:00,810 --> 00:28:06,090
we think in a linear fashion so they're

00:28:03,060 --> 00:28:08,130
easy to write now the producer has a

00:28:06,090 --> 00:28:09,420
much harder time because they only have

00:28:08,130 --> 00:28:11,040
a single entry point they only have the

00:28:09,420 --> 00:28:12,600
operator star and they have to restore

00:28:11,040 --> 00:28:14,460
their state every time as we've seen by

00:28:12,600 --> 00:28:16,110
the concat they are harder to write

00:28:14,460 --> 00:28:18,720
because you have to kind of keep a book

00:28:16,110 --> 00:28:20,130
to do the bookkeeping and you get worse

00:28:18,720 --> 00:28:21,480
performance because you knew always need

00:28:20,130 --> 00:28:24,110
to restore the state that was the

00:28:21,480 --> 00:28:27,270
branching that we see it so on concat

00:28:24,110 --> 00:28:28,980
hmm one of the alternative well if there

00:28:27,270 --> 00:28:31,440
is an external iteration then there's

00:28:28,980 --> 00:28:33,210
also an internal iteration the internal

00:28:31,440 --> 00:28:36,060
iteration just takes this whole thing

00:28:33,210 --> 00:28:37,710
and turns it upside down so now you have

00:28:36,060 --> 00:28:40,710
a producer running at the bottom of the

00:28:37,710 --> 00:28:44,370
stack and calling into the consumer

00:28:40,710 --> 00:28:46,500
whenever a character is ready and then

00:28:44,370 --> 00:28:48,200
the producer has all the advantages of

00:28:46,500 --> 00:28:50,450
being on top of the stack it sits

00:28:48,200 --> 00:28:52,370
it's easy to write the consumer now has

00:28:50,450 --> 00:28:54,649
a trouble but how much trouble does it

00:28:52,370 --> 00:28:56,960
really have I mean we are talking about

00:28:54,649 --> 00:28:59,600
an M place back here we are formatting

00:28:56,960 --> 00:29:01,340
strings so the consumer is not very

00:28:59,600 --> 00:29:02,899
complex the producer is a whole lot more

00:29:01,340 --> 00:29:07,580
complex and you would like it to be

00:29:02,899 --> 00:29:10,250
really at the bottom of the stack now it

00:29:07,580 --> 00:29:11,990
turns out that many of the range

00:29:10,250 --> 00:29:14,870
algorithms that are in the normal range

00:29:11,990 --> 00:29:18,200
library can actually be expressed for

00:29:14,870 --> 00:29:19,760
internet for internal iteration you

00:29:18,200 --> 00:29:22,399
can't do a binary search because you

00:29:19,760 --> 00:29:24,559
don't have iterators okay you can't

00:29:22,399 --> 00:29:26,419
really do a find but only as long as you

00:29:24,559 --> 00:29:28,010
insist on returning an iterator and all

00:29:26,419 --> 00:29:29,990
library you can actually mark it up and

00:29:28,010 --> 00:29:32,510
say oh I only need the value if you only

00:29:29,990 --> 00:29:35,840
need the value you're okay right you can

00:29:32,510 --> 00:29:38,240
do this on with internal iteration for

00:29:35,840 --> 00:29:40,610
each just works accumulators works all

00:29:38,240 --> 00:29:43,639
of not any of none of works I would say

00:29:40,610 --> 00:29:47,450
probably in our code and think so only a

00:29:43,639 --> 00:29:49,490
very small number of of ranges are

00:29:47,450 --> 00:29:52,970
actually done in terms of iterators most

00:29:49,490 --> 00:29:55,429
are our internal iteration right now the

00:29:52,970 --> 00:29:56,990
views also work so you can actually do

00:29:55,429 --> 00:29:58,789
this filtering there's lazy filtering

00:29:56,990 --> 00:30:00,590
that I described can you can actually do

00:29:58,789 --> 00:30:01,580
it more efficiently with internal

00:30:00,590 --> 00:30:05,570
iteration and you can do it with

00:30:01,580 --> 00:30:07,519
iterators the the transform is it also

00:30:05,570 --> 00:30:09,289
as possible transform is basically you

00:30:07,519 --> 00:30:11,269
don't filter the elements of your

00:30:09,289 --> 00:30:13,730
underlying range but you you pump them

00:30:11,269 --> 00:30:16,039
through a function and you return the

00:30:13,730 --> 00:30:18,710
result so that can also be trivially

00:30:16,039 --> 00:30:20,659
implemented with internal iteration so

00:30:18,710 --> 00:30:22,820
what are you going to do well we want to

00:30:20,659 --> 00:30:26,779
extend the range concept so it actually

00:30:22,820 --> 00:30:29,149
supports internal iteration all right um

00:30:26,779 --> 00:30:30,529
how do we do that well first of all we

00:30:29,149 --> 00:30:33,620
have to kind of come up with a syntax

00:30:30,529 --> 00:30:35,960
and what we did what we picked is the

00:30:33,620 --> 00:30:37,519
function call operator now the

00:30:35,960 --> 00:30:41,720
disadvantage of using the function call

00:30:37,519 --> 00:30:43,880
operator is that a range in C++ 20 the

00:30:41,720 --> 00:30:46,039
state span already has the function call

00:30:43,880 --> 00:30:48,260
operator defined it's the same as the

00:30:46,039 --> 00:30:50,210
square bracket operator but still we

00:30:48,260 --> 00:30:52,340
would have to seen it out this is not

00:30:50,210 --> 00:30:55,100
the kind of function cooperation that we

00:30:52,340 --> 00:30:56,990
mean the big advantage of using the

00:30:55,100 --> 00:30:59,770
function call operator is that any

00:30:56,990 --> 00:31:01,390
lambda that takes a sink

00:30:59,770 --> 00:31:03,580
the range and you can use it together

00:31:01,390 --> 00:31:05,950
with the arrange algorithms so if you

00:31:03,580 --> 00:31:07,870
look at the for each year the range is

00:31:05,950 --> 00:31:10,450
just a lambda it takes a sink you just

00:31:07,870 --> 00:31:13,390
pass this one and two into the sink it's

00:31:10,450 --> 00:31:15,910
a range of one and to the visitor just

00:31:13,390 --> 00:31:18,309
takes that number and somehow consumes

00:31:15,910 --> 00:31:20,200
it before each doesn't do a whole lot it

00:31:18,309 --> 00:31:22,179
just takes the second lambda and sticks

00:31:20,200 --> 00:31:24,580
it into the first Lander that's all it

00:31:22,179 --> 00:31:27,220
does and you can't do it directly though

00:31:24,580 --> 00:31:29,860
because the 4-h has to basically check

00:31:27,220 --> 00:31:31,690
whether this is a range that supports

00:31:29,860 --> 00:31:32,650
internal iteration and if it doesn't

00:31:31,690 --> 00:31:34,720
support in terms of the direction you

00:31:32,650 --> 00:31:40,390
have to do the fall back to its raters

00:31:34,720 --> 00:31:43,300
and this is what H does okay now does it

00:31:40,390 --> 00:31:46,630
help well it helps a lot for a Coquette

00:31:43,300 --> 00:31:50,740
because suddenly the the implementation

00:31:46,630 --> 00:31:52,780
for internal iteration is just you have

00:31:50,740 --> 00:31:55,300
your triple of ranges you are your

00:31:52,780 --> 00:31:57,370
components you go over each one of them

00:31:55,300 --> 00:32:01,540
and our for each also takes two poles so

00:31:57,370 --> 00:32:04,480
you can write that and then for each of

00:32:01,540 --> 00:32:06,550
them you just call for each so it is

00:32:04,480 --> 00:32:08,500
very very close to what you would do if

00:32:06,550 --> 00:32:09,580
you iterate with it for each over every

00:32:08,500 --> 00:32:12,280
one of the components you would just

00:32:09,580 --> 00:32:16,210
call for each on every one of them best

00:32:12,280 --> 00:32:22,410
they have no overhead how do we use that

00:32:16,210 --> 00:32:24,880
now to append things to containers well

00:32:22,410 --> 00:32:27,640
we are going to say we have an

00:32:24,880 --> 00:32:32,830
additional customization point appender

00:32:27,640 --> 00:32:35,080
and the append is just a for each on

00:32:32,830 --> 00:32:37,210
that appender you just pass this

00:32:35,080 --> 00:32:39,160
appender that depends to a container to

00:32:37,210 --> 00:32:42,160
the for each this is how the append

00:32:39,160 --> 00:32:45,400
looks like is either some custom defined

00:32:42,160 --> 00:32:48,010
container that that container can pick

00:32:45,400 --> 00:32:50,170
or for the standard containers we have a

00:32:48,010 --> 00:32:57,280
default implementation which just does

00:32:50,170 --> 00:33:00,429
end playback easy enough hmm our resort

00:32:57,280 --> 00:33:02,830
fell in between the cracks I forgot

00:33:00,429 --> 00:33:05,800
about the reserved how do you do the

00:33:02,830 --> 00:33:07,780
research um for reserved to be done

00:33:05,800 --> 00:33:09,490
properly you basically need access to

00:33:07,780 --> 00:33:11,690
the whole range because you want to ask

00:33:09,490 --> 00:33:15,940
the range what's in size

00:33:11,690 --> 00:33:19,280
so we put it in your customization point

00:33:15,940 --> 00:33:22,250
we call the chunk which essentially says

00:33:19,280 --> 00:33:24,800
if you have something if you don't have

00:33:22,250 --> 00:33:27,800
you can tell your appender I don't have

00:33:24,800 --> 00:33:29,450
a single single element but instead I

00:33:27,800 --> 00:33:32,000
have something bigger I have a range

00:33:29,450 --> 00:33:33,470
that maybe the whole range may only be a

00:33:32,000 --> 00:33:37,970
part of the range that would be fine as

00:33:33,470 --> 00:33:40,460
well but I have something bigger and the

00:33:37,970 --> 00:33:42,950
this chunk implementation of the

00:33:40,460 --> 00:33:44,450
reserving appender which derive from the

00:33:42,950 --> 00:33:46,700
appender so it has the regular operator

00:33:44,450 --> 00:33:49,760
the function call operator to deal with

00:33:46,700 --> 00:33:52,750
elements the in the chunk just takes the

00:33:49,760 --> 00:33:55,850
whole range then runs the reserve and

00:33:52,750 --> 00:33:57,620
then just for each s as before it just

00:33:55,850 --> 00:34:00,170
recursively calls for each but actually

00:33:57,620 --> 00:34:03,230
slices off the reserving so if you have

00:34:00,170 --> 00:34:05,000
this huge tree of con cats then what

00:34:03,230 --> 00:34:06,860
would happen is at the first time when

00:34:05,000 --> 00:34:09,440
you actually can determine the size you

00:34:06,860 --> 00:34:12,560
would do the reserve and then you pass

00:34:09,440 --> 00:34:14,120
down that tree and and appender that

00:34:12,560 --> 00:34:15,470
doesn't do any reserve anymore it will

00:34:14,120 --> 00:34:16,760
just use m place back because you've

00:34:15,470 --> 00:34:21,560
done your reserve already they in place

00:34:16,760 --> 00:34:23,330
back will just work you may think well

00:34:21,560 --> 00:34:25,550
this chunk thing it sounds a bit like

00:34:23,330 --> 00:34:28,090
well they've just done something that

00:34:25,550 --> 00:34:30,679
serves their single purpose of reserving

00:34:28,090 --> 00:34:33,830
not quite I mean if you wanted for

00:34:30,679 --> 00:34:36,380
example a pen to a file it's quite you

00:34:33,830 --> 00:34:38,480
the the the operating system function

00:34:36,380 --> 00:34:40,040
usually needs contiguous memory you need

00:34:38,480 --> 00:34:41,870
to give it some chunk of memory to write

00:34:40,040 --> 00:34:42,590
right into the file and then you can do

00:34:41,870 --> 00:34:46,820
it all at once

00:34:42,590 --> 00:34:52,820
now you can do that here with the the

00:34:46,820 --> 00:34:54,350
trunk the trunk customisation point if

00:34:52,820 --> 00:34:56,300
you give it a parameter a stood span

00:34:54,350 --> 00:34:58,250
parameter basically a memory block

00:34:56,300 --> 00:35:00,170
parameter so for each is going to check

00:34:58,250 --> 00:35:03,440
does that compile can I call the chunk

00:35:00,170 --> 00:35:05,420
with that piece of memory say a vector

00:35:03,440 --> 00:35:08,780
and said yeah I can convert the vector

00:35:05,420 --> 00:35:10,670
into a span so so I can do that so then

00:35:08,780 --> 00:35:12,050
the the the basically the chunk takes

00:35:10,670 --> 00:35:14,030
over and writes the whole block at once

00:35:12,050 --> 00:35:16,020
but if you discover well I have a list

00:35:14,030 --> 00:35:21,380
and I can't do the conversion

00:35:16,020 --> 00:35:26,130
I just call it element by element now

00:35:21,380 --> 00:35:29,869
here is actually of course after um all

00:35:26,130 --> 00:35:32,640
these things I wanted to know how much

00:35:29,869 --> 00:35:33,810
performance does that actually cost

00:35:32,640 --> 00:35:36,800
because we build this huge

00:35:33,810 --> 00:35:40,230
infrastructure one big infrastructure

00:35:36,800 --> 00:35:43,080
and the question is how much is that

00:35:40,230 --> 00:35:47,610
over handwritten code how much is that

00:35:43,080 --> 00:35:49,910
over the perfect simplest possible most

00:35:47,610 --> 00:35:54,119
performing formatter

00:35:49,910 --> 00:35:59,220
so I built a special buffer that is just

00:35:54,119 --> 00:36:01,560
plain old memory 1024 bytes and there is

00:35:59,220 --> 00:36:03,540
a handwritten kind of repeat function

00:36:01,560 --> 00:36:05,100
with which I will do the following for

00:36:03,540 --> 00:36:07,350
making tasks I went through ten times a

00:36:05,100 --> 00:36:08,490
ten times be ten times C and I just

00:36:07,350 --> 00:36:10,260
marked it up so that the compiler

00:36:08,490 --> 00:36:13,110
doesn't in line everything and just

00:36:10,260 --> 00:36:15,990
collapses it to a constant strain but

00:36:13,110 --> 00:36:18,030
picking such a very simple task is best

00:36:15,990 --> 00:36:19,440
to expose any overhead that's in the

00:36:18,030 --> 00:36:21,480
system because the actual format that

00:36:19,440 --> 00:36:24,600
doesn't have much to do and if any time

00:36:21,480 --> 00:36:26,280
we spend extra is amplified by the fact

00:36:24,600 --> 00:36:28,650
that we don't do actual work we do

00:36:26,280 --> 00:36:31,590
something very simple or in the format

00:36:28,650 --> 00:36:34,170
itself so that's basically all strawman

00:36:31,590 --> 00:36:37,740
that's all benchmark and against that

00:36:34,170 --> 00:36:39,780
we're gonna have the buffer in addition

00:36:37,740 --> 00:36:41,850
to the in the buffer we have an append

00:36:39,780 --> 00:36:43,830
or implementation that just append to

00:36:41,850 --> 00:36:45,990
the end of the buffer again there is no

00:36:43,830 --> 00:36:47,730
end check here it just writes raw string

00:36:45,990 --> 00:36:51,810
to the end of the buffer just to expose

00:36:47,730 --> 00:36:56,580
whatever inefficiencies there are in in

00:36:51,810 --> 00:36:59,070
the the actual framework so and then the

00:36:56,580 --> 00:37:01,080
repeat is how we would we now would

00:36:59,070 --> 00:37:02,670
write the appeal repeat with a with our

00:37:01,080 --> 00:37:04,260
proper library so you're doing a pen

00:37:02,670 --> 00:37:09,300
through the buffer and then use the

00:37:04,260 --> 00:37:13,619
repeat n in in a very attic way so what

00:37:09,300 --> 00:37:18,510
did we get the repeat n if it's iterator

00:37:13,619 --> 00:37:20,400
based is about 50% slower than our

00:37:18,510 --> 00:37:22,830
benchmark implementation if we use

00:37:20,400 --> 00:37:24,720
iterators now if we use internal

00:37:22,830 --> 00:37:27,180
iteration we end up with something that

00:37:24,720 --> 00:37:29,310
it's just 15 percent slower than

00:37:27,180 --> 00:37:31,620
the perfect formatting which one I think

00:37:29,310 --> 00:37:34,050
it's pretty good it's it's nice and high

00:37:31,620 --> 00:37:36,150
level what we're writing and you don't

00:37:34,050 --> 00:37:37,950
really pay much of it for it and and

00:37:36,150 --> 00:37:39,990
again this is the worst case because we

00:37:37,950 --> 00:37:42,390
are not really actually doing actual

00:37:39,990 --> 00:37:44,490
work you would have you would see a

00:37:42,390 --> 00:37:49,170
smaller difference if you if you'd say

00:37:44,490 --> 00:37:53,580
convert numbers cool to a strip I did

00:37:49,170 --> 00:37:55,590
another test which is I built a toy

00:37:53,580 --> 00:37:58,380
basics training implementation just just

00:37:55,590 --> 00:38:01,380
has straight three-pointers begin and at

00:37:58,380 --> 00:38:03,750
the end of capacity and again I would

00:38:01,380 --> 00:38:06,930
write I write the the trivial formatting

00:38:03,750 --> 00:38:09,870
tasks say turns out to be ten times C so

00:38:06,930 --> 00:38:13,020
that's that's what we have and for the

00:38:09,870 --> 00:38:15,330
first try the basic string appender is

00:38:13,020 --> 00:38:18,210
going to be osted appender on a standard

00:38:15,330 --> 00:38:20,490
fender so it does in the operator

00:38:18,210 --> 00:38:22,620
parentheses it does implants back and it

00:38:20,490 --> 00:38:23,880
has the reserving appender that does the

00:38:22,620 --> 00:38:26,970
research so in this case i'm actually

00:38:23,880 --> 00:38:30,590
measuring I'm including the the time

00:38:26,970 --> 00:38:32,930
that for the for the memory allocation

00:38:30,590 --> 00:38:35,370
question is can I do better than this

00:38:32,930 --> 00:38:37,500
can I do better than a combination of

00:38:35,370 --> 00:38:39,870
first doing a reserve and then doing and

00:38:37,500 --> 00:38:43,410
place back the answer is yes I can

00:38:39,870 --> 00:38:46,350
because I know that after the reserving

00:38:43,410 --> 00:38:48,210
I don't need to do the end track the end

00:38:46,350 --> 00:38:50,240
place back checks at each and every time

00:38:48,210 --> 00:38:52,860
whether it reach the end of the buffer

00:38:50,240 --> 00:38:54,930
it doesn't nature we reserved already we

00:38:52,860 --> 00:38:57,060
know that this is going to fit you can

00:38:54,930 --> 00:38:58,650
just write to your heart's content to

00:38:57,060 --> 00:39:00,960
the end of the buffer and you can be

00:38:58,650 --> 00:39:05,070
sure that you're not gonna overall so

00:39:00,960 --> 00:39:05,660
that is our our improvement how much did

00:39:05,070 --> 00:39:07,530
you get

00:39:05,660 --> 00:39:09,900
remember the string was only 30

00:39:07,530 --> 00:39:11,370
characters not very long and we had the

00:39:09,900 --> 00:39:12,900
heap allocation in there I don't know

00:39:11,370 --> 00:39:14,850
how fast heap allocation is that was not

00:39:12,900 --> 00:39:16,800
on a Windows machine so that's how fast

00:39:14,850 --> 00:39:19,860
the heap allocation was as it is on the

00:39:16,800 --> 00:39:22,680
Windows machine but still with Visual

00:39:19,860 --> 00:39:24,660
Studio latest version actually saves 20

00:39:22,680 --> 00:39:27,480
percent of the time to not check for the

00:39:24,660 --> 00:39:30,210
end so it's done in the library I mean

00:39:27,480 --> 00:39:32,610
you get it for free it's it's fine the

00:39:30,210 --> 00:39:35,160
only problem is that the basic string in

00:39:32,610 --> 00:39:37,550
the vector they they don't really expose

00:39:35,160 --> 00:39:40,310
their internal buffer so

00:39:37,550 --> 00:39:43,220
you need to have your own basic string

00:39:40,310 --> 00:39:46,040
vector implementation we don't have it

00:39:43,220 --> 00:39:51,080
yet but probably at some point we will

00:39:46,040 --> 00:39:52,610
have that in the library now there are

00:39:51,080 --> 00:39:58,460
other things you can actually do and

00:39:52,610 --> 00:40:01,580
this is my one before last slide if not

00:39:58,460 --> 00:40:04,370
all the snippets implement size we

00:40:01,580 --> 00:40:06,890
currently fall back to appending them in

00:40:04,370 --> 00:40:09,350
in there with without doing any reserve

00:40:06,890 --> 00:40:11,270
which is not really necessary maybe some

00:40:09,350 --> 00:40:13,640
of the components know their size but

00:40:11,270 --> 00:40:15,680
only one component doesn't it so - in

00:40:13,640 --> 00:40:17,960
order to avoid having to reallocate

00:40:15,680 --> 00:40:20,660
multiple times I could just say well

00:40:17,960 --> 00:40:24,320
just I know already I will need at least

00:40:20,660 --> 00:40:25,910
that much so what allocate that and then

00:40:24,320 --> 00:40:28,670
we will need to see how much that

00:40:25,910 --> 00:40:31,760
augment out will require that that whose

00:40:28,670 --> 00:40:33,380
size I don't know and you could do that

00:40:31,760 --> 00:40:36,320
with a new customization point you could

00:40:33,380 --> 00:40:38,360
just introduce them in size and the mid

00:40:36,320 --> 00:40:40,460
size is never going to return zero so

00:40:38,360 --> 00:40:42,260
you always have the safe fallback and

00:40:40,460 --> 00:40:44,090
the mid size of the concat of course is

00:40:42,260 --> 00:40:46,670
just the sum of them in sizes of the

00:40:44,090 --> 00:40:51,110
components you can do similar things

00:40:46,670 --> 00:40:53,000
with fire buffers so if you replace the

00:40:51,110 --> 00:40:55,480
file buffer in the state file and

00:40:53,000 --> 00:40:57,710
basically do your own buffer management

00:40:55,480 --> 00:40:59,540
you could check when you are getting

00:40:57,710 --> 00:41:01,010
something you could check inside into -

00:40:59,540 --> 00:41:03,230
right into the file you could check the

00:41:01,010 --> 00:41:05,210
size and see it's my a buffer still

00:41:03,230 --> 00:41:07,160
large enough to hold that

00:41:05,210 --> 00:41:08,810
that's straight and if it's large enough

00:41:07,160 --> 00:41:11,390
you again can write without checking for

00:41:08,810 --> 00:41:12,830
end if it's bigger you can decide you

00:41:11,390 --> 00:41:14,750
can either flush the buffer so you have

00:41:12,830 --> 00:41:17,270
a fresh bottle that's then big enough or

00:41:14,750 --> 00:41:19,070
you can say okay I'm going to do the end

00:41:17,270 --> 00:41:22,520
check and when I'm reaching the end and

00:41:19,070 --> 00:41:24,290
I don't have to do the flushing they may

00:41:22,520 --> 00:41:26,090
also be room for yet another

00:41:24,290 --> 00:41:29,660
customization point you can have max

00:41:26,090 --> 00:41:31,850
size that basically overestimates how

00:41:29,660 --> 00:41:33,770
much size you need if someone can't tell

00:41:31,850 --> 00:41:36,530
for sure they will overestimate like

00:41:33,770 --> 00:41:40,160
like an integer 32 bit will fit into

00:41:36,530 --> 00:41:42,650
whatever mine unsigned into nine

00:41:40,160 --> 00:41:44,930
characters so you return nine and then

00:41:42,650 --> 00:41:46,150
your you can be sure that even if you

00:41:44,930 --> 00:41:47,589
are overestimating it

00:41:46,150 --> 00:41:52,599
it's okay then I don't need an end check

00:41:47,589 --> 00:41:57,220
just write it all down okay so that was

00:41:52,599 --> 00:42:01,210
it what I want to convince you is off is

00:41:57,220 --> 00:42:03,609
that you should use the range syntax to

00:42:01,210 --> 00:42:07,809
do text formatting and it's really

00:42:03,609 --> 00:42:09,490
practical to do so for in order to get

00:42:07,809 --> 00:42:11,710
good performance you need a few more

00:42:09,490 --> 00:42:14,049
customization points in particular the

00:42:11,710 --> 00:42:16,299
range library should support internal

00:42:14,049 --> 00:42:19,270
iteration that's something that I think

00:42:16,299 --> 00:42:20,650
is a really good idea in general because

00:42:19,270 --> 00:42:23,109
you really get performance and also in

00:42:20,650 --> 00:42:25,869
other situations you need an appender

00:42:23,109 --> 00:42:26,440
okay and you need that special search

00:42:25,869 --> 00:42:28,630
UNK

00:42:26,440 --> 00:42:31,770
customization point to inspect the whole

00:42:28,630 --> 00:42:34,240
range or a larger particle range at once

00:42:31,770 --> 00:42:35,710
but if you do all that then the

00:42:34,240 --> 00:42:37,480
performance is competitive with

00:42:35,710 --> 00:42:39,130
handwritten code and I guess that's

00:42:37,480 --> 00:42:41,260
that's what we all want that's why we

00:42:39,130 --> 00:42:43,779
are programming C++ the things that

00:42:41,260 --> 00:42:45,910
library is available on github and we

00:42:43,779 --> 00:42:49,480
also now put it under a boost license so

00:42:45,910 --> 00:42:53,500
it can be used actually in commercial

00:42:49,480 --> 00:42:55,599
projects if you try it out find anything

00:42:53,500 --> 00:42:58,539
wrong with it let me know and then we

00:42:55,599 --> 00:43:00,640
will look into it and if you want to

00:42:58,539 --> 00:43:03,609
help building the library then of course

00:43:00,640 --> 00:43:05,289
go to our website and there's always a

00:43:03,609 --> 00:43:06,610
developer application possible thank you

00:43:05,289 --> 00:43:13,619
very much

00:43:06,610 --> 00:43:39,579
[Applause]

00:43:13,619 --> 00:43:44,079
questions I think ya know we didn't so I

00:43:39,579 --> 00:43:46,029
think they are probably other oh okay we

00:43:44,079 --> 00:43:48,010
repeat the question yeah so did we write

00:43:46,029 --> 00:43:51,279
all our formatting algorithms ourselves

00:43:48,010 --> 00:43:52,990
no this just wasn't our focus there are

00:43:51,279 --> 00:43:56,140
probably better people writing

00:43:52,990 --> 00:43:58,599
formatting algorithms and I also didn't

00:43:56,140 --> 00:44:00,369
pick the TCS deck as a benchmark for

00:43:58,599 --> 00:44:02,410
exactly that purpose because you would

00:44:00,369 --> 00:44:04,869
really possibly I've I've never

00:44:02,410 --> 00:44:08,920
programmed one but I look briefly at the

00:44:04,869 --> 00:44:10,329
the curly braces format code and there

00:44:08,920 --> 00:44:14,109
are tricks to be played with how to

00:44:10,329 --> 00:44:18,250
quickly generate like to format integers

00:44:14,109 --> 00:44:20,650
and yeah you can you can put that in in

00:44:18,250 --> 00:44:25,089
general I mean this is this talk is less

00:44:20,650 --> 00:44:27,730
about imposing a particular you know way

00:44:25,089 --> 00:44:29,740
of algorithms or anything it's just like

00:44:27,730 --> 00:44:32,319
it's nice to have a framework which you

00:44:29,740 --> 00:44:42,520
can put all these things into that you

00:44:32,319 --> 00:44:46,299
need yeah so we are with with the

00:44:42,520 --> 00:44:49,980
library yes which versions of the c++ do

00:44:46,299 --> 00:44:53,140
we require pretty much the latest one so

00:44:49,980 --> 00:44:54,970
with with the library as I said kind of

00:44:53,140 --> 00:44:56,770
a guiding principle is that we always

00:44:54,970 --> 00:44:58,779
evolve the code and the library together

00:44:56,770 --> 00:45:02,650
so I'm not really shy of changing the

00:44:58,779 --> 00:45:04,839
library and that leads to the library

00:45:02,650 --> 00:45:06,670
basically requiring whatever the latest

00:45:04,839 --> 00:45:09,369
version is so we are currently on C++

00:45:06,670 --> 00:45:11,740
15.8 which is what they put out in

00:45:09,369 --> 00:45:13,900
Visual Studio and the latest

00:45:11,740 --> 00:45:15,250
Xcode these are the things that we

00:45:13,900 --> 00:45:19,170
actually test summer because we have a

00:45:15,250 --> 00:45:19,170
Mac and and windows as part it's

00:45:23,680 --> 00:45:31,520
it it's it does yes it still includes

00:45:28,099 --> 00:45:34,310
small parts up does it use boost as a

00:45:31,520 --> 00:45:40,580
requirement yes it does still include

00:45:34,310 --> 00:45:44,270
parts of boost but we are reducing that

00:45:40,580 --> 00:45:47,270
amount more and more especially with

00:45:44,270 --> 00:45:50,119
respect to two trades like like the

00:45:47,270 --> 00:45:53,240
value type of a range for example there

00:45:50,119 --> 00:45:55,880
I go more and more in don't define but

00:45:53,240 --> 00:45:57,530
don't require if that a type def in your

00:45:55,880 --> 00:45:59,000
in your container for example don't

00:45:57,530 --> 00:46:01,849
define your value type explicitly

00:45:59,000 --> 00:46:04,070
instead make it a decayed version of the

00:46:01,849 --> 00:46:06,800
often beginning the the the reference

00:46:04,070 --> 00:46:09,980
type essentially it will start again and

00:46:06,800 --> 00:46:12,200
if that's wrong somehow then then we

00:46:09,980 --> 00:46:15,200
have a custom decay where basically do

00:46:12,200 --> 00:46:17,359
general decaying so so bit by bit we

00:46:15,200 --> 00:46:19,640
kind of kind of munch away on that on

00:46:17,359 --> 00:46:21,500
that part the end that we really have

00:46:19,640 --> 00:46:38,599
been doing for 12 years or 15 or

00:46:21,500 --> 00:46:42,020
whatever I'm afraid neither so my my

00:46:38,599 --> 00:46:43,640
experience with the standard is and and

00:46:42,020 --> 00:46:46,099
I've all respect for the people who are

00:46:43,640 --> 00:46:47,839
we're doing oh well yeah are we are we

00:46:46,099 --> 00:46:50,720
going to put this into the standard

00:46:47,839 --> 00:46:53,210
library or are we switching to the

00:46:50,720 --> 00:46:54,650
standard library which is probably gonna

00:46:53,210 --> 00:46:55,790
be our needless library when it's

00:46:54,650 --> 00:47:00,430
available when it's finally in the

00:46:55,790 --> 00:47:03,380
standard and the answer is neither so I

00:47:00,430 --> 00:47:06,440
as I would like to put this into the

00:47:03,380 --> 00:47:07,880
standard library I know that putting

00:47:06,440 --> 00:47:09,950
something into the standard library or

00:47:07,880 --> 00:47:12,080
writing a library is about a quarter of

00:47:09,950 --> 00:47:14,420
the effort and putting it into the

00:47:12,080 --> 00:47:16,010
standard is 3/4 off the effort well

00:47:14,420 --> 00:47:17,930
maybe it's ten ninety or something I

00:47:16,010 --> 00:47:21,580
mean it the most of the work is being

00:47:17,930 --> 00:47:24,920
gonna going to be to to standardize it

00:47:21,580 --> 00:47:27,950
that's that's number one so it's it's a

00:47:24,920 --> 00:47:32,140
political process no question and number

00:47:27,950 --> 00:47:34,570
two we really I really like you

00:47:32,140 --> 00:47:38,650
that library it I would hate to be stuck

00:47:34,570 --> 00:47:40,420
with something where I'm now bound to it

00:47:38,650 --> 00:47:42,310
because I have put it into the standard

00:47:40,420 --> 00:47:44,290
paper and I think the library is good

00:47:42,310 --> 00:47:46,600
and I think it is good because we were

00:47:44,290 --> 00:47:48,430
able to evolve it it kind of I

00:47:46,600 --> 00:47:51,220
understand that this is not perfect for

00:47:48,430 --> 00:47:53,110
if people want to use it in that project

00:47:51,220 --> 00:47:57,340
then they kind of have to fork it and

00:47:53,110 --> 00:48:00,100
and update or not but it's primarily

00:47:57,340 --> 00:48:03,400
it's an in-house thing that we really

00:48:00,100 --> 00:48:05,080
really use and and I don't want to be

00:48:03,400 --> 00:48:06,880
stuck with something that I don't no

00:48:05,080 --> 00:48:18,130
longer believe in because it has already

00:48:06,880 --> 00:48:20,470
found its way to the statically so how

00:48:18,130 --> 00:48:23,380
does it how does it work with breaking

00:48:20,470 --> 00:48:25,110
and how does it work with channels they

00:48:23,380 --> 00:48:32,470
hmm

00:48:25,110 --> 00:48:37,780
always with chunk good question first of

00:48:32,470 --> 00:48:39,460
all the breaking so in in general

00:48:37,780 --> 00:48:42,880
breaking this is something I completely

00:48:39,460 --> 00:48:44,020
omitted because I'm well I was talking

00:48:42,880 --> 00:48:48,090
about text formatting don't need to

00:48:44,020 --> 00:48:50,830
break there is the the the the

00:48:48,090 --> 00:48:53,800
convention that we are always returning

00:48:50,830 --> 00:48:55,810
an eat on break or continue from

00:48:53,800 --> 00:48:58,030
everything where we want to break out of

00:48:55,810 --> 00:49:00,040
and we have kind of a bit of meta

00:48:58,030 --> 00:49:02,350
programming that basically anything that

00:49:00,040 --> 00:49:04,780
returns a void does not break

00:49:02,350 --> 00:49:07,180
it's basically always continue but if

00:49:04,780 --> 00:49:09,070
you want to break in all situations I

00:49:07,180 --> 00:49:11,320
could take the first element for example

00:49:09,070 --> 00:49:14,080
you can also return an integral constant

00:49:11,320 --> 00:49:15,430
of break so you can turn the it break

00:49:14,080 --> 00:49:16,930
into the you know into an integral

00:49:15,430 --> 00:49:19,540
constant return it then will always

00:49:16,930 --> 00:49:21,730
break or usually you will then we just

00:49:19,540 --> 00:49:23,110
return the enum break on continue and it

00:49:21,730 --> 00:49:24,400
controls whether you want to continue

00:49:23,110 --> 00:49:25,600
the iteration or not

00:49:24,400 --> 00:49:27,100
and with the chunk it actually works the

00:49:25,600 --> 00:49:29,560
same way there's there's nothing really

00:49:27,100 --> 00:49:33,310
special about about chunk I mean whether

00:49:29,560 --> 00:49:35,620
the the Pender does something that is

00:49:33,310 --> 00:49:38,140
unnecessary because someone internally

00:49:35,620 --> 00:49:41,020
braked well that's kind of his business

00:49:38,140 --> 00:49:43,180
he has to understand what he is then

00:49:41,020 --> 00:49:45,550
doing so if you were allocate memory

00:49:43,180 --> 00:49:48,130
a lot and later on you decide to break

00:49:45,550 --> 00:49:50,920
well you call this for each with that

00:49:48,130 --> 00:49:52,690
functor yourself so whatever it does is

00:49:50,920 --> 00:49:55,240
kind of your responsibility when you do

00:49:52,690 --> 00:49:59,619
it inside chunk so so it's a chunk as

00:49:55,240 --> 00:50:01,869
well as the the function cooperator

00:49:59,619 --> 00:50:04,510
could return break or continue and

00:50:01,869 --> 00:50:06,670
that's where you control whether to

00:50:04,510 --> 00:50:07,750
break in a very early very naive

00:50:06,670 --> 00:50:10,000
implementation when we throw an

00:50:07,750 --> 00:50:11,680
exception but that's in an ideal world

00:50:10,000 --> 00:50:13,690
at half this is the semantics that you

00:50:11,680 --> 00:50:23,530
want but of course in practicality is

00:50:13,690 --> 00:50:25,300
wait as well so we return no I haven't

00:50:23,530 --> 00:50:30,069
have you done any measurements of cold

00:50:25,300 --> 00:50:43,690
sighs I must say in in brief no yeah I

00:50:30,069 --> 00:50:45,700
think that's complete well I mean am i

00:50:43,690 --> 00:50:46,930
aware of any any other formatting

00:50:45,700 --> 00:50:48,849
libraries that do the deferred

00:50:46,930 --> 00:50:51,839
evaluation if you mean by the further

00:50:48,849 --> 00:50:55,180
evaluation and do kind of the nesting I

00:50:51,839 --> 00:50:58,809
believe the answer is no at least not

00:50:55,180 --> 00:51:03,540
out of the box but I mean of course they

00:50:58,809 --> 00:51:06,069
all do quite extensive concepts for pre

00:51:03,540 --> 00:51:09,490
optimization so I there's no question

00:51:06,069 --> 00:51:12,369
like I know that the that the the curly

00:51:09,490 --> 00:51:14,079
braces format library does pre

00:51:12,369 --> 00:51:15,730
calculates the size for example so I'm

00:51:14,079 --> 00:51:17,710
assuming that for anything for anything

00:51:15,730 --> 00:51:19,319
flat kind of the same thing is going on

00:51:17,710 --> 00:51:21,819
you just calculate the size and then

00:51:19,319 --> 00:51:23,200
really the contribution here is that you

00:51:21,819 --> 00:51:25,210
can do this in a framework you don't

00:51:23,200 --> 00:51:26,619
have to do that in a special case

00:51:25,210 --> 00:51:28,030
function they're just those texts one

00:51:26,619 --> 00:51:31,589
thing is something that you probably

00:51:28,030 --> 00:51:31,589
want in general in your range library

00:51:34,680 --> 00:51:37,680
okay

00:51:42,079 --> 00:51:47,569
I mean for us is it is a complementary

00:51:45,980 --> 00:51:50,690
or competing with a form of curly braces

00:51:47,569 --> 00:51:52,519
format library for us in house it's

00:51:50,690 --> 00:51:55,549
clearly computing we are not going to

00:51:52,519 --> 00:51:58,430
use the curly braces font library is the

00:51:55,549 --> 00:51:59,539
curly braces format library bad no it's

00:51:58,430 --> 00:51:59,990
probably a whole lot better than what we

00:51:59,539 --> 00:52:05,180
had before

00:51:59,990 --> 00:52:07,579
I mean don't use i/o streams so no hard

00:52:05,180 --> 00:52:10,160
feelings but no I mean in in-house we

00:52:07,579 --> 00:52:13,130
will will go we'll do it this way in

00:52:10,160 --> 00:52:14,900
particular because we are only using

00:52:13,130 --> 00:52:15,950
these format strings we frequently use

00:52:14,900 --> 00:52:18,650
the format strange when we do

00:52:15,950 --> 00:52:20,329
translation there's a whole framework in

00:52:18,650 --> 00:52:22,609
the program that extracts the strings

00:52:20,329 --> 00:52:25,549
and delivers out the trend of the

00:52:22,609 --> 00:52:28,730
translation as as constant strings with

00:52:25,549 --> 00:52:30,230
like a Const expert hashing going on so

00:52:28,730 --> 00:52:32,390
that you basically have functions where

00:52:30,230 --> 00:52:35,539
you pull the right translation out and

00:52:32,390 --> 00:52:37,670
and there you don't want that that

00:52:35,539 --> 00:52:39,140
format string to be to be any smart so

00:52:37,670 --> 00:52:40,970
the format string is also written in a

00:52:39,140 --> 00:52:44,180
way that it doesn't do anything crazy of

00:52:40,970 --> 00:52:47,569
things if people mess it up so if it can

00:52:44,180 --> 00:52:49,309
always very well happen that you you

00:52:47,569 --> 00:52:50,779
don't validate everything that you're

00:52:49,309 --> 00:52:51,920
getting from the translators but

00:52:50,779 --> 00:52:53,480
something we have very quick release

00:52:51,920 --> 00:52:54,529
cycle so you get something on translate

00:52:53,480 --> 00:52:57,430
and put it in there and then you

00:52:54,529 --> 00:53:00,410
discover oops my strings messed up and

00:52:57,430 --> 00:53:05,450
that that the damage done should be very

00:53:00,410 --> 00:53:12,589
limited okay

00:53:05,450 --> 00:53:18,019
oh how do you do a locale dependent

00:53:12,589 --> 00:53:23,749
formatting the lesson that we or that

00:53:18,019 --> 00:53:28,579
that we learned from from from our code

00:53:23,749 --> 00:53:32,269
that's that's all I can say is you have

00:53:28,579 --> 00:53:35,299
to decide which look this general idea

00:53:32,269 --> 00:53:37,400
you set a locale and this is your locale

00:53:35,299 --> 00:53:39,470
and this is great now we have it set it

00:53:37,400 --> 00:53:40,400
for all for forever and you don't have

00:53:39,470 --> 00:53:45,140
to think about it anymore

00:53:40,400 --> 00:53:48,380
is is fraud because a program is John

00:53:45,140 --> 00:53:50,569
Connon going to generate text presented

00:53:48,380 --> 00:53:53,200
to the user there you have an idea of a

00:53:50,569 --> 00:53:57,220
other language certainly

00:53:53,200 --> 00:53:59,230
that you said once from some source you

00:53:57,220 --> 00:54:02,200
but you also generate other strings you

00:53:59,230 --> 00:54:04,990
generate strings for Jason for XML four

00:54:02,200 --> 00:54:07,180
four four sudden stuff to whatever in

00:54:04,990 --> 00:54:10,240
text form somewhere and there you may

00:54:07,180 --> 00:54:14,890
want a different locale you may want a

00:54:10,240 --> 00:54:19,300
different a different would say

00:54:14,890 --> 00:54:21,190
convention for comma and a period so we

00:54:19,300 --> 00:54:23,440
actually supply that each and every time

00:54:21,190 --> 00:54:25,480
we don't have any defaults builds into

00:54:23,440 --> 00:54:27,580
the library we would have defaults if

00:54:25,480 --> 00:54:30,670
that would be really ugly I mean if that

00:54:27,580 --> 00:54:32,620
would bother us like hell then then we

00:54:30,670 --> 00:54:34,360
wouldn't do that but if you look at the

00:54:32,620 --> 00:54:35,740
actual use case isn't it that's kind of

00:54:34,360 --> 00:54:38,080
the advantage from having so much a

00:54:35,740 --> 00:54:39,640
million lines of production code you

00:54:38,080 --> 00:54:42,270
really want to think about each and

00:54:39,640 --> 00:54:44,920
every time and we've actually I've seen

00:54:42,270 --> 00:54:47,110
scenarios where just people have done it

00:54:44,920 --> 00:54:48,730
wrong they they just said okay we're

00:54:47,110 --> 00:54:51,100
gonna use something default like it's

00:54:48,730 --> 00:54:52,960
everywhere and then they send something

00:54:51,100 --> 00:54:55,170
with XML but they have a comma in there

00:54:52,960 --> 00:54:57,340
because they happen to be in Germany so

00:54:55,170 --> 00:54:58,960
that's why I'm kind of forcing people to

00:54:57,340 --> 00:55:01,810
decide that on a case-by-case basis the

00:54:58,960 --> 00:55:04,120
same with with dates right I mean if you

00:55:01,810 --> 00:55:06,340
if you format a date you really have to

00:55:04,120 --> 00:55:09,730
distinguish between formatting this for

00:55:06,340 --> 00:55:13,210
someone where you know that he is any

00:55:09,730 --> 00:55:15,670
particular in a particular country and

00:55:13,210 --> 00:55:18,970
you may know this in a varying degree

00:55:15,670 --> 00:55:20,140
like when you have a you come from the

00:55:18,970 --> 00:55:21,790
India where you are on a desktop

00:55:20,140 --> 00:55:23,380
application then you could be pretty

00:55:21,790 --> 00:55:25,480
sure that he understands will be

00:55:23,380 --> 00:55:27,160
exploring those the file explorer the

00:55:25,480 --> 00:55:28,660
file explorer supports a format you can

00:55:27,160 --> 00:55:30,940
pick that format that's pretty sick he's

00:55:28,660 --> 00:55:33,340
understanding that but if you say you

00:55:30,940 --> 00:55:35,500
have an applicant for a developer

00:55:33,340 --> 00:55:38,400
position right and you're kind of

00:55:35,500 --> 00:55:41,650
guessing like where he comes from

00:55:38,400 --> 00:55:43,300
based on this IP address then you may

00:55:41,650 --> 00:55:46,680
not want to give him a date for an

00:55:43,300 --> 00:55:49,330
interview in in like a month day

00:55:46,680 --> 00:55:51,790
representation that that's just there

00:55:49,330 --> 00:55:53,830
you may be wrong there so you really

00:55:51,790 --> 00:55:56,080
have to think about what you know what

00:55:53,830 --> 00:55:57,839
you want in terms of it's not just like

00:55:56,080 --> 00:56:05,660
as simple as said it'll okay

00:55:57,839 --> 00:56:08,069
and then run with it by experience okay

00:56:05,660 --> 00:56:11,759
thank you very much everyone for

00:56:08,069 --> 00:56:12,590
listening and yeah have a great rest of

00:56:11,759 --> 00:56:18,149
the conference

00:56:12,590 --> 00:56:18,149

YouTube URL: https://www.youtube.com/watch?v=uCybqSX1idU


