Title: CppCon 2018: Kris Jusiak “State Machines Battlefield - Naive vs STL vs Boost”
Publication date: 2018-10-02
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
In this session, we will conduct a battle against different ways of implementing state machines in modern C++, each of which has different trade-offs and characteristics. We will use a connection [1] example to measure and compare varied aspects of each solution such as compilation time, run-time performance, memory usage, executable size, and readability. 

In the first round, the Naive solutions will fight against Standard Template Library (STL) solutions. The Naive will be represented by the if/else and switch/enum, both of which could be classed as the 'old school' way of implementing state machines with implicit states defined by booleans and/or enums. On the other side, we will have STL, featured by C++17 - std::variant [2] and the newest addition to C++20 - coroutines [3]. These two can be used to demonstrate a new way of implementing state machines by leveraging modern C++ language features. 

The winner will go on to take on the Boost libraries represented by Boost.Statechart [4] and Boost.MetaStateMachine (MSM) [5]. Both libraries are compliant with Unified Modeling Language (UML) standard [6] and have many additional features such as logging and/or serialization. Whilst Statechart is more run-time, the MSM represents a fully compile-time approach with minimal run-time overhead. 

While our winners are recovering, we will introduce the final contender - [Boost].StateMachineLanguage (SML) library [7] - a C++14 version of Boost.MSM of which I'm the author and claimes to have much faster compilation times then its precursor. We will follow by some 'godbolting' (comparing a generated assembly) [8] of different dispatching techniques (branch, switch, jump table, fold expressions [9]) available in the library to illustrate the main power of the SML - the ability to change the feature set and behavior at compile-time. 

After that, we will return to the final round, where the winner will battle against [Boost].SML. 

At the end of this epic battle, the audience will walk out with a clear understanding of possible state machine implementations, thir trade-offs, and with guidelines of what solutions suit what problems. 

Let's get ready to rumble at CppCon 2018! 

[1]: http://boost-experimental.github.io/sml/embo-2018/images/connection.png 
[2]: http://en.cppreference.com/w/cpp/utility/variant 
[3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf 
[4]: http://www.boost.org/doc/libs/release/doc/html/boost_statechart.html 
[5]: http://www.boost.org/doc/libs/release/doc/html/boost_msm.html 
[6]: https://www.omg.org/spec/UML/2.5.1/PDF 
[7]: https://github.com/boost-experimental/sml(Boost.SML is not an official Boost library) 
[8]: https://godbolt.org/g/HVavPU 
[9]: http://en.cppreference.com/w/cpp/language/fold
— 

Kris Jusiak, Quantlab Financial, LLC
Senior Software Engineer

Kris is a Software Engineer with interest in modern C++ development, especially during compilation time where performance and quality matters. He has experience in industries such as telecommunications, games, and finance as well as being an open source enthusiast and author of the following libraries:
* [Boost].DI - proposed to Boost, C++14 Dependency Injection library - https://github.com/boost-experimental/di
* [Boost].SML - proposed to Boost, C++14 State Machine library - https://github.com/boost-experimental/sml
* [Boost].TE - C++17/C++20 Type Erasure library - https://github.com/boost-experimental/te
* GUnit - C++14 extensions for Google.Mock/Google.Test/Cucumber - https://github.com/cpp-testing/GUnit
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
YouTube URL: https://www.youtube.com/watch?v=yZVby-PuXM0


