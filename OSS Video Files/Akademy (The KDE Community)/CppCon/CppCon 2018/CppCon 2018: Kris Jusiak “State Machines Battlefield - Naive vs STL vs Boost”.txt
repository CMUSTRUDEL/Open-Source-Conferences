Title: CppCon 2018: Kris Jusiak “State Machines Battlefield - Naive vs STL vs Boost”
Publication date: 2018-10-02
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
In this session, we will conduct a battle against different ways of implementing state machines in modern C++, each of which has different trade-offs and characteristics. We will use a connection [1] example to measure and compare varied aspects of each solution such as compilation time, run-time performance, memory usage, executable size, and readability. 

In the first round, the Naive solutions will fight against Standard Template Library (STL) solutions. The Naive will be represented by the if/else and switch/enum, both of which could be classed as the 'old school' way of implementing state machines with implicit states defined by booleans and/or enums. On the other side, we will have STL, featured by C++17 - std::variant [2] and the newest addition to C++20 - coroutines [3]. These two can be used to demonstrate a new way of implementing state machines by leveraging modern C++ language features. 

The winner will go on to take on the Boost libraries represented by Boost.Statechart [4] and Boost.MetaStateMachine (MSM) [5]. Both libraries are compliant with Unified Modeling Language (UML) standard [6] and have many additional features such as logging and/or serialization. Whilst Statechart is more run-time, the MSM represents a fully compile-time approach with minimal run-time overhead. 

While our winners are recovering, we will introduce the final contender - [Boost].StateMachineLanguage (SML) library [7] - a C++14 version of Boost.MSM of which I'm the author and claimes to have much faster compilation times then its precursor. We will follow by some 'godbolting' (comparing a generated assembly) [8] of different dispatching techniques (branch, switch, jump table, fold expressions [9]) available in the library to illustrate the main power of the SML - the ability to change the feature set and behavior at compile-time. 

After that, we will return to the final round, where the winner will battle against [Boost].SML. 

At the end of this epic battle, the audience will walk out with a clear understanding of possible state machine implementations, thir trade-offs, and with guidelines of what solutions suit what problems. 

Let's get ready to rumble at CppCon 2018! 

[1]: http://boost-experimental.github.io/sml/embo-2018/images/connection.png 
[2]: http://en.cppreference.com/w/cpp/utility/variant 
[3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf 
[4]: http://www.boost.org/doc/libs/release/doc/html/boost_statechart.html 
[5]: http://www.boost.org/doc/libs/release/doc/html/boost_msm.html 
[6]: https://www.omg.org/spec/UML/2.5.1/PDF 
[7]: https://github.com/boost-experimental/sml(Boost.SML is not an official Boost library) 
[8]: https://godbolt.org/g/HVavPU 
[9]: http://en.cppreference.com/w/cpp/language/fold
— 

Kris Jusiak, Quantlab Financial, LLC
Senior Software Engineer

Kris is a Software Engineer with interest in modern C++ development, especially during compilation time where performance and quality matters. He has experience in industries such as telecommunications, games, and finance as well as being an open source enthusiast and author of the following libraries:
* [Boost].DI - proposed to Boost, C++14 Dependency Injection library - https://github.com/boost-experimental/di
* [Boost].SML - proposed to Boost, C++14 State Machine library - https://github.com/boost-experimental/sml
* [Boost].TE - C++17/C++20 Type Erasure library - https://github.com/boost-experimental/te
* GUnit - C++14 extensions for Google.Mock/Google.Test/Cucumber - https://github.com/cpp-testing/GUnit
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,280 --> 00:00:08,310
so let me tell you a story why I started

00:00:03,100 --> 00:00:08,310
to care about state machines and try to

00:00:09,000 --> 00:00:15,779
to pick some misconceptions about them

00:00:11,740 --> 00:00:20,470
and that's where we'll start here today

00:00:15,779 --> 00:00:25,439
so but few years I was an intern in a

00:00:20,470 --> 00:00:28,480
company it was a Christmas period time I

00:00:25,439 --> 00:00:30,369
you know I was ready to go back home and

00:00:28,480 --> 00:00:34,930
I noticed that a lot of developers were

00:00:30,369 --> 00:00:37,480
you know really hard working and I asked

00:00:34,930 --> 00:00:39,270
them you know it's a Christmas spirit

00:00:37,480 --> 00:00:42,100
why do you work so hard right now and

00:00:39,270 --> 00:00:44,469
they replied that they have a you know

00:00:42,100 --> 00:00:48,219
contract going the country which doesn't

00:00:44,469 --> 00:00:50,800
have and you know holidays in the

00:00:48,219 --> 00:00:53,110
Christmas so they had to be on call and

00:00:50,800 --> 00:00:56,530
they had to begin into the problems

00:00:53,110 --> 00:00:59,350
possible problems would they may with

00:00:56,530 --> 00:01:01,270
them which they may encounter so you

00:00:59,350 --> 00:01:04,930
know I came back from Christmas I was an

00:01:01,270 --> 00:01:07,390
intern I was working right so when I go

00:01:04,930 --> 00:01:09,549
back I ask them like how did it go they

00:01:07,390 --> 00:01:13,150
said well Chris we had a lot of issues

00:01:09,549 --> 00:01:16,750
and you know specifically one which you

00:01:13,150 --> 00:01:18,700
know it took us all you know all the

00:01:16,750 --> 00:01:21,420
Christmas to start out so they didn't go

00:01:18,700 --> 00:01:24,100
back home they were really annoyed and

00:01:21,420 --> 00:01:27,130
you know it was bad and the problem was

00:01:24,100 --> 00:01:28,689
that just let me just explain the system

00:01:27,130 --> 00:01:30,640
they were working on the system was very

00:01:28,689 --> 00:01:34,210
simple it was just it was just having

00:01:30,640 --> 00:01:37,090
some inputs you know manipulates them

00:01:34,210 --> 00:01:40,659
and had some outputs so not the rocket

00:01:37,090 --> 00:01:47,110
science but the problem was that they

00:01:40,659 --> 00:01:52,960
haven't had proper practices and they

00:01:47,110 --> 00:01:56,229
found that they didn't reset the boolean

00:01:52,960 --> 00:01:58,270
variable in some switch in some loop in

00:01:56,229 --> 00:02:02,259
some form and that was introduced by the

00:01:58,270 --> 00:02:04,710
bad merge request and the conflict so

00:02:02,259 --> 00:02:08,259
you know I learned quite a few things

00:02:04,710 --> 00:02:10,000
out of that the first one well I didn't

00:02:08,259 --> 00:02:12,970
work for that company they worked for

00:02:10,000 --> 00:02:13,630
during the Christmas time the second one

00:02:12,970 --> 00:02:15,820
I learned

00:02:13,630 --> 00:02:17,530
that well they didn't have a good

00:02:15,820 --> 00:02:18,970
practices because they didn't test it

00:02:17,530 --> 00:02:22,450
the way they found the bug it was by

00:02:18,970 --> 00:02:25,720
reviewing the code so they didn't have

00:02:22,450 --> 00:02:27,790
any good practices so again I didn't

00:02:25,720 --> 00:02:32,890
want to work for that company but the

00:02:27,790 --> 00:02:36,280
main problem I learned is that they

00:02:32,890 --> 00:02:38,470
didn't you know have the declarative way

00:02:36,280 --> 00:02:40,960
of expressing the application flow and

00:02:38,470 --> 00:02:46,120
the four they had to compare different

00:02:40,960 --> 00:02:49,600
solutions using the code review the diff

00:02:46,120 --> 00:02:51,840
between the working and staging instead

00:02:49,600 --> 00:02:55,690
of you know being able to figure out

00:02:51,840 --> 00:02:57,100
upfront what was going on so I asked

00:02:55,690 --> 00:02:59,680
them I did why you didn't use the state

00:02:57,100 --> 00:03:01,240
machines for example well I decided that

00:02:59,680 --> 00:03:03,130
performance issues and other issues

00:03:01,240 --> 00:03:05,680
which we you know didn't want to deal

00:03:03,130 --> 00:03:07,600
with so this talk is about how we can

00:03:05,680 --> 00:03:10,960
actually you know clarify those

00:03:07,600 --> 00:03:13,240
misconceptions and hopefully you know

00:03:10,960 --> 00:03:14,860
spread the word about the state machines

00:03:13,240 --> 00:03:17,980
so let's begin

00:03:14,860 --> 00:03:20,110
but first let's introduce a problem so

00:03:17,980 --> 00:03:24,220
if you have a healthy company not the

00:03:20,110 --> 00:03:26,020
one as the one I was working on will get

00:03:24,220 --> 00:03:28,390
the requirements from our product owner

00:03:26,020 --> 00:03:31,900
our flavors have a client let's do that

00:03:28,390 --> 00:03:35,350
in a TDD BDD style so we have a feature

00:03:31,900 --> 00:03:38,880
connection we have a scenario establish

00:03:35,350 --> 00:03:41,950
connection very simple to CP approach so

00:03:38,880 --> 00:03:45,130
given I don't have a connection when I

00:03:41,950 --> 00:03:46,690
receive a request to connect then I

00:03:45,130 --> 00:03:50,170
should try to establish the connection

00:03:46,690 --> 00:03:53,200
when I got an acknowledgement I should

00:03:50,170 --> 00:03:54,910
be connected very simple and easy way of

00:03:53,200 --> 00:03:56,830
defining the requirements we have

00:03:54,910 --> 00:03:59,050
obviously more the requirements than

00:03:56,830 --> 00:04:01,240
that how can we actually implement that

00:03:59,050 --> 00:04:02,560
guy well let's take a look into state

00:04:01,240 --> 00:04:04,810
machines obviously there are different

00:04:02,560 --> 00:04:07,890
ways of doing that but we don't consider

00:04:04,810 --> 00:04:10,720
them in that tack we will talk about

00:04:07,890 --> 00:04:13,720
unified model modeling language is

00:04:10,720 --> 00:04:18,070
everyone familiar with that guy yeah

00:04:13,720 --> 00:04:22,120
Moore was everyone so it's a standard is

00:04:18,070 --> 00:04:24,780
specified in IMG the dark you can read

00:04:22,120 --> 00:04:27,220
it it's I think it's even worse than the

00:04:24,780 --> 00:04:30,400
C++ standard to read so

00:04:27,220 --> 00:04:33,640
I don't advise you to do that but you

00:04:30,400 --> 00:04:39,120
can the a lot of features specified it

00:04:33,640 --> 00:04:41,290
in it so that's useful so our teachers

00:04:39,120 --> 00:04:43,510
scenarios we can actually translate into

00:04:41,290 --> 00:04:47,500
the state machine and how how does it

00:04:43,510 --> 00:04:49,570
look like so I guess everyone have seen

00:04:47,500 --> 00:04:52,690
some pictures like that we have an

00:04:49,570 --> 00:04:56,530
initial state disconnected we have an

00:04:52,690 --> 00:04:58,360
event connect and we and we call the

00:04:56,530 --> 00:05:01,870
establish action and we transit to the

00:04:58,360 --> 00:05:03,850
connection state connecting state and if

00:05:01,870 --> 00:05:07,600
you have for example in connected we

00:05:03,850 --> 00:05:10,900
have the pink event if the guard which

00:05:07,600 --> 00:05:12,760
is in the square bracket is valid we

00:05:10,900 --> 00:05:15,970
call the reset timeout and we stayed in

00:05:12,760 --> 00:05:18,610
that state otherwise we don't call there

00:05:15,970 --> 00:05:21,910
is a timeout and we don't do the

00:05:18,610 --> 00:05:27,430
transition make sense easy to follow

00:05:21,910 --> 00:05:31,830
every one of that so today we'll try to

00:05:27,430 --> 00:05:31,830
implement that guy many different ways

00:05:31,980 --> 00:05:35,710
so we'll take a look into naive

00:05:34,000 --> 00:05:39,220
solutions by naive

00:05:35,710 --> 00:05:42,340
I mean C++ 98 features a files through

00:05:39,220 --> 00:05:45,669
genome inheritance state pattern we'll

00:05:42,340 --> 00:05:46,840
take a look into HDL and STD variant

00:05:45,669 --> 00:05:48,790
might be used to implement state

00:05:46,840 --> 00:05:50,500
machines coyotes might be used to

00:05:48,790 --> 00:05:53,970
implement state machines and we'll also

00:05:50,500 --> 00:05:53,970
take a look into the booze libraries

00:05:55,410 --> 00:05:58,410
oops

00:05:58,960 --> 00:06:02,149
[Music]

00:06:05,240 --> 00:06:09,410
let's first introduce them come on

00:06:07,400 --> 00:06:10,729
implementation we've common across all

00:06:09,410 --> 00:06:11,930
the solutions so that we don't have to

00:06:10,729 --> 00:06:15,500
repeat ourselves all the time

00:06:11,930 --> 00:06:17,840
so the event will be just simple structs

00:06:15,500 --> 00:06:19,669
we can start from that although they may

00:06:17,840 --> 00:06:23,090
have data as well but we don't really

00:06:19,669 --> 00:06:26,150
care about it in our case we have a

00:06:23,090 --> 00:06:29,090
guard one guard is valid it returns true

00:06:26,150 --> 00:06:31,729
by default it takes an event nothing

00:06:29,090 --> 00:06:35,389
special about it we have an action which

00:06:31,729 --> 00:06:37,580
will just print to the output will use

00:06:35,389 --> 00:06:39,440
put just in order to see in the god

00:06:37,580 --> 00:06:41,210
board whether it's inland or not

00:06:39,440 --> 00:06:43,759
otherwise we would have a lot of code

00:06:41,210 --> 00:06:48,919
from esidisi out there are streams which

00:06:43,759 --> 00:06:52,580
we don't really care about sorry for

00:06:48,919 --> 00:06:59,479
that so let's take a look into a naive

00:06:52,580 --> 00:07:06,229
solutions so the first one will be there

00:06:59,479 --> 00:07:08,240
if else you know we'll starting from

00:07:06,229 --> 00:07:11,539
implanted a connection class will have

00:07:08,240 --> 00:07:14,389
obviously free boolean's to represent

00:07:11,539 --> 00:07:16,849
our state's the state will be implicit

00:07:14,389 --> 00:07:20,030
because they'll be implemented in the

00:07:16,849 --> 00:07:24,710
code by default the disconnected state

00:07:20,030 --> 00:07:27,050
is true other other ones are false and

00:07:24,710 --> 00:07:29,960
when in process event which is the

00:07:27,050 --> 00:07:32,719
connect event we verify with the VI in

00:07:29,960 --> 00:07:35,240
this connected state if we are we call

00:07:32,719 --> 00:07:37,639
establish which is the action and after

00:07:35,240 --> 00:07:39,889
that we have to reset all the states

00:07:37,639 --> 00:07:41,810
because that would you learn from the

00:07:39,889 --> 00:07:43,759
story in the beginning that you always

00:07:41,810 --> 00:07:47,630
have to reset all the states just in

00:07:43,759 --> 00:07:49,370
case because you know if you have really

00:07:47,630 --> 00:07:53,240
nested version you might actually forget

00:07:49,370 --> 00:07:59,259
about it and the transition is just you

00:07:53,240 --> 00:08:02,150
know set in the connected 32 what about

00:07:59,259 --> 00:08:03,830
processing the pink we get the connected

00:08:02,150 --> 00:08:06,289
we verify with the we in the connected

00:08:03,830 --> 00:08:09,110
state we verify we check whether the

00:08:06,289 --> 00:08:10,940
state is the guard is valid and we set

00:08:09,110 --> 00:08:16,710
the time timeout and we stay in the

00:08:10,940 --> 00:08:19,780
current state make sense right

00:08:16,710 --> 00:08:21,280
so what about the gold bolt as you

00:08:19,780 --> 00:08:25,030
notice on the left side on the bottom

00:08:21,280 --> 00:08:26,890
there are 64 lines of code not bad not a

00:08:25,030 --> 00:08:29,100
lot of boilerplate and everything is

00:08:26,890 --> 00:08:33,490
very well in line and optimized with

00:08:29,100 --> 00:08:35,620
flux you can see under top so that's

00:08:33,490 --> 00:08:38,260
that's good and why is that optimized

00:08:35,620 --> 00:08:41,440
well is anything else it's really easy

00:08:38,260 --> 00:08:43,900
for compilers to see it through so

00:08:41,440 --> 00:08:49,330
that's a great that's a great thing

00:08:43,900 --> 00:08:51,610
about the valves right so it's in line

00:08:49,330 --> 00:08:55,230
in GCC and in clonk I just want clang

00:08:51,610 --> 00:08:58,540
but this is he produced the same output

00:08:55,230 --> 00:09:00,640
there's no keep usage that's great we

00:08:58,540 --> 00:09:02,410
don't have to care about you know

00:09:00,640 --> 00:09:05,050
sharepoint as unique points or anything

00:09:02,410 --> 00:09:05,830
like that there's a smallish memory

00:09:05,050 --> 00:09:08,140
footprint

00:09:05,830 --> 00:09:11,170
however it's not ideal because we have

00:09:08,140 --> 00:09:14,050
three buildings as a state machine we

00:09:11,170 --> 00:09:18,670
can only be in one state at the given

00:09:14,050 --> 00:09:21,580
time so that's that's a waste it's hard

00:09:18,670 --> 00:09:26,080
to reuse and to illustrate that let's

00:09:21,580 --> 00:09:27,730
see it's so hard to reuse that I guess

00:09:26,080 --> 00:09:31,090
everyone have seen the code when you

00:09:27,730 --> 00:09:32,590
have multiple lives switches and

00:09:31,090 --> 00:09:35,140
everything is nested is like how much

00:09:32,590 --> 00:09:38,050
can you go I don't know it depends on

00:09:35,140 --> 00:09:42,010
your I guess it depends command how many

00:09:38,050 --> 00:09:45,190
spaces use you've used for your taps I

00:09:42,010 --> 00:09:46,450
don't know we can go quite far but yeah

00:09:45,190 --> 00:09:48,520
obviously it's hard to reuse because

00:09:46,450 --> 00:09:52,020
it's hard to implement those guys and

00:09:48,520 --> 00:09:54,160
maintain so doesn't the best solution

00:09:52,020 --> 00:09:56,410
let's take a look into a different one

00:09:54,160 --> 00:10:01,350
which is still very easy and everyone

00:09:56,410 --> 00:10:04,870
probably have seen it switch an enum

00:10:01,350 --> 00:10:07,840
everyone's loved it I guess because it's

00:10:04,870 --> 00:10:11,170
so popular you can see it in any legacy

00:10:07,840 --> 00:10:13,180
code base so it's a good for the state

00:10:11,170 --> 00:10:14,890
machines from the perspective that only

00:10:13,180 --> 00:10:19,240
one state might be active at the given

00:10:14,890 --> 00:10:20,260
time so we use an you know so it's

00:10:19,240 --> 00:10:21,940
pretty much the same as the previous

00:10:20,260 --> 00:10:25,440
solutions instead of boolean variables

00:10:21,940 --> 00:10:29,040
we use the enum state with the three

00:10:25,440 --> 00:10:33,620
disconnected connected and connected

00:10:29,040 --> 00:10:36,449
States disconnected is the default one

00:10:33,620 --> 00:10:40,519
when we process the event instead of if

00:10:36,449 --> 00:10:45,149
we do the switch to handle current state

00:10:40,519 --> 00:10:48,209
by default we break and if you don't now

00:10:45,149 --> 00:10:53,579
default Maya is a Jasmine label so it

00:10:48,209 --> 00:10:55,730
might be put anywhere in the switch in

00:10:53,579 --> 00:11:00,510
case of disconnected we call establish

00:10:55,730 --> 00:11:04,230
we change the state we break nothing

00:11:00,510 --> 00:11:09,630
really spectacular here and the same

00:11:04,230 --> 00:11:12,209
case for for the pink if you are in

00:11:09,630 --> 00:11:17,250
connected we verify their they even is

00:11:12,209 --> 00:11:21,870
valid we set the timeout and we break so

00:11:17,250 --> 00:11:26,399
far so good what about the performance

00:11:21,870 --> 00:11:28,079
of that guy again compile is already

00:11:26,399 --> 00:11:30,510
good in optimizing simple things and

00:11:28,079 --> 00:11:33,750
switches one of the main constructions

00:11:30,510 --> 00:11:36,300
of C++ in which compare is already good

00:11:33,750 --> 00:11:40,560
at so we have sixty five lines of code

00:11:36,300 --> 00:11:43,410
pretty similar to evals and everything

00:11:40,560 --> 00:11:45,839
is optimized very well so that's great

00:11:43,410 --> 00:11:49,440
but what about the switch what's good

00:11:45,839 --> 00:11:53,699
what's bad about it well it's in line

00:11:49,440 --> 00:11:56,610
that's good we fix the issue of the

00:11:53,699 --> 00:11:57,470
memory footprint it's one bite that's

00:11:56,610 --> 00:12:00,720
fantastic

00:11:57,470 --> 00:12:02,990
there's now he abuse it again it's still

00:12:00,720 --> 00:12:06,209
hard to reuse we still have you know a

00:12:02,990 --> 00:12:09,540
lot of nested switches and ifs and force

00:12:06,209 --> 00:12:13,980
and everything like that it will be hard

00:12:09,540 --> 00:12:16,620
to add a new state and maintain that so

00:12:13,980 --> 00:12:19,949
in a sense like you know you code for

00:12:16,620 --> 00:12:22,170
six minute and debug for six hours even

00:12:19,949 --> 00:12:24,420
with the good test coverage it might be

00:12:22,170 --> 00:12:25,589
difficult to find those bugs so yeah

00:12:24,420 --> 00:12:30,930
maybe that's not the best solution

00:12:25,589 --> 00:12:35,010
either let's try a different one we all

00:12:30,930 --> 00:12:38,370
know that object-oriented design is

00:12:35,010 --> 00:12:39,430
great right we can use short pointers

00:12:38,370 --> 00:12:45,880
everywhere

00:12:39,430 --> 00:12:47,720
throw them away so yeah let's do it

00:12:45,880 --> 00:12:52,160
because you know we care about the

00:12:47,720 --> 00:12:55,370
performance so yeah we'll see

00:12:52,160 --> 00:12:59,200
so we have our state which is an

00:12:55,370 --> 00:13:01,820
interface and with you know a lot of

00:12:59,200 --> 00:13:07,480
process event for all the events we can

00:13:01,820 --> 00:13:07,480
handle and after that we implement it

00:13:10,540 --> 00:13:16,480
per state on per state basis that's the

00:13:13,760 --> 00:13:19,160
thing which actually gives us a lot of a

00:13:16,480 --> 00:13:23,090
lot of goodness because we can implement

00:13:19,160 --> 00:13:25,520
a state transition we can added state

00:13:23,090 --> 00:13:28,700
and transitions to it without changing

00:13:25,520 --> 00:13:30,650
the connection itself so that's that's

00:13:28,700 --> 00:13:32,930
valuable it means that a lot of teams

00:13:30,650 --> 00:13:36,860
can work on different transitions and

00:13:32,930 --> 00:13:39,650
you know combine them together so that's

00:13:36,860 --> 00:13:41,600
positive so how do we do that we have a

00:13:39,650 --> 00:13:45,140
disconnected state we inherit from the

00:13:41,600 --> 00:13:46,520
state we have the constructor well we

00:13:45,140 --> 00:13:51,200
have the connections we have to pass

00:13:46,520 --> 00:13:53,210
through and in case of Connect notice

00:13:51,200 --> 00:13:55,040
that I use final here because that'll be

00:13:53,210 --> 00:13:58,790
important for the dividual is Asian's

00:13:55,040 --> 00:14:00,710
possible the virtualization and we

00:13:58,790 --> 00:14:02,390
change the state to connecting it's

00:14:00,710 --> 00:14:04,160
pretty much the same implementation as

00:14:02,390 --> 00:14:09,980
we've seen before just a bit different

00:14:04,160 --> 00:14:12,350
way the same about the ping we have to

00:14:09,980 --> 00:14:16,640
implement here the pink and probably

00:14:12,350 --> 00:14:18,080
also other events to satisfy our you

00:14:16,640 --> 00:14:20,930
know requirements from the UML state

00:14:18,080 --> 00:14:28,970
machine which we described before but

00:14:20,930 --> 00:14:33,920
all in all it's very simple sorry it's

00:14:28,970 --> 00:14:36,170
plain what about the performance well we

00:14:33,920 --> 00:14:39,860
have a bit more lines of code because

00:14:36,170 --> 00:14:41,930
well it's object-oriented design we

00:14:39,860 --> 00:14:46,310
write a lot of code polyploid code just

00:14:41,930 --> 00:14:47,270
to satisfy the design and unfortunately

00:14:46,310 --> 00:14:50,210
we have the vtable

00:14:47,270 --> 00:14:52,300
it wasn't the virtualized although we

00:14:50,210 --> 00:14:55,750
had final we have

00:14:52,300 --> 00:15:01,690
for clonk and GCC we have around 220

00:14:55,750 --> 00:15:03,880
lines not ideal not perfect and I'm

00:15:01,690 --> 00:15:08,230
using the newest clang and the new HTC

00:15:03,880 --> 00:15:09,550
see here and all the examples are you

00:15:08,230 --> 00:15:13,200
know all the cobalt you can check them

00:15:09,550 --> 00:15:13,200
out yourself and experiment if you want

00:15:13,350 --> 00:15:20,140
so what's good about the state pattern

00:15:16,620 --> 00:15:22,870
as I said it's easy to reuse an extent

00:15:20,140 --> 00:15:25,870
because we can add the states quite

00:15:22,870 --> 00:15:28,990
easily by you know just adding a state

00:15:25,870 --> 00:15:31,150
in Hertz from the interface and does add

00:15:28,990 --> 00:15:33,550
your transitions you want that's cool

00:15:31,150 --> 00:15:36,820
it's object-oriented that's what we want

00:15:33,550 --> 00:15:39,040
from it the highest memory footprint

00:15:36,820 --> 00:15:43,930
because we have to allocate everything

00:15:39,040 --> 00:15:46,750
on the heap which we have to use and we

00:15:43,930 --> 00:15:48,280
have dynamic allocations all over the

00:15:46,750 --> 00:15:53,770
place probably shared pointers unique

00:15:48,280 --> 00:15:56,770
pointers all the goodness but because of

00:15:53,770 --> 00:15:59,740
that it's not inlined it's not even the

00:15:56,770 --> 00:16:03,990
virtualized in our case so that's bad

00:15:59,740 --> 00:16:07,330
because we care about the performance so

00:16:03,990 --> 00:16:09,520
although this guy is pretty good from

00:16:07,330 --> 00:16:10,750
the you know developer perspective it's

00:16:09,520 --> 00:16:12,130
not really good from the production

00:16:10,750 --> 00:16:16,620
perspective because it doesn't give us

00:16:12,130 --> 00:16:16,620
what we are really what we really need

00:16:17,460 --> 00:16:23,860
so okay so it's come through the naive

00:16:20,440 --> 00:16:26,020
solution quite quickly nothing nothing

00:16:23,860 --> 00:16:30,130
really new about it let's take a look

00:16:26,020 --> 00:16:33,220
into something else it's like if I have

00:16:30,130 --> 00:16:35,560
to if I could pick one thing which C++

00:16:33,220 --> 00:16:37,750
is really good for I'd say is the

00:16:35,560 --> 00:16:41,800
writing libraries and one of the best

00:16:37,750 --> 00:16:47,950
libraries available is C STL I hope you

00:16:41,800 --> 00:16:51,640
agree with that and since C++ 17 and C++

00:16:47,950 --> 00:16:54,840
20 we have at least two new ways of

00:16:51,640 --> 00:16:54,840
implementing state machines

00:16:57,340 --> 00:17:07,390
one of them is STD variant everyone is

00:17:00,610 --> 00:17:10,569
using us to do variant who likes it yeah

00:17:07,390 --> 00:17:17,130
it seems like half half of the crowd

00:17:10,569 --> 00:17:19,870
I think it's very powerful idea maybe

00:17:17,130 --> 00:17:22,150
maybe we'll see how how powerful might

00:17:19,870 --> 00:17:25,000
be used how powerful it might be used

00:17:22,150 --> 00:17:26,530
for the state machines so here

00:17:25,000 --> 00:17:29,830
let's take a look interconnection wiki

00:17:26,530 --> 00:17:34,210
we go back to the one connection class

00:17:29,830 --> 00:17:38,830
instead of having it per state and right

00:17:34,210 --> 00:17:42,520
now the state's implemented using just

00:17:38,830 --> 00:17:44,230
you know types and strikes which is very

00:17:42,520 --> 00:17:46,600
powerful for us because they can have

00:17:44,230 --> 00:17:50,050
data which we couldn't have before when

00:17:46,600 --> 00:17:54,040
we used innum for example or a boolean

00:17:50,050 --> 00:17:57,190
variable so keep in mind that although

00:17:54,040 --> 00:17:59,470
we won't have an example here we can

00:17:57,190 --> 00:18:02,320
have the data for the states which may

00:17:59,470 --> 00:18:05,020
have a different different stuff in it

00:18:02,320 --> 00:18:07,090
so disconnected may not have anything

00:18:05,020 --> 00:18:10,240
but when we connected we can have an IP

00:18:07,090 --> 00:18:13,210
specific IP which will be just active

00:18:10,240 --> 00:18:16,540
and available for us to use when we are

00:18:13,210 --> 00:18:20,470
in that state because variant might be

00:18:16,540 --> 00:18:23,650
only in one given state as well so that

00:18:20,470 --> 00:18:26,080
might be very handy for us and we and we

00:18:23,650 --> 00:18:29,670
and we declared the variant as as the

00:18:26,080 --> 00:18:34,470
state with the disconnected by default

00:18:29,670 --> 00:18:37,540
how do we actually handle the the

00:18:34,470 --> 00:18:41,200
transitions what we have to do the visit

00:18:37,540 --> 00:18:45,540
on it overload overload is just an idea

00:18:41,200 --> 00:18:49,660
and I it's proposed for C++ 22 choose

00:18:45,540 --> 00:18:52,690
which lambda to call so we don't have to

00:18:49,660 --> 00:18:56,710
you know implement a lot of boilerplate

00:18:52,690 --> 00:18:58,840
to satisfy that we could use the generic

00:18:56,710 --> 00:19:00,970
one and use if concepts for example if

00:18:58,840 --> 00:19:04,270
you want but overload seems to be

00:19:00,970 --> 00:19:07,150
cleaner in that case so if you if you

00:19:04,270 --> 00:19:09,310
get the disconnected it means that we

00:19:07,150 --> 00:19:10,410
ended disconnected state and we got the

00:19:09,310 --> 00:19:15,390
connect event

00:19:10,410 --> 00:19:17,910
the same I guess all of you can see the

00:19:15,390 --> 00:19:21,180
similarity to previous solutions so we

00:19:17,910 --> 00:19:24,620
call establish and we change the state

00:19:21,180 --> 00:19:27,450
to connecting Dupree the next case is

00:19:24,620 --> 00:19:29,850
just to satisfy the compiler because

00:19:27,450 --> 00:19:32,580
it's generated compile time so we have

00:19:29,850 --> 00:19:35,840
to you know call it for all the events

00:19:32,580 --> 00:19:38,700
all the states possible so in case of

00:19:35,840 --> 00:19:40,650
connecting and connected we just discard

00:19:38,700 --> 00:19:48,630
those guys because we don't care about

00:19:40,650 --> 00:19:51,240
them in that transition make sense so

00:19:48,630 --> 00:19:54,810
what about the ping in the pink we have

00:19:51,240 --> 00:19:59,940
actually very similar but even an easier

00:19:54,810 --> 00:20:01,560
way of doing it we can just verify what

00:19:59,940 --> 00:20:03,900
I mean connected states using get if

00:20:01,560 --> 00:20:07,440
which is the part of the interface of

00:20:03,900 --> 00:20:10,020
STD variant verify whether the guard is

00:20:07,440 --> 00:20:12,750
valid and satisfied and there is a

00:20:10,020 --> 00:20:14,940
timeout being called afterwards we

00:20:12,750 --> 00:20:21,110
stayed in the same state so there is no

00:20:14,940 --> 00:20:24,180
issue here what about the performance

00:20:21,110 --> 00:20:29,160
from the god bald and the newest and

00:20:24,180 --> 00:20:32,340
greatest STD leap and Clank 7 we

00:20:29,160 --> 00:20:36,930
actually get it been in line so that's

00:20:32,340 --> 00:20:38,100
fantastic it's not as good for GCC GCC

00:20:36,930 --> 00:20:41,970
doesn't inline it at all

00:20:38,100 --> 00:20:46,770
it's 140 lines of generated assembly

00:20:41,970 --> 00:20:48,810
with mysterious V table being there we

00:20:46,770 --> 00:20:51,090
have 70 lines of code to implement that

00:20:48,810 --> 00:20:52,770
so all of the you know the

00:20:51,090 --> 00:20:54,540
implementation is very similar to the

00:20:52,770 --> 00:20:57,240
previous Aleutians as you could probably

00:20:54,540 --> 00:21:00,060
see it's very similar to sweden enum

00:20:57,240 --> 00:21:05,000
instead of eNOS with as you types which

00:21:00,060 --> 00:21:05,000
gives us our I and a lot of benefits

00:21:07,510 --> 00:21:17,110
so if you sum up the variant it's quite

00:21:14,290 --> 00:21:19,960
small memory footprint because we use

00:21:17,110 --> 00:21:22,750
distract the strike is one byte so if

00:21:19,960 --> 00:21:26,440
you start the variant we serve the max

00:21:22,750 --> 00:21:28,750
size of all the states which by default

00:21:26,440 --> 00:21:31,300
would be let's say 1 byte in our case

00:21:28,750 --> 00:21:34,750
because we just have them distract plus

00:21:31,300 --> 00:21:38,170
we have to store something to to know

00:21:34,750 --> 00:21:39,310
you know which one is actually active so

00:21:38,170 --> 00:21:43,150
that depends on the compare

00:21:39,310 --> 00:21:46,870
implementation at 1 P 1 byte 8 bytes

00:21:43,150 --> 00:21:48,670
whatever but the footprint will be quite

00:21:46,870 --> 00:21:51,190
small and it'll be really efficient

00:21:48,670 --> 00:21:53,170
because we can use those tracks to add

00:21:51,190 --> 00:21:55,840
the data to it so for example we can

00:21:53,170 --> 00:22:01,000
have an IDE or last ping or whatever we

00:21:55,840 --> 00:22:03,340
need for those guys so that's handy also

00:22:01,000 --> 00:22:06,880
very and integrates very well with the

00:22:03,340 --> 00:22:09,160
expected and studying exceptions ideas

00:22:06,880 --> 00:22:11,940
because we can actually return an error

00:22:09,160 --> 00:22:14,950
which is just part of the variant or

00:22:11,940 --> 00:22:17,380
expected type with some you know error

00:22:14,950 --> 00:22:20,410
case which we couldn't do before

00:22:17,380 --> 00:22:22,720
I won't be talking here is like we have

00:22:20,410 --> 00:22:26,170
exceptions in a disabled in our cases

00:22:22,720 --> 00:22:28,150
just for the performance reasons but you

00:22:26,170 --> 00:22:32,170
know error handling is quite important

00:22:28,150 --> 00:22:35,470
and handling the errors in in in amor

00:22:32,170 --> 00:22:37,030
switch it's not ideal we probably would

00:22:35,470 --> 00:22:40,500
end up from an exceptions or something

00:22:37,030 --> 00:22:42,400
like that or using the return code or

00:22:40,500 --> 00:22:44,380
global variables or something like that

00:22:42,400 --> 00:22:47,580
with variant we actually don't have to

00:22:44,380 --> 00:22:50,350
do that we can return something

00:22:47,580 --> 00:22:57,370
unexpected which is which is nice which

00:22:50,350 --> 00:23:01,540
is good in its inland on clunk that's

00:22:57,370 --> 00:23:04,960
good it's not in mind on GCC I guess

00:23:01,540 --> 00:23:07,390
that bad but but yeah it's there is

00:23:04,960 --> 00:23:11,080
still room for improvement and it's

00:23:07,390 --> 00:23:13,000
quite quite a decent solution for for

00:23:11,080 --> 00:23:15,100
the simple state machines it doesn't

00:23:13,000 --> 00:23:17,290
offer a lot of you know capabilities

00:23:15,100 --> 00:23:18,720
besides simple transitions but it's

00:23:17,290 --> 00:23:21,000
still very useful and

00:23:18,720 --> 00:23:24,929
having the efficient memory footprint is

00:23:21,000 --> 00:23:26,820
quite quite nee quite quite neat it's

00:23:24,929 --> 00:23:29,880
quite hard to reuse though because it's

00:23:26,820 --> 00:23:32,220
very similar to the switch and enum

00:23:29,880 --> 00:23:35,549
approach so we have to you know if you

00:23:32,220 --> 00:23:37,020
have nested state machines like calculus

00:23:35,549 --> 00:23:39,059
state machines or composite state

00:23:37,020 --> 00:23:42,270
machine we'll have to have a visit

00:23:39,059 --> 00:23:44,190
inside the visit inside the visit you

00:23:42,270 --> 00:23:52,100
see the pattern it's not much better

00:23:44,190 --> 00:23:58,770
than if else if else if else right okay

00:23:52,100 --> 00:24:01,620
so let's get to the good part and the

00:23:58,770 --> 00:24:05,360
newest part we can actually use in c

00:24:01,620 --> 00:24:12,030
plus plus 20 so curtains curtains a a

00:24:05,360 --> 00:24:18,120
new way of implementing state machines

00:24:12,030 --> 00:24:21,630
as well in c++ 20 has anyone experienced

00:24:18,120 --> 00:24:23,789
the curtains software try them out yeah

00:24:21,630 --> 00:24:28,919
quite a few hand not a lot of hands

00:24:23,789 --> 00:24:33,200
actually so yeah curtains will try to

00:24:28,919 --> 00:24:38,370
dig it a bit more into them in a sec so

00:24:33,200 --> 00:24:40,470
notice that in our case the the

00:24:38,370 --> 00:24:43,590
connection won't be as tracked anymore

00:24:40,470 --> 00:24:45,299
it's not that type it's a function so

00:24:43,590 --> 00:24:47,000
that's the first difference between

00:24:45,299 --> 00:24:49,140
co-routines

00:24:47,000 --> 00:24:53,730
when using curtains as a state machine

00:24:49,140 --> 00:24:56,100
because before because curtains are

00:24:53,730 --> 00:25:00,080
functions it's they're called resumable

00:24:56,100 --> 00:25:04,080
functions and we can use them to

00:25:00,080 --> 00:25:06,000
basically as a functions so notice on

00:25:04,080 --> 00:25:10,770
the line the second line we have the for

00:25:06,000 --> 00:25:12,419
infinite for loop but that's alright

00:25:10,770 --> 00:25:15,000
what we would have infinite for loop

00:25:12,419 --> 00:25:18,120
well we need that guy because we can

00:25:15,000 --> 00:25:21,480
actually use the curtains to resume and

00:25:18,120 --> 00:25:24,630
suspend and that's where the Kuwait is

00:25:21,480 --> 00:25:28,559
for and if you don't get an event which

00:25:24,630 --> 00:25:32,130
we which we want we want to come back do

00:25:28,559 --> 00:25:35,670
the loop and suspend again in the code

00:25:32,130 --> 00:25:39,300
wait it's a different way of thinking

00:25:35,670 --> 00:25:41,790
but you know you can think of it like

00:25:39,300 --> 00:25:44,970
the state is the position in the

00:25:41,790 --> 00:25:48,420
functions when we in the function you

00:25:44,970 --> 00:25:51,510
know code in a sense where we are so

00:25:48,420 --> 00:25:55,140
here on the third line we have the color

00:25:51,510 --> 00:25:57,690
white we wait on the event if we get it

00:25:55,140 --> 00:26:00,840
and the event is the connect we do

00:25:57,690 --> 00:26:03,300
establish and we go further which means

00:26:00,840 --> 00:26:07,890
that we'll be in the further in the

00:26:03,300 --> 00:26:10,650
function if we don't get event which we

00:26:07,890 --> 00:26:13,830
satisfied we do the loop and co-ed will

00:26:10,650 --> 00:26:19,190
suspend again and wait for it to be

00:26:13,830 --> 00:26:22,290
resumed by by a process event call

00:26:19,190 --> 00:26:24,360
notice that I'm using here a single

00:26:22,290 --> 00:26:27,780
further application these curtains are

00:26:24,360 --> 00:26:30,600
you know often associated with a

00:26:27,780 --> 00:26:33,270
synchronous ideas but you can use them

00:26:30,600 --> 00:26:37,470
in the synchronous way very efficiently

00:26:33,270 --> 00:26:39,480
as well so there's nothing about being

00:26:37,470 --> 00:26:41,580
here like multi-threaded environment or

00:26:39,480 --> 00:26:44,040
something like that it could be could be

00:26:41,580 --> 00:26:45,570
the case but it's not in our case so

00:26:44,040 --> 00:26:49,350
that's very important so you can use

00:26:45,570 --> 00:26:53,040
curtains in a single threaded way so

00:26:49,350 --> 00:26:56,130
right now we do a second loop because we

00:26:53,040 --> 00:26:57,780
want to you know be a bit further in the

00:26:56,130 --> 00:26:59,730
function we never come back to the first

00:26:57,780 --> 00:27:02,550
loop again in our case for example

00:26:59,730 --> 00:27:05,190
because we transit a bit further and

00:27:02,550 --> 00:27:07,560
right now we stay here because when we

00:27:05,190 --> 00:27:10,650
are assumed we are assumed from the car

00:27:07,560 --> 00:27:13,980
weight which is on the second line on

00:27:10,650 --> 00:27:19,350
the second part we won't be resumed you

00:27:13,980 --> 00:27:20,640
know before that guy so so so I hope I'm

00:27:19,350 --> 00:27:22,380
trying to make it clear but it's like

00:27:20,640 --> 00:27:24,300
it's really hard to think of it if you

00:27:22,380 --> 00:27:26,580
don't know what the curtains are we are

00:27:24,300 --> 00:27:29,310
going to be resumed from the car wait

00:27:26,580 --> 00:27:32,430
call in that place we won't be zoomed

00:27:29,310 --> 00:27:33,900
anywhere else so we do the loop because

00:27:32,430 --> 00:27:36,630
we have to verify whatever we only

00:27:33,900 --> 00:27:40,830
established whether we got an

00:27:36,630 --> 00:27:44,870
established event or not I hope that

00:27:40,830 --> 00:27:44,870
makes sense there's a question

00:27:44,990 --> 00:27:49,140
the question is what is the end label

00:27:47,640 --> 00:27:52,760
for and that will allow us to figure out

00:27:49,140 --> 00:27:55,650
in a sec because we need it for that guy

00:27:52,760 --> 00:27:58,700
so as you see we have a lot of for loops

00:27:55,650 --> 00:28:03,320
and the best way to get out of the

00:27:58,700 --> 00:28:07,190
nested for loop these two is go to write

00:28:03,320 --> 00:28:13,800
so I hope that answering a question that

00:28:07,190 --> 00:28:15,780
you know to get to the end you know it's

00:28:13,800 --> 00:28:17,520
a different way of thinking but you have

00:28:15,780 --> 00:28:22,230
to think of it it's like we have

00:28:17,520 --> 00:28:25,080
dysfunctions we are in the position at

00:28:22,230 --> 00:28:28,860
some point in that function we are

00:28:25,080 --> 00:28:31,230
assumed from the point the choroid was

00:28:28,860 --> 00:28:34,650
being called and after that we react on

00:28:31,230 --> 00:28:36,690
the event and all this hassle with a

00:28:34,650 --> 00:28:39,929
continue break and go to is just to go

00:28:36,690 --> 00:28:41,429
to the difference for loop part of the

00:28:39,929 --> 00:28:45,210
function because we always stayed in

00:28:41,429 --> 00:28:46,650
that function so yeah it is possible

00:28:45,210 --> 00:28:48,350
with the curtains daddy

00:28:46,650 --> 00:28:51,720
specific condition is quite difficult

00:28:48,350 --> 00:28:55,950
but as was mentioned we is go to so

00:28:51,720 --> 00:28:58,530
maybe states are really implicit here by

00:28:55,950 --> 00:29:01,470
the way as you notice I I pointed them

00:28:58,530 --> 00:29:03,270
with arrows because we don't really need

00:29:01,470 --> 00:29:06,090
to know the state because the state is

00:29:03,270 --> 00:29:09,120
represented by where we added the

00:29:06,090 --> 00:29:11,190
function which is like intriguing right

00:29:09,120 --> 00:29:16,020
it's not really what we actually think

00:29:11,190 --> 00:29:17,309
of States but maybe maybe we would like

00:29:16,020 --> 00:29:20,220
to take a look into that a bit further

00:29:17,309 --> 00:29:22,320
so what about the performance we have

00:29:20,220 --> 00:29:25,770
more code it's more boilerplate code to

00:29:22,320 --> 00:29:27,780
implement by default because we don't

00:29:25,770 --> 00:29:30,420
have all these facilities coatings are

00:29:27,780 --> 00:29:32,570
implemented in the core language but we

00:29:30,420 --> 00:29:36,840
will have quite a bit of hassle to

00:29:32,570 --> 00:29:38,460
satisfy the interfaces you can check it

00:29:36,840 --> 00:29:41,190
a god bolt and should try it out the

00:29:38,460 --> 00:29:42,510
interface is quite difficult to deal

00:29:41,190 --> 00:29:44,880
with therefore there are different

00:29:42,510 --> 00:29:49,110
proposals how to deal with it however it

00:29:44,880 --> 00:29:50,880
wasn't optimized very well order

00:29:49,110 --> 00:29:53,100
coatings can be optimized especially

00:29:50,880 --> 00:29:55,929
yield might be optimized very well than

00:29:53,100 --> 00:30:01,720
the generators the color it seems not

00:29:55,929 --> 00:30:06,610
and we play for the HIPAA locations not

00:30:01,720 --> 00:30:08,440
great so to sum up the courteous

00:30:06,610 --> 00:30:10,240
what is it good about it the structured

00:30:08,440 --> 00:30:13,419
code is actually really really neat

00:30:10,240 --> 00:30:17,080
right we can use ifs else force my

00:30:13,419 --> 00:30:18,970
before loop not especially in the way we

00:30:17,080 --> 00:30:21,820
would like to but we can still use them

00:30:18,970 --> 00:30:23,529
so for you know everyone who is new to

00:30:21,820 --> 00:30:26,080
the language doesn't have to you you

00:30:23,529 --> 00:30:26,409
know learn libraries or anything like

00:30:26,080 --> 00:30:27,820
that

00:30:26,409 --> 00:30:30,129
they may just you know use the language

00:30:27,820 --> 00:30:32,799
and just have to understand the code way

00:30:30,129 --> 00:30:37,330
it will resume you at at the point you

00:30:32,799 --> 00:30:39,580
were suspended pretty cool as I pointed

00:30:37,330 --> 00:30:41,379
out you can use it in a synchronous

00:30:39,580 --> 00:30:43,210
environment but you can also use it in a

00:30:41,379 --> 00:30:45,580
synchronous environment very easily

00:30:43,210 --> 00:30:46,929
which is not really a case with an elder

00:30:45,580 --> 00:30:50,649
solution which I will be present here

00:30:46,929 --> 00:30:53,470
presented here this is a learning curve

00:30:50,649 --> 00:30:53,980
to it definitely is different way of

00:30:53,470 --> 00:30:58,210
thinking

00:30:53,980 --> 00:31:01,090
so yeah you have to get used to it might

00:30:58,210 --> 00:31:04,809
be worth it requires a hip that might be

00:31:01,090 --> 00:31:05,950
not the case in the future I don't know

00:31:04,809 --> 00:31:07,809
I just checked out the clonk

00:31:05,950 --> 00:31:11,470
implementation because this is he

00:31:07,809 --> 00:31:15,480
doesn't support co-routines I'm sorry I

00:31:11,470 --> 00:31:18,059
didn't bother with Visual Studio but I

00:31:15,480 --> 00:31:20,470
wouldn't expect it to be faster than

00:31:18,059 --> 00:31:22,299
clunky implementation even Gore said

00:31:20,470 --> 00:31:24,159
that the EMA

00:31:22,299 --> 00:31:28,929
as received by the most experimental and

00:31:24,159 --> 00:31:31,269
Clank is doing it right so it was an

00:31:28,929 --> 00:31:34,269
ally death unfortunate we have these

00:31:31,269 --> 00:31:38,110
implicit states which is good and bad it

00:31:34,269 --> 00:31:39,519
depends how you look at it as you know

00:31:38,110 --> 00:31:41,590
depending on where we are in the

00:31:39,519 --> 00:31:44,190
function we know whether we end the

00:31:41,590 --> 00:31:49,119
given state or not that's good or bad

00:31:44,190 --> 00:31:52,450
it depends and the co way it retains a

00:31:49,119 --> 00:31:53,860
type so it has to be a common type sort

00:31:52,450 --> 00:31:55,720
of right because we cannot return

00:31:53,860 --> 00:31:58,419
different types unless we is very under

00:31:55,720 --> 00:32:02,980
something like that so so that's not

00:31:58,419 --> 00:32:06,359
ideal either and I have to admit do

00:32:02,980 --> 00:32:06,359
these four loops are quite weird

00:32:09,559 --> 00:32:19,350
okay so let's just do the go to just for

00:32:14,309 --> 00:32:21,210
the fun of it because we can so it's

00:32:19,350 --> 00:32:23,640
pretty much the same example instead of

00:32:21,210 --> 00:32:25,980
having the four loops we need the first

00:32:23,640 --> 00:32:30,330
four loop because the the state machine

00:32:25,980 --> 00:32:32,460
has to you know go forever but besides

00:32:30,330 --> 00:32:38,549
that we don't need them instead we can

00:32:32,460 --> 00:32:40,470
have labels if you really want this

00:32:38,549 --> 00:32:43,110
connected label may means disconnected

00:32:40,470 --> 00:32:46,710
state connecting label is a connecting

00:32:43,110 --> 00:32:48,990
state gonna connect yeah and basically

00:32:46,710 --> 00:32:50,909
after that we go to the connected state

00:32:48,990 --> 00:32:54,049
which is everything is just described by

00:32:50,909 --> 00:32:58,169
the label and after that we can do go to

00:32:54,049 --> 00:33:01,950
which seamlessly quite even more need

00:32:58,169 --> 00:33:05,159
when you know that's the way we you know

00:33:01,950 --> 00:33:06,590
exit the loops if you have really nested

00:33:05,159 --> 00:33:10,139
ones and we don't want to do the

00:33:06,590 --> 00:33:12,330
checking of the boolean's well that's a

00:33:10,139 --> 00:33:14,010
good solution either now but it's

00:33:12,330 --> 00:33:14,669
definitely valuable solutions with

00:33:14,010 --> 00:33:20,909
co-routines

00:33:14,669 --> 00:33:22,590
it seems like a function you know

00:33:20,909 --> 00:33:25,679
changing the position in the function

00:33:22,590 --> 00:33:28,169
might be use with their go-to please

00:33:25,679 --> 00:33:29,880
don't quote me on that that I'm not

00:33:28,169 --> 00:33:32,399
saying they go to is the the solution

00:33:29,880 --> 00:33:34,350
here I'm just saying there's an option

00:33:32,399 --> 00:33:42,500
you can explore it yourself

00:33:34,350 --> 00:33:45,659
and yeah so if it comes to performance

00:33:42,500 --> 00:33:50,039
still the same amount of code basically

00:33:45,659 --> 00:33:53,279
we still have allocations didn't help

00:33:50,039 --> 00:33:57,870
with that we didn't expect go to to help

00:33:53,279 --> 00:34:00,240
with allocations though I hope so what

00:33:57,870 --> 00:34:03,000
about the summary we don't have these

00:34:00,240 --> 00:34:06,120
infinite loops anymore pretty cool we

00:34:03,000 --> 00:34:09,060
didn't like them we have explicit states

00:34:06,120 --> 00:34:12,300
which we you know can treat as a

00:34:09,060 --> 00:34:15,210
positive or negative depends whether we

00:34:12,300 --> 00:34:17,909
liked it before or now and we had to go

00:34:15,210 --> 00:34:18,360
to and they started about to go to you

00:34:17,909 --> 00:34:21,230
know

00:34:18,360 --> 00:34:24,150
and you never know where you end up

00:34:21,230 --> 00:34:26,630
before maybe go to it's not the best

00:34:24,150 --> 00:34:26,630
idea

00:34:29,360 --> 00:34:35,160
one more different variant we can use we

00:34:32,640 --> 00:34:39,990
can use curtains with functions and

00:34:35,160 --> 00:34:44,460
variant so if you think about the

00:34:39,990 --> 00:34:46,440
disconnected state as a function we can

00:34:44,460 --> 00:34:52,740
actually go come back to our follow if

00:34:46,440 --> 00:34:55,560
you look sorry about that and just have

00:34:52,740 --> 00:34:57,690
the state being represented as a

00:34:55,560 --> 00:35:01,610
function separate functions and use the

00:34:57,690 --> 00:35:03,780
Curie turn to go to the different state

00:35:01,610 --> 00:35:06,990
which is quite handy because we can

00:35:03,780 --> 00:35:09,750
separate the functions it's pretty much

00:35:06,990 --> 00:35:11,790
the same for any other event state

00:35:09,750 --> 00:35:15,930
transition we want so you have a

00:35:11,790 --> 00:35:21,810
connected state which uses the for loop

00:35:15,930 --> 00:35:26,240
for the same reasons as before and we

00:35:21,810 --> 00:35:26,240
just the question

00:35:31,619 --> 00:35:38,160
right so the question is where is the in

00:35:34,570 --> 00:35:41,680
so those guys are part of the connected

00:35:38,160 --> 00:35:44,610
class which has an in sorry about it so

00:35:41,680 --> 00:35:48,510
yeah we actually in the Abbott hyroscope

00:35:44,610 --> 00:35:52,420
we could possibly pass the end into the

00:35:48,510 --> 00:35:55,450
into the our functions but yeah it's

00:35:52,420 --> 00:35:59,050
basically we have a connection class

00:35:55,450 --> 00:36:03,670
which has an in as an variable and we

00:35:59,050 --> 00:36:11,260
can use those guys like that so yeah

00:36:03,670 --> 00:36:13,240
that's very neat performance didn't help

00:36:11,260 --> 00:36:16,360
actually made it worse because the

00:36:13,240 --> 00:36:19,480
variant we use the variant to have the

00:36:16,360 --> 00:36:22,000
different types of the return of Kuwait

00:36:19,480 --> 00:36:23,530
because we couldn't deal with their

00:36:22,000 --> 00:36:28,360
common type so we wanted to you know

00:36:23,530 --> 00:36:33,040
have something more flexible but it

00:36:28,360 --> 00:36:35,320
didn't help so if the functions we can

00:36:33,040 --> 00:36:39,820
use that use them quite easily we can

00:36:35,320 --> 00:36:43,300
add them you know new state behavior we

00:36:39,820 --> 00:36:46,060
can we have types of events and it's

00:36:43,300 --> 00:36:49,080
fancy it's a bit like you know Apple new

00:36:46,060 --> 00:36:51,580
headphones they can easily get lost and

00:36:49,080 --> 00:36:57,910
you can easily get lost with curtains I

00:36:51,580 --> 00:36:59,740
guess so what about the boost so we

00:36:57,910 --> 00:37:04,080
talked about libraries STL is great

00:36:59,740 --> 00:37:08,410
Buddhists maybe even better sometimes

00:37:04,080 --> 00:37:10,300
sometimes it's not so let's compare a

00:37:08,410 --> 00:37:12,850
few other solutions we'll take a look

00:37:10,300 --> 00:37:15,700
into state chart MSM which are available

00:37:12,850 --> 00:37:18,640
in boost you can download them use them

00:37:15,700 --> 00:37:22,600
right now and SML SML is the library I'm

00:37:18,640 --> 00:37:25,420
the author of and we'll just take a look

00:37:22,600 --> 00:37:29,460
it's not a boost library it just called

00:37:25,420 --> 00:37:29,460
boost to confuse everyone

00:37:31,290 --> 00:37:38,340
now the reason is it is aimed to be a

00:37:33,960 --> 00:37:41,870
boost library okay sorry about that

00:37:38,340 --> 00:37:47,730
so let's take a look into state chart

00:37:41,870 --> 00:37:49,800
has anyone used a chart not a lot of you

00:37:47,730 --> 00:37:51,450
guys so let's take a look how we can

00:37:49,800 --> 00:37:53,640
actually implement a state machine in

00:37:51,450 --> 00:37:58,320
state chart so we have to change our

00:37:53,640 --> 00:38:03,120
events to inherit from the state chart

00:37:58,320 --> 00:38:05,400
event which is a CRT P thing well not

00:38:03,120 --> 00:38:08,250
the best start we have to do some more

00:38:05,400 --> 00:38:14,040
boilerplate code but you can deliver

00:38:08,250 --> 00:38:16,260
that actions unfortunately state chart

00:38:14,040 --> 00:38:18,120
is more like the state pattern in the

00:38:16,260 --> 00:38:19,470
object-oriented kind of design so we

00:38:18,120 --> 00:38:22,340
have to inherit from the state machine

00:38:19,470 --> 00:38:25,140
the first argument parameter here is the

00:38:22,340 --> 00:38:28,320
CRT P thing and the other one is the

00:38:25,140 --> 00:38:30,840
initial state so we have to have a bit

00:38:28,320 --> 00:38:33,360
of knowledge how to use that guy and all

00:38:30,840 --> 00:38:36,930
the actions have to be put into into

00:38:33,360 --> 00:38:42,500
their connection implementations just in

00:38:36,930 --> 00:38:42,500
order to to be usable by the state chart

00:38:44,720 --> 00:38:53,670
so as in the state pattern we implement

00:38:48,990 --> 00:38:55,890
that using the per state basis so we

00:38:53,670 --> 00:38:58,650
have a simple state which we have to

00:38:55,890 --> 00:39:01,830
inherit from we passed the type you have

00:38:58,650 --> 00:39:03,720
the connection we use and we have the

00:39:01,830 --> 00:39:06,090
reactions and the reactions are

00:39:03,720 --> 00:39:08,460
basically delays of transitions so you

00:39:06,090 --> 00:39:11,520
have to be able to read it so is a

00:39:08,460 --> 00:39:13,860
transition from the disconnected state

00:39:11,520 --> 00:39:17,190
on a connect event to the connecting

00:39:13,860 --> 00:39:18,750
state connection is the class and we

00:39:17,190 --> 00:39:23,760
have the establish event so it's

00:39:18,750 --> 00:39:27,000
basically like before we've sweetened

00:39:23,760 --> 00:39:31,440
other cases it's just more less robust a

00:39:27,000 --> 00:39:34,380
lot less easy to follow I say we can

00:39:31,440 --> 00:39:36,420
also have a custom reaction so on the

00:39:34,380 --> 00:39:38,340
bottom under connected we have the pink

00:39:36,420 --> 00:39:42,760
which is a custom reaction which allows

00:39:38,340 --> 00:39:45,200
us to do the garden and call in the

00:39:42,760 --> 00:39:47,810
you know it allows us to do anything we

00:39:45,200 --> 00:39:49,550
want with the stator and the transitions

00:39:47,810 --> 00:39:51,170
and we have to discard this event

00:39:49,550 --> 00:39:54,700
because we don't transit otherwise we

00:39:51,170 --> 00:39:54,700
will just call the transit on it

00:39:55,210 --> 00:40:04,340
performance 60 lines of code and 2000

00:39:59,620 --> 00:40:10,370
almost 3000 line of generated code well

00:40:04,340 --> 00:40:13,130
not great so to sum up it has a lot of

00:40:10,370 --> 00:40:15,110
features though UML related which we

00:40:13,130 --> 00:40:19,430
don't even cover here so that's good

00:40:15,110 --> 00:40:21,830
it's a learning curve that's not great

00:40:19,430 --> 00:40:27,980
it says the line amico locations

00:40:21,830 --> 00:40:33,590
dispatch high memory footprint so they

00:40:27,980 --> 00:40:37,370
introduced MSM into boost which is much

00:40:33,590 --> 00:40:40,940
faster however it's really based on

00:40:37,370 --> 00:40:43,370
macros there's a different prominence

00:40:40,940 --> 00:40:47,270
for MSM which is I'm using this one

00:40:43,370 --> 00:40:49,130
because I find it the best to be more

00:40:47,270 --> 00:40:50,540
expressive and that's what I really care

00:40:49,130 --> 00:40:54,500
about the expressiveness and the

00:40:50,540 --> 00:40:56,860
performance so you have the event which

00:40:54,500 --> 00:40:59,510
you have to define with using macro

00:40:56,860 --> 00:41:05,990
there's another macro to define the

00:40:59,510 --> 00:41:08,390
state there's another macro to define

00:41:05,990 --> 00:41:12,710
action actions we have to pass all these

00:41:08,390 --> 00:41:15,490
parameters around four guards guards an

00:41:12,710 --> 00:41:18,950
action just returns boolean variable

00:41:15,490 --> 00:41:21,770
quite a lot of boilerplate but we do

00:41:18,950 --> 00:41:24,590
that all of that boilerplate is just for

00:41:21,770 --> 00:41:27,260
this guy and this guy is awesome it's a

00:41:24,590 --> 00:41:29,270
transition table in which we can

00:41:27,260 --> 00:41:31,940
actually read and reason about the flow

00:41:29,270 --> 00:41:34,190
of our program so if you compare all the

00:41:31,940 --> 00:41:38,560
solutions this one in my opinion so much

00:41:34,190 --> 00:41:41,480
that you can easily read it you read it

00:41:38,560 --> 00:41:43,910
the way that you say I'm in this

00:41:41,480 --> 00:41:46,580
connected state when I get a connect

00:41:43,910 --> 00:41:49,810
event I call establish and I'm going to

00:41:46,580 --> 00:41:54,620
connect him that's really powerful to

00:41:49,810 --> 00:41:56,150
reason about and look at so all those

00:41:54,620 --> 00:41:59,900
markers are worth it

00:41:56,150 --> 00:42:03,470
in order to have that guy in my opinion

00:41:59,900 --> 00:42:06,730
because it keeps us you know really easy

00:42:03,470 --> 00:42:12,230
way to reason about the application flow

00:42:06,730 --> 00:42:15,710
obviously we have more macros and one

00:42:12,230 --> 00:42:19,789
another macro thing what about the

00:42:15,710 --> 00:42:22,430
performance of that guys well it's not a

00:42:19,789 --> 00:42:24,109
lot of code eighty line and the

00:42:22,430 --> 00:42:28,069
performance you can see that there's

00:42:24,109 --> 00:42:29,900
quite a bit of assembly generated but

00:42:28,069 --> 00:42:32,869
it's not a bad assembly it's not always

00:42:29,900 --> 00:42:35,750
about the size if it comes to assembly

00:42:32,869 --> 00:42:37,279
you can see we have a just jump table

00:42:35,750 --> 00:42:40,309
generated compile time so all the

00:42:37,279 --> 00:42:42,410
transitions are just jumps which is not

00:42:40,309 --> 00:42:44,779
but if it comes to performance and we'll

00:42:42,410 --> 00:42:47,599
take a look into that as well so just

00:42:44,779 --> 00:42:49,339
keep in mind that having a longer

00:42:47,599 --> 00:42:53,170
assembly is not always but unless it's

00:42:49,339 --> 00:42:56,299
in line when we want the inline version

00:42:53,170 --> 00:43:00,950
the summary so it's declarative and

00:42:56,299 --> 00:43:06,380
expressive as you notice I hope in the

00:43:00,950 --> 00:43:09,579
state machine transition stable I love

00:43:06,380 --> 00:43:12,650
it I think that that's the way to go

00:43:09,579 --> 00:43:15,829
there's this part which is a one jump

00:43:12,650 --> 00:43:19,250
table during that compile time it has

00:43:15,829 --> 00:43:22,640
UML features small memory footprint

00:43:19,250 --> 00:43:26,599
there's a learning curve if these are

00:43:22,640 --> 00:43:28,760
based not everyone likes details is

00:43:26,599 --> 00:43:33,799
micro based that's terrible we don't

00:43:28,760 --> 00:43:36,349
want that it complies with lovely so if

00:43:33,799 --> 00:43:40,130
you run it on god board you'll get a

00:43:36,349 --> 00:43:43,819
timeout so in order to get the results

00:43:40,130 --> 00:43:45,950
of God bull's-eye to run it locally but

00:43:43,819 --> 00:43:48,789
you can still click it I know maybe

00:43:45,950 --> 00:43:52,819
maybe mud will extend the time I don't

00:43:48,789 --> 00:43:55,579
it raced out to compile and the error

00:43:52,819 --> 00:44:02,900
messages well you don't wanna look at

00:43:55,579 --> 00:44:05,000
them it's MPO 98 so yeah so that's the

00:44:02,900 --> 00:44:08,029
reason that was the main reason why I

00:44:05,000 --> 00:44:09,800
actually implemented they're a slightly

00:44:08,029 --> 00:44:12,690
different version of Amazon

00:44:09,800 --> 00:44:14,520
using modern C++ features at first I

00:44:12,690 --> 00:44:18,140
started with extending MSM but that was

00:44:14,520 --> 00:44:24,840
just quite painful because it's C++ 98

00:44:18,140 --> 00:44:27,390
and in SML we can do that I think that's

00:44:24,840 --> 00:44:31,619
even more powerful than the SML MSM

00:44:27,390 --> 00:44:33,480
because well we don't have macros yes

00:44:31,619 --> 00:44:38,640
we don't have go tooth that's even

00:44:33,480 --> 00:44:41,570
better everything is easy to follow it's

00:44:38,640 --> 00:44:46,530
C++ protein we have the transition table

00:44:41,570 --> 00:44:49,590
really easy to read and follow everyone

00:44:46,530 --> 00:44:51,480
is Greece do you find that easy to

00:44:49,590 --> 00:44:55,440
follow easy to follow then if-else

00:44:51,480 --> 00:44:56,570
nested switch yeah I see their thumbs up

00:44:55,440 --> 00:45:04,380
I like it

00:44:56,570 --> 00:45:07,320
so yeah that's great but but you know we

00:45:04,380 --> 00:45:12,570
don't want it just for the you know sake

00:45:07,320 --> 00:45:15,589
of being able to write expressive way of

00:45:12,570 --> 00:45:18,000
code in a C++ because C++ is all about

00:45:15,589 --> 00:45:20,130
don't pay for what you don't use right

00:45:18,000 --> 00:45:22,349
we care about the performance we want to

00:45:20,130 --> 00:45:24,960
have the best performance possible we

00:45:22,349 --> 00:45:27,780
want to be able to pick how we want to

00:45:24,960 --> 00:45:30,119
optimize that guy but you know the

00:45:27,780 --> 00:45:32,400
interface is pretty neat so let's think

00:45:30,119 --> 00:45:36,720
of the interface and let's give us their

00:45:32,400 --> 00:45:38,670
capability to switch how to this how to

00:45:36,720 --> 00:45:45,990
change the strategy how we actually

00:45:38,670 --> 00:45:48,270
dispatch events so SML has a different

00:45:45,990 --> 00:45:51,720
policies at compile time so we don't

00:45:48,270 --> 00:45:53,609
play at runtime for anything in SML but

00:45:51,720 --> 00:45:56,670
at compile time we can choose which

00:45:53,609 --> 00:45:59,339
version of the dispatching strategy we

00:45:56,670 --> 00:46:00,960
want we can have a jump table that will

00:45:59,339 --> 00:46:03,060
be generated compile time jump table

00:46:00,960 --> 00:46:05,910
like with MSM we can have a nested

00:46:03,060 --> 00:46:08,460
switch we'll take a look into those guys

00:46:05,910 --> 00:46:11,160
if else fault expressions we don't have

00:46:08,460 --> 00:46:13,170
co-routines yet so we can use curtains

00:46:11,160 --> 00:46:15,650
the back end but as an option as well if

00:46:13,170 --> 00:46:20,000
you really want so I think that's very

00:46:15,650 --> 00:46:22,040
actually neat idea to be a

00:46:20,000 --> 00:46:25,040
to switch the backend policy and have

00:46:22,040 --> 00:46:26,570
really nice common interface because you

00:46:25,040 --> 00:46:28,520
know if it comes to performance you

00:46:26,570 --> 00:46:30,020
always have to measure right so it's not

00:46:28,520 --> 00:46:33,350
always that the jump table will be the

00:46:30,020 --> 00:46:36,950
best and from from my experience it's

00:46:33,350 --> 00:46:42,770
not always the best so let's take a look

00:46:36,950 --> 00:46:45,530
into the dispersion policies if-else so

00:46:42,770 --> 00:46:48,830
assuming that we have some mappings and

00:46:45,530 --> 00:46:50,840
states and we have just a dispatch call

00:46:48,830 --> 00:46:53,390
which takes the current state and the

00:46:50,840 --> 00:46:55,220
event so that'll be the you know

00:46:53,390 --> 00:46:58,790
back-end interface for dispatching the

00:46:55,220 --> 00:47:03,830
policy what we can do with that well we

00:46:58,790 --> 00:47:06,170
can actually call it recursively for as

00:47:03,830 --> 00:47:08,810
long as we find whether we are in the

00:47:06,170 --> 00:47:10,520
current state if we are in the current

00:47:08,810 --> 00:47:13,910
state we will call the execute which is

00:47:10,520 --> 00:47:16,850
just the transition if we not will call

00:47:13,910 --> 00:47:19,730
ourselves again with next iterations and

00:47:16,850 --> 00:47:24,530
the next state so that we'll be able to

00:47:19,730 --> 00:47:26,600
call it at the end possibly if we run

00:47:24,530 --> 00:47:27,740
out of states well we don't call any

00:47:26,600 --> 00:47:31,160
transition and probably it's just

00:47:27,740 --> 00:47:35,750
unexpected and that would be very well

00:47:31,160 --> 00:47:39,890
optimized in decision clang it gives us

00:47:35,750 --> 00:47:43,510
exactly the same code in the assembly as

00:47:39,890 --> 00:47:43,510
before so that's fantastic

00:47:44,650 --> 00:47:52,280
switch we have the same case and we do

00:47:49,540 --> 00:47:56,060
yet another trick of the switch nested

00:47:52,280 --> 00:47:59,710
switch so in default we call a dispatch

00:47:56,060 --> 00:48:01,790
again which will call with the next ID

00:47:59,710 --> 00:48:04,220
which we'll call the switch again

00:48:01,790 --> 00:48:06,740
so we have this nested switch which is

00:48:04,220 --> 00:48:09,560
generated that you know compiled time

00:48:06,740 --> 00:48:13,130
for us and if you have the case in which

00:48:09,560 --> 00:48:20,030
we care about we call the execute so is

00:48:13,130 --> 00:48:22,340
that optimized well yes it is so it's

00:48:20,030 --> 00:48:25,010
optimizing clang and GCC and gives us

00:48:22,340 --> 00:48:27,140
the same result as the switch did notice

00:48:25,010 --> 00:48:29,660
that on the left side I highlighted how

00:48:27,140 --> 00:48:31,430
to switch the policy by default we don't

00:48:29,660 --> 00:48:35,030
have to pass it through

00:48:31,430 --> 00:48:38,780
and the policy will be the best one we

00:48:35,030 --> 00:48:40,790
just for the compiler in a way that

00:48:38,780 --> 00:48:47,180
compiler could actually optimize that

00:48:40,790 --> 00:48:52,640
guy whatever jump table jump table is

00:48:47,180 --> 00:48:55,940
not that straightforward but it's not

00:48:52,640 --> 00:48:59,420
difficult either we have the states we

00:48:55,940 --> 00:49:02,329
have the dispatch table kind of type for

00:48:59,420 --> 00:49:05,900
their function pointers and we just

00:49:02,329 --> 00:49:08,150
generate an RI for all the events and

00:49:05,900 --> 00:49:12,650
after that we just jump according to the

00:49:08,150 --> 00:49:17,930
current state with the event so that

00:49:12,650 --> 00:49:21,970
will give us more code less than MSM

00:49:17,930 --> 00:49:25,970
actually but it won't be fully optimized

00:49:21,970 --> 00:49:27,470
neither incline nor in GCC but from the

00:49:25,970 --> 00:49:29,780
performance perspective sometimes it's

00:49:27,470 --> 00:49:34,700
much better than when the inline

00:49:29,780 --> 00:49:36,890
versions of it depends yeah we have to

00:49:34,700 --> 00:49:39,770
measure those guys and yet another

00:49:36,890 --> 00:49:43,790
solution is the fault expressions which

00:49:39,770 --> 00:49:46,790
is like addition for C++ 17 and what we

00:49:43,790 --> 00:49:50,660
can do here we can just you know fall

00:49:46,790 --> 00:49:54,799
through all the available events with

00:49:50,660 --> 00:49:56,660
the available IDs and we just execute

00:49:54,799 --> 00:49:59,450
when in matches it's pretty much the

00:49:56,660 --> 00:50:03,020
same as recursive version just not

00:49:59,450 --> 00:50:05,630
recursive so that's pretty handy and

00:50:03,020 --> 00:50:08,390
fully expressions are actually very well

00:50:05,630 --> 00:50:12,920
optimized as well so it gives us the

00:50:08,390 --> 00:50:20,510
same output as if else or a pseudonym

00:50:12,920 --> 00:50:24,770
so yeah that's handy nice to have so the

00:50:20,510 --> 00:50:28,369
summary the main benefit of using

00:50:24,770 --> 00:50:31,099
libraries like that like SML is to be

00:50:28,369 --> 00:50:34,040
being able to build an expressive we

00:50:31,099 --> 00:50:36,770
have this UML transitions been visible

00:50:34,040 --> 00:50:38,540
quite well for us the declarative flow

00:50:36,770 --> 00:50:43,700
being declarative is always better than

00:50:38,540 --> 00:50:47,230
not we can customize it at compile time

00:50:43,700 --> 00:50:52,250
awesome that what all C++ is about right

00:50:47,230 --> 00:50:56,390
customizes compile-time it's inline this

00:50:52,250 --> 00:50:59,260
part is the one fantastic as fast

00:50:56,390 --> 00:51:02,630
compilation times you'll see that in the

00:50:59,260 --> 00:51:04,730
results in the benchmarks in the sake it

00:51:02,630 --> 00:51:07,869
has additional features which we don't

00:51:04,730 --> 00:51:10,670
talk about but it's obviously libraries

00:51:07,869 --> 00:51:12,800
it's much more powerful than just the

00:51:10,670 --> 00:51:16,670
transition we can't compare that to the

00:51:12,800 --> 00:51:18,200
variant which is just a way of using for

00:51:16,670 --> 00:51:21,560
the transitions but doesn't have

00:51:18,200 --> 00:51:24,829
anything else there's a minimum memory

00:51:21,560 --> 00:51:30,369
footprint so the size of connection is

00:51:24,829 --> 00:51:33,680
just one by it there's a learning curve

00:51:30,369 --> 00:51:36,230
obviously is a library and it's diesel

00:51:33,680 --> 00:51:40,579
based which is a good and part depend

00:51:36,230 --> 00:51:45,380
depends on how you look at it so if we

00:51:40,579 --> 00:51:48,230
sum up the solutions we can quickly get

00:51:45,380 --> 00:51:50,180
through them as depending on how the

00:51:48,230 --> 00:51:51,470
state is represented how the transition

00:51:50,180 --> 00:51:54,980
table is represented and how the

00:51:51,470 --> 00:51:57,880
transition is represented so state might

00:51:54,980 --> 00:52:01,880
be represented by boolean variable in

00:51:57,880 --> 00:52:04,760
if-else you know maybe a class maybe an

00:52:01,880 --> 00:52:07,849
onion maybe a function or maybe even a

00:52:04,760 --> 00:52:10,069
type on the like in SML and transition

00:52:07,849 --> 00:52:12,829
table might be per state which means

00:52:10,069 --> 00:52:15,560
that object-oriented design using

00:52:12,829 --> 00:52:18,380
interstate or you can have it global

00:52:15,560 --> 00:52:20,569
where you see it all of them and the

00:52:18,380 --> 00:52:23,000
transition is implicit or kind of

00:52:20,569 --> 00:52:25,550
explicit implicit means that you have to

00:52:23,000 --> 00:52:28,250
look through it somewhere in the code to

00:52:25,550 --> 00:52:31,220
find where you actually do the change

00:52:28,250 --> 00:52:33,530
State and explicit which is usually

00:52:31,220 --> 00:52:37,160
better than implicit means that we can

00:52:33,530 --> 00:52:42,470
actually take a look into one simple you

00:52:37,160 --> 00:52:44,060
know source code one file a few lines of

00:52:42,470 --> 00:52:52,760
code and we see everything is happening

00:52:44,060 --> 00:52:56,570
there's no surprises afterwards okay

00:52:52,760 --> 00:53:00,080
so sorry let's take a look into

00:52:56,570 --> 00:53:04,280
benchmarks ban how does it compare yeah

00:53:00,080 --> 00:53:07,130
I was talking about good for alms and 50

00:53:04,280 --> 00:53:09,350
minute about those solutions we compared

00:53:07,130 --> 00:53:12,170
the gold bull results but you know we

00:53:09,350 --> 00:53:17,210
have to measure to be sure which one is

00:53:12,170 --> 00:53:18,980
the best if it comes to the measurements

00:53:17,210 --> 00:53:21,290
we'll going to take so in order to do

00:53:18,980 --> 00:53:26,420
that we changed our actions and guards

00:53:21,290 --> 00:53:29,870
to have to verify to access a memory so

00:53:26,420 --> 00:53:32,630
that it won't be totally in line and the

00:53:29,870 --> 00:53:35,510
idea is that we randomized the events

00:53:32,630 --> 00:53:39,470
and we run the process event on those

00:53:35,510 --> 00:53:41,980
guys with GCC and clang the result would

00:53:39,470 --> 00:53:49,220
be for clunk but with GCC is the same

00:53:41,980 --> 00:53:52,550
basically besides the variant and and we

00:53:49,220 --> 00:53:53,780
have to use Clank because we have code

00:53:52,550 --> 00:53:59,120
engine client we don't have them

00:53:53,780 --> 00:54:04,940
anywhere else for now so line lines of

00:53:59,120 --> 00:54:06,980
code the last the better SML is really

00:54:04,940 --> 00:54:10,940
good here because it's like optimized

00:54:06,980 --> 00:54:13,880
for being expressive design pattern

00:54:10,940 --> 00:54:15,860
state pattern is not the best one we

00:54:13,880 --> 00:54:17,600
have to write a lot of code as usual

00:54:15,860 --> 00:54:19,850
with the object oriented design is a lot

00:54:17,600 --> 00:54:21,680
of boilerplate MSM although it's really

00:54:19,850 --> 00:54:23,960
expressive it has a lot of boilerplate

00:54:21,680 --> 00:54:30,140
code to write with those markers but

00:54:23,960 --> 00:54:30,620
besides that it's quite even assembly

00:54:30,140 --> 00:54:32,750
lines

00:54:30,620 --> 00:54:37,150
so that's would be compared before in a

00:54:32,750 --> 00:54:41,000
god bolt we see that there's like naive

00:54:37,150 --> 00:54:43,730
sweet and if-else and SML since it's

00:54:41,000 --> 00:54:45,590
using switch or if underneath in that

00:54:43,730 --> 00:54:48,590
case in those cases a very well

00:54:45,590 --> 00:54:50,420
optimized an inline state chart if you

00:54:48,590 --> 00:54:53,030
care about performance don't you don't

00:54:50,420 --> 00:54:55,870
don't don't use a guy it's it's not the

00:54:53,030 --> 00:55:02,090
best one karate is invariant

00:54:55,870 --> 00:55:03,920
yeah and they take not terrible not not

00:55:02,090 --> 00:55:04,790
idea either it depends obviously on you

00:55:03,920 --> 00:55:08,450
okay

00:55:04,790 --> 00:55:11,060
okay on your case if you care about the

00:55:08,450 --> 00:55:13,880
performance probably you want to use

00:55:11,060 --> 00:55:20,480
them but if you not that bothered when

00:55:13,880 --> 00:55:23,570
when you can so that's the main kind of

00:55:20,480 --> 00:55:26,240
benchmark which you know shows there on

00:55:23,570 --> 00:55:30,530
time performance as I said have been

00:55:26,240 --> 00:55:35,840
longer assembly doesn't mean that will

00:55:30,530 --> 00:55:38,660
be faster or slower so you can see MSM

00:55:35,840 --> 00:55:40,400
had really long assembly lines because

00:55:38,660 --> 00:55:44,180
it generated jumped about compile time

00:55:40,400 --> 00:55:48,080
but actually it's quite fast very undies

00:55:44,180 --> 00:55:51,620
quite fast as well on clunk not

00:55:48,080 --> 00:55:53,720
necessarily in DCC state chart is slow

00:55:51,620 --> 00:55:57,530
but we didn't expect it to be fast as it

00:55:53,720 --> 00:55:59,420
generated so much code SML switch

00:55:57,530 --> 00:56:00,710
if-else they're very well optimized

00:55:59,420 --> 00:56:04,430
because they are really easy to follow

00:56:00,710 --> 00:56:06,470
for the compiler to optimize state

00:56:04,430 --> 00:56:08,540
pattern well if you care about

00:56:06,470 --> 00:56:10,520
performance you don't really want to use

00:56:08,540 --> 00:56:13,640
virtual dispatch right although it might

00:56:10,520 --> 00:56:16,150
be divert relies sometimes most likely

00:56:13,640 --> 00:56:19,370
it won't you will have the heap and

00:56:16,150 --> 00:56:21,710
shared pointers and all that button has

00:56:19,370 --> 00:56:23,500
to deal with so we don't want to do that

00:56:21,710 --> 00:56:28,120
if you care about the performance

00:56:23,500 --> 00:56:30,530
co-routines curtains are quite decent

00:56:28,120 --> 00:56:32,540
probably they might be better and it's

00:56:30,530 --> 00:56:35,930
just you know first stages of them being

00:56:32,540 --> 00:56:39,160
introduced so maybe at some pair at some

00:56:35,930 --> 00:56:39,160
point we can actually improve them

00:56:40,420 --> 00:56:45,800
instructions per cycle all the more

00:56:44,000 --> 00:56:49,220
instructions we can handle per cycle the

00:56:45,800 --> 00:56:54,290
better it just shows how how good we

00:56:49,220 --> 00:56:57,260
actually utilize the cpu if you have

00:56:54,290 --> 00:57:01,490
less instructions we may not use we

00:56:57,260 --> 00:57:05,120
might have not as good you know results

00:57:01,490 --> 00:57:07,720
here but it it serves that all the

00:57:05,120 --> 00:57:08,900
solutions are more or less the same

00:57:07,720 --> 00:57:10,940
co-routines

00:57:08,900 --> 00:57:14,240
a bit smaller than the other ones but

00:57:10,940 --> 00:57:23,510
having a value around two is really good

00:57:14,240 --> 00:57:26,090
to have or keep in mind branches so it's

00:57:23,510 --> 00:57:28,300
interesting how many branches actually

00:57:26,090 --> 00:57:31,390
MSM has because of the jump table

00:57:28,300 --> 00:57:35,270
besides that in lines versions have some

00:57:31,390 --> 00:57:37,100
more branches as well encompassing to

00:57:35,270 --> 00:57:38,750
all the others but it doesn't mean that

00:57:37,100 --> 00:57:44,050
will be slower because it's all about

00:57:38,750 --> 00:57:47,420
how many misses you got and as you see

00:57:44,050 --> 00:57:49,369
with the state pattern and we throw this

00:57:47,420 --> 00:57:52,310
patch well we don't really hit it very

00:57:49,369 --> 00:57:54,230
well you know compilers are not really

00:57:52,310 --> 00:57:57,020
as CPUs are not really good in

00:57:54,230 --> 00:58:00,890
predicting where we are going in other

00:57:57,020 --> 00:58:02,570
cases it's much better state chart since

00:58:00,890 --> 00:58:06,260
it's using the virtual the disparate as

00:58:02,570 --> 00:58:11,690
well it doesn't does have quite a few

00:58:06,260 --> 00:58:16,010
misses but I still not as bad as the

00:58:11,690 --> 00:58:18,680
state pattern compilation time that's

00:58:16,010 --> 00:58:21,109
what I was referring to earlier MSM

00:58:18,680 --> 00:58:28,040
compiles quite slowly in comparison to

00:58:21,109 --> 00:58:30,140
any other solution so that's not good if

00:58:28,040 --> 00:58:31,910
you really you know we have to be

00:58:30,140 --> 00:58:34,490
productive you can be productive with

00:58:31,910 --> 00:58:37,100
MSM by having declarative way of using

00:58:34,490 --> 00:58:44,330
it but do you pay for the compilation

00:58:37,100 --> 00:58:47,420
times a lot really a lot SML compares

00:58:44,330 --> 00:58:50,090
quite fast in the release it's pretty

00:58:47,420 --> 00:58:55,340
much the same as Amazon misters very

00:58:50,090 --> 00:58:57,320
slow to compile and the size because we

00:58:55,340 --> 00:59:02,600
care about the size as well size is

00:58:57,320 --> 00:59:04,250
really important for us to you know if

00:59:02,600 --> 00:59:05,920
you care about performance we probably

00:59:04,250 --> 00:59:08,660
care about the size we have some

00:59:05,920 --> 00:59:11,210
restrictions on that MSM produces quite

00:59:08,660 --> 00:59:14,359
a huge binaries in the debug mode

00:59:11,210 --> 00:59:18,560
because of the debug symbols is all as I

00:59:14,359 --> 00:59:22,790
told you before it's all MPL based so we

00:59:18,560 --> 00:59:26,600
produce a lot of code in comparison to

00:59:22,790 --> 00:59:29,000
other solutions but in

00:59:26,600 --> 00:59:29,720
executable in the release mode they're

00:59:29,000 --> 00:59:33,410
really small

00:59:29,720 --> 00:59:35,690
in comparison in MSM in comparison to

00:59:33,410 --> 00:59:37,100
the debug mode so that's really good

00:59:35,690 --> 00:59:44,450
which means that everything is just

00:59:37,100 --> 00:59:47,840
thrown away so yeah we have like 10

00:59:44,450 --> 00:59:50,870
seconds left so the mission is to

00:59:47,840 --> 00:59:55,460
embrace zero state machine libraries and

00:59:50,870 --> 00:59:58,000
with that we have actually zero seconds

00:59:55,460 --> 01:00:03,329
for questions so thank you

00:59:58,000 --> 01:00:03,329

YouTube URL: https://www.youtube.com/watch?v=yZVby-PuXM0


