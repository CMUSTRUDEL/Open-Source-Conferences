Title: CppCon 2018: Bryce Adelstein Lelbach “The C++ Execution Model”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
At the heart of the C++ programming language is the multi-threaded abstract machine and its execution model, the platform-agnostic formal model that generically describes how to run a C++ program. In this talk, you will learn the rules that govern how your C++ code is executed and see how those rules impact the C++ code you write every day. 

We'll explore the C++ execution and memory model, and discuss fundamental questions such as: 

* What are threads in C++ and how do they interact? 
* What is memory in C++? 
* In what order are things in my C++ program executed? 
* How are C++ expressions and statements executed? 
* What are the semantics of calling a function in C++? 
* What does "happens before" mean? 

If you're interested in gaining a deeper understanding of how your C++ code is executed and how concurrency works in C++, you should attend this talk.
— 
Bryce Adelstein Lelbach, NVIDIA
Senior Software Engineer

Bryce Adelstein Lelbach is a software engineer on the CUDA driver team at NVIDIA. Bryce is passionate about parallel programming. He maintains Thrust, the CUDA C++ core library. He is also one of the initial developers of the HPX C++ runtime system. He spent five years working on HPX while he was at Louisiana State University's Center for Computation and Technology, and three years at Lawrence Berkeley National Laboratory (a US Department of Energy research facility) developing and analyzing new parallel programming models for exascale and post-Moore architectures. He also helped start the LLVMLinux initiative, and has occasionally contributed to the Boost C++ libraries. Bryce is an organizer for the C++Now and CppCon conferences as well as the Bay Area C++ user group, and he is passionate about C++ community development. He is a member of the ISO C++ standard committee. He worked on the C++17 parallel algorithms; today, he works on standardizing better futures, executors, and multi-dimensional arrays.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:05,100
I'm brace it'll see them all back I'm

00:00:02,610 --> 00:00:08,069
giving this talk I'm also the program

00:00:05,100 --> 00:00:11,070
Sheriff UCP become so I hope all of you

00:00:08,069 --> 00:00:12,960
have a great conference I think we have

00:00:11,070 --> 00:00:15,809
a really excellent program this year

00:00:12,960 --> 00:00:23,220
it's by far the best that we ever had

00:00:15,809 --> 00:00:25,590
but I do say that every year so I have

00:00:23,220 --> 00:00:26,910
been on the C++ Standards Committee for

00:00:25,590 --> 00:00:30,380
a few years now and I spend most of my

00:00:26,910 --> 00:00:32,430
time in this group study group 1b

00:00:30,380 --> 00:00:36,180
concurrency and parallelism study group

00:00:32,430 --> 00:00:40,020
and what I want to do with this talk

00:00:36,180 --> 00:00:43,110
today is I want to arm you with the the

00:00:40,020 --> 00:00:46,620
language and formalisms and mindset of

00:00:43,110 --> 00:00:49,739
that group in particular I want to talk

00:00:46,620 --> 00:00:52,230
about the C++ execution model the

00:00:49,739 --> 00:00:54,989
abstract machine a little bit about the

00:00:52,230 --> 00:01:00,149
storage and memory model and the the

00:00:54,989 --> 00:01:01,469
forward progress system in C++ the

00:01:00,149 --> 00:01:04,199
reason I wanted to give this talk is

00:01:01,469 --> 00:01:07,229
that I've it's taken me a number of

00:01:04,199 --> 00:01:10,380
years to to sort of discover all of

00:01:07,229 --> 00:01:12,090
these hidden underpinnings the language

00:01:10,380 --> 00:01:14,850
and I think it's really useful

00:01:12,090 --> 00:01:17,460
information to have so first I want to

00:01:14,850 --> 00:01:19,259
give some caveats about this talk the

00:01:17,460 --> 00:01:22,650
first of which is there's this thing in

00:01:19,259 --> 00:01:24,740
C++ called memory order consume this

00:01:22,650 --> 00:01:27,479
talk pretends that it doesn't exist

00:01:24,740 --> 00:01:29,369
because memory order consumed

00:01:27,479 --> 00:01:30,799
complicates a lot of the model that

00:01:29,369 --> 00:01:32,909
we're going to talk about today and

00:01:30,799 --> 00:01:34,369
you're not really missing much if we

00:01:32,909 --> 00:01:37,200
just pretend it doesn't exist

00:01:34,369 --> 00:01:39,140
so we're just going to act as though

00:01:37,200 --> 00:01:41,939
there is no memory order consumed

00:01:39,140 --> 00:01:46,110
however we are going to be talking about

00:01:41,939 --> 00:01:47,579
the model in C++ 17 and beyond so it's a

00:01:46,110 --> 00:01:49,439
little contradictory that we're gonna be

00:01:47,579 --> 00:01:51,500
talking about the you know the latest

00:01:49,439 --> 00:01:54,810
standard but we're going to be ignoring

00:01:51,500 --> 00:01:57,450
this component of it and there's one

00:01:54,810 --> 00:01:58,649
other thing that I I think you should

00:01:57,450 --> 00:02:01,880
know before you get really started with

00:01:58,649 --> 00:02:03,799
the talk which is the as if rule so you

00:02:01,880 --> 00:02:07,690
as if rule is a part of the super

00:02:03,799 --> 00:02:11,390
standard that gives implementations the

00:02:07,690 --> 00:02:13,940
freedom to optimize to make

00:02:11,390 --> 00:02:16,010
optimizations that are not observable to

00:02:13,940 --> 00:02:18,519
the user so there's certain semantics

00:02:16,010 --> 00:02:21,970
that are specified in the standard and

00:02:18,519 --> 00:02:26,480
they'd be your implementation has to

00:02:21,970 --> 00:02:28,760
abide by those requirements but if you

00:02:26,480 --> 00:02:32,269
can make an optimization that you cannot

00:02:28,760 --> 00:02:32,959
observe that it's sort of cheated then

00:02:32,269 --> 00:02:36,140
that's fine

00:02:32,959 --> 00:02:39,110
and if you could observe that it cheated

00:02:36,140 --> 00:02:40,640
and in a conforming implementation you

00:02:39,110 --> 00:02:42,920
could only observe it through undefined

00:02:40,640 --> 00:02:46,250
behavior so this will come up a couple

00:02:42,920 --> 00:02:47,810
times in the talk so let's let's

00:02:46,250 --> 00:02:49,880
actually it's started now so the

00:02:47,810 --> 00:02:51,110
specific model we're gonna start by

00:02:49,880 --> 00:02:52,400
talking about the C++ abstraction

00:02:51,110 --> 00:02:54,290
machine so what is the abstract machine

00:02:52,400 --> 00:02:57,349
the abstract machine is a theoretical

00:02:54,290 --> 00:02:59,510
model in the standard it's a portable

00:02:57,349 --> 00:03:01,640
abstraction of your operating system

00:02:59,510 --> 00:03:03,829
your kernel and your hardware we as C++

00:03:01,640 --> 00:03:05,630
programmers are all familiar with the

00:03:03,829 --> 00:03:07,040
use of abstractions and I think that the

00:03:05,630 --> 00:03:09,290
C post-post abstract machine is sort of

00:03:07,040 --> 00:03:10,700
like the most fundamental abstraction

00:03:09,290 --> 00:03:12,940
it's like the first abstraction upon

00:03:10,700 --> 00:03:15,769
which all other abstractions are built

00:03:12,940 --> 00:03:19,489
so you can sort of think of it as the

00:03:15,769 --> 00:03:20,840
intermediary between your portable C++

00:03:19,489 --> 00:03:23,510
program in the system that it is run on

00:03:20,840 --> 00:03:27,470
it's like you write some portable C++

00:03:23,510 --> 00:03:28,639
code and then you're implement eight and

00:03:27,470 --> 00:03:30,829
you write that portable secrets opposed

00:03:28,639 --> 00:03:33,920
to the abstract machine and then your

00:03:30,829 --> 00:03:35,750
implementation whatever it may be your

00:03:33,920 --> 00:03:38,269
combination of your hardware your

00:03:35,750 --> 00:03:41,299
compiler your operating system it

00:03:38,269 --> 00:03:43,910
provides a a conforming implementation

00:03:41,299 --> 00:03:45,950
of the abstract machine so we have on

00:03:43,910 --> 00:03:48,139
the Left you have your concrete systems

00:03:45,950 --> 00:03:50,630
that your your implementation provides

00:03:48,139 --> 00:03:51,889
the obstructive IDEs the semantics of

00:03:50,630 --> 00:03:54,049
the abstract machine to you and then you

00:03:51,889 --> 00:03:56,510
write portable code to that abstraction

00:03:54,049 --> 00:04:00,560
and this is sort of the route of

00:03:56,510 --> 00:04:02,209
portability in C++ so the progress uses

00:04:00,560 --> 00:04:03,980
programs describe operations performed

00:04:02,209 --> 00:04:06,109
on the abstract machine not an actual

00:04:03,980 --> 00:04:07,489
hardware and C those implementations

00:04:06,109 --> 00:04:10,489
define the characteristics of the

00:04:07,489 --> 00:04:12,350
abstract machine and translate those

00:04:10,489 --> 00:04:15,390
operations on the abstract machine into

00:04:12,350 --> 00:04:18,420
operations on the system

00:04:15,390 --> 00:04:21,660
so the the this little diagram right

00:04:18,420 --> 00:04:23,400
here I sort of illustrate the the core

00:04:21,660 --> 00:04:24,450
parts of the extra abstract machine

00:04:23,400 --> 00:04:27,120
which is really two things there's

00:04:24,450 --> 00:04:30,690
threads and then there's a flat storage

00:04:27,120 --> 00:04:34,860
space so c++ at its core is just threads

00:04:30,690 --> 00:04:36,990
of execution evaluating functions that

00:04:34,860 --> 00:04:39,060
operate on objects that are in a flat

00:04:36,990 --> 00:04:41,790
storage space that's it it's very simple

00:04:39,060 --> 00:04:45,419
model so the storage is flat there's no

00:04:41,790 --> 00:04:47,490
notion of hierarchy in C++ today there's

00:04:45,419 --> 00:04:49,190
no notion of caches or memory hierarchy

00:04:47,490 --> 00:04:52,050
or Numa or anything like that

00:04:49,190 --> 00:04:55,260
objects reside in storage at a single

00:04:52,050 --> 00:04:57,050
memory location some objects may not

00:04:55,260 --> 00:04:59,850
have a unique memory location such as

00:04:57,050 --> 00:05:02,280
eligible empty base classes like that

00:04:59,850 --> 00:05:05,070
can benefit from the empty base class

00:05:02,280 --> 00:05:07,380
optimizations or objects marked with no

00:05:05,070 --> 00:05:12,410
unique address which is a new thing that

00:05:07,380 --> 00:05:14,970
I believe is new as of C++ 20 not C++ 17

00:05:12,410 --> 00:05:17,730
now of course under as if an

00:05:14,970 --> 00:05:19,230
implementation is allowed to store two

00:05:17,730 --> 00:05:20,880
objects the same machine address or not

00:05:19,230 --> 00:05:22,050
store an object at all so like for

00:05:20,880 --> 00:05:24,870
example if you wrote a program where you

00:05:22,050 --> 00:05:26,520
declared some int and you you initialize

00:05:24,870 --> 00:05:27,720
it with a value of four and you never

00:05:26,520 --> 00:05:30,750
take the address of it and you never

00:05:27,720 --> 00:05:32,520
modify it then it's not observable in

00:05:30,750 --> 00:05:34,140
your program whether or not it's stored

00:05:32,520 --> 00:05:37,169
or not so the compiler doesn't

00:05:34,140 --> 00:05:42,060
necessarily need to actually store it in

00:05:37,169 --> 00:05:44,100
memory in C++ an object cannot have more

00:05:42,060 --> 00:05:46,110
than one memory location this sort of

00:05:44,100 --> 00:05:48,180
like breaks the model in a couple

00:05:46,110 --> 00:05:49,470
different ways and this is the reason

00:05:48,180 --> 00:05:52,979
why we don't have things like a stood

00:05:49,470 --> 00:05:54,360
mem map if you want to use something

00:05:52,979 --> 00:05:56,220
like shared memory you should really do

00:05:54,360 --> 00:05:58,080
it through volatile so like let's

00:05:56,220 --> 00:06:01,770
consider this code right here so I have

00:05:58,080 --> 00:06:03,750
some sort of pointer like class here and

00:06:01,770 --> 00:06:05,550
I have an assignment operator and this

00:06:03,750 --> 00:06:08,310
assignment operator the first thing I do

00:06:05,550 --> 00:06:10,620
is I check to see whether I'm doing a

00:06:08,310 --> 00:06:12,780
self assignment because if I'm doing a

00:06:10,620 --> 00:06:14,340
self assignment I don't I just want to

00:06:12,780 --> 00:06:17,130
like give up and return star this

00:06:14,340 --> 00:06:19,320
because this code will blow up my object

00:06:17,130 --> 00:06:21,330
well if there were two different

00:06:19,320 --> 00:06:25,229
addresses that both pointed to this same

00:06:21,330 --> 00:06:26,980
object then this check would return

00:06:25,229 --> 00:06:29,050
false and

00:06:26,980 --> 00:06:31,630
would go ahead here and blow up so in

00:06:29,050 --> 00:06:36,780
Sivas plus we have one memory one

00:06:31,630 --> 00:06:39,760
address for one object also

00:06:36,780 --> 00:06:41,680
in C++ every thread in the program can

00:06:39,760 --> 00:06:45,670
potentially access every object and

00:06:41,680 --> 00:06:48,610
function in a program so sure we have

00:06:45,670 --> 00:06:50,170
things like thread-local variables but

00:06:48,610 --> 00:06:52,300
if you could take the address of a

00:06:50,170 --> 00:06:53,680
thread local variable or a variable on a

00:06:52,300 --> 00:06:55,630
stack in a particular thread and you

00:06:53,680 --> 00:06:58,450
pass it to another thread it can access

00:06:55,630 --> 00:07:00,550
that object any thread can access any

00:06:58,450 --> 00:07:05,050
object or call any function in a C++

00:07:00,550 --> 00:07:06,520
program today so what what are threads I

00:07:05,050 --> 00:07:07,720
mentioned before I sort of describe

00:07:06,520 --> 00:07:10,420
they're just like being a thing that

00:07:07,720 --> 00:07:12,940
evaluated a function so threads of

00:07:10,420 --> 00:07:15,340
execution are a single flow of control

00:07:12,940 --> 00:07:17,200
in a program that evaluate a top-level

00:07:15,340 --> 00:07:20,830
function call and then all of the

00:07:17,200 --> 00:07:23,020
subsequent expressions within the body

00:07:20,830 --> 00:07:26,980
of that function and threads may run

00:07:23,020 --> 00:07:29,410
concurrently so like there's the main

00:07:26,980 --> 00:07:32,830
thread of execution which all programs

00:07:29,410 --> 00:07:34,990
have that evaluates main and then you

00:07:32,830 --> 00:07:36,850
can trade stood thread threads of

00:07:34,990 --> 00:07:41,020
execution which will evaluate some

00:07:36,850 --> 00:07:42,550
function that you give them now there's

00:07:41,020 --> 00:07:45,040
also some initialization that happens

00:07:42,550 --> 00:07:47,110
here for the main thread static storage

00:07:45,040 --> 00:07:49,540
duration objects are initialized before

00:07:47,110 --> 00:07:52,480
the evaluation of that bat threads

00:07:49,540 --> 00:07:55,120
function and destroyed after that

00:07:52,480 --> 00:07:57,220
evaluation completes and for all threads

00:07:55,120 --> 00:08:00,400
thread local storage is initialized

00:07:57,220 --> 00:08:03,610
before the thread function is evaluated

00:08:00,400 --> 00:08:05,980
and after and after it is evaluated the

00:08:03,610 --> 00:08:10,000
thread storage duration objects are

00:08:05,980 --> 00:08:11,230
destroyed for that threat but I still

00:08:10,000 --> 00:08:14,230
like to just think of them as threads

00:08:11,230 --> 00:08:16,960
evaluate a function call so what does it

00:08:14,230 --> 00:08:18,970
actually mean to evaluate something in

00:08:16,960 --> 00:08:22,030
the C++ like what what does it actually

00:08:18,970 --> 00:08:25,750
mean how does it actually get translated

00:08:22,030 --> 00:08:27,640
down to two actual steps complete steps

00:08:25,750 --> 00:08:30,040
that have to be performed on your

00:08:27,640 --> 00:08:31,930
concrete system so to understand

00:08:30,040 --> 00:08:34,510
evaluation first we have to understand

00:08:31,930 --> 00:08:35,920
the expressions and when I say that I

00:08:34,510 --> 00:08:39,099
mean we need to understand expressions

00:08:35,920 --> 00:08:39,700
in the way that the C++ execution model

00:08:39,099 --> 00:08:42,610
thinks of

00:08:39,700 --> 00:08:47,980
so the the as it used to be known the

00:08:42,610 --> 00:08:50,980
section 1.10 or or intro dot execution

00:08:47,980 --> 00:08:53,680
and not in the sense that you might be

00:08:50,980 --> 00:08:56,080
familiar of like just expressing

00:08:53,680 --> 00:09:00,610
expressions in c++ in general as a as a

00:08:56,080 --> 00:09:02,770
is a element of the language so as far

00:09:00,610 --> 00:09:04,720
as the execution model is concerned

00:09:02,770 --> 00:09:07,480
expressions are a sequence of operators

00:09:04,720 --> 00:09:10,780
and operands that specify a computation

00:09:07,480 --> 00:09:12,880
so like this is an expression that is a

00:09:10,780 --> 00:09:15,730
function call it calls function f the

00:09:12,880 --> 00:09:16,480
second one here we've got a three

00:09:15,730 --> 00:09:18,700
expressions

00:09:16,480 --> 00:09:22,000
two of them are sub expressions a and B

00:09:18,700 --> 00:09:24,040
and then F this is a expression that

00:09:22,000 --> 00:09:27,580
implicit makes a function call to this

00:09:24,040 --> 00:09:30,360
operator these declarations contain an

00:09:27,580 --> 00:09:33,430
expression that calls a constructor here

00:09:30,360 --> 00:09:36,250
some expressions are part of a larger

00:09:33,430 --> 00:09:39,280
expression so like in this example here

00:09:36,250 --> 00:09:41,170
I've got an assignment to a variable

00:09:39,280 --> 00:09:43,510
here and I have so first of all there's

00:09:41,170 --> 00:09:44,800
a constructor call here then there's

00:09:43,510 --> 00:09:47,500
this right-hand side here in the

00:09:44,800 --> 00:09:50,200
right-hand side here is a function call

00:09:47,500 --> 00:09:52,240
and there's three word there's two parts

00:09:50,200 --> 00:09:53,950
of it really there's the expression that

00:09:52,240 --> 00:09:55,960
designates the function that's being

00:09:53,950 --> 00:09:57,310
called here so in this case I'm not

00:09:55,960 --> 00:09:59,010
calling a function by name but like I'm

00:09:57,310 --> 00:10:02,770
be referencing a function pointer and

00:09:59,010 --> 00:10:04,360
then I have the expressions for each one

00:10:02,770 --> 00:10:08,680
of the arguments of the function and

00:10:04,360 --> 00:10:10,690
those these larger expressions so the

00:10:08,680 --> 00:10:13,420
top-level expressions are called full

00:10:10,690 --> 00:10:14,650
expressions and the way that this is

00:10:13,420 --> 00:10:16,650
defined is that foolish questions are

00:10:14,650 --> 00:10:19,090
everything that are not sub expressions

00:10:16,650 --> 00:10:21,310
and full expressions appear in

00:10:19,090 --> 00:10:23,170
statements so like for example here and

00:10:21,310 --> 00:10:25,750
this if statement right here this full

00:10:23,170 --> 00:10:28,690
expression first of all there's the

00:10:25,750 --> 00:10:30,700
obvious the operator equals equals call

00:10:28,690 --> 00:10:36,100
but there's also some conversions that

00:10:30,700 --> 00:10:37,120
happen here too and there's also some

00:10:36,100 --> 00:10:39,040
full expressions that you might not

00:10:37,120 --> 00:10:43,000
expect like the structures are full

00:10:39,040 --> 00:10:44,260
expressions and full expressions may

00:10:43,000 --> 00:10:47,320
include sub expressions that are not

00:10:44,260 --> 00:10:49,930
lexically part of the expression so for

00:10:47,320 --> 00:10:52,780
example I have a function here food that

00:10:49,930 --> 00:10:53,510
has a default argument and when I call

00:10:52,780 --> 00:10:56,630
foo with

00:10:53,510 --> 00:11:00,260
with no parameters this expression here

00:10:56,630 --> 00:11:01,850
includes this expression right here even

00:11:00,260 --> 00:11:07,550
though it's not lexically part of this

00:11:01,850 --> 00:11:10,940
food call here so the evaluation of

00:11:07,550 --> 00:11:12,380
expression consists of evaluating two

00:11:10,940 --> 00:11:14,630
separate parts of the expression its

00:11:12,380 --> 00:11:16,700
value computations and then the

00:11:14,630 --> 00:11:18,200
initiation of its side-effects so let's

00:11:16,700 --> 00:11:20,780
talk about the side effects first side

00:11:18,200 --> 00:11:22,910
effects are things that change the

00:11:20,780 --> 00:11:26,350
execution environment so reading a

00:11:22,910 --> 00:11:29,240
volatile object or modifying any object

00:11:26,350 --> 00:11:32,720
calling a library i/o function which is

00:11:29,240 --> 00:11:34,210
kind of a nebulous term in the spec but

00:11:32,720 --> 00:11:37,010
it sort of means what you would think

00:11:34,210 --> 00:11:38,230
and calling a function that does any of

00:11:37,010 --> 00:11:40,990
the above

00:11:38,230 --> 00:11:44,900
so side effects are things that have

00:11:40,990 --> 00:11:47,630
that they can be observed value

00:11:44,900 --> 00:11:49,130
computations are not side effects they

00:11:47,630 --> 00:11:54,650
are things that are pure that have no

00:11:49,130 --> 00:11:59,240
observable effect so the completion of

00:11:54,650 --> 00:12:01,820
the execution of an evaluation does not

00:11:59,240 --> 00:12:05,030
imply completion of its side effects it

00:12:01,820 --> 00:12:07,700
just implies completion of its value

00:12:05,030 --> 00:12:12,470
computations this will be a little bit

00:12:07,700 --> 00:12:14,690
important later in the talk so some

00:12:12,470 --> 00:12:18,350
examples here and this expression a

00:12:14,690 --> 00:12:21,110
equals a plus B where a and B are int a

00:12:18,350 --> 00:12:23,600
plus B this is a value computation but

00:12:21,110 --> 00:12:25,100
this assignment here is not this as a

00:12:23,600 --> 00:12:28,850
side effect because it modifies some

00:12:25,100 --> 00:12:31,630
object in the second example here this

00:12:28,850 --> 00:12:33,620
is a value computation but this

00:12:31,630 --> 00:12:36,860
expression right here this this

00:12:33,620 --> 00:12:38,870
overloaded shift operator that calls a

00:12:36,860 --> 00:12:39,440
library IL function so it has a

00:12:38,870 --> 00:12:42,260
side-effect

00:12:39,440 --> 00:12:44,360
and then this last one here assuming

00:12:42,260 --> 00:12:45,740
that we don't know what foo is well it

00:12:44,360 --> 00:12:47,060
may have side effect it may not we don't

00:12:45,740 --> 00:12:48,680
we don't know what what what food does

00:12:47,060 --> 00:12:50,390
but but if for the function foo its side

00:12:48,680 --> 00:12:57,110
effects then this expression has side

00:12:50,390 --> 00:13:00,290
effects so next I want to talk about the

00:12:57,110 --> 00:13:02,870
two fundamental relations in C++ that

00:13:00,290 --> 00:13:04,670
describe the order in which things get

00:13:02,870 --> 00:13:06,150
executed the first of them is called

00:13:04,670 --> 00:13:09,510
sequence before and C

00:13:06,150 --> 00:13:11,100
before is a relation between two

00:13:09,510 --> 00:13:14,340
different evaluations of an expression

00:13:11,100 --> 00:13:17,580
within the same thread of execution so

00:13:14,340 --> 00:13:20,130
if a is sequence before B then the

00:13:17,580 --> 00:13:22,740
execution of a shall proceed the

00:13:20,130 --> 00:13:24,900
execution of B and note that little

00:13:22,740 --> 00:13:27,200
caveat I mentioned earlier that the

00:13:24,900 --> 00:13:29,730
execution of an evaluation does not

00:13:27,200 --> 00:13:31,770
incur completion of the execution of an

00:13:29,730 --> 00:13:33,510
evaluation does not imply completion of

00:13:31,770 --> 00:13:37,560
its side effects just of its value

00:13:33,510 --> 00:13:41,430
computations the secrets before relation

00:13:37,560 --> 00:13:43,260
is asymmetric so a is sequence before B

00:13:41,430 --> 00:13:45,150
does not imply that B is sequence before

00:13:43,260 --> 00:13:48,090
a that's sort of straightforward and

00:13:45,150 --> 00:13:51,600
it's transitive if a is sequence before

00:13:48,090 --> 00:13:56,040
B and B is sequence before C then a is

00:13:51,600 --> 00:13:58,530
sequence before C each full expression

00:13:56,040 --> 00:14:00,930
in is sequence before the next full

00:13:58,530 --> 00:14:03,990
expression in program order and the side

00:14:00,930 --> 00:14:05,400
effects of each full expression is

00:14:03,990 --> 00:14:07,920
sequence before the side effects of the

00:14:05,400 --> 00:14:10,950
next full expression in program order so

00:14:07,920 --> 00:14:17,670
it's pretty straightforward like 5 a B a

00:14:10,950 --> 00:14:20,550
is sequence before B now there's two

00:14:17,670 --> 00:14:22,050
other related relations the first of

00:14:20,550 --> 00:14:24,270
them is called indeterminately sequence

00:14:22,050 --> 00:14:27,570
if a and B are in determinately

00:14:24,270 --> 00:14:31,050
sequenced then either a is sequence

00:14:27,570 --> 00:14:33,270
before B or B is sequence before a but

00:14:31,050 --> 00:14:35,910
it's unspecified which but what you do

00:14:33,270 --> 00:14:37,920
know is that a and B are not interleaved

00:14:35,910 --> 00:14:40,890
one comes before the other you just

00:14:37,920 --> 00:14:42,360
don't know which then there's an even

00:14:40,890 --> 00:14:45,570
weaker relation called

00:14:42,360 --> 00:14:48,180
uncie quest if a and B are uncie quest

00:14:45,570 --> 00:14:51,030
then a is not sequence before being and

00:14:48,180 --> 00:14:55,170
B is not sequence before a and they

00:14:51,030 --> 00:14:56,670
might potentially be interleaved so

00:14:55,170 --> 00:14:59,490
choose a little diagram to help us out

00:14:56,670 --> 00:15:03,170
here so if a is sequence before beat

00:14:59,490 --> 00:15:05,370
then I know a comes before B the the

00:15:03,170 --> 00:15:07,290
value temptations in side effects of a

00:15:05,370 --> 00:15:09,330
happened before B if a and B are in

00:15:07,290 --> 00:15:12,930
determinately sequence one of these two

00:15:09,330 --> 00:15:16,830
outcomes happens it's either a a before

00:15:12,930 --> 00:15:18,360
B or B before a and if a and B are uncie

00:15:16,830 --> 00:15:22,410
quest then

00:15:18,360 --> 00:15:28,369
it's either a before baby before a or a

00:15:22,410 --> 00:15:30,179
and B are overlapped in some way so

00:15:28,369 --> 00:15:33,660
let's start a little bit more about

00:15:30,179 --> 00:15:35,069
interleaving here so I'm gonna show you

00:15:33,660 --> 00:15:37,709
a little example that uses some new

00:15:35,069 --> 00:15:40,350
features there's there's one on this

00:15:37,709 --> 00:15:41,819
side which is stood for loop which is a

00:15:40,350 --> 00:15:45,209
new thing that's that's in the

00:15:41,819 --> 00:15:47,220
parallelism TSB - it's sort of like for

00:15:45,209 --> 00:15:49,679
each but it's index based not iterator

00:15:47,220 --> 00:15:51,179
based the reason I'm using it here will

00:15:49,679 --> 00:15:52,470
become a little evident in the next

00:15:51,179 --> 00:15:54,449
slide but I wanted something that was a

00:15:52,470 --> 00:15:56,429
very directly map that map's to a for

00:15:54,449 --> 00:15:59,100
loop in particular I didn't want to use

00:15:56,429 --> 00:16:04,049
4h or transform because I wanted to have

00:15:59,100 --> 00:16:05,549
the assignment be visible in the element

00:16:04,049 --> 00:16:07,769
function we were executing if I used

00:16:05,549 --> 00:16:11,579
return transform here we would just have

00:16:07,769 --> 00:16:14,339
like return a times X and that didn't

00:16:11,579 --> 00:16:17,639
really work for my example here so I've

00:16:14,339 --> 00:16:18,779
also using the parallel overload of for

00:16:17,639 --> 00:16:22,230
loop but I'm calling it with the

00:16:18,779 --> 00:16:23,610
sequence execution policy which says I

00:16:22,230 --> 00:16:27,149
don't want this to be paralyzed I want

00:16:23,610 --> 00:16:29,249
you to do this in sequenced order so

00:16:27,149 --> 00:16:31,919
like if we were to think about four

00:16:29,249 --> 00:16:35,069
iterations of this loop and you can

00:16:31,919 --> 00:16:38,459
think about this operation here Y plus

00:16:35,069 --> 00:16:40,889
equals a times B as being the consisting

00:16:38,459 --> 00:16:44,160
of four steps you load Y you load X

00:16:40,889 --> 00:16:48,449
assume a is some constant here then you

00:16:44,160 --> 00:16:50,850
do a fuse multiply add of a times X plus

00:16:48,449 --> 00:16:53,129
B Y and then you store the result to Y

00:16:50,850 --> 00:16:56,100
so each one of these colors here is the

00:16:53,129 --> 00:16:58,439
steps from one iteration now if we

00:16:56,100 --> 00:17:00,689
change that execution policy from stood

00:16:58,439 --> 00:17:03,149
executions seek the state execution on

00:17:00,689 --> 00:17:06,750
seek compiler is allowed to do this

00:17:03,149 --> 00:17:09,539
that is interleave different iterations

00:17:06,750 --> 00:17:11,579
so what i've done is i've taken all of

00:17:09,539 --> 00:17:14,490
the loads of y and put them together all

00:17:11,579 --> 00:17:17,339
the loads of X and put them together etc

00:17:14,490 --> 00:17:19,649
etc and one reason you might want to do

00:17:17,339 --> 00:17:25,110
this is that then you could instead of

00:17:19,649 --> 00:17:30,360
doing four scalar loads I could do one

00:17:25,110 --> 00:17:31,150
sim D or vector load here now normally

00:17:30,360 --> 00:17:32,980
you

00:17:31,150 --> 00:17:34,750
you wouldn't be able to do this because

00:17:32,980 --> 00:17:35,290
C++ says and we'll talk about a little

00:17:34,750 --> 00:17:38,110
bit later

00:17:35,290 --> 00:17:41,380
you can't enter weave people's functions

00:17:38,110 --> 00:17:43,390
without special permission but this

00:17:41,380 --> 00:17:45,880
execution policy gives that special

00:17:43,390 --> 00:17:48,460
permission and also anything in C++ that

00:17:45,880 --> 00:17:52,120
is specified as being uncie Qin stood

00:17:48,460 --> 00:17:53,740
potentially be interleaved so I like to

00:17:52,120 --> 00:17:56,410
say much about statements but I'll say

00:17:53,740 --> 00:17:57,850
that as far as the execution model is

00:17:56,410 --> 00:18:01,360
concerned statements are just

00:17:57,850 --> 00:18:05,380
compositions of full expressions so like

00:18:01,360 --> 00:18:09,310
a black statement here like statement 0

00:18:05,380 --> 00:18:11,620
sequence 4 statement 1 here in an if

00:18:09,310 --> 00:18:14,970
statement condition the sequence before

00:18:11,620 --> 00:18:17,320
the body in a while loop every

00:18:14,970 --> 00:18:20,110
evaluation of the condition is sequence

00:18:17,320 --> 00:18:22,660
before each evaluation of the body and

00:18:20,110 --> 00:18:27,010
that transitive property spreads out as

00:18:22,660 --> 00:18:28,660
you would imagine all right so now let's

00:18:27,010 --> 00:18:30,220
talk about function evaluation there's

00:18:28,660 --> 00:18:32,890
four rules I'm gonna go through here

00:18:30,220 --> 00:18:34,750
they're a little bit wordy but then

00:18:32,890 --> 00:18:35,770
we're gonna look at an example so the

00:18:34,750 --> 00:18:38,290
first rule is when you're calling a

00:18:35,770 --> 00:18:40,960
function every evaluation within the

00:18:38,290 --> 00:18:42,610
body of the function in every evaluation

00:18:40,960 --> 00:18:43,090
that's not within the body of the

00:18:42,610 --> 00:18:46,420
function

00:18:43,090 --> 00:18:48,700
our indeterminately sequenced this is

00:18:46,420 --> 00:18:50,920
this is the property that says you can't

00:18:48,700 --> 00:18:53,380
enter leave my functions now of course

00:18:50,920 --> 00:18:55,300
if the compiler could prove that it

00:18:53,380 --> 00:18:57,190
could it or leave your functions under

00:18:55,300 --> 00:18:58,990
the as if rule that you can't observe

00:18:57,190 --> 00:19:01,150
the side-effects then sure it could do

00:18:58,990 --> 00:19:04,090
that but if it can't if there were if it

00:19:01,150 --> 00:19:06,870
would be observable not through ub then

00:19:04,090 --> 00:19:10,630
it's not allowed to because of this rule

00:19:06,870 --> 00:19:11,980
the expression designating the function

00:19:10,630 --> 00:19:14,590
so the expression doesn't name in the

00:19:11,980 --> 00:19:18,370
thing to call is sequenced before the

00:19:14,590 --> 00:19:19,600
argument expressions and as i said we'll

00:19:18,370 --> 00:19:22,330
get you an example and it'll become a

00:19:19,600 --> 00:19:24,550
little clearer in a moment and each

00:19:22,330 --> 00:19:26,680
argument expression is indeterminately

00:19:24,550 --> 00:19:29,170
sequenced with respect to all other

00:19:26,680 --> 00:19:31,750
argument expressions this is new and

00:19:29,170 --> 00:19:33,190
supercilious seventeen slightly changed

00:19:31,750 --> 00:19:37,600
from before I believe it was uncie

00:19:33,190 --> 00:19:40,240
quince before seventeen every expression

00:19:37,600 --> 00:19:43,030
in the body of the function is sequenced

00:19:40,240 --> 00:19:44,200
after both the expression designating

00:19:43,030 --> 00:19:45,460
the function

00:19:44,200 --> 00:19:49,299
every argument expression in the

00:19:45,460 --> 00:19:51,370
function this sort of evident right your

00:19:49,299 --> 00:19:52,570
your the arguments to your function you

00:19:51,370 --> 00:19:55,210
need to know what they are before you

00:19:52,570 --> 00:19:56,860
start executing the function so we have

00:19:55,210 --> 00:19:58,539
these four rules here so okay we're

00:19:56,860 --> 00:20:01,269
gonna look at this example so I've got

00:19:58,539 --> 00:20:06,159
some function B I'm gonna call the body

00:20:01,269 --> 00:20:07,539
of that function B E and then I have

00:20:06,159 --> 00:20:08,289
this function G that's not really

00:20:07,539 --> 00:20:10,539
important

00:20:08,289 --> 00:20:14,710
I just wanted to have a full expression

00:20:10,539 --> 00:20:17,529
to stick G M and a function call is a

00:20:14,710 --> 00:20:19,570
useful full expression and then I've got

00:20:17,529 --> 00:20:22,149
a here which is just some arbitrary

00:20:19,570 --> 00:20:24,309
expression that's not part of the body

00:20:22,149 --> 00:20:26,470
of B and I've got F which is some other

00:20:24,309 --> 00:20:28,990
arbitrary expression also not part of

00:20:26,470 --> 00:20:31,139
the body of B so let's walk through and

00:20:28,990 --> 00:20:36,610
apply those rules I just showed you so a

00:20:31,139 --> 00:20:38,049
and E the this expression right here and

00:20:36,610 --> 00:20:40,750
the body of the function are

00:20:38,049 --> 00:20:43,690
indeterminately sequinsed they can't be

00:20:40,750 --> 00:20:46,149
observably interleaved and also F and E

00:20:43,690 --> 00:20:49,779
are indeterminately it's sequence that's

00:20:46,149 --> 00:20:51,610
the first rule I set this expression

00:20:49,779 --> 00:20:53,320
right here and note I put B in

00:20:51,610 --> 00:20:55,120
parenthesis here to indicate it it's an

00:20:53,320 --> 00:20:56,830
expression not like the actual name of

00:20:55,120 --> 00:21:01,840
the function it's some expression that

00:20:56,830 --> 00:21:07,539
gives me B that is sequence before the

00:21:01,840 --> 00:21:10,120
argument expressions C&D C&D as I said

00:21:07,539 --> 00:21:11,799
our indeterminately sequence either c is

00:21:10,120 --> 00:21:17,919
sequence before D or D is sequence

00:21:11,799 --> 00:21:22,210
before C both C and D are sequence

00:21:17,919 --> 00:21:26,169
before the body of the function and a

00:21:22,210 --> 00:21:28,980
through F everything here is sequence

00:21:26,169 --> 00:21:30,700
before the body of that function G so

00:21:28,980 --> 00:21:33,990
most of this is pretty straightforward

00:21:30,700 --> 00:21:36,820
the only thing that's a little bit

00:21:33,990 --> 00:21:39,760
surprising is this indeterminate

00:21:36,820 --> 00:21:41,559
sequencing of function arguments and

00:21:39,760 --> 00:21:43,649
this is not true for all operators and

00:21:41,559 --> 00:21:46,240
we'll talk about that a little bit later

00:21:43,649 --> 00:21:50,200
but let's just look at a little example

00:21:46,240 --> 00:21:52,690
of where they seem problematic so let's

00:21:50,200 --> 00:21:54,279
say I've got some struct here that has

00:21:52,690 --> 00:21:57,309
some simple constructor and it has a

00:21:54,279 --> 00:21:58,110
side effect if I'm making a function

00:21:57,309 --> 00:22:03,240
call

00:21:58,110 --> 00:22:04,769
so parentheses syntax here what I get is

00:22:03,240 --> 00:22:08,250
these two are indeterminately sequence

00:22:04,769 --> 00:22:12,809
the compiler can pick to either do this

00:22:08,250 --> 00:22:15,630
one and then this one or to do dealer to

00:22:12,809 --> 00:22:18,510
do this one or this one which is which

00:22:15,630 --> 00:22:22,409
GCC chooses to do now if you use unicorn

00:22:18,510 --> 00:22:24,720
initialization here it is sequence so

00:22:22,409 --> 00:22:28,919
you'll get from left to right so this is

00:22:24,720 --> 00:22:31,740
what GCC gives you and LLVM gives you

00:22:28,919 --> 00:22:33,090
the opposite so this is a little

00:22:31,740 --> 00:22:36,960
unfortunate but there were there were

00:22:33,090 --> 00:22:38,940
reasons that we didn't fix B this I

00:22:36,960 --> 00:22:40,529
don't want to get into them too much but

00:22:38,940 --> 00:22:42,539
there were reasons I'm not sure that I

00:22:40,529 --> 00:22:44,519
agree with the decision we ended up

00:22:42,539 --> 00:22:50,279
making but because this is a little

00:22:44,519 --> 00:22:53,700
painful but there it's okay so now let's

00:22:50,279 --> 00:22:55,409
talk about operators so the value

00:22:53,700 --> 00:22:56,789
computations of all operators are

00:22:55,409 --> 00:23:00,120
sequence before the value computations

00:22:56,789 --> 00:23:03,149
of if it's operands this is sort of

00:23:00,120 --> 00:23:08,760
straightforward again this set of

00:23:03,149 --> 00:23:10,799
operators the operands our attrition to

00:23:08,760 --> 00:23:13,169
these operators our sequence left to

00:23:10,799 --> 00:23:14,760
right and the sir this is true for most

00:23:13,169 --> 00:23:20,820
of the operators it's sort of what you

00:23:14,760 --> 00:23:24,389
would expect this set so assignments of

00:23:20,820 --> 00:23:26,580
our sequence right to left and and this

00:23:24,389 --> 00:23:28,019
is actually what you expect it would be

00:23:26,580 --> 00:23:29,940
surprising to you if you didn't have

00:23:28,019 --> 00:23:35,179
this but it's a little unfortunate that

00:23:29,940 --> 00:23:37,320
it's not consistent across all operators

00:23:35,179 --> 00:23:39,210
all right so now I want to talk about

00:23:37,320 --> 00:23:41,779
the next relation so that was just

00:23:39,210 --> 00:23:45,269
sequence before we talked about how

00:23:41,779 --> 00:23:48,929
within a single thread is the evaluation

00:23:45,269 --> 00:23:51,899
of expressions ordered now we're going

00:23:48,929 --> 00:23:55,070
to talk about how things are ordered

00:23:51,899 --> 00:23:59,159
between different threads of execution

00:23:55,070 --> 00:24:02,269
so within cheapest loss to library

00:23:59,159 --> 00:24:05,250
operations a and B may be related by the

00:24:02,269 --> 00:24:07,710
synchronizes with relation so

00:24:05,250 --> 00:24:10,740
synchronizes with is an asymmetric

00:24:07,710 --> 00:24:12,960
relation saying a synchronizes with B

00:24:10,740 --> 00:24:16,230
does not imply that be synchronizes with

00:24:12,960 --> 00:24:17,730
a so this this makes a little bit this

00:24:16,230 --> 00:24:19,500
is a little bit less intuitive than the

00:24:17,730 --> 00:24:21,450
asymmetric property of sequence before

00:24:19,500 --> 00:24:27,090
because synchronizes with might imply

00:24:21,450 --> 00:24:29,040
bi-directional but it's not so there's a

00:24:27,090 --> 00:24:30,900
number of ways to achieve synchronizes

00:24:29,040 --> 00:24:33,809
with with the library with the super

00:24:30,900 --> 00:24:37,400
standard library so atomic acquire

00:24:33,809 --> 00:24:40,290
released semantics mutex lock and unlock

00:24:37,400 --> 00:24:43,170
thread create and join future and

00:24:40,290 --> 00:24:47,640
promises and parallel algorithm for can

00:24:43,170 --> 00:24:49,800
join are the most the most common so so

00:24:47,640 --> 00:24:52,200
let's look at an example to sort of help

00:24:49,800 --> 00:24:56,070
us understand a little bit better how

00:24:52,200 --> 00:25:02,220
synchronizes with works so synchronizes

00:24:56,070 --> 00:25:05,790
with is a runtime relation you you have

00:25:02,220 --> 00:25:07,620
to think about who actually observes at

00:25:05,790 --> 00:25:10,410
runtime the side effects of somebody

00:25:07,620 --> 00:25:14,120
else so like in this case here I've got

00:25:10,410 --> 00:25:17,340
some simple example where I have a a

00:25:14,120 --> 00:25:19,770
store beliefs and a load of choir and in

00:25:17,340 --> 00:25:24,000
this case here this particular ballad

00:25:19,770 --> 00:25:27,540
execution of this program this store

00:25:24,000 --> 00:25:30,570
happened and this load observed the

00:25:27,540 --> 00:25:33,390
store and so in this case there is a

00:25:30,570 --> 00:25:34,890
synchronizes with relation from here to

00:25:33,390 --> 00:25:37,860
here and what that synchronizes with

00:25:34,890 --> 00:25:40,559
relation means is everything that

00:25:37,860 --> 00:25:43,620
happened within this thread prior to

00:25:40,559 --> 00:25:45,210
this is visible should this other thread

00:25:43,620 --> 00:25:46,740
nap so therefore does observe the

00:25:45,210 --> 00:25:54,170
side-effects of that of that other

00:25:46,740 --> 00:25:58,080
threat but if this thread here did not

00:25:54,170 --> 00:26:00,390
observe this store here if this sort of

00:25:58,080 --> 00:26:02,460
conceptually happened after this load

00:26:00,390 --> 00:26:05,790
then you don't have any synchronizes

00:26:02,460 --> 00:26:09,120
with relation a node again synchronizes

00:26:05,790 --> 00:26:11,190
with it is is not bi-directional it's

00:26:09,120 --> 00:26:13,500
just in one direction you cannot

00:26:11,190 --> 00:26:15,450
synchronize from a load to a store only

00:26:13,500 --> 00:26:17,670
from a store to a loop where you can't

00:26:15,450 --> 00:26:23,010
synchronize with from a load toy store

00:26:17,670 --> 00:26:23,890
only from the storage of a look so mutex

00:26:23,010 --> 00:26:27,160
is

00:26:23,890 --> 00:26:31,330
unlock operations on mutexes synchronize

00:26:27,160 --> 00:26:33,670
with all subsequent lock operations on

00:26:31,330 --> 00:26:36,910
that mutex it's a little bit different

00:26:33,670 --> 00:26:39,220
than the acquire release example where

00:26:36,910 --> 00:26:41,080
where things are sort of paired and some

00:26:39,220 --> 00:26:43,060
of the others synchronize with relations

00:26:41,080 --> 00:26:44,650
are a little more complex than this so

00:26:43,060 --> 00:26:45,940
it's what I mean is like I've got some

00:26:44,650 --> 00:26:47,680
lock guard here and so I have an

00:26:45,940 --> 00:26:51,460
implicit unlock here and this unlock

00:26:47,680 --> 00:26:54,880
will synchronize with all future lock

00:26:51,460 --> 00:26:56,380
operations and ditto for this next one

00:26:54,880 --> 00:26:58,210
here it'll synchronize with all the

00:26:56,380 --> 00:27:00,160
future ones so it sort of fans out to

00:26:58,210 --> 00:27:05,830
all of the the future lock operations

00:27:00,160 --> 00:27:08,760
that might alright so we've talked about

00:27:05,830 --> 00:27:11,230
sequence before we've talked about

00:27:08,760 --> 00:27:14,890
synchronize with now we're gonna talk

00:27:11,230 --> 00:27:17,920
about happens before which is I think

00:27:14,890 --> 00:27:19,750
the more common term for people to be

00:27:17,920 --> 00:27:21,400
familiar with and what happens before is

00:27:19,750 --> 00:27:24,810
is it's sort of a concatenation of the

00:27:21,400 --> 00:27:30,040
two so given any two evaluations a and B

00:27:24,810 --> 00:27:34,750
if a happens before B then either a is

00:27:30,040 --> 00:27:40,420
sequence before B or a synchronizes with

00:27:34,750 --> 00:27:45,220
B or for some evaluation X a happens

00:27:40,420 --> 00:27:46,330
before X and X happens before B so you

00:27:45,220 --> 00:27:49,000
can sort of think of it as an arbor

00:27:46,330 --> 00:27:52,830
arbitrary concatenation of sequence

00:27:49,000 --> 00:27:59,080
before and synchronizes with relations

00:27:52,830 --> 00:28:02,800
so I think that this is not a great name

00:27:59,080 --> 00:28:07,480
for this relation because happens before

00:28:02,800 --> 00:28:11,650
doesn't mean sort of unquote happened

00:28:07,480 --> 00:28:15,940
before now now I'll make a bit of saying

00:28:11,650 --> 00:28:17,160
if you're able to witness that this then

00:28:15,940 --> 00:28:20,140
your program has undefined behavior

00:28:17,160 --> 00:28:22,840
right this this should not be observable

00:28:20,140 --> 00:28:24,430
unless you're using you be let's look a

00:28:22,840 --> 00:28:28,450
little example here so I've got some

00:28:24,430 --> 00:28:30,730
very simple code I have two variables

00:28:28,450 --> 00:28:32,320
here and I have a function foo there's

00:28:30,730 --> 00:28:35,050
two assignments and foo first this x

00:28:32,320 --> 00:28:37,760
equals y plus one then another full

00:28:35,050 --> 00:28:40,520
expression y equals one as we said for

00:28:37,760 --> 00:28:43,730
expressions are sequence after each

00:28:40,520 --> 00:28:45,950
other so this sequence before this is

00:28:43,730 --> 00:28:47,960
sequence before this so this should

00:28:45,950 --> 00:28:54,160
happen before this but when we look at

00:28:47,960 --> 00:28:59,870
the assembly here this actually happens

00:28:54,160 --> 00:29:01,010
sort of interleaved with this here so

00:28:59,870 --> 00:29:02,630
this is this might seem a little

00:29:01,010 --> 00:29:05,330
intuitive it doesn't actually sort of

00:29:02,630 --> 00:29:07,100
like happen before it in terms of the

00:29:05,330 --> 00:29:08,360
actual assembly you get out but you

00:29:07,100 --> 00:29:09,740
can't observe this and if you could

00:29:08,360 --> 00:29:11,930
observe this the compiler wouldn't do

00:29:09,740 --> 00:29:15,580
this optimization or you'd be absorbing

00:29:11,930 --> 00:29:15,580
it through some weird undefined behavior

00:29:16,510 --> 00:29:22,090
so happens before doesn't mean happened

00:29:19,130 --> 00:29:24,350
before and happening before doesn't mean

00:29:22,090 --> 00:29:28,820
that you have that happens before

00:29:24,350 --> 00:29:31,310
relation so look there an example we got

00:29:28,820 --> 00:29:34,880
two threads here and then we have two

00:29:31,310 --> 00:29:37,310
variables we have a Tomic bool and some

00:29:34,880 --> 00:29:39,770
data I've got a producer thread here and

00:29:37,310 --> 00:29:42,800
what it does is it I'll signs to that

00:29:39,770 --> 00:29:45,800
should that data to that end and then it

00:29:42,800 --> 00:29:48,740
does a relaxed store to this ready flag

00:29:45,800 --> 00:29:52,480
and then I have this consumer here and

00:29:48,740 --> 00:29:57,860
it does if ready then print out the data

00:29:52,480 --> 00:30:00,140
so you would think perhaps that if this

00:29:57,860 --> 00:30:04,520
branch has taken and if you go here then

00:30:00,140 --> 00:30:06,920
you would observe that data is 42 but

00:30:04,520 --> 00:30:08,840
but you won't because memory order

00:30:06,920 --> 00:30:11,390
relaxed does not give you what happens

00:30:08,840 --> 00:30:13,790
before relation just because you see

00:30:11,390 --> 00:30:15,710
this store doesn't mean that you're

00:30:13,790 --> 00:30:19,010
seeing this store because you don't have

00:30:15,710 --> 00:30:21,260
any synchronizes with relation here so

00:30:19,010 --> 00:30:23,390
happening before doesn't necessarily

00:30:21,260 --> 00:30:26,000
mean it happens but this is undefined

00:30:23,390 --> 00:30:28,010
behavior so the only reason we were able

00:30:26,000 --> 00:30:32,120
to observe this is because we used

00:30:28,010 --> 00:30:34,310
undefined behavior so there's a hopeful

00:30:32,120 --> 00:30:36,290
little chart happens before describes

00:30:34,310 --> 00:30:39,860
arbitrary concatenations of sequence

00:30:36,290 --> 00:30:41,750
before and synchronizes with so sequence

00:30:39,860 --> 00:30:45,800
before is the relation that describes

00:30:41,750 --> 00:30:47,270
the ordering within a thread and you get

00:30:45,800 --> 00:30:50,210
that just as a consequence of program

00:30:47,270 --> 00:30:51,210
order and synchronizes with is a

00:30:50,210 --> 00:30:53,580
relation between

00:30:51,210 --> 00:30:55,679
threads it's provided by certain library

00:30:53,580 --> 00:30:58,080
functions so atomic operations

00:30:55,679 --> 00:30:58,740
synchronization operations parallel

00:30:58,080 --> 00:31:03,299
algorithms

00:30:58,740 --> 00:31:05,010
exactly and oh maker law reminder

00:31:03,299 --> 00:31:07,950
remember we're not talking about consume

00:31:05,010 --> 00:31:10,789
here because this chart and these

00:31:07,950 --> 00:31:13,799
relations are not as simple and clean

00:31:10,789 --> 00:31:17,760
when you think about memory order

00:31:13,799 --> 00:31:20,850
consume all right so next we're going to

00:31:17,760 --> 00:31:23,039
talk about the forward progress system

00:31:20,850 --> 00:31:26,970
in C++ which is a relatively new future

00:31:23,039 --> 00:31:31,110
or it's been enhanced in C++ seventeen

00:31:26,970 --> 00:31:32,460
so as we said threads evaluate some top

00:31:31,110 --> 00:31:34,140
level function and then all of the

00:31:32,460 --> 00:31:37,350
expressions contained within the body of

00:31:34,140 --> 00:31:40,110
that function and that evaluation of

00:31:37,350 --> 00:31:43,409
that top level function we can separate

00:31:40,110 --> 00:31:47,789
it into execution steps so threads take

00:31:43,409 --> 00:31:49,950
execution steps towards completion of

00:31:47,789 --> 00:31:53,659
that function you can think of the

00:31:49,950 --> 00:31:57,750
execution steps delineate different

00:31:53,659 --> 00:31:58,980
stages of the evaluation so an execution

00:31:57,750 --> 00:32:00,240
step is one of these things it's either

00:31:58,980 --> 00:32:03,140
the termination of a thread

00:32:00,240 --> 00:32:06,149
so like the threads done make sense an

00:32:03,140 --> 00:32:10,590
access of a bolt I'll object to either a

00:32:06,149 --> 00:32:14,010
read or write word the completion of a

00:32:10,590 --> 00:32:15,539
library IO function call or a

00:32:14,010 --> 00:32:18,990
synchronous a library synchronization

00:32:15,539 --> 00:32:22,710
operation like mutex lock or unlock or

00:32:18,990 --> 00:32:24,899
an atomic operation so all of these are

00:32:22,710 --> 00:32:26,669
execution steps and you can sort of

00:32:24,899 --> 00:32:28,860
think of these as like like the stages

00:32:26,669 --> 00:32:35,039
of the ethics of the evaluation in the

00:32:28,860 --> 00:32:38,460
function so one note here some atomic

00:32:35,039 --> 00:32:40,789
operations may fail spurious lis due to

00:32:38,460 --> 00:32:42,870
interference from other threads and

00:32:40,789 --> 00:32:44,909
implementations are are encouraged but

00:32:42,870 --> 00:32:48,270
not required to prevent these spurious

00:32:44,909 --> 00:32:51,210
failures from indefinitely preventing

00:32:48,270 --> 00:32:54,870
the thread from making forward progress

00:32:51,210 --> 00:32:57,059
by executing execution steps in practice

00:32:54,870 --> 00:32:58,559
the the fact that this is encouragement

00:32:57,059 --> 00:33:01,500
and not a guarantee is not really a

00:32:58,559 --> 00:33:03,659
problem the place where this this comes

00:33:01,500 --> 00:33:04,920
up is on a load lock store conditional

00:33:03,659 --> 00:33:07,110
architecture

00:33:04,920 --> 00:33:09,630
another thread might repeatedly steal

00:33:07,110 --> 00:33:11,250
the cash line you're operating on in

00:33:09,630 --> 00:33:12,480
between the load locked in the store

00:33:11,250 --> 00:33:13,770
conditional instruction just because

00:33:12,480 --> 00:33:16,980
like it needed some other data on that

00:33:13,770 --> 00:33:18,990
cash line and like in theory like that

00:33:16,980 --> 00:33:20,160
could just like to let you forever but

00:33:18,990 --> 00:33:21,750
in practice it's not really concerned

00:33:20,160 --> 00:33:23,310
there's other there's other forward

00:33:21,750 --> 00:33:24,990
progress concerns and C++ that are a

00:33:23,310 --> 00:33:33,840
bigger deal that is worth measuring

00:33:24,990 --> 00:33:36,870
nobody's so september assad there we

00:33:33,840 --> 00:33:39,630
stepped over a slide that said threads

00:33:36,870 --> 00:33:42,720
make progress by executing execution

00:33:39,630 --> 00:33:45,090
steps or it's well Gore it will

00:33:42,720 --> 00:33:48,420
magically appear later so I I want to

00:33:45,090 --> 00:33:51,090
briefly take a little aside to describe

00:33:48,420 --> 00:33:53,130
how we model blocking in the standard

00:33:51,090 --> 00:33:55,530
library sort of relevant to forward

00:33:53,130 --> 00:33:57,540
progress so blocking the definition in

00:33:55,530 --> 00:33:59,250
the standard is is to wait for a

00:33:57,540 --> 00:34:02,190
condition to be satisfied before

00:33:59,250 --> 00:34:04,230
continuing execution or well often say

00:34:02,190 --> 00:34:06,840
in standard ease like to block pending

00:34:04,230 --> 00:34:09,810
this event happening like to block

00:34:06,840 --> 00:34:12,990
pending the completion of this thread to

00:34:09,810 --> 00:34:14,600
block pending the this mutex becoming

00:34:12,990 --> 00:34:17,700
unlocked something like that

00:34:14,600 --> 00:34:20,940
blocking library functions are modeled

00:34:17,700 --> 00:34:22,919
as continuously executing execution

00:34:20,940 --> 00:34:25,970
steps while waiting for their condition

00:34:22,919 --> 00:34:28,440
to be satisfied and and thus blocking

00:34:25,970 --> 00:34:30,630
makes progress this doesn't mean that

00:34:28,440 --> 00:34:33,570
they're necessarily implemented in this

00:34:30,630 --> 00:34:36,510
way that they don't mean they don't have

00:34:33,570 --> 00:34:39,179
to be actively spinning but they have to

00:34:36,510 --> 00:34:43,250
make progress if your implementation

00:34:39,179 --> 00:34:46,280
wants to implement them at another went

00:34:43,250 --> 00:34:49,410
so forward progress guarantee is that

00:34:46,280 --> 00:34:52,620
something observable should eventually

00:34:49,410 --> 00:34:55,440
happen in your program like that your

00:34:52,620 --> 00:34:57,690
program eventually will terminate this

00:34:55,440 --> 00:34:59,520
is like a really bad paraphrasing of

00:34:57,690 --> 00:35:01,530
something Chandler said at the bar last

00:34:59,520 --> 00:35:03,390
night at like 2:00 a.m. so I should have

00:35:01,530 --> 00:35:05,220
like a Chandler Carruth quote up here

00:35:03,390 --> 00:35:08,420
but I didn't want to embarrass him on

00:35:05,220 --> 00:35:11,610
the slide just with my words

00:35:08,420 --> 00:35:14,850
so implementations are allowed to assume

00:35:11,610 --> 00:35:18,570
that all threads will eventually perform

00:35:14,850 --> 00:35:21,480
an execution step this has an important

00:35:18,570 --> 00:35:25,020
caveat which is that infinite loops that

00:35:21,480 --> 00:35:28,590
have no observable side-effects are

00:35:25,020 --> 00:35:29,640
undefined behavior and this is important

00:35:28,590 --> 00:35:33,120
it's important for this to be undefined

00:35:29,640 --> 00:35:34,440
behavior because the compile it's

00:35:33,120 --> 00:35:37,230
important for the compiler to be able to

00:35:34,440 --> 00:35:39,870
optimize loops even when it can't prove

00:35:37,230 --> 00:35:41,790
the loop terminates like for example

00:35:39,870 --> 00:35:43,380
loops or maybe you're like going through

00:35:41,790 --> 00:35:44,760
a circularbuffer or something like that

00:35:43,380 --> 00:35:46,230
or where it's difficult for the compiler

00:35:44,760 --> 00:35:46,530
to infer whether the loop terminates or

00:35:46,230 --> 00:35:48,360
not

00:35:46,530 --> 00:35:50,400
so this guarantee that that

00:35:48,360 --> 00:35:52,860
implementation should assume that you

00:35:50,400 --> 00:35:55,890
haven't put you know while true into

00:35:52,860 --> 00:35:56,850
your program although I want to dive

00:35:55,890 --> 00:35:59,460
into that one in particular

00:35:56,850 --> 00:36:03,150
it is important for compiler

00:35:59,460 --> 00:36:05,490
optimizations of loops so there's three

00:36:03,150 --> 00:36:10,980
types of forward progress guarantees

00:36:05,490 --> 00:36:13,440
that threads can give you in the

00:36:10,980 --> 00:36:15,780
standard they are concurrent forward

00:36:13,440 --> 00:36:18,300
progress parallel forward progress and a

00:36:15,780 --> 00:36:20,100
weakly parallel forward bundles so

00:36:18,300 --> 00:36:21,510
concurrent forward progress is the

00:36:20,100 --> 00:36:23,970
guarantee that the thread will make

00:36:21,510 --> 00:36:26,280
progress regardless of whether other

00:36:23,970 --> 00:36:28,500
threads are making progress concurrently

00:36:26,280 --> 00:36:30,540
with it so even if there's other threads

00:36:28,500 --> 00:36:33,050
like doing stuff your thread will make

00:36:30,540 --> 00:36:37,530
progress it will it will execute

00:36:33,050 --> 00:36:42,450
execution steps and eventually something

00:36:37,530 --> 00:36:45,330
will happen that's observable so some

00:36:42,450 --> 00:36:48,270
examples of the things that give

00:36:45,330 --> 00:36:50,520
concurrent forward progress pre-emptive

00:36:48,270 --> 00:36:52,320
OS thread scheduling something like fair

00:36:50,520 --> 00:36:54,330
share oh s thread scheduling or

00:36:52,320 --> 00:36:56,700
round-robin Oersted scheduling or an

00:36:54,330 --> 00:36:57,990
unbounded thread pool and on unbending

00:36:56,700 --> 00:36:59,940
thread pool will be a thread pool that

00:36:57,990 --> 00:37:01,740
you use create it with some number of

00:36:59,940 --> 00:37:03,840
threads but then if it needs to add more

00:37:01,740 --> 00:37:06,600
threads to ensure forward progress it

00:37:03,840 --> 00:37:08,100
would do so so this is a very strong

00:37:06,600 --> 00:37:12,300
guarantee and it's very desirable

00:37:08,100 --> 00:37:14,400
because it it makes it easy for you to

00:37:12,300 --> 00:37:16,290
ensure that your program has forward

00:37:14,400 --> 00:37:20,280
progress and that your program will like

00:37:16,290 --> 00:37:21,960
your stuff will eventually run Panola

00:37:20,280 --> 00:37:25,020
forward progress is a little weaker what

00:37:21,960 --> 00:37:29,490
it says is once a thread has executed

00:37:25,020 --> 00:37:31,050
its first execution step it will make

00:37:29,490 --> 00:37:32,100
progress so once it's executed its first

00:37:31,050 --> 00:37:34,680
execution step

00:37:32,100 --> 00:37:36,270
it has concurrent Garan concurrent

00:37:34,680 --> 00:37:40,230
forward progress guarantees until it

00:37:36,270 --> 00:37:42,660
terminates so once it started you know

00:37:40,230 --> 00:37:48,150
that it'll it'll have forward progress

00:37:42,660 --> 00:37:51,180
so some examples one to completion

00:37:48,150 --> 00:37:52,650
userspace tasking or hybrid threads or

00:37:51,180 --> 00:37:56,220
userspace scheduling there's like a

00:37:52,650 --> 00:37:57,180
billion names for it for this I hope I

00:37:56,220 --> 00:38:00,000
used one of them that you're familiar

00:37:57,180 --> 00:38:02,130
with or something like a bounded thread

00:38:00,000 --> 00:38:03,630
pool where you've got a thread pool

00:38:02,130 --> 00:38:05,970
you've got a fixed number of threads and

00:38:03,630 --> 00:38:07,890
it will execute functions run those

00:38:05,970 --> 00:38:11,220
functions to completion but it won't add

00:38:07,890 --> 00:38:13,890
new threads if needed to make forward

00:38:11,220 --> 00:38:17,130
progress and threads on modern NVIDIA

00:38:13,890 --> 00:38:21,150
GPUs so Balta and later we'll give you

00:38:17,130 --> 00:38:23,640
parallel forward progress guarantees so

00:38:21,150 --> 00:38:25,590
then we have weekly parallel forward

00:38:23,640 --> 00:38:28,080
progress guarantees which is really just

00:38:25,590 --> 00:38:30,120
you don't get any progress or energy at

00:38:28,080 --> 00:38:32,460
all so the threads not guaranteed to

00:38:30,120 --> 00:38:34,230
make forward progress so there's a lot

00:38:32,460 --> 00:38:35,400
of things that fit this model so

00:38:34,230 --> 00:38:38,730
non-preemptive

00:38:35,400 --> 00:38:39,960
OS thread scheduling suspend Abul user

00:38:38,730 --> 00:38:40,800
space tasking so something like

00:38:39,960 --> 00:38:42,780
work-stealing

00:38:40,800 --> 00:38:45,240
test schedulers things where your thread

00:38:42,780 --> 00:38:47,100
your threads will voluntarily your like

00:38:45,240 --> 00:38:49,290
user space tasks for voluntary print

00:38:47,100 --> 00:38:51,270
themselves or fibers Threadless

00:38:49,290 --> 00:38:52,770
asynchronous minik / teens lazy

00:38:51,270 --> 00:38:54,870
execution can sort of be thought of as a

00:38:52,770 --> 00:38:56,910
threat of execution that has weekly

00:38:54,870 --> 00:38:59,220
parallel forward progress guarantees one

00:38:56,910 --> 00:39:02,580
that I forgot in this slide here is sim

00:38:59,220 --> 00:39:04,430
D lanes can be thought of as modeling

00:39:02,580 --> 00:39:08,730
weekly parallel forward progress and

00:39:04,430 --> 00:39:15,230
threads on non NVIDIA GPUs and older

00:39:08,730 --> 00:39:20,370
GPUs where legacy as we've said here so

00:39:15,230 --> 00:39:22,440
what guarantees do the main thread in

00:39:20,370 --> 00:39:24,960
C++ make like the thread that runs your

00:39:22,440 --> 00:39:26,280
program what do you think you get I want

00:39:24,960 --> 00:39:35,700
to hear some answers what do we think we

00:39:26,280 --> 00:39:37,810
get okay week parallel anybody else okay

00:39:35,700 --> 00:39:39,790
I should parallel concurrent

00:39:37,810 --> 00:39:41,380
so it's actually implementation yeah

00:39:39,790 --> 00:39:43,650
it's actually implementation to find

00:39:41,380 --> 00:39:45,670
there's a like a note that says

00:39:43,650 --> 00:39:49,200
general-purpose implementations are

00:39:45,670 --> 00:39:51,820
encouraged to give you concurrent

00:39:49,200 --> 00:39:52,960
forward progress guarantees but like if

00:39:51,820 --> 00:39:55,270
you're implementing in like a hard

00:39:52,960 --> 00:39:56,590
real-time system you just can't do this

00:39:55,270 --> 00:39:59,020
or if you're putting a system where you

00:39:56,590 --> 00:40:01,090
don't have a scheduler at all we're like

00:39:59,020 --> 00:40:02,410
you just have one core and it's an

00:40:01,090 --> 00:40:04,450
embedded system and you just run on the

00:40:02,410 --> 00:40:05,800
bear the bear hardware like you don't

00:40:04,450 --> 00:40:06,850
have any way to make this guarantee like

00:40:05,800 --> 00:40:09,160
each thread will just run until

00:40:06,850 --> 00:40:15,900
completion so its implementation to find

00:40:09,160 --> 00:40:19,690
what about stood thread threads anyway

00:40:15,900 --> 00:40:23,010
the same yeah yeah that's the same it's

00:40:19,690 --> 00:40:25,330
also implementation to find of course so

00:40:23,010 --> 00:40:26,830
again most implementations will give you

00:40:25,330 --> 00:40:28,360
a concurrent forward progress guarantees

00:40:26,830 --> 00:40:29,920
but on some platforms like embedded

00:40:28,360 --> 00:40:33,190
platforms real-time platforms you might

00:40:29,920 --> 00:40:35,530
not get this so there is a mechanism in

00:40:33,190 --> 00:40:38,500
the standard which is a get a melty name

00:40:35,530 --> 00:40:40,840
it's a block with forward progress

00:40:38,500 --> 00:40:44,830
delegation but there's a nickname that

00:40:40,840 --> 00:40:47,710
we give it within study group 1 which is

00:40:44,830 --> 00:40:50,950
boost blocking and what Bruce Blanca

00:40:47,710 --> 00:40:52,750
does is a mechanism for blocking on a

00:40:50,950 --> 00:40:54,910
thread with weaker forward progress

00:40:52,750 --> 00:40:58,570
guarantees while preserving the calling

00:40:54,910 --> 00:41:01,300
threads forward progress so this is very

00:40:58,570 --> 00:41:05,890
useful when you're dealing with non

00:41:01,300 --> 00:41:07,420
concurrent threads of execution so the

00:41:05,890 --> 00:41:09,070
sort of semantics of what it does is

00:41:07,420 --> 00:41:12,460
when you have a thread P that boost

00:41:09,070 --> 00:41:14,560
blocks on some set of other threads the

00:41:12,460 --> 00:41:16,540
forward progress guarantees of at least

00:41:14,560 --> 00:41:18,820
one of the threads in S is temporarily

00:41:16,540 --> 00:41:23,920
upgraded to the forward progress

00:41:18,820 --> 00:41:26,560
guarantees of P and then this continues

00:41:23,920 --> 00:41:28,060
until that's terminates and then you

00:41:26,560 --> 00:41:29,860
repeat this until the blocking condition

00:41:28,060 --> 00:41:30,850
is satisfied and you go and get other

00:41:29,860 --> 00:41:34,600
threads from that set that you're

00:41:30,850 --> 00:41:37,780
blocking on if you need to it is

00:41:34,600 --> 00:41:42,400
unspecified which threads or which order

00:41:37,780 --> 00:41:45,820
of threads are picked from that set so

00:41:42,400 --> 00:41:47,500
boost blocking ensure is a way to ensure

00:41:45,820 --> 00:41:49,480
that your children threads work that you

00:41:47,500 --> 00:41:50,840
spawn makes progress but it's not

00:41:49,480 --> 00:41:51,950
necessarily a wage

00:41:50,840 --> 00:41:54,800
not a way to make sure that your

00:41:51,950 --> 00:41:56,120
siblings make progress the reason I

00:41:54,800 --> 00:41:58,940
point this out is that boost blocking is

00:41:56,120 --> 00:42:01,460
not a magical solution that prevents you

00:41:58,940 --> 00:42:05,990
from deadlocking

00:42:01,460 --> 00:42:07,580
a lightweight work work-stealing

00:42:05,990 --> 00:42:10,490
task scheduler that only gives you

00:42:07,580 --> 00:42:13,370
weakly parallel forward progress

00:42:10,490 --> 00:42:17,240
guarantees it gives you some protection

00:42:13,370 --> 00:42:18,740
in particular as I said he will ensure

00:42:17,240 --> 00:42:26,630
that your children phones make progress

00:42:18,740 --> 00:42:28,370
but not your siblings so here's like an

00:42:26,630 --> 00:42:31,670
example of long I call lazy threads it's

00:42:28,370 --> 00:42:34,160
like a very simple really bad sort of

00:42:31,670 --> 00:42:35,660
stood thread ish implementation so it's

00:42:34,160 --> 00:42:38,210
just like it's really just like a stood

00:42:35,660 --> 00:42:39,380
function that is in a class it's very

00:42:38,210 --> 00:42:42,410
boring

00:42:39,380 --> 00:42:43,760
Stud function void and I've got this is

00:42:42,410 --> 00:42:47,500
like what join would look like for this

00:42:43,760 --> 00:42:52,160
so if I've still got the function here

00:42:47,500 --> 00:42:56,000
when I call join then I need to ensure

00:42:52,160 --> 00:42:58,340
that it will run and one way to do that

00:42:56,000 --> 00:42:59,960
is for me to just run it and this would

00:42:58,340 --> 00:43:01,880
be boost blocking because whatever my

00:42:59,960 --> 00:43:03,830
current forward progress guarantees in

00:43:01,880 --> 00:43:08,030
my thread of my current calling thread

00:43:03,830 --> 00:43:09,740
of execution are this thread from the

00:43:08,030 --> 00:43:11,180
conceptual thread that actually eats

00:43:09,740 --> 00:43:13,280
this function will run with those

00:43:11,180 --> 00:43:14,720
forward progress guarantees and then

00:43:13,280 --> 00:43:16,190
otherwise I just throw because that's

00:43:14,720 --> 00:43:18,800
what join does if you call it twice and

00:43:16,190 --> 00:43:20,330
I like I sign it out to be you know

00:43:18,800 --> 00:43:23,510
something something that will return

00:43:20,330 --> 00:43:26,420
false you so a slightly more advanced

00:43:23,510 --> 00:43:27,950
example let's imagine we have some sort

00:43:26,420 --> 00:43:31,820
of thread pool where we've got a single

00:43:27,950 --> 00:43:33,770
two of tasks this is the queue here and

00:43:31,820 --> 00:43:35,240
then I have some number of worker

00:43:33,770 --> 00:43:37,880
threads and what the worker threads do

00:43:35,240 --> 00:43:39,500
is they you know check whether this is

00:43:37,880 --> 00:43:41,930
empty or whether they've been signaled

00:43:39,500 --> 00:43:43,940
that like work the thread pools being

00:43:41,930 --> 00:43:45,140
shut down and if it's not empty and if

00:43:43,940 --> 00:43:48,740
they're not done then they go and get

00:43:45,140 --> 00:43:52,670
something out of the queue and they go

00:43:48,740 --> 00:43:55,280
and execute it and so these tasks in the

00:43:52,670 --> 00:44:01,430
queue we can think of these as threads

00:43:55,280 --> 00:44:02,950
of execution and so let's look a little

00:44:01,430 --> 00:44:04,700
code again here let's say that I've got

00:44:02,950 --> 00:44:07,369
some I've made some stat

00:44:04,700 --> 00:44:10,310
I'd pull here and and then I'm gonna go

00:44:07,369 --> 00:44:12,140
and like give it some work to do and I

00:44:10,310 --> 00:44:15,079
said go execute this task on this red

00:44:12,140 --> 00:44:17,390
pool here and this is sort of creating a

00:44:15,079 --> 00:44:19,490
thread of execution on this thread pool

00:44:17,390 --> 00:44:22,490
once there then inside of this task what

00:44:19,490 --> 00:44:24,770
I what I do is I say I'm gonna you know

00:44:22,490 --> 00:44:27,140
I want to paralyze whatever the work is

00:44:24,770 --> 00:44:31,130
that I'm doing so I'm gonna create two

00:44:27,140 --> 00:44:33,170
children tasks on this thread put the

00:44:31,130 --> 00:44:34,609
same thread pool here too and then like

00:44:33,170 --> 00:44:37,099
I'll go do some other stuff and then

00:44:34,609 --> 00:44:39,760
like I'll join them but what if I just

00:44:37,099 --> 00:44:42,619
had one thread in this thread pool here

00:44:39,760 --> 00:44:44,030
so what would happen is like I would put

00:44:42,619 --> 00:44:46,280
this test in the queue it would start

00:44:44,030 --> 00:44:48,619
executing this task then it would add

00:44:46,280 --> 00:44:51,070
these tasks to the queue and then it

00:44:48,619 --> 00:44:53,150
would join unblock and those tasks and

00:44:51,070 --> 00:44:56,210
then it would just keep blocking forever

00:44:53,150 --> 00:44:58,550
because there's no other thread in this

00:44:56,210 --> 00:45:01,160
thread pool to run this task so what

00:44:58,550 --> 00:45:04,400
needs to happen is in these join methods

00:45:01,160 --> 00:45:08,630
here we need to do Bruce blocking we

00:45:04,400 --> 00:45:11,000
need to upgrade the the forward progress

00:45:08,630 --> 00:45:13,250
guarantees of these children here we

00:45:11,000 --> 00:45:15,500
need to sort of give them use of our

00:45:13,250 --> 00:45:19,630
thread until our blocking condition is

00:45:15,500 --> 00:45:22,700
satisfied that is that is Bruce barking

00:45:19,630 --> 00:45:24,589
all right so here's sort of the

00:45:22,700 --> 00:45:26,450
takeaways that I wanted you all to get

00:45:24,589 --> 00:45:30,260
from this this talk sort of four main

00:45:26,450 --> 00:45:32,869
points here the C++ execution model in a

00:45:30,260 --> 00:45:35,930
sentence is threads evaluating

00:45:32,869 --> 00:45:38,030
expressions in a flat member and a flat

00:45:35,930 --> 00:45:39,950
storage space that contains objects that

00:45:38,030 --> 00:45:43,780
are accessed and manipulated by those

00:45:39,950 --> 00:45:47,000
threads evaluations within a thread are

00:45:43,780 --> 00:45:48,079
the order of evaluation within a thread

00:45:47,000 --> 00:45:50,300
is driven by the sequence before

00:45:48,079 --> 00:45:51,619
relation interactions between threads

00:45:50,300 --> 00:45:55,339
are driven by the synchronizes with

00:45:51,619 --> 00:45:58,160
relations and forward progress sort of

00:45:55,339 --> 00:46:02,650
gives us a system by which to ensure we

00:45:58,160 --> 00:46:05,150
have a ventually nation of our program

00:46:02,650 --> 00:46:07,250
all right I've got about five minutes

00:46:05,150 --> 00:46:10,310
left which is a good amount of time for

00:46:07,250 --> 00:46:12,140
questions so I don't know if I can't

00:46:10,310 --> 00:46:14,660
really see if there's microphones here

00:46:12,140 --> 00:46:17,310
it doesn't look like there are maybe

00:46:14,660 --> 00:46:19,560
they're on the back in microns

00:46:17,310 --> 00:46:21,900
all right anybody have questions maybe

00:46:19,560 --> 00:46:33,510
stand up or make yourself invisible to

00:46:21,900 --> 00:46:35,310
me I see Michael back there the question

00:46:33,510 --> 00:46:48,170
was can I go back to the booth blocking

00:46:35,310 --> 00:46:48,170
definition slide this one yep this one

00:47:00,830 --> 00:47:07,950
it only guarantees that your children

00:47:04,020 --> 00:47:10,430
will proceed like as an example let's

00:47:07,950 --> 00:47:13,260
say I've got like a so the question was

00:47:10,430 --> 00:47:14,910
sort of what do you mean about it only

00:47:13,260 --> 00:47:16,860
ensuring progress for your children and

00:47:14,910 --> 00:47:19,350
not your siblings what I mean is like

00:47:16,860 --> 00:47:26,280
let's say I've got a thread pool with

00:47:19,350 --> 00:47:29,340
two threads in it and i NQ three tasks

00:47:26,280 --> 00:47:31,260
each of which inq three tasks each of

00:47:29,340 --> 00:47:34,170
which wait on a fourth task that I in

00:47:31,260 --> 00:47:36,450
queue so now in my my queue I have three

00:47:34,170 --> 00:47:39,810
tasks that wait on a fourth task that's

00:47:36,450 --> 00:47:42,930
in the queue and I've got two threads in

00:47:39,810 --> 00:47:44,610
my thread pool executing it so each one

00:47:42,930 --> 00:47:49,380
of those threads grabs one of the first

00:47:44,610 --> 00:47:51,210
two tasks that blocks and they spin

00:47:49,380 --> 00:47:52,350
waiting for that last task and then like

00:47:51,210 --> 00:47:54,720
I have some other threads some other

00:47:52,350 --> 00:47:57,060
concurrent execution agent that then

00:47:54,720 --> 00:47:59,340
goes and boosts blocks on this queue and

00:47:57,060 --> 00:48:03,960
like it grabs the other task that blocks

00:47:59,340 --> 00:48:05,640
and it just also doesn't make any

00:48:03,960 --> 00:48:06,960
progress because there's the I have

00:48:05,640 --> 00:48:08,490
three four threads now that are waiting

00:48:06,960 --> 00:48:11,130
for this fourth task and there's nobody

00:48:08,490 --> 00:48:15,030
to execute it you can only boost block

00:48:11,130 --> 00:48:17,420
to delegate to give use of your thread

00:48:15,030 --> 00:48:21,840
to your children you can't prevent

00:48:17,420 --> 00:48:24,360
unrelated tasks that are siblings that

00:48:21,840 --> 00:48:25,770
are that are that are you know of the

00:48:24,360 --> 00:48:27,800
same execution cos were within eight

00:48:25,770 --> 00:48:30,060
same execution context

00:48:27,800 --> 00:48:30,660
well you can't ensure that they will

00:48:30,060 --> 00:48:31,770
progress

00:48:30,660 --> 00:48:33,480
you don't really know what they're doing

00:48:31,770 --> 00:48:38,160
and you don't even necessarily know how

00:48:33,480 --> 00:48:39,660
to find them does that help at all okay

00:48:38,160 --> 00:48:41,400
the point the point I'm trying to make

00:48:39,660 --> 00:48:44,340
is that Bruce blocking does not

00:48:41,400 --> 00:48:51,770
magically guarantee that weaker than

00:48:44,340 --> 00:48:51,770
concurrent threads of execution will not

00:48:53,090 --> 00:48:58,740
deadlock when you use synchronization

00:48:56,280 --> 00:49:01,320
primitives designed for concurrent

00:48:58,740 --> 00:49:03,270
execution agents that will block the

00:49:01,320 --> 00:49:06,810
underlying concurrent execution agents

00:49:03,270 --> 00:49:11,940
that are implementing your weaker

00:49:06,810 --> 00:49:13,140
execution agents okay there's a

00:49:11,940 --> 00:49:15,240
microphone we'll go with whoever has the

00:49:13,140 --> 00:49:20,880
microphone when did we assume in the

00:49:15,240 --> 00:49:27,960
snap of the talk that why do we assume

00:49:20,880 --> 00:49:34,350
that a city memory orders not exist the

00:49:27,960 --> 00:49:36,330
reason is that this chart is pretty

00:49:34,350 --> 00:49:39,570
straightforward and fits on a slide and

00:49:36,330 --> 00:49:41,790
when you have to deal with memory order

00:49:39,570 --> 00:49:43,920
consume there's another relation

00:49:41,790 --> 00:49:48,080
strongly happens before that fits in

00:49:43,920 --> 00:49:50,490
here and it gets more complicated but

00:49:48,080 --> 00:49:52,620
explaining this to you without memory

00:49:50,490 --> 00:49:55,040
order consume gives you the basic idea

00:49:52,620 --> 00:49:58,770
the basic idea of being sequence before

00:49:55,040 --> 00:50:00,750
gives you your evaluation order within a

00:49:58,770 --> 00:50:02,640
single thread and it's a consequence of

00:50:00,750 --> 00:50:05,280
program order and synchronizes with

00:50:02,640 --> 00:50:08,820
gives you relations between threads so

00:50:05,280 --> 00:50:11,100
memory like the complexities of the

00:50:08,820 --> 00:50:13,530
wording of the standard to make memory

00:50:11,100 --> 00:50:16,410
order consume work don't change the

00:50:13,530 --> 00:50:18,510
underlying model they just like

00:50:16,410 --> 00:50:23,610
complicate it in ways that I don't think

00:50:18,510 --> 00:50:25,560
are interesting to discuss here like we

00:50:23,610 --> 00:50:28,410
had like you know a full-day workshop so

00:50:25,560 --> 00:50:32,280
I sorry what is the second coming yes

00:50:28,410 --> 00:50:35,280
yeah all right I see there's a queue so

00:50:32,280 --> 00:50:37,380
if you go early on you were you're going

00:50:35,280 --> 00:50:39,480
early on there was a observe

00:50:37,380 --> 00:50:43,620
side-effects and observable there was an

00:50:39,480 --> 00:50:46,980
expression in that assignment is that

00:50:43,620 --> 00:50:48,780
actually a side-effect because you're

00:50:46,980 --> 00:50:51,080
modifying some object but you said it

00:50:48,780 --> 00:50:55,200
was only if it was volatile or i/o or

00:50:51,080 --> 00:51:02,370
just modifying a value cause the side of

00:50:55,200 --> 00:51:06,120
side effect and we'll get there there

00:51:02,370 --> 00:51:11,440
the question wise is modifying and a

00:51:06,120 --> 00:51:13,190
non-volatile object a side-effect

00:51:11,440 --> 00:51:15,630
[Music]

00:51:13,190 --> 00:51:17,430
reading a volatile object or modifying

00:51:15,630 --> 00:51:22,620
any object is the side effect yeah it's

00:51:17,430 --> 00:51:26,760
thank you yeah yep and for your answer

00:51:22,620 --> 00:51:28,680
about the boost blocking you implied but

00:51:26,760 --> 00:51:31,920
didn't say that you can only boost block

00:51:28,680 --> 00:51:33,870
a call that sort of hasn't started

00:51:31,920 --> 00:51:35,850
executing yet is that an accurate way to

00:51:33,870 --> 00:51:39,540
look at it or is there more complexity

00:51:35,850 --> 00:51:41,820
then the question is I see that I seem

00:51:39,540 --> 00:51:43,830
to imply that you can only boost block a

00:51:41,820 --> 00:51:46,890
call that it's not started executing yet

00:51:43,830 --> 00:51:48,330
not necessarily here's an example let's

00:51:46,890 --> 00:51:51,120
say that I've got some sort of

00:51:48,330 --> 00:51:52,910
work-stealing thread scheduler like HP X

00:51:51,120 --> 00:51:56,390
or something like a cur team or a fiber

00:51:52,910 --> 00:52:01,290
where I've got some sort of task that is

00:51:56,390 --> 00:52:03,810
suspended I could one thing I could do

00:52:01,290 --> 00:52:05,700
while boost blocking is resume and

00:52:03,810 --> 00:52:11,370
continue the execution of one of those

00:52:05,700 --> 00:52:14,270
suspend about texts next up can you

00:52:11,370 --> 00:52:18,390
please elaborate a little bit about why

00:52:14,270 --> 00:52:21,720
using atomic boolean causes undefined

00:52:18,390 --> 00:52:26,370
behavior because so the example was hang

00:52:21,720 --> 00:52:28,180
on we can find that one the question was

00:52:26,370 --> 00:52:33,940
about the years

00:52:28,180 --> 00:52:33,940
[Music]

00:52:38,650 --> 00:52:46,760
that was it you know I think what I

00:52:44,840 --> 00:52:48,140
think we should maybe follow up on that

00:52:46,760 --> 00:52:49,340
later because I know it's like you're

00:52:48,140 --> 00:52:51,350
talking about I don't remember where it

00:52:49,340 --> 00:52:56,630
is in the deck but the answer was that

00:52:51,350 --> 00:53:00,050
example I was using memory order relaxed

00:52:56,630 --> 00:53:02,930
the store in the load and that doesn't

00:53:00,050 --> 00:53:05,270
give me a synchronizes with relation so

00:53:02,930 --> 00:53:07,000
I had something where I had like some

00:53:05,270 --> 00:53:10,760
assignments of some data and then like

00:53:07,000 --> 00:53:14,630
store to a doing a relaxed store to some

00:53:10,760 --> 00:53:18,050
guard variable and then in the then an

00:53:14,630 --> 00:53:20,210
if statement do a relaxed load of that

00:53:18,050 --> 00:53:22,070
guard variable and then assume that if I

00:53:20,210 --> 00:53:24,140
saw the low if they saw the guard

00:53:22,070 --> 00:53:26,630
variable be marked as it's ready that

00:53:24,140 --> 00:53:28,940
then that I knew the data was ready you

00:53:26,630 --> 00:53:30,530
only get that with acquire release

00:53:28,940 --> 00:53:34,630
semantics you don't get that with

00:53:30,530 --> 00:53:38,480
relaxed relaxed doesn't give you any

00:53:34,630 --> 00:53:39,650
memory ordering guarantees about what

00:53:38,480 --> 00:53:41,870
like doesn't mean that because I've

00:53:39,650 --> 00:53:43,460
observed this this atomic load I don't

00:53:41,870 --> 00:53:45,290
know anything else about observing other

00:53:43,460 --> 00:53:48,830
things that happen in that thread before

00:53:45,290 --> 00:53:51,020
the store you know I think it would be

00:53:48,830 --> 00:53:53,540
worth to follow up afterwards because I

00:53:51,020 --> 00:53:56,270
think Atomics could be used to

00:53:53,540 --> 00:53:57,890
synchronize access sure all I would have

00:53:56,270 --> 00:54:01,460
had to do to make that not undefined

00:53:57,890 --> 00:54:04,690
behavior is change it from a store

00:54:01,460 --> 00:54:08,630
relaxed to a store release and from a

00:54:04,690 --> 00:54:10,400
load relaxed to a load acquire that's

00:54:08,630 --> 00:54:13,100
all and then then an example or device

00:54:10,400 --> 00:54:15,760
and on one small kind of confusion I

00:54:13,100 --> 00:54:19,190
think you mentioned execution model

00:54:15,760 --> 00:54:23,570
unset yeah it should be execution model

00:54:19,190 --> 00:54:25,520
parallel unset I put stood : : execution

00:54:23,570 --> 00:54:27,320
cone : done seek which I believe is the

00:54:25,520 --> 00:54:30,080
namespace that we ended up putting them

00:54:27,320 --> 00:54:34,400
in but we changed it a couple times all

00:54:30,080 --> 00:54:36,110
right I think last question okay could

00:54:34,400 --> 00:54:42,140
you go back to the slide where you

00:54:36,110 --> 00:54:44,650
introduce an execution step I kinda know

00:54:42,140 --> 00:54:47,610
where that one was yeah

00:54:44,650 --> 00:54:50,500
yeah can you elaborate on what this

00:54:47,610 --> 00:54:52,870
library io function called me how do you

00:54:50,500 --> 00:54:56,380
define an IO function the question was

00:54:52,870 --> 00:54:59,890
can i elaborate on what the library IL

00:54:56,380 --> 00:55:02,770
function is I wish I could a library

00:54:59,890 --> 00:55:04,900
function is not a not a well-defined

00:55:02,770 --> 00:55:07,390
term and the standard I don't think we

00:55:04,900 --> 00:55:10,630
have a definition for it I'm not sure if

00:55:07,390 --> 00:55:12,790
we label things in the library section

00:55:10,630 --> 00:55:15,430
as being sane like this is a library io

00:55:12,790 --> 00:55:17,080
function my guess would be that it

00:55:15,430 --> 00:55:19,780
thought I know that we don't have a

00:55:17,080 --> 00:55:21,820
definition of it we might just use it as

00:55:19,780 --> 00:55:23,680
a term of art in the library section but

00:55:21,820 --> 00:55:25,240
I think from the last time I looked it's

00:55:23,680 --> 00:55:27,250
just a thing that we talked about in the

00:55:25,240 --> 00:55:31,470
execution model that we don't really

00:55:27,250 --> 00:55:36,460
explain what it is and it's sort of like

00:55:31,470 --> 00:55:39,670
it's just common knowledge so I I would

00:55:36,460 --> 00:55:42,880
have to consult with with more senior

00:55:39,670 --> 00:55:45,520
sg1 wizards than then I to give you a

00:55:42,880 --> 00:55:48,070
good definition of that but can I assume

00:55:45,520 --> 00:55:51,060
for example like what any like system

00:55:48,070 --> 00:55:57,090
call that because context which is a

00:55:51,060 --> 00:56:00,430
library io function call or depends no I

00:55:57,090 --> 00:56:02,980
know I don't I'm not I'm not comfortable

00:56:00,430 --> 00:56:05,740
saying anything other than like Stu I'm

00:56:02,980 --> 00:56:08,190
see out and print out our library il

00:56:05,740 --> 00:56:08,190
functions

00:56:08,800 --> 00:56:15,859

YouTube URL: https://www.youtube.com/watch?v=FJIn1YhPJJc


