Title: CppCon 2018: Juan Manuel Martinez Caamaño “Easy::Jit: A Just-in-Time compilation library for C++”
Publication date: 2018-10-11
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Compiled languages like C++ generally don't have access to Just-in-Time facilities, which limits the range of possible optimizations. 
The Easy::Jit library introduces an hybrid approach that combines classical ahead of time compilation with user-specified dynamic recompilation of some functions, using runtime information to improve compiled code. 

Easy::Jit still remains a high level library, aiming to provide a simple way to benefit from Just-in-Time compilation for non-compiler experts. The main abstractions from the library mimics other standard C++ constructs (as std::bind) to ease its adoption. 

The library is composed of two main parts, the library interface and a compiler plugin. The library interface relies on metaprogramming to generate the appropiate low-level API calls. It also wraps the returned raw function pointers in a high-level object that performs type checking on the parameters of the call. 
The compiler plugin is in charge of identifying whose bitcode implementation must be exposed at runtime and inject calls to the API that associate function pointers with the bitcode implementations.
— 
Juan Manuel Martinez Caamaño
Engineer, Quarkslab
Likes LLVM and just-in-time compilation.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,909 --> 00:00:08,380
okay so let's get started welcome

00:00:05,020 --> 00:00:10,210
everybody my name is Quan I have plenty

00:00:08,380 --> 00:00:13,000
of bad ideas and today I'm going to

00:00:10,210 --> 00:00:15,519
present one of them which is easy

00:00:13,000 --> 00:00:16,449
it's a just-in-time compilation library

00:00:15,519 --> 00:00:20,409
for C++

00:00:16,449 --> 00:00:22,480
for C++ codes so this is actually a

00:00:20,409 --> 00:00:25,089
library for rent and consideration it's

00:00:22,480 --> 00:00:27,009
not a virtual machine it's not going to

00:00:25,089 --> 00:00:29,619
magically optimize your code and I

00:00:27,009 --> 00:00:32,140
appear out of nowhere an instrument and

00:00:29,619 --> 00:00:34,240
start doing its thing it's not as read

00:00:32,140 --> 00:00:35,470
evaluation print loop and it's certainly

00:00:34,240 --> 00:00:40,330
not the building blocks for building

00:00:35,470 --> 00:00:43,510
something from higher level like LLVM

00:00:40,330 --> 00:00:46,180
does this is simple simply a library for

00:00:43,510 --> 00:00:48,310
runtime code generation and it's got

00:00:46,180 --> 00:00:50,350
some constraint that I want them to to

00:00:48,310 --> 00:00:54,970
do it has to be types a type safe

00:00:50,350 --> 00:00:57,220
wrapper around the LLVM so you are not

00:00:54,970 --> 00:00:59,140
going to be managing function pointers

00:00:57,220 --> 00:01:02,170
and casting things out in and out and

00:00:59,140 --> 00:01:04,150
stuff like that it has to be easy to

00:01:02,170 --> 00:01:07,210
understand and it has to be clearly

00:01:04,150 --> 00:01:09,969
clear and controllable so it's a library

00:01:07,210 --> 00:01:18,280
that has one function and one

00:01:09,969 --> 00:01:19,960
abstraction in total it's also the the

00:01:18,280 --> 00:01:23,049
front end the language has to remain and

00:01:19,960 --> 00:01:24,939
modified but I actually need some help

00:01:23,049 --> 00:01:27,249
from the compiler to do this so I had to

00:01:24,939 --> 00:01:30,130
plug in inside the Delvian I will later

00:01:27,249 --> 00:01:33,159
show you how and finally this is a copy

00:01:30,130 --> 00:01:35,380
this is not my work even if I can't do

00:01:33,159 --> 00:01:37,780
it I can contribute to it during work

00:01:35,380 --> 00:01:40,810
time so it has to be fun and that's

00:01:37,780 --> 00:01:42,749
imperative if it's not fun many choices

00:01:40,810 --> 00:01:45,579
that I took for this library are not

00:01:42,749 --> 00:01:49,630
regarding features or rather as I

00:01:45,579 --> 00:01:53,889
thought it was fun to implement it so

00:01:49,630 --> 00:01:55,990
why to implement easy have you ever

00:01:53,889 --> 00:02:00,119
used just-in-time compilation library

00:01:55,990 --> 00:02:03,429
for C++ can you raise the hand so

00:02:00,119 --> 00:02:04,899
exactly that it's ugly why typically

00:02:03,429 --> 00:02:08,160
there are not many just-in-time

00:02:04,899 --> 00:02:10,300
compilation libraries for c++ and

00:02:08,160 --> 00:02:14,650
normally you need some compiler

00:02:10,300 --> 00:02:16,330
knowledge to start diving inside them

00:02:14,650 --> 00:02:19,330
so let's see an example to understand

00:02:16,330 --> 00:02:22,150
more or less how this library works so

00:02:19,330 --> 00:02:26,440
here we have an image caramel this is a

00:02:22,150 --> 00:02:29,590
classical kernel computation the outer

00:02:26,440 --> 00:02:32,890
free loops will scan all the pixels on

00:02:29,590 --> 00:02:34,599
an image the inner loops will scan the

00:02:32,890 --> 00:02:38,680
neighborhood of a pixel and will perform

00:02:34,599 --> 00:02:41,349
some computation if by any chance we

00:02:38,680 --> 00:02:45,370
knew divide use of all this of all these

00:02:41,349 --> 00:02:48,220
parameters the compiler may be able to

00:02:45,370 --> 00:02:50,519
further optimize this code but typically

00:02:48,220 --> 00:02:54,160
at compile time you don't know them

00:02:50,519 --> 00:02:57,400
furthermore if we knew the values that

00:02:54,160 --> 00:03:00,670
mask takes that this array contains we

00:02:57,400 --> 00:03:02,470
may even be able to go further but at

00:03:00,670 --> 00:03:06,549
compile time again this values are not

00:03:02,470 --> 00:03:09,129
there they are there at runtime let's

00:03:06,549 --> 00:03:13,359
consider this invocation of the of the

00:03:09,129 --> 00:03:17,680
kernel function I don't know if here if

00:03:13,359 --> 00:03:22,630
you know st Devine are you familiar with

00:03:17,680 --> 00:03:24,910
des dividing line from C++ I see some

00:03:22,630 --> 00:03:29,799
help like yes that's so cool because

00:03:24,910 --> 00:03:31,329
normally nobody knows about it okay so

00:03:29,799 --> 00:03:33,370
this function is too divine from the

00:03:31,329 --> 00:03:36,400
standard library will return a function

00:03:33,370 --> 00:03:38,200
object and destruction object the

00:03:36,400 --> 00:03:41,680
operator the cooperator of this function

00:03:38,200 --> 00:03:45,160
object will call the kernel function we

00:03:41,680 --> 00:03:46,989
pass masks masks eyes and mask area as

00:03:45,160 --> 00:03:49,989
the first second and third parameter to

00:03:46,989 --> 00:03:52,060
the kernel function then the first

00:03:49,989 --> 00:03:53,680
parameter of the operator of the

00:03:52,060 --> 00:03:55,120
collaborator and the second parameter of

00:03:53,680 --> 00:03:59,049
the collaborator are going to be forward

00:03:55,120 --> 00:04:01,750
as fourth and fifth parameter for the

00:03:59,049 --> 00:04:03,010
kernel function and so one for the for

00:04:01,750 --> 00:04:04,480
the rest of the parameters and the

00:04:03,010 --> 00:04:07,389
result is a function offset that we can

00:04:04,480 --> 00:04:10,690
call and it will be equivalent to to

00:04:07,389 --> 00:04:14,650
this previous code okay how does the

00:04:10,690 --> 00:04:16,840
seed look like like this it has one

00:04:14,650 --> 00:04:19,289
header file easy

00:04:16,840 --> 00:04:21,940
Ponta CH and it has one function easy

00:04:19,289 --> 00:04:24,199
JIT

00:04:21,940 --> 00:04:27,729
and it tries to mimic most of the

00:04:24,199 --> 00:04:31,460
behavior of the STD vine function and

00:04:27,729 --> 00:04:33,199
the return object it's a it drops it's a

00:04:31,460 --> 00:04:35,990
function of site that drops a lot of

00:04:33,199 --> 00:04:37,430
LLVM stuff when you call it it's going

00:04:35,990 --> 00:04:40,040
to perform the appropriate cast on

00:04:37,430 --> 00:04:42,110
everything and its type size and it's

00:04:40,040 --> 00:04:43,610
going to call and at this point is one

00:04:42,110 --> 00:04:46,699
day we call the LLVM just-in-time

00:04:43,610 --> 00:04:48,680
compiler we generate optimized code but

00:04:46,699 --> 00:04:54,770
using the values of mask mask size mask

00:04:48,680 --> 00:04:57,289
area and so on for the optimization and

00:04:54,770 --> 00:04:58,970
we generate some optimized code and why

00:04:57,289 --> 00:05:01,729
because it gives performance sometimes

00:04:58,970 --> 00:05:05,720
so for example in this case the she'd

00:05:01,729 --> 00:05:08,169
function will perform 4.5 times faster

00:05:05,720 --> 00:05:11,539
than the original version of the code so

00:05:08,169 --> 00:05:13,520
on a video stream that may be really

00:05:11,539 --> 00:05:15,260
cool because on a video stream the image

00:05:13,520 --> 00:05:20,449
that may the frame dimensions really do

00:05:15,260 --> 00:05:23,479
not change that often typically never ok

00:05:20,449 --> 00:05:25,849
so how do we achieve this so let's see

00:05:23,479 --> 00:05:28,460
an overview of the library I said that

00:05:25,849 --> 00:05:31,190
this library needs some compiler help so

00:05:28,460 --> 00:05:33,710
you grab your C++ code that called

00:05:31,190 --> 00:05:35,750
 and typically you compile it for

00:05:33,710 --> 00:05:37,849
example with actually you have to

00:05:35,750 --> 00:05:40,280
compile it with clang but you have to

00:05:37,849 --> 00:05:41,840
use a special clam plugin we are it's

00:05:40,280 --> 00:05:42,919
not a plug-in on the front end it's a

00:05:41,840 --> 00:05:45,620
plug-in on the middle and on the

00:05:42,919 --> 00:05:48,680
optimizer of khang what this plug-in

00:05:45,620 --> 00:05:50,360
does that it will identify all the calls

00:05:48,680 --> 00:05:51,860
to associate you will see which

00:05:50,360 --> 00:05:55,910
functions are process parameters are

00:05:51,860 --> 00:05:57,590
made beep pass as parameters to to the

00:05:55,910 --> 00:06:00,080
associate function and it's going to

00:05:57,590 --> 00:06:02,870
embed the bit code of these functions in

00:06:00,080 --> 00:06:06,919
the final executable why because we will

00:06:02,870 --> 00:06:09,530
need it at runtime at program startup so

00:06:06,919 --> 00:06:12,620
when the before the main function it's

00:06:09,530 --> 00:06:15,050
called we are going to register all the

00:06:12,620 --> 00:06:16,270
function pointers with the associated

00:06:15,050 --> 00:06:20,020
bit code

00:06:16,270 --> 00:06:22,430
then when the ECC's function is called

00:06:20,020 --> 00:06:25,639
using the function pointers we are able

00:06:22,430 --> 00:06:27,979
to recover the vehicle implementation we

00:06:25,639 --> 00:06:29,870
are able to replace the the parameters

00:06:27,979 --> 00:06:32,270
by the actual values of the things that

00:06:29,870 --> 00:06:34,729
we are passing to call the LLVM just in

00:06:32,270 --> 00:06:35,490
time compiler generate optimized code we

00:06:34,729 --> 00:06:38,580
even have

00:06:35,490 --> 00:06:43,380
when optimization that it's able to for

00:06:38,580 --> 00:06:45,720
the built well calls for the built on

00:06:43,380 --> 00:06:49,440
yeah the built on invocations sometimes

00:06:45,720 --> 00:06:51,840
we are able to visualize the Nicol and

00:06:49,440 --> 00:06:52,890
insert the actual file in line the

00:06:51,840 --> 00:06:55,700
actual function that you are calling

00:06:52,890 --> 00:06:57,810
which can give performance sometimes

00:06:55,700 --> 00:06:59,700
this bit called the video that is

00:06:57,810 --> 00:07:03,390
generated it's compiled by the LLVM and

00:06:59,700 --> 00:07:05,100
then all of this we wrapped it in a in a

00:07:03,390 --> 00:07:07,530
function object that it's opaque for the

00:07:05,100 --> 00:07:09,360
user so the user does not need to know

00:07:07,530 --> 00:07:15,030
that there is LLVM behind it

00:07:09,360 --> 00:07:17,520
except when compiling and that's it and

00:07:15,030 --> 00:07:20,550
this library has two big components it

00:07:17,520 --> 00:07:24,360
has the plugin which is not that me and

00:07:20,550 --> 00:07:26,070
it's just a C++ library and I said it

00:07:24,360 --> 00:07:28,440
was last library has one function so

00:07:26,070 --> 00:07:33,390
let's see more or less what does this

00:07:28,440 --> 00:07:36,540
function do so this function as you can

00:07:33,390 --> 00:07:37,800
see here it has some weird macro

00:07:36,540 --> 00:07:41,670
achieved that it's pass over there

00:07:37,800 --> 00:07:44,040
that's to help the compiler plugin to

00:07:41,670 --> 00:07:46,020
quickly and easily identify which one is

00:07:44,040 --> 00:07:47,580
the associate function because the names

00:07:46,020 --> 00:07:51,090
are going to be mangled and are not

00:07:47,580 --> 00:07:52,160
going to be easy to identify but it's

00:07:51,090 --> 00:07:55,710
nothing special

00:07:52,160 --> 00:07:57,150
then from the parameters that function

00:07:55,710 --> 00:07:59,310
the decision function a function

00:07:57,150 --> 00:08:01,950
receives we are going to build what we

00:07:59,310 --> 00:08:03,630
call the context the context contains

00:08:01,950 --> 00:08:05,430
everything that we need to perform

00:08:03,630 --> 00:08:07,230
chattington compilation which is the

00:08:05,430 --> 00:08:09,120
function that we are specializing which

00:08:07,230 --> 00:08:12,390
are the values of the parameters and so

00:08:09,120 --> 00:08:15,030
on then using the context we are going

00:08:12,390 --> 00:08:17,340
to call the to pass this to the LLVM to

00:08:15,030 --> 00:08:19,470
perform faceting compilation the second

00:08:17,340 --> 00:08:21,810
part is rather straightforward so I'm

00:08:19,470 --> 00:08:25,380
going to focus on the first one how do

00:08:21,810 --> 00:08:28,530
we build the context and if we dive into

00:08:25,380 --> 00:08:31,560
this function in the bottom of it just

00:08:28,530 --> 00:08:33,960
as a disclaimer I'm rather mediocre C++

00:08:31,560 --> 00:08:36,420
programmer so you will see things to

00:08:33,960 --> 00:08:42,660
correct me so after then you can tell me

00:08:36,420 --> 00:08:45,600
which ones at the bottom of them of the

00:08:42,660 --> 00:08:48,750
context generation we will find

00:08:45,600 --> 00:08:49,030
functions like this like thread param so

00:08:48,750 --> 00:08:51,220
for

00:08:49,030 --> 00:08:54,490
sample if we are if the function is

00:08:51,220 --> 00:08:57,910
expecting an integer as a parameter like

00:08:54,490 --> 00:08:59,920
here it's going to cast the input

00:08:57,910 --> 00:09:03,790
parameter it's going to assign the input

00:08:59,920 --> 00:09:06,160
parameter to the input argument to a

00:09:03,790 --> 00:09:09,510
parameter of the integral type and it's

00:09:06,160 --> 00:09:13,020
going to register it in the context

00:09:09,510 --> 00:09:15,040
similarly if it's a placeholder

00:09:13,020 --> 00:09:20,800
placeholder like underscore one

00:09:15,040 --> 00:09:22,840
underscore two we are going to store

00:09:20,800 --> 00:09:24,940
which is the actual index that it's

00:09:22,840 --> 00:09:27,280
being passed because we need to know it

00:09:24,940 --> 00:09:31,180
later when we shall read the goal for my

00:09:27,280 --> 00:09:33,280
how to forward the arguments and let's

00:09:31,180 --> 00:09:37,620
see a case that it's a bit more fun than

00:09:33,280 --> 00:09:40,660
that so easy fit can't take another

00:09:37,620 --> 00:09:42,850
parameter for the sensation another

00:09:40,660 --> 00:09:44,890
object from is a sheet because maybe you

00:09:42,850 --> 00:09:49,150
want to compose the things that you

00:09:44,890 --> 00:09:52,620
created so if it's the input the thing

00:09:49,150 --> 00:09:54,550
that it's being passed it's a easy sheet

00:09:52,620 --> 00:09:57,640
function trapper which is the object

00:09:54,550 --> 00:09:59,800
that wraps the generated code

00:09:57,640 --> 00:10:02,920
we are going to check if the Associated

00:09:59,800 --> 00:10:05,800
function type if we can assign it to the

00:10:02,920 --> 00:10:10,300
two expected argument respected

00:10:05,800 --> 00:10:12,310
parameter and if it's possible if it's

00:10:10,300 --> 00:10:14,050
not possible we are going to show a fail

00:10:12,310 --> 00:10:16,930
fail the compilation but if it's

00:10:14,050 --> 00:10:22,660
possible we are going to register that

00:10:16,930 --> 00:10:25,300
in the context and structures also we

00:10:22,660 --> 00:10:29,200
can pass as parameters and if it's a

00:10:25,300 --> 00:10:34,960
structure we would like to ideally treat

00:10:29,200 --> 00:10:38,800
it as if it was a string of bytes but we

00:10:34,960 --> 00:10:43,570
can expect that this does not work as

00:10:38,800 --> 00:10:45,100
expected why many reasons one of the

00:10:43,570 --> 00:10:47,890
reasons is that there is padding between

00:10:45,100 --> 00:10:51,730
the the fields of the structures

00:10:47,890 --> 00:10:54,820
typically which gives some problems and

00:10:51,730 --> 00:10:59,350
there is another complication so imagine

00:10:54,820 --> 00:10:59,660
we have this pair of T and we have this

00:10:59,350 --> 00:11:02,060
fine

00:10:59,660 --> 00:11:06,470
food that takes two T's just for example

00:11:02,060 --> 00:11:11,060
if ocation and we try to pass two pairs

00:11:06,470 --> 00:11:13,520
of int to the Foo function then add LLVM

00:11:11,060 --> 00:11:16,540
intermediate representation we will have

00:11:13,520 --> 00:11:18,440
a call taking as parameters to integers

00:11:16,540 --> 00:11:22,430
why two integrals

00:11:18,440 --> 00:11:25,400
well apparently on the x86 underscore 64

00:11:22,430 --> 00:11:26,960
ABI if it fits on an integral the

00:11:25,400 --> 00:11:30,440
structure that we are passing and it's

00:11:26,960 --> 00:11:32,270
only the fields are aligned we are going

00:11:30,440 --> 00:11:33,590
to pass them in registers and you are

00:11:32,270 --> 00:11:37,160
going to pack everything in the smallest

00:11:33,590 --> 00:11:40,730
in the garage you can what happened if

00:11:37,160 --> 00:11:42,560
it's a pair of doubles we we while going

00:11:40,730 --> 00:11:49,100
to pass each structure has two doubles

00:11:42,560 --> 00:11:51,860
to a function okay since fair what if we

00:11:49,100 --> 00:11:55,100
are passing a pair of pair of Devils I

00:11:51,860 --> 00:11:59,360
know then it's going to be pass through

00:11:55,100 --> 00:12:00,770
memory with some pointers okay but

00:11:59,360 --> 00:12:03,380
what's the problem with all of this you

00:12:00,770 --> 00:12:06,200
mention that someone tells you okay swap

00:12:03,380 --> 00:12:08,510
the arguments for a pair of doubles and

00:12:06,200 --> 00:12:10,670
we have four arguments and where does

00:12:08,510 --> 00:12:13,370
the first structure begins and where

00:12:10,670 --> 00:12:15,010
does the second structure ends we cannot

00:12:13,370 --> 00:12:18,670
know it and we have to capture this

00:12:15,010 --> 00:12:22,820
somehow and this is dependent on the ABI

00:12:18,670 --> 00:12:25,790
we are getting into scary territory so

00:12:22,820 --> 00:12:29,420
the solution that I found for this is to

00:12:25,790 --> 00:12:31,940
introduce a function called serious

00:12:29,420 --> 00:12:34,610
civilized argument that will take the

00:12:31,940 --> 00:12:39,140
structure by by value and it's going to

00:12:34,610 --> 00:12:41,840
return car pointer we told the fields

00:12:39,140 --> 00:12:45,230
flatten how can you implement this

00:12:41,840 --> 00:12:47,600
function not in C++ but that's why I

00:12:45,230 --> 00:12:50,090
have the compiler so I can implement it

00:12:47,600 --> 00:12:51,980
on the compiler side it can check

00:12:50,090 --> 00:12:55,130
introspect the signature of the function

00:12:51,980 --> 00:12:56,990
on initialized correctly this this

00:12:55,130 --> 00:12:59,680
arrived and we can also register to the

00:12:56,990 --> 00:13:05,090
runtime that okay this parameter here

00:12:59,680 --> 00:13:06,860
it's passed us two doubles in the to the

00:13:05,090 --> 00:13:10,610
Col function or if it's pass of a

00:13:06,860 --> 00:13:12,680
pointer and etc this last feature it's

00:13:10,610 --> 00:13:13,459
currently on work it's almost finished

00:13:12,680 --> 00:13:18,579
its own

00:13:13,459 --> 00:13:18,579
there I have to give it the last push

00:13:18,699 --> 00:13:24,589
and there are some other stuff in the in

00:13:21,319 --> 00:13:27,730
the sheet Wantage library so for example

00:13:24,589 --> 00:13:30,649
we have some options to control their

00:13:27,730 --> 00:13:32,540
how their code is compiled that can be

00:13:30,649 --> 00:13:35,720
useful to say ok kanpai with - Oh free

00:13:32,540 --> 00:13:37,610
or - Oh zero zero or something else or

00:13:35,720 --> 00:13:40,879
to affect how the compilation pipeline

00:13:37,610 --> 00:13:44,569
works we expect to extend this as you

00:13:40,879 --> 00:13:47,269
will see later why not have a code cache

00:13:44,569 --> 00:13:50,360
so this context object but I talked

00:13:47,269 --> 00:13:57,050
about it's comparable its cacheable so

00:13:50,360 --> 00:14:00,679
this I in plumeria ste D you know that

00:13:57,050 --> 00:14:02,689
I'll map if no template parameters are

00:14:00,679 --> 00:14:06,259
specified it's going to use the context

00:14:02,689 --> 00:14:08,439
as the key of the map so for example if

00:14:06,259 --> 00:14:11,990
later with recompile this way

00:14:08,439 --> 00:14:13,819
try to get to another function with

00:14:11,990 --> 00:14:15,379
the same parameters and it's in the

00:14:13,819 --> 00:14:19,869
cache it's going to avoid recompilation

00:14:15,379 --> 00:14:23,600
and return directly the compiler checked

00:14:19,869 --> 00:14:25,279
I'm for threading well this is only C++

00:14:23,600 --> 00:14:27,259
there is nothing special no extension to

00:14:25,279 --> 00:14:29,540
a language that's nothing really weird

00:14:27,259 --> 00:14:32,889
we can move the objects in and out and

00:14:29,540 --> 00:14:36,170
all around so you can use your regular

00:14:32,889 --> 00:14:40,670
C++ constructs and everything it's

00:14:36,170 --> 00:14:42,529
supposed to work and normally does you

00:14:40,670 --> 00:14:45,589
can also cut do some more fun you can

00:14:42,529 --> 00:14:49,129
serialize your compile function into a

00:14:45,589 --> 00:14:51,470
string send it through to a server and

00:14:49,129 --> 00:14:54,529
the server loads this compile this and

00:14:51,470 --> 00:15:04,249
starts executing it yeah totally not a

00:14:54,529 --> 00:15:05,720
security danger but you can do it as I

00:15:04,249 --> 00:15:08,240
said before you can compose the

00:15:05,720 --> 00:15:10,490
generated objects one with another one

00:15:08,240 --> 00:15:13,699
so here for example the function the

00:15:10,490 --> 00:15:15,799
function foo takes two integers AMD we

00:15:13,699 --> 00:15:17,749
generate a new function foo a a that

00:15:15,799 --> 00:15:22,279
only takes one integer and we are now

00:15:17,749 --> 00:15:24,679
able to pass the full aaaa to the map

00:15:22,279 --> 00:15:27,339
Beck function and obtain something

00:15:24,679 --> 00:15:27,339
specialized

00:15:28,930 --> 00:15:37,670
but now let's forget about the compiler

00:15:31,519 --> 00:15:40,430
like the compiler the C++ library and

00:15:37,670 --> 00:15:42,890
let us talk a little bit about the the

00:15:40,430 --> 00:15:44,720
plugin so the plugin it's actually

00:15:42,890 --> 00:15:46,459
really really simple and one of the

00:15:44,720 --> 00:15:49,190
ideas is that it has to be as simple as

00:15:46,459 --> 00:15:52,100
possible because it has to be fun and I

00:15:49,190 --> 00:15:54,829
don't want to maintain it so what it

00:15:52,100 --> 00:15:57,860
does so to use the plug-in you have to

00:15:54,829 --> 00:15:58,430
when you specify one flag - X Clank -

00:15:57,860 --> 00:16:01,089
low

00:15:58,430 --> 00:16:03,589
- X Clank and the name of the library

00:16:01,089 --> 00:16:06,890
now you're done nothing special nothing

00:16:03,589 --> 00:16:10,399
weird and you can use your regular clang

00:16:06,890 --> 00:16:13,910
and supposed to work then we have to

00:16:10,399 --> 00:16:15,740
identify with this what the the main

00:16:13,910 --> 00:16:18,290
goal of the compiler plugins to identify

00:16:15,740 --> 00:16:20,899
which functions are used by easy so

00:16:18,290 --> 00:16:22,700
for doing this we see what are the types

00:16:20,899 --> 00:16:23,870
and the values that are passed to the to

00:16:22,700 --> 00:16:27,500
this you should function and we're going

00:16:23,870 --> 00:16:29,329
to keep to start going up on the on the

00:16:27,500 --> 00:16:31,190
values that are assigned to it and we're

00:16:29,329 --> 00:16:34,399
going to try to discover which ones they

00:16:31,190 --> 00:16:37,250
are unlikely there are some problems

00:16:34,399 --> 00:16:39,440
sometimes so for example if the function

00:16:37,250 --> 00:16:42,050
it's declared in another combination you

00:16:39,440 --> 00:16:43,490
need the compiler is not really able to

00:16:42,050 --> 00:16:47,180
deduce it's coming from another

00:16:43,490 --> 00:16:49,399
compilation you need so it's not able to

00:16:47,180 --> 00:16:51,560
handle it so now it's the shop for the

00:16:49,399 --> 00:16:55,130
programmer to say ok yeah this function

00:16:51,560 --> 00:16:58,130
here export the debit code or you can

00:16:55,130 --> 00:17:01,160
use a just regular expression and dot

00:16:58,130 --> 00:17:05,780
star it's a regular expression where you

00:17:01,160 --> 00:17:08,689
export everything and it works there is

00:17:05,780 --> 00:17:10,610
also one option in Clank called F and

00:17:08,689 --> 00:17:13,880
bit bit code that embeds the bit code of

00:17:10,610 --> 00:17:16,579
the entire application in the executable

00:17:13,880 --> 00:17:17,150
I really I know how it works I know what

00:17:16,579 --> 00:17:20,360
it gives

00:17:17,150 --> 00:17:22,449
I really haven't tried using it because

00:17:20,360 --> 00:17:25,130
in my vision of a just in time compiler

00:17:22,449 --> 00:17:27,199
or the use of the shutting the compiler

00:17:25,130 --> 00:17:28,730
there are only a few kernel function

00:17:27,199 --> 00:17:32,960
that you would like to break on pilot

00:17:28,730 --> 00:17:35,870
runtime not your entire application but

00:17:32,960 --> 00:17:39,309
who knows maybe the other one is the

00:17:35,870 --> 00:17:39,309
best approach I don't know

00:17:39,950 --> 00:17:46,200
one thing it's worthy score this lever

00:17:44,070 --> 00:17:48,420
is going because it's really early and

00:17:46,200 --> 00:17:52,050
we are young we want to have a lot of

00:17:48,420 --> 00:17:53,370
fun so one of the obvious idea to

00:17:52,050 --> 00:17:55,620
implement with a just-in-time compiler

00:17:53,370 --> 00:17:57,600
is to say okay do profile guided

00:17:55,620 --> 00:18:00,330
optimization that's why that's the

00:17:57,600 --> 00:18:02,550
advantage that you have at runtime so we

00:18:00,330 --> 00:18:06,780
want to have an extra option to specify

00:18:02,550 --> 00:18:09,900
okay here this is my profile data

00:18:06,780 --> 00:18:12,180
structure run a create a profile version

00:18:09,900 --> 00:18:14,310
of the code this profile version of the

00:18:12,180 --> 00:18:16,770
code will fill this profile data data

00:18:14,310 --> 00:18:20,370
and then we can reduce what has been

00:18:16,770 --> 00:18:21,840
profile to rep demise the code based on

00:18:20,370 --> 00:18:23,910
this profile data and perform some

00:18:21,840 --> 00:18:25,860
speculation so with something like this

00:18:23,910 --> 00:18:28,160
you can say okay yeah I see that

00:18:25,860 --> 00:18:30,810
we are always calling the same function

00:18:28,160 --> 00:18:34,650
indirectly well here you have the

00:18:30,810 --> 00:18:36,330
vehicle for that function inline it and

00:18:34,650 --> 00:18:45,720
you can get some extra performance like

00:18:36,330 --> 00:18:48,780
that then in some really the next

00:18:45,720 --> 00:18:52,110
objective will be to create a version

00:18:48,780 --> 00:18:54,720
that does this automatically I find it

00:18:52,110 --> 00:18:58,380
scary but maybe someone it's really

00:18:54,720 --> 00:19:00,470
happy to to let the just-in-time

00:18:58,380 --> 00:19:03,390
compiler intervene whenever he wants

00:19:00,470 --> 00:19:05,430
like this the comp the function offset

00:19:03,390 --> 00:19:07,740
will decide by itself that yeah okay

00:19:05,430 --> 00:19:11,580
instrument now ya know now executed

00:19:07,740 --> 00:19:13,140
optimize okay recompile or recompile in

00:19:11,580 --> 00:19:18,480
a background thread and let's see what

00:19:13,140 --> 00:19:20,640
happens and so on and the final

00:19:18,480 --> 00:19:23,700
objective the goal objective that me and

00:19:20,640 --> 00:19:26,460
many people may have and there are many

00:19:23,700 --> 00:19:28,800
the doctorate thesis on this topic it's

00:19:26,460 --> 00:19:31,170
to perform partial evaluation is to say

00:19:28,800 --> 00:19:34,590
okay for example we have the evaluate

00:19:31,170 --> 00:19:36,600
function that evaluates an ast on a

00:19:34,590 --> 00:19:38,850
valuation of variables and you say okay

00:19:36,600 --> 00:19:43,790
you know what they ask is never going to

00:19:38,850 --> 00:19:46,500
change from now on so it's immutable

00:19:43,790 --> 00:19:52,070
generate a version of the code that it's

00:19:46,500 --> 00:19:52,070
equivalent to compiling this this is T

00:19:52,950 --> 00:19:59,010
and this is actually really difficult

00:19:55,230 --> 00:20:02,960
for what I'm investigating but I'm

00:19:59,010 --> 00:20:05,820
moving forward on that and it's not easy

00:20:02,960 --> 00:20:08,280
and we need to introduce this notion of

00:20:05,820 --> 00:20:10,050
immutability which means that the ECT

00:20:08,280 --> 00:20:12,900
table the function object created takes

00:20:10,050 --> 00:20:16,260
ownership of this ast because if I

00:20:12,900 --> 00:20:18,900
didn't inline everything everybody that

00:20:16,260 --> 00:20:21,720
it touches and somebody allocates the

00:20:18,900 --> 00:20:23,810
memory for this subject everything's

00:20:21,720 --> 00:20:27,510
going to crush on people so and today

00:20:23,810 --> 00:20:29,520
technically and many more stuff so for

00:20:27,510 --> 00:20:32,280
example I didn't implemented support for

00:20:29,520 --> 00:20:34,170
metals not because I didn't want to it's

00:20:32,280 --> 00:20:36,800
because I'm not good at C++ and I did

00:20:34,170 --> 00:20:40,980
not find it fun but it should be

00:20:36,800 --> 00:20:43,020
straightforward for function offsets it

00:20:40,980 --> 00:20:45,870
should be also similar to for dust for

00:20:43,020 --> 00:20:47,520
metals it will be really nice to also

00:20:45,870 --> 00:20:49,110
implement to continue with the cache on

00:20:47,520 --> 00:20:53,070
the data structures to implement a

00:20:49,110 --> 00:20:56,820
threading cache or a cache that supports

00:20:53,070 --> 00:20:59,730
at least civilization I'll persist or

00:20:56,820 --> 00:21:01,590
persistence I haven't implemented

00:20:59,730 --> 00:21:04,770
because I didn't thought that was fun it

00:21:01,590 --> 00:21:07,230
was fun and there is yeah there is a

00:21:04,770 --> 00:21:09,750
spin of a fizzy so if there is one

00:21:07,230 --> 00:21:13,770
guy who it and it's using it to

00:21:09,750 --> 00:21:16,350
prototype an auto tuner for C++ and he's

00:21:13,770 --> 00:21:20,010
going to be presenting it in two weeks

00:21:16,350 --> 00:21:22,950
for the during the LLVM developer

00:21:20,010 --> 00:21:26,670
meeting so if you want to see his

00:21:22,950 --> 00:21:28,680
presentation and if you're there go and

00:21:26,670 --> 00:21:31,650
yeah why not showing the fun because

00:21:28,680 --> 00:21:33,330
easy it's a fun project I do it as

00:21:31,650 --> 00:21:34,380
a hobby and if you want to contribute it

00:21:33,330 --> 00:21:37,890
will be really cool because I'm looking

00:21:34,380 --> 00:21:40,050
to learn so if you really like to enter

00:21:37,890 --> 00:21:42,630
into the LLVM easy

00:21:40,050 --> 00:21:44,820
maybe the person for you because it

00:21:42,630 --> 00:21:46,680
actually it's really the code that it

00:21:44,820 --> 00:21:49,680
takes as input is really simple there

00:21:46,680 --> 00:21:51,960
are many low-hanging fruits for example

00:21:49,680 --> 00:21:54,240
the profiling and the optimization based

00:21:51,960 --> 00:21:57,690
on the profiling shouldn't be that

00:21:54,240 --> 00:22:01,200
difficult to to optimize to implement

00:21:57,690 --> 00:22:03,720
and it's something that feels fun this

00:22:01,200 --> 00:22:06,030
for me and maybe you are a really good

00:22:03,720 --> 00:22:06,570
C++ programmer and maybe you even like

00:22:06,030 --> 00:22:10,170
to tell

00:22:06,570 --> 00:22:12,930
someone got something wrong I got a lot

00:22:10,170 --> 00:22:16,050
of things wrong in my in my code so yeah

00:22:12,930 --> 00:22:17,520
is it maybe the project for you and

00:22:16,050 --> 00:22:20,000
everything it's on github if you want to

00:22:17,520 --> 00:22:20,000
check it out

00:22:20,360 --> 00:22:25,490
yeah does anyone have some questions

00:22:28,190 --> 00:22:40,650
make it portable it shouldn't be really

00:22:37,770 --> 00:22:43,200
I'm not using anything architecture or

00:22:40,650 --> 00:22:45,960
operating system specific maybe there

00:22:43,200 --> 00:22:48,240
may be there may be some complications I

00:22:45,960 --> 00:22:50,460
should repeat the question so what's the

00:22:48,240 --> 00:22:53,610
footprint - the question was what's the

00:22:50,460 --> 00:23:02,520
footprint - port is it to another

00:22:53,610 --> 00:23:03,780
platform or yeah okay how much the

00:23:02,520 --> 00:23:05,760
question is how much bigger the

00:23:03,780 --> 00:23:07,950
application will be because you include

00:23:05,760 --> 00:23:10,170
the LLVM Justin compiler and everything

00:23:07,950 --> 00:23:13,320
yeah really big because you have to ship

00:23:10,170 --> 00:23:15,540
with the entire LLVM yeah that's program

00:23:13,320 --> 00:23:18,840
I have some ideas of how to reduce you'd

00:23:15,540 --> 00:23:21,620
reduce it but it's not really easy to do

00:23:18,840 --> 00:23:26,430
on here for the moment I'm shipping with

00:23:21,620 --> 00:23:55,710
the entire big part of LLVM within which

00:23:26,430 --> 00:24:00,510
is not good but yeah I'm not shipping

00:23:55,710 --> 00:24:02,340
yeah yeah so it's not to ship clang it's

00:24:00,510 --> 00:24:04,050
the LLVM that it's shipped and yet those

00:24:02,340 --> 00:24:06,000
are really great ideas that I have to

00:24:04,050 --> 00:24:08,250
try like reducing the amount of targets

00:24:06,000 --> 00:24:10,440
that are shipped with the application

00:24:08,250 --> 00:24:11,610
because you are probably going to

00:24:10,440 --> 00:24:15,630
for the same target that you're running

00:24:11,610 --> 00:24:17,280
I mean you're probably going to compile

00:24:15,630 --> 00:24:19,680
your code for the same target you are

00:24:17,280 --> 00:24:21,300
running on so

00:24:19,680 --> 00:24:23,880
reduce the amount of optimizations that

00:24:21,300 --> 00:24:27,300
will greatly greatly reduce the size of

00:24:23,880 --> 00:24:29,610
the goes for now it should be around 40

00:24:27,300 --> 00:24:31,830
mega so I guess or 30 with the dream

00:24:29,610 --> 00:24:45,960
library and it's not something

00:24:31,830 --> 00:24:49,290
acceptable ok yes hi so obviously the

00:24:45,960 --> 00:24:51,240
the most prominent application of this

00:24:49,290 --> 00:24:55,320
kind of thing is looping optimization

00:24:51,240 --> 00:24:59,450
right and one piece of hardware that

00:24:55,320 --> 00:25:03,170
runs lots of loops is our GPUs and yeah

00:24:59,450 --> 00:25:05,670
the clang for Ned has support for CUDA

00:25:03,170 --> 00:25:09,960
have you looked at what would be

00:25:05,670 --> 00:25:11,880
involved in getting CUDA code for this

00:25:09,960 --> 00:25:13,980
kind of thing I actually haven't checked

00:25:11,880 --> 00:25:25,130
but that's a really interesting just

00:25:13,980 --> 00:25:25,130
case any questions

00:25:27,580 --> 00:25:32,849
okay thanks

00:25:29,210 --> 00:25:32,849

YouTube URL: https://www.youtube.com/watch?v=_WPdof1dTqo


