Title: CppCon 2018: Nicole Mazzuca “Value Semantics: Fast, Safe, and Correct by Default”
Publication date: 2018-10-15
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
We hear a lot about value semantics whenever there's discussion of C++, and value semantics are often credited as one of the "Big Ideas" of C++; but what does this phrase mean? And how can you use the principles of value semantics and regularity to make your code faster and more correct? 

We'll touch on using the existing value semantic standard library types, as well as creating your own types that follow these principles. You will learn useful optimization habits which create faster code without giving up the benefits of value semantics. I'll show you how to think in a value semantic way, so that your code is simple, fast, and correct!
— 
Nicole Mazzuca
Software Engineering Intern, Microsoft
Nicole Mazzuca is a C++ and Rust programmer who is very interested in object models - she is helping to write the Rust object model, and as such has studied other object models heavily, especially C++'s.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:07,109
all right so I'm gonna talk about value

00:00:03,990 --> 00:00:10,889
types today and why they are awesome and

00:00:07,109 --> 00:00:13,110
fast safe and correct uh I'll mostly be

00:00:10,889 --> 00:00:16,550
talking about safe and correct fast

00:00:13,110 --> 00:00:20,250
isn't another talk um

00:00:16,550 --> 00:00:27,930
warning I am pretty sick so I'm kind of

00:00:20,250 --> 00:00:31,949
out of it and I make off a lot so pretty

00:00:27,930 --> 00:00:35,880
warning you alright so first of all who

00:00:31,949 --> 00:00:39,870
am i i I'm Nicole mizuka I am a trans

00:00:35,880 --> 00:00:43,890
woman who just interned at V C++ over

00:00:39,870 --> 00:00:47,520
the summer I'm a student at Western and

00:00:43,890 --> 00:01:00,210
I'm a general C++ nerd my twitter handle

00:00:47,520 --> 00:01:02,100
is at ub san because ub is great so the

00:01:00,210 --> 00:01:04,320
first thing we need to talk about when

00:01:02,100 --> 00:01:08,990
we're talking about value semantics is

00:01:04,320 --> 00:01:12,750
what actually our value semantics and

00:01:08,990 --> 00:01:16,320
people often use this term but in my

00:01:12,750 --> 00:01:18,990
experience people use it without really

00:01:16,320 --> 00:01:25,110
understanding what's going on for

00:01:18,990 --> 00:01:31,909
example what the hex of value anybody

00:01:25,110 --> 00:01:34,970
know what's a value like an end sure

00:01:31,909 --> 00:01:39,479
we're gonna talk about platonic ideals

00:01:34,970 --> 00:01:44,340
events in fact we're gonna talk about

00:01:39,479 --> 00:01:46,710
what the essence of a value is the

00:01:44,340 --> 00:01:48,810
easiest place to start is with the ents

00:01:46,710 --> 00:01:52,020
or a subset of the ant's the natural

00:01:48,810 --> 00:01:56,340
numbers we've got something like one

00:01:52,020 --> 00:01:59,219
we've got something like two these exist

00:01:56,340 --> 00:02:01,530
like well okay we're going to pretend

00:01:59,219 --> 00:02:05,759
that they exist for the purposes of this

00:02:01,530 --> 00:02:10,039
talk we'll get into the Platonic debate

00:02:05,759 --> 00:02:13,890
later and they exist outside of C++ like

00:02:10,039 --> 00:02:14,280
C++ did not invent one does anyone want

00:02:13,890 --> 00:02:22,620
to argue

00:02:14,280 --> 00:02:24,930
otherwise and so we kind of in in

00:02:22,620 --> 00:02:28,950
mathematics and in the world we have

00:02:24,930 --> 00:02:31,920
these ideas where they're like literal

00:02:28,950 --> 00:02:37,230
numbers like we don't just invent these

00:02:31,920 --> 00:02:39,360
did I guess we did just invent them but

00:02:37,230 --> 00:02:46,560
that's unimportant because we're going

00:02:39,360 --> 00:02:50,220
to talk about C++ next because in C++ we

00:02:46,560 --> 00:02:53,550
have values as well we have you know 1 2

00:02:50,220 --> 00:02:57,870
negative 1 0 is a very important one

00:02:53,550 --> 00:03:04,709
we have no pointer and these are all

00:02:57,870 --> 00:03:09,690
kind of examples of translating these

00:03:04,709 --> 00:03:14,220
platonic ideals of values into literal

00:03:09,690 --> 00:03:20,640
bits and bytes or literal on and off

00:03:14,220 --> 00:03:22,500
switches in your computer and I don't

00:03:20,640 --> 00:03:25,079
know about you but one of my favorite

00:03:22,500 --> 00:03:28,019
things about C++ is that it's statically

00:03:25,079 --> 00:03:37,820
typed and that means that every value in

00:03:28,019 --> 00:03:37,820
C++ has a type what's that I don't know

00:03:37,880 --> 00:03:42,980
there are a lot of things that go into

00:03:39,989 --> 00:03:46,620
attack but for this specific

00:03:42,980 --> 00:03:57,630
presentation what we care about is that

00:03:46,620 --> 00:03:59,730
a type defines a set of values so how do

00:03:57,630 --> 00:04:05,220
I want to say that I type defines a set

00:03:59,730 --> 00:04:10,880
of values that belong to that type there

00:04:05,220 --> 00:04:10,880
are subsets of an actual Platonic ideal

00:04:11,359 --> 00:04:19,799
and by the way I realize I'm going into

00:04:15,630 --> 00:04:22,140
very mathy wording if anyone has any

00:04:19,799 --> 00:04:26,520
questions please just shout them out I

00:04:22,140 --> 00:04:28,320
will answer them so we have these kind

00:04:26,520 --> 00:04:35,010
of platonic ideals

00:04:28,320 --> 00:04:40,010
like say the integers and each type that

00:04:35,010 --> 00:04:45,780
models integers is some holds some

00:04:40,010 --> 00:04:52,770
subset of that infinitely large set so

00:04:45,780 --> 00:04:54,720
for example we've got int the Platonic

00:04:52,770 --> 00:04:58,080
ideal of integers is the set of natural

00:04:54,720 --> 00:05:02,790
numbers and the additive in two in the

00:04:58,080 --> 00:05:07,860
additive inverses of those numbers int

00:05:02,790 --> 00:05:09,720
specifically though is the set negative

00:05:07,860 --> 00:05:12,780
two to the thirty one two two to the

00:05:09,720 --> 00:05:14,550
thirty one exclusive intersects with the

00:05:12,780 --> 00:05:17,010
integers so so basically it's the

00:05:14,550 --> 00:05:20,790
integers from negative two to the thirty

00:05:17,010 --> 00:05:22,200
one two okay good I was just making sure

00:05:20,790 --> 00:05:25,260
that that negative sign was in the right

00:05:22,200 --> 00:05:27,540
place to night two two to the thirty one

00:05:25,260 --> 00:05:33,530
on common implementations we're going to

00:05:27,540 --> 00:05:33,530
ignore all bad implementations of C++

00:05:33,560 --> 00:05:40,110
for example okay I actually can't think

00:05:38,430 --> 00:05:45,960
of any implementations where int is not

00:05:40,110 --> 00:05:51,260
there DC plates you know what I'm sure

00:05:45,960 --> 00:05:54,750
that exists and so you can see that int

00:05:51,260 --> 00:05:58,710
the values events are a strict subset of

00:05:54,750 --> 00:06:00,720
the set integer which are infinite and

00:05:58,710 --> 00:06:02,490
obviously we cannot have infinite things

00:06:00,720 --> 00:06:06,930
in computers because they are finite

00:06:02,490 --> 00:06:10,250
spaces now what did I want to say about

00:06:06,930 --> 00:06:16,890
that it's like a useful thing about that

00:06:10,250 --> 00:06:19,530
well anyways we also must invariably

00:06:16,890 --> 00:06:23,130
talk about objects we're gonna switch

00:06:19,530 --> 00:06:30,000
gears a little bit so we have values

00:06:23,130 --> 00:06:35,910
they are some subset of a of a Platonic

00:06:30,000 --> 00:06:38,940
ideal the set of values but in C++ we

00:06:35,910 --> 00:06:41,190
aren't Haskell we have mutability not

00:06:38,940 --> 00:06:42,000
everything is a value we also have

00:06:41,190 --> 00:06:45,120
places

00:06:42,000 --> 00:06:48,300
to store values and places to mutate

00:06:45,120 --> 00:06:53,160
those values well we have places to

00:06:48,300 --> 00:06:56,580
replace them an object is a place where

00:06:53,160 --> 00:06:59,220
a value can and usually does live and we

00:06:56,580 --> 00:07:01,770
can put a value in an object and we can

00:06:59,220 --> 00:07:05,640
replace the value in the object assuming

00:07:01,770 --> 00:07:09,300
the object is non Const so for example

00:07:05,640 --> 00:07:12,690
the simplest program the second simplest

00:07:09,300 --> 00:07:17,400
program in C++ that you can write is int

00:07:12,690 --> 00:07:19,980
x equals 0 you create an an X or an

00:07:17,400 --> 00:07:22,560
object and we're going to call it X

00:07:19,980 --> 00:07:28,470
where an INT lives and then we're gonna

00:07:22,560 --> 00:07:30,210
put 0 in that storage space so we're

00:07:28,470 --> 00:07:34,080
talking a little bit about objects the

00:07:30,210 --> 00:07:40,460
fun thing about C++ is that objects can

00:07:34,080 --> 00:07:44,820
actually be treated like values we can

00:07:40,460 --> 00:07:49,380
here write into x equals 0 in y equals x

00:07:44,820 --> 00:07:53,100
and this is exactly equivalent to int x

00:07:49,380 --> 00:08:00,419
equals 0 in y equals 0 because x is 0 so

00:07:53,100 --> 00:08:02,430
Y now has the value of x which is 0 but

00:08:00,419 --> 00:08:05,070
going back to mutation this is this is

00:08:02,430 --> 00:08:08,120
all non mutating we all we keep all the

00:08:05,070 --> 00:08:10,770
objects having the same values

00:08:08,120 --> 00:08:11,970
probably should have constant them you

00:08:10,770 --> 00:08:14,729
know you really want to console the

00:08:11,970 --> 00:08:20,460
things to truly bring out the haskell a

00:08:14,729 --> 00:08:22,770
nature of c++ but we can also assign we

00:08:20,460 --> 00:08:28,830
can change the value that lives inside

00:08:22,770 --> 00:08:32,700
an object for example into x equals 0 x

00:08:28,830 --> 00:08:37,110
equals 1 this might seem like kind of

00:08:32,700 --> 00:08:42,289
obvious but we'll go a little further a

00:08:37,110 --> 00:08:47,339
little later so X here at the top right

00:08:42,289 --> 00:08:51,810
here has the value 0 and right here has

00:08:47,339 --> 00:08:54,360
the value 1 note that assignment is very

00:08:51,810 --> 00:08:55,830
distinct from initialization they use

00:08:54,360 --> 00:08:58,830
the similar syntax

00:08:55,830 --> 00:09:01,040
they are not the same thing keep that in

00:08:58,830 --> 00:09:01,040
mind

00:09:02,060 --> 00:09:06,960
so some cool things about int first of

00:09:05,340 --> 00:09:12,270
all there are quite a few successes of

00:09:06,960 --> 00:09:15,150
the interface we have this concept in

00:09:12,270 --> 00:09:17,580
C++ where for example in Haskell if you

00:09:15,150 --> 00:09:21,060
have an int type there is one int type

00:09:17,580 --> 00:09:23,310
in Python there is one int type but in

00:09:21,060 --> 00:09:25,340
C++ we have multiple in types we have

00:09:23,310 --> 00:09:32,250
int we have short we have car we have

00:09:25,340 --> 00:09:35,540
int 128 and if you have a value negative

00:09:32,250 --> 00:09:38,280
1 in int and a value negative 1 in short

00:09:35,540 --> 00:09:41,760
they are equal like they're the same

00:09:38,280 --> 00:09:46,590
they model the same float on ik ideal of

00:09:41,760 --> 00:09:48,420
that value and you can say return x

00:09:46,590 --> 00:09:51,360
equals equals y and it will do the right

00:09:48,420 --> 00:09:53,330
thing it will say yep x and y both

00:09:51,360 --> 00:09:55,350
negative 1 they're both equal

00:09:53,330 --> 00:10:01,050
unfortunately we also have unsigned

00:09:55,350 --> 00:10:05,850
numbers and this sucks because 255 and

00:10:01,050 --> 00:10:10,020
negative 1 are not equal in any same

00:10:05,850 --> 00:10:13,230
programming language there actually I

00:10:10,020 --> 00:10:17,760
just realized as I'm talking about this

00:10:13,230 --> 00:10:23,670
this will also return false for really

00:10:17,760 --> 00:10:26,040
gross reasons X is going to be widened

00:10:23,670 --> 00:10:27,330
to int so it'll be 255 int and why it

00:10:26,040 --> 00:10:31,520
will be widened to intend it'll be

00:10:27,330 --> 00:10:34,110
negative 1 int and that will be false

00:10:31,520 --> 00:10:41,690
imagine I did this with unsigned and int

00:10:34,110 --> 00:10:44,490
and worked that out sorry about that so

00:10:41,690 --> 00:10:48,780
compare comparison with unsigned is

00:10:44,490 --> 00:10:55,910
broken in some cases which is really

00:10:48,780 --> 00:10:59,340
unfortunate is very frustrating so

00:10:55,910 --> 00:11:03,330
unsigned does model the Platonic ideal

00:10:59,340 --> 00:11:06,720
of natural numbers it's a subset of the

00:11:03,330 --> 00:11:09,260
integers and yet max of unsigned is

00:11:06,720 --> 00:11:12,110
equal to negative 1 of

00:11:09,260 --> 00:11:13,850
and I don't know about you but in my

00:11:12,110 --> 00:11:18,500
math for billion does not equal negative

00:11:13,850 --> 00:11:22,300
one now let's talk about some more

00:11:18,500 --> 00:11:25,940
interesting types like standard string

00:11:22,300 --> 00:11:30,500
what is a standard string a standard

00:11:25,940 --> 00:11:32,420
string is a list of characters and the

00:11:30,500 --> 00:11:36,020
fun thing about lists of characters in

00:11:32,420 --> 00:11:42,710
C++ is that unlike Java for example or

00:11:36,020 --> 00:11:46,700
unlike I can't think of a c-sharp it

00:11:42,710 --> 00:11:49,400
works exactly the same so for example if

00:11:46,700 --> 00:11:55,100
you write stood string x equals hello

00:11:49,400 --> 00:11:58,040
and then stood string Y is equal to X Y

00:11:55,100 --> 00:12:00,440
is equal to X Y is hello X is hello

00:11:58,040 --> 00:12:02,590
they're both copies of the same value

00:12:00,440 --> 00:12:05,000
they both still have the same value and

00:12:02,590 --> 00:12:09,560
you can also have fun things like

00:12:05,000 --> 00:12:11,360
assignment where you set X equal to

00:12:09,560 --> 00:12:15,260
hello first and then you set it to

00:12:11,360 --> 00:12:21,590
goodbye and this object just kind of

00:12:15,260 --> 00:12:24,770
deals with it and you get comparison and

00:12:21,590 --> 00:12:26,540
equality on these objects and in this

00:12:24,770 --> 00:12:31,180
case even though they're different

00:12:26,540 --> 00:12:34,040
objects x and y are equal because they

00:12:31,180 --> 00:12:39,530
represent the same list of characters

00:12:34,040 --> 00:12:42,380
the same platonic value ideal an even

00:12:39,530 --> 00:12:46,190
cooler thing about C++ is we have other

00:12:42,380 --> 00:12:50,420
string types like stewed string view and

00:12:46,190 --> 00:12:53,290
car Const star and they both model the

00:12:50,420 --> 00:12:56,270
same platonic idealist and string now

00:12:53,290 --> 00:13:00,440
they don't have the same set of values

00:12:56,270 --> 00:13:03,440
to be clear stood string view or sorry

00:13:00,440 --> 00:13:06,800
car Const are models a different set of

00:13:03,440 --> 00:13:11,750
values than stood string because stood

00:13:06,800 --> 00:13:16,280
string can have internal nulls karke on

00:13:11,750 --> 00:13:19,400
star cannot however there's still lists

00:13:16,280 --> 00:13:22,310
of cares we can still compare them there

00:13:19,400 --> 00:13:22,850
might be there might be values that are

00:13:22,310 --> 00:13:28,430
unrepresented

00:13:22,850 --> 00:13:31,310
in Carrick OnStar but it's still a valid

00:13:28,430 --> 00:13:34,550
comparison to make and you get nice

00:13:31,310 --> 00:13:36,889
things like this where you allocate once

00:13:34,550 --> 00:13:40,250
and then don't allocate the other two

00:13:36,889 --> 00:13:43,579
times and you get all three are equal to

00:13:40,250 --> 00:13:44,990
each other they work exactly as they

00:13:43,579 --> 00:13:49,569
should they all modeled the same

00:13:44,990 --> 00:13:49,569
Platonic ideal they all are equal

00:13:50,050 --> 00:13:56,560
sidenote

00:13:51,819 --> 00:14:02,300
sometimes copies are expensive and so

00:13:56,560 --> 00:14:07,040
someone oh what's his name who invented

00:14:02,300 --> 00:14:09,290
moves Thank You Howard Hinnant I feel

00:14:07,040 --> 00:14:10,730
bad for forgetting that Howard Henin

00:14:09,290 --> 00:14:15,350
invented this thing called move

00:14:10,730 --> 00:14:20,180
semantics where you can steal the guts

00:14:15,350 --> 00:14:26,569
of some other object and so for example

00:14:20,180 --> 00:14:31,730
here we declare a local named X with

00:14:26,569 --> 00:14:36,579
value hello and then we return it and in

00:14:31,730 --> 00:14:40,610
C++ oh 3 and c++ 98 the abstract machine

00:14:36,579 --> 00:14:43,040
would look at this and say oh I have an

00:14:40,610 --> 00:14:46,759
X which is a standard string and I need

00:14:43,040 --> 00:14:48,889
to put it into the return slot of foo so

00:14:46,759 --> 00:14:52,759
I need to create a new object that has

00:14:48,889 --> 00:14:56,300
the value of X so I'll do a copy and

00:14:52,759 --> 00:14:57,410
I'll I'll allocate new memory and it

00:14:56,300 --> 00:14:59,750
doesn't actually happen that way with

00:14:57,410 --> 00:15:03,380
string because of sso but I'll allocate

00:14:59,750 --> 00:15:05,930
new memory and then I will mem copy the

00:15:03,380 --> 00:15:13,189
list of cares over and then I'll

00:15:05,930 --> 00:15:22,959
deallocate the old one yeah that is how

00:15:13,189 --> 00:15:26,240
that works so in this case since c++ 11

00:15:22,959 --> 00:15:29,720
instead of doing the whole allocate new

00:15:26,240 --> 00:15:33,860
memory copy the bytes over drop the old

00:15:29,720 --> 00:15:36,410
one and then return you just move the

00:15:33,860 --> 00:15:38,690
pointers over you

00:15:36,410 --> 00:15:43,730
like so this ex after this return

00:15:38,690 --> 00:15:45,769
statement is basically null and dropping

00:15:43,730 --> 00:15:50,660
a null an empty string doesn't do

00:15:45,769 --> 00:15:54,860
anything you can also do some fun things

00:15:50,660 --> 00:15:56,750
like creating your own types so we're

00:15:54,860 --> 00:16:00,379
gonna talk about writing your own value

00:15:56,750 --> 00:16:02,620
types and the cool thing about C++ is it

00:16:00,379 --> 00:16:07,490
makes it really easy to write your own

00:16:02,620 --> 00:16:11,329
types that just work with all of these

00:16:07,490 --> 00:16:17,540
examples so for example if you define a

00:16:11,329 --> 00:16:19,910
person as a pair of a name which is a

00:16:17,540 --> 00:16:24,350
standard string and an age with such as

00:16:19,910 --> 00:16:31,250
an int and this will just work like a

00:16:24,350 --> 00:16:37,480
value so I kind of see if I can do this

00:16:31,250 --> 00:16:37,480
I really like

00:16:47,350 --> 00:17:05,649
if we strike the person you we can

00:17:02,029 --> 00:17:05,649
define a new person really easily

00:17:08,140 --> 00:17:19,630
my name is Nichole and my age is 20 and

00:17:16,339 --> 00:17:22,120
it just works on all three compilers and

00:17:19,630 --> 00:17:27,799
we could do the fun thing where we have

00:17:22,120 --> 00:17:34,360
person why I'm gonna copy myself and it

00:17:27,799 --> 00:17:34,360
just works and I can return X dot age

00:17:34,840 --> 00:17:51,049
let's see we can look at this more

00:17:39,610 --> 00:17:53,649
prettily no you cannot get that to be

00:17:51,049 --> 00:17:58,940
prettier anyways this will return zero

00:17:53,649 --> 00:18:04,720
and this all just works and you can even

00:17:58,940 --> 00:18:04,720
like set a new value for each of these

00:18:11,049 --> 00:18:19,539
and so types in C++ types in C++

00:18:16,179 --> 00:18:24,610
just automatically work like this and

00:18:19,539 --> 00:18:28,869
unlike say C for example you just get

00:18:24,610 --> 00:18:32,379
these automatic safe defaults however

00:18:28,869 --> 00:18:33,759
there is an issue which is comparison if

00:18:32,379 --> 00:18:37,929
you remember we had when we were

00:18:33,759 --> 00:18:39,610
comparing strings we had nice things

00:18:37,929 --> 00:18:41,649
like if you had hello and you had

00:18:39,610 --> 00:18:44,850
another hello they were equal and if you

00:18:41,649 --> 00:18:50,379
had hello and goodbye they're not equal

00:18:44,850 --> 00:18:54,789
but this fails to compile with a like

00:18:50,379 --> 00:18:57,580
operator equals not found so in C++ 20

00:18:54,789 --> 00:19:02,259
they added this awesome thing called

00:18:57,580 --> 00:19:06,999
operator spaceship and basically writing

00:19:02,259 --> 00:19:09,429
this allows you to just automatically be

00:19:06,999 --> 00:19:11,109
able to operate your equals and operate

00:19:09,429 --> 00:19:14,700
or less than and operator greater and

00:19:11,109 --> 00:19:19,899
check if I am less than somebody else

00:19:14,700 --> 00:19:26,169
and unfortunately in C++ 17 you still

00:19:19,899 --> 00:19:29,470
have to write it out the long way see if

00:19:26,169 --> 00:19:33,210
I can get it to still to write it out

00:19:29,470 --> 00:19:37,179
the long way with all of these operators

00:19:33,210 --> 00:19:49,149
they're great aren't they but this is

00:19:37,179 --> 00:19:52,989
fixed in C++ 20 and so yeah so go out

00:19:49,149 --> 00:19:55,809
and write value types the resources I'm

00:19:52,989 --> 00:19:59,769
gonna show you are or I recommend you

00:19:55,809 --> 00:20:02,590
read are elements of programming the

00:19:59,769 --> 00:20:04,720
first chapter goes into value semantics

00:20:02,590 --> 00:20:09,220
far more than I did in 30 minutes and

00:20:04,720 --> 00:20:10,779
you can also go to our our in it don't

00:20:09,220 --> 00:20:15,249
know how to say that name our Demirtas

00:20:10,779 --> 00:20:19,659
blog and they will go over move

00:20:15,249 --> 00:20:22,230
semantics so thank you very much does

00:20:19,659 --> 00:20:22,230
anyone have any questions

00:20:28,210 --> 00:20:47,750
yeah yeah so if the idea is you rarely

00:20:43,190 --> 00:20:50,570
ever want to write any copy constructors

00:20:47,750 --> 00:20:52,880
move constructors or you oh sorry the

00:20:50,570 --> 00:20:56,050
question was what is the rule of zero

00:20:52,880 --> 00:20:58,910
why is the rule of zero the rule of zero

00:20:56,050 --> 00:21:02,690
basically in user code you really don't

00:20:58,910 --> 00:21:04,970
ever want to write copy constructors

00:21:02,690 --> 00:21:07,540
move constructors operated equals you

00:21:04,970 --> 00:21:11,060
want the language to do all that for you

00:21:07,540 --> 00:21:13,700
and there are cases where you are forced

00:21:11,060 --> 00:21:15,320
to write your own if you're writing

00:21:13,700 --> 00:21:19,450
library code for example or if you're

00:21:15,320 --> 00:21:23,120
wrapping a C interface and you should

00:21:19,450 --> 00:21:25,610
write all of them basically and if you

00:21:23,120 --> 00:21:27,560
don't write any of them then the

00:21:25,610 --> 00:21:28,700
language will just do everything for you

00:21:27,560 --> 00:21:35,680
which is wonderful

00:21:28,700 --> 00:21:35,680
I like being lazy any other questions

00:21:36,550 --> 00:21:48,200
cool thank you very much

00:21:42,020 --> 00:21:48,200

YouTube URL: https://www.youtube.com/watch?v=PkyD1iv3ATU


