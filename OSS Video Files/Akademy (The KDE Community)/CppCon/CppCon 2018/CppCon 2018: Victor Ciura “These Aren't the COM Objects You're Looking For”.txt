Title: CppCon 2018: Victor Ciura “These Aren't the COM Objects You're Looking For”
Publication date: 2018-10-10
Playlist: CppCon 2018
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2018
—
Windows COM is 25 years old. Yet it is relevant today more than ever, because Microsoft has bet its entire modern WinRT API on it (starting with Windows 8/10). But, if you’re familiar with the “old” COM with its idioms and SDK helper classes, you’re in for a treat. With the advent of modern C++ 17, using COM objects and new Windows APIs in your applications feels like a completely new experience. 
In this session, we’ll explore how using modern C++ features can radically transform the shape of your COM code. By eliminating a lot of boilerplate, your code will be much more readable and maintainable. Classic COM idioms around activation and QueryInterface() can feel totally different with modern C++ helpers. A beautiful example of modern COM usage is C++/WinRT (now part of Windows SDK). This is a standard C++ language projection for the new Windows Runtime API. 
COM memory management, data marshalling, string handling can all feel quite mechanical in nature and very error prone, so a little help from modern C++ facilities would be more than welcomed. Error handling and debugging can be cumbersome for COM like APIs; we’ll explore some tricks to improve this experience, as well. 
— 
Victor Ciura, CAPHYON
Software Developer

Victor Ciura is a Senior Software Engineer at CAPHYON and Technical Lead on the Advanced Installer team (http://www.advancedinstaller.com). 
For over a decade, he designed and implemented several core components and libraries of Advanced Installer.
He’s a regular guest at Computer Science Department of his Alma Mater, University of Craiova, where he gives student lectures & workshops on “Using C++STL for Competitive Programming and Software Development”. 
Currently, he spends most of his time working with his talented team on improving and extending the repackaging and virtualization technologies in Advanced Installer IDE, helping clients migrate their Win32 desktop apps to the Windows Store (MSIX).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,060 --> 00:00:05,160
good morning everyone thank you for

00:00:01,890 --> 00:00:08,130
coming especially at this hour in the

00:00:05,160 --> 00:00:12,990
morning and given the topic at hand

00:00:08,130 --> 00:00:16,109
I'm very impressed by the turnout my

00:00:12,990 --> 00:00:18,470
name is Victor and we'll be spending an

00:00:16,109 --> 00:00:26,460
hour this morning talking about a very

00:00:18,470 --> 00:00:29,519
sexy subject like calm objects and and

00:00:26,460 --> 00:00:31,640
back in July this happened my friend

00:00:29,519 --> 00:00:35,190
Simon tweeted this and I immediately

00:00:31,640 --> 00:00:38,760
identified with the problem but I'm I

00:00:35,190 --> 00:00:40,500
said I'm gonna roll with it and my

00:00:38,760 --> 00:00:45,469
daughter keeps telling me that I do look

00:00:40,500 --> 00:00:48,300
like GRU and just in case you're

00:00:45,469 --> 00:00:51,539
disoriented this is the roadmap for

00:00:48,300 --> 00:00:53,820
victory for the week you are in the

00:00:51,539 --> 00:00:58,980
third talk hope you're doing the right

00:00:53,820 --> 00:01:00,690
one and you won't regret it and let's

00:00:58,980 --> 00:01:04,619
move on with it

00:01:00,690 --> 00:01:08,460
this is part 1 of n for this topic that

00:01:04,619 --> 00:01:12,900
I'm trying to tackle it's an ambitious

00:01:08,460 --> 00:01:15,750
endeavor given the the interest in the

00:01:12,900 --> 00:01:17,570
community around this topic and I'm

00:01:15,750 --> 00:01:21,240
hoping to get a lot of feedback at

00:01:17,570 --> 00:01:25,020
especially at places like this with such

00:01:21,240 --> 00:01:27,060
a diverse pool of programmers with such

00:01:25,020 --> 00:01:29,880
a diverse background experience and

00:01:27,060 --> 00:01:32,310
actually using and deploying

00:01:29,880 --> 00:01:34,979
applications on top of calm components

00:01:32,310 --> 00:01:37,560
and depending on how well it goes and

00:01:34,979 --> 00:01:39,750
the feedback I receive I plan to refine

00:01:37,560 --> 00:01:43,590
and improve this and take it even

00:01:39,750 --> 00:01:46,890
further so I do really need your help

00:01:43,590 --> 00:01:49,560
and your feedback and ideas and let's

00:01:46,890 --> 00:01:51,899
see how it goes we will have some chairs

00:01:49,560 --> 00:01:55,950
here leftover from a different panel so

00:01:51,899 --> 00:01:59,040
we can do an improv impromptu container

00:01:55,950 --> 00:02:02,070
if you like so audience participation is

00:01:59,040 --> 00:02:03,420
encouraged and feel free to say whatever

00:02:02,070 --> 00:02:07,530
it's on your mind

00:02:03,420 --> 00:02:11,400
hope it's come related though so micom

00:02:07,530 --> 00:02:14,069
why are we talking about this have we

00:02:11,400 --> 00:02:18,349
really exhausted all the cool template

00:02:14,069 --> 00:02:21,359
topics that we can cover at CPP con well

00:02:18,349 --> 00:02:24,209
for me at least comb has been an

00:02:21,359 --> 00:02:26,760
important part of my professional career

00:02:24,209 --> 00:02:29,430
and this is mainly because of the

00:02:26,760 --> 00:02:34,980
constraints of the application I've been

00:02:29,430 --> 00:02:37,859
working on I've been working on this

00:02:34,980 --> 00:02:42,060
application at Westminster for over 13

00:02:37,859 --> 00:02:43,290
years now and advanced installer I just

00:02:42,060 --> 00:02:45,239
need to give you a little bit of a

00:02:43,290 --> 00:02:48,989
background so that you can better relate

00:02:45,239 --> 00:02:52,919
to my common story advancing story is an

00:02:48,989 --> 00:02:55,199
IDE and a tool chain that helps software

00:02:52,919 --> 00:02:57,930
developers to package and deploy their

00:02:55,199 --> 00:03:00,870
applications on Windows and at the same

00:02:57,930 --> 00:03:03,569
time it helps IT pros repackage and

00:03:00,870 --> 00:03:05,969
provision operating systems and deploy a

00:03:03,569 --> 00:03:09,480
line of business apps in enterprises at

00:03:05,969 --> 00:03:12,180
scale so as you might imagine advanced

00:03:09,480 --> 00:03:14,840
installer is a very wide it's an

00:03:12,180 --> 00:03:18,509
umbrella project is a very wide

00:03:14,840 --> 00:03:22,979
application with very different

00:03:18,509 --> 00:03:25,500
components underneath and given the task

00:03:22,979 --> 00:03:27,180
at hand in provisioning the operating

00:03:25,500 --> 00:03:29,430
system and deploying various kinds of

00:03:27,180 --> 00:03:32,790
applications you can imagine it has a

00:03:29,430 --> 00:03:35,939
very wide API surface area and it

00:03:32,790 --> 00:03:39,090
actually interacts with very with many

00:03:35,939 --> 00:03:42,479
components from the windows subsystem be

00:03:39,090 --> 00:03:45,060
there older and or newer features of the

00:03:42,479 --> 00:03:49,069
operating system so basically what we're

00:03:45,060 --> 00:03:53,159
trying is to help clients migrate their

00:03:49,069 --> 00:03:57,120
win32 applications to the modern

00:03:53,159 --> 00:03:58,049
application model like MSI X and maybe

00:03:57,120 --> 00:03:59,519
some of them will bring their

00:03:58,049 --> 00:04:02,729
applications in the Windows Store or

00:03:59,519 --> 00:04:07,919
Windows Store for business so as you

00:04:02,729 --> 00:04:10,169
might imagine this is a big endeavor we

00:04:07,919 --> 00:04:12,900
interact with so many components in the

00:04:10,169 --> 00:04:15,359
operating system and as we all know and

00:04:12,900 --> 00:04:19,349
love Windows you know that's all built

00:04:15,359 --> 00:04:23,370
on Chrome components and just before we

00:04:19,349 --> 00:04:25,020
get started I suspect I know the answer

00:04:23,370 --> 00:04:27,870
but I want to get the feel for the room

00:04:25,020 --> 00:04:32,550
so how many of you have been doing

00:04:27,870 --> 00:04:36,930
in the last 20 years okay this is the

00:04:32,550 --> 00:04:39,630
right crowd again I'm guessing but how

00:04:36,930 --> 00:04:42,090
many of you are still doing this since

00:04:39,630 --> 00:04:44,699
you're here yes I'm guessing it it's

00:04:42,090 --> 00:04:50,240
relevant to you at least if not anecdote

00:04:44,699 --> 00:04:54,590
achill so let's dive into it

00:04:50,240 --> 00:04:57,990
another important takeaway I'm trying to

00:04:54,590 --> 00:05:00,150
push with this talk and I want to

00:04:57,990 --> 00:05:04,080
encourage a discussion around this is

00:05:00,150 --> 00:05:06,630
that even if calm is not something of

00:05:04,080 --> 00:05:08,300
interest to you right now or maybe it

00:05:06,630 --> 00:05:10,530
was in the past

00:05:08,300 --> 00:05:14,660
there are important lessons to be

00:05:10,530 --> 00:05:20,880
learned about good API design and

00:05:14,660 --> 00:05:22,560
examining calm as such an impactful

00:05:20,880 --> 00:05:25,500
infrastructure in the operating system

00:05:22,560 --> 00:05:30,150
and as a library that has been around

00:05:25,500 --> 00:05:32,820
for 25 years now it's very telling to

00:05:30,150 --> 00:05:36,500
examine how well some of the design

00:05:32,820 --> 00:05:40,380
choices to the test of time and to

00:05:36,500 --> 00:05:43,710
really see the seams in the in the grand

00:05:40,380 --> 00:05:45,870
design of the framework and see which

00:05:43,710 --> 00:05:49,590
parts have played well and have aged

00:05:45,870 --> 00:05:53,070
well and which parts really gave us so

00:05:49,590 --> 00:05:55,830
much friction along these years and what

00:05:53,070 --> 00:05:57,990
can we learn from it what does the

00:05:55,830 --> 00:06:01,410
modern operating system has to offer in

00:05:57,990 --> 00:06:03,840
this regard have we learned something

00:06:01,410 --> 00:06:05,070
over these years is it easier now to

00:06:03,840 --> 00:06:07,289
interact with the operating system

00:06:05,070 --> 00:06:09,690
through its calm components or not our

00:06:07,289 --> 00:06:14,070
real estate same mess that we've been

00:06:09,690 --> 00:06:16,650
years ago so I will I'm hoping to

00:06:14,070 --> 00:06:19,080
discover this together with you so like

00:06:16,650 --> 00:06:25,860
any good comm programmer we have to

00:06:19,080 --> 00:06:28,979
initialize and if you think about Co

00:06:25,860 --> 00:06:30,949
initialize X it basically initializes

00:06:28,979 --> 00:06:35,070
the comm library on the calling thread

00:06:30,949 --> 00:06:37,380
very important detail nowadays and it

00:06:35,070 --> 00:06:40,280
sets the thread concurrency model to the

00:06:37,380 --> 00:06:41,460
one requested nowadays multi-threaded

00:06:40,280 --> 00:06:43,680
model

00:06:41,460 --> 00:06:47,539
it creates a new apartment for the

00:06:43,680 --> 00:06:51,180
thread if that's what you need and you

00:06:47,539 --> 00:06:53,400
really need to initialize comm on each

00:06:51,180 --> 00:06:55,650
thread that it actually needs to invoke

00:06:53,400 --> 00:06:58,410
comm related function otherwise it won't

00:06:55,650 --> 00:07:02,370
work so this aspect is really important

00:06:58,410 --> 00:07:04,800
so and ideally you would want to

00:07:02,370 --> 00:07:08,759
initialize Chrome only once per thread

00:07:04,800 --> 00:07:10,740
at least one thing I guess so multiple

00:07:08,759 --> 00:07:13,740
calls to Konya isaacs on the same thread

00:07:10,740 --> 00:07:17,759
are allowed but subsequent calls issue

00:07:13,740 --> 00:07:20,849
and as false each result and this is

00:07:17,759 --> 00:07:25,199
relevant because chrome error handling

00:07:20,849 --> 00:07:27,620
is cumbersome to say the least and you

00:07:25,199 --> 00:07:32,970
need to be careful in how you manage

00:07:27,620 --> 00:07:36,210
expectations and check the success of

00:07:32,970 --> 00:07:38,639
the different API calls and in the case

00:07:36,210 --> 00:07:41,849
of Co initialize you want to be a good

00:07:38,639 --> 00:07:43,440
citizen and uninitialized the comb on

00:07:41,849 --> 00:07:45,990
the calling thread when you're done

00:07:43,440 --> 00:07:49,259
using comm functionality and if you're

00:07:45,990 --> 00:07:51,120
not properly matching those up and not

00:07:49,259 --> 00:07:53,190
doing proper error checking to see if

00:07:51,120 --> 00:07:54,240
you're the one that actually initialized

00:07:53,190 --> 00:07:56,430
common that thread

00:07:54,240 --> 00:07:58,590
you might end up uninitialized in common

00:07:56,430 --> 00:08:01,169
thread and somebody else in some other

00:07:58,590 --> 00:08:03,120
part of the functionality really needs

00:08:01,169 --> 00:08:05,490
it so you can really shoot yourself in

00:08:03,120 --> 00:08:10,039
the foot by trying to be a good citizen

00:08:05,490 --> 00:08:12,780
so you need to be graceful in

00:08:10,039 --> 00:08:17,190
uninitialized income and do it exactly

00:08:12,780 --> 00:08:21,030
when it needs to be done so do or not do

00:08:17,190 --> 00:08:26,099
there is no try by the way any track is

00:08:21,030 --> 00:08:32,190
in the room yeah some of this material

00:08:26,099 --> 00:08:33,930
may may be unpleasant to you okay so how

00:08:32,190 --> 00:08:38,659
do we fix community isaacs

00:08:33,930 --> 00:08:42,329
well Rai is something that will

00:08:38,659 --> 00:08:46,980
accustomed to nowadays so we can build a

00:08:42,329 --> 00:08:52,050
simple helper like this one where we can

00:08:46,980 --> 00:08:54,720
make sure that we acquire a competency

00:08:52,050 --> 00:08:55,260
and release the dependencies when we're

00:08:54,720 --> 00:08:57,120
done with it

00:08:55,260 --> 00:09:00,750
and this is where the proper

00:08:57,120 --> 00:09:04,500
error-checking comes into play as I said

00:09:00,750 --> 00:09:06,840
earlier we need to remember if we were

00:09:04,500 --> 00:09:09,180
the ones that actually were the first to

00:09:06,840 --> 00:09:11,190
initialize come on the calling thread so

00:09:09,180 --> 00:09:14,730
that's why we need to save that that

00:09:11,190 --> 00:09:16,860
enclose boolean state to make sure that

00:09:14,730 --> 00:09:20,550
we're the ones that need to go

00:09:16,860 --> 00:09:25,140
uninitialized on this thread so if

00:09:20,550 --> 00:09:28,130
you're doing this you just need you can

00:09:25,140 --> 00:09:30,570
use it locally for example you have a

00:09:28,130 --> 00:09:32,460
function scope you have some function

00:09:30,570 --> 00:09:36,210
requiring comm functionality and use

00:09:32,460 --> 00:09:37,680
some API you can initialize it locally

00:09:36,210 --> 00:09:41,180
and when it's done with it with the

00:09:37,680 --> 00:09:44,550
current function context you're done

00:09:41,180 --> 00:09:47,070
uninitialized it's okay or you can use

00:09:44,550 --> 00:09:49,710
it and get a class scope for example if

00:09:47,070 --> 00:09:51,660
you have more complex objects that have

00:09:49,710 --> 00:09:53,460
has several methods requiring calm

00:09:51,660 --> 00:09:56,100
access you can hold on to that

00:09:53,460 --> 00:09:58,140
dependency as long as you're done and

00:09:56,100 --> 00:10:00,960
your object is basically tied as a

00:09:58,140 --> 00:10:03,630
dependency to the comm itself so that

00:10:00,960 --> 00:10:06,780
pretty straightforward has worked out

00:10:03,630 --> 00:10:09,720
very well for us we actually use it

00:10:06,780 --> 00:10:15,710
heavily I couldn't imagine living with

00:10:09,720 --> 00:10:15,710
without such functionality yeah sure I

00:10:17,360 --> 00:10:35,670
can go back the threaded model yeah you

00:10:32,120 --> 00:10:37,880
with we don't do we don't do it yeah

00:10:35,670 --> 00:10:40,890
generally speaking it's not a good idea

00:10:37,880 --> 00:10:43,290
technically you're you're right you can

00:10:40,890 --> 00:10:45,630
actually initialize Chrome with a

00:10:43,290 --> 00:10:47,430
different threading model for example

00:10:45,630 --> 00:10:49,940
using multi-threaded or switch to

00:10:47,430 --> 00:10:52,410
apartment reddit or something like that

00:10:49,940 --> 00:10:55,350
technically you can do it but it's never

00:10:52,410 --> 00:10:58,110
a good idea to mix those up so we

00:10:55,350 --> 00:11:00,560
generally try to stay away from mixing

00:10:58,110 --> 00:11:03,570
this mode up we've been burned before by

00:11:00,560 --> 00:11:05,640
accidental initialization with different

00:11:03,570 --> 00:11:07,050
threading models and there were

00:11:05,640 --> 00:11:07,980
components that needed to talk with each

00:11:07,050 --> 00:11:10,110
other

00:11:07,980 --> 00:11:13,230
and there's very careful rules of

00:11:10,110 --> 00:11:15,090
isolation about object calm object

00:11:13,230 --> 00:11:18,240
instances in memory with regards to the

00:11:15,090 --> 00:11:21,800
apartment model so we've been burned

00:11:18,240 --> 00:11:32,070
with this before and we try to stay away

00:11:21,800 --> 00:11:34,020
mixing those up maybe we should the the

00:11:32,070 --> 00:11:36,390
at least an assertion would be a good

00:11:34,020 --> 00:11:39,270
idea because we we've been burned right

00:11:36,390 --> 00:11:41,400
by this and by the way this this is

00:11:39,270 --> 00:11:43,620
classes a little simplified is not

00:11:41,400 --> 00:11:45,960
exactly it it has to fit on a slide but

00:11:43,620 --> 00:11:49,080
you're very right this is a concern and

00:11:45,960 --> 00:11:51,420
we've actually encountered I think like

00:11:49,080 --> 00:11:53,970
last year we've had a problem with this

00:11:51,420 --> 00:11:55,920
we had a component that was not under

00:11:53,970 --> 00:11:58,370
our control and we actually did a

00:11:55,920 --> 00:11:58,370
different

00:12:41,820 --> 00:12:49,690
I'll have to look look that up okay I'll

00:12:48,010 --> 00:12:56,290
get back to you on that I have to look

00:12:49,690 --> 00:12:58,899
it up it's telling it's telling this I

00:12:56,290 --> 00:13:00,640
think this is telling but thank you for

00:12:58,899 --> 00:13:04,899
pointing out I should really look into

00:13:00,640 --> 00:13:10,149
that okay okay I have to look it up

00:13:04,899 --> 00:13:13,029
cannot confirm it okay so come

00:13:10,149 --> 00:13:15,459
initializer and REI you don't care about

00:13:13,029 --> 00:13:19,660
the thread you're on it as long as you

00:13:15,459 --> 00:13:21,250
ain't it encapsulate this dependency if

00:13:19,660 --> 00:13:23,080
you don't care if it's already

00:13:21,250 --> 00:13:25,240
initialized or not on this thread and

00:13:23,080 --> 00:13:26,649
the most important thing you can nest

00:13:25,240 --> 00:13:29,380
these objects as needed

00:13:26,649 --> 00:13:33,640
you don't care at which point in the

00:13:29,380 --> 00:13:35,770
call stack you're in and you don't need

00:13:33,640 --> 00:13:39,149
to about closing and alone become when

00:13:35,770 --> 00:13:43,870
you're done that's the whole purpose so

00:13:39,149 --> 00:13:46,570
let's talk about strings now and I had

00:13:43,870 --> 00:13:51,040
to pick come-come is such a large topic

00:13:46,570 --> 00:13:54,490
and I it would be a mess to try to cover

00:13:51,040 --> 00:13:57,520
too many things so one of the earliest

00:13:54,490 --> 00:14:00,760
feedback I got on this talk idea is that

00:13:57,520 --> 00:14:03,070
I need to pick something and focus on

00:14:00,760 --> 00:14:08,890
something come related and try to

00:14:03,070 --> 00:14:12,520
analyze it throughout and no question I

00:14:08,890 --> 00:14:14,410
had to pick strings for us at least this

00:14:12,520 --> 00:14:19,209
has been the most sensitive issue around

00:14:14,410 --> 00:14:21,100
calm and I'm trying at least for this

00:14:19,209 --> 00:14:26,110
part of the talk to focus on calm

00:14:21,100 --> 00:14:32,350
strings a little bit so what's the calm

00:14:26,110 --> 00:14:34,529
string type based ring old friend so for

00:14:32,350 --> 00:14:38,860
those of us who don't remember this

00:14:34,529 --> 00:14:41,699
ingenious piece of design the B string

00:14:38,860 --> 00:14:45,759
is string

00:14:41,699 --> 00:14:52,110
with a buffering memory it has length

00:14:45,759 --> 00:14:54,850
prefix and is null terminated yeah

00:14:52,110 --> 00:14:57,459
that's the way that we have the length

00:14:54,850 --> 00:14:59,709
and the most interesting part is that B

00:14:57,459 --> 00:15:02,319
string of course in the type system is a

00:14:59,709 --> 00:15:04,749
pointer and it actually points to the

00:15:02,319 --> 00:15:08,639
data buffer in memory not a length

00:15:04,749 --> 00:15:08,639
prefix so there's always a trick of

00:15:09,209 --> 00:15:19,540
offsetting this pointer so if you think

00:15:15,220 --> 00:15:23,740
you can do a thing like this which I

00:15:19,540 --> 00:15:26,079
would expect to work you can't these

00:15:23,740 --> 00:15:29,439
compiles and links and it's incorrect

00:15:26,079 --> 00:15:32,439
and you would say that I would never do

00:15:29,439 --> 00:15:36,160
this it's looks stupid

00:15:32,439 --> 00:15:39,040
yeah you can by accident past a string

00:15:36,160 --> 00:15:43,170
literal to a common API function that

00:15:39,040 --> 00:15:46,959
has a piece drink formal parameter so

00:15:43,170 --> 00:15:51,879
I'm always not to admit I've done that

00:15:46,959 --> 00:15:56,499
before so you can be easily burned by

00:15:51,879 --> 00:16:01,300
this so what you have to do is allocate

00:15:56,499 --> 00:16:04,179
a string for this B string and you have

00:16:01,300 --> 00:16:08,339
to check the success State it almost

00:16:04,179 --> 00:16:11,139
never fails right why check records and

00:16:08,339 --> 00:16:13,929
use the string and then free the string

00:16:11,139 --> 00:16:18,579
so a lot of hand waving around just

00:16:13,929 --> 00:16:22,660
initializing your string and somebody

00:16:18,579 --> 00:16:26,410
has to save our skins here are AI for

00:16:22,660 --> 00:16:28,870
the win let's see what the visual c++

00:16:26,410 --> 00:16:32,829
compiler has offered us to mitigate this

00:16:28,870 --> 00:16:37,259
issue we have a few Aria icon support

00:16:32,829 --> 00:16:42,610
classes I know everybody loves this one

00:16:37,259 --> 00:16:46,299
B string T by the way these underscore

00:16:42,610 --> 00:16:49,779
teeth types really really bad in terms

00:16:46,299 --> 00:16:54,009
of standard conformers they should be

00:16:49,779 --> 00:16:55,070
reserved names but we're going to roll

00:16:54,009 --> 00:16:58,610
with it

00:16:55,070 --> 00:17:01,970
so B string T we have similar similar

00:16:58,610 --> 00:17:07,490
helpers for variance and for compound

00:17:01,970 --> 00:17:10,790
pointers and of course for our H result

00:17:07,490 --> 00:17:12,740
error handling friend and because we're

00:17:10,790 --> 00:17:14,959
focusing on string let's see what B

00:17:12,740 --> 00:17:16,610
string T has to offer for us it

00:17:14,959 --> 00:17:19,579
encapsulates nicely the B string

00:17:16,610 --> 00:17:22,790
datatype manages resource allocation

00:17:19,579 --> 00:17:26,900
through cecil ox is free but we would

00:17:22,790 --> 00:17:28,940
expect from an aria wrapper it uses

00:17:26,900 --> 00:17:31,610
reference counting to avoid excessive

00:17:28,940 --> 00:17:33,080
overhead so this is actually clever and

00:17:31,610 --> 00:17:36,440
uses copy-on-write

00:17:33,080 --> 00:17:38,480
underneath so you can freely copy these

00:17:36,440 --> 00:17:43,100
things as as if they're valuable

00:17:38,480 --> 00:17:44,809
value types it provides various

00:17:43,100 --> 00:17:47,900
conversion constructors like you would

00:17:44,809 --> 00:17:50,030
expect to initialize this data type so

00:17:47,900 --> 00:17:54,260
meets the expectation it's intuitive

00:17:50,030 --> 00:17:57,490
handy very handy operators for

00:17:54,260 --> 00:18:00,980
lexicographic comparisons and

00:17:57,490 --> 00:18:04,309
concatenation and you would use it

00:18:00,980 --> 00:18:05,900
probably something like this pass it

00:18:04,309 --> 00:18:08,840
around to some come API that requires

00:18:05,900 --> 00:18:12,610
the B string has an explicit method for

00:18:08,840 --> 00:18:17,419
getting that pointer to the buffer and

00:18:12,610 --> 00:18:20,000
you can convert it to a standard string

00:18:17,419 --> 00:18:23,299
because you do need to interoperate

00:18:20,000 --> 00:18:25,400
between your chrome related classes and

00:18:23,299 --> 00:18:28,909
your platform-independent code at some

00:18:25,400 --> 00:18:31,400
point you need to do a two-way handshake

00:18:28,909 --> 00:18:37,309
in marshaling data between your model

00:18:31,400 --> 00:18:39,080
and your chrome layer and of course you

00:18:37,309 --> 00:18:41,030
can leverage the lexicographic compare

00:18:39,080 --> 00:18:45,100
operator if you need something like this

00:18:41,030 --> 00:18:50,690
you can construct a B string T from a

00:18:45,100 --> 00:18:53,240
standard string by getting its sis to

00:18:50,690 --> 00:18:55,790
string non null terminated array and you

00:18:53,240 --> 00:19:02,299
can compare it very easily so very handy

00:18:55,790 --> 00:19:04,580
nice clean no unexpected results here if

00:19:02,299 --> 00:19:08,570
we examine the other helper we related

00:19:04,580 --> 00:19:08,960
to this a little more convoluted if we

00:19:08,570 --> 00:19:12,820
need to

00:19:08,960 --> 00:19:17,809
with pointers we need to do some magic

00:19:12,820 --> 00:19:20,840
macro wizardry and we can actually tag

00:19:17,809 --> 00:19:25,970
each interface of interest and construct

00:19:20,840 --> 00:19:30,070
on an ad hoc smart point of reference by

00:19:25,970 --> 00:19:33,140
using this fancy macro and we get an

00:19:30,070 --> 00:19:37,039
instant type like for example I I have

00:19:33,140 --> 00:19:39,980
here I taskbar list PTR which is a smart

00:19:37,039 --> 00:19:42,919
pointer and I can use the get an

00:19:39,980 --> 00:19:48,429
instance of it of this class and use it

00:19:42,919 --> 00:19:49,760
as if it's a regular pointer so little

00:19:48,429 --> 00:19:52,539
weird

00:19:49,760 --> 00:19:58,909
using the macros but we're used to that

00:19:52,539 --> 00:20:03,649
so next bit of history who's been using

00:19:58,909 --> 00:20:08,240
a TL for the past years yeah ATL fans in

00:20:03,649 --> 00:20:14,299
the house so just a quick orientation or

00:20:08,240 --> 00:20:19,549
a history lesson this would be a simple

00:20:14,299 --> 00:20:22,070
ideal structure the core object in ATL

00:20:19,549 --> 00:20:26,090
is cecum object which is a template

00:20:22,070 --> 00:20:28,130
class and I'm not gonna cover aggregate

00:20:26,090 --> 00:20:29,990
objects because it's much more

00:20:28,130 --> 00:20:32,840
complicated topic for this discussion

00:20:29,990 --> 00:20:38,630
but if we're talking just about a simple

00:20:32,840 --> 00:20:41,390
chrome object a comm object-- inherits

00:20:38,630 --> 00:20:44,270
its template parameter and this would be

00:20:41,390 --> 00:20:47,860
a very very contrived and simple example

00:20:44,270 --> 00:20:52,190
of actually creating an instance of this

00:20:47,860 --> 00:20:54,590
circle object and invoking just one

00:20:52,190 --> 00:20:59,450
method of interest on the on it set

00:20:54,590 --> 00:21:05,029
radius in this case and this is what we

00:20:59,450 --> 00:21:07,730
would have to do and all of this is just

00:21:05,029 --> 00:21:10,309
boilerplate I don't care about any of

00:21:07,730 --> 00:21:13,340
this code but I kind of have to write it

00:21:10,309 --> 00:21:17,600
and this isn't even the whole class I

00:21:13,340 --> 00:21:20,659
couldn't fit it on the slide this would

00:21:17,600 --> 00:21:22,010
be the actual code I care about in being

00:21:20,659 --> 00:21:23,320
my constructor and my methods of

00:21:22,010 --> 00:21:27,950
interest

00:21:23,320 --> 00:21:30,290
so having to write all this boilerplate

00:21:27,950 --> 00:21:32,860
code really messes your attention and

00:21:30,290 --> 00:21:37,430
it's sometimes they were prone and

00:21:32,860 --> 00:21:41,090
definitely gets in your way by the way

00:21:37,430 --> 00:21:44,020
do you recognize this pattern it has a

00:21:41,090 --> 00:21:46,820
name yeah

00:21:44,020 --> 00:21:50,360
CR TP curiously reoccurring template

00:21:46,820 --> 00:21:52,250
pattern so basically it achieves a

00:21:50,360 --> 00:21:54,380
similar effect to the use of virtual

00:21:52,250 --> 00:21:57,590
functions but without the cost of

00:21:54,380 --> 00:22:02,180
dynamic polymorphism or a V table and it

00:21:57,590 --> 00:22:04,490
has binding at compile time of course we

00:22:02,180 --> 00:22:08,930
want this for our objects we don't want

00:22:04,490 --> 00:22:12,620
vertical for each method and the pattern

00:22:08,930 --> 00:22:15,410
is used extensively in ATL in and wtl

00:22:12,620 --> 00:22:17,960
libraries we actually use a lot of a

00:22:15,410 --> 00:22:22,310
tear in our application and our whole

00:22:17,960 --> 00:22:26,540
GUI is built on top of WTO so I know

00:22:22,310 --> 00:22:29,660
pain when I see it but it's very very

00:22:26,540 --> 00:22:32,540
powerful construct building up objects

00:22:29,660 --> 00:22:34,460
this way is flexible enough very

00:22:32,540 --> 00:22:38,540
powerful not very friendly for the

00:22:34,460 --> 00:22:41,810
beginner so we do have parallels and

00:22:38,540 --> 00:22:45,350
helpers in atl for the same we construct

00:22:41,810 --> 00:22:47,780
and we have secon pattern and seek on B

00:22:45,350 --> 00:22:50,330
string and of course I'm gonna pick on

00:22:47,780 --> 00:22:52,610
SiC on B string because we're talking

00:22:50,330 --> 00:22:55,070
about strings so this is the IDL wrapper

00:22:52,610 --> 00:22:57,710
for B string type it manages a location

00:22:55,070 --> 00:23:00,590
again the same way because it's the same

00:22:57,710 --> 00:23:02,270
type underneath but this one does not

00:23:00,590 --> 00:23:05,990
implement copy-on-write

00:23:02,270 --> 00:23:08,720
so this this object is different and in

00:23:05,990 --> 00:23:11,270
the latest versions of atl so it

00:23:08,720 --> 00:23:15,680
actually has move semantics just in case

00:23:11,270 --> 00:23:17,690
you didn't know so it provided provides

00:23:15,680 --> 00:23:20,150
again various conversion constructors

00:23:17,690 --> 00:23:24,200
that you would expect to initialize it

00:23:20,150 --> 00:23:28,250
same convenience operators

00:23:24,200 --> 00:23:30,290
usage looks similar with beasts 20 the

00:23:28,250 --> 00:23:32,990
difference being that seek on B string

00:23:30,290 --> 00:23:35,750
actually has an operator to convert it

00:23:32,990 --> 00:23:36,530
to a B string automatically this might

00:23:35,750 --> 00:23:38,260
be a

00:23:36,530 --> 00:23:42,470
fool or might be surprising to you

00:23:38,260 --> 00:23:46,850
depending on if you wrote the code or

00:23:42,470 --> 00:23:50,660
not you can initialize a standard string

00:23:46,850 --> 00:23:51,440
from C convey string of course if we're

00:23:50,660 --> 00:23:53,390
talking about

00:23:51,440 --> 00:23:55,790
I didn't mentioned this earlier if we're

00:23:53,390 --> 00:23:59,510
talking about comm strings we're always

00:23:55,790 --> 00:24:02,210
talking about utf-16 so this is the

00:23:59,510 --> 00:24:05,600
underlying assumption and how the

00:24:02,210 --> 00:24:10,040
operating system is built so I you're

00:24:05,600 --> 00:24:11,930
gonna see only STD W string in the

00:24:10,040 --> 00:24:14,450
slides so you can marshal data between

00:24:11,930 --> 00:24:16,840
back and forth between your model or

00:24:14,450 --> 00:24:20,990
your application logic and comb

00:24:16,840 --> 00:24:23,930
components you can construct the other

00:24:20,990 --> 00:24:26,060
way around you can construct C convey

00:24:23,930 --> 00:24:28,130
string from a standard string you can

00:24:26,060 --> 00:24:31,670
compare them similar functionality with

00:24:28,130 --> 00:25:38,870
B string T so at this point I would like

00:24:31,670 --> 00:25:41,180
to run ad hoc how many so okay I'm just

00:25:38,870 --> 00:25:43,490
gonna summarize but you just said to be

00:25:41,180 --> 00:25:46,220
on the recording and other people to

00:25:43,490 --> 00:25:48,230
follow so a very good observation if

00:25:46,220 --> 00:25:49,799
you're dealing with any cross-platform

00:25:48,230 --> 00:25:51,840
development and you

00:25:49,799 --> 00:25:54,480
to isolate some platform abstraction

00:25:51,840 --> 00:25:55,950
layer that's come dependent and you do

00:25:54,480 --> 00:25:59,850
need to do this marshalling between

00:25:55,950 --> 00:26:02,220
standard string and comb string you need

00:25:59,850 --> 00:26:04,230
to be careful about the string

00:26:02,220 --> 00:26:06,720
representations on other platforms and

00:26:04,230 --> 00:26:11,700
it's indeed a very good observation and

00:26:06,720 --> 00:26:14,279
I remember a talk a few years back some

00:26:11,700 --> 00:26:16,619
people on the only office team did a

00:26:14,279 --> 00:26:19,139
presentation that III thought it was

00:26:16,619 --> 00:26:20,369
fantastic you should look it up on our

00:26:19,139 --> 00:26:23,220
new two board channel line or something

00:26:20,369 --> 00:26:25,950
I don't remember the title but the whole

00:26:23,220 --> 00:26:32,580
talk was around their experience in

00:26:25,950 --> 00:26:37,489
actually porting the the office to iOS

00:26:32,580 --> 00:26:42,139
and the challenges they faced around

00:26:37,489 --> 00:26:45,539
data type lengths and endian s and

00:26:42,139 --> 00:26:50,340
character lengths on different platforms

00:26:45,539 --> 00:26:53,279
so that talk goes into many details

00:26:50,340 --> 00:26:56,220
around data representation in memory and

00:26:53,279 --> 00:26:58,409
adapting and this constructing the

00:26:56,220 --> 00:27:01,859
proper platform abstraction layer and

00:26:58,409 --> 00:27:04,590
it's actually an actual real case study

00:27:01,859 --> 00:27:07,580
on from the office team that did all

00:27:04,590 --> 00:27:09,600
this work and it wasn't easy

00:27:07,580 --> 00:27:11,159
you should definitely if you're

00:27:09,600 --> 00:27:12,929
interested in stuff like that you should

00:27:11,159 --> 00:27:15,779
definitely look it up I'm sorry I don't

00:27:12,929 --> 00:27:29,929
remember the title but it was an

00:27:15,779 --> 00:27:29,929
excellent talk myself included

00:27:53,770 --> 00:27:57,520
I would be very careful about doing that

00:27:55,899 --> 00:28:00,370
in production code

00:27:57,520 --> 00:28:02,950
the reason being some languages return

00:28:00,370 --> 00:28:05,830
dog null-terminated be stirs through

00:28:02,950 --> 00:28:08,140
interfaces which is allowed and the

00:28:05,830 --> 00:28:10,750
wrapper classes while providing

00:28:08,140 --> 00:28:13,299
convenient overloads for the effective

00:28:10,750 --> 00:28:22,919
mill terminated strings and C++ don't

00:28:13,299 --> 00:28:25,510
check that necessarily and yeah very

00:28:22,919 --> 00:28:29,980
good two observations and I'm gonna

00:28:25,510 --> 00:28:33,010
repeat them to be on record the first

00:28:29,980 --> 00:28:34,029
one is that with regards to the pole and

00:28:33,010 --> 00:28:38,760
add earlier

00:28:34,029 --> 00:28:41,850
B string T versus the IDL a secon bestir

00:28:38,760 --> 00:28:44,169
we actually use both like you said

00:28:41,850 --> 00:28:47,440
different components different authors

00:28:44,169 --> 00:28:49,809
what are you gonna do that's life and

00:28:47,440 --> 00:28:51,880
the preference here and the observation

00:28:49,809 --> 00:28:53,980
was made that if you have an API that

00:28:51,880 --> 00:28:58,090
actually returns the string as an output

00:28:53,980 --> 00:29:01,419
parameter the C combustor having and get

00:28:58,090 --> 00:29:04,840
a dress off function can actually be

00:29:01,419 --> 00:29:08,020
used to capture an output parameter did

00:29:04,840 --> 00:29:10,750
I convey that correctly okay

00:29:08,020 --> 00:29:14,169
and it has an clear advantage here over

00:29:10,750 --> 00:29:16,870
B string T the other observation which

00:29:14,169 --> 00:29:22,330
is more subtle is regarding embedded

00:29:16,870 --> 00:29:25,630
nulls or if the if the string isn't null

00:29:22,330 --> 00:29:27,640
terminated you come of course has

00:29:25,630 --> 00:29:29,890
projections in different languages and

00:29:27,640 --> 00:29:32,590
if you're talking about comm the whole

00:29:29,890 --> 00:29:35,710
idea is about Interop and being language

00:29:32,590 --> 00:29:39,850
agnostic around a common API and if

00:29:35,710 --> 00:29:42,460
you're if you're you happen to get a

00:29:39,850 --> 00:29:44,590
hold of a string reference that is not

00:29:42,460 --> 00:29:47,020
null terminated actually constructing a

00:29:44,590 --> 00:29:49,240
standard string this way like line three

00:29:47,020 --> 00:29:52,149
here is potentially dangerous so you

00:29:49,240 --> 00:29:54,039
better watch out for the string length

00:29:52,149 --> 00:30:00,940
because it's not not to mention did I

00:29:54,039 --> 00:30:01,760
convey this correctly and the length

00:30:00,940 --> 00:30:07,820
exactly

00:30:01,760 --> 00:30:11,000
ah I would rather be explicit and put a

00:30:07,820 --> 00:30:22,400
macro there but get the observations

00:30:11,000 --> 00:30:26,080
valid yeah yeah I'm not a fan of those

00:30:22,400 --> 00:30:39,950
but but we do have them in the codebase

00:30:26,080 --> 00:30:43,910
question here yeah yeah yeah and the

00:30:39,950 --> 00:30:46,400
basic string class is templatized so the

00:30:43,910 --> 00:30:49,250
W string is just an template instance

00:30:46,400 --> 00:30:51,080
for W Carty so you can actually use the

00:30:49,250 --> 00:30:53,480
other chart chart types in in the

00:30:51,080 --> 00:30:55,910
standard good observation they're good

00:30:53,480 --> 00:30:58,700
at search so again this is a contrived

00:30:55,910 --> 00:31:01,910
example and it actually assumes a null

00:30:58,700 --> 00:31:05,780
terminated string so yeah very good

00:31:01,910 --> 00:31:08,420
observations and definite in the right

00:31:05,780 --> 00:31:10,670
room no seriously

00:31:08,420 --> 00:31:14,410
actually audience participation regard

00:31:10,670 --> 00:31:18,770
in this talk highly improves the content

00:31:14,410 --> 00:31:20,390
so there's a bigger fish here there it's

00:31:18,770 --> 00:31:25,340
all there there's always a bigger fish

00:31:20,390 --> 00:31:29,390
here and this would be a TLC string one

00:31:25,340 --> 00:31:33,860
of my favorites so again this is a

00:31:29,390 --> 00:31:38,360
templatized class has support for Karen

00:31:33,860 --> 00:31:41,900
W care T and string trades it manages

00:31:38,360 --> 00:31:43,550
allocation the allocation of course uses

00:31:41,900 --> 00:31:45,710
reference counting to avoid excessive

00:31:43,550 --> 00:31:48,770
copy or overhead again this is a

00:31:45,710 --> 00:31:53,180
copy-on-write implementation very handy

00:31:48,770 --> 00:31:54,740
I see so many people trying to avoid g

00:31:53,180 --> 00:31:57,350
string copies and passing references

00:31:54,740 --> 00:32:02,090
around and I always find that a futile

00:31:57,350 --> 00:32:03,680
effort and it actually has a string ref

00:32:02,090 --> 00:32:07,250
internal representation in that

00:32:03,680 --> 00:32:10,220
correctly checks that it actually needs

00:32:07,250 --> 00:32:15,260
to duplicate that string when modified

00:32:10,220 --> 00:32:21,230
has lot more methods and operations then

00:32:15,260 --> 00:32:23,179
B string T or C combi string has all the

00:32:21,230 --> 00:32:27,650
conversion constructors you would expect

00:32:23,179 --> 00:32:29,299
including variant which is nice all the

00:32:27,650 --> 00:32:32,000
operators you would expect for

00:32:29,299 --> 00:32:33,890
convenience lots of algorithms and

00:32:32,000 --> 00:32:36,380
utilities as opposed to the other ones

00:32:33,890 --> 00:32:38,750
that are bare wrappers around the data

00:32:36,380 --> 00:32:42,470
type this one actually has string

00:32:38,750 --> 00:32:46,870
algorithms like fine find off formatting

00:32:42,470 --> 00:32:50,720
strings changing the case the uppercase

00:32:46,870 --> 00:32:52,280
prefix suffix sub strings find reverse

00:32:50,720 --> 00:32:54,559
find tokenized what-have-you

00:32:52,280 --> 00:32:59,290
all the goodies you would expect from a

00:32:54,559 --> 00:33:03,950
string class so definitely my favorite

00:32:59,290 --> 00:33:06,650
in terms of simple usage again you can

00:33:03,950 --> 00:33:10,120
imagine calling some API that requires a

00:33:06,650 --> 00:33:15,350
B string and you can you have to be

00:33:10,120 --> 00:33:19,700
explicit about requesting all a B string

00:33:15,350 --> 00:33:21,770
from the C string and the other way

00:33:19,700 --> 00:33:24,980
around if you're trying to construct

00:33:21,770 --> 00:33:28,900
this is the most frequent offender in

00:33:24,980 --> 00:33:31,940
out code base actually data marshalling

00:33:28,900 --> 00:33:35,120
buffers between standard string and C

00:33:31,940 --> 00:33:37,330
string I think is the most frequent

00:33:35,120 --> 00:33:43,160
operation we do in our application

00:33:37,330 --> 00:33:48,620
because with we have all the application

00:33:43,160 --> 00:33:51,230
logic and the model of the application

00:33:48,620 --> 00:33:53,179
built on top of standard string and each

00:33:51,230 --> 00:33:56,000
time we need to interact with the GUI

00:33:53,179 --> 00:33:59,710
the GUI again is built on top of a TL

00:33:56,000 --> 00:34:02,450
and wtl so everywhere is C string and

00:33:59,710 --> 00:34:09,440
interacting will come and we copy things

00:34:02,450 --> 00:34:12,200
around yeah sorry the line to line 2

00:34:09,440 --> 00:34:14,330
yeah yeah now it's just I'm just trying

00:34:12,200 --> 00:34:19,159
to show the conversion the conversion

00:34:14,330 --> 00:34:21,169
function actually I've never used the Al

00:34:19,159 --> 00:34:26,090
Aqsa string function from C string I

00:34:21,169 --> 00:34:27,909
never need it so but the the third line

00:34:26,090 --> 00:34:31,270
is the thing that

00:34:27,909 --> 00:34:35,020
we have I think that's the most if I do

00:34:31,270 --> 00:34:37,270
a search maybe see string get string is

00:34:35,020 --> 00:34:41,849
the most frequently used function in our

00:34:37,270 --> 00:34:41,849
goddess so that's unfortunate

00:34:42,000 --> 00:34:47,950
yeah the the dialogue see string method

00:34:45,669 --> 00:34:52,379
action allocates a copy the d string

00:34:47,950 --> 00:34:52,379
copy of the underlying c string buffer

00:35:16,079 --> 00:35:20,380
is the same problem you have you with

00:35:18,400 --> 00:35:22,950
cecil lock string insists free string

00:35:20,380 --> 00:35:27,339
you have to manage those memory so I

00:35:22,950 --> 00:35:30,280
would never advise using alex string

00:35:27,339 --> 00:35:35,079
there are some computers macros like he

00:35:30,280 --> 00:35:38,260
mentioned and there it's rare that you

00:35:35,079 --> 00:35:40,569
actually need to do this back and forth

00:35:38,260 --> 00:35:43,390
but in case you do you need to be aware

00:35:40,569 --> 00:35:45,880
that you get new mystery instances

00:35:43,390 --> 00:35:48,910
that's why I put the allocates comment

00:35:45,880 --> 00:35:50,890
there and what I'm trying to do in this

00:35:48,910 --> 00:35:53,079
slide is with the type system itself not

00:35:50,890 --> 00:35:57,730
the memory management so the convergence

00:35:53,079 --> 00:36:00,309
that happened so again and the other way

00:35:57,730 --> 00:36:03,069
around again this is a very frequent

00:36:00,309 --> 00:36:05,559
operation in our code base converting

00:36:03,069 --> 00:36:09,579
from a standard string to a syst ring to

00:36:05,559 --> 00:36:13,390
give it to some GUI function or working

00:36:09,579 --> 00:36:16,660
with some calm component there so these

00:36:13,390 --> 00:36:18,730
are a test for us and they always give

00:36:16,660 --> 00:36:22,720
me headaches and I'm trying to get rid

00:36:18,730 --> 00:36:25,510
of those so but what about this modern

00:36:22,720 --> 00:36:28,109
comma I keep hearing about surely things

00:36:25,510 --> 00:36:30,789
have improved in the last 25 years

00:36:28,109 --> 00:36:33,329
enter Windows runtime

00:36:30,789 --> 00:36:37,359
starting with Windows 8 and Windows 10

00:36:33,329 --> 00:36:39,100
we have a new kid on the block this is a

00:36:37,359 --> 00:36:42,160
new day a new beginning

00:36:39,100 --> 00:36:47,020
so the windows runtimes for the ones

00:36:42,160 --> 00:36:48,520
that are still stuck on windows 7 yeah

00:36:47,020 --> 00:36:52,570
we still need to deploy applications

00:36:48,520 --> 00:36:55,810
there right is a modern class-based

00:36:52,570 --> 00:36:58,210
object-oriented windows api it has rich

00:36:55,810 --> 00:37:01,570
metadata about classes and members

00:36:58,210 --> 00:37:03,040
properties has language projections for

00:37:01,570 --> 00:37:06,880
natural and familiar use in your

00:37:03,040 --> 00:37:12,130
preferred language okay not Ruby but it

00:37:06,880 --> 00:37:15,670
could be null and how do I get access to

00:37:12,130 --> 00:37:17,650
the Windows runtime from C++ well let's

00:37:15,670 --> 00:37:21,310
start with at the beginning

00:37:17,650 --> 00:37:25,150
we have world that's how we started

00:37:21,310 --> 00:37:27,700
right before there were any real

00:37:25,150 --> 00:37:31,170
projections we have the windows runtime

00:37:27,700 --> 00:37:33,160
c++ template library that's a mouthful

00:37:31,170 --> 00:37:35,760
it enables you to more easily

00:37:33,160 --> 00:37:38,710
implementing consume come components

00:37:35,760 --> 00:37:43,570
it's a very thin abstraction of the

00:37:38,710 --> 00:37:46,360
wound over the API it's template based

00:37:43,570 --> 00:37:48,190
of course it gives the ability to

00:37:46,360 --> 00:37:52,500
control the underlying code it's very

00:37:48,190 --> 00:37:55,210
low level so it's not always pretty

00:37:52,500 --> 00:37:58,090
error handling it's still each result

00:37:55,210 --> 00:38:02,350
based because the doesn't have abstract

00:37:58,090 --> 00:38:05,290
way anything on this front its design is

00:38:02,350 --> 00:38:07,210
heaven inspired by a TL so one huge

00:38:05,290 --> 00:38:10,690
benefit of this approach is you can

00:38:07,210 --> 00:38:13,930
actually mix the old com code with

00:38:10,690 --> 00:38:16,390
Newcomb code and this is the main reason

00:38:13,930 --> 00:38:18,460
that the windows runtime effort was

00:38:16,390 --> 00:38:21,210
bootstrap to this way I always consider

00:38:18,460 --> 00:38:24,010
this the world implementation as a

00:38:21,210 --> 00:38:26,980
transitional period so that you can

00:38:24,010 --> 00:38:29,380
bootstrap and start adopting newer API

00:38:26,980 --> 00:38:31,900
is in your existing old application and

00:38:29,380 --> 00:38:34,060
to have a seamless interaction there and

00:38:31,900 --> 00:38:37,540
of course it was easier for them to

00:38:34,060 --> 00:38:39,820
implement this until we got an actual

00:38:37,540 --> 00:38:46,270
language projection in the form of C++ C

00:38:39,820 --> 00:38:48,760
X later so it actually uses standard C++

00:38:46,270 --> 00:38:50,650
and its template based like I said use

00:38:48,760 --> 00:38:52,570
these smart pointers or AII over the

00:38:50,650 --> 00:38:58,060
place it actually

00:38:52,570 --> 00:39:00,730
helps with activation so it was a clear

00:38:58,060 --> 00:39:06,010
improvement over the pure ATL based

00:39:00,730 --> 00:39:09,490
approach rather verbose no and of course

00:39:06,010 --> 00:39:12,190
it allowed us to add support for uwp

00:39:09,490 --> 00:39:16,390
applications and leverage a new API is

00:39:12,190 --> 00:39:19,660
there immediately after that I'm doing I

00:39:16,390 --> 00:39:25,540
thought I think you got the gist of it

00:39:19,660 --> 00:39:28,210
I'm doing a history pass here so quickly

00:39:25,540 --> 00:39:31,800
we got a language projection that it was

00:39:28,210 --> 00:39:37,540
C++ C X if anybody remembers that thing

00:39:31,800 --> 00:39:40,420
with the Hat it uses a non-standard C++

00:39:37,540 --> 00:39:42,190
language extension that the visual C++

00:39:40,420 --> 00:39:45,420
compiler was enhanced to support these

00:39:42,190 --> 00:39:50,500
language extensions the syntax is terse

00:39:45,420 --> 00:39:52,810
clean much less boilerplate all the

00:39:50,500 --> 00:39:54,880
things the compiler does all the messy

00:39:52,810 --> 00:39:56,950
work behind the scenes we just write

00:39:54,880 --> 00:39:59,290
simple code but there's a learning curve

00:39:56,950 --> 00:40:01,360
this being a non-standard language

00:39:59,290 --> 00:40:04,210
extension you need to get accustomed to

00:40:01,360 --> 00:40:05,890
the hats and how it works and know the

00:40:04,210 --> 00:40:08,500
reference counting the helpers behind it

00:40:05,890 --> 00:40:10,840
and understand it a little bit so

00:40:08,500 --> 00:40:14,680
there's a learning curve definitely high

00:40:10,840 --> 00:40:16,390
level abstraction here something nice

00:40:14,680 --> 00:40:18,910
about it I'm a big fan of exceptions

00:40:16,390 --> 00:40:22,840
I'll admit it not right conference to do

00:40:18,910 --> 00:40:25,330
it but I'll admit it so it actually

00:40:22,840 --> 00:40:28,390
encapsulate s-- H results in as

00:40:25,330 --> 00:40:31,470
exceptions automates various

00:40:28,390 --> 00:40:37,270
housekeeping tasks of initialization but

00:40:31,470 --> 00:40:40,180
it's discontinued so let's start hard to

00:40:37,270 --> 00:40:45,190
see how it would look like in it would

00:40:40,180 --> 00:40:48,520
be some includes and namespaces nothing

00:40:45,190 --> 00:40:51,550
special there are AI for the win again

00:40:48,520 --> 00:40:54,460
this time this helper is actually

00:40:51,550 --> 00:40:57,250
provided for us it's not I'm something I

00:40:54,460 --> 00:41:03,190
implemented so very similar to what we

00:40:57,250 --> 00:41:05,890
had earlier row initialize helper simple

00:41:03,190 --> 00:41:06,280
usage would be what required to get an

00:41:05,890 --> 00:41:08,350
activity

00:41:06,280 --> 00:41:11,140
your factory to get an instance of who

00:41:08,350 --> 00:41:17,710
for example I you are a runtime class

00:41:11,140 --> 00:41:21,190
interface so looks like ATL no little

00:41:17,710 --> 00:41:25,330
bit different still very verbose night

00:41:21,190 --> 00:41:27,400
not my cup of tea but what's the windows

00:41:25,330 --> 00:41:30,340
runtime string type again I'm going back

00:41:27,400 --> 00:41:34,620
to this theme of strings so Windows

00:41:30,340 --> 00:41:39,940
runtime string type hint it's not bestir

00:41:34,620 --> 00:41:43,870
sorry H string yeah that's always a new

00:41:39,940 --> 00:41:46,510
and improved model it represents an

00:41:43,870 --> 00:41:48,040
immutable string careful here an

00:41:46,510 --> 00:41:53,230
immutable string in the windows runtime

00:41:48,040 --> 00:41:55,420
it's basically a handle and in order to

00:41:53,230 --> 00:41:59,710
get a hold of these H strings you have

00:41:55,420 --> 00:42:04,300
to use functions like this and man

00:41:59,710 --> 00:42:09,100
they're ugly that's a very sad API

00:42:04,300 --> 00:42:16,410
surface but that's what we have to deal

00:42:09,100 --> 00:42:22,300
with and we have class representation

00:42:16,410 --> 00:42:25,120
for example very simple thing you cannot

00:42:22,300 --> 00:42:27,070
initialize it by construction with a

00:42:25,120 --> 00:42:29,070
string literal you have to actually call

00:42:27,070 --> 00:42:31,360
the set method I thought that was said

00:42:29,070 --> 00:42:35,980
so a very simple example of

00:42:31,360 --> 00:42:37,450
initialization there yeah

00:42:35,980 --> 00:42:40,660
platform string is the language

00:42:37,450 --> 00:42:45,220
projection for C++ C X so if you're

00:42:40,660 --> 00:42:47,830
using if you were using C++ 6 that would

00:42:45,220 --> 00:42:50,470
be the language projection for it this

00:42:47,830 --> 00:42:53,560
time around with the C++ 6 projection it

00:42:50,470 --> 00:42:55,870
looks nice I can see a clean

00:42:53,560 --> 00:43:02,850
initialization as opposed to this

00:42:55,870 --> 00:43:05,050
garbage as they expected operators

00:43:02,850 --> 00:43:10,690
checking for equality concatenating

00:43:05,050 --> 00:43:12,880
stuff it's good but you cannot stop

00:43:10,690 --> 00:43:16,770
change and people don't like

00:43:12,880 --> 00:43:19,759
non-standard language extensions and I

00:43:16,770 --> 00:43:22,719
consider the the evolution

00:43:19,759 --> 00:43:26,269
steppin in the right direction here and

00:43:22,719 --> 00:43:30,649
going back to standard C++ is what you

00:43:26,269 --> 00:43:34,159
want to strive for and you don't have to

00:43:30,649 --> 00:43:38,209
rely on a specific compiler for some

00:43:34,159 --> 00:43:39,889
language extension so C++ WinRT comes

00:43:38,209 --> 00:43:42,679
into play

00:43:39,889 --> 00:43:44,059
it's an ISO standard C++ 17 language

00:43:42,679 --> 00:43:48,019
projection for the Windows runtime

00:43:44,059 --> 00:43:50,259
it's a header only library it has C++

00:43:48,019 --> 00:43:52,909
class wrappers for the winner T api's

00:43:50,259 --> 00:43:55,759
you can author and consume windows

00:43:52,909 --> 00:43:59,499
runtime api with it and officially

00:43:55,759 --> 00:44:04,939
supersedes the world and c++ DX so

00:43:59,499 --> 00:44:10,309
definitely this is the present how many

00:44:04,939 --> 00:44:14,779
of you are using C++ Minardi well that

00:44:10,309 --> 00:44:21,829
said I guess we haven't got written to

00:44:14,779 --> 00:44:26,179
of Windows 7 yet that's clear so this is

00:44:21,829 --> 00:44:28,939
an opera sect it was a long time on on

00:44:26,179 --> 00:44:33,799
github it actually moved to the Windows

00:44:28,939 --> 00:44:36,609
SDK a few months back and I think this

00:44:33,799 --> 00:44:39,699
is the best documentation to start with

00:44:36,609 --> 00:44:43,479
if you're trying to learn about it and

00:44:39,699 --> 00:44:45,529
we have to thank that man for this and

00:44:43,479 --> 00:44:46,860
let's give him a round of applause

00:44:45,529 --> 00:44:51,109
please

00:44:46,860 --> 00:44:56,079
[Applause]

00:44:51,109 --> 00:45:00,049
Kenny did a very big effort in actually

00:44:56,079 --> 00:45:03,109
striving for bringing uniformity and

00:45:00,049 --> 00:45:07,160
using a standard C++ and surfacing all

00:45:03,109 --> 00:45:10,460
the richness of the API is in C++ WinRT

00:45:07,160 --> 00:45:12,230
and I'm so happy that it's finally part

00:45:10,460 --> 00:45:14,450
of the Windows SDK it actually feels

00:45:12,230 --> 00:45:16,880
like it's a first-class citizen and

00:45:14,450 --> 00:45:19,940
using C++ to program when Windows

00:45:16,880 --> 00:45:23,989
runtime is actually legit now I feel I

00:45:19,940 --> 00:45:27,410
feel welcomed in the platform finally so

00:45:23,989 --> 00:45:29,359
I highly recommend that you see this

00:45:27,410 --> 00:45:33,380
talk if you haven't seen it already from

00:45:29,359 --> 00:45:39,289
last year cpp con it's a talk about all

00:45:33,380 --> 00:45:42,650
about inertly and from this year more

00:45:39,289 --> 00:45:47,480
recent version of using c++ WinRT it

00:45:42,650 --> 00:45:51,980
water UWP applications from the build

00:45:47,480 --> 00:45:54,739
conference in spring so how do i get it

00:45:51,980 --> 00:45:58,220
well fortunately it does come with

00:45:54,739 --> 00:46:00,319
Visual Studio 2017 it's you just have to

00:45:58,220 --> 00:46:02,779
select the C++ workload and you're up

00:46:00,319 --> 00:46:06,589
and running it's as simple as that I

00:46:02,779 --> 00:46:09,400
would also add I would like to see I

00:46:06,589 --> 00:46:12,619
understand the reason of rolling out

00:46:09,400 --> 00:46:15,920
extensions in Visual Studio it actually

00:46:12,619 --> 00:46:19,069
gives you the flexibility of updating on

00:46:15,920 --> 00:46:22,309
a different cycle and pushing things a

00:46:19,069 --> 00:46:24,739
little off base or off band than the

00:46:22,309 --> 00:46:27,769
regular product updates but I would like

00:46:24,739 --> 00:46:30,859
to see more support right in the box

00:46:27,769 --> 00:46:33,499
and this extension helps you I highly

00:46:30,859 --> 00:46:34,489
recommend that you check it out it

00:46:33,499 --> 00:46:38,619
actually helps with the bug

00:46:34,489 --> 00:46:40,759
visualization for C++ WinRT projects and

00:46:38,619 --> 00:46:43,160
provides you with project templates to

00:46:40,759 --> 00:46:46,849
get started with building C++ molarity

00:46:43,160 --> 00:46:48,619
applications and has support for msbuild

00:46:46,849 --> 00:46:51,349
and generating projection headers and

00:46:48,619 --> 00:46:55,069
components so this is a separate

00:46:51,349 --> 00:46:58,970
extension you can install so let's start

00:46:55,069 --> 00:47:01,819
with the windows runtime again much more

00:46:58,970 --> 00:47:03,450
simple this time around we have to

00:47:01,819 --> 00:47:07,170
actually give the the

00:47:03,450 --> 00:47:10,050
some instructions there include either

00:47:07,170 --> 00:47:12,960
WinRT base or foundation which

00:47:10,050 --> 00:47:16,080
automatically includes base depending on

00:47:12,960 --> 00:47:18,900
your need and you can just basically

00:47:16,080 --> 00:47:25,290
start going notice there

00:47:18,900 --> 00:47:27,870
it does require c++ 17 so I'm there how

00:47:25,290 --> 00:47:36,180
many of you are able to leverage C++ 17

00:47:27,870 --> 00:47:37,740
in your work I say a fifth of you so it

00:47:36,180 --> 00:47:39,300
actually performs better and produces

00:47:37,740 --> 00:47:41,820
smaller binaries than any other language

00:47:39,300 --> 00:47:44,370
projection it perf it outperforms

00:47:41,820 --> 00:47:47,820
handwritten code using the API

00:47:44,370 --> 00:47:49,860
interfaces directly like world it the

00:47:47,820 --> 00:47:52,200
underlying abstraction uses modern C++

00:47:49,860 --> 00:47:54,540
idioms that the visual C++ compiler is

00:47:52,200 --> 00:47:57,000
designed to optimize for like magic

00:47:54,540 --> 00:48:01,260
statics empty base classes string length

00:47:57,000 --> 00:48:03,000
solutions and so forth so leveraging

00:48:01,260 --> 00:48:05,750
non-standard stuff actually helps

00:48:03,000 --> 00:48:09,840
because the optimizer doesn't look for

00:48:05,750 --> 00:48:15,090
improving non-standard extensions

00:48:09,840 --> 00:48:17,900
what's the CPP WinRT string type and I'm

00:48:15,090 --> 00:48:21,930
getting to my theme of strings again so

00:48:17,900 --> 00:48:27,510
what's the string type anyone and now

00:48:21,930 --> 00:48:36,770
but very close its winner th string yes

00:48:27,510 --> 00:48:36,770
you guessed it so yeah question yeah

00:48:39,800 --> 00:48:43,340
maybe

00:48:40,980 --> 00:48:45,570
Kenny can help there I don't know

00:48:43,340 --> 00:48:49,920
regarding idea the question was if he

00:48:45,570 --> 00:48:52,760
uses a TL to define its interface a I

00:48:49,920 --> 00:48:52,760
deal I guess right

00:49:50,509 --> 00:49:57,180
if I can summarize that for the camera

00:49:53,099 --> 00:50:00,839
so the maybe I wasn't very clear but

00:49:57,180 --> 00:50:02,640
Windows runtime is not built on top of B

00:50:00,839 --> 00:50:04,289
string like any said it's built on top

00:50:02,640 --> 00:50:07,319
of H string which is a different

00:50:04,289 --> 00:50:09,329
representation so if you're defining a

00:50:07,319 --> 00:50:13,739
component has to be defined in terms of

00:50:09,329 --> 00:50:16,440
H string type not B string and I would

00:50:13,739 --> 00:50:19,890
also add that if we're talking about

00:50:16,440 --> 00:50:22,049
middle yeah it is a different middle

00:50:19,890 --> 00:50:25,259
version for authoring Windows runtime

00:50:22,049 --> 00:50:28,499
that was middle to and that was a very

00:50:25,259 --> 00:50:32,190
baroque and the very verbose language of

00:50:28,499 --> 00:50:35,249
describing interfaces and it was

00:50:32,190 --> 00:50:37,769
improved in mid middle three is a much

00:50:35,249 --> 00:50:41,880
more lightweight and airy mode of

00:50:37,769 --> 00:50:43,829
describing type libraries so I have

00:50:41,880 --> 00:50:47,220
actually seen a very nice interview with

00:50:43,829 --> 00:50:50,430
Larry Osterman on on channel 9 around

00:50:47,220 --> 00:50:52,769
this and the changes that he needed to

00:50:50,430 --> 00:50:57,630
operate on actually describing the

00:50:52,769 --> 00:50:59,099
Windows runtime so definitely the

00:50:57,630 --> 00:51:02,420
windows runtime is focused around each

00:50:59,099 --> 00:51:02,420
string not B string

00:51:13,440 --> 00:51:19,090
yeah I think it's best because we're

00:51:16,930 --> 00:51:25,240
almost out of time and I still have a

00:51:19,090 --> 00:51:26,850
few slides yeah okay so when are th

00:51:25,240 --> 00:51:29,130
string represents an immutable string

00:51:26,850 --> 00:51:31,420
consistent with the underlying H string

00:51:29,130 --> 00:51:34,840
you can construct it like you would

00:51:31,420 --> 00:51:37,810
expect has various constructors for your

00:51:34,840 --> 00:51:40,750
convenience there again also the version

00:51:37,810 --> 00:51:44,440
with the length and the pointer has an

00:51:40,750 --> 00:51:46,870
explicit constructor with string views a

00:51:44,440 --> 00:51:49,240
few examples you can construct it in

00:51:46,870 --> 00:51:51,190
various ways from a string view from a

00:51:49,240 --> 00:51:53,290
pointer from a pointer and length all

00:51:51,190 --> 00:51:58,720
the usual suspects they're nothing

00:51:53,290 --> 00:52:00,280
unexpected the operator that converts it

00:51:58,720 --> 00:52:03,880
to a string view is interesting in my

00:52:00,280 --> 00:52:07,540
opinion and I have a whole talk on

00:52:03,880 --> 00:52:11,440
string views that happened on Monday but

00:52:07,540 --> 00:52:14,650
you can catch it on recording the string

00:52:11,440 --> 00:52:18,370
new is actually meant to be a glue

00:52:14,650 --> 00:52:21,040
between these string types and my hope

00:52:18,370 --> 00:52:24,060
is that string we will solve or our

00:52:21,040 --> 00:52:27,670
Interop problems at API design level and

00:52:24,060 --> 00:52:29,650
will help us bridge this gap between

00:52:27,670 --> 00:52:32,650
different string types in our type

00:52:29,650 --> 00:52:36,610
system when we're talking for example of

00:52:32,650 --> 00:52:39,340
standard string and you in are th string

00:52:36,610 --> 00:52:41,710
for example or other string types for

00:52:39,340 --> 00:52:43,960
them for that matter and you can see in

00:52:41,710 --> 00:52:46,420
this example I can initialize the

00:52:43,960 --> 00:52:49,360
standard string from the return result

00:52:46,420 --> 00:52:52,420
of this to domain method that returns an

00:52:49,360 --> 00:52:54,340
edge thing because of that explicit

00:52:52,420 --> 00:52:56,200
operator that converts it to a string

00:52:54,340 --> 00:52:58,690
view and of course I can construct a

00:52:56,200 --> 00:53:01,740
standard string from the string room so

00:52:58,690 --> 00:53:07,180
that's a very nice way to compose things

00:53:01,740 --> 00:53:09,580
so first H string is also range a string

00:53:07,180 --> 00:53:13,570
exposes almost the same interface as

00:53:09,580 --> 00:53:15,880
standard thing and I think you asked a

00:53:13,570 --> 00:53:17,800
little earlier you suspected that the

00:53:15,880 --> 00:53:21,100
seller string type for the

00:53:17,800 --> 00:53:23,530
WinRT is standard thing it's not but

00:53:21,100 --> 00:53:26,020
it's something that's almost like a

00:53:23,530 --> 00:53:28,450
standard ring so it mimics the same api

00:53:26,020 --> 00:53:30,880
same interface although the string is

00:53:28,450 --> 00:53:32,910
immutable but it looks and feels

00:53:30,880 --> 00:53:35,590
familiar and it cannot interoperate

00:53:32,910 --> 00:53:37,660
seamlessly so it actually feels like

00:53:35,590 --> 00:53:39,310
you're using the standard thing you

00:53:37,660 --> 00:53:43,750
don't have to worry about it too much

00:53:39,310 --> 00:53:45,880
and you can use range for you can treat

00:53:43,750 --> 00:53:49,150
it like a range just like with standard

00:53:45,880 --> 00:53:52,240
string although each string again is

00:53:49,150 --> 00:53:54,880
utf-16 underneath it does play nice with

00:53:52,240 --> 00:53:58,870
if you do need to do some data

00:53:54,880 --> 00:54:00,730
marshalling in terms of utf-8 text in it

00:53:58,870 --> 00:54:03,940
has convenient methods to transform it

00:54:00,730 --> 00:54:07,210
to a narrow format for example like

00:54:03,940 --> 00:54:08,980
utf-8 if that's needed in your case we

00:54:07,210 --> 00:54:12,940
don't have that problem but I guess

00:54:08,980 --> 00:54:14,440
there is a nurse for that mostly in

00:54:12,940 --> 00:54:18,520
terms of if you're doing cross-platform

00:54:14,440 --> 00:54:23,020
stuff so so we'd end up with something

00:54:18,520 --> 00:54:29,170
like this in our applications and I love

00:54:23,020 --> 00:54:33,300
this slide so the the highlighted stuff

00:54:29,170 --> 00:54:36,040
is basically just your comp ledger so

00:54:33,300 --> 00:54:41,290
yeah we kind of have to deal with all of

00:54:36,040 --> 00:54:45,580
these so it's stuff so you have to think

00:54:41,290 --> 00:54:48,120
about okay I'm doing my business logic

00:54:45,580 --> 00:54:50,980
Mike platform-independent stuff in

00:54:48,120 --> 00:54:53,230
standard string and doing all my

00:54:50,980 --> 00:54:55,210
platform dependent stuff my GUI my

00:54:53,230 --> 00:54:57,790
chrome objects my platform at section

00:54:55,210 --> 00:54:59,620
layer whatever I'm doing that with let's

00:54:57,790 --> 00:55:03,910
say extinct whatever that is chrome

00:54:59,620 --> 00:55:06,700
whatever and I have to do this data

00:55:03,910 --> 00:55:09,100
marshalling and interrupt and tie those

00:55:06,700 --> 00:55:12,820
things together too so they do make

00:55:09,100 --> 00:55:14,950
sense and that's all fine until your

00:55:12,820 --> 00:55:17,380
application grows and you start to peel

00:55:14,950 --> 00:55:20,440
up utilities and algorithms around

00:55:17,380 --> 00:55:22,870
strings and then pain comes into play

00:55:20,440 --> 00:55:24,820
because you have to decide do i

00:55:22,870 --> 00:55:28,210
implement all my string algorithms in

00:55:24,820 --> 00:55:32,319
standard string do i do overloads sets

00:55:28,210 --> 00:55:34,930
for my extreme types whatever that

00:55:32,319 --> 00:55:38,780
do I'd fall back to a common denominator

00:55:34,930 --> 00:55:40,730
thing and make all my algorithms in

00:55:38,780 --> 00:55:44,720
terms of pointers to characters and

00:55:40,730 --> 00:55:47,690
lengths that's always ugly so this is

00:55:44,720 --> 00:55:49,220
war where stream view hopefully is the

00:55:47,690 --> 00:55:53,480
answer

00:55:49,220 --> 00:56:00,680
like Billy said is the duct type of the

00:55:53,480 --> 00:56:02,630
string types like that and it's still an

00:56:00,680 --> 00:56:05,900
ongoing journey but we're trying to

00:56:02,630 --> 00:56:09,010
discover if string two is really the

00:56:05,900 --> 00:56:12,470
answer to all our string problems and

00:56:09,010 --> 00:56:14,810
that's that's why I have this whole

00:56:12,470 --> 00:56:16,579
quest of actually trying to figure out

00:56:14,810 --> 00:56:19,310
the good practices and all the gotchas

00:56:16,579 --> 00:56:21,140
around using string view and of course

00:56:19,310 --> 00:56:23,829
we have the limitation of actually being

00:56:21,140 --> 00:56:29,109
able to use this if you're on c++ 17

00:56:23,829 --> 00:56:33,260
there are similar classes out there for

00:56:29,109 --> 00:56:36,440
C++ 11 like abseil string view for

00:56:33,260 --> 00:56:38,000
example but again you might have

00:56:36,440 --> 00:56:41,210
limitations on what you can use in your

00:56:38,000 --> 00:56:42,950
code base so definitely a lightweight

00:56:41,210 --> 00:56:45,589
string like view over an erect

00:56:42,950 --> 00:56:49,280
characters it basically maps this

00:56:45,589 --> 00:56:52,430
concept of pointer and length it was

00:56:49,280 --> 00:56:55,130
designed as glue code and to reduce the

00:56:52,430 --> 00:56:59,210
overload sets for your classes that's

00:56:55,130 --> 00:57:02,450
its main purpose but it does not manage

00:56:59,210 --> 00:57:05,180
the lifetime of the object clearly is

00:57:02,450 --> 00:57:08,030
the projection over on over an immutable

00:57:05,180 --> 00:57:11,300
sequence so it Maps really well to win

00:57:08,030 --> 00:57:15,560
our th string which again represents an

00:57:11,300 --> 00:57:19,280
immutable object the lifetime issue is a

00:57:15,560 --> 00:57:22,190
problem that's the main concern it has

00:57:19,280 --> 00:57:25,180
all the usual suspects in terms of

00:57:22,190 --> 00:57:28,150
constructors and conversion operators

00:57:25,180 --> 00:57:30,920
not all of them explicit unfortunately

00:57:28,150 --> 00:57:35,030
or fortunately depending on how you see

00:57:30,920 --> 00:57:38,569
it and because of that it does come with

00:57:35,030 --> 00:57:41,480
plenty of gotchas so my whole talk about

00:57:38,569 --> 00:57:43,160
hanging yourself or string views around

00:57:41,480 --> 00:57:44,870
those gadgets and trying to determine

00:57:43,160 --> 00:57:47,390
best practices in

00:57:44,870 --> 00:57:50,260
properly designing API is around Street

00:57:47,390 --> 00:57:53,060
View and where is it safe or

00:57:50,260 --> 00:57:57,290
comprehensible to use it in formal

00:57:53,060 --> 00:58:01,460
parameters rather than store it in as a

00:57:57,290 --> 00:58:03,650
data member or in containers and we're

00:58:01,460 --> 00:58:08,030
still figuring this out string U is a

00:58:03,650 --> 00:58:11,000
strange type actually deceives you in in

00:58:08,030 --> 00:58:14,210
that it's an actual value type but it

00:58:11,000 --> 00:58:16,580
fails to actually confirm into being a

00:58:14,210 --> 00:58:20,510
regular proper regular type because of

00:58:16,580 --> 00:58:22,910
its assignment operator and how its

00:58:20,510 --> 00:58:28,550
comparison function works so it's

00:58:22,910 --> 00:58:31,040
difficult it's deceiving so it's we're

00:58:28,550 --> 00:58:32,780
still figuring it out and it has real

00:58:31,040 --> 00:58:34,910
potential to really help us here

00:58:32,780 --> 00:58:37,730
especially my hopes are especially

00:58:34,910 --> 00:58:40,130
around comm and string view and I'm

00:58:37,730 --> 00:58:43,610
trying to figure out how how I can make

00:58:40,130 --> 00:58:46,280
this work in mouth my code base and it's

00:58:43,610 --> 00:58:50,210
a it's a learning process but I am

00:58:46,280 --> 00:58:55,580
optimistic so Windows come is 25 years

00:58:50,210 --> 00:58:57,080
old and this shows in many corners yes

00:58:55,580 --> 00:58:59,210
is still relevant today more than ever

00:58:57,080 --> 00:59:03,140
because Microsoft has depth in its

00:58:59,210 --> 00:59:05,780
entire WinRT api on it so we're gonna

00:59:03,140 --> 00:59:07,610
live with it and with the advent of c++

00:59:05,780 --> 00:59:10,070
17 using chrome objects and the news

00:59:07,610 --> 00:59:15,850
WinRT api is feels like a new experience

00:59:10,070 --> 00:59:17,180
in my opinion so definitely something to

00:59:15,850 --> 00:59:19,640
strive for

00:59:17,180 --> 00:59:21,110
so the dark side of chrome is the

00:59:19,640 --> 00:59:25,160
pathway to many abilities some consider

00:59:21,110 --> 00:59:28,100
to be unnatural but I'm very optimistic

00:59:25,160 --> 00:59:31,870
and I still enjoy programming chrome so

00:59:28,100 --> 00:59:31,870
with that thank you

00:59:35,069 --> 00:59:37,130

YouTube URL: https://www.youtube.com/watch?v=T_1zutIBHs0


