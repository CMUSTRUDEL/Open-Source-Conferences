Title: CppCon 2019: Adi Shavit “Generators, Coroutines and Other Brain Unrolling Sweetness”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
C++20 brings us coroutines and with them the power to create generators, iterables and ranges.
We'll see how coroutines allow for cleaner, more readable, code, easier abstraction and genericity, composition and avoiding callbacks and inversion of control.

We'll discuss the pains of writing iterator types with distributed internal state and old-school co-routines. Then we'll look at C++20 coroutines and how easy they are to write clean linear code. Coroutines prevent inversion of control and reduce callback hell. We'll see how they compose and play with Ranges with examples from math, filtering, robotics and rasterization.

The talk will focus more on co_yield and less on co_await and async related usages.
— 
Adi Shavit
Mr
Visioneer
Israel

Adi Shavit is an entrepreneur, speaker, independent consultant, experienced software architect and a computer vision, image processing, and machine learning expert with an emphasis on real-time applications. He specializes in building cross-platform, high-performance software combined with high production quality and maintainable code-bases. Adi is the founder of the Core C++ users group in Israel.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:11,290 --> 00:00:16,970
all right

00:00:12,769 --> 00:00:21,169
hello everyone I'd like to give you a

00:00:16,970 --> 00:00:24,140
taste of generators and co-routines I'll

00:00:21,169 --> 00:00:26,570
only focus on the user side and the user

00:00:24,140 --> 00:00:28,730
usage and I'm actually not going to

00:00:26,570 --> 00:00:31,009
explain a lot of the compiler magic that

00:00:28,730 --> 00:00:33,399
happens behind the scenes there are some

00:00:31,009 --> 00:00:36,590
resources which I'll point to at the end

00:00:33,399 --> 00:00:40,340
but I hope to stimulate you to go and

00:00:36,590 --> 00:00:43,190
learn more so say we want to iterate

00:00:40,340 --> 00:00:45,140
over all the elements of a vector we can

00:00:43,190 --> 00:00:47,620
write a function or a subroutine to do

00:00:45,140 --> 00:00:50,990
that and we can see that this function

00:00:47,620 --> 00:00:53,660
actually does two things it iterates

00:00:50,990 --> 00:00:56,540
over a sequence and then it does some

00:00:53,660 --> 00:00:59,270
operation which on to each element of

00:00:56,540 --> 00:01:00,950
the sequence if we want it to apply to

00:00:59,270 --> 00:01:03,320
do another operation we'd actually have

00:01:00,950 --> 00:01:06,890
to write another function now let's see

00:01:03,320 --> 00:01:09,890
another example say we want to draw a

00:01:06,890 --> 00:01:11,689
line we can go to various algorithm

00:01:09,890 --> 00:01:13,969
books or online resources

00:01:11,689 --> 00:01:15,829
don't try to check this one this is only

00:01:13,969 --> 00:01:18,289
a partial line implementation and

00:01:15,829 --> 00:01:20,710
usually what you see would be code that

00:01:18,289 --> 00:01:23,479
looks somewhat similar to this code of

00:01:20,710 --> 00:01:25,549
drawn line function here and again it

00:01:23,479 --> 00:01:27,409
actually does two things it iterates

00:01:25,549 --> 00:01:29,630
over a sequence in this case is the

00:01:27,409 --> 00:01:31,819
Picts of the rasterized pixels along the

00:01:29,630 --> 00:01:34,520
line and it draws the pixel to the

00:01:31,819 --> 00:01:38,179
screen using a function called put pixel

00:01:34,520 --> 00:01:39,740
now John line actually assumes some

00:01:38,179 --> 00:01:41,840
several things about this function

00:01:39,740 --> 00:01:43,789
called pixel it assumes that it's

00:01:41,840 --> 00:01:45,799
available so that you can come

00:01:43,789 --> 00:01:47,840
compile and Link with it it assumes it

00:01:45,799 --> 00:01:49,909
has the correct signature it assumes

00:01:47,840 --> 00:01:51,979
that it does the correct thing when we

00:01:49,909 --> 00:01:54,200
actually call it in mid computation and

00:01:51,979 --> 00:01:56,149
we're actually assuming this is a little

00:01:54,200 --> 00:01:58,429
bit more implicit that it will return

00:01:56,149 --> 00:02:01,789
the control flow to draw a line where

00:01:58,429 --> 00:02:03,380
for continuing our computation so we can

00:02:01,789 --> 00:02:05,270
see a general pattern here that

00:02:03,380 --> 00:02:07,189
subroutines are actually they have two

00:02:05,270 --> 00:02:08,780
properties first of all is their eager

00:02:07,189 --> 00:02:11,599
they currently process the whole

00:02:08,780 --> 00:02:13,940
sequence before finishing or terminating

00:02:11,599 --> 00:02:16,220
and and they're also closed they have a

00:02:13,940 --> 00:02:20,720
predefined operation which they apply to

00:02:16,220 --> 00:02:21,980
each of the sequence elements so you

00:02:20,720 --> 00:02:26,090
might say yes but

00:02:21,980 --> 00:02:28,760
common mitigation of handling is

00:02:26,090 --> 00:02:30,319
callbacks we can pass external callback

00:02:28,760 --> 00:02:33,230
functions to our own function and

00:02:30,319 --> 00:02:36,830
actually C++ offers multiple mechanisms

00:02:33,230 --> 00:02:39,019
for using callbacks and this is in fact

00:02:36,830 --> 00:02:41,269
how many STL algorithms works

00:02:39,019 --> 00:02:43,310
however callbacks themselves have their

00:02:41,269 --> 00:02:45,620
own set of issues for example in

00:02:43,310 --> 00:02:47,299
inversion of control means that we're

00:02:45,620 --> 00:02:49,250
calling external code that is not

00:02:47,299 --> 00:02:52,099
necessarily known to be trustworthy

00:02:49,250 --> 00:02:55,099
valid or correct from our own library

00:02:52,099 --> 00:02:57,140
and we're kind of assuming that it is

00:02:55,099 --> 00:02:59,390
because we were still in mid computation

00:02:57,140 --> 00:03:01,730
and initially there is something called

00:02:59,390 --> 00:03:04,280
callback Hell where the program the

00:03:01,730 --> 00:03:06,079
program flow is skipping between many

00:03:04,280 --> 00:03:08,170
decoupled parts of the code the code

00:03:06,079 --> 00:03:10,970
actually becomes extremely hard to

00:03:08,170 --> 00:03:12,500
understand to reason about debug and to

00:03:10,970 --> 00:03:14,840
maintain and not to mention an

00:03:12,500 --> 00:03:19,790
additional potential performance issues

00:03:14,840 --> 00:03:22,250
and even couple even when we're using

00:03:19,790 --> 00:03:25,579
code backs our code is still either it

00:03:22,250 --> 00:03:30,769
still wants to process the whole int the

00:03:25,579 --> 00:03:33,109
whole sequence before finishing so if

00:03:30,769 --> 00:03:35,239
only there was a way to sort of flip

00:03:33,109 --> 00:03:36,799
these functions inside out and iterate

00:03:35,239 --> 00:03:39,620
the sequence without pre committing to a

00:03:36,799 --> 00:03:43,459
specific operation okay we're all

00:03:39,620 --> 00:03:47,389
familiar with iterators iterators were

00:03:43,459 --> 00:03:50,450
introduced in by Stepanov in 1993 and

00:03:47,389 --> 00:03:53,180
became part of the STL standard library

00:03:50,450 --> 00:03:55,609
in 1998 and they're often standalone

00:03:53,180 --> 00:03:57,650
types which are only indirectly or

00:03:55,609 --> 00:04:00,590
implicitly coupled to an actual concrete

00:03:57,650 --> 00:04:03,049
sequence and we have many examples in

00:04:00,590 --> 00:04:05,030
our standard we have the ice-cream

00:04:03,049 --> 00:04:06,829
iterator which reads element from an

00:04:05,030 --> 00:04:10,569
input stream using the input iterator

00:04:06,829 --> 00:04:12,650
we've read iterator basically adapts the

00:04:10,569 --> 00:04:14,989
reverses the direction of a given

00:04:12,650 --> 00:04:17,630
iterator for iterating from back to

00:04:14,989 --> 00:04:19,190
front and simplify seventeen brings us

00:04:17,630 --> 00:04:21,289
for example the recursive director

00:04:19,190 --> 00:04:23,419
iterator which is the literary object

00:04:21,289 --> 00:04:27,440
that we krisily iterates over all the

00:04:23,419 --> 00:04:30,530
elements in a file system and all its

00:04:27,440 --> 00:04:32,990
subfolders now an interesting point here

00:04:30,530 --> 00:04:35,210
is that the filesystem directory cited

00:04:32,990 --> 00:04:35,840
sub tree hierarchy is the sequence will

00:04:35,210 --> 00:04:38,300
iterate

00:04:35,840 --> 00:04:41,990
and our program doesn't have an actual

00:04:38,300 --> 00:04:45,010
sequence like a vector that it needs to

00:04:41,990 --> 00:04:47,300
iterate on so basically we have

00:04:45,010 --> 00:04:48,830
conceptually we have a sequence in our

00:04:47,300 --> 00:04:52,040
program although it's only implicitly

00:04:48,830 --> 00:04:56,000
exists in inside our program so but we

00:04:52,040 --> 00:04:58,699
can also write our own iterator types so

00:04:56,000 --> 00:05:00,830
I decided to pick on open CV and open CV

00:04:58,699 --> 00:05:03,050
has the type called CV line iterator

00:05:00,830 --> 00:05:05,180
it's used to iterate over all the pixels

00:05:03,050 --> 00:05:07,550
on a rasterized line connecting two

00:05:05,180 --> 00:05:11,330
points it has a typical iterator object

00:05:07,550 --> 00:05:15,320
type API I simplified it a bit for

00:05:11,330 --> 00:05:17,030
brevity and note that instead it doesn't

00:05:15,320 --> 00:05:19,220
have an explicit sequence that it's

00:05:17,030 --> 00:05:21,530
iterating over it lazily

00:05:19,220 --> 00:05:23,690
and this is an important word it lazily

00:05:21,530 --> 00:05:26,030
calculates the pixel position when the

00:05:23,690 --> 00:05:28,070
iterator is incremented and it

00:05:26,030 --> 00:05:30,500
implements various present harm

00:05:28,070 --> 00:05:33,919
algorithms in four different condition

00:05:30,500 --> 00:05:37,100
so and how do we use such an object here

00:05:33,919 --> 00:05:39,590
is the some code copied from the opencv

00:05:37,100 --> 00:05:43,130
documentations which tries to copies the

00:05:39,590 --> 00:05:46,760
pixels along the line into a buffer so

00:05:43,130 --> 00:05:48,530
but alternatively we may decide we want

00:05:46,760 --> 00:05:50,930
to draw the line by setting colors to

00:05:48,530 --> 00:05:53,240
the pixels maybe want to do some fancy

00:05:50,930 --> 00:05:54,740
color gradients along the line but you

00:05:53,240 --> 00:05:58,340
as you can see we're creating an

00:05:54,740 --> 00:06:00,380
iterator object Oh giving it an image

00:05:58,340 --> 00:06:02,450
into points we're creating a buffer a

00:06:00,380 --> 00:06:05,720
suitably sized buffer and then we are

00:06:02,450 --> 00:06:09,110
iterating on the iterator IT dot count

00:06:05,720 --> 00:06:11,389
time and copying the current pixel value

00:06:09,110 --> 00:06:13,120
and incrementing the iterator we can

00:06:11,389 --> 00:06:15,950
argue if this is the most elegant

00:06:13,120 --> 00:06:17,660
interface with horrible public members

00:06:15,950 --> 00:06:20,090
but that's not really the point I'm

00:06:17,660 --> 00:06:23,180
trying I'm not trying to fix Open Series

00:06:20,090 --> 00:06:27,440
line iterator I actually want to point

00:06:23,180 --> 00:06:31,340
to two more two problems that are

00:06:27,440 --> 00:06:34,789
actually more general and affect most

00:06:31,340 --> 00:06:40,520
iterator types so because iterator is to

00:06:34,789 --> 00:06:43,310
are in imperfect abstraction so how do

00:06:40,520 --> 00:06:46,010
we know when to stop incrementing the

00:06:43,310 --> 00:06:48,409
iterator how do we know when the

00:06:46,010 --> 00:06:49,550
sequence is done and this is a question

00:06:48,409 --> 00:06:52,640
that all iterator

00:06:49,550 --> 00:06:54,860
object must be able to answer so if we

00:06:52,640 --> 00:06:57,680
look at our examples civil an iterator

00:06:54,860 --> 00:06:59,930
as we saw we must increment it most IT

00:06:57,680 --> 00:07:02,690
dot count times I stream iterator

00:06:59,930 --> 00:07:05,660
becomes equal to the global default

00:07:02,690 --> 00:07:08,390
constructor may be a universal I stream

00:07:05,660 --> 00:07:11,510
iterator our reverse iterator becomes

00:07:08,390 --> 00:07:14,000
equal to the our end iterator from the

00:07:11,510 --> 00:07:15,860
underlying sequence and the recursive

00:07:14,000 --> 00:07:18,590
directory iterator becomes equal to

00:07:15,860 --> 00:07:22,130
calling the standalone STP and function

00:07:18,590 --> 00:07:26,780
on the iterator now we can see each of

00:07:22,130 --> 00:07:29,570
these api's chose a slightly different

00:07:26,780 --> 00:07:31,520
condition in slightly way slightly

00:07:29,570 --> 00:07:33,350
different why for deciding or letting

00:07:31,520 --> 00:07:35,630
the user know when to stop now

00:07:33,350 --> 00:07:37,730
the last two examples demonstrate one of

00:07:35,630 --> 00:07:40,370
the biggest drawbacks of iterator

00:07:37,730 --> 00:07:42,710
abstraction that the end iterator is

00:07:40,370 --> 00:07:44,870
tightly coupled at runtime to the

00:07:42,710 --> 00:07:47,960
beginner to later object and this is a

00:07:44,870 --> 00:07:50,240
major pitfall when the anti traitors of

00:07:47,960 --> 00:07:53,390
the correct type but not created from

00:07:50,240 --> 00:07:55,600
the same sequence so that passing such a

00:07:53,390 --> 00:07:58,370
pair to an STL algorithm will actually

00:07:55,600 --> 00:08:00,170
cause undefined behavior and your code

00:07:58,370 --> 00:08:02,510
may come in the worst case the Q code

00:08:00,170 --> 00:08:07,970
will actually compile but you may have

00:08:02,510 --> 00:08:10,730
nasal demons so c plus plus 20 is

00:08:07,970 --> 00:08:13,210
bringing us ranges and ranges really are

00:08:10,730 --> 00:08:16,250
the solution to this awkward coupling

00:08:13,210 --> 00:08:18,940
problem because it's an abstraction

00:08:16,250 --> 00:08:22,460
layer on top of iterators

00:08:18,940 --> 00:08:24,530
that's because a grange c++ 20 range

00:08:22,460 --> 00:08:26,720
encapsulate a beginner to later and an

00:08:24,530 --> 00:08:29,180
end iterator per it also it can also

00:08:26,720 --> 00:08:31,340
capsulate an iterator in the size or an

00:08:29,180 --> 00:08:33,290
iterator in a stopping condition but

00:08:31,340 --> 00:08:36,860
it's still a single object that we can

00:08:33,290 --> 00:08:38,630
pass to the ranges STL algorithms making

00:08:36,860 --> 00:08:41,510
them much more powerful and composable

00:08:38,630 --> 00:08:45,200
and allowing us to create pipes there is

00:08:41,510 --> 00:08:47,960
a ton more to say about ranges and my

00:08:45,200 --> 00:08:50,270
focus here is that i want you to

00:08:47,960 --> 00:08:53,330
contemplate how some ranges might may

00:08:50,270 --> 00:08:57,080
actually be implemented by a user by us

00:08:53,330 --> 00:08:58,850
by us as well as users to be able to

00:08:57,080 --> 00:09:01,250
interact with additional ranges and

00:08:58,850 --> 00:09:02,660
since ranges are generalized iterators

00:09:01,250 --> 00:09:05,899
implementing them

00:09:02,660 --> 00:09:08,389
still suffered from the from another

00:09:05,899 --> 00:09:11,680
difficulty that also plagues it other

00:09:08,389 --> 00:09:15,019
iterator object implementation and

00:09:11,680 --> 00:09:18,740
distributed logic is really the iterator

00:09:15,019 --> 00:09:21,259
cousin of callback hell because the

00:09:18,740 --> 00:09:22,959
iterator API implementation requires us

00:09:21,259 --> 00:09:26,060
to have distributed logic and

00:09:22,959 --> 00:09:28,310
centralized state so while the loop

00:09:26,060 --> 00:09:30,649
iteration the iteration loop is

00:09:28,310 --> 00:09:32,709
externalized which is what we wanted to

00:09:30,649 --> 00:09:36,470
begin with the intermediate computations

00:09:32,709 --> 00:09:38,720
variables and state is stored or stored

00:09:36,470 --> 00:09:41,149
as mutable members as we can see there

00:09:38,720 --> 00:09:43,670
at the top and the iteration logic and

00:09:41,149 --> 00:09:45,439
the whole algorithm logic is split

00:09:43,670 --> 00:09:47,839
between the constructor and other member

00:09:45,439 --> 00:09:50,829
methods like the plus plus increment

00:09:47,839 --> 00:09:53,500
operator and if we look at the CV Lang

00:09:50,829 --> 00:09:56,209
specifically at the Sibylline iterator

00:09:53,500 --> 00:09:57,889
example we can see that at the beginning

00:09:56,209 --> 00:10:00,620
the constructor which I haven't shown

00:09:57,889 --> 00:10:03,139
the implementation here sets up a lot of

00:10:00,620 --> 00:10:05,360
the member variables the user can do F

00:10:03,139 --> 00:10:06,800
an increment the iterator at most

00:10:05,360 --> 00:10:09,350
current times and the current pixel

00:10:06,800 --> 00:10:13,130
along the line is the one pointed to by

00:10:09,350 --> 00:10:15,529
the member PTR now the body of the

00:10:13,130 --> 00:10:18,040
operator plus plus computes the next

00:10:15,529 --> 00:10:21,230
element to do to the reference and

00:10:18,040 --> 00:10:24,380
basically it's equivalent to the form to

00:10:21,230 --> 00:10:26,750
the if we had written this line iterator

00:10:24,380 --> 00:10:29,240
is a function algorithm then the

00:10:26,750 --> 00:10:33,560
operator plus plus body would be what

00:10:29,240 --> 00:10:35,329
would see inside the for loop now the

00:10:33,560 --> 00:10:37,639
second thing which is the centralized

00:10:35,329 --> 00:10:39,949
state is that we're storing the

00:10:37,639 --> 00:10:42,259
intermediate data as persistent members

00:10:39,949 --> 00:10:43,910
in the object and this way we actually

00:10:42,259 --> 00:10:46,250
don't take advantage of scope

00:10:43,910 --> 00:10:48,230
definitions and locality we're giving

00:10:46,250 --> 00:10:52,069
all the methods actual access to these

00:10:48,230 --> 00:10:53,420
to modify these members where not all

00:10:52,069 --> 00:10:55,040
methods actually need access to the

00:10:53,420 --> 00:10:57,620
vision and this is this could be a

00:10:55,040 --> 00:11:01,449
source when we're writing this this type

00:10:57,620 --> 00:11:06,339
of types it can be a source for bugs and

00:11:01,449 --> 00:11:09,649
maybe even increasing the object size so

00:11:06,339 --> 00:11:11,930
we can compare the distributed logic

00:11:09,649 --> 00:11:15,290
implementation that we saw to may be a

00:11:11,930 --> 00:11:17,390
function called process line where I'm

00:11:15,290 --> 00:11:19,790
reverting this line iterator

00:11:17,390 --> 00:11:22,190
implementation to a function on the left

00:11:19,790 --> 00:11:24,650
which I call process line and you can

00:11:22,190 --> 00:11:27,350
see I basically caught we pasted all the

00:11:24,650 --> 00:11:30,350
data for all the members and functions

00:11:27,350 --> 00:11:33,620
from line iterator into the body of the

00:11:30,350 --> 00:11:35,840
function processing line so line

00:11:33,620 --> 00:11:38,440
iterator had the problem of distributed

00:11:35,840 --> 00:11:41,420
logic but it was not gave us lazy

00:11:38,440 --> 00:11:42,830
iteration over the pixel and it was open

00:11:41,420 --> 00:11:44,990
because we could do whatever we want

00:11:42,830 --> 00:11:47,450
with these pixels on the other hand if

00:11:44,990 --> 00:11:49,640
we look at process line we have a single

00:11:47,450 --> 00:11:51,800
function which is linear and is it

00:11:49,640 --> 00:11:53,300
reason about but again because it's a

00:11:51,800 --> 00:11:57,740
fun irregular subroutine or function

00:11:53,300 --> 00:11:59,750
it's eager enclosed so if only there was

00:11:57,740 --> 00:12:01,870
a way to write a simple serial loop

00:11:59,750 --> 00:12:05,240
algorithm while still somehow

00:12:01,870 --> 00:12:10,580
abstracting away the iteration and the

00:12:05,240 --> 00:12:12,730
answer is curtain now quarantines are

00:12:10,580 --> 00:12:17,110
not a new concept in fact they were

00:12:12,730 --> 00:12:19,220
coined by Melvin Conway in 1958 and

00:12:17,110 --> 00:12:20,840
boosters had several correct

00:12:19,220 --> 00:12:23,540
implementation of the years and I've

00:12:20,840 --> 00:12:26,360
seen C libraries going back to at least

00:12:23,540 --> 00:12:31,010
before the beginning of the millennium

00:12:26,360 --> 00:12:33,110
and a quarantine is a function that can

00:12:31,010 --> 00:12:35,000
suspend execution returning an

00:12:33,110 --> 00:12:38,480
intermediate value and be resumed later

00:12:35,000 --> 00:12:39,710
from the same point by we entry and in

00:12:38,480 --> 00:12:41,990
contrast to threads which are

00:12:39,710 --> 00:12:44,330
pre-emptive coding switches are

00:12:41,990 --> 00:12:46,760
cooperative so the programmer who wrote

00:12:44,330 --> 00:12:50,750
the core team controls when the this

00:12:46,760 --> 00:12:52,760
yielding this suspension happens and in

00:12:50,750 --> 00:12:54,920
this case the kernel scheduler is not

00:12:52,760 --> 00:12:56,450
actually involved so this is totally

00:12:54,920 --> 00:12:59,870
something that happens in the user

00:12:56,450 --> 00:13:03,080
thread now if we think about it

00:12:59,870 --> 00:13:06,350
returning an intermediate result in mid

00:13:03,080 --> 00:13:09,470
computation sounds just like what we

00:13:06,350 --> 00:13:11,930
wanted so if we look at process line

00:13:09,470 --> 00:13:14,900
again and if processed were line was a

00:13:11,930 --> 00:13:17,270
call team then instead of calling and do

00:13:14,900 --> 00:13:20,900
something at the bottom in the loop body

00:13:17,270 --> 00:13:23,360
we could somehow suspend execution at

00:13:20,900 --> 00:13:26,720
that point and just yield the current

00:13:23,360 --> 00:13:27,830
value of PTR later the user can do

00:13:26,720 --> 00:13:30,620
whatever it was

00:13:27,830 --> 00:13:32,570
we want with this value and resume the

00:13:30,620 --> 00:13:34,630
computation for where we left off when

00:13:32,570 --> 00:13:39,670
once the ready

00:13:34,630 --> 00:13:44,300
so C++ 20 brings us co-routines and

00:13:39,670 --> 00:13:45,589
let's see a little bit about what's it

00:13:44,300 --> 00:13:48,140
was asked where things are so a

00:13:45,589 --> 00:13:52,130
supersized 20 function is the core

00:13:48,140 --> 00:13:54,560
routine if it's body uses the curtain

00:13:52,130 --> 00:13:58,160
operator to suspend execution until it's

00:13:54,560 --> 00:14:00,470
resumed again or if it uses the keyword

00:13:58,160 --> 00:14:03,740
code yield to suspend execution

00:14:00,470 --> 00:14:05,899
returning a value or if it uses the code

00:14:03,740 --> 00:14:08,660
the keyword called return to complete

00:14:05,899 --> 00:14:10,370
execution and return the value now how

00:14:08,660 --> 00:14:14,149
do we know if a function is the

00:14:10,370 --> 00:14:16,190
co-routine we can't not from its

00:14:14,149 --> 00:14:18,620
signature because co-routines are

00:14:16,190 --> 00:14:21,110
actually an implementation detail of a

00:14:18,620 --> 00:14:23,240
function and only if its body uses one

00:14:21,110 --> 00:14:25,790
of these special keywords can we

00:14:23,240 --> 00:14:28,550
determine if it's according so there's a

00:14:25,790 --> 00:14:30,440
lot to say about quarantines and loose

00:14:28,550 --> 00:14:32,000
Baker just give a talk and there are

00:14:30,440 --> 00:14:34,250
many other talks are linked to at the

00:14:32,000 --> 00:14:36,200
end and we're only going to scratch the

00:14:34,250 --> 00:14:39,860
surface of the capabilities of this new

00:14:36,200 --> 00:14:41,570
feature of the language and in fact I'm

00:14:39,860 --> 00:14:43,339
only going to look we don't have a long

00:14:41,570 --> 00:14:45,380
time a lot of time so I'm only going to

00:14:43,339 --> 00:14:47,810
look at coatings from a very very narrow

00:14:45,380 --> 00:14:49,550
view of creating synchronous generators

00:14:47,810 --> 00:14:51,500
from the user perspective and

00:14:49,550 --> 00:14:54,160
practically this means that we're only

00:14:51,500 --> 00:14:58,700
going to be focusing on the coil keyword

00:14:54,160 --> 00:15:01,490
okay so let's see some code here's a

00:14:58,700 --> 00:15:05,360
little function Xaro and what does are

00:15:01,490 --> 00:15:09,110
we turn we turns 42 the return type is

00:15:05,360 --> 00:15:11,570
int of course and is it according no it

00:15:09,110 --> 00:15:13,010
isn't because we saw its body again we

00:15:11,570 --> 00:15:15,010
don't look at the signature its body

00:15:13,010 --> 00:15:20,000
doesn't Q is one of the special keyword

00:15:15,010 --> 00:15:22,459
so here is another function called coral

00:15:20,000 --> 00:15:26,269
what does it return actually it doesn't

00:15:22,459 --> 00:15:29,660
return 42 and the return type is not int

00:15:26,269 --> 00:15:32,660
and of course it's a protein because it

00:15:29,660 --> 00:15:35,720
uses the Korean code keyword so how

00:15:32,660 --> 00:15:40,160
would we use coral

00:15:35,720 --> 00:15:43,800
like we use any other iterator object

00:15:40,160 --> 00:15:45,630
okay a generator is a range so we can

00:15:43,800 --> 00:15:49,800
put it in a range for loop which in this

00:15:45,630 --> 00:15:52,950
case will run just once in print 42 we

00:15:49,800 --> 00:15:55,649
can also use unroll this loop manually

00:15:52,950 --> 00:15:57,779
and create a generator Jan retrieved the

00:15:55,649 --> 00:16:03,240
beginning territory into IT and then the

00:15:57,779 --> 00:16:05,130
RFI t to get 42 but note that unlike the

00:16:03,240 --> 00:16:08,670
ice-cream iterator which you may be

00:16:05,130 --> 00:16:10,860
familiar with the first value that is 42

00:16:08,670 --> 00:16:12,510
will only be ready after we call begin

00:16:10,860 --> 00:16:17,810
for the first time and not upon

00:16:12,510 --> 00:16:22,260
construction like ice 2 meter it

00:16:17,810 --> 00:16:24,450
so obviously single element ranges

00:16:22,260 --> 00:16:26,700
that's not why you're here for the kind

00:16:24,450 --> 00:16:28,529
of pouring but since your members

00:16:26,700 --> 00:16:30,720
curtains are lazy they yield two

00:16:28,529 --> 00:16:33,480
elements one at a time we can very

00:16:30,720 --> 00:16:37,709
easily generate infinite ranges so we

00:16:33,480 --> 00:16:39,510
have IATA code in here and this infinite

00:16:37,709 --> 00:16:41,279
loop will suspend at every iteration

00:16:39,510 --> 00:16:45,209
building the current value an early

00:16:41,279 --> 00:16:48,000
resume on demand so we can call STD copy

00:16:45,209 --> 00:16:49,980
on with iota giving it 42 asking for

00:16:48,000 --> 00:16:55,579
nine elements printing it out to see out

00:16:49,980 --> 00:16:58,440
and we're getting 42 through 50 now I

00:16:55,579 --> 00:17:00,600
just want to emphasize again although we

00:16:58,440 --> 00:17:02,370
have an infinite loop because we're lazy

00:17:00,600 --> 00:17:04,050
we're allowed to do that and we don't

00:17:02,370 --> 00:17:06,270
need any stopping conditions and this is

00:17:04,050 --> 00:17:07,740
not necessary this is not actually going

00:17:06,270 --> 00:17:12,419
to be an infinite loop unless the user

00:17:07,740 --> 00:17:14,939
is running so we're passing the infinite

00:17:12,419 --> 00:17:18,410
loop a caution to the user and it

00:17:14,939 --> 00:17:21,809
doesn't apply to the court in itself

00:17:18,410 --> 00:17:24,809
okay so before anyone jumps I actually

00:17:21,809 --> 00:17:26,610
lied and although this code does compile

00:17:24,809 --> 00:17:28,500
in work the kodesh just shows it's

00:17:26,610 --> 00:17:30,780
non-standard conforming because

00:17:28,500 --> 00:17:31,770
quarantines are not allowed to have an

00:17:30,780 --> 00:17:35,419
auto return type

00:17:31,770 --> 00:17:38,400
that's an MSD see a feature or extension

00:17:35,419 --> 00:17:41,000
where that when it encounters an auto

00:17:38,400 --> 00:17:45,600
return type it automatically creates an

00:17:41,000 --> 00:17:48,450
STD experimental generator T as the

00:17:45,600 --> 00:17:49,890
return type may be auto return types

00:17:48,450 --> 00:17:53,580
will be supported in the future

00:17:49,890 --> 00:17:56,010
but the reason it cannot be supported at

00:17:53,580 --> 00:17:58,740
this moment is because there is no such

00:17:56,010 --> 00:18:03,180
thing or in no standard class called STD

00:17:58,740 --> 00:18:05,670
generator the c + s 20 standard will not

00:18:03,180 --> 00:18:09,750
ship with any standard code in support

00:18:05,670 --> 00:18:15,150
library and what we're using here is

00:18:09,750 --> 00:18:17,310
Microsoft experimental library but I do

00:18:15,150 --> 00:18:19,980
hope that by supplies of 23 I know this

00:18:17,310 --> 00:18:21,960
is a very high priority we will get a

00:18:19,980 --> 00:18:23,700
code in support library and there are

00:18:21,960 --> 00:18:25,710
several great opera source code in

00:18:23,700 --> 00:18:27,600
libraries if you're not for example on

00:18:25,710 --> 00:18:31,260
Microsoft Visual Studio like louis

00:18:27,600 --> 00:18:34,530
baker's cpp core library and we'll see

00:18:31,260 --> 00:18:39,210
some more of it later so let's see some

00:18:34,530 --> 00:18:41,790
examples i once needed to process the

00:18:39,210 --> 00:18:44,700
neighborhood around the pixel only up to

00:18:41,790 --> 00:18:46,440
its closest neighbor so my solution was

00:18:44,700 --> 00:18:49,290
to scan the image in an ever-growing

00:18:46,440 --> 00:18:52,230
spiral until bumping into it the first

00:18:49,290 --> 00:18:57,860
neighbor so on the top left you can see

00:18:52,230 --> 00:19:00,600
a spiral generator around pixel 0 0 now

00:18:57,860 --> 00:19:03,480
you can see the code is independent of

00:19:00,600 --> 00:19:06,980
an actual image or an image size and it

00:19:03,480 --> 00:19:10,490
basically lazily spirals into infinity

00:19:06,980 --> 00:19:13,110
i'm not going to explain how it works

00:19:10,490 --> 00:19:15,270
but i will point out that if you try to

00:19:13,110 --> 00:19:17,190
reason about it it's much easier to

00:19:15,270 --> 00:19:19,980
reason about code written like this is a

00:19:17,190 --> 00:19:22,980
serial function then having the logic

00:19:19,980 --> 00:19:25,350
split between multiple methods and you

00:19:22,980 --> 00:19:27,780
can see that the loop coils the current

00:19:25,350 --> 00:19:29,760
pixel position and then upon resuming it

00:19:27,780 --> 00:19:33,030
does some calculation calculating the

00:19:29,760 --> 00:19:35,490
next position now if we wanted to draw

00:19:33,030 --> 00:19:38,400
the spiral with some pretty colors we

00:19:35,490 --> 00:19:40,740
can create an RGB color generator that

00:19:38,400 --> 00:19:43,140
infinitely circles through values of the

00:19:40,740 --> 00:19:45,990
hue channel if we're using the HSV color

00:19:43,140 --> 00:19:48,540
space and generating smooth varying

00:19:45,990 --> 00:19:51,030
bright colors so in this case I'm using

00:19:48,540 --> 00:19:53,310
OpenCV to do some color to a color

00:19:51,030 --> 00:19:57,000
conversion so you can see we're creating

00:19:53,310 --> 00:20:00,630
the mattes we be those are two single

00:19:57,000 --> 00:20:02,540
pixel images and then we just return a

00:20:00,630 --> 00:20:06,650
converting starting at

00:20:02,540 --> 00:20:07,820
color HSB color is zero 25 25 I don't

00:20:06,650 --> 00:20:10,130
know I'm not sure what color that is

00:20:07,820 --> 00:20:12,500
probably red and then we're simply

00:20:10,130 --> 00:20:15,170
cycling through the HSV color space

00:20:12,500 --> 00:20:18,950
using open CV to convert it to RGB and

00:20:15,170 --> 00:20:21,530
Co gilding the RGB color for display

00:20:18,950 --> 00:20:29,540
because our displays are not don't use

00:20:21,530 --> 00:20:31,690
HSV they require RGB values so now we

00:20:29,540 --> 00:20:34,760
have these wonderful - wonderful

00:20:31,690 --> 00:20:40,520
infinite generators and we'd like to

00:20:34,760 --> 00:20:44,570
draw the animation lazily and in

00:20:40,520 --> 00:20:47,090
lockstep in tandem so we can only use a

00:20:44,570 --> 00:20:48,500
single range when we use a range for

00:20:47,090 --> 00:20:50,900
loop we own we can only use the range

00:20:48,500 --> 00:20:53,900
for for loops so how do we iterate both

00:20:50,900 --> 00:21:01,760
it generators in tandem with a single

00:20:53,900 --> 00:21:05,480
loop hmm in a pod but of course let's

00:21:01,760 --> 00:21:08,450
zip them together now coroutines can be

00:21:05,480 --> 00:21:10,790
templates so as you can see this simple

00:21:08,450 --> 00:21:12,980
zip implementation it takes two

00:21:10,790 --> 00:21:14,960
generators get there begin iterator and

00:21:12,980 --> 00:21:17,780
walks them in tandem until what either

00:21:14,960 --> 00:21:22,010
one of them if ever is done and then it

00:21:17,780 --> 00:21:25,760
lazily yields a pair of they're yielded

00:21:22,010 --> 00:21:27,290
values now in ranges v3 library there is

00:21:25,760 --> 00:21:29,210
a much more powerful zip view that

00:21:27,290 --> 00:21:31,940
should work very similar to this and

00:21:29,210 --> 00:21:37,460
actually to zip multiple ranges together

00:21:31,940 --> 00:21:41,390
I don't I'm not sure zip is actually in

00:21:37,460 --> 00:21:43,550
the sea process 20 ranges but again you

00:21:41,390 --> 00:21:46,220
see extremely simple to reason about

00:21:43,550 --> 00:21:48,530
this code it's extremely simple to see

00:21:46,220 --> 00:21:51,470
what it does and now we can compose it

00:21:48,530 --> 00:21:53,540
together in a range for loop we C++ 17

00:21:51,470 --> 00:21:56,120
structured bindings so we're creating a

00:21:53,540 --> 00:21:58,760
single generators from two and iterating

00:21:56,120 --> 00:22:01,610
them in tandem as we can see on the

00:21:58,760 --> 00:22:04,640
bottom so we have a four load taking

00:22:01,610 --> 00:22:06,170
pause in color creating zip of spiral

00:22:04,640 --> 00:22:08,330
and huge n and then we're just

00:22:06,170 --> 00:22:12,460
extracting the color and setting it to

00:22:08,330 --> 00:22:14,390
the image I think that's very very cool

00:22:12,460 --> 00:22:15,850
now

00:22:14,390 --> 00:22:18,920
[Music]

00:22:15,850 --> 00:22:20,750
let's see another example so we have a

00:22:18,920 --> 00:22:23,120
binary tree and we'd like to iterate

00:22:20,750 --> 00:22:26,480
over its nodes so we might write

00:22:23,120 --> 00:22:29,180
something like this here we have three

00:22:26,480 --> 00:22:31,430
class methods in order to order and

00:22:29,180 --> 00:22:33,140
postorder the that are in fact

00:22:31,430 --> 00:22:34,820
co-written so now we can see that coding

00:22:33,140 --> 00:22:36,560
can be not only functions in templates

00:22:34,820 --> 00:22:39,380
that can actually be methods as well and

00:22:36,560 --> 00:22:41,210
one regular non coding methods order

00:22:39,380 --> 00:22:42,010
which is going to return a court in

00:22:41,210 --> 00:22:45,100
generator

00:22:42,010 --> 00:22:48,440
now each traversal function recursively

00:22:45,100 --> 00:22:52,850
traverses the child the child nodes and

00:22:48,440 --> 00:22:55,700
Co yield the value of the tree the value

00:22:52,850 --> 00:22:57,140
in the node so given a twin overhead we

00:22:55,700 --> 00:22:58,730
can iterate off with the two elements

00:22:57,140 --> 00:23:06,860
with the chosen order and it will print

00:22:58,730 --> 00:23:10,270
at the relevant order now if you look at

00:23:06,860 --> 00:23:14,180
order you can say that it's returning

00:23:10,270 --> 00:23:16,790
the type the return type is actually the

00:23:14,180 --> 00:23:20,420
generator created by would be generator

00:23:16,790 --> 00:23:22,610
T so it's the value returned by each of

00:23:20,420 --> 00:23:25,610
the method so there is an interesting

00:23:22,610 --> 00:23:27,620
note here it for the keen observers that

00:23:25,610 --> 00:23:30,170
there's actually some type erasure

00:23:27,620 --> 00:23:31,940
happening below the surface because each

00:23:30,170 --> 00:23:33,590
of these methods has a different

00:23:31,940 --> 00:23:36,980
implementation but I'm not going to go

00:23:33,590 --> 00:23:40,250
into that but let's take a look at in

00:23:36,980 --> 00:23:43,540
order so in order checks if the left

00:23:40,250 --> 00:23:46,220
child is valid and then it basically

00:23:43,540 --> 00:23:49,520
iterates and yielding all of the values

00:23:46,220 --> 00:23:51,650
by calling in order on that node then it

00:23:49,520 --> 00:23:55,280
called the value of n does the same

00:23:51,650 --> 00:23:57,410
thing on the right now the CPP core

00:23:55,280 --> 00:23:59,900
library provides an even more convenient

00:23:57,410 --> 00:24:03,170
alternative instead of the STD generator

00:23:59,900 --> 00:24:06,500
that we saw before it's called recursive

00:24:03,170 --> 00:24:08,300
generator and it's very similar to

00:24:06,500 --> 00:24:11,720
generator except that it's designed to

00:24:08,300 --> 00:24:13,760
be more efficient because in addition to

00:24:11,720 --> 00:24:16,970
being able to call it the value of type

00:24:13,760 --> 00:24:19,520
T you can actually call yield the value

00:24:16,970 --> 00:24:21,650
of recursive generator T so when we go

00:24:19,520 --> 00:24:23,360
in the recursive generator value it's

00:24:21,650 --> 00:24:26,150
actually going to generate all of the

00:24:23,360 --> 00:24:29,210
values recursively so I think this is

00:24:26,150 --> 00:24:31,340
probably the most concise way to

00:24:29,210 --> 00:24:34,220
explain how in order to eat reversal

00:24:31,340 --> 00:24:36,320
works and I have never seen something

00:24:34,220 --> 00:24:38,299
more compacted this and it basically

00:24:36,320 --> 00:24:51,830
shows the idea of the algorithm without

00:24:38,299 --> 00:24:54,770
any additional craft so coatings are

00:24:51,830 --> 00:24:56,990
near future and they're not devoid of

00:24:54,770 --> 00:25:00,890
problems and there are extremely heated

00:24:56,990 --> 00:25:03,950
discussions about how and why they

00:25:00,890 --> 00:25:06,620
should work about how exactly in all the

00:25:03,950 --> 00:25:10,250
details again I'm kind of hiding a lot

00:25:06,620 --> 00:25:12,409
of compiler magic and code generation

00:25:10,250 --> 00:25:15,440
that happens below the surface but one

00:25:12,409 --> 00:25:16,190
of the very infamous problems with

00:25:15,440 --> 00:25:20,210
coroutines

00:25:16,190 --> 00:25:22,460
is called dangling references so we can

00:25:20,210 --> 00:25:28,970
take a look at this code here it seems

00:25:22,460 --> 00:25:33,020
reasonable and we have an agile coating

00:25:28,970 --> 00:25:36,529
called explode which takes an STD string

00:25:33,020 --> 00:25:39,500
by reference and iterate over its values

00:25:36,529 --> 00:25:41,419
yielding the characters one by one and

00:25:39,500 --> 00:25:46,640
in our main function we call this hello

00:25:41,419 --> 00:25:48,380
hello world printing the characters now

00:25:46,640 --> 00:25:58,149
once we run this this is going to

00:25:48,380 --> 00:26:00,799
explode and the reason is that in CSS 20

00:25:58,149 --> 00:26:02,690
the curtain is not really one

00:26:00,799 --> 00:26:04,279
indivisible routine it's actually split

00:26:02,690 --> 00:26:08,600
up by the compiler into a bunch of

00:26:04,279 --> 00:26:13,520
little fragments how about at each

00:26:08,600 --> 00:26:15,529
suspension point and because we have

00:26:13,520 --> 00:26:17,649
these suspended ten points each coating

00:26:15,529 --> 00:26:20,059
needs to save its state from one

00:26:17,649 --> 00:26:23,360
suspension point until it's resolved and

00:26:20,059 --> 00:26:31,029
this state takes for example the Const

00:26:23,360 --> 00:26:34,850
as the constant string and what uh so

00:26:31,029 --> 00:26:37,520
let me put this way what is what state

00:26:34,850 --> 00:26:39,200
is stored in X that's at the part of the

00:26:37,520 --> 00:26:40,669
core routine that stores the the

00:26:39,200 --> 00:26:42,700
intermediate values is called the

00:26:40,669 --> 00:26:46,809
curtain frame and

00:26:42,700 --> 00:26:49,769
meets CH and it needs of course s now s

00:26:46,809 --> 00:26:53,830
is the constant reference and that

00:26:49,769 --> 00:26:57,279
created by the temporary hello world now

00:26:53,830 --> 00:26:59,169
if we look even on cpp reference this is

00:26:57,279 --> 00:27:01,330
unrelated not directly related to

00:26:59,169 --> 00:27:03,609
coroutines we can see that when we're

00:27:01,330 --> 00:27:05,889
using arrange for the actual code that

00:27:03,609 --> 00:27:09,970
generated creates multiple statements

00:27:05,889 --> 00:27:11,980
and there is a warning

00:27:09,970 --> 00:27:14,590
beware that the life of any temporary

00:27:11,980 --> 00:27:16,259
within range expression is not extended

00:27:14,590 --> 00:27:21,009
so because we have multiple statements

00:27:16,259 --> 00:27:23,019
the temporary that gets bound and with

00:27:21,009 --> 00:27:27,460
its lifetime extended is actually the

00:27:23,019 --> 00:27:30,970
generator but the internal stream that

00:27:27,460 --> 00:27:34,059
we hope we were hoping to get bound to

00:27:30,970 --> 00:27:37,950
as two stood two s actually doesn't so

00:27:34,059 --> 00:27:40,690
we're getting dangling reference and

00:27:37,950 --> 00:27:42,669
sadly this is the simplest version and

00:27:40,690 --> 00:27:45,879
there are many many more difficult more

00:27:42,669 --> 00:27:48,190
subtle and devious examples of these

00:27:45,879 --> 00:27:50,379
dangling qualities I think there are

00:27:48,190 --> 00:27:54,759
people trying to make this a little bit

00:27:50,379 --> 00:27:57,669
more palatable but again we'll until

00:27:54,759 --> 00:28:02,289
then take care to take part in arguments

00:27:57,669 --> 00:28:04,359
by value so to summarize you know

00:28:02,289 --> 00:28:06,070
curtains are new they're really hot of

00:28:04,359 --> 00:28:08,019
the press and they're not perfect and

00:28:06,070 --> 00:28:10,149
they're not complete in many senses of

00:28:08,019 --> 00:28:11,679
the world so though they can be

00:28:10,149 --> 00:28:15,909
templates as we've seen they could be

00:28:11,679 --> 00:28:17,980
lambdas they cannot return cannot use

00:28:15,909 --> 00:28:19,899
return the return cube at the moment

00:28:17,980 --> 00:28:23,259
although some compilers do support them

00:28:19,899 --> 00:28:25,029
at the moment we can we saw that they

00:28:23,259 --> 00:28:27,759
are not actually allowed to use auto

00:28:25,029 --> 00:28:29,739
return types or concepts they also

00:28:27,759 --> 00:28:31,659
cannot be context / they cannot be

00:28:29,739 --> 00:28:33,759
constructed these factors and in fact

00:28:31,659 --> 00:28:35,230
the main main cannot be according

00:28:33,759 --> 00:28:38,440
although I'm not sure what that would

00:28:35,230 --> 00:28:40,059
mean I suspect some of these will

00:28:38,440 --> 00:28:41,830
actually be lifted as we gain more

00:28:40,059 --> 00:28:43,809
experience we've seen this with lambdas

00:28:41,830 --> 00:28:47,350
when we started very simple and then

00:28:43,809 --> 00:28:51,129
increasing in power from 14 and suppose

00:28:47,350 --> 00:28:52,899
a 17 20 but really beyond the current

00:28:51,129 --> 00:28:53,890
language limitations where is the issue

00:28:52,899 --> 00:28:55,570
of the lack of

00:28:53,890 --> 00:28:58,030
library support and I think that's

00:28:55,570 --> 00:29:00,310
probably the highest priority for the

00:28:58,030 --> 00:29:03,160
standard to give us a nice support

00:29:00,310 --> 00:29:04,690
library because even between the

00:29:03,160 --> 00:29:08,590
libraries that we do have there is a

00:29:04,690 --> 00:29:10,480
quality of implementation problem

00:29:08,590 --> 00:29:12,100
some of them support various features

00:29:10,480 --> 00:29:14,080
others support them differently and

00:29:12,100 --> 00:29:17,980
because there is no standard there is no

00:29:14,080 --> 00:29:20,620
way to tell the difference now the last

00:29:17,980 --> 00:29:22,390
thing is the compiler quality issue a

00:29:20,620 --> 00:29:24,970
quality of implementation issue where

00:29:22,390 --> 00:29:26,710
some compilers will elide heap

00:29:24,970 --> 00:29:29,740
allocations that happen for the court in

00:29:26,710 --> 00:29:31,930
frames others will try to do it in other

00:29:29,740 --> 00:29:34,240
cases so this is also something that I

00:29:31,930 --> 00:29:36,520
hope will get better and better as we

00:29:34,240 --> 00:29:42,880
learn more about how Co routines are

00:29:36,520 --> 00:29:44,740
actually used in practice so this is as

00:29:42,880 --> 00:29:47,080
I said the more very motivation and very

00:29:44,740 --> 00:29:49,600
introductory talk about Co routines and

00:29:47,080 --> 00:29:52,780
generators which I try to focus on how

00:29:49,600 --> 00:29:55,060
we write coatings and ranges from the

00:29:52,780 --> 00:29:56,800
user perspective and there's a lot more

00:29:55,060 --> 00:29:59,920
details that I'm kind of sweeping under

00:29:56,800 --> 00:30:01,630
the carpet here and I'm really not doing

00:29:59,920 --> 00:30:03,550
justice to all the power of coding so

00:30:01,630 --> 00:30:06,220
this is only a very small part of what

00:30:03,550 --> 00:30:08,470
coatings can do there are there is a

00:30:06,220 --> 00:30:11,290
massive list of coding resources by Matt

00:30:08,470 --> 00:30:12,940
Padilla this link cpp reference has a

00:30:11,290 --> 00:30:14,860
nice page about coatings there is a

00:30:12,940 --> 00:30:16,600
quarantine channel on slack which

00:30:14,860 --> 00:30:18,310
basically most I think most of the

00:30:16,600 --> 00:30:22,090
committee members were are interested

00:30:18,310 --> 00:30:25,810
and implementing coatings hang out there

00:30:22,090 --> 00:30:27,130
so feel free to go and ask and I'm

00:30:25,810 --> 00:30:28,750
actually going to publish a more

00:30:27,130 --> 00:30:32,290
detailed version of this talk on my blog

00:30:28,750 --> 00:30:35,200
will be up in the coming weeks so I hope

00:30:32,290 --> 00:30:36,820
you had were stimulated enough to go and

00:30:35,200 --> 00:30:39,010
try coroutines I think they're super

00:30:36,820 --> 00:30:39,930
awesome so thank you very much for

00:30:39,010 --> 00:30:44,289
staying

00:30:39,930 --> 00:30:44,289

YouTube URL: https://www.youtube.com/watch?v=qYHDERleSL8


