Title: CppCon 2019: Mateusz Pusz “A C++ Approach to Physical Units"
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
This talk presents a new C++20 library for Dimensional Analysis and Physical Units handling. The essential requirements of the library are user-friendliness, compile-time safety, no runtime overhead, and easy extensibility. The syntax of the library is built around a few easy to learn concepts and strictly checked at compile time, which makes it easy to learn and very forgiving for the novice.

The talk presents motivating examples of why we need such a library, compares the library with other similar products on the market, describes the basic usage and interface, and highlights the benefits of the design choices made.

The talk is also a great showcase of practical usage of new C++20 features that make the library interface easier to use, maintain, and extend. Concepts, contracts, class types provided as non-type template parameters, and other C++20 features make a huge difference in how we can design Modern C++ code.
— 
Mateusz Pusz
Epam Systems | Train IT
Chief Software Engineer | C++ Trainer
Gdansk, Pomeranian District, Poland

Software architect, chief developer, and security champion with more than 14 years of experience in designing, writing and maintaining C++ code for fun and living. C++ consultant, trainer, and evangelist focused on Modern C++. His main areas of interest and expertise are code performance, low latency, stability, and security.

Mateusz worked at Intel for 13 years and now he leads C++ Community at EPAM Systems. He is also a founder of Train IT that provides C++ trainings to corporations. Mateusz is an active voting member of the ISO C++ Committee (WG21) where, together with the best C++ experts in the world, he shapes the next official version of the C++ language. He is also a member of WG21 Study Group 14 (SG14) responsible for driving performance and low latency subjects in the Committee. In 2013 Mateusz won “Bench Games 2013” – worldwide competition in the C++ language knowledge.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,280 --> 00:00:13,910
hello everyone my name is Matias bush

00:00:11,450 --> 00:00:16,370
I'm the chip zoto engineer and also the

00:00:13,910 --> 00:00:16,970
head of C++ competency center Tippin

00:00:16,370 --> 00:00:19,040
systems

00:00:16,970 --> 00:00:21,800
I'm also a super-fast trainer and a

00:00:19,040 --> 00:00:24,290
consultant today we will be talking

00:00:21,800 --> 00:00:26,869
about the physical Linux library this is

00:00:24,290 --> 00:00:29,210
a subject that I spend a lot of time

00:00:26,869 --> 00:00:31,279
lately trying to figure out how to do it

00:00:29,210 --> 00:00:33,530
in the correct way so we'll be talking

00:00:31,279 --> 00:00:35,840
about the software and Link dimensional

00:00:33,530 --> 00:00:38,960
analysis and physical unit conversions

00:00:35,840 --> 00:00:41,450
and and how to make it right and also

00:00:38,960 --> 00:00:43,480
will I look on the solutions that are

00:00:41,450 --> 00:00:46,340
currently on the market

00:00:43,480 --> 00:00:49,030
but why do we care about this first of

00:00:46,340 --> 00:00:52,910
all you should answer this question so

00:00:49,030 --> 00:00:55,190
probably aware of this story of Mars

00:00:52,910 --> 00:00:59,929
climate orbiter this was one of the

00:00:55,190 --> 00:01:01,070
famous disasters in our IT industry this

00:00:59,929 --> 00:01:05,239
was a robotic space probe that was

00:01:01,070 --> 00:01:08,600
launched in 98 in December it cost a lot

00:01:05,239 --> 00:01:11,410
of money for development for the land

00:01:08,600 --> 00:01:14,690
for the for the operations and so on and

00:01:11,410 --> 00:01:18,890
after a bit more than half a year it

00:01:14,690 --> 00:01:22,759
reached Mars nearly it was about go

00:01:18,890 --> 00:01:27,470
through this trajectory to to the orbit

00:01:22,759 --> 00:01:29,270
as you can see earth is here so we

00:01:27,470 --> 00:01:32,210
expected that we will lose the

00:01:29,270 --> 00:01:36,890
communication with the Webley probe for

00:01:32,210 --> 00:01:40,340
a short time well it will be gaining the

00:01:36,890 --> 00:01:43,009
be entering the orbit of Earth Mars but

00:01:40,340 --> 00:01:46,159
actually after the communication was

00:01:43,009 --> 00:01:49,420
lost we never reestablished it what

00:01:46,159 --> 00:01:51,920
happened is that instead of this Factory

00:01:49,420 --> 00:01:57,469
actually did approp went through this

00:01:51,920 --> 00:01:59,899
line so probably 170 or sixty kilometers

00:01:57,469 --> 00:02:03,740
in a space distance and dimensions is

00:01:59,899 --> 00:02:06,969
not too much but it actually made a big

00:02:03,740 --> 00:02:09,619
difference here the probe went too low

00:02:06,969 --> 00:02:11,810
for the orbit maneuver orbit orbiting

00:02:09,619 --> 00:02:13,910
maneuver and the gravity of the Mars was

00:02:11,810 --> 00:02:18,260
too strong so it is it destroyed it in

00:02:13,910 --> 00:02:20,800
the Mars atmosphere what was the problem

00:02:18,260 --> 00:02:20,800
here

00:02:21,290 --> 00:02:28,250
the primary cause was the lack of

00:02:25,910 --> 00:02:31,069
understanding or communication between

00:02:28,250 --> 00:02:35,890
two teams working separately of the of

00:02:31,069 --> 00:02:38,720
the parts of the software the NASA was

00:02:35,890 --> 00:02:41,810
working was fighting the air components

00:02:38,720 --> 00:02:44,480
according to the specification in SI

00:02:41,810 --> 00:02:47,690
units this is in total units and

00:02:44,480 --> 00:02:49,880
Lockheed Martin was doing the urban

00:02:47,690 --> 00:02:53,180
component and using United States

00:02:49,880 --> 00:02:55,180
customary units and basically it was

00:02:53,180 --> 00:02:58,640
contrary to the into the specification

00:02:55,180 --> 00:03:00,860
the result actual expert if eclis was

00:02:58,640 --> 00:03:03,950
that one of the components were

00:03:00,860 --> 00:03:06,010
providing the data in pounds per second

00:03:03,950 --> 00:03:08,660
another one expected newtons per second

00:03:06,010 --> 00:03:11,959
and because of this we lost a lot of

00:03:08,660 --> 00:03:18,739
money and time and basically this yeah

00:03:11,959 --> 00:03:20,540
we should be a shame of such things but

00:03:18,739 --> 00:03:23,630
you probably know about this but why do

00:03:20,540 --> 00:03:25,880
I personally care about this a long time

00:03:23,630 --> 00:03:28,609
ago in a galaxy far far away so it was

00:03:25,880 --> 00:03:32,720
like three years ago I was a competition

00:03:28,609 --> 00:03:35,420
glider pilot this is me flying over the

00:03:32,720 --> 00:03:37,549
mountains in my glider and you can

00:03:35,420 --> 00:03:40,549
actually see here a small device this is

00:03:37,549 --> 00:03:41,480
an embedded car navigation system were

00:03:40,549 --> 00:03:44,060
running Clyde it's something like

00:03:41,480 --> 00:03:46,100
Windows c40 really all system operations

00:03:44,060 --> 00:03:47,750
operational system and there is a

00:03:46,100 --> 00:03:50,420
software application open source

00:03:47,750 --> 00:03:52,900
application that I contributed to it's a

00:03:50,420 --> 00:03:55,730
tactical flight computer for propagation

00:03:52,900 --> 00:03:59,959
it basically provides us the current

00:03:55,730 --> 00:04:02,720
position over the map and also in real

00:03:59,959 --> 00:04:05,329
time it calculates for example the

00:04:02,720 --> 00:04:08,000
distance that you can achieve from from

00:04:05,329 --> 00:04:10,579
this from this altitude so you can

00:04:08,000 --> 00:04:14,780
secure this dotted area this is the area

00:04:10,579 --> 00:04:16,640
that I can not that they cannot reach

00:04:14,780 --> 00:04:18,940
from from this specific location taking

00:04:16,640 --> 00:04:23,270
into account my altitude the glider and

00:04:18,940 --> 00:04:28,880
efficiency a wind and the rain and and

00:04:23,270 --> 00:04:32,240
other conditions also the same looking

00:04:28,880 --> 00:04:34,580
from the vertical view this is my my my

00:04:32,240 --> 00:04:36,379
my my

00:04:34,580 --> 00:04:38,569
they would like to reach this is my

00:04:36,379 --> 00:04:41,539
position they have a big here I want to

00:04:38,569 --> 00:04:42,830
make sure if I select this route that I

00:04:41,539 --> 00:04:44,960
will be able to go over the speak

00:04:42,830 --> 00:04:46,219
because there's no gliders the do not

00:04:44,960 --> 00:04:48,020
have engines yes

00:04:46,219 --> 00:04:50,199
so sometimes it's really hard to gain

00:04:48,020 --> 00:04:56,539
attitude if you if you lose it already

00:04:50,199 --> 00:04:58,879
so yeah this is how I became familiar

00:04:56,539 --> 00:05:02,389
with the problem of dimensional analysis

00:04:58,879 --> 00:05:04,189
and physical units conversions I don't

00:05:02,389 --> 00:05:05,960
want to blame anyone here because this

00:05:04,189 --> 00:05:07,849
is open-source software written by by

00:05:05,960 --> 00:05:09,500
like three to four developers doing this

00:05:07,849 --> 00:05:11,090
their free time they are doing their

00:05:09,500 --> 00:05:13,789
best and they are serving the community

00:05:11,090 --> 00:05:16,879
is three popular software actually but

00:05:13,789 --> 00:05:19,849
it also heated some code base from even

00:05:16,879 --> 00:05:22,849
order C project so you can expect how it

00:05:19,849 --> 00:05:24,469
works but this is this is not typical

00:05:22,849 --> 00:05:26,509
only for open source projects and not

00:05:24,469 --> 00:05:27,650
particularly this one as a trainer and

00:05:26,509 --> 00:05:30,020
consultant I work with different

00:05:27,650 --> 00:05:32,419
corporations and I know how the

00:05:30,020 --> 00:05:34,639
production code looks in many many

00:05:32,419 --> 00:05:37,039
different industries it's not much

00:05:34,639 --> 00:05:40,129
different from this one so this is the D

00:05:37,039 --> 00:05:43,159
function in that provides us bearing

00:05:40,129 --> 00:05:45,529
Toto specific latitude longitude and it

00:05:43,159 --> 00:05:48,139
returns the the data through the

00:05:45,529 --> 00:05:49,750
argument distance and bearing there is

00:05:48,139 --> 00:05:52,789
another function in the same header file

00:05:49,750 --> 00:05:59,750
that does similar stop but not is the

00:05:52,789 --> 00:06:02,150
order of the arguments yes and I assume

00:05:59,750 --> 00:06:04,219
that's not the unique example here

00:06:02,150 --> 00:06:11,089
probably there are more and if you think

00:06:04,219 --> 00:06:12,680
that it can cannot be worse it can this

00:06:11,089 --> 00:06:15,229
is basically how we tend to write

00:06:12,680 --> 00:06:17,569
software maybe not we but at some people

00:06:15,229 --> 00:06:20,509
tend to write software yes but to be

00:06:17,569 --> 00:06:23,379
correct this is how production software

00:06:20,509 --> 00:06:26,000
open loops also it's not only about

00:06:23,379 --> 00:06:29,089
reorder using doubles there is also a

00:06:26,000 --> 00:06:33,589
lot of magic constants in the code we

00:06:29,089 --> 00:06:35,569
don't want to write code like this and

00:06:33,589 --> 00:06:37,909
this is basically how why I care

00:06:35,569 --> 00:06:40,190
personally about about this this in this

00:06:37,909 --> 00:06:44,029
list up I would like to change something

00:06:40,190 --> 00:06:47,810
so did you ever have to write the codes

00:06:44,029 --> 00:06:50,900
this way why we are doing this yes

00:06:47,810 --> 00:06:52,450
basically we are doing this because we

00:06:50,900 --> 00:06:54,440
don't have tools in the standard library

00:06:52,450 --> 00:06:55,580
what I have noticed working with

00:06:54,440 --> 00:06:57,290
different corporations as a trainer and

00:06:55,580 --> 00:06:59,870
consultant I found out that introducing

00:06:57,290 --> 00:07:03,340
Crona to C++ 11 was a breakthrough for

00:06:59,870 --> 00:07:05,420
the industry to work with time stamped

00:07:03,340 --> 00:07:07,280
so even though there were some

00:07:05,420 --> 00:07:09,230
open-source libraries earlier doing

00:07:07,280 --> 00:07:10,880
doing similar stuff people didn't use

00:07:09,230 --> 00:07:13,670
them putting this subject in a standard

00:07:10,880 --> 00:07:16,790
makes it accessible to everyone it's

00:07:13,670 --> 00:07:19,610
easy to use and also easy to for example

00:07:16,790 --> 00:07:22,400
pass through they like like the legal

00:07:19,610 --> 00:07:23,990
stuff in the company yes it's much

00:07:22,400 --> 00:07:26,150
easier to use the standard or maybe

00:07:23,990 --> 00:07:28,040
boost but probably other open-source

00:07:26,150 --> 00:07:33,220
libraries sometimes are not allowed to

00:07:28,040 --> 00:07:33,220
be used in the in the in the production

00:07:34,750 --> 00:07:40,130
there is lack of good alternatives there

00:07:38,000 --> 00:07:42,470
is of course boost units and other

00:07:40,130 --> 00:07:44,030
libraries but in many cases they provide

00:07:42,470 --> 00:07:45,110
poor user experience as you've seen as

00:07:44,030 --> 00:07:47,540
you will see during this presentation

00:07:45,110 --> 00:07:48,890
and also introduced many dependencies

00:07:47,540 --> 00:07:50,540
like you have to include half of the

00:07:48,890 --> 00:07:55,640
boost in order to just have boost units

00:07:50,540 --> 00:07:57,320
working for you and as I already said

00:07:55,640 --> 00:07:58,940
custom fit part libraries that are

00:07:57,320 --> 00:08:02,360
either in the standard library or the

00:07:58,940 --> 00:08:05,350
booth or maybe QT are not allowed so you

00:08:02,360 --> 00:08:07,820
cannot just take some some anonymous

00:08:05,350 --> 00:08:09,650
project from from the github from from

00:08:07,820 --> 00:08:11,090
vendor you don't know and put it in

00:08:09,650 --> 00:08:15,340
production code because probably someone

00:08:11,090 --> 00:08:15,340
will complain about it in your company

00:08:15,430 --> 00:08:21,470
and we can always do this by ourselves

00:08:18,440 --> 00:08:25,160
yes but actually it's not that easy this

00:08:21,470 --> 00:08:26,720
one is tricky of course you can provide

00:08:25,160 --> 00:08:28,520
some custom plantation for specific

00:08:26,720 --> 00:08:30,169
needs of your project its rating

00:08:28,520 --> 00:08:32,150
constraint but pursue do not not be a

00:08:30,169 --> 00:08:33,740
generic one that will handle all of the

00:08:32,150 --> 00:08:39,500
use cases because it's pretty complex

00:08:33,740 --> 00:08:41,539
domain so before we will go A to D into

00:08:39,500 --> 00:08:43,880
the details let's talk about a bit about

00:08:41,539 --> 00:08:46,660
the it helps and definitions here so

00:08:43,880 --> 00:08:51,110
what is the internal set of units is the

00:08:46,660 --> 00:08:54,650
group of seven base units 22 named units

00:08:51,110 --> 00:08:57,250
20 prefixes to those units those buzzy

00:08:54,650 --> 00:08:59,870
buzzy units are the time length mass

00:08:57,250 --> 00:09:02,630
electric current thermodynamic

00:08:59,870 --> 00:09:05,060
temperature amount of substance

00:09:02,630 --> 00:09:08,899
each of them has its own simple its own

00:09:05,060 --> 00:09:12,199
unit and unit name of course this is

00:09:08,899 --> 00:09:14,510
just basic building bricks for doing

00:09:12,199 --> 00:09:16,940
something bigger is to building co-opted

00:09:14,510 --> 00:09:18,709
derived dimensions so here are some

00:09:16,940 --> 00:09:20,360
examples of the direct dimensions that

00:09:18,709 --> 00:09:23,810
doesn't have their own unit and they are

00:09:20,360 --> 00:09:27,649
just using the the base unit like square

00:09:23,810 --> 00:09:31,880
meters cubic meters meters per second

00:09:27,649 --> 00:09:33,740
and so on there also a lot of the right

00:09:31,880 --> 00:09:35,839
dimensions that have their own symbols

00:09:33,740 --> 00:09:38,690
like Hertz Newton Pascal Joule

00:09:35,839 --> 00:09:44,329
they can be either expressed this way or

00:09:38,690 --> 00:09:50,120
in terms of the base unit here yet or in

00:09:44,329 --> 00:09:51,589
terms of different units what's the

00:09:50,120 --> 00:09:53,959
mission analysis the mission analysis is

00:09:51,589 --> 00:09:57,019
basically analyzing that's such an

00:09:53,959 --> 00:10:00,290
equation and the data provided in the

00:09:57,019 --> 00:10:04,070
words Joule per second and all other

00:10:00,290 --> 00:10:07,069
variations it's exactly the same so you

00:10:04,070 --> 00:10:09,110
can easily add them subtract them or

00:10:07,069 --> 00:10:14,240
maybe do some multiplication division

00:10:09,110 --> 00:10:17,690
operation to get another dimension what

00:10:14,240 --> 00:10:20,060
you would like to have is treating unit

00:10:17,690 --> 00:10:23,089
like a typical integrals the because

00:10:20,060 --> 00:10:25,819
colors just to divide them and have the

00:10:23,089 --> 00:10:27,290
same unit divided by the value you'd

00:10:25,819 --> 00:10:29,089
like to have a conversion between the

00:10:27,290 --> 00:10:32,540
same same dimension but different units

00:10:29,089 --> 00:10:34,910
like one hour is 3600 seconds you know

00:10:32,540 --> 00:10:38,870
this from from cron already and the same

00:10:34,910 --> 00:10:41,120
for work for the lamp for example we can

00:10:38,870 --> 00:10:43,910
also want to convert dimensions like one

00:10:41,120 --> 00:10:47,139
kilometer per one second is 1000 meters

00:10:43,910 --> 00:10:50,000
per second or two kilometers per hour

00:10:47,139 --> 00:10:55,339
and two hours will give us a distance of

00:10:50,000 --> 00:10:57,019
four kilometers or if we will go for two

00:10:55,339 --> 00:11:00,350
kilometers with two key meters per hour

00:10:57,019 --> 00:11:02,630
will it will take us one hour is if we

00:11:00,350 --> 00:11:06,050
do something 1000 times per second is 1

00:11:02,630 --> 00:11:07,399
kilo Hertz or if you are dividing 10

00:11:06,050 --> 00:11:11,420
kilometres by five kilometres

00:11:07,399 --> 00:11:14,740
it's justice color to so this actually

00:11:11,420 --> 00:11:16,990
dimension as result yes

00:11:14,740 --> 00:11:21,550
has to be supported by the unis library

00:11:16,990 --> 00:11:24,550
in order to work correctly besides that

00:11:21,550 --> 00:11:27,660
we also have those SI prefixes but you

00:11:24,550 --> 00:11:31,350
know for example from to the ratio and

00:11:27,660 --> 00:11:34,149
nearly every unit can be prefixed with

00:11:31,350 --> 00:11:36,370
such an SI prefix of course not for

00:11:34,149 --> 00:11:42,220
every it has says but but theoretically

00:11:36,370 --> 00:11:45,850
it can and what does it end on si yes

00:11:42,220 --> 00:11:52,060
there are more systems we have customary

00:11:45,850 --> 00:11:54,040
unit we really need any more so what the

00:11:52,060 --> 00:11:57,070
current system current state on the

00:11:54,040 --> 00:11:59,800
market so a quick review of what we have

00:11:57,070 --> 00:12:01,930
right now as the example we'll use the

00:11:59,800 --> 00:12:04,540
simplest possible function that we just

00:12:01,930 --> 00:12:07,839
calculate the average speed we want to

00:12:04,540 --> 00:12:12,180
provide length and time to the function

00:12:07,839 --> 00:12:12,180
and get velocity go by simple division

00:12:12,750 --> 00:12:17,920
so for example I want to provide average

00:12:15,730 --> 00:12:20,680
speed in kilometers and hours and get

00:12:17,920 --> 00:12:23,770
the speed in chemitest per hour like I

00:12:20,680 --> 00:12:25,270
would do if doubles yes if I provide

00:12:23,770 --> 00:12:28,690
miles and hours I would like to have my

00:12:25,270 --> 00:12:31,709
spare hours like I would do double if I

00:12:28,690 --> 00:12:34,089
would write this by my help by myself I

00:12:31,709 --> 00:12:37,029
want to have additionally compile time

00:12:34,089 --> 00:12:38,709
safety to make sure it's correct I would

00:12:37,029 --> 00:12:41,079
like to have support for multiple units

00:12:38,709 --> 00:12:43,540
and prefixes and of course as I said

00:12:41,079 --> 00:12:46,800
there should be no runtime overhead so

00:12:43,540 --> 00:12:46,800
the same as I will do with double

00:12:51,230 --> 00:12:58,670
as an example here I would provide a

00:12:54,260 --> 00:13:02,000
boost units and the a bit different

00:12:58,670 --> 00:13:03,560
library from Nick hothouse that provides

00:13:02,000 --> 00:13:06,709
a bit different approach to to the

00:13:03,560 --> 00:13:08,300
design there of course more but today we

00:13:06,709 --> 00:13:11,870
don't we have limited scope and at the

00:13:08,300 --> 00:13:14,089
time so we'll just look into those let's

00:13:11,870 --> 00:13:16,370
also put chrono from Cortina that

00:13:14,089 --> 00:13:18,200
basically wish probably I think we

00:13:16,370 --> 00:13:20,899
should based on because this is standard

00:13:18,200 --> 00:13:24,980
proven standard in the industry so so

00:13:20,899 --> 00:13:26,839
it's good to work on this one so let's

00:13:24,980 --> 00:13:28,579
start with boost units it's not that

00:13:26,839 --> 00:13:30,670
easy actually if you think that you can

00:13:28,579 --> 00:13:32,660
include one header only you are wrong

00:13:30,670 --> 00:13:33,950
you can include a lot of them and

00:13:32,660 --> 00:13:36,110
sometimes it's not easy to figure out

00:13:33,950 --> 00:13:37,519
which header has to be have to be

00:13:36,110 --> 00:13:42,440
included because code for example

00:13:37,519 --> 00:13:44,959
compass but doesn't link there is a lot

00:13:42,440 --> 00:13:47,089
of support in boost units for many many

00:13:44,959 --> 00:13:48,470
different systems and units but actually

00:13:47,089 --> 00:13:50,089
it turned out that you will to write

00:13:48,470 --> 00:13:51,950
even something simple as a very speed

00:13:50,089 --> 00:13:53,660
there is not enough types for you

00:13:51,950 --> 00:13:55,850
provided you have to try to custom type

00:13:53,660 --> 00:13:59,839
like here to fight your own kilometer

00:13:55,850 --> 00:14:01,370
base you need type that you can provide

00:13:59,839 --> 00:14:03,260
your own length in kilometers you can

00:14:01,370 --> 00:14:08,990
provide your length in miles and so on

00:14:03,260 --> 00:14:11,810
and also for the time so this is really

00:14:08,990 --> 00:14:13,839
simple stuff and you have to do it by

00:14:11,810 --> 00:14:16,820
yourself

00:14:13,839 --> 00:14:19,700
so let's implement this one we have a

00:14:16,820 --> 00:14:22,730
very speed that takes boost quantity of

00:14:19,700 --> 00:14:23,930
length and boosts quantity of time and

00:14:22,730 --> 00:14:30,589
it returns the boost quantity of

00:14:23,930 --> 00:14:31,630
velocity we can provide the devalued 220

00:14:30,589 --> 00:14:35,810
kilometers

00:14:31,630 --> 00:14:40,459
notice the multiply syntax here and two

00:14:35,810 --> 00:14:43,100
hours as we have possibly defined

00:14:40,459 --> 00:14:47,089
kilometer per hour and we can cast it to

00:14:43,100 --> 00:14:52,959
key meters per hour and then print the

00:14:47,089 --> 00:14:52,959
same for miles even though we didn't

00:14:52,990 --> 00:14:57,410
said anything about the units here the

00:14:55,670 --> 00:15:00,470
trick you need this is not a generic

00:14:57,410 --> 00:15:03,620
code there is no information like meter

00:15:00,470 --> 00:15:04,579
mile or kilometer specified here but

00:15:03,620 --> 00:15:06,829
what discotheque

00:15:04,579 --> 00:15:09,049
why does it convert all of the given

00:15:06,829 --> 00:15:11,869
values to the default unit of specific

00:15:09,049 --> 00:15:14,929
dimension so what it does it will take

00:15:11,869 --> 00:15:16,339
our speed in kilometers distance in

00:15:14,929 --> 00:15:18,350
kilometers and we'll cover did this to

00:15:16,339 --> 00:15:22,339
two meters then we'll convert time to

00:15:18,350 --> 00:15:24,709
seconds divided return as the velocity

00:15:22,339 --> 00:15:26,720
in meters per second and then we have to

00:15:24,709 --> 00:15:28,309
once again convert it to meters per hour

00:15:26,720 --> 00:15:29,839
because this is what user wanted because

00:15:28,309 --> 00:15:32,629
this is the input he wanted to provide

00:15:29,839 --> 00:15:35,029
so this is not the same as working on

00:15:32,629 --> 00:15:38,299
doubles yes we have to provide

00:15:35,029 --> 00:15:41,119
additional conversions that take time in

00:15:38,299 --> 00:15:43,459
run time and also because we lose

00:15:41,119 --> 00:15:44,989
precision for on this I have a lot of

00:15:43,459 --> 00:15:46,759
complaints from people working like with

00:15:44,989 --> 00:15:48,379
units like electron volts or similar

00:15:46,759 --> 00:15:50,929
that they have to come convert all the

00:15:48,379 --> 00:15:53,829
time to do it and back and we will boost

00:15:50,929 --> 00:15:57,079
units and for of this for the scale like

00:15:53,829 --> 00:15:58,610
10 to minus 16 or something it's it's a

00:15:57,079 --> 00:16:06,339
really big loss of precision for poor

00:15:58,610 --> 00:16:09,889
double so let's try to fix it

00:16:06,339 --> 00:16:13,669
boost is a meta is a template library is

00:16:09,889 --> 00:16:15,529
the best meta programming support if you

00:16:13,669 --> 00:16:17,929
do something like this quantity of

00:16:15,529 --> 00:16:21,019
length quality of time just template

00:16:17,929 --> 00:16:25,009
parameters it's actually two Dinaric I

00:16:21,019 --> 00:16:26,569
can provide here power and mass and it

00:16:25,009 --> 00:16:30,040
will try to compile this if it can

00:16:26,569 --> 00:16:32,350
divide the result yes so it's not enough

00:16:30,040 --> 00:16:34,759
so let's try to be a bit more specific

00:16:32,350 --> 00:16:36,439
let's provide better status Asian we

00:16:34,759 --> 00:16:39,110
have here length dimension and time

00:16:36,439 --> 00:16:40,429
dimension and also a bunch of other

00:16:39,110 --> 00:16:41,929
parameters that will be getting out of

00:16:40,429 --> 00:16:46,899
the deuced from the from the function

00:16:41,929 --> 00:16:48,679
template still okay but the

00:16:46,899 --> 00:16:50,689
specification the signature of the

00:16:48,679 --> 00:16:52,939
function doesn't tell us anything about

00:16:50,689 --> 00:16:54,799
the retro type so the user don't know

00:16:52,939 --> 00:16:56,569
what this function if it wasn't named a

00:16:54,799 --> 00:16:57,980
very speed by foo you would not know

00:16:56,569 --> 00:17:01,009
anything well what what is the matter

00:16:57,980 --> 00:17:03,079
type here and what to expect it's really

00:17:01,009 --> 00:17:09,620
hard to provide the type of prototype

00:17:03,079 --> 00:17:13,039
here easily so we can try to force it

00:17:09,620 --> 00:17:16,120
like saying that quantity that we should

00:17:13,039 --> 00:17:18,490
return is a device type of helper of

00:17:16,120 --> 00:17:20,740
length and time in specific

00:17:18,490 --> 00:17:22,570
systems that would take kilometers and

00:17:20,740 --> 00:17:24,610
hours but actually what we are doing

00:17:22,570 --> 00:17:26,020
here we are user has to repeat all of

00:17:24,610 --> 00:17:28,810
the logic implemented in the library

00:17:26,020 --> 00:17:30,580
itself this is only the velocity but

00:17:28,810 --> 00:17:32,860
think about something like power but we

00:17:30,580 --> 00:17:35,070
have like five different units to divide

00:17:32,860 --> 00:17:39,000
and multiply it will be a nightmare to

00:17:35,070 --> 00:17:39,000
automate a something something like this

00:17:40,590 --> 00:17:45,280
so for the sake of next examples let's

00:17:43,570 --> 00:17:47,860
use this one because this one is is

00:17:45,280 --> 00:17:52,990
pretty short and do to make slides more

00:17:47,860 --> 00:17:55,660
mortars so next is pretty simple if you

00:17:52,990 --> 00:17:57,610
have this result did this designator we

00:17:55,660 --> 00:17:59,350
can just pass this and it will work yes

00:17:57,610 --> 00:18:00,850
it would be the speedy committed

00:17:59,350 --> 00:18:03,430
parabola we don't have to cast of course

00:18:00,850 --> 00:18:05,110
I would cast it anyway here but for the

00:18:03,430 --> 00:18:08,050
sake of the slides this will print what

00:18:05,110 --> 00:18:11,110
you want and the same also this will

00:18:08,050 --> 00:18:13,810
work if you don't want to work with

00:18:11,110 --> 00:18:15,250
combat I provided parameters you can

00:18:13,810 --> 00:18:16,660
provide the variables of course I also

00:18:15,250 --> 00:18:19,180
provided compile time but you can

00:18:16,660 --> 00:18:21,490
provide a and B here and it will just

00:18:19,180 --> 00:18:26,560
work with variables and this is how it

00:18:21,490 --> 00:18:31,630
looks with boost units so the benefits

00:18:26,560 --> 00:18:33,640
of using boost units first of all is the

00:18:31,630 --> 00:18:35,200
widest adoption it has widest adoption

00:18:33,640 --> 00:18:36,910
in the in the industry so it's pretty

00:18:35,200 --> 00:18:39,400
simple and pretty easy to add it to your

00:18:36,910 --> 00:18:41,590
production code it has wide range of

00:18:39,400 --> 00:18:43,630
systems and base units provided it's

00:18:41,590 --> 00:18:47,440
highly flexible and extensive it has a

00:18:43,630 --> 00:18:49,630
biggest accessibility options and it

00:18:47,440 --> 00:18:53,890
actually has cause expert because it was

00:18:49,630 --> 00:18:57,040
added after C++ 11 and content type can

00:18:53,890 --> 00:18:59,740
use any number like type so so the dart

00:18:57,040 --> 00:19:01,420
presentation that can be specified even

00:18:59,740 --> 00:19:04,150
though a Judah's contact is still pretty

00:19:01,420 --> 00:19:09,610
C++ 11 design it can be realized on

00:19:04,150 --> 00:19:13,030
macros and boost ampere and many people

00:19:09,610 --> 00:19:15,460
coming to me with feedback said that if

00:19:13,030 --> 00:19:17,440
you are not an expert in C++ and not an

00:19:15,460 --> 00:19:19,030
expert in physical units it's not that

00:19:17,440 --> 00:19:21,040
easy to use this library you have to be

00:19:19,030 --> 00:19:24,190
expert in both in order to be able to

00:19:21,040 --> 00:19:26,910
use it it's not user friendly it's not

00:19:24,190 --> 00:19:26,910
developer friendly

00:19:28,700 --> 00:19:33,470
so let's look into the other library

00:19:31,010 --> 00:19:36,020
from Nicole house this one has only one

00:19:33,470 --> 00:19:39,830
header so it's simple in this case and

00:19:36,020 --> 00:19:42,140
also supports units literals but

00:19:39,830 --> 00:19:44,780
actually this was all I could do

00:19:42,140 --> 00:19:47,690
specify the function so I have to

00:19:44,780 --> 00:19:52,280
provide length and time as template

00:19:47,690 --> 00:19:53,990
parameters what's good is that the

00:19:52,280 --> 00:19:55,760
library provides you type choice to

00:19:53,990 --> 00:19:58,190
verify if actually those parameters are

00:19:55,760 --> 00:19:59,750
length and time but this basically is

00:19:58,190 --> 00:20:01,250
the implementation detail not the

00:19:59,750 --> 00:20:03,890
signature of the author of the function

00:20:01,250 --> 00:20:09,550
so you can type right here vector is

00:20:03,890 --> 00:20:09,550
drink and it will try to compile it yes

00:20:10,270 --> 00:20:15,590
and I wasn't able to provide any better

00:20:13,610 --> 00:20:17,990
partial specialization that's because

00:20:15,590 --> 00:20:19,430
the design is inherited in such a way

00:20:17,990 --> 00:20:21,200
that you have something like a meter

00:20:19,430 --> 00:20:23,870
this is the like a base unit of the of

00:20:21,200 --> 00:20:27,220
the of the dimension and actually

00:20:23,870 --> 00:20:30,380
derived units are constructed by nesting

00:20:27,220 --> 00:20:33,650
other units so you don't know exactly

00:20:30,380 --> 00:20:35,810
where the component called unique

00:20:33,650 --> 00:20:37,910
category length unit will be put in the

00:20:35,810 --> 00:20:40,100
Tampa specialization instantiation

00:20:37,910 --> 00:20:42,170
because it can be in the first level or

00:20:40,100 --> 00:20:44,300
second investing level or third second

00:20:42,170 --> 00:20:45,710
elastic level so it's not not that easy

00:20:44,300 --> 00:20:49,040
to top partial specialize this template

00:20:45,710 --> 00:20:53,140
of course you can use those type traits

00:20:49,040 --> 00:20:55,160
and do spin it within a belief yes but

00:20:53,140 --> 00:20:56,840
consider doing this for every function

00:20:55,160 --> 00:20:59,300
you are doing in your code for

00:20:56,840 --> 00:21:01,520
calculations yes it's too time-consuming

00:20:59,300 --> 00:21:06,880
is too complicated probably no one does

00:21:01,520 --> 00:21:09,400
it so coming back to this by example

00:21:06,880 --> 00:21:12,830
basically what you can do a few deals

00:21:09,400 --> 00:21:15,740
this this also works with miles so this

00:21:12,830 --> 00:21:19,970
is simple and usage with variables also

00:21:15,740 --> 00:21:22,370
is simple in this case however notice

00:21:19,970 --> 00:21:26,300
distant that like for example you need

00:21:22,370 --> 00:21:28,730
time hour or units lamb kilometer a year

00:21:26,300 --> 00:21:31,370
ago I was this considering something

00:21:28,730 --> 00:21:34,190
similar like this and I went to water

00:21:31,370 --> 00:21:36,380
brown to ask him for feedback because he

00:21:34,190 --> 00:21:38,360
is working on the ratio and physically

00:21:36,380 --> 00:21:40,970
sleep area for longer time already this

00:21:38,360 --> 00:21:42,330
is what what he said meter is a unit not

00:21:40,970 --> 00:21:45,059
a quantity

00:21:42,330 --> 00:21:46,889
you shouldn't write meter free it's not

00:21:45,059 --> 00:21:52,139
the quantity is that's a unit of the

00:21:46,889 --> 00:21:53,190
quantity so this is something to think

00:21:52,139 --> 00:21:56,459
about

00:21:53,190 --> 00:22:01,009
during the design of the library so once

00:21:56,459 --> 00:22:01,009
again present comes single color file

00:22:01,969 --> 00:22:10,589
conversions are ratios at compile time

00:22:06,080 --> 00:22:12,989
UDS support it's not possible to extent

00:22:10,589 --> 00:22:15,709
with our base units per compile time

00:22:12,989 --> 00:22:19,079
error messages as you would see later on

00:22:15,709 --> 00:22:20,849
and yeah there's no types representing

00:22:19,079 --> 00:22:26,009
dimensions quantities everything is

00:22:20,849 --> 00:22:27,629
units so this is the current design and

00:22:26,009 --> 00:22:30,839
what are the issues from the user

00:22:27,629 --> 00:22:32,669
perspective about this design let's see

00:22:30,839 --> 00:22:34,979
a simple example from the students like

00:22:32,669 --> 00:22:38,190
we have quantity line and we just want

00:22:34,979 --> 00:22:40,109
to assign the to it kilometers yes

00:22:38,190 --> 00:22:43,139
SI unit SI unit everything should go

00:22:40,109 --> 00:22:45,749
fine if you try to compile this you get

00:22:43,139 --> 00:22:47,940
an error this is the first line of their

00:22:45,749 --> 00:22:50,429
areas there there is more this is only

00:22:47,940 --> 00:22:54,119
the first line this is the most

00:22:50,429 --> 00:22:57,450
important line do you know what was the

00:22:54,119 --> 00:23:03,149
problem here trying to assign kilometer

00:22:57,450 --> 00:23:05,039
to asylum this is a long one yes but

00:23:03,149 --> 00:23:06,389
this is DC DC maybe is wrong track is

00:23:05,039 --> 00:23:11,009
better because it provides a shorter

00:23:06,389 --> 00:23:15,469
thanks yes see let's see clock it's

00:23:11,009 --> 00:23:17,849
shorter for sure but still it probably

00:23:15,469 --> 00:23:24,089
it's really hard on is that what happens

00:23:17,849 --> 00:23:27,019
here and what happens here is that we

00:23:24,089 --> 00:23:31,739
have here the compensation you

00:23:27,019 --> 00:23:32,969
capitalization is less forgiving and it

00:23:31,739 --> 00:23:39,149
doesn't allow us to do implicit

00:23:32,969 --> 00:23:41,399
conversions sorry it allows us implicit

00:23:39,149 --> 00:23:43,739
conversions yes but actually there is a

00:23:41,399 --> 00:23:46,139
bit contractors so we have to use the

00:23:43,739 --> 00:23:50,549
value in translation here very keen

00:23:46,139 --> 00:23:51,690
citation so what it means is that both

00:23:50,549 --> 00:23:54,389
units does it allows implicit

00:23:51,690 --> 00:23:56,160
conversions even for non track editing

00:23:54,389 --> 00:23:57,420
or non allowing save

00:23:56,160 --> 00:23:59,280
conversions like from kilometers to

00:23:57,420 --> 00:24:00,420
meters of course doing this vice-versa

00:23:59,280 --> 00:24:01,890
would not be safe and you should write

00:24:00,420 --> 00:24:04,860
like quantity caste or something like

00:24:01,890 --> 00:24:06,330
this or explicit contractor but for a

00:24:04,860 --> 00:24:07,860
piece of construction like this one from

00:24:06,330 --> 00:24:09,390
kilometers to meters like from hours to

00:24:07,860 --> 00:24:12,390
seconds we used to

00:24:09,390 --> 00:24:15,660
thanks to ratio our sari or your

00:24:12,390 --> 00:24:17,370
creation - - - just read it it should

00:24:15,660 --> 00:24:20,640
work just fine without any explicit

00:24:17,370 --> 00:24:22,680
constructors or all castes yes because

00:24:20,640 --> 00:24:26,310
it's possible to check during compile

00:24:22,680 --> 00:24:31,920
time and make sure it will not truncate

00:24:26,310 --> 00:24:35,930
not narrow the bar you so let's right

00:24:31,920 --> 00:24:39,420
now work with this other example and

00:24:35,930 --> 00:24:41,520
make a mistake in the in the calculation

00:24:39,420 --> 00:24:45,270
so so we are not returning velocity

00:24:41,520 --> 00:24:46,590
anymore yes it was a long calculation we

00:24:45,270 --> 00:24:50,480
did a mistake and we want to make sure

00:24:46,590 --> 00:24:52,860
find out what's wrong this is there're

00:24:50,480 --> 00:24:54,870
if you did notice notice those three

00:24:52,860 --> 00:24:57,110
dots at the end this is not the end of

00:24:54,870 --> 00:25:04,980
the third line although the first line

00:24:57,110 --> 00:25:07,050
this is the end of it promise really

00:25:04,980 --> 00:25:10,610
hard to find out if this function was

00:25:07,050 --> 00:25:10,610
like 100 lines what's wrong

00:25:11,930 --> 00:25:15,150
but again

00:25:13,320 --> 00:25:17,160
clonk is better try produces shorter

00:25:15,150 --> 00:25:20,780
messages yes we learnt line because of

00:25:17,160 --> 00:25:24,530
the shorter error messages this is clock

00:25:20,780 --> 00:25:24,530
do you know what happened here

00:25:27,750 --> 00:25:36,299
it's really short something super hairy

00:25:33,120 --> 00:25:42,059
say this actually is not better because

00:25:36,299 --> 00:25:45,860
there is no context here so let's try

00:25:42,059 --> 00:25:50,340
the other example with the other library

00:25:45,860 --> 00:25:51,360
the same error the same problem we have

00:25:50,340 --> 00:25:52,860
something different we don't have

00:25:51,360 --> 00:25:56,490
problem with the day with the template

00:25:52,860 --> 00:25:58,679
we have static Castle it's better we

00:25:56,490 --> 00:26:03,299
know that units are not compatible but

00:25:58,679 --> 00:26:05,190
which units no information right now you

00:26:03,299 --> 00:26:06,629
can maybe look into the definition of

00:26:05,190 --> 00:26:07,860
the function to find out but imagine

00:26:06,629 --> 00:26:09,720
that you have like 10 different

00:26:07,860 --> 00:26:11,519
conversions in the function and you have

00:26:09,720 --> 00:26:12,750
10 10 different types and then it's

00:26:11,519 --> 00:26:14,639
really hard to find out what's this

00:26:12,750 --> 00:26:18,450
first time third type based on the

00:26:14,639 --> 00:26:21,629
function argument yes so static assert

00:26:18,450 --> 00:26:23,929
are often not the best solution to they

00:26:21,629 --> 00:26:26,879
lack the context in some compilers and

00:26:23,929 --> 00:26:29,039
also they do not if you has developed

00:26:26,879 --> 00:26:30,779
resolution process there are like quite

00:26:29,039 --> 00:26:32,610
a few plantation they can assert in the

00:26:30,779 --> 00:26:34,230
code rather than other than the

00:26:32,610 --> 00:26:36,299
interface of the order of the deep of

00:26:34,230 --> 00:26:40,440
the function like the interface to

00:26:36,299 --> 00:26:42,389
communicate contract to the user client

00:26:40,440 --> 00:26:44,909
X Y here is better because clark's

00:26:42,389 --> 00:26:48,809
provides us also the context of this

00:26:44,909 --> 00:26:55,740
trade in the static assert so we know

00:26:48,809 --> 00:26:57,179
what's happened do we so this is

00:26:55,740 --> 00:27:00,299
different the design of the library a

00:26:57,179 --> 00:27:03,990
bit different approach we will see more

00:27:00,299 --> 00:27:05,669
problems later on yeah so I would claim

00:27:03,990 --> 00:27:07,769
that for this specific library for

00:27:05,669 --> 00:27:10,769
physical news library we have to rethink

00:27:07,769 --> 00:27:16,169
how we are doing our template

00:27:10,769 --> 00:27:18,029
metaprogramming this X Y the subject the

00:27:16,169 --> 00:27:19,230
title of my talk from tomorrow so if

00:27:18,029 --> 00:27:21,779
you're interested in implantation

00:27:19,230 --> 00:27:23,879
details how do how to improve or try to

00:27:21,779 --> 00:27:26,850
improve templates you are invited to

00:27:23,879 --> 00:27:27,929
come at my talk at 9 a.m. tomorrow so

00:27:26,850 --> 00:27:29,399
they will scope more on the user

00:27:27,929 --> 00:27:32,159
interface and use it rather than on

00:27:29,399 --> 00:27:33,750
implantation tricks so if you are

00:27:32,159 --> 00:27:38,210
interested in development in developing

00:27:33,750 --> 00:27:38,210
such stuff come tomorrow to my second

00:27:38,700 --> 00:27:41,730
so for most of the libraries we have

00:27:41,130 --> 00:27:43,680
right now

00:27:41,730 --> 00:27:46,620
temperamental programming libraries the

00:27:43,680 --> 00:27:49,140
compiled computer errors are are how

00:27:46,620 --> 00:27:50,970
often do you do you break like vector or

00:27:49,140 --> 00:27:53,760
string to have a compile time error is

00:27:50,970 --> 00:27:55,200
probably not too often so that's not a

00:27:53,760 --> 00:27:56,520
problem you can make any tricks there

00:27:55,200 --> 00:27:59,070
and probably tour not if you has the

00:27:56,520 --> 00:28:02,100
users but all purpose of having this

00:27:59,070 --> 00:28:05,460
library is to generate like 40 to 50

00:28:02,100 --> 00:28:06,750
errors per day for an engineer because

00:28:05,460 --> 00:28:09,060
this is what like this error is intended

00:28:06,750 --> 00:28:11,100
to so to make sure that the calculations

00:28:09,060 --> 00:28:13,800
are correct and it will generate errors

00:28:11,100 --> 00:28:15,540
every day many of them and user have to

00:28:13,800 --> 00:28:20,460
work with them and then it has to be

00:28:15,540 --> 00:28:22,620
user friendly so we have to rethink how

00:28:20,460 --> 00:28:27,720
we are doing C++ templates for for this

00:28:22,620 --> 00:28:29,610
and maybe similar libraries and when I

00:28:27,720 --> 00:28:32,460
see talk about user experience it's not

00:28:29,610 --> 00:28:34,260
just about things like compiler

00:28:32,460 --> 00:28:38,640
completion error it's also about

00:28:34,260 --> 00:28:41,400
debugging for example this is my ID I

00:28:38,640 --> 00:28:44,280
try to be back all the time there's no

00:28:41,400 --> 00:28:47,840
problem here the same function when I

00:28:44,280 --> 00:28:51,230
enter it this is what the bugger says it

00:28:47,840 --> 00:28:54,150
says quantity of boost units Dabu

00:28:51,230 --> 00:28:57,780
quantity of boost we need double do I

00:28:54,150 --> 00:29:01,950
really have the same type here this is

00:28:57,780 --> 00:29:10,590
what what ID client yes it was lost in

00:29:01,950 --> 00:29:12,150
the long time so I tried to dB do you

00:29:10,590 --> 00:29:18,440
know what is the type of the personal

00:29:12,150 --> 00:29:22,580
secretary human it's not that simple

00:29:18,440 --> 00:29:24,480
also P type then there is even bigger

00:29:22,580 --> 00:29:26,580
definition because it turns out that

00:29:24,480 --> 00:29:28,020
this one is smarter as for example it

00:29:26,580 --> 00:29:30,360
skips like default parameters of

00:29:28,020 --> 00:29:35,400
templates and if we type you if you have

00:29:30,360 --> 00:29:39,890
everything so it's not the best user

00:29:35,400 --> 00:29:45,270
experience to work with second library

00:29:39,890 --> 00:29:50,450
similar the ID is lost it was exactly

00:29:45,270 --> 00:29:50,450
the same type for both arguments

00:29:50,790 --> 00:29:56,080
this is the break point we have a lot of

00:29:53,820 --> 00:29:57,760
studios to the ratios to the ratio to

00:29:56,080 --> 00:29:59,560
the ratio to ratio and you have to find

00:29:57,760 --> 00:30:01,240
out what's the unit here you have to

00:29:59,560 --> 00:30:02,620
remember which one is which is length

00:30:01,240 --> 00:30:05,020
which is time which is which which is

00:30:02,620 --> 00:30:13,120
mass and make all the calculations by

00:30:05,020 --> 00:30:16,120
yourself and be like another issues here

00:30:13,120 --> 00:30:18,430
is the overusing of macros in the user

00:30:16,120 --> 00:30:20,380
interface I don't care about macros in

00:30:18,430 --> 00:30:21,610
the implementation but if the user has

00:30:20,380 --> 00:30:22,980
to use macros in order to work with the

00:30:21,610 --> 00:30:25,480
library there is something wrong

00:30:22,980 --> 00:30:27,610
maybe not for boost units or or other

00:30:25,480 --> 00:30:29,260
libraries but if I would go to Titus and

00:30:27,610 --> 00:30:37,230
say that I want to standardize it as a

00:30:29,260 --> 00:30:37,230
standard library yeah you hear hip motor

00:30:38,910 --> 00:30:46,210
the same for the other library also I

00:30:43,540 --> 00:30:47,920
would assume that the labor that you

00:30:46,210 --> 00:30:49,570
would like to have in our standard

00:30:47,920 --> 00:30:51,820
library would like we would like to make

00:30:49,570 --> 00:30:53,260
it easy to extend because probably will

00:30:51,820 --> 00:30:54,640
not be able to provide all the use cases

00:30:53,260 --> 00:30:57,490
of the users will probably complete

00:30:54,640 --> 00:30:59,680
scope on the on the Moulton Eric and

00:30:57,490 --> 00:31:02,740
most common needs and at least for the

00:30:59,680 --> 00:31:05,440
beginning so we want to be able to

00:31:02,740 --> 00:31:06,790
extend them easily I think you have

00:31:05,440 --> 00:31:09,460
dimension in most of the libraries is

00:31:06,790 --> 00:31:11,230
simple but I think based ones like for

00:31:09,460 --> 00:31:14,170
example would like to extend it with for

00:31:11,230 --> 00:31:16,840
example bits to work with bit rates and

00:31:14,170 --> 00:31:19,510
and and information like ID units rather

00:31:16,840 --> 00:31:24,760
than only with SI units it's really hard

00:31:19,510 --> 00:31:26,020
in most cases in both units the base

00:31:24,760 --> 00:31:29,410
dimension is identified by a unique

00:31:26,020 --> 00:31:31,690
number negative values are reserved for

00:31:29,410 --> 00:31:35,080
for the library itself positive are for

00:31:31,690 --> 00:31:37,120
the users so 30 get simple but let's

00:31:35,080 --> 00:31:38,950
consider two vendors extending library

00:31:37,120 --> 00:31:41,710
and then third vendor that was to use

00:31:38,950 --> 00:31:44,170
both of them probably all those who

00:31:41,710 --> 00:31:47,920
start with one yes and you have a

00:31:44,170 --> 00:31:49,600
collision but you can like tweak the

00:31:47,920 --> 00:31:53,410
libraries and it may be it with at some

00:31:49,600 --> 00:31:56,440
point will work and let's see the other

00:31:53,410 --> 00:31:58,630
library that the library is using

00:31:56,440 --> 00:32:00,970
another common common approach here in

00:31:58,630 --> 00:32:04,310
this domain and just has the list of all

00:32:00,970 --> 00:32:07,280
of the base you need as a template

00:32:04,310 --> 00:32:10,400
meter of the most based framework class

00:32:07,280 --> 00:32:12,950
here so if you would like to dare to add

00:32:10,400 --> 00:32:15,710
one more line here you'd have to rewrite

00:32:12,950 --> 00:32:17,480
all of the library code all of the users

00:32:15,710 --> 00:32:19,310
code and extension from different

00:32:17,480 --> 00:32:24,260
vendors in order to add your own boost

00:32:19,310 --> 00:32:26,540
to it your custom unit here so I would

00:32:24,260 --> 00:32:32,120
say that it's impossible to add anything

00:32:26,540 --> 00:32:34,430
here logistically so let's think how we

00:32:32,120 --> 00:32:35,780
can address that I don't say that my

00:32:34,430 --> 00:32:37,490
library is the best one the my library

00:32:35,780 --> 00:32:39,560
should be the one standardized I just

00:32:37,490 --> 00:32:42,380
provide some hints how to solve those

00:32:39,560 --> 00:32:45,020
issues here and we can even start from

00:32:42,380 --> 00:32:46,520
scratch of different library does to

00:32:45,020 --> 00:32:48,260
make it happen because I care to make it

00:32:46,520 --> 00:32:51,950
happen I don't care if it's my library

00:32:48,260 --> 00:32:53,990
or other solution if you want you can go

00:32:51,950 --> 00:32:58,130
to to github and find if I find this one

00:32:53,990 --> 00:33:00,080
there and it's still working progress

00:32:58,130 --> 00:33:02,780
because I'm still working on the on the

00:33:00,080 --> 00:33:05,480
design I will talk about this for the

00:33:02,780 --> 00:33:07,310
first time in any DWG in Belfast I'll

00:33:05,480 --> 00:33:08,890
expect some some feedback I expect maybe

00:33:07,310 --> 00:33:11,930
some design changes after the feedback

00:33:08,890 --> 00:33:13,970
so it's still not stable yes but I

00:33:11,930 --> 00:33:15,950
encourage you to go try and twenty

00:33:13,970 --> 00:33:18,560
feedback and requirements or maybe

00:33:15,950 --> 00:33:23,960
contribute if you like in order to make

00:33:18,560 --> 00:33:26,420
it happen so what are the comments that

00:33:23,960 --> 00:33:28,520
I signed by myself the first and most

00:33:26,420 --> 00:33:30,080
important is user experience this

00:33:28,520 --> 00:33:33,050
library has to be easy to use for the

00:33:30,080 --> 00:33:35,150
for the users it has to provide good

00:33:33,050 --> 00:33:39,500
compiler errors it has to be friendly

00:33:35,150 --> 00:33:41,690
for debug safe and performance of course

00:33:39,500 --> 00:33:43,670
it has to provide strong types it has to

00:33:41,690 --> 00:33:46,280
support template metaprogramming to

00:33:43,670 --> 00:33:48,260
provide like different to specify it

00:33:46,280 --> 00:33:49,820
like dimension but not specific unit

00:33:48,260 --> 00:33:52,310
because you have to work with different

00:33:49,820 --> 00:33:53,960
unit for the dimension and of course we

00:33:52,310 --> 00:33:56,510
have to cause X all of the things in

00:33:53,960 --> 00:33:58,330
order to provide as fast and as robust

00:33:56,510 --> 00:34:01,670
solution as possible

00:33:58,330 --> 00:34:05,000
no macros in the user interface because

00:34:01,670 --> 00:34:09,010
otherwise I will be screwed in in the

00:34:05,000 --> 00:34:12,140
ISO committee no external dependencies

00:34:09,010 --> 00:34:13,820
right now I am depending on some library

00:34:12,140 --> 00:34:15,610
from Kasey Carter Carter because there

00:34:13,820 --> 00:34:18,240
is no implantation of stood contracts

00:34:15,610 --> 00:34:20,940
concepts sorry two concepts

00:34:18,240 --> 00:34:22,610
but C++ 20 will have it and the

00:34:20,940 --> 00:34:26,790
dependency will be lost

00:34:22,610 --> 00:34:28,550
easy to extend and possibly to

00:34:26,790 --> 00:34:31,710
standardized as a part of freestanding

00:34:28,550 --> 00:34:38,159
in modern understanding of freestanding

00:34:31,710 --> 00:34:40,110
of C++ standard library so coming back

00:34:38,159 --> 00:34:42,179
to a toy example this is how you can do

00:34:40,110 --> 00:34:44,600
it with my library if you're not

00:34:42,179 --> 00:34:47,610
familiar this is the new syntax for for

00:34:44,600 --> 00:34:50,490
templates this actual generic function

00:34:47,610 --> 00:34:52,409
from C++ 20 so it's like generic lambda

00:34:50,490 --> 00:34:54,030
but every time every time you see in

00:34:52,409 --> 00:34:56,250
lambda it means there is a template yes

00:34:54,030 --> 00:34:58,590
the same is for for functions the C

00:34:56,250 --> 00:35:00,450
generic function and it's C++ 20

00:34:58,590 --> 00:35:02,880
everywhere everywhere ready nearly

00:35:00,450 --> 00:35:06,840
everywhere where we can put Auto you can

00:35:02,880 --> 00:35:08,100
constrain it with concept so these are

00:35:06,840 --> 00:35:14,250
the constraints for out of the news

00:35:08,100 --> 00:35:17,180
types velocity length and time yes this

00:35:14,250 --> 00:35:19,770
is this actually what was mandated here

00:35:17,180 --> 00:35:22,290
okay so the question was do we need to

00:35:19,770 --> 00:35:25,530
put both the the name of the construct a

00:35:22,290 --> 00:35:29,340
concept and auto yes we have to provide

00:35:25,530 --> 00:35:30,990
provide both of the keywords here this

00:35:29,340 --> 00:35:37,950
is how what was it decided by the

00:35:30,990 --> 00:35:42,030
committee yeah and you can provide

00:35:37,950 --> 00:35:45,810
average speed 220 and 2 hours and get

00:35:42,030 --> 00:35:47,520
something that's a velocity if you can

00:35:45,810 --> 00:35:49,550
actually verify that the value start

00:35:47,520 --> 00:35:52,320
here is 110 so there were no

00:35:49,550 --> 00:35:54,330
intermediate conversions done like in

00:35:52,320 --> 00:35:56,550
case of booze in it but of course if you

00:35:54,330 --> 00:35:58,440
want to pass it to something that that

00:35:56,550 --> 00:36:00,810
means like in integer or Dabu

00:35:58,440 --> 00:36:02,609
rather than a strong type it's always

00:36:00,810 --> 00:36:05,040
better to do a quantity cut like you we

00:36:02,609 --> 00:36:06,359
have also the duration cast in chrono to

00:36:05,040 --> 00:36:08,880
make sure that you want to print a

00:36:06,359 --> 00:36:13,260
correct value or provided to a C style

00:36:08,880 --> 00:36:14,480
interface with a correct unit and the

00:36:13,260 --> 00:36:17,359
same for miles

00:36:14,480 --> 00:36:22,290
yes the same plantation as you can see

00:36:17,359 --> 00:36:24,600
basically I provides us correct values

00:36:22,290 --> 00:36:26,700
we don't need to cast actual here but

00:36:24,600 --> 00:36:29,280
the causes just to make it clear because

00:36:26,700 --> 00:36:31,470
this function can be refactored and it

00:36:29,280 --> 00:36:32,069
may work differently in 1/4 you want to

00:36:31,470 --> 00:36:37,440
always have

00:36:32,069 --> 00:36:40,829
same and the good result at the end also

00:36:37,440 --> 00:36:42,930
if you put this proof compiler and

00:36:40,829 --> 00:36:44,160
optimizer you will find out that this

00:36:42,930 --> 00:36:47,190
code will generate exactly the same

00:36:44,160 --> 00:36:50,369
binary is working good double there are

00:36:47,190 --> 00:36:51,779
no other intermediate conversions which

00:36:50,369 --> 00:36:58,199
is actually the case for some other

00:36:51,779 --> 00:37:01,369
open-source libraries and you want to

00:36:58,199 --> 00:37:03,839
work with variables it's pretty similar

00:37:01,369 --> 00:37:05,670
you can do quantity caste and name it as

00:37:03,839 --> 00:37:11,249
kilometers per hour and then just print

00:37:05,670 --> 00:37:12,809
it and the same for miles per hour the

00:37:11,249 --> 00:37:15,150
design of my library is pretty simple it

00:37:12,809 --> 00:37:17,789
has like five building blocks it has a

00:37:15,150 --> 00:37:21,569
base dimension that basically defines if

00:37:17,789 --> 00:37:24,170
it's one of those seven SI unit then it

00:37:21,569 --> 00:37:27,119
has exponent so we have basic dimension

00:37:24,170 --> 00:37:29,549
rise to some exponent we have some

00:37:27,119 --> 00:37:31,650
strange dimensions require us fractional

00:37:29,549 --> 00:37:34,910
exponents there is a denominator here

00:37:31,650 --> 00:37:38,819
but in most cases we just use nominator

00:37:34,910 --> 00:37:41,039
and there is a unit dimension that

00:37:38,819 --> 00:37:43,049
basically type lists type list of this

00:37:41,039 --> 00:37:45,809
of those exponents so you have like

00:37:43,049 --> 00:37:47,579
meters to exponent one and seconds to

00:37:45,809 --> 00:37:51,449
exponent minus one to represent the

00:37:47,579 --> 00:37:55,619
velocity there is a unit that takes

00:37:51,449 --> 00:37:57,390
dimension this one and ratio so for

00:37:55,619 --> 00:38:01,549
example for meter it would be 101 and

00:37:57,390 --> 00:38:05,549
for kilometer which would be 1000 and

00:38:01,549 --> 00:38:11,369
quantity is the amount of unit with

00:38:05,549 --> 00:38:16,380
specific representation so by dimension

00:38:11,369 --> 00:38:19,619
in my current penetration is thus simple

00:38:16,380 --> 00:38:21,299
structure name it has operator equal

00:38:19,619 --> 00:38:23,400
suppose operator less in order to be

00:38:21,299 --> 00:38:24,479
able to sort it because it has to

00:38:23,400 --> 00:38:27,900
provide unique and sir table

00:38:24,479 --> 00:38:29,880
compile-time identifier and as an

00:38:27,900 --> 00:38:32,940
example you can provide such constants

00:38:29,880 --> 00:38:36,869
for your unit good that it's really easy

00:38:32,940 --> 00:38:38,489
to extend because names will not collide

00:38:36,869 --> 00:38:40,979
unless you to provide exactly the same

00:38:38,489 --> 00:38:43,400
unit it's not like one and one from

00:38:40,979 --> 00:38:43,400
different vendors

00:38:43,430 --> 00:38:49,150
so if you have collision it just means

00:38:45,800 --> 00:38:49,150
that - under settlement at the same unit

00:38:54,250 --> 00:38:58,690
exponent takes the base dimension

00:38:56,870 --> 00:39:01,690
Lamia - in denominator and just store it

00:38:58,690 --> 00:39:01,690
here

00:39:02,950 --> 00:39:11,410
dementia is a type list it even doesn't

00:39:05,870 --> 00:39:15,710
have any implantation in this case here

00:39:11,410 --> 00:39:17,990
and my velocity for example can be an

00:39:15,710 --> 00:39:20,660
alias to dimension as I said - of length

00:39:17,990 --> 00:39:23,840
2 exponent 1 and time to expire at minus

00:39:20,660 --> 00:39:25,940
1 this solution improves user experience

00:39:23,840 --> 00:39:27,380
because it's the list context only

00:39:25,940 --> 00:39:28,790
what's needed here we don't have those

00:39:27,380 --> 00:39:30,710
ratios there are ratios there are ratio

00:39:28,790 --> 00:39:31,160
0 as you seen in the case of the second

00:39:30,710 --> 00:39:33,800
fibroin

00:39:31,160 --> 00:39:38,600
we analyzed it just has what it what is

00:39:33,800 --> 00:39:40,310
needed to specify specific unit and I

00:39:38,600 --> 00:39:41,600
assume it's pretty easy to understand

00:39:40,310 --> 00:39:48,890
for everyone what's happening here

00:39:41,600 --> 00:39:52,400
because it but actually you have a

00:39:48,890 --> 00:39:55,310
problem here yes so we have two

00:39:52,400 --> 00:39:57,470
operations one meter divided by one

00:39:55,310 --> 00:40:00,020
second and you have two divided by two

00:39:57,470 --> 00:40:03,320
seconds times 1 meter it should be the

00:40:00,020 --> 00:40:05,630
same value the same type yes but the

00:40:03,320 --> 00:40:08,180
order operation is different so how to

00:40:05,630 --> 00:40:10,310
construct this this this type list from

00:40:08,180 --> 00:40:15,050
both of those operations so that would

00:40:10,310 --> 00:40:17,360
be able to compare as equal for this we

00:40:15,050 --> 00:40:18,980
have make dimension helper so you should

00:40:17,360 --> 00:40:20,420
I cry never instantiate the dimension by

00:40:18,980 --> 00:40:22,460
your type is by yourself you should use

00:40:20,420 --> 00:40:25,400
make dimensional hyper that will provide

00:40:22,460 --> 00:40:28,520
unique ordering for for the exponents

00:40:25,400 --> 00:40:29,720
and actually will aggregate exponents of

00:40:28,520 --> 00:40:31,190
the same dimension but different

00:40:29,720 --> 00:40:33,530
exponents so like you have meter and

00:40:31,190 --> 00:40:36,770
meter it will be squared meter or

00:40:33,530 --> 00:40:38,810
eliminate if there's are the same

00:40:36,770 --> 00:40:40,670
dimensions but but opposite exponents

00:40:38,810 --> 00:40:47,360
like you have meter divided by meter

00:40:40,670 --> 00:40:49,760
it's no nothing case so the example

00:40:47,360 --> 00:40:52,220
velocity this is how you create velocity

00:40:49,760 --> 00:40:53,810
make dimension based in line by the type

00:40:52,220 --> 00:40:57,020
you are not using aliases for this one

00:40:53,810 --> 00:41:01,730
and basically the dot is

00:40:57,020 --> 00:41:04,820
dimension by yourself you need and they

00:41:01,730 --> 00:41:07,310
said takes dimension and ratio it

00:41:04,820 --> 00:41:09,710
requires the ratio to be positive and in

00:41:07,310 --> 00:41:12,290
stores the last dimension ratio here as

00:41:09,710 --> 00:41:14,930
an example meter is a unit of length by

00:41:12,290 --> 00:41:17,360
default it's one there are some helpers

00:41:14,930 --> 00:41:18,800
for you to not play with ratio by

00:41:17,360 --> 00:41:22,070
yourself you can twice for example say

00:41:18,800 --> 00:41:24,860
that kilometer is a kilo meter so it

00:41:22,070 --> 00:41:26,330
will provide kilo as a ratio here you

00:41:24,860 --> 00:41:30,710
can also say kilometre per hour is

00:41:26,330 --> 00:41:33,650
direct unit of velocity in units

00:41:30,710 --> 00:41:35,990
kilometer and hour for those dimensions

00:41:33,650 --> 00:41:37,250
that are involved to create velocity so

00:41:35,990 --> 00:41:38,150
it will calculate the ratio for you by

00:41:37,250 --> 00:41:40,430
yourself you don't have to calculate

00:41:38,150 --> 00:41:42,880
that that's what was exactly the

00:41:40,430 --> 00:41:45,590
duration for committed per hour by hand

00:41:42,880 --> 00:41:48,440
those are actually earliest templates

00:41:45,590 --> 00:41:55,720
helpers that will always end up with

00:41:48,440 --> 00:41:55,720
unit type yes

00:41:56,119 --> 00:42:08,479
does the ratio has to be an integer

00:41:59,930 --> 00:42:10,309
you mean we're here actually ratio ratio

00:42:08,479 --> 00:42:11,420
actually is is one of the biggest

00:42:10,309 --> 00:42:14,689
concerns right now on the right now that

00:42:11,420 --> 00:42:16,640
I would like to extend because study

00:42:14,689 --> 00:42:19,099
ratio has this problem that it uses in

00:42:16,640 --> 00:42:21,289
sixty forty eight sixty forty is not

00:42:19,099 --> 00:42:25,809
enough to express things like electron

00:42:21,289 --> 00:42:25,809
volts or work for astronomical units I

00:42:29,049 --> 00:42:33,499
started the discussion or sd-6 lab

00:42:31,390 --> 00:42:38,420
reflector at the six is a numeric group

00:42:33,499 --> 00:42:40,759
to ask if we have in hand the types that

00:42:38,420 --> 00:42:42,259
can represent big integral numbers but

00:42:40,759 --> 00:42:44,809
actually I didn't get much feedback yet

00:42:42,259 --> 00:42:47,150
but I expect to have more discussion on

00:42:44,809 --> 00:42:48,920
the on this in Belfast so it will

00:42:47,150 --> 00:42:50,239
probably change because we have to not

00:42:48,920 --> 00:42:52,479
use the duration I am not using

00:42:50,239 --> 00:42:56,209
acceleration anymore in my information

00:42:52,479 --> 00:42:59,420
because we have to use something else

00:42:56,209 --> 00:43:00,679
anyway I will talk about this a bit more

00:42:59,420 --> 00:43:07,660
tomorrow talking about the performance

00:43:00,679 --> 00:43:07,660
of OB plantations yes

00:43:12,859 --> 00:43:17,869
so the question is in the bottom line

00:43:14,989 --> 00:43:20,239
why did how it knows that this is

00:43:17,869 --> 00:43:21,619
kilometres / hours it knows it from the

00:43:20,239 --> 00:43:24,680
perversity dimension because what's the

00:43:21,619 --> 00:43:26,569
dimension keeps this explicit of typists

00:43:24,680 --> 00:43:28,279
so it basically compares it to the to

00:43:26,569 --> 00:43:31,130
the list of dimensions here in velocity

00:43:28,279 --> 00:43:32,869
and knows that this is Glen this is time

00:43:31,130 --> 00:43:36,130
sees what are the exponents and

00:43:32,869 --> 00:43:36,130
calculate the ratio by itself

00:43:43,610 --> 00:43:49,250
yes so basically the questions about

00:43:45,500 --> 00:43:52,070
absolute temperatures yes temperature is

00:43:49,250 --> 00:43:53,870
a hard problem to solve actually I don't

00:43:52,070 --> 00:43:55,460
have slides for this today

00:43:53,870 --> 00:43:57,290
well yeah I will have let's go to the

00:43:55,460 --> 00:43:59,420
quantity okay because probably this is

00:43:57,290 --> 00:44:00,860
about quantities and I think there will

00:43:59,420 --> 00:44:02,800
be slight after this if not I will

00:44:00,860 --> 00:44:06,590
answer the question

00:44:02,800 --> 00:44:08,720
okay so quantity is the amount amount of

00:44:06,590 --> 00:44:13,220
you need specific specific

00:44:08,720 --> 00:44:15,260
representation interface is very similar

00:44:13,220 --> 00:44:16,850
to what we know from the standard kernel

00:44:15,260 --> 00:44:18,860
duration plus some additional member

00:44:16,850 --> 00:44:20,210
functions first of all we have to

00:44:18,860 --> 00:44:21,950
support pacification of two quantities

00:44:20,210 --> 00:44:24,380
of different dimensions so if you have

00:44:21,950 --> 00:44:26,480
like km/h and our we want to have

00:44:24,380 --> 00:44:27,890
kilometers as a result so you have to

00:44:26,480 --> 00:44:30,230
provide multiplication of different

00:44:27,890 --> 00:44:32,180
quantities of different dimensions we

00:44:30,230 --> 00:44:35,950
have to provide division of those and

00:44:32,180 --> 00:44:38,510
also and duration right now supports the

00:44:35,950 --> 00:44:41,240
quantity divided by this color because

00:44:38,510 --> 00:44:43,460
you can you can divide 10 seconds by 2

00:44:41,240 --> 00:44:45,410
and it's fine but you cannot divide 2 by

00:44:43,460 --> 00:44:47,900
10 seconds because it will not be time

00:44:45,410 --> 00:44:49,370
anymore in for duration so I had to

00:44:47,900 --> 00:44:54,080
provide another function member function

00:44:49,370 --> 00:45:00,640
that will divide this color by the

00:44:54,080 --> 00:45:00,640
quantity also as a feedback from yes

00:45:05,730 --> 00:45:11,590
the question is is the types I'm using

00:45:08,530 --> 00:45:12,970
the same from the chrono no I'm not

00:45:11,590 --> 00:45:15,099
using the duration I have my own

00:45:12,970 --> 00:45:17,830
quantity type it's not at least not

00:45:15,099 --> 00:45:19,750
chrono and also I stated that I'm not

00:45:17,830 --> 00:45:22,510
not using stood ratio anymore because we

00:45:19,750 --> 00:45:24,910
have to replace it and anyway look

00:45:22,510 --> 00:45:26,590
something better but for implantation

00:45:24,910 --> 00:45:28,869
details please can put mortal purple

00:45:26,590 --> 00:45:31,000
today I would like to - yeah those 90

00:45:28,869 --> 00:45:32,710
minute talks on C++ now and actually

00:45:31,000 --> 00:45:33,550
today I have even more material but

00:45:32,710 --> 00:45:35,590
would like to scope on user experience

00:45:33,550 --> 00:45:42,130
here and about implantation tomorrow

00:45:35,590 --> 00:45:44,680
okay another feedback from the users is

00:45:42,130 --> 00:45:48,160
that for some numeric types sometimes

00:45:44,680 --> 00:45:50,230
come on type as a result of operations

00:45:48,160 --> 00:45:51,580
it is not enough because for example

00:45:50,230 --> 00:45:53,290
there are some numerical types that from

00:45:51,580 --> 00:45:55,359
multiple multiplication and division

00:45:53,290 --> 00:46:00,700
will return you a different type because

00:45:55,359 --> 00:46:02,920
they will scale by by themselves so you

00:46:00,700 --> 00:46:04,270
cannot have like one common type that

00:46:02,920 --> 00:46:05,980
will be fine for all of the return types

00:46:04,270 --> 00:46:08,140
you have to just use what actually the

00:46:05,980 --> 00:46:11,830
operation does so I'm not using common

00:46:08,140 --> 00:46:13,240
types for for operators and also added

00:46:11,830 --> 00:46:19,510
some one static function that's really

00:46:13,240 --> 00:46:20,859
not that important here okay so let's

00:46:19,510 --> 00:46:24,670
talk about a bit about the user

00:46:20,859 --> 00:46:26,710
experience we as developers love type a

00:46:24,670 --> 00:46:29,170
yes yes it makes our life much much

00:46:26,710 --> 00:46:31,210
easier think what would happen if we not

00:46:29,170 --> 00:46:34,359
not have type devs or aliases in our

00:46:31,210 --> 00:46:36,780
language how our life would look like it

00:46:34,359 --> 00:46:39,910
would be a disaster to work of this yes

00:46:36,780 --> 00:46:41,530
however temple users are really quickly

00:46:39,910 --> 00:46:45,310
lost during the translation process

00:46:41,530 --> 00:46:48,190
during compilation process as a result

00:46:45,310 --> 00:46:51,000
end users it's not does not have any

00:46:48,190 --> 00:46:54,250
benefit from us we have us as developers

00:46:51,000 --> 00:46:55,780
so as an example we have some aliases

00:46:54,250 --> 00:46:57,400
for velocity and K meter per hour on

00:46:55,780 --> 00:47:00,250
this slide there is not actually how is

00:46:57,400 --> 00:47:03,099
it emitted in my library this is what

00:47:00,250 --> 00:47:08,740
developers is really nice function yes

00:47:03,099 --> 00:47:11,830
and this is what user sees and this is

00:47:08,740 --> 00:47:12,940
actually a problem the products that we

00:47:11,830 --> 00:47:15,089
don't have strong Tyler's in the

00:47:12,940 --> 00:47:18,130
language there were a lot of items

00:47:15,089 --> 00:47:18,730
during class ten years or more to the

00:47:18,130 --> 00:47:21,040
price drop

00:47:18,730 --> 00:47:25,930
we still don't have them and it will

00:47:21,040 --> 00:47:31,570
help a lot here for this I admitted the

00:47:25,930 --> 00:47:34,630
workaround so basically our current is

00:47:31,570 --> 00:47:37,060
that I have the I'm using inheritance

00:47:34,630 --> 00:47:39,310
for this one so I'm using no technically

00:47:37,060 --> 00:47:43,270
I says I'm using inheritance similar to

00:47:39,310 --> 00:47:46,390
strong type devs I will have strong type

00:47:43,270 --> 00:47:48,130
that will not vanish and actually things

00:47:46,390 --> 00:47:50,590
like operator equal equal work because I

00:47:48,130 --> 00:47:51,790
can provide the base type and to be in

00:47:50,590 --> 00:47:53,910
the argument of the function it will

00:47:51,790 --> 00:47:57,010
start work of the derive type

00:47:53,910 --> 00:47:58,600
alternatively too strong type this I do

00:47:57,010 --> 00:48:00,040
not Auto Tech inherit the constructor

00:47:58,600 --> 00:48:01,300
and the same interpreter so I would have

00:48:00,040 --> 00:48:03,040
to rewrite them if the function would be

00:48:01,300 --> 00:48:07,869
not trivial like the class will be not

00:48:03,040 --> 00:48:10,480
non trivial and if member function of

00:48:07,869 --> 00:48:14,820
the base class returns like baseless so

00:48:10,480 --> 00:48:17,109
quantity after the doing the this

00:48:14,820 --> 00:48:18,970
increases here it will not just start

00:48:17,109 --> 00:48:21,070
right on velocity automatically by

00:48:18,970 --> 00:48:22,540
itself and this was one of the

00:48:21,070 --> 00:48:25,210
requirements for the bay for the stroke

00:48:22,540 --> 00:48:30,369
typist that we could return the strong

00:48:25,210 --> 00:48:33,790
type itself instead of the base class so

00:48:30,369 --> 00:48:36,310
it's easy to apply for for really simple

00:48:33,790 --> 00:48:39,810
classes like dimension and unit but

00:48:36,310 --> 00:48:39,810
would be much harder for continue type

00:48:42,390 --> 00:48:51,340
okay so we have one more problem here

00:48:46,200 --> 00:48:53,950
how we can create a velocity from m/s we

00:48:51,340 --> 00:48:56,650
have an operator that will take here the

00:48:53,950 --> 00:49:01,869
length and time and you want to create

00:48:56,650 --> 00:49:03,430
add child class velocity from it it's

00:49:01,869 --> 00:49:05,710
easy to put to create an alias saying

00:49:03,430 --> 00:49:09,850
this is a quantity of such exponent but

00:49:05,710 --> 00:49:12,190
how to make a child class from it for

00:49:09,850 --> 00:49:14,320
that I invented something called called

00:49:12,190 --> 00:49:16,090
the Democratic trade I don't want to go

00:49:14,320 --> 00:49:17,440
in detail about this because I will go

00:49:16,090 --> 00:49:21,130
about this more tomorrow

00:49:17,440 --> 00:49:25,119
basically it it's a tie trade that you

00:49:21,130 --> 00:49:27,400
can specialize and I'll show the result

00:49:25,119 --> 00:49:31,050
because we are a bit tight on tide of

00:49:27,400 --> 00:49:31,050
time because of the question

00:49:31,690 --> 00:49:36,549
yeah this is how you're using this

00:49:33,390 --> 00:49:38,289
basically your unit and dimension type

00:49:36,549 --> 00:49:40,630
is encouraging from dunkers base

00:49:38,289 --> 00:49:41,500
providing the same type this is the CRT

00:49:40,630 --> 00:49:44,589
P pattern yes

00:49:41,500 --> 00:49:46,059
QC Creek template pattern and then you

00:49:44,589 --> 00:49:47,920
have to provide meter per second and you

00:49:46,059 --> 00:49:49,869
have the saying that done custom

00:49:47,920 --> 00:49:52,329
specialising done custom traits saying

00:49:49,869 --> 00:49:55,420
Dunkle's from meter per second is

00:49:52,329 --> 00:49:57,579
dunkers to meter per second so it's

00:49:55,420 --> 00:49:59,770
pretty easy to write but it's is

00:49:57,579 --> 00:50:01,480
boilerplate I would love to find someone

00:49:59,770 --> 00:50:05,109
that will find out and help me to

00:50:01,480 --> 00:50:07,390
automate automate it somehow I don't

00:50:05,109 --> 00:50:08,770
want to wait for reflections to make it

00:50:07,390 --> 00:50:10,569
happen maybe it's possible to do this

00:50:08,770 --> 00:50:13,390
different way by already spoke with some

00:50:10,569 --> 00:50:15,220
guys and it's not that easy so basically

00:50:13,390 --> 00:50:16,780
it's some overhead during the library

00:50:15,220 --> 00:50:19,119
plantation but the benefits are really

00:50:16,780 --> 00:50:21,430
really nice because this is what we have

00:50:19,119 --> 00:50:23,619
right now with our ESS and that is what

00:50:21,430 --> 00:50:26,980
we have with Democratic trades and and

00:50:23,619 --> 00:50:33,309
in Kriegers it's a huge benefit for the

00:50:26,980 --> 00:50:37,690
user also my labor is using have any

00:50:33,309 --> 00:50:39,339
concepts we have concepts for typists

00:50:37,690 --> 00:50:42,849
color ratio exponent dimension unit

00:50:39,339 --> 00:50:46,029
quantity and also for all of the derived

00:50:42,849 --> 00:50:48,760
quantities and length time frequency

00:50:46,029 --> 00:50:53,890
velocity so present velocity is a

00:50:48,760 --> 00:50:56,799
quantity and t dimension has to be the

00:50:53,890 --> 00:50:58,480
same as velocity this is how we'll

00:50:56,799 --> 00:51:03,839
provide your own concepts for your own

00:50:58,480 --> 00:51:03,839
derived derived emotions

00:51:05,790 --> 00:51:12,210
so you'll experience cup compilation we

00:51:08,340 --> 00:51:13,980
have here those concepts and we have the

00:51:12,210 --> 00:51:16,200
error I don't know if you've never ever

00:51:13,980 --> 00:51:17,490
seen how concepts fail during

00:51:16,200 --> 00:51:20,490
compilation but basically what this says

00:51:17,490 --> 00:51:23,490
does that the return return zero D times

00:51:20,490 --> 00:51:24,900
D friends to meet velocity concept and

00:51:23,490 --> 00:51:26,670
then you have information what diversity

00:51:24,900 --> 00:51:30,120
concept and which specific cases

00:51:26,670 --> 00:51:32,430
Unversity concepts is not met so there

00:51:30,120 --> 00:51:35,760
is information that basically velocity

00:51:32,430 --> 00:51:40,050
and dimension of length exponent one

00:51:35,760 --> 00:51:42,540
time exponent one is not a velocity so

00:51:40,050 --> 00:51:45,000
it's more user-friendly and actually

00:51:42,540 --> 00:51:46,890
stated this is experiment experimental

00:51:45,000 --> 00:51:48,450
implantation in compilers I expect this

00:51:46,890 --> 00:51:53,190
to be even more user-friendly in the

00:51:48,450 --> 00:51:56,460
future from the beginning of view ID is

00:51:53,190 --> 00:52:01,800
not lost it works fine with the types I

00:51:56,460 --> 00:52:06,360
provided gdb is great with it we type

00:52:01,800 --> 00:52:08,340
also one on one last thing that will

00:52:06,360 --> 00:52:11,300
really miss in my library are contracts

00:52:08,340 --> 00:52:14,520
I will really hoped about them and

00:52:11,300 --> 00:52:17,910
actually it's a problem that they didn't

00:52:14,520 --> 00:52:20,580
end up in C++ 20 for me first of all

00:52:17,910 --> 00:52:23,250
what it does I want to provide GSL

00:52:20,580 --> 00:52:28,430
expects as the contract precondition for

00:52:23,250 --> 00:52:28,430
my function was the outcome

00:52:31,660 --> 00:52:39,370
what happened this is a macro and macro

00:52:37,780 --> 00:52:47,320
glass got lost because of the template

00:52:39,370 --> 00:52:49,840
comma here yep so you can of you can hug

00:52:47,320 --> 00:52:54,160
this yes you can provide using type and

00:52:49,840 --> 00:52:57,340
compare this type here but it's it's

00:52:54,160 --> 00:52:59,500
meant to be simple guys yes so you can

00:52:57,340 --> 00:53:02,830
do remove severe if another helper from

00:52:59,500 --> 00:53:05,320
C++ 20 and it without come without

00:53:02,830 --> 00:53:07,900
commas and it will work but still not

00:53:05,320 --> 00:53:09,520
the best user-friendly not the best

00:53:07,900 --> 00:53:11,710
solution first of all you're using still

00:53:09,520 --> 00:53:13,690
macros in the in header files because

00:53:11,710 --> 00:53:15,340
this is your template there headers this

00:53:13,690 --> 00:53:19,510
is still a big problem with with ODR

00:53:15,340 --> 00:53:21,040
issues second taco it's not a part of

00:53:19,510 --> 00:53:22,660
the function signature this is just a

00:53:21,040 --> 00:53:24,280
part of quite a bit presentation so the

00:53:22,660 --> 00:53:25,870
user is not aware of you contract you

00:53:24,280 --> 00:53:27,640
have to specify it in documentation

00:53:25,870 --> 00:53:32,380
rather than in the signature of the

00:53:27,640 --> 00:53:37,000
function so not C++ 20 contracts would

00:53:32,380 --> 00:53:39,190
look like this one with this there you

00:53:37,000 --> 00:53:41,260
can use the simplest syntax here there

00:53:39,190 --> 00:53:42,850
are no compile compile errors this is

00:53:41,260 --> 00:53:45,730
put in the in this signature of the

00:53:42,850 --> 00:53:47,260
function so everything is great and

00:53:45,730 --> 00:53:48,580
always up-to-date because it's not a

00:53:47,260 --> 00:53:51,580
documentation that can be outdated

00:53:48,580 --> 00:53:54,130
easily it's verified to be compile time

00:53:51,580 --> 00:53:58,090
that actually this compiles and and runs

00:53:54,130 --> 00:54:01,150
fine and we don't have macros in headers

00:53:58,090 --> 00:54:03,490
anymore actually was told by interplay

00:54:01,150 --> 00:54:05,920
cause like an hour ago that basically

00:54:03,490 --> 00:54:08,710
this syntax will be already supported by

00:54:05,920 --> 00:54:10,270
by GCC and clang even though it's not a

00:54:08,710 --> 00:54:11,890
part of C++ 20 so we can start

00:54:10,270 --> 00:54:14,440
experiment with this syntax and try to

00:54:11,890 --> 00:54:16,720
write our own contracts in the library

00:54:14,440 --> 00:54:18,130
to provide feedback for the for the

00:54:16,720 --> 00:54:21,190
committee how we want to use them

00:54:18,130 --> 00:54:23,020
I'd actually think it's good but I trade

00:54:21,190 --> 00:54:25,330
the latest write the latest trunk GCC

00:54:23,020 --> 00:54:26,710
today and still it complains about comma

00:54:25,330 --> 00:54:28,360
because this is not a tribute syntax

00:54:26,710 --> 00:54:31,270
attributes in fact doesn't allow us come

00:54:28,360 --> 00:54:33,630
up in the in the internals of the

00:54:31,270 --> 00:54:33,630
attribute

00:54:35,980 --> 00:54:40,270
so the last subject how to extend it

00:54:38,680 --> 00:54:43,900
with your own type so you can download

00:54:40,270 --> 00:54:45,099
my library and work with GCC 9.1 because

00:54:43,900 --> 00:54:47,230
this is the only one that supports the

00:54:45,099 --> 00:54:50,319
features that are being used there sorry

00:54:47,230 --> 00:54:53,230
but this is supply past 20 library or c+

00:54:50,319 --> 00:54:55,210
have 23 library so I'm not targeting for

00:54:53,230 --> 00:54:56,500
it now wide audience of a lot of legacy

00:54:55,210 --> 00:54:58,630
software I want to put it in the

00:54:56,500 --> 00:55:02,020
standard and it should use the latest

00:54:58,630 --> 00:55:06,010
features the standard provides so it was

00:55:02,020 --> 00:55:07,569
with DCC 99.1 and you can try it if you

00:55:06,010 --> 00:55:09,339
want to extend it by yourself this is

00:55:07,569 --> 00:55:12,010
what you have to do for example you want

00:55:09,339 --> 00:55:15,190
to dive add bits and bytes support yes

00:55:12,010 --> 00:55:17,319
one byte is eight bits you have to pry

00:55:15,190 --> 00:55:20,220
the base dimension trying inline

00:55:17,319 --> 00:55:25,630
concepts base dimension provide your own

00:55:20,220 --> 00:55:28,540
identifier and the text for it then you

00:55:25,630 --> 00:55:31,569
have to create a dimension derive

00:55:28,540 --> 00:55:35,200
dimension for it so we say that this

00:55:31,569 --> 00:55:37,359
information to exponent 1 and you have

00:55:35,200 --> 00:55:43,299
to do this boilerplate for Democratic

00:55:37,359 --> 00:55:46,380
trace from two you have to provide if

00:55:43,299 --> 00:55:50,440
you want you can provide concept for it

00:55:46,380 --> 00:55:54,970
easy the quantity of T should be digital

00:55:50,440 --> 00:55:57,880
information you can provide your own

00:55:54,970 --> 00:56:02,049
unit saying that bit is a base unit so

00:55:57,880 --> 00:56:05,319
ratio one and byte is a you need to

00:56:02,049 --> 00:56:09,309
appreciate and once again by the plight

00:56:05,319 --> 00:56:12,700
of of Bank a stick place and if you want

00:56:09,309 --> 00:56:17,650
to compile your own UDL for bits and

00:56:12,700 --> 00:56:19,660
bytes and it's all actually you can try

00:56:17,650 --> 00:56:22,240
it out by yourself because last week

00:56:19,660 --> 00:56:25,030
working with mark on board we made it

00:56:22,240 --> 00:56:28,299
happen and this is the part of the of

00:56:25,030 --> 00:56:30,220
the gut but right now so if you want to

00:56:28,299 --> 00:56:33,190
use it first of all you have to use

00:56:30,220 --> 00:56:36,339
pretty decent DCC not mine or or or

00:56:33,190 --> 00:56:38,200
later you should provide simple past

00:56:36,339 --> 00:56:40,630
seventeen at least about a pink two is

00:56:38,200 --> 00:56:42,510
better F concepts because right now it's

00:56:40,630 --> 00:56:46,329
experimental support for concepts and

00:56:42,510 --> 00:56:49,799
also here as a library you have to

00:56:46,329 --> 00:56:49,799
select MP unit

00:56:50,520 --> 00:56:57,849
from truck and I really think thanks

00:56:55,900 --> 00:56:59,589
Matt that that he provided support

00:56:57,849 --> 00:57:02,619
because I hope it will make it easier to

00:56:59,589 --> 00:57:03,220
adapt Matt is not here because he is

00:57:02,619 --> 00:57:05,349
talking huh

00:57:03,220 --> 00:57:07,329
he probably he's on his own talk right

00:57:05,349 --> 00:57:10,900
now in the different room but thank you

00:57:07,329 --> 00:57:15,130
Matt very much so

00:57:10,900 --> 00:57:17,050
next step we really need this in the

00:57:15,130 --> 00:57:19,690
industry we really needed to make in the

00:57:17,050 --> 00:57:22,900
right correct software as I said I think

00:57:19,690 --> 00:57:24,609
in order to make it possible and then

00:57:22,900 --> 00:57:28,450
use a bow it has to be part of the

00:57:24,609 --> 00:57:30,040
standard library first step is to gather

00:57:28,450 --> 00:57:31,809
feedback and requirements that's why I'm

00:57:30,040 --> 00:57:33,010
here and talking to you if you're

00:57:31,809 --> 00:57:35,290
interested in this subject please

00:57:33,010 --> 00:57:36,579
provide me your thoughts about it please

00:57:35,290 --> 00:57:39,220
provide the requirements you have in

00:57:36,579 --> 00:57:41,500
your production in your in your use

00:57:39,220 --> 00:57:45,369
cases you are you are you want to cover

00:57:41,500 --> 00:57:47,470
with this library second point is go to

00:57:45,369 --> 00:57:50,160
ISO committee meeting will start in

00:57:47,470 --> 00:57:52,480
Belfast Design Review

00:57:50,160 --> 00:57:54,880
as I said there will be possible design

00:57:52,480 --> 00:57:56,380
these and updates after that so do not

00:57:54,880 --> 00:57:58,059
expect that this library will be like

00:57:56,380 --> 00:58:00,400
steps have stable interface for for some

00:57:58,059 --> 00:58:01,960
time it's still experimental I'm looking

00:58:00,400 --> 00:58:03,670
for experimental feedback and they

00:58:01,960 --> 00:58:04,839
assume you still probably cannot use it

00:58:03,670 --> 00:58:06,819
in the production because you probably

00:58:04,839 --> 00:58:10,030
have to support more compilers or you're

00:58:06,819 --> 00:58:11,920
not still on this is it 9.1 but for

00:58:10,030 --> 00:58:14,770
experimental and support at the week and

00:58:11,920 --> 00:58:16,569
the requirements I'm really open and I'm

00:58:14,770 --> 00:58:18,130
looking for for that also I'm looking

00:58:16,569 --> 00:58:24,280
for contributors if someone would like

00:58:18,130 --> 00:58:25,420
to help and yeah after that I would like

00:58:24,280 --> 00:58:27,040
to provide support for remaining

00:58:25,420 --> 00:58:29,650
dimensions and units based on feedback

00:58:27,040 --> 00:58:31,000
from you guys if you think that SI units

00:58:29,650 --> 00:58:33,309
or the things that are different that is

00:58:31,000 --> 00:58:34,990
not enough to start I will be extending

00:58:33,309 --> 00:58:36,790
this with time but right now I was

00:58:34,990 --> 00:58:38,290
complete mostly on on the framework by

00:58:36,790 --> 00:58:41,799
itself to make sure that framework is

00:58:38,290 --> 00:58:43,930
robust and not on the coverage of the

00:58:41,799 --> 00:58:45,339
unit systems as I said adding this is

00:58:43,930 --> 00:58:47,440
pretty simple you can do it by yourself

00:58:45,339 --> 00:58:49,329
or you can ask me to do it or you can do

00:58:47,440 --> 00:58:54,250
it and white will request so I can merge

00:58:49,329 --> 00:58:57,460
it I'm really open for that and I will

00:58:54,250 --> 00:58:59,260
try to catch a C++ 23 train if not 23

00:58:57,460 --> 00:59:02,770
then 26 but it will really like to make

00:58:59,260 --> 00:59:06,130
it happen with that

00:59:02,770 --> 00:59:15,839
done thank you much and we are ready for

00:59:06,130 --> 00:59:15,839
questions yes

00:59:34,660 --> 00:59:40,630
I'm not sure I understood the question

00:59:37,430 --> 00:59:40,630
so you asking about ratio

00:59:50,359 --> 00:59:54,319
yeah so the question is we have quantity

00:59:52,849 --> 00:59:56,839
of unit we don't care what it is about

00:59:54,319 --> 00:59:58,369
exactly but we want to print it for that

00:59:56,839 --> 01:00:00,259
you have to you need to have a strong

00:59:58,369 --> 01:00:01,549
type if you have to if you need to work

01:00:00,259 --> 01:00:03,529
of difference from that you need to have

01:00:01,549 --> 01:00:05,239
templates we have generic functions

01:00:03,529 --> 01:00:06,650
templates disappear a bit so they are

01:00:05,239 --> 01:00:08,829
more user-friendly and not that scary

01:00:06,650 --> 01:00:10,849
because you don't see template keyboard

01:00:08,829 --> 01:00:13,249
but but yeah you have to work with

01:00:10,849 --> 01:00:14,869
template still and actually you will not

01:00:13,249 --> 01:00:16,400
you who print think you will not care

01:00:14,869 --> 01:00:18,349
about this because the second step will

01:00:16,400 --> 01:00:20,390
be to add proper output support like

01:00:18,349 --> 01:00:23,179
like extreme support for it what exactly

01:00:20,390 --> 01:00:25,549
would happen for chrono in C++ 20 will

01:00:23,179 --> 01:00:28,069
have support for formatting and and

01:00:25,549 --> 01:00:29,569
output of the of the duration this also

01:00:28,069 --> 01:00:31,849
the second step for this library you

01:00:29,569 --> 01:00:33,469
will just have any quantity any type

01:00:31,849 --> 01:00:35,420
input it to see out it will work

01:00:33,469 --> 01:00:37,219
correctly of course if you'd like to

01:00:35,420 --> 01:00:43,150
make it work with printf then you have

01:00:37,219 --> 01:00:43,150
to do all the work by yourself yes

01:01:47,420 --> 01:01:50,720
okay so there are two questions first

01:01:48,950 --> 01:01:52,099
question is that we know that this is

01:01:50,720 --> 01:01:53,359
bounded problem is really important to

01:01:52,099 --> 01:01:55,760
have it so maybe we should consider

01:01:53,359 --> 01:01:57,680
adding this feature as a language rather

01:01:55,760 --> 01:01:59,660
than the library extension to the

01:01:57,680 --> 01:02:01,279
standard knowing I said purpose

01:01:59,660 --> 01:02:04,670
committee and non ideality it will not

01:02:01,279 --> 01:02:06,260
going to it's not going to fly so it we

01:02:04,670 --> 01:02:10,010
have to do it in the library it's not a

01:02:06,260 --> 01:02:11,809
language feature asking this in the

01:02:10,010 --> 01:02:15,170
second question is it a bit similar Toto

01:02:11,809 --> 01:02:16,819
stood chrono and and then ratio and

01:02:15,170 --> 01:02:18,470
dimension yeah it is similar but it's

01:02:16,819 --> 01:02:22,430
not is it it's a different orientation

01:02:18,470 --> 01:02:24,470
separate penetration right now I would

01:02:22,430 --> 01:02:27,640
have a big problem or there is a

01:02:24,470 --> 01:02:29,930
challenge to cover how to make the

01:02:27,640 --> 01:02:33,230
internal pub in turbidity of duration

01:02:29,930 --> 01:02:35,180
but right now by multiple members in the

01:02:33,230 --> 01:02:37,010
icy committee I was told to not worry

01:02:35,180 --> 01:02:38,119
about this I will add some compression

01:02:37,010 --> 01:02:40,640
functions or something like this later

01:02:38,119 --> 01:02:41,990
on we don't want to be bounded by by the

01:02:40,640 --> 01:02:47,299
design from from ten years ago

01:02:41,990 --> 01:02:49,809
I want to Julian this one actually we

01:02:47,299 --> 01:02:52,809
are out of time but maybe last question

01:02:49,809 --> 01:02:52,809
yes

01:03:32,289 --> 01:03:37,039
yes so the question is basically if we

01:03:34,819 --> 01:03:38,569
can have more than one types for

01:03:37,039 --> 01:03:43,579
specific strong types for the same

01:03:38,569 --> 01:03:45,890
dimension yeah so so right now not by

01:03:43,579 --> 01:03:48,410
this design but this is also what I'm I

01:03:45,890 --> 01:03:50,329
care a lot because for me altitude and

01:03:48,410 --> 01:03:53,390
this has to destination innovation is

01:03:50,329 --> 01:03:54,769
two different lens and the tangent from

01:03:53,390 --> 01:03:57,559
them is to tally it has to be calculated

01:03:54,769 --> 01:03:59,960
properly so that one to misalign those

01:03:57,559 --> 01:04:02,749
arguments length and length in the wrong

01:03:59,960 --> 01:04:05,089
order also sync rate and velocity is a

01:04:02,749 --> 01:04:06,049
tally different speed of the brain is

01:04:05,089 --> 01:04:07,609
also to tell you two different values

01:04:06,049 --> 01:04:09,049
both the same dimension

01:04:07,609 --> 01:04:10,940
I would like to separate this but I

01:04:09,049 --> 01:04:12,859
think that should be a wrapper over the

01:04:10,940 --> 01:04:15,380
library like provides for example some

01:04:12,859 --> 01:04:17,029
some some some additional reference

01:04:15,380 --> 01:04:19,160
system you would like to refer to or

01:04:17,029 --> 01:04:20,420
some maybe target saying what is your

01:04:19,160 --> 01:04:23,749
current use case for this one rather

01:04:20,420 --> 01:04:24,950
than putting this in this library we

01:04:23,749 --> 01:04:26,599
have to provide building blocks and

01:04:24,950 --> 01:04:29,690
build on top of the of them this is

01:04:26,599 --> 01:04:30,829
basically my idea for this and with that

01:04:29,690 --> 01:04:36,950
thank you much we already 5 minutes

01:04:30,829 --> 01:04:37,910
light so so we have to finish I'm I will

01:04:36,950 --> 01:04:39,319
be here so if you have any more

01:04:37,910 --> 01:04:40,999
questions or discussions please please

01:04:39,319 --> 01:04:43,690
find me on the corridor and we can talk

01:04:40,999 --> 01:04:43,690

YouTube URL: https://www.youtube.com/watch?v=0YW6yxkdhlU


