Title: CppCon 2019: Nicolai Josuttis “When C++ Style Guides Contradict”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
C++ is a success story. One reason is its backward compatibility.
But that also makes C++ more or more unteachable.
Too many features, too many rules, too many inconsistences.

So, the only solution (beside clean-ups for simple rules) are good style guides.
However, these style guides contradict significantly.
For example, while some recommend to define operations as non-member non-friend,
others recommend to use hidden friends.
Or when should we define virtual destructors?
Or the details of the rule of 0, 3, 5, "5 or 3".
Or how to initialize an object.

I have no clear solution.
But it's time to open the stage for a consolidation of the situation.
At least in the interest of all the average programmers who do not know all the rules (well, yes, nobody does).
— 
Nicolai Josuttis
IT Communication

Nicolai Josuttis (http://www.josuttis.com) is an independent system architect, technical manager, author, and consultant. He designs mid-sized and large software systems for the telecommunications, traffic, finance, and manufacturing industries.
He is well known in the programming community because he not only speaks and writes with authority (being the (co-)author of the world-wide best sellers The C++ Standard Library (www.cppstdlib.com), C++ Templates, and SOA in Practice), but is also an innovative presenter, having talked at various conferences and events.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:09,290 --> 00:00:12,289
good morning good afternoon good night

00:00:10,759 --> 00:00:15,289
whatever your time zone is you

00:00:12,289 --> 00:00:20,390
originally have for me it's good evening

00:00:15,289 --> 00:00:22,699
or good night my name I am the author of

00:00:20,390 --> 00:00:26,000
a couple of simple pass books and it's

00:00:22,699 --> 00:00:29,960
all my fault because I was involved in

00:00:26,000 --> 00:00:32,839
the standardization of C++ for more than

00:00:29,960 --> 00:00:39,339
20 years now so I voted on every

00:00:32,839 --> 00:00:47,140
standard the reason I'm coming here is

00:00:39,339 --> 00:00:50,690
that recently I found the problem I do

00:00:47,140 --> 00:00:54,309
most of the time now teach C++ to both

00:00:50,690 --> 00:00:57,230
beginners and advanced trainings and

00:00:54,309 --> 00:00:59,449
also if you had the talk

00:00:57,230 --> 00:01:01,910
the last talkie in the room I currently

00:00:59,449 --> 00:01:05,330
teach a big team at an automotive

00:01:01,910 --> 00:01:09,500
company that implements all autonomous

00:01:05,330 --> 00:01:14,240
driving vehicles so I learned something

00:01:09,500 --> 00:01:17,050
about the way we we have to teach C++

00:01:14,240 --> 00:01:20,539
and the way we have to deal with C++ so

00:01:17,050 --> 00:01:23,899
let's look so my first problem starts

00:01:20,539 --> 00:01:26,420
when I think about what should I teach

00:01:23,899 --> 00:01:30,410
as a first program and how could it look

00:01:26,420 --> 00:01:33,319
like so this is a simple program it's a

00:01:30,410 --> 00:01:37,130
included henna fire that declare a

00:01:33,319 --> 00:01:38,330
person let's bring it up already here we

00:01:37,130 --> 00:01:41,660
have something like 10 different

00:01:38,330 --> 00:01:45,319
questions regarding style I mean we can

00:01:41,660 --> 00:01:48,110
skip the usual things like naming

00:01:45,319 --> 00:01:49,880
convention spaces and line breaks but

00:01:48,110 --> 00:01:52,220
the first more interesting thing is what

00:01:49,880 --> 00:01:54,890
would be the suffix of a header file

00:01:52,220 --> 00:01:57,860
should we use namespaces which include

00:01:54,890 --> 00:01:59,899
comes first to be used using namespaces

00:01:57,860 --> 00:02:02,209
or not when we initialize should we use

00:01:59,899 --> 00:02:05,840
braces or parentheses or the equal sign

00:02:02,209 --> 00:02:08,360
well we player should be declared person

00:02:05,840 --> 00:02:09,429
to be cons should we use end line or

00:02:08,360 --> 00:02:12,170
newline here

00:02:09,429 --> 00:02:14,270
should we have a return zero statement

00:02:12,170 --> 00:02:16,160
that all the things you have to decide

00:02:14,270 --> 00:02:20,810
because to beginners you are the first

00:02:16,160 --> 00:02:22,920
guy teaching C++ and yeah we have

00:02:20,810 --> 00:02:26,100
different answers on these questions

00:02:22,920 --> 00:02:28,350
in different style guides and it that we

00:02:26,100 --> 00:02:32,010
have more so let's implement this class

00:02:28,350 --> 00:02:36,570
person this type we are using we have

00:02:32,010 --> 00:02:38,580
even more questions to answer so beside

00:02:36,570 --> 00:02:40,590
of that an interesting question is

00:02:38,580 --> 00:02:44,310
should we first have the private or the

00:02:40,590 --> 00:02:48,890
public section of this class should we

00:02:44,310 --> 00:02:52,560
have east or west cons so the

00:02:48,890 --> 00:02:54,510
Constructors be explicit should operator

00:02:52,560 --> 00:02:56,880
the output operator be a hidden friend

00:02:54,510 --> 00:02:59,250
if you don't know that wait a minute

00:02:56,880 --> 00:03:01,140
shouldn't the constructor take the

00:02:59,250 --> 00:03:03,480
argument by value and move it to the

00:03:01,140 --> 00:03:06,060
member it should be we overload the

00:03:03,480 --> 00:03:09,840
getter for two different kinds of

00:03:06,060 --> 00:03:12,090
references shouldn't be his Auto

00:03:09,840 --> 00:03:14,970
somewhere how much in lines will be used

00:03:12,090 --> 00:03:17,610
etc I've seen all these questions and it

00:03:14,970 --> 00:03:20,730
was discussed recently for example two

00:03:17,610 --> 00:03:24,000
weeks ago I was at a conference where we

00:03:20,730 --> 00:03:25,230
had a meet-up where we just discussed

00:03:24,000 --> 00:03:26,820
the short program and all these

00:03:25,230 --> 00:03:28,590
questions came up and we had different

00:03:26,820 --> 00:03:30,780
opinions in the audience how to deal

00:03:28,590 --> 00:03:33,030
with that and then where if we make that

00:03:30,780 --> 00:03:35,570
a base class yeah even more questions

00:03:33,030 --> 00:03:37,860
coming to play addition to the others

00:03:35,570 --> 00:03:40,950
should we declare virtue this crack

00:03:37,860 --> 00:03:43,860
destructor we would usually answer yes

00:03:40,950 --> 00:03:46,260
but we not always answer yes because

00:03:43,860 --> 00:03:47,519
when I suggested that each and every

00:03:46,260 --> 00:03:50,190
destructor and a class should

00:03:47,519 --> 00:03:54,060
automatically be brutal if we have

00:03:50,190 --> 00:03:55,709
Roberto members that was rejected so

00:03:54,060 --> 00:03:58,910
they are not the opinion that we should

00:03:55,709 --> 00:04:03,690
always have a go to this character

00:03:58,910 --> 00:04:05,310
should we use topo final protect the

00:04:03,690 --> 00:04:08,489
copy constructor here delete the

00:04:05,310 --> 00:04:14,640
assignment operator data member Const

00:04:08,489 --> 00:04:16,350
whoo yeah and why why why do we have

00:04:14,640 --> 00:04:20,010
said in any question well we have a

00:04:16,350 --> 00:04:21,989
history we have a history of C++ this

00:04:20,010 --> 00:04:25,229
history seemed longer than on this slide

00:04:21,989 --> 00:04:27,900
we have a history that started way

00:04:25,229 --> 00:04:30,690
before the first C++ standard in 98 and

00:04:27,900 --> 00:04:34,620
even then some questions about star

00:04:30,690 --> 00:04:36,710
guard came up the reason is we have so

00:04:34,620 --> 00:04:39,320
many tricky question

00:04:36,710 --> 00:04:42,140
programs there's a good reason for that

00:04:39,320 --> 00:04:43,910
one is flexibility we support many

00:04:42,140 --> 00:04:47,930
different platforms many different

00:04:43,910 --> 00:04:49,910
contexts etc then we grow and grow we

00:04:47,930 --> 00:04:53,420
are victims of our success

00:04:49,910 --> 00:04:56,480
so yes so we become more more complex I

00:04:53,420 --> 00:04:58,730
just checked about the number of pages

00:04:56,480 --> 00:05:01,610
in the standard we just have for the

00:04:58,730 --> 00:05:06,530
call language the basic utilities like

00:05:01,610 --> 00:05:08,450
pair and smart pointers and spring so

00:05:06,530 --> 00:05:11,090
things we would usually say that are

00:05:08,450 --> 00:05:14,210
essential to use and we doubled the size

00:05:11,090 --> 00:05:19,100
of pages just for these features over

00:05:14,210 --> 00:05:21,260
the past standards and we are backward

00:05:19,100 --> 00:05:24,320
compatible that's still a problem that

00:05:21,260 --> 00:05:27,200
for a good reason again but we are we

00:05:24,320 --> 00:05:28,940
are in fact 45 years backward compatible

00:05:27,200 --> 00:05:33,860
because we are still compatible again

00:05:28,940 --> 00:05:37,400
see both an instructor and coding and in

00:05:33,860 --> 00:05:39,830
binary compatibility and we are

00:05:37,400 --> 00:05:41,960
community driven which changes a couple

00:05:39,830 --> 00:05:45,380
of things if you no longer have a chief

00:05:41,960 --> 00:05:47,570
architect that means we have two hundred

00:05:45,380 --> 00:05:49,400
people having two different two hundred

00:05:47,570 --> 00:05:50,720
different opinions and two hundred

00:05:49,400 --> 00:05:53,600
different contexts and two hundred

00:05:50,720 --> 00:06:01,400
different ideas about what is useful for

00:05:53,600 --> 00:06:03,200
C++ so that's how we got there so and we

00:06:01,400 --> 00:06:05,030
have we have solved this problem we had

00:06:03,200 --> 00:06:07,400
this problem even with its first C++

00:06:05,030 --> 00:06:09,410
standard so even from the beginning

00:06:07,400 --> 00:06:12,080
there was targets that were introduced

00:06:09,410 --> 00:06:14,900
the first targets introduced were books

00:06:12,080 --> 00:06:18,260
like effective C++ and more effective

00:06:14,900 --> 00:06:21,680
C++ by Scott Myers then they came up out

00:06:18,260 --> 00:06:25,460
of the book in 2005 by thing C++ coding

00:06:21,680 --> 00:06:27,550
standards and then the talk before my

00:06:25,460 --> 00:06:30,140
talk you just introduce them we

00:06:27,550 --> 00:06:33,890
developed some style guides especially

00:06:30,140 --> 00:06:36,230
for safety critical environments then we

00:06:33,890 --> 00:06:39,080
established pretty late the C++ core

00:06:36,230 --> 00:06:41,810
guidelines and also Google plays now an

00:06:39,080 --> 00:06:45,380
interesting role and they have published

00:06:41,810 --> 00:06:49,070
publicly their internal target a big

00:06:45,380 --> 00:06:50,060
huge code base which helps us a lot to

00:06:49,070 --> 00:06:52,790
understand

00:06:50,060 --> 00:06:56,120
the issues of C++ and we can double

00:06:52,790 --> 00:06:59,720
check their new things on a very high

00:06:56,120 --> 00:07:03,560
codebase so they have the AK star guides

00:06:59,720 --> 00:07:06,700
and I thought great we have all these

00:07:03,560 --> 00:07:10,730
targets so let's use them

00:07:06,700 --> 00:07:16,190
unfortunately these guy guides and op

00:07:10,730 --> 00:07:20,990
consists so here just some detail as I

00:07:16,190 --> 00:07:24,770
said the CP core guidelines were started

00:07:20,990 --> 00:07:26,960
in 2015 they are still continuous we

00:07:24,770 --> 00:07:28,670
still not have a version one the

00:07:26,960 --> 00:07:33,650
official version currently publishes

00:07:28,670 --> 00:07:36,800
well ODOT eight here's a link for the

00:07:33,650 --> 00:07:39,770
google style guides abseil tips which

00:07:36,800 --> 00:07:41,360
came from the tip of the week if I

00:07:39,770 --> 00:07:44,330
understood it correctly titles you have

00:07:41,360 --> 00:07:47,590
to correct me that was internal project

00:07:44,330 --> 00:07:50,600
first and then you went public with that

00:07:47,590 --> 00:07:52,130
he has a just an overview of some of the

00:07:50,600 --> 00:07:54,080
safety critical guidelines

00:07:52,130 --> 00:07:59,860
I just learned in the recent talk that

00:07:54,080 --> 00:08:02,870
there are 15 in the world even ok so and

00:07:59,860 --> 00:08:05,780
please note that also these targets have

00:08:02,870 --> 00:08:08,570
to support well the MS Rostock as were

00:08:05,780 --> 00:08:11,030
more or less written by two vendors who

00:08:08,570 --> 00:08:14,450
wanted to sell their tools so they are

00:08:11,030 --> 00:08:17,300
to Griffin and so there are actual to it

00:08:14,450 --> 00:08:22,520
which you can buy but we have other

00:08:17,300 --> 00:08:26,060
tools like the guideline support library

00:08:22,520 --> 00:08:28,550
which is an implementation that supports

00:08:26,060 --> 00:08:30,320
the C++ core guidelines and is

00:08:28,550 --> 00:08:32,540
integrated and can be integrated in

00:08:30,320 --> 00:08:36,110
compilers and has an integration in

00:08:32,540 --> 00:08:39,140
Visual C++ then we have an interesting

00:08:36,110 --> 00:08:43,010
thing happened here with the effective

00:08:39,140 --> 00:08:45,830
C++ style guides there were becoming an

00:08:43,010 --> 00:08:48,230
option in GCC as though you could turn

00:08:45,830 --> 00:08:52,670
them on or some checks against that with

00:08:48,230 --> 00:08:54,980
W effective C++ turned out that now

00:08:52,670 --> 00:08:55,460
people usually recommend not to do so

00:08:54,980 --> 00:08:57,650
anymore

00:08:55,460 --> 00:08:59,870
because they are a little bit too strict

00:08:57,650 --> 00:09:01,640
now even the standard don't follow that

00:08:59,870 --> 00:09:03,470
or the Sun of implementation so let's

00:09:01,640 --> 00:09:05,930
follow that for example if you have

00:09:03,470 --> 00:09:08,450
class Percy inside the class person you

00:09:05,930 --> 00:09:10,190
have declared backed off in and then in

00:09:08,450 --> 00:09:13,100
your constructor you don't initialize

00:09:10,190 --> 00:09:15,590
the vector you get warning saying well

00:09:13,100 --> 00:09:17,090
that should be initialized but I mean

00:09:15,590 --> 00:09:19,820
strictly speaking you can argue

00:09:17,090 --> 00:09:23,470
everything is fine because the vector

00:09:19,820 --> 00:09:27,410
has a specified guaranteed default value

00:09:23,470 --> 00:09:29,450
so and by the way even in GCC then I'll

00:09:27,410 --> 00:09:31,160
say be aware that the standard library

00:09:29,450 --> 00:09:34,190
had us do not obey all of these

00:09:31,160 --> 00:09:36,770
guidelines so they don't actively

00:09:34,190 --> 00:09:42,890
promote them anymore well what they

00:09:36,770 --> 00:09:45,170
promote our other guidelines - w all you

00:09:42,890 --> 00:09:49,010
double check what guidelines they turn

00:09:45,170 --> 00:09:52,970
on here's a list of all of them it's

00:09:49,010 --> 00:09:55,490
about 50 different warnings that I abled

00:09:52,970 --> 00:10:00,680
with that and if that's not enough turn

00:09:55,490 --> 00:10:03,530
on - W extra and when I prepared this

00:10:00,680 --> 00:10:05,270
talk I went again through this

00:10:03,530 --> 00:10:06,290
guidelines and was surprised oh they

00:10:05,270 --> 00:10:08,390
asked oh look there's a warning

00:10:06,290 --> 00:10:11,360
redundant move I didn't know that I

00:10:08,390 --> 00:10:16,390
don't know whether you know so yeah they

00:10:11,360 --> 00:10:19,760
could act you said okay so we have

00:10:16,390 --> 00:10:23,410
different style guide integrated in

00:10:19,760 --> 00:10:27,260
different tools so now what's a problem

00:10:23,410 --> 00:10:30,140
so in fact to demonstrate the problem I

00:10:27,260 --> 00:10:32,600
want to go through a couple of example

00:10:30,140 --> 00:10:35,720
it's for these style guides so let's go

00:10:32,600 --> 00:10:38,600
through just and random or not so random

00:10:35,720 --> 00:10:39,700
selection of a few style guides and see

00:10:38,600 --> 00:10:43,730
what happened

00:10:39,700 --> 00:10:45,530
and my first example has to be the

00:10:43,730 --> 00:10:50,000
question what should be the extension of

00:10:45,530 --> 00:10:52,790
a header file well there's a nasty

00:10:50,000 --> 00:10:56,150
history of that because when we

00:10:52,790 --> 00:10:59,810
standardized C++ in 1998 we couldn't

00:10:56,150 --> 00:11:02,900
agree on a common extension it all

00:10:59,810 --> 00:11:07,400
started that the honest team had a

00:11:02,900 --> 00:11:10,880
capital H I think initially except when

00:11:07,400 --> 00:11:13,339
C was involved and then it turned out

00:11:10,880 --> 00:11:17,200
capital H and lowercase H can't be

00:11:13,339 --> 00:11:19,750
distinguished on visuals on windows of

00:11:17,200 --> 00:11:26,740
rating systems so they introduce HPP

00:11:19,750 --> 00:11:32,140
other containers used H H or H X X X as

00:11:26,740 --> 00:11:34,840
a slightly well-formed plus plus so we

00:11:32,140 --> 00:11:37,300
had that situation and when we try to

00:11:34,840 --> 00:11:40,960
decide about the standard exception

00:11:37,300 --> 00:11:43,810
extension for C++ headers the decision

00:11:40,960 --> 00:11:46,750
was as it always is done in politics we

00:11:43,810 --> 00:11:51,040
make a compromise the compromise was no

00:11:46,750 --> 00:11:52,990
extension at all good which was a ni pen

00:11:51,040 --> 00:11:55,030
itself because now in your file system

00:11:52,990 --> 00:11:57,100
look for your header file your son our

00:11:55,030 --> 00:12:00,180
header file and it has no extension it's

00:11:57,100 --> 00:12:02,380
hard to find it and it's hard to create

00:12:00,180 --> 00:12:05,770
configuration management rules against

00:12:02,380 --> 00:12:08,020
it and now I look in the car guidelines

00:12:05,770 --> 00:12:10,380
and hope they are using more I was using

00:12:08,020 --> 00:12:13,900
all the times all the years since then

00:12:10,380 --> 00:12:18,010
which is HPP but they don't do they

00:12:13,900 --> 00:12:20,920
recommend still h dot h SC extension

00:12:18,010 --> 00:12:23,050
with with saying this is a long-standing

00:12:20,920 --> 00:12:25,810
convention both doesn't mean it's good

00:12:23,050 --> 00:12:28,450
but that's an argument letters are often

00:12:25,810 --> 00:12:30,460
shared with see often is where that

00:12:28,450 --> 00:12:32,560
people I would say and it's easier to

00:12:30,460 --> 00:12:34,870
name all headers in a dot H instead of

00:12:32,560 --> 00:12:37,330
having different extensions I agree with

00:12:34,870 --> 00:12:39,400
that but the question is there's a

00:12:37,330 --> 00:12:41,230
growth ax because it turns out that in

00:12:39,400 --> 00:12:43,980
many many projects we've run into the

00:12:41,230 --> 00:12:46,570
same problems that we can't diss finger

00:12:43,980 --> 00:12:49,090
C++ header files from other header files

00:12:46,570 --> 00:12:51,040
and it starts with having a different

00:12:49,090 --> 00:12:52,840
syntax highlighting and if you're

00:12:51,040 --> 00:12:54,940
configuration management has to treat

00:12:52,840 --> 00:12:57,070
them differently because they somehow

00:12:54,940 --> 00:12:58,180
deal with them differently than with

00:12:57,070 --> 00:13:01,120
other header files you have a

00:12:58,180 --> 00:13:08,430
significant problem here so don't follow

00:13:01,120 --> 00:13:11,430
this guideline good the other thing is

00:13:08,430 --> 00:13:11,430
initializations

00:13:11,640 --> 00:13:15,880
one of our main topics now because it's

00:13:14,350 --> 00:13:18,820
one of the first thing I have to teach

00:13:15,880 --> 00:13:21,580
how to initialize an object and as we

00:13:18,820 --> 00:13:23,290
all know it's a mess now we started to

00:13:21,580 --> 00:13:25,270
have a mess and we made the mess even

00:13:23,290 --> 00:13:28,780
worse by extending the mess with some

00:13:25,270 --> 00:13:30,829
uniform initialization approach and the

00:13:28,780 --> 00:13:34,160
point is we want to have now

00:13:30,829 --> 00:13:38,119
braces everywhere even without an equal

00:13:34,160 --> 00:13:40,869
sign as it was possible NC so that might

00:13:38,119 --> 00:13:43,639
look have the effect that the arrange

00:13:40,869 --> 00:13:46,429
your normal for loop now looks at like

00:13:43,639 --> 00:13:51,920
this who's who's writing a follow-up

00:13:46,429 --> 00:13:56,149
like this on the right okay I changed my

00:13:51,920 --> 00:13:59,149
style two years ago and after three

00:13:56,149 --> 00:14:00,769
month I felt comfortable comfortable and

00:13:59,149 --> 00:14:03,139
now it's a smell for me not to have

00:14:00,769 --> 00:14:05,239
curly braces there so yeah we have some

00:14:03,139 --> 00:14:09,079
history but the see guys still hate us

00:14:05,239 --> 00:14:11,569
for that and yeah so should we use

00:14:09,079 --> 00:14:13,160
braces here or when we initialize base

00:14:11,569 --> 00:14:15,559
classes that's a question and there are

00:14:13,160 --> 00:14:16,369
argument in both directions I agree with

00:14:15,559 --> 00:14:19,549
it perfectly

00:14:16,369 --> 00:14:23,799
so let's look what the stag I'd say the

00:14:19,549 --> 00:14:26,269
core guidelines say prefer the brace

00:14:23,799 --> 00:14:28,879
initializations in syntax nobody says

00:14:26,269 --> 00:14:31,459
take only this syntax because that's

00:14:28,879 --> 00:14:34,579
stupid that doesn't work but what is

00:14:31,459 --> 00:14:39,290
what should you be is your equal so this

00:14:34,579 --> 00:14:41,899
is a clear recommendation I would now

00:14:39,290 --> 00:14:46,029
personally recommend it that way and we

00:14:41,899 --> 00:14:51,910
do that in this group of 200 programmers

00:14:46,029 --> 00:14:54,369
now and they feel comfortable absol has

00:14:51,910 --> 00:14:57,949
guys have a different recommendation

00:14:54,369 --> 00:15:01,369
it's interesting to read that uniform is

00:14:57,949 --> 00:15:03,799
a stretch it is not your uniform yes for

00:15:01,369 --> 00:15:05,209
sure it's not exactly intuitive other

00:15:03,799 --> 00:15:08,779
programming languages have other

00:15:05,209 --> 00:15:10,459
syntaxes I agree how much should we

00:15:08,779 --> 00:15:16,040
change our habits that's an interesting

00:15:10,459 --> 00:15:19,699
question it reads so the question is do

00:15:16,040 --> 00:15:22,429
we like change or not and yet yes we

00:15:19,699 --> 00:15:24,079
don't like that's a problem we have so

00:15:22,429 --> 00:15:27,410
that should be good reason to switch to

00:15:24,079 --> 00:15:30,730
something new and they don't believe

00:15:27,410 --> 00:15:34,309
that the benefits outweigh the drawbacks

00:15:30,730 --> 00:15:35,839
okay so they recommend this one which i

00:15:34,309 --> 00:15:41,389
think is a little bit more complicated

00:15:35,839 --> 00:15:43,189
by default so the point is not to say

00:15:41,389 --> 00:15:44,240
who's right the point is that we have

00:15:43,189 --> 00:15:47,180
different guidelines

00:15:44,240 --> 00:15:51,020
now Mike i-9 would be so say we have

00:15:47,180 --> 00:15:53,570
three major objects to initialize an end

00:15:51,020 --> 00:15:55,839
beside the other 16 ways to initialize

00:15:53,570 --> 00:15:58,820
an input I don't this on this slide and

00:15:55,839 --> 00:16:00,800
I would say prefer uniform direct

00:15:58,820 --> 00:16:03,080
initialization so using braces and we

00:16:00,800 --> 00:16:06,740
cosign and maybe just see equal sign if

00:16:03,080 --> 00:16:08,810
it's and a couple of reasons you should

00:16:06,740 --> 00:16:10,490
do that now I don't go through this list

00:16:08,810 --> 00:16:15,320
there are really a couple of reasons

00:16:10,490 --> 00:16:17,540
used to do that now yeah good but we

00:16:15,320 --> 00:16:19,940
don't agree on that so how could this I

00:16:17,540 --> 00:16:22,339
guides agree on that ending the standard

00:16:19,940 --> 00:16:25,640
committee we don't agree on that I would

00:16:22,339 --> 00:16:27,860
say that's a majority of the 200 guys

00:16:25,640 --> 00:16:34,550
who standardized C++ doesn't like

00:16:27,860 --> 00:16:37,839
uniform initialization okay next example

00:16:34,550 --> 00:16:41,750
in France so this should be easier

00:16:37,839 --> 00:16:43,399
because hidden France or the topic

00:16:41,750 --> 00:16:45,470
behind hidden France is something we

00:16:43,399 --> 00:16:49,600
learn and we all learned sooner or later

00:16:45,470 --> 00:16:53,300
we had a good C plus brass introduction

00:16:49,600 --> 00:16:55,880
so you can read it as item 24 and Scott

00:16:53,300 --> 00:16:58,970
Myers book it says when you have an

00:16:55,880 --> 00:17:02,360
operator and it's a binary operator

00:16:58,970 --> 00:17:04,390
cooperative operator where implicit type

00:17:02,360 --> 00:17:07,329
conversions make sense on both sides

00:17:04,390 --> 00:17:10,640
don't implement it inside the class

00:17:07,329 --> 00:17:14,000
because then one of the operands only

00:17:10,640 --> 00:17:15,829
supports implicit means make sure on

00:17:14,000 --> 00:17:17,569
both sides of the multiplication

00:17:15,829 --> 00:17:21,050
implicit type conversions are possible

00:17:17,569 --> 00:17:24,770
so implemented outside that class as a

00:17:21,050 --> 00:17:27,050
global fun okay there are variations on

00:17:24,770 --> 00:17:29,750
that so prepare writing non-member non

00:17:27,050 --> 00:17:31,940
friend functions or use non-member

00:17:29,750 --> 00:17:34,940
functions for symmetric operators now in

00:17:31,940 --> 00:17:38,059
the CPP guideline Co guidelines they say

00:17:34,940 --> 00:17:39,800
both similar things sometimes exactly

00:17:38,059 --> 00:17:41,780
the right sometimes slightly different

00:17:39,800 --> 00:17:45,380
the different flavor should it apply to

00:17:41,780 --> 00:17:48,559
operators or also to ordinary functions

00:17:45,380 --> 00:17:51,640
etc so here's a problem we solve the

00:17:48,559 --> 00:17:55,460
problem is hopefully well known if we're

00:17:51,640 --> 00:17:57,470
well and and what flavors to implement

00:17:55,460 --> 00:17:58,059
the output operator well there we have

00:17:57,470 --> 00:18:00,580
not

00:17:58,059 --> 00:18:02,769
we can't implement and member function

00:18:00,580 --> 00:18:05,590
because the first operand is in all

00:18:02,769 --> 00:18:10,090
streams we have to implement it outside

00:18:05,590 --> 00:18:12,070
the class and that's why we usually

00:18:10,090 --> 00:18:13,840
learn to implement the output operator

00:18:12,070 --> 00:18:15,429
that's actually the way we implement it

00:18:13,840 --> 00:18:18,549
in the standard library wherever we

00:18:15,429 --> 00:18:22,119
implement an output operator so what's

00:18:18,549 --> 00:18:25,509
wrong with this nothing

00:18:22,119 --> 00:18:29,710
friends works unless you forget to

00:18:25,509 --> 00:18:31,509
define it if you forget to define it you

00:18:29,710 --> 00:18:35,700
see an interesting effect you get an

00:18:31,509 --> 00:18:39,549
error message and in this error message

00:18:35,700 --> 00:18:42,369
we are listing all the candidates

00:18:39,549 --> 00:18:46,049
compiler tries out to find the operator

00:18:42,369 --> 00:18:52,059
of appropriate operator to print it out

00:18:46,049 --> 00:18:55,719
if you just include string you have 30

00:18:52,059 --> 00:18:58,839
different rights here if you have your

00:18:55,719 --> 00:19:01,149
code base extended by many classes that

00:18:58,839 --> 00:19:03,460
can be significant longer and it's not

00:19:01,149 --> 00:19:05,589
only nasty that the error message is not

00:19:03,460 --> 00:19:08,619
the best one to understand the problem

00:19:05,589 --> 00:19:12,429
and it's a scary in fact unless you

00:19:08,619 --> 00:19:15,159
understand how is it going it is but

00:19:12,429 --> 00:19:17,200
that is also sign of that it takes

00:19:15,159 --> 00:19:18,989
compile time the compiler has to find

00:19:17,200 --> 00:19:23,320
out and check all these candidates

00:19:18,989 --> 00:19:28,179
against yeah can I find an implicit type

00:19:23,320 --> 00:19:29,889
conversion or not that works so that's a

00:19:28,179 --> 00:19:31,359
problem and that's a problem we see more

00:19:29,889 --> 00:19:33,879
and more and that's by the way a problem

00:19:31,359 --> 00:19:38,649
they do Google I see in practice also as

00:19:33,879 --> 00:19:42,669
far as I know and so what can we do well

00:19:38,649 --> 00:19:46,149
there's another the other option is use

00:19:42,669 --> 00:19:49,809
hidden friends hidden friends friend

00:19:46,149 --> 00:19:52,359
declarations that are inside the class

00:19:49,809 --> 00:19:58,479
structure who knows in France

00:19:52,359 --> 00:20:02,320
already oh that's an aha ok so that

00:19:58,479 --> 00:20:04,839
means you you can say I implement

00:20:02,320 --> 00:20:07,359
everything you saw before but inside the

00:20:04,839 --> 00:20:08,859
class but you have to use the keyword

00:20:07,359 --> 00:20:09,480
friend because without friend you

00:20:08,859 --> 00:20:12,390
implement

00:20:09,480 --> 00:20:14,250
a member function and that would mean

00:20:12,390 --> 00:20:16,980
you implementing the output operator for

00:20:14,250 --> 00:20:18,960
three operands or a person for a little

00:20:16,980 --> 00:20:21,030
stream and a person that's not allowed

00:20:18,960 --> 00:20:24,900
so with friend you say this is actually

00:20:21,030 --> 00:20:27,510
a way to implement it inside the class

00:20:24,900 --> 00:20:30,750
and the good thing is by rule this is

00:20:27,510 --> 00:20:33,929
used not only for a person but also for

00:20:30,750 --> 00:20:36,600
every type derived from person and that

00:20:33,929 --> 00:20:40,320
means but it's otherwise not evaluated

00:20:36,600 --> 00:20:42,960
so just in general a compiler will not

00:20:40,320 --> 00:20:47,280
look into a class unless the type of the

00:20:42,960 --> 00:20:49,290
class is involved so we don't if we do

00:20:47,280 --> 00:20:53,640
that and you add this as a header file

00:20:49,290 --> 00:20:58,860
your number of 30 candidates will not

00:20:53,640 --> 00:21:03,679
wait to 31 for other times oh but then

00:20:58,860 --> 00:21:09,419
you have out Rosa and Otto Sal says

00:21:03,679 --> 00:21:10,140
friends shall not be used there are good

00:21:09,419 --> 00:21:12,780
reasons for that

00:21:10,140 --> 00:21:15,299
I mean friendship breaks encapsulation

00:21:12,780 --> 00:21:19,530
but this friendship definitely be not

00:21:15,299 --> 00:21:25,320
breaks encapsulation well does it break

00:21:19,530 --> 00:21:27,720
the encapsulation or not maybe why I say

00:21:25,320 --> 00:21:30,299
this is my friend and if I at least if

00:21:27,720 --> 00:21:32,490
you would only declared here and then

00:21:30,299 --> 00:21:37,080
implement it outside you have opened the

00:21:32,490 --> 00:21:40,350
loop and hole and yeah so there are some

00:21:37,080 --> 00:21:44,309
issues here good but anyway they expect

00:21:40,350 --> 00:21:47,549
to say this is a not compliant to have a

00:21:44,309 --> 00:21:49,770
friend here in the class that the

00:21:47,549 --> 00:21:51,480
wording they have and by the way I

00:21:49,770 --> 00:21:54,540
should send sonic say something here

00:21:51,480 --> 00:21:57,210
this tag ID explicitly says we have a

00:21:54,540 --> 00:21:59,040
style guide you should follow and if you

00:21:57,210 --> 00:22:02,429
follow it you have to not to explain why

00:21:59,040 --> 00:22:07,140
- why you do certain things it's allowed

00:22:02,429 --> 00:22:08,610
to break this with an explanation so but

00:22:07,140 --> 00:22:10,200
it's a little bit boring to always

00:22:08,610 --> 00:22:12,799
explain yeah because this is state of

00:22:10,200 --> 00:22:15,330
the art now we should use hidden friends

00:22:12,799 --> 00:22:17,909
hidden friends are not discussed in the

00:22:15,330 --> 00:22:21,299
core guidelines otherwise so no longer

00:22:17,909 --> 00:22:24,809
no long-distance friendship is

00:22:21,299 --> 00:22:29,129
part of the last ODOT two versions until

00:22:24,809 --> 00:22:31,350
we have world and wondered oh and please

00:22:29,129 --> 00:22:34,139
note that hidden friends are important

00:22:31,350 --> 00:22:36,419
for another reason this is one of my

00:22:34,139 --> 00:22:38,759
favorite examples can't be let's

00:22:36,419 --> 00:22:40,379
implement the class begins the big and

00:22:38,759 --> 00:22:45,960
takes a string because it takes an

00:22:40,379 --> 00:22:47,850
arbitrary number of K of digits forget

00:22:45,960 --> 00:22:49,559
that it internally uses long long but

00:22:47,850 --> 00:22:52,019
that could be one implementation and

00:22:49,559 --> 00:22:54,480
then you will say let's say implement

00:22:52,019 --> 00:22:56,789
deed multiplication for two big ends the

00:22:54,480 --> 00:22:59,549
output will be return value will be

00:22:56,789 --> 00:23:02,429
indignant note that we have a

00:22:59,549 --> 00:23:05,749
constructor taking a string here so what

00:23:02,429 --> 00:23:11,119
have we done we have introduced

00:23:05,749 --> 00:23:13,559
multiplication for STDs red because

00:23:11,119 --> 00:23:16,649
there's an implicit type conversion now

00:23:13,559 --> 00:23:19,139
defined by the constructor and that will

00:23:16,649 --> 00:23:22,350
be used and he were only lucky in other

00:23:19,139 --> 00:23:24,929
types if you for example were using plus

00:23:22,350 --> 00:23:26,730
also that string has its own class and

00:23:24,929 --> 00:23:30,149
that has higher priority for the

00:23:26,730 --> 00:23:32,700
compiler so you might or might not get a

00:23:30,149 --> 00:23:34,799
runtime error depending on the value of

00:23:32,700 --> 00:23:38,609
your string if you multiply two strings

00:23:34,799 --> 00:23:40,950
now and hidden friends fixes also

00:23:38,609 --> 00:23:45,869
because this is not considered to be

00:23:40,950 --> 00:23:48,749
used if not had any of the operands is

00:23:45,869 --> 00:23:52,730
bigand or derived from big ears or that

00:23:48,749 --> 00:23:52,730
song okay

00:23:53,190 --> 00:24:10,859
how do I know that question because you

00:24:09,299 --> 00:24:13,590
say it's an operator's fault

00:24:10,859 --> 00:24:15,989
yeah I Mac might my take might be might

00:24:13,590 --> 00:24:18,090
not be the case I don't care I have Auto

00:24:15,989 --> 00:24:21,210
stagger and I want to see whether this

00:24:18,090 --> 00:24:24,389
is okay or not because we have to face a

00:24:21,210 --> 00:24:26,909
situation that not each and every C++

00:24:24,389 --> 00:24:31,499
coma programmer understands all the

00:24:26,909 --> 00:24:34,950
details of C++ that's a problem we have

00:24:31,499 --> 00:24:42,570
with the complexity of the leg

00:24:34,950 --> 00:24:44,129
yeah oh we come from the question

00:24:42,570 --> 00:24:46,789
whether this constructor is okay we

00:24:44,129 --> 00:24:50,759
can't do that question yeah I'm not back

00:24:46,789 --> 00:24:52,769
so first of all how do I know this

00:24:50,759 --> 00:24:54,690
hidden friend problem ID problem in

00:24:52,769 --> 00:24:57,330
feature I didn't know that at all we

00:24:54,690 --> 00:25:00,029
found it when we sanitized C++ 17 and

00:24:57,330 --> 00:25:02,159
got the following back report look at

00:25:00,029 --> 00:25:05,460
the right side that's a little bit

00:25:02,159 --> 00:25:08,580
greater it turned out that somebody

00:25:05,460 --> 00:25:11,129
could suddenly write take a white string

00:25:08,580 --> 00:25:14,309
a slash less B and comparing with the

00:25:11,129 --> 00:25:18,330
nasty D string s a slash B and the

00:25:14,309 --> 00:25:21,690
answer was true why the hell that

00:25:18,330 --> 00:25:25,649
because we had introduced the type

00:25:21,690 --> 00:25:28,259
called path path had an implicit type

00:25:25,649 --> 00:25:30,590
convert from string it could be could

00:25:28,259 --> 00:25:33,029
both convert implicitly to a path and

00:25:30,590 --> 00:25:35,970
for a path it doesn't matter whether you

00:25:33,029 --> 00:25:39,090
as one slash or two slashes so the

00:25:35,970 --> 00:25:41,519
solution we fix that and C++ eptein as a

00:25:39,090 --> 00:25:43,950
back fix it's not in the standard yet it

00:25:41,519 --> 00:25:46,649
will be in C++ 20 the fix is that we

00:25:43,950 --> 00:25:51,149
said this operator for path has to be a

00:25:46,649 --> 00:25:53,309
hidden friend okay now there's an

00:25:51,149 --> 00:25:54,960
alternative and Titus wants to say that

00:25:53,309 --> 00:25:57,980
yes of course we all know let's use

00:25:54,960 --> 00:26:01,679
explicit and we don't have this problem

00:25:57,980 --> 00:26:04,889
good and that's exactly what well some

00:26:01,679 --> 00:26:07,139
star guides say somewhere here for

00:26:04,889 --> 00:26:09,359
example the co-star guide say but for

00:26:07,139 --> 00:26:14,429
single argument constructors we should

00:26:09,359 --> 00:26:17,789
use explicit which but by only by

00:26:14,429 --> 00:26:20,009
default because if you for example take

00:26:17,789 --> 00:26:21,659
this rule even for constructor

00:26:20,009 --> 00:26:24,570
initializing a string from the string

00:26:21,659 --> 00:26:27,090
literal you would say and I can no

00:26:24,570 --> 00:26:29,220
longer directly pass the screen little

00:26:27,090 --> 00:26:31,529
to a function foo if it takes a string I

00:26:29,220 --> 00:26:34,289
have to act always explicitly converted

00:26:31,529 --> 00:26:36,779
which can be good or bad I don't move I

00:26:34,289 --> 00:26:39,840
don't judge this but that's the effect

00:26:36,779 --> 00:26:41,970
and your programmers might not like that

00:26:39,840 --> 00:26:43,590
if they initialize the vector of spring

00:26:41,970 --> 00:26:45,690
that they have to convert all these

00:26:43,590 --> 00:26:48,300
string literals to strings instead of

00:26:45,690 --> 00:26:50,910
passing directly so that's a prize

00:26:48,300 --> 00:26:54,620
of using explicit then you have to use

00:26:50,910 --> 00:26:57,180
explicit everywhere and so some

00:26:54,620 --> 00:26:59,370
compromises discuss in C++ it says

00:26:57,180 --> 00:27:02,310
explicit only in the one argument

00:26:59,370 --> 00:27:04,680
constructor as it is specified in the

00:27:02,310 --> 00:27:08,040
core guidelines that has an interesting

00:27:04,680 --> 00:27:09,990
side effect that means look at this the

00:27:08,040 --> 00:27:12,180
declaration in the middle is possible

00:27:09,990 --> 00:27:15,990
but the first is valid then the last is

00:27:12,180 --> 00:27:18,360
not is valid if a function foo returns a

00:27:15,990 --> 00:27:21,210
person you can't return a string even

00:27:18,360 --> 00:27:23,100
not in curly braces you have to convert

00:27:21,210 --> 00:27:26,010
it but you don't have to convert it if

00:27:23,100 --> 00:27:27,780
you return something that can be

00:27:26,010 --> 00:27:29,820
converted to a person without the value

00:27:27,780 --> 00:27:31,920
or with two values that will compile and

00:27:29,820 --> 00:27:34,290
the same is true if you initialize a

00:27:31,920 --> 00:27:36,360
vector of persons that's the middle

00:27:34,290 --> 00:27:39,300
thing having only one argument will not

00:27:36,360 --> 00:27:44,040
compile the other things will combine so

00:27:39,300 --> 00:27:47,280
we are getting other issues if we have

00:27:44,040 --> 00:27:50,940
this rule and this rule was proposed by

00:27:47,280 --> 00:27:54,780
paper for the C++ 20 standard is a link

00:27:50,940 --> 00:27:56,700
and we put it out after we voted it in

00:27:54,780 --> 00:27:58,620
or after we applied it and then we

00:27:56,700 --> 00:28:01,620
thought oh no no we have to discuss the

00:27:58,620 --> 00:28:05,850
design again and then we took it out

00:28:01,620 --> 00:28:09,180
again so by the way to other things

00:28:05,850 --> 00:28:12,450
regarding explicit and not this funny

00:28:09,180 --> 00:28:14,250
rule that an empty list prefers a

00:28:12,450 --> 00:28:16,700
default constructor and non empty list

00:28:14,250 --> 00:28:21,510
because the initializer list constructor

00:28:16,700 --> 00:28:23,610
so if you have mixed explicit in your

00:28:21,510 --> 00:28:25,920
class you're getting interesting effects

00:28:23,610 --> 00:28:30,030
like this this is an error this is an

00:28:25,920 --> 00:28:33,720
error this is okay this is okay this is

00:28:30,030 --> 00:28:35,700
okay this is an error or okay depending

00:28:33,720 --> 00:28:39,750
on how many arguments you have between

00:28:35,700 --> 00:28:41,670
the curly braces yeah and there's a rule

00:28:39,750 --> 00:28:45,000
by that which I don't know whether in

00:28:41,670 --> 00:28:46,620
any saga did exist the default

00:28:45,000 --> 00:28:49,170
constructor and the initializer list

00:28:46,620 --> 00:28:50,820
constructor should always have to be

00:28:49,170 --> 00:28:53,060
consistent regarding the question

00:28:50,820 --> 00:28:55,380
whether we they are explicit or not

00:28:53,060 --> 00:28:57,630
because that's a heart of the problem

00:28:55,380 --> 00:28:58,509
here okay

00:28:57,630 --> 00:29:01,719
how do I

00:28:58,509 --> 00:29:03,999
that we made the mistake in C++ 11 with

00:29:01,719 --> 00:29:07,899
all the containers and we fix that with

00:29:03,999 --> 00:29:09,759
C++ 40 so yeah you see a pattern here

00:29:07,899 --> 00:29:12,309
first of all you might have seen some

00:29:09,759 --> 00:29:14,499
things you didn't know ya miss missing a

00:29:12,309 --> 00:29:16,839
lack of knowledge even in the standard

00:29:14,499 --> 00:29:19,959
committee and the other thing is we

00:29:16,839 --> 00:29:23,799
learn over time we standardize features

00:29:19,959 --> 00:29:25,809
of C++ there eleven eight years ago and

00:29:23,799 --> 00:29:29,669
now finally we have an idea how to use

00:29:25,809 --> 00:29:29,669
them and that's another problem we have

00:29:30,779 --> 00:29:37,119
Pablo you asked for a quest for an

00:29:33,819 --> 00:29:39,279
example of the misra so I should give

00:29:37,119 --> 00:29:43,389
you one another example of misra here

00:29:39,279 --> 00:29:47,279
and that is the question of enumerations

00:29:43,389 --> 00:29:57,609
and switch so there's an interesting

00:29:47,279 --> 00:30:01,049
absol to use x+ switch statements that

00:29:57,609 --> 00:30:05,559
are d default Ness switch statements

00:30:01,049 --> 00:30:08,199
with responsibility but just not easy to

00:30:05,559 --> 00:30:09,899
understand guideline it's more or less

00:30:08,199 --> 00:30:12,159
to say you should know what you do and

00:30:09,899 --> 00:30:13,539
there are some constraints when this

00:30:12,159 --> 00:30:16,179
should be used and whether this should

00:30:13,539 --> 00:30:19,599
be not the background of this tip is

00:30:16,179 --> 00:30:21,069
something like this if you use an enum

00:30:19,599 --> 00:30:24,279
or you know class doesn't matter whether

00:30:21,069 --> 00:30:28,359
it's an enum or in on class and you have

00:30:24,279 --> 00:30:30,849
a switch statement you should switch

00:30:28,359 --> 00:30:33,789
only over all possible values and not

00:30:30,849 --> 00:30:36,669
have a default case before the label

00:30:33,789 --> 00:30:40,690
because then the compiler might will

00:30:36,669 --> 00:30:45,369
warn you Lee or often if you forget the

00:30:40,690 --> 00:30:47,919
case so we have some support here to

00:30:45,369 --> 00:30:49,929
find out if we extend the statuses by

00:30:47,919 --> 00:30:54,249
one more status we should fix the switch

00:30:49,929 --> 00:30:57,669
statement here so that's what I usually

00:30:54,249 --> 00:31:00,369
recommend until I went to this group of

00:30:57,669 --> 00:31:02,199
200 autonomous driving implementers and

00:31:00,369 --> 00:31:05,969
they told me wait a minute wait a minute

00:31:02,199 --> 00:31:08,799
Nick oh you can't give us this guy

00:31:05,969 --> 00:31:12,039
don't use default here this is a

00:31:08,799 --> 00:31:16,840
violation of misra

00:31:12,039 --> 00:31:19,479
yes no there has to be a default label

00:31:16,840 --> 00:31:23,830
in a switch statement otherwise it's not

00:31:19,479 --> 00:31:26,409
a well form statement and remember the

00:31:23,830 --> 00:31:28,570
point of misery they sell other tools so

00:31:26,409 --> 00:31:30,429
you might not you might say yeah I know

00:31:28,570 --> 00:31:33,879
what I'm doing but it doesn't go through

00:31:30,429 --> 00:31:38,649
your tool and to your quality game so

00:31:33,879 --> 00:31:41,139
yeah so we discussed what to do hmm

00:31:38,649 --> 00:31:44,739
that's tricky the best we could come up

00:31:41,139 --> 00:31:49,090
with this with was have a default label

00:31:44,739 --> 00:31:52,749
and they're having an assertion which is

00:31:49,090 --> 00:31:55,659
still worse because we are miss reckon

00:31:52,749 --> 00:31:58,149
forum but we are turning a compiler I'm

00:31:55,659 --> 00:31:59,950
warning you know into a runtime error or

00:31:58,149 --> 00:32:11,979
content compile time error you can make

00:31:59,950 --> 00:32:14,739
it a compile time error yeah the

00:32:11,979 --> 00:32:16,570
question is isn't this necessary well

00:32:14,739 --> 00:32:19,299
the background is yeah it might be

00:32:16,570 --> 00:32:20,769
necessary because in old C you could

00:32:19,299 --> 00:32:22,809
have other where you send these three

00:32:20,769 --> 00:32:25,059
and it's even possible in C++ with you

00:32:22,809 --> 00:32:27,399
know glass because with you the static

00:32:25,059 --> 00:32:29,229
cost you can have other values so

00:32:27,399 --> 00:32:32,320
shouldn't we have that well that depends

00:32:29,229 --> 00:32:36,549
on your logic and I only point out that

00:32:32,320 --> 00:32:41,619
we have that we have to support to help

00:32:36,549 --> 00:32:44,139
us not to forget the case label and we

00:32:41,619 --> 00:32:48,460
have would that say no this benefit of

00:32:44,139 --> 00:32:52,119
one to the compiler should be disabled

00:32:48,460 --> 00:32:54,099
to benefit from another star guy yeah we

00:32:52,119 --> 00:33:04,289
have contradicting interest in staggered

00:32:54,099 --> 00:33:04,289
that's another lesson wheeler and what

00:33:04,349 --> 00:33:11,190
there's missing a break yeah that was a

00:33:07,450 --> 00:33:11,190
trick to find out whether you find it

00:33:11,519 --> 00:33:15,909
yeah that's exactly what miss Suarez

00:33:13,929 --> 00:33:18,340
says rule because guys like me make this

00:33:15,909 --> 00:33:22,749
mistake with a program and at the

00:33:18,340 --> 00:33:24,460
default label yeah proof proof miserable

00:33:22,749 --> 00:33:29,529
proof

00:33:24,460 --> 00:33:31,720
okay yeah by the way Jesus Sea has three

00:33:29,529 --> 00:33:37,299
different switch options here they have

00:33:31,720 --> 00:33:39,519
- w switch that we lack a case if there

00:33:37,299 --> 00:33:41,499
is no default level default label

00:33:39,519 --> 00:33:44,740
present then they have switched

00:33:41,499 --> 00:33:47,110
enorm that they warned of the you

00:33:44,740 --> 00:33:49,539
lacquer case if there's even a default

00:33:47,110 --> 00:33:51,220
label present so that's maybe the one

00:33:49,539 --> 00:33:54,639
you need but that's not the one that's

00:33:51,220 --> 00:33:58,450
turned on made - W all the first one is

00:33:54,639 --> 00:34:00,549
on being enabled only for enum values so

00:33:58,450 --> 00:34:04,539
I think the second one is a better one

00:34:00,549 --> 00:34:06,429
and then they have the mizrahi saying

00:34:04,539 --> 00:34:09,339
that's saying you should not forget the

00:34:06,429 --> 00:34:13,000
default label they have support for all

00:34:09,339 --> 00:34:16,599
the sides good so let me come to my

00:34:13,000 --> 00:34:18,940
final example I like that because I have

00:34:16,599 --> 00:34:21,190
a lot of discussion right now with a

00:34:18,940 --> 00:34:24,609
couple of guys whether what I tell you

00:34:21,190 --> 00:34:28,780
now is correct or not so let's talk

00:34:24,609 --> 00:34:30,849
about virtual override and final so in

00:34:28,780 --> 00:34:33,339
the CPP car guidelines and a lot of

00:34:30,849 --> 00:34:35,409
people know that rule a surprising

00:34:33,339 --> 00:34:39,250
number of people know that will and tell

00:34:35,409 --> 00:34:42,250
me about that is if you have virtual

00:34:39,250 --> 00:34:44,829
functions you should exactly use only

00:34:42,250 --> 00:34:48,970
one of the keywords virtual override or

00:34:44,829 --> 00:34:51,790
final never more writing more than one

00:34:48,970 --> 00:34:54,190
of these is redundant I understand that

00:34:51,790 --> 00:34:57,010
and the potential source of errors I

00:34:54,190 --> 00:34:59,500
don't understand that if somebody no see

00:34:57,010 --> 00:35:03,760
why please come to me afterwards or send

00:34:59,500 --> 00:35:05,770
me an email to explain them it's simple

00:35:03,760 --> 00:35:07,660
and clear virtual means is a new Voter

00:35:05,770 --> 00:35:09,819
function override means this is a non

00:35:07,660 --> 00:35:13,660
fine override a final means this is a

00:35:09,819 --> 00:35:16,089
final override the background for this

00:35:13,660 --> 00:35:18,339
rule is we have if we have something

00:35:16,089 --> 00:35:20,619
like this a base class introducing foo

00:35:18,339 --> 00:35:24,000
and bar new worth of functions water

00:35:20,619 --> 00:35:27,099
farm then we have a derived class

00:35:24,000 --> 00:35:29,559
overriding pool we should now place foo

00:35:27,099 --> 00:35:32,559
here so that we see that we don't

00:35:29,559 --> 00:35:36,069
overload for example when we forget the

00:35:32,559 --> 00:35:37,869
constant and we can use final here now

00:35:36,069 --> 00:35:41,859
to say okay this

00:35:37,869 --> 00:35:45,970
final over Laura over Ida and so nobody

00:35:41,859 --> 00:35:48,339
else can over write this anymore and if

00:35:45,970 --> 00:35:50,559
somebody in the derived class can still

00:35:48,339 --> 00:35:52,150
override the foo but not bad that's an

00:35:50,559 --> 00:35:54,160
arrow that's good because we have marked

00:35:52,150 --> 00:35:57,880
it fine so far so good

00:35:54,160 --> 00:36:01,029
I agree however there are other

00:35:57,880 --> 00:36:03,099
applications of these keywords so a

00:36:01,029 --> 00:36:05,680
first application of this keyword which

00:36:03,099 --> 00:36:09,339
is pretty common I see that in practice

00:36:05,680 --> 00:36:11,410
a lot is up by the way I should say it

00:36:09,339 --> 00:36:15,130
was always possible in the derived class

00:36:11,410 --> 00:36:17,440
to place virtual or not this question

00:36:15,130 --> 00:36:19,420
still remains and the answer here but

00:36:17,440 --> 00:36:21,970
the star guard is no you should not use

00:36:19,420 --> 00:36:24,519
vocal there overwrite and final is

00:36:21,970 --> 00:36:27,099
enough as far as I know there is no

00:36:24,519 --> 00:36:31,660
semantic difference writing finally

00:36:27,099 --> 00:36:35,529
again or not so here's the case I'm

00:36:31,660 --> 00:36:37,599
missing in the base class I have a

00:36:35,529 --> 00:36:39,940
member function this member function

00:36:37,599 --> 00:36:43,380
returns the ID and I want to make sure

00:36:39,940 --> 00:36:47,799
that nobody nobody in my whole hierarchy

00:36:43,380 --> 00:36:50,049
can override or hide this funky so can

00:36:47,799 --> 00:36:51,999
replace this function by a different

00:36:50,049 --> 00:36:54,670
code because it's key for my whole

00:36:51,999 --> 00:36:57,970
system that whenever somebody calls gate

00:36:54,670 --> 00:37:00,460
ID I get the ID I computed here the way

00:36:57,970 --> 00:37:04,089
I computed it here it's part of my

00:37:00,460 --> 00:37:08,619
framework that this works right the

00:37:04,089 --> 00:37:12,069
problem is they can without being a

00:37:08,619 --> 00:37:13,809
virtual function you can add a new

00:37:12,069 --> 00:37:16,420
implementation of Girardi with less

00:37:13,809 --> 00:37:19,630
formally not overriding with us formally

00:37:16,420 --> 00:37:21,609
hiding but the effect is similar it is

00:37:19,630 --> 00:37:24,569
it means that if you have a B and you

00:37:21,609 --> 00:37:28,150
call get ID you get its change

00:37:24,569 --> 00:37:32,200
implementation of gate ID so how can I

00:37:28,150 --> 00:37:36,880
prevent that well of course we are final

00:37:32,200 --> 00:37:39,700
great so add final here unfortunately we

00:37:36,880 --> 00:37:44,140
can't add final here because final needs

00:37:39,700 --> 00:37:46,930
virtual functions so I have to advert

00:37:44,140 --> 00:37:49,660
over here also and then there's a solve

00:37:46,930 --> 00:37:51,490
this problem so the rules saying you

00:37:49,660 --> 00:37:53,830
should exactly use only

00:37:51,490 --> 00:37:57,010
one of water override our final is

00:37:53,830 --> 00:38:02,190
broken by this requirement so we at

00:37:57,010 --> 00:38:05,920
least have one exception here and yeah

00:38:02,190 --> 00:38:08,230
by the way for those who getting worried

00:38:05,920 --> 00:38:10,780
now and say wait a minute wait a minute

00:38:08,230 --> 00:38:13,240
virtual isn't that making things bad

00:38:10,780 --> 00:38:16,360
because we now need to run time decision

00:38:13,240 --> 00:38:18,720
and the V table for this no that's not

00:38:16,360 --> 00:38:22,090
true if you're on top of a hierarchy

00:38:18,720 --> 00:38:24,940
then this is not in the B table because

00:38:22,090 --> 00:38:27,010
the compiler knows that this is that

00:38:24,940 --> 00:38:29,890
there can't be any other implementation

00:38:27,010 --> 00:38:32,350
of this so what a final will still be

00:38:29,890 --> 00:38:34,360
used as an inline function and will be

00:38:32,350 --> 00:38:37,270
optimized as an inline function so

00:38:34,360 --> 00:38:39,130
that's the way you can do that so and

00:38:37,270 --> 00:38:43,120
therefore I have a problem with that

00:38:39,130 --> 00:38:45,670
rule and we have applications like this

00:38:43,120 --> 00:38:50,400
even in the standard the standard we

00:38:45,670 --> 00:38:54,550
have here in the in the locales we have

00:38:50,400 --> 00:38:57,910
this this topic implemented we have here

00:38:54,550 --> 00:38:59,950
true name and false name they call the

00:38:57,910 --> 00:39:02,830
virtual function do true name and true

00:38:59,950 --> 00:39:04,960
true false name and the intention is

00:39:02,830 --> 00:39:07,600
that nobody overrides true name and

00:39:04,960 --> 00:39:10,360
false name here just implements new

00:39:07,600 --> 00:39:14,140
weights to return a true of a false

00:39:10,360 --> 00:39:16,330
value by reimplemented to do true name

00:39:14,140 --> 00:39:19,030
and do for sale so an interesting

00:39:16,330 --> 00:39:22,450
question is shouldn't this all the base

00:39:19,030 --> 00:39:24,990
they did not do member fact is you

00:39:22,450 --> 00:39:28,150
shouldn't they all become virtual final

00:39:24,990 --> 00:39:30,130
nobody proposed that yet as far as I

00:39:28,150 --> 00:39:31,930
know but that's a question and that's a

00:39:30,130 --> 00:39:38,470
case where we have this requirement in

00:39:31,930 --> 00:39:40,480
the library so I have an other rule and

00:39:38,470 --> 00:39:43,390
the other rule is interesting totally

00:39:40,480 --> 00:39:45,850
different de my rule is either

00:39:43,390 --> 00:39:50,080
everything is virtual or nothing is

00:39:45,850 --> 00:39:51,880
water except where it can so not in

00:39:50,080 --> 00:39:54,100
constructor aesthetic function friends

00:39:51,880 --> 00:39:57,220
but everywhere else you always write

00:39:54,100 --> 00:40:00,610
little if this is a polymorphic table

00:39:57,220 --> 00:40:03,730
type and otherwise not that's a that's a

00:40:00,610 --> 00:40:05,220
more simple rule to teach I think and if

00:40:03,730 --> 00:40:06,839
somebody has a problem

00:40:05,220 --> 00:40:09,960
because they want don't want to have

00:40:06,839 --> 00:40:11,849
virtuality because they have want to

00:40:09,960 --> 00:40:13,369
have it in line so they mark it with

00:40:11,849 --> 00:40:16,170
finer and they have the effect

00:40:13,369 --> 00:40:18,349
everything is nicely aligned I'm not

00:40:16,170 --> 00:40:21,900
sure whether this is a good rule

00:40:18,349 --> 00:40:22,680
no James is shaking is that oh my

00:40:21,900 --> 00:40:28,440
goodness

00:40:22,680 --> 00:40:30,839
so we have to talk about that ah it's

00:40:28,440 --> 00:40:34,170
terrible okay James say this is terrible

00:40:30,839 --> 00:40:36,540
good I would like to learn why and but I

00:40:34,170 --> 00:40:40,819
mean that's my point here my point here

00:40:36,540 --> 00:40:43,740
is we have different contexts different

00:40:40,819 --> 00:40:47,849
experiences we have different rules

00:40:43,740 --> 00:40:49,950
following from that and then yeah we

00:40:47,849 --> 00:41:09,290
should discuss a couple of hands now

00:40:49,950 --> 00:41:11,819
oh my goodness Timor its run enough okay

00:41:09,290 --> 00:41:14,250
good fine it's okay

00:41:11,819 --> 00:41:19,079
so I don't see why this is a problem

00:41:14,250 --> 00:41:22,650
then to allow that this way to say go to

00:41:19,079 --> 00:41:24,900
final then I don't have a warning then I

00:41:22,650 --> 00:41:35,010
can be sure that this is not over

00:41:24,900 --> 00:41:37,680
written or hidden so you ask me I don't

00:41:35,010 --> 00:41:40,530
trust those who derive from my class yes

00:41:37,680 --> 00:41:43,530
there are contexts where I have to trust

00:41:40,530 --> 00:41:45,300
we have to press them and there are

00:41:43,530 --> 00:41:47,430
contexts where I have a problem when I

00:41:45,300 --> 00:41:49,380
don't trust them yes I agree

00:41:47,430 --> 00:41:52,710
in general we have a problem if we can't

00:41:49,380 --> 00:41:54,930
trust there are other ways too that the

00:41:52,710 --> 00:41:58,260
right classes said then screw up my base

00:41:54,930 --> 00:41:59,520
class yes I agree on that yeah but this

00:41:58,260 --> 00:42:22,140
is just one example

00:41:59,520 --> 00:42:25,530
I think Alistair your head okay yeah

00:42:22,140 --> 00:42:29,220
that's yeah the argument is if I write

00:42:25,530 --> 00:42:31,880
and be virtual final and not on the

00:42:29,220 --> 00:42:35,460
final I don't see that I'm overriding

00:42:31,880 --> 00:42:37,980
but my recommendation then would be to

00:42:35,460 --> 00:42:40,829
say I have to declare it whirlpool final

00:42:37,980 --> 00:42:42,839
override because that's my intention

00:42:40,829 --> 00:42:45,119
here I want to override the base

00:42:42,839 --> 00:42:46,800
function that should be the way you do

00:42:45,119 --> 00:42:48,810
is because with override you say it's my

00:42:46,800 --> 00:42:51,839
intention to override a function in the

00:42:48,810 --> 00:42:54,780
base so yeah we have things to discuss

00:42:51,839 --> 00:42:57,119
here I think we agree on that

00:42:54,780 --> 00:43:03,420
well all you think this guy has no idea

00:42:57,119 --> 00:43:05,579
idea no clue I'm probably beyond the

00:43:03,420 --> 00:43:07,230
average programmer who has similar

00:43:05,579 --> 00:43:10,349
questions and doesn't know the answers

00:43:07,230 --> 00:43:14,579
or someone so let's come to the gas

00:43:10,349 --> 00:43:18,839
target and yeah at least my problem

00:43:14,579 --> 00:43:22,190
would be my case having in the base lies

00:43:18,839 --> 00:43:29,700
the funky that is final is not solved

00:43:22,190 --> 00:43:32,069
good just as a bonus here just to give

00:43:29,700 --> 00:43:35,220
you some examples also that what we have

00:43:32,069 --> 00:43:36,960
we don't we have over loops laps and in

00:43:35,220 --> 00:43:40,410
the style guides but we also in the star

00:43:36,960 --> 00:43:42,450
guide each sagas has its own rules so if

00:43:40,410 --> 00:43:45,240
we combine and match all these targets

00:43:42,450 --> 00:43:47,910
we get a huge repository probably of

00:43:45,240 --> 00:43:50,700
different rules I didn't find this

00:43:47,910 --> 00:43:54,000
anywhere else but I might be wrong so

00:43:50,700 --> 00:43:55,800
this is a again an absolute tip saying

00:43:54,000 --> 00:43:59,970
should you prefer a pushback or and

00:43:55,800 --> 00:44:04,440
place back and the answer is you should

00:43:59,970 --> 00:44:07,410
push back if that's enough don't use too

00:44:04,440 --> 00:44:09,720
much because it might introduce more

00:44:07,410 --> 00:44:13,380
danger with them place back you never

00:44:09,720 --> 00:44:16,109
know whether this is directly taking

00:44:13,380 --> 00:44:19,680
this value to initialize to to say this

00:44:16,109 --> 00:44:21,480
is my new value or for example if in

00:44:19,680 --> 00:44:24,990
place back here the vector two is a

00:44:21,480 --> 00:44:27,720
vector of vectors you might use this as

00:44:24,990 --> 00:44:29,490
the size of a vector in this vector and

00:44:27,720 --> 00:44:33,860
insert the

00:44:29,490 --> 00:44:37,110
or is it 1 million elements here that

00:44:33,860 --> 00:44:39,380
danger you don't have if you use here

00:44:37,110 --> 00:44:48,990
back one and just think you are

00:44:39,380 --> 00:44:53,910
inserting and it although good my

00:44:48,990 --> 00:44:57,540
messages says enough of exam we have a

00:44:53,910 --> 00:45:01,430
mass of C++ filters for good reasons or

00:44:57,540 --> 00:45:05,960
reason we understand is very history etc

00:45:01,430 --> 00:45:12,990
the only way to get out of this mess

00:45:05,960 --> 00:45:15,540
except that we all become huge and great

00:45:12,990 --> 00:45:21,030
C++ programmers understanding all the

00:45:15,540 --> 00:45:22,940
corner cases remember how many issues I

00:45:21,030 --> 00:45:25,680
already raised with my first example is

00:45:22,940 --> 00:45:29,750
we need star guys I think style guides

00:45:25,680 --> 00:45:32,610
our solution to tame the beast here and

00:45:29,750 --> 00:45:34,890
give us remote they don't have to give

00:45:32,610 --> 00:45:37,140
us guidance that we follow all the time

00:45:34,890 --> 00:45:40,320
might be enough to say this is by

00:45:37,140 --> 00:45:42,240
default what we should do and maybe just

00:45:40,320 --> 00:45:44,910
to make it consistent what we teach and

00:45:42,240 --> 00:45:49,859
begin our classes and not that everybody

00:45:44,910 --> 00:45:52,350
teaches something different we have a

00:45:49,859 --> 00:45:54,570
massive star guides that's a problem

00:45:52,350 --> 00:45:57,630
so we need them but we have a mess there

00:45:54,570 --> 00:46:00,119
because C+ was trained or changed over

00:45:57,630 --> 00:46:02,580
time we have different opinions what is

00:46:00,119 --> 00:46:05,100
right we have different context and

00:46:02,580 --> 00:46:08,550
where we use C++ we have different goals

00:46:05,100 --> 00:46:10,340
what we want to do with C++ we have that

00:46:08,550 --> 00:46:13,680
because we don't like change

00:46:10,340 --> 00:46:15,869
we don't know better better yet we have

00:46:13,680 --> 00:46:20,190
legacy tools that don't support the new

00:46:15,869 --> 00:46:24,660
ways and because cleaning this up or the

00:46:20,190 --> 00:46:27,390
star guide needs time and work remember

00:46:24,660 --> 00:46:31,830
that the core guidelines still advertent

00:46:27,390 --> 00:46:33,990
0.8 and the number of updates is going

00:46:31,830 --> 00:46:37,020
down I understand that that's not to

00:46:33,990 --> 00:46:40,460
complain problem is yes it's a huge path

00:46:37,020 --> 00:46:41,930
to tame the beast

00:46:40,460 --> 00:46:44,780
yeah

00:46:41,930 --> 00:46:47,630
and we have the problem of that Tazi we

00:46:44,780 --> 00:46:50,450
have different goals like performance

00:46:47,630 --> 00:46:53,150
where this maintainability safety where

00:46:50,450 --> 00:46:55,809
the spot availability whatsoever we have

00:46:53,150 --> 00:47:02,510
history context so that we can't solve

00:46:55,809 --> 00:47:04,609
so what should we teach how would I

00:47:02,510 --> 00:47:07,010
answer all these I think it's something

00:47:04,609 --> 00:47:10,970
like 20 different questions about this

00:47:07,010 --> 00:47:13,819
class can we agree here on one way we

00:47:10,970 --> 00:47:18,140
teach to beginners is that possible or

00:47:13,819 --> 00:47:20,480
not when I discussed this with a couple

00:47:18,140 --> 00:47:23,869
of guys also in the standard committee

00:47:20,480 --> 00:47:28,760
they said no we don't have to agree on

00:47:23,869 --> 00:47:30,710
that the question is not what should we

00:47:28,760 --> 00:47:32,780
teach the question is only might only be

00:47:30,710 --> 00:47:34,520
when should we teach what because sooner

00:47:32,780 --> 00:47:39,859
or later you have to know all the rules

00:47:34,520 --> 00:47:41,930
that are key for your context and maybe

00:47:39,859 --> 00:47:44,119
it doesn't matter which order you teach

00:47:41,930 --> 00:47:47,200
things as long as you see not sooner or

00:47:44,119 --> 00:47:51,200
later teach everything you need to know

00:47:47,200 --> 00:47:55,280
okay they have multiple paths to become

00:47:51,200 --> 00:47:58,970
a good C++ program maybe we just have to

00:47:55,280 --> 00:48:02,680
accept that okay but then at least we

00:47:58,970 --> 00:48:07,630
have to say that when we teach people us

00:48:02,680 --> 00:48:11,569
to begin and we can also argue that

00:48:07,630 --> 00:48:13,700
different style guides is good we both

00:48:11,569 --> 00:48:15,650
have that discussion yesterday over not

00:48:13,700 --> 00:48:20,380
a beer over what you were playing some

00:48:15,650 --> 00:48:26,569
strange game there on the table

00:48:20,380 --> 00:48:28,460
it's I'm talking to two t titles winters

00:48:26,569 --> 00:48:30,380
who is a child the library working group

00:48:28,460 --> 00:48:32,180
at at Google for app sales so yeah I

00:48:30,380 --> 00:48:36,280
asked him about this and he said we're

00:48:32,180 --> 00:48:41,109
having double circuit is good yeah

00:48:36,280 --> 00:48:41,109
because we have different contacts and

00:48:41,740 --> 00:48:46,970
another other people say maybe we could

00:48:44,450 --> 00:48:49,430
at least follow the way we standardize

00:48:46,970 --> 00:48:53,450
so standard the way we standardize is a

00:48:49,430 --> 00:48:55,310
good criterion to get an idea of what is

00:48:53,450 --> 00:48:57,080
okay so we find

00:48:55,310 --> 00:48:58,490
found out that hidden friends are better

00:48:57,080 --> 00:49:01,400
than not met in France

00:48:58,490 --> 00:49:03,980
so let's you say well but we still

00:49:01,400 --> 00:49:07,010
declare templates with class oh my

00:49:03,980 --> 00:49:10,610
goodness so this is not that big the

00:49:07,010 --> 00:49:15,140
cpap a standard is not a style guide end

00:49:10,610 --> 00:49:17,180
of discussion which would not be a

00:49:15,140 --> 00:49:21,560
problem if not so many people would

00:49:17,180 --> 00:49:23,810
quote from that yeah so here the

00:49:21,560 --> 00:49:28,750
declaration of class vector still uses

00:49:23,810 --> 00:49:31,390
class for the chaplet parameters and

00:49:28,750 --> 00:49:34,430
therefore CP be referenced or come

00:49:31,390 --> 00:49:37,670
nobody looks understand but they all

00:49:34,430 --> 00:49:39,770
look at CPP referenced or come and then

00:49:37,670 --> 00:49:42,350
they Co vector wait a minute the

00:49:39,770 --> 00:49:47,690
arguments are class why that I don't

00:49:42,350 --> 00:49:50,780
it's tightening okay yeah so maybe we

00:49:47,690 --> 00:49:55,480
should at least clean that up because to

00:49:50,780 --> 00:50:00,620
some extent the standard is is a Stiga

00:49:55,480 --> 00:50:04,060
against its own will so what should we

00:50:00,620 --> 00:50:08,270
do let's end up i I have no solution

00:50:04,060 --> 00:50:10,850
this is a talk to raise the problem to

00:50:08,270 --> 00:50:14,720
raise awareness of this problem maybe we

00:50:10,850 --> 00:50:18,710
get some ideas or think about it

00:50:14,720 --> 00:50:20,900
I have no solution I have some ideas no

00:50:18,710 --> 00:50:22,460
not even ideas I have some questions so

00:50:20,900 --> 00:50:24,560
you and maybe we just raise hand

00:50:22,460 --> 00:50:27,920
although erase hands of all the

00:50:24,560 --> 00:50:31,580
different options we have so let's go

00:50:27,920 --> 00:50:36,370
through a couple of RP that life leave

00:50:31,580 --> 00:50:36,370
it as it is it's obviously one option

00:50:36,940 --> 00:50:44,420
require at least that when we proposed

00:50:40,010 --> 00:50:47,060
new C++ feature that we finally require

00:50:44,420 --> 00:50:51,200
that for each and every sea bass bass

00:50:47,060 --> 00:50:53,150
feature there is a few examples or table

00:50:51,200 --> 00:50:55,700
saying what is the difference between

00:50:53,150 --> 00:50:59,630
what was the situation before and after

00:50:55,700 --> 00:51:03,170
or in other words what is the effect for

00:50:59,630 --> 00:51:07,130
style guides of this new feature this is

00:51:03,170 --> 00:51:09,290
not required there it happens very often

00:51:07,130 --> 00:51:12,110
that we don't understand why we standard

00:51:09,290 --> 00:51:17,930
something at least looking back 10 years

00:51:12,110 --> 00:51:19,760
later yeah that's a problem even in the

00:51:17,930 --> 00:51:24,410
comment here we have problems to

00:51:19,760 --> 00:51:28,490
understand and by the way sometimes this

00:51:24,410 --> 00:51:30,080
is good because sometimes we have

00:51:28,490 --> 00:51:32,210
different understanding what this means

00:51:30,080 --> 00:51:35,650
and therefore we vote it in and it

00:51:32,210 --> 00:51:38,060
turned out to be good but have good

00:51:35,650 --> 00:51:43,040
would we have known what we have voted

00:51:38,060 --> 00:51:45,770
in in it's full complexity then we

00:51:43,040 --> 00:51:49,370
wouldn't have voted it in so one example

00:51:45,770 --> 00:51:52,640
is namespace and 1x other examples

00:51:49,370 --> 00:51:58,430
templates in there meta programming

00:51:52,640 --> 00:52:01,070
fashion a separate official style guide

00:51:58,430 --> 00:52:10,310
as part of the standardization that's a

00:52:01,070 --> 00:52:15,760
thorough and we try Ascot Maya's to

00:52:10,310 --> 00:52:20,570
write a new guidance we find another guy

00:52:15,760 --> 00:52:23,540
Steiger improve the standard step by

00:52:20,570 --> 00:52:27,410
step we place for example class by type

00:52:23,540 --> 00:52:29,720
name and I just learn it in the talk

00:52:27,410 --> 00:52:34,520
before concentrate at least on safety

00:52:29,720 --> 00:52:36,890
credible aspects let's take some votes

00:52:34,520 --> 00:52:47,470
here what do you think who is in favor

00:52:36,890 --> 00:52:47,470
of option a3 who's in favor of option B

00:52:48,400 --> 00:53:04,090
but close - ha ha ha - ha establish an

00:52:55,670 --> 00:53:04,090
official style guide a few ok

00:53:05,840 --> 00:53:10,930
I'm to betray us God my ass or okay

00:53:12,849 --> 00:53:21,880
improve the standard step by step to be

00:53:15,560 --> 00:53:24,050
more style conforming okay also ah

00:53:21,880 --> 00:53:31,090
concentrate at least on the safety

00:53:24,050 --> 00:53:40,820
critical aspects okay okay

00:53:31,090 --> 00:53:43,040
so we have a path as a question could I

00:53:40,820 --> 00:53:48,920
change require to provide us a question

00:53:43,040 --> 00:53:51,970
provide no I think we already have

00:53:48,920 --> 00:53:55,970
provide so with we don't we don't

00:53:51,970 --> 00:53:59,390
against papers that explain why they

00:53:55,970 --> 00:54:01,220
want to have the new feature the

00:53:59,390 --> 00:54:04,090
question is should we now require it

00:54:01,220 --> 00:54:04,090
because it didn't work

00:54:04,990 --> 00:54:18,589
require it in time okay so you say in

00:54:13,310 --> 00:54:20,750
case so before the last vote there

00:54:18,589 --> 00:54:23,300
should be an explanation why go on a

00:54:20,750 --> 00:54:25,160
very 1/2 it that should be the last time

00:54:23,300 --> 00:54:27,050
we should have this requirement it might

00:54:25,160 --> 00:54:29,869
not be in the first time we prepare

00:54:27,050 --> 00:54:34,970
present the update because we never know

00:54:29,869 --> 00:54:39,710
what is it accepted by the standard it

00:54:34,970 --> 00:54:41,690
arrived process yeah yeah but but why

00:54:39,710 --> 00:54:44,859
can't an iterative process don't start

00:54:41,690 --> 00:54:47,240
at the beginning with also having these

00:54:44,859 --> 00:54:50,920
effect clauses and then iterates through

00:54:47,240 --> 00:54:53,529
them okay that's it

00:54:50,920 --> 00:54:59,319
that's all I have to say here again no

00:54:53,529 --> 00:55:02,619
solution dusted complain and I and I

00:54:59,319 --> 00:55:05,289
will talk to James why my idea with

00:55:02,619 --> 00:55:08,530
everything verbal or not it's not a good

00:55:05,289 --> 00:55:14,339
idea thank you very much

00:55:08,530 --> 00:55:14,339

YouTube URL: https://www.youtube.com/watch?v=WRQ1xqYBKgc


