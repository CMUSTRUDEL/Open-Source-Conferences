Title: CppCon 2019: Chris Di Bella “What a View! Building Your Own (Lazy) Range Adaptors (part 2 of 2)”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
With their addition to C++20, ranges -- a revamped STL -- are going to send shockwaves through the way in which we design our software. The work from ranges gives us three broad things in C++20: redefined algorithms, concepts to assist in these algorithm definitions, and a handful of range adaptors, which are an abstraction over iterators for convenient program composition.

As Alex Stepanov and Sean Parent have said, the algorithms from the STL are only a sample of the algorithms that exist, and you're able to write your own. Range adaptors are no different: just because the adaptor you need isn't in C++20, doesn't mean that you can't write (or propose) it.

Using custom range adaptors can help you express your intentions in a much clearer manner. We'll spend some time implementing a range adaptor that isn't in the pipeline for C++20, starting from a motivating use-case, then move to how we implement the range adaptor -- including design considerations -- and finally, we'll write up a few tests to wrap everything up.
— 
Christopher Di Bella
Codeplay Software
Staff Software Engineer
Edinburgh, UK

Christopher Di Bella is a Staff Software Engineer for Codeplay’s ComputeCpp Runtime Technology. He is a strong proponent for generic programming in C++ and C++ education. Chris was previously a software developer for Nasdaq, and a tutor for UNSW Australia’s COMP6771 Advanced C++ Programming course in Sydney, Australia. When not geeking out over C++, he enjoys snowboarding, playing games, and watching films.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,290 --> 00:00:12,950
let's resume welcome back if you if you

00:00:11,470 --> 00:00:15,110
were here in the last session

00:00:12,950 --> 00:00:19,100
hands please who's near to this section

00:00:15,110 --> 00:00:23,869
who didn't come to part one you to a

00:00:19,100 --> 00:00:26,060
fine you understand his stuff okay so in

00:00:23,869 --> 00:00:28,340
the previous section it was mostly me

00:00:26,060 --> 00:00:30,259
talking about iterators and the audience

00:00:28,340 --> 00:00:31,730
looking confused because I was talking

00:00:30,259 --> 00:00:34,730
about iterators and a talk that promised

00:00:31,730 --> 00:00:38,329
Rangers that was all motivation for how

00:00:34,730 --> 00:00:39,860
we implement arrange adapter and in this

00:00:38,329 --> 00:00:42,590
particular section were actually going

00:00:39,860 --> 00:00:45,200
to be implementing a range adapter but

00:00:42,590 --> 00:00:46,370
before we continue I need to let you all

00:00:45,200 --> 00:00:48,200
know that I although I work for a

00:00:46,370 --> 00:00:50,780
company this is a personal presentation

00:00:48,200 --> 00:00:52,250
any views opinions or statements

00:00:50,780 --> 00:00:53,690
represented in this presentation are

00:00:52,250 --> 00:00:56,120
personal and belong solely to the

00:00:53,690 --> 00:00:58,280
presentation owner myself and do not

00:00:56,120 --> 00:01:01,040
represent those of people institutions

00:00:58,280 --> 00:01:02,750
or organizations that the owner may or

00:01:01,040 --> 00:01:05,149
may not be associated with in a

00:01:02,750 --> 00:01:11,360
professional or personal capacity unless

00:01:05,149 --> 00:01:12,829
explicitly stated okay so as just a

00:01:11,360 --> 00:01:14,390
brief recap for the people who weren't

00:01:12,829 --> 00:01:16,719
in the room last time

00:01:14,390 --> 00:01:20,420
there are many ranges so there are many

00:01:16,719 --> 00:01:23,389
views in C++ 20 we had streaming view

00:01:20,420 --> 00:01:26,509
from C++ 17 we're getting Spain in C++

00:01:23,389 --> 00:01:28,759
20 those about in namespace stood in

00:01:26,509 --> 00:01:32,600
namespace ranges we get a fourth or more

00:01:28,759 --> 00:01:36,889
but that is not the complete set of

00:01:32,600 --> 00:01:37,520
ranges there are at least 70 in range v3

00:01:36,889 --> 00:01:40,609
which is one of the canonical

00:01:37,520 --> 00:01:43,850
implementations of ranges outside of the

00:01:40,609 --> 00:01:45,679
standard library and even that is just a

00:01:43,850 --> 00:01:47,179
survey of a number of different ranges

00:01:45,679 --> 00:01:49,189
that we can possibly have it's similar

00:01:47,179 --> 00:01:51,889
to the algorithms from the STL they're

00:01:49,189 --> 00:01:53,539
only a survey which is me paraphrasing

00:01:51,889 --> 00:01:56,749
Shawn parent paraphrasing out sender

00:01:53,539 --> 00:01:58,880
Stepanov the next thing to explain or to

00:01:56,749 --> 00:02:00,819
talk about is that we have this concept

00:01:58,880 --> 00:02:03,829
called of view we say that a view

00:02:00,819 --> 00:02:05,920
refines the concept of a range where the

00:02:03,829 --> 00:02:09,560
range is semi regular that is that it is

00:02:05,920 --> 00:02:12,170
copyable and default constructible and

00:02:09,560 --> 00:02:14,450
that there's a boolean called enable

00:02:12,170 --> 00:02:17,660
view that allows us to opt into being a

00:02:14,450 --> 00:02:20,360
view and then we also have semantic

00:02:17,660 --> 00:02:21,950
requirements that basically state that

00:02:20,360 --> 00:02:23,930
we need to have a constant time copy a

00:02:21,950 --> 00:02:25,909
constant time mood constant time

00:02:23,930 --> 00:02:27,750
assignment operation and constant time

00:02:25,909 --> 00:02:30,000
destructive bill

00:02:27,750 --> 00:02:32,130
then we talked about slice view which is

00:02:30,000 --> 00:02:33,960
essentially taking a few elements from

00:02:32,130 --> 00:02:36,080
the range but discounting things that

00:02:33,960 --> 00:02:37,800
come before the the position we want and

00:02:36,080 --> 00:02:39,380
ignoring things that come up to the

00:02:37,800 --> 00:02:42,540
position we say that reaches the end

00:02:39,380 --> 00:02:45,480
these are both examples of different

00:02:42,540 --> 00:02:48,210
slices and we talked about how it's

00:02:45,480 --> 00:02:54,180
possible to implement a slice range

00:02:48,210 --> 00:02:56,790
adapter closure using the using a lambda

00:02:54,180 --> 00:02:59,100
and things that we have in C++ 20 so

00:02:56,790 --> 00:03:03,030
it's not exactly an interesting

00:02:59,100 --> 00:03:04,890
particular range adapter then we talked

00:03:03,030 --> 00:03:07,680
about stripe view which is something

00:03:04,890 --> 00:03:10,380
that can't be can't be implemented in

00:03:07,680 --> 00:03:12,690
terms of another range adapter in C++ 20

00:03:10,380 --> 00:03:15,810
so this is an example of a stripe view

00:03:12,690 --> 00:03:17,100
where these strategies size 1 and that

00:03:15,810 --> 00:03:19,920
means we consider all the elements in

00:03:17,100 --> 00:03:21,180
the range then we have a stride of with

00:03:19,920 --> 00:03:24,120
the strategize to means we consider

00:03:21,180 --> 00:03:26,370
every second element and a stride of

00:03:24,120 --> 00:03:29,280
size 3 means that we cut there we only

00:03:26,370 --> 00:03:31,890
consider every third element and this is

00:03:29,280 --> 00:03:33,239
where we go where we finished off and so

00:03:31,890 --> 00:03:37,440
in it we're now going to go and look at

00:03:33,239 --> 00:03:39,120
how to implement strategy in C++ 20 now

00:03:37,440 --> 00:03:42,709
everything that I'm about to show you

00:03:39,120 --> 00:03:48,600
has been present so has been checked on

00:03:42,709 --> 00:03:51,000
MSB sees preview 3 and I checked it last

00:03:48,600 --> 00:03:53,760
night so everything should be working

00:03:51,000 --> 00:03:55,500
fine if if you find that there is

00:03:53,760 --> 00:03:57,300
something that I that I missed just

00:03:55,500 --> 00:03:59,610
please send me an email

00:03:57,300 --> 00:04:02,220
it's the fastest way for me to update

00:03:59,610 --> 00:04:05,610
the slides so we had any further ado

00:04:02,220 --> 00:04:08,100
let's let's move on so the first thing

00:04:05,610 --> 00:04:09,959
we do is we define this this type called

00:04:08,100 --> 00:04:13,800
stride view and we say that it is

00:04:09,959 --> 00:04:15,180
derived from this other type called view

00:04:13,800 --> 00:04:18,239
interface now the view interface we'll

00:04:15,180 --> 00:04:21,930
come back to about midway through this

00:04:18,239 --> 00:04:23,880
presentation but what it gives us

00:04:21,930 --> 00:04:26,040
immediately is that enable view

00:04:23,880 --> 00:04:29,669
essentially view interface has a

00:04:26,040 --> 00:04:33,870
property in it that turns on enable view

00:04:29,669 --> 00:04:36,870
and so that it is unique and we can

00:04:33,870 --> 00:04:38,780
access all the elements properly we rely

00:04:36,870 --> 00:04:41,930
on CIT p2

00:04:38,780 --> 00:04:44,300
to produce strive you as part of its

00:04:41,930 --> 00:04:49,340
time now what we also require is that

00:04:44,300 --> 00:04:51,980
our template parameter requires it needs

00:04:49,340 --> 00:04:54,200
some model the the concept of an input

00:04:51,980 --> 00:04:57,290
range recall that an input range is a

00:04:54,200 --> 00:04:59,840
range that has an iterator whose type

00:04:57,290 --> 00:05:06,260
models and input iterator and then we

00:04:59,840 --> 00:05:09,050
also require that models a view then

00:05:06,260 --> 00:05:12,110
what we do is we require that we provide

00:05:09,050 --> 00:05:13,300
a default constructor because we need a

00:05:12,110 --> 00:05:17,060
semi-regular

00:05:13,300 --> 00:05:19,430
type and we also have a constructor that

00:05:17,060 --> 00:05:21,260
actually allows us to provide meaningful

00:05:19,430 --> 00:05:25,310
information that being we pass in a

00:05:21,260 --> 00:05:27,890
range and we pass in a different type of

00:05:25,310 --> 00:05:29,960
the iterator to the straight now in the

00:05:27,890 --> 00:05:32,450
last session we talked about it's a

00:05:29,960 --> 00:05:37,760
difference T range difference T and in a

00:05:32,450 --> 00:05:40,100
difference T related so we have if we

00:05:37,760 --> 00:05:41,930
take the range difference T of a

00:05:40,100 --> 00:05:44,330
particular range then it would give us

00:05:41,930 --> 00:05:45,620
the equivalent type from the ISA

00:05:44,330 --> 00:05:47,150
difference T of the corresponding

00:05:45,620 --> 00:05:50,540
iterator to the range it's just a

00:05:47,150 --> 00:05:52,900
shorthand that way out a nested types

00:05:50,540 --> 00:05:56,780
don't spiral out of control

00:05:52,900 --> 00:05:58,940
then we have to to help functions

00:05:56,780 --> 00:06:00,800
basically we get the base back the base

00:05:58,940 --> 00:06:04,850
refers to the bass range whatever we

00:06:00,800 --> 00:06:06,320
passed in and we get back the stride so

00:06:04,850 --> 00:06:08,060
we're able to get all these all the

00:06:06,320 --> 00:06:12,710
necessary information should we actually

00:06:08,060 --> 00:06:16,730
want to use it and then because we have

00:06:12,710 --> 00:06:18,770
a range we want to have a begin and an

00:06:16,730 --> 00:06:20,260
end we want to provide the both the

00:06:18,770 --> 00:06:24,830
constant qualified and non-qualified

00:06:20,260 --> 00:06:26,900
overloads and then we also have a size

00:06:24,830 --> 00:06:29,750
function which gives us back our size in

00:06:26,900 --> 00:06:32,300
constant time now there is a concept on

00:06:29,750 --> 00:06:34,000
here we are requiring that the

00:06:32,300 --> 00:06:37,310
underlying range of the base range

00:06:34,000 --> 00:06:39,230
models a sized range now we talked about

00:06:37,310 --> 00:06:40,669
in the previous session a site of the

00:06:39,230 --> 00:06:44,270
concept of a size Sentinel for an

00:06:40,669 --> 00:06:48,260
iterator and these two concepts are not

00:06:44,270 --> 00:06:50,870
related a sized range is something that

00:06:48,260 --> 00:06:51,800
basically says can we call range of size

00:06:50,870 --> 00:06:55,099
on this round

00:06:51,800 --> 00:06:57,280
change and get back these the number of

00:06:55,099 --> 00:07:00,940
elements in the range in constant time

00:06:57,280 --> 00:07:03,139
so an example of something that models a

00:07:00,940 --> 00:07:05,900
size range is a vector

00:07:03,139 --> 00:07:09,110
another one is a list but unlike vector

00:07:05,900 --> 00:07:11,990
lists iterator does not model a size

00:07:09,110 --> 00:07:14,979
Sentinel for for its iterator because we

00:07:11,990 --> 00:07:17,090
do not have we're not able to get the

00:07:14,979 --> 00:07:20,780
the number of elements between two

00:07:17,090 --> 00:07:23,229
iterators in constant time are there any

00:07:20,780 --> 00:07:28,580
questions on that

00:07:23,229 --> 00:07:31,280
C no okay so the detail section is that

00:07:28,580 --> 00:07:33,319
we have a type called D which we're

00:07:31,280 --> 00:07:36,319
going to use as a shorthand for the

00:07:33,319 --> 00:07:38,780
range difference of the of the range and

00:07:36,319 --> 00:07:41,090
we store the range make make sure

00:07:38,780 --> 00:07:44,330
everything is default constructed and we

00:07:41,090 --> 00:07:46,069
store the the Strad as well we'll also

00:07:44,330 --> 00:07:48,229
have a type called an iterator this is

00:07:46,069 --> 00:07:51,919
really why the whole previous section

00:07:48,229 --> 00:07:53,090
was important and the it's it's template

00:07:51,919 --> 00:07:54,379
to reduce the amount of code we have to

00:07:53,090 --> 00:07:56,680
write so we have to write one iterator

00:07:54,379 --> 00:08:01,610
with a bit of extra complexity but

00:07:56,680 --> 00:08:05,599
significantly less code duplication that

00:08:01,610 --> 00:08:07,849
is pretty much copy paste and then we

00:08:05,599 --> 00:08:09,440
also have a static function called in

00:08:07,849 --> 00:08:11,779
implementation this will become very

00:08:09,440 --> 00:08:13,930
important toward the end of this the

00:08:11,779 --> 00:08:17,360
session about 3/4 of the way through and

00:08:13,930 --> 00:08:19,729
finally we have a an algorithm called

00:08:17,360 --> 00:08:21,289
compute distance that will tell us the

00:08:19,729 --> 00:08:24,560
number of elements that are actually in

00:08:21,289 --> 00:08:26,090
the range finally we need to provide a

00:08:24,560 --> 00:08:27,560
deduction guide and a deduction guide

00:08:26,090 --> 00:08:31,789
allows us to not have to specify what

00:08:27,560 --> 00:08:33,640
the what the type parameters are we can

00:08:31,789 --> 00:08:36,680
just call strive view with a range and

00:08:33,640 --> 00:08:40,789
and a distance and what we say is that

00:08:36,680 --> 00:08:43,669
the type of the straight view is for any

00:08:40,789 --> 00:08:46,130
given range or any given reference to a

00:08:43,669 --> 00:08:49,370
range we have this thing called all view

00:08:46,130 --> 00:08:51,940
which allows us to adapt a range that

00:08:49,370 --> 00:08:54,860
doesn't model of you into a view and

00:08:51,940 --> 00:08:58,220
that's what the that's what the viewable

00:08:54,860 --> 00:09:02,390
range concept is also requiring can we

00:08:58,220 --> 00:09:05,630
intake a range that that may may or may

00:09:02,390 --> 00:09:10,389
not be a view and adapt it into a view

00:09:05,630 --> 00:09:14,420
and for those who are new to the session

00:09:10,389 --> 00:09:17,750
the depth range adapter is something

00:09:14,420 --> 00:09:20,269
that you know that is a it takes a range

00:09:17,750 --> 00:09:23,209
a viewable range as its input and gives

00:09:20,269 --> 00:09:24,980
us back a view that may have altering

00:09:23,209 --> 00:09:31,060
properties that way we can produce some

00:09:24,980 --> 00:09:33,920
sort of transformative operation the the

00:09:31,060 --> 00:09:36,829
I'm sorry okay

00:09:33,920 --> 00:09:38,440
so let's move on to the constructor it's

00:09:36,829 --> 00:09:41,690
very straightforward we're just simply

00:09:38,440 --> 00:09:43,850
constructing the elements and putting me

00:09:41,690 --> 00:09:47,240
putting the things we get from the

00:09:43,850 --> 00:09:48,709
constructor into our elements our our

00:09:47,240 --> 00:09:49,519
base and our stride are fairly

00:09:48,709 --> 00:09:53,000
straightforward

00:09:49,519 --> 00:09:57,740
we're simply returning the the members

00:09:53,000 --> 00:10:01,279
and here we come to the getting the

00:09:57,740 --> 00:10:06,199
iterator and the sentinel so we begin

00:10:01,279 --> 00:10:11,240
it's fairly straightforward we have the

00:10:06,199 --> 00:10:14,290
non consequently we have we have a false

00:10:11,240 --> 00:10:17,600
and for the consequent we pass intrude

00:10:14,290 --> 00:10:20,120
for end we're just going to defer to end

00:10:17,600 --> 00:10:21,920
in pull and although it seems a bit

00:10:20,120 --> 00:10:27,819
redundant at this point we're going to

00:10:21,920 --> 00:10:29,990
simply call Ranger's end on on the base

00:10:27,819 --> 00:10:33,889
what we'll do is we'll come back to this

00:10:29,990 --> 00:10:35,509
a little bit later on and we will refine

00:10:33,889 --> 00:10:38,329
it so that way it makes a bit more sense

00:10:35,509 --> 00:10:40,160
but for now it's really just something

00:10:38,329 --> 00:10:45,500
that's a bit boilerplate oh I see a

00:10:40,160 --> 00:10:52,100
question could I give an example of a

00:10:45,500 --> 00:10:54,740
range that is not viewable a temporary

00:10:52,100 --> 00:10:58,779
container thank you Eric

00:10:54,740 --> 00:11:01,189
thank you I blanked on that yes so

00:10:58,779 --> 00:11:04,519
temporaries are not viewable for

00:11:01,189 --> 00:11:08,509
lifetime reasons I believe I see a knot

00:11:04,519 --> 00:11:10,370
there okay so here we have these sides

00:11:08,509 --> 00:11:14,059
and we're going to call range of size

00:11:10,370 --> 00:11:16,339
because we have a sized range what's the

00:11:14,059 --> 00:11:18,290
problem with this I mean beside the fact

00:11:16,339 --> 00:11:18,940
that I've got obviously lots of white

00:11:18,290 --> 00:11:20,380
space there

00:11:18,940 --> 00:11:22,660
that's alluding to something else being

00:11:20,380 --> 00:11:30,370
added what what might be the problem of

00:11:22,660 --> 00:11:31,750
just calling range of size on a base it

00:11:30,370 --> 00:11:33,730
doesn't take into account the fact that

00:11:31,750 --> 00:11:35,710
the strive will make it skip elements

00:11:33,730 --> 00:11:39,280
that is absolutely correct and so what

00:11:35,710 --> 00:11:41,230
we do is we we pass him we pass the size

00:11:39,280 --> 00:11:44,530
actually in to compute distance and we

00:11:41,230 --> 00:11:47,950
define compute distance as such

00:11:44,530 --> 00:11:51,040
essentially what we do is we we we take

00:11:47,950 --> 00:11:53,860
the we divide it by the number of

00:11:51,040 --> 00:11:54,970
elements that so we divide up the number

00:11:53,860 --> 00:11:57,550
of elements that we had in the full

00:11:54,970 --> 00:12:00,670
range by the stride and then there may

00:11:57,550 --> 00:12:03,760
be a few left over because there may

00:12:00,670 --> 00:12:06,760
there may be some extra elements but and

00:12:03,760 --> 00:12:08,710
in that case then what's gonna happen is

00:12:06,760 --> 00:12:11,920
we need to consider that that case and

00:12:08,710 --> 00:12:15,280
add that to how they many elements were

00:12:11,920 --> 00:12:18,190
going to be stepping over now the reason

00:12:15,280 --> 00:12:19,870
it's an requiring an integral instead of

00:12:18,190 --> 00:12:23,830
just taking the range different is

00:12:19,870 --> 00:12:26,830
because arranger size its type may or

00:12:23,830 --> 00:12:27,910
may not be signed where and so we need

00:12:26,830 --> 00:12:29,680
to account for that

00:12:27,910 --> 00:12:33,910
but we are also going to be passing in a

00:12:29,680 --> 00:12:38,650
type that is potentially signed so this

00:12:33,910 --> 00:12:41,800
is a more an easier way to describe this

00:12:38,650 --> 00:12:43,870
instead of having two overloads and then

00:12:41,800 --> 00:12:47,260
we move on to defining the iterator so

00:12:43,870 --> 00:12:49,960
the first thing we do is we we provide

00:12:47,260 --> 00:12:52,240
the structure for it and what we're

00:12:49,960 --> 00:12:53,710
going to do is we're going to define a

00:12:52,240 --> 00:12:55,540
few types so when we're talking about

00:12:53,710 --> 00:12:58,840
the parent we're actually referring to a

00:12:55,540 --> 00:13:01,090
possibly Const qualified version of the

00:12:58,840 --> 00:13:03,580
stripe you may be Const what it does it

00:13:01,090 --> 00:13:06,430
takes a parameter so it takes a boolean

00:13:03,580 --> 00:13:08,290
to indicate is the iterator Const and if

00:13:06,430 --> 00:13:09,700
it is then it can't qualify straight

00:13:08,290 --> 00:13:12,100
view otherwise we're just referring to a

00:13:09,700 --> 00:13:16,420
mutable straight view the base is a

00:13:12,100 --> 00:13:22,270
possibly consequence of aa and we're

00:13:16,420 --> 00:13:25,390
going to say that the the nan say there

00:13:22,270 --> 00:13:28,060
the inverse constants of the the

00:13:25,390 --> 00:13:31,240
iterator is a friend of iterator type

00:13:28,060 --> 00:13:33,110
they're actually working in we also want

00:13:31,240 --> 00:13:36,980
to have a pointer to the pair

00:13:33,110 --> 00:13:38,930
and that that will allow us to actually

00:13:36,980 --> 00:13:41,029
get the stride and work with things a

00:13:38,930 --> 00:13:42,860
little bit more easily we're going to

00:13:41,029 --> 00:13:45,710
have an iterator to the current element

00:13:42,860 --> 00:13:48,110
that we're actually at and then we're

00:13:45,710 --> 00:13:49,430
going to store this thing called step

00:13:48,110 --> 00:13:50,920
we'll come back to step much later on

00:13:49,430 --> 00:13:54,800
it's not important right now

00:13:50,920 --> 00:13:56,510
then we have an a member function called

00:13:54,800 --> 00:14:00,440
advance this will allow us to actually

00:13:56,510 --> 00:14:03,589
take arbitrary steps and finally we have

00:14:00,440 --> 00:14:04,880
a helper function called compute

00:14:03,589 --> 00:14:09,070
distance because friendship is not

00:14:04,880 --> 00:14:13,370
transitive and so just because the

00:14:09,070 --> 00:14:14,690
friend operations are friends to the

00:14:13,370 --> 00:14:17,770
iterator that doesn't mean difference to

00:14:14,690 --> 00:14:20,930
the parent so we need to define this

00:14:17,770 --> 00:14:22,460
locally and so when you see compute

00:14:20,930 --> 00:14:26,120
distance it's really just deferring to

00:14:22,460 --> 00:14:29,960
the parents compute distance next up we

00:14:26,120 --> 00:14:32,120
need to define the the difference type

00:14:29,960 --> 00:14:34,820
and the value type these are just gotten

00:14:32,120 --> 00:14:38,900
we just get these from the base of the

00:14:34,820 --> 00:14:39,380
of the range and then we also add this

00:14:38,900 --> 00:14:43,220
thing called

00:14:39,380 --> 00:14:44,480
iterated category and it's a bit it's

00:14:43,220 --> 00:14:46,160
been involved so I'm going to take a

00:14:44,480 --> 00:14:48,500
moment here the first thing we need to

00:14:46,160 --> 00:14:52,490
do is make sure that we are not saying

00:14:48,500 --> 00:14:56,360
we have a a continuous iterator because

00:14:52,490 --> 00:14:58,190
a complete being having a stride is the

00:14:56,360 --> 00:15:01,250
exact opposite of being continuous the

00:14:58,190 --> 00:15:02,839
elements are sparse instead of compact

00:15:01,250 --> 00:15:05,029
together so all we say is that if it

00:15:02,839 --> 00:15:09,040
models random access via range models

00:15:05,029 --> 00:15:11,209
random access range then we're going to

00:15:09,040 --> 00:15:12,950
we're going to say that it's a random

00:15:11,209 --> 00:15:14,120
access the iterator otherwise what we're

00:15:12,950 --> 00:15:16,370
going to do is we gained into fir - this

00:15:14,120 --> 00:15:18,800
is other type that looks at what's

00:15:16,370 --> 00:15:21,910
inside the iterator traits of our

00:15:18,800 --> 00:15:24,890
underlying Ranger's iterator type and

00:15:21,910 --> 00:15:27,350
get the iterator tag from that so it's a

00:15:24,890 --> 00:15:29,060
bi-directional iterator then we'll get

00:15:27,350 --> 00:15:36,529
that tag and if it's a forward iterator

00:15:29,060 --> 00:15:39,709
we'll get that term and so on been so

00:15:36,529 --> 00:15:40,700
been asked my am i saying that if random

00:15:39,709 --> 00:15:43,459
access range would normally give us a

00:15:40,700 --> 00:15:45,350
continuously Doretta tag it won't do

00:15:43,459 --> 00:15:46,310
that well what a sorry I I think I

00:15:45,350 --> 00:15:49,360
misspoke what

00:15:46,310 --> 00:15:52,180
mint was that a continuous iterator

00:15:49,360 --> 00:15:54,320
models the random access iterator

00:15:52,180 --> 00:15:58,520
requirements because it's a refinement

00:15:54,320 --> 00:16:00,529
and so if we meet the requirements of a

00:15:58,520 --> 00:16:01,610
random access iterator we can bail there

00:16:00,529 --> 00:16:04,490
and just say it's a random access

00:16:01,610 --> 00:16:05,839
iterator because we've already met all

00:16:04,490 --> 00:16:07,190
the requirements that are necessary but

00:16:05,839 --> 00:16:10,130
if we consider that it was a continuous

00:16:07,190 --> 00:16:11,089
iterator then we're just doing a little

00:16:10,130 --> 00:16:12,680
of extra work and then we're going to

00:16:11,089 --> 00:16:18,680
say it's a random access iterator anyway

00:16:12,680 --> 00:16:24,020
does that answer the question okay are

00:16:18,680 --> 00:16:26,960
there any other questions I see none all

00:16:24,020 --> 00:16:28,910
right so now let's define some more some

00:16:26,960 --> 00:16:30,650
of the public member functions and so

00:16:28,910 --> 00:16:33,050
what we're going to do here is we again

00:16:30,650 --> 00:16:35,570
need to model the semi-regular concept

00:16:33,050 --> 00:16:38,060
so we have a default constructor that's

00:16:35,570 --> 00:16:40,010
fairly uninteresting we have an explicit

00:16:38,060 --> 00:16:43,279
constructor that gets the details of the

00:16:40,010 --> 00:16:45,110
parent and puts them into the into the

00:16:43,279 --> 00:16:47,300
elevator what we have here is we take

00:16:45,110 --> 00:16:50,660
the address of the parent and then we

00:16:47,300 --> 00:16:59,360
call begin on the parent base and we

00:16:50,660 --> 00:17:00,680
store that I said so the question is is

00:16:59,360 --> 00:17:02,510
there a reason to use a pointer instead

00:17:00,680 --> 00:17:05,540
of a reference to the parent and I

00:17:02,510 --> 00:17:08,990
believe that is for standard layout

00:17:05,540 --> 00:17:12,380
reasons but I could be wrong copy

00:17:08,990 --> 00:17:14,380
ability thank you yes that makes more

00:17:12,380 --> 00:17:16,730
sense

00:17:14,380 --> 00:17:22,189
copy ability and assignment yes thank

00:17:16,730 --> 00:17:26,179
you cool

00:17:22,189 --> 00:17:30,080
the next thing to to look at is the is

00:17:26,179 --> 00:17:34,700
the non const that we constructed that I

00:17:30,080 --> 00:17:35,810
talked about earlier so what we sorry I

00:17:34,700 --> 00:17:37,520
didn't talk about it I took that friend

00:17:35,810 --> 00:17:42,730
earlier and what we're going to do here

00:17:37,520 --> 00:17:46,360
is we're going to say that the Const

00:17:42,730 --> 00:17:49,820
iterator or the consequently iterator is

00:17:46,360 --> 00:17:53,390
allowed to construct an iterator from

00:17:49,820 --> 00:17:55,910
the non Const version of the iterator

00:17:53,390 --> 00:17:58,580
and so what we say here is that we have

00:17:55,910 --> 00:18:02,620
we have a dependent context

00:17:58,580 --> 00:18:08,210
and we're going to construct an iterator

00:18:02,620 --> 00:18:11,210
based on that when only when is Const is

00:18:08,210 --> 00:18:14,750
true and we can convert an iterator from

00:18:11,210 --> 00:18:17,179
the from the underlying range type to

00:18:14,750 --> 00:18:18,799
the possibly Const qualified range type

00:18:17,179 --> 00:18:20,450
and then we're just going to steal the

00:18:18,799 --> 00:18:22,549
data otherwise it's not a copy

00:18:20,450 --> 00:18:34,190
constructor but it does look like a copy

00:18:22,549 --> 00:18:36,860
constructor Margaret so the question is

00:18:34,190 --> 00:18:40,220
why is there a template head there that

00:18:36,860 --> 00:18:41,990
says ball constitu is it equals copy is

00:18:40,220 --> 00:18:43,850
constant is that correct so the reason

00:18:41,990 --> 00:18:45,679
for that is because we need to force

00:18:43,850 --> 00:18:48,200
this to be a dependent context otherwise

00:18:45,679 --> 00:18:50,570
the the compiler is basically going to

00:18:48,200 --> 00:18:52,490
say well this is this is a copy

00:18:50,570 --> 00:18:55,669
constructor in the non-constant case and

00:18:52,490 --> 00:18:57,889
that because it's it's got all this

00:18:55,669 --> 00:19:01,429
extra stuff on it just doesn't work so

00:18:57,889 --> 00:19:03,289
that's essentially why it's there it's

00:19:01,429 --> 00:19:04,760
something you would experience in

00:19:03,289 --> 00:19:06,200
template metaprogramming a lot it's

00:19:04,760 --> 00:19:10,309
unfortunate that it still needs to be

00:19:06,200 --> 00:19:14,149
there does that answer the question

00:19:10,309 --> 00:19:16,820
cool okay so next up we have the base

00:19:14,149 --> 00:19:21,970
operation which just gets us a the base

00:19:16,820 --> 00:19:24,169
iterator which is the current one and

00:19:21,970 --> 00:19:28,070
then we have the import iterator

00:19:24,169 --> 00:19:32,000
operations so for this we need to have

00:19:28,070 --> 00:19:35,330
the source or the dereference operation

00:19:32,000 --> 00:19:37,610
and we have the successor we just defer

00:19:35,330 --> 00:19:39,559
that to advance which will be on the

00:19:37,610 --> 00:19:44,389
next slide and then you'll notice that

00:19:39,559 --> 00:19:46,460
the the postfix iterator is a increment

00:19:44,389 --> 00:19:48,289
operation it has a return type of void

00:19:46,460 --> 00:19:51,080
now if you have written an iterator

00:19:48,289 --> 00:19:54,919
before then you will potentially be

00:19:51,080 --> 00:19:57,940
surprised by this the definition of of

00:19:54,919 --> 00:20:00,200
an input iterator here requires that

00:19:57,940 --> 00:20:04,690
it's weekly incremental and what that

00:20:00,200 --> 00:20:08,029
means is that it has to have a prefix

00:20:04,690 --> 00:20:09,770
increment operation that is there

00:20:08,029 --> 00:20:12,450
returns a reference to the same iterator

00:20:09,770 --> 00:20:14,370
but the postfix just needs to

00:20:12,450 --> 00:20:16,320
exist it doesn't actually have any

00:20:14,370 --> 00:20:19,610
mandate of return side we'll come back

00:20:16,320 --> 00:20:23,370
to the postfix one in just a few minutes

00:20:19,610 --> 00:20:27,600
but first off we will we'll look at the

00:20:23,370 --> 00:20:30,690
advance the advance operation and that

00:20:27,600 --> 00:20:32,820
takes a difference type and so what we

00:20:30,690 --> 00:20:35,280
do is we call advance and we multiply

00:20:32,820 --> 00:20:38,070
the number of steps we want to take by

00:20:35,280 --> 00:20:41,370
the stride and so what that will do is

00:20:38,070 --> 00:20:44,310
it will increment current but if we have

00:20:41,370 --> 00:20:46,080
something that models a random access

00:20:44,310 --> 00:20:47,610
iterator it can do that in constant time

00:20:46,080 --> 00:20:50,040
so we don't have to have a loop that

00:20:47,610 --> 00:20:52,650
just iterates over that so now it's an

00:20:50,040 --> 00:20:55,380
algorithm helper and the reason we have

00:20:52,650 --> 00:20:57,090
the ranges end at the as the last

00:20:55,380 --> 00:20:58,890
parameter what that means is that once

00:20:57,090 --> 00:21:01,230
we reach the end we're not going to try

00:20:58,890 --> 00:21:03,450
and go any further it's a case of we

00:21:01,230 --> 00:21:09,030
we've we've terminated let's just stop

00:21:03,450 --> 00:21:12,060
yeah and this works for board ranges and

00:21:09,030 --> 00:21:13,380
input ranges but it doesn't work for

00:21:12,060 --> 00:21:14,550
bi-directional rangers because we can

00:21:13,380 --> 00:21:16,290
also go backwards with bi-directional

00:21:14,550 --> 00:21:19,590
ranges so what we need to do is we need

00:21:16,290 --> 00:21:21,960
to provide a way of moving backwards

00:21:19,590 --> 00:21:25,110
that's what we do is we check that if

00:21:21,960 --> 00:21:27,240
we're a bi-directional range and then we

00:21:25,110 --> 00:21:30,480
also check that the direction we want to

00:21:27,240 --> 00:21:32,610
move is backwards we move in the

00:21:30,480 --> 00:21:34,950
opposite direction so our Sentinel is

00:21:32,610 --> 00:21:37,290
now going to be the first element to the

00:21:34,950 --> 00:21:42,570
range and we stop then are there any

00:21:37,290 --> 00:21:43,830
questions about that I see none okay so

00:21:42,570 --> 00:21:46,140
then we have to care about the

00:21:43,830 --> 00:21:48,690
comparison operations and so we check

00:21:46,140 --> 00:21:53,450
that current is equal to other and then

00:21:48,690 --> 00:21:56,310
we also have a an operator for checking

00:21:53,450 --> 00:21:58,680
not just against a sentinel but also

00:21:56,310 --> 00:22:01,590
against an iterator when the iterator is

00:21:58,680 --> 00:22:03,150
a quality comparable with with itself

00:22:01,590 --> 00:22:06,840
now if you have a forward iterator you

00:22:03,150 --> 00:22:08,580
get this for free but in the event that

00:22:06,840 --> 00:22:13,470
you don't have a forward iterator what

00:22:08,580 --> 00:22:16,490
this means is that you have yeah you

00:22:13,470 --> 00:22:20,420
have to make sure that the iterator is

00:22:16,490 --> 00:22:22,860
has both equal to and not equal to

00:22:20,420 --> 00:22:26,370
implemented and the operation is

00:22:22,860 --> 00:22:29,370
reflexive symmetric and transitive

00:22:26,370 --> 00:22:33,510
and thanks to the spaceship operator in

00:22:29,370 --> 00:22:36,390
C++ 20 we don't have to specify anything

00:22:33,510 --> 00:22:37,920
else for equality we don't have to

00:22:36,390 --> 00:22:40,790
specify the not equal to operations

00:22:37,920 --> 00:22:42,840
because those are the compiler does

00:22:40,790 --> 00:22:46,800
there's some extra steps to make sure

00:22:42,840 --> 00:22:49,260
that we we get that when we say X is not

00:22:46,800 --> 00:22:51,750
equal to Y and in the case of the

00:22:49,260 --> 00:22:56,340
sentinel we don't have to provide the

00:22:51,750 --> 00:22:58,980
the friend that would say and we have a

00:22:56,340 --> 00:23:01,230
sentinel and an iterator because the

00:22:58,980 --> 00:23:03,360
spaceship operator also takes care of

00:23:01,230 --> 00:23:05,400
that yonathan mula is giving a talk

00:23:03,360 --> 00:23:06,660
later today I'm at the spaceship

00:23:05,400 --> 00:23:09,410
operator so if you're curious about that

00:23:06,660 --> 00:23:12,540
I highly recommend you go and watch that

00:23:09,410 --> 00:23:15,450
then we we move on to the forward range

00:23:12,540 --> 00:23:18,390
version of iterator so the increment and

00:23:15,450 --> 00:23:21,360
the forward rain oh sorry a forward

00:23:18,390 --> 00:23:25,010
iterator requires we model a concept

00:23:21,360 --> 00:23:27,720
called incremental and this incremental

00:23:25,010 --> 00:23:31,950
refines what weekly incremental does and

00:23:27,720 --> 00:23:36,179
it means that the software the postfix

00:23:31,950 --> 00:23:39,590
increment operation needs to need to

00:23:36,179 --> 00:23:41,130
return an object of type iterator and

00:23:39,590 --> 00:23:43,530
that's what we're doing here we're

00:23:41,130 --> 00:23:44,850
taking a copy and we are going to

00:23:43,530 --> 00:23:48,030
increment the current one and then we

00:23:44,850 --> 00:23:50,970
return the copy and what we do is we put

00:23:48,030 --> 00:23:55,740
on a requires clause saying that we only

00:23:50,970 --> 00:23:58,410
require this operation exists if and

00:23:55,740 --> 00:24:00,090
only if we have a base modeling forward

00:23:58,410 --> 00:24:02,309
range so it's not there when we have an

00:24:00,090 --> 00:24:04,140
input range the the compiler won't

00:24:02,309 --> 00:24:05,700
consider it and then any event that we

00:24:04,140 --> 00:24:07,260
do have a board range only this one will

00:24:05,700 --> 00:24:10,620
be considered are there any questions

00:24:07,260 --> 00:24:13,650
about that okay

00:24:10,620 --> 00:24:15,059
actually no the next thing to do is to

00:24:13,650 --> 00:24:20,280
consider the bi-directional range

00:24:15,059 --> 00:24:22,830
case and that is for moving backwards

00:24:20,280 --> 00:24:28,080
and so we say that we if we have a

00:24:22,830 --> 00:24:29,730
bi-directional range and we then we can

00:24:28,080 --> 00:24:32,030
we can move in the opposite direction we

00:24:29,730 --> 00:24:34,470
don't need to have a void returning

00:24:32,030 --> 00:24:35,940
decrement operator for postfix because

00:24:34,470 --> 00:24:38,820
anything that models a bi-directional

00:24:35,940 --> 00:24:39,900
range is already a forward range and so

00:24:38,820 --> 00:24:42,510
we already have something that

00:24:39,900 --> 00:24:44,550
incrementer ball and it means that we

00:24:42,510 --> 00:24:48,120
can move backwards as well because we

00:24:44,550 --> 00:24:50,640
direction or age then what we are what

00:24:48,120 --> 00:24:53,070
we need to do is we need to implement

00:24:50,640 --> 00:24:54,810
the operations for random access

00:24:53,070 --> 00:24:55,950
iterators which is which are plus the

00:24:54,810 --> 00:24:59,310
equals we need to be able to do that in

00:24:55,950 --> 00:25:01,830
constant time we have the the arbitrary

00:24:59,310 --> 00:25:05,730
plus operations notice that unlike the

00:25:01,830 --> 00:25:07,620
spaceship operator additions but can for

00:25:05,730 --> 00:25:10,260
consistent comparison we need to provide

00:25:07,620 --> 00:25:12,690
both ways of doing this we then also

00:25:10,260 --> 00:25:15,710
have stepping backwards in by an

00:25:12,690 --> 00:25:18,390
arbitrary amount in in constant time and

00:25:15,710 --> 00:25:21,270
then we also are able to compute the

00:25:18,390 --> 00:25:25,140
distance between an iterator and its

00:25:21,270 --> 00:25:29,520
difference type and in between the

00:25:25,140 --> 00:25:31,950
distance between two iterators that

00:25:29,520 --> 00:25:34,740
allows us to work this out in constant

00:25:31,950 --> 00:25:35,220
time then we have the the subscript

00:25:34,740 --> 00:25:37,680
operator

00:25:35,220 --> 00:25:41,600
which is really just deferring to things

00:25:37,680 --> 00:25:41,600
that we previously implemented and

00:25:41,720 --> 00:25:48,930
following on from that we have the we

00:25:45,900 --> 00:25:52,410
have the comparison operations and there

00:25:48,930 --> 00:25:54,450
is a very boiler planner II but they all

00:25:52,410 --> 00:25:56,190
require random access range and in the

00:25:54,450 --> 00:25:58,020
case of the last one which is the

00:25:56,190 --> 00:26:01,950
spaceship operator we also require that

00:25:58,020 --> 00:26:04,740
the iterator to the base is going to be

00:26:01,950 --> 00:26:08,550
what's known as three-way comparable and

00:26:04,740 --> 00:26:11,090
three-way comparable is makes sure that

00:26:08,550 --> 00:26:14,760
we can use all of the the above

00:26:11,090 --> 00:26:16,020
operations as well as the the spaceship

00:26:14,760 --> 00:26:19,320
operator and the reason we have to

00:26:16,020 --> 00:26:22,830
support all of this is because older

00:26:19,320 --> 00:26:25,740
iterators may not have a I was right

00:26:22,830 --> 00:26:27,360
well they from when we first guys start

00:26:25,740 --> 00:26:28,890
using things such as this they won't

00:26:27,360 --> 00:26:30,600
have the spaceship operator so we can't

00:26:28,890 --> 00:26:32,880
take advantage of it we need to provide

00:26:30,600 --> 00:26:37,470
a way of walking into that and it's it's

00:26:32,880 --> 00:26:39,360
done like so are there any questions

00:26:37,470 --> 00:26:46,350
about that and I see a question at the

00:26:39,360 --> 00:26:48,810
front howdy the question is why they're

00:26:46,350 --> 00:26:51,240
the why the comparators there if their

00:26:48,810 --> 00:26:52,419
spaceship is provided and my

00:26:51,240 --> 00:26:56,350
understanding is

00:26:52,419 --> 00:26:59,739
necessary because older iterators may

00:26:56,350 --> 00:27:01,480
not have a have a spaceship and that

00:26:59,739 --> 00:27:05,129
will cause problems for those particular

00:27:01,480 --> 00:27:05,129
innovators does that answer the question

00:27:12,809 --> 00:27:17,470
that that's that's correct so the the

00:27:15,249 --> 00:27:19,239
the response from the audience was that

00:27:17,470 --> 00:27:21,100
the spaceship is is only there

00:27:19,239 --> 00:27:22,659
conditionally so we need to support all

00:27:21,100 --> 00:27:24,759
the rest and that's also important to

00:27:22,659 --> 00:27:31,570
note as well does that answer the

00:27:24,759 --> 00:27:44,350
question addy okay Dubey couldn't you

00:27:31,570 --> 00:27:46,029
implement the spaceship so the question

00:27:44,350 --> 00:27:48,789
was couldn't you implement the spaceship

00:27:46,029 --> 00:27:50,350
operator in terms of the other operation

00:27:48,789 --> 00:27:53,169
if it doesn't already support the

00:27:50,350 --> 00:27:54,609
spaceship and I don't really have a good

00:27:53,169 --> 00:27:56,499
answer to that I have a bit of time to

00:27:54,609 --> 00:27:58,619
think about that take it offline thank

00:27:56,499 --> 00:27:58,619
you

00:28:02,369 --> 00:28:06,429
that should say Otto thank you for

00:28:04,629 --> 00:28:09,100
pointing that out so the point was that

00:28:06,429 --> 00:28:10,720
the spaceship operator returns a bull it

00:28:09,100 --> 00:28:12,700
should actually return auto and return

00:28:10,720 --> 00:28:17,739
whatever the spaceship operator actually

00:28:12,700 --> 00:28:19,029
is supposed to return then we have so

00:28:17,739 --> 00:28:22,980
before we move on are there any other

00:28:19,029 --> 00:28:26,730
questions about this particular slide I

00:28:22,980 --> 00:28:26,730
see none okay

00:28:27,129 --> 00:28:30,519
probably one from this we have to couple

00:28:28,809 --> 00:28:33,429
functions one is called e to move e to

00:28:30,519 --> 00:28:38,769
move is an operation that essentially

00:28:33,429 --> 00:28:40,929
allows us to do in one step

00:28:38,769 --> 00:28:42,879
stood move of dereferencing the iterator

00:28:40,929 --> 00:28:44,499
it's a bit more involved than that but

00:28:42,879 --> 00:28:47,320
that's the platonic description that

00:28:44,499 --> 00:28:50,350
could fit in the sentence and it's a

00:28:47,320 --> 00:28:53,470
swap is likely to move a helper function

00:28:50,350 --> 00:28:55,629
that allows us to swap to dereference

00:28:53,470 --> 00:28:59,409
iterators we're simply going to be

00:28:55,629 --> 00:29:02,039
deferring these to the to the to the

00:28:59,409 --> 00:29:04,869
range based so the range implementations

00:29:02,039 --> 00:29:06,200
and they will resolve everything with

00:29:04,869 --> 00:29:08,749
respect

00:29:06,200 --> 00:29:12,999
the currents either respected current

00:29:08,749 --> 00:29:18,169
iterators alright it's time for a test

00:29:12,999 --> 00:29:22,820
let's let's write a test and in this

00:29:18,169 --> 00:29:25,190
case we have a ever nyos of you and

00:29:22,820 --> 00:29:28,669
we're going to stride over that and

00:29:25,190 --> 00:29:29,960
pretend every tenth element and so what

00:29:28,669 --> 00:29:31,340
we're going to do is we're going to

00:29:29,960 --> 00:29:34,840
assert that we have a random access

00:29:31,340 --> 00:29:38,059
range and that we also model of view and

00:29:34,840 --> 00:29:41,659
so both of those paths and we check that

00:29:38,059 --> 00:29:43,580
the elements are equal for so the thing

00:29:41,659 --> 00:29:45,200
we get back on stride matches that we

00:29:43,580 --> 00:29:47,179
are actually stepping over every tenth

00:29:45,200 --> 00:29:49,879
element so considering any every tenth

00:29:47,179 --> 00:29:50,509
element this works and it's all it's all

00:29:49,879 --> 00:29:52,879
working fine

00:29:50,509 --> 00:29:53,659
we we're done we can we can go now I

00:29:52,879 --> 00:30:00,190
hope you enjoy the rest of the

00:29:53,659 --> 00:30:03,739
conference but problems start to arise

00:30:00,190 --> 00:30:07,999
so here we have a filter view and filter

00:30:03,739 --> 00:30:11,200
view allows us to remove elements from

00:30:07,999 --> 00:30:16,039
our range that don't satisfy a predicate

00:30:11,200 --> 00:30:18,409
this also works actually and that that's

00:30:16,039 --> 00:30:21,649
great there is a slight problem with

00:30:18,409 --> 00:30:25,220
this and that is when we can't qualify

00:30:21,649 --> 00:30:28,159
it because not all ranges can be

00:30:25,220 --> 00:30:32,629
consequent and that is because something

00:30:28,159 --> 00:30:36,200
such as filter view allows us to say it

00:30:32,629 --> 00:30:40,039
is required to and to cache and iterate

00:30:36,200 --> 00:30:42,799
us that way it's it's begin happens in

00:30:40,039 --> 00:30:45,889
constant time because begin and end are

00:30:42,799 --> 00:30:49,070
required to compute their iterator and

00:30:45,889 --> 00:30:50,929
sentinel in amitayus constant time what

00:30:49,070 --> 00:30:53,119
happens is the first time you call begin

00:30:50,929 --> 00:30:55,480
it will it will perform a find if not

00:30:53,119 --> 00:31:00,320
find if find if not one of the two and

00:30:55,480 --> 00:31:02,450
and then that's a linear operation if we

00:31:00,320 --> 00:31:04,309
do it once and then return a cached

00:31:02,450 --> 00:31:08,649
iterator that's that's going to be okay

00:31:04,309 --> 00:31:11,389
but unfortunately we can't even say that

00:31:08,649 --> 00:31:15,259
that we don't have something modeling a

00:31:11,389 --> 00:31:19,009
range because at the moment we have a

00:31:15,259 --> 00:31:20,150
Const qualified a consequently

00:31:19,009 --> 00:31:21,830
overload of beginner

00:31:20,150 --> 00:31:23,810
end and so the compile is going to pick

00:31:21,830 --> 00:31:24,770
those up and try and use them but then

00:31:23,810 --> 00:31:27,560
when it goes to the underlying

00:31:24,770 --> 00:31:29,330
implementation of beginning in for the

00:31:27,560 --> 00:31:31,220
filter view what's going to happen is

00:31:29,330 --> 00:31:32,480
it's going to run into problems there

00:31:31,220 --> 00:31:35,450
and say that it doesn't exist

00:31:32,480 --> 00:31:37,430
and the output that that I've seen

00:31:35,450 --> 00:31:42,740
getting back nak it's not very pretty so

00:31:37,430 --> 00:31:47,330
we want to want to fix that so I just

00:31:42,740 --> 00:31:50,510
want to take good they just step back

00:31:47,330 --> 00:31:54,290
and reiterate that not all ranged actors

00:31:50,510 --> 00:31:56,360
can be con squalor fide so that's

00:31:54,290 --> 00:31:58,850
something that's very important filter

00:31:56,360 --> 00:32:00,320
and I believe drop while are two

00:31:58,850 --> 00:32:03,110
examples of things that copy cons

00:32:00,320 --> 00:32:06,410
qualified there any questions at this

00:32:03,110 --> 00:32:09,310
point I see a question over there which

00:32:06,410 --> 00:32:09,310
might come into the microphone please

00:32:17,919 --> 00:32:24,350
the issue you described with the filter

00:32:21,049 --> 00:32:27,200
view yep to you hard or even sounds like

00:32:24,350 --> 00:32:29,179
an eternal implementation detail in a

00:32:27,200 --> 00:32:31,070
sense that mutable should be used there

00:32:29,179 --> 00:32:33,740
so the beginning end could be constant

00:32:31,070 --> 00:32:37,400
reason couldn't that be a solution so I

00:32:33,740 --> 00:32:39,280
can you please repeat that so it as far

00:32:37,400 --> 00:32:42,830
as I understood the problem with

00:32:39,280 --> 00:32:45,590
filtered view on on his order is even is

00:32:42,830 --> 00:32:47,900
that the beginning and end have to

00:32:45,590 --> 00:32:49,580
modify the view for the first time

00:32:47,900 --> 00:32:51,200
that's correct that sounds like an

00:32:49,580 --> 00:32:55,150
internal implementation detail that

00:32:51,200 --> 00:32:57,830
shouldn't leak outside so rather the

00:32:55,150 --> 00:32:59,659
implementation should use mutable inside

00:32:57,830 --> 00:33:04,010
and have the beginning of Const

00:32:59,659 --> 00:33:05,659
I thought so too at first the I can see

00:33:04,010 --> 00:33:08,600
Eric leaning forward at the moment so

00:33:05,659 --> 00:33:11,510
please do perhaps forget this wrong but

00:33:08,600 --> 00:33:13,250
my understanding for why this can't why

00:33:11,510 --> 00:33:16,880
why can't use mutable is because of a

00:33:13,250 --> 00:33:18,710
particular rule in the I think it's the

00:33:16,880 --> 00:33:21,860
concurrency section of the standard

00:33:18,710 --> 00:33:23,780
library that basically states that we

00:33:21,860 --> 00:33:26,360
need to make sure that we don't have any

00:33:23,780 --> 00:33:27,799
data races and I can remember the exact

00:33:26,360 --> 00:33:30,110
wording but I can remember the stable

00:33:27,799 --> 00:33:32,179
name which is how you look it up because

00:33:30,110 --> 00:33:35,530
I've had that quoted at me several times

00:33:32,179 --> 00:33:40,610
it's called res on data races that's res

00:33:35,530 --> 00:33:44,090
data races and it essentially means that

00:33:40,610 --> 00:33:45,860
we can't use mutable because that could

00:33:44,090 --> 00:33:49,940
lead to having a data race which is

00:33:45,860 --> 00:33:53,240
undefined in in this case I think it

00:33:49,940 --> 00:34:03,010
wouldn't do the same operation many

00:33:53,240 --> 00:34:03,010
times did I miss anything there Eric

00:34:08,659 --> 00:34:31,590
so that yeah there was so the takeaway

00:34:29,580 --> 00:34:32,940
from that I'm getting a very very very

00:34:31,590 --> 00:34:34,590
much paraphrase when Eric just said

00:34:32,940 --> 00:34:37,560
there thank you Eric

00:34:34,590 --> 00:34:39,600
but basically what Eric just said was

00:34:37,560 --> 00:34:43,139
that res on data races means that

00:34:39,600 --> 00:34:46,020
constant must mean Const and we could

00:34:43,139 --> 00:34:48,690
have to two threads calling in to begin

00:34:46,020 --> 00:34:53,639
and that would potentially lead to a

00:34:48,690 --> 00:34:59,670
data race could you do it in the

00:34:53,639 --> 00:35:01,290
Constructors said instead I actually

00:34:59,670 --> 00:35:05,010
don't know the answer to that but that

00:35:01,290 --> 00:35:17,400
may have problems with the with the

00:35:05,010 --> 00:35:18,630
requirements of a view yep so it means

00:35:17,400 --> 00:35:21,450
that we don't have a constant time

00:35:18,630 --> 00:35:24,000
operation anymore but wouldn't be as if

00:35:21,450 --> 00:35:26,130
rule apply here because even you have

00:35:24,000 --> 00:35:28,109
not two but 10 threads doing the same

00:35:26,130 --> 00:35:30,960
thing at the same time but they would

00:35:28,109 --> 00:35:34,710
all be writing the same value it's not

00:35:30,960 --> 00:35:36,750
that one would calculate one value on

00:35:34,710 --> 00:35:38,910
the other different values to you so

00:35:36,750 --> 00:35:42,960
then you would have race in this case

00:35:38,910 --> 00:35:45,210
you'd only have five threads computing

00:35:42,960 --> 00:35:47,510
the same trivial thing at the same time

00:35:45,210 --> 00:35:50,510
and then writing five times our

00:35:47,510 --> 00:35:50,510
necessary

00:35:54,210 --> 00:36:00,480
so the response was that I do you say

00:35:56,670 --> 00:36:01,860
functional databases functional

00:36:00,480 --> 00:36:06,600
functional code bases don't work like

00:36:01,860 --> 00:36:09,900
that okay thank you okay so let's let's

00:36:06,600 --> 00:36:12,180
fix this so for the record filter view

00:36:09,900 --> 00:36:15,330
does not even have a consequent begin

00:36:12,180 --> 00:36:18,420
and end it just doesn't exist so let's

00:36:15,330 --> 00:36:23,180
fix this for surface tribe you and so

00:36:18,420 --> 00:36:30,210
what we do is we require that our range

00:36:23,180 --> 00:36:32,730
for the consequent and end model a Const

00:36:30,210 --> 00:36:36,360
qualified so the cars qualified version

00:36:32,730 --> 00:36:40,020
of our of the base range models arranged

00:36:36,360 --> 00:36:42,090
and the overloads only exist in that

00:36:40,020 --> 00:36:43,980
case otherwise the implementations are

00:36:42,090 --> 00:36:47,370
identical to what we saw when we first

00:36:43,980 --> 00:36:50,640
looked at them in the case of size we

00:36:47,370 --> 00:36:52,020
have a consequence size range we don't

00:36:50,640 --> 00:36:54,060
need to say oh we can just stick that in

00:36:52,020 --> 00:36:56,880
there because size range is already

00:36:54,060 --> 00:36:58,860
modeling a range as just a refinement so

00:36:56,880 --> 00:37:04,260
we can we can simplify it a little bit

00:36:58,860 --> 00:37:06,750
and we also can eliminate a certain

00:37:04,260 --> 00:37:10,230
number of overloads for begin and end in

00:37:06,750 --> 00:37:12,060
the event when we have a range that can

00:37:10,230 --> 00:37:15,360
be cons qualified and its iterator and

00:37:12,060 --> 00:37:18,300
its Sentinel are the same type we can we

00:37:15,360 --> 00:37:20,460
can forget about the non cons because

00:37:18,300 --> 00:37:22,710
they're basically to my understanding

00:37:20,460 --> 00:37:26,070
going to produce the same the same

00:37:22,710 --> 00:37:27,330
result and so what we call this a simple

00:37:26,070 --> 00:37:29,910
view now this is an implementation

00:37:27,330 --> 00:37:34,160
detail this concept so it's not a

00:37:29,910 --> 00:37:36,390
vocabulary concept but it does exist for

00:37:34,160 --> 00:37:39,120
for people who are going to build their

00:37:36,390 --> 00:37:41,100
range adapters and you only have to

00:37:39,120 --> 00:37:42,570
implement this once and if you were

00:37:41,100 --> 00:37:44,760
building something on top of an existing

00:37:42,570 --> 00:37:47,070
ranges library then you'll probably find

00:37:44,760 --> 00:37:53,010
that it already exists and then what we

00:37:47,070 --> 00:37:56,610
can say is that our non consequence have

00:37:53,010 --> 00:37:59,790
a requirement of not modeling a simple

00:37:56,610 --> 00:38:03,830
view for the non cons qualified version

00:37:59,790 --> 00:38:03,830
of ah are there any questions about that

00:38:05,010 --> 00:38:10,470
okay so I seen on the reason for for

00:38:08,490 --> 00:38:11,700
adding this this particular requirement

00:38:10,470 --> 00:38:15,690
on is to reduce the number of

00:38:11,700 --> 00:38:18,420
instantiations of member functions and

00:38:15,690 --> 00:38:20,100
so now we'll meet when we do this it's

00:38:18,420 --> 00:38:22,230
list I'm not gonna be able to have a

00:38:20,100 --> 00:38:25,200
consequence tried view of a filter view

00:38:22,230 --> 00:38:27,330
of an eye out of you but we can at least

00:38:25,200 --> 00:38:29,400
say that we can't get that so this test

00:38:27,330 --> 00:38:32,640
will now actually compile and pass

00:38:29,400 --> 00:38:36,930
instead of being problematic and giving

00:38:32,640 --> 00:38:40,620
us a station error now let's talk about

00:38:36,930 --> 00:38:43,080
element access element access is

00:38:40,620 --> 00:38:45,210
something that a vector can do so we can

00:38:43,080 --> 00:38:47,190
fill up a vector with with some random

00:38:45,210 --> 00:38:48,840
integers if we want to access an

00:38:47,190 --> 00:38:51,420
arbitrary element we can use the

00:38:48,840 --> 00:38:54,060
subscript operator and if we want to

00:38:51,420 --> 00:38:56,340
access the first element we can say that

00:38:54,060 --> 00:38:59,730
we want to access the the front of the

00:38:56,340 --> 00:39:01,320
vector and if we want to access the last

00:38:59,730 --> 00:39:04,320
element we can say we want to act we

00:39:01,320 --> 00:39:06,360
want to get the back and if our our

00:39:04,320 --> 00:39:08,400
underlying range has these operations

00:39:06,360 --> 00:39:10,410
it'll be nice if our stride view also

00:39:08,400 --> 00:39:13,680
respected these operations and behaved

00:39:10,410 --> 00:39:14,970
in the same fashion so we we can do

00:39:13,680 --> 00:39:17,640
something like this

00:39:14,970 --> 00:39:19,950
now you may remember you may recall at

00:39:17,640 --> 00:39:22,530
the very start I talked about this thing

00:39:19,950 --> 00:39:24,720
called view interface and we derived our

00:39:22,530 --> 00:39:26,550
straight of you from that and you

00:39:24,720 --> 00:39:29,190
interface provides us with a large

00:39:26,550 --> 00:39:31,530
number of operations that we just get

00:39:29,190 --> 00:39:33,720
for free if we if we inherit from it for

00:39:31,530 --> 00:39:35,280
example there is a there's a sized

00:39:33,720 --> 00:39:37,590
operation that works when we have a size

00:39:35,280 --> 00:39:43,200
Sentinel but we still need to provide a

00:39:37,590 --> 00:39:47,700
sized range version of of the of the

00:39:43,200 --> 00:39:50,370
sorry of the overload in the ones that I

00:39:47,700 --> 00:39:52,920
want to focus on in particular our front

00:39:50,370 --> 00:39:54,150
back and the subscript operator now it

00:39:52,920 --> 00:39:59,370
turns out that we already meet all the

00:39:54,150 --> 00:40:01,470
requirements for the front and for the

00:39:59,370 --> 00:40:03,890
subscript operator because in the case

00:40:01,470 --> 00:40:06,150
that we have a four word range we model

00:40:03,890 --> 00:40:08,670
we've just met all the requirements so

00:40:06,150 --> 00:40:10,380
that one exists when we have a four word

00:40:08,670 --> 00:40:13,770
range in the event that we want to do a

00:40:10,380 --> 00:40:16,380
subscript operation we have a if we have

00:40:13,770 --> 00:40:18,870
a random access range everything just

00:40:16,380 --> 00:40:21,090
exists but unfortunately this

00:40:18,870 --> 00:40:22,470
doesn't work for the back operation we

00:40:21,090 --> 00:40:23,760
need a bi-directional range we already

00:40:22,470 --> 00:40:25,650
meet this requirement if we have a

00:40:23,760 --> 00:40:28,800
bidirectional range but the thing we

00:40:25,650 --> 00:40:31,140
haven't accounted for is that we we need

00:40:28,800 --> 00:40:35,190
a common range as well I think I shall

00:40:31,140 --> 00:40:36,990
hands please for those who didn't come

00:40:35,190 --> 00:40:40,230
to the last session well those who want

00:40:36,990 --> 00:40:45,810
to refresher on what a common range is

00:40:40,230 --> 00:40:50,550
please okay so a common range is a range

00:40:45,810 --> 00:40:53,070
whose iterator so who begin and end with

00:40:50,550 --> 00:40:55,080
the same type so that means that the

00:40:53,070 --> 00:40:58,740
iterator have a sentinel are the same

00:40:55,080 --> 00:41:00,600
type and so we don't meet that

00:40:58,740 --> 00:41:03,510
requirement yet and we should probably

00:41:00,600 --> 00:41:05,910
fix that so let's get strap you to model

00:41:03,510 --> 00:41:07,710
common range may recall that we match

00:41:05,910 --> 00:41:11,670
earlier on talk about any end in pool

00:41:07,710 --> 00:41:15,630
and that just returned basically what

00:41:11,670 --> 00:41:18,210
you would expect our end to do but in

00:41:15,630 --> 00:41:20,970
the event that we don't model so in the

00:41:18,210 --> 00:41:22,950
event that we have a range that is both

00:41:20,970 --> 00:41:24,960
sized that is we can call range of size

00:41:22,950 --> 00:41:26,280
on it and we have a common range where

00:41:24,960 --> 00:41:28,920
the iterator and the central for the

00:41:26,280 --> 00:41:30,120
range at the same time we can we can

00:41:28,920 --> 00:41:34,020
make it a common range that's what we do

00:41:30,120 --> 00:41:37,350
is return an iterator to our stride view

00:41:34,020 --> 00:41:42,720
instead so what we do is we check the

00:41:37,350 --> 00:41:45,180
constants of self which is the the

00:41:42,720 --> 00:41:48,450
template version of the stride rank over

00:41:45,180 --> 00:41:54,270
strobe you and then we are we pass in

00:41:48,450 --> 00:41:57,810
the iterator so the range and we we also

00:41:54,270 --> 00:42:00,480
take the number of steps between the

00:41:57,810 --> 00:42:01,950
last element we want to consider and the

00:42:00,480 --> 00:42:04,770
end because that's all the information

00:42:01,950 --> 00:42:10,710
we need to get the back are there any

00:42:04,770 --> 00:42:12,570
questions about that I see none okay

00:42:10,710 --> 00:42:14,190
they're moving on we haven't provided

00:42:12,570 --> 00:42:17,070
that constructor yet so we need to do

00:42:14,190 --> 00:42:18,770
that and this is what it looks like it's

00:42:17,070 --> 00:42:21,660
very much similar to the rest of them

00:42:18,770 --> 00:42:24,870
the only difference certainly the

00:42:21,660 --> 00:42:27,060
requirement and adding a step parameter

00:42:24,870 --> 00:42:29,340
is that we are also setting currents to

00:42:27,060 --> 00:42:32,910
the end of the range instead of the

00:42:29,340 --> 00:42:36,540
beginning of the range and now this

00:42:32,910 --> 00:42:42,600
means that we can this means that we can

00:42:36,540 --> 00:42:44,250
called up back on our range as well are

00:42:42,600 --> 00:42:51,780
there any questions about making this a

00:42:44,250 --> 00:42:54,320
common range okay I see none all right

00:42:51,780 --> 00:42:57,060
let's take a look at this particular

00:42:54,320 --> 00:43:00,570
test case now what we're saying here is

00:42:57,060 --> 00:43:02,430
that we have we have an eye out of you

00:43:00,570 --> 00:43:04,100
and we're going to stride through the

00:43:02,430 --> 00:43:07,680
hundred elements we want to take every

00:43:04,100 --> 00:43:09,240
33rd element that means we wouldn't want

00:43:07,680 --> 00:43:12,140
to reverse it this means we're going to

00:43:09,240 --> 00:43:14,370
lazily reverse the number of elements in

00:43:12,140 --> 00:43:16,440
so we're gonna relatedly iterate

00:43:14,370 --> 00:43:18,660
essentially backwards in a strategy

00:43:16,440 --> 00:43:20,880
fashion can I get a show of hands please

00:43:18,660 --> 00:43:24,090
who would expect this to be if we're

00:43:20,880 --> 00:43:28,410
going to take the the stride forward

00:43:24,090 --> 00:43:30,990
which would be 0:33 6699 let me assure

00:43:28,410 --> 00:43:36,720
hands please who would expect this range

00:43:30,990 --> 00:43:41,310
adapter to in Reverse produced 99 66 33

00:43:36,720 --> 00:43:44,880
0 okay I see a few hands who would

00:43:41,310 --> 00:43:50,280
expect it to not do that because your

00:43:44,880 --> 00:43:52,080
hand up because of future slides what we

00:43:50,280 --> 00:43:54,180
expect like as in what we functionally

00:43:52,080 --> 00:43:55,830
expect this to behaviors not know what

00:43:54,180 --> 00:43:57,240
we expect the code to do because anyone

00:43:55,830 --> 00:43:59,760
who is skeptical of this is absolutely

00:43:57,240 --> 00:44:03,230
right we have to get 67 34 and one and

00:43:59,760 --> 00:44:08,700
the reason for that is because our our

00:44:03,230 --> 00:44:11,820
back iterator so stepping backwards

00:44:08,700 --> 00:44:13,500
doesn't actually account for there being

00:44:11,820 --> 00:44:15,600
a precise number of element in the

00:44:13,500 --> 00:44:17,520
strides and so we need to do that so

00:44:15,600 --> 00:44:19,230
you're you may recall that I kind of

00:44:17,520 --> 00:44:22,200
really superficially glossed over this

00:44:19,230 --> 00:44:23,910
thing called step and that's that's

00:44:22,200 --> 00:44:26,520
essentially what's going to be the star

00:44:23,910 --> 00:44:30,570
of this section so we're going to

00:44:26,520 --> 00:44:33,360
revisit advanced and now recall this bit

00:44:30,570 --> 00:44:35,640
here from the previous section this is

00:44:33,360 --> 00:44:38,870
now going to be wrapped inside something

00:44:35,640 --> 00:44:40,740
that is not a bi-directional range and

00:44:38,870 --> 00:44:43,410
then what we're going to do is learn to

00:44:40,740 --> 00:44:46,600
do some computation the first thing that

00:44:43,410 --> 00:44:48,730
we want to do is we want to

00:44:46,600 --> 00:44:53,080
compute the number of steps we take

00:44:48,730 --> 00:44:55,840
whenever we iterate forward and the way

00:44:53,080 --> 00:44:58,210
ranges advance the wavy bounded version

00:44:55,840 --> 00:44:59,680
of ranges advanced works is that it

00:44:58,210 --> 00:45:01,870
returns the difference between the

00:44:59,680 --> 00:45:04,480
number of steps we expected to take and

00:45:01,870 --> 00:45:06,700
the number of steps we actually took so

00:45:04,480 --> 00:45:09,190
if we expect it to take ten steps and we

00:45:06,700 --> 00:45:11,050
only took five ranges advance will

00:45:09,190 --> 00:45:13,360
return five to indicate we didn't take

00:45:11,050 --> 00:45:15,550
five steps and what we're going to do is

00:45:13,360 --> 00:45:17,800
going to subtract that from the actual

00:45:15,550 --> 00:45:20,950
stride to indicate this is where our

00:45:17,800 --> 00:45:22,210
step is and so this is how many this is

00:45:20,950 --> 00:45:24,700
actually how many things we need to move

00:45:22,210 --> 00:45:28,000
backwards in the event we want to move

00:45:24,700 --> 00:45:30,430
backwards if we're at the end now

00:45:28,000 --> 00:45:34,600
because that's where the strike actually

00:45:30,430 --> 00:45:35,590
stops and in the case of when n is less

00:45:34,600 --> 00:45:42,910
than zero

00:45:35,590 --> 00:45:45,460
now our stride is funky but what we do

00:45:42,910 --> 00:45:47,230
is we say that if the step is zero then

00:45:45,460 --> 00:45:50,110
we take back when you step back the

00:45:47,230 --> 00:45:51,940
number of steps that are equivalent to

00:45:50,110 --> 00:45:54,760
the number of sips want to take times

00:45:51,940 --> 00:45:57,760
the stride it all works as before but in

00:45:54,760 --> 00:46:03,670
the event that in the event that we we

00:45:57,760 --> 00:46:05,230
want to move from from the very end of

00:46:03,670 --> 00:46:09,720
the range what we need to do is we need

00:46:05,230 --> 00:46:13,270
to say that we're going to move back a

00:46:09,720 --> 00:46:16,600
certain extra number of steps to ensure

00:46:13,270 --> 00:46:18,790
that we account for however many how

00:46:16,600 --> 00:46:20,020
many elements we skipped over but we

00:46:18,790 --> 00:46:25,300
didn't actually reach another thing in

00:46:20,020 --> 00:46:27,850
our stride and then what we do is we we

00:46:25,300 --> 00:46:30,340
move backward and store a value in

00:46:27,850 --> 00:46:37,090
stride there any questions about that

00:46:30,340 --> 00:46:42,340
I see no okay and this means that our

00:46:37,090 --> 00:46:44,110
reverse will actually work now now part

00:46:42,340 --> 00:46:46,180
of the the great thing about range

00:46:44,110 --> 00:46:48,960
ranges and range adapters is that they

00:46:46,180 --> 00:46:52,540
compose really well and this particular

00:46:48,960 --> 00:46:54,010
example with the pipe operation works it

00:46:52,540 --> 00:46:57,070
just magically works out of the box

00:46:54,010 --> 00:46:59,170
because views reverse is something that

00:46:57,070 --> 00:46:59,869
has already been accounted for in the

00:46:59,170 --> 00:47:02,029
standard library

00:46:59,869 --> 00:47:05,869
the canonical implementations and so we

00:47:02,029 --> 00:47:06,619
can we can move forward by piping strobe

00:47:05,869 --> 00:47:11,509
you can to reverse

00:47:06,619 --> 00:47:15,529
unfortunately this fails because we

00:47:11,509 --> 00:47:16,999
can't pipe iota into stride because it

00:47:15,529 --> 00:47:20,029
doesn't actually understand what a pipe

00:47:16,999 --> 00:47:24,230
operation is and so this final section

00:47:20,029 --> 00:47:24,950
is going to be focusing on how to get

00:47:24,230 --> 00:47:26,990
that to happen

00:47:24,950 --> 00:47:32,200
what is the machinery behind the pipe

00:47:26,990 --> 00:47:35,329
operation and so I'm gonna take this as

00:47:32,200 --> 00:47:38,930
slowly as I can but if you have

00:47:35,329 --> 00:47:39,829
questions please do interrupt me so the

00:47:38,930 --> 00:47:41,720
first thing we need to talk about is

00:47:39,829 --> 00:47:43,430
what arrange adapter closure is so on

00:47:41,720 --> 00:47:45,890
screen we have a range adapter that's

00:47:43,430 --> 00:47:48,049
straight view and we have use stride and

00:47:45,890 --> 00:47:51,079
new strategies arrange adapter closure

00:47:48,049 --> 00:47:54,049
object what this means is that we can

00:47:51,079 --> 00:47:57,109
say views stride of instant five and

00:47:54,049 --> 00:47:59,990
that will give us back a straight view

00:47:57,109 --> 00:48:02,240
of an eye out of you where we have a

00:47:59,990 --> 00:48:06,039
stride of size five and that is

00:48:02,240 --> 00:48:09,190
equivalent to piping int into views of

00:48:06,039 --> 00:48:11,960
abuse stride of five so these two

00:48:09,190 --> 00:48:14,749
expressions should be equivalent if we

00:48:11,960 --> 00:48:18,710
do one it it must be the same as doing

00:48:14,749 --> 00:48:22,249
the other and so what we have here is

00:48:18,710 --> 00:48:25,130
our closure what we call this is as I

00:48:22,249 --> 00:48:27,019
this is how we describe what stride

00:48:25,130 --> 00:48:30,259
function so this is how we describe that

00:48:27,019 --> 00:48:33,140
the views stride as a type what we say

00:48:30,259 --> 00:48:37,999
is that we have an a call operator and

00:48:33,140 --> 00:48:39,799
if we pass in a range and a step then we

00:48:37,999 --> 00:48:41,809
can construct a straight view we wrap it

00:48:39,799 --> 00:48:44,630
inside this thing called views all so

00:48:41,809 --> 00:48:46,789
that way if we pass in a an on view it's

00:48:44,630 --> 00:48:50,539
now but it's of your range it's suddenly

00:48:46,789 --> 00:48:55,369
a view and this gets us the first the

00:48:50,539 --> 00:48:57,019
left-hand side of the the expression the

00:48:55,369 --> 00:48:58,849
stride with the in turn the five but

00:48:57,019 --> 00:49:01,369
what we really want to have is also the

00:48:58,849 --> 00:49:04,489
the other side we can pipe it into

00:49:01,369 --> 00:49:07,819
stride of five and so the way we do that

00:49:04,489 --> 00:49:12,170
is we return and operate a call operator

00:49:07,819 --> 00:49:13,119
where we take an integral and we have a

00:49:12,170 --> 00:49:15,910
this thing

00:49:13,119 --> 00:49:18,039
range adapter closure and this is where

00:49:15,910 --> 00:49:21,970
all of the we're all the funds that

00:49:18,039 --> 00:49:24,579
happens so we're now going to build the

00:49:21,970 --> 00:49:26,680
range adapter closure and the range

00:49:24,579 --> 00:49:29,440
adapter closure is derived from a tuple

00:49:26,680 --> 00:49:30,609
there are better implementations if

00:49:29,440 --> 00:49:32,710
you're actually doing a library

00:49:30,609 --> 00:49:36,279
developer doing library development but

00:49:32,710 --> 00:49:37,450
for the purposes of this session we're

00:49:36,279 --> 00:49:40,299
just going to say that it's derived from

00:49:37,450 --> 00:49:43,029
a table and we want it to be semi

00:49:40,299 --> 00:49:45,910
regular again because that's part of how

00:49:43,029 --> 00:49:48,910
ranges are designed and we're going to

00:49:45,910 --> 00:49:50,769
have a constructor that takes both the

00:49:48,910 --> 00:49:54,789
object that we that we want to be

00:49:50,769 --> 00:49:56,470
calling that's F and the the arguments

00:49:54,789 --> 00:49:58,960
that we don't want to consider when

00:49:56,470 --> 00:50:03,490
we're actually calling and when we're

00:49:58,960 --> 00:50:05,670
actually calling our arrange adapter and

00:50:03,490 --> 00:50:08,319
so both of these things need to be

00:50:05,670 --> 00:50:17,380
copyable so semi-regular refines

00:50:08,319 --> 00:50:19,269
copyable and and it also me sorry i yeah

00:50:17,380 --> 00:50:22,450
anyway so what we need to also do is

00:50:19,269 --> 00:50:24,730
have a a call operator that works with a

00:50:22,450 --> 00:50:28,839
viewable range and we need to say that

00:50:24,730 --> 00:50:31,089
it is invoked ball with receive ocol

00:50:28,839 --> 00:50:33,160
with respect to a arrange that we're

00:50:31,089 --> 00:50:37,930
passing in as our parameter and all of

00:50:33,160 --> 00:50:41,200
the arguments that we have as our as up

00:50:37,930 --> 00:50:45,489
as our parameters that are already being

00:50:41,200 --> 00:50:49,119
cached and this is a consequence I won

00:50:45,489 --> 00:50:51,549
an encore fired one and we're not going

00:50:49,119 --> 00:50:53,349
to consider the consequence but the sake

00:50:51,549 --> 00:50:57,309
of simplicity and time because they're

00:50:53,349 --> 00:51:00,430
identical and then what we're going to

00:50:57,309 --> 00:51:03,069
also have is this the static the static

00:51:00,430 --> 00:51:04,150
member function called apply can I go to

00:51:03,069 --> 00:51:08,259
show hands please who here is familiar

00:51:04,150 --> 00:51:10,089
with stood applying the tables okay

00:51:08,259 --> 00:51:13,119
that's wonderful I will explain that in

00:51:10,089 --> 00:51:15,249
just a moment just there it is very

00:51:13,119 --> 00:51:20,410
similar to that the first thing to do is

00:51:15,249 --> 00:51:21,880
to make a constructor I didn't have it

00:51:20,410 --> 00:51:26,619
on the previous slide but this base T

00:51:21,880 --> 00:51:29,049
refers to the tuple of remove references

00:51:26,619 --> 00:51:30,999
of of the arguments as we're just gonna

00:51:29,049 --> 00:51:34,210
make a cheapo and forward everything

00:51:30,999 --> 00:51:37,779
into that intercept table then we're

00:51:34,210 --> 00:51:39,640
going to make a call operator so it's as

00:51:37,779 --> 00:51:41,980
it was before and we're just going to

00:51:39,640 --> 00:51:43,660
forward everything to the apply now the

00:51:41,980 --> 00:51:48,480
reason that what apply does is it

00:51:43,660 --> 00:51:51,369
forwards on the elements of a tuple into

00:51:48,480 --> 00:51:53,890
into a cooperation and the reason we

00:51:51,369 --> 00:51:56,230
can't just use stead apply is because

00:51:53,890 --> 00:51:59,680
still apply to my knowledge only allows

00:51:56,230 --> 00:52:00,940
us to have one tuple passed in as the

00:51:59,680 --> 00:52:03,339
arguments or function but we need an

00:52:00,940 --> 00:52:06,849
extra parameter which is the range and

00:52:03,339 --> 00:52:09,609
so we need to build their own apply and

00:52:06,849 --> 00:52:11,799
this is the only section where we really

00:52:09,609 --> 00:52:13,960
do any template metaprogramming because

00:52:11,799 --> 00:52:18,249
we are relying on stead index sequence

00:52:13,960 --> 00:52:20,319
which allows us to produce a a sequence

00:52:18,249 --> 00:52:22,839
of integers between zero and the number

00:52:20,319 --> 00:52:25,150
of elements that so the number of

00:52:22,839 --> 00:52:27,400
arguments that are going to be at the

00:52:25,150 --> 00:52:31,109
back of the call what we do is we

00:52:27,400 --> 00:52:33,190
default construct our call level F

00:52:31,109 --> 00:52:34,480
that's why I need to be semi-regular

00:52:33,190 --> 00:52:35,920
because we wanted the default

00:52:34,480 --> 00:52:37,029
constructed here we didn't actually want

00:52:35,920 --> 00:52:39,579
to store anything because there's no

00:52:37,029 --> 00:52:45,430
real need to and we just forward on the

00:52:39,579 --> 00:52:48,099
all the arguments finally what we need

00:52:45,430 --> 00:52:50,259
to be able to do is pipe and we haven't

00:52:48,099 --> 00:52:54,519
done it yet but if we declare a friend

00:52:50,259 --> 00:52:56,920
function that is that is the pipe

00:52:54,519 --> 00:53:00,789
operator and we pass in a range adapter

00:52:56,920 --> 00:53:02,529
closure as the right-hand side and a

00:53:00,789 --> 00:53:04,559
range as the left-hand side so a

00:53:02,529 --> 00:53:07,690
viewable range the left-hand side and

00:53:04,559 --> 00:53:12,549
the range that the closure is invoke

00:53:07,690 --> 00:53:14,920
from the range then we can we can call

00:53:12,549 --> 00:53:17,410
that and return the result that we would

00:53:14,920 --> 00:53:19,720
get back from that and you'll notice

00:53:17,410 --> 00:53:22,509
that I've provided the r-value reference

00:53:19,720 --> 00:53:26,650
one I'm leaving it as an exercise to all

00:53:22,509 --> 00:53:28,630
to implement the remainder I'll give you

00:53:26,650 --> 00:53:33,400
a hint they are very similar to

00:53:28,630 --> 00:53:35,230
implement and finally the final thing

00:53:33,400 --> 00:53:38,140
about the range depth of closure is we

00:53:35,230 --> 00:53:39,260
divided deduction guide and the reason

00:53:38,140 --> 00:53:42,260
for that is

00:53:39,260 --> 00:53:45,080
because we are we don't want to preserve

00:53:42,260 --> 00:53:46,750
any referencing from information in the

00:53:45,080 --> 00:53:49,670
type of the range of actor closure and

00:53:46,750 --> 00:53:55,220
although we have a removed reference in

00:53:49,670 --> 00:53:56,870
the in the derived essay in the in the

00:53:55,220 --> 00:53:58,070
base type that you pool

00:53:56,870 --> 00:54:00,140
we still need to remove that before we

00:53:58,070 --> 00:54:03,980
even get there and so that's how we do

00:54:00,140 --> 00:54:07,310
it here finally the finishing touches we

00:54:03,980 --> 00:54:09,950
want to provide an object that is our

00:54:07,310 --> 00:54:11,600
range adapter stride and this is

00:54:09,950 --> 00:54:12,890
pertaining to what you were talking

00:54:11,600 --> 00:54:15,350
about and asking about in the previous

00:54:12,890 --> 00:54:18,500
session this is what goes into namespace

00:54:15,350 --> 00:54:22,580
views and so that's what we have as our

00:54:18,500 --> 00:54:26,180
range adapter closure it's used as such

00:54:22,580 --> 00:54:28,040
so what we can do is we can we can take

00:54:26,180 --> 00:54:29,240
an i/o to view then we can transform

00:54:28,040 --> 00:54:31,250
it's the way we get the results of the

00:54:29,240 --> 00:54:33,410
Collatz conjecture and i consider every

00:54:31,250 --> 00:54:34,820
fifth element and then what we're going

00:54:33,410 --> 00:54:37,130
to do is we're going to reduce that and

00:54:34,820 --> 00:54:41,450
because the common range it satisfies

00:54:37,130 --> 00:54:42,980
everything that we have as a reduction i

00:54:41,450 --> 00:54:44,690
say that reduce requires because reduce

00:54:42,980 --> 00:54:47,870
doesn't have a sense in or based over

00:54:44,690 --> 00:54:51,680
load and we check that the result is

00:54:47,870 --> 00:54:56,210
correct and that is our range adapter

00:54:51,680 --> 00:55:00,680
forstride so in conclusion we built a

00:54:56,210 --> 00:55:03,050
non-standard range adapter we we built a

00:55:00,680 --> 00:55:04,610
range adapter closure type we learnt

00:55:03,050 --> 00:55:07,100
that honor all ranges of consequence a

00:55:04,610 --> 00:55:08,570
ball and we leverage the spaceship

00:55:07,100 --> 00:55:10,550
operator to make things a little bit

00:55:08,570 --> 00:55:12,980
easier furthermore from the previous

00:55:10,550 --> 00:55:14,300
session we'd kind of blend it with the

00:55:12,980 --> 00:55:17,570
session a bit more than I was

00:55:14,300 --> 00:55:22,670
anticipating we learnt that iterators

00:55:17,570 --> 00:55:25,340
are fundamental to developing a basis

00:55:22,670 --> 00:55:26,720
for ranges as our sentinels they go hand

00:55:25,340 --> 00:55:29,570
in hand with ranges and although we

00:55:26,720 --> 00:55:31,390
don't need to use them as much in our in

00:55:29,570 --> 00:55:34,370
a user base code they're absolutely

00:55:31,390 --> 00:55:37,880
important and essential si essential for

00:55:34,370 --> 00:55:38,900
building range based abstractions I'd

00:55:37,880 --> 00:55:40,310
like to thank you for your time

00:55:38,900 --> 00:55:43,630
especially if you stayed here for the

00:55:40,310 --> 00:55:45,530
full two-hour session and I'd like to

00:55:43,630 --> 00:55:49,240
wish you well for the rest of the

00:55:45,530 --> 00:55:49,240
conference and thank you

00:55:54,680 --> 00:56:04,890
so I think I have four minutes left the

00:55:57,210 --> 00:56:06,890
questions okay there are none left thank

00:56:04,890 --> 00:56:10,159
you

00:56:06,890 --> 00:56:10,159

YouTube URL: https://www.youtube.com/watch?v=g-F280_AQp8


