Title: CppCon 2019: Andrei Alexandrescu “Speed Is Found In The Minds of People"
Publication date: 2019-09-18
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
In all likelihood, sorting is one of the most researched classes of algorithms. It is a fundamental task in Computer Science, both on its own and as a step in other algorithms. Efficient algorithms for sorting and searching are now taught in core undergraduate classes. Are they at their best, or is there more blood to squeeze from that stone? This talk will explore a few less known – but more allegro! – variants of classic sorting algorithms. And as they say, the road matters more than the destination. Along the way, we'll encounter many wondrous surprises and we'll learn how to cope with the puzzling behavior of modern complex architectures.
— 
Andrei Alexandrescu
The D Language Foundation
Vice President and Treasurer
Boston MA

Andrei Alexandrescu is a researcher, software engineer, and author. He wrote three best-selling books on programming (Modern C++ Design, C++ Coding Standards, and The D Programming Language) and numerous articles and papers on wide-ranging topics from programming to language design to Machine Learning to Natural Language Processing. Andrei holds a PhD in Computer Science from the University of Washington and a BSc in Electrical Engineering from University "Politehnica" Bucharest. He is the Vice President of the D Language Foundation.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:10,460 --> 00:00:16,670
I'm not gonna give you Andres bio he

00:00:14,299 --> 00:00:19,250
literally has a Wikipedia page if you

00:00:16,670 --> 00:00:21,169
haven't read it you should read it some

00:00:19,250 --> 00:00:25,009
of you may not have seen an Andre talk

00:00:21,169 --> 00:00:27,650
before and I kind of envy you because

00:00:25,009 --> 00:00:29,000
those of you who have seen one know the

00:00:27,650 --> 00:00:31,519
experience they're about to have for the

00:00:29,000 --> 00:00:34,280
first time you're going to laugh you're

00:00:31,519 --> 00:00:36,320
gonna learn and when you go home I

00:00:34,280 --> 00:00:38,390
haven't heard it yet but I can guarantee

00:00:36,320 --> 00:00:47,600
this will be the talk you will tell

00:00:38,390 --> 00:00:49,909
other people about so get ready this is

00:00:47,600 --> 00:00:52,369
a famous algorithm everybody knows it is

00:00:49,909 --> 00:00:53,449
just implemented an assembler when you

00:00:52,369 --> 00:00:57,580
figure out what it is

00:00:53,449 --> 00:00:57,580
raise your hand you've got 15 seconds I

00:01:01,030 --> 00:01:06,220
just want your attention it's not it's

00:01:03,140 --> 00:01:10,009
just one random code all right

00:01:06,220 --> 00:01:15,860
official announcement hurts gonna do

00:01:10,009 --> 00:01:20,720
book signing after this talk there's no

00:01:15,860 --> 00:01:21,430
time mentioned he's gonna eat when he's

00:01:20,720 --> 00:01:24,440
gonna end

00:01:21,430 --> 00:01:26,630
all right then he's gonna wait I talked

00:01:24,440 --> 00:01:29,090
to him he's gonna wait until it ends

00:01:26,630 --> 00:01:30,980
you're prisoners here and this is

00:01:29,090 --> 00:01:33,860
because we have a shell of material to

00:01:30,980 --> 00:01:45,590
go through cells real quick what sorry

00:01:33,860 --> 00:01:51,620
excuse me sorry it's a confusion

00:01:45,590 --> 00:01:55,909
I said shed load I said shed load it's a

00:01:51,620 --> 00:01:59,049
word it's a decent word it's in the

00:01:55,909 --> 00:01:59,049
cambric dictionary

00:02:01,490 --> 00:02:10,489
can bridge like not Cambridge

00:02:04,290 --> 00:02:19,230
Massachusetts can bridge breaks it okay

00:02:10,489 --> 00:02:22,170
too soon say it's a word so what's the

00:02:19,230 --> 00:02:25,890
deal with sorting what is the deal with

00:02:22,170 --> 00:02:28,140
sorting well it's just the most

00:02:25,890 --> 00:02:33,480
researched problem in computer science

00:02:28,140 --> 00:02:35,760
ever like you know if you google like if

00:02:33,480 --> 00:02:37,350
you go to scholar Google come and look

00:02:35,760 --> 00:02:39,709
for sorting algorithms is just a

00:02:37,350 --> 00:02:43,739
bazillion papers and the most recent is

00:02:39,709 --> 00:02:45,959
2019 and it is like it's meaningful it's

00:02:43,739 --> 00:02:48,510
not like an analysis so yeah it's new

00:02:45,959 --> 00:02:50,970
sort algorithms and new stuff it's

00:02:48,510 --> 00:02:54,150
absolutely amazing so sorting is

00:02:50,970 --> 00:02:57,690
absolutely fundamental from computer

00:02:54,150 --> 00:03:00,060
science CS complete if you wish like the

00:02:57,690 --> 00:03:02,700
basic it's if you're a musician you

00:03:00,060 --> 00:03:05,730
gotta play preludes for anna maria

00:03:02,700 --> 00:03:09,450
magdalena bach right any instrument you

00:03:05,730 --> 00:03:12,030
play if your yoga i heard a good left

00:03:09,450 --> 00:03:15,000
there if your yoga guy you gotta do like

00:03:12,030 --> 00:03:16,590
savasana I don't know like services I

00:03:15,000 --> 00:03:17,670
can do suffice and he's like you lay on

00:03:16,590 --> 00:03:21,660
your back and do nothing

00:03:17,670 --> 00:03:23,640
that's awesome so if you're a programmer

00:03:21,660 --> 00:03:27,180
you gotta implement sort once in your

00:03:23,640 --> 00:03:33,060
life just got to do it sit down and do

00:03:27,180 --> 00:03:35,130
it and it's not even very difficult

00:03:33,060 --> 00:03:37,310
because we have a number of consecrated

00:03:35,130 --> 00:03:40,500
algorithms of which quicksort would be

00:03:37,310 --> 00:03:41,910
naturally the first to come to mind so

00:03:40,500 --> 00:03:43,769
why is it so popular in all

00:03:41,910 --> 00:03:46,650
implementations of standard libraries

00:03:43,769 --> 00:03:48,390
for C++ and other libraries for C++ and

00:03:46,650 --> 00:03:50,640
other languages you're going to find

00:03:48,390 --> 00:03:57,150
quicksort like the pre-madonna

00:03:50,640 --> 00:03:59,579
of sort implementations now it's very

00:03:57,150 --> 00:04:00,359
it's a very nice algorithm it makes a

00:03:59,579 --> 00:04:02,489
lot of sense

00:04:00,359 --> 00:04:04,889
it's the textbook application of divide

00:04:02,489 --> 00:04:06,569
and conquer it just you can spend time

00:04:04,889 --> 00:04:08,760
and talent and you know you can have a

00:04:06,569 --> 00:04:10,230
lot of insight on corner cases to

00:04:08,760 --> 00:04:11,990
optimizing it because it's so simple

00:04:10,230 --> 00:04:14,360
it's easy to Anna

00:04:11,990 --> 00:04:17,340
actually it's kind of interesting

00:04:14,360 --> 00:04:21,140
quicksort is easier to analyze than

00:04:17,340 --> 00:04:24,090
quickselect which is a simpler algorithm

00:04:21,140 --> 00:04:26,580
so quicksort iana it's just easy the

00:04:24,090 --> 00:04:28,890
math is not difficult quickselect is

00:04:26,580 --> 00:04:30,690
absolutely crazy yeah I actually like

00:04:28,890 --> 00:04:32,910
the the latest and greatest like they

00:04:30,690 --> 00:04:34,770
had to use mathematical software to

00:04:32,910 --> 00:04:37,140
analyze it because they couldn't go the

00:04:34,770 --> 00:04:38,340
formula comes like so it's more

00:04:37,140 --> 00:04:41,370
difficult and Einstein's general

00:04:38,340 --> 00:04:46,410
relativity okay maybe I'm exaggerating

00:04:41,370 --> 00:04:49,220
it just a bit so it one nice thing about

00:04:46,410 --> 00:04:53,790
quicksort is it does very little work on

00:04:49,220 --> 00:04:54,990
data that's almost sorted or sorted if

00:04:53,790 --> 00:04:56,910
you cut it right if you kind of take

00:04:54,990 --> 00:04:59,220
care of it and everything it's gonna

00:04:56,910 --> 00:05:03,180
kind of work very nice yes it's very

00:04:59,220 --> 00:05:08,580
nice property idempotence which is also

00:05:03,180 --> 00:05:10,640
polite word and meaning it if the data's

00:05:08,580 --> 00:05:12,990
already sorted is not gonna shuffle it

00:05:10,640 --> 00:05:14,430
there are studying algorithms that are

00:05:12,990 --> 00:05:22,380
going to shuffle data even if it's

00:05:14,430 --> 00:05:25,830
sorted such as such as Thank You

00:05:22,380 --> 00:05:28,500
heapsort the first order of business in

00:05:25,830 --> 00:05:30,150
heapsort is we gotta put the largest

00:05:28,500 --> 00:05:32,220
element that you know the very back of

00:05:30,150 --> 00:05:33,510
the array the first off business let's

00:05:32,220 --> 00:05:36,840
take the greatest that I'm putting at

00:05:33,510 --> 00:05:38,430
the front of the array so hips are like

00:05:36,840 --> 00:05:40,530
worst case in heaps or it's just as good

00:05:38,430 --> 00:05:42,240
as the average case which is kind of

00:05:40,530 --> 00:05:44,610
like they had to find that it's kind of

00:05:42,240 --> 00:05:46,380
a fundamental disadvantage heapsort has

00:05:44,610 --> 00:05:49,860
not to say there's been lot of people

00:05:46,380 --> 00:05:53,850
who spent on improving it but has

00:05:49,860 --> 00:05:56,910
difficulties and it's kind of on average

00:05:53,850 --> 00:05:59,400
is fast and that's kind of a you know

00:05:56,910 --> 00:06:00,960
computer thing computers like to be fast

00:05:59,400 --> 00:06:02,640
on average they don't want to be fast in

00:06:00,960 --> 00:06:05,480
the best case or don't was they want to

00:06:02,640 --> 00:06:08,550
be faster on average for large data sets

00:06:05,480 --> 00:06:10,950
and quicksort last but not least is well

00:06:08,550 --> 00:06:12,360
balanced across comparison swaps meaning

00:06:10,950 --> 00:06:13,830
it doesn't do too many compares compared

00:06:12,360 --> 00:06:17,970
to swaps it doesn't matter you know it

00:06:13,830 --> 00:06:19,919
kind of does about comparable when with

00:06:17,970 --> 00:06:23,610
a native naive implementation of

00:06:19,919 --> 00:06:25,560
quicksort the usual is like two

00:06:23,610 --> 00:06:25,860
recurrence but I replace one recursion

00:06:25,560 --> 00:06:28,889
with

00:06:25,860 --> 00:06:32,219
just to be clear right so it's more

00:06:28,889 --> 00:06:34,289
recursion normal OOP nothing to see here

00:06:32,219 --> 00:06:37,080
except we have a primitive partition

00:06:34,289 --> 00:06:39,599
pivot that's going to choose a pivot

00:06:37,080 --> 00:06:41,280
somehow and it's going to make sure that

00:06:39,599 --> 00:06:43,500
it arranges the array such that

00:06:41,280 --> 00:06:44,909
everything littler than less than the

00:06:43,500 --> 00:06:46,770
pivot is going to be on the left side

00:06:44,909 --> 00:06:48,389
and everything that's greater than a

00:06:46,770 --> 00:06:52,080
pivot is going to come on the right side

00:06:48,389 --> 00:06:55,349
and then you're going to sort the to

00:06:52,080 --> 00:06:57,599
have remaining halves of the array the

00:06:55,349 --> 00:06:59,610
ideal case the partition finds the exact

00:06:57,599 --> 00:07:01,409
middle of the array the median and is

00:06:59,610 --> 00:07:04,020
going to nicely divide the array into

00:07:01,409 --> 00:07:06,090
equal halves and that's going to be the

00:07:04,020 --> 00:07:07,409
best case the worst case of course is

00:07:06,090 --> 00:07:09,870
when you find a bad pivot and you're

00:07:07,409 --> 00:07:12,319
gonna kind of make no progress so almost

00:07:09,870 --> 00:07:15,870
no progress just gonna sort one element

00:07:12,319 --> 00:07:23,159
so the less naive implementation that I

00:07:15,870 --> 00:07:28,020
submit for your attention is with early

00:07:23,159 --> 00:07:31,979
stopping so quicksort uses early

00:07:28,020 --> 00:07:34,830
stopping meaning whenever the array to

00:07:31,979 --> 00:07:39,659
be separate to be sorted is less than a

00:07:34,830 --> 00:07:43,110
threshold it's gonna say you know what

00:07:39,659 --> 00:07:45,210
I'm done here so I'm going to delegate

00:07:43,110 --> 00:07:47,490
that the task of sorting that little

00:07:45,210 --> 00:07:51,089
array that's left I'm going to delegate

00:07:47,490 --> 00:07:52,560
the task to a different routine that's

00:07:51,089 --> 00:07:54,779
special that's good for a smaller race

00:07:52,560 --> 00:07:56,909
it's bad for bigger race problem being

00:07:54,779 --> 00:08:02,069
quicksort is great for big arrays it's

00:07:56,909 --> 00:08:03,659
terrible for small arrays right so if

00:08:02,069 --> 00:08:04,560
you crack up on any standard library

00:08:03,659 --> 00:08:06,719
implementation you're gonna find

00:08:04,560 --> 00:08:12,319
something like this and actually I did

00:08:06,719 --> 00:08:16,500
and threshold is 32 on visual studio and

00:08:12,319 --> 00:08:18,900
it's 16 on all different philosophies I

00:08:16,500 --> 00:08:21,569
guess Windows Linux I dunno

00:08:18,900 --> 00:08:23,250
and client makes a very interesting

00:08:21,569 --> 00:08:28,469
choice which we're gonna talk a bit more

00:08:23,250 --> 00:08:31,620
about it makes it it turns the threshold

00:08:28,469 --> 00:08:35,520
depending on the characteristics of the

00:08:31,620 --> 00:08:37,260
input so you can say well you know if

00:08:35,520 --> 00:08:39,600
the the the type you're giving me to

00:08:37,260 --> 00:08:42,150
sort is trivia trivia

00:08:39,600 --> 00:08:43,979
movable and assignable then I'm gonna

00:08:42,150 --> 00:08:46,640
use a larger threshold otherwise I'm

00:08:43,979 --> 00:08:49,770
going to choose a smaller threshold and

00:08:46,640 --> 00:08:51,510
we're gonna roll like that so all of a

00:08:49,770 --> 00:08:54,690
sudden we see this interesting notion

00:08:51,510 --> 00:08:56,940
you tune this is called a meta parameter

00:08:54,690 --> 00:08:58,590
and I'm not making this up so meta

00:08:56,940 --> 00:09:00,270
parameter is a parameter to the

00:08:58,590 --> 00:09:01,860
algorithm that's nothing that are passed

00:09:00,270 --> 00:09:05,370
on by the user but it's kind of chosen

00:09:01,860 --> 00:09:07,290
in a sort of a hidden way so the

00:09:05,370 --> 00:09:11,340
threshold meta parameter is chosen by

00:09:07,290 --> 00:09:15,000
Clank depending on some relatively

00:09:11,340 --> 00:09:16,500
obscure characteristics of the input so

00:09:15,000 --> 00:09:18,740
you know keep that in mind because I

00:09:16,500 --> 00:09:21,710
believe it's an interesting tidbit and

00:09:18,740 --> 00:09:24,150
for now we're gonna gloss gloss over the

00:09:21,710 --> 00:09:25,920
pathological cases you know kind of

00:09:24,150 --> 00:09:28,260
whenever it becomes quadratic and

00:09:25,920 --> 00:09:30,120
there's a there is a meta algorithm if

00:09:28,260 --> 00:09:32,430
you wish called interest sort that's

00:09:30,120 --> 00:09:34,290
going to detect monitor and detect the

00:09:32,430 --> 00:09:36,900
performance of quicksort whenever things

00:09:34,290 --> 00:09:38,970
go bad is going to just throw everything

00:09:36,900 --> 00:09:41,640
out and fall back to heapsort

00:09:38,970 --> 00:09:45,570
or some other algorithm right so it's

00:09:41,640 --> 00:09:48,630
just gonna redo but you know these

00:09:45,570 --> 00:09:51,290
pathological cases never come up except

00:09:48,630 --> 00:09:54,990
when they come and we're gonna see one

00:09:51,290 --> 00:09:56,370
it's amazing but for now let's let's

00:09:54,990 --> 00:10:02,640
gloss over that so they've like that you

00:09:56,370 --> 00:10:05,310
have right now is decent let's say so

00:10:02,640 --> 00:10:11,610
now the we're gonna focus on small sort

00:10:05,310 --> 00:10:13,200
small sorting small arrays I'm gonna

00:10:11,610 --> 00:10:14,610
bore you the rest of the I'm not kidding

00:10:13,200 --> 00:10:17,340
I'm gonna bore it the rest of the stock

00:10:14,610 --> 00:10:19,770
with sorting small arrays it's not just

00:10:17,340 --> 00:10:21,360
really very small arrays because well

00:10:19,770 --> 00:10:24,480
for large inputs we just talked like

00:10:21,360 --> 00:10:27,960
quicksort is great for very small inputs

00:10:24,480 --> 00:10:31,070
like five ten elements we know we have

00:10:27,960 --> 00:10:34,740
optimal solutions that are hard-coded

00:10:31,070 --> 00:10:36,270
right you just sit down and it's

00:10:34,740 --> 00:10:39,470
actually a hard problem to find like the

00:10:36,270 --> 00:10:42,930
optimal sort for like 15 elements and

00:10:39,470 --> 00:10:45,060
over the years people have found better

00:10:42,930 --> 00:10:46,770
and better algorithms for for small sort

00:10:45,060 --> 00:10:50,130
and they got to the theoretical minimum

00:10:46,770 --> 00:10:52,590
for up to 15 elements now the problem is

00:10:50,130 --> 00:10:53,650
if you saw 15 elements with one of those

00:10:52,590 --> 00:10:55,570
Road route

00:10:53,650 --> 00:10:59,140
it's gonna happen it's gonna be a very

00:10:55,570 --> 00:11:00,850
large routine so we don't like that so

00:10:59,140 --> 00:11:02,620
that's why I say it's kind of solved

00:11:00,850 --> 00:11:04,180
with error codes because not really

00:11:02,620 --> 00:11:06,340
solved it's kind of been you know in

00:11:04,180 --> 00:11:08,500
flux but essentially from a theoretical

00:11:06,340 --> 00:11:09,790
standpoint at least it is a solved

00:11:08,500 --> 00:11:12,610
problem small arrays

00:11:09,790 --> 00:11:15,370
you know we're done so now the challenge

00:11:12,610 --> 00:11:19,110
the real challenge is nobody knows how

00:11:15,370 --> 00:11:23,710
to really sort fast like 1,000 elements

00:11:19,110 --> 00:11:25,870
we have no idea so that's what we're

00:11:23,710 --> 00:11:28,120
gonna work on like a dog with a bone

00:11:25,870 --> 00:11:29,620
we're gonna small we're gonna sort these

00:11:28,120 --> 00:11:32,320
medium sized arrays

00:11:29,620 --> 00:11:35,800
hundreds of elements and we're gonna see

00:11:32,320 --> 00:11:37,480
what's what so the challenge is in this

00:11:35,800 --> 00:11:40,600
algorithm that we just discussed

00:11:37,480 --> 00:11:46,930
increased threshold without compromising

00:11:40,600 --> 00:11:49,030
performance this is the topic by the way

00:11:46,930 --> 00:11:51,940
so this was submit as a Tech Talk not a

00:11:49,030 --> 00:11:53,710
keynote and it was a late submission so

00:11:51,940 --> 00:11:57,580
John said I'm not sure if I can sneak

00:11:53,710 --> 00:11:59,650
you in so then just as nothing like I'm

00:11:57,580 --> 00:12:01,660
like my top was not accepted John said

00:11:59,650 --> 00:12:03,910
nothing for like a month and then I get

00:12:01,660 --> 00:12:05,140
an email like from Michael's birthday

00:12:03,910 --> 00:12:08,560
she said congratulations

00:12:05,140 --> 00:12:12,640
what for he says all for your keynote

00:12:08,560 --> 00:12:15,490
what keynote CPP can here the front page

00:12:12,640 --> 00:12:18,600
of Silicon was like oh my goodness this

00:12:15,490 --> 00:12:18,600
was a tow for like 30 people

00:12:19,129 --> 00:12:22,230
like people are interesting in

00:12:20,999 --> 00:12:24,959
officience in that kind of stuff like

00:12:22,230 --> 00:12:27,449
you know highly niche and so on the way

00:12:24,959 --> 00:12:29,069
to from that from the airport to here

00:12:27,449 --> 00:12:30,660
I'm thinking you know what maybe I don't

00:12:29,069 --> 00:12:37,439
put my seatbelt on there's an accident

00:12:30,660 --> 00:12:41,339
I'd I don't have to be here so anyhow

00:12:37,439 --> 00:12:43,860
going on with the show so our this is

00:12:41,339 --> 00:12:47,189
our this is our like mana make maniac

00:12:43,860 --> 00:12:50,489
all monomaniac all like focus here we

00:12:47,189 --> 00:12:54,049
want to sort smallish hundreds of

00:12:50,489 --> 00:12:57,149
elements erase fast this is it

00:12:54,049 --> 00:12:59,160
so let's see what they do like no and

00:12:57,149 --> 00:13:00,689
Clank and via visual studio what did I

00:12:59,160 --> 00:13:01,679
do they do what's called optimistic

00:13:00,689 --> 00:13:03,629
insertion sort

00:13:01,679 --> 00:13:06,480
starting from the left you cannot do a

00:13:03,629 --> 00:13:08,249
Linea it's gonna have like a progression

00:13:06,480 --> 00:13:09,600
in the array this portion is going to be

00:13:08,249 --> 00:13:11,549
sorted this portion is gonna be

00:13:09,600 --> 00:13:14,040
uncertain again you're going to do a

00:13:11,549 --> 00:13:15,989
linear search backwards in the sorted

00:13:14,040 --> 00:13:17,369
portion for the new element and you're

00:13:15,989 --> 00:13:22,350
going to insert it by moving everything

00:13:17,369 --> 00:13:26,369
else so just for illustration

00:13:22,350 --> 00:13:27,899
courtesy of code for geeks you're gonna

00:13:26,369 --> 00:13:29,669
have like these green elements being

00:13:27,899 --> 00:13:31,649
inserted in the red portion of the array

00:13:29,669 --> 00:13:35,040
which is already sorted and as you can

00:13:31,649 --> 00:13:37,199
see here for example here I mean this is

00:13:35,040 --> 00:13:39,029
the worst case worst case this is best

00:13:37,199 --> 00:13:40,470
case it does not move there's no moving

00:13:39,029 --> 00:13:42,389
because it's already in the right place

00:13:40,470 --> 00:13:44,129
another base case and here you have

00:13:42,389 --> 00:13:46,230
another worst case you have kind of a

00:13:44,129 --> 00:13:49,949
make case right yeah I'm gonna have to

00:13:46,230 --> 00:13:52,230
insert the five here and all is good and

00:13:49,949 --> 00:13:53,399
then we accept the complexity in the

00:13:52,230 --> 00:13:54,720
worst case is gonna be quadratic because

00:13:53,399 --> 00:13:57,389
you gotta you know you do the linear

00:13:54,720 --> 00:13:59,939
searches and you do the linear move a

00:13:57,389 --> 00:14:01,759
rule swapping that around all that

00:13:59,939 --> 00:14:04,379
nonsense right so we don't like that

00:14:01,759 --> 00:14:07,350
however it turns out that you know for

00:14:04,379 --> 00:14:09,389
smaller race is pretty good so for

00:14:07,350 --> 00:14:11,220
example the average number of comparison

00:14:09,389 --> 00:14:14,339
is gonna be half the worst case it's

00:14:11,220 --> 00:14:16,350
just a simple distribution there so it's

00:14:14,339 --> 00:14:20,129
gonna be like 240 comparisons and swaps

00:14:16,350 --> 00:14:22,709
for 32 elements so that strikes me like

00:14:20,129 --> 00:14:26,399
quite a fair amount of those which we

00:14:22,709 --> 00:14:28,319
want to reduce agreed I hope this kind

00:14:26,399 --> 00:14:31,380
of you know bit of overkill right so we

00:14:28,319 --> 00:14:33,509
don't like that so of course

00:14:31,380 --> 00:14:35,279
those fools who spend their careers

00:14:33,509 --> 00:14:37,949
implementing standard libraries they

00:14:35,279 --> 00:14:40,130
never heard of binary search but I did

00:14:37,949 --> 00:14:43,050
so let me try it

00:14:40,130 --> 00:14:45,810
and of course I I knew there's something

00:14:43,050 --> 00:14:48,839
wrong with binary binary insertion

00:14:45,810 --> 00:14:50,970
because nobody does it and there are

00:14:48,839 --> 00:14:53,639
people who like you know this they wake

00:14:50,970 --> 00:14:55,290
up and they think of it and I think of

00:14:53,639 --> 00:14:57,149
like five minutes a day right so it's

00:14:55,290 --> 00:14:58,860
like well wait a second what's going on

00:14:57,149 --> 00:14:59,610
here so you're gonna figure out what's

00:14:58,860 --> 00:15:02,399
what's gonna here

00:14:59,610 --> 00:15:04,380
so the strategy now is let's do binary

00:15:02,399 --> 00:15:08,130
search instead of linear search and that

00:15:04,380 --> 00:15:09,930
way we gain a lot for example CEO of 32

00:15:08,130 --> 00:15:13,730
the number of compressors were 32

00:15:09,930 --> 00:15:19,110
elements drop down by a lot for 250 to

00:15:13,730 --> 00:15:23,250
155 so slam dunk right there so let me

00:15:19,110 --> 00:15:26,279
code it and test it and we got a very

00:15:23,250 --> 00:15:28,470
neat 15 percent reduction of comparisons

00:15:26,279 --> 00:15:30,899
I mean quicksort on 1 million elements

00:15:28,470 --> 00:15:34,199
using this binary search and sort as as

00:15:30,899 --> 00:15:37,470
the fallback for smaller race and we get

00:15:34,199 --> 00:15:39,750
to a very nice from 23 million something

00:15:37,470 --> 00:15:42,449
comparisons to 22 million so looking at

00:15:39,750 --> 00:15:45,660
15 percent win in the number of

00:15:42,449 --> 00:15:47,490
comparisons which is awesome so I stir

00:15:45,660 --> 00:15:49,110
make the code I ran the test I was very

00:15:47,490 --> 00:15:55,110
happy about it was jumping up and down

00:15:49,110 --> 00:16:03,660
the house and I've measured a 13% pacem

00:15:55,110 --> 00:16:08,250
ization of the runtime 13% worse with

00:16:03,660 --> 00:16:14,130
fewer comparisons notebook is gonna tell

00:16:08,250 --> 00:16:16,500
you that forget Cormack throw it away no

00:16:14,130 --> 00:16:18,240
book is gonna tell you that sorry no

00:16:16,500 --> 00:16:20,120
problem gonna mess with the threshold

00:16:18,240 --> 00:16:24,569
and stuff nothing works

00:16:20,120 --> 00:16:27,810
binary search sort is always slower than

00:16:24,569 --> 00:16:31,699
optimistic linear insertion sort like

00:16:27,810 --> 00:16:33,990
for all meta parameters possible I tried

00:16:31,699 --> 00:16:35,459
and obviously the standard library

00:16:33,990 --> 00:16:37,620
implementers don't do that because they

00:16:35,459 --> 00:16:43,260
measured and they saw it's bad so why do

00:16:37,620 --> 00:16:44,340
it so I got to thinking what's going on

00:16:43,260 --> 00:16:47,310
here

00:16:44,340 --> 00:16:51,060
and I thought well it's it must be about

00:16:47,310 --> 00:16:55,500
predictability and entropy informational

00:16:51,060 --> 00:16:57,750
entropy consider this when you do a

00:16:55,500 --> 00:17:00,540
linear search in that simple assumptions

00:16:57,750 --> 00:17:03,390
or the linear version each search is

00:17:00,540 --> 00:17:07,470
going to have one failure per search at

00:17:03,390 --> 00:17:10,380
the end when you found it so we're gonna

00:17:07,470 --> 00:17:11,910
have a success rate of comparisons there

00:17:10,380 --> 00:17:17,520
like that's going to be huge there'll be

00:17:11,910 --> 00:17:21,270
like 90% however the binary search is in

00:17:17,520 --> 00:17:23,760
the exact opposite each binary search by

00:17:21,270 --> 00:17:26,339
its definition information is going to

00:17:23,760 --> 00:17:30,360
extract one bit of information it's the

00:17:26,339 --> 00:17:33,150
most information revealing test it can

00:17:30,360 --> 00:17:35,280
make the binary I'm gonna search in the

00:17:33,150 --> 00:17:37,740
middle does you gain the most

00:17:35,280 --> 00:17:40,470
information that way so it has that you

00:17:37,740 --> 00:17:41,910
know the most it's like the best thing

00:17:40,470 --> 00:17:44,220
you can do from an informational

00:17:41,910 --> 00:17:48,200
standpoint and it's the worst he can do

00:17:44,220 --> 00:17:48,200
from the point of from the viewpoint of

00:17:49,310 --> 00:18:00,120
who's that cash branch predictor right

00:17:56,880 --> 00:18:02,820
sorry I didn't mean to single anyone out

00:18:00,120 --> 00:18:05,730
so so the branch predictor is going to

00:18:02,820 --> 00:18:07,280
be super happy just you know just going

00:18:05,730 --> 00:18:09,210
with pretty highly predictable

00:18:07,280 --> 00:18:12,120
comparisons but when it comes to a

00:18:09,210 --> 00:18:15,090
binary search the branch line she's

00:18:12,120 --> 00:18:17,640
gonna have 50% chances of doing anything

00:18:15,090 --> 00:18:23,400
right right so it's just gonna be branch

00:18:17,640 --> 00:18:26,790
prediction is powerless and I made this

00:18:23,400 --> 00:18:29,520
very unpleasant realization I like maybe

00:18:26,790 --> 00:18:32,070
like you know like all of us have like a

00:18:29,520 --> 00:18:33,860
couple of meters of algorithms books at

00:18:32,070 --> 00:18:36,660
home and at work

00:18:33,860 --> 00:18:40,260
right you could kill an ox with one

00:18:36,660 --> 00:18:41,970
right and you know all research and all

00:18:40,260 --> 00:18:44,280
textbooks and all the classic literature

00:18:41,970 --> 00:18:46,290
goes minimize comparisons and you're

00:18:44,280 --> 00:18:49,170
gonna be happy minimize comparisons

00:18:46,290 --> 00:18:55,160
gonna be happy not I'm not happy I am

00:18:49,170 --> 00:18:57,750
happy so well what do we do now so

00:18:55,160 --> 00:19:00,670
what's gonna

00:18:57,750 --> 00:19:02,470
and if you thought it's not weird enough

00:19:00,670 --> 00:19:06,130
there exists such a thing which is

00:19:02,470 --> 00:19:10,270
called branchless binary search so I

00:19:06,130 --> 00:19:13,470
coded that too like oh if branchy is not

00:19:10,270 --> 00:19:15,880
good then branchless is gonna be awesome

00:19:13,470 --> 00:19:18,070
branches branchless has a different

00:19:15,880 --> 00:19:21,730
problem though it can't do early

00:19:18,070 --> 00:19:22,990
stopping branchless you cannot go

00:19:21,730 --> 00:19:25,030
through all the bits you're gonna have

00:19:22,990 --> 00:19:27,100
to click go all the log and steps all

00:19:25,030 --> 00:19:29,380
the way down and so essentially there's

00:19:27,100 --> 00:19:31,120
no early stopping for it for each search

00:19:29,380 --> 00:19:34,210
you're gonna have to go all you know

00:19:31,120 --> 00:19:36,640
logging operations so actually

00:19:34,210 --> 00:19:44,020
branchless is even slower than binary em

00:19:36,640 --> 00:19:46,870
branchy binary search so I was kinda

00:19:44,020 --> 00:19:51,540
dead in the water here more ideas let's

00:19:46,870 --> 00:19:54,730
see what to do what to do well

00:19:51,540 --> 00:19:56,620
inspiration from tinder you know those

00:19:54,730 --> 00:19:59,850
ads on tinder that say I want somebody

00:19:56,620 --> 00:20:01,990
who's like strong but also sensitive I

00:19:59,850 --> 00:20:05,010
want you know somebody we can wear like

00:20:01,990 --> 00:20:09,100
a fancy dress but also like hiking boots

00:20:05,010 --> 00:20:11,170
at the same time right and I want

00:20:09,100 --> 00:20:12,550
someone who's smart but also poor I want

00:20:11,170 --> 00:20:15,700
an algorithm that is smart but also

00:20:12,550 --> 00:20:17,860
boring so it's boring enough to make the

00:20:15,700 --> 00:20:19,450
branch predictor happy and it's also

00:20:17,860 --> 00:20:23,190
smart enough to kind of beat the

00:20:19,450 --> 00:20:26,670
baseline alright

00:20:23,190 --> 00:20:29,640
who's taught the Silicon Valley show

00:20:26,670 --> 00:20:32,730
alright so you know be loud compression

00:20:29,640 --> 00:20:35,560
awesome so how about me loud insertion

00:20:32,730 --> 00:20:37,450
we start from the middle and go like

00:20:35,560 --> 00:20:40,750
that we take advantage of the fact that

00:20:37,450 --> 00:20:42,970
we have two places we can grow the the

00:20:40,750 --> 00:20:46,410
sorted portion we keep a sorted portion

00:20:42,970 --> 00:20:49,090
in the middle and we gray like that and

00:20:46,410 --> 00:20:50,530
that way you get to swap half the times

00:20:49,090 --> 00:20:51,760
because you don't just swap you know you

00:20:50,530 --> 00:20:53,650
don't chase turkey and swap like

00:20:51,760 --> 00:20:56,410
everything you insert here swap only a

00:20:53,650 --> 00:20:59,880
little thing so an average you're having

00:20:56,410 --> 00:21:03,790
the number of swaps whoa

00:20:59,880 --> 00:21:07,410
let's go that out middle sort awesome

00:21:03,790 --> 00:21:10,300
all right we're gonna patent this

00:21:07,410 --> 00:21:11,380
so you code it very carefully so by the

00:21:10,300 --> 00:21:13,570
way whenever you call

00:21:11,380 --> 00:21:15,580
things like this very careful to not do

00:21:13,570 --> 00:21:17,680
extra work so you're gonna start from

00:21:15,580 --> 00:21:20,020
the middle and notice one detail here

00:21:17,680 --> 00:21:24,400
which is gonna come again and again here

00:21:20,020 --> 00:21:26,290
sighs and one auto right equals first

00:21:24,400 --> 00:21:28,300
plus one plus size and one I'm

00:21:26,290 --> 00:21:30,490
positioning myself in the middle of the

00:21:28,300 --> 00:21:32,530
array but depending on whether the array

00:21:30,490 --> 00:21:33,970
has an even or odd number of elements I

00:21:32,530 --> 00:21:36,460
want to position myself differently

00:21:33,970 --> 00:21:38,740
because you know the middle of if it's

00:21:36,460 --> 00:21:40,090
an array with an odd number of elements

00:21:38,740 --> 00:21:42,520
I want to push you myself just a bit

00:21:40,090 --> 00:21:44,440
sideways so I'm gonna grow the right way

00:21:42,520 --> 00:21:45,940
otherwise I'm gonna have two things that

00:21:44,440 --> 00:21:51,550
are identical I end up doing extra work

00:21:45,940 --> 00:21:55,810
so notice how here I'm integrating this

00:21:51,550 --> 00:22:02,080
not there's not if here I'm integrating

00:21:55,810 --> 00:22:04,840
a conditional within the arithmetic so

00:22:02,080 --> 00:22:09,760
there's no if sighs and one you know

00:22:04,840 --> 00:22:11,500
right plus plus right this is gonna be a

00:22:09,760 --> 00:22:14,380
lot faster it turns out because it's a

00:22:11,500 --> 00:22:15,820
it's a compare without a jump if you

00:22:14,380 --> 00:22:20,280
code it as an if is going to be a

00:22:15,820 --> 00:22:23,200
compare with a jump big difference okay

00:22:20,280 --> 00:22:26,260
always try to integrate conditionals

00:22:23,200 --> 00:22:27,640
within your arithmetic just the

00:22:26,260 --> 00:22:30,460
condition is like a boolean it's an

00:22:27,640 --> 00:22:32,650
integer that's 0 1 that's it consider it

00:22:30,460 --> 00:22:36,010
an integer 0 1 and then you know make it

00:22:32,650 --> 00:22:37,450
flow through the calculation so this is

00:22:36,010 --> 00:22:39,640
I think a highly up you know highly

00:22:37,450 --> 00:22:42,010
thought thought of highly optimized

00:22:39,640 --> 00:22:44,740
version of what I would call middle out

00:22:42,010 --> 00:22:46,450
insertion sort but by the way don't

00:22:44,740 --> 00:22:51,250
think we're very hurried you know here

00:22:46,450 --> 00:22:53,170
like me and many of you and 10,000

00:22:51,250 --> 00:22:55,560
undergraduate students in India have

00:22:53,170 --> 00:22:58,240
coded this okay

00:22:55,560 --> 00:22:59,890
so it's a class you know there's a whole

00:22:58,240 --> 00:23:02,140
cottage industry there's a little

00:22:59,890 --> 00:23:04,780
community of people who write variations

00:23:02,140 --> 00:23:06,100
of insertion sort there's a couple if

00:23:04,780 --> 00:23:06,370
you which they want to take over the

00:23:06,100 --> 00:23:08,770
world

00:23:06,370 --> 00:23:11,200
okay there's just a bunch of people who

00:23:08,770 --> 00:23:13,240
devised the spend our days devising this

00:23:11,200 --> 00:23:15,280
kind of stuff to have a time assertion K

00:23:13,240 --> 00:23:17,740
at a time assertion shells or binary

00:23:15,280 --> 00:23:20,370
merge sort library sort of very recent

00:23:17,740 --> 00:23:24,370
algorithm all of these can be considered

00:23:20,370 --> 00:23:25,309
insertion sort variants so we're not you

00:23:24,370 --> 00:23:31,009
know we're not gonna patent

00:23:25,309 --> 00:23:34,909
you know so awesome seven percent better

00:23:31,009 --> 00:23:36,830
comparisons for the million doubles 13%

00:23:34,909 --> 00:23:39,470
better moves as expected we gain on

00:23:36,830 --> 00:23:46,340
moves big time however no significant

00:23:39,470 --> 00:23:49,039
improvement in time run and this is

00:23:46,340 --> 00:23:51,740
where you can make a difference because

00:23:49,039 --> 00:23:53,389
at this point you can quit where at this

00:23:51,740 --> 00:23:54,759
point you can say I'm gonna make this

00:23:53,389 --> 00:24:03,169
the purpose of my life right now

00:23:54,759 --> 00:24:05,360
hey so what to do in if you know every

00:24:03,169 --> 00:24:06,980
every key note has a having time like by

00:24:05,360 --> 00:24:09,230
you know by tomorrow this time I'm gonna

00:24:06,980 --> 00:24:13,039
forget everything I said but if there's

00:24:09,230 --> 00:24:17,210
one thing I want you to remember is try

00:24:13,039 --> 00:24:20,809
silly things because trying the smart

00:24:17,210 --> 00:24:23,149
things didn't work did it trying the

00:24:20,809 --> 00:24:25,759
good things did just didn't help you one

00:24:23,149 --> 00:24:30,139
bit did it so how about I try something

00:24:25,759 --> 00:24:32,059
stupid see how the hell that goes so

00:24:30,139 --> 00:24:34,490
you're gonna go the other way we're

00:24:32,059 --> 00:24:36,200
gonna acknowledge that the computer gods

00:24:34,490 --> 00:24:38,419
are so complicated their you know

00:24:36,200 --> 00:24:40,340
willingness and whatever they do that

00:24:38,419 --> 00:24:42,039
we're gonna give up on that I don't want

00:24:40,340 --> 00:24:44,269
to understand what's going on and

00:24:42,039 --> 00:24:45,619
because I don't understand I'm going to

00:24:44,269 --> 00:24:50,200
try things that don't make absolutely no

00:24:45,619 --> 00:24:59,259
sense and let's see what happens

00:24:50,200 --> 00:25:03,399
ready I heard one years like literally

00:24:59,259 --> 00:25:06,240
like one like golf or intensity yes yes

00:25:03,399 --> 00:25:08,070
please

00:25:06,240 --> 00:25:11,520
so here's the shower thought that

00:25:08,070 --> 00:25:13,020
motivates this the you know what's bad

00:25:11,520 --> 00:25:15,240
about this is whenever you move things

00:25:13,020 --> 00:25:17,610
if you move small elements in large

00:25:15,240 --> 00:25:19,890
sorted sub-arrays you're gonna spend a

00:25:17,610 --> 00:25:21,950
lot of swaps so the promise like the

00:25:19,890 --> 00:25:24,750
small elements are too much to the right

00:25:21,950 --> 00:25:26,730
so I want to have some pre-processing

00:25:24,750 --> 00:25:29,250
that brings the statistically smaller

00:25:26,730 --> 00:25:31,410
elements to the left so then when I do

00:25:29,250 --> 00:25:38,400
the insertion sort is gonna be better

00:25:31,410 --> 00:25:42,450
swap wise enter stupid small sort stupid

00:25:38,400 --> 00:25:44,120
small sort now a smart pointers then

00:25:42,450 --> 00:25:46,890
every how about some stupid algorithm

00:25:44,120 --> 00:25:50,130
right stupid small sort and it's gonna

00:25:46,890 --> 00:25:51,120
do two things make hip and the classic

00:25:50,130 --> 00:25:56,040
insertion sort

00:25:51,120 --> 00:25:59,940
thank you very much I'm almost sorry

00:25:56,040 --> 00:26:02,040
there's no rotating their IRA which

00:25:59,940 --> 00:26:06,270
they're like by rotating just works

00:26:02,040 --> 00:26:09,240
awesomely so I'll eat this is it I'm

00:26:06,270 --> 00:26:11,940
doing extra work because I'm comparing

00:26:09,240 --> 00:26:15,150
this with the same function in which I

00:26:11,940 --> 00:26:18,090
come in the first line so literally

00:26:15,150 --> 00:26:21,000
we're doing more work instead of just

00:26:18,090 --> 00:26:22,740
calling insertion sort let's make a heap

00:26:21,000 --> 00:26:25,560
before which is kind of a structure that

00:26:22,740 --> 00:26:27,480
has its own interesting properties and

00:26:25,560 --> 00:26:29,820
it's kind of a you know it's kind of

00:26:27,480 --> 00:26:31,980
fine-tune thing an interesting delicate

00:26:29,820 --> 00:26:33,330
structure they're like you know what I'm

00:26:31,980 --> 00:26:35,310
gonna make one of these interesting

00:26:33,330 --> 00:26:36,780
delicate dainty structures and they're

00:26:35,310 --> 00:26:38,670
like an idiot I'm gonna forget all about

00:26:36,780 --> 00:26:42,210
it and I'm gonna do a stupid insertion

00:26:38,670 --> 00:26:45,990
sort all over it with no regard for the

00:26:42,210 --> 00:26:51,160
structure of the heap is this stupid

00:26:45,990 --> 00:26:56,870
enough right no we want more stupid okay

00:26:51,160 --> 00:27:01,030
don't test me here's one here's a little

00:26:56,870 --> 00:27:06,080
improvement I'm going to use unguarded

00:27:01,030 --> 00:27:11,510
insertion sort raise your hand if you

00:27:06,080 --> 00:27:14,210
got it I see one hand in the in the

00:27:11,510 --> 00:27:18,440
little last row one hand and with the

00:27:14,210 --> 00:27:20,020
middle finger pointed up she was like

00:27:18,440 --> 00:27:22,460
what

00:27:20,020 --> 00:27:24,080
so here's I've shared with a

00:27:22,460 --> 00:27:26,300
mathematician I'm corresponding with

00:27:24,080 --> 00:27:28,160
brilliant mathematician also brilliant

00:27:26,300 --> 00:27:31,730
hacker he has like all these awesome

00:27:28,160 --> 00:27:33,170
like routines and so he first didn't

00:27:31,730 --> 00:27:34,520
understand what I what I meant to do it

00:27:33,170 --> 00:27:35,960
was so stupid he he said I don't

00:27:34,520 --> 00:27:37,940
understand what you want what you plan

00:27:35,960 --> 00:27:40,429
what you want to do here I said make a

00:27:37,940 --> 00:27:44,090
heap and then play nice action sort and

00:27:40,429 --> 00:27:50,140
that was his all his email that was the

00:27:44,090 --> 00:27:50,140
entire email he sent me very motivating

00:27:50,230 --> 00:27:55,730
so let's recall the I do have an angle

00:27:53,929 --> 00:27:58,700
here ladies and gentlemen everybody like

00:27:55,730 --> 00:28:00,890
I do have an I do have a thing and my

00:27:58,700 --> 00:28:03,320
thing is the following in a heap you're

00:28:00,890 --> 00:28:07,850
going to have the very smallest element

00:28:03,320 --> 00:28:09,290
at the top of the heap ie it's in an

00:28:07,850 --> 00:28:11,630
array it's going to be the very first

00:28:09,290 --> 00:28:13,309
element of the array so it's gonna be

00:28:11,630 --> 00:28:15,830
the smallest element at the being of the

00:28:13,309 --> 00:28:18,890
array and everybody's happy everybody's

00:28:15,830 --> 00:28:22,190
happy because then I can do this

00:28:18,890 --> 00:28:24,020
unguarded insertion sort meaning I don't

00:28:22,190 --> 00:28:26,770
need to do bounce checking when I test

00:28:24,020 --> 00:28:29,420
for inequality going down the array

00:28:26,770 --> 00:28:32,240
because you can't be smaller than the

00:28:29,420 --> 00:28:34,100
smallest so sooner or later you're gonna

00:28:32,240 --> 00:28:35,960
hit somebody that's they're smaller than

00:28:34,100 --> 00:28:39,260
you and then you're done and you insert

00:28:35,960 --> 00:28:41,900
the element so if you know for a fact

00:28:39,260 --> 00:28:44,240
that the smallest element in the little

00:28:41,900 --> 00:28:45,950
array is at the very beginning of the

00:28:44,240 --> 00:28:51,710
array you don't need to do bounds

00:28:45,950 --> 00:28:56,750
checking agreed awesome

00:28:51,710 --> 00:28:59,120
and why is this big in plus 3 here it's

00:28:56,750 --> 00:29:01,479
not begin and it's begin plus 3 what's

00:28:59,120 --> 00:29:04,599
with 3

00:29:01,479 --> 00:29:06,519
yes I'm hearing some good points so it's

00:29:04,599 --> 00:29:08,950
beginning possibly because the first is

00:29:06,519 --> 00:29:10,929
the smallest the second is going to be

00:29:08,950 --> 00:29:13,089
something greater than the smallest so

00:29:10,929 --> 00:29:15,129
the first two are already sorted so I

00:29:13,089 --> 00:29:17,559
start with inserting a third element

00:29:15,129 --> 00:29:19,659
into the sorted portion of the two first

00:29:17,559 --> 00:29:24,579
elements believe me

00:29:19,659 --> 00:29:25,029
this three is three percent I am not

00:29:24,579 --> 00:29:30,700
kidding

00:29:25,029 --> 00:29:32,379
so is this kind of stuff make sure you

00:29:30,700 --> 00:29:35,529
do the word that needs to be done but

00:29:32,379 --> 00:29:39,219
not extra extra work is not being

00:29:35,529 --> 00:29:43,379
compensated in computer science no it's

00:29:39,219 --> 00:29:46,089
not like school don't do extra work so

00:29:43,379 --> 00:29:49,450
that's why you know that's my whole idea

00:29:46,089 --> 00:29:50,649
I'm going to statistically I'm gonna put

00:29:49,450 --> 00:29:52,779
the smallest in the front which is a

00:29:50,649 --> 00:29:54,249
huge advantage to start with awesome I

00:29:52,779 --> 00:29:56,799
don't need to do the boss checking and

00:29:54,249 --> 00:29:59,019
then it's you if you look at these sub

00:29:56,799 --> 00:30:02,049
arrays here like you know one two

00:29:59,019 --> 00:30:04,959
seventeen twenty five one three seven so

00:30:02,049 --> 00:30:07,209
I'm going to have a few sort sorted sub

00:30:04,959 --> 00:30:08,979
you know streaks within the array the

00:30:07,209 --> 00:30:10,509
way this is arranged by the way the heap

00:30:08,979 --> 00:30:12,099
when you arrange it down with just

00:30:10,509 --> 00:30:15,849
inorder traversal so it's gonna be one

00:30:12,099 --> 00:30:19,179
two three seven P 1936 seven 25 100 and

00:30:15,849 --> 00:30:20,739
that's my array now this array is not

00:30:19,179 --> 00:30:22,509
sorted is far from being sort and in

00:30:20,739 --> 00:30:25,209
fact if you look at that seven there

00:30:22,509 --> 00:30:27,579
right or it's 3604 seven so it's kind

00:30:25,209 --> 00:30:31,329
it's not sorted at all however it does

00:30:27,579 --> 00:30:33,999
have this partial sorting behavior so

00:30:31,329 --> 00:30:37,570
what I'm trying to do here by calling my

00:30:33,999 --> 00:30:40,899
heap is to essentially put mine my rain

00:30:37,570 --> 00:30:41,999
up in us in a topology that's going to

00:30:40,899 --> 00:30:49,719
make it

00:30:41,999 --> 00:30:52,690
favorable for insertion sort let's take

00:30:49,719 --> 00:30:55,749
a look so imagine we set up the rig we

00:30:52,690 --> 00:30:58,059
measure when we get a very nice

00:30:55,749 --> 00:31:00,279
improvement nine percent implementing

00:30:58,059 --> 00:31:03,369
comparisons a whole whopping twenty

00:31:00,279 --> 00:31:09,570
percent less in swaps a lot less data

00:31:03,369 --> 00:31:09,570
moves by doing more work

00:31:11,230 --> 00:31:15,760
so I find that fascinating is like it's

00:31:14,050 --> 00:31:18,310
a gambit is like you know I'm gonna do

00:31:15,760 --> 00:31:22,410
this extra work in hope that arranging

00:31:18,310 --> 00:31:22,410
things for the next stage right

00:31:22,530 --> 00:31:34,420
9% pessimism my wife and kids hated that

00:31:30,370 --> 00:31:37,270
day they didn't like that day I was

00:31:34,420 --> 00:31:37,720
grumpy and what the hell is happening

00:31:37,270 --> 00:31:41,350
here

00:31:37,720 --> 00:31:49,330
leave me alone right so I'm looking at a

00:31:41,350 --> 00:31:51,370
9% pessimism but there is hope because

00:31:49,330 --> 00:31:53,560
maybe you know the direction is real

00:31:51,370 --> 00:31:56,560
good so I'm reducing a lot of metrics by

00:31:53,560 --> 00:31:58,120
a lot and you know maybe I'm gonna

00:31:56,560 --> 00:31:59,650
increase threshold and experiment with

00:31:58,120 --> 00:32:01,990
that because now I can afford to

00:31:59,650 --> 00:32:04,240
increase threshold just because I reduce

00:32:01,990 --> 00:32:06,760
the swaps India to comparison so much so

00:32:04,240 --> 00:32:13,690
I can play with that and I actually can

00:32:06,760 --> 00:32:17,050
start to micro optimize dear colleagues

00:32:13,690 --> 00:32:19,450
it's time to put the hard hats on and go

00:32:17,050 --> 00:32:29,470
down in the mind to shake hands with the

00:32:19,450 --> 00:32:31,300
devil micro optimizations the way to

00:32:29,470 --> 00:32:34,120
transform an array into a heap is called

00:32:31,300 --> 00:32:37,120
Floyd's algorithm is from the 60s great

00:32:34,120 --> 00:32:38,920
algorithm very nice from half of the

00:32:37,120 --> 00:32:42,040
affirmative rate down to zero you're

00:32:38,920 --> 00:32:44,080
going to insert into the partial sub sub

00:32:42,040 --> 00:32:45,490
he below and you're going to done after

00:32:44,080 --> 00:32:48,760
inserting the root which is element at

00:32:45,490 --> 00:32:51,040
index 0 sorry on the side so the way

00:32:48,760 --> 00:32:52,690
it's done on rosetta code is just you

00:32:51,040 --> 00:32:56,380
have this chiefdom routine called inner

00:32:52,690 --> 00:32:58,360
loop and that's pretty much it and the

00:32:56,380 --> 00:33:02,530
shift down routine itself is kind of

00:32:58,360 --> 00:33:04,630
hairy so looking here at some

00:33:02,530 --> 00:33:07,480
calculations and stuff and we have like

00:33:04,630 --> 00:33:08,350
one two conditionals three four

00:33:07,480 --> 00:33:11,350
conditionals

00:33:08,350 --> 00:33:13,240
five conditionals swap so we have quite

00:33:11,350 --> 00:33:15,520
a bit of work within the inner loop

00:33:13,240 --> 00:33:18,270
remember this is a loop inside a loop

00:33:15,520 --> 00:33:20,530
right so I have a loop inner loop right

00:33:18,270 --> 00:33:22,720
so we got five compare and jump

00:33:20,530 --> 00:33:25,180
decisions points and we have three ads

00:33:22,720 --> 00:33:28,750
and shifts and six assignments

00:33:25,180 --> 00:33:31,000
and we must work on reducing this what

00:33:28,750 --> 00:33:33,070
they do to improve an algorithm that is

00:33:31,000 --> 00:33:34,360
implemented in a standard library you

00:33:33,070 --> 00:33:40,600
look how they do it in a standard

00:33:34,360 --> 00:33:42,580
library I gotta give it to the folks who

00:33:40,600 --> 00:33:46,090
implant the standard library they gotta

00:33:42,580 --> 00:33:47,590
write all of those underscores all of

00:33:46,090 --> 00:33:49,870
those damn matter square is just killing

00:33:47,590 --> 00:33:51,700
me just you know just for that they

00:33:49,870 --> 00:33:53,620
should get a bonus like every year the

00:33:51,700 --> 00:33:56,260
underscore premium you got right right

00:33:53,620 --> 00:33:58,870
now underscore bonus you'd go like ten

00:33:56,260 --> 00:34:02,640
percent of salary this is it for like

00:33:58,870 --> 00:34:04,690
you know extra dangerous in your work

00:34:02,640 --> 00:34:06,700
but actually it's a very meaningful

00:34:04,690 --> 00:34:08,230
algorithm so I looked at the analyze it

00:34:06,700 --> 00:34:12,070
and you know it's kind of what also the

00:34:08,230 --> 00:34:14,440
other libraries do and they use moves

00:34:12,070 --> 00:34:16,300
East at those swaps number one so they

00:34:14,440 --> 00:34:18,550
use the they take advantage of state

00:34:16,300 --> 00:34:20,140
move and friends so instead of swapping

00:34:18,550 --> 00:34:21,490
things around they kind of register

00:34:20,140 --> 00:34:23,530
things so they move into a register and

00:34:21,490 --> 00:34:25,690
then they move back from the register

00:34:23,530 --> 00:34:28,120
into the thing and for doubles movies

00:34:25,690 --> 00:34:30,580
gonna be on no op it's gonna be a simple

00:34:28,120 --> 00:34:31,870
assignment so essentially in my code I'm

00:34:30,580 --> 00:34:33,340
not gonna have the move but you can

00:34:31,870 --> 00:34:34,720
assume that for a general algorithm

00:34:33,340 --> 00:34:38,560
we're gonna have the appropriate moves

00:34:34,720 --> 00:34:40,600
in in there and the inner loop is to

00:34:38,560 --> 00:34:42,190
comparison jumps and for thematic and to

00:34:40,600 --> 00:34:44,080
assignments and the author loopy there's

00:34:42,190 --> 00:34:45,640
a bunch of fixed approach to handle s

00:34:44,080 --> 00:34:47,950
not let me explain what's the deal with

00:34:45,640 --> 00:34:52,660
the last note here because this last

00:34:47,950 --> 00:34:54,550
note I hate it all right so what's the

00:34:52,660 --> 00:34:56,710
size of this array one two three four

00:34:54,550 --> 00:34:58,780
five six seven eight nine so have a nine

00:34:56,710 --> 00:35:01,540
elementary what if you had the ten

00:34:58,780 --> 00:35:05,080
element array there'd be a a child for

00:35:01,540 --> 00:35:07,960
the nineteen element right this guy so

00:35:05,080 --> 00:35:11,770
this node would have a child but an only

00:35:07,960 --> 00:35:14,080
child he turns out whenever you do that

00:35:11,770 --> 00:35:16,810
thing that spoiled brat of a child is

00:35:14,080 --> 00:35:18,940
gonna just mess up things because you

00:35:16,810 --> 00:35:21,640
need to test in every iteration there

00:35:18,940 --> 00:35:27,190
whether this is a heap with a lone child

00:35:21,640 --> 00:35:28,930
or a heap with two siblings and that's

00:35:27,190 --> 00:35:30,940
what new does that's what Microsoft does

00:35:28,930 --> 00:35:34,300
that's what everybody does they're just

00:35:30,940 --> 00:35:36,040
going to test for this here actually you

00:35:34,300 --> 00:35:37,820
can see this is the fix up for the

00:35:36,040 --> 00:35:40,220
launch out

00:35:37,820 --> 00:35:41,900
so very unpleasant and you know I'm

00:35:40,220 --> 00:35:46,220
gonna spend out of time thinking how can

00:35:41,900 --> 00:35:57,490
I eliminate this situation I hope you're

00:35:46,220 --> 00:36:01,400
gonna like this we're going to ignore

00:35:57,490 --> 00:36:03,080
the spoiled brat we're going to treat

00:36:01,400 --> 00:36:05,390
that you know the lone child if it

00:36:03,080 --> 00:36:07,940
exists we're going to treat it as if it

00:36:05,390 --> 00:36:13,670
doesn't exist so we're going to make a

00:36:07,940 --> 00:36:16,160
heap without the last element but if

00:36:13,670 --> 00:36:17,930
only there was a method to push an

00:36:16,160 --> 00:36:24,200
element that's not in a heap into the

00:36:17,930 --> 00:36:26,510
heap push heap so you make a heap for

00:36:24,200 --> 00:36:29,720
the advantages case which is faster and

00:36:26,510 --> 00:36:31,310
then you have one note at the very end

00:36:29,720 --> 00:36:33,500
and then you call push heap and it's in

00:36:31,310 --> 00:36:35,870
the heap log and cost and you're done

00:36:33,500 --> 00:36:39,590
and you save all the comparisons in the

00:36:35,870 --> 00:36:47,540
loop so you save a lot and in the end is

00:36:39,590 --> 00:36:50,030
idea fine I'm gonna push it on one more

00:36:47,540 --> 00:36:51,440
thing about optimization it's very good

00:36:50,030 --> 00:36:53,360
to study the standard library because

00:36:51,440 --> 00:36:56,630
you're gonna see that there's people for

00:36:53,360 --> 00:37:01,370
whom like waste of work is like black

00:36:56,630 --> 00:37:04,520
lung two miners they just they they are

00:37:01,370 --> 00:37:07,130
going to debate every single cycle every

00:37:04,520 --> 00:37:11,240
single cycle lost is going to end up on

00:37:07,130 --> 00:37:13,670
their forehead so if you optimize I

00:37:11,240 --> 00:37:18,200
think a very good state of mind is you

00:37:13,670 --> 00:37:22,730
know I want every I want to draw every

00:37:18,200 --> 00:37:25,130
cycle possible from this code I want to

00:37:22,730 --> 00:37:29,570
be able to defend everything I do in a

00:37:25,130 --> 00:37:31,190
court of law this is the attitude and if

00:37:29,570 --> 00:37:32,870
you look at rosetta code that's not the

00:37:31,190 --> 00:37:34,730
attitude which is fine because for

00:37:32,870 --> 00:37:36,560
teaching but if you've got a standard

00:37:34,730 --> 00:37:37,760
library implementation you're gonna see

00:37:36,560 --> 00:37:41,710
that there's people with that attitude

00:37:37,760 --> 00:37:45,670
and we're going to do just the same

00:37:41,710 --> 00:37:47,840
first insertion sort keep stupid sort a

00:37:45,670 --> 00:37:49,910
surface last you know whatever they

00:37:47,840 --> 00:37:51,350
would erase be well-formed I'm going to

00:37:49,910 --> 00:37:54,740
computer size and then if the

00:37:51,350 --> 00:37:57,020
less than three I'm going to do a simple

00:37:54,740 --> 00:38:00,550
routine which is sort for zero and first

00:37:57,020 --> 00:38:00,550
size equals to what the heck is that

00:38:01,750 --> 00:38:07,520
who knows

00:38:03,790 --> 00:38:09,200
well if size is two is gonna be sort -

00:38:07,520 --> 00:38:10,910
you know so - element is like swap them

00:38:09,200 --> 00:38:13,220
if they're you know they're not order

00:38:10,910 --> 00:38:15,320
right so so tree is like a trivial but

00:38:13,220 --> 00:38:18,110
the thing is you sort to first of zero

00:38:15,320 --> 00:38:20,750
and first of one if size is too but if

00:38:18,110 --> 00:38:22,730
size is not two sides gonna be one so

00:38:20,750 --> 00:38:26,050
you're going to sort first of zero and

00:38:22,730 --> 00:38:29,420
first of zero which is a does nothing

00:38:26,050 --> 00:38:31,520
the key point here being that you

00:38:29,420 --> 00:38:33,560
integrate conditionals within your

00:38:31,520 --> 00:38:36,110
arithmetic maybes and German everybody

00:38:33,560 --> 00:38:39,890
else please understand this is crucial

00:38:36,110 --> 00:38:44,410
you don't want if you just want boolean

00:38:39,890 --> 00:38:46,460
swith in your calculations right and

00:38:44,410 --> 00:38:49,400
then we're gonna make hip and we're

00:38:46,460 --> 00:38:59,840
gonna do the on guard intuition so this

00:38:49,400 --> 00:39:02,060
is my stupid sword make hip I'm going to

00:38:59,840 --> 00:39:04,150
start with the first parent it turns out

00:39:02,060 --> 00:39:06,830
to be size minus 3 by 2

00:39:04,150 --> 00:39:08,420
he turns out many implementations they

00:39:06,830 --> 00:39:12,200
do size minus one by two in the wrong

00:39:08,420 --> 00:39:13,310
they they do more work and then I'm

00:39:12,200 --> 00:39:14,840
going to can be the first right kid

00:39:13,310 --> 00:39:16,040
which is like the you know the first

00:39:14,840 --> 00:39:17,960
right kid or the parent which is gonna

00:39:16,040 --> 00:39:19,700
be the first pair plus one times two so

00:39:17,960 --> 00:39:22,340
that's gonna be my simple calculation

00:39:19,700 --> 00:39:24,080
and just want to save that calculation

00:39:22,340 --> 00:39:26,660
doing over over again because then I'm

00:39:24,080 --> 00:39:28,640
going to simply decrement the parent and

00:39:26,660 --> 00:39:31,490
decrement the first right kid and that's

00:39:28,640 --> 00:39:37,220
my outer loop by the way this is an

00:39:31,490 --> 00:39:40,010
infinite loop as of 2019 I announce that

00:39:37,220 --> 00:39:45,800
I've always going to use infinite loops

00:39:40,010 --> 00:39:49,810
I give ivory ivory neg I give up finite

00:39:45,800 --> 00:39:53,540
structure loops they're for bad people

00:39:49,810 --> 00:39:56,210
I'm done with finite loops no more

00:39:53,540 --> 00:39:59,810
structure loops I'm gonna use infinite

00:39:56,210 --> 00:40:03,770
loops for all my work firm commitment

00:39:59,810 --> 00:40:08,040
except for like most loops but that's

00:40:03,770 --> 00:40:09,540
all right and then if the sizes are not

00:40:08,040 --> 00:40:11,010
numbered then nothing to do because it

00:40:09,540 --> 00:40:12,630
was one of those heaps with both

00:40:11,010 --> 00:40:16,680
children at the end but otherwise I have

00:40:12,630 --> 00:40:18,080
one more kid to push called pushy and

00:40:16,680 --> 00:40:21,090
we're done

00:40:18,080 --> 00:40:22,620
very nice outer loop so I'm putting this

00:40:21,090 --> 00:40:25,140
on different slides because this is just

00:40:22,620 --> 00:40:27,600
the code doesn't fit so I'll totally

00:40:25,140 --> 00:40:29,970
remember we had this first right kid and

00:40:27,600 --> 00:40:32,370
first parent and we have the element

00:40:29,970 --> 00:40:36,270
that must go down let's call it Lucifer

00:40:32,370 --> 00:40:39,120
because it goes down right naming the

00:40:36,270 --> 00:40:40,620
hardest prong in computer science so I'm

00:40:39,120 --> 00:40:44,720
going to compare with Lucifer and stuff

00:40:40,620 --> 00:40:44,720
and whatnot so this is my outer loop

00:40:48,890 --> 00:40:56,760
notice that this cannot be transferred

00:40:51,570 --> 00:40:59,160
into a structure loop it has this break

00:40:56,760 --> 00:41:01,140
just before the end of the loop but if

00:40:59,160 --> 00:41:03,030
you break here you're not gonna do these

00:41:01,140 --> 00:41:07,310
two operations in the turns out this is

00:41:03,030 --> 00:41:12,290
important that's why I don't I repudiate

00:41:07,310 --> 00:41:17,070
structure for loops okay

00:41:12,290 --> 00:41:23,240
the pit of hell the inner loop here we

00:41:17,070 --> 00:41:26,070
are in the core of Chernobyl and

00:41:23,240 --> 00:41:29,400
actually that's an apt metaphor because

00:41:26,070 --> 00:41:31,020
the density of current inside the CPU is

00:41:29,400 --> 00:41:33,330
the same as compared same order of

00:41:31,020 --> 00:41:35,850
magnitude as the density of current in a

00:41:33,330 --> 00:41:37,850
nuclear reactor and that's because the

00:41:35,850 --> 00:41:39,930
density is like division by the area

00:41:37,850 --> 00:41:41,990
through which the current is spent there

00:41:39,930 --> 00:41:45,810
is like division by zero is very small

00:41:41,990 --> 00:41:48,150
but the density is huge is humongous so

00:41:45,810 --> 00:41:50,730
this is the pit of hell every cycle

00:41:48,150 --> 00:41:55,260
every hat every percent of a cycle here

00:41:50,730 --> 00:41:59,520
matters and here's what we're gonna do

00:41:55,260 --> 00:42:03,450
which nobody does constant a junior

00:41:59,520 --> 00:42:07,620
equals right kid - comparison result no

00:42:03,450 --> 00:42:10,740
if so I compute a best she a child to

00:42:07,620 --> 00:42:13,320
use for my decisions I choose the chair

00:42:10,740 --> 00:42:16,349
by doing arithmetic not testing not

00:42:13,320 --> 00:42:17,789
decisions not jumps so I

00:42:16,349 --> 00:42:20,220
pick up the right kids either the right

00:42:17,789 --> 00:42:25,559
kid or right in -1 which turns out to be

00:42:20,220 --> 00:42:27,569
the left kid and then I you know I move

00:42:25,559 --> 00:42:30,239
on I ever eg start this particular I

00:42:27,569 --> 00:42:37,289
move from this a of junior to current

00:42:30,239 --> 00:42:39,150
and then I compare and break early and I

00:42:37,289 --> 00:42:48,119
do my operations to update parent and

00:42:39,150 --> 00:42:51,329
right kid and I have a go - what bring

00:42:48,119 --> 00:42:53,729
it yes thank you so I have a good I'm

00:42:51,329 --> 00:42:55,799
not ashamed it saves me one test if you

00:42:53,729 --> 00:43:01,950
can replace this with a structure loop

00:42:55,799 --> 00:43:03,359
I'll eat it thank you bianna for leaving

00:43:01,950 --> 00:43:09,180
go to in the language in spite of

00:43:03,359 --> 00:43:12,739
pressure this go-to is the most

00:43:09,180 --> 00:43:16,489
honorable thing I've done in my life ok

00:43:12,739 --> 00:43:16,489
so I stand by it

00:43:16,670 --> 00:43:21,930
so then I had the push sheep guess what

00:43:19,289 --> 00:43:24,479
push sheep is slow like pushy people

00:43:21,930 --> 00:43:26,309
either by the you know bike know and by

00:43:24,479 --> 00:43:28,319
clang and my vs is slow

00:43:26,309 --> 00:43:31,349
you know it's slow because they you

00:43:28,319 --> 00:43:35,759
structure loops because they use finite

00:43:31,349 --> 00:43:37,890
for and they do more work the problem

00:43:35,759 --> 00:43:40,019
here with push sheep is that how many

00:43:37,890 --> 00:43:41,940
times dieter in this loop here in a push

00:43:40,019 --> 00:43:45,089
sheep it's log and times it's a short

00:43:41,940 --> 00:43:46,019
it's a small amount of times it's like

00:43:45,089 --> 00:43:48,269
five times

00:43:46,019 --> 00:43:50,339
if you iterate a loop 1 million times

00:43:48,269 --> 00:43:52,799
then you do a bit of extra work at the

00:43:50,339 --> 00:43:54,779
million of time it's just fine but if

00:43:52,799 --> 00:43:56,130
you do if five or six or ten times and

00:43:54,779 --> 00:43:58,859
you do extra work at the end of the

00:43:56,130 --> 00:44:02,880
tenth time then you're losing 10 percent

00:43:58,859 --> 00:44:05,460
right so here this loop is very

00:44:02,880 --> 00:44:07,319
carefully written so that it breaks the

00:44:05,460 --> 00:44:08,880
hell out of the loop as soon as humanly

00:44:07,319 --> 00:44:11,249
possible so you look at the parent

00:44:08,880 --> 00:44:15,119
compute the parent and registers the AI

00:44:11,249 --> 00:44:17,489
and parent it breaks early here and

00:44:15,119 --> 00:44:19,920
again it breaks early here and everybody

00:44:17,489 --> 00:44:21,420
else in the STL implementation is going

00:44:19,920 --> 00:44:24,239
to do this extra work this actual

00:44:21,420 --> 00:44:26,880
assignment which is measurable because

00:44:24,239 --> 00:44:29,880
this is the pit of hell this is where

00:44:26,880 --> 00:44:30,750
the action grows this is going to be

00:44:29,880 --> 00:44:38,310
executed million

00:44:30,750 --> 00:44:41,400
millions of times so new rule always use

00:44:38,310 --> 00:44:45,560
infinite loops except of course for most

00:44:41,400 --> 00:44:47,910
cases but always am i clear

00:44:45,560 --> 00:44:51,870
always use infinite loops except most

00:44:47,910 --> 00:44:54,420
cases but always alright I don't make

00:44:51,870 --> 00:44:57,840
the rules don't shoot the messenger and

00:44:54,420 --> 00:45:00,350
just like saying what happens alright so

00:44:57,840 --> 00:45:00,350
don't forget this

00:45:00,650 --> 00:45:04,950
alright so let's make a bit of analysis

00:45:03,450 --> 00:45:06,570
here in the inner we have three

00:45:04,950 --> 00:45:09,210
comparisons but only two compression

00:45:06,570 --> 00:45:11,460
jumps so we're good and we have holy

00:45:09,210 --> 00:45:14,610
truth matrix and to a size so we're good

00:45:11,460 --> 00:45:18,540
so let's put this to the test and we're

00:45:14,610 --> 00:45:21,030
getting close we're getting close but

00:45:18,540 --> 00:45:27,540
not quite there we're within two percent

00:45:21,030 --> 00:45:29,430
but now remember we reduced swaps we

00:45:27,540 --> 00:45:31,650
reduced comparisons so we're in good

00:45:29,430 --> 00:45:33,390
shape we cannot increase threshold we

00:45:31,650 --> 00:45:34,980
can increase the small side that's the

00:45:33,390 --> 00:45:41,700
size of the smaller race that we're

00:45:34,980 --> 00:45:45,210
sorting and finally after millennia of

00:45:41,700 --> 00:45:49,200
work we got it if you set a Thresh of

00:45:45,210 --> 00:45:50,790
just 63 you enjoy a good win 2% here in

00:45:49,200 --> 00:45:52,710
these swaps you essentially it's good

00:45:50,790 --> 00:45:56,790
for everybody it's good for you know all

00:45:52,710 --> 00:45:58,200
metrics are better including time so

00:45:56,790 --> 00:46:00,030
elaborate eyes get only better because

00:45:58,200 --> 00:46:02,040
they're going to have you know more

00:46:00,030 --> 00:46:04,020
expensive comparisons and more expensive

00:46:02,040 --> 00:46:06,120
swaps so you know everything is going to

00:46:04,020 --> 00:46:08,900
do better than double so double is kind

00:46:06,120 --> 00:46:08,900
of the worst case in a way

00:46:16,329 --> 00:46:21,920
I'm gonna use this template for the rest

00:46:18,950 --> 00:46:24,319
of my slides because now we're gonna get

00:46:21,920 --> 00:46:30,160
into completely like weird territory

00:46:24,319 --> 00:46:33,499
here I was kidding it's just but

00:46:30,160 --> 00:46:35,059
consider this let's plot comparisons as

00:46:33,499 --> 00:46:36,950
a function of the threshold and of

00:46:35,059 --> 00:46:39,799
course comparisons are gonna grow with

00:46:36,950 --> 00:46:41,720
the threshold this is expected with the

00:46:39,799 --> 00:46:43,940
quadratic thing and I'm very happy to

00:46:41,720 --> 00:46:46,369
see that comparisons with the blue which

00:46:43,940 --> 00:46:48,799
is the insertion sort the hip insertion

00:46:46,369 --> 00:46:51,170
sort they're gonna grow slower so that's

00:46:48,799 --> 00:46:53,390
nice that's good but compress this

00:46:51,170 --> 00:46:55,130
increase with a threshold so it's get

00:46:53,390 --> 00:46:58,970
worse if you increase the Thresher

00:46:55,130 --> 00:47:01,180
that's fine same about swaps moves you

00:46:58,970 --> 00:47:03,710
know so the swap is kind of two moves

00:47:01,180 --> 00:47:05,269
several swaps we're doing better in move

00:47:03,710 --> 00:47:09,289
you know we're doing better with the

00:47:05,269 --> 00:47:10,910
blue plotter fewer a butter sauce gets

00:47:09,289 --> 00:47:14,329
is just growing right with the threshold

00:47:10,910 --> 00:47:22,960
it's kind of a problem and this is the

00:47:14,329 --> 00:47:27,739
weird thing time continues to drop with

00:47:22,960 --> 00:47:34,099
all the metrics are doing worse but the

00:47:27,739 --> 00:47:35,809
tank continues to go better I kid you

00:47:34,099 --> 00:47:37,489
not this is one of the weirdest moment

00:47:35,809 --> 00:47:39,559
in my career when I plotted this and I

00:47:37,489 --> 00:47:42,799
took a look and say what is happening

00:47:39,559 --> 00:47:45,650
here I'm doing I mean I'm pessimism

00:47:42,799 --> 00:47:48,589
things metrics are getting worse as

00:47:45,650 --> 00:47:51,650
expected but time is getting better so

00:47:48,589 --> 00:47:53,749
the sweet spot like turn a 55 so I have

00:47:51,650 --> 00:47:55,940
an array of 20 55 elements and I'm

00:47:53,749 --> 00:47:58,930
better off with a bunch of comparisons

00:47:55,940 --> 00:48:05,049
and bacio swaps it just works better so

00:47:58,930 --> 00:48:05,049
I find this like really weird and

00:48:05,230 --> 00:48:10,569
disquieting because it means every guy I

00:48:08,690 --> 00:48:13,940
learned from books is no longer valid

00:48:10,569 --> 00:48:15,589
there's no there's no there's no compass

00:48:13,940 --> 00:48:17,779
for the territory we're in right now

00:48:15,589 --> 00:48:19,130
there's no guidelines there's no like oh

00:48:17,779 --> 00:48:20,869
you know if you do this is gonna get

00:48:19,130 --> 00:48:24,279
better you know what to do

00:48:20,869 --> 00:48:26,569
you don't know what to do have no idea

00:48:24,279 --> 00:48:27,230
so trying theory silly things we

00:48:26,569 --> 00:48:28,640
increase

00:48:27,230 --> 00:48:30,590
shall we increase compressions we

00:48:28,640 --> 00:48:33,170
increase what but time continues to drop

00:48:30,590 --> 00:48:35,900
down and we got all the way down to 4%

00:48:33,170 --> 00:48:39,560
better over the base line which is a

00:48:35,900 --> 00:48:40,670
significant improvement by the way you

00:48:39,560 --> 00:48:43,430
shouldn't expect I'm gonna get like

00:48:40,670 --> 00:48:47,119
twice as fast as sort it's not a high

00:48:43,430 --> 00:48:48,560
margin business right it's a like

00:48:47,119 --> 00:48:50,510
there's a political limit you can't go

00:48:48,560 --> 00:48:52,190
under and we're kind of in that area so

00:48:50,510 --> 00:48:54,880
this is you can like say Oh improve like

00:48:52,190 --> 00:48:58,369
2x wow this is awesome

00:48:54,880 --> 00:49:00,890
so 4% is a good result if we can

00:48:58,369 --> 00:49:08,990
reproduce it across a number of data

00:49:00,890 --> 00:49:10,850
shades right but this kept on gnawing at

00:49:08,990 --> 00:49:12,859
me what the heck is going on how what

00:49:10,850 --> 00:49:15,890
matrix can I define and use to improve

00:49:12,859 --> 00:49:18,290
my sorting comparisons are not good

00:49:15,890 --> 00:49:22,270
swaps are not good so here's what I

00:49:18,290 --> 00:49:25,700
tried collect D of n the average

00:49:22,270 --> 00:49:29,000
distance between two subsequent array

00:49:25,700 --> 00:49:31,700
axises so you have the array that you

00:49:29,000 --> 00:49:33,530
want to sort and you read you write you

00:49:31,700 --> 00:49:36,740
read you write at different positions in

00:49:33,530 --> 00:49:41,320
the array and you collect the average

00:49:36,740 --> 00:49:46,609
distance between two successive accesses

00:49:41,320 --> 00:49:47,960
that's gonna give me an idea of what now

00:49:46,609 --> 00:49:49,430
you can say cash yes

00:49:47,960 --> 00:49:53,540
it's gonna give me an idea without

00:49:49,430 --> 00:49:56,050
actually having a cash specific metric

00:49:53,540 --> 00:49:59,030
it's gonna give me an a cache-oblivious

00:49:56,050 --> 00:50:01,190
manner of saying you know what your

00:49:59,030 --> 00:50:03,859
algorithm is not as good because it does

00:50:01,190 --> 00:50:08,119
kind of weird accesses at different ends

00:50:03,859 --> 00:50:10,040
of the array right so I looked at the

00:50:08,119 --> 00:50:11,750
distance and for quicksort the distance

00:50:10,040 --> 00:50:13,430
is very large because partition always

00:50:11,750 --> 00:50:15,140
start from the at the end the worst case

00:50:13,430 --> 00:50:16,670
it's gonna start from the you know

00:50:15,140 --> 00:50:17,000
opposite ends of the array is gonna go

00:50:16,670 --> 00:50:22,190
like that

00:50:17,000 --> 00:50:25,570
that's quicksort partition so that's a

00:50:22,190 --> 00:50:29,450
problem and let's take a look at D of n

00:50:25,570 --> 00:50:32,359
and indeed it does go down with a

00:50:29,450 --> 00:50:35,090
threshold for both algorithms and it

00:50:32,359 --> 00:50:37,790
goes down or for actually no it goes

00:50:35,090 --> 00:50:39,710
down or for the plane algorithm so now

00:50:37,790 --> 00:50:40,610
your engineers what do we do now so we

00:50:39,710 --> 00:50:41,930
have to measure

00:50:40,610 --> 00:50:43,430
that are weird we have a third metric

00:50:41,930 --> 00:50:45,500
that's kind of there but also again

00:50:43,430 --> 00:50:50,120
doesn't tell the whole story so the

00:50:45,500 --> 00:50:54,800
solution is build a composite metric

00:50:50,120 --> 00:50:57,020
that encompasses all of the three so you

00:50:54,800 --> 00:51:01,580
have a blended cost of your computation

00:50:57,020 --> 00:51:06,400
which is C of M plus s of n M moves em

00:51:01,580 --> 00:51:08,960
open plus a constant times D of M and

00:51:06,400 --> 00:51:14,750
once you plot that you're gonna see that

00:51:08,960 --> 00:51:16,760
it follows the time so this is the right

00:51:14,750 --> 00:51:21,980
metric to use for improving sort

00:51:16,760 --> 00:51:24,340
algorithms throw away Cormac throwing

00:51:21,980 --> 00:51:28,040
News honor it shouldn't throw ignores

00:51:24,340 --> 00:51:31,820
but you know understand that this

00:51:28,040 --> 00:51:34,550
there's no notion of this in all of the

00:51:31,820 --> 00:51:36,890
algorithm books in we have there is

00:51:34,550 --> 00:51:39,290
however in recent research literature

00:51:36,890 --> 00:51:40,610
because research is just kind of ahead

00:51:39,290 --> 00:51:43,160
of everybody it's kind of there's a lot

00:51:40,610 --> 00:51:44,660
of research in fast algorithms and how

00:51:43,160 --> 00:51:46,790
to do how to do them how to implement

00:51:44,660 --> 00:51:50,440
them and you can find papers on this

00:51:46,790 --> 00:51:53,540
kind of stuff the books are obsolete

00:51:50,440 --> 00:51:55,580
kind of a weird spot the papers are kind

00:51:53,540 --> 00:51:57,230
of giving good information the industry

00:51:55,580 --> 00:52:02,330
is giving good information because you

00:51:57,230 --> 00:52:04,040
know they measure right and the books

00:52:02,330 --> 00:52:08,110
are kind of out of you know out of date

00:52:04,040 --> 00:52:11,420
so this is the right metric you blend

00:52:08,110 --> 00:52:14,120
compares and swaps and the average

00:52:11,420 --> 00:52:15,620
distance between two array axises that's

00:52:14,120 --> 00:52:23,420
going to give you a good proxy for a

00:52:15,620 --> 00:52:29,000
computation but wait a second not all

00:52:23,420 --> 00:52:33,230
data is random I hear you say well more

00:52:29,000 --> 00:52:35,150
data more measurements so I measured on

00:52:33,230 --> 00:52:39,290
the following this is a kind of a

00:52:35,150 --> 00:52:42,010
typical corpus sort the data 0 1 2 all

00:52:39,290 --> 00:52:44,870
the way to n minus 1 sorted data

00:52:42,010 --> 00:52:49,150
reversed and minus 1 all the way down to

00:52:44,870 --> 00:52:49,150
0 organ pipe

00:52:49,660 --> 00:52:54,250
right actually I'm wrong because

00:52:52,839 --> 00:52:55,569
allgemeine does it be like this because

00:52:54,250 --> 00:52:56,049
logarithmic right it goes like that and

00:52:55,569 --> 00:52:59,369
like that

00:52:56,049 --> 00:53:02,710
but organ pipe right goes up and down

00:52:59,369 --> 00:53:07,240
rotated instead of starting at zero I

00:53:02,710 --> 00:53:10,119
started one and I go to n minus one and

00:53:07,240 --> 00:53:13,049
then I put a zero at the end oh it's the

00:53:10,119 --> 00:53:17,200
result of Kali rotate begin plus one and

00:53:13,049 --> 00:53:22,690
begin begin plus one end right so rotate

00:53:17,200 --> 00:53:26,289
did occur in this talk thank you for the

00:53:22,690 --> 00:53:27,880
golf clap and last but not least we have

00:53:26,289 --> 00:53:29,710
like random there I did my best to

00:53:27,880 --> 00:53:33,519
create some random daredi here for your

00:53:29,710 --> 00:53:36,849
pleasure 0 1 0 0 1 0 1 1 this is random

00:53:33,519 --> 00:53:39,759
believe me so random 0 1 is essentially

00:53:36,849 --> 00:53:43,450
n by 2 zeroes and by N by 2 ones all

00:53:39,759 --> 00:53:46,539
scrambled this is going to test a lot of

00:53:43,450 --> 00:53:49,299
duplicates ins the sorted array a lot of

00:53:46,539 --> 00:53:50,920
duplicates but also high entropy which

00:53:49,299 --> 00:53:54,910
is difficult in difficult situation

00:53:50,920 --> 00:53:56,920
right the difficult case and the key

00:53:54,910 --> 00:53:58,900
detail here does is that you don't get

00:53:56,920 --> 00:54:00,880
to you don't get to choose threshold

00:53:58,900 --> 00:54:03,099
depending on these statistics because

00:54:00,880 --> 00:54:07,259
you don't know the money in advance so

00:54:03,099 --> 00:54:07,259
what we do is we optimize threshold for

00:54:07,559 --> 00:54:14,500
random data because that's sort of the

00:54:11,289 --> 00:54:16,869
that's the worst case right that's sort

00:54:14,500 --> 00:54:19,029
of the baseline you optimize threshold

00:54:16,869 --> 00:54:22,529
for random data and then we test it on

00:54:19,029 --> 00:54:22,529
these guys and see what happens I

00:54:23,670 --> 00:54:28,210
approach this measurement with huge

00:54:26,380 --> 00:54:31,599
trepidation because for example the

00:54:28,210 --> 00:54:35,140
sorted array is the happiest case for

00:54:31,599 --> 00:54:37,809
insertion sort this you do nothing so

00:54:35,140 --> 00:54:39,430
partitions gonna do nothing and then

00:54:37,809 --> 00:54:41,740
every insertion so it's gonna do nothing

00:54:39,430 --> 00:54:45,450
so there's gonna be 0 moves and it's

00:54:41,740 --> 00:54:48,150
just gonna be a bonanza of like speed

00:54:45,450 --> 00:54:53,710
that's why it's good to measure friends

00:54:48,150 --> 00:54:58,960
sorted data we destroy we destroy plane

00:54:53,710 --> 00:55:02,510
insertion 9 percent improvement by

00:54:58,960 --> 00:55:05,000
literally doing more work

00:55:02,510 --> 00:55:06,200
I had a hard time explaining this to

00:55:05,000 --> 00:55:09,800
myself because this is really

00:55:06,200 --> 00:55:12,410
paradoxical least like insertions the

00:55:09,800 --> 00:55:14,510
happiest case for everything and the key

00:55:12,410 --> 00:55:17,300
you know the keys the keys

00:55:14,510 --> 00:55:19,100
unguarded insertion because he'd one

00:55:17,300 --> 00:55:22,580
guarded and the other guy must do

00:55:19,100 --> 00:55:24,440
guarded they are at a disadvantage so

00:55:22,580 --> 00:55:26,630
the fact that you get to make heap which

00:55:24,440 --> 00:55:29,600
also is uh no op like no make make is

00:55:26,630 --> 00:55:32,780
gonna move no data the array sorted any

00:55:29,600 --> 00:55:35,330
sorted arrays a heap but the fact that

00:55:32,780 --> 00:55:36,740
you don't you know that a smallest

00:55:35,330 --> 00:55:38,720
element is already there so you don't

00:55:36,740 --> 00:55:40,910
need to to guard it's gonna save you one

00:55:38,720 --> 00:55:44,960
extra comparison per loop which turns

00:55:40,910 --> 00:55:47,930
out to be a win so we have doing more

00:55:44,960 --> 00:55:50,900
work on a sorted array gives you an

00:55:47,930 --> 00:55:53,960
improvement nine percent even more

00:55:50,900 --> 00:56:00,950
significant time for random data reverse

00:55:53,960 --> 00:56:03,770
data we D file plain assertion three

00:56:00,950 --> 00:56:10,490
point seven percent that would be the

00:56:03,770 --> 00:56:15,440
exact opposite I have bad news for

00:56:10,490 --> 00:56:21,080
Graham pipe though we lose four point

00:56:15,440 --> 00:56:22,940
six percent but here what I noticed is

00:56:21,080 --> 00:56:26,540
the following depending on the choice of

00:56:22,940 --> 00:56:29,990
threshold I saw C saw in the runtime of

00:56:26,540 --> 00:56:32,390
hippie insertion it's very good actually

00:56:29,990 --> 00:56:34,340
this is sort of my worst case the

00:56:32,390 --> 00:56:37,370
hipsters worst case because if you

00:56:34,340 --> 00:56:39,320
choose treasure like instead of 255 is

00:56:37,370 --> 00:56:41,450
like 200 you're gonna get a much better

00:56:39,320 --> 00:56:43,940
behavior on organ pipe and that's

00:56:41,450 --> 00:56:45,710
because I need to investigate so there's

00:56:43,940 --> 00:56:47,540
a seesaw behavior it's like very bad

00:56:45,710 --> 00:56:48,770
very good times very bad times very good

00:56:47,540 --> 00:56:50,750
times very bad times depending on

00:56:48,770 --> 00:56:52,970
threshold so there is some chaotic

00:56:50,750 --> 00:56:55,130
behavior there that needs to be analyzed

00:56:52,970 --> 00:56:56,570
needs to be looked at and the nice thing

00:56:55,130 --> 00:56:58,040
is you know you notice it and you kind

00:56:56,570 --> 00:56:59,840
of studied I didn't have time for this

00:56:58,040 --> 00:57:01,550
talk but definitely there's something to

00:56:59,840 --> 00:57:06,200
be done there on organ pipe is just a

00:57:01,550 --> 00:57:08,840
weird anomaly that's why it's so good to

00:57:06,200 --> 00:57:11,260
test on so many data sets right it's

00:57:08,840 --> 00:57:11,260
beautiful

00:57:12,560 --> 00:57:26,780
rotated Dana rotated data you know I

00:57:25,160 --> 00:57:30,260
knew rotate is gonna be in trouble

00:57:26,780 --> 00:57:32,600
I knew rotate them in trouble

00:57:30,260 --> 00:57:35,330
so again rotate is the smallest element

00:57:32,600 --> 00:57:38,540
is that at the end of the array it's

00:57:35,330 --> 00:57:40,130
actually uh it's a plausible shape of

00:57:38,540 --> 00:57:42,440
data because you may have a sorted array

00:57:40,130 --> 00:57:44,120
you have to you know push back some new

00:57:42,440 --> 00:57:45,230
element it turns out to be very small

00:57:44,120 --> 00:57:49,180
right

00:57:45,230 --> 00:57:53,060
he turns out rotated data hits a new

00:57:49,180 --> 00:57:54,830
partition in the worst way making tweaks

00:57:53,060 --> 00:57:56,420
or quadratic so all quicksort is

00:57:54,830 --> 00:58:00,400
irrelevant because he falls back to

00:57:56,420 --> 00:58:02,720
heapsort you can't measure it

00:58:00,400 --> 00:58:04,400
fortunately a visual studio folks don't

00:58:02,720 --> 00:58:07,010
fall for that trap I've been talking to

00:58:04,400 --> 00:58:08,360
them and Clank folks don't fall for that

00:58:07,010 --> 00:58:11,840
trap they have just a different

00:58:08,360 --> 00:58:15,920
different way of doing things so the

00:58:11,840 --> 00:58:21,470
result the new leap stood C++ team you

00:58:15,920 --> 00:58:23,150
got homework you can't afford this this

00:58:21,470 --> 00:58:25,250
is a bug in the library because the

00:58:23,150 --> 00:58:27,530
plausible data she's not a made-up weird

00:58:25,250 --> 00:58:32,270
data shape it's a plausible data shape

00:58:27,530 --> 00:58:34,610
that leads to worst case okay also I

00:58:32,270 --> 00:58:38,060
have a paper that also shows the worst

00:58:34,610 --> 00:58:42,620
case in new element which also becomes

00:58:38,060 --> 00:58:45,500
quadratic nobody took notice so if you

00:58:42,620 --> 00:58:48,170
know somebody say something all right

00:58:45,500 --> 00:58:52,220
tenth element is broken up no this is

00:58:48,170 --> 00:58:57,410
broken up no okay so with rotator

00:58:52,220 --> 00:59:02,810
current the jury's still out random

00:58:57,410 --> 00:59:06,110
zeros and ones we obliterate plane

00:59:02,810 --> 00:59:16,430
insertion obits 25% is like this huge

00:59:06,110 --> 00:59:18,380
margin I pre awesome so the short result

00:59:16,430 --> 00:59:20,750
would be HIPAA fine before insertion

00:59:18,380 --> 00:59:22,580
sort is going to be a significant win

00:59:20,750 --> 00:59:25,160
significant scientific sense you

00:59:22,580 --> 00:59:25,920
measured the significance significantly

00:59:25,160 --> 00:59:30,720
faster

00:59:25,920 --> 00:59:33,630
most tested distributions I want you to

00:59:30,720 --> 00:59:34,650
take a second to figure like the the

00:59:33,630 --> 00:59:38,490
paradox here

00:59:34,650 --> 00:59:41,609
it's a weird gambit it's doing more work

00:59:38,490 --> 00:59:44,339
it is unstructured because it doesn't

00:59:41,609 --> 00:59:45,720
you know it's not a smart method I think

00:59:44,339 --> 00:59:47,040
it would be much smarter to make the

00:59:45,720 --> 00:59:49,260
heap and then sort the heap kind of

00:59:47,040 --> 00:59:51,000
cleverly allow smooth sort smoothes or

00:59:49,260 --> 00:59:53,369
does kind of that kind of thing but it's

00:59:51,000 --> 00:59:56,190
very complicated this is the problem ooh

00:59:53,369 --> 00:59:57,660
so nobody can implement it so and I

00:59:56,190 --> 00:59:59,160
think nobody can implant it real fast

00:59:57,660 --> 01:00:02,339
because there's so many you know so many

00:59:59,160 --> 01:00:04,859
details to it so so many weird corners

01:00:02,339 --> 01:00:06,990
of it but if you just do this silly

01:00:04,859 --> 01:00:08,849
stupid thing you just make it before the

01:00:06,990 --> 01:00:11,309
array with a good make hip with a good

01:00:08,849 --> 01:00:14,609
push heap pill please fix your library

01:00:11,309 --> 01:00:16,920
STL implementors then you're gonna be

01:00:14,609 --> 01:00:20,309
better in sorting by the way I got you

01:00:16,920 --> 01:00:21,930
know I got a qualify here I kind of

01:00:20,309 --> 01:00:24,410
criticized that I still implement us

01:00:21,930 --> 01:00:27,150
because make heap is not fast enough but

01:00:24,410 --> 01:00:29,359
they have like a whole a standard

01:00:27,150 --> 01:00:32,130
library to implement and maintain and

01:00:29,359 --> 01:00:34,369
make keep - do you call me keeping an

01:00:32,130 --> 01:00:38,339
applicator make keep in one application

01:00:34,369 --> 01:00:41,160
like once I make hip and I mess with it

01:00:38,339 --> 01:00:43,349
right and here I come with this use case

01:00:41,160 --> 01:00:47,430
oh I need may keep a hundred thousand

01:00:43,349 --> 01:00:49,290
times nobody's gonna like what was the

01:00:47,430 --> 01:00:54,950
use case here well there is a use case

01:00:49,290 --> 01:00:54,950
now right so you gotta make it fast I

01:00:56,059 --> 01:01:02,579
wanted to share a few thoughts about

01:01:00,780 --> 01:01:04,290
this all with you because it looks like

01:01:02,579 --> 01:01:08,599
what do we make of all this this is kind

01:01:04,290 --> 01:01:11,400
of a bizarre situation to be in and

01:01:08,599 --> 01:01:13,680
there's this very nice notion in in

01:01:11,400 --> 01:01:16,049
philosophy which is first order thinking

01:01:13,680 --> 01:01:17,609
and second order thinking and first

01:01:16,049 --> 01:01:20,099
stories like the immediate conclusions

01:01:17,609 --> 01:01:23,339
the immediate the obvious consequences

01:01:20,099 --> 01:01:25,470
of certain thoughts and situations and

01:01:23,339 --> 01:01:27,150
realities that would be first order

01:01:25,470 --> 01:01:30,569
thinking I'm hungry and Anita cooking

01:01:27,150 --> 01:01:32,369
right but this was the second order

01:01:30,569 --> 01:01:35,640
thinking which is like what we are good

01:01:32,369 --> 01:01:37,859
at like you know advanced primates right

01:01:35,640 --> 01:01:39,150
and second I think is you know if I eat

01:01:37,859 --> 01:01:41,180
too many cookies maybe I'm gonna get

01:01:39,150 --> 01:01:43,830
diabetes

01:01:41,180 --> 01:01:45,810
so that would be kind of looking at the

01:01:43,830 --> 01:01:48,210
profound consequences of facts and

01:01:45,810 --> 01:01:49,980
situations that would be second and

01:01:48,210 --> 01:01:52,560
third and thinking kind of thinking

01:01:49,980 --> 01:01:55,200
through the immediate because there's a

01:01:52,560 --> 01:01:57,540
lot of immediate conclusions I could

01:01:55,200 --> 01:01:59,250
draw here like throughout the structures

01:01:57,540 --> 01:02:01,170
in algorithms books away look at

01:01:59,250 --> 01:02:03,630
research papers and measure that's what

01:02:01,170 --> 01:02:05,280
we can do so you know the interesting

01:02:03,630 --> 01:02:07,640
the research is what's happening and the

01:02:05,280 --> 01:02:10,620
books are kind of really out of date

01:02:07,640 --> 01:02:12,420
device your proper performance metrics

01:02:10,620 --> 01:02:16,590
and proxies and measure everything like

01:02:12,420 --> 01:02:19,440
a maniac and most of all try silly

01:02:16,590 --> 01:02:21,810
things because silly things are our

01:02:19,440 --> 01:02:28,470
ultimate line of defense in front of an

01:02:21,810 --> 01:02:30,570
Amber big complex machine right try

01:02:28,470 --> 01:02:32,580
silly things these are the first-order

01:02:30,570 --> 01:02:34,860
conclusions these are the immediate like

01:02:32,580 --> 01:02:35,730
if I can conclude my talk with this

01:02:34,860 --> 01:02:38,670
they'll be fine

01:02:35,730 --> 01:02:42,240
dislike these are the things that I can

01:02:38,670 --> 01:02:45,510
say as a as a closure to the or deal

01:02:42,240 --> 01:02:47,610
with B through right but there is

01:02:45,510 --> 01:02:50,970
actually a bit of second-order

01:02:47,610 --> 01:02:52,130
conclusion oh by the way sorry so I got

01:02:50,970 --> 01:02:54,420
ahead of myself

01:02:52,130 --> 01:02:56,340
first-order conclusion like overall

01:02:54,420 --> 01:02:59,070
please remember this after a keynote is

01:02:56,340 --> 01:03:02,820
gone code that wants to be fast is

01:02:59,070 --> 01:03:08,040
left-leaning if you want to write fast

01:03:02,820 --> 01:03:09,750
code you gotta be a coming and I

01:03:08,040 --> 01:03:13,260
understand the irony that you're here in

01:03:09,750 --> 01:03:15,910
this in an Eastern European accent

01:03:13,260 --> 01:03:17,830
if you want if you have fast code you

01:03:15,910 --> 01:03:19,680
gotta be with the Communists that's how

01:03:17,830 --> 01:03:23,410
it goes I don't make the rules

01:03:19,680 --> 01:03:25,150
what do I mean by this repeatedly in my

01:03:23,410 --> 01:03:27,670
experience including in this very code

01:03:25,150 --> 01:03:30,340
that I showed you today in my expense

01:03:27,670 --> 01:03:32,830
repeatedly it cans that code that wants

01:03:30,340 --> 01:03:36,310
to be fast his left goes to the left of

01:03:32,830 --> 01:03:39,190
the page goes to the left of the page

01:03:36,310 --> 01:03:43,810
friends you see what I'm saying

01:03:39,190 --> 01:03:45,760
fill it so if you like a loop enough if

01:03:43,810 --> 01:03:49,240
and a foreignness and a switch it kind

01:03:45,760 --> 01:03:50,890
of weird enough not gonna be fast no by

01:03:49,240 --> 01:03:55,510
the way the Linux kernel you know the

01:03:50,890 --> 01:03:57,869
coding standard is 8 characters tab 80

01:03:55,510 --> 01:04:01,660
characters line width

01:03:57,869 --> 01:04:03,580
you can't write bad code on Linux in the

01:04:01,660 --> 01:04:06,520
Linux kernel it just can't you can't

01:04:03,580 --> 01:04:08,440
right it'll slow code there and I think

01:04:06,520 --> 01:04:10,810
it has to do with you know complexity

01:04:08,440 --> 01:04:12,550
and also like speed if you can like the

01:04:10,810 --> 01:04:14,380
moment we have like too many ifs and

01:04:12,550 --> 01:04:16,960
decision points about all that nonsense

01:04:14,380 --> 01:04:19,090
in your code your kind of efficiencies

01:04:16,960 --> 01:04:20,560
out the window and especially because

01:04:19,090 --> 01:04:21,940
there's many consequences to this

01:04:20,560 --> 01:04:24,850
especially because you're gonna

01:04:21,940 --> 01:04:27,100
inevitably end up mixing hot and cold

01:04:24,850 --> 01:04:28,510
code which is a anti-pattern

01:04:27,100 --> 01:04:30,609
inefficiency you don't want to do that

01:04:28,510 --> 01:04:32,950
you want to have hot culture get hot

01:04:30,609 --> 01:04:35,500
code together call code together that's

01:04:32,950 --> 01:04:37,810
why in all my routines if you saw I kind

01:04:35,500 --> 01:04:38,619
of whenever I have a chance I get the

01:04:37,810 --> 01:04:42,340
hell out of there

01:04:38,619 --> 01:04:44,080
I break I return I get out and then I go

01:04:42,340 --> 01:04:47,609
to the fix up which is gonna find this

01:04:44,080 --> 01:04:51,340
is called code I don't care that much

01:04:47,609 --> 01:04:53,380
right so code that wants to be fast is

01:04:51,340 --> 01:04:56,170
left-leaning does not mix hot and cold

01:04:53,380 --> 01:04:59,050
operations does not make many decisions

01:04:56,170 --> 01:05:01,180
if an ass is the anathema fast computing

01:04:59,050 --> 01:05:04,900
just integrated as your normal

01:05:01,180 --> 01:05:06,880
arithmetic okay and that's that's how I

01:05:04,900 --> 01:05:08,290
write fast code but I was saying I was

01:05:06,880 --> 01:05:10,420
getting ahead of myself there's a few

01:05:08,290 --> 01:05:15,700
second-order conclusions to this friends

01:05:10,420 --> 01:05:18,190
and you're not gonna like them what is

01:05:15,700 --> 01:05:20,859
the perfect sort for the C++ programming

01:05:18,190 --> 01:05:25,440
language imagine I know you know ass is

01:05:20,859 --> 01:05:27,690
like white it's a clean slate you

01:05:25,440 --> 01:05:30,839
to do everything you want any anyway you

01:05:27,690 --> 01:05:33,450
want well I can only assume that we're

01:05:30,839 --> 01:05:36,359
gonna have something like use hard coded

01:05:33,450 --> 01:05:38,760
version for very small sizes up to five

01:05:36,359 --> 01:05:41,510
I'm just coding the routines and

01:05:38,760 --> 01:05:44,520
actually clang does some of that and

01:05:41,510 --> 01:05:46,700
Visual Studio does also some of them so

01:05:44,520 --> 01:05:49,890
you some hard coded like really quick

01:05:46,700 --> 01:05:51,750
inline code for the small cases and that

01:05:49,890 --> 01:05:53,400
may be for small integers and default

01:05:51,750 --> 01:05:55,530
ordering let's use radix sort which is

01:05:53,400 --> 01:05:57,210
very fast and very nice but it's only

01:05:55,530 --> 01:06:01,140
gonna work with small integers and the

01:05:57,210 --> 01:06:05,369
default less or greater right certain

01:06:01,140 --> 01:06:07,319
pretty cuts and then maybe I'm gonna use

01:06:05,369 --> 01:06:09,119
this algorithm with quicksort and

01:06:07,319 --> 01:06:11,010
threshold and small certain whatever but

01:06:09,119 --> 01:06:13,349
the point is how do you choose the

01:06:11,010 --> 01:06:14,369
threshold because remember from the

01:06:13,349 --> 01:06:20,369
beginning of my talk

01:06:14,369 --> 01:06:23,520
visual studio it was thank you 32 G blue

01:06:20,369 --> 01:06:26,280
was 16 he shouldn't say that not the

01:06:23,520 --> 01:06:28,770
same person should say the same thing 16

01:06:26,280 --> 01:06:33,089
and clang was same person

01:06:28,770 --> 01:06:35,099
which was what no it wasn't 30 it was 30

01:06:33,089 --> 01:06:38,400
or 6 depending on type characteristics

01:06:35,099 --> 01:06:40,380
and this is where it all gets crazy

01:06:38,400 --> 01:06:43,200
friends this is where it gets like

01:06:40,380 --> 01:06:44,940
interesting you choose threshold

01:06:43,200 --> 01:06:47,520
actually choose threshold depending on

01:06:44,940 --> 01:06:51,599
many things depending on how much it

01:06:47,520 --> 01:06:54,660
costs to move things around whoa how do

01:06:51,599 --> 01:06:56,640
I even measure that well if it has

01:06:54,660 --> 01:07:01,980
trivial move the cost of moving is

01:06:56,640 --> 01:07:03,630
proportional to size of thank you so we

01:07:01,980 --> 01:07:07,140
already have a notion of oh if it's a

01:07:03,630 --> 01:07:08,670
trivial to move type I can make a

01:07:07,140 --> 01:07:10,260
calculation that's proportional to size

01:07:08,670 --> 01:07:14,510
off that's gonna be the cost of my move

01:07:10,260 --> 01:07:16,910
in let's say compute cost units right

01:07:14,510 --> 01:07:20,130
cost of comparison ah

01:07:16,910 --> 01:07:22,589
that's I told you you can do anything

01:07:20,130 --> 01:07:27,050
you want but this is difficult how do

01:07:22,589 --> 01:07:30,810
you estimate the cost of a lambda what

01:07:27,050 --> 01:07:33,630
yes what's sodium arrival and I'm gonna

01:07:30,810 --> 01:07:35,310
sort these strings by length and you

01:07:33,630 --> 01:07:37,349
know how do you tell the how do I tell

01:07:35,310 --> 01:07:40,190
the sort routine that your length

01:07:37,349 --> 01:07:42,990
comparison is actually one side

01:07:40,190 --> 01:07:45,300
how do you convey that information from

01:07:42,990 --> 01:07:47,670
one end to the other of the algorithm

01:07:45,300 --> 01:07:51,270
and this friends I think is an

01:07:47,670 --> 01:07:52,770
interesting problem and I dislike all of

01:07:51,270 --> 01:07:54,510
you know all through working on this

01:07:52,770 --> 01:07:56,609
album singing I'm working on doubles but

01:07:54,510 --> 01:07:58,650
I want to make this generic I want this

01:07:56,609 --> 01:08:00,750
to make for many types it was clear to

01:07:58,650 --> 01:08:03,510
me the threshold must be chosen

01:08:00,750 --> 01:08:07,290
depending on some weird minutiae

01:08:03,510 --> 01:08:08,820
depending on the type so we have the

01:08:07,290 --> 01:08:10,650
cost of compress and we have the size of

01:08:08,820 --> 01:08:12,630
em we have how about the data contiguity

01:08:10,650 --> 01:08:14,760
because if I sort of vector is one thing

01:08:12,630 --> 01:08:16,080
but if I sort a deck that's a different

01:08:14,760 --> 01:08:18,810
thing because all that distance between

01:08:16,080 --> 01:08:22,140
axis is gonna be different it's gonna

01:08:18,810 --> 01:08:24,890
have a different impact and I'm going to

01:08:22,140 --> 01:08:27,509
customize the algorithm everywhere

01:08:24,890 --> 01:08:30,509
depending on whether I have trivial move

01:08:27,509 --> 01:08:32,219
and copy because if you saw at the elbow

01:08:30,509 --> 01:08:34,140
if you look at the algorithms I'm gonna

01:08:32,219 --> 01:08:35,609
register some elements of the array save

01:08:34,140 --> 01:08:36,960
them as temporary it's messed with them

01:08:35,609 --> 01:08:39,000
then set them back and that kind of

01:08:36,960 --> 01:08:41,100
stuff you don't want to do that if the

01:08:39,000 --> 01:08:43,560
element is expensive to copy so

01:08:41,100 --> 01:08:47,580
depending on the cost of copying things

01:08:43,560 --> 01:08:49,529
around careful here depending on the

01:08:47,580 --> 01:08:51,299
cost of copying things around my

01:08:49,529 --> 01:08:53,819
implementation is going to have very

01:08:51,299 --> 01:08:55,589
many minor differences with regard to

01:08:53,819 --> 01:08:57,299
and registering creating temporaries say

01:08:55,589 --> 01:08:59,160
you know you know I have this temporary

01:08:57,299 --> 01:09:00,830
here if it's cheap otherwise I don't use

01:08:59,160 --> 01:09:05,819
temporaries because it's expensive right

01:09:00,830 --> 01:09:08,160
and all of these all of these decision

01:09:05,819 --> 01:09:10,350
points for the best sort algorithm are

01:09:08,160 --> 01:09:18,140
in tension with the tenets of generic

01:09:10,350 --> 01:09:20,460
programming they just run against it

01:09:18,140 --> 01:09:22,410
this is not generic program this is like

01:09:20,460 --> 01:09:25,620
customized everything depending on types

01:09:22,410 --> 01:09:28,880
programming it's not generic programming

01:09:25,620 --> 01:09:35,009
France dear colleagues this is not it

01:09:28,880 --> 01:09:38,000
what is it if it's not how do you encode

01:09:35,009 --> 01:09:41,660
the cost of operations for example what

01:09:38,000 --> 01:09:41,660
mechanism do we have for that

01:09:44,350 --> 01:09:50,390
how about user-defined attributes you

01:09:47,780 --> 01:09:53,390
can devise a simple library in which you

01:09:50,390 --> 01:09:54,950
assign constants to primitive operations

01:09:53,390 --> 01:09:57,680
like compared to integers or whatever

01:09:54,950 --> 01:09:59,450
and swap to integers and doubles and

01:09:57,680 --> 01:10:01,220
primitive types so you have your

01:09:59,450 --> 01:10:03,350
baseline you have your baseline cost in

01:10:01,220 --> 01:10:04,100
terms of elementary operations and then

01:10:03,350 --> 01:10:06,170
you have fixed

01:10:04,100 --> 01:10:09,200
attributes to functions that are going

01:10:06,170 --> 01:10:13,490
to estimate and propagate those costs of

01:10:09,200 --> 01:10:15,740
computation so then you have information

01:10:13,490 --> 01:10:18,950
with your lambda or with your function

01:10:15,740 --> 01:10:22,100
as to how much it should cost in terms

01:10:18,950 --> 01:10:24,260
of multiples of elementary operations

01:10:22,100 --> 01:10:28,970
I wrote such a library for a different

01:10:24,260 --> 01:10:31,070
language so you have a very nice

01:10:28,970 --> 01:10:33,740
mechanism in terms of user defined

01:10:31,070 --> 01:10:36,080
attributes and calculate an algebra of

01:10:33,740 --> 01:10:38,240
user-defined attributes you can devise

01:10:36,080 --> 01:10:42,140
not difficult that's going to allow you

01:10:38,240 --> 01:10:44,840
to convey propagate and inspect the

01:10:42,140 --> 01:10:47,060
estimated cost of doing operations so

01:10:44,840 --> 01:10:49,040
then you can in al and I can say to the

01:10:47,060 --> 01:10:51,860
soul routine my string comparison you

01:10:49,040 --> 01:10:57,680
know my land up cost like one elementary

01:10:51,860 --> 01:10:59,210
operation so I'm looking at in of course

01:10:57,680 --> 01:11:01,940
the key here is that you get the

01:10:59,210 --> 01:11:04,100
introspection going because

01:11:01,940 --> 01:11:06,350
introspection is the way to communicate

01:11:04,100 --> 01:11:09,080
from the land a predicate into the sort

01:11:06,350 --> 01:11:10,790
routine things and in this case the

01:11:09,080 --> 01:11:13,040
sorting is going to introspect the land

01:11:10,790 --> 01:11:16,790
of the the predicate is guys do you have

01:11:13,040 --> 01:11:19,490
this attribute complexity or cost do you

01:11:16,790 --> 01:11:21,140
have this attribute ball cost yes I do

01:11:19,490 --> 01:11:22,730
have it what is the cost well it's five

01:11:21,140 --> 01:11:24,650
times the compressor of three integers

01:11:22,730 --> 01:11:30,440
oh cool then I'm gonna choose threshold

01:11:24,650 --> 01:11:34,070
42 42 right 42 so whatever there's no

01:11:30,440 --> 01:11:37,910
concept for that casis just just hit the

01:11:34,070 --> 01:11:39,620
wrong barn door there's no concept for a

01:11:37,910 --> 01:11:45,620
pipe that's gonna lead to a threshold of

01:11:39,620 --> 01:11:47,660
42 it's just a simple introspection and

01:11:45,620 --> 01:11:48,980
you look at the type see what he can do

01:11:47,660 --> 01:11:52,040
and whatever right

01:11:48,980 --> 01:11:54,290
if the introspection finds no user

01:11:52,040 --> 01:11:56,030
defined at you before the cost is going

01:11:54,290 --> 01:11:57,740
to use a simple heuristic to say well

01:11:56,030 --> 01:12:01,190
then I assume the generic

01:11:57,740 --> 01:12:02,840
you know generally cost model right but

01:12:01,190 --> 01:12:07,280
the thing is you have the possibility to

01:12:02,840 --> 01:12:08,960
dissolve so there's a tension because in

01:12:07,280 --> 01:12:12,100
general programming we look at this

01:12:08,960 --> 01:12:14,600
strategic approach we define a few broad

01:12:12,100 --> 01:12:16,640
categories like you have input iterators

01:12:14,600 --> 01:12:19,970
and forward iterators and all that

01:12:16,640 --> 01:12:21,680
nonsense okay and we devise algorithms

01:12:19,970 --> 01:12:24,860
and we specialize and all the good

01:12:21,680 --> 01:12:27,140
things but actually there's this whole

01:12:24,860 --> 01:12:30,290
thing which in which I don't look at all

01:12:27,140 --> 01:12:32,390
that it's I do all I do is introspection

01:12:30,290 --> 01:12:34,220
I look at the type what you can do what

01:12:32,390 --> 01:12:35,720
you know how much it costs what you do

01:12:34,220 --> 01:12:37,880
and you know these kind of things these

01:12:35,720 --> 01:12:41,260
are you trivial to move I easy to copy

01:12:37,880 --> 01:12:44,960
and depending on that i optimize I

01:12:41,260 --> 01:12:48,740
change the design details of my

01:12:44,960 --> 01:12:50,570
algorithms in millions of ways so each

01:12:48,740 --> 01:12:51,890
sort routine for each care of types is

01:12:50,570 --> 01:12:57,640
going to be customized for that

01:12:51,890 --> 01:13:00,560
particular type in unexpected ways and

01:12:57,640 --> 01:13:03,620
I've done this I've done this for years

01:13:00,560 --> 01:13:05,540
and it turns out it's unprecedented what

01:13:03,620 --> 01:13:08,680
you get is like very small algorithms

01:13:05,540 --> 01:13:11,540
that work very well for very many types

01:13:08,680 --> 01:13:13,160
that's what you can get this is the this

01:13:11,540 --> 01:13:18,260
is the shiny city on the hill that you

01:13:13,160 --> 01:13:20,900
can get with introspection I've given

01:13:18,260 --> 01:13:25,010
this talk in Germany in November last

01:13:20,900 --> 01:13:29,350
year it was about the next big thing in

01:13:25,010 --> 01:13:31,580
C++ what's the next big thing in in C++

01:13:29,350 --> 01:13:36,980
introspection this is what opens the

01:13:31,580 --> 01:13:38,480
this is the key to the gate of hell this

01:13:36,980 --> 01:13:40,550
is the key to the kingdom this is what

01:13:38,480 --> 01:13:45,110
she was going to enable us to do many

01:13:40,550 --> 01:13:47,030
new wonderful amazing things as opposed

01:13:45,110 --> 01:13:49,100
to other things that they don't they may

01:13:47,030 --> 01:13:50,930
be disabled as from doing bad things but

01:13:49,100 --> 01:13:53,960
I don't want to not do bad things I want

01:13:50,930 --> 01:13:55,180
to do good things you want to do good

01:13:53,960 --> 01:13:59,230
things

01:13:55,180 --> 01:13:59,230
welcome to my last public talk

01:14:00,590 --> 01:14:04,970
generally programming is why we can't

01:14:02,790 --> 01:14:10,740
have nice things

01:14:04,970 --> 01:14:12,870
I'm here laughter okay like the two

01:14:10,740 --> 01:14:14,700
first two first roles applaud everybody

01:14:12,870 --> 01:14:17,060
this is like frozen it's like oh my

01:14:14,700 --> 01:14:17,060
goodness

01:14:17,570 --> 01:14:22,710
please listen to me

01:14:19,640 --> 01:14:23,160
I'm exaggerating of course but consider

01:14:22,710 --> 01:14:26,070
this

01:14:23,160 --> 01:14:28,680
I've tried to implement these algorithms

01:14:26,070 --> 01:14:30,410
for just you know plenty of like

01:14:28,680 --> 01:14:33,750
everything and they still and a lot more

01:14:30,410 --> 01:14:37,560
with a mindset that generic programming

01:14:33,750 --> 01:14:39,270
and I failed and once I realized it's

01:14:37,560 --> 01:14:41,340
not the way the right way to look at

01:14:39,270 --> 01:14:44,610
things the right way to look at things

01:14:41,340 --> 01:14:46,920
is to introspect every type customized

01:14:44,610 --> 01:14:49,250
infinitely your algorithms depending on

01:14:46,920 --> 01:14:51,750
the my need characteristics of the type

01:14:49,250 --> 01:14:54,000
do you this does this range no its

01:14:51,750 --> 01:14:55,680
length in advance in all of one because

01:14:54,000 --> 01:14:57,330
if it does you're gonna call the

01:14:55,680 --> 01:15:01,050
completely different algorithm than if

01:14:57,330 --> 01:15:02,280
it doesn't that kind of stuff and what

01:15:01,050 --> 01:15:04,230
we have with Jennifer is like with

01:15:02,280 --> 01:15:05,550
distance we are like two specialization

01:15:04,230 --> 01:15:08,340
of distance and thank you very much

01:15:05,550 --> 01:15:10,020
that's not enough so I'm not saying this

01:15:08,340 --> 01:15:12,480
is an exaggeration of course I'm not

01:15:10,020 --> 01:15:19,800
saying GP is bad I'm not saying Jerry

01:15:12,480 --> 01:15:22,740
Brown is bad but it's not enough so

01:15:19,800 --> 01:15:25,790
remember the 90s was all the craze he

01:15:22,740 --> 01:15:29,730
hurt us in virtual functions be awesome

01:15:25,790 --> 01:15:32,670
and then a 2000 came and joint program

01:15:29,730 --> 01:15:37,020
came in C++ never was like yeah 30

01:15:32,670 --> 01:15:39,440
second grade we was awesome what's

01:15:37,020 --> 01:15:39,440
coming next

01:15:40,220 --> 01:15:46,740
designed by introspection is coming next

01:15:44,330 --> 01:16:01,220
inspect and customize everything

01:15:46,740 --> 01:16:01,220
everywhere we my friends

01:16:01,440 --> 01:16:06,860
I understand I pushed a few buttons I

01:16:04,190 --> 01:16:11,340
fully realized I pushed a few buttons

01:16:06,860 --> 01:16:13,500
but this is in a good spirit right

01:16:11,340 --> 01:16:17,130
because if well if you if you all set

01:16:13,500 --> 01:16:20,040
here right now and compliment each other

01:16:17,130 --> 01:16:20,520
how great rotate is there will be no

01:16:20,040 --> 01:16:23,730
progress

01:16:20,520 --> 01:16:24,750
yeah rotate is great enough about it and

01:16:23,730 --> 01:16:26,070
done with rotate

01:16:24,750 --> 01:16:29,400
I'm never gonna is rotate my life

01:16:26,070 --> 01:16:31,430
anymore okay and infinite loops those

01:16:29,400 --> 01:16:33,810
anger you know that kind of stuff so

01:16:31,430 --> 01:16:36,150
progress comes when you kind of realize

01:16:33,810 --> 01:16:38,400
what we have in the mindset we have is

01:16:36,150 --> 01:16:40,590
not enough for what we want to do what

01:16:38,400 --> 01:16:42,000
we want to achieve is the best sort we

01:16:40,590 --> 01:16:45,750
can't achieve the best sword with

01:16:42,000 --> 01:16:48,330
generic programming and even if I pushed

01:16:45,750 --> 01:16:49,980
a few buttons you should know that like

01:16:48,330 --> 01:16:52,980
this is like one of the best moments of

01:16:49,980 --> 01:16:55,440
my life is like an amazing crowd and

01:16:52,980 --> 01:16:57,650
amazing community and it's very good to

01:16:55,440 --> 01:16:59,470
be here so from the bottom of my heart

01:16:57,650 --> 01:17:12,379
thank you very much

01:16:59,470 --> 01:17:12,379
[Applause]

01:17:16,270 --> 01:17:25,020
we can take a few questions at the

01:17:18,550 --> 01:17:26,800
microphones we have a few minutes ladies

01:17:25,020 --> 01:17:30,010
thank you for the talk

01:17:26,800 --> 01:17:31,840
first second regarding the replacing

01:17:30,010 --> 01:17:34,750
gift statement with arithmetic

01:17:31,840 --> 01:17:37,239
after watching couple of them at stock I

01:17:34,750 --> 01:17:39,460
come to think that a compiler the

01:17:37,239 --> 01:17:44,260
compiler can do a really good job at it

01:17:39,460 --> 01:17:46,330
so yes yeah the compiler is very good at

01:17:44,260 --> 01:17:46,600
finding these opportunities but not good

01:17:46,330 --> 01:17:49,120
enough

01:17:46,600 --> 01:17:52,060
you're better so I noticed like for

01:17:49,120 --> 01:17:53,890
example in for comparing jones the

01:17:52,060 --> 01:17:56,590
compiler replaces one I replace the rest

01:17:53,890 --> 01:17:58,090
the other three so that's why global dot

01:17:56,590 --> 01:17:59,350
work is such a good resource because it

01:17:58,090 --> 01:18:01,840
tells you where you need to really work

01:17:59,350 --> 01:18:06,430
on it so the compares are not they're

01:18:01,840 --> 01:18:09,430
not even close not yet yeah yes please

01:18:06,430 --> 01:18:12,280
so thanks for the talk thank you I hope

01:18:09,430 --> 01:18:14,980
this is not obviously I'm just not

01:18:12,280 --> 01:18:17,790
seeing it but um you don't really need

01:18:14,980 --> 01:18:20,980
the heap structure right so why do you

01:18:17,790 --> 01:18:22,510
not just why do you do the push in the

01:18:20,980 --> 01:18:25,300
end why don't you just leave the element

01:18:22,510 --> 01:18:27,370
where it is like the last element X

01:18:25,300 --> 01:18:29,170
thank you very much for asking this is I

01:18:27,370 --> 01:18:30,940
wish somebody would ask that so why do

01:18:29,170 --> 01:18:32,950
you worry about that last element and

01:18:30,940 --> 01:18:34,540
keep on pushing it into the hip he turns

01:18:32,950 --> 01:18:36,310
out either three percent it makes a

01:18:34,540 --> 01:18:38,320
difference and you know why because it

01:18:36,310 --> 01:18:40,480
may so happen it was random data that

01:18:38,320 --> 01:18:42,340
that's the smallest element and there's

01:18:40,480 --> 01:18:44,230
a way push heap is gonna push it real

01:18:42,340 --> 01:18:46,330
fast but kind of inserting it is gonna

01:18:44,230 --> 01:18:48,370
be real slow so imbalance in turns out

01:18:46,330 --> 01:18:49,420
it's an advantageous thing to do but

01:18:48,370 --> 01:18:55,210
thanks for noticing

01:18:49,420 --> 01:18:59,320
thank you yes please in C++ we have been

01:18:55,210 --> 01:19:00,940
able F and now we have concepts do you

01:18:59,320 --> 01:19:03,820
consider that constraint based

01:19:00,940 --> 01:19:05,920
programming distinct from design by

01:19:03,820 --> 01:19:08,680
infra spectrum or do you consider that

01:19:05,920 --> 01:19:12,690
birds of a feather constrained based

01:19:08,680 --> 01:19:16,210
programming what what is that

01:19:12,690 --> 01:19:18,700
for instance you describe inspecting

01:19:16,210 --> 01:19:22,239
based on whether size was order one and

01:19:18,700 --> 01:19:25,480
leveraging that I can dispatch based on

01:19:22,239 --> 01:19:27,820
the presence of that with estin a is

01:19:25,480 --> 01:19:29,310
that along the lines of what you mean or

01:19:27,820 --> 01:19:34,050
do you think that that

01:19:29,310 --> 01:19:37,680
sufficient so let me restate the

01:19:34,050 --> 01:19:40,490
question so do you think that sort of

01:19:37,680 --> 01:19:43,020
static dispatch based programming and

01:19:40,490 --> 01:19:46,620
concepts are a good tool for what you

01:19:43,020 --> 01:19:49,290
want to do is that the right question so

01:19:46,620 --> 01:19:55,110
far I don't think that the right tool I

01:19:49,290 --> 01:19:59,700
think I think both are significantly

01:19:55,110 --> 01:20:01,440
difficult to use tools that are not

01:19:59,700 --> 01:20:03,480
going to be enable you to do the right

01:20:01,440 --> 01:20:05,640
the right things everywhere it's just

01:20:03,480 --> 01:20:07,200
gonna it's just so much the algorithms

01:20:05,640 --> 01:20:09,600
end up being generic but they're gonna

01:20:07,200 --> 01:20:11,460
be like huge it's very unpleasant to use

01:20:09,600 --> 01:20:14,580
these these tools and concepts with

01:20:11,460 --> 01:20:17,400
causes like you can't express as a

01:20:14,580 --> 01:20:20,550
concept you know cite the concept of all

01:20:17,400 --> 01:20:23,100
tied with size 16 oh yeah I have the

01:20:20,550 --> 01:20:24,720
castle all size 24 and so on there's no

01:20:23,100 --> 01:20:27,090
such thing with constants you know you

01:20:24,720 --> 01:20:29,010
just got a do introspection not defined

01:20:27,090 --> 01:20:33,180
concepts and just use what you got by

01:20:29,010 --> 01:20:34,500
looking at types yes yes please hi David

01:20:33,180 --> 01:20:36,240
Holman Sandia National Labs

01:20:34,500 --> 01:20:38,400
thank you for your mention of

01:20:36,240 --> 01:20:40,170
user-defined attributes I know that

01:20:38,400 --> 01:20:41,670
maybe these days you don't get as much

01:20:40,170 --> 01:20:44,310
time to follow the committee activities

01:20:41,670 --> 01:20:46,170
but we actually have essentially a

01:20:44,310 --> 01:20:48,360
proposal for a library level solution

01:20:46,170 --> 01:20:51,920
making its way through the committee

01:20:48,360 --> 01:20:54,810
right now P 1393 properties that

01:20:51,920 --> 01:20:57,530
essentially addresses this concern where

01:20:54,810 --> 01:21:00,150
you have user-defined extra semantic

01:20:57,530 --> 01:21:02,100
pieces of information that can be used

01:21:00,150 --> 01:21:03,540
for optimization like thresholds that

01:21:02,100 --> 01:21:05,970
can be attached at the top level and

01:21:03,540 --> 01:21:08,250
then use generic in generic code have

01:21:05,970 --> 01:21:10,230
you seen any of that Craig yeah I was

01:21:08,250 --> 01:21:12,120
yeah so that's what I was referring to

01:21:10,230 --> 01:21:15,300
sorry for not making that clear

01:21:12,120 --> 01:21:17,640
it's my take that attributes are like

01:21:15,300 --> 01:21:20,250
the essential tool for introspection

01:21:17,640 --> 01:21:21,720
based design okay that the essential

01:21:20,250 --> 01:21:24,240
tool because they allow you to carry

01:21:21,720 --> 01:21:28,200
information through statically across

01:21:24,240 --> 01:21:29,700
function called boundaries attributes

01:21:28,200 --> 01:21:32,040
without introspection is like a wedding

01:21:29,700 --> 01:21:33,540
without music right introspection

01:21:32,040 --> 01:21:35,340
without activities I don't know like

01:21:33,540 --> 01:21:37,980
another wedding with no music right so

01:21:35,340 --> 01:21:40,440
it's you want to have both thank you for

01:21:37,980 --> 01:21:42,440
for the announcement yes please John

01:21:40,440 --> 01:21:44,330
plays dramaturge

01:21:42,440 --> 01:21:46,100
there's a branch of complexity theory

01:21:44,330 --> 01:21:48,740
called parametric complexity theory

01:21:46,100 --> 01:21:53,810
called parametric complex my magic

01:21:48,740 --> 01:21:56,690
complexity is Downey I'll give you the

01:21:53,810 --> 01:21:59,120
names later they the idea is that you

01:21:56,690 --> 01:22:00,980
don't just worry about the size of the

01:21:59,120 --> 01:22:03,110
data set but also certain parameters

01:22:00,980 --> 01:22:05,480
describing the actual structure of the

01:22:03,110 --> 01:22:08,900
data and so a lot of problems which

01:22:05,480 --> 01:22:10,670
might in theory be very expensive turn

01:22:08,900 --> 01:22:12,710
out to be quite practical given the

01:22:10,670 --> 01:22:14,740
structure of the data my impression is

01:22:12,710 --> 01:22:17,600
that what you're proposing is parametric

01:22:14,740 --> 01:22:20,900
algorithm designed with and it's very

01:22:17,600 --> 01:22:23,780
much an analyzable with the parametric

01:22:20,900 --> 01:22:29,530
complexity basis thanks for dimension so

01:22:23,780 --> 01:22:31,670
essentially this whole this whole

01:22:29,530 --> 01:22:33,380
user-defined attributes and complexity

01:22:31,670 --> 01:22:34,910
and this can there's a lot of research

01:22:33,380 --> 01:22:36,620
in the area and there's language that do

01:22:34,910 --> 01:22:38,330
that sort of by default they don't need

01:22:36,620 --> 01:22:40,130
annotations they kind of deduce the cost

01:22:38,330 --> 01:22:42,140
of operations and stuff so definitely

01:22:40,130 --> 01:22:43,490
this is rated to that but can't being a

01:22:42,140 --> 01:22:46,400
bit more modest than just looking at

01:22:43,490 --> 01:22:48,230
heuristics to to assess the cost of

01:22:46,400 --> 01:22:49,970
operations not something really precise

01:22:48,230 --> 01:22:54,350
but yeah there's a lot of research and

01:22:49,970 --> 01:22:55,940
development in the area yes please hi my

01:22:54,350 --> 01:22:58,280
name is Sheldon representing snapchat

01:22:55,940 --> 01:22:59,630
and the improvements the 3% improvement

01:22:58,280 --> 01:23:01,100
to random data was really impressive

01:22:59,630 --> 01:23:03,230
I think it seems like you'll be able to

01:23:01,100 --> 01:23:05,750
pull it into stage sort do you have an

01:23:03,230 --> 01:23:08,120
idea the practical bounds here in other

01:23:05,750 --> 01:23:09,320
words how many more 3% improvements to

01:23:08,120 --> 01:23:10,550
sits or do you think we might see

01:23:09,320 --> 01:23:13,490
preventive data

01:23:10,550 --> 01:23:16,370
how many more 3% the improvements can we

01:23:13,490 --> 01:23:19,070
squeeze I suspect there's more and I

01:23:16,370 --> 01:23:21,860
suspect if if you if you take this idea

01:23:19,070 --> 01:23:23,900
and build out other 2/3 ideas on top of

01:23:21,860 --> 01:23:25,460
it is gonna compound because there's a

01:23:23,900 --> 01:23:27,800
lot of smart things you can do once you

01:23:25,460 --> 01:23:29,840
have the heap in place you can kind of

01:23:27,800 --> 01:23:32,840
be clever about it what I dislike just

01:23:29,840 --> 01:23:34,580
like a silly like insertion sort but I

01:23:32,840 --> 01:23:36,380
do believe there's there's more room to

01:23:34,580 --> 01:23:39,440
go this plenty that's why I present this

01:23:36,380 --> 01:23:41,060
idea not as the sort of the end of is

01:23:39,440 --> 01:23:42,650
not the end of some things that begin of

01:23:41,060 --> 01:23:44,480
something because right now a lot of

01:23:42,650 --> 01:23:48,350
people have heard of it and there are

01:23:44,480 --> 01:23:53,780
wait a second what if I do that yeah yes

01:23:48,350 --> 01:23:55,400
please so in your combined speed

01:23:53,780 --> 01:24:00,980
estimation function

01:23:55,400 --> 01:24:03,620
M plus C plus KD over N you said it was

01:24:00,980 --> 01:24:06,590
K with some constant what was that it

01:24:03,620 --> 01:24:09,980
was 1 by 500 I hand pick it because

01:24:06,590 --> 01:24:12,560
there's no easy way to mix this I chose

01:24:09,980 --> 01:24:15,050
it to feed the curve right it's 1 by

01:24:12,560 --> 01:24:17,780
it's 1/4 500 Justin's like this nice

01:24:15,050 --> 01:24:20,090
number but yeah you got a one of my two

01:24:17,780 --> 01:24:22,970
deuce is to figure out a principled way

01:24:20,090 --> 01:24:25,040
of computing that K thank you for thank

01:24:22,970 --> 01:24:28,640
you for asking hello yes please

01:24:25,040 --> 01:24:30,890
I have you tasted this on different CPU

01:24:28,640 --> 01:24:33,980
architectures and also whether you would

01:24:30,890 --> 01:24:36,800
want to introspect I testing it only on

01:24:33,980 --> 01:24:40,400
Intel but different Intel machines like

01:24:36,800 --> 01:24:42,770
laptops and every I got that foam right

01:24:40,400 --> 01:24:44,870
I suspect on other machines you're gonna

01:24:42,770 --> 01:24:46,730
get different results but there's only

01:24:44,870 --> 01:24:47,960
this much you can reduce the comparisons

01:24:46,730 --> 01:24:50,090
and swaps and not get not see an

01:24:47,960 --> 01:24:51,500
improvement so the fact that it reduces

01:24:50,090 --> 01:24:53,660
the comparisons and swaps and the

01:24:51,500 --> 01:24:55,520
distance is a clear indication that

01:24:53,660 --> 01:24:57,170
we're heading the right direction so I

01:24:55,520 --> 01:25:00,160
suspect is gonna work well on other

01:24:57,170 --> 01:25:02,960
machines as well thank you yes please

01:25:00,160 --> 01:25:05,900
more follow-up to questions about the

01:25:02,960 --> 01:25:08,510
heat portion of the algorithm there are

01:25:05,900 --> 01:25:12,890
other algorithms that will also provide

01:25:08,510 --> 01:25:17,150
the first three or however many elements

01:25:12,890 --> 01:25:22,490
already sorted is that the primary goal

01:25:17,150 --> 01:25:24,650
of creating the heap and if so what

01:25:22,490 --> 01:25:26,270
other algorithms and parameterization

01:25:24,650 --> 01:25:28,580
points that may be pull out four or five

01:25:26,270 --> 01:25:29,960
or six of the first initial ones or is

01:25:28,580 --> 01:25:32,780
there something more fundamental about

01:25:29,960 --> 01:25:35,120
the heap structure that is offering the

01:25:32,780 --> 01:25:38,690
improvement thank you I think that heap

01:25:35,120 --> 01:25:40,610
is um is a very subtle and interesting

01:25:38,690 --> 01:25:42,110
data structure it has some informational

01:25:40,610 --> 01:25:43,910
properties that for example is the

01:25:42,110 --> 01:25:46,820
minimum of comparisons that you can get

01:25:43,910 --> 01:25:48,230
for that structure so in the heap I

01:25:46,820 --> 01:25:49,700
notice for examples this other question

01:25:48,230 --> 01:25:51,890
well how about that last term and we

01:25:49,700 --> 01:25:53,570
care to push keep it in it turns out it

01:25:51,890 --> 01:25:55,280
does make a difference so the heap is

01:25:53,570 --> 01:25:57,290
not only that I get the smallest three

01:25:55,280 --> 01:26:00,230
elements at the beginning it's also that

01:25:57,290 --> 01:26:05,210
I get these sorted sub-arrays the sorted

01:26:00,230 --> 01:26:07,280
like if you wish spans in the array that

01:26:05,210 --> 01:26:09,500
are also sorted and of small length

01:26:07,280 --> 01:26:11,840
their log in length but there are many

01:26:09,500 --> 01:26:13,640
there are quite a few and it's the

01:26:11,840 --> 01:26:15,620
entire structure that helps is not only

01:26:13,640 --> 01:26:19,790
the top three elements but thank you for

01:26:15,620 --> 01:26:21,680
asking sir excellent yes so if we had an

01:26:19,790 --> 01:26:22,610
ability to say how much a copy was or

01:26:21,680 --> 01:26:25,880
anything like that how could we do

01:26:22,610 --> 01:26:28,010
things like saying how long a branch

01:26:25,880 --> 01:26:29,210
predictor is going to be hot or how this

01:26:28,010 --> 01:26:30,410
algorithm is gonna be there like you've

01:26:29,210 --> 01:26:33,530
mentioned that seem like a big point of

01:26:30,410 --> 01:26:35,420
it but how could that be conveyed how

01:26:33,530 --> 01:26:36,950
can you convey the cost of a branch

01:26:35,420 --> 01:26:38,750
prediction failure and that kind of

01:26:36,950 --> 01:26:41,540
stuff right or even how often my

01:26:38,750 --> 01:26:42,890
algorithm is going to fail to be you

01:26:41,540 --> 01:26:46,010
know it's gonna be more it's kind of a

01:26:42,890 --> 01:26:47,510
high probability or happy well you know

01:26:46,010 --> 01:26:48,920
there's likely there's the macro likely

01:26:47,510 --> 01:26:50,480
it's kind of the bottom you know the

01:26:48,920 --> 01:26:52,670
first line of resistance we have like

01:26:50,480 --> 01:26:55,010
the means to kind of hard code the

01:26:52,670 --> 01:26:55,700
likely but I think that's a hard problem

01:26:55,010 --> 01:26:57,680
really

01:26:55,700 --> 01:26:59,870
you can encode is gonna cost me this

01:26:57,680 --> 01:27:02,450
many comparisons but it's difficult to

01:26:59,870 --> 01:27:04,460
say well you know the probability of a

01:27:02,450 --> 01:27:06,380
successful comparison is that yeah I I

01:27:04,460 --> 01:27:07,910
did this is take a second-order thing I

01:27:06,380 --> 01:27:09,680
love it you know it still really take

01:27:07,910 --> 01:27:13,700
things forward yes please

01:27:09,680 --> 01:27:16,790
Eric we have these attributes that say

01:27:13,700 --> 01:27:19,340
how much does a copy costs say and I

01:27:16,790 --> 01:27:22,100
have to hand in it and say it costs like

01:27:19,340 --> 01:27:24,680
four units and then I go ahead and add

01:27:22,100 --> 01:27:27,020
an extra member to my class and now I

01:27:24,680 --> 01:27:29,480
have to go and change and say it's not

01:27:27,020 --> 01:27:32,750
five units so it kind of becomes almost

01:27:29,480 --> 01:27:35,030
anymore um the maintenance issue is real

01:27:32,750 --> 01:27:37,610
but you don't say five units you say

01:27:35,030 --> 01:27:39,440
five times the element is you say that's

01:27:37,610 --> 01:27:42,700
one introspection is needed because you

01:27:39,440 --> 01:27:46,400
need to say member you know members

01:27:42,700 --> 01:27:48,680
member count times this size of times

01:27:46,400 --> 01:27:50,930
this elementary cost so you don't say a

01:27:48,680 --> 01:27:53,810
hard number you just say proportional to

01:27:50,930 --> 01:27:56,300
your to your number of elements in this

01:27:53,810 --> 01:27:57,800
in the structure so it should all except

01:27:56,300 --> 01:28:00,590
for the primitive operations it should

01:27:57,800 --> 01:28:01,820
be all propagate and computed depending

01:28:00,590 --> 01:28:03,380
on the interest with the results of

01:28:01,820 --> 01:28:09,080
introspection thank you very much for

01:28:03,380 --> 01:28:11,450
asking yes please Ian's hi does your

01:28:09,080 --> 01:28:13,910
coat hold up against the spectrum fixes

01:28:11,450 --> 01:28:16,910
because you're like depending on the

01:28:13,910 --> 01:28:18,199
branch prediction come again the

01:28:16,910 --> 01:28:20,090
spectrum

01:28:18,199 --> 01:28:24,530
traffic's us and the other box which

01:28:20,090 --> 01:28:28,580
were in the branch predictor the spectra

01:28:24,530 --> 01:28:31,940
odd the specter yeah I'm out of my depth

01:28:28,580 --> 01:28:34,610
here so I don't know it's a it's a good

01:28:31,940 --> 01:28:37,880
research direction I'm gonna take one

01:28:34,610 --> 01:28:40,400
more question yes please hello

01:28:37,880 --> 01:28:44,239
what we were saying at the end reminded

01:28:40,400 --> 01:28:46,550
me to one interview where there is one

01:28:44,239 --> 01:28:48,890
sentence saying one of the things that

01:28:46,550 --> 01:28:51,739
is central to generic programming as I

01:28:48,890 --> 01:28:53,630
understand it now is that complexity or

01:28:51,739 --> 01:28:56,270
at least some general notion of

01:28:53,630 --> 01:29:00,020
complexity has to be associated with an

01:28:56,270 --> 01:29:02,060
operation and that's from 95 Alex

01:29:00,020 --> 01:29:04,429
definitely interviewed two dogs journals

01:29:02,060 --> 01:29:06,230
so does this somehow ties in with that

01:29:04,429 --> 01:29:08,750
all right it is definitely preternatural

01:29:06,230 --> 01:29:10,340
and I think so I have this library in

01:29:08,750 --> 01:29:13,010
which you can actually say Big O of the

01:29:10,340 --> 01:29:15,469
cellar is the first parameter times log

01:29:13,010 --> 01:29:17,960
log the first parameter so you can say

01:29:15,469 --> 01:29:19,850
sort has the complete the all bigger

01:29:17,960 --> 01:29:21,650
Greedo complexity and cost of operations

01:29:19,850 --> 01:29:23,570
different things right because

01:29:21,650 --> 01:29:25,850
amortization and all that math says

01:29:23,570 --> 01:29:28,429
right so it's different algebra but with

01:29:25,850 --> 01:29:30,170
I think that that was pretty natural

01:29:28,429 --> 01:29:31,820
step enough to say hey you know we

01:29:30,170 --> 01:29:33,640
should have that and yes we should have

01:29:31,820 --> 01:29:36,530
that in the form of attributes that are

01:29:33,640 --> 01:29:38,120
have an algebra on top of them and are

01:29:36,530 --> 01:29:40,100
transportable in there you know they can

01:29:38,120 --> 01:29:42,320
be passed around in computer than and

01:29:40,100 --> 01:29:44,210
say you should know by looking at the

01:29:42,320 --> 01:29:46,460
signature of sort is gonna be n log N

01:29:44,210 --> 01:29:49,190
and that's possible with user-defined

01:29:46,460 --> 01:29:50,719
attributes thank you okay thanks again

01:29:49,190 --> 01:29:52,960
very much for those of you who stayed

01:29:50,719 --> 01:29:56,630
thank you

01:29:52,960 --> 01:29:56,630

YouTube URL: https://www.youtube.com/watch?v=FJJTYQYB1JQ


