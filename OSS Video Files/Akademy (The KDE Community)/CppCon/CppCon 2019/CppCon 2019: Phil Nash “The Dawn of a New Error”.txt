Title: CppCon 2019: Phil Nash “The Dawn of a New Error”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
As a community we've tried many different ways to express, propagate and handle error conditions in our code over the years. Each seem to have different trade-offs, with none being perfect in all cases.

This presentation is the follow-up to my earlier talk, "Option(al) Is Not a Failure", where I surveyed existing error-handling approaches and score them against each other, leading up to the new proposal, p0709, "Zero-overhead deterministic exceptions".

We'll summarise some of that background so we're all on the same page, but in this talk we're going to dig into the proposal in more depth - and look at the supporting proposals, p1028 (std::error) and p1029 ([[move relocates]]) and others. We'll also comment similar mechanisms in other languages, notably Swift, to get an idea of how it might work out in practice.
— 
Phil Nash
Developer Advocate, JetBrains
Developer Advocate at JetBrains, author of Catch/Catch2, co-host of cpp.chat, host of C++ London, chair and organiser of C++ on Sea.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,320 --> 00:00:13,990
thank you all for coming I'm Phil Nash

00:00:10,510 --> 00:00:15,700
my twitter handle down there Casey wants

00:00:13,990 --> 00:00:16,990
to follow me and you see it again at the

00:00:15,700 --> 00:00:19,779
end this in case you want to unfollow me

00:00:16,990 --> 00:00:22,390
by that point so I'm developer advocate

00:00:19,779 --> 00:00:23,710
at Jeb rates we had a booth for a week

00:00:22,390 --> 00:00:25,900
but that's finished now so you miss your

00:00:23,710 --> 00:00:27,400
chance but you can catch me or any of my

00:00:25,900 --> 00:00:29,230
colleagues for the rest of the week

00:00:27,400 --> 00:00:31,210
afterwards but we're not gonna talk

00:00:29,230 --> 00:00:32,169
about that now we are going to talk

00:00:31,210 --> 00:00:34,120
about error handling

00:00:32,169 --> 00:00:35,620
hopefully that was obvious from from the

00:00:34,120 --> 00:00:38,199
title in fact were going to talk about

00:00:35,620 --> 00:00:41,890
the the future of error handling in C++

00:00:38,199 --> 00:00:45,210
or the possible futures with a little

00:00:41,890 --> 00:00:49,000
bit of historical context as well now I

00:00:45,210 --> 00:00:54,070
forgot to do my my 60 second transition

00:00:49,000 --> 00:00:57,070
so left to talk a little bit more as I

00:00:54,070 --> 00:01:00,460
go through actually this this photo was

00:00:57,070 --> 00:01:00,940
taken from the the jetbrains Christmas

00:01:00,460 --> 00:01:02,589
party

00:01:00,940 --> 00:01:05,379
last year we actually went out to the

00:01:02,589 --> 00:01:07,479
Austrian Alps to have a party out there

00:01:05,379 --> 00:01:09,580
and I took this photo from from the

00:01:07,479 --> 00:01:12,990
hotel window I thought let's make a nice

00:01:09,580 --> 00:01:12,990
little background picture up on the side

00:01:13,110 --> 00:01:20,020
don't think I can get past it without

00:01:16,030 --> 00:01:29,620
the next 30 seconds so this is a nice

00:01:20,020 --> 00:01:33,880
picture I like it I really should

00:01:29,620 --> 00:01:37,690
rethink that strategy should they

00:01:33,880 --> 00:01:40,170
dissociate new era for me another 9

00:01:37,690 --> 00:01:40,170
seconds left

00:01:45,130 --> 00:01:51,890
there we go finally so a little bit of

00:01:50,119 --> 00:01:53,750
historical context that I wanted to talk

00:01:51,890 --> 00:01:56,630
about because we're going to be talking

00:01:53,750 --> 00:01:58,369
about this proposal so it's obviously

00:01:56,630 --> 00:02:00,799
still the future at the moment this is

00:01:58,369 --> 00:02:02,840
p0 709 many of you have heard of this by

00:02:00,799 --> 00:02:06,979
now hopes going to be talking about it

00:02:02,840 --> 00:02:08,569
more in his keynote and obviously

00:02:06,979 --> 00:02:10,900
there's got hopes name on the paper as

00:02:08,569 --> 00:02:14,300
long as as well as many other people I

00:02:10,900 --> 00:02:17,450
actually did a talk on this proposal

00:02:14,300 --> 00:02:19,220
last year the optional was not a failure

00:02:17,450 --> 00:02:21,110
some of you may have seen that you can

00:02:19,220 --> 00:02:23,390
consider this talk the sequel to that

00:02:21,110 --> 00:02:26,120
one so if you haven't seen that talk

00:02:23,390 --> 00:02:27,200
some of the initial details missing a

00:02:26,120 --> 00:02:29,600
bit lights because we're going to dig

00:02:27,200 --> 00:02:32,450
into more of the supporting proposals

00:02:29,600 --> 00:02:34,880
with some of the sothey for underlying

00:02:32,450 --> 00:02:38,150
things but we are going to look a little

00:02:34,880 --> 00:02:40,220
bit at some of the context again and a

00:02:38,150 --> 00:02:41,600
little bit of a summary now

00:02:40,220 --> 00:02:42,799
interestingly this is not actually the

00:02:41,600 --> 00:02:46,100
first talk that I've done with that

00:02:42,799 --> 00:02:47,750
title I did this one say same title

00:02:46,100 --> 00:02:49,730
option was not a failure but this was

00:02:47,750 --> 00:02:51,739
actually at a mobile conference and it

00:02:49,730 --> 00:02:54,260
was in the context of Swift and the

00:02:51,739 --> 00:02:55,519
reason I bring that up is because this

00:02:54,260 --> 00:02:57,920
is what I first had the idea for this

00:02:55,519 --> 00:02:59,269
subject matter because one of the

00:02:57,920 --> 00:03:02,660
statements I made during that talk was

00:02:59,269 --> 00:03:04,190
that I believe that Swift has probably

00:03:02,660 --> 00:03:05,840
the most advanced error handling

00:03:04,190 --> 00:03:09,100
strategy of any programming language

00:03:05,840 --> 00:03:11,239
today and that's quite a bold claim but

00:03:09,100 --> 00:03:13,370
when I made that statement in front of

00:03:11,239 --> 00:03:14,299
all these Swift developers I could see

00:03:13,370 --> 00:03:17,630
them all nodding their heads in

00:03:14,299 --> 00:03:20,329
agreement is it's actually really really

00:03:17,630 --> 00:03:23,959
done a really good job of air handling

00:03:20,329 --> 00:03:26,239
and my idea was to try and bring some of

00:03:23,959 --> 00:03:28,579
these ideas to the C++ community so I

00:03:26,239 --> 00:03:30,950
proposed the same talk the C++

00:03:28,579 --> 00:03:32,390
conferences and then before actually

00:03:30,950 --> 00:03:34,790
gave the first version I heard about

00:03:32,390 --> 00:03:37,700
hers proposal which was basically to do

00:03:34,790 --> 00:03:39,680
exactly that so what we're going to see

00:03:37,700 --> 00:03:43,790
is something very much like a swift

00:03:39,680 --> 00:03:45,650
error handling in C++ but that history

00:03:43,790 --> 00:03:47,690
wanted to talk about it's not the first

00:03:45,650 --> 00:03:51,530
time I've looked at alternate error

00:03:47,690 --> 00:03:54,220
handing strategies in C++ so who here

00:03:51,530 --> 00:03:57,470
has heard of exploding return types

00:03:54,220 --> 00:03:59,480
yeah just a couple of hands yeah so bit

00:03:57,470 --> 00:04:01,640
of an old idea now and for various

00:03:59,480 --> 00:04:04,760
reasons we don't really do this anymore

00:04:01,640 --> 00:04:06,530
but I think I first heard about it from

00:04:04,760 --> 00:04:10,220
a talk by Andre leagues and rescue back

00:04:06,530 --> 00:04:11,120
in 2007 so choose your poison exceptions

00:04:10,220 --> 00:04:12,770
or error codes

00:04:11,120 --> 00:04:14,780
you know discussing the trade-offs

00:04:12,770 --> 00:04:17,290
between the two and how we might want to

00:04:14,780 --> 00:04:20,570
try and get the best of both worlds and

00:04:17,290 --> 00:04:24,919
the talks focused around this template

00:04:20,570 --> 00:04:27,020
likely T and a couple of interesting

00:04:24,919 --> 00:04:29,270
properties of this template the first

00:04:27,020 --> 00:04:31,790
one which will dig more into a bit later

00:04:29,270 --> 00:04:33,140
is it represents either the or holds

00:04:31,790 --> 00:04:37,820
over the value actually want to do

00:04:33,140 --> 00:04:39,310
return or some exception type but for

00:04:37,820 --> 00:04:42,560
the purpose our discussion right now

00:04:39,310 --> 00:04:45,200
this bit is interesting if you haven't

00:04:42,560 --> 00:04:47,630
actually checked the the value or error

00:04:45,200 --> 00:04:49,419
code before it goes out to scope the

00:04:47,630 --> 00:04:52,580
destructor actually froze the exception

00:04:49,419 --> 00:04:54,100
so heads the exploding return type so it

00:04:52,580 --> 00:04:55,940
forces you to actually deal with it

00:04:54,100 --> 00:04:57,590
although you know obviously it's not

00:04:55,940 --> 00:04:59,479
perfect because he is still a runtime

00:04:57,590 --> 00:05:02,540
thing we have better ways of doing that

00:04:59,479 --> 00:05:05,900
now it turns out that it wasn't even the

00:05:02,540 --> 00:05:08,810
first version of this I I dug back in to

00:05:05,900 --> 00:05:11,479
complain C++ moderated around 2000 it

00:05:08,810 --> 00:05:13,729
was being discussed this one by her Ken

00:05:11,479 --> 00:05:15,950
Hagen here again you can see the

00:05:13,729 --> 00:05:18,979
destructor throwing if the type is not

00:05:15,950 --> 00:05:20,630
being checked and I even referenced only

00:05:18,979 --> 00:05:21,260
work particular by at least the

00:05:20,630 --> 00:05:24,020
Lippincott

00:05:21,260 --> 00:05:25,490
who was in that same thread chipping in

00:05:24,020 --> 00:05:27,650
I really like this this comment that she

00:05:25,490 --> 00:05:29,930
made let's not repeat the mistakes of

00:05:27,650 --> 00:05:32,180
the past model the copy construction and

00:05:29,930 --> 00:05:35,360
assignments but the current auto pointer

00:05:32,180 --> 00:05:38,810
are not the old broken one simpler times

00:05:35,360 --> 00:05:40,340
we lived in so it's like it's been

00:05:38,810 --> 00:05:42,440
around for a long time but let's say

00:05:40,340 --> 00:05:45,140
it's not really what we do today so fast

00:05:42,440 --> 00:05:47,539
forwarding a little bit 2012 Alexandria

00:05:45,140 --> 00:05:51,370
again doing another talk systematic

00:05:47,539 --> 00:05:54,830
error handling in C++ and in this talk

00:05:51,370 --> 00:05:57,490
he presented a very similar template and

00:05:54,830 --> 00:06:00,770
it's not greater than a slide there so I

00:05:57,490 --> 00:06:02,900
thought the original map and you can see

00:06:00,770 --> 00:06:06,090
it still got this idea of containing

00:06:02,900 --> 00:06:08,580
either the value you wanted or an except

00:06:06,090 --> 00:06:10,830
in this case but it doesn't have this

00:06:08,580 --> 00:06:13,280
exploding return type so if they're

00:06:10,830 --> 00:06:19,200
still down to that essential property

00:06:13,280 --> 00:06:21,060
what did he call this type expectancy we

00:06:19,200 --> 00:06:24,560
says expecting to use either a tea or

00:06:21,060 --> 00:06:26,910
the exception preventing its creation

00:06:24,560 --> 00:06:29,669
just might all sound a bit too familiar

00:06:26,910 --> 00:06:33,389
because of course we now have this

00:06:29,669 --> 00:06:35,760
proposal stood expected P Zero free to

00:06:33,389 --> 00:06:37,470
free I don't think it actually made it

00:06:35,760 --> 00:06:40,110
into 20 and then in the end but I think

00:06:37,470 --> 00:06:41,669
it's still still on the table and that

00:06:40,110 --> 00:06:44,250
is really just the evolution of the

00:06:41,669 --> 00:06:47,220
ideas that Andre

00:06:44,250 --> 00:06:49,680
originally proposed but these are not

00:06:47,220 --> 00:06:52,020
new ideas to program languages in

00:06:49,680 --> 00:06:53,940
general so just to pick a few languages

00:06:52,020 --> 00:06:56,160
that I have some familiarity with they

00:06:53,940 --> 00:06:57,590
have very similar types most of them

00:06:56,160 --> 00:06:59,639
called result

00:06:57,590 --> 00:07:01,590
Haskell's case it's a bit more general

00:06:59,639 --> 00:07:04,470
who got the either monad but they're all

00:07:01,590 --> 00:07:06,660
doing the same thing had the type who

00:07:04,470 --> 00:07:09,570
actually wanted or some sort of arrow

00:07:06,660 --> 00:07:12,479
type which may or may not be an

00:07:09,570 --> 00:07:14,820
exception type interestingly the swift

00:07:12,479 --> 00:07:17,160
one there says still only got this

00:07:14,820 --> 00:07:19,380
result type since switch five which

00:07:17,160 --> 00:07:21,660
actually came out earlier this year and

00:07:19,380 --> 00:07:23,520
if you remember I said that I felt that

00:07:21,660 --> 00:07:24,810
Swift's error handling was about the

00:07:23,520 --> 00:07:27,510
best in any programming language right

00:07:24,810 --> 00:07:30,900
now that's because I think the Swift

00:07:27,510 --> 00:07:32,820
actually leaked prompt ahead to where we

00:07:30,900 --> 00:07:34,050
want to be and this is really just a

00:07:32,820 --> 00:07:35,160
stepping stone and it turned out to be

00:07:34,050 --> 00:07:37,440
useful to go back to it for other

00:07:35,160 --> 00:07:39,150
reasons mostly asynchrony and some

00:07:37,440 --> 00:07:42,570
things like that which we might get to

00:07:39,150 --> 00:07:44,580
later so it's quite a common idea that

00:07:42,570 --> 00:07:46,620
we were all sort of converging on this

00:07:44,580 --> 00:07:49,860
stepping stone as I say so let's have a

00:07:46,620 --> 00:07:52,560
look at how that works so here's an

00:07:49,860 --> 00:07:55,590
example function just to parse a string

00:07:52,560 --> 00:07:57,090
into an integer and the significant part

00:07:55,590 --> 00:07:59,520
and forget the fact that it's using i/o

00:07:57,090 --> 00:08:03,930
streams doesn't matter it's see the

00:07:59,520 --> 00:08:07,530
return type is still expected of int

00:08:03,930 --> 00:08:09,060
which is the type we wanted or used an

00:08:07,530 --> 00:08:10,470
exception here stirred domain error but

00:08:09,060 --> 00:08:13,800
it could be any any type you want to

00:08:10,470 --> 00:08:15,080
represent the error and so good exactly

00:08:13,800 --> 00:08:20,320
what we were talking about earlier the

00:08:15,080 --> 00:08:22,450
return for the the error case is this

00:08:20,320 --> 00:08:23,860
student make unexpected it's got this

00:08:22,450 --> 00:08:26,590
little sort of factory function wrapper

00:08:23,860 --> 00:08:28,510
just to make overloading work nicely so

00:08:26,590 --> 00:08:30,970
when you return the actual value you

00:08:28,510 --> 00:08:32,260
don't have to to wrap that one but

00:08:30,970 --> 00:08:36,580
really that's all it's doing is just

00:08:32,260 --> 00:08:38,260
returning the the unexpected so that's

00:08:36,580 --> 00:08:39,849
all pretty straightforward I think we

00:08:38,260 --> 00:08:42,640
readily understand what this is doing

00:08:39,849 --> 00:08:47,430
sever look at how we'd use that how we'd

00:08:42,640 --> 00:08:50,590
call that so calling pars in down here

00:08:47,430 --> 00:08:52,600
capturing the result would test it you

00:08:50,590 --> 00:08:55,030
can see works very much like ensued

00:08:52,600 --> 00:08:56,680
optional which sort of models a pointer

00:08:55,030 --> 00:08:59,920
so you can you can test it using the

00:08:56,680 --> 00:09:02,290
explicit boolean conversion operator and

00:08:59,920 --> 00:09:04,960
you can dereference it using that the

00:09:02,290 --> 00:09:06,610
store operator and of course if it

00:09:04,960 --> 00:09:09,220
doesn't have the value in there that's

00:09:06,610 --> 00:09:11,650
going to throw that exception but then

00:09:09,220 --> 00:09:13,360
in the error path at the bottom is very

00:09:11,650 --> 00:09:14,860
difference from optional with as

00:09:13,360 --> 00:09:17,650
optional that you'll be done you know

00:09:14,860 --> 00:09:18,970
you start to muddle along but this one

00:09:17,650 --> 00:09:21,070
actually gives you the error type that

00:09:18,970 --> 00:09:22,660
you returned and because here it was an

00:09:21,070 --> 00:09:24,670
exception we can do dot what's on it but

00:09:22,660 --> 00:09:26,620
it can be any type new one that's be

00:09:24,670 --> 00:09:29,410
said so again pretty straightforward

00:09:26,620 --> 00:09:31,420
fairly easy to understand anything oh

00:09:29,410 --> 00:09:34,600
really this is just giving us what we

00:09:31,420 --> 00:09:36,130
always had with error codes but now

00:09:34,600 --> 00:09:37,780
we're not blocking the return channel we

00:09:36,130 --> 00:09:39,580
can return other values as well and it

00:09:37,780 --> 00:09:40,930
sort of forces us to deal with it you

00:09:39,580 --> 00:09:42,640
might want to throw no discard in there

00:09:40,930 --> 00:09:45,580
as well I'll talk about that sort of

00:09:42,640 --> 00:09:49,050
thing a lot more my previous talk so

00:09:45,580 --> 00:09:54,370
great that's what's the problem well

00:09:49,050 --> 00:09:57,580
this is the problem see that's the the

00:09:54,370 --> 00:09:58,900
happy path and in fact on this screen

00:09:57,580 --> 00:10:01,150
you can't see I've also highlighted the

00:09:58,900 --> 00:10:02,650
arrow path in red some reason hasn't

00:10:01,150 --> 00:10:04,270
come out but the rest of the code

00:10:02,650 --> 00:10:06,520
basically is see the arrow path the

00:10:04,270 --> 00:10:08,710
boilerplate just associated with our

00:10:06,520 --> 00:10:10,800
handling Dom it's already dominating

00:10:08,710 --> 00:10:12,940
even this smaller tip we've got examples

00:10:10,800 --> 00:10:16,420
it's all mixed in together there's no

00:10:12,940 --> 00:10:17,560
separation as we might be used to with

00:10:16,420 --> 00:10:19,930
exceptions where you get in that nice

00:10:17,560 --> 00:10:22,360
clean separation so that that's a real

00:10:19,930 --> 00:10:24,550
problem I think because especially when

00:10:22,360 --> 00:10:26,980
you scale this up but let's do that

00:10:24,550 --> 00:10:28,660
let's add another function we want to

00:10:26,980 --> 00:10:30,220
compose with that so here's another

00:10:28,660 --> 00:10:32,860
function that takes in this case two

00:10:30,220 --> 00:10:35,619
integers and returns a

00:10:32,860 --> 00:10:38,009
stood expected again so don't worry too

00:10:35,619 --> 00:10:40,989
much about it it's doing a silly

00:10:38,009 --> 00:10:43,480
division by zero check just for the sake

00:10:40,989 --> 00:10:44,619
of the example first put that one up

00:10:43,480 --> 00:10:47,220
there and we're throwing another

00:10:44,619 --> 00:10:47,220
function as well

00:10:47,499 --> 00:10:51,069
this one's not got any error handling

00:10:48,879 --> 00:10:52,600
it's just taking it in turn from

00:10:51,069 --> 00:10:54,869
returning it in but we're going to

00:10:52,600 --> 00:10:57,129
compose these free functions together

00:10:54,869 --> 00:11:00,309
well while taking into account the error

00:10:57,129 --> 00:11:05,799
handling so would write code so in like

00:11:00,309 --> 00:11:08,379
this now it's reasonably easy to follow

00:11:05,799 --> 00:11:11,170
this is nothing complex going on but

00:11:08,379 --> 00:11:12,730
it's really messy so the the error

00:11:11,170 --> 00:11:15,009
handling is really really dominating now

00:11:12,730 --> 00:11:17,110
and you've got this heavy nesting the

00:11:15,009 --> 00:11:18,549
the happy path ends up sort of right in

00:11:17,110 --> 00:11:20,429
the middle of it somewhere it's

00:11:18,549 --> 00:11:23,529
difficult to follow the flow at a glance

00:11:20,429 --> 00:11:25,389
so that's how bad it gets now you might

00:11:23,529 --> 00:11:27,040
be able to clean it up a little bit by

00:11:25,389 --> 00:11:30,119
using early returns if that's an option

00:11:27,040 --> 00:11:34,209
it doesn't actually help that much a bit

00:11:30,119 --> 00:11:35,949
so yeah sum up that pain on on this

00:11:34,209 --> 00:11:38,199
solution although I like the idea of it

00:11:35,949 --> 00:11:40,660
and one thing I dug into a lot more in

00:11:38,199 --> 00:11:44,019
the previous talk was implications such

00:11:40,660 --> 00:11:49,179
as performance costs of exceptions

00:11:44,019 --> 00:11:51,220
versus unexpected and the runtime costs

00:11:49,179 --> 00:11:52,449
in terms of image size and all those

00:11:51,220 --> 00:11:54,429
sorts of things we talked about before

00:11:52,449 --> 00:11:55,600
so I'm going to seem you're on board

00:11:54,429 --> 00:11:58,269
with this is this is the better solution

00:11:55,600 --> 00:12:01,299
for those purposes but this is the cost

00:11:58,269 --> 00:12:02,619
that we have to do with though remember

00:12:01,299 --> 00:12:04,589
I put up that list of other languages

00:12:02,619 --> 00:12:06,939
that had similar things in them earlier

00:12:04,589 --> 00:12:08,589
some of those are functional languages

00:12:06,939 --> 00:12:11,920
or at least they have some functional

00:12:08,589 --> 00:12:14,649
elements how do they deal with with this

00:12:11,920 --> 00:12:16,749
sort of problem well brought up

00:12:14,649 --> 00:12:19,480
functional programming so probably guess

00:12:16,749 --> 00:12:24,910
of course the answer does involve no

00:12:19,480 --> 00:12:26,589
nets so when I have a half an hour

00:12:24,910 --> 00:12:28,569
session or what a monad is no we're just

00:12:26,589 --> 00:12:28,929
going to talk about well that's going to

00:12:28,569 --> 00:12:31,209
give us

00:12:28,929 --> 00:12:32,889
so there's another proposal now this is

00:12:31,209 --> 00:12:35,679
in terms of said optional but it applies

00:12:32,889 --> 00:12:37,600
equally to still expected and the author

00:12:35,679 --> 00:12:39,610
would would fully expect to to assert

00:12:37,600 --> 00:12:41,410
expected version as well so monadic

00:12:39,610 --> 00:12:44,529
operations for in this case stood

00:12:41,410 --> 00:12:45,730
optional and what are they so look what

00:12:44,529 --> 00:12:50,690
the abstract says

00:12:45,730 --> 00:12:53,960
says I propose adding transform and then

00:12:50,690 --> 00:12:56,780
and or else member functions to still

00:12:53,960 --> 00:12:59,570
optional while still expected to support

00:12:56,780 --> 00:13:01,880
this magnetic starter programming so

00:12:59,570 --> 00:13:03,680
what are these functions actually do if

00:13:01,880 --> 00:13:05,840
you do have a bit of a functional

00:13:03,680 --> 00:13:09,560
programming background you might

00:13:05,840 --> 00:13:12,620
recognize these as map bind and what

00:13:09,560 --> 00:13:14,840
about the or else in the context of

00:13:12,620 --> 00:13:17,630
error handling this is very close to

00:13:14,840 --> 00:13:19,130
what you might call a catch it's the

00:13:17,630 --> 00:13:21,650
thing that actually deals with the error

00:13:19,130 --> 00:13:23,630
at the end so you can already see how

00:13:21,650 --> 00:13:25,610
we're pushing the error handling to a

00:13:23,630 --> 00:13:30,350
separate block and using these methods

00:13:25,610 --> 00:13:31,610
to compose the happy path steps so so go

00:13:30,350 --> 00:13:34,940
back to our example and see how that

00:13:31,610 --> 00:13:36,320
will play out so that was the one with

00:13:34,940 --> 00:13:38,870
the early return so really slightly

00:13:36,320 --> 00:13:41,080
better if it could use those magnetic

00:13:38,870 --> 00:13:44,720
methods would look more like that I

00:13:41,080 --> 00:13:47,270
think you can agree just from that slide

00:13:44,720 --> 00:13:48,830
transition just how much that actually

00:13:47,270 --> 00:13:51,620
saves you in terms of boilerplate and

00:13:48,830 --> 00:13:52,880
also once you get used to the style you

00:13:51,620 --> 00:13:54,710
can you know readily see the flow of

00:13:52,880 --> 00:13:58,730
data going through well I haven't but

00:13:54,710 --> 00:14:01,310
the or else block in there but that

00:13:58,730 --> 00:14:03,940
would just be tacked on the end so

00:14:01,310 --> 00:14:07,460
that's a big improvement you know what

00:14:03,940 --> 00:14:09,140
it's still not good enough there's still

00:14:07,460 --> 00:14:12,080
a fair bit of boilerplate on there and

00:14:09,140 --> 00:14:14,540
this is the bleeding edge of C++ this is

00:14:12,080 --> 00:14:16,640
a proposal on top of a proposal we don't

00:14:14,540 --> 00:14:21,020
have yet and we're still not really

00:14:16,640 --> 00:14:25,700
there so I think that's a that's a bit

00:14:21,020 --> 00:14:28,790
of a problem yeah just to compare that

00:14:25,700 --> 00:14:33,620
against what we already have in C++

00:14:28,790 --> 00:14:36,530
which is exceptions that's what we would

00:14:33,620 --> 00:14:38,990
do with exceptions just do that again so

00:14:36,530 --> 00:14:43,040
that's our best efforts looking forward

00:14:38,990 --> 00:14:46,850
to the future and if exceptions it's so

00:14:43,040 --> 00:14:49,420
much lighter weight so what we want to

00:14:46,850 --> 00:14:53,870
do of course is have our cake and eat it

00:14:49,420 --> 00:14:56,710
so what would this look like with p0 709

00:14:53,870 --> 00:15:02,240
curve suppose

00:14:56,710 --> 00:15:04,910
well basically that and in fact say that

00:15:02,240 --> 00:15:07,070
try key word there that parts optional

00:15:04,910 --> 00:15:09,020
and currently the committee is not

00:15:07,070 --> 00:15:11,420
favoring it I'm still hopeful we'll

00:15:09,020 --> 00:15:12,890
discuss what that means in a minute but

00:15:11,420 --> 00:15:14,420
that doesn't even have to be there so

00:15:12,890 --> 00:15:18,200
basically it looks always exactly it's

00:15:14,420 --> 00:15:20,180
like exceptions that we have today but

00:15:18,200 --> 00:15:21,260
the interesting property is it has all

00:15:20,180 --> 00:15:23,750
of the performance and other

00:15:21,260 --> 00:15:27,650
characteristics of the stood expected

00:15:23,750 --> 00:15:29,720
version and if you want to know how it

00:15:27,650 --> 00:15:31,700
does that well first we need to see the

00:15:29,720 --> 00:15:33,200
previous talk and in the second half of

00:15:31,700 --> 00:15:36,200
this talk we're going to dig into all

00:15:33,200 --> 00:15:37,780
the other aspects that support how that

00:15:36,200 --> 00:15:40,820
works

00:15:37,780 --> 00:15:44,870
but let's just look a little bit more

00:15:40,820 --> 00:15:47,300
about how this syntax works here's the

00:15:44,870 --> 00:15:49,970
interesting moving parts so this is this

00:15:47,300 --> 00:15:52,580
additional froze qualifier on the the

00:15:49,970 --> 00:15:55,460
function signature so it's not like the

00:15:52,580 --> 00:15:57,560
deprecated throw keyword and in fact

00:15:55,460 --> 00:15:58,940
that was proposed at one point resurrect

00:15:57,560 --> 00:16:02,180
that for this purpose that was felt to

00:15:58,940 --> 00:16:04,280
be too confusing so it's froze that just

00:16:02,180 --> 00:16:05,750
means that this this function froze but

00:16:04,280 --> 00:16:07,790
you can think of that as being the

00:16:05,750 --> 00:16:11,990
equivalent of saying transform the

00:16:07,790 --> 00:16:14,110
return type into stood expected of the

00:16:11,990 --> 00:16:17,600
value or the type and some arrow type

00:16:14,110 --> 00:16:20,090
discuss what the arrow type is soon Nega

00:16:17,600 --> 00:16:22,490
we have fro looks just like fro we have

00:16:20,090 --> 00:16:25,130
today except we're throwing the value

00:16:22,490 --> 00:16:26,240
type here in fact as we'll see in a

00:16:25,130 --> 00:16:31,490
moment that's actually just an enum

00:16:26,240 --> 00:16:33,230
value rather than an exception type and

00:16:31,490 --> 00:16:35,330
then we had that optional try keyword

00:16:33,230 --> 00:16:36,920
they say it's not actually necessary but

00:16:35,330 --> 00:16:39,440
when you combine that with the froze

00:16:36,920 --> 00:16:41,810
keyword the advantage that has if it

00:16:39,440 --> 00:16:44,240
actually makes exceptions are visible in

00:16:41,810 --> 00:16:46,460
the code it makes it easier to reason

00:16:44,240 --> 00:16:48,110
about where exceptions may may come from

00:16:46,460 --> 00:16:50,420
and I think herp might talk a bit more

00:16:48,110 --> 00:16:52,160
about this in his keynote so I won't go

00:16:50,420 --> 00:16:53,810
into too much here other than to say I'm

00:16:52,160 --> 00:16:56,570
strongly in the camp right I think this

00:16:53,810 --> 00:17:00,110
is a good idea but we'll see how that

00:16:56,570 --> 00:17:02,090
goes on the committee all right listen

00:17:00,110 --> 00:17:04,160
add a bit more code down here let's say

00:17:02,090 --> 00:17:06,770
we're composing this into into another

00:17:04,160 --> 00:17:08,850
function so that function itself can

00:17:06,770 --> 00:17:10,410
also at the froze keyword

00:17:08,850 --> 00:17:11,850
whether you have the try keyword or not

00:17:10,410 --> 00:17:15,240
this can all be statically checked by

00:17:11,850 --> 00:17:17,580
the compiler so if you're in a function

00:17:15,240 --> 00:17:19,890
that's not marked froze and your caller

00:17:17,580 --> 00:17:21,959
function is frozen one of these

00:17:19,890 --> 00:17:23,339
new-style exceptions and we potentially

00:17:21,959 --> 00:17:25,560
could actually give you a compile error

00:17:23,339 --> 00:17:28,170
but the proposal is it will actually go

00:17:25,560 --> 00:17:30,000
into this interoperability mode where it

00:17:28,170 --> 00:17:32,100
will transform these new-style

00:17:30,000 --> 00:17:34,020
exceptions in tirol style and their way

00:17:32,100 --> 00:17:36,720
around again I went to that more

00:17:34,020 --> 00:17:38,330
previously but there is an

00:17:36,720 --> 00:17:44,070
interoperability story there

00:17:38,330 --> 00:17:46,290
so it's coding up a little bit more to

00:17:44,070 --> 00:17:49,740
use him in normal try catch blocks I say

00:17:46,290 --> 00:17:52,380
normal but the catch block again we're

00:17:49,740 --> 00:17:55,350
catching that value type and I you can

00:17:52,380 --> 00:17:56,670
see the type is stood error big part of

00:17:55,350 --> 00:17:57,930
this talk is going to be discussing what

00:17:56,670 --> 00:18:00,990
stood error actually is and how that

00:17:57,930 --> 00:18:04,770
works but for now think of it it's just

00:18:00,990 --> 00:18:08,000
a simple value type see it's got message

00:18:04,770 --> 00:18:10,950
on there but it's incredibly lightweight

00:18:08,000 --> 00:18:13,920
now the next slide I want to really sort

00:18:10,950 --> 00:18:18,240
of try and drill home exactly what's

00:18:13,920 --> 00:18:19,530
going on here or at least as if we need

00:18:18,240 --> 00:18:21,630
to think of everything we just seen as

00:18:19,530 --> 00:18:24,240
being isomorphic to the the still

00:18:21,630 --> 00:18:32,040
expected example just with a lot less

00:18:24,240 --> 00:18:34,200
syntax so the the froze and the the

00:18:32,040 --> 00:18:37,290
return type could be transformed into

00:18:34,200 --> 00:18:39,810
still expected of that type and stood

00:18:37,290 --> 00:18:41,210
error of course the returns like maybe

00:18:39,810 --> 00:18:43,980
void that's fine

00:18:41,210 --> 00:18:46,590
the the fro is the equivalence of

00:18:43,980 --> 00:18:49,950
returning sake first stood make

00:18:46,590 --> 00:18:52,530
unexpected and even that try keyword the

00:18:49,950 --> 00:18:53,880
optional try keyword that some people

00:18:52,530 --> 00:18:56,400
are complaining about as being you know

00:18:53,880 --> 00:19:00,090
free characters too many that's standing

00:18:56,400 --> 00:19:02,460
in for in even in the the best case may

00:19:00,090 --> 00:19:05,010
know tech operators the the and then and

00:19:02,460 --> 00:19:07,170
the transform it's doing a lot of work

00:19:05,010 --> 00:19:10,260
for you in fact we may get all of that

00:19:07,170 --> 00:19:13,140
for free but if you think of them as

00:19:10,260 --> 00:19:14,790
being equivalent and they're not exactly

00:19:13,140 --> 00:19:16,200
equivalent there's some differences but

00:19:14,790 --> 00:19:19,230
conceptually they're doing the same

00:19:16,200 --> 00:19:22,290
thing you can start to see how we get

00:19:19,230 --> 00:19:25,200
the performance benefits and the

00:19:22,290 --> 00:19:27,770
the image size benefits as well as being

00:19:25,200 --> 00:19:32,430
easier to reason about

00:19:27,770 --> 00:19:35,160
alright well go back to our example we

00:19:32,430 --> 00:19:38,120
mentioned this type stood error and this

00:19:35,160 --> 00:19:40,500
is really where the magic happens and

00:19:38,120 --> 00:19:41,970
it's not really being widely discussed

00:19:40,500 --> 00:19:43,860
outside of the committee yet so I

00:19:41,970 --> 00:19:46,170
wondered it'd take a bit of time so he

00:19:43,860 --> 00:19:50,130
drill into what this is how it works and

00:19:46,170 --> 00:19:53,580
why it's actually really useful so

00:19:50,130 --> 00:19:55,170
here's the proposal so p1 zero to eight

00:19:53,580 --> 00:19:57,180
by the way I'm gonna talk about a lot of

00:19:55,170 --> 00:19:59,640
these proposals today there will be

00:19:57,180 --> 00:20:03,300
references at the end so get the wall in

00:19:59,640 --> 00:20:06,600
one place so says it's a status code and

00:20:03,300 --> 00:20:08,760
standard error object and this is for p0

00:20:06,600 --> 00:20:11,760
709 zero overhead deterministic

00:20:08,760 --> 00:20:13,230
exceptions so it's obviously intended to

00:20:11,760 --> 00:20:14,090
be a supporting paper but don't doubt

00:20:13,230 --> 00:20:17,010
that for you

00:20:14,090 --> 00:20:19,170
this paper stands on its own and will be

00:20:17,010 --> 00:20:22,830
really useful even completely separately

00:20:19,170 --> 00:20:26,760
from p0 704 reasons hopefully will

00:20:22,830 --> 00:20:30,540
become clear so what is it proposal

00:20:26,760 --> 00:20:33,750
starts off by saying a proposal for the

00:20:30,540 --> 00:20:37,920
replacement in new code of the system

00:20:33,750 --> 00:20:39,570
header system error with a substantially

00:20:37,920 --> 00:20:42,510
refactored and lighter weight design

00:20:39,570 --> 00:20:44,250
which meets modern C++ design and

00:20:42,510 --> 00:20:46,760
implementation so it's referencing

00:20:44,250 --> 00:20:50,270
something we've already had sister Meera

00:20:46,760 --> 00:20:52,770
who here is familiar with system error

00:20:50,270 --> 00:20:57,000
yep many a few hands always the same

00:20:52,770 --> 00:21:00,300
well we've had this in C++ 11 and it's

00:20:57,000 --> 00:21:01,800
actually already really useful and we

00:21:00,300 --> 00:21:04,110
should be using it more it should be

00:21:01,800 --> 00:21:05,790
greater awareness of it this is just

00:21:04,110 --> 00:21:06,750
fixing some of the deficiencies of it

00:21:05,790 --> 00:21:07,770
we're going to go into what those are

00:21:06,750 --> 00:21:11,540
but first of all I'm going to explain

00:21:07,770 --> 00:21:16,430
what system errors or stood error code

00:21:11,540 --> 00:21:16,430
is the type we're interested in so

00:21:16,790 --> 00:21:22,410
something like a stood error first so

00:21:19,910 --> 00:21:24,510
one thing I need to to clear up some of

00:21:22,410 --> 00:21:26,130
these names are similar it can be

00:21:24,510 --> 00:21:26,490
difficult to remember what we talked

00:21:26,130 --> 00:21:28,350
about

00:21:26,490 --> 00:21:32,670
so stood error is the newly proposed

00:21:28,350 --> 00:21:36,049
time and this is what it is

00:21:32,670 --> 00:21:40,499
hopefully that makes it all clear

00:21:36,049 --> 00:21:42,899
so it's a type def using statement for

00:21:40,499 --> 00:21:44,070
this arid status code arrays system code

00:21:42,899 --> 00:21:47,779
value type so we're going to break that

00:21:44,070 --> 00:21:50,190
up and what it is but before we do that

00:21:47,779 --> 00:21:54,210
before we look into what those are so I

00:21:50,190 --> 00:21:57,299
want to go back to C++ 11 and look at

00:21:54,210 --> 00:21:58,940
stood error code so this is the old one

00:21:57,299 --> 00:22:01,259
the one we currently have in standard

00:21:58,940 --> 00:22:04,639
need to understand this before we can

00:22:01,259 --> 00:22:07,139
understand stood error so what is it

00:22:04,639 --> 00:22:09,419
this is sort of a sketch of what it is

00:22:07,139 --> 00:22:13,139
there's a lot more to it but this is the

00:22:09,419 --> 00:22:14,639
state so just as an integer value and a

00:22:13,139 --> 00:22:19,889
pointer to something called an error

00:22:14,639 --> 00:22:21,600
category that's it so you can already

00:22:19,889 --> 00:22:24,269
see how this is quite lightweight this

00:22:21,600 --> 00:22:25,619
will fit into registers so it's got

00:22:24,269 --> 00:22:28,619
plenty of methods but these are the

00:22:25,619 --> 00:22:30,840
important ones I think there's a there's

00:22:28,619 --> 00:22:33,090
a couple there that are just accesses so

00:22:30,840 --> 00:22:35,580
get in the Intel and get in the error

00:22:33,090 --> 00:22:38,210
category out by reference but it's just

00:22:35,580 --> 00:22:41,029
the same thing really

00:22:38,210 --> 00:22:43,679
but then the other two methods message

00:22:41,029 --> 00:22:44,340
it's returning a string where is that

00:22:43,679 --> 00:22:48,119
coming from

00:22:44,340 --> 00:22:49,850
and be the boolean operator you can

00:22:48,119 --> 00:22:51,809
really guess how that works

00:22:49,850 --> 00:22:54,470
unfortunately you probably guessed wrong

00:22:51,809 --> 00:22:58,289
you'll see why in a moment

00:22:54,470 --> 00:22:59,639
what's his error category most people

00:22:58,289 --> 00:23:00,960
when they try to explain error catch me

00:22:59,639 --> 00:23:04,710
they say it's like a domain of the

00:23:00,960 --> 00:23:06,029
errors which it is in which case why did

00:23:04,710 --> 00:23:09,600
we just call it error domain it would be

00:23:06,029 --> 00:23:11,369
so much easier so anyway the domains are

00:23:09,600 --> 00:23:12,869
just the spaces that these enum living

00:23:11,369 --> 00:23:15,359
don't have to be nums but they usually

00:23:12,869 --> 00:23:18,600
are but this is what will be convertible

00:23:15,359 --> 00:23:21,029
to that integer so the integer value is

00:23:18,600 --> 00:23:23,970
really going to be a an entry in one of

00:23:21,029 --> 00:23:25,169
these enums so there's this one that's

00:23:23,970 --> 00:23:29,100
actually defined in the standard does

00:23:25,169 --> 00:23:30,989
alongside error code which is this C

00:23:29,100 --> 00:23:33,659
enum and these are just all the POSIX

00:23:30,989 --> 00:23:36,239
codes so all the POSIX codes error codes

00:23:33,659 --> 00:23:39,090
are actually in the standard you can use

00:23:36,239 --> 00:23:42,779
them today but you can also define your

00:23:39,090 --> 00:23:45,299
own era categories such as this various

00:23:42,779 --> 00:23:48,450
one up here but if you do that you need

00:23:45,299 --> 00:23:51,299
to define your own era category class

00:23:48,450 --> 00:23:53,970
so it's just a polymorphic class so you

00:23:51,299 --> 00:23:55,499
derive something from era category and

00:23:53,970 --> 00:23:58,919
you have to overload a number of

00:23:55,499 --> 00:24:00,840
virtuals so message there you can see

00:23:58,919 --> 00:24:02,309
how now how it's getting the string out

00:24:00,840 --> 00:24:04,289
it's actually forwarding on to the era

00:24:02,309 --> 00:24:06,779
category the aircraft degree knows how

00:24:04,289 --> 00:24:08,009
to interpret the integer is an enum so

00:24:06,779 --> 00:24:10,529
it can do whatever it needs to do to

00:24:08,009 --> 00:24:13,139
make that into a string we look up table

00:24:10,529 --> 00:24:15,269
switch statement string conversion

00:24:13,139 --> 00:24:16,440
whatever it's entirely up to you that

00:24:15,269 --> 00:24:19,289
you're in control of the era category

00:24:16,440 --> 00:24:21,629
and how that works and then you've got

00:24:19,289 --> 00:24:24,950
these methods called equivalent there's

00:24:21,629 --> 00:24:27,359
a couple of overloads there what they do

00:24:24,950 --> 00:24:28,889
it turns out that when you are dealing

00:24:27,359 --> 00:24:31,679
with error codes from different era

00:24:28,889 --> 00:24:34,049
categories it's really useful to be able

00:24:31,679 --> 00:24:36,359
to compare error codes from different

00:24:34,049 --> 00:24:38,220
error categories for example if you've

00:24:36,359 --> 00:24:39,869
got one of your own custom domain or

00:24:38,220 --> 00:24:43,279
category you might want to compare them

00:24:39,869 --> 00:24:46,470
with error codes in the the POSIX

00:24:43,279 --> 00:24:47,879
category but how does that work

00:24:46,470 --> 00:24:50,369
well that's Beth what you defined in

00:24:47,879 --> 00:24:52,049
these equivalents methods and that

00:24:50,369 --> 00:24:54,119
allows you to do not just one to one but

00:24:52,049 --> 00:24:56,700
one-to-many many-to-many and all have

00:24:54,119 --> 00:24:58,379
lots of gaps whatever makes sense for

00:24:56,700 --> 00:25:02,399
your era category and we usually are

00:24:58,379 --> 00:25:04,529
just comparing to the sea era Canterbury

00:25:02,399 --> 00:25:07,409
whatever makes sense you can do that and

00:25:04,529 --> 00:25:09,029
then you can you can compare areas in

00:25:07,409 --> 00:25:11,489
some custom category that you don't know

00:25:09,029 --> 00:25:13,080
anything about with the era category

00:25:11,489 --> 00:25:14,909
that you do and the chances are it's

00:25:13,080 --> 00:25:18,299
going to work as you expect it's

00:25:14,909 --> 00:25:21,779
actually a really powerful concept what

00:25:18,299 --> 00:25:22,950
we got these overloads so well it turns

00:25:21,779 --> 00:25:24,200
out there's two ways of doing this one

00:25:22,950 --> 00:25:27,509
is where you actually wants to do

00:25:24,200 --> 00:25:29,100
equivalence like here and the other one

00:25:27,509 --> 00:25:32,639
is where you want to do just a direct

00:25:29,100 --> 00:25:33,809
you know bit by bit comparison so if

00:25:32,639 --> 00:25:34,950
there are different categories it's that

00:25:33,809 --> 00:25:38,609
they're not going to compare equal and

00:25:34,950 --> 00:25:41,519
the way that's defined to work in built

00:25:38,609 --> 00:25:44,519
real system is if you have this error

00:25:41,519 --> 00:25:46,489
condition type an error condition is

00:25:44,519 --> 00:25:48,419
basically exactly the same as error code

00:25:46,489 --> 00:25:50,210
it's just a different type for

00:25:48,419 --> 00:25:53,279
overloading purposes that's all it is

00:25:50,210 --> 00:25:54,450
which sounds reasonable and so you

00:25:53,279 --> 00:25:56,580
actually try to use it and it gets very

00:25:54,450 --> 00:25:58,409
confusing in practice so that's one of

00:25:56,580 --> 00:26:00,960
the problems you know why do I have this

00:25:58,409 --> 00:26:05,379
whole separate type just for overloading

00:26:00,960 --> 00:26:08,409
so that's that's really all there is to

00:26:05,379 --> 00:26:11,559
it the error code it's quite

00:26:08,409 --> 00:26:12,789
straightforward I say the fact that so

00:26:11,559 --> 00:26:16,509
many people are not familiar with it I

00:26:12,789 --> 00:26:18,610
think is a little bit sad because this

00:26:16,509 --> 00:26:23,619
is a really useful type hope this could

00:26:18,610 --> 00:26:25,029
become much more useful so here's the

00:26:23,619 --> 00:26:26,440
summary of some of the problems with it

00:26:25,029 --> 00:26:30,159
that we're going to try and so already

00:26:26,440 --> 00:26:32,110
talked about some of them one of them is

00:26:30,159 --> 00:26:35,919
because of the way these error category

00:26:32,110 --> 00:26:37,029
pointers are defined the to compare two

00:26:35,919 --> 00:26:39,340
error categories you have to do it by

00:26:37,029 --> 00:26:41,129
points of value and that means

00:26:39,340 --> 00:26:43,869
essentially they have to be singlet ins

00:26:41,129 --> 00:26:46,720
and in some circumstances I think it's

00:26:43,869 --> 00:26:49,840
basically single the header only

00:26:46,720 --> 00:26:51,730
libraries within a dynamic library tends

00:26:49,840 --> 00:26:53,649
to mean that these Singleton's will have

00:26:51,730 --> 00:26:56,409
different addresses for the same same

00:26:53,649 --> 00:26:59,230
singleton so that breaks down that's a

00:26:56,409 --> 00:27:01,360
problem we mentioned that that message

00:26:59,230 --> 00:27:03,490
returns a string seems fair enough

00:27:01,360 --> 00:27:05,320
no it's a standard site what's the

00:27:03,490 --> 00:27:06,759
problem there but turns out that's

00:27:05,320 --> 00:27:11,519
actually quite a heavyweight dependency

00:27:06,759 --> 00:27:14,769
I pause in often i/o streams locales

00:27:11,519 --> 00:27:18,039
even exceptions which is real shame

00:27:14,769 --> 00:27:20,100
because often this type is used in cases

00:27:18,039 --> 00:27:22,360
where you want to avoid all that stuff

00:27:20,100 --> 00:27:24,509
particularly in embedded and heavily

00:27:22,360 --> 00:27:27,340
constrained systems for example so

00:27:24,509 --> 00:27:29,379
that's a bit of a problem and one of the

00:27:27,340 --> 00:27:32,409
things that the SG 14 study group that's

00:27:29,379 --> 00:27:33,730
raised remember I said that that boolean

00:27:32,409 --> 00:27:36,220
conversion probably doesn't do what you

00:27:33,730 --> 00:27:37,179
think it's actually worse than that it

00:27:36,220 --> 00:27:40,210
will often do what you think you should

00:27:37,179 --> 00:27:43,090
do and then over time viewpoint what is

00:27:40,210 --> 00:27:47,529
defined as doing it's just telling you

00:27:43,090 --> 00:27:51,669
whether the that value which is mapped

00:27:47,529 --> 00:27:53,679
on to one of your enemies is 0 or not so

00:27:51,669 --> 00:27:56,409
depending on your arrow category that

00:27:53,679 --> 00:27:59,019
might mean is not an error or it might

00:27:56,409 --> 00:28:01,179
mean something entirely different it

00:27:59,019 --> 00:28:05,399
depends on the category so it's almost

00:28:01,179 --> 00:28:05,399
completely useless unfortunately

00:28:05,800 --> 00:28:09,920
we mentioned we need that separate our

00:28:07,790 --> 00:28:13,310
condition type for overloading purposes

00:28:09,920 --> 00:28:17,080
for this equivalence which is a bit

00:28:13,310 --> 00:28:19,460
confusing this is all defined in C++ 11

00:28:17,080 --> 00:28:21,290
when we had very minimal concepts for us

00:28:19,460 --> 00:28:26,450
so pretty much none of it is con sex

00:28:21,290 --> 00:28:28,700
bruh it all could be and the the error

00:28:26,450 --> 00:28:31,460
code can only be a integral type let us

00:28:28,700 --> 00:28:33,020
find freedoms but for more general

00:28:31,460 --> 00:28:36,680
solution that could be a bit limiting as

00:28:33,020 --> 00:28:38,330
well and we also mentioned ya the

00:28:36,680 --> 00:28:41,240
categories are actually domains that's

00:28:38,330 --> 00:28:42,740
an easier thing to to teach so these are

00:28:41,240 --> 00:28:44,720
the problems that this paper is going to

00:28:42,740 --> 00:28:48,590
try and address so let's have a look at

00:28:44,720 --> 00:28:52,870
how it does that so here's the main type

00:28:48,590 --> 00:28:56,990
the main template that the the proposal

00:28:52,870 --> 00:28:58,730
proposes surf's latest code so this you

00:28:56,990 --> 00:29:01,340
can see immediately looks very similar

00:28:58,730 --> 00:29:02,900
to error code except it's a template so

00:29:01,340 --> 00:29:06,170
that fixes the problem of it being

00:29:02,900 --> 00:29:07,370
constrained to integral types you can

00:29:06,170 --> 00:29:11,650
also say we fix the problem with the

00:29:07,370 --> 00:29:14,930
naming we now have a status code domain

00:29:11,650 --> 00:29:18,830
instead of category but other than that

00:29:14,930 --> 00:29:23,660
looks pretty similar so let's bring up

00:29:18,830 --> 00:29:25,280
that using alias that you can see we're

00:29:23,660 --> 00:29:27,860
not quite there to matching this up yet

00:29:25,280 --> 00:29:29,330
because we've introduced status code but

00:29:27,860 --> 00:29:31,220
we're actually talking about errored

00:29:29,330 --> 00:29:34,550
status code and the difference is

00:29:31,220 --> 00:29:36,050
actually simply this an arid status code

00:29:34,550 --> 00:29:39,200
is one that's guaranteed to always be

00:29:36,050 --> 00:29:40,100
only an error so it never be success and

00:29:39,200 --> 00:29:43,280
it just enforces that in this

00:29:40,100 --> 00:29:44,930
constructor and that means the boon in

00:29:43,280 --> 00:29:45,860
conversion thing is completely moot in

00:29:44,930 --> 00:29:47,750
fact they take it out the boolean

00:29:45,860 --> 00:29:50,540
conversion though it's just problematic

00:29:47,750 --> 00:29:52,910
but in the case of error codes you want

00:29:50,540 --> 00:29:54,380
them to always represent an error and so

00:29:52,910 --> 00:29:57,320
this guarantees that so that's

00:29:54,380 --> 00:29:59,830
simplifies things a bit I think you've

00:29:57,320 --> 00:30:03,200
got the other bits you got the erased

00:29:59,830 --> 00:30:05,060
system code value type it could probably

00:30:03,200 --> 00:30:08,450
guess that erases some sort of type

00:30:05,060 --> 00:30:12,000
eurasia mechanism and it is but what

00:30:08,450 --> 00:30:16,020
about the system code value type

00:30:12,000 --> 00:30:18,480
well system code body type is in our

00:30:16,020 --> 00:30:20,610
case defined to be something effectively

00:30:18,480 --> 00:30:23,970
like in pointer T they think of it as in

00:30:20,610 --> 00:30:26,790
point a team and being a template type

00:30:23,970 --> 00:30:29,430
to erased you're telling a raised to

00:30:26,790 --> 00:30:32,640
make it storage for its arrays type as

00:30:29,430 --> 00:30:34,320
big as that that's right so setting

00:30:32,640 --> 00:30:37,500
aside memory the size of an in point two

00:30:34,320 --> 00:30:40,170
T to put something into which could be

00:30:37,500 --> 00:30:43,230
an enum integer or of course a pointer

00:30:40,170 --> 00:30:45,360
so that's actually slightly more general

00:30:43,230 --> 00:30:47,400
then then we have before with just the

00:30:45,360 --> 00:30:49,380
integer and actually more useful in that

00:30:47,400 --> 00:30:52,590
case so it's fine for dis stuffing

00:30:49,380 --> 00:30:57,840
integers in logic but pointers in so

00:30:52,590 --> 00:31:01,650
that's good so effectively we can pull

00:30:57,840 --> 00:31:03,840
that template down to this it's a it's

00:31:01,650 --> 00:31:05,640
got the the states code domain and an in

00:31:03,840 --> 00:31:06,690
point two T or something as big as an in

00:31:05,640 --> 00:31:12,840
point to see that we could put up a

00:31:06,690 --> 00:31:15,210
stone into so filling out the the other

00:31:12,840 --> 00:31:18,510
blanks well we mentioned domains in

00:31:15,210 --> 00:31:20,580
alcohol domains what we didn't mention

00:31:18,510 --> 00:31:22,350
is that rather than looking at the the

00:31:20,580 --> 00:31:24,930
pointer Valley is the identity for the

00:31:22,350 --> 00:31:29,460
domains they're actually assigned that

00:31:24,930 --> 00:31:32,550
randomized you in 64 at design-time

00:31:29,460 --> 00:31:34,080
and if you look at the algorithm it's

00:31:32,550 --> 00:31:36,570
pretty much guaranteed to never clash no

00:31:34,080 --> 00:31:37,770
need to worry about that you stick the

00:31:36,570 --> 00:31:39,690
number in and then it's always going to

00:31:37,770 --> 00:31:43,350
be unique we don't need to compare

00:31:39,690 --> 00:31:44,490
pointer values fixes that problem so we

00:31:43,350 --> 00:31:46,880
mentioned the value can be any small

00:31:44,490 --> 00:31:48,810
trivially copyable all movable type

00:31:46,880 --> 00:31:52,950
we'll look at what that means at a

00:31:48,810 --> 00:31:55,770
moment there's no string dependency we

00:31:52,950 --> 00:31:57,960
didn't really look at that this is one

00:31:55,770 --> 00:31:58,830
part of the proposal that i think it's

00:31:57,960 --> 00:32:00,450
going to have a little bit of trouble

00:31:58,830 --> 00:32:02,880
getting through the committee but it's

00:32:00,450 --> 00:32:06,030
currently written it defines its own

00:32:02,880 --> 00:32:08,490
string ref type for the purpose of

00:32:06,030 --> 00:32:09,750
getting rid of this dependency there's

00:32:08,490 --> 00:32:11,160
various ways we can address that and

00:32:09,750 --> 00:32:12,480
hopefully we get something through it it

00:32:11,160 --> 00:32:15,510
doesn't have the stood string dependency

00:32:12,480 --> 00:32:16,950
but that's what it's trying to do it's

00:32:15,510 --> 00:32:18,660
mostly context for now everything that

00:32:16,950 --> 00:32:20,880
could be context for it is so that's

00:32:18,660 --> 00:32:22,530
good as we said be done at the boolean

00:32:20,880 --> 00:32:25,520
conversion we don't need it in our case

00:32:22,530 --> 00:32:29,640
for a purpose in the general case

00:32:25,520 --> 00:32:31,080
you're not fooled by it at least and we

00:32:29,640 --> 00:32:34,740
also removed this need for a separate

00:32:31,080 --> 00:32:37,830
type comparison with the equals operator

00:32:34,740 --> 00:32:40,320
is always equivalents because it turns

00:32:37,830 --> 00:32:43,500
out that's always what we want anyway if

00:32:40,320 --> 00:32:47,190
you do want a bit by bit check you can

00:32:43,500 --> 00:32:49,679
just check the the individual values

00:32:47,190 --> 00:32:53,850
themselves rather than using the equals

00:32:49,679 --> 00:32:55,890
operator so some simple fixes mostly for

00:32:53,850 --> 00:32:58,679
those problems to make a really useful

00:32:55,890 --> 00:33:01,070
type even more useful so I'm actually

00:32:58,679 --> 00:33:04,140
quite excited about this this proposal

00:33:01,070 --> 00:33:08,700
it's digging a bit more into some of

00:33:04,140 --> 00:33:11,640
this so we can say hopefully that this

00:33:08,700 --> 00:33:15,600
type it into two registers because of

00:33:11,640 --> 00:33:18,090
the ways to find I've got this comment

00:33:15,600 --> 00:33:21,299
on here that if move is equal to men

00:33:18,090 --> 00:33:25,130
copy and this is an interesting comment

00:33:21,299 --> 00:33:27,900
because if the compiler can prove that

00:33:25,130 --> 00:33:30,660
moving one of these types could be done

00:33:27,900 --> 00:33:32,640
just by mem copying the bits then

00:33:30,660 --> 00:33:34,740
putting these into radius mean means you

00:33:32,640 --> 00:33:36,210
only have to copy registers around don't

00:33:34,740 --> 00:33:38,010
have to call move constructors or

00:33:36,210 --> 00:33:40,350
anything like that that's quite

00:33:38,010 --> 00:33:42,960
important but because of that type

00:33:40,350 --> 00:33:45,480
erasure especially the compiler can't

00:33:42,960 --> 00:33:49,080
prove that on its own because doesn't

00:33:45,480 --> 00:33:50,520
know what the actual type is gonna be so

00:33:49,080 --> 00:33:54,390
that's where another proposal comes in

00:33:50,520 --> 00:33:57,240
in fact this - this one is a p1 0 to 9

00:33:54,390 --> 00:34:00,960
move relocates and then it's another one

00:33:57,240 --> 00:34:03,299
p1 1 4 for object relocation in terms of

00:34:00,960 --> 00:34:04,559
move + destroy so if I look at them both

00:34:03,299 --> 00:34:06,270
side by side because I think that's the

00:34:04,559 --> 00:34:09,419
most effective way to see what they're

00:34:06,270 --> 00:34:13,020
doing seek you say the first one move

00:34:09,419 --> 00:34:16,710
relocates all it does is defines an

00:34:13,020 --> 00:34:20,700
attribute that indicates whether moving

00:34:16,710 --> 00:34:22,260
that type this annotating is trivial as

00:34:20,700 --> 00:34:24,840
in it can be done just by men copying

00:34:22,260 --> 00:34:29,520
the bits simple as that

00:34:24,840 --> 00:34:32,340
just the attribute where as p1 1 4 4 it

00:34:29,520 --> 00:34:33,690
hasn't actually but it's optional but it

00:34:32,340 --> 00:34:37,379
also has additional things like a

00:34:33,690 --> 00:34:38,929
detection trait it's got this this thing

00:34:37,379 --> 00:34:41,880
where you can

00:34:38,929 --> 00:34:44,010
you can reset the moved from state by

00:34:41,880 --> 00:34:47,700
men copying from a default constructed

00:34:44,010 --> 00:34:49,470
instance which things vary enough but

00:34:47,700 --> 00:34:52,590
that effectively makes this a

00:34:49,470 --> 00:34:54,179
destructive move paper which had a long

00:34:52,590 --> 00:34:57,240
and torturous history going through the

00:34:54,179 --> 00:35:00,930
committee so that's one of the reasons

00:34:57,240 --> 00:35:02,970
that this may get stuck which is a whole

00:35:00,930 --> 00:35:04,500
reason for the first paper if the second

00:35:02,970 --> 00:35:05,790
one doesn't get through we can fall back

00:35:04,500 --> 00:35:07,770
to the first one up you still get what

00:35:05,790 --> 00:35:08,310
we need and there's some other things in

00:35:07,770 --> 00:35:11,070
there as well

00:35:08,310 --> 00:35:12,300
so now gripping some stuff go read the

00:35:11,070 --> 00:35:17,280
paper if you want to find out more say

00:35:12,300 --> 00:35:20,490
there will be links but coming back to

00:35:17,280 --> 00:35:23,640
our example we've discussed now what

00:35:20,490 --> 00:35:26,160
stood error actually is hopefully you

00:35:23,640 --> 00:35:29,070
can see now that this is a really useful

00:35:26,160 --> 00:35:31,590
but simple type that is also incredibly

00:35:29,070 --> 00:35:33,660
lightweight now if you remembered that

00:35:31,590 --> 00:35:37,130
we said that this is effectively

00:35:33,660 --> 00:35:40,260
isomorphic morphic to I stood expected

00:35:37,130 --> 00:35:44,090
or a type and stood error

00:35:40,260 --> 00:35:47,190
I stood error can fit into two registers

00:35:44,090 --> 00:35:49,080
now one advantage of doing this in the

00:35:47,190 --> 00:35:51,420
compiler that we haven't really

00:35:49,080 --> 00:35:55,350
discussed is that we get an additional

00:35:51,420 --> 00:35:56,670
optimization advantage with we've still

00:35:55,350 --> 00:35:59,580
expected there has to be some extra

00:35:56,670 --> 00:36:01,670
value that indicates been aware it's a

00:35:59,580 --> 00:36:04,770
value or an error some discriminator

00:36:01,670 --> 00:36:08,370
when we're just using these static

00:36:04,770 --> 00:36:09,900
exceptions on the return channel the

00:36:08,370 --> 00:36:12,360
compiler knows there's an unused bit in

00:36:09,900 --> 00:36:14,430
one of the registers that it can use as

00:36:12,360 --> 00:36:16,200
a discriminator which means this

00:36:14,430 --> 00:36:19,380
probably takes up no additional overhead

00:36:16,200 --> 00:36:21,060
over just returning the value which is

00:36:19,380 --> 00:36:23,610
actually really interesting depending on

00:36:21,060 --> 00:36:27,330
the size of your your return type of

00:36:23,610 --> 00:36:30,300
course but effectively no overhead in

00:36:27,330 --> 00:36:34,200
size over no error handing not just over

00:36:30,300 --> 00:36:37,710
some other type of air ending so there's

00:36:34,200 --> 00:36:40,020
that and if it is an error you only have

00:36:37,710 --> 00:36:41,640
to copy two registers around so you can

00:36:40,020 --> 00:36:43,290
see how lightweight and performant that

00:36:41,640 --> 00:36:45,450
there should be no there's no

00:36:43,290 --> 00:36:47,250
implementation yet so we haven't

00:36:45,450 --> 00:36:48,690
verified our assumptions about this but

00:36:47,250 --> 00:36:50,250
it looks pretty good

00:36:48,690 --> 00:36:52,230
and in fact

00:36:50,250 --> 00:36:53,730
all of this is effectively what Swift

00:36:52,230 --> 00:36:55,800
does as well it's been doing for about

00:36:53,730 --> 00:36:58,350
four years now and that's been working

00:36:55,800 --> 00:37:00,420
out really great for them doesn't always

00:36:58,350 --> 00:37:01,770
translate the cross languages but I

00:37:00,420 --> 00:37:03,630
think in this case we're close enough

00:37:01,770 --> 00:37:07,620
that we can expect to see the same

00:37:03,630 --> 00:37:09,150
source of their gains so that's why I'm

00:37:07,620 --> 00:37:12,660
really excited about this and how this

00:37:09,150 --> 00:37:15,780
all works let's just summarize the

00:37:12,660 --> 00:37:21,300
proposals who looks at so the top level

00:37:15,780 --> 00:37:22,320
1 p0 709 aka static exceptions hope will

00:37:21,300 --> 00:37:24,780
tell us more about that

00:37:22,320 --> 00:37:27,930
in his keynote or you can read there go

00:37:24,780 --> 00:37:32,250
and watch my previous talk the status

00:37:27,930 --> 00:37:37,280
code proposal p10 - 8 AKA stood era

00:37:32,250 --> 00:37:39,330
I learned the to move relocate papers

00:37:37,280 --> 00:37:44,100
but we've also talked about still

00:37:39,330 --> 00:37:46,200
expected p0 free - free and the melodic

00:37:44,100 --> 00:37:47,610
operations player proposal say that's

00:37:46,200 --> 00:37:50,070
just for optional at the moment there

00:37:47,610 --> 00:37:52,980
should be a parallel one for stood

00:37:50,070 --> 00:37:55,020
expected when that comes along and one

00:37:52,980 --> 00:37:58,680
we didn't mention and not just because

00:37:55,020 --> 00:38:00,870
it was taken out contracts also play

00:37:58,680 --> 00:38:03,450
into this and the reason I say that is

00:38:00,870 --> 00:38:05,220
because turns out that a lot of places

00:38:03,450 --> 00:38:08,430
in the standard library that currently

00:38:05,220 --> 00:38:11,280
use exceptions it's being decided should

00:38:08,430 --> 00:38:13,890
actually be contracts and if we make

00:38:11,280 --> 00:38:15,990
that change the three few places left in

00:38:13,890 --> 00:38:17,310
the standard library but the four

00:38:15,990 --> 00:38:19,860
exceptions the most of those are

00:38:17,310 --> 00:38:23,700
allocation failures and there's another

00:38:19,860 --> 00:38:25,770
optional part of p0 709 is getting a lot

00:38:23,700 --> 00:38:27,270
of attention where we're saying that

00:38:25,770 --> 00:38:29,790
actually allocation failure probably

00:38:27,270 --> 00:38:31,410
shouldn't be an exception either we're

00:38:29,790 --> 00:38:32,970
not going to go into this now I talked

00:38:31,410 --> 00:38:36,480
about that before I think herb might

00:38:32,970 --> 00:38:39,090
talk about it as well so contracts are

00:38:36,480 --> 00:38:42,780
that the big missing piece here because

00:38:39,090 --> 00:38:44,910
if we take out all those uses of

00:38:42,780 --> 00:38:46,650
exceptions from the standard there's

00:38:44,910 --> 00:38:49,370
very little left well if you make them

00:38:46,650 --> 00:38:51,600
this new new style aesthetic exceptions

00:38:49,370 --> 00:38:54,780
then I think being able to see in the

00:38:51,600 --> 00:38:56,730
code the the flow of exceptions using

00:38:54,780 --> 00:39:00,150
that optional try keyword suddenly

00:38:56,730 --> 00:39:01,350
becomes much more compelling and I think

00:39:00,150 --> 00:39:02,860
you need to see in that context to

00:39:01,350 --> 00:39:05,980
really appreciate that

00:39:02,860 --> 00:39:07,720
so honorable mentions contracts a shame

00:39:05,980 --> 00:39:09,670
we didn't make it into C++ when Z I

00:39:07,720 --> 00:39:11,800
think for the right reasons that's

00:39:09,670 --> 00:39:14,290
another story hopefully we should get it

00:39:11,800 --> 00:39:20,110
in time for taking part in this this

00:39:14,290 --> 00:39:23,140
thing and that actually seems to be will

00:39:20,110 --> 00:39:25,150
add to say I did mention that all the

00:39:23,140 --> 00:39:27,100
references for all those proposals and

00:39:25,150 --> 00:39:29,860
and other and other things are on my web

00:39:27,100 --> 00:39:33,400
site level of indirection comm slash

00:39:29,860 --> 00:39:35,230
Rhett's slash donned HTML if you can't

00:39:33,400 --> 00:39:38,290
remember that I've also got extra level

00:39:35,230 --> 00:39:40,810
of indirection that redirects there or

00:39:38,290 --> 00:39:41,930
you can find on Twitter and thank you

00:39:40,810 --> 00:39:48,830
very much

00:39:41,930 --> 00:39:50,820
[Applause]

00:39:48,830 --> 00:39:52,320
and actually finish much earlier than

00:39:50,820 --> 00:40:01,290
usual makes me think I missed something

00:39:52,320 --> 00:40:02,130
so any questions hi so thank you for

00:40:01,290 --> 00:40:05,040
your great talk

00:40:02,130 --> 00:40:08,010
I was just wondering so what is this why

00:40:05,040 --> 00:40:10,470
is it that in pointer in Twitter so

00:40:08,010 --> 00:40:13,140
what's the pointer used for what can you

00:40:10,470 --> 00:40:16,800
use it I I did miss something thank you

00:40:13,140 --> 00:40:18,090
so you are might people I repeat the

00:40:16,800 --> 00:40:20,340
question just make sure I've understood

00:40:18,090 --> 00:40:22,320
it you want you to know why it was

00:40:20,340 --> 00:40:26,070
significant that the potato came in

00:40:22,320 --> 00:40:28,050
pointer whereas it wasn't previously so

00:40:26,070 --> 00:40:30,540
in it's not guaranteed to be able to

00:40:28,050 --> 00:40:31,590
hold pointers within point series and a

00:40:30,540 --> 00:40:34,380
reason that's significant for our

00:40:31,590 --> 00:40:37,050
purposes it's because what we talked

00:40:34,380 --> 00:40:39,450
about just conveying enums instead our

00:40:37,050 --> 00:40:41,460
code for interoperability with

00:40:39,450 --> 00:40:45,330
exceptions it can hold an exception

00:40:41,460 --> 00:40:46,890
pointer so if an a static exceptions

00:40:45,330 --> 00:40:50,010
function it calls something that will

00:40:46,890 --> 00:40:51,960
throw a dynamic exception it crafts that

00:40:50,010 --> 00:40:54,210
in an exception pointer sticks that

00:40:51,960 --> 00:40:56,220
inside an error code and propagates it

00:40:54,210 --> 00:40:58,740
along or you could also use it for your

00:40:56,220 --> 00:40:59,880
own sort of arbitrary payloads but at

00:40:58,740 --> 00:41:01,830
that point you're paying the cost of

00:40:59,880 --> 00:41:05,160
course of you know they're done in the

00:41:01,830 --> 00:41:06,360
calculation but you don't have to so by

00:41:05,160 --> 00:41:08,400
default we're just dealing with Vera

00:41:06,360 --> 00:41:11,040
codes but you can I put arbitrary sized

00:41:08,400 --> 00:41:12,930
objects in there as well by pointer but

00:41:11,040 --> 00:41:16,380
but how is then going with like who is

00:41:12,930 --> 00:41:20,150
the allocating this thing the allocation

00:41:16,380 --> 00:41:22,590
is a topic for another talk I expect I

00:41:20,150 --> 00:41:24,720
don't imagine it's something to do with

00:41:22,590 --> 00:41:28,740
their domain but um I don't know the

00:41:24,720 --> 00:41:31,020
answer to that one good question okay so

00:41:28,740 --> 00:41:33,780
I have two questions the first is that

00:41:31,020 --> 00:41:36,570
this new syntax for trying catch looks

00:41:33,780 --> 00:41:40,020
very similar to I hear you

00:41:36,570 --> 00:41:43,080
yeah so this new syntax for try and

00:41:40,020 --> 00:41:44,780
catch looks so similar to the old one it

00:41:43,080 --> 00:41:47,700
almost looks like we could just

00:41:44,780 --> 00:41:49,740
translate our programs the old programs

00:41:47,700 --> 00:41:52,320
that use dynamic exceptions to to this

00:41:49,740 --> 00:41:54,720
new way is that the intention or is

00:41:52,320 --> 00:41:57,630
there's some work being done to to make

00:41:54,720 --> 00:41:59,609
our programs translatable to the society

00:41:57,630 --> 00:42:00,779
exceptions

00:41:59,609 --> 00:42:02,849
and still struggle to everything you

00:42:00,779 --> 00:42:04,859
said but I think you're asking whether

00:42:02,849 --> 00:42:06,269
because the try-catch blocks are

00:42:04,859 --> 00:42:08,309
basically the same whether we could just

00:42:06,269 --> 00:42:10,229
effectively have a compiler mode where

00:42:08,309 --> 00:42:12,509
it makes old-style exceptions behavior

00:42:10,229 --> 00:42:14,369
out the new ones and and that has been

00:42:12,509 --> 00:42:16,979
talked about and that may be something

00:42:14,369 --> 00:42:19,200
in it but I think they they work

00:42:16,979 --> 00:42:21,479
fundamentally differently enough that it

00:42:19,200 --> 00:42:24,599
is worth having you know being explicit

00:42:21,479 --> 00:42:26,729
in the code about it but but that's not

00:42:24,599 --> 00:42:29,099
completely given that there may be maybe

00:42:26,729 --> 00:42:31,170
a way to do that you take your two

00:42:29,099 --> 00:42:33,809
questions okay so the other question is

00:42:31,170 --> 00:42:36,569
that after andre stocks and and

00:42:33,809 --> 00:42:39,930
chandler's zero cost abstraction is it's

00:42:36,569 --> 00:42:41,849
kind of a you know bold claim so do you

00:42:39,930 --> 00:42:44,599
really think this is a zero cost

00:42:41,849 --> 00:42:47,729
abstraction or a low cost abstraction

00:42:44,599 --> 00:42:48,930
well this has been it's being said that

00:42:47,729 --> 00:42:51,029
this mayor should be a negative cost

00:42:48,930 --> 00:42:53,519
obstruction but it all depends what

00:42:51,029 --> 00:42:56,609
you're measuring against the same

00:42:53,519 --> 00:42:58,499
compared to nowhere a handling if you're

00:42:56,609 --> 00:43:00,539
adding error handling no matter how

00:42:58,499 --> 00:43:02,880
lightweight that's gonna have some cost

00:43:00,539 --> 00:43:06,059
but compared to all the mechanisms in

00:43:02,880 --> 00:43:07,739
common use today I think the only thing

00:43:06,059 --> 00:43:09,599
that could possibly beat it would just

00:43:07,739 --> 00:43:12,390
be return codes but then you have

00:43:09,599 --> 00:43:13,979
there's other trade-offs but it may even

00:43:12,390 --> 00:43:17,160
be better than return codes depending on

00:43:13,979 --> 00:43:21,079
how the optimizer works so I'm not sure

00:43:17,160 --> 00:43:23,099
I entirely agree with the premise but

00:43:21,079 --> 00:43:24,599
again until we actually get an

00:43:23,099 --> 00:43:27,449
implementation and could measure it in

00:43:24,599 --> 00:43:29,819
in practice it's premature to say just

00:43:27,449 --> 00:43:35,099
how much of a an overhead if any there

00:43:29,819 --> 00:43:37,440
is okay thank you hi thanks for a talk I

00:43:35,099 --> 00:43:40,319
also have two questions the first one is

00:43:37,440 --> 00:43:41,789
one of the overheads of exceptions

00:43:40,319 --> 00:43:45,029
wasn't just its runtime but it's

00:43:41,789 --> 00:43:47,849
verbosity when you when you want to

00:43:45,029 --> 00:43:50,430
inspect the call itself directly at the

00:43:47,849 --> 00:43:53,160
place of the call could it be possible

00:43:50,430 --> 00:43:55,589
to where to add to one of the proposals

00:43:53,160 --> 00:43:57,869
that you can do an if on the try

00:43:55,589 --> 00:44:01,859
function instead of doing the trying

00:43:57,869 --> 00:44:03,749
catch maybe even without an additional

00:44:01,859 --> 00:44:06,630
keyword to the language you understand

00:44:03,749 --> 00:44:09,599
why I'm asking because we then we really

00:44:06,630 --> 00:44:13,110
have it all we wouldn't have the

00:44:09,599 --> 00:44:16,350
velocity of the trycatch around

00:44:13,110 --> 00:44:17,760
call yeah I think there are definitely

00:44:16,350 --> 00:44:20,970
cases where you want to do the the

00:44:17,760 --> 00:44:22,620
so-called local handling and in fact in

00:44:20,970 --> 00:44:26,040
in Swift you could do exactly that there

00:44:22,620 --> 00:44:28,230
are extra operators do question mark

00:44:26,040 --> 00:44:30,260
operator effectively converts it into an

00:44:28,230 --> 00:44:32,760
optional so then you can do an F on that

00:44:30,260 --> 00:44:35,430
and there's a few other ways you can do

00:44:32,760 --> 00:44:40,170
it in Swift that's not currently in the

00:44:35,430 --> 00:44:41,850
proposal as written now and that's

00:44:40,170 --> 00:44:44,430
something I would like to see so I might

00:44:41,850 --> 00:44:48,240
even write something to to enter that

00:44:44,430 --> 00:44:49,500
myself later there's definitely people

00:44:48,240 --> 00:44:51,510
that have been asking about that that's

00:44:49,500 --> 00:44:54,270
one of the most common questions I get

00:44:51,510 --> 00:44:57,450
so I do hope to see it I don't see any

00:44:54,270 --> 00:44:59,550
reason why that couldn't be easy to put

00:44:57,450 --> 00:45:02,010
in but it's not in the proposal is it

00:44:59,550 --> 00:45:04,170
stands now okay and the second question

00:45:02,010 --> 00:45:11,550
is that that domain thingy that that

00:45:04,170 --> 00:45:14,970
pointer I expect that's also for more

00:45:11,550 --> 00:45:17,940
polymorphic class so we do have virtual

00:45:14,970 --> 00:45:24,900
functions in RTI and all that ugliness

00:45:17,940 --> 00:45:28,140
with it so it's not so free maybe also

00:45:24,900 --> 00:45:31,710
in addition to to to the to the proposal

00:45:28,140 --> 00:45:33,960
that somehow even even if our TTI is

00:45:31,710 --> 00:45:37,440
using the program I guess nobody cares

00:45:33,960 --> 00:45:39,810
about will do will use dynamic casts on

00:45:37,440 --> 00:45:42,870
K on domains or really some categories

00:45:39,810 --> 00:45:44,610
so as to force a mandate in the stander

00:45:42,870 --> 00:45:47,010
standard that we don't get those records

00:45:44,610 --> 00:45:49,200
in our parent binary not only for a

00:45:47,010 --> 00:45:52,530
binary size maybe I I see but don't want

00:45:49,200 --> 00:45:56,220
and any end-user inspecting the names of

00:45:52,530 --> 00:45:58,530
my types and also I think the problem

00:45:56,220 --> 00:46:03,840
was with the error code or the

00:45:58,530 --> 00:46:06,420
categories was that we in today's world

00:46:03,840 --> 00:46:08,010
we still still often have to link

00:46:06,420 --> 00:46:10,350
statically with the runtime on Android

00:46:08,010 --> 00:46:13,500
for example or in Windows or when you

00:46:10,350 --> 00:46:16,140
build force or Linux is like sent OS and

00:46:13,500 --> 00:46:18,210
then you get all the categories because

00:46:16,140 --> 00:46:22,890
they're Singleton's inside your band

00:46:18,210 --> 00:46:26,240
binary so somehow tweak the language of

00:46:22,890 --> 00:46:27,950
the proposals to force the vendors

00:46:26,240 --> 00:46:30,080
not to leave it for the quality of

00:46:27,950 --> 00:46:32,630
implementation but to force them that

00:46:30,080 --> 00:46:35,650
you don't pay for what you don't use you

00:46:32,630 --> 00:46:35,650
understand my question

00:46:35,859 --> 00:46:40,400
completely the second part but distress

00:46:38,630 --> 00:46:42,920
in the first part first I think you sort

00:46:40,400 --> 00:46:44,990
of answer during question that that

00:46:42,920 --> 00:46:46,339
there is some overhead potentially with

00:46:44,990 --> 00:46:49,070
the virtual functions but you only pay

00:46:46,339 --> 00:46:51,109
for them if you use them I mean you

00:46:49,070 --> 00:46:53,869
would only need them if you want to

00:46:51,109 --> 00:46:55,220
convert vieira to a string or if you

00:46:53,869 --> 00:46:57,200
want to do an equivalence comparison

00:46:55,220 --> 00:47:01,040
across domains otherwise you can just

00:46:57,200 --> 00:47:03,410
compare the the raw integer Eriko

00:47:01,040 --> 00:47:06,920
directly without the cost of the version

00:47:03,410 --> 00:47:09,170
like that so yeah I think but as soon as

00:47:06,920 --> 00:47:11,599
it's inside your program even if you

00:47:09,170 --> 00:47:13,339
don't call the virtual function the RTI

00:47:11,599 --> 00:47:15,680
data will be placed in your binary

00:47:13,339 --> 00:47:19,010
that's what I'm one of the things that I

00:47:15,680 --> 00:47:22,280
said if we could somehow force the

00:47:19,010 --> 00:47:24,920
compiler or or demos of the STL standard

00:47:22,280 --> 00:47:28,369
but allow at least allows or forces

00:47:24,920 --> 00:47:32,230
their vendors so that our TTI data isn't

00:47:28,369 --> 00:47:34,700
generated for for the domain classes

00:47:32,230 --> 00:47:37,970
just something to think about maybe yeah

00:47:34,700 --> 00:47:40,640
and also so that they can remove the the

00:47:37,970 --> 00:47:44,089
unused domains from from from your

00:47:40,640 --> 00:47:45,830
binary okay so think understand what

00:47:44,089 --> 00:47:49,730
you're saying now and we'll think about

00:47:45,830 --> 00:47:51,770
that small hey could you go back to the

00:47:49,730 --> 00:47:53,690
slide with the example on it with the

00:47:51,770 --> 00:47:58,910
bull sorry to the slide with the final

00:47:53,690 --> 00:48:00,800
example on it this one yeah so this like

00:47:58,910 --> 00:48:02,810
it looks really good but one problem I

00:48:00,800 --> 00:48:04,910
have with the declaration of parse in

00:48:02,810 --> 00:48:07,520
there is that I can't tell what type of

00:48:04,910 --> 00:48:08,990
error it throws it's like if I'm gonna

00:48:07,520 --> 00:48:10,609
define my own functions I might want to

00:48:08,990 --> 00:48:13,609
throw my own error categories is there

00:48:10,609 --> 00:48:15,680
been any thought to adding to the throws

00:48:13,609 --> 00:48:17,420
declaration something like the old throw

00:48:15,680 --> 00:48:20,180
declarations where you say I throw

00:48:17,420 --> 00:48:23,500
potentially these types of exceptions so

00:48:20,180 --> 00:48:26,150
where is the old fro declaration today

00:48:23,500 --> 00:48:26,990
Deden got but that sort of tells you

00:48:26,150 --> 00:48:29,450
everything you need to know everything

00:48:26,990 --> 00:48:31,609
well so then you're like I have no way

00:48:29,450 --> 00:48:33,140
to tell what type of errors this could

00:48:31,609 --> 00:48:35,089
know often we throw right is there

00:48:33,140 --> 00:48:39,030
anything I know exactly what you're

00:48:35,089 --> 00:48:42,120
asking for and it does amount to

00:48:39,030 --> 00:48:44,330
checked exceptions in the sense of

00:48:42,120 --> 00:48:47,580
specifying the type of an exception

00:48:44,330 --> 00:48:49,290
which you know obviously we didn't get

00:48:47,580 --> 00:48:52,440
very far we've in C++ they ran with it

00:48:49,290 --> 00:48:53,970
more in Java and then everybody stopped

00:48:52,440 --> 00:48:55,500
using it well except for a few people

00:48:53,970 --> 00:48:57,300
who said that that's exactly what they

00:48:55,500 --> 00:48:58,440
want and that's the trouble it's a small

00:48:57,300 --> 00:49:01,980
group of people that would benefit from

00:48:58,440 --> 00:49:05,010
it they can still use returns have stood

00:49:01,980 --> 00:49:07,860
expected in that case whereas here we've

00:49:05,010 --> 00:49:09,570
decided to optimize for the case where

00:49:07,860 --> 00:49:11,250
you just want to know whether and except

00:49:09,570 --> 00:49:13,170
there an exception could be thrown or

00:49:11,250 --> 00:49:16,440
not and then you can deal with the

00:49:13,170 --> 00:49:17,820
actual exception at runtime there was an

00:49:16,440 --> 00:49:20,640
earlier version of the proposal that

00:49:17,820 --> 00:49:23,820
said maybe we have froze T and that was

00:49:20,640 --> 00:49:25,800
voted down for these reasons has been

00:49:23,820 --> 00:49:29,460
considered thank you that's that's the

00:49:25,800 --> 00:49:31,370
reasoning why don't we there's still

00:49:29,460 --> 00:49:34,380
time to change our minds

00:49:31,370 --> 00:49:36,300
um you mentioned earlier previous talk

00:49:34,380 --> 00:49:38,970
and I missed that what that's called

00:49:36,300 --> 00:49:40,620
optional it's not a failure but those

00:49:38,970 --> 00:49:41,970
references on my web site that I

00:49:40,620 --> 00:49:46,850
mentioned that there's salt in there as

00:49:41,970 --> 00:49:52,830
well okay and also that trailing throws

00:49:46,850 --> 00:49:55,290
keyword you mentioned the optional try

00:49:52,830 --> 00:49:56,700
keyword you can put before calling a

00:49:55,290 --> 00:50:01,350
function that has throws at the end of

00:49:56,700 --> 00:50:02,640
it is the idea such that like a static

00:50:01,350 --> 00:50:04,230
analyzer it could recognize all the

00:50:02,640 --> 00:50:06,930
places where tried doesn't show up after

00:50:04,230 --> 00:50:08,610
functions qualifier throws Multan that

00:50:06,930 --> 00:50:11,580
would be the compiler put in full set

00:50:08,610 --> 00:50:13,890
so assuming so it's optional in the

00:50:11,580 --> 00:50:15,510
proposal as in we don't have to

00:50:13,890 --> 00:50:17,610
implement it but if we do it will be

00:50:15,510 --> 00:50:19,860
that if you miss that try keyword there

00:50:17,610 --> 00:50:21,450
and you called something that was

00:50:19,860 --> 00:50:23,400
froggies it's good point of us say no

00:50:21,450 --> 00:50:24,840
you can't do that is that specifically

00:50:23,400 --> 00:50:29,220
because you in serve and no accept

00:50:24,840 --> 00:50:31,890
function yes except sorry this is the

00:50:29,220 --> 00:50:33,900
wrong example in a function Marx froze

00:50:31,890 --> 00:50:35,130
if you called something else that froze

00:50:33,900 --> 00:50:40,880
and you didn't put the try keyword

00:50:35,130 --> 00:50:40,880
that's the compiler error okay thank you

00:50:42,870 --> 00:50:48,370
so in a couple of days it's going to be

00:50:45,460 --> 00:50:52,030
Monday and we'll be back at editing our

00:50:48,370 --> 00:50:53,560
code I guess my question is do you have

00:50:52,030 --> 00:50:55,960
any recommendations for what we should

00:50:53,560 --> 00:50:56,560
be doing now given that these things are

00:50:55,960 --> 00:51:00,000
coming

00:50:56,560 --> 00:51:02,950
so perhaps specifically is it worth

00:51:00,000 --> 00:51:04,630
re-engineering while taking exceptions

00:51:02,950 --> 00:51:07,600
that we're throwing now and replacing

00:51:04,630 --> 00:51:10,000
them with C++ 11 facilities because that

00:51:07,600 --> 00:51:11,650
might perhaps be closer to what's coming

00:51:10,000 --> 00:51:15,310
and then the eventual transition will be

00:51:11,650 --> 00:51:18,820
easier so I think the first step is to

00:51:15,310 --> 00:51:21,310
be aware of what's available so raising

00:51:18,820 --> 00:51:23,380
awareness of stood error code is good

00:51:21,310 --> 00:51:24,970
but doesn't mean that all cases they're

00:51:23,380 --> 00:51:26,770
going to be appropriate there's no

00:51:24,970 --> 00:51:28,600
one-size-fits-all currently that's what

00:51:26,770 --> 00:51:30,430
we're hoping this is going to be we're

00:51:28,600 --> 00:51:31,480
not quite there yet but the other thing

00:51:30,430 --> 00:51:35,110
I hadn't mentioned is another

00:51:31,480 --> 00:51:36,670
alternative is boost outcome so boost

00:51:35,110 --> 00:51:38,410
outcome is it's a bit like still

00:51:36,670 --> 00:51:41,590
expected but it's actually much closer

00:51:38,410 --> 00:51:43,840
to to this proposal implemented as a

00:51:41,590 --> 00:51:45,880
library so it's got some extra macros

00:51:43,840 --> 00:51:49,660
for handing the effective the try

00:51:45,880 --> 00:51:51,130
keyword and it's also got some extra

00:51:49,660 --> 00:51:52,720
performance tweaks to make it more like

00:51:51,130 --> 00:51:54,370
what we've been talking about here so

00:51:52,720 --> 00:51:58,420
here it'll get as close as possible to

00:51:54,370 --> 00:52:01,990
to p0 709 today first of all you Swift

00:51:58,420 --> 00:52:04,300
but if you have to use C++ you at least

00:52:01,990 --> 00:52:06,460
try boost outcome it's it's not perfect

00:52:04,300 --> 00:52:08,140
that's another option but you know don't

00:52:06,460 --> 00:52:09,610
shy away from exceptions where they're

00:52:08,140 --> 00:52:11,470
appropriate and you don't mind the cost

00:52:09,610 --> 00:52:12,910
because that's still the primary

00:52:11,470 --> 00:52:18,430
recommended way of doing error handling

00:52:12,910 --> 00:52:19,090
you see class posture at the moment one

00:52:18,430 --> 00:52:22,720
more question

00:52:19,090 --> 00:52:25,990
I just know that we're catching here a

00:52:22,720 --> 00:52:27,790
specific time distr there yes but we're

00:52:25,990 --> 00:52:30,810
doing all this type eurasia with domains

00:52:27,790 --> 00:52:33,550
and virtual functions and all that isn't

00:52:30,810 --> 00:52:35,920
isn't that the case that then the only

00:52:33,550 --> 00:52:37,630
thing that we can catch is - there why

00:52:35,920 --> 00:52:40,480
why do we have even have to type them or

00:52:37,630 --> 00:52:42,490
could it be that we could throw and

00:52:40,480 --> 00:52:44,410
catch in this new mechanism something

00:52:42,490 --> 00:52:46,840
else that's - there that doesn't have

00:52:44,410 --> 00:52:50,070
these domains and type ratios and all

00:52:46,840 --> 00:52:54,000
that yes - pass - that one is that

00:52:50,070 --> 00:52:56,790
because we simply can interoperate we've

00:52:54,000 --> 00:52:59,609
you know today's dynamic exceptions you

00:52:56,790 --> 00:53:01,650
can have calls to two functions of made

00:52:59,609 --> 00:53:03,180
fro dynamic exception you can have extra

00:53:01,650 --> 00:53:04,380
catch blocks that catch those exceptions

00:53:03,180 --> 00:53:07,710
as well so we need to distinguish

00:53:04,380 --> 00:53:09,000
between them get maybe a maybe an empty

00:53:07,710 --> 00:53:11,760
cache block would be sufficient but then

00:53:09,000 --> 00:53:15,690
you've got to have a an undeclared name

00:53:11,760 --> 00:53:17,849
I think this is this is reasonable but

00:53:15,690 --> 00:53:20,160
because this is the value and its value

00:53:17,849 --> 00:53:22,500
that indicates what the error is for our

00:53:20,160 --> 00:53:25,800
purposes bernini the single type and we

00:53:22,500 --> 00:53:27,990
will typically do a switch or a series

00:53:25,800 --> 00:53:30,210
of events which I think you need to do

00:53:27,990 --> 00:53:32,180
the equivalence I didn't show that in

00:53:30,210 --> 00:53:34,830
there because I stood a bit in flux but

00:53:32,180 --> 00:53:37,520
you do a runtime check of this specific

00:53:34,830 --> 00:53:39,930
era type we've been the cache block

00:53:37,520 --> 00:53:41,640
maybe will evolve that actually being

00:53:39,930 --> 00:53:44,480
able to catch the specific error value I

00:53:41,640 --> 00:53:47,160
haven't seen that proposed yet so I mean

00:53:44,480 --> 00:53:49,859
when we eventually get rid of the Dayman

00:53:47,160 --> 00:53:51,780
dynamic exceptions theoretically it

00:53:49,859 --> 00:53:54,690
could just say catch air without this

00:53:51,780 --> 00:53:58,800
tener right because it will always be

00:53:54,690 --> 00:54:00,480
that type so if you if you're

00:53:58,800 --> 00:54:01,800
interpreting with dynamic exceptions you

00:54:00,480 --> 00:54:04,109
would have additional catch yes what I'm

00:54:01,800 --> 00:54:06,599
saying if we if we when we get to either

00:54:04,109 --> 00:54:09,780
hopefully dynamic exceptions then all

00:54:06,599 --> 00:54:11,099
that will be left is there there

00:54:09,780 --> 00:54:13,619
wouldn't there will not be a possibility

00:54:11,099 --> 00:54:18,089
to throw anything else other than right

00:54:13,619 --> 00:54:19,470
just say just say yeah maybe but I think

00:54:18,089 --> 00:54:21,270
we'd need to actually get there first

00:54:19,470 --> 00:54:23,460
and we're going to have existing

00:54:21,270 --> 00:54:28,290
exceptions for many years to come so

00:54:23,460 --> 00:54:30,330
maybe C++ 33 or something okay

00:54:28,290 --> 00:54:33,060
this first I understand in languages

00:54:30,330 --> 00:54:36,119
like Swift the e type is something that

00:54:33,060 --> 00:54:40,080
the user can define also right so in the

00:54:36,119 --> 00:54:42,810
result there's DVD Y was not chosen

00:54:40,080 --> 00:54:43,890
those simple spots so if I got your

00:54:42,810 --> 00:54:46,500
question right thing that's equivalent

00:54:43,890 --> 00:54:52,950
to the one we had earlier where we might

00:54:46,500 --> 00:54:55,320
want to specify different arrow type the

00:54:52,950 --> 00:54:57,089
proposal as it is you've taken the view

00:54:55,320 --> 00:54:59,339
that you know checked exceptions with a

00:54:57,089 --> 00:55:02,250
failed experiment what we really want to

00:54:59,339 --> 00:55:03,720
know is that an you know an error can be

00:55:02,250 --> 00:55:06,089
propagated and then we'll deal with very

00:55:03,720 --> 00:55:07,349
runtime that is a trade-off and there

00:55:06,089 --> 00:55:08,210
are definitely cases where you prefer

00:55:07,349 --> 00:55:11,520
that

00:55:08,210 --> 00:55:14,370
more explicit typing and in that those

00:55:11,520 --> 00:55:15,450
cases you can still return to expect it

00:55:14,370 --> 00:55:18,030
or you will be able to forget the

00:55:15,450 --> 00:55:20,400
proposal or you can roll your own of

00:55:18,030 --> 00:55:22,530
course so you do have the choice but for

00:55:20,400 --> 00:55:25,230
most people I think this is the right

00:55:22,530 --> 00:55:27,300
default so that's why we've optimized in

00:55:25,230 --> 00:55:33,630
tax for for that rather than for the the

00:55:27,300 --> 00:55:35,070
more verbose form thanks for the talk so

00:55:33,630 --> 00:55:37,350
I'm very excited about this somebody

00:55:35,070 --> 00:55:39,480
mentioned that they're gonna go to work

00:55:37,350 --> 00:55:42,390
on Monday and then modify their code

00:55:39,480 --> 00:55:46,440
again is there anything I and the rest

00:55:42,390 --> 00:55:50,340
of my team can do to get this in 23 like

00:55:46,440 --> 00:55:55,050
for sure because we like we do embedded

00:55:50,340 --> 00:55:58,560
stuff in controversial if you flash mob

00:55:55,050 --> 00:56:02,820
the Stennis committee meetings and you

00:55:58,560 --> 00:56:04,950
know stuff develop no I think just I

00:56:02,820 --> 00:56:06,420
mean raising awareness in the community

00:56:04,950 --> 00:56:11,040
of where we're going so we get people

00:56:06,420 --> 00:56:12,060
talking about it hopefully we'll make it

00:56:11,040 --> 00:56:15,150
obvious that people are taking

00:56:12,060 --> 00:56:17,730
importance people and that tends to give

00:56:15,150 --> 00:56:21,630
things a greater priority awesome

00:56:17,730 --> 00:56:22,260
thank you I think this might be to be

00:56:21,630 --> 00:56:26,220
the last question

00:56:22,260 --> 00:56:28,470
maybe it kind of looks that if we didn't

00:56:26,220 --> 00:56:30,750
have this optional try keywords they

00:56:28,470 --> 00:56:33,240
want this option in the proposal then

00:56:30,750 --> 00:56:37,050
this entire example would be very

00:56:33,240 --> 00:56:39,810
similar to if we if we didn't track that

00:56:37,050 --> 00:56:41,190
pros the trailing froze it would just

00:56:39,810 --> 00:56:44,010
throw them and an Emmy exception right

00:56:41,190 --> 00:56:45,750
and you wouldn't know it it almost it

00:56:44,010 --> 00:56:48,420
looks very similar to dynamic exceptions

00:56:45,750 --> 00:56:50,700
and it seems likely to be easy to

00:56:48,420 --> 00:56:53,370
mistake by mistake right the dynamic

00:56:50,700 --> 00:56:57,060
exception instead of a static one that

00:56:53,370 --> 00:57:00,570
is very good point that the additional

00:56:57,060 --> 00:57:01,830
reason that the try keyword is good is

00:57:00,570 --> 00:57:04,110
it actually helps you to distinguish

00:57:01,830 --> 00:57:06,300
between this form of exceptions and

00:57:04,110 --> 00:57:07,530
dynamic exceptions I'll have to raise

00:57:06,300 --> 00:57:10,250
that one next time this comes up in the

00:57:07,530 --> 00:57:10,250
committee thank you

00:57:10,450 --> 00:57:16,010
one minute so in the standard all the

00:57:14,690 --> 00:57:17,450
exception set it throw inherits from

00:57:16,010 --> 00:57:19,460
standard exception and it's generally

00:57:17,450 --> 00:57:20,900
like the practice is have all of your

00:57:19,460 --> 00:57:23,000
exceptions inherit from stood exception

00:57:20,900 --> 00:57:24,710
in this case now we have a new type of

00:57:23,000 --> 00:57:26,210
exception which doesn't inherit from

00:57:24,710 --> 00:57:28,070
state exceptions so that kind of breaks

00:57:26,210 --> 00:57:29,420
a lot of code that catches stood

00:57:28,070 --> 00:57:31,310
exception and says well everything else

00:57:29,420 --> 00:57:33,410
is weird it's actually more powerful

00:57:31,310 --> 00:57:37,070
than exception hierarchies

00:57:33,410 --> 00:57:39,650
exception hierarchies are are fixed you

00:57:37,070 --> 00:57:41,690
know they attack basically whereas

00:57:39,650 --> 00:57:43,970
because of the equivalence they're

00:57:41,690 --> 00:57:46,220
checking on on error codes you can have

00:57:43,970 --> 00:57:47,599
will be the sort of complex mesh of many

00:57:46,220 --> 00:57:49,760
to many relationships between error

00:57:47,599 --> 00:57:51,320
codes from different domains and then

00:57:49,760 --> 00:57:53,780
limited it's two domains together across

00:57:51,320 --> 00:57:55,670
many domains and actually gives you all

00:57:53,780 --> 00:57:57,079
of the power you had with exception

00:57:55,670 --> 00:57:58,970
hierarchies and more you've got more

00:57:57,079 --> 00:58:01,369
flexibility alright we can talk after it

00:57:58,970 --> 00:58:03,120
wasn't about exception okay thank you

00:58:01,369 --> 00:58:06,940
very much

00:58:03,120 --> 00:58:06,940

YouTube URL: https://www.youtube.com/watch?v=ZUH8p1EQswA


