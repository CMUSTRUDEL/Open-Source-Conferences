Title: CppCon 2019: Ben Saks “Better Code with C++ Attributes”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Modern C++ attributes such as [[noreturn]] and [[deprecated]] can be used to improve code quality and programmer productivity. They provide valuable information to the compiler, allowing it to generate more efficient code and provide more useful warning messages. C++20 is slated to include several new attributes, including [[no_unique_address]] and the design-by-contract attributes. They also let you use compiler extensions on specific toolchains without locking you into using only those toolchains.

This session explores several C++ attributes and provides examples of how to use each one to improve your programs. Although it focuses on the standard attributes, it also includes examples of non-standard attributes from specific toolchains.
— 
Ben Saks
Chief Engineer, Saks & Associates
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,330 --> 00:00:12,200
hi so

00:00:33,400 --> 00:00:36,470
[Applause]

00:00:59,989 --> 00:01:08,460
so we're providing this qualifier under

00:01:05,190 --> 00:01:18,330
smokers or I argued to make it easier

00:01:08,460 --> 00:01:25,080
for the programmer to write the memories

00:01:18,330 --> 00:01:29,459
they have structures and cold declare

00:01:25,080 --> 00:01:34,590
that function is rarely ever called and

00:01:29,459 --> 00:01:37,229
that important like that it should

00:01:34,590 --> 00:01:44,489
optimize the function of space rather

00:01:37,229 --> 00:01:47,759
than now attributes like this have to be

00:01:44,489 --> 00:01:50,670
polled here in effect the performance of

00:01:47,759 --> 00:01:53,340
your generated color so the sort of

00:01:50,670 --> 00:01:56,069
thing that you often want to be able to

00:01:53,340 --> 00:01:58,920
take advantage of but because their

00:01:56,069 --> 00:02:01,739
compilers to save extensions that can be

00:01:58,920 --> 00:02:04,920
difficult if you're writing code if you

00:02:01,739 --> 00:02:07,530
want to be fearless and you'd like to be

00:02:04,920 --> 00:02:10,170
able to compile the same code using

00:02:07,530 --> 00:02:13,140
multiple school chains using these

00:02:10,170 --> 00:02:16,590
extensions writ large that portability

00:02:13,140 --> 00:02:19,550
but when a tiger tries the first one of

00:02:16,590 --> 00:02:19,550
these after news

00:03:07,670 --> 00:04:01,519
so understand it requires more so this

00:03:58,140 --> 00:04:04,500
provides a certain level of security

00:04:01,519 --> 00:04:07,620
that allows you to write your code more

00:04:04,500 --> 00:04:10,560
flexibly because you because you can

00:04:07,620 --> 00:04:14,610
take advantage of these extensions where

00:04:10,560 --> 00:04:16,320
they exist and if this your extension is

00:04:14,610 --> 00:04:20,580
implemented using one of these modern

00:04:16,320 --> 00:04:23,190
C++ attributes then other compilers that

00:04:20,580 --> 00:04:25,200
don't support that extension will just

00:04:23,190 --> 00:04:26,790
compile that the code as if you haven't

00:04:25,200 --> 00:04:29,250
written that attribute in the first

00:04:26,790 --> 00:04:30,940
place and you'll get you'll still get

00:04:29,250 --> 00:04:33,430
behavior that work

00:04:30,940 --> 00:04:35,530
on the other end it might not be quite

00:04:33,430 --> 00:04:38,080
as fast or quite as efficient as it

00:04:35,530 --> 00:04:40,450
would be on platform that understands

00:04:38,080 --> 00:04:46,870
that extension but you'll still get

00:04:40,450 --> 00:04:51,730
working code now as the as the standard

00:04:46,870 --> 00:04:54,010
evolved it became clear that this wasn't

00:04:51,730 --> 00:04:57,100
useful just for compiler extensions

00:04:54,010 --> 00:04:59,770
there are also language features that it

00:04:57,100 --> 00:05:02,320
made sense to implement using this

00:04:59,770 --> 00:05:04,540
attribute syntax because there are

00:05:02,320 --> 00:05:07,780
certain some of the things that are in

00:05:04,540 --> 00:05:10,830
the language really fundamentally change

00:05:07,780 --> 00:05:14,280
the behavior of code but there are other

00:05:10,830 --> 00:05:17,410
parts of features in the language that

00:05:14,280 --> 00:05:19,030
aren't strictly necessary to make the

00:05:17,410 --> 00:05:21,040
code do what you want

00:05:19,030 --> 00:05:24,460
instead they serve to do things like

00:05:21,040 --> 00:05:27,310
help you detect error conditions or they

00:05:24,460 --> 00:05:29,560
improve code performance and so

00:05:27,310 --> 00:05:31,840
implementing those sorts of features as

00:05:29,560 --> 00:05:34,210
attributes has become the preferred way

00:05:31,840 --> 00:05:36,640
of doing things because they're

00:05:34,210 --> 00:05:38,230
effectively backwards compatible as long

00:05:36,640 --> 00:05:41,980
as your compiler knows that it's

00:05:38,230 --> 00:05:44,260
supposed to ignore any double square

00:05:41,980 --> 00:05:46,540
bracket and attribute that it doesn't

00:05:44,260 --> 00:05:48,160
recognize you can use the latest

00:05:46,540 --> 00:05:49,450
cutting-edge stuff and if your compiler

00:05:48,160 --> 00:05:52,330
doesn't support it

00:05:49,450 --> 00:05:54,040
it just got its just ignored if it does

00:05:52,330 --> 00:05:57,580
support it you get the new and improved

00:05:54,040 --> 00:06:00,430
behavior so let's take a look at some of

00:05:57,580 --> 00:06:03,010
those features so one of the first

00:06:00,430 --> 00:06:04,870
attributes that was added in C++ 11 was

00:06:03,010 --> 00:06:08,140
this no return attribute and it

00:06:04,870 --> 00:06:11,919
indicates that a function never returns

00:06:08,140 --> 00:06:15,010
now I have to be a little pedantic in my

00:06:11,919 --> 00:06:19,090
terminology here because a function with

00:06:15,010 --> 00:06:21,310
a void return type still returns in most

00:06:19,090 --> 00:06:25,150
cases it doesn't return anything

00:06:21,310 --> 00:06:27,550
specifically but it does use the same

00:06:25,150 --> 00:06:30,190
process of returning back to the call

00:06:27,550 --> 00:06:32,919
site to get back to where the function

00:06:30,190 --> 00:06:35,410
was called whereas a no return function

00:06:32,919 --> 00:06:39,640
really doesn't return to the call site

00:06:35,410 --> 00:06:41,680
at all so one of the ways in which this

00:06:39,640 --> 00:06:44,600
is useful is that compilers will often

00:06:41,680 --> 00:06:48,080
issue warnings if they notice the code

00:06:44,600 --> 00:06:50,060
that you've written is unreachable so if

00:06:48,080 --> 00:06:53,060
I fed my compiler code that looks like

00:06:50,060 --> 00:06:55,070
this where I have something that I

00:06:53,060 --> 00:06:58,370
expected to be executed after the return

00:06:55,070 --> 00:07:01,040
statement most compilers would flag this

00:06:58,370 --> 00:07:04,850
as unreachable code and say I think

00:07:01,040 --> 00:07:07,970
you're doing something wrong here now

00:07:04,850 --> 00:07:10,070
that works fine in this case because the

00:07:07,970 --> 00:07:12,620
compiler has an intrinsic understanding

00:07:10,070 --> 00:07:14,270
of what the return statement does the

00:07:12,620 --> 00:07:17,840
fact that that's going to be the

00:07:14,270 --> 00:07:21,380
effective end of the function but if I

00:07:17,840 --> 00:07:23,120
have a more opaque function there that

00:07:21,380 --> 00:07:24,680
doesn't return this and Pilar might not

00:07:23,120 --> 00:07:27,860
be able to tell that without some

00:07:24,680 --> 00:07:31,340
additional help so for example the

00:07:27,860 --> 00:07:33,560
standard exit function from C never

00:07:31,340 --> 00:07:37,160
returns it's job is to terminate the

00:07:33,560 --> 00:07:39,020
program with a specific exit code and so

00:07:37,160 --> 00:07:41,630
in modernism plus plus we declare this

00:07:39,020 --> 00:07:44,990
as a no return function to make it clear

00:07:41,630 --> 00:07:46,970
that this function never returns back to

00:07:44,990 --> 00:07:51,620
the paul site once you call this

00:07:46,970 --> 00:07:54,200
function you're not coming back so now

00:07:51,620 --> 00:07:56,410
if in modern C++ if I write code that

00:07:54,200 --> 00:07:59,870
looks like this

00:07:56,410 --> 00:08:01,670
now my compilers can reasonably flag the

00:07:59,870 --> 00:08:04,460
code after the call to exit as

00:08:01,670 --> 00:08:06,590
unreachable where it wouldn't have been

00:08:04,460 --> 00:08:08,330
able to do that if the function hadn't

00:08:06,590 --> 00:08:10,640
been declared no return because it would

00:08:08,330 --> 00:08:12,170
have assumed that it's going that the

00:08:10,640 --> 00:08:16,430
function is at some point going to end

00:08:12,170 --> 00:08:17,840
and come back to this point now there is

00:08:16,430 --> 00:08:19,700
one of the other reasons you might want

00:08:17,840 --> 00:08:21,620
to declare something no return is that

00:08:19,700 --> 00:08:24,110
there is a small performance benefit to

00:08:21,620 --> 00:08:26,300
it there is some amount of code

00:08:24,110 --> 00:08:30,230
associated with returning back to the

00:08:26,300 --> 00:08:32,419
call site of the function and so if the

00:08:30,230 --> 00:08:35,510
compiler knows that your function is

00:08:32,419 --> 00:08:37,520
never going to return it can omit the

00:08:35,510 --> 00:08:39,620
generation of those instructions it can

00:08:37,520 --> 00:08:41,360
leave that part of the function out and

00:08:39,620 --> 00:08:45,650
the result is you get code that's

00:08:41,360 --> 00:08:47,240
slightly smaller and slightly faster now

00:08:45,650 --> 00:08:49,670
as I said you want to be a little

00:08:47,240 --> 00:08:51,710
cautious about doing this so here we

00:08:49,670 --> 00:08:53,810
have a function that doesn't have an

00:08:51,710 --> 00:08:56,240
explicit return statement it has a

00:08:53,810 --> 00:08:58,610
return type of void all it does is print

00:08:56,240 --> 00:09:01,069
out a value to standard out

00:08:58,610 --> 00:09:03,499
but it still returns controlled back to

00:09:01,069 --> 00:09:06,230
the taller because flowing off the end

00:09:03,499 --> 00:09:09,410
of the function is the same thing as

00:09:06,230 --> 00:09:11,029
returning effectively so this is a

00:09:09,410 --> 00:09:13,879
function that shouldn't be declared no

00:09:11,029 --> 00:09:16,249
return because it still gets back to the

00:09:13,879 --> 00:09:19,730
call site through the standard return

00:09:16,249 --> 00:09:21,350
mechanism now one thing that no return

00:09:19,730 --> 00:09:23,119
functions can do is that they can

00:09:21,350 --> 00:09:24,649
terminate by throwing exceptions

00:09:23,119 --> 00:09:26,899
doesn't necessarily mean that you'll

00:09:24,649 --> 00:09:29,119
never exit the function that was

00:09:26,899 --> 00:09:31,879
declared no return it just means that

00:09:29,119 --> 00:09:35,179
you won't exit it using the normal

00:09:31,879 --> 00:09:37,519
function call return mechanism so here

00:09:35,179 --> 00:09:40,720
we have a function food that throws that

00:09:37,519 --> 00:09:45,679
always throws a standard logic error and

00:09:40,720 --> 00:09:48,319
I can put this inside of a try block in

00:09:45,679 --> 00:09:50,779
this other function bar here and the

00:09:48,319 --> 00:09:52,999
compiler can tell in this case that the

00:09:50,779 --> 00:09:55,999
code that comes after the call to foo

00:09:52,999 --> 00:09:59,839
inside that try block will never be

00:09:55,999 --> 00:10:01,970
called will never be run because it's it

00:09:59,839 --> 00:10:05,829
occurs directly after a no return

00:10:01,970 --> 00:10:08,449
function and whatever that function does

00:10:05,829 --> 00:10:11,660
it's not going to come back to the call

00:10:08,449 --> 00:10:14,360
site in the ordinary mechanism on the

00:10:11,660 --> 00:10:18,049
other hand the compiler does understand

00:10:14,360 --> 00:10:20,149
that it may still reach the point of of

00:10:18,049 --> 00:10:22,699
that catch block where we catch the

00:10:20,149 --> 00:10:24,980
logic error and output the goodbye

00:10:22,699 --> 00:10:30,980
message that code will be treated as

00:10:24,980 --> 00:10:32,720
reachable now one of the reasons you

00:10:30,980 --> 00:10:34,850
want to be so careful about making sure

00:10:32,720 --> 00:10:38,119
that you don't declare functions as no

00:10:34,850 --> 00:10:41,869
return unless they actually don't return

00:10:38,119 --> 00:10:44,119
is that if you if a no return function

00:10:41,869 --> 00:10:46,999
gets to a point where it ordinarily

00:10:44,119 --> 00:10:49,699
would return the result is it produces

00:10:46,999 --> 00:10:52,249
undefined behavior as I said before the

00:10:49,699 --> 00:10:55,100
compiler has the license to omit that

00:10:52,249 --> 00:10:57,230
return the return code from that

00:10:55,100 --> 00:11:00,290
function and if that code isn't there

00:10:57,230 --> 00:11:02,720
what happens you just keep executing

00:11:00,290 --> 00:11:04,759
whatever code comes after that function

00:11:02,720 --> 00:11:07,279
in the compiled executable and that's

00:11:04,759 --> 00:11:10,639
probably not what you wanted to do now

00:11:07,279 --> 00:11:11,220
the compiler tries to is encouraged to

00:11:10,639 --> 00:11:13,680
war

00:11:11,220 --> 00:11:18,180
if a no-return function might actually

00:11:13,680 --> 00:11:20,310
return but for an arbitrarily complex

00:11:18,180 --> 00:11:23,100
function it might not be able to do that

00:11:20,310 --> 00:11:25,230
in many cases it will warn you but it's

00:11:23,100 --> 00:11:27,180
not guaranteed that the compiler can

00:11:25,230 --> 00:11:30,390
catch anything or can catch everything

00:11:27,180 --> 00:11:33,720
there so you want to declare functions

00:11:30,390 --> 00:11:40,820
as no return if and only if they don't

00:11:33,720 --> 00:11:43,140
return so moving on to another attribute

00:11:40,820 --> 00:11:45,570
one of the things one of the common

00:11:43,140 --> 00:11:49,760
things that we see as code bases evolve

00:11:45,570 --> 00:11:53,100
is that you'll have a piece of code that

00:11:49,760 --> 00:11:55,790
you find a better way of doing the thing

00:11:53,100 --> 00:11:58,710
that that code was responsible for and

00:11:55,790 --> 00:12:00,480
you'd like and you replace it with a

00:11:58,710 --> 00:12:03,390
better version or rather I should say

00:12:00,480 --> 00:12:05,940
you'd like to replace it but you have a

00:12:03,390 --> 00:12:09,240
lot of existing code that already uses

00:12:05,940 --> 00:12:12,510
the old interface and so you might not

00:12:09,240 --> 00:12:15,840
want to go through a single big bang

00:12:12,510 --> 00:12:18,270
revision of changing all of your code at

00:12:15,840 --> 00:12:20,970
once but you do want to introduce the

00:12:18,270 --> 00:12:24,180
new way of doing things a new and

00:12:20,970 --> 00:12:27,930
improved interface and tell people to

00:12:24,180 --> 00:12:30,390
migrate away from the old interface and

00:12:27,930 --> 00:12:34,350
towards the new one so we see an example

00:12:30,390 --> 00:12:38,070
of this in the C++ standards back in C++

00:12:34,350 --> 00:12:41,250
3 we had Auto pointer which was a smart

00:12:38,070 --> 00:12:47,580
pointer type that had some surprising

00:12:41,250 --> 00:12:49,940
behaviors and so in modern C++ we

00:12:47,580 --> 00:12:52,530
eventually got the tools to write

00:12:49,940 --> 00:12:54,570
improved smart pointer types that had

00:12:52,530 --> 00:12:57,360
less surprising behaviors like unique

00:12:54,570 --> 00:12:58,710
pointer and so as a result auto pointer

00:12:57,360 --> 00:13:01,140
has fallen out of favor it was

00:12:58,710 --> 00:13:04,020
deprecated in the C++ 11 and in fact now

00:13:01,140 --> 00:13:07,470
it's just straight been removed from C++

00:13:04,020 --> 00:13:10,410
17 but there was that period of six

00:13:07,470 --> 00:13:13,470
years in there where auto pointer lived

00:13:10,410 --> 00:13:15,780
in this sort of gray area where it was

00:13:13,470 --> 00:13:18,420
part of the standard it was something

00:13:15,780 --> 00:13:22,680
that you could use it was guaranteed to

00:13:18,420 --> 00:13:24,520
be there but we were encouraging you not

00:13:22,680 --> 00:13:26,320
to use it there were

00:13:24,520 --> 00:13:28,330
period or alternatives like unique

00:13:26,320 --> 00:13:30,520
pointer that you should be using instead

00:13:28,330 --> 00:13:34,810
and so it was what we call deprecated

00:13:30,520 --> 00:13:36,790
and in modern c++ c plus plus 14

00:13:34,810 --> 00:13:39,460
specifically we now have a deprecated

00:13:36,790 --> 00:13:43,540
attribute that lets you tag your own

00:13:39,460 --> 00:13:46,570
code in this way so if you tagged

00:13:43,540 --> 00:13:49,120
something as deprecated and and you

00:13:46,570 --> 00:13:51,700
actually use that piece of code

00:13:49,120 --> 00:13:53,890
somewhere in your executable the

00:13:51,700 --> 00:13:55,990
compiler should issue a warning telling

00:13:53,890 --> 00:13:59,230
you you're using something that's been

00:13:55,990 --> 00:14:01,570
deprecated go find a better way of doing

00:13:59,230 --> 00:14:03,010
things and you can apply this to all

00:14:01,570 --> 00:14:05,020
sorts of different stuffs you can have

00:14:03,010 --> 00:14:07,990
deprecated variables deprecated

00:14:05,020 --> 00:14:11,650
functions deprecated types type deaths

00:14:07,990 --> 00:14:13,720
aliases all sorts of things you can even

00:14:11,650 --> 00:14:16,240
have deprecated its individual

00:14:13,720 --> 00:14:20,650
enumeration values or explicit template

00:14:16,240 --> 00:14:22,180
specialization like this and one of the

00:14:20,650 --> 00:14:25,030
things that you can do because just

00:14:22,180 --> 00:14:27,090
saying deprecated is it necessarily all

00:14:25,030 --> 00:14:29,230
that helpful as I showed you earlier

00:14:27,090 --> 00:14:31,540
deprecated can take a string literal as

00:14:29,230 --> 00:14:33,760
an argument and that string literal is

00:14:31,540 --> 00:14:36,910
intended to provide information about

00:14:33,760 --> 00:14:40,450
why the thing is deprecated or what you

00:14:36,910 --> 00:14:43,480
might want to use instead so here for

00:14:40,450 --> 00:14:46,330
example I have a function print that

00:14:43,480 --> 00:14:48,760
I've declared deprecated because I have

00:14:46,330 --> 00:14:52,720
a new function right that I would prefer

00:14:48,760 --> 00:14:54,700
that people use instead I don't want to

00:14:52,720 --> 00:14:56,110
completely get rid of the print function

00:14:54,700 --> 00:15:00,640
from my code just yet

00:14:56,110 --> 00:15:03,070
but I want I don't want new write new

00:15:00,640 --> 00:15:04,990
uses of that print function to enter the

00:15:03,070 --> 00:15:09,210
code I want people to be using the write

00:15:04,990 --> 00:15:12,400
function instead and on many compilers

00:15:09,210 --> 00:15:13,930
this attribute that string would rule

00:15:12,400 --> 00:15:16,540
that's specified that it will just be

00:15:13,930 --> 00:15:18,970
directly in the error message it'll just

00:15:16,540 --> 00:15:20,260
say something like here's the here's the

00:15:18,970 --> 00:15:22,810
message from the new compiler and it

00:15:20,260 --> 00:15:28,630
actually includes prefer write in the

00:15:22,810 --> 00:15:30,730
result so another situation that's that

00:15:28,630 --> 00:15:34,570
attributes can be helpful in is when

00:15:30,730 --> 00:15:37,690
writing switch statements so often when

00:15:34,570 --> 00:15:40,090
we write switch statements the case

00:15:37,690 --> 00:15:42,820
within the switch are independent of

00:15:40,090 --> 00:15:44,620
each other and we make sure that that's

00:15:42,820 --> 00:15:48,580
the case by including a break statement

00:15:44,620 --> 00:15:50,170
at the end of every case and if we Furby

00:15:48,580 --> 00:15:53,080
cuz if we forget to include a break

00:15:50,170 --> 00:15:56,170
statement somewhere then control just

00:15:53,080 --> 00:15:58,780
falls through to the next case and

00:15:56,170 --> 00:16:01,150
continues executing there and often

00:15:58,780 --> 00:16:04,540
that's not what we want so here for

00:16:01,150 --> 00:16:08,770
example I have some code for a TCP

00:16:04,540 --> 00:16:10,750
connection state machine for a server so

00:16:08,770 --> 00:16:12,190
somewhere in the height inside that

00:16:10,750 --> 00:16:13,750
server code I have this switch statement

00:16:12,190 --> 00:16:16,450
that looks at the state of the

00:16:13,750 --> 00:16:18,490
connection and it's and it has a case

00:16:16,450 --> 00:16:20,560
where it says if I've just received the

00:16:18,490 --> 00:16:22,510
first part of connection requests go

00:16:20,560 --> 00:16:24,940
ahead and send back the appropriate

00:16:22,510 --> 00:16:27,130
response to continue establishing that

00:16:24,940 --> 00:16:30,130
connection and then break out of the

00:16:27,130 --> 00:16:35,020
switch if I just receive the first part

00:16:30,130 --> 00:16:36,940
of a closer connection request go ahead

00:16:35,020 --> 00:16:39,190
and send back the appropriate response

00:16:36,940 --> 00:16:40,930
and then break out of the switch if I

00:16:39,190 --> 00:16:44,020
forgot to include one of those break

00:16:40,930 --> 00:16:46,510
statements I get some I would fall into

00:16:44,020 --> 00:16:49,470
a different case here for example if I

00:16:46,510 --> 00:16:52,030
missed it the first break in this case

00:16:49,470 --> 00:16:53,080
I'd never be able to connect no one

00:16:52,030 --> 00:16:55,630
would ever be able to connect this

00:16:53,080 --> 00:16:57,820
server because I would first send out a

00:16:55,630 --> 00:17:00,190
response that said okay I'm ready just

00:16:57,820 --> 00:17:01,990
I'm willing to continue connecting oh

00:17:00,190 --> 00:17:06,520
and then I immediately send the

00:17:01,990 --> 00:17:07,810
terminate connection message so people

00:17:06,520 --> 00:17:11,050
wouldn't really be able to connect and

00:17:07,810 --> 00:17:13,390
that would be not a very good server so

00:17:11,050 --> 00:17:16,000
some compilers will warn you in

00:17:13,390 --> 00:17:18,760
situations where you forget to include a

00:17:16,000 --> 00:17:22,360
break statement when fall through would

00:17:18,760 --> 00:17:24,730
occur and that can be very helpful in

00:17:22,360 --> 00:17:26,589
catching errors but sometimes you

00:17:24,730 --> 00:17:28,449
actually do want to fall through to the

00:17:26,589 --> 00:17:31,210
next case in a switch statement

00:17:28,449 --> 00:17:33,700
so here's more code from that same

00:17:31,210 --> 00:17:37,360
switch statement so I have a default

00:17:33,700 --> 00:17:39,820
case here where suppose that my TCP

00:17:37,360 --> 00:17:43,450
server has gotten into an unusual

00:17:39,820 --> 00:17:46,420
connection state and I want to somehow

00:17:43,450 --> 00:17:49,300
recover from that well I do in that

00:17:46,420 --> 00:17:50,730
situation as I reset the connection to

00:17:49,300 --> 00:17:53,010
put my

00:17:50,730 --> 00:17:56,610
back into a known state basically

00:17:53,010 --> 00:17:58,919
terminated and then I go back into the

00:17:56,610 --> 00:18:02,010
listened state at that point and I pick

00:17:58,919 --> 00:18:04,320
up as if I had been in a listen state to

00:18:02,010 --> 00:18:08,100
begin with I just start waiting for a

00:18:04,320 --> 00:18:10,020
connection from some client in this case

00:18:08,100 --> 00:18:12,720
I actually want the bird to fall through

00:18:10,020 --> 00:18:16,020
to occur because the appropriate way of

00:18:12,720 --> 00:18:17,700
handling a default state is to reset the

00:18:16,020 --> 00:18:20,370
connection and then continue on into the

00:18:17,700 --> 00:18:23,040
listening state if I got a compiler

00:18:20,370 --> 00:18:24,919
warning about full through here that

00:18:23,040 --> 00:18:28,230
would be annoying and distracting

00:18:24,919 --> 00:18:31,950
because I actually want the fall-through

00:18:28,230 --> 00:18:33,840
to occur and in C++ 17 we can now make

00:18:31,950 --> 00:18:36,179
it that clear to the compiler with the

00:18:33,840 --> 00:18:39,120
fall through attribute I can specify

00:18:36,179 --> 00:18:42,120
like in place fall through at the end of

00:18:39,120 --> 00:18:43,650
a case in a switch statement and that

00:18:42,120 --> 00:18:45,900
makes it clear to the compiler that I

00:18:43,650 --> 00:18:48,240
really do want to fall through to the

00:18:45,900 --> 00:18:52,559
next case and it shouldn't warn me about

00:18:48,240 --> 00:18:54,750
that situation and fall through can even

00:18:52,559 --> 00:18:57,690
be executed conditionally like this so

00:18:54,750 --> 00:19:00,630
in this case I've augmented the code so

00:18:57,690 --> 00:19:03,540
that will only reset the connection if

00:19:00,630 --> 00:19:05,549
we've been in an unknown state for a

00:19:03,540 --> 00:19:08,490
certain amount of time if we've reached

00:19:05,549 --> 00:19:11,160
a time at so if the timeout has been

00:19:08,490 --> 00:19:13,110
reached we reset the connection and fall

00:19:11,160 --> 00:19:15,750
through into the listen case otherwise

00:19:13,110 --> 00:19:17,700
we just break out and go back and let

00:19:15,750 --> 00:19:19,710
the server go back to doing whatever it

00:19:17,700 --> 00:19:21,059
was doing before and then we'll check

00:19:19,710 --> 00:19:22,470
back on the connection state at some

00:19:21,059 --> 00:19:28,500
point in the future and maybe we'll have

00:19:22,470 --> 00:19:30,840
timed out them now the fall through the

00:19:28,500 --> 00:19:35,340
next statement to be executed after a

00:19:30,840 --> 00:19:37,020
fall through has to be a case later so I

00:19:35,340 --> 00:19:40,260
can't just put a follow through at the

00:19:37,020 --> 00:19:42,450
top of a bull of a case like this where

00:19:40,260 --> 00:19:45,570
the next statement is actually an if

00:19:42,450 --> 00:19:47,520
statement rather than a case label in

00:19:45,570 --> 00:19:50,070
this case the compiler will flag that

00:19:47,520 --> 00:19:53,370
ball through attribute as invalid

00:19:50,070 --> 00:19:54,980
because the next statement isn't the

00:19:53,370 --> 00:19:59,700
sort of thing that I can fall through

00:19:54,980 --> 00:20:01,919
into and this also applies if I find put

00:19:59,700 --> 00:20:04,260
a fall through at the very end of the

00:20:01,919 --> 00:20:06,540
last piece because in

00:20:04,260 --> 00:20:11,700
situation again there's nothing to fall

00:20:06,540 --> 00:20:13,350
through into from the final case so that

00:20:11,700 --> 00:20:15,630
can't that's not a valid place for the

00:20:13,350 --> 00:20:23,340
fall threat of you yeah do you want to

00:20:15,630 --> 00:20:27,450
use the microphone to is the semicolon

00:20:23,340 --> 00:20:29,130
necessary is the question so I believe

00:20:27,450 --> 00:20:32,610
the semicolon is necessary when I've

00:20:29,130 --> 00:20:34,950
seen it used i I've always seen a

00:20:32,610 --> 00:20:36,630
semicolon there but I have to admit one

00:20:34,950 --> 00:20:39,000
that that's something I didn't test when

00:20:36,630 --> 00:20:43,050
I was running through the code for this

00:20:39,000 --> 00:20:50,160
particular talk so I want to check that

00:20:43,050 --> 00:20:52,470
at some point okay any more question

00:20:50,160 --> 00:20:53,580
from the fall through attribute so if

00:20:52,470 --> 00:20:59,310
there are any more questions about that

00:20:53,580 --> 00:21:02,730
feel free to ask okay so another

00:20:59,310 --> 00:21:05,970
situation in which compilers often warn

00:21:02,730 --> 00:21:08,460
us is when we have unused variables many

00:21:05,970 --> 00:21:09,900
compilers if I feed it code that looks

00:21:08,460 --> 00:21:14,970
like this where I have a function called

00:21:09,900 --> 00:21:17,100
half that has a local variable Y that I

00:21:14,970 --> 00:21:19,560
just give the value 10 but then I don't

00:21:17,100 --> 00:21:23,070
use Y anywhere in the body of the

00:21:19,560 --> 00:21:25,800
function after that point most compilers

00:21:23,070 --> 00:21:28,440
will warn me about this situation they

00:21:25,800 --> 00:21:30,570
will say wait a minute you created this

00:21:28,440 --> 00:21:33,720
variable but you never used this did you

00:21:30,570 --> 00:21:36,510
mean to do something else and in general

00:21:33,720 --> 00:21:38,700
this is a good thing because it helps us

00:21:36,510 --> 00:21:41,730
catch programming mistakes

00:21:38,700 --> 00:21:43,320
it helps remind us that maybe I intended

00:21:41,730 --> 00:21:48,600
to have another line in this function

00:21:43,320 --> 00:21:50,310
somewhere but occasionally compilers

00:21:48,600 --> 00:21:52,530
will warn you about these things when

00:21:50,310 --> 00:21:54,870
you don't want them to and I think the

00:21:52,530 --> 00:21:58,050
most common case where this comes up is

00:21:54,870 --> 00:22:00,630
when you're using the assert macro so

00:21:58,050 --> 00:22:05,100
here we have a function foo that takes

00:22:00,630 --> 00:22:09,060
two parameters I and J but the purpose

00:22:05,100 --> 00:22:12,840
of J as a parameter here is only to

00:22:09,060 --> 00:22:15,600
check a precondition of the function we

00:22:12,840 --> 00:22:17,799
use an assert statement to verify that I

00:22:15,600 --> 00:22:21,129
is less than some value J

00:22:17,799 --> 00:22:23,919
and then we continue on to use I and the

00:22:21,129 --> 00:22:27,039
rest of my foo function here doesn't use

00:22:23,919 --> 00:22:29,739
J at all the only purpose of J was to

00:22:27,039 --> 00:22:33,669
verify that preconditions and because

00:22:29,739 --> 00:22:36,009
I'm using assert in this situation J is

00:22:33,669 --> 00:22:38,169
actually only used when I compile in

00:22:36,009 --> 00:22:40,690
debug mode because when I compile in

00:22:38,169 --> 00:22:44,409
release mode assert statements are

00:22:40,690 --> 00:22:47,440
compiled out so I I'm in the annoying

00:22:44,409 --> 00:22:49,809
situation where I have code that looks

00:22:47,440 --> 00:22:51,669
perfectly fine when I'm writing it but

00:22:49,809 --> 00:22:54,450
then I submit it and compile it for

00:22:51,669 --> 00:22:57,340
release and I get an unexpected warning

00:22:54,450 --> 00:23:02,769
because now all of a sudden J isn't

00:22:57,340 --> 00:23:04,629
actually used in this function so C++ 17

00:23:02,769 --> 00:23:06,340
provides an attribute for dealing with

00:23:04,629 --> 00:23:09,460
these sorts of situations the may be

00:23:06,340 --> 00:23:12,279
unused attribute and it lets the

00:23:09,460 --> 00:23:16,239
compiler know that it's possible that a

00:23:12,279 --> 00:23:19,359
particular value won't be used with it

00:23:16,239 --> 00:23:21,970
during its lifetime and that's okay you

00:23:19,359 --> 00:23:24,700
as the programmer intended that you

00:23:21,970 --> 00:23:28,149
don't need to be reminded via warnings

00:23:24,700 --> 00:23:32,619
or other messages that this thing isn't

00:23:28,149 --> 00:23:34,809
being used now unused variables or what

00:23:32,619 --> 00:23:36,700
we typically think of when we think of

00:23:34,809 --> 00:23:39,519
getting warnings about unused and these

00:23:36,700 --> 00:23:41,350
but you can actually put maybe unused in

00:23:39,519 --> 00:23:43,929
lots of different places you can have

00:23:41,350 --> 00:23:46,749
not just maybe unused variables but

00:23:43,929 --> 00:23:52,059
maybe unused functions or parameters or

00:23:46,749 --> 00:23:54,759
types type deaths etc so while we don't

00:23:52,059 --> 00:23:59,529
see compilers right now issuing very

00:23:54,759 --> 00:24:01,239
many warnings about these things we one

00:23:59,529 --> 00:24:03,429
of the nice things about having

00:24:01,239 --> 00:24:06,249
attributes like this is that not

00:24:03,429 --> 00:24:08,080
necessarily it's not necessarily helpful

00:24:06,249 --> 00:24:10,269
to first silencing warnings so much

00:24:08,080 --> 00:24:12,429
right now but it allows compilers to be

00:24:10,269 --> 00:24:15,279
a little bit more aggressive about

00:24:12,429 --> 00:24:18,159
giving us warnings about these things

00:24:15,279 --> 00:24:21,220
being unused that right now they might

00:24:18,159 --> 00:24:24,789
be reluctant to issue because now we

00:24:21,220 --> 00:24:27,070
have this maybe unused mechanism that

00:24:24,789 --> 00:24:29,440
provides a way of turning those warnings

00:24:27,070 --> 00:24:31,680
off if we don't want to see them on a

00:24:29,440 --> 00:24:33,940
case-by-case basis

00:24:31,680 --> 00:24:36,190
here are just a few more examples of

00:24:33,940 --> 00:24:43,780
where you can use the the maybe unused

00:24:36,190 --> 00:24:47,710
attribute now one of the things that the

00:24:43,780 --> 00:24:50,800
standard a lot of these attributes deal

00:24:47,710 --> 00:24:53,830
with warnings and similar behaviors and

00:24:50,800 --> 00:24:57,400
in general the standard doesn't like to

00:24:53,830 --> 00:24:59,530
be too prescriptive about what sorts of

00:24:57,400 --> 00:25:02,020
error messages a compiler needs to

00:24:59,530 --> 00:25:02,440
produce it will tell you when a program

00:25:02,020 --> 00:25:06,040
is

00:25:02,440 --> 00:25:08,200
ill-formed but in terms of warnings the

00:25:06,040 --> 00:25:11,520
standard doesn't like to be too

00:25:08,200 --> 00:25:15,220
prescriptive prescriptive in those cases

00:25:11,520 --> 00:25:17,230
so maybe unused strictly according to

00:25:15,220 --> 00:25:19,540
the standard is actually a request not a

00:25:17,230 --> 00:25:21,970
command the compiler does have the

00:25:19,540 --> 00:25:24,700
license to ignore you and say yeah I

00:25:21,970 --> 00:25:26,680
know you said maybe unused but I'm going

00:25:24,700 --> 00:25:29,440
to issue oh I really think you need to

00:25:26,680 --> 00:25:31,720
know that this thing is unused and I'm

00:25:29,440 --> 00:25:33,550
gonna tell you anyway now I haven't

00:25:31,720 --> 00:25:36,700
found any situations which compiler

00:25:33,550 --> 00:25:38,710
actually does this but the state of but

00:25:36,700 --> 00:25:40,570
because the standard doesn't want to be

00:25:38,710 --> 00:25:44,440
overly prescriptive with warning

00:25:40,570 --> 00:25:47,710
messages it's from a strict standpoint

00:25:44,440 --> 00:25:49,270
you think of this as a request so but

00:25:47,710 --> 00:25:50,920
there a question is this a quick

00:25:49,270 --> 00:25:53,260
question can you go back to the previous

00:25:50,920 --> 00:26:03,360
slide D yeah you wanted to you want me

00:25:53,260 --> 00:26:06,430
to go back to the previous slide here

00:26:03,360 --> 00:26:09,700
the the placement rules for attributes

00:26:06,430 --> 00:26:11,980
are there are many different places in

00:26:09,700 --> 00:26:16,240
which you can put these things there

00:26:11,980 --> 00:26:17,920
they're fairly intricate uh and I didn't

00:26:16,240 --> 00:26:24,450
want to spend a lot of time discussing

00:26:17,920 --> 00:26:27,610
them so this is where I'm using the

00:26:24,450 --> 00:26:31,000
placement of attributes for the purposes

00:26:27,610 --> 00:26:32,950
of this talk in what seems to be the

00:26:31,000 --> 00:26:36,490
general consensus about where to place

00:26:32,950 --> 00:26:39,130
them but there but it's more flexible

00:26:36,490 --> 00:26:41,050
than I'm letting on in terms of exactly

00:26:39,130 --> 00:26:43,710
where these attributes have to be placed

00:26:41,050 --> 00:26:43,710
okay

00:26:45,700 --> 00:26:51,799
okay so another situation that where we

00:26:49,879 --> 00:26:55,970
this is actually sort of the reverse

00:26:51,799 --> 00:26:57,950
case uh sometimes we have functions that

00:26:55,970 --> 00:26:59,929
have return values that aren't very

00:26:57,950 --> 00:27:03,320
interesting there are standard functions

00:26:59,929 --> 00:27:06,710
like memset that behave this way memset

00:27:03,320 --> 00:27:10,549
returns a copy of its first argument did

00:27:06,710 --> 00:27:12,860
you know that I suspect a lot of people

00:27:10,549 --> 00:27:16,490
never think about the return value of

00:27:12,860 --> 00:27:18,559
memset because they didn't it's not a

00:27:16,490 --> 00:27:20,779
particularly useful thing you had to

00:27:18,559 --> 00:27:24,259
already have a copy of that argument in

00:27:20,779 --> 00:27:26,389
order to pass it in so it's very common

00:27:24,259 --> 00:27:29,029
for people to ignore the return value of

00:27:26,389 --> 00:27:31,039
a function like memset but of course

00:27:29,029 --> 00:27:33,649
there are other functions where you

00:27:31,039 --> 00:27:35,960
really don't want to ignore the return

00:27:33,649 --> 00:27:38,570
value so here for example I have a

00:27:35,960 --> 00:27:42,679
function create widget that returns a

00:27:38,570 --> 00:27:45,169
dynamically allocated widget object if I

00:27:42,679 --> 00:27:47,299
call the create widget function and I

00:27:45,169 --> 00:27:49,070
don't look at the return value or pick

00:27:47,299 --> 00:27:51,830
up pick it up and do something with it

00:27:49,070 --> 00:27:55,610
then the result of that is I have a

00:27:51,830 --> 00:27:57,259
memory because I've allocated something

00:27:55,610 --> 00:28:00,499
with new and there's no corresponding

00:27:57,259 --> 00:28:03,200
delete statement for it but so it would

00:28:00,499 --> 00:28:06,230
be nice if the compiler could warn me in

00:28:03,200 --> 00:28:08,690
this sort of situation but because some

00:28:06,230 --> 00:28:11,179
functions have return values that are

00:28:08,690 --> 00:28:14,149
often ignored the compiler doesn't

00:28:11,179 --> 00:28:16,610
really know which return values are

00:28:14,149 --> 00:28:20,330
interesting and which return values

00:28:16,610 --> 00:28:22,999
aren't unless we tell it and now we have

00:28:20,330 --> 00:28:25,369
a way to do that in c++ 17 with the no

00:28:22,999 --> 00:28:26,720
discard attribute and this is the one

00:28:25,369 --> 00:28:29,419
that I think you're probably going to

00:28:26,720 --> 00:28:32,450
use the most out of all the attributes

00:28:29,419 --> 00:28:35,600
I'm gonna mention here I think this one

00:28:32,450 --> 00:28:38,720
you know it's not that common you create

00:28:35,600 --> 00:28:40,460
a function that doesn't return but there

00:28:38,720 --> 00:28:43,999
are lots of times when you create

00:28:40,460 --> 00:28:47,090
functions where the return value really

00:28:43,999 --> 00:28:49,190
should be used for something it would be

00:28:47,090 --> 00:28:51,259
very surprising to you as the author of

00:28:49,190 --> 00:28:54,830
this function if no one picked up the

00:28:51,259 --> 00:28:56,929
return value and did anything with it so

00:28:54,830 --> 00:28:57,500
if I declared my create widget function

00:28:56,929 --> 00:29:00,440
no too

00:28:57,500 --> 00:29:03,140
start then the compiler should give me a

00:29:00,440 --> 00:29:06,230
warning if I don't actually use the

00:29:03,140 --> 00:29:08,060
return value for anything if I just drop

00:29:06,230 --> 00:29:11,480
it on the floor I should get some sort

00:29:08,060 --> 00:29:13,520
of warning from the compiler so you can

00:29:11,480 --> 00:29:16,220
think of this in some respect as the

00:29:13,520 --> 00:29:19,460
opposite of maybe unused the point of

00:29:16,220 --> 00:29:22,550
maybe unused was to silence a compiler

00:29:19,460 --> 00:29:24,080
warning where you knew you wanted to

00:29:22,550 --> 00:29:27,890
ignore something and you needed to tell

00:29:24,080 --> 00:29:30,200
the compiler to that for no discard the

00:29:27,890 --> 00:29:32,510
point is I didn't mean to ignore this

00:29:30,200 --> 00:29:36,860
thing I want you to specifically prompt

00:29:32,510 --> 00:29:40,790
me to make sure that I use it if I if I

00:29:36,860 --> 00:29:43,100
forget to do so so it's not surprising

00:29:40,790 --> 00:29:45,980
perhaps that let that in the same way

00:29:43,100 --> 00:29:49,610
maybe unused is thought of as a request

00:29:45,980 --> 00:29:51,950
not a command let's say the compiler

00:29:49,610 --> 00:29:54,980
does its best job the best job it can to

00:29:51,950 --> 00:29:57,020
try and figure out if you're not using

00:29:54,980 --> 00:30:00,260
the return value of a no discard

00:29:57,020 --> 00:30:04,040
function but it's possible it might not

00:30:00,260 --> 00:30:06,410
catch everything so it's not 100%

00:30:04,040 --> 00:30:08,420
ironclad but it can certainly be helpful

00:30:06,410 --> 00:30:11,660
in terms of preventing these sorts of

00:30:08,420 --> 00:30:14,210
mistakes now another place that you'll

00:30:11,660 --> 00:30:16,580
commonly see this used is you have

00:30:14,210 --> 00:30:19,820
functions that use their return values

00:30:16,580 --> 00:30:21,860
to indicate error conditions there are

00:30:19,820 --> 00:30:27,320
lots of standard C functions that return

00:30:21,860 --> 00:30:30,350
yo F on failure so because these

00:30:27,320 --> 00:30:33,260
functions often succeed we're used to

00:30:30,350 --> 00:30:35,960
them succeeding most of the time it's

00:30:33,260 --> 00:30:40,010
easy for us to forget to check for yo F

00:30:35,960 --> 00:30:42,380
and not actually write the code to

00:30:40,010 --> 00:30:44,840
handle the failure case and if these

00:30:42,380 --> 00:30:47,990
functions were declared no discard it

00:30:44,840 --> 00:30:50,570
would be we would get that prompt from

00:30:47,990 --> 00:30:52,130
the compiler that would force us to

00:30:50,570 --> 00:30:54,200
think a little bit more about that error

00:30:52,130 --> 00:30:56,720
condition so this is another place that

00:30:54,200 --> 00:30:58,820
notice cards can be helpful and one of

00:30:56,720 --> 00:31:01,310
the ways that you can make that a little

00:30:58,820 --> 00:31:04,130
bit easier is that you can in addition

00:31:01,310 --> 00:31:07,370
to no discard functions you can have no

00:31:04,130 --> 00:31:10,490
discard types so when you declare a

00:31:07,370 --> 00:31:11,389
class or enumeration type you can

00:31:10,490 --> 00:31:14,719
declare it with

00:31:11,389 --> 00:31:19,039
no discard attribute and what that does

00:31:14,719 --> 00:31:21,519
is any function that returns a type that

00:31:19,039 --> 00:31:25,009
was declared as a no discard type is

00:31:21,519 --> 00:31:27,440
implicitly a no discard function so here

00:31:25,009 --> 00:31:29,869
I have an enumeration error code that

00:31:27,440 --> 00:31:33,079
lists out a number of different return

00:31:29,869 --> 00:31:34,700
values from from a function a number of

00:31:33,079 --> 00:31:37,279
different behaviors that the function

00:31:34,700 --> 00:31:39,619
could have had I declare that no discard

00:31:37,279 --> 00:31:42,049
and then I don't need to place no

00:31:39,619 --> 00:31:44,869
discard on functions that return error

00:31:42,049 --> 00:31:49,219
codes because they're all implicitly no

00:31:44,869 --> 00:31:51,919
discard because it's on the type so this

00:31:49,219 --> 00:31:57,589
can reduce some of that clutter a little

00:31:51,919 --> 00:31:59,809
bit so another attribute here we're

00:31:57,589 --> 00:32:02,509
getting into the attributes from C++ 20

00:31:59,809 --> 00:32:04,159
so some of these are things that you

00:32:02,509 --> 00:32:06,859
might not necessarily have access to

00:32:04,159 --> 00:32:07,729
just yet but they are thinking but one

00:32:06,859 --> 00:32:11,659
of the things that's nice about

00:32:07,729 --> 00:32:14,119
attributes is if the compiler doesn't

00:32:11,659 --> 00:32:17,690
understand a double bracketed attribute

00:32:14,119 --> 00:32:20,779
it's required to ignore it so there's

00:32:17,690 --> 00:32:24,129
not that much harm in using it even if

00:32:20,779 --> 00:32:26,929
your compiler doesn't understand it so

00:32:24,129 --> 00:32:29,809
when you write code that includes a

00:32:26,929 --> 00:32:34,989
branch an if statement a while loop

00:32:29,809 --> 00:32:38,299
things like that uh usually it's not a

00:32:34,989 --> 00:32:41,719
50/50 split which branch is going to be

00:32:38,299 --> 00:32:44,059
taken often one branch is more likely

00:32:41,719 --> 00:32:46,549
than another branch so here for example

00:32:44,059 --> 00:32:49,339
I have a function factorial that

00:32:46,549 --> 00:32:55,039
calculates factorial values recursively

00:32:49,339 --> 00:32:58,909
and meant most of the time when I pass

00:32:55,039 --> 00:33:00,440
when I call this function it's probably

00:32:58,909 --> 00:33:03,109
going to be calling on a value larger

00:33:00,440 --> 00:33:05,690
than it was so in many cases I'm going

00:33:03,109 --> 00:33:07,759
to fall down into the recursion case I'm

00:33:05,690 --> 00:33:11,209
not going to go into the terminate case

00:33:07,759 --> 00:33:16,299
of just returning one when I get down to

00:33:11,209 --> 00:33:20,599
factorial of 1 so if the compiler knew

00:33:16,299 --> 00:33:23,959
that it was more likely to fall into the

00:33:20,599 --> 00:33:24,659
else case rather than taking the first

00:33:23,959 --> 00:33:27,690
if

00:33:24,659 --> 00:33:30,690
here it might be able to generate more

00:33:27,690 --> 00:33:33,149
efficient code and in C++ 20 we have a

00:33:30,690 --> 00:33:37,229
way of giving it that hint with the

00:33:33,149 --> 00:33:41,309
likely attribute so we can attach likely

00:33:37,229 --> 00:33:44,340
to an else case like this and that tells

00:33:41,309 --> 00:33:47,279
the compiler that it should it's free to

00:33:44,340 --> 00:33:50,669
make the assumption that that is the

00:33:47,279 --> 00:33:52,919
most likely situation from the most

00:33:50,669 --> 00:33:55,820
likely outcome from this if statement

00:33:52,919 --> 00:33:57,989
and it can optimize accordingly and

00:33:55,820 --> 00:34:00,239
unsurprisingly just like there's a

00:33:57,989 --> 00:34:02,099
likely attribute there's an unlikely

00:34:00,239 --> 00:34:03,809
attribute that lets you tell the

00:34:02,099 --> 00:34:08,129
compiler that a particular branch is

00:34:03,809 --> 00:34:11,760
less likely than others to be taken so

00:34:08,129 --> 00:34:15,030
if you have more than two cases here in

00:34:11,760 --> 00:34:18,299
this case I just have an if and an else

00:34:15,030 --> 00:34:20,190
and so the effect of saying likely on

00:34:18,299 --> 00:34:24,119
one versus unlikely on the other is

00:34:20,190 --> 00:34:27,000
likely to be the same thing but if I

00:34:24,119 --> 00:34:28,530
have several different branches then I

00:34:27,000 --> 00:34:31,409
might want to tag some of them as likely

00:34:28,530 --> 00:34:35,309
some of them is unlikely and it could be

00:34:31,409 --> 00:34:39,869
a more complex situation yes case

00:34:35,309 --> 00:34:42,510
statements normally the way out I think

00:34:39,869 --> 00:34:45,960
of a compiler is executing a case state

00:34:42,510 --> 00:34:49,289
a switch case statement is with a jump

00:34:45,960 --> 00:34:51,419
table so normally so I wouldn't normally

00:34:49,289 --> 00:34:54,029
think of that as something where I'd

00:34:51,419 --> 00:35:02,480
expect to get much benefit out of the

00:34:54,029 --> 00:35:02,480
likely attribute that's that's true yes

00:35:02,569 --> 00:35:09,720
everywhere I've seen likely and unlikely

00:35:05,789 --> 00:35:12,210
used so far it's on a more traditional

00:35:09,720 --> 00:35:14,819
an if statement or something like that

00:35:12,210 --> 00:35:16,260
but it might be something that you can

00:35:14,819 --> 00:35:19,789
also use on a case statement I have to

00:35:16,260 --> 00:35:19,789
i'd have to go back and check on that

00:35:20,809 --> 00:35:24,529
inside complex

00:35:28,360 --> 00:35:36,190
inside of a complex of boolean

00:35:30,640 --> 00:35:38,920
conditional what the question was can I

00:35:36,190 --> 00:35:41,830
include that these attributes somewhere

00:35:38,920 --> 00:35:44,170
in the middle of a conditional and have

00:35:41,830 --> 00:35:46,060
that effect short-circuit logic I don't

00:35:44,170 --> 00:35:48,850
believe so I'm maybe I'm

00:35:46,060 --> 00:35:51,940
misunderstanding what you're picturing

00:35:48,850 --> 00:35:56,020
here but this short-circuit evaluation

00:35:51,940 --> 00:35:57,970
is just a the if condition we'll have

00:35:56,020 --> 00:36:09,150
there is the same result one way or the

00:35:57,970 --> 00:36:09,150
other if a or b and b oh you're I

00:36:10,260 --> 00:36:16,320
haven't I haven't seen it used that way

00:36:27,240 --> 00:36:38,950
I can't I I don't believe it can be used

00:36:36,520 --> 00:36:41,050
in that context but I it but I'll check

00:36:38,950 --> 00:36:45,580
on that that's an interesting suggestion

00:36:41,050 --> 00:36:55,540
yes where does it go in a ternary

00:36:45,580 --> 00:37:03,820
statement I believe let's see in the

00:36:55,540 --> 00:37:07,870
case of the ternary I I want to say that

00:37:03,820 --> 00:37:11,580
it goes if you wanted the question mark

00:37:07,870 --> 00:37:14,050
branch to be the likely scenario I

00:37:11,580 --> 00:37:20,080
believe it goes after the question mark

00:37:14,050 --> 00:37:22,270
but I need to double check on that now

00:37:20,080 --> 00:37:24,370
one thing before you get too

00:37:22,270 --> 00:37:28,840
enthusiastic about this one thing that I

00:37:24,370 --> 00:37:32,650
should say here is that these attributes

00:37:28,840 --> 00:37:35,290
are designed to be used sparingly you

00:37:32,650 --> 00:37:37,210
shouldn't take this as advice to go off

00:37:35,290 --> 00:37:39,790
and just every time you write an if

00:37:37,210 --> 00:37:40,940
condition put like Leon's on something

00:37:39,790 --> 00:37:44,150
or unlikely on

00:37:40,940 --> 00:37:47,900
branch this should be something that you

00:37:44,150 --> 00:37:52,430
do in response to information from

00:37:47,900 --> 00:37:54,680
profiler or other or when you have other

00:37:52,430 --> 00:37:57,020
information that would suggest that you

00:37:54,680 --> 00:37:59,900
really want to give the compiler this

00:37:57,020 --> 00:38:02,300
hint in this case if you just the

00:37:59,900 --> 00:38:04,580
standard draft actually goes so far as

00:38:02,300 --> 00:38:06,560
to say that excessive usage of either of

00:38:04,580 --> 00:38:09,590
these attributes is liable to result in

00:38:06,560 --> 00:38:11,840
performance degradation so it is

00:38:09,590 --> 00:38:14,450
possible if you you if you miss you it's

00:38:11,840 --> 00:38:16,580
these that it could be what we sometimes

00:38:14,450 --> 00:38:18,560
call a pessimist whether than an

00:38:16,580 --> 00:38:23,240
optimization it could make your code

00:38:18,560 --> 00:38:26,090
slower rather than faster so you want to

00:38:23,240 --> 00:38:32,680
be a little judicious in your use of

00:38:26,090 --> 00:38:35,840
likely and unlikely so the next example

00:38:32,680 --> 00:38:38,420
involves I think it comes up most

00:38:35,840 --> 00:38:41,870
commonly when you're doing situations

00:38:38,420 --> 00:38:44,150
like policy based design so if I think

00:38:41,870 --> 00:38:46,460
most people who are familiar with this

00:38:44,150 --> 00:38:49,460
came to it through Andre Alexandre

00:38:46,460 --> 00:38:55,220
Steve's book modern C++ design which

00:38:49,460 --> 00:38:56,930
actually predates modern C++ but it's

00:38:55,220 --> 00:39:01,160
like that sort of thing happens

00:38:56,930 --> 00:39:05,060
sometimes with titles and the the idea

00:39:01,160 --> 00:39:09,560
behind policy based design is that you

00:39:05,060 --> 00:39:15,410
want to write one class of one

00:39:09,560 --> 00:39:18,290
conceptual class type that has a set of

00:39:15,410 --> 00:39:21,770
behaviors that you can choose between at

00:39:18,290 --> 00:39:25,340
compile time so rather than having to

00:39:21,770 --> 00:39:28,940
write several different versions of a

00:39:25,340 --> 00:39:33,200
class that differ only in terms of how

00:39:28,940 --> 00:39:36,590
they allocate memory for example you can

00:39:33,200 --> 00:39:39,260
write one class template that uses an

00:39:36,590 --> 00:39:41,990
allocation policy like I'm showing here

00:39:39,260 --> 00:39:45,800
and then by supplying different

00:39:41,990 --> 00:39:48,080
allocation policies at compile time you

00:39:45,800 --> 00:39:52,630
get the performance as if you had

00:39:48,080 --> 00:39:54,410
written several different classes but

00:39:52,630 --> 00:39:56,750
you you own

00:39:54,410 --> 00:39:58,880
we have the maintenance cost of actually

00:39:56,750 --> 00:40:02,930
having to maintain that one class

00:39:58,880 --> 00:40:06,859
template so in this case I'm using two

00:40:02,930 --> 00:40:09,319
different policy plastic policies with

00:40:06,859 --> 00:40:11,539
my class foo here I have an allocation

00:40:09,319 --> 00:40:14,000
policy for determining how it allocates

00:40:11,539 --> 00:40:17,089
memory and I have a comparison policy

00:40:14,000 --> 00:40:21,859
for indicating how two objects should be

00:40:17,089 --> 00:40:23,630
compared to each other and I am I'm

00:40:21,859 --> 00:40:27,109
including them as data members in my

00:40:23,630 --> 00:40:28,940
class too if you if you read Andres book

00:40:27,109 --> 00:40:31,069
you'll know that he does things a little

00:40:28,940 --> 00:40:32,200
bit differently and I'll explain why in

00:40:31,069 --> 00:40:35,240
just a moment

00:40:32,200 --> 00:40:38,030
but for now let's just take a look at

00:40:35,240 --> 00:40:41,539
this picture here where we have the two

00:40:38,030 --> 00:40:44,359
out policies as data members now they

00:40:41,539 --> 00:40:46,700
might have state associate information

00:40:44,359 --> 00:40:48,950
associated with them but then again they

00:40:46,700 --> 00:40:52,220
might not it's not uncommon for these

00:40:48,950 --> 00:40:54,950
policies not have any data so for

00:40:52,220 --> 00:40:58,309
example here's an allocation policy that

00:40:54,950 --> 00:41:00,380
just uses the standard new and delete it

00:40:58,309 --> 00:41:05,630
doesn't need to track in the state in

00:41:00,380 --> 00:41:08,599
order to handle these allocations so my

00:41:05,630 --> 00:41:10,940
a locator just has member functions no

00:41:08,599 --> 00:41:13,910
data members and this is not an uncommon

00:41:10,940 --> 00:41:15,589
thing to see with policy classes the

00:41:13,910 --> 00:41:18,859
same thing can be true of my comparison

00:41:15,589 --> 00:41:22,400
policy here I have I have a policy that

00:41:18,859 --> 00:41:23,480
just compares two values using the less

00:41:22,400 --> 00:41:25,970
than operator

00:41:23,480 --> 00:41:29,299
it doesn't need any state to make these

00:41:25,970 --> 00:41:31,730
sorts of comparisons there are other

00:41:29,299 --> 00:41:34,819
policies that I could have used that

00:41:31,730 --> 00:41:37,220
might have a state and then I and then

00:41:34,819 --> 00:41:41,089
having these things as data members in

00:41:37,220 --> 00:41:43,730
this case would be important but in this

00:41:41,089 --> 00:41:46,789
particular case I'm using policies that

00:41:43,730 --> 00:41:49,640
don't have data members but the thing is

00:41:46,789 --> 00:41:52,940
that class objects in C++ have to have a

00:41:49,640 --> 00:41:56,329
size of at least one even if a class has

00:41:52,940 --> 00:42:00,529
no data members it occupies at least one

00:41:56,329 --> 00:42:02,510
byte of storage doesn't matter that's

00:42:00,529 --> 00:42:07,250
just the nature of how some plus plus

00:42:02,510 --> 00:42:10,370
works and so the result of that is

00:42:07,250 --> 00:42:13,100
using these policies as data members I

00:42:10,370 --> 00:42:16,910
can wind up with a bigger class than I

00:42:13,100 --> 00:42:18,740
would expect to have because each one of

00:42:16,910 --> 00:42:22,520
those policies has to be at least size

00:42:18,740 --> 00:42:26,090
one so in this case foo has to have at

00:42:22,520 --> 00:42:27,650
least two from a Lok and comp plus

00:42:26,090 --> 00:42:30,860
whatever additional storage it would

00:42:27,650 --> 00:42:33,200
have for its other data members and this

00:42:30,860 --> 00:42:37,370
can be you know a meaningful percentage

00:42:33,200 --> 00:42:39,910
of the total size of the foo object can

00:42:37,370 --> 00:42:42,860
make my codes slower and less efficient

00:42:39,910 --> 00:42:45,320
so one way that we could solve this

00:42:42,860 --> 00:42:47,240
problem would be to inherit from the

00:42:45,320 --> 00:42:50,630
policy types rather than making them

00:42:47,240 --> 00:42:53,960
data members it turns out that base

00:42:50,630 --> 00:42:57,590
class sub objects are somewhat special

00:42:53,960 --> 00:43:00,260
in C++ every class object has to have a

00:42:57,590 --> 00:43:05,270
size of at least one and that's true

00:43:00,260 --> 00:43:07,750
even of base class sub objects but when

00:43:05,270 --> 00:43:10,910
you if you derived from a clock from a

00:43:07,750 --> 00:43:14,690
from a base class that has no data

00:43:10,910 --> 00:43:18,290
members that doesn't necessarily

00:43:14,690 --> 00:43:21,350
increase the size of the derived class

00:43:18,290 --> 00:43:23,960
object what you can think about is so in

00:43:21,350 --> 00:43:28,160
this situation here where I have two

00:43:23,960 --> 00:43:30,740
policy classes a load policy and comp

00:43:28,160 --> 00:43:33,080
policy neither one if neither one has

00:43:30,740 --> 00:43:37,190
any data members they both have to be at

00:43:33,080 --> 00:43:39,350
least size one but the way that but the

00:43:37,190 --> 00:43:41,150
standard allows for the possibility that

00:43:39,350 --> 00:43:42,620
that one white they're required to have

00:43:41,150 --> 00:43:46,910
is shared

00:43:42,620 --> 00:43:49,790
they're both occupy the same storage so

00:43:46,910 --> 00:43:52,880
the result of deriving in this case

00:43:49,790 --> 00:43:55,490
rather than using these than using

00:43:52,880 --> 00:43:59,720
composition is that my foo object could

00:43:55,490 --> 00:44:01,760
be smaller so this might provide

00:43:59,720 --> 00:44:04,460
benefits in terms of reducing the size

00:44:01,760 --> 00:44:07,130
on the other hand I might not want to

00:44:04,460 --> 00:44:08,750
derive from these things it's possible

00:44:07,130 --> 00:44:11,450
that these policies aren't really

00:44:08,750 --> 00:44:14,030
designed to be used as base classes

00:44:11,450 --> 00:44:16,700
depending on how I've structured my type

00:44:14,030 --> 00:44:19,070
in this case the two policy classes that

00:44:16,700 --> 00:44:20,980
I showed you they don't have virtual

00:44:19,070 --> 00:44:22,990
destructors or any other

00:44:20,980 --> 00:44:26,020
virtual functions like we would normally

00:44:22,990 --> 00:44:28,570
expect from classes that we would use as

00:44:26,020 --> 00:44:31,690
base classes so it's not clear that

00:44:28,570 --> 00:44:37,030
deriving really gives me the behavior I

00:44:31,690 --> 00:44:39,340
want in this case so in C++ 20 will have

00:44:37,030 --> 00:44:42,340
another way of doing this which is of

00:44:39,340 --> 00:44:46,330
creating sub objects with an effective

00:44:42,340 --> 00:44:49,990
size of 0 and it's this no unique

00:44:46,330 --> 00:44:54,040
address attribute so in this case I

00:44:49,990 --> 00:44:56,410
could go back to using my own my

00:44:54,040 --> 00:44:59,770
allocation and compass comparison

00:44:56,410 --> 00:45:04,480
policies as data members and declare

00:44:59,770 --> 00:45:07,750
them with no unique address and they

00:45:04,480 --> 00:45:09,220
would be allowed to shares that space in

00:45:07,750 --> 00:45:12,730
the same way that they would have been

00:45:09,220 --> 00:45:16,240
allowed to if they were base class sub

00:45:12,730 --> 00:45:18,600
objects so this allows us to avoid

00:45:16,240 --> 00:45:23,140
creating unwanted inheritance

00:45:18,600 --> 00:45:26,740
relationships in this situation there's

00:45:23,140 --> 00:45:29,109
a the know unique address attribute has

00:45:26,740 --> 00:45:31,990
to be applied to non static data members

00:45:29,109 --> 00:45:33,790
it doesn't work for for static data

00:45:31,990 --> 00:45:35,740
members and it doesn't work for things

00:45:33,790 --> 00:45:39,850
that aren't members of classes to begin

00:45:35,740 --> 00:45:42,609
with I should say class types and when

00:45:39,850 --> 00:45:45,010
to see it the C++ standard says class

00:45:42,609 --> 00:45:51,250
types it really means classes and

00:45:45,010 --> 00:45:55,090
structs and unions now there's actually

00:45:51,250 --> 00:45:56,950
another use of no unique address for the

00:45:55,090 --> 00:45:59,350
situation where you might want to

00:45:56,950 --> 00:46:02,109
declare something no unique address even

00:45:59,350 --> 00:46:05,050
if it actually does have data members

00:46:02,109 --> 00:46:07,180
inside it so suppose I have this type

00:46:05,050 --> 00:46:09,400
little here that consists of an integer

00:46:07,180 --> 00:46:13,060
and a character and I'm compiling my

00:46:09,400 --> 00:46:15,250
code on a typical 32-bit black mat what

00:46:13,060 --> 00:46:19,869
I think I would expect to see on most

00:46:15,250 --> 00:46:21,520
32-bit platforms for this struct is that

00:46:19,869 --> 00:46:24,790
the memory layout would look something

00:46:21,520 --> 00:46:27,790
like that table there so first we would

00:46:24,790 --> 00:46:29,410
have four bytes for the integer then we

00:46:27,790 --> 00:46:32,080
would have one byte for the character

00:46:29,410 --> 00:46:34,440
and then there would be three padding

00:46:32,080 --> 00:46:36,850
bytes at the end of this

00:46:34,440 --> 00:46:40,780
to give it the product so that it's

00:46:36,850 --> 00:46:44,740
properly aligned so we have a total size

00:46:40,780 --> 00:46:47,080
of 8 for our little object and now

00:46:44,740 --> 00:46:51,640
suppose I use that little object as a

00:46:47,080 --> 00:46:54,369
data member inside another pipe big so

00:46:51,640 --> 00:46:57,480
big has two data members a little and an

00:46:54,369 --> 00:46:59,860
array of three characters called ID I

00:46:57,480 --> 00:47:02,500
think the memory layout on that same

00:46:59,860 --> 00:47:05,440
32-bit platform would typically look

00:47:02,500 --> 00:47:07,480
like this where you have again four

00:47:05,440 --> 00:47:09,280
bytes for the integer from little one

00:47:07,480 --> 00:47:11,619
byte for the character from little and

00:47:09,280 --> 00:47:16,510
then three padding bytes in the little

00:47:11,619 --> 00:47:19,450
object and then the the three bytes for

00:47:16,510 --> 00:47:21,940
the characters in the ID member and one

00:47:19,450 --> 00:47:26,860
more padding byte at the end of the big

00:47:21,940 --> 00:47:30,280
object for total size and 12 if I

00:47:26,860 --> 00:47:35,020
declare my little object as no unique

00:47:30,280 --> 00:47:36,850
address inside the big object that has

00:47:35,020 --> 00:47:41,460
the effect of telling the compiler that

00:47:36,850 --> 00:47:44,859
its allows to reuse the padding bytes

00:47:41,460 --> 00:47:47,560
inside the will object for the purpose

00:47:44,859 --> 00:47:52,000
of storing other data from the big

00:47:47,560 --> 00:47:54,369
object so by declaring little to be no

00:47:52,000 --> 00:47:56,170
unique address I think in many cases

00:47:54,369 --> 00:47:59,200
what you would see is that that would

00:47:56,170 --> 00:48:01,300
reduce the size of my big object down to

00:47:59,200 --> 00:48:03,880
eight because now I would have four

00:48:01,300 --> 00:48:07,420
bytes for the integer one byte for the

00:48:03,880 --> 00:48:09,430
character from little and then three and

00:48:07,420 --> 00:48:12,369
then instead of having three padding

00:48:09,430 --> 00:48:14,920
bytes at the end of live littlez that

00:48:12,369 --> 00:48:18,480
storage would be reused to store the

00:48:14,920 --> 00:48:21,280
three characters in the ID member of big

00:48:18,480 --> 00:48:24,609
it's like this so this can help save

00:48:21,280 --> 00:48:37,660
space in another way same similar

00:48:24,609 --> 00:48:39,760
behavior yes yes you if you you're

00:48:37,660 --> 00:48:43,090
saying if you try to if you get a

00:48:39,760 --> 00:48:47,619
memsource and you used size of little

00:48:43,090 --> 00:48:48,040
for exaggerate the question you the

00:48:47,619 --> 00:48:51,430
question

00:48:48,040 --> 00:48:54,760
if I do a memset on the little part of a

00:48:51,430 --> 00:48:56,580
big object what happens and what happens

00:48:54,760 --> 00:49:00,070
is yes it would it would potentially

00:48:56,580 --> 00:49:02,770
overwrite data outside of the Whittle

00:49:00,070 --> 00:49:07,240
object assuming you're using size of

00:49:02,770 --> 00:49:10,240
little as your as the Dury the length of

00:49:07,240 --> 00:49:11,860
the medicine because that little objects

00:49:10,240 --> 00:49:14,680
well it's right there in the main it

00:49:11,860 --> 00:49:17,140
doesn't have a unique address it's if

00:49:14,680 --> 00:49:21,220
you overwrite that memory you could also

00:49:17,140 --> 00:49:24,880
be over writing something else I think

00:49:21,220 --> 00:49:32,560
there was another question here are you

00:49:24,880 --> 00:49:37,470
allowed to take the address of L could

00:49:32,560 --> 00:49:37,470
you even feed the address of L to memset

00:49:37,560 --> 00:49:44,460
yes I believe you can yes it's that the

00:49:41,740 --> 00:49:44,460
thing is that

00:49:44,640 --> 00:49:51,880
yeah the tricky part about it is the

00:49:47,860 --> 00:49:54,400
size of little isn't that is the size of

00:49:51,880 --> 00:49:56,530
the little member inside of a big in

00:49:54,400 --> 00:49:58,350
some sense is different from size of

00:49:56,530 --> 00:50:01,510
little when it's a standalone type

00:49:58,350 --> 00:50:09,130
that's where it kind of becomes a little

00:50:01,510 --> 00:50:11,110
murky no you know if you actually take

00:50:09,130 --> 00:50:13,360
size of L you'll get the size of a

00:50:11,110 --> 00:50:15,850
little object the other question was

00:50:13,360 --> 00:50:23,830
what the size of L get affected by this

00:50:15,850 --> 00:50:26,800
and no it doesn't yes well we're just

00:50:23,830 --> 00:50:28,600
about to say yes that the question was

00:50:26,800 --> 00:50:31,620
how does this affect alignment and the

00:50:28,600 --> 00:50:35,140
question the answer is it doesn't this

00:50:31,620 --> 00:50:38,170
what I showed you in this example worked

00:50:35,140 --> 00:50:41,890
well because characters have a size of 1

00:50:38,170 --> 00:50:45,010
an alignment of 1 so it was easy for the

00:50:41,890 --> 00:50:47,350
character data to reuse the padding from

00:50:45,010 --> 00:50:50,500
another structure because it has very

00:50:47,350 --> 00:50:53,170
loose alignment requirements if the

00:50:50,500 --> 00:50:56,530
other data members in big had more

00:50:53,170 --> 00:50:59,470
strict alignment requirements then they

00:50:56,530 --> 00:51:01,859
still have to be aligned properly so

00:50:59,470 --> 00:51:04,800
even if there might be

00:51:01,859 --> 00:51:07,170
that could be you that could

00:51:04,800 --> 00:51:08,730
theoretically store an object if that

00:51:07,170 --> 00:51:10,200
object has a stricter alignment

00:51:08,730 --> 00:51:12,650
requirement the compiler won't

00:51:10,200 --> 00:51:15,930
necessarily choose to use that packet

00:51:12,650 --> 00:51:18,960
the other restriction is that if you

00:51:15,930 --> 00:51:21,000
have two data members of the same type

00:51:18,960 --> 00:51:24,720
they can't overlap even if they're

00:51:21,000 --> 00:51:29,220
declared no unique address even if

00:51:24,720 --> 00:51:30,930
they're empty it's just it's I believe

00:51:29,220 --> 00:51:34,020
the way to think about it is that you

00:51:30,930 --> 00:51:36,930
that you go back to suppose I have an

00:51:34,020 --> 00:51:39,990
array of objects that contain no data

00:51:36,930 --> 00:51:41,490
members if if there were oh if the

00:51:39,990 --> 00:51:44,490
objects were allowed to have a size of

00:51:41,490 --> 00:51:47,400
zero how could what would mean to plus

00:51:44,490 --> 00:51:49,830
plus a pointer on that array adds zero

00:51:47,400 --> 00:51:52,890
to the size of the thing you wouldn't be

00:51:49,830 --> 00:51:54,750
able to step through it and so I believe

00:51:52,890 --> 00:51:57,930
that the same behavior is what's

00:51:54,750 --> 00:51:59,820
underlies the faculty that two objects

00:51:57,930 --> 00:52:03,390
of the same type even if they're both

00:51:59,820 --> 00:52:13,830
declared no unique address can it can't

00:52:03,390 --> 00:52:15,690
really share space well I'm the question

00:52:13,830 --> 00:52:17,310
was how does that duck does that

00:52:15,690 --> 00:52:20,880
interfere with the previous example I

00:52:17,310 --> 00:52:44,369
miss I'm not sure I'm following what

00:52:20,880 --> 00:52:46,910
your concern is their right oh I think I

00:52:44,369 --> 00:52:50,339
see what you're saying that back here

00:52:46,910 --> 00:52:52,550
yes I was using characters in the last

00:52:50,339 --> 00:52:55,320
thing in in Whittle was a character and

00:52:52,550 --> 00:53:01,109
the first thing after that even big was

00:52:55,320 --> 00:53:03,599
a character and is that a problem and no

00:53:01,109 --> 00:53:09,060
it's not because it consists thinks of

00:53:03,599 --> 00:53:10,830
them in terms of the it's thinking about

00:53:09,060 --> 00:53:15,740
it in terms of the structure type little

00:53:10,830 --> 00:53:15,740
not the things that go inside a little

00:53:17,810 --> 00:53:24,180
okay

00:53:20,330 --> 00:53:27,420
so yes so in this situation even though

00:53:24,180 --> 00:53:30,000
I have two two objects declared no

00:53:27,420 --> 00:53:32,100
unique address that have no storage they

00:53:30,000 --> 00:53:34,590
I would wind up having a struct that was

00:53:32,100 --> 00:53:38,550
at least size to because the two a

00:53:34,590 --> 00:53:43,800
locators which need their own phantom

00:53:38,550 --> 00:53:46,320
storage so so far I've been talking

00:53:43,800 --> 00:53:48,180
about the standard attributes but I also

00:53:46,320 --> 00:53:49,230
want to touch a little bit on the

00:53:48,180 --> 00:53:52,170
non-standard

00:53:49,230 --> 00:53:54,510
attributes I mentioned before that one

00:53:52,170 --> 00:53:57,660
of the reasons that this was introduced

00:53:54,510 --> 00:54:01,980
into the standard was so that compilers

00:53:57,660 --> 00:54:05,100
would have a way of using this syntax to

00:54:01,980 --> 00:54:10,290
implement extensions that could be used

00:54:05,100 --> 00:54:12,750
without reducing portability so but they

00:54:10,290 --> 00:54:16,320
don't in order to make sure that

00:54:12,750 --> 00:54:19,109
whatever attributes a particular

00:54:16,320 --> 00:54:22,830
compiler implements as extensions don't

00:54:19,109 --> 00:54:27,210
interfere with future named choices for

00:54:22,830 --> 00:54:29,220
possible standard attributes compilers

00:54:27,210 --> 00:54:31,140
are supposed to place their compiler

00:54:29,220 --> 00:54:35,400
specific attributes into attribute

00:54:31,140 --> 00:54:38,070
namespaces so the new attribute cold

00:54:35,400 --> 00:54:41,100
that I showed you earlier if you want to

00:54:38,070 --> 00:54:43,320
use that as a modern C++ double square

00:54:41,100 --> 00:54:51,570
bracket and attribute it looks like this

00:54:43,320 --> 00:54:53,250
the new colon colon code told so one

00:54:51,570 --> 00:54:56,420
complication on this I've been telling

00:54:53,250 --> 00:54:59,130
you that compilers will ignore

00:54:56,420 --> 00:55:01,980
attributes that they don't recognize and

00:54:59,130 --> 00:55:05,640
that's true they won't let it affect the

00:55:01,980 --> 00:55:10,050
generated code but they might warn you

00:55:05,640 --> 00:55:11,940
about it and this is a this is a

00:55:10,050 --> 00:55:16,320
double-edged sword it's a blessing and a

00:55:11,940 --> 00:55:19,170
curse because if I misspelled deprecated

00:55:16,320 --> 00:55:21,540
as deprecated here it's nice that the

00:55:19,170 --> 00:55:24,030
compiler can tell me you spelled

00:55:21,540 --> 00:55:26,789
something wrong I don't recognize the

00:55:24,030 --> 00:55:33,749
attribute that you were trying to use

00:55:26,789 --> 00:55:36,829
in this case so so give me a warning in

00:55:33,749 --> 00:55:39,089
that situation but it's annoying that

00:55:36,829 --> 00:55:41,069
well-formed attributes that the compiler

00:55:39,089 --> 00:55:43,349
doesn't understand could still elicit

00:55:41,069 --> 00:55:45,449
warnings because the compiler doesn't

00:55:43,349 --> 00:55:49,319
support them specifically extension

00:55:45,449 --> 00:55:51,419
stuff like this so what you might how

00:55:49,319 --> 00:55:53,400
can you solve this problem because we

00:55:51,419 --> 00:55:57,929
generally don't like to ignore warnings

00:55:53,400 --> 00:56:00,390
you could disable warnings unfortunately

00:55:57,929 --> 00:56:04,019
a lot of compilers use one warning code

00:56:00,390 --> 00:56:07,109
for all unrecognized attributes so

00:56:04,019 --> 00:56:09,269
that's a little bit so you kind of have

00:56:07,109 --> 00:56:11,579
to use a blanket approach to that in

00:56:09,269 --> 00:56:14,609
some situations and you wouldn't be able

00:56:11,579 --> 00:56:17,429
to detect misspelled attributes now you

00:56:14,609 --> 00:56:19,679
might be able to to make it work by

00:56:17,429 --> 00:56:22,650
compiling it so that the warning is only

00:56:19,679 --> 00:56:26,160
disabled in certain build modes so for

00:56:22,650 --> 00:56:28,829
example in debug mode you could you

00:56:26,160 --> 00:56:30,660
could enable the warning and that would

00:56:28,829 --> 00:56:32,279
and you would see warnings about

00:56:30,660 --> 00:56:34,890
attributes in the code that you're

00:56:32,279 --> 00:56:37,349
currently working on but then when you

00:56:34,890 --> 00:56:40,709
go to submit your code and compile for

00:56:37,349 --> 00:56:43,409
release then you wouldn't see all of

00:56:40,709 --> 00:56:46,289
these warnings crop up in the generated

00:56:43,409 --> 00:56:48,569
code that would be one approach I think

00:56:46,289 --> 00:56:50,099
a more common approach is what you often

00:56:48,569 --> 00:56:52,529
see people do is they wrap up active

00:56:50,099 --> 00:56:55,019
attributes in macros that look like this

00:56:52,529 --> 00:56:58,529
so they test to see whether the compiler

00:56:55,019 --> 00:57:01,739
supports a macro a particular attribute

00:56:58,529 --> 00:57:03,900
and then they create attributes or they

00:57:01,739 --> 00:57:06,089
create macros that translate to those

00:57:03,900 --> 00:57:09,749
attributes if the compiler actually

00:57:06,089 --> 00:57:11,400
supports them or and if the compiler

00:57:09,749 --> 00:57:14,519
doesn't support them they translate into

00:57:11,400 --> 00:57:18,959
nothing they just go away so in this

00:57:14,519 --> 00:57:22,289
situation here I have a I created a

00:57:18,959 --> 00:57:24,269
macro deprecated message that uses the

00:57:22,289 --> 00:57:26,609
form of deprecated with a string literal

00:57:24,269 --> 00:57:30,150
and then I can use deprecated the

00:57:26,609 --> 00:57:33,390
deprecated message macro instead of the

00:57:30,150 --> 00:57:35,219
actual deprecated attribute now that's

00:57:33,390 --> 00:57:36,839
kind of annoying for conditional

00:57:35,219 --> 00:57:39,809
compilation but one of the things that

00:57:36,839 --> 00:57:40,380
makes it easier is that the standard

00:57:39,809 --> 00:57:43,680
includes

00:57:40,380 --> 00:57:47,369
feature test macros for these things so

00:57:43,680 --> 00:57:49,529
you don't need to do very much work to

00:57:47,369 --> 00:57:53,039
get the conditional compilation to be

00:57:49,529 --> 00:57:56,730
pretty darn accurate in this situation

00:57:53,039 --> 00:57:59,400
because the standard mandates that the

00:57:56,730 --> 00:58:02,089
compiler provide these these feature

00:57:59,400 --> 00:58:07,769
test macro definitions that you can use

00:58:02,089 --> 00:58:09,569
for preprocessor if statements so you

00:58:07,769 --> 00:58:11,910
can check to see does the compiler

00:58:09,569 --> 00:58:15,960
support C++ attributes at all

00:58:11,910 --> 00:58:19,049
that's the CPP attributes at that in the

00:58:15,960 --> 00:58:21,420
first position and then there's has CDP

00:58:19,049 --> 00:58:23,279
attribute and a the name of a specific

00:58:21,420 --> 00:58:26,400
attribute you want to know whether it

00:58:23,279 --> 00:58:30,089
supports and then you can use that to

00:58:26,400 --> 00:58:32,309
define these conditional macros in

00:58:30,089 --> 00:58:35,400
theory you can also test for other

00:58:32,309 --> 00:58:39,329
non-standard attributes in this same way

00:58:35,400 --> 00:58:43,289
the compiler encourages people vendors

00:58:39,329 --> 00:58:45,660
to make this feature test macro work for

00:58:43,289 --> 00:58:49,950
their own compiler specific attributes

00:58:45,660 --> 00:58:54,809
but it's not standard your mileage may

00:58:49,950 --> 00:58:57,119
vary now that that has CBO one thing I

00:58:54,809 --> 00:58:59,039
wanted to mention here was that you do

00:58:57,119 --> 00:59:01,289
actually need to test for both of these

00:58:59,039 --> 00:59:05,430
in my experience you might think that

00:59:01,289 --> 00:59:07,619
well if it has no discard attribute do I

00:59:05,430 --> 00:59:10,079
need the test for has superseded B

00:59:07,619 --> 00:59:11,640
attributes at all and my experience is

00:59:10,079 --> 00:59:15,269
that some compilers will actually define

00:59:11,640 --> 00:59:18,180
has see what C has to be B attribute no

00:59:15,269 --> 00:59:20,069
discard will be true even when C++

00:59:18,180 --> 00:59:24,500
executes the attributes is false if

00:59:20,069 --> 00:59:28,559
you're compiling in like C++ code 3 mode

00:59:24,500 --> 00:59:31,349
go figures the value of the attribute is

00:59:28,559 --> 00:59:34,769
actually sometimes interesting it's the

00:59:31,349 --> 00:59:37,230
time and it's the time that the most

00:59:34,769 --> 00:59:39,720
recent revision to the standard was made

00:59:37,230 --> 00:59:42,809
that the compiler supports so for

00:59:39,720 --> 00:59:45,420
example in C++ 20 no discard is getting

00:59:42,809 --> 00:59:47,430
a string literal parameter the same way

00:59:45,420 --> 00:59:49,650
that deprecated had a string literal

00:59:47,430 --> 00:59:53,250
parameter so you'll be able to explain

00:59:49,650 --> 00:59:53,790
how why you don't want to discard this

00:59:53,250 --> 00:59:57,420
thing

00:59:53,790 --> 01:00:00,750
and so in this situation you could use

00:59:57,420 --> 01:00:03,090
the the value of the has CBP attribute

01:00:00,750 --> 01:00:05,490
no discard the test to see does your

01:00:03,090 --> 01:00:08,550
compiler support that specific version

01:00:05,490 --> 01:00:14,160
of no discard and implement a macro for

01:00:08,550 --> 01:00:16,200
that so closing out prefer the double

01:00:14,160 --> 01:00:19,620
bracketed attributes over compiler

01:00:16,200 --> 01:00:21,630
specific syntax for extensions declare

01:00:19,620 --> 01:00:24,720
functions as no return if and only if

01:00:21,630 --> 01:00:27,000
they never return use deprecated to mark

01:00:24,720 --> 01:00:28,740
code that shouldn't be used marked fall

01:00:27,000 --> 01:00:32,100
through z' would fall through unused

01:00:28,740 --> 01:00:36,180
entities width may be unused and notice

01:00:32,100 --> 01:00:37,710
and use no discard to avoid ignoring

01:00:36,180 --> 01:00:41,720
return values that shouldn't be ignored

01:00:37,710 --> 01:00:41,720
and that brings me to the end

01:00:42,180 --> 01:00:49,560

YouTube URL: https://www.youtube.com/watch?v=teUA5U6eYQY


