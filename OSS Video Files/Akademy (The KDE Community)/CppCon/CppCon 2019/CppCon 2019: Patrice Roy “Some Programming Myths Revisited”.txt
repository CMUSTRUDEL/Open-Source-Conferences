Title: CppCon 2019: Patrice Roy “Some Programming Myths Revisited”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
We have been taught, or we ourselves have taught, things that we took for granted as being "good practice" in programming. Such things often stem from the "wisdom of the ancients" (although computer science being young as sciences come, some of the "ancients" are still among us and thriving today, and we're so lucky to have them!), and are in effect part of our "myths".

However, being as grounded in the science-that-there-was as these recommendations are, our ideas have evolved, so have our programming languages, and it can be interesting to revisit some of these taken-for-granted ideas.

In C++, particularly in what some call "modern C++", we find a language that is different enough from its forebears to make revisiting our "myths" interesting. How do such things as "goto considered harmful" or "only one return per function", for example, hold as "wisdom" with respect to modern C++? Do they still help us write better programs or should be rethink them under the light of modern languages and practice?

The aim of this talk is to examine what some commonly heard recommendations or advices with respect to programming practice mean in the context of "modern" C++. We will take a small set of such advices, present them in context, show how well (or how badly) they suit today's C++, and try to rephrase them if this seems advantageous.
— 
Patrice Roy
Université de Sherbrooke
Professor
Sherbrooke (Québec), Canada

Patrice Roy has been playing with C++, either professionally, for pleasure or (most of the time) both for over 25 years. After a few years doing R&D and working on military flight simulators, he moved on to academics and has been teaching computer science since 1998. Since 2005, he’s been involved more specifically in helping graduate students and professionals from the fields of real-time systems and game programming develop the skills they need to face today’s challenges. The rapid evolution of C++ in recent years has made his job even more enjoyable. He’s been a participating member in the ISO C++ Standards Committee since late 2014 and has been involved with the ISO Programming Language Vulnerabilities Committee since late 2015. He has five kids, and his wife ensures their house is home to a continuously changing number of cats, dogs and other animals.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,360 --> 00:00:12,019
good morning to you our God to meet you

00:00:10,759 --> 00:00:15,260
glad to see you

00:00:12,019 --> 00:00:17,150
if you came in here looking for

00:00:15,260 --> 00:00:20,360
examples for your next code reviews that

00:00:17,150 --> 00:00:22,010
might not be the right place which you

00:00:20,360 --> 00:00:27,590
could prep together from the title of

00:00:22,010 --> 00:00:29,990
the talk so I'm one of the committee

00:00:27,590 --> 00:00:32,000
members who've been with me become since

00:00:29,990 --> 00:00:34,610
the beginning and this morning I'm going

00:00:32,000 --> 00:00:38,390
to make my reputation go down for sure

00:00:34,610 --> 00:00:40,910
with examples of code that might not see

00:00:38,390 --> 00:00:43,070
every day or I might rather not see but

00:00:40,910 --> 00:00:45,710
I think I think it's gonna be worth it

00:00:43,070 --> 00:00:47,780
anyway there are many things that we

00:00:45,710 --> 00:00:49,370
teach I'm a teacher that we teach

00:00:47,780 --> 00:00:51,229
without thinking that we teach because

00:00:49,370 --> 00:00:53,690
we've been taught we've been said this

00:00:51,229 --> 00:00:55,820
told this is good this is bad or

00:00:53,690 --> 00:00:57,500
something and we take something for

00:00:55,820 --> 00:00:59,809
granted and I realize that when I go

00:00:57,500 --> 00:01:02,780
visit my intern students they work at

00:00:59,809 --> 00:01:04,250
shops and people have practices that

00:01:02,780 --> 00:01:05,690
have been established and nobody

00:01:04,250 --> 00:01:08,270
remembers why but they're clear they

00:01:05,690 --> 00:01:09,590
apply it and that's okay it's rules do

00:01:08,270 --> 00:01:12,170
you think that as good prior good

00:01:09,590 --> 00:01:13,909
practice and such things sometimes comes

00:01:12,170 --> 00:01:15,950
from the so called wisdom of the

00:01:13,909 --> 00:01:17,780
Ancients some interesting and right

00:01:15,950 --> 00:01:20,870
people I said this is the way things

00:01:17,780 --> 00:01:22,460
should be and sometimes well yeah that

00:01:20,870 --> 00:01:24,800
makes sense and we go along with it can

00:01:22,460 --> 00:01:26,870
we start me stop thinking so they really

00:01:24,800 --> 00:01:29,660
wear this kind of Mythology as to what

00:01:26,870 --> 00:01:33,740
good practices are which isn't good part

00:01:29,660 --> 00:01:35,120
a good thing now we are a young science

00:01:33,740 --> 00:01:37,430
and we're lucky some of the Ancients are

00:01:35,120 --> 00:01:39,560
still among us or have only recently and

00:01:37,430 --> 00:01:41,240
we take part in something really really

00:01:39,560 --> 00:01:42,590
cool we're very lucky to still have a

00:01:41,240 --> 00:01:44,420
chance among us there's some of the

00:01:42,590 --> 00:01:50,450
bright people in the building right now

00:01:44,420 --> 00:01:52,790
are incredibly nice to know since well

00:01:50,450 --> 00:01:54,260
it's a science and our IDs evolved and

00:01:52,790 --> 00:01:55,790
our languages evolved sometimes it's

00:01:54,260 --> 00:01:58,159
interesting to revisit some it's the

00:01:55,790 --> 00:01:59,990
so-called wisdom that we have because

00:01:58,159 --> 00:02:03,500
some things that were good maybe in the

00:01:59,990 --> 00:02:06,950
60s might not be so did today it's worth

00:02:03,500 --> 00:02:09,979
thinking about it at least so let's do

00:02:06,950 --> 00:02:11,390
so in particular C++ has changed quite a

00:02:09,979 --> 00:02:14,720
bit over the last few years last ten

00:02:11,390 --> 00:02:16,220
years or so and yeah it's different

00:02:14,720 --> 00:02:18,349
enough from the language that we used to

00:02:16,220 --> 00:02:21,349
have such that the practices that we had

00:02:18,349 --> 00:02:22,940
might deserve a second look sometimes

00:02:21,349 --> 00:02:25,580
I'm not saying it's always a good thing

00:02:22,940 --> 00:02:28,340
but let's take it

00:02:25,580 --> 00:02:30,470
so such things as go to considered

00:02:28,340 --> 00:02:33,920
harmful which is a very widely

00:02:30,470 --> 00:02:35,360
circulated paper only one return per

00:02:33,920 --> 00:02:37,730
function is something that deserves

00:02:35,360 --> 00:02:41,320
attention I know that my school still

00:02:37,730 --> 00:02:43,730
teaches that that's just a good thing I

00:02:41,320 --> 00:02:45,680
do these things so that post write good

00:02:43,730 --> 00:02:47,660
programs or better programs or should we

00:02:45,680 --> 00:02:52,580
rethink them under the light of modern

00:02:47,660 --> 00:02:53,600
practice so yeah so this is what we're

00:02:52,580 --> 00:02:55,700
going to do we're going to take a look

00:02:53,600 --> 00:02:57,830
at into these things maybe we'll keep on

00:02:55,700 --> 00:02:59,510
thinking the same way we do well think

00:02:57,830 --> 00:03:02,120
differently Big Buddha criticized I

00:02:59,510 --> 00:03:03,830
don't know let's see so I'm gonna take a

00:03:02,120 --> 00:03:07,400
small set of such advice a small set

00:03:03,830 --> 00:03:09,640
like 3/4 that we here see and sometimes

00:03:07,400 --> 00:03:11,990
tea should be and try to well at least

00:03:09,640 --> 00:03:15,740
take a fresh look at them and see if

00:03:11,990 --> 00:03:19,220
they still hold so does it go and the

00:03:15,740 --> 00:03:21,290
first one of course it's one of the best

00:03:19,220 --> 00:03:22,850
known ones who to consider an armful you

00:03:21,290 --> 00:03:25,250
might have not heard about that there's

00:03:22,850 --> 00:03:27,050
a number of considered harmful P papers

00:03:25,250 --> 00:03:29,420
that have circulated over the years all

00:03:27,050 --> 00:03:31,070
inspired by this one which makes some

00:03:29,420 --> 00:03:37,130
noise in the past how many of you have

00:03:31,070 --> 00:03:39,950
read anything less than the fourth of

00:03:37,130 --> 00:03:41,450
the room that's a good paper it you have

00:03:39,950 --> 00:03:43,280
to go back to 1968 but it's still

00:03:41,450 --> 00:03:45,709
available there's like strike archives

00:03:43,280 --> 00:03:48,110
banging around its write a short paper

00:03:45,709 --> 00:03:51,680
it's not longer than like two papers two

00:03:48,110 --> 00:03:52,400
pages this this is an extract but look

00:03:51,680 --> 00:03:54,230
at that

00:03:52,400 --> 00:03:56,030
the both face start there so the quality

00:03:54,230 --> 00:03:58,820
of programmers is a decreasing function

00:03:56,030 --> 00:04:00,350
of the density of go-to statements and

00:03:58,820 --> 00:04:03,020
the programs they produce which is quite

00:04:00,350 --> 00:04:05,270
a harsh statement you go to your bad

00:04:03,020 --> 00:04:08,209
programmer go to statements should be

00:04:05,270 --> 00:04:11,330
abolished from our level programming

00:04:08,209 --> 00:04:12,500
languages so except perhaps machine code

00:04:11,330 --> 00:04:14,630
because well that's what you'll find

00:04:12,500 --> 00:04:19,120
there anyway so things differently you

00:04:14,630 --> 00:04:21,500
know that can seemed reasonable is

00:04:19,120 --> 00:04:24,650
curiosity I mean if you have used go-to

00:04:21,500 --> 00:04:26,740
statements apart from entry well she

00:04:24,650 --> 00:04:29,030
still - do you feel dirty or something

00:04:26,740 --> 00:04:30,530
first time I saw one in the classroom

00:04:29,030 --> 00:04:32,770
when I was a student I saw people leave

00:04:30,530 --> 00:04:35,020
the room because the teacher had put one

00:04:32,770 --> 00:04:37,090
on the board and citizen what's that

00:04:35,020 --> 00:04:39,250
yeah it's so good to you started like

00:04:37,090 --> 00:04:40,830
writing code and people left they were

00:04:39,250 --> 00:04:44,169
insulted this was that

00:04:40,830 --> 00:04:45,130
so I'm guessing everyone can kind of

00:04:44,169 --> 00:04:48,039
read this thing

00:04:45,130 --> 00:04:50,319
so I loo that prints numbers from 0 to

00:04:48,039 --> 00:04:52,530
10 or something wants them and of course

00:04:50,319 --> 00:04:55,000
this is nothing certainly more readable

00:04:52,530 --> 00:04:56,410
it does the same thing if you look at

00:04:55,000 --> 00:04:58,539
DSM because pretty much the same thing

00:04:56,410 --> 00:05:01,419
we can understand someone sing well this

00:04:58,539 --> 00:05:16,210
one can read this I have to think about

00:05:01,419 --> 00:05:18,789
it not that much but still yep we put

00:05:16,210 --> 00:05:20,740
four loops like did your the question is

00:05:18,789 --> 00:05:23,080
why don't we have labeled go twos

00:05:20,740 --> 00:05:26,620
because the proposals for that have not

00:05:23,080 --> 00:05:28,000
gone through yet it's been proposed so

00:05:26,620 --> 00:05:30,069
some people like it

00:05:28,000 --> 00:05:31,210
Java's this when maybe it will go to go

00:05:30,069 --> 00:05:31,569
through at some point but we're not

00:05:31,210 --> 00:05:34,180
there yet

00:05:31,569 --> 00:05:36,639
you're great to push and to get your

00:05:34,180 --> 00:05:38,289
question if I find me we're targeting

00:05:36,639 --> 00:05:40,180
the big proposals first these days

00:05:38,289 --> 00:05:42,159
because some people think that signals

00:05:40,180 --> 00:05:43,630
were seventeen was too many small things

00:05:42,159 --> 00:05:47,080
that you have big things you might have

00:05:43,630 --> 00:05:48,280
noticed that sequences one is huge you

00:05:47,080 --> 00:05:50,409
might have a better chance with 20

00:05:48,280 --> 00:05:52,300
through 26 but there is a push for that

00:05:50,409 --> 00:05:54,639
so let's go into this so this is yeah

00:05:52,300 --> 00:05:56,409
like a choker that works but maybe not

00:05:54,639 --> 00:05:57,580
that readable and I won't move through

00:05:56,409 --> 00:05:59,229
the assembly but you can look at the

00:05:57,580 --> 00:06:01,780
good bulb things they're they're pretty

00:05:59,229 --> 00:06:06,280
similar not exactly the thing but very

00:06:01,780 --> 00:06:08,110
similar now some people might think well

00:06:06,280 --> 00:06:10,259
I'm going to write due to base loops I'm

00:06:08,110 --> 00:06:13,719
going to be better in my compiler yeah

00:06:10,259 --> 00:06:15,580
in general you probably they're very

00:06:13,719 --> 00:06:18,669
good those compilers these days so you

00:06:15,580 --> 00:06:20,740
can try sometimes to win but I'll take

00:06:18,669 --> 00:06:23,259
the words of a wise management and games

00:06:20,740 --> 00:06:24,340
works for Microsoft these optimizations

00:06:23,259 --> 00:06:25,750
that you might try they tend to get

00:06:24,340 --> 00:06:26,889
stale after a while so revisit your

00:06:25,750 --> 00:06:30,310
assumptions quite awesome

00:06:26,889 --> 00:06:32,349
so there's many reasons to to to avoid

00:06:30,310 --> 00:06:34,389
it looks like the bug ability is easier

00:06:32,349 --> 00:06:36,130
to reason about teach abilities is try

00:06:34,389 --> 00:06:37,030
to explain to people what's going on

00:06:36,130 --> 00:06:40,060
when they don't have to think about

00:06:37,030 --> 00:06:41,650
everything is a maintenance of course so

00:06:40,060 --> 00:06:44,289
that the point of the exercise to like

00:06:41,650 --> 00:06:45,940
raise the level of abstraction you know

00:06:44,289 --> 00:06:47,830
think in terms of

00:06:45,940 --> 00:06:49,420
higher level constructs which gotta make

00:06:47,830 --> 00:06:50,980
sense structured programming brain

00:06:49,420 --> 00:06:54,130
structure into the code which was kind

00:06:50,980 --> 00:06:57,010
of champagne and stock focus yesterday

00:06:54,130 --> 00:07:02,380
so like added everyone agreed no as

00:06:57,010 --> 00:07:04,300
everyone it's red I think mmm-hmm the

00:07:02,380 --> 00:07:07,660
worse than this Center there's this guy

00:07:04,300 --> 00:07:08,710
might have heard of this guy did a few

00:07:07,660 --> 00:07:10,330
things in computer science was

00:07:08,710 --> 00:07:12,370
interesting we wrote a much bigger paper

00:07:10,330 --> 00:07:14,560
six years after like much bigger much of

00:07:12,370 --> 00:07:16,030
our substance there because the first

00:07:14,560 --> 00:07:18,970
one was what we called Richard Beverly

00:07:16,030 --> 00:07:22,000
Lou it was like shaking the things so

00:07:18,970 --> 00:07:25,900
this is a quote but taking the the both

00:07:22,000 --> 00:07:27,610
face things there North advocates a

00:07:25,900 --> 00:07:29,920
methodology program design beginning

00:07:27,610 --> 00:07:32,590
with the readable and correct but

00:07:29,920 --> 00:07:35,290
possibly inefficient programs so he was

00:07:32,590 --> 00:07:36,730
thinking about efficiency maybe if you

00:07:35,290 --> 00:07:39,880
do structure programming in the weight

00:07:36,730 --> 00:07:42,190
was presented you might sometimes end up

00:07:39,880 --> 00:07:43,690
with less efficient things that you

00:07:42,190 --> 00:07:45,600
might like the efficiency is so

00:07:43,690 --> 00:07:47,950
important especially back then and

00:07:45,600 --> 00:07:49,600
whether or not due to sickness should be

00:07:47,950 --> 00:07:51,070
abolished there is merit on both sides

00:07:49,600 --> 00:07:53,230
of the question so it's like it was not

00:07:51,070 --> 00:07:55,900
saying it's a bad thing to push for more

00:07:53,230 --> 00:07:58,330
structure but just that it's not a black

00:07:55,900 --> 00:08:01,300
and white question and yeah add a few

00:07:58,330 --> 00:08:05,230
points with respect to that some of them

00:08:01,300 --> 00:08:06,220
was well in some cases go to smite

00:08:05,230 --> 00:08:08,080
actually simplify your code

00:08:06,220 --> 00:08:11,950
it was thinking about error management

00:08:08,080 --> 00:08:15,520
back then so yeah it was something also

00:08:11,950 --> 00:08:16,900
about efficiency as you will see so yeah

00:08:15,520 --> 00:08:19,600
when you have something like this with

00:08:16,900 --> 00:08:21,280
lots of nesting which was Express

00:08:19,600 --> 00:08:23,770
otherwise of course in his original

00:08:21,280 --> 00:08:25,690
paper from 74 we had a next thing is the

00:08:23,770 --> 00:08:27,640
next thing like this well did she go

00:08:25,690 --> 00:08:28,390
this way you have a test thing there to

00:08:27,640 --> 00:08:30,250
get out of it

00:08:28,390 --> 00:08:32,169
it might meet the culture much more

00:08:30,250 --> 00:08:33,760
readable actually actually mom at least

00:08:32,169 --> 00:08:36,580
according to his interpretation of the

00:08:33,760 --> 00:08:38,979
thing which we would write like this

00:08:36,580 --> 00:08:41,680
today wouldn't we so there there are

00:08:38,979 --> 00:08:43,210
reasonable cases of jumps like that that

00:08:41,680 --> 00:08:45,100
have been formalized in language this is

00:08:43,210 --> 00:08:47,580
one such I'm not a big user of continue

00:08:45,100 --> 00:08:50,470
but I can understand that this may be

00:08:47,580 --> 00:08:52,570
more left-leaning to ki-taek and raises

00:08:50,470 --> 00:08:55,780
words from two days ago then the other

00:08:52,570 --> 00:08:57,910
version I hope you agree you have

00:08:55,780 --> 00:08:59,830
something like this to that that's

00:08:57,910 --> 00:09:02,470
interesting so yeah

00:08:59,830 --> 00:09:05,860
zero constructor there that's being

00:09:02,470 --> 00:09:10,690
called and if B condition is satisfied

00:09:05,860 --> 00:09:12,610
the y0 constructor is being called if

00:09:10,690 --> 00:09:16,720
you do something like this well you

00:09:12,610 --> 00:09:19,870
might get surprises sometimes if you hit

00:09:16,720 --> 00:09:25,120
D go to test of be there and you don't

00:09:19,870 --> 00:09:27,400
hit the closing brace the destructor of

00:09:25,120 --> 00:09:30,340
x0 will still be called so there's a

00:09:27,400 --> 00:09:32,560
kind of structure you can kind of avoid

00:09:30,340 --> 00:09:34,960
the closing brace and still get your

00:09:32,560 --> 00:09:37,120
best structures called in C++ if you

00:09:34,960 --> 00:09:39,070
have just have been constructed so it's

00:09:37,120 --> 00:09:40,210
not as bad as it could've looked in the

00:09:39,070 --> 00:09:44,160
first place you cannot bypass the

00:09:40,210 --> 00:09:46,210
destructor with this making sense okay

00:09:44,160 --> 00:09:47,410
this is something that worried me when I

00:09:46,210 --> 00:09:48,550
started playing with these things like

00:09:47,410 --> 00:09:53,650
what happens with the structures you

00:09:48,550 --> 00:09:55,660
know yeah there's an incarnation for

00:09:53,650 --> 00:09:57,010
that of course it's a good king again so

00:09:55,660 --> 00:09:58,180
continue is something that we have

00:09:57,010 --> 00:09:59,950
formalized because there are use cases

00:09:58,180 --> 00:10:02,940
for this it simplifies code in some

00:09:59,950 --> 00:10:06,130
sense some cases if you have to use it

00:10:02,940 --> 00:10:10,000
this is also fun so you have this main

00:10:06,130 --> 00:10:11,290
there where you have the X 0 constructor

00:10:10,000 --> 00:10:13,420
at the main code and there's this go to

00:10:11,290 --> 00:10:15,520
well the constructor is making out five

00:10:13,420 --> 00:10:19,120
times M bits may surprise you the

00:10:15,520 --> 00:10:20,950
destructor is called five times two so

00:10:19,120 --> 00:10:23,320
soon as bad as it looks I wouldn't write

00:10:20,950 --> 00:10:25,120
code like that myself I'm just saying

00:10:23,320 --> 00:10:30,270
that it's not as unsafe as people could

00:10:25,120 --> 00:10:33,640
think I said oh now please don't do it

00:10:30,270 --> 00:10:36,940
okay just you won't get as much as you

00:10:33,640 --> 00:10:40,930
thought this is illegal because you

00:10:36,940 --> 00:10:42,880
might skip the X 0 constructor and that

00:10:40,930 --> 00:10:44,980
you're not allowed to do so you can kind

00:10:42,880 --> 00:10:46,570
of quote quote skip the destructor it's

00:10:44,980 --> 00:10:49,120
going to be called anyway that's like

00:10:46,570 --> 00:10:50,740
language defined but skipping over a

00:10:49,120 --> 00:10:53,710
constructor and I think a chance because

00:10:50,740 --> 00:10:55,540
the variable afterwards no-go so again

00:10:53,710 --> 00:10:58,930
yeah not as bad as it looked in the

00:10:55,540 --> 00:11:01,620
first place so making sense okay and

00:10:58,930 --> 00:11:01,620
that's it yet please

00:11:02,720 --> 00:11:07,640
yep it's standardized there are quotes

00:11:06,000 --> 00:11:10,620
in the year slide if you look at them

00:11:07,640 --> 00:11:12,149
it's surprising that's why I went there

00:11:10,620 --> 00:11:13,769
and I checked because I'm that as you

00:11:12,149 --> 00:11:16,230
could probably guess I don't use go twos

00:11:13,769 --> 00:11:22,890
everyday I don't use them every year yep

00:11:16,230 --> 00:11:23,850
oh you if you want to look at generated

00:11:22,890 --> 00:11:26,760
code you have to check with your

00:11:23,850 --> 00:11:28,110
favorite compiler that's really

00:11:26,760 --> 00:11:29,730
something that's compare speed second

00:11:28,110 --> 00:11:32,370
option specific so please do so but

00:11:29,730 --> 00:11:37,410
don't do that just showing what it does

00:11:32,370 --> 00:11:39,329
in that thing do laps please okay if

00:11:37,410 --> 00:11:42,649
someone gets already room thing that

00:11:39,329 --> 00:11:45,000
says use go to I'm gonna be very angry

00:11:42,649 --> 00:11:46,920
this wouldn't make might surprise you

00:11:45,000 --> 00:11:48,600
would actually compile what is it

00:11:46,920 --> 00:11:51,240
compound I know if she see it so I'm

00:11:48,600 --> 00:11:54,779
running and running at I sing once every

00:11:51,240 --> 00:11:56,550
ten times I might skip something but the

00:11:54,779 --> 00:11:58,410
constructor in the structure or the NR

00:11:56,550 --> 00:12:00,360
trivial and officially allowed by the

00:11:58,410 --> 00:12:02,010
center now if you have a non-trivial

00:12:00,360 --> 00:12:06,839
concert or instructor you know how to do

00:12:02,010 --> 00:12:08,370
that that's amusing doesn't in museum

00:12:06,839 --> 00:12:12,029
it's frightening isn't it

00:12:08,370 --> 00:12:13,649
it actually compiles it's legal so note

00:12:12,029 --> 00:12:15,329
was interested not in this dirty stuff

00:12:13,649 --> 00:12:18,240
he was interested in efficiency and

00:12:15,329 --> 00:12:20,640
encode that makes sense okay so Noth

00:12:18,240 --> 00:12:22,290
wanted to exit early from loops in the

00:12:20,640 --> 00:12:24,740
original papers they were saying well if

00:12:22,290 --> 00:12:27,570
you want to look for something in

00:12:24,740 --> 00:12:30,899
rebound do something like this yeah

00:12:27,570 --> 00:12:33,060
boolean result or something and iterate

00:12:30,899 --> 00:12:35,310
through things and when you found what

00:12:33,060 --> 00:12:36,959
you were looking for Megna boolean true

00:12:35,310 --> 00:12:38,730
and then at the end return something but

00:12:36,959 --> 00:12:40,260
as you can see from the slide right now

00:12:38,730 --> 00:12:41,790
you're going to go through the entire

00:12:40,260 --> 00:12:46,740
array then if you found your answer at

00:12:41,790 --> 00:12:48,510
the first step so that's in addition you

00:12:46,740 --> 00:12:51,120
could do this do it like this also and

00:12:48,510 --> 00:12:53,040
check your condition and do for a loop

00:12:51,120 --> 00:12:55,140
that tests well three times every

00:12:53,040 --> 00:12:56,459
iteration so you're checking your loop

00:12:55,140 --> 00:12:58,050
counter you're checking whether you

00:12:56,459 --> 00:13:00,779
found something you're doing the N in

00:12:58,050 --> 00:13:04,050
between so it's kind of better but kind

00:13:00,779 --> 00:13:07,290
that's not that good either isn't it you

00:13:04,050 --> 00:13:10,680
will like that earlier no and then well

00:13:07,290 --> 00:13:12,300
in in our friend News perspective this

00:13:10,680 --> 00:13:15,730
would be better I mean once you've found

00:13:12,300 --> 00:13:18,130
something you know get out

00:13:15,730 --> 00:13:19,329
you were in the seventies you know where

00:13:18,130 --> 00:13:20,920
the machines of the seventies these

00:13:19,329 --> 00:13:23,230
things they did count and they still

00:13:20,920 --> 00:13:24,160
count today of course that's not that we

00:13:23,230 --> 00:13:26,829
would write things today

00:13:24,160 --> 00:13:29,350
yeah we're formalize this so early exist

00:13:26,829 --> 00:13:31,000
from a loop it's a go-to we use break

00:13:29,350 --> 00:13:35,320
these days but it's the same idea it's

00:13:31,000 --> 00:13:36,910
just easier to read isn't it yeah so we

00:13:35,320 --> 00:13:39,399
had the thing an amuse the thing I would

00:13:36,910 --> 00:13:40,959
just returned from the same person so

00:13:39,399 --> 00:13:42,910
things such as breakin continue well

00:13:40,959 --> 00:13:44,500
they are structured reasoning this forms

00:13:42,910 --> 00:13:45,730
of giving to so in terms of structured

00:13:44,500 --> 00:13:49,810
programming they are some kind of

00:13:45,730 --> 00:13:50,800
compromise but we use them well we're

00:13:49,810 --> 00:13:53,070
kind of liars

00:13:50,800 --> 00:13:56,470
yet saying we don't use go to which

00:13:53,070 --> 00:13:58,510
switch so and the other thing that's

00:13:56,470 --> 00:14:00,490
that's probably more more important for

00:13:58,510 --> 00:14:01,720
us is error handling so as we we all

00:14:00,490 --> 00:14:03,459
know I think when you're mixing

00:14:01,720 --> 00:14:05,440
everything which feels a real code the

00:14:03,459 --> 00:14:08,350
code that does production stuff well it

00:14:05,440 --> 00:14:10,449
gets messy and it confuses the purpose

00:14:08,350 --> 00:14:12,130
of your algorithm so if you're

00:14:10,449 --> 00:14:14,079
intermingling them to you're gonna end

00:14:12,130 --> 00:14:17,709
up with some kind of super words that's

00:14:14,079 --> 00:14:21,760
hard to make sense of and Knuth already

00:14:17,709 --> 00:14:23,529
knew this so yeah you might some of you

00:14:21,760 --> 00:14:25,480
have done Visual Basic 6 or something

00:14:23,529 --> 00:14:28,269
like that there was a go to Aaron ever

00:14:25,480 --> 00:14:31,180
go to construct that said when you had

00:14:28,269 --> 00:14:32,680
an error at the end of a function so I'm

00:14:31,180 --> 00:14:35,800
thinking like this you know this is

00:14:32,680 --> 00:14:37,839
actually taken from newspaper but using

00:14:35,800 --> 00:14:41,649
another language of course so we try to

00:14:37,839 --> 00:14:43,420
get something and if you think that you

00:14:41,649 --> 00:14:45,459
won't be able to well it due to some

00:14:43,420 --> 00:14:47,139
kind of overflow flying or something and

00:14:45,459 --> 00:14:48,910
then you do your processing but the rest

00:14:47,139 --> 00:14:52,050
of the code you proceed normally and you

00:14:48,910 --> 00:14:53,860
do your allocation me everything's fine

00:14:52,050 --> 00:14:56,829
today it will look kinda like this

00:14:53,860 --> 00:14:58,870
wouldn't it the exceptions are kind of a

00:14:56,829 --> 00:15:02,500
poster child what structured go to scan

00:14:58,870 --> 00:15:05,410
be and you're able you get out of the

00:15:02,500 --> 00:15:07,060
awkward situations process them in some

00:15:05,410 --> 00:15:09,910
other location maybe sometimes outside

00:15:07,060 --> 00:15:12,010
of the function why not and you do your

00:15:09,910 --> 00:15:13,870
thing normally such that you don't mix

00:15:12,010 --> 00:15:16,269
it to in you're a girl you're algorithm

00:15:13,870 --> 00:15:18,040
make sure he stays readable why not

00:15:16,269 --> 00:15:22,709
so actually gave a name to those things

00:15:18,040 --> 00:15:24,880
those reasonable use cases of mootools

00:15:22,709 --> 00:15:26,949
there there's of course the switch

00:15:24,880 --> 00:15:28,709
statement which have I'm sure most of

00:15:26,949 --> 00:15:32,980
you know is a go-to

00:15:28,709 --> 00:15:36,430
it's not a real control structure called

00:15:32,980 --> 00:15:39,220
go-to in Fortran 77 I done Fortran code

00:15:36,430 --> 00:15:42,850
man the best it's not the same

00:15:39,220 --> 00:15:44,829
structured programming this as the other

00:15:42,850 --> 00:15:46,839
things it's it's some kind of weird

00:15:44,829 --> 00:15:48,639
thing go to so if you have this vector

00:15:46,839 --> 00:15:51,490
you'll think that it's actually working

00:15:48,639 --> 00:15:52,870
it's simple for small numbers because

00:15:51,490 --> 00:15:55,329
unsigned longer the limit to what you

00:15:52,870 --> 00:15:58,000
can do with that you could write it like

00:15:55,329 --> 00:16:01,120
this of course which I probably some of

00:15:58,000 --> 00:16:03,279
you have seen the past note in the slide

00:16:01,120 --> 00:16:04,600
how they do in the wild interact with

00:16:03,279 --> 00:16:06,550
the switch statement if you have never

00:16:04,600 --> 00:16:07,690
seen this I'm very very sorry you can

00:16:06,550 --> 00:16:11,829
forget about it when you get out of the

00:16:07,690 --> 00:16:14,079
room it's inspired by something called

00:16:11,829 --> 00:16:15,699
doves device and it was actually a way

00:16:14,079 --> 00:16:18,100
to unroll loops without resorting to

00:16:15,699 --> 00:16:20,350
assembly code in the eighties it still

00:16:18,100 --> 00:16:22,480
works it works because which say

00:16:20,350 --> 00:16:25,690
statements are Gautam's so you actually

00:16:22,480 --> 00:16:29,259
take your the value that you evaluating

00:16:25,690 --> 00:16:30,940
the switch condition or so I know you

00:16:29,259 --> 00:16:32,740
jump somewhere in the middle of the loop

00:16:30,940 --> 00:16:36,399
and then you continue which lets you

00:16:32,740 --> 00:16:38,230
evacuate the excess case of something it

00:16:36,399 --> 00:16:39,730
would otherwise be regular and then you

00:16:38,230 --> 00:16:41,649
check a condition for the loop less

00:16:39,730 --> 00:16:43,420
often which used to make the code faster

00:16:41,649 --> 00:16:45,100
don't do that to take a patters are much

00:16:43,420 --> 00:16:48,130
better than this okay competitors are

00:16:45,100 --> 00:16:49,959
awesome but see it works yet that

00:16:48,130 --> 00:16:51,579
follow-through thing that I put there to

00:16:49,959 --> 00:16:53,889
avoid the warnings because you since it

00:16:51,579 --> 00:16:55,600
was 17 otherwise most competitors will

00:16:53,889 --> 00:16:56,949
Bravo saying need you for your a Greg

00:16:55,600 --> 00:17:03,130
there somewhere those taking pictures

00:16:56,949 --> 00:17:04,419
don't do that at home don't do that when

00:17:03,130 --> 00:17:06,100
I showed this to students I showed this

00:17:04,419 --> 00:17:08,289
to talk to children then switches ago to

00:17:06,100 --> 00:17:10,270
not that this will practice and if you

00:17:08,289 --> 00:17:13,209
look at the generated code competitors

00:17:10,270 --> 00:17:16,829
will trash you so it's actually fun so

00:17:13,209 --> 00:17:20,919
you like a factor you'll find there well

00:17:16,829 --> 00:17:23,470
4-5 module 4 which is 1 well you joked

00:17:20,919 --> 00:17:26,380
case 3 and then you just do two tests

00:17:23,470 --> 00:17:28,030
instead of 5 in your loop kind of but

00:17:26,380 --> 00:17:30,610
loop unrolling competitors are very good

00:17:28,030 --> 00:17:32,549
at but the fact is you can intermingle

00:17:30,610 --> 00:17:36,400
both shows us that switches on the scope

00:17:32,549 --> 00:17:39,429
isn't it yeah so amusingly

00:17:36,400 --> 00:17:41,170
it's it's been used in one of be honest

00:17:39,429 --> 00:17:43,690
papers

00:17:41,170 --> 00:17:45,550
constic spare time to try to implement a

00:17:43,690 --> 00:17:47,380
replacement for dynamic cast a few years

00:17:45,550 --> 00:17:49,600
back what I saw that I was so surprised

00:17:47,380 --> 00:17:53,290
man this thing the things that exists

00:17:49,600 --> 00:17:55,000
who is in c-sharp I start to do this

00:17:53,290 --> 00:17:56,620
this kind of trick because you're forced

00:17:55,000 --> 00:17:59,560
to put breaks in your code you cannot

00:17:56,620 --> 00:18:01,300
skip a break in Java or C short code but

00:17:59,560 --> 00:18:02,920
it was pointed out to me by some c-sharp

00:18:01,300 --> 00:18:07,690
experts that if you really want to do

00:18:02,920 --> 00:18:09,610
this you can using a go-to so they wait

00:18:07,690 --> 00:18:12,610
without to be if you're in c-sharp is to

00:18:09,610 --> 00:18:14,530
use go tools so this is actually a legal

00:18:12,610 --> 00:18:17,050
code I checked it so I don't know if you

00:18:14,530 --> 00:18:18,430
can see it this one if you pass it value

00:18:17,050 --> 00:18:20,620
that it takes you the first statement

00:18:18,430 --> 00:18:22,240
well it goes to go to the secure than a

00:18:20,620 --> 00:18:24,700
third then yeah you get felt through

00:18:22,240 --> 00:18:26,020
behavior but using motives so you cannot

00:18:24,700 --> 00:18:28,810
have that be if you're otherwise

00:18:26,020 --> 00:18:34,510
innocent sharp I'm very sorry for this

00:18:28,810 --> 00:18:37,540
long this this this is interesting this

00:18:34,510 --> 00:18:40,060
is this code compiles and you notice

00:18:37,540 --> 00:18:43,450
that the switch has no case it's

00:18:40,060 --> 00:18:45,700
perfectly legal so so so you might get a

00:18:43,450 --> 00:18:47,920
warning because the ex constructor

00:18:45,700 --> 00:18:51,340
cannot be really reached but it's legal

00:18:47,920 --> 00:18:53,560
code other thing it's useful it's a

00:18:51,340 --> 00:18:58,710
curiosity standards conforming and

00:18:53,560 --> 00:19:00,790
everything are used to my friends okay

00:18:58,710 --> 00:19:01,900
this is the same thing you can do this

00:19:00,790 --> 00:19:02,950
you know you can put a break without

00:19:01,900 --> 00:19:05,130
anything a case statement in the first

00:19:02,950 --> 00:19:08,560
place it works first fine it's useless

00:19:05,130 --> 00:19:10,660
just interesting it's like like going

00:19:08,560 --> 00:19:13,530
through a shop where there's curiosities

00:19:10,660 --> 00:19:20,200
and everything this is actually legal

00:19:13,530 --> 00:19:20,730
compiler sign I'm sorry it but this is

00:19:20,200 --> 00:19:23,440
illegal

00:19:20,730 --> 00:19:26,380
this is actually legal because X would

00:19:23,440 --> 00:19:27,850
be accessible in the case one case but

00:19:26,380 --> 00:19:31,720
it does not be initialize because you

00:19:27,850 --> 00:19:33,340
skip over the constructor okay so I hope

00:19:31,720 --> 00:19:35,860
this does not make you want to just go

00:19:33,340 --> 00:19:40,690
to it's just going around the contours

00:19:35,860 --> 00:19:43,720
are the thing that okay okay and this is

00:19:40,690 --> 00:19:46,390
still illegal for the same reason yeah

00:19:43,720 --> 00:19:49,450
here you you could technically speaking

00:19:46,390 --> 00:19:50,980
you could access or somewhat the coast

00:19:49,450 --> 00:19:52,640
road trip it exists the destructor would

00:19:50,980 --> 00:19:55,220
be call this waited it

00:19:52,640 --> 00:19:57,200
but if you put a scope there you okay so

00:19:55,220 --> 00:20:00,490
because you're doing like more

00:19:57,200 --> 00:20:04,549
reasonable still cool

00:20:00,490 --> 00:20:06,260
good so the next trial that's right at a

00:20:04,549 --> 00:20:07,820
point you know structured programming

00:20:06,260 --> 00:20:09,559
makes you read the code better

00:20:07,820 --> 00:20:11,150
understand mean the better there's like

00:20:09,559 --> 00:20:13,400
good reasons to do that

00:20:11,150 --> 00:20:15,320
and it leads to better code in many ways

00:20:13,400 --> 00:20:17,299
I'm not sure I'm pretty sure nobody

00:20:15,320 --> 00:20:19,940
would want to read code like the one the

00:20:17,299 --> 00:20:21,710
last few slides except like around the

00:20:19,940 --> 00:20:23,440
beard late at night with people that you

00:20:21,710 --> 00:20:26,630
will never see again after in the future

00:20:23,440 --> 00:20:28,040
and and news also at a point for

00:20:26,630 --> 00:20:29,299
efficiency sometimes you can you can

00:20:28,040 --> 00:20:31,730
bend the rules a bit and there are

00:20:29,299 --> 00:20:34,010
structured reasonable ways of doing

00:20:31,730 --> 00:20:36,919
branches like this that are not the

00:20:34,010 --> 00:20:38,600
standard if and while set that can make

00:20:36,919 --> 00:20:40,940
you feel better so the break at new

00:20:38,600 --> 00:20:42,710
switch Stephen Fry cash makes sense and

00:20:40,940 --> 00:20:44,630
break with the label as was suggested by

00:20:42,710 --> 00:20:46,970
one of the questions earlier are under

00:20:44,630 --> 00:20:48,500
discussion so maybe you'll get that if

00:20:46,970 --> 00:20:50,210
that's what you want to get like

00:20:48,500 --> 00:20:51,290
respecting the scope rules let's see

00:20:50,210 --> 00:20:53,020
clusters which are a bit more complex

00:20:51,290 --> 00:20:55,220
than Java because of these structures

00:20:53,020 --> 00:20:57,650
okay so if you want to push for it write

00:20:55,220 --> 00:20:59,720
your own papers not my thing but stuff

00:20:57,650 --> 00:21:00,890
and there are things you cannot do with

00:20:59,720 --> 00:21:02,150
go-to statements to kill how you're

00:21:00,890 --> 00:21:04,340
going to get out to say I'm gonna use

00:21:02,150 --> 00:21:06,559
this playing well you cannot skip a non

00:21:04,340 --> 00:21:09,080
vacuous initialization is miss out today

00:21:06,559 --> 00:21:10,880
you can skip an ins but not an object

00:21:09,080 --> 00:21:14,440
with the fancy destructor constructor

00:21:10,880 --> 00:21:18,160
you cannot jump in or out of functions

00:21:14,440 --> 00:21:20,570
which makes me feel much better

00:21:18,160 --> 00:21:24,110
you cannot use them in context very nice

00:21:20,570 --> 00:21:26,840
try and I hope it stays that way you can

00:21:24,110 --> 00:21:34,929
app again again a jump into a try-catch

00:21:26,840 --> 00:21:37,640
statement yeah you can't jump out and

00:21:34,929 --> 00:21:40,790
the disruptors will become you know as

00:21:37,640 --> 00:21:44,780
long as you respect the intervals oh boy

00:21:40,790 --> 00:21:46,400
so am I saying use this now but you use

00:21:44,780 --> 00:21:47,690
our higher level abstractions of course

00:21:46,400 --> 00:21:50,120
but don't fight yourselves because know

00:21:47,690 --> 00:21:53,450
you you're using them anyway and and

00:21:50,120 --> 00:21:54,620
please if you're saying well if you

00:21:53,450 --> 00:21:57,230
really want to second-guess your

00:21:54,620 --> 00:21:59,169
compiler then try to do things that you

00:21:57,230 --> 00:22:02,000
think you could be better well measure

00:21:59,169 --> 00:22:04,850
and measure often because compilers

00:22:02,000 --> 00:22:05,750
change and we don't necessarily maintain

00:22:04,850 --> 00:22:07,670
that kind of code

00:22:05,750 --> 00:22:08,870
it really is the thing you go to live in

00:22:07,670 --> 00:22:10,970
code there's nothing necessary something

00:22:08,870 --> 00:22:13,270
you want to do so be sure regularly

00:22:10,970 --> 00:22:16,790
because as I said these things get stale

00:22:13,270 --> 00:22:17,870
we're still okay thank you so that

00:22:16,790 --> 00:22:19,460
wasn't that one was in that

00:22:17,870 --> 00:22:22,730
controversial because the code is carry

00:22:19,460 --> 00:22:24,380
some let's go further a bit this is one

00:22:22,730 --> 00:22:26,120
of the things only one exit point per

00:22:24,380 --> 00:22:29,030
function that they teach at my school

00:22:26,120 --> 00:22:31,580
and I'm of two minds about this I think

00:22:29,030 --> 00:22:34,430
I spoke of that earlier in the week in

00:22:31,580 --> 00:22:36,170
another talk that I gave when you start

00:22:34,430 --> 00:22:37,580
with beginners you take one person one

00:22:36,170 --> 00:22:38,750
perspective and when you go with

00:22:37,580 --> 00:22:41,210
experienced programmers there's another

00:22:38,750 --> 00:22:43,220
one when we start with someone who has

00:22:41,210 --> 00:22:44,990
never programmed there are kind of waste

00:22:43,220 --> 00:22:47,270
thing that you want to instill and

00:22:44,990 --> 00:22:49,310
install it there but are the same that

00:22:47,270 --> 00:22:52,340
you deal with someone understand what's

00:22:49,310 --> 00:22:54,260
going on so this was also inspired by

00:22:52,340 --> 00:22:57,500
Dykstra but there's something coming up

00:22:54,260 --> 00:22:59,060
I I always thought it was extra to be

00:22:57,500 --> 00:23:02,120
honest and you know what's so cool about

00:22:59,060 --> 00:23:04,190
suti because I was at the ESG 14 morning

00:23:02,120 --> 00:23:05,780
I mean thing two days ago and I was like

00:23:04,190 --> 00:23:08,000
doing the secretary working with zoom

00:23:05,780 --> 00:23:09,830
and dance acts a very wise man comes to

00:23:08,000 --> 00:23:11,870
me and says what are you doing this week

00:23:09,830 --> 00:23:14,630
so blah blah they meanwhile my Friday

00:23:11,870 --> 00:23:16,640
thought might be weird a bit and then he

00:23:14,630 --> 00:23:17,840
says you know what where'd that one exit

00:23:16,640 --> 00:23:19,700
point per function comes from the

00:23:17,840 --> 00:23:21,920
diagram thing that we used to teach that

00:23:19,700 --> 00:23:24,620
it doesn't come from Dijkstra he comes

00:23:21,920 --> 00:23:26,930
from this guy Corrado boom he had proof

00:23:24,620 --> 00:23:28,130
with the name game the guy named Jack

00:23:26,930 --> 00:23:32,000
opine but I couldn't find it be sure

00:23:28,130 --> 00:23:34,700
than earlier like in 66 with a proof

00:23:32,000 --> 00:23:36,350
that you can turn diagrams into programs

00:23:34,700 --> 00:23:37,040
and they make sense diagrams are

00:23:36,350 --> 00:23:40,400
turing-complete

00:23:37,040 --> 00:23:42,200
if you respect some rules so I went and

00:23:40,400 --> 00:23:45,800
read the paper very interesting a bit

00:23:42,200 --> 00:23:47,810
old but still the guy that really TV

00:23:45,800 --> 00:23:50,000
recently in that paper there's this

00:23:47,810 --> 00:23:53,000
piece that says every Turing machine is

00:23:50,000 --> 00:23:55,760
reducible into or in a determined sense

00:23:53,000 --> 00:23:57,650
is equivalent to a program written in

00:23:55,760 --> 00:23:59,360
lay in the language which admits as

00:23:57,650 --> 00:24:00,710
formation rules only composition and

00:23:59,360 --> 00:24:02,660
iteration so structured programming

00:24:00,710 --> 00:24:05,060
really so he's saying if you're doing

00:24:02,660 --> 00:24:06,890
the structured stuff you can write

00:24:05,060 --> 00:24:10,820
diagrams turn them into code and they

00:24:06,890 --> 00:24:14,120
say there so it works pretty cool when I

00:24:10,820 --> 00:24:16,460
read about it there's this thing that

00:24:14,120 --> 00:24:18,280
says in fact that's the thing has led to

00:24:16,460 --> 00:24:21,400
the heavy criticism of

00:24:18,280 --> 00:24:23,710
to switch make me smile but it's cool so

00:24:21,400 --> 00:24:24,910
the idea is that if you look at the next

00:24:23,710 --> 00:24:26,500
rest paper if you haven't read it it's

00:24:24,910 --> 00:24:28,720
good paper there's a formalization

00:24:26,500 --> 00:24:29,770
saying well there's sequences and

00:24:28,720 --> 00:24:31,960
there's choices that you make

00:24:29,770 --> 00:24:34,600
alternatives which are if statements and

00:24:31,960 --> 00:24:37,630
there's iteration which all amount to

00:24:34,600 --> 00:24:39,190
while loops in some former letter so if

00:24:37,630 --> 00:24:40,480
you arrange them in some ways you can

00:24:39,190 --> 00:24:42,610
actually reason about with the program

00:24:40,480 --> 00:24:44,530
and make proofs about it so you take

00:24:42,610 --> 00:24:46,810
updates units that I have one entry

00:24:44,530 --> 00:24:48,880
point and one exit points and you can

00:24:46,810 --> 00:24:51,100
compose them together you kind of look

00:24:48,880 --> 00:24:54,010
like this so yes sequence in the middle

00:24:51,100 --> 00:24:55,680
you have the if statement the true if

00:24:54,010 --> 00:24:59,530
the condition is true you go to the

00:24:55,680 --> 00:25:00,820
right if it's fast you go to left and

00:24:59,530 --> 00:25:02,950
there's the iteration that you see on

00:25:00,820 --> 00:25:06,750
the right you slide right now with the

00:25:02,950 --> 00:25:09,700
condition is the thing and you have

00:25:06,750 --> 00:25:11,260
initialization condition processing and

00:25:09,700 --> 00:25:14,170
incrementation if you're looking for

00:25:11,260 --> 00:25:16,270
something in unit and if you notice each

00:25:14,170 --> 00:25:18,910
of them has only one entry point and one

00:25:16,270 --> 00:25:19,720
exit exit point and with the proofs that

00:25:18,910 --> 00:25:21,160
these guys made

00:25:19,720 --> 00:25:23,140
if you compose them together you know

00:25:21,160 --> 00:25:25,590
you can make sense out of the code so it

00:25:23,140 --> 00:25:29,410
can about there's a reason for that

00:25:25,590 --> 00:25:31,120
so we have the function cause another

00:25:29,410 --> 00:25:34,060
one which caused another one everything

00:25:31,120 --> 00:25:37,270
will exit one and three it kind of works

00:25:34,060 --> 00:25:39,010
like Lego blocks but there are languages

00:25:37,270 --> 00:25:41,170
where there's not even the concept of

00:25:39,010 --> 00:25:43,300
the return statement I've done Pascal

00:25:41,170 --> 00:25:44,830
for a few years in Pascal you write to

00:25:43,300 --> 00:25:47,440
the output to the name of your function

00:25:44,830 --> 00:25:49,030
that becomes your output value and when

00:25:47,440 --> 00:25:51,010
you reach the end the last thing you

00:25:49,030 --> 00:25:54,190
wrote there is the actual Reserve return

00:25:51,010 --> 00:25:55,570
value but there's no return quick we get

00:25:54,190 --> 00:25:57,160
out that doesn't exist in that language

00:25:55,570 --> 00:25:58,710
at least a bit like this when I work

00:25:57,160 --> 00:26:00,910
with it

00:25:58,710 --> 00:26:03,610
so this is the factorial that's

00:26:00,910 --> 00:26:05,440
recursive as you can see and I write to

00:26:03,610 --> 00:26:07,240
the name of my function every time I go

00:26:05,440 --> 00:26:09,910
and that there's a recursive call within

00:26:07,240 --> 00:26:14,800
the if and there's no return when you

00:26:09,910 --> 00:26:16,840
reach and it's done this thing I think

00:26:14,800 --> 00:26:18,820
repine and exit point is reasonable

00:26:16,840 --> 00:26:21,970
seriously it's a simple reason which is

00:26:18,820 --> 00:26:24,610
why I still use it with my beginners it

00:26:21,970 --> 00:26:26,530
leads to it here train of thought and

00:26:24,610 --> 00:26:28,030
they have trouble with enough stuff in

00:26:26,530 --> 00:26:29,540
programming that you don't want to mess

00:26:28,030 --> 00:26:33,350
things up more

00:26:29,540 --> 00:26:35,210
but it's not always practical there's

00:26:33,350 --> 00:26:38,330
upsides and downsides to it if you get

00:26:35,210 --> 00:26:40,280
this yeah it's not necessary it's very

00:26:38,330 --> 00:26:42,230
simple function I know but it's not

00:26:40,280 --> 00:26:44,450
necessary pretty we got this variable

00:26:42,230 --> 00:26:46,850
there if the condition is true you put

00:26:44,450 --> 00:26:49,790
true if the condition is false you put

00:26:46,850 --> 00:26:53,030
false then you return the thing it's a

00:26:49,790 --> 00:26:55,850
bit long-winded that's it this is like

00:26:53,030 --> 00:26:57,470
he better because you are I'm gonna be

00:26:55,850 --> 00:26:58,910
pessimistic and I'm gonna assume the

00:26:57,470 --> 00:27:00,890
results is false but then I'll revisit

00:26:58,910 --> 00:27:05,840
my assumption if I may if I if I made a

00:27:00,890 --> 00:27:08,570
mistake go through there so we'll do

00:27:05,840 --> 00:27:11,270
that that makes me cringe maybe you do

00:27:08,570 --> 00:27:12,919
that I did this music if the condition

00:27:11,270 --> 00:27:15,470
is conditions through your turn true if

00:27:12,919 --> 00:27:17,059
it's also return false in this case the

00:27:15,470 --> 00:27:18,500
reason for the double region statement

00:27:17,059 --> 00:27:21,309
is not clear to me when my students do

00:27:18,500 --> 00:27:23,720
that say okay they're not getting it

00:27:21,309 --> 00:27:25,549
because they don't understand that the

00:27:23,720 --> 00:27:27,049
actual condition result that they have

00:27:25,549 --> 00:27:29,210
is their result they could just return

00:27:27,049 --> 00:27:31,520
from this this is what I expect to make

00:27:29,210 --> 00:27:32,840
them think about so in such cases the

00:27:31,520 --> 00:27:34,490
single written statement is okay

00:27:32,840 --> 00:27:36,169
pleased bitter cold it's clearer it's

00:27:34,490 --> 00:27:38,120
simpler and one-liners like that there's

00:27:36,169 --> 00:27:39,860
so much easier to debug them is they can

00:27:38,120 --> 00:27:41,450
make when they start now when there's

00:27:39,860 --> 00:27:43,660
more in two lines you're gonna you're

00:27:41,450 --> 00:27:46,100
gonna end up doing debugging

00:27:43,660 --> 00:27:47,299
someone something I said that I think a

00:27:46,100 --> 00:27:53,360
good function should sit in a tweet

00:27:47,299 --> 00:27:55,250
that's pretty much it yeah so yeah this

00:27:53,360 --> 00:27:57,770
is revisiting the case of the early exit

00:27:55,250 --> 00:28:00,049
earlier where I'm looping through my

00:27:57,770 --> 00:28:02,210
array trying to find something and when

00:28:00,049 --> 00:28:03,950
I found it I put some value in my

00:28:02,210 --> 00:28:05,570
variable say okay I found it and then I

00:28:03,950 --> 00:28:09,440
check variable every time it's kinda

00:28:05,570 --> 00:28:11,809
slow the previous attempt I put a break

00:28:09,440 --> 00:28:13,850
in the code that's fine all really

00:28:11,809 --> 00:28:16,549
exists in this case makes sense to write

00:28:13,850 --> 00:28:18,350
to me in when non beginners do that I

00:28:16,549 --> 00:28:20,030
feel I feel okay with it because they

00:28:18,350 --> 00:28:22,730
got it they got the answer there's no

00:28:20,030 --> 00:28:26,020
point in staying there get out so break

00:28:22,730 --> 00:28:29,360
is necessary for such cases it's okay

00:28:26,020 --> 00:28:31,760
now there are good reasons to achieve

00:28:29,360 --> 00:28:34,490
that principle in general but this this

00:28:31,760 --> 00:28:35,690
might save you from nasty bugs now this

00:28:34,490 --> 00:28:37,490
is something that I see sometimes I

00:28:35,690 --> 00:28:38,900
don't know about you there's this

00:28:37,490 --> 00:28:40,909
function there F that returns a string

00:28:38,900 --> 00:28:42,650
you it's implicit from the return

00:28:40,909 --> 00:28:44,330
statement that you see in the switch

00:28:42,650 --> 00:28:45,920
and there's this saloon there with only

00:28:44,330 --> 00:28:47,420
three possible value and in class with

00:28:45,920 --> 00:28:50,360
you right now but it makes for a longer

00:28:47,420 --> 00:28:51,410
coat and and and people feel safe

00:28:50,360 --> 00:28:54,290
together they say well there's three

00:28:51,410 --> 00:28:57,530
values and I've covered all three values

00:28:54,290 --> 00:28:58,820
I'm totally safe and if you look at the

00:28:57,530 --> 00:29:00,950
main statement there about the main

00:28:58,820 --> 00:29:02,960
functions well yeah where it kind of

00:29:00,950 --> 00:29:04,940
works well of course you could put past

00:29:02,960 --> 00:29:07,820
em to the function f and it compiles

00:29:04,940 --> 00:29:10,490
very fine in general it doesn't have to

00:29:07,820 --> 00:29:13,040
be that this one is its first except

00:29:10,490 --> 00:29:15,410
zero one two three so you better even be

00:29:13,040 --> 00:29:17,540
in trouble already because yeah you're

00:29:15,410 --> 00:29:19,700
not true this thing the smallest power

00:29:17,540 --> 00:29:21,170
of student takes all the values but in

00:29:19,700 --> 00:29:23,390
practice you passed and it's gonna work

00:29:21,170 --> 00:29:26,030
so this is a good because there's a bug

00:29:23,390 --> 00:29:27,500
in the code it might go unnoticed for a

00:29:26,030 --> 00:29:30,140
while because well there's no single

00:29:27,500 --> 00:29:31,640
exit point at the end so for this case

00:29:30,140 --> 00:29:34,090
it's kind of reasonable of course there

00:29:31,640 --> 00:29:37,940
is you could have something like this

00:29:34,090 --> 00:29:40,160
eagerly putting a value to return and so

00:29:37,940 --> 00:29:41,809
if nothing else worth at least you know

00:29:40,160 --> 00:29:44,090
what's going on or you could throw an

00:29:41,809 --> 00:29:45,950
exception or something you could also do

00:29:44,090 --> 00:29:48,440
it like this with a default if you feel

00:29:45,950 --> 00:29:49,910
like it to avoid the superfluous

00:29:48,440 --> 00:29:52,460
initialization at first so you don't

00:29:49,910 --> 00:29:55,670
forget the default here okay making

00:29:52,460 --> 00:29:57,020
sense yeah so depending on how you do it

00:29:55,670 --> 00:30:04,700
could be good could be bad as long as

00:29:57,020 --> 00:30:05,870
you're very rigorous about it one good

00:30:04,700 --> 00:30:07,309
trick of course is to write smaller

00:30:05,870 --> 00:30:09,140
functions that's one of the reasons I

00:30:07,309 --> 00:30:10,850
don't use many switches myself they make

00:30:09,140 --> 00:30:12,860
for a large code it's hard to reason

00:30:10,850 --> 00:30:14,420
about see if you have simple functions

00:30:12,860 --> 00:30:17,240
one fiction does one fashion does one

00:30:14,420 --> 00:30:19,640
thing the temptation to a mini return

00:30:17,240 --> 00:30:21,280
statements is a bit lower but it's not

00:30:19,640 --> 00:30:25,040
always practical if you look at this

00:30:21,280 --> 00:30:29,059
this is a handmade way to compute

00:30:25,040 --> 00:30:31,130
whether a year is a leap here what's a

00:30:29,059 --> 00:30:32,809
bit long-winded but if you're not trying

00:30:31,130 --> 00:30:37,040
to learn about if statements why not no

00:30:32,809 --> 00:30:39,830
it's okay it works better with you could

00:30:37,040 --> 00:30:43,130
write it like this but it's a bit more

00:30:39,830 --> 00:30:44,240
difficult to grasp probably things to be

00:30:43,130 --> 00:30:46,000
same reasoning but you have to think a

00:30:44,240 --> 00:30:49,610
bit more about it don't you

00:30:46,000 --> 00:30:51,560
requires more thought and you can also

00:30:49,610 --> 00:30:51,980
actually specify this is not that bad

00:30:51,560 --> 00:30:54,080
also

00:30:51,980 --> 00:30:55,510
but there's the if-else if-else if-else

00:30:54,080 --> 00:30:58,000
dense

00:30:55,510 --> 00:30:59,620
as long as you have the elite the last

00:30:58,000 --> 00:31:01,240
else at the end you can kinda see that

00:30:59,620 --> 00:31:05,620
it would return something at some point

00:31:01,240 --> 00:31:09,190
it's pretty safe but yeah but I'd argue

00:31:05,620 --> 00:31:12,250
that this this reads well doesn't it it

00:31:09,190 --> 00:31:13,840
reads well it's okay so you got all of

00:31:12,250 --> 00:31:16,240
your cases where you're actually

00:31:13,840 --> 00:31:17,770
applying rules and when you get to the

00:31:16,240 --> 00:31:21,340
end another rules applied well that was

00:31:17,770 --> 00:31:23,980
not one of them so get out I used to

00:31:21,340 --> 00:31:26,380
think that this was lack of effort and

00:31:23,980 --> 00:31:28,810
then when I was working on my PhD code

00:31:26,380 --> 00:31:30,790
and I started debugging very complex

00:31:28,810 --> 00:31:32,440
functions I realized that you know early

00:31:30,790 --> 00:31:35,860
return is actually pretty nice when

00:31:32,440 --> 00:31:37,450
you're debugging oh that brought a

00:31:35,860 --> 00:31:39,910
changed my mind maybe I should revisit

00:31:37,450 --> 00:31:41,650
that thinking because I could make

00:31:39,910 --> 00:31:44,890
better code and enhance my own

00:31:41,650 --> 00:31:46,510
experience with this now the language

00:31:44,890 --> 00:31:48,970
has changes everything at first so we

00:31:46,510 --> 00:31:50,830
have both new types now if you play with

00:31:48,970 --> 00:31:53,560
variant it's interesting to think about

00:31:50,830 --> 00:31:55,240
that early return kind of thing because

00:31:53,560 --> 00:31:57,670
you can actually have much better code

00:31:55,240 --> 00:32:00,070
if you're careful let's see if you

00:31:57,670 --> 00:32:01,930
suppose this example is a multi slide

00:32:00,070 --> 00:32:03,220
one it's a bit more complex but they

00:32:01,930 --> 00:32:05,290
kind of look the same from point to

00:32:03,220 --> 00:32:06,670
point so I'm doing I win this case with

00:32:05,290 --> 00:32:08,530
a message type I don't know if you can

00:32:06,670 --> 00:32:12,700
see it up front there's a message type

00:32:08,530 --> 00:32:15,300
in there and I add functions to write to

00:32:12,700 --> 00:32:18,670
some stream and read from some string a

00:32:15,300 --> 00:32:20,050
value so what I'm outputting I'm casting

00:32:18,670 --> 00:32:22,180
the thing to its underlying type I'm

00:32:20,050 --> 00:32:24,490
gonna get some kind of integer and when

00:32:22,180 --> 00:32:26,500
I'm reading I first sure that my stream

00:32:24,490 --> 00:32:29,380
is okay the first it that you can see

00:32:26,500 --> 00:32:32,230
and then return early if they're streams

00:32:29,380 --> 00:32:33,910
in a bad state because why continue and

00:32:32,230 --> 00:32:35,920
then I try to read something I like to

00:32:33,910 --> 00:32:39,250
see these new statements if in it

00:32:35,920 --> 00:32:40,990
semicolon condition they'll work fine

00:32:39,250 --> 00:32:44,380
from there their scopes they're very

00:32:40,990 --> 00:32:46,060
nice and once I have either managed to

00:32:44,380 --> 00:32:48,640
read something or not I return the

00:32:46,060 --> 00:32:49,900
stream so there's two exits but that's

00:32:48,640 --> 00:32:53,770
probably the peso fermentation that you

00:32:49,900 --> 00:32:56,980
could get in this case same thing there

00:32:53,770 --> 00:32:59,110
if you see the to my return statements

00:32:56,980 --> 00:33:00,940
there they are highlighted same thing

00:32:59,110 --> 00:33:03,700
with this message info kinda thing where

00:33:00,940 --> 00:33:06,190
I'm reusing quoted to read and write

00:33:03,700 --> 00:33:08,530
quoted is nice see this was 14 take care

00:33:06,190 --> 00:33:09,510
of the quote marks around your strings

00:33:08,530 --> 00:33:12,940
when there's spaces

00:33:09,510 --> 00:33:15,400
takes care of the inner quotes awesome

00:33:12,940 --> 00:33:17,320
we realize you might not like how you

00:33:15,400 --> 00:33:18,610
streams but makes for a nicer code so

00:33:17,320 --> 00:33:20,020
two returns again because I'm doing I

00:33:18,610 --> 00:33:21,940
know that's okay

00:33:20,020 --> 00:33:27,720
and again another two returns with a

00:33:21,940 --> 00:33:29,830
nerd catastrophic rigor code and now

00:33:27,720 --> 00:33:31,060
there's no blood as I was saying there's

00:33:29,830 --> 00:33:32,380
no reason to continue if you're trying

00:33:31,060 --> 00:33:34,840
to read from a stream its corrupted so

00:33:32,380 --> 00:33:37,930
just get out now this is where we get to

00:33:34,840 --> 00:33:39,730
that barian thing as everyone seen that

00:33:37,930 --> 00:33:42,280
overload structure there that we try to

00:33:39,730 --> 00:33:44,950
standardize but 4:20 but didn't get

00:33:42,280 --> 00:33:48,340
around to you can write your own it's a

00:33:44,950 --> 00:33:50,650
few lines at most the I'm using a

00:33:48,340 --> 00:33:52,120
variant in this case with mono state and

00:33:50,650 --> 00:33:53,680
the two types that might be in the

00:33:52,120 --> 00:33:56,020
variants why am i doing that because in

00:33:53,680 --> 00:33:58,350
the code I'm going to be using at first

00:33:56,020 --> 00:34:00,700
I'm going to be declaring a variable

00:33:58,350 --> 00:34:02,320
that's a point story to it and then

00:34:00,700 --> 00:34:05,590
return so I need some kind of default

00:34:02,320 --> 00:34:07,210
value sight is some kind of empty

00:34:05,590 --> 00:34:09,670
variant they thought before kind of

00:34:07,210 --> 00:34:11,200
thing I don't like that most I think I'd

00:34:09,670 --> 00:34:13,870
rather it's not there because it's not

00:34:11,200 --> 00:34:16,060
part of my interface it's clutter okay

00:34:13,870 --> 00:34:18,490
but for the fact that my first example

00:34:16,060 --> 00:34:19,540
will not be using multiple return

00:34:18,490 --> 00:34:22,150
signals I'm going to be kind of stuck

00:34:19,540 --> 00:34:26,440
with it that's that's a sign that

00:34:22,150 --> 00:34:28,690
something's wrong so my this is my visit

00:34:26,440 --> 00:34:31,060
in this case is using multiple lambdas

00:34:28,690 --> 00:34:32,890
I'm treating the mono state case but I

00:34:31,060 --> 00:34:35,380
shouldn't be because it's not part of my

00:34:32,890 --> 00:34:39,250
interface again but since I might want

00:34:35,380 --> 00:34:40,690
to use the other two and I need some

00:34:39,250 --> 00:34:42,730
kind of default what I have to cover

00:34:40,690 --> 00:34:44,260
this otherwise my code won't compile so

00:34:42,730 --> 00:34:47,110
I'm kind of making my code a bit dirty

00:34:44,260 --> 00:34:48,790
because I'm insisting on having a single

00:34:47,110 --> 00:34:51,370
return statement somewhere and I have

00:34:48,790 --> 00:34:56,770
some kind of need for a default whatever

00:34:51,370 --> 00:34:59,920
yep please it's it's it's an empty class

00:34:56,770 --> 00:35:02,350
that's that you can use for thank you

00:34:59,920 --> 00:35:03,880
the question for my friend there was

00:35:02,350 --> 00:35:07,210
what could you explain that when a state

00:35:03,880 --> 00:35:09,550
thing literally speaking so you have an

00:35:07,210 --> 00:35:11,320
opt for an empty optional and the mono

00:35:09,550 --> 00:35:12,910
state is something it you can use for a

00:35:11,320 --> 00:35:14,650
default value for a variant when you

00:35:12,910 --> 00:35:16,030
have many cases but you don't really

00:35:14,650 --> 00:35:17,830
want to put default constructors in each

00:35:16,030 --> 00:35:19,960
of them so you have something that's

00:35:17,830 --> 00:35:22,780
kind of stands for the empty variant

00:35:19,960 --> 00:35:25,480
kind of case but it's too

00:35:22,780 --> 00:35:27,820
it's a bit better back because you'd

00:35:25,480 --> 00:35:30,790
rather not have that if it's not doing

00:35:27,820 --> 00:35:32,350
something meaningful for you as that is

00:35:30,790 --> 00:35:34,540
that no cancer okay

00:35:32,350 --> 00:35:36,730
so if you look at this case the reason

00:35:34,540 --> 00:35:38,800
I'm adding B mono state is for the first

00:35:36,730 --> 00:35:41,410
line that's involved I'm saying message

00:35:38,800 --> 00:35:42,970
message semicolon so I need some kind of

00:35:41,410 --> 00:35:45,160
default value and parents the initialize

00:35:42,970 --> 00:35:46,360
the first member the first type by

00:35:45,160 --> 00:35:48,880
default if you don't do the thing it's

00:35:46,360 --> 00:35:52,060
special about it and then in the cases

00:35:48,880 --> 00:35:54,400
that I have if I'm reading an info I'm

00:35:52,060 --> 00:35:56,020
storing the info in there if I'm reading

00:35:54,400 --> 00:35:57,220
a warning and so in the warning and

00:35:56,020 --> 00:35:59,980
their parents are nice for that that

00:35:57,220 --> 00:36:02,470
works but and the end of returning the

00:35:59,980 --> 00:36:05,800
message which might be empty might be

00:36:02,470 --> 00:36:08,530
mono state if I read nothing of value so

00:36:05,800 --> 00:36:09,610
the stream was corrupt or whatever so

00:36:08,530 --> 00:36:12,250
I'm you think that when a state think

00:36:09,610 --> 00:36:14,320
there but subtly what I want to do it's

00:36:12,250 --> 00:36:15,880
just helping me along and it's got to be

00:36:14,320 --> 00:36:17,530
more efficient because I'm creating a

00:36:15,880 --> 00:36:19,870
default object that I'm going to replace

00:36:17,530 --> 00:36:23,380
by something else they're wrong default

00:36:19,870 --> 00:36:26,440
constructors tend to be bad things there

00:36:23,380 --> 00:36:28,090
are always Matz them so by by enforcing

00:36:26,440 --> 00:36:29,470
a single try to makes it in the specific

00:36:28,090 --> 00:36:34,780
case I'm making my code were complex it

00:36:29,470 --> 00:36:37,780
should be and it is floral so yeah so if

00:36:34,780 --> 00:36:40,900
you let yourself go without that thing

00:36:37,780 --> 00:36:42,580
if you let yourself work with early

00:36:40,900 --> 00:36:43,930
returns if you look at the code in this

00:36:42,580 --> 00:36:45,430
case I'm returning a message which you

00:36:43,930 --> 00:36:47,590
can see from the function signature up

00:36:45,430 --> 00:36:49,870
there and when I'm reading a message

00:36:47,590 --> 00:36:52,840
info and it works I'm returning it an

00:36:49,870 --> 00:36:55,210
info and if I'm reading a wording I'm

00:36:52,840 --> 00:36:57,070
returning a warning when I get to the

00:36:55,210 --> 00:36:58,690
end in this case while I'm returning an

00:36:57,070 --> 00:37:00,340
empty message which means in this case

00:36:58,690 --> 00:37:01,630
the string was corrupted it could I

00:37:00,340 --> 00:37:03,550
could also throw an extension or

00:37:01,630 --> 00:37:09,610
something like it's in this case my

00:37:03,550 --> 00:37:11,950
friend over there okay the question is

00:37:09,610 --> 00:37:15,370
there's this weird line at first assert

00:37:11,950 --> 00:37:16,030
not not is so not is means the stream is

00:37:15,370 --> 00:37:17,620
corrupted

00:37:16,030 --> 00:37:20,650
nothing that is means the stream is

00:37:17,620 --> 00:37:23,890
doing fine I'll leave it there for

00:37:20,650 --> 00:37:25,360
people to speak about it so yeah that's

00:37:23,890 --> 00:37:27,160
it I'm forcing it to a bull and then

00:37:25,360 --> 00:37:29,730
using the bool and turning it and said

00:37:27,160 --> 00:37:29,730
double hash string

00:37:31,200 --> 00:37:37,180
is that okay so in this case I can even

00:37:34,599 --> 00:37:39,730
do without if you use the exception as a

00:37:37,180 --> 00:37:42,010
signal that something went wrong you can

00:37:39,730 --> 00:37:43,630
do a way completely with the mellow

00:37:42,010 --> 00:37:45,609
State thing and you can have the variant

00:37:43,630 --> 00:37:51,640
that only as what you need so it's more

00:37:45,609 --> 00:37:53,470
efficient it's cleaner cool okay give

00:37:51,640 --> 00:37:54,670
new presentation so if you allow

00:37:53,470 --> 00:37:56,800
yourself of the both points of the

00:37:54,670 --> 00:37:59,170
exhibit some cases well you can reduce

00:37:56,800 --> 00:38:01,359
your code complexity somewhat you can

00:37:59,170 --> 00:38:03,280
limit yourself to constructing only the

00:38:01,359 --> 00:38:05,230
object that you actually need because

00:38:03,280 --> 00:38:07,270
you know when you have objects with

00:38:05,230 --> 00:38:08,859
constructors that are non-trivial you

00:38:07,270 --> 00:38:10,300
don't want to construct them without

00:38:08,859 --> 00:38:11,920
reason because it's cussing me

00:38:10,300 --> 00:38:14,890
processing time and resources and out

00:38:11,920 --> 00:38:16,270
and while you only pay the cost caster

00:38:14,890 --> 00:38:19,540
the default object if it's meaningful in

00:38:16,270 --> 00:38:24,580
your code if it's not why do so I said

00:38:19,540 --> 00:38:27,310
okay so I'm not saying spread the

00:38:24,580 --> 00:38:30,280
multiple returns without thinking that

00:38:27,310 --> 00:38:31,480
without thinking part is that way but if

00:38:30,280 --> 00:38:34,570
you so if you write small functions it

00:38:31,480 --> 00:38:37,570
will occur lecithin of course and if you

00:38:34,570 --> 00:38:38,800
just it's not inherently bad it can help

00:38:37,570 --> 00:38:41,130
make better code so that's that's

00:38:38,800 --> 00:38:45,780
actually fine you're still my friends

00:38:41,130 --> 00:38:45,780
okay there's no hatred in the room yes I

00:38:45,810 --> 00:38:53,130
have colleagues say data members should

00:38:49,450 --> 00:38:57,250
all be private not this Borg thing is

00:38:53,130 --> 00:38:58,810
eccentric Richards I'm sorry and yes yes

00:38:57,250 --> 00:39:00,339
it's a good thing I've said that to

00:38:58,810 --> 00:39:01,750
students for years to make your stuff

00:39:00,339 --> 00:39:03,250
private because you don't know what's

00:39:01,750 --> 00:39:04,930
going on in the future it may be

00:39:03,250 --> 00:39:07,420
something one might want control over it

00:39:04,930 --> 00:39:09,460
or something it's actually character you

00:39:07,420 --> 00:39:12,400
know and this person there there's a

00:39:09,460 --> 00:39:14,530
name in an age and I think people

00:39:12,400 --> 00:39:16,359
construct the person with a name in an

00:39:14,530 --> 00:39:17,830
age if they feel like it could very date

00:39:16,359 --> 00:39:20,349
the thing that's okay that's fine and

00:39:17,830 --> 00:39:21,490
I'm letting them consult the values

00:39:20,349 --> 00:39:23,740
without modifying them afterwards

00:39:21,490 --> 00:39:26,010
because who wants his or her name to be

00:39:23,740 --> 00:39:29,080
changed without permission

00:39:26,010 --> 00:39:30,220
don't answer that would be scary and so

00:39:29,080 --> 00:39:34,300
this is a fixed

00:39:30,220 --> 00:39:36,369
age person the ageless person why not so

00:39:34,300 --> 00:39:38,980
if you put your data members public like

00:39:36,369 --> 00:39:40,869
this well it will still work but people

00:39:38,980 --> 00:39:43,210
can access to this so if you're saying

00:39:40,869 --> 00:39:46,300
well changing the every person is bad

00:39:43,210 --> 00:39:49,150
is order consent yeah it's nothing

00:39:46,300 --> 00:39:50,680
shitty nice they're used to death with

00:39:49,150 --> 00:39:53,470
discipline you know with languages that

00:39:50,680 --> 00:39:56,290
are objected without private public or

00:39:53,470 --> 00:39:58,089
such access control mentions in the code

00:39:56,290 --> 00:40:01,060
I had a teacher when I was younger

00:39:58,089 --> 00:40:02,980
bearded guy named August bright bright

00:40:01,060 --> 00:40:04,270
person but the language that he used to

00:40:02,980 --> 00:40:06,220
teach us object-orientation

00:40:04,270 --> 00:40:09,220
had no such thing as public or private

00:40:06,220 --> 00:40:12,550
with him so he wasn't first thing the

00:40:09,220 --> 00:40:15,070
rules with underscores so he put

00:40:12,550 --> 00:40:17,380
underscores just before it's variable

00:40:15,070 --> 00:40:19,180
but it was a bit of a rough person the

00:40:17,380 --> 00:40:20,410
sense that you'd say that he spent times

00:40:19,180 --> 00:40:21,640
in the woods with the animals and

00:40:20,410 --> 00:40:24,040
everything but he was a bright bright

00:40:21,640 --> 00:40:26,020
computer scientist a very inspiring used

00:40:24,040 --> 00:40:30,580
to smoke and just besides the no smoking

00:40:26,020 --> 00:40:32,109
things and that we were students so the

00:40:30,580 --> 00:40:33,220
guy was nice and that's the point I

00:40:32,109 --> 00:40:34,960
asked him why do you put those little

00:40:33,220 --> 00:40:37,000
underscores like besides your variables

00:40:34,960 --> 00:40:41,740
instead because you're not supposed to

00:40:37,000 --> 00:40:43,330
touch them so if you can add another one

00:40:41,740 --> 00:40:46,000
and then another one until you stop

00:40:43,330 --> 00:40:47,200
touching them the first thing for

00:40:46,000 --> 00:40:49,180
animating through discipline kind of

00:40:47,200 --> 00:40:50,800
works if you say if she said just I'm

00:40:49,180 --> 00:40:53,609
gonna break the contract until you stop

00:40:50,800 --> 00:40:56,050
but but it takes time to do this kind of

00:40:53,609 --> 00:40:57,730
management of source code so you might

00:40:56,050 --> 00:40:59,640
not want to do that so private and

00:40:57,730 --> 00:41:04,869
public is better but you can't enforce

00:40:59,640 --> 00:41:06,130
discipline through violence and this is

00:41:04,869 --> 00:41:07,839
a component of course when you have a

00:41:06,130 --> 00:41:08,619
struck the data members are public by

00:41:07,839 --> 00:41:11,050
default yeah

00:41:08,619 --> 00:41:12,670
so yeah the first thing this thing's

00:41:11,050 --> 00:41:14,349
seen as part of regular encapsulation

00:41:12,670 --> 00:41:16,990
because you want to make sure that you

00:41:14,349 --> 00:41:19,030
can keep your invariants okay but but

00:41:16,990 --> 00:41:21,099
you know not all types and invariants to

00:41:19,030 --> 00:41:23,650
enforce so sometimes they're just data

00:41:21,099 --> 00:41:25,990
and I know that people they are aware

00:41:23,650 --> 00:41:28,300
this stuff so if you have a like three

00:41:25,990 --> 00:41:30,790
point or something like this X Y Z and

00:41:28,300 --> 00:41:32,260
you know three care what the values of

00:41:30,790 --> 00:41:33,970
each of them are there's no specific

00:41:32,260 --> 00:41:35,109
rules as to where they're supposed to go

00:41:33,970 --> 00:41:38,980
you're not tracking when they're

00:41:35,109 --> 00:41:41,890
changing or something this is probably

00:41:38,980 --> 00:41:44,790
overkill a bit you can just you go along

00:41:41,890 --> 00:41:47,790
with something like this is that okay

00:41:44,790 --> 00:41:47,790
yep

00:41:51,499 --> 00:41:55,410
so please allow me to use a phrase that

00:41:54,269 --> 00:41:58,740
you have been use with my mind my

00:41:55,410 --> 00:42:01,400
students objects are rock stars they

00:41:58,740 --> 00:42:01,400
don't know they're children

00:42:01,670 --> 00:42:06,180
okay so predict it is only given in very

00:42:04,799 --> 00:42:09,529
controlled cases otherwise it's as bad

00:42:06,180 --> 00:42:15,420
as public and it's the honest answer

00:42:09,529 --> 00:42:17,579
stays here when it's predicted it's a

00:42:15,420 --> 00:42:19,440
good smell did our research are

00:42:17,579 --> 00:42:20,970
connected but they're few and far

00:42:19,440 --> 00:42:24,930
between if you put predict by default

00:42:20,970 --> 00:42:26,789
think about it so yeah it's a case could

00:42:24,930 --> 00:42:28,619
be made for like think ahead you don't

00:42:26,789 --> 00:42:30,240
know what invariance you might want to

00:42:28,619 --> 00:42:31,769
add in your code later on but think

00:42:30,240 --> 00:42:32,970
about it if you're changing invariance

00:42:31,769 --> 00:42:35,430
of your class once you've pushed them

00:42:32,970 --> 00:42:36,509
away you're changing the code you should

00:42:35,430 --> 00:42:38,160
probably use another name or something

00:42:36,509 --> 00:42:39,839
because it's a new class people have

00:42:38,160 --> 00:42:44,069
been using new one anyway so think about

00:42:39,839 --> 00:42:46,049
it so thinking ahead is cool but putting

00:42:44,069 --> 00:42:47,400
code in case someone in 10 years might

00:42:46,049 --> 00:42:49,890
really do maybe you should think about

00:42:47,400 --> 00:42:51,420
new you type properties would be nice

00:42:49,890 --> 00:42:53,730
for this but we not have them in C++

00:42:51,420 --> 00:42:57,779
yeah there are proposals if you were to

00:42:53,730 --> 00:42:59,339
push for them so yeah the trick is to

00:42:57,779 --> 00:43:02,400
take a design through a bit so write

00:42:59,339 --> 00:43:05,339
small classes document your invariants

00:43:02,400 --> 00:43:06,299
and in general just make it private but

00:43:05,339 --> 00:43:09,359
if they you have known variants to

00:43:06,299 --> 00:43:10,710
enforce probably overkill and so yeah if

00:43:09,359 --> 00:43:13,680
you have palliative members you probably

00:43:10,710 --> 00:43:15,509
have doing variants your tights are

00:43:13,680 --> 00:43:16,890
probably mutable because otherwise you

00:43:15,509 --> 00:43:18,480
wouldn't be making them public in the

00:43:16,890 --> 00:43:20,670
first place and they're probably final

00:43:18,480 --> 00:43:22,170
because if you have child classes trying

00:43:20,670 --> 00:43:23,940
to do things well they're going to have

00:43:22,170 --> 00:43:29,549
to resort to private inheritance to to

00:43:23,940 --> 00:43:31,259
make things work making sense so just

00:43:29,549 --> 00:43:33,029
note because I read the question before

00:43:31,259 --> 00:43:35,190
that these two are not equivalent you

00:43:33,029 --> 00:43:37,410
don't want to do the one on top you want

00:43:35,190 --> 00:43:39,779
to do the one at the bottom you see that

00:43:37,410 --> 00:43:41,670
the content remembers that they're

00:43:39,779 --> 00:43:45,720
they're legal but they complicate

00:43:41,670 --> 00:43:47,609
reasoning in some cases your read your

00:43:45,720 --> 00:43:49,619
containers need to resort to tricks to

00:43:47,609 --> 00:43:54,809
make these things work so prefer the one

00:43:49,619 --> 00:43:57,470
at the bottom okay and maybe one last

00:43:54,809 --> 00:43:59,830
one for today because time flies

00:43:57,470 --> 00:44:01,600
initialize all of your variable

00:43:59,830 --> 00:44:04,890
so this is so cool those who do embedded

00:44:01,600 --> 00:44:07,300
systems know our wrong disses don't you

00:44:04,890 --> 00:44:08,770
because it got something and when I had

00:44:07,300 --> 00:44:11,110
c-sharp programmer is trying to drain

00:44:08,770 --> 00:44:12,730
secret sauce with me and saying why why

00:44:11,110 --> 00:44:16,120
isn't it finished ice to zero because it

00:44:12,730 --> 00:44:19,510
costs something it's just a zero have

00:44:16,120 --> 00:44:21,370
you measured that so instead of doing

00:44:19,510 --> 00:44:23,260
the thing that people say instead of

00:44:21,370 --> 00:44:26,020
doing things on top there and int and

00:44:23,260 --> 00:44:28,150
float F string s liqueur whatever do

00:44:26,020 --> 00:44:34,030
things at the bottom they're okay with

00:44:28,150 --> 00:44:36,040
you yeah wrong I'm totally agreeing with

00:44:34,030 --> 00:44:39,130
you a string s with the code code it's

00:44:36,040 --> 00:44:42,420
even it's slower it's bad thing or you

00:44:39,130 --> 00:44:49,090
can go for this like this

00:44:42,420 --> 00:44:50,680
why no there's no assignment there it's

00:44:49,090 --> 00:44:52,570
a construction you have an assignment if

00:44:50,680 --> 00:44:53,740
the variable already exists this is just

00:44:52,570 --> 00:44:54,940
a constructor in our case and it's the

00:44:53,740 --> 00:44:56,590
default constructor it's actually

00:44:54,940 --> 00:44:58,570
equivalent to if you had put the right

00:44:56,590 --> 00:45:02,620
kind of it rolls and the string case is

00:44:58,570 --> 00:45:06,520
the same as on top you can use you're

00:45:02,620 --> 00:45:08,800
saying this you're in my mind so but III

00:45:06,520 --> 00:45:10,450
like to some need the brace brace thing

00:45:08,800 --> 00:45:13,600
it works for me I know it does refer you

00:45:10,450 --> 00:45:18,040
on the room but it works to me but don't

00:45:13,600 --> 00:45:18,700
do it like this yes it's a peephole

00:45:18,040 --> 00:45:20,560
that's right

00:45:18,700 --> 00:45:23,620
if you do int N equals n Parent Program

00:45:20,560 --> 00:45:24,820
it brings zero to you and yes you say

00:45:23,620 --> 00:45:28,030
it's going to be the same thing as in

00:45:24,820 --> 00:45:29,320
fan parent parent no replace the end

00:45:28,030 --> 00:45:35,830
with an F and you'll see it right away

00:45:29,320 --> 00:45:37,300
so don't do that yes my friend in this

00:45:35,830 --> 00:45:39,490
case you mean it's the same thing as

00:45:37,300 --> 00:45:41,710
vector of X V semicolon same thing thank

00:45:39,490 --> 00:45:42,820
you yeah if you doing generate code it's

00:45:41,710 --> 00:45:44,440
fun because you have a generic solution

00:45:42,820 --> 00:45:46,510
though but yeah it doesn't bring

00:45:44,440 --> 00:45:47,860
anything more actually agree with you so

00:45:46,510 --> 00:45:49,300
if you're doing specific stuff with

00:45:47,860 --> 00:45:50,680
vector you have lost the thing but you

00:45:49,300 --> 00:45:52,360
have gained nothing it's cost you two

00:45:50,680 --> 00:45:53,980
characters if you're doing generate

00:45:52,360 --> 00:45:55,150
stuff well do you have a solution that

00:45:53,980 --> 00:45:56,290
works for everything so it's kind of

00:45:55,150 --> 00:45:58,180
neat can you do that

00:45:56,290 --> 00:46:00,760
okay depending what you want to say

00:45:58,180 --> 00:46:01,360
force I'm not saying to do I'm saying

00:46:00,760 --> 00:46:04,810
it's a myth

00:46:01,360 --> 00:46:06,190
yeah so don't do this and this actually

00:46:04,810 --> 00:46:08,320
works which is suppose you have in mind

00:46:06,190 --> 00:46:13,180
I guess so so you're in this different

00:46:08,320 --> 00:46:13,390
choice and everything so so but do you

00:46:13,180 --> 00:46:15,820
have

00:46:13,390 --> 00:46:18,580
we need to Nisha is everything a lot of

00:46:15,820 --> 00:46:21,280
you that in most cases no no because

00:46:18,580 --> 00:46:23,350
there is many minimum of course if you

00:46:21,280 --> 00:46:24,910
are ready to construct your object

00:46:23,350 --> 00:46:27,780
because you know what you want to put in

00:46:24,910 --> 00:46:34,630
it it's the time to do so

00:46:27,780 --> 00:46:37,060
but there are costs that so yeah this is

00:46:34,630 --> 00:46:39,040
probably easy for you folks there's a

00:46:37,060 --> 00:46:40,840
distinction c++ between declaration and

00:46:39,040 --> 00:46:42,130
definition you can repeat declarations

00:46:40,840 --> 00:46:43,540
you cannot repeat definitions because

00:46:42,130 --> 00:46:44,380
there's something called eco dr that

00:46:43,540 --> 00:46:48,340
will bite you

00:46:44,380 --> 00:46:51,810
and it has big teeth now you haven't

00:46:48,340 --> 00:46:54,070
seen you do at night be careful

00:46:51,810 --> 00:46:55,750
something so you have to be careful with

00:46:54,070 --> 00:46:59,080
this

00:46:55,750 --> 00:47:00,730
so the code that you have on top is sea

00:46:59,080 --> 00:47:02,830
shark code which doesn't compile because

00:47:00,730 --> 00:47:04,870
you're initializing you're declaring and

00:47:02,830 --> 00:47:06,460
without initializing it conceptually

00:47:04,870 --> 00:47:08,140
speaking it at 0 in it but you're not

00:47:06,460 --> 00:47:10,300
supposed to know about it and then

00:47:08,140 --> 00:47:13,120
you're doing a right line to put that

00:47:10,300 --> 00:47:16,060
thing on screen and you know you have

00:47:13,120 --> 00:47:17,920
not initialized your variable but funny

00:47:16,060 --> 00:47:20,260
thing if you look at the code at the

00:47:17,920 --> 00:47:21,760
bottom there's this array then you have

00:47:20,260 --> 00:47:22,960
nothing shines the instant you read but

00:47:21,760 --> 00:47:24,640
because you didn't you it does you

00:47:22,960 --> 00:47:28,720
initialize everything you do it works

00:47:24,640 --> 00:47:31,810
like magic which which makes me feel

00:47:28,720 --> 00:47:33,670
very bad so if you doing C++ and you

00:47:31,810 --> 00:47:37,300
look at the code that's on top well

00:47:33,670 --> 00:47:39,790
someone has put 0 into NY because it's

00:47:37,300 --> 00:47:43,420
supposed to be done that way when then

00:47:39,790 --> 00:47:45,940
reading into n which Kenneth is making

00:47:43,420 --> 00:47:48,340
the initialization probably redundant

00:47:45,940 --> 00:47:51,430
unless of course you're using and even

00:47:48,340 --> 00:47:53,710
if the you reading has failed just K we

00:47:51,430 --> 00:47:55,720
can be kind of weird you could do the

00:47:53,710 --> 00:47:58,000
metal thing uninitialized and then write

00:47:55,720 --> 00:48:00,010
to it of course please don't use the N

00:47:58,000 --> 00:48:02,200
if the reading has not worked in the a

00:48:00,010 --> 00:48:04,360
statement or I think even better than

00:48:02,200 --> 00:48:05,770
one at the bottom which scopes the end

00:48:04,360 --> 00:48:07,150
and the if and removes all of the

00:48:05,770 --> 00:48:10,720
problems that okay

00:48:07,150 --> 00:48:11,740
it's cops are cool aren't they yeah

00:48:10,720 --> 00:48:15,190
netskope's

00:48:11,740 --> 00:48:16,780
who so yeah so the point in history

00:48:15,190 --> 00:48:17,620
suppose those who use it it's because

00:48:16,780 --> 00:48:19,510
they don't want to leave in your

00:48:17,620 --> 00:48:21,010
analyzed either around but that comes

00:48:19,510 --> 00:48:23,140
back to the time when people wrote very

00:48:21,010 --> 00:48:27,930
large functions put their variables on

00:48:23,140 --> 00:48:27,930
top and use them lower doesn't it

00:48:28,589 --> 00:48:36,160
it's been a while like smaller functions

00:48:32,770 --> 00:48:36,819
better toejam and code that's in size at

00:48:36,160 --> 00:48:38,530
the right moment

00:48:36,819 --> 00:48:40,960
better put gel so that's called c-plus

00:48:38,530 --> 00:48:42,730
does so so this tradition and adding

00:48:40,960 --> 00:48:44,289
decoration and then initialization it

00:48:42,730 --> 00:48:45,849
still makes sense when you're with

00:48:44,289 --> 00:48:47,289
beginners and you have to think about

00:48:45,849 --> 00:48:49,030
the code they did not know what's going

00:48:47,289 --> 00:48:50,859
on but that will experience people it's

00:48:49,030 --> 00:48:53,440
not a good thing so if you initialize

00:48:50,859 --> 00:48:54,880
things that usually bad you know but you

00:48:53,440 --> 00:48:56,829
don't have to if it doesn't make any

00:48:54,880 --> 00:48:58,960
sense and if you're not sure did I

00:48:56,829 --> 00:49:03,039
initialize that variable or not your

00:48:58,960 --> 00:49:05,410
function is too big be meters to

00:49:03,039 --> 00:49:08,109
functions in there so the code that I

00:49:05,410 --> 00:49:09,730
put in my friend function there that's

00:49:08,109 --> 00:49:12,940
trying to read the tough for my person

00:49:09,730 --> 00:49:14,829
is initializing string and declaring

00:49:12,940 --> 00:49:16,119
names now depending in age not the

00:49:14,829 --> 00:49:18,430
string constructor is costing me

00:49:16,119 --> 00:49:20,170
something not much with something the

00:49:18,430 --> 00:49:23,079
ShoreTel structures disgusting me much

00:49:20,170 --> 00:49:25,089
and if my stream is feeling bad

00:49:23,079 --> 00:49:27,970
I'm getting out why the hell did I

00:49:25,089 --> 00:49:29,760
declare my name seriously what's the

00:49:27,970 --> 00:49:32,859
point

00:49:29,760 --> 00:49:35,859
this is better because I'm declaring the

00:49:32,859 --> 00:49:39,329
string only after I know that I might be

00:49:35,859 --> 00:49:41,710
in the position to use it making sense

00:49:39,329 --> 00:49:45,279
it's not it's not as wasteful

00:49:41,710 --> 00:49:48,339
the age is a bit like early but it's

00:49:45,279 --> 00:49:50,109
trivial so I don't care that much and

00:49:48,339 --> 00:49:52,240
this is a bit better also because now my

00:49:50,109 --> 00:49:56,170
name is code by DF that uses it it's not

00:49:52,240 --> 00:49:59,079
used anywhere else in our code nicer is

00:49:56,170 --> 00:50:01,660
that ok not maybe one thing in the if

00:49:59,079 --> 00:50:04,270
statement I'm initializing P in one one

00:50:01,660 --> 00:50:06,309
statement because I don't want partly

00:50:04,270 --> 00:50:07,930
initialize variables you know if you're

00:50:06,309 --> 00:50:10,210
trying to read directly the name and

00:50:07,930 --> 00:50:11,680
then directly the age and if the reading

00:50:10,210 --> 00:50:14,619
of the name works in the ringing of the

00:50:11,680 --> 00:50:18,819
age fails you have initialized in part

00:50:14,619 --> 00:50:21,630
object and that's not fun so don't do

00:50:18,819 --> 00:50:21,630
that there okay

00:50:21,900 --> 00:50:25,080
all right this is this is gonna be

00:50:23,820 --> 00:50:27,000
better still if you feel like you to get

00:50:25,080 --> 00:50:28,740
evanescent ifs and have shorter scopes

00:50:27,000 --> 00:50:33,450
again with these shortened doesn't do

00:50:28,740 --> 00:50:34,380
much that okay cool and when you really

00:50:33,450 --> 00:50:35,970
really need to do two-step

00:50:34,380 --> 00:50:37,350
initializations instead of leaving it in

00:50:35,970 --> 00:50:38,760
awhile you can write to effect

00:50:37,350 --> 00:50:41,460
reflections we can actually make them

00:50:38,760 --> 00:50:43,710
very efficient in C++ don't stop

00:50:41,460 --> 00:50:45,420
yourself for anything fun this avoids

00:50:43,710 --> 00:50:47,130
making the initialized objects into

00:50:45,420 --> 00:50:49,800
client code so if you know that you

00:50:47,130 --> 00:50:52,560
shouldn't be adding an empty object in

00:50:49,800 --> 00:50:54,360
your code but you do need to do like IO

00:50:52,560 --> 00:50:55,830
like this so you're going to have to

00:50:54,360 --> 00:50:58,050
declare an empty object at some point

00:50:55,830 --> 00:51:00,110
it's going to be nasty a bit and CAPTCHA

00:50:58,050 --> 00:51:02,820
like that don't get that that leak out

00:51:00,110 --> 00:51:04,590
so I have this two-step thing there this

00:51:02,820 --> 00:51:07,800
is a neat function that really needs to

00:51:04,590 --> 00:51:09,660
be call for some reason and well the

00:51:07,800 --> 00:51:10,740
default constructor there might not be

00:51:09,660 --> 00:51:12,360
something that I want to exposed to

00:51:10,740 --> 00:51:15,030
client code that would have predicted in

00:51:12,360 --> 00:51:16,140
this case but I had a friend that does

00:51:15,030 --> 00:51:18,510
discrete two-step thing

00:51:16,140 --> 00:51:20,970
that one I control I deliver with the

00:51:18,510 --> 00:51:23,210
same files so that nobody tries to hack

00:51:20,970 --> 00:51:25,620
me or something because people are bad

00:51:23,210 --> 00:51:26,220
and then create to step in a control

00:51:25,620 --> 00:51:28,830
environment

00:51:26,220 --> 00:51:30,960
I can do my initialize thing no because

00:51:28,830 --> 00:51:33,210
I control the situation and what it will

00:51:30,960 --> 00:51:35,160
not leak outside as analyze data and

00:51:33,210 --> 00:51:36,360
then I imitate and then I return it one

00:51:35,160 --> 00:51:39,240
that once I've done that's pretty fine

00:51:36,360 --> 00:51:42,000
so in mind when I create the thing I get

00:51:39,240 --> 00:51:45,240
it fully initialized that's okay making

00:51:42,000 --> 00:51:47,520
sense like this to get the name bar vo

00:51:45,240 --> 00:51:50,690
effect that you might probably want if

00:51:47,520 --> 00:51:54,900
you want to be in stock yesterday cool

00:51:50,690 --> 00:51:56,330
cool there so even in other languages

00:51:54,900 --> 00:51:58,650
that they could practice anyway this is

00:51:56,330 --> 00:52:00,300
Java code if I'm not mistaken there's

00:51:58,650 --> 00:52:02,610
this make function there that will

00:52:00,300 --> 00:52:05,100
create an X at some point whatever and

00:52:02,610 --> 00:52:06,870
there's this use X thing that has an X

00:52:05,100 --> 00:52:09,810
and at some point initializes it with

00:52:06,870 --> 00:52:11,730
make X don't know declare when you're

00:52:09,810 --> 00:52:12,840
ready that's it okay otherwise you have

00:52:11,730 --> 00:52:17,850
something floating about there's no

00:52:12,840 --> 00:52:19,980
reason for that that's bad so cool so

00:52:17,850 --> 00:52:21,120
yeah the usual three supplies so thank

00:52:19,980 --> 00:52:23,550
you for your code for all the response

00:52:21,120 --> 00:52:26,600
functions you'll be happy declare

00:52:23,550 --> 00:52:28,740
objects when needed and where needed

00:52:26,600 --> 00:52:30,150
yeah and keep your objects close to

00:52:28,740 --> 00:52:31,770
point of view so you'll have less

00:52:30,150 --> 00:52:34,570
garbage lying around and if you have

00:52:31,770 --> 00:52:38,440
small functions that's a no-brainer

00:52:34,570 --> 00:52:42,190
so because I don't want people getting

00:52:38,440 --> 00:52:42,820
out in the room saying news go to avoid

00:52:42,190 --> 00:52:44,470
tutus

00:52:42,820 --> 00:52:46,870
unless you have a reason that you can

00:52:44,470 --> 00:52:50,020
measure for it's not that dirty but it

00:52:46,870 --> 00:52:51,010
is a cold smell so we look at it we look

00:52:50,020 --> 00:52:53,530
at code it works

00:52:51,010 --> 00:52:55,390
we only ins and outs and we still feel

00:52:53,530 --> 00:52:58,030
bad so that's a sign if you don't feel

00:52:55,390 --> 00:52:59,860
bad we have to talk but not today

00:52:58,030 --> 00:53:01,240
because either play instead sketch so

00:52:59,860 --> 00:53:03,100
keep recorded there Ivor our liberal

00:53:01,240 --> 00:53:06,340
obsessions easier to reason about easier

00:53:03,100 --> 00:53:09,550
to understand cuss lists manage multiple

00:53:06,340 --> 00:53:11,530
returns are not bad but if your

00:53:09,550 --> 00:53:14,620
functions are small and their role is

00:53:11,530 --> 00:53:15,790
clear you will need them less and make

00:53:14,620 --> 00:53:18,190
sure you need the key mention reasons

00:53:15,790 --> 00:53:19,960
and you don't leak stuff so dub to it

00:53:18,190 --> 00:53:21,850
for laziness do it because every reason

00:53:19,960 --> 00:53:24,340
there's a reason that's cool you think

00:53:21,850 --> 00:53:26,980
about things recipes are bad if you

00:53:24,340 --> 00:53:29,680
don't think about things and no you

00:53:26,980 --> 00:53:31,180
don't need to initialize everything but

00:53:29,680 --> 00:53:32,410
but it might be a good reason you have

00:53:31,180 --> 00:53:35,020
to be careful sometimes it's wasteful

00:53:32,410 --> 00:53:37,420
you just waste think oh why Wisco do you

00:53:35,020 --> 00:53:39,040
find them when you need it and if you

00:53:37,420 --> 00:53:41,170
needed to set initialisation thing well

00:53:39,040 --> 00:53:42,400
we have our view and then our view right

00:53:41,170 --> 00:53:46,720
a factory function they're efficient in

00:53:42,400 --> 00:53:48,550
C++ and know you don't have to make

00:53:46,720 --> 00:53:50,410
everything private private but it does

00:53:48,550 --> 00:53:52,960
ease refactoring it can make your life

00:53:50,410 --> 00:53:54,250
easier indeed but if you don't any

00:53:52,960 --> 00:53:56,410
inference you don't have to feel that

00:53:54,250 --> 00:53:59,530
dirty that she didn't make it in the

00:53:56,410 --> 00:54:01,000
first place it's okay so I hoped it

00:53:59,530 --> 00:54:02,860
consoles you and I should sleep better

00:54:01,000 --> 00:54:05,890
if you do something like this in a

00:54:02,860 --> 00:54:07,060
document and manner I have a number of

00:54:05,890 --> 00:54:08,770
other slides but you won't have the time

00:54:07,060 --> 00:54:09,760
to go over them and they will be put

00:54:08,770 --> 00:54:11,500
there because there are other

00:54:09,760 --> 00:54:12,760
performance rootedness at the end so if

00:54:11,500 --> 00:54:14,590
you want to take the slide after the

00:54:12,760 --> 00:54:16,150
talk of course feel free to do so and

00:54:14,590 --> 00:54:17,740
play with got both and use the code

00:54:16,150 --> 00:54:21,160
examples and everything but in the

00:54:17,740 --> 00:54:23,790
meantime if you want to go with threats

00:54:21,160 --> 00:54:23,790
or anything

00:54:27,540 --> 00:54:40,020
Oh mr. summer lab puppies this summer we

00:54:35,130 --> 00:54:42,240
have been miss Rossi blast fest if we

00:54:40,020 --> 00:54:44,100
could be single entry single exit

00:54:42,240 --> 00:54:48,060
principle that comes from safety

00:54:44,100 --> 00:54:49,470
guidelines has the same sources that you

00:54:48,060 --> 00:54:50,250
decided but we came to a different

00:54:49,470 --> 00:54:52,380
conclusion

00:54:50,250 --> 00:54:54,480
it's about distracted programming and

00:54:52,380 --> 00:54:56,730
return is a structured programming term

00:54:54,480 --> 00:54:59,460
the function will always return to the

00:54:56,730 --> 00:55:01,200
call side if you return regardless how

00:54:59,460 --> 00:55:05,850
many returns you have in your function

00:55:01,200 --> 00:55:08,940
yeah it's perfectly not violating the

00:55:05,850 --> 00:55:10,800
single exit principle by just using

00:55:08,940 --> 00:55:11,700
multiple returns because you return to

00:55:10,800 --> 00:55:15,360
the same place

00:55:11,700 --> 00:55:17,940
I swim here with you I did my point I

00:55:15,360 --> 00:55:19,260
think was that people still teach it as

00:55:17,940 --> 00:55:22,320
something good but it comes from another

00:55:19,260 --> 00:55:25,050
era and now we have objects and we have

00:55:22,320 --> 00:55:26,250
constructors and this is wasteful so as

00:55:25,050 --> 00:55:27,270
long as you make sure that you've gone

00:55:26,250 --> 00:55:28,920
through everything and you have good

00:55:27,270 --> 00:55:31,260
tools to that date it it's perfectly

00:55:28,920 --> 00:55:33,840
fine to do so as long as as long as

00:55:31,260 --> 00:55:36,300
you're not just lazy and just doing bad

00:55:33,840 --> 00:55:38,160
code because you can do it short

00:55:36,300 --> 00:55:39,690
functions are helping sure if I

00:55:38,160 --> 00:55:42,870
shouldn't make everyone at the end you

00:55:39,690 --> 00:55:44,940
don't debug much better hello

00:55:42,870 --> 00:55:46,350
two years ago Kevin and he made a talk

00:55:44,940 --> 00:55:49,290
about structured programming yet

00:55:46,350 --> 00:55:51,570
hecu if I remember correctly in which he

00:55:49,290 --> 00:55:53,040
talks about multiple returns and he

00:55:51,570 --> 00:55:54,750
argues that multiple returns are

00:55:53,040 --> 00:55:57,540
acceptable as long as you keep an

00:55:54,750 --> 00:55:59,370
else--if branch afterwards so that from

00:55:57,540 --> 00:56:00,990
top level readability you can still see

00:55:59,370 --> 00:56:02,400
the flow of the function without having

00:56:00,990 --> 00:56:03,780
to go all the way to the end of the line

00:56:02,400 --> 00:56:05,880
to see that there's actually a control

00:56:03,780 --> 00:56:07,140
breach do you agree with that well you

00:56:05,880 --> 00:56:08,460
want to make sure that there doesn't

00:56:07,140 --> 00:56:09,540
wait to get out without problem if you

00:56:08,460 --> 00:56:12,480
have your default case in your switch

00:56:09,540 --> 00:56:14,610
you're okay they at my surprise when I

00:56:12,480 --> 00:56:16,620
ran tests some teashop compilers do this

00:56:14,610 --> 00:56:18,210
wrong there's there's no way to get out

00:56:16,620 --> 00:56:20,310
of infection without eating something

00:56:18,210 --> 00:56:22,290
but it's sometimes don't see it's not as

00:56:20,310 --> 00:56:24,360
I thought with a soft problem to be

00:56:22,290 --> 00:56:26,700
honest and I realize it's not compares

00:56:24,360 --> 00:56:29,760
are not always good our simple sauce

00:56:26,700 --> 00:56:31,920
companies are good at tracking this but

00:56:29,760 --> 00:56:33,750
yeah and there's the out the word case

00:56:31,920 --> 00:56:36,060
of unreachable code sometimes that you

00:56:33,750 --> 00:56:37,620
want to get out or but yeah I agree with

00:56:36,060 --> 00:56:39,300
you as long as you have a clear way to

00:56:37,620 --> 00:56:40,130
say that yeah there's no way to get out

00:56:39,300 --> 00:56:42,320
of my function

00:56:40,130 --> 00:56:45,770
without initializing something that's

00:56:42,320 --> 00:56:47,090
pretty good as you can see I do it now I

00:56:45,770 --> 00:56:48,890
think it's a good thing leads to a

00:56:47,090 --> 00:56:50,780
bigger better debugging experience but

00:56:48,890 --> 00:56:53,120
as you're boosting if you say gonna go

00:56:50,780 --> 00:56:58,880
smaller functions are so much simpler to

00:56:53,120 --> 00:57:02,030
reason but they are thank you okay let's

00:56:58,880 --> 00:57:09,580
meet you same here and thank you for an

00:57:02,030 --> 00:57:12,500
inspiring talk I didn't expect that to

00:57:09,580 --> 00:57:15,590
make here one about leaving the

00:57:12,500 --> 00:57:19,250
variables uninitialized i would add to

00:57:15,590 --> 00:57:22,250
your list that it may be even safer to

00:57:19,250 --> 00:57:27,500
leave it uninitialized natural because

00:57:22,250 --> 00:57:29,360
sanitizer will catch him yeah and it

00:57:27,500 --> 00:57:33,350
would not help you if there is a

00:57:29,360 --> 00:57:37,190
language that puts zeroes inside I

00:57:33,350 --> 00:57:39,770
remember reading that in your blog but

00:57:37,190 --> 00:57:41,630
if you leave them initialize that you

00:57:39,770 --> 00:57:43,760
have better just catching them 25

00:57:41,630 --> 00:57:48,440
behavior sanitizers true and your other

00:57:43,760 --> 00:57:50,570
comment ones is about I'm sorry it's

00:57:48,440 --> 00:57:54,500
about to go - yeah no I'm sorry that

00:57:50,570 --> 00:57:58,520
they put this on the slide so yeah I

00:57:54,500 --> 00:58:03,700
agree with your conclusion that you

00:57:58,520 --> 00:58:06,500
should avoid it unless you shouldn't but

00:58:03,700 --> 00:58:09,500
you give an example where you might need

00:58:06,500 --> 00:58:11,900
it for performance I find that I

00:58:09,500 --> 00:58:16,190
sometimes needed for clarity of the code

00:58:11,900 --> 00:58:18,050
interesting so yes in 99% of the cases

00:58:16,190 --> 00:58:21,820
you usually have an abstraction that

00:58:18,050 --> 00:58:25,370
that's better but there's always this 1%

00:58:21,820 --> 00:58:27,320
just gives me the clear coat oh there's

00:58:25,370 --> 00:58:44,810
clearly reason why the program languages

00:58:27,320 --> 00:58:47,750
just keep it in Greek and get can get

00:58:44,810 --> 00:58:49,790
convoluted in such cases so sometimes

00:58:47,750 --> 00:58:51,320
indeed if you know the scoping rules the

00:58:49,790 --> 00:58:54,250
sorcerer's will be called everything

00:58:51,320 --> 00:58:54,250
it's said that but even

00:58:54,400 --> 00:58:59,839
thank you thanks my friend me do you

00:58:57,109 --> 00:59:01,520
want that's one because yeah thanks for

00:58:59,839 --> 00:59:04,790
talk since we're talking about some

00:59:01,520 --> 00:59:06,980
contradictory topics a little bit

00:59:04,790 --> 00:59:09,530
concerned about partially initialized

00:59:06,980 --> 00:59:11,750
objects when you read from stream and

00:59:09,530 --> 00:59:14,180
stream was broken in the middle so

00:59:11,750 --> 00:59:16,130
what's wrong with the partial

00:59:14,180 --> 00:59:19,970
initialized object when stream was

00:59:16,130 --> 00:59:21,440
broken in the middle okay so my I could

00:59:19,970 --> 00:59:23,420
could you an example if at the time so

00:59:21,440 --> 00:59:25,160
the thing is if you're getting an object

00:59:23,420 --> 00:59:26,329
and you're reeling from a string and

00:59:25,160 --> 00:59:28,010
you're not careful checking the blue

00:59:26,329 --> 00:59:30,500
stream is okay after doing your read and

00:59:28,010 --> 00:59:31,790
you have a half we initialize object in

00:59:30,500 --> 00:59:34,700
your code there's something lying around

00:59:31,790 --> 00:59:36,170
that's not correct it's not encapsulated

00:59:34,700 --> 00:59:38,089
in the sense that it's invariance might

00:59:36,170 --> 00:59:40,430
not be respected because you're over a

00:59:38,089 --> 00:59:41,359
part of it it's not complete so you have

00:59:40,430 --> 00:59:43,130
something that's hard to reason about

00:59:41,359 --> 00:59:45,470
because it's halfway done and if we're

00:59:43,130 --> 00:59:47,720
not done if you have things like that in

00:59:45,470 --> 00:59:49,640
your code you're doing things that might

00:59:47,720 --> 00:59:52,130
be illegal but if you cannot use the

00:59:49,640 --> 00:59:53,450
objects and objects so normally what we

00:59:52,130 --> 00:59:54,680
what we try to do when we have

00:59:53,450 --> 00:59:56,059
constructors is that when they fail

00:59:54,680 --> 00:59:57,770
we'll make sure that the object isn't a

00:59:56,059 --> 00:59:59,480
ghost or something like that if you're

00:59:57,770 --> 01:00:01,130
doing something like this you have an

00:59:59,480 --> 01:00:03,710
object that's wrong but still in the

01:00:01,130 --> 01:00:06,530
codes you have to be careful so you say

01:00:03,710 --> 01:00:09,140
that if the object is partially

01:00:06,530 --> 01:00:12,650
initialize it but it's still valid you

01:00:09,140 --> 01:00:14,540
know that if you have a default

01:00:12,650 --> 01:00:15,980
constructor where you read part of the

01:00:14,540 --> 01:00:17,270
object and you read the things that

01:00:15,980 --> 01:00:18,680
might have been messed up are not that

01:00:17,270 --> 01:00:22,040
bad that's okay but think about it if

01:00:18,680 --> 01:00:24,500
you had an X or Y engine readers e does

01:00:22,040 --> 01:00:26,869
your object makes sense it might be

01:00:24,500 --> 01:00:29,359
usable but it makes sense of course it's

01:00:26,869 --> 01:00:31,670
broken but the stream was broken so I'm

01:00:29,359 --> 01:00:34,460
already in a fault state yeah I'll just

01:00:31,670 --> 01:00:37,250
drop this partial initialized object and

01:00:34,460 --> 01:00:39,740
it will be simply destroyed if your

01:00:37,250 --> 01:00:41,839
color code is if object declaration

01:00:39,740 --> 01:00:47,200
semicolon read the object use the object

01:00:41,839 --> 01:00:52,520
you're safe okay thanks yes thank you

01:00:47,200 --> 01:00:52,520

YouTube URL: https://www.youtube.com/watch?v=KNqRjzSlUVo


