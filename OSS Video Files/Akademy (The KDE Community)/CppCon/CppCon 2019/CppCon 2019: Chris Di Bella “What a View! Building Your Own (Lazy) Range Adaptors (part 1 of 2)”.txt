Title: CppCon 2019: Chris Di Bella “What a View! Building Your Own (Lazy) Range Adaptors (part 1 of 2)”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
With their addition to C++20, ranges -- a revamped STL -- are going to send shockwaves through the way in which we design our software. The work from ranges gives us three broad things in C++20: redefined algorithms, concepts to assist in these algorithm definitions, and a handful of range adaptors, which are an abstraction over iterators for convenient program composition.

As Alex Stepanov and Sean Parent have said, the algorithms from the STL are only a sample of the algorithms that exist, and you're able to write your own. Range adaptors are no different: just because the adaptor you need isn't in C++20, doesn't mean that you can't write (or propose) it.

Using custom range adaptors can help you express your intentions in a much clearer manner. We'll spend some time implementing a range adaptor that isn't in the pipeline for C++20, starting from a motivating use-case, then move to how we implement the range adaptor -- including design considerations -- and finally, we'll write up a few tests to wrap everything up.
— 
Christopher Di Bella
Codeplay Software
Staff Software Engineer
Edinburgh, UK

Christopher Di Bella is a Staff Software Engineer for Codeplay’s ComputeCpp Runtime Technology. He is a strong proponent for generic programming in C++ and C++ education. Chris was previously a software developer for Nasdaq, and a tutor for UNSW Australia’s COMP6771 Advanced C++ Programming course in Sydney, Australia. When not geeking out over C++, he enjoys snowboarding, playing games, and watching films.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,320 --> 00:00:19,650
all right so let's actually let's start

00:00:14,950 --> 00:00:22,330
talking about rust at CP pecan okay so

00:00:19,650 --> 00:00:24,460
basically what we have here is hollow

00:00:22,330 --> 00:00:28,509
welding rust they have a nice function

00:00:24,460 --> 00:00:31,090
that allows you to print a line and one

00:00:28,509 --> 00:00:33,250
of the nice things about rust is that it

00:00:31,090 --> 00:00:35,860
supports utf-8 navy-blue I believe and

00:00:33,250 --> 00:00:38,079
that allows us to have different

00:00:35,860 --> 00:00:40,960
characters that aren't part of the ASCII

00:00:38,079 --> 00:00:43,420
character set but that may leave the

00:00:40,960 --> 00:00:49,330
things getting malformed so there are

00:00:43,420 --> 00:00:52,020
also Unicode escapes in in rust string

00:00:49,330 --> 00:00:55,300
literals and we do that by using

00:00:52,020 --> 00:00:58,450
backslash U and then in braces we are

00:00:55,300 --> 00:01:00,910
allowed to have between 1 and 6

00:00:58,450 --> 00:01:03,700
hexadecimal digits and we're going to

00:01:00,910 --> 00:01:10,689
implement a short parser for Unicode

00:01:03,700 --> 00:01:13,090
characters in in C++ using ranges so the

00:01:10,689 --> 00:01:15,580
first first way we might try it is using

00:01:13,090 --> 00:01:18,550
a raw loop and we're going to set out a

00:01:15,580 --> 00:01:20,710
few expectations these are all pseudo

00:01:18,550 --> 00:01:23,140
contracts allow us to say look if this

00:01:20,710 --> 00:01:24,970
isn't going to if we haven't the

00:01:23,140 --> 00:01:28,020
preconditions then we're either going to

00:01:24,970 --> 00:01:30,040
crash or just the optimize is going to

00:01:28,020 --> 00:01:32,620
take advantage of the fact that this

00:01:30,040 --> 00:01:35,290
algorithm doesn't acknowledge that you

00:01:32,620 --> 00:01:36,670
can pass things incorrectly and so we

00:01:35,290 --> 00:01:39,700
expect there are going to be a minimum

00:01:36,670 --> 00:01:42,159
of 5 characters because backslash you

00:01:39,700 --> 00:01:44,710
open close open curly and close curly

00:01:42,159 --> 00:01:45,790
are all characters that are going to be

00:01:44,710 --> 00:01:48,250
there and we need to have at least one

00:01:45,790 --> 00:01:50,170
digit so that's a minimum of 5

00:01:48,250 --> 00:01:53,140
characters and we're also going to

00:01:50,170 --> 00:01:56,140
expect that the the escape starts with

00:01:53,140 --> 00:01:58,720
backslash you open curly and ends with a

00:01:56,140 --> 00:02:00,390
closed curly and finally we want to

00:01:58,720 --> 00:02:04,409
assert that there's also going to be

00:02:00,390 --> 00:02:08,040
exactly 1 close curly because that's

00:02:04,409 --> 00:02:08,040
that's important as well

00:02:12,500 --> 00:02:18,720
and so now for the actual algorithm what

00:02:17,970 --> 00:02:21,240
we're going to do is we're going to

00:02:18,720 --> 00:02:22,410
start from the from the fourth character

00:02:21,240 --> 00:02:25,710
onwards because we don't have to care

00:02:22,410 --> 00:02:27,660
about backslash you open curly and we're

00:02:25,710 --> 00:02:30,330
going to continue until we reach the end

00:02:27,660 --> 00:02:31,320
of the end of the range and then what

00:02:30,330 --> 00:02:34,560
we're going to do is we're going to

00:02:31,320 --> 00:02:36,300
check to make sure that we have a

00:02:34,560 --> 00:02:37,920
hexadecimal digit but isn't the

00:02:36,300 --> 00:02:41,730
hexadecimal digit or we've reached

00:02:37,920 --> 00:02:44,250
something beyond the the size of what

00:02:41,730 --> 00:02:45,860
we're expecting we're going to simply

00:02:44,250 --> 00:02:51,470
return false otherwise we return true

00:02:45,860 --> 00:02:51,470
but what's wrong with this it is code

00:02:53,239 --> 00:02:59,850
don't like the constants that are six

00:02:55,140 --> 00:03:02,940
and for Ben the last character is gonna

00:02:59,850 --> 00:03:05,430
be a curly yes so those are two things

00:03:02,940 --> 00:03:07,320
that are problematic the third thing is

00:03:05,430 --> 00:03:11,910
that this was a talk that was promising

00:03:07,320 --> 00:03:13,920
ranges and this uses zero ranges so

00:03:11,910 --> 00:03:18,980
let's move on to something that is a

00:03:13,920 --> 00:03:21,540
little bit more algorithmic and we again

00:03:18,980 --> 00:03:22,920
we get again have our expectations and

00:03:21,540 --> 00:03:24,420
what we're going to do here is we're

00:03:22,920 --> 00:03:26,850
gonna replace that exactly one our curly

00:03:24,420 --> 00:03:30,540
with an algorithm slightly we don't have

00:03:26,850 --> 00:03:31,709
to continually reinvent the wheel and so

00:03:30,540 --> 00:03:33,720
we're expressing our intention we're

00:03:31,709 --> 00:03:36,540
counting the number of close Curly's and

00:03:33,720 --> 00:03:40,350
saying we expect one of them and then

00:03:36,540 --> 00:03:43,620
we're going to find a the first curly

00:03:40,350 --> 00:03:45,900
move on past that one because we don't

00:03:43,620 --> 00:03:49,260
actually only consider that and then we

00:03:45,900 --> 00:03:51,380
want to state that we're going to

00:03:49,260 --> 00:03:54,060
consider things up until the end of

00:03:51,380 --> 00:03:56,040
until we reach the the close code which

00:03:54,060 --> 00:03:57,239
is going to point out what say which is

00:03:56,040 --> 00:03:59,910
going to fix the problem that been

00:03:57,239 --> 00:04:01,290
identified and then we're going to do is

00:03:59,910 --> 00:04:03,810
we're going to check that the number of

00:04:01,290 --> 00:04:07,380
characters between there is between one

00:04:03,810 --> 00:04:11,400
and six and that all of them are

00:04:07,380 --> 00:04:15,120
hexadecimal digits but again this is

00:04:11,400 --> 00:04:16,919
still Debose so let's have a third

00:04:15,120 --> 00:04:18,180
attempt and this is going to start

00:04:16,919 --> 00:04:20,970
leveraging things from the ranges

00:04:18,180 --> 00:04:23,099
library first thing we do is unlikely

00:04:20,970 --> 00:04:24,720
this one here where we're using a size

00:04:23,099 --> 00:04:26,670
functional game to change to a

00:04:24,720 --> 00:04:30,630
distance which is a bit more expressive

00:04:26,670 --> 00:04:33,390
and then we're going to on line six use

00:04:30,630 --> 00:04:35,520
the count algorithm that is range based

00:04:33,390 --> 00:04:37,260
instead of iterator based otherwise it's

00:04:35,520 --> 00:04:40,950
still the same at the moment we're then

00:04:37,260 --> 00:04:43,710
going to kind of just simplify the code

00:04:40,950 --> 00:04:45,330
that was there and wrap it inside a sub

00:04:43,710 --> 00:04:47,070
range which is a way of wrapping

00:04:45,330 --> 00:04:52,140
iterators into something that resembles

00:04:47,070 --> 00:04:57,150
a range and then we'll use that to again

00:04:52,140 --> 00:04:59,490
complete the same operation and this is

00:04:57,150 --> 00:05:02,760
how you would implement the the second

00:04:59,490 --> 00:05:05,220
attempt using c++ xx ranges but we can

00:05:02,760 --> 00:05:08,970
go a little bit further again and we'll

00:05:05,220 --> 00:05:10,680
be able to use range adapters which

00:05:08,970 --> 00:05:13,650
allow us to express things even more

00:05:10,680 --> 00:05:15,240
clearly so you start with two Landers

00:05:13,650 --> 00:05:17,730
one that says not open brace and one

00:05:15,240 --> 00:05:19,520
this is not closed brace that's just

00:05:17,730 --> 00:05:22,230
expressing your intentions in words and

00:05:19,520 --> 00:05:25,140
then what we do is we provide a range of

00:05:22,230 --> 00:05:28,590
a range called Unicode that basically

00:05:25,140 --> 00:05:30,330
says that until we reach an open curly

00:05:28,590 --> 00:05:32,280
we don't want to consider any characters

00:05:30,330 --> 00:05:34,110
we just want to discount these and then

00:05:32,280 --> 00:05:37,010
we want to discount the cut the open

00:05:34,110 --> 00:05:39,660
curly and continue acknowledging

00:05:37,010 --> 00:05:43,020
elements in the range until we reach a

00:05:39,660 --> 00:05:45,390
close brace and then the algorithm is

00:05:43,020 --> 00:05:46,740
it's more or less the same as it was

00:05:45,390 --> 00:05:50,100
before we're just checking that there

00:05:46,740 --> 00:05:52,229
are it's at most six six characters and

00:05:50,100 --> 00:05:56,850
that they're all accidental hexadecimal

00:05:52,229 --> 00:06:00,840
digits and so this is an example use

00:05:56,850 --> 00:06:02,850
case of using ranges before I continue I

00:06:00,840 --> 00:06:04,800
just like to point out that this is a

00:06:02,850 --> 00:06:06,390
personal presentation and any views

00:06:04,800 --> 00:06:08,340
opinions or statements represented in

00:06:06,390 --> 00:06:10,380
his presentation a personal and they

00:06:08,340 --> 00:06:12,150
belong solely to me the presentation

00:06:10,380 --> 00:06:14,160
owner and do not represent those people

00:06:12,150 --> 00:06:16,290
institutions or organizations that the

00:06:14,160 --> 00:06:17,820
owner may not be associated it may be

00:06:16,290 --> 00:06:19,770
met or met may or may not be associated

00:06:17,820 --> 00:06:23,880
with in a professional or personal

00:06:19,770 --> 00:06:27,000
capacity unless explicitly cited yes

00:06:23,880 --> 00:06:29,430
that was a lot but there are relay the

00:06:27,000 --> 00:06:31,350
talks so generic programming by chillon

00:06:29,430 --> 00:06:34,830
parent back at specific plus plus last

00:06:31,350 --> 00:06:37,650
year was kind of what inspired me to

00:06:34,830 --> 00:06:38,430
give this talk in this format then there

00:06:37,650 --> 00:06:40,680
were there are a few

00:06:38,430 --> 00:06:44,060
Picon talks can I get a show of hands

00:06:40,680 --> 00:06:46,380
please he was seen a rangers talk before

00:06:44,060 --> 00:06:48,000
okay that's a fair amount of the room

00:06:46,380 --> 00:06:49,440
can I get a hand swap to see if you

00:06:48,000 --> 00:06:50,340
haven't seen a Rangers talk before can I

00:06:49,440 --> 00:06:52,860
get show hands please

00:06:50,340 --> 00:06:55,470
okay so this talk is not going to be

00:06:52,860 --> 00:06:56,790
talking about this isn't we're not going

00:06:55,470 --> 00:06:59,940
to be talking about how to use Rangers

00:06:56,790 --> 00:07:02,460
in this in this double session it's

00:06:59,940 --> 00:07:05,580
going to strictly be about understanding

00:07:02,460 --> 00:07:06,540
Rangers and implementing them so what

00:07:05,580 --> 00:07:09,150
we're going to cover is we're gonna

00:07:06,540 --> 00:07:12,020
understand the basis behind what Rangers

00:07:09,150 --> 00:07:15,890
are in this first hour and we're gonna

00:07:12,020 --> 00:07:20,340
motivate the the need for understanding

00:07:15,890 --> 00:07:24,300
what a range is and how we move with

00:07:20,340 --> 00:07:25,980
Rangers to actually implement one and in

00:07:24,300 --> 00:07:27,240
the second hour we're actually going to

00:07:25,980 --> 00:07:31,320
spend some time implementing a range

00:07:27,240 --> 00:07:32,910
adapter if you have any questions you're

00:07:31,320 --> 00:07:34,740
free to interrupt me at any point I do

00:07:32,910 --> 00:07:36,240
ask that use the microphone in the in

00:07:34,740 --> 00:07:37,830
the middle of the room so everything is

00:07:36,240 --> 00:07:42,120
caught on cameras that way everyone can

00:07:37,830 --> 00:07:45,240
hear you and finally we we're going to

00:07:42,120 --> 00:07:46,470
be using a few a few terms so I figured

00:07:45,240 --> 00:07:49,230
that it would be important to brief you

00:07:46,470 --> 00:07:51,870
on that first of all if you see Rangers

00:07:49,230 --> 00:07:54,390
it's going to refer to the namespaces

00:07:51,870 --> 00:07:57,570
stood rangers the namespace views refers

00:07:54,390 --> 00:08:01,860
to stim views and the namespace CP pecan

00:07:57,570 --> 00:08:03,840
is the content that is you'll find in

00:08:01,860 --> 00:08:05,790
namespace Rangers or namespace views but

00:08:03,840 --> 00:08:08,270
it's slightly different

00:08:05,790 --> 00:08:09,960
I've emitted something for example

00:08:08,270 --> 00:08:11,040
projection to something that everyone's

00:08:09,960 --> 00:08:14,250
been talking about when it comes to

00:08:11,040 --> 00:08:16,710
Rangers in this year to keep things a

00:08:14,250 --> 00:08:19,110
little bit more put them off focus I

00:08:16,710 --> 00:08:20,640
have emitted projections so they're

00:08:19,110 --> 00:08:22,140
putting the stuff in the Rangers

00:08:20,640 --> 00:08:23,850
namespace I'm putting in the CPP Khan

00:08:22,140 --> 00:08:24,990
namespace to help you work out where

00:08:23,850 --> 00:08:28,800
things are different from what's in the

00:08:24,990 --> 00:08:33,120
standard okay are there any questions so

00:08:28,800 --> 00:08:34,740
far I see none all right let's start

00:08:33,120 --> 00:08:36,540
with a simple definition and that is

00:08:34,740 --> 00:08:39,150
that a range is an ordered sequence of

00:08:36,540 --> 00:08:42,990
elements with a designated start and a

00:08:39,150 --> 00:08:46,770
rule for finishing an example of a range

00:08:42,990 --> 00:08:50,130
is a vector which with two elements

00:08:46,770 --> 00:08:51,360
hello.c pecan and a string view that's

00:08:50,130 --> 00:08:55,290
also a range

00:08:51,360 --> 00:08:58,260
the fur the vector the designated start

00:08:55,290 --> 00:09:00,060
is hello and the rule for finishing is

00:08:58,260 --> 00:09:03,839
when there are no more elements left the

00:09:00,060 --> 00:09:06,269
the author the designated start for the

00:09:03,839 --> 00:09:07,290
string view is H and B rule for

00:09:06,269 --> 00:09:11,610
finishing is when there are no more

00:09:07,290 --> 00:09:13,709
characters left all of the the natural

00:09:11,610 --> 00:09:19,019
numbers integers rational numbers and

00:09:13,709 --> 00:09:21,750
real numbers can form a can form a range

00:09:19,019 --> 00:09:24,660
as well so for example the the natural

00:09:21,750 --> 00:09:27,450
numbers have designated start of zero

00:09:24,660 --> 00:09:31,680
and there and the rule for finishing is

00:09:27,450 --> 00:09:33,750
it just doesn't end for integers we

00:09:31,680 --> 00:09:36,450
could say that a designate a start is

00:09:33,750 --> 00:09:40,170
negative two and the rule for finishing

00:09:36,450 --> 00:09:43,290
is that it is positive six and then you

00:09:40,170 --> 00:09:46,790
can you can make similar sorts of points

00:09:43,290 --> 00:09:49,110
for rationals and real numbers

00:09:46,790 --> 00:09:51,300
unfortunately complex numbers don't fall

00:09:49,110 --> 00:09:53,640
into this because we have they don't

00:09:51,300 --> 00:09:54,690
have an ordered sequence or two sequence

00:09:53,640 --> 00:09:56,329
means something comes before something

00:09:54,690 --> 00:09:59,160
else it doesn't necessarily mean that

00:09:56,329 --> 00:10:01,529
it's lexicographically less for example

00:09:59,160 --> 00:10:03,750
hello is going to compare

00:10:01,529 --> 00:10:06,690
lexicographically greater than CP pecan

00:10:03,750 --> 00:10:11,010
yet it comes before C pecan so if we

00:10:06,690 --> 00:10:13,440
impose a partial order on on the complex

00:10:11,010 --> 00:10:17,070
numbers where the real part is compared

00:10:13,440 --> 00:10:19,560
first and the the imaginary parts can

00:10:17,070 --> 00:10:22,800
use compared second then we can say that

00:10:19,560 --> 00:10:27,959
we have a form of range for complex

00:10:22,800 --> 00:10:30,810
numbers and finally we also have streams

00:10:27,959 --> 00:10:32,930
which form a sequence because you can

00:10:30,810 --> 00:10:35,670
get things from an input stream

00:10:32,930 --> 00:10:38,279
repeatedly until there's nothing left in

00:10:35,670 --> 00:10:39,720
the stream or you reach that format for

00:10:38,279 --> 00:10:42,180
example we're reading in integers in

00:10:39,720 --> 00:10:44,820
this example and if you pass in

00:10:42,180 --> 00:10:47,899
something that isn't an integer then the

00:10:44,820 --> 00:10:49,740
stream will suddenly be in a fast state

00:10:47,899 --> 00:10:51,660
are there any questions about the

00:10:49,740 --> 00:10:54,540
definition this is hand wavy definition

00:10:51,660 --> 00:10:56,690
of what arranges I see a question at the

00:10:54,540 --> 00:10:56,690
front

00:11:00,040 --> 00:11:04,790
yes so the point is that I didn't

00:11:03,230 --> 00:11:08,300
particularly define what I meant by

00:11:04,790 --> 00:11:10,730
ordered what I mean is that an element

00:11:08,300 --> 00:11:11,959
in the rain comes before another element

00:11:10,730 --> 00:11:14,420
and it will always come before that

00:11:11,959 --> 00:11:15,560
that's why the natural numbers the

00:11:14,420 --> 00:11:16,940
natural numbers are naturally ordered

00:11:15,560 --> 00:11:19,190
zero comes before one before - before

00:11:16,940 --> 00:11:20,980
three but the complex numbers aren't

00:11:19,190 --> 00:11:24,680
ordered unless we impose a partial order

00:11:20,980 --> 00:11:26,029
does that help answer the point we'll

00:11:24,680 --> 00:11:27,410
come back to this you know it's more

00:11:26,029 --> 00:11:30,519
rigorous detailing of it a little bit

00:11:27,410 --> 00:11:36,470
okay so there is an algorithm on screen

00:11:30,519 --> 00:11:38,060
and it is a linear search essentially

00:11:36,470 --> 00:11:40,100
we're just going to be iterating over

00:11:38,060 --> 00:11:41,899
everything until we find something and

00:11:40,100 --> 00:11:44,120
we return the position of that this is a

00:11:41,899 --> 00:11:46,670
linear search for a vector and this is

00:11:44,120 --> 00:11:51,230
the linear search for an array and this

00:11:46,670 --> 00:11:53,060
is a linear search for roar array this

00:11:51,230 --> 00:11:58,430
is a linear search for a pointer to an

00:11:53,060 --> 00:11:59,510
array does anyone see a common theme let

00:11:58,430 --> 00:12:00,829
me assure hands who thinks that these

00:11:59,510 --> 00:12:06,440
are basically the same with a different

00:12:00,829 --> 00:12:09,620
type okay so one possible solution to

00:12:06,440 --> 00:12:12,170
that is that we could use span and span

00:12:09,620 --> 00:12:15,770
allows us to say that it is a continuous

00:12:12,170 --> 00:12:17,720
sequence of elements then we can wrap

00:12:15,770 --> 00:12:20,300
them inside this pointer to the first

00:12:17,720 --> 00:12:23,779
element and add a size and so now we've

00:12:20,300 --> 00:12:27,470
just solved this problem but there is a

00:12:23,779 --> 00:12:37,040
problem with this solution what is that

00:12:27,470 --> 00:12:38,810
problem well sorry I know he works on

00:12:37,040 --> 00:12:43,550
finite sequences and it only works on

00:12:38,810 --> 00:12:45,050
continuous sequences so for Dec Dec for

00:12:43,550 --> 00:12:46,970
example is not a continuous sequence and

00:12:45,050 --> 00:12:48,020
that means that span is just going to

00:12:46,970 --> 00:12:51,560
fall over here so we need to have

00:12:48,020 --> 00:12:55,730
another overload for the deck and for

00:12:51,560 --> 00:12:57,500
linked lists W linked lists and so let's

00:12:55,730 --> 00:13:00,260
take a step back look at two algorithms

00:12:57,500 --> 00:13:01,670
just compare them see what they'll see

00:13:00,260 --> 00:13:06,290
what they're similar see what's

00:13:01,670 --> 00:13:11,100
different in the in both of these we

00:13:06,290 --> 00:13:12,780
have a start point and then we

00:13:11,100 --> 00:13:15,870
we have a rule for finishing so the

00:13:12,780 --> 00:13:18,780
ruffle finishing for the the spam based

00:13:15,870 --> 00:13:20,790
find is that we have a size that we're

00:13:18,780 --> 00:13:23,010
going to be reaching and in the case of

00:13:20,790 --> 00:13:25,680
the link list one we're going to be

00:13:23,010 --> 00:13:28,200
saying well when the head is now now we

00:13:25,680 --> 00:13:30,240
are going to stop then we have a way of

00:13:28,200 --> 00:13:32,850
moving forward to a successor element or

00:13:30,240 --> 00:13:34,920
the next element in the range and then

00:13:32,850 --> 00:13:37,740
what we do is we do a comparison and

00:13:34,920 --> 00:13:44,280
return a position based on what we've

00:13:37,740 --> 00:13:46,080
observed and this is what I find would

00:13:44,280 --> 00:13:48,240
look like it was streaming data we're

00:13:46,080 --> 00:13:51,090
going to read something in and we're

00:13:48,240 --> 00:13:52,290
going to we're going to continue reading

00:13:51,090 --> 00:13:57,750
until we either find something although

00:13:52,290 --> 00:13:59,310
the range is no longer readable so there

00:13:57,750 --> 00:14:00,570
is a solution to all this we can unify

00:13:59,310 --> 00:14:04,730
all this does anyone want to have a

00:14:00,570 --> 00:14:04,730
guess at what what it might be

00:14:06,260 --> 00:14:13,890
so I heard range in the front the answer

00:14:09,780 --> 00:14:15,990
is iterators and so without iterators we

00:14:13,890 --> 00:14:17,520
have roughly for every data structure

00:14:15,990 --> 00:14:18,660
and for every algorithm we have roughly

00:14:17,520 --> 00:14:20,340
the product of the number of data

00:14:18,660 --> 00:14:21,450
structures and the number of algorithms

00:14:20,340 --> 00:14:24,150
as the number of algorithm

00:14:21,450 --> 00:14:26,370
implementations now I say roughly

00:14:24,150 --> 00:14:29,220
because we were able to remove a handful

00:14:26,370 --> 00:14:31,340
of those by those four continuous ranges

00:14:29,220 --> 00:14:34,290
and just fold it into one span operation

00:14:31,340 --> 00:14:37,320
but we were still bound to deck and and

00:14:34,290 --> 00:14:40,590
link list and so on but with iterators

00:14:37,320 --> 00:14:42,660
we can replace that and say that if we

00:14:40,590 --> 00:14:44,040
have a number of data structures and a

00:14:42,660 --> 00:14:45,540
number of algorithms we only need to

00:14:44,040 --> 00:14:48,210
implement around about the number of

00:14:45,540 --> 00:14:50,970
algorithms that that exists we

00:14:48,210 --> 00:14:52,320
definitely need to employ at minimum the

00:14:50,970 --> 00:14:55,410
number of algorithms that exist but we

00:14:52,320 --> 00:14:57,540
if we can make certain assumptions then

00:14:55,410 --> 00:14:58,980
we can actually optimize and that means

00:14:57,540 --> 00:15:01,710
they'll be slightly more algorithm

00:14:58,980 --> 00:15:04,530
implementations then then actual

00:15:01,710 --> 00:15:06,510
algorithm names now I know what you're

00:15:04,530 --> 00:15:09,570
thinking you came here to learn about

00:15:06,510 --> 00:15:11,130
ranges and I'm talking about iterators I

00:15:09,570 --> 00:15:12,590
promise you there is a point to all of

00:15:11,130 --> 00:15:17,370
this

00:15:12,590 --> 00:15:21,540
so readable iterators are things that we

00:15:17,370 --> 00:15:25,110
can surprisingly read from and so with

00:15:21,540 --> 00:15:27,899
with span we use an index

00:15:25,110 --> 00:15:29,730
and with the link list we have a know

00:15:27,899 --> 00:15:32,070
that we whether it's presumably a

00:15:29,730 --> 00:15:34,019
pointer for an for an input iterator

00:15:32,070 --> 00:15:36,269
which is a an iterator that we can read

00:15:34,019 --> 00:15:38,940
from it's an unspecified type it's

00:15:36,269 --> 00:15:41,490
really just an implementation detail for

00:15:38,940 --> 00:15:44,820
the actual operation as I said before

00:15:41,490 --> 00:15:47,310
it's it's a subscript operation or a

00:15:44,820 --> 00:15:49,680
dereferencing these are all operations

00:15:47,310 --> 00:15:51,810
that are very similar and for the

00:15:49,680 --> 00:15:56,430
successor what you'll find is that we

00:15:51,810 --> 00:15:58,470
have loop we move by increasing the the

00:15:56,430 --> 00:16:00,420
index or moving the head and in the case

00:15:58,470 --> 00:16:03,269
of the iterator we're just going to call

00:16:00,420 --> 00:16:04,860
a successor function and comparison is

00:16:03,269 --> 00:16:07,410
slightly different but again it's

00:16:04,860 --> 00:16:09,300
unified we can unify it the way we do

00:16:07,410 --> 00:16:11,970
that for span is to compare the current

00:16:09,300 --> 00:16:14,880
index against the size or of the the

00:16:11,970 --> 00:16:16,500
data assay idea of the of the span for

00:16:14,880 --> 00:16:19,560
the linked list we're checking that the

00:16:16,500 --> 00:16:20,940
head is not null and in the input get

00:16:19,560 --> 00:16:22,200
her out of case what we're gonna do is

00:16:20,940 --> 00:16:23,850
we're gonna say that this thing called

00:16:22,200 --> 00:16:27,240
last that defines what the finishing

00:16:23,850 --> 00:16:30,000
rule is for the range and we're gonna

00:16:27,240 --> 00:16:31,500
compare the the first though the

00:16:30,000 --> 00:16:33,300
iterator first against the finishing

00:16:31,500 --> 00:16:35,910
rule last we'll come back to that in

00:16:33,300 --> 00:16:37,610
just a moment and so this is what usage

00:16:35,910 --> 00:16:40,470
of iterators looks like you call

00:16:37,610 --> 00:16:43,170
Ranger's begin on some data which is a

00:16:40,470 --> 00:16:45,720
vector of integers and you also hand

00:16:43,170 --> 00:16:48,089
over something you get back from ranges

00:16:45,720 --> 00:16:50,160
end and then you get back in iterator

00:16:48,089 --> 00:16:52,680
and you use that what you need to do is

00:16:50,160 --> 00:16:57,540
you need to what you need to do is you

00:16:52,680 --> 00:17:01,920
need to compare that against the against

00:16:57,540 --> 00:17:02,670
the the end of the of the range so make

00:17:01,920 --> 00:17:04,319
sure that we're not going to

00:17:02,670 --> 00:17:06,780
accidentally be using something that

00:17:04,319 --> 00:17:09,720
doesn't exist that's versa nonsensical

00:17:06,780 --> 00:17:11,040
and then we can use the iterators to

00:17:09,720 --> 00:17:13,199
work out things so we can look at how

00:17:11,040 --> 00:17:15,689
many elements are between the start

00:17:13,199 --> 00:17:16,890
point and where we are and how many

00:17:15,689 --> 00:17:25,640
elements are between where we are and

00:17:16,890 --> 00:17:27,839
the end of the range and this is what

00:17:25,640 --> 00:17:30,770
this is what it looks like the list so

00:17:27,839 --> 00:17:34,110
almost nothing changes just the type and

00:17:30,770 --> 00:17:36,030
so this is what fine looks like when we

00:17:34,110 --> 00:17:38,590
use iterators yeah what we do is we pass

00:17:36,030 --> 00:17:40,690
in an eye which is an iterator

00:17:38,590 --> 00:17:42,490
an input iterator and we have a value

00:17:40,690 --> 00:17:46,559
and what we're going to do is with the

00:17:42,490 --> 00:17:51,820
in direct relation we are going to be

00:17:46,559 --> 00:17:55,200
saying that we require that the what

00:17:51,820 --> 00:18:01,559
start at first gives us back is

00:17:55,200 --> 00:18:05,249
comparable to the to the value type

00:18:01,559 --> 00:18:07,990
there is a problem with our design and

00:18:05,249 --> 00:18:11,740
so here what we can do is we can compare

00:18:07,990 --> 00:18:13,450
a range that has a start point and a

00:18:11,740 --> 00:18:14,769
finishing rule where there are no more

00:18:13,450 --> 00:18:15,820
elements in the range what happens if we

00:18:14,769 --> 00:18:19,539
only want to search the first 10

00:18:15,820 --> 00:18:21,129
elements well we could do that by adding

00:18:19,539 --> 00:18:23,259
another overload where we provide and

00:18:21,129 --> 00:18:25,090
what's called the iterator difference

00:18:23,259 --> 00:18:27,909
which is you may know that is the

00:18:25,090 --> 00:18:29,769
difference type or it's it's simply the

00:18:27,909 --> 00:18:31,360
number of as light as the type that

00:18:29,769 --> 00:18:35,710
allows us to represent how many elements

00:18:31,360 --> 00:18:38,049
are between two iterators we can do that

00:18:35,710 --> 00:18:41,499
we can do that to find but there is a

00:18:38,049 --> 00:18:44,019
slight problem there's roughly a hundred

00:18:41,499 --> 00:18:45,460
and five algorithms in the standard

00:18:44,019 --> 00:18:48,009
library at the moment and there are many

00:18:45,460 --> 00:18:50,759
more that exist we would have to provide

00:18:48,009 --> 00:18:53,559
an enormous number of algorithm

00:18:50,759 --> 00:18:55,509
implementations and overloads for this

00:18:53,559 --> 00:18:58,059
particular thing it's not exactly a

00:18:55,509 --> 00:18:59,379
convenient solution so we can do is we

00:18:58,059 --> 00:19:03,190
can actually provide this thing called

00:18:59,379 --> 00:19:08,619
counted iterator which allows us to it

00:19:03,190 --> 00:19:10,299
allows us to provide an an N and then it

00:19:08,619 --> 00:19:11,710
will decrement until it reaches zero and

00:19:10,299 --> 00:19:13,389
that type of initial rule that we have

00:19:11,710 --> 00:19:16,570
no more elements left from what we're

00:19:13,389 --> 00:19:20,559
considering and this is how its usage

00:19:16,570 --> 00:19:22,059
looks the end is going to be a little

00:19:20,559 --> 00:19:23,980
bit ambiguous because there's no real

00:19:22,059 --> 00:19:28,749
way there's no real finishing rule at

00:19:23,980 --> 00:19:33,249
this point so what we could do is say

00:19:28,749 --> 00:19:37,450
that we have open we could we could use

00:19:33,249 --> 00:19:40,179
a Depot constructed iterator just as

00:19:37,450 --> 00:19:43,740
ice-cream iterator does in C++ 98

00:19:40,179 --> 00:19:46,059
through 217 but this is not particularly

00:19:43,740 --> 00:19:49,119
ideal because we now have to continually

00:19:46,059 --> 00:19:51,429
repeat the type and that's that's a bit

00:19:49,119 --> 00:19:52,270
annoying not to mention it's very

00:19:51,429 --> 00:19:53,500
verbose

00:19:52,270 --> 00:19:55,690
so instead what we could do is we could

00:19:53,500 --> 00:19:58,570
use a default sentinel and this is a

00:19:55,690 --> 00:20:00,070
finishing rule so sentinel is a is a

00:19:58,570 --> 00:20:02,980
much more formal way of me describing

00:20:00,070 --> 00:20:04,150
what the rule for finishing is because

00:20:02,980 --> 00:20:07,330
we're going to say that with people

00:20:04,150 --> 00:20:09,610
sentinel it is simply the default

00:20:07,330 --> 00:20:11,679
operation so for example if a stream

00:20:09,610 --> 00:20:15,040
goes bad or if our county diretor

00:20:11,679 --> 00:20:16,960
goes to zero but then it's a common way

00:20:15,040 --> 00:20:20,770
of saying yes we're going to reach the

00:20:16,960 --> 00:20:22,990
end of this and so the only change to

00:20:20,770 --> 00:20:26,050
our algorithm is that we add a new type

00:20:22,990 --> 00:20:29,860
called a sentinel and we change the type

00:20:26,050 --> 00:20:32,650
of blast to that sense or we say that s

00:20:29,860 --> 00:20:37,240
models a sentinel for the input iterator

00:20:32,650 --> 00:20:41,380
i and its usage is very much the same as

00:20:37,240 --> 00:20:48,520
before and this is what it looks like

00:20:41,380 --> 00:20:53,650
with the list and so now we can talk

00:20:48,520 --> 00:20:55,630
about ranges because this is this is

00:20:53,650 --> 00:20:59,170
most definitely leading up to the

00:20:55,630 --> 00:21:00,940
definition of a range and so here what

00:20:59,170 --> 00:21:03,790
we have is what we call an ice-cream

00:21:00,940 --> 00:21:07,500
view and it allows us to describe an

00:21:03,790 --> 00:21:10,690
ice-cream as though it were a range

00:21:07,500 --> 00:21:13,090
you'll notice that on lines four and

00:21:10,690 --> 00:21:15,370
five were using result twice we actually

00:21:13,090 --> 00:21:16,720
can't do this because the iterator we

00:21:15,370 --> 00:21:17,140
get back is what's called an input

00:21:16,720 --> 00:21:18,429
iterator

00:21:17,140 --> 00:21:21,460
and that it can only be used for single

00:21:18,429 --> 00:21:23,920
pass algorithms meaning that the the

00:21:21,460 --> 00:21:26,740
result is actually going to be is going

00:21:23,920 --> 00:21:29,830
to be trashed so no it's not crossing

00:21:26,740 --> 00:21:32,920
you out pretend that I've crossed out

00:21:29,830 --> 00:21:36,250
that that line five not sure why that

00:21:32,920 --> 00:21:41,100
happened and so you'll have noticed that

00:21:36,250 --> 00:21:43,720
in in all of these examples we've got

00:21:41,100 --> 00:21:44,920
we're using just the range we're not

00:21:43,720 --> 00:21:46,390
saying begin and end anymore which is

00:21:44,920 --> 00:21:51,280
similar to what we were talking about to

00:21:46,390 --> 00:21:53,620
begin with and so the implementation for

00:21:51,280 --> 00:21:55,900
a range based find is as follows we

00:21:53,620 --> 00:21:59,470
simply we have what's called an input

00:21:55,900 --> 00:22:02,110
range which which is similar to an input

00:21:59,470 --> 00:22:04,600
iterator and that we say that the in

00:22:02,110 --> 00:22:06,280
direct relation is applied to the

00:22:04,600 --> 00:22:07,270
iterator of our

00:22:06,280 --> 00:22:08,830
and we get back this thing called a

00:22:07,270 --> 00:22:10,000
safety iterator which essentially just

00:22:08,830 --> 00:22:11,860
made sure that we go we don't

00:22:10,000 --> 00:22:14,980
accidentally have a dangling iterator

00:22:11,860 --> 00:22:17,890
which is very dangerous now I want to

00:22:14,980 --> 00:22:21,880
focus on line number five which is

00:22:17,890 --> 00:22:23,860
defined as we're calling the iterator

00:22:21,880 --> 00:22:26,919
base find and this is important because

00:22:23,860 --> 00:22:30,490
the definition of a range is simply that

00:22:26,919 --> 00:22:35,710
we can call ranges begin on the range R

00:22:30,490 --> 00:22:38,470
and ranges end on the range R and what

00:22:35,710 --> 00:22:40,690
what is what this furthermore what we're

00:22:38,470 --> 00:22:44,429
saying is that the the return type of

00:22:40,690 --> 00:22:47,039
begin is going to be an iterator and the

00:22:44,429 --> 00:22:49,840
the return type of end is going to be a

00:22:47,039 --> 00:22:52,750
sentinel or the thing we got back from

00:22:49,840 --> 00:22:56,620
begin and so this is what the definition

00:22:52,750 --> 00:22:59,620
of a ranges we call an input range

00:22:56,620 --> 00:23:01,870
something that the models the concept of

00:22:59,620 --> 00:23:06,070
a range and it's iterator type also

00:23:01,870 --> 00:23:09,280
models and input iterator finally what

00:23:06,070 --> 00:23:12,700
you're familiar with is with vector and

00:23:09,280 --> 00:23:14,289
other types of containers is commonly is

00:23:12,700 --> 00:23:17,049
what's called a common range where the

00:23:14,289 --> 00:23:21,539
iterator and the sentinel are the same

00:23:17,049 --> 00:23:26,909
type there any questions at this point I

00:23:21,539 --> 00:23:28,990
can't see any okay so it should all be

00:23:26,909 --> 00:23:30,880
coming together now and so we're gonna

00:23:28,990 --> 00:23:35,440
spend we're going to spend a few minutes

00:23:30,880 --> 00:23:37,000
looking at at iterators with just to

00:23:35,440 --> 00:23:38,200
make sure that everyone understands the

00:23:37,000 --> 00:23:41,470
different kinds of iterators that we

00:23:38,200 --> 00:23:47,549
have and how we can move forward with

00:23:41,470 --> 00:23:49,929
building our range adapter so Zach Layne

00:23:47,549 --> 00:23:51,970
wanted to see an algorithm called fine

00:23:49,929 --> 00:23:54,820
last introduced into C++ 20 we

00:23:51,970 --> 00:23:56,950
unfortunately didn't get time to to

00:23:54,820 --> 00:24:01,179
reviewing it in in the library wording

00:23:56,950 --> 00:24:04,299
so it didn't make it in but here is an

00:24:01,179 --> 00:24:06,490
implementation of find last which is

00:24:04,299 --> 00:24:09,850
like find it's a linear search but

00:24:06,490 --> 00:24:12,510
instead of find which fine which gives

00:24:09,850 --> 00:24:17,919
us the iterator to the first element o

00:24:12,510 --> 00:24:19,640
it provides a an iterator to the last

00:24:17,919 --> 00:24:22,970
element that meets

00:24:19,640 --> 00:24:24,679
the value so what we have to do is we

00:24:22,970 --> 00:24:28,420
have to cache the iterator but you'll

00:24:24,679 --> 00:24:31,730
recall that I said that input generators

00:24:28,420 --> 00:24:34,700
only a single pass algorithms we here

00:24:31,730 --> 00:24:36,110
have to do a multiple passes in order

00:24:34,700 --> 00:24:37,580
for this algorithm to actually make

00:24:36,110 --> 00:24:41,540
sense because if we have gone through

00:24:37,580 --> 00:24:44,420
six elements and the fifth element is

00:24:41,540 --> 00:24:46,580
the is the one that we're actually going

00:24:44,420 --> 00:24:48,429
to be returning well that's that's

00:24:46,580 --> 00:24:50,510
potentially been discarded so we have to

00:24:48,429 --> 00:24:55,130
provide something it's a little bit more

00:24:50,510 --> 00:24:57,230
strict and so that's called and forward

00:24:55,130 --> 00:24:59,870
iterator and so if you took a photo of

00:24:57,230 --> 00:25:00,919
the the previous slide I recommend you

00:24:59,870 --> 00:25:02,000
delete that one take a photo of this

00:25:00,919 --> 00:25:03,890
slide because this one is actually a

00:25:02,000 --> 00:25:08,030
correct implementation the previous one

00:25:03,890 --> 00:25:10,100
was incorrect but otherwise it is still

00:25:08,030 --> 00:25:11,840
the same we all were doing is were

00:25:10,100 --> 00:25:14,000
saying you require something a little

00:25:11,840 --> 00:25:16,760
bit stronger something that allows you

00:25:14,000 --> 00:25:19,669
to have multiple passes in your

00:25:16,760 --> 00:25:25,760
algorithm so that way if you that way we

00:25:19,669 --> 00:25:29,510
don't accidentally lose the data this

00:25:25,760 --> 00:25:31,850
algorithm can be improved upon so as I

00:25:29,510 --> 00:25:33,290
was saying earlier we can we can provide

00:25:31,850 --> 00:25:34,340
optimizations and so what we're doing

00:25:33,290 --> 00:25:36,020
here is we're passing through the

00:25:34,340 --> 00:25:38,210
algorithm we're going forward and

00:25:36,020 --> 00:25:39,710
looking for something pacing it and then

00:25:38,210 --> 00:25:44,480
moving on until we reach the end of the

00:25:39,710 --> 00:25:47,960
range and were we're going to return the

00:25:44,480 --> 00:25:51,679
last the last element that matched the

00:25:47,960 --> 00:25:53,450
value but if we have a common range that

00:25:51,679 --> 00:25:55,549
happens to also be bi-directional that

00:25:53,450 --> 00:25:58,549
is we can move backwards not just yeah

00:25:55,549 --> 00:26:01,780
not not just forwards then we can

00:25:58,549 --> 00:26:04,370
actually just start at the end and

00:26:01,780 --> 00:26:06,890
continually move backward until we reach

00:26:04,370 --> 00:26:08,480
the end of the until we reach the

00:26:06,890 --> 00:26:11,299
beginning of the range and then that

00:26:08,480 --> 00:26:13,700
will automatically be the first the the

00:26:11,299 --> 00:26:19,179
the last element that matches the value

00:26:13,700 --> 00:26:19,179
are there any questions about that Ben

00:26:20,860 --> 00:26:27,440
so first is first is last and last is

00:26:24,260 --> 00:26:30,169
first in this case and because there yes

00:26:27,440 --> 00:26:32,659
I swapped them around it makes reading

00:26:30,169 --> 00:26:35,090
algorithm a little bit easier

00:26:32,659 --> 00:26:42,679
then then having to do it the other way

00:26:35,090 --> 00:26:44,749
around okay so moving on there is an

00:26:42,679 --> 00:26:48,799
algorithm called equal and this allows

00:26:44,749 --> 00:26:51,769
us to check that two ranges values are

00:26:48,799 --> 00:26:56,720
equivalent for every for some for some

00:26:51,769 --> 00:26:59,479
given predicate for every element in the

00:26:56,720 --> 00:27:01,129
range and we we can do this by

00:26:59,479 --> 00:27:03,200
implementing it in terms of another

00:27:01,129 --> 00:27:05,679
algorithm called mismatch which returns

00:27:03,200 --> 00:27:09,559
us an iterator to each range and that

00:27:05,679 --> 00:27:12,649
and that tells us where the algorithm is

00:27:09,559 --> 00:27:15,019
no longer meet in this case what we're

00:27:12,649 --> 00:27:15,979
saying is that we want to make sure that

00:27:15,019 --> 00:27:19,220
they're both at the end of their

00:27:15,979 --> 00:27:20,830
respective ranges but the we can

00:27:19,220 --> 00:27:23,090
optimize this a little bit further and

00:27:20,830 --> 00:27:26,869
so if we use what's known as a size

00:27:23,090 --> 00:27:30,379
Sentinel we can we can say that we can

00:27:26,869 --> 00:27:32,389
compute the the distance between the

00:27:30,379 --> 00:27:35,809
first element and the last element in

00:27:32,389 --> 00:27:38,119
constant time and that means that we can

00:27:35,809 --> 00:27:40,070
make this a constant time algorithm if

00:27:38,119 --> 00:27:44,149
the ranges are not actually the same

00:27:40,070 --> 00:27:46,070
science now I'm good if you're familiar

00:27:44,149 --> 00:27:47,840
with iterators you may be expecting me

00:27:46,070 --> 00:27:49,729
to talk about another particular

00:27:47,840 --> 00:27:51,590
category of iterators but I'm going to

00:27:49,729 --> 00:27:53,029
take a bit of a digression and talk

00:27:51,590 --> 00:27:55,220
about writeable iterator operations

00:27:53,029 --> 00:27:58,190
first because allows me to motivate are

00:27:55,220 --> 00:27:59,929
the algorithms that will actually be

00:27:58,190 --> 00:28:02,149
important for talking about the next

00:27:59,929 --> 00:28:03,979
kind of iterator and so it's very much

00:28:02,149 --> 00:28:05,509
the same except that as a readable

00:28:03,979 --> 00:28:07,129
iterator in terms of syntax except

00:28:05,509 --> 00:28:10,279
they're also able to provide writable as

00:28:07,129 --> 00:28:13,700
I write operations are there any

00:28:10,279 --> 00:28:18,440
questions at this point okay I see none

00:28:13,700 --> 00:28:20,720
and so this is an example of a writable

00:28:18,440 --> 00:28:22,159
algorithm so we have this thing called

00:28:20,720 --> 00:28:23,539
weak link roman table which means that

00:28:22,159 --> 00:28:25,580
we can basically just move to the next

00:28:23,539 --> 00:28:28,940
element and indirectly copyable means

00:28:25,580 --> 00:28:33,950
that we can copy something from from our

00:28:28,940 --> 00:28:35,690
input range into our output range and so

00:28:33,950 --> 00:28:37,629
moving on from this we have things as

00:28:35,690 --> 00:28:41,570
permutation and the permutation is

00:28:37,629 --> 00:28:44,210
something that can be rearranged and a

00:28:41,570 --> 00:28:45,470
classic example of a rearrangement is

00:28:44,210 --> 00:28:46,940
reversing

00:28:45,470 --> 00:28:49,340
say we one of them we want to walk

00:28:46,940 --> 00:28:52,490
backwards well what we can do here is we

00:28:49,340 --> 00:28:54,049
can reverse the the range by simply

00:28:52,490 --> 00:28:55,759
taking all the elements and putting them

00:28:54,049 --> 00:28:58,519
the first element in the last point and

00:28:55,759 --> 00:29:01,460
swapping them until we've got the range

00:28:58,519 --> 00:29:03,470
you know backwards fashion there's

00:29:01,460 --> 00:29:06,590
another one called remove and remove

00:29:03,470 --> 00:29:08,210
cops of a bit of black it's it's an

00:29:06,590 --> 00:29:09,679
algorithm that what it does is it takes

00:29:08,210 --> 00:29:15,590
all the elements that meet a particular

00:29:09,679 --> 00:29:16,789
predicate and then allows us to to do

00:29:15,590 --> 00:29:22,070
something throws by putting them at the

00:29:16,789 --> 00:29:23,690
back and and then we can we can remove

00:29:22,070 --> 00:29:26,090
them from the actual range by erasing

00:29:23,690 --> 00:29:28,789
them but if well this is a canonical

00:29:26,090 --> 00:29:32,240
usage of how we would use remove it's

00:29:28,789 --> 00:29:36,379
not the only way we can also copy them

00:29:32,240 --> 00:29:38,750
from a particular range to to another

00:29:36,379 --> 00:29:45,049
range so we can copy one range into this

00:29:38,750 --> 00:29:48,259
as well and so now we've got we were

00:29:45,049 --> 00:29:49,909
able to check that it's different all

00:29:48,259 --> 00:29:50,960
right so another kind of rearrangement

00:29:49,909 --> 00:29:54,289
this is one that I actually wanna talk

00:29:50,960 --> 00:29:56,029
about is naive shuffle well just

00:29:54,289 --> 00:29:58,159
shuffling in general so let's say we

00:29:56,029 --> 00:30:02,779
have a fresh deck of cards and we want

00:29:58,159 --> 00:30:06,259
to we want to shuffle them we can we can

00:30:02,779 --> 00:30:09,049
provide a way of doing this by simply

00:30:06,259 --> 00:30:13,039
taking the current position and swapping

00:30:09,049 --> 00:30:15,559
it with someone else and so this is this

00:30:13,039 --> 00:30:18,399
is what the algorithm looks like there

00:30:15,559 --> 00:30:18,399
any questions about it

00:30:24,340 --> 00:30:31,960
okay so I benchmarked it and I used five

00:30:27,880 --> 00:30:34,539
million cards in my deck and for a

00:30:31,960 --> 00:30:38,010
vector it's roughly 30 milliseconds for

00:30:34,539 --> 00:30:42,029
a deck it's roughly 38 milliseconds

00:30:38,010 --> 00:30:45,730
released it's about 11 and a half hours

00:30:42,029 --> 00:30:48,250
and if I copy it from a kippah copy of

00:30:45,730 --> 00:30:50,529
my list to a vector and shuffled it and

00:30:48,250 --> 00:30:53,860
copied it back it's about 70

00:30:50,529 --> 00:30:55,390
milliseconds so this shuffle algorithm

00:30:53,860 --> 00:30:59,350
although it works for bi-directional

00:30:55,390 --> 00:31:03,159
rangers isn't exactly the best isn't the

00:30:59,350 --> 00:31:04,210
best implementation and so we can if we

00:31:03,159 --> 00:31:06,730
have this thing called random access

00:31:04,210 --> 00:31:08,649
iterator it allows us to make arbitrary

00:31:06,730 --> 00:31:11,320
steps in constant time instead of just

00:31:08,649 --> 00:31:14,470
single steps in constant time then we're

00:31:11,320 --> 00:31:16,840
able to move move forward a lot more

00:31:14,470 --> 00:31:17,710
easily so what we have here is were

00:31:16,840 --> 00:31:22,000
saying that we need to be able to

00:31:17,710 --> 00:31:25,840
commute the elements and we require a

00:31:22,000 --> 00:31:27,700
random access iterator and so what we're

00:31:25,840 --> 00:31:29,950
going to do is we're going to have a bit

00:31:27,700 --> 00:31:33,640
of setup and then what we're going to do

00:31:29,950 --> 00:31:35,529
is we're going to iterate from from what

00:31:33,640 --> 00:31:38,950
we're going to call them the mid until

00:31:35,529 --> 00:31:42,360
we reach the end and then what we're

00:31:38,950 --> 00:31:48,029
going to do is we're going to perform a

00:31:42,360 --> 00:31:52,500
swap with the with the elements and

00:31:48,029 --> 00:31:52,500
we're going to do this in constant time

00:31:54,450 --> 00:32:00,669
are there any questions about that now

00:31:59,110 --> 00:32:01,929
we can take arbitrary steps forward we

00:32:00,669 --> 00:32:03,640
can take arbitrary steps backward in

00:32:01,929 --> 00:32:07,179
constant time we can do comparisons and

00:32:03,640 --> 00:32:10,559
this will all become more apparent once

00:32:07,179 --> 00:32:13,149
we reach the second half of this talk

00:32:10,559 --> 00:32:15,250
continuous ranges are the final piece of

00:32:13,149 --> 00:32:18,640
the puzzle and I don't have any

00:32:15,250 --> 00:32:22,299
algorithms that I can succinctly use as

00:32:18,640 --> 00:32:25,090
motivation or continuous ranges I it's

00:32:22,299 --> 00:32:27,039
possible that they're reusable in

00:32:25,090 --> 00:32:28,600
heterogeneous contexts so I recommend

00:32:27,039 --> 00:32:31,210
taking a look at Gordon Brown's talks

00:32:28,600 --> 00:32:35,250
about sickle to decieve more about

00:32:31,210 --> 00:32:37,890
heterogeneous contexts now let's talk

00:32:35,250 --> 00:32:38,940
having some integers in a range this is

00:32:37,890 --> 00:32:42,270
one way we could do it we could have

00:32:38,940 --> 00:32:45,919
eight eight elements in a vector we

00:32:42,270 --> 00:32:48,620
could use a loop to to fill them with

00:32:45,919 --> 00:32:52,770
zero one two three four five six seven

00:32:48,620 --> 00:32:55,919
does anyone know an algorithm that could

00:32:52,770 --> 00:32:56,419
replace this I see an answer in the

00:32:55,919 --> 00:33:00,650
front

00:32:56,419 --> 00:33:03,000
iota yes so we could do this and

00:33:00,650 --> 00:33:07,169
unfortunately the numeric algorithms

00:33:03,000 --> 00:33:10,260
were not rain defied in C++ 24 many good

00:33:07,169 --> 00:33:13,740
reasons and so we're still using the C++

00:33:10,260 --> 00:33:17,610
11 IATA and that will give us exactly

00:33:13,740 --> 00:33:20,400
the same result as before this is not

00:33:17,610 --> 00:33:22,320
ideal Bo because I could do a pop back

00:33:20,400 --> 00:33:23,909
and that suddenly means that the range

00:33:22,320 --> 00:33:27,360
which I was expecting to be a size eight

00:33:23,909 --> 00:33:28,650
isn't our size seven and so there's been

00:33:27,360 --> 00:33:29,730
an intermediate change there it'd be

00:33:28,650 --> 00:33:32,700
nice if I could actually do this all in

00:33:29,730 --> 00:33:35,820
one step and so the way in which we

00:33:32,700 --> 00:33:38,940
could do this is to use and I out of you

00:33:35,820 --> 00:33:41,940
and I out of you behaves similarly to

00:33:38,940 --> 00:33:44,070
the to the algorithm iota but it behaves

00:33:41,940 --> 00:33:46,289
lays lease means we have to actually

00:33:44,070 --> 00:33:48,360
invoke it for example we would need to

00:33:46,289 --> 00:33:51,900
call equal on this and then compare it

00:33:48,360 --> 00:33:54,450
against and array that would then lazily

00:33:51,900 --> 00:33:57,120
generate all of the elements are between

00:33:54,450 --> 00:33:58,559
zero and and eight and it's important to

00:33:57,120 --> 00:34:01,260
understand that although there's zero

00:33:58,559 --> 00:34:02,880
and eight here eight is not going to be

00:34:01,260 --> 00:34:06,419
a part of this as a half-open range

00:34:02,880 --> 00:34:07,770
meaning that eight is the end once we

00:34:06,419 --> 00:34:11,849
reach eight we terminate you don't get

00:34:07,770 --> 00:34:16,109
paid back is anyone familiar with the

00:34:11,849 --> 00:34:16,980
Collatz conjecture okay is anyone in the

00:34:16,109 --> 00:34:19,740
room not familiar with a Collatz

00:34:16,980 --> 00:34:22,470
conjecture okay so the Collatz

00:34:19,740 --> 00:34:25,889
conjecture is essentially a an algorithm

00:34:22,470 --> 00:34:27,510
that i believe is still unsolved in

00:34:25,889 --> 00:34:29,159
mathematics we're not sure if it

00:34:27,510 --> 00:34:31,260
terminates or not but basically the rule

00:34:29,159 --> 00:34:35,280
is that you start with in integer

00:34:31,260 --> 00:34:38,070
greater than zero and you what you do is

00:34:35,280 --> 00:34:41,070
you continually apply this rule where if

00:34:38,070 --> 00:34:43,349
the algorithm is even then you have it

00:34:41,070 --> 00:34:45,030
otherwise you triple it and add one and

00:34:43,349 --> 00:34:48,510
you continue to do that until you wait

00:34:45,030 --> 00:34:48,839
to zero and as I mention before we're

00:34:48,510 --> 00:34:52,409
not sure

00:34:48,839 --> 00:34:55,289
it actually terminates and so what we

00:34:52,409 --> 00:34:57,569
can do is we can generate the individual

00:34:55,289 --> 00:35:01,979
elements of the of the Collatz

00:34:57,569 --> 00:35:04,529
conjecture using iota and we and then

00:35:01,979 --> 00:35:06,839
composing it with transform so what we

00:35:04,529 --> 00:35:09,479
do here is we pass and something that

00:35:06,839 --> 00:35:11,819
modifies the range and then we transform

00:35:09,479 --> 00:35:17,009
that into the into the Collatz

00:35:11,819 --> 00:35:18,690
conjecture and this kind of version of

00:35:17,009 --> 00:35:20,489
iota is not bounded which means that

00:35:18,690 --> 00:35:22,380
there isn't an end to it it just goes on

00:35:20,489 --> 00:35:26,420
forever and when I say forever I

00:35:22,380 --> 00:35:28,920
literally mean until we exhaust the

00:35:26,420 --> 00:35:32,910
until we exhaust the difference time and

00:35:28,920 --> 00:35:36,509
then we reach undefined behavior so a

00:35:32,910 --> 00:35:43,049
good way for us to actually to move on

00:35:36,509 --> 00:35:46,170
from this is to is to use what's known

00:35:43,049 --> 00:35:51,479
as take view and take view allows us to

00:35:46,170 --> 00:35:53,460
specify a way of of moving forward so

00:35:51,479 --> 00:35:56,190
what we can do here is we can say that

00:35:53,460 --> 00:35:59,759
there are going to be exactly those are

00:35:56,190 --> 00:36:01,039
at most 10 elements in this range there

00:35:59,759 --> 00:36:05,999
any questions about that

00:36:01,039 --> 00:36:07,380
let's see question no so the question

00:36:05,999 --> 00:36:09,329
was is this all eagerly generated the

00:36:07,380 --> 00:36:10,920
answer is no this is not all eagerly

00:36:09,329 --> 00:36:12,900
generated this is all lazily generated

00:36:10,920 --> 00:36:17,130
and what we would need to do is we would

00:36:12,900 --> 00:36:20,759
need to provide something such as range

00:36:17,130 --> 00:36:22,769
as equal and then provide something else

00:36:20,759 --> 00:36:26,519
there to generate every element on the

00:36:22,769 --> 00:36:31,950
fly are there any does the design into

00:36:26,519 --> 00:36:32,460
the question okay are there any other

00:36:31,950 --> 00:36:38,759
questions

00:36:32,460 --> 00:36:43,739
I don't see any all right so let's let's

00:36:38,759 --> 00:36:47,279
move forward and let's talk about about

00:36:43,739 --> 00:36:49,549
views in a little bit more detail so the

00:36:47,279 --> 00:36:56,210
two that you may be familiar with our

00:36:49,549 --> 00:36:56,210
string view and Spain and those two

00:36:57,019 --> 00:37:02,339
those two are the canonical things that

00:37:00,989 --> 00:37:04,709
we think of at first but

00:37:02,339 --> 00:37:08,219
C++ 20 actually introduces a lot more

00:37:04,709 --> 00:37:10,589
spinto views than than that and they're

00:37:08,219 --> 00:37:13,439
all inside the rangers namespace and so

00:37:10,589 --> 00:37:16,259
empty view and provides us with an empty

00:37:13,439 --> 00:37:19,319
and empty range it's useful when we want

00:37:16,259 --> 00:37:21,380
to say this range is empty but we don't

00:37:19,319 --> 00:37:25,829
have any other way of doing that and

00:37:21,380 --> 00:37:27,359
that the filter view allows us to take

00:37:25,829 --> 00:37:31,069
out elements that don't satisfy a given

00:37:27,359 --> 00:37:32,849
predicate drop while view allows us to

00:37:31,069 --> 00:37:34,949
discount elements until a particular

00:37:32,849 --> 00:37:41,640
condition is satisfied we saw that one

00:37:34,949 --> 00:37:44,729
at the very start there are a large

00:37:41,640 --> 00:37:47,369
number of views in there that are out

00:37:44,729 --> 00:37:50,579
there just as Shawn parent has quoted

00:37:47,369 --> 00:37:52,920
Alex saying that there are there are

00:37:50,579 --> 00:37:55,109
multiple so there there's a very large

00:37:52,920 --> 00:37:58,589
number of algorithms and the STL is only

00:37:55,109 --> 00:38:01,380
a small survey of them there are many

00:37:58,589 --> 00:38:03,239
ranges that are out there and we only

00:38:01,380 --> 00:38:04,979
have a small survey of them both in the

00:38:03,239 --> 00:38:06,539
standard library and in the canonical

00:38:04,979 --> 00:38:09,089
library implementations the canonical

00:38:06,539 --> 00:38:11,219
library implementations are Rangeley 3

00:38:09,089 --> 00:38:14,039
which is the oldest modern version of

00:38:11,219 --> 00:38:17,130
ranges CMC STL 2 which is an

00:38:14,039 --> 00:38:20,400
experimental version of ranges using

00:38:17,130 --> 00:38:24,059
concepts and GCC and now Emma specie

00:38:20,400 --> 00:38:26,189
actually and nano range which is an

00:38:24,059 --> 00:38:29,549
independently produced one that is very

00:38:26,189 --> 00:38:32,789
faithful to what's in the standard now

00:38:29,549 --> 00:38:35,219
the definition of a view is that it's

00:38:32,789 --> 00:38:39,839
arranged that also models the concepts

00:38:35,219 --> 00:38:42,900
of semi-regular and we also have this

00:38:39,839 --> 00:38:47,219
this boolean called an able view and

00:38:42,900 --> 00:38:49,529
enable view really just says that we we

00:38:47,219 --> 00:38:55,319
have something that is pretty much the

00:38:49,529 --> 00:39:00,869
view now moving forward from that I on

00:38:55,319 --> 00:39:04,079
Twitter oh I see a question so the

00:39:00,869 --> 00:39:05,640
question is which which views are in the

00:39:04,079 --> 00:39:08,789
the views namespace and which ones are

00:39:05,640 --> 00:39:10,859
in the rangers namespace so although all

00:39:08,789 --> 00:39:12,599
the things that are burying the ones

00:39:10,859 --> 00:39:14,609
that say stood on screen would just

00:39:12,599 --> 00:39:16,040
string which is string view and its

00:39:14,609 --> 00:39:18,050
friends

00:39:16,040 --> 00:39:20,150
basic string view everything it is

00:39:18,050 --> 00:39:23,740
suffix with underscore view is in the

00:39:20,150 --> 00:39:27,080
Rangers namespace and then it has a a

00:39:23,740 --> 00:39:29,690
related object that lives in the views

00:39:27,080 --> 00:39:31,070
namespace so these are all types that

00:39:29,690 --> 00:39:33,470
live in the name in the rangers

00:39:31,070 --> 00:39:34,700
namespace but then we have objects which

00:39:33,470 --> 00:39:39,200
I'll be getting to you in the second

00:39:34,700 --> 00:39:40,400
half in quite some detail so that does

00:39:39,200 --> 00:39:43,940
that answer the question at least for

00:39:40,400 --> 00:39:47,030
now it'll become much clearer once we

00:39:43,940 --> 00:39:48,109
reach the end of the second half are

00:39:47,030 --> 00:39:59,119
there any other questions

00:39:48,109 --> 00:40:01,430
I see question right so the question is

00:39:59,119 --> 00:40:05,060
what is the significance of enable view

00:40:01,430 --> 00:40:06,500
and what does it mean so I've only given

00:40:05,060 --> 00:40:08,780
a partial definition of what a view is

00:40:06,500 --> 00:40:11,690
the full definition is these are these

00:40:08,780 --> 00:40:13,310
syntactic requirements of a view there

00:40:11,690 --> 00:40:15,290
are semantic requirements as well and

00:40:13,310 --> 00:40:17,960
the semantic requirements of a view are

00:40:15,290 --> 00:40:20,380
that there it has a constant time copy

00:40:17,960 --> 00:40:23,720
operation a constant time move operation

00:40:20,380 --> 00:40:25,310
constant time assignment and constant

00:40:23,720 --> 00:40:27,650
time destruction that's the definition

00:40:25,310 --> 00:40:28,040
of a view the full definition of the

00:40:27,650 --> 00:40:32,119
view

00:40:28,040 --> 00:40:35,089
enable view allows us to either opt in

00:40:32,119 --> 00:40:36,589
or opt out depending on what you what

00:40:35,089 --> 00:40:39,220
what you need to do

00:40:36,589 --> 00:40:42,920
in the event that you don't actually

00:40:39,220 --> 00:40:43,910
meet those semantic requirements because

00:40:42,920 --> 00:40:45,260
you can meet all the syntactical

00:40:43,910 --> 00:40:47,300
requirements we've never met the

00:40:45,260 --> 00:40:50,210
semantic requirements you shouldn't be

00:40:47,300 --> 00:40:51,230
modeling the concept view and was like

00:40:50,210 --> 00:40:52,670
you're not modeling the concert view and

00:40:51,230 --> 00:40:55,580
you should be opting out of that from a

00:40:52,670 --> 00:40:56,450
syntax signal syntax point of view and

00:40:55,580 --> 00:40:59,420
does that answer the question

00:40:56,450 --> 00:41:01,040
cool are there any is there any

00:40:59,420 --> 00:41:10,240
confusion about what I just said because

00:41:01,040 --> 00:41:10,240
I get that maybe a new notion I see none

00:41:11,230 --> 00:41:26,710
look there is one sorry sorry you were

00:41:14,079 --> 00:41:30,190
right in the in the light there yeah so

00:41:26,710 --> 00:41:32,500
the question was that I just noted that

00:41:30,190 --> 00:41:36,430
use need to be constant time copyable

00:41:32,500 --> 00:41:38,380
and the question was he's at pause does

00:41:36,430 --> 00:41:48,880
that mean that views views can't cash

00:41:38,380 --> 00:41:51,250
what sorry right so it just if they

00:41:48,880 --> 00:41:55,300
can't cash and well many of yous don't

00:41:51,250 --> 00:41:57,369
need to cash some views we do actually

00:41:55,300 --> 00:42:00,849
do actually need the cash and they have

00:41:57,369 --> 00:42:02,589
certain rules on them that mean that we

00:42:00,849 --> 00:42:04,390
need to obey certain certain principles

00:42:02,589 --> 00:42:06,880
and so I'll be covering that in just a

00:42:04,390 --> 00:42:10,720
moment but some views do absolutely need

00:42:06,880 --> 00:42:12,579
to do some caching and you what we don't

00:42:10,720 --> 00:42:15,790
actually cover the caching in this

00:42:12,579 --> 00:42:17,380
particular session we there is an

00:42:15,790 --> 00:42:20,260
optimization opportunity that you can

00:42:17,380 --> 00:42:21,760
definitely leverage from this it's just

00:42:20,260 --> 00:42:23,470
it would be too much to put on the

00:42:21,760 --> 00:42:26,500
slides does that answer the question

00:42:23,470 --> 00:42:29,680
cool are there any other questions

00:42:26,500 --> 00:42:35,829
didn't want to miss anyone I don't see

00:42:29,680 --> 00:42:38,349
any okay so a few weeks ago I decided to

00:42:35,829 --> 00:42:45,220
query what people were interested in

00:42:38,349 --> 00:42:46,510
seeing because that's that's important

00:42:45,220 --> 00:42:49,569
to understand I promised that I would

00:42:46,510 --> 00:42:52,210
build a non-standard range because the

00:42:49,569 --> 00:42:54,280
ranges that we have in the standard have

00:42:52,210 --> 00:42:55,750
a formal specification they're going to

00:42:54,280 --> 00:42:59,099
be in your standard libraries hopefully

00:42:55,750 --> 00:43:01,990
very soon and there are canonical

00:42:59,099 --> 00:43:03,579
implementations of all of these possibly

00:43:01,990 --> 00:43:05,710
borrowing one and I figured that it'll

00:43:03,579 --> 00:43:08,470
be interesting to see something that may

00:43:05,710 --> 00:43:09,640
not actually be as straightforward so

00:43:08,470 --> 00:43:13,329
the first one that I considered was

00:43:09,640 --> 00:43:15,880
slice view and this is what an example

00:43:13,329 --> 00:43:18,640
of a slice view is on screen what we

00:43:15,880 --> 00:43:21,520
have is a slice between the elements 3 &

00:43:18,640 --> 00:43:23,530
6 and so we only consider the elements

00:43:21,520 --> 00:43:25,110
in this particular bit of the range and

00:43:23,530 --> 00:43:27,420
this is a slide

00:43:25,110 --> 00:43:31,980
between the elements of from position

00:43:27,420 --> 00:43:34,320
four and eight and so this was one of

00:43:31,980 --> 00:43:38,420
the more popular range range adapters

00:43:34,320 --> 00:43:41,250
that we could particularly implement and

00:43:38,420 --> 00:43:42,840
I just realized that I haven't actually

00:43:41,250 --> 00:43:45,810
explained what a range of DAP there is a

00:43:42,840 --> 00:43:48,600
range adapter is something that is it is

00:43:45,810 --> 00:43:50,580
something that takes a range of

00:43:48,600 --> 00:43:52,920
something and that can be converted into

00:43:50,580 --> 00:43:57,000
a view and then gives us back a view

00:43:52,920 --> 00:43:58,380
that has some transform some

00:43:57,000 --> 00:44:03,270
transformative properties for example

00:43:58,380 --> 00:44:05,580
slice view will discount all the

00:44:03,270 --> 00:44:07,050
elements that come before the first

00:44:05,580 --> 00:44:09,540
position that we've specified which is

00:44:07,050 --> 00:44:11,610
four and only consider things up until

00:44:09,540 --> 00:44:14,510
the eighth position which means that we

00:44:11,610 --> 00:44:16,770
stop once we reach the eighth position

00:44:14,510 --> 00:44:25,860
are there any questions about that I see

00:44:16,770 --> 00:44:27,660
a question in the debate so the the

00:44:25,860 --> 00:44:32,520
point that to be made was why don't we

00:44:27,660 --> 00:44:35,790
just use take and drop and that's how we

00:44:32,520 --> 00:44:38,670
implement it so here what we have is a

00:44:35,790 --> 00:44:41,220
lambda and in this lambda what they do

00:44:38,670 --> 00:44:43,460
is we can take two integrals and we're

00:44:41,220 --> 00:44:47,010
going to make a point of saying that

00:44:43,460 --> 00:44:48,780
both D and T so D is the number of

00:44:47,010 --> 00:44:49,800
element that we want to discount and T

00:44:48,780 --> 00:44:52,050
is the number of elements we want to

00:44:49,800 --> 00:44:54,150
consider and what we're going to say is

00:44:52,050 --> 00:44:57,810
that both of them need to be positive

00:44:54,150 --> 00:44:58,920
and D needs to be smaller than T and now

00:44:57,810 --> 00:45:03,780
I'm going to do is we're going to drop

00:44:58,920 --> 00:45:05,130
the number of elements the first number

00:45:03,780 --> 00:45:06,750
of elements we're going to discount them

00:45:05,130 --> 00:45:08,550
they're not a part of it and then we're

00:45:06,750 --> 00:45:10,890
going to take the difference the reason

00:45:08,550 --> 00:45:12,570
for that is because we want to say where

00:45:10,890 --> 00:45:14,370
the range stops not just consider this

00:45:12,570 --> 00:45:20,070
number of elements requests to the front

00:45:14,370 --> 00:45:23,460
I mean this one what is the question is

00:45:20,070 --> 00:45:27,240
what is the return type and the return

00:45:23,460 --> 00:45:32,030
type of this will be a bit complicated

00:45:27,240 --> 00:45:35,030
for me to explain in words the so the

00:45:32,030 --> 00:45:35,030
question

00:45:37,280 --> 00:45:43,080
right so what it is is is a what's

00:45:41,400 --> 00:45:47,520
called a closure arranged up to closure

00:45:43,080 --> 00:45:48,990
and we will get to that in the at the

00:45:47,520 --> 00:45:51,240
end of the next session it's the very

00:45:48,990 --> 00:45:54,119
last thing we talk about in the entire

00:45:51,240 --> 00:45:56,490
session but essentially what that is is

00:45:54,119 --> 00:45:59,369
a way of storing all the all the Lazy

00:45:56,490 --> 00:46:02,670
information before we actually have a

00:45:59,369 --> 00:46:04,560
range that we can adapt so what we're

00:46:02,670 --> 00:46:06,330
saying here is we have a range of data

00:46:04,560 --> 00:46:09,030
and we want to compose it with another

00:46:06,330 --> 00:46:12,530
range adapter and we're going to return

00:46:09,030 --> 00:46:15,240
some unspecified type so that way we can

00:46:12,530 --> 00:46:16,920
we can work with it as we move forward

00:46:15,240 --> 00:46:20,100
and then we would when we pipe that

00:46:16,920 --> 00:46:24,180
moving part of Ector into this it would

00:46:20,100 --> 00:46:29,820
then form some some larger type that

00:46:24,180 --> 00:46:34,230
actually can then be actioned and so I

00:46:29,820 --> 00:46:37,440
see a question so the return type is an

00:46:34,230 --> 00:46:41,570
unspecified type a view is something

00:46:37,440 --> 00:46:44,910
such as such as filter view or take view

00:46:41,570 --> 00:46:46,140
whereas a though in this particular case

00:46:44,910 --> 00:46:47,910
it's something that

00:46:46,140 --> 00:46:51,930
implementation-specific

00:46:47,910 --> 00:46:56,100
and it's related to what we get back yes

00:46:51,930 --> 00:46:58,830
it is a platonically of view but type

00:46:56,100 --> 00:47:00,900
wise it is something that is view

00:46:58,830 --> 00:47:05,130
related but not actually a view does

00:47:00,900 --> 00:47:07,200
that make sense yeah on its own no it

00:47:05,130 --> 00:47:10,430
does not Model View it needs to have a

00:47:07,200 --> 00:47:14,190
bit more information to get that far

00:47:10,430 --> 00:47:18,780
are there any other questions I see a

00:47:14,190 --> 00:47:21,800
question at the front is the slide title

00:47:18,780 --> 00:47:24,030
misleading it's really just for

00:47:21,800 --> 00:47:26,760
consistency with the previous slice view

00:47:24,030 --> 00:47:28,290
science slides I would agree that it is

00:47:26,760 --> 00:47:31,260
slightly misleading yes because this

00:47:28,290 --> 00:47:36,080
should be views slice or at least CPP

00:47:31,260 --> 00:47:38,400
Khan used slice building a slice view is

00:47:36,080 --> 00:47:40,770
is something that's a bit more involved

00:47:38,400 --> 00:47:42,600
but we don't need to do that in C++ 20

00:47:40,770 --> 00:47:45,210
because we can make this lambda and that

00:47:42,600 --> 00:47:47,520
serves for most of the purposes that we

00:47:45,210 --> 00:47:48,570
have we would only probably want if you

00:47:47,520 --> 00:47:51,090
need the extra information

00:47:48,570 --> 00:47:56,490
yes you can go and build the the

00:47:51,090 --> 00:47:59,570
remainder of the slice view but for for

00:47:56,490 --> 00:48:02,430
all the use cases that I can foresee

00:47:59,570 --> 00:48:08,460
barring that special information this is

00:48:02,430 --> 00:48:09,360
all you would need to do I'm sorry I

00:48:08,460 --> 00:48:15,240
can't hear you would you mind going to

00:48:09,360 --> 00:48:18,540
my please so the question is is there a

00:48:15,240 --> 00:48:21,570
reason I keep using the word the word

00:48:18,540 --> 00:48:22,830
and instead of using ampersand ampersand

00:48:21,570 --> 00:48:25,260
and the reason for that is because I

00:48:22,830 --> 00:48:28,530
prefer to use the the English spelt

00:48:25,260 --> 00:48:32,580
words in in my code instead of using epi

00:48:28,530 --> 00:48:35,070
and ampersand and and the pipe pipe and

00:48:32,580 --> 00:48:36,690
the exclamation mark wherever possible

00:48:35,070 --> 00:48:39,180
because it makes reading concepts easier

00:48:36,690 --> 00:48:41,310
and makes things and helps things to

00:48:39,180 --> 00:48:42,900
flow a lot easier in my opinion it's

00:48:41,310 --> 00:48:45,270
something that's been possible since C++

00:48:42,900 --> 00:48:48,480
98 but it is something that's been very

00:48:45,270 --> 00:48:51,960
relatively hidden people aren't

00:48:48,480 --> 00:48:56,280
particularly aware of it now I just

00:48:51,960 --> 00:48:58,950
noticed that the time check it is we

00:48:56,280 --> 00:49:02,180
have roughly seven minutes left there

00:48:58,950 --> 00:49:05,700
are any questions before we press on

00:49:02,180 --> 00:49:09,600
okay I see none so the next one that I

00:49:05,700 --> 00:49:11,340
that I considered was strap you and I

00:49:09,600 --> 00:49:12,750
promise you this time around the

00:49:11,340 --> 00:49:15,150
underscore view is not going to be

00:49:12,750 --> 00:49:20,250
misleading so in this case what we have

00:49:15,150 --> 00:49:21,720
here is a stride and a strike as I say a

00:49:20,250 --> 00:49:23,160
straight of one and that means that

00:49:21,720 --> 00:49:25,080
we're going to consider every single

00:49:23,160 --> 00:49:28,740
element we only move forward by one

00:49:25,080 --> 00:49:30,360
every time a strategy where the

00:49:28,740 --> 00:49:35,460
Australia's two means we skip every

00:49:30,360 --> 00:49:37,500
other elements and a stride view of size

00:49:35,460 --> 00:49:39,090
where the stride is three would mean

00:49:37,500 --> 00:49:41,250
that we consider we only consider every

00:49:39,090 --> 00:49:47,490
third element there any questions about

00:49:41,250 --> 00:49:53,580
this all right so I think here would be

00:49:47,490 --> 00:49:56,130
a good point to pause and so I'd like to

00:49:53,580 --> 00:49:58,860
thank you for your time and in this

00:49:56,130 --> 00:50:02,070
session we we should have covered and

00:49:58,860 --> 00:50:03,900
enough for you to get a feel for

00:50:02,070 --> 00:50:06,030
what the underlying architecture of

00:50:03,900 --> 00:50:09,300
iterators are so we can move forward and

00:50:06,030 --> 00:50:12,990
produce a range adapter which will be

00:50:09,300 --> 00:50:14,220
considered in in the next session so

00:50:12,990 --> 00:50:19,600
thank you

00:50:14,220 --> 00:50:19,600

YouTube URL: https://www.youtube.com/watch?v=YWayW5ePpkY


