Title: CppCon 2019: Jason Turner “Great C++ is_trivial”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
There are many ways to initialize an object in C++, and much time spent analyzing the efficiency of the many options. We then think and rethink and overthink how to avoid copies and if a `std::move` would be more efficient in a certain case.

But if we understand what it means for a type to be trivial most of these questions now become meaningless. We can get all of the efficiency we could hope for, and probably more.

We will look at the trivial type traits, what they mean, and how they affect our code. Will will then examine the benefits of using trivial types and the impact on performance.
— 
Jason Turner
Developer, Trainer, Speaker
Greater Denver Area

Host of C++Weekly https://www.youtube.com/c/JasonTurner-lefticus, Co-host of CppCast http://cppcast.com, Co-creator and maintainer of the embedded scripting language for C++, ChaiScript http://chaiscript.com, and author and curator of the forkable coding standards document http://cppbestpractices.com.

—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,300 --> 00:00:12,790
so my name is Jason Turner just in case

00:00:11,490 --> 00:00:15,820
you haven't been Danny

00:00:12,790 --> 00:00:18,369
other talks this week Costa CVP cast

00:00:15,820 --> 00:00:20,140
host of C++ weekly I've got a few

00:00:18,369 --> 00:00:24,189
projects that I worked on and I'm

00:00:20,140 --> 00:00:25,840
Microsoft MVP I am independent available

00:00:24,189 --> 00:00:30,310
for contacting and training this is what

00:00:25,840 --> 00:00:32,980
I do and this kind of represents what my

00:00:30,310 --> 00:00:36,610
training days look like although in a

00:00:32,980 --> 00:00:41,410
different scale of course by the way who

00:00:36,610 --> 00:00:45,010
here is local to Denver okay

00:00:41,410 --> 00:00:48,790
who still needs to come to the Meetup

00:00:45,010 --> 00:00:50,979
because you've never been before okay so

00:00:48,790 --> 00:00:52,720
that's the name of it I've had a bunch

00:00:50,979 --> 00:00:55,210
of people ask me after other sessions

00:00:52,720 --> 00:00:58,199
it's the North Denver Metro C++ Meetup

00:00:55,210 --> 00:01:00,940
for whatever reason the search engine on

00:00:58,199 --> 00:01:02,530
meetup.com is terrible if you type that

00:01:00,940 --> 00:01:03,970
in you probably won't find the meetup

00:01:02,530 --> 00:01:05,229
even though that's the exact name of it

00:01:03,970 --> 00:01:07,900
but Google will get you there pretty

00:01:05,229 --> 00:01:12,670
quickly we do meet every month and have

00:01:07,900 --> 00:01:14,470
since November 2016 so even though I

00:01:12,670 --> 00:01:16,630
know many of you have been in my talks

00:01:14,470 --> 00:01:21,550
in the past you still sat in the back

00:01:16,630 --> 00:01:23,350
row feel free to take a moment and shift

00:01:21,550 --> 00:01:25,600
yourselves more forward if you want to

00:01:23,350 --> 00:01:26,890
interrupt me ask questions yell out

00:01:25,600 --> 00:01:28,330
there's a good chance I'll end up in the

00:01:26,890 --> 00:01:31,510
middle of the aisles again today

00:01:28,330 --> 00:01:34,840
we'll see what happens I do still have

00:01:31,510 --> 00:01:37,180
one training class good I mean there's

00:01:34,840 --> 00:01:39,760
still time to sign up for my contacts

00:01:37,180 --> 00:01:41,500
per class it is tomorrow if for some

00:01:39,760 --> 00:01:45,550
reason the website won't let you let me

00:01:41,500 --> 00:01:48,340
know and I'll talk to John okay so great

00:01:45,550 --> 00:01:51,810
C++ is trivial I am asking the question

00:01:48,340 --> 00:01:56,010
at the moment what do we mean by great

00:01:51,810 --> 00:02:01,300
he's you're right easier to maintain

00:01:56,010 --> 00:02:03,310
more optimizable we're going to touch a

00:02:01,300 --> 00:02:06,640
little bit on each of these things but

00:02:03,310 --> 00:02:08,619
really for the most part this session is

00:02:06,640 --> 00:02:10,539
talking about code that is great and

00:02:08,619 --> 00:02:14,830
that we're helping the compiler write

00:02:10,539 --> 00:02:17,590
you know optimize our code this is not a

00:02:14,830 --> 00:02:19,420
best practices talk per se most of the

00:02:17,590 --> 00:02:21,370
time when I speak I'm saying you should

00:02:19,420 --> 00:02:24,430
always do this or never do this kind of

00:02:21,370 --> 00:02:27,750
thing this is mostly to make you think

00:02:24,430 --> 00:02:31,540
about the way you write your classes

00:02:27,750 --> 00:02:34,120
and I'm going to build a little bit on

00:02:31,540 --> 00:02:35,470
the things that I discussed on Tuesday

00:02:34,120 --> 00:02:39,879
there's not meant as a direct

00:02:35,470 --> 00:02:43,269
continuation who is here for the what

00:02:39,879 --> 00:02:45,540
was the name of that talk see it was

00:02:43,269 --> 00:02:48,489
less code smells who came to that one oh

00:02:45,540 --> 00:02:54,519
wow well thanks for coming back I must

00:02:48,489 --> 00:02:57,909
not have done a terrible job okay

00:02:54,519 --> 00:03:02,230
we're going to go through some exercises

00:02:57,909 --> 00:03:03,640
as I like to do we're gonna see how

00:03:02,230 --> 00:03:05,769
quickly or slowly we go through them

00:03:03,640 --> 00:03:06,849
honestly I don't really know how this is

00:03:05,769 --> 00:03:08,650
going to go because it's hard to

00:03:06,849 --> 00:03:12,430
practice this kind of thing with

00:03:08,650 --> 00:03:15,099
yourself so we have four options here

00:03:12,430 --> 00:03:18,970
and I am going to ask you which of these

00:03:15,099 --> 00:03:21,310
is the optimal design of the four

00:03:18,970 --> 00:03:27,519
choices which one is going to give us

00:03:21,310 --> 00:03:30,430
the the best most efficient code okay so

00:03:27,519 --> 00:03:38,310
let's do it by poll I heard yet so bees

00:03:30,430 --> 00:03:46,139
who says eh who says bee who says C and

00:03:38,310 --> 00:03:49,209
who says D okay so what do we got with a

00:03:46,139 --> 00:03:51,480
we are forcing a move we're not allowing

00:03:49,209 --> 00:03:54,489
return value optimization to take place

00:03:51,480 --> 00:03:58,530
with B we get returned value

00:03:54,489 --> 00:04:05,019
optimisation moved Felician with see

00:03:58,530 --> 00:04:06,819
what do we have like wait what was that

00:04:05,019 --> 00:04:08,709
oh sorry I see I can't help myself

00:04:06,819 --> 00:04:10,169
there's I have no idea why the stage is

00:04:08,709 --> 00:04:14,709
there it's not for me what did you say

00:04:10,169 --> 00:04:15,489
someone's yelling something right no

00:04:14,709 --> 00:04:17,229
compile error

00:04:15,489 --> 00:04:19,000
no actually it's gonna silently revert

00:04:17,229 --> 00:04:21,180
to a copy unless you've got like cling

00:04:19,000 --> 00:04:24,900
tightly or something amped up on here

00:04:21,180 --> 00:04:28,560
unfortunately silently revert to copy

00:04:24,900 --> 00:04:31,470
okay so that's a copy and then D is

00:04:28,560 --> 00:04:34,810
returned value optimization again

00:04:31,470 --> 00:04:37,389
something like that so I highlighted the

00:04:34,810 --> 00:04:39,670
ones that are good so I've highlighted

00:04:37,389 --> 00:04:42,110
the bad ones with a good one

00:04:39,670 --> 00:04:48,710
good ones okay so I highlighted the good

00:04:42,110 --> 00:04:50,300
ones good cuz that's what I did I have

00:04:48,710 --> 00:04:54,190
changed things up a bit

00:04:50,300 --> 00:04:58,880
I am using a structured binding from C++

00:04:54,190 --> 00:05:01,040
17 get it says get string pair let's

00:04:58,880 --> 00:05:03,590
assume that the undefined function does

00:05:01,040 --> 00:05:12,880
in fact do what it claims to do it is

00:05:03,590 --> 00:05:19,010
returning a pair of strings hmm

00:05:12,880 --> 00:05:20,600
reference someone hopes it's B hope and

00:05:19,010 --> 00:05:25,190
wishes wait how does that I don't have a

00:05:20,600 --> 00:05:28,760
good okay wait oh I'm getting hand

00:05:25,190 --> 00:05:31,760
signals down here okay this is this

00:05:28,760 --> 00:05:35,630
could be fun because again I'm breaking

00:05:31,760 --> 00:05:40,670
the rules with the stage what what what

00:05:35,630 --> 00:05:51,440
is a gonna do it's going to force a move

00:05:40,670 --> 00:05:55,310
okay what is going to happen with B who

00:05:51,440 --> 00:05:56,300
says rvo is gonna apply here oh and see

00:05:55,310 --> 00:05:59,240
now you're not gonna raise your hands

00:05:56,300 --> 00:06:03,980
because I made Marshall says rarbie O's

00:05:59,240 --> 00:06:05,900
gonna happen okay with a structured

00:06:03,980 --> 00:06:08,000
binding I don't have any actual slides

00:06:05,900 --> 00:06:10,760
explaining this well the structured

00:06:08,000 --> 00:06:13,970
binding rvo can't happen here because

00:06:10,760 --> 00:06:15,500
str1 and str2 are actually references

00:06:13,970 --> 00:06:18,350
that point back into a hidden object

00:06:15,500 --> 00:06:20,060
called e defined by the standard which

00:06:18,350 --> 00:06:26,630
is the actual location where the result

00:06:20,060 --> 00:06:29,950
from the function call lives yay so B is

00:06:26,630 --> 00:06:29,950
a copy

00:06:30,970 --> 00:06:34,690
what does C do

00:06:36,840 --> 00:06:41,670
I well actually let's come back to see

00:06:39,840 --> 00:06:45,450
does anyone know that they know for sure

00:06:41,670 --> 00:07:04,530
what sea is gonna do oh okay yes what

00:06:45,450 --> 00:07:07,680
what is it gonna do okay okay so

00:07:04,530 --> 00:07:09,690
lifetime extension because it's because

00:07:07,680 --> 00:07:12,540
of our value reference to the temporary

00:07:09,690 --> 00:07:15,630
that was returned by gets stringpair yes

00:07:12,540 --> 00:07:18,750
and then what happens after that that's

00:07:15,630 --> 00:07:26,310
still the question basically okay let's

00:07:18,750 --> 00:07:28,760
come back to that one D it has to be a

00:07:26,310 --> 00:07:31,590
copy because it's a constant value again

00:07:28,760 --> 00:07:33,510
just for the record I don't believe you

00:07:31,590 --> 00:07:36,060
would get warnings from anything except

00:07:33,510 --> 00:07:44,430
maybe static analysis tools here and

00:07:36,060 --> 00:07:47,669
then ek2 what what what is e do same as

00:07:44,430 --> 00:07:49,919
b e is the same as b it's a copy that's

00:07:47,669 --> 00:07:51,360
what I heard up here by the way for

00:07:49,919 --> 00:07:53,640
those of you who did not pay attention

00:07:51,360 --> 00:07:55,620
and sat further in the back if you want

00:07:53,640 --> 00:07:58,200
to participate more you have to yell

00:07:55,620 --> 00:08:00,180
loudly or somehow convinced me to walk

00:07:58,200 --> 00:08:03,210
down the aisle or run up to one of these

00:08:00,180 --> 00:08:08,760
microphones or something like that okay

00:08:03,210 --> 00:08:18,090
all right so we got a forced move on a

00:08:08,760 --> 00:08:20,539
an accidental copy on B C let's get back

00:08:18,090 --> 00:08:20,539
to see

00:08:21,200 --> 00:08:27,360
d is a forced cot as a copy even though

00:08:25,050 --> 00:08:28,800
it looks like a move and E is a copy so

00:08:27,360 --> 00:08:33,000
at the moment the only thing that we

00:08:28,800 --> 00:08:34,440
know is a move is a and return value

00:08:33,000 --> 00:08:40,110
optimisation doesn't apply to any of

00:08:34,440 --> 00:08:42,300
these the reason I'm saying on C is

00:08:40,110 --> 00:08:45,660
there's this paper that was approved for

00:08:42,300 --> 00:08:48,740
C++ 20 that is more implicit moves as

00:08:45,660 --> 00:08:52,020
David Stone in the room by any chance

00:08:48,740 --> 00:08:54,570
okay because I believe he is the author

00:08:52,020 --> 00:08:58,370
or co-author of that paper and as hoping

00:08:54,570 --> 00:08:58,370
I might get an answer to this question

00:08:58,760 --> 00:09:06,690
with that paper if you've got an R value

00:09:02,490 --> 00:09:09,750
reference and you return it then it's

00:09:06,690 --> 00:09:12,300
supposed to be implicitly a move now but

00:09:09,750 --> 00:09:15,810
will it count an R value reference of a

00:09:12,300 --> 00:09:17,550
structured binding as an implicit move I

00:09:15,810 --> 00:09:19,080
have absolutely no idea I know there are

00:09:17,550 --> 00:09:20,820
several members of the committee like

00:09:19,080 --> 00:09:22,980
sitting in this general area are people

00:09:20,820 --> 00:09:25,470
who attend meetings do you have any idea

00:09:22,980 --> 00:09:33,060
no idea no idea okay great we don't have

00:09:25,470 --> 00:09:35,310
any idea it's none of the compilers

00:09:33,060 --> 00:09:38,220
implement the more explicit moves yet so

00:09:35,310 --> 00:09:42,060
I can't even test it that's otherwise I

00:09:38,220 --> 00:09:43,860
would have yeah okay so we didn't learn

00:09:42,060 --> 00:09:45,270
anything except we learned that

00:09:43,860 --> 00:09:51,300
structured bindings mess with our

00:09:45,270 --> 00:09:56,640
notions here this is you know a little

00:09:51,300 --> 00:09:58,560
bit coming back to Tuesday we don't know

00:09:56,640 --> 00:10:01,230
what use string does we don't know

00:09:58,560 --> 00:10:03,120
anything about its function signature we

00:10:01,230 --> 00:10:11,250
can still make some assumptions about

00:10:03,120 --> 00:10:18,330
this code tell me who prefers a who

00:10:11,250 --> 00:10:23,010
prefers B who prefers C okay that's the

00:10:18,330 --> 00:10:25,260
bulk of the room who prefers D I prefer

00:10:23,010 --> 00:10:27,690
D just for the record from an efficiency

00:10:25,260 --> 00:10:29,760
standpoint whatever needs to happen

00:10:27,690 --> 00:10:31,350
whatever that parameter is that you

00:10:29,760 --> 00:10:32,970
string is using it's going to be

00:10:31,350 --> 00:10:33,820
constructed in place we've returned by

00:10:32,970 --> 00:10:36,430
optimization

00:10:33,820 --> 00:10:38,740
whatever is gonna come into play on C or

00:10:36,430 --> 00:10:42,520
D we're gonna construct that in place B

00:10:38,740 --> 00:10:44,710
we're forcing a move which well we're

00:10:42,520 --> 00:10:46,960
getting a move I guess we should say or

00:10:44,710 --> 00:10:49,570
maybe a move I don't know if you string

00:10:46,960 --> 00:10:51,760
takes a Const reference then then B's

00:10:49,570 --> 00:10:55,180
just wasted code and it makes us wonder

00:10:51,760 --> 00:10:57,070
online for right here what in the world

00:10:55,180 --> 00:10:59,470
is the state of string has it been moved

00:10:57,070 --> 00:11:01,390
from why why did I put this and my

00:10:59,470 --> 00:11:05,310
mental cue of things that I have to deal

00:11:01,390 --> 00:11:09,910
with when I read this code oops

00:11:05,310 --> 00:11:11,920
knock over the clock okay and a a is

00:11:09,910 --> 00:11:13,930
whatever it might be a copy it might be

00:11:11,920 --> 00:11:16,750
a reference we don't know I'm gonna

00:11:13,930 --> 00:11:25,830
prefer C or D from without knowing

00:11:16,750 --> 00:11:25,830
anything I thought the code marshal yes

00:11:29,160 --> 00:11:38,040
if you string takes oh that's true so

00:11:35,200 --> 00:11:41,050
Marshall said if the string takes a

00:11:38,040 --> 00:11:45,700
non-constant no sorry if use string and

00:11:41,050 --> 00:11:48,490
Block C takes a non Constance to a

00:11:45,700 --> 00:11:50,110
string then the code won't compile so I

00:11:48,490 --> 00:11:51,880
guess for the sake of this example we

00:11:50,110 --> 00:11:55,210
have to assume that the samples compile

00:11:51,880 --> 00:11:56,080
and it's not doing that but it's a very

00:11:55,210 --> 00:12:00,820
good point

00:11:56,080 --> 00:12:03,780
really now I just out of curiosity would

00:12:00,820 --> 00:12:11,050
it work on D if you string takes a

00:12:03,780 --> 00:12:12,670
non-conference go ahead and beer if get

00:12:11,050 --> 00:12:13,990
if getstring returns a non-constant

00:12:12,670 --> 00:12:16,780
reference that's the only case in which

00:12:13,990 --> 00:12:18,340
D would work if the prayer the function

00:12:16,780 --> 00:12:23,470
primary took a non-conference a string

00:12:18,340 --> 00:12:25,210
that sounds right yeah okay so we were

00:12:23,470 --> 00:12:27,280
reasoning about what we're asking the

00:12:25,210 --> 00:12:32,500
compiler to do that runt or it's gonna

00:12:27,280 --> 00:12:35,170
happen at runtime here out parameters

00:12:32,500 --> 00:12:39,960
versus return values we spent some time

00:12:35,170 --> 00:12:45,120
on this on Tuesday as well definitely

00:12:39,960 --> 00:12:47,320
who prefers a I have no problem with DES

00:12:45,120 --> 00:12:50,290
hoover's be

00:12:47,320 --> 00:12:55,440
yeah that's we like be Const as many

00:12:50,290 --> 00:13:03,279
things as we can who prefers C all right

00:12:55,440 --> 00:13:06,149
Nandy d can't compile really and that

00:13:03,279 --> 00:13:08,560
was just there to throw you out what

00:13:06,149 --> 00:13:11,880
yeah I used Const gasps let's invoke

00:13:08,560 --> 00:13:11,880
undefined behavior that's a good idea

00:13:17,040 --> 00:13:22,440
maybe I should do a talk undefined

00:13:19,420 --> 00:13:22,440
behavior all the things

00:13:23,790 --> 00:13:31,270
okay so uncie I just want to point out

00:13:28,210 --> 00:13:34,510
we are requiring the compiler to default

00:13:31,270 --> 00:13:38,430
construct this before we pass it in on

00:13:34,510 --> 00:13:41,620
line three right it has to do extra work

00:13:38,430 --> 00:13:43,270
compared to the options on a and B where

00:13:41,620 --> 00:13:48,240
we can take advantage of just capturing

00:13:43,270 --> 00:13:48,240
that thing that was returned to us yeah

00:13:49,650 --> 00:13:55,870
can the compiler just write online

00:13:52,800 --> 00:13:58,300
option C no no the compiler can't fix

00:13:55,870 --> 00:14:00,880
this you might see examples you can go

00:13:58,300 --> 00:14:03,640
on god bolt or compile Explorer Matt

00:14:00,880 --> 00:14:05,410
compiler Explorer whatever yeah he's

00:14:03,640 --> 00:14:07,360
over there just for the record you look

00:14:05,410 --> 00:14:11,470
everyone look at Matt no I'm just

00:14:07,360 --> 00:14:14,770
kidding okay so it happens that I have

00:14:11,470 --> 00:14:16,120
too much flexibility you can construct

00:14:14,770 --> 00:14:18,910
examples where the compiler would

00:14:16,120 --> 00:14:20,980
optimize that version away and the

00:14:18,910 --> 00:14:22,480
general case we can't assume that we

00:14:20,980 --> 00:14:25,090
have to assume that it has to default

00:14:22,480 --> 00:14:28,030
construct that string and then pass it

00:14:25,090 --> 00:14:29,290
in and then assign the value to it it's

00:14:28,030 --> 00:14:31,900
only going to be able to optimize it

00:14:29,290 --> 00:14:33,880
away if the implementation of get value

00:14:31,900 --> 00:14:41,130
is visible to the compiler or you do

00:14:33,880 --> 00:14:41,130
link time optimization perhaps all right

00:14:41,520 --> 00:14:49,380
assignment versus initialization I am

00:14:44,950 --> 00:14:54,910
probably moving slow it's fine okay

00:14:49,380 --> 00:15:04,300
go ahead just yell out something what do

00:14:54,910 --> 00:15:06,670
you we like is that the same code yeah

00:15:04,300 --> 00:15:12,970
okay so what are the problems let's see

00:15:06,670 --> 00:15:15,820
on B potential problem yeah well on B

00:15:12,970 --> 00:15:17,320
let's see yes we construct it and then

00:15:15,820 --> 00:15:20,530
we have to do an assignment same thing

00:15:17,320 --> 00:15:25,210
as a but we also get an extra problem on

00:15:20,530 --> 00:15:27,190
B special problem bonus problem as a

00:15:25,210 --> 00:15:29,770
constant return value so now we're doing

00:15:27,190 --> 00:15:33,400
a copy assignment set of a move

00:15:29,770 --> 00:15:35,620
assignment but C and D avoid those

00:15:33,400 --> 00:15:37,899
problems altogether it's another

00:15:35,620 --> 00:15:43,379
question of initial default initializing

00:15:37,899 --> 00:15:47,589
the thing first reassignment of values

00:15:43,379 --> 00:15:50,470
who prefers a who's gonna say a is

00:15:47,589 --> 00:15:54,089
better more efficient code more

00:15:50,470 --> 00:15:56,110
efficient code really Richard sorry

00:15:54,089 --> 00:16:00,519
since you're in the front row and I know

00:15:56,110 --> 00:16:02,800
your name it's not okay sue so in my

00:16:00,519 --> 00:16:04,660
talk on Monday I had Yan get up on the

00:16:02,800 --> 00:16:06,240
stage with me if any of you are here for

00:16:04,660 --> 00:16:08,559
that although it was in a different room

00:16:06,240 --> 00:16:10,540
we are talking about returned value

00:16:08,559 --> 00:16:12,699
optimization being you know basically

00:16:10,540 --> 00:16:15,069
another neither a copy nor move comes

00:16:12,699 --> 00:16:19,480
into play and guaranteed copy illusion

00:16:15,069 --> 00:16:21,879
kind of rules if the object val is here

00:16:19,480 --> 00:16:24,160
and in the second block then i don't

00:16:21,879 --> 00:16:25,990
have to do an assignment i'm just giving

00:16:24,160 --> 00:16:27,339
a name to the temporary that had to be

00:16:25,990 --> 00:16:30,009
returned from the function in the first

00:16:27,339 --> 00:16:32,259
place and and block AI have to do an

00:16:30,009 --> 00:16:34,389
assignment operation each time it's

00:16:32,259 --> 00:16:37,990
gonna be more work if the scope is only

00:16:34,389 --> 00:16:41,740
for that if i only care about a nut

00:16:37,990 --> 00:16:44,170
scope okay point of this talk was great

00:16:41,740 --> 00:16:48,370
c++ as trivial let's talk about

00:16:44,170 --> 00:16:50,350
triviality okay i'm sorry i have to do

00:16:48,370 --> 00:16:53,250
the disclaimer here i have lots of

00:16:50,350 --> 00:16:58,120
quotes from the standard i'm sorry

00:16:53,250 --> 00:17:02,040
we'll see how it goes is trivially

00:16:58,120 --> 00:17:06,669
destructible this is if it is

00:17:02,040 --> 00:17:08,829
destructible and it is a non class type

00:17:06,669 --> 00:17:11,589
or a class type with a trivial

00:17:08,829 --> 00:17:18,699
destructor that is what this is saying

00:17:11,589 --> 00:17:20,709
is this trivially destructible yes

00:17:18,699 --> 00:17:24,010
clearly nothing has to happen in its

00:17:20,709 --> 00:17:27,459
destructor is this trivially

00:17:24,010 --> 00:17:30,610
destructible oh i heard like a very loud

00:17:27,459 --> 00:17:33,010
yes who did that you know what i've been

00:17:30,610 --> 00:17:38,669
carrying this around for a few days so

00:17:33,010 --> 00:17:38,669
you get to have it now all right

00:17:41,070 --> 00:17:48,039
all right so if the explicitly defaulted

00:17:45,130 --> 00:17:49,750
indeed no if the implicitly defaulted

00:17:48,039 --> 00:17:51,940
destructor would have been trivial than

00:17:49,750 --> 00:17:54,100
the explicitly defaulted destructor is

00:17:51,940 --> 00:17:56,620
trivial okay good that's trivially

00:17:54,100 --> 00:18:00,299
destructible as this trivially

00:17:56,620 --> 00:18:02,160
destructible no we gave it a destructor

00:18:00,299 --> 00:18:06,460
does it do anything

00:18:02,160 --> 00:18:08,289
no but it's still not trivial not really

00:18:06,460 --> 00:18:10,179
destructible so the static asserts here

00:18:08,289 --> 00:18:13,299
are just theoretically proving these

00:18:10,179 --> 00:18:17,740
things is this trivially destructible no

00:18:13,299 --> 00:18:19,950
why not because string is not trivially

00:18:17,740 --> 00:18:23,620
destructible that was the general murmur

00:18:19,950 --> 00:18:27,070
yeah okay string is not trivially

00:18:23,620 --> 00:18:29,620
destructible a trivially copyable type

00:18:27,070 --> 00:18:32,679
this is where things get fun if the

00:18:29,620 --> 00:18:34,990
underlying bites making up the object

00:18:32,679 --> 00:18:38,260
can be copied into an array of car

00:18:34,990 --> 00:18:40,450
unsigned car or byte if the content of

00:18:38,260 --> 00:18:42,909
that array is copied back into the

00:18:40,450 --> 00:18:45,610
object the object shall subsequently

00:18:42,909 --> 00:18:47,260
hold its original value so it's

00:18:45,610 --> 00:18:51,909
something that we can copy the bytes

00:18:47,260 --> 00:18:53,590
around has at least one eligible copy

00:18:51,909 --> 00:18:55,380
constructor move constructor copies on

00:18:53,590 --> 00:19:00,100
an operator or move assignment operator

00:18:55,380 --> 00:19:04,860
where each eligible thing is trivial and

00:19:00,100 --> 00:19:08,880
it has a trivial non deleted destructor

00:19:04,860 --> 00:19:12,100
who has ever deleted their destructor

00:19:08,880 --> 00:19:14,770
why why I know I'm gonna since I just

00:19:12,100 --> 00:19:20,169
gave you a yeah why did you delete your

00:19:14,770 --> 00:19:22,270
destructor testing concepts okay so not

00:19:20,169 --> 00:19:24,730
in production code for some reason I

00:19:22,270 --> 00:19:29,100
have the no not in production code

00:19:24,730 --> 00:19:29,100
either just to show off okay

00:19:29,460 --> 00:19:41,130
who programs in C++ and mostly because

00:19:32,679 --> 00:19:41,130
they like showing off okay

00:19:41,159 --> 00:19:46,330
just for the record if you delete your

00:19:43,419 --> 00:19:48,850
destructor it is valid code you can new

00:19:46,330 --> 00:19:50,470
an object put it on the heap and then

00:19:48,850 --> 00:19:53,049
never clean it up in the lifetime of the

00:19:50,470 --> 00:19:54,639
program you can write valid code with

00:19:53,049 --> 00:19:56,769
objects that have had the destructor

00:19:54,639 --> 00:20:03,220
delete it it's a very strange thing to

00:19:56,769 --> 00:20:04,840
do okay is this trivially copyable I put

00:20:03,220 --> 00:20:09,519
the precondition up there that int is

00:20:04,840 --> 00:20:12,940
trivially copyable yes and then I have

00:20:09,519 --> 00:20:17,889
another static assert down here string

00:20:12,940 --> 00:20:21,759
is not trivially copyable is this

00:20:17,889 --> 00:20:27,929
trivially copyable no because it has a

00:20:21,759 --> 00:20:32,710
non-trivial destructor okay trivial

00:20:27,929 --> 00:20:35,590
constructibility let's see is is known

00:20:32,710 --> 00:20:37,809
to call no operation that is trivial so

00:20:35,590 --> 00:20:40,200
during its construction has to call no

00:20:37,809 --> 00:20:44,980
operation that is trivial

00:20:40,200 --> 00:20:47,379
wait what I say that wrong it has to

00:20:44,980 --> 00:20:49,690
call no operation that is known to call

00:20:47,379 --> 00:20:50,860
no operation that is not trivial they

00:20:49,690 --> 00:20:52,779
feel like they could have removed at

00:20:50,860 --> 00:20:57,059
least one of those negatives somehow and

00:20:52,779 --> 00:20:59,769
cleaned up the sentence we cannot call

00:20:57,059 --> 00:21:00,669
non-trivial operations during

00:20:59,769 --> 00:21:05,080
construction

00:21:00,669 --> 00:21:10,059
that's over going for so this thing this

00:21:05,080 --> 00:21:14,950
struct s with an integer in it and an

00:21:10,059 --> 00:21:17,980
explicitly defaulted default constructor

00:21:14,950 --> 00:21:20,950
it is trivially constructible now I'm

00:21:17,980 --> 00:21:22,629
gonna let's see if I can no I can't do

00:21:20,950 --> 00:21:25,840
that nevermind I'm gonna use the

00:21:22,629 --> 00:21:28,570
wireless mouse so right here is

00:21:25,840 --> 00:21:30,519
trivially constructible this is is the

00:21:28,570 --> 00:21:32,019
type trivially constructible with no

00:21:30,519 --> 00:21:34,509
parameters this is equivalent to the

00:21:32,019 --> 00:21:36,879
default constructor that is true it is

00:21:34,509 --> 00:21:38,679
also trivially constructible with a copy

00:21:36,879 --> 00:21:41,309
of itself it's trivially copy you will

00:21:38,679 --> 00:21:43,740
construct copy constructible or not

00:21:41,309 --> 00:21:45,570
of the same type if I try to call a

00:21:43,740 --> 00:21:48,090
non-existent constructor one that takes

00:21:45,570 --> 00:21:49,980
two integers then this is false because

00:21:48,090 --> 00:21:52,700
it can't be constructed at all with two

00:21:49,980 --> 00:21:56,279
integers and if I try to pass it one

00:21:52,700 --> 00:21:59,690
integer it is also not trivially

00:21:56,279 --> 00:22:02,610
constructible because this constructor

00:21:59,690 --> 00:22:06,330
exists it doesn't matter that the

00:22:02,610 --> 00:22:07,980
constructor does nothing and just for

00:22:06,330 --> 00:22:10,320
the record these are all tested compiles

00:22:07,980 --> 00:22:11,970
so the fact that I declared a

00:22:10,320 --> 00:22:14,009
constructor that takes an integer means

00:22:11,970 --> 00:22:17,820
it is not trivially constructible from

00:22:14,009 --> 00:22:20,279
an integer is trivially default

00:22:17,820 --> 00:22:22,590
constructible it's this you know it's

00:22:20,279 --> 00:22:24,059
that base case the one on line ten if

00:22:22,590 --> 00:22:27,029
that's true then it's default

00:22:24,059 --> 00:22:30,499
contributed default constructible this

00:22:27,029 --> 00:22:36,289
is trivially default constructible and

00:22:30,499 --> 00:22:36,289
yeah so that is the equivalence here

00:22:38,809 --> 00:22:44,129
nope I'm already getting nope nope nope

00:22:41,730 --> 00:22:45,980
not trivially default constructible

00:22:44,129 --> 00:22:49,350
because we defined a default constructor

00:22:45,980 --> 00:22:53,210
as this trivially default constructible

00:22:49,350 --> 00:22:53,210
this is where it gets fun in my opinion

00:22:54,200 --> 00:23:00,119
who says yes this is trivially default

00:22:57,149 --> 00:23:04,820
constructible who says no this is not

00:23:00,119 --> 00:23:06,659
tribute we default constructible wait

00:23:04,820 --> 00:23:07,889
wait wait Richard you raised your hand

00:23:06,659 --> 00:23:09,330
on the second one why not I'm already

00:23:07,889 --> 00:23:22,889
picking on you why is that not trivially

00:23:09,330 --> 00:23:24,119
default constructible I don't think your

00:23:22,889 --> 00:23:27,409
logic followed so I'm not going to

00:23:24,119 --> 00:23:27,409
bother repeating it for the camera

00:23:29,200 --> 00:23:35,000
I'm sorry just for the record for

00:23:32,690 --> 00:23:37,220
YouTube and for the room I've known

00:23:35,000 --> 00:23:39,289
Richard for what five years now or

00:23:37,220 --> 00:23:43,610
something so I mean I give him a hard

00:23:39,289 --> 00:23:48,620
time a little bit it's okay yeah yeah

00:23:43,610 --> 00:23:51,500
okay no um actually more correctly I

00:23:48,620 --> 00:23:53,929
didn't fully understand your logic what

00:23:51,500 --> 00:23:59,419
does what happens if I default construct

00:23:53,929 --> 00:24:02,269
an object of this type the member gets

00:23:59,419 --> 00:24:07,970
value initialized to zero what happens

00:24:02,269 --> 00:24:09,980
if those braces aren't there nothing

00:24:07,970 --> 00:24:11,659
it's whatever memory was there it's

00:24:09,980 --> 00:24:14,480
undefined behavior to read that value

00:24:11,659 --> 00:24:16,580
because it's an uninitialized value this

00:24:14,480 --> 00:24:18,440
is initializing it it's like the

00:24:16,580 --> 00:24:20,419
compiler synthesized a default

00:24:18,440 --> 00:24:23,720
constructor for us that meant sets this

00:24:20,419 --> 00:24:32,360
value to zero so this is not trivially

00:24:23,720 --> 00:24:34,909
default constructible okay so if I

00:24:32,360 --> 00:24:37,190
remove those braces it is now trivially

00:24:34,909 --> 00:24:38,179
default constructible again difference

00:24:37,190 --> 00:24:39,860
we're doing a constructor that does

00:24:38,179 --> 00:24:45,440
something in a constructor that does not

00:24:39,860 --> 00:24:48,169
do something ha is trivially copy

00:24:45,440 --> 00:24:51,470
constructible that's just it is if is

00:24:48,169 --> 00:24:52,850
really constructible with itself so yes

00:24:51,470 --> 00:24:56,600
this thing is trivially copy

00:24:52,850 --> 00:24:59,269
constructible oops this one is not

00:24:56,600 --> 00:25:01,909
trivially copy constructible simply

00:24:59,269 --> 00:25:06,110
because standard string is not trivially

00:25:01,909 --> 00:25:08,330
copy constructible now who's going to go

00:25:06,110 --> 00:25:10,159
and like make like a poster with all of

00:25:08,330 --> 00:25:14,059
the type traits about triviality after

00:25:10,159 --> 00:25:15,110
this maybe I should put one up on you

00:25:14,059 --> 00:25:19,190
know okay

00:25:15,110 --> 00:25:22,159
string is not is it is this trivially

00:25:19,190 --> 00:25:23,779
copy constructible you're raising your

00:25:22,159 --> 00:25:26,690
hands yes ok who says yes this is

00:25:23,779 --> 00:25:28,190
trivially copy constructible ok does

00:25:26,690 --> 00:25:33,070
anyone want to make an argument for why

00:25:28,190 --> 00:25:36,860
it is not trivially copy constructible

00:25:33,070 --> 00:25:40,090
ok so it is trivially copy constructible

00:25:36,860 --> 00:25:42,080
we can copy the bytes back and forth its

00:25:40,090 --> 00:25:45,850
default constructability

00:25:42,080 --> 00:25:50,980
does not affect copy constructability

00:25:45,850 --> 00:25:56,140
his trivially move constructible

00:25:50,980 --> 00:26:00,919
trivially move constructible yes

00:25:56,140 --> 00:26:07,730
trivially move constructible no string

00:26:00,919 --> 00:26:12,769
has to do something on a move is

00:26:07,730 --> 00:26:14,330
trivially assignable it's again it says

00:26:12,769 --> 00:26:15,730
it's known to call no operation that is

00:26:14,330 --> 00:26:20,720
not trivial

00:26:15,730 --> 00:26:25,299
if this trivially assignable and in what

00:26:20,720 --> 00:26:33,350
ways we have options

00:26:25,299 --> 00:26:37,850
is it trivially copy assignable is it

00:26:33,350 --> 00:26:41,630
trivially move assignable is it

00:26:37,850 --> 00:26:44,090
trivially assignable from an integer no

00:26:41,630 --> 00:26:45,889
even though it's just an integer and all

00:26:44,090 --> 00:26:48,740
I'm doing is copying that value of an

00:26:45,889 --> 00:26:53,330
integer over this is not trivially copy

00:26:48,740 --> 00:26:56,389
assignable from an integer so we have

00:26:53,330 --> 00:26:58,370
been broken out here we can call things

00:26:56,389 --> 00:27:00,350
that don't exist and make no sense and

00:26:58,370 --> 00:27:03,409
we'll get the proper response from our

00:27:00,350 --> 00:27:06,559
well compile time static assertion copy

00:27:03,409 --> 00:27:09,080
assignment and user-defined assignment

00:27:06,559 --> 00:27:14,330
operator is simply not trivial no matter

00:27:09,080 --> 00:27:16,460
what's in it is trivially copy

00:27:14,330 --> 00:27:18,260
assignable it's just a shorthand for

00:27:16,460 --> 00:27:20,690
calling this is trivially assignable

00:27:18,260 --> 00:27:21,919
with a dereference and a constituency

00:27:20,690 --> 00:27:27,860
it's what we've already been looking at

00:27:21,919 --> 00:27:29,419
so this is trivially copy assignable no

00:27:27,860 --> 00:27:34,429
we've got a string in here it's not

00:27:29,419 --> 00:27:37,190
trivially copy assignable trivially move

00:27:34,429 --> 00:27:41,409
assignable again it's shorthand is

00:27:37,190 --> 00:27:46,429
tribulus honorable yeah we see a pattern

00:27:41,409 --> 00:27:47,750
no ok string is not alright get back to

00:27:46,429 --> 00:27:52,460
something a little bit more interesting

00:27:47,750 --> 00:27:55,220
is trivial scalar types trivial class

00:27:52,460 --> 00:27:55,700
types arrays of types of such types and

00:27:55,220 --> 00:28:00,620
see

00:27:55,700 --> 00:28:02,930
what a CV mean Const or volatile

00:28:00,620 --> 00:28:07,540
qualified versions of these types are

00:28:02,930 --> 00:28:07,540
collectively called trivial types a

00:28:08,020 --> 00:28:13,760
trivial class is a class that is eight

00:28:10,670 --> 00:28:16,070
review is trivially copyable and has one

00:28:13,760 --> 00:28:19,550
or more eligible default constructors

00:28:16,070 --> 00:28:23,450
all of which are trivial I find this

00:28:19,550 --> 00:28:25,550
note interesting I have a theory I've

00:28:23,450 --> 00:28:27,470
yet to prove it but I think that if you

00:28:25,550 --> 00:28:29,960
were to remove all of the standard and

00:28:27,470 --> 00:28:31,310
leave only the notes and examples there

00:28:29,960 --> 00:28:33,230
would be a lot to learn from just

00:28:31,310 --> 00:28:34,670
reading those like forget what the

00:28:33,230 --> 00:28:36,710
standard says just read the notes and

00:28:34,670 --> 00:28:39,920
examples so this little note in

00:28:36,710 --> 00:28:42,530
particular a trivially copyable or

00:28:39,920 --> 00:28:47,120
trivial class does not have virtual

00:28:42,530 --> 00:28:50,240
functions I'm not a hundred percent sure

00:28:47,120 --> 00:28:57,200
why that rule is true the Peter is oh

00:28:50,240 --> 00:28:59,270
wait no it's the up okay because we have

00:28:57,200 --> 00:29:01,310
to stamp out the V table pointer in the

00:28:59,270 --> 00:29:05,740
copy operation it is not trivial

00:29:01,310 --> 00:29:08,360
so you said dude

00:29:05,740 --> 00:29:09,560
okay so initializing an object of the

00:29:08,360 --> 00:29:12,700
type requires work to be done because

00:29:09,560 --> 00:29:16,550
the V table pointer that makes that okay

00:29:12,700 --> 00:29:18,170
so is this a trivial type I mean I have

00:29:16,550 --> 00:29:27,260
the static asserts there yes it's a

00:29:18,170 --> 00:29:28,550
trivial type it's not a trivial type it

00:29:27,260 --> 00:29:30,680
doesn't have a trivial default

00:29:28,550 --> 00:29:37,300
constructor but it is trivially

00:29:30,680 --> 00:29:42,380
destructible okay is this a trivial type

00:29:37,300 --> 00:29:44,870
no it is still trivially destructible

00:29:42,380 --> 00:29:50,210
and trivially a not really default

00:29:44,870 --> 00:29:53,030
constructible and is not trivial okay so

00:29:50,210 --> 00:29:55,180
I went from moving slower than I

00:29:53,030 --> 00:29:58,300
expected to faster than I expected so

00:29:55,180 --> 00:29:58,300
here we are

00:29:58,330 --> 00:30:07,260
which of these versions is most

00:30:01,730 --> 00:30:10,970
efficient and why I'm

00:30:07,260 --> 00:30:10,970
just talking efficiency at the moment

00:30:13,430 --> 00:30:17,790
okay I'm just letting some people read

00:30:16,680 --> 00:30:19,740
the code just for the record because

00:30:17,790 --> 00:30:35,160
actually see eyes looking up at the

00:30:19,740 --> 00:30:36,720
screen B and D so because int is a

00:30:35,160 --> 00:30:38,850
trivial type they're all going to boil

00:30:36,720 --> 00:30:43,980
down to the exact same assembly this is

00:30:38,850 --> 00:30:45,320
what the answer is I just got and I am

00:30:43,980 --> 00:30:47,820
going to agree with that statement

00:30:45,320 --> 00:30:50,850
they're trivially copyable trivia

00:30:47,820 --> 00:30:54,170
movable is it a copy is it a move does

00:30:50,850 --> 00:30:56,880
it have to whatever it doesn't matter

00:30:54,170 --> 00:31:01,110
they're all gonna fit in a register easy

00:30:56,880 --> 00:31:03,000
on any platform no oh no they wouldn't

00:31:01,110 --> 00:31:06,390
fit in a single register and an AVR when

00:31:03,000 --> 00:31:14,250
they because into 16 bits it's an 8 bit

00:31:06,390 --> 00:31:15,780
I think that's it has to be efficient

00:31:14,250 --> 00:31:20,220
yeah

00:31:15,780 --> 00:31:21,660
Oh int you're saying yes yeah int has to

00:31:20,220 --> 00:31:24,420
be efficient although it has to be at

00:31:21,660 --> 00:31:25,860
least 16 bits I believe I think that's

00:31:24,420 --> 00:31:27,360
right so on maybe platform it's so

00:31:25,860 --> 00:31:31,650
inefficient a single register

00:31:27,360 --> 00:31:34,080
necessarily so yeah like int is the

00:31:31,650 --> 00:31:39,750
efficient word size of the system except

00:31:34,080 --> 00:31:40,740
when it's not or something I so returned

00:31:39,750 --> 00:31:42,840
by by you

00:31:40,740 --> 00:31:46,770
I say irrelevant and distribu Lee

00:31:42,840 --> 00:31:51,210
copyable and movable what happens if I

00:31:46,770 --> 00:31:54,680
disable optimizations on this code what

00:31:51,210 --> 00:31:54,680
happens I build this with a zero ooh

00:31:58,280 --> 00:32:06,680
okay well I've heard the speakers in the

00:32:02,610 --> 00:32:06,680
past I might yes what are you gonna say

00:32:08,930 --> 00:32:13,530
yeah okay

00:32:10,980 --> 00:32:15,420
so for the sake of you who couldn't hear

00:32:13,530 --> 00:32:15,960
that let's just go ahead and compile

00:32:15,420 --> 00:32:19,890
this

00:32:15,960 --> 00:32:20,659
this compiles to move by ax comma 5

00:32:19,890 --> 00:32:22,879
we're moving

00:32:20,659 --> 00:32:25,789
five into the register ax this is the

00:32:22,879 --> 00:32:31,820
return value from the function returning

00:32:25,789 --> 00:32:34,970
an integer on Intel platform okay I'm

00:32:31,820 --> 00:32:39,320
going to disable optimizations here of

00:32:34,970 --> 00:32:42,440
zero the code still had to the compiler

00:32:39,320 --> 00:32:46,279
still had to actually generate a call to

00:32:42,440 --> 00:32:49,759
standard move it had to we told it to we

00:32:46,279 --> 00:32:57,499
called function all right so let's go

00:32:49,759 --> 00:32:59,210
ahead and take out move and it becomes

00:32:57,499 --> 00:33:01,669
more what we would expect a little bit

00:32:59,210 --> 00:33:07,039
of stack handling and then move five and

00:33:01,669 --> 00:33:10,700
Dax basically so it's not a hundred

00:33:07,039 --> 00:33:13,580
percent the same depending on what build

00:33:10,700 --> 00:33:17,499
level we're using now that's what I just

00:33:13,580 --> 00:33:17,499
did okay

00:33:18,200 --> 00:33:25,099
I am using my structured bindings with

00:33:22,369 --> 00:33:37,879
my integer pairs now instead of string

00:33:25,099 --> 00:33:42,320
pairs what house my pair implemented I'm

00:33:37,879 --> 00:33:44,690
assuming it stood pair okay all right so

00:33:42,320 --> 00:33:48,440
I mean based off of what we just learned

00:33:44,690 --> 00:33:50,179
who says what I don't know how do I even

00:33:48,440 --> 00:33:52,429
do this because at this point we're

00:33:50,179 --> 00:34:03,769
assuming multiple answers are correct

00:33:52,429 --> 00:34:07,879
right probably B and D I know I fixed

00:34:03,769 --> 00:34:11,240
those slides I fixed them during tone

00:34:07,879 --> 00:34:14,419
even yards talk I must not have reloaded

00:34:11,240 --> 00:34:19,039
at my presentation now I'm gonna risk

00:34:14,419 --> 00:34:22,159
doing this let's see I must have missed

00:34:19,039 --> 00:34:24,230
a couple of cases I'm sorry okay

00:34:22,159 --> 00:34:26,240
let's assume they compile all right

00:34:24,230 --> 00:34:32,869
we're returning into one I can't easily

00:34:26,240 --> 00:34:34,669
edit it right here live okay so a and C

00:34:32,869 --> 00:34:35,899
and a debug build

00:34:34,669 --> 00:34:38,859
are going to generate these calls to

00:34:35,899 --> 00:34:44,720
move probably no way around that

00:34:38,859 --> 00:34:47,419
B and D copying some bits around they're

00:34:44,720 --> 00:34:51,799
going to be the same in an optimized

00:34:47,419 --> 00:34:53,210
build they're all the same now I start

00:34:51,799 --> 00:34:55,399
putting an Asterix here

00:34:53,210 --> 00:35:01,369
irrelevant Asterix we'll come back to

00:34:55,399 --> 00:35:05,240
that asterisks in a moment passed by

00:35:01,369 --> 00:35:11,589
value vs. passed by move oh man

00:35:05,240 --> 00:35:11,589
C doesn't compile - dagnabbit

00:35:21,099 --> 00:35:26,859
somebody reboot Jason no I did not just

00:35:23,750 --> 00:35:29,809
crash I was just staring at the code

00:35:26,859 --> 00:35:31,819
it's probably non-obvious to the YouTube

00:35:29,809 --> 00:35:33,740
viewers on camera there's a monitor

00:35:31,819 --> 00:35:36,140
right here that I can see the slides on

00:35:33,740 --> 00:35:41,210
I had not just like shut down I was

00:35:36,140 --> 00:35:44,690
staring at the monitor okay

00:35:41,210 --> 00:35:47,480
alright so we're passing these things by

00:35:44,690 --> 00:35:49,760
move or by value now to make a point

00:35:47,480 --> 00:35:55,250
that Marshall I believe brought up

00:35:49,760 --> 00:35:57,290
earlier with the string a and B will you

00:35:55,250 --> 00:36:00,680
know a will compile if you sent as

00:35:57,290 --> 00:36:02,900
expecting an endurance but if it's

00:36:00,680 --> 00:36:04,790
expecting an nth by copy or Const

00:36:02,900 --> 00:36:07,160
reference these are just going to be the

00:36:04,790 --> 00:36:16,460
same thing again right it doesn't matter

00:36:07,160 --> 00:36:18,319
now yeah and a debug build a would

00:36:16,460 --> 00:36:22,609
create a local variable where C would

00:36:18,319 --> 00:36:24,829
not it still has to create local stack

00:36:22,609 --> 00:36:29,980
space for it in either case in a debug

00:36:24,829 --> 00:36:33,910
build so if we want to go down this road

00:36:29,980 --> 00:36:40,309
let's forward declare the function and

00:36:33,910 --> 00:36:42,980
that's the there okay so I set up space

00:36:40,309 --> 00:36:47,450
for it I saved the value 5 here on the

00:36:42,980 --> 00:36:48,290
stack passed that in all right and we're

00:36:47,450 --> 00:36:55,040
comparing that

00:36:48,290 --> 00:36:57,050
to this version okay yeah

00:36:55,040 --> 00:36:59,060
I have other examples that will come

00:36:57,050 --> 00:37:01,930
back to similar but I didn't see that

00:36:59,060 --> 00:37:01,930
particular issue

00:37:02,350 --> 00:37:11,060
okay so again irrelevant asterisks and

00:37:06,730 --> 00:37:14,120
is trivially copyable and moveable out

00:37:11,060 --> 00:37:15,710
parameter versus return value that's

00:37:14,120 --> 00:37:16,820
when I was just having fun with and I

00:37:15,710 --> 00:37:18,590
really hope I have the correct version

00:37:16,820 --> 00:37:34,910
of my slides up right now and if I don't

00:37:18,590 --> 00:37:37,630
now I'm going to fix it I know I changed

00:37:34,910 --> 00:37:37,630
wait a minute

00:37:39,040 --> 00:37:42,950
all right well whatever I have is what I

00:37:41,600 --> 00:37:46,210
have now I know I build the latest

00:37:42,950 --> 00:37:46,210
version okay

00:37:47,440 --> 00:37:57,880
pots I know the next slide said wrote

00:37:53,030 --> 00:37:57,880
largely irrelevant again but so we're

00:37:58,030 --> 00:38:04,310
well okay let's come back to it let's go

00:38:01,280 --> 00:38:06,170
no all right stop we'll stay here I have

00:38:04,310 --> 00:38:10,850
I have a clearly well-defined plan at

00:38:06,170 --> 00:38:14,870
the moment right how many parameters do

00:38:10,850 --> 00:38:27,790
these functions take they all take one

00:38:14,870 --> 00:38:31,340
parameter is that fair no yes so because

00:38:27,790 --> 00:38:34,070
because this int actually fits in the

00:38:31,340 --> 00:38:36,560
EAX register here I

00:38:34,070 --> 00:38:39,920
we actually are not going to get that

00:38:36,560 --> 00:38:43,310
set up of the stack space for our di and

00:38:39,920 --> 00:38:45,460
in these cases here so I guess they

00:38:43,310 --> 00:38:48,260
don't all take one parameter with an int

00:38:45,460 --> 00:38:50,120
hmm so that slide makes that incorrect

00:38:48,260 --> 00:38:52,340
memory address the result but the result

00:38:50,120 --> 00:38:55,160
has to be dealt with regardless all

00:38:52,340 --> 00:38:58,940
right now I want to ask this does this

00:38:55,160 --> 00:39:01,760
change anything so I'm looking at that

00:38:58,940 --> 00:39:02,150
the fact that I added these braces what

00:39:01,760 --> 00:39:06,380
am I

00:39:02,150 --> 00:39:09,019
now to this value embel you initialize

00:39:06,380 --> 00:39:11,240
it I am giving it a value without those

00:39:09,019 --> 00:39:12,950
braces it's a trivial operation it's

00:39:11,240 --> 00:39:14,809
going to do nothing with those braces

00:39:12,950 --> 00:39:18,349
that has to initialize it before it

00:39:14,809 --> 00:39:19,700
passes it to the function and this is

00:39:18,349 --> 00:39:25,190
the slide that I know that I added

00:39:19,700 --> 00:39:27,710
earlier that I hope hey it did work okay

00:39:25,190 --> 00:39:30,200
good all right this looked more and more

00:39:27,710 --> 00:39:35,890
suspicious to me as I was preparing for

00:39:30,200 --> 00:39:38,210
this talk does this code bother anyone

00:39:35,890 --> 00:39:44,990
okay give me reasons are we going back

00:39:38,210 --> 00:39:46,609
here Matt - there are my passing and

00:39:44,990 --> 00:39:49,970
undefined value is that supposed to be a

00:39:46,609 --> 00:39:52,069
reference to capture so yeah let's take

00:39:49,970 --> 00:40:03,249
my hypothetical implementation of get

00:39:52,069 --> 00:40:03,249
value what is the value of s on line

00:40:03,670 --> 00:40:12,650
1042 junk was the other answers

00:40:07,900 --> 00:40:16,700
undefined nasal demons that sounds

00:40:12,650 --> 00:40:17,930
really bad you know I've heard that term

00:40:16,700 --> 00:40:22,420
over and over again I don't know who

00:40:17,930 --> 00:40:25,849
coined it what's it nuclear launch codes

00:40:22,420 --> 00:40:28,099
yes we don't know right worse than we

00:40:25,849 --> 00:40:30,650
don't know we are invoking undefined

00:40:28,099 --> 00:40:40,309
behavior specifically by accessing them

00:40:30,650 --> 00:40:42,259
an uninitialized value that's bad so our

00:40:40,309 --> 00:40:45,079
parameters open the door for undefined

00:40:42,259 --> 00:40:46,430
behavior that's stronger wording than

00:40:45,079 --> 00:40:51,170
I've ever used before about out

00:40:46,430 --> 00:40:55,239
parameters I like it though all right so

00:40:51,170 --> 00:40:55,239
assignment versus initialization

00:40:55,930 --> 00:41:02,660
optimized build let's say even

00:40:58,400 --> 00:41:04,910
unoptimized builds in these cases little

00:41:02,660 --> 00:41:08,960
bit extra work in the unoptimized build

00:41:04,910 --> 00:41:10,369
version nope no I don't see actually in

00:41:08,960 --> 00:41:12,650
an optimized build version there's any

00:41:10,369 --> 00:41:14,070
extra work anywhere is there are these

00:41:12,650 --> 00:41:16,530
all exactly the same

00:41:14,070 --> 00:41:17,880
lissa build type yeah I think they are

00:41:16,530 --> 00:41:19,590
I'm getting nods over here I'm gonna

00:41:17,880 --> 00:41:23,610
agree with them all right

00:41:19,590 --> 00:41:26,160
power of true be a lady and I still have

00:41:23,610 --> 00:41:27,830
my asterisks then tis trivially default

00:41:26,160 --> 00:41:35,970
constructible and trivially assignable

00:41:27,830 --> 00:41:39,570
does this change things yes but when in

00:41:35,970 --> 00:41:41,100
a debug build and an optimized build the

00:41:39,570 --> 00:41:42,900
compilers gonna optimize the way this

00:41:41,100 --> 00:41:45,060
dead store I think I used those two

00:41:42,900 --> 00:41:47,310
words correctly that's the right to the

00:41:45,060 --> 00:41:49,530
memory location online for that was

00:41:47,310 --> 00:41:50,970
never read from again so it will then

00:41:49,530 --> 00:41:53,880
just write in the same memory location

00:41:50,970 --> 00:41:55,500
to get on line five well actually it'll

00:41:53,880 --> 00:41:57,120
just completely optimize away s

00:41:55,500 --> 00:42:01,890
altogether and optimize build in this

00:41:57,120 --> 00:42:06,620
case value reassignment does it matter

00:42:01,890 --> 00:42:09,300
Richard no it doesn't matter because

00:42:06,620 --> 00:42:11,690
answer trivially copyable trivially

00:42:09,300 --> 00:42:13,490
assignable trivially destructible

00:42:11,690 --> 00:42:16,710
alright

00:42:13,490 --> 00:42:19,320
the asterisks with the optimizer

00:42:16,710 --> 00:42:21,000
disabled we still have to deal with

00:42:19,320 --> 00:42:23,190
these things setting up stack space

00:42:21,000 --> 00:42:25,800
initializing value is calling standard

00:42:23,190 --> 00:42:28,200
move even when the types are trivial so

00:42:25,800 --> 00:42:41,150
our best practice options are still the

00:42:28,200 --> 00:42:44,670
best options okay is a rage review I I

00:42:41,150 --> 00:42:50,430
got lots of it depends answers oh let's

00:42:44,670 --> 00:42:51,020
do yes it is trivial okay no it is not

00:42:50,430 --> 00:42:55,170
trivial

00:42:51,020 --> 00:42:59,430
it depends okay what does it depend on

00:42:55,170 --> 00:43:01,440
the type whether or not the type

00:42:59,430 --> 00:43:03,060
contained is trivial it's guaranteed to

00:43:01,440 --> 00:43:08,640
be trivial if the type contained is

00:43:03,060 --> 00:43:14,550
trivial so I was playing with this now

00:43:08,640 --> 00:43:21,000
if you were here on Tuesday and my C++

00:43:14,550 --> 00:43:23,760
code smells I was not very happy with

00:43:21,000 --> 00:43:25,140
the second option they get s bad I'm not

00:43:23,760 --> 00:43:26,970
even going to ask you which one is

00:43:25,140 --> 00:43:27,470
supposed to be good or bad because I am

00:43:26,970 --> 00:43:29,780
good at

00:43:27,470 --> 00:43:32,090
aiming and you can tell which one's

00:43:29,780 --> 00:43:35,300
supposed to be good or bad now on the

00:43:32,090 --> 00:43:37,520
second example on get us bad if these

00:43:35,300 --> 00:43:41,960
were not trivial types I have to

00:43:37,520 --> 00:43:44,720
construct them both I have to move out

00:43:41,960 --> 00:43:47,390
or copy out the correct parameter or the

00:43:44,720 --> 00:43:51,859
correct return value and then I have to

00:43:47,390 --> 00:43:54,170
destroy whatever was left over and on

00:43:51,859 --> 00:43:57,320
the good one quote good one

00:43:54,170 --> 00:44:01,340
I get the efficiency of just doing

00:43:57,320 --> 00:44:04,700
return value optimization right so I

00:44:01,340 --> 00:44:08,560
don't have this setup as good as it

00:44:04,700 --> 00:44:12,080
could be setup but in an optimized build

00:44:08,560 --> 00:44:15,380
these two versions compile to the exact

00:44:12,080 --> 00:44:17,960
same thing it does a branch to test

00:44:15,380 --> 00:44:20,950
which whether or not we passed in true

00:44:17,960 --> 00:44:24,349
or false here and then it returns either

00:44:20,950 --> 00:44:26,720
set of values and in the quote bad

00:44:24,349 --> 00:44:28,790
version it does the test and then it

00:44:26,720 --> 00:44:30,710
returns one of the two efficient values

00:44:28,790 --> 00:44:41,800
there's no lifetime for it to have to

00:44:30,710 --> 00:44:41,800
worry about can everything be trivial

00:44:45,430 --> 00:44:56,510
what can't be trivial polymorphic

00:44:50,600 --> 00:45:03,740
objects okay heap at the moment anyhow

00:44:56,510 --> 00:45:04,970
right yeah are any Rai guide so

00:45:03,740 --> 00:45:17,740
basically anything with the destructor

00:45:04,970 --> 00:45:19,760
can't be trivial any manager oo based

00:45:17,740 --> 00:45:21,500
derivation anything that's managing

00:45:19,760 --> 00:45:25,640
resources or dealing and runtime

00:45:21,500 --> 00:45:28,880
polymorphism effectively they can't be

00:45:25,640 --> 00:45:30,590
fully trivial anything that's dealing

00:45:28,880 --> 00:45:34,400
with resources definitely can't be

00:45:30,590 --> 00:45:36,080
trivially destructible right because

00:45:34,400 --> 00:45:46,100
that's silly because that's what

00:45:36,080 --> 00:45:50,360
destructor czar for okay not everything

00:45:46,100 --> 00:45:54,530
obviously can be trivial I do want to

00:45:50,360 --> 00:45:57,490
point out though that most things can be

00:45:54,530 --> 00:46:01,190
made trivial and I mean just or at least

00:45:57,490 --> 00:46:06,380
trivially destructible and that is where

00:46:01,190 --> 00:46:08,420
most of this power comes in just for the

00:46:06,380 --> 00:46:11,840
record I mean I've implemented an arm

00:46:08,420 --> 00:46:13,880
emulator that is constant spar and some

00:46:11,840 --> 00:46:15,890
of you may have seen that project so I

00:46:13,880 --> 00:46:18,080
have effectively proven that you can do

00:46:15,890 --> 00:46:20,360
anything at compile time because I can

00:46:18,080 --> 00:46:24,290
execute arbitrary arm code at compile

00:46:20,360 --> 00:46:28,610
time right so QED or something because

00:46:24,290 --> 00:46:30,350
I'm like a mathy person so I've got a

00:46:28,610 --> 00:46:32,990
container the value type and a fixed

00:46:30,350 --> 00:46:36,350
capacity I can make the underlying data

00:46:32,990 --> 00:46:38,330
storage an array that has a value type

00:46:36,350 --> 00:46:43,340
in a capacity now this value type is an

00:46:38,330 --> 00:46:45,320
integer my container is trivial tribute

00:46:43,340 --> 00:46:47,450
destructible trivially constructible I

00:46:45,320 --> 00:46:49,160
said the current size here and I have to

00:46:47,450 --> 00:46:50,150
default the size to zero because now

00:46:49,160 --> 00:46:52,480
we're going to start modifying this

00:46:50,150 --> 00:46:55,610
thing it's now low long or trivially

00:46:52,480 --> 00:46:58,309
constructible but it should be trivially

00:46:55,610 --> 00:47:00,499
a sign away to

00:46:58,309 --> 00:47:04,430
rage reveal the assignable it should be

00:47:00,499 --> 00:47:07,420
yeah yeah okay yeah so it should be

00:47:04,430 --> 00:47:09,799
trivially assignable trivially copyable

00:47:07,420 --> 00:47:11,569
trivially not tribute liek constructible

00:47:09,799 --> 00:47:14,119
but still trivially destructible and

00:47:11,569 --> 00:47:16,309
then I can add a pushback function which

00:47:14,119 --> 00:47:18,769
we can see can be constant for here and

00:47:16,309 --> 00:47:29,749
I can just increment the size and add

00:47:18,769 --> 00:47:31,489
the new value in so okay they're the I'm

00:47:29,749 --> 00:47:32,509
not doing any balance checking at the

00:47:31,489 --> 00:47:33,829
moment but then again the standard

00:47:32,509 --> 00:47:39,949
library doesn't really do bounds

00:47:33,829 --> 00:47:44,420
checking yeah so it's good right yes

00:47:39,949 --> 00:47:45,920
Marshall stood earache does not add

00:47:44,420 --> 00:47:47,390
stood iterate doesn't have a default

00:47:45,920 --> 00:47:51,559
constructor iterator has zero

00:47:47,390 --> 00:47:53,660
constructors yes that is it is a work of

00:47:51,559 --> 00:47:55,549
art once you realize that standard array

00:47:53,660 --> 00:47:57,140
has no constructors at all it makes me

00:47:55,549 --> 00:47:59,269
happy

00:47:57,140 --> 00:48:00,529
it's and basically we're not allowed to

00:47:59,269 --> 00:48:01,789
do the same thing they do because

00:48:00,529 --> 00:48:03,410
they're in a storage starts with

00:48:01,789 --> 00:48:08,239
underscores and we're not allowed to see

00:48:03,410 --> 00:48:11,209
or touch the underscores yeah so this

00:48:08,239 --> 00:48:13,369
can be this it's trivially not trivially

00:48:11,209 --> 00:48:14,959
constructible because of our size but

00:48:13,369 --> 00:48:16,459
the array is not going to stop that

00:48:14,959 --> 00:48:17,689
because arrays constructor is going to

00:48:16,459 --> 00:48:19,449
do nothing if there's an ax Jers it's

00:48:17,689 --> 00:48:23,769
gonna be filled with garbage

00:48:19,449 --> 00:48:26,959
the issue is bounds checking okay so if

00:48:23,769 --> 00:48:29,089
we can throw a logic error in here or

00:48:26,959 --> 00:48:31,279
something we can throw an exception we

00:48:29,089 --> 00:48:33,289
can do bounds checking even in a context

00:48:31,279 --> 00:48:36,170
for function just as long as that branch

00:48:33,289 --> 00:48:38,059
is not invoked at compile time if it is

00:48:36,170 --> 00:48:39,529
then we at a compile time error which

00:48:38,059 --> 00:48:41,359
makes sense because we just went past

00:48:39,529 --> 00:48:43,249
the end of our container at compile time

00:48:41,359 --> 00:48:47,170
so it sounds like compile time error to

00:48:43,249 --> 00:48:49,640
me and then we could do things like

00:48:47,170 --> 00:48:52,099
assert that the contained type is

00:48:49,640 --> 00:48:54,529
trivial if we really wanted to like push

00:48:52,099 --> 00:48:56,199
things here although that seems that's

00:48:54,529 --> 00:48:58,369
maybe a bit heavy-handed

00:48:56,199 --> 00:48:59,869
maybe if we really want to do that we

00:48:58,369 --> 00:49:02,689
could just assert that it's trivially

00:48:59,869 --> 00:49:05,029
destructible and trivially assignable or

00:49:02,689 --> 00:49:06,650
something if we wanted to to limit the

00:49:05,029 --> 00:49:08,799
users of this type but we don't have to

00:49:06,650 --> 00:49:08,799
either

00:49:11,950 --> 00:49:18,770
it know so the comment was it has to be

00:49:16,730 --> 00:49:20,870
trivially default constructible for a

00:49:18,770 --> 00:49:22,940
ray for a ray to be trivially default

00:49:20,870 --> 00:49:25,520
constructible yes so if we made this an

00:49:22,940 --> 00:49:29,660
array of strings which I actually did

00:49:25,520 --> 00:49:31,550
mean to get to then then this is no

00:49:29,660 --> 00:49:34,730
longer tribute Lida struck table and

00:49:31,550 --> 00:49:36,470
we're going to initialize all of the

00:49:34,730 --> 00:49:37,760
strings in there if we had ten strings

00:49:36,470 --> 00:49:39,380
they're all going to be empty strings

00:49:37,760 --> 00:49:41,920
it's going to create those objects like

00:49:39,380 --> 00:49:41,920
it's supposed to

00:49:44,060 --> 00:49:49,220
yeah and then I can I can use this and

00:49:46,310 --> 00:49:51,290
if you really want to like I think I

00:49:49,220 --> 00:49:54,290
created an array of a thousand of them

00:49:51,290 --> 00:49:56,270
just to point out that like because

00:49:54,290 --> 00:49:58,340
they're int it's not like it really has

00:49:56,270 --> 00:49:59,780
to deal with all thousand it just has to

00:49:58,340 --> 00:50:02,060
put a little bit of code for that

00:49:59,780 --> 00:50:04,520
exception handler in here and then the

00:50:02,060 --> 00:50:05,810
actual code being executed for adding

00:50:04,520 --> 00:50:07,760
those values back is pretty

00:50:05,810 --> 00:50:11,080
straightforward like this does nothing

00:50:07,760 --> 00:50:13,670
of any consequence

00:50:11,080 --> 00:50:19,550
comparing to vector what happens when I

00:50:13,670 --> 00:50:20,540
do pushback of one on vector allocate so

00:50:19,550 --> 00:50:24,920
what happens when I do the second

00:50:20,540 --> 00:50:27,020
pushback it's probably going to allocate

00:50:24,920 --> 00:50:29,060
and copy those values in and I'll

00:50:27,020 --> 00:50:31,070
probably have a vector of size two or

00:50:29,060 --> 00:50:35,870
capacity to what happens if I do another

00:50:31,070 --> 00:50:37,340
pushback another allocate and other copy

00:50:35,870 --> 00:50:40,130
and now I'm gonna have a vector of

00:50:37,340 --> 00:50:41,630
capacity for depending write like I'm

00:50:40,130 --> 00:50:43,730
looking at standard library implementer

00:50:41,630 --> 00:50:48,800
right in front of me here something like

00:50:43,730 --> 00:50:51,140
that though basic string basic string I

00:50:48,800 --> 00:50:56,930
wanted to mention because actually as

00:50:51,140 --> 00:50:58,820
Brian in the room no okay basic string

00:50:56,930 --> 00:51:00,350
is interesting because it is the only

00:50:58,820 --> 00:51:02,960
container in the standard library that

00:51:00,350 --> 00:51:07,190
requires that the contained types be

00:51:02,960 --> 00:51:10,070
trivial so you can use basic string and

00:51:07,190 --> 00:51:12,890
it's going to use small string

00:51:10,070 --> 00:51:16,610
optimization for a piece of this but not

00:51:12,890 --> 00:51:17,320
I'm not gonna walk through all that not

00:51:16,610 --> 00:51:19,940
for all of it

00:51:17,320 --> 00:51:22,820
okay so bringing us around to the rule

00:51:19,940 --> 00:51:24,040
of zero rule of zero says never define

00:51:22,820 --> 00:51:26,920
any of the special number

00:51:24,040 --> 00:51:28,810
functions with class initializers this

00:51:26,920 --> 00:51:29,260
can include the default constructor as

00:51:28,810 --> 00:51:32,020
well

00:51:29,260 --> 00:51:33,970
this likely results in less code and

00:51:32,020 --> 00:51:36,880
smaller more efficient compiled code

00:51:33,970 --> 00:51:38,980
we're giving the compiler a lot of room

00:51:36,880 --> 00:51:43,230
to optimize when we're not defining

00:51:38,980 --> 00:51:45,790
these special members so it is trivial

00:51:43,230 --> 00:51:47,830
being trivially destructible and tribute

00:51:45,790 --> 00:51:49,120
leak copyable are probably the best

00:51:47,830 --> 00:51:52,510
things that you can do to write

00:51:49,120 --> 00:51:54,760
optimizable code trivial default

00:51:52,510 --> 00:51:55,810
constricted constructability is not

00:51:54,760 --> 00:51:59,800
really our concern

00:51:55,810 --> 00:52:02,440
we like initialized values we like not

00:51:59,800 --> 00:52:06,430
invoking undefined behavior by reading

00:52:02,440 --> 00:52:07,500
uninitialized values probably and it

00:52:06,430 --> 00:52:13,150
doesn't affect our other operations

00:52:07,500 --> 00:52:15,070
follow the road zero and triviality or

00:52:13,150 --> 00:52:16,690
understanding triviality is one of the

00:52:15,070 --> 00:52:19,270
main keys for writing code that is

00:52:16,690 --> 00:52:21,370
constant or friendly I just threw in one

00:52:19,270 --> 00:52:22,690
little context for keyword in there in

00:52:21,370 --> 00:52:24,490
case you didn't realize that is a

00:52:22,690 --> 00:52:25,960
context per container I mean you can

00:52:24,490 --> 00:52:27,940
just create one of those and use it at

00:52:25,960 --> 00:52:29,770
compile time and grow it and access the

00:52:27,940 --> 00:52:31,870
members of it it doesn't take much work

00:52:29,770 --> 00:52:36,220
to add the rest of the members that you

00:52:31,870 --> 00:52:38,500
need so that is me we're just about I

00:52:36,220 --> 00:52:40,260
mean I'm done when we have like five

00:52:38,500 --> 00:52:42,310
minutes left if anyone has any questions

00:52:40,260 --> 00:52:44,470
either yell them out or go to a

00:52:42,310 --> 00:52:49,600
microphone or I'll run around any

00:52:44,470 --> 00:53:01,510
questions end of the day on Friday huh

00:52:49,600 --> 00:53:04,300
oh yes a stood array of non-trivial type

00:53:01,510 --> 00:53:06,040
that's a length zero now I believe if

00:53:04,300 --> 00:53:07,690
your standard library will prevent you

00:53:06,040 --> 00:53:12,730
from creating a stood array of length

00:53:07,690 --> 00:53:14,680
zero because an array of length zero is

00:53:12,730 --> 00:53:16,480
a non-standard extension to the language

00:53:14,680 --> 00:53:18,720
that many compilers implement but it's

00:53:16,480 --> 00:53:21,430
not technically allowed because of

00:53:18,720 --> 00:53:23,470
address rules each object must have its

00:53:21,430 --> 00:53:24,760
own location in memory if you have two

00:53:23,470 --> 00:53:26,530
arrays of lingzi or side by side they'd

00:53:24,760 --> 00:53:28,620
have the same address not allowed to do

00:53:26,530 --> 00:53:34,140
that yes

00:53:28,620 --> 00:53:34,140
though the mics not even on this yell

00:53:39,480 --> 00:53:52,330
okay so small vector you're saying may

00:53:41,920 --> 00:53:53,740
be standardized and I a fixed capacity

00:53:52,330 --> 00:53:57,090
vector called small vector and I think

00:53:53,740 --> 00:54:12,540
boost static vectors of similar notion

00:53:57,090 --> 00:54:15,550
okay yes no no yes so this is not

00:54:12,540 --> 00:54:19,000
trivially default constructible because

00:54:15,550 --> 00:54:20,710
of the initialization of zero that's

00:54:19,000 --> 00:54:22,120
what I tried to say but I may have

00:54:20,710 --> 00:54:28,380
gotten lost in the double negative

00:54:22,120 --> 00:54:30,910
somewhere the data member is maybe

00:54:28,380 --> 00:54:39,880
trivially default constructible but the

00:54:30,910 --> 00:54:41,950
size member is not yes no so this is not

00:54:39,880 --> 00:54:44,020
going to be fully is trivial it's going

00:54:41,950 --> 00:54:45,730
to be potentially trivially default

00:54:44,020 --> 00:54:46,360
constructible assignable movable

00:54:45,730 --> 00:54:48,970
copyable

00:54:46,360 --> 00:54:50,690
all the things that really matter all

00:54:48,970 --> 00:54:53,949
right thank you everyone

00:54:50,690 --> 00:54:53,949

YouTube URL: https://www.youtube.com/watch?v=ZxWjii99yao


