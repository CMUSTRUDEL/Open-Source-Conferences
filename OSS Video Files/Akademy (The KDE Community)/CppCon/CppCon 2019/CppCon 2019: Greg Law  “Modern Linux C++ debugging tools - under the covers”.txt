Title: CppCon 2019: Greg Law  “Modern Linux C++ debugging tools - under the covers”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
An overview of how some of the seemingly-magical modern Linux C++ tools actually work, so that you can get the most from them. C++ is a language and ecosystem that is unashamedly close to the metal, and to be an expert practitioner an understanding of compiler and OS fundamentals is essential, as is the case for debugging and profiling tools. The last decade has seen a ‘Cambrian explosion’ in tooling: Valgrind, perf, Address Sanitizer, rr, Live Recorder, Coverity and cppcheck have either arrived or become mainstream and even good-old GDB has come a long way. Greg gives an overview of how these amazing/magical tools are implemented, often exploiting a combination of compiler, OS and CPU features. Contains multiple demos and details on ptrace, DWARF debug info, how static analyzers work, record and replay systems - to help you to select the right tool for the job and then get the most out of it.
— 
Greg Law
Undo
CTO
Cambridge, UK

Greg is co-founder and CEO at Undo. He is a programmer at heart, but likes to keep one foot in the software world and one in the business world. Greg finds it particularly rewarding to turn innovative software technology into real business development. Greg has over 20 years of experience in both academia and innovative start-up software companies.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,330 --> 00:00:15,199
alright so we walk that second we

00:00:12,099 --> 00:00:16,910
alright should we get going so thanks

00:00:15,199 --> 00:00:20,060
for coming everyone I'm Greg I am

00:00:16,910 --> 00:00:21,529
co-founder and CTO at undo I'm going to

00:00:20,060 --> 00:00:23,989
be talking today with durang who's

00:00:21,529 --> 00:00:26,300
Solutions Architect with it's an obvious

00:00:23,989 --> 00:00:29,779
working on Coverity and we're going to

00:00:26,300 --> 00:00:33,020
talk about some of the some of the under

00:00:29,779 --> 00:00:35,360
the covers on advanced decks C++

00:00:33,020 --> 00:00:36,649
debugging tools and so I'm gonna go

00:00:35,360 --> 00:00:37,969
first to talk about some of the stuff

00:00:36,649 --> 00:00:39,500
that I know about and then doing is

00:00:37,969 --> 00:00:41,810
going to talk about what he knows about

00:00:39,500 --> 00:00:47,149
maybe come away from that ago less a

00:00:41,810 --> 00:00:48,770
curry is it just meet the terrible echo

00:00:47,149 --> 00:00:52,910
can everyone else hear the echo is it

00:00:48,770 --> 00:00:55,420
just me yeah is it a both mics on maybe

00:00:52,910 --> 00:00:57,649
is there anything we can do about that

00:00:55,420 --> 00:01:00,230
it's just the room alright just the way

00:00:57,649 --> 00:01:04,820
it is okay my friend get our try and get

00:01:00,230 --> 00:01:07,250
it past it okay so I think debugging is

00:01:04,820 --> 00:01:09,320
our dirty secret as programmers right

00:01:07,250 --> 00:01:11,659
most programmers spend most of their

00:01:09,320 --> 00:01:13,219
time finding and fixing bugs and if you

00:01:11,659 --> 00:01:16,039
dispute that just think like how often

00:01:13,219 --> 00:01:19,759
does it work first time my roots done

00:01:16,039 --> 00:01:21,139
I'd like to fancy myself as Earth say

00:01:19,759 --> 00:01:23,359
better to be honest better than average

00:01:21,139 --> 00:01:25,039
programmer what's the longest program I

00:01:23,359 --> 00:01:27,469
can write and it'd be completely and

00:01:25,039 --> 00:01:30,649
it'd be correct straight up the bat ten

00:01:27,469 --> 00:01:32,779
lines 30 maybe I'm if I'm really careful

00:01:30,649 --> 00:01:34,459
and pushing it and that's if it's a new

00:01:32,779 --> 00:01:36,679
program if I'm changing an existing

00:01:34,459 --> 00:01:39,469
program this thing complex piece of code

00:01:36,679 --> 00:01:41,450
then that number is I think depressingly

00:01:39,469 --> 00:01:45,560
close to zero lines of code will be

00:01:41,450 --> 00:01:47,060
written without without a bug right and

00:01:45,560 --> 00:01:48,770
it's really a whole process is just

00:01:47,060 --> 00:01:50,990
trying to understand what happened right

00:01:48,770 --> 00:01:52,520
my program did something different from

00:01:50,990 --> 00:01:57,200
what I was exploring I was expecting it

00:01:52,520 --> 00:02:01,429
to do now if you're a C++ programmer as

00:01:57,200 --> 00:02:03,289
I'm guess most of us here are then you

00:02:01,429 --> 00:02:05,060
you've deliberately chosen the language

00:02:03,289 --> 00:02:07,340
that's like very close to the metal

00:02:05,060 --> 00:02:09,619
right you must have a reason for

00:02:07,340 --> 00:02:11,690
choosing C++ over something higher-level

00:02:09,619 --> 00:02:12,530
hopefully that's a better reason than it

00:02:11,690 --> 00:02:14,480
makes you feel clever

00:02:12,530 --> 00:02:16,160
usually it's like performance or

00:02:14,480 --> 00:02:18,140
something but you're deliberately close

00:02:16,160 --> 00:02:19,100
to the metal and you kind of need to

00:02:18,140 --> 00:02:21,050
know what's going on and when you're

00:02:19,100 --> 00:02:21,920
debugging these systems you need to know

00:02:21,050 --> 00:02:23,240
what's going on

00:02:21,920 --> 00:02:24,680
you need to use the tools that are

00:02:23,240 --> 00:02:27,410
available right I think that's really

00:02:24,680 --> 00:02:29,510
you can't be a really good programmer if

00:02:27,410 --> 00:02:30,830
you're not very good at debugging and

00:02:29,510 --> 00:02:32,870
that means you have to use the tools

00:02:30,830 --> 00:02:34,280
that are available but you kind of

00:02:32,870 --> 00:02:36,470
really need to know what the tools are

00:02:34,280 --> 00:02:38,630
doing as well because when you know when

00:02:36,470 --> 00:02:43,520
life gets really fun when you get that

00:02:38,630 --> 00:02:45,110
kind of delicious mystery of like the

00:02:43,520 --> 00:02:45,530
thing I'm observing can't possibly

00:02:45,110 --> 00:02:47,900
happen

00:02:45,530 --> 00:02:49,910
everything is just I cannot have a model

00:02:47,900 --> 00:02:52,489
for what the hell is going on here and

00:02:49,910 --> 00:02:54,110
then if the tools actually you

00:02:52,489 --> 00:02:56,390
misinterpret what the tools are doing

00:02:54,110 --> 00:03:00,019
then that can even lead you astray and

00:02:56,390 --> 00:03:01,580
make it even worse right so I think

00:03:00,019 --> 00:03:04,010
having a basic understanding of how

00:03:01,580 --> 00:03:10,069
these things work underneath is is

00:03:04,010 --> 00:03:11,510
essential so I'd like to divide these

00:03:10,069 --> 00:03:13,069
tools up into these different kind of

00:03:11,510 --> 00:03:14,299
categories right the debugger what we

00:03:13,069 --> 00:03:17,239
all think of and I spend most of my time

00:03:14,299 --> 00:03:19,160
talking about that today not how to use

00:03:17,239 --> 00:03:21,290
it I've done other talks on how to bead

00:03:19,160 --> 00:03:23,810
like how to do lots of cool stuff in gdb

00:03:21,290 --> 00:03:25,540
but how it works underneath there's

00:03:23,810 --> 00:03:27,440
record and replay tools which is

00:03:25,540 --> 00:03:30,500
obviously something that's close to my

00:03:27,440 --> 00:03:32,269
heart where I'm from the dynamic

00:03:30,500 --> 00:03:38,269
checkers and static analysis which

00:03:32,269 --> 00:03:40,549
DeWine will talk about so the debugger

00:03:38,269 --> 00:03:42,140
is really it saying what is my program

00:03:40,549 --> 00:03:44,030
doing right it's the ability to kind of

00:03:42,140 --> 00:03:48,320
freeze time it's a bit like you know

00:03:44,030 --> 00:03:49,760
there was that that style in in in

00:03:48,320 --> 00:03:51,799
movies that was very popular sort of

00:03:49,760 --> 00:03:54,109
popularized I think by the matrix and

00:03:51,799 --> 00:03:56,120
then where there's a freeze time and the

00:03:54,109 --> 00:03:58,400
camera kind of pans around and you can

00:03:56,120 --> 00:04:00,320
see everything kind of frozen and then

00:03:58,400 --> 00:04:01,700
that style got copied by like everybody

00:04:00,320 --> 00:04:03,079
for a few years including every

00:04:01,700 --> 00:04:04,220
commercial and everything well that's

00:04:03,079 --> 00:04:06,319
kind of what I think of the debugger

00:04:04,220 --> 00:04:08,060
like and you can see everything and then

00:04:06,319 --> 00:04:09,079
time can just run again right and then

00:04:08,060 --> 00:04:10,640
you can stop again and have a look

00:04:09,079 --> 00:04:12,200
around so it's very powerful they're

00:04:10,640 --> 00:04:15,319
telling you what's my program doing

00:04:12,200 --> 00:04:16,880
right now and where is the record and

00:04:15,319 --> 00:04:19,370
replay tools already tell you what did

00:04:16,880 --> 00:04:20,720
my program do what happened now there's

00:04:19,370 --> 00:04:22,820
a bit of overlap here admittedly

00:04:20,720 --> 00:04:24,620
debuggers can give you a back trace

00:04:22,820 --> 00:04:25,820
which is kind of the best they can do

00:04:24,620 --> 00:04:27,620
about telling you how you got here an

00:04:25,820 --> 00:04:29,960
obviously that's very limited but it can

00:04:27,620 --> 00:04:33,080
be very useful which we got there which

00:04:29,960 --> 00:04:34,789
stick with my analogy of matrix film

00:04:33,080 --> 00:04:35,870
direction like you've got that ability

00:04:34,789 --> 00:04:37,100
with

00:04:35,870 --> 00:04:38,540
with the replay systems you've got that

00:04:37,100 --> 00:04:41,420
ability to go and see everything from

00:04:38,540 --> 00:04:43,300
any angle you want and like a Time Lord

00:04:41,420 --> 00:04:45,650
you can sort of move time back and forth

00:04:43,300 --> 00:04:50,000
to arabi want to be and see everything

00:04:45,650 --> 00:04:52,910
for any point in time but jackers really

00:04:50,000 --> 00:04:55,730
they're about did a class of a certain

00:04:52,910 --> 00:04:57,290
thing happen buffer overrun being the

00:04:55,730 --> 00:04:59,030
kind of canonical example but there are

00:04:57,290 --> 00:05:00,830
all kinds of others to do with you know

00:04:59,030 --> 00:05:02,210
race conditions or out of order lock

00:05:00,830 --> 00:05:03,980
acquisition or something like that

00:05:02,210 --> 00:05:05,240
you're looking for instances if did this

00:05:03,980 --> 00:05:08,120
specific thing happen when I ran my

00:05:05,240 --> 00:05:10,280
program and the static checkers are

00:05:08,120 --> 00:05:12,170
saying could this thing happen they

00:05:10,280 --> 00:05:14,260
don't even have to run the program okay

00:05:12,170 --> 00:05:17,480
so here's the big difference of course

00:05:14,260 --> 00:05:18,650
with the dynamic checkers you have to it

00:05:17,480 --> 00:05:20,810
won't tell you whether a buffer overflow

00:05:18,650 --> 00:05:22,670
might happen you have to cause the

00:05:20,810 --> 00:05:24,350
buffer overflow in your testing or

00:05:22,670 --> 00:05:25,460
whatever in order to detect it it can

00:05:24,350 --> 00:05:29,300
tell you where it happened which of

00:05:25,460 --> 00:05:32,720
course this is extremely useful so let's

00:05:29,300 --> 00:05:34,550
get on with with gdb I'm gonna talk

00:05:32,720 --> 00:05:36,140
everything about gdb but any Linux

00:05:34,550 --> 00:05:38,270
debugger will be working in basically

00:05:36,140 --> 00:05:40,550
the same way but for the purposes of

00:05:38,270 --> 00:05:43,010
this talk so this is ll DB or

00:05:40,550 --> 00:05:45,110
total view or whatever your debugger

00:05:43,010 --> 00:05:46,910
running on Linux or indeed any unix-like

00:05:45,110 --> 00:05:49,910
system it's gonna be basically the same

00:05:46,910 --> 00:05:51,770
thing so you've got gdb which is a

00:05:49,910 --> 00:05:53,990
process right just the regular user

00:05:51,770 --> 00:05:55,820
level process doesn't have any special

00:05:53,990 --> 00:05:57,260
rights or anything and that's talking to

00:05:55,820 --> 00:05:58,610
your program here as good we're gonna

00:05:57,260 --> 00:06:01,160
call it hello world but whatever your

00:05:58,610 --> 00:06:03,740
program is and it's over this kernel API

00:06:01,160 --> 00:06:06,440
called P trace right which is a really

00:06:03,740 --> 00:06:08,690
lousy interface it's a horribly designed

00:06:06,440 --> 00:06:10,130
interface but it's pretty powerful and

00:06:08,690 --> 00:06:13,130
that's just like that's what it is so

00:06:10,130 --> 00:06:15,440
that's not what we have to use and then

00:06:13,130 --> 00:06:17,090
information goes back or asynchronous

00:06:15,440 --> 00:06:18,410
notifications go back from the program

00:06:17,090 --> 00:06:21,230
to the debugger

00:06:18,410 --> 00:06:24,350
over-over signals so it's just take

00:06:21,230 --> 00:06:27,800
attempts that back to how signals work

00:06:24,350 --> 00:06:30,410
so on on a on a unix system when a

00:06:27,800 --> 00:06:32,300
process receives a signal a lot of the

00:06:30,410 --> 00:06:34,220
time it's going to terminate that's

00:06:32,300 --> 00:06:36,590
often the default most often the default

00:06:34,220 --> 00:06:37,730
behavior depending on what the signal

00:06:36,590 --> 00:06:40,010
was and how the system was configured

00:06:37,730 --> 00:06:41,960
maybe it may be at dump score if it's

00:06:40,010 --> 00:06:45,980
thickened it won't if it's egg V it

00:06:41,960 --> 00:06:47,900
might but maybe the program has been

00:06:45,980 --> 00:06:49,700
configured to ignore the signal or maybe

00:06:47,900 --> 00:06:52,880
the default behavior of the signal

00:06:49,700 --> 00:06:57,740
to be ignored so signals like sig sig

00:06:52,880 --> 00:06:59,870
alarm default behavior is ignore or

00:06:57,740 --> 00:07:03,230
maybe the default behavior is to stop

00:06:59,870 --> 00:07:05,900
the program so signals like sink sink

00:07:03,230 --> 00:07:08,420
titi out sixty TN or sig t stop or sig

00:07:05,900 --> 00:07:11,360
stop their default behavior is to just

00:07:08,420 --> 00:07:12,440
to stop the program and if the program

00:07:11,360 --> 00:07:14,780
is so just so-so

00:07:12,440 --> 00:07:17,780
set things up it can run a signal

00:07:14,780 --> 00:07:19,400
handler on receipt of the signal and the

00:07:17,780 --> 00:07:21,410
other thing you might get is if your

00:07:19,400 --> 00:07:24,440
program is being P traced right so if it

00:07:21,410 --> 00:07:26,960
has a tracer and on receipt of a signal

00:07:24,440 --> 00:07:29,270
it goes into a tracing stop which looks

00:07:26,960 --> 00:07:32,180
very like a regular stop you can see

00:07:29,270 --> 00:07:35,180
this if you look in proc pin status you

00:07:32,180 --> 00:07:37,550
see this that the status of the of the

00:07:35,180 --> 00:07:39,500
process and if it's T that's a that's a

00:07:37,550 --> 00:07:40,730
that's a tracing stop it means it's got

00:07:39,500 --> 00:07:46,010
a pin it's got a tracer and it's

00:07:40,730 --> 00:07:48,260
received a signal so in this world so

00:07:46,010 --> 00:07:50,030
hello world here has its received some

00:07:48,260 --> 00:07:51,590
kind of signal it's a sig alarm whatever

00:07:50,030 --> 00:07:53,480
it is doesn't matter and it's now gone

00:07:51,590 --> 00:07:57,710
into this stopped state so I've shown it

00:07:53,480 --> 00:08:00,140
read it stopped and then the debugger

00:07:57,710 --> 00:08:03,110
will continue it with P trace cont which

00:08:00,140 --> 00:08:05,390
general unstop the target process and

00:08:03,110 --> 00:08:07,340
run it forward by Gd because the the the

00:08:05,390 --> 00:08:09,470
process being debugged the inferior

00:08:07,340 --> 00:08:11,030
which I was think is a is a lousy name

00:08:09,470 --> 00:08:12,470
but that's what it calls it but we can

00:08:11,030 --> 00:08:13,880
call it the target or the debugger you

00:08:12,470 --> 00:08:15,800
however you want to think of it so a

00:08:13,880 --> 00:08:18,140
call speed trace Conte and that process

00:08:15,800 --> 00:08:21,260
now starts running until something

00:08:18,140 --> 00:08:23,300
happens until actually it receives a

00:08:21,260 --> 00:08:25,550
signal and when it receives a signal it

00:08:23,300 --> 00:08:27,320
will go stop into that tracing stop the

00:08:25,550 --> 00:08:29,210
debugger gets notified and actually my

00:08:27,320 --> 00:08:31,610
little diagram I could have made gdb go

00:08:29,210 --> 00:08:32,930
red while the debug he was running

00:08:31,610 --> 00:08:34,460
because that's - while there the

00:08:32,930 --> 00:08:36,080
inferior was running because that's

00:08:34,460 --> 00:08:37,790
typically what happens but it doesn't

00:08:36,080 --> 00:08:38,450
have to actually you can run gdb in non

00:08:37,790 --> 00:08:40,190
stop mode

00:08:38,450 --> 00:08:42,050
there's nothing about there's nothing

00:08:40,190 --> 00:08:43,400
about P trace that requires it stops

00:08:42,050 --> 00:08:45,980
typically know what it'll do is a wait

00:08:43,400 --> 00:08:48,080
pit call and stop waiting for it that

00:08:45,980 --> 00:08:56,030
notification from the signal to come

00:08:48,080 --> 00:08:57,950
back so signals only reach the Tracy if

00:08:56,030 --> 00:09:00,590
they're passed in by this P trace can't

00:08:57,950 --> 00:09:02,300
cool so I said it was a lousy interface

00:09:00,590 --> 00:09:03,080
and you can see proof of it here so

00:09:02,300 --> 00:09:05,420
you've got this

00:09:03,080 --> 00:09:07,370
Petrus Conte the the first argument of

00:09:05,420 --> 00:09:09,020
Petrus is an opcode I think by the way

00:09:07,370 --> 00:09:11,690
if ever you find yourself writing a

00:09:09,020 --> 00:09:14,150
function whose first argument is some

00:09:11,690 --> 00:09:15,530
kind of opcode and then please don't it

00:09:14,150 --> 00:09:17,300
should be several functions it might be

00:09:15,530 --> 00:09:19,280
but whatever that's what Peter is looks

00:09:17,300 --> 00:09:20,720
like and you can see obviously it's

00:09:19,280 --> 00:09:22,130
completely and not typesafe when you

00:09:20,720 --> 00:09:23,390
pass in these boys stars but the last

00:09:22,130 --> 00:09:24,980
part coming there is sick alarm in this

00:09:23,390 --> 00:09:28,070
example so that will actually deliver

00:09:24,980 --> 00:09:29,270
the cig alarm to the Tracy and if

00:09:28,070 --> 00:09:32,420
there's a signal handler for that it

00:09:29,270 --> 00:09:33,800
will run or if there is if it's a if

00:09:32,420 --> 00:09:36,050
it's something like a seg V and there

00:09:33,800 --> 00:09:39,710
isn't a single handle terminate the

00:09:36,050 --> 00:09:42,140
process but the tracy will only ever

00:09:39,710 --> 00:09:43,700
actually see the signal if it's passed

00:09:42,140 --> 00:09:45,350
in via P trace Conte or one of its

00:09:43,700 --> 00:09:50,150
friends Peter a single step or Peter a

00:09:45,350 --> 00:09:52,370
Cisco and and if the signal handler is

00:09:50,150 --> 00:09:53,570
blocked then it will just mark the

00:09:52,370 --> 00:09:56,090
signals pending there's the handler

00:09:53,570 --> 00:09:57,950
won't run in that case and similarly if

00:09:56,090 --> 00:10:01,550
it's set to ignore and it'll just be

00:09:57,950 --> 00:10:02,810
ignored so breakpoints when you're when

00:10:01,550 --> 00:10:04,970
your target process hits a breakpoint

00:10:02,810 --> 00:10:09,020
that's just a signal that's a sig trap

00:10:04,970 --> 00:10:10,490
right now if it's a breakpoint on x86 it

00:10:09,020 --> 00:10:12,800
will have what the debugger would have

00:10:10,490 --> 00:10:15,680
done is poked into the text section a

00:10:12,800 --> 00:10:16,880
special instruction which on on Intel is

00:10:15,680 --> 00:10:17,860
in three I think we'll come to that in a

00:10:16,880 --> 00:10:20,390
bit

00:10:17,860 --> 00:10:21,890
it generates a sig trap and then the

00:10:20,390 --> 00:10:23,110
debugger is notified in just the kind of

00:10:21,890 --> 00:10:25,430
the normal way

00:10:23,110 --> 00:10:27,890
likewise control C right so if you run

00:10:25,430 --> 00:10:31,460
your program within gdb and it's busy

00:10:27,890 --> 00:10:34,010
and you hit control C there's no special

00:10:31,460 --> 00:10:35,720
like GTP's not well at least if it's not

00:10:34,010 --> 00:10:37,280
doing remote debugging gdb is not

00:10:35,720 --> 00:10:38,480
special like in this way doesn't do

00:10:37,280 --> 00:10:40,820
anything particularly special it's just

00:10:38,480 --> 00:10:43,790
that you're you're the program you're

00:10:40,820 --> 00:10:46,520
debugging it has a terminal probably and

00:10:43,790 --> 00:10:48,740
when you hit control C the tty for the

00:10:46,520 --> 00:10:50,990
controlling process group will send

00:10:48,740 --> 00:10:52,730
SIGINT to all of those processes so the

00:10:50,990 --> 00:10:55,760
the process it's being debugged gets

00:10:52,730 --> 00:10:57,080
topped with a SIGINT and then gdb gets

00:10:55,760 --> 00:10:58,310
notified of that effect and then it

00:10:57,080 --> 00:11:05,630
drops down to the prompt and you can do

00:10:58,310 --> 00:11:07,930
what you will and so you can see this so

00:11:05,630 --> 00:11:11,360
I go

00:11:07,930 --> 00:11:13,550
info signals so here are his his the

00:11:11,360 --> 00:11:15,710
default behavior for all of the signals

00:11:13,550 --> 00:11:16,950
in gdb so you've got these different

00:11:15,710 --> 00:11:19,170
things you can say whether is

00:11:16,950 --> 00:11:20,910
gonna stop or whether it's even if you

00:11:19,170 --> 00:11:22,260
say no to stop then when gdb see the

00:11:20,910 --> 00:11:25,110
thing little just feed it straight back

00:11:22,260 --> 00:11:26,700
in to the process and whether it's gonna

00:11:25,110 --> 00:11:28,470
tell the user tell you the user that

00:11:26,700 --> 00:11:29,850
it's happened whether it's going to pass

00:11:28,470 --> 00:11:31,320
it in so it doesn't have to right so

00:11:29,850 --> 00:11:33,750
that's the thing when the when the Tracy

00:11:31,320 --> 00:11:35,490
gets the signal the debugger it's up to

00:11:33,750 --> 00:11:36,870
the debug it's not to the tracer whether

00:11:35,490 --> 00:11:38,790
it's going to feed that signal back in

00:11:36,870 --> 00:11:45,330
usually it does but in things like

00:11:38,790 --> 00:11:46,680
control C which you can see here it

00:11:45,330 --> 00:11:48,330
won't feed it back in because most of

00:11:46,680 --> 00:11:49,650
the time that would just cause the

00:11:48,330 --> 00:12:02,430
program you're debugging to terminate

00:11:49,650 --> 00:12:04,230
right so this is my attempt to the the

00:12:02,430 --> 00:12:05,790
UNIX signal algorithm I think this is

00:12:04,230 --> 00:12:07,200
roughly right I'm almost certain

00:12:05,790 --> 00:12:09,870
there'll be some kind of exceptions to

00:12:07,200 --> 00:12:12,360
it but it's a sick kill and sig stop are

00:12:09,870 --> 00:12:14,190
special you cannot set a signal handler

00:12:12,360 --> 00:12:16,140
for either of them you cannot block them

00:12:14,190 --> 00:12:17,700
you cannot ignore them so if you if a

00:12:16,140 --> 00:12:19,590
process gets a sick kill even if it's

00:12:17,700 --> 00:12:20,880
being traced right even if it's being P

00:12:19,590 --> 00:12:22,320
traced even if it's being debugged and I

00:12:20,880 --> 00:12:24,900
guess I said kill that's it game over

00:12:22,320 --> 00:12:26,550
the program is terminated it becomes a

00:12:24,900 --> 00:12:28,980
zombie until it's until it until that

00:12:26,550 --> 00:12:31,680
result is reached and otherwise if it's

00:12:28,980 --> 00:12:33,900
a sig stop the process will go into a

00:12:31,680 --> 00:12:35,700
stop state again you can't can't you

00:12:33,900 --> 00:12:37,260
can't have a signal handle up for sig

00:12:35,700 --> 00:12:40,110
stop you can't mask it you can't ignore

00:12:37,260 --> 00:12:42,330
it otherwise if the process is being

00:12:40,110 --> 00:12:43,980
traced it goes into this tracing stop

00:12:42,330 --> 00:12:45,900
actually if it's this is not quite right

00:12:43,980 --> 00:12:48,120
if it's a sig stop and it's being traced

00:12:45,900 --> 00:12:49,500
it still goes into a tracing stop so

00:12:48,120 --> 00:12:50,790
that's a useful signal that debuggers

00:12:49,500 --> 00:12:53,640
will often use where they want to stop

00:12:50,790 --> 00:12:55,350
their target process because you can

00:12:53,640 --> 00:12:57,450
know as a debugger writer you can know

00:12:55,350 --> 00:12:59,490
that doesn't matter what the what the

00:12:57,450 --> 00:13:01,170
targets done in terms of masking the

00:12:59,490 --> 00:13:03,060
signals or setting signal handlers or

00:13:01,170 --> 00:13:04,260
ignoring signals it can't mask sick

00:13:03,060 --> 00:13:05,070
stuff it can't ignore it so they're

00:13:04,260 --> 00:13:09,030
going to do what you want

00:13:05,070 --> 00:13:10,620
um likewise any going up use blocked or

00:13:09,030 --> 00:13:12,030
ignored or is a handler otherwise last

00:13:10,620 --> 00:13:14,490
thing we do is terminate the process

00:13:12,030 --> 00:13:16,710
so P trace has a whole bunch of

00:13:14,490 --> 00:13:18,450
operations of petros contrib already

00:13:16,710 --> 00:13:20,340
seen single step runs at forward one

00:13:18,450 --> 00:13:23,430
instruction you can run forward to Cisco

00:13:20,340 --> 00:13:25,740
get set registers and peek and poke a

00:13:23,430 --> 00:13:26,910
memory and all that stuff it's about a

00:13:25,740 --> 00:13:28,530
whole bunch I'm not going to get into

00:13:26,910 --> 00:13:30,030
all the details and what it does but

00:13:28,530 --> 00:13:33,030
it's quite rich

00:13:30,030 --> 00:13:34,770
if you run with Petri Siskel that's kind

00:13:33,030 --> 00:13:36,210
of like Petros but it stops when

00:13:34,770 --> 00:13:38,130
the process issues a system call

00:13:36,210 --> 00:13:39,960
actually it stops twice once on the way

00:13:38,130 --> 00:13:43,860
into the system call and once on the way

00:13:39,960 --> 00:13:46,050
out and on the x86 is a nasty hack where

00:13:43,860 --> 00:13:48,810
you can you can inspect the ax register

00:13:46,050 --> 00:13:51,930
if it's -38 that means it stopped on the

00:13:48,810 --> 00:13:53,910
way in -38 z gnosis there's no way that

00:13:51,930 --> 00:13:55,740
a system call can actually return you

00:13:53,910 --> 00:13:57,650
know sis so that's why they picked that

00:13:55,740 --> 00:14:00,180
magic value I believe on other

00:13:57,650 --> 00:14:01,350
architectures and there's no way to tell

00:14:00,180 --> 00:14:02,700
whether it's on the way in all the way

00:14:01,350 --> 00:14:07,740
out you just have the trace and you just

00:14:02,700 --> 00:14:10,230
need to count and here's a certain thing

00:14:07,740 --> 00:14:13,140
that I you know so I'd been writing to

00:14:10,230 --> 00:14:15,750
the P trace interface for bit barrister

00:14:13,140 --> 00:14:17,550
status but for multiple years before I

00:14:15,750 --> 00:14:19,530
figured out that what happens with sis

00:14:17,550 --> 00:14:21,540
called restart the kernel does a really

00:14:19,530 --> 00:14:24,360
good job at kind of hiding this and

00:14:21,540 --> 00:14:28,950
making it all transparent nearly all the

00:14:24,360 --> 00:14:31,230
time so when when the process gets

00:14:28,950 --> 00:14:33,710
stopped goes into one of these is these

00:14:31,230 --> 00:14:36,600
tracing stop states that I spoke about

00:14:33,710 --> 00:14:38,100
it's let's say it's in deep in a read

00:14:36,600 --> 00:14:39,630
system call or something it's blocked

00:14:38,100 --> 00:14:41,490
reading data from the network and you do

00:14:39,630 --> 00:14:44,850
control C and it goes into this tracing

00:14:41,490 --> 00:14:47,010
stop actually it doesn't stop inside

00:14:44,850 --> 00:14:48,180
deep inside the kernel it percolates all

00:14:47,010 --> 00:14:50,310
the way back out the system called

00:14:48,180 --> 00:14:51,690
returns to user space and it's at the

00:14:50,310 --> 00:14:55,110
time the system call returns to user

00:14:51,690 --> 00:14:56,880
space then it becomes stopped and if you

00:14:55,110 --> 00:14:58,290
think back to the original version

00:14:56,880 --> 00:14:59,730
earlier versions of Linux that had the

00:14:58,290 --> 00:15:02,310
big Colonel Locke this was kind of

00:14:59,730 --> 00:15:03,570
needed right because otherwise you

00:15:02,310 --> 00:15:04,950
wouldn't be able to do anything if it

00:15:03,570 --> 00:15:06,630
was stuck in there in the kernel holding

00:15:04,950 --> 00:15:08,460
the lock and that's still the way but it

00:15:06,630 --> 00:15:10,020
works today it returns back to user

00:15:08,460 --> 00:15:12,450
space but before executing any code in

00:15:10,020 --> 00:15:17,330
user space then it's in that stop state

00:15:12,450 --> 00:15:20,130
and it has a special magic return code

00:15:17,330 --> 00:15:24,380
something like restarts this is

00:15:20,130 --> 00:15:28,800
something minus 512 through to minus 516

00:15:24,380 --> 00:15:31,230
these restart sis and friends and this

00:15:28,800 --> 00:15:32,790
is a special return code that tells the

00:15:31,230 --> 00:15:33,990
kernel when it next get sappy trace cont

00:15:32,790 --> 00:15:35,670
when it's going to be continued

00:15:33,990 --> 00:15:37,500
it's going to magically re-enter the

00:15:35,670 --> 00:15:38,700
system call and restart it and most of

00:15:37,500 --> 00:15:40,110
the time it'll do the right thing with

00:15:38,700 --> 00:15:43,110
timeouts and things so it doesn't reset

00:15:40,110 --> 00:15:46,320
the timeout to what it was

00:15:43,110 --> 00:15:49,230
so you should never see a system called

00:15:46,320 --> 00:15:52,920
return e restart sis as in userspace

00:15:49,230 --> 00:15:56,430
code it should never see kept but there

00:15:52,920 --> 00:15:58,529
are bugs and it's especially in in in

00:15:56,430 --> 00:16:01,310
certain versions of kernels one that's

00:15:58,529 --> 00:16:02,490
can be I think most problematic is the

00:16:01,310 --> 00:16:05,970
rl6

00:16:02,490 --> 00:16:08,279
kernels and central six and like where

00:16:05,970 --> 00:16:09,870
there was actually I said P traces is

00:16:08,279 --> 00:16:12,300
now the interface there was an attempt

00:16:09,870 --> 00:16:13,800
to make it better with a thing called

00:16:12,300 --> 00:16:15,329
you trace which then was going to be a

00:16:13,800 --> 00:16:18,060
new interface and then P trace would be

00:16:15,329 --> 00:16:19,890
a kind of personality on to that and Red

00:16:18,060 --> 00:16:22,200
Hat adopted it and put it all into rl6

00:16:19,890 --> 00:16:25,050
kernels but it never made it and that's

00:16:22,200 --> 00:16:27,690
kind of died that attempt and that

00:16:25,050 --> 00:16:29,579
implementation was a bit iffy so if

00:16:27,690 --> 00:16:30,810
you're debugging a process you might see

00:16:29,579 --> 00:16:32,700
a function you might see a sister

00:16:30,810 --> 00:16:34,920
particularly on rel six you might see a

00:16:32,700 --> 00:16:36,570
system call return e restart sis

00:16:34,920 --> 00:16:38,310
that's not what really happens that's an

00:16:36,570 --> 00:16:43,070
artifact of the fact that you'll be

00:16:38,310 --> 00:16:43,070
tracing it and in in your debugger I

00:16:44,060 --> 00:16:48,300
mentioned this earlier just touching

00:16:45,870 --> 00:16:50,610
this earlier breakpoints on x86 at least

00:16:48,300 --> 00:16:52,620
this int 3 instruction it's a magic

00:16:50,610 --> 00:16:55,100
single point instruction so inches to

00:16:52,620 --> 00:16:57,060
raise an interrupt and usually on x86

00:16:55,100 --> 00:17:00,570
integration interrupt is 2 bytes long

00:16:57,060 --> 00:17:02,100
the interrupt opcode and the 0 to 255 in

00:17:00,570 --> 00:17:03,990
shop number that you're raising but a

00:17:02,100 --> 00:17:05,850
2-byte breakpoint instruction would be

00:17:03,990 --> 00:17:07,350
problematic if you have a single byte

00:17:05,850 --> 00:17:09,179
instruction on which you're trying to

00:17:07,350 --> 00:17:10,500
place a breakpoint right otherwise your

00:17:09,179 --> 00:17:12,030
program could end up reaching into the

00:17:10,500 --> 00:17:14,819
middle of an instruction so there's a

00:17:12,030 --> 00:17:16,319
magic quite could xcc the debugger puts

00:17:14,819 --> 00:17:19,500
that in you should never see it right

00:17:16,319 --> 00:17:21,569
because the the debugger will when you

00:17:19,500 --> 00:17:25,020
look at the memory the debugger will

00:17:21,569 --> 00:17:27,059
take that out but if your program for

00:17:25,020 --> 00:17:28,799
whatever reason is reading its own code

00:17:27,059 --> 00:17:31,290
you might you might observe it when

00:17:28,799 --> 00:17:33,299
there's breakpoints are set when an

00:17:31,290 --> 00:17:35,220
entry instruction is executed the kernel

00:17:33,299 --> 00:17:36,270
stops the process with a sig trap and

00:17:35,220 --> 00:17:37,830
you get all the usual thing you see

00:17:36,270 --> 00:17:39,270
there's also hardware watch points which

00:17:37,830 --> 00:17:41,130
obviously very very useful right so that

00:17:39,270 --> 00:17:43,230
you can heart you can watch data and get

00:17:41,130 --> 00:17:45,690
a trigger a trap when that data is

00:17:43,230 --> 00:17:46,980
changed and those are set by the debug

00:17:45,690 --> 00:17:49,620
registers on x86

00:17:46,980 --> 00:17:51,270
I'm setting everything in x86 terms but

00:17:49,620 --> 00:17:53,940
most architectures have some equivalent

00:17:51,270 --> 00:17:55,080
of this DB zero to seven actually four

00:17:53,940 --> 00:17:56,460
of them and four addresses the other a

00:17:55,080 --> 00:17:58,560
control registers so you can see

00:17:56,460 --> 00:18:01,620
- forward time you can set them to trap

00:17:58,560 --> 00:18:02,700
or memory reads or writes or executes

00:18:01,620 --> 00:18:04,860
actually so you can implement

00:18:02,700 --> 00:18:06,240
breakpoints using the debug registers if

00:18:04,860 --> 00:18:07,920
you really don't want to write to the

00:18:06,240 --> 00:18:10,350
code but there aren't very many of them

00:18:07,920 --> 00:18:12,360
available and you don't you don't write

00:18:10,350 --> 00:18:15,000
to them directly from the program so

00:18:12,360 --> 00:18:16,650
it's configurable on x86 but I think

00:18:15,000 --> 00:18:18,390
Linux means you'll get a fault if you

00:18:16,650 --> 00:18:19,890
try to access the debug registers

00:18:18,390 --> 00:18:22,020
directly from your program but the

00:18:19,890 --> 00:18:27,930
debugger will do it by up a trace poke

00:18:22,020 --> 00:18:29,670
user command okay um so now I've got

00:18:27,930 --> 00:18:31,170
this let's get on to a bitmap

00:18:29,670 --> 00:18:34,260
that's how kind of P trace interface

00:18:31,170 --> 00:18:36,540
it's gone to dwarf info now and how our

00:18:34,260 --> 00:18:38,130
our debug information is represented and

00:18:36,540 --> 00:18:39,240
I suspect we've all kind of fallen afoul

00:18:38,130 --> 00:18:41,700
of this at some point

00:18:39,240 --> 00:18:43,980
so debugging with attributed record

00:18:41,700 --> 00:18:45,690
formats that's the kind of strange

00:18:43,980 --> 00:18:47,010
acronym and I was unsurprised when I

00:18:45,690 --> 00:18:48,630
looked it up earlier to learn that it is

00:18:47,010 --> 00:18:49,020
in fact a backronym and it's called

00:18:48,630 --> 00:18:50,520
dwarf

00:18:49,020 --> 00:18:52,980
because it was made at the same time as

00:18:50,520 --> 00:18:54,780
the elf format was made and they decided

00:18:52,980 --> 00:18:56,190
that would be kind of cool and so it

00:18:54,780 --> 00:18:57,030
doesn't really thought really what it

00:18:56,190 --> 00:18:59,820
stands for but anyway

00:18:57,030 --> 00:19:02,580
it contains the debug info it contains a

00:18:59,820 --> 00:19:04,320
description of your program that the

00:19:02,580 --> 00:19:06,270
debugger can read to give you that kind

00:19:04,320 --> 00:19:08,160
of symbolic information so there's

00:19:06,270 --> 00:19:09,810
simplest level it'll map a program

00:19:08,160 --> 00:19:12,270
counter to a source line so when your

00:19:09,810 --> 00:19:14,610
program is stopped a program counter you

00:19:12,270 --> 00:19:15,930
know X 1 2 3 4 the debugger can look in

00:19:14,610 --> 00:19:19,800
the dwarf information so yeah that

00:19:15,930 --> 00:19:21,090
corresponds to food OC line 42 but

00:19:19,800 --> 00:19:24,300
contains all sorts of information as

00:19:21,090 --> 00:19:26,760
well you know and and all the type

00:19:24,300 --> 00:19:27,900
information classes templates all kinds

00:19:26,760 --> 00:19:33,960
of things that the debugger might want

00:19:27,900 --> 00:19:36,810
to know and you can hear some useful

00:19:33,960 --> 00:19:38,700
useful options so - G is the default one

00:19:36,810 --> 00:19:41,010
that's the easiest one to get debug info

00:19:38,700 --> 00:19:43,140
but actually that defaults to minus G 2

00:19:41,010 --> 00:19:44,880
so minus G is like - oh you give it a

00:19:43,140 --> 00:19:48,810
number afterwards to specify different

00:19:44,880 --> 00:19:51,930
levels and default - G's is level 2 you

00:19:48,810 --> 00:19:53,760
can go - G 3 to get everything with

00:19:51,930 --> 00:19:56,670
generally I think is I recommend this

00:19:53,760 --> 00:19:58,290
just and really useful - G 3 and is

00:19:56,670 --> 00:20:00,060
independent completely orthogonal to the

00:19:58,290 --> 00:20:01,500
optimization level but obviously the

00:20:00,060 --> 00:20:04,590
more aggressively the compiler has

00:20:01,500 --> 00:20:06,120
optimized your code the more quirky your

00:20:04,590 --> 00:20:08,970
experience might be when you come to

00:20:06,120 --> 00:20:10,080
debug it it's not laid out linearly and

00:20:08,970 --> 00:20:11,399
so you can

00:20:10,080 --> 00:20:14,700
think you're going forwards but you jump

00:20:11,399 --> 00:20:16,919
back and butt - og is a useful

00:20:14,700 --> 00:20:18,600
optimization level so good good up the

00:20:16,919 --> 00:20:20,850
sensible optimizations but but nothing

00:20:18,600 --> 00:20:22,019
too crazy so you get a sensible debug

00:20:20,850 --> 00:20:23,549
experience but often you're trying to

00:20:22,019 --> 00:20:25,380
debug you know you're finding a quick

00:20:23,549 --> 00:20:27,809
debug production code and you want to do

00:20:25,380 --> 00:20:31,220
that with full optimizations and and you

00:20:27,809 --> 00:20:34,169
can you can and it does the experiences

00:20:31,220 --> 00:20:37,080
obviously your experience will vary but

00:20:34,169 --> 00:20:38,399
we'll talk a bit about that right now so

00:20:37,080 --> 00:20:40,649
one of the most annoying things when

00:20:38,399 --> 00:20:42,539
you're debugging optimized code oh by

00:20:40,649 --> 00:20:44,220
the way if you do just if you do - g3

00:20:42,539 --> 00:20:45,929
one of the nice things it will do is -

00:20:44,220 --> 00:20:47,340
all the inline functions it will kind of

00:20:45,929 --> 00:20:49,200
make that all go away so as you're

00:20:47,340 --> 00:20:50,850
stepping through it will mostly look

00:20:49,200 --> 00:20:55,470
like inline functions are not inlined

00:20:50,850 --> 00:20:56,730
which is very helpful and but yeah you

00:20:55,470 --> 00:20:58,320
try and print a variable and you get and

00:20:56,730 --> 00:21:01,559
you get variable optimized out right so

00:20:58,320 --> 00:21:08,340
we've all seen that I expect so let's

00:21:01,559 --> 00:21:09,960
have a look at what this means so so

00:21:08,340 --> 00:21:20,519
here's a little program that I'm going

00:21:09,960 --> 00:21:23,639
to compile with optimizations and when

00:21:20,519 --> 00:21:26,789
we load it up and so here I am at the

00:21:23,639 --> 00:21:28,740
beginning of my of my program line seven

00:21:26,789 --> 00:21:30,720
and if I print foo

00:21:28,740 --> 00:21:32,610
it says variable optimize now I think

00:21:30,720 --> 00:21:34,289
this is a really unhelpful error message

00:21:32,610 --> 00:21:36,090
because it kind of implies to me at

00:21:34,289 --> 00:21:37,440
least that that just doesn't exist

00:21:36,090 --> 00:21:38,970
anymore though the compilers been able

00:21:37,440 --> 00:21:40,200
to get rid of for you completely it's

00:21:38,970 --> 00:21:42,990
not what it means here what it means

00:21:40,200 --> 00:21:45,120
here is it's not live but it hasn't

00:21:42,990 --> 00:21:48,389
actually been optimized away if I do

00:21:45,120 --> 00:21:51,779
next and then print Fuu hey well ah

00:21:48,389 --> 00:21:54,570
there it is alright so let's look up

00:21:51,779 --> 00:21:57,590
what that actually I have that all works

00:21:54,570 --> 00:21:59,299
and what gdb is doing so well I could

00:21:57,590 --> 00:22:06,210
read elf

00:21:59,299 --> 00:22:07,919
- debug dump so this is this shows us

00:22:06,210 --> 00:22:10,289
the dwarf information right so dwarf is

00:22:07,919 --> 00:22:13,110
this file format is fairly simple really

00:22:10,289 --> 00:22:14,309
and it's just this tree of objects and

00:22:13,110 --> 00:22:16,889
there are tags which are the kind of the

00:22:14,309 --> 00:22:18,270
nodes of the tree and it the tree

00:22:16,889 --> 00:22:21,720
structure as you might imagine from your

00:22:18,270 --> 00:22:23,760
program layout and and nested blocks of

00:22:21,720 --> 00:22:25,440
code and types in structures with

00:22:23,760 --> 00:22:27,210
structures and classes and templates and

00:22:25,440 --> 00:22:29,880
all that well put together in this tree

00:22:27,210 --> 00:22:31,890
bit a little bit like an AST but not

00:22:29,880 --> 00:22:32,820
quite and here's everything of course

00:22:31,890 --> 00:22:34,500
this has got everything that I've

00:22:32,820 --> 00:22:36,330
included all the type definitions and

00:22:34,500 --> 00:22:38,310
everything so so GC so you can describe

00:22:36,330 --> 00:22:40,890
that if you remember my variable was

00:22:38,310 --> 00:22:44,280
called foo so let's have a look at that

00:22:40,890 --> 00:22:46,350
so here's foo and it tells me you know

00:22:44,280 --> 00:22:47,880
where it is so it's in file number 1

00:22:46,350 --> 00:22:50,850
which will be indexed elsewhere to

00:22:47,880 --> 00:22:53,460
optimize see the file name and the line

00:22:50,850 --> 00:22:54,660
number and everything and the type of

00:22:53,460 --> 00:22:57,750
course and it has this it has a

00:22:54,660 --> 00:23:01,140
locations list and this defines where

00:22:57,750 --> 00:23:03,990
foo is is live and I can actually look

00:23:01,140 --> 00:23:06,240
at that a slightly simpler view I can go

00:23:03,990 --> 00:23:07,950
debug duck equals lock and get just the

00:23:06,240 --> 00:23:09,750
locations list now this program is very

00:23:07,950 --> 00:23:11,550
small so it's totally quite small so

00:23:09,750 --> 00:23:14,100
here's the locations list starting at a

00:23:11,550 --> 00:23:16,680
it's actually a list it's a full list

00:23:14,100 --> 00:23:21,240
and he did these the ranges where foo is

00:23:16,680 --> 00:23:23,280
available right so if I go back let's

00:23:21,240 --> 00:23:25,100
look at the function so I can see from

00:23:23,280 --> 00:23:28,440
the disassembly it's never actually

00:23:25,100 --> 00:23:30,360
writing food writing that food value to

00:23:28,440 --> 00:23:33,930
memory it doesn't need to Rand returns

00:23:30,360 --> 00:23:35,850
it it's in register ax and and it just

00:23:33,930 --> 00:23:37,350
keeps it in a register but the dwarf

00:23:35,850 --> 00:23:39,270
info that's fine it can tell us that

00:23:37,350 --> 00:23:42,300
right you can tell us that these lines

00:23:39,270 --> 00:23:43,620
it seems to have a zero size range it's

00:23:42,300 --> 00:23:46,950
I'm not sure what that's all about but

00:23:43,620 --> 00:23:48,390
from here from from from offset when I

00:23:46,950 --> 00:23:50,880
said and Paul to one in seven eight I

00:23:48,390 --> 00:23:56,820
look here so I can see here it is here's

00:23:50,880 --> 00:23:59,010
the O seven four seven eight and it's

00:23:56,820 --> 00:24:01,320
telling it tells the the debugger that

00:23:59,010 --> 00:24:02,400
the values they're in in in register are

00:24:01,320 --> 00:24:04,290
a X and actually it pops around

00:24:02,400 --> 00:24:05,970
different registers here and it's

00:24:04,290 --> 00:24:06,990
actually telling us a think or having

00:24:05,970 --> 00:24:09,060
actually confirmed this but I think what

00:24:06,990 --> 00:24:12,510
this means is the value of foo is what's

00:24:09,060 --> 00:24:16,950
in our ax plus one right because my code

00:24:12,510 --> 00:24:18,780
if you remember did food plus plus and

00:24:16,950 --> 00:24:20,670
then at the end it's just in our ax

00:24:18,780 --> 00:24:22,620
because that's the value that gets there

00:24:20,670 --> 00:24:25,050
gets returned so modern versions of the

00:24:22,620 --> 00:24:27,660
compiler a modern versions of gdb or

00:24:25,050 --> 00:24:29,640
whatever debugger you're using are able

00:24:27,660 --> 00:24:31,470
to do an okay job at least it's pretty

00:24:29,640 --> 00:24:33,060
good job of tracking register you know

00:24:31,470 --> 00:24:35,310
tracking values through register States

00:24:33,060 --> 00:24:36,300
just as long as they're life now of

00:24:35,310 --> 00:24:37,590
course if you're using reversible

00:24:36,300 --> 00:24:39,419
debugging is even better because

00:24:37,590 --> 00:24:42,419
and go back to when it was live when

00:24:39,419 --> 00:24:43,980
it's kind of become unlive but but even

00:24:42,419 --> 00:24:45,179
if you're using a regular debugger often

00:24:43,980 --> 00:24:48,690
you can just step forwards a bit and

00:24:45,179 --> 00:24:51,720
find out what your what those values are

00:24:48,690 --> 00:24:55,440
there's a nice little tour of dwarf and

00:24:51,720 --> 00:24:58,260
and and all that good stuff so you can

00:24:55,440 --> 00:25:00,539
tell these are all GCC options by the

00:24:58,260 --> 00:25:04,200
way so you can tell GCC quite a bunch of

00:25:00,539 --> 00:25:06,720
things but actually if you just put - g3

00:25:04,200 --> 00:25:09,360
it kind of does everything even macros

00:25:06,720 --> 00:25:16,799
actually which is quite cool let me just

00:25:09,360 --> 00:25:22,520
quickly show that so so if I go my best

00:25:16,799 --> 00:25:26,159
just - G I'm here and I load that up I

00:25:22,520 --> 00:25:27,330
start and my print vowel it goes I don't

00:25:26,159 --> 00:25:29,130
know what that is right because it says

00:25:27,330 --> 00:25:35,029
preprocessor macro hasn't gone through

00:25:29,130 --> 00:25:41,029
the compiler but if I go that's g3 and

00:25:35,029 --> 00:25:43,080
repeats but I it knows about macros so

00:25:41,029 --> 00:25:48,390
particularly it's only about macros like

00:25:43,080 --> 00:25:51,390
that sort of expand you can so part can

00:25:48,390 --> 00:25:52,830
convert data structures into to extract

00:25:51,390 --> 00:25:53,820
the bits the bit fields out of data

00:25:52,830 --> 00:25:55,289
structures or whatever if that when

00:25:53,820 --> 00:25:59,429
that's done by macros which sometimes it

00:25:55,289 --> 00:26:00,690
is that's quite useful obviously you

00:25:59,429 --> 00:26:02,340
shouldn't be using macros but maybe

00:26:00,690 --> 00:26:04,549
you're trying to debug someone else's

00:26:02,340 --> 00:26:04,549
code

00:26:10,880 --> 00:26:19,890
now related related to dwarf format is

00:26:16,010 --> 00:26:23,600
stack information CF a and CF ice which

00:26:19,890 --> 00:26:25,920
is call frame address and information

00:26:23,600 --> 00:26:27,780
respectively so depending on how you

00:26:25,920 --> 00:26:29,390
compile things you may or may not have

00:26:27,780 --> 00:26:31,320
frame pointers and in the modern world

00:26:29,390 --> 00:26:33,990
more than likely you don't any

00:26:31,320 --> 00:26:35,760
optimization on 64-bit Intel the

00:26:33,990 --> 00:26:37,890
compiler will take away frame pointers

00:26:35,760 --> 00:26:40,620
so it can use the rbp register as a

00:26:37,890 --> 00:26:42,210
useful general purpose register and this

00:26:40,620 --> 00:26:45,330
means walking the stack is slightly

00:26:42,210 --> 00:26:47,790
painful but you know it's worth it for

00:26:45,330 --> 00:26:51,180
the extra register that you get and so

00:26:47,790 --> 00:26:54,330
with the CFA and and CFI what you get is

00:26:51,180 --> 00:26:56,190
essentially a mapping of at this if

00:26:54,330 --> 00:26:58,320
every program counter or range of

00:26:56,190 --> 00:27:00,120
program counters what offset from the

00:26:58,320 --> 00:27:04,440
stack pointer is the beginning of my

00:27:00,120 --> 00:27:06,690
stack frame right and then that can be

00:27:04,440 --> 00:27:09,180
so then you can use that to do print

00:27:06,690 --> 00:27:11,760
your back trace or see it and that's on

00:27:09,180 --> 00:27:13,080
the CF a and with CF I you get more

00:27:11,760 --> 00:27:17,190
stuff like locals and everything else

00:27:13,080 --> 00:27:19,800
and actually the exception unwinding

00:27:17,190 --> 00:27:22,650
mechanism and C++ will use some of this

00:27:19,800 --> 00:27:27,720
stuff so it's kind of related but but

00:27:22,650 --> 00:27:30,660
but different from dwarf as this is as

00:27:27,720 --> 00:27:34,530
this is a C++ conference nets just a

00:27:30,660 --> 00:27:37,020
little bit of C++ so cat points pretty

00:27:34,530 --> 00:27:38,400
cool and gdb they let you stop but so

00:27:37,020 --> 00:27:39,960
breakpoints obviously stop but on a

00:27:38,400 --> 00:27:41,730
certain at a certain given any given

00:27:39,960 --> 00:27:43,620
line catch points can make you stop when

00:27:41,730 --> 00:27:57,060
when kind of interesting things happen

00:27:43,620 --> 00:28:03,990
so here's my bit of C++ code minus g3 so

00:27:57,060 --> 00:28:06,030
I can go catch throw exception now will

00:28:03,990 --> 00:28:07,890
catch any time the exception exception

00:28:06,030 --> 00:28:11,690
is thrown I can also catch catch which

00:28:07,890 --> 00:28:16,740
is a bit mouthful but catch if the catch

00:28:11,690 --> 00:28:17,970
and if I look at what it's done it's

00:28:16,740 --> 00:28:20,820
actually inserted just a couple of

00:28:17,970 --> 00:28:21,450
breakpoints and and it's given me

00:28:20,820 --> 00:28:23,580
handily the

00:28:21,450 --> 00:28:31,769
dress here so I can look at that if I

00:28:23,580 --> 00:28:33,510
look at that address info line that we

00:28:31,769 --> 00:28:41,639
can see sure enough that's at this cxa

00:28:33,510 --> 00:28:43,649
throw label and unsurprisingly that's a

00:28:41,639 --> 00:28:46,139
catch right so these are these are

00:28:43,649 --> 00:28:48,480
routines within there's the C++ library

00:28:46,139 --> 00:28:49,860
which the exception mechanism will jump

00:28:48,480 --> 00:28:52,559
into when it's throwing and catching

00:28:49,860 --> 00:28:54,990
exceptions and then you gdb will break

00:28:52,559 --> 00:28:56,580
points on there and then can filter on

00:28:54,990 --> 00:29:01,669
the exception type and and and all that

00:28:56,580 --> 00:29:04,590
good stuff you can also catch Cisco

00:29:01,669 --> 00:29:06,600
which uses the tracer school thing right

00:29:04,590 --> 00:29:08,159
so you can say catch also schools or

00:29:06,600 --> 00:29:13,139
catch a certain syscall and run forward

00:29:08,159 --> 00:29:14,279
until that Cisco happens threads are

00:29:13,139 --> 00:29:17,279
kind of interesting in the debugger

00:29:14,279 --> 00:29:18,620
world so the thread library this is all

00:29:17,279 --> 00:29:21,480
kind of pointless these days because

00:29:18,620 --> 00:29:23,340
pretty much every threaded C++ program

00:29:21,480 --> 00:29:24,870
on linux is going to be using just Lippe

00:29:23,340 --> 00:29:26,250
thread and it's all kind of standard but

00:29:24,870 --> 00:29:27,779
it's designed such that you can have

00:29:26,250 --> 00:29:29,760
different threading libraries and in

00:29:27,779 --> 00:29:31,139
years gone by that was actually more

00:29:29,760 --> 00:29:33,269
common that you would do that

00:29:31,139 --> 00:29:34,919
so the threading library provides its

00:29:33,269 --> 00:29:36,480
lib thread DB where D B stands for

00:29:34,919 --> 00:29:38,820
debugger and that provides different

00:29:36,480 --> 00:29:40,320
routines that the debugger can call to

00:29:38,820 --> 00:29:42,809
look up things like thread-local storage

00:29:40,320 --> 00:29:44,909
so when you try and print ernõ in just

00:29:42,809 --> 00:29:46,889
an irregular c program and that will

00:29:44,909 --> 00:29:48,269
actually go through lib for a DB if it's

00:29:46,889 --> 00:29:52,440
threaded program because I know is

00:29:48,269 --> 00:29:57,769
thread local gdb does that kind of all

00:29:52,440 --> 00:30:00,809
automatically for you just a little plug

00:29:57,769 --> 00:30:03,750
I'm putting together a series of small

00:30:00,809 --> 00:30:06,899
kind of bite-sized 510 minute tutorials

00:30:03,750 --> 00:30:08,370
on all kinds of things gdb so it's kind

00:30:06,899 --> 00:30:09,960
of a lot of content from previous talks

00:30:08,370 --> 00:30:12,720
but a lot of new stuff as well she might

00:30:09,960 --> 00:30:15,720
wanna go and look at our wittingly named

00:30:12,720 --> 00:30:16,500
gdb watchpoints series and for more of

00:30:15,720 --> 00:30:22,470
that kind of stuff

00:30:16,500 --> 00:30:25,710
enough of GDP and the debugger let's

00:30:22,470 --> 00:30:28,470
talk about dynamic checkers it's my

00:30:25,710 --> 00:30:29,700
dress sanitizer and valgrind here there

00:30:28,470 --> 00:30:31,799
are of course many others they're all

00:30:29,700 --> 00:30:33,480
kind of a both the press an appetizer

00:30:31,799 --> 00:30:35,160
and valgrind work on this they have this

00:30:33,480 --> 00:30:38,780
notion of shadow memory

00:30:35,160 --> 00:30:42,800
right what they what so back up a bit

00:30:38,780 --> 00:30:46,740
what we're trying to do here is detect

00:30:42,800 --> 00:30:49,260
invalid memory accesses at a much finer

00:30:46,740 --> 00:30:50,640
grain than the hardware will allow right

00:30:49,260 --> 00:30:52,920
so obviously with modern systems you've

00:30:50,640 --> 00:30:54,060
got pages typically four K might be got

00:30:52,920 --> 00:30:56,190
you know might be might be much better

00:30:54,060 --> 00:30:58,440
than that and that's your kind of the

00:30:56,190 --> 00:31:01,920
granularity with which you can mark

00:30:58,440 --> 00:31:03,150
memory as accessible or not and what

00:31:01,920 --> 00:31:04,860
we're trying to do with both valgrind

00:31:03,150 --> 00:31:06,960
own address and the sanitizer is do that

00:31:04,860 --> 00:31:08,970
at a much finer grained in a person of

00:31:06,960 --> 00:31:11,880
object level much finer grain and the

00:31:08,970 --> 00:31:15,510
hardware will support so what they do is

00:31:11,880 --> 00:31:17,550
create this these shadow map so the

00:31:15,510 --> 00:31:19,620
memory every chunk of memory does this

00:31:17,550 --> 00:31:22,200
work not really every chunk of memory

00:31:19,620 --> 00:31:23,730
will map down to a shape that shadows

00:31:22,200 --> 00:31:26,850
are smaller bits and it needs a few bits

00:31:23,730 --> 00:31:28,620
of information for every eight byte word

00:31:26,850 --> 00:31:31,710
so the shadow is smaller than the memory

00:31:28,620 --> 00:31:34,320
its shadows typically and it just has

00:31:31,710 --> 00:31:35,880
information about whether this so that

00:31:34,320 --> 00:31:37,950
way both address on a times around

00:31:35,880 --> 00:31:39,350
valgrind could look up is this address

00:31:37,950 --> 00:31:42,270
about late or not

00:31:39,350 --> 00:31:44,040
now valgrind works with a binary JIT

00:31:42,270 --> 00:31:45,810
translation right so you can just take

00:31:44,040 --> 00:31:46,950
your program compiled however it's

00:31:45,810 --> 00:31:48,630
compiled maybe you don't even have the

00:31:46,950 --> 00:31:50,310
source code to it and you can run it

00:31:48,630 --> 00:31:53,250
through valgrind and it does it through

00:31:50,310 --> 00:31:54,480
JIT translation the sanitizers work by

00:31:53,250 --> 00:31:55,980
changing the compiler these have

00:31:54,480 --> 00:31:57,060
different trade-offs of course it's nice

00:31:55,980 --> 00:31:58,620
that you don't have to change the

00:31:57,060 --> 00:32:01,290
application change the way you compile

00:31:58,620 --> 00:32:03,630
with valgrind it does mean it is quite

00:32:01,290 --> 00:32:05,520
slow and there are certain things you

00:32:03,630 --> 00:32:07,440
can't do so address sanitizer because

00:32:05,520 --> 00:32:12,150
the compiler is generating the the

00:32:07,440 --> 00:32:14,430
checks around each memory access it can

00:32:12,150 --> 00:32:15,810
it can do more stuff right so one of the

00:32:14,430 --> 00:32:18,570
things it can do that the valgrind

00:32:15,810 --> 00:32:21,750
isn't able to do is detect and buffer

00:32:18,570 --> 00:32:24,690
overruns on the stack and the runtime

00:32:21,750 --> 00:32:27,900
overhead is much less so they report to

00:32:24,690 --> 00:32:29,280
the clear arms of 50% to 100% slowdown

00:32:27,900 --> 00:32:30,690
so it's still you know very real

00:32:29,280 --> 00:32:33,720
immeasurable but it's much less than

00:32:30,690 --> 00:32:35,640
you'd get with something like Algren but

00:32:33,720 --> 00:32:38,460
what both techniques are doing is every

00:32:35,640 --> 00:32:40,290
chunk of memory has this has these red

00:32:38,460 --> 00:32:42,600
zones at the beginning in the end right

00:32:40,290 --> 00:32:44,010
and and so if you do a melaka person

00:32:42,600 --> 00:32:46,440
site I mean it anyway if you do malloc

00:32:44,010 --> 00:32:47,940
of say 32 bytes actually the system's

00:32:46,440 --> 00:32:49,080
gone out and I came more than 32 bytes

00:32:47,940 --> 00:32:50,100
because it's got some bookkeeping

00:32:49,080 --> 00:32:52,670
information that needs to go with that

00:32:50,100 --> 00:32:55,290
Malick's chunk but if you do it with

00:32:52,670 --> 00:32:56,580
with valgrind or with their address

00:32:55,290 --> 00:32:58,500
sanitizer they they have their own

00:32:56,580 --> 00:33:00,030
Malik's they Interceptor Malik and they

00:32:58,500 --> 00:33:01,730
make it even bigger and they put these

00:33:00,030 --> 00:33:05,220
red zones at the beginning in the end

00:33:01,730 --> 00:33:07,440
which and then through the shadow maps

00:33:05,220 --> 00:33:08,850
these red zones are mark bad right so if

00:33:07,440 --> 00:33:12,360
you memory if your program touches these

00:33:08,850 --> 00:33:14,850
in notice it's a problem one thing to be

00:33:12,360 --> 00:33:18,900
aware of of course is the there's the

00:33:14,850 --> 00:33:20,880
smaller the red zone then the if you if

00:33:18,900 --> 00:33:22,770
you stretch over the buffer with a

00:33:20,880 --> 00:33:24,750
certain stride you're gonna you can go

00:33:22,770 --> 00:33:26,550
right with us with the red zone anyone

00:33:24,750 --> 00:33:28,560
notice a bigger red zones will catch

00:33:26,550 --> 00:33:34,530
more types of errors but of course

00:33:28,560 --> 00:33:37,680
consume more memory so that's it for the

00:33:34,530 --> 00:33:40,230
sanitizers let's get in now to record

00:33:37,680 --> 00:33:43,950
and replay systems and something sort of

00:33:40,230 --> 00:33:45,690
close close to my heart so as I say

00:33:43,950 --> 00:33:47,130
activate so it's this control of time

00:33:45,690 --> 00:33:50,430
it's being able to see exactly what

00:33:47,130 --> 00:33:53,640
happens I think we have time where I can

00:33:50,430 --> 00:33:57,480
just show very quick demo this if you

00:33:53,640 --> 00:34:00,300
will indulge me that readable just about

00:33:57,480 --> 00:34:12,620
that well maybe not the back me yeah I

00:34:00,300 --> 00:34:14,730
think there's a but I haven't got any

00:34:12,620 --> 00:34:17,150
that's not doing what I wanted it to do

00:34:14,730 --> 00:34:17,150
all right

00:34:21,430 --> 00:34:27,160
you know that's not done what I wanted

00:34:24,190 --> 00:34:28,390
might just go into normal mode so here

00:34:27,160 --> 00:34:31,570
I've got a little program and I'm going

00:34:28,390 --> 00:34:36,960
to run the program inside the debugger

00:34:31,570 --> 00:34:36,960
get on to the VPN so I can get a license

00:34:45,390 --> 00:34:49,210
ok that's let's get rid of that so in a

00:34:47,710 --> 00:34:50,650
previous time around this little demo so

00:34:49,210 --> 00:34:52,570
apologies if you've seen this demo

00:34:50,650 --> 00:34:54,910
before but I just want to show what we

00:34:52,570 --> 00:34:56,800
mean by record and replay or reversible

00:34:54,910 --> 00:34:59,530
debugging so I'm gonna run my program

00:34:56,800 --> 00:35:01,450
and it's crashed and I come to a certain

00:34:59,530 --> 00:35:02,410
0 all right well what's gone let's have

00:35:01,450 --> 00:35:03,820
a look at what's going on here so I've

00:35:02,410 --> 00:35:05,260
called this function cache calculate

00:35:03,820 --> 00:35:07,450
which given a number is supposed to

00:35:05,260 --> 00:35:10,480
return this square root and I've given

00:35:07,450 --> 00:35:12,910
it 255 and it's return 0 so clearly

00:35:10,480 --> 00:35:15,430
calculating has returned the wrong thing

00:35:12,910 --> 00:35:17,170
I can see from my stack trace here down

00:35:15,430 --> 00:35:19,030
here I'm not actually in my coder so

00:35:17,170 --> 00:35:21,190
it's 0 the debug is nice kindly put me

00:35:19,030 --> 00:35:23,470
there but actually it's in this raised

00:35:21,190 --> 00:35:26,620
function here that the where the program

00:35:23,470 --> 00:35:27,870
has stopped all so far so normal so you

00:35:26,620 --> 00:35:29,950
know you can do that with a regular

00:35:27,870 --> 00:35:31,480
debugger just looking as I said earlier

00:35:29,950 --> 00:35:33,040
looking at the stack trace is kind of

00:35:31,480 --> 00:35:34,690
the though the closest that most

00:35:33,040 --> 00:35:38,650
debuggers give you to it like how did I

00:35:34,690 --> 00:35:39,880
get here and but I need to know what

00:35:38,650 --> 00:35:41,470
happened inside this function right

00:35:39,880 --> 00:35:45,550
cache calculate return the wrong thing I

00:35:41,470 --> 00:35:47,680
need to know why so what I'm going to do

00:35:45,550 --> 00:35:49,630
is hit this button here which is like a

00:35:47,680 --> 00:35:51,250
nun call which is kind of popping up a

00:35:49,630 --> 00:35:53,140
cool stack but rather than guessing is

00:35:51,250 --> 00:35:54,370
really moving back my program has

00:35:53,140 --> 00:35:56,170
definitely been here all the bear all

00:35:54,370 --> 00:35:57,400
the Global's and everything are being go

00:35:56,170 --> 00:36:01,120
back to what they were and now I can

00:35:57,400 --> 00:36:02,800
start to step back through time and now

00:36:01,120 --> 00:36:05,830
if I go here this is right after cache

00:36:02,800 --> 00:36:07,330
calculate returned so I can go in to the

00:36:05,830 --> 00:36:09,070
function and I can see what it returned

00:36:07,330 --> 00:36:12,070
and why so it's returned the I think

00:36:09,070 --> 00:36:15,550
free from the cache I here is 88 so this

00:36:12,070 --> 00:36:17,110
looks like typical programmers worst

00:36:15,550 --> 00:36:18,700
nightmare sure enough my cache contains

00:36:17,110 --> 00:36:21,700
bad data my cache tells me that the

00:36:18,700 --> 00:36:23,200
square root of 2 pi 5 is 0 so someone

00:36:21,700 --> 00:36:24,670
stomped on my cash I've got no idea how

00:36:23,200 --> 00:36:26,650
or when that happened is it a logic

00:36:24,670 --> 00:36:28,810
error is it a memory error I don't know

00:36:26,650 --> 00:36:30,760
well all I'm going to do here is add a

00:36:28,810 --> 00:36:31,960
watch point normally you'd set a watch

00:36:30,760 --> 00:36:33,400
point I'm gonna make this watch point

00:36:31,960 --> 00:36:34,630
persist across stack frames normally

00:36:33,400 --> 00:36:35,290
you'd set a watch point and run forward

00:36:34,630 --> 00:36:37,240
until the data

00:36:35,290 --> 00:36:39,160
Changez I'm gonna run backwards until

00:36:37,240 --> 00:36:41,350
that data changes and that's going to

00:36:39,160 --> 00:36:42,910
take me back to the line of code that's

00:36:41,350 --> 00:36:45,160
where that happened to smoking gun so

00:36:42,910 --> 00:36:46,750
I've gone back in time I've gone back in

00:36:45,160 --> 00:36:49,270
time to where the structure contains

00:36:46,750 --> 00:36:50,740
good data I'm actually I can now step

00:36:49,270 --> 00:36:52,750
forwards watch the data here as I step

00:36:50,740 --> 00:36:56,260
forwards this is we'll see this in like

00:36:52,750 --> 00:36:58,330
watching a live action replay for

00:36:56,260 --> 00:37:01,720
watching sports on TV or something so as

00:36:58,330 --> 00:37:03,640
I step step step that's it that's the

00:37:01,720 --> 00:37:05,260
corruption happening right there let's

00:37:03,640 --> 00:37:06,850
just back up a bit and see if we can see

00:37:05,260 --> 00:37:09,130
what's what's going on so writing square

00:37:06,850 --> 00:37:11,230
root of Jason's and operand adjacent

00:37:09,130 --> 00:37:15,220
into my cache and I can see here that's

00:37:11,230 --> 00:37:16,450
that our parent adjacent is minus one so

00:37:15,220 --> 00:37:17,200
I've tried to take the square root of

00:37:16,450 --> 00:37:19,090
negative one

00:37:17,200 --> 00:37:20,500
you can't do that with integers hence

00:37:19,090 --> 00:37:22,360
the since that's garbage

00:37:20,500 --> 00:37:24,010
what's going on there why's that

00:37:22,360 --> 00:37:26,170
happened well let's just add another

00:37:24,010 --> 00:37:28,750
watch point to that and go back again

00:37:26,170 --> 00:37:30,840
and okay it's being set here so operator

00:37:28,750 --> 00:37:34,600
Jason is being said to operand minus one

00:37:30,840 --> 00:37:35,770
operand is zero so what the program

00:37:34,600 --> 00:37:37,810
tried to be smart just trying to

00:37:35,770 --> 00:37:40,030
populate one entry either side in the

00:37:37,810 --> 00:37:41,350
cache and that's cause when it called a

00:37:40,030 --> 00:37:42,580
function it returned the right thing or

00:37:41,350 --> 00:37:44,590
called the function with an argument at

00:37:42,580 --> 00:37:46,570
zero and it returns zero as it should

00:37:44,590 --> 00:37:48,700
have but by being smart with this

00:37:46,570 --> 00:37:50,170
locality of references it's its left one

00:37:48,700 --> 00:37:52,870
entry in the cache in a bad state and I

00:37:50,170 --> 00:37:54,280
didn't notice for some time later so

00:37:52,870 --> 00:37:58,840
that's kind of what you can do with

00:37:54,280 --> 00:37:59,860
these replay systems and so essentially

00:37:58,840 --> 00:38:01,930
what we're saying is you can go back to

00:37:59,860 --> 00:38:05,140
any instruction that executed and you

00:38:01,930 --> 00:38:06,850
can see any piece of state right any any

00:38:05,140 --> 00:38:08,560
any value any piece of memory any

00:38:06,850 --> 00:38:10,750
register value for any instruction

00:38:08,560 --> 00:38:12,280
executed which clearly is just a huge

00:38:10,750 --> 00:38:14,800
amount of data or anything but the

00:38:12,280 --> 00:38:16,720
tiniest of programs right so clearly we

00:38:14,800 --> 00:38:18,730
can't store all of that even if we try

00:38:16,720 --> 00:38:20,890
to store just the diff just the Delta

00:38:18,730 --> 00:38:22,600
between what's changed each instruction

00:38:20,890 --> 00:38:23,770
that would still be way too much

00:38:22,600 --> 00:38:26,020
information right billions of

00:38:23,770 --> 00:38:28,960
instructions operating every second you

00:38:26,020 --> 00:38:31,300
know it's eight 16 32 byte record every

00:38:28,960 --> 00:38:33,310
every every nanosecond roughly that's

00:38:31,300 --> 00:38:37,450
just not gonna be practical either so

00:38:33,310 --> 00:38:39,970
what we do and this is true for our R

00:38:37,450 --> 00:38:42,640
and for live recorder what we do is to

00:38:39,970 --> 00:38:44,680
just capture non-deterministic stimuli

00:38:42,640 --> 00:38:46,240
and exploit the natural determinism of

00:38:44,680 --> 00:38:47,950
computer so I'm sticking stepping back

00:38:46,240 --> 00:38:49,640
in that demo what's happening under the

00:38:47,950 --> 00:38:51,680
hood is it's going back to us now

00:38:49,640 --> 00:38:54,560
and playing forwards to where it needs

00:38:51,680 --> 00:38:56,330
to be right and so we're recomputing

00:38:54,560 --> 00:39:00,670
previous States rather than trying to

00:38:56,330 --> 00:39:03,859
store everything now for that to work

00:39:00,670 --> 00:39:05,450
then we need to capture those sources

00:39:03,859 --> 00:39:07,550
that non-determinism right computers are

00:39:05,450 --> 00:39:09,710
completely deterministic except when

00:39:07,550 --> 00:39:11,570
they're not and for a user mode

00:39:09,710 --> 00:39:14,869
application you've got several sources

00:39:11,570 --> 00:39:16,880
of this non-determinism namely system

00:39:14,869 --> 00:39:18,950
calls threads which is signals

00:39:16,880 --> 00:39:21,050
asynchronous signals at least some

00:39:18,950 --> 00:39:22,430
instructions are non-deterministic so

00:39:21,050 --> 00:39:25,190
read the timestamp counter is an example

00:39:22,430 --> 00:39:28,310
in modern Intel's also have a get me a

00:39:25,190 --> 00:39:29,930
random number instruction and share

00:39:28,310 --> 00:39:31,490
memory access is shared with the process

00:39:29,930 --> 00:39:34,099
or shared with a device or something and

00:39:31,490 --> 00:39:35,510
so we have so it just but we just need

00:39:34,099 --> 00:39:38,000
to capture those which is typically a

00:39:35,510 --> 00:39:40,250
tiny tiny subset of what the program is

00:39:38,000 --> 00:39:42,560
doing and everything else can be can be

00:39:40,250 --> 00:39:44,869
recomputed now there's another problem

00:39:42,560 --> 00:39:46,400
though we need to know where we are in

00:39:44,869 --> 00:39:48,170
time when we're replaying so when I'm

00:39:46,400 --> 00:39:50,119
you know spin that down a steps forward

00:39:48,170 --> 00:39:51,740
line it has to stop at the right time it

00:39:50,119 --> 00:39:54,140
was inside loop you can't use a program

00:39:51,740 --> 00:39:55,700
counter because loops right so you have

00:39:54,140 --> 00:39:58,099
to know how far through the program we

00:39:55,700 --> 00:39:59,930
are not just so that we can step nicely

00:39:58,099 --> 00:40:01,700
with reverse step and things but so that

00:39:59,930 --> 00:40:03,470
we can replay signals and other

00:40:01,700 --> 00:40:05,810
asynchronous non-deterministic events at

00:40:03,470 --> 00:40:07,280
exactly the right time right it's the

00:40:05,810 --> 00:40:09,020
problem with this kind of technology is

00:40:07,280 --> 00:40:10,700
that if you get it even slightly wrong

00:40:09,020 --> 00:40:13,910
everything unravels

00:40:10,700 --> 00:40:15,349
very quickly this sort of like it's very

00:40:13,910 --> 00:40:16,940
kind of got to get everything you've got

00:40:15,349 --> 00:40:20,180
to capture and replay perfectly every

00:40:16,940 --> 00:40:22,700
single bit precisely the right time so

00:40:20,180 --> 00:40:25,790
RR is built on performance counters

00:40:22,700 --> 00:40:29,630
right so modern CPUs at least modern

00:40:25,790 --> 00:40:31,369
Intel CPUs have sufficiently accurate

00:40:29,630 --> 00:40:35,450
performance counters to count the number

00:40:31,369 --> 00:40:37,130
of retired taken branches that it can

00:40:35,450 --> 00:40:38,839
give you an accurate time how far you

00:40:37,130 --> 00:40:40,580
are to the program and these can be

00:40:38,839 --> 00:40:42,320
these can be exploited so they're nice

00:40:40,580 --> 00:40:44,330
and fast and that the program runs

00:40:42,320 --> 00:40:46,220
without instrumentation nice and simple

00:40:44,330 --> 00:40:48,200
we don't have to write too much code to

00:40:46,220 --> 00:40:49,700
take advantage of them and the only

00:40:48,200 --> 00:40:52,280
thing is they're not always available so

00:40:49,700 --> 00:40:54,710
they don't work on AMD CPUs they're not

00:40:52,280 --> 00:40:56,420
always available in the cloud they don't

00:40:54,710 --> 00:40:58,430
work on arm but where they are available

00:40:56,420 --> 00:41:01,330
they're very good but they also can't

00:40:58,430 --> 00:41:02,990
capture everything so things like gun

00:41:01,330 --> 00:41:06,140
share memory access

00:41:02,990 --> 00:41:09,410
is an asynchronous operations are

00:41:06,140 --> 00:41:10,730
problematic and they used the thing

00:41:09,410 --> 00:41:12,560
called the precision events based

00:41:10,730 --> 00:41:15,110
sampling PEVs in order to generate them

00:41:12,560 --> 00:41:17,600
and interrupt so I don't only need to

00:41:15,110 --> 00:41:19,640
know exactly where I am in the program I

00:41:17,600 --> 00:41:21,500
need to be able to go back to a precise

00:41:19,640 --> 00:41:24,260
state in the program and you can

00:41:21,500 --> 00:41:26,330
configure the Intel performance counters

00:41:24,260 --> 00:41:28,760
to generate an interrupt after a certain

00:41:26,330 --> 00:41:29,869
number of things have happened right and

00:41:28,760 --> 00:41:32,119
so that's how they do that

00:41:29,869 --> 00:41:35,390
whereas with live recorder which is from

00:41:32,119 --> 00:41:37,940
from undo we use a JIT and we binary

00:41:35,390 --> 00:41:41,080
translate there the the machine code is

00:41:37,940 --> 00:41:43,040
running which does impose more overhead

00:41:41,080 --> 00:41:44,000
but does have the advantage you're not

00:41:43,040 --> 00:41:46,280
relying on these things that aren't

00:41:44,000 --> 00:41:47,780
always there and can cover cases like

00:41:46,280 --> 00:41:50,210
share memory and a nice and clear stuff

00:41:47,780 --> 00:41:51,350
but that but basically they're kind of

00:41:50,210 --> 00:41:52,640
the same but they're just using

00:41:51,350 --> 00:41:57,140
different techniques to get the same

00:41:52,640 --> 00:41:58,490
information that we that we need so

00:41:57,140 --> 00:42:01,100
that's it for my very quick run-through

00:41:58,490 --> 00:42:03,560
of those various types of tools I now

00:42:01,100 --> 00:42:09,380
like to hand over to d'Alene who's gonna

00:42:03,560 --> 00:42:11,119
talk about Coverity static analysis all

00:42:09,380 --> 00:42:12,920
right before start a real quick question

00:42:11,119 --> 00:42:15,830
for you guys what do you think will be

00:42:12,920 --> 00:42:21,380
the coolest way to make money for C++

00:42:15,830 --> 00:42:25,609
programmers inheritance of course it's

00:42:21,380 --> 00:42:26,930
free and efficient right ok well the

00:42:25,609 --> 00:42:31,400
second I'm going to talk about static

00:42:26,930 --> 00:42:34,700
analysis a Greg said I work for synopsis

00:42:31,400 --> 00:42:37,880
and I support the product Coverity it's

00:42:34,700 --> 00:42:41,930
a static analyzer so I do static

00:42:37,880 --> 00:42:44,960
analyzers do well what they do is they

00:42:41,930 --> 00:42:48,470
take source code okay

00:42:44,960 --> 00:42:51,050
in case of languages like C C++

00:42:48,470 --> 00:42:53,240
they will compile them and then generate

00:42:51,050 --> 00:42:56,420
a semantic representation that includes

00:42:53,240 --> 00:42:59,090
a abstract syntax tree various call

00:42:56,420 --> 00:43:01,550
graph elements right and then compute

00:42:59,090 --> 00:43:03,590
you know different paths and then go

00:43:01,550 --> 00:43:05,750
through those paths and find problems in

00:43:03,590 --> 00:43:08,450
your code alright so all of this is

00:43:05,750 --> 00:43:11,480
computed and this is done statically and

00:43:08,450 --> 00:43:15,710
it's not during runtime right so when it

00:43:11,480 --> 00:43:16,859
finds problems they will present I know

00:43:15,710 --> 00:43:19,499
it's not readable I took

00:43:16,859 --> 00:43:22,499
like in red it's like annotation of

00:43:19,499 --> 00:43:26,039
steps which leads to the ultimate

00:43:22,499 --> 00:43:29,219
problem in your code yeah and then the

00:43:26,039 --> 00:43:32,729
these defects are very consumable in

00:43:29,219 --> 00:43:35,599
various formats if you are running the

00:43:32,729 --> 00:43:38,910
static analyzer on command-line you know

00:43:35,599 --> 00:43:42,059
print on the command line if you're

00:43:38,910 --> 00:43:45,089
using some IDE the analyzer can often be

00:43:42,059 --> 00:43:47,539
driven in sorry IDE so so your code will

00:43:45,089 --> 00:43:50,880
be overlaid with the problems you find

00:43:47,539 --> 00:43:54,680
it's pretty trivial to push the results

00:43:50,880 --> 00:43:59,910
into code reviews pull requests right

00:43:54,680 --> 00:44:03,690
and you know there are quite a few

00:43:59,910 --> 00:44:05,729
static analyzers in our industry and so

00:44:03,690 --> 00:44:08,190
the way I kind of like to think about

00:44:05,729 --> 00:44:10,049
setting analyzer is this way I mean what

00:44:08,190 --> 00:44:12,150
is the main motivation behind that

00:44:10,049 --> 00:44:14,519
static analyzer and whether that

00:44:12,150 --> 00:44:17,969
analyzer automatically is your friend or

00:44:14,519 --> 00:44:20,489
not okay so there there's a group of

00:44:17,969 --> 00:44:22,829
them where their attempt is to find

00:44:20,489 --> 00:44:25,469
anything that can potentially go wrong

00:44:22,829 --> 00:44:28,140
with your code okay where the false

00:44:25,469 --> 00:44:31,650
positive rate can be as high as 80 to 90

00:44:28,140 --> 00:44:34,859
percent so that class of Sena analyzer

00:44:31,650 --> 00:44:37,410
is typically used mostly for security

00:44:34,859 --> 00:44:39,809
researchers okay so they need to look at

00:44:37,410 --> 00:44:42,329
all possibilities find the research and

00:44:39,809 --> 00:44:42,749
then kind of find the needle in a

00:44:42,329 --> 00:44:45,569
haystack

00:44:42,749 --> 00:44:48,599
right so if you are using static

00:44:45,569 --> 00:44:50,940
analyzer today and you end up facing

00:44:48,599 --> 00:44:52,680
with too many false positives just

00:44:50,940 --> 00:44:54,630
remember that's not your friend because

00:44:52,680 --> 00:44:56,640
if you are charging everything that's in

00:44:54,630 --> 00:44:58,440
there you're gonna do mean the work of

00:44:56,640 --> 00:45:00,989
the security researcher right then you

00:44:58,440 --> 00:45:03,089
don't have time to code okay and I'll

00:45:00,989 --> 00:45:04,769
say the other class is what's already

00:45:03,089 --> 00:45:07,650
building when you're compiling with you

00:45:04,769 --> 00:45:09,509
with your tool chain I say those are

00:45:07,650 --> 00:45:11,009
your friend but I think they're

00:45:09,509 --> 00:45:12,390
typically focused on trying to get you

00:45:11,009 --> 00:45:15,509
something quick right there

00:45:12,390 --> 00:45:16,430
right and then I'll say the last class

00:45:15,509 --> 00:45:18,930
of

00:45:16,430 --> 00:45:21,809
analyzers do tend to be much more

00:45:18,930 --> 00:45:25,199
conservative right they gotta have very

00:45:21,809 --> 00:45:28,799
strong evidence before they put into a

00:45:25,199 --> 00:45:33,109
report that it's a defect yeah and I

00:45:28,799 --> 00:45:33,109
would say that class make that your best

00:45:35,330 --> 00:45:41,190
so I'll quickly go through this so I

00:45:38,640 --> 00:45:44,070
don't know if you read this paper this

00:45:41,190 --> 00:45:46,940
is back in 2002 Linux kernel version 2.2

00:45:44,070 --> 00:45:49,410
a research work at Stanford where they

00:45:46,940 --> 00:45:52,140
created this was the original version of

00:45:49,410 --> 00:45:54,690
Coverity actually they found two hundred

00:45:52,140 --> 00:45:59,070
several hundred very important defects

00:45:54,690 --> 00:46:02,070
in the Linux kernel and you know this is

00:45:59,070 --> 00:46:04,830
like many many years ago so since then

00:46:02,070 --> 00:46:06,870
we have come a really long way the Linux

00:46:04,830 --> 00:46:09,630
kernel team still uses Coverity today

00:46:06,870 --> 00:46:13,590
pretty judiciously actually I should ask

00:46:09,630 --> 00:46:14,940
anybody here work on the kernel okay we

00:46:13,590 --> 00:46:19,340
have a hand there or actually we're just

00:46:14,940 --> 00:46:19,340
giving about round of applause because

00:46:19,820 --> 00:46:24,090
that community they're kind of my heroes

00:46:22,260 --> 00:46:25,590
right if you look at our planet that's

00:46:24,090 --> 00:46:29,370
probably one of the most important code

00:46:25,590 --> 00:46:31,710
bases you know we have yeah but it's

00:46:29,370 --> 00:46:33,300
very public if you if you go into get

00:46:31,710 --> 00:46:34,680
log and then do a keyword search on

00:46:33,300 --> 00:46:37,860
Coverity you'll see thousands of

00:46:34,680 --> 00:46:40,530
references of Coverity they like a

00:46:37,860 --> 00:46:42,270
Verity they give credit to Coverity when

00:46:40,530 --> 00:46:44,580
they're fixing stuff based on what

00:46:42,270 --> 00:46:48,240
career Lee has found for them so um

00:46:44,580 --> 00:46:50,670
you'll see there's a table right here on

00:46:48,240 --> 00:46:53,160
the left column is a list of checkers so

00:46:50,670 --> 00:46:55,140
these are top checkers in terms of total

00:46:53,160 --> 00:46:57,810
number of issues that team has fixed and

00:46:55,140 --> 00:47:00,690
I pulled this data back earlier this

00:46:57,810 --> 00:47:03,420
year March 2019 so you'll see like the

00:47:00,690 --> 00:47:06,570
third one dead code that usually means

00:47:03,420 --> 00:47:08,100
like you have a if some logical

00:47:06,570 --> 00:47:09,960
expression and then there's a blocker

00:47:08,100 --> 00:47:12,510
code right but if that logical

00:47:09,960 --> 00:47:14,880
expression can never ever return true

00:47:12,510 --> 00:47:16,680
then that blocker code becomes dead code

00:47:14,880 --> 00:47:18,930
right so that means that developer

00:47:16,680 --> 00:47:21,900
hasn't made a mistake in their in their

00:47:18,930 --> 00:47:26,130
thinking yeah so you can see that for

00:47:21,900 --> 00:47:28,650
dead code the kernel team has fixed 968

00:47:26,130 --> 00:47:33,750
to date right

00:47:28,650 --> 00:47:35,820
64 dismissed right so 486 outstanding so

00:47:33,750 --> 00:47:37,770
I'll standing usually based on what I

00:47:35,820 --> 00:47:40,260
know is usually in areas where they

00:47:37,770 --> 00:47:41,700
don't care that much right but you but

00:47:40,260 --> 00:47:44,100
the thing that I want to highlight for

00:47:41,700 --> 00:47:45,109
you guys is the dismiss rate itself it's

00:47:44,100 --> 00:47:49,619
it's really

00:47:45,109 --> 00:47:51,770
okay yeah so if you guys are using a

00:47:49,619 --> 00:47:56,820
cell analyzer have this kind of rate

00:47:51,770 --> 00:47:58,230
remember that that's your friend okay so

00:47:56,820 --> 00:48:01,859
now I want to get under the hood a

00:47:58,230 --> 00:48:04,500
little bit about static analysis so on

00:48:01,859 --> 00:48:08,369
the left hand side is an example code

00:48:04,500 --> 00:48:10,590
where it's it's being annotated with a

00:48:08,369 --> 00:48:13,080
problem and on the right hand side is

00:48:10,590 --> 00:48:16,260
actually an example checker

00:48:13,080 --> 00:48:18,869
it's a domain you know it's a functional

00:48:16,260 --> 00:48:20,910
language Coverity has actually recently

00:48:18,869 --> 00:48:24,090
started opening up the analysis engine

00:48:20,910 --> 00:48:26,250
the ast that the call Co graph to

00:48:24,090 --> 00:48:29,700
developers so then you can create your

00:48:26,250 --> 00:48:33,330
own custom analysis you will

00:48:29,700 --> 00:48:36,660
okay so I'll walk you guys through um so

00:48:33,330 --> 00:48:39,750
on the Left right this is a very simple

00:48:36,660 --> 00:48:43,560
problem we have malloc here why we have

00:48:39,750 --> 00:48:46,440
a if it's outer even number here just

00:48:43,560 --> 00:48:49,800
kind of random if it's odd then we will

00:48:46,440 --> 00:48:52,589
free the allocated memory right

00:48:49,800 --> 00:48:55,800
otherwise when it when it goes out of

00:48:52,589 --> 00:48:58,200
scope you know then you have a leak okay

00:48:55,800 --> 00:49:03,180
so let's have a look at to see how the

00:48:58,200 --> 00:49:06,180
checker looks like so the way the way to

00:49:03,180 --> 00:49:10,940
think about this is to say okay I'm

00:49:06,180 --> 00:49:15,660
going to define a pattern where it is a

00:49:10,940 --> 00:49:18,510
step in the car graph okay and then

00:49:15,660 --> 00:49:22,440
where it's a function call the function

00:49:18,510 --> 00:49:25,080
identifier is Malik okay and then

00:49:22,440 --> 00:49:27,780
similarly we're gonna look for a step in

00:49:25,080 --> 00:49:29,760
a call graph where it's a call to free

00:49:27,780 --> 00:49:35,940
where the function identifier is free

00:49:29,760 --> 00:49:38,760
okay ignore the rest okay and then now

00:49:35,940 --> 00:49:42,119
if you think about this we really need

00:49:38,760 --> 00:49:43,440
to match the allocation versus of free

00:49:42,119 --> 00:49:45,990
right you cannot just take random

00:49:43,440 --> 00:49:48,869
allocation and random free and what they

00:49:45,990 --> 00:49:51,240
don't line up right they don't reference

00:49:48,869 --> 00:49:53,550
the same object or memory right so the

00:49:51,240 --> 00:49:57,240
trick is to line up the password the

00:49:53,550 --> 00:50:00,420
object you you care about

00:49:57,240 --> 00:50:03,150
it's lined up yeah so there's a feature

00:50:00,420 --> 00:50:06,930
in our code accent where we could say

00:50:03,150 --> 00:50:12,150
that called expression e whatever the

00:50:06,930 --> 00:50:16,230
point is becomes the key okay

00:50:12,150 --> 00:50:18,569
so then and then here's a checker itself

00:50:16,230 --> 00:50:21,180
now so I could give the name to the

00:50:18,569 --> 00:50:23,250
checker right and then so then what the

00:50:21,180 --> 00:50:25,530
trigger does is to say okay for all

00:50:23,250 --> 00:50:29,609
functions and global set such as all

00:50:25,530 --> 00:50:34,190
functions we're all part evolving the

00:50:29,609 --> 00:50:34,190
function where it matches the sequence

00:50:35,839 --> 00:50:43,559
right you have at one point a lock and

00:50:39,630 --> 00:50:45,329
then this arrow looking thing this can

00:50:43,559 --> 00:50:47,220
be can be chained together so if you

00:50:45,329 --> 00:50:50,099
have multiple call sequence you care

00:50:47,220 --> 00:50:54,230
about and then where there is no call to

00:50:50,099 --> 00:51:04,589
free right easy enough right

00:50:54,230 --> 00:51:06,839
okay yeah okay so before I get to before

00:51:04,589 --> 00:51:12,210
I get to the demo I just want to give

00:51:06,839 --> 00:51:14,130
you a flavor for like you know why or

00:51:12,210 --> 00:51:17,400
when you might use something like this

00:51:14,130 --> 00:51:20,069
right so I was working with a customer

00:51:17,400 --> 00:51:22,619
really big cloud company there have a

00:51:20,069 --> 00:51:25,280
security policy to say anything that

00:51:22,619 --> 00:51:27,290
goes into storage must be encrypted

00:51:25,280 --> 00:51:29,490
right so you can imagine how to

00:51:27,290 --> 00:51:32,280
implement a checker similar to this

00:51:29,490 --> 00:51:36,210
right then is just start with function

00:51:32,280 --> 00:51:38,819
patterns where oh five more minutes okay

00:51:36,210 --> 00:51:41,190
so the use case will be very simple

00:51:38,819 --> 00:51:44,099
where if you track all the operations

00:51:41,190 --> 00:51:47,280
where you can cause a right to to

00:51:44,099 --> 00:51:50,069
storage right and you look up in the car

00:51:47,280 --> 00:51:52,109
graph that's where this function exists

00:51:50,069 --> 00:51:54,660
and then if there's an encryption

00:51:52,109 --> 00:51:55,770
operation right and then furthermore you

00:51:54,660 --> 00:51:57,510
want to make sure that the encryption

00:51:55,770 --> 00:51:59,490
happens to the same object

00:51:57,510 --> 00:52:01,049
now you lined up so every pass that

00:51:59,490 --> 00:52:03,630
comes through that does not have that

00:52:01,049 --> 00:52:07,559
encryption done then that's a problem

00:52:03,630 --> 00:52:10,890
right so like if you are doing code

00:52:07,559 --> 00:52:12,359
reviews right here you frequently chasm

00:52:10,890 --> 00:52:14,460
people you see review comments like

00:52:12,359 --> 00:52:17,549
don't do this and don't do that don't do

00:52:14,460 --> 00:52:19,920
this in this context or what not that's

00:52:17,549 --> 00:52:25,289
a good time to use something like this

00:52:19,920 --> 00:52:28,950
okay so really quick on demo so you can

00:52:25,289 --> 00:52:30,930
see how this looks so this is command

00:52:28,950 --> 00:52:36,150
line so Coverity has a bill wrapper

00:52:30,930 --> 00:52:38,010
cocoa build where we say this is what we

00:52:36,150 --> 00:52:41,549
want to put the capture code and then

00:52:38,010 --> 00:52:46,019
you can put the comes out to man like

00:52:41,549 --> 00:52:48,200
this it's not on the screen oh okay

00:52:46,019 --> 00:52:48,200
great

00:52:50,359 --> 00:52:57,510
all right so um I would hate a command

00:52:53,400 --> 00:52:59,849
like this so the build the bill wrapper

00:52:57,510 --> 00:53:01,589
will monitor the compile so anything

00:52:59,849 --> 00:53:03,690
that gets compiled it will pick up and

00:53:01,589 --> 00:53:05,369
Coverity understand all the compiled

00:53:03,690 --> 00:53:07,529
flags and then so it knows how to

00:53:05,369 --> 00:53:09,359
compile and generate the semantic

00:53:07,529 --> 00:53:15,619
representation that's exactly equal to

00:53:09,359 --> 00:53:18,619
your code so like this year this is come

00:53:15,619 --> 00:53:18,619
okay

00:53:26,360 --> 00:53:32,410
okay this is better apologize

00:53:50,220 --> 00:53:55,680
tastes that better okay so you could

00:53:52,890 --> 00:53:57,750
replace the CL here with C make maven or

00:53:55,680 --> 00:54:00,119
whatever bill you have so everything

00:53:57,750 --> 00:54:12,569
that's that's a gets touched will

00:54:00,119 --> 00:54:17,220
automatically get up so so in this case

00:54:12,569 --> 00:54:19,260
I don't have one compiled so we can you

00:54:17,220 --> 00:54:24,420
can see it there so then we can do carve

00:54:19,260 --> 00:54:27,960
analyze just like that so here it will

00:54:24,420 --> 00:54:30,059
compute the car grass and ASD and all

00:54:27,960 --> 00:54:32,579
that and then run the analysis so this

00:54:30,059 --> 00:54:34,650
resource league is is a default checker

00:54:32,579 --> 00:54:37,319
that that comes with Coverity it's

00:54:34,650 --> 00:54:40,200
already found that so so the question is

00:54:37,319 --> 00:54:48,960
how do we trigger that custom checker I

00:54:40,200 --> 00:54:50,339
show you earlier so we do this so I'm

00:54:48,960 --> 00:54:52,410
going to disable all the default

00:54:50,339 --> 00:54:55,859
checkers that comes to Coverity and I'm

00:54:52,410 --> 00:55:03,809
gonna just enable that particular custom

00:54:55,859 --> 00:55:10,309
checker I show you earlier okay and then

00:55:03,809 --> 00:55:10,309
if I want to look at that issue locally

00:55:28,350 --> 00:55:34,450
and you'll see that the checker name

00:55:31,570 --> 00:55:46,060
here right came from the custom checker

00:55:34,450 --> 00:55:48,450
so yeah and notice right you get several

00:55:46,060 --> 00:55:51,730
things automatically you'll notice that

00:55:48,450 --> 00:55:53,590
in this particular branch where it is

00:55:51,730 --> 00:55:55,180
taking the false branch so that's when

00:55:53,590 --> 00:55:57,310
you when you go out of scope you're

00:55:55,180 --> 00:55:59,320
gonna have the leak right you notice I

00:55:57,310 --> 00:56:02,080
didn't do anything that had to do with

00:55:59,320 --> 00:56:04,420
this conditional branch right here right

00:56:02,080 --> 00:56:06,070
that's because Coverity in the

00:56:04,420 --> 00:56:10,930
background when it computes all these

00:56:06,070 --> 00:56:13,480
paths the paths already pre computed so

00:56:10,930 --> 00:56:16,390
when I when I expressed that this is

00:56:13,480 --> 00:56:17,740
particular sequence I care about I don't

00:56:16,390 --> 00:56:19,840
need to worry about these different

00:56:17,740 --> 00:56:22,750
paths right so it it knows how to

00:56:19,840 --> 00:56:28,210
evaluate this I ma 2 equals 1 for

00:56:22,750 --> 00:56:32,710
example yeah okay yep so so that's study

00:56:28,210 --> 00:56:34,150
analysis if we have one or two really

00:56:32,710 --> 00:56:37,660
quick questions

00:56:34,150 --> 00:56:39,610
I'm seeing a science session is over but

00:56:37,660 --> 00:56:42,120
yeah alright so wherever but thank you

00:56:39,610 --> 00:56:42,120

YouTube URL: https://www.youtube.com/watch?v=WoRmXjVxuFQ


