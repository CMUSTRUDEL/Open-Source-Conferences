Title: CppCon 2019: JeanHeyd Meneide “Catch ⬆️: Unicode for C++23”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
It's 2019 and Unicode is still barely supported in both the C and C++ standards.

From the POSIX standard requiring a single-byte encoding by default, heavy limitations placed in codecvt facets in C++, and the utter lack of UTF8/16/32 multi-unit conversion functions by the standard, the programming languages that have shaped the face of development from operating systems, embedded devices and mobile applications has pushed forward a world that is incredibly unfriendly to a world of text beyond ASCII. Developers frequently roll their own solutions, and almost every major codebase -- from Chrome to Firefox to Qt to Copperspice and more -- all have their own variations of hand-crafted text processing. With no standard implementation in C++ and libraries split between various third party implementations and ICU, it is increasingly difficult and error-prone to handle what is the basic means of communication between people on the planet using C++, let alone the security holes found in hand-rolled libraries that do not carefully handle this tricky design space.

Small victories for character types that represent UTF8 exclusively, mandated UTF16 and UTF32 encoding for literals, and updating the Unicode Standard Reference in C++ have been accomplished by Study Group 16, who are the Unicode Arm of Standard C++. With the last of the foundational work to the C standards committee underway and participation from individuals at Mozilla, Google, Qt, Microsoft, Bloomberg, and Apple informing the design, Unicode in C++ is planned to be the biggest and best addition of first-class support for Unicode in C++.

This talk is going to be an overview of the problem space -- Text in C++ -- the people who are tackling the problem -- Study Group 16 -- and the first major libraries and works to be produced for handling encoding and normalization both flexibly and efficiently. It will talk about what we learned from its predecessors -- Boost.Text, text_view, ICU and Ogonek -- and what can be reasonably expected for C++23 and what aspirations SG16 has for the future. Come see the new face of a range-friendly encoding, decoding and normalization interfaces in C++.
— 
JeanHeyd Meneide
Columbia Unviersity
Student

JeanHeyd "ThePhD" is a student at Columbia University in New York. Most of his programming is for fun and as a hobby, even if his largest open-source contribution -- sol2 -- is used across many industries. He is currently working towards earning his own nickname, climbing the academic ladder while spending as much time as possible contributing to C++ standardization and development.

He very much loves dogs and hopes to have his own in a year or so. He also likes Vulf's "Tee Time" from the album Mr. Finish Line.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,049 --> 00:00:13,639
all right well good afternoon everybody

00:00:11,240 --> 00:00:17,960
my name is John Keefe indeed otherwise

00:00:13,639 --> 00:00:21,500
known as a PhD I am a student who spends

00:00:17,960 --> 00:00:22,610
a lot of time working with you know make

00:00:21,500 --> 00:00:25,250
various different libraries whether it's

00:00:22,610 --> 00:00:26,900
bits or Lua or wherever else and now I

00:00:25,250 --> 00:00:29,900
kind of turned my attention towards

00:00:26,900 --> 00:00:33,860
Unicode and so what this talk is going

00:00:29,900 --> 00:00:37,100
to be about is is the plan that study

00:00:33,860 --> 00:00:38,359
group 16 the Unicode are most cs+ it is

00:00:37,100 --> 00:00:40,249
trying to come up with to fix a lot of

00:00:38,359 --> 00:00:47,510
the problems that Unicode and text

00:00:40,249 --> 00:00:50,359
encoding and handling have in C++ so you

00:00:47,510 --> 00:00:52,309
know obviously 20 is 2019 right now and

00:00:50,359 --> 00:00:54,589
the story for kind of Unicode and see if

00:00:52,309 --> 00:00:58,339
those plus is that it's a it's really

00:00:54,589 --> 00:01:00,859
bad um we we had things like W string

00:00:58,339 --> 00:01:02,089
convert in the standard of a short while

00:01:00,859 --> 00:01:03,649
ago but we kind of need to pull that out

00:01:02,089 --> 00:01:04,850
because it was really bad at performance

00:01:03,649 --> 00:01:06,380
and it was kind of poorly implemented

00:01:04,850 --> 00:01:09,470
mostly because of things like stood

00:01:06,380 --> 00:01:10,969
locale the general code convert and the

00:01:09,470 --> 00:01:13,549
facets on streams and everything else

00:01:10,969 --> 00:01:15,020
are kind of really bad to use the

00:01:13,549 --> 00:01:16,280
virtual interfaces it's hard to have

00:01:15,020 --> 00:01:19,430
data apply more for more data type

00:01:16,280 --> 00:01:23,119
extension and in more or less it's it's

00:01:19,430 --> 00:01:26,270
been very very painful trying to get any

00:01:23,119 --> 00:01:27,469
sort of unicode support into the

00:01:26,270 --> 00:01:31,310
standard or into any of our current

00:01:27,469 --> 00:01:32,750
interfaces and so what what makes text

00:01:31,310 --> 00:01:34,159
inversion hard right so there you know

00:01:32,750 --> 00:01:35,210
obviously they're streams there's faster

00:01:34,159 --> 00:01:37,100
dub you string that we're at need to be

00:01:35,210 --> 00:01:39,920
pulled out of standard but what other

00:01:37,100 --> 00:01:44,780
things really make text and encoding and

00:01:39,920 --> 00:01:48,259
all these things difficult in C++ so one

00:01:44,780 --> 00:01:51,710
of the biggest problems is that locale

00:01:48,259 --> 00:01:55,369
and encoding are sort of completed

00:01:51,710 --> 00:01:57,170
together so every time you ever stood

00:01:55,369 --> 00:02:00,560
locale objects that look how object you

00:01:57,170 --> 00:02:02,090
know strips ships with it the idea of

00:02:00,560 --> 00:02:03,679
not only an encoding but a bunch of

00:02:02,090 --> 00:02:05,270
other things that are allowed related to

00:02:03,679 --> 00:02:07,700
like internationalization and

00:02:05,270 --> 00:02:10,280
localization so for example if you're

00:02:07,700 --> 00:02:12,050
using a dots of a comma money

00:02:10,280 --> 00:02:14,990
punctuation and all these things are

00:02:12,050 --> 00:02:18,170
kind of stored in the locale but when

00:02:14,990 --> 00:02:19,370
you do that right you you tied together

00:02:18,170 --> 00:02:23,330
this idea that

00:02:19,370 --> 00:02:26,450
every single internationalization entity

00:02:23,330 --> 00:02:29,269
also needs some locale with it and also

00:02:26,450 --> 00:02:31,519
needs own encoding with it and so when

00:02:29,269 --> 00:02:34,010
you have that strong coupling between an

00:02:31,519 --> 00:02:36,440
encoding and a locale you end up having

00:02:34,010 --> 00:02:38,379
a situation where every single locale

00:02:36,440 --> 00:02:40,400
for all different cultures in the world

00:02:38,379 --> 00:02:41,690
tend to roll their own encoding and

00:02:40,400 --> 00:02:44,540
that's kind of how what they did for a

00:02:41,690 --> 00:02:46,280
very long time you know just a couple

00:02:44,540 --> 00:02:48,260
examples right if you if you have a file

00:02:46,280 --> 00:02:49,879
and you you know you have non ASCII

00:02:48,260 --> 00:02:51,950
bytes and you save it in Germany and you

00:02:49,879 --> 00:02:53,630
ship it to Japan I mean you might as

00:02:51,950 --> 00:02:55,579
well you know just just start crying

00:02:53,630 --> 00:02:57,829
when the Pug reports start rolling in

00:02:55,579 --> 00:02:59,329
if you slash utf-8 in an MS PC which is

00:02:57,829 --> 00:03:01,519
like the way right what you're supposed

00:02:59,329 --> 00:03:03,680
to do but you forget to save your file

00:03:01,519 --> 00:03:06,110
as utf-8 in your editor you're gonna

00:03:03,680 --> 00:03:08,209
have a really bad time and of course if

00:03:06,110 --> 00:03:09,739
you just generally just ship code to a

00:03:08,209 --> 00:03:12,620
platform that you don't completely own

00:03:09,739 --> 00:03:14,680
right locale is different and you know

00:03:12,620 --> 00:03:18,769
there's tons of bugs whether it's in

00:03:14,680 --> 00:03:21,230
video players or VLC or just anything

00:03:18,769 --> 00:03:22,970
where you know it's very hard to

00:03:21,230 --> 00:03:24,650
reproduce a bug let's locale dependent

00:03:22,970 --> 00:03:27,290
because you open up on your machine

00:03:24,650 --> 00:03:28,850
nothing about the the C API is the seats

00:03:27,290 --> 00:03:31,010
plus API is really tell you that they're

00:03:28,850 --> 00:03:32,690
using the locale and so you have all

00:03:31,010 --> 00:03:34,670
this locale dependent behavior that you

00:03:32,690 --> 00:03:36,200
just kind of magically assumed work in

00:03:34,670 --> 00:03:37,609
your your beautiful you know

00:03:36,200 --> 00:03:39,079
nice English PC and then you ship it

00:03:37,609 --> 00:03:40,130
over to Turkey you ship it over to China

00:03:39,079 --> 00:03:41,810
should put over to India

00:03:40,130 --> 00:03:42,950
parse things differently it handled

00:03:41,810 --> 00:03:45,470
numbers differently and everything went

00:03:42,950 --> 00:03:49,329
down the toilet so this is like a really

00:03:45,470 --> 00:03:52,519
really big problem the other problem is

00:03:49,329 --> 00:03:55,519
what what is the encoding so its title

00:03:52,519 --> 00:03:57,079
locale but it's it's it's even if you

00:03:55,519 --> 00:03:59,359
want it even if you want to try and

00:03:57,079 --> 00:04:01,459
figure out it's impossible because for

00:03:59,359 --> 00:04:03,470
things like carve the narrow encoding

00:04:01,459 --> 00:04:04,700
its whatever system feels I got the moon

00:04:03,470 --> 00:04:06,169
right so you can change it with the lang

00:04:04,700 --> 00:04:08,000
environment variable you can use set

00:04:06,169 --> 00:04:09,709
locale during runtime and it's not just

00:04:08,000 --> 00:04:11,359
you you set locale and your program

00:04:09,709 --> 00:04:12,349
during one time like some library out

00:04:11,359 --> 00:04:13,910
there over there and one of your

00:04:12,349 --> 00:04:15,290
dependencies call set locale it changes

00:04:13,910 --> 00:04:17,299
it for everything because it changed it

00:04:15,290 --> 00:04:19,039
for the whole process the active code

00:04:17,299 --> 00:04:21,440
page on windows you know the fact that

00:04:19,039 --> 00:04:22,910
your computer that you you you opened up

00:04:21,440 --> 00:04:24,289
and boot it up your computer and set it

00:04:22,910 --> 00:04:25,280
all up in France and you move to the US

00:04:24,289 --> 00:04:28,280
you're wondering why are a couple things

00:04:25,280 --> 00:04:30,530
not working quite right all these things

00:04:28,280 --> 00:04:31,460
right and you would think that w Carty

00:04:30,530 --> 00:04:34,250
which was the supposed to be the

00:04:31,460 --> 00:04:36,830
solution to this would be better and it

00:04:34,250 --> 00:04:38,630
kind of was right so utf-16 is what

00:04:36,830 --> 00:04:41,090
Windows and IBM had to kind of settle on

00:04:38,630 --> 00:04:45,289
for W Carty and most other systems use

00:04:41,090 --> 00:04:46,880
utf-32 except that IBM platforms if

00:04:45,289 --> 00:04:49,900
they're compiled for 64-bit choose the

00:04:46,880 --> 00:04:52,669
utf-32 and then use utf-16 otherwise

00:04:49,900 --> 00:04:54,260
except if you're on a Chinese locale and

00:04:52,669 --> 00:04:56,270
they pick some other flavor a big five

00:04:54,260 --> 00:04:58,219
or one of the gpk encodings

00:04:56,270 --> 00:05:01,190
so even the thing that supposed to solve

00:04:58,219 --> 00:05:03,380
the problem didn't solve the problem and

00:05:01,190 --> 00:05:05,300
so we're still kind of back in the back

00:05:03,380 --> 00:05:06,800
and the problems like what when you have

00:05:05,300 --> 00:05:08,060
a literal when you have a string later

00:05:06,800 --> 00:05:09,469
when you have a wide string literal what

00:05:08,060 --> 00:05:11,510
does that mean what is he encoding and

00:05:09,469 --> 00:05:15,280
the answer is whatever your compiler

00:05:11,510 --> 00:05:15,280
decided and whatever your system decided

00:05:16,240 --> 00:05:20,210
so you know again we wanted to have the

00:05:18,620 --> 00:05:22,430
Unicode literals right so we created

00:05:20,210 --> 00:05:23,979
these these Unicode the rules for car 16

00:05:22,430 --> 00:05:28,280
card 32 T which you would think

00:05:23,979 --> 00:05:29,360
naturally should be utf-16 utf-32 turns

00:05:28,280 --> 00:05:31,520
that's actually not the case there's

00:05:29,360 --> 00:05:33,530
these two macros that can tell you

00:05:31,520 --> 00:05:35,450
whether or not you actually have utf-16

00:05:33,530 --> 00:05:37,340
or utf-32

00:05:35,450 --> 00:05:39,349
the good news is is that we've surveyed

00:05:37,340 --> 00:05:40,820
like you know almost a hundred different

00:05:39,349 --> 00:05:42,289
compilers and a bunch of different

00:05:40,820 --> 00:05:44,479
places and turns out that everybody

00:05:42,289 --> 00:05:46,940
thankfully did the same thing and pick

00:05:44,479 --> 00:05:50,570
utf-16 for car 16 T and utf-32 for car

00:05:46,940 --> 00:05:53,750
32 T so what happened is is that robot

00:05:50,570 --> 00:05:56,330
martino fernandez he submitted a paper p

00:05:53,750 --> 00:05:57,440
1041 that basically said listen let's

00:05:56,330 --> 00:05:58,820
just be explicit the standard let's not

00:05:57,440 --> 00:06:00,650
have this waffle wording let's not you

00:05:58,820 --> 00:06:02,360
know try to describe surrogate pairs

00:06:00,650 --> 00:06:04,070
without talking about real surrogate

00:06:02,360 --> 00:06:05,870
pairs that come from utf-16 or any of

00:06:04,070 --> 00:06:08,030
that right let's just make them utf-16

00:06:05,870 --> 00:06:09,080
and utf-32 and so we did that and so

00:06:08,030 --> 00:06:12,800
thanks

00:06:09,080 --> 00:06:14,960
that really helps right the other

00:06:12,800 --> 00:06:16,880
problem is right maybe we think about

00:06:14,960 --> 00:06:18,380
like streams right io streams and i

00:06:16,880 --> 00:06:20,090
talked a little bit about that but the

00:06:18,380 --> 00:06:21,770
problem with io streams is that we've

00:06:20,090 --> 00:06:23,409
actually sort of box ourselves into a

00:06:21,770 --> 00:06:25,820
situation where it's actually

00:06:23,409 --> 00:06:28,130
fundamentally impossible by the standard

00:06:25,820 --> 00:06:31,099
to support and coatings that go beyond

00:06:28,130 --> 00:06:32,960
one byte or one unit at a time and this

00:06:31,099 --> 00:06:34,909
is what kind of cloak we refer to as a

00:06:32,960 --> 00:06:36,860
one to one rule one to one restriction I

00:06:34,909 --> 00:06:38,870
mean what it basically says that if you

00:06:36,860 --> 00:06:42,259
were to convert multiple say you have a

00:06:38,870 --> 00:06:43,729
utf-8 literal write innocent and you

00:06:42,259 --> 00:06:44,870
pick the wineglass because you know

00:06:43,729 --> 00:06:45,529
you're you know that's what you want to

00:06:44,870 --> 00:06:47,209
do

00:06:45,529 --> 00:06:51,049
or serializing it to a ceaseless stream

00:06:47,209 --> 00:06:53,389
a wineglass is four bytes right and so

00:06:51,049 --> 00:06:55,009
the idea behind this rule is that if you

00:06:53,389 --> 00:06:56,479
seer if you were to serialize all four

00:06:55,009 --> 00:06:58,519
bytes and it says that and it will

00:06:56,479 --> 00:07:01,849
return yes everything went okay right it

00:06:58,519 --> 00:07:06,229
returned the the air okay

00:07:01,849 --> 00:07:09,139
from the codec conversion functions what

00:07:06,229 --> 00:07:10,699
happens is is that the implementations

00:07:09,139 --> 00:07:12,679
allow the truncate that's just one bit

00:07:10,699 --> 00:07:15,919
serialize only that one bit and then

00:07:12,679 --> 00:07:17,569
return okay right so in fact well it's

00:07:15,919 --> 00:07:19,549
it's nearly impossible to support

00:07:17,569 --> 00:07:21,529
anything that has to do with with

00:07:19,549 --> 00:07:23,599
multiple with multibyte encodings with

00:07:21,529 --> 00:07:25,249
multi unit encodings just the the the

00:07:23,599 --> 00:07:26,929
standard fundamentally restricts is now

00:07:25,249 --> 00:07:30,019
important to note it only restricts it

00:07:26,929 --> 00:07:31,159
in the case of basic file buff the

00:07:30,019 --> 00:07:32,299
problem is that basic file buff

00:07:31,159 --> 00:07:34,219
converters and a lot of things right how

00:07:32,299 --> 00:07:37,099
many things can a file descriptor on a

00:07:34,219 --> 00:07:38,509
Linux machine represent right so it

00:07:37,099 --> 00:07:39,889
affects your console it affects your

00:07:38,509 --> 00:07:43,219
stick files it affects maybe even the

00:07:39,889 --> 00:07:47,959
network it's basically invasive to the

00:07:43,219 --> 00:07:49,099
entire the entire stack and so there's

00:07:47,959 --> 00:07:51,529
really no way to fix us what stream

00:07:49,099 --> 00:07:53,239
seeks fix to see the streams right even

00:07:51,529 --> 00:07:55,129
if we were to move the restriction right

00:07:53,239 --> 00:07:57,409
there are people who have a buffer of

00:07:55,129 --> 00:07:59,569
size one sitting at the other end of

00:07:57,409 --> 00:08:01,789
this thing expecting to only serialize

00:07:59,569 --> 00:08:03,829
one bit in it for to return okay right

00:08:01,789 --> 00:08:05,360
and if we break that invariant those

00:08:03,829 --> 00:08:07,489
people are broken right and they're not

00:08:05,360 --> 00:08:08,869
broken in like a loud noisy way right

00:08:07,489 --> 00:08:10,159
this is a virtual interface right this

00:08:08,869 --> 00:08:12,079
is would be a requirement change that we

00:08:10,159 --> 00:08:13,369
would change silently behind their back

00:08:12,079 --> 00:08:14,449
and say upgrading the standard version

00:08:13,369 --> 00:08:15,619
they would update their version and

00:08:14,449 --> 00:08:16,789
suddenly you know they just we start

00:08:15,619 --> 00:08:18,469
over running their buffers right that's

00:08:16,789 --> 00:08:19,639
a serious security vulnerability right

00:08:18,469 --> 00:08:24,079
there's no way that we can actually fix

00:08:19,639 --> 00:08:26,419
a lot of this stuff in C++ also one of

00:08:24,079 --> 00:08:29,149
the biggest problems is that a lot of

00:08:26,419 --> 00:08:31,519
i/o streams and code convert and facets

00:08:29,149 --> 00:08:32,689
are virtual right and you may think well

00:08:31,519 --> 00:08:35,479
well we could just add another virtual

00:08:32,689 --> 00:08:39,529
function and even if the implementers do

00:08:35,479 --> 00:08:40,699
great magic to make it so that it takes

00:08:39,529 --> 00:08:43,219
the virtual function it puts at the end

00:08:40,699 --> 00:08:44,360
of the V table so that when you start

00:08:43,219 --> 00:08:46,999
calling things it doesn't like mess with

00:08:44,360 --> 00:08:49,309
the V table of old things somebody in

00:08:46,999 --> 00:08:51,829
that somebody outside the standard may

00:08:49,309 --> 00:08:53,929
have actually derived from one of those

00:08:51,829 --> 00:08:56,509
facets of streams with local objects and

00:08:53,929 --> 00:08:57,949
they have their own breach virtual table

00:08:56,509 --> 00:08:58,430
that sits on top of you on top of the

00:08:57,949 --> 00:09:00,860
one that

00:08:58,430 --> 00:09:02,060
shipped so you make guarantee that you

00:09:00,860 --> 00:09:03,740
put something at the end and right in

00:09:02,060 --> 00:09:05,630
your rest of your V tables fine

00:09:03,740 --> 00:09:06,860
but you just moved everything down for

00:09:05,630 --> 00:09:08,450
another person who derived from your

00:09:06,860 --> 00:09:10,250
type and you basically just ruined their

00:09:08,450 --> 00:09:11,600
day because now sudden starts got flying

00:09:10,250 --> 00:09:12,740
all over the place they have no idea

00:09:11,600 --> 00:09:14,180
what's going on there's like I just I

00:09:12,740 --> 00:09:15,320
just upgraded my co-pilot and ran some

00:09:14,180 --> 00:09:18,290
stuff and also I'm getting all these

00:09:15,320 --> 00:09:19,640
crazy spurious failures right and so

00:09:18,290 --> 00:09:23,330
again we're kind of in a virtual

00:09:19,640 --> 00:09:25,970
function hell we we don't have any non

00:09:23,330 --> 00:09:28,550
virtual functions that are that are well

00:09:25,970 --> 00:09:32,750
specified and so basically we're pretty

00:09:28,550 --> 00:09:37,220
much hosed in the current landscape and

00:09:32,750 --> 00:09:38,000
so you know CC releases know better much

00:09:37,220 --> 00:09:40,490
much better

00:09:38,000 --> 00:09:42,050
we have you know singular code unit

00:09:40,490 --> 00:09:43,670
conversion functions but the problem

00:09:42,050 --> 00:09:46,430
with those is that a lot of them assume

00:09:43,670 --> 00:09:47,899
that one input is kind of equivalent to

00:09:46,430 --> 00:09:50,600
one output or one output is kind of them

00:09:47,899 --> 00:09:53,390
to one input and so anything that's

00:09:50,600 --> 00:09:54,589
pretty much not utf-32 like for wide 4w

00:09:53,390 --> 00:09:57,860
Carty like i was talking about before is

00:09:54,589 --> 00:09:58,880
basically wrong the are and some of

00:09:57,860 --> 00:10:00,350
these functions mean that there are

00:09:58,880 --> 00:10:01,610
restored above functions and what that

00:10:00,350 --> 00:10:02,600
means is that they have an extra state

00:10:01,610 --> 00:10:05,180
parameter where they can store some

00:10:02,600 --> 00:10:10,490
extra stuff but the problem with that is

00:10:05,180 --> 00:10:12,260
that it it's still not specified how you

00:10:10,490 --> 00:10:14,810
were how you use that state and return

00:10:12,260 --> 00:10:16,610
there's a defect report actually out for

00:10:14,810 --> 00:10:18,260
the C you know you would you would think

00:10:16,610 --> 00:10:19,640
that the C committee still receiving

00:10:18,260 --> 00:10:20,540
papers in a lie but it's accessed alive

00:10:19,640 --> 00:10:21,800
and there it's still going and they

00:10:20,540 --> 00:10:26,870
actually recently opened to work item

00:10:21,800 --> 00:10:28,250
for c2 X to come out soon soon but the

00:10:26,870 --> 00:10:29,240
the problem with a lot of these these

00:10:28,250 --> 00:10:30,850
functions is that they have fixed

00:10:29,240 --> 00:10:35,690
interfaces and it's impossible to

00:10:30,850 --> 00:10:37,610
properly convert a stream of multiple

00:10:35,690 --> 00:10:40,760
bytes right multibyte encodings are

00:10:37,610 --> 00:10:41,720
multi unit encodings and of course one

00:10:40,760 --> 00:10:43,640
of the things that they don't have is

00:10:41,720 --> 00:10:46,270
that even for multi coding it they don't

00:10:43,640 --> 00:10:48,410
have it for any of the Unicode functions

00:10:46,270 --> 00:10:50,270
and you know right even if you have the

00:10:48,410 --> 00:10:51,980
the single things right we could just

00:10:50,270 --> 00:10:53,150
Luke right how bad could it be right so

00:10:51,980 --> 00:10:54,649
this is this is a bunch of code actually

00:10:53,150 --> 00:10:59,000
comes with CP reference showing you how

00:10:54,649 --> 00:11:01,279
you loop I use a MBR to see 32 what that

00:10:59,000 --> 00:11:07,850
means is multi byte string restartable

00:11:01,279 --> 00:11:10,970
to a unicode 30 a car 32 string or car

00:11:07,850 --> 00:11:12,070
third you character and when you do this

00:11:10,970 --> 00:11:14,590
right you're able to kind of

00:11:12,070 --> 00:11:16,240
we're everything right and you know it's

00:11:14,590 --> 00:11:19,540
it's pointers it has error codes there's

00:11:16,240 --> 00:11:22,870
no exception it's pretty easy right the

00:11:19,540 --> 00:11:25,360
problem with this is that M slow it's

00:11:22,870 --> 00:11:28,390
terribly slow looping and doing code

00:11:25,360 --> 00:11:29,980
conversions one at a time is just is not

00:11:28,390 --> 00:11:31,960
a good idea for a little right but this

00:11:29,980 --> 00:11:33,070
is the only this this code right here

00:11:31,960 --> 00:11:34,900
that you see is the only way you can

00:11:33,070 --> 00:11:37,480
kind of do this today and the standard

00:11:34,900 --> 00:11:38,860
to go from a literal of a regular

00:11:37,480 --> 00:11:43,450
literal that you put in quotation marks

00:11:38,860 --> 00:11:46,230
to you know a car 32t literal and so

00:11:43,450 --> 00:11:48,250
again it's terribly slow there's no SIMD

00:11:46,230 --> 00:11:50,380
possibilities right because the whole

00:11:48,250 --> 00:11:52,210
point is that the function that that's

00:11:50,380 --> 00:11:55,360
called that's usually compiled into like

00:11:52,210 --> 00:11:58,180
you know Lipsy or lip or G lip C or the

00:11:55,360 --> 00:11:59,860
V C++ C library and so let's usually hit

00:11:58,180 --> 00:12:01,510
it behind a DLL or a compiler barrier

00:11:59,860 --> 00:12:02,710
right so there's no way for the compiler

00:12:01,510 --> 00:12:04,510
to see what's going on inside of that

00:12:02,710 --> 00:12:07,210
and just optimize the whole loop right

00:12:04,510 --> 00:12:09,820
and get you you know all the sim D or

00:12:07,210 --> 00:12:11,110
vectorization possibilities and also the

00:12:09,820 --> 00:12:12,790
restorable versions have a little bit of

00:12:11,110 --> 00:12:15,240
code overhead and and the only versions

00:12:12,790 --> 00:12:20,020
we have for the car 16 car 32 T

00:12:15,240 --> 00:12:23,020
conversions are restarting so we're a

00:12:20,020 --> 00:12:26,050
little bit hos they're small bit of a

00:12:23,020 --> 00:12:27,580
digression um anyone know what what this

00:12:26,050 --> 00:12:31,240
function is supposed to do right just

00:12:27,580 --> 00:12:32,920
call it out right it's mv2 wide

00:12:31,240 --> 00:12:34,270
character right so they anyone have like

00:12:32,920 --> 00:12:35,710
an idea like you know what how this

00:12:34,270 --> 00:12:38,710
supposed to work right you you know

00:12:35,710 --> 00:12:47,920
anyone call out like no no nobody nobody

00:12:38,710 --> 00:12:50,830
oh peter has a right so Peters response

00:12:47,920 --> 00:12:52,360
was that you know you put in a narrow

00:12:50,830 --> 00:12:53,860
ring and you get out a wide string of

00:12:52,360 --> 00:12:56,560
you know for some amount of numbers

00:12:53,860 --> 00:13:01,080
right and actually this this function is

00:12:56,560 --> 00:13:02,320
a bit of a lie you see the W Carty

00:13:01,080 --> 00:13:03,520
pointer

00:13:02,320 --> 00:13:04,810
you know pointer to white characters

00:13:03,520 --> 00:13:06,160
right and this looks like something that

00:13:04,810 --> 00:13:09,160
would be able to handle multiple code

00:13:06,160 --> 00:13:11,680
units right so for example you know you

00:13:09,160 --> 00:13:13,870
have utf-16 on windows right so if i had

00:13:11,680 --> 00:13:14,620
a regular string literal in you know UTF

00:13:13,870 --> 00:13:16,960
a because we're gonna pretend that

00:13:14,620 --> 00:13:20,140
windows supports utf-8 it actually does

00:13:16,960 --> 00:13:23,440
but not for everybody but it does we put

00:13:20,140 --> 00:13:24,910
a utf-8 little for MBS right and we give

00:13:23,440 --> 00:13:26,200
it the size right then we have

00:13:24,910 --> 00:13:28,210
output buffer right we have like a large

00:13:26,200 --> 00:13:31,330
output buffer for pointer to white

00:13:28,210 --> 00:13:34,540
characters - right - the problem here is

00:13:31,330 --> 00:13:36,400
that this isn't actually like an output

00:13:34,540 --> 00:13:37,600
wide string your eligibles output one

00:13:36,400 --> 00:13:39,550
character at a time because that's the

00:13:37,600 --> 00:13:42,820
contract that this function has right

00:13:39,550 --> 00:13:45,130
but because it's a pointer it looks like

00:13:42,820 --> 00:13:49,030
it's an output like buffer thing right

00:13:45,130 --> 00:13:50,320
so please pretty pretty please stop

00:13:49,030 --> 00:13:53,200
using pointers to represent optional

00:13:50,320 --> 00:13:54,370
values obviously this is C so we can't

00:13:53,200 --> 00:13:56,980
get that right so we can't have that

00:13:54,370 --> 00:13:58,090
nice thing but there are C++ versions of

00:13:56,980 --> 00:14:00,400
this that still kind of do the same

00:13:58,090 --> 00:14:02,530
thing that still use a pointer to a car

00:14:00,400 --> 00:14:04,030
type to have an output buffer without

00:14:02,530 --> 00:14:07,690
any kind of other size of information

00:14:04,030 --> 00:14:09,580
and you know the conventions are nice

00:14:07,690 --> 00:14:11,290
you know the convention of always having

00:14:09,580 --> 00:14:14,230
a pointer to a character type being a

00:14:11,290 --> 00:14:16,810
string or a variable amount of things is

00:14:14,230 --> 00:14:20,200
nice until it's actually wrong right so

00:14:16,810 --> 00:14:21,610
just you know don't use pointers for

00:14:20,200 --> 00:14:22,930
optional values those interfaces right I

00:14:21,610 --> 00:14:24,400
spent actually a long time looking at

00:14:22,930 --> 00:14:27,040
this because I thought that this

00:14:24,400 --> 00:14:28,390
supported like multiple utf-16 code

00:14:27,040 --> 00:14:29,530
units right so having the surrogate pair

00:14:28,390 --> 00:14:30,880
then the other part that tells you you

00:14:29,530 --> 00:14:33,700
know what they have a wineglass right or

00:14:30,880 --> 00:14:37,810
snowman or men and levitating a business

00:14:33,700 --> 00:14:40,180
suit right and then I you know I I used

00:14:37,810 --> 00:14:41,710
it and I only got out like half broken

00:14:40,180 --> 00:14:43,150
surrogate pairs and I sent an email to

00:14:41,710 --> 00:14:45,580
Bellino I was like I'm sorry isn't

00:14:43,150 --> 00:14:47,440
Windows utsa she's like no it's UCS - it

00:14:45,580 --> 00:14:48,820
doesn't support more than 16 bits and

00:14:47,440 --> 00:14:50,980
you know he gave me a kind of quick

00:14:48,820 --> 00:14:52,780
rundown about the one-to-one this stuff

00:14:50,980 --> 00:14:55,030
like this but of course when you look at

00:14:52,780 --> 00:14:56,140
it when you look at this API it's

00:14:55,030 --> 00:14:58,060
impossible to tell that because it's a

00:14:56,140 --> 00:14:59,170
pointer right it's a point you like

00:14:58,060 --> 00:15:00,730
that's the convention right you assume

00:14:59,170 --> 00:15:03,150
that it's a it's a multiple thing that

00:15:00,730 --> 00:15:05,530
it can handle multiple things but it can

00:15:03,150 --> 00:15:07,540
and so that's that's kind of unfortunate

00:15:05,530 --> 00:15:09,940
so but that's just kind of a quick quick

00:15:07,540 --> 00:15:13,330
mini rant about you know optional and

00:15:09,940 --> 00:15:15,250
stuff like that but this is kind of the

00:15:13,330 --> 00:15:18,220
full landscape of all the stuff we're

00:15:15,250 --> 00:15:21,040
missing um yeah we're really only hard

00:15:18,220 --> 00:15:22,600
to teach check marks on there and then

00:15:21,040 --> 00:15:24,640
we have these ARS in the table that

00:15:22,600 --> 00:15:25,900
represent that there is a restartable

00:15:24,640 --> 00:15:28,390
version but not a non restartable

00:15:25,900 --> 00:15:30,670
version but basically like all of this

00:15:28,390 --> 00:15:33,220
functionality is missing from the c

00:15:30,670 --> 00:15:35,740
standard so there's really is no good

00:15:33,220 --> 00:15:37,150
way to convert from you know a regular

00:15:35,740 --> 00:15:38,150
string literal to any one of the Unicode

00:15:37,150 --> 00:15:39,680
ones or backward

00:15:38,150 --> 00:15:42,830
it's a morning with wide ones the

00:15:39,680 --> 00:15:46,190
unicode patrols are back and it's very

00:15:42,830 --> 00:15:48,070
much a sad sad state there's also all

00:15:46,190 --> 00:15:50,840
these api's yuzhno terminated strings

00:15:48,070 --> 00:15:51,770
even the the the s ones that are

00:15:50,840 --> 00:15:54,560
supposed to take a actual string

00:15:51,770 --> 00:15:55,760
parameter take mill terminate strings

00:15:54,560 --> 00:15:56,900
and so if you haven't embedded in all in

00:15:55,760 --> 00:15:58,580
your único i hope you're ready to you

00:15:56,900 --> 00:15:59,720
know like check and loop and do all

00:15:58,580 --> 00:16:03,740
stuff it's again more of an impediment

00:15:59,720 --> 00:16:06,670
to performance once again so i might be

00:16:03,740 --> 00:16:11,390
proposing a paper to wu-14 to fix this

00:16:06,670 --> 00:16:12,410
but it is a lot and see the WG 14c

00:16:11,390 --> 00:16:14,420
committee has this rule that you're

00:16:12,410 --> 00:16:16,430
supposed to have two implementations one

00:16:14,420 --> 00:16:19,490
person implemented this already in the

00:16:16,430 --> 00:16:20,930
small device small device c compiler but

00:16:19,490 --> 00:16:22,940
they need one more person for like Musil

00:16:20,930 --> 00:16:25,640
or g Lib C or whatever else so I'm

00:16:22,940 --> 00:16:28,550
slowly gearing up to step into the world

00:16:25,640 --> 00:16:29,990
of G Lib C and you know say goodbye to

00:16:28,550 --> 00:16:32,990
all and I subtract and see it's bus and

00:16:29,990 --> 00:16:37,340
you know writes in D and C and oh man

00:16:32,990 --> 00:16:39,170
that's gonna be great but you know I

00:16:37,340 --> 00:16:40,910
think of Vinci right so fine fine you

00:16:39,170 --> 00:16:41,980
know see suppose are terrible but you

00:16:40,910 --> 00:16:44,750
know you say you ha but we have

00:16:41,980 --> 00:16:46,010
third-party libraries maybe right like

00:16:44,750 --> 00:16:47,210
that's what sees what's all about right

00:16:46,010 --> 00:16:49,160
if the standard doesn't give it to you

00:16:47,210 --> 00:16:50,870
right you can just make your own library

00:16:49,160 --> 00:16:52,490
right and it's gonna be it's gonna be

00:16:50,870 --> 00:17:00,380
great it's gonna be amazing it's gonna

00:16:52,490 --> 00:17:02,690
be no it's not great it's it's it's not

00:17:00,380 --> 00:17:07,220
great at all but to be serious

00:17:02,690 --> 00:17:08,959
right there is ICU but it's a dumpster

00:17:07,220 --> 00:17:10,370
fire my apologies to the ICU

00:17:08,959 --> 00:17:12,230
implementers right you did a great job

00:17:10,370 --> 00:17:14,360
when you made a nice Java API but then

00:17:12,230 --> 00:17:15,800
you poured it to C and didn't go quite

00:17:14,360 --> 00:17:17,089
well and you'd like wrap the see that

00:17:15,800 --> 00:17:20,089
you ported from Java in to see his plus

00:17:17,089 --> 00:17:21,920
and that didn't quite go so well oh it's

00:17:20,089 --> 00:17:24,020
it's horrible um I tried to use it

00:17:21,920 --> 00:17:26,240
actually because I want to like compare

00:17:24,020 --> 00:17:28,040
like my API and other people's api's to

00:17:26,240 --> 00:17:30,110
it and it's just it's not fun most

00:17:28,040 --> 00:17:31,940
people actually don't even use ICU they

00:17:30,110 --> 00:17:33,920
either use you convey or I convey which

00:17:31,940 --> 00:17:35,210
is like the POSIX C wrappers around

00:17:33,920 --> 00:17:36,050
those things they really just have one

00:17:35,210 --> 00:17:37,910
function call and they don't have to

00:17:36,050 --> 00:17:43,460
worry about I need the other stuff but

00:17:37,910 --> 00:17:46,190
man ICU is hot flaming garbage the good

00:17:43,460 --> 00:17:49,730
news is the good news is that like it's

00:17:46,190 --> 00:17:51,110
hand optimized right it's it is probably

00:17:49,730 --> 00:17:52,070
you know one of the most fully featured

00:17:51,110 --> 00:17:54,200
fast

00:17:52,070 --> 00:17:55,880
implementations right it is it has all

00:17:54,200 --> 00:17:57,650
the algorithms it has all the data you

00:17:55,880 --> 00:18:00,050
want right it is everything but it's

00:17:57,650 --> 00:18:01,400
just the API is really bad right so I'm

00:18:00,050 --> 00:18:02,750
beginning when I sort on this right I

00:18:01,400 --> 00:18:04,180
was like why don't everybody issues ICU

00:18:02,750 --> 00:18:05,720
right if that would solve all our

00:18:04,180 --> 00:18:08,210
internationalization and localization

00:18:05,720 --> 00:18:13,490
and encoding problems right and then I

00:18:08,210 --> 00:18:15,620
actually used it and I was like oh oh so

00:18:13,490 --> 00:18:17,150
now I understand right and there's a

00:18:15,620 --> 00:18:20,990
bunch of several ad hoc libraries out

00:18:17,150 --> 00:18:22,130
there like the Ute the utf-8 CPU library

00:18:20,990 --> 00:18:23,930
and a bunch of others but they're very

00:18:22,130 --> 00:18:25,880
hyper focused they don't include a lot

00:18:23,930 --> 00:18:27,560
of the Unicode algorithms some do some

00:18:25,880 --> 00:18:28,970
don't it's it's basically hit or miss

00:18:27,560 --> 00:18:30,350
and you just kind of stumble upon or you

00:18:28,970 --> 00:18:34,040
just end up implementing it yourself in

00:18:30,350 --> 00:18:35,660
a in a fit of rage one day but there are

00:18:34,040 --> 00:18:38,180
some good libraries that are more

00:18:35,660 --> 00:18:39,440
current um so boost out Texas something

00:18:38,180 --> 00:18:43,250
that Zac Matt Lane the first the first

00:18:39,440 --> 00:18:46,940
guy with the handsome beard he made

00:18:43,250 --> 00:18:48,320
boost out texts and what he does is he

00:18:46,940 --> 00:18:49,580
handles a encoder/decoder and a lot of

00:18:48,320 --> 00:18:50,750
the higher level algorithm right and he

00:18:49,580 --> 00:18:53,570
did it like a from scratch like

00:18:50,750 --> 00:18:54,830
cleanroom implementation of it and so it

00:18:53,570 --> 00:18:56,870
includes bi-directional algorithm

00:18:54,830 --> 00:18:57,920
segmentation collation a bunch of stuff

00:18:56,870 --> 00:19:00,530
right I don't think they include

00:18:57,920 --> 00:19:01,610
register cuz that's really hard but if

00:19:00,530 --> 00:19:05,090
you undo that just talk to Hanna do

00:19:01,610 --> 00:19:06,830
Zhukova there's also two other libraries

00:19:05,090 --> 00:19:08,570
there's Lib oh connect and taxi

00:19:06,830 --> 00:19:11,120
Lupo connect is a library that came from

00:19:08,570 --> 00:19:13,990
robot the guy who wrote the other paper

00:19:11,120 --> 00:19:16,070
to fix the car liberals and cs+ and

00:19:13,990 --> 00:19:17,300
another library I called textview

00:19:16,070 --> 00:19:20,930
written by Tom Horner Minh the last

00:19:17,300 --> 00:19:23,720
person there who is actually the chair

00:19:20,930 --> 00:19:25,250
of study group 16 su 16 which is a

00:19:23,720 --> 00:19:29,570
Unicode again the Unicode arm of CS plus

00:19:25,250 --> 00:19:30,830
and so the liberal in act hand is a lot

00:19:29,570 --> 00:19:32,120
more than text because text we kind of

00:19:30,830 --> 00:19:33,320
got all the way to like encoding and

00:19:32,120 --> 00:19:35,960
then kind of stop there because he has a

00:19:33,320 --> 00:19:37,190
you know real job in life and a wife and

00:19:35,960 --> 00:19:39,980
kids and you know you can't just do this

00:19:37,190 --> 00:19:41,990
forever and robot it's sort of in the

00:19:39,980 --> 00:19:44,180
same boat in that he got encoding

00:19:41,990 --> 00:19:47,450
decoding a lot more features but it kind

00:19:44,180 --> 00:19:49,730
of but he's you know ran out of time to

00:19:47,450 --> 00:19:51,050
develop it right so kind of talking

00:19:49,730 --> 00:19:53,510
about some of the ups and downs here

00:19:51,050 --> 00:19:54,740
boost dot text covers you know it covers

00:19:53,510 --> 00:19:57,620
the widest variety of unicode algorithms

00:19:54,740 --> 00:19:59,630
outside of ICU that i've seen so far it

00:19:57,620 --> 00:19:59,840
also uses STL concentrate so it has it

00:19:59,630 --> 00:20:02,540
has

00:19:59,840 --> 00:20:04,820
ranges and iterators and the same kind

00:20:02,540 --> 00:20:05,389
of container stuff the only downside to

00:20:04,820 --> 00:20:07,249
boost

00:20:05,389 --> 00:20:09,829
really the only downside the boost our

00:20:07,249 --> 00:20:13,459
Texans acklin's work is that he's

00:20:09,829 --> 00:20:17,749
opinionated he's very strong opinions if

00:20:13,459 --> 00:20:19,909
you come to an SG 16 meeting but he

00:20:17,749 --> 00:20:23,359
basically he decided for everybody right

00:20:19,909 --> 00:20:25,070
who uses library right that utf-8 is the

00:20:23,359 --> 00:20:28,909
one and true God which is you know kind

00:20:25,070 --> 00:20:31,820
of true but but also it he fundamentally

00:20:28,909 --> 00:20:35,719
chose the normalization form see FCC

00:20:31,820 --> 00:20:37,039
normalization and those two while that's

00:20:35,719 --> 00:20:38,299
it's good for him to fix those things

00:20:37,039 --> 00:20:40,729
and kind of decide for everybody that's

00:20:38,299 --> 00:20:41,779
what they want there's a number of

00:20:40,729 --> 00:20:43,159
different reasons why you would want to

00:20:41,779 --> 00:20:45,589
pick other normalization forms or even

00:20:43,159 --> 00:20:47,269
other in storage schemes and so that

00:20:45,589 --> 00:20:49,549
kind of serves it's like a downside as

00:20:47,269 --> 00:20:51,349
far as like making it having it consume

00:20:49,549 --> 00:20:52,609
a lot of the current problems that we

00:20:51,349 --> 00:20:53,979
have today right because other people

00:20:52,609 --> 00:20:55,789
have different kinds of encoding

00:20:53,979 --> 00:20:57,289
requirements other people especially

00:20:55,789 --> 00:20:59,419
want to use like normalization form D

00:20:57,289 --> 00:20:59,869
for internal processing and other things

00:20:59,419 --> 00:21:02,389
like that

00:20:59,869 --> 00:21:03,829
and so because he's fixed the internal

00:21:02,389 --> 00:21:06,440
representation normalization forms it's

00:21:03,829 --> 00:21:10,129
it's kind of like hamstrung to him or

00:21:06,440 --> 00:21:11,149
having his library the bogan act right

00:21:10,129 --> 00:21:12,559
I'm not gonna talk about text me because

00:21:11,149 --> 00:21:15,409
Lib enact basically dissolve what text

00:21:12,559 --> 00:21:16,940
fee does but like better and further it

00:21:15,409 --> 00:21:18,859
provides many of the Unicode algorithms

00:21:16,940 --> 00:21:20,659
including normalization it has a

00:21:18,859 --> 00:21:22,849
concentration design with iterators and

00:21:20,659 --> 00:21:25,579
it has actually pretty good speed but

00:21:22,849 --> 00:21:27,859
it's not really recently maintained it

00:21:25,579 --> 00:21:29,089
was started I think back in like 2012 um

00:21:27,859 --> 00:21:31,669
and he did a lot of work on it got

00:21:29,089 --> 00:21:36,019
really far but you know he could job

00:21:31,669 --> 00:21:38,149
life wife etc you know so and then

00:21:36,019 --> 00:21:39,739
there's a couple of issues with like the

00:21:38,149 --> 00:21:41,209
iterator iterator post that he used and

00:21:39,739 --> 00:21:44,419
I are gonna talk a little bit about how

00:21:41,209 --> 00:21:45,769
limbo Connect did some of this so here

00:21:44,419 --> 00:21:47,299
to the his approach was entirely

00:21:45,769 --> 00:21:49,820
arranged based an entirely iterator

00:21:47,299 --> 00:21:51,139
based so he was actually able to do all

00:21:49,820 --> 00:21:52,549
the unicorn algorithms but like keep

00:21:51,139 --> 00:21:55,179
with STL concepts right so you could

00:21:52,549 --> 00:21:57,829
take his iterators and like pass them to

00:21:55,179 --> 00:22:01,700
STL algorithms and it would work right

00:21:57,829 --> 00:22:04,190
um the only problem with his setup is

00:22:01,700 --> 00:22:05,389
that when you start stacking a graph

00:22:04,190 --> 00:22:08,839
some iterator on a normalization

00:22:05,389 --> 00:22:12,200
iterator on a decode iterator to do your

00:22:08,839 --> 00:22:13,879
algorithm you end up having to copy and

00:22:12,200 --> 00:22:15,799
store a lot of iterators on iteration a

00:22:13,879 --> 00:22:16,759
lot of state and what they ended up

00:22:15,799 --> 00:22:18,240
doing is that you end up with these

00:22:16,759 --> 00:22:20,300
really chunky iterate

00:22:18,240 --> 00:22:22,380
like these really beefy iterators by

00:22:20,300 --> 00:22:23,850
256-byte iterators right and you're

00:22:22,380 --> 00:22:27,510
trying to pass these things by value on

00:22:23,850 --> 00:22:28,950
the stack that's real painful and a lot

00:22:27,510 --> 00:22:31,110
of these interests needs both begin and

00:22:28,950 --> 00:22:32,520
end inside the decode iterator so I know

00:22:31,110 --> 00:22:35,179
when to stop or when to throw an error

00:22:32,520 --> 00:22:38,880
and other things like that and of course

00:22:35,179 --> 00:22:40,440
because in scaevola 17 and below every

00:22:38,880 --> 00:22:42,960
single iterator pair had to be exactly

00:22:40,440 --> 00:22:45,179
the same type you ended up having 256 by

00:22:42,960 --> 00:22:46,410
iterators twice where one of them

00:22:45,179 --> 00:22:47,730
usually just had like boolean x' and a

00:22:46,410 --> 00:22:49,800
couple of flag to say i'm the end

00:22:47,730 --> 00:22:51,960
iterator right and the other one was

00:22:49,800 --> 00:22:52,980
just had all the extra information but

00:22:51,960 --> 00:22:54,690
both of them were the same type so you

00:22:52,980 --> 00:22:56,880
had these two really chunky iterators

00:22:54,690 --> 00:22:58,140
and of course you stack them you stacked

00:22:56,880 --> 00:23:00,030
them like this where you do you know you

00:22:58,140 --> 00:23:01,200
you wrap three iterators at a time with

00:23:00,030 --> 00:23:05,040
additional information you end up with

00:23:01,200 --> 00:23:07,500
these really really big iterators and so

00:23:05,040 --> 00:23:10,470
the the fixes are the sexiest of ranges

00:23:07,500 --> 00:23:13,230
so stood ranges lets you have a

00:23:10,470 --> 00:23:14,820
different end type than a begin type it

00:23:13,230 --> 00:23:16,170
let you have a sentinel type and what

00:23:14,820 --> 00:23:17,340
that means is that the sentinel type can

00:23:16,170 --> 00:23:20,760
basically just be a completely empty

00:23:17,340 --> 00:23:22,920
class or structure and you can still

00:23:20,760 --> 00:23:24,530
compare it against the first one and use

00:23:22,920 --> 00:23:27,030
it to basically trim down all the state

00:23:24,530 --> 00:23:28,980
so what happened is you usually have

00:23:27,030 --> 00:23:31,020
these big chunky big-boy iterators and

00:23:28,980 --> 00:23:34,290
now there are nice small crescent moon

00:23:31,020 --> 00:23:36,210
sleek iterators right so separate types

00:23:34,290 --> 00:23:37,470
begin and end and so you only have all

00:23:36,210 --> 00:23:39,480
of the information in the decoded array

00:23:37,470 --> 00:23:41,250
or all the information on the one half

00:23:39,480 --> 00:23:42,630
of the equation right and are able to

00:23:41,250 --> 00:23:46,440
optimize that and make it small and tiny

00:23:42,630 --> 00:23:50,190
and it's great there's also other API so

00:23:46,440 --> 00:23:54,300
this this this man here is Henry saponin

00:23:50,190 --> 00:23:56,100
he does a lot of work in Helsinki he

00:23:54,300 --> 00:23:57,960
represented Firefox after for a long

00:23:56,100 --> 00:24:02,070
time to their to their stick to the web

00:23:57,960 --> 00:24:03,270
standards body and he did a lot of work

00:24:02,070 --> 00:24:04,830
on working on like basically the

00:24:03,270 --> 00:24:08,490
conversion routines that are in Firefox

00:24:04,830 --> 00:24:11,030
right and so talk about the firefox and

00:24:08,490 --> 00:24:13,200
chrome database code code bases write

00:24:11,030 --> 00:24:14,550
the Lucchese he wrote are extremely fast

00:24:13,200 --> 00:24:15,600
right they need to convert a lot of text

00:24:14,550 --> 00:24:17,580
but they're handling webpages they need

00:24:15,600 --> 00:24:18,240
to basically like take stuff in process

00:24:17,580 --> 00:24:19,920
it really fast

00:24:18,240 --> 00:24:21,390
dump it out right and they need to also

00:24:19,920 --> 00:24:22,530
have kind of a consistency between them

00:24:21,390 --> 00:24:24,230
right so the way they handle editors etc

00:24:22,530 --> 00:24:26,910
so it's very highly optimized

00:24:24,230 --> 00:24:28,169
implementations the problem is is still

00:24:26,910 --> 00:24:30,090
kind of pointer based right like to see

00:24:28,169 --> 00:24:31,290
interfaces so it becomes a little bit

00:24:30,090 --> 00:24:33,420
problematic if you want to use it with

00:24:31,290 --> 00:24:34,980
exotic storage so if you wanted to say

00:24:33,420 --> 00:24:36,840
you say stood deck well it's a little

00:24:34,980 --> 00:24:39,140
bit difficult if you want to use say a

00:24:36,840 --> 00:24:42,180
rope it's a little bit difficult right

00:24:39,140 --> 00:24:43,770
so and again one of the problems is

00:24:42,180 --> 00:24:44,880
except is that you know the chrome stuff

00:24:43,770 --> 00:24:46,950
and the fire foxes are generally

00:24:44,880 --> 00:24:49,230
code-based specific except Henry went

00:24:46,950 --> 00:24:52,380
out of his way to release what's called

00:24:49,230 --> 00:24:54,840
encoding 2rs as like a free of freely

00:24:52,380 --> 00:24:57,420
available i nes suits + + c bindings so

00:24:54,840 --> 00:25:00,450
he he would start with a he made a

00:24:57,420 --> 00:25:02,640
serious effort to allow other people to

00:25:00,450 --> 00:25:04,910
use his code right and that's been very

00:25:02,640 --> 00:25:07,500
very very helpful

00:25:04,910 --> 00:25:09,840
alright um but no pep talks about the

00:25:07,500 --> 00:25:11,340
landscape and so now we're kind of gonna

00:25:09,840 --> 00:25:12,900
spend the the later half of this talk

00:25:11,340 --> 00:25:15,060
kind of talking about the things that we

00:25:12,900 --> 00:25:16,140
want to do right with text um the way

00:25:15,060 --> 00:25:18,540
that we want to text a show up in the

00:25:16,140 --> 00:25:21,210
standard so here's one of the goals

00:25:18,540 --> 00:25:24,240
right we want to be able to have a stood

00:25:21,210 --> 00:25:25,830
text this nice like you 8 text type

00:25:24,240 --> 00:25:29,670
right we want to be able to hand it a

00:25:25,830 --> 00:25:32,040
literal and tell it to transcode from

00:25:29,670 --> 00:25:34,800
this like narrow string multibyte

00:25:32,040 --> 00:25:37,530
encoding type to utf-8 and just have

00:25:34,800 --> 00:25:38,670
that work right at the box right we also

00:25:37,530 --> 00:25:39,780
want to be able to print it out to stood

00:25:38,670 --> 00:25:41,010
out and whatever else right you

00:25:39,780 --> 00:25:42,420
obviously need a capable console

00:25:41,010 --> 00:25:43,860
microsoft terminal is actually capable

00:25:42,420 --> 00:25:46,890
of utf-8 and stuff like that so this

00:25:43,860 --> 00:25:51,330
might work in a future coming to you

00:25:46,890 --> 00:25:54,030
actually pretty soon the way this works

00:25:51,330 --> 00:25:56,910
is we kind of need a container adapter

00:25:54,030 --> 00:25:58,890
and so the the fundamental of this is

00:25:56,910 --> 00:26:01,590
that we have something that takes an

00:25:58,890 --> 00:26:05,100
encoding a normalization form and then a

00:26:01,590 --> 00:26:07,950
container upon which we build which you

00:26:05,100 --> 00:26:10,740
write these abstractions around so this

00:26:07,950 --> 00:26:12,150
it falls the same coding conventions

00:26:10,740 --> 00:26:13,560
that that's in a standard for other

00:26:12,150 --> 00:26:16,400
cares like basic strings we have basic

00:26:13,560 --> 00:26:19,350
text and it's all tempted into hell

00:26:16,400 --> 00:26:21,300
similarly we also want a text view type

00:26:19,350 --> 00:26:23,100
so that you can take a bit of storage

00:26:21,300 --> 00:26:24,660
that you don't actually own but still

00:26:23,100 --> 00:26:26,330
view it as like a sequence of code

00:26:24,660 --> 00:26:29,190
points right which is incredibly useful

00:26:26,330 --> 00:26:31,500
and so this is the other type basic text

00:26:29,190 --> 00:26:32,880
view and obviously you don't want to

00:26:31,500 --> 00:26:34,050
type a basic text every time a basic

00:26:32,880 --> 00:26:35,370
text view so we have some convenience

00:26:34,050 --> 00:26:37,440
aliases here right so you have you a

00:26:35,370 --> 00:26:39,330
text view 16 texts you 32 texts w text

00:26:37,440 --> 00:26:41,400
with the wide execution you know w car

00:26:39,330 --> 00:26:42,960
right whatever the the user sets or

00:26:41,400 --> 00:26:44,750
whatever the platform sets and then we

00:26:42,960 --> 00:26:47,130
have text which is utf-8

00:26:44,750 --> 00:26:48,720
I'm just kidding it's it's narrow

00:26:47,130 --> 00:26:50,100
execution I would love the pipe dream

00:26:48,720 --> 00:26:53,850
where we could assume that the default

00:26:50,100 --> 00:26:56,490
text type is utf-8 but no this is the

00:26:53,850 --> 00:26:59,040
reality check so Texas narrow execution

00:26:56,490 --> 00:27:01,590
is not that's not utf-8 which you know

00:26:59,040 --> 00:27:03,390
comes with its own set of problems but

00:27:01,590 --> 00:27:04,890
you might be wondering why these

00:27:03,390 --> 00:27:06,000
container why these view adaptors right

00:27:04,890 --> 00:27:08,400
why these things that we build it why

00:27:06,000 --> 00:27:11,090
don't we have a stood text container all

00:27:08,400 --> 00:27:12,960
by itself right without these like

00:27:11,090 --> 00:27:14,250
adaptor things right without having like

00:27:12,960 --> 00:27:15,980
these things that wrapped strings or

00:27:14,250 --> 00:27:18,000
whatever else and the problem is that

00:27:15,980 --> 00:27:21,540
the thing that we want to fix is want

00:27:18,000 --> 00:27:24,720
flexibility right if if STL if if Billy

00:27:21,540 --> 00:27:26,070
O'Neil if if Jonathan Wakely if Eric

00:27:24,720 --> 00:27:28,020
facility a have to sit down and write

00:27:26,070 --> 00:27:29,310
yet another container and provide the

00:27:28,020 --> 00:27:31,520
strong intercept see for yet another

00:27:29,310 --> 00:27:34,590
thing that is essentially stood vector

00:27:31,520 --> 00:27:35,610
we're not really succeeding right and

00:27:34,590 --> 00:27:37,260
plus there's a bunch of different

00:27:35,610 --> 00:27:38,340
storage mechanisms that already exists

00:27:37,260 --> 00:27:39,900
in the world right so there's things in

00:27:38,340 --> 00:27:41,700
the standard already like dec but then

00:27:39,900 --> 00:27:44,310
it stays like LLVM small vector there's

00:27:41,700 --> 00:27:46,380
things like in the in the extensions

00:27:44,310 --> 00:27:47,910
namespace of GNU there's a rope type

00:27:46,380 --> 00:27:49,200
there's an actual rope type that you can

00:27:47,910 --> 00:27:50,850
use to store text and everything

00:27:49,200 --> 00:27:52,260
there's gap buffer implementations

00:27:50,850 --> 00:27:54,140
there's ring spans there's mark there's

00:27:52,260 --> 00:27:56,640
more and more things that you want to

00:27:54,140 --> 00:27:58,590
have this right and we really can't

00:27:56,640 --> 00:27:59,850
afford to reinvent this thing or have

00:27:58,590 --> 00:28:01,020
other people reinvent this thing every

00:27:59,850 --> 00:28:02,970
time they need a new string type right

00:28:01,020 --> 00:28:04,290
like you know obviously I mean it make

00:28:02,970 --> 00:28:05,460
the game devs happy because they'd have

00:28:04,290 --> 00:28:08,040
something to re-implement every single

00:28:05,460 --> 00:28:09,600
bit but you know we want to keep this

00:28:08,040 --> 00:28:11,610
simple one it keeps easy right

00:28:09,600 --> 00:28:12,630
and even then I see who makes sort of

00:28:11,610 --> 00:28:14,220
the same mistake enough they have their

00:28:12,630 --> 00:28:15,240
own Unicode string type and of course

00:28:14,220 --> 00:28:16,620
you're not gonna cart around their

00:28:15,240 --> 00:28:19,590
unicode string type and all your API is

00:28:16,620 --> 00:28:23,040
right so again it's not fun and we don't

00:28:19,590 --> 00:28:25,650
really want that and the thing is is

00:28:23,040 --> 00:28:27,840
that we want the the biggest cell here

00:28:25,650 --> 00:28:30,330
is that nothing changes for the

00:28:27,840 --> 00:28:32,070
implement right so you have a function

00:28:30,330 --> 00:28:35,520
right and think that ICP and you know

00:28:32,070 --> 00:28:37,050
it's it's it's do the thing right and it

00:28:35,520 --> 00:28:38,940
takes a good string which is totally

00:28:37,050 --> 00:28:41,100
utf-8 right you know it doesn't actually

00:28:38,940 --> 00:28:42,690
it is actually a string but like your

00:28:41,100 --> 00:28:44,610
code base in your convention says like

00:28:42,690 --> 00:28:46,560
listen I have car it's we've already

00:28:44,610 --> 00:28:47,910
defined it to be utf-8 I don't want to

00:28:46,560 --> 00:28:50,520
do an extra effort whatever else right

00:28:47,910 --> 00:28:52,680
and so the idea here is that with these

00:28:50,520 --> 00:28:54,960
container adapters and these view and

00:28:52,680 --> 00:28:55,740
these rate adapters you can actually

00:28:54,960 --> 00:28:57,690
have

00:28:55,740 --> 00:29:00,510
your same interface nothing's changed

00:28:57,690 --> 00:29:03,570
for the user but internally you can use

00:29:00,510 --> 00:29:05,880
you a text right you can move the

00:29:03,570 --> 00:29:07,290
storage into this you a text you can use

00:29:05,880 --> 00:29:08,910
it you can do all the stuff you did

00:29:07,290 --> 00:29:10,620
before without having like manually to

00:29:08,910 --> 00:29:11,790
keep track of code points and then you

00:29:10,620 --> 00:29:14,040
can just return the same thing that you

00:29:11,790 --> 00:29:16,590
always returned right and so this means

00:29:14,040 --> 00:29:18,510
that porting and that having people opt

00:29:16,590 --> 00:29:20,310
into this interface is a lot easier

00:29:18,510 --> 00:29:21,750
right you don't have to go change your

00:29:20,310 --> 00:29:23,490
API change your all your source code

00:29:21,750 --> 00:29:24,990
check if all the things still build you

00:29:23,490 --> 00:29:28,260
just do it internally right and you

00:29:24,990 --> 00:29:29,280
still get all the same benefits there's

00:29:28,260 --> 00:29:30,390
also some other goals we want to talk

00:29:29,280 --> 00:29:32,670
about right so so let's talk a little

00:29:30,390 --> 00:29:34,050
bit about networking um this is the this

00:29:32,670 --> 00:29:35,190
is an example from the Beast library

00:29:34,050 --> 00:29:36,930
have obviously trimmed out a lot of

00:29:35,190 --> 00:29:38,700
stuff because there's a lot of work that

00:29:36,930 --> 00:29:41,940
goes into making this kind of stuff but

00:29:38,700 --> 00:29:43,920
we we have you know an HTTP request we

00:29:41,940 --> 00:29:45,660
have a vector that is the body of bytes

00:29:43,920 --> 00:29:47,550
that we get back from this HTTP request

00:29:45,660 --> 00:29:50,040
and then we have this kind of you

00:29:47,550 --> 00:29:51,240
extraneous converted body things that

00:29:50,040 --> 00:29:53,190
represents the body that we're going to

00:29:51,240 --> 00:29:55,710
take that's going to be the converted

00:29:53,190 --> 00:29:57,210
information and so of course there's you

00:29:55,710 --> 00:29:59,790
know the usual beast boilerplate we have

00:29:57,210 --> 00:30:02,940
to you know on connect but what really

00:29:59,790 --> 00:30:04,290
gonna want to work on is the on read on

00:30:02,940 --> 00:30:06,930
read function so we're gonna look at

00:30:04,290 --> 00:30:08,670
that a little bit also there's a usual

00:30:06,930 --> 00:30:10,530
boilerplate right you got a check if the

00:30:08,670 --> 00:30:15,270
error code fails and a lock of failure

00:30:10,530 --> 00:30:16,110
in return but here's what we've checked

00:30:15,270 --> 00:30:17,220
the error code now we're gonna do the

00:30:16,110 --> 00:30:18,900
interesting part right so we have bytes

00:30:17,220 --> 00:30:21,150
we have some bytes we gotta back out of

00:30:18,900 --> 00:30:23,910
the response body and we check the bytes

00:30:21,150 --> 00:30:25,320
transferred value right we put that in

00:30:23,910 --> 00:30:29,250
span right so we have a span of bytes

00:30:25,320 --> 00:30:31,620
right your typical useful stuff now what

00:30:29,250 --> 00:30:33,090
we do is we have this new kind of

00:30:31,620 --> 00:30:34,500
interesting type called unbounded view

00:30:33,090 --> 00:30:36,420
and what that does is that takes a

00:30:34,500 --> 00:30:40,320
single iterator and basically acts as

00:30:36,420 --> 00:30:41,760
this kind of magical output output type

00:30:40,320 --> 00:30:44,760
that you're allowed to kind of dump

00:30:41,760 --> 00:30:46,950
things into infinitely we then have this

00:30:44,760 --> 00:30:49,380
this interesting encoding type called

00:30:46,950 --> 00:30:52,110
encoding scheme where you give it a

00:30:49,380 --> 00:30:53,940
normal encoding but then you can specify

00:30:52,110 --> 00:30:55,350
additional parameters such as I want to

00:30:53,940 --> 00:30:56,550
be big endian or I want to be little

00:30:55,350 --> 00:30:58,140
endian and the whole point of this

00:30:56,550 --> 00:31:00,330
encoding scheme is that you don't

00:30:58,140 --> 00:31:03,180
actually have to re-implement right like

00:31:00,330 --> 00:31:06,429
utf-16 but for big endian utf-16 but for

00:31:03,180 --> 00:31:09,999
little endian utf-16 for PDP onion

00:31:06,429 --> 00:31:11,259
the PDP machine but it's possible and so

00:31:09,999 --> 00:31:15,249
the idea is that you can go from this

00:31:11,259 --> 00:31:16,899
utf-16 that's in big endian to utf-8 and

00:31:15,249 --> 00:31:19,269
so you just call stood text transcode

00:31:16,899 --> 00:31:21,700
you give it an input range and output

00:31:19,269 --> 00:31:24,039
range the including you're coming from

00:31:21,700 --> 00:31:26,169
and the encoding you're going to and it

00:31:24,039 --> 00:31:28,929
converts everything right just like that

00:31:26,169 --> 00:31:30,129
and so in there and you you know

00:31:28,929 --> 00:31:32,139
obviously here we're just gonna kind of

00:31:30,129 --> 00:31:33,639
output the converted body because you

00:31:32,139 --> 00:31:35,379
know we don't have anything else want to

00:31:33,639 --> 00:31:36,460
do and so but this is kind of right all

00:31:35,379 --> 00:31:37,840
the stuff we're doing here this is like

00:31:36,460 --> 00:31:39,669
the dream right this is the top level

00:31:37,840 --> 00:31:41,169
like sticks texas easy you don't to

00:31:39,669 --> 00:31:42,580
worry about it too much this is what

00:31:41,169 --> 00:31:44,350
we're going after so i wanted to keep

00:31:42,580 --> 00:31:45,730
you in mind as we start going a little

00:31:44,350 --> 00:31:47,259
bit lower and like the layers of like

00:31:45,730 --> 00:31:48,970
how exactly are you doing this to tech

00:31:47,259 --> 00:31:50,799
stuff how exactly doing this basic text

00:31:48,970 --> 00:31:52,869
view these encode beauty what does that

00:31:50,799 --> 00:31:54,759
mean was that look like so we're gonna

00:31:52,869 --> 00:31:56,590
start digging a little deeper into the

00:31:54,759 --> 00:31:58,269
api right into the thing that i've been

00:31:56,590 --> 00:31:59,559
working on that you know i'm going to be

00:31:58,269 --> 00:32:01,869
proposing eventually for useful

00:31:59,559 --> 00:32:03,279
standardization obviously at the

00:32:01,869 --> 00:32:04,509
foundation are these encoding atif right

00:32:03,279 --> 00:32:07,570
and you saw them before right you saw a

00:32:04,509 --> 00:32:09,159
utf-8 utf-16 utf-32 you saw ascii narrow

00:32:07,570 --> 00:32:12,909
execution wide execution there's a bunch

00:32:09,159 --> 00:32:14,080
of stuff that are basically encoding

00:32:12,909 --> 00:32:15,159
objects and what these objects are they

00:32:14,080 --> 00:32:18,009
serve as this foundational building

00:32:15,159 --> 00:32:19,480
block and the idea is that these

00:32:18,009 --> 00:32:21,220
building blocks allow you to have

00:32:19,480 --> 00:32:23,200
seamless transcoding from one end of an

00:32:21,220 --> 00:32:24,610
api to another end of the api or

00:32:23,200 --> 00:32:25,779
couldn't code from one encoding to

00:32:24,610 --> 00:32:27,009
another encoding it without having to

00:32:25,779 --> 00:32:30,159
worry too much about all the inter

00:32:27,009 --> 00:32:32,919
details so I'm gonna set up a couple

00:32:30,159 --> 00:32:34,499
examples here where I'm gonna use some

00:32:32,919 --> 00:32:38,710
some helper types right so we have a

00:32:34,499 --> 00:32:40,119
span of car ITU a span of car 60 T span

00:32:38,710 --> 00:32:41,619
a few 32 T we have this like empty

00:32:40,119 --> 00:32:43,059
struct type that's going to come in

00:32:41,619 --> 00:32:47,499
handy later and we have this like

00:32:43,059 --> 00:32:48,669
encoding error enumeration class we also

00:32:47,499 --> 00:32:50,649
have some result types that we're going

00:32:48,669 --> 00:32:52,119
to be using so the idea is that if we

00:32:50,649 --> 00:32:54,909
have a decode result right well then we

00:32:52,119 --> 00:32:56,019
have the input the output the state that

00:32:54,909 --> 00:32:57,039
we were working on and then the error

00:32:56,019 --> 00:32:59,529
code right and it's the same thing for

00:32:57,039 --> 00:33:00,879
the end code result just the you 32 and

00:32:59,529 --> 00:33:03,639
you eight spanner flipped around for the

00:33:00,879 --> 00:33:05,230
input and output we also have a little

00:33:03,639 --> 00:33:07,929
bit of some airheads we're using

00:33:05,230 --> 00:33:10,899
Vittorio's hey we're using Vittorio

00:33:07,929 --> 00:33:13,509
Romeo's stood function ref as a kind of

00:33:10,899 --> 00:33:15,669
a lightweight easy to compile

00:33:13,509 --> 00:33:17,710
reference to a function and it has a

00:33:15,669 --> 00:33:19,900
feature that it returns an encode result

00:33:17,710 --> 00:33:21,730
or decode result after

00:33:19,900 --> 00:33:24,160
the initial encoding and the and the

00:33:21,730 --> 00:33:25,240
results itself and we'll explain this

00:33:24,160 --> 00:33:28,440
but we're just kind of setting out the

00:33:25,240 --> 00:33:32,410
example um so here is like the full like

00:33:28,440 --> 00:33:35,050
many gritty details of with all the

00:33:32,410 --> 00:33:36,640
necessary members and so the idea here

00:33:35,050 --> 00:33:38,320
is that you have an encode function

00:33:36,640 --> 00:33:42,520
which takes an input and output the

00:33:38,320 --> 00:33:44,380
current state you have and an Erica we

00:33:42,520 --> 00:33:47,410
also have a decode function which takes

00:33:44,380 --> 00:33:49,540
a decode result takes the u-32 span you

00:33:47,410 --> 00:33:51,130
expand output you have the state and you

00:33:49,540 --> 00:33:53,170
have an error handler then there's all

00:33:51,130 --> 00:33:56,560
these type deaths at the top and some of

00:33:53,170 --> 00:33:58,330
these other things and so the idea here

00:33:56,560 --> 00:34:01,000
is that you can define a code unit which

00:33:58,330 --> 00:34:02,950
is this which is the individual pieces

00:34:01,000 --> 00:34:05,140
of what make up an individual unit of

00:34:02,950 --> 00:34:07,090
information we have a code point which

00:34:05,140 --> 00:34:09,070
is the actual indivisible unit of

00:34:07,090 --> 00:34:10,570
information after it's been decoded we

00:34:09,070 --> 00:34:12,550
have a state type which tells which

00:34:10,570 --> 00:34:14,260
basically says this is the state I need

00:34:12,550 --> 00:34:16,210
to keep encoding and decoding stuff

00:34:14,260 --> 00:34:18,010
whenever you call me and then we have

00:34:16,210 --> 00:34:20,850
these two special like Matthew sounding

00:34:18,010 --> 00:34:25,120
is decode injective is encode injective

00:34:20,850 --> 00:34:27,280
and we're kind of gonna go walk through

00:34:25,120 --> 00:34:28,750
a lot of a lot of what this means of

00:34:27,280 --> 00:34:29,679
course we're going to show you first the

00:34:28,750 --> 00:34:30,820
thing to scare you a little bit this

00:34:29,679 --> 00:34:32,350
exactly what the gory details in the

00:34:30,820 --> 00:34:34,390
standard would look like I'm and it's

00:34:32,350 --> 00:34:35,620
actually what I've been implementing and

00:34:34,390 --> 00:34:37,270
so it's like static conscious burn we

00:34:35,620 --> 00:34:39,940
take templates everywhere and etc etc

00:34:37,270 --> 00:34:41,800
but you know I I very much like the the

00:34:39,940 --> 00:34:42,940
span based like simple clean

00:34:41,800 --> 00:34:45,070
implementation so we're gonna talk about

00:34:42,940 --> 00:34:47,260
in terms of this right you know obvious

00:34:45,070 --> 00:34:49,600
this all this gory stuff is just like to

00:34:47,260 --> 00:34:51,880
handle like arbitrary iterators that you

00:34:49,600 --> 00:34:53,230
hand me from like an ice stream iterator

00:34:51,880 --> 00:34:55,000
so we can handle it forward and like

00:34:53,230 --> 00:34:56,290
only input only iterators or whatever

00:34:55,000 --> 00:34:58,240
but that's again all the gory details

00:34:56,290 --> 00:35:00,580
and we're gonna kind of talk about this

00:34:58,240 --> 00:35:02,530
in the higher level terms right so code

00:35:00,580 --> 00:35:04,660
unit right like I said you know this is

00:35:02,530 --> 00:35:07,930
the things that that gets converted to

00:35:04,660 --> 00:35:09,340
individual code points and so there's

00:35:07,930 --> 00:35:11,020
various different kinds of their various

00:35:09,340 --> 00:35:13,440
number of code you second you have I'm

00:35:11,020 --> 00:35:17,230
super example for utf-8 as we saw on the

00:35:13,440 --> 00:35:18,820
we saw on the last slide there's a max

00:35:17,230 --> 00:35:21,940
code units of four and a Masco points of

00:35:18,820 --> 00:35:23,470
ones right so the co do is we're gonna

00:35:21,940 --> 00:35:25,420
have from utf-8 are from one to four

00:35:23,470 --> 00:35:27,220
right or one to four bytes right utf-16

00:35:25,420 --> 00:35:29,770
is wants to code units but each code

00:35:27,220 --> 00:35:31,630
unit is 16 bits so it's two to four

00:35:29,770 --> 00:35:32,180
bytes the fut of 32 which is one code

00:35:31,630 --> 00:35:34,460
unit but

00:35:32,180 --> 00:35:36,290
four bytes for each code you have that

00:35:34,460 --> 00:35:37,579
is ASCII which is one code unit to one

00:35:36,290 --> 00:35:40,210
byte which is gonna present an

00:35:37,579 --> 00:35:42,290
interesting case for our framework here

00:35:40,210 --> 00:35:43,839
again we also have code points which is

00:35:42,290 --> 00:35:47,950
again this is an indivisible unit of

00:35:43,839 --> 00:35:50,839
unambiguous a bit of information right

00:35:47,950 --> 00:35:53,089
and so the whole point is that this can

00:35:50,839 --> 00:35:55,250
introduce this represents basically

00:35:53,089 --> 00:35:57,559
everything that the the encoding can can

00:35:55,250 --> 00:35:58,430
vomit out right the point of view to

00:35:57,559 --> 00:35:59,930
code again is that it can kind of

00:35:58,430 --> 00:36:02,240
encapsulate everything so a single-car

00:35:59,930 --> 00:36:03,710
32 T or single utf-32 code point should

00:36:02,240 --> 00:36:05,720
be enough for everybody

00:36:03,710 --> 00:36:07,819
there's also again like I said some

00:36:05,720 --> 00:36:09,800
interesting problems with things like a

00:36:07,819 --> 00:36:11,240
see that we're going to talk about but

00:36:09,800 --> 00:36:15,470
again it's generally the the code point

00:36:11,240 --> 00:36:18,319
type if it uses just car 32 T the state

00:36:15,470 --> 00:36:20,450
is just a structure that contains all

00:36:18,319 --> 00:36:23,180
the things necessary to do stateful

00:36:20,450 --> 00:36:27,079
transformations on so in things like iso

00:36:23,180 --> 00:36:28,940
to 2022 JP there are these like shift

00:36:27,079 --> 00:36:31,280
states or modes that like that can be

00:36:28,940 --> 00:36:32,390
encoded into the stream and once you see

00:36:31,280 --> 00:36:34,490
those you have to change the way that

00:36:32,390 --> 00:36:37,450
you interpret the following stuff right

00:36:34,490 --> 00:36:39,500
and so these are stateful encodings that

00:36:37,450 --> 00:36:40,520
you know require this kind of state

00:36:39,500 --> 00:36:41,990
primering you to fill it out and do

00:36:40,520 --> 00:36:43,819
extra stuff with it right but thankfully

00:36:41,990 --> 00:36:45,230
the unicode encoding or the the three

00:36:43,819 --> 00:36:47,119
ones that we care about utf-8 sixteen

00:36:45,230 --> 00:36:51,530
thirty-two are all stateless so that's

00:36:47,119 --> 00:36:52,849
why we use an empty struct just the

00:36:51,530 --> 00:36:57,380
state equals empty struct right nice

00:36:52,849 --> 00:36:58,309
that's totally fine all right and so now

00:36:57,380 --> 00:36:59,809
let's talk about the encode and decode

00:36:58,309 --> 00:37:01,369
function right so these are basically

00:36:59,809 --> 00:37:03,200
two folks that take an input range and

00:37:01,369 --> 00:37:04,640
output range the current state in an

00:37:03,200 --> 00:37:07,250
error handler right and it computes

00:37:04,640 --> 00:37:08,540
exactly one and only one indivisible

00:37:07,250 --> 00:37:10,309
unit of information right so you go from

00:37:08,540 --> 00:37:12,559
multiple code units to one code point or

00:37:10,309 --> 00:37:16,670
one code point to multiple code units

00:37:12,559 --> 00:37:18,770
right and you can modify the state or G

00:37:16,670 --> 00:37:20,390
and do one of the above or you output an

00:37:18,770 --> 00:37:22,030
error right you know you you return an

00:37:20,390 --> 00:37:24,710
error code or you throw an error or you

00:37:22,030 --> 00:37:26,750
replace the text in the stream with

00:37:24,710 --> 00:37:27,530
replacement character the default that

00:37:26,750 --> 00:37:28,640
we're actually going to have for the

00:37:27,530 --> 00:37:31,640
library is the replacement character

00:37:28,640 --> 00:37:32,780
because there is so much malformed text

00:37:31,640 --> 00:37:34,819
in the world that if you were to

00:37:32,780 --> 00:37:37,579
actually have a throw error handler by

00:37:34,819 --> 00:37:39,799
default you'd actually DDoS like half of

00:37:37,579 --> 00:37:41,599
the world and that's probably not a good

00:37:39,799 --> 00:37:44,450
thing to do so replacement text care

00:37:41,599 --> 00:37:46,100
error handler is the one that gets used

00:37:44,450 --> 00:37:47,510
by default

00:37:46,100 --> 00:37:49,010
and now you maybe I wonder about this

00:37:47,510 --> 00:37:50,690
this thing called an output range right

00:37:49,010 --> 00:37:52,850
I'm sure you have output iterators right

00:37:50,690 --> 00:37:54,680
so like the extreme materials etc but

00:37:52,850 --> 00:37:57,650
the idea behind an output iterator is

00:37:54,680 --> 00:38:00,290
that you can basically have sized

00:37:57,650 --> 00:38:01,460
outputs right so if you've ever worked

00:38:00,290 --> 00:38:02,480
at CU plus for a while you've and you've

00:38:01,460 --> 00:38:04,640
ever used the algorithms like copy

00:38:02,480 --> 00:38:07,040
and/or copy you notice that they take

00:38:04,640 --> 00:38:08,750
only three pieces right the the iterator

00:38:07,040 --> 00:38:10,160
integrator or the iterator in size and

00:38:08,750 --> 00:38:12,020
then only a single iterator as the

00:38:10,160 --> 00:38:13,400
output iterator right and that's very

00:38:12,020 --> 00:38:15,650
easy to make them safe right I can

00:38:13,400 --> 00:38:16,940
easily run over my output buffer right

00:38:15,650 --> 00:38:18,050
and just like you know smash my stack

00:38:16,940 --> 00:38:19,820
destroy things create a security

00:38:18,050 --> 00:38:22,940
vulnerability whatever else right the

00:38:19,820 --> 00:38:24,290
thing about output ranges is that they

00:38:22,940 --> 00:38:25,910
contain both the beginning and the end

00:38:24,290 --> 00:38:29,060
of the output right so I could have a

00:38:25,910 --> 00:38:31,190
span of this output here and that allows

00:38:29,060 --> 00:38:34,190
me to say listen you only can output 16

00:38:31,190 --> 00:38:35,510
characters the size of my my the size of

00:38:34,190 --> 00:38:36,860
my string and then you got to stop right

00:38:35,510 --> 00:38:38,210
and then I get an error back that says

00:38:36,860 --> 00:38:40,630
and then the result type again error

00:38:38,210 --> 00:38:44,600
code that says you know income you know

00:38:40,630 --> 00:38:46,910
insufficient output right output size of

00:38:44,600 --> 00:38:48,710
course there are those people right

00:38:46,910 --> 00:38:50,690
it'll say listen I checked my sizes I

00:38:48,710 --> 00:38:53,420
checked my buffers I don't need your

00:38:50,690 --> 00:38:55,520
safety right and so this is one way to

00:38:53,420 --> 00:38:56,480
get more speed out of it right more and

00:38:55,520 --> 00:38:57,980
more you know they don't need your

00:38:56,480 --> 00:38:59,750
safety right so this is something called

00:38:57,980 --> 00:39:01,340
a nun again the unbounded view and the

00:38:59,750 --> 00:39:03,770
unbounded view takes a single iterator

00:39:01,340 --> 00:39:04,790
and has this like unreachable sentinel T

00:39:03,770 --> 00:39:07,520
so it's basically like it counts from

00:39:04,790 --> 00:39:08,900
zero to the end of time right and so you

00:39:07,520 --> 00:39:10,160
can keep using that iterator keep

00:39:08,900 --> 00:39:11,150
incrementing and always compare it and

00:39:10,160 --> 00:39:12,440
every time you compare to the end it

00:39:11,150 --> 00:39:13,670
says yep you know there's there's still

00:39:12,440 --> 00:39:15,740
more space right now you get totally

00:39:13,670 --> 00:39:17,300
over on your buffer but this is for the

00:39:15,740 --> 00:39:18,640
people who are like yes I checked

00:39:17,300 --> 00:39:20,870
everything it's totally safe it's fine

00:39:18,640 --> 00:39:23,360
for the people aren't extra dangerous

00:39:20,870 --> 00:39:24,740
right so you you want to live super damn

00:39:23,360 --> 00:39:26,870
easy right so you can not only use the

00:39:24,740 --> 00:39:28,160
unbounded view and just pass the pointer

00:39:26,870 --> 00:39:30,920
and say keep writing to the end of time

00:39:28,160 --> 00:39:33,530
you can also pass an assumed valid

00:39:30,920 --> 00:39:35,360
handler right so there's a cost to

00:39:33,530 --> 00:39:36,620
calling the error handler and say listen

00:39:35,360 --> 00:39:37,940
you need to call the error handling and

00:39:36,620 --> 00:39:40,100
you check that sins were right etc etc

00:39:37,940 --> 00:39:41,690
right what if you have some text in a

00:39:40,100 --> 00:39:43,940
database and you've already totally is

00:39:41,690 --> 00:39:45,140
you know made it so that it's utf-8 at

00:39:43,940 --> 00:39:48,620
all time you know this you've checked it

00:39:45,140 --> 00:39:50,780
it's great right so in this case you

00:39:48,620 --> 00:39:51,980
know you have to explicitly say assume

00:39:50,780 --> 00:39:53,180
valid handling right

00:39:51,980 --> 00:39:55,670
and so this is your way of opting into

00:39:53,180 --> 00:39:59,810
not only maximum speed with an unbounded

00:39:55,670 --> 00:40:01,040
view but a No

00:39:59,810 --> 00:40:02,990
to speed with the unbounded view but to

00:40:01,040 --> 00:40:04,580
say listen even if I have bad code point

00:40:02,990 --> 00:40:06,800
just ignore them right everything's fine

00:40:04,580 --> 00:40:08,420
assume valid handle just keep going and

00:40:06,800 --> 00:40:09,620
again this also makes it very easy in

00:40:08,420 --> 00:40:10,850
your code bases right so rather than

00:40:09,620 --> 00:40:12,380
looking for every single instance of

00:40:10,850 --> 00:40:14,240
copy which happens to take three

00:40:12,380 --> 00:40:16,490
iterators instead you have a very

00:40:14,240 --> 00:40:18,020
explicit way of saying listen I opted

00:40:16,490 --> 00:40:19,730
into the undefined behavior so if my

00:40:18,020 --> 00:40:21,500
code start exploding I know what I need

00:40:19,730 --> 00:40:23,720
to grab for first to find the problem

00:40:21,500 --> 00:40:28,040
right and this is again for safety and

00:40:23,720 --> 00:40:29,750
all that stuff no let's let's talk about

00:40:28,040 --> 00:40:32,390
these these uh these kind of Matthieu

00:40:29,750 --> 00:40:34,310
things um so is decode injective is

00:40:32,390 --> 00:40:35,960
encode objective and so the whole point

00:40:34,310 --> 00:40:37,880
of these is to provide additional safety

00:40:35,960 --> 00:40:40,520
to higher-level api's and even some

00:40:37,880 --> 00:40:41,840
lower-level api's and we're gonna kind

00:40:40,520 --> 00:40:43,730
of in to illustrate this with in with

00:40:41,840 --> 00:40:49,190
the ascii with the ascii encoding in the

00:40:43,730 --> 00:40:52,700
ask you problem so we have a utf-32

00:40:49,190 --> 00:40:53,990
literal the whole point here is that

00:40:52,700 --> 00:40:56,990
there's no way that a c can represent

00:40:53,990 --> 00:40:59,210
that right there's no byte sequence in

00:40:56,990 --> 00:41:03,170
ascii that represents dog emoji right it

00:40:59,210 --> 00:41:04,850
just doesn't exist right and so the idea

00:41:03,170 --> 00:41:08,180
here is that we want to static assert

00:41:04,850 --> 00:41:11,090
when the encoding of the decoding might

00:41:08,180 --> 00:41:13,180
not actually fit you know what it's

00:41:11,090 --> 00:41:17,270
trying to what's trying to do right so

00:41:13,180 --> 00:41:18,920
to give a bit of an example here's like

00:41:17,270 --> 00:41:23,450
you know the top the top part of the

00:41:18,920 --> 00:41:25,940
ascii the top part of the ascii encoding

00:41:23,450 --> 00:41:27,740
so going from ashley to unicode is fine

00:41:25,940 --> 00:41:28,910
right you can widen that just fine right

00:41:27,740 --> 00:41:30,290
in fact that's like a you know it's a

00:41:28,910 --> 00:41:32,960
you know if it's going from asking utf-8

00:41:30,290 --> 00:41:35,030
it's a mem copy from asking utf-32 you

00:41:32,960 --> 00:41:37,940
can use like a widen cindy and all other

00:41:35,030 --> 00:41:40,280
fun stuff but the whole point here is

00:41:37,940 --> 00:41:42,170
that going decoding is perfectly fine

00:41:40,280 --> 00:41:43,700
right it's a valid thing you can do but

00:41:42,170 --> 00:41:45,980
kosher muta code to ask you right going

00:41:43,700 --> 00:41:47,780
from the dog emoji right to some ASCII

00:41:45,980 --> 00:41:50,030
characters is not fine right this is

00:41:47,780 --> 00:41:52,010
work right so the way you often do this

00:41:50,030 --> 00:41:54,800
is by saying is encoding injected false

00:41:52,010 --> 00:41:57,290
type right and by defining it as this

00:41:54,800 --> 00:41:58,730
this false type what it does is it make

00:41:57,290 --> 00:42:00,020
sure that if you were to write something

00:41:58,730 --> 00:42:03,980
like this if you were to say listen in

00:42:00,020 --> 00:42:05,600
code this dog emoji as ascii you know

00:42:03,980 --> 00:42:06,890
you get a compiler error right in the

00:42:05,600 --> 00:42:08,690
class says this is a lossy conversion

00:42:06,890 --> 00:42:11,330
you can't do this right it doesn't work

00:42:08,690 --> 00:42:12,110
right so this is again for safety right

00:42:11,330 --> 00:42:13,400
to make sure that people don't

00:42:12,110 --> 00:42:15,260
accidentally start

00:42:13,400 --> 00:42:19,070
hang-up and trimming things that didn't

00:42:15,260 --> 00:42:20,420
really intend to do and so as another

00:42:19,070 --> 00:42:22,580
example right you see where it passed a

00:42:20,420 --> 00:42:23,660
default text handler right and you did

00:42:22,580 --> 00:42:25,580
this right you're still getting a pilot

00:42:23,660 --> 00:42:28,010
error but if you were to say listen I

00:42:25,580 --> 00:42:30,290
know what I'm doing you know I'm using

00:42:28,010 --> 00:42:32,000
the ASCII encoding but I want the

00:42:30,290 --> 00:42:33,410
replacement handler right and so what's

00:42:32,000 --> 00:42:34,820
happened to this will replace the dog

00:42:33,410 --> 00:42:35,900
emoji was just a question mark right

00:42:34,820 --> 00:42:37,940
because that's what that's all I can

00:42:35,900 --> 00:42:40,040
handle right so get a question mark out

00:42:37,940 --> 00:42:41,780
and this is what code will compile now

00:42:40,040 --> 00:42:43,400
but use was specially asked for the fact

00:42:41,780 --> 00:42:44,630
that listen you know I don't care if I

00:42:43,400 --> 00:42:46,190
lose information right just replace the

00:42:44,630 --> 00:42:49,490
text or throw an error or whatever else

00:42:46,190 --> 00:42:51,880
right and that's the way that you do

00:42:49,490 --> 00:42:53,960
that right so you have to be explicit

00:42:51,880 --> 00:42:55,550
and so just have the quick overview

00:42:53,960 --> 00:42:58,430
these are all the encoding that you want

00:42:55,550 --> 00:43:00,590
to provide the standard right so we have

00:42:58,430 --> 00:43:02,990
the ASCII the narrow and wide utf-8

00:43:00,590 --> 00:43:05,510
16:32 but we also have these other types

00:43:02,990 --> 00:43:08,840
right and the reason we have these basic

00:43:05,510 --> 00:43:10,550
utf-8 or basic utf-16 or basic utf-32 is

00:43:08,840 --> 00:43:11,930
because there are plenty of code bases

00:43:10,550 --> 00:43:13,520
out in the world where they don't have

00:43:11,930 --> 00:43:16,490
the time to trip the port everything

00:43:13,520 --> 00:43:19,010
from car to car 8t right so you should

00:43:16,490 --> 00:43:21,140
be able to pass car to basic utf-8 and

00:43:19,010 --> 00:43:23,600
form your own utf-8 handler that works

00:43:21,140 --> 00:43:25,340
off car I don't recommend it because car

00:43:23,600 --> 00:43:27,170
can be signed or unsigned on a certain

00:43:25,340 --> 00:43:29,810
platform and so if you haven't be doing

00:43:27,170 --> 00:43:31,040
some unicode math right you can

00:43:29,810 --> 00:43:33,170
accidentally start like truncating or

00:43:31,040 --> 00:43:35,210
missing or like mangling the text so

00:43:33,170 --> 00:43:37,160
please don't use car but we live in a

00:43:35,210 --> 00:43:39,250
world where people already do that right

00:43:37,160 --> 00:43:41,300
and I can actually get them to

00:43:39,250 --> 00:43:43,370
completely rewrite their whole code base

00:43:41,300 --> 00:43:44,540
right so this is their way right they

00:43:43,370 --> 00:43:46,910
gotta be explicit about they gotta you

00:43:44,540 --> 00:43:47,870
know use the basic utf-8 stuff everybody

00:43:46,910 --> 00:43:50,660
else gets the nice stuff right you get

00:43:47,870 --> 00:43:54,880
the nice car et car 16 car 32 T short

00:43:50,660 --> 00:43:57,770
names so that's a full overview of the

00:43:54,880 --> 00:43:59,840
objects itself right so now I want to

00:43:57,770 --> 00:44:01,220
talk about beyond the objects right so

00:43:59,840 --> 00:44:02,300
we have these like low-level encoding

00:44:01,220 --> 00:44:04,790
option you have it you have like these

00:44:02,300 --> 00:44:05,960
singular like encode 1 decode one at a

00:44:04,790 --> 00:44:06,950
time functions and they're nice and

00:44:05,960 --> 00:44:09,880
they're pretty and you can put them

00:44:06,950 --> 00:44:13,520
together to make interesting things sure

00:44:09,880 --> 00:44:14,840
but we need some speed right I had

00:44:13,520 --> 00:44:17,600
showed you that slide before where we

00:44:14,840 --> 00:44:21,230
did the loop over the the the MB the MB

00:44:17,600 --> 00:44:22,820
to C 32 character thing right with the C

00:44:21,230 --> 00:44:23,990
function and I was slow loop and the

00:44:22,820 --> 00:44:26,030
performance was terrible at cetera et

00:44:23,990 --> 00:44:27,350
cetera the performance of this is also

00:44:26,030 --> 00:44:31,700
terrible right

00:44:27,350 --> 00:44:34,040
but there's more and so what we have is

00:44:31,700 --> 00:44:35,360
here is a three-speed approach and the

00:44:34,040 --> 00:44:37,040
idea is that they're the slowest path

00:44:35,360 --> 00:44:38,540
which is a round-trip transcoding it's

00:44:37,040 --> 00:44:41,570
very lazy it does one that with one

00:44:38,540 --> 00:44:43,040
thing at a time very very nice and then

00:44:41,570 --> 00:44:45,200
there's a faster path where you directly

00:44:43,040 --> 00:44:46,790
transcode there's no round-tripping but

00:44:45,200 --> 00:44:48,500
it still lazy and then it's the absolute

00:44:46,790 --> 00:44:50,930
fastest path which is both processing

00:44:48,500 --> 00:44:53,000
ear consumption to give me all the code

00:44:50,930 --> 00:44:54,710
points at once I will transport them all

00:44:53,000 --> 00:44:57,440
the way to the to the other encoding all

00:44:54,710 --> 00:44:58,460
at the same time right so let's let's

00:44:57,440 --> 00:44:59,870
all see let's talk about the slowest

00:44:58,460 --> 00:45:01,700
paths right so we have this nice little

00:44:59,870 --> 00:45:04,850
diagram here basically you have an

00:45:01,700 --> 00:45:07,190
encoded single input right you decode

00:45:04,850 --> 00:45:08,780
that to a Unicode code point you have a

00:45:07,190 --> 00:45:10,430
you take that Unicode appointment and

00:45:08,780 --> 00:45:12,410
you encode it to the other thing right

00:45:10,430 --> 00:45:13,910
and then you dump out the the single

00:45:12,410 --> 00:45:16,270
you're the single output character right

00:45:13,910 --> 00:45:18,440
or the single output unit of information

00:45:16,270 --> 00:45:20,420
and this is good for disparate encodings

00:45:18,440 --> 00:45:22,780
right if I need to go from shift key is

00:45:20,420 --> 00:45:26,300
2 GB 18 both

00:45:22,780 --> 00:45:29,510
GP 180 30 which is the Chinese ink which

00:45:26,300 --> 00:45:33,830
is the the Chinese which is the National

00:45:29,510 --> 00:45:36,230
Chinese encoding I can't like just have

00:45:33,830 --> 00:45:38,120
I can't write like a routine that if Li

00:45:36,230 --> 00:45:41,210
does that right I need something that

00:45:38,120 --> 00:45:43,100
like decodes to Unicode and then takes

00:45:41,210 --> 00:45:45,890
the Unicode and puts it back into the

00:45:43,100 --> 00:45:47,270
Chinese encoding right and so the idea

00:45:45,890 --> 00:45:48,770
is that we always round-trip to Unicode

00:45:47,270 --> 00:45:50,450
because you never always go into Unicode

00:45:48,770 --> 00:45:52,340
is is a lossless operation right because

00:45:50,450 --> 00:45:55,280
again it's Unicode it's Universal code

00:45:52,340 --> 00:45:58,370
right and so the idea here is that we

00:45:55,280 --> 00:46:00,610
always round trip and you know you

00:45:58,370 --> 00:46:04,250
either call encode and decode explicitly

00:46:00,610 --> 00:46:05,600
or use types like a textview we also

00:46:04,250 --> 00:46:07,550
have some additional types which don't

00:46:05,600 --> 00:46:10,490
do things like normalization but only do

00:46:07,550 --> 00:46:13,460
the encode decode or transcode stack and

00:46:10,490 --> 00:46:15,470
so the way we do this is we have these

00:46:13,460 --> 00:46:17,090
encode decode transcode views you

00:46:15,470 --> 00:46:18,830
basically plug in you were rained like a

00:46:17,090 --> 00:46:21,110
stud string view you plug in the

00:46:18,830 --> 00:46:22,550
encoding like the narrow execution then

00:46:21,110 --> 00:46:25,280
you say listen I'm going to utf-32

00:46:22,550 --> 00:46:27,020
right and then just converts right you

00:46:25,280 --> 00:46:29,390
can you can use and arrange for it's

00:46:27,020 --> 00:46:30,950
very lazy it's very simple right you can

00:46:29,390 --> 00:46:32,600
go from any encoding to any encoding as

00:46:30,950 --> 00:46:34,580
long as there code point types match

00:46:32,600 --> 00:46:36,500
right so this is this makes it scalable

00:46:34,580 --> 00:46:38,600
right you know it's like handwrite like

00:46:36,500 --> 00:46:39,380
a I'm going from shift yeah ask Japanese

00:46:38,600 --> 00:46:41,480
encoding

00:46:39,380 --> 00:46:42,500
you know episodic IBM's encoding right

00:46:41,480 --> 00:46:44,630
you don't have to do that right you just

00:46:42,500 --> 00:46:46,160
it takes care of a whole round trip for

00:46:44,630 --> 00:46:48,350
you right so all your only

00:46:46,160 --> 00:46:50,180
responsibility is to write one good

00:46:48,350 --> 00:46:52,340
encoding object right that handles the

00:46:50,180 --> 00:46:53,780
encode and the decode from your code

00:46:52,340 --> 00:46:55,220
unit and code point types and then

00:46:53,780 --> 00:46:59,870
everything else to scales beyond that

00:46:55,220 --> 00:47:01,100
right it's slow but it scales and so you

00:46:59,870 --> 00:47:03,050
know this is kind of like a bit of a

00:47:01,100 --> 00:47:04,880
snapshot of the code I have written so

00:47:03,050 --> 00:47:06,770
basically you take the decode result you

00:47:04,880 --> 00:47:10,010
call the encoding from you decode you

00:47:06,770 --> 00:47:11,750
check if something went wrong you have

00:47:10,010 --> 00:47:14,000
otherwise you use the intermediate

00:47:11,750 --> 00:47:16,040
storage to encode to the next day and

00:47:14,000 --> 00:47:17,870
then if there happens otherwise you're

00:47:16,040 --> 00:47:22,820
fine you know it's a very kind of slow

00:47:17,870 --> 00:47:24,020
process but obviously need be faster

00:47:22,820 --> 00:47:25,400
than that right I mean if we'd always

00:47:24,020 --> 00:47:27,050
round-trip and we do it one at a time

00:47:25,400 --> 00:47:30,200
we'll have the same problems as I

00:47:27,050 --> 00:47:31,670
mention before the C functions so we

00:47:30,200 --> 00:47:33,680
want something a little bit faster right

00:47:31,670 --> 00:47:34,910
like maybe we can't write a whole CMD

00:47:33,680 --> 00:47:36,590
optimized thing but maybe we can

00:47:34,910 --> 00:47:40,910
transcode between one encoding and

00:47:36,590 --> 00:47:43,010
another very very quickly right and so

00:47:40,910 --> 00:47:46,310
this kind of chops out one of these

00:47:43,010 --> 00:47:47,840
steps in the diagram and so now you're

00:47:46,310 --> 00:47:49,760
kind of going from the coda single input

00:47:47,840 --> 00:47:51,770
you're directly transcoding then you

00:47:49,760 --> 00:47:53,120
have your single output right and so the

00:47:51,770 --> 00:47:54,800
way you do this is you write this this

00:47:53,120 --> 00:47:57,230
interesting function called text

00:47:54,800 --> 00:47:58,160
transcode one and this is an ADL

00:47:57,230 --> 00:48:01,820
function that you can write literally

00:47:58,160 --> 00:48:04,280
anywhere and it's a little bit faster

00:48:01,820 --> 00:48:05,810
but it's not the fastest and the idea is

00:48:04,280 --> 00:48:07,670
that the standard will always look for

00:48:05,810 --> 00:48:09,560
your version of text transcode one to do

00:48:07,670 --> 00:48:14,510
this like one to one this one by wanting

00:48:09,560 --> 00:48:16,220
a transcoding and by doing that you're

00:48:14,510 --> 00:48:18,340
allowed to hook the implementation with

00:48:16,220 --> 00:48:22,610
this very simple with this function to

00:48:18,340 --> 00:48:25,520
get the job done now it doesn't

00:48:22,610 --> 00:48:26,660
necessarily look all that pretty there's

00:48:25,520 --> 00:48:28,790
a lot of information coming in here

00:48:26,660 --> 00:48:31,070
right so you need to have the input the

00:48:28,790 --> 00:48:33,010
output the input and coding the output

00:48:31,070 --> 00:48:39,350
encoding input state output state

00:48:33,010 --> 00:48:42,980
decoder and the good news is if I'm

00:48:39,350 --> 00:48:43,850
going from utf-8 to utf-32 I don't

00:48:42,980 --> 00:48:46,580
really have to do that much right I just

00:48:43,850 --> 00:48:49,190
at the decode write because the output

00:48:46,580 --> 00:48:52,100
the output of decode is already a utf-32

00:48:49,190 --> 00:48:53,030
unicode character right so I don't have

00:48:52,100 --> 00:48:55,800
to like

00:48:53,030 --> 00:48:58,110
decode and then encode again I just

00:48:55,800 --> 00:48:59,910
called eco right tonight I'm done right

00:48:58,110 --> 00:49:01,110
and so this is something that the

00:48:59,910 --> 00:49:02,790
standard will do for you for free but

00:49:01,110 --> 00:49:04,440
this is an example of like I already

00:49:02,790 --> 00:49:06,570
know right that I'm liking a decode

00:49:04,440 --> 00:49:07,890
something and it's already gonna be the

00:49:06,570 --> 00:49:09,840
right state right I don't have to do any

00:49:07,890 --> 00:49:11,780
extra work here so just just decode it

00:49:09,840 --> 00:49:14,670
right just do that nice and naturally

00:49:11,780 --> 00:49:16,170
and so again the whole idea is that you

00:49:14,670 --> 00:49:18,960
can write things for like utf-16 to

00:49:16,170 --> 00:49:21,300
utf-8 or maybe one of the chinese gb

00:49:18,960 --> 00:49:24,510
encoding uh you know the large rivers

00:49:21,300 --> 00:49:27,660
and larger UTF version gb 180 30 right

00:49:24,510 --> 00:49:29,670
because gb 130 is acts like a superset

00:49:27,660 --> 00:49:30,960
of a lot of the gpk and legacy chinese

00:49:29,670 --> 00:49:32,840
encodings i'm so you can actually

00:49:30,960 --> 00:49:37,470
sometimes just like directly mem copy

00:49:32,840 --> 00:49:38,910
and so in this case you know it's still

00:49:37,470 --> 00:49:40,770
the same interface right so you still

00:49:38,910 --> 00:49:42,450
have this lazy view thing right and

00:49:40,770 --> 00:49:43,530
you're still writing the same code it

00:49:42,450 --> 00:49:45,000
just have to be calling your transferred

00:49:43,530 --> 00:49:46,350
one every time to do a little bit faster

00:49:45,000 --> 00:49:47,790
right and so this is a little bit faster

00:49:46,350 --> 00:49:49,740
and you you would think this would this

00:49:47,790 --> 00:49:51,120
is not that great but Zack Lane with

00:49:49,740 --> 00:49:52,380
boost text has an iterator based

00:49:51,120 --> 00:49:54,600
approach that's very similar to this and

00:49:52,380 --> 00:49:56,760
he wrote direct transcode from utf-8

00:49:54,600 --> 00:49:58,050
utf-16 and whatever and when we stack up

00:49:56,760 --> 00:49:59,160
his implementation in a bunch of

00:49:58,050 --> 00:50:00,840
benchmarks is the imputation was

00:49:59,160 --> 00:50:02,610
actually pretty fast not the fastest not

00:50:00,840 --> 00:50:05,040
even complete he was faster than almost

00:50:02,610 --> 00:50:06,810
everybody else but he didn't beat the

00:50:05,040 --> 00:50:07,530
sim D optimist and optimize function

00:50:06,810 --> 00:50:09,720
which is something we're gonna talk

00:50:07,530 --> 00:50:12,360
about in a little bit actually or right

00:50:09,720 --> 00:50:12,980
now so obviously we need a little bit

00:50:12,360 --> 00:50:15,900
more

00:50:12,980 --> 00:50:18,060
we need a fastest path we need something

00:50:15,900 --> 00:50:20,010
that can go blazingly fast like king all

00:50:18,060 --> 00:50:21,990
the input dump it into all the output

00:50:20,010 --> 00:50:23,040
right this is like what your wide card

00:50:21,990 --> 00:50:25,410
on multi fighter multi black to white

00:50:23,040 --> 00:50:26,880
car and windows looks like this is what

00:50:25,410 --> 00:50:29,220
some of the fire this is what the

00:50:26,880 --> 00:50:32,730
encoding artist at henry saponin wrote

00:50:29,220 --> 00:50:35,400
from firefox these are the things that

00:50:32,730 --> 00:50:38,820
we need to enable great performance

00:50:35,400 --> 00:50:42,870
right so in order to do that we need to

00:50:38,820 --> 00:50:44,340
have another hook for that right so the

00:50:42,870 --> 00:50:47,190
first thing that we do right is we

00:50:44,340 --> 00:50:49,200
enable the standard itself to have a way

00:50:47,190 --> 00:50:50,790
of fast transcoding so we bake these we

00:50:49,200 --> 00:50:53,100
basically make these these new functions

00:50:50,790 --> 00:50:54,780
right called encode decode in trance

00:50:53,100 --> 00:50:57,240
code and basically what you can do is

00:50:54,780 --> 00:50:59,190
you can take an input give it an output

00:50:57,240 --> 00:51:00,630
encoding right and it's just tran codes

00:50:59,190 --> 00:51:02,040
everything right the whole thing at the

00:51:00,630 --> 00:51:03,450
same whole thing at once right this is

00:51:02,040 --> 00:51:05,039
this is from the example that you saw

00:51:03,450 --> 00:51:08,109
you know in the beginning right

00:51:05,039 --> 00:51:12,099
and so you can take tax this is this is

00:51:08,109 --> 00:51:14,619
a litter view qualified string literal

00:51:12,099 --> 00:51:17,680
which makes it a car 16 Tierra or utf-16

00:51:14,619 --> 00:51:21,309
literal and transpose it to utf-8 all at

00:51:17,680 --> 00:51:23,380
once right and the whole point about

00:51:21,309 --> 00:51:24,789
this is that we need to also enable not

00:51:23,380 --> 00:51:26,470
only the standard to transport

00:51:24,789 --> 00:51:28,660
everything once but the users to write a

00:51:26,470 --> 00:51:30,339
function on top of that that has their

00:51:28,660 --> 00:51:31,900
things call right because the whole

00:51:30,339 --> 00:51:34,150
point is that the standard can't make

00:51:31,900 --> 00:51:36,099
every single person happy right it needs

00:51:34,150 --> 00:51:38,200
to be everything for everyone but you

00:51:36,099 --> 00:51:39,400
know I can't expect Billy O'Neil to

00:51:38,200 --> 00:51:41,980
spend all his time in the world

00:51:39,400 --> 00:51:43,750
making sure episode 8 - you know utf-8

00:51:41,980 --> 00:51:45,190
is very fast because EPS today is a

00:51:43,750 --> 00:51:46,960
legacy encoding that racing only exists

00:51:45,190 --> 00:51:48,520
in the z/os ecosystem and while they

00:51:46,960 --> 00:51:49,720
might get some text in a while that

00:51:48,520 --> 00:51:51,549
represents that and they might have an

00:51:49,720 --> 00:51:52,720
encoding object for that they can't

00:51:51,549 --> 00:51:54,339
spend all their time in the world like

00:51:52,720 --> 00:51:56,289
sim D optimizing or whatever else right

00:51:54,339 --> 00:51:58,720
but IBM is going to care about

00:51:56,289 --> 00:52:01,240
optimizing episodic to utf-8 because

00:51:58,720 --> 00:52:04,780
well their entire ecosystem is based off

00:52:01,240 --> 00:52:06,460
apps attack right so we need to have a

00:52:04,780 --> 00:52:07,720
way that the user can customize the user

00:52:06,460 --> 00:52:11,020
the person outside the standard can

00:52:07,720 --> 00:52:14,279
customize all this stuff right and so

00:52:11,020 --> 00:52:17,799
the way you do this is with the text and

00:52:14,279 --> 00:52:18,849
D or transcode functions right so this

00:52:17,799 --> 00:52:21,099
case we have an example of text

00:52:18,849 --> 00:52:23,109
transcode you have a input output you

00:52:21,099 --> 00:52:24,190
have the encoding types you have an

00:52:23,109 --> 00:52:26,289
empty Struck's again there are these

00:52:24,190 --> 00:52:28,210
trucks we don't care about them and they

00:52:26,289 --> 00:52:30,160
decode here right and we're using this

00:52:28,210 --> 00:52:32,410
we're this weird thing called UTF utils

00:52:30,160 --> 00:52:39,339
FC convert right which is a sim D

00:52:32,410 --> 00:52:40,900
optimized conversion function parameters

00:52:39,339 --> 00:52:42,279
and that's basically how texture encode

00:52:40,900 --> 00:52:43,779
works right and you might think well

00:52:42,279 --> 00:52:46,299
hold on you're a little you're cheating

00:52:43,779 --> 00:52:48,430
here right this UTF utils SSE convert

00:52:46,299 --> 00:52:49,900
like you know you have to show some code

00:52:48,430 --> 00:52:51,369
about this right leg come on you get

00:52:49,900 --> 00:52:53,170
this cheating you know Tara but it's

00:52:51,369 --> 00:52:55,119
gonna be fast but I don't have to

00:52:53,170 --> 00:52:57,789
because it was already a very lovely

00:52:55,119 --> 00:53:00,700
handsome man named Bob steagle who did

00:52:57,789 --> 00:53:02,920
this already UTF the the the UTF utils

00:53:00,700 --> 00:53:04,720
the SD convert he wrote this function he

00:53:02,920 --> 00:53:06,250
finished it he benchmarked it right and

00:53:04,720 --> 00:53:08,079
he presented about it at C peak on a

00:53:06,250 --> 00:53:09,309
year ago right and so he talked about

00:53:08,079 --> 00:53:10,690
the DFA they wrote everything else

00:53:09,309 --> 00:53:12,190
didn't provide the performance benchmark

00:53:10,690 --> 00:53:13,630
for e benchmarked notley's axe library

00:53:12,190 --> 00:53:15,339
but his library right and he showed that

00:53:13,630 --> 00:53:17,410
he had a fast SMI D optimized

00:53:15,339 --> 00:53:18,280
implementation right and so the whole

00:53:17,410 --> 00:53:20,140
point is that

00:53:18,280 --> 00:53:23,290
Bob steagle right working for company

00:53:20,140 --> 00:53:25,180
acts can crack open this extension point

00:53:23,290 --> 00:53:26,440
put in as utf-8 utils that they've

00:53:25,180 --> 00:53:28,470
already hyper optimized for their

00:53:26,440 --> 00:53:32,350
architecture it was the West mayor and

00:53:28,470 --> 00:53:34,180
use it right so now you know it's not on

00:53:32,350 --> 00:53:36,250
it's not an STL it's not Jonathan whale

00:53:34,180 --> 00:53:38,110
it's not on all those people to write

00:53:36,250 --> 00:53:39,460
fast implementations right if you really

00:53:38,110 --> 00:53:40,930
care at the standards too slow for you

00:53:39,460 --> 00:53:42,910
crack it open and do it yourself

00:53:40,930 --> 00:53:45,190
right because likely right Firefox

00:53:42,910 --> 00:53:46,900
Chrome Bloomberg IBM they already all

00:53:45,190 --> 00:53:48,100
have these implementations right so just

00:53:46,900 --> 00:53:50,140
let them use what they already have

00:53:48,100 --> 00:53:51,370
right they get the nice you know they

00:53:50,140 --> 00:53:56,290
get the nice syntax with the you know

00:53:51,370 --> 00:53:57,670
the the the they get the they get they

00:53:56,290 --> 00:53:58,990
get this nice syntax in everything right

00:53:57,670 --> 00:54:00,070
and so they can use this everywhere but

00:53:58,990 --> 00:54:01,420
they can still have their their

00:54:00,070 --> 00:54:03,490
implementation their internals on the

00:54:01,420 --> 00:54:05,200
inside right and that's that's very

00:54:03,490 --> 00:54:06,880
important right because but this allows

00:54:05,200 --> 00:54:08,920
people is to slowly port their code over

00:54:06,880 --> 00:54:10,750
slowly take over it and you can have

00:54:08,920 --> 00:54:12,220
this kind of thing slowly increment

00:54:10,750 --> 00:54:14,650
incrementally take over a code base

00:54:12,220 --> 00:54:15,730
right which is you know the whole the

00:54:14,650 --> 00:54:16,720
point right you know we want people to

00:54:15,730 --> 00:54:19,750
use better things right

00:54:16,720 --> 00:54:24,070
I wasn't backwards sorry

00:54:19,750 --> 00:54:26,050
and so I guess the the next thing I

00:54:24,070 --> 00:54:28,930
should really talk about is serene

00:54:26,050 --> 00:54:30,190
development right one of the things that

00:54:28,930 --> 00:54:31,510
Thom Hartmann said when I presented this

00:54:30,190 --> 00:54:33,070
idea to him and everything he said this

00:54:31,510 --> 00:54:34,840
is foundation work that is needed for

00:54:33,070 --> 00:54:37,360
C's was 23 to enable nanak first to

00:54:34,840 --> 00:54:40,780
write hello world i mean not the typical

00:54:37,360 --> 00:54:46,600
ascii world but you know earth america

00:54:40,780 --> 00:54:48,370
is you know emoji world and so the the

00:54:46,600 --> 00:54:50,440
ID here's i wrote a paper it's called p

00:54:48,370 --> 00:54:52,090
16 2009 has a lot of this information a

00:54:50,440 --> 00:54:57,130
little bit less because i posit for this

00:54:52,090 --> 00:54:59,230
this talk but this paper right is a

00:54:57,130 --> 00:55:00,970
library it's a purely library thing

00:54:59,230 --> 00:55:02,950
right there's a lot of work i have to do

00:55:00,970 --> 00:55:04,810
right to like go to like lib chulip see

00:55:02,950 --> 00:55:06,460
and like talk to the Musil people and

00:55:04,810 --> 00:55:14,950
like be like hey i need to implement you

00:55:06,460 --> 00:55:16,750
know but this is an implementation right

00:55:14,950 --> 00:55:18,670
I can't convince implementers of this

00:55:16,750 --> 00:55:20,890
fully where I can give a CP can talk you

00:55:18,670 --> 00:55:22,060
can do XY and Z but in order to convince

00:55:20,890 --> 00:55:24,610
implementers flew that this is like

00:55:22,060 --> 00:55:26,790
tractable and workable I need to be able

00:55:24,610 --> 00:55:30,250
to produce an implementation of this and

00:55:26,790 --> 00:55:33,280
in order to do this right I have to you

00:55:30,250 --> 00:55:34,570
know get some sponsorship right so the

00:55:33,280 --> 00:55:37,540
idea is that I want to have an extended

00:55:34,570 --> 00:55:39,040
implementation by 2020 right I can do

00:55:37,540 --> 00:55:40,750
this in my spirit in my spare time right

00:55:39,040 --> 00:55:42,070
I built you know my other library sold

00:55:40,750 --> 00:55:44,380
to out point or whatever in my spare

00:55:42,070 --> 00:55:45,550
time but this is a very serious

00:55:44,380 --> 00:55:48,580
undertaking that will take an

00:55:45,550 --> 00:55:50,200
extraordinary amount of time and so in

00:55:48,580 --> 00:55:51,790
this case right if you want to see this

00:55:50,200 --> 00:55:54,790
in C++ we want to see the support if you

00:55:51,790 --> 00:55:56,830
want to get somewhere quickly right I

00:55:54,790 --> 00:55:59,320
need to spend a lot more time on this

00:55:56,830 --> 00:56:00,310
than I normally have and so in this case

00:55:59,320 --> 00:56:02,290
right I'm going to be starting to reach

00:56:00,310 --> 00:56:04,900
out to individuals and companies right

00:56:02,290 --> 00:56:06,880
to see if they can support having this

00:56:04,900 --> 00:56:08,230
in cease was 20 right you know if you

00:56:06,880 --> 00:56:10,330
know obviously if a certain company

00:56:08,230 --> 00:56:12,280
gives me you know enough funding I can

00:56:10,330 --> 00:56:13,480
make it special for them etc etc but the

00:56:12,280 --> 00:56:15,400
whole idea is to have something that's

00:56:13,480 --> 00:56:17,110
early in the series 23 cycle so we can

00:56:15,400 --> 00:56:18,880
get the encoding decoding normalization

00:56:17,110 --> 00:56:20,860
parts done and finally start actually

00:56:18,880 --> 00:56:22,390
talked about the the cool parts right

00:56:20,860 --> 00:56:24,370
the bi-directional algorithms that allow

00:56:22,390 --> 00:56:26,890
us to have Hebrew and Arabic right

00:56:24,370 --> 00:56:29,830
actually in our program right in a

00:56:26,890 --> 00:56:31,960
sensible reasonable way right without

00:56:29,830 --> 00:56:36,490
people having to you know be held

00:56:31,960 --> 00:56:37,510
hostage by ICU so this is the work I'm

00:56:36,490 --> 00:56:39,130
trying to do and so I'm going to be

00:56:37,510 --> 00:56:40,330
working on getting sponsorship working

00:56:39,130 --> 00:56:41,410
on trying to improve the world working

00:56:40,330 --> 00:56:44,110
on trying to make the digitally

00:56:41,410 --> 00:56:45,910
underserved of the world finally have a

00:56:44,110 --> 00:56:48,520
place in the lowest level language that

00:56:45,910 --> 00:56:50,290
sits below most of everything else so if

00:56:48,520 --> 00:56:53,550
we can do this right then we can really

00:56:50,290 --> 00:56:55,900
accelerate making it easy for people who

00:56:53,550 --> 00:56:58,210
you know who are just like you know I'm

00:56:55,900 --> 00:56:59,980
a US person right you know but I I don't

00:56:58,210 --> 00:57:01,240
know more than English right but we want

00:56:59,980 --> 00:57:03,040
so want them to be you'll have an easy

00:57:01,240 --> 00:57:04,420
time supporting other people in the

00:57:03,040 --> 00:57:06,250
world right and that's been pretty much

00:57:04,420 --> 00:57:08,170
the crux the problem right we have

00:57:06,250 --> 00:57:09,820
systems that make it easy to do you to

00:57:08,170 --> 00:57:11,350
ASCII all the time but we don't have

00:57:09,820 --> 00:57:13,450
systems that make it easy to use utf-8

00:57:11,350 --> 00:57:14,590
all the time or to transcode from this

00:57:13,450 --> 00:57:16,990
or to handle this script or to have

00:57:14,590 --> 00:57:21,980
bi-directional text and so this is what

00:57:16,990 --> 00:57:25,490
we're going to be working on thank you

00:57:21,980 --> 00:57:28,920
[Applause]

00:57:25,490 --> 00:57:31,170
so on you have a little bit of time for

00:57:28,920 --> 00:57:32,850
questions so if anyone has any questions

00:57:31,170 --> 00:57:38,570
or things I want to point out I'm more

00:57:32,850 --> 00:57:41,040
than happy to answer yeah hello

00:57:38,570 --> 00:57:44,220
first of all very good work and thank

00:57:41,040 --> 00:57:45,390
you for already being taking this on one

00:57:44,220 --> 00:57:47,520
thing that is interesting about a

00:57:45,390 --> 00:57:49,320
conversion process that there is one

00:57:47,520 --> 00:57:52,830
piece of information that is actually

00:57:49,320 --> 00:57:54,810
being lost in the process and it's as

00:57:52,830 --> 00:57:57,000
far as the length of the strains concern

00:57:54,810 --> 00:57:59,100
so when you have some characters that

00:57:57,000 --> 00:58:02,700
are reducing in land during the

00:57:59,100 --> 00:58:04,590
transcoding there can be tables that can

00:58:02,700 --> 00:58:06,570
be built during the process to keep the

00:58:04,590 --> 00:58:09,750
displacement information which can be

00:58:06,570 --> 00:58:12,090
very useful for certain use cases yeah

00:58:09,750 --> 00:58:13,350
so that's something that we're trying to

00:58:12,090 --> 00:58:15,420
work on with the encoding Eric because

00:58:13,350 --> 00:58:16,590
I'm so I saw I showed you like the text

00:58:15,420 --> 00:58:17,550
view in the encoding and decoding right

00:58:16,590 --> 00:58:18,480
so a lot of that information actually

00:58:17,550 --> 00:58:20,130
supposed to be like kept on the

00:58:18,480 --> 00:58:21,840
iterators to make it easy to like do

00:58:20,130 --> 00:58:23,400
operations right now we only have

00:58:21,840 --> 00:58:25,020
read-only iterators so that we don't

00:58:23,400 --> 00:58:27,690
like support like trying to like insert

00:58:25,020 --> 00:58:30,150
into like insert through a view into

00:58:27,690 --> 00:58:33,510
like a sequence container right but the

00:58:30,150 --> 00:58:35,430
stood text the basic text types support

00:58:33,510 --> 00:58:38,520
you know insertion and random places in

00:58:35,430 --> 00:58:40,680
et cetera et cetera yeah what I mean is

00:58:38,520 --> 00:58:43,020
that let's assume you've got a piece of

00:58:40,680 --> 00:58:46,560
text in yes utf-8 and you're converting

00:58:43,020 --> 00:58:47,970
to utf-16 yes well during that process

00:58:46,560 --> 00:58:50,700
at the end you've got two different

00:58:47,970 --> 00:58:53,040
strings but if you had an interval of

00:58:50,700 --> 00:58:55,590
text in the original string you can't

00:58:53,040 --> 00:58:58,170
necessarily map it to the new string

00:58:55,590 --> 00:59:00,510
without having information on where the

00:58:58,170 --> 00:59:01,740
characters get shortened and where it is

00:59:00,510 --> 00:59:03,690
okay so you're wondering like how we

00:59:01,740 --> 00:59:05,370
preserve size of me so for preserving

00:59:03,690 --> 00:59:07,770
size information you'd want to use the

00:59:05,370 --> 00:59:08,850
lazy and the lazy interface because when

00:59:07,770 --> 00:59:10,050
we give you back the iterators you can

00:59:08,850 --> 00:59:11,910
call it dot base on those and you get

00:59:10,050 --> 00:59:14,790
the underlying iterators right and that

00:59:11,910 --> 00:59:16,980
gives you like the the placement in the

00:59:14,790 --> 00:59:19,680
original container right so in that way

00:59:16,980 --> 00:59:21,150
you know if you depending on how many

00:59:19,680 --> 00:59:22,380
you know views you stack on right so if

00:59:21,150 --> 00:59:25,230
it like a normalizing view if you have

00:59:22,380 --> 00:59:26,750
like a a if you have a graphing view on

00:59:25,230 --> 00:59:29,760
top of normalizing view on top of a

00:59:26,750 --> 00:59:31,050
decoded decode you have called dot basis

00:59:29,760 --> 00:59:32,430
a couple times to get down to the base

00:59:31,050 --> 00:59:34,110
iterator but you can still retrieve that

00:59:32,430 --> 00:59:37,290
information and it is still preserved in

00:59:34,110 --> 00:59:39,830
that way yeah thank you yes either

00:59:37,290 --> 00:59:39,830
questions

00:59:41,040 --> 00:59:45,760
all right well yeah I'll I'll be I'll be

00:59:43,900 --> 00:59:47,720
here for us the conference and thank you

00:59:45,760 --> 00:59:50,960
for listening thank you for

00:59:47,720 --> 00:59:50,960

YouTube URL: https://www.youtube.com/watch?v=BdUipluIf1E


