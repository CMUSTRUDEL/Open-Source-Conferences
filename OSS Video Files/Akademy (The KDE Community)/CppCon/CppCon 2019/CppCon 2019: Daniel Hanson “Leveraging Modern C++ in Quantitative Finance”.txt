Title: CppCon 2019: Daniel Hanson “Leveraging Modern C++ in Quantitative Finance”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Starting with C++11, new features were introduced into the language and Standard Library that were immediately useful for quantitative developers in financial trading and risk management, yet not very much about these applications seems to have been presented at C++ conferences. Even recently published textbooks for C++ courses in finance still lag in covering these powerful new tools. Welcome additions such as distributional random number generation, task-based concurrency, and lambda expressions provide express lanes to coding necessary components of financial libraries that were once far more time consuming and less reliable to implement. Furthermore, beginning with C++17, parallel STL algorithms have become available to speed up routine computations, typically by simply adding an additional parameter.

In addition, Statistical Distributions, Circular Buffers for time series data, MultiArrays for option pricing lattices, and Quadrature for numerical integration are well-designed Boost libraries that add to an increasingly robust arsenal at the quant developer’s disposal.

The presentation will close with a review of how C++ is perceived in quantitative applications work – not always positive unfortunately – and proposals for overcoming these challenges, specifically by emphasizing and building on the progress made since C++11, and further modernizing math features in Boost.

Quantitative developers in both finance and other technical fields will see how to quickly leverage modern and powerful mathematical tools in C++ with minimal overhead to get on with the job quickly. Members of the Committee and larger C++ community should come away with a clearer view of quantitative developers’ demands for the language, and ideas for growing C++’s presence in the rapidly growing domain of computational finance in particular, and mathematical programming in general.
— 
Daniel Hanson
University of Washington, Applied Mathematics
Lecturer

Daniel Hanson spent 24 years in quantitative development in finance, primarily with C++ implementation of option pricing and portfolio risk models, and related library development. He now holds a full-time lecturer position in the Department of Applied Mathematics at the University of Washington, teaching quantitative development courses in the Computational Finance & Risk Management (CFRM) MSc program. This includes intermediate and advanced classes in computational C++, and mentoring students in Google Summer of Code projects involving implementation of mathematical models in C++ and R.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,320 --> 00:00:15,059
welcome to presentation on C++ and

00:00:12,460 --> 00:00:15,059
quantitative finance

00:00:15,070 --> 00:00:18,490
I don't want to bore you too much but

00:00:16,209 --> 00:00:20,619
just a little bit about myself and now

00:00:18,490 --> 00:00:24,010
starting my fourth year is a full-time

00:00:20,619 --> 00:00:26,050
instructor in the computational finance

00:00:24,010 --> 00:00:28,509
risk management program at the

00:00:26,050 --> 00:00:32,500
University of Washington say terminal

00:00:28,509 --> 00:00:34,630
master's program and we also place our

00:00:32,500 --> 00:00:38,440
students in internships and employment

00:00:34,630 --> 00:00:44,110
so it's not just the degree but we

00:00:38,440 --> 00:00:52,870
actually we are also rated on our

00:00:44,110 --> 00:00:55,390
placement rate then okay before that I

00:00:52,870 --> 00:00:59,110
spent about twenty four years in the

00:00:55,390 --> 00:01:01,090
finance field mostly in quantitative

00:00:59,110 --> 00:01:06,880
development and I got my first start

00:01:01,090 --> 00:01:08,680
with C++ in about 1998 so of course some

00:01:06,880 --> 00:01:11,729
of you also remember way back when when

00:01:08,680 --> 00:01:16,110
we didn't have some of this nice stuff

00:01:11,729 --> 00:01:20,740
okay so what we're going to talk about

00:01:16,110 --> 00:01:23,070
first I'm gonna focus more on the needs

00:01:20,740 --> 00:01:26,020
of end-users and what I mean by that are

00:01:23,070 --> 00:01:30,280
quants who usually use interpreted

00:01:26,020 --> 00:01:35,650
languages to develop models and such as

00:01:30,280 --> 00:01:37,600
VBA or MATLAB Python and you know they

00:01:35,650 --> 00:01:39,640
end up staying it at the office until

00:01:37,600 --> 00:01:41,799
9:30 at night waiting for their programs

00:01:39,640 --> 00:01:43,570
to run or the other case you'd hear

00:01:41,799 --> 00:01:46,030
about is you know someone would have a

00:01:43,570 --> 00:01:48,250
model in MATLAB that would I'm not

00:01:46,030 --> 00:01:50,260
kiddin take two to three days and then

00:01:48,250 --> 00:01:53,260
someone would come along and code it up

00:01:50,260 --> 00:01:56,320
in C++ and it would run in about under

00:01:53,260 --> 00:01:59,290
five minutes on a standard desktop so I

00:01:56,320 --> 00:02:02,170
think what I'm going to talk about today

00:01:59,290 --> 00:02:04,950
in C++ in general would appeal to people

00:02:02,170 --> 00:02:08,229
like that and also include people who

00:02:04,950 --> 00:02:11,260
build financial libraries so things like

00:02:08,229 --> 00:02:12,640
option pricing models risk management

00:02:11,260 --> 00:02:15,340
models that sort of thing

00:02:12,640 --> 00:02:20,200
and that's kind of what I did in the

00:02:15,340 --> 00:02:21,760
after I got into C++ programming so also

00:02:20,200 --> 00:02:25,290
we're going to one thing this

00:02:21,760 --> 00:02:28,420
presentation is not complicated at all

00:02:25,290 --> 00:02:31,930
the theme really is easy to

00:02:28,420 --> 00:02:35,020
use and then but we're gonna get some

00:02:31,930 --> 00:02:38,319
powerful results out of that and in

00:02:35,020 --> 00:02:40,450
other words tools and C++ that we can

00:02:38,319 --> 00:02:44,290
leverage and I know leverage is kind of

00:02:40,450 --> 00:02:48,400
a cliche term right but it really rings

00:02:44,290 --> 00:02:51,340
true here and that we can think of the

00:02:48,400 --> 00:02:54,040
abstractions and new features in C++

00:02:51,340 --> 00:02:56,620
that are like the torque around along

00:02:54,040 --> 00:03:01,230
the right there and so it takes less

00:02:56,620 --> 00:03:04,090
effort to lift a heavier load but I

00:03:01,230 --> 00:03:05,790
think more accurately it looks something

00:03:04,090 --> 00:03:11,709
like that

00:03:05,790 --> 00:03:13,239
so the idea is we want to let C++ do the

00:03:11,709 --> 00:03:16,330
driving as much as we can

00:03:13,239 --> 00:03:23,470
kind of like greyhound but a lot faster

00:03:16,330 --> 00:03:25,690
okay so at the end of the last decade we

00:03:23,470 --> 00:03:30,700
really started to see the start of

00:03:25,690 --> 00:03:32,070
something beautiful and C++ was soon to

00:03:30,700 --> 00:03:34,780
follow

00:03:32,070 --> 00:03:38,769
thank you john califor a good book I

00:03:34,780 --> 00:03:42,310
assigned that book to my students first

00:03:38,769 --> 00:03:45,280
day of the term and I have them read the

00:03:42,310 --> 00:03:48,549
whole book but we'll talk about math

00:03:45,280 --> 00:03:50,980
features coming up but also we got move

00:03:48,549 --> 00:03:56,130
semantics and along with that unique

00:03:50,980 --> 00:03:59,079
pointer and these actually helped make

00:03:56,130 --> 00:04:02,680
make models code more not just more

00:03:59,079 --> 00:04:05,320
efficient but more maintainable more

00:04:02,680 --> 00:04:08,829
readable and also the development time

00:04:05,320 --> 00:04:10,420
was was more rapid and I actually went

00:04:08,829 --> 00:04:13,120
back to some of the stuff that I worked

00:04:10,420 --> 00:04:15,720
on in the in the previous decade and I

00:04:13,120 --> 00:04:19,299
used some of these these new methods and

00:04:15,720 --> 00:04:21,340
it really does make a difference I could

00:04:19,299 --> 00:04:25,950
talk about that one topic for another

00:04:21,340 --> 00:04:28,720
hour but don't worry maybe another time

00:04:25,950 --> 00:04:30,850
and then we also got parallel STL

00:04:28,720 --> 00:04:34,479
algorithms in C++ seventeen everybody

00:04:30,850 --> 00:04:37,450
knows that but if there ever was an

00:04:34,479 --> 00:04:41,000
epitome for leverage it's it's those I

00:04:37,450 --> 00:04:43,910
mean you just had one parameter

00:04:41,000 --> 00:04:46,450
to an algorithm and you can just reap

00:04:43,910 --> 00:04:50,200
incredibly incredible efficiency gains

00:04:46,450 --> 00:04:53,450
okay the other thing that happened was

00:04:50,200 --> 00:04:58,130
better availability of decent

00:04:53,450 --> 00:05:00,800
open-source math libraries and for

00:04:58,130 --> 00:05:02,990
example you may have heard of eigen an

00:05:00,800 --> 00:05:09,100
armadillo these are both quite popular

00:05:02,990 --> 00:05:12,620
in finance and they don't just include

00:05:09,100 --> 00:05:14,960
matrices vectors and the basic

00:05:12,620 --> 00:05:19,610
operations they also include a lot of

00:05:14,960 --> 00:05:21,110
advanced decompositions which are which

00:05:19,610 --> 00:05:25,190
are necessary for a lot of financial

00:05:21,110 --> 00:05:27,280
modeling more recently I've just only

00:05:25,190 --> 00:05:31,160
now heard about these these new

00:05:27,280 --> 00:05:32,960
libraries here not try them but if they

00:05:31,160 --> 00:05:36,770
can do what they claim to do that would

00:05:32,960 --> 00:05:38,990
also be really great and then we have

00:05:36,770 --> 00:05:41,419
coming attractions we're finally going

00:05:38,990 --> 00:05:42,590
to get a date class in C++ 20 I know

00:05:41,419 --> 00:05:45,110
that there are other things like

00:05:42,590 --> 00:05:48,169
concepts and modules people are really

00:05:45,110 --> 00:05:50,120
and understandably so gaga about but for

00:05:48,169 --> 00:05:52,310
quant developers having a proper date

00:05:50,120 --> 00:05:54,050
class finally is really really great

00:05:52,310 --> 00:05:57,290
because dates are so important in

00:05:54,050 --> 00:05:58,970
finance and you know this was yet

00:05:57,290 --> 00:06:00,580
another example of something that we

00:05:58,970 --> 00:06:03,470
would often have to program ourselves

00:06:00,580 --> 00:06:07,190
well now we're finally going to get one

00:06:03,470 --> 00:06:10,040
and also as we speak

00:06:07,190 --> 00:06:12,950
the s g14 group is meeting and

00:06:10,040 --> 00:06:17,780
discussing putting linear algebra into

00:06:12,950 --> 00:06:21,830
probably C++ 23 so that will also be a

00:06:17,780 --> 00:06:26,090
welcome welcome improvement a few things

00:06:21,830 --> 00:06:27,800
about boost there are some things in

00:06:26,090 --> 00:06:32,840
there that are very intuitive and very

00:06:27,800 --> 00:06:34,220
useful but to put it politely there are

00:06:32,840 --> 00:06:36,800
some other things in there that could be

00:06:34,220 --> 00:06:39,500
a lot more user-friendly but we'll talk

00:06:36,800 --> 00:06:41,270
about a few things under the the first

00:06:39,500 --> 00:06:44,990
category toward the end of this

00:06:41,270 --> 00:06:49,550
presentation okay so what I want to do

00:06:44,990 --> 00:06:52,820
is demonstrate I realized C++ 11 is no

00:06:49,550 --> 00:06:54,529
longer that new but what I want to do is

00:06:52,820 --> 00:06:56,929
look at an example is

00:06:54,529 --> 00:07:01,669
is very typical in quant finance of

00:06:56,929 --> 00:07:05,119
having a model develop a model for an

00:07:01,669 --> 00:07:07,339
options price and to be honest I haven't

00:07:05,119 --> 00:07:13,089
we've got all this great stuff even in

00:07:07,339 --> 00:07:18,829
the C++ 11 but I'm not seeing it in in

00:07:13,089 --> 00:07:20,509
other curricula in textbooks it you know

00:07:18,829 --> 00:07:22,309
it's doing my little Rodney Dangerfield

00:07:20,509 --> 00:07:26,209
thing at the beginning there I mean it's

00:07:22,309 --> 00:07:28,539
like it gets no respect but I want to

00:07:26,209 --> 00:07:32,419
show how we can use these things and

00:07:28,539 --> 00:07:34,519
they're also very easy to easy to use to

00:07:32,419 --> 00:07:38,959
apply to a very common problem in

00:07:34,519 --> 00:07:43,789
finance so we will just take the easy

00:07:38,959 --> 00:07:46,309
case of a Monte Carlo option but what we

00:07:43,789 --> 00:07:50,989
do here could be applied to much more

00:07:46,309 --> 00:07:53,809
complex options so in case you don't

00:07:50,989 --> 00:07:57,409
know what a option is and you European

00:07:53,809 --> 00:07:59,779
option is it's a tradable contract that

00:07:57,409 --> 00:08:02,709
gives the holder the right to buy or

00:07:59,779 --> 00:08:05,809
sell a share of stock at a predetermined

00:08:02,709 --> 00:08:11,479
strike price in the future and more

00:08:05,809 --> 00:08:13,189
specifically for for European options at

00:08:11,479 --> 00:08:15,589
the expiration date other types of

00:08:13,189 --> 00:08:17,689
options like American options Bermudan

00:08:15,589 --> 00:08:20,689
options you can exercise before the

00:08:17,689 --> 00:08:25,039
option expires but even though you can't

00:08:20,689 --> 00:08:27,229
exercise until the option expires that

00:08:25,039 --> 00:08:28,789
option has value so the options

00:08:27,229 --> 00:08:32,059
themselves as many of you know are

00:08:28,789 --> 00:08:35,899
traded so we want to find a price for an

00:08:32,059 --> 00:08:39,550
option at the present time even though

00:08:35,899 --> 00:08:44,240
the payoffs won't be until the future so

00:08:39,550 --> 00:08:46,759
to get this set up what we what we need

00:08:44,240 --> 00:08:49,670
are since we we don't know what's going

00:08:46,759 --> 00:08:52,179
to happen in the future well we don't

00:08:49,670 --> 00:08:55,009
have that but what we can do is project

00:08:52,179 --> 00:09:01,730
stock prices into the future using

00:08:55,009 --> 00:09:03,889
random scenarios and so I'm sorry to

00:09:01,730 --> 00:09:05,870
illustrate that here of just five

00:09:03,889 --> 00:09:07,620
scenarios don't worry yet how it's done

00:09:05,870 --> 00:09:10,860
so we have five

00:09:07,620 --> 00:09:12,029
and you can see down here toward the

00:09:10,860 --> 00:09:14,630
left

00:09:12,029 --> 00:09:20,400
the current price at t equals zero is

00:09:14,630 --> 00:09:22,320
$100 a share now suppose that we buy a

00:09:20,400 --> 00:09:23,660
call option with a strike price of a

00:09:22,320 --> 00:09:27,360
hundred and five

00:09:23,660 --> 00:09:30,600
so at expiration let's look at what

00:09:27,360 --> 00:09:34,620
happens if we look at the blue scenario

00:09:30,600 --> 00:09:37,640
we see it the strike price is about a

00:09:34,620 --> 00:09:40,380
hundred and twenty dollars so that means

00:09:37,640 --> 00:09:42,180
we could buy the we could we have the

00:09:40,380 --> 00:09:43,800
right to buy the stock at a hundred and

00:09:42,180 --> 00:09:45,210
five and then we can turn around and

00:09:43,800 --> 00:09:50,520
sell it at a hundred and twenty and make

00:09:45,210 --> 00:09:52,680
fifteen dollars share profit but that's

00:09:50,520 --> 00:09:54,900
in the future but what we what we will

00:09:52,680 --> 00:09:57,690
need for our pricing model is we have to

00:09:54,900 --> 00:10:00,180
discount it back to today so what

00:09:57,690 --> 00:10:02,580
happens is we discount it all the way

00:10:00,180 --> 00:10:06,180
back using a discount factor based on

00:10:02,580 --> 00:10:10,170
the current interest rate now what

00:10:06,180 --> 00:10:13,050
happens if it if the terminal stock

00:10:10,170 --> 00:10:15,270
price is below the the strike well in

00:10:13,050 --> 00:10:16,920
that case the option expires worthless

00:10:15,270 --> 00:10:19,560
because it makes no sense you're not

00:10:16,920 --> 00:10:23,720
going to pay a hundred and five and sell

00:10:19,560 --> 00:10:27,350
it for less than you know sell for 100

00:10:23,720 --> 00:10:32,330
unless you're the US government but

00:10:27,350 --> 00:10:35,550
sorry had to go there but we have to

00:10:32,330 --> 00:10:39,839
discount that back as well trivially to

00:10:35,550 --> 00:10:42,589
zero so and then it would be the same

00:10:39,839 --> 00:10:46,080
for the other payoffs just whatever

00:10:42,589 --> 00:10:48,630
whatever you get so this sets up the

00:10:46,080 --> 00:10:54,990
model now how do we use these to price

00:10:48,630 --> 00:10:56,940
the to price the option well suppose

00:10:54,990 --> 00:11:00,540
that the risk-free rate of interest is

00:10:56,940 --> 00:11:02,370
one point two percent and our time to

00:11:00,540 --> 00:11:03,990
expiration is four months so one third

00:11:02,370 --> 00:11:06,510
of the year

00:11:03,990 --> 00:11:09,870
then the way we compute the option value

00:11:06,510 --> 00:11:11,700
is we add up all of the payoffs and we

00:11:09,870 --> 00:11:14,430
have to account for the zero values I

00:11:11,700 --> 00:11:15,750
mean trivial is trivial but you'll see

00:11:14,430 --> 00:11:17,370
why in a minute I mean we don't actually

00:11:15,750 --> 00:11:19,800
in the computation have to include them

00:11:17,370 --> 00:11:21,240
but we have to be mindful of them then

00:11:19,800 --> 00:11:24,980
we're going to discount back

00:11:21,240 --> 00:11:28,800
to today using the interest rate and the

00:11:24,980 --> 00:11:31,260
the time to maturity or to expiration or

00:11:28,800 --> 00:11:34,080
you just use a continuous discount

00:11:31,260 --> 00:11:36,209
factor and then we take that value and

00:11:34,080 --> 00:11:38,670
we we average by the total number of

00:11:36,209 --> 00:11:41,940
scenarios and that gives us our option

00:11:38,670 --> 00:11:45,000
price in this case about six bucks but

00:11:41,940 --> 00:11:47,220
in reality five scenarios is not going

00:11:45,000 --> 00:11:53,430
to give us a good value for our option

00:11:47,220 --> 00:11:56,370
price and in reality we're typically

00:11:53,430 --> 00:11:57,899
going to be looking at about ten

00:11:56,370 --> 00:12:01,500
thousand even up to about a hundred

00:11:57,899 --> 00:12:04,740
thousand scenarios that we need to

00:12:01,500 --> 00:12:07,649
generate so as you can imagine this can

00:12:04,740 --> 00:12:10,350
lead to rather computationally intensive

00:12:07,649 --> 00:12:11,820
operations but the cool thing is if you

00:12:10,350 --> 00:12:16,800
plot it all out it kind of looks like a

00:12:11,820 --> 00:12:19,350
Jimi Hendrix album cover okay so let's

00:12:16,800 --> 00:12:22,170
impose the same example that we we use

00:12:19,350 --> 00:12:22,830
before so strike price at one hundred

00:12:22,170 --> 00:12:24,720
and five

00:12:22,830 --> 00:12:29,399
you can see down here the the initial

00:12:24,720 --> 00:12:31,140
price is 100 so if we end up above that

00:12:29,399 --> 00:12:33,570
strike price then we have to calculate

00:12:31,140 --> 00:12:36,089
the payoffs of of all those scenarios

00:12:33,570 --> 00:12:42,420
and then at the bottom there they expire

00:12:36,089 --> 00:12:45,149
worthless okay so that's what we need to

00:12:42,420 --> 00:12:49,500
do but before we can do anything we need

00:12:45,149 --> 00:12:52,200
to first generate one scenario and then

00:12:49,500 --> 00:12:55,190
once we have that reusable code right we

00:12:52,200 --> 00:13:05,430
just do it use the same thing many times

00:12:55,190 --> 00:13:10,800
so to do this we will use a stochastic

00:13:05,430 --> 00:13:14,399
process that you see there and what

00:13:10,800 --> 00:13:15,720
these things are so st is the let me

00:13:14,399 --> 00:13:17,870
back up a second what we're going to do

00:13:15,720 --> 00:13:21,180
first of all is we're going to take that

00:13:17,870 --> 00:13:22,380
that time frame from zero to capital T

00:13:21,180 --> 00:13:25,649
and we're going to chop it up into

00:13:22,380 --> 00:13:28,260
little increments delta T and this

00:13:25,649 --> 00:13:29,850
actually comes out of it's called

00:13:28,260 --> 00:13:32,810
stochastic calculus but it's it's like

00:13:29,850 --> 00:13:35,070
calculus at Delta T is an approximation

00:13:32,810 --> 00:13:40,470
for a differential

00:13:35,070 --> 00:13:42,510
small amount so we're gonna chop it up

00:13:40,470 --> 00:13:44,910
and then at each time step we're going

00:13:42,510 --> 00:13:47,280
to generate the next stock price by

00:13:44,910 --> 00:13:50,210
using this this formula this formula

00:13:47,280 --> 00:13:52,380
falls out of the black Scholes Theory

00:13:50,210 --> 00:13:53,730
some of you might be wondering well why

00:13:52,380 --> 00:13:57,210
don't you just use black Scholes we

00:13:53,730 --> 00:14:00,420
could for this one but I want to show

00:13:57,210 --> 00:14:01,830
how to use Monte Carlo pricing and there

00:14:00,420 --> 00:14:04,920
are a lot of options for which there are

00:14:01,830 --> 00:14:08,190
no closed-form solutions so you can use

00:14:04,920 --> 00:14:11,940
this method for more more complex

00:14:08,190 --> 00:14:13,770
options okay so most of these we take in

00:14:11,940 --> 00:14:17,640
at that we're going to write a class

00:14:13,770 --> 00:14:19,530
called equity price generator and so

00:14:17,640 --> 00:14:22,260
we're going to take in most of these at

00:14:19,530 --> 00:14:25,470
construction and they'll be stored as as

00:14:22,260 --> 00:14:27,480
member variables so pretty

00:14:25,470 --> 00:14:29,760
self-explanatory except maybe volatility

00:14:27,480 --> 00:14:31,860
if you don't know what that is it's the

00:14:29,760 --> 00:14:35,390
standard deviation of movements in the

00:14:31,860 --> 00:14:38,070
stock price okay so we have all that but

00:14:35,390 --> 00:14:40,860
you may notice there's one term up there

00:14:38,070 --> 00:14:44,310
epsilon sub T and that's what drives the

00:14:40,860 --> 00:14:48,800
randomness and what that is is a draw

00:14:44,310 --> 00:14:53,190
from a standard normal distribution and

00:14:48,800 --> 00:14:58,110
this is where the random feature in C++

00:14:53,190 --> 00:15:00,600
11 comes in very handy so well of course

00:14:58,110 --> 00:15:03,450
have to include our header file but we

00:15:00,600 --> 00:15:06,210
will also have to include the random

00:15:03,450 --> 00:15:10,530
header so we can use these features okay

00:15:06,210 --> 00:15:14,520
now the way it works in C++ is is a

00:15:10,530 --> 00:15:17,400
two-step process first we need to create

00:15:14,520 --> 00:15:21,420
an engine object and what that will do

00:15:17,400 --> 00:15:24,450
is it will generate positive integers

00:15:21,420 --> 00:15:26,730
that are uniformly distributed and then

00:15:24,450 --> 00:15:28,530
we need a distribution object in this

00:15:26,730 --> 00:15:30,660
case will be the normal distribution and

00:15:28,530 --> 00:15:33,270
it will apply a transformation of those

00:15:30,660 --> 00:15:35,760
integers to standard normal values and

00:15:33,270 --> 00:15:38,160
then the next one that's picked it is

00:15:35,760 --> 00:15:43,410
just the next standard the standard

00:15:38,160 --> 00:15:47,100
normal random draw that you get so for

00:15:43,410 --> 00:15:48,420
this we need first an engine object so

00:15:47,100 --> 00:15:49,860
we will use there

00:15:48,420 --> 00:15:52,139
are a number of different engine objects

00:15:49,860 --> 00:15:55,680
and there are a number of different

00:15:52,139 --> 00:15:58,889
distribution classes in the standard we

00:15:55,680 --> 00:16:02,070
will use the Mersenne twister algorithm

00:15:58,889 --> 00:16:04,920
the 64-bit version and this is the most

00:16:02,070 --> 00:16:10,230
robust engine available in the standard

00:16:04,920 --> 00:16:12,540
so what and what I commonly used when my

00:16:10,230 --> 00:16:15,149
group used when I worked in the private

00:16:12,540 --> 00:16:18,920
sector and then will also use the normal

00:16:15,149 --> 00:16:18,920
distribution so we need to sculpt that

00:16:19,430 --> 00:16:26,040
all right so the place where most of the

00:16:24,000 --> 00:16:28,529
work will be done is oh and by the way

00:16:26,040 --> 00:16:30,720
all this sample code not just what you

00:16:28,529 --> 00:16:32,760
see here but the entire code is

00:16:30,720 --> 00:16:34,940
available on my github site and I'll

00:16:32,760 --> 00:16:41,339
give you the URL at the end of the

00:16:34,940 --> 00:16:43,290
presentation okay so as you probably

00:16:41,339 --> 00:16:47,550
know when we generate a sequence of

00:16:43,290 --> 00:16:50,519
pseudo-random number variables are we

00:16:47,550 --> 00:16:55,370
need a seed value so that's what we'll

00:16:50,519 --> 00:16:57,990
have to take in here in this functor and

00:16:55,370 --> 00:17:02,220
we will store it we'll take those

00:16:57,990 --> 00:17:03,870
generated random stock prices and we'll

00:17:02,220 --> 00:17:10,589
store them in a vector V which you see

00:17:03,870 --> 00:17:15,600
there all right so this is where the

00:17:10,589 --> 00:17:17,790
magic starts so we're going to create an

00:17:15,600 --> 00:17:21,120
object called MT engine it takes in its

00:17:17,790 --> 00:17:25,290
constructor the seed value this is so

00:17:21,120 --> 00:17:26,480
this is our engine and then we create an

00:17:25,290 --> 00:17:30,690
instance of the normal distribution

00:17:26,480 --> 00:17:32,580
called nd you might notice that there

00:17:30,690 --> 00:17:33,929
are no constructor arguments for normal

00:17:32,580 --> 00:17:37,110
distribution that's because the default

00:17:33,929 --> 00:17:41,820
is 0-1 you might also note there's a

00:17:37,110 --> 00:17:46,910
default template parameter it's double

00:17:41,820 --> 00:17:51,660
precision okay so the next step is to

00:17:46,910 --> 00:17:53,910
implement this stochastic process well

00:17:51,660 --> 00:17:56,669
lambda expressions make this very very

00:17:53,910 --> 00:17:58,320
easy and you can basically see how it's

00:17:56,669 --> 00:18:03,470
it's been implemented here I don't think

00:17:58,320 --> 00:18:07,169
I need to go through all that but then

00:18:03,470 --> 00:18:10,409
the the next step would be we need to

00:18:07,169 --> 00:18:12,120
take the current stock price that we see

00:18:10,409 --> 00:18:14,940
in the market and that will be our first

00:18:12,120 --> 00:18:18,240
stock price in the vector for our

00:18:14,940 --> 00:18:20,940
scenario so now we have an ST minus one

00:18:18,240 --> 00:18:23,640
and we can start the process and so that

00:18:20,940 --> 00:18:25,620
goes on down here in we're going to

00:18:23,640 --> 00:18:28,140
iterate through all the the time steps

00:18:25,620 --> 00:18:31,590
and then at each time step we're going

00:18:28,140 --> 00:18:36,870
to call the the iterative stochastic

00:18:31,590 --> 00:18:41,130
process and get the next price in the in

00:18:36,870 --> 00:18:43,350
the scenario path so equity price here

00:18:41,130 --> 00:18:46,380
is the previous equity price and then to

00:18:43,350 --> 00:18:49,980
get the the draw from the normal

00:18:46,380 --> 00:18:52,830
distribution what we do is we call ND

00:18:49,980 --> 00:18:56,220
and it's functor and the argument is

00:18:52,830 --> 00:18:59,070
just the engine object and so every time

00:18:56,220 --> 00:19:02,730
you call that it's going to generate a

00:18:59,070 --> 00:19:04,169
new pseudo-random numbers taken from a

00:19:02,730 --> 00:19:07,770
standard normal distribution

00:19:04,169 --> 00:19:12,929
but it's important to remember that this

00:19:07,770 --> 00:19:21,240
is all made possible by the the random

00:19:12,929 --> 00:19:24,600
feature in C++ 11 so we now have a class

00:19:21,240 --> 00:19:26,880
that will generate one random equity

00:19:24,600 --> 00:19:32,280
scenario but remember we need about

00:19:26,880 --> 00:19:34,409
maybe 10,000 of these things so what

00:19:32,280 --> 00:19:36,450
we're going to do here is as you might

00:19:34,409 --> 00:19:38,700
imagine well we got 10,000 these things

00:19:36,450 --> 00:19:40,919
they don't care about each other so it's

00:19:38,700 --> 00:19:49,230
very easy to use test based concurrency

00:19:40,919 --> 00:19:53,640
so another feature in C++ 11 and so if

00:19:49,230 --> 00:20:00,809
we go back to our 5 scenario example so

00:19:53,640 --> 00:20:03,179
each each generated path is going to be

00:20:00,809 --> 00:20:05,850
is going to be a vector of these these

00:20:03,179 --> 00:20:08,399
prices to generate it in parallel we're

00:20:05,850 --> 00:20:09,600
going to use we're going to do that as a

00:20:08,399 --> 00:20:13,760
task

00:20:09,600 --> 00:20:17,850
and that's managed by a future object so

00:20:13,760 --> 00:20:21,539
the future manages creation of that

00:20:17,850 --> 00:20:24,450
vector so the vector is in the template

00:20:21,539 --> 00:20:28,429
it's the template parameter okay now

00:20:24,450 --> 00:20:28,429
assuming that's everything runs fine

00:20:28,700 --> 00:20:33,870
when it's done then we call get and that

00:20:32,039 --> 00:20:38,100
will get each of those individual

00:20:33,870 --> 00:20:40,380
vectors of random scenarios but remember

00:20:38,100 --> 00:20:44,490
for a European option all we care about

00:20:40,380 --> 00:20:49,380
is that last price so we just call back

00:20:44,490 --> 00:20:52,460
on the the vector that we that we get

00:20:49,380 --> 00:20:54,720
back from the future object and then

00:20:52,460 --> 00:20:57,840
like before we're going to discount

00:20:54,720 --> 00:21:02,490
these back and then take the average to

00:20:57,840 --> 00:21:03,630
get the price so let's look at how we

00:21:02,490 --> 00:21:07,500
might do this

00:21:03,630 --> 00:21:11,429
we'll create a class called MC euro opt

00:21:07,500 --> 00:21:14,760
price er we will use the previous result

00:21:11,429 --> 00:21:18,630
the equity price generator just an aside

00:21:14,760 --> 00:21:20,580
another nice feature from C++ 11 is enum

00:21:18,630 --> 00:21:23,960
class and we can use this to define our

00:21:20,580 --> 00:21:28,429
option type whether it's a call or a put

00:21:23,960 --> 00:21:32,820
ok now if you look at the constructor a

00:21:28,429 --> 00:21:34,500
lot of those variables are the same as

00:21:32,820 --> 00:21:36,539
what we needed for our equity price

00:21:34,500 --> 00:21:38,460
generator but there are a few extra that

00:21:36,539 --> 00:21:41,100
we need for specifically pricing an

00:21:38,460 --> 00:21:43,260
option and those are the strike price of

00:21:41,100 --> 00:21:45,600
the option the option type put our call

00:21:43,260 --> 00:21:48,090
and then there's quantity we will just

00:21:45,600 --> 00:21:51,179
assume 1 because we're buying an option

00:21:48,090 --> 00:21:52,710
on one share but that's if you are if

00:21:51,179 --> 00:21:55,049
you're taking a position in more than

00:21:52,710 --> 00:21:57,620
one but for our purposes we'll just

00:21:55,049 --> 00:22:01,620
we'll just assume one for simplicity

00:21:57,620 --> 00:22:04,789
okay then where most of the work will be

00:22:01,620 --> 00:22:08,820
done is in this class private function

00:22:04,789 --> 00:22:10,590
compute price async and so this is where

00:22:08,820 --> 00:22:13,289
we'll use test based concurrency to

00:22:10,590 --> 00:22:15,090
generate each one of those scenarios but

00:22:13,289 --> 00:22:18,240
so that we can compare runtimes I've

00:22:15,090 --> 00:22:20,070
also implemented a non parallel version

00:22:18,240 --> 00:22:24,530
and so when we get done with this we can

00:22:20,070 --> 00:22:30,240
actually compare how much better we do

00:22:24,530 --> 00:22:32,670
okay so again this is in this function

00:22:30,240 --> 00:22:37,710
this is where really the bulk of the

00:22:32,670 --> 00:22:39,809
work is done we will first we need to

00:22:37,710 --> 00:22:42,630
create an instance of our equity price

00:22:39,809 --> 00:22:45,330
generator and now those values the

00:22:42,630 --> 00:22:49,260
inputs are our members variables so

00:22:45,330 --> 00:22:51,450
that's done there's a we can assume we

00:22:49,260 --> 00:22:53,370
have a vector of seeds equal to the

00:22:51,450 --> 00:22:56,070
number of time steps that's done by this

00:22:53,370 --> 00:22:58,890
function generate seeds but each seed is

00:22:56,070 --> 00:23:01,620
a distinct English integer okay

00:22:58,890 --> 00:23:04,070
so since we're gonna be using future

00:23:01,620 --> 00:23:08,340
classes we need to include the header

00:23:04,070 --> 00:23:09,720
and then we're gonna have a lot of

00:23:08,340 --> 00:23:14,250
future objects and we need a place to

00:23:09,720 --> 00:23:17,220
store them use a container and when in

00:23:14,250 --> 00:23:23,730
doubt use a vector that's what herb

00:23:17,220 --> 00:23:25,770
sutter tells us so okay so now we've set

00:23:23,730 --> 00:23:27,210
it up so that each of these objects will

00:23:25,770 --> 00:23:32,130
be in a vector but at this point nothing

00:23:27,210 --> 00:23:34,410
has happened we have to give the command

00:23:32,130 --> 00:23:36,660
to execute each of these tests in

00:23:34,410 --> 00:23:38,190
parallel and the way that's done again

00:23:36,660 --> 00:23:41,370
so a lot of you may know this already

00:23:38,190 --> 00:23:44,250
but again I want to show how you can use

00:23:41,370 --> 00:23:47,280
this to solve a real world problem so we

00:23:44,250 --> 00:23:50,760
call stood async and it is going to take

00:23:47,280 --> 00:23:54,120
in for its inputs the function that is

00:23:50,760 --> 00:23:57,120
going to run in parallel and the

00:23:54,120 --> 00:24:01,620
argument for that function so we're just

00:23:57,120 --> 00:24:09,690
going to use the functor on the EPG

00:24:01,620 --> 00:24:10,830
object so now at this point as I'm sure

00:24:09,690 --> 00:24:13,140
many of you know there are a lot of

00:24:10,830 --> 00:24:17,610
nuances and obviously a lot but there a

00:24:13,140 --> 00:24:19,679
few and some things that you know you

00:24:17,610 --> 00:24:24,320
might want to consider about using test

00:24:19,679 --> 00:24:24,320
based concurrency but we will assume

00:24:24,470 --> 00:24:29,580
that everything runs fine

00:24:27,480 --> 00:24:31,590
we get the the scenarios and generated

00:24:29,580 --> 00:24:33,870
in parallel and we are now in a position

00:24:31,590 --> 00:24:35,350
to iterate through this vector of

00:24:33,870 --> 00:24:38,050
futures

00:24:35,350 --> 00:24:39,940
and again like I said we call the get

00:24:38,050 --> 00:24:42,250
function on future that returns the

00:24:39,940 --> 00:24:45,880
vector called back on the vector that

00:24:42,250 --> 00:24:47,800
gives us our terminal price and then we

00:24:45,880 --> 00:24:50,440
calculate the payoff based on whether

00:24:47,800 --> 00:24:52,090
its call or put discount it put it into

00:24:50,440 --> 00:24:54,070
another vector and then down at the

00:24:52,090 --> 00:24:57,250
bottom we compute the average and you

00:24:54,070 --> 00:24:59,490
see we get the price so that's how that

00:24:57,250 --> 00:24:59,490
works

00:24:59,950 --> 00:25:08,740
looking at some results so it's run on a

00:25:04,960 --> 00:25:10,420
hyper V twenty core virtual machine this

00:25:08,740 --> 00:25:13,420
is thanks to a friend of mine who works

00:25:10,420 --> 00:25:15,940
at Microsoft but in the real world

00:25:13,420 --> 00:25:17,710
though I mean a virtual machine like

00:25:15,940 --> 00:25:22,480
this would probably be pretty

00:25:17,710 --> 00:25:25,660
commonplace now in a in a Kwanza and you

00:25:22,480 --> 00:25:27,990
can see our first example there's really

00:25:25,660 --> 00:25:31,960
no difference in runtime so we're just

00:25:27,990 --> 00:25:34,270
monthly time steps one year 10,000

00:25:31,960 --> 00:25:36,160
scenarios but as we start increasing the

00:25:34,270 --> 00:25:40,720
number of time steps and scenarios and

00:25:36,160 --> 00:25:42,610
then the value of capital T you can see

00:25:40,720 --> 00:25:46,060
we start to get you know some pretty

00:25:42,610 --> 00:25:48,670
significant improvements and then as we

00:25:46,060 --> 00:25:53,980
go even farther we start to converge

00:25:48,670 --> 00:25:56,470
around 90% so the upshot here though is

00:25:53,980 --> 00:25:58,590
that we've achieved this with very

00:25:56,470 --> 00:26:01,540
little effort so I can't tell my

00:25:58,590 --> 00:26:03,130
students don't do more work than you

00:26:01,540 --> 00:26:09,610
have to and there's all this great stuff

00:26:03,130 --> 00:26:12,700
now in C++ that makes that possible but

00:26:09,610 --> 00:26:14,290
my little rant is is that I can in the

00:26:12,700 --> 00:26:19,000
teaching materials and books and so

00:26:14,290 --> 00:26:21,250
forth you know they're still back at you

00:26:19,000 --> 00:26:24,910
know you know let's do new mime delete

00:26:21,250 --> 00:26:26,620
and design our own linked lists and

00:26:24,910 --> 00:26:28,660
things like that

00:26:26,620 --> 00:26:30,160
maybe that's good for computer science

00:26:28,660 --> 00:26:37,630
but for a quantitative development it's

00:26:30,160 --> 00:26:40,930
a really good at useful anyway that's

00:26:37,630 --> 00:26:43,120
that's really the upshot that and we

00:26:40,930 --> 00:26:46,720
have not had to deal with any manual

00:26:43,120 --> 00:26:48,040
spawning or killing of threads so less

00:26:46,720 --> 00:26:50,530
error-prone

00:26:48,040 --> 00:26:52,900
more maintainable and on top of it it

00:26:50,530 --> 00:26:56,200
can actually be more efficient if you

00:26:52,900 --> 00:26:58,780
don't believe me read Myers effective

00:26:56,200 --> 00:27:06,429
modern C++ that's where that little

00:26:58,780 --> 00:27:08,799
factoid came from okay so just a couple

00:27:06,429 --> 00:27:13,120
of other things to note

00:27:08,799 --> 00:27:15,940
we used the simple case of a European

00:27:13,120 --> 00:27:19,120
equity option but rest assured there are

00:27:15,940 --> 00:27:23,380
far more complex options that must be

00:27:19,120 --> 00:27:27,220
priced in in practice some of these and

00:27:23,380 --> 00:27:28,840
also some of you might be saying you

00:27:27,220 --> 00:27:31,390
know why in the Sam Hill is he price

00:27:28,840 --> 00:27:33,309
pricing a 10-year European stock option

00:27:31,390 --> 00:27:36,760
those don't exist in the market true

00:27:33,309 --> 00:27:38,260
they don't but a lot of other options do

00:27:36,760 --> 00:27:40,630
and some of them are for example

00:27:38,260 --> 00:27:44,010
interest rate and foreign exchange swap

00:27:40,630 --> 00:27:47,020
shion's those can go out five ten years

00:27:44,010 --> 00:27:49,330
hybrid structured derivatives which also

00:27:47,020 --> 00:27:51,220
involve interest rates and foreign

00:27:49,330 --> 00:27:52,840
exchange those are really fun to work

00:27:51,220 --> 00:27:55,480
with that's where the math gets really

00:27:52,840 --> 00:28:00,190
interesting and then there are also

00:27:55,480 --> 00:28:02,100
guaranteed investment products that are

00:28:00,190 --> 00:28:04,419
designed by life insurance companies and

00:28:02,100 --> 00:28:07,390
with they also have a life insurance

00:28:04,419 --> 00:28:10,480
component with them but these things can

00:28:07,390 --> 00:28:15,360
get very very complex and need to often

00:28:10,480 --> 00:28:18,940
need to be projected out 30 years and so

00:28:15,360 --> 00:28:25,090
believe me there it can get a lot more

00:28:18,940 --> 00:28:27,429
complex put a lot more fun and just as

00:28:25,090 --> 00:28:29,200
an aside this is the kind of stuff that

00:28:27,429 --> 00:28:34,570
I worked with before I went into

00:28:29,200 --> 00:28:37,600
teaching okay and then as I mentioned

00:28:34,570 --> 00:28:40,510
just to recap there are different types

00:28:37,600 --> 00:28:43,330
of engine algorithms and distributions

00:28:40,510 --> 00:28:45,640
available in the standard library so

00:28:43,330 --> 00:28:48,669
it's not just Mersenne twister normal

00:28:45,640 --> 00:28:52,240
distribution you know there there are

00:28:48,669 --> 00:28:54,070
others but for this type of problem

00:28:52,240 --> 00:28:57,669
where it's based on what's called the no

00:28:54,070 --> 00:28:59,740
arbitrage pricing theory and black

00:28:57,669 --> 00:29:01,220
Scholes Theory you're going to be using

00:28:59,740 --> 00:29:02,900
standard normal

00:29:01,220 --> 00:29:08,840
you want the most robust engine you can

00:29:02,900 --> 00:29:14,440
find okay so we've gone through kind of

00:29:08,840 --> 00:29:17,419
the modern C++ stuff Oh

00:29:14,440 --> 00:29:22,659
just to recap so resent twisters the

00:29:17,419 --> 00:29:25,039
most robust and I count seventeen

00:29:22,659 --> 00:29:27,770
distributions available in the standard

00:29:25,039 --> 00:29:30,559
library if you want more information on

00:29:27,770 --> 00:29:33,080
this I highly recommend Nico your

00:29:30,559 --> 00:29:35,450
services standard library book 2nd

00:29:33,080 --> 00:29:37,700
edition it's a great book for teaching I

00:29:35,450 --> 00:29:39,380
use it all the time and back when I was

00:29:37,700 --> 00:29:41,480
actually in the private sector I had the

00:29:39,380 --> 00:29:44,210
first edition I practically carried that

00:29:41,480 --> 00:29:45,860
thing everywhere kind of like when I

00:29:44,210 --> 00:29:50,809
carried a basketball everywhere when I

00:29:45,860 --> 00:29:54,350
was a kid ok so moving on we'll talk a

00:29:50,809 --> 00:29:56,809
little bit about boost as you know boost

00:29:54,350 --> 00:29:59,929
is divided into a lot of different

00:29:56,809 --> 00:30:02,419
libraries we'll look at some of the math

00:29:59,929 --> 00:30:05,570
related stuff one of those libraries is

00:30:02,419 --> 00:30:08,809
the boost math toolkit and there are two

00:30:05,570 --> 00:30:12,080
shall we say packages that these are all

00:30:08,809 --> 00:30:14,299
written by different authors so you

00:30:12,080 --> 00:30:19,940
could arguably call them libraries as

00:30:14,299 --> 00:30:23,179
well but two that are very intuitive and

00:30:19,940 --> 00:30:24,650
very useful our statistical

00:30:23,179 --> 00:30:25,880
distributions and that's a bit of a

00:30:24,650 --> 00:30:28,789
mouthful so I'll probably say

00:30:25,880 --> 00:30:33,470
probability distributions and numerical

00:30:28,789 --> 00:30:35,720
integration so and then in addition

00:30:33,470 --> 00:30:42,320
there are some other libraries outside

00:30:35,720 --> 00:30:44,030
the mathematical method toolkit and you

00:30:42,320 --> 00:30:46,010
see them here and we'll talk about those

00:30:44,030 --> 00:30:47,570
a little bit I don't have a lot of time

00:30:46,010 --> 00:30:51,320
to go into detail but there is again

00:30:47,570 --> 00:30:53,530
some sample code that you can see that

00:30:51,320 --> 00:30:59,120
I'll provide you at the end

00:30:53,530 --> 00:31:02,090
ok so probability distributions in boost

00:30:59,120 --> 00:31:04,820
so each distribution in this library is

00:31:02,090 --> 00:31:06,830
a class type now I can probably imagine

00:31:04,820 --> 00:31:08,570
that some of you are saying why are you

00:31:06,830 --> 00:31:10,250
talking about probability distributions

00:31:08,570 --> 00:31:13,250
and boost when we have them in the

00:31:10,250 --> 00:31:14,929
standard library the answer is in the

00:31:13,250 --> 00:31:17,779
standard library it's for

00:31:14,929 --> 00:31:20,869
ran a number generation only in boost

00:31:17,779 --> 00:31:22,399
what we get are the probability density

00:31:20,869 --> 00:31:25,999
function the cumulative distribution

00:31:22,399 --> 00:31:29,059
function and the quantile function but

00:31:25,999 --> 00:31:31,009
in reality we really need all four but

00:31:29,059 --> 00:31:33,679
I'll I'll talk about that at the end

00:31:31,009 --> 00:31:36,589
here but it's very easy to use you need

00:31:33,679 --> 00:31:38,659
to include the necessarily necessary

00:31:36,589 --> 00:31:41,239
headers with just a couple of examples

00:31:38,659 --> 00:31:45,320
here with T distribution and the normal

00:31:41,239 --> 00:31:47,450
distribution and then we can just create

00:31:45,320 --> 00:31:49,940
the objects very easily how do we

00:31:47,450 --> 00:31:50,690
determine a T distribution degrees of

00:31:49,940 --> 00:31:54,320
freedom right

00:31:50,690 --> 00:31:57,379
so students gd1 for degrees of freedom

00:31:54,320 --> 00:32:00,109
done easy and basically the same thing

00:31:57,379 --> 00:32:03,649
for the standard normal mean and

00:32:00,109 --> 00:32:07,099
standard deviation like before now what

00:32:03,649 --> 00:32:10,729
we're after are the those functions that

00:32:07,099 --> 00:32:12,499
I mentioned and the way that they're

00:32:10,729 --> 00:32:14,479
implemented and boost is they are

00:32:12,499 --> 00:32:17,359
generic not member functions but

00:32:14,479 --> 00:32:20,899
extremely easy to use so you want the

00:32:17,359 --> 00:32:25,239
PDF to say PDF your distribution object

00:32:20,899 --> 00:32:29,089
for example with d1 the T distribution

00:32:25,239 --> 00:32:33,309
object we created put PDF d1 value of x

00:32:29,089 --> 00:32:37,759
which you want to evaluate it done easy

00:32:33,309 --> 00:32:39,259
some same thing for the CDF and similar

00:32:37,759 --> 00:32:45,320
for the quantile function except we

00:32:39,259 --> 00:32:49,960
replace X with the percentile value but

00:32:45,320 --> 00:32:52,549
this kind of begs a natural question

00:32:49,960 --> 00:32:55,419
well first of all I count 30 for

00:32:52,549 --> 00:33:00,589
probability distributions in boost

00:32:55,419 --> 00:33:03,589
versus 17 in the standard library so and

00:33:00,589 --> 00:33:05,839
in addition the standard library gives

00:33:03,589 --> 00:33:08,899
us random number generation boosts gives

00:33:05,839 --> 00:33:14,299
us the you know the usual functions that

00:33:08,899 --> 00:33:17,950
we need now will we eventually see a

00:33:14,299 --> 00:33:20,330
union of all of these functions and

00:33:17,950 --> 00:33:22,729
distributions somewhere in the standard

00:33:20,330 --> 00:33:24,710
library so for example in the Arling

00:33:22,729 --> 00:33:27,410
which is everybody most most people

00:33:24,710 --> 00:33:30,350
familiar with our yeah

00:33:27,410 --> 00:33:33,050
so for math and statistics for a new

00:33:30,350 --> 00:33:36,440
distribution to go into either besar or

00:33:33,050 --> 00:33:38,540
into an approved package it must include

00:33:36,440 --> 00:33:41,720
all four it's required or else it'll be

00:33:38,540 --> 00:33:43,880
rejected and in practice we need all

00:33:41,720 --> 00:33:45,560
four so it would be nice to have it all

00:33:43,880 --> 00:33:47,570
in one place and have all 34

00:33:45,560 --> 00:33:59,150
distributions and all the functions

00:33:47,570 --> 00:34:02,960
together but anyway okay so the other

00:33:59,150 --> 00:34:06,860
one that I really like in in boost is

00:34:02,960 --> 00:34:08,780
numerical integration there's a package

00:34:06,860 --> 00:34:11,120
in the toolkit called quadrature it

00:34:08,780 --> 00:34:18,350
actually does both numerical integration

00:34:11,120 --> 00:34:20,870
and differentiation but it is it is

00:34:18,350 --> 00:34:22,879
really really easy to use if suppose you

00:34:20,870 --> 00:34:23,840
want to calculate an integral using the

00:34:22,879 --> 00:34:26,480
trapezoidal

00:34:23,840 --> 00:34:28,250
use the trapezoidal function what does

00:34:26,480 --> 00:34:30,889
it take as inputs it takes in the

00:34:28,250 --> 00:34:34,250
function as either a function object or

00:34:30,889 --> 00:34:36,639
a lambda and then the the limits of

00:34:34,250 --> 00:34:39,020
integration and you're done very easy

00:34:36,639 --> 00:34:40,850
there are some additional parameters

00:34:39,020 --> 00:34:43,520
that have default sara didn't include

00:34:40,850 --> 00:34:45,530
them but for if you want to increase the

00:34:43,520 --> 00:34:53,899
number of iterations or put a different

00:34:45,530 --> 00:34:57,980
tolerance and you can now this kind of

00:34:53,899 --> 00:35:02,450
begs another question what if we wanted

00:34:57,980 --> 00:35:05,690
to write route finding algorithms now

00:35:02,450 --> 00:35:07,130
these are in boost but again because

00:35:05,690 --> 00:35:08,780
this is different author it's done

00:35:07,130 --> 00:35:12,860
completely differently from what you see

00:35:08,780 --> 00:35:17,120
here and I don't want to you know offend

00:35:12,860 --> 00:35:22,430
anyone but it's far more complex than

00:35:17,120 --> 00:35:24,650
what you see here but we could we could

00:35:22,430 --> 00:35:26,300
do the same thing and in fact a student

00:35:24,650 --> 00:35:29,860
of mine died over the summer we did some

00:35:26,300 --> 00:35:33,500
prototyping of the bisection method and

00:35:29,860 --> 00:35:35,450
steffensen's method and and we're able

00:35:33,500 --> 00:35:37,430
to get them to work we took a few hints

00:35:35,450 --> 00:35:39,560
from the actual source code for

00:35:37,430 --> 00:35:42,680
numerical integration in boost

00:35:39,560 --> 00:35:45,230
so again it's just like that you're done

00:35:42,680 --> 00:35:47,930
and you don't have to set up a lot of

00:35:45,230 --> 00:35:50,090
stuff and you know how it can be

00:35:47,930 --> 00:35:53,240
sometimes in some of these libraries so

00:35:50,090 --> 00:35:55,100
anyway there's some examples examples of

00:35:53,240 --> 00:35:59,480
those in the sample code if you want to

00:35:55,100 --> 00:36:05,900
take a look at them okay so to close it

00:35:59,480 --> 00:36:08,750
out there are three other libraries that

00:36:05,900 --> 00:36:14,060
I mean that are I found to be quite

00:36:08,750 --> 00:36:17,990
useful for financial modeling one is the

00:36:14,060 --> 00:36:20,210
circular buffers library this is an STL

00:36:17,990 --> 00:36:23,000
compliant container it's much like a

00:36:20,210 --> 00:36:27,850
stood deck except that it has a fixed

00:36:23,000 --> 00:36:31,100
capacity so it's very very useful for

00:36:27,850 --> 00:36:34,400
handling live rate feeds say from

00:36:31,100 --> 00:36:38,030
Reuters or Bloomberg so it will fill up

00:36:34,400 --> 00:36:41,060
to capacity and then when the next data

00:36:38,030 --> 00:36:44,120
point comes in it pops off the oldest

00:36:41,060 --> 00:36:48,460
one pushes on the new one and it's very

00:36:44,120 --> 00:36:52,640
convenient for that purpose another one

00:36:48,460 --> 00:36:57,320
are the accumulators these are also STL

00:36:52,640 --> 00:36:59,570
compliant they're ideal for managing

00:36:57,320 --> 00:37:01,970
data columns because they're equipped

00:36:59,570 --> 00:37:05,960
with the usual descriptive statistics'

00:37:01,970 --> 00:37:08,540
functions like mean median max standard

00:37:05,960 --> 00:37:15,470
deviation and so forth so those can be

00:37:08,540 --> 00:37:20,300
useful too and then finally is multi

00:37:15,470 --> 00:37:23,480
array and also STL compliant it's a

00:37:20,300 --> 00:37:26,530
templated multidimensional array and one

00:37:23,480 --> 00:37:30,830
thing it can be very useful for is

00:37:26,530 --> 00:37:33,500
lattice models for option pricing and to

00:37:30,830 --> 00:37:36,620
give you an example I'm going to show

00:37:33,500 --> 00:37:40,940
you a binomial lattice for pricing a

00:37:36,620 --> 00:37:46,310
European option and so it looks

00:37:40,940 --> 00:37:48,080
something like this it's similar to the

00:37:46,310 --> 00:37:49,720
Monte Carlo method except the

00:37:48,080 --> 00:37:52,180
up-and-down movements are

00:37:49,720 --> 00:37:54,310
described and the the probability is

00:37:52,180 --> 00:37:56,560
actually prescribed but it's not

00:37:54,310 --> 00:37:58,480
arbitrary it this also comes out of the

00:37:56,560 --> 00:38:01,150
black-scholes theory so again if you

00:37:58,480 --> 00:38:05,590
were to take all three you took the

00:38:01,150 --> 00:38:07,420
Monte Carlo and the this example they

00:38:05,590 --> 00:38:11,890
should all converge to the black-scholes

00:38:07,420 --> 00:38:18,550
price but it's similar in that you see

00:38:11,890 --> 00:38:22,119
if I notice so you can see we go out on

00:38:18,550 --> 00:38:24,609
the tree and it's just like you know

00:38:22,119 --> 00:38:28,900
scenarios in Monte Carlo and we generate

00:38:24,609 --> 00:38:31,810
the equity prices we get to the

00:38:28,900 --> 00:38:33,880
expiration date and we then look at the

00:38:31,810 --> 00:38:35,740
payoff so these are out of the money and

00:38:33,880 --> 00:38:37,869
these are in the money and then we use

00:38:35,740 --> 00:38:41,650
interest rates and the probabilities

00:38:37,869 --> 00:38:44,380
going back to calculate expected values

00:38:41,650 --> 00:38:49,000
of the option price at each one of these

00:38:44,380 --> 00:38:52,750
nodes until we get to our option price

00:38:49,000 --> 00:38:54,940
here now why are the why are these

00:38:52,750 --> 00:38:57,520
useful each one of these nodes is an

00:38:54,940 --> 00:38:59,440
object so this is a very simple case

00:38:57,520 --> 00:39:01,839
going out you could have a struct it

00:38:59,440 --> 00:39:05,250
stores the the equity price going out

00:39:01,839 --> 00:39:08,650
and the payoffs going deck but again

00:39:05,250 --> 00:39:11,800
there are much more complex options and

00:39:08,650 --> 00:39:14,920
in fact that object you have might be a

00:39:11,800 --> 00:39:16,599
full class with more calculations that

00:39:14,920 --> 00:39:18,250
need to be done along with member

00:39:16,599 --> 00:39:22,330
functions that do some of those interim

00:39:18,250 --> 00:39:24,849
calculations and the other thing too is

00:39:22,330 --> 00:39:27,330
like with with Monte Carlo you you would

00:39:24,849 --> 00:39:31,330
need you would need more time steps

00:39:27,330 --> 00:39:33,720
otherwise it's not the you're not really

00:39:31,330 --> 00:39:39,910
going to converge to anything meaningful

00:39:33,720 --> 00:39:42,220
okay so Wow I was worried about not

00:39:39,910 --> 00:39:46,810
having enough time but I'm we're almost

00:39:42,220 --> 00:39:49,420
there so you can see down the bottom

00:39:46,810 --> 00:39:51,609
this is from a book called option theory

00:39:49,420 --> 00:39:55,330
by Peter James if you're interested at

00:39:51,609 --> 00:39:57,339
all in this field I highly recommend

00:39:55,330 --> 00:40:01,660
this book I also use it for several of

00:39:57,339 --> 00:40:04,540
my classes and also use it in practice

00:40:01,660 --> 00:40:08,710
and speaking of references here are a

00:40:04,540 --> 00:40:11,080
few more that I used for for this talk

00:40:08,710 --> 00:40:13,630
if you would like more information on

00:40:11,080 --> 00:40:17,350
our program shameless plug

00:40:13,630 --> 00:40:21,310
that's our URL you can also ask me about

00:40:17,350 --> 00:40:24,840
it if you're interested we are a top 15

00:40:21,310 --> 00:40:26,710
program in the country and we get

00:40:24,840 --> 00:40:36,340
essentially a hundred percent placement

00:40:26,710 --> 00:40:40,450
of graduates so then after that just to

00:40:36,340 --> 00:40:43,540
wrap up here's the github address for

00:40:40,450 --> 00:40:46,060
the sample code if you'd like to contact

00:40:43,540 --> 00:40:48,070
me this is my email address at the

00:40:46,060 --> 00:40:53,350
University

00:40:48,070 --> 00:40:55,840
I'm also on LinkedIn and I will also be

00:40:53,350 --> 00:40:58,180
around all week so for the rest of week

00:40:55,840 --> 00:41:01,540
wise say it's almost over

00:40:58,180 --> 00:41:02,800
we're at the past a halfway mark now but

00:41:01,540 --> 00:41:04,330
anyway I'll be around the rest of the

00:41:02,800 --> 00:41:06,720
week so if you see me if you'd like to

00:41:04,330 --> 00:41:11,200
ask any more questions

00:41:06,720 --> 00:41:13,260
that's fine or I conversely if you work

00:41:11,200 --> 00:41:15,790
in this field I'd like to hear from you

00:41:13,260 --> 00:41:18,010
just don't give me any proprietary

00:41:15,790 --> 00:41:19,300
information because I don't want to go

00:41:18,010 --> 00:41:23,350
to jail and I don't want you to go to

00:41:19,300 --> 00:41:26,740
jail so anyway if you see me around in

00:41:23,350 --> 00:41:28,960
the spirit of leverage and leverage the

00:41:26,740 --> 00:41:31,420
leverage of beverage and talk little

00:41:28,960 --> 00:41:33,630
shop so thank you very much for

00:41:31,420 --> 00:41:33,630
attending

00:41:38,450 --> 00:41:49,200
so we do have some time for questions hi

00:41:44,610 --> 00:41:51,330
thanks for presenting so much I see in

00:41:49,200 --> 00:41:53,730
this field devolves into some form of a

00:41:51,330 --> 00:41:56,340
matrix and linear algebra do you have

00:41:53,730 --> 00:42:01,460
any recommendations or suggestions for

00:41:56,340 --> 00:42:03,780
how to work with matrices or linear

00:42:01,460 --> 00:42:07,020
algebraic libraries that you've used

00:42:03,780 --> 00:42:09,690
thank you yeah well the two that I

00:42:07,020 --> 00:42:14,630
mentioned eigen and armadillo are are

00:42:09,690 --> 00:42:18,600
widely used I personally prefer eigen

00:42:14,630 --> 00:42:22,050
but a lot of people like armadillo I can

00:42:18,600 --> 00:42:24,930
one thing that's nice about it it's it's

00:42:22,050 --> 00:42:27,680
all templated so all you have to do is

00:42:24,930 --> 00:42:30,810
include the header files or as with

00:42:27,680 --> 00:42:33,480
armadillo I have run into some problems

00:42:30,810 --> 00:42:37,290
with the linking with some of the

00:42:33,480 --> 00:42:38,940
libraries in some complex cases where we

00:42:37,290 --> 00:42:42,180
were interfacing with another language

00:42:38,940 --> 00:42:48,030
so and also the documentation for eigen

00:42:42,180 --> 00:42:49,830
is is really really good so I hope the

00:42:48,030 --> 00:42:54,600
question can you recommend any good

00:42:49,830 --> 00:42:57,120
sources on what might be called software

00:42:54,600 --> 00:43:04,370
engineering best practices specifically

00:42:57,120 --> 00:43:08,910
targeted toward quants take my classes

00:43:04,370 --> 00:43:12,840
available online - I'm sorry shameless

00:43:08,910 --> 00:43:15,180
plug well that kind of gets back to my

00:43:12,840 --> 00:43:17,760
gripe at the beginning I'm unable to

00:43:15,180 --> 00:43:20,400
really find any decent resources on it

00:43:17,760 --> 00:43:24,660
that's why I asked they had the same

00:43:20,400 --> 00:43:27,810
problem okay yeah but if you I'm happy

00:43:24,660 --> 00:43:30,270
to share with you lecture notes or

00:43:27,810 --> 00:43:31,740
anything so you know just just drop me a

00:43:30,270 --> 00:43:36,770
note say you're the guy who asked and

00:43:31,740 --> 00:43:36,770
you know be happy - yeah

00:43:37,610 --> 00:43:43,950
you sure you want to do that hi thanks

00:43:42,450 --> 00:43:45,240
for you talk this is a ring from

00:43:43,950 --> 00:43:47,280
Bloomberg can actually go back to the

00:43:45,240 --> 00:43:51,000
slide where you showed the still a sink

00:43:47,280 --> 00:43:52,380
the like this one the the slide where

00:43:51,000 --> 00:44:07,740
you have the code were you creating the

00:43:52,380 --> 00:44:10,500
threads okay so right here I where you

00:44:07,740 --> 00:44:12,480
do create the e sink don't you have to

00:44:10,500 --> 00:44:14,010
specify like a launch policy here

00:44:12,480 --> 00:44:15,750
because that's why I said that's why I

00:44:14,010 --> 00:44:18,960
said there are some subtleties and

00:44:15,750 --> 00:44:20,850
nuances that I just I see yeah because I

00:44:18,960 --> 00:44:23,190
guess I just talked to Anthony Williams

00:44:20,850 --> 00:44:25,350
today and I think from C++ 14 this this

00:44:23,190 --> 00:44:28,320
syntax is invalid I mean undefined

00:44:25,350 --> 00:44:30,630
behavior according to the standard I've

00:44:28,320 --> 00:44:35,850
run it on a 14 and 17 compiler no

00:44:30,630 --> 00:44:37,350
problem I see yeah it's just blah but it

00:44:35,850 --> 00:44:39,570
but if you have you know if there's

00:44:37,350 --> 00:44:41,850
something I can be aware of you got my

00:44:39,570 --> 00:44:42,390
email address cool thank you I'd like to

00:44:41,850 --> 00:44:52,020
hear about it

00:44:42,390 --> 00:44:56,130
thank you I have a follow-up comment on

00:44:52,020 --> 00:44:58,500
this slide especially so first question

00:44:56,130 --> 00:45:00,930
I'm not commented questions right first

00:44:58,500 --> 00:45:03,060
question you created like ten thousand

00:45:00,930 --> 00:45:05,400
or a hundred thousand threads mm-hmm in

00:45:03,060 --> 00:45:08,190
the for loop don't you have like a

00:45:05,400 --> 00:45:11,520
thread congestion on your virtual

00:45:08,190 --> 00:45:13,710
machine it was just 24 course didn't

00:45:11,520 --> 00:45:15,720
have any problem and that's what I say

00:45:13,710 --> 00:45:17,160
is the beauty of tests based concurrency

00:45:15,720 --> 00:45:22,880
because you don't have to worry about it

00:45:17,160 --> 00:45:22,880
I've just never had a problem with it um

00:45:23,330 --> 00:45:33,240
okay oh yeah because it doesn't say

00:45:27,960 --> 00:45:36,300
policy then probably comment when you do

00:45:33,240 --> 00:45:40,130
the accumulate well there is an parallel

00:45:36,300 --> 00:45:43,170
accumulate right oh I know I know I just

00:45:40,130 --> 00:45:45,750
okay no question out of curiosity if

00:45:43,170 --> 00:45:47,010
you're just in this example you take the

00:45:45,750 --> 00:45:48,990
latest point

00:45:47,010 --> 00:45:51,570
why do you return the whole

00:45:48,990 --> 00:45:53,460
vector and then just drop all except a

00:45:51,570 --> 00:45:55,940
flat point because you need to generate

00:45:53,460 --> 00:45:59,220
the whole vector in order to get that

00:45:55,940 --> 00:46:03,119
that last price yeah but it can be just

00:45:59,220 --> 00:46:07,020
you know runtime variable because your

00:46:03,119 --> 00:46:11,210
your endless one time point depends on

00:46:07,020 --> 00:46:14,660
only on anther point so just a question

00:46:11,210 --> 00:46:17,910
I suppose I just found this way to be

00:46:14,660 --> 00:46:33,030
more straightforward I don't know if

00:46:17,910 --> 00:46:36,000
there what's it what do you mean I'm

00:46:33,030 --> 00:46:37,980
gonna go on this point here all I'm

00:46:36,000 --> 00:46:45,570
doing is I'm getting the the last price

00:46:37,980 --> 00:46:48,180
I'm not copying the vendor there no but

00:46:45,570 --> 00:46:49,980
but still there's there's no copy here

00:46:48,180 --> 00:46:51,780
yeah but you still vacuum

00:46:49,980 --> 00:46:53,730
I mean allocate the whole memory for the

00:46:51,780 --> 00:46:55,350
whole array but in principle you just

00:46:53,730 --> 00:46:56,600
trade through the two point and I

00:46:55,350 --> 00:46:59,490
suppose you could but it just

00:46:56,600 --> 00:47:03,600
mathematically it made a lot of sense to

00:46:59,490 --> 00:47:06,900
just put the whole thing in but also

00:47:03,600 --> 00:47:09,240
just to show how to use task based

00:47:06,900 --> 00:47:12,150
concurrency I'm sure there's some you

00:47:09,240 --> 00:47:13,859
know I some improvements that could be

00:47:12,150 --> 00:47:16,440
since we're talking about mathematics I

00:47:13,859 --> 00:47:19,500
have one man York comment there's a

00:47:16,440 --> 00:47:22,470
previous slide with the formula with a

00:47:19,500 --> 00:47:33,240
traitor formula can you please slide on

00:47:22,470 --> 00:47:38,400
it yeah not previous but yeah used to be

00:47:33,240 --> 00:47:41,700
some slide this one yeah so I shouldn't

00:47:38,400 --> 00:47:45,720
converge to something when you'd make

00:47:41,700 --> 00:47:48,770
delta T goes closer to zero I mean

00:47:45,720 --> 00:47:53,990
you're basically to find that it's in

00:47:48,770 --> 00:47:57,600
yes it does it it converges into the

00:47:53,990 --> 00:47:59,490
into a differential equation stochastic

00:47:57,600 --> 00:48:02,430
differential equations what happens I

00:47:59,490 --> 00:48:06,180
see my Bell asked Lisa fine but yes

00:48:02,430 --> 00:48:07,680
we're thirty consultant it says that

00:48:06,180 --> 00:48:13,619
this is what falls out of the theory

00:48:07,680 --> 00:48:15,450
when you when you discretize the you

00:48:13,619 --> 00:48:18,359
discretize the formula that you get from

00:48:15,450 --> 00:48:20,720
stochastic calculus okay well thank you

00:48:18,359 --> 00:48:20,720
sure

00:48:20,809 --> 00:48:26,430
III hope this isn't out of place but I'd

00:48:24,030 --> 00:48:29,160
like to actually comment on the previous

00:48:26,430 --> 00:48:31,380
question ORS question I happen to work

00:48:29,160 --> 00:48:33,390
in a quant group where we are producing

00:48:31,380 --> 00:48:36,089
data that's used for accounting public

00:48:33,390 --> 00:48:39,300
accounting and we get audited on a

00:48:36,089 --> 00:48:41,400
regular basis and having things like the

00:48:39,300 --> 00:48:43,770
entire sequences that you've generated

00:48:41,400 --> 00:48:45,540
in a Monte Carlo model end up being

00:48:43,770 --> 00:48:47,430
quite useful in the scenarios like that

00:48:45,540 --> 00:48:49,020
because sometimes we were fighting with

00:48:47,430 --> 00:48:50,670
you know one of the big a decor big

00:48:49,020 --> 00:48:53,280
however many big and the counter firms

00:48:50,670 --> 00:48:55,170
and we have to get to the point of

00:48:53,280 --> 00:48:57,569
giving them a spreadsheet with okay this

00:48:55,170 --> 00:49:03,720
is what our Monte Carlo method generated

00:48:57,569 --> 00:49:06,900
and so the question of how much data you

00:49:03,720 --> 00:49:08,700
keep somewhat depends on questions of

00:49:06,900 --> 00:49:11,579
whether you're having to do that type of

00:49:08,700 --> 00:49:13,230
validation to third parties so I know

00:49:11,579 --> 00:49:15,510
that's a rare that's a rare thing in a

00:49:13,230 --> 00:49:18,030
quant group no it's not oh no because

00:49:15,510 --> 00:49:21,290
there are lots of regulations that are

00:49:18,030 --> 00:49:24,000
involved and that's why it's important

00:49:21,290 --> 00:49:26,609
that's where the seed value comes in and

00:49:24,000 --> 00:49:28,650
in fact when I worked on the in variable

00:49:26,609 --> 00:49:29,940
annuities especially because you've got

00:49:28,650 --> 00:49:34,380
there

00:49:29,940 --> 00:49:36,930
you've got FINRA SEC you've got state

00:49:34,380 --> 00:49:39,780
insurance you've got standards of

00:49:36,930 --> 00:49:43,500
practice by the Society of Actuaries and

00:49:39,780 --> 00:49:48,329
you've got very some of the at the

00:49:43,500 --> 00:49:50,400
accounting groups a gap and faz and so

00:49:48,329 --> 00:49:52,680
you have to be able to reproduce your

00:49:50,400 --> 00:50:01,490
results and so that's a it's actually a

00:49:52,680 --> 00:50:01,490
very valid comment okay so anything else

00:50:01,520 --> 00:50:05,570

YouTube URL: https://www.youtube.com/watch?v=NeGO8lWDgyo


