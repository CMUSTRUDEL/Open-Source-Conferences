Title: CppCon 2019: Milian Wolff  “How to Write a Heap Memory Profiler”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Have you ever wondered how profilers work? Did you ever run into a situation where you wanted to write your own custom profiler, but didn't know how to go about it? Then this talk is for you.

We will build a proof-of-concept heap profiler on Linux that implements the most important aspects of a custom tracing profiler: Intercepting function calls, runtime injection, call stack unwinding and debug symbol resolution. All of these concepts are generic and don't only apply to a heap profiler, we will just use that as a motivating example.

The talk will also touch on some of the lessons learned creating a productionized heap profiler called heaptrack: What data format should you use? How can you compress the data? What needs to be taken into account to support profiling on embedded platforms?

Combined, this talk will teach you about some of the layers behind the scenes of a standardized C++ application. Sadly, these layers tend to be platform dependent. For that reason, this talk concentrates on Linux, but the core principles apply to other platforms too.
— 
Milian Wolff
KDAB
Senior Software Engineer
Germany / Sweden / France / UK / USA

Milian Wolff is a Senior Software Engineer at KDAB, Milian leads the R&D in tooling and profiling in which he has a special interest. Milian created Massif-Visualizer, heaptrack and hotspot, all of which are now used regularly to improve the performance of C++ and Qt applications. When not applying his knowledge to improving code base performance for KDAB’s customers, Milian maintains QtWebChannel for the Qt Project and is co-maintainer of the KDevelop IDE. In 2015, Milian won KDE’s Akademy Award for his work on Clang integration. He has a Masters Degree in Physics.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,610 --> 00:00:13,860
hi welcome everyone today's last session

00:00:11,850 --> 00:00:17,369
how to write a heap profiler

00:00:13,860 --> 00:00:19,650
um I'm million I really like tooling I

00:00:17,369 --> 00:00:23,480
happen to have written quite a few tools

00:00:19,650 --> 00:00:26,340
in my time already and today I want to

00:00:23,480 --> 00:00:28,470
kind of demystify how to build one of

00:00:26,340 --> 00:00:32,010
such tools what happens behind the

00:00:28,470 --> 00:00:34,620
scenes and how you can maybe leverage

00:00:32,010 --> 00:00:38,840
that yourself to build special-made

00:00:34,620 --> 00:00:43,049
purpose hand-built tool for your needs

00:00:38,840 --> 00:00:46,290
so I kind of hop it I hope that you have

00:00:43,049 --> 00:00:49,710
had enough C++ for today because well

00:00:46,290 --> 00:00:53,430
today this last talk won't be too much

00:00:49,710 --> 00:01:00,869
about C++ editor as it turns out rather

00:00:53,430 --> 00:01:02,489
when we look at what is required many of

00:01:00,869 --> 00:01:05,760
the things that I'll show you are not

00:01:02,489 --> 00:01:07,820
standardized at all as part of the C++

00:01:05,760 --> 00:01:13,440
standard they are standardized by

00:01:07,820 --> 00:01:15,720
platform dependent manuals so it happens

00:01:13,440 --> 00:01:17,790
to be that most of these these tools are

00:01:15,720 --> 00:01:21,420
very very platform specific so in this

00:01:17,790 --> 00:01:23,610
case I like Linux so all of the stuff

00:01:21,420 --> 00:01:26,040
that I'm going to show you is only valid

00:01:23,610 --> 00:01:28,980
on Linux in the way that I implemented

00:01:26,040 --> 00:01:31,950
it the core concepts though they apply

00:01:28,980 --> 00:01:34,640
equally to all the other platforms you

00:01:31,950 --> 00:01:37,590
just have to find corresponding

00:01:34,640 --> 00:01:41,940
equivalent library or whatever to do

00:01:37,590 --> 00:01:43,830
these kind of things this tour contains

00:01:41,940 --> 00:01:46,380
information that I learned the hard way

00:01:43,830 --> 00:01:49,320
so originally ten years ago so I always

00:01:46,380 --> 00:01:53,250
thought that writing a profiler is only

00:01:49,320 --> 00:01:55,260
for like black magic people and that

00:01:53,250 --> 00:01:58,200
doesn't that's not the case at all it's

00:01:55,260 --> 00:02:01,350
actually very very trivial once you

00:01:58,200 --> 00:02:03,960
learn how to put the little pit and

00:02:01,350 --> 00:02:04,680
puzzle pieces together right so this

00:02:03,960 --> 00:02:07,409
park

00:02:04,680 --> 00:02:09,659
hopefully shows you what are these

00:02:07,409 --> 00:02:13,140
puzzle pieces and how can you put them

00:02:09,659 --> 00:02:16,200
together yourself lots of dirty details

00:02:13,140 --> 00:02:17,819
here so language lawyers be we were all

00:02:16,200 --> 00:02:19,890
of the source code that I'm going to

00:02:17,819 --> 00:02:22,010
show as part of this github repo so you

00:02:19,890 --> 00:02:24,140
can just go there after the talk and

00:02:22,010 --> 00:02:25,909
check it out yourself compile it play

00:02:24,140 --> 00:02:31,610
around with it change it and so Quinn

00:02:25,909 --> 00:02:33,590
sores go ahead right so um where did I

00:02:31,610 --> 00:02:37,090
learn all of this there are two tools

00:02:33,590 --> 00:02:40,549
that I've written recently ish so in May

00:02:37,090 --> 00:02:42,590
2013 I started heaped rec heap memory

00:02:40,549 --> 00:02:44,959
profiler for Linux which is like the

00:02:42,590 --> 00:02:47,500
core foundation of this talk anyone in

00:02:44,959 --> 00:02:51,319
the audience who who's used heap track

00:02:47,500 --> 00:02:54,049
not too many those who haven't used it

00:02:51,319 --> 00:02:57,620
but target Linux try it out it's open

00:02:54,049 --> 00:03:01,430
source and then more recently in

00:02:57,620 --> 00:03:04,220
December 2016 I started hotspot so

00:03:01,430 --> 00:03:07,519
anyone heard of that one a UI for Linux

00:03:04,220 --> 00:03:09,859
path also not too many so if you happen

00:03:07,519 --> 00:03:11,720
to have huge Linux perf and found it

00:03:09,859 --> 00:03:14,420
kind of awkward to use on the command

00:03:11,720 --> 00:03:16,579
line try out the UI there's an app image

00:03:14,420 --> 00:03:19,340
just download it make it executable run

00:03:16,579 --> 00:03:21,709
it drop-in replacement for per report I

00:03:19,340 --> 00:03:23,989
kind of like it and I got good feedback

00:03:21,709 --> 00:03:25,940
so this is where I learned all of this

00:03:23,989 --> 00:03:28,700
and you can also look at these

00:03:25,940 --> 00:03:31,760
implementations for further inspiration

00:03:28,700 --> 00:03:35,169
in case you wonder how this could all be

00:03:31,760 --> 00:03:38,840
leveraged so um

00:03:35,169 --> 00:03:41,209
this talk is essentially showing you how

00:03:38,840 --> 00:03:44,419
to do heap profiling based on tracing

00:03:41,209 --> 00:03:46,790
and not sampling right and tracing is

00:03:44,419 --> 00:03:49,250
actually quite useful debugging and

00:03:46,790 --> 00:03:51,650
profiling technique it's been being used

00:03:49,250 --> 00:03:54,639
all over the place right perf tres

00:03:51,650 --> 00:03:57,319
estrellas L trays heap Trek obviously

00:03:54,639 --> 00:03:58,819
but I guess I'm not the only one who

00:03:57,319 --> 00:04:01,700
isn't ashamed to say I'm still using

00:03:58,819 --> 00:04:04,519
printf tracing debugging profiling

00:04:01,700 --> 00:04:06,500
whatever just added a short cluck

00:04:04,519 --> 00:04:08,450
statement to my code to check how long

00:04:06,500 --> 00:04:10,220
does it actually take on the wall clock

00:04:08,450 --> 00:04:13,669
right so it's being used all over the

00:04:10,220 --> 00:04:15,709
place the thing though is once you start

00:04:13,669 --> 00:04:18,260
writing one of these tools yourself to

00:04:15,709 --> 00:04:20,510
deploy it on a larger scale to actually

00:04:18,260 --> 00:04:22,060
make it possible to run you trace on

00:04:20,510 --> 00:04:25,130
real world applications

00:04:22,060 --> 00:04:27,650
it starts become quite hard like if you

00:04:25,130 --> 00:04:30,710
would do printf tracing for Mellark

00:04:27,650 --> 00:04:32,210
already you would completely obliterate

00:04:30,710 --> 00:04:34,760
the performance of your application

00:04:32,210 --> 00:04:35,240
because these like memory allocations

00:04:34,760 --> 00:04:37,669
they have

00:04:35,240 --> 00:04:42,110
thousands millions of times per second

00:04:37,669 --> 00:04:43,490
right so you have to be very performance

00:04:42,110 --> 00:04:45,789
conscious when you write one of these

00:04:43,490 --> 00:04:49,250
things and then there are some other

00:04:45,789 --> 00:04:52,340
features that I demand from a good

00:04:49,250 --> 00:04:53,990
tracer most notably when I don't use the

00:04:52,340 --> 00:04:58,150
trace I don't want to pay any price for

00:04:53,990 --> 00:05:00,710
not using it right so there are some

00:04:58,150 --> 00:05:03,889
approaches to to tracing which require

00:05:00,710 --> 00:05:07,669
you to recompile your code and then this

00:05:03,889 --> 00:05:12,199
adds tracing capabilities I bet it

00:05:07,669 --> 00:05:13,460
exists for heap profiling - I don't do

00:05:12,199 --> 00:05:15,680
this instead

00:05:13,460 --> 00:05:18,830
this talk will show you techniques -

00:05:15,680 --> 00:05:21,050
well not change your code at all

00:05:18,830 --> 00:05:24,080
but instead we well you could say we

00:05:21,050 --> 00:05:26,780
kind of hack into an application to get

00:05:24,080 --> 00:05:30,940
notified whenever an allocation happens

00:05:26,780 --> 00:05:30,940
and I will show you how this is done and

00:05:31,509 --> 00:05:36,949
additionally one cool thing that is kind

00:05:34,759 --> 00:05:39,380
of hard to do is supporting runtime

00:05:36,949 --> 00:05:42,949
attaching so imagine you have a

00:05:39,380 --> 00:05:45,199
long-running server application not on

00:05:42,949 --> 00:05:48,139
Google or Facebook scale but let's say a

00:05:45,199 --> 00:05:50,930
single machine somewhere and after a

00:05:48,139 --> 00:05:54,830
week at a month whatever you realize a

00:05:50,930 --> 00:05:56,900
memory allocations pile up I seem to

00:05:54,830 --> 00:05:59,210
have a leak or something that looks like

00:05:56,900 --> 00:06:01,310
a leak what do you do now right you

00:05:59,210 --> 00:06:03,919
can't just restart your application wait

00:06:01,310 --> 00:06:05,810
again for month and then get some

00:06:03,919 --> 00:06:09,110
results back right you want to runtime

00:06:05,810 --> 00:06:11,180
attach and see instantly what's going on

00:06:09,110 --> 00:06:13,430
there and doing that is kind of tricky

00:06:11,180 --> 00:06:15,409
but thankfully there's Stack Overflow

00:06:13,430 --> 00:06:17,569
with people that helped me out and now

00:06:15,409 --> 00:06:21,830
I'm helping you out and tell you how to

00:06:17,569 --> 00:06:25,250
do this and write one of the key

00:06:21,830 --> 00:06:27,039
takeaways maybe from this talk is when

00:06:25,250 --> 00:06:30,280
you think about writing your own tracer

00:06:27,039 --> 00:06:34,909
don't start from scratch build on top of

00:06:30,280 --> 00:06:37,880
existing proven solutions so there's

00:06:34,909 --> 00:06:42,590
definitely a supporting perfor like user

00:06:37,880 --> 00:06:46,279
space probes or static dtrace like pro

00:06:42,590 --> 00:06:48,490
points there's ltte ng a more recent

00:06:46,279 --> 00:06:51,520
addition to this tooling landscape is

00:06:48,490 --> 00:06:53,680
LLVM x-ray and there are many many more

00:06:51,520 --> 00:06:55,870
tools like that and they solve many of

00:06:53,680 --> 00:06:58,840
the hard problems for you they are

00:06:55,870 --> 00:07:01,599
oftentimes reusable so better not start

00:06:58,840 --> 00:07:06,250
from scratch use those and then build on

00:07:01,599 --> 00:07:09,370
top great so what do we actually want to

00:07:06,250 --> 00:07:13,060
achieve when we say we wanna keep

00:07:09,370 --> 00:07:15,370
profile there are basically four steps

00:07:13,060 --> 00:07:17,319
let's say at least on this slide the

00:07:15,370 --> 00:07:19,840
first one is going to be we want to

00:07:17,319 --> 00:07:21,940
inject custom code like yeah let's be

00:07:19,840 --> 00:07:24,880
hacker hacker man

00:07:21,940 --> 00:07:29,650
let's run stuff that isn't compiled into

00:07:24,880 --> 00:07:31,389
an executable but like I have compiled

00:07:29,650 --> 00:07:34,630
completely separately how can I get it

00:07:31,389 --> 00:07:37,120
into my other library code executable

00:07:34,630 --> 00:07:40,690
you name it and execute it and not only

00:07:37,120 --> 00:07:42,580
that the second step then is I want to

00:07:40,690 --> 00:07:46,210
be notified whenever the other

00:07:42,580 --> 00:07:48,340
application called specific trace points

00:07:46,210 --> 00:07:50,470
so in this case it's library functions

00:07:48,340 --> 00:07:52,150
that we are going to trace malloc and

00:07:50,470 --> 00:07:59,080
free you name it we'll see that in a bit

00:07:52,150 --> 00:08:01,509
and then um just being notified that the

00:07:59,080 --> 00:08:04,590
memory allocation happened is by far not

00:08:01,509 --> 00:08:07,479
enough and it's actually a crucial point

00:08:04,590 --> 00:08:10,719
you need a back trace to make use of

00:08:07,479 --> 00:08:13,030
these kind of tracing data right because

00:08:10,719 --> 00:08:15,969
otherwise you will see I happen to have

00:08:13,030 --> 00:08:18,550
called malloc a lot thank you but the

00:08:15,969 --> 00:08:21,039
actual interesting part is where did I

00:08:18,550 --> 00:08:23,050
call it right without the call stack

00:08:21,039 --> 00:08:25,810
without the back trace the tracing data

00:08:23,050 --> 00:08:28,389
is in my opinion pretty much useless so

00:08:25,810 --> 00:08:29,889
this is a very very hard problem when

00:08:28,389 --> 00:08:32,169
you would have to start from scratch

00:08:29,889 --> 00:08:34,260
when you know the right libraries to use

00:08:32,169 --> 00:08:37,089
this is actually doable because remember

00:08:34,260 --> 00:08:40,630
memory allocations happen like thousands

00:08:37,089 --> 00:08:44,950
millions of times per second if you look

00:08:40,630 --> 00:08:48,480
at bad code letters so the last part

00:08:44,950 --> 00:08:51,310
then is we want to make tracing

00:08:48,480 --> 00:08:53,320
profiling as quick as possible and a

00:08:51,310 --> 00:08:56,220
very very common approach there is to

00:08:53,320 --> 00:08:58,690
delay the post processing step such that

00:08:56,220 --> 00:09:01,660
while recording you don't actually pay

00:08:58,690 --> 00:09:02,140
the price of symbolization resolving of

00:09:01,660 --> 00:09:04,300
in line

00:09:02,140 --> 00:09:07,360
frames yada yada I'll I'll show you how

00:09:04,300 --> 00:09:10,060
this is done later so it's on one hand a

00:09:07,360 --> 00:09:13,240
profiling aspect or no a performance

00:09:10,060 --> 00:09:15,670
aspect and on the other hand it is also

00:09:13,240 --> 00:09:17,260
a functionality aspect because when you

00:09:15,670 --> 00:09:20,170
think about embedded systems and you

00:09:17,260 --> 00:09:22,710
want to profile keep allocations on an

00:09:20,170 --> 00:09:26,470
embedded system you won't be able to

00:09:22,710 --> 00:09:27,790
symbolize back traces because you

00:09:26,470 --> 00:09:30,550
usually don't have to debug symbols

00:09:27,790 --> 00:09:32,410
available on an embedded device right so

00:09:30,550 --> 00:09:34,720
there's an inherent distinguish a

00:09:32,410 --> 00:09:36,460
distinction between recording data

00:09:34,720 --> 00:09:39,850
getting back traces and then later on

00:09:36,460 --> 00:09:42,280
analyzing those with debug symbols and

00:09:39,850 --> 00:09:46,060
so forth so this is a important

00:09:42,280 --> 00:09:51,580
distinction so this is the content of

00:09:46,060 --> 00:09:53,830
this talk now when I'm talking about

00:09:51,580 --> 00:09:57,040
memory allocations I'm usually going to

00:09:53,830 --> 00:10:01,060
say heap memory I think the proper C++

00:09:57,040 --> 00:10:04,300
term is dynamic storage anyways the the

00:10:01,060 --> 00:10:07,780
important part is I'll just concentrate

00:10:04,300 --> 00:10:09,310
on Lipsy functions because on Linux at

00:10:07,780 --> 00:10:11,650
least it happens to be the case that

00:10:09,310 --> 00:10:13,810
even operate anew and all the the

00:10:11,650 --> 00:10:18,160
overlay loads they just end up calling

00:10:13,810 --> 00:10:21,550
Lipsy functions right so when we want to

00:10:18,160 --> 00:10:24,580
profile or get notified about operate

00:10:21,550 --> 00:10:26,470
anew in 100 we don't need to do anything

00:10:24,580 --> 00:10:29,410
special which is good because these

00:10:26,470 --> 00:10:31,930
operators may be typed or whatever let's

00:10:29,410 --> 00:10:37,140
just ignore them and just live in a c2c

00:10:31,930 --> 00:10:40,060
world for now a more problematic

00:10:37,140 --> 00:10:42,100
observation is that people when they

00:10:40,060 --> 00:10:44,800
care about performance tend to write

00:10:42,100 --> 00:10:47,830
custom pool elevators and when they

00:10:44,800 --> 00:10:50,470
bypass malloc and free there is

00:10:47,830 --> 00:10:52,450
basically no easy way to get notified

00:10:50,470 --> 00:10:56,440
about that because they then end up

00:10:52,450 --> 00:10:57,820
calling sis codes and most of the

00:10:56,440 --> 00:11:00,490
techniques that I'm going to show you

00:10:57,820 --> 00:11:02,080
now are not applicable to sis call

00:11:00,490 --> 00:11:05,050
tracing you would have to call something

00:11:02,080 --> 00:11:08,200
like P trace or perf trace or so to get

00:11:05,050 --> 00:11:09,700
notified about an mm call if there is

00:11:08,200 --> 00:11:11,050
not the case and anyone knows how to do

00:11:09,700 --> 00:11:12,730
that please tell me I would be very

00:11:11,050 --> 00:11:15,970
interested in learning how to do that

00:11:12,730 --> 00:11:20,700
without petrus good so we'll ignore

00:11:15,970 --> 00:11:22,439
last part for today which brings us to

00:11:20,700 --> 00:11:25,209
[Music]

00:11:22,439 --> 00:11:26,889
right which brings us to freeloading

00:11:25,209 --> 00:11:29,980
this is the first step that we are going

00:11:26,889 --> 00:11:33,310
to talk about I guess most of you know

00:11:29,980 --> 00:11:35,259
what I will show you or maybe you have

00:11:33,310 --> 00:11:38,259
at least heard of this trick called LD

00:11:35,259 --> 00:11:43,240
preload and that one is pretty nice I

00:11:38,259 --> 00:11:45,399
mean you just take some some library you

00:11:43,240 --> 00:11:49,209
need to specify it by its full path

00:11:45,399 --> 00:11:51,370
that's one limitation and you set that

00:11:49,209 --> 00:11:53,529
absolute path to this LD preload

00:11:51,370 --> 00:11:56,319
environment variable and whenever you

00:11:53,529 --> 00:11:58,959
then run any application the linker on

00:11:56,319 --> 00:12:01,300
Linux so LD Linux will see this

00:11:58,959 --> 00:12:03,370
environment variable and see like oh

00:12:01,300 --> 00:12:06,370
cool you want to preload this library as

00:12:03,370 --> 00:12:10,420
you let me do that and now it's as if

00:12:06,370 --> 00:12:13,360
some app was linked dynamically against

00:12:10,420 --> 00:12:16,079
this library that you provided cool

00:12:13,360 --> 00:12:20,170
right that's actually pretty trivial and

00:12:16,079 --> 00:12:23,019
there are some other nice side effects

00:12:20,170 --> 00:12:25,899
here because the dynamic linker is also

00:12:23,019 --> 00:12:30,160
the one that will resolve library cards

00:12:25,899 --> 00:12:33,490
right and well in C++ we have this term

00:12:30,160 --> 00:12:35,740
does this whole ODR concept right but

00:12:33,490 --> 00:12:39,730
this is outside of C++ this is like on

00:12:35,740 --> 00:12:41,920
on the linker level of Linux in this

00:12:39,730 --> 00:12:44,170
case and that one doesn't care about

00:12:41,920 --> 00:12:46,120
audio at all it just looks at oh you

00:12:44,170 --> 00:12:48,129
want to look you want to call malloc

00:12:46,120 --> 00:12:50,559
sure let me look through the list of

00:12:48,129 --> 00:12:54,670
shared libraries and I'll pick the first

00:12:50,559 --> 00:12:56,949
match and LD preload happens to win over

00:12:54,670 --> 00:13:00,399
all of the other dynamically linked

00:12:56,949 --> 00:13:02,860
libraries so that makes it actually

00:13:00,399 --> 00:13:04,509
pretty damn easy to intercept malloc and

00:13:02,860 --> 00:13:07,600
friends we just have to provide

00:13:04,509 --> 00:13:12,670
functions that have the same name cool

00:13:07,600 --> 00:13:17,199
let's see how this goes so we build a

00:13:12,670 --> 00:13:19,449
library with essentially in this case a

00:13:17,199 --> 00:13:24,100
single symbol that is exported so I

00:13:19,449 --> 00:13:26,470
extra see here this malloc will have

00:13:24,100 --> 00:13:29,890
exactly the same mangled symbol like the

00:13:26,470 --> 00:13:34,029
function that I want to trace and now

00:13:29,890 --> 00:13:36,070
when I LD preload that library my Malik

00:13:34,029 --> 00:13:38,260
will be called instead of the real Lipsy

00:13:36,070 --> 00:13:43,690
Malik so that's good already I get

00:13:38,260 --> 00:13:45,550
notified about Malik but well you asked

00:13:43,690 --> 00:13:47,709
for memory right so I still have to

00:13:45,550 --> 00:13:50,200
provide memory otherwise you would just

00:13:47,709 --> 00:13:52,930
crash so what do I do now right this is

00:13:50,200 --> 00:13:55,390
another interesting aspect here um I

00:13:52,930 --> 00:13:56,950
could end up building my own malacca

00:13:55,390 --> 00:13:59,410
implementation but that's obviously a

00:13:56,950 --> 00:14:03,820
bad idea so instead what I end up doing

00:13:59,410 --> 00:14:08,320
is I leverage again nice API that is

00:14:03,820 --> 00:14:11,709
available from the linker I call DLC

00:14:08,320 --> 00:14:16,180
which is part of Lib DL and you need the

00:14:11,709 --> 00:14:20,079
LFC NH header for that part and the l

00:14:16,180 --> 00:14:22,959
sim when you call it with a string asks

00:14:20,079 --> 00:14:25,209
essentially the linker give me back a

00:14:22,959 --> 00:14:30,100
symbol with this name and when you

00:14:25,209 --> 00:14:34,149
parsers are te LD e next flag it will

00:14:30,100 --> 00:14:35,529
skip the current shared object which is

00:14:34,149 --> 00:14:37,000
important because otherwise you would

00:14:35,529 --> 00:14:38,740
find yourself again righty you don't

00:14:37,000 --> 00:14:41,250
want that you want to find the next

00:14:38,740 --> 00:14:45,910
library that happens to implement this

00:14:41,250 --> 00:14:48,190
so pretty cool and what I get back here

00:14:45,910 --> 00:14:50,649
I originally had Auto here but that kind

00:14:48,190 --> 00:14:55,079
of hit an interesting side effect here

00:14:50,649 --> 00:14:58,209
what you get back is a void star so a

00:14:55,079 --> 00:15:02,860
void star but what I want is a function

00:14:58,209 --> 00:15:05,019
pointer to malloc right what anyone in

00:15:02,860 --> 00:15:06,610
the audience knows what C++ standard

00:15:05,019 --> 00:15:10,410
says about function pointers and void

00:15:06,610 --> 00:15:12,820
star pointers are they compatible I

00:15:10,410 --> 00:15:15,279
think what they say it's a platform

00:15:12,820 --> 00:15:17,529
defined or undefined or whatever well on

00:15:15,279 --> 00:15:20,380
POSIX at least it has to be compatible

00:15:17,529 --> 00:15:23,410
because DLC mixes in DL similar returns

00:15:20,380 --> 00:15:24,910
the void star and if it wouldn't be

00:15:23,410 --> 00:15:27,760
compatible you wouldn't be able to do

00:15:24,910 --> 00:15:29,560
anything with Yeltsin so that's cool so

00:15:27,760 --> 00:15:31,660
on Linux at least I definitely can

00:15:29,560 --> 00:15:36,490
reinterpret cast this void star pointer

00:15:31,660 --> 00:15:39,100
to whatever is malloc I just used echo

00:15:36,490 --> 00:15:43,960
type of the malloc function pointer and

00:15:39,100 --> 00:15:46,390
note how I do so this

00:15:43,960 --> 00:15:49,060
she finds myself in this case right but

00:15:46,390 --> 00:15:51,280
I could wrap this in a template or

00:15:49,060 --> 00:15:53,950
whatever make it reusable and then the :

00:15:51,280 --> 00:15:57,970
: Malik would find a global Malik which

00:15:53,950 --> 00:15:59,950
is good so now I get the original

00:15:57,970 --> 00:16:01,570
function back and now it's it's pretty

00:15:59,950 --> 00:16:03,640
trivial did the kind of hooking you do

00:16:01,570 --> 00:16:06,400
then is you just call the original

00:16:03,640 --> 00:16:10,450
function which gives you a pointer back

00:16:06,400 --> 00:16:14,440
and then you can trace it at this stage

00:16:10,450 --> 00:16:16,600
we are just going to print data so we

00:16:14,440 --> 00:16:20,380
just print it to standard out sterilized

00:16:16,600 --> 00:16:22,390
or and we print a size and return

00:16:20,380 --> 00:16:28,030
pointer value and then return the

00:16:22,390 --> 00:16:30,010
original allocated pointer cool and that

00:16:28,030 --> 00:16:35,290
works quite nicely so we can just

00:16:30,010 --> 00:16:37,870
quickly check the test application with

00:16:35,290 --> 00:16:40,720
nm which gives us some insights into the

00:16:37,870 --> 00:16:43,000
symbols of this application and we see

00:16:40,720 --> 00:16:45,070
it does reference Malik but it's

00:16:43,000 --> 00:16:47,320
undefined at this stage right this is my

00:16:45,070 --> 00:16:51,060
application that I want to trace if I

00:16:47,320 --> 00:16:53,920
look at lip see it has a symbol it

00:16:51,060 --> 00:16:58,000
uppercase T means it's actually defined

00:16:53,920 --> 00:17:01,090
within this shared object and the same

00:16:58,000 --> 00:17:05,200
happens for my preload share library

00:17:01,090 --> 00:17:07,930
that I want to put into LD preload so

00:17:05,200 --> 00:17:12,100
now I can write a little script that

00:17:07,930 --> 00:17:14,890
essentially puts my library into LD

00:17:12,100 --> 00:17:17,680
preload that is the interesting part

00:17:14,890 --> 00:17:20,020
really here absolute pass that's

00:17:17,680 --> 00:17:21,880
important and then it passes whatever

00:17:20,020 --> 00:17:26,440
other arguments you you pass to that

00:17:21,880 --> 00:17:28,780
script so now what I can do I have this

00:17:26,440 --> 00:17:31,720
one malach example which really just

00:17:28,780 --> 00:17:33,430
does malloc and free and I compile it

00:17:31,720 --> 00:17:35,140
without compiler optimizations because

00:17:33,430 --> 00:17:37,330
otherwise the compiler would go in and

00:17:35,140 --> 00:17:39,310
say ma that that's crappy code I can

00:17:37,330 --> 00:17:40,210
just remove the buffer altogether you

00:17:39,310 --> 00:17:43,450
don't do anything with it

00:17:40,210 --> 00:17:45,610
so the one Mellark dot cpp i compiled

00:17:43,450 --> 00:17:47,860
without compiler optimizations and then

00:17:45,610 --> 00:17:54,540
i run it through this little preload

00:17:47,860 --> 00:17:54,540
shell script and i see two Malick's

00:17:55,610 --> 00:18:04,280
the first one is pretty large - well

00:17:59,540 --> 00:18:10,160
what we see here is actually part of

00:18:04,280 --> 00:18:13,200
printf because our tracer calls printf

00:18:10,160 --> 00:18:14,850
and we were lucky here because I mean

00:18:13,200 --> 00:18:16,590
usually what you have to do in one of

00:18:14,850 --> 00:18:19,350
these memory locators is to make really

00:18:16,590 --> 00:18:22,110
sure that you either don't call malloc

00:18:19,350 --> 00:18:24,990
again within your tracer or you kind of

00:18:22,110 --> 00:18:28,049
guard against recursion because this

00:18:24,990 --> 00:18:30,150
could easily blow up printf thankfully

00:18:28,049 --> 00:18:33,030
only allocate once a big buffer and then

00:18:30,150 --> 00:18:39,750
it's done so this happens to work cool

00:18:33,030 --> 00:18:43,590
lucky good so we got our code inside we

00:18:39,750 --> 00:18:45,690
injected using LD preload and thanks to

00:18:43,590 --> 00:18:48,179
the dynamic linker we also intercepted

00:18:45,690 --> 00:18:54,660
Mellark that's pretty good

00:18:48,179 --> 00:18:57,000
we got far great um and before I want to

00:18:54,660 --> 00:18:58,590
advance I want to show you another

00:18:57,000 --> 00:19:01,530
little trick and when you write these

00:18:58,590 --> 00:19:05,340
kind in scepters in which helps you in

00:19:01,530 --> 00:19:07,260
debugging is this LD debug equals

00:19:05,340 --> 00:19:11,790
bindings environment variable because

00:19:07,260 --> 00:19:13,530
that tells the dynamic linker to spit

00:19:11,790 --> 00:19:18,049
out some more information to you while

00:19:13,530 --> 00:19:23,790
it resolves functions or symbols and

00:19:18,049 --> 00:19:28,380
what we see here is at first binds lips

00:19:23,790 --> 00:19:31,230
ESO and it finds a normal symbol malloc

00:19:28,380 --> 00:19:35,640
in there that's good and then it binds

00:19:31,230 --> 00:19:40,679
Lib GCC dot s o again Lipsy malloc and

00:19:35,640 --> 00:19:42,690
then lip STD C++ and so forth in this

00:19:40,679 --> 00:19:45,240
case here I didn't preload anything

00:19:42,690 --> 00:19:47,429
right so it's always going to call lips

00:19:45,240 --> 00:19:48,900
e dot esos malloc version so this is

00:19:47,429 --> 00:19:51,990
kind of nice to see what's going on

00:19:48,900 --> 00:19:55,140
behind the scenes and now I'm actually

00:19:51,990 --> 00:19:58,590
pre loading and it looks different

00:19:55,140 --> 00:20:00,990
because now we actually see that in most

00:19:58,590 --> 00:20:05,040
of these cases it's still it's now going

00:20:00,990 --> 00:20:07,710
to use our loop reloaded as dot zero but

00:20:05,040 --> 00:20:08,850
at the area in a very end within our

00:20:07,710 --> 00:20:12,690
preload

00:20:08,850 --> 00:20:15,240
a lip pre-loaded l dot s oh it will

00:20:12,690 --> 00:20:18,690
actually find Malik within lips II and

00:20:15,240 --> 00:20:21,330
that's the DL sim essentially and then

00:20:18,690 --> 00:20:26,100
we get the normal output cool that's

00:20:21,330 --> 00:20:28,710
good great for debugging so now we

00:20:26,100 --> 00:20:30,900
already solved two parts of the problem

00:20:28,710 --> 00:20:34,230
right we are you could say ha man we are

00:20:30,900 --> 00:20:37,500
nearly done 50% done well turns out the

00:20:34,230 --> 00:20:41,970
the really hard part is just about to

00:20:37,500 --> 00:20:44,880
start steak on money has anyone ever

00:20:41,970 --> 00:20:47,130
done custom stack unwinding within C or

00:20:44,880 --> 00:20:51,330
C++ or Fortran application or whatever I

00:20:47,130 --> 00:20:52,890
see two hands go up three great so

00:20:51,330 --> 00:20:55,080
usually not something that you would do

00:20:52,890 --> 00:20:57,240
right it's I mean obviously you can

00:20:55,080 --> 00:20:59,400
throw an exception in it behind the

00:20:57,240 --> 00:21:01,350
scenes that will unwind but when you

00:20:59,400 --> 00:21:03,330
actually want to get the back-trace

00:21:01,350 --> 00:21:04,890
that's completely different right you

00:21:03,330 --> 00:21:08,460
you need some kind of support to

00:21:04,890 --> 00:21:11,610
actually do that and when you look at

00:21:08,460 --> 00:21:14,550
how to do that oh boy does it get

00:21:11,610 --> 00:21:17,520
complicated quickly um there different

00:21:14,550 --> 00:21:20,160
approaches the best one if at all

00:21:17,520 --> 00:21:22,320
possible is relying on frame pointers

00:21:20,160 --> 00:21:24,770
this is fast as well as stablished it's

00:21:22,320 --> 00:21:28,470
very easy to understand what's going on

00:21:24,770 --> 00:21:32,250
but on pretty much all Linux

00:21:28,470 --> 00:21:35,010
distributions by default and well within

00:21:32,250 --> 00:21:39,210
GCC and clung by default everything is

00:21:35,010 --> 00:21:41,880
compiled with - F omit - frame - pointer

00:21:39,210 --> 00:21:44,610
so if you want to use frame pointers you

00:21:41,880 --> 00:21:48,780
have to pass - f no omit frame pointer

00:21:44,610 --> 00:21:51,450
and if you want to allocate malloc for

00:21:48,780 --> 00:21:54,360
example you have to make sure that your

00:21:51,450 --> 00:21:55,980
real malloc actually is compiled with

00:21:54,360 --> 00:21:58,470
frame pointers because otherwise or

00:21:55,980 --> 00:21:59,970
basically anything inside your back

00:21:58,470 --> 00:22:02,490
trace needs to be compatible at frame

00:21:59,970 --> 00:22:03,930
pointers because otherwise as soon as

00:22:02,490 --> 00:22:05,750
you hit any frame without a frame

00:22:03,930 --> 00:22:08,730
pointer your back dress will break and

00:22:05,750 --> 00:22:11,760
it starts become very confusing - to

00:22:08,730 --> 00:22:13,830
analyze the results so turns out frame

00:22:11,760 --> 00:22:16,050
pointers is basically unusable if you

00:22:13,830 --> 00:22:18,870
look at the documentation of Lipsey's

00:22:16,050 --> 00:22:21,120
back-trace function which well as the

00:22:18,870 --> 00:22:23,220
name says gives you a back trace it kind

00:22:21,120 --> 00:22:27,210
of says it relies on the frame

00:22:23,220 --> 00:22:29,030
so Lipsey's back-trace is not usable or

00:22:27,210 --> 00:22:32,640
you have to recompile your whole system

00:22:29,030 --> 00:22:34,970
so Jen two people or a Yocto based this

00:22:32,640 --> 00:22:38,700
ruse you could probably pull this off

00:22:34,970 --> 00:22:41,610
but that's not us so instead what we

00:22:38,700 --> 00:22:43,920
need to do is we need to unwind just

00:22:41,610 --> 00:22:46,940
like an exception would unwind that's

00:22:43,920 --> 00:22:51,930
doable there are these da th frame

00:22:46,940 --> 00:22:56,070
sections for x86 or the arm exid egg

00:22:51,930 --> 00:22:57,930
section for um and there what one

00:22:56,070 --> 00:23:00,600
further alternative would be relying on

00:22:57,930 --> 00:23:03,120
the debug frame section inside the 12

00:23:00,600 --> 00:23:05,430
debug information that's our cool that's

00:23:03,120 --> 00:23:07,320
possible and it turns out to be really

00:23:05,430 --> 00:23:09,960
really hard to do that because

00:23:07,320 --> 00:23:12,650
essentially you have I believe more less

00:23:09,960 --> 00:23:15,270
turing-complete state machine within

00:23:12,650 --> 00:23:17,370
these kind of exception debug

00:23:15,270 --> 00:23:20,130
information or in within these unwind

00:23:17,370 --> 00:23:22,650
tables so interpreting that just to get

00:23:20,130 --> 00:23:26,370
a back-trace happens to be quite complex

00:23:22,650 --> 00:23:29,850
and that's also why exceptions being

00:23:26,370 --> 00:23:31,770
thrown is well zero cost when you don't

00:23:29,850 --> 00:23:33,870
throw them but as soon as you throw

00:23:31,770 --> 00:23:36,690
exceptions a lot it's done to be very

00:23:33,870 --> 00:23:42,060
very very very slow so don't do that in

00:23:36,690 --> 00:23:44,550
in hot loop so we'll have to figure out

00:23:42,060 --> 00:23:47,220
how to do that and some alternatives

00:23:44,550 --> 00:23:50,280
would be until last branch record or

00:23:47,220 --> 00:23:52,560
shadow stack I'm not going into detail

00:23:50,280 --> 00:23:55,050
there if you want to look at that google

00:23:52,560 --> 00:23:58,890
it up were dropped by the shadow stack

00:23:55,050 --> 00:24:03,290
page it's kind of interesting so it's an

00:23:58,890 --> 00:24:07,890
active field of study on what to do here

00:24:03,290 --> 00:24:10,260
right so Lipsey's back trace depends on

00:24:07,890 --> 00:24:12,900
frame pointer so it's unusable there's a

00:24:10,260 --> 00:24:15,900
few tools as a cool library we'll use

00:24:12,900 --> 00:24:17,760
that in a bit too but it's super complex

00:24:15,900 --> 00:24:19,680
to use that for unwinding I believe you

00:24:17,760 --> 00:24:22,680
could somehow manage to make it work but

00:24:19,680 --> 00:24:25,440
the API that there is right now is

00:24:22,680 --> 00:24:29,610
mostly meant for unwinding from within a

00:24:25,440 --> 00:24:31,770
different application so you this use

00:24:29,610 --> 00:24:34,500
case where you get a stack copy and then

00:24:31,770 --> 00:24:36,180
want to unwind that stack copy on a

00:24:34,500 --> 00:24:36,809
completely different machine so for that

00:24:36,180 --> 00:24:38,820
case it would be

00:24:36,809 --> 00:24:40,830
kind of cool to you stand but if you

00:24:38,820 --> 00:24:43,350
just want to get back trace within your

00:24:40,830 --> 00:24:44,999
application lip unwind and with lip

00:24:43,350 --> 00:24:46,470
unwind I mean this specifically when

00:24:44,999 --> 00:24:48,659
went because they're quite a few

00:24:46,470 --> 00:24:50,909
libraries that have the same name not

00:24:48,659 --> 00:24:54,480
the lip unwinding GCC not the lip unwind

00:24:50,909 --> 00:24:56,730
inclined no this lip unwind that one is

00:24:54,480 --> 00:24:58,590
super easy to use it's extremely fast

00:24:56,730 --> 00:25:02,399
because it does tons of tons of tech

00:24:58,590 --> 00:25:05,039
caching behind behind the scenes and

00:25:02,399 --> 00:25:08,179
it's also very very feature-rich so it

00:25:05,039 --> 00:25:12,299
supports all kinds of things like

00:25:08,179 --> 00:25:15,360
compress debug sections split debug

00:25:12,299 --> 00:25:18,629
sections whatnot arm

00:25:15,360 --> 00:25:20,909
MIPS you name it and using that is

00:25:18,629 --> 00:25:23,549
actually trivial like instead of back

00:25:20,909 --> 00:25:26,190
trace you just call unwind back trace oh

00:25:23,549 --> 00:25:29,279
yeah and by the way do define this group

00:25:26,190 --> 00:25:33,929
I don't want to show that one yet define

00:25:29,279 --> 00:25:35,909
this unwind local only before including

00:25:33,929 --> 00:25:40,230
lib unwind then it becomes magically

00:25:35,909 --> 00:25:43,350
faster and then you can just call unwind

00:25:40,230 --> 00:25:47,490
back trace fill that into some buffer

00:25:43,350 --> 00:25:49,529
and leverage that so that's trivial and

00:25:47,490 --> 00:25:52,830
the cool thing about that is this unwind

00:25:49,529 --> 00:25:55,350
back trace is super fast right one of

00:25:52,830 --> 00:25:57,059
the key blocking steps for me to write

00:25:55,350 --> 00:26:00,149
something I keep track couple of years

00:25:57,059 --> 00:26:03,539
ago was not knowing how to do unwinding

00:26:00,149 --> 00:26:06,029
a lot and with Lib unwind this is doable

00:26:03,539 --> 00:26:08,159
like it's it's it's trivial even and

00:26:06,029 --> 00:26:09,629
that's what I mean what demystifying how

00:26:08,159 --> 00:26:12,299
these kind of tools work right when you

00:26:09,629 --> 00:26:16,230
know the right building blocks it starts

00:26:12,299 --> 00:26:18,570
to become trivial to build them cool so

00:26:16,230 --> 00:26:22,409
that's a very important step we can plug

00:26:18,570 --> 00:26:26,700
that into our preload mechanism right

00:26:22,409 --> 00:26:29,759
and now whenever run this on application

00:26:26,700 --> 00:26:30,179
I get a back trace what's the problem

00:26:29,759 --> 00:26:34,320
here

00:26:30,179 --> 00:26:37,049
a couple people laugh I think you get

00:26:34,320 --> 00:26:38,549
the point right like it's this can you

00:26:37,049 --> 00:26:40,919
give me a pointer in someone replies

00:26:38,549 --> 00:26:44,650
with yeah obviously I can Oh X that be

00:26:40,919 --> 00:26:48,549
found haha so funny you can't make any

00:26:44,650 --> 00:26:51,360
sends out of it right the core problem

00:26:48,549 --> 00:26:54,220
now becomes actually symbolizing these

00:26:51,360 --> 00:26:57,039
pointers because otherwise once again

00:26:54,220 --> 00:26:58,870
you got to stop a step further but hit

00:26:57,039 --> 00:27:03,880
yet another wall right because no one

00:26:58,870 --> 00:27:07,470
can make use of this SS cool which

00:27:03,880 --> 00:27:12,549
brings us to yet another section on

00:27:07,470 --> 00:27:14,770
symbol resolution I'll give a rough

00:27:12,549 --> 00:27:18,309
introduction and then go into details

00:27:14,770 --> 00:27:21,429
theory because it happens to be yeah

00:27:18,309 --> 00:27:23,350
quite a hairy situation the digger we

00:27:21,429 --> 00:27:26,289
deep the more complicated kind of

00:27:23,350 --> 00:27:30,029
becomes but at the end I hope to show

00:27:26,289 --> 00:27:34,539
you some some usable results there cool

00:27:30,029 --> 00:27:37,320
let's start the goal really is once

00:27:34,539 --> 00:27:40,270
again to take a point value and

00:27:37,320 --> 00:27:43,779
translate it to human readers readable

00:27:40,270 --> 00:27:46,750
symbol and because this is CPP con I I

00:27:43,779 --> 00:27:49,029
couldn't get away with this chance and

00:27:46,750 --> 00:27:55,299
not using it a human readable symbol

00:27:49,029 --> 00:27:59,049
right that is a single symbol that's not

00:27:55,299 --> 00:28:01,090
ten of them that is one symbol could

00:27:59,049 --> 00:28:03,010
anyone guess what this is because when

00:28:01,090 --> 00:28:07,090
you write it it's actually kind of tiny

00:28:03,010 --> 00:28:09,309
I guess it's stood map something right

00:28:07,090 --> 00:28:11,770
well if you would apply some kind of

00:28:09,309 --> 00:28:15,850
heuristics to it and replace the type

00:28:11,770 --> 00:28:17,860
devs in there you end up with this it's

00:28:15,850 --> 00:28:22,210
a stock map of a string to a vector of a

00:28:17,860 --> 00:28:25,870
map of into strings hmm what happened

00:28:22,210 --> 00:28:28,029
here right I mean who well tag deaths

00:28:25,870 --> 00:28:30,250
happened right and at the level of the

00:28:28,029 --> 00:28:32,610
linker the type tips don't exist anymore

00:28:30,250 --> 00:28:35,649
and you only see whatever got resolved

00:28:32,610 --> 00:28:37,899
to the end so keep this in mind because

00:28:35,649 --> 00:28:41,080
once we want to do D mangling we want to

00:28:37,899 --> 00:28:43,659
do we won't want to do something like

00:28:41,080 --> 00:28:45,640
that our selves right once again we need

00:28:43,659 --> 00:28:48,279
to look for a solution that does this

00:28:45,640 --> 00:28:53,159
kind of stuff was because parsing that

00:28:48,279 --> 00:28:55,790
would otherwise be a nightmare cool so

00:28:53,159 --> 00:28:58,340
you're doing yet again

00:28:55,790 --> 00:29:00,950
if you would want to go from the huge

00:28:58,340 --> 00:29:04,070
symbol to the tiny symbol this actually

00:29:00,950 --> 00:29:05,990
requires heuristics because the type

00:29:04,070 --> 00:29:08,300
test will change based on your STL

00:29:05,990 --> 00:29:11,540
implementation maybe even the version of

00:29:08,300 --> 00:29:14,180
the STL so we won't talk about how to do

00:29:11,540 --> 00:29:15,980
that today hotspot has one way to do

00:29:14,180 --> 00:29:20,750
that based on some heuristics for I

00:29:15,980 --> 00:29:22,400
believe GCC slip STD is C++ but you

00:29:20,750 --> 00:29:31,460
could apply the same tricks to other

00:29:22,400 --> 00:29:35,330
libraries okay now a core concept that

00:29:31,460 --> 00:29:36,680
you need to grasp is that on Linux by

00:29:35,330 --> 00:29:39,500
default you get address based

00:29:36,680 --> 00:29:41,870
randomization right and you get come

00:29:39,500 --> 00:29:44,150
when you compile a shared object it is

00:29:41,870 --> 00:29:47,900
compiled in a position independent way

00:29:44,150 --> 00:29:50,660
that means symbols aren't represented by

00:29:47,900 --> 00:29:52,610
the absolute address at which they will

00:29:50,660 --> 00:29:55,940
show up in your application but rather

00:29:52,610 --> 00:29:59,900
they somehow are billed in a way that

00:29:55,940 --> 00:30:01,700
they like you you encode an offset to

00:29:59,900 --> 00:30:05,180
wherever the shared library gets mapped

00:30:01,700 --> 00:30:07,010
into your address space basically so we

00:30:05,180 --> 00:30:09,500
need to do the reverse because when we

00:30:07,010 --> 00:30:12,610
want to find out a symbol we need to

00:30:09,500 --> 00:30:16,340
know this offset to our shared library

00:30:12,610 --> 00:30:21,080
so what we do is essentially is we look

00:30:16,340 --> 00:30:24,740
into the mappings of our application for

00:30:21,080 --> 00:30:26,650
now I will use the proc meta file system

00:30:24,740 --> 00:30:30,110
or whatever you call that

00:30:26,650 --> 00:30:31,490
it's easy to get the point across but in

00:30:30,110 --> 00:30:35,930
a bit I'll show you a different way to

00:30:31,490 --> 00:30:38,690
do that so within that file system you

00:30:35,930 --> 00:30:40,340
find this maps file and there you can

00:30:38,690 --> 00:30:41,750
see all of the shared libraries and

00:30:40,340 --> 00:30:44,390
where they get mapped to maybe even

00:30:41,750 --> 00:30:46,490
other files that are not executable and

00:30:44,390 --> 00:30:48,650
and whatnot and now you essentially need

00:30:46,490 --> 00:30:51,740
to do a lookup into this table to find

00:30:48,650 --> 00:30:54,970
the map and you need to take the first

00:30:51,740 --> 00:30:59,540
address so essentially here it's this

00:30:54,970 --> 00:31:01,640
first address that at the left top left

00:30:59,540 --> 00:31:04,280
of this block this is what you need to

00:31:01,640 --> 00:31:07,750
use as your base address use a sub

00:31:04,280 --> 00:31:09,650
subtract that from your input

00:31:07,750 --> 00:31:13,580
instruction pointer address

00:31:09,650 --> 00:31:16,070
to get an offset so this oh XD 9f that

00:31:13,580 --> 00:31:21,170
is our offset this now we can actually

00:31:16,070 --> 00:31:22,910
use to get the cymbal back great because

00:31:21,170 --> 00:31:25,930
with this value we can actually ask

00:31:22,910 --> 00:31:30,680
adder to line or a similar tool to

00:31:25,930 --> 00:31:31,960
symbolize us or give us information back

00:31:30,680 --> 00:31:35,180
about the cymbal

00:31:31,960 --> 00:31:37,910
so what we start off with is iron - line

00:31:35,180 --> 00:31:41,059
- P to make it human readable in some

00:31:37,910 --> 00:31:44,420
sense and then - either the path to the

00:31:41,059 --> 00:31:46,670
library or executable and then - a and

00:31:44,420 --> 00:31:50,270
offset into this library for which you

00:31:46,670 --> 00:31:53,170
want to see some tangible symbol results

00:31:50,270 --> 00:31:56,390
back and this is what you get by default

00:31:53,170 --> 00:31:58,820
which is as the name says the address

00:31:56,390 --> 00:32:01,070
and the line so line and file number

00:31:58,820 --> 00:32:03,920
which is good but it's not really what

00:32:01,070 --> 00:32:06,820
we need or not enough we also need

00:32:03,920 --> 00:32:11,179
functions so well yeah let's past - F

00:32:06,820 --> 00:32:14,390
and - F gives us in this case a mangled

00:32:11,179 --> 00:32:17,870
name for whatever right it's yet again

00:32:14,390 --> 00:32:21,890
not very readable so we have to pass - C

00:32:17,870 --> 00:32:23,450
to actually make it D mangle the symbol

00:32:21,890 --> 00:32:25,540
and now the symbol becomes so large that

00:32:23,450 --> 00:32:27,890
it doesn't fit the slide anymore so I

00:32:25,540 --> 00:32:29,690
cut it down it's it's a different symbol

00:32:27,890 --> 00:32:31,490
than the one before it's not as bad but

00:32:29,690 --> 00:32:38,120
it's already I think spanning three

00:32:31,490 --> 00:32:42,410
lines or so so this is good but turns

00:32:38,120 --> 00:32:45,020
out it's still not enough we are writing

00:32:42,410 --> 00:32:48,260
C++ we are using abstractions all over

00:32:45,020 --> 00:32:50,600
the place right and one of the core

00:32:48,260 --> 00:32:53,840
principles to make these abstractions

00:32:50,600 --> 00:32:57,500
cheap to a certain degree is inlining

00:32:53,840 --> 00:32:59,450
and if you symbolize a back-trace

00:32:57,500 --> 00:33:01,550
without taking inline frames into

00:32:59,450 --> 00:33:03,740
account you will have a very very very

00:33:01,550 --> 00:33:06,050
very hard time and figuring out what the

00:33:03,740 --> 00:33:08,840
hell's going on because it will start

00:33:06,050 --> 00:33:12,679
look like in main you are calling some

00:33:08,840 --> 00:33:14,330
internal lips c plus plus function and

00:33:12,679 --> 00:33:15,710
you're like scratching ahead and

00:33:14,330 --> 00:33:16,820
wondering where the hell did I write

00:33:15,710 --> 00:33:18,980
this I didn't do that

00:33:16,820 --> 00:33:20,720
well you didn't but you called some

00:33:18,980 --> 00:33:23,300
function which was in line which was in

00:33:20,720 --> 00:33:25,880
line which was in night and there

00:33:23,300 --> 00:33:28,700
is then this final call so we need to

00:33:25,880 --> 00:33:31,340
resolve in lines two and this is the - I

00:33:28,700 --> 00:33:35,720
parameter to address to line and now

00:33:31,340 --> 00:33:38,300
we're starting to get there problem is

00:33:35,720 --> 00:33:41,270
if you would call added to line for

00:33:38,300 --> 00:33:44,090
every single instruction pointer offset

00:33:41,270 --> 00:33:46,190
you get back from your tracer it doesn't

00:33:44,090 --> 00:33:48,080
scale it's super slow there are some

00:33:46,190 --> 00:33:50,960
tricks like passing multiple address

00:33:48,080 --> 00:33:52,550
offsets in one go but really what we

00:33:50,960 --> 00:33:54,320
wanted to is we kind of want to

00:33:52,550 --> 00:33:58,630
re-implement energy line for our

00:33:54,320 --> 00:33:58,630
specific use case so let's do that

00:33:58,790 --> 00:34:05,630
first off how do we find elf mappings

00:34:01,460 --> 00:34:07,850
without having to parse proc map that's

00:34:05,630 --> 00:34:10,760
actually trivial once more thanks to

00:34:07,850 --> 00:34:15,230
this little gem called DL iterate P

00:34:10,760 --> 00:34:18,860
header again part of Lib DL you call it

00:34:15,230 --> 00:34:21,710
you can pass it a see pointer or non

00:34:18,860 --> 00:34:24,230
capturing lambda and then with within

00:34:21,710 --> 00:34:27,860
that function you just check what is the

00:34:24,230 --> 00:34:30,440
name of this P header info struct

00:34:27,860 --> 00:34:32,570
if it's empty for some reason it's empty

00:34:30,440 --> 00:34:34,340
for the main executable you just power

00:34:32,570 --> 00:34:37,010
something back out and then later on you

00:34:34,340 --> 00:34:39,350
can map it back to the real path to the

00:34:37,010 --> 00:34:44,740
executable I quite frankly don't get why

00:34:39,350 --> 00:34:50,090
this value is empty but it is and then

00:34:44,740 --> 00:34:52,190
we just output the dlp I address which

00:34:50,090 --> 00:34:54,320
is the base address where the shared

00:34:52,190 --> 00:34:56,840
library got linked to cool so this is

00:34:54,320 --> 00:35:00,920
essentially pausing proc maps and we

00:34:56,840 --> 00:35:03,530
once again we don't actually map during

00:35:00,920 --> 00:35:05,450
profiling we delay this into the post

00:35:03,530 --> 00:35:07,850
processing step and it's quite important

00:35:05,450 --> 00:35:09,590
for performance while recording we just

00:35:07,850 --> 00:35:12,290
get back traces and then in a post

00:35:09,590 --> 00:35:14,630
processing process post processing step

00:35:12,290 --> 00:35:16,400
we take the instruction pointers

00:35:14,630 --> 00:35:22,040
translate them using this mapping and

00:35:16,400 --> 00:35:23,930
then rinse repeat cool obviously when we

00:35:22,040 --> 00:35:26,840
want to do this in our LD preload

00:35:23,930 --> 00:35:29,210
library we now need to take care of DL

00:35:26,840 --> 00:35:31,700
open and deal close because whenever you

00:35:29,210 --> 00:35:33,920
have plugin systems in your applications

00:35:31,700 --> 00:35:36,080
they make all deal open it basically

00:35:33,920 --> 00:35:36,680
anytime and when that happens your

00:35:36,080 --> 00:35:38,540
address

00:35:36,680 --> 00:35:41,650
face may change or the mappings may

00:35:38,540 --> 00:35:44,510
change so you need to update those and

00:35:41,650 --> 00:35:47,569
this example preload mappings that it's

00:35:44,510 --> 00:35:50,569
age dusters it also resolves the

00:35:47,569 --> 00:35:53,930
executable farm using stood file system

00:35:50,569 --> 00:35:57,230
canonical on proc self exome and now we

00:35:53,930 --> 00:36:00,230
can put it all together and get this

00:35:57,230 --> 00:36:02,270
output for example so this is what you

00:36:00,230 --> 00:36:04,940
do at record time you just output the

00:36:02,270 --> 00:36:07,970
modules whenever they changed and then

00:36:04,940 --> 00:36:13,040
you trace malloc and free in output back

00:36:07,970 --> 00:36:14,750
traces this is recording and now we need

00:36:13,040 --> 00:36:19,460
to use this information to actually

00:36:14,750 --> 00:36:22,430
symbolize and for that we use Alf utils

00:36:19,460 --> 00:36:25,760
great library I love it happens to be

00:36:22,430 --> 00:36:27,500
written in C horrible to extend for

00:36:25,760 --> 00:36:33,440
someone who doesn't like to write C but

00:36:27,500 --> 00:36:35,569
kind of cool to use though so doing

00:36:33,440 --> 00:36:37,730
similar resolutions nearly as complex is

00:36:35,569 --> 00:36:39,829
getting the back-trace because once

00:36:37,730 --> 00:36:42,980
again you need to look at a symbol table

00:36:39,829 --> 00:36:44,750
you need to take compress debug

00:36:42,980 --> 00:36:48,349
information into account split debug

00:36:44,750 --> 00:36:51,500
info you name and lip DW FL does all of

00:36:48,349 --> 00:36:53,299
this for us so let's leverage that let's

00:36:51,500 --> 00:36:56,900
build on the top on the shoulders of

00:36:53,299 --> 00:37:01,010
giants pretty trivial setup you need to

00:36:56,900 --> 00:37:03,200
define a couple of default callbacks so

00:37:01,010 --> 00:37:06,109
I didn't write them I just assign them

00:37:03,200 --> 00:37:07,280
into this callback struct I passed that

00:37:06,109 --> 00:37:11,480
one too

00:37:07,280 --> 00:37:14,450
DW FL begin and then when I'm done I

00:37:11,480 --> 00:37:18,609
call g WF l and so this is my

00:37:14,450 --> 00:37:21,980
boilerplate setup code and then I can

00:37:18,609 --> 00:37:24,710
report elf mappings so this is now

00:37:21,980 --> 00:37:27,440
essentially taking the output from DL

00:37:24,710 --> 00:37:30,440
iterate P header and whenever I see

00:37:27,440 --> 00:37:32,869
module I call report or begin report

00:37:30,440 --> 00:37:34,579
then I report all the modules and then I

00:37:32,869 --> 00:37:37,280
call and report and this essentially

00:37:34,579 --> 00:37:41,420
updates the internal mappings within DW

00:37:37,280 --> 00:37:45,260
FL such that then finally we can

00:37:41,420 --> 00:37:47,630
actually similar stuff doing that

00:37:45,260 --> 00:37:49,470
essentially means we take the

00:37:47,630 --> 00:37:53,220
instruction pointer so this is

00:37:49,470 --> 00:37:59,270
UN 6040 in this case of an named

00:37:53,220 --> 00:38:02,089
IP we asked DW FL for the module that

00:37:59,270 --> 00:38:05,940
contains this instruction pointer and

00:38:02,089 --> 00:38:08,040
maybe it doesn't find something we have

00:38:05,940 --> 00:38:10,050
to deal with that but if it does find

00:38:08,040 --> 00:38:12,720
something we can now actually fill the

00:38:10,050 --> 00:38:15,480
symbol struct and set these Oh

00:38:12,720 --> 00:38:17,849
information or symbol information in

00:38:15,480 --> 00:38:20,700
foul line information so let's go

00:38:17,849 --> 00:38:24,150
through these three steps first one

00:38:20,700 --> 00:38:26,099
dears Oh info means what is the name of

00:38:24,150 --> 00:38:29,069
the dynamically shape object or

00:38:26,099 --> 00:38:32,069
executable and what is the offset of the

00:38:29,069 --> 00:38:33,930
symbol within so this is like the offset

00:38:32,069 --> 00:38:37,920
is this parameter that you would have

00:38:33,930 --> 00:38:39,450
passed to error to line right so this is

00:38:37,920 --> 00:38:42,440
already kind of interesting but

00:38:39,450 --> 00:38:45,900
obviously not the most important stuff

00:38:42,440 --> 00:38:48,300
more important is resolving the actual

00:38:45,900 --> 00:38:52,980
symbol name and it's pretty trivial with

00:38:48,300 --> 00:38:56,190
DW FL - you call this module header info

00:38:52,980 --> 00:38:57,720
and I don't know about you but just

00:38:56,190 --> 00:39:00,780
looking at function calls like that I

00:38:57,720 --> 00:39:03,030
really love that we can write C++ with

00:39:00,780 --> 00:39:05,250
default arguments you can't do that in C

00:39:03,030 --> 00:39:09,450
so you always have to pass null pointer

00:39:05,250 --> 00:39:11,609
for optional arguments but well we get a

00:39:09,450 --> 00:39:12,930
symbol name back we can use that cool

00:39:11,609 --> 00:39:16,950
that's good already

00:39:12,930 --> 00:39:19,440
oh and by the way we also get the symbol

00:39:16,950 --> 00:39:21,300
offset so this would be like the offset

00:39:19,440 --> 00:39:25,290
of this instruction to the beginning of

00:39:21,300 --> 00:39:30,119
my my function entry may be interesting

00:39:25,290 --> 00:39:30,630
too and now we can rinse repeat cause

00:39:30,119 --> 00:39:35,069
some

00:39:30,630 --> 00:39:39,359
DW FL functions to get the so called die

00:39:35,069 --> 00:39:43,020
which is the debug information entry and

00:39:39,359 --> 00:39:44,910
this is a dwarf struct so dwarf is the

00:39:43,020 --> 00:39:47,339
name of the debug information format on

00:39:44,910 --> 00:39:51,180
on Linux and probably quite a few piece

00:39:47,339 --> 00:39:55,890
too and that one you can pass to lip

00:39:51,180 --> 00:39:59,220
dwarf to get the actual file and line

00:39:55,890 --> 00:40:02,240
number and column cool so we're getting

00:39:59,220 --> 00:40:02,240
close because

00:40:02,480 --> 00:40:10,369
when we when we get this symbol here

00:40:07,119 --> 00:40:12,020
it's actually mangled right and I showed

00:40:10,369 --> 00:40:14,150
it to you earlier with the adder to line

00:40:12,020 --> 00:40:16,280
we also have two demon mangle and it's

00:40:14,150 --> 00:40:22,460
yet again pretty trivial thankfully

00:40:16,280 --> 00:40:26,869
because there's this maybe a bi specific

00:40:22,460 --> 00:40:28,490
implementation of doing demanding so C++

00:40:26,869 --> 00:40:30,950
filled isn't executable you could use

00:40:28,490 --> 00:40:33,829
for that but once again it's too costly

00:40:30,950 --> 00:40:39,500
to spawn a new process for every symbol

00:40:33,829 --> 00:40:42,859
instead we include this cxx ABI header

00:40:39,500 --> 00:40:45,380
which happens to have a function with

00:40:42,859 --> 00:40:47,780
two underscores you should you're not

00:40:45,380 --> 00:40:49,640
supposed to use that right well better

00:40:47,780 --> 00:40:52,220
than writing my own deeming layer I hope

00:40:49,640 --> 00:40:55,820
the first example where I showed this

00:40:52,220 --> 00:40:59,540
full page of a single symbol explains

00:40:55,820 --> 00:41:02,270
why I'm using a reserved function here

00:40:59,540 --> 00:41:05,359
and this works nicely and now I finally

00:41:02,270 --> 00:41:08,420
can put it all together to get a

00:41:05,359 --> 00:41:12,740
symbolized back trace already so here on

00:41:08,420 --> 00:41:15,349
the top you see me running the running

00:41:12,740 --> 00:41:17,359
the preload step and then I pass it

00:41:15,349 --> 00:41:18,819
directly into my symbolize err so this

00:41:17,359 --> 00:41:24,079
is like these these two steps right

00:41:18,819 --> 00:41:27,859
recording and then reporting good but

00:41:24,079 --> 00:41:31,640
it's missing inline frames and to

00:41:27,859 --> 00:41:35,270
exemplify this here at the bottom we

00:41:31,640 --> 00:41:37,760
have the function main within the

00:41:35,270 --> 00:41:41,359
executable test client vectors so this

00:41:37,760 --> 00:41:44,030
is good but apparently function main

00:41:41,359 --> 00:41:48,410
lives within user include blah blah blah

00:41:44,030 --> 00:41:50,480
vector dot C TCC line 121 no that's not

00:41:48,410 --> 00:41:52,880
the case and this is the effect of the

00:41:50,480 --> 00:41:55,250
in liner right I call the function from

00:41:52,880 --> 00:41:57,349
stood vector which got in lined into

00:41:55,250 --> 00:41:58,849
main and it makes it very hard and

00:41:57,349 --> 00:41:59,210
complex to understand what's going on

00:41:58,849 --> 00:42:04,790
here

00:41:59,210 --> 00:42:05,230
if you ignore inline frames so let's do

00:42:04,790 --> 00:42:10,640
that

00:42:05,230 --> 00:42:12,770
whoo I hope you still with me this

00:42:10,640 --> 00:42:15,859
happens to be the worst part of it all I

00:42:12,770 --> 00:42:18,680
believe because now we're in this realm

00:42:15,859 --> 00:42:21,140
of dwarfs and else and I happen to like

00:42:18,680 --> 00:42:23,420
read I really like to read fantasy but I

00:42:21,140 --> 00:42:28,190
don't like to read the code that I'm

00:42:23,420 --> 00:42:30,380
about to write well we have to start

00:42:28,190 --> 00:42:32,599
with finding the so called compilation

00:42:30,380 --> 00:42:34,460
unit debug information entry cootie or

00:42:32,599 --> 00:42:38,089
cout dial whatever it's pronounced in

00:42:34,460 --> 00:42:40,670
English okay so far so good I don't

00:42:38,089 --> 00:42:43,420
really know why but that happens to be

00:42:40,670 --> 00:42:49,220
the place where I need to look and then

00:42:43,420 --> 00:42:52,099
with this code I I can call dwarf get

00:42:49,220 --> 00:42:54,710
scopes and it essentially kinda gives me

00:42:52,099 --> 00:42:57,109
a list of in nine frames and probably

00:42:54,710 --> 00:42:57,980
more but I'll gloss over that for now

00:42:57,109 --> 00:43:02,329
sorry about that

00:42:57,980 --> 00:43:04,549
and actually even worse I'll just use

00:43:02,329 --> 00:43:07,039
the first scope that is being returned

00:43:04,549 --> 00:43:08,930
because it turns out that it's not

00:43:07,039 --> 00:43:11,180
really the in nine frames but just part

00:43:08,930 --> 00:43:14,779
of it I don't really understand it I'm

00:43:11,180 --> 00:43:17,059
sorry but this happens to work and I'm

00:43:14,779 --> 00:43:20,359
essentially getting out the first scope

00:43:17,059 --> 00:43:25,519
of the kurai for this address that I

00:43:20,359 --> 00:43:26,299
passed and now using this first scope

00:43:25,519 --> 00:43:30,559
die

00:43:26,299 --> 00:43:33,200
I can call dwarf get scopes die so here

00:43:30,559 --> 00:43:37,279
it's dwarf get scopes he it's twelve

00:43:33,200 --> 00:43:41,180
kidzcope die okay whatever this works

00:43:37,279 --> 00:43:43,549
cool and these scopes actually contain

00:43:41,180 --> 00:43:46,849
the inline frames right finally we're

00:43:43,549 --> 00:43:50,059
getting there now we get need to query

00:43:46,849 --> 00:43:52,309
the file information so embedded files

00:43:50,059 --> 00:43:55,220
that got compiled into this translation

00:43:52,309 --> 00:43:59,749
unit and I can iterate over our scopes

00:43:55,220 --> 00:44:02,180
find those scopes that are in mind so

00:43:59,749 --> 00:44:03,710
representing an inline subroutine using

00:44:02,180 --> 00:44:05,900
the stack I can distinguish between

00:44:03,710 --> 00:44:08,420
those and this is now the interesting

00:44:05,900 --> 00:44:13,730
bits these are the symbols that got in

00:44:08,420 --> 00:44:17,390
line so let's use them let's build a

00:44:13,730 --> 00:44:19,279
similar resolution for that yet again I

00:44:17,390 --> 00:44:20,749
need I can't really use a ready-made

00:44:19,279 --> 00:44:23,900
solution I need to build some

00:44:20,749 --> 00:44:25,759
boilerplate code the gist here is using

00:44:23,900 --> 00:44:28,910
this kind of function I get the symbol

00:44:25,759 --> 00:44:29,530
name the mangled symbol name for an

00:44:28,910 --> 00:44:35,140
inland

00:44:29,530 --> 00:44:36,880
so this is good and now I can ask about

00:44:35,140 --> 00:44:39,460
more information so essentially this

00:44:36,880 --> 00:44:42,670
inline subroutine symbol called just

00:44:39,460 --> 00:44:46,210
asks for the die name so this was the

00:44:42,670 --> 00:44:48,760
previous slide and then using some hacky

00:44:46,210 --> 00:44:50,500
well it looks hacky but apparently

00:44:48,760 --> 00:44:53,290
that's the clean way to do that it

00:44:50,500 --> 00:44:57,180
called it asks for the place where this

00:44:53,290 --> 00:44:59,680
inline function was called from and I

00:44:57,180 --> 00:45:01,900
have to admit when I looked at this

00:44:59,680 --> 00:45:03,670
slide over lunch today I realized that

00:45:01,900 --> 00:45:07,240
there's a buck in the implementation now

00:45:03,670 --> 00:45:11,200
because the symbol name that I asked for

00:45:07,240 --> 00:45:13,300
before that doesn't belong to the source

00:45:11,200 --> 00:45:16,960
line information that I'm querying below

00:45:13,300 --> 00:45:19,990
so there's like a as the name says it's

00:45:16,960 --> 00:45:22,420
the colleague I get information about

00:45:19,990 --> 00:45:26,080
the collie not about this symbol but the

00:45:22,420 --> 00:45:27,910
next symbol in hot spot and heap drag

00:45:26,080 --> 00:45:29,950
this is done properly but when I built

00:45:27,910 --> 00:45:32,440
this standalone example I introduced

00:45:29,950 --> 00:45:34,960
this bug so expect a fix for that on the

00:45:32,440 --> 00:45:37,090
github repo soon but the idea is the

00:45:34,960 --> 00:45:39,040
same right I mean you ask these

00:45:37,090 --> 00:45:41,080
functions you just need to fix the

00:45:39,040 --> 00:45:44,080
correlation so you have a symbol name

00:45:41,080 --> 00:45:47,740
and then some file line column numbers

00:45:44,080 --> 00:45:50,710
good and now we can actually plug it in

00:45:47,740 --> 00:45:52,930
and this is a shortened example or

00:45:50,710 --> 00:45:55,270
output because otherwise it would be too

00:45:52,930 --> 00:45:57,550
long the cool thing now is that we

00:45:55,270 --> 00:46:00,940
actually see at the bottom star lips

00:45:57,550 --> 00:46:03,070
Easter internals but then main something

00:46:00,940 --> 00:46:05,950
that we have written and then maybe some

00:46:03,070 --> 00:46:09,040
algorithm generate end it uses a back

00:46:05,950 --> 00:46:11,110
insert interrater into vectors would

00:46:09,040 --> 00:46:14,110
push calls push back on the vector and

00:46:11,110 --> 00:46:17,200
then that one calls in place back and

00:46:14,110 --> 00:46:19,930
that one then calls M realloc insert and

00:46:17,200 --> 00:46:22,120
this is like internals in the allocator

00:46:19,930 --> 00:46:24,280
default a default allocator fostered

00:46:22,120 --> 00:46:28,090
vector then eventually we call operator

00:46:24,280 --> 00:46:28,810
new and then our interceptor yay we

00:46:28,090 --> 00:46:30,790
succeeded

00:46:28,810 --> 00:46:32,670
we got the back-trace that is somewhat

00:46:30,790 --> 00:46:36,580
usable

00:46:32,670 --> 00:46:39,160
[Applause]

00:46:36,580 --> 00:46:40,869
and if you run this command on new

00:46:39,160 --> 00:46:43,390
machines once again that the file line

00:46:40,869 --> 00:46:48,520
numbers off I'll I'll fix it in a bit

00:46:43,390 --> 00:46:50,710
cool now you go home you try this

00:46:48,520 --> 00:46:58,080
example you compile code with clang and

00:46:50,710 --> 00:46:59,530
what happens is nothing works oh damn so

00:46:58,080 --> 00:47:02,470
problem is

00:46:59,530 --> 00:47:05,320
clang happens to emit this debug

00:47:02,470 --> 00:47:06,910
arranges section if there's any clang

00:47:05,320 --> 00:47:08,770
developer round I would be very

00:47:06,910 --> 00:47:12,100
interested in learning why this is

00:47:08,770 --> 00:47:15,820
because GCC puts it in and makes all of

00:47:12,100 --> 00:47:18,000
this work as it's supposed to be working

00:47:15,820 --> 00:47:20,980
according to the maintainer of elf utils

00:47:18,000 --> 00:47:24,190
whereas clowny doesn't and everything

00:47:20,980 --> 00:47:26,020
breaks all the tooling breaks damn so

00:47:24,190 --> 00:47:29,140
option one is recompile everything and

00:47:26,020 --> 00:47:32,920
pass - G dwarf arranges and then you get

00:47:29,140 --> 00:47:36,640
the section option two is what we are

00:47:32,920 --> 00:47:40,359
going to do essentially we will rebuild

00:47:36,640 --> 00:47:44,470
the contents of this arranges section at

00:47:40,359 --> 00:47:47,080
runtime I'm using some more hacky dwarf

00:47:44,470 --> 00:47:50,170
library function calls that I don't have

00:47:47,080 --> 00:47:52,390
the time to go into details here it's

00:47:50,170 --> 00:47:55,300
all part of the github repo and check it

00:47:52,390 --> 00:47:59,530
out the the whole idea here is based on

00:47:55,300 --> 00:48:01,990
this great project by Bombay Lea called

00:47:59,530 --> 00:48:04,060
backward CPP which just gives you a nice

00:48:01,990 --> 00:48:05,920
way to report a back trace whenever you

00:48:04,060 --> 00:48:07,960
get a crash or something like that so if

00:48:05,920 --> 00:48:11,380
you're just looking for that maybe just

00:48:07,960 --> 00:48:13,480
use this library instead okay so now we

00:48:11,380 --> 00:48:14,980
can put that into our symbolise err and

00:48:13,480 --> 00:48:17,200
I've implemented that in this

00:48:14,980 --> 00:48:20,369
symbolization on a school clang folder

00:48:17,200 --> 00:48:23,710
and when you pass that one to a clung

00:48:20,369 --> 00:48:27,580
compiled library it will work cool so

00:48:23,710 --> 00:48:29,710
now it also works both clang great but I

00:48:27,580 --> 00:48:34,330
said I would love to be able to do

00:48:29,710 --> 00:48:36,460
runtime attaching and haha when you

00:48:34,330 --> 00:48:39,220
thought what I just did was easy or

00:48:36,460 --> 00:48:41,859
maybe let's rather say it was medium to

00:48:39,220 --> 00:48:43,630
hard this next step this is real black

00:48:41,859 --> 00:48:46,390
magic stuff I'm kind of proud that and

00:48:43,630 --> 00:48:49,480
now kind of know what's going on there

00:48:46,390 --> 00:48:51,430
I think I got the answer like I asked

00:48:49,480 --> 00:48:54,580
how how do you do this on stackoverflow

00:48:51,430 --> 00:48:56,470
and I put up this reputation bonus of

00:48:54,580 --> 00:48:59,740
500 funny points and someone actually

00:48:56,470 --> 00:49:02,430
took the time to respond and well 500

00:48:59,740 --> 00:49:04,830
points well-deserved for him definitely

00:49:02,430 --> 00:49:08,320
so now let me show you how this is done

00:49:04,830 --> 00:49:11,500
and I'm very very appreciated of the

00:49:08,320 --> 00:49:13,600
person who helped me here once again we

00:49:11,500 --> 00:49:16,360
need to do code injection and then we

00:49:13,600 --> 00:49:18,880
need to intercept two things code

00:49:16,360 --> 00:49:20,430
injection is actually trivial and I knew

00:49:18,880 --> 00:49:23,190
how to do that already because a

00:49:20,430 --> 00:49:25,870
debugger supports

00:49:23,190 --> 00:49:28,960
runtime attaching and it supports

00:49:25,870 --> 00:49:34,420
calling functions that's all right I

00:49:28,960 --> 00:49:37,150
mean what do we do we use the debugger

00:49:34,420 --> 00:49:41,440
and call DL open on our function on our

00:49:37,150 --> 00:49:44,410
library and then the linker will put our

00:49:41,440 --> 00:49:46,810
code in place execute any static global

00:49:44,410 --> 00:49:50,440
initializes whatnot so that would be

00:49:46,810 --> 00:49:53,890
enough already for most purposes that's

00:49:50,440 --> 00:49:57,750
not too hard right um gdb - P the pit of

00:49:53,890 --> 00:49:57,750
the application you want to attach to

00:49:58,410 --> 00:50:01,390
but if you want to do this in a proper

00:50:00,760 --> 00:50:04,330
way

00:50:01,390 --> 00:50:06,310
you will probably want to do a couple of

00:50:04,330 --> 00:50:08,020
tricks so first of all disable automatic

00:50:06,310 --> 00:50:09,760
similar resolutions because otherwise

00:50:08,020 --> 00:50:12,580
it's going to be very very slow when you

00:50:09,760 --> 00:50:14,410
attach to a large application second is

00:50:12,580 --> 00:50:17,380
maybe your application doesn't link

00:50:14,410 --> 00:50:19,030
against lip DL well happens to be the

00:50:17,380 --> 00:50:21,130
case that there's does underscore I'm

00:50:19,030 --> 00:50:23,110
not scold if C underscore DL open

00:50:21,130 --> 00:50:24,880
underscore mode which happens to work

00:50:23,110 --> 00:50:27,190
similar to DL open which you can use

00:50:24,880 --> 00:50:30,310
instead of DL open because DL open is

00:50:27,190 --> 00:50:32,860
only available in Lib DL so people you

00:50:30,310 --> 00:50:35,170
can kind of say mmm pretty much everyone

00:50:32,860 --> 00:50:37,720
will use lip C but not lip DL so this is

00:50:35,170 --> 00:50:40,690
going to work nice and then we'll

00:50:37,720 --> 00:50:44,020
optionally call a function to pass some

00:50:40,690 --> 00:50:47,890
arguments so first of all we run gdb and

00:50:44,020 --> 00:50:50,580
batch mode we disable automatic similar

00:50:47,890 --> 00:50:54,520
resolution and then we attach to our

00:50:50,580 --> 00:50:57,520
application we only load the symbols

00:50:54,520 --> 00:50:59,900
from Lipsy because inside lip C we now

00:50:57,520 --> 00:51:03,170
want to call this function lip CDL Oh

00:50:59,900 --> 00:51:06,079
open moat with the path to our library

00:51:03,170 --> 00:51:08,660
that we want to inject and we passed

00:51:06,079 --> 00:51:13,460
these two flex which make it work just

00:51:08,660 --> 00:51:15,109
like deal open wood then we call shared

00:51:13,460 --> 00:51:18,049
library on the function that we just

00:51:15,109 --> 00:51:21,410
loaded because that makes the symbol

00:51:18,049 --> 00:51:23,779
available and then we can call attach in

00:51:21,410 --> 00:51:25,339
it and pass some paths so for example

00:51:23,779 --> 00:51:27,470
this would be the path where the output

00:51:25,339 --> 00:51:29,150
should be written to you could skip that

00:51:27,470 --> 00:51:32,450
and just always write to a hard-coded

00:51:29,150 --> 00:51:34,869
paths but this is Megan nice way to to

00:51:32,450 --> 00:51:37,400
interact with a code and initialize it

00:51:34,869 --> 00:51:38,900
that you just inject it and then you

00:51:37,400 --> 00:51:42,799
detach and you're done

00:51:38,900 --> 00:51:49,700
cool and now comes the tricky part

00:51:42,799 --> 00:51:52,220
intercepting library calls so I'll try

00:51:49,700 --> 00:51:56,029
to give a rough quick introduction to

00:51:52,220 --> 00:51:59,299
what God the God know that a global

00:51:56,029 --> 00:52:01,099
officer table is and procedure linkage

00:51:59,299 --> 00:52:03,789
table and these are very very

00:52:01,099 --> 00:52:06,710
fundamental things that are required to

00:52:03,789 --> 00:52:09,740
support relocations which are required

00:52:06,710 --> 00:52:11,630
to call library functions because when

00:52:09,740 --> 00:52:14,630
you call malloc and your executable you

00:52:11,630 --> 00:52:18,140
don't know the address where malloc is

00:52:14,630 --> 00:52:24,020
at right you only know its symbol name

00:52:18,140 --> 00:52:27,650
and so what what happens is you get a

00:52:24,020 --> 00:52:29,420
so-called relocation section within main

00:52:27,650 --> 00:52:31,760
so here we just have this trivial

00:52:29,420 --> 00:52:36,079
example that calls Mellark again full

00:52:31,760 --> 00:52:38,750
debug build and if we call read elf we

00:52:36,079 --> 00:52:39,200
can inspect the relocation table oh

00:52:38,750 --> 00:52:43,640
sorry

00:52:39,200 --> 00:52:46,339
and here we see that add a certain

00:52:43,640 --> 00:52:48,470
offset of 2000 this is actually the

00:52:46,339 --> 00:52:50,779
offset into the global officer table

00:52:48,470 --> 00:52:54,049
there that's the address where I will

00:52:50,779 --> 00:52:56,900
expect my real malloc to be placed by

00:52:54,049 --> 00:53:00,520
the dynamic linker and when I

00:52:56,900 --> 00:53:03,289
disassemble one malloc I see down here

00:53:00,520 --> 00:53:06,829
it's not calling malloc directly it

00:53:03,289 --> 00:53:08,900
jumps to the address within the god so

00:53:06,829 --> 00:53:10,940
well put differently it loads the

00:53:08,900 --> 00:53:12,869
address from the global offset table and

00:53:10,940 --> 00:53:14,180
then calls this

00:53:12,869 --> 00:53:17,369
this happens within the so-called

00:53:14,180 --> 00:53:19,829
procedure linkage table there's a magic

00:53:17,369 --> 00:53:23,039
involved to only pay the price once and

00:53:19,829 --> 00:53:25,289
then it kind of initializes it only once

00:53:23,039 --> 00:53:28,349
and afterwards is quite fast so if you

00:53:25,289 --> 00:53:30,930
ever seen an EDL T symbol in a profiler

00:53:28,349 --> 00:53:32,700
this is where this comes from

00:53:30,930 --> 00:53:34,769
and down here when you actually call

00:53:32,700 --> 00:53:37,349
malloc you see a call to this malloc

00:53:34,769 --> 00:53:39,299
inside the procedure linkage table so

00:53:37,349 --> 00:53:42,119
now we do we know what we need to do

00:53:39,299 --> 00:53:43,579
right we override the values in the

00:53:42,119 --> 00:53:46,470
global offset table

00:53:43,579 --> 00:53:47,460
we iterate over all relocations in our

00:53:46,470 --> 00:53:49,670
jump tables

00:53:47,460 --> 00:53:54,630
check if the symbol name matches because

00:53:49,670 --> 00:53:57,480
here inside the table there's some an

00:53:54,630 --> 00:53:59,160
offset into the symbol table and within

00:53:57,480 --> 00:54:01,400
the symbol table is an offset into the

00:53:59,160 --> 00:54:04,680
string table and this we can then use to

00:54:01,400 --> 00:54:07,279
restructure the symbol name and match

00:54:04,680 --> 00:54:10,980
that against our expectations and then

00:54:07,279 --> 00:54:13,140
essentially put our custom hook into the

00:54:10,980 --> 00:54:16,579
global offset table and now that one

00:54:13,140 --> 00:54:20,130
will be caught so let's try that out

00:54:16,579 --> 00:54:23,400
now without pre-loading anything just

00:54:20,130 --> 00:54:26,279
over writing the give the got table we

00:54:23,400 --> 00:54:30,089
have a function foo it calls malloc and

00:54:26,279 --> 00:54:32,099
we call foo then we will overwrite the P

00:54:30,089 --> 00:54:38,309
headers and then we will call foo again

00:54:32,099 --> 00:54:42,059
and overwriting the P headers is well we

00:54:38,309 --> 00:54:44,190
once again use DL iterate P header we

00:54:42,059 --> 00:54:46,470
will skip the linker because bad things

00:54:44,190 --> 00:54:48,960
happen when you try to override stuff

00:54:46,470 --> 00:54:50,279
within the linker so I didn't dare to do

00:54:48,960 --> 00:54:53,519
that

00:54:50,279 --> 00:54:56,910
I then also checked the sections within

00:54:53,519 --> 00:54:59,579
my my P header and look for this dynamic

00:54:56,910 --> 00:55:03,569
section so now I will iterate over all

00:54:59,579 --> 00:55:06,539
entries mime all my dynamic entries

00:55:03,569 --> 00:55:10,910
within this section and I'll override or

00:55:06,539 --> 00:55:14,220
I'll try to override some data there I

00:55:10,910 --> 00:55:16,170
can do that basically by once again

00:55:14,220 --> 00:55:18,569
iterating over all the din entries and

00:55:16,170 --> 00:55:20,700
every entry corresponds to a different

00:55:18,569 --> 00:55:22,799
table so I have a symbol table string

00:55:20,700 --> 00:55:26,130
table jump Braille table rail table rail

00:55:22,799 --> 00:55:26,700
a table for this purpose it's enough to

00:55:26,130 --> 00:55:28,650
just console

00:55:26,700 --> 00:55:30,660
trade on the jump rail terrible this is

00:55:28,650 --> 00:55:33,000
a relocation that encodes the call to

00:55:30,660 --> 00:55:34,890
malloc later on so we'll set up the

00:55:33,000 --> 00:55:39,180
tables this is this loop and then we

00:55:34,890 --> 00:55:42,240
overwrite the G ot entries some type

00:55:39,180 --> 00:55:46,200
Dave's gloss over it our table

00:55:42,240 --> 00:55:49,320
it's not magic it's just this table with

00:55:46,200 --> 00:55:51,240
some size and you can call beginning end

00:55:49,320 --> 00:55:57,960
which gives you back the entries within

00:55:51,240 --> 00:55:59,790
this table we can use that to find the

00:55:57,960 --> 00:56:03,570
iterations or iterate over all Relic

00:55:59,790 --> 00:56:05,940
relocations and then get the symbol name

00:56:03,570 --> 00:56:08,700
using our string table and symbol table

00:56:05,940 --> 00:56:10,770
this is what happens here we get the

00:56:08,700 --> 00:56:13,920
address out and then we try to override

00:56:10,770 --> 00:56:16,470
the g OT entry by checking whether it's

00:56:13,920 --> 00:56:18,900
malloc and if it is homologue we once

00:56:16,470 --> 00:56:22,589
again call all interceptor which does

00:56:18,900 --> 00:56:26,099
what we did with LD preload before right

00:56:22,589 --> 00:56:28,079
calling DL sim and that's it you may

00:56:26,099 --> 00:56:30,240
need to call em protect and whatnot to

00:56:28,079 --> 00:56:35,130
actually made the address writable but

00:56:30,240 --> 00:56:39,420
most of the time this works we can run

00:56:35,130 --> 00:56:41,400
it and we see a single relocation was

00:56:39,420 --> 00:56:44,369
found and a single call to malloc

00:56:41,400 --> 00:56:48,180
intercepted because in our example here

00:56:44,369 --> 00:56:51,060
let me go back doot-doot doot-doot where

00:56:48,180 --> 00:56:53,250
it was it oh yeah here I first called

00:56:51,060 --> 00:56:54,839
foo that malloc wasn't intercepted but

00:56:53,250 --> 00:56:57,230
the second one was actually intercepted

00:56:54,839 --> 00:57:02,030
so this is pretty cool I now somehow

00:56:57,230 --> 00:57:03,960
dynamically changed it all and

00:57:02,030 --> 00:57:06,210
intercepted the second call to malloc

00:57:03,960 --> 00:57:10,290
this is exactly what we want right so

00:57:06,210 --> 00:57:13,859
now we can hook it all together put it

00:57:10,290 --> 00:57:16,380
into one single executable right off

00:57:13,859 --> 00:57:18,599
shared library and then we get something

00:57:16,380 --> 00:57:20,190
like that so we can attach runtime

00:57:18,599 --> 00:57:22,859
attached to a different application and

00:57:20,190 --> 00:57:25,260
then any subsequent malloc will get

00:57:22,859 --> 00:57:31,190
notified we can get a back trace we can

00:57:25,260 --> 00:57:34,800
spit it out pretty amazing I believe so

00:57:31,190 --> 00:57:37,260
some like when you stop here and this is

00:57:34,800 --> 00:57:39,250
where our time is running out

00:57:37,260 --> 00:57:42,190
you got pretty far but

00:57:39,250 --> 00:57:44,350
it's not yet production-ready heap

00:57:42,190 --> 00:57:47,200
profiler you definitely need to take

00:57:44,350 --> 00:57:48,520
your output format in took on account so

00:57:47,200 --> 00:57:49,960
definitely use something like said

00:57:48,520 --> 00:57:52,450
standard for compressing the data

00:57:49,960 --> 00:57:55,480
otherwise you will drown in gigabytes of

00:57:52,450 --> 00:58:00,070
data maybe use a binary data format

00:57:55,480 --> 00:58:02,290
maybe build something that is easily

00:58:00,070 --> 00:58:04,510
integrated into a time series database

00:58:02,290 --> 00:58:07,480
such that you can then later on zu zoom

00:58:04,510 --> 00:58:09,970
in on time slices right you need to

00:58:07,480 --> 00:58:12,130
handle more quirks like forking

00:58:09,970 --> 00:58:13,480
subprocesses threads right we didn't

00:58:12,130 --> 00:58:15,730
talk about threats at all you need

00:58:13,480 --> 00:58:18,820
definitely need synchronization in there

00:58:15,730 --> 00:58:21,900
to some kind of API for custom

00:58:18,820 --> 00:58:24,640
allocators for pool allocators right and

00:58:21,900 --> 00:58:28,000
obviously some kind of UI to visualize

00:58:24,640 --> 00:58:30,670
at all and that is heap track amongst

00:58:28,000 --> 00:58:36,370
others a tool open-source tool that i

00:58:30,670 --> 00:58:39,220
wrote and that will be my last example

00:58:36,370 --> 00:58:42,310
here a run heap track on a worst case

00:58:39,220 --> 00:58:44,260
scenario for this editor which like

00:58:42,310 --> 00:58:48,400
thousands and thousands of lines of

00:58:44,260 --> 00:58:50,380
repetitive C++ code will wait and the

00:58:48,400 --> 00:58:54,540
gist here is it's about two times slower

00:58:50,380 --> 00:58:59,440
than running the editor without any

00:58:54,540 --> 00:59:04,300
profiling and we just traced in this

00:58:59,440 --> 00:59:07,080
case close to seven million locations we

00:59:04,300 --> 00:59:12,820
grabbed seven million back traces and

00:59:07,080 --> 00:59:15,760
what we got out is OOP there's two

00:59:12,820 --> 00:59:20,470
megabyte file which doesn't sound large

00:59:15,760 --> 00:59:23,230
and now we can visualize it and most

00:59:20,470 --> 00:59:24,820
importantly we get a flame graph which I

00:59:23,230 --> 00:59:27,250
believe is the most important

00:59:24,820 --> 00:59:29,050
visualization for this kind of data you

00:59:27,250 --> 00:59:31,390
get consumed graphs number of

00:59:29,050 --> 00:59:35,320
allocations you'll find temporary

00:59:31,390 --> 00:59:38,860
locations you name it and right so try

00:59:35,320 --> 00:59:40,240
it out don't write your own P profiler I

00:59:38,860 --> 00:59:42,700
would very much welcome any

00:59:40,240 --> 00:59:45,760
contributions you can find the source

00:59:42,700 --> 00:59:48,670
code in the slides I think I had the

00:59:45,760 --> 00:59:50,590
proper link on the first page so yeah

00:59:48,670 --> 00:59:52,680
that will be it Thanks if there any

00:59:50,590 --> 00:59:52,680
questions

00:59:58,500 --> 01:00:12,310
any questions please go to the mic I'm

01:00:10,690 --> 01:00:13,840
sorry can you come over because the echo

01:00:12,310 --> 01:00:15,730
is so bad I don't understand anything

01:00:13,840 --> 01:00:17,110
could you make me come here and I'll

01:00:15,730 --> 01:00:22,660
repeat the question and that's probably

01:00:17,110 --> 01:00:23,590
easier sorry last night I've been to

01:00:22,660 --> 01:00:26,140
tool time

01:00:23,590 --> 01:00:28,420
and I've seen this all in action and it

01:00:26,140 --> 01:00:31,330
looks really amazing do you have any

01:00:28,420 --> 01:00:34,630
videos that show in actually everything

01:00:31,330 --> 01:00:36,880
that you have written I think on YouTube

01:00:34,630 --> 01:00:38,170
you should find something from us oh and

01:00:36,880 --> 01:00:40,300
by the way before you leave grab a

01:00:38,170 --> 01:00:42,850
t-shirt that's very important like one

01:00:40,300 --> 01:00:45,040
of these awesome t-shirts free and taken

01:00:42,850 --> 01:00:49,570
before you leave so yeah on youtube you

01:00:45,040 --> 01:00:51,160
can I think find a demo for that on him

01:00:49,570 --> 01:00:54,720
track yeah definitely so next question

01:00:51,160 --> 01:00:54,720
maybe you just talk and I'll repeat it

01:00:55,620 --> 01:00:59,950
right so the question is whether I have

01:00:58,450 --> 01:01:02,350
support for running this on embedded

01:00:59,950 --> 01:01:06,910
Linux yes the answer is yes we do this

01:01:02,350 --> 01:01:08,230
all the time with exclamation mark it's

01:01:06,910 --> 01:01:10,450
not yet perfect because he actually

01:01:08,230 --> 01:01:11,950
still need the debug information or need

01:01:10,450 --> 01:01:14,380
to run some custom commands it's doable

01:01:11,950 --> 01:01:17,070
I need to polish it a bit but it's it's

01:01:14,380 --> 01:01:32,080
doable I've done that on Armin arm v8

01:01:17,070 --> 01:01:34,840
works yeah next question so the question

01:01:32,080 --> 01:01:36,700
is whether I've seen negative impact on

01:01:34,840 --> 01:01:41,860
the quality of the back traces in face

01:01:36,700 --> 01:01:44,410
of no except I have not last time I

01:01:41,860 --> 01:01:47,950
talked to an Intel developer on the

01:01:44,410 --> 01:01:50,500
Linux perf mailing list he said that on

01:01:47,950 --> 01:01:53,310
x86 at least by default every code is

01:01:50,500 --> 01:01:56,470
kind of compiled with - FS and Kronos

01:01:53,310 --> 01:01:59,710
unwind tables anyways so unless you

01:01:56,470 --> 01:02:03,580
change the default you will get unwind

01:01:59,710 --> 01:02:16,000
entries even for now except functions

01:02:03,580 --> 01:02:18,730
I think try it out I would guess okay so

01:02:16,000 --> 01:02:21,000
the question is whether elf utils is

01:02:18,730 --> 01:02:24,430
going to find debug information

01:02:21,000 --> 01:02:27,160
automatically for me when it got

01:02:24,430 --> 01:02:28,810
stripped from the original so kind of

01:02:27,160 --> 01:02:30,960
related to the question for embedded

01:02:28,810 --> 01:02:39,640
systems right let me go back to the

01:02:30,960 --> 01:02:42,760
setup setup here so by default it will

01:02:39,640 --> 01:02:45,640
call this standard find debug info which

01:02:42,760 --> 01:02:48,040
essentially looks into some heuristic

01:02:45,640 --> 01:02:49,690
paths and tries to find debug info there

01:02:48,040 --> 01:02:52,390
if it doesn't find that it will try to

01:02:49,690 --> 01:02:54,880
look up stuff by a built ID if it

01:02:52,390 --> 01:02:56,320
doesn't work you'll lost but the very

01:02:54,880 --> 01:02:59,320
last path here

01:02:56,320 --> 01:03:02,320
there's no pointer is the user supplied

01:02:59,320 --> 01:03:03,970
string to further lookup paths so this

01:03:02,320 --> 01:03:14,440
would be a customization point for that

01:03:03,970 --> 01:03:16,660
purpose okay so the question is in heap

01:03:14,440 --> 01:03:22,000
track what does a temporary allocation

01:03:16,660 --> 01:03:24,190
mean it's a very trivial heuristic that

01:03:22,000 --> 01:03:26,680
I played around with once and it

01:03:24,190 --> 01:03:28,600
happened to be super worthwhile so this

01:03:26,680 --> 01:03:30,190
is an analysis time right I don't see

01:03:28,600 --> 01:03:32,350
what happens in your code I just see

01:03:30,190 --> 01:03:34,750
there's an allocation follow directly by

01:03:32,350 --> 01:03:36,550
it's the allocation so there could be

01:03:34,750 --> 01:03:39,040
seconds in between I don't care but as

01:03:36,550 --> 01:03:41,050
long as the allocation is followed by

01:03:39,040 --> 01:03:43,750
the allocation I call a temporary and

01:03:41,050 --> 01:03:45,700
just this trivial heuristic will find

01:03:43,750 --> 01:03:47,050
tons and tons of history interesting

01:03:45,700 --> 01:03:49,960
inner loops where you allocate memory

01:03:47,050 --> 01:03:51,910
accidentally and you can just hoist out

01:03:49,960 --> 01:03:55,870
the allocation out of the loop and it's

01:03:51,910 --> 01:03:59,130
like a free performance win basically

01:03:55,870 --> 01:03:59,130
yeah you're welcome

01:04:10,470 --> 01:04:16,480
so the question is whether it's doable

01:04:14,170 --> 01:04:19,390
to put this into a reusable library I

01:04:16,480 --> 01:04:21,220
would guess the github repo that a road

01:04:19,390 --> 01:04:25,540
for this purpose is kind of like the

01:04:21,220 --> 01:04:27,820
starting point so mmm help welcome there

01:04:25,540 --> 01:04:30,369
because my tools have it all integrated

01:04:27,820 --> 01:04:32,530
yet right so you could just essentially

01:04:30,369 --> 01:04:35,380
build on top of that but no I haven't

01:04:32,530 --> 01:04:36,400
yet written I'm a library because once

01:04:35,380 --> 01:04:38,500
you would do that you would probably

01:04:36,400 --> 01:04:40,420
want to work more platforms right but it

01:04:38,500 --> 01:04:43,329
would be great project definitely help

01:04:40,420 --> 01:04:47,050
welcome cool

01:04:43,329 --> 01:04:49,089
so again grab a t-shirt yes we are out

01:04:47,050 --> 01:04:52,320
of t-shirts there was my most important

01:04:49,089 --> 01:04:56,920
tool so thank you everyone

01:04:52,320 --> 01:04:56,920

YouTube URL: https://www.youtube.com/watch?v=YB0QoWI-g8E


