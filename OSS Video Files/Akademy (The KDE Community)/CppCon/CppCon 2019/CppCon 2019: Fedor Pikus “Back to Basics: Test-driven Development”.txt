Title: CppCon 2019: Fedor Pikus “Back to Basics: Test-driven Development”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
In this class, attendees will learn about test-driven development as it applies to C++ programming. Test-driven development (TDD) is the weird idea that you should write tests for code that as yet does not exist! The idea grows on you, though, sometimes to the point that you can’t imagine writing programs any other way. 

Now, if you aren’t practicing TDD already, one class may not make you into a fresh convert; for attendees in that category, my goal is to convince you that it’s not completely stupid and that “there is something there.” 

In C++, TDD offers significant advantages but also poses some language-specific challenges you should be aware of. The difficulties are severe enough that TDD in C++ is often limited to small isolated components or low-level libraries. It gets harder when we want to build a large system, but it’s not impossible. 

We will learn about specific programming techniques such as dependency injection. Perhaps more importantly, we will see how the decision to use TDD influences the design process and the resulting software architecture. Some of the problems we will encounter when trying to follow TDD practices in C++ have at most tolerable solutions if we limit ourselves to language tricks. We can make our software-testing life much easier if we build testability into the software from the design stage, which, in turn, makes the software itself better. 
— 

Fedor Pikus
Mentor Graphics
Chief Scientist
Portland, Oregon Area

Fedor G Pikus is a Chief Engineering Scientist in the Design to Silicon division of Mentor 
Graphics Corp (Siemens business). His earlier positions included a Senior Software Engineer at Google and a Chief Software Architect for Calibre PERC, LVS, DFM at Mentor Graphics. He joined Mentor Graphics in 1998 when he made a switch from academic research in computational physics to the software industry. Fedor is a recognized expert on high-performance computing and C++, he presented his works at CPPCon, SD West, DesignCon, in Software Development Journal, and is also an O’Reilly author. His responsibilities as a Chief Scientist include planning the long-term technical direction of Calibre products, directing and training the engineers who work on these products, design, and architecture of the software, and research in the new design and software technologies. Fedor has over 25 patents and over 100 papers and conference presentations on physics, EDA, software design, and C++ language.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,680 --> 00:00:17,000
thank you all for

00:00:10,639 --> 00:00:20,329
and this is the back-to-basics dog or at

00:00:17,000 --> 00:00:22,220
least back to what should be basics the

00:00:20,329 --> 00:00:26,890
testing you know should be the basic

00:00:22,220 --> 00:00:32,480
thing we do my name is Fedor pikas and

00:00:26,890 --> 00:00:37,360
from Mentor Graphics now the Siemens how

00:00:32,480 --> 00:00:40,460
many people regularly test their code

00:00:37,360 --> 00:00:42,350
how many people n't how many people

00:00:40,460 --> 00:00:49,130
regularly test their code before they

00:00:42,350 --> 00:00:52,070
write it those who didn't hold their

00:00:49,130 --> 00:00:54,310
hand remember it you may be wrong we'll

00:00:52,070 --> 00:00:59,780
get to that

00:00:54,310 --> 00:01:02,680
so in in the nutshell that test-driven

00:00:59,780 --> 00:01:09,820
development is about writing tests

00:01:02,680 --> 00:01:09,820
before the code thinking backwards it is

00:01:10,329 --> 00:01:14,630
the thing is you're probably already

00:01:12,290 --> 00:01:19,670
doing it at least sometimes but the

00:01:14,630 --> 00:01:22,220
other part is really this talk is

00:01:19,670 --> 00:01:23,810
probably 10% about test-driven

00:01:22,220 --> 00:01:27,500
development pure test-driven development

00:01:23,810 --> 00:01:29,479
and the rest is about good testing

00:01:27,500 --> 00:01:31,369
practices and the effect it has on your

00:01:29,479 --> 00:01:33,320
development process if you do the

00:01:31,369 --> 00:01:35,720
remaining 90% and you never do the 10%

00:01:33,320 --> 00:01:40,490
about doing the tests first you're doing

00:01:35,720 --> 00:01:44,810
really well so let's talk about

00:01:40,490 --> 00:01:49,340
test-driven development test-driven

00:01:44,810 --> 00:01:51,229
development it's it's more than it's

00:01:49,340 --> 00:01:54,890
much more than the practice of writing

00:01:51,229 --> 00:01:56,659
tests person code later and that little

00:01:54,890 --> 00:01:58,640
bit of practice is actually probably the

00:01:56,659 --> 00:02:01,280
least important to be it it's about the

00:01:58,640 --> 00:02:04,100
software engineering process and the

00:02:01,280 --> 00:02:06,530
effect it has on the development it

00:02:04,100 --> 00:02:09,019
helps you as a programmer to organize

00:02:06,530 --> 00:02:12,709
and discipline your thoughts it's a

00:02:09,019 --> 00:02:15,019
method for interacting between the teams

00:02:12,709 --> 00:02:17,390
for interacting within the team it's a

00:02:15,019 --> 00:02:21,069
method for organizing your projects for

00:02:17,390 --> 00:02:23,170
setting goals overall

00:02:21,069 --> 00:02:25,420
it's not so much about what it does to

00:02:23,170 --> 00:02:30,939
your code it about what it does to your

00:02:25,420 --> 00:02:32,860
mind the classic test-driven development

00:02:30,939 --> 00:02:34,750
is a very short development cycle

00:02:32,860 --> 00:02:37,720
process you write test for the new

00:02:34,750 --> 00:02:39,970
features no I didn't start with your

00:02:37,720 --> 00:02:41,470
write code I said your write tests you

00:02:39,970 --> 00:02:42,849
run the test and you expect them to fail

00:02:41,470 --> 00:02:45,790
because you didn't write the features

00:02:42,849 --> 00:02:47,950
yet you write the code you make the test

00:02:45,790 --> 00:02:50,500
pass your on tests confirm that they

00:02:47,950 --> 00:02:56,890
pass you iterate I think there is echo

00:02:50,500 --> 00:02:58,810
in the room you the first time you write

00:02:56,890 --> 00:03:00,250
the code just to make the test pass so

00:02:58,810 --> 00:03:02,709
it's not a very good code then you

00:03:00,250 --> 00:03:03,849
refactor an improve the code and you

00:03:02,709 --> 00:03:06,159
make sure that you didn't break any

00:03:03,849 --> 00:03:07,420
tests and you iterate on that and then

00:03:06,159 --> 00:03:11,109
you go back to the beginning to write

00:03:07,420 --> 00:03:13,180
the next feature and there are lots of

00:03:11,109 --> 00:03:17,730
questions here the most obvious is one

00:03:13,180 --> 00:03:19,780
why and well that's we'll answer that it

00:03:17,730 --> 00:03:22,450
during this talk and at the end of the

00:03:19,780 --> 00:03:24,209
talk but lots of the practical questions

00:03:22,450 --> 00:03:29,590
write the test for the new features

00:03:24,209 --> 00:03:31,299
before the code around the tests expect

00:03:29,590 --> 00:03:32,879
them to fail well I don't have the code

00:03:31,299 --> 00:03:38,019
yet they won't even compile

00:03:32,879 --> 00:03:39,910
what do you mean run shouldn't we at

00:03:38,019 --> 00:03:44,049
least declare the interface as to make

00:03:39,910 --> 00:03:46,030
sure something compiles right the code

00:03:44,049 --> 00:03:50,530
to make the test pass just enough to

00:03:46,030 --> 00:03:52,870
make the test pass nothing more run

00:03:50,530 --> 00:03:54,970
tests confirm that they pass okay well

00:03:52,870 --> 00:03:58,480
that's good the test pass did we have

00:03:54,970 --> 00:03:59,889
enough tests but if factor improved the

00:03:58,480 --> 00:04:04,870
code run tests refactor in the probe the

00:03:59,889 --> 00:04:06,819
code run tests for how long are the

00:04:04,870 --> 00:04:09,040
tests that we end up at the end the ones

00:04:06,819 --> 00:04:10,690
that we use to refactor and around and

00:04:09,040 --> 00:04:13,150
confirm are they still the same that the

00:04:10,690 --> 00:04:17,560
ones we started with did we create more

00:04:13,150 --> 00:04:19,720
tests did we create different tests not

00:04:17,560 --> 00:04:21,549
as simple so since I brought up the

00:04:19,720 --> 00:04:22,289
subject of did we create more tests or

00:04:21,549 --> 00:04:24,849
different tests

00:04:22,289 --> 00:04:27,510
what sort of different tests can we do

00:04:24,849 --> 00:04:30,960
well there are unit tests and that's a

00:04:27,510 --> 00:04:32,979
test for testing a small bit of code or

00:04:30,960 --> 00:04:34,360
illogically isolated bit of code we'll

00:04:32,979 --> 00:04:36,159
talk more about that in isolation

00:04:34,360 --> 00:04:38,650
integration tests test for interacting

00:04:36,159 --> 00:04:41,280
of several components system tests for

00:04:38,650 --> 00:04:44,800
the entire software system by the way

00:04:41,280 --> 00:04:46,599
not consistent terminology here you may

00:04:44,800 --> 00:04:48,909
find the word system testing used to

00:04:46,599 --> 00:04:51,099
mean what I mean integration testing and

00:04:48,909 --> 00:04:55,800
I may find the words end-to-end testing

00:04:51,099 --> 00:04:55,800
used to mean what I call system testing

00:04:56,039 --> 00:04:59,650
there is this thing sometimes called

00:04:58,270 --> 00:05:01,719
point test again there is no established

00:04:59,650 --> 00:05:03,340
terminology here it's kind of like a

00:05:01,719 --> 00:05:05,259
unit test but you use the rest of the

00:05:03,340 --> 00:05:07,120
application as a test driver for the

00:05:05,259 --> 00:05:09,069
program basically you run the entire

00:05:07,120 --> 00:05:11,439
program or a part of the program but you

00:05:09,069 --> 00:05:16,120
carefully select the input data to test

00:05:11,439 --> 00:05:19,569
one small chunk of your code acceptance

00:05:16,120 --> 00:05:24,029
test this verifies that you pass certain

00:05:19,569 --> 00:05:26,580
requirements regression tests tracks for

00:05:24,029 --> 00:05:29,830
changes where you don't expect them

00:05:26,580 --> 00:05:32,889
performance tests can be any of the

00:05:29,830 --> 00:05:35,430
above you tracking performance of your

00:05:32,889 --> 00:05:37,659
code performance is as much of a goal

00:05:35,430 --> 00:05:38,949
I'm not talking about benchmarking I'm

00:05:37,659 --> 00:05:41,440
talking about tell you about you have a

00:05:38,949 --> 00:05:42,490
performance requirement it could be as

00:05:41,440 --> 00:05:44,110
much of a goal as a correctness

00:05:42,490 --> 00:05:46,690
requirement this code must produce

00:05:44,110 --> 00:05:48,279
correct result and master on this in

00:05:46,690 --> 00:05:53,020
this time and these are your

00:05:48,279 --> 00:05:55,509
requirements both need to be tested now

00:05:53,020 --> 00:05:57,520
it's important to know the difference in

00:05:55,509 --> 00:06:00,279
reality one of the most common reasons

00:05:57,520 --> 00:06:04,240
for basically abandoning your test to it

00:06:00,279 --> 00:06:05,770
and not giving up on it is trying to use

00:06:04,240 --> 00:06:07,449
the wrong kind of test for the wrong

00:06:05,770 --> 00:06:10,419
purpose so for example if you start

00:06:07,449 --> 00:06:12,729
using unit tests as system integration

00:06:10,419 --> 00:06:14,319
tests you will probably in the long run

00:06:12,729 --> 00:06:16,300
will be unhappy with the results

00:06:14,319 --> 00:06:18,430
it will be unstable it will be too hard

00:06:16,300 --> 00:06:20,080
to maintain it's very easy to start

00:06:18,430 --> 00:06:25,990
doing this and it's very hard to keep

00:06:20,080 --> 00:06:28,029
going unit testing we'll talk about it

00:06:25,990 --> 00:06:29,560
because it's most commonly used with

00:06:28,029 --> 00:06:31,779
test-driven development

00:06:29,560 --> 00:06:33,310
and it's probably the most misunderstood

00:06:31,779 --> 00:06:34,180
kind of testing but it's also the kind

00:06:33,310 --> 00:06:36,969
of testing that you as a developer

00:06:34,180 --> 00:06:40,000
should run the rest is split between the

00:06:36,969 --> 00:06:44,560
developers or nqa unit testing is on the

00:06:40,000 --> 00:06:46,500
developers it's testing of a unit of the

00:06:44,560 --> 00:06:48,730
code outside of the rest of the program

00:06:46,500 --> 00:06:50,500
what's the unit of the

00:06:48,730 --> 00:06:53,620
very often people think it's a small

00:06:50,500 --> 00:06:55,810
thing it's like a class well an

00:06:53,620 --> 00:06:58,990
object-oriented programming classes are

00:06:55,810 --> 00:07:04,090
usually units but not necessarily units

00:06:58,990 --> 00:07:05,650
or classes units could be large at some

00:07:04,090 --> 00:07:08,320
point your entire also you're writing a

00:07:05,650 --> 00:07:11,590
database your entire database could be a

00:07:08,320 --> 00:07:14,050
unit for some set of unit tests now it's

00:07:11,590 --> 00:07:15,370
built from other units and the

00:07:14,050 --> 00:07:19,530
assumption is you have already tested

00:07:15,370 --> 00:07:24,370
those so now the database is a unit and

00:07:19,530 --> 00:07:27,220
you're testing its interfaces as a unit

00:07:24,370 --> 00:07:32,410
basically a block box so usually they're

00:07:27,220 --> 00:07:33,850
small they could be large the important

00:07:32,410 --> 00:07:35,830
thing about unit testing is it's done

00:07:33,850 --> 00:07:38,380
without the rest of the program so where

00:07:35,830 --> 00:07:42,130
do we get like main it's actually

00:07:38,380 --> 00:07:44,830
written for each tests individually you

00:07:42,130 --> 00:07:47,560
can do it by hand it's hard you probably

00:07:44,830 --> 00:07:49,390
will be will not continue your testing

00:07:47,560 --> 00:07:50,560
for long if you do it but there are unit

00:07:49,390 --> 00:07:53,320
testing frameworks that basically

00:07:50,560 --> 00:07:55,510
automate the entire process for you okay

00:07:53,320 --> 00:07:56,740
so that's where the the rest of the

00:07:55,510 --> 00:07:58,600
program comes in but the rest of the

00:07:56,740 --> 00:08:02,980
program isn't just the main you also

00:07:58,600 --> 00:08:05,470
have to put your classes your units in

00:08:02,980 --> 00:08:06,610
the correct internal state which

00:08:05,470 --> 00:08:10,210
normally the rest of the program

00:08:06,610 --> 00:08:12,850
supplies that state for you in a unit

00:08:10,210 --> 00:08:15,010
testing you basically fake it or you

00:08:12,850 --> 00:08:16,720
synthesize it you generate it sometimes

00:08:15,010 --> 00:08:18,010
it's easy sometimes it's very hard we'll

00:08:16,720 --> 00:08:20,470
talk about some of the techniques to do

00:08:18,010 --> 00:08:23,620
that throughout the talk we'll be using

00:08:20,470 --> 00:08:24,880
this example I want to write a solver

00:08:23,620 --> 00:08:27,850
for the Sudoku puzzle it's not

00:08:24,880 --> 00:08:31,720
particularly hard easy to show this why

00:08:27,850 --> 00:08:34,320
I'm going to show some of it everybody

00:08:31,720 --> 00:08:38,860
knows what the Sudoku puzzles are right

00:08:34,320 --> 00:08:40,570
you get the square 9 by 9 there are some

00:08:38,860 --> 00:08:42,520
digits in it you have to fill the rest

00:08:40,570 --> 00:08:44,470
of the digits the rules are every row

00:08:42,520 --> 00:08:48,160
every column and every little 3x3 square

00:08:44,470 --> 00:08:50,500
must contain on all 9 digits so no no

00:08:48,160 --> 00:08:52,690
repetitions in any column in any row and

00:08:50,500 --> 00:08:55,960
then it is square so this is how the

00:08:52,690 --> 00:08:57,520
field 1 looks like if you look through

00:08:55,960 --> 00:09:01,829
every column never every square you'll

00:08:57,520 --> 00:09:05,980
find there are one surah 9 one of each

00:09:01,829 --> 00:09:09,310
well before you can ride the silver you

00:09:05,980 --> 00:09:11,680
have to actually write something that

00:09:09,310 --> 00:09:14,260
represents the puzzle itself so you know

00:09:11,680 --> 00:09:18,570
where where the state is you'll probably

00:09:14,260 --> 00:09:25,959
write the puzzle itself as a class and

00:09:18,570 --> 00:09:28,149
you need get to access the value of a

00:09:25,959 --> 00:09:29,850
particular cell and you need to set to

00:09:28,149 --> 00:09:32,949
write the value into the cell

00:09:29,850 --> 00:09:38,430
you could get fancy with operator square

00:09:32,949 --> 00:09:40,839
brackets but this isn't unreasonable

00:09:38,430 --> 00:09:42,610
okay I'll show you a Google test

00:09:40,839 --> 00:09:44,050
framework there are other unit test

00:09:42,610 --> 00:09:46,449
framework fundamentally they're all very

00:09:44,050 --> 00:09:48,910
similar names change the idea is the

00:09:46,449 --> 00:09:51,399
same you include your code you want to

00:09:48,910 --> 00:09:54,850
test you include the test framework and

00:09:51,399 --> 00:09:57,220
then you do the test test has a name in

00:09:54,850 --> 00:09:58,810
a Google test test B they let you group

00:09:57,220 --> 00:10:00,100
the test by groups or group name test

00:09:58,810 --> 00:10:02,829
name doesn't matter

00:10:00,100 --> 00:10:05,800
and inside of the curly braces inside of

00:10:02,829 --> 00:10:07,269
the pointer inside of the curly braces

00:10:05,800 --> 00:10:09,819
here that's your code that's what you're

00:10:07,269 --> 00:10:11,410
testing so this is the actual code

00:10:09,819 --> 00:10:13,269
you're testing I'm just first thing you

00:10:11,410 --> 00:10:16,120
do with any unit is you construct it

00:10:13,269 --> 00:10:17,620
that's really is like pretty much if you

00:10:16,120 --> 00:10:18,880
unit in a class the first thing you do

00:10:17,620 --> 00:10:21,269
in a unit test you just test if you can

00:10:18,880 --> 00:10:25,089
create it everything else comes later

00:10:21,269 --> 00:10:26,920
okay I created it now I want to run some

00:10:25,089 --> 00:10:31,050
tests on it in the Google test syntax

00:10:26,920 --> 00:10:33,069
it's expect in C X X units its assert

00:10:31,050 --> 00:10:36,180
doesn't matter whatever your framework

00:10:33,069 --> 00:10:39,250
is they have something like this this is

00:10:36,180 --> 00:10:42,399
the caller I'm going to make this is the

00:10:39,250 --> 00:10:45,970
result I expect to get if I don't get it

00:10:42,399 --> 00:10:48,040
it'll tell me so I expect that the

00:10:45,970 --> 00:10:50,410
constructed puzzle is empty I'm going to

00:10:48,040 --> 00:10:53,130
check that it is now this is actually

00:10:50,410 --> 00:11:01,029
the complete file this is it no main

00:10:53,130 --> 00:11:03,010
provided by the framework okay you build

00:11:01,029 --> 00:11:05,170
up unit tests the one important thing

00:11:03,010 --> 00:11:07,120
about unit tests you build up the next

00:11:05,170 --> 00:11:09,850
test on top of the previous one so here

00:11:07,120 --> 00:11:12,250
here is the next test I constructed and

00:11:09,850 --> 00:11:14,110
I'm going to test that I can set a

00:11:12,250 --> 00:11:14,889
number in the cell the important part

00:11:14,110 --> 00:11:17,410
here I

00:11:14,889 --> 00:11:18,040
don't test that what I constructed is

00:11:17,410 --> 00:11:20,949
still empty

00:11:18,040 --> 00:11:22,209
I trust my previous unit test this is

00:11:20,949 --> 00:11:23,679
important in unit testing otherwise

00:11:22,209 --> 00:11:25,720
you'll never get anywhere if you keep

00:11:23,679 --> 00:11:29,769
just building up your unit test you

00:11:25,720 --> 00:11:34,660
trust the previous test so this test is

00:11:29,769 --> 00:11:36,850
for the new feature on it the previous

00:11:34,660 --> 00:11:38,230
test was just for the constructor okay

00:11:36,850 --> 00:11:41,709
we got the constructor it works this

00:11:38,230 --> 00:11:43,329
test is just for the set and yeah it

00:11:41,709 --> 00:11:46,569
should be bigger than that it doesn't

00:11:43,329 --> 00:11:50,319
fit on the slide now here is an

00:11:46,569 --> 00:11:51,970
interesting bit let's say what should

00:11:50,319 --> 00:11:59,169
happen if I try to set a cell that

00:11:51,970 --> 00:12:00,429
doesn't exist out of range well sir what

00:11:59,169 --> 00:12:01,929
should happen depends on what my

00:12:00,429 --> 00:12:03,850
document date what my specification says

00:12:01,929 --> 00:12:06,279
what should happen let's say I specify

00:12:03,850 --> 00:12:08,709
that it's an error and I should throw an

00:12:06,279 --> 00:12:11,829
exception well I should test for that

00:12:08,709 --> 00:12:13,749
this is very important all aspects of

00:12:11,829 --> 00:12:18,040
documented behavior should be tested

00:12:13,749 --> 00:12:20,079
including things like errors if you have

00:12:18,040 --> 00:12:23,249
specified behavior on error you test

00:12:20,079 --> 00:12:26,470
that that's that's how the behavior is

00:12:23,249 --> 00:12:29,139
test-driven development most often uses

00:12:26,470 --> 00:12:31,149
this kind of tests why well test-driven

00:12:29,139 --> 00:12:34,089
development is about fast short circuit

00:12:31,149 --> 00:12:36,999
cycle incremental development unit tests

00:12:34,089 --> 00:12:41,019
are ideal for short cycle incremental

00:12:36,999 --> 00:12:42,189
developments one reason is in a

00:12:41,019 --> 00:12:44,410
test-driven development you start

00:12:42,189 --> 00:12:46,329
testing before you write the program so

00:12:44,410 --> 00:12:48,279
you really probably don't have a main

00:12:46,329 --> 00:12:49,839
you don't have the rest of the program

00:12:48,279 --> 00:12:52,299
you may not have the inputs you can't

00:12:49,839 --> 00:12:54,129
create your state of the program you're

00:12:52,299 --> 00:12:56,709
writing some you start to write a

00:12:54,129 --> 00:12:58,899
program from somewhere but wherever you

00:12:56,709 --> 00:13:01,629
started from you don't have the rest how

00:12:58,899 --> 00:13:02,649
are you going to even run that code if

00:13:01,629 --> 00:13:04,739
you don't have the rest of the program

00:13:02,649 --> 00:13:07,269
well that's where unit tests come in

00:13:04,739 --> 00:13:08,769
there is no rule that unit tests are the

00:13:07,269 --> 00:13:10,539
only test that I used in test-driven

00:13:08,769 --> 00:13:12,399
development you can do test-driven

00:13:10,539 --> 00:13:15,459
development integration tests and you

00:13:12,399 --> 00:13:18,429
often need to do that do it but most

00:13:15,459 --> 00:13:20,439
common let's look at the test-driven

00:13:18,429 --> 00:13:23,889
development process as I said very short

00:13:20,439 --> 00:13:26,970
development cycle but we had all these

00:13:23,889 --> 00:13:26,970
questions about what it means

00:13:27,070 --> 00:13:30,370
and we had questions for pretty much

00:13:28,839 --> 00:13:33,970
every step of the process so let's go

00:13:30,370 --> 00:13:38,500
through them when do you really write

00:13:33,970 --> 00:13:40,810
the unit tests okay of all the people

00:13:38,500 --> 00:13:42,250
who do it or who want to do it or the

00:13:40,810 --> 00:13:45,399
thing that ideally they should be doing

00:13:42,250 --> 00:13:46,779
if they have enough time should you

00:13:45,399 --> 00:13:51,850
write the test before the code is

00:13:46,779 --> 00:13:54,550
written at all after the code is

00:13:51,850 --> 00:13:58,509
declared but before it's implemented so

00:13:54,550 --> 00:14:00,279
when the interfaces are declared when

00:13:58,509 --> 00:14:02,470
the interfaces are declared and some

00:14:00,279 --> 00:14:08,920
dumb implementation is provided so it

00:14:02,470 --> 00:14:10,540
will at least link okay well the answer

00:14:08,920 --> 00:14:12,910
is you can do it in any of those ways

00:14:10,540 --> 00:14:15,069
they all have some advantages and

00:14:12,910 --> 00:14:17,550
disadvantages if you do it before any

00:14:15,069 --> 00:14:20,170
code is written your tests won't compile

00:14:17,550 --> 00:14:21,940
on the other hand and that's a drawback

00:14:20,170 --> 00:14:24,610
because your test may have bugs that's

00:14:21,940 --> 00:14:26,529
kind of disheartening thing about code

00:14:24,610 --> 00:14:30,850
you know your test a code they can have

00:14:26,529 --> 00:14:34,779
bugs your compilers a code they can have

00:14:30,850 --> 00:14:38,980
bugs your debugger is a code you see

00:14:34,779 --> 00:14:41,889
where that's going but you know we do

00:14:38,980 --> 00:14:45,220
the best we can so on the advantages

00:14:41,889 --> 00:14:46,959
your tests are at this point kind of

00:14:45,220 --> 00:14:49,779
their conceptual compilation you compile

00:14:46,959 --> 00:14:51,399
it compel them in your head but they

00:14:49,779 --> 00:14:54,459
describe you how the client code would

00:14:51,399 --> 00:14:57,160
look like and in a way they specify the

00:14:54,459 --> 00:14:58,810
requirements on the interface in C++

00:14:57,160 --> 00:15:01,870
instead of English because if you write

00:14:58,810 --> 00:15:03,970
the code so if I write a set of zero

00:15:01,870 --> 00:15:08,920
zero it means my class must have a

00:15:03,970 --> 00:15:11,889
method said that takes two integers so

00:15:08,920 --> 00:15:14,980
it makes me think in terms of the client

00:15:11,889 --> 00:15:16,510
code when I'm before I started designing

00:15:14,980 --> 00:15:19,839
my interfaces that's actually a big

00:15:16,510 --> 00:15:23,680
advantage we'll return to it later also

00:15:19,839 --> 00:15:25,750
kind of a note to self here if my tests

00:15:23,680 --> 00:15:27,910
can specify the interface could I use

00:15:25,750 --> 00:15:31,810
them instead of the specification well

00:15:27,910 --> 00:15:33,449
let's think about that later if the

00:15:31,810 --> 00:15:35,680
interfaces are declared but not

00:15:33,449 --> 00:15:38,980
implementation is not written your tests

00:15:35,680 --> 00:15:40,300
will compile but they will not link the

00:15:38,980 --> 00:15:40,630
fact that they compile is an advantage

00:15:40,300 --> 00:15:41,920
you

00:15:40,630 --> 00:15:43,330
and verify that your interfaces have

00:15:41,920 --> 00:15:45,370
been written correctly they want link so

00:15:43,330 --> 00:15:47,200
you can't do much else so you go back to

00:15:45,370 --> 00:15:49,180
the basically you it's still a mock-up

00:15:47,200 --> 00:15:52,000
for your client code so you do get that

00:15:49,180 --> 00:15:55,240
a vet benefit you can write dumb

00:15:52,000 --> 00:15:58,240
implementation first your tests will

00:15:55,240 --> 00:15:59,980
compile and they will run and we expect

00:15:58,240 --> 00:16:01,090
them to fail because it's a dumb

00:15:59,980 --> 00:16:04,750
implementation it doesn't do what we

00:16:01,090 --> 00:16:06,430
want and it's a good thing it has a

00:16:04,750 --> 00:16:07,750
benefit because it verifies whether your

00:16:06,430 --> 00:16:09,850
tests are sensitive enough to at least

00:16:07,750 --> 00:16:12,310
detect the presence of the code if your

00:16:09,850 --> 00:16:14,590
tests we work out the same way whether

00:16:12,310 --> 00:16:19,180
the code is there or not the probably

00:16:14,590 --> 00:16:20,860
aren't testing much but of course you

00:16:19,180 --> 00:16:22,630
don't have the client code mock up so

00:16:20,860 --> 00:16:27,310
you have to write the interfaces to some

00:16:22,630 --> 00:16:30,130
other form of specification and the

00:16:27,310 --> 00:16:32,380
problem is that as you can't overly rely

00:16:30,130 --> 00:16:33,490
on the expectation that the test will

00:16:32,380 --> 00:16:35,020
fail you would like them all to fail

00:16:33,490 --> 00:16:37,240
because you really don't want the tests

00:16:35,020 --> 00:16:40,810
that always pass even when you don't

00:16:37,240 --> 00:16:44,650
have the code to test but you know even

00:16:40,810 --> 00:16:46,450
the broken clock is Right twice a day so

00:16:44,650 --> 00:16:48,550
here is some function that just adds two

00:16:46,450 --> 00:16:50,280
numbers we have to return something and

00:16:48,550 --> 00:16:52,630
it has to return an integer

00:16:50,280 --> 00:17:00,520
well that integer could be something you

00:16:52,630 --> 00:17:02,380
test for the most common way in my

00:17:00,520 --> 00:17:04,150
experience is writing the tests after

00:17:02,380 --> 00:17:07,209
the dam implementation so you can verify

00:17:04,150 --> 00:17:12,490
that at least your code compiles and in

00:17:07,209 --> 00:17:14,290
links if you do it the first way it's

00:17:12,490 --> 00:17:15,579
not my terms as some other people

00:17:14,290 --> 00:17:17,620
invented it sometimes it's called

00:17:15,579 --> 00:17:18,850
example driven design and that's

00:17:17,620 --> 00:17:20,920
basically the value here you're

00:17:18,850 --> 00:17:22,630
designing your software thing okay if I

00:17:20,920 --> 00:17:24,189
did my interfaces this way how would the

00:17:22,630 --> 00:17:26,730
client code look like would I be able to

00:17:24,189 --> 00:17:29,140
do what I need to do

00:17:26,730 --> 00:17:33,460
you're not compiling the tests except in

00:17:29,140 --> 00:17:35,440
your head but if you discover that you

00:17:33,460 --> 00:17:36,970
with the interfaces you have in mind you

00:17:35,440 --> 00:17:39,580
actually cannot write the tests for what

00:17:36,970 --> 00:17:42,390
you want you just found that your design

00:17:39,580 --> 00:17:45,490
doesn't do what you would like it to do

00:17:42,390 --> 00:17:46,750
before you write any code as I said the

00:17:45,490 --> 00:17:49,510
biggest impact of test-driven

00:17:46,750 --> 00:17:52,380
development is not on your code it's on

00:17:49,510 --> 00:17:52,380
you on your mind

00:17:52,490 --> 00:17:58,440
what do they mean when they say a right

00:17:55,919 --> 00:18:00,360
enough code to make the test pass well

00:17:58,440 --> 00:18:05,100
here is our function at this time it

00:18:00,360 --> 00:18:09,840
adds four numbers and we had 1 2 3 4

00:18:05,100 --> 00:18:12,120
expect 10 is this is this the valid

00:18:09,840 --> 00:18:13,679
implementation probably not that's

00:18:12,120 --> 00:18:16,679
usually not what they mean when they say

00:18:13,679 --> 00:18:21,690
make the test pass what they mean is

00:18:16,679 --> 00:18:23,850
don't do that don't optimize don't put

00:18:21,690 --> 00:18:25,799
can't multi-threading in don't do

00:18:23,850 --> 00:18:28,679
parallelism yet don't do exotic

00:18:25,799 --> 00:18:35,610
algorithms don't vectorize don't do any

00:18:28,679 --> 00:18:37,980
of those things yet but yeah I probably

00:18:35,610 --> 00:18:40,049
should return the results not just for

00:18:37,980 --> 00:18:42,450
the test but according to the more

00:18:40,049 --> 00:18:46,440
general spec that you have if it should

00:18:42,450 --> 00:18:54,179
add it if the spec says it should add it

00:18:46,440 --> 00:18:55,500
should add you run your test you want to

00:18:54,179 --> 00:18:58,980
make sure that they pass after you

00:18:55,500 --> 00:19:01,049
actually implement the code well how do

00:18:58,980 --> 00:19:03,059
you know when you have enough tests the

00:19:01,049 --> 00:19:05,429
truth is it's always a judgment goal

00:19:03,059 --> 00:19:09,149
it's always a judgment call you never

00:19:05,429 --> 00:19:11,759
have full coverage you can test even the

00:19:09,149 --> 00:19:13,889
simplest operation and you test for

00:19:11,759 --> 00:19:16,529
these inputs and their other inputs and

00:19:13,889 --> 00:19:24,200
many many more inputs and you can't

00:19:16,529 --> 00:19:26,490
trust even that so you will never have

00:19:24,200 --> 00:19:31,950
proof positive that your program is

00:19:26,490 --> 00:19:34,559
correct we have to have some trust that

00:19:31,950 --> 00:19:35,909
some things just work in particular your

00:19:34,559 --> 00:19:38,759
hardware instructions you usually expect

00:19:35,909 --> 00:19:41,399
them to actually just work so you're

00:19:38,759 --> 00:19:43,139
right for someone of you test for what

00:19:41,399 --> 00:19:46,019
you consider normal case you write the

00:19:43,139 --> 00:19:47,250
test for all corner cases it's really a

00:19:46,019 --> 00:19:51,960
judgment call you will never have

00:19:47,250 --> 00:19:53,700
complete coverage if your judgment was

00:19:51,960 --> 00:19:55,710
wrong you will sooner or later discover

00:19:53,700 --> 00:19:59,929
it you will have some bugs and so your

00:19:55,710 --> 00:19:59,929
tests tend to grow

00:20:01,100 --> 00:20:04,549
what's a special case what's a normal

00:20:02,539 --> 00:20:06,080
case well you have a benefit it's a

00:20:04,549 --> 00:20:08,389
white box testing you have a benefit of

00:20:06,080 --> 00:20:11,960
knowledge so for example for our Sudoku

00:20:08,389 --> 00:20:14,090
puzzle well setting the value of five or

00:20:11,960 --> 00:20:16,159
the value of three it's all the same

00:20:14,090 --> 00:20:19,730
there is it's an assignment of some

00:20:16,159 --> 00:20:21,830
integer no value is special so you

00:20:19,730 --> 00:20:28,159
probably don't need to test every value

00:20:21,830 --> 00:20:30,529
at least every valid value you may need

00:20:28,159 --> 00:20:32,659
to test multiple cells you can automate

00:20:30,529 --> 00:20:35,090
for something like Sudoku puzzle you can

00:20:32,659 --> 00:20:37,940
do all nine so nine by nine cells you

00:20:35,090 --> 00:20:42,110
can automate it for a bigger program you

00:20:37,940 --> 00:20:44,149
can't have complete coverage you need to

00:20:42,110 --> 00:20:47,090
be careful here you need to resist

00:20:44,149 --> 00:20:49,309
temptation to over test in real life one

00:20:47,090 --> 00:20:52,820
of the most common reasons for basically

00:20:49,309 --> 00:20:54,830
abandoning your test or not using it as

00:20:52,820 --> 00:20:56,659
often as you should is dess take too

00:20:54,830 --> 00:20:58,399
long to run I need to check in my code

00:20:56,659 --> 00:21:01,909
it takes half an hour to run my

00:20:58,399 --> 00:21:04,129
acceptance tests with I'm it's at end of

00:21:01,909 --> 00:21:06,080
the day I need to go home I'm going to

00:21:04,129 --> 00:21:07,970
check in my code I mean that's really

00:21:06,080 --> 00:21:13,610
just how it is

00:21:07,970 --> 00:21:16,190
it shouldn't be but it is it's a test

00:21:13,610 --> 00:21:19,759
that never very good test that never run

00:21:16,190 --> 00:21:26,779
aren't still not as good as partial

00:21:19,759 --> 00:21:28,610
coverage that gets run every time as a

00:21:26,779 --> 00:21:36,110
developer you know what the special

00:21:28,610 --> 00:21:38,750
cases are so general case you may have a

00:21:36,110 --> 00:21:40,610
corner case the the corner cell may be a

00:21:38,750 --> 00:21:42,769
special case that's the last cell in the

00:21:40,610 --> 00:21:44,000
array maybe special so you know what the

00:21:42,769 --> 00:21:47,779
special cases are for your code

00:21:44,000 --> 00:21:52,429
don't confuse special cases with error

00:21:47,779 --> 00:21:55,370
cases so the last line here is not like

00:21:52,429 --> 00:21:58,090
the other ones it's actually a normal

00:21:55,370 --> 00:22:00,679
case for error handling so don't confuse

00:21:58,090 --> 00:22:02,120
special cases with error handling

00:22:00,679 --> 00:22:04,879
they're two different things you test

00:22:02,120 --> 00:22:06,409
them separately error handling is a

00:22:04,879 --> 00:22:08,029
separate function and probably test it

00:22:06,409 --> 00:22:10,549
in a separate step because your first

00:22:08,029 --> 00:22:13,399
step is write enough code for the normal

00:22:10,549 --> 00:22:15,020
things to pass your second step is now

00:22:13,399 --> 00:22:18,020
protect yourself against the error

00:22:15,020 --> 00:22:21,980
and maybe if you have many errors more

00:22:18,020 --> 00:22:24,890
than one step okay how long do you

00:22:21,980 --> 00:22:27,100
refactor depends what you're a factor

00:22:24,890 --> 00:22:29,990
for it's always a judgement call

00:22:27,100 --> 00:22:31,340
you may need to optimize and refactor

00:22:29,990 --> 00:22:34,010
for optimization you may need to

00:22:31,340 --> 00:22:36,350
reorganize so your code is ready for the

00:22:34,010 --> 00:22:38,679
next coding step the next feature if you

00:22:36,350 --> 00:22:42,529
do that never makes new development and

00:22:38,679 --> 00:22:44,570
reorganization that's important if you

00:22:42,529 --> 00:22:46,640
need to make some changes to your code

00:22:44,570 --> 00:22:49,610
so you can add a feature you make

00:22:46,640 --> 00:22:52,100
changes to your code that are no first

00:22:49,610 --> 00:22:53,409
you finish them you run the test make

00:22:52,100 --> 00:22:57,080
sure nothing changes you check them and

00:22:53,409 --> 00:23:03,289
then you make the changes that actually

00:22:57,080 --> 00:23:04,549
change the results and the code

00:23:03,289 --> 00:23:06,320
improvement may itself be guided by

00:23:04,549 --> 00:23:11,450
tests with you will be adding more tests

00:23:06,320 --> 00:23:15,409
at this point the very important very

00:23:11,450 --> 00:23:17,600
tricky part is testing really means

00:23:15,409 --> 00:23:20,630
observing something so what can you

00:23:17,600 --> 00:23:22,610
observe what can you test we've seemed

00:23:20,630 --> 00:23:23,720
so far everything that all the our short

00:23:22,610 --> 00:23:27,230
examples but they're actually realistic

00:23:23,720 --> 00:23:30,140
examples we observed we tested for user

00:23:27,230 --> 00:23:32,630
observable behavior we used public API

00:23:30,140 --> 00:23:35,860
is to test that's also what happens if

00:23:32,630 --> 00:23:38,000
you do that's not just unit test you do

00:23:35,860 --> 00:23:39,590
system in the system end-to-end test

00:23:38,000 --> 00:23:41,570
whole system test you run the program

00:23:39,590 --> 00:23:44,059
you look at the results that's again

00:23:41,570 --> 00:23:45,590
user observable behavior if you have

00:23:44,059 --> 00:23:49,429
class hierarchies you can inherit and

00:23:45,590 --> 00:23:52,520
you can hook up to protect it api's what

00:23:49,429 --> 00:23:56,090
else well okay let's look at this

00:23:52,520 --> 00:24:01,929
example this is ugly sort insertion sort

00:23:56,090 --> 00:24:01,929
then it doesn't matter here is the sword

00:24:04,440 --> 00:24:10,090
okay we're going to run the test for the

00:24:06,670 --> 00:24:12,910
sword okay here is our test we're going

00:24:10,090 --> 00:24:15,070
to run it on an array the way it's

00:24:12,910 --> 00:24:17,530
written it hooks up to a container and

00:24:15,070 --> 00:24:20,460
it uses in this is so not an integer

00:24:17,530 --> 00:24:24,040
iterate arrange the containers or okay

00:24:20,460 --> 00:24:26,260
so here is some array a week sort it and

00:24:24,040 --> 00:24:27,670
we verify that the results are sorted we

00:24:26,260 --> 00:24:29,860
can test for all the special cases

00:24:27,670 --> 00:24:35,860
sorted sequence reverse sorted sequence

00:24:29,860 --> 00:24:38,290
duplicates and everything is correct now

00:24:35,860 --> 00:24:40,270
we still actually in all of this we only

00:24:38,290 --> 00:24:42,700
test we're actually still testing where

00:24:40,270 --> 00:24:45,880
one special case and that special case

00:24:42,700 --> 00:24:48,910
is it's not on the data it's in the

00:24:45,880 --> 00:24:53,490
container the special case is our

00:24:48,910 --> 00:24:59,500
container is an array data is generic

00:24:53,490 --> 00:25:03,520
input is not well okay we can do the

00:24:59,500 --> 00:25:05,410
other container let's do the vector same

00:25:03,520 --> 00:25:12,990
vector set so vector was the same data

00:25:05,410 --> 00:25:12,990
we can test the results okay let's see

00:25:17,970 --> 00:25:32,160
there's that insertion sort I wrote my

00:25:26,760 --> 00:25:33,750
own test driver just to know not be not

00:25:32,160 --> 00:25:35,940
to kind of pollute things with the

00:25:33,750 --> 00:25:38,130
Google test macorís so I'm testing it on

00:25:35,940 --> 00:25:40,800
the container which container is an

00:25:38,130 --> 00:25:43,190
array and I'll test the same thing on

00:25:40,800 --> 00:25:43,190
the vector

00:25:53,750 --> 00:26:11,450
that wasn't expected let's try to oh

00:26:03,580 --> 00:26:14,269
okay what's the difference okay this

00:26:11,450 --> 00:26:17,809
flag this compiler flag causes problems

00:26:14,269 --> 00:26:27,379
never use that yeah use it okay what it

00:26:17,809 --> 00:26:28,370
really does is it's a debug for debug

00:26:27,379 --> 00:26:31,429
option for STL

00:26:28,370 --> 00:26:35,539
so yeah always use them what happens

00:26:31,429 --> 00:26:38,990
here is the insertion sort has an out of

00:26:35,539 --> 00:26:41,360
bound access which you don't normally

00:26:38,990 --> 00:26:43,940
detect on an array unless you get lucky

00:26:41,360 --> 00:26:45,500
and it will crash you don't detect on

00:26:43,940 --> 00:26:47,000
the normally steal again unless you get

00:26:45,500 --> 00:26:51,440
lucky it crashes but debugger steal

00:26:47,000 --> 00:26:52,879
detects it every time so if you didn't

00:26:51,440 --> 00:26:54,799
detect that the Stork is actually

00:26:52,879 --> 00:26:56,570
correct I mean it has out of bound

00:26:54,799 --> 00:26:58,940
access but it will probably return

00:26:56,570 --> 00:27:00,080
correct results usually I mean you never

00:26:58,940 --> 00:27:02,000
know what'll happen is undefined

00:27:00,080 --> 00:27:03,559
behavior but most of the time it will

00:27:02,000 --> 00:27:05,480
give you correct results as we've seen

00:27:03,559 --> 00:27:06,919
in our example I ran it and if if it

00:27:05,480 --> 00:27:10,610
didn't crash it return incorrect results

00:27:06,919 --> 00:27:12,679
so the problem here is that observable

00:27:10,610 --> 00:27:15,289
behaviors through the public API isn't

00:27:12,679 --> 00:27:19,070
sensitive enough to test for all the

00:27:15,289 --> 00:27:20,659
things you want to test the same thing

00:27:19,070 --> 00:27:22,909
for the our Sudoku puzzle it probably

00:27:20,659 --> 00:27:24,710
has an array like this inside how would

00:27:22,909 --> 00:27:26,480
you detect out of bound accesses if they

00:27:24,710 --> 00:27:31,279
don't crash and don't lead to incorrect

00:27:26,480 --> 00:27:33,080
results which boils down to okay I

00:27:31,279 --> 00:27:36,379
tested the interfaces should I also be

00:27:33,080 --> 00:27:38,840
testing implementation well on one hand

00:27:36,379 --> 00:27:40,309
yes because there are a lot of errors

00:27:38,840 --> 00:27:44,059
that cannot be observed through public

00:27:40,309 --> 00:27:47,269
API the problem with that is it makes

00:27:44,059 --> 00:27:48,799
your test a very fragile implementation

00:27:47,269 --> 00:27:51,019
changes implementation is fluid

00:27:48,799 --> 00:27:53,480
sometimes implementation actually

00:27:51,019 --> 00:27:54,919
doesn't produce stable results that you

00:27:53,480 --> 00:27:57,529
may have concurrency your internal

00:27:54,919 --> 00:27:58,940
results are in flux your final results

00:27:57,529 --> 00:28:00,289
are always correct always the same you

00:27:58,940 --> 00:28:03,379
can verify them but what's going on

00:28:00,289 --> 00:28:04,669
inside there's a lot more fluid again

00:28:03,379 --> 00:28:07,080
one of the most common reasons for

00:28:04,669 --> 00:28:08,850
abandoning a set of tests

00:28:07,080 --> 00:28:10,529
is they need to keep constantly updating

00:28:08,850 --> 00:28:13,470
the test to keep up with implementation

00:28:10,529 --> 00:28:18,080
or other flaky details fluid details

00:28:13,470 --> 00:28:19,799
that you decided to test for so

00:28:18,080 --> 00:28:21,690
sometimes you have to test for

00:28:19,799 --> 00:28:24,539
implementation but it's as a last resort

00:28:21,690 --> 00:28:27,750
when everything else fails everything

00:28:24,539 --> 00:28:29,669
else is a lot of things which means we

00:28:27,750 --> 00:28:33,299
have other options but what are the

00:28:29,669 --> 00:28:34,890
other options so let's go back to the

00:28:33,299 --> 00:28:36,960
problem we just had we had an out of

00:28:34,890 --> 00:28:39,470
bound access on the container that

00:28:36,960 --> 00:28:43,019
wasn't visible through the public API

00:28:39,470 --> 00:28:45,539
well it actually was visible to the

00:28:43,019 --> 00:28:50,190
public API just not the public API we

00:28:45,539 --> 00:28:52,139
were testing it's still an invalid use

00:28:50,190 --> 00:28:55,019
of the API but it's an API of the

00:28:52,139 --> 00:28:57,539
container not the API of the class that

00:28:55,019 --> 00:29:00,990
we were testing and that observation

00:28:57,539 --> 00:29:02,820
suggests that in addition to testing the

00:29:00,990 --> 00:29:04,830
interfaces of the unit that you're

00:29:02,820 --> 00:29:06,779
testing you should also be testing from

00:29:04,830 --> 00:29:09,960
the inside you should be testing that

00:29:06,779 --> 00:29:13,470
that unit makes valid use of the

00:29:09,960 --> 00:29:15,929
interfaces it is accessing now if you

00:29:13,470 --> 00:29:16,850
fall if you think of it is in these

00:29:15,929 --> 00:29:19,679
terms

00:29:16,850 --> 00:29:21,539
not only the unit should abide by the

00:29:19,679 --> 00:29:24,830
contracts but the unit should not

00:29:21,539 --> 00:29:29,490
violate any contracts that it depends on

00:29:24,830 --> 00:29:31,620
you can often remove the need to test

00:29:29,490 --> 00:29:34,769
for implementation if you just test for

00:29:31,620 --> 00:29:37,169
the AP for the compliance with the API

00:29:34,769 --> 00:29:38,399
is with the contracts that you the that

00:29:37,169 --> 00:29:39,330
part is actually public that part is

00:29:38,399 --> 00:29:39,960
stable it doesn't depend on

00:29:39,330 --> 00:29:41,519
implementation

00:29:39,960 --> 00:29:43,440
whatever your implementation of the sort

00:29:41,519 --> 00:29:48,990
is you should never access the vector

00:29:43,440 --> 00:29:52,649
container out of bound how do you test

00:29:48,990 --> 00:29:54,870
for these internal contracts external

00:29:52,649 --> 00:29:58,139
ones are easy we have our special

00:29:54,870 --> 00:30:00,899
testing main we call our interfaces unit

00:29:58,139 --> 00:30:04,409
or whatever and we test for the results

00:30:00,899 --> 00:30:06,299
internal code welds compiled in and the

00:30:04,409 --> 00:30:09,899
stuff that compiled in wasn't built for

00:30:06,299 --> 00:30:12,419
testing so we need somehow to substitute

00:30:09,899 --> 00:30:14,850
the dependencies the lower-level

00:30:12,419 --> 00:30:16,139
components those substitutes are called

00:30:14,850 --> 00:30:17,789
the tests double so most of the rest of

00:30:16,139 --> 00:30:18,990
the talk will be about this test doubles

00:30:17,789 --> 00:30:21,029
they're kind of like body doubles in the

00:30:18,990 --> 00:30:22,589
movies take all of the real thing

00:30:21,029 --> 00:30:25,619
and have some additional capabilities

00:30:22,589 --> 00:30:29,699
that the real thing doesn't so there's

00:30:25,619 --> 00:30:31,729
Devils this double sum usually used for

00:30:29,699 --> 00:30:34,379
testing the code from the inside you

00:30:31,729 --> 00:30:38,129
verify that the code you're testing

00:30:34,379 --> 00:30:40,699
makes valid use of all the code that it

00:30:38,129 --> 00:30:43,669
depends on which is just as important as

00:30:40,699 --> 00:30:47,369
that the curl you're testing

00:30:43,669 --> 00:30:49,949
lets you make valid use of itself there

00:30:47,369 --> 00:30:51,329
are other applications maybe you don't

00:30:49,949 --> 00:30:53,569
have the dependencies yet

00:30:51,329 --> 00:30:58,199
well array of course you have the array

00:30:53,569 --> 00:30:59,669
I might want to test the Sudoku solver

00:30:58,199 --> 00:31:01,829
before I actually write the Sudoku

00:30:59,669 --> 00:31:04,049
puzzle class so I may have a fake puzzle

00:31:01,829 --> 00:31:08,399
probably isn't worth it in this case but

00:31:04,049 --> 00:31:09,809
you know testing let's say communication

00:31:08,399 --> 00:31:11,809
to the database before you write the

00:31:09,809 --> 00:31:16,829
real database may very well be worth it

00:31:11,809 --> 00:31:18,749
fake database the other big thing that

00:31:16,829 --> 00:31:20,219
the test doubles do is they simplify

00:31:18,749 --> 00:31:23,069
creating the desired state for the

00:31:20,219 --> 00:31:25,109
testing sorting the container that was

00:31:23,069 --> 00:31:27,869
easy I want to sort the records in the

00:31:25,109 --> 00:31:29,759
database so here is my huge database the

00:31:27,869 --> 00:31:33,089
server the backup server the redundancy

00:31:29,759 --> 00:31:35,039
the communication the backup lots of

00:31:33,089 --> 00:31:39,359
other stuff and I all I care about is

00:31:35,039 --> 00:31:41,729
getting the records inserting them well

00:31:39,359 --> 00:31:43,349
I just need an array of the records and

00:31:41,729 --> 00:31:43,709
the interface to get the records in and

00:31:43,349 --> 00:31:46,139
out

00:31:43,709 --> 00:31:47,909
I don't care where they come from I'm a

00:31:46,139 --> 00:31:49,259
maybe I haven't written them the better

00:31:47,909 --> 00:31:53,879
the redundant server in the backup

00:31:49,259 --> 00:31:57,079
server yet I can fake the database my

00:31:53,879 --> 00:31:57,079
sort doesn't know any different

00:31:59,539 --> 00:32:05,539
different kinds of test doubles test

00:32:02,069 --> 00:32:08,159
stubs their damn implementations fakes

00:32:05,539 --> 00:32:10,799
simplified more or less real

00:32:08,159 --> 00:32:11,909
implementation mocks marks are an

00:32:10,799 --> 00:32:15,329
interesting ones there are tests

00:32:11,909 --> 00:32:17,669
implementations that do internal

00:32:15,329 --> 00:32:20,549
checking so they they validate or track

00:32:17,669 --> 00:32:25,819
of verify the calls that are made to

00:32:20,549 --> 00:32:29,789
them so our debug STL was a mock because

00:32:25,819 --> 00:32:31,259
it well it did all all the things that

00:32:29,789 --> 00:32:33,659
we expected from this deal but it also

00:32:31,259 --> 00:32:34,390
validated the incoming calls the index

00:32:33,659 --> 00:32:36,700
operator

00:32:34,390 --> 00:32:39,880
so there is there is by the way again

00:32:36,700 --> 00:32:43,560
inconsistent terminology here sometimes

00:32:39,880 --> 00:32:47,170
fakes is used to mean all of that stuff

00:32:43,560 --> 00:32:50,070
so be careful was the determination of

00:32:47,170 --> 00:32:50,070
terminology when you see it

00:32:50,250 --> 00:32:55,030
the line between stubs and fakes isn't

00:32:53,140 --> 00:32:58,030
always clear some people are strict

00:32:55,030 --> 00:33:01,600
about this hard-coded return one that's

00:32:58,030 --> 00:33:04,120
a stub take some value from the input

00:33:01,600 --> 00:33:07,080
and return that that's not a stub some

00:33:04,120 --> 00:33:07,080
people call that a stop as well

00:33:07,980 --> 00:33:15,130
so fakes are simplified implementations

00:33:11,410 --> 00:33:17,440
how simplified now mok's on the other

00:33:15,130 --> 00:33:20,800
hand have that clear differential they

00:33:17,440 --> 00:33:24,340
track something in a dish so they do

00:33:20,800 --> 00:33:28,680
additional inspection on on the data

00:33:24,340 --> 00:33:31,840
that they're cold ways so here is a stab

00:33:28,680 --> 00:33:34,330
here's a double for a random now for

00:33:31,840 --> 00:33:36,250
Rand returns one although it's a random

00:33:34,330 --> 00:33:37,240
number why not but it also counts how

00:33:36,250 --> 00:33:41,010
many times you called it

00:33:37,240 --> 00:33:41,010
so it's both a stab and if any Mach

00:33:42,570 --> 00:33:49,030
stops are basically hard-coded things

00:33:46,770 --> 00:33:51,880
just return the value make your code

00:33:49,030 --> 00:33:54,940
compile link and run with some set of

00:33:51,880 --> 00:33:56,380
values that you know what they are you

00:33:54,940 --> 00:33:57,670
got control over you get control over

00:33:56,380 --> 00:33:58,930
the day to this way it's valuable for

00:33:57,670 --> 00:34:02,710
testing you know exactly what you're

00:33:58,930 --> 00:34:04,480
testing on sometimes it's you get kind

00:34:02,710 --> 00:34:05,920
of a more complex tub you feed the data

00:34:04,480 --> 00:34:08,410
into it and then you get it back out

00:34:05,920 --> 00:34:13,990
some people would call it a fake doesn't

00:34:08,410 --> 00:34:15,700
matter in general fakes are simplified

00:34:13,990 --> 00:34:18,130
implementations by the way remember in

00:34:15,700 --> 00:34:20,800
the in the test-driven development you

00:34:18,130 --> 00:34:22,000
write as simple code as you can for the

00:34:20,800 --> 00:34:24,310
first implementation just to pass the

00:34:22,000 --> 00:34:27,610
test very often that becomes your fake

00:34:24,310 --> 00:34:29,350
later if you Eve that's implementation

00:34:27,610 --> 00:34:32,230
tool evolves into something much more

00:34:29,350 --> 00:34:34,210
complex that could be effective so we

00:34:32,230 --> 00:34:36,370
have a database we have a back-end

00:34:34,210 --> 00:34:40,440
redundant distributed concurrent was

00:34:36,370 --> 00:34:43,540
backup and so on high availability and

00:34:40,440 --> 00:34:46,990
we want to test the interface for

00:34:43,540 --> 00:34:47,980
getting records well fake back-end just

00:34:46,990 --> 00:34:53,260
a set of records good

00:34:47,980 --> 00:34:55,740
has the same interface works now here

00:34:53,260 --> 00:34:55,740
comes the problem

00:34:56,250 --> 00:35:02,190
okay well but before we get to the

00:34:59,559 --> 00:35:05,260
problem okay so here is my sword for

00:35:02,190 --> 00:35:07,059
that's my insertion sword with the

00:35:05,260 --> 00:35:09,369
insertion sort I get that container I

00:35:07,059 --> 00:35:11,230
can test for example for an out of bound

00:35:09,369 --> 00:35:13,059
indexing I can give it a special

00:35:11,230 --> 00:35:14,530
container I can use the bugga steel I

00:35:13,059 --> 00:35:16,270
can give it a special container that I

00:35:14,530 --> 00:35:17,609
instrumented to test fire out of bound

00:35:16,270 --> 00:35:22,180
axes but I can do other things for

00:35:17,609 --> 00:35:23,859
example I can check that every element

00:35:22,180 --> 00:35:25,390
was inspected just because I got sorted

00:35:23,859 --> 00:35:26,260
results out of it doesn't mean that it

00:35:25,390 --> 00:35:29,430
always works

00:35:26,260 --> 00:35:31,960
it may be my input wasn't general enough

00:35:29,430 --> 00:35:34,599
it just so happens that the last element

00:35:31,960 --> 00:35:36,069
in my input was the largest and my sword

00:35:34,599 --> 00:35:39,369
has a bug it never looks at the last

00:35:36,069 --> 00:35:41,380
element well this wouldn't catch every

00:35:39,369 --> 00:35:42,549
bug but if you didn't look at some of

00:35:41,380 --> 00:35:44,020
the elements in the sort of container

00:35:42,549 --> 00:35:47,380
you can't possibly be correct in all

00:35:44,020 --> 00:35:48,490
cases so I'm not saying that this is a

00:35:47,380 --> 00:35:51,030
good test this is this again

00:35:48,490 --> 00:35:52,990
illustration for a simple case but

00:35:51,030 --> 00:35:58,059
basically that's the idea you can

00:35:52,990 --> 00:36:00,730
inspect the incoming calls on your on

00:35:58,059 --> 00:36:02,559
your dependencies and you can validate

00:36:00,730 --> 00:36:06,010
that some properties that should be true

00:36:02,559 --> 00:36:11,230
are true like for sort you inspected at

00:36:06,010 --> 00:36:13,599
least once every value well how do you

00:36:11,230 --> 00:36:16,599
get that test double into your code to

00:36:13,599 --> 00:36:18,280
play the role of the real code for our

00:36:16,599 --> 00:36:21,579
sort it was easy the sort is written to

00:36:18,280 --> 00:36:24,490
take any container so if I have my

00:36:21,579 --> 00:36:26,200
guarded instrumented observing vector I

00:36:24,490 --> 00:36:29,230
send it in instead of the real vector

00:36:26,200 --> 00:36:32,170
and everything is fine well here's my

00:36:29,230 --> 00:36:35,680
database it has a data member backend

00:36:32,170 --> 00:36:38,700
and that's it's written exactly like

00:36:35,680 --> 00:36:42,849
that I have my fake back-end class

00:36:38,700 --> 00:36:46,420
different type how do I get it in two

00:36:42,849 --> 00:36:48,849
ways well fundamentally one way magic to

00:36:46,420 --> 00:36:52,660
sources of magic you know arcane and

00:36:48,849 --> 00:36:55,020
divine sorry compiled magic and C++

00:36:52,660 --> 00:36:55,020
magic

00:36:55,800 --> 00:37:01,200
compiler magic basically you make the

00:36:58,740 --> 00:37:03,330
compiler Swizzle in some different code

00:37:01,200 --> 00:37:04,590
we've seen an example of it debuggers TL

00:37:03,330 --> 00:37:09,030
is exactly that you turn on a pound

00:37:04,590 --> 00:37:11,190
define pound defines make the headers

00:37:09,030 --> 00:37:17,070
change a different version of STL has

00:37:11,190 --> 00:37:18,360
compiled in it usually it's pound

00:37:17,070 --> 00:37:21,900
defined you can do some other compiler

00:37:18,360 --> 00:37:24,600
stuff a compiler Flags build magic is

00:37:21,900 --> 00:37:25,950
another option you change the include

00:37:24,600 --> 00:37:28,680
pass you change the library path

00:37:25,950 --> 00:37:31,410
different version of source code gets

00:37:28,680 --> 00:37:33,360
brought into the build you have to

00:37:31,410 --> 00:37:35,610
recompile everything of course but you

00:37:33,360 --> 00:37:36,810
compile was a your code yet the code

00:37:35,610 --> 00:37:38,520
you're testing doesn't change it's

00:37:36,810 --> 00:37:40,020
written the same way but the code it

00:37:38,520 --> 00:37:42,000
depends on suddenly it's a different

00:37:40,020 --> 00:37:43,970
source file or a different object file

00:37:42,000 --> 00:37:46,200
and if you think you at this point

00:37:43,970 --> 00:37:47,610
consider that if you used any kind of

00:37:46,200 --> 00:37:49,350
memory checker you probably use this

00:37:47,610 --> 00:37:51,270
because most of them what they do is

00:37:49,350 --> 00:37:53,160
they slide in an alternative lips

00:37:51,270 --> 00:37:59,550
implementation that has a tracking

00:37:53,160 --> 00:38:03,120
malloc well

00:37:59,550 --> 00:38:06,000
compiler magic okay kind of you know

00:38:03,120 --> 00:38:09,300
easy to do some uneasy feeling there

00:38:06,000 --> 00:38:13,410
let's talk about c++ magic so dependency

00:38:09,300 --> 00:38:17,010
injection the goal here is to trick your

00:38:13,410 --> 00:38:19,470
code into using the test double instead

00:38:17,010 --> 00:38:22,170
of the real code that you're testing

00:38:19,470 --> 00:38:23,670
code depends on it's actually a

00:38:22,170 --> 00:38:24,720
particular case of a very general

00:38:23,670 --> 00:38:26,580
pattern that's called inversion of

00:38:24,720 --> 00:38:30,300
control normally so you have a class it

00:38:26,580 --> 00:38:31,680
has data members the class control how

00:38:30,300 --> 00:38:32,940
the day what the data members out how

00:38:31,680 --> 00:38:36,110
they're initialized that's a normal

00:38:32,940 --> 00:38:38,790
control if you invert the control if the

00:38:36,110 --> 00:38:39,930
injector the outside code controls what

00:38:38,790 --> 00:38:42,200
the data members are and how they are

00:38:39,930 --> 00:38:44,610
initialized that's inversion of control

00:38:42,200 --> 00:38:46,830
more general than that just the testing

00:38:44,610 --> 00:38:47,820
you if you start using it for the

00:38:46,830 --> 00:38:49,230
testing you may discover that you

00:38:47,820 --> 00:38:51,060
actually like this as a design pattern

00:38:49,230 --> 00:38:54,960
in some cases you may you may end up

00:38:51,060 --> 00:38:56,550
using it for other for other reasons so

00:38:54,960 --> 00:39:00,420
two problems with dependency injection

00:38:56,550 --> 00:39:01,860
problem number one our real data the one

00:39:00,420 --> 00:39:04,530
we want to replace was a test double has

00:39:01,860 --> 00:39:08,559
a fixed type in the code it's written in

00:39:04,530 --> 00:39:12,109
its hard-coded back end right there

00:39:08,559 --> 00:39:15,740
well our test double is a different type

00:39:12,109 --> 00:39:17,059
three ways keep the code as written

00:39:15,740 --> 00:39:20,359
change what it means that was the build

00:39:17,059 --> 00:39:21,799
magic make the keep the code as written

00:39:20,359 --> 00:39:23,529
but make the type change at runtime

00:39:21,799 --> 00:39:27,049
runtime polymorphism

00:39:23,529 --> 00:39:31,190
that's dependency injection that

00:39:27,049 --> 00:39:33,019
back-end that BA in Ian D that's

00:39:31,190 --> 00:39:35,740
actually not a type it's a template

00:39:33,019 --> 00:39:41,930
parameter all the dependency injection

00:39:35,740 --> 00:39:44,450
so two ways to do this now in both cases

00:39:41,930 --> 00:39:46,099
what's important is this doesn't just

00:39:44,450 --> 00:39:48,470
happen you can't graft it on after the

00:39:46,099 --> 00:39:50,569
fact you have to design your code to be

00:39:48,470 --> 00:39:52,190
testable you have to think about how

00:39:50,569 --> 00:39:55,309
you're going to test your dependencies

00:39:52,190 --> 00:39:56,720
during the design code must be written

00:39:55,309 --> 00:39:59,769
to be testable if you want to use these

00:39:56,720 --> 00:39:59,769
techniques that's actually a good thing

00:40:00,700 --> 00:40:06,819
problem number two okay I got the types

00:40:03,170 --> 00:40:09,140
down somehow now in addition to just

00:40:06,819 --> 00:40:12,230
changing the type I also must give the

00:40:09,140 --> 00:40:14,240
the class that I'm testing my specific

00:40:12,230 --> 00:40:15,819
test double instance which isn't the

00:40:14,240 --> 00:40:17,930
instance that normally would get

00:40:15,819 --> 00:40:19,220
sometimes it's not a problem if you have

00:40:17,930 --> 00:40:21,500
for example if you decided to use a

00:40:19,220 --> 00:40:22,849
template and your database constant like

00:40:21,500 --> 00:40:24,500
default constructs the backend it'll

00:40:22,849 --> 00:40:27,500
default construct that the different

00:40:24,500 --> 00:40:29,690
type of the back end sometimes you give

00:40:27,500 --> 00:40:31,130
the intense instance anyway to the sort

00:40:29,690 --> 00:40:35,920
I give it the instance of the container

00:40:31,130 --> 00:40:38,509
so I already give it the instance if

00:40:35,920 --> 00:40:40,849
normally you didn't give it the instance

00:40:38,509 --> 00:40:43,160
you now have a problem you have to pass

00:40:40,849 --> 00:40:44,809
in the instance into the code which

00:40:43,160 --> 00:40:46,640
normally didn't take the instance

00:40:44,809 --> 00:40:49,309
because it didn't expect that it would

00:40:46,640 --> 00:40:51,380
need it in the normal conditions in the

00:40:49,309 --> 00:40:53,650
non testing conditions I expect certain

00:40:51,380 --> 00:40:56,539
back end and I know how to create it

00:40:53,650 --> 00:40:59,480
this is always the issue for if you

00:40:56,539 --> 00:41:00,559
decide to use twenty it is always the

00:40:59,480 --> 00:41:01,759
issue if you decide to use runtime

00:41:00,559 --> 00:41:05,000
polymorphism because if you decide to

00:41:01,759 --> 00:41:08,180
use runtime polymorphism then this back

00:41:05,000 --> 00:41:09,920
end is the base class if you decide at

00:41:08,180 --> 00:41:13,579
runtime you wanted instance of a

00:41:09,920 --> 00:41:15,140
different instance somebody else who

00:41:13,579 --> 00:41:16,970
knows what the real type should be just

00:41:15,140 --> 00:41:18,829
for testing has to construct that

00:41:16,970 --> 00:41:20,980
instance and then somehow it has to get

00:41:18,829 --> 00:41:20,980
in

00:41:21,380 --> 00:41:26,610
three ways to do dependency injection

00:41:23,790 --> 00:41:28,350
again constructor injection the instance

00:41:26,610 --> 00:41:31,560
of the test double is passed to the

00:41:28,350 --> 00:41:33,960
constructor two-and-a-half ways let's

00:41:31,560 --> 00:41:35,310
say interface injection the instance is

00:41:33,960 --> 00:41:37,650
given through the interface other than

00:41:35,310 --> 00:41:39,300
the constructor particular case of

00:41:37,650 --> 00:41:41,160
interface injection called set injection

00:41:39,300 --> 00:41:42,900
the instance is given through the

00:41:41,160 --> 00:41:48,120
interface other than the constructor and

00:41:42,900 --> 00:41:49,860
you have setters and getters constructor

00:41:48,120 --> 00:41:51,300
injection you create the dependency

00:41:49,860 --> 00:41:53,970
object outside of the main class you

00:41:51,300 --> 00:41:55,350
create them first the interesting thing

00:41:53,970 --> 00:41:56,340
here is the class doesn't actually have

00:41:55,350 --> 00:41:58,200
the full knowledge of its own

00:41:56,340 --> 00:42:00,660
dependencies anymore just the contract

00:41:58,200 --> 00:42:03,180
just the interfaces that's what

00:42:00,660 --> 00:42:04,890
inversion of control means your class

00:42:03,180 --> 00:42:07,310
doesn't fully control its own data

00:42:04,890 --> 00:42:09,240
members just has expectations on them

00:42:07,310 --> 00:42:11,010
this is what you normally do for

00:42:09,240 --> 00:42:14,850
polymorphic if you'd use polymorphic

00:42:11,010 --> 00:42:17,840
test doubles database takes a back-end

00:42:14,850 --> 00:42:20,340
interface which could be any back-end

00:42:17,840 --> 00:42:26,580
testing back-end real back-end as long

00:42:20,340 --> 00:42:27,950
as it has the right interface you can

00:42:26,580 --> 00:42:31,260
also do it with template types of course

00:42:27,950 --> 00:42:32,370
if now why would you do it with template

00:42:31,260 --> 00:42:34,830
I suppose template types you can just

00:42:32,370 --> 00:42:36,450
construct it in their object knowing the

00:42:34,830 --> 00:42:37,830
type well that's true if you're

00:42:36,450 --> 00:42:39,330
constructing it with the same arguments

00:42:37,830 --> 00:42:42,120
maybe my testing double needs additional

00:42:39,330 --> 00:42:45,180
arguments then I still have even though

00:42:42,120 --> 00:42:46,890
the type has been changed by some

00:42:45,180 --> 00:42:49,440
shading the template differently I still

00:42:46,890 --> 00:42:52,860
need to pass the specific instance of

00:42:49,440 --> 00:42:54,330
the test double so it has the additional

00:42:52,860 --> 00:43:01,460
arguments that the database doesn't know

00:42:54,330 --> 00:43:03,660
about the biggest problem was this well

00:43:01,460 --> 00:43:05,250
one problem is general yeah you have to

00:43:03,660 --> 00:43:07,620
write there you have to write the code

00:43:05,250 --> 00:43:08,850
to be testable once you start writing

00:43:07,620 --> 00:43:11,730
the code to be testable you run into the

00:43:08,850 --> 00:43:15,990
second problem more and more and more

00:43:11,730 --> 00:43:18,300
constructor arguments and the solution

00:43:15,990 --> 00:43:19,950
to that is actually redesigned and it's

00:43:18,300 --> 00:43:21,330
not a bad redesign basic let's say you

00:43:19,950 --> 00:43:23,760
have a class and it has a twenty data

00:43:21,330 --> 00:43:25,830
members you don't passed one argument

00:43:23,760 --> 00:43:27,870
constructor you restructure e you

00:43:25,830 --> 00:43:30,660
restructure your class to depend on two

00:43:27,870 --> 00:43:31,710
components and you pass two arguments to

00:43:30,660 --> 00:43:34,619
the constructor these two components

00:43:31,710 --> 00:43:36,210
have let's say ten data members each ten

00:43:34,619 --> 00:43:39,210
10 of the original data members each

00:43:36,210 --> 00:43:41,640
again they have two or three components

00:43:39,210 --> 00:43:43,259
each so you kind of build a hierarchy of

00:43:41,640 --> 00:43:47,730
these data members by grouping them into

00:43:43,259 --> 00:43:49,859
logical components it's actually not a

00:43:47,730 --> 00:43:51,480
bad thing if it forces you to design

00:43:49,859 --> 00:43:55,289
this way it increases the modularity of

00:43:51,480 --> 00:43:56,970
your design it makes the design harder

00:43:55,289 --> 00:43:59,789
it makes you think about more things

00:43:56,970 --> 00:44:03,839
during the design but usually the design

00:43:59,789 --> 00:44:05,249
is better and then if you think about

00:44:03,839 --> 00:44:07,319
how you're going to test the code is

00:44:05,249 --> 00:44:09,660
definitely going to be more testable but

00:44:07,319 --> 00:44:13,349
it gives you over usually some side

00:44:09,660 --> 00:44:14,999
benefits as well and the truth is the

00:44:13,349 --> 00:44:17,369
code that is not organized for testing

00:44:14,999 --> 00:44:19,170
usually does not get tested it's really

00:44:17,369 --> 00:44:24,869
hard to graph the stability under the

00:44:19,170 --> 00:44:29,819
existing design after the fact interface

00:44:24,869 --> 00:44:31,349
injection fundamentally similar only the

00:44:29,819 --> 00:44:33,059
constructor does whatever it does which

00:44:31,349 --> 00:44:34,109
may be nothing sometimes so the

00:44:33,059 --> 00:44:36,630
constructor may not create the

00:44:34,109 --> 00:44:37,859
dependencies at all and you push them in

00:44:36,630 --> 00:44:39,480
later so the interface or the

00:44:37,859 --> 00:44:41,400
constructor creates the default

00:44:39,480 --> 00:44:43,980
dependencies the production dependencies

00:44:41,400 --> 00:44:48,140
and you somehow swap in the test doubles

00:44:43,980 --> 00:44:50,730
after the fact it all works

00:44:48,140 --> 00:44:52,349
if the injection methods are only used

00:44:50,730 --> 00:44:54,720
for testing it's a test only interface

00:44:52,349 --> 00:44:56,730
if you actually decide to design with

00:44:54,720 --> 00:44:58,279
inversion of control then that becomes

00:44:56,730 --> 00:45:01,950
your primary interface that's how you

00:44:58,279 --> 00:45:06,720
injector code gives the inverted control

00:45:01,950 --> 00:45:08,640
to the to the former owner of the

00:45:06,720 --> 00:45:11,539
dependencies who is now not an owner

00:45:08,640 --> 00:45:15,809
anymore just a client

00:45:11,539 --> 00:45:18,420
so dependency injection in practice

00:45:15,809 --> 00:45:20,039
difficult but I mean ideas a simple

00:45:18,420 --> 00:45:22,170
implementation is hard

00:45:20,039 --> 00:45:23,749
the reason implementation is hard is

00:45:22,170 --> 00:45:27,359
because if you didn't design for this

00:45:23,749 --> 00:45:30,619
it's very hard to graft it on if you did

00:45:27,359 --> 00:45:30,619
design for it then it's pretty easy

00:45:32,450 --> 00:45:39,089
runtime polymorphism yeah has the

00:45:35,970 --> 00:45:40,799
runtime overhead the other downside of

00:45:39,089 --> 00:45:44,549
the runtime polymorphism is it restricts

00:45:40,799 --> 00:45:45,720
your interfaces so for example let's say

00:45:44,549 --> 00:45:47,040
you had a function that returns a

00:45:45,720 --> 00:45:49,890
stirred optional

00:45:47,040 --> 00:45:51,300
and now you want to use a test double

00:45:49,890 --> 00:45:55,080
for that thing that it returns

00:45:51,300 --> 00:45:58,710
well polymorphic classes don't go into

00:45:55,080 --> 00:46:00,450
the optional easily so you probably

00:45:58,710 --> 00:46:03,810
can't use run temple a morphism with

00:46:00,450 --> 00:46:05,550
that interface and it's probably not the

00:46:03,810 --> 00:46:07,050
reason to redesign your interface if you

00:46:05,550 --> 00:46:08,820
if you want it stirred optional you

00:46:07,050 --> 00:46:10,080
probably should use the optional you

00:46:08,820 --> 00:46:12,210
just should use it it should do

00:46:10,080 --> 00:46:19,140
something else for the test doubles make

00:46:12,210 --> 00:46:22,440
it a template parameter okay

00:46:19,140 --> 00:46:24,510
briefly when we talked about writing

00:46:22,440 --> 00:46:27,930
tests if I write the test first before

00:46:24,510 --> 00:46:32,100
any code they do kind of specify what I

00:46:27,930 --> 00:46:38,550
want to do so can I use tests of the

00:46:32,100 --> 00:46:40,470
specification well on one hand yes see

00:46:38,550 --> 00:46:41,940
very easy it's a self verifying

00:46:40,470 --> 00:46:44,490
specification very easy to check if you

00:46:41,940 --> 00:46:46,680
comply with a specification I call F of

00:46:44,490 --> 00:46:49,080
1 I expect 3 I got back to very

00:46:46,680 --> 00:46:52,460
unambiguous you know you can't possibly

00:46:49,080 --> 00:46:55,020
miss the fact that you're not in spec

00:46:52,460 --> 00:46:57,570
you can't misinterpret the results

00:46:55,020 --> 00:46:59,670
the problem is that again your tests are

00:46:57,570 --> 00:47:04,740
never complete you test always require

00:46:59,670 --> 00:47:10,550
inference so f of 1 is 3 f of 2 is 5 7

00:47:04,740 --> 00:47:14,720
what's the next one what's the next one

00:47:10,550 --> 00:47:19,380
anyone sorry

00:47:14,720 --> 00:47:23,910
11 you're you I was actually thinking of

00:47:19,380 --> 00:47:25,970
9 but yeah you could be right so here is

00:47:23,910 --> 00:47:28,890
the case where inference is ambiguous

00:47:25,970 --> 00:47:33,240
I could be thinking of primes or I could

00:47:28,890 --> 00:47:34,860
be thinking of just odd numbers so now

00:47:33,240 --> 00:47:41,220
this is a trivial case but inference is

00:47:34,860 --> 00:47:42,630
very often ambiguous now in reality

00:47:41,220 --> 00:47:44,400
there's actually not one question but

00:47:42,630 --> 00:47:46,140
two can you use the test to fully

00:47:44,400 --> 00:47:48,510
specify behavior we already know the

00:47:46,140 --> 00:47:52,170
answer not really can you use the test

00:47:48,510 --> 00:47:59,540
to fully specify the API well also not

00:47:52,170 --> 00:48:03,350
really but a little closer so you

00:47:59,540 --> 00:48:05,090
F of one should compile that's bigger no

00:48:03,350 --> 00:48:08,810
that's kind of more complete knowledge

00:48:05,090 --> 00:48:10,369
than F of one should returns three F F

00:48:08,810 --> 00:48:13,160
of F of one compiles F of two will

00:48:10,369 --> 00:48:15,350
probably also compile but it doesn't say

00:48:13,160 --> 00:48:16,840
us tell us like how big this entails or

00:48:15,350 --> 00:48:19,250
maybe it's not an Intel could be double

00:48:16,840 --> 00:48:21,560
it doesn't say what the return type is

00:48:19,250 --> 00:48:26,150
for templates of course it's even more

00:48:21,560 --> 00:48:28,310
ambiguous so overall not a good

00:48:26,150 --> 00:48:29,900
specification very good complement to

00:48:28,310 --> 00:48:31,250
the specification examples for the

00:48:29,900 --> 00:48:35,119
specification illustration of the

00:48:31,250 --> 00:48:37,220
specification documentation kind of same

00:48:35,119 --> 00:48:39,320
thing you can use tests to document the

00:48:37,220 --> 00:48:42,710
behavior you get the equivalent of the

00:48:39,320 --> 00:48:46,160
stupid comment this code adds X&Y yeah

00:48:42,710 --> 00:48:47,840
of course it adds X and y and this is if

00:48:46,160 --> 00:48:49,420
you use the test as a documentation

00:48:47,840 --> 00:48:52,570
that's exactly what it tells you

00:48:49,420 --> 00:48:54,410
it adds x and y doesn't tell you why

00:48:52,570 --> 00:48:58,490
which is what the comments would really

00:48:54,410 --> 00:49:00,160
do so not a good specification by itself

00:48:58,490 --> 00:49:04,310
not a good documentation by itself

00:49:00,160 --> 00:49:06,980
excellent appendix excellent

00:49:04,310 --> 00:49:10,550
illustration very good for documenting

00:49:06,980 --> 00:49:12,290
special cases corner cases because for

00:49:10,550 --> 00:49:15,290
corner cases you often just that's often

00:49:12,290 --> 00:49:17,030
what you say in your specification and f

00:49:15,290 --> 00:49:19,609
of X returns this and this and this

00:49:17,030 --> 00:49:20,780
except F of 0 which always does what's

00:49:19,609 --> 00:49:24,170
rows okay

00:49:20,780 --> 00:49:26,330
f of 0 zeroes test will test for this is

00:49:24,170 --> 00:49:29,990
perfect that's it that's it that's your

00:49:26,330 --> 00:49:34,430
spec very briefly testing parallel

00:49:29,990 --> 00:49:36,190
programs you can do test-driven

00:49:34,430 --> 00:49:41,330
development of multi-threaded programs

00:49:36,190 --> 00:49:42,740
the way you do it is you test each

00:49:41,330 --> 00:49:45,130
single threaded component to make sure

00:49:42,740 --> 00:49:48,650
it's correct you develop synchronization

00:49:45,130 --> 00:49:51,050
constructs you test those and then you

00:49:48,650 --> 00:49:56,300
start adding concurrency it's hard to

00:49:51,050 --> 00:49:58,220
concurrency a little bit at a time it's

00:49:56,300 --> 00:49:59,930
also very important that even though you

00:49:58,220 --> 00:50:01,280
say test single threaded components it

00:49:59,930 --> 00:50:03,230
doesn't mean that you design your code

00:50:01,280 --> 00:50:05,660
was a single threaded mindset and then

00:50:03,230 --> 00:50:07,550
add concurrency after the fact design

00:50:05,660 --> 00:50:08,960
should be with the concurrence in mind

00:50:07,550 --> 00:50:12,140
from the beginning if you want to do

00:50:08,960 --> 00:50:14,770
comparin c testing should be first for

00:50:12,140 --> 00:50:14,770
all single threaded

00:50:14,780 --> 00:50:22,950
components it's very hard to add

00:50:19,410 --> 00:50:24,750
concurrency incrementally the easiest

00:50:22,950 --> 00:50:27,089
way to both test or you can actually

00:50:24,750 --> 00:50:30,869
develop for it is you build your code

00:50:27,089 --> 00:50:33,059
from thread safe components and you test

00:50:30,869 --> 00:50:34,500
those components as units for both

00:50:33,059 --> 00:50:37,500
single threaded and multi-threaded

00:50:34,500 --> 00:50:40,819
behavior and then you do integration

00:50:37,500 --> 00:50:43,079
testing on the on the entire thing so

00:50:40,819 --> 00:50:45,750
here is our database it has done

00:50:43,079 --> 00:50:48,240
transaction queue it has a log and

00:50:45,750 --> 00:50:52,559
everything is in the open and we just

00:50:48,240 --> 00:50:56,369
manually synchronize the design style is

00:50:52,559 --> 00:50:58,799
known as the big mess what you want is a

00:50:56,369 --> 00:51:01,260
transaction the thread safe transaction

00:50:58,799 --> 00:51:05,250
queue that encapsulate the thread safety

00:51:01,260 --> 00:51:06,990
aspects and it should provide you with

00:51:05,250 --> 00:51:09,240
atomic transaction by atomic I don't

00:51:06,990 --> 00:51:10,950
mean log free like C++ Atomics it could

00:51:09,240 --> 00:51:14,369
be a little using logs inside I mean the

00:51:10,950 --> 00:51:16,770
interface is atomic every call is an

00:51:14,369 --> 00:51:19,349
atomic transaction does some complete

00:51:16,770 --> 00:51:22,549
transaction operation is uninterruptible

00:51:19,349 --> 00:51:26,760
it happens it cannot be interfered with

00:51:22,549 --> 00:51:32,490
you could use a lock to ensure that okay

00:51:26,760 --> 00:51:35,309
let's skip the interfaces for time so

00:51:32,490 --> 00:51:37,319
how do you test concurrent programs the

00:51:35,309 --> 00:51:39,900
most common answer is with integration

00:51:37,319 --> 00:51:41,160
testing you do unit testing on single

00:51:39,900 --> 00:51:43,170
threaded components you do integration

00:51:41,160 --> 00:51:46,680
testing or not iterative components that

00:51:43,170 --> 00:51:48,329
is not entirely I mean that's not the

00:51:46,680 --> 00:51:49,890
only thing you can do sometimes people

00:51:48,329 --> 00:51:51,329
say that's on integration people say

00:51:49,890 --> 00:51:54,599
concurrent testing is by definition

00:51:51,329 --> 00:51:56,609
integration testing that's not true and

00:51:54,599 --> 00:51:57,780
the downside is live testing of

00:51:56,609 --> 00:52:00,299
concurrent programs is always

00:51:57,780 --> 00:52:03,990
probabilistic and the flaky tests

00:52:00,299 --> 00:52:06,390
usually get ignored you can do unit

00:52:03,990 --> 00:52:07,980
testing of concurrent programs what you

00:52:06,390 --> 00:52:10,680
can do is you test for certain variants

00:52:07,980 --> 00:52:12,599
for example every time the queue is

00:52:10,680 --> 00:52:13,920
accessed this mutex must be hold that's

00:52:12,599 --> 00:52:15,960
a single threaded environment the

00:52:13,920 --> 00:52:17,609
calling thread must hold the mutex

00:52:15,960 --> 00:52:19,710
before it accesses the queue then nobody

00:52:17,609 --> 00:52:21,359
else will be able if that's true then if

00:52:19,710 --> 00:52:22,589
you have a guarantee that nobody else

00:52:21,359 --> 00:52:24,420
will be able to access the queue because

00:52:22,589 --> 00:52:25,890
you another thread can't get the mutex

00:52:24,420 --> 00:52:26,580
you don't need to test for the other

00:52:25,890 --> 00:52:28,590
part of it to make

00:52:26,580 --> 00:52:30,630
sure that another threat doesn't access

00:52:28,590 --> 00:52:32,190
the queue because you already tested

00:52:30,630 --> 00:52:34,860
that any thread that accesses the queue

00:52:32,190 --> 00:52:37,440
holds the mutex it guarantees that you

00:52:34,860 --> 00:52:39,860
cannot have an access by another thread

00:52:37,440 --> 00:52:43,400
that doesn't hold the mutex

00:52:39,860 --> 00:52:46,010
unfortunately in order to test for this

00:52:43,400 --> 00:52:48,330
for the single thread is invariant so

00:52:46,010 --> 00:52:49,740
this is a kind of unit testing you don't

00:52:48,330 --> 00:52:51,410
test for race conditions you test for

00:52:49,740 --> 00:52:53,880
single threaded environments

00:52:51,410 --> 00:52:56,160
unfortunately you have to do dependency

00:52:53,880 --> 00:52:58,110
injection on everything including them

00:52:56,160 --> 00:52:59,550
the locks I mean who on earth would

00:52:58,110 --> 00:53:02,940
write their code from the beginning was

00:52:59,550 --> 00:53:05,070
injectable mutexes if you didn't think

00:53:02,940 --> 00:53:06,930
about it up front like I don't know

00:53:05,070 --> 00:53:08,250
anyone who does it honestly and then you

00:53:06,930 --> 00:53:09,800
think it's really get to this point and

00:53:08,250 --> 00:53:12,870
now oh damn

00:53:09,800 --> 00:53:14,730
like I would I need to know I need to

00:53:12,870 --> 00:53:16,230
injectable mutex because I need to track

00:53:14,730 --> 00:53:20,430
it I need to know if it was taken or not

00:53:16,230 --> 00:53:22,080
I need a mock mutex so anymore q well

00:53:20,430 --> 00:53:24,210
more Q you might think about mock you

00:53:22,080 --> 00:53:28,740
but my mock you needs to ask my mock

00:53:24,210 --> 00:53:31,680
mutex have you been locked so you have

00:53:28,740 --> 00:53:34,740
to dependency inject everything if you

00:53:31,680 --> 00:53:36,240
didn't design for it honestly you're not

00:53:34,740 --> 00:53:40,200
going to be able to refactor for it it's

00:53:36,240 --> 00:53:43,440
too hard if you design for it well you

00:53:40,200 --> 00:53:44,850
may be able to if you didn't design for

00:53:43,440 --> 00:53:49,140
it or it's too hard to design for it

00:53:44,850 --> 00:53:52,020
you go back to magic so yeah dependency

00:53:49,140 --> 00:53:55,560
injection you have to rewrite all the

00:53:52,020 --> 00:53:59,010
classes make it injectable not going to

00:53:55,560 --> 00:54:04,050
happen it would be nice but now we're

00:53:59,010 --> 00:54:05,100
going back to compiler magic we already

00:54:04,050 --> 00:54:08,220
seen the compiler magic

00:54:05,100 --> 00:54:11,190
I didn't inject a new vector I just

00:54:08,220 --> 00:54:15,260
tricked STL into injecting a new vector

00:54:11,190 --> 00:54:18,150
for me because I had the power to find

00:54:15,260 --> 00:54:20,370
there is another way to do similar thing

00:54:18,150 --> 00:54:21,870
and that is to use the sanitizers and

00:54:20,370 --> 00:54:25,140
that's the last idea that I want to

00:54:21,870 --> 00:54:26,790
leave it to leave is combining testing

00:54:25,140 --> 00:54:29,700
and sanitizers is a very powerful

00:54:26,790 --> 00:54:31,470
combination what are the sanitizers

00:54:29,700 --> 00:54:33,300
these are the tools that somehow

00:54:31,470 --> 00:54:36,090
instrument the code or the runtime are

00:54:33,300 --> 00:54:40,250
both and detect certain errors so they

00:54:36,090 --> 00:54:41,690
could be compiler they

00:54:40,250 --> 00:54:43,580
be things built in the compiler they

00:54:41,690 --> 00:54:45,980
could replace system libraries they

00:54:43,580 --> 00:54:47,840
could be tools that basically monitor in

00:54:45,980 --> 00:54:49,190
your program and intercept Hardware

00:54:47,840 --> 00:54:52,250
instructions there are different types

00:54:49,190 --> 00:54:53,930
so these are three ones that built in

00:54:52,250 --> 00:54:55,880
the most common ones built into the

00:54:53,930 --> 00:54:57,850
compiler address sanitizer thread

00:54:55,880 --> 00:55:02,410
sanitizer undefined behavior sanitizer

00:54:57,850 --> 00:55:02,410
these are all built into like clang GCC

00:55:02,710 --> 00:55:09,290
they don't test for everything but what

00:55:06,380 --> 00:55:10,670
they do test for you basically get an

00:55:09,290 --> 00:55:15,170
equivalent of the dependency injection

00:55:10,670 --> 00:55:19,250
on your entire program done for you by

00:55:15,170 --> 00:55:22,520
the compiler or the sanitizer and it's

00:55:19,250 --> 00:55:25,280
much more reliable than just hoping that

00:55:22,520 --> 00:55:27,110
invalid actions will cause a failure for

00:55:25,280 --> 00:55:28,790
example the thread sanitizer will detect

00:55:27,110 --> 00:55:30,680
potential race conditions not just a

00:55:28,790 --> 00:55:32,720
real race conditions address sanitizer

00:55:30,680 --> 00:55:35,180
will detect out of bound accesses even

00:55:32,720 --> 00:55:36,800
when nothing bad happened you write it

00:55:35,180 --> 00:55:38,000
out of bounds of the array there was

00:55:36,800 --> 00:55:39,830
nothing there you didn't corrupt any

00:55:38,000 --> 00:55:48,170
memory your results will be correct

00:55:39,830 --> 00:55:51,680
address sanitizer will let you know that

00:55:48,170 --> 00:55:53,900
same code without the pound define but

00:55:51,680 --> 00:55:56,870
with the address sanitizer out of bound

00:55:53,900 --> 00:55:59,330
error so this was I turned off the

00:55:56,870 --> 00:56:02,360
debugger steel I turned on the address

00:55:59,330 --> 00:56:04,610
sanitizer now it gives me the outer

00:56:02,360 --> 00:56:05,870
boundary on the array by the way which

00:56:04,610 --> 00:56:07,010
debug is still of course couldn't do

00:56:05,870 --> 00:56:09,410
because built-in array whatever no

00:56:07,010 --> 00:56:11,960
there's no debug built-in array but the

00:56:09,410 --> 00:56:17,750
but this thing gave me an out of bounder

00:56:11,960 --> 00:56:19,670
even on the built-in array so it's a

00:56:17,750 --> 00:56:22,340
very powerful combination because it

00:56:19,670 --> 00:56:24,830
gives you a kind of blanket wholesale

00:56:22,340 --> 00:56:26,540
shotgun limited dependency injection

00:56:24,830 --> 00:56:28,370
limited you can sanitize for everything

00:56:26,540 --> 00:56:33,190
but what you can sanitize for very

00:56:28,370 --> 00:56:35,630
powerful under under used in my opinion

00:56:33,190 --> 00:56:37,580
people don't think about it often enough

00:56:35,630 --> 00:56:39,080
go straight for dependency injection or

00:56:37,580 --> 00:56:40,820
what they can't inject they don't test

00:56:39,080 --> 00:56:43,280
remember to think about available

00:56:40,820 --> 00:56:44,480
sanitizers it's a lot easier to sanitize

00:56:43,280 --> 00:56:45,710
your unit test and interpret results

00:56:44,480 --> 00:56:48,380
than it is to sanitize your whole

00:56:45,710 --> 00:56:50,300
program tea Sun may not be able honestly

00:56:48,380 --> 00:56:53,420
to sanitize your entire program it gives

00:56:50,300 --> 00:56:55,280
false positives it's it may be too hard

00:56:53,420 --> 00:56:57,860
getting at Isan error on the unit test

00:56:55,280 --> 00:56:59,900
or small integration test that's just

00:56:57,860 --> 00:57:01,700
the joy you know you get ten lines of

00:56:59,900 --> 00:57:07,400
code this an arrow right here how hard

00:57:01,700 --> 00:57:09,320
can it be one slide on efficiency

00:57:07,400 --> 00:57:10,970
performance could be a design goal I'm

00:57:09,320 --> 00:57:13,970
not going to talk about it

00:57:10,970 --> 00:57:15,770
but it could be a design goal and you if

00:57:13,970 --> 00:57:18,020
it is you need tests for performance

00:57:15,770 --> 00:57:21,920
it's not benchmarking its tests for

00:57:18,020 --> 00:57:27,560
achieving the necessary performance so

00:57:21,920 --> 00:57:30,710
the bottom line two slides why would you

00:57:27,560 --> 00:57:33,770
be not testing your code common reasons

00:57:30,710 --> 00:57:35,600
or things not to do flag at the flaky

00:57:33,770 --> 00:57:38,810
test flight testing environment desert

00:57:35,600 --> 00:57:41,420
take too long test that to depend too

00:57:38,810 --> 00:57:42,860
much dependent on some internal detail

00:57:41,420 --> 00:57:45,530
the changes often needs to be updated

00:57:42,860 --> 00:57:49,940
too often tests that are too hard to

00:57:45,530 --> 00:57:53,750
maintain the design wasn't meant to be

00:57:49,940 --> 00:57:55,250
testable too hard to test you can't

00:57:53,750 --> 00:57:57,620
access the things that you really need

00:57:55,250 --> 00:58:00,020
up to observe to test again the design

00:57:57,620 --> 00:58:02,570
wasn't it wasn't done for testing so

00:58:00,020 --> 00:58:04,220
these are the things that either make

00:58:02,570 --> 00:58:06,290
you not do the test it to begin with or

00:58:04,220 --> 00:58:09,050
start doing the testing and give up on

00:58:06,290 --> 00:58:12,200
Emma the later part is more dangerous

00:58:09,050 --> 00:58:14,420
more pernicious because you don't see it

00:58:12,200 --> 00:58:19,820
coming and then over time you just

00:58:14,420 --> 00:58:23,120
gradually give up on your testing okay

00:58:19,820 --> 00:58:25,790
those are don't do's what do you do

00:58:23,120 --> 00:58:27,440
the biggest thing think about the

00:58:25,790 --> 00:58:29,680
stability from the beginning when you do

00:58:27,440 --> 00:58:31,780
the design that's the most important

00:58:29,680 --> 00:58:34,670
dependency injection is a subset of it

00:58:31,780 --> 00:58:39,170
making this observable what needs to be

00:58:34,670 --> 00:58:42,200
observable even if you don't plan to do

00:58:39,170 --> 00:58:44,440
the test driven development figure out

00:58:42,200 --> 00:58:46,850
this development process learn about it

00:58:44,440 --> 00:58:48,200
think in these terms even if you don't

00:58:46,850 --> 00:58:50,600
write the code if you don't try the test

00:58:48,200 --> 00:58:52,790
before the code think about how the test

00:58:50,600 --> 00:58:54,140
would look like before doing the API

00:58:52,790 --> 00:58:57,470
development that's the example driven

00:58:54,140 --> 00:58:59,300
design it makes you think okay if I did

00:58:57,470 --> 00:59:02,180
design if I do design in the way I think

00:58:59,300 --> 00:59:04,870
I'm about to do it would it actually be

00:59:02,180 --> 00:59:04,870
useful

00:59:05,739 --> 00:59:08,890
you do the design and then you discover

00:59:07,390 --> 00:59:11,529
Oh doesn't do what I want you to start

00:59:08,890 --> 00:59:14,170
ugly workarounds grafting some junk on

00:59:11,529 --> 00:59:17,529
to it you could have avoided it if you

00:59:14,170 --> 00:59:20,440
just imagined the client code in your

00:59:17,529 --> 00:59:21,789
head or just wrote it down wouldn't

00:59:20,440 --> 00:59:23,410
compile wouldn't be complete code but

00:59:21,789 --> 00:59:30,579
just get write it down see how they how

00:59:23,410 --> 00:59:32,920
it would look like if you have this if

00:59:30,579 --> 00:59:34,839
you notice that you start your testing

00:59:32,920 --> 00:59:37,059
discipline starts to decay fix those

00:59:34,839 --> 00:59:38,769
problems as early as possible if you

00:59:37,059 --> 00:59:41,799
have one flaky test in your test field

00:59:38,769 --> 00:59:42,279
and you can't fix it now honestly turn

00:59:41,799 --> 00:59:44,799
it off

00:59:42,279 --> 00:59:47,589
it's better than people mistrusting your

00:59:44,799 --> 00:59:49,329
entire test suite you know this one this

00:59:47,589 --> 00:59:51,249
destron always fails we just ignore the

00:59:49,329 --> 00:59:53,229
results because you run the test and

00:59:51,249 --> 00:59:54,970
says one or more tests fail and it

00:59:53,229 --> 00:59:57,729
always does that we just never look at

00:59:54,970 --> 01:00:00,099
this turn off that flaky test fix it

00:59:57,729 --> 01:00:02,529
ideally but if you can't turn it off so

01:00:00,099 --> 01:00:04,299
when it comes back with your tests

01:00:02,529 --> 01:00:09,759
around comes back was a failure you know

01:00:04,299 --> 01:00:11,499
there is a problem any testing practice

01:00:09,759 --> 01:00:13,509
that you do follow make sure to take

01:00:11,499 --> 01:00:15,009
full advantage of it if you have

01:00:13,509 --> 01:00:19,109
regression test convert them into the

01:00:15,009 --> 01:00:22,119
refactoring test with if you have

01:00:19,109 --> 01:00:24,969
acceptance tests a random was a

01:00:22,119 --> 01:00:27,279
sanitizer you're not guaranteed to get

01:00:24,969 --> 01:00:28,569
everything but take full advantage of

01:00:27,279 --> 01:00:30,519
what you're already doing you may get

01:00:28,569 --> 01:00:35,890
more than you were getting now basically

01:00:30,519 --> 01:00:37,569
for free and the last thing is be

01:00:35,890 --> 01:00:39,069
practical you're right that a test

01:00:37,569 --> 01:00:43,719
somebody kind of says oh this won't find

01:00:39,069 --> 01:00:47,289
all the bugs no it won't but it's but it

01:00:43,719 --> 01:00:49,900
may find some don't try to keep figure

01:00:47,289 --> 01:00:52,079
out what all the bugs are do what you

01:00:49,900 --> 01:00:52,079
can

01:00:52,859 --> 01:00:55,859
Thanks

01:00:56,349 --> 01:00:58,410

YouTube URL: https://www.youtube.com/watch?v=RoYljVOj2H8


