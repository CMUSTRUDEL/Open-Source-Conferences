Title: CppCon 2019: Klaus Iglberger “Back to Basics: Move Semantics (part 1 of 2)”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Move semantics is one of the most complex topics in the world of C++, including many technical details that often confuse even experts. This interactive back-to-the-basics session is entirely focused on understanding the details behind move semantics. It explains the motivation behind move semantics, the need for rvalue references and std::move, the reason for forwarding references and std::forward, and how to properly apply move semantics. The many interactive questions and exercises will help to quickly adapt the newly gained knowledge.
— 
Klaus Iglberger
Siemens
C++ Trainer/Consultant
Nürnberg Area, Germany

Klaus Iglberger is a freelancing C++ trainer and consultant and is currently on the payroll of Siemens in Nuremberg, Germany. He has finished his PhD in computer science in 2010 and since then is focused on large-scale C++ software design. He shares his experience in popular advanced C++ courses around the world (mainly in Germany, but also the EU and US). Additionally, he is the initiator and lead designer of the Blaze C++ math library (https://bitbucket.org/blaze-lib/blaze/src/master/) and the organizer of the Munich C++ user group (https://www.meetup.com/MUCplusplus/).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,410 --> 00:00:14,900
so welcome ladies and gentlemen welcome

00:00:11,000 --> 00:00:17,480
to back-to-basics move semantics part 1

00:00:14,900 --> 00:00:19,310
I'm classy Chewbacca you can consider me

00:00:17,480 --> 00:00:22,610
your guide into the realm of movement

00:00:19,310 --> 00:00:24,710
move semantics so I kind of expect

00:00:22,610 --> 00:00:26,180
there's two groups of people the first

00:00:24,710 --> 00:00:28,849
group of people as the people who

00:00:26,180 --> 00:00:31,400
potentially do not do not know move

00:00:28,849 --> 00:00:32,269
semantics yet or still struggle with the

00:00:31,400 --> 00:00:34,910
details

00:00:32,269 --> 00:00:37,550
this talk is exactly for you so you were

00:00:34,910 --> 00:00:40,040
very welcome but it's also another group

00:00:37,550 --> 00:00:41,540
of people probably this is the guys that

00:00:40,040 --> 00:00:43,750
already know about move semantics

00:00:41,540 --> 00:00:47,299
potentially even know more than I do

00:00:43,750 --> 00:00:50,059
okay you of course welcome to but I have

00:00:47,299 --> 00:00:52,549
requests so I have a couple of

00:00:50,059 --> 00:00:54,589
interactive questions at least give the

00:00:52,549 --> 00:00:58,850
other group three seconds to think about

00:00:54,589 --> 00:01:03,830
the question and then give it away is it

00:00:58,850 --> 00:01:05,510
okay for you so now if you count the

00:01:03,830 --> 00:01:09,920
three in your head and then said yes we

00:01:05,510 --> 00:01:12,259
have a deal alright perfect so the short

00:01:09,920 --> 00:01:14,350
introduction of myself so as I said I'm

00:01:12,259 --> 00:01:17,210
Klaus I have been a c-plus Serena since

00:01:14,350 --> 00:01:20,270
2016 additionally I'm a senior software

00:01:17,210 --> 00:01:22,399
engineer at Siemens had also know one of

00:01:20,270 --> 00:01:25,100
my work I'm the author of the play C++

00:01:22,399 --> 00:01:27,649
math library and also one of the four

00:01:25,100 --> 00:01:29,659
organizers in the of the Munich C++ user

00:01:27,649 --> 00:01:30,950
group which by the way is truly an

00:01:29,659 --> 00:01:33,649
amazing group if you happen to be in

00:01:30,950 --> 00:01:34,060
Munich any time check it out fascinating

00:01:33,649 --> 00:01:36,649
group

00:01:34,060 --> 00:01:39,710
I'm also record a percentage C plus

00:01:36,649 --> 00:01:42,109
because conferences so this is a talk in

00:01:39,710 --> 00:01:44,329
two parts in the first part we are

00:01:42,109 --> 00:01:46,579
focusing on the deep on the on the

00:01:44,329 --> 00:01:47,990
basics we talk about the basics of move

00:01:46,579 --> 00:01:50,149
semantics the new special member

00:01:47,990 --> 00:01:52,039
functions and parameter conventions

00:01:50,149 --> 00:01:54,499
later in the second part we dive into

00:01:52,039 --> 00:01:58,219
the details this is where it gets

00:01:54,499 --> 00:02:00,259
purpose a little gory all right I have a

00:01:58,219 --> 00:02:02,539
couple of thank-yous I want to thank

00:02:00,259 --> 00:02:04,100
Scott Myers Nicolai Hugh suitors this is

00:02:02,539 --> 00:02:05,840
the two guys I learned move semantics

00:02:04,100 --> 00:02:07,759
from so if you have the opportunity

00:02:05,840 --> 00:02:10,220
check out the teach material this is

00:02:07,759 --> 00:02:11,810
really great and I also want to thank

00:02:10,220 --> 00:02:13,760
how I didn't

00:02:11,810 --> 00:02:16,459
is kind of the mental father of move

00:02:13,760 --> 00:02:18,140
semantics so if it wouldn't be up if you

00:02:16,459 --> 00:02:19,520
wouldn't be then I wouldn't have

00:02:18,140 --> 00:02:23,810
anything to tell you today

00:02:19,520 --> 00:02:25,970
all right let's first of all motivate

00:02:23,810 --> 00:02:29,540
this let's go to the real basics what

00:02:25,970 --> 00:02:32,769
are we about to do let's imagine that we

00:02:29,540 --> 00:02:35,239
have a vector of integers quite simple

00:02:32,769 --> 00:02:38,569
this vector would be represented like

00:02:35,239 --> 00:02:42,319
this the vector itself the static part

00:02:38,569 --> 00:02:44,390
is just three pointers to int there's a

00:02:42,319 --> 00:02:46,760
couple of addresses of course and then

00:02:44,390 --> 00:02:49,090
there's the dynamic parts 1 2 3 4 5 this

00:02:46,760 --> 00:02:53,060
is somewhere on the hiepro free store

00:02:49,090 --> 00:02:56,269
now I have a second vector v2 it's empty

00:02:53,060 --> 00:03:00,080
at this point n is so at this point it

00:02:56,269 --> 00:03:02,180
is just a yeah just the stack part all

00:03:00,080 --> 00:03:08,209
the addresses have been zeroed out all

00:03:02,180 --> 00:03:12,430
the pointers now I assign v1 to v2 now

00:03:08,209 --> 00:03:12,430
what do we expect to happen Oh question

00:03:14,440 --> 00:03:21,230
all right the question is what are the

00:03:18,470 --> 00:03:23,500
second two pointers so by the way if you

00:03:21,230 --> 00:03:26,299
have a question please any time but

00:03:23,500 --> 00:03:27,980
prefer preferably use the microphone

00:03:26,299 --> 00:03:30,680
it's much easier much better for the

00:03:27,980 --> 00:03:32,600
recording and of course then I don't

00:03:30,680 --> 00:03:34,640
have to repeat the question the second

00:03:32,600 --> 00:03:36,260
two pointers so the first point of

00:03:34,640 --> 00:03:38,810
points to the very first element this is

00:03:36,260 --> 00:03:41,359
the beginning pointer the second pointer

00:03:38,810 --> 00:03:43,639
basically represents end and the third

00:03:41,359 --> 00:03:46,100
pointer in this case exactly the same

00:03:43,639 --> 00:03:47,720
thing would represent the very end of

00:03:46,100 --> 00:03:48,980
the memory that you have this is

00:03:47,720 --> 00:03:51,170
something you could use to compute a

00:03:48,980 --> 00:03:54,049
capacity yeah all right

00:03:51,170 --> 00:03:57,650
all of them are zero at this point now I

00:03:54,049 --> 00:03:59,930
assign v1 to v2 what we want to happen

00:03:57,650 --> 00:04:02,959
this case is something called a deep

00:03:59,930 --> 00:04:05,840
copy we want to have an exact replica of

00:04:02,959 --> 00:04:08,180
v1 and this is absolutely reasonable

00:04:05,840 --> 00:04:10,459
because this makes our code easy to

00:04:08,180 --> 00:04:12,139
understand easy to comprehend we take a

00:04:10,459 --> 00:04:14,359
look at this and we know that afterwards

00:04:12,139 --> 00:04:17,359
we do not have to take care of any kind

00:04:14,359 --> 00:04:19,940
of shearing so we want to have a real

00:04:17,359 --> 00:04:23,570
copy a deep copy despite my call to move

00:04:19,940 --> 00:04:25,370
value semantics let's do another example

00:04:23,570 --> 00:04:27,470
let's say we have

00:04:25,370 --> 00:04:30,380
a function create vector that is

00:04:27,470 --> 00:04:34,940
returning a vector and again I have an

00:04:30,380 --> 00:04:38,770
empty vector v2 v2 again is just an

00:04:34,940 --> 00:04:42,440
empty vector zero dog pointers inside

00:04:38,770 --> 00:04:45,620
let's assume we directly assigned create

00:04:42,440 --> 00:04:47,600
vector to V now the first thing that

00:04:45,620 --> 00:04:50,479
happens is that of course I return a

00:04:47,600 --> 00:04:53,810
vector from the function that function

00:04:50,479 --> 00:04:55,699
is well that that value is something I

00:04:53,810 --> 00:04:58,370
don't really have a name for I call it

00:04:55,699 --> 00:04:59,930
temp and it is created by something that

00:04:58,370 --> 00:05:02,030
we can ignore the return value

00:04:59,930 --> 00:05:04,970
optimisation now it's somewhere in the

00:05:02,030 --> 00:05:05,360
calling scope of this of this function

00:05:04,970 --> 00:05:09,310
call

00:05:05,360 --> 00:05:11,780
now this one is assigned to beat you but

00:05:09,310 --> 00:05:14,720
do we really want to create a deep copy

00:05:11,780 --> 00:05:17,180
at this point oh this would be a shame

00:05:14,720 --> 00:05:19,039
because of course if you do a deep copy

00:05:17,180 --> 00:05:20,900
temp will be destroyed at the end of the

00:05:19,039 --> 00:05:23,930
statement and we have wasted a lot of

00:05:20,900 --> 00:05:25,820
energy that is not what we want to do

00:05:23,930 --> 00:05:27,680
what we would really want to do is

00:05:25,820 --> 00:05:30,289
actually we would like to transfer the

00:05:27,680 --> 00:05:34,310
content of Tim to v2 in a very simple

00:05:30,289 --> 00:05:37,130
way we simply want to well first of all

00:05:34,310 --> 00:05:39,800
copy the pointers that's the first step

00:05:37,130 --> 00:05:42,110
we cannot stop there at however because

00:05:39,800 --> 00:05:44,570
at this point there would be two vectors

00:05:42,110 --> 00:05:46,400
owning the same memory they do not know

00:05:44,570 --> 00:05:48,410
what about each other and deleting the

00:05:46,400 --> 00:05:50,870
memory then of course Forex havoc now

00:05:48,410 --> 00:05:52,729
the second step is we have to remove the

00:05:50,870 --> 00:05:54,380
pointers of the first one and for

00:05:52,729 --> 00:05:56,860
instance you set the pointers of the

00:05:54,380 --> 00:06:00,110
first so this temp vector to zeros

00:05:56,860 --> 00:06:02,660
that's great because this is very cheap

00:06:00,110 --> 00:06:06,979
this is so cheap that we do not really

00:06:02,660 --> 00:06:09,320
think about it as in operation itself so

00:06:06,979 --> 00:06:11,840
the idea is do the minimum amount of

00:06:09,320 --> 00:06:14,419
work to transfer temp into v2 and of

00:06:11,840 --> 00:06:17,210
course at the end of the statement okay

00:06:14,419 --> 00:06:20,450
by the way note this is only possible

00:06:17,210 --> 00:06:23,150
this kind of optimization because nobody

00:06:20,450 --> 00:06:25,820
knows about this temp except for this

00:06:23,150 --> 00:06:27,979
assignment operation no one all else

00:06:25,820 --> 00:06:30,530
holds reference to temp if there would

00:06:27,979 --> 00:06:33,260
be somebody else holding reference then

00:06:30,530 --> 00:06:34,669
we would have a problem all right at the

00:06:33,260 --> 00:06:36,950
end of the statement however temp of

00:06:34,669 --> 00:06:39,409
course goes out of scope and now the

00:06:36,950 --> 00:06:43,039
final result the vector we created

00:06:39,409 --> 00:06:43,749
in viju perfect now you already start to

00:06:43,039 --> 00:06:49,179
like it

00:06:43,749 --> 00:06:51,319
hey this is something that is cool so

00:06:49,179 --> 00:06:55,219
why don't we apply this to the first

00:06:51,319 --> 00:06:57,679
example well of course in this case we

00:06:55,219 --> 00:06:59,479
would have a problem in the code we

00:06:57,679 --> 00:07:01,429
would not see that v1 is transferred to

00:06:59,479 --> 00:07:03,589
v2 and this is the kind of the wrong

00:07:01,429 --> 00:07:06,110
word semantics but we can do something

00:07:03,589 --> 00:07:08,499
about this if indeed you're interested

00:07:06,110 --> 00:07:13,099
to transfer the content of e 2 into V 2

00:07:08,499 --> 00:07:16,939
V 1 into V 2 and all we need to do is to

00:07:13,099 --> 00:07:20,389
use move still move is now basically

00:07:16,939 --> 00:07:22,999
telling us this is a transfer of content

00:07:20,389 --> 00:07:25,610
so we'll take a look at the details

00:07:22,999 --> 00:07:28,159
later but at this point we basically

00:07:25,610 --> 00:07:31,489
proclaim we want to transfer from V 1 to

00:07:28,159 --> 00:07:34,579
V 2 and we do exactly the same as before

00:07:31,489 --> 00:07:36,769
we first of all copy the pointers and

00:07:34,579 --> 00:07:39,139
the second step is again we just delete

00:07:36,769 --> 00:07:46,459
the pointers not delete we set them to 0

00:07:39,139 --> 00:07:48,319
in V 1 V 1 however in this case lives on

00:07:46,459 --> 00:07:49,819
a little longer so but this is the

00:07:48,319 --> 00:07:52,550
detail so if you take a look at later

00:07:49,819 --> 00:07:55,009
right now just remember V 1 is still

00:07:52,550 --> 00:07:56,240
alive it will be an empty vector for

00:07:55,009 --> 00:08:00,740
quite some time

00:07:56,240 --> 00:08:03,909
well until the end of some scope all

00:08:00,740 --> 00:08:06,679
right let's take a look at the details

00:08:03,909 --> 00:08:10,249
on the left-hand side again we we now

00:08:06,679 --> 00:08:12,019
see the vector standard vector which is

00:08:10,249 --> 00:08:13,579
small excerpt from standard vector and

00:08:12,019 --> 00:08:16,339
and alright we see the example that we

00:08:13,579 --> 00:08:19,849
saw before the first statement that we

00:08:16,339 --> 00:08:25,849
analyzed was this one we P is equal to V

00:08:19,849 --> 00:08:29,300
1 now this is the V 1 is now something

00:08:25,849 --> 00:08:31,759
called an l-value am i now he's starting

00:08:29,300 --> 00:08:33,800
with technical terms okay let's clarify

00:08:31,759 --> 00:08:35,509
the technical terms first at least a

00:08:33,800 --> 00:08:37,550
little bit there's more back to basics

00:08:35,509 --> 00:08:40,789
talks that go much into the into more

00:08:37,550 --> 00:08:43,519
detail here l value and that's also

00:08:40,789 --> 00:08:45,800
something called an r-value this is what

00:08:43,519 --> 00:08:48,079
people usually a little confused about

00:08:45,800 --> 00:08:50,889
so there's a historic reason why they're

00:08:48,079 --> 00:08:52,520
called L&R value the L in this

00:08:50,889 --> 00:08:55,250
assignment that is

00:08:52,520 --> 00:08:57,980
l value simply because it appears on the

00:08:55,250 --> 00:09:00,370
left of the assignment and the other

00:08:57,980 --> 00:09:03,140
thing they are that is an R value

00:09:00,370 --> 00:09:06,020
because it appears on the right strictly

00:09:03,140 --> 00:09:07,670
speaking an R value can only be on the

00:09:06,020 --> 00:09:09,530
right of the assignment and elderly

00:09:07,670 --> 00:09:12,500
could theoretically also be on the on

00:09:09,530 --> 00:09:14,330
the right side but well an elderly can

00:09:12,500 --> 00:09:17,360
be on the left side so it has a certain

00:09:14,330 --> 00:09:18,680
name this is however only the historical

00:09:17,360 --> 00:09:21,440
thing this is where the name comes from

00:09:18,680 --> 00:09:23,150
do not really remember this from an C++

00:09:21,440 --> 00:09:26,060
point of view unfortunately it does not

00:09:23,150 --> 00:09:29,960
work well anymore I give you a simple

00:09:26,060 --> 00:09:32,450
example and say we have a string when s

00:09:29,960 --> 00:09:34,430
plus s is equal to s is actually valid

00:09:32,450 --> 00:09:36,590
code it will compile will not do

00:09:34,430 --> 00:09:39,680
something reasonable but it is valid

00:09:36,590 --> 00:09:44,470
code and it is kind of reversed because

00:09:39,680 --> 00:09:48,040
now the S on the right is an L value and

00:09:44,470 --> 00:09:50,780
on the left actually we have an R value

00:09:48,040 --> 00:09:52,640
so it's kind of reversed it's pretty

00:09:50,780 --> 00:09:56,600
unnatural it's pretty surprising again

00:09:52,640 --> 00:09:58,100
but there's a much better rule for C++

00:09:56,600 --> 00:10:03,320
something that he can remember and

00:09:58,100 --> 00:10:06,020
networks absolutely fascinating well the

00:10:03,320 --> 00:10:08,630
thing on the right the S is now value

00:10:06,020 --> 00:10:11,120
because it has a name a name that you

00:10:08,630 --> 00:10:14,720
have chosen and identifiers that you

00:10:11,120 --> 00:10:16,880
have to liberally yeah put in to put

00:10:14,720 --> 00:10:19,490
those chosen for this variable and L

00:10:16,880 --> 00:10:21,800
value now on the left however you have

00:10:19,490 --> 00:10:24,890
an R value because it does not have a

00:10:21,800 --> 00:10:26,990
name so the result of s plus s this

00:10:24,890 --> 00:10:29,320
temporary you did should not choose a

00:10:26,990 --> 00:10:32,750
name for and hence it is an R value

00:10:29,320 --> 00:10:36,770
that's the entire difference between l

00:10:32,750 --> 00:10:41,030
and r value now v1 has a name hence it

00:10:36,770 --> 00:10:43,250
is an l-value an l varies well okay they

00:10:41,030 --> 00:10:45,320
bind to the assignment operator

00:10:43,250 --> 00:10:47,150
laticia on the left that is perfectly

00:10:45,320 --> 00:10:49,520
key this assignment operator now would

00:10:47,150 --> 00:10:50,870
do a copy because it assumes that you

00:10:49,520 --> 00:10:54,230
indeed want to have this copy

00:10:50,870 --> 00:10:58,910
everything's fine now let's go to the

00:10:54,230 --> 00:11:01,270
second assignment create vectors V 2 is

00:10:58,910 --> 00:11:04,700
equal to create vector

00:11:01,270 --> 00:11:08,120
prior to C++ 11 this would actually have

00:11:04,700 --> 00:11:10,370
created a copy so it is in our value we

00:11:08,120 --> 00:11:11,810
said this before prior to see plus 11

00:11:10,370 --> 00:11:13,940
news would actually have created a copy

00:11:11,810 --> 00:11:16,790
because there's only one assignment

00:11:13,940 --> 00:11:19,370
operator for that case and that is I

00:11:16,790 --> 00:11:22,220
have to say was the essential problem

00:11:19,370 --> 00:11:24,200
I cannot distinguish I could not

00:11:22,220 --> 00:11:27,110
distinguish between the first case in

00:11:24,200 --> 00:11:29,780
the second case the first case the L

00:11:27,110 --> 00:11:31,310
value is copied the second case well I

00:11:29,780 --> 00:11:32,750
want to deal it with is differently but

00:11:31,310 --> 00:11:33,860
unfortunately as long as there's only

00:11:32,750 --> 00:11:36,890
one assignment operator

00:11:33,860 --> 00:11:38,810
it would also do a copy for that reason

00:11:36,890 --> 00:11:43,400
they introduced what you probably have

00:11:38,810 --> 00:11:45,980
seen before arveleï references so using

00:11:43,400 --> 00:11:49,010
two ampersands for a reference makes it

00:11:45,980 --> 00:11:50,780
a so-called arveleï reference an R value

00:11:49,010 --> 00:11:53,600
reference does exactly what it expect

00:11:50,780 --> 00:11:55,010
this arveleï reference takes our values

00:11:53,600 --> 00:11:57,620
so our values

00:11:55,010 --> 00:12:00,320
bind to r-value references l values

00:11:57,620 --> 00:12:03,320
naturally bind to l value references so

00:12:00,320 --> 00:12:05,000
with our value reference in play the

00:12:03,320 --> 00:12:06,910
other kind of reference is just called

00:12:05,000 --> 00:12:10,940
our value reference l value reference

00:12:06,910 --> 00:12:12,710
and now with an R value reference we

00:12:10,940 --> 00:12:14,900
have actually something to make a

00:12:12,710 --> 00:12:17,990
difference so the R value can now bind

00:12:14,900 --> 00:12:20,060
to the R value reference and this

00:12:17,990 --> 00:12:22,880
function knows about the fact that it is

00:12:20,060 --> 00:12:25,280
an R value this function now can assume

00:12:22,880 --> 00:12:27,560
that you want this to be transferred

00:12:25,280 --> 00:12:30,080
well it's temporary or anyway a

00:12:27,560 --> 00:12:32,360
temporary that is not needed afterwards

00:12:30,080 --> 00:12:35,090
and as I said before there's exactly one

00:12:32,360 --> 00:12:37,880
reference to this kind of fact is so

00:12:35,090 --> 00:12:41,090
this particular temporary so I can do a

00:12:37,880 --> 00:12:46,490
move so this operator the one that takes

00:12:41,090 --> 00:12:50,150
an R value reference moves all right now

00:12:46,490 --> 00:12:53,390
let's take a look at the third one we

00:12:50,150 --> 00:13:01,390
want is okay question to you what kind

00:12:53,390 --> 00:13:04,130
of value an L value it has a name

00:13:01,390 --> 00:13:07,700
however the move operation now makes it

00:13:04,130 --> 00:13:10,940
in our value I basically declare please

00:13:07,700 --> 00:13:12,040
treat this v1 as if it would be in our

00:13:10,940 --> 00:13:14,420
value

00:13:12,040 --> 00:13:17,380
officially not to confuse you but

00:13:14,420 --> 00:13:21,140
officially this isn't called an x-value

00:13:17,380 --> 00:13:24,200
one more term expiring value it's

00:13:21,140 --> 00:13:26,120
basically just for the c++ guys to have

00:13:24,200 --> 00:13:29,690
some vocabulary to deal with this

00:13:26,120 --> 00:13:32,540
explicitly but basically make v1 now

00:13:29,690 --> 00:13:35,240
some kind of our value because we deal

00:13:32,540 --> 00:13:37,580
with this as an r-value it will bind to

00:13:35,240 --> 00:13:41,029
the r-value reference exactly where we

00:13:37,580 --> 00:13:43,430
want it to be so it will be treated as

00:13:41,029 --> 00:13:46,420
non value and I move the content off we

00:13:43,430 --> 00:13:52,610
one into v2

00:13:46,420 --> 00:13:55,160
now we one is well still alive it lifts

00:13:52,610 --> 00:13:57,560
on we have transferred the content from

00:13:55,160 --> 00:14:01,279
we one into v2 great this is what we

00:13:57,560 --> 00:14:03,709
wanted but we one lives on it has a name

00:14:01,279 --> 00:14:05,270
you can still use it afterwards and this

00:14:03,709 --> 00:14:08,600
makes it to some extent a little

00:14:05,270 --> 00:14:11,450
dangerous so officially the standard

00:14:08,600 --> 00:14:14,540
says this is a move from object I moved

00:14:11,450 --> 00:14:16,370
from basically says don't use it anymore

00:14:14,540 --> 00:14:18,560
yeah okay if you know a little more

00:14:16,370 --> 00:14:21,110
perhaps you have some ideas how to

00:14:18,560 --> 00:14:23,360
misuse it of course but the general

00:14:21,110 --> 00:14:25,610
advice would be just leave it be just

00:14:23,360 --> 00:14:26,690
wait until it naturally dies so at the

00:14:25,610 --> 00:14:28,070
end of its scope it will be just

00:14:26,690 --> 00:14:30,529
probably destroyed we it's destructor

00:14:28,070 --> 00:14:31,100
but don't do anything special with it

00:14:30,529 --> 00:14:33,440
anymore

00:14:31,100 --> 00:14:35,540
officially there's only three operations

00:14:33,440 --> 00:14:37,670
that you allowed to use on a move from

00:14:35,540 --> 00:14:42,230
object the first one happens implicitly

00:14:37,670 --> 00:14:43,970
that is the destructor the destructor of

00:14:42,230 --> 00:14:45,860
course will eventually be called and

00:14:43,970 --> 00:14:48,260
then as two other operations that he can

00:14:45,860 --> 00:14:50,510
do deliberately the first one is a copy

00:14:48,260 --> 00:14:52,490
assignment and a second one is a move

00:14:50,510 --> 00:14:54,800
assignment so you can assign to this

00:14:52,490 --> 00:14:56,839
thing again and suddenly becomes a valid

00:14:54,800 --> 00:14:59,959
object again you can again use it you

00:14:56,839 --> 00:15:02,450
can work with this properly but as long

00:14:59,959 --> 00:15:06,230
as you did not reassign it just leave it

00:15:02,450 --> 00:15:08,959
be the interesting question would be

00:15:06,230 --> 00:15:10,640
what does it move - how does move look

00:15:08,959 --> 00:15:13,310
like and you might be surprised to find

00:15:10,640 --> 00:15:16,300
that move is actually pretty simple

00:15:13,310 --> 00:15:16,300
this is move

00:15:17,740 --> 00:15:24,790
a move is essentially a steady cast okay

00:15:22,090 --> 00:15:27,870
so steady cast to bla bla bla bla ref

00:15:24,790 --> 00:15:29,230
ref and this is also what move returns

00:15:27,870 --> 00:15:32,410
bla bla bla

00:15:29,230 --> 00:15:35,440
ref ref so a move returns and our Valley

00:15:32,410 --> 00:15:39,280
reference it does not really move

00:15:35,440 --> 00:15:40,900
anything the only thing it does is it

00:15:39,280 --> 00:15:42,790
makes whatever you give it to an R value

00:15:40,900 --> 00:15:45,130
reference and henceforward is treated as

00:15:42,790 --> 00:15:47,710
an R value and therefore it binds to for

00:15:45,130 --> 00:15:51,070
instance the dis move constructor

00:15:47,710 --> 00:15:54,070
I move for Simon operator so move does

00:15:51,070 --> 00:15:56,200
not really move anything the usual

00:15:54,070 --> 00:15:58,720
question is does the compiler give me

00:15:56,200 --> 00:16:01,510
any warnings when I try to use something

00:15:58,720 --> 00:16:03,970
that is moved from now the compiler will

00:16:01,510 --> 00:16:09,000
be absolutely silent of this about this

00:16:03,970 --> 00:16:12,640
and as a simple reason static cast a

00:16:09,000 --> 00:16:14,950
cast is as you know an adult feature you

00:16:12,640 --> 00:16:16,960
know better than the compiler and if the

00:16:14,950 --> 00:16:19,050
compiler says well you know better then

00:16:16,960 --> 00:16:21,940
he will not worry about any misuse later

00:16:19,050 --> 00:16:23,710
so you are on your own here except of

00:16:21,940 --> 00:16:25,540
course that there's other tools so

00:16:23,710 --> 00:16:28,360
static code analysis tools might warn

00:16:25,540 --> 00:16:30,490
you about some access to some use of a

00:16:28,360 --> 00:16:35,320
move from object the compiler will not

00:16:30,490 --> 00:16:37,660
thanks to static cast all right so now

00:16:35,320 --> 00:16:40,090
you understand that move indeed does not

00:16:37,660 --> 00:16:42,640
really move anything but that this make

00:16:40,090 --> 00:16:45,220
a difference in terms of semantics it is

00:16:42,640 --> 00:16:47,470
a semantic transfer of ownership so some

00:16:45,220 --> 00:16:48,820
people actually argue that it should not

00:16:47,470 --> 00:16:51,370
be called move but something like

00:16:48,820 --> 00:16:53,680
transfer content transfer ownership

00:16:51,370 --> 00:16:56,290
would be much longer name move is

00:16:53,680 --> 00:16:58,900
probably a little nicer but this is the

00:16:56,290 --> 00:17:01,120
semantically part about it it is a move

00:16:58,900 --> 00:17:03,610
from a semantic point of view a transfer

00:17:01,120 --> 00:17:07,380
of content it is not a physical move

00:17:03,610 --> 00:17:07,380
nothing physically moves anywhere

00:17:07,440 --> 00:17:13,600
alright

00:17:08,860 --> 00:17:15,730
a short summary in between so containers

00:17:13,600 --> 00:17:17,320
in C++ employ value semantics this is

00:17:15,730 --> 00:17:19,150
something that we desire this makes our

00:17:17,320 --> 00:17:21,670
code easy to understand easy to

00:17:19,150 --> 00:17:23,890
comprehend we do not have to figure out

00:17:21,670 --> 00:17:26,500
where is sharing happening under the

00:17:23,890 --> 00:17:28,330
hood in presea plus 11 this little led

00:17:26,500 --> 00:17:30,410
of course to a lot of potentially

00:17:28,330 --> 00:17:32,540
expensive copy operations

00:17:30,410 --> 00:17:33,740
thanks to the introduction to our Valley

00:17:32,540 --> 00:17:35,510
references now we are able to

00:17:33,740 --> 00:17:37,160
distinguish between our ell values and

00:17:35,510 --> 00:17:39,170
our varies and became therefore react

00:17:37,160 --> 00:17:40,760
accordingly we can deal with ell valleys

00:17:39,170 --> 00:17:44,000
differently that we can deal with our

00:17:40,760 --> 00:17:46,580
valleys and arveleï references basically

00:17:44,000 --> 00:17:49,240
just represent modifiable objects that

00:17:46,580 --> 00:17:51,380
you do not know that you no longer need

00:17:49,240 --> 00:17:53,570
temporaries all the things that you have

00:17:51,380 --> 00:17:55,460
explicitly declared to be temporary and

00:17:53,570 --> 00:17:57,170
basically as politically said I don't

00:17:55,460 --> 00:18:01,520
need this anymore please transfer

00:17:57,170 --> 00:18:04,610
content please optimize alright now

00:18:01,520 --> 00:18:08,390
let's take a look at some implementation

00:18:04,610 --> 00:18:10,610
details there is two functions that you

00:18:08,390 --> 00:18:13,880
need to make this entire magic happening

00:18:10,610 --> 00:18:16,340
and these two functions I show in an

00:18:13,880 --> 00:18:19,240
example of a widget class so class

00:18:16,340 --> 00:18:21,740
widget has three data members an int

00:18:19,240 --> 00:18:25,010
it's a representative of a fundamental

00:18:21,740 --> 00:18:27,020
type a string as a representative of a

00:18:25,010 --> 00:18:29,120
class type and a unique pointer

00:18:27,020 --> 00:18:31,250
admittedly also class type but a special

00:18:29,120 --> 00:18:31,810
one it's a pointer type reference

00:18:31,250 --> 00:18:34,460
Mandrax

00:18:31,810 --> 00:18:37,190
and the two functions that I mentioned

00:18:34,460 --> 00:18:39,860
is these two the Move constructor and

00:18:37,190 --> 00:18:42,080
the Move assignment operator this is the

00:18:39,860 --> 00:18:43,970
two functions that are now also added to

00:18:42,080 --> 00:18:46,010
the set of special member functions so

00:18:43,970 --> 00:18:49,100
now in total we have six the default

00:18:46,010 --> 00:18:50,750
constructor the two copy operations that

00:18:49,100 --> 00:18:54,050
remove operations the new ones and of

00:18:50,750 --> 00:18:56,180
course the destructor the canonical

00:18:54,050 --> 00:18:59,420
syntax for these two or canonical

00:18:56,180 --> 00:19:01,010
signature of these two functions is one

00:18:59,420 --> 00:19:05,080
argument of exactly the type of the

00:19:01,010 --> 00:19:07,520
function a function is class ref ref

00:19:05,080 --> 00:19:09,980
this is indeed the canonical signature

00:19:07,520 --> 00:19:11,960
there's not a lot not a lot of

00:19:09,980 --> 00:19:14,720
difference you can make you can actually

00:19:11,960 --> 00:19:17,960
add a Const air but it does not really

00:19:14,720 --> 00:19:20,690
help you the purpose is that I do modify

00:19:17,960 --> 00:19:23,690
the object that I'm given so well a

00:19:20,690 --> 00:19:25,580
consistent help and as soon as you leave

00:19:23,690 --> 00:19:27,050
out any reference it would be the copy

00:19:25,580 --> 00:19:29,320
constructor or the copy assignment

00:19:27,050 --> 00:19:33,170
operator so this is indeed the canonical

00:19:29,320 --> 00:19:36,680
signature for this cars actually life is

00:19:33,170 --> 00:19:39,050
easy you simply can define these to

00:19:36,680 --> 00:19:40,430
default or perhaps even leave it to the

00:19:39,050 --> 00:19:43,970
compiler you do not have to explicitly

00:19:40,430 --> 00:19:47,090
mentioning them this is great

00:19:43,970 --> 00:19:50,929
all of the things that all of the data

00:19:47,090 --> 00:19:53,539
members are properly moveable the int

00:19:50,929 --> 00:19:55,250
okay this is fundamental the string also

00:19:53,539 --> 00:19:57,139
knows how to transfer content to some

00:19:55,250 --> 00:19:59,690
other string and also the unique pointer

00:19:57,139 --> 00:20:01,580
is equipped with the right functions so

00:19:59,690 --> 00:20:05,480
this is exactly what you would like to

00:20:01,580 --> 00:20:09,529
have this is the best possible situation

00:20:05,480 --> 00:20:11,539
there's a name for this so the coq

00:20:09,529 --> 00:20:13,159
there's a coca at length C 24 that if

00:20:11,539 --> 00:20:16,580
you can avoid defining default

00:20:13,159 --> 00:20:19,129
operations do and this core guideline

00:20:16,580 --> 00:20:21,080
also mentions the in official perhaps

00:20:19,129 --> 00:20:23,419
even official name for this the rule of

00:20:21,080 --> 00:20:25,340
zero this is where you want to live this

00:20:23,419 --> 00:20:27,860
is what you usually want to use your

00:20:25,340 --> 00:20:31,370
life is easy your life is yeah

00:20:27,860 --> 00:20:33,110
comfortable let's for the sake of this

00:20:31,370 --> 00:20:34,820
talk of course let's assume that I have

00:20:33,110 --> 00:20:36,919
to do something extra so let's assume

00:20:34,820 --> 00:20:40,549
for instance that the unit pointer is

00:20:36,919 --> 00:20:43,490
just a pointer and suddenly our life

00:20:40,549 --> 00:20:46,190
gets much much more complicated because

00:20:43,490 --> 00:20:48,289
now we actually have to deal with these

00:20:46,190 --> 00:20:50,269
two functions we can no longer make them

00:20:48,289 --> 00:20:52,700
default we have to implement them

00:20:50,269 --> 00:20:55,399
ourselves in order to make this work

00:20:52,700 --> 00:20:58,220
properly and let's take a look at the

00:20:55,399 --> 00:21:03,590
implementation details first of all of

00:20:58,220 --> 00:21:05,990
the move constructor well the goal of

00:21:03,590 --> 00:21:09,440
the move constructor is to transfer the

00:21:05,990 --> 00:21:14,059
content of the given object W into this

00:21:09,440 --> 00:21:16,070
object and of course we want to leave W

00:21:14,059 --> 00:21:19,220
so the passed object in a valid but

00:21:16,070 --> 00:21:21,679
undefined state so this does not sound

00:21:19,220 --> 00:21:23,899
great of course undefined is always

00:21:21,679 --> 00:21:26,029
something that is a little vague this

00:21:23,899 --> 00:21:27,980
basically means it can be any state it

00:21:26,029 --> 00:21:31,039
must be a valid state but we cannot

00:21:27,980 --> 00:21:33,169
predict the state that it will be in all

00:21:31,039 --> 00:21:36,620
right how do we achieve these goals the

00:21:33,169 --> 00:21:36,889
first step is probably just to copy the

00:21:36,620 --> 00:21:40,879
int

00:21:36,889 --> 00:21:43,639
okay no ill here no ill effect

00:21:40,879 --> 00:21:46,610
everything is working then well let's do

00:21:43,639 --> 00:21:48,879
this with a string too so let's move the

00:21:46,610 --> 00:21:48,879
string

00:21:51,139 --> 00:21:55,620
okay now a couple of people promise you

00:21:53,639 --> 00:21:58,500
know about this probably fainted now

00:21:55,620 --> 00:22:02,820
unfortunately this is not what we might

00:21:58,500 --> 00:22:05,880
believe it is in this line you actually

00:22:02,820 --> 00:22:11,130
do not move the string what do we do

00:22:05,880 --> 00:22:12,929
with the string we copy the string and

00:22:11,130 --> 00:22:14,700
this is exactly what we do not want to

00:22:12,929 --> 00:22:18,210
do we want of course to be as efficient

00:22:14,700 --> 00:22:23,630
as possible we would like it to move why

00:22:18,210 --> 00:22:23,630
doesn't it move who knows

00:22:24,200 --> 00:22:32,730
correct the string has a name pad also

00:22:30,120 --> 00:22:36,260
that W has a name so the widget that I'm

00:22:32,730 --> 00:22:40,440
passing has a name and because of that

00:22:36,260 --> 00:22:42,899
it is simply an L value and an L value

00:22:40,440 --> 00:22:45,480
is something that I cannot or should not

00:22:42,899 --> 00:22:49,549
move of course an L value since it has a

00:22:45,480 --> 00:22:51,929
name is still needed hence I do a copy

00:22:49,549 --> 00:22:53,450
however there's of course an easy

00:22:51,929 --> 00:22:56,370
workaround

00:22:53,450 --> 00:22:58,620
okay I should perhaps point out this

00:22:56,370 --> 00:23:00,419
this mystery here so yes it is an

00:22:58,620 --> 00:23:03,240
elderly that type however of course

00:23:00,419 --> 00:23:08,510
suggests differently which it refresh

00:23:03,240 --> 00:23:11,580
this is I admit a little confusing art

00:23:08,510 --> 00:23:15,299
reference tune our our value reference

00:23:11,580 --> 00:23:17,340
and then it still is nail value it may

00:23:15,299 --> 00:23:19,370
be confusing but it's easy to explain if

00:23:17,340 --> 00:23:22,769
you think about it like this

00:23:19,370 --> 00:23:25,529
it is indeed an R value in the calling

00:23:22,769 --> 00:23:27,750
scope at the point where we call its

00:23:25,529 --> 00:23:30,059
function it is an R value else we would

00:23:27,750 --> 00:23:32,460
not end up in this function however

00:23:30,059 --> 00:23:35,370
inside the function it needs to be an L

00:23:32,460 --> 00:23:37,260
value again if it wouldn't really if we

00:23:35,370 --> 00:23:40,470
do and half a name we could not use it

00:23:37,260 --> 00:23:42,990
and so well it has to be an elderly

00:23:40,470 --> 00:23:46,559
again but we can easily make this work

00:23:42,990 --> 00:23:48,450
again by using move we explicitly move

00:23:46,559 --> 00:23:51,000
the string to the other string and this

00:23:48,450 --> 00:23:52,889
is perfectly fine because we know thanks

00:23:51,000 --> 00:23:56,190
to the type that it actually is in our

00:23:52,889 --> 00:24:00,269
value so ultimately this is now moving

00:23:56,190 --> 00:24:02,690
the string properly now I apply the same

00:24:00,269 --> 00:24:05,749
operation or also to the int

00:24:02,690 --> 00:24:09,889
no it does not make any difference the

00:24:05,749 --> 00:24:12,470
int is still just copied there's no

00:24:09,889 --> 00:24:16,369
speed up at all however it is a nice and

00:24:12,470 --> 00:24:18,799
a pretty reasonable convention just move

00:24:16,369 --> 00:24:20,989
all your data members regardless of

00:24:18,799 --> 00:24:24,379
whether this is int so fundamental types

00:24:20,989 --> 00:24:28,039
or class types then it's first of all

00:24:24,379 --> 00:24:30,739
very heterogeneous and second of all in

00:24:28,039 --> 00:24:32,539
case you might see this in the remainder

00:24:30,739 --> 00:24:34,789
of this talk in case you change the type

00:24:32,539 --> 00:24:38,419
of this I you not have to go back here

00:24:34,789 --> 00:24:40,519
and and basically fix the code it will

00:24:38,419 --> 00:24:40,879
always work it will never do the wrong

00:24:40,519 --> 00:24:43,509
thing

00:24:40,879 --> 00:24:45,830
and so this is why I acquire this

00:24:43,509 --> 00:24:47,570
conventional in for the remainder of the

00:24:45,830 --> 00:24:50,359
talk all right

00:24:47,570 --> 00:24:52,129
and of course I also move the pointer

00:24:50,359 --> 00:24:53,809
it's not really moved it's also just

00:24:52,129 --> 00:24:57,109
copied there's nothing I can do better

00:24:53,809 --> 00:25:00,019
than copying it but as I said I know

00:24:57,109 --> 00:25:03,470
used to use convention we're not quite

00:25:00,019 --> 00:25:05,899
done yet I copied the pointer

00:25:03,470 --> 00:25:09,859
essentially but unfortunately at this

00:25:05,899 --> 00:25:12,019
point we have two objects that point to

00:25:09,859 --> 00:25:13,879
the same memory and the basic assumption

00:25:12,019 --> 00:25:16,909
of this widget is that this pointers in

00:25:13,879 --> 00:25:19,039
owning pointer so now I would have to

00:25:16,909 --> 00:25:22,159
destructors that would destroy the same

00:25:19,039 --> 00:25:23,809
content and this is bad so there's an

00:25:22,159 --> 00:25:26,809
absolutely necessary

00:25:23,809 --> 00:25:29,799
further line we have to explicitly set

00:25:26,809 --> 00:25:35,499
the pointer of the W budget to know

00:25:29,799 --> 00:25:35,499
without this it would break pretty badly

00:25:36,309 --> 00:25:43,070
now you might think okay so by the way

00:25:39,799 --> 00:25:44,869
we have now first of all resolved our

00:25:43,070 --> 00:25:47,889
first goal we have now effectively

00:25:44,869 --> 00:25:51,019
transferred the content of W into this

00:25:47,889 --> 00:25:52,669
now we're there the entire content of

00:25:51,019 --> 00:25:55,399
the right-hand side object is now in

00:25:52,669 --> 00:25:57,470
this perfect now let's take a look at

00:25:55,399 --> 00:25:59,330
more a couple of more details the first

00:25:57,470 --> 00:26:02,059
of all you might feel that these two

00:25:59,330 --> 00:26:03,859
operations well you always have to think

00:26:02,059 --> 00:26:06,349
about this you always have to remember

00:26:03,859 --> 00:26:08,450
that pointers are special that other the

00:26:06,349 --> 00:26:10,970
other pointer in case it's owning has to

00:26:08,450 --> 00:26:13,780
be said to know there is a little helper

00:26:10,970 --> 00:26:16,900
that is called stood exchange

00:26:13,780 --> 00:26:20,080
statics changes a function that sets the

00:26:16,900 --> 00:26:25,060
given pointers at WPI to now pointer and

00:26:20,080 --> 00:26:26,740
it returns the old value of WPI that is

00:26:25,060 --> 00:26:29,710
of course the value that I want to have

00:26:26,740 --> 00:26:31,990
in my own pointer that is a nice helper

00:26:29,710 --> 00:26:34,300
that basically makes this a little more

00:26:31,990 --> 00:26:37,030
compact and you might not forget this

00:26:34,300 --> 00:26:40,030
although it's nice just for educational

00:26:37,030 --> 00:26:41,410
purposes I now simply return to the old

00:26:40,030 --> 00:26:46,330
thing I want just to show a couple of

00:26:41,410 --> 00:26:49,900
more details all right there is another

00:26:46,330 --> 00:26:55,230
cool guideline make move operations no

00:26:49,900 --> 00:26:58,360
except so let's do this but let's also

00:26:55,230 --> 00:27:00,460
ask why is this necessary why is this

00:26:58,360 --> 00:27:03,010
something that is not like consider

00:27:00,460 --> 00:27:05,830
moving it now except but make it now

00:27:03,010 --> 00:27:09,880
accept so first of all it's actually not

00:27:05,830 --> 00:27:11,740
wrong moving the I is well no brainer

00:27:09,880 --> 00:27:13,540
this can never fail this will never

00:27:11,740 --> 00:27:15,640
throw an exception when also the pointer

00:27:13,540 --> 00:27:17,650
is a no-brainer it will never fail the

00:27:15,640 --> 00:27:19,120
string well we just have to look it up

00:27:17,650 --> 00:27:21,250
and find that the move operation for the

00:27:19,120 --> 00:27:23,050
string is no except to and so this is

00:27:21,250 --> 00:27:24,640
not a lie this is perfect this is no

00:27:23,050 --> 00:27:27,460
except also of course setting the

00:27:24,640 --> 00:27:29,020
pointer to no but there it's a good

00:27:27,460 --> 00:27:32,080
reason that the court guidelines point

00:27:29,020 --> 00:27:34,750
this out it has to do with performance

00:27:32,080 --> 00:27:37,390
and in order to demonstrate this I have

00:27:34,750 --> 00:27:39,700
now written a little example program so

00:27:37,390 --> 00:27:47,020
first of all let's say that I create a

00:27:39,700 --> 00:27:49,510
long string longer than necessary sing a

00:27:47,020 --> 00:27:52,000
small string optimization then have a

00:27:49,510 --> 00:27:55,420
vector of widgets at this point it is

00:27:52,000 --> 00:27:58,450
empty n is the number of widgets I want

00:27:55,420 --> 00:28:00,670
to create the next I'm running a for

00:27:58,450 --> 00:28:02,770
loop and I'm creating end widgets and

00:28:00,670 --> 00:28:07,030
I'm pushing back them back into the

00:28:02,770 --> 00:28:09,190
vector by means of move and then of

00:28:07,030 --> 00:28:13,150
course I measure the time this takes and

00:28:09,190 --> 00:28:15,700
eventually I just print the run time if

00:28:13,150 --> 00:28:19,500
I do not make my copy constructor no

00:28:15,700 --> 00:28:22,720
accept then I both clang in GCC they

00:28:19,500 --> 00:28:26,500
show exactly the same result solve this

00:28:22,720 --> 00:28:27,220
in 0.005 seconds market just a number at

00:28:26,500 --> 00:28:29,620
this point

00:28:27,220 --> 00:28:32,050
however if I use snow except then

00:28:29,620 --> 00:28:34,360
suddenly the runtime goes down by 60% to

00:28:32,050 --> 00:28:37,720
only a two point to see if it's zero

00:28:34,360 --> 00:28:41,110
point zero zero in two seconds and it's

00:28:37,720 --> 00:28:43,690
quite a bit that is not just a 1% or 2%

00:28:41,110 --> 00:28:46,750
difference this is very a very

00:28:43,690 --> 00:28:51,160
significant change the reason has to do

00:28:46,750 --> 00:28:53,260
with indeed exceptions push back gives

00:28:51,160 --> 00:28:55,300
you a guarantee it gives you the

00:28:53,260 --> 00:28:59,680
so-called strong exception safety

00:28:55,300 --> 00:29:02,080
guarantee if you if any exception is

00:28:59,680 --> 00:29:03,700
thrown in push back it is as if nothing

00:29:02,080 --> 00:29:05,800
has happened it is as if you would not

00:29:03,700 --> 00:29:08,800
have called the function this is a very

00:29:05,800 --> 00:29:11,410
strong and a very valuable guarantee but

00:29:08,800 --> 00:29:14,560
as soon as we use move as soon as

00:29:11,410 --> 00:29:18,100
objects are transferred I am changing my

00:29:14,560 --> 00:29:21,760
inner content and this is why push back

00:29:18,100 --> 00:29:24,460
has B to be pretty defensive if you have

00:29:21,760 --> 00:29:26,290
if you promise to not throw in your move

00:29:24,460 --> 00:29:28,480
operation then push back will indeed

00:29:26,290 --> 00:29:30,400
move it cannot fail it will not destroy

00:29:28,480 --> 00:29:33,480
the old state everything's fine

00:29:30,400 --> 00:29:36,280
but if you do not give this promise

00:29:33,480 --> 00:29:39,310
unfortunately it has to do a copy and so

00:29:36,280 --> 00:29:41,320
if you do not use no accept it basically

00:29:39,310 --> 00:29:43,270
falls back to the precip lastest 11

00:29:41,320 --> 00:29:44,920
behavior which is pretty unfortunate but

00:29:43,270 --> 00:29:48,250
this is why the quadlings pretty clear

00:29:44,920 --> 00:29:53,310
make your operational accept alright so

00:29:48,250 --> 00:29:56,380
let's do this then what about this WI I

00:29:53,310 --> 00:29:59,890
have set the other pointer to now but I

00:29:56,380 --> 00:30:02,350
did not really set WI to 0 or some other

00:29:59,890 --> 00:30:05,830
default there is yet another core

00:30:02,350 --> 00:30:07,900
guideline c-64 a move operation should

00:30:05,830 --> 00:30:11,890
move and leave its source in a valid

00:30:07,900 --> 00:30:13,540
State this Cork Ireland has a note we

00:30:11,890 --> 00:30:14,650
don't read all of it it's this first

00:30:13,540 --> 00:30:17,530
part that's interesting

00:30:14,650 --> 00:30:20,230
ideally that moved from should be the

00:30:17,530 --> 00:30:22,420
default value of the type and show that

00:30:20,230 --> 00:30:26,260
unless there is an exceptionally good

00:30:22,420 --> 00:30:28,630
reason not to so if you read this then

00:30:26,260 --> 00:30:32,140
this basically means that we actually

00:30:28,630 --> 00:30:35,350
want to set this to zero okay so let's

00:30:32,140 --> 00:30:37,720
do this however this is not what the

00:30:35,350 --> 00:30:39,160
default would do so if I indeed would

00:30:37,720 --> 00:30:39,680
have a unique pointer if I would choose

00:30:39,160 --> 00:30:42,290
the default

00:30:39,680 --> 00:30:45,010
datian the default would not set this to

00:30:42,290 --> 00:30:48,640
zero so if the default is not doing it

00:30:45,010 --> 00:30:50,960
apparently it's not such a bad thing of

00:30:48,640 --> 00:30:53,090
course by setting this to zero we have

00:30:50,960 --> 00:30:53,450
now also perfectly achieved our second

00:30:53,090 --> 00:30:56,000
goal

00:30:53,450 --> 00:30:58,640
w is now invalid but undefined state

00:30:56,000 --> 00:31:00,920
actually it is in a default state which

00:30:58,640 --> 00:31:03,290
is what the core guidelines suggest but

00:31:00,920 --> 00:31:05,510
if you leave this operation well it's

00:31:03,290 --> 00:31:09,230
also in a valid State you just did not

00:31:05,510 --> 00:31:12,200
reset the int to zero it's just the

00:31:09,230 --> 00:31:15,460
value that it had before and this is

00:31:12,200 --> 00:31:17,900
also perfectly valid state however

00:31:15,460 --> 00:31:20,270
undefined from a higher perspective

00:31:17,900 --> 00:31:23,120
because I cannot really predict what it

00:31:20,270 --> 00:31:24,680
will be from a performance point of view

00:31:23,120 --> 00:31:27,530
however it's of course reasonable

00:31:24,680 --> 00:31:29,660
because if I don't really have to set it

00:31:27,530 --> 00:31:32,480
to zero then leaving the out is just a

00:31:29,660 --> 00:31:35,360
tiny little bit faster so this is now

00:31:32,480 --> 00:31:38,540
kind of the canonical move constructor

00:31:35,360 --> 00:31:41,300
this is what I would argue is what you

00:31:38,540 --> 00:31:42,460
would have to write if you indeed have

00:31:41,300 --> 00:31:47,960
to write it yourself

00:31:42,460 --> 00:31:50,810
all right now in this canonical form you

00:31:47,960 --> 00:31:53,960
see some like two phases phase 1 and

00:31:50,810 --> 00:31:56,900
phase 2 and phase 1 I do a member wise

00:31:53,960 --> 00:32:02,600
move all the members are explicitly

00:31:56,900 --> 00:32:04,210
moved from W into this in phase 2 I'm

00:32:02,600 --> 00:32:07,150
explicitly dealing with pointers

00:32:04,210 --> 00:32:09,560
pointers are unfortunately special

00:32:07,150 --> 00:32:11,540
pointers have to be handle explicitly so

00:32:09,560 --> 00:32:12,770
I have to say owning pointers if it's

00:32:11,540 --> 00:32:14,690
not an owning pointer you'd probably

00:32:12,770 --> 00:32:16,160
don't care but an only pointer is

00:32:14,690 --> 00:32:18,170
special I have to deal with this

00:32:16,160 --> 00:32:22,630
explicitly so please don't forget this

00:32:18,170 --> 00:32:26,600
this is a usual a usual kind of problem

00:32:22,630 --> 00:32:29,180
if I however make this a unique pointer

00:32:26,600 --> 00:32:34,970
again so going back to what we started

00:32:29,180 --> 00:32:37,370
with then what I can omit is phase 2 by

00:32:34,970 --> 00:32:41,090
the way now see I change the type I do

00:32:37,370 --> 00:32:43,550
not have to adapt phase 1 so I moved WPI

00:32:41,090 --> 00:32:45,860
and this is still exactly the right

00:32:43,550 --> 00:32:49,880
thing to do and I'm only left with phase

00:32:45,860 --> 00:32:52,790
1 if this is what you only need if phase

00:32:49,880 --> 00:32:53,790
1 is all you need indeed then you are

00:32:52,790 --> 00:32:56,790
fine with the default

00:32:53,790 --> 00:32:59,850
the default move constructor this only

00:32:56,790 --> 00:33:01,680
do face one a member why smooth move

00:32:59,850 --> 00:33:02,670
number one move number two move number

00:33:01,680 --> 00:33:04,710
three and so on

00:33:02,670 --> 00:33:07,500
this is what the default would do and

00:33:04,710 --> 00:33:09,960
note the default is also no accept and

00:33:07,500 --> 00:33:11,730
so you don't have to worry the default

00:33:09,960 --> 00:33:13,320
gives you the whole package and as I

00:33:11,730 --> 00:33:15,390
said this is exactly what you would like

00:33:13,320 --> 00:33:22,800
to have this is the perfect class design

00:33:15,390 --> 00:33:25,860
following the rule of zero all right now

00:33:22,800 --> 00:33:27,270
going back to this this form that I said

00:33:25,860 --> 00:33:29,100
is the canonical form for an

00:33:27,270 --> 00:33:30,990
implementation that you do of course

00:33:29,100 --> 00:33:34,170
there's other variations of course

00:33:30,990 --> 00:33:36,330
there's options you have I cannot show

00:33:34,170 --> 00:33:37,920
you all possible implementations I can

00:33:36,330 --> 00:33:40,050
only show the canonical form and hope

00:33:37,920 --> 00:33:41,580
that this is what you use most of the

00:33:40,050 --> 00:33:44,010
time if indeed you have to write this

00:33:41,580 --> 00:33:46,320
function yourself I would follow the

00:33:44,010 --> 00:33:48,120
advice of how Hinnant I think the most

00:33:46,320 --> 00:33:49,740
important takeaway is that programmers

00:33:48,120 --> 00:33:51,810
should be leery of following patterns

00:33:49,740 --> 00:33:54,180
without thought so

00:33:51,810 --> 00:33:56,160
think about what you really need think

00:33:54,180 --> 00:33:57,960
about how to transfer in a most

00:33:56,160 --> 00:34:00,090
efficient way the content of the other

00:33:57,960 --> 00:34:01,980
object into this if there is something

00:34:00,090 --> 00:34:04,140
better you can do then this canonical

00:34:01,980 --> 00:34:05,610
form of course do it this is all about

00:34:04,140 --> 00:34:08,910
performance this is all about efficiency

00:34:05,610 --> 00:34:14,490
and you can do whatever is necessary to

00:34:08,910 --> 00:34:18,360
be as fast as possible alright having

00:34:14,490 --> 00:34:21,770
covered the move constructor let's take

00:34:18,360 --> 00:34:26,930
a look at the move assignment operator

00:34:21,770 --> 00:34:30,000
question so can you see Mike thank you

00:34:26,930 --> 00:34:34,290
you go back can you go back to the page

00:34:30,000 --> 00:34:37,340
with a unique pointer yeah so we when

00:34:34,290 --> 00:34:41,400
you stood moved P I did that

00:34:37,340 --> 00:34:43,410
automatically reset double use unique

00:34:41,400 --> 00:34:46,130
pointer or leave it alone because this

00:34:43,410 --> 00:34:48,240
two moves just a static cast correct

00:34:46,130 --> 00:34:51,990
basic you answer the question yourself

00:34:48,240 --> 00:34:55,230
if this move WP I would also nicely

00:34:51,990 --> 00:34:57,090
reset the WPI to now oh this would be

00:34:55,230 --> 00:34:59,850
nice a lot of people are usually asking

00:34:57,090 --> 00:35:04,530
me wouldn't this be would need to be

00:34:59,850 --> 00:35:06,570
exactly what I want there is

00:35:04,530 --> 00:35:08,730
the problem with non owning pointers an

00:35:06,570 --> 00:35:11,010
on owning pointer perhaps should not be

00:35:08,730 --> 00:35:13,020
reset and so there is no general move

00:35:11,010 --> 00:35:16,050
that always resets the other pointer it

00:35:13,020 --> 00:35:17,730
depends on what you really want to do in

00:35:16,050 --> 00:35:19,260
case of an owning pointed there for you

00:35:17,730 --> 00:35:21,690
unfortunately have to do it yourself and

00:35:19,260 --> 00:35:25,230
you have to think about it else it's

00:35:21,690 --> 00:35:26,370
usually a serious bug but no it's not

00:35:25,230 --> 00:35:28,470
done automatically

00:35:26,370 --> 00:35:30,630
the string is different because the

00:35:28,470 --> 00:35:39,960
string of course has the move operations

00:35:30,630 --> 00:35:44,580
itself this okay this one sorry then I

00:35:39,960 --> 00:35:48,420
was misunderstanding this one so do I

00:35:44,580 --> 00:35:51,990
have to move the unit pointer so this

00:35:48,420 --> 00:35:55,400
this version yes I have to the unique

00:35:51,990 --> 00:36:03,750
pointer again it would be an l-value I

00:35:55,400 --> 00:36:06,060
would copy the unit pointer okay now I

00:36:03,750 --> 00:36:08,040
got the question completely yes the unit

00:36:06,060 --> 00:36:11,610
pointer is completely reset absolutely

00:36:08,040 --> 00:36:12,330
that is part of the class okay so for

00:36:11,610 --> 00:36:14,880
the misunderstanding

00:36:12,330 --> 00:36:17,130
yeah so the unit pointer has a class

00:36:14,880 --> 00:36:19,200
type knows exactly what to do it resets

00:36:17,130 --> 00:36:20,580
its internal pointer automatically and

00:36:19,200 --> 00:36:25,710
this is exactly why phase one is

00:36:20,580 --> 00:36:27,270
perfectly enough you don't have to you

00:36:25,710 --> 00:36:29,700
don't have to do anything class types

00:36:27,270 --> 00:36:37,630
are much much easier to handle than

00:36:29,700 --> 00:36:42,130
pointers all right okay all right

00:36:37,630 --> 00:36:44,290
then moving forward let's take a look at

00:36:42,130 --> 00:36:45,940
the move assignment operator and of

00:36:44,290 --> 00:36:48,670
course this one it always Christian I'm

00:36:45,940 --> 00:36:51,070
sorry yes so if you have if you have

00:36:48,670 --> 00:36:52,570
this case where it's an owning pointer

00:36:51,070 --> 00:36:56,140
are you gonna if you try to use the

00:36:52,570 --> 00:36:58,600
default move constructor are you gonna

00:36:56,140 --> 00:37:01,720
get a compile error if not what are you

00:36:58,600 --> 00:37:03,550
gonna get okay how can you send you it

00:37:01,720 --> 00:37:06,610
so Mike it's not particularly good okay

00:37:03,550 --> 00:37:08,560
sorry yes so if you have this case where

00:37:06,610 --> 00:37:10,570
you have an owning pointer and you use

00:37:08,560 --> 00:37:12,700
the default move constructor are you

00:37:10,570 --> 00:37:15,610
gonna get a compile error and if not

00:37:12,700 --> 00:37:17,230
what are you gonna get so you're asking

00:37:15,610 --> 00:37:23,380
whether that in the default constructor

00:37:17,230 --> 00:37:25,090
if I get an error to do that no no so if

00:37:23,380 --> 00:37:27,490
you don't him if you don't implement it

00:37:25,090 --> 00:37:30,100
if you just said equals it's just so bad

00:37:27,490 --> 00:37:33,070
there's so much echo that so you have to

00:37:30,100 --> 00:37:35,230
find the right distance okay if you just

00:37:33,070 --> 00:37:37,780
say equals equals AE equals the fault

00:37:35,230 --> 00:37:39,670
okay yep are you gonna get a compiler

00:37:37,780 --> 00:37:42,730
because you have a type that's not

00:37:39,670 --> 00:37:45,580
movable okay so let's let me find the

00:37:42,730 --> 00:37:47,710
right slide now I got it this one well

00:37:45,580 --> 00:37:53,290
but instead of the unique pointer you

00:37:47,710 --> 00:37:55,270
had a raw pointer okay basically if I

00:37:53,290 --> 00:37:58,390
have a pointer now with default do I get

00:37:55,270 --> 00:38:00,190
a compiler no it could be that it is

00:37:58,390 --> 00:38:01,600
perfect if it's not only pointer perhaps

00:38:00,190 --> 00:38:03,730
this is exactly what you would like to

00:38:01,600 --> 00:38:05,650
have so unfortunately this is not a

00:38:03,730 --> 00:38:08,950
compilation error it is no winning oh

00:38:05,650 --> 00:38:11,110
you forgot to deal with the pointer no

00:38:08,950 --> 00:38:11,440
unfortunately no it's not a lot of help

00:38:11,110 --> 00:38:15,150
here

00:38:11,440 --> 00:38:15,150
so you have to really remember yourself

00:38:16,500 --> 00:38:25,750
okay other questions while I try to find

00:38:20,080 --> 00:38:29,740
the slide again all right

00:38:25,750 --> 00:38:31,660
they move for Simon operator it is very

00:38:29,740 --> 00:38:36,550
very similar to what we've seen before

00:38:31,660 --> 00:38:37,810
the move constructor first of all we

00:38:36,550 --> 00:38:39,790
should think about what we wanted chief

00:38:37,810 --> 00:38:42,400
it is a little more we now have three

00:38:39,790 --> 00:38:44,800
points the new point is the first one we

00:38:42,400 --> 00:38:51,160
also want to clean up all visible

00:38:44,800 --> 00:38:53,320
resources in the in our yeah in our own

00:38:51,160 --> 00:38:55,450
object we want again to transfer the

00:38:53,320 --> 00:38:57,820
content of W into this and leave W

00:38:55,450 --> 00:39:00,460
invalid at an undefined state so it is

00:38:57,820 --> 00:39:01,750
similar but it is a little more but it

00:39:00,460 --> 00:39:03,340
is reasonable because the assignment

00:39:01,750 --> 00:39:05,050
operator is of course changing an

00:39:03,340 --> 00:39:06,250
existing object versus the constructor

00:39:05,050 --> 00:39:09,490
is creating something new the

00:39:06,250 --> 00:39:11,680
constructor is usually simpler now the

00:39:09,490 --> 00:39:14,050
first step we do is again we move the

00:39:11,680 --> 00:39:16,930
int again I use the convention to always

00:39:14,050 --> 00:39:19,560
move yes again this does not do any kind

00:39:16,930 --> 00:39:23,470
of speed up but it is just a little more

00:39:19,560 --> 00:39:26,290
canonical then we also now do it

00:39:23,470 --> 00:39:28,300
correctly remove the string again if you

00:39:26,290 --> 00:39:31,030
omit the move here we do the wrong thing

00:39:28,300 --> 00:39:33,250
it would compile it would work but it

00:39:31,030 --> 00:39:38,500
would indeed do a copy so we correctly

00:39:33,250 --> 00:39:41,290
move and then we move the pointer also

00:39:38,500 --> 00:39:44,320
Kay but now in this case I have

00:39:41,290 --> 00:39:48,599
introduced another kind of error I have

00:39:44,320 --> 00:39:50,940
now over written my own pointer my PI

00:39:48,599 --> 00:39:56,440
previously there was some value in there

00:39:50,940 --> 00:39:59,080
some value to the content I own now it's

00:39:56,440 --> 00:40:01,030
gone so what you must not forget in the

00:39:59,080 --> 00:40:04,000
move assignment operator is to

00:40:01,030 --> 00:40:06,130
explicitly delete PII also this is not

00:40:04,000 --> 00:40:08,740
part of the move thing this is something

00:40:06,130 --> 00:40:12,010
that you have to deal with yourself so

00:40:08,740 --> 00:40:13,450
usually the first line is delete and not

00:40:12,010 --> 00:40:15,220
just the first line if you've more

00:40:13,450 --> 00:40:17,080
resources than the beginning the

00:40:15,220 --> 00:40:19,630
beginning block is usually just what you

00:40:17,080 --> 00:40:21,790
do in the destructor as well so

00:40:19,630 --> 00:40:24,970
unfortunately there is currently some

00:40:21,790 --> 00:40:27,130
kind of duplication all right so we

00:40:24,970 --> 00:40:28,839
dealt with our old resource so we

00:40:27,130 --> 00:40:32,619
cleaned up all visible resources

00:40:28,839 --> 00:40:36,280
properly perfect first goal is set then

00:40:32,619 --> 00:40:39,430
again afterwards I reset the pointer of

00:40:36,280 --> 00:40:42,080
WPI to null pointer

00:40:39,430 --> 00:40:44,630
now at this point we have again

00:40:42,080 --> 00:40:51,710
effectively transfer the content of W

00:40:44,630 --> 00:40:53,900
into this great again you can use stood

00:40:51,710 --> 00:40:56,180
exchange it makes the code a little

00:40:53,900 --> 00:40:58,880
easier to read and you do not tend to

00:40:56,180 --> 00:41:01,970
forget to set the pointer if you make

00:40:58,880 --> 00:41:03,980
this the habit exchange pointers but

00:41:01,970 --> 00:41:05,780
again although it's great for

00:41:03,980 --> 00:41:11,200
educational reasons I just show these

00:41:05,780 --> 00:41:15,830
two operations explicitly now in this

00:41:11,200 --> 00:41:18,200
these two operations now some people use

00:41:15,830 --> 00:41:21,590
a different form they kind of collect

00:41:18,200 --> 00:41:26,870
these three into a swap what he can also

00:41:21,590 --> 00:41:29,360
do is you swap P I and WPI this is still

00:41:26,870 --> 00:41:31,790
unfortunately a common way to implement

00:41:29,360 --> 00:41:33,620
the move assignment operator it is

00:41:31,790 --> 00:41:35,720
unfortunately unless little less

00:41:33,620 --> 00:41:38,630
deterministic so there's a couple of

00:41:35,720 --> 00:41:41,240
arguments that usually against this form

00:41:38,630 --> 00:41:42,020
yes of course it's very elegant it's

00:41:41,240 --> 00:41:47,360
very short

00:41:42,020 --> 00:41:49,760
pretty expressive but in this case you

00:41:47,360 --> 00:41:53,900
are transferring your old resource into

00:41:49,760 --> 00:41:55,700
W this is fine it will be taken care of

00:41:53,900 --> 00:41:59,480
eventually but what you don't know

00:41:55,700 --> 00:42:01,670
exactly is when eventually at some point

00:41:59,480 --> 00:42:03,350
in the future this new resource will be

00:42:01,670 --> 00:42:05,210
destroyed but since you cannot tell

00:42:03,350 --> 00:42:09,200
anymore how long it will still stay

00:42:05,210 --> 00:42:11,690
alive it's well less deterministic also

00:42:09,200 --> 00:42:13,940
if he is counting operations admittedly

00:42:11,690 --> 00:42:15,800
just pointer operations there's one

00:42:13,940 --> 00:42:17,330
point operation more and so it's a

00:42:15,800 --> 00:42:21,350
little less efficient

00:42:17,330 --> 00:42:26,330
yes it's elegant but ice tend to just

00:42:21,350 --> 00:42:31,450
recommend use this form explicitly all

00:42:26,330 --> 00:42:31,450
right again please

00:42:33,320 --> 00:42:38,870
so assuming as you're clean not be

00:42:35,150 --> 00:42:43,600
resource before you do the move this

00:42:38,870 --> 00:42:45,800
would all go horribly wrong if the the

00:42:43,600 --> 00:42:47,810
the reference you were passing in was

00:42:45,800 --> 00:42:51,260
actually a reference to the object you

00:42:47,810 --> 00:42:52,549
were swapping into moving into okay I

00:42:51,260 --> 00:42:54,319
think fortunately on

00:42:52,549 --> 00:42:57,339
got half of it I'm sorry sorry I'm

00:42:54,319 --> 00:43:01,609
really very nervous so I miss you

00:42:57,339 --> 00:43:03,739
cell facade all right Simon so with when

00:43:01,609 --> 00:43:05,449
you do it would only happen if you had

00:43:03,739 --> 00:43:07,249
to stood move on an l-value asu's

00:43:05,449 --> 00:43:09,890
because if it's an r-value is a term

00:43:07,249 --> 00:43:13,249
okay this is a very good question is

00:43:09,890 --> 00:43:15,739
that with when you do that static casts

00:43:13,249 --> 00:43:18,349
to an r-value would I still be able to

00:43:15,739 --> 00:43:20,359
have a check to check that it was not

00:43:18,349 --> 00:43:22,880
the same as this all right

00:43:20,359 --> 00:43:24,829
actually it is so self-assignment it

00:43:22,880 --> 00:43:26,989
should have moved to self this is

00:43:24,829 --> 00:43:29,420
possible of course I could simply write

00:43:26,989 --> 00:43:32,989
something like W is equal to move W this

00:43:29,420 --> 00:43:34,699
would obviously be a move to self what

00:43:32,989 --> 00:43:36,099
would happen in this case well let's

00:43:34,699 --> 00:43:38,660
think it through

00:43:36,099 --> 00:43:41,209
delete P I I would delete my own

00:43:38,660 --> 00:43:43,910
resource first all right now it's gone

00:43:41,209 --> 00:43:47,390
now I simply copy my pointer into my own

00:43:43,910 --> 00:43:49,579
pointer I move my string into s now of

00:43:47,390 --> 00:43:53,059
course this depends on what the string

00:43:49,579 --> 00:43:55,759
does and then I move my own pointer into

00:43:53,059 --> 00:43:58,689
my own pointer and set myself to now so

00:43:55,759 --> 00:44:02,689
essentially afterwards I'm just kind of

00:43:58,689 --> 00:44:05,989
in a default State not quite because I

00:44:02,689 --> 00:44:09,979
copy the pointer so it'll be int but

00:44:05,989 --> 00:44:12,890
it's like as if I moved from move to

00:44:09,979 --> 00:44:16,009
self is different than copied to self if

00:44:12,890 --> 00:44:18,559
he copied herself so W is equal to W we

00:44:16,009 --> 00:44:20,719
assume that nothing changes the object

00:44:18,559 --> 00:44:24,319
is still in the same state this is the

00:44:20,719 --> 00:44:27,319
basic assumption move to self however

00:44:24,319 --> 00:44:29,029
basically means we have no assumption

00:44:27,319 --> 00:44:32,689
about the outcome what what should it be

00:44:29,029 --> 00:44:36,439
w is equal to move W you explicitly said

00:44:32,689 --> 00:44:39,170
move W you basically say I don't need

00:44:36,439 --> 00:44:41,359
this guy anymore so this is actually

00:44:39,170 --> 00:44:43,489
perfectly fine I do not have to protect

00:44:41,359 --> 00:44:46,189
against self assignment afterwards it is

00:44:43,489 --> 00:44:48,259
moved from if you feel uncomfortable

00:44:46,189 --> 00:44:51,559
this of course you can add an if

00:44:48,259 --> 00:44:54,890
statement if address of right hand side

00:44:51,559 --> 00:44:58,929
is not equal to this then do this also

00:44:54,890 --> 00:45:01,729
okay the result is valid but undefined

00:44:58,929 --> 00:45:03,529
so move to self is indeed different than

00:45:01,729 --> 00:45:05,390
copy to self now you can feel

00:45:03,529 --> 00:45:05,820
comfortable by just making it as fast as

00:45:05,390 --> 00:45:07,980
path

00:45:05,820 --> 00:45:11,820
what must not happen however is of

00:45:07,980 --> 00:45:12,510
course a crash a crash is is of course

00:45:11,820 --> 00:45:14,970
out of the question

00:45:12,510 --> 00:45:17,400
okay question so he said she moved her

00:45:14,970 --> 00:45:20,100
shelf is in defined okay a little louder

00:45:17,400 --> 00:45:23,070
sorry so move to self is that then

00:45:20,100 --> 00:45:24,770
considered in defined behavior no move

00:45:23,070 --> 00:45:28,380
to self is not undefined behavior

00:45:24,770 --> 00:45:31,050
afterwards however this value is in an

00:45:28,380 --> 00:45:34,260
undefined state as usually it moved from

00:45:31,050 --> 00:45:35,670
object I moved from basically means okay

00:45:34,260 --> 00:45:41,150
it could be in any state I don't need it

00:45:35,670 --> 00:45:44,670
anymore I just leave it died by the way

00:45:41,150 --> 00:45:47,790
W is equal to move W this is probably

00:45:44,670 --> 00:45:49,950
the only situation where you obviously

00:45:47,790 --> 00:45:52,320
move some valid object into itself

00:45:49,950 --> 00:45:54,150
I am only aware of an one other

00:45:52,320 --> 00:45:57,510
situation we move to self happens and

00:45:54,150 --> 00:46:00,750
this is in a swamp in this in a second

00:45:57,510 --> 00:46:03,120
move operation inside a swap swap

00:46:00,750 --> 00:46:05,580
usually three moves in a second one I

00:46:03,120 --> 00:46:08,490
move to self but I move from Ana moved

00:46:05,580 --> 00:46:13,860
from object into a move from object if I

00:46:08,490 --> 00:46:16,260
indeed do move sorry in a swap so also

00:46:13,860 --> 00:46:17,940
in this case this is perfectly fine you

00:46:16,260 --> 00:46:20,070
do not really have to protect against

00:46:17,940 --> 00:46:22,880
move to self perhaps it's a little

00:46:20,070 --> 00:46:25,890
counter into but this is also what you

00:46:22,880 --> 00:46:29,280
find as the common advice I should

00:46:25,890 --> 00:46:31,590
mention there is a core guideline this

00:46:29,280 --> 00:46:33,450
Courtney core guideline says protect

00:46:31,590 --> 00:46:35,940
yourself however there's a note in the

00:46:33,450 --> 00:46:37,950
core guidelines exists well of course we

00:46:35,940 --> 00:46:39,600
try to be a little defensive we don't

00:46:37,950 --> 00:46:43,610
know what could possibly happen and

00:46:39,600 --> 00:46:46,200
therefore they take the point do the if

00:46:43,610 --> 00:46:49,380
however I have never seen it fail

00:46:46,200 --> 00:46:51,030
anywhere so this is indeed kind of the

00:46:49,380 --> 00:46:54,720
canonical form for the movie Simon

00:46:51,030 --> 00:46:56,550
operator okay no except also don't

00:46:54,720 --> 00:47:00,330
forget this and of course we can again

00:46:56,550 --> 00:47:02,370
assign the integer this is again purely

00:47:00,330 --> 00:47:05,400
optional the default would not do it so

00:47:02,370 --> 00:47:07,650
I just leave it we have again achieved

00:47:05,400 --> 00:47:11,310
all our goals the object is now in a

00:47:07,650 --> 00:47:14,580
valid but undefined state in this case

00:47:11,310 --> 00:47:17,610
you see three phases the first phase is

00:47:14,580 --> 00:47:18,630
kind of cleanup yes to some extent a

00:47:17,610 --> 00:47:20,050
repetition of what you do in the

00:47:18,630 --> 00:47:21,970
destructor

00:47:20,050 --> 00:47:24,130
sorted at which structure differently

00:47:21,970 --> 00:47:26,380
but yes it could be a copy of what you

00:47:24,130 --> 00:47:28,750
do in the destructor then in Phase two I

00:47:26,380 --> 00:47:31,839
again do a memorize move move number one

00:47:28,750 --> 00:47:34,390
move number two etc and phase three is

00:47:31,839 --> 00:47:36,609
again an explicit dealing with pointers

00:47:34,390 --> 00:47:39,910
this is something that again you cannot

00:47:36,609 --> 00:47:43,240
forget as soon as I make the pointer a

00:47:39,910 --> 00:47:45,700
unique pointer again I can omit phase

00:47:43,240 --> 00:47:47,319
one and phase three the unique pointer

00:47:45,700 --> 00:47:50,530
knows full well how to do these

00:47:47,319 --> 00:47:53,380
operations and again if you're left with

00:47:50,530 --> 00:47:56,680
this one phase if it's just moving all

00:47:53,380 --> 00:47:59,410
the members then you're fine with just

00:47:56,680 --> 00:48:01,450
using the default so in this case I

00:47:59,410 --> 00:48:04,869
could again say default and again note

00:48:01,450 --> 00:48:06,910
is this no except again so it is much

00:48:04,869 --> 00:48:09,069
much easier and much better for you if

00:48:06,910 --> 00:48:13,690
you can rely on the compiler generated

00:48:09,069 --> 00:48:17,020
default there's one trick that I want to

00:48:13,690 --> 00:48:18,579
show you one possible implementation of

00:48:17,020 --> 00:48:21,940
the move assignment of it it is slightly

00:48:18,579 --> 00:48:23,950
different actually this is not the move

00:48:21,940 --> 00:48:25,990
for Simon operator anymore strictly

00:48:23,950 --> 00:48:28,480
speaking it's to copy a Simon operator

00:48:25,990 --> 00:48:30,970
but if you write it like this it could

00:48:28,480 --> 00:48:31,990
actually be both it's like the copy move

00:48:30,970 --> 00:48:36,750
Simon operator

00:48:31,990 --> 00:48:40,270
I passed widget by value by doing this

00:48:36,750 --> 00:48:44,550
you can actually just swap the term the

00:48:40,270 --> 00:48:48,010
widget internally and then you're done

00:48:44,550 --> 00:48:51,579
if you pass in the assignment and L

00:48:48,010 --> 00:48:54,099
value the argument would now be copied I

00:48:51,579 --> 00:48:56,619
would use the copy constructor and then

00:48:54,099 --> 00:48:59,290
I would swap the copy if I would have an

00:48:56,619 --> 00:49:01,210
r-value so some kind of temporary then

00:48:59,290 --> 00:49:04,230
for the construction of this temporary

00:49:01,210 --> 00:49:06,490
object in the the object here in the

00:49:04,230 --> 00:49:09,310
argument I would use the move

00:49:06,490 --> 00:49:12,220
constructor and so I only have to write

00:49:09,310 --> 00:49:14,829
the move constructor and here I base it

00:49:12,220 --> 00:49:16,510
here to move for free it is not as

00:49:14,829 --> 00:49:18,430
efficient as you would write both

00:49:16,510 --> 00:49:20,500
functions but is it ice trick if you

00:49:18,430 --> 00:49:22,540
just want to quickly cover the

00:49:20,500 --> 00:49:25,180
operations so it's kind of a nice

00:49:22,540 --> 00:49:29,680
fallback if you don't want to sketch out

00:49:25,180 --> 00:49:32,109
everything right away all right

00:49:29,680 --> 00:49:33,640
now that's just one more detail that

00:49:32,109 --> 00:49:36,220
that I want to add

00:49:33,640 --> 00:49:44,950
when does the compiler add these special

00:49:36,220 --> 00:49:47,440
member functions a question so I have

00:49:44,950 --> 00:49:48,309
now implemented my own swap I did

00:49:47,440 --> 00:49:51,369
mention this I'm sorry

00:49:48,309 --> 00:49:54,430
so I now have a swap in the widget so

00:49:51,369 --> 00:49:57,359
one argument not to in this of okay now

00:49:54,430 --> 00:50:00,579
if in case you use Smoove in there okay

00:49:57,359 --> 00:50:02,230
then it certainly is different if you

00:50:00,579 --> 00:50:04,990
add your own swap and if you just say

00:50:02,230 --> 00:50:07,000
okay is what pointers I do an int

00:50:04,990 --> 00:50:10,029
whatever then of course it would work

00:50:07,000 --> 00:50:13,960
yeah so not still swap your own swap now

00:50:10,029 --> 00:50:16,180
which you might have anyway alright when

00:50:13,960 --> 00:50:20,740
does the compiler generate these

00:50:16,180 --> 00:50:22,480
functions well there is a certain well

00:50:20,740 --> 00:50:23,890
some arcane set of rules

00:50:22,480 --> 00:50:25,599
the default move operations are

00:50:23,890 --> 00:50:28,210
generated if no cop operations all

00:50:25,599 --> 00:50:30,369
destructor is easy to find and then move

00:50:28,210 --> 00:50:32,230
the default posada for corporations are

00:50:30,369 --> 00:50:35,619
generated if no move operation is

00:50:32,230 --> 00:50:37,150
user-defined well note it will afford an

00:50:35,619 --> 00:50:39,190
equal delete officially count as

00:50:37,150 --> 00:50:41,020
user-defined user-defined basically

00:50:39,190 --> 00:50:42,849
means you mention these functions in

00:50:41,020 --> 00:50:44,200
your class you do not necessarily have

00:50:42,849 --> 00:50:47,980
to implement them yourself you just

00:50:44,200 --> 00:50:49,569
write them like here into your class all

00:50:47,980 --> 00:50:50,529
right let's play a little game one

00:50:49,569 --> 00:50:54,010
minute

00:50:50,529 --> 00:50:55,630
let's assume I have this class X I want

00:50:54,010 --> 00:50:58,960
to have a virtual instructor this is why

00:50:55,630 --> 00:51:00,880
I write the destructor myself but the

00:50:58,960 --> 00:51:04,450
defaults aren't entirely fine so I say

00:51:00,880 --> 00:51:09,599
equally fault does the compiler now

00:51:04,450 --> 00:51:11,980
generate the copy operations yes or no

00:51:09,599 --> 00:51:18,069
okay to make it a little quicker who

00:51:11,980 --> 00:51:23,500
says yes okay a couple of people say yes

00:51:18,069 --> 00:51:25,660
anyone with no so when does the compiler

00:51:23,500 --> 00:51:27,730
generate copying the default copy

00:51:25,660 --> 00:51:29,829
operations are generated if no move

00:51:27,730 --> 00:51:32,380
operations user-defined at this point I

00:51:29,829 --> 00:51:33,940
did not deal with move at all so the

00:51:32,380 --> 00:51:36,579
compiler would generate the copy

00:51:33,940 --> 00:51:39,000
operations very nice what about the to

00:51:36,579 --> 00:51:39,000
move operations

00:51:41,270 --> 00:51:48,920
no move there's no move because I have

00:51:45,170 --> 00:51:50,780
usually find a destructor so I have to

00:51:48,920 --> 00:51:52,760
admit for virtual class I don't receive

00:51:50,780 --> 00:51:55,340
point of move operations but for the

00:51:52,760 --> 00:51:57,560
sake of learning let's say that we need

00:51:55,340 --> 00:51:59,450
them and that I want to default them so

00:51:57,560 --> 00:52:02,300
now I add the two move operations to my

00:51:59,450 --> 00:52:05,390
class what about the two copy operations

00:52:02,300 --> 00:52:13,580
does the compiler generate the to copy

00:52:05,390 --> 00:52:17,570
operations so no unfortunately it does

00:52:13,580 --> 00:52:19,910
not because now I have user-defined the

00:52:17,570 --> 00:52:22,430
two cop did to move operations so now I

00:52:19,910 --> 00:52:24,830
have to get them back by defaulting the

00:52:22,430 --> 00:52:28,180
cop vibrations to now what you see is

00:52:24,830 --> 00:52:30,080
something called the rule of five or

00:52:28,180 --> 00:52:33,020
something that you see in psycho

00:52:30,080 --> 00:52:35,240
guideline 21 if you define a delete any

00:52:33,020 --> 00:52:38,060
default operation you finally lead them

00:52:35,240 --> 00:52:40,610
all so commonly this is known to be the

00:52:38,060 --> 00:52:43,790
rule of zero Epis sorry you rule of five

00:52:40,610 --> 00:52:47,150
or also if you also count the default

00:52:43,790 --> 00:52:49,609
constructor the rule of six so either

00:52:47,150 --> 00:52:53,210
you live in deep arrested before buying

00:52:49,609 --> 00:52:55,790
the rule of zero or you better define

00:52:53,210 --> 00:52:57,800
all of them this is easier easier for

00:52:55,790 --> 00:53:00,170
the readers of your code they will not

00:52:57,800 --> 00:53:02,270
want wonder do you know about these

00:53:00,170 --> 00:53:05,420
arcane rules are you sure what you're

00:53:02,270 --> 00:53:13,670
doing because indeed they are a little I

00:53:05,420 --> 00:53:20,180
came all right that is the basics of

00:53:13,670 --> 00:53:23,480
move semantics there is just one more

00:53:20,180 --> 00:53:25,700
core guideline I want to show c15

00:53:23,480 --> 00:53:29,060
prefers simple and conventional ways of

00:53:25,700 --> 00:53:31,130
passing information so you might not

00:53:29,060 --> 00:53:33,500
wonder this move semantics doesn't

00:53:31,130 --> 00:53:35,000
appear in in many places do I have to

00:53:33,500 --> 00:53:38,570
spring to my code with our early

00:53:35,000 --> 00:53:40,400
references likely no it is indeed

00:53:38,570 --> 00:53:44,030
something that you can consider an

00:53:40,400 --> 00:53:47,750
optimization C 15 gives a very nice list

00:53:44,030 --> 00:53:50,150
of yeah conventions that you should use

00:53:47,750 --> 00:53:53,510
for return values and passing parameters

00:53:50,150 --> 00:53:54,680
and he promised the advice here you will

00:53:53,510 --> 00:53:56,870
find move

00:53:54,680 --> 00:53:59,750
only in two places you'll find this in

00:53:56,870 --> 00:54:02,630
two special cases in entertain copy and

00:53:59,750 --> 00:54:04,910
in and move from special cases there's

00:54:02,630 --> 00:54:06,560
an input parameter and I need a copy in

00:54:04,910 --> 00:54:08,090
this case you can optimize you can

00:54:06,560 --> 00:54:11,420
optimize based on whether it's L or R

00:54:08,090 --> 00:54:13,850
value and any move from is yet more

00:54:11,420 --> 00:54:16,310
special case I have an in parameter and

00:54:13,850 --> 00:54:18,730
I know that I move from it okay then is

00:54:16,310 --> 00:54:22,070
this know with our references easy to

00:54:18,730 --> 00:54:25,730
deal with by just taking this as an

00:54:22,070 --> 00:54:27,350
r-value reference so the place where

00:54:25,730 --> 00:54:29,600
these are value references creep up is

00:54:27,350 --> 00:54:31,310
primarily the move constructor and move

00:54:29,600 --> 00:54:33,200
assignment operator this is the two

00:54:31,310 --> 00:54:36,170
functions where use the most often in

00:54:33,200 --> 00:54:39,860
other cases it is primarily for

00:54:36,170 --> 00:54:42,890
optimization purposes all right

00:54:39,860 --> 00:54:45,830
notice we are basically at the end of

00:54:42,890 --> 00:54:49,400
the first part and this is what I hope

00:54:45,830 --> 00:54:53,990
you now feel like you now feel like okay

00:54:49,400 --> 00:54:56,000
and I thought move is difficult it's

00:54:53,990 --> 00:54:58,460
just copying couple pointers here Nakia

00:54:56,000 --> 00:55:00,020
have to should not forget to set a

00:54:58,460 --> 00:55:03,460
couple of pointers to zero but

00:55:00,020 --> 00:55:05,960
ultimately it's not that difficult and

00:55:03,460 --> 00:55:07,850
so hopefully this is the feeling that

00:55:05,960 --> 00:55:10,700
you also have if you come back to the

00:55:07,850 --> 00:55:13,550
second part where we climbed downhill a

00:55:10,700 --> 00:55:18,589
little bit okay thank you very much

00:55:13,550 --> 00:55:18,589

YouTube URL: https://www.youtube.com/watch?v=St0MNEU5b0o


