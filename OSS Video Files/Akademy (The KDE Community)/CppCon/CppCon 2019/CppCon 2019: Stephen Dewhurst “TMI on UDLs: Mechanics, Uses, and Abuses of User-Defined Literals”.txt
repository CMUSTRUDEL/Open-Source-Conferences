Title: CppCon 2019: Stephen Dewhurst “TMI on UDLs: Mechanics, Uses, and Abuses of User-Defined Literals”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
We’ve been designing user-defined types in C++ forever, but we were stuck with the same old predefined literal types that somehow had to suit our new concepts. We’d use constructors to beat them into compliance with our new concepts, but we were still just pretending that a double floating-point value had something to do with a kilogram.

C++11 introduced user-defined literals, and C++14, C++17, and C++20 have extended their convenience. In this brisk talk, we’ll look at the mechanics of all six varieties of user-defined literals and use them in a straightforward way to enhance usability and correctness of our user-defined types, and banish type sinks from our interfaces. Along the way, we'll see what the standard lets us get away with and what it doesn't.

Then we’ll see how to force people to write their integers in base 5, require that literals adhere to a particular syntax, deal with those pesky 256-bit integers, and circumvent problems with octals. Time permitting, we’ll see some unusual and possibly useful things we can do with user-defined literals.
— 
Stephen Dewhurst
Semantics Consulting, Inc.
President
Carver, MA

Steve Dewhurst is the co-founder and president of Semantics Consulting, Inc. Steve is the author of numerous technical articles on C++ programming techniques and compiler design, is the author of the critically acclaimed books C++ Common Knowledge and C++ Gotchas, and is the co-author of Programming in C++. He is a frequent speaker at industry conferences, where his presentations are consistently among the most popular and highest rated. He is also a member of the advisory board for The C++ Source, was programming track chair for the Embedded Systems Conference (ESC), and was a visiting scientist at the Software Engineering Institute (SEI) at Carnegie Mellon University. Steve has mentored and consulted with C++ projects ranging in size from 1 to over 100 developers, in areas ranging from compiler design to embedded telecommunications to ecommerce to derivative securities trading. As a Member of Technical Staff in the UNIX Development Laboratory at AT&T Bell Laboratories, Steve worked with Bjarne Stroustrup, the designer and first implementer of C++, on the first public release of the language and cfront C++ compiler, then served as the lead designer and implementer of the first non-cfront C++ compiler. As a compiler architect at Glockenspiel, Ltd., he designed and implemented a second C++ compiler. Steve was a contributing editor for The C/C++ User's Journal, a principal lecturer at The C++ Seminar, has served as a principal on the ANSI/ISO C++ standardization committee, was the C++ training series adviser for Technology Exchange Company (Addison-Wesley), was a member of the editorial board of and columnist for C++ Report, co-founder and member of the editorial board of The C++ Journal, and a Visiting Professor of Computer Science at Jackson State University. He has also written C, COBOL, and Pascal compilers, was a principal on the ANSI/IEEE Pascal Standardization Committee, and a reviewer for ACM Computing Reviews. Semantics Consulting, Inc. is located in the small New England town of Carver, Massachusetts. Like all small New England towns, Carver has a tradition of citizen involvement, and over the years Steve has been astonished to find himself harvesting cranberries, coaching the high school wrestling team, and serving on the town water commission, finance committee, and website committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,450 --> 00:00:13,530
good afternoon so I'm a big fan of

00:00:11,810 --> 00:00:15,450
user-defined literal

00:00:13,530 --> 00:00:17,160
I want to give a nice one-hour talk and

00:00:15,450 --> 00:00:19,830
how wonderful these things are because I

00:00:17,160 --> 00:00:21,900
use them all the time and I see them I

00:00:19,830 --> 00:00:24,060
think they're underused and so I was

00:00:21,900 --> 00:00:28,619
putting together Pleasant one-hour talk

00:00:24,060 --> 00:00:30,419
when I came across Google's C++ coding

00:00:28,619 --> 00:00:32,790
standard and I thought it was a little

00:00:30,419 --> 00:00:35,059
over the top they basically said you

00:00:32,790 --> 00:00:38,850
know who use these things you are

00:00:35,059 --> 00:00:40,680
morally deficient in some way and then

00:00:38,850 --> 00:00:42,809
there was a bloggers it yeah yeah there

00:00:40,680 --> 00:00:44,930
they look useful they look really neat

00:00:42,809 --> 00:00:47,730
but all I do is make your syntax better

00:00:44,930 --> 00:00:49,470
well yeah

00:00:47,730 --> 00:00:50,730
oh sorry I didn't introduce myself I

00:00:49,470 --> 00:00:55,020
think here you can google me for the

00:00:50,730 --> 00:00:59,060
next 15 minutes after which you know I'm

00:00:55,020 --> 00:01:02,100
not gonna be nice to Google okay so

00:00:59,060 --> 00:01:03,750
types inks are a real problem right you

00:01:02,100 --> 00:01:04,610
have a date class like this what's gonna

00:01:03,750 --> 00:01:07,170
happen to you

00:01:04,610 --> 00:01:09,270
you're gonna die there's no question

00:01:07,170 --> 00:01:11,700
about it you as no way you can get the

00:01:09,270 --> 00:01:13,799
dates right especially if you are

00:01:11,700 --> 00:01:16,079
dealing with you know Americans

00:01:13,799 --> 00:01:17,850
Europeans programmers Martians whatever

00:01:16,079 --> 00:01:20,700
they all have different date standards

00:01:17,850 --> 00:01:23,070
you know just never get it right so

00:01:20,700 --> 00:01:24,420
obviously what you want to do by the way

00:01:23,070 --> 00:01:28,020
this is a one-hour talk so I'm speaking

00:01:24,420 --> 00:01:32,729
twice as fast as usual if you want me to

00:01:28,020 --> 00:01:34,440
slow down leave so of course what we do

00:01:32,729 --> 00:01:35,909
is a little reification here we create a

00:01:34,440 --> 00:01:37,860
type that represents a day a month in

00:01:35,909 --> 00:01:41,130
the year we all know how to do this and

00:01:37,860 --> 00:01:42,780
now we can create a nice date class that

00:01:41,130 --> 00:01:44,820
is properly initialized and you just

00:01:42,780 --> 00:01:47,280
simply can't get wrong it'll either work

00:01:44,820 --> 00:01:51,659
or you got a compile time error which is

00:01:47,280 --> 00:01:53,670
what we want and we could force people

00:01:51,659 --> 00:01:57,270
to do things our way or we could be

00:01:53,670 --> 00:01:59,460
proper civilized people and let people

00:01:57,270 --> 00:02:06,150
have their own way of doing things but

00:01:59,460 --> 00:02:09,349
still get a correct result in my other

00:02:06,150 --> 00:02:14,689
life I'm a democratic campaign manager

00:02:09,349 --> 00:02:18,269
yes I will argue about it not now that

00:02:14,689 --> 00:02:20,129
the trouble with this is it's still not

00:02:18,269 --> 00:02:22,590
all that great because we have what

00:02:20,129 --> 00:02:25,920
Scott Myers called C++ is most vexing

00:02:22,590 --> 00:02:27,069
parse you can do something very

00:02:25,920 --> 00:02:30,250
reasonable

00:02:27,069 --> 00:02:32,829
like this and unfortunately C++ is

00:02:30,250 --> 00:02:35,980
inherently ambiguous you've noticed how

00:02:32,829 --> 00:02:37,480
twitchy C++ compiler writers are how

00:02:35,980 --> 00:02:38,560
they look nervously around them all the

00:02:37,480 --> 00:02:40,469
time like they're waiting for another

00:02:38,560 --> 00:02:43,390
non-terminal to appear in the language

00:02:40,469 --> 00:02:47,349
and that's because it can actually parse

00:02:43,390 --> 00:02:48,670
it it works pretty well anyway but it's

00:02:47,349 --> 00:02:51,670
nerve-racking because this is actually a

00:02:48,670 --> 00:02:54,340
function declaration it looks like an

00:02:51,670 --> 00:02:55,870
object declaration but it's not it the

00:02:54,340 --> 00:02:57,519
compiled existences are you don't need

00:02:55,870 --> 00:02:58,950
these parens they're gone

00:02:57,519 --> 00:03:01,750
now it looks like a function declaration

00:02:58,950 --> 00:03:04,180
to fix this traditionally this is the

00:03:01,750 --> 00:03:06,639
greatest fix in the world throw in even

00:03:04,180 --> 00:03:08,230
more parentheses so many the compiler

00:03:06,639 --> 00:03:11,439
can't ignore them anymore that has to

00:03:08,230 --> 00:03:12,730
treat it's kind of like when you want to

00:03:11,439 --> 00:03:14,980
have a correct declaration of our

00:03:12,730 --> 00:03:17,650
pointer if it doesn't work what do you

00:03:14,980 --> 00:03:19,239
do throw another star in there and see

00:03:17,650 --> 00:03:21,459
what happens eventually it's going to

00:03:19,239 --> 00:03:24,519
compile the compiler will just give up

00:03:21,459 --> 00:03:26,799
so in the base language we have this

00:03:24,519 --> 00:03:29,139
really nice facility we can take 39

00:03:26,799 --> 00:03:30,519
which is an integer if we don't want an

00:03:29,139 --> 00:03:32,379
integer we can make it unsigned by

00:03:30,519 --> 00:03:34,510
attacking on a you it can make it long

00:03:32,379 --> 00:03:37,030
or an unsigned long we can change the

00:03:34,510 --> 00:03:39,549
type of literal just by attaching a

00:03:37,030 --> 00:03:42,099
different suffix and this is great it's

00:03:39,549 --> 00:03:46,510
almost like cheating and cheating is a

00:03:42,099 --> 00:03:48,879
good thing in politics and so we want to

00:03:46,510 --> 00:03:51,459
do is have that same capability for our

00:03:48,879 --> 00:03:53,349
own literals we're not just interested

00:03:51,459 --> 00:03:55,510
in unsigned and Long's and things like

00:03:53,349 --> 00:03:58,540
that we want to take these numeric and

00:03:55,510 --> 00:04:01,810
on numeric literals and make them

00:03:58,540 --> 00:04:04,750
generate our types our user-defined

00:04:01,810 --> 00:04:07,120
types so a user-defined literal is just

00:04:04,750 --> 00:04:11,199
a literal which can be parsed as literal

00:04:07,120 --> 00:04:15,099
followed by a user-defined suffix and we

00:04:11,199 --> 00:04:17,829
can define this with a literal operator

00:04:15,099 --> 00:04:20,320
and if you haven't seen this before it

00:04:17,829 --> 00:04:21,310
looks a little strange but you get used

00:04:20,320 --> 00:04:23,320
to it you've gotten used to a lot

00:04:21,310 --> 00:04:25,900
already right let's see if less plus so

00:04:23,320 --> 00:04:27,310
what's a little bit more so this literal

00:04:25,900 --> 00:04:30,610
operators operator double quote double

00:04:27,310 --> 00:04:32,050
quote and then an identifier and the

00:04:30,610 --> 00:04:34,300
standard wants us to start our

00:04:32,050 --> 00:04:36,820
identifier with an underscore strangely

00:04:34,300 --> 00:04:40,400
because other names are reserved to the

00:04:36,820 --> 00:04:45,530
implementation so if you want to have

00:04:40,400 --> 00:04:49,160
and operator go to you're not allowed to

00:04:45,530 --> 00:04:50,690
you get an underscore go to but not not

00:04:49,160 --> 00:04:54,050
a go to but we'll see that we actually

00:04:50,690 --> 00:04:57,650
can use keywords in this context and

00:04:54,050 --> 00:05:00,680
that we shouldn't so here's an example

00:04:57,650 --> 00:05:02,900
of add a user-defined literal here's my

00:05:00,680 --> 00:05:07,960
operator double quote the user-defined

00:05:02,900 --> 00:05:11,419
literal sorry these are fine suffix is

00:05:07,960 --> 00:05:14,600
underscored a and it's a simple context

00:05:11,419 --> 00:05:15,830
/ function as most of these are most

00:05:14,600 --> 00:05:17,690
people want their literals to be

00:05:15,830 --> 00:05:20,240
compiled time constants by making a

00:05:17,690 --> 00:05:23,360
Const expert it will be constant enough

00:05:20,240 --> 00:05:26,660
in most circumstances and all we do is

00:05:23,360 --> 00:05:28,310
return a day and we're done very simple

00:05:26,660 --> 00:05:31,160
and we have a cast in there to shut the

00:05:28,310 --> 00:05:33,350
compiler up notice the type of the

00:05:31,160 --> 00:05:36,229
argument it's the largest integral type

00:05:33,350 --> 00:05:39,139
in the base language so when I produce a

00:05:36,229 --> 00:05:41,360
integer user-defined literal I have to

00:05:39,139 --> 00:05:43,789
declare the argument to be that type not

00:05:41,360 --> 00:05:45,830
int not unsigned long but unsigned long

00:05:43,789 --> 00:05:47,780
long we have no choice and that's

00:05:45,830 --> 00:05:50,660
because the the compilers can be parsing

00:05:47,780 --> 00:05:51,680
an int and giving us that value and we

00:05:50,660 --> 00:05:54,650
have to be prepared to take an

00:05:51,680 --> 00:05:55,910
arbitrarily large value even though you

00:05:54,650 --> 00:05:59,410
know once you get past a couple hundred

00:05:55,910 --> 00:06:03,650
it's probably not a good value for a day

00:05:59,410 --> 00:06:08,750
so again we can fix this gotcha by being

00:06:03,650 --> 00:06:11,750
much too clever or we can be modern or

00:06:08,750 --> 00:06:13,070
it can be very modern so I I suggest

00:06:11,750 --> 00:06:15,320
that this is probably the clearest way

00:06:13,070 --> 00:06:18,590
to write that declaration I can say

00:06:15,320 --> 00:06:20,780
month day in here I can say month year

00:06:18,590 --> 00:06:24,080
and day the way they do on Mars and so

00:06:20,780 --> 00:06:26,150
on so it gives me flexibility is also

00:06:24,080 --> 00:06:30,789
readability and we need all the help we

00:06:26,150 --> 00:06:33,320
can get the C++ what about negatives

00:06:30,789 --> 00:06:34,940
this I just I brought this up because a

00:06:33,320 --> 00:06:36,500
lot of people bring this up well the

00:06:34,940 --> 00:06:38,120
negative sign is not actually part of

00:06:36,500 --> 00:06:39,710
the literal if you look at the standard

00:06:38,120 --> 00:06:41,630
I know you all have a copy of the

00:06:39,710 --> 00:06:45,020
standard I can tell by your upper-body

00:06:41,630 --> 00:06:46,520
strength that you carry it around you'll

00:06:45,020 --> 00:06:49,849
see that the negative sign is not

00:06:46,520 --> 00:06:51,050
actually part of literal and so we

00:06:49,849 --> 00:06:53,000
actually have to if we want to have

00:06:51,050 --> 00:06:53,930
negative days we actually have to

00:06:53,000 --> 00:06:55,759
overload

00:06:53,930 --> 00:06:58,130
negative for our daytime so it's

00:06:55,759 --> 00:07:02,830
associated with a type not with the

00:06:58,130 --> 00:07:05,690
user-defined literal everybody okay

00:07:02,830 --> 00:07:07,789
because you look kind of upset what

00:07:05,690 --> 00:07:12,889
about money it's time we talked about

00:07:07,789 --> 00:07:14,449
this well money is kind of scary

00:07:12,889 --> 00:07:16,250
actually

00:07:14,449 --> 00:07:17,780
I used to write compilers for a living

00:07:16,250 --> 00:07:19,820
and then you know after I got out of

00:07:17,780 --> 00:07:22,550
therapy I decided to do something less

00:07:19,820 --> 00:07:27,800
stressful and I decided to trade

00:07:22,550 --> 00:07:31,389
derivative securities and when I not

00:07:27,800 --> 00:07:31,389
myself I was using somebody else's money

00:07:32,410 --> 00:07:38,300
do I still do this no why don't this and

00:07:37,130 --> 00:07:40,310
I worried about well how do you

00:07:38,300 --> 00:07:41,960
represent US dollars double how do you

00:07:40,310 --> 00:07:44,300
represent Canadian dollars double what

00:07:41,960 --> 00:07:47,870
about Frank's double it was still at

00:07:44,300 --> 00:07:49,070
Frank's and so this made me worried so I

00:07:47,870 --> 00:07:51,169
thought it'd be good I did have money

00:07:49,070 --> 00:07:54,560
and just to find money very simply and

00:07:51,169 --> 00:07:57,620
it probably improperly it's just a

00:07:54,560 --> 00:07:59,750
variable amount of a fixed currency so

00:07:57,620 --> 00:08:01,729
this will prevent mixing and matching US

00:07:59,750 --> 00:08:02,930
and Canadian dollars which is too bad

00:08:01,729 --> 00:08:08,210
because you can make an awful lot of

00:08:02,930 --> 00:08:10,970
money by buying you know can 18 dollars

00:08:08,210 --> 00:08:13,070
on a good day on a bad day in Canada and

00:08:10,970 --> 00:08:15,050
then just turning into US dollars so but

00:08:13,070 --> 00:08:17,659
we don't want to do that so what we can

00:08:15,050 --> 00:08:19,970
do is provide user-defined literals for

00:08:17,659 --> 00:08:21,820
each of these currency types now this is

00:08:19,970 --> 00:08:25,220
going to be a floating-point literal and

00:08:21,820 --> 00:08:27,080
in that case the standard requires that

00:08:25,220 --> 00:08:30,349
the argument be a long double the

00:08:27,080 --> 00:08:32,000
largest built-in floating type and we

00:08:30,349 --> 00:08:34,010
can't change that we must accept the

00:08:32,000 --> 00:08:35,510
long double because again the compiler

00:08:34,010 --> 00:08:38,390
is going to parse and evaluate a

00:08:35,510 --> 00:08:41,539
floating-point literal and pass it by

00:08:38,390 --> 00:08:44,660
value as a value to this overloaded

00:08:41,539 --> 00:08:47,029
operator but these are very very simple

00:08:44,660 --> 00:08:48,170
functions it could perhaps you know you

00:08:47,029 --> 00:08:54,829
could throw on some error checking if

00:08:48,170 --> 00:08:57,140
you want but you don't have to C++ so

00:08:54,829 --> 00:09:00,410
with this in place we can actually write

00:08:57,140 --> 00:09:04,190
a readable declaration I claim that this

00:09:00,410 --> 00:09:07,449
is much more readable than the previous

00:09:04,190 --> 00:09:10,459
version this looks so

00:09:07,449 --> 00:09:12,740
mm when you look at it this looks like a

00:09:10,459 --> 00:09:16,730
truly modern declaration that even Scott

00:09:12,740 --> 00:09:19,189
Myers would approve of you can have

00:09:16,730 --> 00:09:22,149
scientific notation it parses a double a

00:09:19,189 --> 00:09:24,620
long double and hands you the value yeah

00:09:22,149 --> 00:09:26,209
and if you want to going back to the

00:09:24,620 --> 00:09:30,139
days you can write your days and base to

00:09:26,209 --> 00:09:33,949
you know if you're Martians dude I've

00:09:30,139 --> 00:09:35,180
never been to Mars so this gives us even

00:09:33,949 --> 00:09:39,860
more choices

00:09:35,180 --> 00:09:41,240
was it Nicolai justice was quite upset a

00:09:39,860 --> 00:09:44,839
while back because there are more than

00:09:41,240 --> 00:09:49,389
30 ways to write a declaration with an

00:09:44,839 --> 00:09:49,389
initialization in C++ here's another one

00:09:49,420 --> 00:09:54,019
but I think I think this is actually

00:09:51,529 --> 00:09:55,999
helpful because let's look at these are

00:09:54,019 --> 00:09:57,980
really old fashioned declaration it's so

00:09:55,999 --> 00:10:00,040
gauche right you're actually saying the

00:09:57,980 --> 00:10:02,959
type of the thing you want to declare

00:10:00,040 --> 00:10:05,149
well that we can avoid that by using

00:10:02,959 --> 00:10:07,220
what scott Meyers calls the explicitly

00:10:05,149 --> 00:10:08,600
typed initializer idiom which means take

00:10:07,220 --> 00:10:10,579
the information here and push it over

00:10:08,600 --> 00:10:12,589
here that's okay

00:10:10,579 --> 00:10:14,540
know if there are some good things about

00:10:12,589 --> 00:10:17,480
this because I get to use auto so this

00:10:14,540 --> 00:10:18,589
is guaranteed to be initialized Scott

00:10:17,480 --> 00:10:20,240
won't yell at you you know I think

00:10:18,589 --> 00:10:21,920
they're all kinds of good ways reasons

00:10:20,240 --> 00:10:25,100
for doing this what I claim this is even

00:10:21,920 --> 00:10:28,550
better I think is actually is a readable

00:10:25,100 --> 00:10:30,559
way of rendering this declaration and so

00:10:28,550 --> 00:10:34,819
the user-defined literal does help us in

00:10:30,559 --> 00:10:37,100
that regard so there are actually six

00:10:34,819 --> 00:10:40,309
different kinds of user-defined literals

00:10:37,100 --> 00:10:42,680
these are the cooked literals they're

00:10:40,309 --> 00:10:45,259
cooked because the compiler not only

00:10:42,680 --> 00:10:48,559
parses the literal but it evaluates that

00:10:45,259 --> 00:10:50,329
and gives us the value we have we've

00:10:48,559 --> 00:10:52,579
seen a floating-point literal and

00:10:50,329 --> 00:10:54,050
integer literal we also do character and

00:10:52,579 --> 00:10:56,600
string literals the string gets these

00:10:54,050 --> 00:11:00,199
the string which is null terminated plus

00:10:56,600 --> 00:11:02,899
a length of the string and these can be

00:11:00,199 --> 00:11:04,429
various character and string types so

00:11:02,899 --> 00:11:06,290
for instance if I were to write

00:11:04,429 --> 00:11:08,389
something like this this is simply

00:11:06,290 --> 00:11:10,040
calling this operator by the way of

00:11:08,389 --> 00:11:12,170
course just as with all the other

00:11:10,040 --> 00:11:16,329
operators you can call these literal

00:11:12,170 --> 00:11:18,769
operators directly why but you could

00:11:16,329 --> 00:11:21,399
here's a string literal this passes the

00:11:18,769 --> 00:11:25,430
string plus the length of the string

00:11:21,399 --> 00:11:27,589
okay so I am moving rapidly if anybody

00:11:25,430 --> 00:11:32,570
so seriously if you want me to repeat

00:11:27,589 --> 00:11:34,880
something see me after so here's a stock

00:11:32,570 --> 00:11:35,420
this is the worst design stock on the

00:11:34,880 --> 00:11:39,580
planet

00:11:35,420 --> 00:11:43,640
you can initialize it with a ticker a

00:11:39,580 --> 00:11:45,260
numeric q sub q sips are alphanumeric

00:11:43,640 --> 00:11:47,630
but if you have a numeric one you can

00:11:45,260 --> 00:11:49,730
use it or a single character ticker I

00:11:47,630 --> 00:11:51,800
know everybody has a bad day this person

00:11:49,730 --> 00:11:53,570
had a monumentally bad day but

00:11:51,800 --> 00:11:55,970
nevertheless this is now in use so we

00:11:53,570 --> 00:11:59,209
have to support it so we're gonna

00:11:55,970 --> 00:12:01,790
overload three different these are

00:11:59,209 --> 00:12:03,770
defined literals we'll have a character

00:12:01,790 --> 00:12:06,800
string literal a floating-point literal

00:12:03,770 --> 00:12:11,450
and a single character literal and we

00:12:06,800 --> 00:12:16,220
can overload the same ud extension for

00:12:11,450 --> 00:12:18,680
all three and again this is very simple

00:12:16,220 --> 00:12:21,260
stuff and overload resolution will

00:12:18,680 --> 00:12:24,920
disambiguate for us so we can we can

00:12:21,260 --> 00:12:31,730
recognize a a ticker a numeric yusup or

00:12:24,920 --> 00:12:35,240
a single argument ticker extra credit

00:12:31,730 --> 00:12:36,529
somebody tell me what F stands for board

00:12:35,240 --> 00:12:40,430
alright so everybody knows that

00:12:36,529 --> 00:12:42,200
well what's AT&T okay okay so you guys

00:12:40,430 --> 00:12:43,490
are in the same boat I am you've lost so

00:12:42,200 --> 00:12:49,130
much money in the stock market you have

00:12:43,490 --> 00:12:52,490
it you can all the standard library does

00:12:49,130 --> 00:12:55,010
this to s means standard string in the

00:12:52,490 --> 00:12:57,890
context of a string literal but it means

00:12:55,010 --> 00:13:00,320
seconds in the cotton the context of an

00:12:57,890 --> 00:13:04,100
integer literal and I actually disagree

00:13:00,320 --> 00:13:06,140
with this because you know this is the

00:13:04,100 --> 00:13:08,150
only time I agreed with Google on this I

00:13:06,140 --> 00:13:11,930
like them generally but the coding

00:13:08,150 --> 00:13:13,790
standard is written by somebody who's

00:13:11,930 --> 00:13:16,100
had really rough life or something

00:13:13,790 --> 00:13:18,500
because they they just ban everything

00:13:16,100 --> 00:13:21,230
don't code and C++ except how we tell

00:13:18,500 --> 00:13:22,760
you anyway I think would be clearer we

00:13:21,230 --> 00:13:24,380
did this I mean we don't even need the

00:13:22,760 --> 00:13:26,810
common house this is string yep it's a

00:13:24,380 --> 00:13:29,029
string this is seconds so I would I

00:13:26,810 --> 00:13:31,940
would suggest to the extent possible the

00:13:29,029 --> 00:13:34,100
you D suffix should be associated with a

00:13:31,940 --> 00:13:35,870
type returned by the literal

00:13:34,100 --> 00:13:38,960
to make things a little bit clearer I

00:13:35,870 --> 00:13:44,650
mean after all this could be not seconds

00:13:38,960 --> 00:13:55,280
but something else

00:13:44,650 --> 00:13:57,310
seagulls oh I'm having enough trouble up

00:13:55,280 --> 00:13:57,310
here

00:13:58,060 --> 00:14:04,730
okay what about slugs not the things in

00:14:02,270 --> 00:14:06,920
your garden this is a unit of

00:14:04,730 --> 00:14:08,720
measurement of mass in English units and

00:14:06,920 --> 00:14:11,660
English units are great because they're

00:14:08,720 --> 00:14:13,550
really natural like furlong that's the

00:14:11,660 --> 00:14:15,830
length of a furrow it's almost the same

00:14:13,550 --> 00:14:18,920
thing as a stadium you know a little bit

00:14:15,830 --> 00:14:21,530
longer than the stadium so that they

00:14:18,920 --> 00:14:23,990
feel good if you grew up with them but

00:14:21,530 --> 00:14:25,280
you know when you're doing physics if

00:14:23,990 --> 00:14:27,170
you have to do something in you know

00:14:25,280 --> 00:14:30,530
rods per fortnight or something get

00:14:27,170 --> 00:14:32,120
school clumsy so nevertheless we might

00:14:30,530 --> 00:14:35,540
want to support these things so I have a

00:14:32,120 --> 00:14:38,840
slug so I'm gonna have a slug easier to

00:14:35,540 --> 00:14:41,690
find literal underscore slug now of

00:14:38,840 --> 00:14:44,420
course if you're into land-based

00:14:41,690 --> 00:14:45,500
mollusks this could be confusing but

00:14:44,420 --> 00:14:47,480
most of us know we're referring to

00:14:45,500 --> 00:14:49,340
English units of measurement and so this

00:14:47,480 --> 00:14:51,080
works fine this looks floating-point

00:14:49,340 --> 00:14:52,130
literal if you go back here you'll see

00:14:51,080 --> 00:14:54,500
this is a literate

00:14:52,130 --> 00:14:56,570
floating-point easier to find literal it

00:14:54,500 --> 00:14:59,570
works fine but this unfortunately will

00:14:56,570 --> 00:15:02,870
not find we will not attempt to look for

00:14:59,570 --> 00:15:04,670
an integer user-defined literal so it is

00:15:02,870 --> 00:15:06,140
probably a good idea in this case to do

00:15:04,670 --> 00:15:08,300
an additional overloading you just

00:15:06,140 --> 00:15:12,460
forward it to the floating-point version

00:15:08,300 --> 00:15:12,460
so this will fix that particular problem

00:15:12,670 --> 00:15:16,610
let's go back to our dates is this a

00:15:15,920 --> 00:15:19,160
good idea

00:15:16,610 --> 00:15:20,900
we had day month and year types and of

00:15:19,160 --> 00:15:23,500
course they have a date type should we

00:15:20,900 --> 00:15:26,090
have a user-defined literal for date

00:15:23,500 --> 00:15:29,060
notice the quotes if you haven't been

00:15:26,090 --> 00:15:30,590
programming a C++ 14 now you can use

00:15:29,060 --> 00:15:34,160
quotes to making America literals

00:15:30,590 --> 00:15:36,350
clearer or not depending on how you use

00:15:34,160 --> 00:15:39,080
them because you can put them anywhere

00:15:36,350 --> 00:15:40,640
you want inside the literal but this

00:15:39,080 --> 00:15:43,670
looks pretty clear right this must be a

00:15:40,640 --> 00:15:46,250
year is this a day maybe that's not a

00:15:43,670 --> 00:15:46,760
month so in this case but I'm we're

00:15:46,250 --> 00:15:48,170
gonna do

00:15:46,760 --> 00:15:49,970
year-month-day

00:15:48,170 --> 00:15:53,270
because that's the way it should be done

00:15:49,970 --> 00:15:54,790
right yeah it's sorts right

00:15:53,270 --> 00:15:58,610
the trouble is we're getting the value

00:15:54,790 --> 00:16:00,590
here we're accepting an integer type and

00:15:58,610 --> 00:16:03,080
so we might get this which is what we

00:16:00,590 --> 00:16:10,160
want this is not so good

00:16:03,080 --> 00:16:14,780
this is ouch how many people feel warm

00:16:10,160 --> 00:16:17,420
things about octal literals yeah binary

00:16:14,780 --> 00:16:19,400
literals great we broke but we use the

00:16:17,420 --> 00:16:23,150
quotes really well we broke it up into 6

00:16:19,400 --> 00:16:24,860
bits because because when you're

00:16:23,150 --> 00:16:27,950
programming on a Cray you know in the

00:16:24,860 --> 00:16:30,200
mid 70s whenever was it's very handy

00:16:27,950 --> 00:16:31,370
okay so what we want probably like to do

00:16:30,200 --> 00:16:33,110
in this case is we don't want to give

00:16:31,370 --> 00:16:34,460
people too much freedom just to not

00:16:33,110 --> 00:16:38,270
freedom so they can do what we want them

00:16:34,460 --> 00:16:50,630
to when we're programming politically I

00:16:38,270 --> 00:16:53,690
feel differently I was warned oh well so

00:16:50,630 --> 00:16:55,640
we have what are known as raw literal

00:16:53,690 --> 00:16:57,530
operators they don't get a value they

00:16:55,640 --> 00:16:59,330
get the characters of the literal and

00:16:57,530 --> 00:17:02,330
now we have full control there are two

00:16:59,330 --> 00:17:05,420
kinds role literal operators there is a

00:17:02,330 --> 00:17:08,810
well Aurora literal operator which is

00:17:05,420 --> 00:17:11,660
fine it gets a character string of the

00:17:08,810 --> 00:17:12,920
actual characters and we have a literal

00:17:11,660 --> 00:17:16,790
operator template that gets the same

00:17:12,920 --> 00:17:18,530
information as a pack so you can

00:17:16,790 --> 00:17:19,610
probably guess which one I like I just

00:17:18,530 --> 00:17:23,570
talked for two straight days about

00:17:19,610 --> 00:17:26,839
templates templates templates are

00:17:23,570 --> 00:17:29,750
wonderful so here's an example using the

00:17:26,839 --> 00:17:31,520
literal operator the role of a little

00:17:29,750 --> 00:17:35,600
operator say we want to parse things in

00:17:31,520 --> 00:17:37,430
base three as we all do we can actually

00:17:35,600 --> 00:17:41,150
do it like this we can get the

00:17:37,430 --> 00:17:43,040
characters and in this case it is almost

00:17:41,150 --> 00:17:44,510
certain that these that this string will

00:17:43,040 --> 00:17:47,870
be a compile-time constant this is a

00:17:44,510 --> 00:17:49,820
literal so this will be a valid context

00:17:47,870 --> 00:17:51,560
for function and we can probably

00:17:49,820 --> 00:17:56,090
calculate the value at compile time

00:17:51,560 --> 00:18:01,560
doing some sort of simple things context

00:17:56,090 --> 00:18:03,240
or functions from C++ 11 to 17 or like

00:18:01,560 --> 00:18:04,680
print beasts you can do almost anything

00:18:03,240 --> 00:18:09,150
now with the console expert function

00:18:04,680 --> 00:18:10,590
that you can do they want to do changes

00:18:09,150 --> 00:18:12,600
to the concept of function themselves

00:18:10,590 --> 00:18:14,940
and the standard library just give us so

00:18:12,600 --> 00:18:16,530
many tools that we can do a lot at

00:18:14,940 --> 00:18:17,880
compile time and so we can take

00:18:16,530 --> 00:18:19,560
something like this and translate it

00:18:17,880 --> 00:18:22,970
into base three and it could be a

00:18:19,560 --> 00:18:22,970
concept that's nice

00:18:24,420 --> 00:18:28,740
some little bit on the the suffix

00:18:26,490 --> 00:18:31,620
details thinks you you may not know and

00:18:28,740 --> 00:18:34,470
and it probably happy you don't but the

00:18:31,620 --> 00:18:36,270
standard says very carefully that names

00:18:34,470 --> 00:18:38,520
that don't start with none to score are

00:18:36,270 --> 00:18:40,080
reserved to the implementation and of

00:18:38,520 --> 00:18:41,640
course you know that underscore capital

00:18:40,080 --> 00:18:44,990
letter is also reserved the

00:18:41,640 --> 00:18:48,990
implementation but we can do this

00:18:44,990 --> 00:18:53,580
operator underscore that's nice this is

00:18:48,990 --> 00:18:55,890
operator six underscores I don't

00:18:53,580 --> 00:18:59,640
recommend it but you can you can also do

00:18:55,890 --> 00:19:06,410
this this is a valid identifier by the

00:18:59,640 --> 00:19:06,410
way this is the name of a song from 1962

00:19:06,620 --> 00:19:12,450
beechwood four five seven eight nine you

00:19:09,660 --> 00:19:13,650
guys are not into the 60s well you had

00:19:12,450 --> 00:19:16,470
to be there

00:19:13,650 --> 00:19:17,940
so here's 42 and it always returns 42

00:19:16,470 --> 00:19:20,730
alright this is probably a bad idea

00:19:17,940 --> 00:19:23,250
right no one would ever do that but the

00:19:20,730 --> 00:19:25,650
point of C++ if you why is the language

00:19:23,250 --> 00:19:29,730
so complex why is the standard eighteen

00:19:25,650 --> 00:19:35,280
hundred plus pages going for mm actually

00:19:29,730 --> 00:19:39,750
C++ 20 is actually two thousand pages in

00:19:35,280 --> 00:19:42,120
the standard well it gives us capability

00:19:39,750 --> 00:19:45,390
and it's not hard to program in because

00:19:42,120 --> 00:19:47,910
we don't program with the language we

00:19:45,390 --> 00:19:49,950
program with idioms and convention and

00:19:47,910 --> 00:19:52,320
so on so the job of the language is a

00:19:49,950 --> 00:19:56,370
substrate for that is to be flexible and

00:19:52,320 --> 00:19:58,500
useful so we can do things like this if

00:19:56,370 --> 00:20:01,980
you like me I never can deal with

00:19:58,500 --> 00:20:04,680
standard bind it I always get everything

00:20:01,980 --> 00:20:07,740
wrong so I want to have comments in here

00:20:04,680 --> 00:20:11,910
so what I'm going to do is use a literal

00:20:07,740 --> 00:20:14,520
is a use a user-defined operator to

00:20:11,910 --> 00:20:15,420
redefine these placeholder types so

00:20:14,520 --> 00:20:16,710
underscore one

00:20:15,420 --> 00:20:18,240
is gonna be a suffix that returns

00:20:16,710 --> 00:20:20,580
underscore one these are two different

00:20:18,240 --> 00:20:22,800
underscore ones by the way so the nice

00:20:20,580 --> 00:20:24,090
thing is now I can write this I have

00:20:22,800 --> 00:20:26,790
little comments here next to my

00:20:24,090 --> 00:20:30,870
placeholders now this is not really a

00:20:26,790 --> 00:20:33,060
recommendation but the point is we want

00:20:30,870 --> 00:20:35,160
this flexibility in our language so we

00:20:33,060 --> 00:20:38,370
can do things like this where it makes

00:20:35,160 --> 00:20:41,730
sense it doesn't always make sense but

00:20:38,370 --> 00:20:46,620
that's no reason not to do it here's a

00:20:41,730 --> 00:20:49,230
nice thing starting in C++ 14 we can

00:20:46,620 --> 00:20:52,650
have an underscore capital letter at the

00:20:49,230 --> 00:20:54,810
start of a user-defined literal provided

00:20:52,650 --> 00:20:58,560
we don't have a space between the last

00:20:54,810 --> 00:21:00,210
quote in the start of the suffix and

00:20:58,560 --> 00:21:02,910
when I first saw this I was thinking

00:21:00,210 --> 00:21:04,950
like well I say that a lot when I'm

00:21:02,910 --> 00:21:07,950
reading the standard but the nice thing

00:21:04,950 --> 00:21:10,440
is now we can use capital letters and a

00:21:07,950 --> 00:21:12,750
lot of user-defined literals are gonna

00:21:10,440 --> 00:21:17,400
produce things of a class type like this

00:21:12,750 --> 00:21:18,660
Q sub to stock literal and our class

00:21:17,400 --> 00:21:21,300
types usually start with uppercase

00:21:18,660 --> 00:21:25,440
letters in civilized programming

00:21:21,300 --> 00:21:26,940
standards so so now we can do that we

00:21:25,440 --> 00:21:28,230
don't even say lowercase stock wouldn't

00:21:26,940 --> 00:21:29,760
say uppercase talk this is the type of

00:21:28,230 --> 00:21:32,640
thing return that's a little bit clearer

00:21:29,760 --> 00:21:35,040
we can also use keywords of course we

00:21:32,640 --> 00:21:36,570
can have an operator auto so you can

00:21:35,040 --> 00:21:40,110
write things like this auto board equals

00:21:36,570 --> 00:21:43,920
Ford auto now the night the good thing

00:21:40,110 --> 00:21:46,050
about this is that only that this is not

00:21:43,920 --> 00:21:47,370
available to mortals it's only available

00:21:46,050 --> 00:21:48,540
to standard library writers but

00:21:47,370 --> 00:21:51,900
eventually it's going to be quite useful

00:21:48,540 --> 00:21:53,070
the only thing the standard library can

00:21:51,900 --> 00:21:55,050
think of it uses this is a

00:21:53,070 --> 00:21:58,590
floating-point implementation of a

00:21:55,050 --> 00:22:01,230
imaginary number so this is a this if is

00:21:58,590 --> 00:22:02,820
not a keyword this is a user-defined

00:22:01,230 --> 00:22:06,810
literal but in the future we'll find

00:22:02,820 --> 00:22:09,750
other uses for them I choose not to

00:22:06,810 --> 00:22:14,610
explain that for so Google should be a

00:22:09,750 --> 00:22:17,040
little bit happier now right now instead

00:22:14,610 --> 00:22:18,270
of writing underscore date people's

00:22:17,040 --> 00:22:20,610
wondering well is this type going to use

00:22:18,270 --> 00:22:23,040
a date or a date we can say it's going

00:22:20,610 --> 00:22:26,730
to produce a date so that's a little bit

00:22:23,040 --> 00:22:28,380
clearer a little bit nicer but I'd like

00:22:26,730 --> 00:22:28,950
to talk about literal operator templates

00:22:28,380 --> 00:22:30,510
in the

00:22:28,950 --> 00:22:33,540
five seconds remaining we have seven

00:22:30,510 --> 00:22:35,550
minutes the nice thing about this is it

00:22:33,540 --> 00:22:37,080
actually gets the characters that make

00:22:35,550 --> 00:22:39,120
up the literal the other nice thing

00:22:37,080 --> 00:22:40,500
about it is it's a template and once you

00:22:39,120 --> 00:22:44,730
have a template you can do anything you

00:22:40,500 --> 00:22:47,190
want you can do good you can do evil

00:22:44,730 --> 00:22:48,390
it'll be very efficient so here's an

00:22:47,190 --> 00:22:52,200
example we actually just get the

00:22:48,390 --> 00:22:54,810
characters and the the the format of

00:22:52,200 --> 00:22:57,600
this is fixed this is the only template

00:22:54,810 --> 00:23:00,510
parameter you can have no arguments are

00:22:57,600 --> 00:23:02,550
allowed so if you want to do any really

00:23:00,510 --> 00:23:04,590
cute template metaprogramming it has to

00:23:02,550 --> 00:23:07,050
be done on the return type because

00:23:04,590 --> 00:23:09,900
that's your only choice

00:23:07,050 --> 00:23:11,280
so here's pretty simple one Len it tells

00:23:09,900 --> 00:23:13,230
you how many characters you got so in

00:23:11,280 --> 00:23:14,820
this case it will count all of the

00:23:13,230 --> 00:23:16,470
characters not just the numeric ones but

00:23:14,820 --> 00:23:21,020
also this quote we stuck in there for no

00:23:16,470 --> 00:23:24,240
good reason and again this works for

00:23:21,020 --> 00:23:26,010
floating-point and integer literals and

00:23:24,240 --> 00:23:28,860
that's all you can just not work for

00:23:26,010 --> 00:23:30,150
character literals so this will compile

00:23:28,860 --> 00:23:34,640
this will compile this will be able to

00:23:30,150 --> 00:23:34,640
compile so why is this important

00:23:35,090 --> 00:23:41,430
I'm gonna skip over this and I'm sure

00:23:38,810 --> 00:23:44,670
just a couple of restrictions there so

00:23:41,430 --> 00:23:46,650
why do raw operators matter one is

00:23:44,670 --> 00:23:49,350
syntax you might want to enforce a given

00:23:46,650 --> 00:23:51,420
syntax on a user-defined literal so we

00:23:49,350 --> 00:23:54,080
saw before that we probably you know

00:23:51,420 --> 00:23:56,720
don't want to have a dead leaf date

00:23:54,080 --> 00:24:00,990
although I've been subscribed that way

00:23:56,720 --> 00:24:02,880
we want this format precisely and we'd

00:24:00,990 --> 00:24:04,470
like to enforce that but in this case we

00:24:02,880 --> 00:24:06,480
can't enforce any particular format

00:24:04,470 --> 00:24:09,300
because we are getting the cooked value

00:24:06,480 --> 00:24:12,450
of the literal so what we really like to

00:24:09,300 --> 00:24:14,760
do is have the characters and now we can

00:24:12,450 --> 00:24:16,560
actually get the characters here and we

00:24:14,760 --> 00:24:19,200
can confirm in the implementation of

00:24:16,560 --> 00:24:23,670
date that the format of this is correct

00:24:19,200 --> 00:24:25,980
and since c++ 17 anybody can write this

00:24:23,670 --> 00:24:27,540
to produce a compile time constant it's

00:24:25,980 --> 00:24:29,520
just really easy because we've right

00:24:27,540 --> 00:24:32,370
context for functions we used to have to

00:24:29,520 --> 00:24:35,370
do you know fancy character pack nested

00:24:32,370 --> 00:24:37,500
indexing and whatever at compile time no

00:24:35,370 --> 00:24:40,350
more we can just write a function and

00:24:37,500 --> 00:24:42,179
it'll get us the right result the other

00:24:40,350 --> 00:24:44,429
reason we like

00:24:42,179 --> 00:24:46,679
user defined literals sorry a literal

00:24:44,429 --> 00:24:48,419
operator templates is that there are

00:24:46,679 --> 00:24:51,509
limitations in the base language I mean

00:24:48,419 --> 00:24:53,489
you know this is a pretty big number but

00:24:51,509 --> 00:24:55,799
it may not be big enough I mean this

00:24:53,489 --> 00:24:56,879
will probably not compile because this

00:24:55,799 --> 00:24:58,619
is going to overflow most

00:24:56,879 --> 00:25:01,499
implementations of a lot unsigned long

00:24:58,619 --> 00:25:02,009
long so if we want to have a lot of

00:25:01,499 --> 00:25:03,269
slugs

00:25:02,009 --> 00:25:04,529
you know we're measuring the mass of the

00:25:03,269 --> 00:25:07,799
universe or something like that and

00:25:04,529 --> 00:25:09,059
slugs this is not gonna work and also

00:25:07,799 --> 00:25:12,749
you could have some user-defined types

00:25:09,059 --> 00:25:16,859
that are quite large and we want this to

00:25:12,749 --> 00:25:19,079
actually compile so the nice thing again

00:25:16,859 --> 00:25:20,909
this will fail but here we'll get the

00:25:19,079 --> 00:25:22,859
actual characters now I actually haven't

00:25:20,909 --> 00:25:24,689
done this for you in 512 but it had I

00:25:22,859 --> 00:25:27,389
did a nice implementation for you in 128

00:25:24,689 --> 00:25:29,449
and it works fine you can parse

00:25:27,389 --> 00:25:31,739
extremely long numeric literals and

00:25:29,449 --> 00:25:35,959
everything works fine and you can do it

00:25:31,739 --> 00:25:35,959
at compile time so that's great

00:25:36,229 --> 00:25:41,519
literal operator templates versus raw

00:25:38,669 --> 00:25:44,099
literal operators well there's a slight

00:25:41,519 --> 00:25:45,629
difference I mean chances are this is

00:25:44,099 --> 00:25:49,379
going to be a compile-time constant but

00:25:45,629 --> 00:25:53,819
not necessarily because I could call the

00:25:49,379 --> 00:25:56,099
literal operator sorry the wrong the

00:25:53,819 --> 00:25:59,219
rule operator whatever it's called with

00:25:56,099 --> 00:26:02,069
a runtime value like this so this is

00:25:59,219 --> 00:26:05,039
weird but it's legal this is less weird

00:26:02,069 --> 00:26:06,809
it's also legal but the thing is because

00:26:05,039 --> 00:26:08,189
this could is not necessarily compile

00:26:06,809 --> 00:26:09,809
time constant I can't use a static

00:26:08,189 --> 00:26:11,939
assertion in the implementation and

00:26:09,809 --> 00:26:13,709
that's just very irritating but the

00:26:11,939 --> 00:26:16,799
literal operator template this is a a

00:26:13,709 --> 00:26:18,449
parameter Peck sorry a character Peck

00:26:16,799 --> 00:26:21,329
it's guaranteed to be a compile-time

00:26:18,449 --> 00:26:22,979
constant and I can use static assertions

00:26:21,329 --> 00:26:25,129
on it it makes things a lot easier to

00:26:22,979 --> 00:26:27,209
write you know how would you catch this

00:26:25,129 --> 00:26:30,229
in a situation where this is not

00:26:27,209 --> 00:26:33,839
necessarily compile time constant you

00:26:30,229 --> 00:26:36,839
could throw an exception starting a C++

00:26:33,839 --> 00:26:39,389
14 you can use an assert in both cases

00:26:36,839 --> 00:26:41,369
your compiler is going to say abusive

00:26:39,389 --> 00:26:43,199
things about you because you haven't no

00:26:41,369 --> 00:26:44,789
except here it'll say you have an

00:26:43,199 --> 00:26:47,189
exception of no except function you know

00:26:44,789 --> 00:26:48,839
what's wrong with you and they get

00:26:47,189 --> 00:26:50,039
really upset so I'd rather just avoid

00:26:48,839 --> 00:26:51,239
that I don't want you don't want to get

00:26:50,039 --> 00:26:52,319
into an argument with your compiler

00:26:51,239 --> 00:26:54,499
because it's already a strange

00:26:52,319 --> 00:26:54,499
relationship

00:26:54,650 --> 00:27:00,410
so I really do prefer the template first

00:26:57,230 --> 00:27:03,590
now we've we have very few options for

00:27:00,410 --> 00:27:05,930
using spin a in a situation like this we

00:27:03,590 --> 00:27:08,720
can't use it here this is fixed we can't

00:27:05,930 --> 00:27:10,910
add additional arguments we have no

00:27:08,720 --> 00:27:13,580
arguments here so we're restricted to

00:27:10,910 --> 00:27:15,620
the return type but you can have

00:27:13,580 --> 00:27:18,860
conditions here here I'm using enable if

00:27:15,620 --> 00:27:21,680
for some compile time condition and if

00:27:18,860 --> 00:27:23,930
it succeeds then this function will have

00:27:21,680 --> 00:27:26,420
a return type of date if it fails it'll

00:27:23,930 --> 00:27:27,920
fail substitution and maybe I can

00:27:26,420 --> 00:27:31,429
overload on a different implementation

00:27:27,920 --> 00:27:33,559
of date so if you want to support

00:27:31,429 --> 00:27:34,910
various different date formats you could

00:27:33,559 --> 00:27:36,650
have a whole bunch of them and then

00:27:34,910 --> 00:27:40,330
enable one or the other depending on

00:27:36,650 --> 00:27:40,330
your locale or something like that

00:27:40,660 --> 00:27:46,730
here's another example where we yeah

00:27:45,350 --> 00:27:50,540
another reason to prefer templates is

00:27:46,730 --> 00:27:52,610
there's really no reason to prefer a raw

00:27:50,540 --> 00:27:54,320
literal operator now because basically

00:27:52,610 --> 00:27:57,770
whatever you can do here you can also do

00:27:54,320 --> 00:27:59,750
here's recent changes in sequels +17 to

00:27:57,770 --> 00:28:04,270
our standard library containers make it

00:27:59,750 --> 00:28:07,010
trivially easy to basically turn this

00:28:04,270 --> 00:28:09,950
turn the character pack into a very

00:28:07,010 --> 00:28:14,000
usable compile time data structure so

00:28:09,950 --> 00:28:17,270
I've again I'm template centric now

00:28:14,000 --> 00:28:19,370
what's Google's problem now they say

00:28:17,270 --> 00:28:23,179
it's hard to use an abstract data type

00:28:19,370 --> 00:28:25,730
and not also use the user to find

00:28:23,179 --> 00:28:29,450
literals the author of the data type

00:28:25,730 --> 00:28:30,860
wrote to work with the data type kind of

00:28:29,450 --> 00:28:34,370
like not being able to use the

00:28:30,860 --> 00:28:36,080
overloaded operators it's kind of like

00:28:34,370 --> 00:28:37,610
saying yeah we want the class button all

00:28:36,080 --> 00:28:39,230
the keys open loaded operators we don't

00:28:37,610 --> 00:28:40,670
want the literals and I don't even like

00:28:39,230 --> 00:28:42,470
all these member functions why do I have

00:28:40,670 --> 00:28:46,670
to take all the minutes you know some

00:28:42,470 --> 00:28:48,350
people just are never happy so how do

00:28:46,670 --> 00:28:49,880
you deal with this well I would just

00:28:48,350 --> 00:28:51,950
call it the person who wrote the class

00:28:49,880 --> 00:28:53,990
and say these are stinky operators I

00:28:51,950 --> 00:28:56,510
don't want them to take them out that's

00:28:53,990 --> 00:28:58,070
one thing you can do or you can this is

00:28:56,510 --> 00:29:00,470
what the standard library does is this

00:28:58,070 --> 00:29:03,530
sticks the user-defined literals in a

00:29:00,470 --> 00:29:06,560
nested namespace so we have to say we

00:29:03,530 --> 00:29:07,340
want to use them now this is an inline

00:29:06,560 --> 00:29:07,980
namespace

00:29:07,340 --> 00:29:11,429
so if

00:29:07,980 --> 00:29:14,580
I said using yes using standard string I

00:29:11,429 --> 00:29:17,340
would also get the operators but simply

00:29:14,580 --> 00:29:19,620
by doing this I can get the the

00:29:17,340 --> 00:29:22,080
operators the user-defined literals but

00:29:19,620 --> 00:29:23,309
I still have to specifically say I want

00:29:22,080 --> 00:29:28,710
strength this needs to be a very

00:29:23,309 --> 00:29:31,650
reasonable way to solve this problem but

00:29:28,710 --> 00:29:34,620
Google's not satisfied so one thing they

00:29:31,650 --> 00:29:38,190
might want to do in the last eight

00:29:34,620 --> 00:29:40,440
seconds we have here is show how we can

00:29:38,190 --> 00:29:42,870
use a literal operator template to

00:29:40,440 --> 00:29:44,580
basically provide two versions one if

00:29:42,870 --> 00:29:46,140
you want to use a particular operator

00:29:44,580 --> 00:29:48,710
here's an underscore hash that gives you

00:29:46,140 --> 00:29:51,450
a hash value and the other if you don't

00:29:48,710 --> 00:29:53,010
you get to pick one or the other by

00:29:51,450 --> 00:29:57,780
choice at compile time

00:29:53,010 --> 00:29:59,760
so going quickly all we have to do is

00:29:57,780 --> 00:30:01,350
provide a span a condition and here I'm

00:29:59,760 --> 00:30:03,750
using a trailing return type to show

00:30:01,350 --> 00:30:08,940
that I am modern but I could also put

00:30:03,750 --> 00:30:11,070
this up here and basically I have a

00:30:08,940 --> 00:30:12,960
condition if the condition is true you

00:30:11,070 --> 00:30:14,850
know then this will be enabled this will

00:30:12,960 --> 00:30:16,260
be disabled if this is true then this

00:30:14,850 --> 00:30:18,540
will be disabled so I'll either get the

00:30:16,260 --> 00:30:21,720
I want to use hash version or I don't

00:30:18,540 --> 00:30:25,080
want to use hash version and I can

00:30:21,720 --> 00:30:27,299
implement this and again this is

00:30:25,080 --> 00:30:30,350
unfairly quickly but here's here's

00:30:27,299 --> 00:30:34,020
something that declares a variable

00:30:30,350 --> 00:30:36,000
template that is false this is a primary

00:30:34,020 --> 00:30:37,290
variable Network now we can specialize

00:30:36,000 --> 00:30:39,450
variable templates the same we can

00:30:37,290 --> 00:30:43,160
specialize class templates and

00:30:39,450 --> 00:30:48,000
unfortunately a function template and

00:30:43,160 --> 00:30:53,220
here is the hash condition it is defined

00:30:48,000 --> 00:30:54,780
by something that is always true the

00:30:53,220 --> 00:30:56,460
size of characters is always going to be

00:30:54,780 --> 00:30:58,559
nonzero in a literal operator template

00:30:56,460 --> 00:31:02,100
because me at least one character there

00:30:58,559 --> 00:31:04,110
to parse the template correctly and we

00:31:02,100 --> 00:31:08,130
will provide a complete specialization

00:31:04,110 --> 00:31:10,919
if we want to use this we want to enable

00:31:08,130 --> 00:31:12,179
this hash so here is a complete

00:31:10,919 --> 00:31:14,309
specialization of this variable

00:31:12,179 --> 00:31:16,620
temperature if this is not present this

00:31:14,309 --> 00:31:19,110
is always gives a false value if this is

00:31:16,620 --> 00:31:20,760
present it will give a always get a true

00:31:19,110 --> 00:31:21,809
value because this the complete

00:31:20,760 --> 00:31:24,539
specialization

00:31:21,809 --> 00:31:26,999
to the primary the session is over but

00:31:24,539 --> 00:31:29,849
I'll just say here's a macro I don't

00:31:26,999 --> 00:31:31,440
like macros but whatever there's a macro

00:31:29,849 --> 00:31:32,700
that makes it easy to write and now you

00:31:31,440 --> 00:31:33,059
can say that it's include hash include'

00:31:32,700 --> 00:31:35,759
date

00:31:33,059 --> 00:31:37,859
I want hash I don't want date this is a

00:31:35,759 --> 00:31:42,749
work it may compile time error problem

00:31:37,859 --> 00:31:46,379
solved so much for Google this is not

00:31:42,749 --> 00:31:49,289
perfect we really do want to have more

00:31:46,379 --> 00:31:51,659
refined uses of this we might want to

00:31:49,289 --> 00:31:54,179
include namespaces in this as well and

00:31:51,659 --> 00:31:56,909
we know we'd also like to make sure that

00:31:54,179 --> 00:31:58,469
all over user-defined operators can be

00:31:56,909 --> 00:32:00,719
templates because templates are just

00:31:58,469 --> 00:32:03,389
very useful we want to be able to

00:32:00,719 --> 00:32:05,489
overload them a variety of ways so use

00:32:03,389 --> 00:32:07,289
user-defined literals literal operator

00:32:05,489 --> 00:32:11,580
templates are you go to literal operator

00:32:07,289 --> 00:32:14,309
and they should make your code easy to

00:32:11,580 --> 00:32:15,640
use correctly and hard to use and so

00:32:14,309 --> 00:32:21,799
thank you

00:32:15,640 --> 00:32:21,799

YouTube URL: https://www.youtube.com/watch?v=gxMiiI19VnQ


