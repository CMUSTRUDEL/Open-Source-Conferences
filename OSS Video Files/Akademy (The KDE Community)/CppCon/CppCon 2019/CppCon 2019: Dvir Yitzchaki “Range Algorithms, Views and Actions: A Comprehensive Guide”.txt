Title: CppCon 2019: Dvir Yitzchaki “Range Algorithms, Views and Actions: A Comprehensive Guide”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
STL algorithms are something every C++ programmer should know. With ranges being voted in C++ 20, there are even more useful tools that we should at least be aware of, if not use daily.

Using ranges helps writing a code which is great in expressiveness and safety and does not fall behind in performance. In this talk we will cover what ranges add to the C++20 standard library, as well as go over all the different views and actions available in range-v3 library which can be used today.

This talk is inspired by Jonathan Boccara’s talk "105 algorithms in less than an hour".
— 
Dvir Yitzchaki
Verizon Media
Sr. Software Engineer
Israel

Dvir is a senior software engineer at Verizon Media. He has been doing C++ for 12 years, lately only for a hobby. He has contributed to a number of open source projects including Hunter package manager and Catch2 unit testing framework. He has spoken for Core C++ meetup and conference.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,320 --> 00:00:19,000
hello I'm here and today we're going to

00:00:14,350 --> 00:00:21,849
talk about ranges if you have questions

00:00:19,000 --> 00:00:28,380
please approach the mic here so I and

00:00:21,849 --> 00:00:32,559
everybody else can hear well so first

00:00:28,380 --> 00:00:36,220
some words about me I work at Verizon

00:00:32,559 --> 00:00:40,870
media I occasionally speak at our local

00:00:36,220 --> 00:00:43,770
meetup at Israel gossip estas I can find

00:00:40,870 --> 00:00:46,720
me as Devere it's at most social media

00:00:43,770 --> 00:00:53,140
except for Twitter where its vids was

00:00:46,720 --> 00:00:55,090
taken and I like going to use the

00:00:53,140 --> 00:00:57,970
concerts that's where I get all my

00:00:55,090 --> 00:01:00,610
t-shirts off except for simple past

00:00:57,970 --> 00:01:06,119
conferences maybe the left one being

00:01:00,610 --> 00:01:09,460
Eric Clapton in I'll recommend it and

00:01:06,119 --> 00:01:11,430
that will explain the the pictures you

00:01:09,460 --> 00:01:14,400
will see later on

00:01:11,430 --> 00:01:19,479
those are all from my concerts I went to

00:01:14,400 --> 00:01:22,360
so anyway I also like to thank Chris

00:01:19,479 --> 00:01:26,799
develop for helping me prepare my talk

00:01:22,360 --> 00:01:29,500
and Alicia bit for studying the course

00:01:26,799 --> 00:01:32,549
it was past users user group and also

00:01:29,500 --> 00:01:37,240
for helping me prepare prepare my

00:01:32,549 --> 00:01:41,619
alright so watch why should we care

00:01:37,240 --> 00:01:47,200
about ranges so first let let ask

00:01:41,619 --> 00:01:49,330
ourselves what is arranged so arranging

00:01:47,200 --> 00:01:52,180
the sequence of elements between two

00:01:49,330 --> 00:01:58,450
locations I&K which we often denote by

00:01:52,180 --> 00:02:04,240
the half-open range i comma k but if you

00:01:58,450 --> 00:02:07,570
think about it most what you do with

00:02:04,240 --> 00:02:12,870
ranges today is passing them to standard

00:02:07,570 --> 00:02:16,090
algorithms of course and there are

00:02:12,870 --> 00:02:19,419
several ways that you call an

00:02:16,090 --> 00:02:21,680
installment standard algorithms rather

00:02:19,419 --> 00:02:25,400
you pass a pair of iterators

00:02:21,680 --> 00:02:29,739
begin and end usually or you pass an

00:02:25,400 --> 00:02:35,390
iterator in account or you have this

00:02:29,739 --> 00:02:38,750
really strange bathroom iterator and you

00:02:35,390 --> 00:02:42,519
need to default construct one and to

00:02:38,750 --> 00:02:45,200
signal the end of the stream okay so

00:02:42,519 --> 00:02:48,500
this iterator is not a position in some

00:02:45,200 --> 00:02:53,120
sequence but in fact it's a predicate

00:02:48,500 --> 00:02:55,989
wrapped inside an iterator that cause

00:02:53,120 --> 00:03:04,659
the input stream to check if it's

00:02:55,989 --> 00:03:09,079
exhausted right so pair of iterators

00:03:04,659 --> 00:03:14,389
either cannot model or only models with

00:03:09,079 --> 00:03:17,269
like strange hex all the use cases we

00:03:14,389 --> 00:03:22,670
want from ranges so why not have a

00:03:17,269 --> 00:03:27,949
single construct to cover them all and

00:03:22,670 --> 00:03:31,160
of course ranges give us this nicer

00:03:27,949 --> 00:03:37,400
syntax instead of passing begin and end

00:03:31,160 --> 00:03:40,150
just best V so this is also shorter but

00:03:37,400 --> 00:03:42,650
we thought it is also most more safer

00:03:40,150 --> 00:03:44,840
right because you can't mix and match

00:03:42,650 --> 00:03:51,229
iterators from different containers by

00:03:44,840 --> 00:03:55,430
accident and not just just that because

00:03:51,229 --> 00:03:59,659
having a single object that we need to

00:03:55,430 --> 00:04:03,199
pass two algorithms open the door to reg

00:03:59,659 --> 00:04:08,030
adapters which lazily transform the

00:04:03,199 --> 00:04:11,739
sequence and can be composed in many

00:04:08,030 --> 00:04:18,049
interesting ways and we'll talk about it

00:04:11,739 --> 00:04:20,269
today so the good news are that you

00:04:18,049 --> 00:04:23,570
don't have to wait for your compiler to

00:04:20,269 --> 00:04:26,300
ship C + + 20 a standard library you can

00:04:23,570 --> 00:04:30,229
use ranges today with the following

00:04:26,300 --> 00:04:33,110
libraries first seems we have two CMC

00:04:30,229 --> 00:04:35,330
STL two by KC color this is the

00:04:33,110 --> 00:04:38,139
reference implementation for the

00:04:35,330 --> 00:04:43,099
standard and it works only with the

00:04:38,139 --> 00:04:46,250
concept support from the compiler nano

00:04:43,099 --> 00:04:48,550
rage by Tristan it's a simple 17

00:04:46,250 --> 00:04:51,080
implementation of what's in the standard

00:04:48,550 --> 00:04:54,849
and it has a pretty good compiler

00:04:51,080 --> 00:05:00,879
support and of course ranked me 3

00:04:54,849 --> 00:05:04,460
written by Eric nibbler this is what

00:05:00,879 --> 00:05:07,099
basically started up all the ranges I

00:05:04,460 --> 00:05:10,449
thought it has everything that is in the

00:05:07,099 --> 00:05:10,449
standard and much much more

00:05:10,520 --> 00:05:18,169
as we'll see today so I chose to focus

00:05:14,599 --> 00:05:21,650
on what in rate v3 and not just what's

00:05:18,169 --> 00:05:27,469
in the standard because why not use it

00:05:21,650 --> 00:05:30,009
it gives us more tools and as corners

00:05:27,469 --> 00:05:33,289
showed us at the beginning of this week

00:05:30,009 --> 00:05:37,479
we need to know what tools we have in

00:05:33,289 --> 00:05:43,279
our disposal so in time of need we know

00:05:37,479 --> 00:05:50,409
what algorithm to choose and what tools

00:05:43,279 --> 00:05:55,969
we have so as you might already know

00:05:50,409 --> 00:05:59,029
range range libraries use concepts to

00:05:55,969 --> 00:06:02,120
constraint the different algorithm they

00:05:59,029 --> 00:06:04,219
have so in order to properly use those

00:06:02,120 --> 00:06:08,360
algorithms we should familiarize

00:06:04,219 --> 00:06:12,020
ourselves with the basic concepts but

00:06:08,360 --> 00:06:18,169
first here is a declaration of started

00:06:12,020 --> 00:06:19,789
rich from C++ 17 styled library does

00:06:18,169 --> 00:06:30,440
anyone happen to know what is the return

00:06:19,789 --> 00:06:33,610
type here no Marshall right ok so we

00:06:30,440 --> 00:06:36,349
have a standard library implementer here

00:06:33,610 --> 00:06:39,349
well I didn't know it until I made the

00:06:36,349 --> 00:06:42,409
slides and it's it returns the function

00:06:39,349 --> 00:06:44,650
you pass into it I still don't know why

00:06:42,409 --> 00:06:44,650
but

00:06:52,060 --> 00:07:06,830
yeah

00:06:53,330 --> 00:07:10,010
okay so uh sure yeah actually we will

00:07:06,830 --> 00:07:14,120
see there is but anyway the comment from

00:07:10,010 --> 00:07:16,610
Marshall was that instead of returnable

00:07:14,120 --> 00:07:18,560
why not return whatever useful

00:07:16,610 --> 00:07:21,610
information we have and the function

00:07:18,560 --> 00:07:24,230
might have stated we want to pass on

00:07:21,610 --> 00:07:29,150
okay but that's not the point I wanted

00:07:24,230 --> 00:07:31,340
to show you let's take a closer look at

00:07:29,150 --> 00:07:33,080
this is a confirming conformant

00:07:31,340 --> 00:07:35,840
implementation I copied from cpp

00:07:33,080 --> 00:07:36,500
reference of both let's take a closer

00:07:35,840 --> 00:07:40,550
look at it

00:07:36,500 --> 00:07:43,550
so first it has the first argument which

00:07:40,550 --> 00:07:45,530
is called first this is basically the

00:07:43,550 --> 00:07:49,790
start of the range you want to work on

00:07:45,530 --> 00:07:51,560
and what algorithm is doing is doing

00:07:49,790 --> 00:07:55,880
with it is to increment it and

00:07:51,560 --> 00:07:57,530
dereference it on each step right so

00:07:55,880 --> 00:08:01,520
turns out these are the two basic

00:07:57,530 --> 00:08:06,140
operations we require that that

00:08:01,520 --> 00:08:09,710
basically we need to to work with the

00:08:06,140 --> 00:08:15,710
ranges so this brings us to a first

00:08:09,710 --> 00:08:18,980
concept which is called input or a potty

00:08:15,710 --> 00:08:22,640
trainer right it was called the iterator

00:08:18,980 --> 00:08:24,620
in the first type of puzzles but it was

00:08:22,640 --> 00:08:28,700
renamed to not conflict with us to the

00:08:24,620 --> 00:08:30,580
iterator class so as we said it's in the

00:08:28,700 --> 00:08:35,660
type which can be referenced and

00:08:30,580 --> 00:08:38,960
incremented and there are many kinds of

00:08:35,660 --> 00:08:43,190
iterators with additional actions if you

00:08:38,960 --> 00:08:49,970
can use on and for example the

00:08:43,190 --> 00:08:55,100
directional iterator you can go back ok

00:08:49,970 --> 00:08:56,660
so that is that bit rate constants again

00:08:55,100 --> 00:08:59,980
if you have questions please approach

00:08:56,660 --> 00:08:59,980
the line all right

00:09:00,290 --> 00:09:08,490
so moving on the second argument is

00:09:04,500 --> 00:09:11,250
called left and this is basically the

00:09:08,490 --> 00:09:13,440
end of the range and all the rhythm is

00:09:11,250 --> 00:09:18,180
doing with it is comparing needs to

00:09:13,440 --> 00:09:22,050
first that's all okay and when the when

00:09:18,180 --> 00:09:25,050
this compare will return when when they

00:09:22,050 --> 00:09:28,560
will be equal the iterator in the start

00:09:25,050 --> 00:09:34,500
in the end the traitor then the range is

00:09:28,560 --> 00:09:43,380
over and we can return so that brings up

00:09:34,500 --> 00:09:45,650
the second concept sentinels so this is

00:09:43,380 --> 00:09:48,090
the the formal definition of the concept

00:09:45,650 --> 00:09:53,280
when it says is that it this is a

00:09:48,090 --> 00:09:55,650
semi-regular type s that s is a sentinel

00:09:53,280 --> 00:09:59,550
for an iterator i if we can compare them

00:09:55,650 --> 00:10:01,580
and if they do not compare equal then we

00:09:59,550 --> 00:10:05,280
know we can the reference i and

00:10:01,580 --> 00:10:11,220
increment it to get closer to the

00:10:05,280 --> 00:10:13,170
sentinel okay so until now a range was

00:10:11,220 --> 00:10:15,990
basically a pair of iterators now it can

00:10:13,170 --> 00:10:20,100
be two different types can be not much

00:10:15,990 --> 00:10:27,240
but can be an iterator and a sentinel

00:10:20,100 --> 00:10:29,660
and that indeed helps us model the all

00:10:27,240 --> 00:10:32,550
the previous cases we've seen before

00:10:29,660 --> 00:10:36,090
because a pair failure an iterator

00:10:32,550 --> 00:10:40,950
itself is it a sentinel so a powerful

00:10:36,090 --> 00:10:44,250
reader can be modeled an iterator in a

00:10:40,950 --> 00:10:46,700
predicate we can simply have a type that

00:10:44,250 --> 00:10:48,930
stores the predicate is the sentinel and

00:10:46,700 --> 00:10:55,040
whoever the predicate when we call

00:10:48,930 --> 00:10:58,350
operator equals and the third one we can

00:10:55,040 --> 00:11:01,410
store the count in the iterator and

00:10:58,350 --> 00:11:03,780
decrement it on each step and then on

00:11:01,410 --> 00:11:06,020
the operator equal check if the count is

00:11:03,780 --> 00:11:06,020
zero

00:11:08,860 --> 00:11:15,470
so finally now we can define what ranges

00:11:12,429 --> 00:11:17,929
this is a type which we can call begin

00:11:15,470 --> 00:11:23,209
and end on and get an iterator in a

00:11:17,929 --> 00:11:25,879
sentinel that's all and arranged I

00:11:23,209 --> 00:11:27,889
communist refers to the elements start

00:11:25,879 --> 00:11:30,860
RI star are plus plus etcetera and kill

00:11:27,889 --> 00:11:41,480
some iterator J that compare equals to

00:11:30,860 --> 00:11:44,980
this Center there are other so parallel

00:11:41,480 --> 00:11:48,769
to the different concepts we've seen for

00:11:44,980 --> 00:11:53,149
iterators their concept for a similar

00:11:48,769 --> 00:11:55,939
concept for ranges so basically the type

00:11:53,149 --> 00:12:02,619
of the iterator you get from begin says

00:11:55,939 --> 00:12:05,119
what concept this range satisfies and

00:12:02,619 --> 00:12:11,749
you can see examples here from the

00:12:05,119 --> 00:12:15,410
library we also have an additional

00:12:11,749 --> 00:12:20,059
concept called common range which is

00:12:15,410 --> 00:12:23,199
arranged that has its sentinel does have

00:12:20,059 --> 00:12:25,360
the same type as it's a iterator for

00:12:23,199 --> 00:12:28,970
example all the standard containers

00:12:25,360 --> 00:12:30,619
because their region thread the central

00:12:28,970 --> 00:12:36,139
concepts of they only have perfect

00:12:30,619 --> 00:12:40,069
Rachel alright so there are other useful

00:12:36,139 --> 00:12:43,759
concepts in Horrible's aside sentinel is

00:12:40,069 --> 00:12:45,889
a sentinel which knows its distance from

00:12:43,759 --> 00:12:50,299
any other iterator in constant time by

00:12:45,889 --> 00:12:53,029
using operator - and a size range is

00:12:50,299 --> 00:12:56,179
arranged which you can call size on and

00:12:53,029 --> 00:12:58,519
get the size in constant time now this

00:12:56,179 --> 00:13:01,339
does not necessarily mean and implies

00:12:58,519 --> 00:13:03,739
that if the range of sorry the sentinel

00:13:01,339 --> 00:13:06,819
of a sized range is itself a side

00:13:03,739 --> 00:13:10,040
sentinel for example standard list

00:13:06,819 --> 00:13:12,350
stores the size inside the list so you

00:13:10,040 --> 00:13:14,989
can query the size in constant time but

00:13:12,350 --> 00:13:16,970
each point in the list does not know in

00:13:14,989 --> 00:13:19,929
constant time its distance from any

00:13:16,970 --> 00:13:19,929
other point right

00:13:21,450 --> 00:13:26,670
in addition in any case whether it's a

00:13:24,870 --> 00:13:29,850
size range or not we can call ranges

00:13:26,670 --> 00:13:32,760
distance to get its size except it might

00:13:29,850 --> 00:13:35,490
be a linear complexity for non size

00:13:32,760 --> 00:13:37,800
ranges we can check if the range is

00:13:35,490 --> 00:13:41,220
empty and for contiguous ranges we can

00:13:37,800 --> 00:13:46,890
call data and get a pointer to the

00:13:41,220 --> 00:13:51,270
memory all right so these are the basic

00:13:46,890 --> 00:13:54,630
concepts now we can start talking about

00:13:51,270 --> 00:14:00,530
algorithms okay this is the most first

00:13:54,630 --> 00:14:03,330
thing you do when you have a range and

00:14:00,530 --> 00:14:07,790
almost all of the algorithms you know

00:14:03,330 --> 00:14:10,710
you know are supported in range v3 so

00:14:07,790 --> 00:14:12,420
again continuing with this for each

00:14:10,710 --> 00:14:14,190
example this is the declaration of

00:14:12,420 --> 00:14:18,840
reached from the staples past when you

00:14:14,190 --> 00:14:22,100
working draft I know it's scary but

00:14:18,840 --> 00:14:25,500
let's take it one part at a time

00:14:22,100 --> 00:14:27,470
so first we have two overloads one which

00:14:25,500 --> 00:14:30,470
takes an iterator in a sentinel and

00:14:27,470 --> 00:14:33,150
another one which takes a whole range

00:14:30,470 --> 00:14:38,790
okay so we still have the option to send

00:14:33,150 --> 00:14:42,330
an iterator an essential separately then

00:14:38,790 --> 00:14:47,100
we have a constraint fraction okay don't

00:14:42,330 --> 00:14:49,800
need to read the details about the

00:14:47,100 --> 00:14:54,180
concept of the function just know it's

00:14:49,800 --> 00:14:56,280
there and the return type instead of

00:14:54,180 --> 00:15:00,930
just being the function is now a struct

00:14:56,280 --> 00:15:04,560
called for each result and here it is so

00:15:00,930 --> 00:15:07,910
it has the function called fun and it

00:15:04,560 --> 00:15:11,370
also has day-trader

00:15:07,910 --> 00:15:12,690
called in in this case so so what is

00:15:11,370 --> 00:15:16,010
this iterator which we didn't have

00:15:12,690 --> 00:15:19,320
before so again what we pass to the

00:15:16,010 --> 00:15:22,350
algorithm is a sentinel is not it is not

00:15:19,320 --> 00:15:26,070
necessarily an iterator so what

00:15:22,350 --> 00:15:28,380
algorithm returns us is the ad each

00:15:26,070 --> 00:15:31,710
Raider the iterator that compared equal

00:15:28,380 --> 00:15:33,600
to the sentinel okay so this is an

00:15:31,710 --> 00:15:39,390
information we didn't have before so

00:15:33,600 --> 00:15:42,450
it may be useful to return it back okay

00:15:39,390 --> 00:15:45,480
so let's use it here I've implemented a

00:15:42,450 --> 00:15:49,400
poor-man's accumulator so I have a

00:15:45,480 --> 00:15:53,460
vector with four numbers 0 2 4 & 6 I

00:15:49,400 --> 00:15:55,680
have my son and I call for each with a

00:15:53,460 --> 00:15:58,620
lambda which increments this the sum by

00:15:55,680 --> 00:16:03,750
the value it gets so if I call it on my

00:15:58,620 --> 00:16:05,490
vector sum will be 12 okay and then we

00:16:03,750 --> 00:16:09,300
take back the iterator and function from

00:16:05,490 --> 00:16:10,830
this returns truck to see and the

00:16:09,300 --> 00:16:13,320
iterator will point to the end of the

00:16:10,830 --> 00:16:15,360
vector and the function is the same

00:16:13,320 --> 00:16:17,430
function as the lambda so we can call it

00:16:15,360 --> 00:16:20,700
again with one and it will increment sum

00:16:17,430 --> 00:16:22,590
again by one okay I'm not saying you

00:16:20,700 --> 00:16:30,930
should write it like but I just wanted

00:16:22,590 --> 00:16:33,750
to show a possible uses by the way all

00:16:30,930 --> 00:16:38,610
the code samples you'll see today can be

00:16:33,750 --> 00:16:42,660
found at my github they're tested with

00:16:38,610 --> 00:16:45,690
both 23 and same csto to whatever is

00:16:42,660 --> 00:16:48,810
supported there and the samples assumed

00:16:45,690 --> 00:16:50,570
using namespace ranges so they fit the

00:16:48,810 --> 00:16:53,910
slides

00:16:50,570 --> 00:16:57,600
okay so returning to the Declaration of

00:16:53,910 --> 00:17:00,570
rich I know I don't know if anyone of

00:16:57,600 --> 00:17:03,180
you are noticed but the overload which

00:17:00,570 --> 00:17:07,199
takes range does not return for each

00:17:03,180 --> 00:17:13,040
result of an iterator but of save each

00:17:07,199 --> 00:17:18,300
radio chip okay so that's interesting

00:17:13,040 --> 00:17:20,220
why do we need this so think about this

00:17:18,300 --> 00:17:23,189
example you have a function which

00:17:20,220 --> 00:17:26,510
returns a vector and you pass it to find

00:17:23,189 --> 00:17:29,070
to find that number 42 in this vector

00:17:26,510 --> 00:17:32,640
okay and fine returns an iterator right

00:17:29,070 --> 00:17:34,740
the iterator of the position but this is

00:17:32,640 --> 00:17:37,140
not an r-value container it has already

00:17:34,740 --> 00:17:43,220
been freed so now you have an invalid

00:17:37,140 --> 00:17:46,350
iterator to vector that it's not there

00:17:43,220 --> 00:17:47,430
so what a safe iterator T gives us is

00:17:46,350 --> 00:17:50,340
that

00:17:47,430 --> 00:17:53,400
in cases where the where you pass in our

00:17:50,340 --> 00:17:55,890
value container it will be an alias of a

00:17:53,400 --> 00:18:00,180
type called dangling which is naughty

00:17:55,890 --> 00:18:04,740
referenceable say you can do anything

00:18:00,180 --> 00:18:07,320
with it basically and for L value

00:18:04,740 --> 00:18:09,480
vectors there's no problem you can the

00:18:07,320 --> 00:18:12,540
reference day trader and indeed in this

00:18:09,480 --> 00:18:17,910
case the this type will be in August of

00:18:12,540 --> 00:18:24,170
the HIV okay so red rings libraries have

00:18:17,910 --> 00:18:24,170
many small safety nice things like this

00:18:26,120 --> 00:18:35,430
but algorithms if not just for each of

00:18:29,460 --> 00:18:37,740
course as Jonathan bukhara mentioned so

00:18:35,430 --> 00:18:41,040
to get to know all the algorithms I will

00:18:37,740 --> 00:18:42,480
recommend watching this is talk from

00:18:41,040 --> 00:18:44,400
last year

00:18:42,480 --> 00:18:48,000
if you're on YouTube pause now and go

00:18:44,400 --> 00:18:52,740
watch is talking then come back and

00:18:48,000 --> 00:19:00,330
Derek's close all the world of see pass

00:18:52,740 --> 00:19:04,980
pass algorithms so there are some range

00:19:00,330 --> 00:19:06,810
algorithms which have not been or not in

00:19:04,980 --> 00:19:13,320
the suppose for twenty working draft on

00:19:06,810 --> 00:19:15,780
T these are numerix okay all the hotel

00:19:13,320 --> 00:19:20,910
greetings from an American setter the

00:19:15,780 --> 00:19:24,180
parallel algorithms and the algorithms

00:19:20,910 --> 00:19:27,590
that were added after the range T s was

00:19:24,180 --> 00:19:33,950
formed the highlighted ones are

00:19:27,590 --> 00:19:38,250
implemented in range v3 all right so

00:19:33,950 --> 00:19:45,270
algorithms are pretty nice but just in

00:19:38,250 --> 00:19:50,210
the second but the feature that really

00:19:45,270 --> 00:19:54,000
attracts me in Agra in air ages is views

00:19:50,210 --> 00:19:56,910
as U is a range that has constant time

00:19:54,000 --> 00:19:58,950
copy move in assignment so basically

00:19:56,910 --> 00:20:00,540
it's a lightweight range which you can

00:19:58,950 --> 00:20:04,530
pass around by then

00:20:00,540 --> 00:20:08,030
for example arrange that hose a pair of

00:20:04,530 --> 00:20:10,890
iterators to just copy this pair

00:20:08,030 --> 00:20:16,050
arranged that holds its type its values

00:20:10,890 --> 00:20:17,730
by chef-owner and the range that

00:20:16,050 --> 00:20:20,730
generates its elements on the fly so it

00:20:17,730 --> 00:20:22,290
is not in the copy facing most

00:20:20,730 --> 00:20:25,050
containers are not views of course

00:20:22,290 --> 00:20:27,150
because vector does move its elements

00:20:25,050 --> 00:20:31,080
around when copied so it can be a

00:20:27,150 --> 00:20:33,950
constant time a viewable range is a

00:20:31,080 --> 00:20:37,440
range which you can take a view of

00:20:33,950 --> 00:20:40,290
safely so whether it's already a view or

00:20:37,440 --> 00:20:44,820
it's an l-value container again we don't

00:20:40,290 --> 00:20:49,830
want to have references to things that

00:20:44,820 --> 00:20:52,730
will soon be destroyed here is an

00:20:49,830 --> 00:20:55,380
example again from the working draft of

00:20:52,730 --> 00:20:58,740
a view called

00:20:55,380 --> 00:21:03,830
empty view like any range it has a

00:20:58,740 --> 00:21:08,280
beginning and end it is always empty

00:21:03,830 --> 00:21:11,040
it's a sized range of size zero and it's

00:21:08,280 --> 00:21:19,520
a contiguous range so it has a data

00:21:11,040 --> 00:21:22,680
member for every for almost every view

00:21:19,520 --> 00:21:29,570
there is a utility object called either

00:21:22,680 --> 00:21:29,570
a factory or an adapter which generates

00:21:30,140 --> 00:21:40,130
instances of the respective you and the

00:21:36,750 --> 00:21:47,370
those adapters sit in the use namespace

00:21:40,130 --> 00:21:51,270
and we'll see examples prism views are

00:21:47,370 --> 00:21:55,410
lazy they generate the elements on the

00:21:51,270 --> 00:21:58,200
fly as you iterate over them okay so

00:21:55,410 --> 00:22:00,450
every time you increment late an

00:21:58,200 --> 00:22:05,090
iterator to view it will generate a new

00:22:00,450 --> 00:22:08,760
value and that's why we can also have

00:22:05,090 --> 00:22:12,920
views of infinite infinitely many LEDs

00:22:08,760 --> 00:22:12,920
and we'll see examples

00:22:13,700 --> 00:22:19,470
again a quick note the code samples use

00:22:16,680 --> 00:22:22,530
this check equal to compare range and an

00:22:19,470 --> 00:22:25,500
issue as the rift and the views that are

00:22:22,530 --> 00:22:29,910
in the working drafts will be denoted by

00:22:25,500 --> 00:22:36,420
the C++ logo okay so now we don't cover

00:22:29,910 --> 00:22:38,850
all the views that are in 93 and I split

00:22:36,420 --> 00:22:41,310
them into categories so it will be more

00:22:38,850 --> 00:22:46,850
easier to there Jeff this is just my

00:22:41,310 --> 00:22:50,760
classification but I hope it's enough

00:22:46,850 --> 00:22:56,580
okay so views empty well we've already

00:22:50,760 --> 00:23:02,340
seen it it is always empty your single

00:22:56,580 --> 00:23:03,930
is a view of a single value this is

00:23:02,340 --> 00:23:06,000
actually also a container because it

00:23:03,930 --> 00:23:08,850
holds the value inside but since it's

00:23:06,000 --> 00:23:16,140
only one well value it's copy is

00:23:08,850 --> 00:23:20,040
constant time sub range reps are an

00:23:16,140 --> 00:23:23,840
iterator and sent it out in a view okay

00:23:20,040 --> 00:23:32,340
if you know things like an iterator

00:23:23,840 --> 00:23:34,410
rangy trader rules so yeah so you give

00:23:32,340 --> 00:23:41,480
it an iterator that you know and then

00:23:34,410 --> 00:23:45,090
you can view those evidence repeat

00:23:41,480 --> 00:23:48,810
lazily echoes a given value infinitely

00:23:45,090 --> 00:23:52,260
many times so this is the first example

00:23:48,810 --> 00:24:01,260
of an infinite view and repeat n does

00:23:52,260 --> 00:24:04,470
the same exactly n times unbounded takes

00:24:01,260 --> 00:24:05,970
an iterator and generate all the

00:24:04,470 --> 00:24:08,940
elements starting from this iterator

00:24:05,970 --> 00:24:13,290
infinitely and counted again that's the

00:24:08,940 --> 00:24:14,910
same for a given number of times okay

00:24:13,290 --> 00:24:17,550
this is a recurrent recurrent pattern

00:24:14,910 --> 00:24:22,930
having having an infinite view and aside

00:24:17,550 --> 00:24:28,540
view that basically do the same

00:24:22,930 --> 00:24:32,730
now the infamously named the Yoda we

00:24:28,540 --> 00:24:39,960
also have in your view given one

00:24:32,730 --> 00:24:43,000
incremental value it generates all the

00:24:39,960 --> 00:24:45,820
values by incrementing this value over

00:24:43,000 --> 00:24:48,580
and over again infinitely many times and

00:24:45,820 --> 00:24:53,100
given two values it generates the

00:24:48,580 --> 00:24:53,100
half-open range between those values

00:24:53,310 --> 00:24:58,360
there is also closed iota which

00:24:55,450 --> 00:25:03,040
generates the close range between the

00:24:58,360 --> 00:25:07,390
inputs and now I said that iota works on

00:25:03,040 --> 00:25:10,290
any incremental type if it's an integral

00:25:07,390 --> 00:25:18,070
type then you can see simply call it ins

00:25:10,290 --> 00:25:20,500
just for to clarify your me and close

00:25:18,070 --> 00:25:26,370
the aura for integral types is called

00:25:20,500 --> 00:25:30,280
closed indices and there's also indices

00:25:26,370 --> 00:25:33,310
which is all the numbers from 0 to the

00:25:30,280 --> 00:25:37,960
inputs okay so indices of 10 is the

00:25:33,310 --> 00:25:43,000
numbers from 0 to 9 and each of them is

00:25:37,960 --> 00:25:45,210
the numbers from 10 to infinity so this

00:25:43,000 --> 00:25:49,600
can be confusing and that that is why

00:25:45,210 --> 00:25:58,870
you should pass this unreachable utility

00:25:49,600 --> 00:26:02,530
when you want the infinite overload okay

00:25:58,870 --> 00:26:05,620
moving on linear distributes takes two

00:26:02,530 --> 00:26:10,320
numbers in account and distribute and

00:26:05,620 --> 00:26:13,570
values linearly between the hedges and

00:26:10,320 --> 00:26:16,330
the most general one generates takes a

00:26:13,570 --> 00:26:21,850
function another a function and cause it

00:26:16,330 --> 00:26:25,930
to generate determinants views on

00:26:21,850 --> 00:26:27,880
strings C star takes either a string

00:26:25,930 --> 00:26:29,890
literal or a constant F star and

00:26:27,880 --> 00:26:32,710
generate the different characters out of

00:26:29,890 --> 00:26:36,270
it excluding the non the null pointer

00:26:32,710 --> 00:26:36,270
the null terminator

00:26:37,540 --> 00:26:43,780
tokenize takes a string a regex and a

00:26:40,990 --> 00:26:47,820
group index and generates all the sub

00:26:43,780 --> 00:26:47,820
matches of these rejects from the string

00:26:48,840 --> 00:26:56,770
views on streams there's ice cream which

00:26:53,650 --> 00:26:58,480
takes a stream and reads values of a

00:26:56,770 --> 00:27:02,640
certain type T out of it

00:26:58,480 --> 00:27:07,440
and get lines with lines from the stream

00:27:02,640 --> 00:27:07,440
the line separator can be configured

00:27:08,850 --> 00:27:15,730
filters are filters tape arranged and

00:27:12,310 --> 00:27:20,890
lazily generate some of the elements of

00:27:15,730 --> 00:27:22,900
this range so first filter takes a

00:27:20,890 --> 00:27:27,430
predicate and generates all the elements

00:27:22,900 --> 00:27:30,850
that satisfy the predicate and remove it

00:27:27,430 --> 00:27:35,560
then generate the element that do not

00:27:30,850 --> 00:27:39,010
satisfy the product the Pritikin these

00:27:35,560 --> 00:27:43,080
views return elements from the start of

00:27:39,010 --> 00:27:46,540
the input range take and take exactly

00:27:43,080 --> 00:27:48,280
return the first n elements the

00:27:46,540 --> 00:27:52,210
difference is that take exactly is

00:27:48,280 --> 00:27:54,940
unchecked so it can be more efficient

00:27:52,210 --> 00:27:58,540
but also more dangerous in case you pass

00:27:54,940 --> 00:28:03,910
it besides that is loud larger than the

00:27:58,540 --> 00:28:06,790
whole range and take while also takes

00:28:03,910 --> 00:28:09,190
elements from the start of the range all

00:28:06,790 --> 00:28:14,850
consecutive elements that satisfy given

00:28:09,190 --> 00:28:14,850
predicate similarly you have dropped

00:28:15,000 --> 00:28:18,940
this drops elements from the start of

00:28:17,440 --> 00:28:22,440
the range so give you the elements from

00:28:18,940 --> 00:28:28,180
the end again for a number of times or

00:28:22,440 --> 00:28:29,500
for some predicate the limit takes all

00:28:28,180 --> 00:28:31,870
the elements from the start of the range

00:28:29,500 --> 00:28:35,800
until the first occurrence of some

00:28:31,870 --> 00:28:40,800
delimiter and sample generates n

00:28:35,800 --> 00:28:44,800
randomly selected elements in order life

00:28:40,800 --> 00:28:46,690
is given to offsets to the ranch and

00:28:44,800 --> 00:28:49,960
generates the half-open range between

00:28:46,690 --> 00:28:52,570
those offsets you can also use this end

00:28:49,960 --> 00:29:00,789
utility to take the offset from the end

00:28:52,570 --> 00:29:03,789
of the range stride generates everyone's

00:29:00,789 --> 00:29:11,500
element of the input sequence starting

00:29:03,789 --> 00:29:14,169
with the first unique these views work

00:29:11,500 --> 00:29:16,260
on adjacent elements unique and

00:29:14,169 --> 00:29:19,390
adjustment to remove if filters out

00:29:16,260 --> 00:29:22,990
filter out elements which which are

00:29:19,390 --> 00:29:27,309
either equal or satisfied signed binary

00:29:22,990 --> 00:29:32,010
predicate and a Justin filter keeps the

00:29:27,309 --> 00:29:35,980
element that satisfy the predicate so if

00:29:32,010 --> 00:29:39,010
in the example I pass it equal to and

00:29:35,980 --> 00:29:44,710
not equal to so these two will have the

00:29:39,010 --> 00:29:46,330
same result okay but these are opposites

00:29:44,710 --> 00:29:50,710
all right

00:29:46,330 --> 00:29:55,899
set views so set what I mean by set is

00:29:50,710 --> 00:29:57,789
any ordered sequence so you can take

00:29:55,899 --> 00:30:00,850
literally generate the Union

00:29:57,789 --> 00:30:05,970
intersection difference in symmetric

00:30:00,850 --> 00:30:05,970
difference of penny to sorted sequences

00:30:06,750 --> 00:30:15,100
now views which take a single range and

00:30:10,529 --> 00:30:18,520
generate multiple ranges out of chunk

00:30:15,100 --> 00:30:21,220
generates contiguous sub-ranges all of

00:30:18,520 --> 00:30:23,429
whom have the same size except for the

00:30:21,220 --> 00:30:23,429
left

00:30:24,940 --> 00:30:30,760
sliding produces a sliding window with

00:30:28,330 --> 00:30:37,960
steps of one of a given size over the

00:30:30,760 --> 00:30:40,690
range these guys split the inputs range

00:30:37,960 --> 00:30:42,880
had their occurrences of a given

00:30:40,690 --> 00:30:46,299
delimiter for eight elements that is

00:30:42,880 --> 00:30:50,039
fine the predicate and ruobai groups

00:30:46,299 --> 00:30:50,039
together consecutive equivalent elements

00:30:51,090 --> 00:30:56,649
now views that take multiple range and

00:30:54,610 --> 00:31:01,290
ranges and generate a single range out

00:30:56,649 --> 00:31:04,280
of them conquered concatenates the views

00:31:01,290 --> 00:31:10,410
so concatenates any number of ranges

00:31:04,280 --> 00:31:13,770
having where where their value type has

00:31:10,410 --> 00:31:16,290
some common underline type okay you can

00:31:13,770 --> 00:31:22,500
mix and match different ranges start in

00:31:16,290 --> 00:31:26,220
the same range and join takes a range of

00:31:22,500 --> 00:31:29,970
ranges and joins them together and

00:31:26,220 --> 00:31:32,160
optionally can push some value or range

00:31:29,970 --> 00:31:39,000
of values between any two consecutive

00:31:32,160 --> 00:31:42,720
odd ranges cartesian product takes n

00:31:39,000 --> 00:31:45,240
ranges and generate all n all possible

00:31:42,720 --> 00:31:47,430
and tuples where the first element of

00:31:45,240 --> 00:31:51,350
the tuple is from the first range the

00:31:47,430 --> 00:31:51,350
second from the second range etcetera

00:31:53,270 --> 00:32:00,780
and zip takes again n ranges and

00:31:57,780 --> 00:32:02,640
generates a range of tuples but this

00:32:00,780 --> 00:32:05,280
time the first tuple is the first

00:32:02,640 --> 00:32:08,690
element of all the ranges the second is

00:32:05,280 --> 00:32:13,650
the second element of other engine etc

00:32:08,690 --> 00:32:19,550
and zip with starts with the zip and

00:32:13,650 --> 00:32:23,250
then applies some given any function f

00:32:19,550 --> 00:32:31,140
to all those tuples reducing the result

00:32:23,250 --> 00:32:37,500
to a range of values transformers are

00:32:31,140 --> 00:32:41,850
views that change the elements of a

00:32:37,500 --> 00:32:47,330
given range reverse literally generates

00:32:41,850 --> 00:32:49,730
the elements in a reverse order replace

00:32:47,330 --> 00:32:52,760
replaces either a single value or

00:32:49,730 --> 00:32:58,310
elements which satisfy some condition

00:32:52,760 --> 00:32:58,310
that is replace if with another value

00:32:58,430 --> 00:33:03,960
enumerate generates a range of spares

00:33:01,200 --> 00:33:08,900
where the first element is index of the

00:33:03,960 --> 00:33:08,900
second element in the source range a

00:33:09,820 --> 00:33:15,600
recive produces a range of addresses of

00:33:12,460 --> 00:33:20,710
the elements of the original range and

00:33:15,600 --> 00:33:23,140
conversely indirect gets a range of the

00:33:20,710 --> 00:33:25,710
referenceable elements and the

00:33:23,140 --> 00:33:25,710
references

00:33:25,980 --> 00:33:31,110
it is unset so be careful with that

00:33:33,990 --> 00:33:43,750
Const underscore produces a constitute

00:33:37,660 --> 00:33:47,050
of some range and move like move

00:33:43,750 --> 00:33:48,880
iterator generates a new range of our

00:33:47,050 --> 00:33:52,240
value references to the original

00:33:48,880 --> 00:33:55,270
elements now this itself does not move

00:33:52,240 --> 00:33:59,590
them but if we press them this resulting

00:33:55,270 --> 00:34:01,920
range to copy for example it will move

00:33:59,590 --> 00:34:08,500
the elements out of the sauce range

00:34:01,920 --> 00:34:14,740
right because it caused the assignment

00:34:08,500 --> 00:34:18,520
operator within our value all right

00:34:14,740 --> 00:34:21,670
elements given a range of tuples and a

00:34:18,520 --> 00:34:25,840
constant n will generate a sequence of

00:34:21,670 --> 00:34:28,510
all the elements in the nth position so

00:34:25,840 --> 00:34:32,170
for example we have a map which is

00:34:28,510 --> 00:34:34,210
basically a range of pairs and we call

00:34:32,170 --> 00:34:37,030
element zero on it and we will give us

00:34:34,210 --> 00:34:41,500
the keys and elements one will give us

00:34:37,030 --> 00:34:44,830
the values and indeed you can use these

00:34:41,500 --> 00:34:52,480
aliases to get keys and values of a man

00:34:44,830 --> 00:34:54,180
or any range of this type and finally

00:34:52,480 --> 00:34:58,170
the most general transform

00:34:54,180 --> 00:35:03,970
gets a unary function and applies it to

00:34:58,170 --> 00:35:08,010
the element of the sauce range all right

00:35:03,970 --> 00:35:12,310
there there are views that generate

00:35:08,010 --> 00:35:16,450
ranges with more elements than they got

00:35:12,310 --> 00:35:19,740
for example interspersed pushes a value

00:35:16,450 --> 00:35:23,090
between any two consecutive elements and

00:35:19,740 --> 00:35:30,140
cycle infinitely repeats

00:35:23,090 --> 00:35:34,490
the given range there are also numeric

00:35:30,140 --> 00:35:38,660
views partial sum this is doing the same

00:35:34,490 --> 00:35:43,460
as the algorithm with the same name on

00:35:38,660 --> 00:35:46,700
it easily and that that is true also for

00:35:43,460 --> 00:35:50,000
exclusive scam remember that we don't

00:35:46,700 --> 00:35:53,150
have parallel algorithm so inclusive

00:35:50,000 --> 00:35:56,000
scan is not required because in a non

00:35:53,150 --> 00:36:00,850
parallel cases it is the same as partial

00:35:56,000 --> 00:36:00,850
sum just silent

00:36:01,180 --> 00:36:08,420
there are some utility views all

00:36:05,860 --> 00:36:11,840
generates all the elements of it the

00:36:08,420 --> 00:36:13,970
input range it is useful if you get a

00:36:11,840 --> 00:36:17,450
range and you want to make a view out of

00:36:13,970 --> 00:36:23,870
it for some reason for generic

00:36:17,450 --> 00:36:26,080
programming usually common gets a range

00:36:23,870 --> 00:36:29,510
and generates a common range out of it

00:36:26,080 --> 00:36:32,480
okay so as you recall a common range is

00:36:29,510 --> 00:36:35,510
a range where the iterator in the

00:36:32,480 --> 00:36:38,750
sentinel are the same type and this is

00:36:35,510 --> 00:36:45,920
useful for calling legacy code which

00:36:38,750 --> 00:36:49,190
expects a pair of iterators and the

00:36:45,920 --> 00:36:53,510
stood function of use any of you this is

00:36:49,190 --> 00:36:57,560
a type type to residue of some type T

00:36:53,510 --> 00:37:02,870
and some category which is basically the

00:36:57,560 --> 00:37:07,670
range concept you expect to store okay

00:37:02,870 --> 00:37:09,770
so if you declare an any view which with

00:37:07,670 --> 00:37:14,570
a category forward it will only accept

00:37:09,770 --> 00:37:17,360
forward rate forward ranges and up of

00:37:14,570 --> 00:37:23,810
course it will not accept any input

00:37:17,360 --> 00:37:27,110
range okay like most tab to rest

00:37:23,810 --> 00:37:31,570
values it is useful if you want to for

00:37:27,110 --> 00:37:31,570
example store of you in your type

00:37:33,000 --> 00:37:39,610
and finally you might have heard the

00:37:37,030 --> 00:37:43,870
term list comprehension or generators

00:37:39,610 --> 00:37:47,820
from Python and other languages now we

00:37:43,870 --> 00:37:54,370
also have it in C++ and this is

00:37:47,820 --> 00:37:56,460
surprisingly for each so what it does

00:37:54,370 --> 00:38:01,900
it's a bit complicated it takes a range

00:37:56,460 --> 00:38:04,810
and a function which returns ranges then

00:38:01,900 --> 00:38:08,020
it applied the function to each element

00:38:04,810 --> 00:38:11,640
of the sauce range to get multiple

00:38:08,020 --> 00:38:15,580
ranges and then it joins them together

00:38:11,640 --> 00:38:21,160
how is this list comprehension let's

00:38:15,580 --> 00:38:27,520
look at the example now this field there

00:38:21,160 --> 00:38:30,340
is a utility that is just there to make

00:38:27,520 --> 00:38:34,300
it look like a generator but basically

00:38:30,340 --> 00:38:39,520
all it does is return a single view okay

00:38:34,300 --> 00:38:43,270
so we have a range of 0 1 2 3 and then

00:38:39,520 --> 00:38:45,370
we cook for each number we generate a

00:38:43,270 --> 00:38:48,340
single view of the square of this number

00:38:45,370 --> 00:38:50,530
so now we have four single views of

00:38:48,340 --> 00:38:56,980
squares then we join them together and

00:38:50,530 --> 00:39:00,940
get range of the squares similarly does

00:38:56,980 --> 00:39:05,470
yield from which except range and just

00:39:00,940 --> 00:39:09,040
returns it as it again this is just a

00:39:05,470 --> 00:39:14,560
syntactic syntactic sugar so it will be

00:39:09,040 --> 00:39:18,040
clear that this is like a generator ok

00:39:14,560 --> 00:39:21,730
so for the number 0 we call indices of

00:39:18,040 --> 00:39:25,060
zero we get an empty range then we call

00:39:21,730 --> 00:39:28,630
indices of 1 we get our range with with

00:39:25,060 --> 00:39:32,830
just 0 then range with 0 and 1 and

00:39:28,630 --> 00:39:39,220
finally 0 1 and 2 and we join them to do

00:39:32,830 --> 00:39:43,390
them there are also yield if and lazy

00:39:39,220 --> 00:39:44,620
leaf which conditionally generate an

00:39:43,390 --> 00:39:47,320
output

00:39:44,620 --> 00:39:52,600
but I want going to the more detail

00:39:47,320 --> 00:39:58,570
today alright we've covered all the

00:39:52,600 --> 00:40:03,220
views of rent v3 so as promised you

00:39:58,570 --> 00:40:05,650
would like to compose them together here

00:40:03,220 --> 00:40:11,020
is some code using classic STL

00:40:05,650 --> 00:40:14,200
algorithms to computing sum the sum of

00:40:11,020 --> 00:40:18,430
all the squares of the numbers from 1 to

00:40:14,200 --> 00:40:21,880
count inclusively so we create a vector

00:40:18,430 --> 00:40:25,330
we fill it with iota with the numbers

00:40:21,880 --> 00:40:26,950
want to count we call transform to get

00:40:25,330 --> 00:40:30,360
the squares and then pass it to

00:40:26,950 --> 00:40:35,440
accumulate to get the sum of the squares

00:40:30,360 --> 00:40:39,910
and he will Harris ah we will do it with

00:40:35,440 --> 00:40:45,370
view so first we need to read it inside

00:40:39,910 --> 00:40:48,040
out we call a Ora 1 coma count again to

00:40:45,370 --> 00:40:52,390
get the number run took the numbers want

00:40:48,040 --> 00:40:54,700
to count then we transform it to be the

00:40:52,390 --> 00:41:00,520
square and the result we pass to

00:40:54,700 --> 00:41:05,170
accumulate so this is much shorter than

00:41:00,520 --> 00:41:08,260
the previous example but it's a little

00:41:05,170 --> 00:41:11,050
bit inconvenient to read ok we need to

00:41:08,260 --> 00:41:15,100
read inside out and maybe here it's easy

00:41:11,050 --> 00:41:21,340
but for complex calculations it may be

00:41:15,100 --> 00:41:27,430
it can be much harder so what we have

00:41:21,340 --> 00:41:29,980
for this is the pipe operator the pipe

00:41:27,430 --> 00:41:34,600
operator enables us to pass a range

00:41:29,980 --> 00:41:38,620
between the view so now we can call it

00:41:34,600 --> 00:41:41,800
from we can really it sorry from left to

00:41:38,620 --> 00:41:46,450
right is usual because I era we pass the

00:41:41,800 --> 00:41:51,600
result to transform and then test the

00:41:46,450 --> 00:41:54,160
result of that to accumulate note that

00:41:51,600 --> 00:41:56,250
because the laziness of use no work is

00:41:54,160 --> 00:41:58,450
done until you call you call accumulate

00:41:56,250 --> 00:42:01,720
generating the

00:41:58,450 --> 00:42:05,680
via the generative squares which is

00:42:01,720 --> 00:42:09,280
itself of you will not actually do any

00:42:05,680 --> 00:42:13,599
work only when accumulate will iterate

00:42:09,280 --> 00:42:18,210
over it will it generate the results on

00:42:13,599 --> 00:42:21,970
the flag all right so we composed views

00:42:18,210 --> 00:42:24,490
now there are cases that after doing

00:42:21,970 --> 00:42:29,589
such a pipeline you would like to save

00:42:24,490 --> 00:42:35,799
the result in some container and you can

00:42:29,589 --> 00:42:41,440
use this to utility for that okay so

00:42:35,799 --> 00:42:44,970
it's in the rageous namespace and this

00:42:41,440 --> 00:42:48,450
one will generate a vector of hints of

00:42:44,970 --> 00:42:51,730
what i have calculated here

00:42:48,450 --> 00:42:53,440
note that the element type of the vector

00:42:51,730 --> 00:43:02,260
is inferred you know you don't need to

00:42:53,440 --> 00:43:08,140
to specify it okay so we've covered

00:43:02,260 --> 00:43:11,079
views now for a feature which is not in

00:43:08,140 --> 00:43:13,619
the working draft at all okay as some of

00:43:11,079 --> 00:43:21,569
the views are in the working draft but

00:43:13,619 --> 00:43:25,089
actions have not been proposed yet so

00:43:21,569 --> 00:43:29,020
one or actions so we have algorithms

00:43:25,089 --> 00:43:33,720
which are eager but don't compose okay

00:43:29,020 --> 00:43:33,720
we can we can't use the pipe operator

00:43:34,020 --> 00:43:39,670
for with algorithms only with views so

00:43:36,849 --> 00:43:43,930
far and we have used which are lazy and

00:43:39,670 --> 00:43:47,549
compose so we would like to get the best

00:43:43,930 --> 00:43:51,270
of both worlds it's the best but to get

00:43:47,549 --> 00:43:54,940
bigger and composable algorithms and

00:43:51,270 --> 00:43:57,240
this is exactly what action actions

00:43:54,940 --> 00:43:57,240
business

00:43:57,270 --> 00:44:03,190
so what actions do we have we have

00:44:00,160 --> 00:44:06,819
pushed back for adding elements to the

00:44:03,190 --> 00:44:08,319
end of the range we can add elements to

00:44:06,819 --> 00:44:10,890
the beginning of the range which push up

00:44:08,319 --> 00:44:10,890
push front

00:44:12,450 --> 00:44:21,900
we can insert elements to the middle of

00:44:15,610 --> 00:44:21,900
the range and erased elements out of it

00:44:24,480 --> 00:44:38,380
we can also sort the range stable or not

00:44:32,080 --> 00:44:43,150
and shuffle a deck and there are more

00:44:38,380 --> 00:44:47,380
actions these actions do the same as the

00:44:43,150 --> 00:44:54,850
views with the same name so I want to go

00:44:47,380 --> 00:44:57,940
over them one by one and as we said we

00:44:54,850 --> 00:45:01,110
can compose actions so here we have a

00:44:57,940 --> 00:45:04,030
function to read some data into a vector

00:45:01,110 --> 00:45:15,870
then we sort it and remove the

00:45:04,030 --> 00:45:22,210
duplicates what basically one liner now

00:45:15,870 --> 00:45:26,050
actions modify their input and pipelines

00:45:22,210 --> 00:45:27,970
work only on our value containers so if

00:45:26,050 --> 00:45:30,820
you have an L value you need to call

00:45:27,970 --> 00:45:33,670
copy and move before starting the

00:45:30,820 --> 00:45:36,100
pipeline so you can copy the vector into

00:45:33,670 --> 00:45:38,430
the pipeline or move it there if you

00:45:36,100 --> 00:45:41,460
don't need anymore

00:45:38,430 --> 00:45:46,120
okay this is a good thing it makes you

00:45:41,460 --> 00:45:50,920
explicit about your intent and the

00:45:46,120 --> 00:45:54,100
second case of moving the iterator if

00:45:50,920 --> 00:45:56,640
you want to write it back to the source

00:45:54,100 --> 00:46:00,930
interior you can use this pipe equal

00:45:56,640 --> 00:46:00,930
operator the shorter

00:46:03,200 --> 00:46:24,950
okay some projections I'm only taking

00:46:22,640 --> 00:46:30,530
sips for you to take a look at the

00:46:24,950 --> 00:46:32,420
picture so I don't know if anyone

00:46:30,530 --> 00:46:34,819
noticed but her again here is the

00:46:32,420 --> 00:46:39,109
Declaration of Farid from the working

00:46:34,819 --> 00:46:42,880
draft of C++ 20 and what what I

00:46:39,109 --> 00:46:47,809
highlighted here is an additional

00:46:42,880 --> 00:46:54,010
argument that for each state which is

00:46:47,809 --> 00:46:57,589
called the projection why is it useful

00:46:54,010 --> 00:47:00,170
here is a classic struct employee with

00:46:57,589 --> 00:47:04,400
first and last names and let's say we

00:47:00,170 --> 00:47:06,609
have a vector of these employees and we

00:47:04,400 --> 00:47:10,670
want to solve the vector by left named

00:47:06,609 --> 00:47:12,220
so because to the sort this is still a

00:47:10,670 --> 00:47:15,470
classic

00:47:12,220 --> 00:47:20,119
yeah we pass beginning and end and then

00:47:15,470 --> 00:47:25,099
we need custom comparator to compare the

00:47:20,119 --> 00:47:28,309
last names then we have a solid vector

00:47:25,099 --> 00:47:33,470
and we want to search it with lower

00:47:28,309 --> 00:47:36,230
bound which does a binary search so we

00:47:33,470 --> 00:47:37,940
want to find nibbler we want to find the

00:47:36,230 --> 00:47:38,480
employee with the left named nipple

00:47:37,940 --> 00:47:42,470
nibblers

00:47:38,480 --> 00:47:44,990
in the list of employees and again we

00:47:42,470 --> 00:47:46,910
only want to compare by last name so we

00:47:44,990 --> 00:47:51,950
need to find yet another we need to

00:47:46,910 --> 00:47:56,720
define it another custom comparator okay

00:47:51,950 --> 00:48:00,589
so we have to you pretty similar use

00:47:56,720 --> 00:48:06,079
cases to compare by less names but we

00:48:00,589 --> 00:48:09,589
need to write them twice and this is

00:48:06,079 --> 00:48:14,230
basically code duplication which can get

00:48:09,589 --> 00:48:16,790
out of think and cause hard to find that

00:48:14,230 --> 00:48:22,810
so we would like to avoid that

00:48:16,790 --> 00:48:25,400
and projections give us exactly that so

00:48:22,810 --> 00:48:29,420
coming back to the implementation of

00:48:25,400 --> 00:48:34,100
reach what for it does with the

00:48:29,420 --> 00:48:37,010
projection is invoke it on the element

00:48:34,100 --> 00:48:41,810
of the sequence and then pass the result

00:48:37,010 --> 00:48:47,660
too far to the function so the function

00:48:41,810 --> 00:48:49,190
will always see the projected value now

00:48:47,660 --> 00:48:53,090
by default the projection is after

00:48:49,190 --> 00:48:56,960
identity so it will have no effect but

00:48:53,090 --> 00:49:00,830
in our case we can define a projection

00:48:56,960 --> 00:49:02,630
called get lift name which given an

00:49:00,830 --> 00:49:07,810
employee returns it's in its last name

00:49:02,630 --> 00:49:14,260
and then pass the same projection to the

00:49:07,810 --> 00:49:18,080
two algorithms okay these two algorithms

00:49:14,260 --> 00:49:20,720
will apply this function and will only

00:49:18,080 --> 00:49:24,820
work on the last name so sort will sort

00:49:20,720 --> 00:49:27,950
by last name and also the search and

00:49:24,820 --> 00:49:35,000
then we can use the default comparator

00:49:27,950 --> 00:49:37,550
which is less notice that although sort

00:49:35,000 --> 00:49:40,630
will sort by last names it will still

00:49:37,550 --> 00:49:44,360
move employees around and not strings

00:49:40,630 --> 00:49:48,520
okay so it's up to the implementation of

00:49:44,360 --> 00:49:51,560
the algorithm to do the right thing but

00:49:48,520 --> 00:49:54,080
this is what it does and also the

00:49:51,560 --> 00:50:03,890
rebound with return us are an iterator

00:49:54,080 --> 00:50:07,790
to an employee and not just in this case

00:50:03,890 --> 00:50:11,110
since we call student VOC to apply the

00:50:07,790 --> 00:50:16,670
projection student book has a nice

00:50:11,110 --> 00:50:20,510
property that it can also treat pointer

00:50:16,670 --> 00:50:23,300
to members as callable and in this case

00:50:20,510 --> 00:50:24,200
since we only compare by a member of

00:50:23,300 --> 00:50:27,620
first struct

00:50:24,200 --> 00:50:28,910
who can simply pass a pointer to the

00:50:27,620 --> 00:50:30,890
last name

00:50:28,910 --> 00:50:34,099
and we don't need to define a separate

00:50:30,890 --> 00:50:36,349
lambda and also we can omit this list

00:50:34,099 --> 00:50:48,079
because this is the default so we just

00:50:36,349 --> 00:50:56,809
need an empty brace all right so we saw

00:50:48,079 --> 00:51:00,460
a couple of useful and nice tools and

00:50:56,809 --> 00:51:02,900
you might wonder does it perform

00:51:00,460 --> 00:51:06,519
ok we're superstars programmers we care

00:51:02,900 --> 00:51:10,160
about performance maybe all these

00:51:06,519 --> 00:51:16,069
obstruction layers will hurt our

00:51:10,160 --> 00:51:21,859
performance so coming back to this sum

00:51:16,069 --> 00:51:27,440
of square examples I wrote a benchmark

00:51:21,859 --> 00:51:31,789
comparing this code with the function

00:51:27,440 --> 00:51:36,190
call syntax over F of use and with the

00:51:31,789 --> 00:51:42,589
pipes in text and also the same code

00:51:36,190 --> 00:51:45,710
with a simple for loop and this these

00:51:42,589 --> 00:51:50,269
are the results so the classic FTL

00:51:45,710 --> 00:51:56,390
algorithm is pretty bad and all the rest

00:51:50,269 --> 00:52:00,769
are basically the same so register you

00:51:56,390 --> 00:52:07,339
can be optimized by the compiler the

00:52:00,769 --> 00:52:09,380
same as a simple fall of care so this is

00:52:07,339 --> 00:52:14,140
just a single benchmark on a single

00:52:09,380 --> 00:52:14,140
machine but I do think it shows that

00:52:14,380 --> 00:52:25,460
useful code which is also safe and

00:52:18,859 --> 00:52:28,579
elegant which is why which is what the

00:52:25,460 --> 00:52:33,170
ranges libraries give us can also be

00:52:28,579 --> 00:52:34,510
performing home and with this I'd like

00:52:33,170 --> 00:52:38,439
to thank you

00:52:34,510 --> 00:52:38,439
[Applause]

00:52:40,420 --> 00:52:54,830
any question what do you count account

00:52:53,119 --> 00:52:57,349
for in that performance difference at

00:52:54,830 --> 00:52:59,800
the end no this is because in the

00:52:57,349 --> 00:53:06,470
classic STL I used the vector which does

00:52:59,800 --> 00:53:08,240
home but it's what the mic tips so the

00:53:06,470 --> 00:53:14,480
question why is the difference between

00:53:08,240 --> 00:53:20,030
the in the benchmarking is because only

00:53:14,480 --> 00:53:24,109
the STL version allocated memory for the

00:53:20,030 --> 00:53:25,839
vector but I didn't see any other way to

00:53:24,109 --> 00:53:31,280
work with the standard algorithm hunter

00:53:25,839 --> 00:53:34,420
without allocating this vector do you

00:53:31,280 --> 00:53:40,540
mind coming back to the slide on samples

00:53:34,420 --> 00:53:40,540
we'd like our sample few simple

00:53:47,940 --> 00:53:57,660
where are those dices sorry relatively

00:53:52,200 --> 00:53:59,880
page oh all right okay I thought there

00:53:57,660 --> 00:54:06,180
was a sample and so I just missed it

00:53:59,880 --> 00:54:09,839
thank you yeah all right I have two

00:54:06,180 --> 00:54:13,260
questions first is there a benefit to

00:54:09,839 --> 00:54:14,039
using projections over just transforming

00:54:13,260 --> 00:54:17,670
it first

00:54:14,039 --> 00:54:20,339
yes so the question was if there are

00:54:17,670 --> 00:54:22,980
benefit to used projections instead of

00:54:20,339 --> 00:54:25,079
transformation transforming the region

00:54:22,980 --> 00:54:28,170
the answer is that if you would

00:54:25,079 --> 00:54:33,180
transform it to a range of strings and

00:54:28,170 --> 00:54:36,599
you saw the debt then the original range

00:54:33,180 --> 00:54:42,839
of employees would not be sorry it will

00:54:36,599 --> 00:54:46,020
only be sought was formed okay and for

00:54:42,839 --> 00:54:47,849
generate where that's where it just

00:54:46,020 --> 00:54:51,900
calls a function over and over again and

00:54:47,849 --> 00:54:53,309
creates a yeah is there some way to tell

00:54:51,900 --> 00:54:56,250
it to stop to like make the function

00:54:53,309 --> 00:55:13,020
return something saying to stop or does

00:54:56,250 --> 00:55:16,079
it just yeah so so no and what you

00:55:13,020 --> 00:55:18,690
should do basically is to use your

00:55:16,079 --> 00:55:25,980
condition for stopping to filter the

00:55:18,690 --> 00:55:28,440
range beforehand so you can yeah this is

00:55:25,980 --> 00:55:32,210
basically what I offer so first you stay

00:55:28,440 --> 00:55:35,099
quiet there or whatever to filter the

00:55:32,210 --> 00:55:38,160
range to only the values you want to

00:55:35,099 --> 00:55:44,190
work on and then you can apply generate

00:55:38,160 --> 00:55:46,770
to all of them thank you so it's the

00:55:44,190 --> 00:55:49,950
lifetime of the views tied to the actual

00:55:46,770 --> 00:55:52,740
range yes there's a reference types and

00:55:49,950 --> 00:55:55,740
package where so do you see like

00:55:52,740 --> 00:56:00,900
problems occurring because let's say the

00:55:55,740 --> 00:56:01,980
range goes out of scope but yes so so be

00:56:00,900 --> 00:56:07,200
be careful

00:56:01,980 --> 00:56:12,420
you store views like like any reference

00:56:07,200 --> 00:56:15,599
type mostly used them for calculating

00:56:12,420 --> 00:56:18,290
some stuff and then take the result and

00:56:15,599 --> 00:56:23,040
push that to some vector or something

00:56:18,290 --> 00:56:25,140
okay thanks all right so I work in a low

00:56:23,040 --> 00:56:26,609
latency space I was wondering if any of

00:56:25,140 --> 00:56:31,369
the views have any guarantees where

00:56:26,609 --> 00:56:36,329
where no dynamic allocation happens I

00:56:31,369 --> 00:56:40,160
don't know the question is whether views

00:56:36,329 --> 00:56:40,160
have guaranteed to not allocate memory

00:56:46,670 --> 00:56:53,700
yeah they might have a local statement

00:56:50,700 --> 00:56:57,109
member but I don't think any one of them

00:56:53,700 --> 00:56:57,109
okay thank you

00:56:58,320 --> 00:57:04,980
is it possible to paralyze the the

00:57:01,710 --> 00:57:08,160
creation of a view so does it only runs

00:57:04,980 --> 00:57:10,380
occasionally yes so this is basically I

00:57:08,160 --> 00:57:12,839
believe what Derek nibbler is

00:57:10,380 --> 00:57:18,450
researching now how to do this in

00:57:12,839 --> 00:57:19,710
parallel so this is still an open right

00:57:18,450 --> 00:57:24,229
thank you again

00:57:19,710 --> 00:57:24,229

YouTube URL: https://www.youtube.com/watch?v=qQtS50ZChN8


