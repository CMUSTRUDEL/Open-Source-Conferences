Title: CppCon 2019: Olivier Giroux “The One-Decade Task: Putting std::atomic in CUDA.”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Some tasks are projected to take a long time to complete, and many take more time than planned. We didn't plan for it at the onset, but putting std::atomic into CUDA will have taken almost 10 years when it's all over. Many exceptional engineers contributed, everyone learned a lot, I would do it again 100%.

In this talk I will share 10 stories from the trenches in the 10-year arc of this "one task", each with a concise lesson I learned and/or a word about people that made a big difference. You will get a glimpse of what it's like to work on a hardware team, take a quick dive into a seminal computer science thesis, learn the basics of a computer modeling language called Alloy, get a tour of the libcxx ＜atomic＞ header... and more! 
— 
Olivier Giroux
NVIDIA
Distinguished Engineer

Olivier Giroux has worked on nine GPU and five SM architecture generations released by NVIDIA. Most recently, he's been working to clarify the forms and semantics of valid GPU programs, present and future. He was the programming model lead for the NVIDIA Volta architecture. He is the chair of SG1, the concurrency and parallelism study group of the ISO C++ committee.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,490 --> 00:00:19,029
good afternoon welcome this talk is the

00:00:14,260 --> 00:00:23,070
story of the incredible heavy lift that

00:00:19,029 --> 00:00:26,410
it took to put standard atomic into CUDA

00:00:23,070 --> 00:00:28,000
it didn't take a decade because we

00:00:26,410 --> 00:00:29,800
stopped to smell the roses it took a

00:00:28,000 --> 00:00:32,169
decade because there was an incredibly

00:00:29,800 --> 00:00:34,149
long dependent chain of things that had

00:00:32,169 --> 00:00:38,980
to go just right in order for it to

00:00:34,149 --> 00:00:40,840
happen my name is una voz Lu I'm a GPU

00:00:38,980 --> 00:00:44,260
architect have been for quite some time

00:00:40,840 --> 00:00:47,860
and I am also your chair of concurrency

00:00:44,260 --> 00:00:51,010
and parallelism and in this talk I have

00:00:47,860 --> 00:00:55,060
the opportunity to really join together

00:00:51,010 --> 00:00:58,180
my my two jobs I get to talk the whole

00:00:55,060 --> 00:00:59,890
time about both at the same time instead

00:00:58,180 --> 00:01:01,720
of having a portion of my talk that's

00:00:59,890 --> 00:01:03,940
about GPUs and a portion of my talk

00:01:01,720 --> 00:01:07,470
that's about concurrency and parallelism

00:01:03,940 --> 00:01:10,119
in C++ the whole talk is only about this

00:01:07,470 --> 00:01:13,360
all right so I'm a member of a couple of

00:01:10,119 --> 00:01:16,210
communities first and foremost I'm an

00:01:13,360 --> 00:01:19,450
Nvidia engineer I've been an engineer at

00:01:16,210 --> 00:01:22,030
Nvidia for 17 years I've been in the

00:01:19,450 --> 00:01:24,610
architecture team the entire time I have

00:01:22,030 --> 00:01:27,549
been working on the SM for the last 10

00:01:24,610 --> 00:01:30,909
years so that means you know Kepler

00:01:27,549 --> 00:01:36,549
Maxwell Pascal Volta Turing next next

00:01:30,909 --> 00:01:42,490
next next next next and so on I've been

00:01:36,549 --> 00:01:44,710
a C++ user since 1997 or so I'm a member

00:01:42,490 --> 00:01:46,900
of dub G 21 I'm the chair of concurrency

00:01:44,710 --> 00:01:48,549
and parallelism and I'm also a member of

00:01:46,900 --> 00:01:52,780
this memory model community which is a

00:01:48,549 --> 00:01:56,380
relatively small group of less than a

00:01:52,780 --> 00:01:58,780
hundred experts who go around and fix up

00:01:56,380 --> 00:02:00,939
memory models all over the place all

00:01:58,780 --> 00:02:04,780
right all right so here's the context of

00:02:00,939 --> 00:02:11,409
our story our story you know 1993 and

00:02:04,780 --> 00:02:14,920
Vidia is 2007 and video ships cuda CUDA

00:02:11,409 --> 00:02:18,790
C++ you know CUDA from the first is a

00:02:14,920 --> 00:02:21,040
C++ product CUDA C++ is a C++ product

00:02:18,790 --> 00:02:21,610
much in the same way that Visual C++ is

00:02:21,040 --> 00:02:24,180
a c-plus

00:02:21,610 --> 00:02:28,320
product it's got a bunch of extensions

00:02:24,180 --> 00:02:31,740
but it's it's a base lingua franca is

00:02:28,320 --> 00:02:33,510
the cheapest bus that we know and love

00:02:31,740 --> 00:02:40,300
all right

00:02:33,510 --> 00:02:42,400
2011 C++ gains still atomic CUDA C++

00:02:40,300 --> 00:02:46,030
does not gain still atomic at the same

00:02:42,400 --> 00:02:53,470
time student on make arrives in CUDA in

00:02:46,030 --> 00:02:59,280
the 2019 2020 timeframe and this span of

00:02:53,470 --> 00:03:05,440
time is the subject of this talk alright

00:02:59,280 --> 00:03:07,860
let's start in 2011 and sort of my tiny

00:03:05,440 --> 00:03:10,510
little bit of advice the plug here is

00:03:07,860 --> 00:03:13,090
when I think about 2011 I think the

00:03:10,510 --> 00:03:15,160
thing that mattered was having side

00:03:13,090 --> 00:03:19,450
projects you know I had all my main

00:03:15,160 --> 00:03:22,420
things and and then people also had side

00:03:19,450 --> 00:03:26,350
projects alright so the story starts

00:03:22,420 --> 00:03:28,870
very small different side projects that

00:03:26,350 --> 00:03:32,500
a number of people participate in well

00:03:28,870 --> 00:03:35,940
one side project is some clarifications

00:03:32,500 --> 00:03:40,030
on the memory model our memory model was

00:03:35,940 --> 00:03:42,670
added to concise and it was bit vague at

00:03:40,030 --> 00:03:44,680
that time and so you know we start

00:03:42,670 --> 00:03:46,600
circulating oh what if you know we

00:03:44,680 --> 00:03:48,310
clarified this atomicity thing but if we

00:03:46,600 --> 00:03:50,950
clarified what it means to synchronize

00:03:48,310 --> 00:03:55,560
using fences and whatnot okay so we do

00:03:50,950 --> 00:03:59,530
some of that and what's there to clarify

00:03:55,560 --> 00:04:03,100
so on the left is an excerpt from the

00:03:59,530 --> 00:04:04,690
sparc v9 manuals and to first order

00:04:03,100 --> 00:04:07,750
their entire memory model is in that

00:04:04,690 --> 00:04:10,930
excerpt the furni programming guide

00:04:07,750 --> 00:04:12,970
which this you know this is not the

00:04:10,930 --> 00:04:15,130
program I'm not this quote there is not

00:04:12,970 --> 00:04:16,859
what we put on the web this is this is

00:04:15,130 --> 00:04:18,070
what we have this is how much we have

00:04:16,859 --> 00:04:21,880
all right

00:04:18,070 --> 00:04:25,930
it says the rules refer me are based on

00:04:21,880 --> 00:04:29,110
son our mo as specified in appendix D of

00:04:25,930 --> 00:04:31,280
the SPARC architecture manual okay

00:04:29,110 --> 00:04:34,580
you mean there's differences okay but

00:04:31,280 --> 00:04:36,650
they differ how and and there are things

00:04:34,580 --> 00:04:38,780
in that text that are kind of implied

00:04:36,650 --> 00:04:41,000
okay so we're not gonna go into great

00:04:38,780 --> 00:04:43,310
detail but I'll just gives you a quick a

00:04:41,000 --> 00:04:47,900
quick overview of how to read this okay

00:04:43,310 --> 00:04:49,610
so this reads an operation X that's in

00:04:47,900 --> 00:04:53,060
dependency order before an operation Y

00:04:49,610 --> 00:04:56,300
and X is a load means that X is

00:04:53,060 --> 00:04:58,550
performed in memory before Y this little

00:04:56,300 --> 00:05:00,710
bit of algebra means this when you and

00:04:58,550 --> 00:05:02,270
unpack it well one of the things that I

00:05:00,710 --> 00:05:04,370
wonder when I look at something like

00:05:02,270 --> 00:05:07,280
this I mean I wondered this a lot more

00:05:04,370 --> 00:05:08,720
now than I did in 2011 but something

00:05:07,280 --> 00:05:10,789
that I wonder when I see something like

00:05:08,720 --> 00:05:15,139
this is uh this thing at the bottom

00:05:10,789 --> 00:05:16,039
there do you mean what M is a partial

00:05:15,139 --> 00:05:18,110
order or tall order

00:05:16,039 --> 00:05:21,319
we didn't even know to ask this question

00:05:18,110 --> 00:05:23,300
at the time and our programming model

00:05:21,319 --> 00:05:26,780
didn't say anything about that okay so

00:05:23,300 --> 00:05:30,680
we had a lot to clarify some other side

00:05:26,780 --> 00:05:32,210
projects we around that time we had some

00:05:30,680 --> 00:05:33,680
forward progress stuff running on on

00:05:32,210 --> 00:05:35,419
gate simulation it would take a long

00:05:33,680 --> 00:05:38,020
time before something like that would

00:05:35,419 --> 00:05:40,250
ever ship but it was a side project

00:05:38,020 --> 00:05:43,190
another side project was attending the

00:05:40,250 --> 00:05:47,240
C++ committee meetings that's that's

00:05:43,190 --> 00:05:48,800
when Nvidia joined the C++ Committee all

00:05:47,240 --> 00:05:51,740
right well all of these side projects

00:05:48,800 --> 00:05:53,599
they're encouraged and I want to say

00:05:51,740 --> 00:06:00,490
that they're encouraged from all the way

00:05:53,599 --> 00:06:03,650
up but if people were skeptical that

00:06:00,490 --> 00:06:05,120
work on formal things would fix problems

00:06:03,650 --> 00:06:08,630
you know and videos a hardware company

00:06:05,120 --> 00:06:11,930
there's very pragmatic people there and

00:06:08,630 --> 00:06:14,210
so you know things that are about the

00:06:11,930 --> 00:06:16,580
workings of the machinery are obviously

00:06:14,210 --> 00:06:20,150
valuable to work on and then things that

00:06:16,580 --> 00:06:26,650
are more theoretical more academic or

00:06:20,150 --> 00:06:28,880
not immediately seen as valuable 2012

00:06:26,650 --> 00:06:34,370
2012 is the year that we learned that

00:06:28,880 --> 00:06:37,060
formalism can fix some problems here is

00:06:34,370 --> 00:06:39,409
a very simple very simplified story

00:06:37,060 --> 00:06:41,570
you're all going to wish that I told you

00:06:39,409 --> 00:06:42,140
a lot more about it I'm not gonna tell

00:06:41,570 --> 00:06:45,500
you more about

00:06:42,140 --> 00:06:48,110
all right here's a simplified story one

00:06:45,500 --> 00:06:53,420
day we have memory ordering issues that

00:06:48,110 --> 00:06:56,630
are appalling it's a legendary bonfire

00:06:53,420 --> 00:06:59,690
and it's an epic firefighting effort

00:06:56,630 --> 00:07:01,910
within the company there are people that

00:06:59,690 --> 00:07:03,440
worked on this and they're still known

00:07:01,910 --> 00:07:11,570
within the company for having worked on

00:07:03,440 --> 00:07:18,620
this an all's well that ends well all

00:07:11,570 --> 00:07:21,020
right so now huzzah

00:07:18,620 --> 00:07:23,360
the site project seems like it's part of

00:07:21,020 --> 00:07:24,740
a solution good we need to understand we

00:07:23,360 --> 00:07:31,880
need to be on top of this memory order

00:07:24,740 --> 00:07:37,180
thing so so we started with this and we

00:07:31,880 --> 00:07:40,760
had a sustained series of negotiations

00:07:37,180 --> 00:07:45,320
drafting sessions reviews and sign offs

00:07:40,760 --> 00:07:47,270
and we ended with something like this we

00:07:45,320 --> 00:07:49,880
had a little bit more to say it turns

00:07:47,270 --> 00:07:54,410
out our memory model is quite a bit more

00:07:49,880 --> 00:07:57,770
complex you know son our mo was designed

00:07:54,410 --> 00:08:00,920
for cache coherence CPUs and we don't

00:07:57,770 --> 00:08:03,350
have coherent l1 caches so there's quite

00:08:00,920 --> 00:08:06,410
a lot we need to say about what are all

00:08:03,350 --> 00:08:08,210
the steps you need to take to make

00:08:06,410 --> 00:08:10,520
memory operations visible from one

00:08:08,210 --> 00:08:11,810
thread to another thread and we've got

00:08:10,520 --> 00:08:14,630
some other complications like we have

00:08:11,810 --> 00:08:16,640
the notion of scopes our fences don't

00:08:14,630 --> 00:08:18,410
reach infinitely far there we you have

00:08:16,640 --> 00:08:20,300
different fences if you're going to

00:08:18,410 --> 00:08:22,820
communicate to a thread nearby to you or

00:08:20,300 --> 00:08:25,010
a thread far from you okay so that all

00:08:22,820 --> 00:08:28,550
has to go into the model now I'm gonna

00:08:25,010 --> 00:08:30,650
give you a tour this is the mob are

00:08:28,550 --> 00:08:35,450
literally screen caps of the actual huh

00:08:30,650 --> 00:08:37,190
okay so this part describes something

00:08:35,450 --> 00:08:40,130
that's like happens before and if you're

00:08:37,190 --> 00:08:41,960
familiar with C++ you know using Atomics

00:08:40,130 --> 00:08:43,970
and C++ you would read this part you

00:08:41,960 --> 00:08:47,180
would say oh you know that wasn't so bad

00:08:43,970 --> 00:08:49,850
that part here though is a little bit

00:08:47,180 --> 00:08:51,980
embarrassing once you had established

00:08:49,850 --> 00:08:53,510
the equivalent of happens before you

00:08:51,980 --> 00:08:55,000
still didn't necessarily see the data

00:08:53,510 --> 00:08:56,410
you might still get

00:08:55,000 --> 00:08:59,139
in consistent data so there was this

00:08:56,410 --> 00:09:01,990
second set of rules that you had to

00:08:59,139 --> 00:09:04,420
reason about entirely in parallel with

00:09:01,990 --> 00:09:06,730
the main set of rules and if both rules

00:09:04,420 --> 00:09:11,079
are greed then you would have

00:09:06,730 --> 00:09:13,540
communicated that's that's you know I

00:09:11,079 --> 00:09:17,350
think it's a little bit of hostile for

00:09:13,540 --> 00:09:19,180
users so I did you know I we were not

00:09:17,350 --> 00:09:21,430
all fans of this part and then this

00:09:19,180 --> 00:09:23,680
entire part in the back there is really

00:09:21,430 --> 00:09:25,509
just documenting exceptions to the rules

00:09:23,680 --> 00:09:27,850
they're not telling you how the

00:09:25,509 --> 00:09:31,480
exceptions work it is merely an

00:09:27,850 --> 00:09:34,180
enumeration of all the exceptions okay

00:09:31,480 --> 00:09:37,600
so that was the memory model at that

00:09:34,180 --> 00:09:42,579
time I want to talk about a thing that

00:09:37,600 --> 00:09:45,490
we got I think particularly well and it

00:09:42,579 --> 00:09:47,500
has to do with these three concepts

00:09:45,490 --> 00:09:48,910
transitivity cumulative 'ti and

00:09:47,500 --> 00:09:54,629
composability all right so transitivity

00:09:48,910 --> 00:09:58,540
is what you would remember from school

00:09:54,629 --> 00:10:02,079
you know a a rule that keeps following

00:09:58,540 --> 00:10:04,240
along multiple concatenated relations

00:10:02,079 --> 00:10:06,339
right cumulative it E is a term that the

00:10:04,240 --> 00:10:08,139
memory model people created to talk

00:10:06,339 --> 00:10:11,860
about fences having a cumulative effect

00:10:08,139 --> 00:10:13,240
where if I fence my memory then I

00:10:11,860 --> 00:10:16,139
synchronize with someone else and that

00:10:13,240 --> 00:10:19,180
someone else does offense their fence

00:10:16,139 --> 00:10:22,029
borders memory operations cumulatively

00:10:19,180 --> 00:10:26,649
with the first fence okay so the fences

00:10:22,029 --> 00:10:28,360
sort of add up and composability is

00:10:26,649 --> 00:10:31,569
exactly what what you would think that

00:10:28,360 --> 00:10:33,490
is if your right piece of code with two

00:10:31,569 --> 00:10:36,040
functions and each function is correct

00:10:33,490 --> 00:10:38,649
and then you use both functions in your

00:10:36,040 --> 00:10:43,420
program your program should be correct

00:10:38,649 --> 00:10:44,920
ideally all right so so here is

00:10:43,420 --> 00:10:46,449
something we call a litmus test we're

00:10:44,920 --> 00:10:48,579
going to talk about this more in a few

00:10:46,449 --> 00:10:50,050
minutes but this litmus test is exactly

00:10:48,579 --> 00:10:52,990
what I described we have an initial

00:10:50,050 --> 00:10:55,149
thread it writes to X then it writes to

00:10:52,990 --> 00:10:58,059
Y where Y would be a flag in this case a

00:10:55,149 --> 00:11:02,319
second thread observes this first flag

00:10:58,059 --> 00:11:04,870
and then writes to a second flag then a

00:11:02,319 --> 00:11:06,910
third thread sees the second flag and

00:11:04,870 --> 00:11:09,120
attempts to read the initial piece of

00:11:06,910 --> 00:11:09,120
data

00:11:10,050 --> 00:11:16,180
obviously not all computers order this

00:11:12,910 --> 00:11:17,320
memory with no fences in it our computer

00:11:16,180 --> 00:11:19,300
does not over do this with no offense

00:11:17,320 --> 00:11:21,040
isn't it but suppose you put the right

00:11:19,300 --> 00:11:25,330
fences of the fences that are intuitive

00:11:21,040 --> 00:11:28,480
in it the question is is it in fact true

00:11:25,330 --> 00:11:31,540
that the second thread will see the

00:11:28,480 --> 00:11:32,740
intended member ok so this could be this

00:11:31,540 --> 00:11:34,960
whole part on the left could be some

00:11:32,740 --> 00:11:37,780
library function foo that pops a thing

00:11:34,960 --> 00:11:39,640
off of a queue and you know there's a

00:11:37,780 --> 00:11:41,590
thread that pushed in thread 0 pushed

00:11:39,640 --> 00:11:44,950
into a queue thread one popped it from

00:11:41,590 --> 00:11:48,100
the queue this could be another library

00:11:44,950 --> 00:11:49,900
function where I say I I know that a

00:11:48,100 --> 00:11:51,460
certain piece of data has been made

00:11:49,900 --> 00:11:53,320
visible that I know the piece of data

00:11:51,460 --> 00:11:55,390
has been computed so go ahead and do

00:11:53,320 --> 00:11:58,450
some processing on that but unknown to

00:11:55,390 --> 00:12:00,220
the caller of bar the way that bar does

00:11:58,450 --> 00:12:02,860
its processing is it asks another thread

00:12:00,220 --> 00:12:09,610
to do it ok and in between these things

00:12:02,860 --> 00:12:12,730
is white space ok we got on the wrong

00:12:09,610 --> 00:12:15,310
side of this argument at the time we

00:12:12,730 --> 00:12:17,490
what I wrote on the right was what we

00:12:15,310 --> 00:12:20,860
had in our rules which I think is wrong

00:12:17,490 --> 00:12:23,110
we said if all of the fences everywhere

00:12:20,860 --> 00:12:25,780
all of the same scopes then yes this is

00:12:23,110 --> 00:12:27,940
ensured if the Scopes are mixed then it

00:12:25,780 --> 00:12:29,440
really depends and it might not

00:12:27,940 --> 00:12:33,130
therefore the machine might be really

00:12:29,440 --> 00:12:36,880
counterintuitive ok well luckily the

00:12:33,130 --> 00:12:39,760
software team argued us to sanity and we

00:12:36,880 --> 00:12:43,390
ensured composability we did not finish

00:12:39,760 --> 00:12:46,210
the Year 2012 with the user hostile rule

00:12:43,390 --> 00:12:56,980
we actually said yes it's always in

00:12:46,210 --> 00:13:00,640
short ok 2013 you know at the time we

00:12:56,980 --> 00:13:04,000
still had yet to see other memory models

00:13:00,640 --> 00:13:06,280
so other GPU memory models so we knew of

00:13:04,000 --> 00:13:08,220
ours and we knew of the warts in ours I

00:13:06,280 --> 00:13:11,380
just this guy just aired a few of them

00:13:08,220 --> 00:13:14,230
we knew of the warts in them and so we

00:13:11,380 --> 00:13:16,960
felt like even though we had just done

00:13:14,230 --> 00:13:19,540
the whole drafting and sign-off and

00:13:16,960 --> 00:13:20,790
negotiation and everything we felt like

00:13:19,540 --> 00:13:22,650
doing it again

00:13:20,790 --> 00:13:27,870
so then we're gonna write an entirely

00:13:22,650 --> 00:13:30,630
new model here's how it starts so we

00:13:27,870 --> 00:13:32,250
know we have certain elements that we

00:13:30,630 --> 00:13:35,670
have in our architecture we've got

00:13:32,250 --> 00:13:37,530
thread groups we've got scope fences we

00:13:35,670 --> 00:13:40,860
have this concept of a generic address

00:13:37,530 --> 00:13:42,690
space which is very Nvidia in the as far

00:13:40,860 --> 00:13:45,750
as GPUs are concerned and what I mean by

00:13:42,690 --> 00:13:47,790
that is yes we have scratch pads yes we

00:13:45,750 --> 00:13:51,120
have global memory yes we have thread

00:13:47,790 --> 00:13:54,150
stack memory but when you form a pointer

00:13:51,120 --> 00:13:56,160
on an Nvidia device your pointer does

00:13:54,150 --> 00:13:58,110
not carry type information as to which

00:13:56,160 --> 00:13:59,790
of these things it is the machine

00:13:58,110 --> 00:14:04,380
automatically goes to the right place

00:13:59,790 --> 00:14:05,730
every time okay and we have barrier

00:14:04,380 --> 00:14:07,950
synchronization so these are the

00:14:05,730 --> 00:14:09,780
elements that are unique to us that we

00:14:07,950 --> 00:14:13,320
knew we needed to bring into this new

00:14:09,780 --> 00:14:15,510
model but by now we're a little bit more

00:14:13,320 --> 00:14:16,770
familiar with other models you know

00:14:15,510 --> 00:14:19,230
we've just been through this other

00:14:16,770 --> 00:14:20,430
exercise we learned a bunch we've been

00:14:19,230 --> 00:14:21,470
at the Seacoast Committee for a little

00:14:20,430 --> 00:14:25,260
while we learned a bunch

00:14:21,470 --> 00:14:27,320
so there are things that we see in the

00:14:25,260 --> 00:14:30,090
C++ and Java memory models that we like

00:14:27,320 --> 00:14:34,410
and I'm gonna explain the American node

00:14:30,090 --> 00:14:36,090
in a minute um C++ and Java make a

00:14:34,410 --> 00:14:37,980
distinction between atomic operations

00:14:36,090 --> 00:14:39,660
and non atomic operations did you notice

00:14:37,980 --> 00:14:41,250
that CPU memory models don't tend to

00:14:39,660 --> 00:14:43,170
make that distinction CPU memory models

00:14:41,250 --> 00:14:44,700
promise that if you touch memories you

00:14:43,170 --> 00:14:47,490
always touch it atomically that's kind

00:14:44,700 --> 00:14:49,230
of over-promising I think um I you know

00:14:47,490 --> 00:14:50,850
if C++ is going to make this distinction

00:14:49,230 --> 00:14:52,860
it's a really useful distinction for me

00:14:50,850 --> 00:14:54,240
to know about as a an implementer a

00:14:52,860 --> 00:14:56,370
machine implementer

00:14:54,240 --> 00:14:58,980
so we decide yes we're gonna have this

00:14:56,370 --> 00:15:00,860
distinction between atomic loads and

00:14:58,980 --> 00:15:03,600
stores and non-atomic loads and stores

00:15:00,860 --> 00:15:05,040
we really want the one happens before we

00:15:03,600 --> 00:15:06,690
don't want the two relations that you

00:15:05,040 --> 00:15:09,510
need to reason about we want it to be

00:15:06,690 --> 00:15:11,340
always transitive and in C++ they're

00:15:09,510 --> 00:15:12,600
actually three memory model subsets if

00:15:11,340 --> 00:15:14,550
you look at it you could take them as

00:15:12,600 --> 00:15:16,800
C++ memory model and bin everything into

00:15:14,550 --> 00:15:19,080
three bits there's a relaxed consistent

00:15:16,800 --> 00:15:20,550
subset there's a release consistent

00:15:19,080 --> 00:15:22,110
subset the release of quiet and acquired

00:15:20,550 --> 00:15:24,600
part and there's a sequentially

00:15:22,110 --> 00:15:26,310
consistent part and they interoperate in

00:15:24,600 --> 00:15:27,720
a way that makes sense but you can you

00:15:26,310 --> 00:15:29,370
can see the elements of these three

00:15:27,720 --> 00:15:32,160
subsets and we like that too we wanted

00:15:29,370 --> 00:15:34,990
that in our model but we were also

00:15:32,160 --> 00:15:37,480
looking at hardware memory models which

00:15:34,990 --> 00:15:40,300
are also interesting so the par way the

00:15:37,480 --> 00:15:44,740
power in our models I'll tell you memory

00:15:40,300 --> 00:15:46,390
is not total a total order meaning you

00:15:44,740 --> 00:15:49,330
might have an assumption then if she do

00:15:46,390 --> 00:15:51,070
a bunch of loads and stores no fences

00:15:49,330 --> 00:15:54,990
you just borrow loads and stores into

00:15:51,070 --> 00:15:57,750
the machine that the machine picks a

00:15:54,990 --> 00:16:02,709
total order for all these operations

00:15:57,750 --> 00:16:07,600
it's true on x86 but power says no every

00:16:02,709 --> 00:16:10,000
core can observe a different order that

00:16:07,600 --> 00:16:12,760
memory operations settled into in the

00:16:10,000 --> 00:16:14,170
absence of synchronization and it turns

00:16:12,760 --> 00:16:16,959
out that that's really empowering for us

00:16:14,170 --> 00:16:19,029
so we borrow that dependency order is

00:16:16,959 --> 00:16:22,149
well specified in CPU memory models it's

00:16:19,029 --> 00:16:24,670
very poorly specified in C++ but it's

00:16:22,149 --> 00:16:26,649
well specified in CPU memory models

00:16:24,670 --> 00:16:28,209
there is a hard out of thin air

00:16:26,649 --> 00:16:34,630
guarantee which unfortunately I cannot

00:16:28,209 --> 00:16:36,970
get into yes and there's something else

00:16:34,630 --> 00:16:38,529
that's neat this cpu memory models the

00:16:36,970 --> 00:16:39,940
hardware memory models don't have

00:16:38,529 --> 00:16:42,970
undefined behavior in the president of

00:16:39,940 --> 00:16:47,040
races they have extremely loose behavior

00:16:42,970 --> 00:16:49,839
but not you be at the end of the day

00:16:47,040 --> 00:16:52,740
we're gonna say you're completely

00:16:49,839 --> 00:16:58,240
erasing reads and writes will obtain

00:16:52,740 --> 00:16:59,560
byte that you wrote and not the credit

00:16:58,240 --> 00:17:02,410
card number of the in the other process

00:16:59,560 --> 00:17:03,760
over there right okay yeah because you

00:17:02,410 --> 00:17:05,890
couldn't sell hardware with hardware it

00:17:03,760 --> 00:17:06,819
said that all right okay now now one

00:17:05,890 --> 00:17:10,000
thing that I think is really interesting

00:17:06,819 --> 00:17:13,050
to note is that academics sort of neatly

00:17:10,000 --> 00:17:15,490
sorted themselves into two buckets where

00:17:13,050 --> 00:17:17,470
most of the American academics are

00:17:15,490 --> 00:17:18,939
looking at things on the right and most

00:17:17,470 --> 00:17:20,620
of the European academics are you

00:17:18,939 --> 00:17:22,569
looking at things on the left so

00:17:20,620 --> 00:17:24,640
sometimes you'll be interesting a little

00:17:22,569 --> 00:17:27,429
group of memory model experts and you'll

00:17:24,640 --> 00:17:29,500
notice why is no one bringing up the you

00:17:27,429 --> 00:17:31,840
know the the power of partial ordering

00:17:29,500 --> 00:17:33,970
issues and then you realize oh it's

00:17:31,840 --> 00:17:36,720
because I only have people from UIUC at

00:17:33,970 --> 00:17:36,720
MIT with me right now

00:17:36,850 --> 00:17:44,600
okay so so now that we had loftier goals

00:17:43,310 --> 00:17:48,740
you might imagine that that took a

00:17:44,600 --> 00:17:50,810
little bit longer to explain and I'll

00:17:48,740 --> 00:17:53,090
give you that quick tour again so

00:17:50,810 --> 00:17:54,710
actually the front part of it is a pro's

00:17:53,090 --> 00:17:56,180
version of the memory model which is

00:17:54,710 --> 00:17:59,780
full of examples and that's actually

00:17:56,180 --> 00:18:01,070
kind of nice the semi-formal part is the

00:17:59,780 --> 00:18:02,780
rest which sure if you look at the

00:18:01,070 --> 00:18:04,550
semi-formal by sort of the same size as

00:18:02,780 --> 00:18:07,010
the previous one so we did a pretty good

00:18:04,550 --> 00:18:10,070
job there and and that thing at the end

00:18:07,010 --> 00:18:12,920
is advice to the reader the last pages

00:18:10,070 --> 00:18:15,740
exceptions all right so that's that's a

00:18:12,920 --> 00:18:19,100
lot better all right so what were other

00:18:15,740 --> 00:18:20,750
x' doing contemporaneously in 2013 what

00:18:19,100 --> 00:18:22,430
were they doing with their memory model

00:18:20,750 --> 00:18:24,320
so it's right it's a GPU elements there

00:18:22,430 --> 00:18:28,820
because it's not gonna be about us right

00:18:24,320 --> 00:18:31,430
so well the first thing is they're not

00:18:28,820 --> 00:18:34,100
really looking at the CPU style memory

00:18:31,430 --> 00:18:37,490
model specifications so they they have

00:18:34,100 --> 00:18:38,990
undefined behavior for races they're out

00:18:37,490 --> 00:18:40,880
of thin air guarantee is pretty thin

00:18:38,990 --> 00:18:42,350
it's the same one as in C++ the

00:18:40,880 --> 00:18:44,150
dependency order definition is also

00:18:42,350 --> 00:18:46,700
pretty thin that's the same as in C++

00:18:44,150 --> 00:18:48,680
and they don't speak too much about the

00:18:46,700 --> 00:18:50,060
the partial ordering but it turns out

00:18:48,680 --> 00:18:53,690
they sort of walk away from it because

00:18:50,060 --> 00:18:54,800
um because there are their release

00:18:53,690 --> 00:18:56,390
consistent operations are gonna be

00:18:54,800 --> 00:18:58,310
sequentially consistent all right

00:18:56,390 --> 00:18:59,840
they have multiple address faces they

00:18:58,310 --> 00:19:01,820
don't have a generic pointer facility

00:18:59,840 --> 00:19:03,200
where you can form a pointer into a

00:19:01,820 --> 00:19:04,640
piece of code it doesn't matter whether

00:19:03,200 --> 00:19:06,800
it's a scratch pad or global memory

00:19:04,640 --> 00:19:08,000
every function needs to say that this

00:19:06,800 --> 00:19:10,550
isn't scratch pad or this is a global

00:19:08,000 --> 00:19:11,930
memory they end up with two happens

00:19:10,550 --> 00:19:13,840
before us because they have one in

00:19:11,930 --> 00:19:16,130
scratch pad and one in global memory

00:19:13,840 --> 00:19:18,020
there are sometimes transitive for the

00:19:16,130 --> 00:19:21,500
same reasons as a mistake we made the

00:19:18,020 --> 00:19:24,110
same but year before and they have

00:19:21,500 --> 00:19:26,660
something that's really popular among

00:19:24,110 --> 00:19:28,580
the American academic crowd which is

00:19:26,660 --> 00:19:31,310
they don't really have our CNSC

00:19:28,580 --> 00:19:32,900
they have our CSC meaning their load

00:19:31,310 --> 00:19:35,630
acquire is a sequentially consistent

00:19:32,900 --> 00:19:37,610
load and their store release is a

00:19:35,630 --> 00:19:40,550
sequentially consistent store they're

00:19:37,610 --> 00:19:42,410
sort of lacking that weaker definition

00:19:40,550 --> 00:19:44,540
which really enables the partial

00:19:42,410 --> 00:19:47,180
ordering to be exploited okay so that's

00:19:44,540 --> 00:19:49,400
what existed at the time so we we made a

00:19:47,180 --> 00:19:51,950
pretty fancy model okay

00:19:49,400 --> 00:19:53,510
um and I dig gentler in many ways but

00:19:51,950 --> 00:19:56,870
not always I mean it's not gentler and

00:19:53,510 --> 00:20:01,190
always is because I will admit that our

00:19:56,870 --> 00:20:02,270
CSC without the slash is gentler it's

00:20:01,190 --> 00:20:04,970
just I don't think it's good for

00:20:02,270 --> 00:20:07,090
implementations okay could we have

00:20:04,970 --> 00:20:10,580
shipped it well no oh we can't ship it

00:20:07,090 --> 00:20:11,960
we can't ship it in 2013 because we

00:20:10,580 --> 00:20:14,720
don't have the hardware that that model

00:20:11,960 --> 00:20:18,110
really was we're working on it but we

00:20:14,720 --> 00:20:19,430
don't have it um also it's kind of

00:20:18,110 --> 00:20:21,020
written like it's 1990

00:20:19,430 --> 00:20:24,290
I mean remember that we started from

00:20:21,020 --> 00:20:26,750
this spark 9 manual then we took they're

00:20:24,290 --> 00:20:29,140
like three line little example and we

00:20:26,750 --> 00:20:33,710
turned it into a twenty page monstrosity

00:20:29,140 --> 00:20:35,680
okay that that wording technology was

00:20:33,710 --> 00:20:38,870
never intended to be stretched this far

00:20:35,680 --> 00:20:40,280
and we can't prove any formal facts

00:20:38,870 --> 00:20:43,370
about it okay

00:20:40,280 --> 00:20:45,470
so what's gonna happen now is we're

00:20:43,370 --> 00:20:48,970
going to catch up 25 years of science in

00:20:45,470 --> 00:20:54,490
about fun all right

00:20:48,970 --> 00:20:56,990
2014 this is when we really became

00:20:54,490 --> 00:20:58,850
comfortable with partial order models

00:20:56,990 --> 00:21:01,630
and this is when you will now become

00:20:58,850 --> 00:21:05,720
comfortable with partial order models

00:21:01,630 --> 00:21:07,700
alright the first thing that we need to

00:21:05,720 --> 00:21:09,350
have in our vocabulary is we need to

00:21:07,700 --> 00:21:13,340
understand what is the meaning of

00:21:09,350 --> 00:21:16,760
atomicity and here's a citation this is

00:21:13,340 --> 00:21:19,190
a book we're going to have two

00:21:16,760 --> 00:21:22,460
definitions of atomicity the first one

00:21:19,190 --> 00:21:24,140
called single copy ethnicity means that

00:21:22,460 --> 00:21:26,600
when I perform a memory operation I

00:21:24,140 --> 00:21:28,100
never have an interleaving of that

00:21:26,600 --> 00:21:32,320
operation with another one in the middle

00:21:28,100 --> 00:21:34,670
I perform a load entirely or not at all

00:21:32,320 --> 00:21:37,430
same first or same for an atomic

00:21:34,670 --> 00:21:39,890
read-modify-write multiple copy

00:21:37,430 --> 00:21:44,150
atomicity is something else it's saying

00:21:39,890 --> 00:21:46,850
that not only are the operations not you

00:21:44,150 --> 00:21:49,790
cannot observe an inter leaving internal

00:21:46,850 --> 00:21:52,190
to the operations but also they are part

00:21:49,790 --> 00:21:56,240
of a single total order across the whole

00:21:52,190 --> 00:21:58,490
machine okay so the analogy is the teeth

00:21:56,240 --> 00:22:00,350
on a zipper are indivisible and then

00:21:58,490 --> 00:22:03,140
what you get at the bottom is the

00:22:00,350 --> 00:22:05,000
serialization okay you started with two

00:22:03,140 --> 00:22:06,800
streams of teeth and you interleave them

00:22:05,000 --> 00:22:09,800
in some way but they're interleaved in

00:22:06,800 --> 00:22:11,990
the serialization you never have to dip

00:22:09,800 --> 00:22:17,870
your teeth that like happen to inhabit

00:22:11,990 --> 00:22:20,900
the same volume in space yeah okay there

00:22:17,870 --> 00:22:22,130
was a there was a thought which I I'm

00:22:20,900 --> 00:22:26,030
gonna immediately tell you that I

00:22:22,130 --> 00:22:27,440
disagree with that the way you should

00:22:26,030 --> 00:22:31,580
define a memory model is you should

00:22:27,440 --> 00:22:33,920
first immediately say only multi copy

00:22:31,580 --> 00:22:36,230
atomicity is acceptable I don't agree

00:22:33,920 --> 00:22:39,110
with that but anyway I'm suppose you say

00:22:36,230 --> 00:22:41,420
that and then you explain all of the

00:22:39,110 --> 00:22:44,150
machines behavior in terms of reordering

00:22:41,420 --> 00:22:47,080
and if at any time you have had a

00:22:44,150 --> 00:22:49,760
conversation with someone that was

00:22:47,080 --> 00:22:53,240
debating memory models in terms of

00:22:49,760 --> 00:22:55,640
reordering then I can tell you that

00:22:53,240 --> 00:23:01,430
conversation you had was with that frame

00:22:55,640 --> 00:23:03,140
of mind which I think is wrong okay so

00:23:01,430 --> 00:23:04,670
you start with the same thing as earlier

00:23:03,140 --> 00:23:06,680
you get both E and divisible and is

00:23:04,670 --> 00:23:09,860
serializable and then you explain the

00:23:06,680 --> 00:23:10,580
zipper machinery thingy as some table of

00:23:09,860 --> 00:23:13,780
reorderings

00:23:10,580 --> 00:23:15,980
so for example you might say that

00:23:13,780 --> 00:23:19,430
subsequent load can pass an earlier

00:23:15,980 --> 00:23:22,820
store and that would essentially be

00:23:19,430 --> 00:23:26,660
exodus xDSL okay it is enough for T so

00:23:22,820 --> 00:23:30,260
that is definitely true okay but what

00:23:26,660 --> 00:23:34,790
we're looking for is the next step the

00:23:30,260 --> 00:23:38,840
next step is asserting less we're gonna

00:23:34,790 --> 00:23:41,000
say okay instead of assuming multi copy

00:23:38,840 --> 00:23:45,860
atomicity we're gonna only assume single

00:23:41,000 --> 00:23:48,520
copy atomicity now I have a couple of em

00:23:45,860 --> 00:23:51,380
blanks there so what can we say about

00:23:48,520 --> 00:23:53,030
what the result of the machine execution

00:23:51,380 --> 00:23:58,070
will be and how can we describe the

00:23:53,030 --> 00:23:59,240
machine well what we do is is we treat

00:23:58,070 --> 00:24:04,280
the machine as essentially being

00:23:59,240 --> 00:24:06,530
inscrutable and we give you some axioms

00:24:04,280 --> 00:24:09,260
about that finally interleaving we're

00:24:06,530 --> 00:24:13,020
going to say in that final interleaving

00:24:09,260 --> 00:24:16,700
you may find anything

00:24:13,020 --> 00:24:19,410
but not certain kinds of inconsistencies

00:24:16,700 --> 00:24:24,750
certain kind of inconsistencies will not

00:24:19,410 --> 00:24:26,700
be in the interleaving okay all right

00:24:24,750 --> 00:24:27,929
now you're gonna forget the zipper

00:24:26,700 --> 00:24:31,530
analogy because we're not gonna use it

00:24:27,929 --> 00:24:34,280
again there is no such thing as a unique

00:24:31,530 --> 00:24:38,240
total order of memory operations done

00:24:34,280 --> 00:24:38,240
okay so how do you make a memory vault

00:24:38,660 --> 00:24:44,970
first you consider intended constraints

00:24:42,570 --> 00:24:48,450
for some test program so you're right a

00:24:44,970 --> 00:24:49,559
really really short little program like

00:24:48,450 --> 00:24:50,970
the one I had earlier in fact the one I

00:24:49,559 --> 00:24:52,830
had earlier is by far not one of the

00:24:50,970 --> 00:24:55,230
shortest it had six instructions in it

00:24:52,830 --> 00:24:56,580
that's huge usually you're gonna start

00:24:55,230 --> 00:24:58,200
with like two instruction programs and

00:24:56,580 --> 00:24:59,700
three instruction programs okay and

00:24:58,200 --> 00:25:01,440
you're gonna think about what are they

00:24:59,700 --> 00:25:03,150
good inconsistencies you don't want to

00:25:01,440 --> 00:25:05,309
see for that mystery for that little

00:25:03,150 --> 00:25:07,559
program so you're gonna formulate those

00:25:05,309 --> 00:25:11,630
axioms over some set of relations which

00:25:07,559 --> 00:25:14,160
you know is coming in the next slides

00:25:11,630 --> 00:25:16,770
then we're gonna use some kind of a tool

00:25:14,160 --> 00:25:18,929
to enumerate the programs that still

00:25:16,770 --> 00:25:20,550
remain after we have constrain the

00:25:18,929 --> 00:25:23,160
executions are good you're gonna get

00:25:20,550 --> 00:25:25,410
that as an output you're gonna look at

00:25:23,160 --> 00:25:27,330
it and you're going to use your

00:25:25,410 --> 00:25:30,450
intuition and your knowledge of C bus

00:25:27,330 --> 00:25:33,059
boss and you know what your intent is as

00:25:30,450 --> 00:25:35,400
a designer and you're gonna repeat

00:25:33,059 --> 00:25:37,620
you're gonna go back to the top consider

00:25:35,400 --> 00:25:39,179
the constraints constraint produce

00:25:37,620 --> 00:25:41,940
programs look at them again and you'll

00:25:39,179 --> 00:25:44,820
just keep doing this until you don't see

00:25:41,940 --> 00:25:48,300
anything weird anymore okay well your

00:25:44,820 --> 00:25:51,450
workhorse litmus test is always MP which

00:25:48,300 --> 00:25:53,790
stands for message passing most

00:25:51,450 --> 00:25:56,240
conversations about communication

00:25:53,790 --> 00:25:59,940
through memory involves describing MP

00:25:56,240 --> 00:26:02,400
because MP is this example of I set some

00:25:59,940 --> 00:26:04,410
data then I set some flag someone loads

00:26:02,400 --> 00:26:07,040
the flag then loads the data and the

00:26:04,410 --> 00:26:11,400
question is at the end of all of this

00:26:07,040 --> 00:26:16,020
does seeing a 1 in flag imply seeing a 1

00:26:11,400 --> 00:26:21,660
in data and you expect yes but the

00:26:16,020 --> 00:26:23,520
reality is it depends now MP is actually

00:26:21,660 --> 00:26:25,080
a stand-in for most forms of

00:26:23,520 --> 00:26:26,549
synchronization which is why it comes up

00:26:25,080 --> 00:26:28,169
so often

00:26:26,549 --> 00:26:31,679
when you are teaching a memory model to

00:26:28,169 --> 00:26:35,600
someone because I could replace my flag

00:26:31,679 --> 00:26:38,610
let's say with mutex operations and

00:26:35,600 --> 00:26:40,410
thread zero begins as the first owner of

00:26:38,610 --> 00:26:43,320
the mutex writes some data

00:26:40,410 --> 00:26:45,110
unlocks the mutex read one locks the

00:26:43,320 --> 00:26:48,120
mutex and then wants to look at the data

00:26:45,110 --> 00:26:52,200
if thread one is the second owner does

00:26:48,120 --> 00:26:54,929
it mean it sees one those are those the

00:26:52,200 --> 00:26:58,530
previous form in this form are

00:26:54,929 --> 00:27:03,330
equivalent except that in this case here

00:26:58,530 --> 00:27:05,280
reality has to be yes ok so there's

00:27:03,330 --> 00:27:06,929
gonna be something about that unlocked

00:27:05,280 --> 00:27:08,940
function and that lock function they're

00:27:06,929 --> 00:27:19,020
gonna need to contain something so that

00:27:08,940 --> 00:27:20,400
the it depends becomes yes ok so we're

00:27:19,020 --> 00:27:24,270
gonna say that we're looking for

00:27:20,400 --> 00:27:26,330
consistent results results consistent

00:27:24,270 --> 00:27:28,590
with an intuitive read of the program

00:27:26,330 --> 00:27:31,140
and that implies that there's some sort

00:27:28,590 --> 00:27:32,700
of sort key there's sort of a notion of

00:27:31,140 --> 00:27:35,039
this happened before that happened

00:27:32,700 --> 00:27:37,049
before this we've already spilled beam

00:27:35,039 --> 00:27:41,640
happens before isn't sequel suppose okay

00:27:37,049 --> 00:27:45,059
so so you know we want the initial right

00:27:41,640 --> 00:27:46,890
of zero to data to be before the

00:27:45,059 --> 00:27:50,309
execution of the program so that

00:27:46,890 --> 00:27:53,220
initiative initialization at t zero at

00:27:50,309 --> 00:27:56,789
time zero happens before thread zero run

00:27:53,220 --> 00:28:00,419
is that's before that the stored data is

00:27:56,789 --> 00:28:03,120
before the store flag in in a way the

00:28:00,419 --> 00:28:05,880
store of one two flag is before reading

00:28:03,120 --> 00:28:07,799
one how could I have read one if it was

00:28:05,880 --> 00:28:11,549
not stored before that would not be

00:28:07,799 --> 00:28:14,700
intuitive and then the second load is

00:28:11,549 --> 00:28:19,610
before also and so the thing we are

00:28:14,700 --> 00:28:24,390
trying to forbid is that load being

00:28:19,610 --> 00:28:26,159
before the store of data and then that

00:28:24,390 --> 00:28:29,970
would form a that would form a cycle

00:28:26,159 --> 00:28:33,870
okay so the question becomes what kind

00:28:29,970 --> 00:28:36,150
of code do I expect at the common a and

00:28:33,870 --> 00:28:40,010
or the comments B so that will forbid

00:28:36,150 --> 00:28:42,620
the loop and so then you expect

00:28:40,010 --> 00:28:44,520
that it's forbidden and the reality is

00:28:42,620 --> 00:28:45,960
it's going to be forbidden but

00:28:44,520 --> 00:28:48,060
programmer shall ensure that it has that

00:28:45,960 --> 00:28:49,770
he's got the right code at AMD and the

00:28:48,060 --> 00:28:52,890
author of the mutex is the one

00:28:49,770 --> 00:28:54,900
responsible for that okay and the memory

00:28:52,890 --> 00:28:57,360
model tells the author of the mutex

00:28:54,900 --> 00:29:00,630
where to put what to put has the morally

00:28:57,360 --> 00:29:04,380
equivalent Andy okay I use this word

00:29:00,630 --> 00:29:06,690
before but you know things in program

00:29:04,380 --> 00:29:09,870
order or notionally differently before

00:29:06,690 --> 00:29:10,830
then a read that reads from a right okay

00:29:09,870 --> 00:29:12,570
so we're gonna be a little bit more

00:29:10,830 --> 00:29:15,990
specific we're gonna go back to that

00:29:12,570 --> 00:29:18,060
Suzette's work and we're gonna actually

00:29:15,990 --> 00:29:19,500
create a bunch of different kinds of

00:29:18,060 --> 00:29:23,040
before and we're gonna use them to

00:29:19,500 --> 00:29:25,560
describe the execution okay so what the

00:29:23,040 --> 00:29:27,210
program wrote down is program order I

00:29:25,560 --> 00:29:29,040
had a series of statements in each

00:29:27,210 --> 00:29:33,120
thread the statements in a Tibet are

00:29:29,040 --> 00:29:34,350
related and happens in program order the

00:29:33,120 --> 00:29:38,580
instructions in different threads are

00:29:34,350 --> 00:29:40,650
not related in program order okay what

00:29:38,580 --> 00:29:42,720
the Machine actually did the other

00:29:40,650 --> 00:29:45,450
before arrows is what the machine did

00:29:42,720 --> 00:29:52,560
those are several relations we're gonna

00:29:45,450 --> 00:29:55,740
call our F read from the right that

00:29:52,560 --> 00:29:58,620
produces a value preceding a read that

00:29:55,740 --> 00:30:01,650
reads that value specifically that value

00:29:58,620 --> 00:30:03,510
not an equivalent value this one I gave

00:30:01,650 --> 00:30:05,640
for writes horse 42 and there's another

00:30:03,510 --> 00:30:06,960
right in the program that stores 42 the

00:30:05,640 --> 00:30:08,910
memory model will actually distinguish

00:30:06,960 --> 00:30:14,250
between which of the two writes your you

00:30:08,910 --> 00:30:16,680
read from okay coherence order is the

00:30:14,250 --> 00:30:19,110
order in which two writes that overwrite

00:30:16,680 --> 00:30:22,740
one another are related that's also a

00:30:19,110 --> 00:30:24,060
before a kind of before the next one is

00:30:22,740 --> 00:30:27,810
a little bit kind of weird and so I need

00:30:24,060 --> 00:30:30,960
a diagram for that firm read is gonna be

00:30:27,810 --> 00:30:32,820
the opposite of read from if I read from

00:30:30,960 --> 00:30:36,390
a value and that value is later

00:30:32,820 --> 00:30:38,310
overwritten then my read that read the

00:30:36,390 --> 00:30:42,150
value but not one of the values that

00:30:38,310 --> 00:30:44,370
overrode it is some kind of before their

00:30:42,150 --> 00:30:45,930
rights that over wrote the value okay

00:30:44,370 --> 00:30:50,190
and so you see this diagram over there I

00:30:45,930 --> 00:30:53,080
have a w0 and it is connected to a a

00:30:50,190 --> 00:30:55,300
read that reached its value and

00:30:53,080 --> 00:30:58,900
I have aw1 in a w-2 and those are

00:30:55,300 --> 00:31:01,680
related in Co because they overwrite w1

00:30:58,900 --> 00:31:06,490
overwrites w0 and W to overwrites the b1

00:31:01,680 --> 00:31:11,380
well F R is going to connect the read to

00:31:06,490 --> 00:31:13,960
all the co subsequent writes okay it

00:31:11,380 --> 00:31:17,350
doesn't seem all that useful now it'll

00:31:13,960 --> 00:31:18,910
be very useful in a few minutes okay and

00:31:17,350 --> 00:31:21,520
then we're just gonna have one more

00:31:18,910 --> 00:31:23,350
we're gonna have in in Jan's work these

00:31:21,520 --> 00:31:26,530
are the orders unfortunately the

00:31:23,350 --> 00:31:30,310
specification of power is very ugly with

00:31:26,530 --> 00:31:31,630
only these four SC is going to be a

00:31:30,310 --> 00:31:33,670
special relation we're not really going

00:31:31,630 --> 00:31:35,290
to talk about today but it relates their

00:31:33,670 --> 00:31:37,720
heaviest offenses that your machine has

00:31:35,290 --> 00:31:39,520
in a unique total order and that is the

00:31:37,720 --> 00:31:43,540
only thing related in a DNA tall order

00:31:39,520 --> 00:31:46,060
okay all right now that I've shown you

00:31:43,540 --> 00:31:49,270
these relations I can show you a sample

00:31:46,060 --> 00:31:51,520
of different litmus tests and the kinds

00:31:49,270 --> 00:31:54,610
of cycles you were looking to forbid as

00:31:51,520 --> 00:31:57,310
you are designing your memory model okay

00:31:54,610 --> 00:32:00,100
so the it starts from very simple ones

00:31:57,310 --> 00:32:03,490
like you know like this one it would not

00:32:00,100 --> 00:32:05,380
be acceptable to me if two rights that

00:32:03,490 --> 00:32:10,360
are in the same thread in program order

00:32:05,380 --> 00:32:12,520
over route each other via time travel it

00:32:10,360 --> 00:32:14,770
would not be acceptable to me if a read

00:32:12,520 --> 00:32:16,330
could read from the future you know

00:32:14,770 --> 00:32:18,160
things like that you know so you start

00:32:16,330 --> 00:32:19,570
with simple facts eventually you get a

00:32:18,160 --> 00:32:24,100
little bit more complicated and then you

00:32:19,570 --> 00:32:25,900
find MP somewhere in there and MP makes

00:32:24,100 --> 00:32:29,170
use of that FR edge

00:32:25,900 --> 00:32:32,590
that yellow FR edge where it says that

00:32:29,170 --> 00:32:35,680
means if this read rates from the

00:32:32,590 --> 00:32:39,490
initial value 0 then it's connected from

00:32:35,680 --> 00:32:41,860
the initial value to it by an RF the

00:32:39,490 --> 00:32:44,290
initial value is connected to this other

00:32:41,860 --> 00:32:47,110
stores in the program by a code which

00:32:44,290 --> 00:32:48,580
means that that read would if the cycle

00:32:47,110 --> 00:32:51,580
occurs and that read is connected to

00:32:48,580 --> 00:32:56,530
this write by a form okay we're gonna do

00:32:51,580 --> 00:32:59,920
this again more slowly okay but now we

00:32:56,530 --> 00:33:02,560
have the tools it's easy to specify

00:32:59,920 --> 00:33:04,630
sequential consistency and i in this

00:33:02,560 --> 00:33:07,080
framework sequential consistency is

00:33:04,630 --> 00:33:10,270
saying that if i take all the POE edges

00:33:07,080 --> 00:33:13,030
Union all the ko edges Union all the RF

00:33:10,270 --> 00:33:15,130
edges Union all the fr edges then this

00:33:13,030 --> 00:33:18,880
entire set of edges all Union together

00:33:15,130 --> 00:33:21,460
there are no cycles in it that is

00:33:18,880 --> 00:33:25,169
sequential consistency and it's it's so

00:33:21,460 --> 00:33:27,309
neat it's so compact easy to understand

00:33:25,169 --> 00:33:29,710
okay so we kept simple things simple

00:33:27,309 --> 00:33:31,780
just cool but complex complex models

00:33:29,710 --> 00:33:33,400
will continue to be complex and but but

00:33:31,780 --> 00:33:36,730
the most important thing is in the

00:33:33,400 --> 00:33:39,280
previous framing we didn't even have the

00:33:36,730 --> 00:33:41,620
tools to describe a complex memory model

00:33:39,280 --> 00:33:44,440
now we have the tools now we're gonna

00:33:41,620 --> 00:33:48,840
you know fill in what's this is a cyclic

00:33:44,440 --> 00:33:56,590
in a in a more complex memory model

00:33:48,840 --> 00:33:59,950
alright 2015 2015 is when the team

00:33:56,590 --> 00:34:04,210
learned alloy and it's when you will

00:33:59,950 --> 00:34:09,250
learn Nellie here's here's sort of your

00:34:04,210 --> 00:34:11,609
ideal your ideal storyline for debugging

00:34:09,250 --> 00:34:15,010
a memory model problem in your company

00:34:11,609 --> 00:34:17,919
say you have solved the issue of model

00:34:15,010 --> 00:34:20,940
izing your system as logic over some

00:34:17,919 --> 00:34:24,159
graphs as we described before

00:34:20,940 --> 00:34:25,690
well you might you might one day be

00:34:24,159 --> 00:34:28,030
faced with some behavior of your machine

00:34:25,690 --> 00:34:30,040
you'll be like I really wonder if that

00:34:28,030 --> 00:34:34,929
behavior is something that we said is

00:34:30,040 --> 00:34:37,510
permitted so what do you do you go your

00:34:34,929 --> 00:34:41,490
closest Sat solver to prove it's not

00:34:37,510 --> 00:34:46,240
possible and your Sat solver goes away

00:34:41,490 --> 00:34:47,919
fan spinning takes some time hopefully

00:34:46,240 --> 00:34:52,290
you didn't ask for a problem so hard

00:34:47,919 --> 00:34:55,320
that the Sun is no longer 500k and and

00:34:52,290 --> 00:34:58,480
then the Sat solver will come back

00:34:55,320 --> 00:35:00,280
possibly with you got this completely

00:34:58,480 --> 00:35:03,580
wrong it's entirely possible here's a

00:35:00,280 --> 00:35:05,140
bunch of counter examples great thanks

00:35:03,580 --> 00:35:07,480
for the counter examples I could really

00:35:05,140 --> 00:35:09,130
use something like that and then you go

00:35:07,480 --> 00:35:10,900
away and you debug your problem using

00:35:09,130 --> 00:35:16,930
the counter examples of the Sat solver

00:35:10,900 --> 00:35:19,150
has given you all right now it's no joke

00:35:16,930 --> 00:35:20,890
the the time complexity of this is

00:35:19,150 --> 00:35:24,549
enormous

00:35:20,890 --> 00:35:26,859
here is actual times on different axioms

00:35:24,549 --> 00:35:29,079
of our memory model actual times through

00:35:26,859 --> 00:35:31,720
solving for graphs of a certain size you

00:35:29,079 --> 00:35:34,240
know our graph of size six is not very

00:35:31,720 --> 00:35:35,500
big but you're still talking about an

00:35:34,240 --> 00:35:37,089
interesting fraction of an app of an

00:35:35,500 --> 00:35:38,440
hour to solve something here and

00:35:37,089 --> 00:35:42,819
obviously if you want to solve for a

00:35:38,440 --> 00:35:46,900
large program I'm sorry large like I

00:35:42,819 --> 00:35:51,279
don't know 18 operations like you might

00:35:46,900 --> 00:35:54,160
end up having to wait years okay but

00:35:51,279 --> 00:35:55,930
don't let that discourage you because we

00:35:54,160 --> 00:36:02,619
are going to learn about this amazing

00:35:55,930 --> 00:36:04,569
tool from MIT what do you get when you

00:36:02,619 --> 00:36:06,010
take 1,200 papers and 13 PhD

00:36:04,569 --> 00:36:07,680
dissertations and you crystallize it

00:36:06,010 --> 00:36:11,019
into a piece of software you get this

00:36:07,680 --> 00:36:12,640
and we are going to use it right now and

00:36:11,019 --> 00:36:15,940
we're going to prove some things with it

00:36:12,640 --> 00:36:21,279
right now you know your nerd cred is in

00:36:15,940 --> 00:36:23,920
there okay so alloy is what is it it's a

00:36:21,279 --> 00:36:27,730
really clever graph DSL for set solvers

00:36:23,920 --> 00:36:30,490
you do not need to be an expert at set

00:36:27,730 --> 00:36:33,269
to make use of alloy because it's

00:36:30,490 --> 00:36:35,769
actually rather friendly to get into

00:36:33,269 --> 00:36:37,180
what why did why is it friendiy and

00:36:35,769 --> 00:36:39,700
you're gonna see the syntax I think you

00:36:37,180 --> 00:36:42,220
might like it why is it trendy well it's

00:36:39,700 --> 00:36:44,079
got these lowercase key words and curly

00:36:42,220 --> 00:36:47,349
braces and you don't need to

00:36:44,079 --> 00:36:52,539
parenthesize this like it's Lisp and it

00:36:47,349 --> 00:36:55,539
has C++ comments it's got a thing that's

00:36:52,539 --> 00:36:59,109
like classes with members and your

00:36:55,539 --> 00:37:01,859
classes can inherit okay I get that it's

00:36:59,109 --> 00:37:06,009
got a thing like pointers and some

00:37:01,859 --> 00:37:07,299
containers of pointers and it's also got

00:37:06,009 --> 00:37:11,019
a thing like functions although those

00:37:07,299 --> 00:37:13,539
are pure functional they are and it's

00:37:11,019 --> 00:37:16,529
got a syntax you know when I said

00:37:13,539 --> 00:37:18,519
earlier a cyclic something-or-other

00:37:16,529 --> 00:37:20,319
actually when we're gonna write these

00:37:18,519 --> 00:37:23,319
axioms we're gonna have a pattern

00:37:20,319 --> 00:37:25,480
matching syntax which is like your reg X

00:37:23,319 --> 00:37:27,009
and it's like a reg X syntax that you

00:37:25,480 --> 00:37:29,769
would recognize like you already know

00:37:27,009 --> 00:37:31,720
how to write many of the statements that

00:37:29,769 --> 00:37:32,320
we're gonna write here because the

00:37:31,720 --> 00:37:35,800
syntax is

00:37:32,320 --> 00:37:37,150
the same and it's got a kind of a main

00:37:35,800 --> 00:37:38,530
function now that one you really need to

00:37:37,150 --> 00:37:40,120
squint it's gonna think that's kind of

00:37:38,530 --> 00:37:41,500
like a main function and if you cause it

00:37:40,120 --> 00:37:48,370
to execute you're gonna get a thing

00:37:41,500 --> 00:37:51,900
that's output okay so it users familiar

00:37:48,370 --> 00:37:54,280
idioms so you go into it not scared

00:37:51,900 --> 00:37:57,940
appropriately no not scared get in not

00:37:54,280 --> 00:37:59,070
scared okay um so first here's the thing

00:37:57,940 --> 00:38:02,560
that's like a class

00:37:59,070 --> 00:38:05,230
they're called signatures and they have

00:38:02,560 --> 00:38:07,540
different kinds of members and on the

00:38:05,230 --> 00:38:11,320
left is how you would declare such a

00:38:07,540 --> 00:38:15,430
member in alloy you could say member a

00:38:11,320 --> 00:38:18,970
is a set of B and it's really as if it

00:38:15,430 --> 00:38:24,160
was a stood set of pointers to B's have

00:38:18,970 --> 00:38:27,310
to be not B's same thing for the other

00:38:24,160 --> 00:38:30,400
types some is a set that's actually

00:38:27,310 --> 00:38:33,670
constrained to not be empty one is a

00:38:30,400 --> 00:38:35,440
pointer that's not null and loan don't

00:38:33,670 --> 00:38:38,260
ask me why it is a pointer that could be

00:38:35,440 --> 00:38:41,320
no okay so I could just I could create

00:38:38,260 --> 00:38:43,210
one of those nodes one of those Outland

00:38:41,320 --> 00:38:47,230
I'll create one of these classes I'll

00:38:43,210 --> 00:38:50,050
say cig operation one of its members is

00:38:47,230 --> 00:38:52,630
program order and it points to zero or

00:38:50,050 --> 00:38:55,480
one other operations okay because in a

00:38:52,630 --> 00:38:57,280
thread the last operation does not have

00:38:55,480 --> 00:38:58,780
a program order subsequent right every

00:38:57,280 --> 00:39:02,710
other one has one but the last one does

00:38:58,780 --> 00:39:04,600
not have them okay I could inherit from

00:39:02,710 --> 00:39:07,150
operation I could say I have Reed's that

00:39:04,600 --> 00:39:09,100
extend the operation and I could say

00:39:07,150 --> 00:39:11,800
that I have rights which also extend

00:39:09,100 --> 00:39:13,510
operation and they have a member called

00:39:11,800 --> 00:39:16,570
reads from the little red arrow from

00:39:13,510 --> 00:39:19,480
before and it points to reads a set of

00:39:16,570 --> 00:39:21,850
reads a write is not necessarily ever

00:39:19,480 --> 00:39:23,620
connected to any other reads you could

00:39:21,850 --> 00:39:24,970
have you know a tree dies in the forest

00:39:23,620 --> 00:39:28,380
you know you can ever write another one

00:39:24,970 --> 00:39:33,370
reads um so it's a set and not a son

00:39:28,380 --> 00:39:34,780
okay before we can switch to the alloy

00:39:33,370 --> 00:39:36,700
UI we're gonna have something else to

00:39:34,780 --> 00:39:40,110
say that's gonna be a little bit more

00:39:36,700 --> 00:39:42,310
interesting okay two more things a

00:39:40,110 --> 00:39:44,780
predicate there's two kinds of functions

00:39:42,310 --> 00:39:46,160
in alloy there are functions that have

00:39:44,780 --> 00:39:47,090
bunch of input and a bunch of output and

00:39:46,160 --> 00:39:48,580
then there are functions that are

00:39:47,090 --> 00:39:50,660
specially constrained to return bool

00:39:48,580 --> 00:39:53,720
functions that return bool are special

00:39:50,660 --> 00:39:57,070
and there is a special kind of statement

00:39:53,720 --> 00:40:01,070
in alloy called a fact which which says

00:39:57,070 --> 00:40:04,910
whatever this evaluates to it's always

00:40:01,070 --> 00:40:07,400
true meaning if that expression has the

00:40:04,910 --> 00:40:08,360
potential to be false then any graph in

00:40:07,400 --> 00:40:10,460
which it is false

00:40:08,360 --> 00:40:14,480
is not a valid graph and can be

00:40:10,460 --> 00:40:17,360
discarded severely okay so we're gonna

00:40:14,480 --> 00:40:18,350
write one such functions you know in a

00:40:17,360 --> 00:40:19,850
language like this it would have been

00:40:18,350 --> 00:40:22,610
nice if things like your reflexive was

00:40:19,850 --> 00:40:24,110
provided but it was not okay so I'm so

00:40:22,610 --> 00:40:27,320
we're gonna walk through it so function

00:40:24,110 --> 00:40:28,790
returns bool that's its name the braces

00:40:27,320 --> 00:40:31,040
is the arguments that's the name of the

00:40:28,790 --> 00:40:33,830
argument well what is it but that's its

00:40:31,040 --> 00:40:36,110
type it has an arrow in here meaning its

00:40:33,830 --> 00:40:38,450
type is a relation and it's gonna be

00:40:36,110 --> 00:40:40,670
constrained to it can point from

00:40:38,450 --> 00:40:42,340
anything to anything okay so that's not

00:40:40,670 --> 00:40:46,520
very constraint but you can constrain it

00:40:42,340 --> 00:40:48,590
okay my predicate is true if the thing

00:40:46,520 --> 00:40:51,500
on the right is an empty set and I'm

00:40:48,590 --> 00:40:53,240
gonna form this set by taking the self

00:40:51,500 --> 00:40:54,830
relation which is a special relation

00:40:53,240 --> 00:40:57,710
where every note only points to itself

00:40:54,830 --> 00:41:00,710
and I am going to intersect it with the

00:40:57,710 --> 00:41:03,320
relation I got going in there reflects

00:41:00,710 --> 00:41:07,010
it what's a solicitor

00:41:03,320 --> 00:41:09,920
while a stasek Lissa T is the e reflect

00:41:07,010 --> 00:41:11,660
the e reflexivity of the transitive

00:41:09,920 --> 00:41:13,400
closure of a relation so I'm gonna use a

00:41:11,660 --> 00:41:15,080
transitive closure operator I take a

00:41:13,400 --> 00:41:17,330
relation transitive the close

00:41:15,080 --> 00:41:20,150
give it to her reflexive and then I'm

00:41:17,330 --> 00:41:22,220
gonna say you know what's a fact program

00:41:20,150 --> 00:41:23,780
order doesn't go in loops in these

00:41:22,220 --> 00:41:26,420
things because this is the post

00:41:23,780 --> 00:41:28,610
execution instructions not your original

00:41:26,420 --> 00:41:30,740
program okay so if you had a loop in

00:41:28,610 --> 00:41:33,170
your program this graph considers the

00:41:30,740 --> 00:41:36,080
actual steps taken and the steps taken

00:41:33,170 --> 00:41:39,740
don't are not causally loopy okay

00:41:36,080 --> 00:41:40,940
alright and so we're gonna say only

00:41:39,740 --> 00:41:42,890
graphs where this is true can be

00:41:40,940 --> 00:41:47,960
considered okay

00:41:42,890 --> 00:41:51,350
now I used I used a name earlier a name

00:41:47,960 --> 00:41:54,200
in alloy the name right or the name

00:41:51,350 --> 00:41:57,110
operation is a set but obviously you

00:41:54,200 --> 00:41:58,610
have like for all and for some so we're

00:41:57,110 --> 00:42:01,880
gonna have one more fact here

00:41:58,610 --> 00:42:06,800
before we run this fact is gonna say for

00:42:01,880 --> 00:42:10,270
all name is a member of Reid so for all

00:42:06,800 --> 00:42:12,410
our that is in reads it is true that

00:42:10,270 --> 00:42:14,090
some statement that something that can

00:42:12,410 --> 00:42:18,010
be true or yeah so the thing that can be

00:42:14,090 --> 00:42:20,510
true is we're gonna say this our

00:42:18,010 --> 00:42:22,750
composition now we're gonna stick a

00:42:20,510 --> 00:42:25,580
relation here let me say from this are

00:42:22,750 --> 00:42:29,690
some relation that's that's the dot some

00:42:25,580 --> 00:42:31,730
relation reverse of read from only

00:42:29,690 --> 00:42:33,800
points to one thing what did I just say

00:42:31,730 --> 00:42:36,440
I said reads only read from one right I

00:42:33,800 --> 00:42:38,750
can't have in an atomic memory model I

00:42:36,440 --> 00:42:41,830
can't have a read pull from two writes I

00:42:38,750 --> 00:42:43,820
read from one specific right okay and

00:42:41,830 --> 00:42:45,470
this whole thing is the thing that can

00:42:43,820 --> 00:42:49,010
be true and we said it's a fact so it's

00:42:45,470 --> 00:42:50,690
true alright so how do we run things

00:42:49,010 --> 00:42:52,850
well we are gonna have a run statement

00:42:50,690 --> 00:42:54,170
we can put a constraint in there or we

00:42:52,850 --> 00:42:56,120
can run unconstrained and then we're

00:42:54,170 --> 00:42:58,490
given an arity and now we're gonna run

00:42:56,120 --> 00:43:00,560
and this is what I Lou it looks like you

00:42:58,490 --> 00:43:01,880
run it this is the code that I wrote a

00:43:00,560 --> 00:43:04,520
few minutes ago this is the same code

00:43:01,880 --> 00:43:07,730
from the slides okay and we're gonna

00:43:04,520 --> 00:43:10,190
click that execute button when we click

00:43:07,730 --> 00:43:12,590
execute the solver will go out and it

00:43:10,190 --> 00:43:15,700
will find all valid solutions to this

00:43:12,590 --> 00:43:19,580
set of facts in the set of signatures

00:43:15,700 --> 00:43:22,460
it'll say instance found would click on

00:43:19,580 --> 00:43:26,420
that and now we get a viewer that's

00:43:22,460 --> 00:43:29,600
built in this is so friendly you guys it

00:43:26,420 --> 00:43:31,040
has its own graph visualizer that comes

00:43:29,600 --> 00:43:32,420
with it and you don't need to learn how

00:43:31,040 --> 00:43:35,450
to like output the graphs and put them

00:43:32,420 --> 00:43:37,220
through dot or whatever right so we got

00:43:35,450 --> 00:43:39,320
the first thing that looks really good I

00:43:37,220 --> 00:43:41,210
have a right I have two reasons program

00:43:39,320 --> 00:43:42,140
order and one of the reasons from the

00:43:41,210 --> 00:43:45,890
right legit

00:43:42,140 --> 00:43:48,200
I click Next and oh I guess we didn't

00:43:45,890 --> 00:43:52,340
constrain empty graphs I guess an empty

00:43:48,200 --> 00:43:53,660
graph is a valid execution okay um crap

00:43:52,340 --> 00:43:55,430
we're reading from the future here I

00:43:53,660 --> 00:43:56,450
said earlier when we had litmus test

00:43:55,430 --> 00:43:57,920
that I don't like reading from the

00:43:56,450 --> 00:43:59,530
future but we just did that okay we're

00:43:57,920 --> 00:44:01,910
gonna need to work on that and then

00:43:59,530 --> 00:44:05,900
we've got an operation here that's

00:44:01,910 --> 00:44:08,090
neither read nor write I didn't mean for

00:44:05,900 --> 00:44:10,310
that to be about it okay so we're gonna

00:44:08,090 --> 00:44:11,630
add a couple more constraints one of

00:44:10,310 --> 00:44:12,440
them is we're gonna say that sig is that

00:44:11,630 --> 00:44:15,890
strap

00:44:12,440 --> 00:44:17,240
you never instantiate operation on its

00:44:15,890 --> 00:44:20,450
own you instantiate only things that

00:44:17,240 --> 00:44:22,549
extend operation and also we're gonna

00:44:20,450 --> 00:44:24,019
say there's always some operation so we

00:44:22,549 --> 00:44:26,000
don't get empty graphs and we don't

00:44:24,019 --> 00:44:30,559
graphs that contain operations that are

00:44:26,000 --> 00:44:32,059
not writes or reads nice next thing read

00:44:30,559 --> 00:44:34,160
from the future you see there's a read

00:44:32,059 --> 00:44:36,019
program order program order and yet we

00:44:34,160 --> 00:44:38,089
read from the second right that's not

00:44:36,019 --> 00:44:40,400
cool well we're gonna say you know what

00:44:38,089 --> 00:44:44,450
we said earlier what's a cyclic is

00:44:40,400 --> 00:44:46,910
program order but what we meant is

00:44:44,450 --> 00:44:48,980
what's a cyclic is program order n reads

00:44:46,910 --> 00:44:50,599
from Union together so that's the plus

00:44:48,980 --> 00:44:52,880
I'm gonna Union program order and reads

00:44:50,599 --> 00:44:54,859
from if you remember that definition of

00:44:52,880 --> 00:44:56,509
sequential consistency from the other

00:44:54,859 --> 00:45:01,490
slide you see we're gonna kind of be

00:44:56,509 --> 00:45:04,640
building towards that okay okay this one

00:45:01,490 --> 00:45:07,009
is program order has a join in it read

00:45:04,640 --> 00:45:08,480
is program order after these two rights

00:45:07,009 --> 00:45:10,819
but the two rights are not related in

00:45:08,480 --> 00:45:12,920
program order for our memory model we're

00:45:10,819 --> 00:45:14,450
gonna say that that's not legit so we

00:45:12,920 --> 00:45:17,509
want to stomp on that and we're gonna

00:45:14,450 --> 00:45:20,539
say if I take any program order edge and

00:45:17,509 --> 00:45:23,420
I sequence it with another program order

00:45:20,539 --> 00:45:24,440
edge that's reversed I always come back

00:45:23,420 --> 00:45:27,829
where I started

00:45:24,440 --> 00:45:30,529
okay so I follow one program order edge

00:45:27,829 --> 00:45:32,119
now here I'm gonna fall over a reverse

00:45:30,529 --> 00:45:34,160
program order edge which could either be

00:45:32,119 --> 00:45:36,230
the same one I just took or this one

00:45:34,160 --> 00:45:38,420
well if it's the same one I just took

00:45:36,230 --> 00:45:40,940
then I end up in either I end up back

00:45:38,420 --> 00:45:42,559
where I started which is what I want if

00:45:40,940 --> 00:45:44,750
I think the other one I don't end up

00:45:42,559 --> 00:45:46,579
where I started so we're gonna ban any

00:45:44,750 --> 00:45:48,019
time that you follow a program order in

00:45:46,579 --> 00:45:51,519
the reverse program order if you don't

00:45:48,019 --> 00:45:51,519
end up at the same place that's been

00:45:52,000 --> 00:46:01,430
okay now we have a different issue in

00:45:56,930 --> 00:46:04,579
this issue I have a right which is

00:46:01,430 --> 00:46:07,759
overwritten but my read reads the old

00:46:04,579 --> 00:46:10,150
value I don't like that but I didn't put

00:46:07,759 --> 00:46:13,069
a notion of overwriting remember that

00:46:10,150 --> 00:46:14,299
co-relation from before the blue Co we

00:46:13,069 --> 00:46:15,950
didn't put that in the model so now

00:46:14,299 --> 00:46:17,750
we're gonna put that in we're gonna say

00:46:15,950 --> 00:46:20,119
rights actually have another member

00:46:17,750 --> 00:46:22,640
called coherence there's zero or one

00:46:20,119 --> 00:46:25,700
right that full loads this right in

00:46:22,640 --> 00:46:26,240
coherence order we're gonna say I can

00:46:25,700 --> 00:46:29,540
find

00:46:26,240 --> 00:46:32,720
from any right to any other right I can

00:46:29,540 --> 00:46:34,430
find that in the closure of coherence so

00:46:32,720 --> 00:46:36,320
every because right now I'm doing a

00:46:34,430 --> 00:46:38,240
single address memory model I'm gonna

00:46:36,320 --> 00:46:41,210
say if I start from any given right and

00:46:38,240 --> 00:46:45,800
I follow coherence forward or backwards

00:46:41,210 --> 00:46:47,980
I can find every other way okay and now

00:46:45,800 --> 00:46:50,690
we're gonna increase what's a cyclic

00:46:47,980 --> 00:46:54,170
program order reads from and coherence

00:46:50,690 --> 00:46:57,380
is a cyclic now I can't read from rights

00:46:54,170 --> 00:47:00,440
that have been overridden okay at this

00:46:57,380 --> 00:47:02,480
point if you had pasted this code into a

00:47:00,440 --> 00:47:04,010
low E and click execute and then went

00:47:02,480 --> 00:47:05,540
next next next next next next next next

00:47:04,010 --> 00:47:07,940
in the new gig Graf Graf Graf Graf Graf

00:47:05,540 --> 00:47:12,260
Graf Graf they would all look fine okay

00:47:07,940 --> 00:47:16,700
but we said for three what if we go for

00:47:12,260 --> 00:47:18,820
four well if we go for four here's the

00:47:16,700 --> 00:47:23,839
pattern that we have we have a right

00:47:18,820 --> 00:47:27,560
it's overwritten the overwritten value

00:47:23,839 --> 00:47:31,280
is read by a read then in the same

00:47:27,560 --> 00:47:34,930
thread I read again but I again the old

00:47:31,280 --> 00:47:38,119
right and not than your right that's

00:47:34,930 --> 00:47:41,869
that is a little bit upsetting and this

00:47:38,119 --> 00:47:44,420
is where from reads comes in so we're

00:47:41,869 --> 00:47:46,580
gonna say oh actually read also has a

00:47:44,420 --> 00:47:48,530
member to prior to this it did not have

00:47:46,580 --> 00:47:50,210
a member now does it's from read and it

00:47:48,530 --> 00:47:52,310
points to a set of right it has exactly

00:47:50,210 --> 00:47:54,530
the definition that I said earlier from

00:47:52,310 --> 00:47:56,330
reads as equal literally I am NOT giving

00:47:54,530 --> 00:47:59,270
Holloway it constraint I'm from reads

00:47:56,330 --> 00:48:01,760
I'm telling it what firm reads is it is

00:47:59,270 --> 00:48:03,230
equal to you chase my reads from

00:48:01,760 --> 00:48:07,609
backward and then you chase down

00:48:03,230 --> 00:48:09,349
coherence okay and now you say a cyclic

00:48:07,609 --> 00:48:12,790
program order reads from coherence from

00:48:09,349 --> 00:48:16,220
reads and that is sequential consistency

00:48:12,790 --> 00:48:17,599
okay so now we fix the issue now if you

00:48:16,220 --> 00:48:19,460
were to take this and you ran it for

00:48:17,599 --> 00:48:22,660
four four five four six four seven and

00:48:19,460 --> 00:48:26,119
you like live through clicking next

00:48:22,660 --> 00:48:29,300
because n permutation is creates large

00:48:26,119 --> 00:48:31,460
sets um you would find that now we're

00:48:29,300 --> 00:48:34,970
good for any number of instructions but

00:48:31,460 --> 00:48:36,109
we're still converts to only a catering

00:48:34,970 --> 00:48:37,820
to programs that have a single address

00:48:36,109 --> 00:48:39,950
so now we're gonna teach it

00:48:37,820 --> 00:48:41,900
oh and that by the way that memory model

00:48:39,950 --> 00:48:44,120
is the memory model of a program

00:48:41,900 --> 00:48:48,230
comprising and only one variable and

00:48:44,120 --> 00:48:49,610
it's a student ami okay we're going to

00:48:48,230 --> 00:48:51,350
teach it about multiple addresses we're

00:48:49,610 --> 00:48:53,780
gonna do this fast

00:48:51,350 --> 00:48:55,430
we created a sig that's an address we

00:48:53,780 --> 00:48:58,070
say that operations are related to an

00:48:55,430 --> 00:49:01,610
address exactly one address we're gonna

00:48:58,070 --> 00:49:03,740
say that for every address there's at

00:49:01,610 --> 00:49:06,110
least one write to it this is what this

00:49:03,740 --> 00:49:08,330
constraint here says it says for there's

00:49:06,110 --> 00:49:09,140
some from this address and you chase a

00:49:08,330 --> 00:49:12,110
door backwards

00:49:09,140 --> 00:49:13,490
it ends in a write and you also say

00:49:12,110 --> 00:49:14,570
there's always some address I'm not

00:49:13,490 --> 00:49:18,530
interested in programs that don't have

00:49:14,570 --> 00:49:22,010
any addresses and we're gonna say rates

00:49:18,530 --> 00:49:24,290
from and coherence are constrained to be

00:49:22,010 --> 00:49:26,720
relatable through address okay so I

00:49:24,290 --> 00:49:30,260
cannot read if I'm a read of X I can't

00:49:26,720 --> 00:49:32,270
read from Y in order for for a read to

00:49:30,260 --> 00:49:33,950
be connected to a write it needs to be

00:49:32,270 --> 00:49:36,380
possible to go from the read to the

00:49:33,950 --> 00:49:41,900
right by bouncing off the address

00:49:36,380 --> 00:49:43,640
relation okay and then finally my when I

00:49:41,900 --> 00:49:46,490
said earlier that all rights are

00:49:43,640 --> 00:49:48,320
reachable intransitive coherence when

00:49:46,490 --> 00:49:50,660
they're related by address of course I

00:49:48,320 --> 00:49:54,650
know her right to X doesn't overwrite a

00:49:50,660 --> 00:49:56,360
right why okay well now we have

00:49:54,650 --> 00:49:58,570
sequential consistency if you were to

00:49:56,360 --> 00:50:03,200
take all of this and paste it into alloy

00:49:58,570 --> 00:50:05,690
you would have a model of sequential

00:50:03,200 --> 00:50:08,900
consistency that you can throw test

00:50:05,690 --> 00:50:11,150
graphs at and ask for proofs and check

00:50:08,900 --> 00:50:12,440
if the patterns are as you understand

00:50:11,150 --> 00:50:14,510
them to be it is a complete it's

00:50:12,440 --> 00:50:17,450
complete model it's a complete mob of SC

00:50:14,510 --> 00:50:21,800
okay all right let's view more edit to

00:50:17,450 --> 00:50:23,810
get px you know it's a lot of text here

00:50:21,800 --> 00:50:26,890
but it's actually not that much the the

00:50:23,810 --> 00:50:29,600
Nvidia model ends up being a 180 lines

00:50:26,890 --> 00:50:30,890
you know think about 180 lines of C++

00:50:29,600 --> 00:50:33,710
like you don't write a major application

00:50:30,890 --> 00:50:38,090
with that but I wrote a major memory

00:50:33,710 --> 00:50:40,910
model in 180 lines and it's still

00:50:38,090 --> 00:50:44,270
relatively easy to use so for instance I

00:50:40,910 --> 00:50:46,190
can ask run PTX mmm is true so that's my

00:50:44,270 --> 00:50:49,880
memory model is true Ron ptex mmm and

00:50:46,190 --> 00:50:52,290
not irreflexive this chain here that

00:50:49,880 --> 00:50:55,290
chain is the

00:50:52,290 --> 00:50:58,710
Chane that describes a relaxed MP

00:50:55,290 --> 00:51:00,960
execution okay so here you can say

00:50:58,710 --> 00:51:04,590
what's a valid relaxed execution of MP

00:51:00,960 --> 00:51:06,150
on-on-on p-tex and if you were to to

00:51:04,590 --> 00:51:08,160
scrutinize it a little bit you'll see

00:51:06,150 --> 00:51:10,350
there's some acquires in the thread that

00:51:08,160 --> 00:51:13,830
reads but the thread that writes does

00:51:10,350 --> 00:51:15,480
not have a release or a fence and so

00:51:13,830 --> 00:51:18,690
that's why the relaxed execution is

00:51:15,480 --> 00:51:20,100
allowed in this case okay and I use the

00:51:18,690 --> 00:51:21,390
team to hang up the graph because the

00:51:20,100 --> 00:51:28,470
graph would be enormous with all the

00:51:21,390 --> 00:51:29,790
various relations all right 2016 in 2016

00:51:28,470 --> 00:51:31,860
we learned that c plus plus 11 is

00:51:29,790 --> 00:51:33,870
unimplemented ball which is a bit of a

00:51:31,860 --> 00:51:36,030
big deal there's a perplexing counter

00:51:33,870 --> 00:51:39,630
example that's found we run something

00:51:36,030 --> 00:51:41,700
like a check that Pete xmm implies C++

00:51:39,630 --> 00:51:44,730
mmm so any an execution that's valid in

00:51:41,700 --> 00:51:47,430
in context is also valid in C++ for some

00:51:44,730 --> 00:51:50,430
eight and eight or nine and this check

00:51:47,430 --> 00:51:52,860
failed but when we dove into it we

00:51:50,430 --> 00:51:55,020
discovered actually the manner in which

00:51:52,860 --> 00:51:57,450
in fails is common mode with IBM Power

00:51:55,020 --> 00:52:00,380
which is concerning because as far as we

00:51:57,450 --> 00:52:02,490
knew this actually was implementable and

00:52:00,380 --> 00:52:05,790
other groups actually find the same

00:52:02,490 --> 00:52:06,990
thing elsewhere so here is a very simple

00:52:05,790 --> 00:52:09,330
program they will not make your head

00:52:06,990 --> 00:52:14,070
hurt at all this program is not allowed

00:52:09,330 --> 00:52:16,410
to execute without asserting and that's

00:52:14,070 --> 00:52:18,360
because it is where the asserts are I

00:52:16,410 --> 00:52:21,600
check the values seen we are not allowed

00:52:18,360 --> 00:52:23,190
to see these values all that cannot see

00:52:21,600 --> 00:52:24,780
all of these values all at once but

00:52:23,190 --> 00:52:27,750
obviously that makes everybody's head

00:52:24,780 --> 00:52:31,320
hurt so what we do is we take this and

00:52:27,750 --> 00:52:33,390
we stick it in a tool called CPP mmm CPP

00:52:31,320 --> 00:52:36,000
mmm is this website you're right in this

00:52:33,390 --> 00:52:39,800
modified C++ syntax you put it in there

00:52:36,000 --> 00:52:42,390
and you say run and it comes back

00:52:39,800 --> 00:52:46,170
telling you whether this execution is a

00:52:42,390 --> 00:52:50,130
valid C++ execution or not here we did

00:52:46,170 --> 00:52:53,190
that plug it in run says no the the the

00:52:50,130 --> 00:52:56,970
values that are in this program are not

00:52:53,190 --> 00:52:58,380
permitted to be seen all of them some

00:52:56,970 --> 00:53:00,990
subset of them yes but all of them know

00:52:58,380 --> 00:53:03,330
in a C++ execution okay so that's

00:53:00,990 --> 00:53:06,060
interesting but we're gonna

00:53:03,330 --> 00:53:07,920
transliterate it to power we're gonna go

00:53:06,060 --> 00:53:09,870
to this other website which has the

00:53:07,920 --> 00:53:11,070
compiler mappings from C++ to different

00:53:09,870 --> 00:53:14,820
processors and we're going to use the

00:53:11,070 --> 00:53:16,590
compiler mapping from C++ to power and

00:53:14,820 --> 00:53:18,660
we're gonna translate it to its

00:53:16,590 --> 00:53:21,240
equivalent power I've highlighted this

00:53:18,660 --> 00:53:23,430
in two colors the cyan part totally

00:53:21,240 --> 00:53:25,470
meaningless it does nothing that code

00:53:23,430 --> 00:53:28,230
does not constrain the power execution

00:53:25,470 --> 00:53:29,910
in any way only the yellow constrained

00:53:28,230 --> 00:53:32,250
the pout constrains the power execution

00:53:29,910 --> 00:53:35,100
but it's a relatively small test store

00:53:32,250 --> 00:53:37,440
2x lightweight fence store Y and in

00:53:35,100 --> 00:53:40,800
another thread overwrite Y heavy fence

00:53:37,440 --> 00:53:41,940
read from X you don't need to know you

00:53:40,800 --> 00:53:43,680
know the power memory model to

00:53:41,940 --> 00:53:47,490
adjudicate this one because there's a

00:53:43,680 --> 00:53:49,110
perfectly valid other website which has

00:53:47,490 --> 00:53:51,240
all the dismiss tests with the

00:53:49,110 --> 00:53:52,740
constraints for power and if we dig into

00:53:51,240 --> 00:53:57,600
this we're going to find that it missed

00:53:52,740 --> 00:54:00,180
s called R and R says that given the

00:53:57,600 --> 00:54:03,840
constraints that are here the execution

00:54:00,180 --> 00:54:06,240
is allowed sync in that PDF stands for

00:54:03,840 --> 00:54:09,390
heavyweight sync whereas lightweight

00:54:06,240 --> 00:54:11,580
sync is lightweight sync so this says if

00:54:09,390 --> 00:54:13,350
you want to forbid the cycle in are you

00:54:11,580 --> 00:54:14,910
need heavy fences on both sides but our

00:54:13,350 --> 00:54:16,260
program did not have any fences in both

00:54:14,910 --> 00:54:17,730
sides when we took the C++ and

00:54:16,260 --> 00:54:19,740
transliterated the other compiler

00:54:17,730 --> 00:54:21,270
mappings we ended up with one heavy

00:54:19,740 --> 00:54:24,390
fence and one light fence therefore this

00:54:21,270 --> 00:54:26,510
execution is allowed ok so this is a

00:54:24,390 --> 00:54:28,380
tough choice what do we do now

00:54:26,510 --> 00:54:30,570
and you know there's like what does

00:54:28,380 --> 00:54:33,630
in-video do now which is IBM do now what

00:54:30,570 --> 00:54:34,920
does the C++ kamini do now at this point

00:54:33,630 --> 00:54:36,480
we could either declare the compiler man

00:54:34,920 --> 00:54:39,270
things are invalid and then that would

00:54:36,480 --> 00:54:42,780
mean untold petabytes of compiled code

00:54:39,270 --> 00:54:46,680
must be sent to Devin all somehow how

00:54:42,780 --> 00:54:48,660
would you even achieve that or we need

00:54:46,680 --> 00:54:50,550
to make a change to see bus bus we need

00:54:48,660 --> 00:54:52,650
to see actually C++ got this wrong and

00:54:50,550 --> 00:54:54,570
that's what we ended up doing years

00:54:52,650 --> 00:54:58,350
later we adjust the C++ memory model and

00:54:54,570 --> 00:55:00,600
it's in this paper ok and because it's

00:54:58,350 --> 00:55:02,980
retroactive then then binaries are okay

00:55:00,600 --> 00:55:06,099
all right

00:55:02,980 --> 00:55:08,260
20:17 a lot happens do remember to enjoy

00:55:06,099 --> 00:55:10,030
the good times don't always be miserable

00:55:08,260 --> 00:55:12,550
I mean we're all we tend to be cynical

00:55:10,030 --> 00:55:14,170
and whatnot it's finally here the

00:55:12,550 --> 00:55:15,880
hardware we were waiting for earlier

00:55:14,170 --> 00:55:18,250
it's here

00:55:15,880 --> 00:55:20,170
there's the following is not hyperbole

00:55:18,250 --> 00:55:23,770
we made a new kind of computer what I

00:55:20,170 --> 00:55:27,310
mean by that is you know the sim TMD mem

00:55:23,770 --> 00:55:29,050
t-spin D we refreshed Sinti on its tenth

00:55:27,310 --> 00:55:31,060
birthday we gave it the ability to

00:55:29,050 --> 00:55:34,750
execute all concurrent algorithms Bar

00:55:31,060 --> 00:55:37,480
None and expressed over Atomics so make

00:55:34,750 --> 00:55:38,859
use of the memory moment but at this

00:55:37,480 --> 00:55:40,569
point we're really really really really

00:55:38,859 --> 00:55:42,369
busy you have to imagine that this made

00:55:40,569 --> 00:55:44,740
a really big splash we're really busy

00:55:42,369 --> 00:55:46,180
we're too busy for Tommy and I come here

00:55:44,740 --> 00:55:47,500
to sippy pecan and I tell about tell you

00:55:46,180 --> 00:55:51,460
guys about the Volta suppose--suppose

00:55:47,500 --> 00:55:54,250
affinity okay in 2018

00:55:51,460 --> 00:55:56,140
you know we still we still haven't had

00:55:54,250 --> 00:55:58,270
atomic you know we were too busy for

00:55:56,140 --> 00:56:02,020
that but the need for it hasn't gone

00:55:58,270 --> 00:56:05,950
away so um so this is where bottom-up

00:56:02,020 --> 00:56:08,680
leadership actually can work basically

00:56:05,950 --> 00:56:10,750
engineers looked out for each other a

00:56:08,680 --> 00:56:13,930
little bit and we realized we actually

00:56:10,750 --> 00:56:18,010
needed this to get our jobs done so

00:56:13,930 --> 00:56:22,510
we're back to side projects and we pitch

00:56:18,010 --> 00:56:25,780
a standard library a C++ standard

00:56:22,510 --> 00:56:27,099
library for CUDA to everyone who will

00:56:25,780 --> 00:56:30,460
listen to us and some people who don't

00:56:27,099 --> 00:56:32,290
want to and death text just fall in love

00:56:30,460 --> 00:56:33,940
with the idea that's our Department of

00:56:32,290 --> 00:56:37,060
people who help developers out in the

00:56:33,940 --> 00:56:39,670
field I have some quotes they loved it

00:56:37,060 --> 00:56:40,630
and one of the biggest improvements and

00:56:39,670 --> 00:56:42,369
this session

00:56:40,630 --> 00:56:45,280
essential step to move CUDA into the

00:56:42,369 --> 00:56:47,910
future and the natural way to get clean

00:56:45,280 --> 00:56:51,640
performing implementations all right

00:56:47,910 --> 00:56:53,380
this pushes it over the top I come here

00:56:51,640 --> 00:56:54,730
there's a demo at the time of the demo

00:56:53,380 --> 00:56:56,890
it wasn't actually committed work which

00:56:54,730 --> 00:57:00,609
is why it's Cynthia Cohen Cohen stood

00:56:56,890 --> 00:57:03,010
and not CUDA Cohen Cohen stood but the

00:57:00,609 --> 00:57:06,150
demo and the Deaf decks we push it over

00:57:03,010 --> 00:57:13,420
the line and now it's the committed plan

00:57:06,150 --> 00:57:16,150
all right in 2019 we learned how to

00:57:13,420 --> 00:57:17,740
update the atomic header and in a very

00:57:16,150 --> 00:57:20,339
brief wait you're gonna learn it now but

00:57:17,740 --> 00:57:23,260
probably not as much as you wish okay

00:57:20,339 --> 00:57:26,020
how is libs the x-axis to the atomic

00:57:23,260 --> 00:57:28,359
header structure so at the top level you

00:57:26,020 --> 00:57:31,510
have an atomic class and a

00:57:28,359 --> 00:57:34,569
specialization for pointer and it

00:57:31,510 --> 00:57:36,700
inherits from an atomic base which

00:57:34,569 --> 00:57:40,839
handles the integral specific

00:57:36,700 --> 00:57:42,640
specialization that in turns contains an

00:57:40,839 --> 00:57:44,710
internal abstraction layer called

00:57:42,640 --> 00:57:46,660
underbar underbar cxx atomic this is an

00:57:44,710 --> 00:57:49,329
object's astruc that's the internal

00:57:46,660 --> 00:57:52,329
abstraction layer which shims the

00:57:49,329 --> 00:57:56,170
publicly accessible objects from the

00:57:52,329 --> 00:57:58,510
internal built-ins that inherits from a

00:57:56,170 --> 00:57:59,980
couple of implementations there is a c11

00:57:58,510 --> 00:58:01,539
implementation there's a GCC

00:57:59,980 --> 00:58:03,039
implementation and it is possible for

00:58:01,539 --> 00:58:06,279
you to provide your own which we do do

00:58:03,039 --> 00:58:09,039
for CUDA and one of the changes that we

00:58:06,279 --> 00:58:11,829
up streamed to the cxx is we added an

00:58:09,039 --> 00:58:15,220
intermediate layer which allows Lipsy xx

00:58:11,829 --> 00:58:17,559
to handle the non lock-free Atomics

00:58:15,220 --> 00:58:19,299
without any compiler help if the

00:58:17,559 --> 00:58:20,920
compiler doesn't support the non

00:58:19,299 --> 00:58:23,260
lock-free Atomics and it only supports

00:58:20,920 --> 00:58:25,059
the lock-free ones then Lipsey xx will

00:58:23,260 --> 00:58:27,819
create an object with a built-in lock

00:58:25,059 --> 00:58:29,829
using only the built-in ones this was

00:58:27,819 --> 00:58:31,599
not supported in nipsey xx before and

00:58:29,829 --> 00:58:33,640
it's a feature CUDA needed so we wrote

00:58:31,599 --> 00:58:34,839
it and we gave it to the community who

00:58:33,640 --> 00:58:38,770
could use it in free-standing

00:58:34,839 --> 00:58:43,210
implementations in the future ok the

00:58:38,770 --> 00:58:45,520
CUDA enablement part we enabled this

00:58:43,210 --> 00:58:48,309
built-in mode and we put it in the right

00:58:45,520 --> 00:58:51,369
namespace we supply our shim layer our

00:58:48,309 --> 00:58:53,710
ashame layer starts from that's the xx

00:58:51,369 --> 00:58:55,779
atomic base we have two versions very

00:58:53,710 --> 00:58:57,309
small objects and normal objects we

00:58:55,779 --> 00:58:59,410
don't have one or two byte Atomics on

00:58:57,309 --> 00:59:02,410
GPUs so the very small objects need to

00:58:59,410 --> 00:59:04,750
be padded up we do that there and then

00:59:02,410 --> 00:59:07,480
we may have some alignment issues so we

00:59:04,750 --> 00:59:11,079
fix that with another alignment wrapper

00:59:07,480 --> 00:59:13,869
and on the host side we just send all

00:59:11,079 --> 00:59:16,660
this code to the hosts stood atomic

00:59:13,869 --> 00:59:18,520
implementation behind behind the

00:59:16,660 --> 00:59:19,660
abstraction layer you know and then

00:59:18,520 --> 00:59:21,490
there's a small matter of like providing

00:59:19,660 --> 00:59:24,819
100 built-ins

00:59:21,490 --> 00:59:27,789
which all kind of look like this there's

00:59:24,819 --> 00:59:29,079
a bunch of inline Azzam and then people

00:59:27,789 --> 00:59:30,190
who've written some of this code in

00:59:29,079 --> 00:59:31,720
standard libraries will

00:59:30,190 --> 00:59:34,090
you end up switching on ma'am order

00:59:31,720 --> 00:59:35,650
which is really annoying and then

00:59:34,090 --> 00:59:38,470
there's an implementation for Volta and

00:59:35,650 --> 00:59:40,870
an implementation for Pascal there's

00:59:38,470 --> 00:59:42,570
this scope tag dinging okay well that's

00:59:40,870 --> 00:59:45,490
part of our non-standard extensions

00:59:42,570 --> 00:59:47,920
scopes are added the type hierarchy is

00:59:45,490 --> 00:59:50,770
enhanced with scopes and we pass that in

00:59:47,920 --> 00:59:53,380
through the type system so that the way

00:59:50,770 --> 00:59:57,280
you would use it in CUDA is like this a

00:59:53,380 --> 00:59:58,810
CUDA atomic of T of scope device okay

00:59:57,280 --> 01:00:01,270
now you might say but wait what if I

00:59:58,810 --> 01:00:04,810
want to miss mix scopes that is fully

01:00:01,270 --> 01:00:07,930
supported it's fully supported but not

01:00:04,810 --> 01:00:10,780
in the C++ layer because the odds of

01:00:07,930 --> 01:00:13,420
getting this wrong or very high and

01:00:10,780 --> 01:00:16,000
we're going to help you write fewer bugs

01:00:13,420 --> 01:00:18,190
so if you really really really need to

01:00:16,000 --> 01:00:20,170
mix then you can use the inline Azzam

01:00:18,190 --> 01:00:22,960
same as you could before this change

01:00:20,170 --> 01:00:24,820
okay and we have some extended atomic

01:00:22,960 --> 01:00:27,780
operations like fetch min and fetch max

01:00:24,820 --> 01:00:32,710
which maybe you'll will bring to s t1

01:00:27,780 --> 01:00:36,700
okay if you even touch me for like four

01:00:32,710 --> 01:00:40,540
more minutes let me tell you about that

01:00:36,700 --> 01:00:43,090
tenth year it's been nine so far if you

01:00:40,540 --> 01:00:46,000
were keeping track that tenth year it's

01:00:43,090 --> 01:00:48,730
not really me it's you okay the tenth

01:00:46,000 --> 01:00:50,680
year is now you need to adopt this you

01:00:48,730 --> 01:00:52,450
need to move off of volatile in CUDA

01:00:50,680 --> 01:00:53,710
code and to still atomic

01:00:52,450 --> 01:00:57,010
so let's give you just a couple of

01:00:53,710 --> 01:00:59,050
examples so before you would notionally

01:00:57,010 --> 01:01:01,210
write code like this now you'd use a

01:00:59,050 --> 01:01:02,830
volatile for your flag and then you'd

01:01:01,210 --> 01:01:04,360
have a separate fence but really it's

01:01:02,830 --> 01:01:06,400
more efficient if you confuse the fence

01:01:04,360 --> 01:01:07,930
with the flag operation and then we've

01:01:06,400 --> 01:01:11,560
got these atomic operations which ask

01:01:07,930 --> 01:01:13,240
you to cast thing off volatile and you

01:01:11,560 --> 01:01:15,580
end up using an atomic instead of a

01:01:13,240 --> 01:01:17,080
store now it's it's them if you do them

01:01:15,580 --> 01:01:20,080
if you don't because if you use this

01:01:17,080 --> 01:01:21,310
store then now it's you be in C++ you

01:01:20,080 --> 01:01:23,590
know you can't have data races on

01:01:21,310 --> 01:01:26,770
volatile and C++ okay so that's that's

01:01:23,590 --> 01:01:30,910
all rather crafty now what can you write

01:01:26,770 --> 01:01:33,070
now you can just use atomic and atomic

01:01:30,910 --> 01:01:35,740
operator equal or you could use store

01:01:33,070 --> 01:01:37,330
with memory or to release or in the c++

01:01:35,740 --> 01:01:39,760
20 implementation that will have later

01:01:37,330 --> 01:01:43,420
you could use that in the notify

01:01:39,760 --> 01:01:43,759
operation okay on the polling side the

01:01:43,420 --> 01:01:46,279
river

01:01:43,759 --> 01:01:47,779
happens all the same but the reverse now

01:01:46,279 --> 01:01:50,359
on the polling side there's a special

01:01:47,779 --> 01:01:52,939
gotcha that I have to tell you a lot of

01:01:50,359 --> 01:01:53,539
people have written this code and it's

01:01:52,939 --> 01:01:56,119
not great

01:01:53,539 --> 01:01:57,889
sometimes people omit the fence they

01:01:56,119 --> 01:01:59,929
rely on dependency order and they mark

01:01:57,889 --> 01:02:02,569
their data volatile okay that is just

01:01:59,929 --> 01:02:05,749
wrong in so many more ways and you fix

01:02:02,569 --> 01:02:07,880
all of that by switching to sturdy Tomic

01:02:05,749 --> 01:02:09,679
alright so you you can write it like

01:02:07,880 --> 01:02:13,399
this or you could write it like this

01:02:09,679 --> 01:02:15,649
with memory or to require or in C++ 20

01:02:13,399 --> 01:02:19,219
coming up later on you can use the

01:02:15,649 --> 01:02:21,649
weight functions on the GPU as well all

01:02:19,219 --> 01:02:23,749
right one special thing that we took

01:02:21,649 --> 01:02:25,909
care of for you is the whole host device

01:02:23,749 --> 01:02:27,380
integration imagine writing a host

01:02:25,909 --> 01:02:29,269
device function that needs to do some

01:02:27,380 --> 01:02:31,579
atomic update well on the device side

01:02:29,269 --> 01:02:32,809
you can use the atomic operation but

01:02:31,579 --> 01:02:34,099
with you right on the host side on the

01:02:32,809 --> 01:02:35,809
host side you're supposed to use to the

01:02:34,099 --> 01:02:37,789
timing that's what you're supposed to

01:02:35,809 --> 01:02:39,019
use but you're not using it right now so

01:02:37,789 --> 01:02:41,809
you're gonna use a whole bunch of inline

01:02:39,019 --> 01:02:42,679
azzam um you know I think I think it

01:02:41,809 --> 01:02:44,689
would be a rough to go through a code

01:02:42,679 --> 01:02:48,309
review for that well would you you down

01:02:44,689 --> 01:02:50,299
you just use atomic because it works

01:02:48,309 --> 01:02:52,759
okay all right

01:02:50,299 --> 01:02:55,279
there'll be more things coming to lib

01:02:52,759 --> 01:02:58,389
qu+ bus in the future I look forward to

01:02:55,279 --> 01:03:04,130
telling you more about it but not now

01:02:58,389 --> 01:03:06,499
in conclusion it's kind of mind-boggling

01:03:04,130 --> 01:03:07,999
that it took 10 years to do this but I

01:03:06,499 --> 01:03:09,529
think you can see that there was an

01:03:07,999 --> 01:03:11,839
enormous amount of work that needed to

01:03:09,529 --> 01:03:15,259
happen it's not just the work is that we

01:03:11,839 --> 01:03:17,659
didn't even know what work we needed to

01:03:15,259 --> 01:03:19,579
do when we started you know we we were

01:03:17,659 --> 01:03:21,259
interested in making clarifications they

01:03:19,579 --> 01:03:22,639
were well intentioned you know to make a

01:03:21,259 --> 01:03:24,979
nice theme programming model for our

01:03:22,639 --> 01:03:27,739
users but we learned so much along the

01:03:24,979 --> 01:03:29,959
way that almost everything we ended up

01:03:27,739 --> 01:03:32,779
doing we didn't know about at the

01:03:29,959 --> 01:03:34,489
beginning and we could have failed every

01:03:32,779 --> 01:03:36,349
single year just make no mistake about

01:03:34,489 --> 01:03:39,109
this there's nothing automatic about

01:03:36,349 --> 01:03:40,849
doing work like this every single year

01:03:39,109 --> 01:03:43,459
we could have turned away from the cause

01:03:40,849 --> 01:03:44,869
every single year we could have made a

01:03:43,459 --> 01:03:49,609
memory model that was incompatible or

01:03:44,869 --> 01:03:52,099
failed to do the work but like I said we

01:03:49,609 --> 01:03:55,009
still need your help we need you to move

01:03:52,099 --> 01:03:56,000
off the volatile in on two atomic going

01:03:55,009 --> 01:04:17,200
forward

01:03:56,000 --> 01:04:17,200
and that's it for my story any questions

01:04:21,820 --> 01:04:29,180
with the mobile CUDA atomic operations

01:04:25,640 --> 01:04:31,520
there are type limits depending on the

01:04:29,180 --> 01:04:35,930
hardware architecture yeah how is this

01:04:31,520 --> 01:04:38,090
handled we are not providing this far

01:04:35,930 --> 01:04:40,520
back in time we're providing this for

01:04:38,090 --> 01:04:43,040
Volta entering primarily and we also are

01:04:40,520 --> 01:04:44,270
going to support Pascal although as you

01:04:43,040 --> 01:04:45,859
could see in the code the Pascal

01:04:44,270 --> 01:04:51,310
implementation has sort of a different

01:04:45,859 --> 01:04:51,310
quality to it than the Volta entering so

01:04:51,730 --> 01:04:58,520
really the Pascal support is provided to

01:04:54,470 --> 01:05:02,480
help you port but we are not going to

01:04:58,520 --> 01:05:05,150
support Maxwell or Kepler okay thanks if

01:05:02,480 --> 01:05:08,030
you colleagues working on your IDs that

01:05:05,150 --> 01:05:09,730
you provide considered providing

01:05:08,030 --> 01:05:15,170
automatic support for transformation

01:05:09,730 --> 01:05:17,300
from volatile - tell me oh that's that's

01:05:15,170 --> 01:05:20,060
a wonderful question I don't think we

01:05:17,300 --> 01:05:22,310
have ever discussed that yeah you might

01:05:20,060 --> 01:05:24,849
know someone who can do things like that

01:05:22,310 --> 01:05:24,849
yes

01:05:33,050 --> 01:05:40,179
well thank you everyone

01:05:35,550 --> 01:05:40,179

YouTube URL: https://www.youtube.com/watch?v=VogqOscJYvk


