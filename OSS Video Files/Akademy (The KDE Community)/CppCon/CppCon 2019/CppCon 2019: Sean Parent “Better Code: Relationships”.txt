Title: CppCon 2019: Sean Parent “Better Code: Relationships”
Publication date: 2019-09-20
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Computer scientists are bad at relationships. Nearly every program crash is rooted in a mismanaged relationship, yet we spend most of our time discussing types and functions and not the relationships connecting them together. This talk looks at common ways data and code are connected in an application, how those relationships are typically represented, and the problems caused by the use, and misuse of these paradigms. Then we'll look at ways to model these relationships in C++ and use them to build correct applications.
— 
Sean Parent
Adobe / Photoshop
Sr. Principal Scientist
San Jose, CA

Sean Parent is a principal scientist and software architect for Adobe’s digital imaging group. Sean has been at Adobe since 1993 when he joined as a senior engineer working on Photoshop and later managed Adobe’s Software Technology Lab. In 2009 Sean spent a year at Google working on Chrome OS before returning to Adobe to work on mobile and web technology. From 1988 through 1993 Sean worked at Apple, where he was part of the system software team that developed the technologies allowing Apple’s successful transition to PowerPC.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:10,820 --> 00:00:17,030
I told you earlier that we have to see

00:00:14,809 --> 00:00:20,779
pecan attendees that are actually in

00:00:17,030 --> 00:00:24,500
high school I introduced you earlier to

00:00:20,779 --> 00:00:26,810
April and now I've got up here Zoe

00:00:24,500 --> 00:00:28,580
Carver who is a high school kid he's

00:00:26,810 --> 00:00:30,320
tall enough to be out of high school but

00:00:28,580 --> 00:00:45,199
he's but he's still in high school

00:00:30,320 --> 00:00:47,629
right hello so you really do C++ yeah

00:00:45,199 --> 00:00:58,280
well I've made a few commits to Lib C++

00:00:47,629 --> 00:01:03,260
I think you must go to a different high

00:00:58,280 --> 00:01:05,330
school than I did so have you heard of

00:01:03,260 --> 00:01:08,180
our keynote speaker today yeah

00:01:05,330 --> 00:01:11,830
I was actually lucky enough to get to

00:01:08,180 --> 00:01:14,930
talk with Sean earlier this week and

00:01:11,830 --> 00:01:18,170
ever since I've been looking forward to

00:01:14,930 --> 00:01:19,850
this talk I am absolutely certain that

00:01:18,170 --> 00:01:22,850
every single one of you will learn

00:01:19,850 --> 00:01:25,650
something after this talk so will you

00:01:22,850 --> 00:01:37,900
please help me welcome Sean to the stage

00:01:25,650 --> 00:01:41,900
[Applause]

00:01:37,900 --> 00:01:44,360
Hey good morning so I'm gonna apologize

00:01:41,900 --> 00:01:46,100
up front for drinking some water but

00:01:44,360 --> 00:01:52,370
I've been talking all week and my voice

00:01:46,100 --> 00:01:54,140
is kind of shot it's been pretty amazing

00:01:52,370 --> 00:01:56,270
at this conference and to see this

00:01:54,140 --> 00:01:59,690
conference grow over the years like six

00:01:56,270 --> 00:02:01,940
years ago I gave this talk where my

00:01:59,690 --> 00:02:03,560
tagline was that's a rotate and it

00:02:01,940 --> 00:02:05,270
wasn't intended to be something that

00:02:03,560 --> 00:02:08,920
would spread virally and not something

00:02:05,270 --> 00:02:13,090
that would last for six years that's

00:02:08,920 --> 00:02:13,090
that is is truly amazing

00:02:13,850 --> 00:02:19,790
so I'm a senior principal scientist a

00:02:16,820 --> 00:02:21,860
very very high title kind of

00:02:19,790 --> 00:02:24,830
embarrassing working on the the

00:02:21,860 --> 00:02:27,560
Photoshop team at Adobe most of what I

00:02:24,830 --> 00:02:29,390
do on at Adobe is not actually graphics

00:02:27,560 --> 00:02:33,190
but it's it's worrying about the

00:02:29,390 --> 00:02:36,230
architecture of the application and

00:02:33,190 --> 00:02:39,950
that's somewhat what this topic is about

00:02:36,230 --> 00:02:42,910
is the notion of relationships right of

00:02:39,950 --> 00:02:45,470
how things interconnect and this is a

00:02:42,910 --> 00:02:47,690
part of a series of talks that I've been

00:02:45,470 --> 00:02:50,480
giving that started six years ago with

00:02:47,690 --> 00:02:53,720
that C++ seasoning talk that I titled

00:02:50,480 --> 00:02:58,570
now the better code series of talks and

00:02:53,720 --> 00:03:01,820
all of my better code talks have a goal

00:02:58,570 --> 00:03:05,660
so if you haven't heard my talks

00:03:01,820 --> 00:03:09,170
I picked the word goal very carefully

00:03:05,660 --> 00:03:10,190
these are not rules these are not

00:03:09,170 --> 00:03:14,330
guidelines

00:03:10,190 --> 00:03:16,130
I don't want code to not be to be

00:03:14,330 --> 00:03:18,320
blocked from going in because you're

00:03:16,130 --> 00:03:19,940
like hey Sean said don't do this and you

00:03:18,320 --> 00:03:22,280
did this because these can be in

00:03:19,940 --> 00:03:25,010
practice very difficult things to

00:03:22,280 --> 00:03:27,380
achieve and so all of my goals are non

00:03:25,010 --> 00:03:30,890
prescriptive I can tell you what not to

00:03:27,380 --> 00:03:33,770
do but I can't tell you what to do but

00:03:30,890 --> 00:03:35,390
what I can say is if you actually spot

00:03:33,770 --> 00:03:37,310
this is the one rule where if you

00:03:35,390 --> 00:03:40,310
actually spot a contradiction in a code

00:03:37,310 --> 00:03:42,020
review don't let that code review don't

00:03:40,310 --> 00:03:46,640
let that code go into your project

00:03:42,020 --> 00:03:48,260
why what's a contradiction it's a bug so

00:03:46,640 --> 00:03:49,940
the clickbait

00:03:48,260 --> 00:03:55,940
for this talk would be how to write

00:03:49,940 --> 00:03:59,659
bug-free code so I'm gonna build on a

00:03:55,940 --> 00:04:01,879
quote here I heard this quote years ago

00:03:59,659 --> 00:04:03,860
and now I can't figure out where it came

00:04:01,879 --> 00:04:04,910
from and this is my own paraphrasing of

00:04:03,860 --> 00:04:07,129
it I thought it was from the movie

00:04:04,910 --> 00:04:11,060
searching for Bobby Fischer but the

00:04:07,129 --> 00:04:13,519
internet disagrees with me so a novice

00:04:11,060 --> 00:04:16,030
sees only the chess men an amateur sees

00:04:13,519 --> 00:04:19,340
the board and a master sees the game

00:04:16,030 --> 00:04:21,620
right so what do we mean by see here

00:04:19,340 --> 00:04:24,919
what is it that the master chess player

00:04:21,620 --> 00:04:26,720
sees that the novice doesn't and the

00:04:24,919 --> 00:04:30,500
answer is the master sees the

00:04:26,720 --> 00:04:32,690
relationships right and this is a

00:04:30,500 --> 00:04:36,050
problem for us because computer

00:04:32,690 --> 00:04:37,760
scientists are bad at relationships now

00:04:36,050 --> 00:04:39,410
I know my wife would agree with this

00:04:37,760 --> 00:04:40,760
statement many of you probably have

00:04:39,410 --> 00:04:42,889
partners who would agree with this

00:04:40,760 --> 00:04:47,870
statement but what I mean by this

00:04:42,889 --> 00:04:50,330
statement is that computer scientists we

00:04:47,870 --> 00:04:52,070
tend to talk a lot about types and we

00:04:50,330 --> 00:04:55,400
tend to law to talk about algorithms

00:04:52,070 --> 00:04:57,380
that might be partially my fault but we

00:04:55,400 --> 00:04:59,150
don't talk about relationships and

00:04:57,380 --> 00:05:04,250
there's this underlying fabric that

00:04:59,150 --> 00:05:05,450
knits those things together right so in

00:05:04,250 --> 00:05:07,669
this game where we're talking about

00:05:05,450 --> 00:05:12,139
relationships let's review what the

00:05:07,669 --> 00:05:14,870
pieces are right a relation in math is a

00:05:12,139 --> 00:05:18,320
set of ordered pairs mapping entities

00:05:14,870 --> 00:05:19,550
from a domain to a range it's distinct

00:05:18,320 --> 00:05:21,590
from a function and that the first

00:05:19,550 --> 00:05:24,530
entity doesn't uniquely identify the

00:05:21,590 --> 00:05:26,720
second entity a relationship is the way

00:05:24,530 --> 00:05:28,099
two entities are connected so that's

00:05:26,720 --> 00:05:32,000
what we're talking about how are things

00:05:28,099 --> 00:05:34,310
connected now relationships have

00:05:32,000 --> 00:05:36,380
properties they have cardinality which

00:05:34,310 --> 00:05:38,240
is the maximum number of times an entity

00:05:36,380 --> 00:05:40,550
can be related to another entity and

00:05:38,240 --> 00:05:42,860
they have modality which is the minimum

00:05:40,550 --> 00:05:45,470
number of times okay

00:05:42,860 --> 00:05:47,930
the diagram in here is stolen from ER

00:05:45,470 --> 00:05:50,330
diagrams entity relationship diagrams

00:05:47,930 --> 00:05:51,530
from from database theory but I'm not

00:05:50,330 --> 00:05:56,719
going to be talking about database

00:05:51,530 --> 00:05:58,750
theory today for any relationship

00:05:56,719 --> 00:06:00,919
there's a corresponding predicate a

00:05:58,750 --> 00:06:02,000
relationship that that's implied by that

00:06:00,919 --> 00:06:04,970
relations

00:06:02,000 --> 00:06:09,580
right if it's true we say the

00:06:04,970 --> 00:06:09,580
relationship is satisfied or it holds

00:06:09,850 --> 00:06:15,920
John is married to Jane is a

00:06:13,250 --> 00:06:21,710
relationship the corresponding predicate

00:06:15,920 --> 00:06:24,710
is is John married to Jane now a

00:06:21,710 --> 00:06:29,170
constraint is a relationship which must

00:06:24,710 --> 00:06:35,720
be satisfied what do we mean by must

00:06:29,170 --> 00:06:37,720
write anybody little circular here for

00:06:35,720 --> 00:06:41,900
another relationship to be satisfied

00:06:37,720 --> 00:06:43,130
right so for example the denominator

00:06:41,900 --> 00:06:46,190
must not be 0

00:06:43,130 --> 00:06:51,650
that's relationship for the result of

00:06:46,190 --> 00:06:54,230
division to be defined okay

00:06:51,650 --> 00:06:57,490
the notion of a constraint is strongly

00:06:54,230 --> 00:07:01,100
related to the relationship of

00:06:57,490 --> 00:07:05,980
implication right right this is a very

00:07:01,100 --> 00:07:08,930
basic boolean relationship a implies B

00:07:05,980 --> 00:07:11,180
this is the truth table for implication

00:07:08,930 --> 00:07:18,860
the only time the truth table is false

00:07:11,180 --> 00:07:20,540
is if we have a and B is not true so I'm

00:07:18,860 --> 00:07:22,940
going to introduce a very simple

00:07:20,540 --> 00:07:25,070
notation here for talking about

00:07:22,940 --> 00:07:27,050
relationships this is the notation that

00:07:25,070 --> 00:07:30,170
I tend to scribble on my whiteboard a

00:07:27,050 --> 00:07:32,360
lot it's incomplete you can't represent

00:07:30,170 --> 00:07:34,820
everything in this notation is not

00:07:32,360 --> 00:07:40,130
intended to be formal but it does help

00:07:34,820 --> 00:07:41,660
me convey the structure of software so

00:07:40,130 --> 00:07:43,640
entities are represented with a

00:07:41,660 --> 00:07:45,680
rectangle and relationships with a

00:07:43,640 --> 00:07:47,270
circle I use a circle instead of the

00:07:45,680 --> 00:07:48,620
database triangle because when you're

00:07:47,270 --> 00:07:50,810
writing on the whiteboard and you're

00:07:48,620 --> 00:07:54,740
writing sideways your triangles start to

00:07:50,810 --> 00:08:00,620
look like like like rectangles I'm sorry

00:07:54,740 --> 00:08:02,480
not triangles diamonds so these things

00:08:00,620 --> 00:08:04,490
form bipartite graphs

00:08:02,480 --> 00:08:06,800
what's a bipartite graph it's a graph

00:08:04,490 --> 00:08:09,800
where you have two distinct different

00:08:06,800 --> 00:08:13,070
node types and one node type is between

00:08:09,800 --> 00:08:15,230
every other node type right so to

00:08:13,070 --> 00:08:16,900
connect an entity to another entity

00:08:15,230 --> 00:08:19,430
you must do so through a relationship

00:08:16,900 --> 00:08:21,350
you cannot connect a relationship

00:08:19,430 --> 00:08:23,000
directly to a relationship without an

00:08:21,350 --> 00:08:24,380
intervening entity you had a

00:08:23,000 --> 00:08:25,910
relationship connected to another

00:08:24,380 --> 00:08:28,250
relationship that would be a composite

00:08:25,910 --> 00:08:32,120
relationship and just one relationship

00:08:28,250 --> 00:08:34,190
right so it would collapse right so this

00:08:32,120 --> 00:08:39,910
is a nice way to kind of look at the

00:08:34,190 --> 00:08:43,100
structure of things now we can represent

00:08:39,910 --> 00:08:45,890
implication in this by adding

00:08:43,100 --> 00:08:48,830
directional edges to our graph so this

00:08:45,890 --> 00:08:52,880
is shorthand for given entities B and C

00:08:48,830 --> 00:08:55,310
a isn't it is any entity such that our

00:08:52,880 --> 00:08:59,960
holds our relationship our holes is

00:08:55,310 --> 00:09:03,620
satisfied right so I read this as a as B

00:08:59,960 --> 00:09:05,000
and C implies a right right and that

00:09:03,620 --> 00:09:07,700
doesn't mean implies a particular limit

00:09:05,000 --> 00:09:10,580
of value it means implies a particular

00:09:07,700 --> 00:09:12,350
set of values potentially that satisfy

00:09:10,580 --> 00:09:15,320
this relationship this is not quite a

00:09:12,350 --> 00:09:21,860
function although it could be if we only

00:09:15,320 --> 00:09:24,320
had one result relationships and objects

00:09:21,860 --> 00:09:27,650
right as soon as we have two entities we

00:09:24,320 --> 00:09:30,860
have implicit relationships and the

00:09:27,650 --> 00:09:33,230
memory space is an entity what this

00:09:30,860 --> 00:09:35,030
means as as soon as I have one object in

00:09:33,230 --> 00:09:39,350
an entity I have a whole bunch of

00:09:35,030 --> 00:09:41,420
relationships that go with that when an

00:09:39,350 --> 00:09:43,340
object is copied or moved in your

00:09:41,420 --> 00:09:46,670
relationship that object was involved in

00:09:43,340 --> 00:09:48,560
is either maintained or it's severed

00:09:46,670 --> 00:09:51,320
maintained meaning the relationship

00:09:48,560 --> 00:09:53,480
still holds and severed meaning it

00:09:51,320 --> 00:09:57,470
doesn't with respect to the destination

00:09:53,480 --> 00:10:01,760
object so as an example if I were to

00:09:57,470 --> 00:10:04,960
clone myself okay I am married to my

00:10:01,760 --> 00:10:07,490
wife that relationship continues to hold

00:10:04,960 --> 00:10:11,240
there are one of two possible options

00:10:07,490 --> 00:10:14,300
for my clone my clone may be married to

00:10:11,240 --> 00:10:17,510
my wife depending on what state we live

00:10:14,300 --> 00:10:20,540
in in which case the relationship is

00:10:17,510 --> 00:10:22,820
maintained right if my clone is not

00:10:20,540 --> 00:10:25,280
married to my wife then the relationship

00:10:22,820 --> 00:10:27,670
was severed those are the two possible

00:10:25,280 --> 00:10:29,680
outcomes

00:10:27,670 --> 00:10:32,050
when an object is destructed any

00:10:29,680 --> 00:10:33,880
relationship that object was involved in

00:10:32,050 --> 00:10:37,510
is severed I can't have a relationship

00:10:33,880 --> 00:10:39,670
to a nonentity okay

00:10:37,510 --> 00:10:43,720
I cannot maintain some relationship to

00:10:39,670 --> 00:10:46,960
nothing this brings us to the notion of

00:10:43,720 --> 00:10:49,900
a witnessed relationship so a witnessed

00:10:46,960 --> 00:10:52,270
relationship I used to call this in a

00:10:49,900 --> 00:10:54,820
previous talk reified relationships but

00:10:52,270 --> 00:10:58,600
some good computer scientists corrected

00:10:54,820 --> 00:11:00,610
me a witness relationship is a

00:10:58,600 --> 00:11:03,240
relationship represented by an object

00:11:00,610 --> 00:11:06,730
right so we have a concrete object

00:11:03,240 --> 00:11:08,650
that's a token for some relationship a

00:11:06,730 --> 00:11:12,070
wedding ring which I'm not wearing mine

00:11:08,650 --> 00:11:16,360
but a wedding ring would be a token for

00:11:12,070 --> 00:11:19,120
a relationship as an object a witness

00:11:16,360 --> 00:11:20,680
relationship is copyable and a quality

00:11:19,120 --> 00:11:25,810
comparable and we'll talk more about

00:11:20,680 --> 00:11:29,710
that in in just a minute but that can

00:11:25,810 --> 00:11:32,290
cause a bit of a problem when an object

00:11:29,710 --> 00:11:34,270
witness relationship or not is copier or

00:11:32,290 --> 00:11:36,370
move any witness relationship that that

00:11:34,270 --> 00:11:39,250
object was involved in is either

00:11:36,370 --> 00:11:41,440
maintained its severed or it's

00:11:39,250 --> 00:11:45,370
invalidated what do we mean by

00:11:41,440 --> 00:11:48,100
invalidated right what we mean is that

00:11:45,370 --> 00:11:49,660
that object lost its meaning and we're

00:11:48,100 --> 00:11:53,200
going to talk more about that in a

00:11:49,660 --> 00:11:55,450
moment right so when we say oh if you

00:11:53,200 --> 00:11:57,850
insert into a vector than if you had

00:11:55,450 --> 00:12:00,490
another iterator into that vector that

00:11:57,850 --> 00:12:04,390
iterator wasn't validated my iterator is

00:12:00,490 --> 00:12:08,170
a witness to the relationship and doing

00:12:04,390 --> 00:12:10,810
that insert shifted the memory and now

00:12:08,170 --> 00:12:15,430
that iterator is invalid it's lost its

00:12:10,810 --> 00:12:17,350
meaning right it didn't get severed my

00:12:15,430 --> 00:12:19,930
iterator didn't get annulled and it

00:12:17,350 --> 00:12:22,270
didn't move magically with the object

00:12:19,930 --> 00:12:25,860
that went away to maintain that so now

00:12:22,270 --> 00:12:29,800
we have three states were concerned with

00:12:25,860 --> 00:12:31,780
okay and these states also apply to the

00:12:29,800 --> 00:12:33,790
witness relationship itself it's an

00:12:31,780 --> 00:12:40,090
object involved in this relationship

00:12:33,790 --> 00:12:40,960
right so when an object is destructed

00:12:40,090 --> 00:12:44,950
any witness

00:12:40,960 --> 00:12:47,320
relationship that object was involved in

00:12:44,950 --> 00:12:50,850
is either severed or maintained right we

00:12:47,320 --> 00:12:55,060
still can't maintain a relationship to

00:12:50,850 --> 00:12:57,220
to a nonentity but now we've got this

00:12:55,060 --> 00:12:59,050
other thing to worry about not just that

00:12:57,220 --> 00:13:04,810
our relationship is broken but that it's

00:12:59,050 --> 00:13:06,790
invalidated because of this notion of

00:13:04,810 --> 00:13:10,600
losing meanings sometimes we might

00:13:06,790 --> 00:13:13,540
choose not to implement copy or move for

00:13:10,600 --> 00:13:17,740
a witnessed relationship right this is a

00:13:13,540 --> 00:13:22,930
conscious choice right when we say that

00:13:17,740 --> 00:13:25,990
unique pointers or mutexes or locks are

00:13:22,930 --> 00:13:28,180
not copyable what we're actually saying

00:13:25,990 --> 00:13:30,190
is we're choosing not to copy them

00:13:28,180 --> 00:13:35,470
because of the ramifications that would

00:13:30,190 --> 00:13:38,490
follow if we did okay and this whole

00:13:35,470 --> 00:13:41,470
idea of invalidation is how we get

00:13:38,490 --> 00:13:43,540
iterator invalidation at a distance and

00:13:41,470 --> 00:13:45,670
that's kind of the scary quantum effect

00:13:43,540 --> 00:13:48,880
thing right I change an object over here

00:13:45,670 --> 00:13:51,760
and somehow some objects somewhere else

00:13:48,880 --> 00:13:54,670
in my application just got zapped it

00:13:51,760 --> 00:14:00,910
magically lost its meaning right all the

00:13:54,670 --> 00:14:03,420
way across space and time so let's talk

00:14:00,910 --> 00:14:06,310
a little bit of more about meaning and

00:14:03,420 --> 00:14:10,360
the board in our game right those are

00:14:06,310 --> 00:14:15,250
just the pieces so what's the board the

00:14:10,360 --> 00:14:17,740
board is structures a structure on a set

00:14:15,250 --> 00:14:20,050
going back to math here consists of

00:14:17,740 --> 00:14:22,150
additional entities so I've got some set

00:14:20,050 --> 00:14:25,060
of entities and I've got another set of

00:14:22,150 --> 00:14:28,600
entities that in some manner relate to

00:14:25,060 --> 00:14:32,190
the set endow in the collection that's

00:14:28,600 --> 00:14:35,410
our set with meaning or significance

00:14:32,190 --> 00:14:36,880
okay that's the definition it's a little

00:14:35,410 --> 00:14:43,420
abstract it's a little philosophical

00:14:36,880 --> 00:14:45,700
even so step with me into the void so

00:14:43,420 --> 00:14:48,310
this slide is void what I mean by a void

00:14:45,700 --> 00:14:51,160
it is it's dimensionless it has no width

00:14:48,310 --> 00:14:55,060
it has no height it's always existed

00:14:51,160 --> 00:14:58,670
it's not in time it's not

00:14:55,060 --> 00:15:00,680
into this void we're going to drop four

00:14:58,670 --> 00:15:02,750
bits now of course since we have no time

00:15:00,680 --> 00:15:10,070
these bits were always there you guys

00:15:02,750 --> 00:15:12,589
just weren't paying attention okay so

00:15:10,070 --> 00:15:15,889
now we ascribe meaning to those bits

00:15:12,589 --> 00:15:20,000
what do those bits mean maybe those bits

00:15:15,889 --> 00:15:24,589
mean four bananas maybe those bits mean

00:15:20,000 --> 00:15:28,209
the color blue maybe they just mean the

00:15:24,589 --> 00:15:31,670
abstract four right this is a

00:15:28,209 --> 00:15:33,889
representational relationship and there

00:15:31,670 --> 00:15:36,319
is nothing in the machine that tells us

00:15:33,889 --> 00:15:39,829
what these four bits represent only what

00:15:36,319 --> 00:15:41,899
we intend them to represent okay that's

00:15:39,829 --> 00:15:43,370
a representational relationship and

00:15:41,899 --> 00:15:49,279
that's what ascribes meaning to our

00:15:43,370 --> 00:15:52,459
objects now the collection of bits here

00:15:49,279 --> 00:15:55,850
as a whole we refer to as a type what is

00:15:52,459 --> 00:15:58,790
a type it's a pattern that we can use to

00:15:55,850 --> 00:16:03,350
represent other things within the domain

00:15:58,790 --> 00:16:06,110
of our entity right so maybe this

00:16:03,350 --> 00:16:08,329
collection here could represent values

00:16:06,110 --> 00:16:10,819
in the range of negative eight to seven

00:16:08,329 --> 00:16:14,209
right it's a little signed integer a

00:16:10,819 --> 00:16:17,540
4-bit signed integer so we could then

00:16:14,209 --> 00:16:18,980
have another object of the same type it

00:16:17,540 --> 00:16:23,329
was always here you guys just weren't

00:16:18,980 --> 00:16:28,880
looking in our void that also represents

00:16:23,329 --> 00:16:30,800
negative 8 to 7 ok and now that we have

00:16:28,880 --> 00:16:32,779
two objects we can talk about the

00:16:30,800 --> 00:16:34,279
relationship between the objects even if

00:16:32,779 --> 00:16:36,050
the objects were different types we

00:16:34,279 --> 00:16:39,860
would have a relationship which is are

00:16:36,050 --> 00:16:41,810
they the same type okay so now we've got

00:16:39,860 --> 00:16:46,399
a relationship where we can compare them

00:16:41,810 --> 00:16:47,839
and say is 4 greater than 3 trust me you

00:16:46,399 --> 00:16:50,860
guys if you're like where's Sean going

00:16:47,839 --> 00:16:50,860
with this there will be code

00:16:51,990 --> 00:17:00,160
okay so we've got then this

00:16:57,250 --> 00:17:02,110
representation in terms of bits which

00:17:00,160 --> 00:17:04,569
means we also have representations that

00:17:02,110 --> 00:17:07,030
aren't about the values themselves but

00:17:04,569 --> 00:17:09,579
are just about the bits so if our

00:17:07,030 --> 00:17:13,630
representation is unique then we can

00:17:09,579 --> 00:17:16,720
hash that representation and the the

00:17:13,630 --> 00:17:18,850
hash is not being equal implies that the

00:17:16,720 --> 00:17:22,120
values that those two things represent

00:17:18,850 --> 00:17:24,270
are not equal right so now we've got a

00:17:22,120 --> 00:17:27,699
correspondence between the

00:17:24,270 --> 00:17:29,500
representation and oven functions that

00:17:27,699 --> 00:17:35,530
we can apply to the representation and

00:17:29,500 --> 00:17:38,200
the meaning of those operations okay but

00:17:35,530 --> 00:17:40,690
objects don't exist in this void they

00:17:38,200 --> 00:17:44,140
exist in a memory space okay and they

00:17:40,690 --> 00:17:46,540
exist in time and they they are physical

00:17:44,140 --> 00:17:47,980
entities that exist in the world we talk

00:17:46,540 --> 00:17:50,860
about them being virtual but they're

00:17:47,980 --> 00:17:56,410
really not their physical bits inside of

00:17:50,860 --> 00:17:58,360
your machine right so what makes our two

00:17:56,410 --> 00:18:00,700
objects here different than just some

00:17:58,360 --> 00:18:03,340
arbitrary set of bits that we have

00:18:00,700 --> 00:18:05,740
somewhere else in the address space the

00:18:03,340 --> 00:18:11,530
only difference is the meaning we

00:18:05,740 --> 00:18:13,000
ascribe to those bits right as soon as

00:18:11,530 --> 00:18:15,160
we have an object in the memory space

00:18:13,000 --> 00:18:19,840
now we have additional relationships our

00:18:15,160 --> 00:18:22,150
object has an address okay the other

00:18:19,840 --> 00:18:24,640
object has an address and we can compare

00:18:22,150 --> 00:18:26,620
the addresses right this is true of

00:18:24,640 --> 00:18:28,510
every physical object every one of you

00:18:26,620 --> 00:18:33,990
guys has a coordinate within the

00:18:28,510 --> 00:18:37,000
universe okay and every one of you guys

00:18:33,990 --> 00:18:37,840
is in a relationship with everybody else

00:18:37,000 --> 00:18:39,809
in the room

00:18:37,840 --> 00:18:42,549
right we can compare your coordinates

00:18:39,809 --> 00:18:45,820
okay so these are called physical

00:18:42,549 --> 00:18:47,380
relationships right so don't go home and

00:18:45,820 --> 00:18:49,000
tell your spouse's hey I wasn't a

00:18:47,380 --> 00:18:50,290
physical relationship right or your

00:18:49,000 --> 00:18:54,299
partners I was in a physical

00:18:50,290 --> 00:18:54,299
relationship with everybody at CPP con

00:18:55,410 --> 00:18:59,919
okay now because these things have

00:18:58,270 --> 00:19:01,880
coordinates it means that we can do

00:18:59,919 --> 00:19:05,330
things like sorting them

00:19:01,880 --> 00:19:09,620
okay we're putting the values in memory

00:19:05,330 --> 00:19:13,010
now implies the vet that implies a

00:19:09,620 --> 00:19:14,570
corresponding relationship to I'm sorry

00:19:13,010 --> 00:19:16,940
the location in memory implies a

00:19:14,570 --> 00:19:19,550
corresponding relationship to the values

00:19:16,940 --> 00:19:22,490
the smaller value is before the bigger

00:19:19,550 --> 00:19:26,180
value okay that's what it means to sort

00:19:22,490 --> 00:19:28,760
data a very useful operation we can also

00:19:26,180 --> 00:19:31,730
use these objects with an operation such

00:19:28,760 --> 00:19:34,220
as plus we can add them together to

00:19:31,730 --> 00:19:36,920
ascribe new meaning to other bits of the

00:19:34,220 --> 00:19:40,730
machine so we add three and four and we

00:19:36,920 --> 00:19:43,040
get seven okay and what we're saying is

00:19:40,730 --> 00:19:46,970
this is not just seven this is the sum

00:19:43,040 --> 00:19:49,010
of those two other objects that's what

00:19:46,970 --> 00:19:50,930
it represents right so we're taking the

00:19:49,010 --> 00:19:56,510
meaning of the initial objects and we're

00:19:50,930 --> 00:20:00,370
creating new objects with new meaning so

00:19:56,510 --> 00:20:02,960
let's talk a little bit about safety an

00:20:00,370 --> 00:20:06,470
object instance without meaning is

00:20:02,960 --> 00:20:09,320
invalid okay so I can have bits in the

00:20:06,470 --> 00:20:11,720
machine which are an object but somehow

00:20:09,320 --> 00:20:13,580
have lost their meaning such as an

00:20:11,720 --> 00:20:17,890
invalid iterator which we talked about

00:20:13,580 --> 00:20:20,900
before an object in an invalid state

00:20:17,890 --> 00:20:23,990
must either be restored to a valid State

00:20:20,900 --> 00:20:25,610
or be destroyed right we somehow have to

00:20:23,990 --> 00:20:27,380
get the meaning back into that object or

00:20:25,610 --> 00:20:29,240
we have to let that thing go if we just

00:20:27,380 --> 00:20:30,860
let it wander around the system it's

00:20:29,240 --> 00:20:33,080
spreading nonsense throughout our

00:20:30,860 --> 00:20:36,560
machine and our program becomes invalid

00:20:33,080 --> 00:20:37,640
so we want to localize the damage right

00:20:36,560 --> 00:20:39,200
we want to make sure that we're

00:20:37,640 --> 00:20:40,910
conscious that it's there and that the

00:20:39,200 --> 00:20:45,680
damage of these invalid objects is

00:20:40,910 --> 00:20:47,990
contained this relates to the idea if

00:20:45,680 --> 00:20:50,210
you're familiar with alec Stepanov book

00:20:47,990 --> 00:20:52,280
elements of programming to the idea of a

00:20:50,210 --> 00:20:54,560
partially formed object and partially

00:20:52,280 --> 00:20:56,960
formed object in elements of programming

00:20:54,560 --> 00:20:59,050
is an object where the requirements are

00:20:56,960 --> 00:21:02,930
only that you can assign to it or

00:20:59,050 --> 00:21:05,180
destruct it right I can either put

00:21:02,930 --> 00:21:07,070
meaning back into the object or I can

00:21:05,180 --> 00:21:09,950
destroy it those are the only two

00:21:07,070 --> 00:21:11,750
operations that are allowed now it's a

00:21:09,950 --> 00:21:13,850
little bit weaker to say about an

00:21:11,750 --> 00:21:15,360
invalid object if you think about a

00:21:13,850 --> 00:21:17,280
doubly linked list

00:21:15,360 --> 00:21:18,690
if I'm inside the class for a

00:21:17,280 --> 00:21:20,520
doubly-linked list and I'm doing some

00:21:18,690 --> 00:21:23,940
operation at some point I'm going to

00:21:20,520 --> 00:21:26,610
need to change one of the links in my in

00:21:23,940 --> 00:21:28,200
my list at that point where I've only

00:21:26,610 --> 00:21:31,310
changed one and I haven't done the

00:21:28,200 --> 00:21:34,260
corresponding change for the backlink my

00:21:31,310 --> 00:21:37,580
doubly linked list is now in an invalid

00:21:34,260 --> 00:21:40,830
State it doesn't at that moment in time

00:21:37,580 --> 00:21:43,500
represent my canonical list it's not

00:21:40,830 --> 00:21:45,810
completely devoid of information but it

00:21:43,500 --> 00:21:47,790
has in some sense lost its meaning and

00:21:45,810 --> 00:21:54,590
so I need to come along into another

00:21:47,790 --> 00:21:57,180
operation to restore the meaning so an

00:21:54,590 --> 00:22:00,420
operation which leaves an object in an

00:21:57,180 --> 00:22:04,260
invalid State we refer to as being

00:22:00,420 --> 00:22:06,630
unsafe okay so an operation that can

00:22:04,260 --> 00:22:11,370
nuke some other object in your device is

00:22:06,630 --> 00:22:13,680
is an unsafe operation now unsafe

00:22:11,370 --> 00:22:15,810
doesn't mean bad it doesn't mean you

00:22:13,680 --> 00:22:18,180
should never call it in fact we can

00:22:15,810 --> 00:22:21,510
prove that there is a relationship

00:22:18,180 --> 00:22:24,090
between safety and efficiency and you

00:22:21,510 --> 00:22:31,410
cannot have complete efficiency and

00:22:24,090 --> 00:22:34,080
complete safety both provably STD move

00:22:31,410 --> 00:22:35,730
is an unsafe operation and I want to

00:22:34,080 --> 00:22:37,110
bring this up because the standard

00:22:35,730 --> 00:22:38,910
wording although it's improved in the

00:22:37,110 --> 00:22:41,220
latest standard I still somewhat object

00:22:38,910 --> 00:22:43,290
to the standard word wording on this the

00:22:41,220 --> 00:22:46,770
post condition the required post

00:22:43,290 --> 00:22:50,160
condition of STD move is that the object

00:22:46,770 --> 00:22:54,870
that was moved from is in a valid but

00:22:50,160 --> 00:22:58,020
unspecified State okay well what do we

00:22:54,870 --> 00:23:01,310
mean by valid and unspecified if it's

00:22:58,020 --> 00:23:05,970
unspecified it's has no meaning

00:23:01,310 --> 00:23:07,730
okay the standard itself kind of

00:23:05,970 --> 00:23:12,810
contradicts itself it talks about

00:23:07,730 --> 00:23:16,200
iterators being invalid right and it

00:23:12,810 --> 00:23:18,540
talks about objects being being valid

00:23:16,200 --> 00:23:20,880
after a move okay

00:23:18,540 --> 00:23:22,080
and when they say an iterator is invalid

00:23:20,880 --> 00:23:23,760
it means you have to assign a new

00:23:22,080 --> 00:23:25,800
iterator into it or you have to let it

00:23:23,760 --> 00:23:27,480
go but you can't do references well you

00:23:25,800 --> 00:23:28,169
also can't dereference an iterator to an

00:23:27,480 --> 00:23:30,029
end

00:23:28,169 --> 00:23:35,129
and dereference an iterator to the

00:23:30,029 --> 00:23:36,929
beginning so so kind of structurally

00:23:35,129 --> 00:23:40,259
there's no difference in that really

00:23:36,929 --> 00:23:45,320
what invalidation means there is that

00:23:40,259 --> 00:23:45,320
that the meaning of that object is lost

00:23:45,649 --> 00:23:52,830
so and I want to be clear because I said

00:23:50,399 --> 00:23:54,809
that at a prior talk that STD move is

00:23:52,830 --> 00:23:57,059
unsafe and that turned into this whole

00:23:54,809 --> 00:23:59,669
big debate because it followed some

00:23:57,059 --> 00:24:02,489
stuff that Eric Kneedler said that Shawn

00:23:59,669 --> 00:24:03,239
parents had STD safe that STD move is

00:24:02,489 --> 00:24:08,850
bad

00:24:03,239 --> 00:24:10,470
Shawn said STD move is destructive no I

00:24:08,850 --> 00:24:14,429
said something very precise and very

00:24:10,470 --> 00:24:20,369
particular right so it's not bad it's

00:24:14,429 --> 00:24:22,679
just unsafe you know in C++ 20 we have

00:24:20,369 --> 00:24:23,539
two new features specifically about

00:24:22,679 --> 00:24:29,059
relationships

00:24:23,539 --> 00:24:33,230
can somebody name them I heard concepts

00:24:29,059 --> 00:24:38,789
that's number one what's the other one

00:24:33,230 --> 00:24:43,619
buddy contracts okay I lied in C++ 20 we

00:24:38,789 --> 00:24:49,289
have one new feature specifically about

00:24:43,619 --> 00:24:51,470
relationships concepts so concepts the

00:24:49,289 --> 00:24:54,289
term was originally coined in this paper

00:24:51,470 --> 00:24:57,029
fundamentals of a generic programming

00:24:54,289 --> 00:25:00,929
this is from james jenner and alexander

00:24:57,029 --> 00:25:04,200
stepping off and this is what they said

00:25:00,929 --> 00:25:06,509
we call the set of axioms satisfied by a

00:25:04,200 --> 00:25:14,429
data type and a set of operations on it

00:25:06,509 --> 00:25:18,149
a concept this work is very tightly

00:25:14,429 --> 00:25:22,980
related to this paper here an axiomatic

00:25:18,149 --> 00:25:25,769
basis for computer programming this is

00:25:22,980 --> 00:25:28,679
from Tony Hoare sir Tony Hoare this was

00:25:25,769 --> 00:25:31,649
published back in 1969 and this

00:25:28,679 --> 00:25:34,139
introduced what's known as or logic it's

00:25:31,649 --> 00:25:37,609
also known as Floyd heart or logic Bob

00:25:34,139 --> 00:25:37,609
Floyd was Tony's advisor

00:25:38,030 --> 00:25:41,720
I'm not going to go into logic but

00:25:40,580 --> 00:25:42,230
you'll see the relevance here in a

00:25:41,720 --> 00:25:44,030
moment

00:25:42,230 --> 00:25:46,370
so let's talk a little bit about

00:25:44,030 --> 00:25:49,400
concepts right two objects are equal if

00:25:46,370 --> 00:25:51,770
and only if right if if with two F's

00:25:49,400 --> 00:25:56,180
their values correspond to the same

00:25:51,770 --> 00:25:58,900
entity right so we have two objects they

00:25:56,180 --> 00:26:01,820
have some meaning they represent for

00:25:58,900 --> 00:26:04,370
some abstract for those two objects are

00:26:01,820 --> 00:26:07,010
eat or equal only if they represent the

00:26:04,370 --> 00:26:12,650
same floor there's only one platonic for

00:26:07,010 --> 00:26:16,730
right one truth for that from that we

00:26:12,650 --> 00:26:18,230
define the following properties right

00:26:16,730 --> 00:26:21,080
it's not going the other way around

00:26:18,230 --> 00:26:23,660
people think the axioms for equality are

00:26:21,080 --> 00:26:26,450
what define equality no it's the meaning

00:26:23,660 --> 00:26:30,170
of equality that defines equality the

00:26:26,450 --> 00:26:31,910
axioms are the minimum set of

00:26:30,170 --> 00:26:35,720
relationships that we can derive from

00:26:31,910 --> 00:26:38,000
that definition as to what Akoo to

00:26:35,720 --> 00:26:40,700
represent equality and these in fact to

00:26:38,000 --> 00:26:47,930
find any equivalence relationship not

00:26:40,700 --> 00:26:50,800
just equality so with concepts axioms

00:26:47,930 --> 00:26:53,870
follow from from our definition a

00:26:50,800 --> 00:26:56,540
collection of connected axioms form an

00:26:53,870 --> 00:26:58,370
algebraic structure right that's what

00:26:56,540 --> 00:27:01,730
what algebraic structures are in

00:26:58,370 --> 00:27:05,300
mathematics connected axioms connect to

00:27:01,730 --> 00:27:07,760
type requirements form a concept right

00:27:05,300 --> 00:27:10,340
so we're lifting a mathematical idea of

00:27:07,760 --> 00:27:15,260
algebraic structures into the computer

00:27:10,340 --> 00:27:18,760
science realm so what do I mean by

00:27:15,260 --> 00:27:21,380
connected well operations like copy are

00:27:18,760 --> 00:27:24,560
connected to equality in fact the

00:27:21,380 --> 00:27:26,930
quality is our most basic operation

00:27:24,560 --> 00:27:30,020
because it tells us whether or not two

00:27:26,930 --> 00:27:32,540
things mean the same thing and so every

00:27:30,020 --> 00:27:34,700
other thing that we do we define in some

00:27:32,540 --> 00:27:38,420
way in terms of equality that's known as

00:27:34,700 --> 00:27:44,660
equational reasoning right so copies are

00:27:38,420 --> 00:27:47,270
equal and copies are disjoint right and

00:27:44,660 --> 00:27:49,610
we can extend this to other operations a

00:27:47,270 --> 00:27:50,460
natural total order is a total order

00:27:49,610 --> 00:27:52,200
that respects

00:27:50,460 --> 00:27:54,870
the other fundamental operations on a

00:27:52,200 --> 00:27:56,850
type right toll order has the following

00:27:54,870 --> 00:28:05,010
properties it'll be as the trichotomy

00:27:56,850 --> 00:28:07,890
law and it's transitive right so here we

00:28:05,010 --> 00:28:10,320
can say natural toll order right for all

00:28:07,890 --> 00:28:14,610
n which are are within the integer

00:28:10,320 --> 00:28:17,430
domain and is less than n plus 1 right

00:28:14,610 --> 00:28:19,530
why don't we have a natural total order

00:28:17,430 --> 00:28:22,020
and define operator equal on complex

00:28:19,530 --> 00:28:25,590
types there are many total orders that

00:28:22,020 --> 00:28:27,870
we could define on complex types but

00:28:25,590 --> 00:28:30,180
there are no no total orders that are

00:28:27,870 --> 00:28:33,480
consistent with the other operations on

00:28:30,180 --> 00:28:35,940
a complex type so we omit defining

00:28:33,480 --> 00:28:41,600
operator equal operator equal should

00:28:35,940 --> 00:28:46,770
mean the natural total order now these

00:28:41,600 --> 00:28:48,510
quantified axioms for all there exists

00:28:46,770 --> 00:28:51,510
those are quantified axioms are not

00:28:48,510 --> 00:28:54,510
generally actionable right I can't write

00:28:51,510 --> 00:28:57,570
code and say that require for every

00:28:54,510 --> 00:29:01,080
possible thing pairs of values that I

00:28:57,570 --> 00:29:03,840
could call this function with this is

00:29:01,080 --> 00:29:08,460
satisfied I don't have a way to describe

00:29:03,840 --> 00:29:10,740
that people continue to try what you

00:29:08,460 --> 00:29:12,960
need is an algebraic system layered on

00:29:10,740 --> 00:29:15,960
top so that you can prove and reason

00:29:12,960 --> 00:29:18,270
about these quantified axioms in fact

00:29:15,960 --> 00:29:20,250
Aleks stepping off and Dave Dave Masur

00:29:18,270 --> 00:29:21,780
when they create a generic programming

00:29:20,250 --> 00:29:24,420
went off and created an entire

00:29:21,780 --> 00:29:28,470
programming language called Tecton which

00:29:24,420 --> 00:29:30,960
is all about a formal proving of

00:29:28,470 --> 00:29:33,360
software and algorithms and in fact not

00:29:30,960 --> 00:29:37,470
many people know this but all of the STL

00:29:33,360 --> 00:29:40,770
has been formally proven or circa you

00:29:37,470 --> 00:29:48,210
know the HP STL has been formally proven

00:29:40,770 --> 00:29:50,730
using Tecton so concepts in C++ work by

00:29:48,210 --> 00:29:53,160
associating the semantics these meanings

00:29:50,730 --> 00:29:56,850
with some name right which is exactly

00:29:53,160 --> 00:29:59,150
what we do when we're talking right what

00:29:56,850 --> 00:30:02,190
do the words coming out of my mouth mean

00:29:59,150 --> 00:30:04,020
we have some set of associated semantics

00:30:02,190 --> 00:30:08,700
so we lift that

00:30:04,020 --> 00:30:10,590
same idea into our software and we

00:30:08,700 --> 00:30:15,320
associate meaning with our named

00:30:10,590 --> 00:30:18,050
operations so software is defined very

00:30:15,320 --> 00:30:21,690
fundamentally on algebraic structures

00:30:18,050 --> 00:30:23,960
this is how it comes together now I want

00:30:21,690 --> 00:30:27,210
to talk a little bit here about

00:30:23,960 --> 00:30:29,460
contracts right even though they didn't

00:30:27,210 --> 00:30:33,570
fall into the lane or even though they

00:30:29,460 --> 00:30:36,120
didn't land in C++ 20 contracts came out

00:30:33,570 --> 00:30:37,530
of this paper this is a slightly newer

00:30:36,120 --> 00:30:40,140
rendition I couldn't find an original

00:30:37,530 --> 00:30:45,600
copy but it was originally published in

00:30:40,140 --> 00:30:49,230
86 by Bertrand Meyer that's a picture of

00:30:45,600 --> 00:30:54,180
Bertrand so it's applying design by

00:30:49,230 --> 00:30:56,940
contract okay and it came out of his

00:30:54,180 --> 00:31:01,050
work came out of exactly the same work

00:30:56,940 --> 00:31:04,230
as generic programming right this work

00:31:01,050 --> 00:31:07,110
by Tony Hoare an axiomatic basis for

00:31:04,230 --> 00:31:11,040
computer programming they share the same

00:31:07,110 --> 00:31:13,740
roots contracts were originally part of

00:31:11,040 --> 00:31:15,990
the eiffel programming language in

00:31:13,740 --> 00:31:18,480
contracts allowed the specification of

00:31:15,990 --> 00:31:21,030
constraints we had pre and post

00:31:18,480 --> 00:31:25,020
conditions on functions and we have

00:31:21,030 --> 00:31:28,950
class invariants what does it mean to

00:31:25,020 --> 00:31:33,510
have a class invariant right what we

00:31:28,950 --> 00:31:35,400
mean is is a class invariant is a

00:31:33,510 --> 00:31:41,580
constrained a set of properties that

00:31:35,400 --> 00:31:45,690
must hold when the value is valid when

00:31:41,580 --> 00:31:48,000
it has meaning okay that gets a little

00:31:45,690 --> 00:31:49,830
tough the normal way that we represent

00:31:48,000 --> 00:31:51,420
this is we're allowed to violate the

00:31:49,830 --> 00:31:53,730
class invariants when we're inside of a

00:31:51,420 --> 00:31:57,810
private method but we can't when we're

00:31:53,730 --> 00:32:02,280
outside except for efficiency we need

00:31:57,810 --> 00:32:06,740
unsafe operations outside okay so class

00:32:02,280 --> 00:32:11,390
invariants get a little tricky so

00:32:06,740 --> 00:32:14,390
contracts are actionable predicates on

00:32:11,390 --> 00:32:14,390
values

00:32:14,940 --> 00:32:22,570
Bertrand ran into exactly the same issue

00:32:18,370 --> 00:32:25,540
that Alex and Dave ran into this is a

00:32:22,570 --> 00:32:28,390
quote from from Burt Ron's paper in some

00:32:25,540 --> 00:32:31,120
cases might one might want to use

00:32:28,390 --> 00:32:34,360
quantified expressions of the form for

00:32:31,120 --> 00:32:37,090
all X of type T P X holds or there

00:32:34,360 --> 00:32:39,120
exists X of type T such that P X holds

00:32:37,090 --> 00:32:41,920
where P is a certain boolean property

00:32:39,120 --> 00:32:46,770
such expressions are not available in

00:32:41,920 --> 00:32:49,450
Eiffel they just can't be right

00:32:46,770 --> 00:32:51,130
so concepts describe relationships

00:32:49,450 --> 00:32:53,020
between operations on the type and

00:32:51,130 --> 00:32:55,840
contracts described relationships

00:32:53,020 --> 00:32:58,630
between values and the distinction is

00:32:55,840 --> 00:33:01,270
not always clear right if you think

00:32:58,630 --> 00:33:04,000
about it that compares the requirements

00:33:01,270 --> 00:33:06,100
for the comparison operation past STD

00:33:04,000 --> 00:33:07,990
sort is that the comparison must

00:33:06,100 --> 00:33:10,480
implement a strict weak ordering

00:33:07,990 --> 00:33:14,470
relation over the values that are being

00:33:10,480 --> 00:33:18,490
sorted is that a contract is that a

00:33:14,470 --> 00:33:21,070
property of the type okay or is that a

00:33:18,490 --> 00:33:24,790
precondition on the function object that

00:33:21,070 --> 00:33:30,130
we're passing in it's not always clear

00:33:24,790 --> 00:33:34,299
and there's a bit of a difference in the

00:33:30,130 --> 00:33:37,390
way we handle contracts and the way we

00:33:34,299 --> 00:33:39,549
handle concepts concepts are used as a

00:33:37,390 --> 00:33:42,160
compile-time constraint to select an

00:33:39,549 --> 00:33:44,799
appropriate operation okay if a concept

00:33:42,160 --> 00:33:46,480
isn't satisfied then we just ignore that

00:33:44,799 --> 00:33:48,610
that function and we go look for a

00:33:46,480 --> 00:33:49,809
different function and if there is no

00:33:48,610 --> 00:33:53,530
other function then you would get a

00:33:49,809 --> 00:33:56,679
compilation error contracts assert at

00:33:53,530 --> 00:34:00,250
runtime if an Operations preconditions

00:33:56,679 --> 00:34:03,150
are not met okay so it's the equivalent

00:34:00,250 --> 00:34:06,400
they're just writing assert in their a

00:34:03,150 --> 00:34:08,109
runtime constraint to select an

00:34:06,400 --> 00:34:10,510
appropriate operation is known as

00:34:08,109 --> 00:34:12,490
pattern matching right we don't have

00:34:10,510 --> 00:34:16,450
pattern matching in C++ although I've

00:34:12,490 --> 00:34:17,830
seen a couple papers proposing it so

00:34:16,450 --> 00:34:21,520
let's take a look here we could have a

00:34:17,830 --> 00:34:23,649
concept on a function like this this is

00:34:21,520 --> 00:34:26,340
a little bit of pseudocode our double

00:34:23,649 --> 00:34:28,360
requires clause here people hate that

00:34:26,340 --> 00:34:31,960
but what this is saying

00:34:28,360 --> 00:34:35,080
is that for whatever type eye is the

00:34:31,960 --> 00:34:42,160
expression not eye less than zero must

00:34:35,080 --> 00:34:48,910
be a valid expression okay we could have

00:34:42,160 --> 00:34:55,240
a contract that says for whatever value

00:34:48,910 --> 00:34:59,950
I hold I cannot be negative okay or we

00:34:55,240 --> 00:35:03,880
assert and in theory we could have a

00:34:59,950 --> 00:35:07,690
pattern match that says for whatever

00:35:03,880 --> 00:35:10,270
value I holds I cannot be negative and

00:35:07,690 --> 00:35:12,190
if it is we go try to find another copy

00:35:10,270 --> 00:35:16,900
of F to execute at runtime

00:35:12,190 --> 00:35:18,730
that's what pattern matching is all

00:35:16,900 --> 00:35:23,170
right so all these ideas are very

00:35:18,730 --> 00:35:25,990
closely related I want to talk briefly

00:35:23,170 --> 00:35:27,880
about one more important relationship

00:35:25,990 --> 00:35:32,230
and this is the whole part relationship

00:35:27,880 --> 00:35:33,370
for composite objects right the

00:35:32,230 --> 00:35:35,380
relationship for whole part

00:35:33,370 --> 00:35:37,600
relationships means that objects are

00:35:35,380 --> 00:35:39,700
connected right we can have a local part

00:35:37,600 --> 00:35:43,780
and a remote part here C is our remote

00:35:39,700 --> 00:35:46,300
part non-circular we can't just hold on

00:35:43,780 --> 00:35:48,820
to C itself and and have it also

00:35:46,300 --> 00:35:51,930
connected to its parents so so we can't

00:35:48,820 --> 00:35:54,280
do that in a whole part relationship

00:35:51,930 --> 00:35:57,630
whole part relationship means things are

00:35:54,280 --> 00:36:01,780
logically disjoint right so I can't have

00:35:57,630 --> 00:36:06,640
some a prime and some a sharing some

00:36:01,780 --> 00:36:10,300
state that's not allowed and they're

00:36:06,640 --> 00:36:14,440
owning relationships right and what that

00:36:10,300 --> 00:36:18,070
means is that I if I made a copy here

00:36:14,440 --> 00:36:22,840
and I destruct the object the whole

00:36:18,070 --> 00:36:24,510
thing goes including the remote parts so

00:36:22,840 --> 00:36:26,950
that's the whole part relationship

00:36:24,510 --> 00:36:29,950
standard containers are composite

00:36:26,950 --> 00:36:31,870
objects composite objects allow us to

00:36:29,950 --> 00:36:35,470
reason about a collection of objects as

00:36:31,870 --> 00:36:37,690
if they were a single entity right an

00:36:35,470 --> 00:36:40,780
entity in the relationship in the

00:36:37,690 --> 00:36:41,750
structure of our application that's why

00:36:40,780 --> 00:36:44,420
this is important

00:36:41,750 --> 00:36:46,340
simplifies our reasoning about a

00:36:44,420 --> 00:36:50,900
collection of objects down to that is

00:36:46,340 --> 00:36:53,030
just one entity right so this is why I

00:36:50,900 --> 00:36:55,610
give a talk on no incidental data

00:36:53,030 --> 00:36:57,740
structures right I see this a lot I've

00:36:55,610 --> 00:36:59,420
got a view class and it's got a shared

00:36:57,740 --> 00:37:01,220
pointer to other views and I could be

00:36:59,420 --> 00:37:03,770
hanging on to those views and I've got a

00:37:01,220 --> 00:37:06,080
weak pointer to the parent and I've got

00:37:03,770 --> 00:37:08,810
this whole tangled mess of objects

00:37:06,080 --> 00:37:10,580
I can't reason about that I don't have

00:37:08,810 --> 00:37:12,590
an entity I have a whole bunch of

00:37:10,580 --> 00:37:15,290
complex relationships spread all over my

00:37:12,590 --> 00:37:17,030
code so if I can get rid of that and

00:37:15,290 --> 00:37:19,870
turn it into a container or something

00:37:17,030 --> 00:37:23,120
like an Adobe for us to views

00:37:19,870 --> 00:37:25,190
now I've just just got one box I can

00:37:23,120 --> 00:37:30,500
draw on my whiteboard okay

00:37:25,190 --> 00:37:32,900
and I can think about that I give

00:37:30,500 --> 00:37:34,460
another talk that has been cited more

00:37:32,900 --> 00:37:37,880
times than I can count at this

00:37:34,460 --> 00:37:40,130
conference I know raw loops and I put up

00:37:37,880 --> 00:37:44,030
this piece of code and this piece of

00:37:40,130 --> 00:37:45,760
code is a rotate it's a find if followed

00:37:44,030 --> 00:37:50,360
by rotate but we'll call it a rotate

00:37:45,760 --> 00:37:58,550
right so that's a rotate that's for

00:37:50,360 --> 00:38:01,250
Conor right why do I want that that lets

00:37:58,550 --> 00:38:03,200
me take this big mess of code i distill

00:38:01,250 --> 00:38:06,260
it down to the function and that

00:38:03,200 --> 00:38:09,080
function now is just one relationship I

00:38:06,260 --> 00:38:11,030
can see the structure I can reason about

00:38:09,080 --> 00:38:13,790
the structure about what's going on I

00:38:11,030 --> 00:38:18,470
can draw it on my whiteboard that's why

00:38:13,790 --> 00:38:23,150
no raw loose so now we finally get to

00:38:18,470 --> 00:38:26,270
the game the game is architecture what

00:38:23,150 --> 00:38:28,430
is architecture architecture is the art

00:38:26,270 --> 00:38:31,580
and practice of designing and

00:38:28,430 --> 00:38:34,250
constructing structures right

00:38:31,580 --> 00:38:35,870
that's what architecture means how many

00:38:34,250 --> 00:38:39,170
people have software architects in their

00:38:35,870 --> 00:38:41,810
title okay a few how many people knew

00:38:39,170 --> 00:38:43,130
that who are architects anybody all

00:38:41,810 --> 00:38:45,020
right that's what architecture means

00:38:43,130 --> 00:38:47,510
when we're talking about software

00:38:45,020 --> 00:38:50,000
architecture we are talking about taking

00:38:47,510 --> 00:38:53,740
these structures and designing them

00:38:50,000 --> 00:38:57,820
putting them together purposefully

00:38:53,740 --> 00:39:01,180
that's what we do so let's give a

00:38:57,820 --> 00:39:04,210
concrete example here I was given this

00:39:01,180 --> 00:39:06,460
task recently this is the basic

00:39:04,210 --> 00:39:08,560
description of the task save the

00:39:06,460 --> 00:39:10,510
document every five minutes after the

00:39:08,560 --> 00:39:12,940
application has been idle for at least

00:39:10,510 --> 00:39:15,520
five seconds that's the description in

00:39:12,940 --> 00:39:18,190
English so how do I approach this

00:39:15,520 --> 00:39:19,869
problem well the first thing I do is I

00:39:18,190 --> 00:39:21,670
say the others this piece save the

00:39:19,869 --> 00:39:23,020
document every five minutes I know how

00:39:21,670 --> 00:39:25,660
to create a schedule timer that will

00:39:23,020 --> 00:39:27,820
execute every five minutes so I can

00:39:25,660 --> 00:39:29,740
ignore that piece you know as an

00:39:27,820 --> 00:39:34,180
exercise for you I was absolutely wrong

00:39:29,740 --> 00:39:36,570
I can't ignore that piece if you realize

00:39:34,180 --> 00:39:39,099
why after you've seen the rest of this

00:39:36,570 --> 00:39:40,619
you'll also know how to fix it so I'm

00:39:39,099 --> 00:39:46,060
not going to tell you how to fix that

00:39:40,619 --> 00:39:49,300
okay that's an exercise so but in any

00:39:46,060 --> 00:39:51,130
case I'm ignoring that for now that

00:39:49,300 --> 00:39:53,380
leaves me with this and I generalized it

00:39:51,130 --> 00:39:55,240
a little bit after the application has

00:39:53,380 --> 00:39:57,520
been idle for at least 10 seconds

00:39:55,240 --> 00:40:00,640
because somebody pulled five out of thin

00:39:57,520 --> 00:40:02,470
air do something because it really

00:40:00,640 --> 00:40:04,089
doesn't matter if we're saving or not

00:40:02,470 --> 00:40:07,210
right and we're gonna generalize this

00:40:04,089 --> 00:40:10,720
just a little bit and I wrote this piece

00:40:07,210 --> 00:40:13,180
of code and what did I said well I need

00:40:10,720 --> 00:40:17,589
to know when was the last time we were

00:40:13,180 --> 00:40:19,210
idle so somewhere in the application

00:40:17,589 --> 00:40:21,369
that's gonna have to be provided so I'll

00:40:19,210 --> 00:40:23,020
just stick in a reference to a global

00:40:21,369 --> 00:40:27,250
variable which is the last time the

00:40:23,020 --> 00:40:30,820
application was idle okay and then I'm

00:40:27,250 --> 00:40:33,820
gonna need some operation to schedule a

00:40:30,820 --> 00:40:36,670
task to execute at a particular time now

00:40:33,820 --> 00:40:39,790
I have that it's been provided by the OS

00:40:36,670 --> 00:40:42,010
somewhere so I'm just going to assume

00:40:39,790 --> 00:40:44,859
that it's outside of my domain right I

00:40:42,010 --> 00:40:47,619
know that I can go find that it's

00:40:44,859 --> 00:40:49,119
somewhere in my application so I need

00:40:47,619 --> 00:40:50,890
those two things now given those two

00:40:49,119 --> 00:40:55,480
things I can write this function after

00:40:50,890 --> 00:40:58,960
idle and what I'm going to do is I'm

00:40:55,480 --> 00:41:03,310
going to calculate when I should execute

00:40:58,960 --> 00:41:04,780
this task right so I'm going to take the

00:41:03,310 --> 00:41:06,670
current clock subtract away the eye a

00:41:04,780 --> 00:41:07,210
little minus the delay it which is going

00:41:06,670 --> 00:41:09,550
to be hour

00:41:07,210 --> 00:41:15,119
seconds and that's going to tell me when

00:41:09,550 --> 00:41:15,119
to execute and now I'm going to say

00:41:15,220 --> 00:41:20,890
should it be executing now or not if not

00:41:18,250 --> 00:41:25,080
I will kind of do this funky little

00:41:20,890 --> 00:41:27,820
recursion here where I will say schedule

00:41:25,080 --> 00:41:31,089
not a time to actually execute the task

00:41:27,820 --> 00:41:33,280
but to check again right why check again

00:41:31,089 --> 00:41:37,330
because my last idle is a global

00:41:33,280 --> 00:41:39,940
variable it might get updated okay so

00:41:37,330 --> 00:41:43,119
what am I gonna do I'm going to say oh I

00:41:39,940 --> 00:41:45,160
should should execute this task in four

00:41:43,119 --> 00:41:47,349
seconds in four seconds I check again

00:41:45,160 --> 00:41:50,050
and say lamp now user did something

00:41:47,349 --> 00:41:53,830
maybe three more seconds okay until I

00:41:50,050 --> 00:41:56,890
finally execute and the final execution

00:41:53,830 --> 00:41:59,680
is here now there's a couple problems

00:41:56,890 --> 00:42:02,290
with this code right my last Idol

00:41:59,680 --> 00:42:04,119
probably wants to be atomic I wanted to

00:42:02,290 --> 00:42:06,520
put it as an atomic on the slide here

00:42:04,119 --> 00:42:09,520
but I can't because STD atomic requires

00:42:06,520 --> 00:42:11,980
that the value be no except default

00:42:09,520 --> 00:42:14,290
constructible but for some reason a time

00:42:11,980 --> 00:42:15,940
point is not know except default

00:42:14,290 --> 00:42:19,990
constructible so the compiler gives me

00:42:15,940 --> 00:42:21,369
an error if I attempt to do that but if

00:42:19,990 --> 00:42:23,650
I'm assuming that this is all getting

00:42:21,369 --> 00:42:26,859
scheduled through a run loop on just one

00:42:23,650 --> 00:42:30,540
thread this still works fine I've also

00:42:26,859 --> 00:42:32,980
got a bit of an issue here with with

00:42:30,540 --> 00:42:35,650
registering my task which is when I call

00:42:32,980 --> 00:42:37,960
this my task may get scheduled and

00:42:35,650 --> 00:42:40,450
executed through my scheduler or it may

00:42:37,960 --> 00:42:43,030
just execute immediately an execution

00:42:40,450 --> 00:42:45,010
context matter right so I might have a

00:42:43,030 --> 00:42:47,020
it might be a little bit surprising and

00:42:45,010 --> 00:42:50,260
introduce weird bugs in my application

00:42:47,020 --> 00:42:52,359
if 99% of the time that thing gets

00:42:50,260 --> 00:42:53,980
scheduled and executed in some context

00:42:52,359 --> 00:42:55,780
but every once in a while you could that

00:42:53,980 --> 00:42:58,270
gets executed right now and whatever

00:42:55,780 --> 00:43:00,810
code is surrounding this call wasn't

00:42:58,270 --> 00:43:00,810
ready for that

00:43:00,839 --> 00:43:05,740
so a couple small issues but let's

00:43:03,730 --> 00:43:09,359
ignore those and let's stand back and

00:43:05,740 --> 00:43:13,630
look at the structure of this function

00:43:09,359 --> 00:43:16,300
right we can draw it now so what have we

00:43:13,630 --> 00:43:18,760
got we've got last idle we've got now

00:43:16,300 --> 00:43:20,710
and we've got delay and those are

00:43:18,760 --> 00:43:22,839
related to our win

00:43:20,710 --> 00:43:25,180
okay and then we take win and our tasks

00:43:22,839 --> 00:43:27,010
and those are related to invoke after

00:43:25,180 --> 00:43:29,349
and then invoke after is going to do

00:43:27,010 --> 00:43:30,700
some funky recursion thing and we're

00:43:29,349 --> 00:43:32,380
just gonna ignore that because it's just

00:43:30,700 --> 00:43:34,809
this graph repeated over and over so

00:43:32,380 --> 00:43:38,770
that's not interesting okay so that's

00:43:34,809 --> 00:43:40,780
the structure so what are the

00:43:38,770 --> 00:43:42,220
dependencies on this little function we

00:43:40,780 --> 00:43:44,650
have more dependencies than we have

00:43:42,220 --> 00:43:46,720
going on inside the function right we've

00:43:44,650 --> 00:43:49,000
got last idle is a global variable we've

00:43:46,720 --> 00:43:51,609
got now is some global function we've

00:43:49,000 --> 00:43:53,859
got our delay operation which is an

00:43:51,609 --> 00:43:55,990
argument coming in we've got our task

00:43:53,859 --> 00:43:58,930
operation which is our argument coming

00:43:55,990 --> 00:44:01,530
in and we've got a dependency on this

00:43:58,930 --> 00:44:07,900
global operation to do the scheduling

00:44:01,530 --> 00:44:09,190
okay and it's very clear when we look at

00:44:07,900 --> 00:44:13,650
it this way that we have two things

00:44:09,190 --> 00:44:15,730
going on inside of this function right

00:44:13,650 --> 00:44:17,349
we've got everything over here on the

00:44:15,730 --> 00:44:22,690
left and everything over on the right

00:44:17,349 --> 00:44:25,480
and they're very loosely connected right

00:44:22,690 --> 00:44:29,440
so let's just look at the first part of

00:44:25,480 --> 00:44:32,410
that what is this relationship right

00:44:29,440 --> 00:44:38,069
could somebody name this this structure

00:44:32,410 --> 00:44:38,069
what is this thing it's not a rotate

00:44:38,369 --> 00:44:45,460
okay this is what that is it's a timer

00:44:41,980 --> 00:44:48,640
it's like a kitchen timer okay a kitchen

00:44:45,460 --> 00:44:51,400
timer you can add time to it right and

00:44:48,640 --> 00:44:53,980
it ticks down you can't speed it up

00:44:51,400 --> 00:44:57,760
without breaking it okay but you can add

00:44:53,980 --> 00:45:01,500
more time to it right so that's what

00:44:57,760 --> 00:45:03,609
that structure is it's a kitchen timer

00:45:01,500 --> 00:45:05,290
so let's take another stab at writing

00:45:03,609 --> 00:45:08,380
this function we're going to call this

00:45:05,290 --> 00:45:10,329
on expiration okay and we're just gonna

00:45:08,380 --> 00:45:11,710
package up our timer and we're gonna say

00:45:10,329 --> 00:45:15,280
what we assume we have a timer

00:45:11,710 --> 00:45:17,440
somebody supplies us a timer now we see

00:45:15,280 --> 00:45:19,540
that when was really a pretty bad name

00:45:17,440 --> 00:45:21,549
for what came out of our timer what

00:45:19,540 --> 00:45:24,730
comes out of our timer is the remaining

00:45:21,549 --> 00:45:27,549
time so now we've got a better name here

00:45:24,730 --> 00:45:29,950
just for our variable so our timer gives

00:45:27,549 --> 00:45:32,349
us the amount of remaining time and then

00:45:29,950 --> 00:45:33,800
we've got our tasks and then we've got

00:45:32,349 --> 00:45:36,350
our scheduler

00:45:33,800 --> 00:45:38,630
okay so that's the other part of the

00:45:36,350 --> 00:45:43,460
structure and now we just have these

00:45:38,630 --> 00:45:45,410
three dependencies coming into this and

00:45:43,460 --> 00:45:46,640
so now we can rewrite our code and we'll

00:45:45,410 --> 00:45:48,350
just make those dependencies be

00:45:46,640 --> 00:45:50,000
arguments we don't have to assume some

00:45:48,350 --> 00:45:52,610
global scheduler you want to call me

00:45:50,000 --> 00:45:54,080
call me with your own scheduler execute

00:45:52,610 --> 00:45:57,020
the code where you want the code to be

00:45:54,080 --> 00:45:59,150
executed so now we've got this on

00:45:57,020 --> 00:46:01,460
expiration function and we're going to

00:45:59,150 --> 00:46:04,610
get the remaining time and if the

00:46:01,460 --> 00:46:06,740
timer's expired I'm sorry if the timer

00:46:04,610 --> 00:46:09,770
hasn't expired then we're gonna come

00:46:06,740 --> 00:46:11,480
back and check later right so I put the

00:46:09,770 --> 00:46:13,370
cookies in the oven and I set the timer

00:46:11,480 --> 00:46:15,440
to be five minutes I walk out of the

00:46:13,370 --> 00:46:17,000
room my wife might come in she might

00:46:15,440 --> 00:46:18,320
look in the oven and go hey those are

00:46:17,000 --> 00:46:20,390
gonna need about three more minutes

00:46:18,320 --> 00:46:23,240
and so she adds three minutes to the

00:46:20,390 --> 00:46:26,300
timer I come back after five minutes and

00:46:23,240 --> 00:46:29,510
I'm like oh three more minutes so I go

00:46:26,300 --> 00:46:34,310
and repeat right so that's what this is

00:46:29,510 --> 00:46:37,280
doing okay after the timer's expired we

00:46:34,310 --> 00:46:38,840
execute the task now I named this

00:46:37,280 --> 00:46:40,250
function with a little underscore on the

00:46:38,840 --> 00:46:42,350
end I would probably put it into a

00:46:40,250 --> 00:46:45,830
detail namespace or something if I were

00:46:42,350 --> 00:46:47,720
writing this code for production because

00:46:45,830 --> 00:46:50,510
we can now fix the little issue that we

00:46:47,720 --> 00:46:52,880
had about the context for the task by

00:46:50,510 --> 00:46:55,270
basically unrolling one round of our

00:46:52,880 --> 00:46:57,980
recursion and making sure that we always

00:46:55,270 --> 00:47:00,800
schedule or on expiration on the timer

00:46:57,980 --> 00:47:04,130
so now our task will always get executed

00:47:00,800 --> 00:47:06,080
through the scheduler right it will just

00:47:04,130 --> 00:47:08,650
get you know it may be that at the time

00:47:06,080 --> 00:47:10,490
we hit this the timers already expired

00:47:08,650 --> 00:47:15,620
all right we just want to make sure

00:47:10,490 --> 00:47:16,970
everything happens consistently okay so

00:47:15,620 --> 00:47:19,100
by looking at the structure of the

00:47:16,970 --> 00:47:21,260
function we can design a better function

00:47:19,100 --> 00:47:24,830
right this is a more general function

00:47:21,260 --> 00:47:28,160
it's a more useful function it has zero

00:47:24,830 --> 00:47:31,370
external dependencies not one it doesn't

00:47:28,160 --> 00:47:34,790
rely on STD chrono it doesn't use STD

00:47:31,370 --> 00:47:36,920
function it doesn't need some invoke

00:47:34,790 --> 00:47:41,240
after or some global variable for a last

00:47:36,920 --> 00:47:43,550
idle okay the only requirements here are

00:47:41,240 --> 00:47:45,260
the requirements between the arguments

00:47:43,550 --> 00:47:47,650
themselves which have a very particular

00:47:45,260 --> 00:47:50,050
structure my timer

00:47:47,650 --> 00:47:52,630
must we turn adoration that I can pass

00:47:50,050 --> 00:47:55,090
to my scheduler okay

00:47:52,630 --> 00:47:58,120
my task must be an object of the type

00:47:55,090 --> 00:48:00,010
that I can pass to my scheduler it's

00:47:58,120 --> 00:48:02,200
completely self-contained little

00:48:00,010 --> 00:48:05,130
universe right it's really a beautiful

00:48:02,200 --> 00:48:08,290
little thing okay

00:48:05,130 --> 00:48:10,270
very general purpose and if you look

00:48:08,290 --> 00:48:12,690
there's not even any heap allocations I

00:48:10,270 --> 00:48:17,560
never even called operator new in there

00:48:12,690 --> 00:48:22,630
and it solves the problem so let's take

00:48:17,560 --> 00:48:24,760
a look at another problem right this is

00:48:22,630 --> 00:48:26,590
the registry problem a registry is a

00:48:24,760 --> 00:48:28,930
container supporting the following

00:48:26,590 --> 00:48:30,940
operations right we can add an object

00:48:28,930 --> 00:48:33,580
and when we add an object we retain a

00:48:30,940 --> 00:48:36,640
receipt some kind of token to the thing

00:48:33,580 --> 00:48:39,220
we put in a registry we can use the

00:48:36,640 --> 00:48:45,730
receipt to retrieve the object or remove

00:48:39,220 --> 00:48:47,590
it okay we can operate on all the

00:48:45,730 --> 00:48:50,050
objects in the registry right so we

00:48:47,590 --> 00:48:51,220
should be able to just like cruise

00:48:50,050 --> 00:48:54,490
through and say do something to

00:48:51,220 --> 00:48:56,470
everything that was registered so one

00:48:54,490 --> 00:48:58,120
very common example of this our signal

00:48:56,470 --> 00:49:00,070
handlers right so I have a signal

00:48:58,120 --> 00:49:02,860
handler that's a registry I register a

00:49:00,070 --> 00:49:06,100
slot I get back to a receipt I can use

00:49:02,860 --> 00:49:08,260
that receipt to unregister my slot okay

00:49:06,100 --> 00:49:11,170
when a message get dispatched it

00:49:08,260 --> 00:49:15,880
iterates through everything within my

00:49:11,170 --> 00:49:18,610
registry to dispatch that message so

00:49:15,880 --> 00:49:21,700
that's a registry so I see this in code

00:49:18,610 --> 00:49:23,620
a surprising amount of time right people

00:49:21,700 --> 00:49:25,090
usually don't call it a registry even

00:49:23,620 --> 00:49:27,070
though it is a registry they call it a

00:49:25,090 --> 00:49:28,900
slot or a signal or something or

00:49:27,070 --> 00:49:31,000
something else whatever else they're

00:49:28,900 --> 00:49:34,600
building but what do they do they use

00:49:31,000 --> 00:49:35,890
either a map or an unordered map right

00:49:34,600 --> 00:49:37,300
and a lot of people if they see a map

00:49:35,890 --> 00:49:38,950
and a code review they'll say oh you

00:49:37,300 --> 00:49:40,210
should really use an unordered map there

00:49:38,950 --> 00:49:42,580
well there's actually an important

00:49:40,210 --> 00:49:44,140
distinction which is that a map would

00:49:42,580 --> 00:49:46,690
let us iterate everything in the order

00:49:44,140 --> 00:49:48,220
that things were put in okay which might

00:49:46,690 --> 00:49:49,810
be important in something like a slot

00:49:48,220 --> 00:49:51,460
signal handler that you know the first

00:49:49,810 --> 00:49:56,710
guy to register to receive a message is

00:49:51,460 --> 00:49:57,970
the first guy who gets the message and

00:49:56,710 --> 00:49:59,589
I'm gonna pause right there because I

00:49:57,970 --> 00:50:03,160
said guy

00:49:59,589 --> 00:50:05,859
and I say guy a lot at my talks and

00:50:03,160 --> 00:50:08,140
that's a bit of a problem I wish that I

00:50:05,859 --> 00:50:10,869
could weaken the postconditions on guy

00:50:08,140 --> 00:50:12,759
to mean everyone so if I accidentally

00:50:10,869 --> 00:50:24,869
say guy do not think that I am excluding

00:50:12,759 --> 00:50:30,099
anybody in this room okay

00:50:24,869 --> 00:50:31,539
so we've got this unordered map we've

00:50:30,099 --> 00:50:34,589
got this counter that we're going to use

00:50:31,539 --> 00:50:37,719
for handing out receipts we can append

00:50:34,589 --> 00:50:39,400
elements here okay into our registry

00:50:37,719 --> 00:50:42,160
maybe app and with an unordered map as a

00:50:39,400 --> 00:50:43,539
bad term but it started out as a map and

00:50:42,160 --> 00:50:44,680
then some kind of code reviews said it

00:50:43,539 --> 00:50:45,519
would be better if I made it an

00:50:44,680 --> 00:50:49,209
unordered map

00:50:45,519 --> 00:50:51,130
so we're appending them we can erase

00:50:49,209 --> 00:50:52,930
from the map and then we can iterate

00:50:51,130 --> 00:50:56,219
through everything that was in the

00:50:52,930 --> 00:51:00,189
registry so it's fairly straightforward

00:50:56,219 --> 00:51:05,349
so I get this in a code review and this

00:51:00,189 --> 00:51:10,749
is my expression okay yeah it's fine

00:51:05,349 --> 00:51:13,059
right so I'm going to introduce you to

00:51:10,749 --> 00:51:14,920
the Russian coat check algorithm I have

00:51:13,059 --> 00:51:17,229
no idea if this is how code checks

00:51:14,920 --> 00:51:18,699
actually work in Russia but I'm from

00:51:17,229 --> 00:51:27,069
California and we don't actually have

00:51:18,699 --> 00:51:30,189
coats so the first thing to realize here

00:51:27,069 --> 00:51:32,170
is that our receipts are ordered that's

00:51:30,189 --> 00:51:37,479
an important relationship we're handing

00:51:32,170 --> 00:51:38,890
them out so we can we got our our pad

00:51:37,479 --> 00:51:41,769
we're working the Russian coat check

00:51:38,890 --> 00:51:44,259
here so if somebody comes up we hand

00:51:41,769 --> 00:51:47,589
them a receipt we take the stub we take

00:51:44,259 --> 00:51:50,769
their jacket and we put it on the end of

00:51:47,589 --> 00:51:57,309
the rack just put it right on the end of

00:51:50,769 --> 00:51:58,929
the rack okay then somebody comes back

00:51:57,309 --> 00:52:01,029
with their receipt and they say I'd like

00:51:58,929 --> 00:52:03,069
my coat and you can say oh okay well

00:52:01,029 --> 00:52:06,420
that would be about here

00:52:03,069 --> 00:52:09,069
why because all the stubs are ordered

00:52:06,420 --> 00:52:12,760
okay so it's really easy to come along

00:52:09,069 --> 00:52:15,910
and find the item right

00:52:12,760 --> 00:52:17,860
at some point your rack is half-empty

00:52:15,910 --> 00:52:19,930
every time you pull out a coat off the

00:52:17,860 --> 00:52:21,910
rack you don't want to be like Oh slide

00:52:19,930 --> 00:52:24,190
those altogether you'll be spending all

00:52:21,910 --> 00:52:26,110
your time sliding coats together but at

00:52:24,190 --> 00:52:27,730
some point a bunch of the rack is empty

00:52:26,110 --> 00:52:29,080
and you're like okay now let's just push

00:52:27,730 --> 00:52:31,890
all the coats down and make room for

00:52:29,080 --> 00:52:35,620
more coats on the end

00:52:31,890 --> 00:52:39,280
okay so coats are always ordered by the

00:52:35,620 --> 00:52:41,320
receipt stubs and as an additional

00:52:39,280 --> 00:52:42,760
useful property courts are always

00:52:41,320 --> 00:52:45,640
ordered by the order that they were

00:52:42,760 --> 00:52:49,180
added to our container so the oldest

00:52:45,640 --> 00:52:53,320
coat is always at the back right and the

00:52:49,180 --> 00:52:55,660
newest coat is always at the front right

00:52:53,320 --> 00:52:59,710
so I could write a Russian coat check

00:52:55,660 --> 00:53:03,580
here I have a vector okay and it's a

00:52:59,710 --> 00:53:05,020
vector holding my stubs and an optional

00:53:03,580 --> 00:53:06,670
value that I want to put in I'm gonna

00:53:05,020 --> 00:53:10,120
use optional because I want to be able

00:53:06,670 --> 00:53:16,810
to remove the coat and leave the slot in

00:53:10,120 --> 00:53:18,820
the rack okay the size here is is the

00:53:16,810 --> 00:53:20,260
number of coats that are actually in the

00:53:18,820 --> 00:53:21,790
rack which is a little different than

00:53:20,260 --> 00:53:23,560
the number of elements in my vector

00:53:21,790 --> 00:53:27,160
because some of the elements were dead

00:53:23,560 --> 00:53:29,440
they got removed and the ID is the same

00:53:27,160 --> 00:53:30,730
thing here this is this is my notepad

00:53:29,440 --> 00:53:36,190
that I'm going to use to hand out

00:53:30,730 --> 00:53:37,690
receipts and stubs okay so now my hand

00:53:36,190 --> 00:53:40,900
looks like this and now append is

00:53:37,690 --> 00:53:43,090
magically a better name I can take my

00:53:40,900 --> 00:53:47,050
coats and I put them on the back of my

00:53:43,090 --> 00:53:49,660
vector and I can increment the size the

00:53:47,050 --> 00:53:52,420
count of the number of coats I have and

00:53:49,660 --> 00:53:53,740
I returned the receipts there so this is

00:53:52,420 --> 00:53:57,670
what it looks like we've got all the

00:53:53,740 --> 00:54:00,040
stubs and we've got coats a through H if

00:53:57,670 --> 00:54:04,030
I want to erase one I can use lower

00:54:00,040 --> 00:54:06,970
bound to go and find the coat which may

00:54:04,030 --> 00:54:10,510
not be there in which case we're just

00:54:06,970 --> 00:54:13,450
gonna bail okay but if we've got it

00:54:10,510 --> 00:54:16,150
we'll just mark it dead we'll just reset

00:54:13,450 --> 00:54:17,680
the optional value and we'll decrement

00:54:16,150 --> 00:54:22,810
the number of coats that we're keeping

00:54:17,680 --> 00:54:25,540
track of and then if the number of coats

00:54:22,810 --> 00:54:27,790
that we have in the rack is less than

00:54:25,540 --> 00:54:29,380
half of the number of elements that we

00:54:27,790 --> 00:54:30,660
have in the vector the space that we

00:54:29,380 --> 00:54:32,860
have for coats

00:54:30,660 --> 00:54:36,400
only then we're gonna come along and

00:54:32,860 --> 00:54:39,520
we're gonna make a pass right and we're

00:54:36,400 --> 00:54:41,710
going to remove all the blank slots and

00:54:39,520 --> 00:54:46,450
compress everything down so that we have

00:54:41,710 --> 00:54:49,000
space for the new coats okay does

00:54:46,450 --> 00:54:54,100
everybody follow pretty straightforward

00:54:49,000 --> 00:54:57,400
lots of nodding good okay so what does

00:54:54,100 --> 00:54:59,470
that look like so we come along we mark

00:54:57,400 --> 00:55:00,970
a bunch of things dead as people are

00:54:59,470 --> 00:55:02,500
retrieving their codes we've got empty

00:55:00,970 --> 00:55:04,810
slots in the rack now we have more than

00:55:02,500 --> 00:55:08,320
half the empty slots so we go through

00:55:04,810 --> 00:55:10,180
and we compress everything down okay now

00:55:08,320 --> 00:55:12,580
notice we're still ordered our stubs are

00:55:10,180 --> 00:55:17,080
still 0-3 for our binary search is still

00:55:12,580 --> 00:55:19,450
going to work and we can add additional

00:55:17,080 --> 00:55:22,780
elements and everything stays in order

00:55:19,450 --> 00:55:24,610
and the code continues to work okay and

00:55:22,780 --> 00:55:29,860
we can iterate through all the items we

00:55:24,610 --> 00:55:33,070
just skip over the dead slots right so

00:55:29,860 --> 00:55:37,750
if we look at the timing on this okay if

00:55:33,070 --> 00:55:41,170
we come along and we we register a bunch

00:55:37,750 --> 00:55:43,720
of coats into our system here our

00:55:41,170 --> 00:55:45,490
unordered map takes this long to add

00:55:43,720 --> 00:55:49,300
we're just adding elements at this point

00:55:45,490 --> 00:55:51,700
to add a whole bunch of coats our vector

00:55:49,300 --> 00:55:56,800
only takes that long to add a whole

00:55:51,700 --> 00:55:59,620
bunch of coats okay how long would it

00:55:56,800 --> 00:56:05,170
take to iterate all of the coats we put

00:55:59,620 --> 00:56:09,820
in there by comparison anybody about

00:56:05,170 --> 00:56:12,820
that long okay the gap between these two

00:56:09,820 --> 00:56:14,490
is about 640 I can iterate through all

00:56:12,820 --> 00:56:17,410
the coats

00:56:14,490 --> 00:56:21,220
640 times in the Delta between the time

00:56:17,410 --> 00:56:25,450
it took me to add the coats what didn't

00:56:21,220 --> 00:56:29,040
I tell you in these statements how many

00:56:25,450 --> 00:56:33,040
coats does it matter

00:56:29,040 --> 00:56:37,010
did I profile this with ten coats with a

00:56:33,040 --> 00:56:41,070
hundred coats with a million coats

00:56:37,010 --> 00:56:43,140
it doesn't matter and here's why what

00:56:41,070 --> 00:56:45,990
dominates this graph is the number of

00:56:43,140 --> 00:56:50,010
allocations I'm making okay

00:56:45,990 --> 00:56:53,700
so a vector for a number of allocations

00:56:50,010 --> 00:56:58,460
we know a vector grows grows linear but

00:56:53,700 --> 00:57:03,900
the allocations grow by log n okay an

00:56:58,460 --> 00:57:08,460
unordered map grows by log n plus n for

00:57:03,900 --> 00:57:11,250
the number of allocations okay so what

00:57:08,460 --> 00:57:16,770
we're timing with the 640 iterations is

00:57:11,250 --> 00:57:22,500
the difference in time here okay that it

00:57:16,770 --> 00:57:26,130
takes to add one element and that grows

00:57:22,500 --> 00:57:28,830
linearly one to one so it's 640 if it's

00:57:26,130 --> 00:57:31,710
five if it's ten if it's an a million

00:57:28,830 --> 00:57:35,670
now it will eventually start to bend up

00:57:31,710 --> 00:57:37,590
because of eventually the insertion

00:57:35,670 --> 00:57:41,760
behavior of the vector will move from

00:57:37,590 --> 00:57:43,590
login to flat but really small right

00:57:41,760 --> 00:57:47,610
maybe they'll get down to 600 out around

00:57:43,590 --> 00:57:49,770
four billion okay that's a lot of times

00:57:47,610 --> 00:57:53,960
that I could do a linear search and I'm

00:57:49,770 --> 00:57:53,960
not even doing a binary search for coats

00:57:55,400 --> 00:58:03,450
so architecture is recognizing that you

00:58:01,200 --> 00:58:06,060
have relationships that can be exploited

00:58:03,450 --> 00:58:09,770
for performance now I could probably

00:58:06,060 --> 00:58:13,830
come along and get the same win here on

00:58:09,770 --> 00:58:18,150
our codes by using something like a flat

00:58:13,830 --> 00:58:20,130
a flat a hash map of some kind right I

00:58:18,150 --> 00:58:23,430
could get the allocation performance and

00:58:20,130 --> 00:58:26,310
still have the hashing win right I could

00:58:23,430 --> 00:58:27,330
pull a library to do that but it's also

00:58:26,310 --> 00:58:29,550
important that I understand the

00:58:27,330 --> 00:58:31,830
relationships which is what Andre was

00:58:29,550 --> 00:58:34,260
saying between the relative cost of

00:58:31,830 --> 00:58:37,760
performance of my operations right

00:58:34,260 --> 00:58:37,760
that's important too

00:58:40,530 --> 00:58:49,440
which finally brings us back to our goal

00:58:42,450 --> 00:58:51,150
of no contradictions and so we're going

00:58:49,440 --> 00:58:53,370
to go back in time a little bit here

00:58:51,150 --> 00:59:00,030
who knows what double-entry bookkeeping

00:58:53,370 --> 00:59:02,610
is relatively small number okay

00:59:00,030 --> 00:59:04,140
so double entry bookkeeping is something

00:59:02,610 --> 00:59:05,670
that an accountant would know if you

00:59:04,140 --> 00:59:07,800
guys were all accountants you would know

00:59:05,670 --> 00:59:09,870
this immediately double entry

00:59:07,800 --> 00:59:13,130
bookkeeping is an accounting tool for

00:59:09,870 --> 00:59:15,840
error detection and fraud prevention

00:59:13,130 --> 00:59:18,090
right it relies on something known as

00:59:15,840 --> 00:59:23,340
the accounting equation which is assets

00:59:18,090 --> 00:59:26,460
is equal to liabilities plus equity by

00:59:23,340 --> 00:59:29,460
ensuring that all transactions are made

00:59:26,460 --> 00:59:31,590
against two separate accounts okay

00:59:29,460 --> 00:59:33,630
within our system that's why it's called

00:59:31,590 --> 00:59:36,050
double entry right we have one

00:59:33,630 --> 00:59:38,400
transaction we're gonna enter two times

00:59:36,050 --> 00:59:41,790
and it should be a minimum of two

00:59:38,400 --> 00:59:43,800
separate accounts the probably the

00:59:41,790 --> 00:59:48,360
probability of error is significantly

00:59:43,800 --> 00:59:50,550
reduced okay if I do the math twice and

00:59:48,360 --> 00:59:53,790
then I apply this equation assets equals

00:59:50,550 --> 00:59:56,400
liabilities plus equity and that doesn't

00:59:53,790 --> 01:00:00,360
hold then I made a mistake somewhere in

00:59:56,400 --> 01:00:02,850
my math through double entry bookkeeping

01:00:00,360 --> 01:00:05,340
and accounting transparency making it

01:00:02,850 --> 01:00:07,230
easier to audit and detect fraud and in

01:00:05,340 --> 01:00:09,270
fact at a lot of banks you will actually

01:00:07,230 --> 01:00:12,360
have two separate individuals who are

01:00:09,270 --> 01:00:13,830
entering each side of the balance to

01:00:12,360 --> 01:00:18,180
make sure that nobody's cheating and

01:00:13,830 --> 01:00:25,080
introducing offsetting errors right this

01:00:18,180 --> 01:00:26,880
is an example of equational reasoning so

01:00:25,080 --> 01:00:30,030
this was pioneered in the 11th century

01:00:26,880 --> 01:00:31,950
by the Jewish banking community it

01:00:30,030 --> 01:00:35,070
likely developed independently in Korea

01:00:31,950 --> 01:00:36,750
in about the same time period in the

01:00:35,070 --> 01:00:39,900
14th century double-entry bookkeeping

01:00:36,750 --> 01:00:42,170
was adopted by the Medici bank how many

01:00:39,900 --> 01:00:44,910
people have heard of the Medici family

01:00:42,170 --> 01:00:47,700
way more people than who have heard

01:00:44,910 --> 01:00:49,440
about double-entry bookkeeping right

01:00:47,700 --> 01:00:51,390
well double entry bookkeeping is

01:00:49,440 --> 01:00:54,109
credited with establishing the Medici

01:00:51,390 --> 01:00:56,029
bank as reliable and trustworthy

01:00:54,109 --> 01:00:57,499
didn't make mistakes they didn't lose

01:00:56,029 --> 01:01:00,259
your money they could tell you where

01:00:57,499 --> 01:01:02,239
your money came from this led to the

01:01:00,259 --> 01:01:06,380
rise of one of the most powerful family

01:01:02,239 --> 01:01:07,940
dynasties in history right so

01:01:06,380 --> 01:01:10,819
double-entry bookkeeping was later

01:01:07,940 --> 01:01:16,190
codified by a Luca Pacioli the father of

01:01:10,819 --> 01:01:19,160
accounting in 1494 so the monk here in

01:01:16,190 --> 01:01:22,190
the foreground is Luca Pacioli you can

01:01:19,160 --> 01:01:24,710
see he's probably a Euclid Elements fan

01:01:22,190 --> 01:01:26,420
he's got Euclid solids here and it's

01:01:24,710 --> 01:01:28,670
probably Euclid that he's reading in the

01:01:26,420 --> 01:01:33,529
book there we don't actually know who

01:01:28,670 --> 01:01:36,440
the guy is photobombing the picture he's

01:01:33,529 --> 01:01:38,539
referred to as as the just the student

01:01:36,440 --> 01:01:45,739
and some people think he might be an

01:01:38,539 --> 01:01:47,480
artist known as gerar so every

01:01:45,739 --> 01:01:49,549
transaction is entered twice two

01:01:47,480 --> 01:01:55,359
separate accounts there are five

01:01:49,549 --> 01:01:57,499
standard accounts this ensures the

01:01:55,359 --> 01:01:59,779
mechanical process is done in two

01:01:57,499 --> 01:02:03,380
distinct ways right it's not just like I

01:01:59,779 --> 01:02:05,269
have a hundred and I add ten and I get a

01:02:03,380 --> 01:02:06,680
hundred and ten and I have a hundred and

01:02:05,269 --> 01:02:08,390
I had ten and I get one hundred and ten

01:02:06,680 --> 01:02:13,220
I'm not doing exactly the same thing

01:02:08,390 --> 01:02:15,619
twice okay and if the accounting

01:02:13,220 --> 01:02:18,769
equation is not satisfied then we have a

01:02:15,619 --> 01:02:22,579
contradiction there's that word again

01:02:18,769 --> 01:02:26,150
right our relationship of equality does

01:02:22,579 --> 01:02:30,799
not hold but it must hold our constraint

01:02:26,150 --> 01:02:32,630
is violated okay so the next time

01:02:30,799 --> 01:02:35,239
somebody asks you well what's the value

01:02:32,630 --> 01:02:37,489
of unit testing you can answer well

01:02:35,239 --> 01:02:43,759
what's the value of the biggest bache in

01:02:37,489 --> 01:02:45,289
European history this is why we write

01:02:43,759 --> 01:02:48,140
unit tests we're trying to find

01:02:45,289 --> 01:02:50,150
contradictions this is why people have

01:02:48,140 --> 01:02:52,009
them is somewhat mistaken notion that

01:02:50,150 --> 01:02:54,529
software is correct if the software

01:02:52,009 --> 01:02:55,519
matches the specification all right the

01:02:54,529 --> 01:02:57,170
problem there is if there's a

01:02:55,519 --> 01:02:59,599
contradiction between the specification

01:02:57,170 --> 01:03:01,640
and the software it's actually more

01:02:59,599 --> 01:03:05,269
likely those the specification that's

01:03:01,640 --> 01:03:07,069
wrong and not the software right what

01:03:05,269 --> 01:03:07,460
we're saying is that software is correct

01:03:07,069 --> 01:03:11,630
when the

01:03:07,460 --> 01:03:13,640
tire ecosystem is consistent right so

01:03:11,630 --> 01:03:17,030
when two relationships imply the same

01:03:13,640 --> 01:03:20,690
entity has different values that's what

01:03:17,030 --> 01:03:23,000
a contradiction is relationships are

01:03:20,690 --> 01:03:25,340
consistent if they imply the entity has

01:03:23,000 --> 01:03:28,940
the same value if our accounting

01:03:25,340 --> 01:03:32,390
equation holds that means every

01:03:28,940 --> 01:03:35,450
contradiction has this structure okay we

01:03:32,390 --> 01:03:39,680
have two relationships and they imply an

01:03:35,450 --> 01:03:42,050
entity okay this may be consistent those

01:03:39,680 --> 01:03:44,960
two relationships may imply exactly the

01:03:42,050 --> 01:03:47,540
same entity or it may be a contradiction

01:03:44,960 --> 01:03:50,000
right so not everything with this

01:03:47,540 --> 01:03:52,750
structure is a contradiction but every

01:03:50,000 --> 01:03:57,830
contradiction has this structure

01:03:52,750 --> 01:04:01,460
everyone this is the structure of a race

01:03:57,830 --> 01:04:03,650
condition okay this is exactly the

01:04:01,460 --> 01:04:06,470
structure of a race condition we have

01:04:03,650 --> 01:04:08,810
when two or more threads access the same

01:04:06,470 --> 01:04:12,200
object the same entity concurrently and

01:04:08,810 --> 01:04:14,630
at least one of them is writing we have

01:04:12,200 --> 01:04:19,330
a race condition okay

01:04:14,630 --> 01:04:23,090
if they're both reading is consistent

01:04:19,330 --> 01:04:29,570
but if one of them is writing it's a

01:04:23,090 --> 01:04:32,390
contradiction okay we can solve this by

01:04:29,570 --> 01:04:33,620
throwing in a mutex we just add some

01:04:32,390 --> 01:04:35,810
additional relationship that

01:04:33,620 --> 01:04:40,280
synchronizes those so that only one

01:04:35,810 --> 01:04:43,100
value goes through but what does that

01:04:40,280 --> 01:04:45,080
mean right ask somebody in a code review

01:04:43,100 --> 01:04:47,180
who plops in a relationship into the

01:04:45,080 --> 01:04:50,900
middle of their code what did you mean

01:04:47,180 --> 01:04:53,840
by that try to describe the relationship

01:04:50,900 --> 01:04:55,190
of a mutex right well it's mutually

01:04:53,840 --> 01:04:57,920
exclusive and you're like well what do I

01:04:55,190 --> 01:05:00,680
get out well the last thing that was

01:04:57,920 --> 01:05:04,460
there when I put it there well what does

01:05:00,680 --> 01:05:07,340
that mean right right is it random is it

01:05:04,460 --> 01:05:09,260
intentionally random right you can't

01:05:07,340 --> 01:05:11,570
reason about a mutex without knowing a

01:05:09,260 --> 01:05:14,030
whole lot about what's going on in the

01:05:11,570 --> 01:05:17,420
rest of your system maybe it has meaning

01:05:14,030 --> 01:05:18,800
but in isolation all by itself it's a

01:05:17,420 --> 01:05:20,990
very difficult thing to think about

01:05:18,800 --> 01:05:22,940
right so if you have

01:05:20,990 --> 01:05:25,010
race condition and you plop in a mutex

01:05:22,940 --> 01:05:27,740
to solve it this is going to be my face

01:05:25,010 --> 01:05:30,710
in the code review right right

01:05:27,740 --> 01:05:33,260
did you fix the problem I don't know

01:05:30,710 --> 01:05:35,860
right you just patched it you probably

01:05:33,260 --> 01:05:39,460
just shifted the problem somewhere else

01:05:35,860 --> 01:05:41,840
so no Ross synchronization primitives

01:05:39,460 --> 01:05:43,700
one of the titles from my other talk we

01:05:41,840 --> 01:05:45,410
need to get up into something that has

01:05:43,700 --> 01:05:47,510
higher-level meaning that we can reason

01:05:45,410 --> 01:05:49,640
about this is why futures and

01:05:47,510 --> 01:05:51,740
co-routines are an incredibly important

01:05:49,640 --> 01:05:55,550
concepts right so that we can lift up

01:05:51,740 --> 01:05:58,460
out of here what about a null pointer

01:05:55,550 --> 01:06:00,140
dereference well the C++ specification

01:05:58,460 --> 01:06:04,340
says the dereferencing a null pointer is

01:06:00,140 --> 01:06:05,570
undefined behavior right so we have a

01:06:04,340 --> 01:06:08,240
piece of code that looks like this

01:06:05,570 --> 01:06:13,040
Pierrot member and we get this sick

01:06:08,240 --> 01:06:14,480
abort right that's pretty undefined all

01:06:13,040 --> 01:06:17,330
right so what's going on here well the

01:06:14,480 --> 01:06:20,000
standard says you cannot the little

01:06:17,330 --> 01:06:22,490
sideways L is not you cannot dereference

01:06:20,000 --> 01:06:25,000
null right I have to figure out how to

01:06:22,490 --> 01:06:29,570
put not dereference a null into a circle

01:06:25,000 --> 01:06:34,880
and yet we do reference null so this

01:06:29,570 --> 01:06:39,020
must be true it was false okay undefined

01:06:34,880 --> 01:06:40,670
behavior that is the link well how do we

01:06:39,020 --> 01:06:44,060
fix this well we could just throw in a

01:06:40,670 --> 01:06:49,190
conditional and check right we just

01:06:44,060 --> 01:06:51,380
write if P then P arrow this is the

01:06:49,190 --> 01:06:53,210
moral equivalent of saying oh I've got

01:06:51,380 --> 01:06:55,550
an assert in my code that says assert

01:06:53,210 --> 01:06:58,430
this can't ever happen so what I'll do

01:06:55,550 --> 01:07:01,850
is I'll say well around my assert I'll

01:06:58,430 --> 01:07:12,050
say well if it is gonna happen skip the

01:07:01,850 --> 01:07:14,510
assert okay that's what this is now not

01:07:12,050 --> 01:07:17,540
always though the graceful handling of

01:07:14,510 --> 01:07:18,800
nothing as a limit is important right we

01:07:17,540 --> 01:07:20,900
want to make sure that we gracefully

01:07:18,800 --> 01:07:23,380
handle empty ranges that we gracefully

01:07:20,900 --> 01:07:25,790
handle the value zero as a limit right

01:07:23,380 --> 01:07:28,910
we have something and we can have

01:07:25,790 --> 01:07:31,400
nothing okay well we can't just remove

01:07:28,910 --> 01:07:33,990
sections of arbitrary code to avoid a

01:07:31,400 --> 01:07:35,220
crash that is not look

01:07:33,990 --> 01:07:37,170
at the structure that is not

01:07:35,220 --> 01:07:39,960
architecting our system that's the

01:07:37,170 --> 01:07:43,670
novice chess player right just whipping

01:07:39,960 --> 01:07:43,670
his queen into the middle of the board

01:07:44,090 --> 01:07:52,770
that's my reaction in the code review

01:07:48,080 --> 01:07:54,840
okay so a pro tip use strong

01:07:52,770 --> 01:07:56,850
preconditions to move the issue to the

01:07:54,840 --> 01:07:59,610
caller okay

01:07:56,850 --> 01:08:02,040
this sounds a little counterintuitive

01:07:59,610 --> 01:08:04,710
but you have a piece of code like this

01:08:02,040 --> 01:08:07,260
right which is dereferencing this member

01:08:04,710 --> 01:08:10,350
and we already patched it do we really

01:08:07,260 --> 01:08:13,800
have any any reason to have a pointer

01:08:10,350 --> 01:08:15,900
coming in here to begin with right do we

01:08:13,800 --> 01:08:17,460
need it to be a pointer maybe we could

01:08:15,900 --> 01:08:19,790
just make it a reference and we could

01:08:17,460 --> 01:08:25,609
make it the other guy's problem

01:08:19,790 --> 01:08:25,609
my dad used to have a saying that was

01:08:28,069 --> 01:08:34,380
your fix doesn't have to last forever it

01:08:31,589 --> 01:08:42,060
only has to last until the next person's

01:08:34,380 --> 01:08:44,730
shift okay so what are we doing here

01:08:42,060 --> 01:08:48,210
we should't inside of every function say

01:08:44,730 --> 01:08:51,330
if you hand me meaningless nonsense that

01:08:48,210 --> 01:08:55,049
I will somehow try to make lemonade out

01:08:51,330 --> 01:08:58,130
of that okay what you want to say is

01:08:55,049 --> 01:09:00,690
don't hand me meaningless nonsense

01:08:58,130 --> 01:09:04,730
percolate this up and catch the issue

01:09:00,690 --> 01:09:08,460
outside so let's look at one more thing

01:09:04,730 --> 01:09:10,620
this is a really subtle one okay we have

01:09:08,460 --> 01:09:13,080
two functions setting the same value

01:09:10,620 --> 01:09:14,850
through a shared pointer and I'm using

01:09:13,080 --> 01:09:19,830
pointer very liberally here this could

01:09:14,850 --> 01:09:21,810
be a shared reference even okay so so

01:09:19,830 --> 01:09:23,549
what do I mean like we have some p and

01:09:21,810 --> 01:09:27,750
we call set property some value and

01:09:23,549 --> 01:09:30,750
somewhere else in the code we also have

01:09:27,750 --> 01:09:34,830
P set property and those peas are

01:09:30,750 --> 01:09:38,900
referring to the same object okay that's

01:09:34,830 --> 01:09:38,900
this structure right here

01:09:39,469 --> 01:09:46,219
what are the possible meanings of that

01:09:41,690 --> 01:09:47,989
in your code could be that the code is

01:09:46,219 --> 01:09:49,819
redundant that they're always setting

01:09:47,989 --> 01:09:54,080
the same value everything is consistent

01:09:49,819 --> 01:09:56,030
just one of them is unnecessary it could

01:09:54,080 --> 01:09:58,219
mean that there are different sides of

01:09:56,030 --> 01:10:00,800
the same relationship right we might

01:09:58,219 --> 01:10:02,930
have a relationship on our property

01:10:00,800 --> 01:10:06,260
which is our property is equal to some a

01:10:02,930 --> 01:10:09,230
times B and we set it in one place when

01:10:06,260 --> 01:10:12,710
a changes and we set it in a different

01:10:09,230 --> 01:10:13,310
place when B changes okay if you're

01:10:12,710 --> 01:10:15,199
doing that

01:10:13,310 --> 01:10:16,699
how long until somebody screws that up

01:10:15,199 --> 01:10:19,790
and modifies one side of the

01:10:16,699 --> 01:10:21,410
relationship right you have two separate

01:10:19,790 --> 01:10:25,010
pieces of code representing one

01:10:21,410 --> 01:10:27,350
relationship it could be that they're

01:10:25,010 --> 01:10:29,540
mutually exclusive that at any point in

01:10:27,350 --> 01:10:32,239
time only the relationship represented

01:10:29,540 --> 01:10:35,180
by one side or the other holds right

01:10:32,239 --> 01:10:37,489
right so never simultaneously hence

01:10:35,180 --> 01:10:41,300
never a contradiction they're separated

01:10:37,489 --> 01:10:43,219
by time okay but that means that there's

01:10:41,300 --> 01:10:45,710
some controlling entity that determines

01:10:43,219 --> 01:10:48,730
that that is outside of both of those

01:10:45,710 --> 01:10:51,050
operations okay

01:10:48,730 --> 01:10:54,350
so you have to figure out how to reason

01:10:51,050 --> 01:10:55,850
about that it could really mean that

01:10:54,350 --> 01:10:58,040
what the user intended is just the last

01:10:55,850 --> 01:11:01,010
one in wins that is the relationship

01:10:58,040 --> 01:11:04,190
right right it was carefully architected

01:11:01,010 --> 01:11:09,410
to be last one in in a wins probably not

01:11:04,190 --> 01:11:12,110
that's a very unusual relationship it

01:11:09,410 --> 01:11:14,469
could be some incidental algorithm what

01:11:12,110 --> 01:11:16,699
I mean for that is we could be

01:11:14,469 --> 01:11:18,560
calculating things in some kind of graph

01:11:16,699 --> 01:11:19,910
and we're setting this value repeatedly

01:11:18,560 --> 01:11:21,680
and we're reading it from other places

01:11:19,910 --> 01:11:23,570
and we're resetting it and eventually

01:11:21,680 --> 01:11:26,980
we're going we're going to converge on

01:11:23,570 --> 01:11:30,800
the value that it actually is right

01:11:26,980 --> 01:11:32,810
that's worse than a raw loop right we

01:11:30,800 --> 01:11:35,570
don't want incidental algorithms flowing

01:11:32,810 --> 01:11:37,010
throughout our code either it could be

01:11:35,570 --> 01:11:38,960
that the property isn't really a

01:11:37,010 --> 01:11:41,210
property but it really represents some

01:11:38,960 --> 01:11:43,219
sort of stream or a latch or a trigger

01:11:41,210 --> 01:11:44,600
maybe it's a dirty flag that I'm setting

01:11:43,219 --> 01:11:46,250
and everybody's gonna set the dirty flag

01:11:44,600 --> 01:11:48,500
to be true and then somebody else's

01:11:46,250 --> 01:11:52,600
responsibility is to read it and clear

01:11:48,500 --> 01:11:52,600
it right maybe

01:11:53,300 --> 01:12:00,630
or it's just wrong I'm not saying that's

01:11:56,730 --> 01:12:02,160
wrong but it's probably wrong right I

01:12:00,630 --> 01:12:04,680
really wish that I could have a static

01:12:02,160 --> 01:12:06,510
analyzer or even a dynamic analyzer they

01:12:04,680 --> 01:12:08,970
could decorate my objects and say hey

01:12:06,510 --> 01:12:11,640
you are setting this property from two

01:12:08,970 --> 01:12:15,510
distinct places in your code and on the

01:12:11,640 --> 01:12:17,640
same object it's probably a bug I went

01:12:15,510 --> 01:12:18,870
through a photoshop codebase looking for

01:12:17,640 --> 01:12:20,970
a good examples here and I actually

01:12:18,870 --> 01:12:23,010
found a couple of bugs going through

01:12:20,970 --> 01:12:24,660
trying to find places where where a

01:12:23,010 --> 01:12:25,290
property was getting set from multiple

01:12:24,660 --> 01:12:27,990
places

01:12:25,290 --> 01:12:29,640
now I didn't bring the examples because

01:12:27,990 --> 01:12:31,020
the examples were all kind of funky

01:12:29,640 --> 01:12:33,030
right they were doing things like one

01:12:31,020 --> 01:12:35,300
piece of code was setting the was saving

01:12:33,030 --> 01:12:37,770
away the property setting the property

01:12:35,300 --> 01:12:39,630
clearly the intent and then running some

01:12:37,770 --> 01:12:42,180
calculation and clearly the intent was

01:12:39,630 --> 01:12:47,580
to restore the property but they forgot

01:12:42,180 --> 01:12:49,830
the restore part okay so so they weren't

01:12:47,580 --> 01:12:51,270
good examples to show kind of the

01:12:49,830 --> 01:12:53,550
contradiction structure but they were

01:12:51,270 --> 01:12:55,050
good examples just to show that if

01:12:53,550 --> 01:12:57,330
you're doing this you're probably not

01:12:55,050 --> 01:12:59,910
thinking through your code and there's

01:12:57,330 --> 01:13:02,100
just random things that are going wrong

01:12:59,910 --> 01:13:04,170
somewhere right or it could just mean

01:13:02,100 --> 01:13:07,730
Photoshop 30 years old and if you look

01:13:04,170 --> 01:13:07,730
at it for 15 minutes you'll find a bug

01:13:10,190 --> 01:13:17,190
yeah so when I see this that's my

01:13:12,840 --> 01:13:20,070
reaction in the code review so no raw

01:13:17,190 --> 01:13:23,280
pointers right try not to share data

01:13:20,070 --> 01:13:30,170
keep your reasoning local think through

01:13:23,280 --> 01:13:33,600
your objects so what does this mean

01:13:30,170 --> 01:13:36,960
means we need to try to learn to play

01:13:33,600 --> 01:13:39,030
the game right we need to learn as

01:13:36,960 --> 01:13:41,810
developers to consider the essential

01:13:39,030 --> 01:13:42,990
relationships and that's really hard

01:13:41,810 --> 01:13:44,970
okay

01:13:42,990 --> 01:13:46,860
because just like everyone in this room

01:13:44,970 --> 01:13:49,950
is involved in a relationship with

01:13:46,860 --> 01:13:52,110
everyone else there is an astronomical

01:13:49,950 --> 01:13:53,820
number of relationships you're looking

01:13:52,110 --> 01:13:57,390
at when you're reading a piece of code

01:13:53,820 --> 01:13:58,890
right if you are the novice chess player

01:13:57,390 --> 01:14:00,420
who's thinking about well what if I move

01:13:58,890 --> 01:14:01,620
this piece here what if I moved him here

01:14:00,420 --> 01:14:03,030
what if I moved him here and what if it

01:14:01,620 --> 01:14:05,970
when I moved him here he moved him here

01:14:03,030 --> 01:14:08,640
right you're not playing the game

01:14:05,970 --> 01:14:12,540
you have to learn to see at least the

01:14:08,640 --> 01:14:17,040
board okay what is the structure what is

01:14:12,540 --> 01:14:19,950
actually going on here learn to see that

01:14:17,040 --> 01:14:22,940
structure formed by all the essential

01:14:19,950 --> 01:14:26,190
relationships and then learn to move

01:14:22,940 --> 01:14:27,900
intentionally right don't just come

01:14:26,190 --> 01:14:30,720
along and say hey this doesn't work let

01:14:27,900 --> 01:14:33,630
me throw in a patch right I crashed tear

01:14:30,720 --> 01:14:35,310
patched that right you have to think

01:14:33,630 --> 01:14:37,440
through the implications of that in the

01:14:35,310 --> 01:14:38,820
rest of your system you have to look at

01:14:37,440 --> 01:14:40,710
the structure of your system and say

01:14:38,820 --> 01:14:43,080
this is what I want the structure to be

01:14:40,710 --> 01:14:45,110
not this is the structure it happens to

01:14:43,080 --> 01:14:45,110
be

01:14:45,260 --> 01:14:51,930
that's architecting the code okay so now

01:14:50,730 --> 01:14:54,810
you guys are all going to go off and

01:14:51,930 --> 01:14:57,930
stop talking about rotate and start

01:14:54,810 --> 01:15:01,010
talking about relationships right well

01:14:57,930 --> 01:15:01,010
thank you

01:15:11,200 --> 01:15:18,020
so before I take questions

01:15:13,610 --> 01:15:22,070
two quick slides if you want to find my

01:15:18,020 --> 01:15:23,870
talks and papers and ramblings I tend to

01:15:22,070 --> 01:15:27,140
post them here this talk will be up

01:15:23,870 --> 01:15:29,330
there as soon as I get a chance to to

01:15:27,140 --> 01:15:34,969
finalize it and add a little bit to my

01:15:29,330 --> 01:15:36,950
website me being here is partially

01:15:34,969 --> 01:15:38,960
sponsored by Adobe allowing me to be

01:15:36,950 --> 01:15:41,000
here and I work on the Photoshop team

01:15:38,960 --> 01:15:43,880
and Photoshop is hiring so you can go to

01:15:41,000 --> 01:15:45,469
Photoshop is hiring calm and you can

01:15:43,880 --> 01:15:49,580
find both the open positions on the

01:15:45,469 --> 01:15:52,090
Photoshop team and you can find links to

01:15:49,580 --> 01:16:00,260
open positions at Adobe in general

01:15:52,090 --> 01:16:07,520
thank you questions about why efficiency

01:16:00,260 --> 01:16:12,940
and safety this is sure so let's try to

01:16:07,520 --> 01:16:17,390
prove this very quickly I have a a

01:16:12,940 --> 01:16:19,580
vector of items that I want to sort okay

01:16:17,390 --> 01:16:22,460
or perform any permutation on it it

01:16:19,580 --> 01:16:26,780
doesn't even have to be sort in order to

01:16:22,460 --> 01:16:31,460
do that at one point I need to lift one

01:16:26,780 --> 01:16:33,260
of those objects out of my vector at the

01:16:31,460 --> 01:16:34,100
point that I lift the objects I have a

01:16:33,260 --> 01:16:36,830
choice

01:16:34,100 --> 01:16:38,420
I can either fill in some kind of

01:16:36,830 --> 01:16:41,030
meaning into the rest of my structure

01:16:38,420 --> 01:16:42,400
but that requires writing data back into

01:16:41,030 --> 01:16:47,000
that hole

01:16:42,400 --> 01:16:50,560
okay so or I can just leave it as a hole

01:16:47,000 --> 01:16:56,770
at that point I have an unsafe operation

01:16:50,560 --> 01:16:59,600
this is no longer a valid container okay

01:16:56,770 --> 01:17:02,290
so I have a very fundamental choice

01:16:59,600 --> 01:17:05,930
there right I can have full efficiency

01:17:02,290 --> 01:17:08,870
right and we know that that doing sort

01:17:05,930 --> 01:17:11,330
in situ is provably faster than doing

01:17:08,870 --> 01:17:13,700
say a merge sort and always copy right

01:17:11,330 --> 01:17:15,739
so in a functional environment you're

01:17:13,700 --> 01:17:18,440
going to say we need safety at every

01:17:15,739 --> 01:17:20,000
step and the cost of that in a

01:17:18,440 --> 01:17:22,100
functional environment says well we're

01:17:20,000 --> 01:17:23,449
going to do merge sort and we're going

01:17:22,100 --> 01:17:24,949
to create a copy

01:17:23,449 --> 01:17:27,829
we can't do quicksort even though

01:17:24,949 --> 01:17:32,510
quicksort is provably faster okay or an

01:17:27,829 --> 01:17:35,479
intra sort right so that is where the

01:17:32,510 --> 01:17:38,719
conflict comes into play doesn't mean

01:17:35,479 --> 01:17:40,940
that's functional languages efficient

01:17:38,719 --> 01:17:42,889
well most functional languages end up

01:17:40,940 --> 01:17:44,599
having an escape hatch right you have

01:17:42,889 --> 01:17:48,409
some way in your functional language to

01:17:44,599 --> 01:17:51,260
say I'm doing something unsafe now okay

01:17:48,409 --> 01:17:54,289
and and I think we need more of that

01:17:51,260 --> 01:17:56,749
right we have too many unsafe operations

01:17:54,289 --> 01:18:13,729
that are unnecessarily unsafe operations

01:17:56,749 --> 01:18:15,590
inside of our language expressed

01:18:13,729 --> 01:18:17,959
relationships and mentioned contracts

01:18:15,590 --> 01:18:20,209
which expression express relationships

01:18:17,959 --> 01:18:22,340
between values and concepts which you

01:18:20,209 --> 01:18:25,130
can express relationships between types

01:18:22,340 --> 01:18:28,099
and operations on those types but

01:18:25,130 --> 01:18:30,920
there's arguably a third which is C++

01:18:28,099 --> 01:18:33,769
modules which allow library writers to

01:18:30,920 --> 01:18:36,610
kind of create a formalized relation

01:18:33,769 --> 01:18:39,170
between entities in their library and

01:18:36,610 --> 01:18:41,209
the programmer that consumes that

01:18:39,170 --> 01:18:45,949
library I'm as curious as to why this

01:18:41,209 --> 01:18:48,590
was missing or - in something it's a

01:18:45,949 --> 01:18:50,690
completely valid observation that I

01:18:48,590 --> 01:18:55,389
agree with and now I'm gonna add it to

01:18:50,690 --> 01:18:58,639
my slides so now there's three really -

01:18:55,389 --> 01:19:00,530
and it's something that I ignored here

01:18:58,639 --> 01:19:03,079
and that I think as a community we

01:19:00,530 --> 01:19:05,800
ignore too much which is as soon as you

01:19:03,079 --> 01:19:09,050
are trying to develop software at scale

01:19:05,800 --> 01:19:10,969
the relationships between your modules

01:19:09,050 --> 01:19:16,369
and your build system becomes incredibly

01:19:10,969 --> 01:19:21,760
important so just just an omission not

01:19:16,369 --> 01:19:21,760
intentional thank you yeah anybody else

01:19:22,449 --> 01:19:27,119
then you guys get eight minutes back and

01:19:24,979 --> 01:19:29,179
you can see me out

01:19:27,119 --> 01:19:29,179

YouTube URL: https://www.youtube.com/watch?v=ejF6qqohp3M


