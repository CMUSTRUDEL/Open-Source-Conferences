Title: CppCon 2019: Inbal Levi “Back to Basics: Virtual Dispatch and its Alternatives”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Code efficiency is one of the strongest features of modern C++, therefore broadly used in industries with a need for high performance, such as Real-Time or Embedded Systems.

In this talk, we will go through the search for high run-time efficiency using the dispatch mechanism.

We will start by providing tools for understanding and estimating run-time performance cost.

Next, we'll analyze a test case, and dive into some of the most fundamental components of the language such as inheritance, and templates.

We will continue by introducing implementations which produce high run-time efficiency code such as CRTP, std::variant and visitor, and use them to maximize performance.

Finally, we will do benchmarking and draw conclusions, and try to answer the question -
How can we use C++ ideally for achieving high-performance efficiency?
— 
Inbal Levi
Software engineer, SolarEdge
Inbal Levi is a C++ enthusiastic, embedded software engineer with a passion for high performance.
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,350 --> 00:00:17,740
hello everyone my name is in BAU C++ and

00:00:14,620 --> 00:00:22,119
better developer I work at SolarEdge and

00:00:17,740 --> 00:00:23,410
we make smart solar systems and today in

00:00:22,119 --> 00:00:27,279
our talk we're going to talk about

00:00:23,410 --> 00:00:30,009
something that is very relevant the way

00:00:27,279 --> 00:00:36,430
I see it it's very in the front of the

00:00:30,009 --> 00:00:40,750
stage right now the ability of the of

00:00:36,430 --> 00:00:47,620
our of C++ to be able to activate things

00:00:40,750 --> 00:00:49,510
both on compile time and on run time so

00:00:47,620 --> 00:00:52,270
before that I just want to tell you a

00:00:49,510 --> 00:00:53,770
little story so when I was in high

00:00:52,270 --> 00:00:57,910
school I had a chance to take a

00:00:53,770 --> 00:01:00,010
translation extra curse and I thought it

00:00:57,910 --> 00:01:02,230
might be it should be easy because I

00:01:00,010 --> 00:01:05,130
grew up with English speakers but

00:01:02,230 --> 00:01:07,509
apparently it wasn't that easy and

00:01:05,130 --> 00:01:10,720
translation is hard because you have to

00:01:07,509 --> 00:01:15,040
take under consideration every bit of

00:01:10,720 --> 00:01:17,290
the language and I feel that as a C++

00:01:15,040 --> 00:01:19,720
developers we're trying to translate as

00:01:17,290 --> 00:01:23,050
close as possible to the computer

00:01:19,720 --> 00:01:25,420
language and this is why it's hard and I

00:01:23,050 --> 00:01:30,460
think the reason that I'm so interested

00:01:25,420 --> 00:01:32,320
in high performance is because I feel

00:01:30,460 --> 00:01:33,700
that when we're getting high performance

00:01:32,320 --> 00:01:36,479
that means that we were able to

00:01:33,700 --> 00:01:39,100
translate as close as possible to the

00:01:36,479 --> 00:01:42,130
computer language so that's my

00:01:39,100 --> 00:01:49,150
philosophy and this is what happens when

00:01:42,130 --> 00:01:55,630
you miss translating so it's try not to

00:01:49,150 --> 00:01:58,229
get there all right so let's overview so

00:01:55,630 --> 00:02:00,640
we're gonna start with defining the go

00:01:58,229 --> 00:02:03,970
then we're gonna understand virtual

00:02:00,640 --> 00:02:08,049
table we're going to go over some of the

00:02:03,970 --> 00:02:12,580
alternatives and of course benchmark and

00:02:08,049 --> 00:02:14,110
draw a conclusion so we want to

00:02:12,580 --> 00:02:15,599
understand what happens behind the scene

00:02:14,110 --> 00:02:18,010
our goal is to improve performance

00:02:15,599 --> 00:02:20,739
especially in the embedded world which I

00:02:18,010 --> 00:02:22,959
am part of and

00:02:20,739 --> 00:02:25,540
once you understand how exactly things

00:02:22,959 --> 00:02:28,900
works we might be able to make them

00:02:25,540 --> 00:02:30,549
better and another thing that we want to

00:02:28,900 --> 00:02:34,030
be able to do is identify the type of

00:02:30,549 --> 00:02:36,790
the object and according to the type do

00:02:34,030 --> 00:02:41,530
something some activate function or

00:02:36,790 --> 00:02:43,239
whatever and the last thing it will be

00:02:41,530 --> 00:02:47,040
nice to have a derived as a base

00:02:43,239 --> 00:02:47,040
relation on compile time

00:02:48,810 --> 00:02:55,060
so there's few things that you can do to

00:02:53,139 --> 00:02:58,109
optimize performance and again I'm

00:02:55,060 --> 00:03:01,510
referring to runtime performance and

00:02:58,109 --> 00:03:03,879
optimized hot baths and so on is some of

00:03:01,510 --> 00:03:06,430
them but there's a few things that you

00:03:03,879 --> 00:03:07,540
can decrease anyone have idea what you

00:03:06,430 --> 00:03:10,139
want to decrease when you want to

00:03:07,540 --> 00:03:17,189
approve runtime performance

00:03:10,139 --> 00:03:19,750
you can shout yeah right function yeah

00:03:17,189 --> 00:03:22,599
dereferencing of pointers that's what

00:03:19,750 --> 00:03:28,650
you meant probably anyone else want to

00:03:22,599 --> 00:03:31,269
suggest something okay so we can also

00:03:28,650 --> 00:03:34,889
decrease our dynamic allocation right

00:03:31,269 --> 00:03:38,680
that would be great and the system calls

00:03:34,889 --> 00:03:40,479
both of those things are for example I

00:03:38,680 --> 00:03:42,849
work on Linux system so we have

00:03:40,479 --> 00:03:45,099
operation system not all embedded

00:03:42,849 --> 00:03:48,340
developers have an operation system but

00:03:45,099 --> 00:03:51,370
in any case we're trying to external

00:03:48,340 --> 00:03:53,919
code and right and this is decision

00:03:51,370 --> 00:03:56,939
making would be also great to decrease

00:03:53,919 --> 00:04:01,299
because then we decrease branching and

00:03:56,939 --> 00:04:03,129
the function calls we can use inline but

00:04:01,299 --> 00:04:06,790
we don't know for sure that a compiler

00:04:03,129 --> 00:04:11,560
actually doing inline and other than

00:04:06,790 --> 00:04:13,120
that it might actually increase the time

00:04:11,560 --> 00:04:15,659
for the program to run so it's not

00:04:13,120 --> 00:04:20,259
always working to the best of our

00:04:15,659 --> 00:04:22,750
purpose and of course the code size that

00:04:20,259 --> 00:04:25,150
will decrease our cache miss and what

00:04:22,750 --> 00:04:28,779
we're going to focus on on this talk is

00:04:25,150 --> 00:04:30,969
those two things so let's start with

00:04:28,779 --> 00:04:32,800
warm-up we have our base class and it

00:04:30,969 --> 00:04:34,270
have a constructor a destructor and a

00:04:32,800 --> 00:04:36,100
print me function

00:04:34,270 --> 00:04:38,020
and we have our derived class with a

00:04:36,100 --> 00:04:43,810
constructor a destructor and apprently

00:04:38,020 --> 00:04:44,920
function now this is our function and we

00:04:43,810 --> 00:04:48,700
have a problem here

00:04:44,920 --> 00:04:52,290
anyone can say think about what the

00:04:48,700 --> 00:04:56,050
problem might be with this function

00:04:52,290 --> 00:04:59,020
that's true that's one but let's assume

00:04:56,050 --> 00:05:02,620
that I actually this is what you want

00:04:59,020 --> 00:05:05,250
now like okay at the beginning at least

00:05:02,620 --> 00:05:08,830
we're trying to make compile-time

00:05:05,250 --> 00:05:10,510
structures and we want to have them like

00:05:08,830 --> 00:05:13,930
for now we're not going to use virtual

00:05:10,510 --> 00:05:16,630
so but you're right that the virtual is

00:05:13,930 --> 00:05:19,630
what we're missing here and the problem

00:05:16,630 --> 00:05:23,380
here is that our object is not actually

00:05:19,630 --> 00:05:27,100
a base we took a base a base pointer but

00:05:23,380 --> 00:05:29,380
it's not really a base this is not a

00:05:27,100 --> 00:05:33,010
real you know code and the sitter's for

00:05:29,380 --> 00:05:35,590
the sake of presentation but here you

00:05:33,010 --> 00:05:37,090
can see that the function doesn't know

00:05:35,590 --> 00:05:39,060
the type of the object because we just

00:05:37,090 --> 00:05:42,490
split the dynamic type from the

00:05:39,060 --> 00:05:45,820
complexion tab from the runtime type

00:05:42,490 --> 00:05:48,580
from the compile time type and a worst

00:05:45,820 --> 00:05:52,990
thing can happen when you do it at the

00:05:48,580 --> 00:05:56,380
destructor right this is really bad so

00:05:52,990 --> 00:05:59,260
we don't want to do that so we have like

00:05:56,380 --> 00:06:03,220
two solutions generally one would be to

00:05:59,260 --> 00:06:06,280
limit the ability to actually create a

00:06:03,220 --> 00:06:08,470
base pointer so instead of that we will

00:06:06,280 --> 00:06:11,260
just create the right pointer right so

00:06:08,470 --> 00:06:14,350
just raise the pointer of the class that

00:06:11,260 --> 00:06:16,450
you actually have and a different

00:06:14,350 --> 00:06:18,940
solution is what you just said the

00:06:16,450 --> 00:06:20,440
virtual but the virtual keyword actually

00:06:18,940 --> 00:06:22,660
contains a lot of things this is

00:06:20,440 --> 00:06:27,160
actually a whole mechanism behind the

00:06:22,660 --> 00:06:30,460
scene the compiler creates structure and

00:06:27,160 --> 00:06:34,000
all the calls are going from compile

00:06:30,460 --> 00:06:37,090
time to run time and this is costing at

00:06:34,000 --> 00:06:42,220
least when you're an embedded system so

00:06:37,090 --> 00:06:44,110
this work but so let's just go quickly

00:06:42,220 --> 00:06:45,660
over dynamic binding which is what we

00:06:44,110 --> 00:06:48,600
just did we just pass

00:06:45,660 --> 00:06:50,250
The Dispatch from rental sorry from

00:06:48,600 --> 00:06:55,070
compiled time to run time and we did

00:06:50,250 --> 00:06:57,480
dynamic binding right so sorry so

00:06:55,070 --> 00:07:00,260
implementation details are not covered

00:06:57,480 --> 00:07:02,310
by the standard it appears on the API so

00:07:00,260 --> 00:07:05,610
basically the compiler can do whatever

00:07:02,310 --> 00:07:08,270
you want but if it follows the API then

00:07:05,610 --> 00:07:13,410
it will probably do it using the virtual

00:07:08,270 --> 00:07:15,180
function holes table sorry and common

00:07:13,410 --> 00:07:18,720
implementation as I said is the virtual

00:07:15,180 --> 00:07:20,550
table so in this in this lecture I will

00:07:18,720 --> 00:07:23,070
use this example I will use an example

00:07:20,550 --> 00:07:27,990
of a picture which is ten thousand over

00:07:23,070 --> 00:07:30,360
ten thousand pixels size my benchmarking

00:07:27,990 --> 00:07:33,210
will be on a Linux Debian machine and I

00:07:30,360 --> 00:07:35,910
will apply filters on each pixel of the

00:07:33,210 --> 00:07:42,870
picture and you can start thinking why

00:07:35,910 --> 00:07:45,090
is this example interesting right and I

00:07:42,870 --> 00:07:49,230
will dispatch the activate function on

00:07:45,090 --> 00:07:54,120
each pixel so let's move on the tools

00:07:49,230 --> 00:07:56,100
that I'll be using are familiar gold

00:07:54,120 --> 00:07:58,400
ball that everyone are probably know and

00:07:56,100 --> 00:08:02,400
he's lecturing the next room

00:07:58,400 --> 00:08:04,710
C++ insights allows you to unfold

00:08:02,400 --> 00:08:06,300
template functions which is also useful

00:08:04,710 --> 00:08:09,090
if you want to check like exactly what's

00:08:06,300 --> 00:08:11,340
going on in your code quick bench is a

00:08:09,090 --> 00:08:13,170
website that implements Google benchmark

00:08:11,340 --> 00:08:16,470
so I hope you know it because it's also

00:08:13,170 --> 00:08:20,760
very useful and you can also plop and

00:08:16,470 --> 00:08:23,910
take the time of our function so this is

00:08:20,760 --> 00:08:26,220
our base filter again and this is the

00:08:23,910 --> 00:08:30,960
virtual table for the base filter

00:08:26,220 --> 00:08:33,479
alright so once we create our instance

00:08:30,960 --> 00:08:36,450
of base filter inside the compilation

00:08:33,479 --> 00:08:38,160
unit we're getting the virtual table

00:08:36,450 --> 00:08:42,000
created by the compiler and this is a

00:08:38,160 --> 00:08:44,010
global virtual table and as other people

00:08:42,000 --> 00:08:46,860
have talked already about in this

00:08:44,010 --> 00:08:48,690
convention we can have virtual tables on

00:08:46,860 --> 00:08:50,550
different compilation units and then the

00:08:48,690 --> 00:08:53,850
compiler sorry the link you will

00:08:50,550 --> 00:08:55,589
probably pick one okay but it's for now

00:08:53,850 --> 00:08:58,910
we're just referring to compilation you

00:08:55,589 --> 00:08:58,910
need the single copulation

00:08:58,960 --> 00:09:04,210
the virtual table for the developed is

00:09:01,290 --> 00:09:09,310
overriding the function pointers that we

00:09:04,210 --> 00:09:13,180
need for the derives okay so we have our

00:09:09,310 --> 00:09:15,490
filter base filter class and it have the

00:09:13,180 --> 00:09:17,649
pointer to the virtual table of Base and

00:09:15,490 --> 00:09:20,920
if we instantiate another one of course

00:09:17,649 --> 00:09:24,490
you're also having the pointer for the

00:09:20,920 --> 00:09:26,260
same virtual table and in normal

00:09:24,490 --> 00:09:30,130
polymorphism right this is not like a

00:09:26,260 --> 00:09:33,160
virtual fancy form of item sort like

00:09:30,130 --> 00:09:37,120
it's a public and not virtual public we

00:09:33,160 --> 00:09:40,390
have the filter derived have his type of

00:09:37,120 --> 00:09:42,040
the objective base and added part of the

00:09:40,390 --> 00:09:50,860
object which is the derived and they

00:09:42,040 --> 00:09:52,630
both get their own pointers so the

00:09:50,860 --> 00:09:55,089
structure in the assembly would look

00:09:52,630 --> 00:09:57,070
like this we have our filter right

00:09:55,089 --> 00:10:01,060
virtual table and we have the base

00:09:57,070 --> 00:10:03,010
filter virtual table and they both have

00:10:01,060 --> 00:10:04,510
pointer for the activate function and if

00:10:03,010 --> 00:10:06,279
the derived have a different activation

00:10:04,510 --> 00:10:09,550
function that would obviously be a

00:10:06,279 --> 00:10:12,310
different pointer and we have our

00:10:09,550 --> 00:10:15,130
destructors now there's 2d structures

00:10:12,310 --> 00:10:18,100
here and this is again implementation

00:10:15,130 --> 00:10:21,660
little belongs to the compiler so I'm

00:10:18,100 --> 00:10:25,420
not going to focus on this part here but

00:10:21,660 --> 00:10:29,110
right and this whole part is actually

00:10:25,420 --> 00:10:32,320
the RT TI information part all right so

00:10:29,110 --> 00:10:35,440
this part is responsible for keeping

00:10:32,320 --> 00:10:38,050
your object type for one time so if

00:10:35,440 --> 00:10:39,970
you're like me trying to pass as much as

00:10:38,050 --> 00:10:42,430
possible to compile time you can

00:10:39,970 --> 00:10:45,730
actually use this flag on your compiler

00:10:42,430 --> 00:10:48,459
to be able to eliminate this part and

00:10:45,730 --> 00:10:51,820
check if your code actually using

00:10:48,459 --> 00:10:54,360
information from runtime so this is also

00:10:51,820 --> 00:10:54,360
useful

00:10:56,950 --> 00:11:06,600
any questions so far all right so we

00:11:02,709 --> 00:11:08,860
have this is like the real like this is

00:11:06,600 --> 00:11:11,380
implementation for the virtual table and

00:11:08,860 --> 00:11:13,389
see but of course it's not exact so have

00:11:11,380 --> 00:11:15,730
our stripped of theater bright and then

00:11:13,389 --> 00:11:19,149
we have our pointers for the functions

00:11:15,730 --> 00:11:22,930
and we have virtual tables chart that is

00:11:19,149 --> 00:11:26,050
special for filter right and here we

00:11:22,930 --> 00:11:28,570
have once we have an installation of

00:11:26,050 --> 00:11:31,060
filter bright the compiler will actually

00:11:28,570 --> 00:11:34,720
feel the sorry the compiler will

00:11:31,060 --> 00:11:39,130
instantiate the virtual table and fill

00:11:34,720 --> 00:11:41,949
the pointers and this is how this this

00:11:39,130 --> 00:11:43,810
will look like first of all we have the

00:11:41,949 --> 00:11:46,660
creation of our object so we call the

00:11:43,810 --> 00:11:48,870
constructor right so the constructor

00:11:46,660 --> 00:11:53,519
will fill the virtual table for the base

00:11:48,870 --> 00:11:56,589
structure then we will call the derived

00:11:53,519 --> 00:12:00,160
constructor and it will fill the proper

00:11:56,589 --> 00:12:02,230
virtual table as well then we will have

00:12:00,160 --> 00:12:05,260
the call for activate through the

00:12:02,230 --> 00:12:10,209
virtual table and the destructors will

00:12:05,260 --> 00:12:12,940
be also called accordingly and this is

00:12:10,209 --> 00:12:15,190
how the assembly looks like so the first

00:12:12,940 --> 00:12:17,980
line is the address of the object on the

00:12:15,190 --> 00:12:20,649
stack then we have the address of the

00:12:17,980 --> 00:12:23,230
relevant virtual table we dereference

00:12:20,649 --> 00:12:25,899
that to get address of the function in

00:12:23,230 --> 00:12:28,360
the virtual table then we pass all the

00:12:25,899 --> 00:12:31,360
per arms on the stock for the function

00:12:28,360 --> 00:12:35,680
call and then we have our indirect call

00:12:31,360 --> 00:12:37,930
and if we would not use this mechanism

00:12:35,680 --> 00:12:41,079
we would actually have just the direct

00:12:37,930 --> 00:12:46,630
call through the pointer so this is what

00:12:41,079 --> 00:12:49,390
we're trying to achieve so again just to

00:12:46,630 --> 00:12:51,940
conclude the overhead of using the

00:12:49,390 --> 00:12:53,980
virtual table is to retrieve and

00:12:51,940 --> 00:12:57,790
calculate the location of the function

00:12:53,980 --> 00:13:02,260
right because we have to do few D

00:12:57,790 --> 00:13:07,240
references for that to execute the call

00:13:02,260 --> 00:13:09,040
which is an indirect call and again

00:13:07,240 --> 00:13:11,500
that's good

00:13:09,040 --> 00:13:15,130
and adjust the values of the pointer for

00:13:11,500 --> 00:13:19,420
using through going on different parts

00:13:15,130 --> 00:13:21,820
of the object and so on and as far as I

00:13:19,420 --> 00:13:24,430
see it there's currently like two major

00:13:21,820 --> 00:13:26,050
approaches to solve this the first one

00:13:24,430 --> 00:13:28,800
would be to minimize the overhead of

00:13:26,050 --> 00:13:31,509
virtual table by increasing the

00:13:28,800 --> 00:13:35,319
localization and decreasing the

00:13:31,509 --> 00:13:37,449
references and the second one would be

00:13:35,319 --> 00:13:40,360
to minimize the use of virtual table by

00:13:37,449 --> 00:13:44,139
implementing polymorphism and passing

00:13:40,360 --> 00:13:46,209
morphine's to compile time so the

00:13:44,139 --> 00:13:48,819
example to that would be I know by Louis

00:13:46,209 --> 00:13:52,170
yan and I think it's a really cool

00:13:48,819 --> 00:13:55,029
library so you can have a look at it and

00:13:52,170 --> 00:14:02,339
template metaprogramming it's what we're

00:13:55,029 --> 00:14:05,319
gonna focus on okay so there are a few

00:14:02,339 --> 00:14:08,649
things that the virtual normal

00:14:05,319 --> 00:14:10,000
polymorphism is giving us it gives us

00:14:08,649 --> 00:14:13,569
the ability to don't repeat ourselves

00:14:10,000 --> 00:14:16,389
this is like a basic OOP mechanism it

00:14:13,569 --> 00:14:18,010
gives us runtime panic it also allows us

00:14:16,389 --> 00:14:22,420
to override functions in the drive

00:14:18,010 --> 00:14:24,430
without changing the base we also have

00:14:22,420 --> 00:14:27,490
multiple level inheritance and add

00:14:24,430 --> 00:14:29,199
external derived to the to the base like

00:14:27,490 --> 00:14:32,440
after we finished writing the best we

00:14:29,199 --> 00:14:35,459
can always add another derived to do

00:14:32,440 --> 00:14:37,600
something and inherited form it and

00:14:35,459 --> 00:14:39,250
multiple inheritance is also something

00:14:37,600 --> 00:14:42,399
that a virtual table is giving us but

00:14:39,250 --> 00:14:45,579
we're not gonna we're not gonna refer to

00:14:42,399 --> 00:14:49,029
that it's actually something that you

00:14:45,579 --> 00:14:52,300
should really learn separately so I just

00:14:49,029 --> 00:14:54,160
marked them in a initials so it would be

00:14:52,300 --> 00:14:57,550
easy for us to judge the farthest

00:14:54,160 --> 00:14:59,620
solution so we're going to look at so

00:14:57,550 --> 00:15:01,389
solutions should provide the structure

00:14:59,620 --> 00:15:03,639
right we don't want to start taking

00:15:01,389 --> 00:15:05,170
pointers and passing them in order to

00:15:03,639 --> 00:15:07,449
call our functions we actually want to

00:15:05,170 --> 00:15:10,089
be able to have some kind of structure

00:15:07,449 --> 00:15:12,839
in our code even though we're giving up

00:15:10,089 --> 00:15:15,850
the virtual table and polymorphism and

00:15:12,839 --> 00:15:20,999
we want to trade focused ability with

00:15:15,850 --> 00:15:25,480
performance so we're gonna give up the

00:15:20,999 --> 00:15:27,459
like easiest more user-friendly

00:15:25,480 --> 00:15:30,309
mechanism that the language have to

00:15:27,459 --> 00:15:33,040
offer for us to have have to offer to us

00:15:30,309 --> 00:15:37,119
for polymorphism but we're going to try

00:15:33,040 --> 00:15:38,920
that with performance and some of the

00:15:37,119 --> 00:15:42,610
solutions are only possible if you know

00:15:38,920 --> 00:15:45,339
all your types on compile time right and

00:15:42,610 --> 00:15:50,709
this is very important so I refer to

00:15:45,339 --> 00:15:53,910
that again so the non virtual

00:15:50,709 --> 00:15:56,769
inheritance is just like what we saw on

00:15:53,910 --> 00:16:00,579
the first warm-up slide

00:15:56,769 --> 00:16:02,499
so we're basically hiding our ability to

00:16:00,579 --> 00:16:06,519
create a base and we're only creating

00:16:02,499 --> 00:16:08,410
drives okay we can live with that and we

00:16:06,519 --> 00:16:12,519
now have everything on compile time

00:16:08,410 --> 00:16:15,399
which is great but there's the

00:16:12,519 --> 00:16:17,230
limitation to that let's say I have my

00:16:15,399 --> 00:16:21,489
best class and it implements their print

00:16:17,230 --> 00:16:24,429
function and it have getters and I also

00:16:21,489 --> 00:16:28,449
have a derived and have getters on its

00:16:24,429 --> 00:16:31,389
own and I create my derived and I called

00:16:28,449 --> 00:16:33,240
print color which is this function that

00:16:31,389 --> 00:16:38,949
goes through the base prints function

00:16:33,240 --> 00:16:41,170
but now I go here and this is the result

00:16:38,949 --> 00:16:44,889
I'm getting this is not what I attended

00:16:41,170 --> 00:16:49,689
right I didn't get my full polymorphism

00:16:44,889 --> 00:16:54,819
as I wanted instead of going here I went

00:16:49,689 --> 00:16:58,059
here so this is doesn't give us all that

00:16:54,819 --> 00:17:00,699
we want it does give us it does give us

00:16:58,059 --> 00:17:02,709
the ability to not repeat ourselves by

00:17:00,699 --> 00:17:04,449
implementing things on a base class but

00:17:02,709 --> 00:17:06,159
it doesn't give us runtime binding and

00:17:04,449 --> 00:17:08,169
we can't override functions on the

00:17:06,159 --> 00:17:10,990
derived this is exactly the example why

00:17:08,169 --> 00:17:13,029
we can't and we can also have multiple

00:17:10,990 --> 00:17:16,360
level inheritance and we can add

00:17:13,029 --> 00:17:18,880
additional derived so ZRTP is the first

00:17:16,360 --> 00:17:21,220
alternative solution like real solution

00:17:18,880 --> 00:17:23,110
and here we're using template

00:17:21,220 --> 00:17:25,329
metaprogramming in order to achieve what

00:17:23,110 --> 00:17:28,809
we just couldn't achieve in the previous

00:17:25,329 --> 00:17:32,470
slide so we have our activate function

00:17:28,809 --> 00:17:34,990
implemented at a base filter and the

00:17:32,470 --> 00:17:37,750
call to activate function actually

00:17:34,990 --> 00:17:39,610
refer to the type of the object right

00:17:37,750 --> 00:17:42,100
calls through the type of the object and

00:17:39,610 --> 00:17:45,429
here we have a filter bride arrives home

00:17:42,100 --> 00:17:49,090
base and implements the right activate

00:17:45,429 --> 00:17:50,679
and the filter darked it also derives

00:17:49,090 --> 00:17:56,290
from base and implement our derived

00:17:50,679 --> 00:17:58,390
activate so now we're able to call

00:17:56,290 --> 00:18:03,970
activate function for a filter brides

00:17:58,390 --> 00:18:07,049
and get the call being in sort

00:18:03,970 --> 00:18:11,620
dispatched by the type of the object

00:18:07,049 --> 00:18:15,820
right and we'll go here which is what we

00:18:11,620 --> 00:18:18,640
wanted and once we have our filter dark

00:18:15,820 --> 00:18:21,309
we can have The Dispatch mechanism take

00:18:18,640 --> 00:18:27,370
us to here and right so we have

00:18:21,309 --> 00:18:33,280
polymorphism on compile time so just to

00:18:27,370 --> 00:18:34,750
emphasize this is our subclass and this

00:18:33,280 --> 00:18:39,400
is the back what we saw before with the

00:18:34,750 --> 00:18:42,280
gathers and this is the print colon

00:18:39,400 --> 00:18:46,230
function and we get the wrong answer and

00:18:42,280 --> 00:18:50,799
see OTP actually allows us to get the

00:18:46,230 --> 00:18:53,470
call sorry the getters from our derived

00:18:50,799 --> 00:19:01,440
class so we actually gets the

00:18:53,470 --> 00:19:04,090
polymorphism all right so now but

00:19:01,440 --> 00:19:08,169
inheritance actually lets us inheritance

00:19:04,090 --> 00:19:10,990
from with multiple levels we can inherit

00:19:08,169 --> 00:19:16,059
and derive and learning hearten from it

00:19:10,990 --> 00:19:17,620
so this is also possible with ZRTP so we

00:19:16,059 --> 00:19:21,840
have our base filter and we have our

00:19:17,620 --> 00:19:24,490
activate function and the static cast is

00:19:21,840 --> 00:19:27,820
just what we saw before and this is our

00:19:24,490 --> 00:19:30,690
middle filter it have it's a templated

00:19:27,820 --> 00:19:34,510
class of course and it have a default

00:19:30,690 --> 00:19:39,100
template power arm which is void and now

00:19:34,510 --> 00:19:42,730
we can have our activate function with

00:19:39,100 --> 00:19:44,419
condition so the condition asks whether

00:19:42,730 --> 00:19:48,889
the

00:19:44,419 --> 00:19:51,979
whether this template was filled so if

00:19:48,889 --> 00:19:56,959
it wasn't sorry if it was will get here

00:19:51,979 --> 00:19:59,869
which is the true answer the true and

00:19:56,959 --> 00:20:03,049
the condition was met and if it it

00:19:59,869 --> 00:20:06,049
wasn't will get here so this is our

00:20:03,049 --> 00:20:13,940
filter derived derives from our middle

00:20:06,049 --> 00:20:18,459
filter and now we can actually

00:20:13,940 --> 00:20:20,979
instantiate our middle filter sorry and

00:20:18,459 --> 00:20:25,249
we'll go through the Bayes filter and

00:20:20,979 --> 00:20:27,319
we'll get our condition met because as

00:20:25,249 --> 00:20:32,049
you can see we didn't pass a template

00:20:27,319 --> 00:20:35,329
and we have the middle filter code and

00:20:32,049 --> 00:20:38,149
if we create our filter derived as you

00:20:35,329 --> 00:20:39,549
can see on the Declaration of the filter

00:20:38,149 --> 00:20:43,279
derived you can see that it

00:20:39,549 --> 00:20:45,409
automatically takes the filter sorry it

00:20:43,279 --> 00:20:47,839
to matically inheritance from middle

00:20:45,409 --> 00:20:50,719
filter filter dragged and necessarily

00:20:47,839 --> 00:20:55,329
our condition is not met and we are

00:20:50,719 --> 00:20:58,940
going here so we just built our

00:20:55,329 --> 00:21:01,129
polymorphism on compile time which is

00:20:58,940 --> 00:21:07,639
really great in a manner of performance

00:21:01,129 --> 00:21:09,319
so to conclude we have in like the basic

00:21:07,639 --> 00:21:11,149
principle would be to have the activate

00:21:09,319 --> 00:21:13,159
function goes with the static pass

00:21:11,149 --> 00:21:16,219
through the type of the object so you

00:21:13,159 --> 00:21:19,399
can have as many as leveled as you want

00:21:16,219 --> 00:21:20,839
for your inheritance and of course you

00:21:19,399 --> 00:21:23,769
don't have runtime binding but that's

00:21:20,839 --> 00:21:26,389
sort of what we aim for

00:21:23,769 --> 00:21:29,209
so we're just going to compare between

00:21:26,389 --> 00:21:31,489
those two things so sub classing is what

00:21:29,209 --> 00:21:35,269
the first thing we saw it's easy to read

00:21:31,489 --> 00:21:37,219
and it's like really obvious and 30p is

00:21:35,269 --> 00:21:40,219
not reveal you need to think about the

00:21:37,219 --> 00:21:42,440
things that the templates and so on and

00:21:40,219 --> 00:21:47,389
you can inheritance from more than one

00:21:42,440 --> 00:21:52,429
your descendant and co teepee you need

00:21:47,389 --> 00:21:54,739
to implement that and notice that on sub

00:21:52,429 --> 00:21:57,379
classing what happened we togethers was

00:21:54,739 --> 00:21:57,809
that we actually hided the functions

00:21:57,379 --> 00:22:01,019
with

00:21:57,809 --> 00:22:03,840
override them in 30 P we can actually

00:22:01,019 --> 00:22:07,409
overwrite the functions this is like the

00:22:03,840 --> 00:22:09,239
big difference and sorry I just wanted

00:22:07,409 --> 00:22:11,429
to emphasize again that both are only

00:22:09,239 --> 00:22:12,929
relevant if we have all the information

00:22:11,429 --> 00:22:17,309
on compiled time this is what we're

00:22:12,929 --> 00:22:20,549
aiming for so now we're going to pass to

00:22:17,309 --> 00:22:23,099
a different structure that implements

00:22:20,549 --> 00:22:27,269
virtual table which is visitor and

00:22:23,099 --> 00:22:29,849
variance so I'm just going to remind you

00:22:27,269 --> 00:22:31,349
of the declarations of visit or variance

00:22:29,849 --> 00:22:33,899
and lambda because they're going to

00:22:31,349 --> 00:22:37,769
appear in the next slide so variant

00:22:33,899 --> 00:22:39,509
would be basically structured that can

00:22:37,769 --> 00:22:42,710
hold multiple classes and you can

00:22:39,509 --> 00:22:47,940
instantiate it with one type right and

00:22:42,710 --> 00:22:50,940
visit would be a way to perform operator

00:22:47,940 --> 00:22:57,509
parenthesis on your according to your

00:22:50,940 --> 00:23:02,460
type so this is our simple visitor and I

00:22:57,509 --> 00:23:05,279
have these types declared here and here

00:23:02,460 --> 00:23:08,820
you can see that we have our objects

00:23:05,279 --> 00:23:14,999
that actually calls the operator front

00:23:08,820 --> 00:23:18,419
parenthesis so we instantiate our object

00:23:14,999 --> 00:23:20,849
and then we call the operator

00:23:18,419 --> 00:23:26,039
parenthesis by using the visit alright

00:23:20,849 --> 00:23:29,669
so this is simple great but what happens

00:23:26,039 --> 00:23:31,889
behind the scene is actually not what

00:23:29,669 --> 00:23:35,190
may be not what we expect when I first

00:23:31,889 --> 00:23:38,009
saw this structure I thought this

00:23:35,190 --> 00:23:41,129
probably should be on compile time it

00:23:38,009 --> 00:23:44,460
looks fairly easy and it doesn't look

00:23:41,129 --> 00:23:47,639
like any of the information is not

00:23:44,460 --> 00:23:51,089
exposed but the implementation is

00:23:47,639 --> 00:23:53,820
actually first of all we have the

00:23:51,089 --> 00:23:56,789
verdict template to be able to take a

00:23:53,820 --> 00:23:59,519
few classes then we have error and one

00:23:56,789 --> 00:24:03,599
that is not very relative very relevant

00:23:59,519 --> 00:24:07,080
to our talk but now what we do have is

00:24:03,599 --> 00:24:11,240
the creation of a virtual table in the

00:24:07,080 --> 00:24:14,370
variance object and

00:24:11,240 --> 00:24:22,320
for someone that works on embedded

00:24:14,370 --> 00:24:24,030
systems this might be a problem so I'm

00:24:22,320 --> 00:24:25,830
just going to show one more example of

00:24:24,030 --> 00:24:31,410
the visitor this is the anonymous

00:24:25,830 --> 00:24:34,020
visitor way of writing it and you can

00:24:31,410 --> 00:24:36,809
actually refer to some people in this

00:24:34,020 --> 00:24:40,140
convention if it's looks complicated to

00:24:36,809 --> 00:24:42,210
you so first of all we have our

00:24:40,140 --> 00:24:45,150
overloaded is a ver addict thump

00:24:42,210 --> 00:24:47,790
template and it's also this is like a

00:24:45,150 --> 00:24:54,090
recursive right this is a recursion

00:24:47,790 --> 00:24:58,860
sorry and we have our we have our basic

00:24:54,090 --> 00:25:02,760
condition that like instantiates the

00:24:58,860 --> 00:25:05,429
recursive and here we can actually

00:25:02,760 --> 00:25:10,970
create our filter we decide which filter

00:25:05,429 --> 00:25:13,740
do we want and then by using the overall

00:25:10,970 --> 00:25:19,380
template that we just declared we can

00:25:13,740 --> 00:25:22,530
have our filter dark activated and you

00:25:19,380 --> 00:25:25,260
can also do it with multiple variants

00:25:22,530 --> 00:25:27,210
all right so you can have like filter

00:25:25,260 --> 00:25:33,000
dark and filter bright one after another

00:25:27,210 --> 00:25:36,059
and you can activate them both okay by

00:25:33,000 --> 00:25:39,809
passing the type the classes you get a

00:25:36,059 --> 00:25:43,200
type and you get the calls and I use

00:25:39,809 --> 00:25:47,400
that in order to to activate on my

00:25:43,200 --> 00:25:52,520
picture so I create a variant that is a

00:25:47,400 --> 00:25:56,160
pixel and I pass it to the visitor and

00:25:52,520 --> 00:25:59,540
now I can actually change the value of

00:25:56,160 --> 00:26:05,760
the pixel of the picture by using

00:25:59,540 --> 00:26:07,290
visitor visitor pattern so again we can

00:26:05,760 --> 00:26:09,929
sort of have do not repeat yourself

00:26:07,290 --> 00:26:13,559
because we can do things on the function

00:26:09,929 --> 00:26:16,549
that the overload function that rely to

00:26:13,559 --> 00:26:19,620
all of our derives and you don't have

00:26:16,549 --> 00:26:21,900
sorry you do have runtime binding but

00:26:19,620 --> 00:26:23,490
you can over and you can overwrite the

00:26:21,900 --> 00:26:23,830
functions in a derive basically this is

00:26:23,490 --> 00:26:26,260
all

00:26:23,830 --> 00:26:29,200
you do you don't have like other

00:26:26,260 --> 00:26:33,100
function in the base but you can't have

00:26:29,200 --> 00:26:35,520
multiple layer and you also can extend

00:26:33,100 --> 00:26:38,620
the derived once you've created your

00:26:35,520 --> 00:26:40,330
visitor you have to stick with the

00:26:38,620 --> 00:26:45,250
functions that you gave it the classes

00:26:40,330 --> 00:26:48,130
sorry did you give it and now I created

00:26:45,250 --> 00:26:51,220
a compile-time visitor now there's a lot

00:26:48,130 --> 00:26:53,440
of ways to do that sorry

00:26:51,220 --> 00:26:55,450
and there's a lot of different like

00:26:53,440 --> 00:26:57,130
options on the internet we implement

00:26:55,450 --> 00:27:00,340
what we just saw with the virtual table

00:26:57,130 --> 00:27:04,540
and because we want to avoid the runtime

00:27:00,340 --> 00:27:07,840
dispatch but I just try to force the

00:27:04,540 --> 00:27:10,510
normal variants to to actually being

00:27:07,840 --> 00:27:12,280
removed from one time to compile them so

00:27:10,510 --> 00:27:16,300
when you call it once it actually

00:27:12,280 --> 00:27:18,970
optimized out the virtual table but when

00:27:16,300 --> 00:27:22,450
we call it more than four times which is

00:27:18,970 --> 00:27:24,730
a bit weird we get the function through

00:27:22,450 --> 00:27:30,460
the runtime and all the optimization is

00:27:24,730 --> 00:27:33,780
laid off so for me this behavior looks a

00:27:30,460 --> 00:27:37,420
bit strange so we also opened about that

00:27:33,780 --> 00:27:40,920
so now we actually have I have to change

00:27:37,420 --> 00:27:47,580
the way that we activate our visitor and

00:27:40,920 --> 00:27:50,230
we're using like different approach and

00:27:47,580 --> 00:27:57,790
alright but now we have a visitor on

00:27:50,230 --> 00:28:01,960
compile time which is great so I think

00:27:57,790 --> 00:28:07,450
that like my talk among other thing is

00:28:01,960 --> 00:28:09,730
trying to emphasize this the the hard

00:28:07,450 --> 00:28:13,180
time that embedded developers are going

00:28:09,730 --> 00:28:16,470
through in order to improve small part

00:28:13,180 --> 00:28:19,570
of the performance and I think that like

00:28:16,470 --> 00:28:21,820
it would be great if you could have the

00:28:19,570 --> 00:28:24,670
compiler look at our structures and

00:28:21,820 --> 00:28:26,350
understand that we have all the

00:28:24,670 --> 00:28:30,430
information on compile time and maybe

00:28:26,350 --> 00:28:35,560
optimize out the virtual calls or the

00:28:30,430 --> 00:28:37,360
run time binding so the problem is I

00:28:35,560 --> 00:28:40,450
mean I looked at console expiry

00:28:37,360 --> 00:28:44,370
when it first you know what when it

00:28:40,450 --> 00:28:44,370
first came out and now when it's really

00:28:46,080 --> 00:28:52,450
emphasis and I thought this might be my

00:28:49,030 --> 00:28:57,580
answer but the problem is that conscious

00:28:52,450 --> 00:28:59,710
bear is very limited okay until supposed

00:28:57,580 --> 00:29:01,360
us 20 it couldn't even have very like

00:28:59,710 --> 00:29:04,120
the functions that our concepts bear

00:29:01,360 --> 00:29:09,970
couldn't even be here twelve and it only

00:29:04,120 --> 00:29:13,270
gets little types only be able to to use

00:29:09,970 --> 00:29:15,760
virtual types and also in the

00:29:13,270 --> 00:29:21,220
constructor you can't have virtual base

00:29:15,760 --> 00:29:23,680
so this is basically like not allowing

00:29:21,220 --> 00:29:25,690
you to have like at least for me not

00:29:23,680 --> 00:29:26,230
allowing me to have what I was hoping

00:29:25,690 --> 00:29:28,840
for

00:29:26,230 --> 00:29:31,750
so maybe consec spare is not the answer

00:29:28,840 --> 00:29:36,940
but if it would have been that would be

00:29:31,750 --> 00:29:40,240
great to my opinion okay so this is like

00:29:36,940 --> 00:29:42,520
a question for for the future maybe will

00:29:40,240 --> 00:29:45,850
some they have the ability to have that

00:29:42,520 --> 00:29:47,640
maybe with a different keyword so in the

00:29:45,850 --> 00:29:49,780
benchmarking that I'm about to show you

00:29:47,640 --> 00:29:51,760
you need to pay attention to the

00:29:49,780 --> 00:29:54,250
platform because platform is important

00:29:51,760 --> 00:29:57,700
you also need to pay attention to the

00:29:54,250 --> 00:30:01,030
optimization level if you have like a

00:29:57,700 --> 00:30:04,630
product that you have to optimize o for

00:30:01,030 --> 00:30:08,170
size o that then you need to take that

00:30:04,630 --> 00:30:12,820
under consideration because the results

00:30:08,170 --> 00:30:16,120
may be very differently compile-time

00:30:12,820 --> 00:30:19,690
instructions also really impact on your

00:30:16,120 --> 00:30:23,350
performance so less than the other

00:30:19,690 --> 00:30:28,090
things and compiler versions always make

00:30:23,350 --> 00:30:30,130
a matter so the code is as follows this

00:30:28,090 --> 00:30:37,690
is our normal virtual table that we just

00:30:30,130 --> 00:30:40,450
saw and this is our CRT P this is the

00:30:37,690 --> 00:30:42,430
code for the activate function in the

00:30:40,450 --> 00:30:47,170
normal virtual table and this is the

00:30:42,430 --> 00:30:49,830
call on the CRT P and we have our

00:30:47,170 --> 00:30:55,590
runtime visitor

00:30:49,830 --> 00:30:57,840
and compile-time visitor optimization

00:30:55,590 --> 00:30:58,919
levels I'll just go over them very

00:30:57,840 --> 00:31:01,499
quickly

00:30:58,919 --> 00:31:04,289
Oh zero and one basically reduce your

00:31:01,499 --> 00:31:08,129
code size but they try not to get your

00:31:04,289 --> 00:31:10,559
compilation time to go too high how to

00:31:08,129 --> 00:31:13,559
reduce code size and increase

00:31:10,559 --> 00:31:19,259
compilation time it's also doing and

00:31:13,559 --> 00:31:23,009
some compilers to loop unrolling we get

00:31:19,259 --> 00:31:25,379
all three for optimizations on and OS

00:31:23,009 --> 00:31:31,830
sorry reduced size I got it wrong last

00:31:25,379 --> 00:31:34,999
time it's always so under greener is our

00:31:31,830 --> 00:31:37,739
virtual table and the blue is for CR TP

00:31:34,999 --> 00:31:40,169
anyone have idea why on the minimal

00:31:37,739 --> 00:31:44,239
optimisation the co TP performs that's

00:31:40,169 --> 00:31:55,529
good and remember it's using templates

00:31:44,239 --> 00:31:58,889
instantiation sorry I can't hear ya okay

00:31:55,529 --> 00:32:01,739
so more no I think actually the reason

00:31:58,889 --> 00:32:05,249
is that because when you using templates

00:32:01,739 --> 00:32:08,759
you you get a lot of like extra code

00:32:05,249 --> 00:32:11,940
right and when you get extra code you

00:32:08,759 --> 00:32:14,789
have like a lot of more cache misses and

00:32:11,940 --> 00:32:16,590
so on so yeah that's also right what you

00:32:14,789 --> 00:32:19,379
said but I think like this is the main

00:32:16,590 --> 00:32:23,159
reason but I'm not a compiler developer

00:32:19,379 --> 00:32:25,109
and once you use a one you already see

00:32:23,159 --> 00:32:28,859
the performance difference

00:32:25,109 --> 00:32:33,480
you already see great great improvements

00:32:28,859 --> 00:32:36,749
Oh two is less you can see less

00:32:33,480 --> 00:32:39,749
improvement but still it's improving in

00:32:36,749 --> 00:32:42,629
like regarding the virtual tables so if

00:32:39,749 --> 00:32:46,799
the virtual table got better the 30p got

00:32:42,629 --> 00:32:49,919
even more better and in the best

00:32:46,799 --> 00:32:55,590
optimization level that we have 30 PS

00:32:49,919 --> 00:32:58,109
actually performs very well this was on

00:32:55,590 --> 00:33:02,990
Jesse C so I'll show you on clang which

00:32:58,109 --> 00:33:02,990
have similar results but

00:33:03,270 --> 00:33:10,419
somehow only on o2 it gets like really

00:33:07,090 --> 00:33:16,150
gets the hang of the CR T P and unrolled

00:33:10,419 --> 00:33:17,950
it and this is for a visitor so the

00:33:16,150 --> 00:33:23,020
runtime visitor comparing to the

00:33:17,950 --> 00:33:25,929
compiled time visitor and we can see

00:33:23,020 --> 00:33:28,510
that in the best benchmarking the best

00:33:25,929 --> 00:33:33,059
optimization level we actually get a

00:33:28,510 --> 00:33:39,070
pretty fair optimum performance

00:33:33,059 --> 00:33:42,220
deviation but sorry this is on of course

00:33:39,070 --> 00:33:48,970
on runtime visitor right sorry this is

00:33:42,220 --> 00:33:51,070
on GCC and on clan well the story is a

00:33:48,970 --> 00:33:54,070
bit better here within the best

00:33:51,070 --> 00:33:56,500
optimization level but I'm sure we could

00:33:54,070 --> 00:34:00,010
maybe do something better in the future

00:33:56,500 --> 00:34:02,169
now I want to emphasize that it's it's

00:34:00,010 --> 00:34:04,750
very hard to pass things from compile

00:34:02,169 --> 00:34:08,589
time to run time sorry from one time to

00:34:04,750 --> 00:34:11,770
compile time in the current version of

00:34:08,589 --> 00:34:13,899
the language for example you have to

00:34:11,770 --> 00:34:16,440
consider static for loops you have to

00:34:13,899 --> 00:34:21,190
change all your structures all your

00:34:16,440 --> 00:34:23,379
containers so I think it's unfortunate

00:34:21,190 --> 00:34:26,589
again from the perspective of a better

00:34:23,379 --> 00:34:28,690
developer I wish I could have an easier

00:34:26,589 --> 00:34:34,510
mechanism to have my code on compile

00:34:28,690 --> 00:34:37,330
time ok so to conclude what we need to

00:34:34,510 --> 00:34:39,429
take under consideration is of course

00:34:37,330 --> 00:34:43,119
the memory verse is one time but also

00:34:39,429 --> 00:34:46,240
the design once we pass our structures

00:34:43,119 --> 00:34:49,470
to compile time we usually at least in

00:34:46,240 --> 00:34:52,990
the current version of the language have

00:34:49,470 --> 00:34:57,000
like struck the structures are getting

00:34:52,990 --> 00:35:02,380
bigger everything is getting less

00:34:57,000 --> 00:35:06,750
trivial and so on and we have to look at

00:35:02,380 --> 00:35:10,180
our code and decide which parts can be

00:35:06,750 --> 00:35:13,420
instantiated which parts are we can have

00:35:10,180 --> 00:35:16,360
this patch on on static and which parts

00:35:13,420 --> 00:35:22,900
have to be dispatched on the dynamic on

00:35:16,360 --> 00:35:25,420
on runtime so this is just a conclusion

00:35:22,900 --> 00:35:28,210
of all the things that the different

00:35:25,420 --> 00:35:29,830
solutions are giving us but pay

00:35:28,210 --> 00:35:33,040
attention that virtual tables really

00:35:29,830 --> 00:35:37,270
slow comparing to the other solutions at

00:35:33,040 --> 00:35:39,970
least on this example and here I just

00:35:37,270 --> 00:35:42,520
want to talk like two words about the

00:35:39,970 --> 00:35:45,670
future so as far as I see it suppose

00:35:42,520 --> 00:35:49,120
first when you're really trying to make

00:35:45,670 --> 00:35:52,420
my life easier alright so first of all

00:35:49,120 --> 00:35:53,350
we have broad use of normal C++ to have

00:35:52,420 --> 00:35:59,800
runt

00:35:53,350 --> 00:36:02,230
sorry compile time development and we

00:35:59,800 --> 00:36:06,790
hope we also have an expansion of

00:36:02,230 --> 00:36:10,260
context pair and constable but I would

00:36:06,790 --> 00:36:13,240
love to have a way to have my

00:36:10,260 --> 00:36:15,430
polymorphic structure with some kind of

00:36:13,240 --> 00:36:20,830
keyword being passed to compile time

00:36:15,430 --> 00:36:22,930
fully so these ideas regarding this but

00:36:20,830 --> 00:36:25,960
it's not anything that I can see in the

00:36:22,930 --> 00:36:31,530
near future but again this is a working

00:36:25,960 --> 00:36:31,530
process that's it thank you

00:36:38,220 --> 00:36:47,020
and questions please go to the

00:36:42,970 --> 00:36:51,730
microphone do you have any yeah so

00:36:47,020 --> 00:36:57,370
thanks for the talk just for me to

00:36:51,730 --> 00:36:59,950
clarify and so when you use syrupy then

00:36:57,370 --> 00:37:02,440
this kind of means that like the

00:36:59,950 --> 00:37:05,520
compiler generates a specific version

00:37:02,440 --> 00:37:09,130
for the subtype of the whole code of the

00:37:05,520 --> 00:37:10,990
hierarchy right yeah for the class and

00:37:09,130 --> 00:37:18,070
that's why it is works that you still

00:37:10,990 --> 00:37:21,250
have yeah kind of yeah exactly and of

00:37:18,070 --> 00:37:24,430
course it decrease code size but it

00:37:21,250 --> 00:37:24,850
really you know depends on what you care

00:37:24,430 --> 00:37:30,540
about

00:37:24,850 --> 00:37:30,540
so yes anyone else

00:37:33,000 --> 00:37:49,570
yeah can you buy weight will take me a

00:37:43,990 --> 00:37:53,560
while talking about visit our compiler

00:37:49,570 --> 00:38:03,570
for example on clan yeah yeah this one

00:37:53,560 --> 00:38:07,290
or like one compile-time visitor and one

00:38:03,570 --> 00:38:09,250
why is it worse you're asking now I was

00:38:07,290 --> 00:38:12,580
like this detail which you said that

00:38:09,250 --> 00:38:16,650
till and for the first four that's the

00:38:12,580 --> 00:38:19,960
gradient cleared so within people and

00:38:16,650 --> 00:38:24,160
sorry could you come closer because the

00:38:19,960 --> 00:38:27,150
echo is really thanking me yeah just ask

00:38:24,160 --> 00:38:27,150
me yeah

00:38:32,069 --> 00:38:40,009
ah so we're basically open the bug on

00:38:36,749 --> 00:38:40,009
that because it's weird

00:38:51,920 --> 00:39:04,470
we suspect that this is a bug yeah so I

00:39:01,500 --> 00:39:06,990
did I use this different method and I of

00:39:04,470 --> 00:39:10,350
all the code on github so you must

00:39:06,990 --> 00:39:12,540
welcome to go and look at it and sorry I

00:39:10,350 --> 00:39:14,790
didn't mention it before you you can go

00:39:12,540 --> 00:39:17,820
to get up and execute all those

00:39:14,790 --> 00:39:22,610
structures and use them with different

00:39:17,820 --> 00:39:22,610
size of the pictures and so on yeah so

00:39:24,050 --> 00:39:32,070
what oh yeah sorry sorry so he asked

00:39:28,140 --> 00:39:44,010
basically why four times was the magic

00:39:32,070 --> 00:39:46,530
number and yeah sorry no no okay so he

00:39:44,010 --> 00:39:49,260
asked if the difference between the two

00:39:46,530 --> 00:39:52,770
visitors is the bug so my answer is no

00:39:49,260 --> 00:39:55,260
the first visitor instantiates the

00:39:52,770 --> 00:39:57,570
virtual table and the second visitor

00:39:55,260 --> 00:40:06,750
doesn't it's completely compatible I

00:39:57,570 --> 00:40:08,490
might not emphasize that so yes thank

00:40:06,750 --> 00:40:10,530
you you're most welcome to come and ask

00:40:08,490 --> 00:40:14,399
me anything else

00:40:10,530 --> 00:40:14,399

YouTube URL: https://www.youtube.com/watch?v=jBnIMEb2GhA


