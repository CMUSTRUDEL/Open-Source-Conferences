Title: CppCon 2019: Bjarne Stroustrup “C++20: C++ at 40”
Publication date: 2019-09-17
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
It is now 40 years since C++ (then called C with Classes) had its first non-research user. It is now 35 years since the first commercial release of C++. It is now 30 years since the start of the standards process.

So what is C++? I will try to explain what's great about C++, C++20, as a modern language, not treating it as a layer cake of features. Imagine you have never heard of C, C with Classes, or C++11. How do classes, templates, and lambdas fit together? What have constructors and destructors to do with exceptions? What's in the standard library? How can we start using C++?

Finally, I will make a few comments about how to get from older styles of C++ use to modern C++ and point to areas where we need to improve C++ further.
— 
Bjarne Stroustrup
technical fellow, MorganStanley

C++: history, design, use, standardization, future; performance, reliability; software developer education;distributed systemsBio: www.stroustrup.com/bio.html
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:08,750 --> 00:00:17,190
[Applause]

00:00:14,420 --> 00:00:19,080
so I would like to introduce you to a

00:00:17,190 --> 00:00:25,110
friend of mine April can you come up

00:00:19,080 --> 00:00:28,110
here so our keynote today is is a look

00:00:25,110 --> 00:00:29,640
at C++ at 40 years so there's some

00:00:28,110 --> 00:00:32,910
looking back but most of its about

00:00:29,640 --> 00:00:34,170
looking forward to the future and so as

00:00:32,910 --> 00:00:38,030
I think about the future

00:00:34,170 --> 00:00:41,519
C++ I think about young people

00:00:38,030 --> 00:00:45,269
good morning April good morning so April

00:00:41,519 --> 00:00:46,800
is one of two high school students who

00:00:45,269 --> 00:00:49,110
are registered for this conference and

00:00:46,800 --> 00:00:51,930
that is a person for us and I'm very

00:00:49,110 --> 00:00:55,799
excited to have her here you how do you

00:00:51,930 --> 00:00:58,170
use C++ April I work on a lot of small

00:00:55,799 --> 00:01:00,949
hobby projects like currently I'm just

00:00:58,170 --> 00:01:05,070
making chess but I love experimenting

00:01:00,949 --> 00:01:06,119
especially with games and huh okay

00:01:05,070 --> 00:01:08,520
that's exciting

00:01:06,119 --> 00:01:11,070
all right would you be interested in

00:01:08,520 --> 00:01:14,190
what the creator of C++ has to say about

00:01:11,070 --> 00:01:17,609
the future of C++ definitely then why

00:01:14,190 --> 00:01:20,880
didn't you ask this group to welcome our

00:01:17,609 --> 00:01:24,659
keynote speaker okay everybody please

00:01:20,880 --> 00:01:27,450
give a warm soup applause for the

00:01:24,659 --> 00:01:28,660
keynote speaker inventor of C++ we are

00:01:27,450 --> 00:01:50,250
nice to stuff

00:01:28,660 --> 00:01:50,250
[Applause]

00:01:50,659 --> 00:02:04,259
so welcome and it's quite a crowd that

00:01:59,960 --> 00:02:07,979
is not a picture of the global C++

00:02:04,259 --> 00:02:13,550
community it could have been but it's

00:02:07,979 --> 00:02:18,900
just a slide I borrowed from the web of

00:02:13,550 --> 00:02:22,019
something I'm going to talk about C++ 20

00:02:18,900 --> 00:02:24,959
not the the fartist and future because

00:02:22,019 --> 00:02:27,660
I'm not actually that great is a sort of

00:02:24,959 --> 00:02:29,700
a blue sky visionary I'll talk about

00:02:27,660 --> 00:02:31,410
things that we know a little bit about

00:02:29,700 --> 00:02:34,200
as a matter of fact we know almost

00:02:31,410 --> 00:02:36,239
everything about which is c plus plus 20

00:02:34,200 --> 00:02:40,380
and then I'll try and put it a little

00:02:36,239 --> 00:02:44,160
bit into a perspective because it is

00:02:40,380 --> 00:02:47,790
about 40 years across - a month before I

00:02:44,160 --> 00:02:51,239
started that when I started at this so

00:02:47,790 --> 00:02:54,630
it's it's an obvious topic I will

00:02:51,239 --> 00:02:57,060
however speak mostly about the the

00:02:54,630 --> 00:03:00,569
current in the near future I'm not going

00:02:57,060 --> 00:03:02,130
to go on about how it really was in the

00:03:00,569 --> 00:03:05,880
old days and you should have been there

00:03:02,130 --> 00:03:08,519
and all of that stuff there there's a

00:03:05,880 --> 00:03:13,410
sort of one way of contrasting what has

00:03:08,519 --> 00:03:16,470
happened in those 40 years the two

00:03:13,410 --> 00:03:18,720
gadgets are more or less to scale you

00:03:16,470 --> 00:03:23,519
can see the handset and the phone there

00:03:18,720 --> 00:03:25,769
and I will point out that the gadgets to

00:03:23,519 --> 00:03:27,630
the left the old one is something that

00:03:25,769 --> 00:03:30,000
has to be attached to a physical system

00:03:27,630 --> 00:03:32,730
inside a war for its power and

00:03:30,000 --> 00:03:36,690
connectivity it's it's it's very

00:03:32,730 --> 00:03:40,560
different today and one of the points I

00:03:36,690 --> 00:03:44,459
will make possibly repeatedly this at

00:03:40,560 --> 00:03:47,639
C++ actually had a significant part of

00:03:44,459 --> 00:03:50,730
this transition if you look at a gadget

00:03:47,639 --> 00:03:53,430
like the one with C++ inside it's not

00:03:50,730 --> 00:03:55,530
just that it's running C++ programs and

00:03:53,430 --> 00:03:58,410
that the key communication systems are

00:03:55,530 --> 00:03:59,620
C++ it's also that the manufacturing

00:03:58,410 --> 00:04:02,170
processes the

00:03:59,620 --> 00:04:05,709
sign of the processes the data baba has

00:04:02,170 --> 00:04:07,299
C++ in it I have another talk which I

00:04:05,709 --> 00:04:10,299
won't give today which is known as the

00:04:07,299 --> 00:04:13,569
invisible C++ the point is that if you

00:04:10,299 --> 00:04:18,150
do it right nobody can see it but it is

00:04:13,569 --> 00:04:21,190
everywhere and I'll go look here is

00:04:18,150 --> 00:04:24,520
that's actually the computer I started

00:04:21,190 --> 00:04:28,510
off so pdp-11 7c the two guys of course

00:04:24,520 --> 00:04:31,120
is Ken and Dennis this year is the 50th

00:04:28,510 --> 00:04:35,080
anniversary of Unix

00:04:31,120 --> 00:04:37,030
which is another great thing that has

00:04:35,080 --> 00:04:40,479
taken over the world and is found

00:04:37,030 --> 00:04:43,360
everywhere I'd like to point out that

00:04:40,479 --> 00:04:47,310
that computer there is less than a

00:04:43,360 --> 00:04:54,639
thousands of the speed of a Raspberry Pi

00:04:47,310 --> 00:05:03,960
it cost maybe a thousand times more than

00:04:54,639 --> 00:05:03,960
a Raspberry Pi it the Raspberry Pi

00:05:04,080 --> 00:05:11,889
weighs about 10,000 times less but then

00:05:09,400 --> 00:05:16,000
of course that computer only had to

00:05:11,889 --> 00:05:18,370
serve 40 researchers the world has

00:05:16,000 --> 00:05:23,470
changed and we've been part of that

00:05:18,370 --> 00:05:26,860
change one problem I have and I try to

00:05:23,470 --> 00:05:31,210
address is that people actually describe

00:05:26,860 --> 00:05:34,320
C++ in ways that harms the community and

00:05:31,210 --> 00:05:38,440
it harms the effectiveness of what we do

00:05:34,320 --> 00:05:42,820
they they they have ideas that were

00:05:38,440 --> 00:05:46,599
outdated in 1990 and we hear them all

00:05:42,820 --> 00:05:48,639
the time there can never be an r2 got

00:05:46,599 --> 00:05:52,510
anything I say on the web without

00:05:48,639 --> 00:05:55,919
somebody coming making noises that were

00:05:52,510 --> 00:06:00,190
inappropriate in 85 or thereabout

00:05:55,919 --> 00:06:02,380
but I'll point out that what is old is

00:06:00,190 --> 00:06:06,039
not necessarily bad what is new is not

00:06:02,380 --> 00:06:07,360
necessarily good we have to look at C++

00:06:06,039 --> 00:06:11,110
as it is today

00:06:07,360 --> 00:06:13,150
and by today I mean C++ 20 I'll show a

00:06:11,110 --> 00:06:15,550
lot of code examples I'm not

00:06:13,150 --> 00:06:18,070
going to label them with dates you can

00:06:15,550 --> 00:06:19,810
have fun to think about when you could

00:06:18,070 --> 00:06:22,449
do this and whether you can actually do

00:06:19,810 --> 00:06:24,010
it on your current compiler and whether

00:06:22,449 --> 00:06:26,740
you can do it in your codebase I

00:06:24,010 --> 00:06:28,620
actually expect and somewhat hope that

00:06:26,740 --> 00:06:31,960
the answer is often you can't and

00:06:28,620 --> 00:06:34,680
therefore there is a path forward and we

00:06:31,960 --> 00:06:37,840
are getting ready to get you there and

00:06:34,680 --> 00:06:42,160
it's not a talk about details this is a

00:06:37,840 --> 00:06:46,300
keynote I think every slide I have there

00:06:42,160 --> 00:06:49,500
will be a one hour or more tour digging

00:06:46,300 --> 00:06:53,710
into that in depth I'm not going to try

00:06:49,500 --> 00:06:56,560
find the talk and listen to it and my

00:06:53,710 --> 00:06:59,020
general approach both for using C++ and

00:06:56,560 --> 00:07:01,120
for teaching it is to focus on the

00:06:59,020 --> 00:07:04,780
essentials try and figure out what is

00:07:01,120 --> 00:07:07,000
the essentials focus on that and be

00:07:04,780 --> 00:07:09,910
advanced and clever only when you

00:07:07,000 --> 00:07:12,729
absolutely must there's no prize for

00:07:09,910 --> 00:07:15,570
using the largest number of features or

00:07:12,729 --> 00:07:18,010
showing the most sophisticated example

00:07:15,570 --> 00:07:21,330
that's something you do when you must

00:07:18,010 --> 00:07:25,030
you tried to keep symbol and we also

00:07:21,330 --> 00:07:28,060
since C++ is an older language have to

00:07:25,030 --> 00:07:30,820
distinguish between what is good what is

00:07:28,060 --> 00:07:34,389
effective well what is useful and what's

00:07:30,820 --> 00:07:38,560
legal I'm not a language lawyer well I

00:07:34,389 --> 00:07:41,680
guess I am but I don't want to be and I

00:07:38,560 --> 00:07:44,470
want to sort of ignore the the subtle

00:07:41,680 --> 00:07:47,080
details as often as I can and I'm going

00:07:44,470 --> 00:07:49,210
to going to do here that means that we

00:07:47,080 --> 00:07:52,570
need to have guidelines for how to use

00:07:49,210 --> 00:07:55,210
the language well and I'm working on the

00:07:52,570 --> 00:07:58,120
C++ core guidelines which can be found

00:07:55,210 --> 00:08:02,830
in in many places this is not unique to

00:07:58,120 --> 00:08:05,050
C++ but I think it's very important part

00:08:02,830 --> 00:08:09,880
of the inspiration for this talk and

00:08:05,050 --> 00:08:12,760
part of the the background is an

00:08:09,880 --> 00:08:17,729
experiment I do every year I I get a

00:08:12,760 --> 00:08:20,830
class at Columbia and I get in students

00:08:17,729 --> 00:08:22,710
finally undergrads first-year graduates

00:08:20,830 --> 00:08:24,840
from all over the world

00:08:22,710 --> 00:08:30,210
all over the US all over the world and

00:08:24,840 --> 00:08:33,690
so I give them that book there and the

00:08:30,210 --> 00:08:35,940
first exercise is tell me what you

00:08:33,690 --> 00:08:37,890
didn't know about the language that is

00:08:35,940 --> 00:08:41,010
you read the language chapters and you

00:08:37,890 --> 00:08:42,870
tell me what you didn't know then second

00:08:41,010 --> 00:08:46,160
one do the same for the chapters about

00:08:42,870 --> 00:08:49,800
the library there's 200 pages 2 weeks

00:08:46,160 --> 00:08:53,370
work and I get a lot of feedback and I'm

00:08:49,800 --> 00:08:55,410
always shocked and so some of the things

00:08:53,370 --> 00:09:00,300
I'm going to tell you here you know very

00:08:55,410 --> 00:09:03,420
well but assume that the average student

00:09:00,300 --> 00:09:08,460
coming out of good university will have

00:09:03,420 --> 00:09:12,270
missed about half and that's why I think

00:09:08,460 --> 00:09:15,300
this is a worthwhile exercise C++ I

00:09:12,270 --> 00:09:17,220
think is principled and eclectic it's a

00:09:15,300 --> 00:09:20,900
general-purpose programming language and

00:09:17,220 --> 00:09:23,430
the key to the good use is definition

00:09:20,900 --> 00:09:25,080
implementation and use of lightweight

00:09:23,430 --> 00:09:27,770
abstractions and a lightweight

00:09:25,080 --> 00:09:31,020
abstraction is something that directly

00:09:27,770 --> 00:09:34,470
represent an idea and does it in an

00:09:31,020 --> 00:09:37,380
affordable and simple manner and a

00:09:34,470 --> 00:09:39,270
language is not just product development

00:09:37,380 --> 00:09:43,140
there's people says let's let's just

00:09:39,270 --> 00:09:44,880
build the next release you can't just

00:09:43,140 --> 00:09:47,550
build the next release for something

00:09:44,880 --> 00:09:50,780
that's supposed to last decades you have

00:09:47,550 --> 00:09:54,240
to have a design philosophy and

00:09:50,780 --> 00:09:57,570
something to help you find what is

00:09:54,240 --> 00:10:00,870
essential and I think we have had some

00:09:57,570 --> 00:10:02,820
success in that and this has given a

00:10:00,870 --> 00:10:05,850
certain degree of stability over the

00:10:02,820 --> 00:10:08,910
decades and a certain flexibility that

00:10:05,850 --> 00:10:11,190
you don't get if you just focus on the

00:10:08,910 --> 00:10:12,840
individual feature I mean people who

00:10:11,190 --> 00:10:14,850
think that they can't write a program

00:10:12,840 --> 00:10:18,090
without a virtual function because then

00:10:14,850 --> 00:10:20,430
it isn't good and have been disproven a

00:10:18,090 --> 00:10:23,130
few times over the years on the other

00:10:20,430 --> 00:10:27,810
hand there are good uses of just about

00:10:23,130 --> 00:10:32,570
every feature and C++ and one of the

00:10:27,810 --> 00:10:36,870
things that have been a focus and also

00:10:32,570 --> 00:10:40,710
was reflected in John's opening remarks

00:10:36,870 --> 00:10:43,529
is that in the design of C++ the view is

00:10:40,710 --> 00:10:46,529
we have to do whatever it takes to get

00:10:43,529 --> 00:10:49,980
good production code C++ is a language

00:10:46,529 --> 00:10:53,010
for building things for delivering

00:10:49,980 --> 00:10:55,640
systems maintaining systems making

00:10:53,010 --> 00:10:59,460
systems affordable it's it's not

00:10:55,640 --> 00:11:05,220
particularly aimed at a particular

00:10:59,460 --> 00:11:07,230
little group academics students etc it's

00:11:05,220 --> 00:11:11,610
it's it's it's ferret II and our purpose

00:11:07,230 --> 00:11:14,790
and I'm sometimes reminded about manager

00:11:11,610 --> 00:11:19,370
high level manager once MIT in a company

00:11:14,790 --> 00:11:24,000
which shall remain unnamed who said yeah

00:11:19,370 --> 00:11:26,100
yeah we don't really like C++ we only

00:11:24,000 --> 00:11:30,420
use it because it's the only thing that

00:11:26,100 --> 00:11:32,900
works I thought a couple of seconds and

00:11:30,420 --> 00:11:36,750
said oh thank you

00:11:32,900 --> 00:11:39,390
so but you can't just be expert friendly

00:11:36,750 --> 00:11:41,370
I was actually the one that coined the

00:11:39,390 --> 00:11:44,250
phrase expert friendly as a caricature

00:11:41,370 --> 00:11:46,290
to people who wanted to be just expert

00:11:44,250 --> 00:11:50,279
friendly you have to be simply enough

00:11:46,290 --> 00:11:57,060
for casual use most programmers as long

00:11:50,279 --> 00:12:01,500
as our use of C++ grows are going to be

00:11:57,060 --> 00:12:05,010
relative novices and we have to focus on

00:12:01,500 --> 00:12:07,050
making the language simple enough and

00:12:05,010 --> 00:12:10,380
the techniques for using it's simple

00:12:07,050 --> 00:12:12,450
enough that people can come on board we

00:12:10,380 --> 00:12:15,480
should not try to enforce some kind of

00:12:12,450 --> 00:12:19,700
idea of theoretical purity the series

00:12:15,480 --> 00:12:19,700
changed over the years for starters and

00:12:20,450 --> 00:12:26,130
I've never seen a philosophy that

00:12:24,120 --> 00:12:28,620
covered absolutely everything that

00:12:26,130 --> 00:12:31,380
everybody needed in the C++ community

00:12:28,620 --> 00:12:33,330
it's eclectic they're principled so

00:12:31,380 --> 00:12:37,279
that's what we're going to do so

00:12:33,330 --> 00:12:40,620
high-level aims C++ is evolutionary I

00:12:37,279 --> 00:12:43,260
knew from day one that I couldn't build

00:12:40,620 --> 00:12:45,680
a complete language to serving

00:12:43,260 --> 00:12:47,670
everything that I would like to sir

00:12:45,680 --> 00:12:49,560
therefore you have to start at the

00:12:47,670 --> 00:12:50,310
beginning and then grow based on

00:12:49,560 --> 00:12:54,120
feedback

00:12:50,310 --> 00:12:57,420
based on what you learn so you have to

00:12:54,120 --> 00:13:00,029
evolve and you have to support gradual

00:12:57,420 --> 00:13:03,600
adoption because well people can't just

00:13:00,029 --> 00:13:05,990
throw all of their code away and start

00:13:03,600 --> 00:13:09,089
again from scratch not large

00:13:05,990 --> 00:13:12,350
organizations not people millions of

00:13:09,089 --> 00:13:15,449
lines of billions of lines of code

00:13:12,350 --> 00:13:18,420
deployed and furthermore you have to be

00:13:15,449 --> 00:13:22,350
stable a lot of the things I like most

00:13:18,420 --> 00:13:24,240
about C++ and systems building are

00:13:22,350 --> 00:13:26,579
things that you can't actually replace

00:13:24,240 --> 00:13:29,939
that easily when you put a lot of

00:13:26,579 --> 00:13:33,029
gadgets out and in the wild you can't

00:13:29,939 --> 00:13:35,819
just go and replace them when you build

00:13:33,029 --> 00:13:37,860
a large infrastructure it has to keep

00:13:35,819 --> 00:13:40,019
running you can't take the electricity

00:13:37,860 --> 00:13:43,139
supply down for a month while you

00:13:40,019 --> 00:13:47,069
upgrade the software controls this just

00:13:43,139 --> 00:13:51,029
doesn't work so you have to have

00:13:47,069 --> 00:13:54,629
stability compatibility or years and

00:13:51,029 --> 00:13:57,420
decades people tend to forget that and

00:13:54,629 --> 00:14:00,209
think let's just solve the urgent

00:13:57,420 --> 00:14:04,079
problems now but you know what happens

00:14:00,209 --> 00:14:09,000
when you succeed your stuff lasts only

00:14:04,079 --> 00:14:10,790
failures will you you can you can just

00:14:09,000 --> 00:14:16,259
redo them again in a year or two

00:14:10,790 --> 00:14:18,750
successes lasts and there's been other

00:14:16,259 --> 00:14:20,459
things try to make simple things simple

00:14:18,750 --> 00:14:22,620
which is the thing I'm going to talk

00:14:20,459 --> 00:14:25,379
about in this talk and the zero hour

00:14:22,620 --> 00:14:28,620
principle that is don't have distributed

00:14:25,379 --> 00:14:31,769
fat try and make sure that you can write

00:14:28,620 --> 00:14:36,480
the code so that you can afford to run

00:14:31,769 --> 00:14:40,230
it and you have to aim high I don't

00:14:36,480 --> 00:14:42,929
actually think a 10% improvement is such

00:14:40,230 --> 00:14:45,720
a great thing in the big picture it is a

00:14:42,929 --> 00:14:49,850
great thing for a particular system for

00:14:45,720 --> 00:14:53,399
a particular year but if you are

00:14:49,850 --> 00:14:56,339
thinking in terms of decades and

00:14:53,399 --> 00:14:59,699
language designed and community what you

00:14:56,339 --> 00:15:02,040
actually have to go for is significantly

00:14:59,699 --> 00:15:04,140
change the way we design implement

00:15:02,040 --> 00:15:07,320
software basically we have

00:15:04,140 --> 00:15:09,330
to change the way we think and and I'm

00:15:07,320 --> 00:15:11,580
not being patronizing and says you have

00:15:09,330 --> 00:15:16,800
to change the way you think its way

00:15:11,580 --> 00:15:19,670
including me okay so the aim and the

00:15:16,800 --> 00:15:22,170
purpose of the exercise is to create

00:15:19,670 --> 00:15:24,840
really good applications it's really

00:15:22,170 --> 00:15:28,380
good users and as usual I have some

00:15:24,840 --> 00:15:30,900
pictures because I can't talk about all

00:15:28,380 --> 00:15:34,080
of these applications though sometimes I

00:15:30,900 --> 00:15:36,120
would like to so the purpose of the

00:15:34,080 --> 00:15:41,100
exercise is to have great applications

00:15:36,120 --> 00:15:44,130
and you know looking back we actually

00:15:41,100 --> 00:15:46,340
succeeded to a large extent this this

00:15:44,130 --> 00:15:49,980
should be a happy event because you know

00:15:46,340 --> 00:15:53,490
you did something good over the years in

00:15:49,980 --> 00:15:57,720
the area of programming and design code

00:15:53,490 --> 00:15:59,730
is written deployed and maintained in

00:15:57,720 --> 00:16:03,720
ways that are radically different from

00:15:59,730 --> 00:16:06,000
what it was a few decades ago and C++

00:16:03,720 --> 00:16:08,790
has been part of that the C++ community

00:16:06,000 --> 00:16:11,550
has been part of that the the use of

00:16:08,790 --> 00:16:17,430
abstraction to more directly express

00:16:11,550 --> 00:16:20,250
ideas has has spread it's not just C++

00:16:17,430 --> 00:16:23,970
its simplest was has been one of the

00:16:20,250 --> 00:16:27,120
drivers of evolution of languages in the

00:16:23,970 --> 00:16:29,400
poor some people wanted to do things

00:16:27,120 --> 00:16:32,520
better than C++ some things wanted to do

00:16:29,400 --> 00:16:35,370
things different from C++ but it's been

00:16:32,520 --> 00:16:37,710
one of the drivers hardware have

00:16:35,370 --> 00:16:41,640
improved but how do I can only improve

00:16:37,710 --> 00:16:44,100
in combination with software these days

00:16:41,640 --> 00:16:46,680
software and hardware are not totally

00:16:44,100 --> 00:16:50,420
disjoint and C prosper has been part of

00:16:46,680 --> 00:16:54,870
that and our compiler infrastructure the

00:16:50,420 --> 00:16:57,120
the way we analyze our code and generate

00:16:54,870 --> 00:17:00,510
code is radically different from what it

00:16:57,120 --> 00:17:03,570
was and I'm happy to see that C++

00:17:00,510 --> 00:17:05,730
actually through LLVM and that kind of

00:17:03,570 --> 00:17:08,820
stuff is actually one of the things that

00:17:05,730 --> 00:17:10,680
helps most programming languages modern

00:17:08,820 --> 00:17:13,230
programming languages these days and

00:17:10,680 --> 00:17:16,020
then of course the applications the

00:17:13,230 --> 00:17:17,970
scale is just enormous ly different from

00:17:16,020 --> 00:17:22,709
what it was sophistication in

00:17:17,970 --> 00:17:25,470
mostly difference from that C++ has had

00:17:22,709 --> 00:17:28,230
a major impact in in science and

00:17:25,470 --> 00:17:30,630
engineering I mean there's this there's

00:17:28,230 --> 00:17:33,710
a reason I've gotten highest awards for

00:17:30,630 --> 00:17:39,480
engineering and such we we've done well

00:17:33,710 --> 00:17:42,480
okay so yeah there's been change C++ has

00:17:39,480 --> 00:17:47,549
been been key to some of those dramatic

00:17:42,480 --> 00:17:49,799
changes so let's get back to code if you

00:17:47,549 --> 00:17:55,919
look at the design and evolution of C++

00:17:49,799 --> 00:17:58,400
you'll find a list of rules of thumb I I

00:17:55,919 --> 00:18:03,330
felt shy I wouldn't call them principles

00:17:58,400 --> 00:18:05,820
so rules are thumb and this list here

00:18:03,330 --> 00:18:10,650
which is a subset of that list is going

00:18:05,820 --> 00:18:13,409
to be my guide for this talk and there's

00:18:10,650 --> 00:18:15,419
a few you have probably seen most of

00:18:13,409 --> 00:18:18,299
them in other words most of you are seen

00:18:15,419 --> 00:18:18,929
most of them it's not just a list of

00:18:18,299 --> 00:18:22,980
features

00:18:18,929 --> 00:18:26,880
it's a evolving language the trouble and

00:18:22,980 --> 00:18:30,750
the challenge is to maintain coherency

00:18:26,880 --> 00:18:33,809
for a long long time and aim for gradual

00:18:30,750 --> 00:18:35,909
and steady improvement and there was and

00:18:33,809 --> 00:18:40,830
there is a plan and you can read up on

00:18:35,909 --> 00:18:41,940
it there's some links there so let's

00:18:40,830 --> 00:18:45,900
look at it

00:18:41,940 --> 00:18:48,150
C++ is static type system will equal

00:18:45,900 --> 00:18:50,669
support for building and user defined

00:18:48,150 --> 00:18:54,570
type that's the idea and become pretty

00:18:50,669 --> 00:18:57,840
close in other words the type system is

00:18:54,570 --> 00:19:01,169
extensible and having a static type

00:18:57,840 --> 00:19:03,299
system allows us to catch things at

00:19:01,169 --> 00:19:06,530
compile time because we can express

00:19:03,299 --> 00:19:09,059
things so the compiler can understand it

00:19:06,530 --> 00:19:12,870
one of the things I like best about that

00:19:09,059 --> 00:19:15,419
is that if I can have my errors caught

00:19:12,870 --> 00:19:17,400
at compile time I don't have to have a

00:19:15,419 --> 00:19:21,030
runtime error handler for that kind of

00:19:17,400 --> 00:19:25,710
error and one of the hardest pieces of

00:19:21,030 --> 00:19:27,360
code to write is error handling strange

00:19:25,710 --> 00:19:30,270
things happen and you have to deal with

00:19:27,360 --> 00:19:32,630
them and when things are strange they're

00:19:30,270 --> 00:19:35,700
hard to deal with

00:19:32,630 --> 00:19:39,540
performance comes to a large extent by

00:19:35,700 --> 00:19:43,110
allowing the compilers and optimizes

00:19:39,540 --> 00:19:46,830
more information about what you're doing

00:19:43,110 --> 00:19:49,230
again we're improving there and the root

00:19:46,830 --> 00:19:52,230
of a lot of the best improvements are in

00:19:49,230 --> 00:19:53,970
the static type system and then the

00:19:52,230 --> 00:19:56,280
static type system allows us to be

00:19:53,970 --> 00:19:59,310
flexible to be expressive

00:19:56,280 --> 00:20:01,260
we have overloading when we started back

00:19:59,310 --> 00:20:05,760
in the dark ages square root of tool

00:20:01,260 --> 00:20:08,760
gave a crash because early c couldn't

00:20:05,760 --> 00:20:11,310
figure out that int could be used as a

00:20:08,760 --> 00:20:14,220
double because it required a conversion

00:20:11,310 --> 00:20:16,920
we have as type system that allows us to

00:20:14,220 --> 00:20:19,610
express things directly and make it work

00:20:16,920 --> 00:20:23,700
we get generic programming

00:20:19,610 --> 00:20:27,500
metaprogramming and a lot of compile

00:20:23,700 --> 00:20:31,890
time evaluation if we can move

00:20:27,500 --> 00:20:36,000
computation to compile time we can catch

00:20:31,890 --> 00:20:38,700
errors and run faster so let's let's

00:20:36,000 --> 00:20:43,410
look at it one of the things that C++

00:20:38,700 --> 00:20:47,490
has a lot of languages are not focused

00:20:43,410 --> 00:20:50,610
on that is actually support both value

00:20:47,490 --> 00:20:54,840
and reference semantics so basically

00:20:50,610 --> 00:21:00,740
simple things like this X becomes Y plus

00:20:54,840 --> 00:21:03,480
said X can be an int complex matrix and

00:21:00,740 --> 00:21:07,890
basically the semantics is what you

00:21:03,480 --> 00:21:09,600
would expect X becomes Y then well X has

00:21:07,890 --> 00:21:12,510
the same value of y but they're still

00:21:09,600 --> 00:21:16,740
independent objects on the other hand we

00:21:12,510 --> 00:21:20,040
have a lot of types that must be sort of

00:21:16,740 --> 00:21:24,150
pointer reference like it refers to

00:21:20,040 --> 00:21:26,400
something over there and so we can

00:21:24,150 --> 00:21:29,850
assign through them read from them and

00:21:26,400 --> 00:21:33,360
if we make something that has a point of

00:21:29,850 --> 00:21:35,130
reference immensities we have an

00:21:33,360 --> 00:21:37,710
assignment there they'll refer to the

00:21:35,130 --> 00:21:41,970
same object the combination of the two

00:21:37,710 --> 00:21:46,230
is is one of the keys to C++ a success

00:21:41,970 --> 00:21:48,960
and so on our most comments hi

00:21:46,230 --> 00:21:52,260
our value types integers character

00:21:48,960 --> 00:21:54,810
strings the containers and I think the

00:21:52,260 --> 00:21:57,950
semantics is ideal but pointers and

00:21:54,810 --> 00:22:00,990
references are essential in the

00:21:57,950 --> 00:22:03,930
implementation of some of the most

00:22:00,990 --> 00:22:06,630
interesting of those types so we have

00:22:03,930 --> 00:22:08,850
ordinary pointers references unique

00:22:06,630 --> 00:22:11,550
pointers share pointers all the rest and

00:22:08,850 --> 00:22:14,070
basically when we want to pass something

00:22:11,550 --> 00:22:16,710
along we don't always want to do a copy

00:22:14,070 --> 00:22:19,520
we just want to refer to it and so they

00:22:16,710 --> 00:22:23,270
need to it and and both are needed to

00:22:19,520 --> 00:22:29,570
give good use of the hardware resources

00:22:23,270 --> 00:22:37,190
so basically once you get the ability to

00:22:29,570 --> 00:22:40,290
to to have you building types and

00:22:37,190 --> 00:22:42,090
user-defined types work uniformly you

00:22:40,290 --> 00:22:45,150
don't have to think all the time about

00:22:42,090 --> 00:22:47,730
what it is the example here is of course

00:22:45,150 --> 00:22:49,860
the classical vector example which by

00:22:47,730 --> 00:22:52,740
the way shows two levels of abstraction

00:22:49,860 --> 00:22:56,730
the vector level and the implementation

00:22:52,740 --> 00:22:58,770
which is pointers and stuff but I can

00:22:56,730 --> 00:23:02,550
have vectors or building types vectors

00:22:58,770 --> 00:23:04,560
of user-defined types and this all works

00:23:02,550 --> 00:23:06,300
recursively so I can have a vector of

00:23:04,560 --> 00:23:08,460
vector of integers and that kind of

00:23:06,300 --> 00:23:10,410
stuff if there have been different rules

00:23:08,460 --> 00:23:13,350
for building types and user-defined

00:23:10,410 --> 00:23:14,910
types say user-defined types has to be

00:23:13,350 --> 00:23:17,730
created with you and leave them the

00:23:14,910 --> 00:23:20,010
FreeStore and building types can be on

00:23:17,730 --> 00:23:25,080
the stack this kind of stuff would not

00:23:20,010 --> 00:23:29,310
have worked well so one of the things

00:23:25,080 --> 00:23:32,820
that that has driven C++ is direct use

00:23:29,310 --> 00:23:34,830
of the machine c++ usually not

00:23:32,820 --> 00:23:37,110
necessarily but usually don't work on a

00:23:34,830 --> 00:23:39,300
virtual machine and it's a it's not a

00:23:37,110 --> 00:23:44,250
mathematical abstraction it's it's an

00:23:39,300 --> 00:23:46,650
abstraction of the machine and well it

00:23:44,250 --> 00:23:49,590
means that the objects are lying in

00:23:46,650 --> 00:23:52,200
memory and we can point to them memory

00:23:49,590 --> 00:23:55,920
is a sequence of object or rather it is

00:23:52,200 --> 00:23:58,320
a set of sequences of objects and we can

00:23:55,920 --> 00:24:01,650
combine things into new types

00:23:58,320 --> 00:24:03,360
just by sticking values next to each

00:24:01,650 --> 00:24:05,640
other object next to each other you get

00:24:03,360 --> 00:24:08,330
a raise if they're the same type if

00:24:05,640 --> 00:24:12,090
there are different types you can create

00:24:08,330 --> 00:24:14,100
objects structures classes and the

00:24:12,090 --> 00:24:16,500
pointers they are turns into some kind

00:24:14,100 --> 00:24:18,930
of things with with reference matrix

00:24:16,500 --> 00:24:22,800
this is a very simple abstraction of

00:24:18,930 --> 00:24:25,530
hardware this is the beauty of Dennis

00:24:22,800 --> 00:24:28,580
Rich's view of the machine and the

00:24:25,530 --> 00:24:31,530
design of C and I mention this because

00:24:28,580 --> 00:24:35,400
at least a third of my class when I do

00:24:31,530 --> 00:24:37,950
this class don't get it they haven't

00:24:35,400 --> 00:24:42,600
seen this before this is shocking to

00:24:37,950 --> 00:24:45,870
them and so please don't forget when

00:24:42,600 --> 00:24:47,520
you're introducing new people to C++ if

00:24:45,870 --> 00:24:49,530
they if they haven't seen something like

00:24:47,520 --> 00:24:53,850
C before they might need to see this

00:24:49,530 --> 00:24:56,100
slide and of course again we abstract we

00:24:53,850 --> 00:24:58,770
go one level higher when you're dealing

00:24:56,100 --> 00:25:02,070
with with hardware directly all the

00:24:58,770 --> 00:25:06,090
sizes are fixed there's no flexibility

00:25:02,070 --> 00:25:09,360
there's no protection there's no elegant

00:25:06,090 --> 00:25:11,790
error detection so we move up a level

00:25:09,360 --> 00:25:14,100
you always move up a level when we can

00:25:11,790 --> 00:25:15,960
so we can have bit sets that will give

00:25:14,100 --> 00:25:19,100
us the bit operations but for an

00:25:15,960 --> 00:25:23,070
arbitrary number of elements and we have

00:25:19,100 --> 00:25:25,860
arrays which have have their size known

00:25:23,070 --> 00:25:31,380
and we have spans so there I have an

00:25:25,860 --> 00:25:33,630
array of some bytes and I would like to

00:25:31,380 --> 00:25:34,440
manipulate it this is something happens

00:25:33,630 --> 00:25:38,250
all the time

00:25:34,440 --> 00:25:40,200
think buffers think networking think

00:25:38,250 --> 00:25:42,630
string manipulation character

00:25:40,200 --> 00:25:46,050
manipulation and such and so I want to

00:25:42,630 --> 00:25:46,740
spend over that so that I can pass it

00:25:46,050 --> 00:25:50,580
around

00:25:46,740 --> 00:25:54,390
I can iterate over it with range for

00:25:50,580 --> 00:25:57,870
loops and and this is fine notice that I

00:25:54,390 --> 00:26:01,140
don't actually have to mention the type

00:25:57,870 --> 00:26:05,700
of the elements in the span or the size

00:26:01,140 --> 00:26:09,840
of the the number of elements in that

00:26:05,700 --> 00:26:11,520
span because well a compiler knew it

00:26:09,840 --> 00:26:11,940
already and why should I tell the

00:26:11,520 --> 00:26:15,269
combine

00:26:11,940 --> 00:26:18,240
something that compiler knows I can if I

00:26:15,269 --> 00:26:21,870
want to give a size I can if I want to

00:26:18,240 --> 00:26:25,019
give a type sometimes we need this but

00:26:21,870 --> 00:26:28,620
whenever I say something I might get it

00:26:25,019 --> 00:26:31,649
wrong the compiler is more likely with

00:26:28,620 --> 00:26:33,659
almost perfect knowledge and very

00:26:31,649 --> 00:26:36,539
systematic rules are more likely to get

00:26:33,659 --> 00:26:39,059
it right on average than I am so I don't

00:26:36,539 --> 00:26:42,600
actually trust this kind of stuff where

00:26:39,059 --> 00:26:43,799
I am being explicit as much as when the

00:26:42,600 --> 00:26:47,450
compiler knows it

00:26:43,799 --> 00:26:51,419
again we are moving up a level from the

00:26:47,450 --> 00:26:54,149
pointers to zero terminated her arrays

00:26:51,419 --> 00:26:57,090
of integer characters or something like

00:26:54,149 --> 00:27:00,480
that and this is something I tend to

00:26:57,090 --> 00:27:04,169
refer to as the onion principle the

00:27:00,480 --> 00:27:07,649
average C++ program is is a set of

00:27:04,169 --> 00:27:10,860
layers of abstraction and you can always

00:27:07,649 --> 00:27:15,210
peel off one layer you get more details

00:27:10,860 --> 00:27:18,029
to express you get more you get more

00:27:15,210 --> 00:27:21,570
controls you get more opportunities to

00:27:18,029 --> 00:27:23,809
make mistakes you have to say more to

00:27:21,570 --> 00:27:26,970
work in other words you cry more and

00:27:23,809 --> 00:27:29,370
basically this is one of the ways we

00:27:26,970 --> 00:27:31,950
manage complexity we have many many

00:27:29,370 --> 00:27:33,570
layers and once I found the picture I

00:27:31,950 --> 00:27:37,159
noticed something interesting this is

00:27:33,570 --> 00:27:39,179
not just layers there are sort of

00:27:37,159 --> 00:27:42,179
irregularities that are being absorbed

00:27:39,179 --> 00:27:44,490
and encapsulated this is good stuff so I

00:27:42,179 --> 00:27:48,539
think it's a it's a good way of thinking

00:27:44,490 --> 00:27:51,419
about how to structure software so let's

00:27:48,539 --> 00:27:56,220
get back a bit one of the first things

00:27:51,419 --> 00:27:58,860
that came into C++ was was basically

00:27:56,220 --> 00:28:01,980
constructors and destructors and so

00:27:58,860 --> 00:28:04,169
basically we can look at the constructor

00:28:01,980 --> 00:28:07,769
destructor pairs they came in in the

00:28:04,169 --> 00:28:09,960
second week of C++ design so there they

00:28:07,769 --> 00:28:13,080
are the rock bottom of C++ here

00:28:09,960 --> 00:28:16,649
everything rest on it so we have a

00:28:13,080 --> 00:28:19,580
gadget we create a gadget it acquires

00:28:16,649 --> 00:28:23,639
some resources or needs to function

00:28:19,580 --> 00:28:24,580
memories file handles locks I don't know

00:28:23,639 --> 00:28:27,100
and

00:28:24,580 --> 00:28:29,710
no most of the time I don't have to know

00:28:27,100 --> 00:28:32,470
and I don't have to care because once we

00:28:29,710 --> 00:28:36,190
have finished it cranes are bits own

00:28:32,470 --> 00:28:38,740
miss this is important we can copy move

00:28:36,190 --> 00:28:41,409
them rest give it a good user interface

00:28:38,740 --> 00:28:43,029
and then the next level of abstractions

00:28:41,409 --> 00:28:45,549
down here there are is of course

00:28:43,029 --> 00:28:49,899
represented in terms of something else

00:28:45,549 --> 00:28:53,019
this is fine and if we have a local

00:28:49,899 --> 00:28:55,090
variable like this that's a gadget if I

00:28:53,019 --> 00:28:57,429
throw an exception if I return from the

00:28:55,090 --> 00:29:01,480
middle if I fall down the bottom I know

00:28:57,429 --> 00:29:02,559
that whatever misses that might be will

00:29:01,480 --> 00:29:07,029
be cleaned up

00:29:02,559 --> 00:29:10,149
so basically if you have every resource

00:29:07,029 --> 00:29:12,070
owned by an owner like gadget then the

00:29:10,149 --> 00:29:13,929
cleanup the destruction happens

00:29:12,070 --> 00:29:17,860
automatically you don't have to worry

00:29:13,929 --> 00:29:20,860
about it it also tends to be optimally

00:29:17,860 --> 00:29:23,260
fast it when you get out of the scope it

00:29:20,860 --> 00:29:25,870
goes away means you have minimal

00:29:23,260 --> 00:29:27,519
resource retention reasonable retention

00:29:25,870 --> 00:29:31,360
is a real pain in the neck if you have

00:29:27,519 --> 00:29:33,010
limited resources and basically don't

00:29:31,360 --> 00:29:41,889
don't don't try oops

00:29:33,010 --> 00:29:46,899
whoops don't try and handle ownership

00:29:41,889 --> 00:29:49,029
with overall pointers we have maybe

00:29:46,899 --> 00:29:51,279
fifty years of experience to say we are

00:29:49,029 --> 00:29:54,730
not very good at it we actually need to

00:29:51,279 --> 00:29:58,330
do something else and the pros do unique

00:29:54,730 --> 00:30:02,230
facility in C++ is that it is directly

00:29:58,330 --> 00:30:04,899
supported there's one thing that has

00:30:02,230 --> 00:30:07,419
been a source of a lot of user pointers

00:30:04,899 --> 00:30:10,470
for ownership which is people wants to

00:30:07,419 --> 00:30:14,710
make a big thing like a factory function

00:30:10,470 --> 00:30:16,360
and so they create an object they fill

00:30:14,710 --> 00:30:18,940
it up with good stuff and have to pass

00:30:16,360 --> 00:30:21,220
it back and the traditional way is to

00:30:18,940 --> 00:30:23,260
pass it back with a pointer if you do

00:30:21,220 --> 00:30:24,850
that you now have to deal with memory

00:30:23,260 --> 00:30:27,820
management explicitly you have to

00:30:24,850 --> 00:30:29,590
remember to delete that pointer all you

00:30:27,820 --> 00:30:31,269
have to use the share pointer which

00:30:29,590 --> 00:30:33,789
means that you have said maintain use

00:30:31,269 --> 00:30:36,100
counts and synchronization on use counts

00:30:33,789 --> 00:30:37,850
or you have to use unique pointers which

00:30:36,100 --> 00:30:40,700
a lot of people haven't learned

00:30:37,850 --> 00:30:44,869
there's a much better way it's over the

00:30:40,700 --> 00:30:50,169
mountains but we can do it better now so

00:30:44,869 --> 00:30:54,259
here we simply return the gadget and

00:30:50,169 --> 00:30:56,239
most of the time the compiler is smart

00:30:54,259 --> 00:30:58,999
enough to figure out that I have a local

00:30:56,239 --> 00:31:01,249
variable there which I want to become a

00:30:58,999 --> 00:31:04,100
local variable in the external scope

00:31:01,249 --> 00:31:06,590
very soon so let's allocate it so that

00:31:04,100 --> 00:31:10,340
we don't have to move it at all we

00:31:06,590 --> 00:31:13,009
certainly don't want to copy it but if

00:31:10,340 --> 00:31:16,820
the compiler can't figure this out we

00:31:13,009 --> 00:31:19,279
fall back - move semantics where he says

00:31:16,820 --> 00:31:23,359
okay there's the gadget big things tend

00:31:19,279 --> 00:31:27,499
to be a handle to the real stuff handles

00:31:23,359 --> 00:31:30,109
are really cheap to copy so what we do

00:31:27,499 --> 00:31:33,739
we steal a representation from G put it

00:31:30,109 --> 00:31:37,059
into G C into G G and remove the link

00:31:33,739 --> 00:31:40,849
from G problem solved we can move

00:31:37,059 --> 00:31:45,409
something with a million elements to

00:31:40,849 --> 00:31:48,590
file handles and and the lock out at the

00:31:45,409 --> 00:31:51,049
cost of essentially nothing so that's

00:31:48,590 --> 00:31:54,289
important and now we have a complete

00:31:51,049 --> 00:31:57,080
control of the of the object cycle of

00:31:54,289 --> 00:32:00,679
the life side of objects creation copy

00:31:57,080 --> 00:32:04,099
move and destruction that's important

00:32:00,679 --> 00:32:06,859
and this is sort of pervasive in the

00:32:04,099 --> 00:32:09,879
standard library I wish it was pervasive

00:32:06,859 --> 00:32:12,859
in all libraries but we're getting there

00:32:09,879 --> 00:32:14,779
and it's not just memory so when people

00:32:12,859 --> 00:32:16,879
talk about garbage collection they can

00:32:14,779 --> 00:32:19,340
handle everything up here provided it's

00:32:16,879 --> 00:32:22,509
only memory but there's lots and lots of

00:32:19,340 --> 00:32:26,929
things that aren't memory threads

00:32:22,509 --> 00:32:29,599
mutexes scope locks file handles

00:32:26,929 --> 00:32:32,599
Teradata so I'm not a great fan of

00:32:29,599 --> 00:32:34,909
garbage collection I would like to put

00:32:32,599 --> 00:32:36,289
it out of business if I can and of

00:32:34,909 --> 00:32:39,200
course again all of this works

00:32:36,289 --> 00:32:41,090
recursively so I can have a vector of a

00:32:39,200 --> 00:32:43,460
forward list of a pair of a string and a

00:32:41,090 --> 00:32:47,029
J thread Chara

00:32:43,460 --> 00:32:50,299
it it things has to work in composition

00:32:47,029 --> 00:32:51,450
in collaboration this is how we get

00:32:50,299 --> 00:32:57,059
reasonably simple

00:32:51,450 --> 00:33:01,139
maintainable code so back to this list

00:32:57,059 --> 00:33:04,169
of rules support conversation of

00:33:01,139 --> 00:33:05,580
software from separately developed parts

00:33:04,169 --> 00:33:08,130
oh yeah

00:33:05,580 --> 00:33:10,529
C++ applications are not all sort of

00:33:08,130 --> 00:33:13,860
grand and sexy that's a coffee machine

00:33:10,529 --> 00:33:16,289
there it's it's a course programmed in

00:33:13,860 --> 00:33:19,559
C++ I talk to the people who are doing

00:33:16,289 --> 00:33:21,510
we development of it and I like this one

00:33:19,559 --> 00:33:24,179
because my favorite definition of a

00:33:21,510 --> 00:33:28,529
programmer is a machine for turning

00:33:24,179 --> 00:33:30,720
caffeine into code and yes I have a

00:33:28,529 --> 00:33:33,690
machine not quite as fancy at that in my

00:33:30,720 --> 00:33:37,260
office otherwise I'll never get any code

00:33:33,690 --> 00:33:42,419
done anyway back to composition we

00:33:37,260 --> 00:33:46,799
compose software out of modules remember

00:33:42,419 --> 00:33:48,929
I'm assuming C++ 20 here and so if I

00:33:46,799 --> 00:33:51,179
want to write a map printer it's just

00:33:48,929 --> 00:33:55,159
sort of the smallest reasonable program

00:33:51,179 --> 00:33:57,899
that fits on the slide I'll import STD

00:33:55,159 --> 00:34:00,419
which unfortunately isn't standard but

00:33:57,899 --> 00:34:04,320
it's easy enough to define you just grab

00:34:00,419 --> 00:34:07,139
all of the standard library and then I

00:34:04,320 --> 00:34:13,440
import my own containers and then I want

00:34:07,139 --> 00:34:17,190
to export the the map printer there it's

00:34:13,440 --> 00:34:21,510
it's Tim template it requires takes a

00:34:17,190 --> 00:34:26,220
forward range and prints anything that

00:34:21,510 --> 00:34:29,669
has printable key and value types and

00:34:26,220 --> 00:34:32,730
then I do a loop over the elements there

00:34:29,669 --> 00:34:35,700
using structured binding and write out

00:34:32,730 --> 00:34:38,760
the key value pair that's nice it's

00:34:35,700 --> 00:34:40,379
simple and as a matter of fact it's you

00:34:38,760 --> 00:34:42,569
don't have to remember a lot of things

00:34:40,379 --> 00:34:44,909
just give me the standard library that

00:34:42,569 --> 00:34:47,609
that's the way to do it

00:34:44,909 --> 00:34:50,429
so basically modules support clean code

00:34:47,609 --> 00:34:54,750
it minimizes dependencies about things

00:34:50,429 --> 00:34:57,119
you bring in and it avoids circular

00:34:54,750 --> 00:34:59,609
dependencies some of you are probably

00:34:57,119 --> 00:35:03,240
thinking well that's not the way my code

00:34:59,609 --> 00:35:05,090
looks I have oodles of includes and we

00:35:03,240 --> 00:35:07,400
have to be careful about them

00:35:05,090 --> 00:35:09,350
yeah that's the point you have far too

00:35:07,400 --> 00:35:12,050
many intrudes and you have to be far too

00:35:09,350 --> 00:35:15,500
careful we're doing better these days so

00:35:12,050 --> 00:35:18,830
much energy if I import a and B means

00:35:15,500 --> 00:35:20,300
the same as importing P na hi that's the

00:35:18,830 --> 00:35:23,210
way things should be right

00:35:20,300 --> 00:35:26,350
why should I know about this and why

00:35:23,210 --> 00:35:29,270
should a be able to in in fact be with

00:35:26,350 --> 00:35:33,710
information if I wanted dependencies I

00:35:29,270 --> 00:35:36,080
should state them and only the use part

00:35:33,710 --> 00:35:40,040
of an important module has turned into

00:35:36,080 --> 00:35:43,300
generated code so when I grab all of a

00:35:40,040 --> 00:35:46,910
CD there I didn't load up my memory with

00:35:43,300 --> 00:35:49,730
etc junk that I didn't use I just said I

00:35:46,910 --> 00:35:51,830
I want it to be accessible and there's

00:35:49,730 --> 00:35:57,220
only one copy of a module so you don't

00:35:51,830 --> 00:36:00,530
have to copy this so to analyze it a

00:35:57,220 --> 00:36:03,170
hundred times because you included

00:36:00,530 --> 00:36:09,110
something a hundred times so basically

00:36:03,170 --> 00:36:13,010
all the major features of C++ exists to

00:36:09,110 --> 00:36:18,220
support composition modules classes

00:36:13,010 --> 00:36:18,220
concepts templates functions aliases

00:36:18,340 --> 00:36:24,560
if you can't compose you have to

00:36:21,200 --> 00:36:27,230
replicate and you get the code many

00:36:24,560 --> 00:36:29,060
times if you get the code many times if

00:36:27,230 --> 00:36:30,740
you fix the bug in one place you can't

00:36:29,060 --> 00:36:33,170
fix it in the other places that is no

00:36:30,740 --> 00:36:37,460
good you want to actually compose things

00:36:33,170 --> 00:36:41,420
out of unique parts incidentally that is

00:36:37,460 --> 00:36:44,900
a Lego Turing machine given that you can

00:36:41,420 --> 00:36:47,150
do anything but it is the lowest level

00:36:44,900 --> 00:36:50,690
of abstraction so you may not want to do

00:36:47,150 --> 00:36:53,870
that in production code so let's see

00:36:50,690 --> 00:36:57,410
generic programming is something that I

00:36:53,870 --> 00:37:00,200
worked on on and off the first paper on

00:36:57,410 --> 00:37:04,610
serial classes the ancestor of the C++

00:37:00,200 --> 00:37:06,620
which was written in 81 says we need

00:37:04,610 --> 00:37:09,800
generic programming and I thought I

00:37:06,620 --> 00:37:12,350
could do it with macros boy was I wrong

00:37:09,800 --> 00:37:14,660
generic programming we want to write

00:37:12,350 --> 00:37:17,780
code that works for types that meet

00:37:14,660 --> 00:37:18,530
abstract inquire requirements so we

00:37:17,780 --> 00:37:21,260
start our

00:37:18,530 --> 00:37:24,770
to be able to sort anything that sort of

00:37:21,260 --> 00:37:27,290
or do arithmetic on anything that

00:37:24,770 --> 00:37:28,340
actually is our numbers and things like

00:37:27,290 --> 00:37:30,800
that

00:37:28,340 --> 00:37:33,680
so we have concepts like forward

00:37:30,800 --> 00:37:36,230
iterator is in integral is irregular and

00:37:33,680 --> 00:37:39,950
can be sorted things like that you'll

00:37:36,230 --> 00:37:42,320
notice the integral is in K and R 1 so

00:37:39,950 --> 00:37:45,200
this is pretty fundamental and or not

00:37:42,320 --> 00:37:48,140
all that new and a concept is a simple

00:37:45,200 --> 00:37:50,720
compile time predicate on a set of types

00:37:48,140 --> 00:37:53,210
and values so if I won't say a sortable

00:37:50,720 --> 00:37:56,300
range which is the things that I want

00:37:53,210 --> 00:37:58,820
this all to work on I can say it should

00:37:56,300 --> 00:38:01,310
be an access range it should be its

00:37:58,820 --> 00:38:02,990
iterator should be permeable and it

00:38:01,310 --> 00:38:06,500
should have an indirect strict will

00:38:02,990 --> 00:38:11,570
order you can look the meaning of those

00:38:06,500 --> 00:38:14,180
concepts up in the C++ 20 committee

00:38:11,570 --> 00:38:17,570
draft that is now being voted on and

00:38:14,180 --> 00:38:19,910
this is good good standard stuff and now

00:38:17,570 --> 00:38:24,280
I can say I want to sort a sortable

00:38:19,910 --> 00:38:27,440
range say that's a vector of strings

00:38:24,280 --> 00:38:29,390
that'll work fine because the string has

00:38:27,440 --> 00:38:31,400
those properties vector of strings has

00:38:29,390 --> 00:38:32,510
those properties I can try it with a

00:38:31,400 --> 00:38:35,420
list of integers

00:38:32,510 --> 00:38:37,910
however lists do not have the random

00:38:35,420 --> 00:38:40,670
access range so it does not work so

00:38:37,910 --> 00:38:45,350
static type checking works out nicely

00:38:40,670 --> 00:38:47,990
the ability to express things concisely

00:38:45,350 --> 00:38:50,090
by using what the compiler already knows

00:38:47,990 --> 00:38:53,390
works nicely I have been wondering the

00:38:50,090 --> 00:38:57,830
right sort of Vic in standard C++ for

00:38:53,390 --> 00:39:00,170
ages I've had to fake it so far we do

00:38:57,830 --> 00:39:03,290
better but anyway what if I really

00:39:00,170 --> 00:39:05,630
wanted to sort the list well I can

00:39:03,290 --> 00:39:09,020
define a forwards audible range which

00:39:05,630 --> 00:39:10,700
basically is just a forward range and it

00:39:09,020 --> 00:39:13,040
has iterators that can be used for

00:39:10,700 --> 00:39:16,100
sorting against standard and now I

00:39:13,040 --> 00:39:20,780
define my own forward sortable range

00:39:16,100 --> 00:39:22,970
there's a nice algorithm for that in in

00:39:20,780 --> 00:39:25,730
elements of programming or you can just

00:39:22,970 --> 00:39:29,060
copy the range into a vector sort it and

00:39:25,730 --> 00:39:31,380
copy it back again but you can do it and

00:39:29,060 --> 00:39:35,430
now they were both work

00:39:31,380 --> 00:39:38,220
and if I saw the list well I can't sort

00:39:35,430 --> 00:39:40,319
it with with a sortable range which is

00:39:38,220 --> 00:39:42,720
random access so we'll pick that one and

00:39:40,319 --> 00:39:46,230
for the vector it has all the properties

00:39:42,720 --> 00:39:49,950
required for this so it'll work it just

00:39:46,230 --> 00:39:53,059
works out of the box and so my idea is

00:39:49,950 --> 00:39:56,369
that genetic programming is just

00:39:53,059 --> 00:39:58,619
programming it's programming like we've

00:39:56,369 --> 00:40:01,019
known it for a long time

00:39:58,619 --> 00:40:03,000
take your time machine go back to last

00:40:01,019 --> 00:40:05,759
year listen to my keynote then it was

00:40:03,000 --> 00:40:09,329
all about that basically a concept

00:40:05,759 --> 00:40:12,660
specifies an interface a type specifies

00:40:09,329 --> 00:40:14,910
an interface plus a layout and basically

00:40:12,660 --> 00:40:18,210
is not that much different between say

00:40:14,910 --> 00:40:20,940
saw the vector and square root of x Bay

00:40:18,210 --> 00:40:23,700
both of them works for a set of types

00:40:20,940 --> 00:40:27,059
that has a set of required properties

00:40:23,700 --> 00:40:30,089
and it doesn't well and I don't actually

00:40:27,059 --> 00:40:32,069
really want to know whether that was an

00:40:30,089 --> 00:40:34,200
overloaded set of functions and that's a

00:40:32,069 --> 00:40:37,380
generic function it'll just work from a

00:40:34,200 --> 00:40:40,079
user point of view and of course the

00:40:37,380 --> 00:40:43,470
default sort uses less than and we have

00:40:40,079 --> 00:40:47,880
all the alternatives for specifying what

00:40:43,470 --> 00:40:50,390
criteria we want I can sort in in the

00:40:47,880 --> 00:40:55,940
opposite order I can sort the lower case

00:40:50,390 --> 00:40:59,240
if it's if it's lists and such so let's

00:40:55,940 --> 00:41:01,170
breeze through this again

00:40:59,240 --> 00:41:07,740
object-oriented programming has had a

00:41:01,170 --> 00:41:10,349
bad press for the last few years I guess

00:41:07,740 --> 00:41:14,190
we can blame various languages including

00:41:10,349 --> 00:41:17,369
C++ but certainly there are languages

00:41:14,190 --> 00:41:21,059
the things that you have to be using

00:41:17,369 --> 00:41:22,470
heritance all the time C++ can do

00:41:21,059 --> 00:41:24,319
inheritance and there's a lot of

00:41:22,470 --> 00:41:30,829
applications where it's the right thing

00:41:24,319 --> 00:41:35,849
here's a with draw shapes examples from

00:41:30,829 --> 00:41:38,640
about 69 67 there abouts when I first

00:41:35,849 --> 00:41:40,619
learned it from Christ new goal or

00:41:38,640 --> 00:41:43,920
design Simula and came up with this

00:41:40,619 --> 00:41:45,240
stuff we have an abstract base class we

00:41:43,920 --> 00:41:48,720
have some overriding from

00:41:45,240 --> 00:41:52,860
actions we build a hierarchy and then we

00:41:48,720 --> 00:41:55,440
can draw the shapes here I've taken the

00:41:52,860 --> 00:41:57,750
forward range I want all the things to

00:41:55,440 --> 00:42:00,030
be derived from shape then I can do a

00:41:57,750 --> 00:42:04,200
range for loop over and print them all

00:42:00,030 --> 00:42:06,750
out the test example here shows that I

00:42:04,200 --> 00:42:10,710
make a bunch of shear pointers you need

00:42:06,750 --> 00:42:12,990
pointers to do physical object oriented

00:42:10,710 --> 00:42:15,360
programming because you program against

00:42:12,990 --> 00:42:18,030
interfaces you don't know what I in

00:42:15,360 --> 00:42:20,220
those interfaces you don't know if that

00:42:18,030 --> 00:42:23,280
shape is a circle or a smiley face or

00:42:20,220 --> 00:42:27,780
triangle so you inherently work with

00:42:23,280 --> 00:42:29,880
less information through pointers and I

00:42:27,780 --> 00:42:32,250
use more smart pointers of course

00:42:29,880 --> 00:42:34,320
because in this case I need pointers and

00:42:32,250 --> 00:42:39,150
I use the smart pointers to avoid leaks

00:42:34,320 --> 00:42:40,920
I really hate leaks now I'm just

00:42:39,150 --> 00:42:41,520
wondering is this object-oriented

00:42:40,920 --> 00:42:45,330
programming

00:42:41,520 --> 00:42:47,630
I don't need a runtime resolution in

00:42:45,330 --> 00:42:50,550
many cases and so I can use a variant

00:42:47,630 --> 00:42:55,010
give me a variant of a circle a triangle

00:42:50,550 --> 00:42:58,530
and smiley this is a closed set of

00:42:55,010 --> 00:43:01,109
alternatives this solution is an open

00:42:58,530 --> 00:43:03,150
set of alternatives but because there's

00:43:01,109 --> 00:43:05,010
a closed set of alternatives you can do

00:43:03,150 --> 00:43:07,770
certain optimizations that you couldn't

00:43:05,010 --> 00:43:08,970
do with an open set so I can do things

00:43:07,770 --> 00:43:13,410
like this

00:43:08,970 --> 00:43:19,140
draw draw all the B in that vector here

00:43:13,410 --> 00:43:22,109
which was a bit of variant and I visit

00:43:19,140 --> 00:43:24,630
them and if it's a circle to it the

00:43:22,109 --> 00:43:26,670
circle way trying to robot the usual

00:43:24,630 --> 00:43:28,950
stuff this by the way works much better

00:43:26,670 --> 00:43:31,140
if the variance if the elements of the

00:43:28,950 --> 00:43:33,420
variants are roughly the same size or

00:43:31,140 --> 00:43:39,930
you have to start implementing within

00:43:33,420 --> 00:43:42,600
directions so 54 close set of similar

00:43:39,930 --> 00:43:44,550
objects this make a lot of sense for an

00:43:42,600 --> 00:43:48,600
open set of dramatically different

00:43:44,550 --> 00:43:51,540
objects this one makes more sense this

00:43:48,600 --> 00:43:53,760
is like problem here I don't know if you

00:43:51,540 --> 00:43:57,859
noticed the overloaded function here

00:43:53,760 --> 00:43:57,859
that's the one that allows me to write

00:43:57,960 --> 00:44:05,630
the variants visitor they're quite

00:44:00,839 --> 00:44:08,400
simply with lambdas are used so you know

00:44:05,630 --> 00:44:13,050
see perhaps past when G isn't perfect it

00:44:08,400 --> 00:44:16,680
is not the end end of our development in

00:44:13,050 --> 00:44:18,270
C++ but you know C++ is extensible if

00:44:16,680 --> 00:44:20,760
it's not understand that you can just

00:44:18,270 --> 00:44:25,109
build your own here's your bill to your

00:44:20,760 --> 00:44:31,589
own I hope this one will be in the it

00:44:25,109 --> 00:44:33,990
the next standard C++ 23 this is not

00:44:31,589 --> 00:44:38,250
totally obvious to anybody who the

00:44:33,990 --> 00:44:39,540
background in old C++ or C but you can

00:44:38,250 --> 00:44:41,970
look and give it up

00:44:39,540 --> 00:44:47,420
there's always another level of

00:44:41,970 --> 00:44:50,760
expertise there's always another sort of

00:44:47,420 --> 00:44:55,050
layer of the onion you can peel off some

00:44:50,760 --> 00:44:57,990
of them are quite simple not necessarily

00:44:55,050 --> 00:45:00,059
easy to understand but you know if you

00:44:57,990 --> 00:45:02,520
need more than it's available at the

00:45:00,059 --> 00:45:04,770
simplest level at the most abstract

00:45:02,520 --> 00:45:10,460
level at the most convenient level you

00:45:04,770 --> 00:45:14,940
can always peel off a layer of Union so

00:45:10,460 --> 00:45:20,309
we need to use machines and operating

00:45:14,940 --> 00:45:23,250
systems resources simply and directly

00:45:20,309 --> 00:45:25,500
and concurrency is one of the major

00:45:23,250 --> 00:45:27,450
things I mean just about anything we do

00:45:25,500 --> 00:45:29,430
these days involve some form of

00:45:27,450 --> 00:45:32,520
concurrency and to make life difficult

00:45:29,430 --> 00:45:37,220
there are many many forms of concurrency

00:45:32,520 --> 00:45:39,630
so here I'm thinking about logging

00:45:37,220 --> 00:45:43,650
thinking about the basic level of

00:45:39,630 --> 00:45:45,960
concurrency with threads and locks so I

00:45:43,650 --> 00:45:47,910
have a musics that protects some data I

00:45:45,960 --> 00:45:50,609
have another musics that take some other

00:45:47,910 --> 00:45:54,299
data I have to grab both of them to do

00:45:50,609 --> 00:46:00,420
an operation I have to grab both mutexes

00:45:54,299 --> 00:46:02,970
so so true to get any work done and I

00:46:00,420 --> 00:46:05,790
better not deadlock I mean I don't want

00:46:02,970 --> 00:46:08,520
this piece of code to take em one before

00:46:05,790 --> 00:46:11,800
him - and this one - take him - before

00:46:08,520 --> 00:46:14,710
m1 it's simply solved in

00:46:11,800 --> 00:46:18,520
the library you ask the school block to

00:46:14,710 --> 00:46:21,190
grab both it will proceed here once it's

00:46:18,520 --> 00:46:23,740
got post and this is our AII so it

00:46:21,190 --> 00:46:26,230
releases at the end of the scope it sits

00:46:23,740 --> 00:46:31,110
so are quite simple and removes one of

00:46:26,230 --> 00:46:33,790
the most common forms of of deadlocks

00:46:31,110 --> 00:46:35,920
there's people who have been working

00:46:33,790 --> 00:46:40,000
over the last sort of twenty years they

00:46:35,920 --> 00:46:41,740
observed that mutex is an operating

00:46:40,000 --> 00:46:45,820
system resource and therefore relatively

00:46:41,740 --> 00:46:48,190
expensive so we need to protect the use

00:46:45,820 --> 00:46:50,440
of music C's with something cheaper so

00:46:48,190 --> 00:46:54,820
we get to double-locked initialization

00:46:50,440 --> 00:47:00,730
using an atomic for that and so we go

00:46:54,820 --> 00:47:03,340
through the the operations of of

00:47:00,730 --> 00:47:05,830
double-locked initialization which looks

00:47:03,340 --> 00:47:09,310
very very simple and we have eliminated

00:47:05,830 --> 00:47:12,040
the data races that could easily happen

00:47:09,310 --> 00:47:16,680
with with bad code of this and it's at a

00:47:12,040 --> 00:47:19,480
quite reasonable level of abstraction

00:47:16,680 --> 00:47:22,500
you use a cheap synchronization

00:47:19,480 --> 00:47:26,380
mechanism so what you to protect a

00:47:22,500 --> 00:47:31,570
expensive mechanism which protects the

00:47:26,380 --> 00:47:33,700
precious initialization if this is too

00:47:31,570 --> 00:47:35,530
high level for you if you really need to

00:47:33,700 --> 00:47:38,410
chew it for a particular piece of code

00:47:35,530 --> 00:47:40,900
maybe code on a machine where the

00:47:38,410 --> 00:47:43,420
compilers weren't able to generate this

00:47:40,900 --> 00:47:47,020
code from the higher-level code you can

00:47:43,420 --> 00:47:49,810
do it there's always another layer of

00:47:47,020 --> 00:47:55,390
the Audion but don't do this unless you

00:47:49,810 --> 00:47:58,030
have to so one thing that I find with C+

00:47:55,390 --> 00:48:01,060
process that it's tunable and there's a

00:47:58,030 --> 00:48:03,730
scenario I find in person on the web

00:48:01,060 --> 00:48:07,180
many times every year a proponent for

00:48:03,730 --> 00:48:11,530
some usually new language access look

00:48:07,180 --> 00:48:14,950
see X is faster than or as fast as or

00:48:11,530 --> 00:48:17,550
almost as fast as C++ it is interesting

00:48:14,950 --> 00:48:20,410
that being not that much slower than C++

00:48:17,550 --> 00:48:25,860
is often claimed to be a great

00:48:20,410 --> 00:48:30,030
achievement okay the answer is well the

00:48:25,860 --> 00:48:32,700
C++ su c-plus performance is very poor

00:48:30,030 --> 00:48:35,070
C++ it's it's not colloquial no

00:48:32,700 --> 00:48:38,250
experience C++ programmer would write it

00:48:35,070 --> 00:48:41,220
like that try this it is as fast as or

00:48:38,250 --> 00:48:42,930
faster than what you just showed and the

00:48:41,220 --> 00:48:46,610
proponents makes usually says that's

00:48:42,930 --> 00:48:48,720
cheating you have violated one of my

00:48:46,610 --> 00:48:52,470
fundamental assumptions about how you

00:48:48,720 --> 00:48:54,570
should write code the C++ programmer

00:48:52,470 --> 00:48:58,050
scratchies hints is this not one of my

00:48:54,570 --> 00:48:59,750
assumptions anyway before all this

00:48:58,050 --> 00:49:02,790
discussion got much further

00:48:59,750 --> 00:49:06,810
another proponent of C++ comes in and

00:49:02,790 --> 00:49:09,360
says you know the the first C++

00:49:06,810 --> 00:49:11,220
programmers version is it's not nearly

00:49:09,360 --> 00:49:13,530
as fast as it should be

00:49:11,220 --> 00:49:17,070
here's a much faster version I've tuned

00:49:13,530 --> 00:49:21,510
it carefully and by now the proponents

00:49:17,070 --> 00:49:28,440
of language X says but my version is

00:49:21,510 --> 00:49:30,510
much easier simpler cleaner and some C++

00:49:28,440 --> 00:49:33,960
proponents is here but I need the

00:49:30,510 --> 00:49:37,110
performance I need this more size or

00:49:33,960 --> 00:49:41,100
whatever is we needed okay but if we

00:49:37,110 --> 00:49:44,550
grant the Iligan easier safer which are

00:49:41,100 --> 00:49:47,550
properties I really love and I want them

00:49:44,550 --> 00:49:50,220
in C++ if I can get them so we wait soon

00:49:47,550 --> 00:49:54,050
after some other proponents says yeah

00:49:50,220 --> 00:49:54,050
here's a library that does that

00:49:54,650 --> 00:50:00,810
sometimes it's a bit clunky but it will

00:49:57,960 --> 00:50:03,420
do it and then you wait a bit and if it

00:50:00,810 --> 00:50:07,700
really was as important as was claimed

00:50:03,420 --> 00:50:10,890
here C++ will develop a feature that

00:50:07,700 --> 00:50:13,200
will actually do that matching the

00:50:10,890 --> 00:50:16,920
original claims of performance and

00:50:13,200 --> 00:50:19,740
elegance C++ is tunable and it is a

00:50:16,920 --> 00:50:23,640
Volvo deliberately available from day

00:50:19,740 --> 00:50:26,700
one and so since it's tunable you can

00:50:23,640 --> 00:50:28,380
make some simple things simple as long

00:50:26,700 --> 00:50:30,300
as you don't make complicated tasks to

00:50:28,380 --> 00:50:33,200
impossible or unreasonably hard to do

00:50:30,300 --> 00:50:37,080
and you go to the onion principle but

00:50:33,200 --> 00:50:39,150
please provide that first level and make

00:50:37,080 --> 00:50:42,809
it possible to go to the next level

00:50:39,150 --> 00:50:46,200
don't don't close the door though so

00:50:42,809 --> 00:50:48,089
this this layer architecture is good and

00:50:46,200 --> 00:50:51,749
as you saw for the onion it's not quite

00:50:48,089 --> 00:50:54,390
layers its encapsulated areas of code

00:50:51,749 --> 00:50:57,119
and you don't drop to the lower level of

00:50:54,390 --> 00:51:00,809
abstraction unless you really really

00:50:57,119 --> 00:51:03,390
need to after or interfaces one of the

00:51:00,809 --> 00:51:07,079
uses of interfaces is to hide ugly stuff

00:51:03,390 --> 00:51:10,769
and so it doesn't have to be pretty all

00:51:07,079 --> 00:51:13,559
the way down and don't make any claims

00:51:10,769 --> 00:51:16,769
of the need to go over level and need to

00:51:13,559 --> 00:51:19,650
optimize unless you measure and and be

00:51:16,769 --> 00:51:24,239
careful I've seen examples recently

00:51:19,650 --> 00:51:26,190
where people optimized based on their

00:51:24,239 --> 00:51:27,930
local machine their laptop or something

00:51:26,190 --> 00:51:31,140
like that and they got really nice

00:51:27,930 --> 00:51:34,079
results they proved that things really

00:51:31,140 --> 00:51:37,259
work much faster with their fine-tuned

00:51:34,079 --> 00:51:39,180
code and then you move it on to the

00:51:37,259 --> 00:51:40,670
server and the production stuff and you

00:51:39,180 --> 00:51:43,619
have actually pesum eyes the

00:51:40,670 --> 00:51:46,259
optimization I mean many more threads

00:51:43,619 --> 00:51:47,969
many more locking can really kill you if

00:51:46,259 --> 00:51:50,519
you have optimized for the wrong thing

00:51:47,969 --> 00:51:51,180
by the way the first time I noticed this

00:51:50,519 --> 00:51:54,930
phenomenon

00:51:51,180 --> 00:51:57,539
a long long time ago doesn't eh is John

00:51:54,930 --> 00:52:00,989
Bentley came and showed a highly

00:51:57,539 --> 00:52:05,069
optimized program for a pdp-11 7 see

00:52:00,989 --> 00:52:10,440
that when ported to a Cray which was a

00:52:05,069 --> 00:52:12,989
hundred times faster ran 16 times law so

00:52:10,440 --> 00:52:15,719
be careful yes never talk about

00:52:12,989 --> 00:52:18,420
performance without measure but really

00:52:15,719 --> 00:52:21,660
be careful furthermore if you have

00:52:18,420 --> 00:52:25,799
something that runs nicely on on one of

00:52:21,660 --> 00:52:27,569
the big national lab machines it may

00:52:25,799 --> 00:52:31,469
actually not work very well on your

00:52:27,569 --> 00:52:34,410
machine and so you may have to change

00:52:31,469 --> 00:52:38,400
the optimization and such when you move

00:52:34,410 --> 00:52:39,960
it onto to smaller machines and so this

00:52:38,400 --> 00:52:41,910
is one reason you want the higher-level

00:52:39,960 --> 00:52:44,489
interfaces because then you can go to

00:52:41,910 --> 00:52:47,009
the lower level separately from

00:52:44,489 --> 00:52:49,229
different kind of architectures again

00:52:47,009 --> 00:52:53,130
direct use of system resources here's a

00:52:49,229 --> 00:52:56,970
very simple use I have n threads

00:52:53,130 --> 00:53:00,980
that does my in tasks fine we use our

00:52:56,970 --> 00:53:03,540
aii at the end of the block they all

00:53:00,980 --> 00:53:06,570
wait for each other and when everybody

00:53:03,540 --> 00:53:07,550
is finished with receipt can't be much

00:53:06,570 --> 00:53:10,440
simpler than that

00:53:07,550 --> 00:53:14,550
however what if I'm doing something like

00:53:10,440 --> 00:53:18,630
a parallel search and I only want to

00:53:14,550 --> 00:53:21,080
know one so when one of these tasks

00:53:18,630 --> 00:53:26,640
straights come up and says I got it I

00:53:21,080 --> 00:53:28,530
really like to tell the other the other

00:53:26,640 --> 00:53:30,930
threads the other tasks to go away

00:53:28,530 --> 00:53:34,650
that's the way you do that with J

00:53:30,930 --> 00:53:37,680
threads you have a stop token and most

00:53:34,650 --> 00:53:40,620
of the code that we write has some kind

00:53:37,680 --> 00:53:43,050
of outer loop that says do something

00:53:40,620 --> 00:53:46,800
then do more than do more and so at a

00:53:43,050 --> 00:53:49,740
trouble loop you just check are people

00:53:46,800 --> 00:53:53,820
still interested in my result and if the

00:53:49,740 --> 00:53:55,650
answer is no I'll go away that's the

00:53:53,820 --> 00:53:58,890
older solution to this problem

00:53:55,650 --> 00:54:03,780
it is now quite simple supported by the

00:53:58,890 --> 00:54:05,280
standard again first level second level

00:54:03,780 --> 00:54:08,420
of the onion okay

00:54:05,280 --> 00:54:11,030
I really don't actually want to write

00:54:08,420 --> 00:54:13,650
threads and tasks and lock

00:54:11,030 --> 00:54:16,650
synchronization that kind of stuff what

00:54:13,650 --> 00:54:20,130
I want is parallel algorithms if I can

00:54:16,650 --> 00:54:23,340
get them I want to sort things compilers

00:54:20,130 --> 00:54:25,230
can't be trusted to actually figure out

00:54:23,340 --> 00:54:27,870
whether you want to parallel eyes and

00:54:25,230 --> 00:54:30,300
vector eyes because well that depends on

00:54:27,870 --> 00:54:33,000
the data and by and large the compilers

00:54:30,300 --> 00:54:36,240
don't know about the data so I can give

00:54:33,000 --> 00:54:39,180
it hints on sequence parallel parallel

00:54:36,240 --> 00:54:42,360
on sequence this is fine and I can write

00:54:39,180 --> 00:54:44,730
around there's a scaling function here I

00:54:42,360 --> 00:54:47,550
wanted vector eyes and I just want to

00:54:44,730 --> 00:54:49,350
scale all the elements this this is sort

00:54:47,550 --> 00:54:52,950
of the level of code I would like to

00:54:49,350 --> 00:54:56,250
write there's only one snag we ran out

00:54:52,950 --> 00:54:59,760
of time for C++ 20 so I have to drop

00:54:56,250 --> 00:55:02,450
down one level again here is what we are

00:54:59,760 --> 00:55:06,390
provided there's an execution policy

00:55:02,450 --> 00:55:09,420
like power on sake and on sick

00:55:06,390 --> 00:55:12,780
and it uses the old-style iterate

00:55:09,420 --> 00:55:18,060
iterators I really want to use my range

00:55:12,780 --> 00:55:21,540
well it's not it's not brain surgery you

00:55:18,060 --> 00:55:24,990
just write it and one thing that has

00:55:21,540 --> 00:55:29,330
been increasing from from day one C++

00:55:24,990 --> 00:55:32,430
but especially since Gabby does raisin I

00:55:29,330 --> 00:55:35,160
proposed constant expression evaluation

00:55:32,430 --> 00:55:39,180
context for functions in eleven is

00:55:35,160 --> 00:55:41,130
compile time programming the basic idea

00:55:39,180 --> 00:55:43,860
is if you can move computation from

00:55:41,130 --> 00:55:45,900
runtime to compile time you can get more

00:55:43,860 --> 00:55:49,050
elegant code you can get more performant

00:55:45,900 --> 00:55:51,170
code you get less calculation off on the

00:55:49,050 --> 00:55:55,770
doodle pad that gives you constants that

00:55:51,170 --> 00:55:57,810
might go wrong if you can do it once by

00:55:55,770 --> 00:55:59,670
the compiler instead of a billion times

00:55:57,810 --> 00:56:02,430
you probably have a performance

00:55:59,670 --> 00:56:05,940
advantage then you don't meet the

00:56:02,430 --> 00:56:07,890
runtime error handling again and I like

00:56:05,940 --> 00:56:09,510
constants they are getting one more

00:56:07,890 --> 00:56:11,160
important with concurrency because you

00:56:09,510 --> 00:56:15,360
can't have a race condition on a

00:56:11,160 --> 00:56:18,330
constant and it's everywhere all loading

00:56:15,360 --> 00:56:21,360
and virtual functions each move a very

00:56:18,330 --> 00:56:24,990
common operation from writing it

00:56:21,360 --> 00:56:27,540
explicitly or resolving at runtime to

00:56:24,990 --> 00:56:29,400
compile time templates does a lot of

00:56:27,540 --> 00:56:32,250
that very attic templates is a good

00:56:29,400 --> 00:56:34,310
example of that that has created much

00:56:32,250 --> 00:56:37,770
more flexibility in the way we write our

00:56:34,310 --> 00:56:41,720
interfaces and basically context work in

00:56:37,770 --> 00:56:45,930
so here's the integer square root that I

00:56:41,720 --> 00:56:48,450
got a male about maybe 20 years ago

00:56:45,930 --> 00:56:52,190
somebody in the embedded systems

00:56:48,450 --> 00:56:55,680
industry wandered means as a square root

00:56:52,190 --> 00:56:57,870
at compile time and it took us a few

00:56:55,680 --> 00:57:00,240
years to figure out how to do it but

00:56:57,870 --> 00:57:03,180
that's the simple square root algorithm

00:57:00,240 --> 00:57:05,720
I know I'm saying it's crunched expa so

00:57:03,180 --> 00:57:09,180
I can take the square root of nine I

00:57:05,720 --> 00:57:11,040
could have done that myself but then I

00:57:09,180 --> 00:57:14,670
would have to match it constants three

00:57:11,040 --> 00:57:17,300
in the program and how would I know that

00:57:14,670 --> 00:57:20,339
it was meant to be the square root of

00:57:17,300 --> 00:57:23,670
nine because when I'm

00:57:20,339 --> 00:57:25,079
reading your code if I see three I do

00:57:23,670 --> 00:57:26,880
not know why it's there

00:57:25,079 --> 00:57:30,749
ELISA says so so you'd have to have a

00:57:26,880 --> 00:57:34,589
comment that is far longer and long or

00:57:30,749 --> 00:57:37,739
long-winded than the then the code nurse

00:57:34,589 --> 00:57:39,809
instead of square root of 1 2 3 4 I may

00:57:37,739 --> 00:57:42,089
not have actually have recognized at all

00:57:39,809 --> 00:57:46,099
and it's not just compile time

00:57:42,089 --> 00:57:49,619
computation the C++ type system is

00:57:46,099 --> 00:57:52,460
extensible it is meant to provide the

00:57:49,619 --> 00:57:54,779
same support for user-defined code and

00:57:52,460 --> 00:57:57,479
buildings user-defined types and

00:57:54,779 --> 00:58:00,749
building types so we can do that here's

00:57:57,479 --> 00:58:02,999
an example from the from chrono from the

00:58:00,749 --> 00:58:07,499
date library I want to write out the

00:58:02,999 --> 00:58:09,089
week day of some day in the past and if

00:58:07,499 --> 00:58:11,099
I want to check it's right I didn't

00:58:09,089 --> 00:58:14,759
actually have the compiler check it for

00:58:11,099 --> 00:58:17,519
me the static assert that means that

00:58:14,759 --> 00:58:22,469
things like June with the weekday of

00:58:17,519 --> 00:58:23,609
June 21 2016 is actually comprehensible

00:58:22,469 --> 00:58:25,410
to the compiler

00:58:23,609 --> 00:58:28,019
it's comprehended and it can figure out

00:58:25,410 --> 00:58:30,390
the answer and it does it also means

00:58:28,019 --> 00:58:33,059
that the code here well there will be no

00:58:30,390 --> 00:58:36,569
code generated but the code here will

00:58:33,059 --> 00:58:40,249
also be very close to optimal and we can

00:58:36,569 --> 00:58:44,430
use things like complex numbers 3 plus

00:58:40,249 --> 00:58:48,719
2.7 III for imaginary composing times

00:58:44,430 --> 00:58:51,450
which is quite common and composing real

00:58:48,719 --> 00:58:54,029
strings as opposed to C style strings

00:58:51,450 --> 00:58:58,140
and it's it's again it's quite simple

00:58:54,029 --> 00:59:00,719
here's the code for the suffix I used

00:58:58,140 --> 00:59:02,849
for imaginary it simply returns a

00:59:00,719 --> 00:59:06,539
complex number with an imaginary part

00:59:02,849 --> 00:59:10,410
and Cyril as the real side so on so on

00:59:06,539 --> 00:59:16,339
it's fairly simple and elegant again

00:59:10,410 --> 00:59:19,019
back to direct use of the the hardware

00:59:16,339 --> 00:59:21,180
one of the things that's really really

00:59:19,019 --> 00:59:22,859
fundamental in the program's so

00:59:21,180 --> 00:59:25,109
fundamental that we don't usually think

00:59:22,859 --> 00:59:27,089
about it is stack frames when we call a

00:59:25,109 --> 00:59:29,849
function it creates a stack frame that

00:59:27,089 --> 00:59:32,009
uses the Machine and it uses stacks

00:59:29,849 --> 00:59:33,780
machines optimized for stacks

00:59:32,009 --> 00:59:36,570
however if you want a code

00:59:33,780 --> 00:59:39,240
she want to have a computation that

00:59:36,570 --> 00:59:43,320
gives her a salt wait a bit and when you

00:59:39,240 --> 00:59:47,730
ask it the next time you it continues

00:59:43,320 --> 00:59:49,920
its computation and give that the next

00:59:47,730 --> 00:59:52,850
research then we have to be able to do

00:59:49,920 --> 00:59:56,940
invocation frames that doesn't follow a

00:59:52,850 --> 00:59:59,760
stack doesn't necessarily follow a stack

00:59:56,940 --> 01:00:02,160
allocation strategy so would like to do

00:59:59,760 --> 01:00:03,780
that and I particularly would like to do

01:00:02,160 --> 01:00:07,470
that because it was my bread and butter

01:00:03,780 --> 01:00:11,190
for 10 years with the early years of C++

01:00:07,470 --> 01:00:12,330
we wouldn't be here if C++ hadn't been

01:00:11,190 --> 01:00:16,350
really good at that

01:00:12,330 --> 01:00:19,380
but unfortunately Sun developed the

01:00:16,350 --> 01:00:23,280
SPARC architecture where my trickery

01:00:19,380 --> 01:00:25,050
with stack frames and registers didn't

01:00:23,280 --> 01:00:28,590
work anymore and they didn't ship it so

01:00:25,050 --> 01:00:32,640
we lost it so one of the things cold

01:00:28,590 --> 01:00:34,650
chains get directly is generators and

01:00:32,640 --> 01:00:36,840
pipelines when you get a little bit more

01:00:34,650 --> 01:00:39,210
advanced you can get fairly

01:00:36,840 --> 01:00:41,070
sophisticated simulations which was what

01:00:39,210 --> 01:00:42,840
I was doing but here's an hour just

01:00:41,070 --> 01:00:44,310
misses sealed

01:00:42,840 --> 01:00:47,100
I would like an infinite sequence

01:00:44,310 --> 01:00:53,160
starting the two I want to filter out

01:00:47,100 --> 01:00:56,130
the things that aren't crimes and I

01:00:53,160 --> 01:01:00,000
would like to get me the first 10,000 of

01:00:56,130 --> 01:01:02,130
those that's fairly simple we are wants

01:01:00,000 --> 01:01:05,850
print them we need a little bit of

01:01:02,130 --> 01:01:09,210
boilerplate here is the core routine it

01:01:05,850 --> 01:01:11,520
has it returns a generator that each

01:01:09,210 --> 01:01:15,120
time you're asked it's gives it the next

01:01:11,520 --> 01:01:17,550
integer so basically the first time you

01:01:15,120 --> 01:01:20,600
call it it gives you start which was to

01:01:17,550 --> 01:01:23,490
the second time 3 and so on and then

01:01:20,600 --> 01:01:25,940
here's the way we we take from a

01:01:23,490 --> 01:01:30,780
sequence if we have a sequence here

01:01:25,940 --> 01:01:34,050
essentially infinite we can simply give

01:01:30,780 --> 01:01:36,300
me in the next element until we have

01:01:34,050 --> 01:01:39,630
gotten the n elements we wanted the

01:01:36,300 --> 01:01:42,660
count elements we wanted 10,000 in that

01:01:39,630 --> 01:01:44,400
case the Eratosthenes a sieve is a

01:01:42,660 --> 01:01:47,250
little bit more complicated to give me

01:01:44,400 --> 01:01:51,290
the first one make a filter

01:01:47,250 --> 01:01:56,340
then then do that recursively and then

01:01:51,290 --> 01:01:58,790
the filter simply looks for the next X

01:01:56,340 --> 01:01:58,790
Prime

01:01:58,910 --> 01:02:03,810
okay

01:02:00,570 --> 01:02:06,660
it actually works this the output there

01:02:03,810 --> 01:02:10,740
I didn't hand calculate this that was

01:02:06,660 --> 01:02:15,270
all the code you needed yeah

01:02:10,740 --> 01:02:19,860
C++ in space I don't know if you noticed

01:02:15,270 --> 01:02:22,260
I wasn't actually using integers I was

01:02:19,860 --> 01:02:25,620
writing generic code very primitive

01:02:22,260 --> 01:02:29,070
generic code I had are using int being

01:02:25,620 --> 01:02:30,180
integer but what if I wanted more prior

01:02:29,070 --> 01:02:32,720
more Prime's

01:02:30,180 --> 01:02:35,910
I could use a long long simply by

01:02:32,720 --> 01:02:41,820
aliasing long long instead of it and I

01:02:35,910 --> 01:02:46,140
could use my infinite precision integer

01:02:41,820 --> 01:02:48,690
if I really wanted big Prime's this is a

01:02:46,140 --> 01:02:52,860
brute-force technique it's not the way

01:02:48,690 --> 01:02:55,530
you would probably do just illnesses see

01:02:52,860 --> 01:02:57,540
but it illustrates the techniques and it

01:02:55,530 --> 01:03:00,150
illustrates that you have the cold

01:02:57,540 --> 01:03:02,970
chains that are fundamentally a way of

01:03:00,150 --> 01:03:06,450
organizing computation and using

01:03:02,970 --> 01:03:10,310
hardware with the generic code and

01:03:06,450 --> 01:03:13,800
aliasing as a composition mechanism and

01:03:10,310 --> 01:03:17,220
most of the use of code scenes today are

01:03:13,800 --> 01:03:19,290
actually simple asynchronous speeding up

01:03:17,220 --> 01:03:23,490
simple simple asynchronous operations

01:03:19,290 --> 01:03:27,000
here's a buffer I read from a socket and

01:03:23,490 --> 01:03:29,160
I writes for a socket and if this one

01:03:27,000 --> 01:03:32,100
waits til there's something read this

01:03:29,160 --> 01:03:36,690
one waits til there's something to write

01:03:32,100 --> 01:03:39,150
and so basically the idea again and

01:03:36,690 --> 01:03:41,720
again is that these things have to work

01:03:39,150 --> 01:03:44,250
in combination and all of these

01:03:41,720 --> 01:03:46,590
principles on my list the rules of

01:03:44,250 --> 01:03:49,230
thumbs my list works in combination and

01:03:46,590 --> 01:03:51,990
one of the things we do is to build

01:03:49,230 --> 01:03:54,990
library from it a user shouldn't have to

01:03:51,990 --> 01:03:58,110
care with a feature is implemented

01:03:54,990 --> 01:04:00,830
that's how it is implemented as building

01:03:58,110 --> 01:04:04,950
or as a

01:04:00,830 --> 01:04:06,600
as a library facility and that that bill

01:04:04,950 --> 01:04:08,520
I actually used to say the library

01:04:06,600 --> 01:04:10,410
design is language design and language

01:04:08,520 --> 01:04:12,930
design is library design it's

01:04:10,410 --> 01:04:15,510
fundamental the same thing you're trying

01:04:12,930 --> 01:04:20,730
to allow the users to express their

01:04:15,510 --> 01:04:23,880
ideas directly and affordably and so we

01:04:20,730 --> 01:04:26,940
need great libraries the standard

01:04:23,880 --> 01:04:30,960
library should be designed with the same

01:04:26,940 --> 01:04:33,270
principles as the language facilities

01:04:30,960 --> 01:04:36,240
because well it is fundamentally the

01:04:33,270 --> 01:04:39,600
same thing I don't want to know whether

01:04:36,240 --> 01:04:43,770
a complex number is a building or a user

01:04:39,600 --> 01:04:46,020
defined type we have lots of libraries a

01:04:43,770 --> 01:04:47,460
lot of them are under standard and we

01:04:46,020 --> 01:04:50,370
should get more on the standard in the

01:04:47,460 --> 01:04:52,860
future and lots and lots of other

01:04:50,370 --> 01:04:54,900
languages I mean there there's at least

01:04:52,860 --> 01:04:56,700
an order of magnitude probably two

01:04:54,900 --> 01:04:59,640
orders who make and shoot between the

01:04:56,700 --> 01:05:02,160
nice stuff we get in the standard

01:04:59,640 --> 01:05:09,540
library and the nice stuff we get by

01:05:02,160 --> 01:05:11,970
downloading so the rules of talk what am

01:05:09,540 --> 01:05:15,720
I going to do here oh one of my favorite

01:05:11,970 --> 01:05:18,000
new libraries here is chrono and it

01:05:15,720 --> 01:05:21,240
gives us time points durations days

01:05:18,000 --> 01:05:23,160
months years and time zones now one of

01:05:21,240 --> 01:05:25,470
the things is that once you get today

01:05:23,160 --> 01:05:28,350
it's a calendar kind of stuff and time

01:05:25,470 --> 01:05:30,390
zones things get very messy this is not

01:05:28,350 --> 01:05:32,880
math anymore it's not computer science

01:05:30,390 --> 01:05:36,870
anymore it's a combination of physics

01:05:32,880 --> 01:05:39,210
physics and local conventions especially

01:05:36,870 --> 01:05:43,920
the local conventions are very tricky

01:05:39,210 --> 01:05:46,500
like the time zones or the the leap

01:05:43,920 --> 01:05:48,360
seconds things like that and the

01:05:46,500 --> 01:05:51,390
standard library chronal takes care of

01:05:48,360 --> 01:05:55,020
that so here is something I found in my

01:05:51,390 --> 01:05:59,220
mail one day from Howard Hinnant who

01:05:55,020 --> 01:06:02,760
designed kronole and so I looked at it a

01:05:59,220 --> 01:06:05,810
bit so he is using kernel and he says

01:06:02,760 --> 01:06:11,670
for all days starting from that date

01:06:05,810 --> 01:06:12,480
until the year becomes 2020 move forward

01:06:11,670 --> 01:06:13,920
two weeks

01:06:12,480 --> 01:06:17,310
so he's looping

01:06:13,920 --> 01:06:20,190
or two weeks period of a year and then

01:06:17,310 --> 01:06:24,870
he gives me that he hits he grabs a time

01:06:20,190 --> 01:06:27,570
in London plus 18 hours

01:06:24,870 --> 01:06:31,200
oh yeah it's six o'clock in London and

01:06:27,570 --> 01:06:35,190
then he writes it out he then gets the

01:06:31,200 --> 01:06:39,600
version of that time for for the

01:06:35,190 --> 01:06:41,720
standard Eastern Time in the US and just

01:06:39,600 --> 01:06:47,430
to show off I think he gives the

01:06:41,720 --> 01:06:52,590
Greenwich Mean Time the UTC now that is

01:06:47,430 --> 01:06:56,370
the share tool for the C++ standards

01:06:52,590 --> 01:07:01,020
committees Direction group so I printed

01:06:56,370 --> 01:07:05,550
it out and this is our meeting times you

01:07:01,020 --> 01:07:07,140
can use this for very useful interesting

01:07:05,550 --> 01:07:08,370
things I wouldn't have guessed that and

01:07:07,140 --> 01:07:10,730
I think most of you wouldn't have

01:07:08,370 --> 01:07:13,800
guessed this was a obvious and easy

01:07:10,730 --> 01:07:16,320
implication notice the for loop and the

01:07:13,800 --> 01:07:23,700
time zones and things like that that

01:07:16,320 --> 01:07:27,180
that one digs tunnels so except for

01:07:23,700 --> 01:07:29,460
implementation details and besides I did

01:07:27,180 --> 01:07:31,770
not mention all of these things sizes

01:07:29,460 --> 01:07:36,020
wrong pointers allocations dear

01:07:31,770 --> 01:07:41,400
occasions loop control costs macros

01:07:36,020 --> 01:07:43,830
resource or flows all this kind of good

01:07:41,400 --> 01:07:47,010
stuff that people talk about you can

01:07:43,830 --> 01:07:49,910
talk about C++ without going there don't

01:07:47,010 --> 01:07:53,480
go to that level unless you have to and

01:07:49,910 --> 01:07:56,240
we can do most of the things that we are

01:07:53,480 --> 01:08:00,360
using as an implementation at that level

01:07:56,240 --> 01:08:03,540
we have to separate what we want to do

01:08:00,360 --> 01:08:06,600
and what we can do and I'm encouraging

01:08:03,540 --> 01:08:09,360
is the right Martin C++ and this is hard

01:08:06,600 --> 01:08:13,470
because a lot of us have sort of

01:08:09,360 --> 01:08:19,920
internalized this kind of stuff over the

01:08:13,470 --> 01:08:24,330
years and anything that's new is often

01:08:19,920 --> 01:08:27,120
assumed to be useless complicated and

01:08:24,330 --> 01:08:30,480
too expensive it isn't on

01:08:27,120 --> 01:08:33,060
average so let's try and do it and we

01:08:30,480 --> 01:08:34,890
have to distinguish what works what's

01:08:33,060 --> 01:08:38,400
maintainable what runs and what's

01:08:34,890 --> 01:08:40,740
affordable and basically you can usually

01:08:38,400 --> 01:08:43,560
at the higher level right type and

01:08:40,740 --> 01:08:45,660
resource safe C++ no leaks no memory

01:08:43,560 --> 01:08:48,060
corruption no garbage collector no

01:08:45,660 --> 01:08:50,370
limitation of Express ability no

01:08:48,060 --> 01:08:53,790
performance degradation you don't have

01:08:50,370 --> 01:08:56,220
to leave standard C++ and the tools are

01:08:53,790 --> 01:08:59,580
coming along there's some Visual Studio

01:08:56,220 --> 01:09:03,290
there's some in client ID I'm looking

01:08:59,580 --> 01:09:07,980
forward to this kind of guarantees to be

01:09:03,290 --> 01:09:11,250
actually guaranteed by a program you can

01:09:07,980 --> 01:09:15,180
by the way never get there if you are

01:09:11,250 --> 01:09:17,910
writing 88 vintage C++ you have to lift

01:09:15,180 --> 01:09:20,550
the level of abstraction to the point

01:09:17,910 --> 01:09:24,210
where the analyzers can understand what

01:09:20,550 --> 01:09:26,370
you're doing and I find that one of the

01:09:24,210 --> 01:09:28,290
good measures of good code and good

01:09:26,370 --> 01:09:30,960
performance is that I can understand it

01:09:28,290 --> 01:09:32,340
if I can't understand it there's a good

01:09:30,960 --> 01:09:34,500
chance that the optimizer can't

01:09:32,340 --> 01:09:36,960
understand it and there's a good chance

01:09:34,500 --> 01:09:40,170
that there's bugs in it so the best way

01:09:36,960 --> 01:09:43,260
of optimizing stuff is to use good

01:09:40,170 --> 01:09:45,420
libraries we use the standard facilities

01:09:43,260 --> 01:09:48,720
then throw away the clever stuff and see

01:09:45,420 --> 01:09:53,610
if it still runs fast enough and often

01:09:48,720 --> 01:09:55,350
does and sometimes speeds up and so one

01:09:53,610 --> 01:09:57,240
of the interesting thing about this talk

01:09:55,350 --> 01:09:59,550
and the thing there was the inspiration

01:09:57,240 --> 01:10:01,890
of this talk is that these rules of

01:09:59,550 --> 01:10:04,710
problems are old they are picked from

01:10:01,890 --> 01:10:08,340
the design and evolution of C++ which

01:10:04,710 --> 01:10:10,740
was from 94 when I was forced to sort of

01:10:08,340 --> 01:10:14,130
collect the rules I've been using for

01:10:10,740 --> 01:10:15,990
C++ and I think this is one of the

01:10:14,130 --> 01:10:20,220
things that has given stability over the

01:10:15,990 --> 01:10:21,810
years the the language features changed

01:10:20,220 --> 01:10:24,090
the feature set change the

01:10:21,810 --> 01:10:26,340
implementations change the optimizer has

01:10:24,090 --> 01:10:30,870
changed but some of the fundamental

01:10:26,340 --> 01:10:35,010
concerns for performance reliability use

01:10:30,870 --> 01:10:38,610
of resources do not change and that

01:10:35,010 --> 01:10:41,040
that's why this still works so I was

01:10:38,610 --> 01:10:43,560
talking about C++ 20 at least

01:10:41,040 --> 01:10:45,780
that was so what is this to do with C++

01:10:43,560 --> 01:10:48,210
20 what is C + + 20

01:10:45,780 --> 01:10:53,970
it's basically the best approximation of

01:10:48,210 --> 01:10:57,390
C++ ideals so far I expect C++ 23 to be

01:10:53,970 --> 01:11:00,240
a better approximation I expect C++ 26

01:10:57,390 --> 01:11:04,260
to be a better approximation of that we

01:11:00,240 --> 01:11:09,060
are not at the end of history and we get

01:11:04,260 --> 01:11:11,010
a lot of useful features in C++ 20 but a

01:11:09,060 --> 01:11:14,990
language is not just the set of features

01:11:11,010 --> 01:11:17,340
and the language is not a layer cake I

01:11:14,990 --> 01:11:19,590
encourage you when you talk to people

01:11:17,340 --> 01:11:23,820
when you try to explain what C++ is

01:11:19,590 --> 01:11:27,480
don't start with C and then say and then

01:11:23,820 --> 01:11:28,500
in C++ 98 we got and then in C++ lemon

01:11:27,480 --> 01:11:30,990
we got and so on

01:11:28,500 --> 01:11:33,600
you will just tire people out before you

01:11:30,990 --> 01:11:36,090
get to the end start with the simple and

01:11:33,600 --> 01:11:39,390
elegant and then peel off a layer of the

01:11:36,090 --> 01:11:40,620
onion when you have to it's so

01:11:39,390 --> 01:11:42,750
superfluous the general-purpose

01:11:40,620 --> 01:11:44,730
programming language for the definition

01:11:42,750 --> 01:11:47,130
in pronunciation and use of lightweight

01:11:44,730 --> 01:11:49,350
abstractions that's still true it's not

01:11:47,130 --> 01:11:51,600
just the grab bag of features there's a

01:11:49,350 --> 01:11:55,860
set of ideals there's a set of design

01:11:51,600 --> 01:11:58,650
principles and yes a community as John

01:11:55,860 --> 01:12:02,880
pointed out it's an evolutionary process

01:11:58,650 --> 01:12:04,590
and it is a process in WT 21 so let's

01:12:02,880 --> 01:12:07,020
just remember the Standards Committee

01:12:04,590 --> 01:12:11,340
they've been hard at work for 30 years

01:12:07,020 --> 01:12:14,750
and starting out that was a group there

01:12:11,340 --> 01:12:17,550
and this was when we voted out modules

01:12:14,750 --> 01:12:21,840
Richard Smith and Gabby dos Reis were

01:12:17,550 --> 01:12:24,180
the main signers and that will help from

01:12:21,840 --> 01:12:26,130
lots of others and you can see the

01:12:24,180 --> 01:12:32,850
committee was very very happy when we

01:12:26,130 --> 01:12:35,550
got modules so this is old story about a

01:12:32,850 --> 01:12:37,710
journalist coming up to an accomplished

01:12:35,550 --> 01:12:40,650
person Allah says o K you have cured

01:12:37,710 --> 01:12:42,680
cancer and ensure word of peace so what

01:12:40,650 --> 01:12:45,720
are you going to do next

01:12:42,680 --> 01:12:49,800
people are never happy right you want

01:12:45,720 --> 01:12:52,080
more so C++ is is the best proximation

01:12:49,800 --> 01:12:55,260
it's not perfect of course but it's

01:12:52,080 --> 01:12:58,230
actually great C++ 20

01:12:55,260 --> 01:13:00,840
I think should complete super +20 there

01:12:58,230 --> 01:13:03,420
are things you cannot know till you ship

01:13:00,840 --> 01:13:05,550
there are things you cannot put into the

01:13:03,420 --> 01:13:07,860
latest release because as a feature

01:13:05,550 --> 01:13:12,750
freeze we need a couple of years to

01:13:07,860 --> 01:13:15,840
actually learn what this is at scale so

01:13:12,750 --> 01:13:18,330
there will be a lot of completing things

01:13:15,840 --> 01:13:21,719
like getting ranges used more

01:13:18,330 --> 01:13:23,910
systematically that are a table and then

01:13:21,719 --> 01:13:26,820
we would like to see standard modules

01:13:23,910 --> 01:13:28,800
I would like my import STD instead of

01:13:26,820 --> 01:13:30,840
having to do it myself

01:13:28,800 --> 01:13:33,870
library support for cold chains is

01:13:30,840 --> 01:13:36,450
incomplete and executors which is the

01:13:33,870 --> 01:13:39,360
model of concurrency and finally getting

01:13:36,450 --> 01:13:42,150
networking in place is a good idea and

01:13:39,360 --> 01:13:45,810
if we have time static reflection more

01:13:42,150 --> 01:13:47,840
compile time evaluation but here with

01:13:45,810 --> 01:13:49,980
generation at compile time and

01:13:47,840 --> 01:13:52,469
functional style pattern matching

01:13:49,980 --> 01:13:54,030
there's been experiments with that there

01:13:52,469 --> 01:13:57,030
are people working on all of these

01:13:54,030 --> 01:14:00,680
things this is an approximation of what

01:13:57,030 --> 01:14:03,960
c++ 23 might be as suggested by

01:14:00,680 --> 01:14:07,020
Villopoto lining and actually supported

01:14:03,960 --> 01:14:09,510
by the directions group and well it's

01:14:07,020 --> 01:14:12,630
hard to make predictions but this is

01:14:09,510 --> 01:14:15,630
what I think we might be seeing in the

01:14:12,630 --> 01:14:19,980
future and so basically the executive

01:14:15,630 --> 01:14:23,090
summary is that C++ 20 is great the

01:14:19,980 --> 01:14:26,370
votes have started national body

01:14:23,090 --> 01:14:29,150
comments are being sent in we have a

01:14:26,370 --> 01:14:32,090
committee draft food it's out for that

01:14:29,150 --> 01:14:36,570
there will be resolutions or problems

01:14:32,090 --> 01:14:41,580
found in the next two meetings and

01:14:36,570 --> 01:14:48,719
hopefully in Prague in February we will

01:14:41,580 --> 01:14:50,880
vote in C++ 20 we we know the outline of

01:14:48,719 --> 01:14:53,520
it we don't know the last little details

01:14:50,880 --> 01:14:54,810
but this is not a detail talk it's not

01:14:53,520 --> 01:14:56,460
going to be perfect

01:14:54,810 --> 01:14:59,840
we're never going to reach there as long

01:14:56,460 --> 01:15:02,790
as we have haven't stopped evolving and

01:14:59,840 --> 01:15:05,160
you can go for the in-depth talk for all

01:15:02,790 --> 01:15:08,050
the features here and all the major

01:15:05,160 --> 01:15:11,020
parts will ship in

01:15:08,050 --> 01:15:13,480
sheep are +20 meaning next year and the

01:15:11,020 --> 01:15:15,850
reason I predict that is all the major

01:15:13,480 --> 01:15:18,400
parts of Sigma plus 20 is shipping

01:15:15,850 --> 01:15:21,490
somewhere today it's just that we don't

01:15:18,400 --> 01:15:24,760
have all the implementation shipping all

01:15:21,490 --> 01:15:29,680
of the major features today that is next

01:15:24,760 --> 01:15:32,740
year presumably before the is own Geneva

01:15:29,680 --> 01:15:36,000
managed to approve the standard we were

01:15:32,740 --> 01:15:38,000
supposedly getting this stuff earlier

01:15:36,000 --> 01:15:50,850
thank you

01:15:38,000 --> 01:15:55,600
[Applause]

01:15:50,850 --> 01:15:59,500
um how is kool-aid going to interact

01:15:55,600 --> 01:16:05,530
with the executor so will it walk a

01:15:59,500 --> 01:16:07,510
thread or censor extinct uses have still

01:16:05,530 --> 01:16:09,430
not finished I don't not know how cool

01:16:07,510 --> 01:16:13,960
routines interact with them but I

01:16:09,430 --> 01:16:16,120
believe that you get a choice and in

01:16:13,960 --> 01:16:18,520
particular as possible to stack up a

01:16:16,120 --> 01:16:24,310
stack of coal genes have been optimized

01:16:18,520 --> 01:16:31,720
at once to do lazy evaluation that was

01:16:24,310 --> 01:16:33,850
true a few months ago good morning thank

01:16:31,720 --> 01:16:36,220
you for taking my question keep Mikolas

01:16:33,850 --> 01:16:39,990
it's my name I work in a financial

01:16:36,220 --> 01:16:43,960
community one of the problems I faced is

01:16:39,990 --> 01:16:47,410
legacy code often on projects were

01:16:43,960 --> 01:16:50,320
working with code that's at least 10 if

01:16:47,410 --> 01:16:52,150
not 20 years old and as I see you

01:16:50,320 --> 01:16:55,270
present these great new ideas and

01:16:52,150 --> 01:16:59,260
concepts can you give me any advice as

01:16:55,270 --> 01:17:01,570
to how to migrate legacy systems often

01:16:59,260 --> 01:17:04,270
there's own a lot of resistance to

01:17:01,570 --> 01:17:07,110
changing these systems because they work

01:17:04,270 --> 01:17:10,030
and they've been hardened thank you I

01:17:07,110 --> 01:17:13,150
have a slight problem with the

01:17:10,030 --> 01:17:16,030
microphone the echo up here so if I get

01:17:13,150 --> 01:17:20,320
your questions likely wrong please

01:17:16,030 --> 01:17:27,070
either correct me or forgive me legacy

01:17:20,320 --> 01:17:29,590
code is a major problem we have well 40

01:17:27,070 --> 01:17:31,510
years worth of legacy code and in many

01:17:29,590 --> 01:17:38,530
industries that means that there are

01:17:31,510 --> 01:17:42,790
code that are 20 years old that I sent

01:17:38,530 --> 01:17:44,050
off for the one organization they don't

01:17:42,790 --> 01:17:46,360
know how it was written the

01:17:44,050 --> 01:17:49,780
documentation isn't there the people

01:17:46,360 --> 01:17:51,700
wrote it weren't there and the unit

01:17:49,780 --> 01:17:53,650
testing had barely been invented and the

01:17:51,700 --> 01:17:58,030
regression testing is incomplete

01:17:53,650 --> 01:18:01,320
and that is a major major problem I

01:17:58,030 --> 01:18:07,070
think my approach is

01:18:01,320 --> 01:18:09,930
is twofold one is for new code try to

01:18:07,070 --> 01:18:15,750
use the modern features and write modern

01:18:09,930 --> 01:18:19,440
code secondly try to get rid of the old

01:18:15,750 --> 01:18:22,860
code either by encapsulating it or by

01:18:19,440 --> 01:18:30,720
actually really writing some of the

01:18:22,860 --> 01:18:33,210
older systems bottom-up we are not going

01:18:30,720 --> 01:18:38,970
to get anything near perfection till we

01:18:33,210 --> 01:18:41,960
get more to support for analyzing both

01:18:38,970 --> 01:18:45,210
old and modern code to detect problems

01:18:41,960 --> 01:18:49,440
so you need things like leak finders and

01:18:45,210 --> 01:18:52,110
I prefer if I can so get statically

01:18:49,440 --> 01:18:53,850
finders that is if you can write your

01:18:52,110 --> 01:18:56,670
code so that you don't have any leaks

01:18:53,850 --> 01:18:57,660
that that is the best way to do it we're

01:18:56,670 --> 01:19:00,140
not there yet

01:18:57,660 --> 01:19:02,970
there are research and deployed

01:19:00,140 --> 01:19:06,570
solutions for rule checkers leak

01:19:02,970 --> 01:19:10,050
checkers things like that but legacy

01:19:06,570 --> 01:19:13,890
problems is legacy code problems is

01:19:10,050 --> 01:19:17,610
common to all languages that has been

01:19:13,890 --> 01:19:20,160
successful legacy code often is just old

01:19:17,610 --> 01:19:23,640
code and if it still works it's really

01:19:20,160 --> 01:19:26,220
hard to get the bean counters to to

01:19:23,640 --> 01:19:28,170
understand that we are actually building

01:19:26,220 --> 01:19:31,040
up technical tests and need to clean up

01:19:28,170 --> 01:19:33,930
the messes what we have to eventually

01:19:31,040 --> 01:19:36,840
all the languages doesn't have as much

01:19:33,930 --> 01:19:38,940
legacy code as C++ because they don't

01:19:36,840 --> 01:19:51,060
have as much code but they'll get there

01:19:38,940 --> 01:19:54,770
if they succeed I have a question what

01:19:51,060 --> 01:19:58,680
was the one single feature in that

01:19:54,770 --> 01:20:02,430
appear to us it was plus eleven that had

01:19:58,680 --> 01:20:06,390
the most profound impact on the language

01:20:02,430 --> 01:20:11,449
and what in your opinion one single

01:20:06,390 --> 01:20:16,929
feature in 2020 supplies blast

01:20:11,449 --> 01:20:22,699
we'll have that similar effect I think

01:20:16,929 --> 01:20:30,040
however I'm going to cheat I'm going to

01:20:22,699 --> 01:20:32,600
give two of each the most important

01:20:30,040 --> 01:20:37,400
single feature that affects the way you

01:20:32,600 --> 01:20:40,250
you write code in C++ 11 is constable

01:20:37,400 --> 01:20:42,770
functions moving a lot of the complex

01:20:40,250 --> 01:20:47,210
template metaprogramming into simple

01:20:42,770 --> 01:20:50,630
ordinary programming with functions to

01:20:47,210 --> 01:20:53,360
produce values so that template

01:20:50,630 --> 01:20:55,550
metaprogramming can be reserved to the

01:20:53,360 --> 01:20:57,380
things that that computes types and

01:20:55,550 --> 01:21:00,440
things that doesn't fit into the

01:20:57,380 --> 01:21:02,510
functional pattern very well and this

01:21:00,440 --> 01:21:04,580
has been spreading like wildfire to the

01:21:02,510 --> 01:21:07,550
point where I am worrying that we are

01:21:04,580 --> 01:21:14,360
you doing too much of it the invisible

01:21:07,550 --> 01:21:17,060
part of C++ 11 that was most important

01:21:14,360 --> 01:21:21,469
is simply the support for basic

01:21:17,060 --> 01:21:24,380
concurrency we had been doing concurrent

01:21:21,469 --> 01:21:26,390
programming for ages before but has not

01:21:24,380 --> 01:21:29,360
been standard people have been using

01:21:26,390 --> 01:21:34,179
POSIX directly using macros and void

01:21:29,360 --> 01:21:34,179
star stars lifting the level of

01:21:35,739 --> 01:21:43,219
expression of the thread and locks kind

01:21:38,690 --> 01:21:45,350
of code to a type safe level and having

01:21:43,219 --> 01:21:48,800
a machine model underlying it that makes

01:21:45,350 --> 01:21:50,449
it make sense was the most important so

01:21:48,800 --> 01:21:52,340
we have the visible thing which is the

01:21:50,449 --> 01:21:54,110
context of a function and the invisible

01:21:52,340 --> 01:21:58,400
things which is basically the

01:21:54,110 --> 01:22:01,070
concurrency model similar for C++ 20 I

01:21:58,400 --> 01:22:03,830
think the thing that'll have the most

01:22:01,070 --> 01:22:06,949
impact on the way we write code is

01:22:03,830 --> 01:22:10,130
concepts because it'll make generic code

01:22:06,949 --> 01:22:14,570
much easier much more elegant and much

01:22:10,130 --> 01:22:18,020
more widely useful increasing the

01:22:14,570 --> 01:22:21,429
express ability of what we are doing and

01:22:18,020 --> 01:22:23,739
again taking some parts of what is now

01:22:21,429 --> 01:22:25,840
complicated simpler metaprogramming

01:22:23,739 --> 01:22:29,079
and trending into something much simpler

01:22:25,840 --> 01:22:34,840
template metaprogramming was a widely

01:22:29,079 --> 01:22:37,030
successful c++ 98 feature but it didn't

01:22:34,840 --> 01:22:40,539
have enough support and the fact that it

01:22:37,030 --> 01:22:42,760
was so heavily used over the years even

01:22:40,539 --> 01:22:45,789
though it was so ugly and difficult this

01:22:42,760 --> 01:22:49,690
approved its utility so we make we have

01:22:45,789 --> 01:22:51,179
to make it easier to do the things that

01:22:49,690 --> 01:22:54,340
was done with template metaprogramming

01:22:51,179 --> 01:22:57,219
the invisible part actually is the

01:22:54,340 --> 01:23:03,429
modules the module should with a bit of

01:22:57,219 --> 01:23:07,389
loc improve our compile speeds by say 5

01:23:03,429 --> 01:23:09,699
to 10 times and that is a major thing

01:23:07,389 --> 01:23:11,679
it'll change the way we work what a

01:23:09,699 --> 01:23:13,929
fundamental structure of our programs

01:23:11,679 --> 01:23:16,929
will actually not change that's why I

01:23:13,929 --> 01:23:19,749
call it invisible the way you get that

01:23:16,929 --> 01:23:22,949
advantage major compile-time advantage

01:23:19,749 --> 01:23:29,380
is by cleaning up your coat

01:23:22,949 --> 01:23:31,360
removing disgusting dependencies saving

01:23:29,380 --> 01:23:33,280
the compiler for compiling the same

01:23:31,360 --> 01:23:38,190
thing 10 times over because you might

01:23:33,280 --> 01:23:41,320
have a macro that is different so yeah

01:23:38,190 --> 01:23:47,610
cheating I can't count to one got two

01:23:41,320 --> 01:23:53,860
but I think I have a point yes thank you

01:23:47,610 --> 01:23:58,329
hey so I wanted to go back to your don't

01:23:53,860 --> 01:24:01,239
pay you don't use principal which I very

01:23:58,329 --> 01:24:03,610
much strongly agree with but I had a

01:24:01,239 --> 01:24:08,019
colleague recently challenged me on that

01:24:03,610 --> 01:24:12,190
saying that if we had time zones 220 or

01:24:08,019 --> 01:24:15,190
we add graphics or whatever 23 and we

01:24:12,190 --> 01:24:17,679
don't use them as a company we still pay

01:24:15,190 --> 01:24:20,769
for them because we pay the implementers

01:24:17,679 --> 01:24:25,449
to implement those things in money not

01:24:20,769 --> 01:24:27,340
in cycles but I had a response for him

01:24:25,449 --> 01:24:28,840
that I wasn't quite satisfied with

01:24:27,340 --> 01:24:31,530
myself I'd be interested to hear your

01:24:28,840 --> 01:24:34,620
response to that yeah

01:24:31,530 --> 01:24:34,620
[Music]

01:24:36,449 --> 01:24:52,600
yeah somebody has to pay and I I think

01:24:46,440 --> 01:24:56,520
maybe my statement of the cereal head

01:24:52,600 --> 01:25:00,850
principle has been taken out of the

01:24:56,520 --> 01:25:05,020
context of writing code and looking at

01:25:00,850 --> 01:25:11,890
the generated machine code and such and

01:25:05,020 --> 01:25:14,710
into a different domain and I have for a

01:25:11,890 --> 01:25:17,219
long time I think its DNA had the

01:25:14,710 --> 01:25:20,949
philosophy that if you can do things

01:25:17,219 --> 01:25:23,460
once or a hundred times or a thousand

01:25:20,949 --> 01:25:26,370
times it's much much better to do it in

01:25:23,460 --> 01:25:30,179
then doing it in a million times and

01:25:26,370 --> 01:25:36,280
therefore rather put a burden on

01:25:30,179 --> 01:25:38,770
implementers then on users and I think

01:25:36,280 --> 01:25:43,300
that's what we're doing here a lot of

01:25:38,770 --> 01:25:46,719
users benefit I know huge industries

01:25:43,300 --> 01:25:51,100
that they hint critically on kronole

01:25:46,719 --> 01:25:57,429
with time zones and the works and they

01:25:51,100 --> 01:26:00,400
pay a price every time they use a time

01:25:57,429 --> 01:26:02,410
zone library and sometimes that prices

01:26:00,400 --> 01:26:07,480
and the dollars to library vendors and

01:26:02,410 --> 01:26:12,640
such all of that code goes away maybe

01:26:07,480 --> 01:26:16,840
for ten fifty thousand organizations on

01:26:12,640 --> 01:26:21,510
earth and your implementers get stuck

01:26:16,840 --> 01:26:24,820
with it how many are there five ten I

01:26:21,510 --> 01:26:29,620
think I just made a major saving for the

01:26:24,820 --> 01:26:32,320
community that that's the principle that

01:26:29,620 --> 01:26:34,420
that I can bring forward here but but I

01:26:32,320 --> 01:26:37,140
think the the principle was yanked out

01:26:34,420 --> 01:26:37,140
of context

01:26:43,729 --> 01:26:48,809
hello BRE thank you very much for the

01:26:46,739 --> 01:26:50,489
talk my name is karellen network Phoenix

01:26:48,809 --> 01:26:52,949
and here's my question

01:26:50,489 --> 01:26:56,159
two of the rules of thumb you mentioned

01:26:52,949 --> 01:26:58,309
were compiled compile time detection and

01:26:56,159 --> 01:27:00,739
systematic general resource management

01:26:58,309 --> 01:27:03,389
specifically the ownership management

01:27:00,739 --> 01:27:07,590
but there is nothing in C++ that

01:27:03,389 --> 01:27:10,499
enforces ownership control at compile

01:27:07,590 --> 01:27:13,679
time like the burrow checker at the rust

01:27:10,499 --> 01:27:15,570
programming language other any plans on

01:27:13,679 --> 01:27:18,119
introducing a new mechanism that will

01:27:15,570 --> 01:27:23,760
check ownership at compile time thank

01:27:18,119 --> 01:27:27,419
you I don't have any plans for a feature

01:27:23,760 --> 01:27:30,269
and forces over ship at compile time the

01:27:27,419 --> 01:27:32,489
the problem with that is that then all

01:27:30,269 --> 01:27:36,389
the old code that doesn't use it will

01:27:32,489 --> 01:27:41,820
break instead I'm aiming at this

01:27:36,389 --> 01:27:44,280
distinction between the code that we

01:27:41,820 --> 01:27:46,590
consider good and the control we

01:27:44,280 --> 01:27:49,429
consider legal and we use coding

01:27:46,590 --> 01:27:54,239
guidelines and statically enforced

01:27:49,429 --> 01:27:56,969
coding guidelines where we can enter the

01:27:54,239 --> 01:27:59,820
extent we can as opposed to changing the

01:27:56,969 --> 01:28:03,809
language to try to enforce something

01:27:59,820 --> 01:28:07,590
that we probably could I do not know how

01:28:03,809 --> 01:28:09,419
much C++ code is out there but I have

01:28:07,590 --> 01:28:11,489
been told off recently for saying

01:28:09,419 --> 01:28:14,249
hundreds of billions of lines somebody

01:28:11,489 --> 01:28:16,860
wants me to mention trillion and I'm not

01:28:14,249 --> 01:28:19,289
sure I can but we're getting there and

01:28:16,860 --> 01:28:21,869
that means the change in language to

01:28:19,289 --> 01:28:25,320
outlaw most of that is not going to fly

01:28:21,869 --> 01:28:29,129
so instead I want to aim for four code

01:28:25,320 --> 01:28:30,899
checkers and style guides because if you

01:28:29,129 --> 01:28:33,329
have a style guide that says you don't

01:28:30,899 --> 01:28:35,849
have any leaks and the sleek finders now

01:28:33,329 --> 01:28:37,979
static leak finders that proves that you

01:28:35,849 --> 01:28:40,320
actually can do it in the language if

01:28:37,979 --> 01:28:44,789
you want it but I don't see us deploying

01:28:40,320 --> 01:28:45,880
such a language feature thanks for the

01:28:44,789 --> 01:28:51,100
answer

01:28:45,880 --> 01:28:53,670
I think for the talk

01:28:51,100 --> 01:28:57,760
my name is Cyril I'm from Bloomberg

01:28:53,670 --> 01:29:00,250
going forward on the designing new

01:28:57,760 --> 01:29:03,760
project starting from scratch you

01:29:00,250 --> 01:29:06,250
discourage reliance on abstract base

01:29:03,760 --> 01:29:09,970
classes as interfaces as abstractions

01:29:06,250 --> 01:29:12,750
and possibly going forward is other any

01:29:09,970 --> 01:29:17,140
plans to phase out then a morphism

01:29:12,750 --> 01:29:21,790
altogether first of all it is very rare

01:29:17,140 --> 01:29:24,010
that we start really from scratch it is

01:29:21,790 --> 01:29:26,950
much more common that there is a code

01:29:24,010 --> 01:29:31,960
base already or that we start by

01:29:26,950 --> 01:29:36,700
including five or ten fairly massive

01:29:31,960 --> 01:29:41,620
libraries that were designed 10 15 20

01:29:36,700 --> 01:29:44,530
years ago furthermore I'm still of the

01:29:41,620 --> 01:29:47,890
opinion that there are domains where a

01:29:44,530 --> 01:29:50,170
physical object oriented programming is

01:29:47,890 --> 01:29:54,250
a good and possibly even the best

01:29:50,170 --> 01:29:56,110
solution so I would not discourage the

01:29:54,250 --> 01:30:00,970
use of class hierarchies and virtual

01:29:56,110 --> 01:30:04,230
functions what I would do and do is to

01:30:00,970 --> 01:30:07,030
recommend people look carefully at the

01:30:04,230 --> 01:30:10,120
problem to be solved and see if it

01:30:07,030 --> 01:30:13,090
really is hierarchical and if it really

01:30:10,120 --> 01:30:16,030
does need runtime resolution and it

01:30:13,090 --> 01:30:18,880
really needs open sets of alternatives

01:30:16,030 --> 01:30:24,210
and if the answer to those things are

01:30:18,880 --> 01:30:28,200
yes use traditional hierarchy based

01:30:24,210 --> 01:30:31,450
object-oriented programming and my

01:30:28,200 --> 01:30:37,630
suspicion is that there is very

01:30:31,450 --> 01:30:39,760
significant sections of the fundamental

01:30:37,630 --> 01:30:42,580
rockin areas for which this makes sense

01:30:39,760 --> 01:30:44,680
and there's a much larger series where

01:30:42,580 --> 01:30:47,710
there are libraries and support systems

01:30:44,680 --> 01:30:51,930
that are structured that way mostly in

01:30:47,710 --> 01:30:54,670
graphics and GUI but also in control of

01:30:51,930 --> 01:30:58,390
hardware gadgets where you have an

01:30:54,670 --> 01:30:59,480
abstract class as stable interface to a

01:30:58,390 --> 01:31:02,300
series

01:30:59,480 --> 01:31:08,960
of gadgets say different models electro

01:31:02,300 --> 01:31:13,180
motors and such in other words I don't

01:31:08,960 --> 01:31:13,180
think everything should be attempted I

01:31:15,340 --> 01:31:27,680
think we have run out so thank you

01:31:19,080 --> 01:31:27,680

YouTube URL: https://www.youtube.com/watch?v=u_ij0YNkFUs


