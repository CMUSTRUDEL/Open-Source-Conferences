Title: CppCon 2019: Klaus Iglberger “Back to Basics: Move Semantics (part 2 of 2)”
Publication date: 2019-09-27
Playlist: CppCon 2019
Description: 
	http://CppCon.org
—
Discussion & Comments: https://www.reddit.com/r/cpp/
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2019
—
Move semantics is one of the most complex topics in the world of C++, including many technical details that often confuse even experts. This interactive back-to-the-basics session is entirely focused on understanding the details behind move semantics. It explains the motivation behind move semantics, the need for rvalue references and std::move, the reason for forwarding references and std::forward, and how to properly apply move semantics. The many interactive questions and exercises will help to quickly adapt the newly gained knowledge.
— 
Klaus Iglberger
Siemens
C++ Trainer/Consultant
Nürnberg Area, Germany

Klaus Iglberger is a freelancing C++ trainer and consultant and is currently on the payroll of Siemens in Nuremberg, Germany. He has finished his PhD in computer science in 2010 and since then is focused on large-scale C++ software design. He shares his experience in popular advanced C++ courses around the world (mainly in Germany, but also the EU and US). Additionally, he is the initiator and lead designer of the Blaze C++ math library (https://bitbucket.org/blaze-lib/blaze/src/master/) and the organizer of the Munich C++ user group (https://www.meetup.com/MUCplusplus/).
—
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:10,820 --> 00:00:16,129
so welcome ladies and gentlemen welcome

00:00:12,980 --> 00:00:18,560
to back to basics smooth semantics part

00:00:16,129 --> 00:00:22,430
2 perhaps a slightly more interesting

00:00:18,560 --> 00:00:25,550
part because this is now going more into

00:00:22,430 --> 00:00:26,660
the details of move semantics so for

00:00:25,550 --> 00:00:27,380
those who have not been here in the

00:00:26,660 --> 00:00:30,079
first part

00:00:27,380 --> 00:00:33,200
my name is Chloe burger - a surplus of

00:00:30,079 --> 00:00:35,420
trainer since 2016 I'm also senior soft

00:00:33,200 --> 00:00:37,190
engineer it's seaman's and I might know

00:00:35,420 --> 00:00:39,110
one of my works I'm the author of the

00:00:37,190 --> 00:00:42,739
place he passed pass math library also

00:00:39,110 --> 00:00:45,080
additionally I am co-organizer one of

00:00:42,739 --> 00:00:47,630
the four organizes of the Munich C++

00:00:45,080 --> 00:00:50,630
user group also sometimes present Etsy

00:00:47,630 --> 00:00:53,990
places conferences we are now in part

00:00:50,630 --> 00:00:56,540
two in this part I will be dealing with

00:00:53,990 --> 00:00:58,910
forwarding references meaning we will

00:00:56,540 --> 00:01:00,440
talk about perfect forwarding pairs of

00:00:58,910 --> 00:01:02,960
perfect for wedding and overloading with

00:01:00,440 --> 00:01:05,210
for wedding references and I will also

00:01:02,960 --> 00:01:07,970
show a couple of common pitfalls that

00:01:05,210 --> 00:01:09,799
hopefully afterwards you will avoid this

00:01:07,970 --> 00:01:12,670
part is going to be a little more

00:01:09,799 --> 00:01:15,830
interactive than the first part again

00:01:12,670 --> 00:01:19,100
please if you know the answer because

00:01:15,830 --> 00:01:21,500
you are a very experienced C++ guy allow

00:01:19,100 --> 00:01:22,970
the audience the rest of the people to

00:01:21,500 --> 00:01:25,640
think about this for let's say three

00:01:22,970 --> 00:01:28,820
seconds and then you can give it away

00:01:25,640 --> 00:01:31,430
this I think this is just fair this is

00:01:28,820 --> 00:01:33,500
okay if you have a question in between I

00:01:31,430 --> 00:01:35,479
believe we have enough time for that

00:01:33,500 --> 00:01:37,280
please go up to the mic now it's been

00:01:35,479 --> 00:01:40,880
moved forward the acoustics should be a

00:01:37,280 --> 00:01:43,570
little better now so for the recording

00:01:40,880 --> 00:01:45,830
this is perfect please use the mic

00:01:43,570 --> 00:01:48,290
alright this is the feeling that you

00:01:45,830 --> 00:01:51,140
still have from the first part yes I

00:01:48,290 --> 00:01:53,479
have mastered move semantics it's not

00:01:51,140 --> 00:01:55,250
that difficult why are people

00:01:53,479 --> 00:01:59,030
complaining why is this something that

00:01:55,250 --> 00:02:02,420
people argue is so difficult one of the

00:01:59,030 --> 00:02:06,890
most difficult features well I did not

00:02:02,420 --> 00:02:10,909
mention another feature I'm not talking

00:02:06,890 --> 00:02:13,849
about forwarding references these two

00:02:10,909 --> 00:02:17,390
fellows here the red ones T ref ref and

00:02:13,849 --> 00:02:19,639
also this r2 ref ref this looks like our

00:02:17,390 --> 00:02:21,260
value references to some extended

00:02:19,639 --> 00:02:22,700
purposes you feels like an R value

00:02:21,260 --> 00:02:24,140
reference if you look at it but

00:02:22,700 --> 00:02:27,380
unfortunately it's not

00:02:24,140 --> 00:02:29,600
this is a special kind of reference and

00:02:27,380 --> 00:02:36,140
immediately this good feeling that you

00:02:29,600 --> 00:02:37,220
have before is gone oh my what have they

00:02:36,140 --> 00:02:40,820
done okay

00:02:37,220 --> 00:02:42,830
so at first give me a chance to explain

00:02:40,820 --> 00:02:45,590
what forwarding references are because

00:02:42,830 --> 00:02:47,230
they indeed are special a forwarding

00:02:45,590 --> 00:02:50,900
reference represents an l-value

00:02:47,230 --> 00:02:53,690
reference if you pass it in ll value and

00:02:50,900 --> 00:02:57,440
as a reminder and L value is something

00:02:53,690 --> 00:03:00,320
with a name and a forwarding reference

00:02:57,440 --> 00:03:03,650
represents an r-value reference if you

00:03:00,320 --> 00:03:06,110
give it an R value so meaning it adapts

00:03:03,650 --> 00:03:09,140
it is whatever you initialize it with

00:03:06,110 --> 00:03:11,690
and an R value reference is in fact

00:03:09,140 --> 00:03:13,820
forwarding reference if it involves type

00:03:11,690 --> 00:03:14,959
deduction and this is exactly these two

00:03:13,820 --> 00:03:18,290
thinks so

00:03:14,959 --> 00:03:20,780
either function template or order and if

00:03:18,290 --> 00:03:23,900
it appears in exactly this form so only

00:03:20,780 --> 00:03:26,810
if you encounter and in quotation marks

00:03:23,900 --> 00:03:28,519
are value reference in this form then it

00:03:26,810 --> 00:03:33,080
happens to be the special kind of

00:03:28,519 --> 00:03:34,910
reference and r-value reference now let

00:03:33,080 --> 00:03:37,880
me show you why they are special why

00:03:34,910 --> 00:03:39,680
they behave differently let's say that I

00:03:37,880 --> 00:03:42,920
indeed have a function camp template

00:03:39,680 --> 00:03:45,170
called foo and food takes an T ref ref

00:03:42,920 --> 00:03:47,330
argument well remember this is one of

00:03:45,170 --> 00:03:49,160
the forms I showed before and just to

00:03:47,330 --> 00:03:51,410
prove that something happens I have

00:03:49,160 --> 00:03:55,160
added some output now in the main

00:03:51,410 --> 00:03:59,350
function I have a widget this is an LL

00:03:55,160 --> 00:04:03,110
value it has a name and I pass it to foo

00:03:59,350 --> 00:04:05,959
it should not work from all I've said so

00:04:03,110 --> 00:04:08,450
far this should not compile because an L

00:04:05,959 --> 00:04:11,330
value should not bind to novel reference

00:04:08,450 --> 00:04:13,250
this would be bad we would move from the

00:04:11,330 --> 00:04:16,820
L value the elavil can still be used I

00:04:13,250 --> 00:04:21,229
have a name this would be bad but it

00:04:16,820 --> 00:04:23,419
does compile and it prints so this is

00:04:21,229 --> 00:04:26,690
the signature it does compile and it

00:04:23,419 --> 00:04:31,270
prints fruity ref ref so I've called the

00:04:26,690 --> 00:04:36,160
function surprisingly now what happens

00:04:31,270 --> 00:04:36,789
why does this work well in argument

00:04:36,160 --> 00:04:41,370
deduction

00:04:36,789 --> 00:04:45,759
this team is Fornell value deduced to be

00:04:41,370 --> 00:04:47,169
widget ref I can I don't unfortunate

00:04:45,759 --> 00:04:49,990
don't have time to go into details why

00:04:47,169 --> 00:04:52,569
this is now made of widget ref there is

00:04:49,990 --> 00:04:54,849
a one-hour talk by Scott Myers from 2014

00:04:52,569 --> 00:04:57,430
that goes in a lot of detail about type

00:04:54,849 --> 00:04:59,889
deduction but believe me T is the juice

00:04:57,430 --> 00:05:03,009
to be widget ref but there is another

00:04:59,889 --> 00:05:06,729
set of references so I have widget ref

00:05:03,009 --> 00:05:09,160
space ref ref the space actually makes

00:05:06,729 --> 00:05:10,630
it something different you are actually

00:05:09,160 --> 00:05:13,030
not allowed to write this kind of code

00:05:10,630 --> 00:05:17,530
you cannot make a reference to reference

00:05:13,030 --> 00:05:19,479
this is illegal but the the compiler

00:05:17,530 --> 00:05:22,300
cannot can come up with this new entire

00:05:19,479 --> 00:05:23,470
deduction now I have two references an

00:05:22,300 --> 00:05:27,820
l-value reference and an r-value

00:05:23,470 --> 00:05:30,639
reference we must do something and it's

00:05:27,820 --> 00:05:32,740
something called reference collapsing if

00:05:30,639 --> 00:05:35,380
indeed during template argument

00:05:32,740 --> 00:05:38,889
deduction I have a reference to a

00:05:35,380 --> 00:05:42,130
reference then I simply remove one of

00:05:38,889 --> 00:05:44,919
them and rule is as soon as I have one L

00:05:42,130 --> 00:05:46,870
value reference in this mix the result

00:05:44,919 --> 00:05:49,530
is an L value reference only and

00:05:46,870 --> 00:05:53,620
exclusively if I have a ref ref ref ref

00:05:49,530 --> 00:05:55,120
in the end I have a ref ref and so now

00:05:53,620 --> 00:06:00,990
you understand why there's so many dog

00:05:55,120 --> 00:06:04,539
jokes okay in this case I end up with a

00:06:00,990 --> 00:06:05,800
single L value reference that's the

00:06:04,539 --> 00:06:08,530
deduction rule or the reference

00:06:05,800 --> 00:06:10,150
collapsing rule and so finally this is

00:06:08,530 --> 00:06:12,759
the function that we would have a

00:06:10,150 --> 00:06:15,430
function the full function that takes an

00:06:12,759 --> 00:06:18,520
L value because it's an L value

00:06:15,430 --> 00:06:21,909
reference and so it compiles I can pass

00:06:18,520 --> 00:06:26,710
W to the function it's an L value this

00:06:21,909 --> 00:06:29,620
fits perfectly I know this is a little

00:06:26,710 --> 00:06:32,020
frightening but what about our values

00:06:29,620 --> 00:06:34,199
let's pass an R value let's create a

00:06:32,020 --> 00:06:38,169
widget without a name this is an R value

00:06:34,199 --> 00:06:41,680
in this particular case okay again it

00:06:38,169 --> 00:06:43,260
calls the function it prints foo so also

00:06:41,680 --> 00:06:45,600
this works

00:06:43,260 --> 00:06:49,710
and it works because now this T is

00:06:45,600 --> 00:06:52,170
deduced to be simply widget okay again

00:06:49,710 --> 00:06:56,640
don't ask me about the details

00:06:52,170 --> 00:06:59,370
the result is widget ref ref and this is

00:06:56,640 --> 00:07:01,710
exactly the kind of argument that the

00:06:59,370 --> 00:07:05,010
parameter that I need to pass an r-value

00:07:01,710 --> 00:07:10,200
widget widget refer it fits perfectly

00:07:05,010 --> 00:07:15,240
oh my I know what you're thinking right

00:07:10,200 --> 00:07:18,870
now what okay take a deep breath yeah so

00:07:15,240 --> 00:07:21,840
perhaps this helps a little bit okay

00:07:18,870 --> 00:07:23,700
relax your mind a little bit of course

00:07:21,840 --> 00:07:26,940
there is a very very good reason why

00:07:23,700 --> 00:07:29,310
they added this to C++ and now I have to

00:07:26,940 --> 00:07:31,890
some extent blame how I didn't he came

00:07:29,310 --> 00:07:35,400
up with this because there was indeed a

00:07:31,890 --> 00:07:38,040
problem was truly and soft in C++ 98 and

00:07:35,400 --> 00:07:43,650
oh three so prior C++ 11 and this

00:07:38,040 --> 00:07:46,880
problem is perfect for wording if you

00:07:43,650 --> 00:07:49,080
want to write a function that is merely

00:07:46,880 --> 00:07:52,830
forwarding its arguments to some other

00:07:49,080 --> 00:07:55,050
function then you have exactly this

00:07:52,830 --> 00:07:57,660
situation so a good example is the

00:07:55,050 --> 00:07:59,730
simplest is 14 make unique makes uni

00:07:57,660 --> 00:08:01,620
tasks is just to forward the arguments

00:07:59,730 --> 00:08:05,700
that give to it to the constructor of a

00:08:01,620 --> 00:08:09,810
T and so whatever T I have I just want

00:08:05,700 --> 00:08:10,700
to forward the arguments now how do I do

00:08:09,810 --> 00:08:13,320
that

00:08:10,700 --> 00:08:16,020
this interestingly was a problem totally

00:08:13,320 --> 00:08:19,500
unsolved prior to C plus 11 of pre C

00:08:16,020 --> 00:08:22,950
plus 11 because there was not not a good

00:08:19,500 --> 00:08:27,780
general solution the first solution that

00:08:22,950 --> 00:08:32,130
we would have is to pass by value this

00:08:27,780 --> 00:08:34,410
works pretty often it might not work for

00:08:32,130 --> 00:08:36,570
types that are not copyable though this

00:08:34,410 --> 00:08:39,300
is alimentation and of course this

00:08:36,570 --> 00:08:42,780
creates overhead imagine that i want to

00:08:39,300 --> 00:08:45,420
pass a string a vector something big I

00:08:42,780 --> 00:08:47,700
do not want to create an extra copy this

00:08:45,420 --> 00:08:49,650
is not perfect forwarding this would be

00:08:47,700 --> 00:08:53,610
kind of a forwarding but not perfect

00:08:49,650 --> 00:08:55,660
forwarding so for instance yeah

00:08:53,610 --> 00:08:57,940
imps would be fine

00:08:55,660 --> 00:09:02,889
widgets you saw this contained string

00:08:57,940 --> 00:09:06,060
unit pointer this would be expensive we

00:09:02,889 --> 00:09:08,740
could pass by reference non constants

00:09:06,060 --> 00:09:11,379
that surprisingly works for console

00:09:08,740 --> 00:09:15,339
village too so our could also have a

00:09:11,379 --> 00:09:18,550
Const but this year for instance this

00:09:15,339 --> 00:09:21,879
would not work I could not pass an

00:09:18,550 --> 00:09:24,279
r-value because in our Valley does not

00:09:21,879 --> 00:09:27,339
bind to an l-value reference to none

00:09:24,279 --> 00:09:31,300
Const it should not this was something

00:09:27,339 --> 00:09:33,850
at from the so in before the standard

00:09:31,300 --> 00:09:36,730
was forbidden this also causes problems

00:09:33,850 --> 00:09:38,709
a lot so this would not compile it's not

00:09:36,730 --> 00:09:41,350
perfect forwarding either called group

00:09:38,709 --> 00:09:44,110
of arguments would be impossible and the

00:09:41,350 --> 00:09:47,920
third option 1/2 is reference to Const

00:09:44,110 --> 00:09:50,649
of course the usual default this is

00:09:47,920 --> 00:09:53,639
actually not so bad it works for a lot

00:09:50,649 --> 00:09:55,990
of things but it is again one limitation

00:09:53,639 --> 00:09:59,410
let's say for instance that I have a

00:09:55,990 --> 00:10:01,269
class example that takes an int ref and

00:09:59,410 --> 00:10:03,370
I want to create an example so it has

00:10:01,269 --> 00:10:05,170
constructed they take an interest and I

00:10:03,370 --> 00:10:08,199
want you create an example by means of

00:10:05,170 --> 00:10:12,160
make unique I want to pass an int + int

00:10:08,199 --> 00:10:14,230
ref I cannot because I have already

00:10:12,160 --> 00:10:16,930
added the Const in the function and a

00:10:14,230 --> 00:10:19,389
chemical cannot get rid of it anymore so

00:10:16,930 --> 00:10:21,459
also this would not compile meaning

00:10:19,389 --> 00:10:23,680
there was no perfect solution

00:10:21,459 --> 00:10:25,660
no general solution all the options I

00:10:23,680 --> 00:10:28,240
have have some limitation we were

00:10:25,660 --> 00:10:31,660
basically bound to have special-purpose

00:10:28,240 --> 00:10:33,279
solutions this is exactly what

00:10:31,660 --> 00:10:35,170
forwarding references supposed to solve

00:10:33,279 --> 00:10:39,189
and this is exactly where they get their

00:10:35,170 --> 00:10:44,079
name from this allows you to pass

00:10:39,189 --> 00:10:46,899
anything this X this except L values is

00:10:44,079 --> 00:10:48,459
ax accepts our values cons values none

00:10:46,899 --> 00:10:50,670
can spell is volatile non-volatile

00:10:48,459 --> 00:10:53,589
anything that you could possibly have

00:10:50,670 --> 00:10:55,600
perfect this is the right kind of

00:10:53,589 --> 00:10:58,120
reference this is by the way why Scott

00:10:55,600 --> 00:11:00,790
Myers initially call these universal

00:10:58,120 --> 00:11:04,310
reference it is kind of universal it

00:11:00,790 --> 00:11:07,069
accepts anything and it can be anything

00:11:04,310 --> 00:11:08,810
now it's just a small additional problem

00:11:07,069 --> 00:11:12,379
that you now have and this is what

00:11:08,810 --> 00:11:14,720
you've seen before this may be in our

00:11:12,379 --> 00:11:16,850
value okay I can pass null value to this

00:11:14,720 --> 00:11:20,749
function but just because in this

00:11:16,850 --> 00:11:24,589
function it has a name it becomes an L

00:11:20,749 --> 00:11:27,139
value again and now as an elderly if it

00:11:24,589 --> 00:11:29,990
forwarded in this form I basically

00:11:27,139 --> 00:11:34,610
remove the opportunity to move this into

00:11:29,990 --> 00:11:38,420
T so it's again not perfect this is a

00:11:34,610 --> 00:11:40,550
limitation using move at this point of

00:11:38,420 --> 00:11:43,059
course again would be big mistake

00:11:40,550 --> 00:11:45,379
if I pass an L value I would

00:11:43,059 --> 00:11:47,059
unconditionally move and this would of

00:11:45,379 --> 00:11:49,939
course destroy me l valid it might still

00:11:47,059 --> 00:11:51,999
be used in the calling scope that so I

00:11:49,939 --> 00:11:54,740
need something different instead of an

00:11:51,999 --> 00:11:57,680
unconditional move I need a conditional

00:11:54,740 --> 00:12:00,499
move a move that only moves if it is

00:11:57,680 --> 00:12:02,990
indeed an R value and this is what was

00:12:00,499 --> 00:12:04,999
introduced okay the animation litoris

00:12:02,990 --> 00:12:07,399
was in what was introduced by means of

00:12:04,999 --> 00:12:10,850
standard forward let's say little

00:12:07,399 --> 00:12:13,040
brother of standard move standard

00:12:10,850 --> 00:12:16,449
forward is a conditional move for the

00:12:13,040 --> 00:12:20,300
reason it looks similar yet different to

00:12:16,449 --> 00:12:23,120
just an ad move it doesn't that static

00:12:20,300 --> 00:12:25,399
cast also but directly cast 2d ref ref

00:12:23,120 --> 00:12:29,540
there's no remove reference whatever it

00:12:25,399 --> 00:12:30,170
looks a little simpler I will a little

00:12:29,540 --> 00:12:32,240
later

00:12:30,170 --> 00:12:35,360
tell you about the the implementation

00:12:32,240 --> 00:12:37,600
details of forward how it works etc for

00:12:35,360 --> 00:12:40,189
now let's just say we use this forward

00:12:37,600 --> 00:12:45,079
we use it a little different though than

00:12:40,189 --> 00:12:47,809
move we additionally passed the type the

00:12:45,079 --> 00:12:51,139
value arc does not help me it's always

00:12:47,809 --> 00:12:53,420
an L value but the type gives it away if

00:12:51,139 --> 00:12:55,370
the type shows me this is nel value I

00:12:53,420 --> 00:12:57,589
basically cast to an L value reference

00:12:55,370 --> 00:12:57,949
again if the type shows me this is an R

00:12:57,589 --> 00:13:01,459
value

00:12:57,949 --> 00:13:03,019
I cast to an R value reference so stood

00:13:01,459 --> 00:13:04,730
forward is the conditionally moved and

00:13:03,019 --> 00:13:07,579
ended here and now it's certainly

00:13:04,730 --> 00:13:09,829
perfect whatever you pass to this

00:13:07,579 --> 00:13:11,839
function it will perfectly with exactly

00:13:09,829 --> 00:13:14,720
this right type with exactly the same

00:13:11,839 --> 00:13:16,569
properties forwarded to the function so

00:13:14,720 --> 00:13:18,149
in this case the constructor of T

00:13:16,569 --> 00:13:19,889
perfect

00:13:18,149 --> 00:13:23,910
now make unique is of course not quite

00:13:19,889 --> 00:13:25,859
complete in in real life it has uses

00:13:23,910 --> 00:13:28,290
forwarding references so now I can pass

00:13:25,859 --> 00:13:29,970
an arbitrary number of elements and all

00:13:28,290 --> 00:13:33,089
of them are forwarding references of

00:13:29,970 --> 00:13:35,220
course this is the final make unique but

00:13:33,089 --> 00:13:36,929
it works exactly as before I forward

00:13:35,220 --> 00:13:37,850
every single argument in exactly the

00:13:36,929 --> 00:13:43,439
same way

00:13:37,850 --> 00:13:46,279
perfect now let's take it should look at

00:13:43,439 --> 00:13:49,109
how center-forward works it is not

00:13:46,279 --> 00:13:50,759
something particularly difficult but

00:13:49,109 --> 00:13:54,029
again it is relying on reference

00:13:50,759 --> 00:13:58,739
collapsing so this is how we used it we

00:13:54,029 --> 00:14:01,709
passed the type arcs so this is the

00:13:58,739 --> 00:14:03,980
forward function again let's first of

00:14:01,709 --> 00:14:07,079
all assume that I pass an l-value

00:14:03,980 --> 00:14:11,639
if a pass and which it again my toy

00:14:07,079 --> 00:14:15,019
example and it an l-value widget then T

00:14:11,639 --> 00:14:17,189
would as before become a widget ref

00:14:15,019 --> 00:14:19,049
exactly the same thing as before in all

00:14:17,189 --> 00:14:21,629
the places where had T suddenly have a

00:14:19,049 --> 00:14:26,069
widget ref and now the same rules as

00:14:21,629 --> 00:14:31,879
before apply widget ref ref ref becomes

00:14:26,069 --> 00:14:34,799
in these two ka places a widget ref and

00:14:31,879 --> 00:14:38,789
it's remove reference T of widget ref

00:14:34,799 --> 00:14:40,470
will simply be resolved to widget and so

00:14:38,789 --> 00:14:43,139
ultimately this is the forward function

00:14:40,470 --> 00:14:46,559
that would be instantiated okay I take a

00:14:43,139 --> 00:14:48,809
widget an l-value and I've cast to an

00:14:46,559 --> 00:14:53,329
l-value reference so if you pass in an L

00:14:48,809 --> 00:14:56,669
value you get back in L value reference

00:14:53,329 --> 00:15:00,439
however if I pass it in our value then

00:14:56,669 --> 00:15:05,669
just as before we would deduce widget

00:15:00,439 --> 00:15:07,319
just widget so widget ref ref perfect I

00:15:05,669 --> 00:15:09,749
do not have to do reference collapsing

00:15:07,319 --> 00:15:13,350
here and remove reference T would

00:15:09,749 --> 00:15:16,649
resolve to widget so again I get in a

00:15:13,350 --> 00:15:19,829
valley widget but every turn in this

00:15:16,649 --> 00:15:22,799
case widget ref ref I statically cast to

00:15:19,829 --> 00:15:24,839
widget refresh and so if you pass an R

00:15:22,799 --> 00:15:27,149
value you will get back in our Val

00:15:24,839 --> 00:15:30,270
reference you cast to the right type

00:15:27,149 --> 00:15:32,100
again so it's not a big

00:15:30,270 --> 00:15:34,290
mr. e it's not a lot of magic it just

00:15:32,100 --> 00:15:37,410
uses the rules that we've seen before in

00:15:34,290 --> 00:15:41,880
a very nice way and so the mechanics off

00:15:37,410 --> 00:15:45,690
stood forward by the way going back to

00:15:41,880 --> 00:15:48,779
do the initial signature this is how it

00:15:45,690 --> 00:15:51,060
looks like and yes it is different to

00:15:48,779 --> 00:15:53,640
what move looks like so I showed you

00:15:51,060 --> 00:15:56,160
move before and now for the first time

00:15:53,640 --> 00:15:59,040
we can perfectly analyze move move

00:15:56,160 --> 00:16:01,260
indeed takes a forwarding reference I

00:15:59,040 --> 00:16:03,690
didn't mention this before part of the

00:16:01,260 --> 00:16:07,110
second part but yes this T ref ref here

00:16:03,690 --> 00:16:09,270
is in fact a falling reference this is

00:16:07,110 --> 00:16:11,399
why move just takes anything just give

00:16:09,270 --> 00:16:13,830
me an L value or an R value constant on

00:16:11,399 --> 00:16:24,450
console I don't care I will cast it into

00:16:13,830 --> 00:16:26,820
a are value reference all right this

00:16:24,450 --> 00:16:29,130
sounds like a pretty good idea so far Oh

00:16:26,820 --> 00:16:32,100
foreign references but take anything oh

00:16:29,130 --> 00:16:34,470
cool absolutely nice this is exactly

00:16:32,100 --> 00:16:36,180
what it's looking for unfortunately

00:16:34,470 --> 00:16:40,260
there is indeed a couple of perils that

00:16:36,180 --> 00:16:43,649
you should be at least aware of and as

00:16:40,260 --> 00:16:46,740
an example I now introduce a construct

00:16:43,649 --> 00:16:50,100
here to simplify things person a person

00:16:46,740 --> 00:16:51,899
has a constructor that takes a name by

00:16:50,100 --> 00:16:54,270
string this is a reasonable choice

00:16:51,899 --> 00:16:57,540
probably so I can name a person by

00:16:54,270 --> 00:17:00,240
string but there's so many more kinds of

00:16:57,540 --> 00:17:01,770
strings so we might consider string view

00:17:00,240 --> 00:17:03,779
and of course he said string literals

00:17:01,770 --> 00:17:06,480
cue string and okay so there's many

00:17:03,779 --> 00:17:09,209
kinds of strings you might have the idea

00:17:06,480 --> 00:17:10,679
that disable at work you introduce

00:17:09,209 --> 00:17:13,490
another constructor that takes a

00:17:10,679 --> 00:17:17,550
forwarding reference any kind of string

00:17:13,490 --> 00:17:20,339
this sounds pretty nice all right let's

00:17:17,550 --> 00:17:22,220
use this let's create a person and

00:17:20,339 --> 00:17:24,929
decided to create a piano on my own

00:17:22,220 --> 00:17:30,350
everybody needs a piano which

00:17:24,929 --> 00:17:30,350
constructor is used to create my piano

00:17:34,980 --> 00:17:40,900
correct the second one you might think

00:17:39,070 --> 00:17:44,650
but this is a string no it's not a

00:17:40,900 --> 00:17:47,410
string this is AC string riddle of type

00:17:44,650 --> 00:17:48,880
char seven yeah I can count it six

00:17:47,410 --> 00:17:52,750
characters but there's also the null

00:17:48,880 --> 00:17:56,050
terminating character and this fits best

00:17:52,750 --> 00:17:56,860
to the reference the T reference well it

00:17:56,050 --> 00:17:59,410
could be anything

00:17:56,860 --> 00:18:01,810
so it takes reference to HR seven and

00:17:59,410 --> 00:18:04,870
we're done we do not have at this point

00:18:01,810 --> 00:18:06,070
to create a string first but this is

00:18:04,870 --> 00:18:10,890
exactly what we wanted

00:18:06,070 --> 00:18:14,110
cool not bad okay I want a second person

00:18:10,890 --> 00:18:15,430
what person do I create I think you only

00:18:14,110 --> 00:18:19,090
needs herb

00:18:15,430 --> 00:18:21,640
yes everybody needs a herb too so I

00:18:19,090 --> 00:18:24,340
create a herb and I create a string

00:18:21,640 --> 00:18:27,730
first so string named herb and I pass

00:18:24,340 --> 00:18:33,520
the string now which constructors used

00:18:27,730 --> 00:18:36,430
to create herb okay I hear a couple of

00:18:33,520 --> 00:18:38,200
one this is exactly what we expect this

00:18:36,430 --> 00:18:41,020
is very natural I have a string it's of

00:18:38,200 --> 00:18:43,750
course how why should it be different of

00:18:41,020 --> 00:18:44,620
course it goes to the first function but

00:18:43,750 --> 00:18:48,520
no it does not

00:18:44,620 --> 00:18:53,110
it's cause the second function and

00:18:48,520 --> 00:18:54,100
slowly but steadily feel oh this is

00:18:53,110 --> 00:18:55,390
unexpected

00:18:54,100 --> 00:18:58,720
this is probably something that you

00:18:55,390 --> 00:19:01,060
later have to think through again so why

00:18:58,720 --> 00:19:02,950
does it call the second function well it

00:19:01,060 --> 00:19:06,070
calls the second function just because

00:19:02,950 --> 00:19:09,540
the argument the name is not constant

00:19:06,070 --> 00:19:11,770
this is the only difference yet the only

00:19:09,540 --> 00:19:14,560
detail that makes it call the second

00:19:11,770 --> 00:19:18,190
function the second function is

00:19:14,560 --> 00:19:21,460
instantiated in exactly the same form I

00:19:18,190 --> 00:19:24,340
explained before is to take a string ref

00:19:21,460 --> 00:19:28,300
it's an l-value string reference

00:19:24,340 --> 00:19:30,070
collapsing etc string ref now I have two

00:19:28,300 --> 00:19:32,080
functions after this template in

00:19:30,070 --> 00:19:34,480
sensation they can choose construct the

00:19:32,080 --> 00:19:36,160
one it takes a con string and this newly

00:19:34,480 --> 00:19:38,500
accentuated second function taking

00:19:36,160 --> 00:19:42,490
string ref none Const

00:19:38,500 --> 00:19:44,770
which one is better oh yeah the second

00:19:42,490 --> 00:19:46,360
one just because it's not constants you

00:19:44,770 --> 00:19:48,349
can easily prove this at accounts to the

00:19:46,360 --> 00:19:51,269
name it will call the first firm

00:19:48,349 --> 00:19:53,989
that was unexpected pretty unexpected

00:19:51,269 --> 00:19:57,479
but this is not even the worst thing

00:19:53,989 --> 00:19:59,820
okay we now do something that we

00:19:57,479 --> 00:20:03,269
probably shouldn't do but we do another

00:19:59,820 --> 00:20:03,869
less if if you don't tell I perfectly

00:20:03,269 --> 00:20:05,309
fine with it

00:20:03,869 --> 00:20:09,479
we are not cloning one of these two guys

00:20:05,309 --> 00:20:11,519
and I decided to clone a PNM everybody

00:20:09,479 --> 00:20:17,340
needs to be on a'right so I'm now

00:20:11,519 --> 00:20:18,989
creating yharnam again as a copy I pass

00:20:17,340 --> 00:20:21,839
p1 s the argument

00:20:18,989 --> 00:20:30,749
now watch happens what do you think what

00:20:21,839 --> 00:20:32,989
do we expect I actually hope that you're

00:20:30,749 --> 00:20:35,700
thinking of course we do a copy

00:20:32,989 --> 00:20:37,529
everybody copies superior and for that

00:20:35,700 --> 00:20:41,700
purpose of course we have a copy

00:20:37,529 --> 00:20:44,239
constructor no it does not call the copy

00:20:41,700 --> 00:20:48,539
constructor unfortunately it calls

00:20:44,239 --> 00:20:52,229
constructor two again why well same

00:20:48,539 --> 00:20:55,679
argument bernie is not Const Bjorn is a

00:20:52,229 --> 00:20:57,629
free man and for that reason again the

00:20:55,679 --> 00:20:59,789
second function is just a tiny bit

00:20:57,629 --> 00:21:02,789
better the second constructor would take

00:20:59,789 --> 00:21:07,379
a person ref the copy constructor on the

00:21:02,789 --> 00:21:10,830
other hand takes a Const person ref okay

00:21:07,379 --> 00:21:11,759
I cannot exactly I can imagine what

00:21:10,830 --> 00:21:15,659
you're thinking right now

00:21:11,759 --> 00:21:20,549
Oh what okay again Keep Calm this is

00:21:15,659 --> 00:21:22,109
perhaps this helps yeah so the problem

00:21:20,549 --> 00:21:24,899
is of course that we have to remember

00:21:22,109 --> 00:21:28,580
that this is indeed special and the

00:21:24,899 --> 00:21:32,940
problem is primarily overloading on

00:21:28,580 --> 00:21:35,399
forwarding references in order to give

00:21:32,940 --> 00:21:37,109
you an idea now let's practice this a

00:21:35,399 --> 00:21:40,109
little bit so now it becomes a limo and

00:21:37,109 --> 00:21:43,919
either interactive on the right I have a

00:21:40,109 --> 00:21:45,989
function G that does a couple of things

00:21:43,919 --> 00:21:51,419
now in this example it creates a widget

00:21:45,989 --> 00:21:54,570
W and passes this w to F and believe it

00:21:51,419 --> 00:21:55,979
or not I have six F functions one two

00:21:54,570 --> 00:21:58,200
three four five six

00:21:55,979 --> 00:21:59,879
all of them can perfectly live in

00:21:58,200 --> 00:22:01,020
harmony because all of them just take

00:21:59,879 --> 00:22:02,910
references but

00:22:01,020 --> 00:22:07,830
all possible kinds of references

00:22:02,910 --> 00:22:09,570
function one takes a nun constants so

00:22:07,830 --> 00:22:11,520
reference L Valley reference to nun

00:22:09,570 --> 00:22:14,490
Const function two takes an l-value

00:22:11,520 --> 00:22:17,280
reference to Const function three takes

00:22:14,490 --> 00:22:19,440
an R value reference function for it

00:22:17,280 --> 00:22:20,850
takes although this is probably not

00:22:19,440 --> 00:22:24,180
something that you've seen a wild and

00:22:20,850 --> 00:22:27,420
arveleï reference to Const function five

00:22:24,180 --> 00:22:30,180
takes a falling reference hopefully you

00:22:27,420 --> 00:22:32,910
see this by now and function six takes a

00:22:30,180 --> 00:22:35,160
constant here F ref which makes it a an

00:22:32,910 --> 00:22:38,490
R value reference again so this is not a

00:22:35,160 --> 00:22:42,330
forwarding reference this is just a yeah

00:22:38,490 --> 00:22:45,570
an R value reference to constic in so

00:22:42,330 --> 00:22:48,740
given the code on the right I have an L

00:22:45,570 --> 00:22:52,710
value it has a name and I pass it to F

00:22:48,740 --> 00:22:55,350
which of these six functions is chosen

00:22:52,710 --> 00:23:03,450
as the primary choice in other words

00:22:55,350 --> 00:23:05,010
what is the best match okay I hear a

00:23:03,450 --> 00:23:06,530
couple of answers and see a couple of

00:23:05,010 --> 00:23:12,650
answers

00:23:06,530 --> 00:23:16,110
this calls function 1 some people

00:23:12,650 --> 00:23:18,540
expected function 5 well actually this

00:23:16,110 --> 00:23:20,400
is really really close function 5 is

00:23:18,540 --> 00:23:22,860
considered of course as well it is

00:23:20,400 --> 00:23:26,160
instantiated and the compiler comes up

00:23:22,860 --> 00:23:29,160
with a signature so function 5 becomes F

00:23:26,160 --> 00:23:31,440
of widget ref exactly the same

00:23:29,160 --> 00:23:33,450
signatures function 1 can also happen

00:23:31,440 --> 00:23:35,010
during template instantiation now we

00:23:33,450 --> 00:23:37,830
have two functions they take a widget

00:23:35,010 --> 00:23:40,920
ref luckily there's a rule in C++ that

00:23:37,830 --> 00:23:43,080
says if a template is instantiated it

00:23:40,920 --> 00:23:45,450
becomes exactly the same signature is a

00:23:43,080 --> 00:23:47,280
non template function the non template

00:23:45,450 --> 00:23:49,500
is preferred and for that reason

00:23:47,280 --> 00:23:51,060
function one is the better match

00:23:49,500 --> 00:23:54,420
although strictly speaking both are

00:23:51,060 --> 00:23:56,820
equally we'll managed now let's assume

00:23:54,420 --> 00:23:59,670
that function 1 does not exist what

00:23:56,820 --> 00:24:01,740
would be the second choice this so

00:23:59,670 --> 00:24:02,910
ignore function 1 would be that what

00:24:01,740 --> 00:24:09,240
would be the best choice of the

00:24:02,910 --> 00:24:11,220
remaining 5 correct function 5 because

00:24:09,240 --> 00:24:12,630
it is the same signature and now that

00:24:11,220 --> 00:24:15,049
the function 1 doesn't exist anymore

00:24:12,630 --> 00:24:18,390
this is the best match

00:24:15,049 --> 00:24:21,900
there's a third possibility the third

00:24:18,390 --> 00:24:24,570
best choice which of these functions is

00:24:21,900 --> 00:24:30,750
also an option but was not chosen yet

00:24:24,570 --> 00:24:37,470
because of the other two correct

00:24:30,750 --> 00:24:39,720
function to a Narvel is a an l-value can

00:24:37,470 --> 00:24:41,659
of course be passed to and will

00:24:39,720 --> 00:24:43,830
reference to Const this works

00:24:41,659 --> 00:24:46,020
the other three functions are not an

00:24:43,830 --> 00:24:47,909
optional and have an L value does not

00:24:46,020 --> 00:24:50,460
bind to normally reference this would be

00:24:47,909 --> 00:24:52,669
bad then something would be moved and

00:24:50,460 --> 00:24:56,340
again I would have a pretty big problem

00:24:52,669 --> 00:24:58,200
this is the only choices all right let's

00:24:56,340 --> 00:25:02,010
make the code on the right hand side

00:24:58,200 --> 00:25:04,620
create and cons widget a console really

00:25:02,010 --> 00:25:06,809
and let's again think which function is

00:25:04,620 --> 00:25:08,990
caught so it's the same functions on the

00:25:06,809 --> 00:25:08,990
left

00:25:16,210 --> 00:25:21,879
all right I see a couple of two and

00:25:18,879 --> 00:25:25,419
you're correct function two is now again

00:25:21,879 --> 00:25:26,950
the best match but again there is one

00:25:25,419 --> 00:25:28,960
function it is a very very tough

00:25:26,950 --> 00:25:31,119
competitor and it only loses Bigfoot

00:25:28,960 --> 00:25:33,970
because its template that is function v

00:25:31,119 --> 00:25:41,740
function v is again the second best

00:25:33,970 --> 00:25:45,070
match so try it

00:25:41,740 --> 00:25:48,249
it is indeed function v why not six so

00:25:45,070 --> 00:25:50,860
function six is not an option because it

00:25:48,249 --> 00:25:53,139
takes in our value reference it is an

00:25:50,860 --> 00:25:54,850
r-value reference I can pass in cons

00:25:53,139 --> 00:25:57,159
elavil to forwarding reference but I

00:25:54,850 --> 00:25:59,350
cannot pass an elderly in any state

00:25:57,159 --> 00:26:01,570
consonant cons to an r-value reference

00:25:59,350 --> 00:26:04,419
never works this is why function six is

00:26:01,570 --> 00:26:05,619
indeed not an option perhaps to some

00:26:04,419 --> 00:26:08,139
extent this proofs is an r-value

00:26:05,619 --> 00:26:09,610
reference this is the only choices are

00:26:08,139 --> 00:26:11,590
half in this case function one is not an

00:26:09,610 --> 00:26:13,179
option because of the constant I can

00:26:11,590 --> 00:26:17,830
remove constantly others are again

00:26:13,179 --> 00:26:20,169
r-value references the fun continues now

00:26:17,830 --> 00:26:22,769
I have our values on the right hand side

00:26:20,169 --> 00:26:25,029
so the function that creates our values

00:26:22,769 --> 00:26:28,149
assuming that I call F with an R value

00:26:25,029 --> 00:26:31,149
which function would be the best match

00:26:28,149 --> 00:26:35,799
okay I should be specific and none can

00:26:31,149 --> 00:26:38,139
starve le of course okay

00:26:35,799 --> 00:26:39,009
if starting to pick up a pattern here

00:26:38,139 --> 00:26:42,279
this is not bad

00:26:39,009 --> 00:26:44,259
function three function three is the

00:26:42,279 --> 00:26:48,429
best choice because it's again a perfect

00:26:44,259 --> 00:26:51,220
match however yet again function five is

00:26:48,429 --> 00:26:53,200
a very tough competitor the compiler

00:26:51,220 --> 00:26:55,720
will come up with a signature widget ref

00:26:53,200 --> 00:26:57,429
ref it is only loosing again because

00:26:55,720 --> 00:26:59,440
it's a template if function three does

00:26:57,429 --> 00:27:01,929
not exist this function would be called

00:26:59,440 --> 00:27:05,740
yet again and you start to get the

00:27:01,929 --> 00:27:08,440
feeling if there is if there's no other

00:27:05,740 --> 00:27:11,350
function it it's a perfect match I so

00:27:08,440 --> 00:27:12,940
called identity match then this tiny

00:27:11,350 --> 00:27:17,769
little black hole called forwarding

00:27:12,940 --> 00:27:20,470
reference takes it all not in this case

00:27:17,769 --> 00:27:22,389
I have a third choice what would be

00:27:20,470 --> 00:27:26,070
assuming that these two do not exist

00:27:22,389 --> 00:27:26,070
what would be the third choice

00:27:31,310 --> 00:27:38,550
function for is correct I have an

00:27:35,640 --> 00:27:41,460
r-value an RV le wants to bind to novel

00:27:38,550 --> 00:27:44,730
reference and so this function is a

00:27:41,460 --> 00:27:47,340
little better function six is a template

00:27:44,730 --> 00:27:48,750
and so again function for is preferred

00:27:47,340 --> 00:27:52,500
and function six would in this situation

00:27:48,750 --> 00:27:55,770
be the second choice but if you thought

00:27:52,500 --> 00:27:58,650
to correct it is a choice but however

00:27:55,770 --> 00:28:01,680
this is the fallback this is the

00:27:58,650 --> 00:28:04,080
fallback that has ever has always

00:28:01,680 --> 00:28:06,840
existed since the very beginning our

00:28:04,080 --> 00:28:09,000
values bind to El Valle reference to

00:28:06,840 --> 00:28:11,070
Const so if you do not use our value

00:28:09,000 --> 00:28:14,270
references at all so if function three

00:28:11,070 --> 00:28:17,370
to six do not exist then function two is

00:28:14,270 --> 00:28:20,070
the common fallback this by the way it's

00:28:17,370 --> 00:28:24,270
also the reason why if you don't use

00:28:20,070 --> 00:28:25,770
move it still works if you can r-value

00:28:24,270 --> 00:28:28,350
it would simply call the copy

00:28:25,770 --> 00:28:29,940
constructor of something it will create

00:28:28,350 --> 00:28:33,270
a copy okay

00:28:29,940 --> 00:28:35,670
there's of course one one possibility

00:28:33,270 --> 00:28:39,300
left I do not think that you see this a

00:28:35,670 --> 00:28:41,910
lot in in in wild I now create a Const R

00:28:39,300 --> 00:28:44,730
value which function is now the best

00:28:41,910 --> 00:28:48,530
match you know what do you think but I

00:28:44,730 --> 00:28:48,530
like to play it till the end okay

00:28:49,490 --> 00:28:56,040
function for perfect so if you thought

00:28:53,760 --> 00:29:04,860
about this right away I think you got it

00:28:56,040 --> 00:29:07,380
what would be the second choice okay

00:29:04,860 --> 00:29:09,660
actually are correct it's six okay you

00:29:07,380 --> 00:29:11,730
avoided my trap this is the first case

00:29:09,660 --> 00:29:15,150
in the only case where it does not call

00:29:11,730 --> 00:29:17,130
five this time function six is a little

00:29:15,150 --> 00:29:19,500
bit better because of the counts this

00:29:17,130 --> 00:29:22,260
takes cars are really references the

00:29:19,500 --> 00:29:24,450
function five however would indeed match

00:29:22,260 --> 00:29:26,190
exactly the signature function six but

00:29:24,450 --> 00:29:27,840
because the other one is Const meaning a

00:29:26,190 --> 00:29:29,460
little more special function six is

00:29:27,840 --> 00:29:32,460
called in function five is only the

00:29:29,460 --> 00:29:34,640
third choice and also here I can choose

00:29:32,460 --> 00:29:37,260
function two as the final fourth choice

00:29:34,640 --> 00:29:40,530
function one and function function one

00:29:37,260 --> 00:29:42,330
is not an option because it's an L

00:29:40,530 --> 00:29:45,180
you reference and functions three is

00:29:42,330 --> 00:29:48,240
normal reference of course but it hasn't

00:29:45,180 --> 00:29:52,110
any Const all right now I think you got

00:29:48,240 --> 00:29:53,910
it still it is a pretty complicated so

00:29:52,110 --> 00:29:55,770
overloading with forwarding references

00:29:53,910 --> 00:29:58,980
is something that is probably best

00:29:55,770 --> 00:30:01,080
avoided make unique a single function it

00:29:58,980 --> 00:30:04,710
is somewhere this is where it is working

00:30:01,080 --> 00:30:06,900
best so personal refer my personal

00:30:04,710 --> 00:30:08,550
advice if you indeed what to solve this

00:30:06,900 --> 00:30:10,290
forwarding this perfect folding problem

00:30:08,550 --> 00:30:12,090
useful reading references because

00:30:10,290 --> 00:30:14,310
there's nothing better this is exactly

00:30:12,090 --> 00:30:16,710
what it does well do not just use it

00:30:14,310 --> 00:30:18,840
randomly so if you use a forwarding

00:30:16,710 --> 00:30:19,680
reference then use it for a specific

00:30:18,840 --> 00:30:23,130
reason

00:30:19,680 --> 00:30:24,570
ya know what you're doing and I

00:30:23,130 --> 00:30:26,280
basically just give you the advice it's

00:30:24,570 --> 00:30:29,400
got my escape in a some effective modern

00:30:26,280 --> 00:30:31,170
C++ book item 26 avoid overloading on

00:30:29,400 --> 00:30:33,900
numerous references so as I said before

00:30:31,170 --> 00:30:36,900
Scott called him universe reference many

00:30:33,900 --> 00:30:38,850
forwarding reference of course if you

00:30:36,900 --> 00:30:40,620
know what you're doing you're fine for

00:30:38,850 --> 00:30:44,790
the back-to-basics track this is the

00:30:40,620 --> 00:30:47,780
general advice that I would give you now

00:30:44,790 --> 00:30:50,010
there is indeed a couple of pitfalls

00:30:47,780 --> 00:30:53,010
basically if not covered the technical

00:30:50,010 --> 00:30:54,720
parts but still although we now know

00:30:53,010 --> 00:30:57,810
about the technical details we might

00:30:54,720 --> 00:30:59,820
stumble across a couple of yeah pitfalls

00:30:57,810 --> 00:31:01,680
things that go wrong because we do not

00:30:59,820 --> 00:31:04,290
pay attention things that go wrong

00:31:01,680 --> 00:31:08,160
perhaps because people do not completely

00:31:04,290 --> 00:31:11,580
understand the details and well I now

00:31:08,160 --> 00:31:13,770
designed this in a special way and so

00:31:11,580 --> 00:31:16,380
you now invited to participate in a new

00:31:13,770 --> 00:31:19,980
episode of who wants to become an R

00:31:16,380 --> 00:31:21,810
value reference expert and involuntarily

00:31:19,980 --> 00:31:24,330
you are the participants of this game

00:31:21,810 --> 00:31:26,930
show you now have to participate by

00:31:24,330 --> 00:31:32,310
thinking about the following problems

00:31:26,930 --> 00:31:36,090
problem number one I know half a okay

00:31:32,310 --> 00:31:39,750
simplified class a class a takes eighty

00:31:36,090 --> 00:31:44,100
ref ref and you see it is a templated

00:31:39,750 --> 00:31:47,310
constructor and I move my argument

00:31:44,100 --> 00:31:49,890
little T into my data member B now the

00:31:47,310 --> 00:31:52,110
question is of course not does B wants

00:31:49,890 --> 00:31:53,960
to have the T now the question that I

00:31:52,110 --> 00:31:56,029
basically have is is this

00:31:53,960 --> 00:31:57,770
semantically correct do I use the

00:31:56,029 --> 00:31:59,029
features that are just described in a

00:31:57,770 --> 00:32:02,149
correct way or not

00:31:59,029 --> 00:32:19,940
so entry question you have 15 seconds to

00:32:02,149 --> 00:32:22,250
think about it alright hopefully you all

00:32:19,940 --> 00:32:24,620
saw this this was kind of the entry

00:32:22,250 --> 00:32:26,600
level question and I heard the answer

00:32:24,620 --> 00:32:29,840
already I said three seconds yeah not

00:32:26,600 --> 00:32:33,380
one or two so it doesn't matter you

00:32:29,840 --> 00:32:36,559
should use not move this is basically

00:32:33,380 --> 00:32:40,419
basically a big big error this is what

00:32:36,559 --> 00:32:42,860
kind of reference this tariff ref a

00:32:40,419 --> 00:32:46,100
forwarding or universe reference I

00:32:42,860 --> 00:32:48,559
should not move unconditionally it could

00:32:46,100 --> 00:32:51,260
be an l-value and this is causing

00:32:48,559 --> 00:32:53,899
trouble at the call site I should need

00:32:51,260 --> 00:32:55,179
use a forward and exactly this form now

00:32:53,899 --> 00:32:57,470
it's perfect

00:32:55,179 --> 00:32:59,240
okay hopefully is something that never

00:32:57,470 --> 00:33:02,570
happens to you but this would indeed be

00:32:59,240 --> 00:33:06,559
a serious bug okay precious was too

00:33:02,570 --> 00:33:09,260
simple let's use this word let's take a

00:33:06,559 --> 00:33:12,919
look at this one example two now I have

00:33:09,260 --> 00:33:14,090
a class template and it takes its I it

00:33:12,919 --> 00:33:15,980
has a constructor that takes its

00:33:14,090 --> 00:33:19,730
argument as a t ref ref again

00:33:15,980 --> 00:33:25,450
I now forward my little T into my data

00:33:19,730 --> 00:33:25,450
member B again you're 15 seconds

00:33:39,220 --> 00:33:45,919
all right what is going wrong here and

00:33:43,389 --> 00:33:47,929
I've to admit this is indeed something

00:33:45,919 --> 00:33:55,690
I've seen a couple of times okay it's a

00:33:47,929 --> 00:33:55,690
lot of times a small number of times yes

00:33:58,210 --> 00:34:05,620
okay so you're correct I have

00:34:05,860 --> 00:34:10,940
unfortunately anticipated that I'm using

00:34:08,480 --> 00:34:15,770
a forwarding reference here T ref ref

00:34:10,940 --> 00:34:18,619
what kind of reference is T ref ref it

00:34:15,770 --> 00:34:24,560
is an r-value reference indeed this here

00:34:18,619 --> 00:34:26,270
is a class template parameter okay let's

00:34:24,560 --> 00:34:29,869
ignore this so the comment was to

00:34:26,270 --> 00:34:33,169
deduction rules okay T ref ref is in our

00:34:29,869 --> 00:34:35,089
value reference only in order to make

00:34:33,169 --> 00:34:37,940
this a photograph ins I need to type

00:34:35,089 --> 00:34:42,980
deduction in the function of course it

00:34:37,940 --> 00:34:46,790
needs to be a func template function

00:34:42,980 --> 00:34:48,980
templated constructor if it's only in

00:34:46,790 --> 00:34:51,230
arvalera fence and a for which it's not

00:34:48,980 --> 00:34:53,480
perfect this is sound not something that

00:34:51,230 --> 00:34:55,490
breaks things this is kind of harmless

00:34:53,480 --> 00:34:56,750
you will notice that this is not a

00:34:55,490 --> 00:34:58,609
forwarding reference because you will

00:34:56,750 --> 00:35:02,359
not be able to pass any kind of L value

00:34:58,609 --> 00:35:03,920
and since you only passed can pass our

00:35:02,359 --> 00:35:05,960
values then the forward would still do

00:35:03,920 --> 00:35:07,460
the right thing it still it's not really

00:35:05,960 --> 00:35:10,700
correct this is probably not what you

00:35:07,460 --> 00:35:12,770
intended the fix so this is an r-value

00:35:10,700 --> 00:35:15,740
references I said the fix would

00:35:12,770 --> 00:35:18,280
basically be to say let's move it's an

00:35:15,740 --> 00:35:20,540
arveleï reference let's should be moved

00:35:18,280 --> 00:35:22,550
but I doubt that this was the intention

00:35:20,540 --> 00:35:23,780
probably has to be redesigned probably

00:35:22,550 --> 00:35:26,900
want to make this a templated

00:35:23,780 --> 00:35:29,200
constructor I don't know okay please

00:35:26,900 --> 00:35:32,480
don't repeat this please take care that

00:35:29,200 --> 00:35:36,800
it's only a folding reference if it is

00:35:32,480 --> 00:35:41,150
using type deduction all right example

00:35:36,800 --> 00:35:44,810
three now I have two data members column

00:35:41,150 --> 00:35:47,030
B and C I have one argument again and

00:35:44,810 --> 00:35:49,880
now again half a templated constructor

00:35:47,030 --> 00:35:50,900
my argument my little T is forwarded

00:35:49,880 --> 00:35:54,279
into being

00:35:50,900 --> 00:36:11,930
and my little tea is forwarded into see

00:35:54,279 --> 00:36:19,190
again 15 seconds at least three all

00:36:11,930 --> 00:36:24,200
right a little oh sorry okay the second

00:36:19,190 --> 00:36:27,559
one can't fail you say I know what you

00:36:24,200 --> 00:36:29,809
mean so I would just want you a little

00:36:27,559 --> 00:36:35,569
more precise what should I not do what

00:36:29,809 --> 00:36:41,299
is the real mistake okay double move

00:36:35,569 --> 00:36:45,020
correct I am using forward twice forward

00:36:41,299 --> 00:36:46,940
is basically some kind of move it's

00:36:45,020 --> 00:36:49,220
obvious that I should not move something

00:36:46,940 --> 00:36:51,859
twice once it's moved from I cannot

00:36:49,220 --> 00:36:53,690
really move again it apparently is not

00:36:51,859 --> 00:36:56,089
so obvious that I also should not use

00:36:53,690 --> 00:36:59,390
forward twice because it's well the same

00:36:56,089 --> 00:37:01,819
thing if a person our value and if B

00:36:59,390 --> 00:37:04,339
happens to indeed move from this team

00:37:01,819 --> 00:37:06,250
then C is left with a move from object

00:37:04,339 --> 00:37:09,410
this is again a pretty bad situation

00:37:06,250 --> 00:37:11,599
this is something I have luckily only

00:37:09,410 --> 00:37:13,849
seen in test code for whatever reason

00:37:11,599 --> 00:37:15,789
but it and it was hard to under to make

00:37:13,849 --> 00:37:18,819
people understand that this is a move

00:37:15,789 --> 00:37:23,930
although it's called forward all right

00:37:18,819 --> 00:37:27,470
so do not use forward twice forward

00:37:23,930 --> 00:37:29,539
exactly once meaning I have to first

00:37:27,470 --> 00:37:33,049
copy T there's no other way

00:37:29,539 --> 00:37:35,809
I passed T to be B does too just creates

00:37:33,049 --> 00:37:40,990
a copy when whatever needs and then I

00:37:35,809 --> 00:37:47,450
can safely fourteen to see all right

00:37:40,990 --> 00:37:49,760
example for I now have again two data

00:37:47,450 --> 00:37:52,240
memories but I have also have two

00:37:49,760 --> 00:37:55,160
arguments the first argument is of

00:37:52,240 --> 00:37:59,420
capital T r1 and the second type of tau

00:37:55,160 --> 00:38:02,299
is of type capital T to my little t1 my

00:37:59,420 --> 00:38:04,670
argument is forwarded into David mmm a

00:38:02,299 --> 00:38:09,559
beam and my little teach

00:38:04,670 --> 00:38:13,180
who is forwarded in to see again 15

00:38:09,559 --> 00:38:13,180
seconds to think about this one all

00:38:27,460 --> 00:38:35,869
right what's wrong here okay perhaps

00:38:33,740 --> 00:38:36,859
after us differently who feels this is

00:38:35,869 --> 00:38:40,369
absolutely correct

00:38:36,859 --> 00:38:45,230
Oh quite a number of hands meaning you

00:38:40,369 --> 00:38:48,369
actually feel this is okay have you have

00:38:45,230 --> 00:38:51,380
you considered the distinct possibility

00:38:48,369 --> 00:38:59,799
that these two refer to the same object

00:38:51,380 --> 00:38:59,799
but you're right it is absolutely okay

00:38:59,950 --> 00:39:06,410
so it can refer to the same object this

00:39:04,280 --> 00:39:08,750
is of course possible it can be the same

00:39:06,410 --> 00:39:12,890
l value so for instance I can call this

00:39:08,750 --> 00:39:14,960
constructor with two times T so opening

00:39:12,890 --> 00:39:16,640
parenthesis T comma T okay this is the

00:39:14,960 --> 00:39:18,430
same L value and overlays are fine

00:39:16,640 --> 00:39:21,500
they're not forwarded everything's okay

00:39:18,430 --> 00:39:27,619
but how do I call this function with the

00:39:21,500 --> 00:39:30,680
same r-value think about this I have to

00:39:27,619 --> 00:39:34,599
do something pretty bad I have to call

00:39:30,680 --> 00:39:37,369
its constructor with move T comma move T

00:39:34,599 --> 00:39:39,589
this is of course a serious error on the

00:39:37,369 --> 00:39:43,130
call site with just said we should not

00:39:39,589 --> 00:39:45,440
never move twice the basic idea of

00:39:43,130 --> 00:39:47,750
Narvel reference is this is a unique

00:39:45,440 --> 00:39:50,240
reference there is exactly one reference

00:39:47,750 --> 00:39:52,010
to this object exactly one and there

00:39:50,240 --> 00:39:53,690
folk you can safely forward here without

00:39:52,010 --> 00:39:55,819
having to think about potentially

00:39:53,690 --> 00:39:57,650
aliasing perfectly okay

00:39:55,819 --> 00:40:02,230
yeah okay I know it was messing with you

00:39:57,650 --> 00:40:04,700
and so it was interesting example five

00:40:02,230 --> 00:40:06,319
something that also on which is

00:40:04,700 --> 00:40:09,890
sometimes see now I have a function

00:40:06,319 --> 00:40:13,369
create create gets a couple of arguments

00:40:09,890 --> 00:40:17,410
these arguments are now perfectly for

00:40:13,369 --> 00:40:19,040
with it into the make unique function

00:40:17,410 --> 00:40:20,840
probably there's something

00:40:19,040 --> 00:40:22,820
we're happening here that's a little

00:40:20,840 --> 00:40:25,100
short we could use some make you need

00:40:22,820 --> 00:40:27,080
directly make unique returns unique

00:40:25,100 --> 00:40:29,570
pointer and then just to be a little

00:40:27,080 --> 00:40:50,150
more efficient we move the in a pointer

00:40:29,570 --> 00:40:58,310
from the function that's wrong here okay

00:40:50,150 --> 00:41:02,150
who spotted problem okay little out as

00:40:58,310 --> 00:41:05,330
I'm sorry perfect

00:41:02,150 --> 00:41:08,000
perfect answer you break copy elysian so

00:41:05,330 --> 00:41:10,250
this is not a buck in a sense of it does

00:41:08,000 --> 00:41:13,700
not work anymore this is a buck in the

00:41:10,250 --> 00:41:21,320
sense you actually pesum eyes your coach

00:41:13,700 --> 00:41:24,830
if this is a word it was I'm sorry not

00:41:21,320 --> 00:41:27,020
guaranteed that is true but okay very

00:41:24,830 --> 00:41:29,120
likely this function would actually

00:41:27,020 --> 00:41:30,410
return this very efficiently by means of

00:41:29,120 --> 00:41:33,130
something called a return ville a

00:41:30,410 --> 00:41:35,810
permutation also called copy lesion that

00:41:33,130 --> 00:41:38,150
is by the way the best thing a compiler

00:41:35,810 --> 00:41:40,580
can do for you if you return something

00:41:38,150 --> 00:41:43,040
from function in a return statement then

00:41:40,580 --> 00:41:44,810
this very likely will end up in the

00:41:43,040 --> 00:41:46,280
return value optimization most

00:41:44,810 --> 00:41:48,140
specifically in this case the named

00:41:46,280 --> 00:41:51,170
return well optimization because you

00:41:48,140 --> 00:41:53,300
partner has a name however as soon as

00:41:51,170 --> 00:41:55,370
you try to move something from the

00:41:53,300 --> 00:41:57,770
function this return immobilization is

00:41:55,370 --> 00:41:59,960
simply turned off yes this will be moved

00:41:57,770 --> 00:42:03,080
from function great but the move is

00:41:59,960 --> 00:42:06,710
indeed a pointer operation with rvo is

00:42:03,080 --> 00:42:10,010
kind of no opt you have no cause at all

00:42:06,710 --> 00:42:12,650
so this is kind of an anti-pattern do

00:42:10,010 --> 00:42:13,940
not move objects from a function it does

00:42:12,650 --> 00:42:17,890
not give you anything it does not

00:42:13,940 --> 00:42:21,770
improve anything do not move just

00:42:17,890 --> 00:42:24,050
properly return and since I basically

00:42:21,770 --> 00:42:26,960
don't do anything here in this small

00:42:24,050 --> 00:42:31,460
example I could simply return directly

00:42:26,960 --> 00:42:32,750
if this is possible do so this is now

00:42:31,460 --> 00:42:35,960
returning in our

00:42:32,750 --> 00:42:38,000
you do not give it a name and this gives

00:42:35,960 --> 00:42:41,450
you additional properties for instance

00:42:38,000 --> 00:42:43,850
in c-plus r17 this guarantees the return

00:42:41,450 --> 00:42:45,650
value conversation and of course this is

00:42:43,850 --> 00:42:48,020
much more valuable so whenever you have

00:42:45,650 --> 00:42:49,850
the opportunity to not name anything do

00:42:48,020 --> 00:42:52,550
not name it now this is kind of a

00:42:49,850 --> 00:42:59,450
general could use and like that would be

00:42:52,550 --> 00:43:01,820
great yes so this is something that I'm

00:42:59,450 --> 00:43:03,410
worried about so how do you know when

00:43:01,820 --> 00:43:05,510
you're gonna get our vo or not get our

00:43:03,410 --> 00:43:07,880
view because if that's a huge object and

00:43:05,510 --> 00:43:10,580
you don't get that our vo he's like all

00:43:07,880 --> 00:43:12,800
right fast ok this is what what I try to

00:43:10,580 --> 00:43:15,530
evade also in the rest of the talk so I

00:43:12,800 --> 00:43:17,990
mentioned it and of course that the

00:43:15,530 --> 00:43:19,880
Pandora's box has been opened um so the

00:43:17,990 --> 00:43:22,400
return validation is a pretty complex

00:43:19,880 --> 00:43:24,410
topping itself there's no guarantee that

00:43:22,400 --> 00:43:26,180
it gets so in this case I'm sorry in

00:43:24,410 --> 00:43:29,330
this case you get the guarantee this is

00:43:26,180 --> 00:43:33,020
easy + / 17 guarantee but in the general

00:43:29,330 --> 00:43:36,770
case you don't know however there is a

00:43:33,020 --> 00:43:38,780
something that you can rely on if the

00:43:36,770 --> 00:43:40,910
compiler cannot use our vo and it's a

00:43:38,780 --> 00:43:43,910
very first thing it tries then it falls

00:43:40,910 --> 00:43:45,890
back to move and so I don't have to do

00:43:43,910 --> 00:43:47,840
it explicitly so if our vo is not

00:43:45,890 --> 00:43:50,330
triggered at least I get a move for free

00:43:47,840 --> 00:43:52,610
and if move does not happen the last

00:43:50,330 --> 00:43:54,710
thing the compiler tries is a copy and

00:43:52,610 --> 00:43:57,260
if this doesn't work then of course the

00:43:54,710 --> 00:44:03,580
codis doesn't work you get a compilation

00:43:57,260 --> 00:44:06,820
error all right I have one more sorry

00:44:03,580 --> 00:44:06,820
okay sorry

00:44:10,810 --> 00:44:20,540
first earlier nevertheless so is there a

00:44:15,860 --> 00:44:22,760
way to force our do as I said in c-plus

00:44:20,540 --> 00:44:24,710
17 there is the guaranteed understand

00:44:22,760 --> 00:44:27,620
and it says this example here we'll

00:44:24,710 --> 00:44:29,630
return it surprisingly even if it does

00:44:27,620 --> 00:44:32,000
not have a move constructor and not an

00:44:29,630 --> 00:44:34,280
copy constructor in this example it will

00:44:32,000 --> 00:44:35,900
be re out now I can return something

00:44:34,280 --> 00:44:39,560
cannot move that cannot copy from a

00:44:35,900 --> 00:44:41,750
function else you cannot force it it's a

00:44:39,560 --> 00:44:44,810
compiler optimization at least I'm not

00:44:41,750 --> 00:44:45,800
aware of any kind of to force it however

00:44:44,810 --> 00:44:47,540
this is a you know

00:44:45,800 --> 00:44:49,780
demonstration that exists in c-plus us

00:44:47,540 --> 00:44:51,740
98 now with the years it has improved

00:44:49,780 --> 00:44:53,450
c-plus Islam gave you a little more

00:44:51,740 --> 00:44:55,820
guarantee since he passed 11 this became

00:44:53,450 --> 00:44:58,400
a mandatory optimization and I think

00:44:55,820 --> 00:45:01,990
compilers a pretty clever nowadays there

00:44:58,400 --> 00:45:05,840
is no way you can force it but you can

00:45:01,990 --> 00:45:08,320
rely on it pretty pretty well okay does

00:45:05,840 --> 00:45:11,420
does it affect if you use different

00:45:08,320 --> 00:45:15,380
compilation flags like Oh 201 release

00:45:11,420 --> 00:45:20,270
debug to enforce using return value

00:45:15,380 --> 00:45:21,770
optimisation interesting you know our

00:45:20,270 --> 00:45:23,690
hero is something they compile am I to

00:45:21,770 --> 00:45:26,690
right away it is for instance well

00:45:23,690 --> 00:45:29,690
there's a guarantee even if you compile

00:45:26,690 --> 00:45:34,880
with debug mode or zero this will return

00:45:29,690 --> 00:45:36,380
it so it's not switched off so this

00:45:34,880 --> 00:45:38,240
return value optimisation is kind of

00:45:36,380 --> 00:45:47,540
independent of the optimization already

00:45:38,240 --> 00:45:49,070
choose okay it's a little bit like you

00:45:47,540 --> 00:45:49,640
don't want to see the six example but

00:45:49,070 --> 00:45:53,330
okay go on

00:45:49,640 --> 00:45:55,910
can you go back to the previous right -

00:45:53,330 --> 00:45:58,670
which example to the previous just a

00:45:55,910 --> 00:46:02,030
previous yes one so yeah you peek here

00:45:58,670 --> 00:46:07,310
it's local variable we are talking our

00:46:02,030 --> 00:46:08,990
restaurants again a lot of echo okay

00:46:07,310 --> 00:46:10,850
move away a little bit from the mic and

00:46:08,990 --> 00:46:28,460
perhaps speak louder that this is makes

00:46:10,850 --> 00:46:31,520
it easy for me okay okay I do not return

00:46:28,460 --> 00:46:36,170
a reference in this case I do return by

00:46:31,520 --> 00:46:38,300
value okay yeah but perhaps your

00:46:36,170 --> 00:46:41,030
question is pointing is going in the

00:46:38,300 --> 00:46:46,100
direction I wanted to show anyway do not

00:46:41,030 --> 00:46:47,810
please return by reference even so not L

00:46:46,100 --> 00:46:50,810
value reference and also not arvind

00:46:47,810 --> 00:46:53,240
reference yeah this does not help at all

00:46:50,810 --> 00:46:55,430
you would return a reference to local

00:46:53,240 --> 00:46:57,260
object the reference would be invalid

00:46:55,430 --> 00:47:00,049
when it is returned your jig is already

00:46:57,260 --> 00:47:05,200
destroyed this is of course also

00:47:00,049 --> 00:47:05,200
an anti-pattern okay

00:47:06,650 --> 00:47:11,660
comment to make there's sort of two

00:47:08,390 --> 00:47:14,450
flavors of return back there's no return

00:47:11,660 --> 00:47:16,220
value corrective correctly the easy way

00:47:14,450 --> 00:47:18,530
to check what's going on is just to do

00:47:16,220 --> 00:47:20,540
it with a simple clasp right you can

00:47:18,530 --> 00:47:22,849
step in the debugger or you can just put

00:47:20,540 --> 00:47:25,069
some print statements what I found where

00:47:22,849 --> 00:47:27,680
I am is the older Solaris compilers

00:47:25,069 --> 00:47:29,660
don't do an overview so if you name it

00:47:27,680 --> 00:47:32,359
and return it you don't get it but the

00:47:29,660 --> 00:47:34,609
Linux compiler alright okay thanks for

00:47:32,359 --> 00:47:39,049
the comment always measure yep alright

00:47:34,609 --> 00:47:43,400
thanks for the cover all right example

00:47:39,049 --> 00:47:44,960
six okay my animation return returns

00:47:43,400 --> 00:47:46,940
reference local opting of course there

00:47:44,960 --> 00:47:48,559
is a core guideline don't return it to

00:47:46,940 --> 00:47:52,040
your RF apparently this is so common

00:47:48,559 --> 00:48:00,109
that there is even a core guideline so

00:47:52,040 --> 00:48:05,059
please don't do it so okay why is it

00:48:00,109 --> 00:48:07,309
valid why do they let you do it okay you

00:48:05,059 --> 00:48:09,710
have you're in charge in C++ you are the

00:48:07,309 --> 00:48:11,619
one who decides what is happening so

00:48:09,710 --> 00:48:15,859
perhaps it's a reason okay

00:48:11,619 --> 00:48:18,740
example six I now have a full function

00:48:15,859 --> 00:48:21,770
it takes again a floating reference now

00:48:18,740 --> 00:48:24,170
we see it for what it is the type that I

00:48:21,770 --> 00:48:26,750
get could be integral but it could be

00:48:24,170 --> 00:48:29,210
also something else I would like to this

00:48:26,750 --> 00:48:31,790
to deal with integral types differently

00:48:29,210 --> 00:48:33,980
so there is an if context per I use the

00:48:31,790 --> 00:48:36,140
type two it is integral if it is indeed

00:48:33,980 --> 00:48:40,180
integral I fall into this if branch and

00:48:36,140 --> 00:48:43,040
else I deal with this as a non integer

00:48:40,180 --> 00:48:45,430
something wrong here I promise fifteen

00:48:43,040 --> 00:48:45,430
seconds

00:48:57,480 --> 00:49:02,470
all right this is indeed tricky

00:49:00,400 --> 00:49:04,720
after admit I spent two hours of my life

00:49:02,470 --> 00:49:06,900
debugging this particular problem so I

00:49:04,720 --> 00:49:15,359
felt like sharing it's not a bad idea

00:49:06,900 --> 00:49:21,930
what is happening here so Pharaoh says

00:49:15,359 --> 00:49:21,930
it's about the team is integral tea

00:49:23,220 --> 00:49:28,900
unfortunately tea is not necessarily

00:49:25,839 --> 00:49:31,270
concrete type type deduction in case of

00:49:28,900 --> 00:49:34,390
an l-value would make the TA for

00:49:31,270 --> 00:49:37,450
instance widget ref and which dref is

00:49:34,390 --> 00:49:41,829
never an integral and so even if you

00:49:37,450 --> 00:49:43,570
pass an l-value integer int then this

00:49:41,829 --> 00:49:46,230
would be an int ref and this would also

00:49:43,570 --> 00:49:49,210
not be an integral so in other words

00:49:46,230 --> 00:49:51,490
this integral might fail although it's

00:49:49,210 --> 00:49:54,369
an integral type and so this does not

00:49:51,490 --> 00:49:56,790
exactly do what I intended to do what

00:49:54,369 --> 00:50:00,670
you have to do here what you cannot

00:49:56,790 --> 00:50:02,920
forget is okay animation again you

00:50:00,670 --> 00:50:06,010
should explicitly remove the reference

00:50:02,920 --> 00:50:09,190
it could be a reference based type the

00:50:06,010 --> 00:50:11,069
tea itself if you use the no ref type

00:50:09,190 --> 00:50:13,869
everything works as expected

00:50:11,069 --> 00:50:15,910
this is a little tricky but this is just

00:50:13,869 --> 00:50:17,650
part of this deduction rules this is

00:50:15,910 --> 00:50:20,020
part of the magic of forwarding

00:50:17,650 --> 00:50:25,060
references this is why a little more

00:50:20,020 --> 00:50:34,440
difficult to use okay we just a Mike

00:50:25,060 --> 00:50:34,440
please you should remove the context /

00:50:34,890 --> 00:50:38,680
okay the Const

00:50:36,640 --> 00:50:40,569
is by the way not a problem a constant

00:50:38,680 --> 00:50:42,400
is recognized as an int or as an

00:50:40,569 --> 00:50:45,760
integral the cons is not a problem but

00:50:42,400 --> 00:50:48,310
the ref is so I okay if you want to you

00:50:45,760 --> 00:50:53,560
can also remove the Const but this is

00:50:48,310 --> 00:50:55,040
what you have to do all right we are

00:50:53,560 --> 00:50:57,920
back here

00:50:55,040 --> 00:50:59,900
yes it was a tough piece of work I admit

00:50:57,920 --> 00:51:02,540
it is not one of the easiest features

00:50:59,900 --> 00:51:05,090
but still he managed within two hours to

00:51:02,540 --> 00:51:08,600
basically see the the technical details

00:51:05,090 --> 00:51:11,270
I believe on your wrote into more

00:51:08,600 --> 00:51:14,630
details you will have now a much much

00:51:11,270 --> 00:51:17,960
smoother path so now believe it or not

00:51:14,630 --> 00:51:20,570
this could be you this is you the new

00:51:17,960 --> 00:51:22,810
our Valley reference expert so thank you

00:51:20,570 --> 00:51:22,810
very much

00:51:28,510 --> 00:51:42,080
is there any more questions yeah this is

00:51:32,450 --> 00:51:43,820
Mike okay questions about that stack

00:51:42,080 --> 00:51:44,840
frame I don't really understand I don't

00:51:43,820 --> 00:51:47,120
know if it's the scope of this

00:51:44,840 --> 00:51:49,430
presentation to let me to understand how

00:51:47,120 --> 00:51:52,700
would a stack frame look like if I would

00:51:49,430 --> 00:51:54,590
you call a function that is okay now the

00:51:52,700 --> 00:51:57,350
acoustics is again perfect I call the

00:51:54,590 --> 00:51:59,420
function that a text document as there a

00:51:57,350 --> 00:52:02,060
flap which is itself calling the target

00:51:59,420 --> 00:52:03,680
function because since it's refreshed I

00:52:02,060 --> 00:52:06,860
would understand that modifying that

00:52:03,680 --> 00:52:09,410
object would land modification in the

00:52:06,860 --> 00:52:11,660
deeper in the stack am I correct okay do

00:52:09,410 --> 00:52:15,590
you mean I can call if what happens if I

00:52:11,660 --> 00:52:19,910
call myself kind of no no no simply its

00:52:15,590 --> 00:52:22,010
acoustics I'm sorry if I'm to avoid

00:52:19,910 --> 00:52:25,010
moving the object it means that the

00:52:22,010 --> 00:52:27,290
automatic variable still resides in a

00:52:25,010 --> 00:52:27,890
stack frame of my parent right yes

00:52:27,290 --> 00:52:31,270
correct

00:52:27,890 --> 00:52:34,610
which means that my automatic let's say

00:52:31,270 --> 00:52:36,380
referent if I modified this reference or

00:52:34,610 --> 00:52:38,210
not but if I simply call this referee

00:52:36,380 --> 00:52:39,920
body I cannot modify it it means I've

00:52:38,210 --> 00:52:42,170
been calling the something that is up in

00:52:39,920 --> 00:52:45,830
the stack correct

00:52:42,170 --> 00:52:48,140
so yes it's still on the stack the

00:52:45,830 --> 00:52:50,330
object you move from is honestech still

00:52:48,140 --> 00:52:53,540
it lifts on until it is finally

00:52:50,330 --> 00:52:56,900
destroyed yeah okay the second very

00:52:53,540 --> 00:52:58,850
simple question and I can have an int I

00:52:56,900 --> 00:53:01,970
princess the integer I can't have a

00:52:58,850 --> 00:53:04,580
reference to that integer the AI has a

00:53:01,970 --> 00:53:07,910
name this will be null value it would

00:53:04,580 --> 00:53:08,650
not pass to a ruffler function yes not a

00:53:07,910 --> 00:53:11,050
simple

00:53:08,650 --> 00:53:13,570
forget about the functions in this

00:53:11,050 --> 00:53:15,120
function body I can have a fiend is I

00:53:13,570 --> 00:53:18,550
don't know three then I could in

00:53:15,120 --> 00:53:20,730
reference J its I it means that I would

00:53:18,550 --> 00:53:22,600
be the reference a trance up J now I

00:53:20,730 --> 00:53:26,400
understand it wouldn't make sense to

00:53:22,600 --> 00:53:30,010
make a riff raff to the I somehow right

00:53:26,400 --> 00:53:31,900
okay I think this is hard to explain

00:53:30,010 --> 00:53:33,250
especially since you're trying to point

00:53:31,900 --> 00:53:35,050
out different things so let's take this

00:53:33,250 --> 00:53:36,340
offline I'm happy to answer the question

00:53:35,050 --> 00:53:42,700
perhaps you can show me a piece of code

00:53:36,340 --> 00:53:44,960
well if you mind other questions no

00:53:42,700 --> 00:53:50,510
alright then thank you very much

00:53:44,960 --> 00:53:50,510

YouTube URL: https://www.youtube.com/watch?v=pIzaZbKUw2s


