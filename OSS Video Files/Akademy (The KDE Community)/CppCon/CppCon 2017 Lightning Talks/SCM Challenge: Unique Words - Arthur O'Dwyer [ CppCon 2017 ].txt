Title: SCM Challenge: Unique Words - Arthur O'Dwyer [ CppCon 2017 ]
Publication date: 2017-10-27
Playlist: CppCon 2017 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
—
Optimized And Managed by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:00,000 --> 00:00:07,940
[ARTHUR] This is my last talk, I think. [MICHAEL] If you didn't see him, it's too bad! It will not happen again. [ARTHUR] Not this year.

00:00:07,940 --> 00:00:10,140
[MICHAEL] Except right now. Oh— and here's the challenge! Go ahead.

00:00:10,140 --> 00:00:15,040
Yeah, so most of you may know — well, some of you know — at least, like, seven of you know —

00:00:15,720 --> 00:00:19,940
That we did this SCM challenge, and I was one of several people who —

00:00:19,940 --> 00:00:24,480
So it was Phil Nash — he was just up here — did one these puzzles. I did one of these puzzles.

00:00:24,480 --> 00:00:29,760
I actually completely missed when they gave out the iPad to a randomly selected winner...

00:00:29,760 --> 00:00:32,200
and that was a RANDOM selection.

00:00:32,200 --> 00:00:36,420
Here are the three that I consider honorable mentions. (You don't get iPads.)

00:00:36,420 --> 00:00:38,360
Number one, Tai Meng.

00:00:38,360 --> 00:00:41,420
Very simple... just... Ah. The puzzle was,

00:00:42,160 --> 00:00:44,340
print out numbers that go —

00:00:45,120 --> 00:00:52,460
Print out a series of numbers 1, 2, 3, 4, 5, up to N. And then back down: ...5, 4, 3, 2, 1.

00:00:52,480 --> 00:01:01,240
But you have to do it without repeating any identifiers in your entire program text.

00:01:01,240 --> 00:01:05,260
So the first step was write a tokenizer that pulls out all the identifiers and make sure they're all unique,

00:01:05,260 --> 00:01:08,100
and then the second step was, operate under that constraint.

00:01:08,110 --> 00:01:13,019
So this made it hard because you couldn't do loops — or, you know, you couldn't do more than one loop.

00:01:13,020 --> 00:01:18,980
You couldn't do a loop that mentioned the name of a variable twice; you couldn't have a function and call it; things like that.

00:01:18,980 --> 00:01:24,260
It turned out you didn't actually need any of this, and someone figured that out.

00:01:25,300 --> 00:01:33,380
Yeah, std::cout, and then — that's just the literal string, and it's got spaces in between and then on the way down it has tabs in between.

00:01:33,480 --> 00:01:39,800
"t78" is a different identifier from "78". Yeah, that works. Yeah, sorry about that. All right.

00:01:41,080 --> 00:01:48,500
And he explicitly mentions the magic number "652", which was in fact the biggest number you could put in that wouldn't break the grader.

00:01:48,500 --> 00:01:53,720
But there were some other people who tried to solve it in more, ah...

00:01:54,120 --> 00:01:59,900
Interesting ways as well. To try to smuggle in a non-trivial program, right?

00:01:59,900 --> 00:02:03,400
One that didn't just print, but could do it for arbitrary N based on a loop.

00:02:03,540 --> 00:02:08,340
This one is from Michael Kazakov.

00:02:09,220 --> 00:02:15,040
He actually contacted me on Slack afterward, and wanted to know, was there a way to do it that wasn't so hacky?

00:02:17,800 --> 00:02:20,640
And then we have Richard Smith —

00:02:20,640 --> 00:02:22,200
THE Richard Smith —

00:02:22,200 --> 00:02:26,380
Who takes great delight in breaking everyone's puzzles —

00:02:26,640 --> 00:02:28,640
Submitted this.

00:02:28,640 --> 00:02:36,500
[LAUGHTER, APPLAUSE]

00:02:36,800 --> 00:02:38,960
So those are my three honorable mentions.

00:02:40,300 --> 00:02:43,440
And I have two minutes left, so I'm just gonna —

00:02:43,820 --> 00:02:45,710
evangelize a little bit.

00:02:45,710 --> 00:02:49,809
Everyone read this slide and internalize it. An allocator is a handle to a heap.

00:02:50,900 --> 00:02:54,120
I see Marshall [Clow] there. Marshall, internalize this.

00:02:55,760 --> 00:02:57,360
Internalize this.

00:02:57,740 --> 00:03:01,780
An allocator is not a source of memory. An allocator is a POINTER to a source of memory.

00:03:01,900 --> 00:03:04,800
A container CONTAINS a pointer TO a source of memory.

00:03:04,800 --> 00:03:10,200
The source of memory is separate FROM the container. It is separate FROM the allocator. The allocator is contained WITHIN the container.

00:03:10,220 --> 00:03:15,620
You can have an allocator that's not in a container. An allocator is NOT a heap. It is merely a HANDLE to a heap.

00:03:18,020 --> 00:03:22,860
Allocator types should be copyable. This has ALWAYS been true. Still true.

00:03:22,860 --> 00:03:25,600
They should be copyable, just like pointers. This was ALWAYS true. Now it's more obvious.

00:03:26,480 --> 00:03:28,480
They should be cheaply copyable.

00:03:28,700 --> 00:03:30,700
Memory resource types should be immobile.

00:03:32,120 --> 00:03:39,400
That's all the slides I have— Oh yeah, what about std::allocator? Yeah, it works. Ask a mathematician about logs.

00:03:39,580 --> 00:03:41,440
Internalize this!

00:03:41,740 --> 00:03:46,180
That's not even my lightning talk. My first lightning talk was all this stuff. Let me show those again.

00:03:46,180 --> 00:03:49,680
[SOME LAUGHTER]

00:03:56,680 --> 00:04:00,560

YouTube URL: https://www.youtube.com/watch?v=PwNC2k0pFi0


