Title: CppCon 2017: Walter E. Brown “A C++20 Preview: operator ＜=＞”
Publication date: 2017-10-22
Playlist: CppCon 2017 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,959
thank you very much before I actually

00:00:02,070 --> 00:00:07,470
get started I need to ask you for a

00:00:03,959 --> 00:00:09,660
small favor everybody I'm an old man as

00:00:07,470 --> 00:00:12,030
you know we're all with my wife and I

00:00:09,660 --> 00:00:16,049
have been married almost 50 years 40

00:00:12,030 --> 00:00:20,180
years sorry 40 years and yeah our kids

00:00:16,049 --> 00:00:22,800
would be surprised but my wife actually

00:00:20,180 --> 00:00:24,330
fabricated all the ties I'm wearing this

00:00:22,800 --> 00:00:27,580
week and I'd appreciate it if he would

00:00:24,330 --> 00:00:37,979
help me thank her for these times

00:00:27,580 --> 00:00:37,979
[Applause]

00:00:39,030 --> 00:00:44,280
no no no no no no no how about we start

00:00:43,030 --> 00:00:49,660
at the beginning

00:00:44,280 --> 00:00:54,970
much better yes yes okay so this is

00:00:49,660 --> 00:00:59,280
going to be like a movie trailer right

00:00:54,970 --> 00:01:02,830
coming soon to a compiler near you yes

00:00:59,280 --> 00:01:06,310
the the Standards Committee WG 21 of

00:01:02,830 --> 00:01:08,290
which I'm an emeritus member for us C++

00:01:06,310 --> 00:01:11,710
17 is actually old hat we've started

00:01:08,290 --> 00:01:12,670
working on C++ 20 and I'm here to share

00:01:11,710 --> 00:01:15,850
with you tonight

00:01:12,670 --> 00:01:18,280
a tiny taste of some things that are in

00:01:15,850 --> 00:01:20,710
the pipeline that were rather optimistic

00:01:18,280 --> 00:01:23,560
about and it starts with this

00:01:20,710 --> 00:01:25,900
observation from roughly 20 years ago by

00:01:23,560 --> 00:01:28,420
Dave Abraham's that may be a name you

00:01:25,900 --> 00:01:32,560
recognize the abrahams exception safety

00:01:28,420 --> 00:01:34,960
guarantees for example if you ever write

00:01:32,560 --> 00:01:38,619
less than you probably also want the

00:01:34,960 --> 00:01:39,280
other operators as well and the status

00:01:38,619 --> 00:01:41,369
quo

00:01:39,280 --> 00:01:46,240
you know since forever has been

00:01:41,369 --> 00:01:47,979
typically I mean it's formulaic you

00:01:46,240 --> 00:01:49,420
write one operator and you implement the

00:01:47,979 --> 00:01:54,250
other five in terms of it

00:01:49,420 --> 00:01:56,830
for example this or this alternatively

00:01:54,250 --> 00:01:59,140
some people prefer to write to operators

00:01:56,830 --> 00:02:02,170
by hand and then implement the other

00:01:59,140 --> 00:02:06,660
four in terms of those two like that or

00:02:02,170 --> 00:02:09,940
like that okay kind of boring

00:02:06,660 --> 00:02:12,400
we'd like to automate this and we've

00:02:09,940 --> 00:02:15,160
wanted this for well over 20 years now

00:02:12,400 --> 00:02:19,360
this has been an ongoing problem for a

00:02:15,160 --> 00:02:22,810
long long time this is specifically what

00:02:19,360 --> 00:02:24,850
we would like compiler assistance so

00:02:22,810 --> 00:02:32,050
that we only have to write one Operator

00:02:24,850 --> 00:02:34,450
and the rest just works period done we

00:02:32,050 --> 00:02:35,890
would like something more it would

00:02:34,450 --> 00:02:39,130
really be great if we could somehow

00:02:35,890 --> 00:02:41,709
specify what comparison means for our

00:02:39,130 --> 00:02:43,960
type because there are types that should

00:02:41,709 --> 00:02:45,489
only be equality comparable that you

00:02:43,960 --> 00:02:46,750
can't order them

00:02:45,489 --> 00:02:48,700
a lot like like a random number

00:02:46,750 --> 00:02:50,319
distribution you can't arrange them in

00:02:48,700 --> 00:02:53,379
any sequence you can compare them for

00:02:50,319 --> 00:02:54,909
equality or not but that's that's it but

00:02:53,379 --> 00:02:57,849
there are other kinds of orderings as

00:02:54,909 --> 00:02:59,530
well and of course we want backwards

00:02:57,849 --> 00:03:03,459
compatibility you know current code

00:02:59,530 --> 00:03:07,359
should continue to work just fine so we

00:03:03,459 --> 00:03:09,489
want this to be opt in it turns out that

00:03:07,359 --> 00:03:11,500
as I said we could working on this for a

00:03:09,489 --> 00:03:16,209
very long time the oldest paper that I

00:03:11,500 --> 00:03:17,799
could find dates from 1995 and I suspect

00:03:16,209 --> 00:03:19,870
there are some older ones than that that

00:03:17,799 --> 00:03:22,450
I haven't been able to unearth yet and

00:03:19,870 --> 00:03:24,879
we've had several library attempts the

00:03:22,450 --> 00:03:27,760
notable notable ones being the standard

00:03:24,879 --> 00:03:30,299
rail laps and we've had Bustan operators

00:03:27,760 --> 00:03:34,450
which was on the first packages in boost

00:03:30,299 --> 00:03:36,760
dating back to I think 1999 maybe 1998

00:03:34,450 --> 00:03:39,639
I'm not sure but they've proven both

00:03:36,760 --> 00:03:43,989
awkward and inadequate they don't fill

00:03:39,639 --> 00:03:45,549
all the requirements I set forth and it

00:03:43,989 --> 00:03:47,530
happens that in the last three or four

00:03:45,549 --> 00:03:50,760
years there's been a resurgence of

00:03:47,530 --> 00:03:53,440
interest we've had like a dozen papers

00:03:50,760 --> 00:03:55,889
exploring this from various angles I

00:03:53,440 --> 00:04:01,209
wrote one beyond I wrote some etc etc

00:03:55,889 --> 00:04:02,079
okay so what's recently happened is all

00:04:01,209 --> 00:04:07,060
of this

00:04:02,079 --> 00:04:09,310
suddenly gelled and it's culminated in a

00:04:07,060 --> 00:04:14,650
recent proposal that the committee has

00:04:09,310 --> 00:04:17,739
already reviewed for a new operator this

00:04:14,650 --> 00:04:19,659
is not something we do lightly we're

00:04:17,739 --> 00:04:21,400
adding a new operator to the language

00:04:19,659 --> 00:04:24,099
officially called the three-way

00:04:21,400 --> 00:04:26,320
comparison operator unofficially of

00:04:24,099 --> 00:04:31,570
course it's the spaceship operator which

00:04:26,320 --> 00:04:33,699
explains my title slide here are a few

00:04:31,570 --> 00:04:37,090
details we've picked the precedents for

00:04:33,699 --> 00:04:40,240
it we've picked the associativity there

00:04:37,090 --> 00:04:43,830
will be a new header in the library

00:04:40,240 --> 00:04:46,270
because it comes with library support

00:04:43,830 --> 00:04:49,300
here are some of the highlights of how

00:04:46,270 --> 00:04:52,510
we envisioned it to be used you define

00:04:49,300 --> 00:04:55,719
this operator for your type that's how

00:04:52,510 --> 00:04:57,099
you opt-in for example this is kind of

00:04:55,719 --> 00:04:58,900
the minimum that you have to write

00:04:57,099 --> 00:05:01,150
assuming the defaults are acceptable

00:04:58,900 --> 00:05:06,130
for your type as we believe they often

00:05:01,150 --> 00:05:10,000
will be it's a one-liner what this does

00:05:06,130 --> 00:05:12,190
is memorize compare and how does it

00:05:10,000 --> 00:05:14,590
compare met corresponding members well

00:05:12,190 --> 00:05:18,820
however those members have defined their

00:05:14,590 --> 00:05:20,590
own comparison operators okay and when

00:05:18,820 --> 00:05:24,760
this all is said and done you get a

00:05:20,590 --> 00:05:28,380
three-way result so what happens when

00:05:24,760 --> 00:05:31,390
client code says a less than B or a

00:05:28,380 --> 00:05:35,560
greater than B or a you know fill in the

00:05:31,390 --> 00:05:37,960
blank well if the type has the

00:05:35,560 --> 00:05:41,080
corresponding operator the compiler will

00:05:37,960 --> 00:05:43,020
arrange to use it if it doesn't and

00:05:41,080 --> 00:05:45,670
you've provided a spaceship operator

00:05:43,020 --> 00:05:48,970
then the compiler arranges to use that

00:05:45,670 --> 00:05:51,430
and pretends that you wrote a call to

00:05:48,970 --> 00:05:53,590
the spaceship operator and asks if the

00:05:51,430 --> 00:05:57,760
result has the right relationship

00:05:53,590 --> 00:05:58,930
against zero right so I mean we're used

00:05:57,760 --> 00:06:00,640
to this because we have this in the

00:05:58,930 --> 00:06:05,020
standard library with stretched or come

00:06:00,640 --> 00:06:08,020
right so we know how to do this here are

00:06:05,020 --> 00:06:09,910
some options that the programmers will

00:06:08,020 --> 00:06:12,010
have in case the defaults aren't right

00:06:09,910 --> 00:06:13,600
for us you can provide your own

00:06:12,010 --> 00:06:16,360
definition of course you don't have to

00:06:13,600 --> 00:06:18,640
define it as equal default when might

00:06:16,360 --> 00:06:20,440
you want to do that well if not all the

00:06:18,640 --> 00:06:22,780
members are supposed to participate in

00:06:20,440 --> 00:06:24,670
the comparison or if the order of your

00:06:22,780 --> 00:06:26,980
members isn't quite the order in which

00:06:24,670 --> 00:06:28,960
you need them compared you have to

00:06:26,980 --> 00:06:32,670
provide your own if you write only one

00:06:28,960 --> 00:06:37,000
function and it's going to be used you

00:06:32,670 --> 00:06:41,140
also get to specify your types ordering

00:06:37,000 --> 00:06:44,410
properties as the return type of this

00:06:41,140 --> 00:06:47,200
operator and there's a a library a set

00:06:44,410 --> 00:06:49,150
of library types and pick one and that

00:06:47,200 --> 00:06:54,790
defines what the appropriate operations

00:06:49,150 --> 00:06:56,860
are for your type you can choose to have

00:06:54,790 --> 00:06:58,180
this as a member function as I've shown

00:06:56,860 --> 00:07:01,720
or you can have it as a non-member

00:06:58,180 --> 00:07:03,910
function by design your choice and you

00:07:01,720 --> 00:07:09,030
can actually overload this for example

00:07:03,910 --> 00:07:11,410
if you want cross type comparisons okay

00:07:09,030 --> 00:07:12,280
so there's where you go for more

00:07:11,410 --> 00:07:13,630
information

00:07:12,280 --> 00:07:15,700
said there have been like a dozen that

00:07:13,630 --> 00:07:18,130
15 or 20 papers in the last three or

00:07:15,700 --> 00:07:20,410
four years this is one of the seminal

00:07:18,130 --> 00:07:23,530
ones it doesn't have any part of the

00:07:20,410 --> 00:07:26,530
proposal in it but it sets forth some

00:07:23,530 --> 00:07:31,180
key insights that we've based our design

00:07:26,530 --> 00:07:31,870
on this is the paper that has the design

00:07:31,180 --> 00:07:34,660
in it

00:07:31,870 --> 00:07:37,930
it also has examples it has a nice

00:07:34,660 --> 00:07:41,280
bibliography of the recent papers it

00:07:37,930 --> 00:07:43,690
also has the proposed formal wording

00:07:41,280 --> 00:07:46,320
there will be a revision of this paper

00:07:43,690 --> 00:07:49,150
in the next mailing which will come out

00:07:46,320 --> 00:07:52,720
either late October early November this

00:07:49,150 --> 00:07:55,600
year 2017 and there's a companion paper

00:07:52,720 --> 00:08:00,190
which is mine that provides the library

00:07:55,600 --> 00:08:04,150
wording proposed library wording for C++

00:08:00,190 --> 00:08:06,040
20 we have not officially decided what

00:08:04,150 --> 00:08:08,440
the new header name will be we're

00:08:06,040 --> 00:08:10,780
proposing cmp that's the one part that

00:08:08,440 --> 00:08:12,850
hasn't yet been blessed by the committee

00:08:10,780 --> 00:08:15,190
we hope that can be done quickly I don't

00:08:12,850 --> 00:08:17,620
want to have to type out compare with

00:08:15,190 --> 00:08:18,790
son as the name of the header but the

00:08:17,620 --> 00:08:21,760
committee will do what the committee

00:08:18,790 --> 00:08:24,250
will do the proposal as I say is still

00:08:21,760 --> 00:08:26,650
on its way through WG 21 we're

00:08:24,250 --> 00:08:31,419
optimistic the design has been approved

00:08:26,650 --> 00:08:34,870
already we now have to review carefully

00:08:31,419 --> 00:08:37,510
the wording there's not a whole lot of

00:08:34,870 --> 00:08:40,240
wording but it's not trivial either so

00:08:37,510 --> 00:08:43,060
there is some work yet to be done but

00:08:40,240 --> 00:08:44,710
all the words are in these papers mine

00:08:43,060 --> 00:08:46,570
is still forthcoming it'll be out in the

00:08:44,710 --> 00:08:49,060
same mailing as the revision of the

00:08:46,570 --> 00:08:50,980
initial proposal paper we do not yet

00:08:49,060 --> 00:08:52,990
have any implementation experience

00:08:50,980 --> 00:08:54,760
because it seems like the vendors are

00:08:52,990 --> 00:08:57,160
waiting for at least the initial wording

00:08:54,760 --> 00:09:00,070
review before they should go and start

00:08:57,160 --> 00:09:01,390
implementing things to try out but if

00:09:00,070 --> 00:09:04,270
you're one of those people who likes to

00:09:01,390 --> 00:09:07,750
hack on GCC maybe or clang please come

00:09:04,270 --> 00:09:09,160
see me and you know I want to talk to

00:09:07,750 --> 00:09:10,540
you because we would love to have an

00:09:09,160 --> 00:09:10,839
implementation of this stuff to play

00:09:10,540 --> 00:09:13,700
with

00:09:10,839 --> 00:09:19,959
and with that I thank you all very much

00:09:13,700 --> 00:09:19,959

YouTube URL: https://www.youtube.com/watch?v=_PKpyD6Ba1s


