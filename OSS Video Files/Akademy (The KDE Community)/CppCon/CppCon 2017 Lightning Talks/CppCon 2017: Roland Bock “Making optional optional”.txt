Title: CppCon 2017: Roland Bock “Making optional optional”
Publication date: 2017-10-23
Playlist: CppCon 2017 Lightning Talks
Description: 
	http://CppCon.org
—
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2017
—
Lightning Talk
— 
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:01,040 --> 00:00:05,960
This is about me feeling stupid, so please bear with me.

00:00:06,720 --> 00:00:09,520
How do you construct an optional?

00:00:09,620 --> 00:00:13,380
If you look into the documentation at cppreference.com for instance,

00:00:14,080 --> 00:00:17,480
you construct an optional default constructor,

00:00:17,620 --> 00:00:22,740
and if you have a value, you assign this value to the optional, and then you return it.

00:00:22,740 --> 00:00:28,280
Because all the examples that you see are about returning optionals.

00:00:28,340 --> 00:00:31,460
I have a slightly different situation.

00:00:31,720 --> 00:00:37,820
I want people to pass values to my function.

00:00:38,100 --> 00:00:43,800
My test function, in this case here, that's expecting an optional.

00:00:44,200 --> 00:00:49,840
So, how does the user provide that optional to me?

00:00:50,140 --> 00:00:56,500
The user could do it in the same way as document and always default construct the optional,

00:00:56,680 --> 00:01:03,740
and then, in this case, take a value from the map if that value is available,

00:01:03,920 --> 00:01:06,180
and then pass that to me.

00:01:06,360 --> 00:01:13,780
That is what's documented. And if that is the canonical way to do it, then I'm not using optional. Right?

00:01:13,800 --> 00:01:19,640
I don't like that, because it's spilling into the outer context. That's awful.

00:01:19,960 --> 00:01:23,660
How can I do this in a different way?

00:01:25,480 --> 00:01:29,160
There is a function called make_optional. That sounds good. That sounds promising.

00:01:29,160 --> 00:01:35,820
But basically what it does is it's forwarding all the arguments that you give it to the constructor.

00:01:36,620 --> 00:01:41,680
You have to choose at compile time whether you construct it with a value or without a value.

00:01:42,100 --> 00:01:48,340
So, it's not really optional, right? It should be called make_mandatory, I think.

00:01:50,320 --> 00:01:55,860
So, if that's not doing what I want, maybe I'll write my own function:

00:01:56,040 --> 00:01:58,380
make_really_optional

00:01:58,560 --> 00:02:04,940
It gets a condition and some factory function. Then we can hide all the ugliness in this function.

00:02:05,760 --> 00:02:10,000
We construct the default constructor for optional.

00:02:10,000 --> 00:02:15,120
Then, if the condition is true, we call the factory function, return the thing and we're done.

00:02:15,300 --> 00:02:19,340
And when we call this... It looks better than before.

00:02:19,560 --> 00:02:24,100
So, make_really_optional, then the condition, then some lambda function that,

00:02:24,100 --> 00:02:28,580
because we don't want to repeat ourselves, captures everything by reference,

00:02:28,880 --> 00:02:34,780
and then this will extract the data if necessary.

00:02:35,700 --> 00:02:39,040
But Scott Meyers says that capturing everything by reference is bad.

00:02:39,040 --> 00:02:41,140
So, let's not do that.

00:02:41,340 --> 00:02:45,840
Then I thought, what we really want to do is, we want to,

00:02:45,840 --> 00:02:50,600
based on a condition, pass either an optional with a value or without a value.

00:02:51,740 --> 00:02:55,160
That sounds like a good job for a ternary operator.

00:02:55,320 --> 00:03:02,500
In the good case, we just pass the optional with a value. And in the bad case, we pass one without a value.

00:03:02,740 --> 00:03:09,480
But I certainly don't want to write std::optional<type> because types can be very long.

00:03:09,660 --> 00:03:14,840
Especially in my library types can be BIG. You don't want to write them.

00:03:15,080 --> 00:03:18,640
So, you should do something different.

00:03:19,260 --> 00:03:22,800
I created a type "nought".

00:03:23,880 --> 00:03:29,360
Nought is something that can be converted implicitly to any optional.

00:03:30,120 --> 00:03:32,460
So, we can do something like this.

00:03:32,460 --> 00:03:34,700
We can write: ternary operator,

00:03:34,720 --> 00:03:39,720
if the condition is true, then we pass the optional with the value.

00:03:39,720 --> 00:03:45,100
Otherwise, nought, which will be automatically converted to the optional that we want to have.

00:03:45,760 --> 00:03:48,200
Cool. That works.

00:03:48,200 --> 00:03:53,100
And then I said "oh damn it, this is a real face palm situation",

00:03:53,160 --> 00:03:57,280
because there is something that I saw in the documentation at cpp reference.

00:03:57,480 --> 00:03:59,500
That's nullopt.

00:03:59,520 --> 00:04:02,620
Nullopt was done for this case, I think.

00:04:02,960 --> 00:04:07,840
It can be used to to construct an optional.

00:04:08,000 --> 00:04:10,600
It's not conversion, but it's construction.

00:04:10,600 --> 00:04:14,160
It does exactly the same that I did with my mod thing.

00:04:14,160 --> 00:04:20,960
So, actually I think that this is the canonical way to create an optional.

00:04:21,520 --> 00:04:27,620
And I think that the documentation which does this default initialization,

00:04:27,700 --> 00:04:33,040
and then if there is a value, then assign it, and then pass it.

00:04:33,220 --> 00:04:38,240
That's not good. That's ugly. This should be the the good one.

00:04:38,620 --> 00:04:44,100
If you agree, then update the documentation. Update your code. Make it nicer.

00:04:44,240 --> 00:04:46,300

YouTube URL: https://www.youtube.com/watch?v=QB0oY5f6q-E


