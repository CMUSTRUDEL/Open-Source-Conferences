Title: Some Things C++ Does Right - Patrice Roy - CppCon 2020
Publication date: 2020-10-08
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/some_things_cpp_does_right/some_things_cpp_does_right__patrice_roy__cppcon_2020.pdf
---
People often complain about C++: to some, it's not memory-safe enough, not type-safe enough. Some will tell you that some (or all!) of its defaults are wrong. Many complain that it's too expert-friendly.

There's often a grain of truth in criticism, and C++ surely has a bit of each of these alleged warts; it's a language that has history, obviously, and that has evolved organically over the years, and it has the imperfections we can expect for a tool used by millions to perform high-performance or safety- critical tasks in various application domains.

However, there are a significant number of things C++ does right, and there are a number of reasons why we love this language... and love it so much that we gather together to trade ideas, learn about it, understand it better... and enjoy it all!

This talk is about some of the things C++ does right. It does not aim to provide an exhaustive list (far from it!), or to throw arrows at other languages (although there will be comparisons), nor does it aim to offer an apologetic perspective on C++. This talk is about some of those things one misses when using other languages, and aims to remind us of some of those things that make C++ beautiful, fun and efficient.

---
Patrice Roy has been playing with C++, either professionally, for pleasure or (most of the time) both for over 25 years. After a few years doing R&D and working on military flight simulators, he moved on to academics and has been teaching computer science since 1998. Since 2005, he’s been involved more specifically in helping graduate students and professionals from the fields of real-time systems and game programming develop the skills they need to face today’s challenges. The rapid evolution of C++ in recent years has made his job even more enjoyable. He’s been a participating member in the ISO C++ Standards Committee since late 2014 and has been involved with the ISO Programming Language Vulnerabilities Committee since late 2015. He has five kids, and his wife ensures their house is home to a continuously changing number of cats, dogs and other animals.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,360 --> 00:00:13,840
so welcome everyone

00:00:10,800 --> 00:00:15,599
to this talk named some things c

00:00:13,840 --> 00:00:17,199
plus does right i hope you're in the

00:00:15,599 --> 00:00:17,920
right room and that's what you were

00:00:17,199 --> 00:00:20,960
planning to

00:00:17,920 --> 00:00:23,039
to go for or go to so my name is patrice

00:00:20,960 --> 00:00:25,119
as you can see my email addresses

00:00:23,039 --> 00:00:26,320
are in the slide right now which will be

00:00:25,119 --> 00:00:30,560
made available to you

00:00:26,320 --> 00:00:32,640
after the event of course

00:00:30,560 --> 00:00:34,160
if you've never been to my talks and you

00:00:32,640 --> 00:00:35,040
or if you don't know me well i have a

00:00:34,160 --> 00:00:37,600
few kids

00:00:35,040 --> 00:00:38,800
you will see some of them while you see

00:00:37,600 --> 00:00:40,559
oh you will see all of them

00:00:38,800 --> 00:00:42,399
in fact in the slides that will come

00:00:40,559 --> 00:00:43,360
because they're part of the presentation

00:00:42,399 --> 00:00:45,280
today

00:00:43,360 --> 00:00:47,120
a number of animals you will see a few

00:00:45,280 --> 00:00:49,520
of them too for some reasons

00:00:47,120 --> 00:00:51,440
uh i used to write military flight

00:00:49,520 --> 00:00:54,719
simulators in the past and do

00:00:51,440 --> 00:00:56,320
r d but i've been a professor for over

00:00:54,719 --> 00:00:59,760
20 years now and this is

00:00:56,320 --> 00:01:02,879
pretty much what's uh bringing the stock

00:00:59,760 --> 00:01:05,840
to the far today and i'm also

00:01:02,879 --> 00:01:07,280
incidentally a wg 21 member who hasn't

00:01:05,840 --> 00:01:09,520
been to the last two three meetings

00:01:07,280 --> 00:01:11,119
because i've been very busy with the

00:01:09,520 --> 00:01:15,280
pandemic and such

00:01:11,119 --> 00:01:17,040
such stuff so let's start

00:01:15,280 --> 00:01:18,400
you can see my beautiful wife here and

00:01:17,040 --> 00:01:21,759
one of the animals

00:01:18,400 --> 00:01:24,880
named gracie these uh things we do right

00:01:21,759 --> 00:01:26,400
like my kids and animals and such things

00:01:24,880 --> 00:01:27,920
things that are right in life will be

00:01:26,400 --> 00:01:30,000
part of the presentation to give it some

00:01:27,920 --> 00:01:31,600
color because the slides are white

00:01:30,000 --> 00:01:33,119
to contrast with the black slides that i

00:01:31,600 --> 00:01:35,280
had yesterday

00:01:33,119 --> 00:01:37,520
so you might have heard that c plus plus

00:01:35,280 --> 00:01:40,000
is not good for many reasons not

00:01:37,520 --> 00:01:41,600
memory safe enough you'll see that not

00:01:40,000 --> 00:01:43,680
type safe enough you'll hear people

00:01:41,600 --> 00:01:45,840
complain about this

00:01:43,680 --> 00:01:47,920
some it's language where some defaults

00:01:45,840 --> 00:01:49,600
are wrong or even as some people say

00:01:47,920 --> 00:01:51,920
all defaults are wrong you can see that

00:01:49,600 --> 00:01:54,240
sometimes i see that pass by

00:01:51,920 --> 00:01:55,920
whenever people tweet to me or write to

00:01:54,240 --> 00:01:57,040
me because they hate c plus plus and

00:01:55,920 --> 00:01:58,320
tell me you should use something else

00:01:57,040 --> 00:02:00,320
instead

00:01:58,320 --> 00:02:01,520
too expert friendly i hear that even

00:02:00,320 --> 00:02:04,799
from experts

00:02:01,520 --> 00:02:06,799
which is true herb's talks later today

00:02:04,799 --> 00:02:08,000
herb's talk later today will be about

00:02:06,799 --> 00:02:10,959
how we simplify c plus

00:02:08,000 --> 00:02:11,200
plus uh he's working on things many of

00:02:10,959 --> 00:02:13,760
us

00:02:11,200 --> 00:02:14,400
are so yeah people maybe to expert

00:02:13,760 --> 00:02:16,720
friendly

00:02:14,400 --> 00:02:18,640
although my talk last year was about how

00:02:16,720 --> 00:02:20,160
it's you don't have to be expert to do c

00:02:18,640 --> 00:02:23,280
plus plus

00:02:20,160 --> 00:02:24,080
there's things about that so so there's

00:02:23,280 --> 00:02:26,720
truth there's

00:02:24,080 --> 00:02:28,319
some kind of truth in there because yes

00:02:26,720 --> 00:02:30,400
c plus plus has warts

00:02:28,319 --> 00:02:31,680
and it has to have words you know it has

00:02:30,400 --> 00:02:35,360
history it covers

00:02:31,680 --> 00:02:37,519
a wide wide range of application domains

00:02:35,360 --> 00:02:39,280
and lots of people work on it from the

00:02:37,519 --> 00:02:41,120
very level to the very high level

00:02:39,280 --> 00:02:42,400
it's high performance it can do city

00:02:41,120 --> 00:02:44,720
critical stuff

00:02:42,400 --> 00:02:47,280
so yeah it's when you when you go that

00:02:44,720 --> 00:02:50,160
that wide you're bound to have warts

00:02:47,280 --> 00:02:51,760
but we do a number of things right

00:02:50,160 --> 00:02:53,360
there's a significant number of things

00:02:51,760 --> 00:02:54,879
that we do right

00:02:53,360 --> 00:02:56,959
and there's a lot of reasons to love

00:02:54,879 --> 00:02:58,800
this language i love this language

00:02:56,959 --> 00:03:01,760
that's one of the reasons why i'm here

00:02:58,800 --> 00:03:04,159
that while you're there i guess we like

00:03:01,760 --> 00:03:05,840
it enough to get together even virtually

00:03:04,159 --> 00:03:07,760
to to talk about it and try to

00:03:05,840 --> 00:03:09,200
understand it better we enjoy coding in

00:03:07,760 --> 00:03:10,640
c plus there should be something good

00:03:09,200 --> 00:03:12,239
about it

00:03:10,640 --> 00:03:14,000
so so this is the talk about the things

00:03:12,239 --> 00:03:17,360
that we do right it's not exhaustive

00:03:14,000 --> 00:03:18,959
in any way okay just as an example i put

00:03:17,360 --> 00:03:20,720
this small tweet there that you can see

00:03:18,959 --> 00:03:22,720
right now when i was trying to promote

00:03:20,720 --> 00:03:23,760
my class that i gave last week my coupon

00:03:22,720 --> 00:03:27,120
cloud plus plus

00:03:23,760 --> 00:03:30,239
a cbcon class about managing memory

00:03:27,120 --> 00:03:31,120
and i had this uh memory management is

00:03:30,239 --> 00:03:33,920
one of the things

00:03:31,120 --> 00:03:35,680
some used to give c plus a bad name and

00:03:33,920 --> 00:03:36,879
i was trying to put forward that you can

00:03:35,680 --> 00:03:39,280
do something cool with it

00:03:36,879 --> 00:03:40,400
i had an immediate reaction by jan who

00:03:39,280 --> 00:03:42,640
was a very nice guy

00:03:40,400 --> 00:03:44,080
who said well i thought it was one of

00:03:42,640 --> 00:03:44,480
the good things about c plus plus that

00:03:44,080 --> 00:03:46,400
we can

00:03:44,480 --> 00:03:48,080
like manage memory and manage resources

00:03:46,400 --> 00:03:51,040
tightly so well

00:03:48,080 --> 00:03:53,360
yeah some say that i don't i like it i

00:03:51,040 --> 00:03:56,480
think we do the right thing

00:03:53,360 --> 00:03:58,959
so so it's not an exhaustive list far

00:03:56,480 --> 00:04:00,720
far far from it we do a number of cool

00:03:58,959 --> 00:04:02,560
things and we do a number of bad things

00:04:00,720 --> 00:04:04,720
i know but this is about the good stuff

00:04:02,560 --> 00:04:06,239
some of the good stuff there will be

00:04:04,720 --> 00:04:07,840
comparisons with other languages so you

00:04:06,239 --> 00:04:08,799
will see some c sharp and java code in

00:04:07,840 --> 00:04:10,159
there

00:04:08,799 --> 00:04:12,640
quite a bit of c sharp because i do more

00:04:10,159 --> 00:04:14,879
c sharp these days for school reasons

00:04:12,640 --> 00:04:16,720
but but it's not a resource is good and

00:04:14,879 --> 00:04:18,239
the others is bad or bad

00:04:16,720 --> 00:04:20,079
it's more about the things that i like

00:04:18,239 --> 00:04:20,880
in c cluster that i miss when i'm not

00:04:20,079 --> 00:04:22,479
there

00:04:20,880 --> 00:04:24,240
when i'm stuck doing something else i

00:04:22,479 --> 00:04:26,240
miss c plus a lot

00:04:24,240 --> 00:04:27,360
so and i won't make anyone believe that

00:04:26,240 --> 00:04:31,040
siblings is perfect

00:04:27,360 --> 00:04:33,680
it's not but it's cool it's beautiful

00:04:31,040 --> 00:04:34,400
it's fun it's efficient if you if you

00:04:33,680 --> 00:04:37,040
use it right

00:04:34,400 --> 00:04:37,759
and and i miss it when it's not around

00:04:37,040 --> 00:04:40,080
so

00:04:37,759 --> 00:04:42,080
as i said c sharp is a fine language

00:04:40,080 --> 00:04:44,080
whichever is a fine language javascript

00:04:42,080 --> 00:04:46,240
the final language python sklc

00:04:44,080 --> 00:04:47,600
they're all cool so so this i'm not

00:04:46,240 --> 00:04:49,120
bashing anyone even though i'm going to

00:04:47,600 --> 00:04:50,560
take examples from other languages to

00:04:49,120 --> 00:04:53,840
make comparisons

00:04:50,560 --> 00:04:55,199
they have good sites too so let's talk

00:04:53,840 --> 00:04:57,280
about beauty and elegance

00:04:55,199 --> 00:04:59,120
what you see there is ludo ludo is now

00:04:57,280 --> 00:05:01,759
seven years old you see him later in the

00:04:59,120 --> 00:05:05,759
the talk he's uh well he's my youngest

00:05:01,759 --> 00:05:05,759
son i have four daughters and one son

00:05:05,840 --> 00:05:08,560
so about beauty when beauty is hard to

00:05:07,520 --> 00:05:09,600
describe when you're talking about

00:05:08,560 --> 00:05:12,560
programming languages

00:05:09,600 --> 00:05:13,120
people will say well it's a bit cultural

00:05:12,560 --> 00:05:15,600
maybe

00:05:13,120 --> 00:05:16,560
local subjective there's beauty in most

00:05:15,600 --> 00:05:19,919
programming languages

00:05:16,560 --> 00:05:20,639
and c has beauty so let's take this

00:05:19,919 --> 00:05:23,440
example for

00:05:20,639 --> 00:05:24,720
of uh for sense so we have this game i

00:05:23,440 --> 00:05:26,080
work with game programmers as most of

00:05:24,720 --> 00:05:28,800
you know i guess

00:05:26,080 --> 00:05:30,479
and we have this class hierarchy that in

00:05:28,800 --> 00:05:32,240
which we have objects stored in the

00:05:30,479 --> 00:05:33,280
pimple class it's a design pattern if

00:05:32,240 --> 00:05:35,120
you're looking for it uh

00:05:33,280 --> 00:05:37,600
an idiom that you will find in herb's

00:05:35,120 --> 00:05:39,039
book among herbs books and manganese

00:05:37,600 --> 00:05:41,039
it's called monsters you know the

00:05:39,039 --> 00:05:42,320
monster so a monster is something you

00:05:41,039 --> 00:05:44,320
can copy around

00:05:42,320 --> 00:05:45,600
that has polymorphic behavior inside

00:05:44,320 --> 00:05:47,919
whatever

00:05:45,600 --> 00:05:49,199
and so you have this this fight in your

00:05:47,919 --> 00:05:51,919
game where there's

00:05:49,199 --> 00:05:53,360
a carnage so so a monster said to

00:05:51,919 --> 00:05:55,280
another monster well

00:05:53,360 --> 00:05:56,479
you smell good today and the other

00:05:55,280 --> 00:05:57,840
monster got angry because

00:05:56,479 --> 00:05:59,199
it's not supposed to say that as a

00:05:57,840 --> 00:06:00,639
monster and they started fighting and

00:05:59,199 --> 00:06:02,639
there's death all over the place

00:06:00,639 --> 00:06:03,919
so after that you want to remove the

00:06:02,639 --> 00:06:06,880
dead bodies and keep the ones that are

00:06:03,919 --> 00:06:08,720
left alive if you're doing c sharp code

00:06:06,880 --> 00:06:10,400
you could do something like this

00:06:08,720 --> 00:06:12,080
so as i said it's not a c sharp bashing

00:06:10,400 --> 00:06:14,240
thing but still

00:06:12,080 --> 00:06:16,319
so so this is very easy you look at this

00:06:14,240 --> 00:06:18,160
cozy way cute simple nice

00:06:16,319 --> 00:06:20,000
i have this list list there is not a

00:06:18,160 --> 00:06:22,000
linked list in c sharp this is the name

00:06:20,000 --> 00:06:23,840
they give to what we call vector so it's

00:06:22,000 --> 00:06:25,600
dynamic array it's fast when you add at

00:06:23,840 --> 00:06:27,680
the end it's very slow when you remove

00:06:25,600 --> 00:06:29,360
at the beginning or something

00:06:27,680 --> 00:06:31,199
so you do remove all you pass the lambda

00:06:29,360 --> 00:06:32,800
this is the lambda c uh syntax of c

00:06:31,199 --> 00:06:34,000
sharp it's simple but it's less powerful

00:06:32,800 --> 00:06:37,120
than what we have in c plus plus

00:06:34,000 --> 00:06:39,520
it does less things so remove all

00:06:37,120 --> 00:06:41,120
the not alive ones because there would

00:06:39,520 --> 00:06:43,360
be a property in that language

00:06:41,120 --> 00:06:44,160
so it's simple it's nice uh cool i like

00:06:43,360 --> 00:06:47,919
it

00:06:44,160 --> 00:06:49,919
yeah but but you're in c sharp see so so

00:06:47,919 --> 00:06:51,520
that lsd object there it's not an object

00:06:49,919 --> 00:06:52,639
it's a reference to a list and you're

00:06:51,520 --> 00:06:54,560
sharing state

00:06:52,639 --> 00:06:56,080
that thing shares state between the

00:06:54,560 --> 00:06:58,000
caller and the callee

00:06:56,080 --> 00:06:59,360
so it's a mutable shared state and

00:06:58,000 --> 00:07:01,599
you're affecting the code

00:06:59,360 --> 00:07:03,199
the client code with this so you have to

00:07:01,599 --> 00:07:05,280
think about your code was that the

00:07:03,199 --> 00:07:07,520
proper thing to do

00:07:05,280 --> 00:07:10,319
that's something to think about it's

00:07:07,520 --> 00:07:11,520
hard to reason on those things

00:07:10,319 --> 00:07:13,520
if you're doing c plus plus code it

00:07:11,520 --> 00:07:15,120
could look like this so

00:07:13,520 --> 00:07:17,199
i have this remove algorithm in there

00:07:15,120 --> 00:07:17,599
that mr zipanov has given us among other

00:07:17,199 --> 00:07:20,479
things

00:07:17,599 --> 00:07:21,120
it's a bit of an esteem and i actually

00:07:20,479 --> 00:07:22,560
like this

00:07:21,120 --> 00:07:24,880
so remove doesn't remove anything if

00:07:22,560 --> 00:07:26,240
you're not familiar with this it moves

00:07:24,880 --> 00:07:28,800
it takes the things that you are not

00:07:26,240 --> 00:07:31,360
removing at the beginning and it returns

00:07:28,800 --> 00:07:33,039
t in this case which is the the position

00:07:31,360 --> 00:07:34,000
that's actually the an iterator to the

00:07:33,039 --> 00:07:36,400
first

00:07:34,000 --> 00:07:37,199
one that you are not keeping so from

00:07:36,400 --> 00:07:39,520
beginning to p

00:07:37,199 --> 00:07:41,120
it's what you keep so it's a good

00:07:39,520 --> 00:07:41,680
algorithm does the job if you know what

00:07:41,120 --> 00:07:43,360
you're doing

00:07:41,680 --> 00:07:45,440
you could of course use erase and other

00:07:43,360 --> 00:07:47,919
things like that

00:07:45,440 --> 00:07:49,120
and then when i'm done i keep the live

00:07:47,919 --> 00:07:51,440
ones

00:07:49,120 --> 00:07:52,560
i'm using the sequence constructor in

00:07:51,440 --> 00:07:55,599
this case that takes

00:07:52,560 --> 00:07:57,120
a pair of editors range and creates a

00:07:55,599 --> 00:08:00,400
different vector from it

00:07:57,120 --> 00:08:01,520
so supposing that my my uh my monstrous

00:08:00,400 --> 00:08:03,199
copy well

00:08:01,520 --> 00:08:05,759
this is actually pretty cute and i'm

00:08:03,199 --> 00:08:08,879
working locally so i'm working with

00:08:05,759 --> 00:08:10,160
my v pass by value maybe it's been moved

00:08:08,879 --> 00:08:12,160
into my function which would be the

00:08:10,160 --> 00:08:14,319
right thing to do probably in this case

00:08:12,160 --> 00:08:15,360
and i'm reasoning locally locally so i'm

00:08:14,319 --> 00:08:17,520
avoiding the sharing

00:08:15,360 --> 00:08:18,560
state that we had in the c sharp code i

00:08:17,520 --> 00:08:22,720
like this

00:08:18,560 --> 00:08:24,639
i like this code so if you compare both

00:08:22,720 --> 00:08:26,240
the c plus plus code is a bit longer to

00:08:24,639 --> 00:08:28,080
write but if you look at both

00:08:26,240 --> 00:08:29,599
it does it is more general it could

00:08:28,080 --> 00:08:32,399
apply to other things

00:08:29,599 --> 00:08:33,120
than just a vector it's not tied to a

00:08:32,399 --> 00:08:34,959
specific

00:08:33,120 --> 00:08:37,839
member function it's a general algorithm

00:08:34,959 --> 00:08:40,320
that works on iterators

00:08:37,839 --> 00:08:43,039
and they generalize differently see the

00:08:40,320 --> 00:08:46,240
c sharper is smaller but it's specific

00:08:43,039 --> 00:08:48,000
the c code is more general

00:08:46,240 --> 00:08:49,680
it's a bit longer to write but it's

00:08:48,000 --> 00:08:51,360
still two instructions

00:08:49,680 --> 00:08:53,120
if you look at it two instructions in

00:08:51,360 --> 00:08:56,959
both cases a call to remove if

00:08:53,120 --> 00:08:58,320
and a return in our case i like this

00:08:56,959 --> 00:09:00,160
i like this because we can build from

00:08:58,320 --> 00:09:02,000
basic principles with it we'll go back

00:09:00,160 --> 00:09:05,120
to that

00:09:02,000 --> 00:09:06,640
there there the other

00:09:05,120 --> 00:09:08,240
interesting thing in this case is that

00:09:06,640 --> 00:09:08,720
as i said we're working on iterators

00:09:08,240 --> 00:09:10,720
that's the

00:09:08,720 --> 00:09:12,080
genius of x and they're stepping off so

00:09:10,720 --> 00:09:13,279
we're not tied to vector we could be

00:09:12,080 --> 00:09:15,440
using something else

00:09:13,279 --> 00:09:16,959
there are rules of course ben has

00:09:15,440 --> 00:09:18,080
discussed this in his talk earlier this

00:09:16,959 --> 00:09:21,680
week

00:09:18,080 --> 00:09:24,880
but but yeah it's it has this

00:09:21,680 --> 00:09:26,080
nice upside so one of the things that

00:09:24,880 --> 00:09:28,000
signals does well

00:09:26,080 --> 00:09:29,600
is allow us to compose elegant and

00:09:28,000 --> 00:09:30,800
division solutions from basic sets of

00:09:29,600 --> 00:09:32,640
principles i

00:09:30,800 --> 00:09:34,240
like this it's not a case-by-case kind

00:09:32,640 --> 00:09:36,240
of language it's not

00:09:34,240 --> 00:09:39,839
at least not the the standard library in

00:09:36,240 --> 00:09:39,839
the algorithms that we love to use

00:09:40,399 --> 00:09:43,839
let's take another solution so you want

00:09:41,760 --> 00:09:44,720
to read all of the text all of the text

00:09:43,839 --> 00:09:45,839
from a text file

00:09:44,720 --> 00:09:48,160
and you want to make a big string out of

00:09:45,839 --> 00:09:49,120
this so c sharp is a simple function for

00:09:48,160 --> 00:09:51,040
that it's called

00:09:49,120 --> 00:09:53,680
really read all text it's a static

00:09:51,040 --> 00:09:55,440
static function of class file

00:09:53,680 --> 00:09:57,040
then there's no such thing as a read alt

00:09:55,440 --> 00:09:57,600
text in the c plus plus standard library

00:09:57,040 --> 00:10:00,399
of course

00:09:57,600 --> 00:10:02,399
because that's not how we do things so

00:10:00,399 --> 00:10:04,640
if you look at this c-sharp code

00:10:02,399 --> 00:10:06,480
the using static and the third lines to

00:10:04,640 --> 00:10:08,640
make the code fit in a slide

00:10:06,480 --> 00:10:10,399
it allows me not to write console that

00:10:08,640 --> 00:10:12,079
write down there so let's just

00:10:10,399 --> 00:10:13,600
read our text and i'm reading the text

00:10:12,079 --> 00:10:17,279
from a file

00:10:13,600 --> 00:10:18,880
i'm putting it on screen so it's simple

00:10:17,279 --> 00:10:20,800
but someone did this for us someone

00:10:18,880 --> 00:10:21,200
wrote this function if you want to write

00:10:20,800 --> 00:10:23,680
it in c

00:10:21,200 --> 00:10:24,560
sharp it's tricky it's not very

00:10:23,680 --> 00:10:26,640
difficult

00:10:24,560 --> 00:10:28,240
but it probably won't be the most

00:10:26,640 --> 00:10:32,000
beautiful piece of code you will have

00:10:28,240 --> 00:10:33,600
written in your life

00:10:32,000 --> 00:10:35,200
simplest fast equivalent of this i think

00:10:33,600 --> 00:10:36,720
looks like this so

00:10:35,200 --> 00:10:38,640
you might see the read alt text there

00:10:36,720 --> 00:10:41,680
takes the file name opens the file

00:10:38,640 --> 00:10:43,519
and returns well a string made from the

00:10:41,680 --> 00:10:46,399
contents of the file using against

00:10:43,519 --> 00:10:47,839
again the pair of iterators and creating

00:10:46,399 --> 00:10:49,680
something with the sequence constructor

00:10:47,839 --> 00:10:52,800
so my read all text

00:10:49,680 --> 00:10:54,800
well it's a two-liner it's cute nice

00:10:52,800 --> 00:10:57,120
and built from the same basic general

00:10:54,800 --> 00:11:00,959
principles as the return statement from

00:10:57,120 --> 00:11:03,040
the previous function

00:11:00,959 --> 00:11:05,279
that's what you're missing includes it's

00:11:03,040 --> 00:11:07,120
all there

00:11:05,279 --> 00:11:08,480
so there's no special case saying it

00:11:07,120 --> 00:11:09,680
would work under

00:11:08,480 --> 00:11:12,399
well it works with the same principles

00:11:09,680 --> 00:11:14,560
as the previous case

00:11:12,399 --> 00:11:16,000
and if you look like this i personally

00:11:14,560 --> 00:11:19,680
like this it's less flexible of course

00:11:16,000 --> 00:11:19,680
because it's a hardcoded literal but

00:11:20,240 --> 00:11:24,640
you might think it's cool you might

00:11:21,839 --> 00:11:26,720
think it's ugly i've heard both

00:11:24,640 --> 00:11:29,360
but if you look at the entire code the

00:11:26,720 --> 00:11:31,279
whole code to get this result

00:11:29,360 --> 00:11:32,800
it's a single function with a one-liner

00:11:31,279 --> 00:11:34,399
that delegates to the other function

00:11:32,800 --> 00:11:36,800
that we just wrote

00:11:34,399 --> 00:11:38,560
so we can build extremely powerful and

00:11:36,800 --> 00:11:42,240
surprising abstractions

00:11:38,560 --> 00:11:44,480
from very simple basic stuff

00:11:42,240 --> 00:11:46,399
which i like i think it's beautiful i

00:11:44,480 --> 00:11:48,880
think it's elegant that we can do this

00:11:46,399 --> 00:11:51,760
you might not want to do this that

00:11:48,880 --> 00:11:55,760
weekend is actually pretty nice

00:11:51,760 --> 00:11:57,200
yeah nothing more there

00:11:55,760 --> 00:11:58,959
so there's beauty about this there's

00:11:57,200 --> 00:11:59,920
beauty there's elegance that doesn't

00:11:58,959 --> 00:12:03,120
mean frameworks

00:11:59,920 --> 00:12:04,720
that give you a whole set of functions

00:12:03,120 --> 00:12:07,279
on a case-by-case basis

00:12:04,720 --> 00:12:08,639
are bad they allow people who don't want

00:12:07,279 --> 00:12:10,240
to get the basic principles

00:12:08,639 --> 00:12:12,240
to get along with their lives and do

00:12:10,240 --> 00:12:15,600
stuff simply

00:12:12,240 --> 00:12:17,519
but still you know so

00:12:15,600 --> 00:12:19,120
let's take another one so you you you

00:12:17,519 --> 00:12:21,200
might have seen something like this

00:12:19,120 --> 00:12:22,240
you went to david senko stock yesterday

00:12:21,200 --> 00:12:24,079
because he has

00:12:22,240 --> 00:12:25,440
essentially the same code under another

00:12:24,079 --> 00:12:28,480
name because it was talking about

00:12:25,440 --> 00:12:30,240
uh maladic programming um

00:12:28,480 --> 00:12:31,680
it wasn't the monado so you want to

00:12:30,240 --> 00:12:32,399
apply a compositional function you want

00:12:31,680 --> 00:12:36,880
to do f

00:12:32,399 --> 00:12:40,079
of g of x for some set of x's

00:12:36,880 --> 00:12:41,040
arranged so replacing the two calls to

00:12:40,079 --> 00:12:43,360
transform

00:12:41,040 --> 00:12:45,120
at the top there they're playing g and

00:12:43,360 --> 00:12:47,839
then applying f

00:12:45,120 --> 00:12:50,000
to one that does the composition of both

00:12:47,839 --> 00:12:51,440
two i have only one traversal of your

00:12:50,000 --> 00:12:53,600
sequence instead of having

00:12:51,440 --> 00:12:55,279
two you know to make it a simpler bit

00:12:53,600 --> 00:12:58,160
faster maybe

00:12:55,279 --> 00:12:59,760
and this might have some other upsides

00:12:58,160 --> 00:13:00,720
and the rv i'm mentioning is not like

00:12:59,760 --> 00:13:03,600
the transforms

00:13:00,720 --> 00:13:03,600
for some other reason

00:13:03,760 --> 00:13:07,120
and you look at this it's actually quite

00:13:05,120 --> 00:13:09,040
simple you know the with currency plus

00:13:07,120 --> 00:13:11,440
plus of course

00:13:09,040 --> 00:13:12,480
so yeah i like it a function that takes

00:13:11,440 --> 00:13:15,519
two functions

00:13:12,480 --> 00:13:18,160
creates a lambda that will take anything

00:13:15,519 --> 00:13:20,639
and pass it to g which will pass it to f

00:13:18,160 --> 00:13:22,560
and return the result

00:13:20,639 --> 00:13:24,560
it's very simple very cute we can do

00:13:22,560 --> 00:13:26,959
that without much effort in c plus plus

00:13:24,560 --> 00:13:28,079
it used to be more complicated but be

00:13:26,959 --> 00:13:30,320
careful because

00:13:28,079 --> 00:13:31,200
this is what it used to look like with c

00:13:30,320 --> 00:13:34,560
plus plus

00:13:31,200 --> 00:13:36,240
14 and before it was a bit more painful

00:13:34,560 --> 00:13:38,079
before it was plus 14.

00:13:36,240 --> 00:13:39,920
and i cheated on this one because i used

00:13:38,079 --> 00:13:42,880
auto as return type which is c plus

00:13:39,920 --> 00:13:44,079
14 but with 11 and when you had to write

00:13:42,880 --> 00:13:47,279
all the scaffolding

00:13:44,079 --> 00:13:49,760
the return type was was a pain so

00:13:47,279 --> 00:13:50,639
yeah it's a sharp it looks like what you

00:13:49,760 --> 00:13:54,000
see

00:13:50,639 --> 00:13:57,440
in the blue blue stuff down there so

00:13:54,000 --> 00:13:58,720
it's not that much more complicated or

00:13:57,440 --> 00:14:01,279
that much more simple

00:13:58,720 --> 00:14:02,160
the complexities are different a bit i'd

00:14:01,279 --> 00:14:03,760
say

00:14:02,160 --> 00:14:05,920
but you get all of the function

00:14:03,760 --> 00:14:09,120
signatures so the way to read this is

00:14:05,920 --> 00:14:10,480
g takes a t and returns a u f takes to u

00:14:09,120 --> 00:14:12,720
and returns on r

00:14:10,480 --> 00:14:13,519
so you have a general function f of g of

00:14:12,720 --> 00:14:16,320
x

00:14:13,519 --> 00:14:17,839
that will return a function that takes a

00:14:16,320 --> 00:14:20,240
t and returns an r so t

00:14:17,839 --> 00:14:22,800
to u to r the lambda n there is very

00:14:20,240 --> 00:14:25,199
simple though

00:14:22,800 --> 00:14:26,000
the calling code is not beautiful in c

00:14:25,199 --> 00:14:28,160
sharp you have to

00:14:26,000 --> 00:14:29,360
explicit the types when you call for

00:14:28,160 --> 00:14:30,399
something like this it's not able to

00:14:29,360 --> 00:14:32,480
deduce everything

00:14:30,399 --> 00:14:34,959
because it's trying to check the

00:14:32,480 --> 00:14:37,600
contracts from the counter to the kali

00:14:34,959 --> 00:14:40,160
uh at call point and it cannot do this

00:14:37,600 --> 00:14:42,480
in this case it's not able to

00:14:40,160 --> 00:14:44,000
maybe something i don't know so if you

00:14:42,480 --> 00:14:45,760
compare both

00:14:44,000 --> 00:14:47,199
i i wouldn't say that one is more

00:14:45,760 --> 00:14:50,399
complicated than the other you have

00:14:47,199 --> 00:14:53,120
things to understand in both cases

00:14:50,399 --> 00:14:55,040
when you call them both well which one

00:14:53,120 --> 00:14:56,800
is more beautiful i don't know

00:14:55,040 --> 00:14:58,639
but i do like the simplest version the

00:14:56,800 --> 00:15:01,040
way it's expressed it

00:14:58,639 --> 00:15:02,399
it makes me more comfortable enough not

00:15:01,040 --> 00:15:03,279
to have to accept the types there

00:15:02,399 --> 00:15:07,199
because they can get

00:15:03,279 --> 00:15:09,440
pretty hairy in c sometimes the types

00:15:07,199 --> 00:15:10,959
yeah and of course you can tell me well

00:15:09,440 --> 00:15:12,639
if you really want to do a good job you

00:15:10,959 --> 00:15:14,240
have to forward the stuff in there

00:15:12,639 --> 00:15:16,560
then this gets more complicated to

00:15:14,240 --> 00:15:19,680
explain to people yeah well yeah

00:15:16,560 --> 00:15:21,920
c plus it gives you control it does

00:15:19,680 --> 00:15:23,440
i like it i don't think it's a wart i

00:15:21,920 --> 00:15:26,399
think it's a feature

00:15:23,440 --> 00:15:28,240
but yeah it can be something you can

00:15:26,399 --> 00:15:30,160
take against the language or for it but

00:15:28,240 --> 00:15:31,759
i like it i like that we can control

00:15:30,160 --> 00:15:33,279
this and we're all not always taking

00:15:31,759 --> 00:15:34,720
everything by reference like in other

00:15:33,279 --> 00:15:38,160
languages because

00:15:34,720 --> 00:15:38,160
that has other problems

00:15:39,360 --> 00:15:42,880
so yeah you want to apply functions with

00:15:41,519 --> 00:15:44,399
each argument of a function

00:15:42,880 --> 00:15:46,480
this one is not for me so you have a

00:15:44,399 --> 00:15:49,440
function that takes a function

00:15:46,480 --> 00:15:51,680
and number of arguments and applies the

00:15:49,440 --> 00:15:53,360
function to each of the arguments

00:15:51,680 --> 00:15:55,360
this this wasn't from me but it's it's

00:15:53,360 --> 00:15:58,720
it's so beautiful i had to mention it

00:15:55,360 --> 00:15:59,440
it's from uh sean parent so there's a

00:15:58,720 --> 00:16:01,759
number of

00:15:59,440 --> 00:16:02,639
syntactic elements in there but look at

00:16:01,759 --> 00:16:04,320
this

00:16:02,639 --> 00:16:07,440
it's so nice oh cpp.org if you want to

00:16:04,320 --> 00:16:09,600
see it from 2015.

00:16:07,440 --> 00:16:11,680
so there's this empty lambda there that

00:16:09,600 --> 00:16:14,079
takes anything it's an ellipsis

00:16:11,680 --> 00:16:14,880
and does nothing with it it's just there

00:16:14,079 --> 00:16:18,000
to

00:16:14,880 --> 00:16:20,320
make place for a call to something

00:16:18,000 --> 00:16:23,040
and what will the arguments that lambda

00:16:20,320 --> 00:16:25,120
is being created and destroyed

00:16:23,040 --> 00:16:26,480
what will they be these arguments well

00:16:25,120 --> 00:16:29,199
which you see there

00:16:26,480 --> 00:16:30,639
so it's a fold expression over operator

00:16:29,199 --> 00:16:34,079
comma

00:16:30,639 --> 00:16:35,199
using f for each argument and the comma

00:16:34,079 --> 00:16:37,920
zero was to

00:16:35,199 --> 00:16:39,279
have a long set of integers quite simply

00:16:37,920 --> 00:16:42,000
and these integers are passed to the

00:16:39,279 --> 00:16:43,519
lambda that does nothing with it

00:16:42,000 --> 00:16:45,360
this section this whole code actually

00:16:43,519 --> 00:16:48,399
fits in the tweet

00:16:45,360 --> 00:16:50,720
so we might like we might not like

00:16:48,399 --> 00:16:51,920
but that we can express such complex

00:16:50,720 --> 00:16:54,639
ideas

00:16:51,920 --> 00:16:55,759
in such a generic way or general way

00:16:54,639 --> 00:16:57,279
makes me very happy

00:16:55,759 --> 00:16:59,120
no so yeah now is it beautiful is it

00:16:57,279 --> 00:17:03,360
clever is it both

00:16:59,120 --> 00:17:05,039
you tell me but i like that we can do it

00:17:03,360 --> 00:17:06,400
yeah and i'd like to see example a

00:17:05,039 --> 00:17:08,079
c-sharp example of this because i don't

00:17:06,400 --> 00:17:09,839
think you can express that in c-sharp if

00:17:08,079 --> 00:17:10,880
i'm mistaken right to vm i'm curious to

00:17:09,839 --> 00:17:13,600
know it's uh

00:17:10,880 --> 00:17:14,079
but very addicting c-sharp well i don't

00:17:13,600 --> 00:17:18,160
think

00:17:14,079 --> 00:17:20,880
it will do what you think it does

00:17:18,160 --> 00:17:22,480
this is my son today well today recently

00:17:20,880 --> 00:17:23,839
because the the the

00:17:22,480 --> 00:17:26,559
the cat you see in his hands is a big

00:17:23,839 --> 00:17:29,200
cat now one of the strengths

00:17:26,559 --> 00:17:30,240
of c plus plus is that it's value based

00:17:29,200 --> 00:17:32,240
i really like this

00:17:30,240 --> 00:17:33,360
i took this street from michael case uh

00:17:32,240 --> 00:17:34,799
in august

00:17:33,360 --> 00:17:36,720
who who complained about reference

00:17:34,799 --> 00:17:39,919
semantic languages

00:17:36,720 --> 00:17:42,960
i agree with him so i i like

00:17:39,919 --> 00:17:44,559
that c plus plus favors direct access

00:17:42,960 --> 00:17:46,240
over indirections you can do pointers

00:17:44,559 --> 00:17:47,039
you can do references in c plus we do

00:17:46,240 --> 00:17:49,360
that

00:17:47,039 --> 00:17:50,400
but it's opt in it's not what we by

00:17:49,360 --> 00:17:52,559
default

00:17:50,400 --> 00:17:55,600
i think the fact that we have to make an

00:17:52,559 --> 00:17:58,080
effort and add syntax to get reference

00:17:55,600 --> 00:17:59,120
semantics is a good thing i think we're

00:17:58,080 --> 00:18:01,520
doing this right

00:17:59,120 --> 00:18:02,400
it to some other people it influences

00:18:01,520 --> 00:18:04,000
the way we code

00:18:02,400 --> 00:18:05,440
because we have objects not references

00:18:04,000 --> 00:18:09,039
to objects in our code

00:18:05,440 --> 00:18:10,799
at first at least so yeah

00:18:09,039 --> 00:18:13,280
some people criticize initialization in

00:18:10,799 --> 00:18:14,559
c plus plus yes complicated there's many

00:18:13,280 --> 00:18:16,000
ways

00:18:14,559 --> 00:18:18,320
because we have values we have to take

00:18:16,000 --> 00:18:20,640
care about of constructors

00:18:18,320 --> 00:18:22,960
one where i think string s is string

00:18:20,640 --> 00:18:24,559
it's a reference to a string

00:18:22,960 --> 00:18:27,120
but other languages have their words too

00:18:24,559 --> 00:18:28,880
check it out this series of

00:18:27,120 --> 00:18:31,360
initializations did there are ways to

00:18:28,880 --> 00:18:32,480
initialize an end so x0 has an unknown

00:18:31,360 --> 00:18:36,799
value

00:18:32,480 --> 00:18:39,760
x1 2 have 0. x3 is not an

00:18:36,799 --> 00:18:41,360
initialization it's a function that's

00:18:39,760 --> 00:18:43,440
that's

00:18:41,360 --> 00:18:45,600
unfortunate but that's the way it is you

00:18:43,440 --> 00:18:49,440
know it's a function prototype

00:18:45,600 --> 00:18:52,799
x4 5 6 7 8 9

00:18:49,440 --> 00:18:54,320
they're all ins a value 0. so so there's

00:18:52,799 --> 00:18:56,080
many ways to do this and people could

00:18:54,320 --> 00:18:58,160
complain about this saying

00:18:56,080 --> 00:18:59,440
why do we need so many initialization

00:18:58,160 --> 00:19:02,160
means there might be others

00:18:59,440 --> 00:19:03,919
don't think about it with strings it's

00:19:02,160 --> 00:19:07,200
similar but slightly different

00:19:03,919 --> 00:19:09,679
we set up the function on s3 and

00:19:07,200 --> 00:19:10,320
s0 is an empty string when i wrote this

00:19:09,679 --> 00:19:12,720
with my

00:19:10,320 --> 00:19:13,600
integer i zero and didn't intentionalize

00:19:12,720 --> 00:19:16,880
it i had an

00:19:13,600 --> 00:19:19,200
uninitialized thing but the rest

00:19:16,880 --> 00:19:20,400
is mostly strings now there's a catch

00:19:19,200 --> 00:19:21,760
with s6

00:19:20,400 --> 00:19:23,760
if you look at it because there's six

00:19:21,760 --> 00:19:24,559
it's not a string it's a reference to an

00:19:23,760 --> 00:19:26,000
array of chars

00:19:24,559 --> 00:19:29,360
or if it decays in this case because

00:19:26,000 --> 00:19:31,440
there's although it's a construct star

00:19:29,360 --> 00:19:32,640
so yeah it's complicated you see well

00:19:31,440 --> 00:19:35,840
this is c sharp you say

00:19:32,640 --> 00:19:37,840
it's simpler because s0 is no

00:19:35,840 --> 00:19:39,679
i guess but it depends on the context

00:19:37,840 --> 00:19:42,400
because if you use s0 like this

00:19:39,679 --> 00:19:42,799
in a function it's not initialized and

00:19:42,400 --> 00:19:45,600
it's an

00:19:42,799 --> 00:19:47,200
error to use it but if you use it in an

00:19:45,600 --> 00:19:48,720
object that you have to create with new

00:19:47,200 --> 00:19:50,720
it will be null initialized because

00:19:48,720 --> 00:19:52,960
that's the default value

00:19:50,720 --> 00:19:53,919
so as one is now s2 is an empty string

00:19:52,960 --> 00:19:55,679
it's not now

00:19:53,919 --> 00:19:57,120
it's three well it's default but

00:19:55,679 --> 00:19:58,559
defaultness is sharp because it's a

00:19:57,120 --> 00:19:59,919
reference type it's not it's not an

00:19:58,559 --> 00:20:01,840
empty string

00:19:59,919 --> 00:20:03,440
new string parent paren doesn't compile

00:20:01,840 --> 00:20:06,720
there's no such constructor

00:20:03,440 --> 00:20:07,600
in c sharp for string but quote parent

00:20:06,720 --> 00:20:11,200
is empty string

00:20:07,600 --> 00:20:13,840
and it's equivalent to s2 in this case

00:20:11,200 --> 00:20:16,000
so there's less cases but i wouldn't say

00:20:13,840 --> 00:20:18,400
it's easy to grasp at first

00:20:16,000 --> 00:20:21,280
because there's corner cases and weird

00:20:18,400 --> 00:20:23,200
stuff to think about there

00:20:21,280 --> 00:20:25,200
this is amusing though look at it if you

00:20:23,200 --> 00:20:26,559
think we have the defaults wrong think

00:20:25,200 --> 00:20:29,520
about this

00:20:26,559 --> 00:20:31,280
here i have a null s and c sharp i do s

00:20:29,520 --> 00:20:32,159
dot length which is a property but that

00:20:31,280 --> 00:20:34,640
gives me the

00:20:32,159 --> 00:20:37,679
length of string like our size function

00:20:34,640 --> 00:20:39,600
and goes boom because it's not

00:20:37,679 --> 00:20:41,600
if you look at this you have a null and

00:20:39,600 --> 00:20:44,320
you do plus equals with something

00:20:41,600 --> 00:20:45,840
it works fine so you can do now plus

00:20:44,320 --> 00:20:47,520
equal as the string

00:20:45,840 --> 00:20:49,120
now you have to know things this is not

00:20:47,520 --> 00:20:51,440
trivial to me

00:20:49,120 --> 00:20:52,880
i don't know if it's revealed to you but

00:20:51,440 --> 00:20:53,200
what happens is that there's a rewrite

00:20:52,880 --> 00:20:54,480
see

00:20:53,200 --> 00:20:56,159
when you do plus equals it doesn't

00:20:54,480 --> 00:20:57,520
really exist because it's showing c

00:20:56,159 --> 00:21:00,960
sharp it rewrites your thing

00:20:57,520 --> 00:21:03,200
to s equals s plus u s is in

00:21:00,960 --> 00:21:04,880
a string strings are immutable in the

00:21:03,200 --> 00:21:05,919
operator that's the way it behaves when

00:21:04,880 --> 00:21:08,000
it's overloaded it

00:21:05,919 --> 00:21:10,000
rewrites your code with the operator

00:21:08,000 --> 00:21:11,120
plus it's very hard to do efficient code

00:21:10,000 --> 00:21:13,520
in that language

00:21:11,120 --> 00:21:14,159
and because the operator plus which has

00:21:13,520 --> 00:21:17,200
a string

00:21:14,159 --> 00:21:19,600
and a null string and not reference well

00:21:17,200 --> 00:21:20,880
its behavior is to give you the string

00:21:19,600 --> 00:21:23,600
that's not now

00:21:20,880 --> 00:21:25,679
well you have links to so we miss

00:21:23,600 --> 00:21:28,080
self-evident to you maybe it's not

00:21:25,679 --> 00:21:29,039
but i don't think it's trivial this one

00:21:28,080 --> 00:21:31,919
is more amusing

00:21:29,039 --> 00:21:32,880
so you have a noun plus equals a null

00:21:31,919 --> 00:21:36,000
gives you of course

00:21:32,880 --> 00:21:38,799
an empty string and then you can call

00:21:36,000 --> 00:21:42,000
length and it works

00:21:38,799 --> 00:21:42,640
that to me is icky that feels bad to me

00:21:42,000 --> 00:21:45,679
and teaching

00:21:42,640 --> 00:21:48,480
the things students do that and

00:21:45,679 --> 00:21:49,440
scratch their heads is a bit weird to me

00:21:48,480 --> 00:21:52,640
but hey

00:21:49,440 --> 00:21:54,400
to each language's own words

00:21:52,640 --> 00:21:55,919
so i think we have a senior model for

00:21:54,400 --> 00:21:57,520
initialization that people will create

00:21:55,919 --> 00:21:58,159
it for even though it has words and it's

00:21:57,520 --> 00:22:01,280
complicated

00:21:58,159 --> 00:22:03,600
i know look at this

00:22:01,280 --> 00:22:04,720
so i have this integral class that by

00:22:03,600 --> 00:22:07,200
default

00:22:04,720 --> 00:22:08,640
initializes the value data number with

00:22:07,200 --> 00:22:10,159
create value and create value i'll put

00:22:08,640 --> 00:22:12,159
something on screen right now just to

00:22:10,159 --> 00:22:13,679
show if we pass there

00:22:12,159 --> 00:22:15,919
there's the default constructor down

00:22:13,679 --> 00:22:16,320
there that that default initializes the

00:22:15,919 --> 00:22:19,280
thing

00:22:16,320 --> 00:22:20,480
in a kind of a way it calls create value

00:22:19,280 --> 00:22:22,559
and there's the uh

00:22:20,480 --> 00:22:25,520
constructor that takes an int argument

00:22:22,559 --> 00:22:28,559
that initializes value with yent

00:22:25,520 --> 00:22:32,640
well if you look at this code i0

00:22:28,559 --> 00:22:34,799
will call create value but i1 will not

00:22:32,640 --> 00:22:36,240
i think that's same if you're passing an

00:22:34,799 --> 00:22:38,080
argument to the thing

00:22:36,240 --> 00:22:40,080
you don't expect the default value to be

00:22:38,080 --> 00:22:42,559
applied you expect the

00:22:40,080 --> 00:22:44,640
value you gave why do some wasteful

00:22:42,559 --> 00:22:45,280
initialization before you construct the

00:22:44,640 --> 00:22:46,880
thing

00:22:45,280 --> 00:22:48,799
but that works because in c plus plus we

00:22:46,880 --> 00:22:51,679
have objects that references two objects

00:22:48,799 --> 00:22:54,559
it's a different world

00:22:51,679 --> 00:22:55,919
yeah this is c-sharp code again i'm not

00:22:54,559 --> 00:22:56,799
c-sharp bashing i'm talking about

00:22:55,919 --> 00:22:59,520
differences in

00:22:56,799 --> 00:23:00,880
meaning so it's similar if you look at

00:22:59,520 --> 00:23:02,720
it create value prints something on

00:23:00,880 --> 00:23:05,440
screen returns the default int

00:23:02,720 --> 00:23:05,440
which is zero

00:23:05,840 --> 00:23:10,159
the property name value it has only a

00:23:08,159 --> 00:23:12,640
get so it's not modifiable once

00:23:10,159 --> 00:23:13,360
the object is constructed and it's

00:23:12,640 --> 00:23:15,360
default

00:23:13,360 --> 00:23:16,720
initialized in a way to create value so

00:23:15,360 --> 00:23:18,159
it's going to concrete value for the

00:23:16,720 --> 00:23:20,640
initialization

00:23:18,159 --> 00:23:21,280
my default constructor the public

00:23:20,640 --> 00:23:23,520
integral

00:23:21,280 --> 00:23:25,360
that you see there with empty parents it

00:23:23,520 --> 00:23:27,679
will call create value

00:23:25,360 --> 00:23:30,320
but the integral that you see at the end

00:23:27,679 --> 00:23:33,360
the one that takes an int argument

00:23:30,320 --> 00:23:35,760
funny enough if you look at the code it

00:23:33,360 --> 00:23:39,760
will calculate value and then replace it

00:23:35,760 --> 00:23:42,000
with the parameter the argument

00:23:39,760 --> 00:23:43,760
you'll see two calls to create value now

00:23:42,000 --> 00:23:44,320
in this case it's very simple it's

00:23:43,760 --> 00:23:46,880
ringing an

00:23:44,320 --> 00:23:48,400
int with value zero we could do away

00:23:46,880 --> 00:23:49,520
with the function but the interesting

00:23:48,400 --> 00:23:51,440
thing here

00:23:49,520 --> 00:23:52,960
is that you will get the wasteful cow

00:23:51,440 --> 00:23:54,400
you don't have any choice if you put it

00:23:52,960 --> 00:23:55,919
there you gotta get there for

00:23:54,400 --> 00:23:58,400
everyone regardless of what happens

00:23:55,919 --> 00:23:58,400
afterwards

00:23:59,120 --> 00:24:02,480
so we have values by default we have to

00:24:01,440 --> 00:24:05,200
make an effort

00:24:02,480 --> 00:24:06,799
to get pointers and references and our

00:24:05,200 --> 00:24:08,400
objects they actually construct their

00:24:06,799 --> 00:24:10,240
data members because they can call their

00:24:08,400 --> 00:24:11,360
constructor they're not references to

00:24:10,240 --> 00:24:15,360
things by default

00:24:11,360 --> 00:24:16,000
their objects this is bad c plus plus

00:24:15,360 --> 00:24:17,840
code

00:24:16,000 --> 00:24:19,919
because it's default constructing the

00:24:17,840 --> 00:24:22,159
name name with the underscore at the end

00:24:19,919 --> 00:24:24,159
and then replacing it with an assignment

00:24:22,159 --> 00:24:25,679
which removes what was there and put

00:24:24,159 --> 00:24:29,039
something else instead

00:24:25,679 --> 00:24:30,799
so it's wasteful this is there c

00:24:29,039 --> 00:24:32,240
plus but we can do that in c plus plus

00:24:30,799 --> 00:24:36,320
because we have objects again

00:24:32,240 --> 00:24:36,320
and we're constructing them at first

00:24:37,200 --> 00:24:40,640
when you're using something like c sharp

00:24:38,880 --> 00:24:42,159
or java it's a different mindset so you

00:24:40,640 --> 00:24:43,840
have references

00:24:42,159 --> 00:24:45,360
your values will be zero initialized

00:24:43,840 --> 00:24:46,960
when you do new and

00:24:45,360 --> 00:24:49,520
this will give you essentially a null

00:24:46,960 --> 00:24:51,279
value when you're working with pointers

00:24:49,520 --> 00:24:53,840
so something like this if you do a new

00:24:51,279 --> 00:24:55,360
person well your name will be set to

00:24:53,840 --> 00:24:56,159
null initially even though you

00:24:55,360 --> 00:24:58,559
initialize it

00:24:56,159 --> 00:24:59,919
in the constructor systematically so you

00:24:58,559 --> 00:25:01,279
paid for the zero initialization

00:24:59,919 --> 00:25:03,600
regardless of what you're going to be

00:25:01,279 --> 00:25:05,360
doing that's how it works

00:25:03,600 --> 00:25:06,799
on the other end name equals name with

00:25:05,360 --> 00:25:08,559
the big end the small n

00:25:06,799 --> 00:25:10,159
it copies a pointer essentially because

00:25:08,559 --> 00:25:11,760
it's a reference based thing so you're

00:25:10,159 --> 00:25:13,200
not copying a string you're copying a

00:25:11,760 --> 00:25:16,640
reference to a string

00:25:13,200 --> 00:25:18,240
and strings are immutable so that's fine

00:25:16,640 --> 00:25:19,760
if you do a generate name function that

00:25:18,240 --> 00:25:21,760
does some computation

00:25:19,760 --> 00:25:22,880
and you let's quote quote by mistake

00:25:21,760 --> 00:25:23,120
because you don't realize what's going

00:25:22,880 --> 00:25:26,480
on

00:25:23,120 --> 00:25:27,840
call it on all name properties

00:25:26,480 --> 00:25:30,159
while your initialization in the

00:25:27,840 --> 00:25:31,520
constructor well it will always call

00:25:30,159 --> 00:25:32,960
generate name of course this wouldn't

00:25:31,520 --> 00:25:34,960
make sense if there wasn't a default

00:25:32,960 --> 00:25:36,640
constructor somewhere else but anyway

00:25:34,960 --> 00:25:38,880
so the point is you're always paying for

00:25:36,640 --> 00:25:38,880
this

00:25:39,360 --> 00:25:42,880
signal doesn't do this so i think

00:25:41,679 --> 00:25:47,200
there's a same

00:25:42,880 --> 00:25:49,919
model that we have another tricky thing

00:25:47,200 --> 00:25:50,480
that we get from value semantics is the

00:25:49,919 --> 00:25:52,240
way the

00:25:50,480 --> 00:25:53,840
fact that we can reason locally on code

00:25:52,240 --> 00:25:56,159
it's much harder to do that with

00:25:53,840 --> 00:25:58,480
reference based languages

00:25:56,159 --> 00:25:59,840
particularly when you have mutable state

00:25:58,480 --> 00:26:01,760
because non-immutable state

00:25:59,840 --> 00:26:03,520
it's not really a problem especially

00:26:01,760 --> 00:26:06,159
with generic code

00:26:03,520 --> 00:26:07,120
so this is some kind of smallish

00:26:06,159 --> 00:26:10,080
collection

00:26:07,120 --> 00:26:11,200
in c sharp so bag of tea is holding a

00:26:10,080 --> 00:26:13,279
list of t in there

00:26:11,200 --> 00:26:14,880
so get means it's only initialized at

00:26:13,279 --> 00:26:16,880
construction time not after that

00:26:14,880 --> 00:26:18,240
you can just read for a bit afterwards

00:26:16,880 --> 00:26:21,120
but remember list

00:26:18,240 --> 00:26:22,720
is an is a class so like a vector and

00:26:21,120 --> 00:26:24,480
you get a reference to it

00:26:22,720 --> 00:26:26,880
so when you're calling the get to the

00:26:24,480 --> 00:26:29,200
thing it's your sharing state with the

00:26:26,880 --> 00:26:29,200
others

00:26:29,840 --> 00:26:34,640
this is the c-sharp way of doing a

00:26:32,400 --> 00:26:37,279
operator bracket bracket

00:26:34,640 --> 00:26:38,320
overloading it's called a an indexer

00:26:37,279 --> 00:26:41,120
that's okay

00:26:38,320 --> 00:26:41,520
and the get again means that i can only

00:26:41,120 --> 00:26:44,400
read

00:26:41,520 --> 00:26:44,880
the values in the array i cannot write

00:26:44,400 --> 00:26:47,679
to them

00:26:44,880 --> 00:26:48,799
so it will return the nth element of

00:26:47,679 --> 00:26:52,000
contents

00:26:48,799 --> 00:26:54,320
that's okay and there's this

00:26:52,000 --> 00:26:55,840
constructor there that takes a list of t

00:26:54,320 --> 00:26:57,679
and make sure that it has

00:26:55,840 --> 00:26:58,960
uh five elements and less because i want

00:26:57,679 --> 00:27:00,640
a small bag

00:26:58,960 --> 00:27:02,320
and if it's too big and for an exception

00:27:00,640 --> 00:27:05,360
i could use a better type than just

00:27:02,320 --> 00:27:08,480
exception that would be fine

00:27:05,360 --> 00:27:10,400
there's so many bugs in this code

00:27:08,480 --> 00:27:12,960
it looks simpler until you do something

00:27:10,400 --> 00:27:12,960
real with it

00:27:13,360 --> 00:27:17,600
so this this evil function see it

00:27:15,200 --> 00:27:19,039
creates a list of five elements

00:27:17,600 --> 00:27:21,120
creates the lag with it that's totally

00:27:19,039 --> 00:27:22,720
fine it's all ants then it adds another

00:27:21,120 --> 00:27:25,440
element to the list

00:27:22,720 --> 00:27:26,240
your local list in evil which is now

00:27:25,440 --> 00:27:27,840
shared

00:27:26,240 --> 00:27:29,600
by bank because that's reference

00:27:27,840 --> 00:27:31,200
cementite's at their worst

00:27:29,600 --> 00:27:33,440
so you just broke the variant from the

00:27:31,200 --> 00:27:34,880
outside you're an attacker because

00:27:33,440 --> 00:27:36,480
you're doing something like this

00:27:34,880 --> 00:27:38,240
to defend itself against that the bag

00:27:36,480 --> 00:27:40,559
would have had to create internally

00:27:38,240 --> 00:27:41,440
manually speaking a new list and copy

00:27:40,559 --> 00:27:44,080
the elements

00:27:41,440 --> 00:27:45,600
and hoping the elements are either what

00:27:44,080 --> 00:27:48,399
they call structs

00:27:45,600 --> 00:27:49,039
value types or or that they're immutable

00:27:48,399 --> 00:27:52,080
otherwise

00:27:49,039 --> 00:27:52,080
they're still for a job

00:27:52,399 --> 00:27:56,640
this is a breaking thing so i have this

00:27:54,480 --> 00:27:58,159
bag of that takes a list

00:27:56,640 --> 00:28:00,559
with two things and there are three

00:27:58,159 --> 00:28:03,440
things in there two three five

00:28:00,559 --> 00:28:04,720
but thing is a mutable object if you you

00:28:03,440 --> 00:28:07,039
can know that if you look at

00:28:04,720 --> 00:28:07,760
thing at the top part because there's a

00:28:07,039 --> 00:28:10,880
public

00:28:07,760 --> 00:28:11,200
valve with a set so it's mutable so when

00:28:10,880 --> 00:28:14,000
i

00:28:11,200 --> 00:28:16,720
do bag at the end at the bottom bag

00:28:14,000 --> 00:28:19,360
square bracket two square bracket.val

00:28:16,720 --> 00:28:20,000
and i modify this thing i mutate the

00:28:19,360 --> 00:28:22,799
element

00:28:20,000 --> 00:28:25,120
inside my bag of things so if that

00:28:22,799 --> 00:28:27,600
wasn't something i was planning to allow

00:28:25,120 --> 00:28:28,799
i'm in trouble but that's what you get

00:28:27,600 --> 00:28:29,600
when you get reference semantics by

00:28:28,799 --> 00:28:30,880
default

00:28:29,600 --> 00:28:31,919
we get the same thing in c plus plus

00:28:30,880 --> 00:28:32,720
when we play with references and

00:28:31,919 --> 00:28:36,399
pointers

00:28:32,720 --> 00:28:36,399
it's just not the default that we get

00:28:36,799 --> 00:28:41,600
so it's it's difficult to return locally

00:28:40,080 --> 00:28:42,640
it's like you have pointers everywhere

00:28:41,600 --> 00:28:43,520
people say there's no pointers in

00:28:42,640 --> 00:28:45,600
javascript

00:28:43,520 --> 00:28:47,200
that's false there's nothing else and

00:28:45,600 --> 00:28:48,240
concurrency is more complicated because

00:28:47,200 --> 00:28:50,000
of that

00:28:48,240 --> 00:28:51,840
in modern c plus plus we tend to use

00:28:50,000 --> 00:28:52,240
different semantics but we don't we're

00:28:51,840 --> 00:28:54,559
not

00:28:52,240 --> 00:28:56,000
forced to do it we with move semantics

00:28:54,559 --> 00:28:57,200
among other things we can get more

00:28:56,000 --> 00:28:59,760
value-based reasoning

00:28:57,200 --> 00:29:01,360
it's easier in many ways even pointers

00:28:59,760 --> 00:29:03,120
are encouraged to have unique ownerships

00:29:01,360 --> 00:29:03,840
we use unique pointers more than shared

00:29:03,120 --> 00:29:06,960
stuff

00:29:03,840 --> 00:29:09,039
in general so this is the

00:29:06,960 --> 00:29:11,200
simple plus kind of equivalent of the

00:29:09,039 --> 00:29:13,520
bag but if you look at it

00:29:11,200 --> 00:29:16,559
it's it's safer because my operator

00:29:13,520 --> 00:29:18,399
square bracket it returns a copy of t

00:29:16,559 --> 00:29:19,840
and my constructor makes a copy of the

00:29:18,399 --> 00:29:22,000
values of the vectors

00:29:19,840 --> 00:29:23,039
so it's kind of the same code but

00:29:22,000 --> 00:29:24,720
without the problems

00:29:23,039 --> 00:29:26,240
and with actual encapsulation that

00:29:24,720 --> 00:29:28,320
lacked in c sharp

00:29:26,240 --> 00:29:29,360
it's it's trickier to do correct generic

00:29:28,320 --> 00:29:33,679
code in c sharp than c

00:29:29,360 --> 00:29:33,679
plus plus yeah

00:29:34,159 --> 00:29:38,080
let's talk about three functions a bit

00:29:36,000 --> 00:29:39,919
the the kid that you see there is veda

00:29:38,080 --> 00:29:42,240
and she's 13 now she's in school right

00:29:39,919 --> 00:29:43,840
now she's in high school beautiful kid

00:29:42,240 --> 00:29:46,000
so that was a few years back let's put

00:29:43,840 --> 00:29:47,200
it that way if she knows that i put it

00:29:46,000 --> 00:29:50,320
there i'm gonna

00:29:47,200 --> 00:29:52,240
hear about it later on today

00:29:50,320 --> 00:29:53,520
there was a vogue i know when i was a

00:29:52,240 --> 00:29:55,200
student there was a vogue saying

00:29:53,520 --> 00:29:56,640
everything should be in a class if maine

00:29:55,200 --> 00:29:58,000
is in a class it's a better mane or

00:29:56,640 --> 00:30:01,520
something

00:29:58,000 --> 00:30:02,799
yeah so the this

00:30:01,520 --> 00:30:04,720
the problem in this case is the same

00:30:02,799 --> 00:30:06,000
with c sharper java i'm not bashing c

00:30:04,720 --> 00:30:07,840
sharp it's interesting there's actually

00:30:06,000 --> 00:30:08,480
something cute about it so let's take

00:30:07,840 --> 00:30:10,399
this

00:30:08,480 --> 00:30:12,480
beautiful code let's put it this way

00:30:10,399 --> 00:30:15,200
there's this super math class

00:30:12,480 --> 00:30:17,120
that has a static function named square

00:30:15,200 --> 00:30:18,960
that takes a ninth and returns a square

00:30:17,120 --> 00:30:20,240
of an end code using system that met the

00:30:18,960 --> 00:30:22,320
tau

00:30:20,240 --> 00:30:24,880
and main calls this thing and does

00:30:22,320 --> 00:30:27,760
supermassive square two

00:30:24,880 --> 00:30:29,360
there's a lot of noise in the code yeah

00:30:27,760 --> 00:30:30,399
and you can ask yourself why are there

00:30:29,360 --> 00:30:32,399
classes in this case

00:30:30,399 --> 00:30:34,000
that well there's nothing related to

00:30:32,399 --> 00:30:36,559
class-based programming

00:30:34,000 --> 00:30:37,039
in there it's just functions you know

00:30:36,559 --> 00:30:39,600
but

00:30:37,039 --> 00:30:41,120
they're required originally at least but

00:30:39,600 --> 00:30:42,559
there's been efforts so now they have

00:30:41,120 --> 00:30:45,200
steady classes

00:30:42,559 --> 00:30:45,760
that you cannot instantiate and that can

00:30:45,200 --> 00:30:47,279
contain

00:30:45,760 --> 00:30:50,159
only static members they're kind of

00:30:47,279 --> 00:30:52,880
close name spaces of sorts

00:30:50,159 --> 00:30:54,080
so you can put static there and static

00:30:52,880 --> 00:30:55,360
still in your function

00:30:54,080 --> 00:30:58,960
and you're still calling supervisor

00:30:55,360 --> 00:31:01,360
square that's fine but so that's a start

00:30:58,960 --> 00:31:03,279
we haven't gained much from that but now

00:31:01,360 --> 00:31:05,440
we can do using static with c sharp

00:31:03,279 --> 00:31:07,200
so when you're doing using static you're

00:31:05,440 --> 00:31:09,600
doing shortcuts

00:31:07,200 --> 00:31:11,519
for the member function the static

00:31:09,600 --> 00:31:14,240
member functions of the static classes

00:31:11,519 --> 00:31:15,120
but only these such that you can avoid

00:31:14,240 --> 00:31:18,320
putting the name

00:31:15,120 --> 00:31:19,200
at front so if you're doing using static

00:31:18,320 --> 00:31:21,360
super math

00:31:19,200 --> 00:31:22,960
like you see there look in main you

00:31:21,360 --> 00:31:24,640
don't have to write super mass dot

00:31:22,960 --> 00:31:27,279
square you can just write square because

00:31:24,640 --> 00:31:29,120
you have using static it's a shortcut

00:31:27,279 --> 00:31:31,600
and you can continue this is cool if you

00:31:29,120 --> 00:31:33,279
use using static system.console

00:31:31,600 --> 00:31:35,480
then in main you can just do write you

00:31:33,279 --> 00:31:37,360
don't have to do console.write or

00:31:35,480 --> 00:31:40,080
system.console.right

00:31:37,360 --> 00:31:42,240
cool and if you push it further you can

00:31:40,080 --> 00:31:43,440
do using system.math

00:31:42,240 --> 00:31:45,240
and then you can just write tao in

00:31:43,440 --> 00:31:46,559
supermath instead of writing

00:31:45,240 --> 00:31:49,679
system.power

00:31:46,559 --> 00:31:52,000
or just map the tau but look at this

00:31:49,679 --> 00:31:52,000
code

00:31:53,039 --> 00:31:59,039
if we had functions we'd be done so

00:31:56,320 --> 00:32:00,399
all this work this the some of this

00:31:59,039 --> 00:32:01,840
comes from c sharp eight or nine or

00:32:00,399 --> 00:32:05,919
something

00:32:01,840 --> 00:32:08,480
all this code to get two functions

00:32:05,919 --> 00:32:09,600
i like functions sometimes functions are

00:32:08,480 --> 00:32:12,640
what you need

00:32:09,600 --> 00:32:15,360
sometimes they're the right thing

00:32:12,640 --> 00:32:17,039
so yes it looks novel but it's a lot of

00:32:15,360 --> 00:32:19,279
work to get to where we were 40 years

00:32:17,039 --> 00:32:19,279
ago

00:32:20,320 --> 00:32:24,640
the the guy forget the guy at the the

00:32:22,799 --> 00:32:25,440
back end who hasn't shaved that day but

00:32:24,640 --> 00:32:27,039
the girl

00:32:25,440 --> 00:32:28,880
in front of you is calipso she's

00:32:27,039 --> 00:32:30,799
daughter number two over four

00:32:28,880 --> 00:32:32,399
perez doctor number four the one we used

00:32:30,799 --> 00:32:33,120
earlier and the dogs that you see there

00:32:32,399 --> 00:32:36,000
are still with us

00:32:33,120 --> 00:32:36,880
if you hear dogs yelping these are the

00:32:36,000 --> 00:32:39,840
ones

00:32:36,880 --> 00:32:40,240
they're called obi-wan the brown one is

00:32:39,840 --> 00:32:42,720
not

00:32:40,240 --> 00:32:43,279
very intelligent but it's very sweet and

00:32:42,720 --> 00:32:47,360
the

00:32:43,279 --> 00:32:49,919
she's too in front is greasy

00:32:47,360 --> 00:32:51,679
i really like const i really like cons i

00:32:49,919 --> 00:32:53,519
really like cons correctness now

00:32:51,679 --> 00:32:55,120
i talked about that in my other talk the

00:32:53,519 --> 00:32:56,799
other day

00:32:55,120 --> 00:32:58,159
the fact that we can say something like

00:32:56,799 --> 00:33:00,559
this member function

00:32:58,159 --> 00:33:02,399
will leave the object unmodified when

00:33:00,559 --> 00:33:05,039
you call it it's brilliant

00:33:02,399 --> 00:33:06,559
but not everyone agrees with me see

00:33:05,039 --> 00:33:08,000
there's a big quote that i won't read

00:33:06,559 --> 00:33:10,159
for you i'm gonna tell you where it

00:33:08,000 --> 00:33:11,919
comes from though a big quote that

00:33:10,159 --> 00:33:14,480
explains why some other languages don't

00:33:11,919 --> 00:33:17,519
use const i'm going to put

00:33:14,480 --> 00:33:18,240
a part of it like bigger see it's this

00:33:17,519 --> 00:33:20,240
part says

00:33:18,240 --> 00:33:21,760
if you declare a method that takes a

00:33:20,240 --> 00:33:24,559
non-cons block

00:33:21,760 --> 00:33:25,600
you can't pass it a cons block so you're

00:33:24,559 --> 00:33:27,440
stuck

00:33:25,600 --> 00:33:29,360
you gradually need a conservation of

00:33:27,440 --> 00:33:32,559
everything that isn't a

00:33:29,360 --> 00:33:34,080
and you end up in a shadow world so so

00:33:32,559 --> 00:33:37,120
those of you who were with me yesterday

00:33:34,080 --> 00:33:40,000
you might recognize something there

00:33:37,120 --> 00:33:40,480
so there's something wrong there not

00:33:40,000 --> 00:33:44,000
against

00:33:40,480 --> 00:33:44,320
my other talk but the guy who wrote that

00:33:44,000 --> 00:33:45,840
thing

00:33:44,320 --> 00:33:47,519
he's not dumb at all he's the guy who

00:33:45,840 --> 00:33:48,960
wrote character he wrote he wrote the

00:33:47,519 --> 00:33:50,480
delphian typescript

00:33:48,960 --> 00:33:52,399
so he's a brilliant guy this is actually

00:33:50,480 --> 00:33:54,640
taken from an interview in 2004.

00:33:52,399 --> 00:33:55,919
i understand the point of view i know

00:33:54,640 --> 00:33:57,360
that's there's other reasons why you

00:33:55,919 --> 00:33:58,640
know that constant c-sharp

00:33:57,360 --> 00:34:01,760
they have comes but not in the sense

00:33:58,640 --> 00:34:04,159
that we we intend it in c

00:34:01,760 --> 00:34:07,120
but he's not it's not dumb it makes

00:34:04,159 --> 00:34:08,879
sense in the mindset that he has

00:34:07,120 --> 00:34:11,040
but but there's something cool about

00:34:08,879 --> 00:34:12,960
this and he's right in the fact that we

00:34:11,040 --> 00:34:15,440
we need ways to circumvent

00:34:12,960 --> 00:34:16,320
in some cases as we have mutable we have

00:34:15,440 --> 00:34:17,839
cons cast

00:34:16,320 --> 00:34:20,480
there's things like this that we need to

00:34:17,839 --> 00:34:22,399
be productive we can opt out locally

00:34:20,480 --> 00:34:23,919
but but it still works the fact that you

00:34:22,399 --> 00:34:25,200
can opt out of that doesn't mean it's

00:34:23,919 --> 00:34:29,200
bad

00:34:25,200 --> 00:34:30,480
it works many languages go by without

00:34:29,200 --> 00:34:33,760
constant

00:34:30,480 --> 00:34:35,440
java is final so you can make references

00:34:33,760 --> 00:34:37,119
immutable but not necessarily the

00:34:35,440 --> 00:34:39,119
referred objects you can do

00:34:37,119 --> 00:34:41,359
set values on them if you get the final

00:34:39,119 --> 00:34:43,520
reference but still it's useful

00:34:41,359 --> 00:34:45,919
c-sharp is read-only it makes again

00:34:43,520 --> 00:34:48,079
references not the referred to objects

00:34:45,919 --> 00:34:50,159
immutable but it has something

00:34:48,079 --> 00:34:51,760
and you can do const for some things too

00:34:50,159 --> 00:34:54,000
but not everything

00:34:51,760 --> 00:34:55,599
some things so constant makes sense and

00:34:54,000 --> 00:34:56,960
it's always static

00:34:55,599 --> 00:34:59,760
you don't you cannot write static you

00:34:56,960 --> 00:34:59,760
have it by default

00:35:00,240 --> 00:35:04,720
so this this is a bit of c-sharp code

00:35:02,960 --> 00:35:06,800
the integral classes you see there the

00:35:04,720 --> 00:35:08,800
point of it is that the value is mutable

00:35:06,800 --> 00:35:10,079
so you have get and set people write you

00:35:08,800 --> 00:35:12,240
like this

00:35:10,079 --> 00:35:13,200
i i'm not bitching by the way if you

00:35:12,240 --> 00:35:14,880
look at two-string

00:35:13,200 --> 00:35:16,400
with the arrow function the arrow

00:35:14,880 --> 00:35:17,280
notation for things that just have a

00:35:16,400 --> 00:35:19,359
return

00:35:17,280 --> 00:35:21,119
i i kind of like that i think with the

00:35:19,359 --> 00:35:23,760
operator dot and c plus plus we could

00:35:21,119 --> 00:35:24,160
get something that's cute like this so

00:35:23,760 --> 00:35:25,520
this

00:35:24,160 --> 00:35:26,960
this this is actually nice so you have

00:35:25,520 --> 00:35:29,280
an integral class that's mutable i

00:35:26,960 --> 00:35:29,280
couldn't

00:35:29,440 --> 00:35:33,599
i have my point class there that has

00:35:32,160 --> 00:35:37,040
read only integrals

00:35:33,599 --> 00:35:37,440
x and y and the properties big x and big

00:35:37,040 --> 00:35:41,359
y

00:35:37,440 --> 00:35:44,480
lets you access without modifying them

00:35:41,359 --> 00:35:46,400
the uh the data members let's put it the

00:35:44,480 --> 00:35:48,400
way uh x and y

00:35:46,400 --> 00:35:50,320
the point constructor creates new

00:35:48,400 --> 00:35:52,640
integrals so the point in this case

00:35:50,320 --> 00:35:54,480
to make a bad pun is to have an

00:35:52,640 --> 00:35:56,240
immutable point of source

00:35:54,480 --> 00:35:58,560
which is not achieved i can tell you

00:35:56,240 --> 00:36:00,960
that this right now

00:35:58,560 --> 00:36:02,160
the reason it's not achieved is that the

00:36:00,960 --> 00:36:05,040
x big x

00:36:02,160 --> 00:36:07,040
thing gives me access to the x small x

00:36:05,040 --> 00:36:09,040
thing which is read only

00:36:07,040 --> 00:36:11,440
but that does not prevent setting the

00:36:09,040 --> 00:36:13,839
state of this thing i just cannot really

00:36:11,440 --> 00:36:15,119
change the reference for something else

00:36:13,839 --> 00:36:15,760
so if you look at the code that you have

00:36:15,119 --> 00:36:19,040
right there

00:36:15,760 --> 00:36:22,160
i'm making a 0.23 and when do i

00:36:19,040 --> 00:36:23,520
when i do pt.x that's an immutable

00:36:22,160 --> 00:36:25,520
reference

00:36:23,520 --> 00:36:27,200
but the referred object is totally

00:36:25,520 --> 00:36:30,400
mutable and value plus plus

00:36:27,200 --> 00:36:32,720
changes the value of the point

00:36:30,400 --> 00:36:34,400
so it's difficult to do something like

00:36:32,720 --> 00:36:36,000
this at least with classes

00:36:34,400 --> 00:36:37,359
you can do it with structs sometimes

00:36:36,000 --> 00:36:37,760
because c-sharp makes a difference

00:36:37,359 --> 00:36:41,040
between

00:36:37,760 --> 00:36:43,119
classes and struts

00:36:41,040 --> 00:36:44,720
so so the the real problem in this case

00:36:43,119 --> 00:36:46,000
is that it's lacking value semantics if

00:36:44,720 --> 00:36:47,200
you're playing with classes you lose a

00:36:46,000 --> 00:36:48,800
new semantics

00:36:47,200 --> 00:36:50,880
yeah it's you're playing with pointers

00:36:48,800 --> 00:36:52,000
but people a lot of people do code like

00:36:50,880 --> 00:36:53,359
that and you don't think about it

00:36:52,000 --> 00:36:54,800
because they think they have objects in

00:36:53,359 --> 00:36:55,280
their mind but they're in their hands

00:36:54,800 --> 00:36:57,040
but

00:36:55,280 --> 00:36:58,079
you almost never have objects when

00:36:57,040 --> 00:36:59,359
you're playing with these languages you

00:36:58,079 --> 00:37:03,280
have references to objects

00:36:59,359 --> 00:37:03,280
your mindset is reference based

00:37:03,359 --> 00:37:07,680
this c plus plus version of the thing is

00:37:05,920 --> 00:37:10,720
value base so my integral

00:37:07,680 --> 00:37:12,480
has an int i don't have a set it's it's

00:37:10,720 --> 00:37:14,000
by design i want it to be mutable of

00:37:12,480 --> 00:37:16,880
sorts

00:37:14,000 --> 00:37:18,800
i have operator the operator to put it

00:37:16,880 --> 00:37:20,079
on an output stream to display it

00:37:18,800 --> 00:37:22,720
fair enough i don't think there's any

00:37:20,079 --> 00:37:24,400
big difficulty my point there is two

00:37:22,720 --> 00:37:28,079
integrals

00:37:24,400 --> 00:37:30,240
my x and y accessors of sorts return

00:37:28,079 --> 00:37:33,599
copies of the integral

00:37:30,240 --> 00:37:34,560
okay it's value-based and i cannot

00:37:33,599 --> 00:37:36,960
modify

00:37:34,560 --> 00:37:38,240
my point the way it's written in this

00:37:36,960 --> 00:37:39,760
case

00:37:38,240 --> 00:37:41,760
of course if i make an effort this is

00:37:39,760 --> 00:37:43,680
small but the point is if i want to put

00:37:41,760 --> 00:37:46,800
pointers in there if i want to make the

00:37:43,680 --> 00:37:46,800
effort of making it

00:37:46,880 --> 00:37:50,000
providing it with indirect semantics and

00:37:48,800 --> 00:37:51,200
some people do that on purpose

00:37:50,000 --> 00:37:53,440
because they think there's a way to do

00:37:51,200 --> 00:37:56,160
object-oriented programming

00:37:53,440 --> 00:37:56,880
don't ask well the constructor might

00:37:56,160 --> 00:37:58,240
leak

00:37:56,880 --> 00:38:00,000
if you don't understand why you can come

00:37:58,240 --> 00:38:02,000
and talk to me i'll tell you why

00:38:00,000 --> 00:38:04,640
i had to make it uncomparable if you

00:38:02,000 --> 00:38:06,480
look at the middle mid section of point

00:38:04,640 --> 00:38:08,240
there's two equality there because i

00:38:06,480 --> 00:38:10,640
have to if i make it

00:38:08,240 --> 00:38:12,320
uh if i make it comparable i have to

00:38:10,640 --> 00:38:14,800
write the copy constructor to copy the

00:38:12,320 --> 00:38:18,800
referred two objects and everything

00:38:14,800 --> 00:38:21,359
i put the cons but returning references

00:38:18,800 --> 00:38:22,240
x and y just make a point in this case

00:38:21,359 --> 00:38:24,960
like i'm

00:38:22,240 --> 00:38:26,880
the the functions are const but they're

00:38:24,960 --> 00:38:27,440
returning references to the pointers so

00:38:26,880 --> 00:38:29,839
i can do

00:38:27,440 --> 00:38:31,280
dirty things with them and i have to

00:38:29,839 --> 00:38:33,040
make a lot of syntactic

00:38:31,280 --> 00:38:35,920
effort to get reference semantics in c

00:38:33,040 --> 00:38:37,359
and c plus plus and pointer semantics

00:38:35,920 --> 00:38:38,800
which is good i mean if you want to do

00:38:37,359 --> 00:38:40,960
something like this it has to be painful

00:38:38,800 --> 00:38:43,760
it's not fun

00:38:40,960 --> 00:38:45,200
the natural code is value based and when

00:38:43,760 --> 00:38:46,640
i make all of this effort while i

00:38:45,200 --> 00:38:48,000
introduce problems like the one you see

00:38:46,640 --> 00:38:49,760
in the bold part

00:38:48,000 --> 00:38:52,000
the ball face part of the code it

00:38:49,760 --> 00:38:54,720
becomes mutable

00:38:52,000 --> 00:38:55,520
so yeah value based by default is a very

00:38:54,720 --> 00:38:58,079
good idea

00:38:55,520 --> 00:39:00,079
it lets you reason locally if i use a

00:38:58,079 --> 00:39:02,960
unique pointer

00:39:00,079 --> 00:39:03,760
it's still more complicated and if i do

00:39:02,960 --> 00:39:06,640
a auto

00:39:03,760 --> 00:39:08,000
ref in my x and y functions in the

00:39:06,640 --> 00:39:10,000
middle there

00:39:08,000 --> 00:39:11,920
well i'm still getting problems i can't

00:39:10,000 --> 00:39:13,200
return a copy of these things c

00:39:11,920 --> 00:39:15,440
because they're unique pointers so i

00:39:13,200 --> 00:39:16,560
have to return references if i return

00:39:15,440 --> 00:39:19,599
constrifs

00:39:16,560 --> 00:39:20,800
it might be in better state but if you

00:39:19,599 --> 00:39:23,280
look at this code there's

00:39:20,800 --> 00:39:24,800
it's less fragile than the previous

00:39:23,280 --> 00:39:29,119
version but still a lot of work

00:39:24,800 --> 00:39:31,040
value is easier in c plus

00:39:29,119 --> 00:39:32,400
and i can still do something like what

00:39:31,040 --> 00:39:34,560
using the boldface code

00:39:32,400 --> 00:39:36,240
in this case because i return references

00:39:34,560 --> 00:39:38,160
to my unique pointers

00:39:36,240 --> 00:39:39,920
and when i'm modifying the contents in

00:39:38,160 --> 00:39:42,160
there it's because i'm modifying the

00:39:39,920 --> 00:39:44,079
integral that i'm referring to not the

00:39:42,160 --> 00:39:46,400
unique pointer itself i could not call a

00:39:44,079 --> 00:39:48,640
non-cons function of the unique pointer

00:39:46,400 --> 00:39:50,000
but what's in there if it's accessible

00:39:48,640 --> 00:39:53,280
by ref i can replace it

00:39:50,000 --> 00:39:53,280
so nothing's stopping me

00:39:53,520 --> 00:39:57,200
so yeah value based by default is good

00:39:55,760 --> 00:39:58,960
because if i make it first

00:39:57,200 --> 00:40:01,920
point myself in trouble it's nice that

00:39:58,960 --> 00:40:04,079
this simple code is the good code

00:40:01,920 --> 00:40:05,599
so i love code const plays well with

00:40:04,079 --> 00:40:06,880
value semi-ticks and c plus plus is the

00:40:05,599 --> 00:40:08,560
value-based language

00:40:06,880 --> 00:40:10,240
tony then here has told me that a few

00:40:08,560 --> 00:40:11,760
times and i agree with him except that

00:40:10,240 --> 00:40:13,359
he gave this talk and i disagree with

00:40:11,760 --> 00:40:15,440
the talk

00:40:13,359 --> 00:40:16,560
so so tony had this good talk he's a

00:40:15,440 --> 00:40:18,720
very good speaker so

00:40:16,560 --> 00:40:20,720
this talk in 2019 with objects which

00:40:18,720 --> 00:40:22,720
shows values

00:40:20,720 --> 00:40:24,079
putting in front the c plus plus a value

00:40:22,720 --> 00:40:26,720
based language

00:40:24,079 --> 00:40:29,760
but and you can invite you to watch the

00:40:26,720 --> 00:40:32,160
talk it's always fun to watch tony

00:40:29,760 --> 00:40:33,760
and in there in his talk he presents

00:40:32,160 --> 00:40:36,000
objects as reference types

00:40:33,760 --> 00:40:37,680
kind of like chart and java do and

00:40:36,000 --> 00:40:39,920
distinct from values but i disagree

00:40:37,680 --> 00:40:41,680
that's my point c plus what you have by

00:40:39,920 --> 00:40:44,079
default are values you make an effort to

00:40:41,680 --> 00:40:46,240
get out of it if you really want to

00:40:44,079 --> 00:40:49,200
but still go watch the talk and he's got

00:40:46,240 --> 00:40:49,200
other good talks to me

00:40:49,599 --> 00:40:53,440
the question came yesterday matter of

00:40:51,680 --> 00:40:54,480
talk it came soon it comes off and

00:40:53,440 --> 00:40:57,119
should const be

00:40:54,480 --> 00:40:58,160
uh out instead of up in should it be the

00:40:57,119 --> 00:41:00,400
default

00:40:58,160 --> 00:41:02,000
well we're in 2020 so we have hindsight

00:41:00,400 --> 00:41:04,800
maybe it's possible

00:41:02,000 --> 00:41:05,440
russ does that it might be a good thing

00:41:04,800 --> 00:41:08,480
from the

00:41:05,440 --> 00:41:10,880
1979 perspective it's not as clear to me

00:41:08,480 --> 00:41:12,480
but this does not prevent us from doing

00:41:10,880 --> 00:41:14,800
a good job with costs

00:41:12,480 --> 00:41:15,520
we can do a good job it's useful it's

00:41:14,800 --> 00:41:18,160
not perfect

00:41:15,520 --> 00:41:18,160
it's useful

00:41:18,880 --> 00:41:22,400
this is veda again she's 13 now the cat

00:41:21,040 --> 00:41:24,160
there is minion

00:41:22,400 --> 00:41:26,240
you should see the pause of that cat it

00:41:24,160 --> 00:41:29,839
does like something like 10 toes per

00:41:26,240 --> 00:41:31,760
per um per hander per paw week with one

00:41:29,839 --> 00:41:33,119
of our oldest residents in the shelter

00:41:31,760 --> 00:41:33,760
and we kept him because it's just too

00:41:33,119 --> 00:41:37,119
cold

00:41:33,760 --> 00:41:39,520
he sleeps in the sink in the kitchen

00:41:37,119 --> 00:41:43,839
because he wants water to be dripping

00:41:39,520 --> 00:41:43,839
instead of in a bowl is a huge gap

00:41:44,240 --> 00:41:48,000
from friend is a controversial topic i

00:41:46,240 --> 00:41:49,920
heard about it a few times this week

00:41:48,000 --> 00:41:51,599
people saying i don't get this and some

00:41:49,920 --> 00:41:52,000
of you might not agree with my examples

00:41:51,599 --> 00:41:55,040
but

00:41:52,000 --> 00:41:57,839
anyway let's try this so i read

00:41:55,040 --> 00:41:59,520
in books and i heard in classes given by

00:41:57,839 --> 00:42:01,280
other people that friend is

00:41:59,520 --> 00:42:03,040
bad dangerous and breach of

00:42:01,280 --> 00:42:05,599
encapsulation which i think is

00:42:03,040 --> 00:42:07,200
is not true well used at least it

00:42:05,599 --> 00:42:09,440
enforces the encapsulation it adds

00:42:07,200 --> 00:42:11,520
something to the code

00:42:09,440 --> 00:42:13,359
so this you might as i said disagree

00:42:11,520 --> 00:42:14,319
with my example but that's fine so let's

00:42:13,359 --> 00:42:16,560
say we have a type

00:42:14,319 --> 00:42:18,640
that needs two-step initialization that

00:42:16,560 --> 00:42:19,200
exists and that that exists in real life

00:42:18,640 --> 00:42:21,040
you know

00:42:19,200 --> 00:42:22,640
a thread that you create and then start

00:42:21,040 --> 00:42:25,839
afterwards for some reason

00:42:22,640 --> 00:42:27,520
uh in some platforms you want to

00:42:25,839 --> 00:42:29,040
get a resource like a window and you

00:42:27,520 --> 00:42:31,440
have to call an init function

00:42:29,040 --> 00:42:33,119
on it afterwards there were examples in

00:42:31,440 --> 00:42:35,359
the singleton column the one that talks

00:42:33,119 --> 00:42:38,319
this morning that required that too

00:42:35,359 --> 00:42:39,760
but it wasn't explained why though so

00:42:38,319 --> 00:42:41,359
it's like this it's a two-step in a

00:42:39,760 --> 00:42:42,880
thing a very good name

00:42:41,359 --> 00:42:44,480
that has a constructor that does not

00:42:42,880 --> 00:42:45,040
finish the job for some reason we don't

00:42:44,480 --> 00:42:46,240
know

00:42:45,040 --> 00:42:48,480
and then an init function you want to

00:42:46,240 --> 00:42:51,520
call and then news of course

00:42:48,480 --> 00:42:52,880
so the main that i have the bottom part

00:42:51,520 --> 00:42:54,960
there well it creates

00:42:52,880 --> 00:42:56,480
a default to submit thing and then it

00:42:54,960 --> 00:42:59,280
calls in it and then uses

00:42:56,480 --> 00:43:01,119
as one should but of course as you know

00:42:59,280 --> 00:43:02,400
programmers they don't do as we should

00:43:01,119 --> 00:43:04,079
because they're programmers so they have

00:43:02,400 --> 00:43:05,839
their own mindset

00:43:04,079 --> 00:43:07,680
so if you leave it to program discipline

00:43:05,839 --> 00:43:09,040
you'll get what you deserve see

00:43:07,680 --> 00:43:10,720
they will do something like this they

00:43:09,040 --> 00:43:12,160
will create and use and not call it

00:43:10,720 --> 00:43:13,760
because programmers are like that they

00:43:12,160 --> 00:43:14,640
don't listen they don't read the

00:43:13,760 --> 00:43:17,760
comments that's

00:43:14,640 --> 00:43:19,359
that's what they do you know that so you

00:43:17,760 --> 00:43:20,160
look at the literature from the ancients

00:43:19,359 --> 00:43:21,520
and you say oh

00:43:20,160 --> 00:43:24,160
when you have a two-step thing you could

00:43:21,520 --> 00:43:26,319
do a factory so hey design pattern books

00:43:24,160 --> 00:43:27,760
is going to be good so you want to make

00:43:26,319 --> 00:43:30,000
sure that init follows construction

00:43:27,760 --> 00:43:32,079
because that's what you plan to do

00:43:30,000 --> 00:43:33,520
so you go there you do a two-step in a

00:43:32,079 --> 00:43:36,560
factory that creates

00:43:33,520 --> 00:43:39,200
inits and returns why not

00:43:36,560 --> 00:43:39,760
except that if you look at the code the

00:43:39,200 --> 00:43:43,280
init

00:43:39,760 --> 00:43:45,520
and constructor are still public so

00:43:43,280 --> 00:43:47,920
people could do it right like you see

00:43:45,520 --> 00:43:49,359
there and do what you asked

00:43:47,920 --> 00:43:51,200
and people could do it wrong of course

00:43:49,359 --> 00:43:52,400
because people are bad they don't listen

00:43:51,200 --> 00:43:55,839
when you give them tools and they don't

00:43:52,400 --> 00:43:58,079
listen anyway it's part of life

00:43:55,839 --> 00:43:59,280
so so so you could use trend but if you

00:43:58,079 --> 00:44:00,400
don't want to use friends you have

00:43:59,280 --> 00:44:01,359
options so if you're in a language

00:44:00,400 --> 00:44:04,640
without friends

00:44:01,359 --> 00:44:05,760
you have many options so you can use an

00:44:04,640 --> 00:44:07,280
interface

00:44:05,760 --> 00:44:08,800
the c-sharp in java way you will see

00:44:07,280 --> 00:44:10,640
normally you have an interface

00:44:08,800 --> 00:44:12,640
and you make sure that the class is only

00:44:10,640 --> 00:44:13,920
visible to the factory

00:44:12,640 --> 00:44:16,800
so something like this you have the

00:44:13,920 --> 00:44:19,040
usable interface with use

00:44:16,800 --> 00:44:20,640
that's abstract you have your two

00:44:19,040 --> 00:44:22,319
separate factory it returns a unique

00:44:20,640 --> 00:44:23,680
pointer to a usable

00:44:22,319 --> 00:44:26,079
because you don't want to expose the

00:44:23,680 --> 00:44:27,119
details and then your source file you

00:44:26,079 --> 00:44:29,839
make two-step anything

00:44:27,119 --> 00:44:30,560
some kind of usable so you deface your

00:44:29,839 --> 00:44:33,359
design a bit

00:44:30,560 --> 00:44:34,880
by adding polymorphic behavior adding a

00:44:33,359 --> 00:44:37,359
base class and stuff

00:44:34,880 --> 00:44:39,119
and your two-step factory creates and

00:44:37,359 --> 00:44:41,119
initializes the two-step anything and

00:44:39,119 --> 00:44:42,640
then returns it as a usable so that

00:44:41,119 --> 00:44:44,319
works

00:44:42,640 --> 00:44:46,960
some people consider that satisfying but

00:44:44,319 --> 00:44:46,960
there's costs

00:44:48,640 --> 00:44:52,720
you can also make 270 factory a class

00:44:51,280 --> 00:44:54,640
and make your two separate thing

00:44:52,720 --> 00:44:57,680
an inner class that we don't see it from

00:44:54,640 --> 00:45:00,480
the outside and then you still add the

00:44:57,680 --> 00:45:01,119
overhead of the interface something like

00:45:00,480 --> 00:45:04,079
this

00:45:01,119 --> 00:45:05,920
so you make it inside and then you put

00:45:04,079 --> 00:45:08,240
your code in this you could make it

00:45:05,920 --> 00:45:10,480
a you couldn't make the factory function

00:45:08,240 --> 00:45:10,480
a

00:45:10,640 --> 00:45:14,560
this code is bad because the function

00:45:13,200 --> 00:45:16,839
should have a different name from the

00:45:14,560 --> 00:45:19,040
class there's a bug in that slide

00:45:16,839 --> 00:45:20,720
anyway you can

00:45:19,040 --> 00:45:23,200
add a static member factory function to

00:45:20,720 --> 00:45:26,640
your thing too like this

00:45:23,200 --> 00:45:27,440
so you put your static function inside

00:45:26,640 --> 00:45:29,839
the two-step

00:45:27,440 --> 00:45:31,599
thing you push your constructor and unit

00:45:29,839 --> 00:45:33,599
functions to be private

00:45:31,599 --> 00:45:35,680
and you make it so people have to write

00:45:33,599 --> 00:45:37,119
two separate thing column column

00:45:35,680 --> 00:45:38,880
and then it would require another name

00:45:37,119 --> 00:45:42,319
again there's a bug in the slide create

00:45:38,880 --> 00:45:43,440
say or something but all of these

00:45:42,319 --> 00:45:44,880
solutions they have a cost

00:45:43,440 --> 00:45:46,880
you have to allocate because you end up

00:45:44,880 --> 00:45:47,839
doing a new using a unique pointer in

00:45:46,880 --> 00:45:50,720
some cases

00:45:47,839 --> 00:45:52,640
you have indirect calls um you're

00:45:50,720 --> 00:45:54,240
restructuring your class to do something

00:45:52,640 --> 00:45:56,240
different than what was planned at first

00:45:54,240 --> 00:45:58,079
it's a minor network and it's still

00:45:56,240 --> 00:45:59,440
you could also wrap here to step your

00:45:58,079 --> 00:46:01,839
thing in another class

00:45:59,440 --> 00:46:02,960
and make a wrapper that in this

00:46:01,839 --> 00:46:05,040
constructor creates

00:46:02,960 --> 00:46:06,880
and initializes and then delegate from

00:46:05,040 --> 00:46:10,319
the outside to the inside the functions

00:46:06,880 --> 00:46:10,319
there's a number of ways to solve this

00:46:10,720 --> 00:46:14,560
friend has the advantage of doing what

00:46:12,319 --> 00:46:17,359
you want not more

00:46:14,560 --> 00:46:19,119
so you can see well yes init is private

00:46:17,359 --> 00:46:21,280
the constructor is private

00:46:19,119 --> 00:46:23,200
so if you want one well call the

00:46:21,280 --> 00:46:27,599
function that's my friend

00:46:23,200 --> 00:46:30,240
and it will do the job that's it

00:46:27,599 --> 00:46:31,040
it has nice properties so yeah we can

00:46:30,240 --> 00:46:36,560
complain but

00:46:31,040 --> 00:46:36,560
it's nice property works well

00:46:37,280 --> 00:46:41,040
java has something else java is package

00:46:39,040 --> 00:46:42,640
private so if you don't write anything

00:46:41,040 --> 00:46:44,640
that's what you have

00:46:42,640 --> 00:46:46,480
it's not the same thing as private

00:46:44,640 --> 00:46:48,319
public so it's not the same rules

00:46:46,480 --> 00:46:50,079
the rules are there in fact you can look

00:46:48,319 --> 00:46:51,040
at them so with public everyone is

00:46:50,079 --> 00:46:53,920
success

00:46:51,040 --> 00:46:55,040
predicted it's you your package your

00:46:53,920 --> 00:46:57,119
subclasses so

00:46:55,040 --> 00:46:58,160
package is the module in which you are

00:46:57,119 --> 00:47:00,319
same

00:46:58,160 --> 00:47:01,839
if you do nothing it's yourself and the

00:47:00,319 --> 00:47:03,359
other classes in the same package

00:47:01,839 --> 00:47:05,200
and if it's private it's only you so

00:47:03,359 --> 00:47:06,800
that's the java way of doing things

00:47:05,200 --> 00:47:08,640
so we don't have the package concept in

00:47:06,800 --> 00:47:10,240
c plus yet with module maybe we'll have

00:47:08,640 --> 00:47:12,400
something like that

00:47:10,240 --> 00:47:14,720
c sharp has other things it has internal

00:47:12,400 --> 00:47:17,599
protected internal private protected

00:47:14,720 --> 00:47:18,319
different relations but not a friend so

00:47:17,599 --> 00:47:21,440
internal is

00:47:18,319 --> 00:47:23,920
everyone else in the same dll

00:47:21,440 --> 00:47:25,359
it's what you have by default for at

00:47:23,920 --> 00:47:27,440
least four year classes

00:47:25,359 --> 00:47:28,640
and not the internals a predicted

00:47:27,440 --> 00:47:31,440
internal means well

00:47:28,640 --> 00:47:33,440
you your child classes and the ones in

00:47:31,440 --> 00:47:35,760
the same assembly

00:47:33,440 --> 00:47:37,359
and private predicted it's you and your

00:47:35,760 --> 00:47:38,000
child classes but those in the same

00:47:37,359 --> 00:47:40,480
assembly not

00:47:38,000 --> 00:47:41,280
the other ones in the world so there's

00:47:40,480 --> 00:47:43,200
nothing that says

00:47:41,280 --> 00:47:44,800
only you and there so if you want to

00:47:43,200 --> 00:47:48,079
point fingers and say it's you and

00:47:44,800 --> 00:47:48,079
nobody else you cannot do it

00:47:48,800 --> 00:47:52,160
that's more precise but you have to be

00:47:50,400 --> 00:47:52,880
careful because you can have many

00:47:52,160 --> 00:47:54,000
friends

00:47:52,880 --> 00:47:56,319
so if you do something like this in c

00:47:54,000 --> 00:47:58,000
plus plus it works today

00:47:56,319 --> 00:47:59,440
and so in this case all of the

00:47:58,000 --> 00:48:02,000
aficionado of tea

00:47:59,440 --> 00:48:03,200
are friends of the popular that's a bit

00:48:02,000 --> 00:48:04,240
aggressive you have to know what you're

00:48:03,200 --> 00:48:04,559
doing if you're doing something like

00:48:04,240 --> 00:48:07,839
this

00:48:04,559 --> 00:48:07,839
because you see and there is private

00:48:08,640 --> 00:48:13,040
and if i'm using my own aficionado that

00:48:11,119 --> 00:48:14,240
does a fetch from a popular and returns

00:48:13,040 --> 00:48:16,160
the end there

00:48:14,240 --> 00:48:17,680
if i wanted this to be hidden well

00:48:16,160 --> 00:48:20,319
anyone can make an efficient node an

00:48:17,680 --> 00:48:22,720
efficient or void and fetch from it so

00:48:20,319 --> 00:48:24,000
yeah so if you do something like this

00:48:22,720 --> 00:48:25,119
you put up a bridge you have to know

00:48:24,000 --> 00:48:28,960
what you're doing but friend

00:48:25,119 --> 00:48:28,960
by default doesn't go that far

00:48:29,920 --> 00:48:35,040
this is amanda it's child number three

00:48:32,559 --> 00:48:36,720
of five for the third dollar

00:48:35,040 --> 00:48:38,480
there's a size twitter readers i know

00:48:36,720 --> 00:48:40,240
that time is flying so i'll try to go

00:48:38,480 --> 00:48:41,520
fast

00:48:40,240 --> 00:48:43,040
let's say you want to write your own

00:48:41,520 --> 00:48:44,240
reverse function it's something you will

00:48:43,040 --> 00:48:45,920
see in step one of this book

00:48:44,240 --> 00:48:48,559
c plus two seven star and you're using

00:48:45,920 --> 00:48:49,280
the new ranges there so it looks like

00:48:48,559 --> 00:48:50,960
this

00:48:49,280 --> 00:48:52,960
see it's a very simple algorithm yeah

00:48:50,960 --> 00:48:53,680
beginning and and while they don't cross

00:48:52,960 --> 00:48:57,280
one another

00:48:53,680 --> 00:48:59,359
you pull the ending towards you

00:48:57,280 --> 00:49:01,359
you compare them again in case something

00:48:59,359 --> 00:49:03,040
they they're crossing one another

00:49:01,359 --> 00:49:05,200
you're swapping the values then

00:49:03,040 --> 00:49:08,319
something like this very simple

00:49:05,200 --> 00:49:11,520
look at this it works with vector

00:49:08,319 --> 00:49:12,720
works with list works with deck because

00:49:11,520 --> 00:49:14,640
it's a generic algorithm

00:49:12,720 --> 00:49:16,319
algorithm based on iterators it's the

00:49:14,640 --> 00:49:19,839
same function

00:49:16,319 --> 00:49:22,240
adapting itself to what we pass it

00:49:19,839 --> 00:49:22,880
as long as it's uh reverse iterators not

00:49:22,240 --> 00:49:25,440
reversed but

00:49:22,880 --> 00:49:27,200
the directional iterators that you have

00:49:25,440 --> 00:49:28,079
so it's essentially independent of the

00:49:27,200 --> 00:49:32,400
container

00:49:28,079 --> 00:49:34,559
it has expectations but it's limited

00:49:32,400 --> 00:49:35,520
if you want to do this with c-sharp and

00:49:34,559 --> 00:49:38,880
you want to do something

00:49:35,520 --> 00:49:40,400
general you start say okay i have an

00:49:38,880 --> 00:49:41,920
innumerable because that's the way it

00:49:40,400 --> 00:49:43,200
works that has an interface for

00:49:41,920 --> 00:49:46,880
something that you can

00:49:43,200 --> 00:49:48,559
go through with for reach and then you

00:49:46,880 --> 00:49:50,559
look at the documentation well you say

00:49:48,559 --> 00:49:53,040
with an innumerable i can get an

00:49:50,559 --> 00:49:55,200
enumerator

00:49:53,040 --> 00:49:56,640
and from that i can from there i can

00:49:55,200 --> 00:49:58,640
move next i can look at the current

00:49:56,640 --> 00:49:59,440
value and i can go back to the beginning

00:49:58,640 --> 00:50:03,440
but there's

00:49:59,440 --> 00:50:05,839
there's no end there's no end

00:50:03,440 --> 00:50:06,960
so well you can model easily in infinite

00:50:05,839 --> 00:50:08,960
sequence but

00:50:06,960 --> 00:50:11,440
writing reverse is a lot trickier than

00:50:08,960 --> 00:50:13,280
it looks it requires

00:50:11,440 --> 00:50:14,960
additional stake so you have to allocate

00:50:13,280 --> 00:50:16,800
and stuff

00:50:14,960 --> 00:50:18,720
so it's it's it's difficult to write

00:50:16,800 --> 00:50:20,640
properly at least

00:50:18,720 --> 00:50:22,000
you can you can add functions there's

00:50:20,640 --> 00:50:24,720
something called system.link

00:50:22,000 --> 00:50:26,240
that adds uh methods from the outside

00:50:24,720 --> 00:50:28,319
extension methods and there's

00:50:26,240 --> 00:50:29,280
case-by-case implementations and virtual

00:50:28,319 --> 00:50:31,280
calls in there

00:50:29,280 --> 00:50:33,440
so you can do it but it's a very

00:50:31,280 --> 00:50:35,680
different philosophy

00:50:33,440 --> 00:50:37,599
so there's elegance to iterators we can

00:50:35,680 --> 00:50:40,800
express general algorithms

00:50:37,599 --> 00:50:42,880
i mean many of us love this thing and

00:50:40,800 --> 00:50:46,160
you're not imposing yourself additional

00:50:42,880 --> 00:50:48,000
calls for virtual functions and such

00:50:46,160 --> 00:50:49,440
if you want to make a list event from an

00:50:48,000 --> 00:50:51,760
int array in c

00:50:49,440 --> 00:50:53,599
sharp well it's evident you call two

00:50:51,760 --> 00:50:55,599
array.two

00:50:53,599 --> 00:50:57,280
there's a specific function to get the

00:50:55,599 --> 00:50:58,480
list from an array it's written like

00:50:57,280 --> 00:51:01,359
this

00:50:58,480 --> 00:51:04,559
and if you want to get a list from an

00:51:01,359 --> 00:51:06,960
array from that list you go to array

00:51:04,559 --> 00:51:08,319
it's a case-by-case thing and it works

00:51:06,960 --> 00:51:09,760
and it's discoverable

00:51:08,319 --> 00:51:12,480
and that's totally fine it's a

00:51:09,760 --> 00:51:12,480
philosophy

00:51:12,800 --> 00:51:16,160
if you use link you you are going to

00:51:14,400 --> 00:51:19,680
have other functions like this

00:51:16,160 --> 00:51:21,760
there's a set if you want to make a

00:51:19,680 --> 00:51:24,800
vector event from an entering c plus

00:51:21,760 --> 00:51:27,359
well you call begin and end

00:51:24,800 --> 00:51:29,040
and use the range constructor like this

00:51:27,359 --> 00:51:30,640
if you want to make a list from the

00:51:29,040 --> 00:51:31,920
vector from the array well you do the

00:51:30,640 --> 00:51:35,760
same thing

00:51:31,920 --> 00:51:37,280
as general yes

00:51:35,760 --> 00:51:40,480
you're not on the case-by-case thing but

00:51:37,280 --> 00:51:43,200
you have to learn things at first though

00:51:40,480 --> 00:51:44,319
it's elegant and you have to write only

00:51:43,200 --> 00:51:46,480
one per container

00:51:44,319 --> 00:51:47,520
not one per type of thing you might want

00:51:46,480 --> 00:51:50,720
one day to go

00:51:47,520 --> 00:51:52,960
two or two to convert to that's kind of

00:51:50,720 --> 00:51:52,960
neat

00:51:55,119 --> 00:51:59,040
i'll let you figure out what this is but

00:51:57,599 --> 00:52:02,079
there's a shoe like that in my house

00:51:59,040 --> 00:52:03,359
from day to day i really like varieties

00:52:02,079 --> 00:52:05,839
these are really missed when i go to

00:52:03,359 --> 00:52:07,280
other languages

00:52:05,839 --> 00:52:08,800
so we want to serialize a series of

00:52:07,280 --> 00:52:10,559
objects with standard output we want to

00:52:08,800 --> 00:52:13,359
take objection from them to a stream

00:52:10,559 --> 00:52:14,079
and make it quick this is a java code

00:52:13,359 --> 00:52:15,599
you see

00:52:14,079 --> 00:52:17,599
that thing we have that in c plus plus 2

00:52:15,599 --> 00:52:19,520
but there's a different meaning

00:52:17,599 --> 00:52:21,680
so in java and when you do dot dot it

00:52:19,520 --> 00:52:22,079
will synthesize an array at the call

00:52:21,680 --> 00:52:24,319
site

00:52:22,079 --> 00:52:26,559
so you have to have objects of the same

00:52:24,319 --> 00:52:27,359
type now if you look at the example call

00:52:26,559 --> 00:52:30,160
the print

00:52:27,359 --> 00:52:30,880
at the bottom of the page you see well i

00:52:30,160 --> 00:52:34,480
have an

00:52:30,880 --> 00:52:36,319
edible e string and an x

00:52:34,480 --> 00:52:37,520
it will work because everything is an

00:52:36,319 --> 00:52:39,280
object in c and java

00:52:37,520 --> 00:52:41,040
and object has two string which is

00:52:39,280 --> 00:52:43,200
called by print

00:52:41,040 --> 00:52:44,480
so this thing makes me an array of

00:52:43,200 --> 00:52:46,319
object

00:52:44,480 --> 00:52:48,880
so it's allocating an array the size is

00:52:46,319 --> 00:52:52,000
determined by the call site

00:52:48,880 --> 00:52:53,520
it's it's actually neat it's cool

00:52:52,000 --> 00:52:55,119
so when you're you're paying for a few

00:52:53,520 --> 00:52:57,040
things there because intendable are not

00:52:55,119 --> 00:52:57,520
classes so there's boxing which creates

00:52:57,040 --> 00:53:00,640
class

00:52:57,520 --> 00:53:02,880
objects in there but anyway it works

00:53:00,640 --> 00:53:03,920
c sharp is similar the params thing

00:53:02,880 --> 00:53:06,079
there with the array

00:53:03,920 --> 00:53:08,000
it creates an array at the call site but

00:53:06,079 --> 00:53:09,119
it's an array so objects have to be all

00:53:08,000 --> 00:53:12,319
the same type

00:53:09,119 --> 00:53:14,079
see that's the way it works so so that's

00:53:12,319 --> 00:53:15,359
it's you you get simplicity but you pay

00:53:14,079 --> 00:53:17,839
for something

00:53:15,359 --> 00:53:19,200
and again objects in c sharp have to

00:53:17,839 --> 00:53:21,760
string so you can tell to string on them

00:53:19,200 --> 00:53:24,319
with the for each thing

00:53:21,760 --> 00:53:25,119
same principle c plus plus version might

00:53:24,319 --> 00:53:26,319
be harder to

00:53:25,119 --> 00:53:28,480
understand i know this one is not the

00:53:26,319 --> 00:53:31,440
perfect version it's simple

00:53:28,480 --> 00:53:33,040
but it takes any number of arguments of

00:53:31,440 --> 00:53:34,559
any type

00:53:33,040 --> 00:53:36,960
and doesn't create an array it just

00:53:34,559 --> 00:53:38,960
prints them it's naive

00:53:36,960 --> 00:53:41,599
but it's still cute no conversion to

00:53:38,960 --> 00:53:45,119
string no synthesizing an array

00:53:41,599 --> 00:53:45,680
simple it's harder to write i know when

00:53:45,119 --> 00:53:47,520
i

00:53:45,680 --> 00:53:49,359
show this to people who are not using

00:53:47,520 --> 00:53:51,200
plus the wins

00:53:49,359 --> 00:53:52,640
but the point is is very easy to use

00:53:51,200 --> 00:53:56,480
though that's that's the good thing and

00:53:52,640 --> 00:53:57,839
there's no real cost

00:53:56,480 --> 00:53:59,760
and with full expressions it's even

00:53:57,839 --> 00:54:00,640
cooler but that has to be explained to

00:53:59,760 --> 00:54:04,319
those who aren't

00:54:00,640 --> 00:54:05,920
used with pretty nuts so i like it i

00:54:04,319 --> 00:54:09,520
like the way that we can express things

00:54:05,920 --> 00:54:09,520
like this without incurring the costs

00:54:10,000 --> 00:54:13,280
yeah of course

00:54:13,440 --> 00:54:17,040
so their part to me at least what makes

00:54:15,599 --> 00:54:18,000
the language beautiful it's not an

00:54:17,040 --> 00:54:19,520
obvious syntax

00:54:18,000 --> 00:54:21,839
you have to get used to it but it makes

00:54:19,520 --> 00:54:24,000
you expressive

00:54:21,839 --> 00:54:25,200
this function is totally useless it's my

00:54:24,000 --> 00:54:26,559
last one the talk

00:54:25,200 --> 00:54:27,839
it's totally useless but it's fun

00:54:26,559 --> 00:54:28,319
because it shows what you can do you

00:54:27,839 --> 00:54:29,599
know

00:54:28,319 --> 00:54:31,680
things you can do not everything of

00:54:29,599 --> 00:54:35,040
course so it's a function that takes

00:54:31,680 --> 00:54:36,400
any number of integers as template

00:54:35,040 --> 00:54:39,359
parameters

00:54:36,400 --> 00:54:41,119
i could put auto instead of it but this

00:54:39,359 --> 00:54:42,480
is what i want

00:54:41,119 --> 00:54:44,880
you could make an array of the proper

00:54:42,480 --> 00:54:46,480
size so this is a compiled time size

00:54:44,880 --> 00:54:48,079
because the number of hints is known

00:54:46,480 --> 00:54:50,319
when i compound my code so it's totally

00:54:48,079 --> 00:54:50,319
fine

00:54:50,799 --> 00:54:54,640
i can initialize the array with the

00:54:52,160 --> 00:54:57,680
values i could make it constant for

00:54:54,640 --> 00:54:58,400
if i felt like it i don't even need to

00:54:57,680 --> 00:55:00,480
put the size of

00:54:58,400 --> 00:55:01,440
dot dot anymore because the values are

00:55:00,480 --> 00:55:04,799
in a

00:55:01,440 --> 00:55:06,240
compile time known number anyway i can

00:55:04,799 --> 00:55:07,680
of course iterate through the array and

00:55:06,240 --> 00:55:09,839
print stuff this is why my function is

00:55:07,680 --> 00:55:12,720
not on sexpert because i'm printing

00:55:09,839 --> 00:55:14,160
so that's okay or i can just iterate on

00:55:12,720 --> 00:55:16,640
an initializer list

00:55:14,160 --> 00:55:17,440
made of the values and that works too

00:55:16,640 --> 00:55:18,640
because i'm sure

00:55:17,440 --> 00:55:21,280
i'll initialize your lists at the

00:55:18,640 --> 00:55:22,640
beginning and general

00:55:21,280 --> 00:55:24,319
and if i want to return the sum of the

00:55:22,640 --> 00:55:26,319
values well i

00:55:24,319 --> 00:55:27,839
compute the sum of the value if i remove

00:55:26,319 --> 00:55:29,440
the cs from there it's second second

00:55:27,839 --> 00:55:30,640
function

00:55:29,440 --> 00:55:32,640
the fact that we can express these

00:55:30,640 --> 00:55:33,359
things in c plus plus so simply makes me

00:55:32,640 --> 00:55:34,640
so happy

00:55:33,359 --> 00:55:37,839
and when i move to other languages i

00:55:34,640 --> 00:55:37,839
listen so much

00:55:39,359 --> 00:55:42,799
so a few words about fun and we're done

00:55:41,040 --> 00:55:44,640
the tall girl at the

00:55:42,799 --> 00:55:46,720
left hand is marguerite it's child

00:55:44,640 --> 00:55:49,839
number one and the other two are in

00:55:46,720 --> 00:55:49,839
order child number four and five

00:55:50,559 --> 00:55:54,160
i like programming i really like

00:55:52,880 --> 00:55:55,119
programming i miss programming when i'm

00:55:54,160 --> 00:55:56,960
not doing it

00:55:55,119 --> 00:55:58,480
i'm reading papers a lot these days and

00:55:56,960 --> 00:56:00,559
programming a lot less

00:55:58,480 --> 00:56:03,599
the the problem solving the action the

00:56:00,559 --> 00:56:05,280
act of doing this i love it

00:56:03,599 --> 00:56:07,200
i love building solutions from

00:56:05,280 --> 00:56:08,960
principles i love using and writing

00:56:07,200 --> 00:56:10,079
algorithms i love concealing containers

00:56:08,960 --> 00:56:11,760
i like doing that

00:56:10,079 --> 00:56:13,920
i'm not against libraries don't worry

00:56:11,760 --> 00:56:14,839
about it but i love it i love it's an

00:56:13,920 --> 00:56:18,880
action that i

00:56:14,839 --> 00:56:21,280
appreciate i like that

00:56:18,880 --> 00:56:23,040
at the top part there's a specialized

00:56:21,280 --> 00:56:25,520
thing at the bottom part there's a

00:56:23,040 --> 00:56:27,839
generalized thing

00:56:25,520 --> 00:56:28,720
with all lines same thing it's not much

00:56:27,839 --> 00:56:30,960
more difficult

00:56:28,720 --> 00:56:32,240
let's exactly the same thing though i

00:56:30,960 --> 00:56:32,960
would have to make it a bit different

00:56:32,240 --> 00:56:37,040
but

00:56:32,960 --> 00:56:37,440
it's a similar idea i like that when i

00:56:37,040 --> 00:56:40,480
make

00:56:37,440 --> 00:56:42,240
i want to make a list to a rate

00:56:40,480 --> 00:56:43,920
list up there there's a specialized

00:56:42,240 --> 00:56:46,240
function at the bottom there's something

00:56:43,920 --> 00:56:47,839
in general

00:56:46,240 --> 00:56:49,520
i like that if i want to convert to any

00:56:47,839 --> 00:56:50,799
container i can still do it with the

00:56:49,520 --> 00:56:53,359
same syntax

00:56:50,799 --> 00:56:56,720
in c plus and it's not something that

00:56:53,359 --> 00:56:56,720
makes sense in some other languages

00:56:57,520 --> 00:57:00,880
so there's something to learn but

00:56:59,200 --> 00:57:04,720
there's a reward

00:57:00,880 --> 00:57:04,720
and that word is in part fun

00:57:05,440 --> 00:57:13,839
there we go i hope you enjoyed

00:57:27,680 --> 00:57:29,760

YouTube URL: https://www.youtube.com/watch?v=bMSrNBcir4Y


