Title: Structure and Interpretation of Computer Programs: SICP - Conor Hoekstra - CppCon 2020
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020/blob/main/Presentations/structure_and_interpretation_of_computer_programs/structure_and_interpretation_of_computer_programs__conor_hoekstra__cppcon_2020.pdf
---
This talk will summarise what can be learned from the infamous MIT textbook the Structure and Interpretation of Computer Programs, the book that some engineers have referred to as their "bible." Concepts that are taught in the book will be shown in modern C++ (as opposed to Scheme or a LISP dialect that is used in the textbook). Some of the concepts include: functions, higher order functions, abstract data representations, concurrency & streams and metalinguistic abstraction.

This is the first book that the The Programming Languages Virtual Meetup (PLVM) worked their way through. The PLVM had their first meeting in May 2020 and have been working their way through the book since then.

Link to free copy of SICP: https://web.mit.edu/alexmv/6.037/sicp.pdf)
Link to PLVM: https://www.meetup.com/Programming-Languages-Toronto-Meetup

---
Conor is a Senior Library Software Engineer at NVIDIA working on the RAPIDS team. He is extremely passionate about programming languages, algorithms and beautiful code. He is the founder and organizer of the Programming Languages Virtual Meetup and he has a YouTube channel.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:09,200 --> 00:00:14,320
how's it going everybody

00:00:10,880 --> 00:00:17,440
welcome to my cppcon 2020 talk

00:00:14,320 --> 00:00:18,960
entitled structure and interpretation of

00:00:17,440 --> 00:00:21,119
computer programs

00:00:18,960 --> 00:00:22,320
otherwise known as sickbee my name is

00:00:21,119 --> 00:00:24,800
connor hoekstra

00:00:22,320 --> 00:00:26,800
and i go by code underscore report

00:00:24,800 --> 00:00:30,000
online thanks for tuning in

00:00:26,800 --> 00:00:32,880
on the last day of cppcon

00:00:30,000 --> 00:00:33,760
2020 i hope you guys have enjoyed the

00:00:32,880 --> 00:00:36,960
conference

00:00:33,760 --> 00:00:39,120
just as much as i have

00:00:36,960 --> 00:00:40,719
so all of these slides and the code

00:00:39,120 --> 00:00:43,760
examples for this talk

00:00:40,719 --> 00:00:44,000
are posted on my github page you can

00:00:43,760 --> 00:00:45,360
follow

00:00:44,000 --> 00:00:47,600
these links if you'd like to check them

00:00:45,360 --> 00:00:49,440
out and there will also be

00:00:47,600 --> 00:00:51,120
links provided at the end of the talk

00:00:49,440 --> 00:00:53,760
for other resources

00:00:51,120 --> 00:00:55,520
so a little bit about me i'm a senior

00:00:53,760 --> 00:00:58,640
library software engineer for

00:00:55,520 --> 00:00:59,520
nvidia i work on the rapids ai team

00:00:58,640 --> 00:01:02,239
where we focus

00:00:59,520 --> 00:01:04,559
on uh building a end-to-end data science

00:01:02,239 --> 00:01:06,240
like uh pipeline on the gpu

00:01:04,559 --> 00:01:08,159
um if you want to know more check us out

00:01:06,240 --> 00:01:10,560
at rapids.ai and nvidia

00:01:08,159 --> 00:01:12,720
is always looking for top talent uh

00:01:10,560 --> 00:01:14,159
there are a few open positions on the

00:01:12,720 --> 00:01:14,799
rapids team right now so if you're

00:01:14,159 --> 00:01:17,240
interested

00:01:14,799 --> 00:01:18,640
in checking that out go to

00:01:17,240 --> 00:01:20,720
careers.nvidia.com

00:01:18,640 --> 00:01:22,159
and punch in rapids and you'll see the

00:01:20,720 --> 00:01:24,560
open positions

00:01:22,159 --> 00:01:26,080
i am a pro programming language

00:01:24,560 --> 00:01:28,560
enthusiast

00:01:26,080 --> 00:01:29,840
i primarily code in c plus but i love

00:01:28,560 --> 00:01:32,400
all programming languages

00:01:29,840 --> 00:01:33,200
and am typically learning a number of

00:01:32,400 --> 00:01:36,320
languages

00:01:33,200 --> 00:01:37,200
at any given time i love algorithms and

00:01:36,320 --> 00:01:38,560
beautiful code

00:01:37,200 --> 00:01:40,479
be sure to check out my other talks if

00:01:38,560 --> 00:01:42,399
you haven't seen them already i'm the

00:01:40,479 --> 00:01:43,520
organizer of the programming languages

00:01:42,399 --> 00:01:45,200
virtual meetup

00:01:43,520 --> 00:01:46,799
which i'll say a little bit about in a

00:01:45,200 --> 00:01:48,640
couple seconds and

00:01:46,799 --> 00:01:50,880
i have a youtube channel which primarily

00:01:48,640 --> 00:01:53,360
focused uh for the first two years on

00:01:50,880 --> 00:01:56,000
solving competitive programming problems

00:01:53,360 --> 00:01:58,000
in a variety of languages but more

00:01:56,000 --> 00:02:00,079
recently

00:01:58,000 --> 00:02:01,280
it has been the place where i upload the

00:02:00,079 --> 00:02:04,719
pre-recordings

00:02:01,280 --> 00:02:06,880
of the meetup that happens every monday

00:02:04,719 --> 00:02:08,000
at 8pm eastern standard time because

00:02:06,880 --> 00:02:09,440
obviously that is not a very

00:02:08,000 --> 00:02:11,039
convenient time for people in different

00:02:09,440 --> 00:02:12,319
parts of the world so uh

00:02:11,039 --> 00:02:14,800
as i'm trying to be as inclusive and

00:02:12,319 --> 00:02:16,640
possible uh i post these pre-recordings

00:02:14,800 --> 00:02:18,080
for those that that time zone and time

00:02:16,640 --> 00:02:19,520
doesn't work out they can watch them

00:02:18,080 --> 00:02:22,560
online

00:02:19,520 --> 00:02:24,959
so this talk is all about the structure

00:02:22,560 --> 00:02:26,319
and interpretation of computer programs

00:02:24,959 --> 00:02:27,920
i'm going to break it up into sort of

00:02:26,319 --> 00:02:29,200
three sections the first section we're

00:02:27,920 --> 00:02:29,760
going to take a look at what people have

00:02:29,200 --> 00:02:31,760
to say

00:02:29,760 --> 00:02:33,120
about the structure and interpretation

00:02:31,760 --> 00:02:34,879
of computer programs

00:02:33,120 --> 00:02:36,480
the second is going to be some high

00:02:34,879 --> 00:02:37,920
level highlights of things you can

00:02:36,480 --> 00:02:39,280
expect to learn and see

00:02:37,920 --> 00:02:40,480
in the book or at least in the first

00:02:39,280 --> 00:02:41,200
sort of three or four chapters of the

00:02:40,480 --> 00:02:43,120
book

00:02:41,200 --> 00:02:44,800
and then in the third section we are

00:02:43,120 --> 00:02:46,239
going to look at four problems

00:02:44,800 --> 00:02:47,920
from the book and we're going to solve

00:02:46,239 --> 00:02:48,959
them in c plus

00:02:47,920 --> 00:02:51,200
um and then they'll be a short

00:02:48,959 --> 00:02:53,599
conclusion at the end note that this uh

00:02:51,200 --> 00:02:55,040
talk is not supposed to be a

00:02:53,599 --> 00:02:57,440
comprehensive summary

00:02:55,040 --> 00:02:58,480
um i have had to cut a lot out of this

00:02:57,440 --> 00:03:00,400
talk i

00:02:58,480 --> 00:03:01,519
uh my in my first couple practice runs

00:03:00,400 --> 00:03:04,239
this talk went

00:03:01,519 --> 00:03:06,239
way way longer than an hour so a lot of

00:03:04,239 --> 00:03:08,720
it has been carved out

00:03:06,239 --> 00:03:11,280
and this is sort of the sick pitoc light

00:03:08,720 --> 00:03:14,080
that i had originally envisioned

00:03:11,280 --> 00:03:15,760
but nonetheless i still hope it is going

00:03:14,080 --> 00:03:17,840
to be a great

00:03:15,760 --> 00:03:18,800
sort of taster if you will for what you

00:03:17,840 --> 00:03:22,720
can expect to see

00:03:18,800 --> 00:03:24,879
in sick p as it is an amazing textbook

00:03:22,720 --> 00:03:27,120
so reviews for the structure and

00:03:24,879 --> 00:03:29,120
interpretation of computer programs

00:03:27,120 --> 00:03:30,799
if you saw my lightning talk on tuesday

00:03:29,120 --> 00:03:32,879
you will have already seen this quote

00:03:30,799 --> 00:03:35,200
from brian harvey who was a professor or

00:03:32,879 --> 00:03:38,560
was a professor at the

00:03:35,200 --> 00:03:40,000
uc berkeley where he said the it is the

00:03:38,560 --> 00:03:41,360
best computer science book

00:03:40,000 --> 00:03:43,200
in the world and he taught an

00:03:41,360 --> 00:03:45,120
introductory course there for over 25

00:03:43,200 --> 00:03:47,360
years 61a

00:03:45,120 --> 00:03:49,200
where all of the lectures are now online

00:03:47,360 --> 00:03:50,959
uh for free

00:03:49,200 --> 00:03:53,280
the next quote we have is from peter

00:03:50,959 --> 00:03:54,159
norvig who is the author of one of the

00:03:53,280 --> 00:03:56,159
most well-known

00:03:54,159 --> 00:03:58,159
textbooks on artificial intelligence and

00:03:56,159 --> 00:04:00,720
he said probably the best introduction

00:03:58,159 --> 00:04:02,799
to computer science

00:04:00,720 --> 00:04:04,480
moving on to paul graham the founder of

00:04:02,799 --> 00:04:05,439
hacker news and the co-founder of y

00:04:04,480 --> 00:04:07,920
combinator

00:04:05,439 --> 00:04:10,319
he said one of the great classics of

00:04:07,920 --> 00:04:12,319
computer science

00:04:10,319 --> 00:04:14,799
adam tornhill said simply the best

00:04:12,319 --> 00:04:16,560
programming book i've ever read

00:04:14,799 --> 00:04:18,160
it changed the way i approach

00:04:16,560 --> 00:04:21,840
programming

00:04:18,160 --> 00:04:24,240
and last but not least amazing startling

00:04:21,840 --> 00:04:26,160
it has become a kind of bible for me and

00:04:24,240 --> 00:04:28,160
this is from the first episode of one of

00:04:26,160 --> 00:04:30,160
my favorite podcasts

00:04:28,160 --> 00:04:31,360
functional geekery i highly recommend if

00:04:30,160 --> 00:04:32,000
you are interested in programming

00:04:31,360 --> 00:04:33,680
languages

00:04:32,000 --> 00:04:35,120
or in functional programming you check

00:04:33,680 --> 00:04:37,919
this uh

00:04:35,120 --> 00:04:39,919
podcast out and this was actually at

00:04:37,919 --> 00:04:42,560
least from what i can call recall the

00:04:39,919 --> 00:04:44,720
first time i heard of the structure and

00:04:42,560 --> 00:04:46,639
interpretation of computer programs

00:04:44,720 --> 00:04:48,160
the first 15 minutes of this inaugural

00:04:46,639 --> 00:04:50,720
episode of the podcast

00:04:48,160 --> 00:04:52,479
is spent on explaining why this book is

00:04:50,720 --> 00:04:54,479
so fantastic

00:04:52,479 --> 00:04:55,600
and why everybody should read it so i

00:04:54,479 --> 00:04:58,320
highly encourage you go

00:04:55,600 --> 00:05:00,000
check that podcast out the second time

00:04:58,320 --> 00:05:02,320
at least that i can recall

00:05:00,000 --> 00:05:04,000
that i heard about sick p was in

00:05:02,320 --> 00:05:06,720
november of 2018

00:05:04,000 --> 00:05:08,080
at the silicon valley bay area python

00:05:06,720 --> 00:05:10,320
user group

00:05:08,080 --> 00:05:12,479
which is hosted at linkedin headquarters

00:05:10,320 --> 00:05:15,120
uh there was a presentation being given

00:05:12,479 --> 00:05:15,600
and the individual presenting posted

00:05:15,120 --> 00:05:18,479
five

00:05:15,600 --> 00:05:19,919
uh great books that um they thought they

00:05:18,479 --> 00:05:21,199
they thought everyone should read

00:05:19,919 --> 00:05:23,440
and you'll note that second from the

00:05:21,199 --> 00:05:24,320
right is uh the structure and

00:05:23,440 --> 00:05:26,240
interpretation

00:05:24,320 --> 00:05:28,080
of computer programs and note that the

00:05:26,240 --> 00:05:31,199
book right to its right

00:05:28,080 --> 00:05:31,759
um is what is or at least the presenter

00:05:31,199 --> 00:05:34,080
at the time

00:05:31,759 --> 00:05:35,919
said is the unofficial sequel to sick p

00:05:34,080 --> 00:05:37,759
which is ctm the concepts

00:05:35,919 --> 00:05:38,880
techniques and models of computer

00:05:37,759 --> 00:05:39,680
programming and that is probably going

00:05:38,880 --> 00:05:43,280
to be a book

00:05:39,680 --> 00:05:45,600
that we cover in a follow-up series in

00:05:43,280 --> 00:05:48,720
the programming languages virtual meetup

00:05:45,600 --> 00:05:51,360
so going back to brian harvey who the

00:05:48,720 --> 00:05:54,240
first quote was from

00:05:51,360 --> 00:05:56,080
he also wrote a article called why sick

00:05:54,240 --> 00:05:58,400
p matters we're not going to go through

00:05:56,080 --> 00:05:59,680
uh the whole article but um we're going

00:05:58,400 --> 00:06:00,560
to look at highlights from the first

00:05:59,680 --> 00:06:05,280
paragraph

00:06:00,560 --> 00:06:07,840
which i think are pretty powerful

00:06:05,280 --> 00:06:09,440
uh the first paragraph states sick p was

00:06:07,840 --> 00:06:11,039
revolutionary in many different ways

00:06:09,440 --> 00:06:12,960
sick p is about standing back from the

00:06:11,039 --> 00:06:14,800
details to learn big picture ways to

00:06:12,960 --> 00:06:17,039
think about the programming process

00:06:14,800 --> 00:06:18,080
it focused attention on the central idea

00:06:17,039 --> 00:06:20,560
of abstraction

00:06:18,080 --> 00:06:22,240
the idea of functions as data and three

00:06:20,560 --> 00:06:24,479
different programming paradigms

00:06:22,240 --> 00:06:25,840
functional object-oriented and

00:06:24,479 --> 00:06:28,880
declarative

00:06:25,840 --> 00:06:31,440
um and i highly recommend if at the end

00:06:28,880 --> 00:06:32,960
of this talk you aren't convinced

00:06:31,440 --> 00:06:34,960
that you should go and read this book

00:06:32,960 --> 00:06:35,840
you go and read this full article at the

00:06:34,960 --> 00:06:38,639
hyperlink

00:06:35,840 --> 00:06:40,160
provided at the bottom um it's it talks

00:06:38,639 --> 00:06:42,800
so much more than just about

00:06:40,160 --> 00:06:44,880
um it being sort of a textbook in its

00:06:42,800 --> 00:06:46,800
own class it talks about why

00:06:44,880 --> 00:06:48,639
scheme is such an amazing language it's

00:06:46,800 --> 00:06:50,080
the language the lisp dialect that they

00:06:48,639 --> 00:06:52,479
use in the book

00:06:50,080 --> 00:06:54,479
to teach programming and it talks about

00:06:52,479 --> 00:06:56,720
why the programming language

00:06:54,479 --> 00:06:58,720
usually just gets a in the way of the

00:06:56,720 --> 00:07:01,120
fundamental ideas that most introductory

00:06:58,720 --> 00:07:02,960
cs courses are trying to teach

00:07:01,120 --> 00:07:05,199
and on top of that it as it mentions in

00:07:02,960 --> 00:07:07,680
this uh right on the slide here

00:07:05,199 --> 00:07:09,280
it teaches these fundamental ideas um in

00:07:07,680 --> 00:07:11,120
different programming paradigms

00:07:09,280 --> 00:07:13,599
and for those of you that aren't

00:07:11,120 --> 00:07:14,000
familiar i am sure many of the attendees

00:07:13,599 --> 00:07:16,000
are

00:07:14,000 --> 00:07:17,120
and many of the youtube watchers at a

00:07:16,000 --> 00:07:18,880
later date are

00:07:17,120 --> 00:07:20,479
but for the first couple of years as i

00:07:18,880 --> 00:07:21,360
didn't study computer science in

00:07:20,479 --> 00:07:23,120
university

00:07:21,360 --> 00:07:25,599
i wasn't familiar with the term

00:07:23,120 --> 00:07:26,880
programming paradigms and

00:07:25,599 --> 00:07:28,000
most times when people mention

00:07:26,880 --> 00:07:29,280
programming paradigms they don't

00:07:28,000 --> 00:07:31,120
actually mention what they are they just

00:07:29,280 --> 00:07:33,039
mention it sort of in the abstract

00:07:31,120 --> 00:07:35,039
if you aren't familiar with the idea of

00:07:33,039 --> 00:07:36,000
programming paradigms i highly recommend

00:07:35,039 --> 00:07:37,520
going and reading

00:07:36,000 --> 00:07:39,440
programming paradigms for dummies what

00:07:37,520 --> 00:07:41,520
every programmer should know

00:07:39,440 --> 00:07:43,360
it's a paper by peter van roy who is

00:07:41,520 --> 00:07:44,639
also the author of the ctm textbook that

00:07:43,360 --> 00:07:47,440
was mentioned just previously

00:07:44,639 --> 00:07:48,639
it's a fantastic read one because it

00:07:47,440 --> 00:07:49,840
goes through a bunch of different

00:07:48,639 --> 00:07:51,759
paradigms but

00:07:49,840 --> 00:07:53,759
two because it doesn't just go through

00:07:51,759 --> 00:07:54,319
three or five or seven it goes through

00:07:53,759 --> 00:07:57,360
like

00:07:54,319 --> 00:07:58,080
40 plus different paradigms so a lot of

00:07:57,360 --> 00:07:59,520
people are familiar

00:07:58,080 --> 00:08:01,280
with functional programming or object

00:07:59,520 --> 00:08:04,400
oriented programming um

00:08:01,280 --> 00:08:06,080
or a couple others but um this is uh

00:08:04,400 --> 00:08:07,520
it's a non-exhaustive list but it's a

00:08:06,080 --> 00:08:07,840
lot more comprehensive than you might

00:08:07,520 --> 00:08:10,879
see

00:08:07,840 --> 00:08:11,520
in a lot of other places this brings us

00:08:10,879 --> 00:08:14,800
to

00:08:11,520 --> 00:08:17,360
uh the highlights section of our talk

00:08:14,800 --> 00:08:18,720
so we're gonna start with um some quotes

00:08:17,360 --> 00:08:20,319
which are primarily taken from the

00:08:18,720 --> 00:08:21,840
dedication and the four words to the

00:08:20,319 --> 00:08:22,560
book um the first quote we're going to

00:08:21,840 --> 00:08:24,240
start with

00:08:22,560 --> 00:08:26,240
is probably one of my favorite quotes

00:08:24,240 --> 00:08:29,039
and this is how the textbook starts off

00:08:26,240 --> 00:08:30,400
it's from alan j perlis and it reads i

00:08:29,039 --> 00:08:30,960
think that it's extraordinarily

00:08:30,400 --> 00:08:33,919
important

00:08:30,960 --> 00:08:34,880
that we in computer science keep fun in

00:08:33,919 --> 00:08:36,240
computing

00:08:34,880 --> 00:08:38,240
um for those of you that don't know

00:08:36,240 --> 00:08:40,719
anything about alan j perlis

00:08:38,240 --> 00:08:41,839
he was a former president of the acm and

00:08:40,719 --> 00:08:44,560
most importantly

00:08:41,839 --> 00:08:45,279
the first recipient of the turing award

00:08:44,560 --> 00:08:47,920
and he is

00:08:45,279 --> 00:08:49,200
a pioneer in the field of computer

00:08:47,920 --> 00:08:50,959
science in my opinion

00:08:49,200 --> 00:08:52,560
um i think this is fantastic it's a

00:08:50,959 --> 00:08:53,279
fantastic way to start a textbook you

00:08:52,560 --> 00:08:56,160
know most

00:08:53,279 --> 00:08:57,760
computer science courses you know

00:08:56,160 --> 00:08:58,880
students don't associate with like

00:08:57,760 --> 00:09:00,800
having fun

00:08:58,880 --> 00:09:02,480
but i absolutely love programming i

00:09:00,800 --> 00:09:03,440
absolutely love algorithms i love

00:09:02,480 --> 00:09:06,160
beautiful code

00:09:03,440 --> 00:09:08,399
and to see someone who is so prolific at

00:09:06,160 --> 00:09:09,040
the beginning of a textbook starting off

00:09:08,399 --> 00:09:11,279
with

00:09:09,040 --> 00:09:12,800
let's let's remember to have fun uh i

00:09:11,279 --> 00:09:15,600
just think is awesome

00:09:12,800 --> 00:09:16,240
another quote from alan j perlis a

00:09:15,600 --> 00:09:18,399
programmer

00:09:16,240 --> 00:09:19,760
should acquire good algorithms and

00:09:18,399 --> 00:09:21,680
idioms

00:09:19,760 --> 00:09:24,240
now this if you are from the c plus plus

00:09:21,680 --> 00:09:25,680
community should sound quite familiar to

00:09:24,240 --> 00:09:27,360
some statements that other

00:09:25,680 --> 00:09:29,519
uh individuals in the c plus plus

00:09:27,360 --> 00:09:31,200
community have said

00:09:29,519 --> 00:09:34,000
so you have all these algorithms at your

00:09:31,200 --> 00:09:37,120
disposal right

00:09:34,000 --> 00:09:38,880
learn them it's very important you need

00:09:37,120 --> 00:09:41,040
to know the patterns and the idioms that

00:09:38,880 --> 00:09:42,720
we use

00:09:41,040 --> 00:09:44,560
so of course most of you will be

00:09:42,720 --> 00:09:47,519
familiar with these two individuals

00:09:44,560 --> 00:09:49,040
that is sean parent from his amazing

00:09:47,519 --> 00:09:51,519
2013 c

00:09:49,040 --> 00:09:52,320
plus seasoning talk and kate gregory

00:09:51,519 --> 00:09:54,720
from her

00:09:52,320 --> 00:09:56,240
amazing it's compliment it's complicated

00:09:54,720 --> 00:09:59,680
keynote from meeting c

00:09:56,240 --> 00:10:01,040
plus uh 2017 i believe um so

00:09:59,680 --> 00:10:03,360
the point that i'm highlighting here is

00:10:01,040 --> 00:10:05,200
this is a great quote talking about how

00:10:03,360 --> 00:10:06,640
it's important to know the algorithms

00:10:05,200 --> 00:10:09,600
and idioms in your language

00:10:06,640 --> 00:10:11,600
um but also that this has been uh been

00:10:09,600 --> 00:10:14,160
being talked about for decades now

00:10:11,600 --> 00:10:14,880
um it's not just kate and sean and other

00:10:14,160 --> 00:10:16,880
people in the c

00:10:14,880 --> 00:10:19,040
plus community this book was originally

00:10:16,880 --> 00:10:20,320
published in 1986 i'm not exactly sure

00:10:19,040 --> 00:10:21,600
when the forward was written

00:10:20,320 --> 00:10:23,360
but you could imagine that it was

00:10:21,600 --> 00:10:24,720
sometime in the 80s which means people

00:10:23,360 --> 00:10:28,399
have been talking about this

00:10:24,720 --> 00:10:30,320
for decades now um and uh yeah

00:10:28,399 --> 00:10:33,040
don't don't listen to me listen to sean

00:10:30,320 --> 00:10:35,040
listen to kate and listen to alan

00:10:33,040 --> 00:10:37,440
the next quote which is a bit of a

00:10:35,040 --> 00:10:39,120
mouthful the discretionary exportable

00:10:37,440 --> 00:10:40,399
functionality entrusted to the

00:10:39,120 --> 00:10:42,720
individual list programmer

00:10:40,399 --> 00:10:44,800
is more than an order of magnitude

00:10:42,720 --> 00:10:46,959
greater than that to be found within

00:10:44,800 --> 00:10:49,440
pascal enterprises

00:10:46,959 --> 00:10:50,079
so this i included because it highlights

00:10:49,440 --> 00:10:52,880
uh

00:10:50,079 --> 00:10:55,440
how amazing alan j perlis is with words

00:10:52,880 --> 00:10:57,200
you'll see that even more in a second

00:10:55,440 --> 00:10:58,880
but it's also highlighting the power

00:10:57,200 --> 00:11:00,000
that comes with lisp there's many

00:10:58,880 --> 00:11:03,040
different quotes about

00:11:00,000 --> 00:11:04,880
this sort of phenomenon but

00:11:03,040 --> 00:11:06,160
what alan is trying to point out here is

00:11:04,880 --> 00:11:08,720
that you

00:11:06,160 --> 00:11:10,240
are entrusted with so much more power

00:11:08,720 --> 00:11:12,160
when you are programming enlist than you

00:11:10,240 --> 00:11:15,120
are with other languages which makes it

00:11:12,160 --> 00:11:17,519
an amazing tool to learn with

00:11:15,120 --> 00:11:18,560
the next quote we have is also about

00:11:17,519 --> 00:11:20,959
pascal and lisp

00:11:18,560 --> 00:11:22,880
pascal is for building pyramids imposing

00:11:20,959 --> 00:11:25,279
breathtaking static structures built by

00:11:22,880 --> 00:11:27,839
armies pushing heavy blocks into place

00:11:25,279 --> 00:11:29,680
lisp is for building organisms imposing

00:11:27,839 --> 00:11:30,480
breathtaking dynamic structures built by

00:11:29,680 --> 00:11:32,640
squads

00:11:30,480 --> 00:11:34,560
fitting fluctuating myriads of simpler

00:11:32,640 --> 00:11:37,760
organisms into place

00:11:34,560 --> 00:11:40,480
so once again you can see here alan

00:11:37,760 --> 00:11:42,000
j perlis is just amazing with words and

00:11:40,480 --> 00:11:42,880
describing the differences between

00:11:42,000 --> 00:11:44,560
what you're doing when you're

00:11:42,880 --> 00:11:46,079
programming in pascal versus what you're

00:11:44,560 --> 00:11:47,760
doing when you're programming in lisp

00:11:46,079 --> 00:11:50,320
building pyramids versus building

00:11:47,760 --> 00:11:50,320
organisms

00:11:51,279 --> 00:11:56,320
and last but not least a quote

00:11:54,480 --> 00:11:57,600
which is not from alan j perlis but is

00:11:56,320 --> 00:11:58,320
just from the preface to the first

00:11:57,600 --> 00:12:00,480
edition

00:11:58,320 --> 00:12:01,920
scheme the dialect of lisp that we use

00:12:00,480 --> 00:12:03,440
is an attempt to bring together the

00:12:01,920 --> 00:12:06,240
power of elegance

00:12:03,440 --> 00:12:06,560
power and elegance of lisp and algol um

00:12:06,240 --> 00:12:08,160
so

00:12:06,560 --> 00:12:09,839
at at this point when i had read this i

00:12:08,160 --> 00:12:11,279
had no idea i knew scheme was a

00:12:09,839 --> 00:12:13,279
dialectic list but i didn't know that it

00:12:11,279 --> 00:12:15,200
was an amalgamation of the ideas and

00:12:13,279 --> 00:12:17,040
lisps and the ideas in algol

00:12:15,200 --> 00:12:18,639
and it was at this point that i went and

00:12:17,040 --> 00:12:20,720
did a little bit of research and so now

00:12:18,639 --> 00:12:21,120
we're going to dive into a mini history

00:12:20,720 --> 00:12:23,120
of

00:12:21,120 --> 00:12:24,160
lisp so this is not meant to be

00:12:23,120 --> 00:12:25,760
comprehensive at all

00:12:24,160 --> 00:12:27,200
just to give you an idea of all the

00:12:25,760 --> 00:12:28,240
different flavors of list that are out

00:12:27,200 --> 00:12:30,720
there and sort of

00:12:28,240 --> 00:12:31,600
how lisp led to scheme and how that led

00:12:30,720 --> 00:12:35,040
to racket

00:12:31,600 --> 00:12:37,600
so this is a diagram stolen from the

00:12:35,040 --> 00:12:38,959
lisp wikipedia page that shows sort of

00:12:37,600 --> 00:12:41,120
all the most popular

00:12:38,959 --> 00:12:43,200
list dialects in time lisp was

00:12:41,120 --> 00:12:44,880
originally invented or created

00:12:43,200 --> 00:12:46,320
in the late 50s by an individual by the

00:12:44,880 --> 00:12:49,040
name of john mccarthy

00:12:46,320 --> 00:12:50,800
and from there it went on to inspire a

00:12:49,040 --> 00:12:52,240
ton of other lisp dialects i'm not going

00:12:50,800 --> 00:12:53,600
to read through them all but any of them

00:12:52,240 --> 00:12:55,760
that i could find a logo for

00:12:53,600 --> 00:12:57,200
i'm going to highlight so after lisp

00:12:55,760 --> 00:12:59,760
became scheme

00:12:57,200 --> 00:13:00,240
then came common lisp then came emacs

00:12:59,760 --> 00:13:03,920
lisp

00:13:00,240 --> 00:13:06,160
pico lisp racket guile which is a

00:13:03,920 --> 00:13:08,399
scheme implementation closure which was

00:13:06,160 --> 00:13:10,399
invented more recently by rich hickey

00:13:08,399 --> 00:13:11,839
and high which is i believe it's a

00:13:10,399 --> 00:13:14,639
python flavored lisp

00:13:11,839 --> 00:13:16,320
so of all these lisps at least from my

00:13:14,639 --> 00:13:18,399
podcast listening and reading and

00:13:16,320 --> 00:13:20,880
researching the two most popular

00:13:18,399 --> 00:13:23,120
seem to be racket and closure closure is

00:13:20,880 --> 00:13:25,360
definitely the most modern of the two

00:13:23,120 --> 00:13:28,320
and so note that even though the book is

00:13:25,360 --> 00:13:30,399
uh written with its exercises in scheme

00:13:28,320 --> 00:13:32,720
it's very easy to do the exercises in

00:13:30,399 --> 00:13:34,079
any scheme or in any list dialect let

00:13:32,720 --> 00:13:36,399
alone any other language and there's

00:13:34,079 --> 00:13:38,480
tons of resources online

00:13:36,399 --> 00:13:40,079
in order to check solutions in different

00:13:38,480 --> 00:13:42,399
languages and note that

00:13:40,079 --> 00:13:44,160
all of the lectures and the book are

00:13:42,399 --> 00:13:46,800
free so

00:13:44,160 --> 00:13:48,000
that is awesome talking about the

00:13:46,800 --> 00:13:50,800
relationship between lisp

00:13:48,000 --> 00:13:52,480
scheme and racket i had listened to many

00:13:50,800 --> 00:13:54,720
podcasts and always heard

00:13:52,480 --> 00:13:56,320
racket and this variant of scheme called

00:13:54,720 --> 00:13:58,000
plt scheme

00:13:56,320 --> 00:13:59,440
sort of used interchangeably and i never

00:13:58,000 --> 00:14:01,199
really understood the difference so this

00:13:59,440 --> 00:14:03,440
is the relationship between lisp

00:14:01,199 --> 00:14:04,320
scheme and racket list was created first

00:14:03,440 --> 00:14:07,440
then scheme

00:14:04,320 --> 00:14:10,320
then racket lisp as mentioned before

00:14:07,440 --> 00:14:11,040
uh led to in combination with algol

00:14:10,320 --> 00:14:13,279
scheme so

00:14:11,040 --> 00:14:14,720
in the late 50s lisp was created by

00:14:13,279 --> 00:14:16,399
mccarthy and algol

00:14:14,720 --> 00:14:17,920
in the early 60s was created by the

00:14:16,399 --> 00:14:19,440
algol committee which included

00:14:17,920 --> 00:14:22,160
uh alan j perlis he was one of the

00:14:19,440 --> 00:14:23,920
members and this led to scheme which was

00:14:22,160 --> 00:14:24,959
invented in the mid 70s and this was

00:14:23,920 --> 00:14:26,480
created by

00:14:24,959 --> 00:14:28,399
sussman who's one of the co-authors of

00:14:26,480 --> 00:14:28,959
sick p and guy steele who's a prolific

00:14:28,399 --> 00:14:31,680
author

00:14:28,959 --> 00:14:32,399
he's written books on java c lisp and

00:14:31,680 --> 00:14:35,600
more

00:14:32,399 --> 00:14:37,440
and then this led to the plt research

00:14:35,600 --> 00:14:39,199
group in the 90s

00:14:37,440 --> 00:14:41,600
creating something which was originally

00:14:39,199 --> 00:14:43,199
called plt scheme but at a certain point

00:14:41,600 --> 00:14:45,040
this was decided that it was different

00:14:43,199 --> 00:14:46,560
enough from the original scheme

00:14:45,040 --> 00:14:48,800
that they needed a new name so they

00:14:46,560 --> 00:14:50,560
rebranded racket but you can see

00:14:48,800 --> 00:14:52,560
the similarity between the two logos

00:14:50,560 --> 00:14:55,600
because essentially racket is just

00:14:52,560 --> 00:14:56,480
an evolved form of scheme so that is

00:14:55,600 --> 00:14:59,199
your mini

00:14:56,480 --> 00:15:00,880
lisp history the next highlight is a

00:14:59,199 --> 00:15:02,320
quote that many of you may or may not

00:15:00,880 --> 00:15:05,199
have heard of and that it's

00:15:02,320 --> 00:15:06,639
it's just data um so one of the first

00:15:05,199 --> 00:15:07,920
times this really stuck in my head was

00:15:06,639 --> 00:15:09,519
when i was watching one of the best

00:15:07,920 --> 00:15:12,480
talks i've ever seen

00:15:09,519 --> 00:15:14,959
every closure talk ever and uh it was

00:15:12,480 --> 00:15:16,880
given at closure college 2018

00:15:14,959 --> 00:15:18,079
and in that talk it's about 30 or 40

00:15:16,880 --> 00:15:20,560
minutes there is a

00:15:18,079 --> 00:15:22,160
two and a half minute advertisement that

00:15:20,560 --> 00:15:25,040
they made for closure

00:15:22,160 --> 00:15:27,199
i couldn't find this posted individually

00:15:25,040 --> 00:15:27,680
by itself anywhere so i re-uploaded it

00:15:27,199 --> 00:15:29,839
to my

00:15:27,680 --> 00:15:31,440
uh channel i highly recommend if you

00:15:29,839 --> 00:15:32,720
have two and a half minutes to spare you

00:15:31,440 --> 00:15:34,639
go and watch the whole thing

00:15:32,720 --> 00:15:36,079
because it is absolutely amazing and

00:15:34,639 --> 00:15:37,920
hilarious and probably one of the

00:15:36,079 --> 00:15:39,519
funniest things i've seen sort of in the

00:15:37,920 --> 00:15:41,440
programming world um but we're going to

00:15:39,519 --> 00:15:44,160
take a look at just a short seven second

00:15:41,440 --> 00:15:47,680
clip from this advertisement

00:15:44,160 --> 00:15:55,839
it's just data it's just data

00:15:47,680 --> 00:15:55,839
it's not code it's data no code

00:16:00,240 --> 00:16:05,040
so hopefully uh the audio of that is um

00:16:03,440 --> 00:16:06,959
you can hear please let me know in the

00:16:05,040 --> 00:16:09,279
chat if you cannot um so this is

00:16:06,959 --> 00:16:12,160
interesting for a number of reasons

00:16:09,279 --> 00:16:13,839
um one is that it's talking about this

00:16:12,160 --> 00:16:16,000
phenomenon of it's just data

00:16:13,839 --> 00:16:17,199
code is data the second though is that

00:16:16,000 --> 00:16:19,759
this last quote

00:16:17,199 --> 00:16:20,320
um that we just heard is from alan j

00:16:19,759 --> 00:16:22,959
perlis

00:16:20,320 --> 00:16:24,160
and i actually saw in the chat earlier

00:16:22,959 --> 00:16:26,639
someone posted the

00:16:24,160 --> 00:16:27,680
uh epigrams on programming um and sure

00:16:26,639 --> 00:16:28,959
enough uh

00:16:27,680 --> 00:16:30,959
that is what i have a link to at the

00:16:28,959 --> 00:16:32,880
bottom of my slides here so and this

00:16:30,959 --> 00:16:34,560
exact quote i'm not sure if it

00:16:32,880 --> 00:16:36,240
it first showed up in the structure and

00:16:34,560 --> 00:16:36,880
interpretation of computer programs but

00:16:36,240 --> 00:16:38,959
it is

00:16:36,880 --> 00:16:40,959
exactly in there so here it reads in

00:16:38,959 --> 00:16:42,639
pascal the plethora of declarable data

00:16:40,959 --> 00:16:43,519
structures induces a specialization

00:16:42,639 --> 00:16:45,519
within functions

00:16:43,519 --> 00:16:46,560
that inhibits and penalizes casual

00:16:45,519 --> 00:16:48,079
cooperation

00:16:46,560 --> 00:16:49,519
it is better to have 100 functions

00:16:48,079 --> 00:16:50,560
operate on one data structure than to

00:16:49,519 --> 00:16:52,160
have 10 functions

00:16:50,560 --> 00:16:53,920
operate on 10 data structures as a

00:16:52,160 --> 00:16:56,240
result the pyramid must stand

00:16:53,920 --> 00:16:58,160
unchanged for a millennium the organisms

00:16:56,240 --> 00:17:00,560
must evolve or perish

00:16:58,160 --> 00:17:02,320
so like i said this is from alan j

00:17:00,560 --> 00:17:04,240
perlis's epigrams on programming

00:17:02,320 --> 00:17:06,000
which is a collection of quotes of his

00:17:04,240 --> 00:17:08,880
um another one of them i believe is

00:17:06,000 --> 00:17:10,240
lisps uh list programmers know the uh

00:17:08,880 --> 00:17:10,720
the value of everything in the cost of

00:17:10,240 --> 00:17:13,600
nothing

00:17:10,720 --> 00:17:15,280
so there's these very sort of uh um many

00:17:13,600 --> 00:17:16,640
witticisms that come from him that are

00:17:15,280 --> 00:17:17,919
that are quite cool so

00:17:16,640 --> 00:17:19,439
uh i thought it was interesting that

00:17:17,919 --> 00:17:19,919
there's sort of this circularity that

00:17:19,439 --> 00:17:21,760
when i

00:17:19,919 --> 00:17:23,120
uh was learning about the coda's data i

00:17:21,760 --> 00:17:26,000
thought about this ad then when i

00:17:23,120 --> 00:17:27,760
went and rewatched it um it had a quote

00:17:26,000 --> 00:17:29,440
exactly from alan j perlis so

00:17:27,760 --> 00:17:31,120
pretty funny um so what is this talking

00:17:29,440 --> 00:17:33,679
about though the first thing

00:17:31,120 --> 00:17:34,320
um we need to look at is uh a sort of

00:17:33,679 --> 00:17:37,679
cons

00:17:34,320 --> 00:17:40,160
in a scheme or any list dialect so uh

00:17:37,679 --> 00:17:40,880
cons is the equivalent of what we have

00:17:40,160 --> 00:17:44,240
in c

00:17:40,880 --> 00:17:48,000
plus as a pair sort of loosely um

00:17:44,240 --> 00:17:50,880
if you see here we've got uh uh define p

00:17:48,000 --> 00:17:51,919
cons of 42 and 1729 this is basically

00:17:50,880 --> 00:17:54,880
defining a pair

00:17:51,919 --> 00:17:56,640
of the values 42 and 1729 and the two

00:17:54,880 --> 00:17:57,600
ways to get to the first value and the

00:17:56,640 --> 00:18:00,880
second value

00:17:57,600 --> 00:18:01,840
are car and cutter note that this is

00:18:00,880 --> 00:18:04,080
sort of a relic

00:18:01,840 --> 00:18:04,960
of the old lisps the newer lisps call

00:18:04,080 --> 00:18:08,799
these

00:18:04,960 --> 00:18:10,960
two variables or accessor

00:18:08,799 --> 00:18:13,039
functions differently if we take a look

00:18:10,960 --> 00:18:14,400
at a table for what

00:18:13,039 --> 00:18:16,400
these are called in different languages

00:18:14,400 --> 00:18:17,280
you can see scheme calls these car and

00:18:16,400 --> 00:18:19,039
cutter

00:18:17,280 --> 00:18:21,039
racket calls these first and rest as

00:18:19,039 --> 00:18:23,520
does closure uh haskell

00:18:21,039 --> 00:18:25,360
elixir and o camel all call these head

00:18:23,520 --> 00:18:27,039
and tail although elixir and ocam will

00:18:25,360 --> 00:18:29,280
drop the uh

00:18:27,039 --> 00:18:30,559
a and a i so i guess they don't have

00:18:29,280 --> 00:18:33,360
they don't have the time

00:18:30,559 --> 00:18:34,720
and energy for vowels c plus almost has

00:18:33,360 --> 00:18:38,640
the equivalence of these

00:18:34,720 --> 00:18:40,640
um we have uh a view uh arranges views

00:18:38,640 --> 00:18:41,679
tail in the range v3 library so that

00:18:40,640 --> 00:18:44,799
might show up in the c

00:18:41,679 --> 00:18:46,080
plus ranges at some point and we don't

00:18:44,799 --> 00:18:47,760
have head but we can get the same

00:18:46,080 --> 00:18:50,160
behavior by doing a take one

00:18:47,760 --> 00:18:50,960
and an apl note that we can get this by

00:18:50,160 --> 00:18:53,039
doing uh

00:18:50,960 --> 00:18:55,120
take one and drop one which is basically

00:18:53,039 --> 00:18:57,919
how all of these could be implemented

00:18:55,120 --> 00:18:59,200
so if we uh go back to our code and we

00:18:57,919 --> 00:19:00,080
compare this to what this might look

00:18:59,200 --> 00:19:02,400
like in c

00:19:00,080 --> 00:19:04,160
plus we have the following so we

00:19:02,400 --> 00:19:05,039
creating a pair here note that we're

00:19:04,160 --> 00:19:06,799
using c

00:19:05,039 --> 00:19:08,240
17 c tag class template argument

00:19:06,799 --> 00:19:09,200
deduction so we don't need to specify

00:19:08,240 --> 00:19:12,320
the type

00:19:09,200 --> 00:19:14,160
and in order to get um access to our

00:19:12,320 --> 00:19:16,160
first and second values we can just use

00:19:14,160 --> 00:19:19,760
the first and second

00:19:16,160 --> 00:19:23,600
member names so what is this about

00:19:19,760 --> 00:19:26,640
it's just data well in the book for the

00:19:23,600 --> 00:19:28,799
scheme they show this implementation of

00:19:26,640 --> 00:19:31,760
cons

00:19:28,799 --> 00:19:32,240
which is basically code for thought we

00:19:31,760 --> 00:19:35,280
have

00:19:32,240 --> 00:19:36,799
a procedure cons that takes two

00:19:35,280 --> 00:19:38,559
parameters x and y

00:19:36,799 --> 00:19:39,919
and then defines an internal procedure

00:19:38,559 --> 00:19:42,240
called dispatch

00:19:39,919 --> 00:19:43,520
which takes a message and then in this

00:19:42,240 --> 00:19:44,720
conditional expression you can just

00:19:43,520 --> 00:19:46,640
think of this as a case

00:19:44,720 --> 00:19:48,240
it checks whether the message is car or

00:19:46,640 --> 00:19:50,480
coulder and

00:19:48,240 --> 00:19:52,240
if it's car it returns x and if it's

00:19:50,480 --> 00:19:53,919
cutter it returns y

00:19:52,240 --> 00:19:55,280
and then once we finish defining this

00:19:53,919 --> 00:19:57,440
internal procedure

00:19:55,280 --> 00:19:59,039
we just uh return that procedure from

00:19:57,440 --> 00:20:01,440
our outer procedure cons

00:19:59,039 --> 00:20:02,960
um and this is this is really

00:20:01,440 --> 00:20:04,880
interesting because you think of cons as

00:20:02,960 --> 00:20:05,440
sort of like a data structure or holding

00:20:04,880 --> 00:20:08,480
data

00:20:05,440 --> 00:20:11,679
but here we have defined cons to return

00:20:08,480 --> 00:20:13,120
another procedure um which is which is

00:20:11,679 --> 00:20:13,520
interesting and this is the whole idea

00:20:13,120 --> 00:20:14,960
that

00:20:13,520 --> 00:20:16,799
or at least this is the beginning of the

00:20:14,960 --> 00:20:19,760
idea that um

00:20:16,799 --> 00:20:21,520
code is just data and data is just code

00:20:19,760 --> 00:20:22,720
and if we look at the equivalent in c

00:20:21,520 --> 00:20:24,240
plus it might look something like this

00:20:22,720 --> 00:20:25,120
now i'm not advocating you to write code

00:20:24,240 --> 00:20:27,600
like this

00:20:25,120 --> 00:20:29,280
um this is just code for thought so we

00:20:27,600 --> 00:20:31,679
have our scoped enumerator

00:20:29,280 --> 00:20:34,080
with two values first and second and

00:20:31,679 --> 00:20:36,000
then we have our procedure pair

00:20:34,080 --> 00:20:37,919
that takes two parameters x and y and

00:20:36,000 --> 00:20:40,240
then returns a lambda expression

00:20:37,919 --> 00:20:41,760
technically a closure object

00:20:40,240 --> 00:20:44,960
and this is going to capture the two

00:20:41,760 --> 00:20:46,960
values x and y and then our

00:20:44,960 --> 00:20:48,880
lambda that we're returning is going to

00:20:46,960 --> 00:20:50,240
take a single parameter mr message and

00:20:48,880 --> 00:20:52,080
it's going to check if our message is

00:20:50,240 --> 00:20:53,919
equal to first then to return x

00:20:52,080 --> 00:20:54,960
otherwise it's going to return y i mean

00:20:53,919 --> 00:20:56,559
no you could do this a lot more

00:20:54,960 --> 00:20:57,039
succinctly with a ternary operator this

00:20:56,559 --> 00:20:59,200
is just

00:20:57,039 --> 00:21:02,320
it's just slidewear to try and make this

00:20:59,200 --> 00:21:04,159
point as crystal clear as possible

00:21:02,320 --> 00:21:05,679
and like i said this is just code for

00:21:04,159 --> 00:21:07,039
thought that we can represent what we

00:21:05,679 --> 00:21:08,159
typically think is data or data

00:21:07,039 --> 00:21:10,159
structures

00:21:08,159 --> 00:21:12,159
we can implement these all with

00:21:10,159 --> 00:21:13,679
functions or what they call procedures

00:21:12,159 --> 00:21:16,400
in lisp dialects

00:21:13,679 --> 00:21:18,000
and sure enough if we write the code to

00:21:16,400 --> 00:21:19,600
sort of get access to these

00:21:18,000 --> 00:21:21,760
uh we define p to be a pair of the

00:21:19,600 --> 00:21:23,440
values 42 and 1729

00:21:21,760 --> 00:21:26,320
and then we can print out by sort of

00:21:23,440 --> 00:21:28,159
passing uh the corresponding

00:21:26,320 --> 00:21:29,840
enumerator value that we want so either

00:21:28,159 --> 00:21:31,039
the first message or the second message

00:21:29,840 --> 00:21:33,200
to either get the first value or the

00:21:31,039 --> 00:21:34,320
second value so

00:21:33,200 --> 00:21:35,760
this is like i said it's just the

00:21:34,320 --> 00:21:37,120
starting point for thinking about code

00:21:35,760 --> 00:21:39,039
as data and data as code

00:21:37,120 --> 00:21:40,480
and this really starts to melt your mind

00:21:39,039 --> 00:21:41,919
when you get to chapter four

00:21:40,480 --> 00:21:44,640
and you start implementing a meta

00:21:41,919 --> 00:21:46,400
circular evaluator which is

00:21:44,640 --> 00:21:48,720
implementing an interpreter for scheme

00:21:46,400 --> 00:21:49,919
in scheme but unfortunately

00:21:48,720 --> 00:21:51,200
due to time constraints we're not going

00:21:49,919 --> 00:21:53,120
to be able to say much about that in

00:21:51,200 --> 00:21:54,799
this talk

00:21:53,120 --> 00:21:56,400
next up we have one of the most

00:21:54,799 --> 00:21:58,320
important ideas

00:21:56,400 --> 00:21:59,840
in the first three chapters of the book

00:21:58,320 --> 00:22:02,960
which is the idea of

00:21:59,840 --> 00:22:05,520
data abstraction here

00:22:02,960 --> 00:22:07,280
is a snippet from the textbook which

00:22:05,520 --> 00:22:08,640
reads the general technique of isolating

00:22:07,280 --> 00:22:10,240
the parts of a program that deal with

00:22:08,640 --> 00:22:11,840
how data objects are represented

00:22:10,240 --> 00:22:13,600
from the parts of a program that deal

00:22:11,840 --> 00:22:15,760
with how data objects are used

00:22:13,600 --> 00:22:16,720
is a powerful design methodology called

00:22:15,760 --> 00:22:18,400
data abstraction

00:22:16,720 --> 00:22:20,559
we will see how data abstraction makes

00:22:18,400 --> 00:22:24,240
programs much easier to design

00:22:20,559 --> 00:22:26,000
maintain and modify this is an extremely

00:22:24,240 --> 00:22:27,520
important point that they build on and

00:22:26,000 --> 00:22:28,880
build on and build on they introduce it

00:22:27,520 --> 00:22:30,320
at the beginning of chapter two and they

00:22:28,880 --> 00:22:31,360
continue to build on it to the end of

00:22:30,320 --> 00:22:34,559
chapter two

00:22:31,360 --> 00:22:37,200
um this is the idea that you have your

00:22:34,559 --> 00:22:38,559
sort of user consuming code so here in

00:22:37,200 --> 00:22:40,159
the example in the textbook

00:22:38,559 --> 00:22:41,760
they have a sort of data object of

00:22:40,159 --> 00:22:44,000
rational numbers and

00:22:41,760 --> 00:22:44,799
at the top level the users are consuming

00:22:44,000 --> 00:22:46,320
it here

00:22:44,799 --> 00:22:48,320
and then we have our constructors and

00:22:46,320 --> 00:22:50,400
selectors and c plus think like

00:22:48,320 --> 00:22:51,760
constructors and get methods or accessor

00:22:50,400 --> 00:22:53,600
methods

00:22:51,760 --> 00:22:55,679
and then underneath we have the

00:22:53,600 --> 00:22:58,159
representation and the implementation

00:22:55,679 --> 00:22:59,600
and the point that the textbook makes is

00:22:58,159 --> 00:23:01,039
that your implementation and

00:22:59,600 --> 00:23:03,039
representation

00:23:01,039 --> 00:23:04,960
the user should not care about this and

00:23:03,039 --> 00:23:07,280
if you design your programs well

00:23:04,960 --> 00:23:08,720
you should be able to swap out and in

00:23:07,280 --> 00:23:10,720
different representations and different

00:23:08,720 --> 00:23:12,000
implementations without your end user

00:23:10,720 --> 00:23:13,919
caring about it

00:23:12,000 --> 00:23:16,080
this is an extremely powerful idea and

00:23:13,919 --> 00:23:18,799
it actually was not the first time

00:23:16,080 --> 00:23:19,200
that i had heard this idea as this is a

00:23:18,799 --> 00:23:20,559
c

00:23:19,200 --> 00:23:22,480
plus conference i'm sure many of the

00:23:20,559 --> 00:23:24,720
people watching this are familiar

00:23:22,480 --> 00:23:26,080
with the scott myers effective c plus

00:23:24,720 --> 00:23:28,799
plus book series

00:23:26,080 --> 00:23:29,760
and in the effective c plus book his

00:23:28,799 --> 00:23:31,679
first book

00:23:29,760 --> 00:23:33,440
um there is an item that specifically

00:23:31,679 --> 00:23:35,039
talks about this item 23 prefer

00:23:33,440 --> 00:23:36,000
non-member non-friend functions to

00:23:35,039 --> 00:23:37,120
member functions

00:23:36,000 --> 00:23:39,120
we're not going to go through this whole

00:23:37,120 --> 00:23:39,520
point and that's actually um we're not

00:23:39,120 --> 00:23:40,880
even

00:23:39,520 --> 00:23:41,679
the point of the item is not what we're

00:23:40,880 --> 00:23:43,600
going to highlight we're going to

00:23:41,679 --> 00:23:44,080
highlight a specific paragraph from this

00:23:43,600 --> 00:23:46,880
point

00:23:44,080 --> 00:23:48,320
that talks about encapsulation which was

00:23:46,880 --> 00:23:49,679
incredibly

00:23:48,320 --> 00:23:52,960
important when i read it for the first

00:23:49,679 --> 00:23:54,799
time so uh from this point item 23 it

00:23:52,960 --> 00:23:56,799
reads we'll begin with encapsulation

00:23:54,799 --> 00:23:58,400
if something is encapsulated it's hidden

00:23:56,799 --> 00:24:00,159
from view the more something is

00:23:58,400 --> 00:24:01,679
encapsulated the fewer things can see it

00:24:00,159 --> 00:24:03,440
the fewer things can see it the greater

00:24:01,679 --> 00:24:04,240
flexibility we have to change it because

00:24:03,440 --> 00:24:05,919
our changes

00:24:04,240 --> 00:24:07,679
directly affect only those things that

00:24:05,919 --> 00:24:08,880
can see what we change the greater

00:24:07,679 --> 00:24:10,720
something is encapsulated

00:24:08,880 --> 00:24:12,960
then the greater our ability to change

00:24:10,720 --> 00:24:14,799
it that's the reason we encapsul

00:24:12,960 --> 00:24:16,799
that's the reason we value encapsulation

00:24:14,799 --> 00:24:18,559
in the first place it affords us the

00:24:16,799 --> 00:24:19,200
flexibility to change things in a way

00:24:18,559 --> 00:24:21,840
that affects

00:24:19,200 --> 00:24:23,200
only a limited number of clients so in

00:24:21,840 --> 00:24:24,880
different words this is basically

00:24:23,200 --> 00:24:28,080
talking about the same idea

00:24:24,880 --> 00:24:30,320
that if we design our classes in c

00:24:28,080 --> 00:24:32,080
plus correctly we can sort of change

00:24:30,320 --> 00:24:34,559
things without affecting

00:24:32,080 --> 00:24:36,240
our users we're affecting the minimum

00:24:34,559 --> 00:24:37,360
number of things possible

00:24:36,240 --> 00:24:39,760
so that's all i'm going to say about

00:24:37,360 --> 00:24:41,600
data abstraction i also highly recommend

00:24:39,760 --> 00:24:42,799
all of these books if you have not read

00:24:41,600 --> 00:24:45,360
them

00:24:42,799 --> 00:24:46,880
they are absolutely amazing and there's

00:24:45,360 --> 00:24:48,799
no way you can read them and not learn

00:24:46,880 --> 00:24:50,320
something from them

00:24:48,799 --> 00:24:52,559
and last but not least from our

00:24:50,320 --> 00:24:54,240
highlight section uh

00:24:52,559 --> 00:24:55,919
we are going to talk about object

00:24:54,240 --> 00:24:57,919
oriented programming um

00:24:55,919 --> 00:25:01,039
question mark so we're going to cover

00:24:57,919 --> 00:25:03,039
this pretty quickly but at the end of

00:25:01,039 --> 00:25:06,400
the object-oriented section in the

00:25:03,039 --> 00:25:09,200
berkeley lectures taught by brian harvey

00:25:06,400 --> 00:25:11,200
they have you watch a talk about small

00:25:09,200 --> 00:25:13,120
talk by dan ingles who's one of the main

00:25:11,200 --> 00:25:14,080
implementers of the small talk language

00:25:13,120 --> 00:25:14,880
which for those of you that aren't

00:25:14,080 --> 00:25:17,919
familiar

00:25:14,880 --> 00:25:19,600
was the original oop language and they

00:25:17,919 --> 00:25:21,760
have this table which i thought was

00:25:19,600 --> 00:25:24,640
absolutely fascinating

00:25:21,760 --> 00:25:25,520
so this table states three prerequisites

00:25:24,640 --> 00:25:27,760
you need to have

00:25:25,520 --> 00:25:28,559
in order to be an object-oriented

00:25:27,760 --> 00:25:31,520
language

00:25:28,559 --> 00:25:32,320
the first is closures otherwise known as

00:25:31,520 --> 00:25:34,880
lambdas

00:25:32,320 --> 00:25:35,520
the second is everything is an object

00:25:34,880 --> 00:25:37,679
aka

00:25:35,520 --> 00:25:38,720
uniform reference and the third is

00:25:37,679 --> 00:25:40,559
garbage collection

00:25:38,720 --> 00:25:42,080
note that these lectures were given in

00:25:40,559 --> 00:25:44,720
2010 so

00:25:42,080 --> 00:25:46,000
at the time they had no planned um

00:25:44,720 --> 00:25:48,080
meaning that they were coming in c

00:25:46,000 --> 00:25:49,279
plus 11 and in java they said kind of

00:25:48,080 --> 00:25:50,559
because you had i believe like the

00:25:49,279 --> 00:25:52,400
single accessor methods

00:25:50,559 --> 00:25:54,720
i'm not a java expert but there was a

00:25:52,400 --> 00:25:59,200
way of sort of simulating a closure

00:25:54,720 --> 00:26:02,000
type object but now in uh 2020

00:25:59,200 --> 00:26:03,279
we both have closures in c plus and java

00:26:02,000 --> 00:26:05,679
so this is what the table

00:26:03,279 --> 00:26:06,640
up to date now looks like but the point

00:26:05,679 --> 00:26:09,679
that dan ingalls

00:26:06,640 --> 00:26:10,720
and the small talk folks were stating

00:26:09,679 --> 00:26:12,000
was that

00:26:10,720 --> 00:26:13,440
you don't have an object oriented

00:26:12,000 --> 00:26:15,120
language unless if you meet all three of

00:26:13,440 --> 00:26:17,120
these criteria so

00:26:15,120 --> 00:26:18,400
apparently c plus is not an

00:26:17,120 --> 00:26:21,520
object-oriented language

00:26:18,400 --> 00:26:23,039
according to allen k and dan ingalls

00:26:21,520 --> 00:26:25,279
obviously i'm sure there are many people

00:26:23,039 --> 00:26:27,520
that disagree with this um it's odd

00:26:25,279 --> 00:26:28,720
that you would think uh that gc is a

00:26:27,520 --> 00:26:31,679
prerequisite for an

00:26:28,720 --> 00:26:32,240
ooo language um but yes this is just

00:26:31,679 --> 00:26:34,799
what the

00:26:32,240 --> 00:26:35,440
creators of uh small talk like i said

00:26:34,799 --> 00:26:38,799
which is the

00:26:35,440 --> 00:26:40,880
original oop language that's what they

00:26:38,799 --> 00:26:44,960
have to say about what makes a language

00:26:40,880 --> 00:26:48,080
object-oriented and with that i believe

00:26:44,960 --> 00:26:48,640
we have come to my my favorite half of

00:26:48,080 --> 00:26:50,159
the talk

00:26:48,640 --> 00:26:52,640
and section of the talk and that is

00:26:50,159 --> 00:26:55,120
solving problems um in c

00:26:52,640 --> 00:26:56,720
plus so i had to cut out a bunch of

00:26:55,120 --> 00:26:57,200
these because there's so many amazing

00:26:56,720 --> 00:26:59,840
ones

00:26:57,200 --> 00:27:00,559
and depending on our time we may even

00:26:59,840 --> 00:27:02,000
need to

00:27:00,559 --> 00:27:03,760
skip one of these but it looks like

00:27:02,000 --> 00:27:05,039
we're doing all right um

00:27:03,760 --> 00:27:07,120
we're going to look at four problems the

00:27:05,039 --> 00:27:07,520
first one's a warm-up and then the last

00:27:07,120 --> 00:27:08,720
three

00:27:07,520 --> 00:27:09,919
are problems that are taken from

00:27:08,720 --> 00:27:11,120
different chapters in the book and we

00:27:09,919 --> 00:27:14,400
are going to solve these

00:27:11,120 --> 00:27:14,799
in c plus and uh i think this is going

00:27:14,400 --> 00:27:16,559
to be

00:27:14,799 --> 00:27:18,159
this is going to be a lot of fun so

00:27:16,559 --> 00:27:19,039
let's start with our warm-up problem

00:27:18,159 --> 00:27:21,360
similar to

00:27:19,039 --> 00:27:23,360
a problem that i originally covered in

00:27:21,360 --> 00:27:24,720
my very first talk algorithm intuition

00:27:23,360 --> 00:27:27,520
that i originally gave at c

00:27:24,720 --> 00:27:28,399
plus now so the warm-up problem is

00:27:27,520 --> 00:27:31,600
entitled sum

00:27:28,399 --> 00:27:33,600
square of two largest and it

00:27:31,600 --> 00:27:35,200
states the following given a list of n

00:27:33,600 --> 00:27:38,159
where n is greater than one

00:27:35,200 --> 00:27:38,880
positive integers return the sum of the

00:27:38,159 --> 00:27:42,000
squares

00:27:38,880 --> 00:27:44,640
of the two largest numbers so

00:27:42,000 --> 00:27:46,159
uh you can feel free to post uh you know

00:27:44,640 --> 00:27:46,880
what you think your solutions might be

00:27:46,159 --> 00:27:49,600
in the chat

00:27:46,880 --> 00:27:51,440
i know there's a little bit of a leg but

00:27:49,600 --> 00:27:53,600
for example if our list of numbers is 1

00:27:51,440 --> 00:27:55,279
2 and 3

00:27:53,600 --> 00:27:57,039
the solution would be 2 squared plus 3

00:27:55,279 --> 00:27:58,320
squared which is 4 plus 9 which is 13

00:27:57,039 --> 00:27:59,039
because 2 and 3 are the two largest

00:27:58,320 --> 00:28:00,799
numbers

00:27:59,039 --> 00:28:02,480
uh and for a final example if we have

00:28:00,799 --> 00:28:04,320
the numbers one eight two six and three

00:28:02,480 --> 00:28:06,240
the two largest are eight and six

00:28:04,320 --> 00:28:07,679
uh eight squared is sixty-four six

00:28:06,240 --> 00:28:09,200
squared is thirty-six add those together

00:28:07,679 --> 00:28:10,080
and you get a hundred so hopefully the

00:28:09,200 --> 00:28:13,520
idea

00:28:10,080 --> 00:28:14,799
is uh pretty pretty clear um and while

00:28:13,520 --> 00:28:15,120
you're thinking about it i should note

00:28:14,799 --> 00:28:16,880
that

00:28:15,120 --> 00:28:18,320
up up until this point and from this

00:28:16,880 --> 00:28:20,960
point all of my

00:28:18,320 --> 00:28:22,480
examples were coded in uh compiler

00:28:20,960 --> 00:28:24,080
explorer thank you matt

00:28:22,480 --> 00:28:26,320
it's an amazing tool and all the people

00:28:24,080 --> 00:28:27,840
that work on compiler explorer

00:28:26,320 --> 00:28:29,520
the flags i use and the compiler i use

00:28:27,840 --> 00:28:32,399
was gcc 10.2 with

00:28:29,520 --> 00:28:33,520
c plus 20 and o2 all of the goblet links

00:28:32,399 --> 00:28:35,520
as i mentioned at the beginning of the

00:28:33,520 --> 00:28:38,000
talk are posted on the github page

00:28:35,520 --> 00:28:38,799
with the code examples so let's take a

00:28:38,000 --> 00:28:41,039
look

00:28:38,799 --> 00:28:42,000
at the first solution so we're not going

00:28:41,039 --> 00:28:44,320
to cover

00:28:42,000 --> 00:28:45,840
the sub optimal solutions i do have some

00:28:44,320 --> 00:28:46,799
sub-optimal solutions posted on my

00:28:45,840 --> 00:28:50,159
github

00:28:46,799 --> 00:28:53,360
but in the uh in the

00:28:50,159 --> 00:28:54,799
uh point of

00:28:53,360 --> 00:28:56,559
trying to not take too long to go

00:28:54,799 --> 00:28:58,159
through the solution we're just going to

00:28:56,559 --> 00:28:59,279
look at what i consider to be sort of

00:28:58,159 --> 00:29:02,480
the three most elegant

00:28:59,279 --> 00:29:05,360
um so the first is using

00:29:02,480 --> 00:29:05,840
stood accumulate so what we're doing

00:29:05,360 --> 00:29:08,880
here

00:29:05,840 --> 00:29:12,559
is we are using stood accumulate

00:29:08,880 --> 00:29:14,399
to initially uh create a pair of values

00:29:12,559 --> 00:29:15,919
0 and 0 which are going to represent our

00:29:14,399 --> 00:29:18,559
two largest values

00:29:15,919 --> 00:29:19,520
and then for each value in our range

00:29:18,559 --> 00:29:21,440
which we're

00:29:19,520 --> 00:29:23,279
getting access to with our c begin and c

00:29:21,440 --> 00:29:25,360
end we are going to iterate

00:29:23,279 --> 00:29:26,799
use c plus 17 structure bindings to

00:29:25,360 --> 00:29:28,640
destructure our pair

00:29:26,799 --> 00:29:29,840
so a is the largest value b is the

00:29:28,640 --> 00:29:31,039
second largest value

00:29:29,840 --> 00:29:33,039
and then for each element we do the

00:29:31,039 --> 00:29:35,200
following check if e is

00:29:33,039 --> 00:29:36,399
greater than our largest value so the

00:29:35,200 --> 00:29:38,080
current element we're looking at

00:29:36,399 --> 00:29:40,399
is greater than our largest value then

00:29:38,080 --> 00:29:43,200
we store our current largest

00:29:40,399 --> 00:29:44,880
in b and then reset our largest to be

00:29:43,200 --> 00:29:46,720
equal to the current element

00:29:44,880 --> 00:29:48,399
otherwise if we know we're not bigger

00:29:46,720 --> 00:29:50,240
than the largest element if we're bigger

00:29:48,399 --> 00:29:52,640
than the second largest element

00:29:50,240 --> 00:29:54,080
reset b to be the current element

00:29:52,640 --> 00:29:55,600
otherwise we know that the current

00:29:54,080 --> 00:29:57,120
element is less than both our two

00:29:55,600 --> 00:29:57,760
largest that we currently have so just

00:29:57,120 --> 00:29:59,279
return

00:29:57,760 --> 00:30:01,120
the pair and then at the end we square

00:29:59,279 --> 00:30:04,399
both of them and add them

00:30:01,120 --> 00:30:06,640
up um so

00:30:04,399 --> 00:30:07,520
this is quite a nice solution in my

00:30:06,640 --> 00:30:10,399
opinion

00:30:07,520 --> 00:30:11,360
however uh we are going to go on a small

00:30:10,399 --> 00:30:14,960
digression

00:30:11,360 --> 00:30:16,799
um so this i'm actually going to

00:30:14,960 --> 00:30:18,640
check to see in the chat if anybody

00:30:16,799 --> 00:30:21,679
knows does anybody know

00:30:18,640 --> 00:30:23,840
who this quote is from we write awful

00:30:21,679 --> 00:30:23,840
code

00:30:26,240 --> 00:30:32,960
and while you're typing i'll add

00:30:29,520 --> 00:30:34,159
a second piece of it to see if this

00:30:32,960 --> 00:30:35,760
gives you any more hints

00:30:34,159 --> 00:30:37,279
we write off a code i think that the

00:30:35,760 --> 00:30:39,200
starting point for all of us

00:30:37,279 --> 00:30:42,080
is to just admit to yourself that you

00:30:39,200 --> 00:30:45,440
write awful code

00:30:42,080 --> 00:30:48,480
i do see uh that victor uh

00:30:45,440 --> 00:30:51,520
has the correct answer um

00:30:48,480 --> 00:30:53,039
and so let's take a look at uh this

00:30:51,520 --> 00:30:55,840
actual quote

00:30:53,039 --> 00:30:57,039
it's not it's not a unique google is not

00:30:55,840 --> 00:31:00,559
specifically

00:30:57,039 --> 00:31:00,559
i mean it is an awful place

00:31:00,640 --> 00:31:03,840
it's perfect on adobe as well though

00:31:02,960 --> 00:31:06,480
know they have

00:31:03,840 --> 00:31:07,039
awful code that adobe they have awful

00:31:06,480 --> 00:31:10,399
code

00:31:07,039 --> 00:31:13,039
we write awful code and i think that the

00:31:10,399 --> 00:31:15,679
starting point for all of us

00:31:13,039 --> 00:31:18,320
is to just admit to yourself that you

00:31:15,679 --> 00:31:20,960
write awful code

00:31:18,320 --> 00:31:21,919
so congratulations victor uh you were

00:31:20,960 --> 00:31:24,720
indeed correct

00:31:21,919 --> 00:31:25,440
this is from alexander stepanov the

00:31:24,720 --> 00:31:29,840
author

00:31:25,440 --> 00:31:32,640
of uh stl um from the extended version

00:31:29,840 --> 00:31:34,640
of c plus seasoning um so if you are a

00:31:32,640 --> 00:31:36,720
huge fan of c plus plus seasoning

00:31:34,640 --> 00:31:39,279
um there's links at the end and links on

00:31:36,720 --> 00:31:41,519
github to a two-part extended version of

00:31:39,279 --> 00:31:43,600
this talk which is hosted on the a9

00:31:41,519 --> 00:31:45,519
uh videos youtube channel a9 is a

00:31:43,600 --> 00:31:46,399
subsidiary of amazon that works on

00:31:45,519 --> 00:31:49,360
search

00:31:46,399 --> 00:31:50,000
um and i think i think this is extremely

00:31:49,360 --> 00:31:53,919
important

00:31:50,000 --> 00:31:55,200
um as presenters and i think as c plus

00:31:53,919 --> 00:31:57,600
plus developers in general

00:31:55,200 --> 00:31:58,720
um i at least i know i'm terrified of

00:31:57,600 --> 00:32:01,519
making mistakes

00:31:58,720 --> 00:32:02,000
and like showing that i write bad code

00:32:01,519 --> 00:32:03,600
um

00:32:02,000 --> 00:32:05,120
and when i when i saw this from

00:32:03,600 --> 00:32:08,240
alexander stephanov

00:32:05,120 --> 00:32:08,799
it was like it's amazing it's seeing one

00:32:08,240 --> 00:32:11,120
of the

00:32:08,799 --> 00:32:13,039
you know foremost experts in template

00:32:11,120 --> 00:32:14,080
meta programming and algorithms talking

00:32:13,039 --> 00:32:15,679
about how we all

00:32:14,080 --> 00:32:17,679
write awful code i know the word awful

00:32:15,679 --> 00:32:19,600
is a bit negative but think about it as

00:32:17,679 --> 00:32:22,240
just like we all make mistakes

00:32:19,600 --> 00:32:23,440
and um he goes on in this conversation

00:32:22,240 --> 00:32:25,120
with uh sean

00:32:23,440 --> 00:32:26,799
to talk about how it's important to

00:32:25,120 --> 00:32:28,399
discuss your code the same way that

00:32:26,799 --> 00:32:30,320
mathematicians discuss proof with

00:32:28,399 --> 00:32:32,559
proofs with each other to get to like

00:32:30,320 --> 00:32:35,679
the ultimate version of your code

00:32:32,559 --> 00:32:37,120
um and so at times now when i make

00:32:35,679 --> 00:32:37,840
mistakes i'm gonna leave them in my

00:32:37,120 --> 00:32:40,320
slides

00:32:37,840 --> 00:32:42,159
and then correct them later and say you

00:32:40,320 --> 00:32:43,840
know just as stephanov said we all write

00:32:42,159 --> 00:32:45,760
off a code we all make mistakes

00:32:43,840 --> 00:32:47,760
and i think it's important especially as

00:32:45,760 --> 00:32:49,519
sort of leaders in the c plus community

00:32:47,760 --> 00:32:51,360
um for all the other c plus plus

00:32:49,519 --> 00:32:53,039
developers out there to see that even

00:32:51,360 --> 00:32:55,519
the people at the top

00:32:53,039 --> 00:32:56,720
we're all writing bad code and we all

00:32:55,519 --> 00:32:57,360
need to help each other to write better

00:32:56,720 --> 00:32:58,880
code so

00:32:57,360 --> 00:33:00,880
this is really important while we're on

00:32:58,880 --> 00:33:02,640
this digression on stepping off

00:33:00,880 --> 00:33:03,760
on stepping off papers.com which is a

00:33:02,640 --> 00:33:05,440
website that everybody should

00:33:03,760 --> 00:33:08,320
familiarize themselves with

00:33:05,440 --> 00:33:09,519
we can scroll down to the source code

00:33:08,320 --> 00:33:11,279
section

00:33:09,519 --> 00:33:12,960
and this was uh when i discovered this

00:33:11,279 --> 00:33:13,679
for other reasons but this was just so

00:33:12,960 --> 00:33:16,799
amazing

00:33:13,679 --> 00:33:17,679
um the first uh bullet point in this

00:33:16,799 --> 00:33:19,919
section

00:33:17,679 --> 00:33:22,159
is a scheme higher order programming

00:33:19,919 --> 00:33:23,600
library 1986 i'm not sure if that's a

00:33:22,159 --> 00:33:24,320
coincidence that it came out in the year

00:33:23,600 --> 00:33:25,760
that

00:33:24,320 --> 00:33:27,440
the structure interpretation of computer

00:33:25,760 --> 00:33:30,000
programs came out

00:33:27,440 --> 00:33:31,600
but you can see here on this page that

00:33:30,000 --> 00:33:33,279
the standard template library was

00:33:31,600 --> 00:33:34,480
implemented in multiple languages before

00:33:33,279 --> 00:33:36,240
it was implemented in c

00:33:34,480 --> 00:33:37,760
plus you can see here there's the java

00:33:36,240 --> 00:33:39,279
algorithm library there's the ada

00:33:37,760 --> 00:33:40,720
generic library

00:33:39,279 --> 00:33:43,039
the scheme higher order programming

00:33:40,720 --> 00:33:45,279
library this is very faintly

00:33:43,039 --> 00:33:46,720
sort of resembles what stl ultimately

00:33:45,279 --> 00:33:48,480
became

00:33:46,720 --> 00:33:49,760
but if you need another reason to go and

00:33:48,480 --> 00:33:52,080
read sick p

00:33:49,760 --> 00:33:53,760
know that the father and the author of

00:33:52,080 --> 00:33:54,960
the standard template library when he

00:33:53,760 --> 00:33:56,480
was first exploring

00:33:54,960 --> 00:33:58,240
uh the ideas of generics and higher

00:33:56,480 --> 00:34:00,880
order programming uh

00:33:58,240 --> 00:34:01,360
explored it in scheme and here's just a

00:34:00,880 --> 00:34:03,760
small

00:34:01,360 --> 00:34:04,799
uh you know snippet from the 81 page

00:34:03,760 --> 00:34:06,159
paper

00:34:04,799 --> 00:34:07,519
this paper is amazing i haven't fully

00:34:06,159 --> 00:34:08,480
read it but it's amazing for multiple

00:34:07,519 --> 00:34:11,040
reasons one

00:34:08,480 --> 00:34:12,960
you can see sort of here's the reduction

00:34:11,040 --> 00:34:15,040
uh operator

00:34:12,960 --> 00:34:16,800
that is making use of iterators he's

00:34:15,040 --> 00:34:19,440
exploring the idea of iterators here

00:34:16,800 --> 00:34:21,679
but on top of this the paper is

00:34:19,440 --> 00:34:22,720
scattered with little uh history tidbits

00:34:21,679 --> 00:34:24,000
so you can see here

00:34:22,720 --> 00:34:25,520
he's mentioning that the reduction

00:34:24,000 --> 00:34:26,960
operator was introduced by kenneth

00:34:25,520 --> 00:34:28,079
iverson in my favorite programming

00:34:26,960 --> 00:34:30,320
language apl

00:34:28,079 --> 00:34:32,079
and he has he has multiple of these sort

00:34:30,320 --> 00:34:34,480
of like little shout outs to

00:34:32,079 --> 00:34:36,320
other programming languages and uh sort

00:34:34,480 --> 00:34:38,800
of historical tidbits um

00:34:36,320 --> 00:34:39,679
which is just amazing so uh another

00:34:38,800 --> 00:34:42,800
reason to

00:34:39,679 --> 00:34:45,040
uh read sick p and to learn scheme uh

00:34:42,800 --> 00:34:46,000
alex alexander stephanov uh was doing

00:34:45,040 --> 00:34:48,240
this um

00:34:46,000 --> 00:34:49,679
you know ages ago uh what is that 34

00:34:48,240 --> 00:34:50,720
years 35 years depending on

00:34:49,679 --> 00:34:53,760
when you're watching this on youtube

00:34:50,720 --> 00:34:56,240
maybe even later end of digression so

00:34:53,760 --> 00:34:57,920
why did i go on that digression well i'm

00:34:56,240 --> 00:35:01,119
sure that there's some of you

00:34:57,920 --> 00:35:03,040
uh looking in the chat

00:35:01,119 --> 00:35:04,400
or looking at the screen and thinking in

00:35:03,040 --> 00:35:07,920
your head um

00:35:04,400 --> 00:35:07,920
why are we doing a stood swap here

00:35:08,079 --> 00:35:13,599
i realized this a couple days ago

00:35:11,119 --> 00:35:14,560
and it was devastating because this was

00:35:13,599 --> 00:35:17,760
a question that i've

00:35:14,560 --> 00:35:19,440
asked for uh months a couple years ago

00:35:17,760 --> 00:35:20,880
in interviews and so i'm very familiar

00:35:19,440 --> 00:35:23,119
with the answer to this question

00:35:20,880 --> 00:35:24,160
yet when i coded it up in preparing for

00:35:23,119 --> 00:35:25,920
this talk

00:35:24,160 --> 00:35:27,200
for some reason i used a stood swap and

00:35:25,920 --> 00:35:28,720
if you're familiar with

00:35:27,200 --> 00:35:31,040
andre alexandrescu's talk there's

00:35:28,720 --> 00:35:32,800
treasure everywhere you'll know that

00:35:31,040 --> 00:35:34,800
you should try to avoid swap whenever

00:35:32,800 --> 00:35:36,079
possible this talk delves into a couple

00:35:34,800 --> 00:35:37,680
different algorithms

00:35:36,079 --> 00:35:38,960
and optimizing them and in one of them

00:35:37,680 --> 00:35:39,920
he looks at i believe it was stood

00:35:38,960 --> 00:35:42,079
partition

00:35:39,920 --> 00:35:43,440
and uses this idea of something called

00:35:42,079 --> 00:35:45,520
vacancies if you're interested

00:35:43,440 --> 00:35:47,680
go watch the talk it's amazing but how

00:35:45,520 --> 00:35:49,040
using a vacant vacancy which enables you

00:35:47,680 --> 00:35:51,599
to avoid a swap

00:35:49,040 --> 00:35:53,040
um can lead to like in some cases a

00:35:51,599 --> 00:35:56,240
performance

00:35:53,040 --> 00:35:57,200
increase of like 40 um and so using this

00:35:56,240 --> 00:35:59,599
swap here

00:35:57,200 --> 00:36:00,720
is super super sub-optimal it doesn't

00:35:59,599 --> 00:36:02,480
make a performance difference in this

00:36:00,720 --> 00:36:03,680
code but it's just it's unnecessary and

00:36:02,480 --> 00:36:05,040
it also makes the code a little bit

00:36:03,680 --> 00:36:06,079
harder to read in my opinion so we can

00:36:05,040 --> 00:36:08,720
replace this

00:36:06,079 --> 00:36:09,760
uh with just uh setting b to be equal to

00:36:08,720 --> 00:36:10,880
a because that's essentially what we're

00:36:09,760 --> 00:36:12,320
doing we don't need the other side of

00:36:10,880 --> 00:36:12,800
the swap and we don't need the temporary

00:36:12,320 --> 00:36:15,119
copy

00:36:12,800 --> 00:36:15,839
that comes with that swap um so in the

00:36:15,119 --> 00:36:17,599
first case

00:36:15,839 --> 00:36:19,440
if our current element is greater than a

00:36:17,599 --> 00:36:20,240
just set b so you're basically shifting

00:36:19,440 --> 00:36:23,359
their top value

00:36:20,240 --> 00:36:26,079
a down to b and uh

00:36:23,359 --> 00:36:27,119
and then setting a equal to e um so

00:36:26,079 --> 00:36:28,800
that's all i have to say about this

00:36:27,119 --> 00:36:30,960
solution you can see here we're using c

00:36:28,800 --> 00:36:32,480
plus plus 20 concepts in the most

00:36:30,960 --> 00:36:34,560
general way that we possibly can by

00:36:32,480 --> 00:36:36,960
using the auto keyword um

00:36:34,560 --> 00:36:38,400
we're also making use of uh c plus plus

00:36:36,960 --> 00:36:39,920
14 generic lambdas

00:36:38,400 --> 00:36:41,760
we're making use of c plus plus 14

00:36:39,920 --> 00:36:44,079
function deduce return type we're making

00:36:41,760 --> 00:36:46,160
use of c plus plus 17 structure bindings

00:36:44,079 --> 00:36:48,160
and last but not least we're making use

00:36:46,160 --> 00:36:50,320
of c plus plus 17's uh

00:36:48,160 --> 00:36:51,359
c tab class template argument deduction

00:36:50,320 --> 00:36:52,160
and the fact that we don't have to

00:36:51,359 --> 00:36:54,079
specify

00:36:52,160 --> 00:36:55,680
the explicit return uh the explicit

00:36:54,079 --> 00:36:58,880
types of pair um

00:36:55,680 --> 00:37:00,880
so this code makes me really happy um

00:36:58,880 --> 00:37:02,560
some would argue that it's not enough

00:37:00,880 --> 00:37:04,560
it's not as nice as a for loop and i

00:37:02,560 --> 00:37:05,280
would have to vehemently disagree um we

00:37:04,560 --> 00:37:07,760
can use

00:37:05,280 --> 00:37:09,040
uh const at the top here because we're

00:37:07,760 --> 00:37:12,400
using an algorithm

00:37:09,040 --> 00:37:13,599
and um for me this is this is uh elegant

00:37:12,400 --> 00:37:14,640
code and the way that i would like to

00:37:13,599 --> 00:37:17,839
solve this problem

00:37:14,640 --> 00:37:20,160
let's take a look at a couple other

00:37:17,839 --> 00:37:21,440
solutions which are not as efficient so

00:37:20,160 --> 00:37:22,000
a couple of you might have been thinking

00:37:21,440 --> 00:37:25,040
of a certain

00:37:22,000 --> 00:37:28,079
algorithm and that is

00:37:25,040 --> 00:37:28,880
an element so here is a very verbose

00:37:28,079 --> 00:37:31,920
solution

00:37:28,880 --> 00:37:33,599
that is basically uh taking and

00:37:31,920 --> 00:37:35,520
the top two elements from our range and

00:37:33,599 --> 00:37:38,400
putting it at the front

00:37:35,520 --> 00:37:40,000
and then we have a transform to square

00:37:38,400 --> 00:37:40,560
the values and then accumulate to reduce

00:37:40,000 --> 00:37:43,359
them

00:37:40,560 --> 00:37:44,160
this is a bit verbose in my opinion for

00:37:43,359 --> 00:37:47,119
just

00:37:44,160 --> 00:37:48,240
squaring and summing up two values so i

00:37:47,119 --> 00:37:50,800
personally prefer

00:37:48,240 --> 00:37:53,359
uh this version but i'm sure there's

00:37:50,800 --> 00:37:55,760
differing opinions on which is better

00:37:53,359 --> 00:37:57,040
and note that we are making use of the c

00:37:55,760 --> 00:37:59,599
plus plus 20

00:37:57,040 --> 00:38:01,119
uh range algorithm and elements so

00:37:59,599 --> 00:38:03,680
instead of having to pass

00:38:01,119 --> 00:38:05,119
three iterators here we're passing uh

00:38:03,680 --> 00:38:08,000
the data structure v

00:38:05,119 --> 00:38:08,640
and then uh only one iterator so this is

00:38:08,000 --> 00:38:11,119
really nice

00:38:08,640 --> 00:38:12,960
um i love the range uh algorithms that

00:38:11,119 --> 00:38:14,720
are coming in c plus plus 20.

00:38:12,960 --> 00:38:16,960
um note that one of the downsides of

00:38:14,720 --> 00:38:20,960
this though is that we have to modify

00:38:16,960 --> 00:38:23,200
the uh the original data structure

00:38:20,960 --> 00:38:24,560
so in that case in that sense it's it's

00:38:23,200 --> 00:38:27,359
not optimal and also to

00:38:24,560 --> 00:38:28,079
uh element isn't going to be anywhere

00:38:27,359 --> 00:38:31,599
nearly as

00:38:28,079 --> 00:38:34,400
performant as just a single reduction

00:38:31,599 --> 00:38:35,920
so uh if we take a look at what modern

00:38:34,400 --> 00:38:38,000
features we're using here c plus plus 20

00:38:35,920 --> 00:38:38,960
concepts again c plus 14 function deduce

00:38:38,000 --> 00:38:41,599
return type

00:38:38,960 --> 00:38:43,280
c tab once again from 17 and c plus plus

00:38:41,599 --> 00:38:46,000
20 uh ranges and

00:38:43,280 --> 00:38:48,240
uh just for curiosity's sake i profiled

00:38:46,000 --> 00:38:50,400
these two so this is with five elements

00:38:48,240 --> 00:38:52,160
uh stood accumulate versus the two

00:38:50,400 --> 00:38:53,760
different element solutions so clearly

00:38:52,160 --> 00:38:54,960
accumulates better and when we kick up

00:38:53,760 --> 00:38:57,280
the number of elements

00:38:54,960 --> 00:38:58,320
um of course accumulate uh continues to

00:38:57,280 --> 00:39:00,320
do better and also

00:38:58,320 --> 00:39:01,599
on the github not in the slide deck i

00:39:00,320 --> 00:39:03,680
have profiling

00:39:01,599 --> 00:39:04,880
of a comparison against accumulate

00:39:03,680 --> 00:39:06,880
versus for loops

00:39:04,880 --> 00:39:08,079
and sure enough the profiling shows that

00:39:06,880 --> 00:39:11,200
accumulate is

00:39:08,079 --> 00:39:12,320
in all cases just as fast or faster than

00:39:11,200 --> 00:39:15,359
raw for loops

00:39:12,320 --> 00:39:18,320
which is fantastic so that is the end

00:39:15,359 --> 00:39:19,520
of our uh problem one i can see or a

00:39:18,320 --> 00:39:22,640
warm-up problem i should say

00:39:19,520 --> 00:39:24,720
i can see we have a question uh

00:39:22,640 --> 00:39:27,520
which where is just a troll from jf so

00:39:24,720 --> 00:39:29,280
we're not going to read that

00:39:27,520 --> 00:39:31,760
moving on to problem one so this is

00:39:29,280 --> 00:39:35,119
called uh even uh fibonacci

00:39:31,760 --> 00:39:36,640
um and this problem uh looks at

00:39:35,119 --> 00:39:38,160
basically two different problems so you

00:39:36,640 --> 00:39:40,320
can see here we have even fibonacci

00:39:38,160 --> 00:39:43,119
versus some odd squares so in the book

00:39:40,320 --> 00:39:44,400
it shows two different uh procedures one

00:39:43,119 --> 00:39:46,480
called some odd squares

00:39:44,400 --> 00:39:48,000
and then one called even fibs i'll

00:39:46,480 --> 00:39:49,680
quickly go through this but

00:39:48,000 --> 00:39:51,440
it's not uh super important to

00:39:49,680 --> 00:39:52,800
understand what this lisp code is doing

00:39:51,440 --> 00:39:54,400
but essentially

00:39:52,800 --> 00:39:56,480
given a procedure that takes a single

00:39:54,400 --> 00:39:58,880
argument that takes a tree

00:39:56,480 --> 00:40:00,960
we want to basically collect all the odd

00:39:58,880 --> 00:40:03,440
values at the leafs of the tree

00:40:00,960 --> 00:40:05,119
and then sum them up so we're using a

00:40:03,440 --> 00:40:06,800
conditional expression once again

00:40:05,119 --> 00:40:09,520
you can consider this to be like a c

00:40:06,800 --> 00:40:11,599
plus a switch case statement

00:40:09,520 --> 00:40:13,280
and then we've got our base case where

00:40:11,599 --> 00:40:16,240
our nodes are empty

00:40:13,280 --> 00:40:16,720
uh we just return zero then if we are at

00:40:16,240 --> 00:40:19,520
a

00:40:16,720 --> 00:40:20,880
uh leaf node then we want to check is it

00:40:19,520 --> 00:40:23,119
odd if so

00:40:20,880 --> 00:40:24,960
uh square it so i guess yes some odd

00:40:23,119 --> 00:40:26,000
squares i i missed out squares in the

00:40:24,960 --> 00:40:27,760
implementation

00:40:26,000 --> 00:40:29,440
otherwise return zero and if we're not

00:40:27,760 --> 00:40:31,760
at a leaf node then we're just gonna go

00:40:29,440 --> 00:40:34,640
to our else condition and recurse down

00:40:31,760 --> 00:40:36,480
um uh by calling some odd squares on the

00:40:34,640 --> 00:40:37,920
car and the cutter of the current node

00:40:36,480 --> 00:40:39,440
that we're at to go down the left branch

00:40:37,920 --> 00:40:41,359
and the right branch

00:40:39,440 --> 00:40:42,880
if we move to our next solution we're

00:40:41,359 --> 00:40:45,040
going to go through this one even less

00:40:42,880 --> 00:40:46,880
and this is basically generating even

00:40:45,040 --> 00:40:48,560
fibonacci numbers

00:40:46,880 --> 00:40:50,960
so we're doing this with an internal

00:40:48,560 --> 00:40:53,040
procedure so even fibs takes a single

00:40:50,960 --> 00:40:56,160
integer n and then it defines

00:40:53,040 --> 00:40:58,800
a internal procedure called next and

00:40:56,160 --> 00:41:01,760
then inside here basically you can see

00:40:58,800 --> 00:41:02,640
that there's an even in an if expression

00:41:01,760 --> 00:41:05,040
happening

00:41:02,640 --> 00:41:06,480
and ultimately what this code is doing

00:41:05,040 --> 00:41:09,040
is it's making use of this

00:41:06,480 --> 00:41:10,560
fib function here to generate fibonacci

00:41:09,040 --> 00:41:11,920
numbers in linear time so this is a very

00:41:10,560 --> 00:41:14,240
sub-optimal solution

00:41:11,920 --> 00:41:15,760
and it's filtering out any odd

00:41:14,240 --> 00:41:16,880
fibonaccis and just keeping the even

00:41:15,760 --> 00:41:18,960
ones

00:41:16,880 --> 00:41:20,000
and we kick off this outer procedure

00:41:18,960 --> 00:41:23,280
even fibs by making

00:41:20,000 --> 00:41:25,520
a call to the internal procedure uh next

00:41:23,280 --> 00:41:26,880
um so like i said it's not entirely

00:41:25,520 --> 00:41:27,839
important to understand what this code

00:41:26,880 --> 00:41:29,599
is doing

00:41:27,839 --> 00:41:31,520
the point that i want to highlight here

00:41:29,599 --> 00:41:33,200
is that the textbook goes on to show the

00:41:31,520 --> 00:41:36,880
following so if we switch back

00:41:33,200 --> 00:41:38,079
to our um even fibs or even fibs with

00:41:36,880 --> 00:41:40,480
the fib code

00:41:38,079 --> 00:41:41,760
uh the text points out the following is

00:41:40,480 --> 00:41:44,000
that um

00:41:41,760 --> 00:41:45,280
these two solutions don't look like they

00:41:44,000 --> 00:41:47,280
have much in common

00:41:45,280 --> 00:41:48,640
um but if we actually implement them in

00:41:47,280 --> 00:41:51,280
terms of

00:41:48,640 --> 00:41:53,119
algorithms or higher order procedures we

00:41:51,280 --> 00:41:55,280
we can see that we can make use

00:41:53,119 --> 00:41:56,480
of a lot of the same algorithms those

00:41:55,280 --> 00:41:58,640
being accumulate

00:41:56,480 --> 00:42:00,319
filter and map so at the bottom here we

00:41:58,640 --> 00:42:02,160
have a different implementation of even

00:42:00,319 --> 00:42:04,079
fibs that makes use of accumulate

00:42:02,160 --> 00:42:05,760
makes use of filter where we're

00:42:04,079 --> 00:42:06,640
filtering in the even ones and then

00:42:05,760 --> 00:42:08,079
makes use of map

00:42:06,640 --> 00:42:11,119
and then enumerate interval here is

00:42:08,079 --> 00:42:12,960
similar to iota and c plus plus

00:42:11,119 --> 00:42:15,520
we can reorganize this code at the top

00:42:12,960 --> 00:42:17,280
here so that we have the

00:42:15,520 --> 00:42:19,760
outer procedure now as an internal

00:42:17,280 --> 00:42:23,359
procedure but the point here is that

00:42:19,760 --> 00:42:25,359
uh we're making use of these algorithms

00:42:23,359 --> 00:42:26,880
which makes the code a lot easier to

00:42:25,359 --> 00:42:28,000
read is one of the points that this

00:42:26,880 --> 00:42:29,839
textbook points out

00:42:28,000 --> 00:42:31,200
and there's an amazing footnote which

00:42:29,839 --> 00:42:33,040
i'm gonna read uh

00:42:31,200 --> 00:42:34,640
and it's it's by far my favorite

00:42:33,040 --> 00:42:36,240
footnote of the book and there are and

00:42:34,640 --> 00:42:38,400
uh there are an amazing number

00:42:36,240 --> 00:42:41,040
of footnotes in this book uh so the

00:42:38,400 --> 00:42:42,640
footnote reads richard waters in 1979

00:42:41,040 --> 00:42:44,880
developed a program that automatically

00:42:42,640 --> 00:42:47,200
analyzes traditional fortran programs

00:42:44,880 --> 00:42:48,560
viewing them in terms of maps filters

00:42:47,200 --> 00:42:51,599
and accumulations

00:42:48,560 --> 00:42:53,359
he found that fully 90 of the code in

00:42:51,599 --> 00:42:54,000
the fortran scientific subroutine

00:42:53,359 --> 00:42:57,119
package

00:42:54,000 --> 00:42:59,839
fits neatly into this paradigm

00:42:57,119 --> 00:43:01,680
and if we go to this paper the paper is

00:42:59,839 --> 00:43:02,400
called a method for analyzing loop

00:43:01,680 --> 00:43:05,920
programs

00:43:02,400 --> 00:43:07,040
in 19 1979 so you know sean parent he's

00:43:05,920 --> 00:43:09,680
been talking about loops

00:43:07,040 --> 00:43:11,280
more recently but even back in the 70s

00:43:09,680 --> 00:43:13,040
they were analyzing loops

00:43:11,280 --> 00:43:14,400
um and saying the following if we if we

00:43:13,040 --> 00:43:18,560
go to the part that mentions the

00:43:14,400 --> 00:43:22,640
70 it says of the 70 273 augmentations

00:43:18,560 --> 00:43:23,520
uh 243 89 were easy to recognize as

00:43:22,640 --> 00:43:26,640
either a product

00:43:23,520 --> 00:43:27,760
a sum a max a min a count or a trivial

00:43:26,640 --> 00:43:30,240
augmentation

00:43:27,760 --> 00:43:31,760
um so a trivial augmentation referring

00:43:30,240 --> 00:43:35,040
to the maps and the filters

00:43:31,760 --> 00:43:36,480
uh so this is this is unbelievable 1979

00:43:35,040 --> 00:43:38,720
and they're doing analysis of code and

00:43:36,480 --> 00:43:41,040
fortran and finding that 90

00:43:38,720 --> 00:43:42,240
of the for loops could just be

00:43:41,040 --> 00:43:44,079
algorithms

00:43:42,240 --> 00:43:45,280
so just absolutely phenomenal if we go

00:43:44,079 --> 00:43:46,720
back to the footnote

00:43:45,280 --> 00:43:48,400
and continue to read it says one of the

00:43:46,720 --> 00:43:49,760
reasons for the success of lisp as a

00:43:48,400 --> 00:43:51,680
programming language is that

00:43:49,760 --> 00:43:53,040
lisps provide a standard medium for

00:43:51,680 --> 00:43:54,319
expressing order collections so that

00:43:53,040 --> 00:43:55,920
they can be manipulated

00:43:54,319 --> 00:43:58,079
using higher order procedures or

00:43:55,920 --> 00:43:59,760
operations the programming language apl

00:43:58,079 --> 00:44:01,839
owes much of its power and appeal to a

00:43:59,760 --> 00:44:03,839
similar choice and apl all data

00:44:01,839 --> 00:44:05,440
are represented as arrays and there is a

00:44:03,839 --> 00:44:06,079
universal and convenient set of generic

00:44:05,440 --> 00:44:08,400
operators

00:44:06,079 --> 00:44:10,160
for all sorts of array operations so

00:44:08,400 --> 00:44:10,880
just for fun to look at what each of

00:44:10,160 --> 00:44:12,800
those

00:44:10,880 --> 00:44:14,000
uh five reductions that were mentioned

00:44:12,800 --> 00:44:16,720
in the paper um

00:44:14,000 --> 00:44:17,119
this is product multiply reduce this is

00:44:16,720 --> 00:44:20,240
sum

00:44:17,119 --> 00:44:21,920
plus reduce this is max max reduce and

00:44:20,240 --> 00:44:22,640
this is min element min reduce and this

00:44:21,920 --> 00:44:25,839
is count

00:44:22,640 --> 00:44:27,200
so uh this textbook mentions apl and

00:44:25,839 --> 00:44:30,560
every single one of the three

00:44:27,200 --> 00:44:32,560
uh professors sussman abelson and harvey

00:44:30,560 --> 00:44:34,079
across the mit and berkeley lectures at

00:44:32,560 --> 00:44:36,240
some point talk about apl

00:44:34,079 --> 00:44:37,280
uh which is just fantastic because i

00:44:36,240 --> 00:44:38,480
think there's a lot we can learn from

00:44:37,280 --> 00:44:41,119
abl

00:44:38,480 --> 00:44:41,760
so if we take a look at the c plus

00:44:41,119 --> 00:44:44,240
version

00:44:41,760 --> 00:44:45,760
of the even fibs code that we saw before

00:44:44,240 --> 00:44:48,400
uh this is what it might look like

00:44:45,760 --> 00:44:50,880
we are using rv as a shortcut name space

00:44:48,400 --> 00:44:53,040
for stood ranges views we can first

00:44:50,880 --> 00:44:54,160
zoom in on this fib function which is

00:44:53,040 --> 00:44:55,839
our helper function to

00:44:54,160 --> 00:44:57,920
in linear time calculate fibonacci

00:44:55,839 --> 00:44:58,720
numbers um i'm not going to spend much

00:44:57,920 --> 00:45:01,040
time on this

00:44:58,720 --> 00:45:02,560
but it's sort of cool because we have a

00:45:01,040 --> 00:45:05,119
recursive lambda here

00:45:02,560 --> 00:45:06,720
essentially by default if you're just

00:45:05,119 --> 00:45:08,560
using the auto keyword you can't have a

00:45:06,720 --> 00:45:10,880
recursive lambda but if you use a stood

00:45:08,560 --> 00:45:14,000
function to explicitly declare the type

00:45:10,880 --> 00:45:16,880
of your lambda you can then capture it

00:45:14,000 --> 00:45:18,319
and call it which is super awesome and

00:45:16,880 --> 00:45:19,119
so you can see the same way that we were

00:45:18,319 --> 00:45:21,280
kicking off

00:45:19,119 --> 00:45:22,880
our fib function by making a call to the

00:45:21,280 --> 00:45:25,920
internal procedure next

00:45:22,880 --> 00:45:26,880
we are um making a a call to the

00:45:25,920 --> 00:45:28,880
internal

00:45:26,880 --> 00:45:30,880
quote unquote lambda fib iter and

00:45:28,880 --> 00:45:33,680
passing it the values one zero and n

00:45:30,880 --> 00:45:34,319
uh to kick off this fib function if we

00:45:33,680 --> 00:45:36,560
zoom out

00:45:34,319 --> 00:45:38,720
and then zoom back in this is probably

00:45:36,560 --> 00:45:41,200
one of my favorite pieces of code

00:45:38,720 --> 00:45:42,960
from this presentation because this is

00:45:41,200 --> 00:45:45,200
completely possible in c plus

00:45:42,960 --> 00:45:47,200
20. so this is making use of the ranges

00:45:45,200 --> 00:45:50,640
views in the ranges header which

00:45:47,200 --> 00:45:52,079
is available on godbolt and gcc 10.2

00:45:50,640 --> 00:45:53,680
um you can see here that we're creating

00:45:52,079 --> 00:45:56,000
a list of the numbers uh

00:45:53,680 --> 00:45:57,280
zero to n plus one exclusive so

00:45:56,000 --> 00:45:58,720
basically zero to n

00:45:57,280 --> 00:46:00,319
then transforming them using the

00:45:58,720 --> 00:46:01,119
fibonacci helper function that we just

00:46:00,319 --> 00:46:03,680
implemented

00:46:01,119 --> 00:46:05,680
and then filtering out uh any of the odd

00:46:03,680 --> 00:46:06,319
numbers aka filtering in the even

00:46:05,680 --> 00:46:08,240
numbers

00:46:06,319 --> 00:46:10,319
and this will do the exact same thing

00:46:08,240 --> 00:46:11,280
that the previous code that we saw in

00:46:10,319 --> 00:46:14,640
scheme does

00:46:11,280 --> 00:46:15,680
um this this is just it's so elegant in

00:46:14,640 --> 00:46:18,240
my opinion

00:46:15,680 --> 00:46:19,839
um this is just beautiful uh i

00:46:18,240 --> 00:46:20,960
absolutely love piping operations

00:46:19,839 --> 00:46:23,760
together like this

00:46:20,960 --> 00:46:24,079
and when you um compare this to sort of

00:46:23,760 --> 00:46:26,800
the

00:46:24,079 --> 00:46:28,160
uh non-idiomatic non-ranges code that

00:46:26,800 --> 00:46:29,839
just uses for loops

00:46:28,160 --> 00:46:32,240
uh it doesn't even it's not even a

00:46:29,839 --> 00:46:34,720
closed contest in my opinion

00:46:32,240 --> 00:46:35,280
so uh if we zoom out once again and look

00:46:34,720 --> 00:46:37,200
at all the

00:46:35,280 --> 00:46:39,359
uh features we've got c plus plus 20

00:46:37,200 --> 00:46:41,040
ranges and all of these iota transform

00:46:39,359 --> 00:46:41,359
and filter are in c plus plus 20. we've

00:46:41,040 --> 00:46:43,520
got c

00:46:41,359 --> 00:46:44,560
plus plus 20 concepts using auto which

00:46:43,520 --> 00:46:46,160
isn't constrained

00:46:44,560 --> 00:46:48,400
um but we could constrain it if we

00:46:46,160 --> 00:46:50,800
wanted to uh be more comprehensive

00:46:48,400 --> 00:46:51,440
c plus 14 generic lambdas and c plus

00:46:50,800 --> 00:46:53,520
plus

00:46:51,440 --> 00:46:55,119
14 function deduce return type so

00:46:53,520 --> 00:46:57,200
awesome gotta love modern c

00:46:55,119 --> 00:46:58,880
plus moving on to the second last

00:46:57,200 --> 00:46:59,680
problem uh which we're gonna go quickly

00:46:58,880 --> 00:47:02,560
through because

00:46:59,680 --> 00:47:04,480
i've only got 13 minutes left and um

00:47:02,560 --> 00:47:07,119
this is uh focusing on some

00:47:04,480 --> 00:47:07,760
approximations of pi um so in the book

00:47:07,119 --> 00:47:09,760
there are

00:47:07,760 --> 00:47:11,680
this this isn't even an exhaustive list

00:47:09,760 --> 00:47:14,160
there's a monte carlo estimations for pi

00:47:11,680 --> 00:47:14,720
as well as i believe a couple others um

00:47:14,160 --> 00:47:17,359
the first

00:47:14,720 --> 00:47:17,760
estimation for pi here at the top is uh

00:47:17,359 --> 00:47:19,359
um

00:47:17,760 --> 00:47:20,960
attributed to john wallace we're not

00:47:19,359 --> 00:47:22,480
going to look at this one although in my

00:47:20,960 --> 00:47:24,000
opinion it's the most interesting and i

00:47:22,480 --> 00:47:26,000
promise i will come back to this

00:47:24,000 --> 00:47:27,040
in a future talk but the two we're going

00:47:26,000 --> 00:47:29,680
to focus on

00:47:27,040 --> 00:47:31,119
are the leibniz approximations for pi so

00:47:29,680 --> 00:47:33,599
these are just two statements

00:47:31,119 --> 00:47:35,040
of the same approximation and uh we're

00:47:33,599 --> 00:47:36,720
going to look at how to solve these in c

00:47:35,040 --> 00:47:38,559
plus plus using ranges once again so

00:47:36,720 --> 00:47:40,240
we'll start uh with the one at the

00:47:38,559 --> 00:47:42,240
bottom so we've got pi over eight

00:47:40,240 --> 00:47:44,079
is equal to one over one times three

00:47:42,240 --> 00:47:46,880
plus one over five times seven

00:47:44,079 --> 00:47:48,880
plus one over nine times eleven um so

00:47:46,880 --> 00:47:51,119
how could we go about solving this

00:47:48,880 --> 00:47:52,000
um the first thing a good starting point

00:47:51,119 --> 00:47:54,000
would be to generate

00:47:52,000 --> 00:47:55,280
odd numbers because then we have sort of

00:47:54,000 --> 00:47:57,440
the values that are needed for the

00:47:55,280 --> 00:48:00,319
denominators of these fractions

00:47:57,440 --> 00:48:01,599
um once we have the odd numbers if we

00:48:00,319 --> 00:48:04,240
could group them into chunks of two

00:48:01,599 --> 00:48:06,240
that'd be a good next step

00:48:04,240 --> 00:48:08,319
then if we transform each of those

00:48:06,240 --> 00:48:09,760
chunks by multiplying them together

00:48:08,319 --> 00:48:11,440
because that's what the formula does

00:48:09,760 --> 00:48:12,800
multiplies them and inverting them

00:48:11,440 --> 00:48:14,960
we then have the different fractions

00:48:12,800 --> 00:48:16,880
needed to compute this value

00:48:14,960 --> 00:48:18,160
and once we're done this all we have to

00:48:16,880 --> 00:48:21,040
do is add them up

00:48:18,160 --> 00:48:21,440
and multiply by eight and we're done and

00:48:21,040 --> 00:48:22,720
so

00:48:21,440 --> 00:48:25,200
i've sort of cheated here a little bit

00:48:22,720 --> 00:48:25,760
by explicitly using uh the words that i

00:48:25,200 --> 00:48:27,680
need

00:48:25,760 --> 00:48:29,119
for the algorithms uh but we've got

00:48:27,680 --> 00:48:32,400
generate chunk

00:48:29,119 --> 00:48:33,520
transform and add uh so uh a common

00:48:32,400 --> 00:48:36,880
uh generate function that we've already

00:48:33,520 --> 00:48:40,000
seen a couple times is iota

00:48:36,880 --> 00:48:41,040
and then we can pipe the results of iota

00:48:40,000 --> 00:48:43,200
0 to n

00:48:41,040 --> 00:48:45,119
to transform to get our odd numbers so

00:48:43,200 --> 00:48:46,240
iota plus transform is a neat way of

00:48:45,119 --> 00:48:48,240
getting odd numbers

00:48:46,240 --> 00:48:49,680
if you multiply each of those by two and

00:48:48,240 --> 00:48:51,760
then add one to it

00:48:49,680 --> 00:48:52,960
um alternatively you can there's a

00:48:51,760 --> 00:48:54,480
couple different ways you can do it with

00:48:52,960 --> 00:48:55,200
different values but this is just one of

00:48:54,480 --> 00:48:57,200
them

00:48:55,200 --> 00:49:00,160
once we have our odd numbers here we

00:48:57,200 --> 00:49:02,079
just chunk them using a view in range v3

00:49:00,160 --> 00:49:04,400
that doesn't exist in c plus plus 20 but

00:49:02,079 --> 00:49:05,200
might exist in c plus plus 23 called

00:49:04,400 --> 00:49:07,440
chunk

00:49:05,200 --> 00:49:09,200
and then we transform it once again by

00:49:07,440 --> 00:49:10,640
multiplying the two values in each of

00:49:09,200 --> 00:49:12,160
our chunks which we can get access to

00:49:10,640 --> 00:49:13,440
using the bracket operators and then

00:49:12,160 --> 00:49:15,599
dividing it

00:49:13,440 --> 00:49:17,599
or doing one over to get the inverse and

00:49:15,599 --> 00:49:19,040
then we just accumulate using plus and

00:49:17,599 --> 00:49:21,200
an initial value of zero

00:49:19,040 --> 00:49:22,960
this is just uh in the hs namespace so

00:49:21,200 --> 00:49:25,920
that we can make accumulate pipeable

00:49:22,960 --> 00:49:27,920
um check out uh tristan brindle's uh

00:49:25,920 --> 00:49:29,599
ranges talk that he gave yesterday

00:49:27,920 --> 00:49:30,960
to hear more about sort of the numeric

00:49:29,599 --> 00:49:33,119
uh capability

00:49:30,960 --> 00:49:34,480
and implementation of um the numeric

00:49:33,119 --> 00:49:35,440
algorithms that don't exist yet in c

00:49:34,480 --> 00:49:36,480
plus plus 20.

00:49:35,440 --> 00:49:38,800
and then once we have this we just

00:49:36,480 --> 00:49:39,200
multiply by eight um and once again this

00:49:38,800 --> 00:49:42,400
code

00:49:39,200 --> 00:49:45,040
makes me um extremely happy uh

00:49:42,400 --> 00:49:45,839
just it's the pipeline model the output

00:49:45,040 --> 00:49:47,280
of one

00:49:45,839 --> 00:49:49,680
operation is the input of the next

00:49:47,280 --> 00:49:51,280
operation um this makes me extremely

00:49:49,680 --> 00:49:54,480
happy

00:49:51,280 --> 00:49:56,599
um and if we uh use uh

00:49:54,480 --> 00:50:00,480
format to print this out you'll get

00:49:56,599 --> 00:50:03,440
3.14149 which is pretty close

00:50:00,480 --> 00:50:03,440
a couple decimal places

00:50:11,990 --> 00:50:17,739
[Music]

00:50:19,520 --> 00:50:25,359
of this one uh a first good step once

00:50:22,800 --> 00:50:26,800
n would be to generate odd numbers then

00:50:25,359 --> 00:50:29,040
what we need to do this would be

00:50:26,800 --> 00:50:30,559
to zip with it repeating numbers 1 and

00:50:29,040 --> 00:50:31,280
negative 1. so then you end up with

00:50:30,559 --> 00:50:33,359
tuples

00:50:31,280 --> 00:50:34,960
of sort of each of the odd numbers and a

00:50:33,359 --> 00:50:36,960
1 or negative 1.

00:50:34,960 --> 00:50:38,480
and if we multiply those so we transform

00:50:36,960 --> 00:50:39,280
the odd numbers by inverting them to get

00:50:38,480 --> 00:50:41,520
the fraction

00:50:39,280 --> 00:50:42,800
and then by multiplying them multiplying

00:50:41,520 --> 00:50:43,520
the corresponding one or negative one

00:50:42,800 --> 00:50:45,599
that they're with

00:50:43,520 --> 00:50:47,280
we'll end up with the correct term in

00:50:45,599 --> 00:50:50,559
our fraction

00:50:47,280 --> 00:50:53,119
then once again we add these up

00:50:50,559 --> 00:50:53,680
we can buy four um so taking a look at

00:50:53,119 --> 00:50:55,200
this code

00:50:53,680 --> 00:50:56,559
doing the same sort of trick where we

00:50:55,200 --> 00:50:57,200
highlight the different algorithms that

00:50:56,559 --> 00:50:58,800
we need

00:50:57,200 --> 00:51:00,800
um note that repeating isn't purple

00:50:58,800 --> 00:51:02,480
because it's on the same line but also

00:51:00,800 --> 00:51:04,319
uh the algorithm that we want for this

00:51:02,480 --> 00:51:06,880
is an algorithm called cycle

00:51:04,319 --> 00:51:08,319
um so this is the second approximation

00:51:06,880 --> 00:51:10,079
for pi

00:51:08,319 --> 00:51:11,520
using a sort of different formula here

00:51:10,079 --> 00:51:14,240
we have our signs 1

00:51:11,520 --> 00:51:14,240
and negative 1.

00:51:17,040 --> 00:51:20,800
comments in the chat that say anyone

00:51:19,520 --> 00:51:23,839
else losing chunks

00:51:20,800 --> 00:51:23,839
of video

00:51:31,760 --> 00:51:36,800
i will continue and hopefully this isn't

00:51:33,520 --> 00:51:41,599
a problem for um

00:51:36,800 --> 00:51:44,319
oh i'm back the video is very choppy

00:51:41,599 --> 00:51:45,680
okay i slowed down uh and apparently

00:51:44,319 --> 00:51:47,200
it's better now hopefully it stays this

00:51:45,680 --> 00:51:49,200
way so we have our signs

00:51:47,200 --> 00:51:50,800
uh one and negative one that we're going

00:51:49,200 --> 00:51:52,319
to pass the cycle here

00:51:50,800 --> 00:51:55,359
and then we have a call to zip width so

00:51:52,319 --> 00:51:58,800
zipwidth takes a binary operator

00:51:55,359 --> 00:51:59,680
um and or i should say an inner n area

00:51:58,800 --> 00:52:02,640
operator and then

00:51:59,680 --> 00:52:04,000
n ranges so here we're taking two ranges

00:52:02,640 --> 00:52:05,200
and a binary operator so

00:52:04,000 --> 00:52:06,800
we're getting our odd numbers the same

00:52:05,200 --> 00:52:08,720
way we did in our previous solution

00:52:06,800 --> 00:52:10,800
which is piping iota to transform and

00:52:08,720 --> 00:52:12,800
then doing the two times plus one

00:52:10,800 --> 00:52:13,920
and then we're getting a repeating one

00:52:12,800 --> 00:52:15,920
negative one by just

00:52:13,920 --> 00:52:17,359
passing this to cycle so once we have

00:52:15,920 --> 00:52:18,720
these two ranges

00:52:17,359 --> 00:52:20,160
these get zipped together and

00:52:18,720 --> 00:52:21,599
transformed with our zip width and our

00:52:20,160 --> 00:52:24,000
binary operator which

00:52:21,599 --> 00:52:25,599
inverts the odd number e and then

00:52:24,000 --> 00:52:27,040
multiplies it with the sign

00:52:25,599 --> 00:52:29,920
and then once we've done this we just

00:52:27,040 --> 00:52:32,960
add up all our numbers multiply by four

00:52:29,920 --> 00:52:34,400
and we're done and because we are down

00:52:32,960 --> 00:52:35,200
to eight minutes i'm just going to move

00:52:34,400 --> 00:52:37,359
along

00:52:35,200 --> 00:52:38,319
um this is a alternate way of solving

00:52:37,359 --> 00:52:40,880
the problem

00:52:38,319 --> 00:52:41,520
note uh once again stepanov we write bad

00:52:40,880 --> 00:52:44,160
code

00:52:41,520 --> 00:52:46,319
in that we're using immutable lambda

00:52:44,160 --> 00:52:48,400
with a captured sign that just toggles

00:52:46,319 --> 00:52:50,160
but this expression here we do not need

00:52:48,400 --> 00:52:51,359
to do in order to toggle we can just

00:52:50,160 --> 00:52:53,359
multiply

00:52:51,359 --> 00:52:55,040
by negative one in order to get toggling

00:52:53,359 --> 00:52:57,119
ones and negative ones so

00:52:55,040 --> 00:52:58,559
uh once again we write back code and we

00:52:57,119 --> 00:52:59,920
can all do better by iterating and

00:52:58,559 --> 00:53:01,920
discussing

00:52:59,920 --> 00:53:03,040
but yeah this is the second solution and

00:53:01,920 --> 00:53:06,640
as i mentioned

00:53:03,040 --> 00:53:09,440
i will uh come back to the john wallace

00:53:06,640 --> 00:53:10,720
pi approximation in a follow-up talk in

00:53:09,440 --> 00:53:12,800
the future

00:53:10,720 --> 00:53:14,079
so last but not least we have my

00:53:12,800 --> 00:53:17,200
favorite problem

00:53:14,079 --> 00:53:19,359
um of the whole talk and it is

00:53:17,200 --> 00:53:20,960
ramanujan numbers um so i saw in the

00:53:19,359 --> 00:53:21,359
chat earlier someone pointing out that

00:53:20,960 --> 00:53:23,119
oh

00:53:21,359 --> 00:53:24,880
uh you know that's awesome that you're

00:53:23,119 --> 00:53:26,559
using a ramona john number in your

00:53:24,880 --> 00:53:29,440
example so what is

00:53:26,559 --> 00:53:30,720
a ramanajam number um it comes from this

00:53:29,440 --> 00:53:32,800
footnote in the book that says the

00:53:30,720 --> 00:53:34,640
following to quote from g.h hardy's

00:53:32,800 --> 00:53:36,160
obituary of romanojon

00:53:34,640 --> 00:53:37,760
it was mr littlewood i believe who

00:53:36,160 --> 00:53:39,440
remarked that every positive integer was

00:53:37,760 --> 00:53:40,240
one of his friends i remember once going

00:53:39,440 --> 00:53:42,160
to see him

00:53:40,240 --> 00:53:43,920
when he was lying ill at putney i had

00:53:42,160 --> 00:53:46,079
written in taxicab number

00:53:43,920 --> 00:53:47,680
uh 1729 and remarked that the number

00:53:46,079 --> 00:53:48,960
seemed to be a rather dull one

00:53:47,680 --> 00:53:51,040
and that i hoped it was not an

00:53:48,960 --> 00:53:52,640
unfavorable omen no he replied

00:53:51,040 --> 00:53:54,319
it is a very interesting number it is

00:53:52,640 --> 00:53:56,319
the smallest number expressible as the

00:53:54,319 --> 00:53:58,240
sum of two cubes in two different ways

00:53:56,319 --> 00:53:59,680
uh this is awesome because when i read

00:53:58,240 --> 00:54:00,480
this i was like wait a second i've seen

00:53:59,680 --> 00:54:02,000
this in a movie

00:54:00,480 --> 00:54:03,520
um there's a movie called the man who

00:54:02,000 --> 00:54:06,800
knew infinity which is

00:54:03,520 --> 00:54:08,559
uh the the story of ramanujan so let's

00:54:06,800 --> 00:54:09,680
take a look at uh the clip from this

00:54:08,559 --> 00:54:10,960
video and hopefully it comes through

00:54:09,680 --> 00:54:13,119
okay

00:54:10,960 --> 00:54:14,000
sorry i'm late bloody cab driving got

00:54:13,119 --> 00:54:15,760
lost

00:54:14,000 --> 00:54:18,040
should have known for his number and

00:54:15,760 --> 00:54:21,520
what was that tomorrow dull one

00:54:18,040 --> 00:54:23,920
1729 no hardy

00:54:21,520 --> 00:54:25,680
it is a very interesting number is the

00:54:23,920 --> 00:54:29,359
smallest number expressible as the sum

00:54:25,680 --> 00:54:29,359
of two cubes in two different ways

00:54:31,119 --> 00:54:34,400
so this is awesome uh go check this

00:54:32,880 --> 00:54:37,760
movie out i mean it's not

00:54:34,400 --> 00:54:39,040
it's not the the uh most amazing movie

00:54:37,760 --> 00:54:41,680
in the world but if you're

00:54:39,040 --> 00:54:42,480
um a fan of math i'm sure you will enjoy

00:54:41,680 --> 00:54:45,599
it so

00:54:42,480 --> 00:54:46,000
um these numbers are um known because of

00:54:45,599 --> 00:54:47,839
this

00:54:46,000 --> 00:54:49,440
also not just as ramanujan numbers but

00:54:47,839 --> 00:54:52,160
as taxi cab numbers

00:54:49,440 --> 00:54:52,880
um so a little piece of trivia and

00:54:52,160 --> 00:54:56,400
depending

00:54:52,880 --> 00:55:00,240
on the talks that you watched um earlier

00:54:56,400 --> 00:55:02,559
uh this week you might have uh noticed

00:55:00,240 --> 00:55:04,640
some of these numbers was anyone in uh

00:55:02,559 --> 00:55:08,160
stefan lowell wade's talk

00:55:04,640 --> 00:55:11,200
um if you look close enough you'll see

00:55:08,160 --> 00:55:14,280
1729 and uh

00:55:11,200 --> 00:55:18,000
you'll also see on another slide

00:55:14,280 --> 00:55:21,040
1729 down here uh so

00:55:18,000 --> 00:55:22,640
now you know whenever you see 1729 uh

00:55:21,040 --> 00:55:24,079
it's because it's a ramanujan number and

00:55:22,640 --> 00:55:27,520
clearly stefan is

00:55:24,079 --> 00:55:30,240
a ramanujan fan um so to recap

00:55:27,520 --> 00:55:31,920
um uh the way a ramanujan number is

00:55:30,240 --> 00:55:33,920
calculated is you have to have

00:55:31,920 --> 00:55:35,920
uh two different ways of expressing the

00:55:33,920 --> 00:55:36,960
number using the following form so a q

00:55:35,920 --> 00:55:39,040
plus b cubed

00:55:36,960 --> 00:55:40,319
for the number 1729 as i see someone

00:55:39,040 --> 00:55:43,280
just typed in the chat

00:55:40,319 --> 00:55:44,799
um we have 1 cubed plus 12 cubed and 9

00:55:43,280 --> 00:55:47,040
cubed plus 10 cubed

00:55:44,799 --> 00:55:48,000
um so how can we solve this in c plus

00:55:47,040 --> 00:55:49,359
plus and this is what we're going to

00:55:48,000 --> 00:55:52,640
spend the remaining uh

00:55:49,359 --> 00:55:54,079
four minutes uh looking at um so here

00:55:52,640 --> 00:55:56,640
there's a lot of code on slide let's

00:55:54,079 --> 00:56:00,160
walk through it one by one so at the top

00:55:56,640 --> 00:56:02,240
we have a lambda that takes a tuple

00:56:00,160 --> 00:56:04,000
d structures the tuple on the first line

00:56:02,240 --> 00:56:05,200
and then just cubes each of the values

00:56:04,000 --> 00:56:07,200
and adds them together

00:56:05,200 --> 00:56:09,599
so this is just some cubes pretty

00:56:07,200 --> 00:56:11,119
straightforward we can hide this away in

00:56:09,599 --> 00:56:13,760
a little ellipsis to

00:56:11,119 --> 00:56:15,680
make the code a little bit more clear

00:56:13,760 --> 00:56:16,799
then we have a bunch of ranges so the

00:56:15,680 --> 00:56:20,799
first thing we do

00:56:16,799 --> 00:56:23,760
is a cartesian product of iota 1-33

00:56:20,799 --> 00:56:24,240
twice um so what is a cartesian product

00:56:23,760 --> 00:56:25,680
well

00:56:24,240 --> 00:56:27,680
in several different languages they have

00:56:25,680 --> 00:56:29,599
it by a different name so rust d racket

00:56:27,680 --> 00:56:30,000
and c-plus plus all call this cartesian

00:56:29,599 --> 00:56:32,799
product

00:56:30,000 --> 00:56:34,000
in c plus plus it exists in range v3 and

00:56:32,799 --> 00:56:35,680
python and ruby

00:56:34,000 --> 00:56:38,240
it's called product and in queue which

00:56:35,680 --> 00:56:40,240
is a descendant of apl it's called cross

00:56:38,240 --> 00:56:41,839
um there are two other sort of sibling

00:56:40,240 --> 00:56:43,280
algorithms inner product

00:56:41,839 --> 00:56:44,720
and outer product which i'm not going to

00:56:43,280 --> 00:56:45,359
talk about here but it's just good to

00:56:44,720 --> 00:56:47,920
know

00:56:45,359 --> 00:56:49,040
and this is a visualization actually of

00:56:47,920 --> 00:56:51,200
outer product but you can think of

00:56:49,040 --> 00:56:53,359
cartesian product as just the flattened

00:56:51,200 --> 00:56:54,400
version of this so it's given a list of

00:56:53,359 --> 00:56:56,559
two uh

00:56:54,400 --> 00:56:58,799
given two lists it creates uh

00:56:56,559 --> 00:57:00,720
combinations of each of them

00:56:58,799 --> 00:57:02,960
so that's what cartesian product does

00:57:00,720 --> 00:57:05,440
and if we look at the next line

00:57:02,960 --> 00:57:06,799
filter we're basically filtering out any

00:57:05,440 --> 00:57:09,200
of the pairs where

00:57:06,799 --> 00:57:10,319
the or filtering in any of the pairs

00:57:09,200 --> 00:57:12,319
where the first one

00:57:10,319 --> 00:57:13,599
is less than the second one and all of

00:57:12,319 --> 00:57:15,280
the other ones are filtered out

00:57:13,599 --> 00:57:16,880
so if we go back to this diagram this

00:57:15,280 --> 00:57:17,440
filter is basically essentially doing

00:57:16,880 --> 00:57:19,440
this

00:57:17,440 --> 00:57:22,240
it's only keeping the pairs where the

00:57:19,440 --> 00:57:24,240
first element is less than the second

00:57:22,240 --> 00:57:26,319
and if we go back to this once we have

00:57:24,240 --> 00:57:29,119
this we then transform

00:57:26,319 --> 00:57:31,200
uh using the same lambda that we uh

00:57:29,119 --> 00:57:33,599
defined up above to get our sort of

00:57:31,200 --> 00:57:35,040
potential ramanujan values we then have

00:57:33,599 --> 00:57:36,799
to convert this into a vector

00:57:35,040 --> 00:57:38,319
and then in order to sort it and because

00:57:36,799 --> 00:57:40,240
we're using an action here we then need

00:57:38,319 --> 00:57:41,839
to store this in an l value

00:57:40,240 --> 00:57:43,520
once it's in an l value we can go back

00:57:41,839 --> 00:57:45,839
to using views where we go

00:57:43,520 --> 00:57:46,799
adjacent filter to filter out any of

00:57:45,839 --> 00:57:48,960
them

00:57:46,799 --> 00:57:50,799
that are not equal to each other when

00:57:48,960 --> 00:57:53,040
they're adjacent so that's how we can

00:57:50,799 --> 00:57:54,240
sort of identify the ramanujan numbers

00:57:53,040 --> 00:57:55,520
looking at the ones that are adjacent

00:57:54,240 --> 00:57:57,040
and equal to each other and then we have

00:57:55,520 --> 00:57:58,319
to drop one because of the way a json

00:57:57,040 --> 00:58:00,319
filter works i'm not going to talk about

00:57:58,319 --> 00:58:02,960
that now because i'm very short on time

00:58:00,319 --> 00:58:04,720
um so the first change like this is this

00:58:02,960 --> 00:58:06,799
is an okay solution but

00:58:04,720 --> 00:58:08,640
we're going to iterate to sort of the

00:58:06,799 --> 00:58:11,440
ideal solution and so

00:58:08,640 --> 00:58:13,440
what i really want um is a combination

00:58:11,440 --> 00:58:16,960
of cartesian product and filter

00:58:13,440 --> 00:58:19,920
with this exact pattern so if we had an

00:58:16,960 --> 00:58:22,079
algorithm called triangle product um we

00:58:19,920 --> 00:58:23,520
could avoid this filter

00:58:22,079 --> 00:58:24,880
and this is a very common pattern that

00:58:23,520 --> 00:58:26,640
i've seen in sort of array-oriented

00:58:24,880 --> 00:58:29,040
languages and i'm surprised this

00:58:26,640 --> 00:58:31,119
algorithm doesn't exist at some point i

00:58:29,040 --> 00:58:32,720
will add this to the range v3 lab

00:58:31,119 --> 00:58:35,440
library or write a paper and have

00:58:32,720 --> 00:58:36,799
someone else do it for me

00:58:35,440 --> 00:58:38,480
once we do this the next thing we want

00:58:36,799 --> 00:58:40,880
to do is get rid of this uh

00:58:38,480 --> 00:58:41,520
action sort um and this sort of comes

00:58:40,880 --> 00:58:43,839
from the

00:58:41,520 --> 00:58:45,760
idea in chapter three of sick p of

00:58:43,839 --> 00:58:47,599
streams so if we had a

00:58:45,760 --> 00:58:50,079
modified version of our triangle product

00:58:47,599 --> 00:58:52,640
algorithm that took an order um

00:58:50,079 --> 00:58:54,640
we could eliminate this sort and we

00:58:52,640 --> 00:58:57,040
could eliminate this ranges two vector

00:58:54,640 --> 00:58:58,000
so if we had an algorithm called ordered

00:58:57,040 --> 00:59:00,079
triangle product

00:58:58,000 --> 00:59:01,520
that took a weighting and between the

00:59:00,079 --> 00:59:02,960
two sort of lists of numbers that were

00:59:01,520 --> 00:59:04,079
being generated it would just look at

00:59:02,960 --> 00:59:06,880
the waiting and take the next

00:59:04,079 --> 00:59:08,799
one we could avoid uh the sort which

00:59:06,880 --> 00:59:11,280
would be absolutely amazing

00:59:08,799 --> 00:59:12,559
and now because we uh are no longer

00:59:11,280 --> 00:59:14,240
using an action

00:59:12,559 --> 00:59:16,079
we don't actually need to explicitly

00:59:14,240 --> 00:59:16,960
provide the number 33 which gets us the

00:59:16,079 --> 00:59:20,240
first five

00:59:16,960 --> 00:59:22,880
ramanujan numbers we can replace the 33

00:59:20,240 --> 00:59:24,559
with just a take five at the bottom and

00:59:22,880 --> 00:59:25,520
then once we've done this if we combine

00:59:24,559 --> 00:59:28,000
it with the future

00:59:25,520 --> 00:59:29,040
c plus 23 pipeline operator using the

00:59:28,000 --> 00:59:31,359
placeholder here

00:59:29,040 --> 00:59:32,720
we get even more elegant code because we

00:59:31,359 --> 00:59:34,640
don't need to

00:59:32,720 --> 00:59:36,160
define iota so we can pass it twice we

00:59:34,640 --> 00:59:37,839
can just use the placeholder twice

00:59:36,160 --> 00:59:39,760
depending on how it gets designed and

00:59:37,839 --> 00:59:42,079
then we have this extremely

00:59:39,760 --> 00:59:44,880
elegant code in my opinion so very

00:59:42,079 --> 00:59:46,240
quickly because i'm out of time

00:59:44,880 --> 00:59:47,440
if we bring back this code and then

00:59:46,240 --> 00:59:49,680
highlight all the different features we

00:59:47,440 --> 00:59:51,440
have c plus plus 20 slash 23

00:59:49,680 --> 00:59:53,359
xx ranges all the ones highlighted in

00:59:51,440 --> 00:59:54,079
green are available in c plus plus 20

00:59:53,359 --> 00:59:56,000
now

00:59:54,079 --> 00:59:58,400
um we've got the c plus plus 23 pipeline

00:59:56,000 --> 01:00:01,200
operators c plus plus 14 generic lambdas

00:59:58,400 --> 01:00:01,599
uh c plus plus 17 structure bindings and

01:00:01,200 --> 01:00:04,079
uh

01:00:01,599 --> 01:00:05,599
yeah that brings us to our conclusion so

01:00:04,079 --> 01:00:07,200
sick p is an absolutely brilliant and

01:00:05,599 --> 01:00:08,960
timeless textbook you will learn about

01:00:07,200 --> 01:00:10,480
the fundamentals of computer science

01:00:08,960 --> 01:00:12,319
in not just one but three different

01:00:10,480 --> 01:00:13,839
programming paradigms many of the

01:00:12,319 --> 01:00:15,440
examples and exercises in the text are

01:00:13,839 --> 01:00:16,640
challenging but is incredibly rewarding

01:00:15,440 --> 01:00:18,640
and fun to solve them

01:00:16,640 --> 01:00:20,559
in whichever language you choose and it

01:00:18,640 --> 01:00:22,319
is entirely free

01:00:20,559 --> 01:00:24,720
so as well as the mit and berkeley

01:00:22,319 --> 01:00:26,160
lectures the textbook is free

01:00:24,720 --> 01:00:28,240
and i want to say thank you to all of

01:00:26,160 --> 01:00:30,720
the passionate teachers and presenters

01:00:28,240 --> 01:00:32,720
uh that inspire me and other individuals

01:00:30,720 --> 01:00:33,839
so obviously sussman and abelson if you

01:00:32,720 --> 01:00:36,640
watch the lectures

01:00:33,839 --> 01:00:37,119
they're absolutely phenomenal um i mean

01:00:36,640 --> 01:00:38,960
uh

01:00:37,119 --> 01:00:40,240
sussman actually dresses up as a wizard

01:00:38,960 --> 01:00:42,559
in one of the lectures it's

01:00:40,240 --> 01:00:44,079
it's amazing everyone should watch it um

01:00:42,559 --> 01:00:46,400
to stephanov and sean parent

01:00:44,079 --> 01:00:47,920
uh you both have been inspiring me since

01:00:46,400 --> 01:00:49,520
i started watching talks and

01:00:47,920 --> 01:00:51,599
uh i just and i want to say thank you to

01:00:49,520 --> 01:00:53,760
all the speakers at this cpp con and

01:00:51,599 --> 01:00:55,920
past cpp cons and all the conferences

01:00:53,760 --> 01:00:57,200
um it's absolutely awesome uh and so

01:00:55,920 --> 01:01:00,160
just a couple last notes

01:00:57,200 --> 01:01:01,599
as i mentioned all the uh code and links

01:01:00,160 --> 01:01:03,920
to the talks that i mentioned

01:01:01,599 --> 01:01:05,280
are on my github um if you want to check

01:01:03,920 --> 01:01:07,119
out all of the links to the free

01:01:05,280 --> 01:01:07,760
lectures and the free textbooks check

01:01:07,119 --> 01:01:11,440
out the

01:01:07,760 --> 01:01:13,760
uh meetup github sick page

01:01:11,440 --> 01:01:15,520
um you can find all the links here and

01:01:13,760 --> 01:01:16,160
all of the videos are linked here as

01:01:15,520 --> 01:01:19,359
well

01:01:16,160 --> 01:01:21,280
uh and finally thank you

01:01:19,359 --> 01:01:22,480
any uh i guess we're sort of out of time

01:01:21,280 --> 01:01:23,040
so i'm not sure how questions work at

01:01:22,480 --> 01:01:25,920
this point

01:01:23,040 --> 01:01:27,359
if i get kicked off i will say before i

01:01:25,920 --> 01:01:30,400
answer any questions

01:01:27,359 --> 01:01:33,760
um i will be going to uh

01:01:30,400 --> 01:01:35,760
we'll say hallway track floor

01:01:33,760 --> 01:01:37,599
9 for anyone that wants to chat

01:01:35,760 --> 01:01:39,040
afterwards about this or has questions

01:01:37,599 --> 01:01:42,079
that don't get answered

01:01:39,040 --> 01:01:45,200
in uh the q a period

01:01:42,079 --> 01:01:47,920
um the first two questions are for jf so

01:01:45,200 --> 01:01:50,799
i'm just going to ignore them

01:01:47,920 --> 01:01:52,880
um and then victor says stepanov was a

01:01:50,799 --> 01:01:55,440
strong proponent of algorithms

01:01:52,880 --> 01:01:57,680
on arrays coming really strong against

01:01:55,440 --> 01:02:00,880
node-based data structures and list-like

01:01:57,680 --> 01:02:00,880
or small-talk languages

01:02:05,280 --> 01:02:08,480
uh i'm not gonna click on the link but i

01:02:07,119 --> 01:02:10,079
assume that this is i

01:02:08,480 --> 01:02:11,760
i think i've seen the link that you're

01:02:10,079 --> 01:02:12,799
talking about where he explicitly

01:02:11,760 --> 01:02:16,559
mentions

01:02:12,799 --> 01:02:19,680
um that like map and unordered map

01:02:16,559 --> 01:02:21,200
uh and set they come from small talk

01:02:19,680 --> 01:02:22,720
and that the reduction algorithms come

01:02:21,200 --> 01:02:26,319
from apl

01:02:22,720 --> 01:02:29,359
um i love

01:02:26,319 --> 01:02:32,480
algorithms uh that operate on arrays

01:02:29,359 --> 01:02:33,359
i think it's a very natural way to think

01:02:32,480 --> 01:02:35,760
about

01:02:33,359 --> 01:02:38,160
sort of the pipeline model um if you've

01:02:35,760 --> 01:02:40,319
worked in any array-oriented languages

01:02:38,160 --> 01:02:41,920
you'll find it extremely natural coming

01:02:40,319 --> 01:02:43,839
to sort of other languages that have

01:02:41,920 --> 01:02:45,200
reduction operations on arrays or other

01:02:43,839 --> 01:02:50,160
sequences

01:02:45,200 --> 01:02:54,319
so i'm a i'm a huge fan um

01:02:50,160 --> 01:02:58,480
uh with the opinion sort of against

01:02:54,319 --> 01:03:00,079
node based data structures um

01:02:58,480 --> 01:03:02,000
i don't really have any thoughts maybe

01:03:00,079 --> 01:03:06,079
find me after after the talk and

01:03:02,000 --> 01:03:09,039
we can chat um there's a question from

01:03:06,079 --> 01:03:10,000
augustine that says uh what other

01:03:09,039 --> 01:03:12,079
resources

01:03:10,000 --> 01:03:15,039
for learning that were not mentioned

01:03:12,079 --> 01:03:15,039
would you like to share

01:03:15,119 --> 01:03:17,839
um

01:03:19,920 --> 01:03:23,599
what do i think the best resources are

01:03:21,440 --> 01:03:25,359
so there was a lightning talk actually

01:03:23,599 --> 01:03:27,039
i'm not gonna remember the name of it um

01:03:25,359 --> 01:03:30,079
but it mentioned basically like

01:03:27,039 --> 01:03:32,240
a ton of great c plus resources um so

01:03:30,079 --> 01:03:34,559
for c plus like the two c plus plus

01:03:32,240 --> 01:03:36,640
podcast cppcast and cppchat

01:03:34,559 --> 01:03:37,760
um all of the free videos online all of

01:03:36,640 --> 01:03:39,760
the textbooks

01:03:37,760 --> 01:03:43,280
um the scott myers books are absolutely

01:03:39,760 --> 01:03:43,280
fantastic i think they're a must read

01:03:43,440 --> 01:03:46,160
it's hard for me to pinpoint like what

01:03:44,880 --> 01:03:48,079
are the best resources because i just

01:03:46,160 --> 01:03:50,640
have so many that i constantly consume

01:03:48,079 --> 01:03:51,680
um i sort of approach it from like the

01:03:50,640 --> 01:03:55,520
fire hose method

01:03:51,680 --> 01:03:56,960
um uh but yeah maybe sync with me after

01:03:55,520 --> 01:03:58,000
and if you've got like specifics on like

01:03:56,960 --> 01:03:59,920
if top videos or

01:03:58,000 --> 01:04:02,559
top books or top podcasts i can i can

01:03:59,920 --> 01:04:06,160
point you in the direction of some

01:04:02,559 --> 01:04:08,799
um and uh

01:04:06,160 --> 01:04:10,480
maybe uh the next question i think is

01:04:08,799 --> 01:04:12,000
from romario it says i've always felt

01:04:10,480 --> 01:04:16,160
the elegance of lisp doesn't fully map

01:04:12,000 --> 01:04:16,160
cleanly to type languages do you agree

01:04:19,359 --> 01:04:26,880
the elegance of lisp doesn't map cleanly

01:04:23,599 --> 01:04:28,400
um i i'm not informed enough i'm not

01:04:26,880 --> 01:04:30,559
enough of a lisp expert

01:04:28,400 --> 01:04:32,240
to answer this well i know that in

01:04:30,559 --> 01:04:35,280
racket they have the typed

01:04:32,240 --> 01:04:37,520
racket project and enclosure they are

01:04:35,280 --> 01:04:40,720
also working on like a typed

01:04:37,520 --> 01:04:42,400
typed version or spec um

01:04:40,720 --> 01:04:44,559
but i know that yeah there's it's a

01:04:42,400 --> 01:04:48,079
struggle to add typing

01:04:44,559 --> 01:04:49,839
uh to like lisp dialects um

01:04:48,079 --> 01:04:51,599
and i know rich hickey if you watch any

01:04:49,839 --> 01:04:54,559
of his talks he

01:04:51,599 --> 01:04:55,280
um he's he says that static typing does

01:04:54,559 --> 01:04:58,880
help

01:04:55,280 --> 01:05:01,520
um but that like uh dynamically typed

01:04:58,880 --> 01:05:03,359
language um also has like a ton of

01:05:01,520 --> 01:05:06,880
benefits which i do agree with

01:05:03,359 --> 01:05:07,599
um so yeah you would have to probably

01:05:06,880 --> 01:05:09,440
ask a list

01:05:07,599 --> 01:05:12,559
ellipse a lisp expert to get a better

01:05:09,440 --> 01:05:14,720
answer um

01:05:12,559 --> 01:05:14,720
oh

01:05:15,839 --> 01:05:20,240
uh next question from pablo in the fib

01:05:18,799 --> 01:05:21,440
with stood function why you stood

01:05:20,240 --> 01:05:24,799
function

01:05:21,440 --> 01:05:25,440
iey polymorphic uh is there an

01:05:24,799 --> 01:05:28,960
alternative

01:05:25,440 --> 01:05:30,319
like a better alternative um i was just

01:05:28,960 --> 01:05:33,039
uh

01:05:30,319 --> 01:05:34,960
i was reading online like how to do a

01:05:33,039 --> 01:05:36,480
recursive lambda and that was the

01:05:34,960 --> 01:05:38,160
recommendation that i came across but if

01:05:36,480 --> 01:05:42,079
there's a

01:05:38,160 --> 01:05:45,359
a better way um feel free to let me know

01:05:42,079 --> 01:05:47,359
and then uh last but not least is

01:05:45,359 --> 01:05:49,039
stepping off was definitely against oop

01:05:47,359 --> 01:05:50,640
and thus probably small talk not sure

01:05:49,039 --> 01:05:52,960
about node-based data structures okay so

01:05:50,640 --> 01:05:54,960
that's just a comment

01:05:52,960 --> 01:05:56,640
all right so it looks like the question

01:05:54,960 --> 01:05:58,960
queue is empty

01:05:56,640 --> 01:06:00,240
like i said i'll be on floor 9 of the

01:05:58,960 --> 01:06:01,119
hallway track if people want to chat

01:06:00,240 --> 01:06:02,720
about this

01:06:01,119 --> 01:06:04,720
thank you everyone to tuning in and i

01:06:02,720 --> 01:06:19,839
hope you enjoy

01:06:04,720 --> 01:06:19,839
the rest of the conference

01:06:25,920 --> 01:06:28,000

YouTube URL: https://www.youtube.com/watch?v=7oV7hiAsVTI


