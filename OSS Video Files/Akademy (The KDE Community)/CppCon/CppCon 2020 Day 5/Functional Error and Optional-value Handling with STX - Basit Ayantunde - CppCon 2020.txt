Title: Functional Error and Optional-value Handling with STX - Basit Ayantunde - CppCon 2020
Publication date: 2020-10-06
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Error-handling is arguably the most divergent part of C++. Many coding guidelines partially allow exceptions or totally ban it and this leads to many projects supporting multiple error-handling interfaces such as exceptions, the error-prone c-style error-handling, and/or custom error-handling types. This also leads many C++ developers to not use exceptions and instead roll their in-house error and optional-value handling facilities which are duplicated across the ecosystem.

This divergence has birthed numerous projects like boost.expected, boost.outcome, boost.leaf, tl::optional, tl::expected, and many others that have done a great job at addressing these issues.

This talk introduces STX; a C++ library that tries to address some of these concerns with error and optional-value handling in the C++ ecosystem and also tries to unify some of these efforts/implementations.

---
Basit Ayantunde is an undergraduate at the University of Ilorin, Nigeria where he majors in Mechanical Engineering. Basit has 4 years of experience writing industrial software both as a contract software developer and intern. He is one of the C++Now 2020 scholars, he contributes to open source projects like Tensorflow and CMSIS, and authors STX and a number of open source C++ libraries.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,240 --> 00:00:13,840
hello and welcome to super become

00:00:10,639 --> 00:00:17,199
my name is basset antony i'm a student

00:00:13,840 --> 00:00:19,279
at the university of lauren in nigeria

00:00:17,199 --> 00:00:20,800
i have taken a number of internships and

00:00:19,279 --> 00:00:22,880
i recently completed

00:00:20,800 --> 00:00:25,119
my internship at good morning sharks

00:00:22,880 --> 00:00:26,880
where i would search way for managing

00:00:25,119 --> 00:00:28,560
some of the high performance data

00:00:26,880 --> 00:00:31,119
engineering systems

00:00:28,560 --> 00:00:32,160
i've been in the ability space for about

00:00:31,119 --> 00:00:34,719
three years now

00:00:32,160 --> 00:00:35,760
and i started out as an obvious nvidia

00:00:34,719 --> 00:00:39,040
developer

00:00:35,760 --> 00:00:42,239
i have in some previous projects

00:00:39,040 --> 00:00:45,840
um written empty drivers for

00:00:42,239 --> 00:00:46,960
mini robots and for really small robotic

00:00:45,840 --> 00:00:49,280
systems

00:00:46,960 --> 00:00:50,800
i've also been contributing to open

00:00:49,280 --> 00:00:53,440
source projects for micro

00:00:50,800 --> 00:00:54,480
controllers like simsy's name and

00:00:53,440 --> 00:00:57,920
tensorflow lite

00:00:54,480 --> 00:00:58,719
micro i've recently been getting more

00:00:57,920 --> 00:01:01,280
interested in

00:00:58,719 --> 00:01:02,719
exploring the operating system's field

00:01:01,280 --> 00:01:05,760
of lately

00:01:02,719 --> 00:01:08,479
so um yeah

00:01:05,760 --> 00:01:10,080
first the goals of this talk let's go

00:01:08,479 --> 00:01:12,799
through some of the goals for this

00:01:10,080 --> 00:01:15,360
talk first of all we want to perform a

00:01:12,799 --> 00:01:17,920
brief introduction into stx

00:01:15,360 --> 00:01:20,080
it's optional value on functional error

00:01:17,920 --> 00:01:23,200
and reporting

00:01:20,080 --> 00:01:25,840
facilities goal number two

00:01:23,200 --> 00:01:27,600
is to encourage you to rethink and pay

00:01:25,840 --> 00:01:28,240
more attention to everyone lean and

00:01:27,600 --> 00:01:31,840
reporting

00:01:28,240 --> 00:01:33,680
in your code base goal number three is

00:01:31,840 --> 00:01:35,439
to briefly illustrate the

00:01:33,680 --> 00:01:36,960
abstract action logic abstraction

00:01:35,439 --> 00:01:38,560
capabilities of this

00:01:36,960 --> 00:01:40,799
type model that we'll be introducing to

00:01:38,560 --> 00:01:44,079
you later today

00:01:40,799 --> 00:01:46,799
so um first a disclaimer um

00:01:44,079 --> 00:01:48,479
s6 panic option and results are

00:01:46,799 --> 00:01:51,840
entertaining my ideas

00:01:48,479 --> 00:01:55,200
though rather a unified and refined form

00:01:51,840 --> 00:01:57,439
of the enrollment lean techniques that

00:01:55,200 --> 00:02:00,640
we commonly use today in supposed plus

00:01:57,439 --> 00:02:03,759
project on the outside

00:02:00,640 --> 00:02:05,840
so um a brief overview of the embedded

00:02:03,759 --> 00:02:07,680
system space

00:02:05,840 --> 00:02:11,039
on some design considerations that are

00:02:07,680 --> 00:02:14,080
usually just for writing a software

00:02:11,039 --> 00:02:15,520
we try to maximize performance and

00:02:14,080 --> 00:02:19,920
utilization of

00:02:15,520 --> 00:02:22,879
the hardware and we try to

00:02:19,920 --> 00:02:25,520
make the firmware as skill and memory

00:02:22,879 --> 00:02:28,800
safe as possible

00:02:25,520 --> 00:02:30,879
another one is we try to have

00:02:28,800 --> 00:02:32,720
failure and safety strong failure on

00:02:30,879 --> 00:02:36,480
safety guarantees unlike normal

00:02:32,720 --> 00:02:38,879
systems we have very very

00:02:36,480 --> 00:02:40,720
small memory and storage constraints you

00:02:38,879 --> 00:02:44,640
can now build devices with like

00:02:40,720 --> 00:02:48,080
it's four kilobytes of ram and basically

00:02:44,640 --> 00:02:49,680
it's very very small amounts of 128

00:02:48,080 --> 00:02:52,319
kilobytes

00:02:49,680 --> 00:02:53,120
so you have to pay close attention to

00:02:52,319 --> 00:02:56,640
your code on

00:02:53,120 --> 00:02:59,920
what features and facilities you pull in

00:02:56,640 --> 00:03:02,560
also um we also pay more

00:02:59,920 --> 00:03:03,519
attention to touching and future

00:03:02,560 --> 00:03:05,760
completeness

00:03:03,519 --> 00:03:06,800
because maybe touching some teachers for

00:03:05,760 --> 00:03:09,840
example don't

00:03:06,800 --> 00:03:13,040
fully implement exceptions on some other

00:03:09,840 --> 00:03:15,280
libraries so you have to test and be

00:03:13,040 --> 00:03:18,959
sure of what you're doing

00:03:15,280 --> 00:03:21,440
um we also do have some ad

00:03:18,959 --> 00:03:22,480
real time on soft or software video time

00:03:21,440 --> 00:03:26,400
constraints

00:03:22,480 --> 00:03:29,040
in other time um software we try to

00:03:26,400 --> 00:03:31,280
um make sure we know exactly the

00:03:29,040 --> 00:03:34,720
execution time of the functions

00:03:31,280 --> 00:03:36,319
and and be able to have stronger things

00:03:34,720 --> 00:03:39,390
about the execution time

00:03:36,319 --> 00:03:40,560
if not real time if if the

00:03:39,390 --> 00:03:44,080
[Music]

00:03:40,560 --> 00:03:47,440
if they if the execution time exceeds a

00:03:44,080 --> 00:03:50,560
time limit that is essentially a bug

00:03:47,440 --> 00:03:53,040
like soft real time it can exhibit 10

00:03:50,560 --> 00:03:54,959
minutes but not too much and even even

00:03:53,040 --> 00:03:58,080
if it's exhibit time limit it's not

00:03:54,959 --> 00:04:00,799
a bug so i don't need the

00:03:58,080 --> 00:04:01,280
enjoy of in the investigation space is

00:04:00,799 --> 00:04:03,280
the

00:04:01,280 --> 00:04:04,879
to address the ever evolving needs of

00:04:03,280 --> 00:04:08,879
the consumers

00:04:04,879 --> 00:04:12,560
and users of the software

00:04:08,879 --> 00:04:14,879
yeah um also we need to

00:04:12,560 --> 00:04:16,720
we often try to write portable code but

00:04:14,879 --> 00:04:18,880
that's not always possible

00:04:16,720 --> 00:04:20,000
because we still need to maximize

00:04:18,880 --> 00:04:22,720
efficiency

00:04:20,000 --> 00:04:23,600
um usually our very diverse hardware

00:04:22,720 --> 00:04:26,960
platforms

00:04:23,600 --> 00:04:30,160
so yeah um let's

00:04:26,960 --> 00:04:33,199
so today we'll be introducing you to stx

00:04:30,160 --> 00:04:33,520
first um let me like try to describe

00:04:33,199 --> 00:04:36,479
what

00:04:33,520 --> 00:04:38,320
stx is six is a collection of libraries

00:04:36,479 --> 00:04:40,000
and utilities designed to make working

00:04:38,320 --> 00:04:40,960
with simple sports easier and less

00:04:40,000 --> 00:04:42,720
european

00:04:40,960 --> 00:04:45,759
this inclusible is not limited to

00:04:42,720 --> 00:04:47,759
well-proven and widely adopted paradigms

00:04:45,759 --> 00:04:49,199
data structures and designs from other

00:04:47,759 --> 00:04:49,919
permanent projects and programming

00:04:49,199 --> 00:04:51,360
language

00:04:49,919 --> 00:04:53,440
across the software engineering

00:04:51,360 --> 00:04:56,000
community i recall

00:04:53,440 --> 00:04:57,199
all sx libraries and facilities are no

00:04:56,000 --> 00:04:59,680
std

00:04:57,199 --> 00:05:00,720
no rgti which is one time type

00:04:59,680 --> 00:05:05,440
information

00:05:00,720 --> 00:05:05,440
if memory allocation no exceptions

00:05:06,960 --> 00:05:13,520
so stx has a number of libraries

00:05:10,000 --> 00:05:16,000
within it which is um panic library

00:05:13,520 --> 00:05:18,080
the optional value and erranding library

00:05:16,000 --> 00:05:19,520
which contains the option and results

00:05:18,080 --> 00:05:22,320
type monad

00:05:19,520 --> 00:05:22,960
we also have the batteries library for

00:05:22,320 --> 00:05:26,000
getting

00:05:22,960 --> 00:05:26,960
um function by choices and the platform

00:05:26,000 --> 00:05:29,039
configuration

00:05:26,960 --> 00:05:30,720
macros identification library which is

00:05:29,039 --> 00:05:33,600
basically for identify

00:05:30,720 --> 00:05:34,160
platform macros like detection there's a

00:05:33,600 --> 00:05:36,639
iron

00:05:34,160 --> 00:05:39,039
compiler for x86 and stuff like that

00:05:36,639 --> 00:05:42,320
which can be error prone

00:05:39,039 --> 00:05:44,240
yeah so for this talk we'll only be

00:05:42,320 --> 00:05:45,680
illustrating the panic library and the

00:05:44,240 --> 00:05:49,520
optional aero only

00:05:45,680 --> 00:05:52,080
library so on motivation

00:05:49,520 --> 00:05:52,639
the reason why i started htx xtx because

00:05:52,080 --> 00:05:54,800
i've been

00:05:52,639 --> 00:05:56,400
working on embedded systems projects in

00:05:54,800 --> 00:05:58,479
citrus pose and all

00:05:56,400 --> 00:05:59,680
projects i've worked on or contributed

00:05:58,479 --> 00:06:02,000
on all different

00:05:59,680 --> 00:06:03,520
around lean techniques the one is single

00:06:02,000 --> 00:06:05,440
projects could have different

00:06:03,520 --> 00:06:06,720
rna techniques in this project we have

00:06:05,440 --> 00:06:09,039
different dynamic

00:06:06,720 --> 00:06:11,039
requirements for adding errors

00:06:09,039 --> 00:06:13,360
especially wires you don't have

00:06:11,039 --> 00:06:14,400
in order to immediately have a monitor

00:06:13,360 --> 00:06:17,360
for wearing logs

00:06:14,400 --> 00:06:19,759
so stood there finding out your debugger

00:06:17,360 --> 00:06:21,759
or spectacular drums

00:06:19,759 --> 00:06:23,039
so i needed a library that could

00:06:21,759 --> 00:06:28,000
sufficiently solve

00:06:23,039 --> 00:06:28,000
this problem that's why i started stx

00:06:28,800 --> 00:06:34,479
um motivation to number two

00:06:31,919 --> 00:06:36,240
is their audience error and optional

00:06:34,479 --> 00:06:39,120
value immune systems

00:06:36,240 --> 00:06:40,880
some code bases with your optional and

00:06:39,120 --> 00:06:42,720
iranian type recommendations

00:06:40,880 --> 00:06:45,280
you often see them doing same things

00:06:42,720 --> 00:06:48,319
within the same code base

00:06:45,280 --> 00:06:51,120
so i think that's basically code blood

00:06:48,319 --> 00:06:52,479
um a recent study showed that 50 of

00:06:51,120 --> 00:06:55,840
civil sports projects

00:06:52,479 --> 00:06:58,240
burn exceptions in total or whole

00:06:55,840 --> 00:06:58,960
and use a vast number of variety of

00:06:58,240 --> 00:07:02,000
different

00:06:58,960 --> 00:07:04,400
running techniques so

00:07:02,000 --> 00:07:05,280
um basically i think there's a need for

00:07:04,400 --> 00:07:07,199
easier

00:07:05,280 --> 00:07:08,800
more deterministic and efficient

00:07:07,199 --> 00:07:11,840
rambling techniques

00:07:08,800 --> 00:07:14,840
as a quote from hub sota and the

00:07:11,840 --> 00:07:16,000
zero by deterministic exceptions paper

00:07:14,840 --> 00:07:18,080
00:07:16,000 --> 00:07:19,840
said we cannot accept the standard super

00:07:18,080 --> 00:07:21,199
support we're not applicable for

00:07:19,840 --> 00:07:23,759
real-time systems

00:07:21,199 --> 00:07:25,520
that would be an admission of defeat

00:07:23,759 --> 00:07:27,840
insurance commission as an

00:07:25,520 --> 00:07:29,199
efficient systems programming language

00:07:27,840 --> 00:07:32,080
therefore we know

00:07:29,199 --> 00:07:35,120
we cannot live with today's exceptions

00:07:32,080 --> 00:07:35,120
model or change

00:07:35,599 --> 00:07:40,560
yeah so let's take a look into fuel

00:07:38,800 --> 00:07:44,319
first abandonment as we

00:07:40,560 --> 00:07:47,599
do it today um but first of all

00:07:44,319 --> 00:07:50,160
i'll record from epsota a

00:07:47,599 --> 00:07:51,039
programming blog or abstract machine

00:07:50,160 --> 00:07:54,120
corruption

00:07:51,039 --> 00:07:57,280
is never an error both are not

00:07:54,120 --> 00:07:59,360
programmatically recoverable so report

00:07:57,280 --> 00:08:02,000
box to the human programmer using

00:07:59,360 --> 00:08:02,879
contract violations that default to fail

00:08:02,000 --> 00:08:06,080
fast

00:08:02,879 --> 00:08:09,199
and report abstract machine corruption

00:08:06,080 --> 00:08:09,199
using fill first

00:08:09,599 --> 00:08:16,560
so um now let's go into fatal failures

00:08:14,319 --> 00:08:18,400
what's exactly our fatal failures

00:08:16,560 --> 00:08:19,280
effective failure is a failure in which

00:08:18,400 --> 00:08:21,599
there is no

00:08:19,280 --> 00:08:23,919
no known way of recovering and in which

00:08:21,599 --> 00:08:26,319
it would be otherwise illogical

00:08:23,919 --> 00:08:27,599
and or dangerous for the breakdown to

00:08:26,319 --> 00:08:30,080
proceed in the

00:08:27,599 --> 00:08:32,080
phase of such failure and we are

00:08:30,080 --> 00:08:35,120
planning on the program

00:08:32,080 --> 00:08:36,560
commonly today we use stood about for

00:08:35,120 --> 00:08:38,640
fuel first environment

00:08:36,560 --> 00:08:40,000
but the question now is that is still

00:08:38,640 --> 00:08:42,320
about ever okay

00:08:40,000 --> 00:08:43,839
just a plain student about real context

00:08:42,320 --> 00:08:47,040
you say okay

00:08:43,839 --> 00:08:48,480
um about doesn't really provide context

00:08:47,040 --> 00:08:51,200
no reports about the course

00:08:48,480 --> 00:08:52,000
of the error which optionally provides a

00:08:51,200 --> 00:08:54,560
code drum

00:08:52,000 --> 00:08:56,880
or snapshot of the system memory at the

00:08:54,560 --> 00:09:00,240
time of invocation

00:08:56,880 --> 00:09:02,720
so um let's take a look at this code

00:09:00,240 --> 00:09:04,560
we'll define a function named ensure

00:09:02,720 --> 00:09:06,399
data okay and use it to check whether

00:09:04,560 --> 00:09:09,120
data is corrupted or not

00:09:06,399 --> 00:09:10,480
and if it is corrupted we simply abaddon

00:09:09,120 --> 00:09:13,680
the program

00:09:10,480 --> 00:09:16,399
so here is basically how we do this we

00:09:13,680 --> 00:09:17,600
don't know that the crc type 2 is a weak

00:09:16,399 --> 00:09:19,600
hash algorithm

00:09:17,600 --> 00:09:22,160
we're commonly using assistance for

00:09:19,600 --> 00:09:25,440
detecting data corruption

00:09:22,160 --> 00:09:29,040
now let's try to run this code and

00:09:25,440 --> 00:09:29,040
see what we get

00:09:31,120 --> 00:09:38,000
get about it core dumped

00:09:34,320 --> 00:09:40,320
i as most users would ask the programmer

00:09:38,000 --> 00:09:41,440
what went wrong i need admissional

00:09:40,320 --> 00:09:44,560
information

00:09:41,440 --> 00:09:46,480
and context about the error

00:09:44,560 --> 00:09:48,839
even if i want to report it to you i

00:09:46,480 --> 00:09:50,480
don't have any information to report to

00:09:48,839 --> 00:09:53,279
you

00:09:50,480 --> 00:09:55,360
and for a better systems quadrants

00:09:53,279 --> 00:09:59,120
aren't always available

00:09:55,360 --> 00:10:01,279
so that's another issue um

00:09:59,120 --> 00:10:03,200
now let's try to provide more context by

00:10:01,279 --> 00:10:04,640
writing the fatal error reports just

00:10:03,200 --> 00:10:06,560
stood here

00:10:04,640 --> 00:10:08,320
so instead of the previous one where we

00:10:06,560 --> 00:10:10,880
just plainly about at least

00:10:08,320 --> 00:10:12,560
we'll give the user a little information

00:10:10,880 --> 00:10:16,240
about the error

00:10:12,560 --> 00:10:18,959
now um that's that's fair enough

00:10:16,240 --> 00:10:20,399
but we were able to provide some context

00:10:18,959 --> 00:10:22,959
and the user can now

00:10:20,399 --> 00:10:23,920
have an idea of what the fatal failure

00:10:22,959 --> 00:10:27,040
was

00:10:23,920 --> 00:10:27,600
and what would and that would help guide

00:10:27,040 --> 00:10:30,640
our

00:10:27,600 --> 00:10:32,079
investigation but always is the error

00:10:30,640 --> 00:10:35,279
message we don't get to source

00:10:32,079 --> 00:10:37,360
context i really error or call in the

00:10:35,279 --> 00:10:40,000
source code for example which part of

00:10:37,360 --> 00:10:42,800
code did it occur

00:10:40,000 --> 00:10:44,399
um an actually common approach is which

00:10:42,800 --> 00:10:46,000
i've seen in codebases

00:10:44,399 --> 00:10:47,920
especially once i work with is with

00:10:46,000 --> 00:10:50,959
macros and here is

00:10:47,920 --> 00:10:54,160
how it is commonly used today

00:10:50,959 --> 00:10:56,399
um it's it's it gives the

00:10:54,160 --> 00:10:57,200
file information on the expression that

00:10:56,399 --> 00:11:00,399
cause the

00:10:57,200 --> 00:11:02,000
error the line the error message on many

00:11:00,399 --> 00:11:02,720
others which could be very useful

00:11:02,000 --> 00:11:05,279
especially

00:11:02,720 --> 00:11:08,000
if the user is giving you the reports

00:11:05,279 --> 00:11:08,000
about the error

00:11:08,160 --> 00:11:15,680
so um yeah if you run the code here's

00:11:11,920 --> 00:11:17,279
what you will say um i personally really

00:11:15,680 --> 00:11:19,519
like this approach because

00:11:17,279 --> 00:11:20,320
it's it's even about the most projects

00:11:19,519 --> 00:11:24,640
that i've worked

00:11:20,320 --> 00:11:28,160
with so yeah well let's see if we can do

00:11:24,640 --> 00:11:28,800
more yeah more robust projects like

00:11:28,160 --> 00:11:31,519
upsell

00:11:28,800 --> 00:11:32,320
and evolving provide a customizable

00:11:31,519 --> 00:11:34,160
error hook

00:11:32,320 --> 00:11:36,560
which is just a function you can change

00:11:34,160 --> 00:11:39,760
at one time this function

00:11:36,560 --> 00:11:41,760
decides how the fertile error is handled

00:11:39,760 --> 00:11:43,680
i think it's really neat because it

00:11:41,760 --> 00:11:46,320
allows you as a user of leveraging

00:11:43,680 --> 00:11:48,800
decisions on how you want the fit out

00:11:46,320 --> 00:11:51,839
error to be handled for your project

00:11:48,800 --> 00:11:52,639
um as you can see this function named

00:11:51,839 --> 00:11:55,680
error hook

00:11:52,639 --> 00:11:59,040
is passing it for is getting a photo

00:11:55,680 --> 00:12:01,440
photo error level um value

00:11:59,040 --> 00:12:02,399
so it should enter the arrow as a fatal

00:12:01,440 --> 00:12:05,120
error

00:12:02,399 --> 00:12:07,200
and basically to find a function that is

00:12:05,120 --> 00:12:09,200
already attached as a hook

00:12:07,200 --> 00:12:11,839
at one time and basically invoke the

00:12:09,200 --> 00:12:11,839
function

00:12:12,160 --> 00:12:18,079
yeah another example in the world

00:12:15,680 --> 00:12:19,519
as we just feel first about me today is

00:12:18,079 --> 00:12:22,959
the zericoin cranial

00:12:19,519 --> 00:12:25,600
it also has a fuel first function

00:12:22,959 --> 00:12:26,160
called panic we just logs to stop here

00:12:25,600 --> 00:12:30,000
again

00:12:26,160 --> 00:12:31,680
about the program um the living knox

00:12:30,000 --> 00:12:34,959
canyon also has a more

00:12:31,680 --> 00:12:38,240
complex field first function named panic

00:12:34,959 --> 00:12:38,800
which turns off some fairy it locks the

00:12:38,240 --> 00:12:40,800
air

00:12:38,800 --> 00:12:42,720
and then performs other required

00:12:40,800 --> 00:12:44,880
cleanups as necessary

00:12:42,720 --> 00:12:46,720
again i would like to emphasize that

00:12:44,880 --> 00:12:50,720
these are the needs for this project it

00:12:46,720 --> 00:12:54,720
might not be same for other projects

00:12:50,720 --> 00:12:55,680
we need to manage these expectations

00:12:54,720 --> 00:12:58,720
without touching

00:12:55,680 --> 00:13:02,160
all parts of the equipment because just

00:12:58,720 --> 00:13:04,800
just just for example look at this um

00:13:02,160 --> 00:13:05,279
this requirement user owner might want

00:13:04,800 --> 00:13:07,839
to lock

00:13:05,279 --> 00:13:08,639
the error report to disk user 2 might

00:13:07,839 --> 00:13:10,160
want to edit

00:13:08,639 --> 00:13:12,560
batteries at the of the area at the

00:13:10,160 --> 00:13:13,120
point in time usually might want to lock

00:13:12,560 --> 00:13:16,320
the photo

00:13:13,120 --> 00:13:18,000
arrow to pull to the console i as an

00:13:16,320 --> 00:13:20,880
angular user might want to

00:13:18,000 --> 00:13:22,959
lock the arrow to your outs or spi or

00:13:20,880 --> 00:13:26,480
isosce as per c or any

00:13:22,959 --> 00:13:28,639
um wired protocol that i'm using i might

00:13:26,480 --> 00:13:29,839
also want to capture the device memory

00:13:28,639 --> 00:13:31,519
at the point

00:13:29,839 --> 00:13:35,200
in which the error code i'm sending to

00:13:31,519 --> 00:13:35,519
the company's hq a user might also want

00:13:35,200 --> 00:13:38,399
to

00:13:35,519 --> 00:13:38,880
want to hold the executing trade so that

00:13:38,399 --> 00:13:42,000
it can

00:13:38,880 --> 00:13:42,959
the user can investigate the error so

00:13:42,000 --> 00:13:45,839
there are various

00:13:42,959 --> 00:13:46,560
needs that arises as as you get more

00:13:45,839 --> 00:13:51,519
users

00:13:46,560 --> 00:13:51,519
more procedures yeah

00:13:52,399 --> 00:13:57,839
so there are a number of consequences to

00:13:54,880 --> 00:14:01,040
managing these upon domains expectations

00:13:57,839 --> 00:14:03,279
first of all to

00:14:01,040 --> 00:14:05,760
sorry there are a number of um

00:14:03,279 --> 00:14:07,600
challenges or consequences to

00:14:05,760 --> 00:14:10,240
manually hard coding these are the

00:14:07,600 --> 00:14:14,480
boundaries expectations

00:14:10,240 --> 00:14:16,880
um according them leads to disparities

00:14:14,480 --> 00:14:18,959
i having many positive calls with using

00:14:16,880 --> 00:14:21,519
their variance error only

00:14:18,959 --> 00:14:23,120
methods of only this environment

00:14:21,519 --> 00:14:25,680
expectations

00:14:23,120 --> 00:14:27,600
and photo fields are often treated

00:14:25,680 --> 00:14:29,839
especially in sql business

00:14:27,600 --> 00:14:30,720
as non-photo failures so avoid

00:14:29,839 --> 00:14:34,240
addressing this

00:14:30,720 --> 00:14:38,560
problem just leave it to the like the

00:14:34,240 --> 00:14:42,320
main um sorry like to the main trade and

00:14:38,560 --> 00:14:45,519
assume the user knows go to photo video

00:14:42,320 --> 00:14:46,720
so um libraries which are created fatal

00:14:45,519 --> 00:14:49,279
failure endless

00:14:46,720 --> 00:14:49,839
often require extra effort to be usable

00:14:49,279 --> 00:14:53,279
in

00:14:49,839 --> 00:14:54,079
projects to be integrated into other

00:14:53,279 --> 00:14:55,920
projects

00:14:54,079 --> 00:14:57,600
and i think the important lesson we've

00:14:55,920 --> 00:14:59,440
learnt here is that different projects

00:14:57,600 --> 00:15:01,199
of different needs and professions for

00:14:59,440 --> 00:15:04,720
field first environment

00:15:01,199 --> 00:15:06,880
this this is especially um

00:15:04,720 --> 00:15:07,920
visible in the embedded and operating

00:15:06,880 --> 00:15:10,639
system space

00:15:07,920 --> 00:15:14,480
where the needs become more evolved

00:15:10,639 --> 00:15:14,480
beyond just log into street air

00:15:14,560 --> 00:15:22,079
yeah and the so um xtx solution to this

00:15:18,720 --> 00:15:22,639
program is the panic mechanism a panic

00:15:22,079 --> 00:15:25,360
function

00:15:22,639 --> 00:15:26,880
is basically a configurable field first

00:15:25,360 --> 00:15:28,800
ambulance mechanism

00:15:26,880 --> 00:15:30,320
for handling and reporting facal

00:15:28,800 --> 00:15:32,800
failures providing

00:15:30,320 --> 00:15:34,480
additional context or information about

00:15:32,800 --> 00:15:35,279
the state of the system at the time of

00:15:34,480 --> 00:15:37,440
failure

00:15:35,279 --> 00:15:38,959
and then perform necessary cleanup

00:15:37,440 --> 00:15:41,120
routines

00:15:38,959 --> 00:15:42,079
a panic can be seen as a fancy stud

00:15:41,120 --> 00:15:44,800
about

00:15:42,079 --> 00:15:45,759
departing believer is customizable at

00:15:44,800 --> 00:15:47,920
both as one time

00:15:45,759 --> 00:15:50,560
via panic books and at compile time via

00:15:47,920 --> 00:15:53,920
the global panic handler

00:15:50,560 --> 00:15:56,399
um is the panic function and its

00:15:53,920 --> 00:15:57,199
functional signature the first overload

00:15:56,399 --> 00:15:59,199
provides

00:15:57,199 --> 00:16:00,639
a string video containing information

00:15:59,199 --> 00:16:04,160
about the cost of the

00:16:00,639 --> 00:16:09,839
abandonment we want to be going into

00:16:04,160 --> 00:16:09,839
detail about the second argument for now

00:16:11,199 --> 00:16:14,800
so um integrating the panic into our

00:16:14,160 --> 00:16:18,639
previous

00:16:14,800 --> 00:16:22,160
example is just as simple as this

00:16:18,639 --> 00:16:25,120
um let's see what information we'll get

00:16:22,160 --> 00:16:25,920
here is the um information i get we get

00:16:25,120 --> 00:16:31,040
more source

00:16:25,920 --> 00:16:31,040
level information than the previous ones

00:16:31,279 --> 00:16:36,959
um yeah so here the let's let's

00:16:34,399 --> 00:16:38,720
look through the information we get get

00:16:36,959 --> 00:16:41,360
the trade identifier

00:16:38,720 --> 00:16:42,160
get the function name already panic or

00:16:41,360 --> 00:16:44,480
code

00:16:42,160 --> 00:16:46,240
the file name the line number and column

00:16:44,480 --> 00:16:46,959
number you also get the error message

00:16:46,240 --> 00:16:50,560
that will pass

00:16:46,959 --> 00:16:52,720
through it yeah so

00:16:50,560 --> 00:16:54,480
um do you know that this simple sport

00:16:52,720 --> 00:16:56,240
doesn't have the cross platform trade

00:16:54,480 --> 00:16:58,880
naming capability so we just

00:16:56,240 --> 00:16:59,680
use the trade ash in the meantime which

00:16:58,880 --> 00:17:04,079
isn't

00:16:59,680 --> 00:17:07,520
like for most people of much use

00:17:04,079 --> 00:17:10,640
yeah so um

00:17:07,520 --> 00:17:13,919
let's say assuming you have the sdx

00:17:10,640 --> 00:17:16,959
batteries feature any board

00:17:13,919 --> 00:17:18,799
really is already make build file you

00:17:16,959 --> 00:17:20,559
can enable buttresses and you'll be able

00:17:18,799 --> 00:17:23,360
to see which part of the code

00:17:20,559 --> 00:17:25,520
was being executed on the functions that

00:17:23,360 --> 00:17:28,400
were presently on the call stack

00:17:25,520 --> 00:17:30,480
at the time of the error i find it's

00:17:28,400 --> 00:17:32,000
very useful

00:17:30,480 --> 00:17:33,520
instead of having to step into a

00:17:32,000 --> 00:17:37,440
debugger with the

00:17:33,520 --> 00:17:40,720
call dump and really hope you can

00:17:37,440 --> 00:17:42,160
um i hope she can reproduce the error a

00:17:40,720 --> 00:17:47,600
time time

00:17:42,160 --> 00:17:51,760
yeah so um

00:17:47,600 --> 00:17:53,840
you can also customize the panic handler

00:17:51,760 --> 00:17:55,679
which is the primary customization point

00:17:53,840 --> 00:17:57,679
for the panel function

00:17:55,679 --> 00:17:59,520
it is the part of the program where you

00:17:57,679 --> 00:18:00,400
perform necessary cleanups under

00:17:59,520 --> 00:18:03,760
consistency

00:18:00,400 --> 00:18:06,799
measures so there are few caveats

00:18:03,760 --> 00:18:09,280
to it first it must only be defined

00:18:06,799 --> 00:18:12,080
once across an executable which is the

00:18:09,280 --> 00:18:14,640
one definition rule

00:18:12,080 --> 00:18:17,120
it is also not intended for definition

00:18:14,640 --> 00:18:19,600
by library developers

00:18:17,120 --> 00:18:21,360
it is mostly meant for the high level

00:18:19,600 --> 00:18:23,120
application developers

00:18:21,360 --> 00:18:24,640
or just application developers in

00:18:23,120 --> 00:18:27,440
general

00:18:24,640 --> 00:18:28,559
um the panic antlers should be trade

00:18:27,440 --> 00:18:31,600
safe

00:18:28,559 --> 00:18:34,400
it should be signal safe and re-entrant

00:18:31,600 --> 00:18:35,840
and you should be very very conscious of

00:18:34,400 --> 00:18:38,000
shared states

00:18:35,840 --> 00:18:40,640
as many parts of the program can call

00:18:38,000 --> 00:18:43,600
panic at any point in time

00:18:40,640 --> 00:18:45,039
and it could be in it could be called

00:18:43,600 --> 00:18:46,960
from a context switching or

00:18:45,039 --> 00:18:48,720
multi-trading context

00:18:46,960 --> 00:18:51,120
so you have to be very conscious of

00:18:48,720 --> 00:18:54,559
shared states

00:18:51,120 --> 00:18:57,039
yeah so is are you um suppose you

00:18:54,559 --> 00:18:59,200
your desire feel first about them do you

00:18:57,039 --> 00:19:02,240
it's load to your file you'd write the

00:18:59,200 --> 00:19:06,000
panic handler as does

00:19:02,240 --> 00:19:09,120
um yeah so just um open

00:19:06,000 --> 00:19:10,720
the file um check if the file was

00:19:09,120 --> 00:19:15,200
successfully opened

00:19:10,720 --> 00:19:18,720
then write the look to it that's simple

00:19:15,200 --> 00:19:20,880
um yeah so um

00:19:18,720 --> 00:19:23,039
yeah rather than write it from scratch

00:19:20,880 --> 00:19:26,080
we have some helper functions that

00:19:23,039 --> 00:19:28,799
you can use to get your implementations

00:19:26,080 --> 00:19:30,640
we have the um panic alt which hold

00:19:28,799 --> 00:19:31,760
which holds the present trade of

00:19:30,640 --> 00:19:34,400
execution

00:19:31,760 --> 00:19:35,200
until it is forced to resume probably

00:19:34,400 --> 00:19:38,240
you attach

00:19:35,200 --> 00:19:40,320
a jtag debugger to it and

00:19:38,240 --> 00:19:41,600
set the variable the controlling

00:19:40,320 --> 00:19:44,000
variable to

00:19:41,600 --> 00:19:45,200
um to true which then results the

00:19:44,000 --> 00:19:49,120
program

00:19:45,200 --> 00:19:51,679
you can also use the panic about

00:19:49,120 --> 00:19:52,400
panel behavior which immediately cause

00:19:51,679 --> 00:19:55,600
stood up

00:19:52,400 --> 00:19:58,240
and doesn't log anything um

00:19:55,600 --> 00:19:58,880
we can also use the panic default

00:19:58,240 --> 00:20:00,799
behavior

00:19:58,880 --> 00:20:02,559
which locks the arrow reports to the

00:20:00,799 --> 00:20:03,840
which is the default point of behavior

00:20:02,559 --> 00:20:06,080
that logs the error report to the

00:20:03,840 --> 00:20:09,760
terminal and optionally gives you a

00:20:06,080 --> 00:20:12,799
bucket of the core stock

00:20:09,760 --> 00:20:15,039
yeah if you need a more dynamic

00:20:12,799 --> 00:20:17,200
panel behavior that you can customize at

00:20:15,039 --> 00:20:19,679
one time you can use panic oaks

00:20:17,200 --> 00:20:21,120
which works similarly to panic angler

00:20:19,679 --> 00:20:23,039
this is essentially useful for

00:20:21,120 --> 00:20:24,799
dynamically loaded libraries where you

00:20:23,039 --> 00:20:27,600
don't want the dll

00:20:24,799 --> 00:20:29,039
the dll to decide how to avoid the

00:20:27,600 --> 00:20:32,080
program

00:20:29,039 --> 00:20:34,480
um it is this is

00:20:32,080 --> 00:20:36,960
the primary customization panel it is

00:20:34,480 --> 00:20:39,760
the runtime panel customization point

00:20:36,960 --> 00:20:40,960
it's intercept calls to the global panic

00:20:39,760 --> 00:20:44,159
handler

00:20:40,960 --> 00:20:46,960
um yeah which is

00:20:44,159 --> 00:20:47,360
so um this is very identical to upsells

00:20:46,960 --> 00:20:50,240
raw

00:20:47,360 --> 00:20:51,360
login oak and llvm's fertile aero

00:20:50,240 --> 00:20:53,679
handler

00:20:51,360 --> 00:20:54,960
and also similar to tensorflow lite's

00:20:53,679 --> 00:20:57,760
micro

00:20:54,960 --> 00:20:57,760
error reporter

00:20:59,360 --> 00:21:03,760
is our here is some code of how you use

00:21:02,159 --> 00:21:06,799
the attached panic hook

00:21:03,760 --> 00:21:10,000
by default the panic under is set to um

00:21:06,799 --> 00:21:12,000
panic default so um but

00:21:10,000 --> 00:21:13,760
you are now intercepting it at one time

00:21:12,000 --> 00:21:16,640
so you are basically changing this

00:21:13,760 --> 00:21:18,080
the panel behavior at one time unlike

00:21:16,640 --> 00:21:20,240
the previous example where we

00:21:18,080 --> 00:21:21,840
just defined the function so you can

00:21:20,240 --> 00:21:25,039
just change it to any function at

00:21:21,840 --> 00:21:27,440
one time um yeah so

00:21:25,039 --> 00:21:29,200
in this example we use panic out and it

00:21:27,440 --> 00:21:30,240
will just hold the current trade of the

00:21:29,200 --> 00:21:33,120
execution

00:21:30,240 --> 00:21:34,000
until until you probably step into a

00:21:33,120 --> 00:21:36,240
debugger

00:21:34,000 --> 00:21:37,919
and inspect the program state and

00:21:36,240 --> 00:21:39,200
possibly force the trade to continue

00:21:37,919 --> 00:21:42,880
running which immediately

00:21:39,200 --> 00:21:44,240
wants to abort yeah so

00:21:42,880 --> 00:21:46,720
basically basically also works like

00:21:44,240 --> 00:21:50,400
stood terminate

00:21:46,720 --> 00:21:52,880
so that would be all for panic

00:21:50,400 --> 00:21:53,520
so um i would like us to take a few

00:21:52,880 --> 00:21:56,159
seconds

00:21:53,520 --> 00:21:58,559
to look at this code and try to infer

00:21:56,159 --> 00:22:00,720
what this shot is meant for

00:21:58,559 --> 00:22:00,720
now

00:22:03,760 --> 00:22:08,559
okay now let me give you more context

00:22:09,919 --> 00:22:13,840
now take a look at it again

00:22:15,520 --> 00:22:18,880
yeah i'm sure right now you must be

00:22:17,919 --> 00:22:21,760
thinking this is

00:22:18,880 --> 00:22:23,280
no terminated street pointer string

00:22:21,760 --> 00:22:25,679
pointer downloads

00:22:23,280 --> 00:22:26,720
but that's just what the naming tells

00:22:25,679 --> 00:22:29,120
you

00:22:26,720 --> 00:22:31,200
we naturally rely on naming to give us

00:22:29,120 --> 00:22:34,480
constant context about the code

00:22:31,200 --> 00:22:37,600
but naming expresses our intent not the

00:22:34,480 --> 00:22:41,840
truth about the code also naming is hard

00:22:37,600 --> 00:22:41,840
but we only try our best

00:22:43,120 --> 00:22:49,760
yeah so um disregarding the naming

00:22:47,919 --> 00:22:51,600
i want you to disregard the name the

00:22:49,760 --> 00:22:54,799
operational girl says on this

00:22:51,600 --> 00:22:58,240
short could be encapsulated by

00:22:54,799 --> 00:23:00,400
any of the following alternatives

00:22:58,240 --> 00:23:01,679
how many people remember value type

00:23:00,400 --> 00:23:03,919
alternatives

00:23:01,679 --> 00:23:05,919
so um they actually give more

00:23:03,919 --> 00:23:08,720
information about the truth

00:23:05,919 --> 00:23:09,120
and the intent of the code rather than

00:23:08,720 --> 00:23:12,400
what

00:23:09,120 --> 00:23:14,240
we said it does this is actually what

00:23:12,400 --> 00:23:16,400
we intend to use it this is actually

00:23:14,240 --> 00:23:19,919
what it does

00:23:16,400 --> 00:23:23,200
so um and i would like to um

00:23:19,919 --> 00:23:26,320
need to quote robert c martin

00:23:23,200 --> 00:23:27,280
which he said truth can only be found in

00:23:26,320 --> 00:23:30,880
one piece

00:23:27,280 --> 00:23:32,640
very code so our advisory professional

00:23:30,880 --> 00:23:35,039
value types they are defined at

00:23:32,640 --> 00:23:36,240
a high level the operations become

00:23:35,039 --> 00:23:40,159
perform on it

00:23:36,240 --> 00:23:42,799
and and possibly have a well-defined

00:23:40,159 --> 00:23:42,799
lifetimes

00:23:43,279 --> 00:23:46,880
so specifically the truth isn't what

00:23:45,760 --> 00:23:51,520
your code does

00:23:46,880 --> 00:23:53,919
not what you intend for it to do

00:23:51,520 --> 00:23:56,400
yeah let's move on to optional value

00:23:53,919 --> 00:23:56,400
handling

00:23:56,480 --> 00:24:00,240
um we have a few common techniques for

00:23:58,880 --> 00:24:02,960
optional value only

00:24:00,240 --> 00:24:03,600
in single squares today the most common

00:24:02,960 --> 00:24:06,640
one is the

00:24:03,600 --> 00:24:10,480
wrong pointers oral pointers approach

00:24:06,640 --> 00:24:12,559
they stood optional stud variants and

00:24:10,480 --> 00:24:13,840
various emails optional value

00:24:12,559 --> 00:24:17,279
implementations

00:24:13,840 --> 00:24:19,200
like absolute optional

00:24:17,279 --> 00:24:21,039
operation system is optional which is

00:24:19,200 --> 00:24:24,480
future optional

00:24:21,039 --> 00:24:27,520
and mozilla's maybe monarch and the

00:24:24,480 --> 00:24:31,039
awms optional

00:24:27,520 --> 00:24:34,320
value implementation yeah

00:24:31,039 --> 00:24:37,279
there are so still option now has a few

00:24:34,320 --> 00:24:38,320
possibly minor issues so yes it could

00:24:37,279 --> 00:24:42,240
compare in both

00:24:38,320 --> 00:24:46,240
techniques pointers instead of optional

00:24:42,240 --> 00:24:46,559
um to most reclaim the pointer technique

00:24:46,240 --> 00:24:50,159
is

00:24:46,559 --> 00:24:53,520
more readable and concise but that's

00:24:50,159 --> 00:24:55,600
that's no for me that's that's about

00:24:53,520 --> 00:25:00,240
true

00:24:55,600 --> 00:25:04,080
um yeah

00:25:00,240 --> 00:25:06,000
optional volume link code is really not

00:25:04,080 --> 00:25:08,159
that easier to write with a stored

00:25:06,000 --> 00:25:09,840
option now here's an example of how

00:25:08,159 --> 00:25:12,000
you'd write the same code

00:25:09,840 --> 00:25:13,600
um using the description control flow

00:25:12,000 --> 00:25:17,440
instead of the

00:25:13,600 --> 00:25:17,440
boolean control flow we used earlier

00:25:18,320 --> 00:25:24,080
another issue with optional that i find

00:25:21,520 --> 00:25:24,880
very programmatic in my code is that

00:25:24,080 --> 00:25:27,919
it's

00:25:24,880 --> 00:25:30,640
even copies you currently be

00:25:27,919 --> 00:25:31,200
already like be so sure of when copies

00:25:30,640 --> 00:25:34,240
are called

00:25:31,200 --> 00:25:36,240
instead optional as in the example here

00:25:34,240 --> 00:25:38,159
if you check the assembly output for the

00:25:36,240 --> 00:25:40,559
first example you'll notice that the

00:25:38,159 --> 00:25:42,960
container vector is copied

00:25:40,559 --> 00:25:44,720
and the memory allocation is performed

00:25:42,960 --> 00:25:47,919
iron with optimization

00:25:44,720 --> 00:25:51,360
turned on it can be quite problematic

00:25:47,919 --> 00:25:54,000
especially with no warnings about this

00:25:51,360 --> 00:25:54,880
reason for the second example you notice

00:25:54,000 --> 00:25:57,200
that we used an

00:25:54,880 --> 00:25:58,960
explicit stock move just to make sure

00:25:57,200 --> 00:26:01,279
that it is not copied

00:25:58,960 --> 00:26:02,000
the object's copies aren't really

00:26:01,279 --> 00:26:05,679
visible

00:26:02,000 --> 00:26:09,679
you can view the god board link in the

00:26:05,679 --> 00:26:12,880
um below to see what i'm trying to

00:26:09,679 --> 00:26:16,080
say here yeah

00:26:12,880 --> 00:26:17,520
another major issue i think um

00:26:16,080 --> 00:26:20,080
which is the major difference i see

00:26:17,520 --> 00:26:23,039
between these optional implementations

00:26:20,080 --> 00:26:25,120
is the outlaw for free tower failures

00:26:23,039 --> 00:26:27,440
from assessing and invalid states

00:26:25,120 --> 00:26:28,320
ie when there is when you try to get

00:26:27,440 --> 00:26:31,600
involved from an

00:26:28,320 --> 00:26:34,240
optional that doesn't have a value the

00:26:31,600 --> 00:26:36,799
handler is not really customizable

00:26:34,240 --> 00:26:41,200
in the installed optional case prism

00:26:36,799 --> 00:26:41,200
closed captioning not

00:26:51,200 --> 00:26:56,080
safe type available for representing the

00:26:53,760 --> 00:26:58,159
possible absence of a value

00:26:56,080 --> 00:26:59,919
scx option is a type community in the

00:26:58,159 --> 00:27:00,799
sense that it's abstract the optional

00:26:59,919 --> 00:27:03,520
value and the

00:27:00,799 --> 00:27:05,200
logic and those make handling the null

00:27:03,520 --> 00:27:07,679
and value states easier

00:27:05,200 --> 00:27:09,200
and provide clearer optimization path

00:27:07,679 --> 00:27:13,360
for the compiler

00:27:09,200 --> 00:27:16,240
another advantage to uh option is that

00:27:13,360 --> 00:27:16,880
is the clarity of intent immutability

00:27:16,240 --> 00:27:21,440
and

00:27:16,880 --> 00:27:24,880
composability of this type monarch

00:27:21,440 --> 00:27:27,039
yeah the ocean shock is basically

00:27:24,880 --> 00:27:27,919
implemented as a union with a type

00:27:27,039 --> 00:27:31,120
discriminant

00:27:27,919 --> 00:27:35,840
boolean that tells us whether it is a

00:27:31,120 --> 00:27:35,840
non oil value variant

00:27:35,919 --> 00:27:39,679
on the option short as a few

00:27:38,399 --> 00:27:43,120
constructors

00:27:39,679 --> 00:27:43,600
the song type is used for tag dispatch

00:27:43,120 --> 00:27:46,559
to the

00:27:43,600 --> 00:27:48,399
value variant state and the norm type is

00:27:46,559 --> 00:27:51,600
similarly used for tag dispatch

00:27:48,399 --> 00:27:54,399
to the non-variant state it

00:27:51,600 --> 00:27:55,200
also has some move constructors and copy

00:27:54,399 --> 00:27:58,799
constructors

00:27:55,200 --> 00:27:59,520
as usual so let's let's see some

00:27:58,799 --> 00:28:03,679
examples

00:27:59,520 --> 00:28:06,320
of option to obtain the value

00:28:03,679 --> 00:28:07,279
from the option we use the rap method

00:28:06,320 --> 00:28:10,080
call

00:28:07,279 --> 00:28:10,720
and to provide an alternate value in

00:28:10,080 --> 00:28:14,159
case the

00:28:10,720 --> 00:28:17,760
option is in non variant states

00:28:14,159 --> 00:28:22,480
we use the rap or method as shown below

00:28:17,760 --> 00:28:22,480
in the second disaccharide line

00:28:29,360 --> 00:28:33,360
for only in both the scenario where your

00:28:31,600 --> 00:28:36,559
value might be present or not

00:28:33,360 --> 00:28:38,880
present we use the match method as shown

00:28:36,559 --> 00:28:38,880
below

00:28:42,159 --> 00:28:48,960
yeah so as we can see here

00:28:45,440 --> 00:28:51,600
the um option is a type monarch

00:28:48,960 --> 00:28:52,320
um by that i mean it type you type a

00:28:51,600 --> 00:28:55,919
type with

00:28:52,320 --> 00:28:59,039
methods to obstruct actions it does

00:28:55,919 --> 00:29:01,440
basically mix error handling easier

00:28:59,039 --> 00:29:02,559
air only code easier to write and

00:29:01,440 --> 00:29:05,440
directly expresses

00:29:02,559 --> 00:29:06,640
intent without having the error handling

00:29:05,440 --> 00:29:10,240
or option handling

00:29:06,640 --> 00:29:14,000
noise let's look at one of the

00:29:10,240 --> 00:29:17,600
monadic methods which is the map oils

00:29:14,000 --> 00:29:18,480
method it's it's applies a function to

00:29:17,600 --> 00:29:22,000
the contain

00:29:18,480 --> 00:29:24,960
value if any or computes a default

00:29:22,000 --> 00:29:27,360
if not which is the second function

00:29:24,960 --> 00:29:30,080
argument

00:29:27,360 --> 00:29:30,960
so here is how you write the code with

00:29:30,080 --> 00:29:34,000
option

00:29:30,960 --> 00:29:35,760
and the second one is the

00:29:34,000 --> 00:29:37,200
one with pointers and the third one is

00:29:35,760 --> 00:29:40,799
one we start optional

00:29:37,200 --> 00:29:44,320
as we can see here stood option

00:29:40,799 --> 00:29:49,200
sorry stx options it's it's it's

00:29:44,320 --> 00:29:53,120
it directly um expresses the intent

00:29:49,200 --> 00:29:55,039
um yeah i'd also like to illustrate one

00:29:53,120 --> 00:29:57,919
of the optional value handling

00:29:55,039 --> 00:29:59,919
abstraction capabilities of onenote in

00:29:57,919 --> 00:30:03,039
the coach

00:29:59,919 --> 00:30:04,960
here we are changing multiple foldable

00:30:03,039 --> 00:30:07,039
operations that are optioned as a

00:30:04,960 --> 00:30:10,159
ubiquinone type

00:30:07,039 --> 00:30:12,640
the rxxx is basically arched by

00:30:10,159 --> 00:30:14,080
art hearts at shoe eyeglasses to a

00:30:12,640 --> 00:30:16,640
person

00:30:14,080 --> 00:30:17,520
so we have a person objects we want to

00:30:16,640 --> 00:30:21,840
style

00:30:17,520 --> 00:30:24,080
the person by adding various items to

00:30:21,840 --> 00:30:26,960
but it wants to return the person object

00:30:24,080 --> 00:30:29,600
if any of the operations fail

00:30:26,960 --> 00:30:31,360
which basically makes it fallible now

00:30:29,600 --> 00:30:34,480
here's how we do just that with the

00:30:31,360 --> 00:30:36,799
under method of the option type monad

00:30:34,480 --> 00:30:38,880
and here is the equivalence code of how

00:30:36,799 --> 00:30:41,039
you do that with student option now

00:30:38,880 --> 00:30:42,000
as you can see study option house code

00:30:41,039 --> 00:30:45,279
is quite

00:30:42,000 --> 00:30:47,840
noisy it notes how

00:30:45,279 --> 00:30:48,880
we are more clearly expressing intent by

00:30:47,840 --> 00:30:50,960
using the option

00:30:48,880 --> 00:30:53,039
monad for control flow and at the same

00:30:50,960 --> 00:30:55,679
time reducing the noise in the code

00:30:53,039 --> 00:30:55,679
in progress

00:30:59,039 --> 00:31:03,279
another reason why you might consider

00:31:00,960 --> 00:31:06,559
option is that unlike stored optional

00:31:03,279 --> 00:31:08,960
it doesn't throw exceptions in case

00:31:06,559 --> 00:31:09,679
of a request for your value and there is

00:31:08,960 --> 00:31:11,600
no

00:31:09,679 --> 00:31:14,559
value present but it calls the

00:31:11,600 --> 00:31:19,840
customizable global frequent

00:31:14,559 --> 00:31:19,840
video under which is the panic

00:31:20,720 --> 00:31:24,640
option has tons of other magnetic

00:31:22,960 --> 00:31:26,399
methods that can abstract with the

00:31:24,640 --> 00:31:27,600
optional value adding logic you can

00:31:26,399 --> 00:31:31,120
explore for yourself

00:31:27,600 --> 00:31:34,880
in these urls in the project url

00:31:31,120 --> 00:31:37,200
below hello and let's move on to error

00:31:34,880 --> 00:31:39,600
handling

00:31:37,200 --> 00:31:40,480
so always around linkedin is presupposed

00:31:39,600 --> 00:31:43,760
to be

00:31:40,480 --> 00:31:47,120
the startup method for erranding is with

00:31:43,760 --> 00:31:47,679
exceptions other methods include stereo

00:31:47,120 --> 00:31:51,440
code

00:31:47,679 --> 00:31:52,399
sentinel or return virus error output

00:31:51,440 --> 00:31:55,760
parameters

00:31:52,399 --> 00:31:58,399
with muslim pointers on the and the

00:31:55,760 --> 00:32:00,559
global stereo era

00:31:58,399 --> 00:32:01,600
error propagation markers like ensure

00:32:00,559 --> 00:32:04,799
okay expect

00:32:01,600 --> 00:32:07,919
equal um distort pair

00:32:04,799 --> 00:32:11,039
and they'll used to return both an error

00:32:07,919 --> 00:32:15,840
code on the on the value and

00:32:11,039 --> 00:32:15,840
other custom error editing types

00:32:16,080 --> 00:32:19,200
now exceptions

00:32:21,120 --> 00:32:28,640
exceptions are often considered as

00:32:24,399 --> 00:32:32,480
harmful so these are a few major um

00:32:28,640 --> 00:32:35,919
reasons which i really um

00:32:32,480 --> 00:32:39,440
already understand

00:32:35,919 --> 00:32:39,760
so um the first one is that exceptions

00:32:39,440 --> 00:32:42,880
of

00:32:39,760 --> 00:32:46,000
invisible control flow which is same

00:32:42,880 --> 00:32:46,399
but i see it as both an advantage and a

00:32:46,000 --> 00:32:49,679
big

00:32:46,399 --> 00:32:50,480
disadvantage because ideally any

00:32:49,679 --> 00:32:53,919
expression

00:32:50,480 --> 00:32:56,720
come true and there is no way of knowing

00:32:53,919 --> 00:32:58,320
which expression first and what express

00:32:56,720 --> 00:33:00,880
exception you chose

00:32:58,320 --> 00:33:01,519
mainly by looking at it you'd have to

00:33:00,880 --> 00:33:04,159
inspect the

00:33:01,519 --> 00:33:04,720
expressions source code to be sure if

00:33:04,159 --> 00:33:08,559
that

00:33:04,720 --> 00:33:10,399
if it is available if it is sorry if

00:33:08,559 --> 00:33:12,159
you want to check the you have to

00:33:10,399 --> 00:33:14,640
inspect the expression source code

00:33:12,159 --> 00:33:15,760
to be sure if the documentation for it

00:33:14,640 --> 00:33:18,320
is available

00:33:15,760 --> 00:33:20,000
or a proper or if it is a proprietary

00:33:18,320 --> 00:33:20,640
level you'd have to hold the library

00:33:20,000 --> 00:33:24,320
authors

00:33:20,640 --> 00:33:27,039
provide good documentation

00:33:24,320 --> 00:33:28,799
one is that code using exceptions is

00:33:27,039 --> 00:33:31,760
usually non-deterministic

00:33:28,799 --> 00:33:32,640
in addition real-time embedded systems

00:33:31,760 --> 00:33:35,840
code you don't

00:33:32,640 --> 00:33:37,360
want to you want to have a good idea of

00:33:35,840 --> 00:33:39,600
the amount of time

00:33:37,360 --> 00:33:40,880
each section of the code will execute

00:33:39,600 --> 00:33:44,320
for and its

00:33:40,880 --> 00:33:47,120
space or memory usage you can't do that

00:33:44,320 --> 00:33:47,840
with exceptions as most implementations

00:33:47,120 --> 00:33:50,880
use

00:33:47,840 --> 00:33:52,480
one time type information with a based

00:33:50,880 --> 00:33:55,279
allocation procedure

00:33:52,480 --> 00:33:56,080
and as we all know if allocation is not

00:33:55,279 --> 00:33:59,519
deterministic

00:33:56,080 --> 00:34:00,320
in time it can take a variable amount of

00:33:59,519 --> 00:34:03,360
time

00:34:00,320 --> 00:34:06,080
it's not really specific so um

00:34:03,360 --> 00:34:07,360
yeah another issue with it is type

00:34:06,080 --> 00:34:10,960
mismatch arrows

00:34:07,360 --> 00:34:11,679
eins like compile time change exceptions

00:34:10,960 --> 00:34:13,919
are

00:34:11,679 --> 00:34:15,599
often used like they are they you can

00:34:13,919 --> 00:34:17,359
there's a little difference between

00:34:15,599 --> 00:34:19,520
using exceptions and using their

00:34:17,359 --> 00:34:21,280
typing because you're they're basically

00:34:19,520 --> 00:34:23,200
doing type switching

00:34:21,280 --> 00:34:24,800
and they are not really checked so

00:34:23,200 --> 00:34:25,599
there's no telling when you use the

00:34:24,800 --> 00:34:28,000
wrong types

00:34:25,599 --> 00:34:28,000
for it

00:34:29,760 --> 00:34:35,119
um another issue a common issue with

00:34:33,119 --> 00:34:37,359
people other things that it is

00:34:35,119 --> 00:34:38,159
often hard to manage in large and

00:34:37,359 --> 00:34:41,440
evolving

00:34:38,159 --> 00:34:43,679
cold business so a lot of problems arise

00:34:41,440 --> 00:34:45,119
when a library implementer uses a

00:34:43,679 --> 00:34:48,240
certain exception

00:34:45,119 --> 00:34:51,359
for the failure that really happens

00:34:48,240 --> 00:34:53,440
and then duplicates and switches to

00:34:51,359 --> 00:34:55,679
another exception type

00:34:53,440 --> 00:34:56,480
so you as a user of the code will not

00:34:55,679 --> 00:34:59,440
know when this

00:34:56,480 --> 00:34:59,839
change occurs just like them type into

00:34:59,440 --> 00:35:02,960
of

00:34:59,839 --> 00:35:06,079
exceptions another issue

00:35:02,960 --> 00:35:08,960
of that i personally encounter is

00:35:06,079 --> 00:35:09,599
really touching support some teachers

00:35:08,960 --> 00:35:12,400
don't

00:35:09,599 --> 00:35:13,359
support exceptions and instead the

00:35:12,400 --> 00:35:16,079
unlisted

00:35:13,359 --> 00:35:16,640
results will feel fast about when you

00:35:16,079 --> 00:35:19,119
throw an

00:35:16,640 --> 00:35:19,760
exception an example is the extensor

00:35:19,119 --> 00:35:23,200
tool chain

00:35:19,760 --> 00:35:25,119
and the avr tool chain so

00:35:23,200 --> 00:35:27,359
yeah another issue is that nothing

00:35:25,119 --> 00:35:31,839
prevents the users from handling

00:35:27,359 --> 00:35:31,839
fatal or monthly android exceptions

00:35:32,400 --> 00:35:37,520
yeah so what problems did exceptions

00:35:35,760 --> 00:35:40,079
really solve

00:35:37,520 --> 00:35:41,440
i'll say there's some some they solve

00:35:40,079 --> 00:35:44,800
some problems

00:35:41,440 --> 00:35:45,520
for many people which are exceptions

00:35:44,800 --> 00:35:47,920
reduce

00:35:45,520 --> 00:35:48,720
a lot of clutter and noise in the error

00:35:47,920 --> 00:35:53,200
only

00:35:48,720 --> 00:35:56,960
code so the the exceptions also ensured

00:35:53,200 --> 00:35:58,800
errors can't be ignored though it is not

00:35:56,960 --> 00:36:01,280
by compiler enforcement

00:35:58,800 --> 00:36:02,000
but by tearing down the old program if

00:36:01,280 --> 00:36:04,960
the

00:36:02,000 --> 00:36:05,680
the exceptions aren't andrew the

00:36:04,960 --> 00:36:08,800
symptoms

00:36:05,680 --> 00:36:10,640
provide a somewhat unified error and the

00:36:08,800 --> 00:36:11,200
existence provides somewhat unified hero

00:36:10,640 --> 00:36:14,400
reporting

00:36:11,200 --> 00:36:18,320
interface yeah i'm going to

00:36:14,400 --> 00:36:22,000
put this on this um this message for

00:36:18,320 --> 00:36:24,560
um joe dorffy which is box and record

00:36:22,000 --> 00:36:26,800
variable errors

00:36:24,560 --> 00:36:29,040
remember i want you to remember that

00:36:26,800 --> 00:36:31,760
books of hotel failures and wasn't

00:36:29,040 --> 00:36:33,920
the recorder recovered from using

00:36:31,760 --> 00:36:34,960
exceptions means a caller some way of

00:36:33,920 --> 00:36:38,320
the call stack

00:36:34,960 --> 00:36:41,119
knows how to undo the error

00:36:38,320 --> 00:36:43,440
so you have to think more about using

00:36:41,119 --> 00:36:46,400
exceptions

00:36:43,440 --> 00:36:47,520
so um all really are exceptions ideal

00:36:46,400 --> 00:36:49,839
for

00:36:47,520 --> 00:36:51,359
this is the question that we are left to

00:36:49,839 --> 00:36:54,240
so i

00:36:51,359 --> 00:36:55,839
um the questions we are able to ask is

00:36:54,240 --> 00:36:58,640
not really a straightforward question

00:36:55,839 --> 00:37:00,240
we are off to ask what's reason for how

00:36:58,640 --> 00:37:03,280
usually them fulfill often

00:37:00,240 --> 00:37:04,640
or feel really if so how often are we

00:37:03,280 --> 00:37:06,560
talking about here

00:37:04,640 --> 00:37:08,560
i'll use them for recoverable or

00:37:06,560 --> 00:37:10,240
recoverable errors

00:37:08,560 --> 00:37:12,560
and also are we using them in

00:37:10,240 --> 00:37:14,079
time-consuming or non-time-consuming

00:37:12,560 --> 00:37:15,920
scenarios

00:37:14,079 --> 00:37:17,920
i personally don't have a concrete

00:37:15,920 --> 00:37:20,320
answer to this but i feel we should

00:37:17,920 --> 00:37:21,520
try to answer these questions do we want

00:37:20,320 --> 00:37:24,560
to decide to use

00:37:21,520 --> 00:37:27,359
exceptions yeah so

00:37:24,560 --> 00:37:28,800
results result is x6 solution to

00:37:27,359 --> 00:37:31,440
recoverable errors

00:37:28,800 --> 00:37:32,320
result is a type c from an addiction for

00:37:31,440 --> 00:37:35,599
non-fertile

00:37:32,320 --> 00:37:38,640
failures it either contains an error or

00:37:35,599 --> 00:37:40,960
is successful value so

00:37:38,640 --> 00:37:42,960
result is a menu is like option but

00:37:40,960 --> 00:37:46,160
results represent the possible

00:37:42,960 --> 00:37:48,320
presence of an alternate or error value

00:37:46,160 --> 00:37:50,800
the real value is used in constructing

00:37:48,320 --> 00:37:53,280
the error reports as appropriate

00:37:50,800 --> 00:37:55,200
it is in a sense very similar to stood

00:37:53,280 --> 00:37:57,440
uh sorry bruce expected

00:37:55,200 --> 00:37:59,119
but with a centralized fatal error

00:37:57,440 --> 00:38:00,480
reporting mechanism which we discussed

00:37:59,119 --> 00:38:05,119
earlier the panic

00:38:00,480 --> 00:38:07,920
and also has many mentals

00:38:05,119 --> 00:38:10,079
so um results is implemented as a safety

00:38:07,920 --> 00:38:10,880
neon with a boolean to represent where

00:38:10,079 --> 00:38:13,839
do you know

00:38:10,880 --> 00:38:16,240
storing a value or an arrow at a point

00:38:13,839 --> 00:38:16,240
in time

00:38:17,440 --> 00:38:23,359
yeah results also has some constructors

00:38:21,119 --> 00:38:24,880
they as you can see here the archetype

00:38:23,359 --> 00:38:28,079
is used for

00:38:24,880 --> 00:38:29,200
dispatch to the viral variant states

00:38:28,079 --> 00:38:32,160
which

00:38:29,200 --> 00:38:32,480
denotes sources and the arrow type which

00:38:32,160 --> 00:38:34,079
is

00:38:32,480 --> 00:38:36,160
similarly used for attack dispatch to

00:38:34,079 --> 00:38:36,480
the error variant states in which there

00:38:36,160 --> 00:38:39,839
is

00:38:36,480 --> 00:38:40,880
an error and as you can see it results

00:38:39,839 --> 00:38:44,240
only as

00:38:40,880 --> 00:38:44,839
a move constructor will go it doesn't

00:38:44,240 --> 00:38:48,640
have a

00:38:44,839 --> 00:38:51,839
constructor we'll go into that later

00:38:48,640 --> 00:38:52,720
yeah so as i said earlier you notice

00:38:51,839 --> 00:38:55,680
that

00:38:52,720 --> 00:38:57,520
results don't have a copy constructor

00:38:55,680 --> 00:39:00,800
because it is primarily used as a

00:38:57,520 --> 00:39:03,119
rebound channel using the free twin

00:39:00,800 --> 00:39:05,839
channel as a returning channel means

00:39:03,119 --> 00:39:08,560
detention must be as fast as possible

00:39:05,839 --> 00:39:11,040
without invisible copies of the object

00:39:08,560 --> 00:39:12,240
being passed which would otherwise be

00:39:11,040 --> 00:39:14,400
costly for large

00:39:12,240 --> 00:39:18,079
objects especially ones that perform

00:39:14,400 --> 00:39:18,079
dynamic memory allocation

00:39:18,480 --> 00:39:22,160
like like story vector

00:39:24,160 --> 00:39:30,079
let's let's look at some examples of how

00:39:27,280 --> 00:39:32,160
you use results in your code base today

00:39:30,079 --> 00:39:33,119
all right um we are writing a simple

00:39:32,160 --> 00:39:35,520
password

00:39:33,119 --> 00:39:36,960
which just gets the first character and

00:39:35,520 --> 00:39:39,680
maps it to your version

00:39:36,960 --> 00:39:41,520
number you can observe how we use the

00:39:39,680 --> 00:39:44,800
okay and error type for your

00:39:41,520 --> 00:39:45,119
17 sources and error let's look at some

00:39:44,800 --> 00:39:47,200
of

00:39:45,119 --> 00:39:50,079
results let's now look at some of the

00:39:47,200 --> 00:39:50,079
results methods

00:39:51,280 --> 00:39:56,000
first off is the match method which we

00:39:54,560 --> 00:39:58,480
used for handling both the

00:39:56,000 --> 00:39:59,920
case where there was a successful pass

00:39:58,480 --> 00:40:03,599
and where

00:39:59,920 --> 00:40:07,040
and where there was no successful pass

00:40:03,599 --> 00:40:07,040
so um yeah

00:40:08,240 --> 00:40:11,920
now let's look at another method the

00:40:10,720 --> 00:40:14,319
oral method

00:40:11,920 --> 00:40:15,280
it works similar to options or of as it

00:40:14,319 --> 00:40:18,000
caused the global

00:40:15,280 --> 00:40:18,720
panic under you found error of course as

00:40:18,000 --> 00:40:22,640
you can see

00:40:18,720 --> 00:40:26,079
that's the second operation we show

00:40:22,640 --> 00:40:28,960
so yeah let's see what the

00:40:26,079 --> 00:40:28,960
output will be

00:40:29,760 --> 00:40:32,880
we'll get some useful information about

00:40:31,520 --> 00:40:34,720
the error but

00:40:32,880 --> 00:40:36,720
what if we need to provide more

00:40:34,720 --> 00:40:37,440
information based on the function

00:40:36,720 --> 00:40:40,800
context

00:40:37,440 --> 00:40:41,839
as which the record on wrap we can use

00:40:40,800 --> 00:40:44,240
the expect

00:40:41,839 --> 00:40:44,240
method

00:40:46,000 --> 00:40:51,200
so here's how we use the expect method

00:40:48,880 --> 00:40:53,040
it sticks a string view

00:40:51,200 --> 00:40:54,560
as an argument which used to provide

00:40:53,040 --> 00:40:57,200
context specific error

00:40:54,560 --> 00:40:57,200
information

00:40:58,960 --> 00:41:03,119
now we can see the outputs here

00:41:04,640 --> 00:41:08,880
the only difference is that so we add

00:41:06,560 --> 00:41:11,599
more context specific information to the

00:41:08,880 --> 00:41:11,599
error message

00:41:12,160 --> 00:41:22,000
now let's look at error propagation

00:41:15,359 --> 00:41:22,000
with with our errorly macro try okay um

00:41:22,880 --> 00:41:27,119
the pause file function illustrates how

00:41:25,520 --> 00:41:30,160
the error show will be

00:41:27,119 --> 00:41:30,800
try okay macro it basically returns the

00:41:30,160 --> 00:41:34,160
error

00:41:30,800 --> 00:41:36,800
type if the pause version function

00:41:34,160 --> 00:41:37,839
fails and the result is constructed by

00:41:36,800 --> 00:41:41,599
type dispatch

00:41:37,839 --> 00:41:43,440
from the error type this is basically an

00:41:41,599 --> 00:41:46,319
emulation of the automatic

00:41:43,440 --> 00:41:46,720
error propagation we get from exceptions

00:41:46,319 --> 00:41:49,359
but

00:41:46,720 --> 00:41:51,599
unlike exceptions this is invisible and

00:41:49,359 --> 00:41:52,079
concise we know at what part of the

00:41:51,599 --> 00:41:55,520
program

00:41:52,079 --> 00:41:55,520
the propagation occurs

00:41:56,400 --> 00:42:02,480
um similar to option

00:41:59,839 --> 00:42:03,680
the option when i demonstrated a layer

00:42:02,480 --> 00:42:07,119
here is our

00:42:03,680 --> 00:42:07,119
control flow with results

00:42:07,599 --> 00:42:12,640
in the exceptions counterpart the

00:42:09,839 --> 00:42:14,560
exception is automatically propagated

00:42:12,640 --> 00:42:16,319
the results honored as similar

00:42:14,560 --> 00:42:20,000
abstraction capabilities

00:42:16,319 --> 00:42:20,000
via its monolithic methods

00:42:22,400 --> 00:42:26,000
so here's how you'd write the same code

00:42:24,800 --> 00:42:29,200
with outputs

00:42:26,000 --> 00:42:32,319
pointers on the right for

00:42:29,200 --> 00:42:37,599
foreign which is in a sense quite

00:42:32,319 --> 00:42:37,599
verbose and i'm very clothed

00:42:38,240 --> 00:42:41,280
now let's take a brief look into how you

00:42:40,960 --> 00:42:44,000
do

00:42:41,280 --> 00:42:45,040
a reporting of the results type you have

00:42:44,000 --> 00:42:47,920
a demonstration

00:42:45,040 --> 00:42:50,079
function named head which we assumes

00:42:47,920 --> 00:42:53,119
perform let's assume it performs a

00:42:50,079 --> 00:42:54,000
request it returns an error and we call

00:42:53,119 --> 00:42:57,200
the or up

00:42:54,000 --> 00:42:58,640
method on it let's say what's what's

00:42:57,200 --> 00:43:00,800
what is love to the

00:42:58,640 --> 00:43:03,119
console says there's there's definitely

00:43:00,800 --> 00:43:06,160
a figure there

00:43:03,119 --> 00:43:09,520
now this is the error of this it gets

00:43:06,160 --> 00:43:12,880
very um we get very little information

00:43:09,520 --> 00:43:16,079
about the nature of the era based on the

00:43:12,880 --> 00:43:18,640
value of the results

00:43:16,079 --> 00:43:19,839
now we as you can remember in the

00:43:18,640 --> 00:43:22,960
previous slide here

00:43:19,839 --> 00:43:25,280
we return a k assets denied error

00:43:22,960 --> 00:43:26,960
on the terminal we nearly give much

00:43:25,280 --> 00:43:29,359
information about that

00:43:26,960 --> 00:43:30,640
we can give more information or context

00:43:29,359 --> 00:43:35,920
about that with the

00:43:30,640 --> 00:43:35,920
report area with sdx error reporting

00:43:36,240 --> 00:43:42,880
so for your custom types you can define

00:43:39,280 --> 00:43:44,640
a reports in reports method you can

00:43:42,880 --> 00:43:47,839
train reports for it

00:43:44,640 --> 00:43:51,200
so um here is how you define the reports

00:43:47,839 --> 00:43:52,400
operation here's how you construct an

00:43:51,200 --> 00:43:56,160
error report from the

00:43:52,400 --> 00:43:58,079
error type as illustrated it's

00:43:56,160 --> 00:43:59,280
it's not necessarily right in this way

00:43:58,079 --> 00:44:00,480
you can only function that

00:43:59,280 --> 00:44:01,920
responsibility

00:44:00,480 --> 00:44:04,000
based on the error value and just

00:44:01,920 --> 00:44:05,119
construct these particles directly from

00:44:04,000 --> 00:44:08,079
there

00:44:05,119 --> 00:44:08,560
um spanning processing type usb over a

00:44:08,079 --> 00:44:11,760
string

00:44:08,560 --> 00:44:16,000
or contiguous bright sequence

00:44:11,760 --> 00:44:18,240
so uh now as we've defined our

00:44:16,000 --> 00:44:20,079
report let's see what we'll get on the

00:44:18,240 --> 00:44:22,960
console

00:44:20,079 --> 00:44:25,520
yeah there's the error you'll get the

00:44:22,960 --> 00:44:25,520
reporting

00:44:25,760 --> 00:44:28,960
do you notice uh because of information

00:44:28,160 --> 00:44:31,839
based on the

00:44:28,960 --> 00:44:31,839
error type

00:44:32,160 --> 00:44:38,480
now you can check on more online methods

00:44:34,720 --> 00:44:38,480
at the documentation as usual

00:44:39,119 --> 00:44:43,160
yeah so now let's perform some

00:44:41,920 --> 00:44:46,480
benchmarks and say

00:44:43,160 --> 00:44:49,200
our results performs

00:44:46,480 --> 00:44:49,920
so um we'll be performing two nested

00:44:49,200 --> 00:44:51,839
foliable

00:44:49,920 --> 00:44:53,119
divide divisions and supporting them

00:44:51,839 --> 00:44:56,319
into three different

00:44:53,119 --> 00:44:56,880
functions uh the division is just

00:44:56,319 --> 00:45:01,839
basically

00:44:56,880 --> 00:45:01,839
x divided by y divided by z so

00:45:02,640 --> 00:45:05,599
you don't really need to pay much

00:45:04,000 --> 00:45:06,880
attention to the code we'll be showing

00:45:05,599 --> 00:45:09,520
for this simple case

00:45:06,880 --> 00:45:11,280
benchmark it can always be record on the

00:45:09,520 --> 00:45:14,160
top repository

00:45:11,280 --> 00:45:16,000
the benchmarks will perform using the

00:45:14,160 --> 00:45:18,880
google benchmark tool

00:45:16,000 --> 00:45:19,359
so um this benchmark will illustrate a

00:45:18,880 --> 00:45:22,480
few

00:45:19,359 --> 00:45:24,640
properties which is a common um

00:45:22,480 --> 00:45:26,960
the common propagation depth there will

00:45:24,640 --> 00:45:30,400
be communication code bases

00:45:26,960 --> 00:45:32,240
the it illustrates a common use case

00:45:30,400 --> 00:45:34,960
uh the nature of the resources are

00:45:32,240 --> 00:45:36,960
failure path for each method

00:45:34,960 --> 00:45:38,160
so the video part is basically is

00:45:36,960 --> 00:45:40,480
basically when both

00:45:38,160 --> 00:45:42,000
divisions fail and resources path is

00:45:40,480 --> 00:45:45,119
when both divisions

00:45:42,000 --> 00:45:49,200
associate society so um

00:45:45,119 --> 00:45:49,680
yeah they here's the benchmark called

00:45:49,200 --> 00:45:53,440
foster

00:45:49,680 --> 00:45:55,520
variant um you'll notice we use um

00:45:53,440 --> 00:45:57,440
benchmark do not optimize because the

00:45:55,520 --> 00:46:00,160
compiler can't try to optimize some

00:45:57,440 --> 00:46:02,800
variables away

00:46:00,160 --> 00:46:04,960
so and basically the action is never

00:46:02,800 --> 00:46:09,280
performed

00:46:04,960 --> 00:46:09,280
here's the benchmark code for exceptions

00:46:10,079 --> 00:46:15,839
and here's the smart code for stx

00:46:12,839 --> 00:46:15,839
results

00:46:17,040 --> 00:46:20,720
and here's the benchmark for force this

00:46:19,280 --> 00:46:24,640
is style error only

00:46:20,720 --> 00:46:24,640
which is basically output pointers

00:46:25,119 --> 00:46:29,520
now here are your results for the rp

00:46:28,000 --> 00:46:33,280
path which is when both

00:46:29,520 --> 00:46:35,119
um divisions associate you can see

00:46:33,280 --> 00:46:36,560
that they all perform within the same

00:46:35,119 --> 00:46:40,880
reach for resources for ap

00:46:36,560 --> 00:46:43,200
path as there is some minor system noise

00:46:40,880 --> 00:46:44,400
but let's see how they perform on the

00:46:43,200 --> 00:46:48,160
side path

00:46:44,400 --> 00:46:51,359
which is where both divisions feel

00:46:48,160 --> 00:46:53,599
as expected the implementation using

00:46:51,359 --> 00:46:55,359
exceptions performed terribly for the

00:46:53,599 --> 00:46:57,119
video or support

00:46:55,359 --> 00:46:58,400
so let's let's let's quickly see what

00:46:57,119 --> 00:47:01,119
the actual values are

00:46:58,400 --> 00:47:01,119
on the table

00:47:01,760 --> 00:47:05,319
we can see that the implementation using

00:47:03,599 --> 00:47:08,960
exceptions as a

00:47:05,319 --> 00:47:11,520
554 384 percent

00:47:08,960 --> 00:47:13,440
latency increase compared to the system

00:47:11,520 --> 00:47:15,520
error only method

00:47:13,440 --> 00:47:18,319
but we should remember that their

00:47:15,520 --> 00:47:20,800
primary design concentration

00:47:18,319 --> 00:47:21,359
wasn't for failed orphan functions but

00:47:20,800 --> 00:47:23,680
for

00:47:21,359 --> 00:47:25,280
failed relief functions so it's

00:47:23,680 --> 00:47:28,240
advisable to prevent you

00:47:25,280 --> 00:47:30,000
using present exception implementations

00:47:28,240 --> 00:47:31,920
on earth's code path

00:47:30,000 --> 00:47:33,680
we can see that the information using

00:47:31,920 --> 00:47:35,599
results is just as fast as the

00:47:33,680 --> 00:47:39,839
application using the system

00:47:35,599 --> 00:47:41,920
error online

00:47:39,839 --> 00:47:42,960
i would like to leave us with a few

00:47:41,920 --> 00:47:45,599
notes from

00:47:42,960 --> 00:47:47,520
john short stroke and they suppose

00:47:45,599 --> 00:47:48,240
exceptions and authorities people which

00:47:47,520 --> 00:47:51,359
is

00:47:48,240 --> 00:47:54,400
there are multiple exceptions than of

00:47:51,359 --> 00:47:57,599
performance the coin discussion of

00:47:54,400 --> 00:47:58,240
exceptions tend to focus on performance

00:47:57,599 --> 00:48:00,240
however

00:47:58,240 --> 00:48:01,599
error handling is a prime software

00:48:00,240 --> 00:48:05,359
engineering topic

00:48:01,599 --> 00:48:08,240
i recommend a greater focus on notation

00:48:05,359 --> 00:48:08,640
on drill of constructors disruptors and

00:48:08,240 --> 00:48:11,680
are

00:48:08,640 --> 00:48:14,160
right on the effects of

00:48:11,680 --> 00:48:15,359
unreadability from literally tests and

00:48:14,160 --> 00:48:18,240
annotations

00:48:15,359 --> 00:48:19,200
on the guarantees offered and on the

00:48:18,240 --> 00:48:22,640
complexity

00:48:19,200 --> 00:48:27,599
of the cost of passing information about

00:48:22,640 --> 00:48:30,880
an error of the coaching

00:48:27,599 --> 00:48:34,720
yeah so yeah some useful links

00:48:30,880 --> 00:48:37,839
in case you want to know more about stx

00:48:34,720 --> 00:48:39,520
yeah thanks for listening um i think we

00:48:37,839 --> 00:48:42,720
still have a few

00:48:39,520 --> 00:48:44,240
minutes to take some questions so yeah

00:48:42,720 --> 00:48:47,599
please drop your questions in the

00:48:44,240 --> 00:49:03,839
qrd section and remove and go

00:48:47,599 --> 00:49:03,839
outside if i can

00:49:09,200 --> 00:49:11,280

YouTube URL: https://www.youtube.com/watch?v=MpWtS_I_pJI


