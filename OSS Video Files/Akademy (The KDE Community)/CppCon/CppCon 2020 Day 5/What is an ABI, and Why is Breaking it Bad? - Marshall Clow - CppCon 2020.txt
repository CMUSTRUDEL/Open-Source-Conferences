Title: What is an ABI, and Why is Breaking it Bad? - Marshall Clow - CppCon 2020
Publication date: 2021-01-28
Playlist: CppCon 2020 Day 5
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Occasionally, someone will toss out in discussion “That’s an ABI breaking change”. What does that mean? Is that a problem? In this talk, I’ll walk though what an ABI is, show a couple different kinds of ABI, and give examples of innocuous changes that caused an “ABI break”. I’ll talk about history (libstdc++ and string, and others), and talk about some things that the C++ committee is considering.

---
Marshall has been programming professionally for almost 40 years. He is the author of Boost.Algorithm, and has been a contributor to Boost for more almost 20 years. Until recently, he was the chairman of the Library working group of the C++ standard committee, and the lead developer for libc++, the C++ standard library for LLVM.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,320 --> 00:00:12,880
thank you john

00:00:09,679 --> 00:00:14,960
and welcome everybody um sorry i will

00:00:12,880 --> 00:00:16,480
give this in september but we had a

00:00:14,960 --> 00:00:19,920
family emergency and

00:00:16,480 --> 00:00:23,199
it's taken me a while to dig out for my

00:00:19,920 --> 00:00:23,920
uh anyway the title talk is uh what is

00:00:23,199 --> 00:00:26,480
an api

00:00:23,920 --> 00:00:27,760
and why is it breaking breaking it bad

00:00:26,480 --> 00:00:31,039
there's been a bunch of

00:00:27,760 --> 00:00:32,239
talk on various reflectors and groups

00:00:31,039 --> 00:00:35,360
about

00:00:32,239 --> 00:00:37,040
aba bar abi breaks and on standard

00:00:35,360 --> 00:00:37,920
committee mailing lists and so on like

00:00:37,040 --> 00:00:41,040
that

00:00:37,920 --> 00:00:43,920
um so i thought i'd

00:00:41,040 --> 00:00:44,879
give some content and some opinion so on

00:00:43,920 --> 00:00:47,280
uh

00:00:44,879 --> 00:00:48,640
is you have a button down at the bottom

00:00:47,280 --> 00:00:52,640
of the zoom

00:00:48,640 --> 00:00:56,000
um window for asking questions

00:00:52,640 --> 00:00:58,879
um as during the talk

00:00:56,000 --> 00:01:00,239
i probably won't respond to them as we

00:00:58,879 --> 00:01:03,680
go on but i'll hang on

00:01:00,239 --> 00:01:06,479
and answer them at the end um anyway

00:01:03,680 --> 00:01:08,240
about me because it's always about me uh

00:01:06,479 --> 00:01:11,200
my name is marshall clow

00:01:08,240 --> 00:01:12,880
uh i know last february i was the

00:01:11,200 --> 00:01:16,000
chairman of library working group

00:01:12,880 --> 00:01:18,159
on the roswell standards committee i've

00:01:16,000 --> 00:01:19,680
been maintaining libsy plus plus for a

00:01:18,159 --> 00:01:23,280
long time

00:01:19,680 --> 00:01:26,720
um i'm doing less of that now and

00:01:23,280 --> 00:01:29,200
i'm cutting back workload

00:01:26,720 --> 00:01:30,479
um because we've like i said we've had a

00:01:29,200 --> 00:01:34,159
lot of family problems

00:01:30,479 --> 00:01:37,439
anyway so let's just jump right into

00:01:34,159 --> 00:01:41,119
this uh this talk what is an abi

00:01:37,439 --> 00:01:45,040
why would breaking it be bad

00:01:41,119 --> 00:01:48,079
and why are my slides now

00:01:45,040 --> 00:01:50,399
okay what is an avi break

00:01:48,079 --> 00:01:52,240
well i'll get to that i've got a lot of

00:01:50,399 --> 00:01:53,040
slides before i get to what is an avi

00:01:52,240 --> 00:01:55,360
break but

00:01:53,040 --> 00:01:56,479
abi stands for application binary

00:01:55,360 --> 00:01:59,520
interface

00:01:56,479 --> 00:02:03,360
and it is has to do with

00:01:59,520 --> 00:02:06,960
um things like parameter passing and

00:02:03,360 --> 00:02:09,119
layouts layout structures and having

00:02:06,960 --> 00:02:11,039
how exceptions are handled and so on and

00:02:09,119 --> 00:02:15,599
this is this is not

00:02:11,039 --> 00:02:17,680
strictly a concern of the standard libra

00:02:15,599 --> 00:02:20,840
of the the sea postpone standard this is

00:02:17,680 --> 00:02:23,840
a concern for the platform vendors

00:02:20,840 --> 00:02:26,160
um you know you you don't

00:02:23,840 --> 00:02:28,400
expect to be able to sell something for

00:02:26,160 --> 00:02:31,840
arm and run it on x86

00:02:28,400 --> 00:02:33,920
or vice versa to say something or

00:02:31,840 --> 00:02:35,360
you know on a risk five machine or

00:02:33,920 --> 00:02:37,760
something like

00:02:35,360 --> 00:02:39,120
are not only are the instruction sets

00:02:37,760 --> 00:02:41,920
not compatible but the

00:02:39,120 --> 00:02:44,959
layout of structs may not be the size of

00:02:41,920 --> 00:02:47,200
integers may not be the same and so on

00:02:44,959 --> 00:02:49,680
so that's not really what i'm going to

00:02:47,200 --> 00:02:52,319
talk about today about cross

00:02:49,680 --> 00:02:55,519
avi you know about interoperability

00:02:52,319 --> 00:02:58,879
concerns but all on a single platform

00:02:55,519 --> 00:03:01,440
but um i wanted to make the point that

00:02:58,879 --> 00:03:03,360
the abi the application binary interface

00:03:01,440 --> 00:03:06,640
is really defined by the platform

00:03:03,360 --> 00:03:10,319
not by the c plus plus standard

00:03:06,640 --> 00:03:13,120
okay anyway um

00:03:10,319 --> 00:03:13,440
in c plus plus and in c actually there's

00:03:13,120 --> 00:03:16,640
this

00:03:13,440 --> 00:03:19,599
this idea of the one definition rule

00:03:16,640 --> 00:03:21,200
um there's a really nice right write up

00:03:19,599 --> 00:03:24,080
of it on c plus plus

00:03:21,200 --> 00:03:26,000
cpp reference you can search for one

00:03:24,080 --> 00:03:27,440
definition rule on c plus reference

00:03:26,000 --> 00:03:30,480
it'll take you right to the page

00:03:27,440 --> 00:03:32,959
excuse me right to the page there

00:03:30,480 --> 00:03:34,720
and basically you know it there's a lot

00:03:32,959 --> 00:03:38,239
of words there

00:03:34,720 --> 00:03:40,239
but basically what it comes down to is

00:03:38,239 --> 00:03:42,319
says if there's more than one

00:03:40,239 --> 00:03:43,360
non-identical definition of an entity in

00:03:42,319 --> 00:03:45,280
a program

00:03:43,360 --> 00:03:46,959
then the behavior of that program is

00:03:45,280 --> 00:03:48,480
undefined

00:03:46,959 --> 00:03:50,319
i've given a bunch of talks about

00:03:48,480 --> 00:03:50,879
undefined behavior i've given the talks

00:03:50,319 --> 00:03:52,560
about

00:03:50,879 --> 00:03:53,920
just straight up undefined behavior

00:03:52,560 --> 00:03:55,840
about tools help you find

00:03:53,920 --> 00:03:57,680
finding behavior like address sanitizer

00:03:55,840 --> 00:03:59,599
or ubsan

00:03:57,680 --> 00:04:00,879
and you could kind of think of this as

00:03:59,599 --> 00:04:02,879
another uh

00:04:00,879 --> 00:04:05,200
another in that series of talks but

00:04:02,879 --> 00:04:06,159
mostly this is about a very specific

00:04:05,200 --> 00:04:09,040
thing

00:04:06,159 --> 00:04:09,680
that has recently become a top of

00:04:09,040 --> 00:04:12,959
interest

00:04:09,680 --> 00:04:14,319
on the standards committee so an abi

00:04:12,959 --> 00:04:17,759
break is basically a

00:04:14,319 --> 00:04:18,639
very specific odr violation and it's an

00:04:17,759 --> 00:04:21,280
artifact of

00:04:18,639 --> 00:04:21,759
separate compilation separate linkings

00:04:21,280 --> 00:04:24,800
of

00:04:21,759 --> 00:04:28,080
shared libraries usually but not always

00:04:24,800 --> 00:04:30,800
um if we had no shared compilation there

00:04:28,080 --> 00:04:34,800
would be no api breaks

00:04:30,800 --> 00:04:37,840
okay all right so let's look at some

00:04:34,800 --> 00:04:40,639
odr files

00:04:37,840 --> 00:04:42,720
um here's some examples and wow i've

00:04:40,639 --> 00:04:43,919
lost the title to the slide

00:04:42,720 --> 00:04:45,759
um you can have two different

00:04:43,919 --> 00:04:49,120
definitions of something

00:04:45,759 --> 00:04:50,800
you can um

00:04:49,120 --> 00:04:52,880
you can change the layout of the struct

00:04:50,800 --> 00:04:54,639
you can do a bunch of things to it and i

00:04:52,880 --> 00:04:55,680
actually have examples so we'll move

00:04:54,639 --> 00:04:59,120
right on past

00:04:55,680 --> 00:05:00,800
this slide which doesn't have a title

00:04:59,120 --> 00:05:02,720
okay so let's start with this one here

00:05:00,800 --> 00:05:06,479
we have a struct struct foo

00:05:02,720 --> 00:05:10,240
it has two members right it has

00:05:06,479 --> 00:05:12,160
an n32 ta and hit 32 tb

00:05:10,240 --> 00:05:13,360
i'm using in these examples i'm using

00:05:12,160 --> 00:05:15,440
institute

00:05:13,360 --> 00:05:19,520
as opposed to int or long or whatever

00:05:15,440 --> 00:05:22,400
because i really don't want to get into

00:05:19,520 --> 00:05:24,800
um discussions of well on this platform

00:05:22,400 --> 00:05:28,240
and into 32 bits on this platform is in

00:05:24,800 --> 00:05:30,800
64 bits and on the so on and so forth

00:05:28,240 --> 00:05:32,479
that's that's not of the point of the

00:05:30,800 --> 00:05:34,880
these examples

00:05:32,479 --> 00:05:36,080
here we have a struct it has two fields

00:05:34,880 --> 00:05:39,520
a and b

00:05:36,080 --> 00:05:40,560
it's a very simple but in this other

00:05:39,520 --> 00:05:43,199
header file

00:05:40,560 --> 00:05:44,800
we have another definition for foo and

00:05:43,199 --> 00:05:48,160
it's different

00:05:44,800 --> 00:05:49,039
it has three fields the first two are

00:05:48,160 --> 00:05:54,479
the same

00:05:49,039 --> 00:05:54,479
but the third one is different and so

00:05:55,120 --> 00:06:00,160
you just we flip back and forth here you

00:05:57,039 --> 00:06:03,199
see that that's the only difference

00:06:00,160 --> 00:06:07,680
okay but the question is what happens

00:06:03,199 --> 00:06:09,840
if you mix two chunks of code which has

00:06:07,680 --> 00:06:12,000
seen

00:06:09,840 --> 00:06:13,680
food the first definition of food and

00:06:12,000 --> 00:06:15,759
one of which has seen the second

00:06:13,680 --> 00:06:18,400
definition of food

00:06:15,759 --> 00:06:18,880
so the first definition will believe

00:06:18,400 --> 00:06:22,479
that

00:06:18,880 --> 00:06:24,479
a foo is eight bytes long and the

00:06:22,479 --> 00:06:27,280
definition will include we believe that

00:06:24,479 --> 00:06:30,720
foo is twelve of ice law

00:06:27,280 --> 00:06:34,080
and if so if you mix these if you

00:06:30,720 --> 00:06:35,759
pass foos around in some way

00:06:34,080 --> 00:06:37,600
foods pointer to the foods arrays of

00:06:35,759 --> 00:06:40,639
foods

00:06:37,600 --> 00:06:42,960
um this could cause

00:06:40,639 --> 00:06:45,199
problems your code will behave if you

00:06:42,960 --> 00:06:48,560
you know you're lucky

00:06:45,199 --> 00:06:50,080
um your code will crash quickly viable

00:06:48,560 --> 00:06:52,720
if you're not lucky you'll get wrong

00:06:50,080 --> 00:06:54,400
answers if you're really unlucky you'll

00:06:52,720 --> 00:06:56,560
get

00:06:54,400 --> 00:06:58,800
reasonable looking wrong answers or

00:06:56,560 --> 00:07:00,960
occasionally right answers

00:06:58,800 --> 00:07:02,240
to my mind that's the worst yes this is

00:07:00,960 --> 00:07:05,520
just undefined behavior

00:07:02,240 --> 00:07:07,599
okay but the point is is that you know

00:07:05,520 --> 00:07:09,199
this is the kind of things that can

00:07:07,599 --> 00:07:13,120
happen

00:07:09,199 --> 00:07:13,440
um just beside there if you have classes

00:07:13,120 --> 00:07:16,240
that

00:07:13,440 --> 00:07:18,000
inherit from foo or contain memorables

00:07:16,240 --> 00:07:21,360
of type food

00:07:18,000 --> 00:07:24,240
um they're affected as well

00:07:21,360 --> 00:07:25,520
and you have to you know which which

00:07:24,240 --> 00:07:29,039
definition of food

00:07:25,520 --> 00:07:31,360
they see affects how they

00:07:29,039 --> 00:07:33,680
um things that inherit from foo this

00:07:31,360 --> 00:07:35,280
actually has a long history in c plus

00:07:33,680 --> 00:07:38,080
plus it's called

00:07:35,280 --> 00:07:39,840
problem and basically what that means a

00:07:38,080 --> 00:07:41,280
fragile base class is if you have a base

00:07:39,840 --> 00:07:44,000
class if you have a class that other

00:07:41,280 --> 00:07:44,000
things inherit

00:07:49,360 --> 00:07:54,000
you change anything base class like

00:07:52,400 --> 00:07:54,639
adding a member variable is the most

00:07:54,000 --> 00:07:58,160
common

00:07:54,639 --> 00:08:00,879
adding uh you can do other things uh

00:07:58,160 --> 00:08:02,479
you need to recompile all of your

00:08:00,879 --> 00:08:05,199
derived classes

00:08:02,479 --> 00:08:07,120
transitively all your drive classes all

00:08:05,199 --> 00:08:07,599
your drive from derived classes and so

00:08:07,120 --> 00:08:09,440
on

00:08:07,599 --> 00:08:10,720
because otherwise you will you will have

00:08:09,440 --> 00:08:13,759
run afoul of the one

00:08:10,720 --> 00:08:16,879
definition rule and your

00:08:13,759 --> 00:08:19,280
um your program will exhibit undefined

00:08:16,879 --> 00:08:19,280
behavior

00:08:19,520 --> 00:08:24,400
okay so there's there's there's the the

00:08:22,879 --> 00:08:26,879
canonical example you added of

00:08:24,400 --> 00:08:27,680
additive field but there are other ways

00:08:26,879 --> 00:08:31,199
to

00:08:27,680 --> 00:08:32,159
break this okay you have variation on

00:08:31,199 --> 00:08:33,919
the theme

00:08:32,159 --> 00:08:35,680
you can remove a member obviously that

00:08:33,919 --> 00:08:38,159
works the exact same way you know

00:08:35,680 --> 00:08:39,200
two different pieces of code that had

00:08:38,159 --> 00:08:41,839
ideas

00:08:39,200 --> 00:08:43,360
different ideas about the size of a

00:08:41,839 --> 00:08:46,399
class

00:08:43,360 --> 00:08:49,040
um you can reorder members if you what

00:08:46,399 --> 00:08:50,480
switched b and a and a and b now they're

00:08:49,040 --> 00:08:53,839
the same size

00:08:50,480 --> 00:08:56,000
but still different pieces of code that

00:08:53,839 --> 00:08:58,080
sees the different definitions will have

00:08:56,000 --> 00:09:01,839
different ideas on how to deal with it

00:08:58,080 --> 00:09:05,600
when you want to say stop all the a's

00:09:01,839 --> 00:09:07,600
in internet of these

00:09:05,600 --> 00:09:10,160
if you see the second definition where

00:09:07,600 --> 00:09:11,920
the or the members have been reordered

00:09:10,160 --> 00:09:14,160
you might end up with a sum of b's

00:09:11,920 --> 00:09:16,640
instead of a's

00:09:14,160 --> 00:09:18,160
um because c plus pulse does by the time

00:09:16,640 --> 00:09:19,920
it gets the object file it doesn't

00:09:18,160 --> 00:09:21,120
actually know what the field names are

00:09:19,920 --> 00:09:24,399
all it knows is

00:09:21,120 --> 00:09:27,519
it knows that an offset four is a

00:09:24,399 --> 00:09:29,120
there's an n32 which is which is refers

00:09:27,519 --> 00:09:33,120
to

00:09:29,120 --> 00:09:36,160
maybe a depending on what which um

00:09:33,120 --> 00:09:38,560
definition you see um

00:09:36,160 --> 00:09:40,320
another one is called pragma pack every

00:09:38,560 --> 00:09:42,880
compiler has

00:09:40,320 --> 00:09:44,160
something like pragma pack it basically

00:09:42,880 --> 00:09:46,880
affects how

00:09:44,160 --> 00:09:47,600
structures are packed together you know

00:09:46,880 --> 00:09:49,600
how

00:09:47,600 --> 00:09:51,360
how things are aligned in there whether

00:09:49,600 --> 00:09:52,000
or not things are squished together

00:09:51,360 --> 00:09:55,279
reducing

00:09:52,000 --> 00:09:57,440
padding and so on really useful for say

00:09:55,279 --> 00:09:58,880
matching wire formats or things like

00:09:57,440 --> 00:10:01,519
that

00:09:58,880 --> 00:10:03,200
but if you have you know two definitions

00:10:01,519 --> 00:10:05,200
of a structure even if they're the same

00:10:03,200 --> 00:10:08,399
but one of them is inside they say

00:10:05,200 --> 00:10:11,200
pack one and the other one is inside

00:10:08,399 --> 00:10:12,560
not inside it they may have two doubts

00:10:11,200 --> 00:10:16,160
they may have

00:10:12,560 --> 00:10:19,839
you know um and so

00:10:16,160 --> 00:10:19,839
bad things will happen

00:10:20,560 --> 00:10:28,240
okay let's look at a different example

00:10:24,160 --> 00:10:32,480
of how you can change a uh

00:10:28,240 --> 00:10:35,920
a class or a struct and have it um

00:10:32,480 --> 00:10:37,920
have it be different here we have a um

00:10:35,920 --> 00:10:39,279
structure no members this time just two

00:10:37,920 --> 00:10:42,560
virtual functions first

00:10:39,279 --> 00:10:48,399
function one virtual and a destructor

00:10:42,560 --> 00:10:48,399
and in some other header file you have

00:10:48,640 --> 00:10:55,200
a one a two and a destructor

00:10:52,320 --> 00:10:58,480
now that's the only difference the

00:10:55,200 --> 00:11:02,160
difference is somebody added the uh

00:10:58,480 --> 00:11:02,160
the virtual function two

00:11:03,440 --> 00:11:07,680
okay so what happens how is this

00:11:05,760 --> 00:11:09,760
implemented under the hood

00:11:07,680 --> 00:11:10,800
under the hood every variable of type

00:11:09,760 --> 00:11:13,279
food is a v

00:11:10,800 --> 00:11:14,880
table pointer it's a tape a pointer to a

00:11:13,279 --> 00:11:16,000
virtual table which is an array of

00:11:14,880 --> 00:11:18,079
function pointers

00:11:16,000 --> 00:11:20,079
there's one function point one per

00:11:18,079 --> 00:11:22,880
virtual function

00:11:20,079 --> 00:11:24,720
so the first definition if you're

00:11:22,880 --> 00:11:26,000
generating code based on definition you

00:11:24,720 --> 00:11:29,190
believe that function

00:11:26,000 --> 00:11:30,320
table comes two entries and

00:11:29,190 --> 00:11:32,720
[Music]

00:11:30,320 --> 00:11:34,320
if you're doing the second one you

00:11:32,720 --> 00:11:37,360
believe that function table has

00:11:34,320 --> 00:11:39,600
function pointer table ocean pointers

00:11:37,360 --> 00:11:42,720
excuse me

00:11:39,600 --> 00:11:44,959
three entries needless to say this could

00:11:42,720 --> 00:11:48,240
cause confusion

00:11:44,959 --> 00:11:52,240
um there's a question for you

00:11:48,240 --> 00:11:55,519
how are entries ordered in the

00:11:52,240 --> 00:11:58,320
virtual table in the v table

00:11:55,519 --> 00:12:00,959
the answer is that's defined by the

00:11:58,320 --> 00:12:00,959
compiler

00:12:01,040 --> 00:12:05,440
there there is no agreed on order they

00:12:03,760 --> 00:12:06,639
could be the order in which they're

00:12:05,440 --> 00:12:10,320
declared in this

00:12:06,639 --> 00:12:14,320
in the struct they could be alphabetized

00:12:10,320 --> 00:12:16,399
it could be you know too long

00:12:14,320 --> 00:12:18,399
so it doesn't really matter is that they

00:12:16,399 --> 00:12:20,720
are in fact consistent

00:12:18,399 --> 00:12:21,519
that different runs of the compiler put

00:12:20,720 --> 00:12:24,639
things in the v

00:12:21,519 --> 00:12:27,680
table at um at

00:12:24,639 --> 00:12:31,680
in the same order um

00:12:27,680 --> 00:12:31,680
what happens if you to call

00:12:32,639 --> 00:12:39,519
the destructors say in the uh

00:12:37,360 --> 00:12:41,760
from code that believes you had one

00:12:39,519 --> 00:12:44,800
definition when in fact you had another

00:12:41,760 --> 00:12:46,880
it's going to get the virtual table

00:12:44,800 --> 00:12:50,240
pointer out of the object that's fine

00:12:46,880 --> 00:12:51,680
it's going to go pick an entry out of

00:12:50,240 --> 00:12:54,880
the um

00:12:51,680 --> 00:12:56,480
output which one i don't know

00:12:54,880 --> 00:12:58,480
and it's going to it's going to call

00:12:56,480 --> 00:13:01,360
that

00:12:58,480 --> 00:13:03,519
now if it thinks it's going to the third

00:13:01,360 --> 00:13:05,120
entry in the v table and there's only

00:13:03,519 --> 00:13:07,120
two it's going to pick up a random

00:13:05,120 --> 00:13:11,760
address and try to call that

00:13:07,120 --> 00:13:11,760
okay if it thinks that there are

00:13:12,079 --> 00:13:15,839
uh if it thinks that the the destruction

00:13:14,800 --> 00:13:18,240
is at offset

00:13:15,839 --> 00:13:20,160
one and instead it's at offset two it's

00:13:18,240 --> 00:13:22,160
going to call the wrong member function

00:13:20,160 --> 00:13:24,320
anyway bad things are going to happen

00:13:22,160 --> 00:13:24,320
here

00:13:24,720 --> 00:13:29,440
um during the run up to c plus plus 20

00:13:27,760 --> 00:13:31,839
one of the proposals that was not

00:13:29,440 --> 00:13:35,200
adopted for c plus 20

00:13:31,839 --> 00:13:37,440
was to add another

00:13:35,200 --> 00:13:38,399
floating point type this would be called

00:13:37,440 --> 00:13:40,480
half float or

00:13:38,399 --> 00:13:42,880
short float i don't remember which but

00:13:40,480 --> 00:13:45,360
it's a 16 bit floating point type

00:13:42,880 --> 00:13:46,399
um people like to do 16 bit floating

00:13:45,360 --> 00:13:50,480
point arithmetic

00:13:46,399 --> 00:13:53,440
these days and and a lot of processors

00:13:50,480 --> 00:13:54,800
have you know have sse instructions that

00:13:53,440 --> 00:13:58,959
work on

00:13:54,800 --> 00:14:02,160
eight sixteen put bit fluids all at once

00:13:58,959 --> 00:14:04,320
uh anyway the problem one of the

00:14:02,160 --> 00:14:09,680
problems with this proposal was that

00:14:04,320 --> 00:14:11,839
adding support in io streams for this

00:14:09,680 --> 00:14:13,680
these new this new type excuse me not

00:14:11,839 --> 00:14:16,880
these these this new type

00:14:13,680 --> 00:14:18,560
would involve adding a new virtual

00:14:16,880 --> 00:14:20,560
function to a couple of classes in

00:14:18,560 --> 00:14:23,279
iostream specifically to

00:14:20,560 --> 00:14:23,920
num put and numget which is the the

00:14:23,279 --> 00:14:27,279
classes

00:14:23,920 --> 00:14:31,839
inside of those streams that

00:14:27,279 --> 00:14:31,839
have numeric input and output

00:14:31,920 --> 00:14:34,959
this would be a bet this would

00:14:33,440 --> 00:14:38,240
definitely be a uh

00:14:34,959 --> 00:14:41,600
a change in in the uh the virtual

00:14:38,240 --> 00:14:43,680
function b table layout

00:14:41,600 --> 00:14:45,279
this could lead to bad things just like

00:14:43,680 --> 00:14:48,320
i showed above

00:14:45,279 --> 00:14:52,000
anyway um okay this

00:14:48,320 --> 00:14:52,000
this next one is much more subtle

00:14:54,800 --> 00:15:01,120
um so i saw a a question from

00:14:58,079 --> 00:15:02,560
zach who said does this imply that

00:15:01,120 --> 00:15:03,440
separate runs of the compiler may

00:15:02,560 --> 00:15:07,199
generate different

00:15:03,440 --> 00:15:08,880
v table orders uh no no

00:15:07,199 --> 00:15:10,240
that that's kind of a requirement for

00:15:08,880 --> 00:15:13,440
the compiler if

00:15:10,240 --> 00:15:16,639
separate compilation that it generate

00:15:13,440 --> 00:15:20,000
consistent v table order um

00:15:16,639 --> 00:15:21,920
otherwise yeah you can't you couldn't

00:15:20,000 --> 00:15:23,519
do separate compilation and link things

00:15:21,920 --> 00:15:25,519
together um

00:15:23,519 --> 00:15:27,360
the point my point is it has to be

00:15:25,519 --> 00:15:30,480
consistent

00:15:27,360 --> 00:15:32,800
but it doesn't actually um

00:15:30,480 --> 00:15:33,759
have to be documented or actually

00:15:32,800 --> 00:15:35,519
rephrase that

00:15:33,759 --> 00:15:36,800
it doesn't have to be consistent of

00:15:35,519 --> 00:15:38,839
compilers

00:15:36,800 --> 00:15:40,320
it has to be consistent within a

00:15:38,839 --> 00:15:42,880
compiler

00:15:40,320 --> 00:15:44,320
um as it turns out that clang for

00:15:42,880 --> 00:15:46,000
example when

00:15:44,320 --> 00:15:48,079
when clang was being developed one of

00:15:46,000 --> 00:15:52,639
their design criteria

00:15:48,079 --> 00:15:52,639
one of their goals was to generate

00:15:52,839 --> 00:15:58,079
um object files which were compatible

00:15:56,320 --> 00:16:00,639
with gcc

00:15:58,079 --> 00:16:02,399
and so they went and looked and see how

00:16:00,639 --> 00:16:05,120
how did gcc order

00:16:02,399 --> 00:16:06,079
um virtual functions in the v table and

00:16:05,120 --> 00:16:08,079
match that

00:16:06,079 --> 00:16:09,680
i honestly don't know what the order is

00:16:08,079 --> 00:16:11,839
i suspect it's the

00:16:09,680 --> 00:16:14,000
order in which they're declared in the

00:16:11,839 --> 00:16:18,079
class i don't know that

00:16:14,000 --> 00:16:18,880
um so now all that you require from the

00:16:18,079 --> 00:16:21,199
compiler

00:16:18,880 --> 00:16:22,959
for those things that they be consistent

00:16:21,199 --> 00:16:24,320
across runs of the compiler

00:16:22,959 --> 00:16:26,320
because otherwise yeah separate

00:16:24,320 --> 00:16:29,519
compilation would not work and we know

00:16:26,320 --> 00:16:29,519
separate compilation works

00:16:30,079 --> 00:16:34,639
um okay anyway this one's a little more

00:16:32,560 --> 00:16:36,880
subtle so imagine you have a struct

00:16:34,639 --> 00:16:38,639
name pair i don't know why you would

00:16:36,880 --> 00:16:41,360
have a struct name pair but

00:16:38,639 --> 00:16:43,199
we have a starting name pair okay it has

00:16:41,360 --> 00:16:45,279
it's a struct it has two functions

00:16:43,199 --> 00:16:46,320
and it has a copy constructor it takes a

00:16:45,279 --> 00:16:49,519
pair

00:16:46,320 --> 00:16:50,720
and the copy construct constructs the

00:16:49,519 --> 00:16:54,240
first member copy

00:16:50,720 --> 00:16:54,240
the second member that's all it does

00:16:55,199 --> 00:17:04,079
and you say wait wait but we have

00:16:59,120 --> 00:17:07,199
tools now just make that cool default

00:17:04,079 --> 00:17:12,400
yes yes we can

00:17:07,199 --> 00:17:12,400
okay um and that's not a bad thing

00:17:13,439 --> 00:17:17,520
except it's a behavior change and let me

00:17:15,600 --> 00:17:20,959
explain

00:17:17,520 --> 00:17:23,919
okay um see the only difference is

00:17:20,959 --> 00:17:25,439
right so what have we done we've let the

00:17:23,919 --> 00:17:27,039
compiler

00:17:25,439 --> 00:17:28,880
generate the copy constructor per pair

00:17:27,039 --> 00:17:30,960
by saying equal default since this is

00:17:28,880 --> 00:17:32,640
struck the default copy constructor does

00:17:30,960 --> 00:17:34,799
member-wise construction

00:17:32,640 --> 00:17:37,200
exactly what we were doing before should

00:17:34,799 --> 00:17:40,880
even generate the same code

00:17:37,200 --> 00:17:42,320
same code okay but there's a behavior

00:17:40,880 --> 00:17:45,200
change here

00:17:42,320 --> 00:17:46,799
and the behavior change is is that with

00:17:45,200 --> 00:17:48,640
this change

00:17:46,799 --> 00:17:50,720
specialization where some

00:17:48,640 --> 00:17:53,520
specializations of pair

00:17:50,720 --> 00:17:55,120
can be trivially copyable trivially copy

00:17:53,520 --> 00:17:58,160
constructable trivially

00:17:55,120 --> 00:18:01,360
copy assignable well constructable

00:17:58,160 --> 00:18:03,200
because we change the constructor um

00:18:01,360 --> 00:18:05,679
where before they could never be and the

00:18:03,200 --> 00:18:09,039
reason they could never be is because

00:18:05,679 --> 00:18:11,039
pair had a user-defined copy constructor

00:18:09,039 --> 00:18:12,320
and if you say equal default it now does

00:18:11,039 --> 00:18:14,880
not have a user-defined

00:18:12,320 --> 00:18:15,840
copy constructor and that's one of the

00:18:14,880 --> 00:18:17,520
the

00:18:15,840 --> 00:18:19,760
requirements for being trivially

00:18:17,520 --> 00:18:23,039
copyable is that

00:18:19,760 --> 00:18:26,320
it has it does not have a user defined

00:18:23,039 --> 00:18:29,840
copy constructor okay

00:18:26,320 --> 00:18:29,840
what does this mean

00:18:30,480 --> 00:18:34,480
okay what does this mean this mean but

00:18:33,039 --> 00:18:36,160
why does this matter

00:18:34,480 --> 00:18:38,799
actually it's a better state on some

00:18:36,160 --> 00:18:40,080
platforms parameters of trivially

00:18:38,799 --> 00:18:43,200
copyable types

00:18:40,080 --> 00:18:44,720
which can fit into a register are passed

00:18:43,200 --> 00:18:47,679
as function parameters in a register

00:18:44,720 --> 00:18:47,679
rather than on the stack

00:18:49,280 --> 00:18:56,480
so say pair

00:18:52,640 --> 00:19:00,000
stud pair of short comma int

00:18:56,480 --> 00:19:01,760
or short pumic care say

00:19:00,000 --> 00:19:03,360
that will almost certainly fit into a

00:19:01,760 --> 00:19:06,559
register

00:19:03,360 --> 00:19:09,840
and um if you think of

00:19:06,559 --> 00:19:12,880
this pair as being std pair

00:19:09,840 --> 00:19:16,559
then and this change was made

00:19:12,880 --> 00:19:19,200
then std pair short comma care

00:19:16,559 --> 00:19:20,559
can would now be passed as a register in

00:19:19,200 --> 00:19:23,919
a register rather than

00:19:20,559 --> 00:19:24,400
on the stack not all specializations of

00:19:23,919 --> 00:19:27,039
pair

00:19:24,400 --> 00:19:27,919
would be trivially copyable it depends

00:19:27,039 --> 00:19:31,679
on what type

00:19:27,919 --> 00:19:34,799
t t1 and t2 are if they are in fact

00:19:31,679 --> 00:19:37,039
trivially constructable trivially copy

00:19:34,799 --> 00:19:40,240
constructable

00:19:37,039 --> 00:19:42,960
but some are okay this

00:19:40,240 --> 00:19:44,480
this change was actually proposed for c

00:19:42,960 --> 00:19:47,440
plus

00:19:44,480 --> 00:19:48,960
14 i think might have been 17 but 14 or

00:19:47,440 --> 00:19:51,520
00:19:48,960 --> 00:19:52,000
and it was not adopted specifically

00:19:51,520 --> 00:19:54,880
because

00:19:52,000 --> 00:19:56,080
of this problem this this change in

00:19:54,880 --> 00:19:58,640
behavior

00:19:56,080 --> 00:20:00,799
it's the interesting thing is the change

00:19:58,640 --> 00:20:03,440
with the change the

00:20:00,799 --> 00:20:04,480
the code generated for pairs copy

00:20:03,440 --> 00:20:07,520
constructor

00:20:04,480 --> 00:20:09,840
would be exactly the same

00:20:07,520 --> 00:20:11,600
but you've changed with this change

00:20:09,840 --> 00:20:15,440
you've changed how

00:20:11,600 --> 00:20:21,840
some specializations of pair

00:20:15,440 --> 00:20:21,840
would be passed as parameters

00:20:22,320 --> 00:20:28,640
okay that one's a pretty subtle one

00:20:26,400 --> 00:20:29,520
all right let's talk about this how do i

00:20:28,640 --> 00:20:33,840
get from an

00:20:29,520 --> 00:20:35,679
odr violation to an abi break

00:20:33,840 --> 00:20:37,200
because this was this is a talk about

00:20:35,679 --> 00:20:39,919
abi breaks and we've just

00:20:37,200 --> 00:20:40,720
i've been talking about odr mentions

00:20:39,919 --> 00:20:42,240
okay

00:20:40,720 --> 00:20:43,840
um the easiest way to do that is to

00:20:42,240 --> 00:20:45,600
think about

00:20:43,840 --> 00:20:47,120
two versions instead of two header files

00:20:45,600 --> 00:20:48,799
with different definitions to

00:20:47,120 --> 00:20:51,200
two different versions of the same

00:20:48,799 --> 00:20:53,360
header file and a shared library that

00:20:51,200 --> 00:20:55,280
goes with

00:20:53,360 --> 00:20:56,720
so you install a new version of library

00:20:55,280 --> 00:20:58,480
that you use it comes with an updated

00:20:56,720 --> 00:21:01,760
header file

00:20:58,480 --> 00:21:06,080
and there's a different declaration

00:21:01,760 --> 00:21:07,919
for a struct that you use in your code

00:21:06,080 --> 00:21:09,919
and your code does not get rebuilt to

00:21:07,919 --> 00:21:13,600
incorporate that change

00:21:09,919 --> 00:21:13,600
maybe you don't have the source for that

00:21:14,840 --> 00:21:23,600
um maybe you decide that you're going up

00:21:18,559 --> 00:21:27,200
the uh because because you're using icu

00:21:23,600 --> 00:21:28,559
international components for unicode and

00:21:27,200 --> 00:21:30,559
you see there's a new release it has

00:21:28,559 --> 00:21:33,200
some features you like so you install

00:21:30,559 --> 00:21:35,760
a uh you update the version of icu on

00:21:33,200 --> 00:21:35,760
your system

00:21:36,000 --> 00:21:39,600
but you have this other app that uses

00:21:38,799 --> 00:21:41,840
icu

00:21:39,600 --> 00:21:43,600
and uses the c suppose bindings in icu

00:21:41,840 --> 00:21:44,400
and maybe that app is called oh i don't

00:21:43,600 --> 00:21:47,280
know

00:21:44,400 --> 00:21:47,280
microsoft word

00:21:49,440 --> 00:21:52,640
well you should recompile that right

00:21:51,919 --> 00:21:54,400
because the

00:21:52,640 --> 00:21:58,240
because it might pick up there might be

00:21:54,400 --> 00:21:58,720
changes in the header files for icu well

00:21:58,240 --> 00:22:00,000
you don't

00:21:58,720 --> 00:22:02,240
obviously you don't have the source for

00:22:00,000 --> 00:22:03,840
microsoft word or maybe you do

00:22:02,240 --> 00:22:06,240
i know john used to work at microsoft

00:22:03,840 --> 00:22:09,760
maybe he has the source for word

00:22:06,240 --> 00:22:13,200
um anyway but the point is is

00:22:09,760 --> 00:22:13,840
uh dating icu because you want new

00:22:13,200 --> 00:22:15,919
features

00:22:13,840 --> 00:22:17,520
if things have changed in the

00:22:15,919 --> 00:22:22,000
definitions of the

00:22:17,520 --> 00:22:22,000
the types that icu provides

00:22:22,720 --> 00:22:27,200
then this this is an aedi break that's

00:22:25,679 --> 00:22:30,559
what abi break is you

00:22:27,200 --> 00:22:33,600
get a new version of something and

00:22:30,559 --> 00:22:36,720
the application binary interface

00:22:33,600 --> 00:22:39,200
of that something has changed

00:22:36,720 --> 00:22:42,320
if it's changing you need to build all

00:22:39,200 --> 00:22:42,320
the things that use it

00:22:44,159 --> 00:22:47,919
another way to get a new thing is to you

00:22:46,000 --> 00:22:49,360
install system update your os vendor

00:22:47,919 --> 00:22:51,200
provides you a system update and it

00:22:49,360 --> 00:22:54,320
installs an updated shared library

00:22:51,200 --> 00:22:57,520
of something well i don't know mysql

00:22:54,320 --> 00:23:01,520
or tddc

00:22:57,520 --> 00:23:03,840
plus plus or even lib c plus plus um

00:23:01,520 --> 00:23:05,200
and something's changed you know imagine

00:23:03,840 --> 00:23:09,120
it's all a separate

00:23:05,200 --> 00:23:12,559
i i knew a new version of your standard

00:23:09,120 --> 00:23:16,880
library and it has this change in it

00:23:12,559 --> 00:23:18,720
and some door existing binary crash

00:23:16,880 --> 00:23:21,600
every now and then where they didn't

00:23:18,720 --> 00:23:25,919
before and this was the only change

00:23:21,600 --> 00:23:28,720
because now under certain circumstances

00:23:25,919 --> 00:23:29,280
these pairs are expecting to be are

00:23:28,720 --> 00:23:33,840
being

00:23:29,280 --> 00:23:35,679
passed but your code that you haven't

00:23:33,840 --> 00:23:37,360
recompiled expects to see them on the

00:23:35,679 --> 00:23:40,559
stack

00:23:37,360 --> 00:23:40,559
this is an api break

00:23:41,200 --> 00:23:48,840
okay this is and

00:23:44,320 --> 00:23:52,080
ugly and nasty and really really hard to

00:23:48,840 --> 00:23:56,080
detect um

00:23:52,080 --> 00:23:56,640
well now adding a field picture okay

00:23:56,080 --> 00:23:58,559
yeah

00:23:56,640 --> 00:24:01,760
you you can kind of think to yourself

00:23:58,559 --> 00:24:04,000
right the size has changed this is a

00:24:01,760 --> 00:24:05,279
you know code that expect to be eight

00:24:04,000 --> 00:24:08,000
and now it's 12

00:24:05,279 --> 00:24:10,960
this is a pro adding a virtual function

00:24:08,000 --> 00:24:10,960
is a little more subtle

00:24:11,919 --> 00:24:17,360
um but you know once you've seen that

00:24:14,880 --> 00:24:19,840
once you you can be on the lookout

00:24:17,360 --> 00:24:21,279
this one this one was is quite subtle

00:24:19,840 --> 00:24:24,240
and it requires you know

00:24:21,279 --> 00:24:25,679
knowledge about the um the calling

00:24:24,240 --> 00:24:26,720
convention for the platform you're

00:24:25,679 --> 00:24:28,880
working on

00:24:26,720 --> 00:24:30,000
and lucas has popped something into the

00:24:28,880 --> 00:24:32,559
chat about

00:24:30,000 --> 00:24:34,159
the titanium c plus plus avi dock which

00:24:32,559 --> 00:24:36,960
is a great message

00:24:34,159 --> 00:24:37,600
but it also talking about how the order

00:24:36,960 --> 00:24:39,120
of

00:24:37,600 --> 00:24:40,799
virtual function pointers in the virtual

00:24:39,120 --> 00:24:44,000
table is the order of dictions

00:24:40,799 --> 00:24:45,600
in the class fine uh

00:24:44,000 --> 00:24:47,679
that's a perfectly reasonable way to

00:24:45,600 --> 00:24:50,000
order them i'm sure that they

00:24:47,679 --> 00:24:53,039
the gcc people are really really happy

00:24:50,000 --> 00:24:53,039
to know that i think they're

00:24:53,279 --> 00:25:01,600
i think they don't care but yeah

00:24:56,640 --> 00:25:03,279
um so

00:25:01,600 --> 00:25:05,760
this is uh this is one of those things

00:25:03,279 --> 00:25:09,200
that you know that pair change

00:25:05,760 --> 00:25:10,000
would have been really bad if we had

00:25:09,200 --> 00:25:12,840
been

00:25:10,000 --> 00:25:14,480
adopted that and and people had shipped

00:25:12,840 --> 00:25:16,880
it

00:25:14,480 --> 00:25:17,679
it's a very strange and the idea is yeah

00:25:16,880 --> 00:25:20,960
yeah this is

00:25:17,679 --> 00:25:21,520
this is you know this is a better way to

00:25:20,960 --> 00:25:24,880
specify

00:25:21,520 --> 00:25:26,000
it just says you know as pairwise

00:25:24,880 --> 00:25:28,000
construction you know as

00:25:26,000 --> 00:25:29,919
member wise construction which is what

00:25:28,000 --> 00:25:33,039
this does

00:25:29,919 --> 00:25:33,039
but there's a side affair

00:25:33,360 --> 00:25:37,600
or there's a there's a there's an

00:25:36,080 --> 00:25:38,799
additional bit there is a better way to

00:25:37,600 --> 00:25:41,120
say

00:25:38,799 --> 00:25:42,559
okay so the question is how can you

00:25:41,120 --> 00:25:46,720
avoid doing this

00:25:42,559 --> 00:25:46,720
because it right

00:25:46,799 --> 00:25:50,320
um the answer is don't change things

00:25:49,520 --> 00:25:53,520
that

00:25:50,320 --> 00:25:56,000
affect abi when i was uh

00:25:53,520 --> 00:25:57,600
much younger is this there's this raft

00:25:56,000 --> 00:25:59,520
of jokes that were generally called

00:25:57,600 --> 00:26:02,240
doctor doctor jokes

00:25:59,520 --> 00:26:04,400
uh and the basically canonical joke was

00:26:02,240 --> 00:26:07,919
doctor doctor it hurts when i do this

00:26:04,400 --> 00:26:07,919
doctor says well don't do it

00:26:08,400 --> 00:26:12,480
um yeah doctor hurts when i hit my

00:26:10,799 --> 00:26:13,679
hammer well don't hit your hand with a

00:26:12,480 --> 00:26:16,960
hammer

00:26:13,679 --> 00:26:18,799
um dr dr mice my programs crash when i

00:26:16,960 --> 00:26:21,840
change the ibi on my shared library and

00:26:18,799 --> 00:26:24,480
don't recompile well don't do that

00:26:21,840 --> 00:26:25,520
um don't have stale binaries don't have

00:26:24,480 --> 00:26:30,640
binary that are

00:26:25,520 --> 00:26:33,760
older than the things they use

00:26:30,640 --> 00:26:34,320
um have only one definition for

00:26:33,760 --> 00:26:37,520
everything

00:26:34,320 --> 00:26:40,400
but um but that is that

00:26:37,520 --> 00:26:41,760
there are lots of things that you don't

00:26:40,400 --> 00:26:43,679
have source for

00:26:41,760 --> 00:26:45,360
i mean there are people out there there

00:26:43,679 --> 00:26:47,840
are organisms out there that don't

00:26:45,360 --> 00:26:49,200
have any stale buyers because every

00:26:47,840 --> 00:26:53,679
single time they build

00:26:49,200 --> 00:26:55,919
our system they rebuild everything from

00:26:53,679 --> 00:26:57,520
um they rebuild all their shared

00:26:55,919 --> 00:26:58,159
libraries including standard library

00:26:57,520 --> 00:27:00,799
they use

00:26:58,159 --> 00:27:02,559
they you know they rebuild everything

00:27:00,799 --> 00:27:05,919
every single time

00:27:02,559 --> 00:27:08,080
and if you can do that you won't have

00:27:05,919 --> 00:27:12,159
any abi breaks because

00:27:08,080 --> 00:27:12,159
every single has its own abi

00:27:12,720 --> 00:27:18,159
but this only works if a you have source

00:27:15,360 --> 00:27:22,799
for every single thing you use

00:27:18,159 --> 00:27:23,360
and b are willing to spend a lot of use

00:27:22,799 --> 00:27:27,360
cycles

00:27:23,360 --> 00:27:27,360
rebuilding everything all the time

00:27:28,640 --> 00:27:31,440
people can do that

00:27:32,159 --> 00:27:36,960
all right um like i said

00:27:35,200 --> 00:27:39,600
avoid stale binary stale binaries

00:27:36,960 --> 00:27:42,720
include commercial

00:27:39,600 --> 00:27:45,440
um and have one definition

00:27:42,720 --> 00:27:48,640
includes all the libraries you use

00:27:45,440 --> 00:27:52,880
transitively if you use

00:27:48,640 --> 00:27:55,279
you know mysql to use

00:27:52,880 --> 00:27:58,640
some networking library which uses the

00:27:55,279 --> 00:28:00,399
standard library well those are all

00:27:58,640 --> 00:28:02,080
libraries that you have to worry about

00:28:00,399 --> 00:28:04,559
you know if i update

00:28:02,080 --> 00:28:06,399
that networking library does that going

00:28:04,559 --> 00:28:09,279
to cause

00:28:06,399 --> 00:28:12,159
my my library to break which is going to

00:28:09,279 --> 00:28:14,960
cause my programs

00:28:12,159 --> 00:28:16,240
you have to be aware of this um really

00:28:14,960 --> 00:28:18,960
the easiest thing is to

00:28:16,240 --> 00:28:20,159
change things that affect adi that's

00:28:18,960 --> 00:28:24,240
that's hard

00:28:20,159 --> 00:28:27,840
it's easy to inadvertently change jbm

00:28:24,240 --> 00:28:30,799
okay doing examples

00:28:27,840 --> 00:28:32,480
of an avi break in the wild oh yes very

00:28:30,799 --> 00:28:36,960
much so

00:28:32,480 --> 00:28:39,600
we have the canonical one for c plus 11

00:28:36,960 --> 00:28:40,559
the the c substance committee tightened

00:28:39,600 --> 00:28:43,919
up the res

00:28:40,559 --> 00:28:45,039
these definitions of what std string

00:28:43,919 --> 00:28:46,880
basic string

00:28:45,039 --> 00:28:48,559
could do and could not do and it

00:28:46,880 --> 00:28:53,200
effectively outlawed

00:28:48,559 --> 00:28:55,440
copy on write string copy strings um

00:28:53,200 --> 00:28:57,600
well they don't play well multi-threaded

00:28:55,440 --> 00:29:02,320
environment shall we say

00:28:57,600 --> 00:29:04,640
um that std c pulse plus had to

00:29:02,320 --> 00:29:05,600
change their supplementation they

00:29:04,640 --> 00:29:08,240
changed

00:29:05,600 --> 00:29:10,159
the layout of the the basic string

00:29:08,240 --> 00:29:13,919
struct they had to

00:29:10,159 --> 00:29:17,600
change implement the um implementation

00:29:13,919 --> 00:29:17,600
they had and basically

00:29:17,679 --> 00:29:22,559
you know it this string had an api now

00:29:23,440 --> 00:29:26,880
i see somebody in the chat yeah i'm

00:29:25,200 --> 00:29:31,360
still using the old abi

00:29:26,880 --> 00:29:33,520
yes um provided a backdoor

00:29:31,360 --> 00:29:34,880
a thing you could define at compile time

00:29:33,520 --> 00:29:35,200
and at run time so that people could

00:29:34,880 --> 00:29:36,559
keep

00:29:35,200 --> 00:29:39,120
the layout and behavior for

00:29:36,559 --> 00:29:43,039
compatibility with old software

00:29:39,120 --> 00:29:46,320
um many many people

00:29:43,039 --> 00:29:48,480
hi daniel have just refused to change

00:29:46,320 --> 00:29:49,840
and organizations just say no you know

00:29:48,480 --> 00:29:50,480
we're gonna stick with the old stuff

00:29:49,840 --> 00:29:55,200
because

00:29:50,480 --> 00:29:57,120
you know we have all these old binary

00:29:55,200 --> 00:29:58,320
um i know of at least one large

00:29:57,120 --> 00:30:01,600
organization

00:29:58,320 --> 00:30:04,159
who stopped defining that thing g loop c

00:30:01,600 --> 00:30:06,080
plus u c plus plus 11 a bi equals zero

00:30:04,159 --> 00:30:09,840
stop defining that

00:30:06,080 --> 00:30:09,840
just this last year

00:30:09,919 --> 00:30:14,000
okay so ten years after the new after c

00:30:13,279 --> 00:30:17,279
plus plus eleven

00:30:14,000 --> 00:30:20,080
nine years after six eleven came out

00:30:17,279 --> 00:30:20,799
they uh that organization decided to

00:30:20,080 --> 00:30:24,000
move to

00:30:20,799 --> 00:30:25,120
c plus plus 11 style strings

00:30:24,000 --> 00:30:27,679
there are a bunch of people who i think

00:30:25,120 --> 00:30:31,200
will never change and unless

00:30:27,679 --> 00:30:34,240
um you know libbed stdc plus plus

00:30:31,200 --> 00:30:36,399
boosts old format which i can't see them

00:30:34,240 --> 00:30:40,080
doing because it doesn't actually ever

00:30:36,399 --> 00:30:43,440
it's it's not really ever changing

00:30:40,080 --> 00:30:47,760
um every now and then you um

00:30:43,440 --> 00:30:50,000
you see it on stackover somebody says

00:30:47,760 --> 00:30:52,399
i just installed the most recent one was

00:30:50,000 --> 00:30:55,760
i have a centos system

00:30:52,399 --> 00:30:59,120
and i just sold gcc 9

00:30:55,760 --> 00:31:00,799
and i built some programs and

00:30:59,120 --> 00:31:02,559
every now and then crash and i don't

00:31:00,799 --> 00:31:04,080
think i'm doing anything wrong here and

00:31:02,559 --> 00:31:05,919
here's the source and up and up and up

00:31:04,080 --> 00:31:07,840
and up and up and it

00:31:05,919 --> 00:31:10,159
and it yeah this is what it is is that

00:31:07,840 --> 00:31:10,960
the the centos they have was built with

00:31:10,159 --> 00:31:14,399
gcc

00:31:10,960 --> 00:31:18,080
four two or four three

00:31:14,399 --> 00:31:18,559
which uh uses the old string layout and

00:31:18,080 --> 00:31:21,840
their

00:31:18,559 --> 00:31:24,799
new shiny gcc 9 use

00:31:21,840 --> 00:31:26,480
the new string layout get an abi

00:31:24,799 --> 00:31:28,960
mismatch across

00:31:26,480 --> 00:31:31,200
between the code that they just compiled

00:31:28,960 --> 00:31:35,039
and the shared library they're using and

00:31:31,200 --> 00:31:35,919
bad things happen um the last time i saw

00:31:35,039 --> 00:31:39,519
this

00:31:35,919 --> 00:31:42,559
on stack overflow was

00:31:39,519 --> 00:31:44,880
may 20 so

00:31:42,559 --> 00:31:46,720
nine months ago this is a decade after

00:31:44,880 --> 00:31:50,080
this thing happened

00:31:46,720 --> 00:31:52,720
um this is still

00:31:50,080 --> 00:31:53,840
causing pain okay for people this is

00:31:52,720 --> 00:31:56,480
years after

00:31:53,840 --> 00:31:59,039
and it's still causing pain and people

00:31:56,480 --> 00:31:59,039
adopting

00:31:59,200 --> 00:32:04,320
um yes yeah most people

00:32:02,240 --> 00:32:06,320
have have moved on by now they've

00:32:04,320 --> 00:32:07,279
recompiled all their bodies so that they

00:32:06,320 --> 00:32:09,360
can use

00:32:07,279 --> 00:32:11,600
they see plus 11 style strings but

00:32:09,360 --> 00:32:14,000
there's a significant pers

00:32:11,600 --> 00:32:16,320
um portion of the world out there that

00:32:14,000 --> 00:32:18,480
just hasn't moved on from c plus plus

00:32:16,320 --> 00:32:22,000
03.

00:32:18,480 --> 00:32:25,679
um a museum libsy plus plus

00:32:22,000 --> 00:32:29,519
also has two different string apis

00:32:25,679 --> 00:32:31,440
um after after we ship lipstick post

00:32:29,519 --> 00:32:32,159
plus the initial versions of libsy plus

00:32:31,440 --> 00:32:33,840
plus

00:32:32,159 --> 00:32:36,080
um some people at google did some

00:32:33,840 --> 00:32:39,840
profiling and discovered that if you

00:32:36,080 --> 00:32:43,279
change the layout uh but not the size of

00:32:39,840 --> 00:32:44,880
basic string um you get much better cash

00:32:43,279 --> 00:32:46,480
performance you get much better cash

00:32:44,880 --> 00:32:49,360
alignment and this

00:32:46,480 --> 00:32:50,640
actually was a surprisingly large

00:32:49,360 --> 00:32:55,039
performance win

00:32:50,640 --> 00:32:55,519
in real world a real world code like you

00:32:55,039 --> 00:32:58,480
know

00:32:55,519 --> 00:32:59,679
browser rendering and things like that

00:32:58,480 --> 00:33:04,320
and so

00:32:59,679 --> 00:33:04,320
we have two different string apis now

00:33:04,399 --> 00:33:08,480
we don't really offer them we offer them

00:33:06,799 --> 00:33:10,320
to platform vendors

00:33:08,480 --> 00:33:11,679
and platform vendors decide which one to

00:33:10,320 --> 00:33:14,000
use um

00:33:11,679 --> 00:33:16,880
when apple like four years you know it's

00:33:14,000 --> 00:33:19,519
five years ago when apple introduced

00:33:16,880 --> 00:33:19,519
64.

00:33:20,000 --> 00:33:29,279
they chose to use the new new

00:33:23,600 --> 00:33:29,279
string abi on arm 64.

00:33:30,399 --> 00:33:33,440
and they did that from the very

00:33:31,519 --> 00:33:34,559
beginning of using that platform so

00:33:33,440 --> 00:33:36,399
there was no

00:33:34,559 --> 00:33:37,679
a break there there's no avi

00:33:36,399 --> 00:33:41,279
compatibility because there was

00:33:37,679 --> 00:33:43,679
no code before that

00:33:41,279 --> 00:33:44,480
so this was not a api break it was

00:33:43,679 --> 00:33:46,320
merely

00:33:44,480 --> 00:33:47,919
on this platform the string looks like

00:33:46,320 --> 00:33:51,120
this but on

00:33:47,919 --> 00:33:51,120
x86 or

00:33:51,279 --> 00:33:58,960
arm 32 whatever non 64-bit arm

00:33:55,600 --> 00:34:00,880
we still have the old um standard string

00:33:58,960 --> 00:34:02,640
layout

00:34:00,880 --> 00:34:04,960
so there was not a compatibility problem

00:34:02,640 --> 00:34:04,960
there

00:34:05,440 --> 00:34:11,599
this has been this was a big deal

00:34:08,560 --> 00:34:12,639
this was this was a lot of pain for a

00:34:11,599 --> 00:34:17,040
lot of people

00:34:12,639 --> 00:34:18,879
and has not actually you know

00:34:17,040 --> 00:34:20,079
should be a cautionary tale to people

00:34:18,879 --> 00:34:24,480
who want to change

00:34:20,079 --> 00:34:29,520
abi's anyway

00:34:24,480 --> 00:34:30,800
so why is it why is g21 talking about

00:34:29,520 --> 00:34:33,520
this

00:34:30,800 --> 00:34:34,320
well theoretically you know wg21 doesn't

00:34:33,520 --> 00:34:37,200
really have any

00:34:34,320 --> 00:34:39,040
reason to poke at this uh there's no i

00:34:37,200 --> 00:34:41,359
there's no real concept of

00:34:39,040 --> 00:34:43,200
in the standards world of compatibility

00:34:41,359 --> 00:34:46,879
between standards there's only

00:34:43,200 --> 00:34:47,359
one standard at any given time and once

00:34:46,879 --> 00:34:49,040
the

00:34:47,359 --> 00:34:51,599
once you have a new standard the old

00:34:49,040 --> 00:34:55,119
standard's gone effectively

00:34:51,599 --> 00:34:57,599
um from from the iso's point of view

00:34:55,119 --> 00:34:59,119
the only mention of older standards is

00:34:57,599 --> 00:35:02,000
the standard is in nxc

00:34:59,119 --> 00:35:03,119
and that's merely informative in

00:35:02,000 --> 00:35:05,359
committee speak

00:35:03,119 --> 00:35:07,920
informative this is for your information

00:35:05,359 --> 00:35:10,480
this is not a requirement

00:35:07,920 --> 00:35:12,480
um traditionally it's been implementers

00:35:10,480 --> 00:35:14,000
who prevented abi breaks mostly by

00:35:12,480 --> 00:35:16,560
speaking up in committee

00:35:14,000 --> 00:35:18,720
when a change could cause an abi break

00:35:16,560 --> 00:35:20,960
or reporting beef effects for api breaks

00:35:18,720 --> 00:35:24,320
that were found

00:35:20,960 --> 00:35:26,320
as after a changes into the standard

00:35:24,320 --> 00:35:27,359
um implementers have a long skin in the

00:35:26,320 --> 00:35:29,520
game

00:35:27,359 --> 00:35:30,560
because they're interested in preventing

00:35:29,520 --> 00:35:32,480
user pain

00:35:30,560 --> 00:35:33,760
they're the ones who get the bug reports

00:35:32,480 --> 00:35:37,119
there's the one who

00:35:33,760 --> 00:35:37,119
have to solve these problems

00:35:39,760 --> 00:35:43,200
there are some members of wg21 who

00:35:41,920 --> 00:35:46,400
really want to make

00:35:43,200 --> 00:35:49,119
changes that involve avi you know

00:35:46,400 --> 00:35:50,079
all the api changes start with having a

00:35:49,119 --> 00:35:52,960
meta discussion

00:35:50,079 --> 00:35:54,640
when avi brakes are allowed or designed

00:35:52,960 --> 00:35:58,480
there's a paper

00:35:54,640 --> 00:36:01,119
written pot2028 what is abi

00:35:58,480 --> 00:36:01,920
and what should we do about it which

00:36:01,119 --> 00:36:04,160
lays out

00:36:01,920 --> 00:36:06,480
some of the radical for this there are a

00:36:04,160 --> 00:36:08,400
couple of places in the standard library

00:36:06,480 --> 00:36:11,280
where

00:36:08,400 --> 00:36:13,119
basically changes it would be changes

00:36:11,280 --> 00:36:14,400
without breaking avi

00:36:13,119 --> 00:36:16,240
where there is a fair amount of

00:36:14,400 --> 00:36:19,520
performance that can be

00:36:16,240 --> 00:36:20,079
um regex for example we know a lot more

00:36:19,520 --> 00:36:22,079
about

00:36:20,079 --> 00:36:24,839
writing regex engines and so on than we

00:36:22,079 --> 00:36:28,160
did back in 2006

00:36:24,839 --> 00:36:30,000
um hannah has

00:36:28,160 --> 00:36:32,160
quite the exemplar over the last few

00:36:30,000 --> 00:36:33,839
years about how much

00:36:32,160 --> 00:36:35,839
better regexes could be with her

00:36:33,839 --> 00:36:40,640
compile-time regulation

00:36:35,839 --> 00:36:43,839
uh talks and um

00:36:40,640 --> 00:36:45,040
whoops sorry somewhere in our house in

00:36:43,839 --> 00:36:48,000
alarm

00:36:45,040 --> 00:36:48,000
anyway um

00:36:49,359 --> 00:36:58,720
anyway so uh and another one is in

00:36:54,320 --> 00:37:00,640
in unordered containers um

00:36:58,720 --> 00:37:02,800
the people at google have been doing a

00:37:00,640 --> 00:37:03,520
lot of work in their abseil library

00:37:02,800 --> 00:37:08,240
about

00:37:03,520 --> 00:37:11,280
on making alternate um

00:37:08,240 --> 00:37:13,680
making alternate implementations of

00:37:11,280 --> 00:37:16,000
unordered containers whether they be

00:37:13,680 --> 00:37:17,760
just uh different organizations or

00:37:16,000 --> 00:37:21,119
possibly even split store

00:37:17,760 --> 00:37:22,720
have the um the keys kept in one

00:37:21,119 --> 00:37:25,760
container and

00:37:22,720 --> 00:37:29,839
the values kept in another container and

00:37:25,760 --> 00:37:32,880
they're showing some very imp um

00:37:29,839 --> 00:37:36,880
performance marks

00:37:32,880 --> 00:37:39,280
um the changes they want you know

00:37:36,880 --> 00:37:40,640
involve abi just to the existing

00:37:39,280 --> 00:37:44,160
standard containers

00:37:40,640 --> 00:37:47,359
and so we're talking about that

00:37:44,160 --> 00:37:47,839
um those are big ones there's and then

00:37:47,359 --> 00:37:51,119
there's a

00:37:47,839 --> 00:37:53,520
list of small things that would be nice

00:37:51,119 --> 00:37:53,520
to have

00:37:56,160 --> 00:38:00,960
okay um

00:38:02,839 --> 00:38:07,760
anyway so how could this be detectable i

00:38:05,920 --> 00:38:08,320
mean one of the really nasty things

00:38:07,760 --> 00:38:10,160
about

00:38:08,320 --> 00:38:11,760
abi breaks that frequently they're not

00:38:10,160 --> 00:38:14,320
detectable except that your code

00:38:11,760 --> 00:38:14,320
crashes

00:38:14,800 --> 00:38:20,320
one of the and and nobody wants that

00:38:18,880 --> 00:38:23,119
one of the suggestions that someone has

00:38:20,320 --> 00:38:25,359
made is that basically if

00:38:23,119 --> 00:38:26,880
you're to choose to have an avi break

00:38:25,359 --> 00:38:30,240
say that for c

00:38:26,880 --> 00:38:32,400
26 let's just say let's know this this

00:38:30,240 --> 00:38:36,240
hasn't been decided it hasn't it

00:38:32,400 --> 00:38:36,960
it has been discussed at some future

00:38:36,240 --> 00:38:39,760
point

00:38:36,960 --> 00:38:41,119
you know there might be an abi

00:38:39,760 --> 00:38:44,079
incompatible version

00:38:41,119 --> 00:38:46,240
of the standard library when i say say

00:38:44,079 --> 00:38:47,440
for c plus plus 26 that is not meaning

00:38:46,240 --> 00:38:50,000
oh yes this is going to

00:38:47,440 --> 00:38:51,839
please don't go on reddit it says

00:38:50,000 --> 00:38:52,480
marshall says that the center library is

00:38:51,839 --> 00:38:54,480
going to

00:38:52,480 --> 00:38:57,680
going to have a different avi for cpus

00:38:54,480 --> 00:39:00,240
26 because that's not the case

00:38:57,680 --> 00:39:00,720
um one of the suggestions for those if

00:39:00,240 --> 00:39:03,839
if

00:39:00,720 --> 00:39:06,079
such a thing were to happen is that to

00:39:03,839 --> 00:39:09,520
have implementers change the enabling

00:39:06,079 --> 00:39:12,640
scheme starting in that release

00:39:09,520 --> 00:39:14,079
basically you know their the name bangla

00:39:12,640 --> 00:39:16,079
has an introductory

00:39:14,079 --> 00:39:17,760
introductory character black can't say

00:39:16,079 --> 00:39:20,720
that it's hard

00:39:17,760 --> 00:39:21,119
can't say that quickly um starts with

00:39:20,720 --> 00:39:22,960
most

00:39:21,119 --> 00:39:24,480
it starts with z and you could change

00:39:22,960 --> 00:39:26,640
the introductory character to say

00:39:24,480 --> 00:39:28,320
y or something and basically what this

00:39:26,640 --> 00:39:30,240
would mean is that object files built

00:39:28,320 --> 00:39:31,680
with that standard would not link with

00:39:30,240 --> 00:39:32,480
object files built with previous

00:39:31,680 --> 00:39:35,359
standard

00:39:32,480 --> 00:39:37,359
and if you tried to to load a library

00:39:35,359 --> 00:39:38,880
that was built with

00:39:37,359 --> 00:39:42,800
new standard with code of the old

00:39:38,880 --> 00:39:46,160
standard it would fail to load because

00:39:42,800 --> 00:39:46,160
all the name lookups would fail

00:39:46,960 --> 00:39:51,920
okay um it's also possible

00:39:50,079 --> 00:39:53,760
if we're to do something like this to

00:39:51,920 --> 00:39:56,320
provide

00:39:53,760 --> 00:39:58,720
quote unquote fat binaries a an object

00:39:56,320 --> 00:40:01,599
filed or a shared library that contain

00:39:58,720 --> 00:40:03,520
two different copies of the code one

00:40:01,599 --> 00:40:05,760
mangled one way and one may i handle the

00:40:03,520 --> 00:40:05,760
other

00:40:09,599 --> 00:40:13,920
so um

00:40:17,359 --> 00:40:21,119
that could be done i mean details matter

00:40:19,359 --> 00:40:23,119
there's a lot of detail hashed out

00:40:21,119 --> 00:40:24,800
but you know apple for example has had a

00:40:23,119 --> 00:40:26,319
long history of shipping what they call

00:40:24,800 --> 00:40:28,880
fat binaries they've

00:40:26,319 --> 00:40:30,319
recently revived that for their new arm

00:40:28,880 --> 00:40:32,079
laptops

00:40:30,319 --> 00:40:34,240
you know the idea is that you can ship

00:40:32,079 --> 00:40:35,680
arm code and x86 code in the same

00:40:34,240 --> 00:40:38,240
executable

00:40:35,680 --> 00:40:41,040
back in the day they did that for 68k

00:40:38,240 --> 00:40:44,880
and powerpc code as well

00:40:41,040 --> 00:40:46,880
um anyway so

00:40:44,880 --> 00:40:50,319
this is one of the ways to that you

00:40:46,880 --> 00:40:50,319
could um do this

00:40:51,359 --> 00:40:56,319
but the real problem with

00:40:54,480 --> 00:40:58,079
this kind of even even this kind of

00:40:56,319 --> 00:41:00,640
approach but with abi

00:40:58,079 --> 00:41:01,520
um abi breaks in general is even when

00:41:00,640 --> 00:41:05,520
they're detectable

00:41:01,520 --> 00:41:06,960
the problem is is that the system

00:41:05,520 --> 00:41:09,119
the system that you want to check

00:41:06,960 --> 00:41:11,760
against is never really

00:41:09,119 --> 00:41:12,720
assembled until you actually launch the

00:41:11,760 --> 00:41:16,079
program

00:41:12,720 --> 00:41:16,079
and that's the time when

00:41:16,240 --> 00:41:19,280
the executable program all the shared

00:41:18,079 --> 00:41:22,160
libraries

00:41:19,280 --> 00:41:23,440
the plugins they're all together and

00:41:22,160 --> 00:41:26,720
that's the uh

00:41:23,440 --> 00:41:28,960
and that is where such checking would

00:41:26,720 --> 00:41:31,839
need to happen

00:41:28,960 --> 00:41:32,880
um i want to point out that programs

00:41:31,839 --> 00:41:36,720
manually load

00:41:32,880 --> 00:41:38,400
plugins that you know have a plug-in

00:41:36,720 --> 00:41:40,079
directory that you can stuff in and at

00:41:38,400 --> 00:41:43,040
launch they enumerate it and

00:41:40,079 --> 00:41:43,440
choose whether or not to load them like

00:41:43,040 --> 00:41:47,119
say

00:41:43,440 --> 00:41:51,440
browsers or acrobat or

00:41:47,119 --> 00:41:53,119
apache or things like that um

00:41:51,440 --> 00:41:54,960
are not really statically checkable

00:41:53,119 --> 00:41:56,480
because it depends on configuration

00:41:54,960 --> 00:42:00,160
information and what

00:41:56,480 --> 00:42:02,880
um what browser what plugins are

00:42:00,160 --> 00:42:03,359
are here and which are enabled enabled

00:42:02,880 --> 00:42:05,359
you know

00:42:03,359 --> 00:42:07,680
a static checker would have to know how

00:42:05,359 --> 00:42:09,520
to need their uh

00:42:07,680 --> 00:42:11,680
their configuration information and so

00:42:09,520 --> 00:42:11,680
on

00:42:12,400 --> 00:42:18,400
uh has asked a question

00:42:16,079 --> 00:42:18,400
said

00:42:19,760 --> 00:42:23,200
the system is never really put together

00:42:21,440 --> 00:42:24,079
until you actually launch isn't this

00:42:23,200 --> 00:42:25,920
what's happened

00:42:24,079 --> 00:42:27,920
during linking yes i'm going to ask that

00:42:25,920 --> 00:42:30,720
will answer that one right now

00:42:27,920 --> 00:42:31,200
um but basically the thing is is that

00:42:30,720 --> 00:42:33,599
during

00:42:31,200 --> 00:42:33,599
linking

00:42:34,240 --> 00:42:37,440
you specify all the things that are

00:42:35,920 --> 00:42:42,079
needed to run the program

00:42:37,440 --> 00:42:42,079
and then that's um

00:42:42,640 --> 00:42:46,560
you say i i'm going to gather up all

00:42:44,960 --> 00:42:49,520
these object files

00:42:46,560 --> 00:42:50,319
and i'm going to require these shared

00:42:49,520 --> 00:42:51,920
libraries

00:42:50,319 --> 00:42:54,319
let's let's just say there's one shared

00:42:51,920 --> 00:42:55,920
library lib

00:42:54,319 --> 00:42:58,319
lib c plus plus because you know that's

00:42:55,920 --> 00:43:01,599
the one i worked okay

00:42:58,319 --> 00:43:02,400
and then you take that executable that

00:43:01,599 --> 00:43:03,680
you just linked

00:43:02,400 --> 00:43:05,520
and take it to another machine and

00:43:03,680 --> 00:43:08,960
launch it

00:43:05,520 --> 00:43:10,240
and it says i need lipstick plus plus

00:43:08,960 --> 00:43:12,960
and mc plus plus

00:43:10,240 --> 00:43:15,119
dot dial it and that other machine says

00:43:12,960 --> 00:43:17,680
i have a loops default plus dot dialog

00:43:15,119 --> 00:43:17,680
here it is

00:43:18,960 --> 00:43:24,839
is that the same version of the die lib

00:43:21,040 --> 00:43:28,800
that you that you linked against

00:43:24,839 --> 00:43:31,040
maybe maybe not

00:43:28,800 --> 00:43:33,119
um to give an example say you're on mac

00:43:31,040 --> 00:43:36,960
os

00:43:33,119 --> 00:43:39,359
10 14

00:43:36,960 --> 00:43:40,560
and then you and you build yourself a

00:43:39,359 --> 00:43:43,839
plan and then you

00:43:40,560 --> 00:43:46,880
upgrade your system to 10.15

00:43:43,839 --> 00:43:49,440
and you launch that program again

00:43:46,880 --> 00:43:51,200
that's a different shared library a

00:43:49,440 --> 00:43:54,160
different dilip

00:43:51,200 --> 00:43:55,200
so no it doesn't all happen during

00:43:54,160 --> 00:43:56,640
linking

00:43:55,200 --> 00:43:59,040
i mean a lot of it happens during

00:43:56,640 --> 00:44:01,680
linking

00:43:59,040 --> 00:44:03,119
okay hopefully that answers endless

00:44:01,680 --> 00:44:05,839
question if it doesn't

00:44:03,119 --> 00:44:09,200
um she can ask some more that'll be fine

00:44:05,839 --> 00:44:11,440
i would be fine with that okay

00:44:09,200 --> 00:44:11,440
so

00:44:16,160 --> 00:44:25,680
let's oops let me get back to my slides

00:44:23,760 --> 00:44:28,160
okay so what would this mean to

00:44:25,680 --> 00:44:28,160
developers

00:44:28,800 --> 00:44:38,800
okay um

00:44:36,079 --> 00:44:39,839
so if you assume actually you know what

00:44:38,800 --> 00:44:41,520
let me answer chris

00:44:39,839 --> 00:44:44,079
chris's question because it's it's like

00:44:41,520 --> 00:44:44,079
a follow-on

00:44:44,880 --> 00:44:48,079
no no i'm going to wait on chris's

00:44:46,319 --> 00:44:50,319
question never mind um

00:44:48,079 --> 00:44:52,240
anyway suit assuming of fat bucket

00:44:50,319 --> 00:44:54,960
binary packaging scheme

00:44:52,240 --> 00:44:56,560
developers could ship binaries could

00:44:54,960 --> 00:44:58,079
would have to choose between choosing

00:44:56,560 --> 00:44:59,760
you know supporting old standards new

00:44:58,079 --> 00:45:02,880
standards both

00:44:59,760 --> 00:45:06,640
um if you have a packaging scheme

00:45:02,880 --> 00:45:09,520
um then you know most of this

00:45:06,640 --> 00:45:11,200
is you know make file whacking you know

00:45:09,520 --> 00:45:12,880
build everything twice and package it

00:45:11,200 --> 00:45:16,640
all together

00:45:12,880 --> 00:45:18,000
but it's probably a little more

00:45:16,640 --> 00:45:20,640
complicated than that there's certainly

00:45:18,000 --> 00:45:22,560
a testing burden certainly a a

00:45:20,640 --> 00:45:26,240
distribution burden

00:45:22,560 --> 00:45:28,720
you know your binaries get big

00:45:26,240 --> 00:45:29,680
i know for example that the the standard

00:45:28,720 --> 00:45:32,800
library team

00:45:29,680 --> 00:45:36,400
microsoft is uh

00:45:32,800 --> 00:45:37,760
it gets uh is under pressure to reduce

00:45:36,400 --> 00:45:40,960
the size of their uh

00:45:37,760 --> 00:45:43,839
their their binary not double it

00:45:40,960 --> 00:45:45,040
because basically people wanting minimal

00:45:43,839 --> 00:45:48,319
windows installed to be

00:45:45,040 --> 00:45:48,319
actually noticeably smaller

00:45:48,960 --> 00:45:55,200
anyway so it's not a lot of pain

00:45:52,800 --> 00:45:56,880
for developers i mean they're real costs

00:45:55,200 --> 00:46:00,160
but in terms of

00:45:56,880 --> 00:46:00,880
for people who are developing software

00:46:00,160 --> 00:46:06,319
it's not

00:46:00,880 --> 00:46:06,319
such an awful thing but by users

00:46:06,800 --> 00:46:12,480
so if you have

00:46:10,160 --> 00:46:13,839
assuming that there's an abi break

00:46:12,480 --> 00:46:15,599
coming and assuming that you know

00:46:13,839 --> 00:46:17,599
there's some kind of

00:46:15,599 --> 00:46:19,040
you have some way of detecting the abi

00:46:17,599 --> 00:46:20,960
break whether it be that changing the

00:46:19,040 --> 00:46:22,560
name mangling or whatever

00:46:20,960 --> 00:46:25,440
if you have source bit of software that

00:46:22,560 --> 00:46:28,000
you use and you're willing to rebuild it

00:46:25,440 --> 00:46:29,680
there's not a problem for you and there

00:46:28,000 --> 00:46:30,319
are there are people out there in the

00:46:29,680 --> 00:46:31,599
world

00:46:30,319 --> 00:46:34,160
there are organizations out there in the

00:46:31,599 --> 00:46:37,599
world that that absolutely have this

00:46:34,160 --> 00:46:39,760
um you're an os vendor say you know

00:46:37,599 --> 00:46:41,760
the ubuntu folk for example definitely

00:46:39,760 --> 00:46:45,200
fall into this category

00:46:41,760 --> 00:46:46,720
um if you never use any third-party

00:46:45,200 --> 00:46:48,640
software then this is not a problem with

00:46:46,720 --> 00:46:51,440
you for you because your os vendor will

00:46:48,640 --> 00:46:51,440
take care of all this

00:46:52,079 --> 00:46:58,640
um if um

00:46:57,119 --> 00:47:01,760
because you're getting all your software

00:46:58,640 --> 00:47:03,680
from one place and

00:47:01,760 --> 00:47:05,440
it's all it all comes from the same

00:47:03,680 --> 00:47:06,319
place at the same time so there won't be

00:47:05,440 --> 00:47:09,359
any abi

00:47:06,319 --> 00:47:11,119
concerns but

00:47:09,359 --> 00:47:12,560
if you have binaries that you see plus

00:47:11,119 --> 00:47:16,640
plus internally

00:47:12,560 --> 00:47:16,640
somehow then this could affect you

00:47:19,200 --> 00:47:23,760
okay so let's do this

00:47:22,319 --> 00:47:26,559
let's take a look at these questions

00:47:23,760 --> 00:47:29,280
actually let's let's work through this

00:47:26,559 --> 00:47:32,000
okay imagine you're a graphic artist and

00:47:29,280 --> 00:47:34,480
you're a heavy photographer

00:47:32,000 --> 00:47:35,119
and you get a system update from

00:47:34,480 --> 00:47:38,160
somewhere

00:47:35,119 --> 00:47:40,400
apple microsoft ubuntu whatever

00:47:38,160 --> 00:47:40,400
um

00:47:43,520 --> 00:47:46,880
and you upgrade and it comes with a new

00:47:45,280 --> 00:47:48,160
standard light i live which has a

00:47:46,880 --> 00:47:51,280
different aviation

00:47:48,160 --> 00:47:52,400
and you say damn but fortunately adobe

00:47:51,280 --> 00:47:55,599
is right on top of this

00:47:52,400 --> 00:47:57,200
adobe has stuff ready to go on day zero

00:47:55,599 --> 00:47:58,640
and they have a new new copy of

00:47:57,200 --> 00:48:01,119
photoshop and

00:47:58,640 --> 00:48:02,240
which uses that new api and you launch

00:48:01,119 --> 00:48:06,160
your new version of photos

00:48:02,240 --> 00:48:08,559
and um none of your third-party plugins

00:48:06,160 --> 00:48:09,440
for those who are not familiar with the

00:48:08,559 --> 00:48:12,880
photoshop

00:48:09,440 --> 00:48:15,920
uh software economy or even

00:48:12,880 --> 00:48:17,839
there is a there is a thriving market in

00:48:15,920 --> 00:48:20,880
third-party plug-ins that add

00:48:17,839 --> 00:48:21,599
additional effects functionality to

00:48:20,880 --> 00:48:24,640
photoshop

00:48:21,599 --> 00:48:26,000
photoshop has well documented plug-in

00:48:24,640 --> 00:48:27,680
mechanism

00:48:26,000 --> 00:48:29,040
none of your third-party plug-ins load

00:48:27,680 --> 00:48:32,240
because

00:48:29,040 --> 00:48:32,960
they're all using the old api maybe they

00:48:32,240 --> 00:48:34,480
crash

00:48:32,960 --> 00:48:36,240
that would be worse maybe they crash on

00:48:34,480 --> 00:48:39,520
launch maybe they corrupt your document

00:48:36,240 --> 00:48:43,200
yeah or you crash when they use but

00:48:39,520 --> 00:48:45,440
not loading is the best possible outcome

00:48:43,200 --> 00:48:46,880
okay you're a heavy you're a heavy

00:48:45,440 --> 00:48:51,839
photoshop user i.e

00:48:46,880 --> 00:48:53,119
you photoshop to make money um

00:48:51,839 --> 00:48:56,079
you know this is how you make your

00:48:53,119 --> 00:48:58,079
living now you have to disable all those

00:48:56,079 --> 00:49:00,000
plugins that you use on a regular basis

00:48:58,079 --> 00:49:01,119
and contact the say 15 different

00:49:00,000 --> 00:49:03,040
developers

00:49:01,119 --> 00:49:04,240
the 40 plugins you use on a regular

00:49:03,040 --> 00:49:05,760
basis

00:49:04,240 --> 00:49:07,359
some of them will say oh sure here's a

00:49:05,760 --> 00:49:10,160
new version

00:49:07,359 --> 00:49:12,880
someone will say oh yeah i have a new

00:49:10,160 --> 00:49:15,280
version but it's going to cost you

00:49:12,880 --> 00:49:17,280
don't know how much some will oh yeah

00:49:15,280 --> 00:49:18,079
you have to get version three which is

00:49:17,280 --> 00:49:21,200
you know

00:49:18,079 --> 00:49:22,640
50 i don't know what some will say

00:49:21,200 --> 00:49:24,720
oh thanks for letting me know i'll get

00:49:22,640 --> 00:49:27,680
right on that some of them will say

00:49:24,720 --> 00:49:29,280
yeah it's on my list and some of them

00:49:27,680 --> 00:49:31,040
will not answer your emails or phone

00:49:29,280 --> 00:49:33,760
because they're busy

00:49:31,040 --> 00:49:34,720
or they're back in school or this is a

00:49:33,760 --> 00:49:38,160
part-time gig

00:49:34,720 --> 00:49:41,040
for them or whatever so what do you do

00:49:38,160 --> 00:49:42,559
to get your system back up and running

00:49:41,040 --> 00:49:44,240
you go to your backup you restore the

00:49:42,559 --> 00:49:45,119
old working system and you move on and

00:49:44,240 --> 00:49:48,400
you say yeah

00:49:45,119 --> 00:49:51,359
i am not ready to upgrade maybe i'll

00:49:48,400 --> 00:49:51,359
never be ready to upgrade

00:49:53,359 --> 00:50:00,720
um this is not a really great

00:49:57,520 --> 00:50:03,680
scenario for people who want to uh

00:50:00,720 --> 00:50:06,480
move things forward compatibility is

00:50:03,680 --> 00:50:06,480
kind of a barrier

00:50:07,359 --> 00:50:12,720
okay let's go to questions

00:50:11,119 --> 00:50:15,280
go to questions we have a few questions

00:50:12,720 --> 00:50:19,040
let's take a look

00:50:15,280 --> 00:50:21,760
all right tyler says i will be

00:50:19,040 --> 00:50:24,839
read that apple says swift will be abi

00:50:21,760 --> 00:50:28,079
compatible going forward

00:50:24,839 --> 00:50:29,680
um what strategies will they have to

00:50:28,079 --> 00:50:31,599
employ to innovate in the language

00:50:29,680 --> 00:50:32,720
without not with while not breaking the

00:50:31,599 --> 00:50:36,000
api

00:50:32,720 --> 00:50:39,280
um i certainly can't speak for apple

00:50:36,000 --> 00:50:41,520
i have not worked at apple in wow

00:50:39,280 --> 00:50:42,720
almost 25 years and that was just as a

00:50:41,520 --> 00:50:45,920
consultant

00:50:42,720 --> 00:50:45,920
um but

00:50:46,960 --> 00:50:51,920
i don't know what they would do for the

00:50:48,400 --> 00:50:51,920
language okay

00:50:52,839 --> 00:50:58,800
uh they are going to uh

00:50:55,200 --> 00:51:00,400
for the library they can make sure that

00:50:58,800 --> 00:51:05,040
they don't make changes to

00:51:00,400 --> 00:51:08,160
things in the array that change avis

00:51:05,040 --> 00:51:10,400
um the java folk for example have been

00:51:08,160 --> 00:51:11,760
really straightforward about that yeah

00:51:10,400 --> 00:51:12,800
it didn't work we're going to make a new

00:51:11,760 --> 00:51:14,480
version of

00:51:12,800 --> 00:51:16,240
that fixes the problems and instead of

00:51:14,480 --> 00:51:19,599
using say

00:51:16,240 --> 00:51:22,160
hashmap you use hashmap 2 or hashmap new

00:51:19,599 --> 00:51:24,240
or whatever they call it or improved

00:51:22,160 --> 00:51:27,440
hashtag or something like that

00:51:24,240 --> 00:51:28,800
um i'm making fun of

00:51:27,440 --> 00:51:30,960
somebody's naming scheme don't worry

00:51:28,800 --> 00:51:32,319
about it but hopefully you get a better

00:51:30,960 --> 00:51:35,680
name than

00:51:32,319 --> 00:51:37,599
new hashmap um anyway

00:51:35,680 --> 00:51:40,400
um java has done a lot of that they've

00:51:37,599 --> 00:51:42,559
done a lot of oh yeah

00:51:40,400 --> 00:51:44,319
this this library facility is deprecated

00:51:42,559 --> 00:51:46,800
just don't use it anymore use this which

00:51:44,319 --> 00:51:50,480
is really similar and much better

00:51:46,800 --> 00:51:52,880
um i don't i can't really speak about

00:51:50,480 --> 00:51:56,800
changing things at a language level

00:51:52,880 --> 00:51:59,680
because that's not my area of expertise

00:51:56,800 --> 00:51:59,680
um let's see

00:52:01,200 --> 00:52:05,760
anchor asks can optimization flags

00:52:04,119 --> 00:52:10,160
o10203

00:52:05,760 --> 00:52:15,280
um result in avi breakage um

00:52:10,160 --> 00:52:18,880
oh i sure hope not

00:52:15,280 --> 00:52:21,599
i don't believe that's a uh that is

00:52:18,880 --> 00:52:23,680
um something that should happen i would

00:52:21,599 --> 00:52:24,240
consider that a bug either specification

00:52:23,680 --> 00:52:27,440
bug

00:52:24,240 --> 00:52:27,440
or a um

00:52:28,000 --> 00:52:31,359
or a compiler bug or maybe even linker

00:52:29,920 --> 00:52:34,000
bug because

00:52:31,359 --> 00:52:34,640
um should not happen you should be able

00:52:34,000 --> 00:52:37,040
to mix

00:52:34,640 --> 00:52:38,400
code at compiled at different

00:52:37,040 --> 00:52:41,920
observation levels because

00:52:38,400 --> 00:52:45,680
you know sometimes you need to optimize

00:52:41,920 --> 00:52:48,240
the out of one inner loop and

00:52:45,680 --> 00:52:49,760
not the rest of stuff or you want to opt

00:52:48,240 --> 00:52:53,280
most of your code for

00:52:49,760 --> 00:52:56,319
size and um

00:52:53,280 --> 00:53:01,359
much less of your code for you know one

00:52:56,319 --> 00:53:03,920
piece of your code for speed

00:53:01,359 --> 00:53:04,880
um hopefully that answers your question

00:53:03,920 --> 00:53:08,640
all right

00:53:04,880 --> 00:53:10,160
chris asks an abi can cause a rejection

00:53:08,640 --> 00:53:11,280
of standard proposals not words but

00:53:10,160 --> 00:53:12,960
usually

00:53:11,280 --> 00:53:15,280
but i noticed that standard optional

00:53:12,960 --> 00:53:16,880
change guy in g plus plus between

00:53:15,280 --> 00:53:19,599
versions seven five and eight one and

00:53:16,880 --> 00:53:21,280
cladding between spur seven and eight

00:53:19,599 --> 00:53:24,400
uh trivially copied constructable for

00:53:21,280 --> 00:53:26,960
optional went from node yes

00:53:24,400 --> 00:53:29,200
um why would that why would one change

00:53:26,960 --> 00:53:34,319
licenses be accepted but others

00:53:29,200 --> 00:53:37,920
not i believe this is a timing thing

00:53:34,319 --> 00:53:42,880
i believe that that this change optional

00:53:37,920 --> 00:53:46,079
was made during the run up for 17.

00:53:42,880 --> 00:53:48,640
so while c plus plus 14 was the current

00:53:46,079 --> 00:53:53,520
standard which did not contain optional

00:53:48,640 --> 00:53:56,640
and c pulse 17 not yet been adopted

00:53:53,520 --> 00:53:59,040
and so all right all the all the

00:53:56,640 --> 00:54:02,000
seatposts plus 17 features were still

00:53:59,040 --> 00:54:03,440
quote-unquote experimental um gcc is

00:54:02,000 --> 00:54:06,960
very

00:54:03,440 --> 00:54:09,440
very upfront in their uh documentation

00:54:06,960 --> 00:54:12,640
let's see pulse plus a little less so

00:54:09,440 --> 00:54:14,960
but um that features

00:54:12,640 --> 00:54:16,079
that are in an upcoming but not yet

00:54:14,960 --> 00:54:20,319
adopted standard

00:54:16,079 --> 00:54:24,640
are not considered to be

00:54:20,319 --> 00:54:27,760
final not considered to be stable and so

00:54:24,640 --> 00:54:31,200
that's a case where there was a

00:54:27,760 --> 00:54:31,200
something was discovered to be

00:54:31,599 --> 00:54:35,359
not well i don't know whether you could

00:54:33,680 --> 00:54:37,520
call it wrong or you could call it just

00:54:35,359 --> 00:54:40,559
not as good as it could be

00:54:37,520 --> 00:54:42,240
but um this was a case where

00:54:40,559 --> 00:54:43,599
you the change was made to something

00:54:42,240 --> 00:54:44,400
which has not been released in a

00:54:43,599 --> 00:54:47,839
standard yet

00:54:44,400 --> 00:54:51,280
and so there was much less resistance to

00:54:47,839 --> 00:54:54,400
changing that and also because

00:54:51,280 --> 00:54:58,960
the idea that people who were

00:54:54,400 --> 00:55:02,960
using optional before c plus plus 17 was

00:54:58,960 --> 00:55:02,960
released were smaller

00:55:04,400 --> 00:55:08,880
were much smaller population and these

00:55:07,440 --> 00:55:10,880
are people who are doing active

00:55:08,880 --> 00:55:14,720
development and so recompiling their

00:55:10,880 --> 00:55:14,720
stuff is less of a burden for them

00:55:16,559 --> 00:55:22,720
okay um

00:55:21,200 --> 00:55:24,880
daniel asks do you ever see a point

00:55:22,720 --> 00:55:25,440
where c-pip spells could become a build

00:55:24,880 --> 00:55:27,280
you

00:55:25,440 --> 00:55:29,599
build your own abi by picking and

00:55:27,280 --> 00:55:31,920
choosing which avi breaking changes are

00:55:29,599 --> 00:55:31,920
brought

00:55:32,839 --> 00:55:38,960
um

00:55:35,200 --> 00:55:43,599
we have that today but in general

00:55:38,960 --> 00:55:43,599
it's done by platform vendors

00:55:44,319 --> 00:55:52,559
um people who distribute

00:55:49,280 --> 00:55:54,559
standard library dilips okay

00:55:52,559 --> 00:55:56,160
or people who link their standard

00:55:54,559 --> 00:55:59,280
libraries statically

00:55:56,160 --> 00:56:00,400
can do that today but if you're going to

00:55:59,280 --> 00:56:03,440
use

00:56:00,400 --> 00:56:06,960
the the standard library dynamic

00:56:03,440 --> 00:56:09,440
library that is just part of your system

00:56:06,960 --> 00:56:12,240
well that pretty much defines the api

00:56:09,440 --> 00:56:17,280
for your system

00:56:12,240 --> 00:56:18,960
so hopefully that um

00:56:17,280 --> 00:56:21,040
hopefully that answers your question if

00:56:18,960 --> 00:56:22,880
not answer another one ask another one

00:56:21,040 --> 00:56:26,000
i'm fine with that

00:56:22,880 --> 00:56:31,839
um all right

00:56:26,000 --> 00:56:31,839
let's see that one okay

00:56:33,599 --> 00:56:38,960
what do you say about tools like lib

00:56:36,240 --> 00:56:40,000
abigail or abi compat that can check abi

00:56:38,960 --> 00:56:44,160
bring

00:56:40,000 --> 00:56:45,599
using dwarf information um i am not that

00:56:44,160 --> 00:56:48,400
familiar with those i

00:56:45,599 --> 00:56:48,880
tried playing with um with abigail a

00:56:48,400 --> 00:56:51,680
long

00:56:48,880 --> 00:56:52,880
a long time ago but lost interest really

00:56:51,680 --> 00:56:55,920
quickly because

00:56:52,880 --> 00:56:59,839
well my doesn't generate more

00:56:55,920 --> 00:57:01,839
information um

00:56:59,839 --> 00:57:03,280
you can certainly uh it could certainly

00:57:01,839 --> 00:57:07,680
do some of those

00:57:03,280 --> 00:57:10,480
things but um

00:57:07,680 --> 00:57:12,079
yeah as you say um they're not going to

00:57:10,480 --> 00:57:14,240
be complete

00:57:12,079 --> 00:57:15,359
and this is certainly not something you

00:57:14,240 --> 00:57:18,720
want

00:57:15,359 --> 00:57:18,720
end users to be doing

00:57:18,880 --> 00:57:24,400
also um

00:57:22,160 --> 00:57:26,400
if i am if i'm an end user and wondering

00:57:24,400 --> 00:57:30,000
if you know my

00:57:26,400 --> 00:57:33,680
my pins for well i don't know

00:57:30,000 --> 00:57:35,760
for my mail program are compatible with

00:57:33,680 --> 00:57:37,599
my ml program

00:57:35,760 --> 00:57:39,040
i may not have dwarf information for

00:57:37,599 --> 00:57:41,599
those

00:57:39,040 --> 00:57:42,319
now i believe that the lib abigail stuff

00:57:41,599 --> 00:57:45,119
isn't

00:57:42,319 --> 00:57:45,760
and so on abi compact is useful but

00:57:45,119 --> 00:57:48,240
certainly not

00:57:45,760 --> 00:57:48,240
enough

00:57:48,880 --> 00:57:51,359
um

00:57:52,720 --> 00:57:55,839
stuff like that is done

00:57:56,000 --> 00:58:00,079
are there any best practices andrew says

00:57:58,319 --> 00:58:02,240
there any best practices for using

00:58:00,079 --> 00:58:03,599
things like inline name spaces or symbol

00:58:02,240 --> 00:58:09,839
versioning to maintain

00:58:03,599 --> 00:58:09,839
high compatibility um

00:58:11,040 --> 00:58:18,319
so that was one of the goals for

00:58:15,680 --> 00:58:19,119
inline namespaces was that you could you

00:58:18,319 --> 00:58:24,319
know have different

00:58:19,119 --> 00:58:26,079
different versions of um

00:58:24,319 --> 00:58:28,480
that were in different inline name

00:58:26,079 --> 00:58:30,319
spaces and

00:58:28,480 --> 00:58:33,200
they could be incompatible and the

00:58:30,319 --> 00:58:33,200
linker would

00:58:34,640 --> 00:58:38,960
would pick those program loader would

00:58:36,480 --> 00:58:43,119
pick right time the linkers and

00:58:38,960 --> 00:58:43,119
the program orders but

00:58:43,200 --> 00:58:48,640
i have never actually seen that

00:58:45,839 --> 00:58:50,960
successfully on a large project

00:58:48,640 --> 00:58:52,880
and so i don't have any best project

00:58:50,960 --> 00:58:54,880
best practice for that

00:58:52,880 --> 00:58:56,960
libsy plus plus certainly puts all of

00:58:54,880 --> 00:59:00,000
its in

00:58:56,960 --> 00:59:01,680
std colon colon underscore underscore

00:59:00,000 --> 00:59:03,920
one colon colon

00:59:01,680 --> 00:59:06,000
as a preparation for this but every time

00:59:03,920 --> 00:59:08,160
i've gone and tried to

00:59:06,000 --> 00:59:09,839
make a double underscore underscore two

00:59:08,160 --> 00:59:11,599
and keep them side by side

00:59:09,839 --> 00:59:13,359
i've gotten bogged down in an amazing

00:59:11,599 --> 00:59:17,119
set of details

00:59:13,359 --> 00:59:17,119
so i don't really

00:59:17,680 --> 00:59:23,280
don't have any good advice for you on

00:59:21,119 --> 00:59:23,280
this

00:59:25,280 --> 00:59:33,200
um nice todd has just said

00:59:28,720 --> 00:59:35,680
uh has given a links to lib cuda

00:59:33,200 --> 00:59:37,599
that has is doing this now good now i

00:59:35,680 --> 00:59:40,000
have some reading to do

00:59:37,599 --> 00:59:40,960
um he's put it in he has put a couple

00:59:40,000 --> 00:59:43,520
links in the q

00:59:40,960 --> 00:59:43,520
a for those

00:59:44,839 --> 00:59:47,839
um

00:59:47,920 --> 00:59:52,240
john has asked why is abi a standards

00:59:51,520 --> 00:59:54,000
problem

00:59:52,240 --> 00:59:56,880
it seems like it's the responsibility of

00:59:54,000 --> 00:59:56,880
the core creator

00:59:57,200 --> 01:00:04,079
so the problem here is that

01:00:00,880 --> 01:00:07,040
there is no software creator there is a

01:00:04,079 --> 01:00:10,240
collection of software creators

01:00:07,040 --> 01:00:14,240
and um they all

01:00:10,240 --> 01:00:15,280
have to work together to make where runs

01:00:14,240 --> 01:00:16,480
successfully

01:00:15,280 --> 01:00:18,000
there's the person who wrote the

01:00:16,480 --> 01:00:20,559
application there's the person who

01:00:18,000 --> 01:00:22,160
provided the standard library dialing

01:00:20,559 --> 01:00:24,319
there's the person who provided the

01:00:22,160 --> 01:00:24,799
other dialogues that the application

01:00:24,319 --> 01:00:28,319
need

01:00:24,799 --> 01:00:31,359
there's people the plugins um

01:00:28,319 --> 01:00:34,240
anyway lots of lots of different people

01:00:31,359 --> 01:00:35,040
and to um and say why is this a

01:00:34,240 --> 01:00:36,880
standards problem

01:00:35,040 --> 01:00:38,640
traditionally has not been a standards

01:00:36,880 --> 01:00:41,520
problem

01:00:38,640 --> 01:00:43,440
it has been a well not extent when i say

01:00:41,520 --> 01:00:46,079
standards from not album of the

01:00:43,440 --> 01:00:47,280
the iso c plus plus standards committee

01:00:46,079 --> 01:00:50,400
it's been

01:00:47,280 --> 01:00:52,000
has been handled by the people who

01:00:50,400 --> 01:00:53,520
implement shared libraries the people

01:00:52,000 --> 01:00:57,760
who main the

01:00:53,520 --> 01:01:00,400
um abi standards for individual

01:00:57,760 --> 01:01:00,400
platforms

01:01:01,680 --> 01:01:05,359
it's technically it's not there's

01:01:03,599 --> 01:01:07,440
problem this is not something that the c

01:01:05,359 --> 01:01:09,119
postpone standard addresses

01:01:07,440 --> 01:01:11,119
but there are people on the c postpone

01:01:09,119 --> 01:01:12,160
standard committee who are involved in

01:01:11,119 --> 01:01:14,400
addressing this

01:01:12,160 --> 01:01:16,640
and now there are people on the sea

01:01:14,400 --> 01:01:19,760
postal standards committee who

01:01:16,640 --> 01:01:21,680
um wish to get into do this get involved

01:01:19,760 --> 01:01:23,839
in this in more depth

01:01:21,680 --> 01:01:26,079
so traditionally it has been the people

01:01:23,839 --> 01:01:28,240
who ship standard library dylips

01:01:26,079 --> 01:01:29,520
okay who say yeah no we're not doing

01:01:28,240 --> 01:01:31,760
that because we'll break a bunch of

01:01:29,520 --> 01:01:33,920
existing software

01:01:31,760 --> 01:01:35,599
that's what happened to the pair

01:01:33,920 --> 01:01:38,160
proposal for c plus plus

01:01:35,599 --> 01:01:40,000
i think it was 14 was just like yeah no

01:01:38,160 --> 01:01:43,520
we're not doing this because

01:01:40,000 --> 01:01:43,520
you know it breaks existing code

01:01:44,640 --> 01:01:49,200
hopefully that answers your question

01:01:47,440 --> 01:01:51,119
okay

01:01:49,200 --> 01:01:53,359
see i hope i'm pronouncing your name

01:01:51,119 --> 01:01:57,520
correctly j-u-s-s-i

01:01:53,359 --> 01:01:59,280
um says asks for unordered map

01:01:57,520 --> 01:02:00,880
uh could an alternative approach of

01:01:59,280 --> 01:02:02,319
defining a new hash map and leaving the

01:02:00,880 --> 01:02:03,920
old one

01:02:02,319 --> 01:02:08,079
untouched with guidelines recommended

01:02:03,920 --> 01:02:08,079
people to stop using it um

01:02:09,760 --> 01:02:14,559
possible yes and that is very much the

01:02:12,720 --> 01:02:18,400
uh the

01:02:14,559 --> 01:02:21,760
the way that both java and python

01:02:18,400 --> 01:02:25,839
have handled um

01:02:21,760 --> 01:02:27,760
my let's see the way i put not my

01:02:25,839 --> 01:02:29,599
updating their standard library changing

01:02:27,760 --> 01:02:31,200
their standard library is defining

01:02:29,599 --> 01:02:33,920
facilities

01:02:31,200 --> 01:02:36,720
and recommending that people stop using

01:02:33,920 --> 01:02:39,039
the old one or deprecating the old ones

01:02:36,720 --> 01:02:39,039
um

01:02:42,640 --> 01:02:48,319
and moving on i mean essentially right

01:02:46,559 --> 01:02:50,319
the python 3 people have started

01:02:48,319 --> 01:02:52,720
removing old stuff

01:02:50,319 --> 01:02:54,640
um i don't believe although my knowledge

01:02:52,720 --> 01:02:56,720
of this is somewhat dated that

01:02:54,640 --> 01:02:58,240
that java the java people have done that

01:02:56,720 --> 01:03:02,240
or they just left the old

01:02:58,240 --> 01:03:05,440
pieces in place so um

01:03:02,240 --> 01:03:09,119
yes that is a very workable proposal um

01:03:05,440 --> 01:03:10,400
whether or not um

01:03:09,119 --> 01:03:12,000
people will be happy with it i don't

01:03:10,400 --> 01:03:14,799
know people are looking at alternate

01:03:12,000 --> 01:03:18,480
solutions as well

01:03:14,799 --> 01:03:21,440
uh let's see victor has asked are you a

01:03:18,480 --> 01:03:24,640
fan of the seatpost plus epic's proposal

01:03:21,440 --> 01:03:26,640
do i see something like rust editions

01:03:24,640 --> 01:03:29,440
working for c plus plus

01:03:26,640 --> 01:03:30,000
uh i am not familiar enough with rust

01:03:29,440 --> 01:03:32,880
editions

01:03:30,000 --> 01:03:32,880
to have a um

01:03:33,119 --> 01:03:41,359
uh an opinion on that so i'm not

01:03:37,599 --> 01:03:41,760
opine um i am not a fan of sea pulse

01:03:41,359 --> 01:03:45,119
plus

01:03:41,760 --> 01:03:48,079
epics because i believe it will

01:03:45,119 --> 01:03:50,319
fracture the user base every time we

01:03:48,079 --> 01:03:53,359
fracture the user base

01:03:50,319 --> 01:03:55,920
we leave a bunch of people behind and we

01:03:53,359 --> 01:03:55,920
we make it

01:03:56,880 --> 01:04:02,880
harder for people to quote keep

01:04:00,000 --> 01:04:03,839
up to continue to advance this is

01:04:02,880 --> 01:04:08,960
happening now

01:04:03,839 --> 01:04:11,039
anyway i mean the example of um

01:04:08,960 --> 01:04:12,000
see plot you know that that's the

01:04:11,039 --> 01:04:15,440
libsted c plus

01:04:12,000 --> 01:04:17,200
plus string string uh

01:04:15,440 --> 01:04:19,599
layout was an example or the string

01:04:17,200 --> 01:04:23,599
functionality and we have this now with

01:04:19,599 --> 01:04:26,720
c plus plus oh three c plus 11 14 17 20

01:04:23,599 --> 01:04:30,960
and whatever comes after 20. we have

01:04:26,720 --> 01:04:30,960
this now but we're trying to keep the um

01:04:32,559 --> 01:04:37,760
the stuff moving as soon as possible

01:04:36,000 --> 01:04:39,280
you know in an ideal world we would like

01:04:37,760 --> 01:04:41,599
to have everybody

01:04:39,280 --> 01:04:42,960
using the latest and greatest stuff but

01:04:41,599 --> 01:04:45,440
we don't both to make it

01:04:42,960 --> 01:04:47,680
so that people can it's easy for people

01:04:45,440 --> 01:04:49,839
to move

01:04:47,680 --> 01:04:50,799
upward if you if you want to say that if

01:04:49,839 --> 01:04:53,520
you if you

01:04:50,799 --> 01:04:53,920
want to give a value judgment towards

01:04:53,520 --> 01:04:56,559
the

01:04:53,920 --> 01:04:58,960
the more current stuff on their own

01:04:56,559 --> 01:05:01,839
schedule

01:04:58,960 --> 01:05:03,119
and i think that that cpa plus epics

01:05:01,839 --> 01:05:06,839
will

01:05:03,119 --> 01:05:08,319
if if enacted would encourage people not

01:05:06,839 --> 01:05:12,240
to

01:05:08,319 --> 01:05:14,559
um that's just my opinion that's not

01:05:12,240 --> 01:05:14,559
you know

01:05:15,359 --> 01:05:19,200
it's based on me sitting and listening

01:05:17,119 --> 01:05:24,400
to a 45 minute presentation of c

01:05:19,200 --> 01:05:24,400
specifics so i have not done a lot of um

01:05:25,680 --> 01:05:30,400
a lot of investigation let's see do we

01:05:28,000 --> 01:05:37,839
have any other ones

01:05:30,400 --> 01:05:37,839
i think that's the end of the questions

01:05:52,079 --> 01:05:54,160

YouTube URL: https://www.youtube.com/watch?v=7RoTDjLLXJQ


