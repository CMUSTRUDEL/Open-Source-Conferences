Title: CppCon 2014: Lightning Talks - Karl Niu "Convergent Evolution"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
I work on Microsoft's C++ language conformance efforts and IntelliSense in Visual Studio. | I am also interested in type theory and language design.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:06,000
alright Carl also a Microsoft person

00:00:03,480 --> 00:00:07,859
will compare and contrast C++ concepts

00:00:06,000 --> 00:00:09,480
with type classes from functional

00:00:07,859 --> 00:00:11,429
programming languages as a program

00:00:09,480 --> 00:00:13,049
manager on the visual c++ front-end team

00:00:11,429 --> 00:00:17,430
he's interested in type theory and

00:00:13,049 --> 00:00:18,720
language design and can later you guys

00:00:17,430 --> 00:00:25,439
can teach me how to be on the right page

00:00:18,720 --> 00:00:39,390
in an office document okay this five

00:00:25,439 --> 00:00:40,350
minutes five whoa here we go okay so my

00:00:39,390 --> 00:00:42,719
talk is called convergent evolution

00:00:40,350 --> 00:00:46,739
because it is about control pow I don't

00:00:42,719 --> 00:00:49,379
want this um you don't see it but

00:00:46,739 --> 00:00:52,430
there's a Wi-Fi hotspot thing nottin

00:00:49,379 --> 00:00:58,739
screen out dang it okay the client

00:00:52,430 --> 00:01:00,780
anyway uh let's talk about is about now

00:00:58,739 --> 00:01:04,379
it's not anything new if you read the

00:01:00,780 --> 00:01:07,530
papers most of this information is it's

00:01:04,379 --> 00:01:10,110
already been pointed out elsewhere but I

00:01:07,530 --> 00:01:11,760
just thought it was a cool idea i think

00:01:10,110 --> 00:01:15,689
it's a cool idea and i want to show you

00:01:11,760 --> 00:01:18,299
guys how cool it is and might help you

00:01:15,689 --> 00:01:21,900
think about your programs a different

00:01:18,299 --> 00:01:23,759
light and i think it demonstrates that

00:01:21,900 --> 00:01:26,210
when there is a design problem and if

00:01:23,759 --> 00:01:28,920
you try to solve the problem right

00:01:26,210 --> 00:01:36,240
everybody comes at a same solution for

00:01:28,920 --> 00:01:38,340
it so start out with the well-known fact

00:01:36,240 --> 00:01:41,600
that programs are proofs they call this

00:01:38,340 --> 00:01:44,280
the hurt curry Howard correspondence

00:01:41,600 --> 00:01:46,530
basically means is types are

00:01:44,280 --> 00:01:49,649
propositions or statements of whether

00:01:46,530 --> 00:01:53,369
it's true or false and an object with

00:01:49,649 --> 00:01:55,439
that type is a proof of the proposition

00:01:53,369 --> 00:01:57,170
that that type represents now of course

00:01:55,439 --> 00:01:59,610
this is not true in any real life

00:01:57,170 --> 00:02:03,060
pouring system especially not C++

00:01:59,610 --> 00:02:04,920
because C++ is messieurs evaluation is

00:02:03,060 --> 00:02:06,930
schemes to think of its side of factors

00:02:04,920 --> 00:02:10,020
cosmic rays and come in and mess up in

00:02:06,930 --> 00:02:12,010
memory bits for you it's it's not a it's

00:02:10,020 --> 00:02:16,329
not a very neat

00:02:12,010 --> 00:02:20,170
a system but it's fun to think of it lie

00:02:16,329 --> 00:02:22,629
like that sometimes and i think it's my

00:02:20,170 --> 00:02:25,750
opinion this idea ties every foreign

00:02:22,629 --> 00:02:31,019
language in the world together in

00:02:25,750 --> 00:02:35,379
harmony now what does this mean a very

00:02:31,019 --> 00:02:39,129
kind of a rough interpretation of the

00:02:35,379 --> 00:02:42,250
types in c++ are that you know you got

00:02:39,129 --> 00:02:44,470
functions functions are whoops functions

00:02:42,250 --> 00:02:47,709
are implication which is why I'm Haskell

00:02:44,470 --> 00:02:51,190
it uses arrow any sort of aggregate is

00:02:47,709 --> 00:02:56,819
and obviously you want two valleys

00:02:51,190 --> 00:02:59,200
together you need both some types unions

00:02:56,819 --> 00:03:01,690
Haskell has also great day arrives these

00:02:59,200 --> 00:03:05,230
are either or situations and why they're

00:03:01,690 --> 00:03:10,209
or we also have parametric polymorphism

00:03:05,230 --> 00:03:13,329
it's for all Haskell has for all

00:03:10,209 --> 00:03:16,230
explicitly write for all and C++ you got

00:03:13,329 --> 00:03:18,160
to use templates essential tides are

00:03:16,230 --> 00:03:20,410
complicated and I will not be talking

00:03:18,160 --> 00:03:21,730
about them but if you read types and

00:03:20,410 --> 00:03:24,699
foreign languages apparently there are

00:03:21,730 --> 00:03:29,019
pairs of values and types together leave

00:03:24,699 --> 00:03:32,980
it at that now there are with me for a

00:03:29,019 --> 00:03:35,919
second what exactly is a constraint yeah

00:03:32,980 --> 00:03:40,780
think about it its goals an example you

00:03:35,919 --> 00:03:43,090
say you want to sort a set right and you

00:03:40,780 --> 00:03:46,359
know you got to prove that the elements

00:03:43,090 --> 00:03:48,819
of that said have a total order now you

00:03:46,359 --> 00:03:51,160
got the Q sort function from see you can

00:03:48,819 --> 00:03:54,459
look at that there's a compare function

00:03:51,160 --> 00:03:57,220
there that takes to void stars and

00:03:54,459 --> 00:04:01,720
returns a greater than equal to or less

00:03:57,220 --> 00:04:03,190
than and hear that that is the proof by

00:04:01,720 --> 00:04:05,590
the definition of pull or debt that it

00:04:03,190 --> 00:04:07,590
proves that there's a total order on the

00:04:05,590 --> 00:04:12,310
elements of the set it's a constraint on

00:04:07,590 --> 00:04:14,560
the elements of this set yes once again

00:04:12,310 --> 00:04:17,440
if I'm always see then was not like a

00:04:14,560 --> 00:04:19,959
pure functional thing it's a very rough

00:04:17,440 --> 00:04:22,060
approximation but essentially a

00:04:19,959 --> 00:04:24,610
constraint is just an extra parameter

00:04:22,060 --> 00:04:28,580
right your lemmas in your proof

00:04:24,610 --> 00:04:31,969
so why are there concepts and type

00:04:28,580 --> 00:04:33,349
classes life like the convenience of

00:04:31,969 --> 00:04:38,930
course I mean if you really think about

00:04:33,349 --> 00:04:40,550
it all they are all kinda we can program

00:04:38,930 --> 00:04:41,749
in a way if you want to provide proofs

00:04:40,550 --> 00:04:43,129
for something you just pass it in

00:04:41,749 --> 00:04:44,629
explicitly right but we don't want to do

00:04:43,129 --> 00:04:47,449
that all the time if you have an

00:04:44,629 --> 00:04:49,159
established fact about a type if you

00:04:47,449 --> 00:04:51,889
know something you want to be able to

00:04:49,159 --> 00:04:54,680
just say it once tell the compiler hey

00:04:51,889 --> 00:04:57,219
this is known about these things and

00:04:54,680 --> 00:05:00,020
every time I mention this constraint vil

00:04:57,219 --> 00:05:02,150
bring it up for me out you're telling

00:05:00,020 --> 00:05:06,529
the compiler to who here knows what jfgi

00:05:02,150 --> 00:05:08,930
means stands for just get it from the

00:05:06,529 --> 00:05:10,819
environment for me please I don't want

00:05:08,930 --> 00:05:14,240
to supply that proof every time I want

00:05:10,819 --> 00:05:16,009
to sort a set of T objects if I can if I

00:05:14,240 --> 00:05:21,020
already told you that T has a total

00:05:16,009 --> 00:05:24,199
order and this is like three interesting

00:05:21,020 --> 00:05:27,680
as in Haskell and in scalar type classes

00:05:24,199 --> 00:05:30,409
are implemented in terms underneath

00:05:27,680 --> 00:05:32,779
there you implemented with implicit

00:05:30,409 --> 00:05:34,430
parameters they are implicit parameters

00:05:32,779 --> 00:05:37,490
their implicit parameters that are

00:05:34,430 --> 00:05:41,240
indexed by the type and yes type classes

00:05:37,490 --> 00:05:42,379
are a type of a different kind than the

00:05:41,240 --> 00:05:44,389
normal text you deal with but they're

00:05:42,379 --> 00:05:45,740
still a type nonetheless and by

00:05:44,389 --> 00:05:49,069
mentioning the type class so eventually

00:05:45,740 --> 00:05:51,229
this how your indexing into that the the

00:05:49,069 --> 00:05:52,879
thing you've told the compiler already

00:05:51,229 --> 00:05:54,620
and you can bring it out you know yours

00:05:52,879 --> 00:05:57,589
here's a record of these methods you use

00:05:54,620 --> 00:05:59,089
them directly so that's what they are

00:05:57,589 --> 00:06:02,629
concepts and type classes they allow you

00:05:59,089 --> 00:06:05,449
to state facts about types in a single

00:06:02,629 --> 00:06:06,800
place and then those facts are not known

00:06:05,449 --> 00:06:10,610
everywhere it's been mentioning the

00:06:06,800 --> 00:06:12,680
constraint of course every time people

00:06:10,610 --> 00:06:14,990
bring up concepts they lo we want to

00:06:12,680 --> 00:06:18,919
simplify a template template errors and

00:06:14,990 --> 00:06:20,899
that's that's nice and all but yeah the

00:06:18,919 --> 00:06:23,659
more theoretical I'd like to think of it

00:06:20,899 --> 00:06:26,899
this way it's more it's it tickles the

00:06:23,659 --> 00:06:28,520
functional programming at me so if you

00:06:26,899 --> 00:06:30,319
drink the kool-aid here's what stuff

00:06:28,520 --> 00:06:32,389
looks like you know this is the left is

00:06:30,319 --> 00:06:35,060
actually kind of it is what Haskell

00:06:32,389 --> 00:06:36,960
libraries have you have a sort function

00:06:35,060 --> 00:06:41,020
its sorts a list

00:06:36,960 --> 00:06:45,759
that equals greater than that's the

00:06:41,020 --> 00:06:47,860
arrow that that tells you things on the

00:06:45,759 --> 00:06:50,590
left that's the constraint so you have a

00:06:47,860 --> 00:06:53,110
Nord if it's ordered well order requires

00:06:50,590 --> 00:06:55,569
that you be able to sort something a

00:06:53,110 --> 00:06:58,180
bully it's a best than or equal to and

00:06:55,569 --> 00:06:59,770
then that of course requires an equality

00:06:58,180 --> 00:07:02,680
thing and you translate that into c plus

00:06:59,770 --> 00:07:07,270
plus you got I hope I got the syntax

00:07:02,680 --> 00:07:13,120
right for that one thank you thank you

00:07:07,270 --> 00:07:15,039
very much so that's it so I one more

00:07:13,120 --> 00:07:16,960
question for you guys was this is well

00:07:15,039 --> 00:07:22,110
known information before I brought it up

00:07:16,960 --> 00:07:24,939
here this is like do any of you guys

00:07:22,110 --> 00:07:41,379
already think of constraints in such a

00:07:24,939 --> 00:07:43,210
way it's good to know so yeah further

00:07:41,379 --> 00:07:45,039
reading if you got done i'll type

00:07:43,210 --> 00:07:46,689
classes as object implicit and it'll is

00:07:45,039 --> 00:07:49,120
it's very good taper martin luther ski

00:07:46,689 --> 00:07:50,710
of course people already like i said

00:07:49,120 --> 00:07:52,810
there's a paper already on comparing

00:07:50,710 --> 00:07:54,879
haskell type classes in generic

00:07:52,810 --> 00:07:57,719
programming in c++ with concepts and

00:07:54,879 --> 00:07:57,719

YouTube URL: https://www.youtube.com/watch?v=y1ir1B6QiE4


