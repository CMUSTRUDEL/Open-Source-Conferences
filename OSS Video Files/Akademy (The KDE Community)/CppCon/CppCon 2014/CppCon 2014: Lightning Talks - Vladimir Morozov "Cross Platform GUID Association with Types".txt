Title: CppCon 2014: Lightning Talks - Vladimir Morozov "Cross Platform GUID Association with Types"
Publication date: 2014-10-23
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Captions: 
	00:00:00,030 --> 00:00:03,780
well had arere is going to show shares

00:00:02,040 --> 00:00:06,170
experience implementing cross-platform

00:00:03,780 --> 00:00:08,040
gooood support in Microsoft Office

00:00:06,170 --> 00:00:10,849
because he's a developer in the

00:00:08,040 --> 00:00:13,830
Microsoft Office core experience team

00:00:10,849 --> 00:00:16,440
okay just for me you can get idea that

00:00:13,830 --> 00:00:21,439
how many people still use Chrome enjoy

00:00:16,440 --> 00:00:26,060
code okay so I guess you're using goods

00:00:21,439 --> 00:00:29,699
so in our office codebase we take we use

00:00:26,060 --> 00:00:32,399
still continue to use Chrome and then we

00:00:29,699 --> 00:00:34,590
talk about so why we're using comma in

00:00:32,399 --> 00:00:36,210
the first place and we want to use kind

00:00:34,590 --> 00:00:38,309
of implement this unknown query

00:00:36,210 --> 00:00:40,410
interface many places and mostly because

00:00:38,309 --> 00:00:43,350
in our office codebase we don't use of

00:00:40,410 --> 00:00:45,210
DTI so using I know I known query

00:00:43,350 --> 00:00:49,050
interface is kind of very

00:00:45,210 --> 00:00:53,610
well-established way to to do them then

00:00:49,050 --> 00:00:55,469
I'm cast and and as you know like visual

00:00:53,610 --> 00:00:56,640
studio supports come from many many

00:00:55,469 --> 00:00:59,820
years we have all these different

00:00:56,640 --> 00:01:02,430
facilities like how to declare good in

00:00:59,820 --> 00:01:03,239
for Chrome how to access it using this

00:01:02,430 --> 00:01:07,200
special grater

00:01:03,239 --> 00:01:09,960
yueji off but for some reason go is not

00:01:07,200 --> 00:01:13,110
supported in standard C++ so when when

00:01:09,960 --> 00:01:14,670
our team moved to come and decide we

00:01:13,110 --> 00:01:16,650
want to share the same codebase across

00:01:14,670 --> 00:01:19,020
multiple platforms who want to have the

00:01:16,650 --> 00:01:21,030
same office code like majority of our

00:01:19,020 --> 00:01:24,750
share of is called work on Android

00:01:21,030 --> 00:01:28,340
platform work on iOS platform the

00:01:24,750 --> 00:01:30,960
question was like how we do goods and I

00:01:28,340 --> 00:01:33,479
pretty much I was not the first person

00:01:30,960 --> 00:01:35,820
who come up with this idea but tinkly is

00:01:33,479 --> 00:01:38,220
what I saw in our code and I I actually

00:01:35,820 --> 00:01:40,170
expanded markers so tinkly yes

00:01:38,220 --> 00:01:43,229
definitely I call this code you will see

00:01:40,170 --> 00:01:44,909
typically it hidden behind markers but

00:01:43,229 --> 00:01:46,979
main idea is like you have interface

00:01:44,909 --> 00:01:50,130
using the visual studio construct called

00:01:46,979 --> 00:01:53,790
echo spec to define your good and some

00:01:50,130 --> 00:01:55,649
well below you need to people typically

00:01:53,790 --> 00:01:58,229
have some kind of template and have

00:01:55,649 --> 00:02:00,090
template specialization and specify for

00:01:58,229 --> 00:02:02,430
this given type I would like to have a

00:02:00,090 --> 00:02:03,689
certain good but we know like our

00:02:02,430 --> 00:02:06,000
template specialization

00:02:03,689 --> 00:02:08,640
must happen in same namespace where

00:02:06,000 --> 00:02:10,440
template is defined so if you type

00:02:08,640 --> 00:02:12,360
happen to be in special namespace

00:02:10,440 --> 00:02:13,980
what these people may do like they just

00:02:12,360 --> 00:02:16,890
simply saying I would like to

00:02:13,980 --> 00:02:18,720
closed namespace first kind of global

00:02:16,890 --> 00:02:21,150
namespace opening space again

00:02:18,720 --> 00:02:23,239
the other solution will be like this GUI

00:02:21,150 --> 00:02:25,620
just simply go to a different file

00:02:23,239 --> 00:02:27,780
altogether but in the end you have

00:02:25,620 --> 00:02:29,190
faculty code application right you have

00:02:27,780 --> 00:02:31,620
the same stuff written multiple places

00:02:29,190 --> 00:02:34,140
in one case you have you good written as

00:02:31,620 --> 00:02:36,930
a string and another case you have just

00:02:34,140 --> 00:02:40,170
a bunch of form I can't read these

00:02:36,930 --> 00:02:42,090
numbers it really kind of bites I ain't

00:02:40,170 --> 00:02:45,030
no human readable I really want my good

00:02:42,090 --> 00:02:47,459
to be kind of string ways to sapphic

00:02:45,030 --> 00:02:52,879
this so this is what I felt about this

00:02:47,459 --> 00:02:55,950
code it's really kind of big and hairy

00:02:52,879 --> 00:02:58,819
so the question is can we do better like

00:02:55,950 --> 00:03:02,959
I saw this code and it was we can't

00:02:58,819 --> 00:03:05,819
really can we do something different and

00:03:02,959 --> 00:03:07,590
I'm coming from kind of many years of

00:03:05,819 --> 00:03:09,450
five C sharp development and this pretty

00:03:07,590 --> 00:03:11,370
much what I want to do and if

00:03:09,450 --> 00:03:14,489
effectively this code compiles in

00:03:11,370 --> 00:03:17,609
visuals to you C++ because visuals to

00:03:14,489 --> 00:03:19,919
C++ has support for middle interfaces

00:03:17,609 --> 00:03:24,540
but the pattern is the same middle thing

00:03:19,919 --> 00:03:26,430
syntax you can use for your types it's

00:03:24,540 --> 00:03:29,340
going to great idea but don't use it

00:03:26,430 --> 00:03:31,260
because what happened what we found that

00:03:29,340 --> 00:03:33,510
it's a big difference between if you

00:03:31,260 --> 00:03:37,049
using this attribute versus vehicle spec

00:03:33,510 --> 00:03:39,660
this attribute to increase your instance

00:03:37,049 --> 00:03:41,970
size by extra pointer and looking this

00:03:39,660 --> 00:03:43,680
point is just zeros I don't know I found

00:03:41,970 --> 00:03:46,950
the black visual students still didn't

00:03:43,680 --> 00:03:48,510
fix it but just don't use it anyway it's

00:03:46,950 --> 00:03:51,000
not standard it will be creative

00:03:48,510 --> 00:03:53,970
standard that adopts it at some point it

00:03:51,000 --> 00:03:55,680
just doesn't work this way so what we

00:03:53,970 --> 00:03:58,950
can do how we can still be kind of

00:03:55,680 --> 00:04:02,849
psychic with this but that we can

00:03:58,950 --> 00:04:06,569
implement today so micro to the rescue

00:04:02,849 --> 00:04:09,329
I know some people don't like markers

00:04:06,569 --> 00:04:10,980
but I believe markers the tool as any

00:04:09,329 --> 00:04:12,750
tool you can help you can overuse it

00:04:10,980 --> 00:04:14,699
like you can have a camera you can smash

00:04:12,750 --> 00:04:18,209
your finger or you can kind of put nail

00:04:14,699 --> 00:04:20,220
to the deck right so it's a tool and I

00:04:18,209 --> 00:04:22,049
think this is a great tool in in this

00:04:20,220 --> 00:04:23,700
context and I believe this is how

00:04:22,049 --> 00:04:25,770
markers should look like

00:04:23,700 --> 00:04:27,610
I changed names a little bit in reality

00:04:25,770 --> 00:04:29,979
it will be like a mess sauce

00:04:27,610 --> 00:04:33,039
but just for the sake of this

00:04:29,979 --> 00:04:35,080
presentation I believe this would it

00:04:33,039 --> 00:04:39,990
might look like so what's important to

00:04:35,080 --> 00:04:42,129
notice here like if you see a wonderful

00:04:39,990 --> 00:04:44,590
approaches see sometimes people do

00:04:42,129 --> 00:04:46,240
they're just heavy smoker and have in

00:04:44,590 --> 00:04:49,720
service markers they have type and we

00:04:46,240 --> 00:04:52,090
have good and ethically is a high

00:04:49,720 --> 00:04:54,669
destructive class inside of the smoker

00:04:52,090 --> 00:04:56,949
what we found is not good idea because

00:04:54,669 --> 00:04:59,740
you have bunch of different tools say

00:04:56,949 --> 00:05:01,270
like Visual Studio or sublime the editor

00:04:59,740 --> 00:05:03,219
or inside of Microsoft we have special

00:05:01,270 --> 00:05:05,680
kind of research tool to index all your

00:05:03,219 --> 00:05:07,300
source code and if you put your class

00:05:05,680 --> 00:05:08,530
name inside of marker you can't find

00:05:07,300 --> 00:05:11,560
your class you can't simply say I'm

00:05:08,530 --> 00:05:14,469
looking for struck blah or struck struck

00:05:11,560 --> 00:05:16,479
fool so it would simply not able to find

00:05:14,469 --> 00:05:19,960
so we would like to have explicit

00:05:16,479 --> 00:05:22,810
keyword struct or class to be kind of

00:05:19,960 --> 00:05:24,759
separated like to be kind of so it can

00:05:22,810 --> 00:05:26,860
be easily found without any facts to

00:05:24,759 --> 00:05:31,240
your tools which use for index in your

00:05:26,860 --> 00:05:33,130
code and but unfortunately we in this

00:05:31,240 --> 00:05:34,930
case marker to define good we need to

00:05:33,130 --> 00:05:38,979
become specific as a strap to class

00:05:34,930 --> 00:05:42,639
because in visual c++ a struct or class

00:05:38,979 --> 00:05:44,590
is actually part of a bi so thankfully

00:05:42,639 --> 00:05:46,990
even according to standard struct in

00:05:44,590 --> 00:05:49,840
class interchangeable but in visual

00:05:46,990 --> 00:05:51,729
studio if you do that and say in one

00:05:49,840 --> 00:05:54,250
case you doing four declaration class

00:05:51,729 --> 00:05:56,349
and of that you really say instruct you

00:05:54,250 --> 00:05:59,319
will have warning level one warning

00:05:56,349 --> 00:06:01,449
because it just doesn't work it works

00:05:59,319 --> 00:06:03,069
probably probably fine in client in any

00:06:01,449 --> 00:06:06,029
other kind of standard compliant

00:06:03,069 --> 00:06:06,029
compilers

00:06:10,330 --> 00:06:17,570
so in reality we need to have two

00:06:13,070 --> 00:06:23,660
markers struck good and close good so

00:06:17,570 --> 00:06:27,710
this is I believe much better so how

00:06:23,660 --> 00:06:30,830
implement this macro visual C++ this

00:06:27,710 --> 00:06:32,570
trivial we just simply kind of say in

00:06:30,830 --> 00:06:35,240
this Marcus just the same deco spec

00:06:32,570 --> 00:06:37,430
vehicle spec what we found this has very

00:06:35,240 --> 00:06:39,199
nice property even you have like for a

00:06:37,430 --> 00:06:41,150
declaration of the class declaration of

00:06:39,199 --> 00:06:42,979
your class or kind of regulation of

00:06:41,150 --> 00:06:45,380
class you can put this deck respect

00:06:42,979 --> 00:06:46,850
anywhere and Visual Studio C++ will

00:06:45,380 --> 00:06:49,760
still picked up and do the right thing

00:06:46,850 --> 00:06:55,070
so it's totally table implementation not

00:06:49,760 --> 00:06:56,690
interesting clamp so yes we I think we

00:06:55,070 --> 00:07:01,010
chose just use client for all other

00:06:56,690 --> 00:07:02,690
comes except windows so there are two

00:07:01,010 --> 00:07:05,900
different techniques we apply here first

00:07:02,690 --> 00:07:09,830
of all in C++ 11 we can simply take a

00:07:05,900 --> 00:07:13,370
string and have a constellation function

00:07:09,830 --> 00:07:15,110
to convert string to do it another thing

00:07:13,370 --> 00:07:17,210
what we do we pretty much just simply

00:07:15,110 --> 00:07:19,700
saying be strap itself it will be

00:07:17,210 --> 00:07:21,950
nothing more just a function definition

00:07:19,700 --> 00:07:25,430
like special cons expression function

00:07:21,950 --> 00:07:31,669
which will take our good and return it

00:07:25,430 --> 00:07:33,740
for a given type and if you see so thank

00:07:31,669 --> 00:07:36,680
you even with this marker does we have a

00:07:33,740 --> 00:07:40,910
four declaration for our struct we say

00:07:36,680 --> 00:07:43,070
this external C++ why because say look

00:07:40,910 --> 00:07:45,440
at some middle generated header files

00:07:43,070 --> 00:07:48,110
and you often find you have the

00:07:45,440 --> 00:07:50,180
interface declaration people put around

00:07:48,110 --> 00:07:53,720
this external sea so the technically

00:07:50,180 --> 00:07:55,130
saying this is C type so if you put this

00:07:53,720 --> 00:07:59,750
motto inside the first C

00:07:55,130 --> 00:08:01,400
context and we can rely on function

00:07:59,750 --> 00:08:03,320
overloading and see there's no support

00:08:01,400 --> 00:08:05,599
function of volume so you to explicitly

00:08:03,320 --> 00:08:09,620
say this function which we declare here

00:08:05,599 --> 00:08:15,289
it will be according to C++ code in

00:08:09,620 --> 00:08:18,590
: convert conventions so we just use

00:08:15,289 --> 00:08:20,449
this function to initialize good field

00:08:18,590 --> 00:08:22,039
so in our code we just using

00:08:20,449 --> 00:08:25,490
I feel because we need to kind of rely

00:08:22,039 --> 00:08:27,830
on some some default implementation for

00:08:25,490 --> 00:08:29,120
sure what I have but I believe these

00:08:27,830 --> 00:08:30,469
things extrude work we just have

00:08:29,120 --> 00:08:33,740
constant expression for where you

00:08:30,469 --> 00:08:36,229
initialize it you I do becomes just a

00:08:33,740 --> 00:08:40,760
matter which returns are filled from the

00:08:36,229 --> 00:08:43,600
good and we also need to think about

00:08:40,760 --> 00:08:46,160
case then say you have a Class A and

00:08:43,600 --> 00:08:49,639
which it has a good on it and now we

00:08:46,160 --> 00:08:52,459
have class be derived from a so if you

00:08:49,639 --> 00:08:54,709
just forget for B it actually may return

00:08:52,459 --> 00:08:57,019
you kind of do it from the base class so

00:08:54,709 --> 00:08:58,550
to avoid this converter tuning good for

00:08:57,019 --> 00:09:01,940
the wrong class we need to have default

00:08:58,550 --> 00:09:03,980
case and we just want a special template

00:09:01,940 --> 00:09:06,860
function which would simply kind of

00:09:03,980 --> 00:09:08,540
throw error I didn't specify it here but

00:09:06,860 --> 00:09:11,149
typically what we do like we have some

00:09:08,540 --> 00:09:12,649
kind of fake template for this type and

00:09:11,149 --> 00:09:15,350
just check in size if it size is zero

00:09:12,649 --> 00:09:17,060
then it's kind of error because if you

00:09:15,350 --> 00:09:18,949
say in like static assert false it would

00:09:17,060 --> 00:09:22,449
fail all the time we need to have some

00:09:18,949 --> 00:09:30,290
kind of condition depending on type so

00:09:22,449 --> 00:09:33,319
any questions you not supposed to read

00:09:30,290 --> 00:09:35,480
it but this kind of put how is

00:09:33,319 --> 00:09:39,709
conversion from string to goo it looks

00:09:35,480 --> 00:09:40,970
like I try different versions I probably

00:09:39,709 --> 00:09:42,800
still don't understand how cons

00:09:40,970 --> 00:09:45,410
expression work because what I found

00:09:42,800 --> 00:09:47,990
like and the debugger even I say constic

00:09:45,410 --> 00:09:50,029
expression I still then I run my code

00:09:47,990 --> 00:09:52,550
somehow like always installation right

00:09:50,029 --> 00:09:55,120
there in my code and if I have a call

00:09:52,550 --> 00:09:58,880
with smart budget with if statements

00:09:55,120 --> 00:10:00,500
taken different character ranges from an

00:09:58,880 --> 00:10:02,120
exception it with something wrong and so

00:10:00,500 --> 00:10:03,500
on you're going to produce me a lot of

00:10:02,120 --> 00:10:05,720
code i kind of was a little bit

00:10:03,500 --> 00:10:07,069
concerned at this in debug mode so thank

00:10:05,720 --> 00:10:08,630
Lee I try to implement simplest

00:10:07,069 --> 00:10:12,350
algorithm which erring foot does just

00:10:08,630 --> 00:10:16,279
takes a character Maps it Maps it to its

00:10:12,350 --> 00:10:22,510
decimal number and just forms a good

00:10:16,279 --> 00:10:25,940
call to them so just repeat we have

00:10:22,510 --> 00:10:31,540
string to do it as a just consecration

00:10:25,940 --> 00:10:34,540
to convert we have get good method

00:10:31,540 --> 00:10:36,490
and we also found some few issues I

00:10:34,540 --> 00:10:38,410
don't know how it can be important in

00:10:36,490 --> 00:10:40,810
your case but just decide to put them in

00:10:38,410 --> 00:10:43,060
the slides it works only for C++ level

00:10:40,810 --> 00:10:45,760
because we rely on cons expressions if

00:10:43,060 --> 00:10:50,170
your code still somewhere using C++ 98

00:10:45,760 --> 00:10:51,370
or C this code will not work and the

00:10:50,170 --> 00:10:54,250
also fans are very interesting

00:10:51,370 --> 00:10:57,730
situations and people use sometimes with

00:10:54,250 --> 00:11:00,190
UID off inside afar there's a template

00:10:57,730 --> 00:11:01,889
parameter it didn't really works but we

00:11:00,190 --> 00:11:05,290
can actually do very simple workaround

00:11:01,889 --> 00:11:08,620
just factory define special resolve good

00:11:05,290 --> 00:11:11,260
PR struggling about specialization if

00:11:08,620 --> 00:11:12,579
for example this PTR is now not now so

00:11:11,260 --> 00:11:16,829
we can actually do it Jone just

00:11:12,579 --> 00:11:19,690
different things but again it was

00:11:16,829 --> 00:11:22,149
indicate specific linker error if the

00:11:19,690 --> 00:11:24,670
same code works just fine on is or like

00:11:22,149 --> 00:11:27,190
mark it's just something like seems like

00:11:24,670 --> 00:11:32,500
NDK has some kind of eager optimization

00:11:27,190 --> 00:11:35,290
just somehow kimye's I saw this code so

00:11:32,500 --> 00:11:38,529
what I think we have a pretty good

00:11:35,290 --> 00:11:40,779
solution for this cross-platform story

00:11:38,529 --> 00:11:42,430
for goods but I think the similar

00:11:40,779 --> 00:11:44,560
technique can be applied for any type of

00:11:42,430 --> 00:11:47,680
other custom templates which you may

00:11:44,560 --> 00:11:49,600
have in your code so imagine that today

00:11:47,680 --> 00:11:51,339
is pretty easy you can have just kind of

00:11:49,600 --> 00:11:52,839
some type source of shade before

00:11:51,339 --> 00:11:55,269
yo types and you can do all this

00:11:52,839 --> 00:11:56,649
different interesting and template magic

00:11:55,269 --> 00:11:58,899
but what if you want to associate on

00:11:56,649 --> 00:12:00,790
some values will calculate something

00:11:58,899 --> 00:12:02,260
along the lines so a similar technique

00:12:00,790 --> 00:12:03,880
can be applied here you just define some

00:12:02,260 --> 00:12:05,889
kind of marker marker it will be

00:12:03,880 --> 00:12:08,860
expanded to function and you have just

00:12:05,889 --> 00:12:10,510
some kind of special type type traits to

00:12:08,860 --> 00:12:12,760
access this value you just initialize

00:12:10,510 --> 00:12:17,790
this value from this function have some

00:12:12,760 --> 00:12:17,790
default case and you don't thank you

00:12:19,660 --> 00:12:21,720

YouTube URL: https://www.youtube.com/watch?v=kfHCoTSetmo


