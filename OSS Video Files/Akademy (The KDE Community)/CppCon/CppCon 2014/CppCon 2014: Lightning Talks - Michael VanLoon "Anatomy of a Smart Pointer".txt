Title: CppCon 2014: Lightning Talks - Michael VanLoon "Anatomy of a Smart Pointer"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
I have been developing software for roughly 30 years. Yes, I started before I was born. I have been doing C++ for roughly 20 years, not very well at first, and slightly better now.

I work at F5 Networks, and have worked at Disney, VMware, Yahoo!, and Microsoft, among many others. I have benefited from a wide range of experience and personalities.

I have a personal grudge against code that does not strive to reach a high standard. I am dismayed at code that does not reach its potential. And I firmly believe that writing code well creates a better, more stable, more maintainable product.
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,870
we have Michael Van Loon was going to be

00:00:02,250 --> 00:00:07,710
five and his instead asked me for ten

00:00:03,870 --> 00:00:09,450
because he wants to add to your store of

00:00:07,710 --> 00:00:17,550
arcane and useless knowledge by sharing

00:00:09,450 --> 00:00:22,740
how smart pointer sausage is made all

00:00:17,550 --> 00:00:25,740
right I'm not really but as anybody

00:00:22,740 --> 00:00:28,519
who's worn the button can attest they

00:00:25,740 --> 00:00:31,790
aren't really a doctor

00:00:28,519 --> 00:00:35,190
so yes what do we want to know about

00:00:31,790 --> 00:00:36,930
arcane and useless knowledge because

00:00:35,190 --> 00:00:37,950
it's early in the morning we probably

00:00:36,930 --> 00:00:41,730
haven't had enough coffee

00:00:37,950 --> 00:00:43,950
so what's a smart pointer most you guys

00:00:41,730 --> 00:00:46,020
probably know most of this stuff but for

00:00:43,950 --> 00:00:48,510
those who need a refresher or maybe want

00:00:46,020 --> 00:00:52,020
to know a little bit more the basics are

00:00:48,510 --> 00:00:54,600
it's a container it holds a pointer

00:00:52,020 --> 00:00:57,390
pretty basic but the cool thing is that

00:00:54,600 --> 00:00:59,789
it facilitates our III which means that

00:00:57,390 --> 00:01:04,619
of course it constructs with reasonable

00:00:59,789 --> 00:01:07,680
defaults you don't have a pointer that's

00:01:04,619 --> 00:01:09,360
holding some random value that may look

00:01:07,680 --> 00:01:11,640
like memory because you forgot to

00:01:09,360 --> 00:01:13,920
initialize it it also even more

00:01:11,640 --> 00:01:15,570
importantly cleans itself up when it's

00:01:13,920 --> 00:01:17,189
time to do that there's various ways

00:01:15,570 --> 00:01:21,210
that they might do that and we're going

00:01:17,189 --> 00:01:23,100
to talk about those and it may convey

00:01:21,210 --> 00:01:24,810
some interface semantics which is nice

00:01:23,100 --> 00:01:28,380
if you have a unique pointer obviously

00:01:24,810 --> 00:01:30,659
it's unique you can't share it and so

00:01:28,380 --> 00:01:32,159
it's it's good if that's clear in your

00:01:30,659 --> 00:01:34,280
interface if you have a shared pointer

00:01:32,159 --> 00:01:36,990
it implies you're sharing the pointer

00:01:34,280 --> 00:01:39,540
it's a proxy which means that you can

00:01:36,990 --> 00:01:41,430
use it in place of the pointer in in

00:01:39,540 --> 00:01:45,720
many circumstances that's kind of the

00:01:41,430 --> 00:01:47,369
whole point so some examples out of

00:01:45,720 --> 00:01:50,070
pointers go pointer unique pointer

00:01:47,369 --> 00:01:52,950
shared pointer weak pointer a couple of

00:01:50,070 --> 00:01:55,049
commoners there are many others of

00:01:52,950 --> 00:01:56,700
course these are generic smart pointers

00:01:55,049 --> 00:01:58,860
they're whole the whole pointers is just

00:01:56,700 --> 00:02:03,090
about any type there are main

00:01:58,860 --> 00:02:04,920
domain-specific smart pointers smart

00:02:03,090 --> 00:02:06,000
pointer we're kind of abusing the term a

00:02:04,920 --> 00:02:09,330
little bit here they're really smart

00:02:06,000 --> 00:02:11,879
containers string is one it it contains

00:02:09,330 --> 00:02:12,569
your string properly it D allocates it

00:02:11,879 --> 00:02:14,640
when

00:02:12,569 --> 00:02:18,299
using it it has reasonable

00:02:14,640 --> 00:02:20,909
initialization defaults Windows has some

00:02:18,299 --> 00:02:23,129
beasts turkey variant T is a cool one

00:02:20,909 --> 00:02:27,329
because it's this variant type and knows

00:02:23,129 --> 00:02:29,989
how to properly contain and manage it so

00:02:27,329 --> 00:02:33,989
different kinds of reference counting

00:02:29,989 --> 00:02:35,609
well there's I use object based

00:02:33,989 --> 00:02:37,950
reference counting and container based

00:02:35,609 --> 00:02:40,620
reference counting as my terms because I

00:02:37,950 --> 00:02:43,049
like them better than intrusive is one

00:02:40,620 --> 00:02:45,239
that boost likes to use it's been used

00:02:43,049 --> 00:02:46,620
in other places too object based

00:02:45,239 --> 00:02:49,439
reference count means the count is

00:02:46,620 --> 00:02:51,959
stored in the object this is similar to

00:02:49,439 --> 00:02:55,010
the the calm model the Microsoft uses a

00:02:51,959 --> 00:02:57,780
lot it's been around forever and ever I

00:02:55,010 --> 00:02:59,549
don't like the term intrusive because

00:02:57,780 --> 00:03:01,620
obviously we're doing this with the

00:02:59,549 --> 00:03:04,019
cooperation of the object it was an

00:03:01,620 --> 00:03:06,599
intentional interface design so we're

00:03:04,019 --> 00:03:08,699
not really intruding on it we're doing

00:03:06,599 --> 00:03:11,609
it in cooperation but the fact that

00:03:08,699 --> 00:03:13,049
we're calling the object and asking it

00:03:11,609 --> 00:03:14,449
to do things with its reference is why

00:03:13,049 --> 00:03:16,469
it's called him true serve and of course

00:03:14,449 --> 00:03:18,209
container based reference counting is

00:03:16,469 --> 00:03:21,659
the share pointer style we're all

00:03:18,209 --> 00:03:23,280
familiar with hopefully the object based

00:03:21,659 --> 00:03:26,699
reference counting model has the

00:03:23,280 --> 00:03:28,590
advantage that it's the smart pointer

00:03:26,699 --> 00:03:30,870
logic is very simple the smart pointer

00:03:28,590 --> 00:03:32,819
for an or one of these is basically just

00:03:30,870 --> 00:03:34,319
an ref and delete or add breath and

00:03:32,819 --> 00:03:37,109
release or whatever you want to call the

00:03:34,319 --> 00:03:40,079
interface I won't go over everything

00:03:37,109 --> 00:03:42,930
because we don't have that much time but

00:03:40,079 --> 00:03:45,299
basically it can it can add a little bit

00:03:42,930 --> 00:03:49,169
of complexity object but the smart

00:03:45,299 --> 00:03:51,389
pointer container is simpler also it's

00:03:49,169 --> 00:03:53,549
easier to pass through say C interfaces

00:03:51,389 --> 00:03:55,229
because you can pass around the raw

00:03:53,549 --> 00:03:57,449
pointers and you're still calling the

00:03:55,229 --> 00:03:59,250
address and release on the pointer

00:03:57,449 --> 00:04:03,269
you're not having to manage it whereas

00:03:59,250 --> 00:04:07,439
with a shared pointer we need to of

00:04:03,269 --> 00:04:09,019
course with exceptions make sure that we

00:04:07,439 --> 00:04:11,250
pass around the shared pointers

00:04:09,019 --> 00:04:13,259
themselves because they have to know

00:04:11,250 --> 00:04:17,389
about each other since they share a

00:04:13,259 --> 00:04:17,389
common a common theme

00:04:17,400 --> 00:04:21,840
so how it works algae-based reference

00:04:20,549 --> 00:04:24,810
counting that's about all I'm going to

00:04:21,840 --> 00:04:28,889
talk about because you know it's it's

00:04:24,810 --> 00:04:31,860
not the common case Auto pointer one of

00:04:28,889 --> 00:04:34,710
the original smart pointers it contains

00:04:31,860 --> 00:04:37,979
a raw pointer and an ownership flag the

00:04:34,710 --> 00:04:41,790
ownership is transferred to the the last

00:04:37,979 --> 00:04:43,350
guy basically who got the pointer which

00:04:41,790 --> 00:04:45,750
means it's problematic so maybe that's

00:04:43,350 --> 00:04:47,910
not the guy who should be destroying the

00:04:45,750 --> 00:04:50,460
thing and so it's deprecated cause we

00:04:47,910 --> 00:04:52,020
have better stuff now scope point of

00:04:50,460 --> 00:04:55,139
unique pointer scope pointer is a boost

00:04:52,020 --> 00:04:57,169
thing unique pointers is C++ 11 pointer

00:04:55,139 --> 00:04:59,250
that's an improvement on scope pointer

00:04:57,169 --> 00:05:02,160
does not allow transfer of ownership

00:04:59,250 --> 00:05:05,750
obviously scoped and unique that's

00:05:02,160 --> 00:05:08,729
intentional it makes it much simpler and

00:05:05,750 --> 00:05:10,530
makes it more efficient also

00:05:08,729 --> 00:05:14,250
conveyancing the internet interface

00:05:10,530 --> 00:05:15,840
semantics that it's unique right the

00:05:14,250 --> 00:05:17,760
unique pointer off also has the the

00:05:15,840 --> 00:05:19,740
option of having a custom deleter

00:05:17,760 --> 00:05:22,830
which is a function that you can pass in

00:05:19,740 --> 00:05:24,840
that says when it's time to destroy this

00:05:22,830 --> 00:05:27,810
thing instead of calling delete I want

00:05:24,840 --> 00:05:30,360
you to do this which is a nice way to

00:05:27,810 --> 00:05:31,530
clean up resources somebody I don't

00:05:30,360 --> 00:05:33,599
remember maybe was Bernie

00:05:31,530 --> 00:05:36,300
yesterday was talking about well what if

00:05:33,599 --> 00:05:37,979
you're using malloc well here's a good

00:05:36,300 --> 00:05:39,990
way you use accustomed to leader that

00:05:37,979 --> 00:05:48,440
does free instead of delete

00:05:39,990 --> 00:05:50,370
yeah okay thanks so shared pointer I

00:05:48,440 --> 00:05:51,870
think most of us are familiar with

00:05:50,370 --> 00:05:53,699
shared pointer but basically it's a

00:05:51,870 --> 00:05:56,760
reference counted container that

00:05:53,699 --> 00:05:58,080
contains your pointer and hopefully if

00:05:56,760 --> 00:06:00,990
you're using it properly

00:05:58,080 --> 00:06:03,030
the last user of it is the one who

00:06:00,990 --> 00:06:06,930
releases the the last reference and

00:06:03,030 --> 00:06:08,460
everything goes out of scope so I don't

00:06:06,930 --> 00:06:10,440
have a laser pointer I'm going to use my

00:06:08,460 --> 00:06:14,039
mouse so hopefully it's accurate enough

00:06:10,440 --> 00:06:15,690
and I of course didn't have time to make

00:06:14,039 --> 00:06:17,960
these slides even more fancy and

00:06:15,690 --> 00:06:21,660
detailed so we're doing it this way

00:06:17,960 --> 00:06:24,180
shared pointer basically is is a a

00:06:21,660 --> 00:06:25,890
complex design where you have your

00:06:24,180 --> 00:06:29,190
shared pointer the thing that you've

00:06:25,890 --> 00:06:31,320
declared and it is a share pointer to a

00:06:29,190 --> 00:06:33,840
type internally it contain

00:06:31,320 --> 00:06:36,270
now this is a logical representation

00:06:33,840 --> 00:06:37,980
this isn't how its implemented in every

00:06:36,270 --> 00:06:40,650
compiler obviously there there's some

00:06:37,980 --> 00:06:43,070
some differences but this just gives you

00:06:40,650 --> 00:06:45,660
an idea of how to put together logically

00:06:43,070 --> 00:06:48,960
there's a pointer to the thing that

00:06:45,660 --> 00:06:53,220
you're containing obviously and there's

00:06:48,960 --> 00:06:54,990
also a corner to a reference count

00:06:53,220 --> 00:06:56,430
container and this is the thing that's

00:06:54,990 --> 00:06:58,770
shared among all the shared pointers now

00:06:56,430 --> 00:07:01,860
if I were to say take share pointer p1

00:06:58,770 --> 00:07:05,780
and create a shared pointer P to that is

00:07:01,860 --> 00:07:07,680
a sign from p1 they are going to contain

00:07:05,780 --> 00:07:09,660
references to the same reference count

00:07:07,680 --> 00:07:10,950
container and inside here there's a

00:07:09,660 --> 00:07:14,340
strong reference count a weak reference

00:07:10,950 --> 00:07:15,570
count eighty pointer and the leader the

00:07:14,340 --> 00:07:17,670
strong reference count is going to go

00:07:15,570 --> 00:07:21,180
from one to two because now we have two

00:07:17,670 --> 00:07:23,160
references to this thing inside here we

00:07:21,180 --> 00:07:26,040
also of course have a pointer to T and

00:07:23,160 --> 00:07:27,540
our deleter why do we have a pointer

00:07:26,040 --> 00:07:30,360
here and a pointer here I know that's a

00:07:27,540 --> 00:07:31,770
question obviously you need it here

00:07:30,360 --> 00:07:33,600
because if you have a deleter function

00:07:31,770 --> 00:07:35,010
well even if you know I'm to leave it

00:07:33,600 --> 00:07:36,090
fine if you're using delete you still

00:07:35,010 --> 00:07:38,910
need to have the pointer so you can

00:07:36,090 --> 00:07:40,620
delete it right but do we really want it

00:07:38,910 --> 00:07:44,190
do you reference a pointer every time we

00:07:40,620 --> 00:07:45,750
need the answer to give me my pointer no

00:07:44,190 --> 00:07:47,670
it's much more efficient if we can just

00:07:45,750 --> 00:07:50,370
pull it straight out of here but we can

00:07:47,670 --> 00:07:52,320
also do cool tricks like a dynamic cast

00:07:50,370 --> 00:07:54,360
to a related type and get a shared

00:07:52,320 --> 00:07:57,060
pointer back to that say t2 is derived

00:07:54,360 --> 00:08:02,340
from T and we want a shared pointer to

00:07:57,060 --> 00:08:04,470
t2 from p1 or p2 we can do that inside

00:08:02,340 --> 00:08:06,570
here we're going to get a container that

00:08:04,470 --> 00:08:10,110
has a t2 pointer and a reference to the

00:08:06,570 --> 00:08:15,060
same block because obviously they refer

00:08:10,110 --> 00:08:18,510
the same object cool stuff we can do an

00:08:15,060 --> 00:08:20,220
optimization that we can make because

00:08:18,510 --> 00:08:22,950
when you're using these kind of

00:08:20,220 --> 00:08:27,570
paradigms it's really nice to not have

00:08:22,950 --> 00:08:29,400
to explicitly ever use delete or new the

00:08:27,570 --> 00:08:30,780
share pointer itself of course makes it

00:08:29,400 --> 00:08:34,590
so that we don't have to use delete

00:08:30,780 --> 00:08:36,210
which is nice how can we avoid using new

00:08:34,590 --> 00:08:40,620
well there's this thing called make sure

00:08:36,210 --> 00:08:42,210
and one effect is that it does the new

00:08:40,620 --> 00:08:44,910
for you

00:08:42,210 --> 00:08:45,570
the other cool thing is it can be a

00:08:44,910 --> 00:08:48,240
little bit more

00:08:45,570 --> 00:08:51,360
Damone the reason why is it's capable of

00:08:48,240 --> 00:08:54,780
most I should say many of them

00:08:51,360 --> 00:08:56,850
implementations can allocate the shared

00:08:54,780 --> 00:08:58,410
pointer and the reference block all in

00:08:56,850 --> 00:09:01,980
one memory allocation a little more

00:08:58,410 --> 00:09:03,990
efficient Chandler will like this even

00:09:01,980 --> 00:09:06,150
though it's you know got links and

00:09:03,990 --> 00:09:10,050
things because this is one block more

00:09:06,150 --> 00:09:11,300
cache locality he gets picked on a lot

00:09:10,050 --> 00:09:15,900
doesn't he

00:09:11,300 --> 00:09:18,090
the cool thing is so it's it's it's a

00:09:15,900 --> 00:09:22,700
little bit more compact it's a little

00:09:18,090 --> 00:09:22,700
more efficient and it's also capable of

00:09:23,510 --> 00:09:28,620
I was going to say something but now

00:09:26,100 --> 00:09:31,530
it's put on my head so anyway the the

00:09:28,620 --> 00:09:33,720
rest of it works the same way as the the

00:09:31,530 --> 00:09:35,160
other shared pointer of course since

00:09:33,720 --> 00:09:37,080
it's all allocated here there's a little

00:09:35,160 --> 00:09:42,450
bit more complex about deleting the last

00:09:37,080 --> 00:09:46,620
reference but it all works enabled share

00:09:42,450 --> 00:09:48,810
from this has a cool feature it's a cool

00:09:46,620 --> 00:09:49,980
feature that we have as well because one

00:09:48,810 --> 00:09:51,420
of the things that I saw is weakness

00:09:49,980 --> 00:09:53,220
with share pointers that you can't

00:09:51,420 --> 00:09:54,810
really pass the raw pointer around and

00:09:53,220 --> 00:09:56,330
then you get another shared pointer from

00:09:54,810 --> 00:09:58,590
it unless you do something like this

00:09:56,330 --> 00:10:01,440
enabled share from this as a class that

00:09:58,590 --> 00:10:03,930
you can derive from and it makes your

00:10:01,440 --> 00:10:06,300
object aware of its shared pointer the

00:10:03,930 --> 00:10:09,870
reference count block and the way that

00:10:06,300 --> 00:10:11,430
it does that is there's some magic

00:10:09,870 --> 00:10:14,790
inside enabled share from this that

00:10:11,430 --> 00:10:17,580
takes the so this is my object of an a

00:10:14,790 --> 00:10:18,990
drive from an able chair from this it

00:10:17,580 --> 00:10:21,000
requires that somebody's created a

00:10:18,990 --> 00:10:23,130
shared pointer first to your object and

00:10:21,000 --> 00:10:24,240
so maybe you've done a make sure well in

00:10:23,130 --> 00:10:25,620
this case you haven't because we don't

00:10:24,240 --> 00:10:27,510
have the block embedded but say you've

00:10:25,620 --> 00:10:29,190
created your object with and you've put

00:10:27,510 --> 00:10:33,000
it in a shared pointer now there is a

00:10:29,190 --> 00:10:36,240
shared pointer block if I ask say I get

00:10:33,000 --> 00:10:40,110
the raw pointer and I ask my object for

00:10:36,240 --> 00:10:43,830
another shared pointer it can use the

00:10:40,110 --> 00:10:46,140
knowledge of this this link here and

00:10:43,830 --> 00:10:49,880
give me back a new shared pointer that

00:10:46,140 --> 00:10:53,329
knows about the shared reference and

00:10:49,880 --> 00:10:55,550
do the right thing and that's kind of

00:10:53,329 --> 00:10:59,509
how that stuff's all glued together I'm

00:10:55,550 --> 00:11:01,880
20 seconds over so my summary is use

00:10:59,509 --> 00:11:03,649
smart pointers they're the right way to

00:11:01,880 --> 00:11:05,360
do things to avoid news and deletes

00:11:03,649 --> 00:11:07,550
prefer unique pointer it's more

00:11:05,360 --> 00:11:09,829
efficient your shared pointer if you

00:11:07,550 --> 00:11:12,259
have to use make sure to be more

00:11:09,829 --> 00:11:14,000
efficient consider the object based

00:11:12,259 --> 00:11:16,600
reference hunting model if fits your

00:11:14,000 --> 00:11:16,600

YouTube URL: https://www.youtube.com/watch?v=bxaj_0o4XAI


