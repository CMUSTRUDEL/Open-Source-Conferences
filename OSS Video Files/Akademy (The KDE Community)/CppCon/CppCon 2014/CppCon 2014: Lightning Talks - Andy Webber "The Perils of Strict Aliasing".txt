Title: CppCon 2014: Lightning Talks - Andy Webber "The Perils of Strict Aliasing"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://www.cppcon.org
â€”
Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Andrew Webber, Technologist, SIG
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,000 --> 00:00:04,770
Andy Weber has been enthusiastically

00:00:03,030 --> 00:00:06,180
developing in C++ for the defense and

00:00:04,770 --> 00:00:08,760
financial industries for the last 10

00:00:06,180 --> 00:00:10,200
years it's going to spend the next five

00:00:08,760 --> 00:00:18,990
minutes explaining why you should be

00:00:10,200 --> 00:00:20,670
terrified of strict aliasing okay we'll

00:00:18,990 --> 00:00:22,619
go for it you may be may be scared

00:00:20,670 --> 00:00:30,599
and the essential keys to avoid

00:00:22,619 --> 00:00:34,140
violating it good this is my first

00:00:30,599 --> 00:00:38,070
lightning talk so forgive me if it's

00:00:34,140 --> 00:00:41,309
terrible so strictly saying I'd like to

00:00:38,070 --> 00:00:44,460
talk about it my name is Amy Weber it's

00:00:41,309 --> 00:00:47,370
a subject that I've learned a lot about

00:00:44,460 --> 00:00:49,620
lately if you have questions please ask

00:00:47,370 --> 00:00:50,940
me afterward if you completely disagree

00:00:49,620 --> 00:00:52,440
with me tell me afterward because I

00:00:50,940 --> 00:00:54,480
would like to know because I want to

00:00:52,440 --> 00:00:56,460
compile the best information about this

00:00:54,480 --> 00:00:58,199
and get it out to the public it's a

00:00:56,460 --> 00:01:01,320
subject I think a lot of people don't

00:00:58,199 --> 00:01:03,000
know about and it it scared me when I

00:01:01,320 --> 00:01:03,409
learned about it so maybe it'll scare

00:01:03,000 --> 00:01:08,070
you

00:01:03,409 --> 00:01:11,520
so don't break the rules what are the

00:01:08,070 --> 00:01:14,580
rules this is three 10.10 from standard

00:01:11,520 --> 00:01:16,710
the C rules are basically the same what

00:01:14,580 --> 00:01:22,369
this says is that you can access the

00:01:16,710 --> 00:01:25,200
stored value of memory through the

00:01:22,369 --> 00:01:28,229
dynamic type of the value not sure what

00:01:25,200 --> 00:01:30,990
happened to the monitor over there so

00:01:28,229 --> 00:01:33,500
the dynamic type of the value or a care

00:01:30,990 --> 00:01:36,360
or unsigned care type otherwise

00:01:33,500 --> 00:01:40,979
undefined behavior which as we all know

00:01:36,360 --> 00:01:44,939
is very bad okay does this work

00:01:40,979 --> 00:01:46,560
this code takes a UN 32 we want to swap

00:01:44,939 --> 00:01:48,210
the two halves of it this is kind of

00:01:46,560 --> 00:01:49,649
low-level C code you might have

00:01:48,210 --> 00:01:53,310
something like this in your code base so

00:01:49,649 --> 00:01:56,040
we take a pointer to a UN 16 and we swap

00:01:53,310 --> 00:02:00,810
the two sides of it the the two array

00:01:56,040 --> 00:02:02,939
pieces this does not work or it's not

00:02:00,810 --> 00:02:05,280
guaranteed to work because we are

00:02:02,939 --> 00:02:08,399
aliasing the 32 bit value through a

00:02:05,280 --> 00:02:10,890
16-bit value that's not a 32-bit value

00:02:08,399 --> 00:02:12,990
and 32 and it's not a care not

00:02:10,890 --> 00:02:15,550
guaranteed to work

00:02:12,990 --> 00:02:17,440
some people try to get clever you might

00:02:15,550 --> 00:02:20,290
have heard that you can use a union to

00:02:17,440 --> 00:02:23,080
do this so let's take a union you in 32

00:02:20,290 --> 00:02:23,650
and in this case it's an N 16 but it

00:02:23,080 --> 00:02:27,700
doesn't matter

00:02:23,650 --> 00:02:30,670
so in 16 size to array we reinterpret

00:02:27,700 --> 00:02:32,590
casts our 32-bit value to a pointer to

00:02:30,670 --> 00:02:39,010
that and we do it through the Union

00:02:32,590 --> 00:02:41,350
that's it work right no so let's take a

00:02:39,010 --> 00:02:43,270
different Union well actually it's the

00:02:41,350 --> 00:02:45,700
same Union we're gonna take the same

00:02:43,270 --> 00:02:47,410
Union and in this case it's it's a union

00:02:45,700 --> 00:02:49,960
of values of the types that we care

00:02:47,410 --> 00:02:52,330
about but we're gonna have essentially a

00:02:49,960 --> 00:02:55,600
value of the Union and we're going to

00:02:52,330 --> 00:02:57,100
copy into one side of it and copy out of

00:02:55,600 --> 00:03:01,960
the other side of it slightly different

00:02:57,100 --> 00:03:04,210
example this case does work or is

00:03:01,960 --> 00:03:08,860
guaranteed to work but only on GCC

00:03:04,210 --> 00:03:12,430
because it's a GCC extension to type on

00:03:08,860 --> 00:03:14,530
through unions but only in this very

00:03:12,430 --> 00:03:18,040
special case where you copy in and out

00:03:14,530 --> 00:03:24,100
of it a lot of people think that it's C

00:03:18,040 --> 00:03:26,560
99 but it's not so GCC also has a may

00:03:24,100 --> 00:03:28,720
alias attribute which basically says I

00:03:26,560 --> 00:03:31,810
know what I'm doing I want this thing to

00:03:28,720 --> 00:03:34,930
be able to alias anything else and in

00:03:31,810 --> 00:03:39,670
GCC's case so we basically make a type

00:03:34,930 --> 00:03:42,280
def - am a alias UN 16 T and if we cast

00:03:39,670 --> 00:03:44,140
through that GCC says that that this

00:03:42,280 --> 00:03:46,000
will work although getting this right is

00:03:44,140 --> 00:03:53,110
a little bit tricky and of course it's

00:03:46,000 --> 00:03:57,640
not portable so what do we have left

00:03:53,110 --> 00:04:01,269
we can just not do this by using F no

00:03:57,640 --> 00:04:04,030
strict a leasing on GCC and clang Visual

00:04:01,269 --> 00:04:06,190
Studio I believe doesn't have this

00:04:04,030 --> 00:04:07,690
aliasing problem as much but it's of

00:04:06,190 --> 00:04:10,959
course not guaranteed they can just

00:04:07,690 --> 00:04:13,600
change it at any time in any version so

00:04:10,959 --> 00:04:16,900
we reinterpret cast it works because

00:04:13,600 --> 00:04:20,830
we've turned T be AAA off which is type

00:04:16,900 --> 00:04:23,370
based aliasing information and this this

00:04:20,830 --> 00:04:23,370
does work

00:04:25,420 --> 00:04:32,270
so or this is what the Committee says

00:04:28,520 --> 00:04:35,990
they says they say use mem copy which is

00:04:32,270 --> 00:04:37,700
is the code is much less friendly but

00:04:35,990 --> 00:04:39,980
we're basically casting to a care

00:04:37,700 --> 00:04:42,260
pointer and copying through mem copy why

00:04:39,980 --> 00:04:45,170
does this work if you notice mem copy

00:04:42,260 --> 00:04:46,850
has void or care pointers as the

00:04:45,170 --> 00:04:49,100
arguments you're always allowed to view

00:04:46,850 --> 00:04:51,050
your memory as bytes because that's the

00:04:49,100 --> 00:04:51,590
way that the OS works read/write mm

00:04:51,050 --> 00:04:56,050
coffee

00:04:51,590 --> 00:04:58,670
mem set so so this is guaranteed to work

00:04:56,050 --> 00:05:03,740
because we're a leasing through care

00:04:58,670 --> 00:05:05,420
pointers so this kind of code you may

00:05:03,740 --> 00:05:09,100
have seen it all over the place low

00:05:05,420 --> 00:05:11,000
level code especially network libraries

00:05:09,100 --> 00:05:12,800
serialization deserialization

00:05:11,000 --> 00:05:15,080
current modern code that's being

00:05:12,800 --> 00:05:18,500
produced definitely has this problem in

00:05:15,080 --> 00:05:23,390
the wild including market data from

00:05:18,500 --> 00:05:26,110
certain exchanges there's s no strict

00:05:23,390 --> 00:05:28,490
aliasing the Linux kernel turns it off

00:05:26,110 --> 00:05:31,400
Linus has choice words about this

00:05:28,490 --> 00:05:33,640
optimization live event some other

00:05:31,400 --> 00:05:36,310
libraries I'm sure also turn it off but

00:05:33,640 --> 00:05:39,350
we have seen real-world performance

00:05:36,310 --> 00:05:40,910
losses when you turn it off so it's kind

00:05:39,350 --> 00:05:44,330
of unfortunate

00:05:40,910 --> 00:05:46,490
I asked GCC help and I got in conclusive

00:05:44,330 --> 00:05:48,980
answers about whether or not placement

00:05:46,490 --> 00:05:51,560
knew would actually do what you wanted

00:05:48,980 --> 00:05:54,620
to do here and just this morning I heard

00:05:51,560 --> 00:05:58,190
from Jason Merrill that he asked the C

00:05:54,620 --> 00:06:00,470
the C++ sent core standards mailing list

00:05:58,190 --> 00:06:01,940
and they said the value of the thing

00:06:00,470 --> 00:06:04,040
after the placement new is indeterminate

00:06:01,940 --> 00:06:06,740
so note no type hunting through

00:06:04,040 --> 00:06:10,810
placement new so why don't we have alias

00:06:06,740 --> 00:06:14,870
cast well it would work only on systems

00:06:10,810 --> 00:06:18,380
that allow non-aligned memory access and

00:06:14,870 --> 00:06:20,390
that's x86 and new arms which is a lot

00:06:18,380 --> 00:06:24,710
of the world so maybe we could have this

00:06:20,390 --> 00:06:26,830
but we don't right now so be aware thank

00:06:24,710 --> 00:06:26,830

YouTube URL: https://www.youtube.com/watch?v=Jd8MI4b_AUc


