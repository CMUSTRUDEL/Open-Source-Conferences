Title: CppCon 2014: Lightning Talks - Jeff Trull "Rolling Your Own Circuit Simulator"
Publication date: 2014-10-22
Playlist: CppCon 2014
Description: 
	http://cppcon2014.sched.org

Presentation Slides, PDFs, Source Code and other presenter materials are available at: https://github.com/CppCon/CppCon2014
--
Videos Filmed & Edited by Bash Films: http://www.BashFilms.com
Captions: 
	00:00:00,030 --> 00:00:03,090
next we have Jeff troll where are you

00:00:02,760 --> 00:00:06,210
sitting

00:00:03,090 --> 00:00:08,250
there you go a former microprocessor

00:00:06,210 --> 00:00:10,019
design engineer and now a C++ consultant

00:00:08,250 --> 00:00:12,769
who sometimes misses the days when he

00:00:10,019 --> 00:00:15,179
needed a microscope to see his work and

00:00:12,769 --> 00:00:17,010
this is an intriguing title rolling your

00:00:15,179 --> 00:00:22,710
own circuit simulator with eigen and

00:00:17,010 --> 00:00:28,140
busto de int so in 15 minutes a circuit

00:00:22,710 --> 00:00:29,820
simulator sure we can do that okay so

00:00:28,140 --> 00:00:31,859
historically computer-aided design

00:00:29,820 --> 00:00:33,510
programs had this sort of thick layer of

00:00:31,859 --> 00:00:35,520
infrastructure in the bottom of them

00:00:33,510 --> 00:00:39,989
that were things like you know graph

00:00:35,520 --> 00:00:41,730
algorithms or linear algebra or numerix

00:00:39,989 --> 00:00:44,399
or parsers or stuff like that

00:00:41,730 --> 00:00:46,110
and these are a lot of things that sort

00:00:44,399 --> 00:00:47,850
of look like general-purpose libraries

00:00:46,110 --> 00:00:49,260
but back then when these programs were

00:00:47,850 --> 00:00:52,410
started which is sometimes a really long

00:00:49,260 --> 00:00:54,690
time ago the people involved were like

00:00:52,410 --> 00:00:56,969
they tended to be like XC programmers

00:00:54,690 --> 00:00:58,320
and that also sometimes even like the

00:00:56,969 --> 00:01:00,329
standard library wasn't always that

00:00:58,320 --> 00:01:01,620
reliable and stuff like that so you've

00:01:00,329 --> 00:01:04,949
got all this stuff that's kind of like

00:01:01,620 --> 00:01:07,530
internally invented code but time as

00:01:04,949 --> 00:01:09,720
times have changed and there's a lot of

00:01:07,530 --> 00:01:13,470
good stuff out there for doing

00:01:09,720 --> 00:01:15,840
engineering work and I think that in the

00:01:13,470 --> 00:01:17,759
in the EDA and the CAD world we need to

00:01:15,840 --> 00:01:19,950
start thinking about using some of these

00:01:17,759 --> 00:01:22,229
libraries that are available now so that

00:01:19,950 --> 00:01:23,970
we can focus instead of this this all

00:01:22,229 --> 00:01:27,420
this sort of legacy code that we're

00:01:23,970 --> 00:01:29,729
maintaining focus instead on addressing

00:01:27,420 --> 00:01:32,250
our problem area and and focusing on our

00:01:29,729 --> 00:01:34,650
core competency instead and so I'm going

00:01:32,250 --> 00:01:38,369
to give a motivating example which is

00:01:34,650 --> 00:01:40,680
circuit simulation so for the purpose of

00:01:38,369 --> 00:01:43,130
this of this group I think we can

00:01:40,680 --> 00:01:48,479
describe circuits as a type of graph and

00:01:43,130 --> 00:01:49,590
graphs have nodes are where the

00:01:48,479 --> 00:01:52,259
components of the graph come together

00:01:49,590 --> 00:01:54,930
and they have voltages and the edges of

00:01:52,259 --> 00:01:57,180
the graph are sometimes called branches

00:01:54,930 --> 00:01:58,680
they are components and the components

00:01:57,180 --> 00:02:00,840
have currents and the currents are

00:01:58,680 --> 00:02:02,750
functions of the voltages across the

00:02:00,840 --> 00:02:06,630
components between the connecting nodes

00:02:02,750 --> 00:02:08,489
and there the value of the component and

00:02:06,630 --> 00:02:10,289
sometimes the history that the component

00:02:08,489 --> 00:02:12,870
has gone through so here's a here's an

00:02:10,289 --> 00:02:13,500
example this is the simplest one you can

00:02:12,870 --> 00:02:15,900
imagine it

00:02:13,500 --> 00:02:17,970
a resistor the resistor has a current

00:02:15,900 --> 00:02:20,100
between the two nodes which is

00:02:17,970 --> 00:02:22,680
proportional to the difference in

00:02:20,100 --> 00:02:25,980
voltages on the nodes and the value of

00:02:22,680 --> 00:02:28,770
the resistor so here's the example

00:02:25,980 --> 00:02:30,480
circuit I'm going to use it's got three

00:02:28,770 --> 00:02:32,240
sort of interesting components just

00:02:30,480 --> 00:02:34,950
disregard the input voltage for now

00:02:32,240 --> 00:02:36,990
there's a resistor then there's a

00:02:34,950 --> 00:02:40,350
capacitor and then there's an inductor

00:02:36,990 --> 00:02:42,120
and so I'm going to try to simulate what

00:02:40,350 --> 00:02:44,880
happens when we apply a square wave at

00:02:42,120 --> 00:02:48,420
the input on the left and what what

00:02:44,880 --> 00:02:50,959
should be happening on the output so

00:02:48,420 --> 00:02:55,470
here's how you can analyze that

00:02:50,959 --> 00:02:57,600
differential equations yeah it was a

00:02:55,470 --> 00:02:57,930
little bit startled to do this for me as

00:02:57,600 --> 00:03:00,480
well

00:02:57,930 --> 00:03:02,010
so if you if you do like me and go get

00:03:00,480 --> 00:03:03,810
your differential equations textbook

00:03:02,010 --> 00:03:06,720
from college you can work out that

00:03:03,810 --> 00:03:08,370
there's there's basically two equations

00:03:06,720 --> 00:03:10,050
that are important here the first one

00:03:08,370 --> 00:03:11,940
has the sum of all the currents going

00:03:10,050 --> 00:03:13,560
into the node number one on the right

00:03:11,940 --> 00:03:15,989
has to be zero because of charge

00:03:13,560 --> 00:03:17,580
conservation the other one represents

00:03:15,989 --> 00:03:20,880
the branch current on the output

00:03:17,580 --> 00:03:24,570
inductor if you solve all of that take

00:03:20,880 --> 00:03:26,280
my word for it you come up with a the

00:03:24,570 --> 00:03:27,930
output as a function of time with that

00:03:26,280 --> 00:03:32,459
square wave input looks like that

00:03:27,930 --> 00:03:34,920
equation on the bottom so we can we can

00:03:32,459 --> 00:03:39,420
go and and sort of simulate this by

00:03:34,920 --> 00:03:41,489
simply implementing that equation we

00:03:39,420 --> 00:03:44,370
construct a circuit which is a function

00:03:41,489 --> 00:03:47,040
object and you supply the the time and

00:03:44,370 --> 00:03:49,170
it returns to you the output value at

00:03:47,040 --> 00:03:54,150
that time so that's one way of solving

00:03:49,170 --> 00:03:58,230
this and there you can move plotting out

00:03:54,150 --> 00:04:00,150
the results and it looks like this so

00:03:58,230 --> 00:04:02,130
they just it just kind of like you get a

00:04:00,150 --> 00:04:07,709
square input in it kind of rings you

00:04:02,130 --> 00:04:09,600
know so there's a problem with this

00:04:07,709 --> 00:04:11,790
which is that you don't want people

00:04:09,600 --> 00:04:13,590
sitting around and like manually solving

00:04:11,790 --> 00:04:16,380
differential equations to come up with

00:04:13,590 --> 00:04:18,269
their their program it's also not

00:04:16,380 --> 00:04:20,040
general there's even some some kinds of

00:04:18,269 --> 00:04:21,780
circuits where you actually can't

00:04:20,040 --> 00:04:24,060
manually solve the differential equation

00:04:21,780 --> 00:04:26,810
but we can use numeric integration and

00:04:24,060 --> 00:04:29,870
make this a lot easier

00:04:26,810 --> 00:04:32,180
handle both of those issues so the boost

00:04:29,870 --> 00:04:35,419
odeon --the library came out two years

00:04:32,180 --> 00:04:38,360
ago you can use it for numerical

00:04:35,419 --> 00:04:41,600
integration of systems of differential

00:04:38,360 --> 00:04:42,800
equations you just need to supply four

00:04:41,600 --> 00:04:45,139
things to it you need the state

00:04:42,800 --> 00:04:47,510
definition which is kind of like if you

00:04:45,139 --> 00:04:49,310
look at that that first example I showed

00:04:47,510 --> 00:04:52,280
it's like the current and the voltage at

00:04:49,310 --> 00:04:54,500
the output you need a callable object

00:04:52,280 --> 00:04:56,090
and this actually sort of instantiates

00:04:54,500 --> 00:04:59,270
your differential equations it returns

00:04:56,090 --> 00:05:01,160
for a given state vector and time it

00:04:59,270 --> 00:05:03,320
returns the change in the state vector

00:05:01,160 --> 00:05:05,720
and OD aunt is going to repeatedly call

00:05:03,320 --> 00:05:08,060
this to determine the values at each

00:05:05,720 --> 00:05:09,680
point need the initial conditions which

00:05:08,060 --> 00:05:12,380
are just the first values of the state

00:05:09,680 --> 00:05:15,380
variables and finally a callable object

00:05:12,380 --> 00:05:16,940
every time OD and figures out the value

00:05:15,380 --> 00:05:19,400
at a time point it's going to call this

00:05:16,940 --> 00:05:22,100
thing and you can store it away or print

00:05:19,400 --> 00:05:26,360
it or whatever so here's how this would

00:05:22,100 --> 00:05:28,040
look for example circuit I'm building

00:05:26,360 --> 00:05:29,960
here another function object but this

00:05:28,040 --> 00:05:33,530
time it's in the form that OD e ant

00:05:29,960 --> 00:05:35,390
wants to see we have this we have the

00:05:33,530 --> 00:05:40,490
state vector which is just two two

00:05:35,390 --> 00:05:42,680
values and the the operator give it

00:05:40,490 --> 00:05:44,510
takes the current value of the state

00:05:42,680 --> 00:05:46,700
variables and the time and returns in

00:05:44,510 --> 00:05:48,770
that second reference parameter the

00:05:46,700 --> 00:05:50,390
change in the values and if you look now

00:05:48,770 --> 00:05:51,950
instead of solving the differential

00:05:50,390 --> 00:05:53,210
equations and having just one thing

00:05:51,950 --> 00:05:55,490
that's a function of time

00:05:53,210 --> 00:05:57,620
I'm actually just reorganized the

00:05:55,490 --> 00:06:00,139
equations a little bit and now I can

00:05:57,620 --> 00:06:02,780
return the change in the state variables

00:06:00,139 --> 00:06:05,030
as function of time and this is the way

00:06:02,780 --> 00:06:06,440
OD an wants to see it and so when you're

00:06:05,030 --> 00:06:09,680
actually going to call this thing I'm

00:06:06,440 --> 00:06:11,750
instantiating the circuit by creating

00:06:09,680 --> 00:06:13,520
the initial conditions and then this is

00:06:11,750 --> 00:06:17,900
the main call to to the integrate

00:06:13,520 --> 00:06:20,090
function that odn provides and you give

00:06:17,900 --> 00:06:22,250
it the that circuit object I created the

00:06:20,090 --> 00:06:24,169
initial conditions the time range and

00:06:22,250 --> 00:06:26,919
something to do with the values as it

00:06:24,169 --> 00:06:26,919
calculates it

00:06:27,990 --> 00:06:31,770
so that's still that's that's good it's

00:06:30,389 --> 00:06:33,870
and it's an improvement of our what we

00:06:31,770 --> 00:06:35,430
started with we decided to manually

00:06:33,870 --> 00:06:36,990
rearrange everything so there's still

00:06:35,430 --> 00:06:40,139
some sort of human intervention here

00:06:36,990 --> 00:06:43,490
what we really want to do is have a

00:06:40,139 --> 00:06:46,470
mechanical way of representing circuits

00:06:43,490 --> 00:06:49,050
in a standard form that we can can then

00:06:46,470 --> 00:06:50,880
operate on so that the user can supply

00:06:49,050 --> 00:06:54,150
any circuit they want and we'll still

00:06:50,880 --> 00:06:57,090
handle it correctly the standard way of

00:06:54,150 --> 00:07:00,750
representing circuits now is something

00:06:57,090 --> 00:07:04,500
called modified nodal analysis you'll

00:07:00,750 --> 00:07:07,460
end up with a set of matrices some of

00:07:04,500 --> 00:07:09,690
which hold one of which holds the

00:07:07,460 --> 00:07:13,800
time-dependent elements and one of which

00:07:09,690 --> 00:07:16,470
holds everything else and I'll

00:07:13,800 --> 00:07:18,360
demonstrate that so this is kind of what

00:07:16,470 --> 00:07:20,280
it looks like instead of two equations

00:07:18,360 --> 00:07:21,960
two differential equations in two

00:07:20,280 --> 00:07:24,150
variables we now have four differential

00:07:21,960 --> 00:07:26,520
equations at four variables but in

00:07:24,150 --> 00:07:28,110
return for that increase verbosity we

00:07:26,520 --> 00:07:31,349
have a standard format that we can

00:07:28,110 --> 00:07:33,240
mechanically put information into so if

00:07:31,349 --> 00:07:36,539
you look down at the G matrix there

00:07:33,240 --> 00:07:38,400
you'll see this little you'll see this

00:07:36,539 --> 00:07:40,199
this pattern where there's the one over

00:07:38,400 --> 00:07:42,570
ours there's four one over ours there

00:07:40,199 --> 00:07:45,750
that's what we call that the stamp of

00:07:42,570 --> 00:07:49,979
the resistor component and you can you

00:07:45,750 --> 00:07:52,530
can take the the user can supply a any

00:07:49,979 --> 00:07:53,820
resistor and just simply say the value

00:07:52,530 --> 00:07:55,680
of the resistor and the nodes is

00:07:53,820 --> 00:07:57,690
connected in between and we have a

00:07:55,680 --> 00:07:59,729
mechanical way of sticking that in the

00:07:57,690 --> 00:08:03,090
matrix and when you put this all

00:07:59,729 --> 00:08:04,979
together you have a correct differential

00:08:03,090 --> 00:08:06,900
equation of differential equations that

00:08:04,979 --> 00:08:13,919
represents the circuit correctly but now

00:08:06,900 --> 00:08:16,110
we've created it mechanically so once

00:08:13,919 --> 00:08:18,840
we've done that now we can we can

00:08:16,110 --> 00:08:22,860
multiply both sides of this equation by

00:08:18,840 --> 00:08:25,860
the inverse of C and we get the form

00:08:22,860 --> 00:08:28,050
that boost OD and wanted to see we can

00:08:25,860 --> 00:08:30,030
now calculate that change in the state

00:08:28,050 --> 00:08:33,539
variables as a function of the time and

00:08:30,030 --> 00:08:35,279
the current state variable but to do

00:08:33,539 --> 00:08:39,810
that we're going to need a matrix

00:08:35,279 --> 00:08:41,910
library to represent the matrices

00:08:39,810 --> 00:08:44,130
and this in this case I chose eigem

00:08:41,910 --> 00:08:46,740
there's there's several but eigen had a

00:08:44,130 --> 00:08:49,050
really active a user base and friendly

00:08:46,740 --> 00:08:50,100
documentation so I started there it's

00:08:49,050 --> 00:08:52,620
also got a lot of other features

00:08:50,100 --> 00:08:57,090
including algorithms which we're going

00:08:52,620 --> 00:08:58,800
to make use of so this is an example of

00:08:57,090 --> 00:09:01,380
the stamp which is the conventional way

00:08:58,800 --> 00:09:03,240
of representing a component and I've

00:09:01,380 --> 00:09:07,620
given the example of the resistor which

00:09:03,240 --> 00:09:10,340
I showed you earlier so this is just a

00:09:07,620 --> 00:09:12,660
way if you look at the usage here

00:09:10,340 --> 00:09:14,970
imagine that we're reading in from the

00:09:12,660 --> 00:09:17,250
user or some file or something like that

00:09:14,970 --> 00:09:18,900
all the different resistors and other

00:09:17,250 --> 00:09:21,630
components we can simply call this

00:09:18,900 --> 00:09:23,610
function as long as we have a matrix of

00:09:21,630 --> 00:09:26,190
the right size then we'll end up with

00:09:23,610 --> 00:09:31,290
with all of the matrices we need to

00:09:26,190 --> 00:09:33,270
represent the system we have

00:09:31,290 --> 00:09:35,100
unfortunately a little problem here and

00:09:33,270 --> 00:09:36,870
some of you know about math we'll we'll

00:09:35,100 --> 00:09:39,300
know what it is we can't actually

00:09:36,870 --> 00:09:41,370
multiply both sides by the inverse of C

00:09:39,300 --> 00:09:47,130
here because C is singular which means

00:09:41,370 --> 00:09:48,810
it can't be inverted this this is a it's

00:09:47,130 --> 00:09:51,030
the singular is the mathematical term

00:09:48,810 --> 00:09:54,330
but I kind of think of it as the matrix

00:09:51,030 --> 00:09:59,880
has too many zeros it's it's not very

00:09:54,330 --> 00:10:01,740
but I'm not a mathematician but we can

00:09:59,880 --> 00:10:06,150
fix this and so here's how we're going

00:10:01,740 --> 00:10:08,640
to fix it we're going to turn those four

00:10:06,150 --> 00:10:11,700
equations into two equations and two

00:10:08,640 --> 00:10:13,770
variables again by first of all moving

00:10:11,700 --> 00:10:16,230
the nonzero elements of C up into the

00:10:13,770 --> 00:10:19,820
upper left-hand corner with Gaussian

00:10:16,230 --> 00:10:19,820
elimination do you guys remember that

00:10:20,960 --> 00:10:26,790
Russ can take advantage of the all zero

00:10:23,520 --> 00:10:31,160
roses of C to restate two of the state

00:10:26,790 --> 00:10:34,290
variables in terms of the other two so

00:10:31,160 --> 00:10:36,450
this is how the code will look and eigen

00:10:34,290 --> 00:10:38,910
provides all of this stuff for you it's

00:10:36,450 --> 00:10:40,290
gonna apply Gaussian elimination to C

00:10:38,910 --> 00:10:43,200
and it's going to remember all the

00:10:40,290 --> 00:10:46,290
operations that did and the result of

00:10:43,200 --> 00:10:49,020
that is you see C is now L and C are in

00:10:46,290 --> 00:10:52,800
the upper left hand corner and it's also

00:10:49,020 --> 00:10:54,899
reordered G and it used the

00:10:52,800 --> 00:10:57,330
applied the same changes to G that it

00:10:54,899 --> 00:10:59,459
did to C because it remembered them and

00:10:57,330 --> 00:11:01,260
so now we have another system of four

00:10:59,459 --> 00:11:04,320
equations and four variables that's just

00:11:01,260 --> 00:11:09,329
been reordered but it's still it's still

00:11:04,320 --> 00:11:11,399
effectively the same so but now we can

00:11:09,329 --> 00:11:13,470
we can apply a little bit more algebra

00:11:11,399 --> 00:11:16,440
and get to something that we can invert

00:11:13,470 --> 00:11:18,450
so what we're gonna do now is that we're

00:11:16,440 --> 00:11:21,089
going to eliminate those last two state

00:11:18,450 --> 00:11:23,250
variables the the v-0 and the input

00:11:21,089 --> 00:11:25,920
current using some algebra and again

00:11:23,250 --> 00:11:27,269
this is more eigen stuff we end up with

00:11:25,920 --> 00:11:30,510
something that looks like that equation

00:11:27,269 --> 00:11:33,269
down there and now the C nu is actually

00:11:30,510 --> 00:11:35,100
a matrix that can be inverted and once

00:11:33,269 --> 00:11:37,709
we've done that then we can end up with

00:11:35,100 --> 00:11:39,300
that last line there where we can once

00:11:37,709 --> 00:11:41,010
again calculate the change in the state

00:11:39,300 --> 00:11:43,970
variables based on their current value

00:11:41,010 --> 00:11:46,769
in the time which is what OD and once

00:11:43,970 --> 00:11:48,209
having done that we can do our numerical

00:11:46,769 --> 00:11:49,800
integration and you get a graph that

00:11:48,209 --> 00:11:52,079
looks like that which is very much like

00:11:49,800 --> 00:11:53,579
the first one only there's a little bit

00:11:52,079 --> 00:11:55,079
of numeric integration artifacts I

00:11:53,579 --> 00:11:59,550
actually just left that in so you could

00:11:55,079 --> 00:12:03,089
see it was being done that way so in

00:11:59,550 --> 00:12:06,089
conclusion we now have all these really

00:12:03,089 --> 00:12:08,040
awesome libraries OD and eigen there's

00:12:06,089 --> 00:12:09,990
actually a whole bunch of matrix and

00:12:08,040 --> 00:12:11,310
linear algebra libraries out there and

00:12:09,990 --> 00:12:13,829
they can do some pretty incredible

00:12:11,310 --> 00:12:15,779
things for us and so a lot of this stuff

00:12:13,829 --> 00:12:17,820
that we used to do kind of like with

00:12:15,779 --> 00:12:21,360
this sort of you know proprietary

00:12:17,820 --> 00:12:22,800
library layer which has bugs and has to

00:12:21,360 --> 00:12:25,290
be maintained and all that kind of stuff

00:12:22,800 --> 00:12:28,740
you can start to eliminate them and

00:12:25,290 --> 00:12:30,930
instead of doing that use an open source

00:12:28,740 --> 00:12:32,850
library that that's very powerful and

00:12:30,930 --> 00:12:35,279
robust and well maintained and has lots

00:12:32,850 --> 00:12:38,699
of eyes on it and even contribute to it

00:12:35,279 --> 00:12:40,230
and life will be like super better I

00:12:38,699 --> 00:12:45,079
think so

00:12:40,230 --> 00:12:45,079
and there's some resources thank you

00:12:46,209 --> 00:12:48,269

YouTube URL: https://www.youtube.com/watch?v=TIKSL40fEVs


