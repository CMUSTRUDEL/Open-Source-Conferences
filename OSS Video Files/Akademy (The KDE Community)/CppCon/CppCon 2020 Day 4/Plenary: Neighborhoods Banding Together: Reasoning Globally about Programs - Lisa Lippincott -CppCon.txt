Title: Plenary: Neighborhoods Banding Together: Reasoning Globally about Programs - Lisa Lippincott -CppCon
Publication date: 2020-10-03
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Our most detailed reasoning about programs is done locally: we consider a neighborhood of a program — usually a single function and the interfaces surrounding it — and reason about its behavior without reference to the remainder of the program. But this reasoning is in service of a larger goal: we want to ensure that the entire program behaves correctly.

In this talk, I will take local reasoning for granted, and look at the process of joining neighborhoods of local reasoning together, and the global reasoning that ensures they form a coherent whole. I will show how we can prevent incoherent joining, and prevent the emergence of unbounded non-local recursion as the program is linked together.

This talk builds upon the discussion of local reasoning in last year's talk "The Truth of a Procedure,” but is intended to be understandable independently.

---
Lisa Lippincott designed the software architectures of Tanium and BigFix, two systems for managing large fleets of computers. She's also a language nerd, and has contributed to arcane parts of the C++ standard. In her spare time, she studies mathematical logic, and wants to make computer-checked proofs of correctness a routine part of programming.

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:10,000 --> 00:00:14,160
hi

00:00:10,880 --> 00:00:15,839
i'm lisa lippincott and i'm here at home

00:00:14,160 --> 00:00:17,199
talking about neighborhoods banding

00:00:15,839 --> 00:00:20,480
together or

00:00:17,199 --> 00:00:23,199
reasoning globally about programs now

00:00:20,480 --> 00:00:24,800
this is a bit of a departure for me

00:00:23,199 --> 00:00:25,439
usually when i speak at conferences

00:00:24,800 --> 00:00:28,160
these days

00:00:25,439 --> 00:00:29,679
i speak about reasoning locally about

00:00:28,160 --> 00:00:33,040
programs

00:00:29,679 --> 00:00:35,120
but the usual warning still applies

00:00:33,040 --> 00:00:36,719
which is that the code here is written

00:00:35,120 --> 00:00:38,800
in a fantasy c

00:00:36,719 --> 00:00:40,320
plus with a number of extensions that

00:00:38,800 --> 00:00:41,840
support local reasoning

00:00:40,320 --> 00:00:43,520
i don't think they'll be too hard to

00:00:41,840 --> 00:00:45,760
understand but

00:00:43,520 --> 00:00:48,879
they will be there and you can't expect

00:00:45,760 --> 00:00:52,960
to use them in your compilers today

00:00:48,879 --> 00:00:56,800
um local reasoning is the process

00:00:52,960 --> 00:00:59,359
of looking at a program one neighborhood

00:00:56,800 --> 00:01:00,480
at a time and analyzing that

00:00:59,359 --> 00:01:03,600
neighborhood

00:01:00,480 --> 00:01:06,880
to see if the neighborhood

00:01:03,600 --> 00:01:10,479
fits the boundary conditions

00:01:06,880 --> 00:01:13,520
set by its interface and the interfaces

00:01:10,479 --> 00:01:16,799
that it connects to

00:01:13,520 --> 00:01:17,759
so the fundamental idea of local

00:01:16,799 --> 00:01:20,799
reasoning

00:01:17,759 --> 00:01:22,080
is the neighborhood and this is a

00:01:20,799 --> 00:01:25,200
schematic

00:01:22,080 --> 00:01:27,640
of a neighborhood in a program

00:01:25,200 --> 00:01:31,040
the center of the neighborhood is the

00:01:27,640 --> 00:01:34,799
implementation of a function

00:01:31,040 --> 00:01:38,079
um so that's where things actually

00:01:34,799 --> 00:01:42,079
well kind of things actually happen

00:01:38,079 --> 00:01:44,479
um the neighborhood also includes

00:01:42,079 --> 00:01:45,600
on the left the interface to the

00:01:44,479 --> 00:01:47,200
function

00:01:45,600 --> 00:01:49,280
um through which it's entered through

00:01:47,200 --> 00:01:49,840
which it's it's exited when the program

00:01:49,280 --> 00:01:52,079
returned

00:01:49,840 --> 00:01:54,079
when the function returns uh the

00:01:52,079 --> 00:01:54,720
interface can set up preconditions it

00:01:54,079 --> 00:01:57,119
can set up

00:01:54,720 --> 00:01:58,320
post conditions in the epilogue and it

00:01:57,119 --> 00:02:00,640
can relate

00:01:58,320 --> 00:02:01,439
conditions before the function to

00:02:00,640 --> 00:02:05,439
conditions

00:02:01,439 --> 00:02:06,799
after the function the neighborhood also

00:02:05,439 --> 00:02:10,560
includes interfaces

00:02:06,799 --> 00:02:12,480
of functions called by the neighborhood

00:02:10,560 --> 00:02:14,000
so anything that is called from the

00:02:12,480 --> 00:02:16,720
neighborhood

00:02:14,000 --> 00:02:18,080
and any interface is called from the

00:02:16,720 --> 00:02:19,760
neighborhood

00:02:18,080 --> 00:02:22,080
is part of the neighborhood but

00:02:19,760 --> 00:02:24,480
generally the implementation

00:02:22,080 --> 00:02:25,360
of things that are outside the

00:02:24,480 --> 00:02:28,480
neighborhood

00:02:25,360 --> 00:02:30,080
are that um the implementation of the

00:02:28,480 --> 00:02:31,920
caller or the implementation of

00:02:30,080 --> 00:02:35,200
something called from the neighborhood

00:02:31,920 --> 00:02:38,400
is not part of the neighborhood so

00:02:35,200 --> 00:02:40,319
this is enough to look at

00:02:38,400 --> 00:02:42,640
to see if the function meets its

00:02:40,319 --> 00:02:46,239
boundary conditions

00:02:42,640 --> 00:02:48,000
um i will say that um i have found it's

00:02:46,239 --> 00:02:51,760
useful to include one more thing

00:02:48,000 --> 00:02:52,239
in the neighborhood which is the bodies

00:02:51,760 --> 00:02:54,480
of

00:02:52,239 --> 00:02:55,360
inline functions that are called from

00:02:54,480 --> 00:02:58,000
the neighborhood

00:02:55,360 --> 00:02:59,760
that's not shown here but the bodies of

00:02:58,000 --> 00:03:01,040
inline functions that are called from

00:02:59,760 --> 00:03:03,760
the neighborhood

00:03:01,040 --> 00:03:05,200
are going to be i'm going to consider

00:03:03,760 --> 00:03:07,519
part of the neighborhood

00:03:05,200 --> 00:03:10,560
unless that inline function is broken

00:03:07,519 --> 00:03:13,360
into an interface and an implementation

00:03:10,560 --> 00:03:15,680
that's going to be important in about 30

00:03:13,360 --> 00:03:18,800
minutes

00:03:15,680 --> 00:03:22,720
so when you're looking locally

00:03:18,800 --> 00:03:25,519
at a neighborhood you can think of

00:03:22,720 --> 00:03:27,599
the function fitting the implementation

00:03:25,519 --> 00:03:31,200
fitting its boundary conditions

00:03:27,599 --> 00:03:32,959
as a sort of game and in this game

00:03:31,200 --> 00:03:36,080
there are two players or perhaps it's

00:03:32,959 --> 00:03:39,360
better to say two teams of players

00:03:36,080 --> 00:03:41,599
um on the edges we have

00:03:39,360 --> 00:03:42,480
the guys with the horns the guys with

00:03:41,599 --> 00:03:45,040
the horns

00:03:42,480 --> 00:03:46,560
represent the forces outside the

00:03:45,040 --> 00:03:49,760
neighborhood

00:03:46,560 --> 00:03:52,560
that are caught that are

00:03:49,760 --> 00:03:53,920
causing the flow of control to enter the

00:03:52,560 --> 00:03:55,519
neighborhood

00:03:53,920 --> 00:03:57,159
so the guys with the horns are

00:03:55,519 --> 00:04:01,840
responsible for making the

00:03:57,159 --> 00:04:05,439
preconditions our functions interface

00:04:01,840 --> 00:04:06,720
uh hold as the as the implementation is

00:04:05,439 --> 00:04:10,159
entered

00:04:06,720 --> 00:04:12,720
and they are responsible for um

00:04:10,159 --> 00:04:14,480
hold for making sure the epilogues the

00:04:12,720 --> 00:04:18,079
post conditions

00:04:14,480 --> 00:04:19,759
of called functions hold

00:04:18,079 --> 00:04:21,519
so the guides of the horns basically

00:04:19,759 --> 00:04:24,560
represent the outside

00:04:21,519 --> 00:04:27,199
of the neighborhood the center of the

00:04:24,560 --> 00:04:31,600
neighborhood though the implementation

00:04:27,199 --> 00:04:34,320
is the domain of the bald guys

00:04:31,600 --> 00:04:34,720
um so here we have a bald guy in charge

00:04:34,320 --> 00:04:38,000
of

00:04:34,720 --> 00:04:40,560
our function foo's implementation but

00:04:38,000 --> 00:04:41,040
the bald guy is also in charge of

00:04:40,560 --> 00:04:44,000
getting

00:04:41,040 --> 00:04:44,960
flow out of the neighborhood so every

00:04:44,000 --> 00:04:47,520
time

00:04:44,960 --> 00:04:48,960
an interface is called from the bald

00:04:47,520 --> 00:04:52,000
guy's domain

00:04:48,960 --> 00:04:54,320
that the prologue of that interface is

00:04:52,000 --> 00:04:58,000
part of the bald guy's domain

00:04:54,320 --> 00:05:00,479
and anytime the function returns

00:04:58,000 --> 00:05:02,080
through the epilogue the epilogue of

00:05:00,479 --> 00:05:05,039
that interface

00:05:02,080 --> 00:05:07,120
is part of the bald guy's domain so we

00:05:05,039 --> 00:05:10,560
have this game

00:05:07,120 --> 00:05:13,680
and what we do when we program

00:05:10,560 --> 00:05:14,560
is we try to rig the game so that the

00:05:13,680 --> 00:05:17,680
bald guy

00:05:14,560 --> 00:05:22,000
has a winning strategy and

00:05:17,680 --> 00:05:22,000
the guys of the horns always lose the

00:05:22,840 --> 00:05:25,840
game

00:05:27,440 --> 00:05:35,199
and so local reasoning

00:05:31,840 --> 00:05:38,720
is the art is basically about

00:05:35,199 --> 00:05:43,840
making sure that bald guys

00:05:38,720 --> 00:05:47,039
can win the local games in your programs

00:05:43,840 --> 00:05:50,960
but we're not really

00:05:47,039 --> 00:05:54,400
interested in the big picture

00:05:50,960 --> 00:05:59,520
about whether individual functions

00:05:54,400 --> 00:06:02,400
in our program win their local games

00:05:59,520 --> 00:06:06,240
we're interested in putting all the

00:06:02,400 --> 00:06:10,160
functions together

00:06:06,240 --> 00:06:12,560
and when we put the functions together

00:06:10,160 --> 00:06:16,240
we have places where there's a calling

00:06:12,560 --> 00:06:19,680
function and a called function

00:06:16,240 --> 00:06:21,840
and each of those functions has its own

00:06:19,680 --> 00:06:26,880
bald guy

00:06:21,840 --> 00:06:26,880
and we put the two functions together

00:06:27,440 --> 00:06:34,720
making a combined game

00:06:31,120 --> 00:06:37,919
that we hope the team of bald guys

00:06:34,720 --> 00:06:38,639
can win so when we link our program

00:06:37,919 --> 00:06:41,680
together

00:06:38,639 --> 00:06:42,800
we're forming a bald guy team up that

00:06:41,680 --> 00:06:48,800
still needs to

00:06:42,800 --> 00:06:52,319
defeat the guys with the horns

00:06:48,800 --> 00:06:54,639
and here the um

00:06:52,319 --> 00:06:57,280
the game is different the game is a

00:06:54,639 --> 00:06:59,520
combined game between the two

00:06:57,280 --> 00:07:01,680
whereas each bald guy was playing their

00:06:59,520 --> 00:07:04,639
own individual game before

00:07:01,680 --> 00:07:05,039
but the strategies are related because

00:07:04,639 --> 00:07:08,960
this

00:07:05,039 --> 00:07:12,000
isn't is a game in which

00:07:08,960 --> 00:07:15,120
the um bald guys are not

00:07:12,000 --> 00:07:17,360
playing a touchy feely

00:07:15,120 --> 00:07:19,840
everybody helps each other out sort of

00:07:17,360 --> 00:07:22,960
strategy

00:07:19,840 --> 00:07:26,479
in this game there's a plan and

00:07:22,960 --> 00:07:30,080
every bald guy has a job to do and every

00:07:26,479 --> 00:07:33,199
individual bald guy is doing his best

00:07:30,080 --> 00:07:36,400
to make sure that the

00:07:33,199 --> 00:07:37,039
that he is not the one who lets the team

00:07:36,400 --> 00:07:41,280
down

00:07:37,039 --> 00:07:44,319
by not doing his job so in effect

00:07:41,280 --> 00:07:48,639
each bald guy is playing a

00:07:44,319 --> 00:07:52,080
smaller game the game of their job

00:07:48,639 --> 00:07:56,080
and treating their teammates as if

00:07:52,080 --> 00:07:58,319
their teammates were guys of horns

00:07:56,080 --> 00:07:59,759
so that's what happens when we link our

00:07:58,319 --> 00:08:02,800
program together

00:07:59,759 --> 00:08:04,000
we form bigger games and we form bigger

00:08:02,800 --> 00:08:13,840
strategies

00:08:04,000 --> 00:08:13,840
by combining the existing strategies

00:08:14,400 --> 00:08:16,879
pardon me

00:08:17,520 --> 00:08:23,120
um so this is

00:08:20,800 --> 00:08:24,720
the framework for today's talk there's

00:08:23,120 --> 00:08:27,759
local reasoning

00:08:24,720 --> 00:08:30,960
and local reasoning is not our problem

00:08:27,759 --> 00:08:32,640
today local reasoning

00:08:30,960 --> 00:08:34,640
any problem that can be solved locally

00:08:32,640 --> 00:08:37,839
that can even be seen

00:08:34,640 --> 00:08:40,320
locally and understood locally

00:08:37,839 --> 00:08:41,599
we're going to count as not today's

00:08:40,320 --> 00:08:45,600
problem

00:08:41,599 --> 00:08:48,880
today's problem today's problems plural

00:08:45,600 --> 00:08:50,240
are the ones that come from combining

00:08:48,880 --> 00:08:53,680
neighborhoods together

00:08:50,240 --> 00:08:54,640
the problems that you can't see locally

00:08:53,680 --> 00:08:58,000
that no

00:08:54,640 --> 00:09:00,959
individual bald guy can be held

00:08:58,000 --> 00:09:00,959
responsible for

00:09:01,040 --> 00:09:08,720
and one example of such a problem

00:09:05,200 --> 00:09:09,440
is that sometimes you might have a

00:09:08,720 --> 00:09:13,440
caller

00:09:09,440 --> 00:09:16,240
and a call function that disagree

00:09:13,440 --> 00:09:16,880
on what the interface between the two

00:09:16,240 --> 00:09:20,160
functions

00:09:16,880 --> 00:09:23,440
is the these

00:09:20,160 --> 00:09:24,880
two these two might think the interface

00:09:23,440 --> 00:09:26,240
is different they might be going

00:09:24,880 --> 00:09:29,360
according to different

00:09:26,240 --> 00:09:32,080
plans and

00:09:29,360 --> 00:09:32,560
when you form the team up what happens

00:09:32,080 --> 00:09:34,480
is

00:09:32,560 --> 00:09:36,880
they pull in different directions they

00:09:34,480 --> 00:09:40,320
have different expectations

00:09:36,880 --> 00:09:43,519
of what's going on between them

00:09:40,320 --> 00:09:45,519
and so you can end up with problems

00:09:43,519 --> 00:09:47,120
that neither in the interface that

00:09:45,519 --> 00:09:50,399
neither bald guy

00:09:47,120 --> 00:09:52,640
feels responsible for

00:09:50,399 --> 00:09:56,160
and of course that's going to make our

00:09:52,640 --> 00:09:58,959
teamwork fault pieces

00:09:56,160 --> 00:10:00,640
now this is a problem that shows up in a

00:09:58,959 --> 00:10:04,160
number of contexts

00:10:00,640 --> 00:10:07,040
in c plus and other computer languages

00:10:04,160 --> 00:10:09,839
and c plus has a rule to deal with

00:10:07,040 --> 00:10:13,760
exactly this sort of situation

00:10:09,839 --> 00:10:15,839
we have the one definition rule

00:10:13,760 --> 00:10:17,519
the one definition rule is actually

00:10:15,839 --> 00:10:18,320
quite complicated because it spells

00:10:17,519 --> 00:10:21,839
things out

00:10:18,320 --> 00:10:24,800
in great detail but

00:10:21,839 --> 00:10:25,920
the gist of it is here on the slide

00:10:24,800 --> 00:10:28,160
which is

00:10:25,920 --> 00:10:30,240
there are many things in a program that

00:10:28,160 --> 00:10:34,720
must be defined

00:10:30,240 --> 00:10:39,440
and those things fall into two classes

00:10:34,720 --> 00:10:42,560
um some things may be defined only once

00:10:39,440 --> 00:10:45,680
in an entire program so

00:10:42,560 --> 00:10:48,320
non-inline functions dot cpp

00:10:45,680 --> 00:10:49,519
sorts of things all of those things are

00:10:48,320 --> 00:10:52,959
things that get defined

00:10:49,519 --> 00:10:54,800
once in an entire program

00:10:52,959 --> 00:10:57,839
and then the there's another class of

00:10:54,800 --> 00:11:00,959
things that can be defined repeatedly

00:10:57,839 --> 00:11:04,399
as long as you only define it once per

00:11:00,959 --> 00:11:07,120
translation unit so inline functions

00:11:04,399 --> 00:11:09,040
are that sort of thing dot h file sorts

00:11:07,120 --> 00:11:12,160
of things we put things in the dot

00:11:09,040 --> 00:11:13,360
h file because we want the same

00:11:12,160 --> 00:11:15,440
definition

00:11:13,360 --> 00:11:18,160
to appear in many translation units in

00:11:15,440 --> 00:11:22,399
many compilations

00:11:18,160 --> 00:11:26,240
so each compile only sees one definition

00:11:22,399 --> 00:11:28,959
of the of those things of anything

00:11:26,240 --> 00:11:30,000
but when we link together we are linking

00:11:28,959 --> 00:11:35,360
together

00:11:30,000 --> 00:11:39,040
compiles that saw different definitions

00:11:35,360 --> 00:11:42,320
and when we do when we have

00:11:39,040 --> 00:11:43,279
have um multiple definitions of the same

00:11:42,320 --> 00:11:46,000
thing

00:11:43,279 --> 00:11:48,640
the rule says that all the definitions

00:11:46,000 --> 00:11:52,160
have to match

00:11:48,640 --> 00:11:55,519
and it lays out exactly what matching

00:11:52,160 --> 00:11:59,200
means again it's a long list

00:11:55,519 --> 00:12:03,200
of rules to get there but the gist of it

00:11:59,200 --> 00:12:05,519
is that the to match

00:12:03,200 --> 00:12:07,279
two definitions have to use the same

00:12:05,519 --> 00:12:09,440
sequence of tokens

00:12:07,279 --> 00:12:11,440
that's why using macros in one of the

00:12:09,440 --> 00:12:13,839
reasons macros in your header file can

00:12:11,440 --> 00:12:15,440
really mess things up it can cause you

00:12:13,839 --> 00:12:17,839
to unknowingly break

00:12:15,440 --> 00:12:18,480
the one definition rule where you

00:12:17,839 --> 00:12:22,839
thought

00:12:18,480 --> 00:12:25,440
you had um you had satisfied it

00:12:22,839 --> 00:12:28,800
um and in general

00:12:25,440 --> 00:12:29,360
the different definitions that come from

00:12:28,800 --> 00:12:32,399
different

00:12:29,360 --> 00:12:32,720
translation units have to refer to the

00:12:32,399 --> 00:12:35,920
same

00:12:32,720 --> 00:12:37,519
other entities that is um that the

00:12:35,920 --> 00:12:39,440
principal culprit here is

00:12:37,519 --> 00:12:40,560
overload resolution if overload

00:12:39,440 --> 00:12:43,040
resolution went

00:12:40,560 --> 00:12:44,399
differently in two of the different

00:12:43,040 --> 00:12:46,079
definitions

00:12:44,399 --> 00:12:47,680
then you could end up with in two

00:12:46,079 --> 00:12:49,519
different translation units

00:12:47,680 --> 00:12:51,680
then you could end up referring to

00:12:49,519 --> 00:12:53,920
different functions

00:12:51,680 --> 00:12:55,440
to you could end up calling different

00:12:53,920 --> 00:12:56,880
functions or taking the address of

00:12:55,440 --> 00:12:59,120
different functions

00:12:56,880 --> 00:13:00,480
where you should have taken you know

00:12:59,120 --> 00:13:03,120
where you should have referred to

00:13:00,480 --> 00:13:04,079
the same function so to satisfy the one

00:13:03,120 --> 00:13:07,519
definition rule

00:13:04,079 --> 00:13:09,440
generally the two the definitions that

00:13:07,519 --> 00:13:11,760
that are matching have to refer to the

00:13:09,440 --> 00:13:15,680
same other entities

00:13:11,760 --> 00:13:18,639
there are some um exceptions to that

00:13:15,680 --> 00:13:19,360
and they are about um situations where

00:13:18,639 --> 00:13:23,040
you can refer

00:13:19,360 --> 00:13:25,120
to different constant objects

00:13:23,040 --> 00:13:26,959
that happen to have the same value

00:13:25,120 --> 00:13:30,160
because it turns out the value

00:13:26,959 --> 00:13:34,160
is the only important thing for making

00:13:30,160 --> 00:13:37,600
our program work

00:13:34,160 --> 00:13:41,680
so that's the one definition rule and

00:13:37,600 --> 00:13:45,120
um since i'm since these interfaces

00:13:41,680 --> 00:13:47,680
and implementations are part of the

00:13:45,120 --> 00:13:48,399
fantasy extensions to the language i'm

00:13:47,680 --> 00:13:51,360
going to

00:13:48,399 --> 00:13:52,120
extend the one definition rule to say

00:13:51,360 --> 00:13:55,040
that

00:13:52,120 --> 00:13:55,519
implementations of functions in general

00:13:55,040 --> 00:13:58,320
are

00:13:55,519 --> 00:13:59,760
dot cp file stuff they are things that

00:13:58,320 --> 00:14:03,120
may only be defined

00:13:59,760 --> 00:14:05,120
once in an entire program

00:14:03,120 --> 00:14:06,880
with an exception for inline

00:14:05,120 --> 00:14:10,000
implementations

00:14:06,880 --> 00:14:14,079
um the and i'm going to say that

00:14:10,000 --> 00:14:16,720
interfaces are dot h file stuff

00:14:14,079 --> 00:14:17,839
they may be defined once per translation

00:14:16,720 --> 00:14:20,000
unit

00:14:17,839 --> 00:14:21,440
so we're going to see multiple

00:14:20,000 --> 00:14:23,519
definitions

00:14:21,440 --> 00:14:24,480
in different translation units and when

00:14:23,519 --> 00:14:27,920
we link

00:14:24,480 --> 00:14:30,320
we want them to match and we want

00:14:27,920 --> 00:14:31,199
them to match according to exactly these

00:14:30,320 --> 00:14:35,839
rules

00:14:31,199 --> 00:14:35,839
the the rules of the one definition rule

00:14:36,000 --> 00:14:39,519
now the one definition rule does spell

00:14:38,639 --> 00:14:43,120
things out

00:14:39,519 --> 00:14:47,279
in sufficient detail that we do know

00:14:43,120 --> 00:14:51,040
just what it means by definition

00:14:47,279 --> 00:14:52,519
a definition is a mapping from a linkage

00:14:51,040 --> 00:14:56,480
name from a unique

00:14:52,519 --> 00:15:00,160
identifier for the thing being defined

00:14:56,480 --> 00:15:03,360
to a bunch of a sequence of tokens

00:15:00,160 --> 00:15:04,880
a bunch of values that the token that

00:15:03,360 --> 00:15:08,560
might be referred to

00:15:04,880 --> 00:15:11,519
and linkage names of other entities

00:15:08,560 --> 00:15:12,000
that might be referred to so the one

00:15:11,519 --> 00:15:15,120
definition

00:15:12,000 --> 00:15:18,160
rule tells us a definition looks

00:15:15,120 --> 00:15:21,519
like this linkage name maps to tokens

00:15:18,160 --> 00:15:21,519
and values and linkage names

00:15:21,760 --> 00:15:27,279
um and we can take advantage of that

00:15:25,040 --> 00:15:30,160
to find out if we have broken the one

00:15:27,279 --> 00:15:30,160
definition rule

00:15:30,480 --> 00:15:34,720
because when we're compiling we could

00:15:33,600 --> 00:15:37,920
compile

00:15:34,720 --> 00:15:41,040
lists of all the definitions

00:15:37,920 --> 00:15:44,480
that we're using in a program that is

00:15:41,040 --> 00:15:47,680
each neighborhood could have

00:15:44,480 --> 00:15:48,399
or each translation unit which is a

00:15:47,680 --> 00:15:51,199
translation

00:15:48,399 --> 00:15:52,560
is now a union of neighborhoods because

00:15:51,199 --> 00:15:55,440
each neighborhood

00:15:52,560 --> 00:15:56,959
does have a translation unit that

00:15:55,440 --> 00:15:58,240
contains the whole

00:15:56,959 --> 00:16:00,480
thing that contains the whole

00:15:58,240 --> 00:16:03,040
neighborhood

00:16:00,480 --> 00:16:03,680
so each translation unit and or each

00:16:03,040 --> 00:16:08,560
neighborhood

00:16:03,680 --> 00:16:11,839
could have a list of all the definitions

00:16:08,560 --> 00:16:13,199
that it relies on and if we want to see

00:16:11,839 --> 00:16:15,839
if our program

00:16:13,199 --> 00:16:16,639
satisfies the one definition rule well

00:16:15,839 --> 00:16:19,839
we sort

00:16:16,639 --> 00:16:24,000
unique find adjacent and we find

00:16:19,839 --> 00:16:27,759
any places where the same linkage name

00:16:24,000 --> 00:16:31,360
refers to two different definitions

00:16:27,759 --> 00:16:34,560
so in this sense in the technical

00:16:31,360 --> 00:16:37,839
sense the one definition rule

00:16:34,560 --> 00:16:41,360
is entirely diagnosable

00:16:37,839 --> 00:16:43,600
we don't require diagnosis in the

00:16:41,360 --> 00:16:44,639
of the one definition rule in the c plus

00:16:43,600 --> 00:16:47,600
standard

00:16:44,639 --> 00:16:48,160
there are reasons we don't but though

00:16:47,600 --> 00:16:52,160
but

00:16:48,160 --> 00:16:55,440
those reasons are not technical reasons

00:16:52,160 --> 00:16:58,480
about c plus so much as

00:16:55,440 --> 00:17:01,600
reasons about getting along with

00:16:58,480 --> 00:17:02,639
everybody who's using the linker um it

00:17:01,600 --> 00:17:05,760
turns out it's

00:17:02,639 --> 00:17:08,959
really hard to require things to be done

00:17:05,760 --> 00:17:11,439
at length time from the point of view of

00:17:08,959 --> 00:17:14,720
the standards committee

00:17:11,439 --> 00:17:18,160
and there isn't a lot

00:17:14,720 --> 00:17:23,679
of getting together and agreeing to

00:17:18,160 --> 00:17:23,679
improve the link process in this world

00:17:25,120 --> 00:17:32,320
so i explain this not because

00:17:29,440 --> 00:17:32,880
it's difficult it's sort unique find

00:17:32,320 --> 00:17:36,480
adjacent

00:17:32,880 --> 00:17:39,679
it's standard library algorithms here

00:17:36,480 --> 00:17:41,200
um and i don't think it should be very

00:17:39,679 --> 00:17:43,919
surprising

00:17:41,200 --> 00:17:44,640
to any of you that sort unique find

00:17:43,919 --> 00:17:47,840
adjacent

00:17:44,640 --> 00:17:52,400
finds duplicate definitions or

00:17:47,840 --> 00:17:52,400
finds mismatching definitions rather

00:17:52,720 --> 00:17:56,720
but this is an example of how we can

00:17:56,320 --> 00:18:00,559
check

00:17:56,720 --> 00:18:04,880
our global reasoning and

00:18:00,559 --> 00:18:04,880
the example shows us the pattern

00:18:05,200 --> 00:18:12,640
the way we do we can do global reasoning

00:18:09,280 --> 00:18:14,880
is we start with a local phase

00:18:12,640 --> 00:18:15,679
we validate our small neighborhoods we

00:18:14,880 --> 00:18:18,320
can use

00:18:15,679 --> 00:18:20,000
high complexity algorithms to validate

00:18:18,320 --> 00:18:23,039
small neighborhoods

00:18:20,000 --> 00:18:25,679
because the small neighborhoods are

00:18:23,039 --> 00:18:27,520
small and we can get away with applying

00:18:25,679 --> 00:18:30,960
high complexity algorithms to small

00:18:27,520 --> 00:18:33,280
data and

00:18:30,960 --> 00:18:35,840
also in the local phase in the compile

00:18:33,280 --> 00:18:38,080
time phase

00:18:35,840 --> 00:18:39,120
we can describe the neighborhood

00:18:38,080 --> 00:18:43,840
interactions

00:18:39,120 --> 00:18:43,840
in a course manner using small tables

00:18:44,080 --> 00:18:51,039
and then in the global phase in the link

00:18:47,600 --> 00:18:53,520
time phase we can collate

00:18:51,039 --> 00:18:55,600
the small tables into big tables sort

00:18:53,520 --> 00:18:57,760
unique again

00:18:55,600 --> 00:18:58,880
and then we can apply low complexity

00:18:57,760 --> 00:19:00,960
algorithms

00:18:58,880 --> 00:19:02,080
to the table to the tables of

00:19:00,960 --> 00:19:05,600
interactions

00:19:02,080 --> 00:19:09,919
to find out if we have failed some

00:19:05,600 --> 00:19:10,799
global property that we want to maintain

00:19:09,919 --> 00:19:13,919
so

00:19:10,799 --> 00:19:14,799
the global phase uses low complexity

00:19:13,919 --> 00:19:18,000
algorithms

00:19:14,799 --> 00:19:21,360
on big data the local phase uses

00:19:18,000 --> 00:19:24,880
high complexity algorithms on small data

00:19:21,360 --> 00:19:28,160
and this does require a little bit of

00:19:24,880 --> 00:19:31,520
making sure that your program

00:19:28,160 --> 00:19:33,039
fits the model that is if you make huge

00:19:31,520 --> 00:19:34,799
neighborhoods

00:19:33,039 --> 00:19:36,160
you're going to create a problem for the

00:19:34,799 --> 00:19:39,600
model

00:19:36,160 --> 00:19:43,120
if you create small neighborhoods

00:19:39,600 --> 00:19:44,640
that don't ex that don't adequately

00:19:43,120 --> 00:19:48,000
express

00:19:44,640 --> 00:19:51,360
the the global nature of their of

00:19:48,000 --> 00:19:52,480
their interactions you could get a false

00:19:51,360 --> 00:19:56,400
positive

00:19:52,480 --> 00:19:59,240
in the global phase um but

00:19:56,400 --> 00:20:01,120
in gen so this is going to require

00:19:59,240 --> 00:20:02,960
occasionally

00:20:01,120 --> 00:20:04,480
some modification of the structure of

00:20:02,960 --> 00:20:06,559
program functions may have

00:20:04,480 --> 00:20:07,840
have to be broken into two functions in

00:20:06,559 --> 00:20:10,880
some case

00:20:07,840 --> 00:20:12,080
um sometimes different types will have

00:20:10,880 --> 00:20:15,120
to be used

00:20:12,080 --> 00:20:18,960
where one type sufficed before

00:20:15,120 --> 00:20:22,400
but um this

00:20:18,960 --> 00:20:26,320
this is a scalable model of looking

00:20:22,400 --> 00:20:28,080
at global problems because

00:20:26,320 --> 00:20:29,919
we get to use high complexity of

00:20:28,080 --> 00:20:32,720
algorithms locally

00:20:29,919 --> 00:20:33,679
on small data and low complexity

00:20:32,720 --> 00:20:36,559
algorithms

00:20:33,679 --> 00:20:39,760
on big data for the global phase making

00:20:36,559 --> 00:20:42,880
the whole thing quite scalable

00:20:39,760 --> 00:20:45,120
and this sort of thing

00:20:42,880 --> 00:20:46,080
does solve our one definition rule

00:20:45,120 --> 00:20:48,480
problem

00:20:46,080 --> 00:20:49,600
it makes our functions function

00:20:48,480 --> 00:20:53,200
interfaces match

00:20:49,600 --> 00:20:56,320
exactly between the caller

00:20:53,200 --> 00:20:56,320
and the called function

00:20:57,039 --> 00:21:01,360
but there's a hitch there's always a

00:20:59,440 --> 00:21:03,840
hitch

00:21:01,360 --> 00:21:04,880
turns out there's a situation where you

00:21:03,840 --> 00:21:07,679
don't want

00:21:04,880 --> 00:21:08,640
the function interfaces to match exactly

00:21:07,679 --> 00:21:12,320
between the caller

00:21:08,640 --> 00:21:16,320
and the called function because

00:21:12,320 --> 00:21:18,400
a function interface tends to be very

00:21:16,320 --> 00:21:21,840
specific

00:21:18,400 --> 00:21:25,200
a function interface expresses

00:21:21,840 --> 00:21:28,159
the interface to a function ideally

00:21:25,200 --> 00:21:29,039
in such detail that you would know why

00:21:28,159 --> 00:21:32,159
you would use

00:21:29,039 --> 00:21:33,760
this function rather than some other

00:21:32,159 --> 00:21:36,320
function

00:21:33,760 --> 00:21:38,400
so here we have an interface for an

00:21:36,320 --> 00:21:42,080
identity function

00:21:38,400 --> 00:21:42,720
and it act it specifies a property of

00:21:42,080 --> 00:21:45,679
the result

00:21:42,720 --> 00:21:47,120
of the identity function that very few

00:21:45,679 --> 00:21:50,559
other functions

00:21:47,120 --> 00:21:53,120
are going to have so

00:21:50,559 --> 00:21:54,799
here this function interface is very

00:21:53,120 --> 00:21:58,240
specific

00:21:54,799 --> 00:22:01,280
and that's great if i'm calling the um

00:21:58,240 --> 00:22:05,840
identity function directly i get to know

00:22:01,280 --> 00:22:05,840
very much about what's going on inside

00:22:05,919 --> 00:22:09,760
but if i'm writing an identity function

00:22:08,480 --> 00:22:11,840
usually

00:22:09,760 --> 00:22:12,880
i'm using it in some context where i'm

00:22:11,840 --> 00:22:16,240
going to call it

00:22:12,880 --> 00:22:20,000
indirectly and the indirect

00:22:16,240 --> 00:22:23,200
caller wants an interface that fits

00:22:20,000 --> 00:22:25,360
many different functions so

00:22:23,200 --> 00:22:26,520
an example of that is an indirect caller

00:22:25,360 --> 00:22:29,679
that needs a

00:22:26,520 --> 00:22:32,400
non-decreasing function um

00:22:29,679 --> 00:22:32,799
so there are many different functions

00:22:32,400 --> 00:22:35,679
that

00:22:32,799 --> 00:22:36,720
are non-decreasing but there are not

00:22:35,679 --> 00:22:41,840
very many

00:22:36,720 --> 00:22:41,840
functions that are identity functions

00:22:47,360 --> 00:22:54,640
um so this creates a problem

00:22:51,280 --> 00:22:55,520
we have a caller's interface that does

00:22:54,640 --> 00:23:00,159
not

00:22:55,520 --> 00:23:03,520
exactly match our functions interface

00:23:00,159 --> 00:23:06,960
but we want this call to go through

00:23:03,520 --> 00:23:09,600
and we want to not break

00:23:06,960 --> 00:23:11,200
our global reasoning that says

00:23:09,600 --> 00:23:14,720
interfaces have to match

00:23:11,200 --> 00:23:14,720
between translation units

00:23:15,520 --> 00:23:22,400
so let's fiddle with the language a

00:23:18,240 --> 00:23:24,480
little bit to give us a mechanism

00:23:22,400 --> 00:23:26,960
i'm going to call this mechanism

00:23:24,480 --> 00:23:30,559
interface adapters

00:23:26,960 --> 00:23:34,640
it's an indirect caller's interface

00:23:30,559 --> 00:23:38,080
that rather than thought of as fitting

00:23:34,640 --> 00:23:41,600
many functions could perhaps

00:23:38,080 --> 00:23:45,039
be thought of as fit as

00:23:41,600 --> 00:23:48,320
fitting many specific interfaces

00:23:45,039 --> 00:23:51,760
so it's more general than the interface

00:23:48,320 --> 00:23:54,559
of the function that it connects to

00:23:51,760 --> 00:23:56,000
and i'm going to say this works like a

00:23:54,559 --> 00:23:59,679
template

00:23:56,000 --> 00:24:01,600
in that you use non-decreasing here this

00:23:59,679 --> 00:24:04,799
interface adapter you use it

00:24:01,600 --> 00:24:05,600
like a template you instantiate it by

00:24:04,799 --> 00:24:10,559
slapping it

00:24:05,600 --> 00:24:14,480
onto the front of existing functions

00:24:10,559 --> 00:24:17,279
so in this case we could have

00:24:14,480 --> 00:24:19,120
your non-decreasing interface adapter

00:24:17,279 --> 00:24:22,240
and identity

00:24:19,120 --> 00:24:24,799
the function interface the the function

00:24:22,240 --> 00:24:28,720
that we want to connect to

00:24:24,799 --> 00:24:30,840
and we're going to create a new function

00:24:28,720 --> 00:24:32,400
through a mechanism like template

00:24:30,840 --> 00:24:35,679
instantiation

00:24:32,400 --> 00:24:39,120
that has both interfaces in it

00:24:35,679 --> 00:24:41,679
one on top of the other so

00:24:39,120 --> 00:24:43,919
when you call this the prolog of

00:24:41,679 --> 00:24:47,120
non-decreasing can execute

00:24:43,919 --> 00:24:49,600
the prologue of identity can execute

00:24:47,120 --> 00:24:51,200
the implementation of identity of course

00:24:49,600 --> 00:24:53,679
executes

00:24:51,200 --> 00:24:54,640
the epilogue of the identity function

00:24:53,679 --> 00:24:57,840
can execute

00:24:54,640 --> 00:25:01,679
and the of epilogue of non-decreasing

00:24:57,840 --> 00:25:04,240
can execute and so

00:25:01,679 --> 00:25:06,480
all of the conditions that functions are

00:25:04,240 --> 00:25:09,520
relying on

00:25:06,480 --> 00:25:13,360
are being can be tested

00:25:09,520 --> 00:25:16,159
in this path and the reason to do this

00:25:13,360 --> 00:25:18,240
in a template instantiation sort of way

00:25:16,159 --> 00:25:20,960
rather than some sort of conversion that

00:25:18,240 --> 00:25:24,320
replaces the interface

00:25:20,960 --> 00:25:27,440
is that when we instantiate the the

00:25:24,320 --> 00:25:31,840
template we can cre we create

00:25:27,440 --> 00:25:31,840
a new neighborhood of reasoning

00:25:32,080 --> 00:25:36,960
so here we have the adapter

00:25:34,360 --> 00:25:40,840
instantiation neighborhood

00:25:36,960 --> 00:25:43,120
which connects the two interfaces

00:25:40,840 --> 00:25:46,400
together so here

00:25:43,120 --> 00:25:47,600
we have bald guy with a monocle is in

00:25:46,400 --> 00:25:51,039
charge of

00:25:47,600 --> 00:25:52,720
making sure the adaptation came together

00:25:51,039 --> 00:25:56,880
right

00:25:52,720 --> 00:26:00,080
and in his game the outsiders

00:25:56,880 --> 00:26:02,240
the guys with the horns are playing the

00:26:00,080 --> 00:26:05,440
prologue of non-decreasing

00:26:02,240 --> 00:26:09,360
and the epilogue of

00:26:05,440 --> 00:26:10,159
identity whereas it's the monocle guy's

00:26:09,360 --> 00:26:13,279
job

00:26:10,159 --> 00:26:16,400
to make sure that the prologue of

00:26:13,279 --> 00:26:18,000
identity and the epilogue of

00:26:16,400 --> 00:26:20,240
non-decreasing

00:26:18,000 --> 00:26:22,720
will be executed without without any

00:26:20,240 --> 00:26:22,720
problems

00:26:23,039 --> 00:26:30,080
so here we have a new player

00:26:26,640 --> 00:26:34,159
in our game the monocle guy

00:26:30,080 --> 00:26:37,039
is instantiated by whoever puts

00:26:34,159 --> 00:26:38,000
this interf whoever attaches this

00:26:37,039 --> 00:26:41,440
adapter

00:26:38,000 --> 00:26:44,480
to this function and

00:26:41,440 --> 00:26:47,600
can be and so the monocle guy again

00:26:44,480 --> 00:26:50,799
his neighborhood exists in some

00:26:47,600 --> 00:26:54,000
translation unit and can be checked

00:26:50,799 --> 00:26:57,039
at compile time and

00:26:54,000 --> 00:26:59,840
at link time we now have

00:26:57,039 --> 00:27:00,960
the caller talking to the instantiation

00:26:59,840 --> 00:27:03,840
neighborhood

00:27:00,960 --> 00:27:05,520
which in turn talks to the called

00:27:03,840 --> 00:27:10,240
neighborhood

00:27:05,520 --> 00:27:15,279
and we make a three-way bald guy team up

00:27:10,240 --> 00:27:18,480
so the sunglasses guy the caller

00:27:15,279 --> 00:27:21,360
sees the interface of non-decreasing he

00:27:18,480 --> 00:27:24,960
sees the interface that he shares

00:27:21,360 --> 00:27:26,000
with monocle guy and the interface is on

00:27:24,960 --> 00:27:29,120
the nose

00:27:26,000 --> 00:27:32,080
it has the same stream of tokens it has

00:27:29,120 --> 00:27:34,080
the same it refers to the same values it

00:27:32,080 --> 00:27:34,799
refers to the same other linkage names

00:27:34,080 --> 00:27:39,200
it's

00:27:34,799 --> 00:27:39,200
one definition rule exact match

00:27:41,120 --> 00:27:47,919
and the um

00:27:44,720 --> 00:27:48,559
on the right hand side the right hand

00:27:47,919 --> 00:27:52,320
side

00:27:48,559 --> 00:27:55,360
of the um of the

00:27:52,320 --> 00:27:58,399
diagram the monocle guy

00:27:55,360 --> 00:28:01,679
connects directly to

00:27:58,399 --> 00:28:06,000
the guy with the hat and

00:28:01,679 --> 00:28:09,039
they match on the nose in the interface

00:28:06,000 --> 00:28:11,600
of the called function the the detailed

00:28:09,039 --> 00:28:13,279
function interface the interface of

00:28:11,600 --> 00:28:16,320
identity

00:28:13,279 --> 00:28:19,279
so that's our solution for

00:28:16,320 --> 00:28:19,760
situations where we think there's not

00:28:19,279 --> 00:28:22,799
quite

00:28:19,760 --> 00:28:26,480
supposed to be a match we invent

00:28:22,799 --> 00:28:28,880
a new neighborhood that fits in between

00:28:26,480 --> 00:28:30,320
again changing our code a little bit

00:28:28,880 --> 00:28:32,000
perhaps but we

00:28:30,320 --> 00:28:34,000
create a new neighbor in fact changing

00:28:32,000 --> 00:28:36,159
our language a little bit to do this

00:28:34,000 --> 00:28:37,039
we create a new neighborhood that make

00:28:36,159 --> 00:28:40,480
the matches

00:28:37,039 --> 00:28:43,760
on the nodes now there is

00:28:40,480 --> 00:28:46,960
a little detail to this solution

00:28:43,760 --> 00:28:50,640
which is that we do need three kinds

00:28:46,960 --> 00:28:54,000
of uh function adapters because we have

00:28:50,640 --> 00:28:56,960
three kinds of um indirect

00:28:54,000 --> 00:28:57,600
calls all with slightly different syntax

00:28:56,960 --> 00:29:00,320
in c

00:28:57,600 --> 00:29:02,159
plus so we have indirect calls through

00:29:00,320 --> 00:29:03,600
pointers and references to functions the

00:29:02,159 --> 00:29:05,120
ordinary indirection

00:29:03,600 --> 00:29:06,960
we also have indirect calls through

00:29:05,120 --> 00:29:08,960
virtual dispatch

00:29:06,960 --> 00:29:12,880
and we have indirect calls through

00:29:08,960 --> 00:29:14,720
pointers to member functions

00:29:12,880 --> 00:29:16,720
and they all work just a little

00:29:14,720 --> 00:29:20,000
differently from each other

00:29:16,720 --> 00:29:21,120
so we need interfaces we need function

00:29:20,000 --> 00:29:22,559
adapters that work

00:29:21,120 --> 00:29:25,200
just a little differently from each

00:29:22,559 --> 00:29:27,440
other for these three cases

00:29:25,200 --> 00:29:29,600
i will point out that a pointer to

00:29:27,440 --> 00:29:31,760
member function can of course point to a

00:29:29,600 --> 00:29:34,640
virtual function

00:29:31,760 --> 00:29:35,360
and when that happens you're going to

00:29:34,640 --> 00:29:41,840
end up with

00:29:35,360 --> 00:29:41,840
a four-way bald guy team up

00:29:44,480 --> 00:29:50,880
so um

00:29:47,600 --> 00:29:54,720
this idea that

00:29:50,880 --> 00:29:59,440
of functions as things that connect

00:29:54,720 --> 00:30:03,520
interfaces together also leads into

00:29:59,440 --> 00:30:06,080
another non-local problem we might have

00:30:03,520 --> 00:30:07,440
in our program another problem that

00:30:06,080 --> 00:30:11,039
can't be seen

00:30:07,440 --> 00:30:14,080
by any individual bald guy

00:30:11,039 --> 00:30:16,640
so if you think of

00:30:14,080 --> 00:30:17,200
a function neighborhood or an adapter

00:30:16,640 --> 00:30:20,559
neighborhood

00:30:17,200 --> 00:30:24,480
any sort of neighborhood as connecting

00:30:20,559 --> 00:30:27,440
interfaces together you can of course

00:30:24,480 --> 00:30:29,679
see that if you connect enough

00:30:27,440 --> 00:30:32,960
interfaces together

00:30:29,679 --> 00:30:36,880
you may find that an interface ends up

00:30:32,960 --> 00:30:39,919
indirectly relying on itself

00:30:36,880 --> 00:30:43,440
we could have a recursion

00:30:39,919 --> 00:30:47,120
and this is a non-local recursion

00:30:43,440 --> 00:30:48,080
this isn't viewable it isn't possible to

00:30:47,120 --> 00:30:50,320
analyze

00:30:48,080 --> 00:30:51,279
an individual translation unit of the

00:30:50,320 --> 00:30:54,000
program

00:30:51,279 --> 00:30:54,960
to see if the functions in it are

00:30:54,000 --> 00:30:58,159
recursive

00:30:54,960 --> 00:31:01,600
no individual bald guy can

00:30:58,159 --> 00:31:04,720
see that there's a cycle here can no

00:31:01,600 --> 00:31:05,360
bald guy can see the recursion so of

00:31:04,720 --> 00:31:07,760
course

00:31:05,360 --> 00:31:08,720
the recursion can't actually be the

00:31:07,760 --> 00:31:11,919
fault

00:31:08,720 --> 00:31:15,440
of any individual bald guy

00:31:11,919 --> 00:31:15,440
it's a global problem

00:31:17,600 --> 00:31:22,480
and the global problem gets a little

00:31:20,880 --> 00:31:25,440
more complicated

00:31:22,480 --> 00:31:27,120
by the fact that there are two kinds of

00:31:25,440 --> 00:31:30,720
recursion

00:31:27,120 --> 00:31:31,200
there's unbounded recursion which is the

00:31:30,720 --> 00:31:34,480
bad

00:31:31,200 --> 00:31:37,840
kind unbounded recursion might

00:31:34,480 --> 00:31:39,760
go on for a very long time and blow out

00:31:37,840 --> 00:31:43,600
our stack

00:31:39,760 --> 00:31:46,399
um and that would be bad

00:31:43,600 --> 00:31:47,600
bounded recursion on the other hand is a

00:31:46,399 --> 00:31:50,880
kind of recursion

00:31:47,600 --> 00:31:54,480
that most of us at least

00:31:50,880 --> 00:31:58,559
are willing to allow in our programs

00:31:54,480 --> 00:32:01,039
so we need to make us make a distinction

00:31:58,559 --> 00:32:01,600
between unbounded recursion which we

00:32:01,039 --> 00:32:05,039
want to

00:32:01,600 --> 00:32:09,679
get rid of using some global reasoning

00:32:05,039 --> 00:32:13,120
algorithm and bounded recursion

00:32:09,679 --> 00:32:15,600
that we want to allow that we want to

00:32:13,120 --> 00:32:17,519
not complain about when it's in our

00:32:15,600 --> 00:32:20,720
program

00:32:17,519 --> 00:32:21,440
um so the difference between unbounded

00:32:20,720 --> 00:32:24,320
recursion

00:32:21,440 --> 00:32:27,279
and bounded recursion is of course a

00:32:24,320 --> 00:32:31,120
recursion bound

00:32:27,279 --> 00:32:34,559
and the recursion bound here represented

00:32:31,120 --> 00:32:37,840
by distance from the center of this

00:32:34,559 --> 00:32:41,519
of these spirals um

00:32:37,840 --> 00:32:44,720
is something that decreases

00:32:41,519 --> 00:32:46,240
somewhere in every cycle it has to

00:32:44,720 --> 00:32:50,480
decrease

00:32:46,240 --> 00:32:53,679
as you go round and round your spiral

00:32:50,480 --> 00:32:56,399
it also has to never increase because

00:32:53,679 --> 00:32:58,240
you could wipe out all of the progress

00:32:56,399 --> 00:33:00,720
you've made by decreasing by

00:32:58,240 --> 00:33:02,640
increasing it in some other part of the

00:33:00,720 --> 00:33:04,960
spiral

00:33:02,640 --> 00:33:06,480
and the final thing that a recursion

00:33:04,960 --> 00:33:09,679
bound needs

00:33:06,480 --> 00:33:13,200
is to eventually run out a mathematical

00:33:09,679 --> 00:33:17,039
property called well-foundedness

00:33:13,200 --> 00:33:18,960
but eventually run out is really a good

00:33:17,039 --> 00:33:22,159
way to think about it

00:33:18,960 --> 00:33:25,360
um so we want to avoid

00:33:22,159 --> 00:33:26,000
recursion bounds that involve things

00:33:25,360 --> 00:33:29,279
like

00:33:26,000 --> 00:33:30,159
fractions which might not eventually run

00:33:29,279 --> 00:33:32,799
out

00:33:30,159 --> 00:33:33,679
or negative numbers which you can keep

00:33:32,799 --> 00:33:36,000
decreasing

00:33:33,679 --> 00:33:37,120
without actually without ever running

00:33:36,000 --> 00:33:40,080
out

00:33:37,120 --> 00:33:41,360
we want somewhere in our program to be a

00:33:40,080 --> 00:33:42,960
check

00:33:41,360 --> 00:33:44,799
that our recursion bounds the ones we

00:33:42,960 --> 00:33:46,799
are actually using

00:33:44,799 --> 00:33:47,919
will run out we could of course use

00:33:46,799 --> 00:33:50,559
fractions

00:33:47,919 --> 00:33:53,039
as long as we used them in some way that

00:33:50,559 --> 00:33:57,440
would eventually run out

00:33:53,039 --> 00:33:59,360
um so this again

00:33:57,440 --> 00:34:00,640
telling if something is a good recursion

00:33:59,360 --> 00:34:04,240
bound

00:34:00,640 --> 00:34:07,519
is a non-local problem you can tell

00:34:04,240 --> 00:34:09,440
because two of the rules talk about

00:34:07,519 --> 00:34:13,040
something that happens

00:34:09,440 --> 00:34:16,639
um with respect to cycles and cycles

00:34:13,040 --> 00:34:19,679
are non-local in a non-local recursion

00:34:16,639 --> 00:34:23,040
no individual bald guy can see

00:34:19,679 --> 00:34:23,040
a whole cycle

00:34:23,280 --> 00:34:30,480
but there is an aspect of

00:34:27,040 --> 00:34:32,560
those two rules that we can see locally

00:34:30,480 --> 00:34:36,560
and in fact i've color-coded things

00:34:32,560 --> 00:34:40,320
in this picture um to show it

00:34:36,560 --> 00:34:43,599
um we can see locally

00:34:40,320 --> 00:34:45,760
that certain steps certain bald guys

00:34:43,599 --> 00:34:47,359
making a connection from one interface

00:34:45,760 --> 00:34:50,560
to another

00:34:47,359 --> 00:34:52,240
um will always decrease

00:34:50,560 --> 00:34:53,760
the recursion count because that's

00:34:52,240 --> 00:34:58,320
that's a local problem it is

00:34:53,760 --> 00:34:58,320
within the domain of one bald guy

00:34:58,560 --> 00:35:02,079
there are also steps that might increase

00:35:01,280 --> 00:35:06,800
a recursion

00:35:02,079 --> 00:35:08,720
bound and again that's a local problem

00:35:06,800 --> 00:35:10,400
seeing whether the step increases the

00:35:08,720 --> 00:35:12,800
recursion bound

00:35:10,400 --> 00:35:13,599
is something that is in the domain of

00:35:12,800 --> 00:35:16,640
one step

00:35:13,599 --> 00:35:19,200
of one bald guy connecting one interface

00:35:16,640 --> 00:35:19,200
to another

00:35:19,440 --> 00:35:25,520
so i'm going to use these two symbols

00:35:22,560 --> 00:35:26,400
the green check mark and the red do not

00:35:25,520 --> 00:35:29,839
cycle

00:35:26,400 --> 00:35:32,480
sign um to indicate

00:35:29,839 --> 00:35:34,240
these two kinds of steps steps that

00:35:32,480 --> 00:35:37,040
locally are shown

00:35:34,240 --> 00:35:38,960
to always decrease the recursion bound

00:35:37,040 --> 00:35:40,880
get the green check mark because every

00:35:38,960 --> 00:35:43,280
cycle needs one

00:35:40,880 --> 00:35:44,000
and steps that might increase the

00:35:43,280 --> 00:35:47,200
recursion

00:35:44,000 --> 00:35:51,119
bound get the red mark

00:35:47,200 --> 00:35:53,440
because they are not allowed in cycles

00:35:51,119 --> 00:35:54,960
and using these two marks we can put

00:35:53,440 --> 00:35:59,119
together our strategy

00:35:54,960 --> 00:36:02,320
for global reasoning

00:35:59,119 --> 00:36:06,240
so here we have in our

00:36:02,320 --> 00:36:08,640
local phase um we will

00:36:06,240 --> 00:36:09,760
set the problem of making sure the

00:36:08,640 --> 00:36:11,359
recursion bound

00:36:09,760 --> 00:36:14,320
eventually runs out we'll set that as a

00:36:11,359 --> 00:36:17,520
local problem we'll get back to that

00:36:14,320 --> 00:36:20,400
um but in our local phase we will also

00:36:17,520 --> 00:36:21,839
compile lists of the steps that connect

00:36:20,400 --> 00:36:24,560
interfaces that is

00:36:21,839 --> 00:36:25,520
each neighborhood as we compile it we

00:36:24,560 --> 00:36:28,240
will say

00:36:25,520 --> 00:36:29,520
it it makes connections between its

00:36:28,240 --> 00:36:33,359
interface

00:36:29,520 --> 00:36:36,640
and these other interfaces

00:36:33,359 --> 00:36:39,040
um and we will mark the ones that

00:36:36,640 --> 00:36:40,240
possibly increase the recursion bound

00:36:39,040 --> 00:36:42,320
with the red mark

00:36:40,240 --> 00:36:44,560
we will mark the ones that necessarily

00:36:42,320 --> 00:36:47,760
decrease the recursion bound

00:36:44,560 --> 00:36:47,760
with the green mark

00:36:48,160 --> 00:36:53,359
and again local phase not really our

00:36:51,839 --> 00:36:54,720
problem today

00:36:53,359 --> 00:36:57,280
today we're here to talk about the

00:36:54,720 --> 00:37:00,640
global phase where we check that no

00:36:57,280 --> 00:37:05,760
cycle contains a step with the red mark

00:37:00,640 --> 00:37:08,400
and we check that um

00:37:05,760 --> 00:37:10,400
uh so i'm getting some questions i'm

00:37:08,400 --> 00:37:11,040
going to take questions at the end thank

00:37:10,400 --> 00:37:14,720
you

00:37:11,040 --> 00:37:17,359
uh so we check that every cycle

00:37:14,720 --> 00:37:19,599
contains a step marked with the green

00:37:17,359 --> 00:37:25,599
mark

00:37:19,599 --> 00:37:30,000
um so at the end of our local phase

00:37:25,599 --> 00:37:32,720
we have a list like this

00:37:30,000 --> 00:37:35,520
um or a number of lists like this

00:37:32,720 --> 00:37:38,960
individual neighborhoods compile lists

00:37:35,520 --> 00:37:41,200
of what interfaces

00:37:38,960 --> 00:37:42,640
they see connecting to what other

00:37:41,200 --> 00:37:46,160
interfaces

00:37:42,640 --> 00:37:49,280
and these connections can take a number

00:37:46,160 --> 00:37:52,640
of um different

00:37:49,280 --> 00:37:55,200
forms in direct function calls we are

00:37:52,640 --> 00:37:56,079
connecting something to a function

00:37:55,200 --> 00:37:58,320
interface

00:37:56,079 --> 00:38:00,000
and the caller may have its own

00:37:58,320 --> 00:38:02,320
interface or it might be

00:38:00,000 --> 00:38:04,000
um it might be called from inside an

00:38:02,320 --> 00:38:07,839
interface or it might be called from

00:38:04,000 --> 00:38:09,119
inside an adapter indirect function

00:38:07,839 --> 00:38:12,320
calls connect things

00:38:09,119 --> 00:38:15,440
to adapters as we saw before and

00:38:12,320 --> 00:38:18,720
the adapter implementation point

00:38:15,440 --> 00:38:21,520
can connect you know connects

00:38:18,720 --> 00:38:23,520
an adapter to an interface or in some

00:38:21,520 --> 00:38:24,480
cases when reforming the big bald guy

00:38:23,520 --> 00:38:27,599
team ups

00:38:24,480 --> 00:38:28,880
um we connect an adapter to another

00:38:27,599 --> 00:38:32,560
adapter

00:38:28,880 --> 00:38:37,839
so all of those count as arrows

00:38:32,560 --> 00:38:37,839
to put in our tables of arrows over here

00:38:37,920 --> 00:38:41,200
and so these are the connections we've

00:38:40,000 --> 00:38:44,560
marked some of them

00:38:41,200 --> 00:38:45,280
with red and green marks and then we can

00:38:44,560 --> 00:38:48,960
go to

00:38:45,280 --> 00:38:51,760
our global phase and in the global phase

00:38:48,960 --> 00:38:52,800
as usual sort unique starts our global

00:38:51,760 --> 00:38:55,839
phase

00:38:52,800 --> 00:38:58,079
and we have a big table of

00:38:55,839 --> 00:39:00,560
of arrows and what do you do with a big

00:38:58,079 --> 00:39:04,720
table of arrows while you make a graph

00:39:00,560 --> 00:39:04,720
i'm going to start by making a forest

00:39:04,880 --> 00:39:13,599
what i'm going to do is build a forest

00:39:08,640 --> 00:39:16,880
top to bottom depth first left to right

00:39:13,599 --> 00:39:18,079
and i'm going to throw arrows into the

00:39:16,880 --> 00:39:21,760
forest

00:39:18,079 --> 00:39:25,040
as long as they don't break the forest

00:39:21,760 --> 00:39:26,000
property and the so not breaking the

00:39:25,040 --> 00:39:29,280
forest property is

00:39:26,000 --> 00:39:31,920
means i have to skip arrows

00:39:29,280 --> 00:39:33,520
that go back to some place i've already

00:39:31,920 --> 00:39:36,079
been

00:39:33,520 --> 00:39:39,040
so that's how i have built this forest

00:39:36,079 --> 00:39:41,520
which has just one tree in it

00:39:39,040 --> 00:39:42,240
um the arrows that go to places i've

00:39:41,520 --> 00:39:47,200
already been

00:39:42,240 --> 00:39:50,240
coming sorry come in three kinds

00:39:47,200 --> 00:39:53,760
um one kind

00:39:50,240 --> 00:39:57,839
is a downward arrow it runs

00:39:53,760 --> 00:40:01,040
parallel to some path in the forest

00:39:57,839 --> 00:40:02,119
there are also the opposite upward

00:40:01,040 --> 00:40:05,359
arrows that run

00:40:02,119 --> 00:40:09,119
anti-parallel to some path in the forest

00:40:05,359 --> 00:40:12,160
and i'm going to include simple loops as

00:40:09,119 --> 00:40:15,520
upward arrows so simple loops

00:40:12,160 --> 00:40:16,640
and things that run anti-parallel to a

00:40:15,520 --> 00:40:20,400
path in the forest

00:40:16,640 --> 00:40:22,160
are upward arrows and the remaining

00:40:20,400 --> 00:40:25,599
arrows

00:40:22,160 --> 00:40:28,240
are leftward that is they connect

00:40:25,599 --> 00:40:29,200
one tree to another tree in the forest

00:40:28,240 --> 00:40:31,520
or they connect

00:40:29,200 --> 00:40:33,119
one branch of a tree to another branch

00:40:31,520 --> 00:40:36,319
of the same tree

00:40:33,119 --> 00:40:38,880
but they always go to the left

00:40:36,319 --> 00:40:40,319
because they go to some place we had

00:40:38,880 --> 00:40:43,680
already been

00:40:40,319 --> 00:40:47,359
when we got to their tail and that means

00:40:43,680 --> 00:40:50,400
to the left um

00:40:47,359 --> 00:40:53,839
so now that we've categorized

00:40:50,400 --> 00:40:53,839
these three kinds of arrows

00:40:53,920 --> 00:40:58,560
we can treat them individually

00:41:00,160 --> 00:41:06,800
upward arrows always fall i add

00:41:03,520 --> 00:41:09,920
some add a cycle to our forest

00:41:06,800 --> 00:41:12,000
as we put them in so

00:41:09,920 --> 00:41:14,240
we'll go through the upward arrows and

00:41:12,000 --> 00:41:16,800
mark the upward arrows

00:41:14,240 --> 00:41:18,160
and the arrows of the forest that they

00:41:16,800 --> 00:41:20,960
are anti-parallel to

00:41:18,160 --> 00:41:23,520
with cycle marks these are parts of a

00:41:20,960 --> 00:41:26,800
recursion

00:41:23,520 --> 00:41:29,920
then we'll come to the leftward arrows

00:41:26,800 --> 00:41:33,760
and we'll take each leftward arrow

00:41:29,920 --> 00:41:35,119
and see it doesn't create a cycle on its

00:41:33,760 --> 00:41:38,720
own

00:41:35,119 --> 00:41:42,640
but it can extend some existing cycle

00:41:38,720 --> 00:41:45,920
so if a leftward arrow forms a triangle

00:41:42,640 --> 00:41:49,040
by remaining inside a single tree

00:41:45,920 --> 00:41:52,480
and the left side of that triangle

00:41:49,040 --> 00:41:55,440
already has a cycle mark

00:41:52,480 --> 00:41:56,800
then we will put cycle marks on the

00:41:55,440 --> 00:42:00,000
right side of the triangle

00:41:56,800 --> 00:42:02,240
and on the leftward arrow now this rule

00:42:00,000 --> 00:42:06,079
can chain

00:42:02,240 --> 00:42:09,359
so um we have to apply it

00:42:06,079 --> 00:42:11,280
left to right because it chains

00:42:09,359 --> 00:42:13,280
left to right we can apply it in one

00:42:11,280 --> 00:42:16,400
pass as long as we

00:42:13,280 --> 00:42:19,520
apply it left to right

00:42:16,400 --> 00:42:21,440
and finally we look

00:42:19,520 --> 00:42:23,359
at the downward arrows and the downward

00:42:21,440 --> 00:42:26,240
arrows participate in a cycle

00:42:23,359 --> 00:42:27,680
only if the arrows they run of the tree

00:42:26,240 --> 00:42:30,720
that they run parallel to

00:42:27,680 --> 00:42:33,599
all participate in a cycle

00:42:30,720 --> 00:42:35,760
so rule one rule two rule three apply

00:42:33,599 --> 00:42:36,960
those in order apply rule two left to

00:42:35,760 --> 00:42:40,560
right

00:42:36,960 --> 00:42:41,520
and we have identified all the cycle

00:42:40,560 --> 00:42:44,400
marks

00:42:41,520 --> 00:42:46,079
all the arrows that participate in

00:42:44,400 --> 00:42:51,359
recursion

00:42:46,079 --> 00:42:54,560
in our graph and having done that

00:42:51,359 --> 00:42:57,680
we can compare it back to our list find

00:42:54,560 --> 00:43:00,800
the arrows that have cycle marks

00:42:57,680 --> 00:43:02,640
but also can increase the recursion

00:43:00,800 --> 00:43:05,440
bound

00:43:02,640 --> 00:43:06,400
so here that downward arrow that

00:43:05,440 --> 00:43:08,319
increases the

00:43:06,400 --> 00:43:09,440
that can increase the recursion bound is

00:43:08,319 --> 00:43:12,960
a problem

00:43:09,440 --> 00:43:14,720
because it's part of a cycle

00:43:12,960 --> 00:43:16,240
the other arrows with red marks are not

00:43:14,720 --> 00:43:17,359
part of a problem they increase the

00:43:16,240 --> 00:43:20,000
recursion bound

00:43:17,359 --> 00:43:21,520
but what they're doing is setting up a

00:43:20,000 --> 00:43:24,560
recursion bound

00:43:21,520 --> 00:43:27,680
for the recursive part of the program

00:43:24,560 --> 00:43:29,680
to decrease so that's fine

00:43:27,680 --> 00:43:31,599
increasing the recursion bound is fine

00:43:29,680 --> 00:43:34,240
and in fact expected

00:43:31,599 --> 00:43:35,599
when you're setting up a recursion but

00:43:34,240 --> 00:43:39,280
during a recursion

00:43:35,599 --> 00:43:39,280
you want to keep it going downward

00:43:39,760 --> 00:43:46,800
so that enforces our red rule

00:43:43,040 --> 00:43:48,319
we find all the cycles uh maybe you have

00:43:46,800 --> 00:43:50,400
been through a graph theory course and

00:43:48,319 --> 00:43:53,440
you know a better way to find cycles

00:43:50,400 --> 00:43:57,040
it's not hard to find cycles um

00:43:53,440 --> 00:44:00,160
but this um algorithm

00:43:57,040 --> 00:44:01,359
finds our cycles finds the pl and can

00:44:00,160 --> 00:44:03,839
compare them

00:44:01,359 --> 00:44:05,760
against the places that may increase the

00:44:03,839 --> 00:44:08,400
recursion bound

00:44:05,760 --> 00:44:09,119
the green rule is pretty similar but we

00:44:08,400 --> 00:44:11,440
start

00:44:09,119 --> 00:44:12,240
with the green checking the green rule

00:44:11,440 --> 00:44:15,359
by

00:44:12,240 --> 00:44:18,400
throwing all that work away so that

00:44:15,359 --> 00:44:22,480
we're back to just our list

00:44:18,400 --> 00:44:23,920
then we strike the green arrows off of

00:44:22,480 --> 00:44:25,520
the list

00:44:23,920 --> 00:44:27,839
and we build a new forest just like

00:44:25,520 --> 00:44:30,079
before now

00:44:27,839 --> 00:44:32,160
this one looks very much like before

00:44:30,079 --> 00:44:34,839
because i cheated and picked an example

00:44:32,160 --> 00:44:36,560
that didn't involve drawing a lot of new

00:44:34,839 --> 00:44:38,640
stuff

00:44:36,560 --> 00:44:41,119
in general your forest may look rather

00:44:38,640 --> 00:44:41,119
different

00:44:41,839 --> 00:44:45,680
but in my example it looks pretty much

00:44:44,079 --> 00:44:48,720
the same

00:44:45,680 --> 00:44:51,119
once we have drawn the forest we

00:44:48,720 --> 00:44:52,240
run through rule one rule two and rule

00:44:51,119 --> 00:44:54,960
three

00:44:52,240 --> 00:44:55,440
and we find any cycles that are left

00:44:54,960 --> 00:44:58,240
those

00:44:55,440 --> 00:44:59,520
are cycles that have nothing marked with

00:44:58,240 --> 00:45:03,119
the green mark

00:44:59,520 --> 00:45:06,000
that's a bad cycle that

00:45:03,119 --> 00:45:06,720
does not decrease the recursion bound it

00:45:06,000 --> 00:45:08,960
can keep on

00:45:06,720 --> 00:45:10,079
it can be unbounded because the

00:45:08,960 --> 00:45:14,400
recursion bound

00:45:10,079 --> 00:45:14,400
doesn't decrease during the cycle

00:45:14,640 --> 00:45:19,119
so that's how we do the global reasoning

00:45:18,319 --> 00:45:22,000
part of this

00:45:19,119 --> 00:45:22,880
it's simple graph algorithms soup to

00:45:22,000 --> 00:45:25,920
nuts

00:45:22,880 --> 00:45:29,280
the whole thing is n log n

00:45:25,920 --> 00:45:33,839
um so low complexity we can apply it to

00:45:29,280 --> 00:45:33,839
big data

00:45:34,079 --> 00:45:40,720
but you may be

00:45:37,520 --> 00:45:44,240
a little disappointed that i didn't

00:45:40,720 --> 00:45:47,359
talk about really what a recursion bound

00:45:44,240 --> 00:45:49,440
is um that is

00:45:47,359 --> 00:45:52,640
i talked about how it has to work

00:45:49,440 --> 00:45:55,760
mathematically it had those three rules

00:45:52,640 --> 00:45:56,560
but i didn't tell you how to spot it in

00:45:55,760 --> 00:45:59,839
code

00:45:56,560 --> 00:46:03,119
how our neighborhoods agree

00:45:59,839 --> 00:46:05,040
on what the recursion bounds are

00:46:03,119 --> 00:46:07,040
and whether they're increasing or

00:46:05,040 --> 00:46:09,040
possibly increasing or necessarily

00:46:07,040 --> 00:46:11,839
decreasing

00:46:09,040 --> 00:46:13,280
so i will get into the local thing a

00:46:11,839 --> 00:46:16,560
little bit

00:46:13,280 --> 00:46:20,560
um so here is an example of

00:46:16,560 --> 00:46:24,240
a recursive function i count recursively

00:46:20,560 --> 00:46:27,200
which counts a sequence in

00:46:24,240 --> 00:46:28,960
pretty much the one of the worst ways

00:46:27,200 --> 00:46:34,960
imaginable

00:46:28,960 --> 00:46:38,319
um but it is a nice example of recursion

00:46:34,960 --> 00:46:42,480
um because it counts

00:46:38,319 --> 00:46:46,000
its tail recursively um now

00:46:42,480 --> 00:46:49,760
the recursion bound needs to be

00:46:46,000 --> 00:46:52,720
specified in the interface of a function

00:46:49,760 --> 00:46:54,400
because the interfaces are where the

00:46:52,720 --> 00:46:56,720
different neighborhoods are going to

00:46:54,400 --> 00:46:59,280
find agreement

00:46:56,720 --> 00:47:01,200
so let's add an interface to count

00:46:59,280 --> 00:47:05,040
recursively

00:47:01,200 --> 00:47:06,000
um here again i've just sort of shoved

00:47:05,040 --> 00:47:08,839
it off on

00:47:06,000 --> 00:47:10,240
some other piece of text because pretty

00:47:08,839 --> 00:47:12,880
obviously um

00:47:10,240 --> 00:47:14,079
my recursion bound needs to be specified

00:47:12,880 --> 00:47:17,359
by this thing

00:47:14,079 --> 00:47:18,319
recursively reachable that is being

00:47:17,359 --> 00:47:20,800
asserted

00:47:18,319 --> 00:47:22,880
in the prologue to this function it's

00:47:20,800 --> 00:47:25,599
recursively reachable

00:47:22,880 --> 00:47:27,440
is something that is a precondition for

00:47:25,599 --> 00:47:30,880
the function

00:47:27,440 --> 00:47:32,000
and somehow this precondition has to

00:47:30,880 --> 00:47:35,920
express

00:47:32,000 --> 00:47:39,119
what the recursion bound is

00:47:35,920 --> 00:47:42,559
and um this part

00:47:39,119 --> 00:47:45,920
fairly straightforward but uh

00:47:42,559 --> 00:47:46,400
you know and you could plug in more or

00:47:45,920 --> 00:47:48,800
less

00:47:46,400 --> 00:47:50,319
anything here that has the right

00:47:48,800 --> 00:47:53,760
properties

00:47:50,319 --> 00:47:55,119
but i do have a favorite thing to plug

00:47:53,760 --> 00:47:57,760
in here

00:47:55,119 --> 00:47:58,800
um so i'm going to show you my favorite

00:47:57,760 --> 00:48:02,319
way to express

00:47:58,800 --> 00:48:05,359
a recursion bound um and

00:48:02,319 --> 00:48:06,000
i kind of hope that if this ever gets

00:48:05,359 --> 00:48:09,280
deployed

00:48:06,000 --> 00:48:11,440
out to real languages this is how

00:48:09,280 --> 00:48:14,079
recursion bounds are going to be

00:48:11,440 --> 00:48:14,079
expressed

00:48:14,400 --> 00:48:19,200
here we have a claimable function it's a

00:48:17,040 --> 00:48:22,160
thing you can assert

00:48:19,200 --> 00:48:23,680
and when you assert a claimable function

00:48:22,160 --> 00:48:27,119
you are you are asserting

00:48:23,680 --> 00:48:31,599
that the execution of this function

00:48:27,119 --> 00:48:35,040
will succeed and return to its caller

00:48:31,599 --> 00:48:38,200
uh and this particular

00:48:35,040 --> 00:48:41,520
claimable function is

00:48:38,200 --> 00:48:45,040
recursively entailing itself

00:48:41,520 --> 00:48:48,160
that is recursively reachable is itself

00:48:45,040 --> 00:48:50,319
a recursive function so it sounds like

00:48:48,160 --> 00:48:53,839
i'm cheating

00:48:50,319 --> 00:48:57,200
but i have added the word inline to this

00:48:53,839 --> 00:49:00,160
function inline functions as i said

00:48:57,200 --> 00:49:01,040
about 30 minutes ago i'm going to

00:49:00,160 --> 00:49:04,000
consider

00:49:01,040 --> 00:49:05,599
part of the neighborhood that is calling

00:49:04,000 --> 00:49:08,559
them

00:49:05,599 --> 00:49:11,119
so recursively reach all of the

00:49:08,559 --> 00:49:14,319
iterations down recursively reachable

00:49:11,119 --> 00:49:17,839
are local to any

00:49:14,319 --> 00:49:20,880
function that calls count recursively

00:49:17,839 --> 00:49:22,800
it sees the whole recursion in its

00:49:20,880 --> 00:49:26,160
neighborhood

00:49:22,800 --> 00:49:29,599
and so any function that

00:49:26,160 --> 00:49:33,119
calls count recursively has to get

00:49:29,599 --> 00:49:37,040
through the prologue and has to

00:49:33,119 --> 00:49:37,760
find a a path that makes recursively

00:49:37,040 --> 00:49:40,480
reachable

00:49:37,760 --> 00:49:43,599
return just in order to get to the

00:49:40,480 --> 00:49:46,960
implementation of count recursively

00:49:43,599 --> 00:49:50,400
um so in doing so

00:49:46,960 --> 00:49:53,920
the calling function is showing

00:49:50,400 --> 00:49:56,720
that the recursion eventually runs out

00:49:53,920 --> 00:49:58,000
property three of recursion bounds they

00:49:56,720 --> 00:50:01,119
eventually run

00:49:58,000 --> 00:50:03,040
out so this is just loading a whole

00:50:01,119 --> 00:50:04,240
recursion into a single neighborhood so

00:50:03,040 --> 00:50:07,680
that it can be looked at

00:50:04,240 --> 00:50:09,359
by local reasoning which is not our

00:50:07,680 --> 00:50:12,240
problem today

00:50:09,359 --> 00:50:12,960
um the actual mechanism of looking at

00:50:12,240 --> 00:50:16,079
that

00:50:12,960 --> 00:50:16,640
is fairly ordinary for local reasoning

00:50:16,079 --> 00:50:19,440
because

00:50:16,640 --> 00:50:20,880
it's just matching branches against

00:50:19,440 --> 00:50:24,559
branches

00:50:20,880 --> 00:50:27,440
to see if the uh to to see

00:50:24,559 --> 00:50:29,520
if the recursion um is going to

00:50:27,440 --> 00:50:32,720
terminate

00:50:29,520 --> 00:50:35,040
so and local reasoning is all about

00:50:32,720 --> 00:50:36,960
being able to tell that certain branches

00:50:35,040 --> 00:50:39,119
will go the same direction as certain

00:50:36,960 --> 00:50:42,160
other branches

00:50:39,119 --> 00:50:45,440
so when we look at this um

00:50:42,160 --> 00:50:46,800
from the caller's point of view in order

00:50:45,440 --> 00:50:50,160
to

00:50:46,800 --> 00:50:53,200
assert recursively reachable the caller

00:50:50,160 --> 00:50:56,559
has to provide the spiral

00:50:53,200 --> 00:51:00,160
that makes recursively reachable end so

00:50:56,559 --> 00:51:02,160
it sh you and there's just this list

00:51:00,160 --> 00:51:03,280
of this called this called this called

00:51:02,160 --> 00:51:07,200
this

00:51:03,280 --> 00:51:10,240
um that the caller has to see

00:51:07,200 --> 00:51:13,680
before it can get to before the test

00:51:10,240 --> 00:51:16,720
of can can succeed or before

00:51:13,680 --> 00:51:19,920
local or it has to show that it exists

00:51:16,720 --> 00:51:23,040
in order to form a proof that the that

00:51:19,920 --> 00:51:27,440
this local recursion is going to end

00:51:23,040 --> 00:51:30,559
um now of course one of the callers

00:51:27,440 --> 00:51:32,559
of recursively reach of uh recursive of

00:51:30,559 --> 00:51:34,640
count recursively

00:51:32,559 --> 00:51:37,920
one of the callers account recursively

00:51:34,640 --> 00:51:41,520
is count recursively itself

00:51:37,920 --> 00:51:45,680
count recursively has to show a spiral

00:51:41,520 --> 00:51:47,680
every time it calls itself

00:51:45,680 --> 00:51:48,800
and what count recursively is going to

00:51:47,680 --> 00:51:52,400
do

00:51:48,800 --> 00:51:55,920
is take the spiral it was given

00:51:52,400 --> 00:52:00,559
and when it calls itself it will show

00:51:55,920 --> 00:52:03,599
a sub-spiral of the spiral it was given

00:52:00,559 --> 00:52:05,359
so it keeps showing smaller and smaller

00:52:03,599 --> 00:52:06,160
spirals and we know they're smaller

00:52:05,359 --> 00:52:09,200
because

00:52:06,160 --> 00:52:12,319
they were actually nested within

00:52:09,200 --> 00:52:14,880
the spiral in its interface

00:52:12,319 --> 00:52:16,160
they are matched branch for branch

00:52:14,880 --> 00:52:19,440
identical

00:52:16,160 --> 00:52:22,160
because it's passive it's doing

00:52:19,440 --> 00:52:25,119
the same thing that was in its interface

00:52:22,160 --> 00:52:28,240
everything is substitutable

00:52:25,119 --> 00:52:30,160
so count recursively called it takes the

00:52:28,240 --> 00:52:32,559
spiral its interface

00:52:30,160 --> 00:52:33,520
and calls itself with a piece of that

00:52:32,559 --> 00:52:37,200
spiral

00:52:33,520 --> 00:52:39,200
that's decreasing the recursion bound

00:52:37,200 --> 00:52:41,920
um increasing the recursion bound would

00:52:39,200 --> 00:52:42,480
be creating some new spiral that can't

00:52:41,920 --> 00:52:45,599
be matched

00:52:42,480 --> 00:52:48,880
branch for branch with something in the

00:52:45,599 --> 00:52:51,839
spirals you were given in your prologue

00:52:48,880 --> 00:52:53,520
um so possibly a piece of it could be i

00:52:51,839 --> 00:52:55,599
might make a bigger spiral

00:52:53,520 --> 00:52:56,880
that would be increasing i might create

00:52:55,599 --> 00:53:00,000
a new spiral

00:52:56,880 --> 00:53:03,599
that would be increasing but

00:53:00,000 --> 00:53:05,680
if i take a piece but not all

00:53:03,599 --> 00:53:07,359
of the spirals i was given it pass them

00:53:05,680 --> 00:53:11,680
to another function

00:53:07,359 --> 00:53:14,559
that's decreasing if i take every spiral

00:53:11,680 --> 00:53:15,760
that i was given in full and pass them

00:53:14,559 --> 00:53:19,760
to another function

00:53:15,760 --> 00:53:19,760
that's neither increasing nor decreasing

00:53:20,079 --> 00:53:27,599
um now the reason i think this is a

00:53:23,280 --> 00:53:30,720
great way to represent recursion bounds

00:53:27,599 --> 00:53:34,559
is that it's effectively building

00:53:30,720 --> 00:53:36,480
a model of the recursion you intend to

00:53:34,559 --> 00:53:39,680
make

00:53:36,480 --> 00:53:40,800
so in order to call count recursively at

00:53:39,680 --> 00:53:43,839
all

00:53:40,800 --> 00:53:46,880
i have to build a model

00:53:43,839 --> 00:53:48,000
of the of the recursion in count

00:53:46,880 --> 00:53:51,520
recursively

00:53:48,000 --> 00:53:54,480
and each time we go around the cycle

00:53:51,520 --> 00:53:55,680
each time we call some further function

00:53:54,480 --> 00:53:58,160
the cycle we pass

00:53:55,680 --> 00:53:58,880
the model and at certain points in the

00:53:58,160 --> 00:54:01,200
cycle

00:53:58,880 --> 00:54:02,880
we cut off part of the model and pass a

00:54:01,200 --> 00:54:06,559
smaller piece

00:54:02,880 --> 00:54:07,040
of the model and eventually because the

00:54:06,559 --> 00:54:10,559
model

00:54:07,040 --> 00:54:10,880
had to run out because this was actually

00:54:10,559 --> 00:54:13,359
a

00:54:10,880 --> 00:54:15,040
test that was done in the neighborhood

00:54:13,359 --> 00:54:17,040
that originally entered count

00:54:15,040 --> 00:54:20,000
recursively

00:54:17,040 --> 00:54:22,559
we know that eventually as we keep

00:54:20,000 --> 00:54:25,839
decreasing the size of this model

00:54:22,559 --> 00:54:25,839
we run out of pieces

00:54:26,160 --> 00:54:32,960
and that idea

00:54:29,280 --> 00:54:36,160
can be fit neatly into a number of

00:54:32,960 --> 00:54:38,079
other sorts of interfaces you can fit it

00:54:36,160 --> 00:54:40,559
to the particular recursion

00:54:38,079 --> 00:54:41,680
you need if you need a tree-shaped

00:54:40,559 --> 00:54:44,400
recursion

00:54:41,680 --> 00:54:46,720
you can write a tree-shaped recursion

00:54:44,400 --> 00:54:50,839
bound

00:54:46,720 --> 00:54:53,760
and if you need a

00:54:50,839 --> 00:54:55,839
um i think something may have gone wrong

00:54:53,760 --> 00:54:57,440
with my slides ah there we go

00:54:55,839 --> 00:55:00,400
here i will show the tree shaped

00:54:57,440 --> 00:55:00,400
recursion bound again

00:55:00,480 --> 00:55:03,760
if you need a tree shaped recursion you

00:55:02,720 --> 00:55:07,839
can have

00:55:03,760 --> 00:55:07,839
a tree shaped recursion bound

00:55:08,880 --> 00:55:12,480
if you want a two-phase recursion you

00:55:11,680 --> 00:55:15,440
can have

00:55:12,480 --> 00:55:15,920
a two-phase recursion bound by having

00:55:15,440 --> 00:55:18,000
two

00:55:15,920 --> 00:55:21,280
in-line claimable functions each

00:55:18,000 --> 00:55:24,319
entailing the other

00:55:21,280 --> 00:55:28,640
so this sort of thing

00:55:24,319 --> 00:55:28,640
um lets me um

00:55:28,880 --> 00:55:35,359
lets me create a model that matches the

00:55:31,839 --> 00:55:39,040
problem at hand

00:55:35,359 --> 00:55:40,000
and that's actually on a much larger

00:55:39,040 --> 00:55:44,720
scale

00:55:40,000 --> 00:55:48,160
almost a theme in my intellectual life

00:55:44,720 --> 00:55:51,280
which is this represent like

00:55:48,160 --> 00:55:54,880
with like um

00:55:51,280 --> 00:55:58,480
if you are given a choice between

00:55:54,880 --> 00:56:02,160
two representations of the same thing

00:55:58,480 --> 00:56:04,720
one of which has a lot of linguistic

00:56:02,160 --> 00:56:05,359
noise a lot of linguistic distance

00:56:04,720 --> 00:56:08,799
between

00:56:05,359 --> 00:56:12,240
it and the thing you want to represent

00:56:08,799 --> 00:56:14,960
and the other is very like the thing you

00:56:12,240 --> 00:56:17,359
want to represent

00:56:14,960 --> 00:56:19,040
if you want to be clear if you want to

00:56:17,359 --> 00:56:22,160
be clear in your thinking if you want to

00:56:19,040 --> 00:56:25,359
be clear in your explanations

00:56:22,160 --> 00:56:28,640
you are do well to represent like

00:56:25,359 --> 00:56:31,760
with like um

00:56:28,640 --> 00:56:35,040
now the latin

00:56:31,760 --> 00:56:35,920
while it lacks a certain clarity does

00:56:35,040 --> 00:56:37,839
make up for that

00:56:35,920 --> 00:56:39,680
in obscurity and if you want an

00:56:37,839 --> 00:56:43,040
enigmatic way to end your novel

00:56:39,680 --> 00:56:45,280
sure go with the latin but if you want

00:56:43,040 --> 00:56:50,720
to think clearly if you want to explain

00:56:45,280 --> 00:56:55,680
clearly represent like with like

00:56:50,720 --> 00:56:58,880
and on that note thank you for listening

00:56:55,680 --> 00:57:01,520
are there any questions i'll be looking

00:56:58,880 --> 00:57:01,520
at the chat

00:57:06,900 --> 00:57:11,680
[Music]

00:57:08,559 --> 00:57:14,079
ah somebody asked since memory addresses

00:57:11,680 --> 00:57:15,520
are just 64-bit integers wouldn't that

00:57:14,079 --> 00:57:18,720
mean technically

00:57:15,520 --> 00:57:20,480
any pointer is reachable from any other

00:57:18,720 --> 00:57:23,680
pointer

00:57:20,480 --> 00:57:27,599
uh okay there are

00:57:23,680 --> 00:57:30,799
two different ideas of reachable in play

00:57:27,599 --> 00:57:34,640
for they're similar um here

00:57:30,799 --> 00:57:37,760
um and in general i would say

00:57:34,640 --> 00:57:39,359
no um but the

00:57:37,760 --> 00:57:41,760
well actually the reasoning is the same

00:57:39,359 --> 00:57:45,200
for both um

00:57:41,760 --> 00:57:49,040
you know yes um if you look

00:57:45,200 --> 00:57:52,160
at the implementation eventually um

00:57:49,040 --> 00:57:56,000
on many implementations but not

00:57:52,160 --> 00:57:58,480
all that loop will terminate in some way

00:57:56,000 --> 00:58:00,880
but it will have invoked und or that

00:57:58,480 --> 00:58:03,359
recursion would terminate in some way

00:58:00,880 --> 00:58:04,160
but it would have a taken a very long

00:58:03,359 --> 00:58:06,960
time

00:58:04,160 --> 00:58:07,599
um so you would notice it in testing and

00:58:06,960 --> 00:58:10,799
b

00:58:07,599 --> 00:58:15,280
it would invoke undefined behavior long

00:58:10,799 --> 00:58:18,400
before it got to actually repeating

00:58:15,280 --> 00:58:21,920
or actually terminating um

00:58:18,400 --> 00:58:22,720
so involve and that undefined behavior

00:58:21,920 --> 00:58:26,319
would be a

00:58:22,720 --> 00:58:29,839
local undefined behavior which again

00:58:26,319 --> 00:58:33,599
is a problem of lo of the

00:58:29,839 --> 00:58:35,839
local um um reasoning

00:58:33,599 --> 00:58:37,680
which you can see my other talks for

00:58:35,839 --> 00:58:41,520
more about local reasoning

00:58:37,680 --> 00:58:44,880
um i will say that um

00:58:41,520 --> 00:58:45,520
that uh that the undefined behavior

00:58:44,880 --> 00:58:48,799
there is

00:58:45,520 --> 00:58:51,839
actually because pointers are not really

00:58:48,799 --> 00:58:54,720
unsigned integers they are

00:58:51,839 --> 00:58:55,599
represented in a similar way to unsigned

00:58:54,720 --> 00:58:58,079
integers

00:58:55,599 --> 00:59:00,720
and it's they are so close that it's

00:58:58,079 --> 00:59:03,119
easy to conflate them in our heads

00:59:00,720 --> 00:59:04,160
and in fact the computer underneath

00:59:03,119 --> 00:59:06,240
conflates them

00:59:04,160 --> 00:59:08,559
but to the language a pointer and an

00:59:06,240 --> 00:59:12,720
integer are very different things

00:59:08,559 --> 00:59:12,720
and they work by different rules

00:59:13,520 --> 00:59:19,280
next thing do i think that

00:59:17,119 --> 00:59:21,839
global reasoning is in the domain of

00:59:19,280 --> 00:59:23,040
static analyzers or possibly residing in

00:59:21,839 --> 00:59:26,160
the compiler slash

00:59:23,040 --> 00:59:29,440
linker or both um

00:59:26,160 --> 00:59:32,559
so a yes this is exactly

00:59:29,440 --> 00:59:33,200
in the domain or should be in the domain

00:59:32,559 --> 00:59:38,000
of static

00:59:33,200 --> 00:59:41,040
analyzers um a long-term

00:59:38,000 --> 00:59:43,280
very deeply long-term goal of mine and

00:59:41,040 --> 00:59:44,319
many other people is to get us to the

00:59:43,280 --> 00:59:47,280
point where

00:59:44,319 --> 00:59:48,160
static analyzers actually show that our

00:59:47,280 --> 00:59:50,000
programs

00:59:48,160 --> 00:59:53,119
don't have undefined behavior that they

00:59:50,000 --> 00:59:56,720
don't have unbounded recursions

00:59:53,119 --> 01:00:00,240
um and these and getting there

00:59:56,720 --> 01:00:03,520
is a long trek but that's basically

01:00:00,240 --> 01:00:07,200
what all of my talks are about is

01:00:03,520 --> 01:00:09,359
how do we get there um and

01:00:07,200 --> 01:00:10,400
of course the global reasoning can't

01:00:09,359 --> 01:00:14,559
possibly

01:00:10,400 --> 01:00:17,040
um reside purely in the compiler

01:00:14,559 --> 01:00:17,599
you do need this link phase where you

01:00:17,040 --> 01:00:20,799
look

01:00:17,599 --> 01:00:24,559
at the at the big picture

01:00:20,799 --> 01:00:25,599
but if the compilers prepare the right

01:00:24,559 --> 01:00:29,119
stuff

01:00:25,599 --> 01:00:32,400
for that phase the big picture

01:00:29,119 --> 01:00:35,520
global checks can be um done

01:00:32,400 --> 01:00:37,520
with efficient algorithms or at least i

01:00:35,520 --> 01:00:42,960
hope they all can

01:00:37,520 --> 01:00:44,720
uh next question um

01:00:42,960 --> 01:00:46,559
i think that this whole thing is

01:00:44,720 --> 01:00:47,760
describing a kind of whole program

01:00:46,559 --> 01:00:50,319
correctness algorithm

01:00:47,760 --> 01:00:52,319
you think correctly um and the

01:00:50,319 --> 01:00:53,760
additional notation would really be a

01:00:52,319 --> 01:00:56,240
language addition to help

01:00:53,760 --> 01:00:57,680
that analysis you also think correctly

01:00:56,240 --> 01:01:01,359
in that

01:00:57,680 --> 01:01:04,720
um so if i were

01:01:01,359 --> 01:01:07,359
king of c plus and i didn't care

01:01:04,720 --> 01:01:08,640
one wit about disrupting other people's

01:01:07,359 --> 01:01:11,839
programs

01:01:08,640 --> 01:01:14,799
um on other people's development then

01:01:11,839 --> 01:01:15,680
yes these things would be going into c

01:01:14,799 --> 01:01:19,119
plus

01:01:15,680 --> 01:01:20,559
20 right now um and i'd probably get

01:01:19,119 --> 01:01:23,440
them wrong because i would have done

01:01:20,559 --> 01:01:26,640
them all by myself without input from

01:01:23,440 --> 01:01:29,440
the hundreds of other people who work on

01:01:26,640 --> 01:01:31,119
making c plus plus a better language um

01:01:29,440 --> 01:01:35,599
so it's perhaps best that i'm

01:01:31,119 --> 01:01:38,960
not king or queen of c plus plus

01:01:35,599 --> 01:01:41,200
um let's see uh

01:01:38,960 --> 01:01:42,079
what would be some resources or

01:01:41,200 --> 01:01:44,319
references

01:01:42,079 --> 01:01:45,119
for people who wanted to learn more

01:01:44,319 --> 01:01:48,640
about this

01:01:45,119 --> 01:01:52,240
field um okay

01:01:48,640 --> 01:01:55,280
uh there are lots of people

01:01:52,240 --> 01:01:58,720
around who can talk to

01:01:55,280 --> 01:02:01,760
um this um you certainly have

01:01:58,720 --> 01:02:02,480
um a whole bunch of talks by me on

01:02:01,760 --> 01:02:05,280
youtube

01:02:02,480 --> 01:02:06,799
that you that you can listen this is in

01:02:05,280 --> 01:02:09,680
some sense

01:02:06,799 --> 01:02:10,799
maybe the sixth talk i've given on

01:02:09,680 --> 01:02:14,079
different aspects

01:02:10,799 --> 01:02:16,960
of reasoning on um programs

01:02:14,079 --> 01:02:19,440
i particularly recommend last year's

01:02:16,960 --> 01:02:22,960
talk the truth of a procedure

01:02:19,440 --> 01:02:25,680
for a good overview um

01:02:22,960 --> 01:02:26,960
and one that i gave several years ago

01:02:25,680 --> 01:02:27,920
which you'll see the notation is

01:02:26,960 --> 01:02:30,960
somewhat different

01:02:27,920 --> 01:02:34,400
in um is

01:02:30,960 --> 01:02:37,520
uh the is what is the basic interface

01:02:34,400 --> 01:02:40,960
that that was a fan favorite

01:02:37,520 --> 01:02:43,599
um okay next question

01:02:40,960 --> 01:02:45,599
uh does reachable recursively still

01:02:43,599 --> 01:02:48,240
reduce to the halting problem

01:02:45,599 --> 01:02:49,760
at the local level is the assertion that

01:02:48,240 --> 01:02:50,559
you don't blow up the stack at the local

01:02:49,760 --> 01:02:53,920
level

01:02:50,559 --> 01:02:57,599
that you can't move to the global

01:02:53,920 --> 01:03:02,000
um okay um another

01:02:57,599 --> 01:03:04,079
uh uh talk that i will recommend uh a

01:03:02,000 --> 01:03:05,119
couple of years ago i gave a lightning

01:03:04,079 --> 01:03:08,720
talk

01:03:05,119 --> 01:03:12,000
at um at meeting c plus

01:03:08,720 --> 01:03:15,280
called the halting problem is not our

01:03:12,000 --> 01:03:18,640
problem um and

01:03:15,280 --> 01:03:21,359
in synopsis um

01:03:18,640 --> 01:03:21,760
the halting problem when you look at the

01:03:21,359 --> 01:03:25,520
whole

01:03:21,760 --> 01:03:29,200
problem is the problem of

01:03:25,520 --> 01:03:31,680
whether or not a program that you found

01:03:29,200 --> 01:03:34,720
in the gutter that you found carved into

01:03:31,680 --> 01:03:38,319
hieroglyphics by aliens in a pyramid

01:03:34,720 --> 01:03:42,160
um is going to halt

01:03:38,319 --> 01:03:47,359
you don't find programs in practice

01:03:42,160 --> 01:03:50,000
in the gutter or in in ancient pyramids

01:03:47,359 --> 01:03:52,079
programs are actually artifacts of human

01:03:50,000 --> 01:03:56,000
intention

01:03:52,079 --> 01:03:57,680
and the halting problem doesn't describe

01:03:56,000 --> 01:04:01,119
the process

01:03:57,680 --> 01:04:03,839
of having the person who understood

01:04:01,119 --> 01:04:04,319
why the program was supposed to halt

01:04:03,839 --> 01:04:07,520
write

01:04:04,319 --> 01:04:09,839
down those reasons so that other people

01:04:07,520 --> 01:04:13,039
could check them

01:04:09,839 --> 01:04:15,200
and that's so the halting problem is an

01:04:13,039 --> 01:04:16,400
analog of goodell's incompleteness

01:04:15,200 --> 01:04:19,520
theorems

01:04:16,400 --> 01:04:23,079
um the checking proofs

01:04:19,520 --> 01:04:24,559
doing automated code review with a

01:04:23,079 --> 01:04:27,440
sufficiently

01:04:24,559 --> 01:04:30,160
advanced language can be an analog of

01:04:27,440 --> 01:04:33,039
google's completeness theorems

01:04:30,160 --> 01:04:33,839
um and that's an entirely solvable

01:04:33,039 --> 01:04:36,960
problem

01:04:33,839 --> 01:04:38,960
so automated code review is something we

01:04:36,960 --> 01:04:42,799
can do

01:04:38,960 --> 01:04:46,160
and so we might say here is a program

01:04:42,799 --> 01:04:49,839
we don't know whether it halts but we do

01:04:46,160 --> 01:04:52,000
know that it doesn't say why it halts

01:04:49,839 --> 01:04:54,799
and if we see a program that does say

01:04:52,000 --> 01:04:56,880
why it's halt and the reasons make sense

01:04:54,799 --> 01:04:59,359
we're not up against the halting problem

01:04:56,880 --> 01:05:03,200
we know because the reasons make sense

01:04:59,359 --> 01:05:05,520
it does halt uh next question

01:05:03,200 --> 01:05:05,520
ah

01:05:06,559 --> 01:05:13,280
let's see what other oh sorry uh

01:05:10,160 --> 01:05:14,240
we have uh time i guess for one more

01:05:13,280 --> 01:05:17,440
question

01:05:14,240 --> 01:05:19,599
um so what other properties of local or

01:05:17,440 --> 01:05:20,960
global reasoning that i still have to

01:05:19,599 --> 01:05:24,720
explore

01:05:20,960 --> 01:05:26,640
so i i will say when i started preparing

01:05:24,720 --> 01:05:27,200
this talk i was preparing a very

01:05:26,640 --> 01:05:30,400
different

01:05:27,200 --> 01:05:32,880
talk about um how

01:05:30,400 --> 01:05:34,880
the reasoning around using global

01:05:32,880 --> 01:05:37,920
variables safely

01:05:34,880 --> 01:05:41,280
works um and

01:05:37,920 --> 01:05:43,200
all of this turned out to be material

01:05:41,280 --> 01:05:44,319
that had to go in the introduction of

01:05:43,200 --> 01:05:47,680
that talk

01:05:44,319 --> 01:05:52,000
so one day i hope i will

01:05:47,680 --> 01:05:55,039
uh talk about uh global variables

01:05:52,000 --> 01:05:58,559
um and uh

01:05:55,039 --> 01:06:01,680
so there are a

01:05:58,559 --> 01:06:02,160
great many um problems already explored

01:06:01,680 --> 01:06:05,440
in my

01:06:02,160 --> 01:06:08,640
in my other talks um another one

01:06:05,440 --> 01:06:11,920
that i'm hoping to do um sometime

01:06:08,640 --> 01:06:14,799
soon is how different neighborhoods can

01:06:11,920 --> 01:06:17,680
make promises to each other

01:06:14,799 --> 01:06:18,000
that go beyond what's in the interface

01:06:17,680 --> 01:06:21,119
of

01:06:18,000 --> 01:06:24,559
adjacent neighborhoods um

01:06:21,119 --> 01:06:26,559
and there's one that i think

01:06:24,559 --> 01:06:28,000
i attempted to cover many years ago but

01:06:26,559 --> 01:06:31,119
i really want to do

01:06:28,000 --> 01:06:31,760
a better job of i have in the back of my

01:06:31,119 --> 01:06:35,359
mind

01:06:31,760 --> 01:06:37,599
a uh talk on why loops end

01:06:35,359 --> 01:06:40,640
that one day hopefully i will get around

01:06:37,599 --> 01:06:40,640
to putting together

01:06:40,720 --> 01:06:44,559
oh let's see i guess i have one more

01:06:42,480 --> 01:06:47,839
question here i'll let

01:06:44,559 --> 01:06:49,200
my team on the other side tell me when i

01:06:47,839 --> 01:06:52,480
have to stop

01:06:49,200 --> 01:06:53,760
um so are there any examples of

01:06:52,480 --> 01:06:56,400
languages besides

01:06:53,760 --> 01:06:58,839
c plus plus that have achieved this kind

01:06:56,400 --> 01:07:03,520
of static analysis

01:06:58,839 --> 01:07:06,880
um so many have attempted it

01:07:03,520 --> 01:07:10,240
none have completely succeeded um

01:07:06,880 --> 01:07:13,359
so i understand that um

01:07:10,240 --> 01:07:16,559
ada has quite a lot of work going

01:07:13,359 --> 01:07:19,680
into this uh i will say that

01:07:16,559 --> 01:07:20,319
uh there's um the place i got started

01:07:19,680 --> 01:07:22,799
from was

01:07:20,319 --> 01:07:23,680
many years ago there's a book the

01:07:22,799 --> 01:07:26,880
science of

01:07:23,680 --> 01:07:28,880
programming by david greece or griez i

01:07:26,880 --> 01:07:32,559
don't know how to pronounce his name

01:07:28,880 --> 01:07:35,039
um that you know that was

01:07:32,559 --> 01:07:36,720
really an attempt to do this same thing

01:07:35,039 --> 01:07:40,720
and in some sense what i do

01:07:36,720 --> 01:07:43,920
could be considered reply to him

01:07:40,720 --> 01:07:44,480
so many people are working on it many

01:07:43,920 --> 01:07:47,599
have

01:07:44,480 --> 01:07:50,559
invented new languages to um

01:07:47,599 --> 01:07:52,480
try and do this and some are working

01:07:50,559 --> 01:07:54,880
with existing languages

01:07:52,480 --> 01:07:56,400
i prefer working with existing languages

01:07:54,880 --> 01:07:56,960
because working with an existing

01:07:56,400 --> 01:08:00,160
language

01:07:56,960 --> 01:08:03,359
keeps me honest i have to actually

01:08:00,160 --> 01:08:04,079
do the weird details that come from a

01:08:03,359 --> 01:08:07,039
language

01:08:04,079 --> 01:08:08,640
that is used for a huge number of

01:08:07,039 --> 01:08:11,760
programs

01:08:08,640 --> 01:08:14,240
okay apparently that is it uh

01:08:11,760 --> 01:08:15,760
i will say one more thing which is in a

01:08:14,240 --> 01:08:16,400
few minutes i'm going to be going to

01:08:15,760 --> 01:08:19,040
floor

01:08:16,400 --> 01:08:20,080
five of the hallway so if you want to

01:08:19,040 --> 01:08:22,799
buttonhole me

01:08:20,080 --> 01:08:25,839
go to floor 5 of the hallway thank you

01:08:22,799 --> 01:08:25,839
very much

01:08:44,560 --> 01:08:46,640

YouTube URL: https://www.youtube.com/watch?v=Zjy8RCb8p7M


