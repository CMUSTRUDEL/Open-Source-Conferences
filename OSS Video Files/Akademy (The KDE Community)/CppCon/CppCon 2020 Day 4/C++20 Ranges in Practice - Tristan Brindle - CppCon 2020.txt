Title: C++20 Ranges in Practice - Tristan Brindle - CppCon 2020
Publication date: 2020-10-04
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Among the many new additions to C++20 are Ranges, a modern revision of the STL offering updated algorithms and new “views” with lazy evaluation.

In this example-based talk we’ll work through several practical demonstrations of how the new Ranges functionality may be used to solve everyday problems concisely, elegantly and efficiently. In addition, we’ll offer tips on how to avoid common errors in your Ranges code, and demonstrate a couple of useful utility functions which you can drop into your codebase today.

---
Tristan Brindle
C++ London Uni

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,880 --> 00:00:13,040
okay hello everybody welcome to c

00:00:11,040 --> 00:00:14,400
plus plus 20 ranges in practice uh my

00:00:13,040 --> 00:00:17,039
name is tristan i'll be your host for

00:00:14,400 --> 00:00:19,199
this evening um

00:00:17,039 --> 00:00:20,640
so uh let's begin our journey so our

00:00:19,199 --> 00:00:23,279
journey begins as

00:00:20,640 --> 00:00:23,680
so many good journeys do uh a long time

00:00:23,279 --> 00:00:26,560
ago

00:00:23,680 --> 00:00:28,880
in a galaxy far far away or well okay

00:00:26,560 --> 00:00:30,880
last september in colorado

00:00:28,880 --> 00:00:32,480
so last september in colorado i was at

00:00:30,880 --> 00:00:34,880
cppcon 2019

00:00:32,480 --> 00:00:36,239
uh i was speaking there is me on stage

00:00:34,880 --> 00:00:37,840
no i really did it

00:00:36,239 --> 00:00:39,920
um and i gave a talk that was called an

00:00:37,840 --> 00:00:41,360
overview of standard ranges

00:00:39,920 --> 00:00:43,600
uh the youtube link is there that's

00:00:41,360 --> 00:00:45,920
mostly for when these slides go out

00:00:43,600 --> 00:00:46,960
later but you can find it you just have

00:00:45,920 --> 00:00:50,160
to uh

00:00:46,960 --> 00:00:52,000
search for that title on youtube and

00:00:50,160 --> 00:00:53,840
uh as the title suggests this was sort

00:00:52,000 --> 00:00:54,719
of a broad brush overview of the new

00:00:53,840 --> 00:00:56,399
features

00:00:54,719 --> 00:00:59,120
that we're going to be getting in c plus

00:00:56,399 --> 00:01:01,920
plus 20. um

00:00:59,120 --> 00:01:03,359
and you know it went pretty well i think

00:01:01,920 --> 00:01:04,720
uh and afterwards i was kind of

00:01:03,359 --> 00:01:06,960
inundated with people

00:01:04,720 --> 00:01:08,400
asking me questions about things that i

00:01:06,960 --> 00:01:11,200
hadn't been able to cover

00:01:08,400 --> 00:01:12,560
uh in the time available in that talk um

00:01:11,200 --> 00:01:15,280
so

00:01:12,560 --> 00:01:16,000
this year for cppcon i uh proposed a

00:01:15,280 --> 00:01:17,840
follow-up

00:01:16,000 --> 00:01:19,759
and that follow-up is what you're

00:01:17,840 --> 00:01:21,200
watching right now so if you haven't

00:01:19,759 --> 00:01:22,560
seen the overview talk

00:01:21,200 --> 00:01:24,000
uh don't worry if you've got some

00:01:22,560 --> 00:01:25,520
experience with rangers if you've been

00:01:24,000 --> 00:01:27,520
using range v3 if you've

00:01:25,520 --> 00:01:29,759
seen a few examples online you should be

00:01:27,520 --> 00:01:32,000
able to follow along today

00:01:29,759 --> 00:01:34,720
if not if you're watching this at some

00:01:32,000 --> 00:01:37,040
point in the future

00:01:34,720 --> 00:01:38,240
then this overview talk is a good place

00:01:37,040 --> 00:01:39,520
to start if you

00:01:38,240 --> 00:01:41,840
have no experience with ranges

00:01:39,520 --> 00:01:41,840
whatsoever

00:01:42,079 --> 00:01:45,840
so with that out of the way what's on

00:01:43,680 --> 00:01:48,560
the menu for today

00:01:45,840 --> 00:01:49,600
so today we're going to be looking at

00:01:48,560 --> 00:01:52,079
three

00:01:49,600 --> 00:01:53,520
uh programming problems the kind of

00:01:52,079 --> 00:01:55,040
things that might turn up in a

00:01:53,520 --> 00:01:56,799
in a you know interview the dreaded

00:01:55,040 --> 00:01:59,520
whiteboard thing um

00:01:56,799 --> 00:02:01,119
reasonably simple problems uh i think

00:01:59,520 --> 00:02:03,439
but they're gonna

00:02:01,119 --> 00:02:05,040
lead us down some interesting rabbit

00:02:03,439 --> 00:02:05,840
holes we're gonna try and use rangers to

00:02:05,040 --> 00:02:08,800
solve them

00:02:05,840 --> 00:02:09,840
we're gonna see um you know where that

00:02:08,800 --> 00:02:13,360
takes us

00:02:09,840 --> 00:02:16,080
and hopefully um everybody will will

00:02:13,360 --> 00:02:17,360
come out of this learning something

00:02:16,080 --> 00:02:18,959
so as i say we're going to look at three

00:02:17,360 --> 00:02:19,520
problems first problem we're going to

00:02:18,959 --> 00:02:21,120
look at

00:02:19,520 --> 00:02:22,560
how to calculate how to find the least

00:02:21,120 --> 00:02:23,599
element of an array you're probably

00:02:22,560 --> 00:02:24,879
sitting there thinking well i know how

00:02:23,599 --> 00:02:28,000
to do this this is silly

00:02:24,879 --> 00:02:30,480
um stick with it uh as i say

00:02:28,000 --> 00:02:32,319
we're going down rabbit horse today

00:02:30,480 --> 00:02:33,920
second problem we're going to look at

00:02:32,319 --> 00:02:35,680
we're going to look at how to calculate

00:02:33,920 --> 00:02:38,879
the sum of the squares

00:02:35,680 --> 00:02:40,560
of some numbers in an array

00:02:38,879 --> 00:02:42,239
and then we're gonna we're gonna finish

00:02:40,560 --> 00:02:43,360
on uh my favorite problem which is

00:02:42,239 --> 00:02:45,599
string trimming and we're gonna look at

00:02:43,360 --> 00:02:46,080
how we can use range adapters uh to do

00:02:45,599 --> 00:02:47,840
that

00:02:46,080 --> 00:02:51,040
which i think is really really cool and

00:02:47,840 --> 00:02:52,959
i'm really looking forward to it um

00:02:51,040 --> 00:02:54,640
so i'll take questions at the end

00:02:52,959 --> 00:02:56,400
ideally if i was doing this as an

00:02:54,640 --> 00:02:57,120
in-person talk i would take questions as

00:02:56,400 --> 00:02:59,120
we go along

00:02:57,120 --> 00:03:00,720
i think with the online formats uh

00:02:59,120 --> 00:03:02,319
because i'm on a bit of a delay

00:03:00,720 --> 00:03:04,239
it'll work better if we leave questions

00:03:02,319 --> 00:03:06,560
till we end

00:03:04,239 --> 00:03:08,239
please do write questions in the little

00:03:06,560 --> 00:03:09,519
q a tab on remo

00:03:08,239 --> 00:03:11,680
upvote questions if you think they're

00:03:09,519 --> 00:03:13,440
good questions uh all being well as long

00:03:11,680 --> 00:03:16,000
as i don't run over too far

00:03:13,440 --> 00:03:17,200
we'll have some time left at the end um

00:03:16,000 --> 00:03:18,239
and the other thing to note is that

00:03:17,200 --> 00:03:20,159
every slide

00:03:18,239 --> 00:03:21,680
uh you can see it just which direction

00:03:20,159 --> 00:03:23,120
over there um

00:03:21,680 --> 00:03:24,640
in the bottom right we have a slide

00:03:23,120 --> 00:03:25,680
number so if there's something on a

00:03:24,640 --> 00:03:27,760
particular slide

00:03:25,680 --> 00:03:28,879
that's perplexing you if i've made any

00:03:27,760 --> 00:03:32,560
typos or

00:03:28,879 --> 00:03:34,480
silly mistakes um or anything else

00:03:32,560 --> 00:03:38,080
uh just take a note of the slide number

00:03:34,480 --> 00:03:38,080
and then we can go back to it at the end

00:03:38,400 --> 00:03:43,280
so with that other way let's crack on

00:03:40,159 --> 00:03:46,560
with our first problem for the day

00:03:43,280 --> 00:03:47,920
which is calculating the minimum element

00:03:46,560 --> 00:03:49,360
of an array

00:03:47,920 --> 00:03:51,280
so here's the problem statement given a

00:03:49,360 --> 00:03:53,439
non-empty array array of integers

00:03:51,280 --> 00:03:55,519
find the minimum value that it contains

00:03:53,439 --> 00:04:00,000
so for example if we're given an array

00:03:55,519 --> 00:04:03,599
of numbers 5 22 88 minus 12 and 14.

00:04:00,000 --> 00:04:06,239
we want to find -12 that is the lowest

00:04:03,599 --> 00:04:07,519
value in this array pretty

00:04:06,239 --> 00:04:10,560
straightforward

00:04:07,519 --> 00:04:11,840
we want to find the minimum value in the

00:04:10,560 --> 00:04:15,200
array minimum value

00:04:11,840 --> 00:04:18,880
minimum element min element

00:04:15,200 --> 00:04:20,880
min min element min element there we go

00:04:18,880 --> 00:04:22,079
so of course you could do this with a

00:04:20,880 --> 00:04:25,360
for loop

00:04:22,079 --> 00:04:27,759
in a few lines but

00:04:25,360 --> 00:04:28,479
the stl the existing stl comes with a

00:04:27,759 --> 00:04:30,400
function that

00:04:28,479 --> 00:04:32,400
will calculate this for us and it's

00:04:30,400 --> 00:04:35,040
called standard min elements so

00:04:32,400 --> 00:04:36,320
here is how you would or you might find

00:04:35,040 --> 00:04:39,759
the minimum element

00:04:36,320 --> 00:04:40,720
in c plus plus 17. so we're getting our

00:04:39,759 --> 00:04:42,160
input vector

00:04:40,720 --> 00:04:44,080
and then we're calling standard min

00:04:42,160 --> 00:04:47,600
elements with the beginning and end

00:04:44,080 --> 00:04:47,600
iterators from this vector

00:04:47,759 --> 00:04:51,360
so pretty familiar stuff i hope and of

00:04:50,560 --> 00:04:53,919
course

00:04:51,360 --> 00:04:55,120
we're getting new algorithms in the

00:04:53,919 --> 00:04:57,680
ranges namespace

00:04:55,120 --> 00:04:59,600
rangified versions of these algorithms

00:04:57,680 --> 00:05:02,080
so we can replace

00:04:59,600 --> 00:05:02,639
standard min with standard ranges min um

00:05:02,080 --> 00:05:05,360
just

00:05:02,639 --> 00:05:07,440
a note that on these slides i will quite

00:05:05,360 --> 00:05:10,000
often drop the std just

00:05:07,440 --> 00:05:11,360
for space on the slides you can just

00:05:10,000 --> 00:05:15,360
imagine there are

00:05:11,360 --> 00:05:16,479
using directives in place so

00:05:15,360 --> 00:05:19,600
uh and the other thing to mention is

00:05:16,479 --> 00:05:22,960
that everything i'm going to show today

00:05:19,600 --> 00:05:26,080
except where noted is part of c

00:05:22,960 --> 00:05:29,680
plus 20 ranges and is available today in

00:05:26,080 --> 00:05:32,400
lip standard c plus plus um

00:05:29,680 --> 00:05:34,479
uh version sorry uh in gcc version 10

00:05:32,400 --> 00:05:37,039
lip standard c plus plus it

00:05:34,479 --> 00:05:38,240
implements the range of stuff and also

00:05:37,039 --> 00:05:39,759
uh msvc

00:05:38,240 --> 00:05:41,440
is doesn't quite have everything but

00:05:39,759 --> 00:05:42,960
it's it's getting very close now i think

00:05:41,440 --> 00:05:45,759
the latest preview version

00:05:42,960 --> 00:05:46,320
has uh quite a lot of support for ranges

00:05:45,759 --> 00:05:47,759
so

00:05:46,320 --> 00:05:51,039
fingers crossed it won't be long before

00:05:47,759 --> 00:05:53,039
they have a full implementation as well

00:05:51,039 --> 00:05:54,639
so yes we can replace standard main

00:05:53,039 --> 00:05:56,240
element with ranges min elements

00:05:54,639 --> 00:05:58,240
and of course we can still pass the

00:05:56,240 --> 00:05:59,840
beginning and end iterator if we want to

00:05:58,240 --> 00:06:02,960
just as we could before

00:05:59,840 --> 00:06:05,680
um but min element

00:06:02,960 --> 00:06:06,479
is ranges algorithm so we can pass the

00:06:05,680 --> 00:06:08,160
whole

00:06:06,479 --> 00:06:10,080
range if we want to we can just pass

00:06:08,160 --> 00:06:12,800
back and this will

00:06:10,080 --> 00:06:14,319
in turn dispatch to the uh iterator

00:06:12,800 --> 00:06:17,520
version

00:06:14,319 --> 00:06:22,160
so okay yep that's pretty cool uh that's

00:06:17,520 --> 00:06:24,639
that solved the problem that was quick

00:06:22,160 --> 00:06:25,199
well okay so let's say you have

00:06:24,639 --> 00:06:26,720
something

00:06:25,199 --> 00:06:28,560
that looks a bit like this in your code

00:06:26,720 --> 00:06:31,360
base it might not be exactly

00:06:28,560 --> 00:06:32,800
this but something that looks similar

00:06:31,360 --> 00:06:34,319
and

00:06:32,800 --> 00:06:36,000
one of the co-workers comes along and

00:06:34,319 --> 00:06:36,720
they're you know weeks months years

00:06:36,000 --> 00:06:37,919
later

00:06:36,720 --> 00:06:40,479
and they look at this and they go well

00:06:37,919 --> 00:06:41,680
hang on um i'm not actually using this

00:06:40,479 --> 00:06:44,960
uh

00:06:41,680 --> 00:06:46,000
this vec object after after the call to

00:06:44,960 --> 00:06:48,240
mid element

00:06:46,000 --> 00:06:50,560
why am i bothering saving it in a named

00:06:48,240 --> 00:06:54,240
variable what's the point of that

00:06:50,560 --> 00:06:56,319
can't i just do this can i just pass

00:06:54,240 --> 00:06:57,680
the result of the get input function

00:06:56,319 --> 00:07:00,639
straight into

00:06:57,680 --> 00:07:00,639
range's min element

00:07:01,680 --> 00:07:07,440
and when this comes up in code review

00:07:05,039 --> 00:07:09,840
well it should start setting off alarm

00:07:07,440 --> 00:07:09,840
bells

00:07:10,080 --> 00:07:17,520
because we have a potential problem here

00:07:14,720 --> 00:07:19,919
we have a potential dangling iterator or

00:07:17,520 --> 00:07:23,759
at least we do on the face of it

00:07:19,919 --> 00:07:25,599
so get input is going to return an r

00:07:23,759 --> 00:07:29,199
value vector a temporary

00:07:25,599 --> 00:07:30,560
standard vector and

00:07:29,199 --> 00:07:31,840
that vector is going to be passed to mid

00:07:30,560 --> 00:07:33,039
element no element's going to do its

00:07:31,840 --> 00:07:36,800
thing it's going to return

00:07:33,039 --> 00:07:38,479
an iterator into the vector

00:07:36,800 --> 00:07:40,000
that's all fine the problem comes at the

00:07:38,479 --> 00:07:41,120
end of the statement or at the end of

00:07:40,000 --> 00:07:42,880
the full expression if you want to be

00:07:41,120 --> 00:07:44,800
technical

00:07:42,880 --> 00:07:46,000
at which point the temporary vector is

00:07:44,800 --> 00:07:48,720
destroyed

00:07:46,000 --> 00:07:50,639
and then our nice ita variable there is

00:07:48,720 --> 00:07:52,479
going to be pointing into some deleted

00:07:50,639 --> 00:07:56,400
memory

00:07:52,479 --> 00:07:59,759
this is bad we don't want this

00:07:56,400 --> 00:08:03,520
and this is not a problem that could

00:07:59,759 --> 00:08:05,440
occur in the uh old stl

00:08:03,520 --> 00:08:07,440
because in that case you always had to

00:08:05,440 --> 00:08:11,039
pass separate begin and end

00:08:07,440 --> 00:08:13,280
so you always had to save the uh

00:08:11,039 --> 00:08:14,720
the vector in this case has a variable

00:08:13,280 --> 00:08:15,520
in order to be able to call both begin

00:08:14,720 --> 00:08:18,639
and end on it

00:08:15,520 --> 00:08:19,360
so this is uh in a sense a problem that

00:08:18,639 --> 00:08:22,479
ranges

00:08:19,360 --> 00:08:23,919
introduces by taking uh containers as a

00:08:22,479 --> 00:08:26,960
whole

00:08:23,919 --> 00:08:28,800
or it would be but in fact

00:08:26,960 --> 00:08:30,160
the question mark is there for a reason

00:08:28,800 --> 00:08:34,640
because in fact

00:08:30,160 --> 00:08:36,320
this as it turns out is not a problem

00:08:34,640 --> 00:08:38,159
because ranges does something really

00:08:36,320 --> 00:08:41,839
clever

00:08:38,159 --> 00:08:43,839
and what happens in this situation

00:08:41,839 --> 00:08:44,959
is that when you pass an r value

00:08:43,839 --> 00:08:47,200
container

00:08:44,959 --> 00:08:50,399
into an algorithm like min element that

00:08:47,200 --> 00:08:50,399
returns an iterator

00:08:50,800 --> 00:08:53,839
or would normally return an iterator

00:08:52,800 --> 00:08:56,560
what ranges does

00:08:53,839 --> 00:08:58,399
is it changes the return type so that

00:08:56,560 --> 00:09:01,279
instead of returning iterator

00:08:58,399 --> 00:09:03,760
it returns an object of type ranges

00:09:01,279 --> 00:09:03,760
dangling

00:09:05,760 --> 00:09:09,680
so if we pass an r value container

00:09:07,839 --> 00:09:12,720
something like a vector

00:09:09,680 --> 00:09:14,720
into uh

00:09:12,720 --> 00:09:17,120
an algorithm like min element like find

00:09:14,720 --> 00:09:19,839
like anything that returns an iterator

00:09:17,120 --> 00:09:21,440
the iterator return type will be changed

00:09:19,839 --> 00:09:25,200
so that instead it returns

00:09:21,440 --> 00:09:25,200
one of these ranges dangling objects

00:09:25,220 --> 00:09:29,920
[Music]

00:09:26,720 --> 00:09:31,120
so this line this will compile this is

00:09:29,920 --> 00:09:33,360
just fine

00:09:31,120 --> 00:09:34,560
but i was a bit sneaky because i used

00:09:33,360 --> 00:09:37,680
auto

00:09:34,560 --> 00:09:38,959
on ita the actual type that is going to

00:09:37,680 --> 00:09:40,320
be deduced here

00:09:38,959 --> 00:09:42,320
the type that min element is going to

00:09:40,320 --> 00:09:46,320
return for this input is going to be one

00:09:42,320 --> 00:09:46,320
of these ranges dangling objects

00:09:47,600 --> 00:09:50,800
now ranges dangling is more or less just

00:09:49,680 --> 00:09:54,240
an empty struct

00:09:50,800 --> 00:09:57,680
it has no operations defined on it

00:09:54,240 --> 00:09:59,920
so constructing a dangling object

00:09:57,680 --> 00:10:01,440
is not the problem the problem comes

00:09:59,920 --> 00:10:04,320
when we try to use

00:10:01,440 --> 00:10:04,959
a dangling object attempting to use a

00:10:04,320 --> 00:10:08,160
dangling

00:10:04,959 --> 00:10:10,320
will cause a compile error so if we were

00:10:08,160 --> 00:10:12,959
to do something like this

00:10:10,320 --> 00:10:14,959
if we were attempting to dereference the

00:10:12,959 --> 00:10:17,680
iterator

00:10:14,959 --> 00:10:18,720
and print the value we're going to get

00:10:17,680 --> 00:10:20,240
an

00:10:18,720 --> 00:10:21,920
error that looks like this in fact not

00:10:20,240 --> 00:10:22,480
just looks like this this is the exact

00:10:21,920 --> 00:10:25,600
error

00:10:22,480 --> 00:10:26,160
that gcc prints out uh for this for this

00:10:25,600 --> 00:10:28,399
example

00:10:26,160 --> 00:10:30,839
so no match for operator star operand

00:10:28,399 --> 00:10:34,160
type is standard ranges tank

00:10:30,839 --> 00:10:37,600
dangling and this is really cool

00:10:34,160 --> 00:10:40,720
because the error message has this

00:10:37,600 --> 00:10:42,000
name in its standard ranges dangling it

00:10:40,720 --> 00:10:45,200
helps you diagnose

00:10:42,000 --> 00:10:45,200
exactly what the problem is

00:10:45,360 --> 00:10:49,200
if we see ranges dangling in an error

00:10:47,360 --> 00:10:52,240
message we can look at it and go okay

00:10:49,200 --> 00:10:55,440
we are trying to use an iterator

00:10:52,240 --> 00:10:56,000
that we've got from an algorithm and

00:10:55,440 --> 00:10:59,680
we've

00:10:56,000 --> 00:11:02,720
erroneously passed an r value

00:10:59,680 --> 00:11:04,480
container into this algorithm

00:11:02,720 --> 00:11:06,560
so we know what the problem is and we

00:11:04,480 --> 00:11:07,920
know probably the easiest solution is

00:11:06,560 --> 00:11:09,920
just to save the

00:11:07,920 --> 00:11:14,000
uh input into a named variable so that

00:11:09,920 --> 00:11:16,079
we pass it an l value instead

00:11:14,000 --> 00:11:17,760
so i mean this is c plus plus we can't

00:11:16,079 --> 00:11:20,880
protect you from every use of

00:11:17,760 --> 00:11:23,200
uh dangling iterators um unfortunately

00:11:20,880 --> 00:11:24,640
until we get full lifetime checking and

00:11:23,200 --> 00:11:27,040
borrow checking and all of that stuff

00:11:24,640 --> 00:11:29,040
if that ever happens uh but this is

00:11:27,040 --> 00:11:30,720
something that this is one particular

00:11:29,040 --> 00:11:34,160
case where ranges can help

00:11:30,720 --> 00:11:35,760
prevent uh errors um

00:11:34,160 --> 00:11:38,320
uh lifetime errors and i think this is

00:11:35,760 --> 00:11:38,320
pretty nice

00:11:38,480 --> 00:11:42,320
so rangers applies this dangling

00:11:39,920 --> 00:11:44,000
protection as i say

00:11:42,320 --> 00:11:47,200
whenever you have an algorithm that

00:11:44,000 --> 00:11:49,120
would return an iterator

00:11:47,200 --> 00:11:50,639
ranges applies this dangling protection

00:11:49,120 --> 00:11:52,320
transforms the return type into

00:11:50,639 --> 00:11:53,600
something involving this dangling type

00:11:52,320 --> 00:11:57,839
something that's going to show up

00:11:53,600 --> 00:11:57,839
noisily in your errors

00:11:58,000 --> 00:12:05,040
however there are some types

00:12:02,079 --> 00:12:06,240
whose iterators can safely outlive their

00:12:05,040 --> 00:12:08,320
parents

00:12:06,240 --> 00:12:12,079
for example a standard string view or

00:12:08,320 --> 00:12:13,519
new nc plus 20 stand a span

00:12:12,079 --> 00:12:15,040
so if you think about uh what a string

00:12:13,519 --> 00:12:16,720
view is a string view just points into

00:12:15,040 --> 00:12:18,720
some other character array

00:12:16,720 --> 00:12:20,800
a string views iterators in fact just

00:12:18,720 --> 00:12:23,360
point into the other character array

00:12:20,800 --> 00:12:25,120
so if you have a string view iterator

00:12:23,360 --> 00:12:27,360
you can continue using that

00:12:25,120 --> 00:12:28,240
iterator after the string view itself is

00:12:27,360 --> 00:12:30,880
destroyed

00:12:28,240 --> 00:12:32,079
as long as the underlying character

00:12:30,880 --> 00:12:33,680
array is still around

00:12:32,079 --> 00:12:35,440
you can do things like this this is kind

00:12:33,680 --> 00:12:39,760
of weird

00:12:35,440 --> 00:12:41,839
but it's not problematic this is safe

00:12:39,760 --> 00:12:43,120
so here you see on the what is it the

00:12:41,839 --> 00:12:44,880
third line

00:12:43,120 --> 00:12:46,240
we're creating a temporary string view

00:12:44,880 --> 00:12:47,839
calling begin on it and then the string

00:12:46,240 --> 00:12:51,120
view is immediately destroyed but we can

00:12:47,839 --> 00:12:53,519
safely dereference it later

00:12:51,120 --> 00:12:55,760
so types like these like string view

00:12:53,519 --> 00:13:00,399
like span

00:12:55,760 --> 00:13:02,399
uh we these are types for which we don't

00:13:00,399 --> 00:13:04,720
need the dangling protection that ranges

00:13:02,399 --> 00:13:07,279
offers

00:13:04,720 --> 00:13:07,920
because their iterators can safely

00:13:07,279 --> 00:13:09,360
dangle

00:13:07,920 --> 00:13:11,680
they're not really dangling because it's

00:13:09,360 --> 00:13:11,680
safe

00:13:11,760 --> 00:13:15,760
we don't need the dangling protection so

00:13:13,680 --> 00:13:18,000
we can in fact disable it

00:13:15,760 --> 00:13:20,480
for these kind of types and we do that

00:13:18,000 --> 00:13:21,200
by specializing a trait in the rangers

00:13:20,480 --> 00:13:24,000
library called

00:13:21,200 --> 00:13:25,600
enable borrowed range in fact in effect

00:13:24,000 --> 00:13:27,680
we're telling the rangers machinery

00:13:25,600 --> 00:13:30,880
hey don't worry about it these iterators

00:13:27,680 --> 00:13:33,200
can safely outlive their parents

00:13:30,880 --> 00:13:34,560
so we specialize a trade like this so

00:13:33,200 --> 00:13:36,240
this is an imaginary

00:13:34,560 --> 00:13:37,680
string ref type that you might have is

00:13:36,240 --> 00:13:40,560
quite common in

00:13:37,680 --> 00:13:40,560
in code bases

00:13:40,720 --> 00:13:46,320
so if we have one of these types we can

00:13:44,079 --> 00:13:47,440
specialize the standard ranges enable

00:13:46,320 --> 00:13:49,760
borrowed

00:13:47,440 --> 00:13:50,880
range trade like this it's a variable

00:13:49,760 --> 00:13:54,320
template so we're just

00:13:50,880 --> 00:13:54,320
specializing variable templates

00:13:54,959 --> 00:13:58,399
so now if we use an algorithm like find

00:13:57,600 --> 00:14:00,240
and

00:13:58,399 --> 00:14:01,600
we imagine that get string ref returns

00:14:00,240 --> 00:14:03,440
us an r value

00:14:01,600 --> 00:14:05,360
string ref we've told the rangers

00:14:03,440 --> 00:14:07,440
machinery hey this is fine

00:14:05,360 --> 00:14:08,560
this isn't going to dangle so this is

00:14:07,440 --> 00:14:11,839
going to return you an

00:14:08,560 --> 00:14:14,160
iterator not a dangly

00:14:11,839 --> 00:14:15,839
so if we called find on get vector it

00:14:14,160 --> 00:14:17,680
would return

00:14:15,839 --> 00:14:20,399
but we've told the machinery ranges

00:14:17,680 --> 00:14:21,760
machinery hey stringer fits fine

00:14:20,399 --> 00:14:24,000
so it's going to give us an iterator

00:14:21,760 --> 00:14:24,000
back

00:14:25,360 --> 00:14:31,839
so these kind of types as we just seen

00:14:28,560 --> 00:14:34,800
are called borrowed ranges in the uh

00:14:31,839 --> 00:14:36,000
rangers world a type whose iterators can

00:14:34,800 --> 00:14:38,079
safely outlive

00:14:36,000 --> 00:14:39,440
the thing that you call begin on are

00:14:38,079 --> 00:14:40,800
called borrowed ranges

00:14:39,440 --> 00:14:43,120
so there are two kinds of borrowed

00:14:40,800 --> 00:14:46,079
ranges either l values

00:14:43,120 --> 00:14:47,600
so again if we pass an l value vector

00:14:46,079 --> 00:14:48,560
into find that's just gonna that's

00:14:47,600 --> 00:14:49,920
absolutely fine we're gonna get an

00:14:48,560 --> 00:14:53,040
iterator out

00:14:49,920 --> 00:14:53,839
so either an l value range or an r value

00:14:53,040 --> 00:14:56,160
range

00:14:53,839 --> 00:14:57,120
with this specialized trait something

00:14:56,160 --> 00:14:59,839
like a string view

00:14:57,120 --> 00:14:59,839
or a span

00:15:02,240 --> 00:15:05,839
so if we pass a borrowed range in we get

00:15:04,800 --> 00:15:07,760
an iterator out

00:15:05,839 --> 00:15:08,880
we pass a non-borrowed range in that's

00:15:07,760 --> 00:15:10,399
an r value which

00:15:08,880 --> 00:15:12,000
doesn't have the trait specialized we're

00:15:10,399 --> 00:15:15,040
going to get a dangling object out

00:15:12,000 --> 00:15:16,399
of our algorithms so this is a way as i

00:15:15,040 --> 00:15:21,040
say in which ranges

00:15:16,399 --> 00:15:21,040
helps protect you from making mistakes

00:15:22,560 --> 00:15:27,360
so let's go further into this rabbit

00:15:24,000 --> 00:15:31,199
hole um and

00:15:27,360 --> 00:15:31,199
and talk about views so

00:15:32,399 --> 00:15:35,519
informally uh when when people are sort

00:15:34,480 --> 00:15:37,120
of talking casually

00:15:35,519 --> 00:15:38,639
trying to explain in one sentence what

00:15:37,120 --> 00:15:40,160
is a view

00:15:38,639 --> 00:15:42,320
sometimes people say well a view is a

00:15:40,160 --> 00:15:43,759
range that doesn't own its elements

00:15:42,320 --> 00:15:45,519
that makes it sound quite a lot like a

00:15:43,759 --> 00:15:48,000
borrowed range they're actually distinct

00:15:45,519 --> 00:15:48,000
concepts

00:15:48,480 --> 00:15:51,120
because there are in fact views which do

00:15:50,079 --> 00:15:54,240
own their elements there's one in the

00:15:51,120 --> 00:15:57,600
standard library it's called single view

00:15:54,240 --> 00:16:00,959
so more formally a view is a range which

00:15:57,600 --> 00:16:03,199
is default constructable has constant

00:16:00,959 --> 00:16:05,279
time move instruction operations

00:16:03,199 --> 00:16:06,800
and if it's copyable has constant time

00:16:05,279 --> 00:16:09,759
copy operations

00:16:06,800 --> 00:16:11,040
so fuse uh in the rangers world need not

00:16:09,759 --> 00:16:13,279
be cop it need not be

00:16:11,040 --> 00:16:14,079
copyable they can be move only it's

00:16:13,279 --> 00:16:18,399
pretty rare but

00:16:14,079 --> 00:16:19,839
it's it's permissible um

00:16:18,399 --> 00:16:21,680
but these are the properties full

00:16:19,839 --> 00:16:23,440
properties that you need and

00:16:21,680 --> 00:16:25,279
by constant time here we mean

00:16:23,440 --> 00:16:28,480
independent of the number of elements

00:16:25,279 --> 00:16:29,759
in that range in the view

00:16:28,480 --> 00:16:32,160
and what these properties mean is that

00:16:29,759 --> 00:16:34,639
we can pass views around by value

00:16:32,160 --> 00:16:36,399
uh within our range implement within our

00:16:34,639 --> 00:16:39,360
range implementations

00:16:36,399 --> 00:16:40,720
um without worrying about the cost of

00:16:39,360 --> 00:16:41,680
these opera too much about the cost of

00:16:40,720 --> 00:16:44,160
these operations

00:16:41,680 --> 00:16:45,680
and without worrying about uh the

00:16:44,160 --> 00:16:47,199
algorithmic complexity uh

00:16:45,680 --> 00:16:51,839
multiplying and ending up with quadratic

00:16:47,199 --> 00:16:51,839
behavior and all sorts of bad things

00:16:52,240 --> 00:16:59,680
so unfortunately

00:16:55,440 --> 00:17:02,720
the compiler cannot work out for us

00:16:59,680 --> 00:17:04,079
whether copy constructors assignment

00:17:02,720 --> 00:17:06,880
operators etc

00:17:04,079 --> 00:17:07,919
etc whether they have uh constant time

00:17:06,880 --> 00:17:09,520
complexity or not

00:17:07,919 --> 00:17:11,120
right kind of beyond the ability of

00:17:09,520 --> 00:17:14,000
compilers to do so

00:17:11,120 --> 00:17:15,520
we have to opt in to being a view just

00:17:14,000 --> 00:17:18,720
as we have to opt into being a borrowed

00:17:15,520 --> 00:17:20,720
range we have to opt into being view

00:17:18,720 --> 00:17:22,480
and just as with borrowed range there is

00:17:20,720 --> 00:17:24,079
a trait enable view that we can use to

00:17:22,480 --> 00:17:25,600
do this

00:17:24,079 --> 00:17:28,079
or there's an alternative way because

00:17:25,600 --> 00:17:29,520
view um there are no views so people are

00:17:28,079 --> 00:17:32,720
going to be writing new ones

00:17:29,520 --> 00:17:34,400
um there's a base class an empty base

00:17:32,720 --> 00:17:36,400
class called ranges view base

00:17:34,400 --> 00:17:37,440
that we can use to do that or there's

00:17:36,400 --> 00:17:40,320
another base class

00:17:37,440 --> 00:17:41,440
uh called ranges view interface which is

00:17:40,320 --> 00:17:43,840
actually more useful

00:17:41,440 --> 00:17:46,320
and which gives you a load of default um

00:17:43,840 --> 00:17:49,440
default operations um

00:17:46,320 --> 00:17:51,200
that we can use to mark a particular

00:17:49,440 --> 00:17:53,440
class as being a view

00:17:51,200 --> 00:17:54,880
from the point of view of the range's

00:17:53,440 --> 00:17:57,440
machinery

00:17:54,880 --> 00:17:59,440
so if i had longer time available if

00:17:57,440 --> 00:18:02,720
this were a two-hour talk

00:17:59,440 --> 00:18:04,240
i would love to show you an example of

00:18:02,720 --> 00:18:05,760
how you would write a view how can you

00:18:04,240 --> 00:18:06,320
how you can use the view interface based

00:18:05,760 --> 00:18:09,200
class

00:18:06,320 --> 00:18:11,039
fortunately don't have the time

00:18:09,200 --> 00:18:15,360
available but you know maybe i'll do

00:18:11,039 --> 00:18:17,520
another follow-up next year who knows

00:18:15,360 --> 00:18:20,960
so as i mentioned views and borrowed

00:18:17,520 --> 00:18:22,240
ranges are distinct concepts

00:18:20,960 --> 00:18:23,679
there are views that are not borrowed

00:18:22,240 --> 00:18:26,240
ranges there are borrowed ranges that

00:18:23,679 --> 00:18:29,679
are not views

00:18:26,240 --> 00:18:32,480
but whenever we have a borrowed range

00:18:29,679 --> 00:18:32,960
we can convert it into a view using this

00:18:32,480 --> 00:18:35,120
function

00:18:32,960 --> 00:18:37,919
views all that is the purpose of this

00:18:35,120 --> 00:18:39,919
views all function

00:18:37,919 --> 00:18:42,240
so views all takes a borrowed range

00:18:39,919 --> 00:18:44,000
remember that's either an l value range

00:18:42,240 --> 00:18:46,240
or something like a span or a string

00:18:44,000 --> 00:18:49,440
view

00:18:46,240 --> 00:18:51,120
and it returned to a view object

00:18:49,440 --> 00:18:53,120
so here's an example we've got an l

00:18:51,120 --> 00:18:53,520
value vector we're passing it into views

00:18:53,120 --> 00:18:56,240
all

00:18:53,520 --> 00:18:58,240
and we're getting out some view object

00:18:56,240 --> 00:19:00,160
um this is in fact going to be

00:18:58,240 --> 00:19:01,280
a ref view i mean you don't really have

00:19:00,160 --> 00:19:03,200
to care

00:19:01,280 --> 00:19:04,640
but it's going to be a refu it's tiny

00:19:03,200 --> 00:19:05,280
object it's literally a wrapper around

00:19:04,640 --> 00:19:06,960
the pointer

00:19:05,280 --> 00:19:11,440
so this is incredibly cheap to pass

00:19:06,960 --> 00:19:14,480
around to copy etc

00:19:11,440 --> 00:19:16,720
so together views and borrowed ranges

00:19:14,480 --> 00:19:18,320
are collectively called viewable ranges

00:19:16,720 --> 00:19:21,600
that are that is they are things that

00:19:18,320 --> 00:19:21,600
can be turned into views

00:19:22,640 --> 00:19:27,120
why does this matter why am i why why

00:19:25,280 --> 00:19:28,000
have i delved so deep into this range of

00:19:27,120 --> 00:19:31,120
minutia

00:19:28,000 --> 00:19:33,760
well here's the most important

00:19:31,120 --> 00:19:34,559
sentence of this little section range

00:19:33,760 --> 00:19:39,840
adapters

00:19:34,559 --> 00:19:39,840
only operate on viewable ranges

00:19:41,520 --> 00:19:46,080
so in order to use a range adapter you

00:19:44,720 --> 00:19:48,000
need to have

00:19:46,080 --> 00:19:49,760
either another view or you need to have

00:19:48,000 --> 00:19:50,559
a borrowed range that is an l value

00:19:49,760 --> 00:19:52,720
container

00:19:50,559 --> 00:19:56,240
or one of these things that has

00:19:52,720 --> 00:19:56,240
specialized the borrowed range trait

00:19:56,880 --> 00:20:01,039
so uh as i said after i gave the the

00:19:59,360 --> 00:20:01,520
last two i got lots of questions from

00:20:01,039 --> 00:20:04,000
people

00:20:01,520 --> 00:20:04,960
and a lot of people um got very confused

00:20:04,000 --> 00:20:07,520
about why

00:20:04,960 --> 00:20:08,720
they were passing an r-value vector say

00:20:07,520 --> 00:20:09,919
into a pipeline

00:20:08,720 --> 00:20:12,720
and they were getting cryptic error

00:20:09,919 --> 00:20:15,760
messages out why wasn't this working

00:20:12,720 --> 00:20:18,480
well it's because range adapters

00:20:15,760 --> 00:20:20,960
only operate on viewable ranges views or

00:20:18,480 --> 00:20:22,080
borrowed ranges

00:20:20,960 --> 00:20:24,159
so let's just show you what i mean by

00:20:22,080 --> 00:20:27,360
this uh

00:20:24,159 --> 00:20:31,039
so we've got our l value vector

00:20:27,360 --> 00:20:33,440
uh called vec and here it's an l value

00:20:31,039 --> 00:20:35,360
it's got a name it's an l value so i can

00:20:33,440 --> 00:20:37,440
just pipe that interviews transform

00:20:35,360 --> 00:20:38,880
and this is going to work just fine beck

00:20:37,440 --> 00:20:40,320
has an l value therefore it's a borrowed

00:20:38,880 --> 00:20:41,760
range therefore it's viewable

00:20:40,320 --> 00:20:44,159
therefore i can use it for fuse

00:20:41,760 --> 00:20:44,159
transform

00:20:45,039 --> 00:20:48,400
second example we've got an imaginary

00:20:46,960 --> 00:20:50,400
function called get span imagine it

00:20:48,400 --> 00:20:53,200
returns a scenar value span well

00:20:50,400 --> 00:20:55,280
a span standard span is a borrowed range

00:20:53,200 --> 00:20:57,760
it's also usually a view not always

00:20:55,280 --> 00:20:59,679
let's not get into that uh but it's a

00:20:57,760 --> 00:21:00,720
borrowed range so it's viewable so it

00:20:59,679 --> 00:21:02,480
can be used

00:21:00,720 --> 00:21:05,520
as an r value with views transform

00:21:02,480 --> 00:21:05,520
that's going to work just fine

00:21:06,799 --> 00:21:10,000
sub range is a new type we're getting in

00:21:08,400 --> 00:21:12,480
the ranges library it's basically a

00:21:10,000 --> 00:21:14,880
wrapper around it just holds an iterator

00:21:12,480 --> 00:21:18,080
and a sentinel

00:21:14,880 --> 00:21:19,679
so it's very lightweight object um kind

00:21:18,080 --> 00:21:20,960
of like a span but for

00:21:19,679 --> 00:21:23,200
ranges that are not necessarily

00:21:20,960 --> 00:21:23,919
contiguous so we can construct a sub

00:21:23,200 --> 00:21:25,679
range

00:21:23,919 --> 00:21:27,600
uh just an r value sub range and we can

00:21:25,679 --> 00:21:29,600
pass that into views transform

00:21:27,600 --> 00:21:32,799
because sub range is borrowed and it

00:21:29,600 --> 00:21:34,880
happens to be a view as well

00:21:32,799 --> 00:21:35,840
however what we can't do is this last

00:21:34,880 --> 00:21:38,960
example

00:21:35,840 --> 00:21:39,520
we can't have a get vector which returns

00:21:38,960 --> 00:21:44,159
us an

00:21:39,520 --> 00:21:45,760
r value our pr value in fact vector

00:21:44,159 --> 00:21:47,280
we cannot pass that straight into the

00:21:45,760 --> 00:21:49,760
views transform

00:21:47,280 --> 00:21:50,320
because get vector returns us an r value

00:21:49,760 --> 00:21:52,400
vector

00:21:50,320 --> 00:21:53,440
and that's neither a view nor is it a

00:21:52,400 --> 00:21:55,440
borrowed range

00:21:53,440 --> 00:21:56,640
vector does not have this trait

00:21:55,440 --> 00:21:59,919
specialized because

00:21:56,640 --> 00:22:03,039
its iterators cannot safely dangle

00:21:59,919 --> 00:22:04,720
so most of the time people try and do

00:22:03,039 --> 00:22:07,520
something like this last example

00:22:04,720 --> 00:22:08,480
they get uh unfortunately really cryptic

00:22:07,520 --> 00:22:10,559
error messages

00:22:08,480 --> 00:22:11,520
um hopefully you know we're getting

00:22:10,559 --> 00:22:13,760
better at that

00:22:11,520 --> 00:22:14,799
hopefully uh as these things mature

00:22:13,760 --> 00:22:16,640
we'll get

00:22:14,799 --> 00:22:18,640
uh you know compiler arranges which will

00:22:16,640 --> 00:22:20,240
get better using real concepts and so

00:22:18,640 --> 00:22:23,039
forth

00:22:20,240 --> 00:22:24,640
um but you cannot do this last thing uh

00:22:23,039 --> 00:22:26,799
and the reason for that is that

00:22:24,640 --> 00:22:27,679
uh the transform view actually has to

00:22:26,799 --> 00:22:30,960
store

00:22:27,679 --> 00:22:33,840
the thing it's called on inside it

00:22:30,960 --> 00:22:34,240
and if it stored a vector inside it well

00:22:33,840 --> 00:22:36,640
then

00:22:34,240 --> 00:22:38,799
its destruction operation its copy

00:22:36,640 --> 00:22:41,840
operation

00:22:38,799 --> 00:22:42,960
would then have to call the equivalent

00:22:41,840 --> 00:22:46,640
operations on the vector

00:22:42,960 --> 00:22:49,440
and they'd uh no longer be constant time

00:22:46,640 --> 00:22:49,840
so it would violate the requirements of

00:22:49,440 --> 00:22:52,799
the

00:22:49,840 --> 00:22:53,360
view concept so you can't do this last

00:22:52,799 --> 00:22:55,440
one

00:22:53,360 --> 00:22:57,360
what you have to do is in fact save the

00:22:55,440 --> 00:22:58,159
vector in the name variable and pass

00:22:57,360 --> 00:23:00,640
that

00:22:58,159 --> 00:23:00,640
into the

00:23:01,360 --> 00:23:09,039
algorithm sorry the adapter

00:23:04,960 --> 00:23:12,000
so we started off just looking at

00:23:09,039 --> 00:23:13,679
uh getting the minimum elements it turns

00:23:12,000 --> 00:23:15,520
out we solved that on slide one

00:23:13,679 --> 00:23:17,440
uh but it helped us get down this rabbit

00:23:15,520 --> 00:23:18,240
hole as looking at borrowed ranges and

00:23:17,440 --> 00:23:21,120
views

00:23:18,240 --> 00:23:22,640
um i did uh write a blog post on this as

00:23:21,120 --> 00:23:24,000
well if you're somebody who likes

00:23:22,640 --> 00:23:26,080
uh reading things and having a bit of a

00:23:24,000 --> 00:23:27,440
reference um i haven't put a link to it

00:23:26,080 --> 00:23:28,480
on the slides i probably will before

00:23:27,440 --> 00:23:30,159
they're put up

00:23:28,480 --> 00:23:31,520
um but if you go to my website

00:23:30,159 --> 00:23:33,760
tristanbrindle.com

00:23:31,520 --> 00:23:35,840
uh there is a blog post on this where i

00:23:33,760 --> 00:23:39,200
go into a bit more detail

00:23:35,840 --> 00:23:39,200
than i've been able to today

00:23:41,120 --> 00:23:46,240
so that's part one

00:23:44,640 --> 00:23:48,080
let's go i'm gonna have a quick sip of

00:23:46,240 --> 00:23:51,840
water and then we'll go on to look at

00:23:48,080 --> 00:23:51,840
problem number two

00:23:55,039 --> 00:23:58,880
so our second problem

00:24:00,640 --> 00:24:04,000
given an array of integer integers

00:24:02,240 --> 00:24:05,600
calculate the sum of the squares and the

00:24:04,000 --> 00:24:07,200
values it contains

00:24:05,600 --> 00:24:09,200
so for example if we're given an array

00:24:07,200 --> 00:24:09,600
containing minus two minus one zero one

00:24:09,200 --> 00:24:12,240
two

00:24:09,600 --> 00:24:12,799
squares are four one zero one four add

00:24:12,240 --> 00:24:15,919
them up

00:24:12,799 --> 00:24:18,799
and hopefully you get ten so how can we

00:24:15,919 --> 00:24:21,120
do this with the existing stl uh

00:24:18,799 --> 00:24:22,320
well in various ways of course there are

00:24:21,120 --> 00:24:23,760
always multiple ways of doing this but

00:24:22,320 --> 00:24:26,159
one way we might do

00:24:23,760 --> 00:24:27,840
is uh by using standard transform

00:24:26,159 --> 00:24:30,080
followed by standard accumulate

00:24:27,840 --> 00:24:32,080
so transform we're going to transform

00:24:30,080 --> 00:24:32,960
beginning from the beginning of the

00:24:32,080 --> 00:24:34,080
vector to the end

00:24:32,960 --> 00:24:35,360
we're going to put the results back in

00:24:34,080 --> 00:24:36,559
the beginning of the vector we're going

00:24:35,360 --> 00:24:39,120
to apply this

00:24:36,559 --> 00:24:40,320
transform this square function to every

00:24:39,120 --> 00:24:41,760
element

00:24:40,320 --> 00:24:43,440
so we're going to transform the vector

00:24:41,760 --> 00:24:43,760
in place replace every element with

00:24:43,440 --> 00:24:45,200
there

00:24:43,760 --> 00:24:46,960
with its square and then we're going to

00:24:45,200 --> 00:24:50,400
use accumulate to sum up

00:24:46,960 --> 00:24:54,080
the values that we have so

00:24:50,400 --> 00:24:54,080
again pretty straightforward and

00:24:54,400 --> 00:24:58,240
we can of course replace standard

00:24:56,559 --> 00:25:00,080
transform with standard ranges transform

00:24:58,240 --> 00:25:00,640
we no longer need to say vector begin

00:25:00,080 --> 00:25:03,279
and vector

00:25:00,640 --> 00:25:04,559
end for the first vector we do for the

00:25:03,279 --> 00:25:05,279
second because it takes an output

00:25:04,559 --> 00:25:06,559
iterator

00:25:05,279 --> 00:25:08,000
but we can replace this with ranges

00:25:06,559 --> 00:25:10,720
transform and this is going to do

00:25:08,000 --> 00:25:12,480
exactly the same thing

00:25:10,720 --> 00:25:14,880
but we can immediately do quite a lot

00:25:12,480 --> 00:25:17,600
better and that's by replacing

00:25:14,880 --> 00:25:19,279
the eager transform ranges transform

00:25:17,600 --> 00:25:23,760
with this

00:25:19,279 --> 00:25:23,760
lazy transform view instead

00:25:24,640 --> 00:25:30,559
so this is a lazy

00:25:28,000 --> 00:25:31,679
operation this only performs the

00:25:30,559 --> 00:25:35,039
transformation

00:25:31,679 --> 00:25:36,960
when we de-reference the iterators

00:25:35,039 --> 00:25:38,080
as we do reference the iterators

00:25:36,960 --> 00:25:41,679
[Music]

00:25:38,080 --> 00:25:43,520
as we're iterating over this range

00:25:41,679 --> 00:25:45,200
so this is immediately bigger better

00:25:43,520 --> 00:25:46,080
because previously we were doing two

00:25:45,200 --> 00:25:48,799
passes

00:25:46,080 --> 00:25:51,039
over the input range now wants to

00:25:48,799 --> 00:25:55,039
transform and then wants to accumulate

00:25:51,039 --> 00:25:59,200
now we're just doing one pass

00:25:55,039 --> 00:25:59,200
so immediately this is pretty cool

00:26:00,720 --> 00:26:06,559
and we can write it uh using the pipe

00:26:04,480 --> 00:26:08,000
syntax as well so we're having vec

00:26:06,559 --> 00:26:10,000
and then we're piping it through views

00:26:08,000 --> 00:26:11,120
transform with this square operation and

00:26:10,000 --> 00:26:12,480
then we're piping it through views

00:26:11,120 --> 00:26:16,400
common

00:26:12,480 --> 00:26:16,880
so just to explain what's happening

00:26:16,400 --> 00:26:18,640
there

00:26:16,880 --> 00:26:20,080
it turns out in this specific case we

00:26:18,640 --> 00:26:22,400
don't need views

00:26:20,080 --> 00:26:23,840
we can get away without it but because

00:26:22,400 --> 00:26:27,440
accumulate is a c plus

00:26:23,840 --> 00:26:30,480
17 era algorithm it expects its

00:26:27,440 --> 00:26:32,559
two uh its

00:26:30,480 --> 00:26:33,919
begin and end values to have the same

00:26:32,559 --> 00:26:37,120
type for them both to be

00:26:33,919 --> 00:26:40,159
iterators but in the ranges world

00:26:37,120 --> 00:26:41,919
we can have separate sentinel types

00:26:40,159 --> 00:26:43,200
and this is going to uh confuse

00:26:41,919 --> 00:26:45,200
accumulate

00:26:43,200 --> 00:26:47,360
so it's good practice if you're calling

00:26:45,200 --> 00:26:50,159
a c plus plus 17 error algorithm

00:26:47,360 --> 00:26:51,840
to uh on a transformed range it's to pop

00:26:50,159 --> 00:26:53,120
this views common adapter at the end and

00:26:51,840 --> 00:26:55,760
what views common does

00:26:53,120 --> 00:26:57,679
is it transforms the range into one that

00:26:55,760 --> 00:26:58,559
has a common type for the iterator and

00:26:57,679 --> 00:27:00,480
sentinel

00:26:58,559 --> 00:27:01,840
so it turns out that in this specific

00:27:00,480 --> 00:27:02,799
case we wouldn't need it if we were just

00:27:01,840 --> 00:27:03,679
doing a transform

00:27:02,799 --> 00:27:05,600
but if we were doing something more

00:27:03,679 --> 00:27:07,440
complicated something like a filter then

00:27:05,600 --> 00:27:09,919
we might need it

00:27:07,440 --> 00:27:10,640
so fuse common does nothing if it's

00:27:09,919 --> 00:27:13,760
already

00:27:10,640 --> 00:27:16,159
uh it's just a pass through if

00:27:13,760 --> 00:27:18,320
the range already has the same type so

00:27:16,159 --> 00:27:20,000
there's no harm in popping it on the end

00:27:18,320 --> 00:27:21,600
and it's good practice if we're passing

00:27:20,000 --> 00:27:25,840
something into a c

00:27:21,600 --> 00:27:27,440
plus plus 17 error algorithm like this

00:27:25,840 --> 00:27:29,440
so we've replaced standard transform

00:27:27,440 --> 00:27:32,960
with views transform that's great

00:27:29,440 --> 00:27:35,120
um what can we do about accumulate

00:27:32,960 --> 00:27:37,039
well unfortunately c plus 20 doesn't

00:27:35,120 --> 00:27:38,559
have rangified versions of the

00:27:37,039 --> 00:27:40,159
algorithms from the numeric header

00:27:38,559 --> 00:27:43,760
remember accumulate is in this

00:27:40,159 --> 00:27:47,360
other header numeric not in algorithm i

00:27:43,760 --> 00:27:51,200
wish i knew why this split had occurred

00:27:47,360 --> 00:27:51,919
um fingers crossed we're going to have

00:27:51,200 --> 00:27:53,840
this in c

00:27:51,919 --> 00:27:55,440
plus 23. uh it turns out that the

00:27:53,840 --> 00:27:57,279
numerical algorithms are actually

00:27:55,440 --> 00:27:58,799
pretty difficult to specify the concepts

00:27:57,279 --> 00:27:59,600
for that's why they're not in c plus

00:27:58,799 --> 00:28:01,440
plus 20.

00:27:59,600 --> 00:28:03,279
but work is underway uh christopher de

00:28:01,440 --> 00:28:05,440
bella is um

00:28:03,279 --> 00:28:07,440
has a paper in progress i believe the

00:28:05,440 --> 00:28:10,000
committee's looked at it once already

00:28:07,440 --> 00:28:10,559
um to bring these to c plus plus 23. and

00:28:10,000 --> 00:28:12,399
i know c

00:28:10,559 --> 00:28:13,520
plus 23 is all up in the air and i can't

00:28:12,399 --> 00:28:14,159
promise anything it's going to be in

00:28:13,520 --> 00:28:15,600
there

00:28:14,159 --> 00:28:18,000
but i'm really hopeful that we're going

00:28:15,600 --> 00:28:22,240
to get these numeric algorithms in c

00:28:18,000 --> 00:28:24,399
plus 23. so being that we don't have

00:28:22,240 --> 00:28:25,520
a range of fight accumulate let's write

00:28:24,399 --> 00:28:26,720
one

00:28:25,520 --> 00:28:28,720
so this is the rabbit hole that we're

00:28:26,720 --> 00:28:30,399
going down this time right

00:28:28,720 --> 00:28:32,320
because i imagine a lot of people a lot

00:28:30,399 --> 00:28:35,200
of you will have um

00:28:32,320 --> 00:28:36,159
algorithm in your your own code base

00:28:35,200 --> 00:28:39,440
that use these

00:28:36,159 --> 00:28:44,480
c plus plus 17 uh older

00:28:39,440 --> 00:28:45,919
um concepts concepts and the purpose of

00:28:44,480 --> 00:28:47,919
this is to kind of show you how you can

00:28:45,919 --> 00:28:50,640
modernize those to use c plus plus 20

00:28:47,919 --> 00:28:50,640
ranges instead

00:28:50,799 --> 00:28:54,159
yes okay the you know sort of tricked

00:28:53,600 --> 00:28:56,399
you with the

00:28:54,159 --> 00:28:57,919
the sum of the some of the squares that

00:28:56,399 --> 00:29:00,559
was just that was just a hook to get us

00:28:57,919 --> 00:29:00,559
into doing this

00:29:00,880 --> 00:29:05,760
so let's begin with a an implementation

00:29:03,840 --> 00:29:09,120
of accumulate as it starts out

00:29:05,760 --> 00:29:11,440
in c plus 17. so

00:29:09,120 --> 00:29:13,679
this is this is accumulate with the

00:29:11,440 --> 00:29:16,880
default plus operation

00:29:13,679 --> 00:29:20,320
we're just going to update init in it

00:29:16,880 --> 00:29:22,960
every time every as we iterate over add

00:29:20,320 --> 00:29:26,159
the new value to the existing value and

00:29:22,960 --> 00:29:27,600
then finally return the value so

00:29:26,159 --> 00:29:28,080
immediately the first change we want to

00:29:27,600 --> 00:29:30,399
make

00:29:28,080 --> 00:29:32,159
as i mentioned c plus plus 20 ranges we

00:29:30,399 --> 00:29:33,520
can support different iterator and

00:29:32,159 --> 00:29:35,440
sentiment types so we're going to add a

00:29:33,520 --> 00:29:38,080
new template parameter s

00:29:35,440 --> 00:29:39,200
um for the sentinel and you can see the

00:29:38,080 --> 00:29:40,000
only thing we're supposed that we're

00:29:39,200 --> 00:29:42,240
doing with

00:29:40,000 --> 00:29:44,880
last is comparing it to first that's the

00:29:42,240 --> 00:29:48,320
only thing sentinels are required to do

00:29:44,880 --> 00:29:48,320
so we're all good

00:29:48,799 --> 00:29:52,320
there's actually uh there are actually

00:29:50,240 --> 00:29:55,840
two overloads of accumulate

00:29:52,320 --> 00:29:58,399
in c plus plus 17

00:29:55,840 --> 00:29:59,679
and older one of which takes a

00:29:58,399 --> 00:30:02,000
user-defined operation

00:29:59,679 --> 00:30:03,279
and one of which defaults the operation

00:30:02,000 --> 00:30:05,200
to plus

00:30:03,279 --> 00:30:06,960
well we can combine both of those things

00:30:05,200 --> 00:30:08,000
we can just have one version

00:30:06,960 --> 00:30:09,520
what we're going to do is we're going to

00:30:08,000 --> 00:30:10,159
add the operation as a template

00:30:09,520 --> 00:30:12,480
parameter

00:30:10,159 --> 00:30:14,320
that's defaulted to using standard plus

00:30:12,480 --> 00:30:17,200
and then as a function parameter

00:30:14,320 --> 00:30:17,919
we're just going to uh again default uh

00:30:17,200 --> 00:30:20,320
construct

00:30:17,919 --> 00:30:21,760
the operation we were given and then in

00:30:20,320 --> 00:30:23,120
the body of the loop you can see we're

00:30:21,760 --> 00:30:26,080
using this operation

00:30:23,120 --> 00:30:26,720
so if you call this function without the

00:30:26,080 --> 00:30:29,039
uh op

00:30:26,720 --> 00:30:30,000
argument it's just going to do exactly

00:30:29,039 --> 00:30:32,799
what the

00:30:30,000 --> 00:30:32,799
old version did

00:30:34,159 --> 00:30:38,399
so i mentioned that accumulate in

00:30:37,600 --> 00:30:40,559
particular

00:30:38,399 --> 00:30:42,240
uh is quite difficult to specify

00:30:40,559 --> 00:30:44,640
concepts for

00:30:42,240 --> 00:30:45,919
it's um again this is this is a rabbit

00:30:44,640 --> 00:30:48,480
hole i don't want to go down

00:30:45,919 --> 00:30:49,279
um so we're not going to try and do that

00:30:48,480 --> 00:30:51,360
that would take

00:30:49,279 --> 00:30:52,960
you know this entire video i would

00:30:51,360 --> 00:30:54,399
imagine um

00:30:52,960 --> 00:30:57,039
so what we're going to do is we're going

00:30:54,399 --> 00:30:59,200
to use concepts

00:30:57,039 --> 00:31:00,640
just enough to be able to disambiguate

00:30:59,200 --> 00:31:02,840
the overloads of accumulate that we're

00:31:00,640 --> 00:31:05,840
going to write

00:31:02,840 --> 00:31:07,600
um if we were you know masochistic we

00:31:05,840 --> 00:31:10,559
could use sweeney to do this

00:31:07,600 --> 00:31:12,799
we're going to use concepts instead so

00:31:10,559 --> 00:31:14,720
actually conceptifying your algorithms

00:31:12,799 --> 00:31:16,240
generally tends to be really really

00:31:14,720 --> 00:31:18,320
difficult um

00:31:16,240 --> 00:31:19,840
in my experience at least so just for

00:31:18,320 --> 00:31:20,320
the purposes of this example we're not

00:31:19,840 --> 00:31:23,279
going to go

00:31:20,320 --> 00:31:24,320
all in we're just going to use enough

00:31:23,279 --> 00:31:25,760
just to dissemble

00:31:24,320 --> 00:31:28,159
disambiguate the overloads that we're

00:31:25,760 --> 00:31:29,679
going to write

00:31:28,159 --> 00:31:32,559
so these are the concepts we're going to

00:31:29,679 --> 00:31:33,760
introduce so we now require that i is an

00:31:32,559 --> 00:31:37,840
input integrator

00:31:33,760 --> 00:31:40,480
and s is a sentinel for i

00:31:37,840 --> 00:31:42,000
so we're using a requires clause here of

00:31:40,480 --> 00:31:43,360
course we can put these in the template

00:31:42,000 --> 00:31:46,000
head instead

00:31:43,360 --> 00:31:48,320
so we're saying that is input iterator s

00:31:46,000 --> 00:31:50,159
is a sentinel for i

00:31:48,320 --> 00:31:53,919
um and apart from that everything is

00:31:50,159 --> 00:31:53,919
added was everything's hunky-dory

00:31:54,080 --> 00:31:58,159
there's actually one more cool thing we

00:31:55,360 --> 00:32:00,080
can do um

00:31:58,159 --> 00:32:01,679
standard accumulate you always have to

00:32:00,080 --> 00:32:05,679
provide the initial value

00:32:01,679 --> 00:32:07,120
uh begin vector end zero um

00:32:05,679 --> 00:32:09,120
that's kind of a drag i wish we didn't

00:32:07,120 --> 00:32:10,640
have to do that uh so

00:32:09,120 --> 00:32:13,120
for our implementation what we're gonna

00:32:10,640 --> 00:32:14,880
do is we're gonna provide a default

00:32:13,120 --> 00:32:16,799
uh for the init type so we're going to

00:32:14,880 --> 00:32:18,880
use this alias value t

00:32:16,799 --> 00:32:20,000
which is the value as you might imagine

00:32:18,880 --> 00:32:23,200
the value type

00:32:20,000 --> 00:32:24,640
of the iterator i so we're going to

00:32:23,200 --> 00:32:26,720
default the template parameter

00:32:24,640 --> 00:32:29,120
we're going to default the function

00:32:26,720 --> 00:32:29,919
parameter to just a default constructed

00:32:29,120 --> 00:32:33,200
in it

00:32:29,919 --> 00:32:37,039
so for our case we're

00:32:33,200 --> 00:32:39,919
calling this on a vector of integers

00:32:37,039 --> 00:32:40,640
the value type of uh the iterator is

00:32:39,919 --> 00:32:41,919
going to be an int

00:32:40,640 --> 00:32:44,000
we're going to default constructor name

00:32:41,919 --> 00:32:46,240
to zero so we're going to get what we

00:32:44,000 --> 00:32:46,240
want

00:32:48,320 --> 00:32:51,600
so let's have a look at what that does

00:32:49,600 --> 00:32:54,000
to our uh

00:32:51,600 --> 00:32:55,679
function uh a little function we were

00:32:54,000 --> 00:32:57,360
writing

00:32:55,679 --> 00:32:58,640
well this is what it looked like before

00:32:57,360 --> 00:32:59,600
and we're going to replace this with our

00:32:58,640 --> 00:33:03,039
newly written

00:32:59,600 --> 00:33:05,679
range accumulate function and well

00:33:03,039 --> 00:33:07,200
okay we've managed to drop the zero but

00:33:05,679 --> 00:33:08,159
so far it doesn't look that different

00:33:07,200 --> 00:33:10,000
the other thing we've been able to get

00:33:08,159 --> 00:33:11,279
rid of these views common because we now

00:33:10,000 --> 00:33:13,039
support separate

00:33:11,279 --> 00:33:14,480
sentinel iterator and sentiment types we

00:33:13,039 --> 00:33:16,960
no longer need common

00:33:14,480 --> 00:33:19,760
so it's a little bit nicer but there's a

00:33:16,960 --> 00:33:19,760
little way to go yet

00:33:21,600 --> 00:33:25,440
the next thing we want to do is to be

00:33:23,440 --> 00:33:29,120
able to support

00:33:25,440 --> 00:33:30,240
passing ranges directly so

00:33:29,120 --> 00:33:33,760
what we're going to do is we're going to

00:33:30,240 --> 00:33:37,360
add a second overload of accumulate

00:33:33,760 --> 00:33:39,440
and this is what it looks like so

00:33:37,360 --> 00:33:41,360
this is saying we're taking template

00:33:39,440 --> 00:33:43,120
parameters and the input range are

00:33:41,360 --> 00:33:45,519
an initial value which this time we

00:33:43,120 --> 00:33:45,919
defaulted to the range value type that's

00:33:45,519 --> 00:33:48,159
the

00:33:45,919 --> 00:33:48,960
it's a value type of the iterator type

00:33:48,159 --> 00:33:50,480
of the range

00:33:48,960 --> 00:33:52,320
which again in our case is going to be

00:33:50,480 --> 00:33:55,279
int and we're defaulting the operations

00:33:52,320 --> 00:33:55,279
to standard plus again

00:33:57,039 --> 00:34:02,720
so we're going to and in the body of

00:34:00,640 --> 00:34:03,679
accumulate the range based accumulate

00:34:02,720 --> 00:34:05,840
all we're going to do

00:34:03,679 --> 00:34:07,279
is call begin and end on the range we

00:34:05,840 --> 00:34:09,040
were given and we're going to

00:34:07,279 --> 00:34:10,800
forward to the iterator the

00:34:09,040 --> 00:34:12,720
intersentinal based version

00:34:10,800 --> 00:34:14,000
and this is exactly what all of the

00:34:12,720 --> 00:34:17,200
range-based

00:34:14,000 --> 00:34:18,480
the the range-based algorithms do in c

00:34:17,200 --> 00:34:20,399
plus plus 20.

00:34:18,480 --> 00:34:23,040
all they do is just forward to the

00:34:20,399 --> 00:34:24,879
iterator sentinel versions

00:34:23,040 --> 00:34:26,720
so this is uh you know perfectly

00:34:24,879 --> 00:34:29,599
inlineable by the compiler this is

00:34:26,720 --> 00:34:30,639
this is really uh trivial for it to do

00:34:29,599 --> 00:34:32,639
so we've now got

00:34:30,639 --> 00:34:34,159
two overloads of accumulate one taking

00:34:32,639 --> 00:34:34,879
iterator and sentinel that actually does

00:34:34,159 --> 00:34:36,399
the work

00:34:34,879 --> 00:34:38,399
one that takes a range that just

00:34:36,399 --> 00:34:41,520
forwards to the other version

00:34:38,399 --> 00:34:41,520
the convenience overlap

00:34:44,720 --> 00:34:50,560
so using this we no longer have to call

00:34:47,200 --> 00:34:53,040
view don't begin and view dot end

00:34:50,560 --> 00:34:53,919
we can just call range accumulate on our

00:34:53,040 --> 00:34:56,240
view

00:34:53,919 --> 00:34:58,879
so hey this is now starting to look a

00:34:56,240 --> 00:34:58,879
bit nicer

00:34:58,880 --> 00:35:03,599
in fact we can go a bit further no

00:35:01,839 --> 00:35:07,599
longer have to save the view

00:35:03,599 --> 00:35:11,520
as a named variable we can just pass it

00:35:07,599 --> 00:35:11,520
straight into accumulate just like that

00:35:11,839 --> 00:35:16,079
so you know whether you find this more

00:35:14,400 --> 00:35:17,920
readable or not

00:35:16,079 --> 00:35:21,200
i guess it's a matter of a matter of

00:35:17,920 --> 00:35:24,480
preference but you know we can do it now

00:35:21,200 --> 00:35:27,760
so that's that's pretty nice

00:35:24,480 --> 00:35:29,359
but it could be nicer still because the

00:35:27,760 --> 00:35:32,880
rangers algorithms

00:35:29,359 --> 00:35:35,760
uh in c plus 20 most of them take

00:35:32,880 --> 00:35:37,040
an extra optional parameter called a

00:35:35,760 --> 00:35:39,040
projection

00:35:37,040 --> 00:35:40,640
now i talked about uh projections in the

00:35:39,040 --> 00:35:42,960
overview talk last year

00:35:40,640 --> 00:35:44,960
uh gave an example of what they do and

00:35:42,960 --> 00:35:46,400
how you use them

00:35:44,960 --> 00:35:47,920
but a projection is basically like a

00:35:46,400 --> 00:35:48,720
transform that is built into the

00:35:47,920 --> 00:35:51,839
algorithm

00:35:48,720 --> 00:35:53,200
call itself so uh

00:35:51,839 --> 00:35:54,480
they're really handy i really love

00:35:53,200 --> 00:35:55,680
projections i don't think they get

00:35:54,480 --> 00:35:58,800
enough love

00:35:55,680 --> 00:36:02,079
so i'm going to add a projection to

00:35:58,800 --> 00:36:02,079
our version of accumulate

00:36:02,160 --> 00:36:05,760
so here's what our iterator sentinel

00:36:04,400 --> 00:36:08,480
version looks like with a

00:36:05,760 --> 00:36:11,280
projection so you can see i've added an

00:36:08,480 --> 00:36:13,760
extra template parameter

00:36:11,280 --> 00:36:16,800
uh proj and that's defaulted to this

00:36:13,760 --> 00:36:19,040
type stood identity so stood identity is

00:36:16,800 --> 00:36:20,880
just a pass-through function it does

00:36:19,040 --> 00:36:23,280
absolutely nothing it just returns what

00:36:20,880 --> 00:36:26,400
you give it

00:36:23,280 --> 00:36:28,400
so proj is defaulted to standard

00:36:26,400 --> 00:36:30,480
identity but of course we can

00:36:28,400 --> 00:36:32,800
provide our own project projection if we

00:36:30,480 --> 00:36:34,160
want

00:36:32,800 --> 00:36:35,599
and then so we're defaulting the

00:36:34,160 --> 00:36:37,200
template parameter and again we're

00:36:35,599 --> 00:36:37,680
defaulting the function parameter as

00:36:37,200 --> 00:36:39,359
well

00:36:37,680 --> 00:36:41,839
to just the default constructed whatever

00:36:39,359 --> 00:36:41,839
projection

00:36:42,240 --> 00:36:46,079
and then in the body of the loop you can

00:36:44,400 --> 00:36:49,760
see instead of just passing

00:36:46,079 --> 00:36:52,320
star first into the

00:36:49,760 --> 00:36:53,119
operation what we're first doing is

00:36:52,320 --> 00:36:56,480
invoking

00:36:53,119 --> 00:36:58,000
the projection on star first

00:36:56,480 --> 00:36:59,839
so this is what projections do they're

00:36:58,000 --> 00:37:02,400
like a transform built

00:36:59,839 --> 00:37:04,880
into the operating built into the

00:37:02,400 --> 00:37:04,880
algorithm

00:37:05,119 --> 00:37:10,880
so uh again if we're just using identity

00:37:09,200 --> 00:37:12,320
this is just gonna be a pass through it

00:37:10,880 --> 00:37:13,920
it's completely transparent for compiler

00:37:12,320 --> 00:37:16,720
there's no overhead but

00:37:13,920 --> 00:37:17,359
it allows us to uh use a projection if

00:37:16,720 --> 00:37:19,520
we want

00:37:17,359 --> 00:37:21,359
um i i love projections i think they're

00:37:19,520 --> 00:37:23,599
awesome

00:37:21,359 --> 00:37:25,599
so we're also going to add one to our

00:37:23,599 --> 00:37:27,520
range accumulate

00:37:25,599 --> 00:37:29,520
um just exactly the same we're just

00:37:27,520 --> 00:37:31,040
going to uh default to using standard

00:37:29,520 --> 00:37:32,960
identity the pass through

00:37:31,040 --> 00:37:37,359
and we're going to default construct the

00:37:32,960 --> 00:37:39,040
approach argument to our function

00:37:37,359 --> 00:37:41,040
so this incidentally is the reason that

00:37:39,040 --> 00:37:43,839
we uh

00:37:41,040 --> 00:37:45,119
just use this minimum amount of concept

00:37:43,839 --> 00:37:48,079
is because

00:37:45,119 --> 00:37:49,440
because these things take uh both of

00:37:48,079 --> 00:37:50,640
these overloads take variable numbers of

00:37:49,440 --> 00:37:52,160
parameters we need to be able to

00:37:50,640 --> 00:37:54,480
disambiguate them

00:37:52,160 --> 00:37:55,680
um in a way that couldn't be done well

00:37:54,480 --> 00:37:57,359
uh

00:37:55,680 --> 00:37:59,040
but you'd have to use screen a and lots

00:37:57,359 --> 00:38:02,960
of horrible things to do in c

00:37:59,040 --> 00:38:07,200
plus 98 now we can use concepts

00:38:02,960 --> 00:38:08,960
and it's a lot of things life is better

00:38:07,200 --> 00:38:10,000
so again in the body of this function

00:38:08,960 --> 00:38:11,200
we're just going to forward the

00:38:10,000 --> 00:38:18,720
projection parameter

00:38:11,200 --> 00:38:21,440
onto our uh main overload of accumulate

00:38:18,720 --> 00:38:22,160
so here's uh some square function as it

00:38:21,440 --> 00:38:23,599
was

00:38:22,160 --> 00:38:25,440
we're calling it accumulate on this

00:38:23,599 --> 00:38:27,760
transformed vect well

00:38:25,440 --> 00:38:28,480
now we can dispense with views

00:38:27,760 --> 00:38:31,520
transformed

00:38:28,480 --> 00:38:33,520
we can just use our projection uh

00:38:31,520 --> 00:38:35,040
directly so we're going to call

00:38:33,520 --> 00:38:38,000
accumulate on the vector

00:38:35,040 --> 00:38:39,119
we're going to default the initializer

00:38:38,000 --> 00:38:41,359
it's just going to be an into

00:38:39,119 --> 00:38:44,400
zero i could have written zero in there

00:38:41,359 --> 00:38:46,400
we're going to default the comparator

00:38:44,400 --> 00:38:47,440
not the comparator sorry the um the

00:38:46,400 --> 00:38:49,119
binary operation

00:38:47,440 --> 00:38:51,280
it's gonna be standard plus and then

00:38:49,119 --> 00:38:51,920
we're gonna pass this uh lambda as our

00:38:51,280 --> 00:38:55,359
projection

00:38:51,920 --> 00:38:58,720
that's gonna square every element right

00:38:55,359 --> 00:39:01,440
i think this is this is cool and

00:38:58,720 --> 00:39:02,720
of course because accumulate doesn't

00:39:01,440 --> 00:39:04,880
return iterators

00:39:02,720 --> 00:39:06,800
it just uses the users up the range

00:39:04,880 --> 00:39:08,160
we're not uh returning any iterators

00:39:06,800 --> 00:39:08,640
into the range we don't have to worry

00:39:08,160 --> 00:39:10,800
about

00:39:08,640 --> 00:39:11,920
lifetime issues about dangling about

00:39:10,800 --> 00:39:15,040
borrowed ranges

00:39:11,920 --> 00:39:16,640
we can just replace this uh we can just

00:39:15,040 --> 00:39:18,240
pass get input straight into our

00:39:16,640 --> 00:39:21,520
accumulate function

00:39:18,240 --> 00:39:22,480
um and so yes you can do this with

00:39:21,520 --> 00:39:24,400
transform reduce

00:39:22,480 --> 00:39:26,079
in the existing stl but i think this is

00:39:24,400 --> 00:39:29,839
really cool this is what we hopefully

00:39:26,079 --> 00:39:29,839
will be getting in c plus plus 23.

00:39:30,400 --> 00:39:33,680
so all being well we will get rangified

00:39:32,720 --> 00:39:36,400
versions of

00:39:33,680 --> 00:39:37,520
um accumulate and friends adjacent

00:39:36,400 --> 00:39:39,359
difference all the other

00:39:37,520 --> 00:39:40,839
algorithms in the numeric header all

00:39:39,359 --> 00:39:43,920
being well we'll get those in c plus

00:39:40,839 --> 00:39:45,440
23. in the meantime i have written some

00:39:43,920 --> 00:39:48,320
implementations of

00:39:45,440 --> 00:39:50,640
uh accumulating trends that are

00:39:48,320 --> 00:39:52,880
compatible with cpl plus 20 ranges

00:39:50,640 --> 00:39:54,880
uh you can find them at that github link

00:39:52,880 --> 00:39:56,640
um they're there as a stop gap until we

00:39:54,880 --> 00:39:59,119
get there the real thing in c plus plus

00:39:56,640 --> 00:39:59,119
23.

00:40:02,400 --> 00:40:06,079
so i hope that was a useful example of

00:40:04,480 --> 00:40:08,800
how we can uh

00:40:06,079 --> 00:40:10,079
how you can go up if quite rapid fire

00:40:08,800 --> 00:40:13,920
example of how you can

00:40:10,079 --> 00:40:16,240
rangify um c plus plus 17 algorithms

00:40:13,920 --> 00:40:17,040
uh how it can make the function your

00:40:16,240 --> 00:40:19,440
function calls

00:40:17,040 --> 00:40:21,440
i think prettier easier to use more

00:40:19,440 --> 00:40:25,839
express easier to read more expressive

00:40:21,440 --> 00:40:25,839
um you know i like it

00:40:29,599 --> 00:40:34,079
so time is marching on so without

00:40:32,480 --> 00:40:37,200
further ado

00:40:34,079 --> 00:40:40,560
let's move on to our third problem for

00:40:37,200 --> 00:40:41,359
today which is string trimming this is

00:40:40,560 --> 00:40:46,079
my favorite

00:40:41,359 --> 00:40:46,079
i've been looking forward to this one so

00:40:46,400 --> 00:40:49,920
here's our problem statement this time

00:40:47,760 --> 00:40:52,000
around so given an input string

00:40:49,920 --> 00:40:54,560
we want to construct a new string with a

00:40:52,000 --> 00:40:56,880
leading and trailing white space removed

00:40:54,560 --> 00:40:58,640
so if we have this string with a bunch

00:40:56,880 --> 00:41:01,839
of junk at the front

00:40:58,640 --> 00:41:05,200
space new line tab etc at the front

00:41:01,839 --> 00:41:08,240
and at the rear we want to get rid of it

00:41:05,200 --> 00:41:10,240
and just return hello world now

00:41:08,240 --> 00:41:12,000
again as with all these problems there

00:41:10,240 --> 00:41:13,119
are tons of ways that you could do this

00:41:12,000 --> 00:41:15,520
[Music]

00:41:13,119 --> 00:41:16,880
obviously we're going to be using ranges

00:41:15,520 --> 00:41:20,079
and in particular for this problem we're

00:41:16,880 --> 00:41:21,359
going to be using range adapters

00:41:20,079 --> 00:41:24,000
first of all let's have a look at the

00:41:21,359 --> 00:41:27,040
function we want to write we want to

00:41:24,000 --> 00:41:27,599
take if we're given a string we want to

00:41:27,040 --> 00:41:29,359
call

00:41:27,599 --> 00:41:31,839
we have this function called trimstra

00:41:29,359 --> 00:41:34,079
and we want to return a new string

00:41:31,839 --> 00:41:37,040
um i could have taken a string view but

00:41:34,079 --> 00:41:39,440
uh you know i'm being old school

00:41:37,040 --> 00:41:40,640
so the way we're going to do this is

00:41:39,440 --> 00:41:41,839
we're going to break the problem into

00:41:40,640 --> 00:41:43,440
two

00:41:41,839 --> 00:41:46,839
we're first of all going to write a trim

00:41:43,440 --> 00:41:49,839
function which returns us a range

00:41:46,839 --> 00:41:49,839
adapter

00:41:50,000 --> 00:41:53,520
returns us uh sorry an adapted range

00:41:52,079 --> 00:41:55,119
returns as a view

00:41:53,520 --> 00:41:56,800
and then we're going to pass that view

00:41:55,119 --> 00:41:57,440
to a tostring function which is going to

00:41:56,800 --> 00:42:00,720
convert it

00:41:57,440 --> 00:42:02,000
into a string so we're going to break

00:42:00,720 --> 00:42:04,319
the down of a problem down into two

00:42:02,000 --> 00:42:04,319
parts

00:42:04,640 --> 00:42:09,520
so first of all let's look at two string

00:42:08,079 --> 00:42:11,839
what does our two string function look

00:42:09,520 --> 00:42:14,000
like so our two string function is going

00:42:11,839 --> 00:42:17,119
to accept any range again i'm emitting

00:42:14,000 --> 00:42:19,839
uh concepts here just for for brevity um

00:42:17,119 --> 00:42:21,040
if we were being really uh you know

00:42:19,839 --> 00:42:23,359
doing this

00:42:21,040 --> 00:42:24,160
in in production or for something that

00:42:23,359 --> 00:42:27,680
was going to be

00:42:24,160 --> 00:42:29,280
uh used uh in a variety of situations

00:42:27,680 --> 00:42:29,760
you'd want to use the concepts here i'm

00:42:29,280 --> 00:42:32,400
just

00:42:29,760 --> 00:42:34,640
omitting them just just for brevity

00:42:32,400 --> 00:42:34,640
really

00:42:35,040 --> 00:42:38,880
so how do we implement this tostring

00:42:37,760 --> 00:42:43,520
function

00:42:38,880 --> 00:42:45,280
well here is one way we can do it so

00:42:43,520 --> 00:42:48,480
sanders string has a constructor that

00:42:45,280 --> 00:42:51,839
accepts uh an iterator pair

00:42:48,480 --> 00:42:55,119
um but that that expects

00:42:51,839 --> 00:42:55,599
a c plus plus 17 uh iterated pair that

00:42:55,119 --> 00:42:58,319
is

00:42:55,599 --> 00:42:59,520
begin and end having the same type so in

00:42:58,319 --> 00:43:02,560
order to use it

00:42:59,520 --> 00:43:05,920
we need to uh

00:43:02,560 --> 00:43:06,560
or possibly need to pass the input range

00:43:05,920 --> 00:43:09,520
that we're given

00:43:06,560 --> 00:43:10,839
through views common again just as we

00:43:09,520 --> 00:43:13,839
did before

00:43:10,839 --> 00:43:15,119
um if we are given a range that have

00:43:13,839 --> 00:43:16,880
differing inter

00:43:15,119 --> 00:43:18,319
iterator and sentinel types this is

00:43:16,880 --> 00:43:21,520
going to sort that out for us

00:43:18,319 --> 00:43:22,640
and give us something that most of the

00:43:21,520 --> 00:43:24,640
time we can call

00:43:22,640 --> 00:43:26,319
the standard string constructor on

00:43:24,640 --> 00:43:29,520
obviously goes on said this

00:43:26,319 --> 00:43:32,800
uh also requires a range whose uh

00:43:29,520 --> 00:43:34,640
reference type is convertible to a char

00:43:32,800 --> 00:43:35,920
uh this is as i said if we were doing

00:43:34,640 --> 00:43:37,359
concepts that's

00:43:35,920 --> 00:43:39,760
on this function that's what we would

00:43:37,359 --> 00:43:42,560
check um

00:43:39,760 --> 00:43:43,280
one of the things we would check uh this

00:43:42,560 --> 00:43:45,440
function

00:43:43,280 --> 00:43:46,319
is gonna and you can adapt this function

00:43:45,440 --> 00:43:48,480
you can imagine

00:43:46,319 --> 00:43:49,359
uh writing a very similar two vector

00:43:48,480 --> 00:43:52,480
function

00:43:49,359 --> 00:43:53,359
um a function like this is going to

00:43:52,480 --> 00:43:56,079
serve

00:43:53,359 --> 00:43:57,440
going to do what you need 90 something

00:43:56,079 --> 00:43:59,200
percent of the time

00:43:57,440 --> 00:44:00,480
there are a few corner cases that this

00:43:59,200 --> 00:44:02,880
won't handle

00:44:00,480 --> 00:44:04,720
a few types of iterators that even after

00:44:02,880 --> 00:44:07,040
passing them through views common

00:44:04,720 --> 00:44:08,800
the that aren't valid c plus 17

00:44:07,040 --> 00:44:10,400
iterators the most common is

00:44:08,800 --> 00:44:12,720
move only iterators which are a new

00:44:10,400 --> 00:44:13,280
thing in ranges they're not very heavily

00:44:12,720 --> 00:44:16,319
used

00:44:13,280 --> 00:44:19,839
yet um but

00:44:16,319 --> 00:44:19,839
they are they wouldn't be handled by

00:44:20,839 --> 00:44:25,200
this

00:44:22,000 --> 00:44:25,760
as i say 95 percent of the time uh this

00:44:25,200 --> 00:44:27,280
is going to do

00:44:25,760 --> 00:44:28,880
this is going to do the right thing but

00:44:27,280 --> 00:44:32,560
we can do better

00:44:28,880 --> 00:44:34,640
if we're using range v3 range v3 has um

00:44:32,560 --> 00:44:37,440
an adapter called ranges 2 so you can do

00:44:34,640 --> 00:44:39,440
something like this you can construct a

00:44:37,440 --> 00:44:41,520
complex pipeline and at the end of it

00:44:39,440 --> 00:44:44,560
you can put ranges to

00:44:41,520 --> 00:44:46,160
standard string and that will eagerly or

00:44:44,560 --> 00:44:46,960
that will process the range consume the

00:44:46,160 --> 00:44:51,680
range

00:44:46,960 --> 00:44:54,880
and convert it into a standard string

00:44:51,680 --> 00:44:57,680
so ranges two is really awesome

00:44:54,880 --> 00:44:59,280
unfortunately uh it was proposed for c

00:44:57,680 --> 00:45:01,040
plus plus 20 but uh

00:44:59,280 --> 00:45:02,560
unfortunately was just a bit too late in

00:45:01,040 --> 00:45:03,680
the process so it didn't make it into c

00:45:02,560 --> 00:45:05,599
plus plus 20.

00:45:03,680 --> 00:45:07,359
it's another one of those things that i

00:45:05,599 --> 00:45:10,720
really hope is going to be in 23.

00:45:07,359 --> 00:45:12,640
uh it has been proposed

00:45:10,720 --> 00:45:14,480
uh you know the proposal is still in

00:45:12,640 --> 00:45:15,200
flight um i really hope we're going to

00:45:14,480 --> 00:45:16,960
see it uh

00:45:15,200 --> 00:45:18,560
it's really really useful it handles all

00:45:16,960 --> 00:45:21,760
the corner cases that uh

00:45:18,560 --> 00:45:25,680
this function doesn't so

00:45:21,760 --> 00:45:27,920
uh yeah can we use ranges to

00:45:25,680 --> 00:45:29,280
well as i say it's not in 20 but

00:45:27,920 --> 00:45:31,680
fortunately um

00:45:29,280 --> 00:45:32,400
korean town uh i hope i pronounced that

00:45:31,680 --> 00:45:36,000
right

00:45:32,400 --> 00:45:37,520
uh who is the author of um rangers 2 and

00:45:36,000 --> 00:45:41,040
various

00:45:37,520 --> 00:45:43,839
copious other standard library papers um

00:45:41,040 --> 00:45:44,400
has written a library he calls ranges

00:45:43,839 --> 00:45:46,960
next

00:45:44,400 --> 00:45:48,079
which has an implementation of ranges 2

00:45:46,960 --> 00:45:50,800
that is compatible

00:45:48,079 --> 00:45:51,680
with c plus plus 20 ranges so if you go

00:45:50,800 --> 00:45:53,680
to that link on it

00:45:51,680 --> 00:45:54,960
it's also got um you know a few other

00:45:53,680 --> 00:45:57,599
things

00:45:54,960 --> 00:45:58,560
that we hope to see in 23 um that i

00:45:57,599 --> 00:46:01,839
proposed

00:45:58,560 --> 00:46:02,880
so this is a sort of rangers extension

00:46:01,839 --> 00:46:05,280
library

00:46:02,880 --> 00:46:08,160
that we uh of things that um will

00:46:05,280 --> 00:46:09,760
hopefully see the light of day in 23

00:46:08,160 --> 00:46:12,480
so this is a really really useful thing

00:46:09,760 --> 00:46:14,880
to know uh

00:46:12,480 --> 00:46:15,599
for for things that you would that you

00:46:14,880 --> 00:46:19,040
would like but

00:46:15,599 --> 00:46:20,800
aren't yet in c plus what are

00:46:19,040 --> 00:46:23,359
in in the standard version not in sql

00:46:20,800 --> 00:46:23,359
plus 20.

00:46:24,160 --> 00:46:27,440
so rather than having rather than

00:46:25,680 --> 00:46:28,960
writing that to string function

00:46:27,440 --> 00:46:30,720
we're gonna we're not gonna bother with

00:46:28,960 --> 00:46:32,319
a function call we're just gonna have

00:46:30,720 --> 00:46:33,920
our trim strap function

00:46:32,319 --> 00:46:35,599
and we're gonna do what we said before

00:46:33,920 --> 00:46:38,079
we're gonna

00:46:35,599 --> 00:46:38,800
in a minute write a trim function that

00:46:38,079 --> 00:46:40,720
returns us

00:46:38,800 --> 00:46:42,800
a view and we're gonna pipe that view

00:46:40,720 --> 00:46:46,800
into quarantine's

00:46:42,800 --> 00:46:46,800
ranges next to implementation

00:46:47,440 --> 00:46:51,920
um and of course we don't really need

00:46:50,079 --> 00:46:53,839
the intermediate variable there we can

00:46:51,920 --> 00:46:55,520
just do it like this

00:46:53,839 --> 00:46:57,200
oh sorry that shouldn't be returned view

00:46:55,520 --> 00:47:00,800
equals that should just be returned trim

00:46:57,200 --> 00:47:02,920
straw pipe thing that's a that's a bad

00:47:00,800 --> 00:47:05,200
copy paste error i apologize for that

00:47:02,920 --> 00:47:07,839
[Music]

00:47:05,200 --> 00:47:08,800
so that's how we're going to do the

00:47:07,839 --> 00:47:10,480
string conversion

00:47:08,800 --> 00:47:12,960
how are we going to write this range

00:47:10,480 --> 00:47:12,960
adapter

00:47:13,359 --> 00:47:16,560
well let's have a go at it now

00:47:17,119 --> 00:47:21,760
let's start off with a function template

00:47:20,079 --> 00:47:23,200
a template over function a template of a

00:47:21,760 --> 00:47:24,720
function template

00:47:23,200 --> 00:47:26,480
that looks like this so we're going to

00:47:24,720 --> 00:47:27,839
have our trim it's going to take

00:47:26,480 --> 00:47:30,880
an arbitrary range and it's going to

00:47:27,839 --> 00:47:32,400
return something

00:47:30,880 --> 00:47:35,119
well actually again we're going to break

00:47:32,400 --> 00:47:37,520
the problem down into two

00:47:35,119 --> 00:47:39,280
we're going to write a trim trim front

00:47:37,520 --> 00:47:40,720
which removes white space from the front

00:47:39,280 --> 00:47:41,839
of the string

00:47:40,720 --> 00:47:45,359
and we're going to write a trim back

00:47:41,839 --> 00:47:45,359
that removes white space from the end

00:47:45,599 --> 00:47:48,800
so the reason we're going to do that

00:47:47,520 --> 00:47:50,559
it's not just because it makes it easier

00:47:48,800 --> 00:47:52,800
but because trim front and trim back are

00:47:50,559 --> 00:47:55,839
useful operations in their own rights

00:47:52,800 --> 00:47:56,960
so and you know it kind of makes sense

00:47:55,839 --> 00:47:58,559
to do it this way

00:47:56,960 --> 00:48:00,240
so we're going to take the range we're

00:47:58,559 --> 00:48:00,960
going to pass it through this trim front

00:48:00,240 --> 00:48:02,240
adapter

00:48:00,960 --> 00:48:03,839
we're going to pass the result of that

00:48:02,240 --> 00:48:05,280
through the trim back adapter and then

00:48:03,839 --> 00:48:08,640
we're going to return that

00:48:05,280 --> 00:48:08,640
as the return value of trim

00:48:09,200 --> 00:48:16,240
so next level let's dive even deeper

00:48:13,040 --> 00:48:18,960
let's take a look at trim front how do

00:48:16,240 --> 00:48:22,079
we write trim front

00:48:18,960 --> 00:48:25,200
we want to trim white space characters

00:48:22,079 --> 00:48:25,200
from the front of our range

00:48:26,000 --> 00:48:30,400
that is we want to begin at the

00:48:28,319 --> 00:48:31,920
beginning of our range

00:48:30,400 --> 00:48:34,079
look at our cat look at each character

00:48:31,920 --> 00:48:35,359
in turn say is this white space okay

00:48:34,079 --> 00:48:37,040
well that's no longer the beginning of

00:48:35,359 --> 00:48:38,960
my range the next one is is that white

00:48:37,040 --> 00:48:40,720
space oh it is okay well i'm now going

00:48:38,960 --> 00:48:44,160
to say that's the beginning of my range

00:48:40,720 --> 00:48:46,559
and so on and so on we want to

00:48:44,160 --> 00:48:47,359
drop elements from the front of our

00:48:46,559 --> 00:48:51,040
range

00:48:47,359 --> 00:48:54,319
whilst a condition is true

00:48:51,040 --> 00:48:57,599
and yes there is an adapter in c plus

00:48:54,319 --> 00:48:59,680
20 that does this it's called drop while

00:48:57,599 --> 00:49:02,319
so what we can do is we can take our

00:48:59,680 --> 00:49:03,440
range and we can use the drop while

00:49:02,319 --> 00:49:06,720
adapter

00:49:03,440 --> 00:49:08,559
and the is space function um

00:49:06,720 --> 00:49:10,240
it's not great but for the purposes of

00:49:08,559 --> 00:49:12,079
slides that's what i'm going to use

00:49:10,240 --> 00:49:15,200
just the e-base function which tells you

00:49:12,079 --> 00:49:18,480
if a chart is

00:49:15,200 --> 00:49:20,400
is a particular character is uh

00:49:18,480 --> 00:49:24,000
considered white space or not according

00:49:20,400 --> 00:49:24,000
to seed rules anyway

00:49:24,319 --> 00:49:28,720
so what trim front is going to do is

00:49:27,280 --> 00:49:30,480
it's going to return us an

00:49:28,720 --> 00:49:31,839
adapted range it's going to take the

00:49:30,480 --> 00:49:35,440
range we give it

00:49:31,839 --> 00:49:36,559
it's going to apply this lazy drop while

00:49:35,440 --> 00:49:38,240
adapter

00:49:36,559 --> 00:49:39,680
and it's going to return us some

00:49:38,240 --> 00:49:41,359
specialization of

00:49:39,680 --> 00:49:45,839
drop while view we don't really care

00:49:41,359 --> 00:49:45,839
that's why the function returns

00:49:46,079 --> 00:49:49,760
and i've written it using the function

00:49:48,400 --> 00:49:51,359
call syntax

00:49:49,760 --> 00:49:53,839
i could equally have written it using

00:49:51,359 --> 00:49:55,760
the pipe syntax like this the two are

00:49:53,839 --> 00:49:59,839
equivalent

00:49:55,760 --> 00:49:59,839
so this is going to

00:49:59,920 --> 00:50:04,160
give us an adapted range that drops the

00:50:02,800 --> 00:50:07,520
white space from the front

00:50:04,160 --> 00:50:09,760
of our range so we're halfway there

00:50:07,520 --> 00:50:09,760
yes

00:50:10,720 --> 00:50:16,559
so now let's have a look at trim back

00:50:12,960 --> 00:50:16,559
how do we implement treatment trim back

00:50:17,119 --> 00:50:21,040
well in the ideal world what we would be

00:50:20,079 --> 00:50:22,319
able to do

00:50:21,040 --> 00:50:24,079
is we'd be able to do something like

00:50:22,319 --> 00:50:27,839
this we'd be able to call views drop

00:50:24,079 --> 00:50:30,319
last while which would go from the end

00:50:27,839 --> 00:50:31,760
do the same as drop drop while but work

00:50:30,319 --> 00:50:33,839
from the back of the range

00:50:31,760 --> 00:50:35,119
unfortunately drop drop last while

00:50:33,839 --> 00:50:38,559
doesn't exist

00:50:35,119 --> 00:50:40,000
um you can write it and it's not it's

00:50:38,559 --> 00:50:41,599
not all that hard to do i have an

00:50:40,000 --> 00:50:42,720
implementation of it if anybody's really

00:50:41,599 --> 00:50:45,040
curious

00:50:42,720 --> 00:50:48,000
um but unfortunately this doesn't exist

00:50:45,040 --> 00:50:50,160
in c plus 20.

00:50:48,000 --> 00:50:51,760
i doubt we've said in 23 anyway and the

00:50:50,160 --> 00:50:52,559
reason for that is because it's possible

00:50:51,760 --> 00:50:55,520
to do this

00:50:52,559 --> 00:50:57,440
another way if you think about what we

00:50:55,520 --> 00:50:59,839
want to do

00:50:57,440 --> 00:51:02,400
we want to whereas drop while goes from

00:50:59,839 --> 00:51:04,319
the beginning of the range

00:51:02,400 --> 00:51:06,960
we want to do exactly the same thing but

00:51:04,319 --> 00:51:09,359
work backwards from the end

00:51:06,960 --> 00:51:11,200
so the way we can do that is by first

00:51:09,359 --> 00:51:13,520
reversing our range

00:51:11,200 --> 00:51:16,720
then counting from the front and then

00:51:13,520 --> 00:51:16,720
reversing the range again

00:51:18,319 --> 00:51:23,040
so rather than using drop drop last

00:51:20,640 --> 00:51:25,520
while view that doesn't exist

00:51:23,040 --> 00:51:27,200
we're going to take our range we're

00:51:25,520 --> 00:51:28,640
going to reverse it

00:51:27,200 --> 00:51:31,200
we're going to drop from what is now the

00:51:28,640 --> 00:51:33,440
front and then we're going to reverse it

00:51:31,200 --> 00:51:33,440
again

00:51:35,119 --> 00:51:38,160
so this is pretty cool i think this is

00:51:37,520 --> 00:51:41,200
building up

00:51:38,160 --> 00:51:42,000
a pipe an operation pipeline to trim

00:51:41,200 --> 00:51:44,000
from the back

00:51:42,000 --> 00:51:45,359
by reversing of course this requires a

00:51:44,000 --> 00:51:46,960
bi-directional range

00:51:45,359 --> 00:51:48,880
uh again if we were doing concepts we

00:51:46,960 --> 00:51:50,880
take care of that but a standard string

00:51:48,880 --> 00:51:52,079
string view almost any string type you

00:51:50,880 --> 00:51:54,880
use is going to be bi-directional so

00:51:52,079 --> 00:51:54,880
that's not going to be problem

00:51:54,960 --> 00:51:58,880
so let's put these things uh together

00:51:56,880 --> 00:52:01,839
and have a look at

00:51:58,880 --> 00:52:03,839
have a look at where we're where we are

00:52:01,839 --> 00:52:07,280
with our trimming

00:52:03,839 --> 00:52:09,839
operations so we've got trim front

00:52:07,280 --> 00:52:10,480
we use a drop while trim back which

00:52:09,839 --> 00:52:13,200
reverses

00:52:10,480 --> 00:52:14,720
uses drop while reverses and then we've

00:52:13,200 --> 00:52:16,960
got trim

00:52:14,720 --> 00:52:18,480
which combines the two operations and

00:52:16,960 --> 00:52:19,440
then we've got this trimster version

00:52:18,480 --> 00:52:21,599
which

00:52:19,440 --> 00:52:22,880
just does this especially for standard

00:52:21,599 --> 00:52:25,440
strings because that's what we were

00:52:22,880 --> 00:52:25,440
asked to write

00:52:30,839 --> 00:52:37,119
so this is pretty good now

00:52:34,160 --> 00:52:38,240
you know i i quite like this this does

00:52:37,119 --> 00:52:41,920
what we were asked to

00:52:38,240 --> 00:52:44,160
it's one uh page code and we've got

00:52:41,920 --> 00:52:45,839
these reusable trim trim back and trim

00:52:44,160 --> 00:52:49,200
front operations that will retur

00:52:45,839 --> 00:52:52,480
will work on any bi-directional range of

00:52:49,200 --> 00:52:54,319
char more or less

00:52:52,480 --> 00:52:55,760
so you know this is pretty good as it

00:52:54,319 --> 00:52:58,800
stands

00:52:55,760 --> 00:52:58,800
but we can make it better

00:52:58,960 --> 00:53:04,240
so let's uh for a moment focus back in

00:53:02,160 --> 00:53:06,319
on trim front again

00:53:04,240 --> 00:53:08,000
so what does this do this function takes

00:53:06,319 --> 00:53:11,119
an arbitrary range

00:53:08,000 --> 00:53:13,680
and it pipes it through drop while

00:53:11,119 --> 00:53:16,559
and this is returns us an adapted range

00:53:13,680 --> 00:53:16,559
a lazy range

00:53:18,800 --> 00:53:24,400
well actually we don't really need to do

00:53:22,480 --> 00:53:26,000
all this work that we're doing at least

00:53:24,400 --> 00:53:29,119
not in this function

00:53:26,000 --> 00:53:31,599
what we can do instead instead of taking

00:53:29,119 --> 00:53:32,720
an arbitrary range and piping it through

00:53:31,599 --> 00:53:34,880
drop while

00:53:32,720 --> 00:53:36,079
is we can just return the drop while

00:53:34,880 --> 00:53:37,440
view itself

00:53:36,079 --> 00:53:39,280
this is now instead of returning an

00:53:37,440 --> 00:53:43,839
adapted range we're now

00:53:39,280 --> 00:53:43,839
just returning the adapter

00:53:45,200 --> 00:53:48,559
so we're not quite doing the same thing

00:53:47,200 --> 00:53:49,520
we were before we're doing something

00:53:48,559 --> 00:53:50,880
slightly different

00:53:49,520 --> 00:53:52,880
but as you can see we're cleaning up the

00:53:50,880 --> 00:53:54,960
code a bit

00:53:52,880 --> 00:53:56,559
instead of returning an adapted range

00:53:54,960 --> 00:54:00,000
we're just going to return the adapter

00:53:56,559 --> 00:54:00,000
that later on someone can use

00:54:02,240 --> 00:54:05,599
and we can do the same thing with trim

00:54:03,920 --> 00:54:07,440
back

00:54:05,599 --> 00:54:09,359
so here's trim back as it was as a

00:54:07,440 --> 00:54:12,480
function template

00:54:09,359 --> 00:54:14,079
taking an arbitrary range and we can do

00:54:12,480 --> 00:54:17,920
the same thing

00:54:14,079 --> 00:54:20,960
instead of returning an adapted range

00:54:17,920 --> 00:54:22,720
we're going to compose adapters to

00:54:20,960 --> 00:54:25,839
return a new adapter

00:54:22,720 --> 00:54:26,480
now this is something that i don't think

00:54:25,839 --> 00:54:28,800
many people

00:54:26,480 --> 00:54:32,240
uh know really that you can do with

00:54:28,800 --> 00:54:35,760
ranges but uh is really cool

00:54:32,240 --> 00:54:37,119
is reverse is just an adapter drop while

00:54:35,760 --> 00:54:39,200
is just an adapter

00:54:37,119 --> 00:54:41,119
but we can compose these things together

00:54:39,200 --> 00:54:41,920
even without piping a range into them at

00:54:41,119 --> 00:54:43,760
the start

00:54:41,920 --> 00:54:45,920
we can compose these things together to

00:54:43,760 --> 00:54:49,200
create a new adapter

00:54:45,920 --> 00:54:52,480
which is ready for use which we can pipe

00:54:49,200 --> 00:54:55,599
a range into

00:54:52,480 --> 00:54:58,000
so that's pretty cool um

00:54:55,599 --> 00:55:00,240
helps to simplify our code or does it

00:54:58,000 --> 00:55:00,240
well

00:55:00,720 --> 00:55:04,000
if you think about what we have to do

00:55:02,000 --> 00:55:05,359
now trim front is a function that

00:55:04,000 --> 00:55:08,160
returns an adapter

00:55:05,359 --> 00:55:08,960
so in our trim function um things have

00:55:08,160 --> 00:55:10,240
got to be

00:55:08,960 --> 00:55:11,680
gone a bit haywire things have gone a

00:55:10,240 --> 00:55:12,640
bit lispy we've got lots of trends

00:55:11,680 --> 00:55:14,480
everywhere

00:55:12,640 --> 00:55:15,760
so we're calling trim front that's

00:55:14,480 --> 00:55:18,640
returning us an adapter

00:55:15,760 --> 00:55:20,319
and then we're calling that adapter uh

00:55:18,640 --> 00:55:21,520
and passing at our adapted range

00:55:20,319 --> 00:55:23,520
and then we're doing the same thing with

00:55:21,520 --> 00:55:25,359
trim back

00:55:23,520 --> 00:55:28,079
so this is beginning to look a little

00:55:25,359 --> 00:55:30,480
bit nasty now

00:55:28,079 --> 00:55:32,000
fortunately things begin to begin to

00:55:30,480 --> 00:55:36,480
make a lot more sense

00:55:32,000 --> 00:55:39,920
if we use the pipe syntax instead

00:55:36,480 --> 00:55:42,000
so now trim takes the range you give it

00:55:39,920 --> 00:55:43,040
passes it through trim front passes it

00:55:42,000 --> 00:55:45,520
through the

00:55:43,040 --> 00:55:47,200
adapter the trim front returns passes

00:55:45,520 --> 00:55:48,880
that through the adapter the trim back

00:55:47,200 --> 00:55:52,480
returns

00:55:48,880 --> 00:55:53,440
and you know gives you the adapted range

00:55:52,480 --> 00:55:55,200
which we're then going

00:55:53,440 --> 00:55:58,559
iterating over using ranges to

00:55:55,200 --> 00:55:58,559
converting it to a string

00:55:59,680 --> 00:56:04,240
so instead of three function templates

00:56:02,799 --> 00:56:06,079
we've now just got two

00:56:04,240 --> 00:56:08,960
in fact we can apply exactly the same

00:56:06,079 --> 00:56:12,160
logic to trim itself

00:56:08,960 --> 00:56:13,359
so trim we can replace with something

00:56:12,160 --> 00:56:15,200
that just

00:56:13,359 --> 00:56:16,799
takes the return value of trim front

00:56:15,200 --> 00:56:18,880
that's takes an adapter

00:56:16,799 --> 00:56:21,520
composes it with the adapter returned by

00:56:18,880 --> 00:56:24,240
trim back

00:56:21,520 --> 00:56:25,200
and then in our trim strip function you

00:56:24,240 --> 00:56:27,119
could say we're calling

00:56:25,200 --> 00:56:28,880
calling trim first that's giving us back

00:56:27,119 --> 00:56:31,839
an adapter and then we're applying

00:56:28,880 --> 00:56:32,640
straw to that adapter again this looks

00:56:31,839 --> 00:56:34,720
kind of

00:56:32,640 --> 00:56:36,559
horrible if you look at it like this it

00:56:34,720 --> 00:56:41,440
makes more sense

00:56:36,559 --> 00:56:41,440
if you use the pipe syntax instead

00:56:43,440 --> 00:56:49,280
so this is this is

00:56:47,359 --> 00:56:52,319
like looking pretty nice now i think i

00:56:49,280 --> 00:56:53,920
like this i think this is cool

00:56:52,319 --> 00:56:56,079
but there's one more trick we can play

00:56:53,920 --> 00:56:56,480
well trick it's not a trick there's one

00:56:56,079 --> 00:56:58,079
more

00:56:56,480 --> 00:57:00,880
awesome thing we can do to make this

00:56:58,079 --> 00:57:00,880
even nicer

00:57:01,839 --> 00:57:06,559
so here's our function trim front that

00:57:04,880 --> 00:57:08,480
we were just looking at

00:57:06,559 --> 00:57:09,920
and this now returns us the drop while

00:57:08,480 --> 00:57:13,359
adapter using

00:57:09,920 --> 00:57:16,559
his space well this is a function that

00:57:13,359 --> 00:57:16,559
always returns the same thing

00:57:16,960 --> 00:57:20,559
returns us the views drop while function

00:57:19,599 --> 00:57:22,160
object

00:57:20,559 --> 00:57:23,680
this this call is going to return this

00:57:22,160 --> 00:57:24,799
function object

00:57:23,680 --> 00:57:27,359
so this function's always going to

00:57:24,799 --> 00:57:30,720
return the function return the same

00:57:27,359 --> 00:57:35,920
thing what we can do is save it

00:57:30,720 --> 00:57:35,920
as an inline constexpr variable

00:57:38,000 --> 00:57:41,440
so we no longer need the function call

00:57:40,400 --> 00:57:44,559
this is this is

00:57:41,440 --> 00:57:46,079
awesome so uh inline variables are a

00:57:44,559 --> 00:57:46,880
reasonably new thing they just save you

00:57:46,079 --> 00:57:49,200
from um

00:57:46,880 --> 00:57:50,799
potential odr violations in if you

00:57:49,200 --> 00:57:54,160
include the header and take the address

00:57:50,799 --> 00:57:57,200
and what have you uh consexper doesn't

00:57:54,160 --> 00:57:58,799
by the way refer to the um call operator

00:57:57,200 --> 00:58:00,480
here it just refers to the constructor

00:57:58,799 --> 00:58:00,880
and we can construct this at compile

00:58:00,480 --> 00:58:04,400
time

00:58:00,880 --> 00:58:08,240
and that's all fine so

00:58:04,400 --> 00:58:10,559
we can replace trim front instead of

00:58:08,240 --> 00:58:12,799
it being a function it's now just a

00:58:10,559 --> 00:58:14,559
function object

00:58:12,799 --> 00:58:16,319
and we can do the same thing with trim

00:58:14,559 --> 00:58:17,760
back we can replace our function

00:58:16,319 --> 00:58:20,240
with just a function object that does

00:58:17,760 --> 00:58:20,240
the same thing

00:58:21,440 --> 00:58:25,280
so trim back is reversed composed with

00:58:24,240 --> 00:58:29,359
drop while

00:58:25,280 --> 00:58:31,680
uh of his space composed with reverse

00:58:29,359 --> 00:58:32,559
so you can do that for trim back sorry

00:58:31,680 --> 00:58:34,960
for trim front

00:58:32,559 --> 00:58:36,400
for trim back and of course we can do it

00:58:34,960 --> 00:58:38,480
for trim as well

00:58:36,400 --> 00:58:40,880
and now we've reduced our code even

00:58:38,480 --> 00:58:40,880
further

00:58:41,839 --> 00:58:46,640
and i think that this is absolutely

00:58:44,799 --> 00:58:49,599
amazing i absolutely love this

00:58:46,640 --> 00:58:51,119
so our trim string function what he does

00:58:49,599 --> 00:58:54,160
it takes the string

00:58:51,119 --> 00:58:55,599
it pipes it through trim and then it

00:58:54,160 --> 00:58:58,720
pipes that onto

00:58:55,599 --> 00:59:02,319
range's range next to

00:58:58,720 --> 00:59:04,480
and trim is composed of two adapters

00:59:02,319 --> 00:59:06,160
and one is one of those is a

00:59:04,480 --> 00:59:07,680
specialization of a standard adapter

00:59:06,160 --> 00:59:10,000
another one is a composition

00:59:07,680 --> 00:59:11,280
of some standard adapters i think this

00:59:10,000 --> 00:59:13,280
is absolutely awesome

00:59:11,280 --> 00:59:19,839
i love this and this is what makes me

00:59:13,280 --> 00:59:19,839
excited to work on ranges

00:59:20,559 --> 00:59:27,440
so that's it for my for my talk

00:59:24,160 --> 00:59:29,680
um i have used up every moment of my

00:59:27,440 --> 00:59:32,160
allotted time so thank you very much

00:59:29,680 --> 00:59:35,599
everyone for uh

00:59:32,160 --> 00:59:37,760
sticking along um i hope we've still got

00:59:35,599 --> 00:59:40,480
a couple of minutes left for questions

00:59:37,760 --> 00:59:42,000
um i'll maybe take just take a couple of

00:59:40,480 --> 00:59:44,480
questions because i'm not quite sure how

00:59:42,000 --> 00:59:47,920
long we've got

00:59:44,480 --> 00:59:51,040
otherwise i will be hanging around um

00:59:47,920 --> 00:59:52,319
in uh in the the remo lobby um just in

00:59:51,040 --> 00:59:54,079
about five minutes or so

00:59:52,319 --> 00:59:55,760
come and find the table i'm sitting on

00:59:54,079 --> 00:59:57,839
and um i'll be happy to

00:59:55,760 --> 00:59:59,680
answer questions um for as long as

00:59:57,839 --> 01:00:02,720
people keep asking them

00:59:59,680 --> 01:00:02,720
so thank you very much

01:00:03,119 --> 01:00:08,319
uh so just gonna look at some questions

01:00:06,079 --> 01:00:10,000
now

01:00:08,319 --> 01:00:11,920
could you immediately do reference the

01:00:10,000 --> 01:00:12,799
dangling iterator to avoid the lifetime

01:00:11,920 --> 01:00:16,000
issue

01:00:12,799 --> 01:00:19,280
so this is a good question so in so

01:00:16,000 --> 01:00:22,079
if you say star range is min element

01:00:19,280 --> 01:00:23,520
um you are correct in that if you did

01:00:22,079 --> 01:00:24,960
that that would there would be no

01:00:23,520 --> 01:00:27,520
lifetime issue

01:00:24,960 --> 01:00:28,960
however mid element doesn't know that

01:00:27,520 --> 01:00:30,400
you're immediately going to dereference

01:00:28,960 --> 01:00:32,240
it so min elements

01:00:30,400 --> 01:00:33,920
passed in our value range is still going

01:00:32,240 --> 01:00:37,520
to return you a dangling so

01:00:33,920 --> 01:00:39,200
that line as written in the question

01:00:37,520 --> 01:00:40,799
is going to generate a compile error

01:00:39,200 --> 01:00:44,160
that you saw before

01:00:40,799 --> 01:00:46,880
no operator star in rangers dangling

01:00:44,160 --> 01:00:47,200
fortunately um and i didn't show it uh

01:00:46,880 --> 01:00:50,400
but

01:00:47,200 --> 01:00:51,680
i i perhaps i should have done uh there

01:00:50,400 --> 01:00:55,280
is a new overload of

01:00:51,680 --> 01:00:58,720
um min called rangers min

01:00:55,280 --> 01:01:02,000
obviously uh which which does do

01:00:58,720 --> 01:01:04,799
basically does do uh the immediate um

01:01:02,000 --> 01:01:06,559
the reference that you wanted to so an

01:01:04,799 --> 01:01:07,920
even easier way to do because

01:01:06,559 --> 01:01:09,839
in the question i guarantee that the

01:01:07,920 --> 01:01:11,280
range was not empty uh we could have

01:01:09,839 --> 01:01:12,799
just used range's min

01:01:11,280 --> 01:01:14,400
and but that would have that wouldn't

01:01:12,799 --> 01:01:17,599
have allowed me to dive down this rabbit

01:01:14,400 --> 01:01:17,599
hole about borrowed ranges

01:01:19,040 --> 01:01:24,240
um so uh a question

01:01:22,799 --> 01:01:25,520
what is the point of returning rangers

01:01:24,240 --> 01:01:27,280
dangling instead of having static

01:01:25,520 --> 01:01:30,799
assertions

01:01:27,280 --> 01:01:32,480
um well actually uh

01:01:30,799 --> 01:01:34,480
for a short time during the range of

01:01:32,480 --> 01:01:38,240
standardization progress process

01:01:34,480 --> 01:01:40,960
these calls were um were made ill formed

01:01:38,240 --> 01:01:43,200
they were made hard errors

01:01:40,960 --> 01:01:44,559
and the reason you don't want that is

01:01:43,200 --> 01:01:47,440
because

01:01:44,559 --> 01:01:48,880
um it's generating the dangling iterator

01:01:47,440 --> 01:01:51,119
is not a problem

01:01:48,880 --> 01:01:51,920
it's only a problem when you try to use

01:01:51,119 --> 01:01:54,640
it

01:01:51,920 --> 01:01:56,400
so probably more algorithms than you

01:01:54,640 --> 01:01:59,359
realize return iterators so

01:01:56,400 --> 01:01:59,760
um standard copy for example standard

01:01:59,359 --> 01:02:02,559
sword

01:01:59,760 --> 01:02:04,160
these return iterators so standard sort

01:02:02,559 --> 01:02:04,720
is not very useful calling that on an r

01:02:04,160 --> 01:02:06,400
value

01:02:04,720 --> 01:02:08,319
but standard copy you can imagine

01:02:06,400 --> 01:02:09,920
copying an r value vector

01:02:08,319 --> 01:02:11,520
into an out string into an output string

01:02:09,920 --> 01:02:13,280
to print it

01:02:11,520 --> 01:02:15,280
that would be really annoying if that

01:02:13,280 --> 01:02:17,280
was disallowed because

01:02:15,280 --> 01:02:20,640
99 of the time you don't really care

01:02:17,280 --> 01:02:23,760
about the the return value of

01:02:20,640 --> 01:02:25,760
static copy so

01:02:23,760 --> 01:02:27,599
range is dangling rather than

01:02:25,760 --> 01:02:30,160
disallowing these things outright

01:02:27,599 --> 01:02:31,839
it says okay what you've done is okay

01:02:30,160 --> 01:02:35,839
provided you don't try to

01:02:31,839 --> 01:02:35,839
use what would be a dangling iterator

01:02:37,280 --> 01:02:40,559
and the reason and another suggestion

01:02:39,119 --> 01:02:42,240
it's not in the question but somebody

01:02:40,559 --> 01:02:44,720
said okay well why is this dangling type

01:02:42,240 --> 01:02:46,559
why not just void

01:02:44,720 --> 01:02:48,960
and the reason for that is as i

01:02:46,559 --> 01:02:51,920
mentioned ranges dangling is a nice

01:02:48,960 --> 01:02:52,720
uh loud uh type that shows up in your

01:02:51,920 --> 01:02:54,720
error messages

01:02:52,720 --> 01:02:56,400
that tells you exactly what's gone wrong

01:02:54,720 --> 01:02:59,119
whereas void would give you a lot more

01:02:56,400 --> 01:02:59,119
cryptic errors

01:02:59,520 --> 01:03:04,240
uh so next question i'm just i'm just

01:03:02,319 --> 01:03:07,039
going to continue until um

01:03:04,240 --> 01:03:08,960
i'm told i can't anymore so uh what's

01:03:07,039 --> 01:03:10,079
the performance impact of ranges versus

01:03:08,960 --> 01:03:13,760
the stl

01:03:10,079 --> 01:03:17,359
um so that's several questions in one

01:03:13,760 --> 01:03:18,880
that i will do my best to answer so um

01:03:17,359 --> 01:03:20,559
firstly the performance impact of the

01:03:18,880 --> 01:03:23,039
range is algorithms

01:03:20,559 --> 01:03:24,960
that is the eager the the algorithms in

01:03:23,039 --> 01:03:26,880
the standard ranges name space

01:03:24,960 --> 01:03:28,400
um you know standard ranges sort versus

01:03:26,880 --> 01:03:31,440
standard sort there is

01:03:28,400 --> 01:03:35,359
no performance impact whatsoever

01:03:31,440 --> 01:03:38,000
they are using the exact same code

01:03:35,359 --> 01:03:38,880
um almost certainly using the exact same

01:03:38,000 --> 01:03:40,400
code paths

01:03:38,880 --> 01:03:42,160
uh they do a little extra template

01:03:40,400 --> 01:03:42,720
checking constraint checking and so

01:03:42,160 --> 01:03:46,079
forth

01:03:42,720 --> 01:03:47,200
but the actual generated code is going

01:03:46,079 --> 01:03:49,440
to be the same

01:03:47,200 --> 01:03:53,520
so there is no runtime performance

01:03:49,440 --> 01:03:53,520
impact of using the eager algorithms

01:03:56,319 --> 01:04:02,240
in terms of using range adapters um

01:04:00,960 --> 01:04:05,039
it's one of those annoying answers in

01:04:02,240 --> 01:04:07,599
that it depends um

01:04:05,039 --> 01:04:08,240
as a sort of general rule that i'm very

01:04:07,599 --> 01:04:12,000
hesitant

01:04:08,240 --> 01:04:14,319
to uh say applies

01:04:12,000 --> 01:04:15,359
too widely as a general rule not just in

01:04:14,319 --> 01:04:19,200
c plus bus

01:04:15,359 --> 01:04:20,960
but using lazy evaluation is

01:04:19,200 --> 01:04:22,319
sometimes slower than doing eager

01:04:20,960 --> 01:04:25,599
evaluation

01:04:22,319 --> 01:04:27,520
now having said that we saw an example

01:04:25,599 --> 01:04:28,880
of where we reduced instead of doing two

01:04:27,520 --> 01:04:30,880
passes through a range

01:04:28,880 --> 01:04:33,200
range adapters let us just do a single

01:04:30,880 --> 01:04:35,280
pass through a range

01:04:33,200 --> 01:04:37,119
so there are situations in which using

01:04:35,280 --> 01:04:39,359
range range adapters can

01:04:37,119 --> 01:04:41,039
conceptually theoretically at least it

01:04:39,359 --> 01:04:44,400
always depends always measure

01:04:41,039 --> 01:04:44,400
etc um

01:04:45,599 --> 01:04:48,640
there are situations in which using

01:04:46,880 --> 01:04:52,240
range adapters can

01:04:48,640 --> 01:04:53,920
improve the performance of your code so

01:04:52,240 --> 01:04:56,240
the answer is unfortunately uh it

01:04:53,920 --> 01:04:58,799
depends um

01:04:56,240 --> 01:05:00,319
okay so uh my time is up so thank you

01:04:58,799 --> 01:05:01,520
very much everybody for watching

01:05:00,319 --> 01:05:03,680
thank you very much for the questions

01:05:01,520 --> 01:05:05,280
i'm sorry uh we didn't have time for

01:05:03,680 --> 01:05:06,160
many more i will be hanging around on

01:05:05,280 --> 01:05:08,720
remote

01:05:06,160 --> 01:05:11,119
um for a while so please do come and

01:05:08,720 --> 01:05:11,119
find me

01:05:11,920 --> 01:05:16,480
and um i will do my best to answer so

01:05:14,960 --> 01:05:19,359
thank you very much everybody

01:05:16,480 --> 01:05:20,400
and uh oh yes by the way these are some

01:05:19,359 --> 01:05:22,480
links that were mentioned

01:05:20,400 --> 01:05:23,839
if you uh if you just if you missed them

01:05:22,480 --> 01:05:37,839
as we were going through

01:05:23,839 --> 01:05:37,839
thank you

01:05:44,240 --> 01:05:46,319

YouTube URL: https://www.youtube.com/watch?v=d_E-VLyUnzc


