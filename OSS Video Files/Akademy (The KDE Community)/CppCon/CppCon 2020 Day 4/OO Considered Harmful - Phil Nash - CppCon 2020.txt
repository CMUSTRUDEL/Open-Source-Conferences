Title: OO Considered Harmful - Phil Nash - CppCon 2020
Publication date: 2020-10-05
Playlist: CppCon 2020 Day 4
Description: 
	https://cppcon.org/
https://github.com/CppCon/CppCon2020
---
Is C++ on OO language? What does it mean to be an OO language anyway? What were the original goals, and how have they turned out?

What other approaches are there? Some say there was nothing wrong with Structured Programming and we should go back to that. Others push for a more Functional approach. There's also Logic Programming and others. Is there one right answer? Does it depend? Does it blend?

Experienced C++ programmers think of C++ as a Multi-Paradigm language, capable of moving between paradigms as needed. But is it particularly good at any particular one? Is that focus shifting? Where is it going, and why? What can we learn from other languages.

If all this sounds very abstract, be assured that we will look at real code and techniques you can apply today or, in some cases, the near future - as well as a glimpse of what may be down the road. More importantly we try to put it in a context that helps answer "why?"

Along the way we'll take a tour through C++'s approach to OO, Generic Programming and Functional Programming. 

---
Phil Nash is a Developer Advocate at JetBrains, author of Catch/Catch2, co-host of cpp.chat, host of C++ London, chair and organiser of C++ on Sea. 

---
Streamed & Edited by Digital Medium Ltd - events.digital-medium.co.uk
events@digital-medium.co.uk
Captions: 
	00:00:08,320 --> 00:00:10,559
hello good afternoon good evening good

00:00:10,080 --> 00:00:13,280
morning

00:00:10,559 --> 00:00:13,679
delete as applicable that's the beauty

00:00:13,280 --> 00:00:16,400
of

00:00:13,679 --> 00:00:17,920
an online conference so welcome to oo

00:00:16,400 --> 00:00:19,520
considered harmful

00:00:17,920 --> 00:00:21,600
and we'll get to that title in just a

00:00:19,520 --> 00:00:23,039
moment just to introduce myself

00:00:21,600 --> 00:00:24,960
uh many of you know me anyway but i'm

00:00:23,039 --> 00:00:26,080
phil nash developer advocate of

00:00:24,960 --> 00:00:28,640
jetbrains for their

00:00:26,080 --> 00:00:29,840
uh c plus plus tools particularly c-line

00:00:28,640 --> 00:00:31,920
we do have a uh

00:00:29,840 --> 00:00:33,120
an exhibitor room here so do come and

00:00:31,920 --> 00:00:34,000
see us there in fact i'm going to do a

00:00:33,120 --> 00:00:35,680
demo

00:00:34,000 --> 00:00:37,200
in there right after this so we won't

00:00:35,680 --> 00:00:38,559
even have that much time

00:00:37,200 --> 00:00:39,920
for any socializing immediately

00:00:38,559 --> 00:00:41,520
afterwards but we'll talk about that

00:00:39,920 --> 00:00:43,120
more later

00:00:41,520 --> 00:00:45,680
uh you may also know me as the original

00:00:43,120 --> 00:00:47,840
author of catch and catch two

00:00:45,680 --> 00:00:49,120
test framework and i'm involved in a

00:00:47,840 --> 00:00:50,559
number of other things i won't bore you

00:00:49,120 --> 00:00:53,360
with the list now

00:00:50,559 --> 00:00:55,280
let's get into the subject oh oh

00:00:53,360 --> 00:00:57,039
considered harmful

00:00:55,280 --> 00:00:58,559
obviously there's a bit of a play on a

00:00:57,039 --> 00:01:00,559
meme here we call it

00:00:58,559 --> 00:01:02,879
memes these days they've had different

00:01:00,559 --> 00:01:04,640
names actually this particular pattern

00:01:02,879 --> 00:01:06,640
goes back to at least the 40s uh

00:01:04,640 --> 00:01:08,880
journalists tended to use it

00:01:06,640 --> 00:01:10,799
in the 40s and 50s i've crossed over

00:01:08,880 --> 00:01:12,720
into software development circles

00:01:10,799 --> 00:01:14,000
where arguably it became particularly

00:01:12,720 --> 00:01:17,200
famous in uh

00:01:14,000 --> 00:01:19,439
1968 and we'll get to that

00:01:17,200 --> 00:01:20,479
in just a moment but uh interestingly

00:01:19,439 --> 00:01:22,000
there's this pattern

00:01:20,479 --> 00:01:24,479
of words not this particular one but

00:01:22,000 --> 00:01:27,520
just in general using titles like this

00:01:24,479 --> 00:01:29,200
that itself has a name snow clones this

00:01:27,520 --> 00:01:32,400
is a snow clone of the

00:01:29,200 --> 00:01:35,759
considered harmful pattern

00:01:32,400 --> 00:01:38,400
and of course we know it from go to

00:01:35,759 --> 00:01:39,759
considered harmful in fact technically

00:01:38,400 --> 00:01:43,200
go to statement

00:01:39,759 --> 00:01:47,040
considered harmful was the title of

00:01:43,200 --> 00:01:52,240
edgar dykstra's original letter actually

00:01:47,040 --> 00:01:55,600
to the acm magazine i believe it was

00:01:52,240 --> 00:01:58,159
now um everybody just about

00:01:55,600 --> 00:01:58,960
knows this title but i wonder how many

00:01:58,159 --> 00:02:01,600
people have

00:01:58,960 --> 00:02:03,920
actually read it now just before i

00:02:01,600 --> 00:02:05,200
started i pasted a link into the chat

00:02:03,920 --> 00:02:07,600
so go get that if you haven't done

00:02:05,200 --> 00:02:10,080
already there's a page you can go to

00:02:07,600 --> 00:02:11,520
that will allow me to ask for some

00:02:10,080 --> 00:02:13,440
collaborative feedback

00:02:11,520 --> 00:02:14,959
uh bearing in mind the 10 second delay

00:02:13,440 --> 00:02:16,480
i'm just going to drop out of my slides

00:02:14,959 --> 00:02:18,000
for a second

00:02:16,480 --> 00:02:19,680
and you should be stuck on this page at

00:02:18,000 --> 00:02:20,959
the moment the um they're not started

00:02:19,680 --> 00:02:22,480
but if i

00:02:20,959 --> 00:02:25,040
flip it over hopefully that should have

00:02:22,480 --> 00:02:28,480
changed for you as well

00:02:25,040 --> 00:02:29,760
and i go into present mode so you can

00:02:28,480 --> 00:02:31,280
see that more clearly i can see some

00:02:29,760 --> 00:02:36,239
feedback coming in already

00:02:31,280 --> 00:02:38,640
that's great so as expected

00:02:36,239 --> 00:02:40,160
most people haven't read it uh some

00:02:38,640 --> 00:02:42,000
people may have skimmed it

00:02:40,160 --> 00:02:43,360
and all there's a few a few late entries

00:02:42,000 --> 00:02:45,360
saying they've read it fully

00:02:43,360 --> 00:02:47,280
that's good uh quite a few actually

00:02:45,360 --> 00:02:48,319
surprising number i've never heard of it

00:02:47,280 --> 00:02:50,239
so

00:02:48,319 --> 00:02:51,920
that's interesting i'll leave that

00:02:50,239 --> 00:02:52,879
running for a moment but we'll

00:02:51,920 --> 00:02:54,720
come back and have a look how you're

00:02:52,879 --> 00:02:55,440
getting on in a while i'm going to carry

00:02:54,720 --> 00:02:57,680
on

00:02:55,440 --> 00:02:59,920
with the presentation but yeah so as

00:02:57,680 --> 00:03:02,480
expected most people have not read it

00:02:59,920 --> 00:03:04,480
and if they did probably a while ago i

00:03:02,480 --> 00:03:07,599
would recommend reading it again

00:03:04,480 --> 00:03:08,400
um it's not that long uh this screenshot

00:03:07,599 --> 00:03:11,440
here is about

00:03:08,400 --> 00:03:14,159
um about half of the paper so

00:03:11,440 --> 00:03:15,920
yeah you can read it in a in a sitting

00:03:14,159 --> 00:03:17,920
some of the the wording

00:03:15,920 --> 00:03:19,280
gets a little bit intricate but it's

00:03:17,920 --> 00:03:21,040
pretty accessible as well

00:03:19,280 --> 00:03:22,720
now obviously here he's talking about go

00:03:21,040 --> 00:03:24,319
to uh

00:03:22,720 --> 00:03:26,720
we're going to be talking about ooh

00:03:24,319 --> 00:03:27,519
today and other than how the letters

00:03:26,720 --> 00:03:28,720
slot in

00:03:27,519 --> 00:03:31,280
you might be wondering what the

00:03:28,720 --> 00:03:32,640
connection is but just because i wanted

00:03:31,280 --> 00:03:35,519
to use that title

00:03:32,640 --> 00:03:36,239
there's a bit more to it and in fact if

00:03:35,519 --> 00:03:39,200
we

00:03:36,239 --> 00:03:39,760
look in to he actually says his second

00:03:39,200 --> 00:03:42,959
remark

00:03:39,760 --> 00:03:45,599
but the first one is less interesting um

00:03:42,959 --> 00:03:46,879
it says my second remark is that our

00:03:45,599 --> 00:03:49,680
intellectual powers

00:03:46,879 --> 00:03:51,120
are rather geared to master static

00:03:49,680 --> 00:03:54,640
relations

00:03:51,120 --> 00:03:57,680
and our powers to visualize processes

00:03:54,640 --> 00:04:01,040
evolving in time are relatively

00:03:57,680 --> 00:04:02,959
poorly developed that's

00:04:01,040 --> 00:04:04,720
interesting phrasing there so obviously

00:04:02,959 --> 00:04:05,200
he's talking we're going to be leading

00:04:04,720 --> 00:04:07,120
up to

00:04:05,200 --> 00:04:09,280
how the go-to statement plays into this

00:04:07,120 --> 00:04:12,319
but carrying on

00:04:09,280 --> 00:04:14,400
for that reason we should do as wise

00:04:12,319 --> 00:04:17,600
programmers or wherever limitations

00:04:14,400 --> 00:04:20,160
our utmost to shorten the conceptual gap

00:04:17,600 --> 00:04:22,079
between the static program and the

00:04:20,160 --> 00:04:24,080
dynamic process

00:04:22,079 --> 00:04:27,280
to make the correspondence between the

00:04:24,080 --> 00:04:30,560
program spread out in text space

00:04:27,280 --> 00:04:33,680
and the process spread out in time

00:04:30,560 --> 00:04:37,360
as trivial as possible

00:04:33,680 --> 00:04:39,360
so quite a profound statement there that

00:04:37,360 --> 00:04:40,720
we should be aware of our limitations

00:04:39,360 --> 00:04:43,919
and we want to

00:04:40,720 --> 00:04:46,639
shorten that conceptual gap between

00:04:43,919 --> 00:04:48,400
how our programs actually run and how

00:04:46,639 --> 00:04:50,880
they're written

00:04:48,400 --> 00:04:52,240
and he brings in this this subject of a

00:04:50,880 --> 00:04:54,880
dynamic process

00:04:52,240 --> 00:04:56,240
now let's say he's talking more about

00:04:54,880 --> 00:04:58,000
how the instruction pointer

00:04:56,240 --> 00:04:59,520
moves through your code and he starts

00:04:58,000 --> 00:05:01,039
talking about textual indexes in the

00:04:59,520 --> 00:05:02,560
next couple of paragraphs which is just

00:05:01,039 --> 00:05:04,560
just a way of saying

00:05:02,560 --> 00:05:05,680
how we can reason about lines of code in

00:05:04,560 --> 00:05:07,759
isolation

00:05:05,680 --> 00:05:09,919
and how we can take in the whole of our

00:05:07,759 --> 00:05:10,960
code by thinking about a progression

00:05:09,919 --> 00:05:13,440
through it

00:05:10,960 --> 00:05:14,240
so you can see how go-to's can screw

00:05:13,440 --> 00:05:15,840
that up

00:05:14,240 --> 00:05:18,160
in fact it does say that even just even

00:05:15,840 --> 00:05:20,560
procedures do complicate things

00:05:18,160 --> 00:05:23,600
but they can make it manageable but

00:05:20,560 --> 00:05:26,880
go-to's make it almost impossible

00:05:23,600 --> 00:05:29,199
so we're going to come back to this

00:05:26,880 --> 00:05:30,479
but i want to move on because obviously

00:05:29,199 --> 00:05:32,160
this essay was

00:05:30,479 --> 00:05:34,080
talking mostly about structured

00:05:32,160 --> 00:05:36,160
programming um

00:05:34,080 --> 00:05:38,160
you may see that as maybe a precursor to

00:05:36,160 --> 00:05:40,479
object oriented programming

00:05:38,160 --> 00:05:41,840
and certainly a lot of what went into

00:05:40,479 --> 00:05:43,199
structured programming has made it into

00:05:41,840 --> 00:05:45,600
object-oriented language

00:05:43,199 --> 00:05:46,800
languages so we haven't lost it all or

00:05:45,600 --> 00:05:49,360
have we

00:05:46,800 --> 00:05:52,080
it's a great talk by kevin henny the

00:05:49,360 --> 00:05:55,440
forgotten art of structured programming

00:05:52,080 --> 00:05:58,160
this was uh from say plus plus on c

00:05:55,440 --> 00:05:59,440
last year uh you may have actually seen

00:05:58,160 --> 00:05:59,840
this there's a good chance you have

00:05:59,440 --> 00:06:05,039
because

00:05:59,840 --> 00:06:06,240
last time i checked i had 125 000 views

00:06:05,039 --> 00:06:08,319
now if you haven't been looking at view

00:06:06,240 --> 00:06:09,440
counts on uh talks from c plus plus

00:06:08,319 --> 00:06:12,560
conferences

00:06:09,440 --> 00:06:14,240
um you uh you may be surprised that

00:06:12,560 --> 00:06:16,240
that's actually a really high number

00:06:14,240 --> 00:06:17,360
um most good ones getting like maybe the

00:06:16,240 --> 00:06:18,639
tens of thousands

00:06:17,360 --> 00:06:20,800
there's a few that really break through

00:06:18,639 --> 00:06:22,639
like some of the bianna's keynotes

00:06:20,800 --> 00:06:24,160
so for some reason this got caught up in

00:06:22,639 --> 00:06:26,800
the the upwinds of

00:06:24,160 --> 00:06:27,919
the youtube algorithm and it's it's

00:06:26,800 --> 00:06:29,039
doing pretty well that means a lot of

00:06:27,919 --> 00:06:32,000
people have seen this talk

00:06:29,039 --> 00:06:34,880
just good things it's a great talk uh in

00:06:32,000 --> 00:06:37,919
fact i have a bit of a confession here

00:06:34,880 --> 00:06:39,520
when i was preparing uh this material

00:06:37,919 --> 00:06:41,360
or when i when i was first preparing the

00:06:39,520 --> 00:06:43,520
abstract i thought

00:06:41,360 --> 00:06:45,039
i know there's one or two kevin henry

00:06:43,520 --> 00:06:47,199
talks that i want to refer to because

00:06:45,039 --> 00:06:49,280
he's talking about similar stuff

00:06:47,199 --> 00:06:51,840
but when i was actually researching uh

00:06:49,280 --> 00:06:53,280
doing the background research

00:06:51,840 --> 00:06:55,919
every where i went i just got the

00:06:53,280 --> 00:06:57,440
feeling that kevin had got there first

00:06:55,919 --> 00:06:59,440
with another great talk

00:06:57,440 --> 00:07:00,479
and it's a bit like that south park

00:06:59,440 --> 00:07:02,000
episode

00:07:00,479 --> 00:07:04,160
where everything they did they realized

00:07:02,000 --> 00:07:06,639
that the simpsons had already done it so

00:07:04,160 --> 00:07:08,080
maybe we could say kevin henny already

00:07:06,639 --> 00:07:10,720
did it

00:07:08,080 --> 00:07:11,919
but this is actually good news because

00:07:10,720 --> 00:07:13,039
we're going to be talking about some

00:07:11,919 --> 00:07:16,160
quite deep

00:07:13,039 --> 00:07:19,120
broad topics um but obviously

00:07:16,160 --> 00:07:20,720
in a 60 minute talk which i have 50 to

00:07:19,120 --> 00:07:22,160
55 minutes left

00:07:20,720 --> 00:07:23,840
i'm only going to be touching on a lot

00:07:22,160 --> 00:07:24,240
of these topics lightly i'm going to

00:07:23,840 --> 00:07:27,360
weave

00:07:24,240 --> 00:07:30,560
the narrative to to get me to where uh

00:07:27,360 --> 00:07:31,919
the point that i wanted to make so as we

00:07:30,560 --> 00:07:33,599
touch on some of those things i can

00:07:31,919 --> 00:07:36,080
point you to other talks

00:07:33,599 --> 00:07:37,440
um particularly kevin's some others as

00:07:36,080 --> 00:07:38,720
well including some of my own

00:07:37,440 --> 00:07:41,599
so right in the last slide i'm going to

00:07:38,720 --> 00:07:43,280
give you a link to a page on my website

00:07:41,599 --> 00:07:44,400
with a load of extra resources that you

00:07:43,280 --> 00:07:47,599
can go and have a look at

00:07:44,400 --> 00:07:49,039
including lots of talks so if i skim a

00:07:47,599 --> 00:07:51,199
bit lightly on some of this stuff

00:07:49,039 --> 00:07:52,080
um be reassured that you can you can do

00:07:51,199 --> 00:07:55,840
some more

00:07:52,080 --> 00:07:58,319
research afterwards so okay

00:07:55,840 --> 00:07:59,360
enough of structured programming we were

00:07:58,319 --> 00:08:03,039
talking about

00:07:59,360 --> 00:08:06,800
oh what is o

00:08:03,039 --> 00:08:09,840
that's easy you say object orientation

00:08:06,800 --> 00:08:10,800
but what does that actually mean now i

00:08:09,840 --> 00:08:13,199
thought it might be

00:08:10,800 --> 00:08:14,400
quite destructive to find out what you

00:08:13,199 --> 00:08:17,599
think it means

00:08:14,400 --> 00:08:20,240
so i'm going to drop out of here again

00:08:17,599 --> 00:08:22,400
and go to the next slide i think i can

00:08:20,240 --> 00:08:24,160
do that there we go

00:08:22,400 --> 00:08:25,599
if you go back to that same url if you

00:08:24,160 --> 00:08:28,879
or if you're still there

00:08:25,599 --> 00:08:30,639
you should be able to just enter words

00:08:28,879 --> 00:08:33,200
or short phrases

00:08:30,639 --> 00:08:34,959
um that capture what you think object

00:08:33,200 --> 00:08:36,560
orientation means or

00:08:34,959 --> 00:08:38,320
things that are associated with object

00:08:36,560 --> 00:08:39,760
orientation

00:08:38,320 --> 00:08:42,080
and it should start to build a word

00:08:39,760 --> 00:08:43,519
cloud

00:08:42,080 --> 00:08:45,120
now i'm not seeing any come up yeah oh

00:08:43,519 --> 00:08:47,920
there's one polymorphism great

00:08:45,120 --> 00:08:48,560
there we go starting to get a view now

00:08:47,920 --> 00:08:50,160
you can

00:08:48,560 --> 00:08:51,440
you can enter more than one word so once

00:08:50,160 --> 00:08:52,320
you've entered one you can go back and

00:08:51,440 --> 00:08:54,399
enter another one

00:08:52,320 --> 00:08:56,640
you can even enter the same one but

00:08:54,399 --> 00:08:59,760
don't use that to cheat

00:08:56,640 --> 00:09:00,880
there we go encapsulation coming up

00:08:59,760 --> 00:09:03,200
pretty big

00:09:00,880 --> 00:09:04,320
we've got classes there inheritance all

00:09:03,200 --> 00:09:07,279
the usual suspects

00:09:04,320 --> 00:09:08,800
yeah that's that's pretty good again

00:09:07,279 --> 00:09:10,080
pretty much as i expected but it's

00:09:08,800 --> 00:09:12,800
always nice to see

00:09:10,080 --> 00:09:14,080
when it actually goes as you expected

00:09:12,800 --> 00:09:18,720
i'll give it a moment

00:09:14,080 --> 00:09:23,040
to uh settle down bugs i like that one

00:09:18,720 --> 00:09:24,640
dynamic dispatchers interesting okay

00:09:23,040 --> 00:09:26,640
if i remember we'll come back to this at

00:09:24,640 --> 00:09:28,080
the end and compare notes

00:09:26,640 --> 00:09:32,320
um let's say you can keep going i'm

00:09:28,080 --> 00:09:32,320
going to carry on with the slides

00:09:32,399 --> 00:09:36,720
so all right part of the point of this

00:09:35,680 --> 00:09:39,120
exercise was

00:09:36,720 --> 00:09:41,360
that actually we do have different ideas

00:09:39,120 --> 00:09:43,519
about what object orientation really is

00:09:41,360 --> 00:09:45,120
and if you do some reading online you'll

00:09:43,519 --> 00:09:46,959
find different definitions

00:09:45,120 --> 00:09:49,200
um including from you know some

00:09:46,959 --> 00:09:50,560
authorities they'll have different ideas

00:09:49,200 --> 00:09:52,480
but there are you know some common

00:09:50,560 --> 00:09:55,519
themes that most people agree these are

00:09:52,480 --> 00:09:57,120
the the core concepts of o.o

00:09:55,519 --> 00:09:59,120
but would it be useful to actually go

00:09:57,120 --> 00:10:02,399
back to where it all started

00:09:59,120 --> 00:10:04,720
and most people agree that

00:10:02,399 --> 00:10:05,519
the first what we would consider oh

00:10:04,720 --> 00:10:06,959
language

00:10:05,519 --> 00:10:09,600
although some concepts that existed

00:10:06,959 --> 00:10:12,000
before that was similar

00:10:09,600 --> 00:10:13,440
interesting thing about similar is that

00:10:12,000 --> 00:10:15,279
there were two similar languages and

00:10:13,440 --> 00:10:17,760
they're actually both quite different

00:10:15,279 --> 00:10:19,519
there's uh the original similar one

00:10:17,760 --> 00:10:22,720
which was originally intended to be

00:10:19,519 --> 00:10:27,360
just a um an extension or a plug-in

00:10:22,720 --> 00:10:27,360
to the algol 60 language

00:10:27,519 --> 00:10:30,560
eventually they realized that they

00:10:28,640 --> 00:10:32,079
couldn't do what they wanted to do

00:10:30,560 --> 00:10:34,240
just as an extension and they had to

00:10:32,079 --> 00:10:37,519
write their own compiler but it's still

00:10:34,240 --> 00:10:40,560
basically a superset of algol 60.

00:10:37,519 --> 00:10:42,240
and they added a number of a number of

00:10:40,560 --> 00:10:45,680
features in fact let's go on to

00:10:42,240 --> 00:10:47,680
have a look at that the main

00:10:45,680 --> 00:10:50,160
concept that they came up with was what

00:10:47,680 --> 00:10:52,000
they called a process which itself was a

00:10:50,160 --> 00:10:53,680
generalization of a couple of concepts

00:10:52,000 --> 00:10:56,640
they'd had before that

00:10:53,680 --> 00:10:57,680
and a process was really just like a

00:10:56,640 --> 00:10:59,040
function

00:10:57,680 --> 00:11:00,880
or you might think like a functional

00:10:59,040 --> 00:11:04,320
object that has just one member um

00:11:00,880 --> 00:11:05,920
one method a run method so

00:11:04,320 --> 00:11:07,360
you start the process and it starts

00:11:05,920 --> 00:11:08,800
running but you've got you can also

00:11:07,360 --> 00:11:10,959
suspend and resume it

00:11:08,800 --> 00:11:12,480
you can you call other processes you

00:11:10,959 --> 00:11:13,279
suspend yourself and you resume another

00:11:12,480 --> 00:11:15,120
process

00:11:13,279 --> 00:11:17,440
so actually you can think of these as a

00:11:15,120 --> 00:11:19,120
bit like co-routines

00:11:17,440 --> 00:11:20,959
now this is not what we normally think

00:11:19,120 --> 00:11:22,720
of when when we talk of

00:11:20,959 --> 00:11:24,880
simula being the first object-oriented

00:11:22,720 --> 00:11:26,560
language actually quite interesting this

00:11:24,880 --> 00:11:30,000
is where it actually started

00:11:26,560 --> 00:11:32,320
this idea of processes but when they

00:11:30,000 --> 00:11:33,120
came to do the next version of simula by

00:11:32,320 --> 00:11:35,440
that time

00:11:33,120 --> 00:11:37,279
this had moved out of the research phase

00:11:35,440 --> 00:11:38,560
and in fact out of the simulation

00:11:37,279 --> 00:11:40,800
space they realized they could make this

00:11:38,560 --> 00:11:42,079
much more general in application

00:11:40,800 --> 00:11:44,320
and they wanted to generalize some of

00:11:42,079 --> 00:11:47,040
these concepts even more

00:11:44,320 --> 00:11:48,000
and so that they came up with something

00:11:47,040 --> 00:11:49,600
was actually

00:11:48,000 --> 00:11:51,040
already in existence before this but

00:11:49,600 --> 00:11:52,480
they brought this into the language uh

00:11:51,040 --> 00:11:54,079
really for the first time in a

00:11:52,480 --> 00:11:57,120
mainstream language

00:11:54,079 --> 00:11:58,959
and that was the class

00:11:57,120 --> 00:12:01,839
and classes could inherit from other

00:11:58,959 --> 00:12:04,399
classes uh called subclassing

00:12:01,839 --> 00:12:06,399
or sounding familiar now and a class can

00:12:04,399 --> 00:12:07,680
have its own variables member variables

00:12:06,399 --> 00:12:10,240
you can have procedures

00:12:07,680 --> 00:12:11,440
we now would call methods and those

00:12:10,240 --> 00:12:14,639
procedures may be

00:12:11,440 --> 00:12:17,279
virtual so yeah this is also

00:12:14,639 --> 00:12:18,480
much more familiar and then you could

00:12:17,279 --> 00:12:20,160
have um

00:12:18,480 --> 00:12:22,720
say certain types of classes one special

00:12:20,160 --> 00:12:25,920
type of class was the process class

00:12:22,720 --> 00:12:28,320
and this is how they actually got

00:12:25,920 --> 00:12:30,000
the old similar one ideas into similar

00:12:28,320 --> 00:12:31,680
67 but they sort of brush them under the

00:12:30,000 --> 00:12:33,120
carpet a bit now the new way forward

00:12:31,680 --> 00:12:34,560
with these classes

00:12:33,120 --> 00:12:36,480
and in a way it's a little bit of a

00:12:34,560 --> 00:12:37,360
shame that they they de-emphasize that

00:12:36,480 --> 00:12:38,959
because

00:12:37,360 --> 00:12:41,600
some of these ideas have come back to

00:12:38,959 --> 00:12:43,200
the forefront more recently but actually

00:12:41,600 --> 00:12:45,600
we had them right there at the starting

00:12:43,200 --> 00:12:48,480
in similar one

00:12:45,600 --> 00:12:49,200
so we had virtuals we had inheritance so

00:12:48,480 --> 00:12:52,000
we had

00:12:49,200 --> 00:12:53,600
polymorphism what it didn't have was

00:12:52,000 --> 00:12:55,839
encapsulation

00:12:53,600 --> 00:12:57,040
everything was basically public here's

00:12:55,839 --> 00:13:00,800
an example

00:12:57,040 --> 00:13:02,399
um from uh there's a link at the bottom

00:13:00,800 --> 00:13:04,639
two bit history.org this will be

00:13:02,399 --> 00:13:06,079
in the references at the end uh so i

00:13:04,639 --> 00:13:07,440
didn't come up with this example i've

00:13:06,079 --> 00:13:10,560
never written a line of similar

00:13:07,440 --> 00:13:12,800
i should confess but here we have the

00:13:10,560 --> 00:13:13,920
reasonably familiar example with a dog

00:13:12,800 --> 00:13:17,279
class

00:13:13,920 --> 00:13:18,880
uh has a bark procedure it's a little

00:13:17,279 --> 00:13:19,760
bit odd how you have to specify the

00:13:18,880 --> 00:13:21,600
virtuals

00:13:19,760 --> 00:13:23,200
that the comments suggest this may be

00:13:21,600 --> 00:13:24,160
something to do with gcc's

00:13:23,200 --> 00:13:27,279
implementation

00:13:24,160 --> 00:13:29,360
gcc still has a similar

00:13:27,279 --> 00:13:30,720
compiler front end you know it compiles

00:13:29,360 --> 00:13:33,200
down to c

00:13:30,720 --> 00:13:34,399
so you can still play with this and then

00:13:33,200 --> 00:13:38,000
if you extend that

00:13:34,399 --> 00:13:39,920
with the chihuahua class otc put the

00:13:38,000 --> 00:13:41,760
the parent class before the word class

00:13:39,920 --> 00:13:45,120
so you have a dog class

00:13:41,760 --> 00:13:47,120
something nice about that and

00:13:45,120 --> 00:13:48,560
then you you can implement a new version

00:13:47,120 --> 00:13:49,360
of the bach procedure which does

00:13:48,560 --> 00:13:52,480
something different

00:13:49,360 --> 00:13:55,519
so fairly familiar the way that this

00:13:52,480 --> 00:13:56,880
polymorphism works very similar other

00:13:55,519 --> 00:13:58,079
than the syntax of course but even

00:13:56,880 --> 00:14:01,120
that's not too far off

00:13:58,079 --> 00:14:03,040
c plus plus and other mainstream o

00:14:01,120 --> 00:14:06,480
languages that we know

00:14:03,040 --> 00:14:08,160
so once we moved to similar 67 things

00:14:06,480 --> 00:14:11,199
started to get very

00:14:08,160 --> 00:14:12,000
familiar but obviously things didn't

00:14:11,199 --> 00:14:14,959
stop there

00:14:12,000 --> 00:14:16,000
there's a bit of a family history so

00:14:14,959 --> 00:14:19,440
similar itself

00:14:16,000 --> 00:14:20,720
belongs to the algal family of languages

00:14:19,440 --> 00:14:22,079
we already said that it started off as

00:14:20,720 --> 00:14:25,519
an extension to alcohol

00:14:22,079 --> 00:14:27,839
so very heavily for the syntax of algol

00:14:25,519 --> 00:14:29,519
it's basically a superset there's a

00:14:27,839 --> 00:14:32,240
whole other branch

00:14:29,519 --> 00:14:33,279
of the alcohol line that led to the c

00:14:32,240 --> 00:14:36,399
language

00:14:33,279 --> 00:14:37,199
cpl or bcplb languages you don't really

00:14:36,399 --> 00:14:39,279
hear

00:14:37,199 --> 00:14:41,040
anything of these days except as

00:14:39,279 --> 00:14:42,880
precursors to c

00:14:41,040 --> 00:14:45,600
they didn't really have much impact

00:14:42,880 --> 00:14:48,160
beyond that not more iterative

00:14:45,600 --> 00:14:49,760
um and obviously they didn't go in the

00:14:48,160 --> 00:14:52,000
direction of oh

00:14:49,760 --> 00:14:54,560
uh it is possible to do io in those

00:14:52,000 --> 00:14:56,320
languages but you have to work hard

00:14:54,560 --> 00:14:57,760
um the reason i bring that up is because

00:14:56,320 --> 00:15:01,279
of course we then have a common

00:14:57,760 --> 00:15:04,639
heritage in c plus plus so c plus plus

00:15:01,279 --> 00:15:06,560
then heavily of course on c but it got

00:15:04,639 --> 00:15:09,279
most of its o

00:15:06,560 --> 00:15:12,000
ideas from similar as we just saw look

00:15:09,279 --> 00:15:15,600
look very familiar in that sense

00:15:12,000 --> 00:15:18,079
so that sort of algol loop uh reconvened

00:15:15,600 --> 00:15:20,880
in a sort of a virtual inheritance um

00:15:18,079 --> 00:15:23,360
diamond of death at the bottom

00:15:20,880 --> 00:15:24,320
but that wasn't the only direction that

00:15:23,360 --> 00:15:27,680
i went in

00:15:24,320 --> 00:15:28,320
from simula so a couple of other

00:15:27,680 --> 00:15:30,000
directions

00:15:28,320 --> 00:15:31,839
very different directions were small

00:15:30,000 --> 00:15:33,360
talk and eiffel

00:15:31,839 --> 00:15:35,120
and both of them could be considered

00:15:33,360 --> 00:15:38,240
much purer

00:15:35,120 --> 00:15:40,399
implementations of the oo idea

00:15:38,240 --> 00:15:41,440
so i'm instructed to look at what they

00:15:40,399 --> 00:15:43,279
do differently

00:15:41,440 --> 00:15:44,720
and whether that's better or worse or

00:15:43,279 --> 00:15:46,000
what the trade-offs are

00:15:44,720 --> 00:15:49,120
the small talk is a particularly

00:15:46,000 --> 00:15:51,519
interesting branch because

00:15:49,120 --> 00:15:52,720
around the time that c plus was just

00:15:51,519 --> 00:15:55,920
getting going as a

00:15:52,720 --> 00:15:56,959
an object-oriented extension to c a lot

00:15:55,920 --> 00:15:57,360
of people were thinking how could we

00:15:56,959 --> 00:15:58,959
make c

00:15:57,360 --> 00:16:00,399
object oriented that was the buzzword at

00:15:58,959 --> 00:16:03,279
the time

00:16:00,399 --> 00:16:04,959
and one other application was to

00:16:03,279 --> 00:16:05,839
basically take small talk and graph it

00:16:04,959 --> 00:16:08,639
on top of c

00:16:05,839 --> 00:16:09,199
and call it objective c and when you

00:16:08,639 --> 00:16:10,399
think of

00:16:09,199 --> 00:16:12,639
that there are different directions that

00:16:10,399 --> 00:16:14,560
those languages came in at that point

00:16:12,639 --> 00:16:15,839
it's actually remarkable just how

00:16:14,560 --> 00:16:18,399
cleanly objective c

00:16:15,839 --> 00:16:19,920
actually works uh you you can definitely

00:16:18,399 --> 00:16:21,199
see that the stratas are the language

00:16:19,920 --> 00:16:23,519
there they're very different levels

00:16:21,199 --> 00:16:24,800
much more so than in c plus plus but

00:16:23,519 --> 00:16:26,560
they actually complement

00:16:24,800 --> 00:16:28,079
complements each other quite nicely so

00:16:26,560 --> 00:16:28,800
some nice things about objective c it's

00:16:28,079 --> 00:16:30,959
a shame

00:16:28,800 --> 00:16:32,160
in a way that's been pushed aside in the

00:16:30,959 --> 00:16:35,120
favor of swift

00:16:32,160 --> 00:16:36,720
these days that's another story but i

00:16:35,120 --> 00:16:39,920
think we lost something there

00:16:36,720 --> 00:16:41,360
we certainly lost um a uh an enduring

00:16:39,920 --> 00:16:43,759
part of the the small talk

00:16:41,360 --> 00:16:44,800
legacy uh but we'll come back to that

00:16:43,759 --> 00:16:47,279
anyway

00:16:44,800 --> 00:16:48,320
eiffel had some even stronger ideas

00:16:47,279 --> 00:16:51,120
about oh

00:16:48,320 --> 00:16:52,480
as well as another a number of other

00:16:51,120 --> 00:16:54,000
things that we're starting to come

00:16:52,480 --> 00:16:55,839
around to thinking actually

00:16:54,000 --> 00:16:57,040
they're quite important like contracts

00:16:55,839 --> 00:16:59,759
for example

00:16:57,040 --> 00:17:00,160
um we're not going to talk quite so much

00:16:59,759 --> 00:17:03,040
about

00:17:00,160 --> 00:17:04,079
rifle obviously this is a very

00:17:03,040 --> 00:17:06,880
simplified family

00:17:04,079 --> 00:17:08,000
tree there are many other influences and

00:17:06,880 --> 00:17:10,160
influences

00:17:08,000 --> 00:17:12,400
different directions but i think in

00:17:10,160 --> 00:17:14,880
terms of the oo story leading to c

00:17:12,400 --> 00:17:15,439
plus plus these are the main players

00:17:14,880 --> 00:17:17,839
even

00:17:15,439 --> 00:17:19,919
objective c had an influence in later

00:17:17,839 --> 00:17:21,839
times

00:17:19,919 --> 00:17:23,280
so what i want to do is just take these

00:17:21,839 --> 00:17:24,959
languages and i'm going to

00:17:23,280 --> 00:17:26,319
lump small talk and objective c together

00:17:24,959 --> 00:17:28,799
for our purposes here because in terms

00:17:26,319 --> 00:17:31,039
of lo they're basically the same

00:17:28,799 --> 00:17:32,880
and just compare the different oo

00:17:31,039 --> 00:17:36,000
features that they had

00:17:32,880 --> 00:17:36,559
or have so the first three are pretty

00:17:36,000 --> 00:17:38,640
common

00:17:36,559 --> 00:17:40,160
and pretty basic fundamental they all

00:17:38,640 --> 00:17:42,480
have classes

00:17:40,160 --> 00:17:43,919
uh usually i think always actually with

00:17:42,480 --> 00:17:45,520
the class keyword

00:17:43,919 --> 00:17:47,520
they all support inheritance in some

00:17:45,520 --> 00:17:48,880
form and they'll support some form of

00:17:47,520 --> 00:17:52,480
polymorphism

00:17:48,880 --> 00:17:54,160
now say some form the differences

00:17:52,480 --> 00:17:56,400
in the the details are actually quite

00:17:54,160 --> 00:17:59,440
interesting we'll talk more about that

00:17:56,400 --> 00:18:02,480
inheritance the main difference is uh

00:17:59,440 --> 00:18:03,039
similar and the small talk line are

00:18:02,480 --> 00:18:06,320
purely

00:18:03,039 --> 00:18:07,520
single inheritance um of both

00:18:06,320 --> 00:18:10,000
implementation

00:18:07,520 --> 00:18:11,520
and interface actually objective c could

00:18:10,000 --> 00:18:14,880
have multiple interfaces

00:18:11,520 --> 00:18:17,919
called protocols whereas

00:18:14,880 --> 00:18:18,880
i4 and c plus plus support multiple

00:18:17,919 --> 00:18:19,919
inheritance

00:18:18,880 --> 00:18:21,360
and it could be argued that actually

00:18:19,919 --> 00:18:22,480
eiffel does a much better job of it than

00:18:21,360 --> 00:18:24,480
c plus plus

00:18:22,480 --> 00:18:26,480
i've considered many more of the edge

00:18:24,480 --> 00:18:28,640
cases at the troubles in c plus plus and

00:18:26,480 --> 00:18:30,799
done a better job of making those

00:18:28,640 --> 00:18:33,679
manageable

00:18:30,799 --> 00:18:35,600
but then we start to get some more

00:18:33,679 --> 00:18:37,760
breakdowns so

00:18:35,600 --> 00:18:39,760
um as we said similar didn't really

00:18:37,760 --> 00:18:41,280
support encapsulation

00:18:39,760 --> 00:18:43,039
we didn't support it at all in the way

00:18:41,280 --> 00:18:44,480
that we know there's no private keyword

00:18:43,039 --> 00:18:46,400
no protected keyword everything is

00:18:44,480 --> 00:18:48,880
basically public

00:18:46,400 --> 00:18:50,160
there was actually a very limited form

00:18:48,880 --> 00:18:53,760
of encapsulation

00:18:50,160 --> 00:18:55,440
remember that we said that similar one

00:18:53,760 --> 00:18:57,440
had this idea of a process which is like

00:18:55,440 --> 00:18:58,400
a co-routine so curating could have its

00:18:57,440 --> 00:19:01,360
own state

00:18:58,400 --> 00:19:02,640
which would not be visible outside of

00:19:01,360 --> 00:19:04,960
the code reading

00:19:02,640 --> 00:19:06,240
or the process now whereas with a normal

00:19:04,960 --> 00:19:07,840
function you wouldn't think anything

00:19:06,240 --> 00:19:11,280
more of that because

00:19:07,840 --> 00:19:13,840
these processes live on beyond

00:19:11,280 --> 00:19:15,200
invocations of other processes you know

00:19:13,840 --> 00:19:17,039
they run alongside them

00:19:15,200 --> 00:19:18,559
in a way the fact that they have their

00:19:17,039 --> 00:19:19,919
own state which is completely separate

00:19:18,559 --> 00:19:22,559
and encapsulated

00:19:19,919 --> 00:19:23,120
it's actually quite an interesting idea

00:19:22,559 --> 00:19:24,559
so

00:19:23,120 --> 00:19:26,080
i think we're going to come back to that

00:19:24,559 --> 00:19:28,320
as well but in terms of the

00:19:26,080 --> 00:19:30,480
encapsulation that we know today

00:19:28,320 --> 00:19:31,840
that didn't exist in similar that came

00:19:30,480 --> 00:19:35,520
about with uh

00:19:31,840 --> 00:19:35,520
smalltalk and eiffel

00:19:36,480 --> 00:19:40,799
and then we have this idea that well

00:19:39,440 --> 00:19:42,240
we're going to be object-oriented then

00:19:40,799 --> 00:19:43,679
everything must be an object including

00:19:42,240 --> 00:19:45,760
classes

00:19:43,679 --> 00:19:46,960
small talk went this direction either

00:19:45,760 --> 00:19:49,600
went this direction

00:19:46,960 --> 00:19:51,440
and many oo purists think that this is

00:19:49,600 --> 00:19:53,280
maybe the central idea

00:19:51,440 --> 00:19:55,120
in object orientation that everything is

00:19:53,280 --> 00:19:57,280
an object

00:19:55,120 --> 00:19:59,200
and certainly other mainstream languages

00:19:57,280 --> 00:20:00,880
i mean we're only considering up to c

00:19:59,200 --> 00:20:02,559
plus in this particular story but

00:20:00,880 --> 00:20:04,080
thinking of languages like java and c

00:20:02,559 --> 00:20:05,760
sharp

00:20:04,080 --> 00:20:07,919
they don't have classes as objects

00:20:05,760 --> 00:20:10,960
unless you consider reflection

00:20:07,919 --> 00:20:13,200
but everything being a class

00:20:10,960 --> 00:20:14,400
is still there so you can't just have

00:20:13,200 --> 00:20:15,679
three functions yet they have to be

00:20:14,400 --> 00:20:17,280
wrapped in some class even if they

00:20:15,679 --> 00:20:19,280
become static methods

00:20:17,280 --> 00:20:21,760
and we may find that gets in the way but

00:20:19,280 --> 00:20:22,720
it comes back to this idea that

00:20:21,760 --> 00:20:24,000
if you're really going to be

00:20:22,720 --> 00:20:25,039
object-oriented then everything should

00:20:24,000 --> 00:20:27,919
be an object

00:20:25,039 --> 00:20:28,240
even classes and that's certainly true

00:20:27,919 --> 00:20:30,799
in

00:20:28,240 --> 00:20:31,760
small talk ifo and even objective c

00:20:30,799 --> 00:20:34,559
that's not true in c

00:20:31,760 --> 00:20:36,159
plus plus and it wasn't really true in

00:20:34,559 --> 00:20:39,600
simula either

00:20:36,159 --> 00:20:41,120
so there's another fault line

00:20:39,600 --> 00:20:43,760
but i think the particularly interesting

00:20:41,120 --> 00:20:48,240
one and it sort of follows on from that

00:20:43,760 --> 00:20:52,400
is the way that small talk and eiffel

00:20:48,240 --> 00:20:54,960
support message passing and

00:20:52,400 --> 00:20:56,240
might ask what is message passing and

00:20:54,960 --> 00:20:57,760
maybe you know what message basking is

00:20:56,240 --> 00:20:59,760
maybe you have an idea maybe you're not

00:20:57,760 --> 00:21:01,679
quite sure how that fits into oo

00:20:59,760 --> 00:21:03,360
if you think it's a high level concept

00:21:01,679 --> 00:21:04,159
um so be instructive to have a look at

00:21:03,360 --> 00:21:07,520
that

00:21:04,159 --> 00:21:10,799
so let's consider

00:21:07,520 --> 00:21:14,640
virtual dispatch as we have it in

00:21:10,799 --> 00:21:16,480
c plus plus today so you have a

00:21:14,640 --> 00:21:17,840
some code that wants to call a method on

00:21:16,480 --> 00:21:20,240
a class which

00:21:17,840 --> 00:21:21,120
happens to be a virtual method so you

00:21:20,240 --> 00:21:22,880
have your

00:21:21,120 --> 00:21:24,640
object implementing the class which has

00:21:22,880 --> 00:21:28,240
a number of methods

00:21:24,640 --> 00:21:30,240
you want to call method1 now to do that

00:21:28,240 --> 00:21:32,799
first of all of course that under the

00:21:30,240 --> 00:21:34,400
hood will pass the hidden this pointer

00:21:32,799 --> 00:21:36,559
it's it's as if you had passed it

00:21:34,400 --> 00:21:40,559
manually it's just been written for you

00:21:36,559 --> 00:21:42,640
and hidden and there's even proposals

00:21:40,559 --> 00:21:44,400
going through at the moment to in some

00:21:42,640 --> 00:21:45,360
cases make that visible again because it

00:21:44,400 --> 00:21:48,080
turns out that

00:21:45,360 --> 00:21:49,840
hiding actually causes some problems but

00:21:48,080 --> 00:21:51,840
this is what we know today

00:21:49,840 --> 00:21:54,080
and then there's also this this v table

00:21:51,840 --> 00:21:56,960
that we don't see at all

00:21:54,080 --> 00:21:58,960
and that also has to be considered when

00:21:56,960 --> 00:22:01,440
looking up what what the method is

00:21:58,960 --> 00:22:03,360
so there's a few levels of indirection

00:22:01,440 --> 00:22:07,280
we have to go through to invoke a

00:22:03,360 --> 00:22:09,360
virtual method um free by most accounts

00:22:07,280 --> 00:22:12,000
so there's a bit of overhead there and

00:22:09,360 --> 00:22:15,600
this is one of the reasons that

00:22:12,000 --> 00:22:19,200
certainly the virtual dispatch as

00:22:15,600 --> 00:22:22,720
well as any form of polymorphism are

00:22:19,200 --> 00:22:24,720
often um not

00:22:22,720 --> 00:22:26,799
moved away from in a lot of modern c

00:22:24,720 --> 00:22:28,960
plus code bases by default

00:22:26,799 --> 00:22:30,480
uh obviously they still exist in large

00:22:28,960 --> 00:22:32,240
numbers but

00:22:30,480 --> 00:22:33,919
uh the sort of the leading edge of

00:22:32,240 --> 00:22:35,440
thinking in c plus plus is moving away

00:22:33,919 --> 00:22:37,360
from that that's part of what this talk

00:22:35,440 --> 00:22:40,720
is about

00:22:37,360 --> 00:22:43,039
whereas in a message passing system

00:22:40,720 --> 00:22:44,559
like a small talker objective c i'm less

00:22:43,039 --> 00:22:46,960
familiar with how it works in iphone so

00:22:44,559 --> 00:22:50,080
i'm not going to try to illustrate it

00:22:46,960 --> 00:22:50,720
um you say i want to pass the the method

00:22:50,080 --> 00:22:54,080
one

00:22:50,720 --> 00:22:55,520
message to the object so that does

00:22:54,080 --> 00:22:57,280
literally that it passes it straight to

00:22:55,520 --> 00:23:00,559
the object

00:22:57,280 --> 00:23:03,360
uh the object then has an opportunity

00:23:00,559 --> 00:23:04,000
to do whatever it wants with it but the

00:23:03,360 --> 00:23:07,200
default

00:23:04,000 --> 00:23:08,480
thing it does is to then call it one of

00:23:07,200 --> 00:23:11,039
its methods

00:23:08,480 --> 00:23:12,320
and there's usually default mapping so

00:23:11,039 --> 00:23:14,480
the end result

00:23:12,320 --> 00:23:17,120
is very similar to what we'd expect with

00:23:14,480 --> 00:23:20,400
virtual dispatch

00:23:17,120 --> 00:23:21,679
and again at that point there is a self

00:23:20,400 --> 00:23:23,520
parameter but that's passed by the

00:23:21,679 --> 00:23:26,240
object to the method

00:23:23,520 --> 00:23:26,640
rather than by the cooler then there's

00:23:26,240 --> 00:23:29,120
no v

00:23:26,640 --> 00:23:31,039
table because this is effectively

00:23:29,120 --> 00:23:33,280
dynamic binding

00:23:31,039 --> 00:23:34,799
and it's late binding which actually

00:23:33,280 --> 00:23:36,559
gives you a lot more flexibility because

00:23:34,799 --> 00:23:38,799
the object gets to look in

00:23:36,559 --> 00:23:41,039
as to what happens before calling a

00:23:38,799 --> 00:23:42,960
method it doesn't have to call a method

00:23:41,039 --> 00:23:44,640
it could call a different method or you

00:23:42,960 --> 00:23:46,080
could replace which method it's meant to

00:23:44,640 --> 00:23:47,440
call

00:23:46,080 --> 00:23:50,000
lots of things you can do lots of

00:23:47,440 --> 00:23:52,640
possibilities not all of them good

00:23:50,000 --> 00:23:53,120
but many of them very useful so there

00:23:52,640 --> 00:23:56,240
must

00:23:53,120 --> 00:23:56,880
be an overhead to this over the virtual

00:23:56,240 --> 00:23:58,960
dispatch

00:23:56,880 --> 00:24:00,240
approach which must be why c plus plus

00:23:58,960 --> 00:24:02,320
does it a different way

00:24:00,240 --> 00:24:04,159
and it's true there is an overhead you

00:24:02,320 --> 00:24:07,279
always pay the cost of this look up

00:24:04,159 --> 00:24:08,880
every time which on the surface is like

00:24:07,279 --> 00:24:10,000
a string look up in practice it's a bit

00:24:08,880 --> 00:24:11,919
more optimized than that

00:24:10,000 --> 00:24:14,080
in fact over the years this whole

00:24:11,919 --> 00:24:16,799
process at least in objective c

00:24:14,080 --> 00:24:18,640
has been so heavily optimized that at

00:24:16,799 --> 00:24:20,799
least last time i looked at any

00:24:18,640 --> 00:24:21,840
uh comparison uh they were claiming that

00:24:20,799 --> 00:24:23,919
it was a

00:24:21,840 --> 00:24:25,919
about the same overhead as virtual

00:24:23,919 --> 00:24:28,240
dispatch in c plus plus

00:24:25,919 --> 00:24:30,240
now these things change with cpu

00:24:28,240 --> 00:24:30,880
architectures compiler optimizations and

00:24:30,240 --> 00:24:32,000
things and

00:24:30,880 --> 00:24:34,559
probably doesn't consider the

00:24:32,000 --> 00:24:35,840
virtualization and that sort of thing um

00:24:34,559 --> 00:24:38,799
so i'm not going to claim that's always

00:24:35,840 --> 00:24:41,039
the case if anything it's gonna

00:24:38,799 --> 00:24:41,919
um steer slightly more in the in the

00:24:41,039 --> 00:24:44,880
direction of

00:24:41,919 --> 00:24:46,880
more overhead but it's about the same

00:24:44,880 --> 00:24:50,400
and that's actually quite interesting

00:24:46,880 --> 00:24:52,320
that maybe we are

00:24:50,400 --> 00:24:53,760
uh paying for many of the the penalties

00:24:52,320 --> 00:24:55,120
of using virtual dispatch should not be

00:24:53,760 --> 00:24:57,200
getting the benefit

00:24:55,120 --> 00:24:58,400
anyway let's stack up some of these

00:24:57,200 --> 00:25:01,360
points so

00:24:58,400 --> 00:25:02,640
as we said message passing is a form of

00:25:01,360 --> 00:25:04,960
dynamic binding

00:25:02,640 --> 00:25:06,159
um very late binding so that means we

00:25:04,960 --> 00:25:08,400
have a chance to do

00:25:06,159 --> 00:25:09,760
well method swizzling is um certainly

00:25:08,400 --> 00:25:12,080
what they call it an objective c i don't

00:25:09,760 --> 00:25:14,960
know if that's a more general term

00:25:12,080 --> 00:25:16,240
where you can you can say well normally

00:25:14,960 --> 00:25:17,520
when you call method one it will call

00:25:16,240 --> 00:25:18,880
this but this time i want you to call

00:25:17,520 --> 00:25:20,880
this

00:25:18,880 --> 00:25:22,720
and that lets you actually change what

00:25:20,880 --> 00:25:24,159
uh objects can call

00:25:22,720 --> 00:25:26,400
javascript is famous for being able to

00:25:24,159 --> 00:25:29,120
do this as well um monkey patching i

00:25:26,400 --> 00:25:30,960
think they call it there

00:25:29,120 --> 00:25:32,240
you can also run time delegation

00:25:30,960 --> 00:25:34,640
patterns

00:25:32,240 --> 00:25:36,159
that means you can actually hook in

00:25:34,640 --> 00:25:37,600
different behaviors

00:25:36,159 --> 00:25:39,600
at runtime depending on runtime

00:25:37,600 --> 00:25:41,279
conditions and a great example again

00:25:39,600 --> 00:25:44,159
coming from the objective-c world

00:25:41,279 --> 00:25:45,760
when you construct a string object

00:25:44,159 --> 00:25:47,120
depending on properties of that string

00:25:45,760 --> 00:25:48,880
such as its length

00:25:47,120 --> 00:25:50,480
whether it contains unicode characters

00:25:48,880 --> 00:25:51,679
or whatever else that it can examine in

00:25:50,480 --> 00:25:53,600
its constructor

00:25:51,679 --> 00:25:56,240
it will then select a different

00:25:53,600 --> 00:25:59,520
implementation to actually

00:25:56,240 --> 00:26:01,440
implement that string at runtime

00:25:59,520 --> 00:26:03,760
and just hook it in with no additional

00:26:01,440 --> 00:26:05,840
overhead once that

00:26:03,760 --> 00:26:07,120
hooking up has been done that's actually

00:26:05,840 --> 00:26:09,120
quite powerful when you think about it

00:26:07,120 --> 00:26:10,480
that way

00:26:09,120 --> 00:26:11,600
because you can change these methods of

00:26:10,480 --> 00:26:13,200
runtime it makes these things really

00:26:11,600 --> 00:26:15,919
easy to mock

00:26:13,200 --> 00:26:17,360
you just say well you know when you call

00:26:15,919 --> 00:26:18,720
me on this method i want this to happen

00:26:17,360 --> 00:26:21,919
that's exactly what you can do

00:26:18,720 --> 00:26:23,360
with message passing with virtual

00:26:21,919 --> 00:26:26,159
dispatch though there are

00:26:23,360 --> 00:26:26,720
there are some advantages it may be more

00:26:26,159 --> 00:26:28,400
efficient

00:26:26,720 --> 00:26:30,320
as i say there are some caveats here may

00:26:28,400 --> 00:26:32,080
not actually be that much more efficient

00:26:30,320 --> 00:26:34,080
and it does depend on a number of

00:26:32,080 --> 00:26:36,000
factors um it can

00:26:34,080 --> 00:26:38,480
also give you stronger type japanese

00:26:36,000 --> 00:26:41,039
checking which may or may not may or may

00:26:38,480 --> 00:26:44,400
not be a benefit

00:26:41,039 --> 00:26:46,799
um benefits basically end there really

00:26:44,400 --> 00:26:48,799
so actually the scoring is not looking

00:26:46,799 --> 00:26:51,679
that good

00:26:48,799 --> 00:26:53,360
virtual dispatch also doesn't require

00:26:51,679 --> 00:26:56,240
but usually implies

00:26:53,360 --> 00:26:58,400
that your objects be heap allocated and

00:26:56,240 --> 00:27:01,520
this is perhaps the the biggest

00:26:58,400 --> 00:27:03,600
source of um

00:27:01,520 --> 00:27:05,520
dismay i suppose that simples plus

00:27:03,600 --> 00:27:07,200
programs will have when considering

00:27:05,520 --> 00:27:09,200
using virtual dispatch to implement

00:27:07,200 --> 00:27:10,720
polymorphism

00:27:09,200 --> 00:27:12,480
having these heap allocated objects and

00:27:10,720 --> 00:27:15,840
then have to be memory managed and

00:27:12,480 --> 00:27:17,679
the cost of the heap allocation so

00:27:15,840 --> 00:27:19,600
there are ways to to mitigate that of

00:27:17,679 --> 00:27:22,080
course but by default that's generally

00:27:19,600 --> 00:27:25,440
what it implies

00:27:22,080 --> 00:27:27,440
now there are other ways to implement

00:27:25,440 --> 00:27:29,919
polymorphism as well as what is message

00:27:27,440 --> 00:27:31,919
fasting virtual dispatch

00:27:29,919 --> 00:27:33,520
type eurasia is a particularly popular

00:27:31,919 --> 00:27:35,120
one right now

00:27:33,520 --> 00:27:36,640
which may or may not be implemented in

00:27:35,120 --> 00:27:39,440
terms of virtual dispatch

00:27:36,640 --> 00:27:40,880
it doesn't have to be um so i put an

00:27:39,440 --> 00:27:41,279
example here of the dyno library there's

00:27:40,880 --> 00:27:44,320
also

00:27:41,279 --> 00:27:47,039
dynamics um eduardo madrid

00:27:44,320 --> 00:27:47,760
has something as well including his only

00:27:47,039 --> 00:27:49,760
callable

00:27:47,760 --> 00:27:51,600
type there's a lot of interesting work

00:27:49,760 --> 00:27:54,960
going on on the library side and c

00:27:51,600 --> 00:27:58,159
plus plus around type eurasia right now

00:27:54,960 --> 00:28:01,039
in other languages um rust traits

00:27:58,159 --> 00:28:02,399
are a similar concept as well as swift

00:28:01,039 --> 00:28:04,399
protocols

00:28:02,399 --> 00:28:06,159
uh which are a bit deceptive because on

00:28:04,399 --> 00:28:07,840
the surface they just look like

00:28:06,159 --> 00:28:10,000
implementation inheritance and virtual

00:28:07,840 --> 00:28:11,600
dispatch but actually you can do

00:28:10,000 --> 00:28:13,120
all the same sorts of things that you

00:28:11,600 --> 00:28:15,120
can do with type erasure

00:28:13,120 --> 00:28:16,880
but i'm not quite sure how they've been

00:28:15,120 --> 00:28:19,200
implemented behind the scenes but

00:28:16,880 --> 00:28:21,039
they certainly have the um the desirable

00:28:19,200 --> 00:28:23,760
properties

00:28:21,039 --> 00:28:25,520
so what is type eurasia well we could do

00:28:23,760 --> 00:28:27,840
a whole talk on type eurasia

00:28:25,520 --> 00:28:30,240
um so i'm not going to do it justice but

00:28:27,840 --> 00:28:31,760
they will say it's just a way of having

00:28:30,240 --> 00:28:34,480
a value type

00:28:31,760 --> 00:28:35,039
where the actual implementing type um

00:28:34,480 --> 00:28:37,919
can

00:28:35,039 --> 00:28:38,880
vary dynamically and then the forwarding

00:28:37,919 --> 00:28:41,840
mechanism

00:28:38,880 --> 00:28:42,720
for any cause you make on it is handled

00:28:41,840 --> 00:28:44,880
um

00:28:42,720 --> 00:28:46,399
much more directly more like that

00:28:44,880 --> 00:28:47,760
message passing hookup

00:28:46,399 --> 00:28:49,440
that we talked about before there's

00:28:47,760 --> 00:28:50,480
different ways to do that so i'm not

00:28:49,440 --> 00:28:52,960
going to do it justice

00:28:50,480 --> 00:28:54,320
uh giving that coverage now so it tends

00:28:52,960 --> 00:28:57,120
to be

00:28:54,320 --> 00:28:58,799
non-intrusive whereas with virtual

00:28:57,120 --> 00:29:00,240
dispatch you have to implement virtual

00:28:58,799 --> 00:29:02,159
methods and then implement those virtual

00:29:00,240 --> 00:29:04,640
methods and you have to say what your

00:29:02,159 --> 00:29:05,600
super class is and all those things

00:29:04,640 --> 00:29:09,279
which just reek

00:29:05,600 --> 00:29:11,120
of um

00:29:09,279 --> 00:29:12,720
virtual inherit virtual methods and

00:29:11,120 --> 00:29:14,720
inheritance

00:29:12,720 --> 00:29:17,200
we don't need to have any of that we

00:29:14,720 --> 00:29:18,240
type erasure

00:29:17,200 --> 00:29:20,480
you generally get much higher

00:29:18,240 --> 00:29:21,440
performance as a result as well partly

00:29:20,480 --> 00:29:22,240
because you don't need the heat

00:29:21,440 --> 00:29:24,240
allocation

00:29:22,240 --> 00:29:25,520
that can be a big part but also because

00:29:24,240 --> 00:29:26,640
you remove some of those levels of

00:29:25,520 --> 00:29:29,919
indirection

00:29:26,640 --> 00:29:31,760
in um dereferencing

00:29:29,919 --> 00:29:34,320
pointers and things along the the

00:29:31,760 --> 00:29:35,679
virtual dispatch room

00:29:34,320 --> 00:29:37,039
and there may be more optimization

00:29:35,679 --> 00:29:39,279
opportunities as a result of that

00:29:37,039 --> 00:29:42,559
because the compiler is much closer to

00:29:39,279 --> 00:29:43,840
the thing being called um but i said

00:29:42,559 --> 00:29:45,520
there may be because

00:29:43,840 --> 00:29:47,360
obviously compilers tend to be optimized

00:29:45,520 --> 00:29:48,080
for the code that we write and a lot of

00:29:47,360 --> 00:29:50,480
code out there

00:29:48,080 --> 00:29:51,840
is written using virtual dispatch it's

00:29:50,480 --> 00:29:53,200
optimizing for that

00:29:51,840 --> 00:29:55,520
but it may be starting to pick up on

00:29:53,200 --> 00:29:57,840
this trend as well

00:29:55,520 --> 00:29:59,360
for me maybe the the most valuable part

00:29:57,840 --> 00:30:01,919
though

00:29:59,360 --> 00:30:04,240
is that type erasure is compatible with

00:30:01,919 --> 00:30:06,640
uh value types

00:30:04,240 --> 00:30:08,240
um as i say you tend to wrap these

00:30:06,640 --> 00:30:09,840
things with a value type that you can

00:30:08,240 --> 00:30:11,520
pass around as a value

00:30:09,840 --> 00:30:12,960
even though its implementation is

00:30:11,520 --> 00:30:15,039
polymorphic

00:30:12,960 --> 00:30:16,159
that was the thing that we're usually

00:30:15,039 --> 00:30:18,559
interested in

00:30:16,159 --> 00:30:20,399
the implementation being polymorphic but

00:30:18,559 --> 00:30:21,919
the whole thing is a value

00:30:20,399 --> 00:30:23,840
there's a really good talk that i'll

00:30:21,919 --> 00:30:25,360
mention in a moment which goes into that

00:30:23,840 --> 00:30:26,720
in a lot more depth

00:30:25,360 --> 00:30:30,240
but one more thing i wanted to mention

00:30:26,720 --> 00:30:33,679
about type erasure is concept mapping

00:30:30,240 --> 00:30:37,520
concept mapping is where you can

00:30:33,679 --> 00:30:39,919
implement a call on the uh the top level

00:30:37,520 --> 00:30:41,279
type using a different call and the on

00:30:39,919 --> 00:30:44,720
the eraser type

00:30:41,279 --> 00:30:45,919
so it's like a mapping between the

00:30:44,720 --> 00:30:47,760
outward-facing concept and the

00:30:45,919 --> 00:30:50,080
over-facing concept

00:30:47,760 --> 00:30:51,679
and this is exactly what swift protocols

00:30:50,080 --> 00:30:53,360
lets you do which is why i lump it in

00:30:51,679 --> 00:30:55,039
with the the type erasure

00:30:53,360 --> 00:30:56,960
uh because it basically lets you do the

00:30:55,039 --> 00:30:58,799
same thing it's actually

00:30:56,960 --> 00:31:00,480
actually quite powerful and although you

00:30:58,799 --> 00:31:01,919
can do it with virtual dispatch it's

00:31:00,480 --> 00:31:04,399
it's much harder and more intrusive

00:31:01,919 --> 00:31:07,279
again so

00:31:04,399 --> 00:31:08,720
there's a lot going for type erasure um

00:31:07,279 --> 00:31:10,960
but there's also other forms

00:31:08,720 --> 00:31:12,799
of polymorphism out there some types

00:31:10,960 --> 00:31:13,679
which in c plus plus we have in the form

00:31:12,799 --> 00:31:17,440
of

00:31:13,679 --> 00:31:19,200
stood variant and stood optional

00:31:17,440 --> 00:31:21,039
uh again these are library

00:31:19,200 --> 00:31:21,600
implementations which would be much

00:31:21,039 --> 00:31:22,960
better

00:31:21,600 --> 00:31:26,080
if they were in the language or

00:31:22,960 --> 00:31:28,159
certainly stood variant but we have them

00:31:26,080 --> 00:31:29,840
that they generally require you to use

00:31:28,159 --> 00:31:34,080
things like stood visit

00:31:29,840 --> 00:31:35,440
which is fine but again um

00:31:34,080 --> 00:31:37,919
it's not as clean as it would be if it

00:31:35,440 --> 00:31:40,480
was in the language so talking of that

00:31:37,919 --> 00:31:41,760
again there are proposals uh going

00:31:40,480 --> 00:31:43,600
through the the process

00:31:41,760 --> 00:31:46,240
which which may help here patent

00:31:43,600 --> 00:31:47,679
matching seems to be they're getting

00:31:46,240 --> 00:31:50,399
along quite nicely

00:31:47,679 --> 00:31:52,720
um i'm hoping that's still targeting 23.

00:31:50,399 --> 00:31:56,880
um i don't know whether that's been

00:31:52,720 --> 00:31:58,240
uh derailed by um the current situation

00:31:56,880 --> 00:32:00,480
around the world a lot of things are

00:31:58,240 --> 00:32:02,880
slowed down it's an ambitious

00:32:00,480 --> 00:32:04,159
proposal but a lot of people are

00:32:02,880 --> 00:32:04,720
interested in getting patent matching

00:32:04,159 --> 00:32:06,880
language

00:32:04,720 --> 00:32:08,240
pattern matching is a much cleaner and

00:32:06,880 --> 00:32:10,320
more direct way

00:32:08,240 --> 00:32:13,440
of doing what we do with studvision plus

00:32:10,320 --> 00:32:16,399
a lot more it's a way of working with

00:32:13,440 --> 00:32:17,519
variant types as well as lots of other

00:32:16,399 --> 00:32:20,399
types but particularly

00:32:17,519 --> 00:32:22,320
thinking right now of varying types as

00:32:20,399 --> 00:32:24,240
polymorphic types

00:32:22,320 --> 00:32:26,320
so the idea here is that rather than

00:32:24,240 --> 00:32:28,320
types being related in a hierarchy

00:32:26,320 --> 00:32:29,760
as they have to be with a virtual

00:32:28,320 --> 00:32:32,159
dispatch type

00:32:29,760 --> 00:32:32,799
can be entirely independent but you can

00:32:32,159 --> 00:32:36,000
still

00:32:32,799 --> 00:32:38,640
uh treat them in a more homogeneous way

00:32:36,000 --> 00:32:40,720
a bit like with type erasure pattern

00:32:38,640 --> 00:32:44,240
matching will really help there

00:32:40,720 --> 00:32:46,080
and there's also a another proposal for

00:32:44,240 --> 00:32:47,840
a language level variant

00:32:46,080 --> 00:32:50,559
um i haven't been keeping up on whether

00:32:47,840 --> 00:32:54,000
that's been progressing or not i know

00:32:50,559 --> 00:32:55,039
originally um we were waiting for

00:32:54,000 --> 00:32:57,679
partner matching to

00:32:55,039 --> 00:32:58,880
to get through as a precursor to it but

00:32:57,679 --> 00:33:00,320
it may be pushed through in parallel

00:32:58,880 --> 00:33:02,480
anyway so i'm saying that's probably

00:33:00,320 --> 00:33:06,080
going to be 26 of the earliest

00:33:02,480 --> 00:33:09,679
so there are some things coming

00:33:06,080 --> 00:33:12,559
for providing more forms of

00:33:09,679 --> 00:33:12,559
in c plus plus

00:33:13,279 --> 00:33:17,039
we also have templates more recently

00:33:16,159 --> 00:33:18,720
concepts

00:33:17,039 --> 00:33:20,320
which you can also consider to be forms

00:33:18,720 --> 00:33:23,360
of polymorphism albeit

00:33:20,320 --> 00:33:25,200
at compile time rather than runtime my

00:33:23,360 --> 00:33:28,000
point here is that there are

00:33:25,200 --> 00:33:30,159
many different types of polymorphism not

00:33:28,000 --> 00:33:31,519
just virtual dispatch

00:33:30,159 --> 00:33:34,080
not just the ones which rely on

00:33:31,519 --> 00:33:35,760
inheritance and not just the ones which

00:33:34,080 --> 00:33:38,720
we tend to associate

00:33:35,760 --> 00:33:41,120
with object orientation which tend to be

00:33:38,720 --> 00:33:42,880
the message passing a virtual dispatch

00:33:41,120 --> 00:33:44,880
polymorphism is a really valuable

00:33:42,880 --> 00:33:47,200
concept in its own right

00:33:44,880 --> 00:33:49,120
in fact many of these approaches to

00:33:47,200 --> 00:33:49,440
polymorphism are actually more popular

00:33:49,120 --> 00:33:52,000
in

00:33:49,440 --> 00:33:52,880
functional programming languages rich

00:33:52,000 --> 00:33:57,039
hickey

00:33:52,880 --> 00:33:59,200
the creator of closure

00:33:57,039 --> 00:34:00,559
he likes to talk about polymorphism a la

00:33:59,200 --> 00:34:02,960
carte

00:34:00,559 --> 00:34:04,720
so you know we don't force you to use

00:34:02,960 --> 00:34:06,320
one particular type of polymorphism they

00:34:04,720 --> 00:34:07,519
have their own strengths and weaknesses

00:34:06,320 --> 00:34:09,440
pick the one that's right on this

00:34:07,519 --> 00:34:11,520
occasion make them all available

00:34:09,440 --> 00:34:12,480
we're gradually getting there in c plus

00:34:11,520 --> 00:34:15,520
plus

00:34:12,480 --> 00:34:16,960
but we've still got a ways to go and

00:34:15,520 --> 00:34:19,599
virtually inheritance sorry virtual

00:34:16,960 --> 00:34:22,639
dispatch it's probably the worst of the

00:34:19,599 --> 00:34:24,960
trade-offs that we have at the moment

00:34:22,639 --> 00:34:26,079
interestingly virtual dispatch is the

00:34:24,960 --> 00:34:30,079
only one

00:34:26,079 --> 00:34:32,839
that relies on inheritance and

00:34:30,079 --> 00:34:34,320
we don't need inheritance to implement

00:34:32,839 --> 00:34:36,639
polymorphism

00:34:34,320 --> 00:34:37,440
and set aside interfaces as well which

00:34:36,639 --> 00:34:39,200
you can treat

00:34:37,440 --> 00:34:41,280
separately as other languages like java

00:34:39,200 --> 00:34:42,960
and c-sharp do

00:34:41,280 --> 00:34:45,520
what else do we actually need

00:34:42,960 --> 00:34:48,639
implementation inheritance for

00:34:45,520 --> 00:34:49,599
there are cases for implementing chunks

00:34:48,639 --> 00:34:52,399
of behavior

00:34:49,599 --> 00:34:53,760
and we often will call these mixins

00:34:52,399 --> 00:34:56,720
again in um

00:34:53,760 --> 00:34:58,160
in rust we call these traits or some

00:34:56,720 --> 00:35:00,240
other languages

00:34:58,160 --> 00:35:02,079
mix-ins traits these are different names

00:35:00,240 --> 00:35:05,440
for being able to compose

00:35:02,079 --> 00:35:08,960
lumps of um behavior together

00:35:05,440 --> 00:35:10,400
in an object but in a cleaner way than

00:35:08,960 --> 00:35:11,839
that we do with with inheritance

00:35:10,400 --> 00:35:14,000
inheritance has a lots of a lot of

00:35:11,839 --> 00:35:16,480
problems in that regard

00:35:14,000 --> 00:35:18,480
in fact inheritance is not essential for

00:35:16,480 --> 00:35:20,640
being an oral language

00:35:18,480 --> 00:35:22,640
visual basic the original one not the

00:35:20,640 --> 00:35:25,040
dot-net incarnation

00:35:22,640 --> 00:35:26,320
never had an inheritance but was

00:35:25,040 --> 00:35:28,880
considered to be you know

00:35:26,320 --> 00:35:30,880
a reasonably pure implementation of the

00:35:28,880 --> 00:35:35,280
oro concepts

00:35:30,880 --> 00:35:38,480
so we don't strictly need inheritance

00:35:35,280 --> 00:35:40,880
polymorphism is definitely not a pure

00:35:38,480 --> 00:35:42,320
oo concept it's much more widely

00:35:40,880 --> 00:35:43,599
applicable and valuable

00:35:42,320 --> 00:35:46,640
and there's lots of different ways to do

00:35:43,599 --> 00:35:51,280
it that aren't strictly ro

00:35:46,640 --> 00:35:52,640
so what else do we have well

00:35:51,280 --> 00:35:56,160
encapsulation that's going to be the big

00:35:52,640 --> 00:36:00,240
thing this has got to be the the core

00:35:56,160 --> 00:36:05,440
concept in object orientation

00:36:00,240 --> 00:36:07,599
but that original language similar

00:36:05,440 --> 00:36:10,560
remember we said actually didn't have

00:36:07,599 --> 00:36:10,560
encapsulation at all

00:36:10,720 --> 00:36:13,839
except for that very limited form in uh

00:36:13,359 --> 00:36:16,240
in

00:36:13,839 --> 00:36:19,119
similar one which is not the sort of

00:36:16,240 --> 00:36:22,640
encapsulation as we think of it today

00:36:19,119 --> 00:36:25,760
so all members were public

00:36:22,640 --> 00:36:27,280
and yet we consider it the original io

00:36:25,760 --> 00:36:30,480
language

00:36:27,280 --> 00:36:33,040
so even encapsulation is not an inherent

00:36:30,480 --> 00:36:35,200
property for velo that doesn't mean it's

00:36:33,040 --> 00:36:36,880
not a particularly valuable one

00:36:35,200 --> 00:36:40,000
i'd still argue it's probably the most

00:36:36,880 --> 00:36:42,720
valuable property of object orientation

00:36:40,000 --> 00:36:44,960
and one that we would certainly want to

00:36:42,720 --> 00:36:48,480
to maintain

00:36:44,960 --> 00:36:51,520
but i want to go back for a moment to

00:36:48,480 --> 00:36:53,599
that dijkstra essay and

00:36:51,520 --> 00:36:55,040
that section that i highlighted before i

00:36:53,599 --> 00:36:56,480
want to read a few choice bits from

00:36:55,040 --> 00:37:00,640
there again

00:36:56,480 --> 00:37:03,280
and see what you think now so he said

00:37:00,640 --> 00:37:05,440
our powers to visualize processes

00:37:03,280 --> 00:37:07,920
evolving in time

00:37:05,440 --> 00:37:09,599
are relatively poorly developed and that

00:37:07,920 --> 00:37:10,560
we should try to shorten the conceptual

00:37:09,599 --> 00:37:11,839
gap

00:37:10,560 --> 00:37:13,280
between the static program and the

00:37:11,839 --> 00:37:16,560
dynamic process and make that

00:37:13,280 --> 00:37:18,160
correspondence as trivial as possible

00:37:16,560 --> 00:37:19,920
now say he was talking about the path of

00:37:18,160 --> 00:37:20,880
the instruction pointer through your

00:37:19,920 --> 00:37:23,200
code

00:37:20,880 --> 00:37:25,440
but i don't know if you get the same

00:37:23,200 --> 00:37:28,560
feeling that i did when i read this that

00:37:25,440 --> 00:37:34,079
he could equally have been talking about

00:37:28,560 --> 00:37:35,839
mutable state processes evolving in time

00:37:34,079 --> 00:37:38,160
our powers to visualize and poorly

00:37:35,839 --> 00:37:39,520
developed conceptual gap between

00:37:38,160 --> 00:37:41,280
the static program as written and the

00:37:39,520 --> 00:37:43,119
dynamic process as it runs

00:37:41,280 --> 00:37:44,960
well these are all all things that apply

00:37:43,119 --> 00:37:48,160
to mutable state

00:37:44,960 --> 00:37:50,079
if you have a variable which is mutable

00:37:48,160 --> 00:37:51,359
in order to know what its value is at

00:37:50,079 --> 00:37:52,800
any point in the program

00:37:51,359 --> 00:37:54,400
you have to consider pretty much every

00:37:52,800 --> 00:37:57,599
other point in the program

00:37:54,400 --> 00:37:58,720
everything is entwined so reasoning

00:37:57,599 --> 00:38:00,720
about that value

00:37:58,720 --> 00:38:02,000
becomes really really hard whereas if

00:38:00,720 --> 00:38:06,000
it's constant

00:38:02,000 --> 00:38:07,839
it's trivial just to

00:38:06,000 --> 00:38:09,200
put something concrete on that let's

00:38:07,839 --> 00:38:11,119
actually consider

00:38:09,200 --> 00:38:13,359
an example so here's our first real

00:38:11,119 --> 00:38:14,720
class just going to go with a very basic

00:38:13,359 --> 00:38:16,400
date class

00:38:14,720 --> 00:38:18,079
the purpose here is not to be a great

00:38:16,400 --> 00:38:21,599
date implementation

00:38:18,079 --> 00:38:23,760
it's just illustrative but we have

00:38:21,599 --> 00:38:25,599
some state some integers for year month

00:38:23,760 --> 00:38:29,359
and day

00:38:25,599 --> 00:38:32,000
we have a constructor which as well as

00:38:29,359 --> 00:38:33,200
setting letting you set those values

00:38:32,000 --> 00:38:35,920
also do some checking

00:38:33,200 --> 00:38:37,359
on their ranges now if you deserts here

00:38:35,920 --> 00:38:39,200
uh if you want to make this

00:38:37,359 --> 00:38:41,200
uh input validation you would probably

00:38:39,200 --> 00:38:43,839
use exceptions or some other technique

00:38:41,200 --> 00:38:45,040
to to verify it at the point here is

00:38:43,839 --> 00:38:46,000
that there's some way that we are

00:38:45,040 --> 00:38:48,000
checking

00:38:46,000 --> 00:38:49,520
those ranges and i delighted the more

00:38:48,000 --> 00:38:50,000
complex bits let's just imagine you've

00:38:49,520 --> 00:38:52,000
gone

00:38:50,000 --> 00:38:53,839
you've been very thorough and validated

00:38:52,000 --> 00:38:55,200
that this is actually a real date that

00:38:53,839 --> 00:38:58,480
represents a real date in

00:38:55,200 --> 00:39:00,880
in history or the future which means

00:38:58,480 --> 00:39:02,000
you get this nice property of correct by

00:39:00,880 --> 00:39:04,000
construction

00:39:02,000 --> 00:39:05,680
if you can construct one of these then

00:39:04,000 --> 00:39:08,400
you know it's a valid data

00:39:05,680 --> 00:39:10,079
you cannot construct an invalid date

00:39:08,400 --> 00:39:12,560
that's a really nice property that we

00:39:10,079 --> 00:39:13,680
we generally strive for in particularly

00:39:12,560 --> 00:39:14,880
our value types

00:39:13,680 --> 00:39:16,720
and i think we would consider this a

00:39:14,880 --> 00:39:20,240
value type

00:39:16,720 --> 00:39:22,720
so that's quite nice we also have some

00:39:20,240 --> 00:39:24,400
getters just to give you access to the

00:39:22,720 --> 00:39:26,240
year month and day and then

00:39:24,400 --> 00:39:28,560
they're fairly innocuous we need those

00:39:26,240 --> 00:39:33,040
because we have made our state

00:39:28,560 --> 00:39:35,680
private why do we make it private

00:39:33,040 --> 00:39:37,920
because that's how we do encapsulation

00:39:35,680 --> 00:39:42,240
but consider this

00:39:37,920 --> 00:39:44,320
if we did make that public

00:39:42,240 --> 00:39:46,240
then what would what would happen well

00:39:44,320 --> 00:39:48,480
first of all we could lose the

00:39:46,240 --> 00:39:50,079
the getters because now we can just

00:39:48,480 --> 00:39:51,280
access those members directly so they'll

00:39:50,079 --> 00:39:54,960
probably change the names

00:39:51,280 --> 00:39:57,839
get rid of that prefix uh we can also

00:39:54,960 --> 00:39:58,800
use a struct instead of a class i like

00:39:57,839 --> 00:40:01,920
to do that when

00:39:58,800 --> 00:40:02,720
everything is public for me that states

00:40:01,920 --> 00:40:06,079
intention

00:40:02,720 --> 00:40:08,960
as well as losing a line of code but

00:40:06,079 --> 00:40:10,560
downside of course is that invariant

00:40:08,960 --> 00:40:13,520
that this is always a valid date

00:40:10,560 --> 00:40:14,960
it's no longer enforced that's the main

00:40:13,520 --> 00:40:16,560
consequent not the only consequence but

00:40:14,960 --> 00:40:19,920
the main consequence

00:40:16,560 --> 00:40:19,920
of breaking encapsulation

00:40:20,319 --> 00:40:24,720
now let's say there are other things

00:40:23,200 --> 00:40:27,359
that we get from encapsulation

00:40:24,720 --> 00:40:28,800
mostly um that we can change our private

00:40:27,359 --> 00:40:29,440
implementation to something else without

00:40:28,800 --> 00:40:30,960
breaking

00:40:29,440 --> 00:40:33,359
callers but in this case we're providing

00:40:30,960 --> 00:40:34,400
getters anyway and yes you can compute

00:40:33,359 --> 00:40:35,839
getters you can

00:40:34,400 --> 00:40:38,319
you can do mappings and things they give

00:40:35,839 --> 00:40:42,160
you some protection but

00:40:38,319 --> 00:40:43,440
in many cases your your classes really

00:40:42,160 --> 00:40:45,599
are just

00:40:43,440 --> 00:40:47,119
bags of data that people just want to

00:40:45,599 --> 00:40:48,880
get

00:40:47,119 --> 00:40:50,640
the the specific bits out that are in

00:40:48,880 --> 00:40:52,240
there when that's not the case then

00:40:50,640 --> 00:40:54,720
absolutely

00:40:52,240 --> 00:40:55,839
encapsulation will help you but in many

00:40:54,720 --> 00:40:57,280
many cases

00:40:55,839 --> 00:40:58,400
it really is just like this we just want

00:40:57,280 --> 00:41:00,880
the year the month and the date and

00:40:58,400 --> 00:41:04,160
that's how they're held

00:41:00,880 --> 00:41:07,040
so of course if we made them const

00:41:04,160 --> 00:41:08,640
then we wouldn't have the problem of

00:41:07,040 --> 00:41:09,760
being able to construct invalid dates

00:41:08,640 --> 00:41:13,520
anymore

00:41:09,760 --> 00:41:16,800
so this first of all

00:41:13,520 --> 00:41:20,160
solves not solves but um is a

00:41:16,800 --> 00:41:23,040
a nod to uh what dijkstra

00:41:20,160 --> 00:41:25,040
asked us to do to do what we can to

00:41:23,040 --> 00:41:28,240
close the gap between

00:41:25,040 --> 00:41:28,960
our um ability to reason about the code

00:41:28,240 --> 00:41:32,240
as written

00:41:28,960 --> 00:41:34,400
and the code as it's running so that we

00:41:32,240 --> 00:41:37,040
get fewer surprises

00:41:34,400 --> 00:41:38,319
and when we do that suddenly we find

00:41:37,040 --> 00:41:40,880
that encapsulation isn't

00:41:38,319 --> 00:41:42,400
as important as it was before for all of

00:41:40,880 --> 00:41:44,160
these types

00:41:42,400 --> 00:41:46,400
as i say it doesn't completely remove it

00:41:44,160 --> 00:41:47,520
of course but for many types you can

00:41:46,400 --> 00:41:51,040
actually make

00:41:47,520 --> 00:41:54,240
you can actually make the state public

00:41:51,040 --> 00:41:54,240
and that simplifies some things

00:41:55,200 --> 00:42:02,640
um there's other ways actually you can

00:41:58,880 --> 00:42:06,640
you can also do this so if you

00:42:02,640 --> 00:42:10,400
um if you were using polymorphism

00:42:06,640 --> 00:42:13,839
then you may only need to see that state

00:42:10,400 --> 00:42:15,680
in a particular module

00:42:13,839 --> 00:42:17,040
to use that in the general sense not

00:42:15,680 --> 00:42:20,319
modules in c plus

00:42:17,040 --> 00:42:22,319
20 but like a translation unit or or a

00:42:20,319 --> 00:42:23,839
component

00:42:22,319 --> 00:42:25,760
so only that module maybe that

00:42:23,839 --> 00:42:26,880
translation unit actually has access to

00:42:25,760 --> 00:42:28,400
that

00:42:26,880 --> 00:42:30,319
private state without actually using the

00:42:28,400 --> 00:42:33,520
private keyword

00:42:30,319 --> 00:42:35,040
whereas other clients would only access

00:42:33,520 --> 00:42:37,200
it via interface if you're going to go

00:42:35,040 --> 00:42:39,839
that route

00:42:37,200 --> 00:42:42,000
so but there are also other ways to

00:42:39,839 --> 00:42:43,599
achieve the same effect without

00:42:42,000 --> 00:42:45,119
the forms of encapsulation that we've

00:42:43,599 --> 00:42:48,400
been used to the

00:42:45,119 --> 00:42:50,560
private protected public

00:42:48,400 --> 00:42:52,079
so maybe we should also be asking our

00:42:50,560 --> 00:42:53,760
classes the right unit for even

00:42:52,079 --> 00:42:55,599
expressing this in the first place

00:42:53,760 --> 00:42:57,760
there are other languages that do

00:42:55,599 --> 00:42:58,960
implement access control but at the

00:42:57,760 --> 00:43:00,560
module level

00:42:58,960 --> 00:43:02,960
and they seem to be actually better for

00:43:00,560 --> 00:43:04,400
it so

00:43:02,960 --> 00:43:06,640
yeah another another question to ask

00:43:04,400 --> 00:43:08,560
about encapsulation

00:43:06,640 --> 00:43:10,240
but i do think that certainly that

00:43:08,560 --> 00:43:12,240
component level whether you call it a

00:43:10,240 --> 00:43:14,400
module or something else

00:43:12,240 --> 00:43:15,839
encapsulation that's where it's really

00:43:14,400 --> 00:43:18,079
important

00:43:15,839 --> 00:43:19,119
protecting what's in your implementation

00:43:18,079 --> 00:43:21,760
of your component

00:43:19,119 --> 00:43:24,000
from the outside world and that's where

00:43:21,760 --> 00:43:28,319
we start to get back to

00:43:24,000 --> 00:43:29,839
something like similar ones processes

00:43:28,319 --> 00:43:32,480
if you think about processes like a

00:43:29,839 --> 00:43:35,599
module self-contained

00:43:32,480 --> 00:43:38,640
running itself a little bit like um

00:43:35,599 --> 00:43:41,920
erlang has a similar approach

00:43:38,640 --> 00:43:43,119
uh you have components processes again

00:43:41,920 --> 00:43:45,040
that

00:43:43,119 --> 00:43:47,119
can talk to each other message passing

00:43:45,040 --> 00:43:48,480
again but they have internal state that

00:43:47,119 --> 00:43:50,079
can mutate

00:43:48,480 --> 00:43:51,520
but it's completely encapsulated from

00:43:50,079 --> 00:43:52,960
the outside world and this is real

00:43:51,520 --> 00:43:54,880
encapsulation

00:43:52,960 --> 00:43:57,280
so the encapsulation we have in c plus

00:43:54,880 --> 00:43:58,640
plus is actually a bit broken

00:43:57,280 --> 00:44:00,880
there's all sorts of ways that we can

00:43:58,640 --> 00:44:03,599
subvert it even just

00:44:00,880 --> 00:44:04,640
inheriting from a class gives us access

00:44:03,599 --> 00:44:08,000
to

00:44:04,640 --> 00:44:10,000
its protected data at least

00:44:08,000 --> 00:44:11,359
which in a way breaks some forms of

00:44:10,000 --> 00:44:13,359
encapsulation

00:44:11,359 --> 00:44:14,560
a class members of a class have access

00:44:13,359 --> 00:44:17,440
to the private members

00:44:14,560 --> 00:44:19,280
of another instance of the same class

00:44:17,440 --> 00:44:22,560
but that's not so

00:44:19,280 --> 00:44:24,400
with languages like erlang

00:44:22,560 --> 00:44:25,920
um and i would imagine even simulator

00:44:24,400 --> 00:44:27,680
one other side never actually written a

00:44:25,920 --> 00:44:30,960
line of similar so

00:44:27,680 --> 00:44:30,960
i'm extrapolating that

00:44:31,520 --> 00:44:34,560
okay so we we were talking a bit about

00:44:33,520 --> 00:44:36,560
mutability

00:44:34,560 --> 00:44:38,640
a moment ago and how that can impact

00:44:36,560 --> 00:44:41,839
encapsulation

00:44:38,640 --> 00:44:44,800
and we also tied it back to

00:44:41,839 --> 00:44:45,839
dijkstra's comments on how we can reason

00:44:44,800 --> 00:44:46,880
about our code

00:44:45,839 --> 00:44:49,440
even though he never actually used the

00:44:46,880 --> 00:44:49,440
word reason

00:44:49,680 --> 00:44:52,880
but we can't completely eliminate

00:44:51,040 --> 00:44:55,040
mutability

00:44:52,880 --> 00:44:56,640
uh we want to minimize it to the

00:44:55,040 --> 00:44:59,280
essential mutability

00:44:56,640 --> 00:45:00,800
but without it at all our programs

00:44:59,280 --> 00:45:04,319
wouldn't do much

00:45:00,800 --> 00:45:08,000
even haskell has to introduce mutability

00:45:04,319 --> 00:45:09,839
the back door but but it is there

00:45:08,000 --> 00:45:11,440
but you want to be able to express it at

00:45:09,839 --> 00:45:14,240
the right level

00:45:11,440 --> 00:45:16,400
and for me what i've been leaning

00:45:14,240 --> 00:45:19,680
towards over the years

00:45:16,400 --> 00:45:22,560
is for that mutability to be mostly

00:45:19,680 --> 00:45:24,960
expressed at the component level

00:45:22,560 --> 00:45:26,319
but at the lower level strive for

00:45:24,960 --> 00:45:28,640
immutability

00:45:26,319 --> 00:45:29,760
by which i mean using value types as

00:45:28,640 --> 00:45:31,839
much as possible

00:45:29,760 --> 00:45:33,040
and package them together into

00:45:31,839 --> 00:45:34,640
components

00:45:33,040 --> 00:45:36,480
that express those ideas of

00:45:34,640 --> 00:45:41,119
encapsulation

00:45:36,480 --> 00:45:41,119
and potentially active processes

00:45:41,440 --> 00:45:46,880
now there's one interesting fault here

00:45:44,400 --> 00:45:50,400
which is when we talk about value types

00:45:46,880 --> 00:45:52,400
and value types being immutable

00:45:50,400 --> 00:45:55,280
but we have value types at least in c

00:45:52,400 --> 00:45:57,200
plus plus that are not immutable

00:45:55,280 --> 00:46:00,240
uh string is probably the the best

00:45:57,200 --> 00:46:01,040
example of that stood string you can

00:46:00,240 --> 00:46:04,880
mutate it

00:46:01,040 --> 00:46:08,160
in place but it's a value type so

00:46:04,880 --> 00:46:10,720
what's going on there well

00:46:08,160 --> 00:46:12,960
i would argue it shouldn't be that way

00:46:10,720 --> 00:46:14,240
and uh talk i did a few years ago

00:46:12,960 --> 00:46:16,720
functional c plus plus for fun and

00:46:14,240 --> 00:46:19,040
profit again links at the end

00:46:16,720 --> 00:46:19,920
i talk about a lot of this stuff but i

00:46:19,040 --> 00:46:22,240
do

00:46:19,920 --> 00:46:23,040
specifically talk about a string

00:46:22,240 --> 00:46:24,960
implementation

00:46:23,040 --> 00:46:26,319
just in general although it's based on a

00:46:24,960 --> 00:46:27,520
few string implementations i have

00:46:26,319 --> 00:46:30,960
written

00:46:27,520 --> 00:46:35,200
which is an immutable string

00:46:30,960 --> 00:46:37,040
but paired with a another type

00:46:35,200 --> 00:46:39,440
which is a what i call it a string

00:46:37,040 --> 00:46:40,960
builder and in general you can refer to

00:46:39,440 --> 00:46:44,560
these things as builders

00:46:40,960 --> 00:46:49,040
their purpose is entirely to be mutable

00:46:44,560 --> 00:46:50,240
to construct a a particular value

00:46:49,040 --> 00:46:52,400
and once you've got that value that

00:46:50,240 --> 00:46:55,440
value is then unchanging

00:46:52,400 --> 00:46:56,480
and immutable but the interesting thing

00:46:55,440 --> 00:47:00,400
with the string builder

00:46:56,480 --> 00:47:03,599
is first of all using move semantics

00:47:00,400 --> 00:47:05,520
you can construct that string

00:47:03,599 --> 00:47:07,359
in a piece of memory but then pass that

00:47:05,520 --> 00:47:11,119
memory off to your

00:47:07,359 --> 00:47:13,520
to your value type to take ownership of

00:47:11,119 --> 00:47:15,359
sole ownership so it can now be shared

00:47:13,520 --> 00:47:16,800
because it's immutable

00:47:15,359 --> 00:47:18,480
uh in this implementation i made it

00:47:16,800 --> 00:47:20,559
reference counted um

00:47:18,480 --> 00:47:21,839
doesn't have to be but it actually

00:47:20,559 --> 00:47:23,520
worked out pretty well

00:47:21,839 --> 00:47:26,559
but then you if you want to change it

00:47:23,520 --> 00:47:28,720
later you could move it back

00:47:26,559 --> 00:47:29,680
into a string builder and if that was

00:47:28,720 --> 00:47:32,960
the last

00:47:29,680 --> 00:47:34,319
copy of that string then

00:47:32,960 --> 00:47:35,920
that memory would then be transferred

00:47:34,319 --> 00:47:36,960
back to a string builder you could

00:47:35,920 --> 00:47:40,160
mutate it again

00:47:36,960 --> 00:47:41,760
safely in the string builder and then

00:47:40,160 --> 00:47:43,440
move it back into another immutable

00:47:41,760 --> 00:47:45,599
string

00:47:43,440 --> 00:47:46,880
now the purpose of going into this is to

00:47:45,599 --> 00:47:49,680
show how

00:47:46,880 --> 00:47:50,559
you can make explicit exactly where the

00:47:49,680 --> 00:47:52,559
mutations

00:47:50,559 --> 00:47:55,040
are allowed to occur rather than it

00:47:52,559 --> 00:47:56,240
being potentially anywhere in your code

00:47:55,040 --> 00:47:58,079
you can say well i know that from the

00:47:56,240 --> 00:47:59,920
moment i get this immutable string

00:47:58,079 --> 00:48:01,839
to any other place that i use it it's

00:47:59,920 --> 00:48:03,119
the same string

00:48:01,839 --> 00:48:05,200
but this little bit of code that i've

00:48:03,119 --> 00:48:06,640
got over here

00:48:05,200 --> 00:48:07,760
that's where the mutability is going on

00:48:06,640 --> 00:48:08,960
and that's where i need to make sure

00:48:07,760 --> 00:48:10,720
that

00:48:08,960 --> 00:48:12,640
i can completely reason through what's

00:48:10,720 --> 00:48:15,440
happening so you

00:48:12,640 --> 00:48:17,200
you scope the mutability to exactly

00:48:15,440 --> 00:48:18,720
where you need it

00:48:17,200 --> 00:48:20,240
and that's something that we can do with

00:48:18,720 --> 00:48:21,680
with pretty much any value type but we

00:48:20,240 --> 00:48:23,119
really do because

00:48:21,680 --> 00:48:25,680
it just feels more convenient to just

00:48:23,119 --> 00:48:28,800
leave everything mutable all the time

00:48:25,680 --> 00:48:31,680
it's a bad habit and we've

00:48:28,800 --> 00:48:32,079
we've lost our ability to even see how

00:48:31,680 --> 00:48:34,880
we

00:48:32,079 --> 00:48:36,240
we can't reason about that anymore once

00:48:34,880 --> 00:48:38,079
you start to see it

00:48:36,240 --> 00:48:40,480
you can actually be quite shocked at how

00:48:38,079 --> 00:48:43,040
you're able to live with it before

00:48:40,480 --> 00:48:44,800
so listen i've not done that justice go

00:48:43,040 --> 00:48:46,640
and go and watch that talk

00:48:44,800 --> 00:48:48,240
but another great talk which i did

00:48:46,640 --> 00:48:51,920
reference earlier

00:48:48,240 --> 00:48:56,000
so i'll give you the talk title now um

00:48:51,920 --> 00:48:57,599
pompeii juan pedro uh ponti

00:48:56,000 --> 00:48:59,440
he's done we've done a few talks on this

00:48:57,599 --> 00:49:00,640
subject um i'm particularly thinking of

00:48:59,440 --> 00:49:04,319
this one he did last year at

00:49:00,640 --> 00:49:06,960
c plus 103 this year at c plus plus on c

00:49:04,319 --> 00:49:07,760
because he talks about the intersection

00:49:06,960 --> 00:49:10,000
of

00:49:07,760 --> 00:49:12,319
value-oriented design and

00:49:10,000 --> 00:49:13,359
object-oriented systems

00:49:12,319 --> 00:49:16,319
which is sort of what we're talking

00:49:13,359 --> 00:49:18,000
about here so i've come around to saying

00:49:16,319 --> 00:49:19,680
value-oriented

00:49:18,000 --> 00:49:21,359
uh design is really what you want to be

00:49:19,680 --> 00:49:22,079
doing at the lower level actually uh

00:49:21,359 --> 00:49:24,400
juanpay

00:49:22,079 --> 00:49:26,079
talks about doing it at higher levels

00:49:24,400 --> 00:49:28,800
obviously you can push that

00:49:26,079 --> 00:49:31,359
um but also that's connecting with

00:49:28,800 --> 00:49:33,359
object-oriented systems

00:49:31,359 --> 00:49:34,800
so it's a great talk encourage you to

00:49:33,359 --> 00:49:36,240
watch that one and

00:49:34,800 --> 00:49:38,160
many of his other talks on similar

00:49:36,240 --> 00:49:39,920
topics including

00:49:38,160 --> 00:49:42,240
the persistent data structures and that

00:49:39,920 --> 00:49:44,640
sort of thing

00:49:42,240 --> 00:49:46,720
in fact this is really what i want to

00:49:44,640 --> 00:49:48,800
lead on to

00:49:46,720 --> 00:49:49,760
can we get the best of both worlds i've

00:49:48,800 --> 00:49:53,280
talked about

00:49:49,760 --> 00:49:55,440
how ideally for me i see the low level

00:49:53,280 --> 00:49:57,359
design being about value types higher

00:49:55,440 --> 00:49:59,359
level design

00:49:57,359 --> 00:50:00,960
component types that certainly include

00:49:59,359 --> 00:50:03,680
encapsulation they may include other

00:50:00,960 --> 00:50:05,440
aspects of object orientation

00:50:03,680 --> 00:50:06,960
but how can we bridge these worlds and

00:50:05,440 --> 00:50:11,119
how can we get the best of

00:50:06,960 --> 00:50:14,000
both of them or all of them because

00:50:11,119 --> 00:50:16,960
one of c plus plus h's biggest strengths

00:50:14,000 --> 00:50:18,319
is that it is a multi-paradigm language

00:50:16,960 --> 00:50:20,000
in the early days it was thought of as

00:50:18,319 --> 00:50:21,280
an o language because that was the new

00:50:20,000 --> 00:50:22,160
thing that was the buzzword and what

00:50:21,280 --> 00:50:25,520
everyone wanted to

00:50:22,160 --> 00:50:28,400
get into and it was its main delta over

00:50:25,520 --> 00:50:29,680
c at the time but it's grown into so

00:50:28,400 --> 00:50:31,520
much more

00:50:29,680 --> 00:50:33,200
uh and it's still pushing into new

00:50:31,520 --> 00:50:34,480
paradigms taken on more and more

00:50:33,200 --> 00:50:37,440
functional

00:50:34,480 --> 00:50:38,240
uh design aspects and value types are

00:50:37,440 --> 00:50:40,240
becoming

00:50:38,240 --> 00:50:41,599
a very important consideration in new

00:50:40,240 --> 00:50:44,160
features

00:50:41,599 --> 00:50:45,920
uh it's been a really great generic

00:50:44,160 --> 00:50:49,839
programming environment

00:50:45,920 --> 00:50:52,720
uh certainly since uh the first standard

00:50:49,839 --> 00:50:53,040
many paradigms are supported fairly well

00:50:52,720 --> 00:50:55,680
in

00:50:53,040 --> 00:50:56,640
plus plus um i think there are a few

00:50:55,680 --> 00:50:59,839
that are supported

00:50:56,640 --> 00:51:03,200
really well maybe generic programming

00:50:59,839 --> 00:51:03,200
but how can we bring these all together

00:51:03,359 --> 00:51:06,480
well let's summarize so as i say at the

00:51:05,680 --> 00:51:08,480
low level

00:51:06,480 --> 00:51:10,079
prefer immutable value types is my

00:51:08,480 --> 00:51:12,960
advice

00:51:10,079 --> 00:51:14,960
in order to do that well you need to

00:51:12,960 --> 00:51:17,440
really understand

00:51:14,960 --> 00:51:19,920
certain other features such as

00:51:17,440 --> 00:51:23,119
persistent data structures

00:51:19,920 --> 00:51:26,240
in order to treat containers

00:51:23,119 --> 00:51:27,119
as immutable value types persistent data

00:51:26,240 --> 00:51:30,400
structures

00:51:27,119 --> 00:51:31,760
are the only reasonable way to do that

00:51:30,400 --> 00:51:32,800
and once you understand them you realize

00:51:31,760 --> 00:51:34,960
they solve a whole load of other

00:51:32,800 --> 00:51:38,240
problems as well

00:51:34,960 --> 00:51:39,920
um i hate to say it but

00:51:38,240 --> 00:51:41,920
becoming at least familiar with what

00:51:39,920 --> 00:51:43,520
magnetic operations are

00:51:41,920 --> 00:51:45,760
could be valuable you don't have to

00:51:43,520 --> 00:51:48,960
understand all of the theory behind them

00:51:45,760 --> 00:51:50,720
although that can be useful but

00:51:48,960 --> 00:51:52,720
this is going to become more and more of

00:51:50,720 --> 00:51:54,800
a topic it's not actually going away

00:51:52,720 --> 00:51:56,480
um we're just we've started to get used

00:51:54,800 --> 00:51:59,839
to it

00:51:56,480 --> 00:52:01,680
builders a bit of a simpler idea

00:51:59,839 --> 00:52:03,280
actually very simple idea which is the

00:52:01,680 --> 00:52:04,640
beauty of it

00:52:03,280 --> 00:52:07,119
as i mentioned with the strings they're

00:52:04,640 --> 00:52:10,160
all about controlling

00:52:07,119 --> 00:52:11,599
the immutability values too exactly the

00:52:10,160 --> 00:52:14,480
scope that we need in

00:52:11,599 --> 00:52:16,160
and no more which is really what we're

00:52:14,480 --> 00:52:17,680
trying to do here

00:52:16,160 --> 00:52:19,839
we want to be able to make our code

00:52:17,680 --> 00:52:22,720
reasonable as in

00:52:19,839 --> 00:52:24,000
able to reason about it and if we can

00:52:22,720 --> 00:52:26,480
keep as much of our code

00:52:24,000 --> 00:52:29,520
immutable as possible while still

00:52:26,480 --> 00:52:30,720
allowing that essential mutability and

00:52:29,520 --> 00:52:31,920
that's a really big way that we're going

00:52:30,720 --> 00:52:32,800
to be able to do that and builders are a

00:52:31,920 --> 00:52:34,240
really

00:52:32,800 --> 00:52:37,440
powerful way to do that in a really

00:52:34,240 --> 00:52:39,760
simple concept

00:52:37,440 --> 00:52:40,800
and then we have functionally composable

00:52:39,760 --> 00:52:41,760
algorithms so we're going to talk about

00:52:40,800 --> 00:52:43,839
these

00:52:41,760 --> 00:52:45,200
in this talk but they're definitely

00:52:43,839 --> 00:52:47,520
something that supports this idea of

00:52:45,200 --> 00:52:49,839
immutable belly types

00:52:47,520 --> 00:52:51,119
ranges are coming in c plus plus 20

00:52:49,839 --> 00:52:52,640
they're only going to get more powerful

00:52:51,119 --> 00:52:54,960
over time

00:52:52,640 --> 00:52:56,160
and they are a great way to a lot of

00:52:54,960 --> 00:52:59,200
other

00:52:56,160 --> 00:53:01,920
functional concepts as well

00:52:59,200 --> 00:53:04,160
so do become familiar with those but

00:53:01,920 --> 00:53:06,800
that's at the low level

00:53:04,160 --> 00:53:08,640
at the high level depends on your

00:53:06,800 --> 00:53:10,559
project on your architecture but very

00:53:08,640 --> 00:53:14,960
often

00:53:10,559 --> 00:53:18,160
components with encapsulated state

00:53:14,960 --> 00:53:20,960
are the way to go so if you think of

00:53:18,160 --> 00:53:21,920
particularly persistent data structures

00:53:20,960 --> 00:53:24,960
you may have a

00:53:21,920 --> 00:53:26,079
large container of objects but that

00:53:24,960 --> 00:53:29,599
structure is immutable

00:53:26,079 --> 00:53:30,880
it can't change so in order to

00:53:29,599 --> 00:53:33,119
add something to it you actually need to

00:53:30,880 --> 00:53:34,480
take a copy of it it's very cheap copy

00:53:33,119 --> 00:53:35,440
this is what persistent data structures

00:53:34,480 --> 00:53:38,160
give you

00:53:35,440 --> 00:53:39,440
with the new item in it and the only

00:53:38,160 --> 00:53:42,640
thing that then changes

00:53:39,440 --> 00:53:44,720
is the new route something

00:53:42,640 --> 00:53:46,559
has to hold that new route and that

00:53:44,720 --> 00:53:50,400
thing then itself

00:53:46,559 --> 00:53:51,760
is mutable and there are concepts in in

00:53:50,400 --> 00:53:54,000
the functional world

00:53:51,760 --> 00:53:55,680
that uh sort of formalize this a bit you

00:53:54,000 --> 00:53:56,480
may hear about ref cells and things like

00:53:55,680 --> 00:53:57,760
that

00:53:56,480 --> 00:53:59,599
but all you really need to think about

00:53:57,760 --> 00:54:02,640
is

00:53:59,599 --> 00:54:04,480
like we did with builders okay try to

00:54:02,640 --> 00:54:08,319
constrain the mutability to certain

00:54:04,480 --> 00:54:10,400
well-defined places having

00:54:08,319 --> 00:54:11,920
your your state encapsulated at the

00:54:10,400 --> 00:54:14,000
component level means you've got

00:54:11,920 --> 00:54:15,359
one level where you keep all of your

00:54:14,000 --> 00:54:17,599
mutable hooks

00:54:15,359 --> 00:54:19,040
to the other parts of your code which

00:54:17,599 --> 00:54:21,599
are then themselves

00:54:19,040 --> 00:54:21,599
immutable

00:54:22,559 --> 00:54:26,720
takes a little getting your head around

00:54:24,160 --> 00:54:28,880
the idea but once it clicks you think ah

00:54:26,720 --> 00:54:30,640
yes that's how it all works and of

00:54:28,880 --> 00:54:31,839
course yes it's always more complicated

00:54:30,640 --> 00:54:34,720
than that in practice

00:54:31,839 --> 00:54:35,839
and there are additional um additional

00:54:34,720 --> 00:54:38,480
research into

00:54:35,839 --> 00:54:40,319
uh things like software transactional

00:54:38,480 --> 00:54:41,680
memory to try to capture the more

00:54:40,319 --> 00:54:43,680
general case

00:54:41,680 --> 00:54:45,599
but you can actually get a long way with

00:54:43,680 --> 00:54:48,799
some of the simple ideas

00:54:45,599 --> 00:54:50,720
even if it's not exhaustive

00:54:48,799 --> 00:54:53,599
uh maybe also consider things like

00:54:50,720 --> 00:54:57,280
active objects co-routines

00:54:53,599 --> 00:54:58,400
for encapsulation may not be something

00:54:57,280 --> 00:55:01,920
that we've been familiar with

00:54:58,400 --> 00:55:06,400
thinking about these are all ideas

00:55:01,920 --> 00:55:08,559
so i seem to have come to

00:55:06,400 --> 00:55:09,520
the end of this talk a little bit early

00:55:08,559 --> 00:55:11,359
i think

00:55:09,520 --> 00:55:12,640
so me thinking i may have missed

00:55:11,359 --> 00:55:15,839
something

00:55:12,640 --> 00:55:18,960
um there's the link that i mentioned to

00:55:15,839 --> 00:55:21,040
my website level of indirection.com

00:55:18,960 --> 00:55:22,799
uh if you can't remember that also extra

00:55:21,040 --> 00:55:23,280
level of indirection.com the redirect

00:55:22,799 --> 00:55:26,319
set

00:55:23,280 --> 00:55:27,119
of course and then slash refs where i

00:55:26,319 --> 00:55:31,040
keep all of my

00:55:27,119 --> 00:55:33,760
talk references slash oo-harmful

00:55:31,040 --> 00:55:34,799
html that will get you the links i'll

00:55:33,760 --> 00:55:35,119
try and remember to place that in the

00:55:34,799 --> 00:55:38,160
chat

00:55:35,119 --> 00:55:40,319
afterwards as well now i

00:55:38,160 --> 00:55:41,680
would have had my laptop up and running

00:55:40,319 --> 00:55:43,200
to be able to look at

00:55:41,680 --> 00:55:44,559
any questions that you may have

00:55:43,200 --> 00:55:46,079
unfortunately the battery died and it

00:55:44,559 --> 00:55:49,119
doesn't seem to be

00:55:46,079 --> 00:55:52,640
revived so i've asked um kevin my

00:55:49,119 --> 00:55:56,000
volunteer um buddy here to

00:55:52,640 --> 00:55:57,520
pop into the um the stream

00:55:56,000 --> 00:55:59,520
to read out any questions that we may

00:55:57,520 --> 00:56:02,480
have

00:55:59,520 --> 00:56:03,440
so kevin are you there yep can you hear

00:56:02,480 --> 00:56:06,720
me all right right

00:56:03,440 --> 00:56:10,160
i can how do you okay so

00:56:06,720 --> 00:56:12,799
scott asks in terms of encapsulation

00:56:10,160 --> 00:56:14,720
i see functions are to classes as stack

00:56:12,799 --> 00:56:17,440
frames are to objects

00:56:14,720 --> 00:56:18,640
functions are methods without the quote

00:56:17,440 --> 00:56:20,960
this

00:56:18,640 --> 00:56:21,839
friend extra parameter potentially

00:56:20,960 --> 00:56:24,799
ruining your day

00:56:21,839 --> 00:56:25,680
do you have any thoughts i like the

00:56:24,799 --> 00:56:27,920
potentially

00:56:25,680 --> 00:56:28,960
ruining your day part what i don't like

00:56:27,920 --> 00:56:30,160
is

00:56:28,960 --> 00:56:32,559
the way around that you're thinking of

00:56:30,160 --> 00:56:36,240
them i would rather think of

00:56:32,559 --> 00:56:38,079
methods as just functions that happen to

00:56:36,240 --> 00:56:39,440
um have some idea about an object

00:56:38,079 --> 00:56:41,359
associated with them

00:56:39,440 --> 00:56:42,839
and then functions of the pure concept

00:56:41,359 --> 00:56:44,400
which i'm sure is what you were saying

00:56:42,839 --> 00:56:46,480
but

00:56:44,400 --> 00:56:49,520
yeah not sure that answers the question

00:56:46,480 --> 00:56:49,520
though was it a question

00:56:50,880 --> 00:56:55,200
and that's all that we have in the q a

00:56:52,400 --> 00:56:57,760
right now okay

00:56:55,200 --> 00:56:58,640
um then i'm gonna i'm going to wrap up

00:56:57,760 --> 00:57:01,440
here

00:56:58,640 --> 00:57:02,240
um because i'm a little bit early i may

00:57:01,440 --> 00:57:04,400
have some time

00:57:02,240 --> 00:57:05,520
to spend at a table if any anybody wants

00:57:04,400 --> 00:57:07,040
to reach me

00:57:05,520 --> 00:57:08,960
otherwise i'm going to be over in the

00:57:07,040 --> 00:57:12,079
the jetbrains room

00:57:08,960 --> 00:57:13,599
in about um 15 minutes or so for

00:57:12,079 --> 00:57:15,680
for a demo there you can always catch me

00:57:13,599 --> 00:57:17,520
there or maybe tomorrow

00:57:15,680 --> 00:57:27,839
at the conference thank you very much

00:57:17,520 --> 00:57:27,839
for listening

00:57:38,640 --> 00:57:40,720

YouTube URL: https://www.youtube.com/watch?v=pH-q2m5sb04


