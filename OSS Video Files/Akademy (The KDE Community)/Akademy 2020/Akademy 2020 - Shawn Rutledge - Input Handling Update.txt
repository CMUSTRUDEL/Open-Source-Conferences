Title: Akademy 2020 - Shawn Rutledge - Input Handling Update
Publication date: 2020-11-24
Playlist: Akademy 2020
Description: 
	We have several goals for input events in Qt 6; the main one of course is to fix a lot of open Qt Quick bugs that have been intractable because of bad architecture in Qt 5.

Shawn will talk about the API changes in QInputEvent and its subclasses, what it means for Qt Quick, and do a demo of some new features that the new event delivery architecture enables.

More details about the goals in Qt 6:

- every QInputEvent should carry a pointer to an object representing the device it came from, with more details than we had before, to enable the recipients to handle it intelligently
- Qt Quick items (and especially Input Handlers) should mostly keep working as they already do
- Widgets will keep working as they already do
- QPointerEvent will be introduced, with common API for mouse, touch and tablet events; that will hopefully enable more unified delivery code rather than duplicated code for different event types, and also less reliance on mouse emulation
- Qt Quick can go back to delivering the original QPointerEvents rather than wrapping them
- we can perhaps finally make Flickable touch-aware: because the event doesn't look that different from a mouse event anymore, we shouldn't have to duplicate much code to get Flickable to do all its filtering, delaying and replaying with touch events just as with mouse events
- Wacom tablets and other pressure-sensitive stylus devices will be much better supported in Qt Quick
- we hope to be in a position that we can begin to support multi-seat (multi-user) UIs
Captions: 
	00:00:01,130 --> 00:00:08,600
[Music]

00:00:10,480 --> 00:00:14,160
okay you can see my screen now right

00:00:14,320 --> 00:00:18,640
so yeah this is the input handling

00:00:16,400 --> 00:00:20,240
update well i'm going to talk about um

00:00:18,640 --> 00:00:22,480
some things that will be coming up in

00:00:20,240 --> 00:00:25,199
qt6

00:00:22,480 --> 00:00:26,960
um you have the yeah my handle on irc is

00:00:25,199 --> 00:00:28,400
ecloud and i hang out on those couple of

00:00:26,960 --> 00:00:29,760
channels sometimes although we're not

00:00:28,400 --> 00:00:30,320
using it as much in the cute company

00:00:29,760 --> 00:00:32,480
anymore

00:00:30,320 --> 00:00:33,440
because they switched to microsoft teams

00:00:32,480 --> 00:00:36,800
of all things so

00:00:33,440 --> 00:00:38,559
i'm not an irc as much as i used to be

00:00:36,800 --> 00:00:40,399
um i've been a cute application

00:00:38,559 --> 00:00:43,520
developer since about 2004

00:00:40,399 --> 00:00:45,600
joined the cute company in oslo in 2011

00:00:43,520 --> 00:00:46,559
and since then i've been i knew just

00:00:45,600 --> 00:00:48,239
right away that there were

00:00:46,559 --> 00:00:50,800
some problems with our support for touch

00:00:48,239 --> 00:00:52,320
screens and wacom tablets and so i've

00:00:50,800 --> 00:00:54,559
been kind of focused on that

00:00:52,320 --> 00:00:55,840
um over the years but also quite a few

00:00:54,559 --> 00:00:58,160
other things

00:00:55,840 --> 00:01:00,079
worked on linux and mac os and cute pdf

00:00:58,160 --> 00:01:00,800
and a bunch of cute quick stuff and now

00:01:00,079 --> 00:01:03,840
i'm one of the

00:01:00,800 --> 00:01:03,840
cute quick maintainers

00:01:04,479 --> 00:01:08,560
so the goals for the um the agenda for

00:01:07,200 --> 00:01:10,400
this session i'm going to talk about the

00:01:08,560 --> 00:01:13,760
goals what we wanted to change about

00:01:10,400 --> 00:01:16,479
input handling in q6 and

00:01:13,760 --> 00:01:19,920
the api changes that um seem to be

00:01:16,479 --> 00:01:22,479
necessary to make that possible

00:01:19,920 --> 00:01:24,840
and um how it relates to qt quick and

00:01:22,479 --> 00:01:28,000
then there will be a kind of a demo

00:01:24,840 --> 00:01:30,560
although nothing yeah well you'll see

00:01:28,000 --> 00:01:31,840
and then um some remaining work and i

00:01:30,560 --> 00:01:35,200
don't know if we have time for questions

00:01:31,840 --> 00:01:39,439
at the end it depends how fast i go

00:01:35,200 --> 00:01:42,479
so the goals um q

00:01:39,439 --> 00:01:45,200
a q mouse event had a mouse event source

00:01:42,479 --> 00:01:46,560
which we added in q 5.4 and we thought

00:01:45,200 --> 00:01:49,439
that that would help us um

00:01:46,560 --> 00:01:50,640
figure out the cases when a mouse event

00:01:49,439 --> 00:01:52,000
is synthesized from touch

00:01:50,640 --> 00:01:54,079
you should be able to find out somehow

00:01:52,000 --> 00:01:55,280
that that's what it is right when you're

00:01:54,079 --> 00:01:56,799
handling the event

00:01:55,280 --> 00:01:58,560
but it turned out that that's not really

00:01:56,799 --> 00:02:01,360
enough

00:01:58,560 --> 00:02:02,399
so in q6 i wanted to have a whole device

00:02:01,360 --> 00:02:04,320
hierarchy

00:02:02,399 --> 00:02:06,079
and every input event should have the

00:02:04,320 --> 00:02:07,600
device that it came from

00:02:06,079 --> 00:02:09,119
so you'll be able to get all the all the

00:02:07,600 --> 00:02:09,360
possible information about the device

00:02:09,119 --> 00:02:10,879
and

00:02:09,360 --> 00:02:12,080
so you can tell if a mouse event really

00:02:10,879 --> 00:02:14,319
comes from a touchscreen you can see

00:02:12,080 --> 00:02:16,800
which touchscreen it is

00:02:14,319 --> 00:02:18,480
um we want to keep widgets and quick

00:02:16,800 --> 00:02:20,319
stuff working the same as it did before

00:02:18,480 --> 00:02:23,120
as much as possible

00:02:20,319 --> 00:02:24,879
we want to have the ability to write

00:02:23,120 --> 00:02:28,160
common event delivery code for

00:02:24,879 --> 00:02:29,200
all the pointer events in qt quick and

00:02:28,160 --> 00:02:31,680
probably we're not going to change

00:02:29,200 --> 00:02:34,080
widgets but we could if we wanted to so

00:02:31,680 --> 00:02:35,519
we want to have the ability to write

00:02:34,080 --> 00:02:36,879
agnostic delivery code

00:02:35,519 --> 00:02:38,319
that it doesn't really care whether it's

00:02:36,879 --> 00:02:40,000
mouse or touch it knows what to do with

00:02:38,319 --> 00:02:42,400
it

00:02:40,000 --> 00:02:43,440
yeah we had prototyped that in qt quick

00:02:42,400 --> 00:02:44,959
in q5

00:02:43,440 --> 00:02:46,640
by writing wrapper classes for the

00:02:44,959 --> 00:02:48,000
events so we should be able to get rid

00:02:46,640 --> 00:02:48,640
of those now because we'll make the

00:02:48,000 --> 00:02:51,440
events just

00:02:48,640 --> 00:02:53,280
look just like them um there's always

00:02:51,440 --> 00:02:55,440
been some problems with flicka ball

00:02:53,280 --> 00:02:57,040
in cute quick it didn't really handle

00:02:55,440 --> 00:02:57,920
touch directly it only handles mouse

00:02:57,040 --> 00:03:00,400
events

00:02:57,920 --> 00:03:02,159
and so that means if you have set the

00:03:00,400 --> 00:03:04,159
press delay on a flickable

00:03:02,159 --> 00:03:05,599
and then you want to have it do a replay

00:03:04,159 --> 00:03:06,879
later on it's always going to replay a

00:03:05,599 --> 00:03:08,640
mouse event because it never got the

00:03:06,879 --> 00:03:09,519
touch event it got a synthesized mouse

00:03:08,640 --> 00:03:11,280
event

00:03:09,519 --> 00:03:12,640
so that's kind of silly we need to fix

00:03:11,280 --> 00:03:15,599
that

00:03:12,640 --> 00:03:17,120
um we want the event objects to be as

00:03:15,599 --> 00:03:19,840
lightweight as possible like they always

00:03:17,120 --> 00:03:21,519
have been or even lighter

00:03:19,840 --> 00:03:23,519
and there's other bugs besides flickable

00:03:21,519 --> 00:03:24,959
that we hope will be easier to fix after

00:03:23,519 --> 00:03:26,640
this stuff is done

00:03:24,959 --> 00:03:28,319
like i say i always try to try to make

00:03:26,640 --> 00:03:29,040
the welcome tablet support a little bit

00:03:28,319 --> 00:03:30,400
better but

00:03:29,040 --> 00:03:32,480
the main thing that's left is the

00:03:30,400 --> 00:03:34,080
proximity events when you hold the

00:03:32,480 --> 00:03:35,519
stylus close to the tablet but you're

00:03:34,080 --> 00:03:37,120
not touching yet

00:03:35,519 --> 00:03:38,319
those need to be delivered fully and

00:03:37,120 --> 00:03:40,159
they're not yet they're just delivered

00:03:38,319 --> 00:03:42,959
to the application not to the window

00:03:40,159 --> 00:03:44,400
so we'll try to fix that and maybe we'll

00:03:42,959 --> 00:03:45,360
try to work towards having multi-seat

00:03:44,400 --> 00:03:46,640
support eventually

00:03:45,360 --> 00:03:49,200
that's not going to be something that's

00:03:46,640 --> 00:03:50,720
going to make q60 but we'll try to

00:03:49,200 --> 00:03:52,400
remove the obstacles

00:03:50,720 --> 00:03:53,920
so that as much as possible so that

00:03:52,400 --> 00:03:56,239
maybe we can get there eventually in the

00:03:53,920 --> 00:03:58,959
six series

00:03:56,239 --> 00:04:00,560
by which i mean wayland support you can

00:03:58,959 --> 00:04:01,519
have multiple users with multiple

00:04:00,560 --> 00:04:02,959
keyboards and mice

00:04:01,519 --> 00:04:06,080
working at the same time and stuff like

00:04:02,959 --> 00:04:07,840
that and also on x11

00:04:06,080 --> 00:04:11,040
so the initial conditions where we were

00:04:07,840 --> 00:04:13,280
with cute quick and q5

00:04:11,040 --> 00:04:15,280
the we have these wrapper objects so q

00:04:13,280 --> 00:04:16,320
quick pointer event is a cue object

00:04:15,280 --> 00:04:18,479
wrapper for

00:04:16,320 --> 00:04:19,919
touch event mouse event and so forth

00:04:18,479 --> 00:04:22,320
because we wanted to have the

00:04:19,919 --> 00:04:24,240
newer api and prototype how that was

00:04:22,320 --> 00:04:26,000
going to work

00:04:24,240 --> 00:04:27,680
quick event point is a wrapper for the

00:04:26,000 --> 00:04:29,280
qtouch event touch point

00:04:27,680 --> 00:04:31,280
but every single point event like a

00:04:29,280 --> 00:04:32,639
mouse event has one point as well

00:04:31,280 --> 00:04:34,560
so you can always get a point and you

00:04:32,639 --> 00:04:37,040
can always see what the um

00:04:34,560 --> 00:04:38,639
position is and so forth from that and

00:04:37,040 --> 00:04:40,400
then we have q quick event point because

00:04:38,639 --> 00:04:42,320
it's a long lift object

00:04:40,400 --> 00:04:43,600
a queue object it can actually store

00:04:42,320 --> 00:04:45,280
state in between events

00:04:43,600 --> 00:04:47,280
like if you set the grabber you're

00:04:45,280 --> 00:04:49,440
actually grabbing a point

00:04:47,280 --> 00:04:51,040
because touch of course touch events are

00:04:49,440 --> 00:04:52,720
split up and delivered according to

00:04:51,040 --> 00:04:54,880
where they're touching so

00:04:52,720 --> 00:04:56,000
if a couple of your fingers are touching

00:04:54,880 --> 00:04:57,360
one item then

00:04:56,000 --> 00:04:59,520
that item is going to get a special

00:04:57,360 --> 00:05:01,600
event that has just those points

00:04:59,520 --> 00:05:03,360
so when it grabs it grabs just those two

00:05:01,600 --> 00:05:05,759
points if that's what it wants to do

00:05:03,360 --> 00:05:07,440
and so the q quick event point will

00:05:05,759 --> 00:05:09,039
store the state because it continues to

00:05:07,440 --> 00:05:10,560
live on even after that one event is

00:05:09,039 --> 00:05:11,440
delivered and then the next time an

00:05:10,560 --> 00:05:12,880
event comes

00:05:11,440 --> 00:05:14,240
then we match it up and we see that the

00:05:12,880 --> 00:05:15,759
grabber is still there so we know where

00:05:14,240 --> 00:05:18,479
to deliver it

00:05:15,759 --> 00:05:19,600
uh quick event point has a parent

00:05:18,479 --> 00:05:21,199
pointer so it knows

00:05:19,600 --> 00:05:22,720
the event that it came from which is a

00:05:21,199 --> 00:05:25,680
stable pointer because the

00:05:22,720 --> 00:05:28,080
those event queue objects are also

00:05:25,680 --> 00:05:29,759
persisting between events

00:05:28,080 --> 00:05:31,440
and so we can pass the q quick event

00:05:29,759 --> 00:05:34,320
point all by itself to a function and it

00:05:31,440 --> 00:05:36,560
knows the event that it came from

00:05:34,320 --> 00:05:38,160
this makes our delivery code it's

00:05:36,560 --> 00:05:41,440
possible to make it simpler in quick

00:05:38,160 --> 00:05:43,280
window and we partially did that in q5

00:05:41,440 --> 00:05:46,000
um and the wrappers were meant to

00:05:43,280 --> 00:05:47,520
prototype for q6

00:05:46,000 --> 00:05:49,199
so if you look back at older versions

00:05:47,520 --> 00:05:52,000
this is an old slide as well

00:05:49,199 --> 00:05:52,479
the the problem originally in versions

00:05:52,000 --> 00:05:55,199
of

00:05:52,479 --> 00:05:55,680
early versions of q5 was that touch

00:05:55,199 --> 00:05:57,280
events

00:05:55,680 --> 00:05:58,960
that's the green series of arrows you

00:05:57,280 --> 00:06:00,560
see how the delivery goes

00:05:58,960 --> 00:06:02,160
and then the q mouse event that's the

00:06:00,560 --> 00:06:03,680
orange series of arrows

00:06:02,160 --> 00:06:05,680
and you can see that it visits different

00:06:03,680 --> 00:06:06,400
functions depending on what the type of

00:06:05,680 --> 00:06:09,199
the

00:06:06,400 --> 00:06:10,479
of the event was and then tablet events

00:06:09,199 --> 00:06:12,160
were not being delivered at all they

00:06:10,479 --> 00:06:13,759
they make it to quick window event and

00:06:12,160 --> 00:06:15,440
then they're simply thrown away

00:06:13,759 --> 00:06:17,199
and i wanted to be able to support

00:06:15,440 --> 00:06:19,199
tablet events without having to

00:06:17,199 --> 00:06:20,720
completely write a whole nother set of

00:06:19,199 --> 00:06:22,000
delivery logic

00:06:20,720 --> 00:06:24,560
so that was why we started this

00:06:22,000 --> 00:06:26,479
refactoring

00:06:24,560 --> 00:06:27,759
um and you can see why this became a

00:06:26,479 --> 00:06:30,400
problem and the

00:06:27,759 --> 00:06:32,080
event hierarchy in q5 looks like this so

00:06:30,400 --> 00:06:33,680
the only common base class we have for

00:06:32,080 --> 00:06:35,680
all the stuff is input event and that

00:06:33,680 --> 00:06:38,560
also includes key event

00:06:35,680 --> 00:06:40,479
and then the different event objects

00:06:38,560 --> 00:06:41,199
have similar api but not exactly the

00:06:40,479 --> 00:06:43,919
same like

00:06:41,199 --> 00:06:45,600
pause is pretty much always there but in

00:06:43,919 --> 00:06:47,680
touch point it's a cue point f

00:06:45,600 --> 00:06:48,720
and in mouse event it's cue point and

00:06:47,680 --> 00:06:50,560
you

00:06:48,720 --> 00:06:52,000
that's this isn't polymorphic i mean you

00:06:50,560 --> 00:06:54,080
have to know what the

00:06:52,000 --> 00:06:55,280
what the actual leaf event type is in

00:06:54,080 --> 00:06:56,720
order to handle it

00:06:55,280 --> 00:06:58,800
so you can't just handle all input

00:06:56,720 --> 00:07:02,880
events the same way

00:06:58,800 --> 00:07:06,560
um so in q5

00:07:02,880 --> 00:07:08,240
like greater than 5 8 we made this um

00:07:06,560 --> 00:07:10,400
this new hierarchy of these wrapper

00:07:08,240 --> 00:07:12,400
objects

00:07:10,400 --> 00:07:13,919
so the cons the common interface now is

00:07:12,400 --> 00:07:16,000
that there's point and point count

00:07:13,919 --> 00:07:17,199
we have a pointer event and regardless

00:07:16,000 --> 00:07:19,199
what type of um

00:07:17,199 --> 00:07:20,479
device it came from you can always ask

00:07:19,199 --> 00:07:22,319
how many points there are if it's a

00:07:20,479 --> 00:07:23,759
mouse it's going to say there's one

00:07:22,319 --> 00:07:25,199
if it's touch it can be more than one

00:07:23,759 --> 00:07:27,039
and then you can iterate over the points

00:07:25,199 --> 00:07:29,120
and deal with them somehow

00:07:27,039 --> 00:07:31,199
and we also prototype this device object

00:07:29,120 --> 00:07:33,759
which uh we're going to have in q6 and

00:07:31,199 --> 00:07:33,759
kit gui

00:07:34,080 --> 00:07:39,919
so how did the delivery work in q5

00:07:37,440 --> 00:07:41,919
10 and greater actually but you know

00:07:39,919 --> 00:07:43,520
pointer events were officially supported

00:07:41,919 --> 00:07:46,720
in 511 so that's why i said

00:07:43,520 --> 00:07:49,280
5 11 and greater we start um

00:07:46,720 --> 00:07:50,800
always with a q event loop which gets

00:07:49,280 --> 00:07:51,919
the original event from the operating

00:07:50,800 --> 00:07:54,400
system

00:07:51,919 --> 00:07:56,000
and then that event we send windows

00:07:54,400 --> 00:07:58,319
system events all of them to uh

00:07:56,000 --> 00:07:59,759
cute windows system interface and then

00:07:58,319 --> 00:08:02,160
it does some dispatching

00:07:59,759 --> 00:08:04,720
so it processes a windows system event

00:08:02,160 --> 00:08:08,479
and let's say a mouse event came in

00:08:04,720 --> 00:08:11,680
now your platform plug-in actually

00:08:08,479 --> 00:08:14,879
heap allocated an event

00:08:11,680 --> 00:08:16,240
this um or windows system interface did

00:08:14,879 --> 00:08:17,840
actually this came in from the platform

00:08:16,240 --> 00:08:19,520
plug-in but then

00:08:17,840 --> 00:08:21,120
well anyway there's a heap allocated q

00:08:19,520 --> 00:08:21,919
window system interface private mouse

00:08:21,120 --> 00:08:23,599
event

00:08:21,919 --> 00:08:26,080
and that's because it can potentially be

00:08:23,599 --> 00:08:29,039
put onto an event queue

00:08:26,080 --> 00:08:30,639
so we process that and notify and and

00:08:29,039 --> 00:08:32,159
then um

00:08:30,639 --> 00:08:33,839
in this process mouse event this is

00:08:32,159 --> 00:08:35,839
where we create the original q mouse

00:08:33,839 --> 00:08:37,279
event and that was stack allocated

00:08:35,839 --> 00:08:39,760
because it stays in the same thread

00:08:37,279 --> 00:08:42,000
after that it goes to the

00:08:39,760 --> 00:08:43,760
in this case uh the event function of

00:08:42,000 --> 00:08:45,920
the quick window

00:08:43,760 --> 00:08:47,200
and then we do dispatching there and so

00:08:45,920 --> 00:08:48,080
we find out that it's a mouse press

00:08:47,200 --> 00:08:50,480
event

00:08:48,080 --> 00:08:52,000
and then we start to make a pointer

00:08:50,480 --> 00:08:53,839
event out of that this is where the

00:08:52,000 --> 00:08:55,600
wrapper comes into play so we call

00:08:53,839 --> 00:08:57,200
pointer event instance

00:08:55,600 --> 00:08:59,040
which we'll then call query pointer

00:08:57,200 --> 00:08:59,760
event instance which will then try to

00:08:59,040 --> 00:09:01,360
find

00:08:59,760 --> 00:09:03,360
do we have an existing queue object

00:09:01,360 --> 00:09:05,600
wrapper that's suitable for this event

00:09:03,360 --> 00:09:06,959
usually it finds one and then it calls

00:09:05,600 --> 00:09:09,920
the reset function

00:09:06,959 --> 00:09:10,320
to initialize this object to handle a

00:09:09,920 --> 00:09:13,120
new

00:09:10,320 --> 00:09:15,440
event that just came in and then that

00:09:13,120 --> 00:09:16,000
has to initialize a pointer mouse event

00:09:15,440 --> 00:09:19,040
as well

00:09:16,000 --> 00:09:20,800
that's the no i wanted to say it has to

00:09:19,040 --> 00:09:21,440
initialize the cue quick given point as

00:09:20,800 --> 00:09:24,080
well

00:09:21,440 --> 00:09:25,440
which is the individual point that is

00:09:24,080 --> 00:09:27,040
inside the event

00:09:25,440 --> 00:09:28,880
and at that point this event has become

00:09:27,040 --> 00:09:31,120
a wrapper and now we can start pointer

00:09:28,880 --> 00:09:33,200
event delivery in qt quick

00:09:31,120 --> 00:09:35,279
so then we deliver the pointer event and

00:09:33,200 --> 00:09:36,800
we presses and releases are special

00:09:35,279 --> 00:09:38,399
because that's the case where we have to

00:09:36,800 --> 00:09:41,519
actually go and find the item

00:09:38,399 --> 00:09:43,760
that it needs to be delivered to

00:09:41,519 --> 00:09:45,519
so we call this pointer targets function

00:09:43,760 --> 00:09:46,720
which is a recursive function that

00:09:45,519 --> 00:09:48,560
generates a vector

00:09:46,720 --> 00:09:51,120
of all the items that are underneath the

00:09:48,560 --> 00:09:52,720
point because in in a particular order

00:09:51,120 --> 00:09:54,240
the top-down order because that's the

00:09:52,720 --> 00:09:57,839
order that we're going to visit them

00:09:54,240 --> 00:10:00,880
so we want that list to be stable

00:09:57,839 --> 00:10:03,519
so we generate it up front and

00:10:00,880 --> 00:10:04,240
then for each of those items we go

00:10:03,519 --> 00:10:06,240
through and ask

00:10:04,240 --> 00:10:07,920
uh are there any handlers inside this

00:10:06,240 --> 00:10:09,760
item that want the event

00:10:07,920 --> 00:10:11,440
and so then the item in turn iterates

00:10:09,760 --> 00:10:12,399
all of the handlers handlers that are

00:10:11,440 --> 00:10:14,399
inside the item

00:10:12,399 --> 00:10:15,760
that are children of the item and asks

00:10:14,399 --> 00:10:17,040
each of those do you want this event

00:10:15,760 --> 00:10:19,600
point

00:10:17,040 --> 00:10:21,519
so let's say it says yes in this example

00:10:19,600 --> 00:10:22,320
it's a drag handler we're doing a drag

00:10:21,519 --> 00:10:25,920
here

00:10:22,320 --> 00:10:27,680
so it says yes i want it the press

00:10:25,920 --> 00:10:29,200
so then we called then it goes back and

00:10:27,680 --> 00:10:30,000
calls deliver matching points to item

00:10:29,200 --> 00:10:32,880
and that calls

00:10:30,000 --> 00:10:34,160
handle pointer event on the item private

00:10:32,880 --> 00:10:36,000
and then that will

00:10:34,160 --> 00:10:37,760
in turn dispatch to all of the handlers

00:10:36,000 --> 00:10:38,560
so we get back to our drag handler again

00:10:37,760 --> 00:10:40,720
and then it asks

00:10:38,560 --> 00:10:41,600
again do you want this pointer event so

00:10:40,720 --> 00:10:43,360
it says yes

00:10:41,600 --> 00:10:46,000
so then we call handle pointer event

00:10:43,360 --> 00:10:49,200
impul which is the implementation

00:10:46,000 --> 00:10:50,880
and that will realize that since you're

00:10:49,200 --> 00:10:52,399
if it wants to find out that a drag is

00:10:50,880 --> 00:10:53,040
happening then it needs to become a

00:10:52,399 --> 00:10:54,720
grabber

00:10:53,040 --> 00:10:56,079
this is simplifying a little bit because

00:10:54,720 --> 00:10:57,279
actually it becomes a passive grabber

00:10:56,079 --> 00:10:58,880
first and then it becomes

00:10:57,279 --> 00:11:00,480
but let's just say it becomes exclusive

00:10:58,880 --> 00:11:03,200
grabber right away

00:11:00,480 --> 00:11:04,160
so it will call set grabber passing

00:11:03,200 --> 00:11:05,760
itself

00:11:04,160 --> 00:11:07,440
as the the drag handler becomes the

00:11:05,760 --> 00:11:09,360
grabber and then

00:11:07,440 --> 00:11:10,640
because it knows that this event doesn't

00:11:09,360 --> 00:11:12,560
need to go anywhere else it will call

00:11:10,640 --> 00:11:13,360
said accepted on the point which means

00:11:12,560 --> 00:11:15,839
that we're done

00:11:13,360 --> 00:11:15,839
doing delivery

00:11:17,360 --> 00:11:21,839
so now in q6 we have an event hierarchy

00:11:20,240 --> 00:11:25,120
that looks a lot like the q

00:11:21,839 --> 00:11:25,519
quick event hierarchy in q5 so you have

00:11:25,120 --> 00:11:28,000
q

00:11:25,519 --> 00:11:30,240
event q input event then we have a new

00:11:28,000 --> 00:11:32,240
class here cube pointer event

00:11:30,240 --> 00:11:33,600
which has this familiar interface you

00:11:32,240 --> 00:11:36,560
can ask how many points there are

00:11:33,600 --> 00:11:38,480
and you can get an individual point and

00:11:36,560 --> 00:11:41,279
i also added this points

00:11:38,480 --> 00:11:42,320
which returns a cue list by reference

00:11:41,279 --> 00:11:43,440
because that's how we're actually

00:11:42,320 --> 00:11:45,120
storing them

00:11:43,440 --> 00:11:46,959
so if you want to write in based for

00:11:45,120 --> 00:11:49,200
loops then you can use the old

00:11:46,959 --> 00:11:50,720
two functions point and point count if

00:11:49,200 --> 00:11:51,760
you want to write the range for loop you

00:11:50,720 --> 00:11:54,800
can use this one

00:11:51,760 --> 00:11:56,480
but um this one is const

00:11:54,800 --> 00:11:58,800
so the trouble is if you have an event

00:11:56,480 --> 00:12:01,440
point in a range for loop

00:11:58,800 --> 00:12:02,399
then you can't necessarily call said

00:12:01,440 --> 00:12:03,600
accepted on that

00:12:02,399 --> 00:12:05,680
so we've been trying to figure out what

00:12:03,600 --> 00:12:07,440
to do about that

00:12:05,680 --> 00:12:10,240
but anyway the pointer event has a

00:12:07,440 --> 00:12:12,720
pointing device which is this um

00:12:10,240 --> 00:12:14,639
well input event has a device which is

00:12:12,720 --> 00:12:16,240
the input device and then this pointing

00:12:14,639 --> 00:12:17,839
device is just a convenience method that

00:12:16,240 --> 00:12:18,959
will do the casting for you to convert

00:12:17,839 --> 00:12:21,440
it to a cue pointing

00:12:18,959 --> 00:12:23,200
device which is what it actually is so

00:12:21,440 --> 00:12:25,839
the q input device

00:12:23,200 --> 00:12:26,880
has um has a seat name now for one thing

00:12:25,839 --> 00:12:29,279
so that will

00:12:26,880 --> 00:12:30,639
be how you distinguish them we're not

00:12:29,279 --> 00:12:32,720
really sure if we need to do anything

00:12:30,639 --> 00:12:34,639
more formal than that to handle seats

00:12:32,720 --> 00:12:35,920
on weyland but that seems like a good

00:12:34,639 --> 00:12:38,160
place to start to just say that the

00:12:35,920 --> 00:12:40,240
input device has a seat name and so

00:12:38,160 --> 00:12:41,600
if your application actually cares about

00:12:40,240 --> 00:12:43,200
working with multiple seats then it's

00:12:41,600 --> 00:12:44,480
kind of up to you to just

00:12:43,200 --> 00:12:46,160
realize that the seat names are going to

00:12:44,480 --> 00:12:49,040
be different on different devices and

00:12:46,160 --> 00:12:49,040
handle them differently

00:12:49,839 --> 00:12:53,760
you can get a list of all the known

00:12:51,120 --> 00:12:56,560
input devices and those get there

00:12:53,760 --> 00:12:58,160
because the platform plug-in is calling

00:12:56,560 --> 00:13:00,240
this register input device

00:12:58,160 --> 00:13:01,519
on q windows system interface and this

00:13:00,240 --> 00:13:03,279
is something we're not done with yet

00:13:01,519 --> 00:13:04,880
that all of the platform plugins need to

00:13:03,279 --> 00:13:07,600
be able to discover the

00:13:04,880 --> 00:13:07,920
connected devices and register them all

00:13:07,600 --> 00:13:09,040
and

00:13:07,920 --> 00:13:10,560
and i thought that that was going to be

00:13:09,040 --> 00:13:12,320
possible but it actually turns out on

00:13:10,560 --> 00:13:13,839
some operat some operating systems it's

00:13:12,320 --> 00:13:15,200
easier than others i mean i started with

00:13:13,839 --> 00:13:16,720
x11 so

00:13:15,200 --> 00:13:18,560
there's a lot of details available there

00:13:16,720 --> 00:13:20,800
and on on weyland it works pretty well

00:13:18,560 --> 00:13:23,760
too but then it turns out on mac os

00:13:20,800 --> 00:13:24,399
yeah not so much they pretty much um you

00:13:23,760 --> 00:13:25,519
won't know

00:13:24,399 --> 00:13:26,800
you won't know that there's a device

00:13:25,519 --> 00:13:28,160
there until you get an event from it

00:13:26,800 --> 00:13:28,480
that's the trouble and even then there's

00:13:28,160 --> 00:13:30,720
not

00:13:28,480 --> 00:13:32,240
much details about the the device it

00:13:30,720 --> 00:13:34,000
won't tell you whether

00:13:32,240 --> 00:13:35,760
is this the track bed the track pad

00:13:34,000 --> 00:13:38,160
built into my macbook pro or is it a

00:13:35,760 --> 00:13:39,920
bluetooth connected trackpad or is it

00:13:38,160 --> 00:13:41,760
something else a magic mouse i don't

00:13:39,920 --> 00:13:44,000
really know um but

00:13:41,760 --> 00:13:45,920
it'd be nice if we can find the native

00:13:44,000 --> 00:13:48,240
apis to register those devices then we

00:13:45,920 --> 00:13:50,079
should do that

00:13:48,240 --> 00:13:51,440
um and so there's a fallback mechanism

00:13:50,079 --> 00:13:53,519
if the device hasn't been registered

00:13:51,440 --> 00:13:55,519
then it will just create one at runtime

00:13:53,519 --> 00:13:57,600
even if there's no devices known you'll

00:13:55,519 --> 00:13:59,760
get a default one

00:13:57,600 --> 00:14:00,880
so you can get a list of devices and

00:13:59,760 --> 00:14:03,279
that's nice for

00:14:00,880 --> 00:14:04,880
tools like cute diag for example we've

00:14:03,279 --> 00:14:07,040
already updated to just list all the

00:14:04,880 --> 00:14:08,240
devices on your system

00:14:07,040 --> 00:14:09,920
and then if you don't if you're

00:14:08,240 --> 00:14:10,399
delivering a keyboard even for example

00:14:09,920 --> 00:14:11,360
and

00:14:10,399 --> 00:14:13,199
you don't know where it came from

00:14:11,360 --> 00:14:14,720
there's this primary keyboard accessor

00:14:13,199 --> 00:14:16,800
which will figure that out for you

00:14:14,720 --> 00:14:18,639
and guarantees to give you back an input

00:14:16,800 --> 00:14:20,480
device and likewise there's

00:14:18,639 --> 00:14:21,920
one for primary pointing device which on

00:14:20,480 --> 00:14:24,240
both systems is going to return you a

00:14:21,920 --> 00:14:24,240
mouse

00:14:24,560 --> 00:14:30,320
um okay so we have pointer event

00:14:27,680 --> 00:14:32,079
with this common interface and then

00:14:30,320 --> 00:14:35,199
about setting grabbers

00:14:32,079 --> 00:14:35,839
um those were in the q event point

00:14:35,199 --> 00:14:38,639
before

00:14:35,839 --> 00:14:41,519
because you're grabbing a point right

00:14:38,639 --> 00:14:43,440
but because of this problem that um

00:14:41,519 --> 00:14:45,040
now we cannot an even point cannot

00:14:43,440 --> 00:14:46,160
necessarily have a pointer back to its

00:14:45,040 --> 00:14:47,440
pointer event

00:14:46,160 --> 00:14:50,079
which we'll talk about in a minute about

00:14:47,440 --> 00:14:52,240
the memory allocation and so

00:14:50,079 --> 00:14:53,519
we basically move those functions up to

00:14:52,240 --> 00:14:56,240
to cue pointer event

00:14:53,519 --> 00:14:57,360
so when you receive an event then you'll

00:14:56,240 --> 00:14:59,120
be able to um

00:14:57,360 --> 00:15:00,639
take the exclusive grab by calling said

00:14:59,120 --> 00:15:02,720
exclusive crabber

00:15:00,639 --> 00:15:04,160
or take a passive grab by calling add

00:15:02,720 --> 00:15:05,760
passive grabber and you have to pass in

00:15:04,160 --> 00:15:07,440
the point instance that you want to grab

00:15:05,760 --> 00:15:09,600
and the object that is becoming the

00:15:07,440 --> 00:15:11,199
grabber

00:15:09,600 --> 00:15:12,800
so then for subclasses we have single

00:15:11,199 --> 00:15:14,720
point event which is

00:15:12,800 --> 00:15:15,920
most of them like mouse event only has

00:15:14,720 --> 00:15:18,560
one point

00:15:15,920 --> 00:15:20,800
and then we have touch event and it has

00:15:18,560 --> 00:15:22,720
this legacy access or touch points

00:15:20,800 --> 00:15:23,920
which is exactly the same as the points

00:15:22,720 --> 00:15:25,360
accessor so we just went ahead and

00:15:23,920 --> 00:15:26,959
deprecated that

00:15:25,360 --> 00:15:28,399
because now you can be agnostic you get

00:15:26,959 --> 00:15:29,839
a pointer event you can always handle

00:15:28,399 --> 00:15:31,839
multiple points it just might turn out

00:15:29,839 --> 00:15:36,160
that there's only one

00:15:31,839 --> 00:15:38,800
um and then we had a bit of debate about

00:15:36,160 --> 00:15:41,120
whether to have d pointer or not in the

00:15:38,800 --> 00:15:43,279
event point i didn't really want to but

00:15:41,120 --> 00:15:45,600
lars thinks that we should because

00:15:43,279 --> 00:15:47,680
that way uh that way we'll be free to

00:15:45,600 --> 00:15:50,880
change it the usual reason right so

00:15:47,680 --> 00:15:50,880
we'll get into that in a minute

00:15:51,040 --> 00:15:55,199
so the delivery to handlers and cute

00:15:53,519 --> 00:15:56,800
looks like this now

00:15:55,199 --> 00:15:58,480
we're still starting with our send

00:15:56,800 --> 00:15:59,600
window system events process windows

00:15:58,480 --> 00:16:01,199
system event and we

00:15:59,600 --> 00:16:03,199
have this heap allocated mouse event

00:16:01,199 --> 00:16:05,680
coming in and now

00:16:03,199 --> 00:16:08,079
we ask the pointing device for the

00:16:05,680 --> 00:16:10,880
active point with id0

00:16:08,079 --> 00:16:11,199
and it returns that so that's because

00:16:10,880 --> 00:16:14,000
the

00:16:11,199 --> 00:16:15,440
the pointing device has uh this event

00:16:14,000 --> 00:16:17,120
point data object

00:16:15,440 --> 00:16:18,639
which then has an event point and this

00:16:17,120 --> 00:16:20,160
is the place where we're storing the

00:16:18,639 --> 00:16:22,079
persistent event point now where it's

00:16:20,160 --> 00:16:23,519
going to remember the grabbers

00:16:22,079 --> 00:16:25,600
except for the sake of making the

00:16:23,519 --> 00:16:27,360
endpoint lighter we move the grabbers

00:16:25,600 --> 00:16:29,519
out so we have this even point data

00:16:27,360 --> 00:16:31,360
holding a list of passive grabbers and

00:16:29,519 --> 00:16:35,440
the one exclusive grabber

00:16:31,360 --> 00:16:35,440
and we just keep these instances around

00:16:35,680 --> 00:16:39,920
so first it will ask for the active

00:16:38,560 --> 00:16:42,639
point it gets the back

00:16:39,920 --> 00:16:46,399
and then it's ready to go to construct a

00:16:42,639 --> 00:16:46,399
mouse event with that active point

00:16:46,800 --> 00:16:52,079
which in turn makes um the point inside

00:16:49,519 --> 00:16:55,120
the mouse event because it has one

00:16:52,079 --> 00:16:57,279
and then we update this isn't really

00:16:55,120 --> 00:16:58,639
correct anymore at some point there was

00:16:57,279 --> 00:17:00,000
an update from but but now that we're

00:16:58,639 --> 00:17:00,720
actually just caught we're just taking

00:17:00,000 --> 00:17:01,920
the

00:17:00,720 --> 00:17:03,279
the point that we already got and

00:17:01,920 --> 00:17:04,319
putting it in the mouse event that's not

00:17:03,279 --> 00:17:06,000
necessary

00:17:04,319 --> 00:17:07,520
so now we start our pointer event

00:17:06,000 --> 00:17:08,559
delivery a little bit earlier we have

00:17:07,520 --> 00:17:10,400
the cue pointer event

00:17:08,559 --> 00:17:11,679
all the way in gui layer instead of just

00:17:10,400 --> 00:17:13,439
enqueued quick

00:17:11,679 --> 00:17:14,959
so we call process mouse event you see

00:17:13,439 --> 00:17:16,559
it as a q mouse event but it's really a

00:17:14,959 --> 00:17:19,199
cue pointer event

00:17:16,559 --> 00:17:20,880
and then um we call event on q quick

00:17:19,199 --> 00:17:22,720
window

00:17:20,880 --> 00:17:24,240
so it gets a mouse press event and does

00:17:22,720 --> 00:17:26,799
the usual stuff so it gets the

00:17:24,240 --> 00:17:28,000
list of targets checks about handlers

00:17:26,799 --> 00:17:31,120
wanting them

00:17:28,000 --> 00:17:33,280
and then um

00:17:31,120 --> 00:17:34,720
when the handler wants to become the

00:17:33,280 --> 00:17:35,120
exclusive grabber it's going to actually

00:17:34,720 --> 00:17:37,280
call

00:17:35,120 --> 00:17:39,440
on the on the mouse event itself to ask

00:17:37,280 --> 00:17:41,039
for this point to become a grabber

00:17:39,440 --> 00:17:42,640
and at that point those events can be

00:17:41,039 --> 00:17:45,520
thrown away

00:17:42,640 --> 00:17:46,559
but the points remain because we're

00:17:45,520 --> 00:17:49,919
actually doing

00:17:46,559 --> 00:17:49,919
um reference counting

00:17:50,160 --> 00:17:56,000
so i'll get to that in a minute um

00:17:54,000 --> 00:17:57,679
so initial conditions in cute gui i

00:17:56,000 --> 00:17:59,360
think i mostly explained this already

00:17:57,679 --> 00:18:01,360
this is the cute five state of affairs

00:17:59,360 --> 00:18:02,640
that the touchpoint was heap allocated

00:18:01,360 --> 00:18:04,000
and has a pimple in spite of being

00:18:02,640 --> 00:18:05,200
temporary and i thought well that's

00:18:04,000 --> 00:18:07,440
awfully heavyweight

00:18:05,200 --> 00:18:09,600
for something that's being created and

00:18:07,440 --> 00:18:12,960
thrown away in such a short time

00:18:09,600 --> 00:18:15,919
uh qpa events and touch points are

00:18:12,960 --> 00:18:18,160
yeah duplicate classes but they have

00:18:15,919 --> 00:18:21,679
similar api but it's not close enough

00:18:18,160 --> 00:18:23,360
the qpa events are being heap allocated

00:18:21,679 --> 00:18:24,720
in spite of being temporary i wish we

00:18:23,360 --> 00:18:26,640
could change that but it seems like we

00:18:24,720 --> 00:18:28,080
can't because of the queuing

00:18:26,640 --> 00:18:30,799
and because it's because of it because

00:18:28,080 --> 00:18:32,640
it's crossing threads

00:18:30,799 --> 00:18:34,480
on the other hand the q input events are

00:18:32,640 --> 00:18:36,240
stack allocated in q gui application and

00:18:34,480 --> 00:18:38,400
they go out of scope after delivery so

00:18:36,240 --> 00:18:41,440
that's nice and efficient

00:18:38,400 --> 00:18:43,440
um q input event subclasses have

00:18:41,440 --> 00:18:44,720
duplicated a bit incompatible api like

00:18:43,440 --> 00:18:47,440
mouse event looks like

00:18:44,720 --> 00:18:48,799
touch event kind of but not really and

00:18:47,440 --> 00:18:51,840
the touch event was the only one that

00:18:48,799 --> 00:18:51,840
could have multiple points

00:18:52,080 --> 00:18:56,000
so design decisions this is kind of a

00:18:54,640 --> 00:18:57,919
decision tree that we've been through

00:18:56,000 --> 00:19:00,240
so far so starting from the initial

00:18:57,919 --> 00:19:01,679
conditions on the previous slide

00:19:00,240 --> 00:19:02,960
we knew that we wanted to introduce cue

00:19:01,679 --> 00:19:04,320
pointer event because we did this

00:19:02,960 --> 00:19:05,600
prototype in quick and that worked

00:19:04,320 --> 00:19:08,080
really well

00:19:05,600 --> 00:19:09,760
and we knew that every pointer event

00:19:08,080 --> 00:19:11,039
should have the multi-point api

00:19:09,760 --> 00:19:13,039
even though sometimes there's only one

00:19:11,039 --> 00:19:13,360
point because if we didn't do that then

00:19:13,039 --> 00:19:15,200
we

00:19:13,360 --> 00:19:16,720
we wouldn't be able to use this nice

00:19:15,200 --> 00:19:17,120
unified delivery logic we'd have to

00:19:16,720 --> 00:19:19,280
write

00:19:17,120 --> 00:19:20,799
different logic for each type of event

00:19:19,280 --> 00:19:22,799
and you know i don't want to do that so

00:19:20,799 --> 00:19:25,039
then we'd have to keep the wrappers

00:19:22,799 --> 00:19:26,240
and we want to get rid of those so then

00:19:25,039 --> 00:19:29,919
the next question is

00:19:26,240 --> 00:19:31,679
um where should we put the storage

00:19:29,919 --> 00:19:33,440
single point event and touch event

00:19:31,679 --> 00:19:35,200
originally had virtual

00:19:33,440 --> 00:19:37,120
functions for the point count and the

00:19:35,200 --> 00:19:38,640
point accessor and so that

00:19:37,120 --> 00:19:40,000
is nice because the single point event

00:19:38,640 --> 00:19:41,520
could be smaller because it only needs

00:19:40,000 --> 00:19:42,000
to store one point whereas the touch

00:19:41,520 --> 00:19:43,919
event

00:19:42,000 --> 00:19:45,360
has to have a cue list but then the

00:19:43,919 --> 00:19:46,960
trouble is if we want to have this api

00:19:45,360 --> 00:19:48,799
for the sake of range 4

00:19:46,960 --> 00:19:50,400
to have a points accessor it needs to

00:19:48,799 --> 00:19:51,840
return a cue list anyway

00:19:50,400 --> 00:19:53,919
so we might as well just move the list

00:19:51,840 --> 00:19:57,440
up that makes things easier

00:19:53,919 --> 00:19:59,600
and um so

00:19:57,440 --> 00:20:01,039
cue pointer event currently doesn't have

00:19:59,600 --> 00:20:04,080
virtual functions that's an

00:20:01,039 --> 00:20:06,720
um at least not for those accessors

00:20:04,080 --> 00:20:07,760
because it can yeah directly access the

00:20:06,720 --> 00:20:12,000
list

00:20:07,760 --> 00:20:14,400
um okay the next question was

00:20:12,000 --> 00:20:16,880
should the queue even point have a

00:20:14,400 --> 00:20:21,200
pointer to the event

00:20:16,880 --> 00:20:22,960
and well the problem with that is

00:20:21,200 --> 00:20:24,720
events come and go they're kind of

00:20:22,960 --> 00:20:26,720
disposable and they're also

00:20:24,720 --> 00:20:28,400
they don't have d pointers so they're

00:20:26,720 --> 00:20:30,159
stack allocated and therefore they're

00:20:28,400 --> 00:20:30,720
movable uncopyable and all that kind of

00:20:30,159 --> 00:20:32,080
stuff

00:20:30,720 --> 00:20:34,000
and so the the pointer wouldn't be

00:20:32,080 --> 00:20:35,440
stable i wanted to do that

00:20:34,000 --> 00:20:36,640
just for the sake of cute quick but then

00:20:35,440 --> 00:20:38,880
i realized it just takes too much

00:20:36,640 --> 00:20:41,120
bookkeeping i have to find out when the

00:20:38,880 --> 00:20:42,320
when the event that the point is

00:20:41,120 --> 00:20:44,320
pointing to moves

00:20:42,320 --> 00:20:45,679
and change it and so forth and it's just

00:20:44,320 --> 00:20:47,520
too much trouble

00:20:45,679 --> 00:20:48,880
so no we're going to have to change some

00:20:47,520 --> 00:20:50,799
things in qt quick a little bit because

00:20:48,880 --> 00:20:52,320
of that but it's just private api it

00:20:50,799 --> 00:20:53,679
just means everywhere we passed a point

00:20:52,320 --> 00:20:56,080
we have to pass the event and the point

00:20:53,679 --> 00:20:56,080
together

00:20:58,640 --> 00:21:07,120
yeah should i keep going or

00:21:03,600 --> 00:21:07,120
okay um

00:21:07,840 --> 00:21:12,240
um so if you want to do a q a you could

00:21:10,240 --> 00:21:13,360
start now we have one question for you

00:21:12,240 --> 00:21:15,120
on the shared notes

00:21:13,360 --> 00:21:16,480
maybe additional questions will pop up

00:21:15,120 --> 00:21:18,000
in the chat

00:21:16,480 --> 00:21:20,080
well i've got quite a bit more to go

00:21:18,000 --> 00:21:23,440
through if that's okay or

00:21:20,080 --> 00:21:25,200
then go for it yep yeah okay so the next

00:21:23,440 --> 00:21:26,960
question was um

00:21:25,200 --> 00:21:28,640
should we hold the event point state in

00:21:26,960 --> 00:21:29,679
the pointing device which conceptually

00:21:28,640 --> 00:21:30,880
makes sense because

00:21:29,679 --> 00:21:33,039
you know the touchscreen should keep

00:21:30,880 --> 00:21:34,960
track of your finger positions all the

00:21:33,039 --> 00:21:38,000
time

00:21:34,960 --> 00:21:40,000
so let's go with that uh the next time

00:21:38,000 --> 00:21:42,400
should we keep the q event point

00:21:40,000 --> 00:21:43,840
instances inside the events directly or

00:21:42,400 --> 00:21:44,799
should we have pointers inside the

00:21:43,840 --> 00:21:46,880
events

00:21:44,799 --> 00:21:47,919
so we decided to keep them inside

00:21:46,880 --> 00:21:49,600
directly

00:21:47,919 --> 00:21:51,200
and instead we're just hoping that we'll

00:21:49,600 --> 00:21:52,960
be able to make the few event points

00:21:51,200 --> 00:21:54,240
small enough that that's okay to hold

00:21:52,960 --> 00:21:56,320
them by value

00:21:54,240 --> 00:21:57,840
and the consequence of the nice

00:21:56,320 --> 00:21:59,280
consequence of this is events are

00:21:57,840 --> 00:22:00,000
copyable and they can be saved and

00:21:59,280 --> 00:22:01,520
replayed

00:22:00,000 --> 00:22:02,559
which is what people expect because it

00:22:01,520 --> 00:22:03,919
turned out that there were a lot of

00:22:02,559 --> 00:22:06,799
places in the code

00:22:03,919 --> 00:22:08,080
where somebody just constructs a q mouse

00:22:06,799 --> 00:22:09,520
event and then wants to play it back

00:22:08,080 --> 00:22:11,440
later and they expect that to be

00:22:09,520 --> 00:22:12,720
an atomic thing that you construct a q

00:22:11,440 --> 00:22:14,480
mouse event and it will just sit there

00:22:12,720 --> 00:22:17,840
and it won't change underneath you

00:22:14,480 --> 00:22:20,640
whereas if a qe event point was holding

00:22:17,840 --> 00:22:22,720
pointers to the points

00:22:20,640 --> 00:22:24,400
rather yeah the event itself holds

00:22:22,720 --> 00:22:25,679
pointers to the points then

00:22:24,400 --> 00:22:27,840
the points could change underneath you

00:22:25,679 --> 00:22:30,159
because as soon as the the next one

00:22:27,840 --> 00:22:31,440
comes in from the operating system

00:22:30,159 --> 00:22:32,880
it might turn out that a point that you

00:22:31,440 --> 00:22:34,320
thought was being held is actually

00:22:32,880 --> 00:22:36,320
released now and then you try to deliver

00:22:34,320 --> 00:22:38,880
your replay and that doesn't work

00:22:36,320 --> 00:22:39,520
so okay they're going to be held by

00:22:38,880 --> 00:22:41,120
value

00:22:39,520 --> 00:22:42,720
so the next thing is should they be q

00:22:41,120 --> 00:22:44,559
gadgets

00:22:42,720 --> 00:22:47,120
and the nice thing about that is that we

00:22:44,559 --> 00:22:49,360
can emit them by signals to qml

00:22:47,120 --> 00:22:51,360
gadgets can be emitted by value only

00:22:49,360 --> 00:22:52,080
queue objects can be emitted by pointer

00:22:51,360 --> 00:22:53,679
basically

00:22:52,080 --> 00:22:55,120
we don't want cue objects because that

00:22:53,679 --> 00:22:56,559
would be heavy so

00:22:55,120 --> 00:22:58,720
if we make them cute gadgets then we can

00:22:56,559 --> 00:23:01,360
emit signals but on the other hand

00:22:58,720 --> 00:23:02,080
um when you emit by value you're making

00:23:01,360 --> 00:23:03,440
a copy

00:23:02,080 --> 00:23:05,600
so then if you call a function which

00:23:03,440 --> 00:23:07,520
changes the state the state can be lost

00:23:05,600 --> 00:23:09,600
because it's a copy

00:23:07,520 --> 00:23:11,120
so it doesn't seem like accepting and

00:23:09,600 --> 00:23:12,000
rejecting like the way mouse area does

00:23:11,120 --> 00:23:14,799
would work that way

00:23:12,000 --> 00:23:15,360
if you're emitting a an event or a point

00:23:14,799 --> 00:23:18,640
by

00:23:15,360 --> 00:23:18,960
value and then changing it okay so then

00:23:18,640 --> 00:23:21,679
the

00:23:18,960 --> 00:23:22,000
then we had this um api review with lars

00:23:21,679 --> 00:23:23,679
a couple

00:23:22,000 --> 00:23:26,880
days ago and he basically wants to put

00:23:23,679 --> 00:23:28,720
back the d pointer in queue event point

00:23:26,880 --> 00:23:30,559
which i was kind of against to an extent

00:23:28,720 --> 00:23:32,799
because i wanted to make them so small

00:23:30,559 --> 00:23:35,039
and i thought ah this is just

00:23:32,799 --> 00:23:36,240
um every accessor has an interaction

00:23:35,039 --> 00:23:37,520
we're going to be doing all this heap

00:23:36,240 --> 00:23:38,240
allocation i didn't really want to do

00:23:37,520 --> 00:23:40,640
that

00:23:38,240 --> 00:23:42,240
but on the other hand uh well we have

00:23:40,640 --> 00:23:43,600
the usual freedom to change the event

00:23:42,240 --> 00:23:45,120
point private later on which

00:23:43,600 --> 00:23:48,720
maybe is going to be important we don't

00:23:45,120 --> 00:23:51,039
really know and then

00:23:48,720 --> 00:23:52,799
the qpa events are heap allocated anyway

00:23:51,039 --> 00:23:54,559
so maybe later we can just do the heap

00:23:52,799 --> 00:23:56,080
allocation in the platform plug-in and

00:23:54,559 --> 00:23:57,919
then those even points could come all

00:23:56,080 --> 00:23:59,440
the way from there up into the

00:23:57,919 --> 00:24:01,520
into the whole delivery logic that might

00:23:59,440 --> 00:24:04,400
be a way to optimize it

00:24:01,520 --> 00:24:05,919
and also um if we store the grabbers

00:24:04,400 --> 00:24:07,360
separately and we also store the

00:24:05,919 --> 00:24:10,159
accepted states separately

00:24:07,360 --> 00:24:11,520
then it could be that since it's or even

00:24:10,159 --> 00:24:12,559
if we don't store it separately since we

00:24:11,520 --> 00:24:14,159
have a d pointer

00:24:12,559 --> 00:24:16,080
that means that it's really the private

00:24:14,159 --> 00:24:17,600
that is the long-lived object

00:24:16,080 --> 00:24:19,039
and so the accepted state could be

00:24:17,600 --> 00:24:21,039
remembered long enough even if you're

00:24:19,039 --> 00:24:22,000
emitting by value to qml and you change

00:24:21,039 --> 00:24:23,279
the accepted state

00:24:22,000 --> 00:24:24,640
you're actually modifying the private

00:24:23,279 --> 00:24:25,600
which is still there so you don't lose

00:24:24,640 --> 00:24:28,640
it when that

00:24:25,600 --> 00:24:28,640
copy is destroyed

00:24:29,120 --> 00:24:32,880
um the next thing was uh should we move

00:24:31,600 --> 00:24:35,840
those instances to

00:24:32,880 --> 00:24:35,840
cue pointing device

00:24:36,159 --> 00:24:40,880
and um no should we move the grabber

00:24:40,000 --> 00:24:42,559
information to the

00:24:40,880 --> 00:24:44,240
pointing device to this even point data

00:24:42,559 --> 00:24:45,840
object so then the nice thing is that

00:24:44,240 --> 00:24:46,559
the skew of endpoint private becomes

00:24:45,840 --> 00:24:48,960
mostly

00:24:46,559 --> 00:24:50,640
read-only data and it gets really small

00:24:48,960 --> 00:24:52,400
and it's kind of ephemeral data it just

00:24:50,640 --> 00:24:54,720
holds the positions and stuff and then

00:24:52,400 --> 00:24:56,720
we throw it away when we're done with it

00:24:54,720 --> 00:24:57,760
whereas the the grabs tend to live on

00:24:56,720 --> 00:24:59,440
for longer

00:24:57,760 --> 00:25:00,640
so this is where we ended up so far and

00:24:59,440 --> 00:25:01,200
we'll see if we're still there by the

00:25:00,640 --> 00:25:05,600
time

00:25:01,200 --> 00:25:05,600
q6 comes out but that's how it looks

00:25:06,080 --> 00:25:10,080
okay so here's a little snippet about

00:25:07,760 --> 00:25:12,960
what i meant about agnostic delivery

00:25:10,080 --> 00:25:14,880
if you received a q event you can call

00:25:12,960 --> 00:25:16,559
this is pointer event function

00:25:14,880 --> 00:25:18,240
which is actually just checking a flag

00:25:16,559 --> 00:25:20,000
we added a couple of flags in there so

00:25:18,240 --> 00:25:21,279
that it avoids dynamic cast and things

00:25:20,000 --> 00:25:22,799
like that

00:25:21,279 --> 00:25:24,960
and so if you find out that it is a

00:25:22,799 --> 00:25:26,400
pointer event you can static cast it

00:25:24,960 --> 00:25:28,400
you can check whether it is a press

00:25:26,400 --> 00:25:29,360
event regardless what device it comes

00:25:28,400 --> 00:25:30,880
from it could be a

00:25:29,360 --> 00:25:32,960
finger being pressed or a mouse button

00:25:30,880 --> 00:25:34,559
being pressed and then you can go

00:25:32,960 --> 00:25:36,960
through the points and handle them

00:25:34,559 --> 00:25:38,960
so if you have a positive reaction to a

00:25:36,960 --> 00:25:40,960
press at a particular position

00:25:38,960 --> 00:25:42,000
then maybe you want to go ahead and grab

00:25:40,960 --> 00:25:44,080
you can do all of this

00:25:42,000 --> 00:25:46,400
without caring what specific device it

00:25:44,080 --> 00:25:46,400
came from

00:25:47,039 --> 00:25:50,320
that might be useful some of the time

00:25:48,400 --> 00:25:53,679
but uh a lot of times you're going to

00:25:50,320 --> 00:25:53,679
care about more details than that

00:25:54,320 --> 00:25:57,600
here's another snippet about sorry to

00:25:56,480 --> 00:25:59,360
interrupt you but

00:25:57,600 --> 00:26:01,200
uh we're running running slightly out of

00:25:59,360 --> 00:26:03,440
time do you want to

00:26:01,200 --> 00:26:05,279
quickly wrap up or do you want to take a

00:26:03,440 --> 00:26:07,919
quick look at the two questions on on

00:26:05,279 --> 00:26:10,240
the shared notes for you

00:26:07,919 --> 00:26:11,279
well can i just answer the questions

00:26:10,240 --> 00:26:15,600
afterwards on the

00:26:11,279 --> 00:26:17,760
on the share notes absolutely yeah okay

00:26:15,600 --> 00:26:19,440
um so checking about whether a mouse

00:26:17,760 --> 00:26:21,760
event is synthesized or not

00:26:19,440 --> 00:26:23,039
our oldest api was just to check whether

00:26:21,760 --> 00:26:24,400
it was spontaneous

00:26:23,039 --> 00:26:26,480
which turned out to be pretty vague

00:26:24,400 --> 00:26:27,600
because most events are spontaneous

00:26:26,480 --> 00:26:29,279
actually

00:26:27,600 --> 00:26:31,360
um so we added this mouse event source

00:26:29,279 --> 00:26:32,080
and q5.4 so you can check whether the

00:26:31,360 --> 00:26:34,400
source is

00:26:32,080 --> 00:26:36,000
not synthesized or synthesized by cute

00:26:34,400 --> 00:26:37,279
or synthesized by the os

00:26:36,000 --> 00:26:38,799
but then you don't really know is it

00:26:37,279 --> 00:26:41,200
from a touch screen or a tablet or

00:26:38,799 --> 00:26:43,760
something else

00:26:41,200 --> 00:26:44,960
so now we want to have api similar to uh

00:26:43,760 --> 00:26:46,720
what we had in

00:26:44,960 --> 00:26:48,480
cute quick that you can actually check

00:26:46,720 --> 00:26:50,159
the pointing device type

00:26:48,480 --> 00:26:52,799
and check specifically is it a touch

00:26:50,159 --> 00:26:55,039
screen a touch pad a tablet or whatever

00:26:52,799 --> 00:26:56,960
and we also have this um pointer type

00:26:55,039 --> 00:26:58,240
which was originally put in place just

00:26:56,960 --> 00:27:00,559
to be able to distinguish

00:26:58,240 --> 00:27:01,600
the ends of a wacom stylus you could

00:27:00,559 --> 00:27:03,360
have

00:27:01,600 --> 00:27:04,960
on the pointy end for drawing or you

00:27:03,360 --> 00:27:06,000
could have the eraser but then we filled

00:27:04,960 --> 00:27:07,919
it out with some other

00:27:06,000 --> 00:27:09,679
types too just to kind of have it always

00:27:07,919 --> 00:27:10,720
make sense but now it's starting to look

00:27:09,679 --> 00:27:12,080
like that might be a little bit

00:27:10,720 --> 00:27:13,440
redundant like

00:27:12,080 --> 00:27:15,039
there's two ways to tell if it's from a

00:27:13,440 --> 00:27:16,640
touch device it could be a the device

00:27:15,039 --> 00:27:18,159
type is a touch screen

00:27:16,640 --> 00:27:19,440
and the pointer type is a finger so

00:27:18,159 --> 00:27:22,720
that's a little bit redundant we're not

00:27:19,440 --> 00:27:22,720
sure if we want to keep it that way

00:27:23,200 --> 00:27:26,559
okay so point handler this is an old

00:27:24,880 --> 00:27:28,080
example which i just updated a little

00:27:26,559 --> 00:27:30,640
bit to

00:27:28,080 --> 00:27:35,840
show off some of the q6 stuff so you see

00:27:30,640 --> 00:27:35,840
there's a seat name there

00:27:38,720 --> 00:27:40,799

YouTube URL: https://www.youtube.com/watch?v=uKx6x0qlvnY


