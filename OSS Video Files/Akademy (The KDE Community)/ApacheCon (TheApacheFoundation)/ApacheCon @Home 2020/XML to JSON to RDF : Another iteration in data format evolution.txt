Title: XML to JSON to RDF : Another iteration in data format evolution
Publication date: 2020-10-14
Playlist: ApacheCon @Home 2020
Description: 
	XML to JSON to RDF : Another iteration in data format evolution
Claude Warren

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Starting with a brief history of web and micro server data serialization formats, this talk looks at the advantages of using RDF as the data format for web and micros service processing. An example of the processing as performed in a live application is presented. The talk demonstrates how RDF processed by Jena can deliver a clean, extensible data format with simple merge characteristics and mechanisms for reasoning.

Claude Warren is a Senior Software Engineer with over 30 years experience. He currently lives in Galway, Ireland where he works on innovative solutions to technical problems. He is also a Comitter and Project Management Committee member on the Apache Jena project and has several small open source projects on Github. He has presented papers at several conferences and has several papers published both in the popular IT press and in refereed journals. He is a founding member of the Denver Mad Scientists Club and winner of the original Critter Crunch competition.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,480 --> 00:00:28,400
well thank you

00:00:25,359 --> 00:00:30,080
um again this is the uh another

00:00:28,400 --> 00:00:34,320
iteration in the

00:00:30,080 --> 00:00:38,399
data format evolution it says um

00:00:34,320 --> 00:00:38,719
a little hopefully background on myself

00:00:38,399 --> 00:00:41,680
here

00:00:38,719 --> 00:00:43,360
i'm uh i'm claude warren uh so i'll tell

00:00:41,680 --> 00:00:46,399
you who's doing this i'm claude warren

00:00:43,360 --> 00:00:49,120
uh i am not the one found in wikipedia

00:00:46,399 --> 00:00:50,000
uh i'm an apache foundation member jenna

00:00:49,120 --> 00:00:52,559
pmc member

00:00:50,000 --> 00:00:53,920
for a number of years now uh software

00:00:52,559 --> 00:00:55,680
engineer developer i

00:00:53,920 --> 00:00:57,600
used to be a project manager and i used

00:00:55,680 --> 00:00:59,600
to be a systems engineer

00:00:57,600 --> 00:01:00,879
backed away from those that's not my

00:00:59,600 --> 00:01:03,120
forte

00:01:00,879 --> 00:01:05,040
i am a mad scientist i'll put that out

00:01:03,120 --> 00:01:06,640
there and a musician

00:01:05,040 --> 00:01:08,400
and the project i'm going to talk about

00:01:06,640 --> 00:01:10,960
today um

00:01:08,400 --> 00:01:13,280
was developed at ibm and then later at

00:01:10,960 --> 00:01:16,159
we pro

00:01:13,280 --> 00:01:18,799
so uh not just myself but a number of

00:01:16,159 --> 00:01:22,479
people were involved

00:01:18,799 --> 00:01:26,240
now i did promise a history of um

00:01:22,479 --> 00:01:28,240
xml and rdf and so this is my history

00:01:26,240 --> 00:01:31,360
slide

00:01:28,240 --> 00:01:32,880
so back in ancient times 1960s it was

00:01:31,360 --> 00:01:35,560
the arpanet

00:01:32,880 --> 00:01:37,439
and then by the 80s you have we have

00:01:35,560 --> 00:01:40,240
sgml which is

00:01:37,439 --> 00:01:41,840
sort of a form of xml so xml has a very

00:01:40,240 --> 00:01:44,240
early pedigree

00:01:41,840 --> 00:01:45,840
if you will 1990s we get the modern

00:01:44,240 --> 00:01:49,360
internet

00:01:45,840 --> 00:01:52,640
95 with javascript is introduced

00:01:49,360 --> 00:01:55,119
and we have anybody who worked in 95

00:01:52,640 --> 00:01:55,920
would remember the the browser wars and

00:01:55,119 --> 00:01:57,920
that you

00:01:55,920 --> 00:01:59,520
really couldn't write javascript that

00:01:57,920 --> 00:02:00,640
went across all of the browsers that

00:01:59,520 --> 00:02:02,799
were in use it made it

00:02:00,640 --> 00:02:05,280
almost impossible to do anything with it

00:02:02,799 --> 00:02:05,280
reasonable

00:02:06,000 --> 00:02:11,840
in 97 the rdf is first published

00:02:09,599 --> 00:02:13,840
um and then amazingly it took all the

00:02:11,840 --> 00:02:14,560
way until 98 for xml to actually be

00:02:13,840 --> 00:02:17,840
published

00:02:14,560 --> 00:02:20,400
um and at this point we're using xml

00:02:17,840 --> 00:02:22,959
for x our pc type calls and those sorts

00:02:20,400 --> 00:02:25,840
of things across the network

00:02:22,959 --> 00:02:27,520
and then we have at the millennium a

00:02:25,840 --> 00:02:33,440
watershed moment because we get

00:02:27,520 --> 00:02:36,800
soap which codifies the xml transports

00:02:33,440 --> 00:02:39,680
we have rest being defined at that point

00:02:36,800 --> 00:02:41,120
jason is first specified so there's a

00:02:39,680 --> 00:02:44,160
lot of things happen right at

00:02:41,120 --> 00:02:45,760
the turn of the millennium and then

00:02:44,160 --> 00:02:48,640
obviously we move forward you get

00:02:45,760 --> 00:02:50,640
firefoxes introduced in 2004

00:02:48,640 --> 00:02:51,760
the same year that the rdf specification

00:02:50,640 --> 00:02:53,920
is published

00:02:51,760 --> 00:02:55,040
uh and then it takes all the way until

00:02:53,920 --> 00:02:58,400
2005 for

00:02:55,040 --> 00:03:00,159
for ajax to be described and defined and

00:02:58,400 --> 00:03:02,319
it's using xml or json

00:03:00,159 --> 00:03:05,120
and javascript and asynchronous

00:03:02,319 --> 00:03:07,760
communications great stuff

00:03:05,120 --> 00:03:08,800
so really starting in 2005 we start to

00:03:07,760 --> 00:03:10,959
see

00:03:08,800 --> 00:03:12,400
some action some movement on the uh

00:03:10,959 --> 00:03:13,840
really being able to do things on the

00:03:12,400 --> 00:03:17,440
client side

00:03:13,840 --> 00:03:20,319
2008 chrome browser comes out 2009

00:03:17,440 --> 00:03:22,159
we finally get an agreement on how

00:03:20,319 --> 00:03:24,400
javascript is going to work across

00:03:22,159 --> 00:03:25,680
all of the browsers and from about that

00:03:24,400 --> 00:03:28,239
point on

00:03:25,680 --> 00:03:30,840
you can start to write code that really

00:03:28,239 --> 00:03:33,519
will transfer

00:03:30,840 --> 00:03:34,799
across multiple browsers

00:03:33,519 --> 00:03:36,879
you'd be able to write the code once and

00:03:34,799 --> 00:03:40,000
then have it work

00:03:36,879 --> 00:03:44,560
and then took all the way until 2013

00:03:40,000 --> 00:03:46,959
for jason to become standardized so

00:03:44,560 --> 00:03:49,120
what we see here is this early on we're

00:03:46,959 --> 00:03:51,120
playing in xml and then we're we start

00:03:49,120 --> 00:03:54,000
to see transitions to json

00:03:51,120 --> 00:03:55,200
uh more when you're dealing with um

00:03:54,000 --> 00:03:57,200
interactive

00:03:55,200 --> 00:03:58,560
you know user base facing uh

00:03:57,200 --> 00:04:01,840
applications on the

00:03:58,560 --> 00:04:02,959
on the browser uh some xml there but uh

00:04:01,840 --> 00:04:05,680
that seems to have

00:04:02,959 --> 00:04:07,120
migrated significantly over to to jason

00:04:05,680 --> 00:04:10,319
and

00:04:07,120 --> 00:04:12,400
so then in 2017 which is when this

00:04:10,319 --> 00:04:16,320
project starts

00:04:12,400 --> 00:04:18,560
we have javascript on the client side um

00:04:16,320 --> 00:04:21,440
as the programming language usually

00:04:18,560 --> 00:04:24,560
implementing the ajax protocols

00:04:21,440 --> 00:04:26,800
json is the common format to exchange

00:04:24,560 --> 00:04:28,639
between these and they're generally rest

00:04:26,800 --> 00:04:30,880
based applications

00:04:28,639 --> 00:04:32,240
but xml is still there it's still pr

00:04:30,880 --> 00:04:34,639
it's used

00:04:32,240 --> 00:04:37,360
in between in service calls between

00:04:34,639 --> 00:04:39,840
between services and large organizations

00:04:37,360 --> 00:04:41,040
using often using the soap based

00:04:39,840 --> 00:04:44,960
protocols

00:04:41,040 --> 00:04:50,160
for that although also available in

00:04:44,960 --> 00:04:50,160
in other formats in the web services

00:04:50,800 --> 00:04:55,600
my opinion of both of these is that they

00:04:53,040 --> 00:04:58,960
have a difficulty

00:04:55,600 --> 00:05:00,479
complex relationships between items in a

00:04:58,960 --> 00:05:03,120
data forest so if you

00:05:00,479 --> 00:05:04,800
if you have a simple tree it's not so

00:05:03,120 --> 00:05:07,919
bad but if you want to describe

00:05:04,800 --> 00:05:09,840
things that that occur multiple times

00:05:07,919 --> 00:05:11,199
you know xml gives you the ability to

00:05:09,840 --> 00:05:13,600
cite a reference within

00:05:11,199 --> 00:05:15,280
the document um i'm not sure what what

00:05:13,600 --> 00:05:16,639
jason does i suspect there's something

00:05:15,280 --> 00:05:19,120
similar

00:05:16,639 --> 00:05:19,919
um but it's a little more a little more

00:05:19,120 --> 00:05:22,880
complex

00:05:19,919 --> 00:05:25,360
um to express the forest in the in these

00:05:22,880 --> 00:05:28,560
two uh

00:05:25,360 --> 00:05:31,039
systems so at this point um

00:05:28,560 --> 00:05:34,080
our story begins in 2017 we began

00:05:31,039 --> 00:05:34,080
looking at this project

00:05:34,240 --> 00:05:37,680
so the question now is you know what is

00:05:36,400 --> 00:05:40,560
this project um

00:05:37,680 --> 00:05:41,680
we're going to do device configuration

00:05:40,560 --> 00:05:44,479
management

00:05:41,680 --> 00:05:45,600
uh and initially this meant we were

00:05:44,479 --> 00:05:48,880
looking at

00:05:45,600 --> 00:05:51,039
uh devices that support

00:05:48,880 --> 00:05:52,160
networks so you're the routers the you

00:05:51,039 --> 00:05:54,400
know all of the the

00:05:52,160 --> 00:05:55,360
those components that you see in an

00:05:54,400 --> 00:05:58,720
internet in a

00:05:55,360 --> 00:06:00,800
internet network um and the customers

00:05:58,720 --> 00:06:01,600
were primarily big telco so they have

00:06:00,800 --> 00:06:03,360
very

00:06:01,600 --> 00:06:05,680
you know restricted systems and that you

00:06:03,360 --> 00:06:08,639
know they're firewalled off

00:06:05,680 --> 00:06:09,840
very large systems and we're basically

00:06:08,639 --> 00:06:11,280
we're just going to configure we're

00:06:09,840 --> 00:06:12,960
going to manage the configurations of

00:06:11,280 --> 00:06:17,680
those devices

00:06:12,960 --> 00:06:17,680
now later this changes and becomes

00:06:17,759 --> 00:06:20,960
we're going to start looking at you know

00:06:19,520 --> 00:06:23,759
smart meters and

00:06:20,960 --> 00:06:25,039
other things that form networks and have

00:06:23,759 --> 00:06:26,800
configurations

00:06:25,039 --> 00:06:28,800
and the definition of configuration

00:06:26,800 --> 00:06:30,160
changed over time

00:06:28,800 --> 00:06:32,160
but effectively what we're going to talk

00:06:30,160 --> 00:06:34,639
about is configuration management of

00:06:32,160 --> 00:06:36,800
devices in a network

00:06:34,639 --> 00:06:38,639
okay and the second piece we did was we

00:06:36,800 --> 00:06:39,280
decided to design with an open world

00:06:38,639 --> 00:06:42,800
assumption

00:06:39,280 --> 00:06:44,800
and um i have found

00:06:42,800 --> 00:06:46,160
that as soon as you think you know

00:06:44,800 --> 00:06:49,199
everything

00:06:46,160 --> 00:06:50,479
about the environment um somebody will

00:06:49,199 --> 00:06:51,919
come along and tell you something you

00:06:50,479 --> 00:06:54,319
didn't know

00:06:51,919 --> 00:06:55,360
and that if you work with closed world

00:06:54,319 --> 00:06:58,000
assumptions

00:06:55,360 --> 00:06:59,759
you will end up writing yourself into a

00:06:58,000 --> 00:07:01,039
corner and having to do a lot of work

00:06:59,759 --> 00:07:02,960
but if you start with

00:07:01,039 --> 00:07:04,720
open world assumptions of where you say

00:07:02,960 --> 00:07:06,960
you know we don't know everything

00:07:04,720 --> 00:07:08,240
and we need to be able to adapt easily

00:07:06,960 --> 00:07:11,520
and quickly

00:07:08,240 --> 00:07:15,199
then your projects are my experiences

00:07:11,520 --> 00:07:18,000
and projects are more likely to succeed

00:07:15,199 --> 00:07:19,120
in our case we recognized that the users

00:07:18,000 --> 00:07:22,400
of the system

00:07:19,120 --> 00:07:24,240
would want to be able to add

00:07:22,400 --> 00:07:27,360
information to the system or annotate

00:07:24,240 --> 00:07:29,520
the objects in the system in some way

00:07:27,360 --> 00:07:31,039
there's things that are part of the

00:07:29,520 --> 00:07:32,720
company that were you know we're going

00:07:31,039 --> 00:07:33,919
to deploy this in

00:07:32,720 --> 00:07:35,520
that where they're going to want to be

00:07:33,919 --> 00:07:36,240
able to identify the devices they're

00:07:35,520 --> 00:07:39,280
talking to

00:07:36,240 --> 00:07:40,319
in specific ways and that we don't know

00:07:39,280 --> 00:07:43,280
what those are

00:07:40,319 --> 00:07:44,000
when we're starting this project we also

00:07:43,280 --> 00:07:46,400
recognize

00:07:44,000 --> 00:07:48,080
that when we pull the data and we start

00:07:46,400 --> 00:07:49,360
to get our data together subsequent

00:07:48,080 --> 00:07:51,280
processing is going to

00:07:49,360 --> 00:07:53,199
enhance that data and we're going to

00:07:51,280 --> 00:07:55,120
want to be able to track that and

00:07:53,199 --> 00:07:58,240
for some cases we don't know what that

00:07:55,120 --> 00:08:01,599
is in some of the cases as well

00:07:58,240 --> 00:08:04,080
the third part of it is the application

00:08:01,599 --> 00:08:05,039
driven device discovery uh when we go

00:08:04,080 --> 00:08:07,599
out to

00:08:05,039 --> 00:08:09,120
interrogate a device uh when we started

00:08:07,599 --> 00:08:11,440
it was really simple

00:08:09,120 --> 00:08:12,800
we were gonna open an ssh session right

00:08:11,440 --> 00:08:14,319
and talk to the device and get its

00:08:12,800 --> 00:08:15,840
configuration

00:08:14,319 --> 00:08:17,840
but when we start looking at other

00:08:15,840 --> 00:08:19,199
applications other applications of the

00:08:17,840 --> 00:08:21,759
product

00:08:19,199 --> 00:08:22,800
you want to talk to smart meters then

00:08:21,759 --> 00:08:24,960
you're going to be talking

00:08:22,800 --> 00:08:26,000
mqtt so you're going to be you have

00:08:24,960 --> 00:08:28,960
front end pieces that you

00:08:26,000 --> 00:08:30,720
talk to that you're going to use to get

00:08:28,960 --> 00:08:32,800
device discovery so there's a lot of

00:08:30,720 --> 00:08:35,120
information about

00:08:32,800 --> 00:08:37,760
how you talk to these things that we

00:08:35,120 --> 00:08:40,880
don't know at the beginning

00:08:37,760 --> 00:08:43,200
and then finally it is

00:08:40,880 --> 00:08:44,720
probable that the information we pull

00:08:43,200 --> 00:08:46,959
off a device

00:08:44,720 --> 00:08:48,800
will identify that device in some other

00:08:46,959 --> 00:08:50,800
data set and we're going to want to be

00:08:48,800 --> 00:08:53,920
able to pull that data

00:08:50,800 --> 00:08:57,279
into the system and be able to use it to

00:08:53,920 --> 00:08:57,279
answer questions by the users

00:08:57,760 --> 00:09:01,519
so we decided to use rdf graphs as our

00:09:00,640 --> 00:09:04,160
data storage

00:09:01,519 --> 00:09:04,160
technology

00:09:05,839 --> 00:09:10,480
and so what we end up with then is a

00:09:10,720 --> 00:09:14,320
a system that looks like this we've got

00:09:12,399 --> 00:09:16,800
the the user

00:09:14,320 --> 00:09:18,000
uh as represented by the smiley face

00:09:16,800 --> 00:09:20,320
we've got devices

00:09:18,000 --> 00:09:22,320
as represented by the boxes there the

00:09:20,320 --> 00:09:23,600
orange boxes we got the firewalls a nice

00:09:22,320 --> 00:09:25,600
red line

00:09:23,600 --> 00:09:27,440
and then our solution is going to be

00:09:25,600 --> 00:09:30,399
we're going to have a service network

00:09:27,440 --> 00:09:31,200
that's obviously powered by apache uh

00:09:30,399 --> 00:09:32,959
we're going to

00:09:31,200 --> 00:09:35,040
use that we're going to use kafka to

00:09:32,959 --> 00:09:36,880
cross the firewall

00:09:35,040 --> 00:09:38,480
we're going to talk to another component

00:09:36,880 --> 00:09:41,120
inside the firewall

00:09:38,480 --> 00:09:41,839
and that component will use apache miner

00:09:41,120 --> 00:09:44,180
to talk

00:09:41,839 --> 00:09:46,480
ssh to the devices and then

00:09:44,180 --> 00:09:49,760
[Music]

00:09:46,480 --> 00:09:51,279
we'll pull the data back we'll store

00:09:49,760 --> 00:09:54,000
whatever information it needs

00:09:51,279 --> 00:09:54,720
in terms of the graph data in a fuseki

00:09:54,000 --> 00:09:56,800
storage on

00:09:54,720 --> 00:09:58,720
inside the firewall might have a little

00:09:56,800 --> 00:10:00,000
bit of blob storage inside the firewall

00:09:58,720 --> 00:10:02,399
to store

00:10:00,000 --> 00:10:04,480
you know configurations and things like

00:10:02,399 --> 00:10:07,040
that so we can make comparisons with

00:10:04,480 --> 00:10:09,040
with later configurations in the end

00:10:07,040 --> 00:10:10,720
it's going to put the data back on kafka

00:10:09,040 --> 00:10:11,839
and send it back across to the service

00:10:10,720 --> 00:10:13,279
network

00:10:11,839 --> 00:10:15,839
we're going to do more processing in

00:10:13,279 --> 00:10:18,000
that network we'll stream it through

00:10:15,839 --> 00:10:19,200
we'll put it and we'll put the

00:10:18,000 --> 00:10:21,279
information

00:10:19,200 --> 00:10:23,120
the graph information the fuseki and the

00:10:21,279 --> 00:10:25,040
blob information the

00:10:23,120 --> 00:10:27,360
configuration files and things like that

00:10:25,040 --> 00:10:30,079
into blob storage

00:10:27,360 --> 00:10:33,839
so that's the general idea of what this

00:10:30,079 --> 00:10:37,279
application is going to do

00:10:33,839 --> 00:10:39,120
so why did we do it this way well

00:10:37,279 --> 00:10:40,959
one is what i've been trying to say is

00:10:39,120 --> 00:10:42,800
the future is a vast and undiscovered

00:10:40,959 --> 00:10:44,240
country

00:10:42,800 --> 00:10:46,000
you know there are many things that

00:10:44,240 --> 00:10:48,000
relate to this we don't there's no

00:10:46,000 --> 00:10:49,040
way we're going to know what the users

00:10:48,000 --> 00:10:50,560
are going to want to do with the

00:10:49,040 --> 00:10:53,360
application

00:10:50,560 --> 00:10:54,959
there are similar phrases in modern

00:10:53,360 --> 00:10:56,720
culture you get you know you can't make

00:10:54,959 --> 00:10:58,160
anything idiot-proof because idiots are

00:10:56,720 --> 00:11:00,480
so ingenious

00:10:58,160 --> 00:11:01,600
statements like that you really cannot

00:11:00,480 --> 00:11:04,000
tell

00:11:01,600 --> 00:11:05,440
what's going to happen uh and how your

00:11:04,000 --> 00:11:06,240
application is going to be used in the

00:11:05,440 --> 00:11:10,079
future so we

00:11:06,240 --> 00:11:10,079
we recognize that at the beginning

00:11:10,720 --> 00:11:15,279
we're dealing with network devices and

00:11:13,040 --> 00:11:18,320
thus a network data model just

00:11:15,279 --> 00:11:20,560
fits the domain so in our case the

00:11:18,320 --> 00:11:23,839
um you know we picked rdf because it was

00:11:20,560 --> 00:11:23,839
a network data model

00:11:23,920 --> 00:11:28,560
the other piece of this is that rdf uh

00:11:27,040 --> 00:11:30,399
in rdf all the properties are first

00:11:28,560 --> 00:11:32,399
class citizens so you don't

00:11:30,399 --> 00:11:34,079
have the distinction between a property

00:11:32,399 --> 00:11:35,360
and an edge like you do in some other

00:11:34,079 --> 00:11:38,480
graph

00:11:35,360 --> 00:11:39,440
models uh modeling systems and i sort of

00:11:38,480 --> 00:11:43,440
relate this back

00:11:39,440 --> 00:11:46,800
to to xml you know in xml you have

00:11:43,440 --> 00:11:50,959
child nodes and you have uh the

00:11:46,800 --> 00:11:53,440
properties of elements and

00:11:50,959 --> 00:11:54,240
you know if if you start a process and

00:11:53,440 --> 00:11:57,279
you think oh

00:11:54,240 --> 00:11:58,399
you know perhaps a phone number is a

00:11:57,279 --> 00:12:01,760
property of

00:11:58,399 --> 00:12:03,279
a person then down the road you realize

00:12:01,760 --> 00:12:04,720
that you need to have more phones and

00:12:03,279 --> 00:12:05,200
then there are different types of phones

00:12:04,720 --> 00:12:07,360
and

00:12:05,200 --> 00:12:09,519
all of a sudden the phone number is no

00:12:07,360 --> 00:12:11,600
longer really a property

00:12:09,519 --> 00:12:13,200
it really needs to have its own sub you

00:12:11,600 --> 00:12:16,240
know child element and you need to have

00:12:13,200 --> 00:12:19,200
lots more properties of that element

00:12:16,240 --> 00:12:19,920
and if you try then later to make that

00:12:19,200 --> 00:12:23,760
change

00:12:19,920 --> 00:12:26,240
all of your xpath queries have to change

00:12:23,760 --> 00:12:28,639
because of this distinction

00:12:26,240 --> 00:12:30,399
uh what rdf forced us to do was to you

00:12:28,639 --> 00:12:32,079
know get rid of that distinction and say

00:12:30,399 --> 00:12:35,440
okay everything

00:12:32,079 --> 00:12:37,120
can be an object and and let's you know

00:12:35,440 --> 00:12:40,160
allow us to move in that direction if

00:12:37,120 --> 00:12:40,160
that's what we need to do

00:12:41,440 --> 00:12:45,200
okay the other piece that it gives us is

00:12:43,839 --> 00:12:46,320
that all of the properties are

00:12:45,200 --> 00:12:47,519
namespaced

00:12:46,320 --> 00:12:50,480
so we're not going to have name

00:12:47,519 --> 00:12:52,880
conflicts if we want to call

00:12:50,480 --> 00:12:54,480
something in the system a name you know

00:12:52,880 --> 00:12:56,720
give it a property a name

00:12:54,480 --> 00:12:58,000
and the user wants to in their data that

00:12:56,720 --> 00:12:59,839
they're adding to the system wants to

00:12:58,000 --> 00:13:01,040
call something name

00:12:59,839 --> 00:13:02,560
those will be in two different name

00:13:01,040 --> 00:13:04,240
spaces but they can be in two different

00:13:02,560 --> 00:13:06,240
name spaces and so there's not going to

00:13:04,240 --> 00:13:08,880
be a conflict there

00:13:06,240 --> 00:13:10,800
we don't have to worry about about that

00:13:08,880 --> 00:13:12,240
kind of conflict coming from user data

00:13:10,800 --> 00:13:16,800
or other data coming in

00:13:12,240 --> 00:13:16,800
or changing the data later

00:13:16,959 --> 00:13:21,279
you know other properties coming into

00:13:18,320 --> 00:13:23,760
the system

00:13:21,279 --> 00:13:25,279
there's also a standard query language

00:13:23,760 --> 00:13:26,800
the sparkle is our standard query

00:13:25,279 --> 00:13:30,079
language we get this in the graph

00:13:26,800 --> 00:13:32,800
it's it's a very simple language in a

00:13:30,079 --> 00:13:36,160
lot of respects if you know

00:13:32,800 --> 00:13:39,279
sql sparkle is very easy to pick up

00:13:36,160 --> 00:13:41,920
so that helped us in you know making the

00:13:39,279 --> 00:13:44,959
case that we should go in this direction

00:13:41,920 --> 00:13:46,560
um there's a lot of rdf libraries

00:13:44,959 --> 00:13:48,959
available out there i was actually when

00:13:46,560 --> 00:13:53,279
i went to look i was rather surprised

00:13:48,959 --> 00:13:56,240
i knew that jenna obviously for java

00:13:53,279 --> 00:13:58,079
and a number of others now javascript

00:13:56,240 --> 00:13:59,680
has a library python has a library

00:13:58,079 --> 00:14:01,199
plural then there are many more

00:13:59,680 --> 00:14:03,600
libraries

00:14:01,199 --> 00:14:05,279
that'll read and write the rdf graph or

00:14:03,600 --> 00:14:08,000
talk sparkle to

00:14:05,279 --> 00:14:10,399
the sparkle endpoint so that the

00:14:08,000 --> 00:14:13,839
accessibility of the data

00:14:10,399 --> 00:14:17,440
is there it's not as restricted as

00:14:13,839 --> 00:14:20,800
you might think at first

00:14:17,440 --> 00:14:22,480
okay so the first thing we have to do

00:14:20,800 --> 00:14:25,040
is we have to be able to accept input

00:14:22,480 --> 00:14:28,320
from users

00:14:25,040 --> 00:14:29,680
so you know if you think about the

00:14:28,320 --> 00:14:32,800
traditional

00:14:29,680 --> 00:14:36,079
data coming from a web

00:14:32,800 --> 00:14:39,040
coming into a web service it comes in

00:14:36,079 --> 00:14:40,639
in a web form so the name value pairs

00:14:39,040 --> 00:14:43,279
effectively

00:14:40,639 --> 00:14:44,000
you can you can get xml documents you

00:14:43,279 --> 00:14:46,560
can get json

00:14:44,000 --> 00:14:47,680
documents and on top of that we're going

00:14:46,560 --> 00:14:49,519
to support

00:14:47,680 --> 00:14:52,880
all the rdf formats that are supported

00:14:49,519 --> 00:14:54,320
by jenna so serialization of rdf graph

00:14:52,880 --> 00:14:56,240
so that's the one at the bottom

00:14:54,320 --> 00:14:58,320
obviously is the easy one

00:14:56,240 --> 00:14:59,279
the other three what we ended up doing

00:14:58,320 --> 00:15:01,519
was we took

00:14:59,279 --> 00:15:02,800
those and used the apache commons

00:15:01,519 --> 00:15:05,760
configuration

00:15:02,800 --> 00:15:07,600
to read those types of data so web form

00:15:05,760 --> 00:15:09,680
that's name value pair

00:15:07,600 --> 00:15:11,519
that becomes that's a standard you know

00:15:09,680 --> 00:15:13,360
commons

00:15:11,519 --> 00:15:14,800
configuration reading property files

00:15:13,360 --> 00:15:17,360
effectively uh

00:15:14,800 --> 00:15:18,000
xml there's an xml version of you know

00:15:17,360 --> 00:15:21,120
to read

00:15:18,000 --> 00:15:22,240
xml for commons configuration and json

00:15:21,120 --> 00:15:24,639
the same

00:15:22,240 --> 00:15:25,519
and then in the end we can take that and

00:15:24,639 --> 00:15:28,160
then a very

00:15:25,519 --> 00:15:30,480
simple conversion from apache commons

00:15:28,160 --> 00:15:34,079
configuration into an rdf format

00:15:30,480 --> 00:15:34,079
that we can then feed into the system

00:15:35,199 --> 00:15:39,040
so the next part is we're then going to

00:15:37,920 --> 00:15:42,399
pass

00:15:39,040 --> 00:15:43,440
the rdf between uh between services

00:15:42,399 --> 00:15:45,360
within the system

00:15:43,440 --> 00:15:46,639
so once we put it into rdf we leave it

00:15:45,360 --> 00:15:49,360
that way and

00:15:46,639 --> 00:15:50,399
and we pass it throughout so when we're

00:15:49,360 --> 00:15:52,320
putting it on the

00:15:50,399 --> 00:15:53,680
the kafka queue it's rdf it's a

00:15:52,320 --> 00:15:55,759
serialized rdf

00:15:53,680 --> 00:15:57,279
when it's coming off you know obviously

00:15:55,759 --> 00:15:58,639
traverse the firewall and we'd read it

00:15:57,279 --> 00:16:02,240
process it

00:15:58,639 --> 00:16:02,959
everything um is is done in rdf in terms

00:16:02,240 --> 00:16:05,600
of

00:16:02,959 --> 00:16:08,320
metadata if you will obviously the

00:16:05,600 --> 00:16:11,120
configuration files are a specific

00:16:08,320 --> 00:16:11,680
object and we don't encode those into

00:16:11,120 --> 00:16:14,160
rdi

00:16:11,680 --> 00:16:16,240
we could you can there are steps in our

00:16:14,160 --> 00:16:18,800
process to do some of that

00:16:16,240 --> 00:16:23,440
but in general um the data that's

00:16:18,800 --> 00:16:27,360
flowing through the system is in rdf

00:16:23,440 --> 00:16:28,399
we used a beans on rdf framework or we

00:16:27,360 --> 00:16:32,000
actually

00:16:28,399 --> 00:16:33,759
wrote one here similar to pa for rdf

00:16:32,000 --> 00:16:36,639
persistent sanitation for rdf which was

00:16:33,759 --> 00:16:40,480
a package i wrote a couple years ago

00:16:36,639 --> 00:16:44,000
and this allows us to to use

00:16:40,480 --> 00:16:48,839
rdf elements in java in a very

00:16:44,000 --> 00:16:52,000
easy manner and as an example here

00:16:48,839 --> 00:16:56,399
um i have this triple

00:16:52,000 --> 00:16:56,399
at the top um it's a un

00:16:56,440 --> 00:17:03,120
6ln2971 which happens to be

00:16:58,639 --> 00:17:06,559
my id on slack i think um

00:17:03,120 --> 00:17:08,079
has the name claude it's simple triple

00:17:06,559 --> 00:17:09,919
uh if we think about this in terms of

00:17:08,079 --> 00:17:11,280
java we can say well there's an instance

00:17:09,919 --> 00:17:15,199
of something

00:17:11,280 --> 00:17:18,079
and um that thing has a method then

00:17:15,199 --> 00:17:19,600
which has the value so um the instance

00:17:18,079 --> 00:17:20,959
in the method is going to provide you

00:17:19,600 --> 00:17:21,919
know get name and the value will be

00:17:20,959 --> 00:17:24,959
clawed

00:17:21,919 --> 00:17:26,880
and then down below here i've got the an

00:17:24,959 --> 00:17:29,679
example of what that might look like you

00:17:26,880 --> 00:17:31,360
have a resource we have a static

00:17:29,679 --> 00:17:34,080
property called name

00:17:31,360 --> 00:17:35,200
so we can do that easily and then the

00:17:34,080 --> 00:17:38,240
method get name

00:17:35,200 --> 00:17:38,960
simply gets the name value from the

00:17:38,240 --> 00:17:41,440
resource

00:17:38,960 --> 00:17:42,640
and returns that and that's fairly

00:17:41,440 --> 00:17:45,919
simple now i can

00:17:42,640 --> 00:17:48,240
take any element any object or

00:17:45,919 --> 00:17:50,400
any subject into triples in the data

00:17:48,240 --> 00:17:51,840
store and say oh that's a person

00:17:50,400 --> 00:17:54,240
and then i can make calls on it i can

00:17:51,840 --> 00:17:57,280
get the name i can whatever other

00:17:54,240 --> 00:18:00,640
methods i add per person what we can do

00:17:57,280 --> 00:18:03,120
and so it makes it very easy

00:18:00,640 --> 00:18:04,080
for java developers then to say okay

00:18:03,120 --> 00:18:06,000
well i've got

00:18:04,080 --> 00:18:07,280
a device that i'm going to talk to so

00:18:06,000 --> 00:18:08,240
you know what are the properties of the

00:18:07,280 --> 00:18:10,400
device

00:18:08,240 --> 00:18:11,440
and get those uh out of the out of the

00:18:10,400 --> 00:18:13,679
rdf graph

00:18:11,440 --> 00:18:14,880
um into local storage you know into

00:18:13,679 --> 00:18:17,280
local

00:18:14,880 --> 00:18:18,480
locally and then you're able to access

00:18:17,280 --> 00:18:21,520
all of those components

00:18:18,480 --> 00:18:23,840
uh fairly simply and the

00:18:21,520 --> 00:18:25,520
advantage here again is that now all

00:18:23,840 --> 00:18:28,320
those other things that get added

00:18:25,520 --> 00:18:29,440
later are still attached even though you

00:18:28,320 --> 00:18:32,720
don't have direct

00:18:29,440 --> 00:18:33,919
access through the person class you can

00:18:32,720 --> 00:18:35,520
still get them by going through the

00:18:33,919 --> 00:18:36,960
resource and getting them so if you knew

00:18:35,520 --> 00:18:40,240
that something was there

00:18:36,960 --> 00:18:42,160
on a person um you know you could

00:18:40,240 --> 00:18:43,679
you could go ahead and grab it from the

00:18:42,160 --> 00:18:46,640
person object anyway you just have

00:18:43,679 --> 00:18:46,640
access to the resource

00:18:47,039 --> 00:18:52,400
um okay and then also

00:18:50,080 --> 00:18:54,880
there's a query builder library which

00:18:52,400 --> 00:18:57,760
gives us the ability in jenna to

00:18:54,880 --> 00:18:58,160
construct query templates so sort of

00:18:57,760 --> 00:19:01,840
like

00:18:58,160 --> 00:19:05,440
um uh the

00:19:01,840 --> 00:19:07,760
named queries in uh sql

00:19:05,440 --> 00:19:09,280
we can do this similar things we can

00:19:07,760 --> 00:19:11,360
build a standard query and say okay

00:19:09,280 --> 00:19:13,840
we're going to replace these parameters

00:19:11,360 --> 00:19:14,720
uh execute the query at that time so it

00:19:13,840 --> 00:19:16,080
makes you know

00:19:14,720 --> 00:19:18,160
we can do a lot of the same things you

00:19:16,080 --> 00:19:20,240
can do in sql

00:19:18,160 --> 00:19:21,280
in terms of setting it up to make it

00:19:20,240 --> 00:19:24,880
easy to

00:19:21,280 --> 00:19:27,440
to process requests

00:19:24,880 --> 00:19:28,400
uh let's see we're going to use fuseki

00:19:27,440 --> 00:19:30,160
on

00:19:28,400 --> 00:19:32,240
on td as of note on the graph when we're

00:19:30,160 --> 00:19:33,520
using tdb as our storage systems of

00:19:32,240 --> 00:19:39,440
standard

00:19:33,520 --> 00:19:42,240
uh jenna components

00:19:39,440 --> 00:19:43,600
and we are going to enhance the data as

00:19:42,240 --> 00:19:45,840
it passes through the system this is

00:19:43,600 --> 00:19:48,160
sort of what we expect to do this is why

00:19:45,840 --> 00:19:50,320
we started this in the first place uh

00:19:48,160 --> 00:19:52,480
realizing that we didn't know everything

00:19:50,320 --> 00:19:54,080
so data comes in we're going to we're

00:19:52,480 --> 00:19:57,039
going to enhance it

00:19:54,080 --> 00:19:57,520
as it passes through so as it goes to

00:19:57,039 --> 00:20:00,960
the

00:19:57,520 --> 00:20:01,360
um the agent the agent might add to the

00:20:00,960 --> 00:20:03,440
data

00:20:01,360 --> 00:20:04,559
saying to the event you get an event

00:20:03,440 --> 00:20:06,880
comes in on the front end

00:20:04,559 --> 00:20:07,679
it's a time stamp on that passes it off

00:20:06,880 --> 00:20:09,280
to the

00:20:07,679 --> 00:20:11,120
the agent the agent might say well this

00:20:09,280 --> 00:20:12,640
agent processed this event and you can

00:20:11,120 --> 00:20:14,799
add that data to the event

00:20:12,640 --> 00:20:16,159
pieces you're going to be able to go out

00:20:14,799 --> 00:20:17,760
and hit the

00:20:16,159 --> 00:20:21,200
device and get information from the

00:20:17,760 --> 00:20:22,960
device and enhance the you know the idea

00:20:21,200 --> 00:20:25,360
of what the device is

00:20:22,960 --> 00:20:27,360
pass that through the system um

00:20:25,360 --> 00:20:30,640
subsequent processes can then look at

00:20:27,360 --> 00:20:31,280
that data and add uh more data to the to

00:20:30,640 --> 00:20:32,640
the

00:20:31,280 --> 00:20:35,520
description of the event as it goes

00:20:32,640 --> 00:20:37,360
along through the system

00:20:35,520 --> 00:20:38,799
okay so now the question is that i

00:20:37,360 --> 00:20:40,320
always get asked when i presented this

00:20:38,799 --> 00:20:42,320
as you know what about the ui

00:20:40,320 --> 00:20:43,440
and we haven't spoken about the ui here

00:20:42,320 --> 00:20:44,960
we've got

00:20:43,440 --> 00:20:48,000
this front end and we're processing the

00:20:44,960 --> 00:20:51,520
data through as i just described but we

00:20:48,000 --> 00:20:51,520
haven't spoken at all about the ui

00:20:52,080 --> 00:20:56,720
so what we've done though is we've

00:20:54,320 --> 00:20:59,120
provided the microservices

00:20:56,720 --> 00:21:01,440
so we can access the graph we can access

00:20:59,120 --> 00:21:04,320
objects like a device an event

00:21:01,440 --> 00:21:05,200
as you can pull them out of the graph as

00:21:04,320 --> 00:21:07,200
java objects

00:21:05,200 --> 00:21:08,880
serialize them out and do whatever you

00:21:07,200 --> 00:21:10,720
want to do with device and event and

00:21:08,880 --> 00:21:13,039
other objects like that

00:21:10,720 --> 00:21:15,360
we have a series of microservices that

00:21:13,039 --> 00:21:18,720
will return

00:21:15,360 --> 00:21:20,240
the data from the graph as you know text

00:21:18,720 --> 00:21:24,080
plain

00:21:20,240 --> 00:21:26,400
as xml application xml as json

00:21:24,080 --> 00:21:27,840
or as any of the jenna supported rdf

00:21:26,400 --> 00:21:30,799
serialization formats

00:21:27,840 --> 00:21:32,240
so we can pull data back out we also

00:21:30,799 --> 00:21:36,480
gave direct query to the

00:21:32,240 --> 00:21:39,440
to the uh graph so that users could then

00:21:36,480 --> 00:21:40,799
access the data that's in the graph and

00:21:39,440 --> 00:21:44,080
ask the questions

00:21:40,799 --> 00:21:45,679
um that we didn't really arrange

00:21:44,080 --> 00:21:47,280
for in the front end because you know

00:21:45,679 --> 00:21:49,679
when you build the

00:21:47,280 --> 00:21:50,400
the services and then when you build the

00:21:49,679 --> 00:21:52,480
ui on

00:21:50,400 --> 00:21:53,919
when somebody builds a ui on top of that

00:21:52,480 --> 00:21:56,559
you're making assumptions

00:21:53,919 --> 00:21:57,840
about what the user wants to know and if

00:21:56,559 --> 00:21:58,799
there's anything that you haven't

00:21:57,840 --> 00:22:00,400
accounted for

00:21:58,799 --> 00:22:02,240
and there's a lot of work to go around

00:22:00,400 --> 00:22:04,000
and

00:22:02,240 --> 00:22:05,760
you know re-implement parts of that to

00:22:04,000 --> 00:22:06,400
get that data up to the front end where

00:22:05,760 --> 00:22:09,520
it can then be

00:22:06,400 --> 00:22:12,640
seen by the ui that's being implemented

00:22:09,520 --> 00:22:15,120
and um and presented to the user so we

00:22:12,640 --> 00:22:18,400
provided this direct query to the jenna

00:22:15,120 --> 00:22:21,120
the fuseki graph so that you could make

00:22:18,400 --> 00:22:24,240
queries that we hadn't anticipated

00:22:21,120 --> 00:22:25,520
um and the other reason that we didn't

00:22:24,240 --> 00:22:29,200
actually build a ui

00:22:25,520 --> 00:22:29,679
was that we expected that the tool would

00:22:29,200 --> 00:22:33,200
be

00:22:29,679 --> 00:22:37,039
integrated into existing systems

00:22:33,200 --> 00:22:38,960
so you would have a framework that

00:22:37,039 --> 00:22:40,720
telco would put together and they would

00:22:38,960 --> 00:22:42,960
just want to be able to query

00:22:40,720 --> 00:22:44,960
and get data and they want it to look

00:22:42,960 --> 00:22:46,799
and feel like their component

00:22:44,960 --> 00:22:50,320
so we didn't spend a lot of time working

00:22:46,799 --> 00:22:50,320
on the ui we did use

00:22:50,400 --> 00:22:55,679
a tool that gave us the ability to

00:22:52,080 --> 00:22:58,880
define the apis and then quickly

00:22:55,679 --> 00:23:01,600
present that as a a simple web-based

00:22:58,880 --> 00:23:03,360
interface but that's really a

00:23:01,600 --> 00:23:06,720
demonstration and proof to

00:23:03,360 --> 00:23:08,640
of the api it wasn't a

00:23:06,720 --> 00:23:10,559
an actual you know really nicely

00:23:08,640 --> 00:23:12,320
formatted api with graphs and buttons

00:23:10,559 --> 00:23:13,919
and all that great stuff

00:23:12,320 --> 00:23:17,280
it was just enough to show that it works

00:23:13,919 --> 00:23:17,280
and show how the how it worked

00:23:17,520 --> 00:23:22,960
so the answer is there is no ui and

00:23:21,039 --> 00:23:24,880
to be honest i like the back-end

00:23:22,960 --> 00:23:28,640
development so when there's no ui

00:23:24,880 --> 00:23:32,480
i'm really happy um

00:23:28,640 --> 00:23:32,960
okay so now we've got all of that in

00:23:32,480 --> 00:23:35,120
play

00:23:32,960 --> 00:23:36,000
we can start to talk about what does

00:23:35,120 --> 00:23:42,080
this look

00:23:36,000 --> 00:23:44,559
like so let me back up here if

00:23:42,080 --> 00:23:45,679
if in this diagram uh you've got the

00:23:44,559 --> 00:23:47,520
user and

00:23:45,679 --> 00:23:49,520
it wants to well we just have to do this

00:23:47,520 --> 00:23:50,960
we're going to make a call to the

00:23:49,520 --> 00:23:53,279
service framework and say i want to

00:23:50,960 --> 00:23:54,480
register a new device

00:23:53,279 --> 00:23:55,840
and it's going to go out to the agent

00:23:54,480 --> 00:23:57,840
and then it's going to talk to that

00:23:55,840 --> 00:23:59,919
device and get some information

00:23:57,840 --> 00:24:02,159
okay so i just want to know what does it

00:23:59,919 --> 00:24:04,799
look like when i make that call

00:24:02,159 --> 00:24:07,039
from the user side to the service frame

00:24:04,799 --> 00:24:09,360
network because everything beyond that

00:24:07,039 --> 00:24:10,400
is really internal processing and we're

00:24:09,360 --> 00:24:13,600
really interested in

00:24:10,400 --> 00:24:18,080
how can we replace this json or xml

00:24:13,600 --> 00:24:21,039
with rdf and how well does that work

00:24:18,080 --> 00:24:22,559
let's go the right correction here so

00:24:21,039 --> 00:24:24,480
what we want to do is we want to be able

00:24:22,559 --> 00:24:26,159
to send something that looks like

00:24:24,480 --> 00:24:27,760
something like what i'm showing here in

00:24:26,159 --> 00:24:28,320
the convert and the conversion so for

00:24:27,760 --> 00:24:31,440
the

00:24:28,320 --> 00:24:33,679
rdf we've defined a name space the

00:24:31,440 --> 00:24:36,720
default namespace is the usernamespace

00:24:33,679 --> 00:24:38,960
for the for the user for the

00:24:36,720 --> 00:24:40,799
whoever's using the system obviously and

00:24:38,960 --> 00:24:42,960
then we have a system namespace for all

00:24:40,799 --> 00:24:45,200
of the stuff that we're doing internally

00:24:42,960 --> 00:24:48,799
and then i've added cpe which is the

00:24:45,200 --> 00:24:52,080
common platform enumeration

00:24:48,799 --> 00:24:54,720
so this is you know a common naming for

00:24:52,080 --> 00:24:57,039
all sorts of things it's used in bug

00:24:54,720 --> 00:25:00,080
reports and whatnot

00:24:57,039 --> 00:25:02,960
so in the example here um

00:25:00,080 --> 00:25:04,320
the user's saying i want to create and

00:25:02,960 --> 00:25:04,960
i'm going to create an event i'm going

00:25:04,320 --> 00:25:07,919
to

00:25:04,960 --> 00:25:08,559
put this um request in i want to create

00:25:07,919 --> 00:25:10,720
a new

00:25:08,559 --> 00:25:12,240
a device i'm going to call it my new

00:25:10,720 --> 00:25:13,919
device that's that's my name that's what

00:25:12,240 --> 00:25:17,840
i'm going to call it

00:25:13,919 --> 00:25:17,840
and i think that it is

00:25:18,320 --> 00:25:25,919
it has a cpe name of

00:25:21,919 --> 00:25:29,919
what is that 360 fc f5c router

00:25:25,919 --> 00:25:34,080
which is a real live cpe id name

00:25:29,919 --> 00:25:36,799
um in their nomenclature and um

00:25:34,080 --> 00:25:38,559
this this event that that's coming in

00:25:36,799 --> 00:25:42,080
was triggered by

00:25:38,559 --> 00:25:43,440
a thing that i call thing one and i want

00:25:42,080 --> 00:25:47,039
to talk to

00:25:43,440 --> 00:25:49,039
the ip192 16813

00:25:47,039 --> 00:25:50,559
that's the data we're trying to look for

00:25:49,039 --> 00:25:52,240
right that's sort of what we're trying

00:25:50,559 --> 00:25:55,039
to

00:25:52,240 --> 00:25:56,880
show in the rest of these examples here

00:25:55,039 --> 00:26:00,240
so

00:25:56,880 --> 00:26:02,320
um if we were to do this in json the

00:26:00,240 --> 00:26:03,600
example the way we did it was we said

00:26:02,320 --> 00:26:06,000
all right

00:26:03,600 --> 00:26:07,279
in the we'll put brackets up here now

00:26:06,000 --> 00:26:10,880
this is not

00:26:07,279 --> 00:26:14,159
this is not rdf uh ld this is not

00:26:10,880 --> 00:26:17,600
json ld this is not the rdf json this is

00:26:14,159 --> 00:26:20,799
a mechanism that we use to convert from

00:26:17,600 --> 00:26:22,080
very simple json into the the type of

00:26:20,799 --> 00:26:24,799
structure that we were looking for like

00:26:22,080 --> 00:26:26,559
that where it was very easy for

00:26:24,799 --> 00:26:28,320
end user developers to be able to come

00:26:26,559 --> 00:26:31,200
in and build

00:26:28,320 --> 00:26:32,159
build a json query build a json object

00:26:31,200 --> 00:26:35,440
that they could send

00:26:32,159 --> 00:26:37,200
they would not um they would not have to

00:26:35,440 --> 00:26:39,440
go out and learn all of the

00:26:37,200 --> 00:26:40,880
the rdf stuff so the developers made it

00:26:39,440 --> 00:26:43,760
easier for developers to get

00:26:40,880 --> 00:26:45,520
started in the process so in this case

00:26:43,760 --> 00:26:48,159
define the name spaces inside these

00:26:45,520 --> 00:26:50,960
square brackets with the at

00:26:48,159 --> 00:26:52,960
namespace kind of notation here so we

00:26:50,960 --> 00:26:55,600
define the name spaces and then

00:26:52,960 --> 00:26:56,880
the ob the names of the values then are

00:26:55,600 --> 00:27:01,679
have a colon

00:26:56,880 --> 00:27:04,720
uh in the names of the json uh about

00:27:01,679 --> 00:27:07,120
names and then other than that it's

00:27:04,720 --> 00:27:08,159
pretty much a straight structured you

00:27:07,120 --> 00:27:12,240
know json

00:27:08,159 --> 00:27:15,840
structure um

00:27:12,240 --> 00:27:17,360
okay so when we looked at it doing this

00:27:15,840 --> 00:27:21,840
as a

00:27:17,360 --> 00:27:21,840
name value pairs if we look at what

00:27:21,919 --> 00:27:25,919
what the commons

00:27:26,000 --> 00:27:31,279
configuration did basically this is

00:27:29,440 --> 00:27:33,200
what the property file would look like

00:27:31,279 --> 00:27:34,880
for that so again it's the same sort of

00:27:33,200 --> 00:27:36,880
structure with the square brackets

00:27:34,880 --> 00:27:40,480
defining the name spaces

00:27:36,880 --> 00:27:43,520
and then properties with the colon

00:27:40,480 --> 00:27:46,960
separating the values now in the

00:27:43,520 --> 00:27:50,799
in the commons configuration

00:27:46,960 --> 00:27:51,919
colon is a an acceptable replacement for

00:27:50,799 --> 00:27:54,960
equals and

00:27:51,919 --> 00:27:56,080
so this example shows what you would

00:27:54,960 --> 00:27:58,559
have to do

00:27:56,080 --> 00:28:00,840
if you didn't write a a little bit of a

00:27:58,559 --> 00:28:04,240
custom code for the

00:28:00,840 --> 00:28:05,440
commons uh configuration system now you

00:28:04,240 --> 00:28:07,440
you can tell it

00:28:05,440 --> 00:28:08,799
never mind the colon is not the same as

00:28:07,440 --> 00:28:10,399
equals and then you can get rid of all

00:28:08,799 --> 00:28:13,679
those escapes on the

00:28:10,399 --> 00:28:15,760
on the colons in here but uh so this

00:28:13,679 --> 00:28:17,679
shows basically what a property file the

00:28:15,760 --> 00:28:21,679
name you know name value pairs or

00:28:17,679 --> 00:28:24,880
posting from a web form might look like

00:28:21,679 --> 00:28:27,919
um see so

00:28:24,880 --> 00:28:30,720
our story thus far we have

00:28:27,919 --> 00:28:32,480
thing one now out here in user space has

00:28:30,720 --> 00:28:34,799
submitted

00:28:32,480 --> 00:28:36,720
the request to the service network it's

00:28:34,799 --> 00:28:38,799
gone across the agent processes it it

00:28:36,720 --> 00:28:39,200
talks to the device it gets information

00:28:38,799 --> 00:28:42,080
back

00:28:39,200 --> 00:28:43,279
puts it back on the queue comes back in

00:28:42,080 --> 00:28:46,399
gets stuck up into

00:28:43,279 --> 00:28:49,360
the jenna fuseki space there

00:28:46,399 --> 00:28:51,919
um the user can now come in later and

00:28:49,360 --> 00:28:54,799
ask questions like

00:28:51,919 --> 00:28:56,640
what thing what did thing one register

00:28:54,799 --> 00:28:58,640
in the last hour

00:28:56,640 --> 00:29:01,279
because we've got you know the event has

00:28:58,640 --> 00:29:02,880
a time associated with it we know

00:29:01,279 --> 00:29:04,559
you know we can ask what ip addresses

00:29:02,880 --> 00:29:05,440
were registered we can ask things like

00:29:04,559 --> 00:29:06,960
this

00:29:05,440 --> 00:29:08,399
which is something you know we might not

00:29:06,960 --> 00:29:10,080
have thought about when we originally

00:29:08,399 --> 00:29:13,600
wrote the code

00:29:10,080 --> 00:29:15,120
um we can ask you know is

00:29:13,600 --> 00:29:16,640
you can ask questions like you know is

00:29:15,120 --> 00:29:19,360
thing one making

00:29:16,640 --> 00:29:21,279
uh registrations is it has it fallen

00:29:19,360 --> 00:29:22,240
over basically you can you can sort of

00:29:21,279 --> 00:29:25,279
ask that of this

00:29:22,240 --> 00:29:27,120
the data stream um

00:29:25,279 --> 00:29:28,720
so what we've done is we've effectively

00:29:27,120 --> 00:29:31,600
replaced

00:29:28,720 --> 00:29:32,240
the xml and the json in the system with

00:29:31,600 --> 00:29:33,679
rdap

00:29:32,240 --> 00:29:35,520
and shown that we can move it end to end

00:29:33,679 --> 00:29:38,559
and the the data is

00:29:35,520 --> 00:29:41,840
um very easy to query uh

00:29:38,559 --> 00:29:41,840
in this inside the system

00:29:42,080 --> 00:29:46,880
okay so what are our advantages um

00:29:45,120 --> 00:29:49,679
we don't have the name collisions as we

00:29:46,880 --> 00:29:49,679
noted um

00:29:49,760 --> 00:29:53,520
we have the ability to add data elements

00:29:51,840 --> 00:29:54,960
so the user was able to add an element

00:29:53,520 --> 00:29:56,640
and that would have flown gone all the

00:29:54,960 --> 00:29:58,399
way through the system and been

00:29:56,640 --> 00:30:00,399
with the object in the end so you can

00:29:58,399 --> 00:30:02,640
use that as part of their queries to

00:30:00,399 --> 00:30:04,640
determine what they're looking for

00:30:02,640 --> 00:30:07,120
or to find what they're looking for in

00:30:04,640 --> 00:30:09,520
in the in the data

00:30:07,120 --> 00:30:10,640
we're able to quickly support new user

00:30:09,520 --> 00:30:12,799
requirements so we can

00:30:10,640 --> 00:30:15,360
answer questions that we never plan for

00:30:12,799 --> 00:30:17,360
during the analysis

00:30:15,360 --> 00:30:18,799
we can inject additional user

00:30:17,360 --> 00:30:20,000
information or additional information

00:30:18,799 --> 00:30:22,559
from other systems

00:30:20,000 --> 00:30:24,240
into the into the data stream and

00:30:22,559 --> 00:30:25,520
process them and be able to query

00:30:24,240 --> 00:30:27,679
against them

00:30:25,520 --> 00:30:29,679
uh and we're able to process externally

00:30:27,679 --> 00:30:33,039
linked data so for example

00:30:29,679 --> 00:30:34,559
the the cpe data um there's a

00:30:33,039 --> 00:30:38,000
publication that lists

00:30:34,559 --> 00:30:40,640
there's a list all of the cpes and

00:30:38,000 --> 00:30:42,480
information about those each one of

00:30:40,640 --> 00:30:42,880
those named things uh you know who owns

00:30:42,480 --> 00:30:45,120
it

00:30:42,880 --> 00:30:46,559
what does it mean what is it what

00:30:45,120 --> 00:30:48,880
versions of it are there any and you can

00:30:46,559 --> 00:30:50,720
then query that and ask if there are any

00:30:48,880 --> 00:30:53,360
bugs open against those devices are

00:30:50,720 --> 00:30:53,360
there any you know

00:30:53,760 --> 00:30:58,320
reports of security issues and things

00:30:57,360 --> 00:31:00,720
like that

00:30:58,320 --> 00:31:02,880
so we're able to now look at what what

00:31:00,720 --> 00:31:03,679
the devices are saying they are and put

00:31:02,880 --> 00:31:05,600
that in and then

00:31:03,679 --> 00:31:06,880
tie that into the cpe and be able to say

00:31:05,600 --> 00:31:08,640
oh

00:31:06,880 --> 00:31:10,559
user can now come in and say oh do we

00:31:08,640 --> 00:31:14,159
have any devices that have

00:31:10,559 --> 00:31:18,559
new security reports against them

00:31:14,159 --> 00:31:20,159
and we can answer that question um and

00:31:18,559 --> 00:31:22,640
finally we have this extensible

00:31:20,159 --> 00:31:24,399
architecture where we're using kafka to

00:31:22,640 --> 00:31:27,360
stream the data through

00:31:24,399 --> 00:31:27,760
and then because we're using kafka we

00:31:27,360 --> 00:31:29,200
can

00:31:27,760 --> 00:31:30,960
use all of the kafka streaming

00:31:29,200 --> 00:31:34,399
capabilities to look

00:31:30,960 --> 00:31:35,679
at the data that's that's in the rdf

00:31:34,399 --> 00:31:38,320
documents as they're streaming through

00:31:35,679 --> 00:31:41,760
the system and add to that

00:31:38,320 --> 00:31:43,279
make it do analysis of that um

00:31:41,760 --> 00:31:46,399
it takes a little bit more work

00:31:43,279 --> 00:31:47,679
currently to do that because um you know

00:31:46,399 --> 00:31:49,279
most of those processes

00:31:47,679 --> 00:31:51,840
that people are writing are looking for

00:31:49,279 --> 00:31:54,960
for rdf or x or not stuff party for

00:31:51,840 --> 00:31:57,360
json or xml we can convert back to json

00:31:54,960 --> 00:31:59,039
because we've got this the front end

00:31:57,360 --> 00:32:02,080
piece that does that

00:31:59,039 --> 00:32:04,640
but it's it's often easier to just write

00:32:02,080 --> 00:32:05,600
small components that plug into the to

00:32:04,640 --> 00:32:08,480
the kafka

00:32:05,600 --> 00:32:09,840
architect networks to be able to parse

00:32:08,480 --> 00:32:14,640
that data

00:32:09,840 --> 00:32:17,919
as it's flowing through the system

00:32:14,640 --> 00:32:19,840
so my favorite casablanca slide is as

00:32:17,919 --> 00:32:23,440
time goes by

00:32:19,840 --> 00:32:26,720
um what we found out were that

00:32:23,440 --> 00:32:28,880
some of these devices have very large

00:32:26,720 --> 00:32:30,080
configurations on the order of hundreds

00:32:28,880 --> 00:32:32,240
of megabytes

00:32:30,080 --> 00:32:34,000
in size and then that just seems

00:32:32,240 --> 00:32:35,679
outrageous to me but that's what they

00:32:34,000 --> 00:32:36,960
are you ask it for that's the device for

00:32:35,679 --> 00:32:40,480
its configuration

00:32:36,960 --> 00:32:42,799
hundreds of megabytes come back um

00:32:40,480 --> 00:32:43,840
kafka has some upper limits to the size

00:32:42,799 --> 00:32:45,360
of messages

00:32:43,840 --> 00:32:47,200
so we had to develop a technique to

00:32:45,360 --> 00:32:50,720
split those messages

00:32:47,200 --> 00:32:53,840
um and then reassemble them that's

00:32:50,720 --> 00:32:56,000
not that hard uh there's no priority

00:32:53,840 --> 00:32:59,120
queue in cafe okay we can handle that

00:32:56,000 --> 00:33:02,480
in code um the

00:32:59,120 --> 00:33:04,159
last one here the rdf data plus

00:33:02,480 --> 00:33:05,840
the schema now we had a little bit of

00:33:04,159 --> 00:33:08,399
schema attached to you know

00:33:05,840 --> 00:33:09,120
was this value supposed to only occur

00:33:08,399 --> 00:33:10,880
once or

00:33:09,120 --> 00:33:13,279
you know did we allow multiples things

00:33:10,880 --> 00:33:13,279
like that

00:33:13,919 --> 00:33:18,000
we ended up having to we passed the

00:33:15,679 --> 00:33:21,200
schema around with the data

00:33:18,000 --> 00:33:24,320
because it's all a graph right um

00:33:21,200 --> 00:33:26,320
that gave us largest graphs uh

00:33:24,320 --> 00:33:28,320
and so we when they got really big we

00:33:26,320 --> 00:33:30,480
begin to split them up as well there's

00:33:28,320 --> 00:33:32,000
there are probably better solutions to

00:33:30,480 --> 00:33:33,840
that and that's one of those

00:33:32,000 --> 00:33:35,919
things where i would have to say we

00:33:33,840 --> 00:33:39,360
thought we knew what we were doing and

00:33:35,919 --> 00:33:40,240
um it came back around to be something

00:33:39,360 --> 00:33:44,399
we didn't know

00:33:40,240 --> 00:33:47,440
um and and so that's one of those things

00:33:44,399 --> 00:33:52,399
we could have handled better

00:33:47,440 --> 00:33:54,320
um so that's um

00:33:52,399 --> 00:33:55,679
basically the end of comes to the end of

00:33:54,320 --> 00:33:59,120
the my talk

00:33:55,679 --> 00:34:00,960
um so let me ask if there's

00:33:59,120 --> 00:34:02,720
any questions i'll let you know that any

00:34:00,960 --> 00:34:03,600
of the open source pieces that were

00:34:02,720 --> 00:34:06,960
developed

00:34:03,600 --> 00:34:08,560
i have available on my github um

00:34:06,960 --> 00:34:10,079
i've got some publications i don't think

00:34:08,560 --> 00:34:13,520
there's any specifically on

00:34:10,079 --> 00:34:16,800
on this package up on research lease or

00:34:13,520 --> 00:34:18,720
search gate and um you can find me on

00:34:16,800 --> 00:34:20,800
linkedin

00:34:18,720 --> 00:34:23,200
so uh let me ask if there are any

00:34:20,800 --> 00:34:23,200
questions

00:34:26,720 --> 00:34:30,560
oh not chad i can't see it

00:34:30,960 --> 00:34:35,040
okay oh i went

00:34:35,750 --> 00:34:38,869
[Music]

00:34:45,520 --> 00:34:52,960
five minutes

00:34:49,520 --> 00:34:52,960
okay well

00:34:54,000 --> 00:35:03,839
well then um oh here's a question

00:34:57,520 --> 00:35:03,839
what would be the alternative to rdf

00:35:06,000 --> 00:35:13,040
um oh you mean in in terms of

00:35:09,359 --> 00:35:17,839
passing back and forth in the um

00:35:13,040 --> 00:35:20,560
the biggest container our biggest graphs

00:35:17,839 --> 00:35:22,079
i don't know that we would need to pass

00:35:20,560 --> 00:35:23,839
the entire graph

00:35:22,079 --> 00:35:25,680
back and forth we decided to split the

00:35:23,839 --> 00:35:28,480
graph and we actually

00:35:25,680 --> 00:35:31,119
split the message and look at the whole

00:35:28,480 --> 00:35:33,040
graph as of one message and split it up

00:35:31,119 --> 00:35:34,240
and ship it across and reassemble it on

00:35:33,040 --> 00:35:36,720
the other side but

00:35:34,240 --> 00:35:38,720
realistically the rdf graph you can

00:35:36,720 --> 00:35:40,720
split into two parts and you really have

00:35:38,720 --> 00:35:43,119
two graphs you don't have

00:35:40,720 --> 00:35:44,640
you know one one part one graph and two

00:35:43,119 --> 00:35:44,960
pieces that you have to recombine to

00:35:44,640 --> 00:35:47,680
make

00:35:44,960 --> 00:35:48,720
work so we could have shipped this you

00:35:47,680 --> 00:35:50,400
could have just

00:35:48,720 --> 00:35:52,320
you know segmented it and shipped the

00:35:50,400 --> 00:35:55,839
data across the

00:35:52,320 --> 00:35:56,320
the network um in a different way and

00:35:55,839 --> 00:35:59,359
that probably

00:35:56,320 --> 00:36:03,440
greg hinley how does the graph structure

00:35:59,359 --> 00:36:03,440
help with representing configuration

00:36:05,040 --> 00:36:11,200
um there's a couple

00:36:09,440 --> 00:36:13,200
there's a couple of things that happen

00:36:11,200 --> 00:36:16,240
here we have uh if you think about it

00:36:13,200 --> 00:36:18,560
in multiple layers we were looking at

00:36:16,240 --> 00:36:20,079
initially just how do we keep track of

00:36:18,560 --> 00:36:23,359
what devices

00:36:20,079 --> 00:36:25,440
were tracking and when things occurred

00:36:23,359 --> 00:36:27,359
on those devices when did configurations

00:36:25,440 --> 00:36:30,960
change and things like that

00:36:27,359 --> 00:36:33,359
then as we move forward we look at

00:36:30,960 --> 00:36:34,960
the device configuration and that's you

00:36:33,359 --> 00:36:36,079
know that's the truth of what that

00:36:34,960 --> 00:36:38,160
device is doing and

00:36:36,079 --> 00:36:39,680
if you can parse that configuration you

00:36:38,160 --> 00:36:41,599
can then

00:36:39,680 --> 00:36:43,359
pull the pieces that are critical to

00:36:41,599 --> 00:36:45,200
what you want to work on

00:36:43,359 --> 00:36:48,000
and put those in the graphs you can then

00:36:45,200 --> 00:36:50,160
query so we could have parsed that

00:36:48,000 --> 00:36:52,839
information and actually had a project

00:36:50,160 --> 00:36:56,160
to do this parse the information and say

00:36:52,839 --> 00:36:58,160
um this is this graph this

00:36:56,160 --> 00:36:59,440
node in the network talks to all of

00:36:58,160 --> 00:37:04,079
these other nodes

00:36:59,440 --> 00:37:06,400
uh on you know various um levels of the

00:37:04,079 --> 00:37:08,079
the network uh you know is it talking is

00:37:06,400 --> 00:37:09,280
it plugged into something or is it this

00:37:08,079 --> 00:37:11,040
is actually just talking across the

00:37:09,280 --> 00:37:13,440
network

00:37:11,040 --> 00:37:15,119
and you're able to determine that by

00:37:13,440 --> 00:37:15,920
actually looking at the configuration

00:37:15,119 --> 00:37:18,960
file

00:37:15,920 --> 00:37:19,359
so the graph structure there really lets

00:37:18,960 --> 00:37:21,200
you

00:37:19,359 --> 00:37:22,720
say oh yeah this node thinks it's

00:37:21,200 --> 00:37:24,320
talking to this other node and the other

00:37:22,720 --> 00:37:25,760
node doesn't realize that

00:37:24,320 --> 00:37:27,359
there's nothing in the configuration and

00:37:25,760 --> 00:37:28,079
say it's talking something's talking to

00:37:27,359 --> 00:37:31,440
it

00:37:28,079 --> 00:37:32,079
um for example you might have firewall

00:37:31,440 --> 00:37:33,200
rules

00:37:32,079 --> 00:37:35,280
that would come into play and you'd be

00:37:33,200 --> 00:37:36,320
able to say oh this node's trying to

00:37:35,280 --> 00:37:38,160
talk to that node

00:37:36,320 --> 00:37:40,000
but that node has a firewall rule that

00:37:38,160 --> 00:37:42,640
stops it from happening

00:37:40,000 --> 00:37:43,440
so you can do some sorts of work like

00:37:42,640 --> 00:37:46,560
that

00:37:43,440 --> 00:37:49,280
to to uh understand it and

00:37:46,560 --> 00:37:50,320
you know really the configurations on

00:37:49,280 --> 00:37:52,960
those devices

00:37:50,320 --> 00:37:53,839
are talking about what the network looks

00:37:52,960 --> 00:37:55,920
like

00:37:53,839 --> 00:37:57,359
in some respects now some other things

00:37:55,920 --> 00:38:00,320
on this well adina

00:37:57,359 --> 00:38:00,640
asks you mentioned largest graphs can

00:38:00,320 --> 00:38:04,160
you

00:38:00,640 --> 00:38:06,800
comment on how big the rdf data set is

00:38:04,160 --> 00:38:06,800
in jenna

00:38:07,920 --> 00:38:10,240
um

00:38:11,359 --> 00:38:14,560
we ran

00:38:14,880 --> 00:38:18,720
it's it's not the it's not the total

00:38:17,839 --> 00:38:21,520
data set

00:38:18,720 --> 00:38:23,200
that that were large-ish in this case

00:38:21,520 --> 00:38:26,320
the the data set was

00:38:23,200 --> 00:38:29,680
um thousands of devices when we got done

00:38:26,320 --> 00:38:31,440
uh and many of those had um

00:38:29,680 --> 00:38:32,800
well you had devices and then devices

00:38:31,440 --> 00:38:34,240
would have uh

00:38:32,800 --> 00:38:36,240
components that talk to like you know

00:38:34,240 --> 00:38:38,400
what how did we talk to the device you

00:38:36,240 --> 00:38:39,920
know did we talk over ssh and

00:38:38,400 --> 00:38:41,839
what was the configuration so we could

00:38:39,920 --> 00:38:42,720
go back and do that again very quickly

00:38:41,839 --> 00:38:45,520
but

00:38:42,720 --> 00:38:47,119
um so you had thousands of devices and

00:38:45,520 --> 00:38:49,119
then each of the devices had

00:38:47,119 --> 00:38:50,320
uh references to their configurations

00:38:49,119 --> 00:38:51,440
and how when those were updated and

00:38:50,320 --> 00:38:55,599
things like that so

00:38:51,440 --> 00:38:59,280
the graph for a device gets fairly large

00:38:55,599 --> 00:39:03,520
when we started talking to those devices

00:38:59,280 --> 00:39:06,640
and we would send data over to the

00:39:03,520 --> 00:39:09,920
in to the agent and the agent would then

00:39:06,640 --> 00:39:12,480
uh get a lot of data from the device

00:39:09,920 --> 00:39:14,640
and if we at one time we were parsing

00:39:12,480 --> 00:39:15,680
some of that data on out on the agent to

00:39:14,640 --> 00:39:18,400
make some decisions

00:39:15,680 --> 00:39:18,960
so we were enhancing the graph and that

00:39:18,400 --> 00:39:21,359
graph

00:39:18,960 --> 00:39:22,880
along with the schema that talked about

00:39:21,359 --> 00:39:24,320
what things were supposed to be unique

00:39:22,880 --> 00:39:25,839
and whatnot

00:39:24,320 --> 00:39:27,839
got to the point where they were

00:39:25,839 --> 00:39:30,960
approaching this the limit

00:39:27,839 --> 00:39:33,359
of the default size for a

00:39:30,960 --> 00:39:34,240
for a kafka message and that's what i

00:39:33,359 --> 00:39:37,040
meant by largest

00:39:34,240 --> 00:39:37,760
so those those are actually in terms of

00:39:37,040 --> 00:39:41,119
a graph

00:39:37,760 --> 00:39:43,359
they're pretty small in terms of

00:39:41,119 --> 00:39:44,560
how big of the data package it is on on

00:39:43,359 --> 00:39:46,640
kafka that can be fairly

00:39:44,560 --> 00:39:48,480
large so it all depends on where you're

00:39:46,640 --> 00:39:52,320
looking so how many triples total

00:39:48,480 --> 00:39:52,320
and then we have to end it

00:39:53,440 --> 00:39:58,880
in the data set um how many

00:39:56,720 --> 00:40:00,400
i don't know how many triples actually

00:39:58,880 --> 00:40:01,200
were in the data set well i was just

00:40:00,400 --> 00:40:04,160
curious

00:40:01,200 --> 00:40:04,800
um it was i remember that it was large

00:40:04,160 --> 00:40:06,400
and um

00:40:04,800 --> 00:40:08,160
i was surprised that we actually thank

00:40:06,400 --> 00:40:11,839
you uh and

00:40:08,160 --> 00:40:11,839
i guess it's time for the next talk

00:40:14,000 --> 00:40:25,839
all right thank you

00:40:42,800 --> 00:40:44,880

YouTube URL: https://www.youtube.com/watch?v=0Y8uydFtq2w


