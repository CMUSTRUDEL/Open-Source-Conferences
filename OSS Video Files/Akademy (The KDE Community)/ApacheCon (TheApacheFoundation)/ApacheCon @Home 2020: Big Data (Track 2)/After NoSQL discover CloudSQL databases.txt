Title: After NoSQL discover CloudSQL databases
Publication date: 2020-10-21
Playlist: ApacheCon @Home 2020: Big Data (Track 2)
Description: 
	After NoSQL discover CloudSQL databases
Romain Manni-Bucau, Enrico Olivelli

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Application without persistence are rare and since some years the persistence layer is changing a lot. After years where SQL databases where the only ones, we saw NoSQL popping up bringing new concepts. More recently, the cloud changed again our paradigms with distributed computing and microservices. However, even with these brand new solutions, we still lack the flexibility of the SQL in terms of evolutivity and tooling. This is where HerdDB is entering into the game. Built as a SQL database, its foundations are Apache BookKeeper (bookie for close friends) and Apache Calcite. Therefore it brings to our architecture new solutions. This talk will first go through the challenges which led to creating HerdDB, then how it is designed and why it merges the best of both NoSQL and SQL worlds and finally we will illustrate its usage by two applications using very different deployment modes (from plain old bare metal to Kubernetes) using Apache Meecrowave and Geronimo Microprofile Stack.

Romain Manni-Bucau:
Joined the Apache EE family (OpenWebBeans, Meecrowave, Johnzon, BatchEE...) in 2011. My goal is to make development a detail of an idea becoming reality.
Enrico Olivelli:
Software Developer Manager at https://MagNews.com and https://EmailSuccess.com. PMC in Apache BookKeeper,ZooKeeper,Curator, Committer in Maven. OpenSource/ASF Enthusiast Initial creator of other OpenSource projects:HerdDB,BlazingCache,BlobIt
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:25,760 --> 00:00:28,160
okay

00:00:28,840 --> 00:00:35,920
okay hello everyone

00:00:32,559 --> 00:00:39,200
my name is eric olivelli

00:00:35,920 --> 00:00:42,840
i'm with roman let's talk about the

00:00:39,200 --> 00:00:45,840
after nosql discovery called sql

00:00:42,840 --> 00:00:45,840
databases

00:00:47,039 --> 00:00:50,960
let me introduce myself i'm marie

00:00:48,800 --> 00:00:52,640
colivelli i'm working at the immigrant

00:00:50,960 --> 00:00:55,680
success.com

00:00:52,640 --> 00:00:58,239
and my news.com i'm really

00:00:55,680 --> 00:00:59,039
open source enthusiastic contributing to

00:00:58,239 --> 00:01:02,960
several

00:00:59,039 --> 00:01:03,600
asf projects like bookkeeper the keeper

00:01:02,960 --> 00:01:06,320
curator

00:01:03,600 --> 00:01:07,439
the posterstack and maven you can find

00:01:06,320 --> 00:01:11,040
me on twitter and

00:01:07,439 --> 00:01:12,080
on github my colleague roman will

00:01:11,040 --> 00:01:15,680
introduce himself

00:01:12,080 --> 00:01:19,040
when i when it's time

00:01:15,680 --> 00:01:19,920
uh so what we have in our agenda uh we

00:01:19,040 --> 00:01:23,360
will talk about

00:01:19,920 --> 00:01:26,640
rdb uh we will see the advantages and

00:01:23,360 --> 00:01:29,759
challenges for embedded sql database

00:01:26,640 --> 00:01:32,960
we will run through the rdb

00:01:29,759 --> 00:01:36,240
model and our replication works

00:01:32,960 --> 00:01:36,960
we will see a few benchmarks results

00:01:36,240 --> 00:01:40,320
with

00:01:36,960 --> 00:01:43,119
the yahoo benchmark suite then we will

00:01:40,320 --> 00:01:44,000
talk about the gpa the java persistence

00:01:43,119 --> 00:01:47,920
api

00:01:44,000 --> 00:01:48,880
the jpi challenges how can you use jp

00:01:47,920 --> 00:01:52,799
opengpr

00:01:48,880 --> 00:01:53,680
with rdb and the challenges in switching

00:01:52,799 --> 00:01:56,880
from h2

00:01:53,680 --> 00:01:56,880
database to rdb

00:01:57,520 --> 00:02:04,560
okay so let's talk about rdb

00:02:01,439 --> 00:02:07,680
adb is the distributed sql database

00:02:04,560 --> 00:02:08,479
written in java it's open source it's

00:02:07,680 --> 00:02:11,680
apache 2

00:02:08,479 --> 00:02:15,760
licensed and you can find it on github

00:02:11,680 --> 00:02:20,720
with full jdbc support uh

00:02:15,760 --> 00:02:23,599
it speaks mysql compatible dialect

00:02:20,720 --> 00:02:24,319
you can run it embedded in the os client

00:02:23,599 --> 00:02:27,920
application

00:02:24,319 --> 00:02:30,560
uh and in standalone mode but

00:02:27,920 --> 00:02:32,319
we will talk about more uh running the

00:02:30,560 --> 00:02:33,680
database together with the client

00:02:32,319 --> 00:02:35,920
application

00:02:33,680 --> 00:02:37,519
uh supports high availability and

00:02:35,920 --> 00:02:41,360
horizontal scalability

00:02:37,519 --> 00:02:45,280
we will talk about replication later

00:02:41,360 --> 00:02:45,920
let me give you a brief overview of rdb

00:02:45,280 --> 00:02:49,680
history

00:02:45,920 --> 00:02:51,080
just because just another database why

00:02:49,680 --> 00:02:53,200
the project started inside

00:02:51,080 --> 00:02:54,480
imagesuccess.com as a replacement for

00:02:53,200 --> 00:02:57,920
mysql

00:02:54,480 --> 00:02:58,400
email success is an mta a mail transfer

00:02:57,920 --> 00:03:00,800
agent

00:02:58,400 --> 00:03:02,000
like send mail or postfix but it's

00:03:00,800 --> 00:03:04,480
written in java

00:03:02,000 --> 00:03:05,200
and it uses a database to store message

00:03:04,480 --> 00:03:08,400
state

00:03:05,200 --> 00:03:11,840
image success was designed

00:03:08,400 --> 00:03:15,120
to uh to deliver

00:03:11,840 --> 00:03:18,720
huge volumes of messages

00:03:15,120 --> 00:03:19,360
and so performance is very important for

00:03:18,720 --> 00:03:22,400
immersive

00:03:19,360 --> 00:03:23,280
image success in 2016 we started the

00:03:22,400 --> 00:03:26,480
development of

00:03:23,280 --> 00:03:28,720
image success cluster version and

00:03:26,480 --> 00:03:30,879
we needed a better solution for storing

00:03:28,720 --> 00:03:34,239
message state

00:03:30,879 --> 00:03:37,840
um what what

00:03:34,239 --> 00:03:40,799
were the um our requisites

00:03:37,840 --> 00:03:41,680
um we wanted an embedded database and

00:03:40,799 --> 00:03:44,879
the database

00:03:41,680 --> 00:03:47,760
should run together with this the java

00:03:44,879 --> 00:03:51,599
application or you know like sqlite

00:03:47,760 --> 00:03:53,840
or h2 database we wanted a real database

00:03:51,599 --> 00:03:56,879
that can

00:03:53,840 --> 00:03:59,439
manage in production several gigabytes

00:03:56,879 --> 00:04:03,040
of data

00:03:59,439 --> 00:04:05,840
and just because

00:04:03,040 --> 00:04:07,519
when you uh installed image success in

00:04:05,840 --> 00:04:10,720
the first versions you had to

00:04:07,519 --> 00:04:14,080
deal with email success and my sequel

00:04:10,720 --> 00:04:16,959
uh it would be very easier

00:04:14,080 --> 00:04:18,959
to just manage only image success or

00:04:16,959 --> 00:04:22,000
your application

00:04:18,959 --> 00:04:24,800
and we wanted a replicated database and

00:04:22,000 --> 00:04:26,240
the database we wanted it to scale out

00:04:24,800 --> 00:04:27,280
and offer high availability

00:04:26,240 --> 00:04:31,120
automatically

00:04:27,280 --> 00:04:34,320
uh in theory and this is practical

00:04:31,120 --> 00:04:37,040
in practice with email success.com

00:04:34,320 --> 00:04:37,919
uh in order to scale out email success

00:04:37,040 --> 00:04:40,880
and rtb

00:04:37,919 --> 00:04:43,120
you just only have to add the nodes and

00:04:40,880 --> 00:04:47,600
the application and all of the other

00:04:43,120 --> 00:04:47,600
components automatically scale

00:04:48,080 --> 00:04:55,360
we are talking about not using docker or

00:04:51,360 --> 00:05:00,880
kubernetes you can use it

00:04:55,360 --> 00:05:02,560
just a very simple java application

00:05:00,880 --> 00:05:04,800
solutions were already present on the

00:05:02,560 --> 00:05:07,919
market but nothing could meet

00:05:04,800 --> 00:05:09,039
both of the two requirements so an

00:05:07,919 --> 00:05:12,639
embedded database

00:05:09,039 --> 00:05:12,639
a distributed database

00:05:13,199 --> 00:05:20,400
we already have users in production

00:05:17,039 --> 00:05:23,199
and not only image success of course

00:05:20,400 --> 00:05:25,039
you immediately.com in standalone single

00:05:23,199 --> 00:05:28,240
machine and in cluster mode

00:05:25,039 --> 00:05:28,240
uses rdb

00:05:28,720 --> 00:05:35,520
for storing data

00:05:32,479 --> 00:05:37,840
it is only also the database for

00:05:35,520 --> 00:05:38,639
apache pulsar manager it's the default

00:05:37,840 --> 00:05:41,759
database

00:05:38,639 --> 00:05:43,919
apache poster manager runs on rdb and on

00:05:41,759 --> 00:05:47,280
postgre

00:05:43,919 --> 00:05:49,440
and we're using it and as metadata

00:05:47,280 --> 00:05:50,720
service on blobit it's a binary large

00:05:49,440 --> 00:05:54,240
object storage

00:05:50,720 --> 00:05:54,240
based on apache bookkeeper

00:05:54,400 --> 00:05:57,759
as a configuration and certificate store

00:05:56,560 --> 00:06:00,560
for a kara palace

00:05:57,759 --> 00:06:01,120
carpass proxy server it's a reverse

00:06:00,560 --> 00:06:04,639
proxy

00:06:01,120 --> 00:06:06,960
http reverse proxy and we're using

00:06:04,639 --> 00:06:08,880
it as a mysql replacement in a few other

00:06:06,960 --> 00:06:12,639
non-open source interim products at

00:06:08,880 --> 00:06:12,639
dnr.com it's my company

00:06:13,280 --> 00:06:19,440
there is also another kind of usage

00:06:16,400 --> 00:06:20,080
of rdb it's adb collection framework and

00:06:19,440 --> 00:06:23,039
we are using

00:06:20,080 --> 00:06:24,639
it on magnus.com i will talk about it

00:06:23,039 --> 00:06:28,160
later

00:06:24,639 --> 00:06:29,360
so let's talk about embedding the

00:06:28,160 --> 00:06:32,840
database

00:06:29,360 --> 00:06:37,280
in the client application you

00:06:32,840 --> 00:06:39,840
you you are not required to run airdb

00:06:37,280 --> 00:06:41,360
uh in this way you can run it standalone

00:06:39,840 --> 00:06:44,400
you can

00:06:41,360 --> 00:06:46,160
deploy but let's talk about the medic

00:06:44,400 --> 00:06:48,479
it in the client application this is

00:06:46,160 --> 00:06:52,560
very common for rdb

00:06:48,479 --> 00:06:55,520
the advantages you do not need initial

00:06:52,560 --> 00:06:56,000
deployment or management tools for the

00:06:55,520 --> 00:06:58,160
users

00:06:56,000 --> 00:06:59,120
in the case of image success it is

00:06:58,160 --> 00:07:01,759
really easy

00:06:59,120 --> 00:07:02,560
to install email success it's only one

00:07:01,759 --> 00:07:05,759
program

00:07:02,560 --> 00:07:09,120
um you don't have to

00:07:05,759 --> 00:07:12,800
manage a separate entity

00:07:09,120 --> 00:07:13,520
system the database is totally hidden to

00:07:12,800 --> 00:07:17,680
the user

00:07:13,520 --> 00:07:22,080
you have to only manage the application

00:07:17,680 --> 00:07:25,840
sometimes in products

00:07:22,080 --> 00:07:29,280
you know i want to install a application

00:07:25,840 --> 00:07:31,680
full football but

00:07:29,280 --> 00:07:33,599
you need the postgre you need my sequel

00:07:31,680 --> 00:07:36,960
uh

00:07:33,599 --> 00:07:40,160
it is really easier to have on

00:07:36,960 --> 00:07:42,400
one single bundle and the application

00:07:40,160 --> 00:07:43,199
is tested with only one version of the

00:07:42,400 --> 00:07:46,879
database

00:07:43,199 --> 00:07:49,840
and it is the same as in production um

00:07:46,879 --> 00:07:50,720
usually if you depend on my sequel or

00:07:49,840 --> 00:07:54,240
sql server

00:07:50,720 --> 00:07:56,960
or whatever other database technology

00:07:54,240 --> 00:07:58,240
uh probably you're going to write unit

00:07:56,960 --> 00:08:01,280
tests

00:07:58,240 --> 00:08:03,360
with h2 database

00:08:01,280 --> 00:08:06,160
and then you are running in production

00:08:03,360 --> 00:08:08,960
on with my sequel

00:08:06,160 --> 00:08:10,400
and also in the case of your success for

00:08:08,960 --> 00:08:11,440
instance we have to maintain the

00:08:10,400 --> 00:08:15,120
compatibility

00:08:11,440 --> 00:08:19,039
with the matrix of versions of my sequel

00:08:15,120 --> 00:08:19,039
that is really uh really big

00:08:19,440 --> 00:08:23,360
but yes if you can test the application

00:08:22,960 --> 00:08:26,800
with

00:08:23,360 --> 00:08:30,160
rdbe and you can run it in production

00:08:26,800 --> 00:08:33,760
the same code the same sql dialect it

00:08:30,160 --> 00:08:36,320
it is really simple to work

00:08:33,760 --> 00:08:38,719
it is easier to test for developers you

00:08:36,320 --> 00:08:39,839
can run the database in memory for unit

00:08:38,719 --> 00:08:43,279
tests

00:08:39,839 --> 00:08:46,399
if you have to run integration tests

00:08:43,279 --> 00:08:49,600
you have to start my sql

00:08:46,399 --> 00:08:53,120
and then run your tests and then tier

00:08:49,600 --> 00:08:55,120
down you can run the same database that

00:08:53,120 --> 00:08:59,040
you are using in production

00:08:55,120 --> 00:09:02,480
uh in your unique test

00:08:59,040 --> 00:09:03,360
but a it's not so simple to handle a

00:09:02,480 --> 00:09:05,040
database

00:09:03,360 --> 00:09:06,640
together with the application you have

00:09:05,040 --> 00:09:08,720
to deal with memory management

00:09:06,640 --> 00:09:10,800
yes because the database cannot choose

00:09:08,720 --> 00:09:12,160
all of the heap

00:09:10,800 --> 00:09:14,320
all of the resources of the client

00:09:12,160 --> 00:09:17,519
application um

00:09:14,320 --> 00:09:19,040
in particular ldb one of the most

00:09:17,519 --> 00:09:22,480
important features of rdb

00:09:19,040 --> 00:09:25,519
is to be able to set a

00:09:22,480 --> 00:09:28,880
limit on the amount of

00:09:25,519 --> 00:09:31,760
heap memory the database is using

00:09:28,880 --> 00:09:32,399
and this way you're sure that it won't

00:09:31,760 --> 00:09:36,000
hit

00:09:32,399 --> 00:09:39,440
all of the deep of your application

00:09:36,000 --> 00:09:42,880
um also it is not

00:09:39,440 --> 00:09:44,720
not very easy to tune the jvm

00:09:42,880 --> 00:09:47,200
if you run the database together with

00:09:44,720 --> 00:09:50,880
the application it's not easy

00:09:47,200 --> 00:09:54,880
but especially for uh

00:09:50,880 --> 00:09:58,320
simple applications uh

00:09:54,880 --> 00:10:01,680
it is really really useful

00:09:58,320 --> 00:10:04,320
to have this setup you have to have

00:10:01,680 --> 00:10:05,600
to provide sensible defaults and enabled

00:10:04,320 --> 00:10:08,560
automatic management

00:10:05,600 --> 00:10:10,399
routines by default yes because the

00:10:08,560 --> 00:10:13,360
application

00:10:10,399 --> 00:10:14,000
the developer of the application will

00:10:13,360 --> 00:10:17,040
focus

00:10:14,000 --> 00:10:19,120
the attention on the application

00:10:17,040 --> 00:10:21,200
and if the database is just only a

00:10:19,120 --> 00:10:24,240
library for you

00:10:21,200 --> 00:10:27,680
probably you

00:10:24,240 --> 00:10:31,279
you won't care that much and

00:10:27,680 --> 00:10:34,880
also usually when you are running

00:10:31,279 --> 00:10:37,200
mysql or other standalone databases

00:10:34,880 --> 00:10:38,240
separate from the application uh you

00:10:37,200 --> 00:10:40,399
have probably

00:10:38,240 --> 00:10:43,760
someone that is expert for the database

00:10:40,399 --> 00:10:46,880
and is going to tune it

00:10:43,760 --> 00:10:49,200
but if the database does not exist there

00:10:46,880 --> 00:10:51,920
is only your application

00:10:49,200 --> 00:10:53,279
okay the database should work well out

00:10:51,920 --> 00:10:55,920
of the box

00:10:53,279 --> 00:10:58,000
it must provide all of the tunables all

00:10:55,920 --> 00:11:01,279
of the configuration parameters

00:10:58,000 --> 00:11:03,839
to make it work really perfect for your

00:11:01,279 --> 00:11:06,160
workload but out of the box it should

00:11:03,839 --> 00:11:06,160
work

00:11:09,760 --> 00:11:16,240
while developing rdb you have to handle

00:11:13,600 --> 00:11:18,000
upgrade procedures totally automatically

00:11:16,240 --> 00:11:21,120
without manual integration

00:11:18,000 --> 00:11:23,360
uh that's because the database

00:11:21,120 --> 00:11:24,320
is just a library for the application

00:11:23,360 --> 00:11:26,560
developer

00:11:24,320 --> 00:11:28,000
so probably the application developer

00:11:26,560 --> 00:11:31,760
will will think about

00:11:28,000 --> 00:11:37,360
rolling upgrades and upgrade procedures

00:11:31,760 --> 00:11:37,360
and if the database needs some kind of

00:11:37,519 --> 00:11:42,800
change to the disk format some upgrade

00:11:40,959 --> 00:11:46,560
internal rewriting

00:11:42,800 --> 00:11:50,240
of data structure everything is to

00:11:46,560 --> 00:11:53,279
be totally automatic and transparent

00:11:50,240 --> 00:11:55,920
uh also you have to when

00:11:53,279 --> 00:11:57,440
we have to pay much attention to the web

00:11:55,920 --> 00:12:00,000
protocol

00:11:57,440 --> 00:12:01,600
to not introduce protocol changes or to

00:12:00,000 --> 00:12:05,120
these formats because

00:12:01,600 --> 00:12:08,639
yes as you can upgrade the database

00:12:05,120 --> 00:12:12,320
just by changing the the version

00:12:08,639 --> 00:12:14,399
in your maven palm file but you can also

00:12:12,320 --> 00:12:18,720
roll back

00:12:14,399 --> 00:12:18,720
and also in a cluster

00:12:19,200 --> 00:12:25,440
you have to pay much attention

00:12:22,800 --> 00:12:26,160
to what is happening during the the

00:12:25,440 --> 00:12:29,440
upgrade

00:12:26,160 --> 00:12:32,160
of the notes of the cluster and

00:12:29,440 --> 00:12:33,920
again if the application is bundled

00:12:32,160 --> 00:12:36,800
together with the database

00:12:33,920 --> 00:12:37,600
um you are going to applicat update the

00:12:36,800 --> 00:12:40,079
application

00:12:37,600 --> 00:12:42,320
and upgrade the database at the same

00:12:40,079 --> 00:12:42,320
time

00:12:45,760 --> 00:12:50,880
replication high availability and

00:12:48,160 --> 00:12:54,240
scalability

00:12:50,880 --> 00:12:56,560
um you know we are talking about

00:12:54,240 --> 00:13:00,240
working even in case of temporary or

00:12:56,560 --> 00:13:00,240
permanent loss of machines

00:13:01,600 --> 00:13:07,120
um you also would like to keep data

00:13:04,480 --> 00:13:11,760
closer to the clients

00:13:07,120 --> 00:13:11,760
let me explain more in this topic

00:13:12,160 --> 00:13:19,600
you have a cluster of machines say

00:13:15,760 --> 00:13:20,480
four or five nodes but the application

00:13:19,600 --> 00:13:23,040
is running

00:13:20,480 --> 00:13:23,920
on the these machines and the database

00:13:23,040 --> 00:13:26,720
as well

00:13:23,920 --> 00:13:28,000
and you would like that the data that

00:13:26,720 --> 00:13:30,880
the application

00:13:28,000 --> 00:13:32,839
that each node of the application is

00:13:30,880 --> 00:13:36,320
working more uh

00:13:32,839 --> 00:13:39,360
uh frequently uh

00:13:36,320 --> 00:13:41,360
moves near to the application uh this is

00:13:39,360 --> 00:13:42,399
actually possible in image successfully

00:13:41,360 --> 00:13:46,959
for instance

00:13:42,399 --> 00:13:50,079
um because um

00:13:46,959 --> 00:13:54,880
yes uh the database can be moved

00:13:50,079 --> 00:13:57,360
nearby the the users of the tables

00:13:54,880 --> 00:13:59,040
uh you also do not want shared disks or

00:13:57,360 --> 00:14:02,160
network file systems

00:13:59,040 --> 00:14:03,120
uh you only want you know that the

00:14:02,160 --> 00:14:05,680
network is

00:14:03,120 --> 00:14:08,959
connecting the nodes of your application

00:14:05,680 --> 00:14:08,959
and this should be enough

00:14:11,199 --> 00:14:15,519
you would like to be able to scale out

00:14:13,839 --> 00:14:16,560
just by adding machines to the

00:14:15,519 --> 00:14:18,399
application

00:14:16,560 --> 00:14:19,600
and deal only with the application and

00:14:18,399 --> 00:14:22,639
not the database

00:14:19,600 --> 00:14:24,000
uh this is true for instance in cara

00:14:22,639 --> 00:14:26,720
pass proxy

00:14:24,000 --> 00:14:27,360
or even in a success you add nodes to

00:14:26,720 --> 00:14:30,880
the

00:14:27,360 --> 00:14:35,360
reverse proxy and then you have

00:14:30,880 --> 00:14:38,639
more uh scalability in the database

00:14:35,360 --> 00:14:43,360
replication and high availability

00:14:38,639 --> 00:14:43,360
challenges for a embedded database

00:14:43,440 --> 00:14:47,199
yes if you are running the database

00:14:45,440 --> 00:14:49,680
together with the application

00:14:47,199 --> 00:14:50,959
uh you have to handle gracefully uh

00:14:49,680 --> 00:14:54,320
temporary failures

00:14:50,959 --> 00:14:55,279
long dc poses for the application or the

00:14:54,320 --> 00:14:58,160
database

00:14:55,279 --> 00:14:58,800
or simply the application restart uh yes

00:14:58,160 --> 00:15:01,920
because

00:14:58,800 --> 00:15:04,320
if the operator restarts the application

00:15:01,920 --> 00:15:06,079
he is also restarting the database and

00:15:04,320 --> 00:15:10,160
in the cluster

00:15:06,079 --> 00:15:13,600
if you restart one node of the database

00:15:10,160 --> 00:15:16,959
probably uh this will have an affect

00:15:13,600 --> 00:15:20,959
other nodes so we'll

00:15:16,959 --> 00:15:23,120
have to uh become responsible for that

00:15:20,959 --> 00:15:26,240
part of the database

00:15:23,120 --> 00:15:29,839
so the system must be tuned

00:15:26,240 --> 00:15:32,880
and be able to deal with this

00:15:29,839 --> 00:15:35,759
as much as gracefully possible

00:15:32,880 --> 00:15:37,279
you need some external source of truth

00:15:35,759 --> 00:15:39,040
in this case we are using apache

00:15:37,279 --> 00:15:42,240
zookeeper

00:15:39,040 --> 00:15:43,279
yes because uh if any of the nodes of

00:15:42,240 --> 00:15:46,560
the application

00:15:43,279 --> 00:15:50,320
may disappear or

00:15:46,560 --> 00:15:53,600
crash um we need

00:15:50,320 --> 00:15:56,800
some reference and so uh

00:15:53,600 --> 00:16:00,560
in the case of airdb you can run

00:15:56,800 --> 00:16:02,880
zookeeper nodes on the same machines

00:16:00,560 --> 00:16:06,079
but not together with the application

00:16:02,880 --> 00:16:09,360
this is not suggested

00:16:06,079 --> 00:16:10,560
also it's not trivial to understand the

00:16:09,360 --> 00:16:13,839
storage topology

00:16:10,560 --> 00:16:16,399
uh because uh

00:16:13,839 --> 00:16:16,880
data uh flows through the bright high

00:16:16,399 --> 00:16:21,040
log

00:16:16,880 --> 00:16:24,880
uh we do keeper and the data

00:16:21,040 --> 00:16:28,000
have separate replication mechanisms

00:16:24,880 --> 00:16:31,199
because in the right part you are

00:16:28,000 --> 00:16:34,800
writing to bookkeeper and bookkeeper

00:16:31,199 --> 00:16:38,720
replicates synchronously data

00:16:34,800 --> 00:16:40,800
and then all of the data

00:16:38,720 --> 00:16:42,399
will eventually be replicated towards

00:16:40,800 --> 00:16:45,680
the other nodes i'm not

00:16:42,399 --> 00:16:46,959
going to talk more more deeply about

00:16:45,680 --> 00:16:49,360
replication rdb

00:16:46,959 --> 00:16:50,320
but if you are interested you can check

00:16:49,360 --> 00:16:52,959
it on

00:16:50,320 --> 00:16:55,839
on github on the wiki or you can ask on

00:16:52,959 --> 00:16:59,360
the main list and we will be happy to

00:16:55,839 --> 00:17:01,600
to share let let's see

00:16:59,360 --> 00:17:03,360
uh the internal structures of health

00:17:01,600 --> 00:17:06,079
beam

00:17:03,360 --> 00:17:08,400
the database is partitioned into table

00:17:06,079 --> 00:17:10,720
spaces a tablespace is a group of tables

00:17:08,400 --> 00:17:14,079
very like to a database in my sql world

00:17:10,720 --> 00:17:16,559
but in ldb you only have one database

00:17:14,079 --> 00:17:19,120
and tablespaces yes because with only

00:17:16,559 --> 00:17:22,240
one data source or jdbc url

00:17:19,120 --> 00:17:23,439
one single java sql connection in terms

00:17:22,240 --> 00:17:25,600
of jdbc

00:17:23,439 --> 00:17:26,640
you can connect to multiple table spaces

00:17:25,600 --> 00:17:30,000
and servers

00:17:26,640 --> 00:17:30,559
so the driver automatically understands

00:17:30,000 --> 00:17:33,840
that

00:17:30,559 --> 00:17:33,840
you are going to

00:17:34,240 --> 00:17:38,880
to ask for data on tablespace and

00:17:37,760 --> 00:17:41,520
connect to the

00:17:38,880 --> 00:17:43,840
the right servers with a single

00:17:41,520 --> 00:17:47,280
javascript connection

00:17:43,840 --> 00:17:50,400
transactions transactions must span

00:17:47,280 --> 00:17:53,440
tables of the same table space this is

00:17:50,400 --> 00:17:54,960
by design because basically tablespace

00:17:53,440 --> 00:17:59,120
is a variety log

00:17:54,960 --> 00:18:01,200
with tables and so

00:17:59,120 --> 00:18:03,120
all of the changes in the transaction

00:18:01,200 --> 00:18:05,440
must belong to the same

00:18:03,120 --> 00:18:07,120
right analog so if you start a

00:18:05,440 --> 00:18:10,240
transaction you start writing

00:18:07,120 --> 00:18:13,840
data um you can only touch tables

00:18:10,240 --> 00:18:17,280
from the same table space and joins

00:18:13,840 --> 00:18:20,559
queries cannot refer to tables

00:18:17,280 --> 00:18:25,039
of the same table space

00:18:20,559 --> 00:18:29,120
this is only a limitation

00:18:25,039 --> 00:18:31,600
for efficiency we could

00:18:29,120 --> 00:18:32,880
implement really easily uh

00:18:31,600 --> 00:18:36,640
crosstablespace

00:18:32,880 --> 00:18:40,240
joins but actually no one

00:18:36,640 --> 00:18:40,240
uh ever asked for it

00:18:40,320 --> 00:18:44,400
uh a tablespace must reside entirely on

00:18:43,360 --> 00:18:47,120
every machine

00:18:44,400 --> 00:18:48,000
assigned to it uh this is only for

00:18:47,120 --> 00:18:52,640
performances

00:18:48,000 --> 00:18:54,799
uh this is the standard mode of rdb um

00:18:52,640 --> 00:18:56,320
during the summer we released the new

00:18:54,799 --> 00:18:59,600
model for ldb

00:18:56,320 --> 00:19:01,919
that stores data on bookkeeper and

00:18:59,600 --> 00:19:03,200
in this in that case the data will be on

00:19:01,919 --> 00:19:07,280
boot keeper and not

00:19:03,200 --> 00:19:10,400
on rdb machines a table

00:19:07,280 --> 00:19:12,720
a table in rdb is just only a key value

00:19:10,400 --> 00:19:13,760
dictionary that maps a byte array to a

00:19:12,720 --> 00:19:17,440
byte array

00:19:13,760 --> 00:19:20,720
but clients use jdbc api

00:19:17,440 --> 00:19:22,880
and sql language and so we

00:19:20,720 --> 00:19:24,160
created a sql layer on top the key

00:19:22,880 --> 00:19:28,000
values structure

00:19:24,160 --> 00:19:31,280
the key is the primary key of the record

00:19:28,000 --> 00:19:34,640
and the value is the is made of

00:19:31,280 --> 00:19:35,440
uh all of the other columns the primary

00:19:34,640 --> 00:19:38,799
key and

00:19:35,440 --> 00:19:42,320
columns are serialized

00:19:38,799 --> 00:19:46,320
in a way that it is easy to access

00:19:42,320 --> 00:19:49,679
data without

00:19:46,320 --> 00:19:50,799
performing copies in memory we are using

00:19:49,679 --> 00:19:54,000
a particle site

00:19:50,799 --> 00:19:55,360
for sql work for planner the parser and

00:19:54,000 --> 00:19:57,520
the planner

00:19:55,360 --> 00:19:59,280
but we also were also working on a

00:19:57,520 --> 00:20:03,280
smaller j sql bars

00:19:59,280 --> 00:20:06,000
parser based stack with a particle site

00:20:03,280 --> 00:20:06,480
you have the full power of sql and you

00:20:06,000 --> 00:20:09,039
have

00:20:06,480 --> 00:20:11,280
that great uh cost based the optimizer

00:20:09,039 --> 00:20:14,480
the volcano planner

00:20:11,280 --> 00:20:17,840
but cassata is very big

00:20:14,480 --> 00:20:20,159
and it it comes with

00:20:17,840 --> 00:20:20,960
lots of third-party dependencies and

00:20:20,159 --> 00:20:24,480
sometimes

00:20:20,960 --> 00:20:25,280
only with for only uh very simple

00:20:24,480 --> 00:20:27,120
queries

00:20:25,280 --> 00:20:28,480
you don't need all of the power of a

00:20:27,120 --> 00:20:32,559
particular site

00:20:28,480 --> 00:20:32,559
so we are working on a smaller stack

00:20:32,840 --> 00:20:40,720
um a table a table

00:20:36,080 --> 00:20:44,480
uh is made of data pages um

00:20:40,720 --> 00:20:45,039
a database is only a bunch of records

00:20:44,480 --> 00:20:47,600
indexed

00:20:45,039 --> 00:20:49,679
by the primary key we have the core data

00:20:47,600 --> 00:20:50,159
structure in rdb that's the primary key

00:20:49,679 --> 00:20:54,320
index

00:20:50,159 --> 00:20:57,039
is basically a b link tree

00:20:54,320 --> 00:20:58,720
and that maps a primary key value to the

00:20:57,039 --> 00:21:00,880
id of the data page

00:20:58,720 --> 00:21:02,320
and we have the dirty page buffer it's a

00:21:00,880 --> 00:21:04,880
data page or more

00:21:02,320 --> 00:21:06,320
than one that is open for write and

00:21:04,880 --> 00:21:09,600
secondary indexes

00:21:06,320 --> 00:21:10,480
uh simply map values indexed values to

00:21:09,600 --> 00:21:13,760
the set of

00:21:10,480 --> 00:21:16,480
primary key values that are

00:21:13,760 --> 00:21:17,600
bound to that value so this way when you

00:21:16,480 --> 00:21:20,640
move

00:21:17,600 --> 00:21:24,240
a record from a page to another page

00:21:20,640 --> 00:21:25,360
um you do not have to update secondary

00:21:24,240 --> 00:21:28,240
indexes

00:21:25,360 --> 00:21:28,799
uh for instance rdb collection framework

00:21:28,240 --> 00:21:31,280
uses

00:21:28,799 --> 00:21:32,960
the directly the key value structure

00:21:31,280 --> 00:21:36,480
without the sql layer

00:21:32,960 --> 00:21:39,679
um it's like mapdb

00:21:36,480 --> 00:21:43,039
uh the only the very big difference with

00:21:39,679 --> 00:21:46,480
mapdb is uh that ldb

00:21:43,039 --> 00:21:50,240
as this internal um are the

00:21:46,480 --> 00:21:54,320
limit on memory um so you can

00:21:50,240 --> 00:21:59,760
basically start a java map um

00:21:54,320 --> 00:22:01,600
and you can set a maximum usage of java

00:21:59,760 --> 00:22:03,840
let's talk about briefly about the

00:22:01,600 --> 00:22:06,720
replication how it works

00:22:03,840 --> 00:22:08,240
an rgb cluster is made of rdb servers

00:22:06,720 --> 00:22:11,760
apache boot keyboard servers

00:22:08,240 --> 00:22:15,280
bookies and apache zookeeper servers

00:22:11,760 --> 00:22:17,919
you can use existing bookkeeper server

00:22:15,280 --> 00:22:19,360
cluster like if you are you running

00:22:17,919 --> 00:22:22,799
apache pulsar

00:22:19,360 --> 00:22:23,679
or or other products for instance image

00:22:22,799 --> 00:22:26,480
success

00:22:23,679 --> 00:22:27,840
runs a boot keeper cluster and also

00:22:26,480 --> 00:22:31,760
magnus

00:22:27,840 --> 00:22:33,360
you can you can use them each tablespace

00:22:31,760 --> 00:22:36,400
alexa leader node

00:22:33,360 --> 00:22:38,080
so for each tablespace you have a list

00:22:36,400 --> 00:22:41,039
of replica nodes

00:22:38,080 --> 00:22:42,880
one of them is elected as leader uh we

00:22:41,039 --> 00:22:45,039
are using bookkeeper

00:22:42,880 --> 00:22:46,320
that guarantees the consistency of the

00:22:45,039 --> 00:22:48,559
cluster

00:22:46,320 --> 00:22:50,320
and zookeeper and this metadata and

00:22:48,559 --> 00:22:54,720
provides service discovery

00:22:50,320 --> 00:22:57,200
both for ldb and for bookkeeper as well

00:22:54,720 --> 00:22:59,520
very briefly how the replication part

00:22:57,200 --> 00:23:01,840
works

00:22:59,520 --> 00:23:02,880
clients talk only to the leader of the

00:23:01,840 --> 00:23:04,640
table space

00:23:02,880 --> 00:23:06,159
they use the keeper for service

00:23:04,640 --> 00:23:10,400
discovery

00:23:06,159 --> 00:23:14,400
and when they run chain

00:23:10,400 --> 00:23:17,520
dml data manipulation language

00:23:14,400 --> 00:23:19,200
uh statements uh the changes are written

00:23:17,520 --> 00:23:20,720
to the bookies that represent the

00:23:19,200 --> 00:23:23,600
brighter log

00:23:20,720 --> 00:23:25,200
so bookkeeper replicates data

00:23:23,600 --> 00:23:26,799
synchronously and then

00:23:25,200 --> 00:23:29,679
acknowledges the right to the leader

00:23:26,799 --> 00:23:33,120
node and the other nodes the replicas

00:23:29,679 --> 00:23:36,559
of the table space simply tail

00:23:33,120 --> 00:23:39,840
they continuously follow read the log

00:23:36,559 --> 00:23:43,600
and apply the changes locally

00:23:39,840 --> 00:23:45,760
it's a simple asynchronous replication

00:23:43,600 --> 00:23:46,640
and when a follower is promoted to

00:23:45,760 --> 00:23:49,279
leader

00:23:46,640 --> 00:23:50,000
it leverages a feature of bookkeeper

00:23:49,279 --> 00:23:54,080
it's

00:23:50,000 --> 00:23:57,760
fencing and basically the old leader

00:23:54,080 --> 00:24:01,679
is fenced out and cannot

00:23:57,760 --> 00:24:04,799
make progress in updating the

00:24:01,679 --> 00:24:07,120
the the the contents of the table

00:24:04,799 --> 00:24:08,400
even in case of split brains and

00:24:07,120 --> 00:24:11,039
partitions

00:24:08,400 --> 00:24:11,520
and so the overall consistency of the

00:24:11,039 --> 00:24:15,600
system

00:24:11,520 --> 00:24:18,880
is always preserved

00:24:15,600 --> 00:24:22,159
uh just one slide

00:24:18,880 --> 00:24:25,840
about uh benchmarks uh when we switched

00:24:22,159 --> 00:24:28,960
from my sequel to rdb image success we

00:24:25,840 --> 00:24:29,840
do not care about performances and we

00:24:28,960 --> 00:24:34,159
use the

00:24:29,840 --> 00:24:37,039
es ecsb benchmarks and also

00:24:34,159 --> 00:24:38,720
internal image success benchmarks but as

00:24:37,039 --> 00:24:44,159
you can see in this slide

00:24:38,720 --> 00:24:44,159
this slide refers to rdb

00:24:44,200 --> 00:24:52,320
0.19 and my sql 5.7

00:24:49,120 --> 00:24:55,520
on their machine bare metal machines

00:24:52,320 --> 00:25:01,039
on ssds disks

00:24:55,520 --> 00:25:04,640
and java 13 and as you can see um

00:25:01,039 --> 00:25:07,679
or rdb outperforms my sequel in

00:25:04,640 --> 00:25:10,480
all of the workloads uh but we

00:25:07,679 --> 00:25:11,440
more cared about the latest workflow i

00:25:10,480 --> 00:25:15,840
mean success

00:25:11,440 --> 00:25:18,240
workload um

00:25:15,840 --> 00:25:19,760
yes and we are constantly uh running

00:25:18,240 --> 00:25:22,799
these benchmarks

00:25:19,760 --> 00:25:24,960
uh inside the development of immune

00:25:22,799 --> 00:25:25,679
success in order to be sure that the any

00:25:24,960 --> 00:25:28,320
kind of

00:25:25,679 --> 00:25:31,200
changes towards b does not impact the

00:25:28,320 --> 00:25:31,200
performances

00:25:31,919 --> 00:25:34,880
so it's time

00:25:35,039 --> 00:25:43,200
for roman hello everyone

00:25:39,840 --> 00:25:45,840
i present myself very quickly so

00:25:43,200 --> 00:25:46,720
i'm a contributor and committee at

00:25:45,840 --> 00:25:50,400
apache since

00:25:46,720 --> 00:25:50,400
a lot of years now

00:25:50,880 --> 00:25:54,080
and i'm working now for upek which is a

00:25:53,440 --> 00:25:57,520
company

00:25:54,080 --> 00:25:58,240
company doing let's say lots of services

00:25:57,520 --> 00:26:01,279
around the

00:25:58,240 --> 00:26:05,679
apache to summarize it um

00:26:01,279 --> 00:26:09,120
about rdb uh i discovered it some

00:26:05,679 --> 00:26:12,559
months ago i think now when aniko

00:26:09,120 --> 00:26:16,799
spoke about it to me and

00:26:12,559 --> 00:26:19,919
i was interested about it mainly because

00:26:16,799 --> 00:26:21,600
we have an application

00:26:19,919 --> 00:26:23,440
which is using a database for

00:26:21,600 --> 00:26:25,440
referential data

00:26:23,440 --> 00:26:26,720
and the main issue with this kind of

00:26:25,440 --> 00:26:31,120
architecture is

00:26:26,720 --> 00:26:33,120
you need a database for a small amount

00:26:31,120 --> 00:26:34,960
of data

00:26:33,120 --> 00:26:37,279
so what's interesting with rdb is you

00:26:34,960 --> 00:26:41,279
get from tolerance

00:26:37,279 --> 00:26:43,279
scalability etc without having

00:26:41,279 --> 00:26:46,159
to pay for a real database which is

00:26:43,279 --> 00:26:46,159
quite expensive

00:26:49,279 --> 00:26:57,120
so the part time i have now is mainly

00:26:53,600 --> 00:26:57,760
about the journey to make rdb gdbc

00:26:57,120 --> 00:27:01,200
driver

00:26:57,760 --> 00:27:03,039
compliant with a gpa

00:27:01,200 --> 00:27:04,640
because that's what most applications

00:27:03,039 --> 00:27:09,200
are using

00:27:04,640 --> 00:27:12,799
so um so gpa stands for java persistence

00:27:09,200 --> 00:27:15,919
api uh it's mainly

00:27:12,799 --> 00:27:19,679
the java ee

00:27:15,919 --> 00:27:23,919
api to bind the database on a java model

00:27:19,679 --> 00:27:26,399
and project um gdbc on the

00:27:23,919 --> 00:27:28,000
another end stands for java database

00:27:26,399 --> 00:27:30,080
connectivity it's just the connection to

00:27:28,000 --> 00:27:34,240
the database and the way to

00:27:30,080 --> 00:27:38,159
issue statements to the database so

00:27:34,240 --> 00:27:41,919
naturally gdbc is lower level than gpa

00:27:38,159 --> 00:27:44,480
and gpa is built on top of gdbc

00:27:41,919 --> 00:27:45,120
today a lot of applications are using

00:27:44,480 --> 00:27:47,360
gpa

00:27:45,120 --> 00:27:49,039
because it's simpler to cut and it

00:27:47,360 --> 00:27:50,960
integrates better with frameworks

00:27:49,039 --> 00:27:54,399
because it is based on bojo

00:27:50,960 --> 00:27:57,440
so it works with mappers with

00:27:54,399 --> 00:27:59,120
automatic discovery of the model with

00:27:57,440 --> 00:28:01,760
schemas etc

00:27:59,120 --> 00:28:03,679
whereas if you are using gdbc you need

00:28:01,760 --> 00:28:06,480
to write it in string or

00:28:03,679 --> 00:28:07,360
do it manually another thing which is

00:28:06,480 --> 00:28:09,760
interesting with

00:28:07,360 --> 00:28:11,840
gpa is it is portable across databases

00:28:09,760 --> 00:28:13,039
so if you write code you can run it on

00:28:11,840 --> 00:28:17,840
my scroll

00:28:13,039 --> 00:28:17,840
on oracle on rdb it's there

00:28:18,720 --> 00:28:28,000
so really the goal is to be able to run

00:28:22,320 --> 00:28:31,279
with gpa using mdb database

00:28:28,000 --> 00:28:34,799
it's not really a question so

00:28:31,279 --> 00:28:38,159
um in terms of setup or

00:28:34,799 --> 00:28:42,399
a change from an application using gpa

00:28:38,159 --> 00:28:42,399
to an application using gpa with rdb

00:28:42,799 --> 00:28:47,120
it does not need anything specific

00:28:46,159 --> 00:28:49,279
actually so you don't

00:28:47,120 --> 00:28:50,720
change your code that's one of the goal

00:28:49,279 --> 00:28:53,360
and it's reached

00:28:50,720 --> 00:28:54,080
you don't change your the configuration

00:28:53,360 --> 00:28:57,279
except the

00:28:54,080 --> 00:28:58,880
database connection indeed but if you

00:28:57,279 --> 00:29:01,120
run it just like that

00:28:58,880 --> 00:29:02,399
it does not work so if you run on

00:29:01,120 --> 00:29:04,960
hibernate for instance

00:29:02,399 --> 00:29:05,679
it will not work because rdb is not

00:29:04,960 --> 00:29:09,520
known

00:29:05,679 --> 00:29:09,520
by uh ibernet

00:29:09,760 --> 00:29:15,200
so the challenges we encountered

00:29:12,080 --> 00:29:15,200
starting to work on that

00:29:16,720 --> 00:29:21,200
were mainly about the fact gpa runtime

00:29:19,600 --> 00:29:24,559
rybanite eclipse link

00:29:21,200 --> 00:29:27,919
open gpa is issuing

00:29:24,559 --> 00:29:28,720
a statements so it is converting the

00:29:27,919 --> 00:29:32,720
java code

00:29:28,720 --> 00:29:35,840
java model to produce two statements

00:29:32,720 --> 00:29:38,399
and this conversion seems

00:29:35,840 --> 00:29:39,520
portable and just using sql it is

00:29:38,399 --> 00:29:42,880
portable right

00:29:39,520 --> 00:29:46,240
but actually it is not because

00:29:42,880 --> 00:29:49,000
all databases have custom types so

00:29:46,240 --> 00:29:51,360
worker in one database can be a worker

00:29:49,000 --> 00:29:54,000
255 in another one

00:29:51,360 --> 00:29:56,399
it can be something else in another

00:29:54,000 --> 00:29:58,960
database

00:29:56,399 --> 00:30:00,320
there are specific functions we have

00:29:58,960 --> 00:30:03,520
specific

00:30:00,320 --> 00:30:06,960
escaping delimiters things like that

00:30:03,520 --> 00:30:10,240
that's why all implementations of

00:30:06,960 --> 00:30:12,559
specification gpa

00:30:10,240 --> 00:30:14,240
are abstracting this layer so the

00:30:12,559 --> 00:30:17,679
conversion between the java model

00:30:14,240 --> 00:30:18,399
and the statements so for ibnet it is a

00:30:17,679 --> 00:30:21,679
dialect

00:30:18,399 --> 00:30:23,039
for opengpa it is a dictionary if i keep

00:30:21,679 --> 00:30:25,600
thinking it's a platform but

00:30:23,039 --> 00:30:28,159
it's just an abstraction to create the

00:30:25,600 --> 00:30:28,159
statements

00:30:28,720 --> 00:30:33,760
another thing which is important is that

00:30:31,520 --> 00:30:37,200
gpa is handling relationship

00:30:33,760 --> 00:30:40,000
you can say that this bojo is really

00:30:37,200 --> 00:30:40,399
is in relationship with this one when

00:30:40,000 --> 00:30:43,840
when

00:30:40,399 --> 00:30:46,960
n relationship and m it's there

00:30:43,840 --> 00:30:48,240
and it is using joints to translate it

00:30:46,960 --> 00:30:51,600
in sequel

00:30:48,240 --> 00:30:54,960
so john must be supported by

00:30:51,600 --> 00:30:54,960
the rdb either

00:30:55,679 --> 00:31:04,000
and one surprise we got was that

00:30:59,760 --> 00:31:04,000
rdb is expecting lowercase

00:31:04,399 --> 00:31:10,080
values for the columns and tables

00:31:08,320 --> 00:31:12,480
whereas if you check all the

00:31:10,080 --> 00:31:13,919
dictionaries of open gpa they are always

00:31:12,480 --> 00:31:19,840
insensitive

00:31:13,919 --> 00:31:19,840
it was a small point we had to face

00:31:20,240 --> 00:31:24,640
and finally databases have reserved

00:31:23,279 --> 00:31:29,039
keywords

00:31:24,640 --> 00:31:31,039
or words so ever you

00:31:29,039 --> 00:31:32,320
prevent your application to use these

00:31:31,039 --> 00:31:35,360
words like

00:31:32,320 --> 00:31:39,200
user for example which is often reserved

00:31:35,360 --> 00:31:40,000
or you delimit all columns and table

00:31:39,200 --> 00:31:41,679
names

00:31:40,000 --> 00:31:44,559
to ensure there is no conflict with

00:31:41,679 --> 00:31:44,559
reserved words

00:31:44,960 --> 00:31:51,440
in our case we pick the delimiters

00:31:48,240 --> 00:31:51,440
we'll see it later

00:31:52,159 --> 00:32:00,000
so a quick example so i have a table

00:31:56,640 --> 00:32:03,679
an entity which has almost

00:32:00,000 --> 00:32:06,880
nothing except a few fields and tags

00:32:03,679 --> 00:32:09,039
and tags like in a blog so it's it's a

00:32:06,880 --> 00:32:10,159
collection table so automatically gpa

00:32:09,039 --> 00:32:14,080
will create a table

00:32:10,159 --> 00:32:17,440
in relation in relationship to the

00:32:14,080 --> 00:32:19,679
entity and

00:32:17,440 --> 00:32:21,519
we can ask to gpa to automatically

00:32:19,679 --> 00:32:23,760
create these tables we don't have to do

00:32:21,519 --> 00:32:27,120
the ddl ourself

00:32:23,760 --> 00:32:28,000
so typically if we ask gpa to create the

00:32:27,120 --> 00:32:30,720
tables it will

00:32:28,000 --> 00:32:31,200
issue this kind of statement so kite

00:32:30,720 --> 00:32:34,480
table

00:32:31,200 --> 00:32:35,760
for the entity no big surprise except we

00:32:34,480 --> 00:32:39,440
can see that there are

00:32:35,760 --> 00:32:44,399
the types of columns

00:32:39,440 --> 00:32:47,519
and we can see oh it's too small

00:32:44,399 --> 00:32:48,480
yeah it's not very important not sure

00:32:47,519 --> 00:32:51,760
you can

00:32:48,480 --> 00:32:51,760
is it better yeah

00:32:52,960 --> 00:32:57,519
so we can see that the type some

00:32:55,919 --> 00:33:00,559
constraint

00:32:57,519 --> 00:33:01,600
but we can also see the tag table

00:33:00,559 --> 00:33:03,679
created

00:33:01,600 --> 00:33:06,000
automatically it is not in the code it

00:33:03,679 --> 00:33:08,320
is just in the

00:33:06,000 --> 00:33:11,440
in the database and we can see it is

00:33:08,320 --> 00:33:14,159
creating an identification column

00:33:11,440 --> 00:33:15,919
to the entity and element is the value

00:33:14,159 --> 00:33:19,519
of the tag

00:33:15,919 --> 00:33:22,799
so indeed functionally you can guess

00:33:19,519 --> 00:33:25,039
you'll want the tags for an entity

00:33:22,799 --> 00:33:25,840
so to do that it will do something like

00:33:25,039 --> 00:33:29,679
select

00:33:25,840 --> 00:33:32,799
select all tags uh where the

00:33:29,679 --> 00:33:36,240
entity id is uh

00:33:32,799 --> 00:33:41,840
to be efficient it needs an index

00:33:36,240 --> 00:33:41,840
so it also create the required index

00:33:42,080 --> 00:33:46,159
so all that is it's created by the gpa

00:33:44,720 --> 00:33:49,039
layer but it means

00:33:46,159 --> 00:33:49,600
the adb driver must be able to

00:33:49,039 --> 00:33:52,960
understand

00:33:49,600 --> 00:33:56,159
all these statements

00:33:52,960 --> 00:33:58,960
uh yeah and then it unveils indeed

00:33:56,159 --> 00:33:59,760
the create statement so insert update

00:33:58,960 --> 00:34:03,200
select

00:33:59,760 --> 00:34:04,960
delete uh just what's interesting in

00:34:03,200 --> 00:34:06,240
these statements is the fact that the

00:34:04,960 --> 00:34:09,520
values are bound

00:34:06,240 --> 00:34:10,079
that's one reason to use gpa over gdbc

00:34:09,520 --> 00:34:12,960
because

00:34:10,079 --> 00:34:14,879
you can't get the temptation to bind

00:34:12,960 --> 00:34:17,280
directly values in

00:34:14,879 --> 00:34:19,040
in statements it is done by the

00:34:17,280 --> 00:34:19,760
framework automatically in a secret way

00:34:19,040 --> 00:34:24,159
so no

00:34:19,760 --> 00:34:27,839
sql injections and we can see it is

00:34:24,159 --> 00:34:29,520
expanding the columns of the table

00:34:27,839 --> 00:34:30,879
so for instance in the select we have

00:34:29,520 --> 00:34:35,839
all the fields selected

00:34:30,879 --> 00:34:35,839
and we don't have a select star

00:34:37,359 --> 00:34:41,679
so to be able to support fdb out of the

00:34:40,320 --> 00:34:44,720
box without

00:34:41,679 --> 00:34:47,040
any tuning where tuning

00:34:44,720 --> 00:34:49,679
work because it can be done because

00:34:47,040 --> 00:34:52,800
opengl is very flexible but it's a bit

00:34:49,679 --> 00:34:56,480
bothering we created the

00:34:52,800 --> 00:34:57,880
rdb dictionary so

00:34:56,480 --> 00:34:59,599
in terms of configuration the

00:34:57,880 --> 00:35:01,040
persistent.xml which is around three

00:34:59,599 --> 00:35:03,839
points for the

00:35:01,040 --> 00:35:03,839
gpa

00:35:04,880 --> 00:35:08,720
creation of an entity manager which is

00:35:06,880 --> 00:35:11,839
the best to create any

00:35:08,720 --> 00:35:12,800
query or classes data there is nothing

00:35:11,839 --> 00:35:14,960
specific

00:35:12,800 --> 00:35:16,079
in this persistence unit which is a big

00:35:14,960 --> 00:35:18,400
win

00:35:16,079 --> 00:35:20,480
if you don't have a specific dictionary

00:35:18,400 --> 00:35:21,680
for your database you need to configure

00:35:20,480 --> 00:35:23,839
explicitly there

00:35:21,680 --> 00:35:25,920
the property specific to your provider

00:35:23,839 --> 00:35:28,720
hibernate open gpa or clips link

00:35:25,920 --> 00:35:30,240
saying it will be this dictionary with

00:35:28,720 --> 00:35:33,359
this configuration

00:35:30,240 --> 00:35:35,200
so this part is fine and when we start

00:35:33,359 --> 00:35:37,280
we can see that open gpa

00:35:35,200 --> 00:35:39,200
is starting indeed but we can also see

00:35:37,280 --> 00:35:43,040
it is deducing

00:35:39,200 --> 00:35:45,040
the dictionary implicitly

00:35:43,040 --> 00:35:47,200
so that's what we want we don't want to

00:35:45,040 --> 00:35:51,040
configure anything explicit in the

00:35:47,200 --> 00:35:54,240
in the application

00:35:51,040 --> 00:35:56,400
in term of code it looks like this so

00:35:54,240 --> 00:35:58,560
i i don't care much about how it is

00:35:56,400 --> 00:36:00,640
coded but what's important to see there

00:35:58,560 --> 00:36:02,400
is it is just tuning a default

00:36:00,640 --> 00:36:05,599
dictionary

00:36:02,400 --> 00:36:08,240
it is disabling some advanced feature

00:36:05,599 --> 00:36:08,800
not yet supported but we are working on

00:36:08,240 --> 00:36:11,200
that and

00:36:08,800 --> 00:36:12,240
it will likely be supported in the near

00:36:11,200 --> 00:36:16,960
future

00:36:12,240 --> 00:36:20,320
like like cascade elections

00:36:16,960 --> 00:36:23,440
we are forcing the case to lower case

00:36:20,320 --> 00:36:24,000
and we are forcing all identity shares

00:36:23,440 --> 00:36:26,720
column name

00:36:24,000 --> 00:36:27,280
schema name to be delimited by backtick

00:36:26,720 --> 00:36:29,280
like in

00:36:27,280 --> 00:36:30,720
my school which is the setup in rdb by

00:36:29,280 --> 00:36:33,359
default

00:36:30,720 --> 00:36:34,240
and this is in open gpa so next phrase

00:36:33,359 --> 00:36:36,079
will get it

00:36:34,240 --> 00:36:38,000
so it will work out of the box without

00:36:36,079 --> 00:36:39,359
anything without any knowledge you will

00:36:38,000 --> 00:36:44,079
have your application running on

00:36:39,359 --> 00:36:46,320
mdb in terms of data source definition

00:36:44,079 --> 00:36:47,440
it is a standard data source definition

00:36:46,320 --> 00:36:49,920
so this is using

00:36:47,440 --> 00:36:51,760
apache tomy syntax but it works with

00:36:49,920 --> 00:36:55,200
tomcat syntax or whatever you

00:36:51,760 --> 00:36:59,760
are using the only specific thing is the

00:36:55,200 --> 00:37:02,160
gdbc url so i put some examples there in

00:36:59,760 --> 00:37:03,599
comments so they are the local case from

00:37:02,160 --> 00:37:07,200
this case

00:37:03,599 --> 00:37:10,640
very useful for tests the

00:37:07,200 --> 00:37:14,640
remote of db standalone server so

00:37:10,640 --> 00:37:18,320
rdb server and your your austin port

00:37:14,640 --> 00:37:21,680
or the zookeeper case and riko spoke

00:37:18,320 --> 00:37:24,240
a bit about that it's when you are in a

00:37:21,680 --> 00:37:26,800
in cluster mode

00:37:24,240 --> 00:37:29,839
just a sign not there you can configure

00:37:26,800 --> 00:37:32,880
more or less that using standard gpa

00:37:29,839 --> 00:37:34,560
properties in the customers.xml but

00:37:32,880 --> 00:37:36,160
you don't really know what you will get

00:37:34,560 --> 00:37:38,320
as pulling

00:37:36,160 --> 00:37:40,240
so it's not recommended and it's better

00:37:38,320 --> 00:37:43,680
to inject the data source using an

00:37:40,240 --> 00:37:43,680
external configuration like that

00:37:44,800 --> 00:37:51,760
in terms of usage there are a few

00:37:48,839 --> 00:37:54,480
changes so the first one

00:37:51,760 --> 00:37:55,599
i faced because when i record it was not

00:37:54,480 --> 00:37:58,400
unchanged

00:37:55,599 --> 00:37:59,920
is that uh i'm really used to h2 so it

00:37:58,400 --> 00:38:04,800
is quite fast

00:37:59,920 --> 00:38:06,960
for unit tests it's really awesome um

00:38:04,800 --> 00:38:10,400
and it is light if you download the jar

00:38:06,960 --> 00:38:12,560
is i don't record but a few minutes

00:38:10,400 --> 00:38:13,920
and the first time i downloaded rdb it

00:38:12,560 --> 00:38:18,240
was uh

00:38:13,920 --> 00:38:19,040
some 30 meg something like that and it

00:38:18,240 --> 00:38:21,680
was

00:38:19,040 --> 00:38:22,720
it was slower really slower so we worked

00:38:21,680 --> 00:38:27,000
on that

00:38:22,720 --> 00:38:28,880
as well and the er summary of

00:38:27,000 --> 00:38:32,079
[Music]

00:38:28,880 --> 00:38:33,359
current state last week state to be

00:38:32,079 --> 00:38:37,200
exact

00:38:33,359 --> 00:38:39,839
uh so compared to h2 rdb is still

00:38:37,200 --> 00:38:41,200
uh a bit slower and actually it's mainly

00:38:39,839 --> 00:38:41,839
the class loading because the big

00:38:41,200 --> 00:38:45,359
difference

00:38:41,839 --> 00:38:47,200
between h2 amd and rdbmd is that rdb is

00:38:45,359 --> 00:38:50,800
still using the network protocol

00:38:47,200 --> 00:38:53,280
it is not using a remote connection

00:38:50,800 --> 00:38:54,560
it is using a local connection but it is

00:38:53,280 --> 00:38:58,160
serializing two bytes

00:38:54,560 --> 00:39:01,599
as an ico explained whereas h2 is using

00:38:58,160 --> 00:39:04,000
object reference passing calls

00:39:01,599 --> 00:39:06,400
so it's slower but it's fast enough to

00:39:04,000 --> 00:39:10,000
be used and you can debug you can do a

00:39:06,400 --> 00:39:10,000
test-driven development it's not

00:39:10,560 --> 00:39:14,640
it's not slow it does not block you the

00:39:13,760 --> 00:39:17,760
smaller variety

00:39:14,640 --> 00:39:19,599
you are using rdb and um did mod and

00:39:17,760 --> 00:39:22,800
you use the same database than in

00:39:19,599 --> 00:39:24,640
production so it's a big advantage

00:39:22,800 --> 00:39:26,560
an alternative when you are writing a

00:39:24,640 --> 00:39:28,320
persistence test is to use test

00:39:26,560 --> 00:39:30,079
container and run a docker image with

00:39:28,320 --> 00:39:31,280
your real database this way you test

00:39:30,079 --> 00:39:32,079
with the same database when in

00:39:31,280 --> 00:39:35,119
production

00:39:32,079 --> 00:39:36,880
my school for example but in this case

00:39:35,119 --> 00:39:38,400
you need to start my school it's very

00:39:36,880 --> 00:39:40,560
slow

00:39:38,400 --> 00:39:43,200
and even if you are using a mysql which

00:39:40,560 --> 00:39:47,520
is already started it's the case in

00:39:43,200 --> 00:39:50,240
this table rdb is not that far

00:39:47,520 --> 00:39:52,079
in and if you compare to an rdb remote

00:39:50,240 --> 00:39:55,520
which is exactly the same case but

00:39:52,079 --> 00:39:58,640
then the mysql rdb is faster than ricoh

00:39:55,520 --> 00:40:03,359
showed with your benchmark

00:39:58,640 --> 00:40:05,920
so it's a lot of numbers but at the end

00:40:03,359 --> 00:40:06,880
yeah rdb is a bit slower in test mode

00:40:05,920 --> 00:40:10,800
than

00:40:06,880 --> 00:40:14,319
h2o sql sql for example

00:40:10,800 --> 00:40:17,040
but it's fast enough to be using test

00:40:14,319 --> 00:40:18,880
and just to so these figures were done

00:40:17,040 --> 00:40:19,680
on a small amount of data really test

00:40:18,880 --> 00:40:22,720
data

00:40:19,680 --> 00:40:25,680
but using it on a bit bigger application

00:40:22,720 --> 00:40:30,160
with a lot of tables

00:40:25,680 --> 00:40:30,160
the ratio are more or less the same

00:40:31,520 --> 00:40:34,560
so on gpa

00:40:34,880 --> 00:40:39,760
it's really easy to set up now it works

00:40:37,680 --> 00:40:42,960
out of the box with open gpa

00:40:39,760 --> 00:40:46,079
with ibnet and eclipsing you need some

00:40:42,960 --> 00:40:48,160
tuning but it can work as well

00:40:46,079 --> 00:40:50,400
it's really interesting to use the rdb

00:40:48,160 --> 00:40:53,359
because it can optimize your scalability

00:40:50,400 --> 00:40:54,880
as enrico said it can be emptied it can

00:40:53,359 --> 00:41:00,400
be remote

00:40:54,880 --> 00:41:02,960
but localized in a closed vpc

00:41:00,400 --> 00:41:05,440
and it's self-stable which is really

00:41:02,960 --> 00:41:07,839
interesting because if you already

00:41:05,440 --> 00:41:12,079
used a managed database in the cloud

00:41:07,839 --> 00:41:12,079
it's very very very very expensive

00:41:12,960 --> 00:41:17,200
just a small word on kubernetes because

00:41:15,359 --> 00:41:20,160
it's what is used

00:41:17,200 --> 00:41:22,800
almost for new application so you can

00:41:20,160 --> 00:41:24,720
deploy your db with kubernetes

00:41:22,800 --> 00:41:26,480
you need to use a personal volume and

00:41:24,720 --> 00:41:30,319
the first transform claim

00:41:26,480 --> 00:41:32,720
and the backup is managed either in a

00:41:30,319 --> 00:41:34,319
local disk depending your cloud provider

00:41:32,720 --> 00:41:37,839
in s3 can be

00:41:34,319 --> 00:41:38,480
nfs or google storage something a bit

00:41:37,839 --> 00:41:40,400
better

00:41:38,480 --> 00:41:42,319
if you can use it it's a stateful set

00:41:40,400 --> 00:41:46,480
it's just combining the deployments

00:41:42,319 --> 00:41:50,079
of rdb bookkeeper zookeeper probably

00:41:46,480 --> 00:41:51,760
and the their stance volume

00:41:50,079 --> 00:41:55,200
there are some bugs and some providers

00:41:51,760 --> 00:41:55,200
so i'm sure you can use them

00:41:57,839 --> 00:42:00,880
okay so i not spend a lot of time on

00:42:00,480 --> 00:42:04,560
this

00:42:00,880 --> 00:42:05,920
but i leave what you have to to keep in

00:42:04,560 --> 00:42:08,800
mind

00:42:05,920 --> 00:42:10,800
with this part is that you can write any

00:42:08,800 --> 00:42:11,599
application using persistence or a

00:42:10,800 --> 00:42:15,040
database

00:42:11,599 --> 00:42:17,040
without db it will work smoothly in the

00:42:15,040 --> 00:42:22,720
cloud

00:42:17,040 --> 00:42:22,720
and it is really flexible and you can

00:42:22,960 --> 00:42:26,480
make it matching exactly your

00:42:24,640 --> 00:42:28,960
application your sla

00:42:26,480 --> 00:42:30,800
and your deployment which is very rare

00:42:28,960 --> 00:42:35,119
today often you have to use manage

00:42:30,800 --> 00:42:37,760
databases or bad support because it's

00:42:35,119 --> 00:42:37,760
expensive

00:42:38,960 --> 00:42:44,240
a small nut and the fact it is open

00:42:42,000 --> 00:42:47,440
source and you can do pr on github

00:42:44,240 --> 00:42:50,480
it's really great i did a few and

00:42:47,440 --> 00:42:53,200
it's really smooth and

00:42:50,480 --> 00:42:53,680
staying on sql you keep the tools you

00:42:53,200 --> 00:42:57,119
are

00:42:53,680 --> 00:43:01,359
used to so it's really really good

00:42:57,119 --> 00:43:04,079
so now i'll try to do a very quick demo

00:43:01,359 --> 00:43:04,079
in two minutes

00:43:05,280 --> 00:43:09,920
so i uh i took antonio goncalves pet

00:43:09,119 --> 00:43:12,079
store

00:43:09,920 --> 00:43:14,880
so if you don't know it it's a small

00:43:12,079 --> 00:43:17,839
java demo application

00:43:14,880 --> 00:43:17,839
and i use tomi

00:43:19,359 --> 00:43:22,960
which is a e server we have a type of if

00:43:21,839 --> 00:43:26,640
you don't know it you should

00:43:22,960 --> 00:43:27,920
google it oh yeah we we see that thomas

00:43:26,640 --> 00:43:32,880
is starting

00:43:27,920 --> 00:43:32,880
this part is oh it's too small again

00:43:34,240 --> 00:43:37,920
you can see here that this log is the

00:43:36,560 --> 00:43:41,119
amd rdb

00:43:37,920 --> 00:43:42,480
which is starting and then the

00:43:41,119 --> 00:43:46,400
application

00:43:42,480 --> 00:43:49,520
the application has um init sql script

00:43:46,400 --> 00:43:51,760
launched by gpa standard feature now so

00:43:49,520 --> 00:43:55,119
we can see here all the insert

00:43:51,760 --> 00:43:58,560
done automatically so gpa is sending

00:43:55,119 --> 00:43:58,560
within certain rdb

00:43:59,119 --> 00:44:03,200
very quickly the application oops

00:44:03,280 --> 00:44:09,839
looking like that

00:44:10,240 --> 00:44:16,800
too big now okay so basically you

00:44:13,839 --> 00:44:19,119
you can buy pets so i need to login i

00:44:16,800 --> 00:44:19,119
guess

00:44:20,839 --> 00:44:28,640
okay so

00:44:24,560 --> 00:44:31,359
okay up you can select any part you want

00:44:28,640 --> 00:44:34,079
add it to a cart and check out the cart

00:44:31,359 --> 00:44:36,480
and what's interesting is so this

00:44:34,079 --> 00:44:39,599
application was written for a well fly

00:44:36,480 --> 00:44:42,880
for a standard database my sequel or

00:44:39,599 --> 00:44:44,319
h2h link and here the search

00:44:42,880 --> 00:44:47,119
just returned the result and it is

00:44:44,319 --> 00:44:48,160
running an rbb and i didn't modify the

00:44:47,119 --> 00:44:51,599
application

00:44:48,160 --> 00:44:55,680
and if we go at the end

00:44:51,599 --> 00:44:55,680
uh yeah we have the select there

00:44:56,800 --> 00:45:00,880
which is a standard select issued by

00:44:59,599 --> 00:45:02,800
opengpa

00:45:00,880 --> 00:45:04,400
so this part is really interesting

00:45:02,800 --> 00:45:06,640
without doing anything

00:45:04,400 --> 00:45:08,800
it is working another thing which is

00:45:06,640 --> 00:45:12,800
interesting

00:45:08,800 --> 00:45:14,960
and i finish on that is that it's

00:45:12,800 --> 00:45:16,720
you have a data source in terms of code

00:45:14,960 --> 00:45:19,920
a standard data source

00:45:16,720 --> 00:45:23,440
so it integrates with the ecosystem of

00:45:19,920 --> 00:45:26,640
all libraries working with data sources

00:45:23,440 --> 00:45:30,480
so for instance with microprofile

00:45:26,640 --> 00:45:33,520
we can get matrix here

00:45:30,480 --> 00:45:34,640
i have metrics about the pool of the

00:45:33,520 --> 00:45:38,560
data source

00:45:34,640 --> 00:45:42,880
the current size max active etc

00:45:38,560 --> 00:45:42,880
and it integrates with microprofile

00:45:43,440 --> 00:45:47,520
here i have an endpoint checking the

00:45:45,520 --> 00:45:49,200
resources of my application and here

00:45:47,520 --> 00:45:50,720
it is checking the data source is

00:45:49,200 --> 00:45:54,160
working

00:45:50,720 --> 00:45:55,200
all that running on rdb so that's really

00:45:54,160 --> 00:45:58,800
the interesting part

00:45:55,200 --> 00:46:02,240
you can deploy any you can even migrate

00:45:58,800 --> 00:46:05,440
existing application to mdb

00:46:02,240 --> 00:46:08,640
and it will be quite smooth

00:46:05,440 --> 00:46:15,839
that's it for me i don't know if we have

00:46:08,640 --> 00:46:15,839
time for questions

00:46:20,000 --> 00:46:23,440
and i go you are muted you think

00:46:24,319 --> 00:46:28,400
thank you very much to everyone thank

00:46:27,040 --> 00:46:31,520
you roman

00:46:28,400 --> 00:46:34,560
for talking with me about him

00:46:31,520 --> 00:46:38,640
uh feel free to

00:46:34,560 --> 00:46:44,000
to to connect with us on github

00:46:38,640 --> 00:46:48,160
or on on slack we have a select channel

00:46:44,000 --> 00:46:53,599
about rdb inside the apache boot keeper

00:46:48,160 --> 00:46:53,599
workspace so that's it

00:46:54,839 --> 00:47:11,839
um

00:46:57,040 --> 00:47:11,839
bye to everyone cheers

00:47:35,440 --> 00:47:37,520

YouTube URL: https://www.youtube.com/watch?v=EinPVQlaLqw


