Title: FOSS Never Forgets: Intro to FOSS Solutions for Data Processing & Mgmt w Emphasis on Fault Tolerance
Publication date: 2020-10-21
Playlist: ApacheCon @Home 2020: Big Data (Track 2)
Description: 
	FOSS Never Forgets: An Introduction to Free and Open Source Solutions for Data Processing and Management with an Emphasis on Fault Tolerance
Katie McMillan

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

This talk will provide an introduction to data processing and management in two of the most popular Free and Open Source Solutions: Hadoop and PostgreSQL. The talk will link these solutions to current challenges in big data, with an emphasis on the fault tolerancy of each solution. It will then show how the solutions can be used together, using Foreign Data Wrappers. By combining the functionality of PostgreSQL and Hadoop with Foreign Data Wrappers, one is able to apply ACID properties to processes (transactions) in Hadoop.

Katie McMillan leads strategic and creative projects that advance the public health, information technology, and social sectors. She currently works for a multi-site Canadian hospital, and is an advisor to local, national and international healthcare and public interest initiatives. Katie brings passion and talent for new now know-how and engaging a diverse range of stakeholders to co-create solutions to complex organizational, industry and systems challenges. She leverages a multi-disciplinary background in Health Systems, Geographic Information Systems, Public Policy, and Data Science, and works with communities to design, select, implement, and monitor solutions in order to improve outcomes with an emphasis on multi-intervention approaches, interoperability, mixed methods, and Ubuntu. She has worked for organizations including Health Canada, the Canadian Institute for Health Information, and the Royal College of Physicians and Surgeons of Canada. Additional information:
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,080 --> 00:00:27,680
all within this

00:00:25,039 --> 00:00:28,400
foss elephant if you will so what are

00:00:27,680 --> 00:00:32,960
postgres

00:00:28,400 --> 00:00:34,880
and hadoop they are free and open

00:00:32,960 --> 00:00:36,160
foss solutions for storing and managing

00:00:34,880 --> 00:00:38,160
big data

00:00:36,160 --> 00:00:39,680
so the goals of both solutions this is

00:00:38,160 --> 00:00:42,399
based on my interpretation

00:00:39,680 --> 00:00:44,239
i would fall into uh save piffy i

00:00:42,399 --> 00:00:46,079
pronounce it piffy because uh

00:00:44,239 --> 00:00:48,239
pie phi is something else in the

00:00:46,079 --> 00:00:50,320
community um so number one

00:00:48,239 --> 00:00:52,239
uh storage big data needs to have a

00:00:50,320 --> 00:00:53,120
place to exist and needs to continue to

00:00:52,239 --> 00:00:55,280
exist

00:00:53,120 --> 00:00:57,039
number two access big data needs to be

00:00:55,280 --> 00:00:58,160
accessible when needed by designated

00:00:57,039 --> 00:01:00,960
individuals

00:00:58,160 --> 00:01:02,239
number three versatility big data comes

00:01:00,960 --> 00:01:03,440
in structured semi-structured and

00:01:02,239 --> 00:01:05,840
unstructured formats

00:01:03,440 --> 00:01:07,119
all must be supported number four

00:01:05,840 --> 00:01:08,320
extension capability and

00:01:07,119 --> 00:01:10,000
interoperability

00:01:08,320 --> 00:01:11,760
extensions optional add-ons and

00:01:10,000 --> 00:01:12,080
integrations with other solutions which

00:01:11,760 --> 00:01:13,439
help

00:01:12,080 --> 00:01:16,000
achieve the other goals are formally

00:01:13,439 --> 00:01:17,280
supported number five processing

00:01:16,000 --> 00:01:18,720
big data needs to be efficiently

00:01:17,280 --> 00:01:20,400
processed to facilitate storage

00:01:18,720 --> 00:01:22,720
retrieval and analysis

00:01:20,400 --> 00:01:24,799
number six integrity big data needs to

00:01:22,720 --> 00:01:26,960
be correct

00:01:24,799 --> 00:01:28,880
number seven fault tolerance even if a

00:01:26,960 --> 00:01:30,079
component in the system fails the other

00:01:28,880 --> 00:01:32,479
goals are still met

00:01:30,079 --> 00:01:33,520
and number eight inclusion all goals are

00:01:32,479 --> 00:01:36,400
achieved through

00:01:33,520 --> 00:01:36,400
inclusive means

00:01:36,560 --> 00:01:40,159
so we can sort of compare and contrast

00:01:39,200 --> 00:01:42,479
these solutions

00:01:40,159 --> 00:01:44,720
um within other frameworks and theorems

00:01:42,479 --> 00:01:46,479
for example the cap theorem states that

00:01:44,720 --> 00:01:47,040
when there is a network partition so

00:01:46,479 --> 00:01:49,759
when we

00:01:47,040 --> 00:01:51,920
introduce a p um the distributed data

00:01:49,759 --> 00:01:54,079
store has to choose between

00:01:51,920 --> 00:01:55,600
consistency availability and that

00:01:54,079 --> 00:01:58,960
partition tolerance

00:01:55,600 --> 00:02:00,960
um so hadoop has focused more on the uh

00:01:58,960 --> 00:02:02,479
c and the p the consistency and the

00:02:00,960 --> 00:02:05,600
partition tolerance

00:02:02,479 --> 00:02:07,920
and postgres is focused more on the ap

00:02:05,600 --> 00:02:10,959
the availability and the consistency

00:02:07,920 --> 00:02:12,239
within the cap theorem

00:02:10,959 --> 00:02:14,239
why is fall tolerance important for

00:02:12,239 --> 00:02:15,520
postgres and hadoop well fault tolerance

00:02:14,239 --> 00:02:16,800
is important so that you don't lose

00:02:15,520 --> 00:02:18,720
access to your data or

00:02:16,800 --> 00:02:20,239
lose your data altogether building fault

00:02:18,720 --> 00:02:22,560
tolerance into systems ensures that they

00:02:20,239 --> 00:02:25,120
are reliable available and serviceable

00:02:22,560 --> 00:02:26,080
ras the term ras was originally coined

00:02:25,120 --> 00:02:27,920
by ibm

00:02:26,080 --> 00:02:29,440
and used to describe the robustness of

00:02:27,920 --> 00:02:31,440
their mainframe computers

00:02:29,440 --> 00:02:33,680
however system science has evolved the

00:02:31,440 --> 00:02:36,720
use of the term to apply to all systems

00:02:33,680 --> 00:02:39,360
including software

00:02:36,720 --> 00:02:40,879
fault tolerance and data management

00:02:39,360 --> 00:02:42,560
fault tolerance is a concept used in

00:02:40,879 --> 00:02:43,920
many fields but it is particularly

00:02:42,560 --> 00:02:45,920
important to data storage and

00:02:43,920 --> 00:02:47,840
information technology infrastructure

00:02:45,920 --> 00:02:49,440
in this context fault tolerance refers

00:02:47,840 --> 00:02:51,519
to the ability of a computer system or

00:02:49,440 --> 00:02:53,760
storage subsystem to suffer failures in

00:02:51,519 --> 00:02:55,040
component hardware or software parts

00:02:53,760 --> 00:02:57,120
yet continue to function without a

00:02:55,040 --> 00:03:00,159
service interruption and without losing

00:02:57,120 --> 00:03:02,239
data or compromising safety

00:03:00,159 --> 00:03:03,440
um so there's often some confusion

00:03:02,239 --> 00:03:04,480
between the concepts of high

00:03:03,440 --> 00:03:07,200
availability

00:03:04,480 --> 00:03:08,560
high availability and fault tolerance at

00:03:07,200 --> 00:03:10,239
the most basic level

00:03:08,560 --> 00:03:12,959
high availability refers to systems that

00:03:10,239 --> 00:03:14,640
suffer minimal service interruptions

00:03:12,959 --> 00:03:16,319
while systems with fault tolerance are

00:03:14,640 --> 00:03:19,920
designed never to experience

00:03:16,319 --> 00:03:20,319
service interruptions so building on

00:03:19,920 --> 00:03:22,159
this

00:03:20,319 --> 00:03:24,720
in practice the difference can be quite

00:03:22,159 --> 00:03:25,760
small highly available systems often aim

00:03:24,720 --> 00:03:28,560
for the so-called

00:03:25,760 --> 00:03:30,879
five nines up time which equates to just

00:03:28,560 --> 00:03:32,480
a few minutes of downtime a year

00:03:30,879 --> 00:03:34,080
however the underlying principles

00:03:32,480 --> 00:03:36,480
between high and high availability and

00:03:34,080 --> 00:03:38,720
fault tolerant are quite different

00:03:36,480 --> 00:03:40,560
um fault tolerance systems are designed

00:03:38,720 --> 00:03:41,120
to detect faults and remediate the

00:03:40,560 --> 00:03:42,959
problem

00:03:41,120 --> 00:03:45,280
perhaps by swapping in a redundant

00:03:42,959 --> 00:03:47,280
component without interruption

00:03:45,280 --> 00:03:49,200
while highly available systems generally

00:03:47,280 --> 00:03:51,200
generally use standard hardware and aim

00:03:49,200 --> 00:03:52,640
to restore service quickly after an

00:03:51,200 --> 00:03:54,560
outage has occurred

00:03:52,640 --> 00:03:55,680
um i thought this was well stated by

00:03:54,560 --> 00:03:57,200
paul rubins

00:03:55,680 --> 00:03:58,799
the reason why high availability is

00:03:57,200 --> 00:04:00,239
often considered acceptable instead of

00:03:58,799 --> 00:04:00,959
full fault tolerance usually comes down

00:04:00,239 --> 00:04:02,400
to cost

00:04:00,959 --> 00:04:04,000
building fault tolerance into a system

00:04:02,400 --> 00:04:05,840
can be more expensive than accepting

00:04:04,000 --> 00:04:08,319
that short outages may occur from time

00:04:05,840 --> 00:04:10,400
to time

00:04:08,319 --> 00:04:12,480
um so some systems cannot be allowed to

00:04:10,400 --> 00:04:14,159
fail so for example i

00:04:12,480 --> 00:04:16,320
work at a hospital and patient

00:04:14,159 --> 00:04:17,040
monitoring systems cannot be allowed to

00:04:16,320 --> 00:04:19,919
fail

00:04:17,040 --> 00:04:21,440
as well mission critical systems banking

00:04:19,919 --> 00:04:24,000
systems and surveillance and security

00:04:21,440 --> 00:04:28,320
systems really cannot be interrupted

00:04:24,000 --> 00:04:30,160
what are faults um so the iso defines

00:04:28,320 --> 00:04:31,680
a fault as an abnormal condition or

00:04:30,160 --> 00:04:33,360
defect at the component equipment or

00:04:31,680 --> 00:04:34,080
subsystem level which may lead to a

00:04:33,360 --> 00:04:36,000
failure

00:04:34,080 --> 00:04:37,360
in everyday language the terms fault

00:04:36,000 --> 00:04:38,320
failure and error are used

00:04:37,360 --> 00:04:40,560
interchangeably

00:04:38,320 --> 00:04:42,479
but in fault tolerant computing prolongs

00:04:40,560 --> 00:04:45,040
these have distinct meanings

00:04:42,479 --> 00:04:46,800
so i'll put some definitions here um

00:04:45,040 --> 00:04:48,320
from the ieee i'm not gonna go through

00:04:46,800 --> 00:04:50,080
all these but i'm just gonna focus on

00:04:48,320 --> 00:04:52,479
the definition for fault so it does

00:04:50,080 --> 00:04:54,400
state that it is a defect in the code

00:04:52,479 --> 00:04:55,280
that can be the cause of one or more

00:04:54,400 --> 00:04:57,360
failures

00:04:55,280 --> 00:04:59,520
it is also a manifestation of an error

00:04:57,360 --> 00:05:02,000
in the software

00:04:59,520 --> 00:05:04,000
so some examples of faults there's lots

00:05:02,000 --> 00:05:05,120
of these but we may have stuck at faults

00:05:04,000 --> 00:05:07,520
in the logic level

00:05:05,120 --> 00:05:08,880
uh bit flip faults can be caused by

00:05:07,520 --> 00:05:12,000
cosmic ray strikes

00:05:08,880 --> 00:05:13,600
we can have processor stop um

00:05:12,000 --> 00:05:16,000
firmware updates not completing

00:05:13,600 --> 00:05:17,360
successfully data items being corrupted

00:05:16,000 --> 00:05:20,320
in the disk image of the operating

00:05:17,360 --> 00:05:20,320
system etc

00:05:20,560 --> 00:05:24,320
so when categorizing faults we can have

00:05:22,800 --> 00:05:25,840
temporary and permanent

00:05:24,320 --> 00:05:27,919
we can also have hardware-based and

00:05:25,840 --> 00:05:29,600
software-based faults as well as random

00:05:27,919 --> 00:05:31,680
and systematic

00:05:29,600 --> 00:05:34,240
uh faults can be temporary or permanent

00:05:31,680 --> 00:05:35,520
in manifestation however the same fault

00:05:34,240 --> 00:05:37,600
may result in different effects

00:05:35,520 --> 00:05:39,440
depending on where and when it occurs

00:05:37,600 --> 00:05:41,440
so as an example a soft error in the

00:05:39,440 --> 00:05:43,280
code segment is a permanent error

00:05:41,440 --> 00:05:44,479
while one in the data segment may be

00:05:43,280 --> 00:05:46,320
temporary

00:05:44,479 --> 00:05:47,520
faults may also affect different layers

00:05:46,320 --> 00:05:49,440
differently

00:05:47,520 --> 00:05:51,280
so a permanent fault in the logic layer

00:05:49,440 --> 00:05:52,080
may manifest as a temporary fault at the

00:05:51,280 --> 00:05:53,840
architectural

00:05:52,080 --> 00:05:55,600
level if the functional unit in which it

00:05:53,840 --> 00:05:57,840
occurs is often unused

00:05:55,600 --> 00:05:58,639
only a small fraction of faults make it

00:05:57,840 --> 00:06:01,120
to the operator

00:05:58,639 --> 00:06:02,000
and user level some errors can be mass

00:06:01,120 --> 00:06:03,680
or overwritten

00:06:02,000 --> 00:06:05,520
and if the fault is directly in the

00:06:03,680 --> 00:06:06,000
operating system or application layer

00:06:05,520 --> 00:06:08,000
the user

00:06:06,000 --> 00:06:09,520
is likely to observe the faults but the

00:06:08,000 --> 00:06:11,600
underlying layers may not be able to

00:06:09,520 --> 00:06:13,280
help in detection

00:06:11,600 --> 00:06:14,240
in computing fault tolerance is often

00:06:13,280 --> 00:06:15,840
broken down into hardware and

00:06:14,240 --> 00:06:17,039
software-based approaches so for

00:06:15,840 --> 00:06:19,199
hardware based

00:06:17,039 --> 00:06:21,120
those would really focus on the the

00:06:19,199 --> 00:06:22,000
power supply the ram the motherboard the

00:06:21,120 --> 00:06:24,880
cables

00:06:22,000 --> 00:06:26,720
um other peripherals as well um

00:06:24,880 --> 00:06:28,000
software-based approaches would focus on

00:06:26,720 --> 00:06:29,680
the set of instructions

00:06:28,000 --> 00:06:31,199
which are stored and run on the hardware

00:06:29,680 --> 00:06:32,000
such as the os the programs and

00:06:31,199 --> 00:06:35,120
applications

00:06:32,000 --> 00:06:36,720
the database management system etc

00:06:35,120 --> 00:06:38,720
um hardware and software-based

00:06:36,720 --> 00:06:39,759
approaches are quite different so some

00:06:38,720 --> 00:06:42,240
approaches

00:06:39,759 --> 00:06:42,880
for the hardware would be repairs

00:06:42,240 --> 00:06:45,120
updates

00:06:42,880 --> 00:06:46,639
upgrades and recycling and some

00:06:45,120 --> 00:06:47,360
software-based approaches would be new

00:06:46,639 --> 00:06:50,639
releases

00:06:47,360 --> 00:06:52,080
patches and bug fixes as well um

00:06:50,639 --> 00:06:54,080
it's important to mention that hardware

00:06:52,080 --> 00:06:54,720
exhibits both random and systematic

00:06:54,080 --> 00:06:56,560
faults

00:06:54,720 --> 00:06:58,479
so random faults are usually caused by

00:06:56,560 --> 00:06:59,759
deterioration over time and defects

00:06:58,479 --> 00:07:01,520
during manufacturing

00:06:59,759 --> 00:07:03,360
whereas systematic faults can be created

00:07:01,520 --> 00:07:04,960
in any stage of the system's life

00:07:03,360 --> 00:07:06,800
including specification design

00:07:04,960 --> 00:07:08,479
manufacture etc

00:07:06,800 --> 00:07:10,240
whereas software does not exhibit the

00:07:08,479 --> 00:07:11,919
random or where out related failure

00:07:10,240 --> 00:07:13,280
behavior that we see in the hardware

00:07:11,919 --> 00:07:15,280
software faults are categorized as

00:07:13,280 --> 00:07:16,800
systematic faults and these systematic

00:07:15,280 --> 00:07:18,479
faults are produced by human error

00:07:16,800 --> 00:07:20,479
during any stage of system development

00:07:18,479 --> 00:07:22,560
and operation

00:07:20,479 --> 00:07:24,080
and there will always be faults computer

00:07:22,560 --> 00:07:25,599
scientists and engineers have responded

00:07:24,080 --> 00:07:27,199
to the challenge of designing complex

00:07:25,599 --> 00:07:28,560
systems with a variety of tools and

00:07:27,199 --> 00:07:30,000
techniques to reduce the number of

00:07:28,560 --> 00:07:31,680
faults in the systems they build

00:07:30,000 --> 00:07:33,120
however that is not enough we need to

00:07:31,680 --> 00:07:34,880
build systems that will acknowledge the

00:07:33,120 --> 00:07:35,759
existence of faults as a fact of life

00:07:34,880 --> 00:07:37,120
and incorporate

00:07:35,759 --> 00:07:40,160
fault tolerant design into computer

00:07:37,120 --> 00:07:41,759
systems so what is fault tolerance

00:07:40,160 --> 00:07:43,520
uh there's lots of different definitions

00:07:41,759 --> 00:07:44,960
of fault tolerance i just picked you

00:07:43,520 --> 00:07:47,520
here that i thought were

00:07:44,960 --> 00:07:49,039
quite good and straightforward so on in

00:07:47,520 --> 00:07:50,879
nasa's fault management handbook they

00:07:49,039 --> 00:07:52,639
described it as the ability to perform a

00:07:50,879 --> 00:07:54,080
function in the presence of any of a

00:07:52,639 --> 00:07:55,759
specified number of coincident

00:07:54,080 --> 00:07:58,560
independent failure causes

00:07:55,759 --> 00:07:59,520
of specified types and data flare define

00:07:58,560 --> 00:08:01,039
it as

00:07:59,520 --> 00:08:03,199
the ability of the system to work or

00:08:01,039 --> 00:08:05,199
operate even in the case of unfavorable

00:08:03,199 --> 00:08:06,560
conditions and i did like these two

00:08:05,199 --> 00:08:08,479
definitions because they were quite

00:08:06,560 --> 00:08:12,000
broad and not necessarily specific

00:08:08,479 --> 00:08:14,000
to computing so

00:08:12,000 --> 00:08:15,680
uh fault tolerance as a concept is not

00:08:14,000 --> 00:08:17,680
specific to computing

00:08:15,680 --> 00:08:20,080
i won't go through all of this but uh

00:08:17,680 --> 00:08:21,599
the iso's definition is also quite broad

00:08:20,080 --> 00:08:23,280
and isn't necessarily specific to

00:08:21,599 --> 00:08:24,560
computing even though it was found

00:08:23,280 --> 00:08:25,520
within a systems and software

00:08:24,560 --> 00:08:28,800
engineering

00:08:25,520 --> 00:08:30,479
manual so fun with terminology outside

00:08:28,800 --> 00:08:31,280
of the engineering and computer science

00:08:30,479 --> 00:08:33,039
literature

00:08:31,280 --> 00:08:34,560
various terms are used to discuss the

00:08:33,039 --> 00:08:36,240
concept of fault tolerance in different

00:08:34,560 --> 00:08:38,560
systems so i've listed

00:08:36,240 --> 00:08:40,080
a number of the commonly used ones here

00:08:38,560 --> 00:08:42,719
particularly disaster

00:08:40,080 --> 00:08:44,560
management and recovery uh continuity

00:08:42,719 --> 00:08:44,959
particularly business continuity those

00:08:44,560 --> 00:08:46,640
are

00:08:44,959 --> 00:08:48,560
really big ones in the literature we

00:08:46,640 --> 00:08:50,240
also see terms like dependability

00:08:48,560 --> 00:08:52,080
robustness etc

00:08:50,240 --> 00:08:53,440
and at the bottom we see resiliency and

00:08:52,080 --> 00:08:55,760
i'll be discussing that at the end of

00:08:53,440 --> 00:08:58,720
the presentation

00:08:55,760 --> 00:09:00,560
so faults and failures faults can lead

00:08:58,720 --> 00:09:01,120
to failures but do not always lead to

00:09:00,560 --> 00:09:03,040
failures

00:09:01,120 --> 00:09:04,959
and this is true of all systems for

00:09:03,040 --> 00:09:07,519
example in cellular systems a number of

00:09:04,959 --> 00:09:09,680
robust dna damage response ddr pathways

00:09:07,519 --> 00:09:11,519
repair dna damage and

00:09:09,680 --> 00:09:13,519
damage from replicating and causing

00:09:11,519 --> 00:09:14,959
observable problems in the organism

00:09:13,519 --> 00:09:17,600
this system could be considered fault

00:09:14,959 --> 00:09:19,120
tolerant in computing a fault

00:09:17,600 --> 00:09:20,640
fault that occurs in one component of

00:09:19,120 --> 00:09:22,080
the system may not lead to a fault or

00:09:20,640 --> 00:09:24,000
failure in another component

00:09:22,080 --> 00:09:25,200
for example faults and hardware may not

00:09:24,000 --> 00:09:26,880
create noticeable impacts on the

00:09:25,200 --> 00:09:28,880
software components that the end

00:09:26,880 --> 00:09:29,920
user experiences as we've discussed

00:09:28,880 --> 00:09:31,680
previously

00:09:29,920 --> 00:09:33,279
faults are upstream causes of failures

00:09:31,680 --> 00:09:34,880
and failures in one system can cause

00:09:33,279 --> 00:09:36,560
faults or failures in another that's

00:09:34,880 --> 00:09:38,080
quite an important point

00:09:36,560 --> 00:09:39,519
therefore even though faults do not

00:09:38,080 --> 00:09:41,120
always cause failures failures are

00:09:39,519 --> 00:09:43,040
always caused by faults and fault

00:09:41,120 --> 00:09:44,480
tolerant design is needed so that's some

00:09:43,040 --> 00:09:46,160
fun with language there

00:09:44,480 --> 00:09:48,399
but looking at the relationship between

00:09:46,160 --> 00:09:50,480
faults and failures we do see

00:09:48,399 --> 00:09:52,080
that faults are the upstream causes of

00:09:50,480 --> 00:09:53,760
failures but they don't always cause

00:09:52,080 --> 00:09:54,240
failures they can domino into other

00:09:53,760 --> 00:09:56,560
faults

00:09:54,240 --> 00:09:58,240
or they don't necessarily have to cause

00:09:56,560 --> 00:09:59,600
downstream faults or failures at all and

00:09:58,240 --> 00:10:03,440
that's called

00:09:59,600 --> 00:10:05,360
fall containment so in fault tolerant

00:10:03,440 --> 00:10:06,959
design the goal is to recognize prevent

00:10:05,360 --> 00:10:08,000
or repair faults so that they do not

00:10:06,959 --> 00:10:09,839
lead to failures

00:10:08,000 --> 00:10:11,600
the ability of maintaining functionality

00:10:09,839 --> 00:10:13,839
when portions of a system break down

00:10:11,600 --> 00:10:15,600
is referred to as graceful degradation

00:10:13,839 --> 00:10:17,279
if a system is capable of continuing to

00:10:15,600 --> 00:10:18,320
provide full functionality despite a

00:10:17,279 --> 00:10:20,720
fault or failure

00:10:18,320 --> 00:10:22,399
it is considered fail safe it is if it

00:10:20,720 --> 00:10:23,920
is capable of continuing at a reduced

00:10:22,399 --> 00:10:26,480
functionality it is considered

00:10:23,920 --> 00:10:27,519
fail soft so those are some important uh

00:10:26,480 --> 00:10:30,800
terms in the fault

00:10:27,519 --> 00:10:32,480
tolerance design literature

00:10:30,800 --> 00:10:34,800
so again fault tolerance is not specific

00:10:32,480 --> 00:10:38,240
to computing it's multidisciplinary

00:10:34,800 --> 00:10:39,680
um to all systems theory and analysis

00:10:38,240 --> 00:10:41,440
enhancing fault tolerance increases

00:10:39,680 --> 00:10:44,160
availability and reliability which are

00:10:41,440 --> 00:10:45,920
desirable characteristics in any system

00:10:44,160 --> 00:10:47,680
as a concept it is also important in

00:10:45,920 --> 00:10:50,560
many other fields and i've listed

00:10:47,680 --> 00:10:52,560
um multiple fields there um so including

00:10:50,560 --> 00:10:55,360
human resources environmental systems

00:10:52,560 --> 00:10:57,360
aerospace systems telecommunications etc

00:10:55,360 --> 00:10:58,880
uh similar strategies can be used to

00:10:57,360 --> 00:11:00,079
create fault tolerant design in

00:10:58,880 --> 00:11:01,839
different systems

00:11:00,079 --> 00:11:03,519
such as fault modeling recovery

00:11:01,839 --> 00:11:05,120
processes feedback control

00:11:03,519 --> 00:11:06,560
as well as identification and prevention

00:11:05,120 --> 00:11:08,320
of single points of failure and the

00:11:06,560 --> 00:11:10,320
implementation of redundancy

00:11:08,320 --> 00:11:12,880
so those techniques really can be

00:11:10,320 --> 00:11:14,480
applied across the disciplines

00:11:12,880 --> 00:11:16,079
for example in day-to-day life

00:11:14,480 --> 00:11:17,519
preventing single points of failure by

00:11:16,079 --> 00:11:19,279
applying redundancy

00:11:17,519 --> 00:11:21,600
could take the form of multiple alarm

00:11:19,279 --> 00:11:22,240
clocks faults are normally identified

00:11:21,600 --> 00:11:24,800
and defined

00:11:22,240 --> 00:11:25,440
in a way that is field specific however

00:11:24,800 --> 00:11:27,279
different

00:11:25,440 --> 00:11:29,040
disciplines can work together to enhance

00:11:27,279 --> 00:11:30,800
fault tolerance this is important as

00:11:29,040 --> 00:11:33,680
failures and catastrophic events often

00:11:30,800 --> 00:11:36,160
affect multiple systems

00:11:33,680 --> 00:11:37,760
so i've put in some definitions here of

00:11:36,160 --> 00:11:39,360
availability and reliability i'm not

00:11:37,760 --> 00:11:41,200
going to go through all of those but

00:11:39,360 --> 00:11:42,560
that's mainly for reference just to show

00:11:41,200 --> 00:11:45,760
that they are slightly different from

00:11:42,560 --> 00:11:47,440
one another but i do um come into play

00:11:45,760 --> 00:11:49,680
in terms of fault tolerance and this was

00:11:47,440 --> 00:11:51,600
uh a graphic that i found

00:11:49,680 --> 00:11:53,760
um that i thought really exemplified

00:11:51,600 --> 00:11:55,440
both reactive and proactive

00:11:53,760 --> 00:11:57,279
fault tolerance approaches quite well

00:11:55,440 --> 00:11:59,200
and sort of provided some useful

00:11:57,279 --> 00:12:01,200
categories for those

00:11:59,200 --> 00:12:02,880
so jumping into fault tolerance and

00:12:01,200 --> 00:12:04,639
postgres just a little bit of background

00:12:02,880 --> 00:12:06,720
on postgres it is written in c

00:12:04,639 --> 00:12:09,120
and was originally developed in 1986 as

00:12:06,720 --> 00:12:11,279
a successor to ingress which was also

00:12:09,120 --> 00:12:12,160
an open source sql relational database

00:12:11,279 --> 00:12:14,000
project

00:12:12,160 --> 00:12:15,680
it is licensed under the postgres sql

00:12:14,000 --> 00:12:16,800
license which is a free and open source

00:12:15,680 --> 00:12:19,200
license

00:12:16,800 --> 00:12:21,519
um it was originally known as postgres

00:12:19,200 --> 00:12:23,360
but it's now known as postgresql

00:12:21,519 --> 00:12:24,880
and it was the brainchild of michael

00:12:23,360 --> 00:12:25,519
stonebreaker who was a computer

00:12:24,880 --> 00:12:27,920
scientist

00:12:25,519 --> 00:12:28,800
or a computer science professor at

00:12:27,920 --> 00:12:30,959
berkeley

00:12:28,800 --> 00:12:32,880
in 1994 the project added support for

00:12:30,959 --> 00:12:35,040
sql and shortly thereafter the name

00:12:32,880 --> 00:12:37,040
postgres sql came about

00:12:35,040 --> 00:12:38,480
it is considered an object relational

00:12:37,040 --> 00:12:39,920
database management system

00:12:38,480 --> 00:12:41,760
for structured semi-structured and

00:12:39,920 --> 00:12:43,519
unstructured data um

00:12:41,760 --> 00:12:45,519
although it's primarily a relational

00:12:43,519 --> 00:12:47,120
database it also includes features such

00:12:45,519 --> 00:12:48,399
as table inheritance and function

00:12:47,120 --> 00:12:50,639
overloading that are more often

00:12:48,399 --> 00:12:53,120
associated with object databases

00:12:50,639 --> 00:12:55,360
therefore uh it is considered an object

00:12:53,120 --> 00:12:57,200
relational database management system

00:12:55,360 --> 00:13:00,480
so for data storage and processing and

00:12:57,200 --> 00:13:02,320
postgres it does support 170 out of the

00:13:00,480 --> 00:13:05,360
179 features for full

00:13:02,320 --> 00:13:07,440
core sql 2016 compliance in addition to

00:13:05,360 --> 00:13:09,839
a long list of optional features

00:13:07,440 --> 00:13:10,639
um it is highly acid compliant i'm going

00:13:09,839 --> 00:13:13,440
to go through the

00:13:10,639 --> 00:13:14,639
acid principles in the next slide but

00:13:13,440 --> 00:13:16,000
this basically means that data

00:13:14,639 --> 00:13:16,959
transactions are protected through the

00:13:16,000 --> 00:13:18,880
principles of

00:13:16,959 --> 00:13:20,160
atomicity consistency isolation and

00:13:18,880 --> 00:13:21,839
durability

00:13:20,160 --> 00:13:23,279
all changes to data are performed as if

00:13:21,839 --> 00:13:25,120
they are a single operation

00:13:23,279 --> 00:13:27,279
and that guarantees validity even when

00:13:25,120 --> 00:13:29,200
faced with errors power failures etc

00:13:27,279 --> 00:13:31,600
which prevents data corruption

00:13:29,200 --> 00:13:32,560
this really enhances postgres sql's

00:13:31,600 --> 00:13:34,639
fault tolerance

00:13:32,560 --> 00:13:36,560
postgres sql is capable of effectively

00:13:34,639 --> 00:13:37,839
handling multiple tasks at the same time

00:13:36,560 --> 00:13:39,040
which is a characteristic known as

00:13:37,839 --> 00:13:41,040
concurrency

00:13:39,040 --> 00:13:42,639
it achieves this without relocks thanks

00:13:41,040 --> 00:13:44,000
to its implementation of multiversion

00:13:42,639 --> 00:13:45,680
concurrency control

00:13:44,000 --> 00:13:47,199
which allows multiple users to access

00:13:45,680 --> 00:13:49,199
data at the same time and manages

00:13:47,199 --> 00:13:50,639
concurrency efficiently

00:13:49,199 --> 00:13:52,399
which basically means that in practice

00:13:50,639 --> 00:13:54,399
the read operations don't block right

00:13:52,399 --> 00:13:58,000
operations and vice versa

00:13:54,399 --> 00:14:00,720
postgres sql is ideal for etl oltp

00:13:58,000 --> 00:14:02,000
o olap use cases and it's sql compliance

00:14:00,720 --> 00:14:03,680
and query optimizer

00:14:02,000 --> 00:14:05,360
also make it useful for analytics and

00:14:03,680 --> 00:14:07,839
data management

00:14:05,360 --> 00:14:10,079
so the acid principles automaticity

00:14:07,839 --> 00:14:11,760
consistency isolation durability as they

00:14:10,079 --> 00:14:14,079
apply to postgres

00:14:11,760 --> 00:14:16,079
so automaticity ensures that results of

00:14:14,079 --> 00:14:17,839
a transaction are seen entirely or not

00:14:16,079 --> 00:14:20,959
at all within transactions

00:14:17,839 --> 00:14:23,920
but a transaction need not appear atomic

00:14:20,959 --> 00:14:26,000
to itself postgres sql is consistent and

00:14:23,920 --> 00:14:27,279
system-defined consistency constraints

00:14:26,000 --> 00:14:28,399
are enforced on the results of

00:14:27,279 --> 00:14:29,760
transactions

00:14:28,399 --> 00:14:31,040
transactions are not affected by the

00:14:29,760 --> 00:14:33,120
behavior of concurrently running

00:14:31,040 --> 00:14:34,880
transactions which shows isolation

00:14:33,120 --> 00:14:36,720
and once a transaction commits its

00:14:34,880 --> 00:14:37,839
results will not be lost regardless of

00:14:36,720 --> 00:14:40,880
subsequent failures

00:14:37,839 --> 00:14:42,959
and this makes postgres sql durable

00:14:40,880 --> 00:14:45,440
so there is some interesting literature

00:14:42,959 --> 00:14:48,320
on the replication history in postgres

00:14:45,440 --> 00:14:48,560
um at first postgres only concentrated

00:14:48,320 --> 00:14:50,639
in

00:14:48,560 --> 00:14:52,720
single node fault tolerance and recovery

00:14:50,639 --> 00:14:54,399
which is mostly achieved by the

00:14:52,720 --> 00:14:56,240
wall transaction log which i'll discuss

00:14:54,399 --> 00:14:56,800
a little bit more later fault tolerance

00:14:56,240 --> 00:15:00,399
is handled

00:14:56,800 --> 00:15:02,800
partially by the mvcc which i discussed

00:15:00,399 --> 00:15:04,560
but that's mainly an optimization right

00:15:02,800 --> 00:15:06,000
ahead logging was and still is the

00:15:04,560 --> 00:15:07,279
biggest fault tolerance method in

00:15:06,000 --> 00:15:08,959
postgres sql

00:15:07,279 --> 00:15:10,480
basically just having wall files where

00:15:08,959 --> 00:15:12,000
you write everything and can recover in

00:15:10,480 --> 00:15:13,920
terms of failure by replacing

00:15:12,000 --> 00:15:15,440
them this was enough for single node

00:15:13,920 --> 00:15:16,880
architectures and replication is

00:15:15,440 --> 00:15:18,480
considered to be the best solution for

00:15:16,880 --> 00:15:19,199
achieving fault tolerance with multiple

00:15:18,480 --> 00:15:20,720
nodes

00:15:19,199 --> 00:15:22,240
eventually it became clear that one

00:15:20,720 --> 00:15:23,839
super tolerance is not enough

00:15:22,240 --> 00:15:25,519
and more people demanded proper fault

00:15:23,839 --> 00:15:26,480
tolerance of the hardware and proper way

00:15:25,519 --> 00:15:28,959
of switching

00:15:26,480 --> 00:15:30,399
something um and built in something to

00:15:28,959 --> 00:15:32,079
be built in postgres

00:15:30,399 --> 00:15:34,079
this is when physical then physical

00:15:32,079 --> 00:15:35,199
streaming replication came to life

00:15:34,079 --> 00:15:38,160
that's a little bit about the

00:15:35,199 --> 00:15:39,920
interesting uh replication history

00:15:38,160 --> 00:15:41,360
so some keys default tolerance and

00:15:39,920 --> 00:15:43,360
postgres it's uh

00:15:41,360 --> 00:15:45,040
it's again based on the acid principles

00:15:43,360 --> 00:15:47,040
if a failure occurs that prevents a

00:15:45,040 --> 00:15:48,480
transaction from completing and postgres

00:15:47,040 --> 00:15:50,639
then none of the steps affect the

00:15:48,480 --> 00:15:52,079
database essentially postgres does not

00:15:50,639 --> 00:15:53,360
support dirty reads

00:15:52,079 --> 00:15:54,639
in addition to the enhanced fault

00:15:53,360 --> 00:15:56,399
tolerance achieved through acid

00:15:54,639 --> 00:15:58,160
compliance all actions on the database

00:15:56,399 --> 00:16:00,480
are performed within transactions

00:15:58,160 --> 00:16:01,600
protected by that transaction log that

00:16:00,480 --> 00:16:03,120
wal

00:16:01,600 --> 00:16:05,519
that will perform automatic crash

00:16:03,120 --> 00:16:07,920
recovery in case of software failure

00:16:05,519 --> 00:16:09,759
um this allows a user to complete a

00:16:07,920 --> 00:16:11,839
restore back to a specific starting

00:16:09,759 --> 00:16:13,440
point in the event of a fault or failure

00:16:11,839 --> 00:16:15,759
called point in time recovery

00:16:13,440 --> 00:16:17,519
postgres sql allows physical and logical

00:16:15,759 --> 00:16:20,000
replication and has built-in physical

00:16:17,519 --> 00:16:21,759
and logical replication solutions

00:16:20,000 --> 00:16:24,720
database replication and postgres is

00:16:21,759 --> 00:16:26,639
supported natively

00:16:24,720 --> 00:16:28,320
physical streaming replication streams

00:16:26,639 --> 00:16:29,279
physical changes from one node to

00:16:28,320 --> 00:16:31,360
another using an

00:16:29,279 --> 00:16:33,759
internal protocol for sending those wall

00:16:31,360 --> 00:16:34,720
files for example when a row is inserted

00:16:33,759 --> 00:16:36,320
into a table

00:16:34,720 --> 00:16:38,320
change records are generated for the

00:16:36,320 --> 00:16:41,279
insert as well as for all the index

00:16:38,320 --> 00:16:42,240
entries by default postgresql implements

00:16:41,279 --> 00:16:44,399
asynchronous

00:16:42,240 --> 00:16:46,079
replication where data is streamed out

00:16:44,399 --> 00:16:47,920
whenever convenient for the server

00:16:46,079 --> 00:16:49,600
however this can result in data loss in

00:16:47,920 --> 00:16:51,600
the case of a fault or failure

00:16:49,600 --> 00:16:53,279
therefore it's possible to ask postgres

00:16:51,600 --> 00:16:55,120
to require one or more

00:16:53,279 --> 00:16:56,480
standbys to acknowledge replication of

00:16:55,120 --> 00:16:58,560
the data prior to commit

00:16:56,480 --> 00:17:00,240
which is called synchronous replication

00:16:58,560 --> 00:17:02,240
synchronous replication guarantees that

00:17:00,240 --> 00:17:04,000
data is written to at least two nodes

00:17:02,240 --> 00:17:06,079
before the user or application is told

00:17:04,000 --> 00:17:08,240
that a transaction has committed the

00:17:06,079 --> 00:17:10,000
user can select the commit mode of each

00:17:08,240 --> 00:17:11,280
transaction so that it is possible to

00:17:10,000 --> 00:17:13,520
have both synchronous

00:17:11,280 --> 00:17:14,799
and asynchronous commit transactions

00:17:13,520 --> 00:17:16,640
running concurrently

00:17:14,799 --> 00:17:18,880
this is important as with synchronous

00:17:16,640 --> 00:17:20,640
replication the replication delay will

00:17:18,880 --> 00:17:22,160
directly affect the elapsed time of

00:17:20,640 --> 00:17:24,160
transactions on the master

00:17:22,160 --> 00:17:25,919
with asynchronous replication the master

00:17:24,160 --> 00:17:27,760
may continue at full speed

00:17:25,919 --> 00:17:29,440
therefore this option allows flexible

00:17:27,760 --> 00:17:30,880
trade-offs between performance and fault

00:17:29,440 --> 00:17:32,320
tolerance

00:17:30,880 --> 00:17:33,760
the quorum commit feature further

00:17:32,320 --> 00:17:35,679
enhances fault tolerance as it can

00:17:33,760 --> 00:17:37,360
facilitate right to at least two nodes

00:17:35,679 --> 00:17:39,120
before the transaction is considered

00:17:37,360 --> 00:17:40,880
completed

00:17:39,120 --> 00:17:42,799
when a transaction commits the default

00:17:40,880 --> 00:17:45,840
behavior is to force that wall

00:17:42,799 --> 00:17:47,360
uh record that wall log to disk if a

00:17:45,840 --> 00:17:48,960
fault or failure is encountered and

00:17:47,360 --> 00:17:50,960
postgresql crashes

00:17:48,960 --> 00:17:52,240
the wall will be replayed which returns

00:17:50,960 --> 00:17:54,000
the database to the point

00:17:52,240 --> 00:17:55,360
of the last committed transaction and

00:17:54,000 --> 00:17:56,799
ensures that your ability of any

00:17:55,360 --> 00:17:58,240
database changes

00:17:56,799 --> 00:18:00,080
recovery starts from points on the wall

00:17:58,240 --> 00:18:02,000
known as checkpoints which are known

00:18:00,080 --> 00:18:03,840
um which are known safe starting points

00:18:02,000 --> 00:18:05,200
for recovery they can be either

00:18:03,840 --> 00:18:08,320
immediate or scheduled

00:18:05,200 --> 00:18:10,000
the duration of crash recovery

00:18:08,320 --> 00:18:11,760
changes in the transaction log since the

00:18:10,000 --> 00:18:14,000
last checkpoint

00:18:11,760 --> 00:18:15,200
postgres has also introduced a notion of

00:18:14,000 --> 00:18:17,039
timelines

00:18:15,200 --> 00:18:18,240
um i i won't go through that too much

00:18:17,039 --> 00:18:19,520
but that's quite interesting if you want

00:18:18,240 --> 00:18:21,360
to refer back to that

00:18:19,520 --> 00:18:23,360
and pg rewind is a tool for

00:18:21,360 --> 00:18:25,600
synchronizing a postgres sql cluster

00:18:23,360 --> 00:18:28,240
with another copy of the same cluster

00:18:25,600 --> 00:18:28,960
um so that's also a very useful tool

00:18:28,240 --> 00:18:31,600
within

00:18:28,960 --> 00:18:33,360
postgres databases may be optionally

00:18:31,600 --> 00:18:34,960
created with data block checksums to

00:18:33,360 --> 00:18:36,480
help diagnose hardware faults so that

00:18:34,960 --> 00:18:37,360
can be very helpful in fall tolerance as

00:18:36,480 --> 00:18:38,880
well

00:18:37,360 --> 00:18:40,720
therefore the key characteristics which

00:18:38,880 --> 00:18:42,400
support fault tolerance and postgres are

00:18:40,720 --> 00:18:43,120
point in time recovery and right ahead

00:18:42,400 --> 00:18:44,559
logging

00:18:43,120 --> 00:18:47,200
built-in physical and logical

00:18:44,559 --> 00:18:48,400
replication methods isolation levels and

00:18:47,200 --> 00:18:50,720
acid features

00:18:48,400 --> 00:18:54,480
checkpointing and crash recovery and use

00:18:50,720 --> 00:18:57,200
of extensions such as pg rewind

00:18:54,480 --> 00:18:58,640
and using patrony with postgres petronia

00:18:57,200 --> 00:19:00,720
is a popular tool to maximize

00:18:58,640 --> 00:19:02,640
availability in postgres sql

00:19:00,720 --> 00:19:04,400
it is a template for anyone to create

00:19:02,640 --> 00:19:05,919
their own customized high availability

00:19:04,400 --> 00:19:09,120
solution using python

00:19:05,919 --> 00:19:11,280
for maximum accessibility um and can use

00:19:09,120 --> 00:19:12,240
a distributed configuration store like

00:19:11,280 --> 00:19:15,600
zookeeper

00:19:12,240 --> 00:19:16,880
uh console kubernetes etc a list of

00:19:15,600 --> 00:19:17,760
tools that can be used to increase

00:19:16,880 --> 00:19:20,559
availability

00:19:17,760 --> 00:19:22,160
um is uh is there i've linked it on the

00:19:20,559 --> 00:19:24,320
on the slides

00:19:22,160 --> 00:19:26,720
so the key fault tolerance enhancements

00:19:24,320 --> 00:19:27,520
added in postgres 13 which has recently

00:19:26,720 --> 00:19:30,400
been released

00:19:27,520 --> 00:19:31,919
are the parallel vacuum for indexes

00:19:30,400 --> 00:19:33,440
which speed up the vacuuming of the

00:19:31,919 --> 00:19:35,039
indexes which helps to clean up the

00:19:33,440 --> 00:19:36,320
database and ensure that you do not run

00:19:35,039 --> 00:19:38,400
out of space on disk

00:19:36,320 --> 00:19:39,440
or experience transaction wrap around

00:19:38,400 --> 00:19:41,280
where the database

00:19:39,440 --> 00:19:42,799
wraps around back to one after two

00:19:41,280 --> 00:19:44,559
billion transactions and starts to

00:19:42,799 --> 00:19:47,840
overwrite transactions

00:19:44,559 --> 00:19:48,559
um inserts now can also trigger an auto

00:19:47,840 --> 00:19:50,559
vacuum

00:19:48,559 --> 00:19:52,080
previously only updates or deletes could

00:19:50,559 --> 00:19:54,080
trigger an auto vacuum

00:19:52,080 --> 00:19:55,520
the auto vacuum mechanism is important

00:19:54,080 --> 00:19:57,039
as it helps ensure you don't run out of

00:19:55,520 --> 00:20:00,080
disk space and also

00:19:57,039 --> 00:20:01,200
prevents that transaction wrap around pg

00:20:00,080 --> 00:20:03,360
verified backup

00:20:01,200 --> 00:20:05,280
is a core utility that helps to verify

00:20:03,360 --> 00:20:08,320
that a physical backup is correct

00:20:05,280 --> 00:20:10,799
so it verifies the check sums um

00:20:08,320 --> 00:20:13,039
and pg based backup is integratable if

00:20:10,799 --> 00:20:15,679
it is needed for restoring recovery

00:20:13,039 --> 00:20:17,280
the wall append only logging um

00:20:15,679 --> 00:20:18,720
facilitates streaming replication and

00:20:17,280 --> 00:20:20,640
helps to prevent the primary from

00:20:18,720 --> 00:20:24,400
running out of disk space

00:20:20,640 --> 00:20:25,919
um and uh and

00:20:24,400 --> 00:20:28,159
the slot will not get dropped by the

00:20:25,919 --> 00:20:29,840
wall logs after it gets flushed

00:20:28,159 --> 00:20:31,760
uh wall receivers can use temporary

00:20:29,840 --> 00:20:33,520
replication slot wall can use a

00:20:31,760 --> 00:20:35,520
temporary replication slot on a replica

00:20:33,520 --> 00:20:37,200
until reconfiguration can be completed

00:20:35,520 --> 00:20:38,880
this prevents a replica from falling out

00:20:37,200 --> 00:20:40,000
of sync as well

00:20:38,880 --> 00:20:42,240
streaming replication can be

00:20:40,000 --> 00:20:43,840
reconfigured with a reload a replica

00:20:42,240 --> 00:20:45,440
can be reconfigured with a reload

00:20:43,840 --> 00:20:47,360
instead of a restart this

00:20:45,440 --> 00:20:48,799
reduces the total number of restarts

00:20:47,360 --> 00:20:50,880
necessary

00:20:48,799 --> 00:20:52,320
um a wall recovery can continue if there

00:20:50,880 --> 00:20:53,840
are invalid pages

00:20:52,320 --> 00:20:55,360
while will continue to replay and does

00:20:53,840 --> 00:20:56,720
not abort which will get the database

00:20:55,360 --> 00:20:58,960
back to a valid state

00:20:56,720 --> 00:21:00,880
that can this can then allow you to use

00:20:58,960 --> 00:21:02,720
the diagnostic and introspective

00:21:00,880 --> 00:21:03,919
introspection tools to determine the

00:21:02,720 --> 00:21:06,400
root cause

00:21:03,919 --> 00:21:08,640
and pg rewind can now configure standbys

00:21:06,400 --> 00:21:10,320
so pg rewind is a core utility which can

00:21:08,640 --> 00:21:12,000
rewind or fast forward the wall

00:21:10,320 --> 00:21:13,520
and can now inject the configuration to

00:21:12,000 --> 00:21:16,320
bring a standby back up so that was

00:21:13,520 --> 00:21:19,039
another important enhancement

00:21:16,320 --> 00:21:20,799
so jumping into hadoop a little bit of

00:21:19,039 --> 00:21:23,360
background here hadoop is written in

00:21:20,799 --> 00:21:26,000
java and was initially released in 2006

00:21:23,360 --> 00:21:27,679
it is licensed under the apache 2.0

00:21:26,000 --> 00:21:29,039
license and which is also a free and

00:21:27,679 --> 00:21:30,480
open source license

00:21:29,039 --> 00:21:32,480
it is a collection of open source

00:21:30,480 --> 00:21:34,320
software utilities that facilitate using

00:21:32,480 --> 00:21:34,960
a network of many computers to solve

00:21:34,320 --> 00:21:36,559
problems

00:21:34,960 --> 00:21:38,640
involving massive amounts of data and

00:21:36,559 --> 00:21:40,480
computation this is done using the

00:21:38,640 --> 00:21:43,039
hadoop distributed file system

00:21:40,480 --> 00:21:45,120
hdfs sometimes combining this with data

00:21:43,039 --> 00:21:47,440
storage systems such as hbase or

00:21:45,120 --> 00:21:48,880
hive hadoop common which provides the

00:21:47,440 --> 00:21:49,760
tools needed for the user's computer

00:21:48,880 --> 00:21:53,120
systems

00:21:49,760 --> 00:21:55,280
um os debian freebsd et cetera to read

00:21:53,120 --> 00:21:57,760
data stored under the hadoop file system

00:21:55,280 --> 00:21:58,640
and yarn yet another resource negotia

00:21:57,760 --> 00:22:00,799
negotiator

00:21:58,640 --> 00:22:02,159
which manages resources of the systems

00:22:00,799 --> 00:22:02,960
storing the data and running the

00:22:02,159 --> 00:22:04,720
analysis

00:22:02,960 --> 00:22:07,120
as well as the mapreduce programming

00:22:04,720 --> 00:22:10,400
model so it's primarily those

00:22:07,120 --> 00:22:10,400
uh key components

00:22:10,480 --> 00:22:15,120
um so i'll be focusing on hdfs and

00:22:13,120 --> 00:22:17,120
mapreduce in the next few slides a

00:22:15,120 --> 00:22:17,840
mapreduce program is composed of a map

00:22:17,120 --> 00:22:19,919
procedure

00:22:17,840 --> 00:22:20,960
which performs filtering and sorting and

00:22:19,919 --> 00:22:23,360
a reduced method

00:22:20,960 --> 00:22:24,559
which performs a summary operation the

00:22:23,360 --> 00:22:26,000
mapreduce system

00:22:24,559 --> 00:22:28,000
uh which is also sometimes called an

00:22:26,000 --> 00:22:29,520
infrastructure or framework orchestrates

00:22:28,000 --> 00:22:31,200
the processing by marshaling the

00:22:29,520 --> 00:22:32,400
distributed servers running the various

00:22:31,200 --> 00:22:34,240
tasks in parallel

00:22:32,400 --> 00:22:35,600
managing all the communications and data

00:22:34,240 --> 00:22:36,400
transfers between the various parts of

00:22:35,600 --> 00:22:38,080
the system

00:22:36,400 --> 00:22:39,679
and providing for redundancy and fault

00:22:38,080 --> 00:22:41,679
tolerance

00:22:39,679 --> 00:22:44,000
data storage and processing in hadoop

00:22:41,679 --> 00:22:45,200
within the hdfs layer there is a name

00:22:44,000 --> 00:22:47,360
node and data nodes

00:22:45,200 --> 00:22:49,039
the name node manages the file system

00:22:47,360 --> 00:22:50,320
keeping the metadata for all the files

00:22:49,039 --> 00:22:52,320
and directories in the tree

00:22:50,320 --> 00:22:54,080
while the data nodes store and retrieve

00:22:52,320 --> 00:22:56,000
the data blocks when they are told to

00:22:54,080 --> 00:22:57,039
buy clients or the name node and report

00:22:56,000 --> 00:22:59,200
back to the name node

00:22:57,039 --> 00:23:00,880
periodically which is called a heartbeat

00:22:59,200 --> 00:23:03,440
within the mapreduce layer

00:23:00,880 --> 00:23:04,880
there is a job tracker and task trackers

00:23:03,440 --> 00:23:06,799
the job tracker cord

00:23:04,880 --> 00:23:08,159
coordinates the execution of the jobs

00:23:06,799 --> 00:23:10,000
and the task trackers

00:23:08,159 --> 00:23:12,000
control the execution of the map and

00:23:10,000 --> 00:23:13,360
reduce tasks in the machines that are

00:23:12,000 --> 00:23:14,640
doing the processing

00:23:13,360 --> 00:23:16,000
hadoop can be used to support

00:23:14,640 --> 00:23:17,120
distributed fault tolerant data

00:23:16,000 --> 00:23:18,080
processing and storage for

00:23:17,120 --> 00:23:20,400
semi-structured

00:23:18,080 --> 00:23:22,240
and nosql data it can also be used to

00:23:20,400 --> 00:23:22,880
manage structured data especially data

00:23:22,240 --> 00:23:25,360
in

00:23:22,880 --> 00:23:26,960
part k and orc formats and can be

00:23:25,360 --> 00:23:28,960
integrated with database stores other

00:23:26,960 --> 00:23:31,200
than hdfs

00:23:28,960 --> 00:23:32,320
hdfs is particularly useful for data

00:23:31,200 --> 00:23:33,679
lake applications

00:23:32,320 --> 00:23:35,919
as well as for establishing text

00:23:33,679 --> 00:23:37,520
oriented or rich media data warehouses

00:23:35,919 --> 00:23:39,280
however data warehouse infrastructure

00:23:37,520 --> 00:23:41,360
data is restricted in hadoop

00:23:39,280 --> 00:23:43,120
due to the lack of record level indexing

00:23:41,360 --> 00:23:45,760
so that's an important point

00:23:43,120 --> 00:23:47,200
fault tolerance in hadoop despite faults

00:23:45,760 --> 00:23:48,720
and failures hadoop will guide jobs

00:23:47,200 --> 00:23:50,559
towards successful completion

00:23:48,720 --> 00:23:52,320
hadoop was established as a platform to

00:23:50,559 --> 00:23:53,679
support distributed computing leveraging

00:23:52,320 --> 00:23:54,400
cheap commodity hardware from the

00:23:53,679 --> 00:23:56,080
beginning

00:23:54,400 --> 00:23:57,600
individual nodes and network components

00:23:56,080 --> 00:23:58,880
were assumed to experience high rates of

00:23:57,600 --> 00:24:00,159
faulted failure

00:23:58,880 --> 00:24:01,679
as such it was designed from the

00:24:00,159 --> 00:24:03,600
beginning to withstand those regular

00:24:01,679 --> 00:24:05,120
faults and failures within that hardware

00:24:03,600 --> 00:24:06,960
the discussion will be broken down into

00:24:05,120 --> 00:24:07,440
fault tolerance features in the hdfs

00:24:06,960 --> 00:24:11,039
layer

00:24:07,440 --> 00:24:12,799
and the mapreduce layer but within hdfs

00:24:11,039 --> 00:24:14,000
the detection of faults and rapid

00:24:12,799 --> 00:24:16,880
automatic recovery are

00:24:14,000 --> 00:24:19,279
key goals um failures may occur in

00:24:16,880 --> 00:24:21,279
either the name node or those data nodes

00:24:19,279 --> 00:24:23,120
if the name node does not receive the

00:24:21,279 --> 00:24:24,320
heartbeat signal from a data node for 10

00:24:23,120 --> 00:24:26,320
minutes

00:24:24,320 --> 00:24:28,240
and that can be changed if needed it

00:24:26,320 --> 00:24:29,200
considers that data node to be dead or

00:24:28,240 --> 00:24:31,039
out of service

00:24:29,200 --> 00:24:32,640
the name node then initiates replication

00:24:31,039 --> 00:24:34,240
of the data blocks that were hosted on

00:24:32,640 --> 00:24:35,200
that now dead node to be hosted on

00:24:34,240 --> 00:24:37,600
another node

00:24:35,200 --> 00:24:40,320
there's only one named node per cluster

00:24:37,600 --> 00:24:41,520
prior to hadoop 2.0 the name node was a

00:24:40,320 --> 00:24:44,799
single point of failure for

00:24:41,520 --> 00:24:46,799
an um hdfs cluster however there is an

00:24:44,799 --> 00:24:47,279
option to have two redundant name nodes

00:24:46,799 --> 00:24:49,120
now

00:24:47,279 --> 00:24:51,279
in the same cluster using an active

00:24:49,120 --> 00:24:54,159
passive configuration with a hot standby

00:24:51,279 --> 00:24:55,120
this also allows a gentle administration

00:24:54,159 --> 00:24:57,120
administrator

00:24:55,120 --> 00:25:00,000
initiated failover for plan maintenance

00:24:57,120 --> 00:25:01,760
and servicing

00:25:00,000 --> 00:25:03,600
so fault tolerance and mapreduce is a

00:25:01,760 --> 00:25:05,360
little bit different jobs can fail in

00:25:03,600 --> 00:25:06,480
mapreduce in different ways through the

00:25:05,360 --> 00:25:08,720
job tracker

00:25:06,480 --> 00:25:10,799
or through a task tracker failure or

00:25:08,720 --> 00:25:12,400
while running the task itself

00:25:10,799 --> 00:25:14,000
if a task tracker stops sending a

00:25:12,400 --> 00:25:15,679
heartbeat signal to the job tracker

00:25:14,000 --> 00:25:17,520
the job tracker will remove that task

00:25:15,679 --> 00:25:19,120
from the pool to handle failures that

00:25:17,520 --> 00:25:20,960
occur while running a task

00:25:19,120 --> 00:25:22,480
the task tracker marks the task attempt

00:25:20,960 --> 00:25:22,960
as failed and creates room for another

00:25:22,480 --> 00:25:25,279
task

00:25:22,960 --> 00:25:27,520
the failed job can then be rerun if the

00:25:25,279 --> 00:25:29,039
job tracker fails it you um

00:25:27,520 --> 00:25:31,360
it used to act as a single point of

00:25:29,039 --> 00:25:32,000
failure however one of the key goals of

00:25:31,360 --> 00:25:33,679
yarn

00:25:32,000 --> 00:25:35,120
uh when yarn was introduced was to

00:25:33,679 --> 00:25:36,000
eliminate single points of failure in

00:25:35,120 --> 00:25:38,640
mapreduce

00:25:36,000 --> 00:25:39,360
as of hadoop 2.0.0 when yarn was

00:25:38,640 --> 00:25:40,559
introduced

00:25:39,360 --> 00:25:42,799
there are no more single points of

00:25:40,559 --> 00:25:45,279
failure in mapreduce mapreduce sits on

00:25:42,799 --> 00:25:47,120
top of yarn which sits on top of hdfs

00:25:45,279 --> 00:25:49,360
yarn includes a resource manager node

00:25:47,120 --> 00:25:51,200
manager and application master

00:25:49,360 --> 00:25:53,039
in the event of a crash the resource

00:25:51,200 --> 00:25:53,679
manager can be recovered from a saved

00:25:53,039 --> 00:25:55,520
state

00:25:53,679 --> 00:25:58,240
the state consists of known managers in

00:25:55,520 --> 00:25:59,919
the systems and the running applications

00:25:58,240 --> 00:26:01,360
so some more recent enhancements to

00:25:59,919 --> 00:26:04,240
fault tolerance and hadoop

00:26:01,360 --> 00:26:06,080
before hadoop 3.0.0 hadoop handled

00:26:04,240 --> 00:26:07,919
faults through replica creation

00:26:06,080 --> 00:26:09,840
which means that it created a replica of

00:26:07,919 --> 00:26:12,480
the user's data on different machines

00:26:09,840 --> 00:26:14,000
those data nodes in the hdfs cluster so

00:26:12,480 --> 00:26:15,679
if a machine failed there would be a

00:26:14,000 --> 00:26:17,520
copy of the data available

00:26:15,679 --> 00:26:18,960
creating redundancy the number of

00:26:17,520 --> 00:26:20,960
replicas created dependent on the

00:26:18,960 --> 00:26:21,520
replication factor which was three by

00:26:20,960 --> 00:26:23,679
default

00:26:21,520 --> 00:26:25,279
for that default two replicas would be

00:26:23,679 --> 00:26:26,400
created on different nodes in addition

00:26:25,279 --> 00:26:28,480
to the original

00:26:26,400 --> 00:26:30,640
uh in additional to the original which

00:26:28,480 --> 00:26:34,000
would be three replicas in total

00:26:30,640 --> 00:26:35,440
as of hadoop 3.0 uh two or more standby

00:26:34,000 --> 00:26:37,679
nodes are supported to provide

00:26:35,440 --> 00:26:40,080
additional fault tolerance unlike hadoop

00:26:37,679 --> 00:26:42,159
2.0 which supported only two name nodes

00:26:40,080 --> 00:26:43,520
this limited fault tolerance as hdfs

00:26:42,159 --> 00:26:45,840
could run only

00:26:43,520 --> 00:26:46,559
one single standby and a single active

00:26:45,840 --> 00:26:48,080
name node

00:26:46,559 --> 00:26:50,159
this limitation has been addressed in

00:26:48,080 --> 00:26:53,200
hadoop 3.0 to enhance the fault

00:26:50,159 --> 00:26:56,320
tolerance in hdfs

00:26:53,200 --> 00:26:57,600
in hadoop 3.0.0 erasure coding was

00:26:56,320 --> 00:27:00,880
introduced this was

00:26:57,600 --> 00:27:03,039
a big improvement um in this release

00:27:00,880 --> 00:27:04,720
it improved storage efficient efficiency

00:27:03,039 --> 00:27:06,159
while also providing the same level of

00:27:04,720 --> 00:27:08,320
fault tolerance as the traditional

00:27:06,159 --> 00:27:11,120
replication-based hdfs

00:27:08,320 --> 00:27:12,000
it had much less storage overhead

00:27:11,120 --> 00:27:15,200
essentially

00:27:12,000 --> 00:27:17,120
um raid architectures use erasure coding

00:27:15,200 --> 00:27:18,799
which cuts the file into different units

00:27:17,120 --> 00:27:20,559
and stores it on various disks

00:27:18,799 --> 00:27:22,559
for each strip a certain number of

00:27:20,559 --> 00:27:24,399
parity cells are calculated and stored

00:27:22,559 --> 00:27:26,480
so that if any machine fails the block

00:27:24,399 --> 00:27:28,320
can be recovered from that purity cell

00:27:26,480 --> 00:27:30,799
this reduces the storage overhead by up

00:27:28,320 --> 00:27:33,600
to 50 percent which is huge

00:27:30,799 --> 00:27:34,480
prior to the 3.3.0 release information

00:27:33,600 --> 00:27:37,200
from a data

00:27:34,480 --> 00:27:38,799
dead data node in in the stream was

00:27:37,200 --> 00:27:40,880
stored locally this meant that it could

00:27:38,799 --> 00:27:43,600
not be shared among the input streams

00:27:40,880 --> 00:27:45,679
of that same client in hdfs to eliminate

00:27:43,600 --> 00:27:47,279
this impact from dead data nodes a dead

00:27:45,679 --> 00:27:49,120
data node detector was designed

00:27:47,279 --> 00:27:50,960
which detects that those dead nodes and

00:27:49,120 --> 00:27:52,880
shares this information among all the

00:27:50,960 --> 00:27:55,039
input streams in the same client

00:27:52,880 --> 00:27:56,880
therefore when a dead node blocks that

00:27:55,039 --> 00:27:58,399
stream dead node detection

00:27:56,880 --> 00:28:00,240
can find it and share this information

00:27:58,399 --> 00:28:00,880
to the other streams in the same dfs

00:28:00,240 --> 00:28:02,799
client

00:28:00,880 --> 00:28:05,600
this means that the dfs streams will not

00:28:02,799 --> 00:28:07,200
bother reading from that dead node

00:28:05,600 --> 00:28:10,000
and some other key enhancements in

00:28:07,200 --> 00:28:13,120
hadoop 3.0.0

00:28:10,000 --> 00:28:14,000
and other three uh releases are are

00:28:13,120 --> 00:28:15,919
these ones here

00:28:14,000 --> 00:28:17,679
um i'm hoping to dive into some of these

00:28:15,919 --> 00:28:20,399
a little bit more particularly

00:28:17,679 --> 00:28:21,039
that uh support for eargier encoding the

00:28:20,399 --> 00:28:23,200
yarn

00:28:21,039 --> 00:28:24,559
timeline service um the support for more

00:28:23,200 --> 00:28:26,880
than two name nodes

00:28:24,559 --> 00:28:28,799
the default ports of multiple services

00:28:26,880 --> 00:28:30,960
having been changed and the intra

00:28:28,799 --> 00:28:32,320
data node balancer are areas i'm hoping

00:28:30,960 --> 00:28:34,240
to dive in more

00:28:32,320 --> 00:28:35,679
i just want to quickly discuss using

00:28:34,240 --> 00:28:37,200
ambari with hadoop

00:28:35,679 --> 00:28:39,120
apache mbari is an open source

00:28:37,200 --> 00:28:40,720
management platform for provisioning

00:28:39,120 --> 00:28:42,320
managing and monitoring

00:28:40,720 --> 00:28:44,320
as well as securing apache hadoop

00:28:42,320 --> 00:28:46,080
clusters it is it used to be a

00:28:44,320 --> 00:28:47,440
sub-project of hadoop but it is now a

00:28:46,080 --> 00:28:49,760
top-level project

00:28:47,440 --> 00:28:51,279
it has a wizard-driven interface which

00:28:49,760 --> 00:28:52,480
can assist in the config

00:28:51,279 --> 00:28:55,360
configuration of fault-tolerant

00:28:52,480 --> 00:28:56,960
components it can help protect hdfs data

00:28:55,360 --> 00:28:58,799
and metadata as it enables the

00:28:56,960 --> 00:29:01,039
configuration of hdfs

00:28:58,799 --> 00:29:01,919
snapshots for data protection and backup

00:29:01,039 --> 00:29:03,520
so that's very

00:29:01,919 --> 00:29:05,120
important uh when we're discussing fault

00:29:03,520 --> 00:29:06,559
tolerance and

00:29:05,120 --> 00:29:08,480
um ambari allows the system

00:29:06,559 --> 00:29:10,159
administrator to manage and disable

00:29:08,480 --> 00:29:12,559
components of a particular service or

00:29:10,159 --> 00:29:14,320
cluster and fault tolerance is enhanced

00:29:12,559 --> 00:29:15,760
by establishing primary and secondary

00:29:14,320 --> 00:29:16,480
components of different clusters in

00:29:15,760 --> 00:29:18,559
ambari

00:29:16,480 --> 00:29:20,559
providing redundancy in case a primary

00:29:18,559 --> 00:29:23,600
component fails or becomes unavailable

00:29:20,559 --> 00:29:26,240
so we can see how ambari can enhance

00:29:23,600 --> 00:29:28,000
fault tolerance with hadoop

00:29:26,240 --> 00:29:29,360
so fault tolerance and resilience

00:29:28,000 --> 00:29:31,279
systems i did want to

00:29:29,360 --> 00:29:33,760
kind of do a little bit of contrasting

00:29:31,279 --> 00:29:35,600
and comparing between these terms

00:29:33,760 --> 00:29:37,679
um so resilience is based on the

00:29:35,600 --> 00:29:38,159
shifting relationship between skills and

00:29:37,679 --> 00:29:39,760
between

00:29:38,159 --> 00:29:41,679
autonomy on the one hand and

00:29:39,760 --> 00:29:42,960
connectivity on the other i really like

00:29:41,679 --> 00:29:44,799
that description

00:29:42,960 --> 00:29:46,480
um from this paper here which is

00:29:44,799 --> 00:29:48,320
actually uh which was published in the

00:29:46,480 --> 00:29:51,440
journal of landscape architecture

00:29:48,320 --> 00:29:54,640
and i thought it was just um so well put

00:29:51,440 --> 00:29:57,120
um so recently in canada we had um

00:29:54,640 --> 00:29:58,480
our speech from the throne and the theme

00:29:57,120 --> 00:29:59,760
for that speech from the throne was

00:29:58,480 --> 00:30:02,880
build back better

00:29:59,760 --> 00:30:04,320
and um multiple times resiliency

00:30:02,880 --> 00:30:06,159
and the word resilient were mentioned

00:30:04,320 --> 00:30:07,120
and i pulled out a couple instances here

00:30:06,159 --> 00:30:09,440
in the slide

00:30:07,120 --> 00:30:11,520
um so that's definitely a key for for

00:30:09,440 --> 00:30:13,279
canada moving forward this whole

00:30:11,520 --> 00:30:14,799
concept of resilience and i wanted to

00:30:13,279 --> 00:30:16,640
kind of dive a little bit

00:30:14,799 --> 00:30:18,320
into what are sort of the the

00:30:16,640 --> 00:30:19,840
commonalities and differences between

00:30:18,320 --> 00:30:22,159
fault tolerance and resilience and how

00:30:19,840 --> 00:30:25,279
they really do fit together

00:30:22,159 --> 00:30:27,520
so fault tolerance and resilience um

00:30:25,279 --> 00:30:28,320
i did uh look at this the seminal piece

00:30:27,520 --> 00:30:30,880
by lorenz

00:30:28,320 --> 00:30:32,320
uh lorenzo stragini on fault tolerance

00:30:30,880 --> 00:30:34,480
and resilience meanings measures and

00:30:32,320 --> 00:30:36,000
assessment um and i do pull out a couple

00:30:34,480 --> 00:30:38,559
passages from there because it

00:30:36,000 --> 00:30:39,840
it was just um very well put i thought

00:30:38,559 --> 00:30:42,480
the word resilience from

00:30:39,840 --> 00:30:42,880
is from the latin verb um meaning to

00:30:42,480 --> 00:30:45,039
jump

00:30:42,880 --> 00:30:46,640
back which means literally the tendency

00:30:45,039 --> 00:30:48,240
or ability to spring back

00:30:46,640 --> 00:30:50,240
and thus the ability of a body to

00:30:48,240 --> 00:30:52,159
recover its normal size and shape after

00:30:50,240 --> 00:30:54,559
being pushed or pulled out of shape

00:30:52,159 --> 00:30:56,159
and therefore figuratively any ability

00:30:54,559 --> 00:30:57,200
to recover to normality after a

00:30:56,159 --> 00:30:58,960
disturbance

00:30:57,200 --> 00:31:00,640
engineering concepts that are related to

00:30:58,960 --> 00:31:02,080
resilience therefore include for

00:31:00,640 --> 00:31:04,320
instance fault tolerance

00:31:02,080 --> 00:31:05,200
redundancy stability and feedback

00:31:04,320 --> 00:31:07,279
control

00:31:05,200 --> 00:31:09,440
a review of uses of the word resilience

00:31:07,279 --> 00:31:10,559
by scientists identified uses in child

00:31:09,440 --> 00:31:13,039
psychology

00:31:10,559 --> 00:31:14,559
psychiatry ecology business and

00:31:13,039 --> 00:31:16,720
industrial safety so there's

00:31:14,559 --> 00:31:18,159
certainly a more broad use of the term

00:31:16,720 --> 00:31:20,480
resilience than there is a fault

00:31:18,159 --> 00:31:23,200
tolerance

00:31:20,480 --> 00:31:24,960
the 2007 resist document for instance

00:31:23,200 --> 00:31:26,399
concluded that a useful meaning to apply

00:31:24,960 --> 00:31:29,919
to resilience for current

00:31:26,399 --> 00:31:32,240
and future ict is the ability to deliver

00:31:29,919 --> 00:31:33,679
maintain improved service when facing

00:31:32,240 --> 00:31:36,960
threats and evolutionary

00:31:33,679 --> 00:31:39,039
changes so the important extension to

00:31:36,960 --> 00:31:40,399
emphasize in comparison with words like

00:31:39,039 --> 00:31:44,640
fault tolerance

00:31:40,399 --> 00:31:47,120
seems to be that disturbances

00:31:44,640 --> 00:31:48,720
need to be tolerated and that current

00:31:47,120 --> 00:31:52,559
and future systems

00:31:48,720 --> 00:31:55,039
also need to be able to tolerate change

00:31:52,559 --> 00:31:56,240
so lorenzo stragini put it really well

00:31:55,039 --> 00:31:58,320
in that seminal piece

00:31:56,240 --> 00:32:00,000
while existing practices of dependable

00:31:58,320 --> 00:32:01,760
design deal reasonably well with

00:32:00,000 --> 00:32:03,200
achieving and predicting dependability

00:32:01,760 --> 00:32:05,440
in ict systems

00:32:03,200 --> 00:32:06,799
that are relatively close and unchanging

00:32:05,440 --> 00:32:08,480
the tendency to making

00:32:06,799 --> 00:32:10,000
all kinds of ict systems more

00:32:08,480 --> 00:32:11,360
interconnected open

00:32:10,000 --> 00:32:13,360
and able to change without new

00:32:11,360 --> 00:32:15,120
intervention by designers is making

00:32:13,360 --> 00:32:16,480
existing technologies inadequate to

00:32:15,120 --> 00:32:19,039
deliver the same levels of

00:32:16,480 --> 00:32:20,799
dependability for instance evolution

00:32:19,039 --> 00:32:22,320
itself of the system and its uses

00:32:20,799 --> 00:32:24,480
impairs dependability

00:32:22,320 --> 00:32:26,159
new components create system design

00:32:24,480 --> 00:32:28,399
faults or vulnerabilities

00:32:26,159 --> 00:32:29,760
by feature interaction or by triggering

00:32:28,399 --> 00:32:32,240
pre-existing bugs

00:32:29,760 --> 00:32:34,080
in existing components likewise new

00:32:32,240 --> 00:32:36,240
patterns of use arise

00:32:34,080 --> 00:32:38,559
new interconnections open the system to

00:32:36,240 --> 00:32:40,159
attack by new potential adversaries and

00:32:38,559 --> 00:32:42,080
so on so i thought that was

00:32:40,159 --> 00:32:43,840
a really well put and really thought

00:32:42,080 --> 00:32:45,600
provoking

00:32:43,840 --> 00:32:47,840
an important specialized use of the word

00:32:45,600 --> 00:32:48,480
resilience has emerged uh within the

00:32:47,840 --> 00:32:51,840
engineering

00:32:48,480 --> 00:32:53,360
field um so this term is resilience

00:32:51,840 --> 00:32:56,559
engineering and it is sort of

00:32:53,360 --> 00:32:59,200
a movement a new sub discipline

00:32:56,559 --> 00:33:00,320
and it looks at complex socio-technical

00:32:59,200 --> 00:33:02,559
systems

00:33:00,320 --> 00:33:04,240
so within this sphere the word

00:33:02,559 --> 00:33:05,679
resilience is meant to identify

00:33:04,240 --> 00:33:08,159
enhanced ability to deal with the

00:33:05,679 --> 00:33:08,880
unexpected or a more flexible approach

00:33:08,159 --> 00:33:10,720
to achieving

00:33:08,880 --> 00:33:13,279
safety than the current mainstream

00:33:10,720 --> 00:33:13,279
approaches

00:33:14,159 --> 00:33:17,279
so there is a little bit of a problem as

00:33:16,559 --> 00:33:19,360
stiletto

00:33:17,279 --> 00:33:20,480
in um points out in their article from

00:33:19,360 --> 00:33:22,000
00:33:20,480 --> 00:33:23,600
uh one of the current problems with

00:33:22,000 --> 00:33:25,200
systems engineering is that different

00:33:23,600 --> 00:33:26,720
stakeholders use the same

00:33:25,200 --> 00:33:28,559
word to mean different things and

00:33:26,720 --> 00:33:30,080
different words to mean the same thing

00:33:28,559 --> 00:33:31,679
and that's really what we can see by

00:33:30,080 --> 00:33:36,320
examining some of the uh

00:33:31,679 --> 00:33:37,919
the published frameworks on resiliency

00:33:36,320 --> 00:33:40,080
this slide just demonstrates all the

00:33:37,919 --> 00:33:41,200
different uh ways systems are defined

00:33:40,080 --> 00:33:43,360
i'm not going to go through these but

00:33:41,200 --> 00:33:45,440
this just really illustrates uh how

00:33:43,360 --> 00:33:46,559
complex these definitions and uses can

00:33:45,440 --> 00:33:48,640
get

00:33:46,559 --> 00:33:50,399
um so when we're looking at resilience

00:33:48,640 --> 00:33:52,159
frameworks i think i just have a couple

00:33:50,399 --> 00:33:55,279
minutes to zoom through these

00:33:52,159 --> 00:33:59,279
um we do uh we do see some

00:33:55,279 --> 00:34:00,399
interesting um uh pulling together of

00:33:59,279 --> 00:34:03,039
fault tolerance

00:34:00,399 --> 00:34:04,559
and this idea of resilience and sort of

00:34:03,039 --> 00:34:06,159
how they compare and contrast

00:34:04,559 --> 00:34:07,760
and how those principles of fault

00:34:06,159 --> 00:34:09,359
tolerance really do fit in to the

00:34:07,760 --> 00:34:12,480
principles of resilience

00:34:09,359 --> 00:34:14,399
so in the common agricultural policy uh

00:34:12,480 --> 00:34:15,919
framework we can see that they talk

00:34:14,399 --> 00:34:17,919
about robustness here

00:34:15,919 --> 00:34:19,200
and then they add transformability and

00:34:17,919 --> 00:34:21,119
adaptability

00:34:19,200 --> 00:34:23,760
to that framework and then they say

00:34:21,119 --> 00:34:26,639
resilience is more than robustness

00:34:23,760 --> 00:34:28,480
so for me i think that this idea of

00:34:26,639 --> 00:34:30,000
robustness that they're showing in this

00:34:28,480 --> 00:34:31,760
framework is sort of

00:34:30,000 --> 00:34:33,440
uh similar to the idea of fault

00:34:31,760 --> 00:34:35,040
tolerance or is portraying fault

00:34:33,440 --> 00:34:37,040
tolerance within this framework

00:34:35,040 --> 00:34:38,639
and then those ideas of transformability

00:34:37,040 --> 00:34:42,000
and adaptability or sort of

00:34:38,639 --> 00:34:44,480
conveying that idea of uh resilience

00:34:42,000 --> 00:34:45,119
within the framework so it's uh it's

00:34:44,480 --> 00:34:48,879
more than

00:34:45,119 --> 00:34:50,879
robustness um within the city resilience

00:34:48,879 --> 00:34:53,040
framework which is a very commonly used

00:34:50,879 --> 00:34:54,960
uh framework and was developed by arab

00:34:53,040 --> 00:34:56,320
with support from the rockefeller center

00:34:54,960 --> 00:34:58,480
in 2015

00:34:56,320 --> 00:35:00,079
uh we see a lot of similarities as well

00:34:58,480 --> 00:35:02,720
so for example we see

00:35:00,079 --> 00:35:04,800
um providing reliable communications and

00:35:02,720 --> 00:35:05,599
mobility so that's certainly key to

00:35:04,800 --> 00:35:07,440
fault tolerance

00:35:05,599 --> 00:35:08,960
we also see ensure continuity of

00:35:07,440 --> 00:35:10,800
critical services

00:35:08,960 --> 00:35:12,560
again very key default tolerance and we

00:35:10,800 --> 00:35:16,240
see these words ensure

00:35:12,560 --> 00:35:17,680
ensure um which i i would take to mean

00:35:16,240 --> 00:35:20,400
that these are sort of the sub

00:35:17,680 --> 00:35:20,800
parameters within this framework that

00:35:20,400 --> 00:35:22,560
are

00:35:20,800 --> 00:35:24,800
are essentially those fault tolerance

00:35:22,560 --> 00:35:27,200
aspects and are meeting those

00:35:24,800 --> 00:35:29,280
uh fault tolerance needs within the

00:35:27,200 --> 00:35:31,760
larger city resilience framework in this

00:35:29,280 --> 00:35:33,760
case

00:35:31,760 --> 00:35:35,520
uh and if we looked at the world health

00:35:33,760 --> 00:35:37,119
organization's conceptual framework for

00:35:35,520 --> 00:35:37,440
resilience we see something similar as

00:35:37,119 --> 00:35:39,440
well

00:35:37,440 --> 00:35:41,359
so we see this idea of decreased

00:35:39,440 --> 00:35:43,280
vulnerability which we could also

00:35:41,359 --> 00:35:45,440
think of as perhaps increased

00:35:43,280 --> 00:35:47,119
reliability and availability

00:35:45,440 --> 00:35:48,960
um and we also see this idea of

00:35:47,119 --> 00:35:51,119
recovering to pre-state

00:35:48,960 --> 00:35:52,400
uh pre-event states and recovering but

00:35:51,119 --> 00:35:54,000
worse than before

00:35:52,400 --> 00:35:55,599
which i think would really capture that

00:35:54,000 --> 00:35:56,480
idea of fault tolerance within the

00:35:55,599 --> 00:35:58,480
system

00:35:56,480 --> 00:36:00,000
and then these ideas of transform and

00:35:58,480 --> 00:36:02,720
recover better than before

00:36:00,000 --> 00:36:03,760
would capture those ideas of resilience

00:36:02,720 --> 00:36:05,520
all within

00:36:03,760 --> 00:36:07,200
the same sort of framework so we do see

00:36:05,520 --> 00:36:09,520
that these resilience frameworks

00:36:07,200 --> 00:36:11,359
are acknowledging the importance of

00:36:09,520 --> 00:36:13,520
fault tolerance

00:36:11,359 --> 00:36:15,119
and i won't go through this one but uh

00:36:13,520 --> 00:36:17,040
but we can see that again and we see a

00:36:15,119 --> 00:36:19,760
lot of similarities we see those words

00:36:17,040 --> 00:36:20,800
recovery redundancy robustness so again

00:36:19,760 --> 00:36:22,320
we're seeing those

00:36:20,800 --> 00:36:24,079
common features of fault tolerance

00:36:22,320 --> 00:36:26,560
within this resilience framework for

00:36:24,079 --> 00:36:28,240
urban climate resilience

00:36:26,560 --> 00:36:30,000
and this was a very interesting one

00:36:28,240 --> 00:36:31,680
because um within this conceptual

00:36:30,000 --> 00:36:33,760
framework for the resilience of

00:36:31,680 --> 00:36:36,320
systems um which was actually put

00:36:33,760 --> 00:36:38,000
together by the oecd

00:36:36,320 --> 00:36:39,920
we see all of these principles of

00:36:38,000 --> 00:36:41,520
resilience laid out here and in fact if

00:36:39,920 --> 00:36:42,400
we go through these principles all of

00:36:41,520 --> 00:36:44,480
these principles

00:36:42,400 --> 00:36:46,560
are common between the ideas of

00:36:44,480 --> 00:36:49,200
resilience and fault tolerance

00:36:46,560 --> 00:36:51,440
um so preparedness learning and

00:36:49,200 --> 00:36:53,599
innovation thresholds responsiveness

00:36:51,440 --> 00:36:55,440
diversity and redundancy connectivity

00:36:53,599 --> 00:36:56,240
self-organization inclusion social

00:36:55,440 --> 00:36:58,000
cohesion

00:36:56,240 --> 00:36:59,359
these in one way or another could also

00:36:58,000 --> 00:37:01,520
be um

00:36:59,359 --> 00:37:03,119
keys and and seen as principles of fault

00:37:01,520 --> 00:37:03,599
tolerance so it's very interesting to

00:37:03,119 --> 00:37:05,599
see

00:37:03,599 --> 00:37:06,880
essentially the the connectedness

00:37:05,599 --> 00:37:08,640
between these ideas of

00:37:06,880 --> 00:37:10,720
resilience and fault tolerance within

00:37:08,640 --> 00:37:12,800
these published frameworks

00:37:10,720 --> 00:37:14,079
so the key takeaways for today are that

00:37:12,800 --> 00:37:15,680
fault tolerant design enhances

00:37:14,079 --> 00:37:16,320
availability and reliability in all

00:37:15,680 --> 00:37:18,079
systems

00:37:16,320 --> 00:37:19,680
stakeholders often use different terms

00:37:18,079 --> 00:37:21,119
to discuss the same thing for example

00:37:19,680 --> 00:37:22,560
fault tolerance is used in defined in

00:37:21,119 --> 00:37:24,240
reputable computer science and

00:37:22,560 --> 00:37:26,160
engineering literature however

00:37:24,240 --> 00:37:27,280
other terms may be used to discuss or

00:37:26,160 --> 00:37:28,160
include fall tolerance in other

00:37:27,280 --> 00:37:29,920
disciplines

00:37:28,160 --> 00:37:31,680
software-based fault tolerance is key to

00:37:29,920 --> 00:37:33,599
fault tolerant computing systems which

00:37:31,680 --> 00:37:35,440
can affect many other systems

00:37:33,599 --> 00:37:37,440
postgres sql and hadoop are free and

00:37:35,440 --> 00:37:39,200
open source tools which could be used to

00:37:37,440 --> 00:37:40,560
enhance software-based fault tolerance

00:37:39,200 --> 00:37:42,240
in data management

00:37:40,560 --> 00:37:43,920
the inclusion of fault tolerant design

00:37:42,240 --> 00:37:45,200
principles and conceptual frameworks of

00:37:43,920 --> 00:37:46,640
resilient systems

00:37:45,200 --> 00:37:48,720
from multiple fields supports the

00:37:46,640 --> 00:37:50,720
recognized importance of fault tolerance

00:37:48,720 --> 00:37:52,320
across systems and sectors

00:37:50,720 --> 00:37:54,079
although resilience is a slightly

00:37:52,320 --> 00:37:54,880
different broader concept than fault

00:37:54,079 --> 00:37:56,400
tolerance

00:37:54,880 --> 00:37:58,960
fault tolerance is a key part of

00:37:56,400 --> 00:38:00,560
resilient systems postgres sql and

00:37:58,960 --> 00:38:03,119
hadoop can be used as part of a

00:38:00,560 --> 00:38:05,520
resilient system design

00:38:03,119 --> 00:38:08,320
special thanks go to dr wei chu chung

00:38:05,520 --> 00:38:10,720
who is a committer to apache hadoop hgfs

00:38:08,320 --> 00:38:11,440
and submarine um he gave a lot of input

00:38:10,720 --> 00:38:13,599
on the

00:38:11,440 --> 00:38:14,480
hadoop slides and the enhancements in

00:38:13,599 --> 00:38:16,400
the three

00:38:14,480 --> 00:38:18,320
point x releases so i really appreciate

00:38:16,400 --> 00:38:20,320
that as well as to jonathan katz

00:38:18,320 --> 00:38:22,320
who is a committer to the postgres sql

00:38:20,320 --> 00:38:23,520
project and gave me a lot of guidance on

00:38:22,320 --> 00:38:25,760
fault tolerance and postgres

00:38:23,520 --> 00:38:27,280
sql especially uh the new features in

00:38:25,760 --> 00:38:29,040
postgres sql13

00:38:27,280 --> 00:38:31,599
and nicola lovin who's an advocate of

00:38:29,040 --> 00:38:32,800
inkscape and open broadcaster software

00:38:31,599 --> 00:38:34,960
and who helped me design the

00:38:32,800 --> 00:38:47,839
introduction graphic

00:38:34,960 --> 00:38:47,839
thank you

00:40:15,119 --> 00:40:17,200

YouTube URL: https://www.youtube.com/watch?v=vd7APbYDzAY


