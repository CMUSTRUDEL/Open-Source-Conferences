Title: Extending Automation towards Self-Service CDNs
Publication date: 2020-10-15
Playlist: ApacheCon @Home 2020: Content Delivery
Description: 
	Extending Automation towards Self-Service CDNs
Jonathan Gray

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Apache Traffic Control is a set of applications designed to complement Apache Traffic Server to comprise a Content Delivery Network. Currently the creation of production-like CDN environments is a complex process. I will be demonstrating how Iâ€™ve been able to augment existing OSS Ansible automation to produce disposable test CDN environments.

Jonathan Gray has been with Comcast on the Content Delivery Network team for approaching 3 years focusing on Operations and Automation. Prior to that he's served as a software developer, integrator, and devops lead for Milsoft Utility Solutions for 7 years. He holds a Bachelor of Science Degree in Computer Science from Abilene Christian University where he also served as an IT Systems Administrator, Datacenter Administrator, and Virtualization Administrator for over 3 years.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,160 --> 00:00:28,800
started

00:00:26,240 --> 00:00:31,279
my name's jonathan gray i'm with the

00:00:28,800 --> 00:00:33,440
comcast content delivery network team

00:00:31,279 --> 00:00:35,200
i've been on the operations and

00:00:33,440 --> 00:00:37,280
automation side of the fence now for

00:00:35,200 --> 00:00:40,640
just over three years

00:00:37,280 --> 00:00:44,559
and uh looking at

00:00:40,640 --> 00:00:45,520
uh you know been in the industry itself

00:00:44,559 --> 00:00:48,079
and with a very

00:00:45,520 --> 00:00:49,039
varied uh experience of probably over

00:00:48,079 --> 00:00:50,559
10.

00:00:49,039 --> 00:00:53,039
but today i'm going to go over with you

00:00:50,559 --> 00:00:55,199
a bit about some things we've done

00:00:53,039 --> 00:00:57,039
not with necessarily within the apache

00:00:55,199 --> 00:00:59,280
traffic control project scope but

00:00:57,039 --> 00:01:02,160
outside of it as well

00:00:59,280 --> 00:01:04,400
so we'll talk a little bit about not

00:01:02,160 --> 00:01:06,640
just some of the open source components

00:01:04,400 --> 00:01:08,640
that we do leverage but also some of the

00:01:06,640 --> 00:01:09,760
closed source technology stack choices

00:01:08,640 --> 00:01:12,159
we've made

00:01:09,760 --> 00:01:13,600
now because those choices are ours and

00:01:12,159 --> 00:01:14,720
they're not going to necessarily be

00:01:13,600 --> 00:01:18,080
appropriate for

00:01:14,720 --> 00:01:18,880
all implementations um i'm not going to

00:01:18,080 --> 00:01:20,640
dive

00:01:18,880 --> 00:01:22,640
super deep into some of the code that i

00:01:20,640 --> 00:01:24,320
have today but i'm going to more

00:01:22,640 --> 00:01:24,640
importantly talk about the concepts and

00:01:24,320 --> 00:01:26,560
the

00:01:24,640 --> 00:01:29,759
reasons and the rationales as to why i

00:01:26,560 --> 00:01:29,759
chose things the way i did

00:01:30,240 --> 00:01:34,560
so hopefully you can take away from this

00:01:32,720 --> 00:01:37,360
something that

00:01:34,560 --> 00:01:38,320
inspires you to kind of think about how

00:01:37,360 --> 00:01:41,759
self-service

00:01:38,320 --> 00:01:44,159
for your environments might look um and

00:01:41,759 --> 00:01:44,960
uh being able to relate those things

00:01:44,159 --> 00:01:46,560
back to

00:01:44,960 --> 00:01:48,320
your technology choices and your

00:01:46,560 --> 00:01:50,960
implementations

00:01:48,320 --> 00:01:51,920
first off um let me start with with a

00:01:50,960 --> 00:01:54,960
with a

00:01:51,920 --> 00:01:56,079
forward that kind of in terms of

00:01:54,960 --> 00:01:58,320
infrastructure they're

00:01:56,079 --> 00:02:00,320
more or less two paths forward within

00:01:58,320 --> 00:02:02,240
the apache traffic control project one

00:02:00,320 --> 00:02:04,799
is our cd and the box effort

00:02:02,240 --> 00:02:06,560
whereas today i'll be focusing on our

00:02:04,799 --> 00:02:10,399
ansible-based lab deployments

00:02:06,560 --> 00:02:12,720
instead it very much is

00:02:10,399 --> 00:02:14,879
for cd in a box everything runs local

00:02:12,720 --> 00:02:17,680
very few dependencies

00:02:14,879 --> 00:02:18,560
everything's containerized very simple

00:02:17,680 --> 00:02:22,400
to get going

00:02:18,560 --> 00:02:24,400
quickly whereas on the ansible-based lab

00:02:22,400 --> 00:02:27,760
deployment side of the fence

00:02:24,400 --> 00:02:28,239
um it's only the pieces that are common

00:02:27,760 --> 00:02:31,120
to the

00:02:28,239 --> 00:02:32,959
to between implementations of the

00:02:31,120 --> 00:02:35,120
project and only the pieces that are in

00:02:32,959 --> 00:02:37,200
the scope of the project itself

00:02:35,120 --> 00:02:40,239
so there's going to be more work

00:02:37,200 --> 00:02:42,560
necessary to make it useful to you

00:02:40,239 --> 00:02:45,360
but the pieces that are there should be

00:02:42,560 --> 00:02:47,599
generally applicable

00:02:45,360 --> 00:02:49,280
for those of you who are joining us um

00:02:47,599 --> 00:02:52,080
this year that were not with us last

00:02:49,280 --> 00:02:55,519
year um this is almost an extension of

00:02:52,080 --> 00:02:56,480
a talk i gave last year and so if you're

00:02:55,519 --> 00:02:58,080
interested

00:02:56,480 --> 00:02:59,840
those links will take you to last year's

00:02:58,080 --> 00:03:01,040
presentation and slides you're welcome

00:02:59,840 --> 00:03:02,319
to review those at your leisure

00:03:01,040 --> 00:03:03,760
afterward

00:03:02,319 --> 00:03:05,440
but i'm going to go ahead and give you a

00:03:03,760 --> 00:03:06,080
quick recap for the most necessary

00:03:05,440 --> 00:03:08,400
pieces

00:03:06,080 --> 00:03:10,159
of of being able to kind of understand

00:03:08,400 --> 00:03:11,920
where we're at

00:03:10,159 --> 00:03:13,920
in my brain kind of the way i break

00:03:11,920 --> 00:03:16,480
things up in terms of deploying a full

00:03:13,920 --> 00:03:18,159
bore cdn from nothingness to functional

00:03:16,480 --> 00:03:19,840
functionality is i think of things in

00:03:18,159 --> 00:03:21,519
terms of three layers

00:03:19,840 --> 00:03:22,879
of provisioning layer that deals with

00:03:21,519 --> 00:03:25,120
getting

00:03:22,879 --> 00:03:26,239
a system off the ground from nothingness

00:03:25,120 --> 00:03:29,280
to more of a

00:03:26,239 --> 00:03:31,280
vanilla operating system state and then

00:03:29,280 --> 00:03:32,319
more of a steady state layer on top of

00:03:31,280 --> 00:03:35,120
that dealing with

00:03:32,319 --> 00:03:36,879
things that make it more general to your

00:03:35,120 --> 00:03:38,720
own implementations

00:03:36,879 --> 00:03:40,400
and then lastly the application layer

00:03:38,720 --> 00:03:41,680
which deals with each of the components

00:03:40,400 --> 00:03:45,360
of an atc

00:03:41,680 --> 00:03:48,879
or apache traffic control stack

00:03:45,360 --> 00:03:54,080
everything from databases to caches to

00:03:48,879 --> 00:03:54,080
um metrics everything um

00:03:54,879 --> 00:03:58,799
everybody's going to have their own

00:03:56,319 --> 00:04:00,080
choices of kind of how they go about

00:03:58,799 --> 00:04:04,080
that

00:04:00,080 --> 00:04:06,480
people are going to use different pieces

00:04:04,080 --> 00:04:07,519
that's going to lower their your costs

00:04:06,480 --> 00:04:09,599
in terms of

00:04:07,519 --> 00:04:11,920
getting off the ground by using things

00:04:09,599 --> 00:04:13,439
you're already familiar with

00:04:11,920 --> 00:04:15,200
let me start off a bit about

00:04:13,439 --> 00:04:18,320
provisioning start at the bottom

00:04:15,200 --> 00:04:19,680
um at comcast we do a lot of things with

00:04:18,320 --> 00:04:21,600
physical hosts

00:04:19,680 --> 00:04:23,120
when it comes to things that are

00:04:21,600 --> 00:04:26,880
performance sensitive

00:04:23,120 --> 00:04:29,040
so things like our traffic routers and

00:04:26,880 --> 00:04:31,040
caches for example we typically deploy

00:04:29,040 --> 00:04:33,520
onto bare metal hardware

00:04:31,040 --> 00:04:34,400
and things that are less performance

00:04:33,520 --> 00:04:36,880
intensive

00:04:34,400 --> 00:04:38,639
like traffic ops for example will

00:04:36,880 --> 00:04:40,960
leverage cloud resources

00:04:38,639 --> 00:04:43,040
for rapid deployments or for greater

00:04:40,960 --> 00:04:45,600
redundancy and reliability outside of

00:04:43,040 --> 00:04:47,199
our own maintenances

00:04:45,600 --> 00:04:48,800
if you've ever looked around inside a

00:04:47,199 --> 00:04:50,560
traffic portal before if you look under

00:04:48,800 --> 00:04:50,960
the tools menu there's this option

00:04:50,560 --> 00:04:52,560
that's

00:04:50,960 --> 00:04:54,240
been hiding there that you probably have

00:04:52,560 --> 00:04:54,720
looked at but not really messed with too

00:04:54,240 --> 00:04:57,600
much

00:04:54,720 --> 00:04:59,600
called isogen if you look at the

00:04:57,600 --> 00:05:00,080
documentation for apache traffic control

00:04:59,600 --> 00:05:03,280
there's

00:05:00,080 --> 00:05:06,880
um sort of an embracement of

00:05:03,280 --> 00:05:09,759
the kickstart methodology for building

00:05:06,880 --> 00:05:10,800
bootable images which is a fedora

00:05:09,759 --> 00:05:13,280
concept

00:05:10,800 --> 00:05:14,800
that extends all the way through rel and

00:05:13,280 --> 00:05:16,800
centos

00:05:14,800 --> 00:05:17,919
which also matches up with our standard

00:05:16,800 --> 00:05:22,000
rpm

00:05:17,919 --> 00:05:25,759
packaging formats for all the binaries

00:05:22,000 --> 00:05:29,039
if you use the isogen form

00:05:25,759 --> 00:05:30,000
and have the appropriate config files in

00:05:29,039 --> 00:05:33,759
place

00:05:30,000 --> 00:05:37,759
and have the kickstart

00:05:33,759 --> 00:05:39,759
template configs you want the ks.cfg for

00:05:37,759 --> 00:05:42,560
example

00:05:39,759 --> 00:05:43,759
doing um what you need it to do during

00:05:42,560 --> 00:05:48,000
the boot and install

00:05:43,759 --> 00:05:49,680
process these ks scripts files for disks

00:05:48,000 --> 00:05:52,320
network management password

00:05:49,680 --> 00:05:54,000
info for roots that information is

00:05:52,320 --> 00:05:54,880
actually generated by the form that

00:05:54,000 --> 00:05:58,240
you're filling out

00:05:54,880 --> 00:05:58,960
in traffic portal and then that iso is

00:05:58,240 --> 00:06:01,120
basically

00:05:58,960 --> 00:06:03,280
built on the fly and streamed back to

00:06:01,120 --> 00:06:05,600
you with all the network identity

00:06:03,280 --> 00:06:08,720
information for a particular host

00:06:05,600 --> 00:06:09,280
baked in this makes it very easy to just

00:06:08,720 --> 00:06:11,600
go in

00:06:09,280 --> 00:06:13,360
pop the you know virtual media

00:06:11,600 --> 00:06:16,800
attachment to that iso

00:06:13,360 --> 00:06:20,080
boot and you're done now

00:06:16,800 --> 00:06:21,759
in our case um we

00:06:20,080 --> 00:06:24,880
there's kind of some scaling issues with

00:06:21,759 --> 00:06:27,759
that um when you're doing you know 10 20

00:06:24,880 --> 00:06:29,600
100 hosts at a time having to make

00:06:27,759 --> 00:06:31,840
individual isos for each system

00:06:29,600 --> 00:06:34,400
is both time-consuming and error-prone

00:06:31,840 --> 00:06:37,520
it's very easy to accidentally

00:06:34,400 --> 00:06:39,039
attach the wrong iso to the wrong

00:06:37,520 --> 00:06:41,840
host and then you end up with ip

00:06:39,039 --> 00:06:44,400
information out of whack

00:06:41,840 --> 00:06:46,240
so the way we kind of did things is we

00:06:44,400 --> 00:06:48,080
stepped outside of the traffic control

00:06:46,240 --> 00:06:51,199
project itself

00:06:48,080 --> 00:06:53,360
and instead formulated more of a generic

00:06:51,199 --> 00:06:56,880
kickstart

00:06:53,360 --> 00:06:57,840
that addresses all systems without

00:06:56,880 --> 00:07:00,400
regard to its

00:06:57,840 --> 00:07:01,039
information and then one of my

00:07:00,400 --> 00:07:04,080
colleagues

00:07:01,039 --> 00:07:06,080
last year at this time in apachecon 2019

00:07:04,080 --> 00:07:06,720
gave a presentation on damon that he had

00:07:06,080 --> 00:07:09,680
created an

00:07:06,720 --> 00:07:12,080
open source called tc net config you

00:07:09,680 --> 00:07:15,199
heard in the last talk with sergey

00:07:12,080 --> 00:07:18,000
a little bit of alluded to this so

00:07:15,199 --> 00:07:19,199
um effectively what the daemon does is

00:07:18,000 --> 00:07:21,919
that um it just

00:07:19,199 --> 00:07:23,039
phones home to traffic ops and says who

00:07:21,919 --> 00:07:24,960
am i

00:07:23,039 --> 00:07:26,319
tell me what my ip info should be tell

00:07:24,960 --> 00:07:29,520
me what my host name should be

00:07:26,319 --> 00:07:32,720
and i'll go and apply that for you um

00:07:29,520 --> 00:07:35,520
so that way we have one iso that scales

00:07:32,720 --> 00:07:36,960
much greater than uh where we were

00:07:35,520 --> 00:07:38,639
before

00:07:36,960 --> 00:07:41,680
now the other downside to this is that

00:07:38,639 --> 00:07:42,800
it um does rely on ipv6 auto conf router

00:07:41,680 --> 00:07:46,560
advertisements

00:07:42,800 --> 00:07:48,639
um which is not typically turned on by

00:07:46,560 --> 00:07:51,120
default in a lot of cases but

00:07:48,639 --> 00:07:52,319
is supported it's not the same thing as

00:07:51,120 --> 00:07:55,120
dhcp

00:07:52,319 --> 00:07:57,520
but in the co in the scope of how ipv6

00:07:55,120 --> 00:07:59,759
works it's very similar

00:07:57,520 --> 00:08:01,280
now in my case i'm working on labs and

00:07:59,759 --> 00:08:02,240
lab environments i have the kind of

00:08:01,280 --> 00:08:05,520
unique problem

00:08:02,240 --> 00:08:07,039
that since traffic ops uses itself as

00:08:05,520 --> 00:08:09,680
its own system of record

00:08:07,039 --> 00:08:10,479
i have a chicken and egg problem of well

00:08:09,680 --> 00:08:12,319
i can't

00:08:10,479 --> 00:08:14,319
delegate to traffic ops to tell me what

00:08:12,319 --> 00:08:16,319
my network information is if traffic ops

00:08:14,319 --> 00:08:19,759
doesn't exist yet

00:08:16,319 --> 00:08:21,840
so um this is where i kind of got into

00:08:19,759 --> 00:08:25,199
the idea of thinking well

00:08:21,840 --> 00:08:27,280
maybe instead i can look at creating a

00:08:25,199 --> 00:08:29,680
third-party you know out-of-band system

00:08:27,280 --> 00:08:31,759
to just hold the information long enough

00:08:29,680 --> 00:08:34,000
to get those initial systems off the

00:08:31,759 --> 00:08:35,919
ground and transfer the system of record

00:08:34,000 --> 00:08:39,680
responsibility off

00:08:35,919 --> 00:08:43,039
um to traffic cops once it's ready

00:08:39,680 --> 00:08:44,159
um the isos that i made are very very

00:08:43,039 --> 00:08:47,360
similar

00:08:44,159 --> 00:08:49,760
to the ones we use for um

00:08:47,360 --> 00:08:51,600
the normal production deployments with

00:08:49,760 --> 00:08:53,279
the universal iso approach

00:08:51,600 --> 00:08:55,040
with the exception of instead of using

00:08:53,279 --> 00:08:57,120
the tc net config daemon

00:08:55,040 --> 00:08:59,760
i simply leverage ansible jinja 2

00:08:57,120 --> 00:09:01,279
templates to simply render

00:08:59,760 --> 00:09:03,519
ifconfig and if route files

00:09:01,279 --> 00:09:06,959
appropriately

00:09:03,519 --> 00:09:08,720
when it comes to physical deployments

00:09:06,959 --> 00:09:10,320
it basically there are lots and lots of

00:09:08,720 --> 00:09:11,120
tools to help you manage that but it

00:09:10,320 --> 00:09:13,680
fundamentally

00:09:11,120 --> 00:09:14,880
at some point boils down to almost two

00:09:13,680 --> 00:09:18,320
approaches

00:09:14,880 --> 00:09:23,279
um the most common by far

00:09:18,320 --> 00:09:24,800
is leveraging pxe which relies on dhcp

00:09:23,279 --> 00:09:27,360
and a couple of other technologies to

00:09:24,800 --> 00:09:29,519
effectively add boot time into bios

00:09:27,360 --> 00:09:30,480
tell it where to go look for an image to

00:09:29,519 --> 00:09:32,800
run

00:09:30,480 --> 00:09:34,399
now in our case you know if you're

00:09:32,800 --> 00:09:36,959
running in a small network

00:09:34,399 --> 00:09:37,839
you know you have total control over it

00:09:36,959 --> 00:09:40,320
that might be

00:09:37,839 --> 00:09:41,279
applicable to you it might be easier to

00:09:40,320 --> 00:09:43,040
work with

00:09:41,279 --> 00:09:45,200
now in our case because our network is

00:09:43,040 --> 00:09:48,240
excessive exceptionally large

00:09:45,200 --> 00:09:50,720
and complicated in a lot of ways um

00:09:48,240 --> 00:09:53,120
it's not as easy to ensure consistency

00:09:50,720 --> 00:09:56,480
on those configurations across the board

00:09:53,120 --> 00:09:59,839
so instead what we do here is

00:09:56,480 --> 00:10:03,600
um we leverage the uh ansible playbooks

00:09:59,839 --> 00:10:06,399
and modules that are either part of the

00:10:03,600 --> 00:10:07,360
core project or supplied by our hardware

00:10:06,399 --> 00:10:10,800
vendors

00:10:07,360 --> 00:10:14,160
to provide a rudimentary um

00:10:10,800 --> 00:10:16,880
step of mount remote iso image from

00:10:14,160 --> 00:10:19,200
share from file share somewhere set a

00:10:16,880 --> 00:10:21,920
one-time boot and go

00:10:19,200 --> 00:10:22,959
so it's not leveraging pxe to manage

00:10:21,920 --> 00:10:26,079
those deployments

00:10:22,959 --> 00:10:28,720
um it's out of band and um

00:10:26,079 --> 00:10:30,240
that way we don't have to necessarily

00:10:28,720 --> 00:10:33,040
coordinate as tightly with our

00:10:30,240 --> 00:10:36,320
networking infrastructure teams

00:10:33,040 --> 00:10:39,680
now when it comes to cloud there are

00:10:36,320 --> 00:10:41,920
lots of ways you can skin that cap but

00:10:39,680 --> 00:10:44,399
in our case we leverage hashicorp

00:10:41,920 --> 00:10:47,360
terraform as an abstraction layer

00:10:44,399 --> 00:10:48,880
for our cloud infrastructure so that um

00:10:47,360 --> 00:10:50,399
if today we're in aws

00:10:48,880 --> 00:10:52,720
and tomorrow we want to be in google

00:10:50,399 --> 00:10:53,600
cloud platform it's not a complete

00:10:52,720 --> 00:10:56,880
rehash

00:10:53,600 --> 00:10:58,560
of all the infrastructure and tooling

00:10:56,880 --> 00:11:00,320
now when it comes to dns we leverage the

00:10:58,560 --> 00:11:02,880
vinyl dns project

00:11:00,320 --> 00:11:03,680
as a api self-service wrapper around

00:11:02,880 --> 00:11:06,480
bind

00:11:03,680 --> 00:11:07,120
so that that way we can adjust our dns

00:11:06,480 --> 00:11:09,279
configs

00:11:07,120 --> 00:11:12,000
during deployment without having to work

00:11:09,279 --> 00:11:13,920
with our dns teams either

00:11:12,000 --> 00:11:16,000
for our compute stack um we use

00:11:13,920 --> 00:11:16,720
openstack resources managed by one of

00:11:16,000 --> 00:11:19,760
our

00:11:16,720 --> 00:11:21,040
internal teams and then when it comes to

00:11:19,760 --> 00:11:23,279
specialization

00:11:21,040 --> 00:11:25,519
we leverage cloud init to get those

00:11:23,279 --> 00:11:29,680
systems from their base template state

00:11:25,519 --> 00:11:33,920
into more of the generalized state

00:11:29,680 --> 00:11:37,519
going forward speaking of steady state

00:11:33,920 --> 00:11:39,440
we are a stateful system so we

00:11:37,519 --> 00:11:42,000
don't quite hold on to the concepts of

00:11:39,440 --> 00:11:44,720
immutable infrastructure so much

00:11:42,000 --> 00:11:44,720
but we do

00:11:45,040 --> 00:11:48,720
deploy our systems and keep them alive

00:11:46,800 --> 00:11:50,399
until such times they need to be

00:11:48,720 --> 00:11:51,839
reborn for whatever reason be it

00:11:50,399 --> 00:11:54,560
maintenance problems

00:11:51,839 --> 00:11:56,320
or regular routine upgrades so that

00:11:54,560 --> 00:11:58,160
steady state is doing the basic things

00:11:56,320 --> 00:11:59,839
like making sure young repositories go

00:11:58,160 --> 00:12:01,040
to the right places making sure user

00:11:59,839 --> 00:12:04,240
accounts are managed

00:12:01,040 --> 00:12:05,839
the right ways firewalls etc now when it

00:12:04,240 --> 00:12:08,639
comes to managing steady state

00:12:05,839 --> 00:12:10,240
um if you've used ansible before um the

00:12:08,639 --> 00:12:11,600
out of the box behavior that you're

00:12:10,240 --> 00:12:13,440
probably the most familiar with is the

00:12:11,600 --> 00:12:15,279
notion of having a control host this is

00:12:13,440 --> 00:12:16,480
probably like your laptop

00:12:15,279 --> 00:12:18,399
but it might be something more

00:12:16,480 --> 00:12:19,600
enterprisey like ansible tower for

00:12:18,399 --> 00:12:21,839
example

00:12:19,600 --> 00:12:23,440
and it's based on the premise that you

00:12:21,839 --> 00:12:25,839
define a pattern of hosts

00:12:23,440 --> 00:12:26,639
and it pushes those set of tasks to

00:12:25,839 --> 00:12:30,160
those hosts

00:12:26,639 --> 00:12:31,760
to perform which is fine

00:12:30,160 --> 00:12:33,440
that's one approach to doing it it's

00:12:31,760 --> 00:12:34,720
very successful in a lot of

00:12:33,440 --> 00:12:37,200
infrastructures

00:12:34,720 --> 00:12:38,480
in our case however we chose to go kind

00:12:37,200 --> 00:12:40,240
of the other way

00:12:38,480 --> 00:12:41,600
there's another binary in standard

00:12:40,240 --> 00:12:43,279
installations of ansible you'll find

00:12:41,600 --> 00:12:46,160
called ansible pull

00:12:43,279 --> 00:12:48,079
instead of pushing commands to target

00:12:46,160 --> 00:12:50,320
patterns of hosts

00:12:48,079 --> 00:12:51,279
instead ansible portal inverts the

00:12:50,320 --> 00:12:54,160
control flow

00:12:51,279 --> 00:12:55,279
instead saying periodically a cron job

00:12:54,160 --> 00:12:58,480
kicks off and says

00:12:55,279 --> 00:13:00,160
go fetch any latest get commits from

00:12:58,480 --> 00:13:01,760
some git repository you've got

00:13:00,160 --> 00:13:06,399
configured and apply

00:13:01,760 --> 00:13:08,959
anything that might need to be done

00:13:06,399 --> 00:13:10,800
each host has no concept of other hosts

00:13:08,959 --> 00:13:14,880
it's only itself

00:13:10,800 --> 00:13:18,000
and notably git in this case scales

00:13:14,880 --> 00:13:19,519
very well horizontally with load

00:13:18,000 --> 00:13:21,839
balancers with different

00:13:19,519 --> 00:13:25,680
patterns of moving mirrors around etc

00:13:21,839 --> 00:13:27,440
there are lots of ways to make git scale

00:13:25,680 --> 00:13:29,200
and notably also one of the other big

00:13:27,440 --> 00:13:31,279
benefits we had in this case was it

00:13:29,200 --> 00:13:34,399
allowed us to do things like

00:13:31,279 --> 00:13:36,880
move changes to our steady state through

00:13:34,399 --> 00:13:38,399
standard get workflow practices like git

00:13:36,880 --> 00:13:41,199
flow or github flow

00:13:38,399 --> 00:13:42,240
to be able to modify um infrastructure

00:13:41,199 --> 00:13:44,800
in rollout

00:13:42,240 --> 00:13:45,920
of you know small roll outs at a time so

00:13:44,800 --> 00:13:48,720
that that way

00:13:45,920 --> 00:13:49,360
we can ensure that changes that might go

00:13:48,720 --> 00:13:51,360
sideways

00:13:49,360 --> 00:13:54,079
only if apply to either lower

00:13:51,360 --> 00:13:57,839
environments or smaller blast radiuses

00:13:54,079 --> 00:14:02,079
of production itself until we're more

00:13:57,839 --> 00:14:04,320
certain of their success being assured

00:14:02,079 --> 00:14:06,160
back a little bit to the recap from last

00:14:04,320 --> 00:14:08,480
year um

00:14:06,160 --> 00:14:09,279
thinking a little bit more about those

00:14:08,480 --> 00:14:12,320
three layers

00:14:09,279 --> 00:14:13,360
of the stack and it's not just enough to

00:14:12,320 --> 00:14:16,720
think of it so much

00:14:13,360 --> 00:14:18,560
in in those purely delineated sections

00:14:16,720 --> 00:14:20,720
there are also contracts that need to be

00:14:18,560 --> 00:14:23,680
observed between those layers

00:14:20,720 --> 00:14:25,040
so for example the provision layer is

00:14:23,680 --> 00:14:26,720
one of the most

00:14:25,040 --> 00:14:28,160
easy to think about in this case because

00:14:26,720 --> 00:14:28,839
the provisioning layer needs to be able

00:14:28,160 --> 00:14:31,440
to provide

00:14:28,839 --> 00:14:32,000
information to later on during the

00:14:31,440 --> 00:14:35,120
process

00:14:32,000 --> 00:14:37,440
as to what hosts are in scope so

00:14:35,120 --> 00:14:38,720
if you're doing things like saying give

00:14:37,440 --> 00:14:41,279
me three caches

00:14:38,720 --> 00:14:42,480
for example in a cloud infrastructure

00:14:41,279 --> 00:14:45,760
mixed with

00:14:42,480 --> 00:14:48,000
physical hosts and for traffic ops and

00:14:45,760 --> 00:14:49,199
traffic ops tv for example

00:14:48,000 --> 00:14:51,120
and all the other components of the

00:14:49,199 --> 00:14:53,360
stack

00:14:51,120 --> 00:14:55,360
something has to assemble an ansible

00:14:53,360 --> 00:14:58,480
compliant inventory

00:14:55,360 --> 00:14:59,440
that can be passed further along down

00:14:58,480 --> 00:15:01,199
the line

00:14:59,440 --> 00:15:03,680
so that as the steady state and

00:15:01,199 --> 00:15:05,519
application layers go to do their thing

00:15:03,680 --> 00:15:07,760
they know what they're specifically

00:15:05,519 --> 00:15:09,600
targeting um

00:15:07,760 --> 00:15:10,800
if you've got an out-of-band management

00:15:09,600 --> 00:15:13,440
kind of thing like i do

00:15:10,800 --> 00:15:15,360
for a physical infrastructure that makes

00:15:13,440 --> 00:15:17,040
the physical side a little bit easier to

00:15:15,360 --> 00:15:19,040
pre-compute up front

00:15:17,040 --> 00:15:21,040
but in terms of cloud resources you may

00:15:19,040 --> 00:15:21,760
not you may not know what the ips or

00:15:21,040 --> 00:15:24,000
host names

00:15:21,760 --> 00:15:25,920
are until after they're created so

00:15:24,000 --> 00:15:26,880
there's a feedback loop and a contract

00:15:25,920 --> 00:15:30,000
that has to exist

00:15:26,880 --> 00:15:31,199
there and it also might serve as some

00:15:30,000 --> 00:15:33,120
form of sentinel value

00:15:31,199 --> 00:15:34,399
say hey the seti state layer is done

00:15:33,120 --> 00:15:36,720
it's ready to move on

00:15:34,399 --> 00:15:39,120
let's go specialize some applications

00:15:36,720 --> 00:15:40,880
and get those running

00:15:39,120 --> 00:15:42,480
when it comes to each one of those

00:15:40,880 --> 00:15:45,360
application component

00:15:42,480 --> 00:15:46,480
layer um pieces uh the way i think about

00:15:45,360 --> 00:15:48,320
it is

00:15:46,480 --> 00:15:49,600
they all follow more or less a standard

00:15:48,320 --> 00:15:52,000
template of

00:15:49,600 --> 00:15:52,800
go load some variable data that's

00:15:52,000 --> 00:15:56,320
important

00:15:52,800 --> 00:15:57,839
um for this deployment and specifically

00:15:56,320 --> 00:16:00,959
this environment

00:15:57,839 --> 00:16:03,680
then wrap a implementation

00:16:00,959 --> 00:16:04,800
specific driver playbook around a

00:16:03,680 --> 00:16:07,920
generic core

00:16:04,800 --> 00:16:09,440
ansible role that implementation

00:16:07,920 --> 00:16:10,959
specific driver could be

00:16:09,440 --> 00:16:12,560
things that are you know important to

00:16:10,959 --> 00:16:15,440
you and your implementations like you

00:16:12,560 --> 00:16:19,680
know your monitoring systems or

00:16:15,440 --> 00:16:21,600
your metrics or um being able to tie in

00:16:19,680 --> 00:16:22,800
other system of record etc and your

00:16:21,600 --> 00:16:25,360
workflows

00:16:22,800 --> 00:16:26,720
um the generic core on the other hand is

00:16:25,360 --> 00:16:30,480
the open source

00:16:26,720 --> 00:16:32,320
um role that is in the traffic control

00:16:30,480 --> 00:16:35,360
repository today

00:16:32,320 --> 00:16:35,839
in the infrastructure um repository in

00:16:35,360 --> 00:16:37,600
the

00:16:35,839 --> 00:16:40,880
infrastructure folder of the traffic

00:16:37,600 --> 00:16:43,839
control repository

00:16:40,880 --> 00:16:45,199
now how do you get those roles into

00:16:43,839 --> 00:16:47,920
something that's usable

00:16:45,199 --> 00:16:49,440
you know when at runtime um there are

00:16:47,920 --> 00:16:50,320
lots of ways to handle versioning of

00:16:49,440 --> 00:16:52,399
rolls

00:16:50,320 --> 00:16:55,360
ansible galaxy is one of the most common

00:16:52,399 --> 00:16:57,680
ones but i chose to use a tool called

00:16:55,360 --> 00:16:59,440
guilt or get layering technology it's

00:16:57,680 --> 00:17:02,560
available on pi pi

00:16:59,440 --> 00:17:03,600
or pip it's very simple to to use it's

00:17:02,560 --> 00:17:06,880
basically just a

00:17:03,600 --> 00:17:09,120
yaml config file that defines a set of

00:17:06,880 --> 00:17:10,799
repositories a set of references

00:17:09,120 --> 00:17:14,480
inside of the repositories be it

00:17:10,799 --> 00:17:17,199
branches commits tags etc

00:17:14,480 --> 00:17:19,039
and then files of you know source and

00:17:17,199 --> 00:17:20,480
destination and the repository to your

00:17:19,039 --> 00:17:20,959
working directory where you want things

00:17:20,480 --> 00:17:22,720
to go

00:17:20,959 --> 00:17:26,559
so effectively it's just a really fancy

00:17:22,720 --> 00:17:28,559
wrapper around get clone and copy

00:17:26,559 --> 00:17:29,760
kind of the last important concept to

00:17:28,559 --> 00:17:31,760
think about

00:17:29,760 --> 00:17:32,880
from from before is the notion of

00:17:31,760 --> 00:17:35,280
variable precedence

00:17:32,880 --> 00:17:36,240
um inansible when you're interpolating

00:17:35,280 --> 00:17:39,440
variables there's

00:17:36,240 --> 00:17:41,760
lots of places that can come from there

00:17:39,440 --> 00:17:43,679
in fact there are 21 of them here on the

00:17:41,760 --> 00:17:45,760
far end you have the role defaults

00:17:43,679 --> 00:17:47,440
which are in the open source for example

00:17:45,760 --> 00:17:49,760
being at the lowest

00:17:47,440 --> 00:17:51,760
uh precedence level overridden by

00:17:49,760 --> 00:17:53,440
anything from anywhere

00:17:51,760 --> 00:17:55,120
all the way up to the most important

00:17:53,440 --> 00:17:57,679
things which are things passed in on the

00:17:55,120 --> 00:18:00,480
command line at runtime

00:17:57,679 --> 00:18:02,160
now at this point i didn't originally

00:18:00,480 --> 00:18:04,960
consider it this way

00:18:02,160 --> 00:18:06,559
but it occurred to me that because both

00:18:04,960 --> 00:18:09,679
ansible and terraform

00:18:06,559 --> 00:18:11,840
support supplying json based variable

00:18:09,679 --> 00:18:14,000
files on the command line

00:18:11,840 --> 00:18:16,480
i could take the process and the

00:18:14,000 --> 00:18:17,440
workflows for deploying environments to

00:18:16,480 --> 00:18:20,720
be

00:18:17,440 --> 00:18:22,720
more abstract more uh generalized

00:18:20,720 --> 00:18:24,320
and so this is when i got kind of the

00:18:22,720 --> 00:18:25,840
light bulb moment of

00:18:24,320 --> 00:18:27,520
you know what maybe i can be a little

00:18:25,840 --> 00:18:29,440
bit more ambitious here

00:18:27,520 --> 00:18:32,240
and think about things in terms of

00:18:29,440 --> 00:18:34,320
self-service as opposed to

00:18:32,240 --> 00:18:35,679
having to custom roll every one of these

00:18:34,320 --> 00:18:39,520
things each time

00:18:35,679 --> 00:18:42,480
even if it's only the small pieces

00:18:39,520 --> 00:18:43,280
for the things around the generic cores

00:18:42,480 --> 00:18:46,400
that are different

00:18:43,280 --> 00:18:46,880
or nuanced but it allows me to be able

00:18:46,400 --> 00:18:48,480
to

00:18:46,880 --> 00:18:50,480
take all the pieces that make each

00:18:48,480 --> 00:18:53,760
individual environment special

00:18:50,480 --> 00:18:55,679
and instead bring them into that

00:18:53,760 --> 00:18:59,039
external system of record

00:18:55,679 --> 00:19:01,360
which in my case i call the lab manager

00:18:59,039 --> 00:19:03,120
the lab manager is a you know internal

00:19:01,360 --> 00:19:04,880
application for us because again it

00:19:03,120 --> 00:19:06,720
wouldn't make a whole lot of sense to

00:19:04,880 --> 00:19:08,320
to really kind of dig into the details

00:19:06,720 --> 00:19:09,919
of it so much but

00:19:08,320 --> 00:19:11,280
the important things here were that it

00:19:09,919 --> 00:19:13,120
resolved the chicken and egg problem

00:19:11,280 --> 00:19:14,480
with traffic ops it was a reliable

00:19:13,120 --> 00:19:16,720
system of record

00:19:14,480 --> 00:19:17,840
with which focused on data relationships

00:19:16,720 --> 00:19:21,120
integrity and more

00:19:17,840 --> 00:19:22,400
importantly was simple um i'll go over

00:19:21,120 --> 00:19:23,679
some of the concepts that are modeled

00:19:22,400 --> 00:19:25,760
inside of it so that

00:19:23,679 --> 00:19:27,760
you kind of have an idea as to how deep

00:19:25,760 --> 00:19:30,960
some of that rabbit hole goes

00:19:27,760 --> 00:19:31,440
and what my scope was but first of all

00:19:30,960 --> 00:19:33,280
you know

00:19:31,440 --> 00:19:34,480
technology choices wise you know when i

00:19:33,280 --> 00:19:37,520
went to go build it

00:19:34,480 --> 00:19:38,320
i wanted to pick up graphql uh it's an

00:19:37,520 --> 00:19:41,280
up-and-coming

00:19:38,320 --> 00:19:42,720
alternative to rest that solves several

00:19:41,280 --> 00:19:44,480
of the problems that one of my

00:19:42,720 --> 00:19:46,160
colleagues today earlier mentioned about

00:19:44,480 --> 00:19:47,120
rest with things like the n plus one

00:19:46,160 --> 00:19:50,400
problem

00:19:47,120 --> 00:19:53,520
um when it comes to rest or primary keys

00:19:50,400 --> 00:19:54,720
um and so graphql is originally

00:19:53,520 --> 00:19:57,760
developed by facebook

00:19:54,720 --> 00:19:59,520
and graduated into its own foundation

00:19:57,760 --> 00:20:01,280
um where there are now several

00:19:59,520 --> 00:20:03,679
implementations

00:20:01,280 --> 00:20:06,080
on the other end um i wanted a

00:20:03,679 --> 00:20:08,559
relational database on the back end

00:20:06,080 --> 00:20:10,559
and the 800 pound gorilla in the room at

00:20:08,559 --> 00:20:13,039
that point is postgres

00:20:10,559 --> 00:20:13,679
and more importantly the traffic control

00:20:13,039 --> 00:20:16,080
project

00:20:13,679 --> 00:20:18,000
already leverages postgres as it is so

00:20:16,080 --> 00:20:20,159
the skill sets and tools needed to

00:20:18,000 --> 00:20:21,200
work with it understand it manipulate it

00:20:20,159 --> 00:20:22,960
develop it

00:20:21,200 --> 00:20:25,200
we're already there and present on our

00:20:22,960 --> 00:20:28,240
team myself included

00:20:25,200 --> 00:20:30,559
now to kind of stitch together

00:20:28,240 --> 00:20:32,159
both ends of that spectrum um from

00:20:30,559 --> 00:20:34,400
protocol to back end

00:20:32,159 --> 00:20:35,840
i leveraged an open source library

00:20:34,400 --> 00:20:37,600
called postgrefile

00:20:35,840 --> 00:20:39,200
um it's been around for a little while

00:20:37,600 --> 00:20:41,679
now it's open source

00:20:39,200 --> 00:20:42,559
um you can use it as a library or

00:20:41,679 --> 00:20:44,480
standalone

00:20:42,559 --> 00:20:46,960
but it's a more importantly effectively

00:20:44,480 --> 00:20:49,200
a no code to low code solution

00:20:46,960 --> 00:20:50,320
when it comes to getting functional apis

00:20:49,200 --> 00:20:54,320
off the ground

00:20:50,320 --> 00:20:56,080
for basically nothing um

00:20:54,320 --> 00:20:57,120
i went ahead and made it into a library

00:20:56,080 --> 00:20:58,880
so that i could add a few other

00:20:57,120 --> 00:21:00,799
libraries to it to make it

00:20:58,880 --> 00:21:02,640
handle a couple of use cases i had that

00:21:00,799 --> 00:21:04,320
were different and to make it just

00:21:02,640 --> 00:21:06,080
a bit more user-friendly getting off the

00:21:04,320 --> 00:21:08,080
ground

00:21:06,080 --> 00:21:09,840
a little bit more details about how that

00:21:08,080 --> 00:21:11,520
particular library works

00:21:09,840 --> 00:21:13,520
um and how it ties into the bigger

00:21:11,520 --> 00:21:15,120
picture what i was trying to accomplish

00:21:13,520 --> 00:21:18,400
um the most important thing here was

00:21:15,120 --> 00:21:21,039
security being able to make sure that

00:21:18,400 --> 00:21:21,919
the api was secure from the get-go to

00:21:21,039 --> 00:21:23,679
make sure that

00:21:21,919 --> 00:21:25,280
the data was protected and that it was

00:21:23,679 --> 00:21:26,480
more importantly not a hassle to have to

00:21:25,280 --> 00:21:29,120
deal with

00:21:26,480 --> 00:21:30,240
so i leverage an oauth2 provider to get

00:21:29,120 --> 00:21:33,840
a valid jwt

00:21:30,240 --> 00:21:36,640
back which is then in turn validated and

00:21:33,840 --> 00:21:37,679
passed along through postgrefile all the

00:21:36,640 --> 00:21:40,880
way down

00:21:37,679 --> 00:21:43,919
into postgres itself

00:21:40,880 --> 00:21:45,520
and once it's in postgres itself you can

00:21:43,919 --> 00:21:47,120
leverage the native postgres

00:21:45,520 --> 00:21:48,559
permission schemes that are available

00:21:47,120 --> 00:21:51,600
inside the database as

00:21:48,559 --> 00:21:54,799
is so you can do things like row

00:21:51,600 --> 00:21:57,600
row column or table permissions and

00:21:54,799 --> 00:21:58,000
because the jwt data is exposed inside

00:21:57,600 --> 00:22:00,960
of the

00:21:58,000 --> 00:22:01,760
databases variable in the context of the

00:22:00,960 --> 00:22:03,600
query

00:22:01,760 --> 00:22:05,200
you can also do check constraints to

00:22:03,600 --> 00:22:07,840
ensure things like

00:22:05,200 --> 00:22:09,039
applying ownership or change tracking to

00:22:07,840 --> 00:22:11,280
user ids

00:22:09,039 --> 00:22:13,360
notably this also allows me to leverage

00:22:11,280 --> 00:22:17,440
things like the concept of a role

00:22:13,360 --> 00:22:20,480
in inside the jwt or claims or

00:22:17,440 --> 00:22:23,280
uh permissions or capabilities

00:22:20,480 --> 00:22:24,720
otherwise conceptually to be able to

00:22:23,280 --> 00:22:28,559
control what people see

00:22:24,720 --> 00:22:31,919
can and do with said api

00:22:28,559 --> 00:22:35,440
so as a side benefit there

00:22:31,919 --> 00:22:37,120
because i don't have to the the username

00:22:35,440 --> 00:22:38,960
for example is simply a piece of

00:22:37,120 --> 00:22:41,039
ancillary data

00:22:38,960 --> 00:22:44,000
so i don't actually need to in postgres

00:22:41,039 --> 00:22:46,720
define individual users as a concept

00:22:44,000 --> 00:22:47,760
i can only i can for example use the

00:22:46,720 --> 00:22:50,400
role

00:22:47,760 --> 00:22:51,200
in the postgres sense being a collection

00:22:50,400 --> 00:22:54,960
of users

00:22:51,200 --> 00:22:57,039
with a set of permissions instead

00:22:54,960 --> 00:22:58,080
business logic wise out of the box you

00:22:57,039 --> 00:23:01,039
get crud

00:22:58,080 --> 00:23:03,280
um create read update destroy you get

00:23:01,039 --> 00:23:04,799
specific functions for every table out

00:23:03,280 --> 00:23:06,640
of the box

00:23:04,799 --> 00:23:08,000
that you have and that includes if you

00:23:06,640 --> 00:23:10,080
do all the proper data modeling and

00:23:08,000 --> 00:23:12,559
documentation inside the database

00:23:10,080 --> 00:23:14,080
it's propagated upward into the graphql

00:23:12,559 --> 00:23:15,840
schema as well

00:23:14,080 --> 00:23:18,159
now this is an example of a mutation

00:23:15,840 --> 00:23:20,320
doing a creative on a division object

00:23:18,159 --> 00:23:22,320
which is one of the most basic concepts

00:23:20,320 --> 00:23:23,760
in the traffic control data model which

00:23:22,320 --> 00:23:26,080
is simply just a string

00:23:23,760 --> 00:23:27,360
which has a one-to-many relationship or

00:23:26,080 --> 00:23:28,480
actually really zero-to-many

00:23:27,360 --> 00:23:30,480
relationship

00:23:28,480 --> 00:23:31,520
with regions which is again just another

00:23:30,480 --> 00:23:34,240
string

00:23:31,520 --> 00:23:34,640
now in this case this is one operation

00:23:34,240 --> 00:23:36,640
to

00:23:34,640 --> 00:23:38,720
simply ensure that the division record

00:23:36,640 --> 00:23:42,320
exists

00:23:38,720 --> 00:23:45,520
postprofile also does read

00:23:42,320 --> 00:23:47,600
at run time anything that um

00:23:45,520 --> 00:23:48,880
is a postgrass function or stored

00:23:47,600 --> 00:23:52,080
procedure and then

00:23:48,880 --> 00:23:54,480
interprets those immediately into new

00:23:52,080 --> 00:23:56,960
mutation functions or query functions

00:23:54,480 --> 00:23:57,840
which also extends to views as well be

00:23:56,960 --> 00:24:00,000
it

00:23:57,840 --> 00:24:01,200
materialized or not so that you can

00:24:00,000 --> 00:24:03,440
implement your own custom

00:24:01,200 --> 00:24:05,279
business logic as well so you can define

00:24:03,440 --> 00:24:06,320
a function that takes certain parameters

00:24:05,279 --> 00:24:08,480
and does

00:24:06,320 --> 00:24:10,400
as many things as you like so in this

00:24:08,480 --> 00:24:11,600
case i'm not only passing in the name of

00:24:10,400 --> 00:24:13,679
the division but also

00:24:11,600 --> 00:24:16,640
regions i want associated to it in a

00:24:13,679 --> 00:24:16,640
single transaction

00:24:16,799 --> 00:24:19,440
if you're interested in learning a

00:24:17,840 --> 00:24:21,440
little bit more about that um there's

00:24:19,440 --> 00:24:23,039
actually an experimental setup

00:24:21,440 --> 00:24:25,039
already committed to the traffic control

00:24:23,039 --> 00:24:26,640
repository in our experimental stuff

00:24:25,039 --> 00:24:30,159
that's enough to kind of get you a basic

00:24:26,640 --> 00:24:30,159
environment up and off the ground

00:24:30,320 --> 00:24:33,360
uh moving on to kind of the data

00:24:32,000 --> 00:24:36,400
concepts of the data

00:24:33,360 --> 00:24:38,559
of the lab manager uh the environment is

00:24:36,400 --> 00:24:41,120
probably the most fundamental and key

00:24:38,559 --> 00:24:42,880
piece of information right um there's

00:24:41,120 --> 00:24:45,440
basic metadata

00:24:42,880 --> 00:24:47,279
that you want to hold on to but if

00:24:45,440 --> 00:24:50,480
you've ever really tried to build

00:24:47,279 --> 00:24:52,640
an apache traffic control cdn before you

00:24:50,480 --> 00:24:53,840
already know there's 10 gajillion knobs

00:24:52,640 --> 00:24:58,159
in the system

00:24:53,840 --> 00:24:58,159
that can be tuned all manner of ways

00:24:58,840 --> 00:25:04,400
so one of the things that i did here was

00:25:02,320 --> 00:25:06,799
instead of trying to create a hard

00:25:04,400 --> 00:25:08,799
schema of here is the totality of all

00:25:06,799 --> 00:25:11,440
options present in the system

00:25:08,799 --> 00:25:12,960
i instead simply leverage a json column

00:25:11,440 --> 00:25:14,799
of the database which is then presented

00:25:12,960 --> 00:25:16,880
all the way through as raw unstructured

00:25:14,799 --> 00:25:19,440
json in graphql

00:25:16,880 --> 00:25:22,000
to be able to model all the various and

00:25:19,440 --> 00:25:24,559
sundry configuration items

00:25:22,000 --> 00:25:26,000
without having to necessarily enumerate

00:25:24,559 --> 00:25:27,520
them because simply if i tried to

00:25:26,000 --> 00:25:29,679
enumerate them it'd be out of date by

00:25:27,520 --> 00:25:32,240
the time i got finished

00:25:29,679 --> 00:25:33,360
um there's a little bit of a loose

00:25:32,240 --> 00:25:35,039
schema that i did

00:25:33,360 --> 00:25:37,679
apply and i'll come back to why i did

00:25:35,039 --> 00:25:40,720
that closer to the end

00:25:37,679 --> 00:25:41,120
but effectively it's unstructured but

00:25:40,720 --> 00:25:43,360
there

00:25:41,120 --> 00:25:44,880
is a loose structure at the very root of

00:25:43,360 --> 00:25:48,000
the dictionary

00:25:44,880 --> 00:25:50,080
the guilt config also is a considered a

00:25:48,000 --> 00:25:52,480
field of the environment itself

00:25:50,080 --> 00:25:54,400
you saw earlier that it's a yaml file

00:25:52,480 --> 00:25:56,640
well postgres doesn't have

00:25:54,400 --> 00:25:58,159
yaml as a concept built in but it does

00:25:56,640 --> 00:26:01,919
json again

00:25:58,159 --> 00:26:04,960
so ansible has a very easy easy easy

00:26:01,919 --> 00:26:09,039
conversion process of json down to

00:26:04,960 --> 00:26:12,159
yaml so um effectively i just

00:26:09,039 --> 00:26:15,039
jam that guilt config

00:26:12,159 --> 00:26:15,360
in to the definition of the environment

00:26:15,039 --> 00:26:17,919
as

00:26:15,360 --> 00:26:19,520
json which then gets rendered at runtime

00:26:17,919 --> 00:26:21,360
down to the yaml file that's being

00:26:19,520 --> 00:26:23,120
expected

00:26:21,360 --> 00:26:24,400
this allows each environment to be able

00:26:23,120 --> 00:26:26,159
to find

00:26:24,400 --> 00:26:28,080
different points from whence its code

00:26:26,159 --> 00:26:30,400
comes so if for example

00:26:28,080 --> 00:26:31,120
i want to grab the latest and greatest

00:26:30,400 --> 00:26:33,440
versions

00:26:31,120 --> 00:26:35,039
of the code available i can grab it off

00:26:33,440 --> 00:26:36,960
the head of master

00:26:35,039 --> 00:26:38,559
if i'm doing some scary development work

00:26:36,960 --> 00:26:40,720
on one particular area

00:26:38,559 --> 00:26:42,320
i can grab one of the generic cores or a

00:26:40,720 --> 00:26:44,159
piece of my

00:26:42,320 --> 00:26:46,159
code from somewhere else in a totally

00:26:44,159 --> 00:26:47,919
different repository be it internal or

00:26:46,159 --> 00:26:51,440
external

00:26:47,919 --> 00:26:52,960
and weave that in at runtime the next

00:26:51,440 --> 00:26:55,360
concept which is probably the most

00:26:52,960 --> 00:26:57,279
variati is the notion of a resource pool

00:26:55,360 --> 00:26:58,880
whether it's physical or virtual

00:26:57,279 --> 00:27:00,320
in the case of virtual it's probably

00:26:58,880 --> 00:27:02,240
looks a little bit like an asset

00:27:00,320 --> 00:27:03,200
management system sort of thing but not

00:27:02,240 --> 00:27:06,480
really

00:27:03,200 --> 00:27:08,559
um and then on the cloud side of things

00:27:06,480 --> 00:27:09,760
you're basically doing a tr a quota

00:27:08,559 --> 00:27:11,600
around your tracking

00:27:09,760 --> 00:27:13,120
of your quotas and whatever your cloud

00:27:11,600 --> 00:27:14,559
resources are

00:27:13,120 --> 00:27:16,000
um when it comes to physical

00:27:14,559 --> 00:27:17,200
infrastructure you do have to provide

00:27:16,000 --> 00:27:19,120
some other

00:27:17,200 --> 00:27:20,640
um ancillary data when it comes to

00:27:19,120 --> 00:27:23,520
actually associating

00:27:20,640 --> 00:27:24,080
those physical assets with the cdn

00:27:23,520 --> 00:27:25,760
namely

00:27:24,080 --> 00:27:27,279
which environment do you want to tag

00:27:25,760 --> 00:27:28,960
those resources to

00:27:27,279 --> 00:27:30,559
what thing is it going to be at the end

00:27:28,960 --> 00:27:32,640
of the day whether it's a cache or

00:27:30,559 --> 00:27:34,640
whether it's a database whether it's an

00:27:32,640 --> 00:27:38,480
api server etc

00:27:34,640 --> 00:27:40,880
and then what cdn does it belong to

00:27:38,480 --> 00:27:43,760
since a given apache traffic control

00:27:40,880 --> 00:27:46,159
instance can have multiple cdns

00:27:43,760 --> 00:27:47,600
represented if you're building a cache

00:27:46,159 --> 00:27:50,799
you need to be able to specify

00:27:47,600 --> 00:27:54,080
to which cdn that belongs

00:27:50,799 --> 00:27:55,760
next concept here is a job so i didn't

00:27:54,080 --> 00:27:58,080
want the lab manager to just be a

00:27:55,760 --> 00:28:00,480
you know read write crud database i want

00:27:58,080 --> 00:28:03,440
to be more of a life cycle tool

00:28:00,480 --> 00:28:05,919
for an environment so um the notion of a

00:28:03,440 --> 00:28:07,360
job was effectively something i want a

00:28:05,919 --> 00:28:10,640
back-end process to do

00:28:07,360 --> 00:28:13,760
for me so doing things like saying

00:28:10,640 --> 00:28:16,799
let me file a job query that does

00:28:13,760 --> 00:28:18,720
things like um

00:28:16,799 --> 00:28:20,640
you know build an environment from

00:28:18,720 --> 00:28:22,240
scratch or destroy it back to nothing

00:28:20,640 --> 00:28:24,559
and release the resources

00:28:22,240 --> 00:28:26,000
or expand it or upgrade it those

00:28:24,559 --> 00:28:27,760
operations are nebulous and can be

00:28:26,000 --> 00:28:28,720
defined esoterically as you just as you

00:28:27,760 --> 00:28:31,200
see fit

00:28:28,720 --> 00:28:33,279
but the notion of a job to being able to

00:28:31,200 --> 00:28:35,760
define the life cycle events

00:28:33,279 --> 00:28:37,039
of an environment the next big one here

00:28:35,760 --> 00:28:38,480
was logs

00:28:37,039 --> 00:28:42,640
there are many many ways to slice and

00:28:38,480 --> 00:28:45,039
dice that into different ways

00:28:42,640 --> 00:28:45,840
a little bit of implementation detail

00:28:45,039 --> 00:28:47,600
here

00:28:45,840 --> 00:28:49,039
uh when it comes to actually running the

00:28:47,600 --> 00:28:52,159
playbooks themselves

00:28:49,039 --> 00:28:55,120
i leveraged the junit um output

00:28:52,159 --> 00:28:56,799
callback plugin to be able to export all

00:28:55,120 --> 00:28:59,120
the log data as a flat

00:28:56,799 --> 00:29:00,799
file in xml format conforming to the

00:28:59,120 --> 00:29:05,039
junit format

00:29:00,799 --> 00:29:07,600
which is then picked up and processed

00:29:05,039 --> 00:29:09,440
actually within postgres itself because

00:29:07,600 --> 00:29:13,840
postgres supports

00:29:09,440 --> 00:29:18,240
native operations on xml as well as json

00:29:13,840 --> 00:29:20,960
so that way i can break apart and re

00:29:18,240 --> 00:29:24,559
reconfigure the data as i see fit to

00:29:20,960 --> 00:29:24,559
enrich it to be more useful

00:29:24,640 --> 00:29:28,480
next um i went ahead and threw in the

00:29:26,720 --> 00:29:29,919
concept of a fact inventory

00:29:28,480 --> 00:29:31,840
um if you're used to the concept of

00:29:29,919 --> 00:29:33,840
puppetdb or

00:29:31,840 --> 00:29:35,440
um ansible tower i believe has a very

00:29:33,840 --> 00:29:36,080
similar concept of just being able to

00:29:35,440 --> 00:29:37,840
say

00:29:36,080 --> 00:29:39,760
i know all the facts about all the

00:29:37,840 --> 00:29:43,840
things um inside of my

00:29:39,760 --> 00:29:45,440
domain so ansible generates fact data on

00:29:43,840 --> 00:29:47,760
every run

00:29:45,440 --> 00:29:50,320
by default unless you tell it not to

00:29:47,760 --> 00:29:53,919
that includes

00:29:50,320 --> 00:29:56,240
a lot of information about the system

00:29:53,919 --> 00:29:57,840
and notably because

00:29:56,240 --> 00:30:00,159
the variable the data is going to vary

00:29:57,840 --> 00:30:02,320
from implementation to implementation

00:30:00,159 --> 00:30:04,159
um it's not i couldn't structure it per

00:30:02,320 --> 00:30:07,120
se this is again where

00:30:04,159 --> 00:30:08,880
using a native unstructured json column

00:30:07,120 --> 00:30:12,080
mixed with

00:30:08,880 --> 00:30:14,640
a postgres view to be able

00:30:12,080 --> 00:30:15,600
to use native json operators to then

00:30:14,640 --> 00:30:19,919
expose

00:30:15,600 --> 00:30:21,919
common pieces through the api of graphql

00:30:19,919 --> 00:30:23,919
now let me move on to the next big piece

00:30:21,919 --> 00:30:25,520
here um the other half of the system

00:30:23,919 --> 00:30:27,440
which is the lab executor

00:30:25,520 --> 00:30:29,760
we talked about the lab manager that

00:30:27,440 --> 00:30:31,760
basically is just the system of record

00:30:29,760 --> 00:30:34,000
this is the piece that actually does

00:30:31,760 --> 00:30:35,520
work so

00:30:34,000 --> 00:30:37,360
when it comes to the abstractions of how

00:30:35,520 --> 00:30:38,960
all this works i could spend forever on

00:30:37,360 --> 00:30:40,000
kind of digging into details but at a

00:30:38,960 --> 00:30:41,840
high level

00:30:40,000 --> 00:30:43,440
um i chose to use a docker container to

00:30:41,840 --> 00:30:45,039
help insulate the dependencies that it

00:30:43,440 --> 00:30:46,159
might have as well as improve

00:30:45,039 --> 00:30:48,080
portability

00:30:46,159 --> 00:30:49,279
notably there are still some gotchas

00:30:48,080 --> 00:30:53,120
that hide between

00:30:49,279 --> 00:30:56,559
running docker on os x versus on linux

00:30:53,120 --> 00:30:59,679
when it comes to things like ipv6 and

00:30:56,559 --> 00:31:02,000
ssh key access passthroughs

00:30:59,679 --> 00:31:04,080
so it's not perfect but it's a lot

00:31:02,000 --> 00:31:06,720
better than it could be

00:31:04,080 --> 00:31:08,640
um then i have the notion of a root

00:31:06,720 --> 00:31:10,960
shell script as well which is the the

00:31:08,640 --> 00:31:15,120
lowest of levels of execution

00:31:10,960 --> 00:31:17,360
um at runtime this is where uh

00:31:15,120 --> 00:31:20,000
the the most primitive things happen

00:31:17,360 --> 00:31:20,640
like being able to upload logs at the

00:31:20,000 --> 00:31:23,120
very very

00:31:20,640 --> 00:31:25,279
end and flag the job state of either you

00:31:23,120 --> 00:31:26,960
did something successfully or it failed

00:31:25,279 --> 00:31:28,559
in some way

00:31:26,960 --> 00:31:30,240
and the reason i went with shell here is

00:31:28,559 --> 00:31:33,440
simply because it was a lot easier to

00:31:30,240 --> 00:31:35,600
redirect shell output to itself

00:31:33,440 --> 00:31:36,799
so that even this lowest level script

00:31:35,600 --> 00:31:40,240
has access to its own

00:31:36,799 --> 00:31:43,360
output to then upload as a log

00:31:40,240 --> 00:31:44,480
a little bit inceptionist but it it

00:31:43,360 --> 00:31:46,880
really does help

00:31:44,480 --> 00:31:48,640
when your triaging those lowest of

00:31:46,880 --> 00:31:50,559
levels

00:31:48,640 --> 00:31:51,840
then the notion of an executor playbook

00:31:50,559 --> 00:31:53,279
it could have been blended into the

00:31:51,840 --> 00:31:55,760
shell script but

00:31:53,279 --> 00:31:56,399
i wanted to use the technology and skill

00:31:55,760 --> 00:31:57,919
sets

00:31:56,399 --> 00:32:00,080
that would make it easier to maintain

00:31:57,919 --> 00:32:01,440
over the long haul so this is where

00:32:00,080 --> 00:32:03,600
things like the code weaving and

00:32:01,440 --> 00:32:07,440
obtaining of work happens

00:32:03,600 --> 00:32:09,279
and then also beyond that point is the

00:32:07,440 --> 00:32:10,960
job entry point playbook

00:32:09,279 --> 00:32:13,760
which is effectively and conceptually

00:32:10,960 --> 00:32:17,120
like what you could think of as main

00:32:13,760 --> 00:32:20,399
in a normal application execution

00:32:17,120 --> 00:32:21,840
i use these a convention on the naming

00:32:20,399 --> 00:32:23,919
of those to leverage both

00:32:21,840 --> 00:32:25,600
the type of environment and the

00:32:23,919 --> 00:32:27,600
operation being performed on the

00:32:25,600 --> 00:32:28,000
environment to formulate the name of the

00:32:27,600 --> 00:32:31,120
playbook

00:32:28,000 --> 00:32:31,840
that's being executed that way the

00:32:31,120 --> 00:32:33,679
playbooks

00:32:31,840 --> 00:32:35,279
defining those variances can actually

00:32:33,679 --> 00:32:37,519
coexist happily

00:32:35,279 --> 00:32:40,399
in the same repository and not

00:32:37,519 --> 00:32:42,240
cross-interfere with one another

00:32:40,399 --> 00:32:44,240
when it comes to execution logging

00:32:42,240 --> 00:32:45,519
security um security obviously is an

00:32:44,240 --> 00:32:48,399
important concept

00:32:45,519 --> 00:32:50,399
so uh first of all when it comes to

00:32:48,399 --> 00:32:51,600
security i expect all the developers

00:32:50,399 --> 00:32:53,840
working in the system

00:32:51,600 --> 00:32:55,039
uh i mean not just using it but actually

00:32:53,840 --> 00:32:57,919
developing in it

00:32:55,039 --> 00:32:58,880
to appropriately make use of the no log

00:32:57,919 --> 00:33:02,720
option

00:32:58,880 --> 00:33:04,640
on any ansible module that might emit

00:33:02,720 --> 00:33:06,559
sensitive information so that it doesn't

00:33:04,640 --> 00:33:08,399
end up in the logs

00:33:06,559 --> 00:33:10,799
additionally because i assume humans are

00:33:08,399 --> 00:33:13,039
humans and are fallible

00:33:10,799 --> 00:33:14,720
therefore there's also there's also a

00:33:13,039 --> 00:33:15,679
backup mechanism that's part of the

00:33:14,720 --> 00:33:18,240
executor

00:33:15,679 --> 00:33:21,039
now earlier i mentioned i use um the

00:33:18,240 --> 00:33:22,799
junit output being xml

00:33:21,039 --> 00:33:24,960
one of the things i did here was to

00:33:22,799 --> 00:33:27,600
actually write a small xslt

00:33:24,960 --> 00:33:30,000
to process those files before upload to

00:33:27,600 --> 00:33:33,360
do some basic token based

00:33:30,000 --> 00:33:36,720
pattern matching and redact

00:33:33,360 --> 00:33:38,480
fields as necessary because

00:33:36,720 --> 00:33:40,399
assuming humans make mistakes and

00:33:38,480 --> 00:33:42,320
overlook things um

00:33:40,399 --> 00:33:44,720
just as a backup mechanism to try and

00:33:42,320 --> 00:33:46,559
prevent that from happening

00:33:44,720 --> 00:33:48,320
when it comes to tips and tricks about

00:33:46,559 --> 00:33:49,760
ansible itself to make it go faster do

00:33:48,320 --> 00:33:52,480
the job better

00:33:49,760 --> 00:33:53,600
um one of the things that um you can do

00:33:52,480 --> 00:33:55,440
is parallelize

00:33:53,600 --> 00:33:56,799
so there's a couple of ways you can do

00:33:55,440 --> 00:33:59,440
this so with

00:33:56,799 --> 00:34:01,679
parallelization you can do um kind of

00:33:59,440 --> 00:34:03,760
like a pause on an individual task while

00:34:01,679 --> 00:34:07,120
you operate over a long

00:34:03,760 --> 00:34:09,119
dictionary of objects or list of objects

00:34:07,120 --> 00:34:10,560
and then also you can do kind of a fire

00:34:09,119 --> 00:34:12,079
and forget model where you don't care

00:34:10,560 --> 00:34:13,839
about the answers you just say

00:34:12,079 --> 00:34:15,839
you know go off in the background and do

00:34:13,839 --> 00:34:18,800
what you want to do

00:34:15,839 --> 00:34:20,000
and again the concept of forks is an

00:34:18,800 --> 00:34:21,520
important low-level concept

00:34:20,000 --> 00:34:24,000
an ansible that basically defines how

00:34:21,520 --> 00:34:25,839
many independent python

00:34:24,000 --> 00:34:28,560
interpreters are allowed to spin up at a

00:34:25,839 --> 00:34:28,560
given moment

00:34:28,720 --> 00:34:32,879
and then the last parallelization

00:34:30,159 --> 00:34:34,960
pattern here is fire and revisit

00:34:32,879 --> 00:34:36,079
so it looks it starts like the fire and

00:34:34,960 --> 00:34:37,839
forget

00:34:36,079 --> 00:34:39,839
pattern except that it registers a

00:34:37,839 --> 00:34:41,760
handle which at a later point of

00:34:39,839 --> 00:34:45,040
execution in a separate task

00:34:41,760 --> 00:34:45,839
can then be blocked on and waited until

00:34:45,040 --> 00:34:48,159
it's complete

00:34:45,839 --> 00:34:48,960
now this is a really important thing for

00:34:48,159 --> 00:34:51,679
us

00:34:48,960 --> 00:34:53,200
when deploying cdns in cdn environments

00:34:51,679 --> 00:34:55,440
because it means that

00:34:53,200 --> 00:34:57,599
for the various components of the atc

00:34:55,440 --> 00:35:00,000
stack that have no dependencies

00:34:57,599 --> 00:35:02,240
of among each other we can actually

00:35:00,000 --> 00:35:04,240
start those asynchronous deploys of all

00:35:02,240 --> 00:35:05,920
the components at the same time

00:35:04,240 --> 00:35:07,599
and then simply wait for all of them to

00:35:05,920 --> 00:35:08,960
have completed before moving on to the

00:35:07,599 --> 00:35:11,119
next tier of components

00:35:08,960 --> 00:35:13,040
that have obviously dependencies on

00:35:11,119 --> 00:35:16,160
lower level tiers

00:35:13,040 --> 00:35:18,480
so like you have to deploy postgres for

00:35:16,160 --> 00:35:22,560
todp before you can deploy traffic cops

00:35:18,480 --> 00:35:25,280
for example there is a gotcha here

00:35:22,560 --> 00:35:26,240
i'll also mention which is that the

00:35:25,280 --> 00:35:28,320
async

00:35:26,240 --> 00:35:29,839
options are not available on every

00:35:28,320 --> 00:35:33,920
ansible module

00:35:29,839 --> 00:35:37,280
notably not the include or import based

00:35:33,920 --> 00:35:38,560
modules so um

00:35:37,280 --> 00:35:40,640
i mentioned earlier that i think of

00:35:38,560 --> 00:35:43,119
those uh

00:35:40,640 --> 00:35:44,960
the implementation uh the there's a

00:35:43,119 --> 00:35:47,359
drive implementation specific driver

00:35:44,960 --> 00:35:50,160
playbook for each component

00:35:47,359 --> 00:35:51,599
well that comes into play here um

00:35:50,160 --> 00:35:53,680
instead of

00:35:51,599 --> 00:35:54,800
um having one playbook that simply

00:35:53,680 --> 00:35:57,359
invokes or includes

00:35:54,800 --> 00:35:59,920
other playbooks into its own main thread

00:35:57,359 --> 00:36:02,640
i leveraged the shell module

00:35:59,920 --> 00:36:03,680
which does allow the async option to

00:36:02,640 --> 00:36:06,240
actually create

00:36:03,680 --> 00:36:08,560
separate ansible playbook invocations as

00:36:06,240 --> 00:36:10,839
separate process

00:36:08,560 --> 00:36:13,119
doing those individual component

00:36:10,839 --> 00:36:16,400
installs

00:36:13,119 --> 00:36:19,280
that way there's no cross pollution of

00:36:16,400 --> 00:36:20,079
data that's only what's available from

00:36:19,280 --> 00:36:22,560
the variable

00:36:20,079 --> 00:36:24,079
files being defined is what shows up at

00:36:22,560 --> 00:36:26,320
runtime

00:36:24,079 --> 00:36:27,839
and then kind of lastly here um for tips

00:36:26,320 --> 00:36:29,839
and tricks one of the fun things that i

00:36:27,839 --> 00:36:31,119
had to wrestle with at some point

00:36:29,839 --> 00:36:32,640
um maybe i could have done it

00:36:31,119 --> 00:36:34,560
differently or better in different ways

00:36:32,640 --> 00:36:35,839
but i came up with the concept of meta

00:36:34,560 --> 00:36:37,599
templating

00:36:35,839 --> 00:36:39,359
now when it comes to cdn configuration i

00:36:37,599 --> 00:36:42,480
told you earlier that

00:36:39,359 --> 00:36:45,920
it's an unstructured mostly json blob

00:36:42,480 --> 00:36:46,560
well that's true except that the root

00:36:45,920 --> 00:36:48,880
keys

00:36:46,560 --> 00:36:50,880
in that case are what i basically define

00:36:48,880 --> 00:36:53,040
to be separate files to be used at

00:36:50,880 --> 00:36:56,240
separate times in the deployment

00:36:53,040 --> 00:36:58,240
now uh it turns out that not just

00:36:56,240 --> 00:36:59,760
the complexity of the application or the

00:36:58,240 --> 00:37:01,119
complexity of the code modeling the

00:36:59,760 --> 00:37:03,599
application

00:37:01,119 --> 00:37:04,560
um the one of the harder questions you

00:37:03,599 --> 00:37:06,480
have to answer

00:37:04,560 --> 00:37:08,000
in deployments is not just what to do

00:37:06,480 --> 00:37:10,880
but when do you have the data

00:37:08,000 --> 00:37:12,320
available to know what to do so for

00:37:10,880 --> 00:37:15,280
example if you want to say

00:37:12,320 --> 00:37:16,480
what's the to url for this environment

00:37:15,280 --> 00:37:18,320
um

00:37:16,480 --> 00:37:20,240
if you're leveraging cloud resources you

00:37:18,320 --> 00:37:22,240
don't know the host names to tell it in

00:37:20,240 --> 00:37:24,000
a hard-coded way for example

00:37:22,240 --> 00:37:26,160
so you need to leverage the inventory to

00:37:24,000 --> 00:37:27,200
tell you that but the inventory when it

00:37:26,160 --> 00:37:29,839
starts

00:37:27,200 --> 00:37:32,400
doesn't actually have that information

00:37:29,839 --> 00:37:36,000
because it hasn't been provisioned yet

00:37:32,400 --> 00:37:39,839
so um by being able to take these

00:37:36,000 --> 00:37:41,839
um the the template module has one of

00:37:39,839 --> 00:37:43,280
the lesser known options to it that was

00:37:41,839 --> 00:37:45,920
more recently added

00:37:43,280 --> 00:37:46,480
to allow you to override what ansible

00:37:45,920 --> 00:37:48,240
treats

00:37:46,480 --> 00:37:50,400
and more importantly ginger underneath

00:37:48,240 --> 00:37:51,520
it treats as the variable interpolation

00:37:50,400 --> 00:37:53,680
token

00:37:51,520 --> 00:37:55,040
the way that i leverage that is by

00:37:53,680 --> 00:37:58,400
saying you know what i can co

00:37:55,040 --> 00:37:59,839
i can co-mingle in the same object

00:37:58,400 --> 00:38:01,280
things with different interpolation

00:37:59,839 --> 00:38:02,640
tokens so that they're rendered at

00:38:01,280 --> 00:38:05,040
separate times

00:38:02,640 --> 00:38:06,880
so i can render things in this case for

00:38:05,040 --> 00:38:09,520
the provisioning layer up front

00:38:06,880 --> 00:38:09,920
make it available up front but maybe i

00:38:09,520 --> 00:38:11,280
have

00:38:09,920 --> 00:38:13,200
other pieces of data that are only

00:38:11,280 --> 00:38:15,599
available later in the process

00:38:13,200 --> 00:38:16,880
so again in the same config object i can

00:38:15,599 --> 00:38:19,040
still model it

00:38:16,880 --> 00:38:21,359
but i use the template module to simply

00:38:19,040 --> 00:38:24,079
render the j2 template

00:38:21,359 --> 00:38:26,079
which is itself as a j2 template rather

00:38:24,079 --> 00:38:29,440
which then generates

00:38:26,079 --> 00:38:32,480
a ansible variable file to then be

00:38:29,440 --> 00:38:34,880
included further down the road

00:38:32,480 --> 00:38:36,000
it's a modestly complicated system to

00:38:34,880 --> 00:38:39,520
wrap your head around

00:38:36,000 --> 00:38:41,760
but it actually works pretty well

00:38:39,520 --> 00:38:43,119
now when it comes to future work things

00:38:41,760 --> 00:38:45,440
that are coming down the pipe

00:38:43,119 --> 00:38:46,960
the main bulk of the work is already in

00:38:45,440 --> 00:38:48,480
the main line of the apache traffic

00:38:46,960 --> 00:38:50,560
control repository

00:38:48,480 --> 00:38:51,920
you can use it today with guilt um if

00:38:50,560 --> 00:38:55,359
you so choose

00:38:51,920 --> 00:38:56,400
um but also i do have my own fork

00:38:55,359 --> 00:38:59,200
where i've been doing a bunch of

00:38:56,400 --> 00:39:02,720
refactor work and also more

00:38:59,200 --> 00:39:05,280
of my day-to-day kind of thing so far

00:39:02,720 --> 00:39:05,760
so there are more improvements coming

00:39:05,280 --> 00:39:07,200
again

00:39:05,760 --> 00:39:08,800
because of guilt you can leverage it

00:39:07,200 --> 00:39:10,240
today if you really want to

00:39:08,800 --> 00:39:12,839
but i make no promises that it's

00:39:10,240 --> 00:39:15,760
perfectly stable yet

00:39:12,839 --> 00:39:17,680
um so kind of takeaways here

00:39:15,760 --> 00:39:19,680
you know um i'm hoping you've got a

00:39:17,680 --> 00:39:21,200
better feel for how the open source and

00:39:19,680 --> 00:39:23,280
closed source pieces

00:39:21,200 --> 00:39:24,320
um and your implementations might work

00:39:23,280 --> 00:39:26,960
together

00:39:24,320 --> 00:39:28,480
how your technology stack can make a

00:39:26,960 --> 00:39:29,520
difference in how you implement your

00:39:28,480 --> 00:39:31,520
solutions

00:39:29,520 --> 00:39:32,800
how complex the end-to-end picture

00:39:31,520 --> 00:39:35,040
actually is

00:39:32,800 --> 00:39:36,480
and more importantly how how you might

00:39:35,040 --> 00:39:38,800
go about tackling

00:39:36,480 --> 00:39:39,520
um getting yourselves into these better

00:39:38,800 --> 00:39:41,440
positions

00:39:39,520 --> 00:39:43,680
now my contact info is here i know i

00:39:41,440 --> 00:39:47,440
don't have a ton of time we'll go until

00:39:43,680 --> 00:39:48,720
the session kicks us off um but

00:39:47,440 --> 00:39:52,320
you're welcome to reach me out on the

00:39:48,720 --> 00:39:54,560
traffic control cdn slack instance

00:39:52,320 --> 00:39:56,160
i'm pretty easy to find with the atc

00:39:54,560 --> 00:39:59,280
robots channel

00:39:56,160 --> 00:40:01,280
so dave how much

00:39:59,280 --> 00:40:02,480
question how many questions we have here

00:40:01,280 --> 00:40:04,880
now thanks jonathan

00:40:02,480 --> 00:40:05,760
looks like we just have one concept of a

00:40:04,880 --> 00:40:07,680
job is great

00:40:05,760 --> 00:40:08,800
provides state tracking for longer

00:40:07,680 --> 00:40:10,880
running tasks

00:40:08,800 --> 00:40:13,280
now when a job fails can it be restarted

00:40:10,880 --> 00:40:16,960
so it continues from where it failed

00:40:13,280 --> 00:40:20,560
that's a good question um my solution

00:40:16,960 --> 00:40:21,040
doesn't um because there's a lot of

00:40:20,560 --> 00:40:23,520
state

00:40:21,040 --> 00:40:24,079
questions that come into play there

00:40:23,520 --> 00:40:25,839
because

00:40:24,079 --> 00:40:27,760
because of the asynchronous nature of

00:40:25,839 --> 00:40:31,040
deployments it gets kind of funny

00:40:27,760 --> 00:40:32,640
when you

00:40:31,040 --> 00:40:34,319
have one thing fail and you don't

00:40:32,640 --> 00:40:36,079
necessarily know what happened to the

00:40:34,319 --> 00:40:38,160
rest of them

00:40:36,079 --> 00:40:39,680
and also recovery is one of the most

00:40:38,160 --> 00:40:42,960
complicated pieces you could

00:40:39,680 --> 00:40:46,240
probably come up with so i kind of

00:40:42,960 --> 00:40:46,800
uh started that and simply for things

00:40:46,240 --> 00:40:49,200
that i know

00:40:46,800 --> 00:40:50,000
are problematic i leveraged the retry

00:40:49,200 --> 00:40:52,000
option

00:40:50,000 --> 00:40:53,839
built into ansible on particular tasks

00:40:52,000 --> 00:40:56,640
that are error-prone

00:40:53,839 --> 00:40:58,960
um but if for some reason there's a

00:40:56,640 --> 00:41:01,599
legitimate failure of some kind

00:40:58,960 --> 00:41:03,520
like not having enough quota or a typo

00:41:01,599 --> 00:41:06,160
in the code somewhere

00:41:03,520 --> 00:41:08,240
and it fails i can review the log data

00:41:06,160 --> 00:41:10,560
to know where it failed

00:41:08,240 --> 00:41:11,599
and hopefully have an idea as to how to

00:41:10,560 --> 00:41:14,079
remediate it going

00:41:11,599 --> 00:41:14,079
forward

00:41:14,720 --> 00:41:19,599
so to answer your question no i don't

00:41:16,800 --> 00:41:22,079
really track the state per se

00:41:19,599 --> 00:41:22,720
within the execution for resumption

00:41:22,079 --> 00:41:25,119
instead i

00:41:22,720 --> 00:41:26,560
tracked the state in the sense of binary

00:41:25,119 --> 00:41:29,680
yes or no

00:41:26,560 --> 00:41:30,800
um to a end user was it good or was it

00:41:29,680 --> 00:41:34,000
not good

00:41:30,800 --> 00:41:36,000
um and then if it's not good figure

00:41:34,000 --> 00:41:38,480
out why and then simply hit it with a

00:41:36,000 --> 00:41:39,599
big hammer and redeploy it from scratch

00:41:38,480 --> 00:41:42,480
all over again

00:41:39,599 --> 00:41:44,319
um because it's a whole lot easier to

00:41:42,480 --> 00:41:45,359
use a big hammer in those sense than to

00:41:44,319 --> 00:41:46,880
try to triage

00:41:45,359 --> 00:41:49,839
all the ways that it might have gone

00:41:46,880 --> 00:41:49,839
sideways

00:41:50,960 --> 00:41:56,000
cool thanks um

00:41:54,240 --> 00:41:58,079
got it can the current set of ansible

00:41:56,000 --> 00:41:59,920
automation be used to bring up a cdn

00:41:58,079 --> 00:42:02,160
from scratch

00:41:59,920 --> 00:42:03,839
so the the that was where i started um

00:42:02,160 --> 00:42:05,280
the cd in a box effort can

00:42:03,839 --> 00:42:08,480
but it's going to be limited local

00:42:05,280 --> 00:42:11,040
resources the ansible based approach

00:42:08,480 --> 00:42:12,160
is not an out of the box solution you do

00:42:11,040 --> 00:42:14,640
have to

00:42:12,160 --> 00:42:16,720
uh implement your own pieces around it

00:42:14,640 --> 00:42:20,480
because again the scope of the atc

00:42:16,720 --> 00:42:22,800
project effectively limits the

00:42:20,480 --> 00:42:24,720
scope of the generic cores to being

00:42:22,800 --> 00:42:27,280
around the application layers

00:42:24,720 --> 00:42:28,560
i mean just because i use openstack

00:42:27,280 --> 00:42:30,240
doesn't mean you do so it wouldn't

00:42:28,560 --> 00:42:30,960
exactly be appropriate for me to say you

00:42:30,240 --> 00:42:32,480
know what hey

00:42:30,960 --> 00:42:34,480
you got to use openstack for this to

00:42:32,480 --> 00:42:35,599
work um and

00:42:34,480 --> 00:42:37,440
obviously when it gets into

00:42:35,599 --> 00:42:39,440
infrastructure details there are all

00:42:37,440 --> 00:42:41,760
manner of different problems

00:42:39,440 --> 00:42:43,119
that will span from implementation to

00:42:41,760 --> 00:42:47,040
implementation

00:42:43,119 --> 00:42:47,440
um so it you know conventionally you

00:42:47,040 --> 00:42:48,800
know

00:42:47,440 --> 00:42:50,079
people are around to kind of maybe give

00:42:48,800 --> 00:42:51,760
you some tips but there's not going to

00:42:50,079 --> 00:42:52,560
be an out of the box hey just go rip

00:42:51,760 --> 00:42:55,839
this out and

00:42:52,560 --> 00:42:56,480
uh you're off and running in a day um in

00:42:55,839 --> 00:42:58,480
production

00:42:56,480 --> 00:43:02,319
you do have to kind of do some leg work

00:42:58,480 --> 00:43:04,160
to make it fit in your infrastructure

00:43:02,319 --> 00:43:07,920
yep and if you're interested in that

00:43:04,160 --> 00:43:07,920
like jonathan already said the

00:43:08,160 --> 00:43:10,880
channel on the

00:43:11,200 --> 00:43:17,280
slack is a good place to discuss

00:43:15,040 --> 00:43:17,280
yep

00:43:19,440 --> 00:43:21,680
cool

00:43:23,359 --> 00:43:26,560
all right well thanks again jonathan

00:43:25,280 --> 00:43:29,760
it's really good

00:43:26,560 --> 00:43:31,599
um and thanks to everyone um for for

00:43:29,760 --> 00:43:35,040
everything all day long

00:43:31,599 --> 00:43:37,040
but i think we are done great thanks

00:43:35,040 --> 00:43:39,040
everybody have a good rest your day

00:43:37,040 --> 00:43:41,839
thank you have a fun apache on

00:43:39,040 --> 00:43:41,839
yeah you too

00:43:42,240 --> 00:43:55,520

YouTube URL: https://www.youtube.com/watch?v=TO0N9sPZdnU


