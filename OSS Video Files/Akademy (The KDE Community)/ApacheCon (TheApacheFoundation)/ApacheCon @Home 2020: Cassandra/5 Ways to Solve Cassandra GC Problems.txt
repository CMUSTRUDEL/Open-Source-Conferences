Title: 5 Ways to Solve Cassandra GC Problems
Publication date: 2020-10-21
Playlist: ApacheCon @Home 2020: Cassandra
Description: 
	5 Ways to Solve Cassandra GC Problems
Caroline George

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Garbage Collection can be painful, impact performance and stability, and can even take down entire clusters. In this talk, we will start by going over the 5 most common reasons for GC in Apache Cassandra. Then we will discuss ways to address these issues. And end with how to monitor your cluster going forward to avoid running into GC problems.

Spent over 6 years working with Apache Cassandra as an SE at Datastax, Caroline is now helping customers increase performance and provide stability with their JVM at Azul Systems. Originally from France, she has spent most of her life in NYC and holds a BA in Computer Science from NYU and MBA from NYU Stern School of Business.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:26,640 --> 00:00:30,640
great

00:00:27,039 --> 00:00:33,680
so um i guess it's uh

00:00:30,640 --> 00:00:36,960
let me get started um

00:00:33,680 --> 00:00:39,600
so thank you everyone for uh

00:00:36,960 --> 00:00:40,480
joining the session uh during which

00:00:39,600 --> 00:00:43,280
we're gonna cover

00:00:40,480 --> 00:00:44,399
everything you ever wanted to know about

00:00:43,280 --> 00:00:47,840
garbage collection

00:00:44,399 --> 00:00:50,399
in java and how it applies to apache

00:00:47,840 --> 00:00:50,399
cassandra

00:00:51,920 --> 00:00:55,760
so to go into more details also i'm

00:00:54,399 --> 00:00:59,280
going to start with an overview

00:00:55,760 --> 00:01:02,160
of java garbage collection

00:00:59,280 --> 00:01:03,359
uh what is it why does it happen why is

00:01:02,160 --> 00:01:05,199
it important

00:01:03,359 --> 00:01:07,840
what you need to know about and then

00:01:05,199 --> 00:01:11,200
different garbage collectors

00:01:07,840 --> 00:01:13,920
and then dive into specifically how gc

00:01:11,200 --> 00:01:15,600
affects cassandra the different

00:01:13,920 --> 00:01:18,720
components of cassandra

00:01:15,600 --> 00:01:20,400
that create garbage collection and then

00:01:18,720 --> 00:01:22,400
how do you address them right it's nice

00:01:20,400 --> 00:01:23,280
to know you have problems but it's even

00:01:22,400 --> 00:01:25,840
better to know

00:01:23,280 --> 00:01:26,799
what you can do about them and then i'll

00:01:25,840 --> 00:01:29,680
leave you with some

00:01:26,799 --> 00:01:29,680
final thoughts

00:01:29,840 --> 00:01:35,280
so a little bit about me uh it's nice to

00:01:32,960 --> 00:01:37,360
see everybody from data stacks again

00:01:35,280 --> 00:01:39,360
i was an sc a sales engineer at data

00:01:37,360 --> 00:01:41,840
stocks well over five years

00:01:39,360 --> 00:01:43,520
helping companies learn about the

00:01:41,840 --> 00:01:46,560
technology what is cassandra

00:01:43,520 --> 00:01:49,119
implement it review data model

00:01:46,560 --> 00:01:51,840
tuning configuration et cetera and then

00:01:49,119 --> 00:01:55,680
more recently i joined azul

00:01:51,840 --> 00:01:57,920
ozil provides a high performance

00:01:55,680 --> 00:01:59,040
garbage collector that avoids stops or

00:01:57,920 --> 00:02:01,040
pauses

00:01:59,040 --> 00:02:03,280
so lately i've been working more with

00:02:01,040 --> 00:02:05,040
low linc trading application

00:02:03,280 --> 00:02:06,799
and i always thought chrysandra atlanti

00:02:05,040 --> 00:02:07,439
was incredibly fast but now i'm talking

00:02:06,799 --> 00:02:10,479
about like

00:02:07,439 --> 00:02:12,560
nanosecond latencies uh

00:02:10,479 --> 00:02:14,800
but you know luckily you know people are

00:02:12,560 --> 00:02:17,120
using zing on cassandra

00:02:14,800 --> 00:02:19,599
uh hadoop nate node elastic solar so

00:02:17,120 --> 00:02:23,360
basically anything that runs on the jvm

00:02:19,599 --> 00:02:27,120
can run on so my world is basically more

00:02:23,360 --> 00:02:30,160
or less cassandra and garbage collection

00:02:27,120 --> 00:02:30,800
uh so let's talk about uh garbage

00:02:30,160 --> 00:02:34,239
collection

00:02:30,800 --> 00:02:35,200
in java uh let's start with a brief

00:02:34,239 --> 00:02:40,400
history of

00:02:35,200 --> 00:02:43,840
java java 1.0 came out in 1996.

00:02:40,400 --> 00:02:45,519
um it feels like a hundred years ago

00:02:43,840 --> 00:02:47,120
i mean after the year we've just had

00:02:45,519 --> 00:02:48,160
that feels like ages i don't know if

00:02:47,120 --> 00:02:51,040
anybody can remember what they were

00:02:48,160 --> 00:02:53,200
doing in 96. um

00:02:51,040 --> 00:02:55,120
the next you know the next major release

00:02:53,200 --> 00:02:58,640
was four years later

00:02:55,120 --> 00:03:01,120
and then uh java 7

00:02:58,640 --> 00:03:02,239
came out in 2011 right so there was

00:03:01,120 --> 00:03:04,000
quite some time

00:03:02,239 --> 00:03:05,360
there's still definitely people using

00:03:04,000 --> 00:03:09,680
java 7.

00:03:05,360 --> 00:03:12,319
most people are using

00:03:09,680 --> 00:03:14,159
java 8 which is a long-term support

00:03:12,319 --> 00:03:16,800
meaning like it's supported for at least

00:03:14,159 --> 00:03:18,000
10 plus years the next long-term

00:03:16,800 --> 00:03:21,120
supported version

00:03:18,000 --> 00:03:21,120
is um

00:03:21,360 --> 00:03:26,799
java 11. thanks for everybody sharing

00:03:23,760 --> 00:03:29,280
what they were doing in 1996

00:03:26,799 --> 00:03:30,720
and then the next uh long-term supported

00:03:29,280 --> 00:03:34,720
version is coming out

00:03:30,720 --> 00:03:37,840
right now nice target for september 2021

00:03:34,720 --> 00:03:39,280
so next year right so

00:03:37,840 --> 00:03:40,720
you could see the evolution i mean

00:03:39,280 --> 00:03:41,360
there's definitely been a lot more

00:03:40,720 --> 00:03:43,200
activity

00:03:41,360 --> 00:03:45,200
in the java world over the last few

00:03:43,200 --> 00:03:48,000
years

00:03:45,200 --> 00:03:48,720
so now you know what is garbage

00:03:48,000 --> 00:03:51,440
collection

00:03:48,720 --> 00:03:52,480
right like what is it exactly uh so

00:03:51,440 --> 00:03:55,040
garbage collection

00:03:52,480 --> 00:03:56,239
is a way for the java virtual machine

00:03:55,040 --> 00:03:59,280
the jvm

00:03:56,239 --> 00:04:01,360
to free up memory right so

00:03:59,280 --> 00:04:03,280
any objects that are being used that's

00:04:01,360 --> 00:04:04,720
unreachable well that

00:04:03,280 --> 00:04:06,879
that should get freed up so other

00:04:04,720 --> 00:04:10,159
objects can get created and can be used

00:04:06,879 --> 00:04:13,360
and use that memory space and so there's

00:04:10,159 --> 00:04:16,799
two types of garbage collection there's

00:04:13,360 --> 00:04:19,600
a minor garbage collection which is uh

00:04:16,799 --> 00:04:20,320
you know most objects are going to be

00:04:19,600 --> 00:04:22,880
created

00:04:20,320 --> 00:04:24,000
and then they're going to be unreachable

00:04:22,880 --> 00:04:26,720
within

00:04:24,000 --> 00:04:28,000
the first garbage collection cycle and

00:04:26,720 --> 00:04:31,199
then you have

00:04:28,000 --> 00:04:34,560
a major and full gc which is

00:04:31,199 --> 00:04:36,639
a lot more uh i don't say relevant but

00:04:34,560 --> 00:04:40,080
that's what people notice because that's

00:04:36,639 --> 00:04:42,240
usually impacts the application and

00:04:40,080 --> 00:04:43,360
at the bottom the picture basically

00:04:42,240 --> 00:04:45,919
depicts um

00:04:43,360 --> 00:04:46,560
a traditional generational garbage

00:04:45,919 --> 00:04:50,240
collector

00:04:46,560 --> 00:04:54,400
like cms cms used to be the default

00:04:50,240 --> 00:04:57,280
in in java and with cassandra

00:04:54,400 --> 00:04:59,440
you know you start with eden survivor of

00:04:57,280 --> 00:05:03,360
space zero and one and that makes up

00:04:59,440 --> 00:05:05,039
your young uh generation and then uh as

00:05:03,360 --> 00:05:08,000
objects get promoted

00:05:05,039 --> 00:05:09,840
they um they're looking you know they

00:05:08,000 --> 00:05:10,639
get promoted to tenured and then

00:05:09,840 --> 00:05:13,759
permanent

00:05:10,639 --> 00:05:17,199
and then when you do a full gc is when

00:05:13,759 --> 00:05:17,199
those objects are removed

00:05:17,520 --> 00:05:22,240
um so you know why does garbage

00:05:20,000 --> 00:05:24,720
collection even happen

00:05:22,240 --> 00:05:25,840
so it's based on the premise that most

00:05:24,720 --> 00:05:29,039
objects in java

00:05:25,840 --> 00:05:30,479
are short-lived what it means is that

00:05:29,039 --> 00:05:32,160
they're not going to survive that first

00:05:30,479 --> 00:05:35,680
garbage collection cycle

00:05:32,160 --> 00:05:38,400
uh they're created and

00:05:35,680 --> 00:05:39,199
referenced fairly quickly and so you

00:05:38,400 --> 00:05:42,080
need a way

00:05:39,199 --> 00:05:44,000
to to clear up the the heat to free up

00:05:42,080 --> 00:05:47,039
memories you don't want to run out of

00:05:44,000 --> 00:05:51,039
memory um and so you know the pro

00:05:47,039 --> 00:05:52,960
you know to add to the premise is that

00:05:51,039 --> 00:05:55,039
when you're cleaning up new new

00:05:52,960 --> 00:05:56,080
generation you know eden survivor space

00:05:55,039 --> 00:05:59,120
zero one it's

00:05:56,080 --> 00:06:02,240
really fast promoting from young to old

00:05:59,120 --> 00:06:02,240
is slower

00:06:02,639 --> 00:06:06,800
the more objects you create uh you're

00:06:05,120 --> 00:06:08,240
the more your young generation is gonna

00:06:06,800 --> 00:06:09,840
get full and then it's gonna get

00:06:08,240 --> 00:06:12,479
promoted to old

00:06:09,840 --> 00:06:13,280
and these promotions also means longer

00:06:12,479 --> 00:06:16,479
pauses

00:06:13,280 --> 00:06:20,080
so this is all these

00:06:16,479 --> 00:06:21,039
uh items all these objects affect your

00:06:20,080 --> 00:06:24,319
garbage collection

00:06:21,039 --> 00:06:25,280
and your pauses and so the the diagram

00:06:24,319 --> 00:06:28,479
at the bottom

00:06:25,280 --> 00:06:32,080
is actually a representation of g1

00:06:28,479 --> 00:06:35,919
which is garbage first which is

00:06:32,080 --> 00:06:38,560
the now the default garbage collector in

00:06:35,919 --> 00:06:40,240
from i think like java 9 onwards and

00:06:38,560 --> 00:06:43,600
with cassandra

00:06:40,240 --> 00:06:45,600
and it's similar to cms in terms of

00:06:43,600 --> 00:06:48,080
it's still generational you still have

00:06:45,600 --> 00:06:51,280
your eden your survivor face

00:06:48,080 --> 00:06:52,880
your old gen but what it does is it

00:06:51,280 --> 00:06:54,639
takes instead of taking the entire heap

00:06:52,880 --> 00:06:56,639
and breaking up to the section

00:06:54,639 --> 00:06:57,840
it actually takes your entire heap

00:06:56,639 --> 00:07:00,160
breaks it up into

00:06:57,840 --> 00:07:01,120
smaller regions uh usually you know

00:07:00,160 --> 00:07:04,560
divided by

00:07:01,120 --> 00:07:06,080
uh 2048 and so it means that

00:07:04,560 --> 00:07:07,840
when it's actually doing garbage

00:07:06,080 --> 00:07:08,160
collection it's doing garbage collection

00:07:07,840 --> 00:07:11,280
on

00:07:08,160 --> 00:07:16,000
smaller um smaller regions small heap

00:07:11,280 --> 00:07:19,360
sizes and so it's a lot more efficient

00:07:16,000 --> 00:07:21,199
and so you know why is there

00:07:19,360 --> 00:07:23,360
garbage collection happening even to

00:07:21,199 --> 00:07:25,440
begin with well

00:07:23,360 --> 00:07:27,599
i mean that's also the reason why people

00:07:25,440 --> 00:07:30,400
are using java instead of c

00:07:27,599 --> 00:07:32,080
plus plus right it's just a lot easier

00:07:30,400 --> 00:07:34,000
from a developer standpoint

00:07:32,080 --> 00:07:35,599
where you don't have to worry about

00:07:34,000 --> 00:07:38,960
releasing memory

00:07:35,599 --> 00:07:41,120
uh you don't have to to do it manually

00:07:38,960 --> 00:07:42,400
it's done for you in java through

00:07:41,120 --> 00:07:44,479
coverage collection

00:07:42,400 --> 00:07:45,680
uh cover selection is a way of

00:07:44,479 --> 00:07:47,759
allocating objects

00:07:45,680 --> 00:07:48,960
on heap and then on the flip side

00:07:47,759 --> 00:07:51,759
clearing up the memory

00:07:48,960 --> 00:07:53,599
so that you have memory available to

00:07:51,759 --> 00:07:56,879
create future objects

00:07:53,599 --> 00:07:59,280
um it's also a way of making sure that

00:07:56,879 --> 00:08:00,319
you're not overriding the content of an

00:07:59,280 --> 00:08:03,039
object

00:08:00,319 --> 00:08:04,800
uh for example let's say you you create

00:08:03,039 --> 00:08:06,080
an object and then you have a

00:08:04,800 --> 00:08:08,160
you know another part of the application

00:08:06,080 --> 00:08:10,319
that creates a pointer to that object

00:08:08,160 --> 00:08:11,360
uh and then they say you clean up the

00:08:10,319 --> 00:08:12,080
object but you didn't clean up the

00:08:11,360 --> 00:08:14,160
pointer

00:08:12,080 --> 00:08:15,520
and then you use that space to create a

00:08:14,160 --> 00:08:17,440
new object so now the pointer is

00:08:15,520 --> 00:08:19,759
pointing something that it didn't even

00:08:17,440 --> 00:08:20,879
you know completely different uh and

00:08:19,759 --> 00:08:22,400
it's this is a

00:08:20,879 --> 00:08:25,280
that type of situation is actually

00:08:22,400 --> 00:08:27,680
really really hard to debug

00:08:25,280 --> 00:08:28,400
so it just makes it makes programming a

00:08:27,680 --> 00:08:31,599
lot easier

00:08:28,400 --> 00:08:34,479
it makes debugging a lot easier um

00:08:31,599 --> 00:08:35,120
but then you know keep in mind that uh

00:08:34,479 --> 00:08:37,279
the more

00:08:35,120 --> 00:08:38,880
garbage collection activity there is the

00:08:37,279 --> 00:08:40,080
more resources it's going to use and

00:08:38,880 --> 00:08:42,240
it's not just

00:08:40,080 --> 00:08:44,480
on you know in terms of memory but it's

00:08:42,240 --> 00:08:47,680
also on your cpu

00:08:44,480 --> 00:08:48,480
right and then um the one thing you

00:08:47,680 --> 00:08:50,080
really really

00:08:48,480 --> 00:08:52,240
should pay attention to with garbage

00:08:50,080 --> 00:08:53,279
collection is these stop the world

00:08:52,240 --> 00:08:55,760
pauses

00:08:53,279 --> 00:08:58,399
so i'm sure everybody's seeing their

00:08:55,760 --> 00:09:00,080
cassandra environment

00:08:58,399 --> 00:09:02,720
you know sometimes the stability and the

00:09:00,080 --> 00:09:05,760
smoothness isn't there

00:09:02,720 --> 00:09:07,360
for example you know imagine if you're

00:09:05,760 --> 00:09:08,880
so when you do stop the world pause it

00:09:07,360 --> 00:09:11,839
actually stops the application

00:09:08,880 --> 00:09:12,720
for running and so let's say you have a

00:09:11,839 --> 00:09:16,000
one second

00:09:12,720 --> 00:09:18,480
garbage collection pause which you know

00:09:16,000 --> 00:09:20,080
it's fairly big for garbage collection

00:09:18,480 --> 00:09:20,480
but you know in cassandra i've actually

00:09:20,080 --> 00:09:22,720
seen

00:09:20,480 --> 00:09:24,160
worse pauses well during that time

00:09:22,720 --> 00:09:27,440
cassandra can't

00:09:24,160 --> 00:09:29,120
uh handle rights or reads right so think

00:09:27,440 --> 00:09:31,200
about you're doing a million rights per

00:09:29,120 --> 00:09:34,160
second and you have a million pause

00:09:31,200 --> 00:09:35,680
then also your coordinator has to handle

00:09:34,160 --> 00:09:37,839
you know all the hitting handoffs

00:09:35,680 --> 00:09:39,440
and uh and then has to replay all the

00:09:37,839 --> 00:09:42,640
information to the replicas

00:09:39,440 --> 00:09:44,160
or the replica that was uh experiencing

00:09:42,640 --> 00:09:47,360
a stop the world pause

00:09:44,160 --> 00:09:49,839
so it's just additional work

00:09:47,360 --> 00:09:53,120
um on your cluster when you're having

00:09:49,839 --> 00:09:53,120
these stop the world posits

00:09:53,440 --> 00:09:56,480
and so just you know a little bit of

00:09:55,120 --> 00:09:59,200
terminology

00:09:56,480 --> 00:09:59,600
uh i just mentioned you know generations

00:09:59,200 --> 00:10:02,079
uh

00:09:59,600 --> 00:10:03,519
generational garbage collectors like cms

00:10:02,079 --> 00:10:06,959
slide g1

00:10:03,519 --> 00:10:08,959
uh zing is another one uh it's a

00:10:06,959 --> 00:10:11,040
you know going back to that premise that

00:10:08,959 --> 00:10:13,120
most objects will not survive

00:10:11,040 --> 00:10:15,120
the first gc cycle and so they get

00:10:13,120 --> 00:10:17,519
created and cleaned up fairly quickly

00:10:15,120 --> 00:10:19,440
so you know you have one garbage

00:10:17,519 --> 00:10:20,000
collector that actually is monitoring

00:10:19,440 --> 00:10:21,920
these

00:10:20,000 --> 00:10:23,279
objects versus another one that's

00:10:21,920 --> 00:10:26,320
actually tracking

00:10:23,279 --> 00:10:27,839
um objects that are promoted to the old

00:10:26,320 --> 00:10:30,320
generation

00:10:27,839 --> 00:10:32,880
as opposed to for example some of the

00:10:30,320 --> 00:10:36,720
newer garbage collectors like shenandoah

00:10:32,880 --> 00:10:40,240
and by red hat and zgc by

00:10:36,720 --> 00:10:41,760
oracle uh those are single generation

00:10:40,240 --> 00:10:43,440
right they don't differentiate they

00:10:41,760 --> 00:10:46,079
don't keep track of

00:10:43,440 --> 00:10:47,440
young and old so that's you know just

00:10:46,079 --> 00:10:50,800
different

00:10:47,440 --> 00:10:53,839
um parallel uh most

00:10:50,800 --> 00:10:55,680
more modern gen garbage collectors or

00:10:53,839 --> 00:10:58,079
parallel meaning they're running you

00:10:55,680 --> 00:11:01,120
know multiple threads simultaneously

00:10:58,079 --> 00:11:02,240
as opposed to to cereal i mean serial is

00:11:01,120 --> 00:11:03,760
more you know older

00:11:02,240 --> 00:11:05,120
garbage collectors where let's say

00:11:03,760 --> 00:11:06,959
you're running an application from a

00:11:05,120 --> 00:11:09,600
command line and smaller

00:11:06,959 --> 00:11:12,320
um your garbage collection is just

00:11:09,600 --> 00:11:15,519
executed in just one gc thread

00:11:12,320 --> 00:11:19,040
uh but most garbage collectors now uh

00:11:15,519 --> 00:11:20,720
run in parallel and uh they also run

00:11:19,040 --> 00:11:21,839
you'll hear they run concurrently

00:11:20,720 --> 00:11:23,839
because they're running concurrently

00:11:21,839 --> 00:11:28,160
with the application

00:11:23,839 --> 00:11:29,920
um and so the last terminology is

00:11:28,160 --> 00:11:30,320
actually two different methodology of

00:11:29,920 --> 00:11:33,360
how

00:11:30,320 --> 00:11:36,720
garbage collection per se is done

00:11:33,360 --> 00:11:39,360
mark and sweep you know cms uh

00:11:36,720 --> 00:11:40,160
concurrent market sweep the name says it

00:11:39,360 --> 00:11:42,640
all

00:11:40,160 --> 00:11:44,079
the way it works is that it will start

00:11:42,640 --> 00:11:46,880
at the root

00:11:44,079 --> 00:11:47,760
and and it'll traverse your heap and

00:11:46,880 --> 00:11:49,839
identify

00:11:47,760 --> 00:11:52,320
and basically mark objects which one are

00:11:49,839 --> 00:11:55,519
reachable which one are unreachable

00:11:52,320 --> 00:11:56,079
and uh and then it'll do a sweeping

00:11:55,519 --> 00:11:58,240
phase

00:11:56,079 --> 00:11:59,120
where anything that was marked as

00:11:58,240 --> 00:12:02,800
unreachable

00:11:59,120 --> 00:12:06,160
gets cleared up versus mark and copy

00:12:02,800 --> 00:12:10,079
which is uh you know the methodology

00:12:06,160 --> 00:12:12,639
for you know shenandoah zgc

00:12:10,079 --> 00:12:13,519
zhang they all do mark and copy where

00:12:12,639 --> 00:12:15,839
instead

00:12:13,519 --> 00:12:17,040
of just marking first and then sweeping

00:12:15,839 --> 00:12:19,519
uh it will mark

00:12:17,040 --> 00:12:21,600
and when it finds an object reachable

00:12:19,519 --> 00:12:23,920
then it will copy it to a different

00:12:21,600 --> 00:12:25,279
memory space and this is a little bit

00:12:23,920 --> 00:12:27,760
more complicated because then if you

00:12:25,279 --> 00:12:29,440
have other objects referencing

00:12:27,760 --> 00:12:31,200
that that object you know the new

00:12:29,440 --> 00:12:33,920
pointers the pointers need to

00:12:31,200 --> 00:12:39,360
point to the new location but it's just

00:12:33,920 --> 00:12:41,360
a lot more efficient and more performant

00:12:39,360 --> 00:12:42,800
and so now you're probably thinking oh i

00:12:41,360 --> 00:12:44,320
should have paid attention to what all

00:12:42,800 --> 00:12:45,279
these garbage collectors were and which

00:12:44,320 --> 00:12:47,040
one did what

00:12:45,279 --> 00:12:48,720
uh just kidding uh this is just a

00:12:47,040 --> 00:12:49,519
summary of the different garbage

00:12:48,720 --> 00:12:52,800
collectors

00:12:49,519 --> 00:12:55,920
you have out there and i mean there's

00:12:52,800 --> 00:12:59,519
quite a few uh you know

00:12:55,920 --> 00:13:03,360
parallel it's kind of the beginning cms

00:12:59,519 --> 00:13:05,519
with the default g1 is now the default

00:13:03,360 --> 00:13:06,639
uh it's a lot easier to use a lot less

00:13:05,519 --> 00:13:10,560
tuning

00:13:06,639 --> 00:13:13,600
uh zgc shenandoah came out recently

00:13:10,560 --> 00:13:16,959
their single generation concurrent

00:13:13,600 --> 00:13:18,839
parallel garbage collector zing is also

00:13:16,959 --> 00:13:22,240
concurrent

00:13:18,839 --> 00:13:22,639
copy uh mark and copy garbage collector

00:13:22,240 --> 00:13:26,639
that

00:13:22,639 --> 00:13:28,399
avoids software pauses and then epsilon

00:13:26,639 --> 00:13:30,800
i'll mention it here but you probably

00:13:28,399 --> 00:13:34,240
won't see it in cassandra because

00:13:30,800 --> 00:13:36,240
uh epsilon is great if you have zero gc

00:13:34,240 --> 00:13:38,480
so let's say you know some of these low

00:13:36,240 --> 00:13:40,560
latency training systems i work with

00:13:38,480 --> 00:13:42,880
uh they might use epsilon but as soon as

00:13:40,560 --> 00:13:46,639
you hit a garbage collection

00:13:42,880 --> 00:13:49,040
the application will probably crash so

00:13:46,639 --> 00:13:49,920
um so yeah so there's definitely a lot

00:13:49,040 --> 00:13:53,839
of uh

00:13:49,920 --> 00:13:56,160
a lot of options with garbage collectors

00:13:53,839 --> 00:13:57,040
um and then just you know a little bit

00:13:56,160 --> 00:14:00,839
of history

00:13:57,040 --> 00:14:04,079
on i'm just gonna just g1 right

00:14:00,839 --> 00:14:07,360
uh g1 has been around for

00:14:04,079 --> 00:14:08,639
quite a while it uh came out in it was

00:14:07,360 --> 00:14:12,399
first experimental

00:14:08,639 --> 00:14:16,480
in java 6 in 2009

00:14:12,399 --> 00:14:19,279
uh it became supported in java 7

00:14:16,480 --> 00:14:21,040
a couple years later it became supported

00:14:19,279 --> 00:14:24,880
along cms it was promoted

00:14:21,040 --> 00:14:26,880
so it's now in java 8 and actually as of

00:14:24,880 --> 00:14:28,079
java 9 i didn't put it in there so i put

00:14:26,880 --> 00:14:30,000
it in 11.

00:14:28,079 --> 00:14:31,680
it actually replaces if you're using

00:14:30,000 --> 00:14:35,120
hotspot it actually replaces

00:14:31,680 --> 00:14:36,000
um the garbage collector uh before used

00:14:35,120 --> 00:14:39,680
to be cms

00:14:36,000 --> 00:14:41,279
that was the default now it's g1

00:14:39,680 --> 00:14:42,800
uh and then it's also you know

00:14:41,279 --> 00:14:45,040
illustrate that

00:14:42,800 --> 00:14:47,199
garbage collection is hard right like it

00:14:45,040 --> 00:14:50,320
takes a while for a garbage collector

00:14:47,199 --> 00:14:52,320
to be efficient to be tested uh

00:14:50,320 --> 00:14:53,360
to work out some of the details sorry

00:14:52,320 --> 00:14:55,120
like this one

00:14:53,360 --> 00:14:57,279
it took about nine years between the

00:14:55,120 --> 00:14:58,800
time it was first released to the time

00:14:57,279 --> 00:15:01,920
it became the default

00:14:58,800 --> 00:15:04,480
so um

00:15:01,920 --> 00:15:05,120
and then my last point on garbage call

00:15:04,480 --> 00:15:08,720
election

00:15:05,120 --> 00:15:10,399
per se specifically is like this is

00:15:08,720 --> 00:15:13,279
all the different tuning parameters and

00:15:10,399 --> 00:15:17,120
flags that

00:15:13,279 --> 00:15:19,279
you can use with cms right so cms is

00:15:17,120 --> 00:15:21,519
fairly you know very powerful but took a

00:15:19,279 --> 00:15:25,360
lot of time and resources

00:15:21,519 --> 00:15:26,079
tuning it correctly uh g1 it takes a lot

00:15:25,360 --> 00:15:28,240
fewer

00:15:26,079 --> 00:15:29,120
flags you know you still want to set

00:15:28,240 --> 00:15:32,000
your maxi

00:15:29,120 --> 00:15:33,040
maybe your minimum heap size uh the

00:15:32,000 --> 00:15:36,880
number of

00:15:33,040 --> 00:15:40,720
uh max pass time and uh concurrent

00:15:36,880 --> 00:15:43,279
compact uh compactors but um as new

00:15:40,720 --> 00:15:45,040
garbage collectors come out they've tend

00:15:43,279 --> 00:15:46,800
to also try to move towards like ease of

00:15:45,040 --> 00:15:48,480
use in terms of tuning

00:15:46,800 --> 00:15:49,920
for example you know like c4 is a

00:15:48,480 --> 00:15:52,880
garbage collector in zing

00:15:49,920 --> 00:15:54,959
and you only really need to set the xmx

00:15:52,880 --> 00:15:57,759
the max heap size and that's it

00:15:54,959 --> 00:15:58,560
so um i mean kind of the same way

00:15:57,759 --> 00:16:00,880
cassandra

00:15:58,560 --> 00:16:03,040
has been trying to ease ease of use in

00:16:00,880 --> 00:16:04,800
terms of you know using and operating

00:16:03,040 --> 00:16:07,279
and developing on cassandra

00:16:04,800 --> 00:16:08,959
same thing with garbage collectors and

00:16:07,279 --> 00:16:10,959
then my last point is

00:16:08,959 --> 00:16:12,560
don't just switch your garbage collector

00:16:10,959 --> 00:16:14,560
and not change your flags

00:16:12,560 --> 00:16:15,680
because uh if you know especially if

00:16:14,560 --> 00:16:17,600
you're changing to something like

00:16:15,680 --> 00:16:20,000
shenandoah cgc

00:16:17,600 --> 00:16:22,160
single generation tune it correctly

00:16:20,000 --> 00:16:24,880
right don't just change it uh take a

00:16:22,160 --> 00:16:26,959
look at your flags

00:16:24,880 --> 00:16:28,480
so now you know let's talk about uh

00:16:26,959 --> 00:16:31,600
garbage collection

00:16:28,480 --> 00:16:34,880
uh for apache cassandra specifically

00:16:31,600 --> 00:16:37,440
so the first topic i'm gonna address is

00:16:34,880 --> 00:16:41,040
compaction

00:16:37,440 --> 00:16:42,560
quick recap compaction let me go through

00:16:41,040 --> 00:16:44,880
you know the right path

00:16:42,560 --> 00:16:45,839
uh when cassandra writes data it will

00:16:44,880 --> 00:16:48,240
write to

00:16:45,839 --> 00:16:50,480
a on this journal entry called the

00:16:48,240 --> 00:16:53,120
commit log as well as an in-memory

00:16:50,480 --> 00:16:53,839
uh data structure called the mem table

00:16:53,120 --> 00:16:56,480
this way

00:16:53,839 --> 00:16:58,320
if you're rebooting your server you know

00:16:56,480 --> 00:16:59,759
everything is memory gets wiped out but

00:16:58,320 --> 00:17:00,639
then you can replay all your entry from

00:16:59,759 --> 00:17:02,800
the commit log

00:17:00,639 --> 00:17:04,880
and you don't lose any data which is

00:17:02,800 --> 00:17:06,880
kind of nice when you have a database

00:17:04,880 --> 00:17:08,160
uh as you know you write more and more

00:17:06,880 --> 00:17:10,319
data your commit log in

00:17:08,160 --> 00:17:13,120
tables get full and then the mem tables

00:17:10,319 --> 00:17:14,640
get flushed onto disk into ss tables

00:17:13,120 --> 00:17:16,160
and then you know the more you do this

00:17:14,640 --> 00:17:18,079
the more you're going to have ss tables

00:17:16,160 --> 00:17:20,240
and then compaction takes all these ss

00:17:18,079 --> 00:17:23,360
tables combine them into one

00:17:20,240 --> 00:17:24,000
so so compassion is great in terms of of

00:17:23,360 --> 00:17:26,400
disk space

00:17:24,000 --> 00:17:28,480
right also it's you know a very

00:17:26,400 --> 00:17:30,799
efficient way of clearing up

00:17:28,480 --> 00:17:32,480
all these ss tables relying on disk and

00:17:30,799 --> 00:17:34,320
then combining your records that you

00:17:32,480 --> 00:17:36,960
might have updated over time

00:17:34,320 --> 00:17:38,640
into just the you know based on the one

00:17:36,960 --> 00:17:40,960
uh primary key

00:17:38,640 --> 00:17:41,919
the thing is compaction actually creates

00:17:40,960 --> 00:17:44,480
a lot of very

00:17:41,919 --> 00:17:45,919
you know short-lived objects and so you

00:17:44,480 --> 00:17:47,360
know the martial and objects you have

00:17:45,919 --> 00:17:50,160
they get promoted

00:17:47,360 --> 00:17:51,520
and they create garbage collection so a

00:17:50,160 --> 00:17:53,679
lot of times when you see

00:17:51,520 --> 00:17:54,960
a lot of compactions happening you'll

00:17:53,679 --> 00:17:58,000
probably also notice

00:17:54,960 --> 00:18:00,080
that your your cluster your nodes are

00:17:58,000 --> 00:18:03,919
also going through a lot of they might

00:18:00,080 --> 00:18:03,919
be going through a lot of gc pulses

00:18:04,640 --> 00:18:11,520
the next topic is tombstones so

00:18:08,480 --> 00:18:14,240
uh can't get away from the right path

00:18:11,520 --> 00:18:15,840
um you know like i mentioned commit log

00:18:14,240 --> 00:18:18,000
mem table to write a

00:18:15,840 --> 00:18:18,960
a record when you're deleting data in

00:18:18,000 --> 00:18:20,880
cassandra

00:18:18,960 --> 00:18:22,400
uh it doesn't go through your terabytes

00:18:20,880 --> 00:18:23,360
of data i found the record and then

00:18:22,400 --> 00:18:25,120
deletes it

00:18:23,360 --> 00:18:26,720
it actually you know inserts a new

00:18:25,120 --> 00:18:30,720
record uh

00:18:26,720 --> 00:18:33,520
it will insert the primary key

00:18:30,720 --> 00:18:34,240
uh puts a flag called the tombstone and

00:18:33,520 --> 00:18:36,960
so

00:18:34,240 --> 00:18:38,799
when you're reading data it will know

00:18:36,960 --> 00:18:39,600
that that record is marked for deletion

00:18:38,799 --> 00:18:42,799
will include it

00:18:39,600 --> 00:18:46,559
into um into your result set as

00:18:42,799 --> 00:18:47,679
well as um when you're running

00:18:46,559 --> 00:18:49,840
compaction

00:18:47,679 --> 00:18:51,679
you know um it'll compact the data but

00:18:49,840 --> 00:18:53,520
the data isn't actually deleted right

00:18:51,679 --> 00:18:56,480
when compaction happens it will wait

00:18:53,520 --> 00:18:58,640
until gc grace seconds it's over

00:18:56,480 --> 00:19:00,640
so you don't have phantom records uh

00:18:58,640 --> 00:19:03,360
coming back in case back look as

00:19:00,640 --> 00:19:04,320
we're offline or out of sync right and

00:19:03,360 --> 00:19:07,600
so

00:19:04,320 --> 00:19:08,880
the thing is if you're if you're writing

00:19:07,600 --> 00:19:12,160
a lot of tombstones

00:19:08,880 --> 00:19:14,240
and you're retrieving large result sets

00:19:12,160 --> 00:19:15,760
the thing is that the tombstones are

00:19:14,240 --> 00:19:18,640
actually kept in memories because the

00:19:15,760 --> 00:19:20,000
coordinator needs to know which records

00:19:18,640 --> 00:19:21,039
are marked for deletion you know

00:19:20,000 --> 00:19:22,960
especially if you're pulling from

00:19:21,039 --> 00:19:25,679
multiple replicas as you should be

00:19:22,960 --> 00:19:26,720
with a consistency level of local quorum

00:19:25,679 --> 00:19:29,440
hopefully

00:19:26,720 --> 00:19:30,559
uh and so it means that you know on your

00:19:29,440 --> 00:19:33,679
on your queries

00:19:30,559 --> 00:19:35,520
uh the coordinator can't leverage paging

00:19:33,679 --> 00:19:36,880
and so all these records need to be

00:19:35,520 --> 00:19:38,320
returned and they'll

00:19:36,880 --> 00:19:40,720
you know right into memory and it

00:19:38,320 --> 00:19:44,320
creates memory pressure onto your nodes

00:19:40,720 --> 00:19:47,280
especially on the coordinator um

00:19:44,320 --> 00:19:48,240
the next so i just mentioned compaction

00:19:47,280 --> 00:19:51,039
tombstones

00:19:48,240 --> 00:19:52,400
now mem table so i know i mentioned men

00:19:51,039 --> 00:19:53,039
table already because you can't talk

00:19:52,400 --> 00:19:54,559
about the

00:19:53,039 --> 00:19:56,480
the right path or even the read path

00:19:54,559 --> 00:19:58,400
without mem table but they're you know

00:19:56,480 --> 00:20:02,320
in memory data structure

00:19:58,400 --> 00:20:04,960
um what you should keep in mind is that

00:20:02,320 --> 00:20:06,799
for every table you create in cassandra

00:20:04,960 --> 00:20:09,120
it creates a mem table

00:20:06,799 --> 00:20:10,559
and so if you think about best practices

00:20:09,120 --> 00:20:13,200
in cassandra data modeling

00:20:10,559 --> 00:20:14,320
is you're supposed to take your access

00:20:13,200 --> 00:20:16,320
patterns and then

00:20:14,320 --> 00:20:18,320
build your tables based on how you're

00:20:16,320 --> 00:20:22,320
filtering your data

00:20:18,320 --> 00:20:24,000
so if you're doing um

00:20:22,320 --> 00:20:26,240
let's say you have a table for account

00:20:24,000 --> 00:20:27,919
information and you want to you know

00:20:26,240 --> 00:20:29,360
filter by email by phone number or by

00:20:27,919 --> 00:20:31,440
account number right there's multiple

00:20:29,360 --> 00:20:33,440
ways of pulling information

00:20:31,440 --> 00:20:35,039
well you know best practices says you

00:20:33,440 --> 00:20:36,880
should actually have three different

00:20:35,039 --> 00:20:37,919
tables partitioned differently because

00:20:36,880 --> 00:20:40,640
then you're pulling based

00:20:37,919 --> 00:20:41,520
on the partition key but now you also

00:20:40,640 --> 00:20:43,200
you know

00:20:41,520 --> 00:20:45,120
you now have three mim tables for that

00:20:43,200 --> 00:20:49,039
one representation of data

00:20:45,120 --> 00:20:52,559
and i've seen customers who had hundreds

00:20:49,039 --> 00:20:55,200
hundreds of of tables in their cassandra

00:20:52,559 --> 00:20:55,919
cluster and it's you know it's the

00:20:55,200 --> 00:20:57,840
evolution

00:20:55,919 --> 00:20:59,760
of as your data model grows as your

00:20:57,840 --> 00:21:01,760
application grow as you start you

00:20:59,760 --> 00:21:03,200
using your cassandra clusters for more

00:21:01,760 --> 00:21:06,400
and more use cases

00:21:03,200 --> 00:21:08,720
you're going to end up with um

00:21:06,400 --> 00:21:10,720
with more more tables in cassandra which

00:21:08,720 --> 00:21:14,640
also means more mem table

00:21:10,720 --> 00:21:17,520
and so mem table takes a space in memory

00:21:14,640 --> 00:21:19,840
the default is a quarter of your heap is

00:21:17,520 --> 00:21:22,320
allocated towards your mem tables

00:21:19,840 --> 00:21:22,880
so keep that in mind and then of course

00:21:22,320 --> 00:21:25,120
you know

00:21:22,880 --> 00:21:26,960
when them tables get flushed onto disk

00:21:25,120 --> 00:21:27,679
uh it creates objects and it also

00:21:26,960 --> 00:21:29,919
triggers

00:21:27,679 --> 00:21:32,080
uh garbage collection so the more room

00:21:29,919 --> 00:21:34,480
tables you have the more the flush it is

00:21:32,080 --> 00:21:36,960
the more garbage collection you're going

00:21:34,480 --> 00:21:36,960
to occur

00:21:37,760 --> 00:21:40,880
and then the last topic is white

00:21:39,520 --> 00:21:44,240
partitions

00:21:40,880 --> 00:21:45,600
right you create your table you have

00:21:44,240 --> 00:21:47,520
your primary key

00:21:45,600 --> 00:21:49,600
your primary key is made up of your

00:21:47,520 --> 00:21:50,480
partition key and your clustering

00:21:49,600 --> 00:21:52,480
columns

00:21:50,480 --> 00:21:54,559
you know cassandra is a distributed

00:21:52,480 --> 00:21:56,480
hashmap it's based on that partition key

00:21:54,559 --> 00:21:59,120
i'll take that value hashes it

00:21:56,480 --> 00:21:59,919
and then it knows which data which which

00:21:59,120 --> 00:22:02,799
node

00:21:59,919 --> 00:22:05,679
uh has a copy of that data and then your

00:22:02,799 --> 00:22:08,400
clustering columns make that very unique

00:22:05,679 --> 00:22:09,440
so for example you're keeping track of

00:22:08,400 --> 00:22:13,760
market data

00:22:09,440 --> 00:22:16,720
so you might have a table that's

00:22:13,760 --> 00:22:17,600
market data by ticker symbol and so your

00:22:16,720 --> 00:22:19,200
partition key

00:22:17,600 --> 00:22:20,640
might be the ticker and then your

00:22:19,200 --> 00:22:21,440
clustering column might be the time

00:22:20,640 --> 00:22:23,919
stamp

00:22:21,440 --> 00:22:26,000
and you're collecting information let's

00:22:23,919 --> 00:22:28,159
say every second uh

00:22:26,000 --> 00:22:29,360
and then as you start collecting more

00:22:28,159 --> 00:22:32,080
and more data

00:22:29,360 --> 00:22:32,720
well that partition is unbounded right

00:22:32,080 --> 00:22:35,520
it can go

00:22:32,720 --> 00:22:37,440
infinitely big this is small you know

00:22:35,520 --> 00:22:39,200
it's just one one data set but

00:22:37,440 --> 00:22:40,720
you know in a more realistic use case

00:22:39,200 --> 00:22:42,720
you're going to have multiple columns

00:22:40,720 --> 00:22:46,159
and so it's a lot more data

00:22:42,720 --> 00:22:49,200
in your partition and so

00:22:46,159 --> 00:22:50,159
you know again when you're reading your

00:22:49,200 --> 00:22:51,360
partition

00:22:50,159 --> 00:22:52,720
you're going to be you know when you're

00:22:51,360 --> 00:22:53,440
reading your result set you're going to

00:22:52,720 --> 00:22:56,880
be reading that

00:22:53,440 --> 00:22:58,400
into memory best practice says what like

00:22:56,880 --> 00:23:00,559
100 meg

00:22:58,400 --> 00:23:02,799
i know with newer versions of cassandra

00:23:00,559 --> 00:23:06,080
especially adventure 3.6

00:23:02,799 --> 00:23:08,640
you can have wider partitions i

00:23:06,080 --> 00:23:10,320
don't know enough about uh 4.0 but maybe

00:23:08,640 --> 00:23:11,840
hopefully they've done something where

00:23:10,320 --> 00:23:13,520
you can have even wider partitions

00:23:11,840 --> 00:23:16,240
because i've seen like

00:23:13,520 --> 00:23:17,280
two gig partitions if not bigger at

00:23:16,240 --> 00:23:19,760
customers

00:23:17,280 --> 00:23:21,200
right so so think about that like right

00:23:19,760 --> 00:23:23,200
you're reading a partition

00:23:21,200 --> 00:23:24,240
and then you're reading your two gigs

00:23:23,200 --> 00:23:27,120
into memory

00:23:24,240 --> 00:23:29,919
you're creating all these objects and

00:23:27,120 --> 00:23:32,480
then you're creating garbage collection

00:23:29,919 --> 00:23:33,840
which impacts of course your performance

00:23:32,480 --> 00:23:37,440
and could actually

00:23:33,840 --> 00:23:39,840
trigger nodes to go offline

00:23:37,440 --> 00:23:41,120
and hopefully not cascading failure

00:23:39,840 --> 00:23:42,080
because you're not at that point yet

00:23:41,120 --> 00:23:43,840
because

00:23:42,080 --> 00:23:46,000
you're watching this presentation and

00:23:43,840 --> 00:23:48,799
you'll know what to do

00:23:46,000 --> 00:23:50,880
um so you know like it's not the end of

00:23:48,799 --> 00:23:54,000
the world like this is not

00:23:50,880 --> 00:23:55,279
um it's it's not that bad right there's

00:23:54,000 --> 00:23:57,200
there's ways you can

00:23:55,279 --> 00:23:59,120
uh address garbage collection in

00:23:57,200 --> 00:24:00,880
cassandra

00:23:59,120 --> 00:24:02,640
uh so let's go back to the first topic

00:24:00,880 --> 00:24:05,840
of compaction

00:24:02,640 --> 00:24:07,360
uh so first make sure

00:24:05,840 --> 00:24:09,600
you pick the right compaction strategy

00:24:07,360 --> 00:24:10,880
for your use case right default is size

00:24:09,600 --> 00:24:13,840
steer compaction

00:24:10,880 --> 00:24:16,080
if you have a a read heavy use case use

00:24:13,840 --> 00:24:18,799
level compaction you'll have

00:24:16,080 --> 00:24:19,760
bigger but fewer ss tables right and so

00:24:18,799 --> 00:24:21,600
you won't be

00:24:19,760 --> 00:24:23,440
compacting as much and so you won't be

00:24:21,600 --> 00:24:25,679
triggering garbage collection

00:24:23,440 --> 00:24:27,679
if you have time windows you know time

00:24:25,679 --> 00:24:30,720
series data where you're updating it

00:24:27,679 --> 00:24:32,080
on a ongoing rolling forward basis well

00:24:30,720 --> 00:24:32,559
you don't need to compact all the old

00:24:32,080 --> 00:24:34,880
data

00:24:32,559 --> 00:24:36,559
just compact what you need to right so

00:24:34,880 --> 00:24:38,159
that's also going to help with garbage

00:24:36,559 --> 00:24:42,400
collection

00:24:38,159 --> 00:24:44,080
and then tune it um

00:24:42,400 --> 00:24:45,600
change you know throttle your compaction

00:24:44,080 --> 00:24:47,440
stupid

00:24:45,600 --> 00:24:49,200
the number of concurrent compactors if

00:24:47,440 --> 00:24:52,400
you need to right there's

00:24:49,200 --> 00:24:55,039
uh you know a ton of lovers in cassandra

00:24:52,400 --> 00:24:58,320
so make sure you're using them if you're

00:24:55,039 --> 00:25:00,640
seeing issues with compaction

00:24:58,320 --> 00:25:02,240
uh you know i mentioned in the you know

00:25:00,640 --> 00:25:04,400
when i was talking about white partition

00:25:02,240 --> 00:25:05,520
that white partition also impacts

00:25:04,400 --> 00:25:07,919
compaction

00:25:05,520 --> 00:25:09,679
right so a lot of all these different

00:25:07,919 --> 00:25:10,320
components are all interrelated with

00:25:09,679 --> 00:25:12,320
cassandra

00:25:10,320 --> 00:25:14,240
so keep in mind what is your partition

00:25:12,320 --> 00:25:17,360
size make sure they don't grow

00:25:14,240 --> 00:25:20,880
too big and then the last one

00:25:17,360 --> 00:25:22,559
is uh i should put cautiously in bold

00:25:20,880 --> 00:25:26,799
and not in parentheses

00:25:22,559 --> 00:25:30,000
but increase your heap

00:25:26,799 --> 00:25:32,000
right but i say cautiously because

00:25:30,000 --> 00:25:34,000
the bigger your heap size depending on

00:25:32,000 --> 00:25:36,080
what garbage collector you're using

00:25:34,000 --> 00:25:37,919
uh the longer your stop the oil pauses

00:25:36,080 --> 00:25:41,039
could be right because

00:25:37,919 --> 00:25:43,039
especially if it's um if it's actually

00:25:41,039 --> 00:25:43,760
doing cardboard collection on the entire

00:25:43,039 --> 00:25:46,000
heap

00:25:43,760 --> 00:25:46,799
each time like some of the uh single

00:25:46,000 --> 00:25:49,120
generational

00:25:46,799 --> 00:25:50,559
garbage collectors uh it's gonna take

00:25:49,120 --> 00:25:54,240
more time to complete

00:25:50,559 --> 00:25:56,000
right it's also why like this is uh

00:25:54,240 --> 00:25:58,159
i took it from datastax website they

00:25:56,000 --> 00:26:00,240
have recommendation you know this is for

00:25:58,159 --> 00:26:01,200
uh cassandra 3 but they also have it for

00:26:00,240 --> 00:26:04,320
dse

00:26:01,200 --> 00:26:07,520
um cms we you know recommendation

00:26:04,320 --> 00:26:10,080
for smaller heap sizes g1 you know you

00:26:07,520 --> 00:26:12,880
can have a bigger heap size uh

00:26:10,080 --> 00:26:14,559
garbage collector like zing uh the heap

00:26:12,880 --> 00:26:15,840
size is actually not proportional to

00:26:14,559 --> 00:26:18,159
stop the world pauses

00:26:15,840 --> 00:26:18,880
so it can actually handle you know

00:26:18,159 --> 00:26:21,120
significantly

00:26:18,880 --> 00:26:22,320
like actually up to like 20 terabyte

00:26:21,120 --> 00:26:25,440
heap sizes

00:26:22,320 --> 00:26:28,080
so there you can increase it but

00:26:25,440 --> 00:26:28,640
but i mean make sure you're testing

00:26:28,080 --> 00:26:30,159
right

00:26:28,640 --> 00:26:32,640
uh make sure you don't just increase

00:26:30,159 --> 00:26:34,480
your heap size without paying attention

00:26:32,640 --> 00:26:35,760
to what else is going on in your

00:26:34,480 --> 00:26:37,200
environment

00:26:35,760 --> 00:26:40,080
and make sure when you're testing you're

00:26:37,200 --> 00:26:43,600
actually hitting garbage collection so

00:26:40,080 --> 00:26:43,600
you can see how long your pauses are

00:26:44,000 --> 00:26:50,320
so second topic was tombstone

00:26:47,200 --> 00:26:52,799
so um okay so sorry

00:26:50,320 --> 00:26:55,039
probably not the the most popular thing

00:26:52,799 --> 00:26:57,440
to say on a cassandra track but

00:26:55,039 --> 00:26:58,480
if your application is generating a lot

00:26:57,440 --> 00:27:00,000
of tombstones

00:26:58,480 --> 00:27:02,080
just just make sure that you're picking

00:27:00,000 --> 00:27:04,400
the right technology for your use case

00:27:02,080 --> 00:27:07,039
right there's no point in trying to fit

00:27:04,400 --> 00:27:08,880
you know a bad fit uh into a because

00:27:07,039 --> 00:27:09,760
crusader is like a great technology it's

00:27:08,880 --> 00:27:11,279
powerful

00:27:09,760 --> 00:27:12,640
uh but if you need you know let's say

00:27:11,279 --> 00:27:14,720
you need scalability and high

00:27:12,640 --> 00:27:17,039
availability and you are generating

00:27:14,720 --> 00:27:18,240
uh tombstones while there's things you

00:27:17,039 --> 00:27:21,200
can do

00:27:18,240 --> 00:27:22,480
uh so first of all check what is what is

00:27:21,200 --> 00:27:24,720
creating tombstones

00:27:22,480 --> 00:27:26,399
uh the most obvious is of course if you

00:27:24,720 --> 00:27:29,279
have delete statements

00:27:26,399 --> 00:27:29,760
but also if you have ttl right time to

00:27:29,279 --> 00:27:31,760
live

00:27:29,760 --> 00:27:34,720
on your table on your row on your

00:27:31,760 --> 00:27:38,000
partition it will create a tombstone

00:27:34,720 --> 00:27:39,440
uh also inserting nulls into columns

00:27:38,000 --> 00:27:41,440
right with cassandra

00:27:39,440 --> 00:27:42,880
uh you need to provide all the columns

00:27:41,440 --> 00:27:43,840
from your partition keys but the other

00:27:42,880 --> 00:27:45,440
columns

00:27:43,840 --> 00:27:46,799
it's efficient in terms of disk space

00:27:45,440 --> 00:27:47,679
right you don't have to insert nulls for

00:27:46,799 --> 00:27:51,360
those columns

00:27:47,679 --> 00:27:53,120
so you know make sure you're not

00:27:51,360 --> 00:27:54,559
inserting nulls for no reason

00:27:53,120 --> 00:27:57,039
and then also if you're using

00:27:54,559 --> 00:27:58,559
collections right um

00:27:57,039 --> 00:27:59,919
if you're inserting updating part of a

00:27:58,559 --> 00:28:02,080
collection you could actually be

00:27:59,919 --> 00:28:04,640
creating a tombstone as well so just

00:28:02,080 --> 00:28:04,640
keep in mind

00:28:04,720 --> 00:28:08,480
and then you know take a look at your

00:28:06,240 --> 00:28:10,960
queries

00:28:08,480 --> 00:28:12,000
technically i mean best practice you

00:28:10,960 --> 00:28:14,559
should be hitting

00:28:12,000 --> 00:28:15,279
a partition but i've seen a lot of

00:28:14,559 --> 00:28:17,039
customers

00:28:15,279 --> 00:28:18,480
people using let's say like a range

00:28:17,039 --> 00:28:21,760
where you're like an n right like a

00:28:18,480 --> 00:28:24,640
select columns from keyspace.table

00:28:21,760 --> 00:28:27,440
where your partition key is in and then

00:28:24,640 --> 00:28:31,120
list a whole bunch of columns right

00:28:27,440 --> 00:28:32,640
or allow filtering uh allow filtering is

00:28:31,120 --> 00:28:34,080
there to basically remind you that this

00:28:32,640 --> 00:28:35,520
is probably a bad idea

00:28:34,080 --> 00:28:37,360
at scale it'll probably work on your

00:28:35,520 --> 00:28:40,240
computer but not with

00:28:37,360 --> 00:28:44,000
uh in a production environment so just

00:28:40,240 --> 00:28:46,480
review your queries

00:28:44,000 --> 00:28:47,919
uh and then mmm tables and i just want

00:28:46,480 --> 00:28:50,799
to highlight that

00:28:47,919 --> 00:28:51,440
you know some of these recommendations

00:28:50,799 --> 00:28:53,919
are

00:28:51,440 --> 00:28:55,440
you know tuning your garbage collector

00:28:53,919 --> 00:28:57,600
uh increasing your heap

00:28:55,440 --> 00:28:59,600
but a lot of them are actually you know

00:28:57,600 --> 00:29:00,159
not even related to garbage collection

00:28:59,600 --> 00:29:01,919
per se

00:29:00,159 --> 00:29:03,919
but actually what creates garbage

00:29:01,919 --> 00:29:06,240
collection right so it's not just the

00:29:03,919 --> 00:29:09,360
garbage collector

00:29:06,240 --> 00:29:12,480
so rem table um

00:29:09,360 --> 00:29:14,000
right you can tune your mem table you

00:29:12,480 --> 00:29:15,840
don't have to use the default

00:29:14,000 --> 00:29:16,880
one-quarter heap space for your rim

00:29:15,840 --> 00:29:18,399
table if you

00:29:16,880 --> 00:29:20,399
using a garbage collector where you can

00:29:18,399 --> 00:29:23,440
have a larger heap then

00:29:20,399 --> 00:29:24,480
you know give more heat size space to

00:29:23,440 --> 00:29:27,279
your mem table

00:29:24,480 --> 00:29:28,480
and it will let you have more cassandra

00:29:27,279 --> 00:29:31,279
table

00:29:28,480 --> 00:29:33,120
uh it's maybe more of a band-aid than a

00:29:31,279 --> 00:29:36,159
you know best approach but

00:29:33,120 --> 00:29:38,559
you know there's real life too right

00:29:36,159 --> 00:29:40,559
uh you can specify some of your tables

00:29:38,559 --> 00:29:43,600
to be off-heap for example

00:29:40,559 --> 00:29:45,200
if you're storing blobs you know large

00:29:43,600 --> 00:29:47,200
text fields

00:29:45,200 --> 00:29:48,559
probably not what you really want to do

00:29:47,200 --> 00:29:49,840
in cassandra you probably want to store

00:29:48,559 --> 00:29:51,120
that somewhere else and then have it

00:29:49,840 --> 00:29:54,320
pointed to it

00:29:51,120 --> 00:29:57,200
but that could be a use case for

00:29:54,320 --> 00:29:57,200
off-heat table

00:29:57,760 --> 00:30:01,279
and then you know maybe separate your

00:29:59,760 --> 00:30:04,159
cluster right

00:30:01,279 --> 00:30:05,600
i've seen that where as your cluster

00:30:04,159 --> 00:30:06,559
grows and you start adding more and more

00:30:05,600 --> 00:30:08,960
tables

00:30:06,559 --> 00:30:10,240
you'll see that normally you don't need

00:30:08,960 --> 00:30:11,120
all these tables to be part of the same

00:30:10,240 --> 00:30:13,039
cluster

00:30:11,120 --> 00:30:14,880
but there are different workloads you

00:30:13,039 --> 00:30:18,000
know maybe some of them are

00:30:14,880 --> 00:30:18,960
you know heavy early morning data loads

00:30:18,000 --> 00:30:22,559
versus

00:30:18,960 --> 00:30:24,960
uh hourly audit query

00:30:22,559 --> 00:30:26,399
jobs right and so also in your query

00:30:24,960 --> 00:30:29,120
your audit job's going to fail

00:30:26,399 --> 00:30:30,960
because it's in the middle of that heavy

00:30:29,120 --> 00:30:34,720
unusually heavy morning

00:30:30,960 --> 00:30:37,760
load and that could also be a good

00:30:34,720 --> 00:30:40,000
a good fit for separating your cluster

00:30:37,760 --> 00:30:40,799
and then i mean i guess you can't go

00:30:40,000 --> 00:30:42,799
wrong with

00:30:40,799 --> 00:30:46,080
increasing your heat size again the

00:30:42,799 --> 00:30:46,080
caveats of

00:30:46,960 --> 00:30:54,240
do it cautiously so

00:30:50,399 --> 00:30:58,159
compaction tombstones um table

00:30:54,240 --> 00:31:01,600
wide partition uh so i know it's easy

00:30:58,159 --> 00:31:03,519
for anybody to just tell you hey

00:31:01,600 --> 00:31:05,919
take a look at your data model you might

00:31:03,519 --> 00:31:08,799
want to create a different table

00:31:05,919 --> 00:31:10,720
have a smaller partition you know

00:31:08,799 --> 00:31:11,440
realistically i know you have terabytes

00:31:10,720 --> 00:31:14,399
of data

00:31:11,440 --> 00:31:15,919
you have application production you the

00:31:14,399 --> 00:31:16,399
amount of regression testing it's going

00:31:15,919 --> 00:31:18,399
to take

00:31:16,399 --> 00:31:19,519
it's it's not as simple as just saying

00:31:18,399 --> 00:31:22,559
hey change your

00:31:19,519 --> 00:31:25,919
your partition key but

00:31:22,559 --> 00:31:27,440
um you know unfortunately if you have a

00:31:25,919 --> 00:31:29,440
really wide partition

00:31:27,440 --> 00:31:30,559
uh you know maybe the partition was

00:31:29,440 --> 00:31:33,600
correct in the beginning

00:31:30,559 --> 00:31:34,960
right and then your use case evolved you

00:31:33,600 --> 00:31:36,320
let's say you you had a huge client

00:31:34,960 --> 00:31:37,679
let's say amazon decides to be one of

00:31:36,320 --> 00:31:40,960
your client and next thing you know

00:31:37,679 --> 00:31:43,120
it blows through your partition right so

00:31:40,960 --> 00:31:44,880
review your your partition and your data

00:31:43,120 --> 00:31:48,240
model

00:31:44,880 --> 00:31:50,559
um another one is upgrade cassandra

00:31:48,240 --> 00:31:51,600
and so i i you know i put in here in

00:31:50,559 --> 00:31:53,440
white partition because there's

00:31:51,600 --> 00:31:55,679
definitely been significant improvements

00:31:53,440 --> 00:31:56,880
in in partition sizes with later

00:31:55,679 --> 00:32:00,000
versions of cassandra

00:31:56,880 --> 00:32:03,039
but that's true across all the other

00:32:00,000 --> 00:32:04,799
you know compaction and mm table usage

00:32:03,039 --> 00:32:07,279
and everything else in cassandra

00:32:04,799 --> 00:32:08,080
so usually later versions of cassandra

00:32:07,279 --> 00:32:10,159
you know if you're

00:32:08,080 --> 00:32:14,240
still on a 2.2 version you might want to

00:32:10,159 --> 00:32:16,320
get to at least a three three eleven

00:32:14,240 --> 00:32:17,760
and then of course increase your heap

00:32:16,320 --> 00:32:20,559
size that's always

00:32:17,760 --> 00:32:21,679
um will let you you know ultimately you

00:32:20,559 --> 00:32:24,320
can actually

00:32:21,679 --> 00:32:26,080
have wider rows inhabit them into memory

00:32:24,320 --> 00:32:28,480
it'll help with compaction

00:32:26,080 --> 00:32:30,399
but then you might experience longer

00:32:28,480 --> 00:32:33,679
pauses so

00:32:30,399 --> 00:32:36,720
grain of salt uh and then you know

00:32:33,679 --> 00:32:39,200
the fifth a recommendation or

00:32:36,720 --> 00:32:40,480
option is there's a lot of garbage

00:32:39,200 --> 00:32:44,640
collectors out there now

00:32:40,480 --> 00:32:48,559
right before it was cms g1

00:32:44,640 --> 00:32:52,640
now you also have shenandoah zgc

00:32:48,559 --> 00:32:55,120
zing so take a look at different garbage

00:32:52,640 --> 00:32:58,640
collectors

00:32:55,120 --> 00:32:59,840
which one is the right one uh

00:32:58,640 --> 00:33:02,720
people are probably not going to start

00:32:59,840 --> 00:33:04,399
switching to cms uh

00:33:02,720 --> 00:33:06,240
because it took a lot of time and

00:33:04,399 --> 00:33:07,679
resources to tune

00:33:06,240 --> 00:33:09,440
do you really want to be spending that

00:33:07,679 --> 00:33:10,240
time tuning your garbage collector when

00:33:09,440 --> 00:33:11,840
you could be doing

00:33:10,240 --> 00:33:13,279
something maybe a little bit more

00:33:11,840 --> 00:33:15,919
interesting

00:33:13,279 --> 00:33:17,919
um different garbage collectors you know

00:33:15,919 --> 00:33:20,960
whether they're single generation

00:33:17,919 --> 00:33:22,159
uh generational uh they handle the way

00:33:20,960 --> 00:33:25,200
they clean up memory

00:33:22,159 --> 00:33:25,679
they do it differently right so some can

00:33:25,200 --> 00:33:28,960
handle

00:33:25,679 --> 00:33:32,559
larger heaps without actually impacting

00:33:28,960 --> 00:33:35,120
stuff the world pauses um

00:33:32,559 --> 00:33:35,760
when i say you know go to the latest

00:33:35,120 --> 00:33:38,000
release

00:33:35,760 --> 00:33:38,960
i am not saying hey go from java e to

00:33:38,000 --> 00:33:41,279
java 11.

00:33:38,960 --> 00:33:42,559
i mean that's that's a huge change but

00:33:41,279 --> 00:33:45,760
if you're on java 8

00:33:42,559 --> 00:33:47,440
get to the latest version of java 8

00:33:45,760 --> 00:33:49,120
for one the most obvious reason of

00:33:47,440 --> 00:33:51,600
security but then

00:33:49,120 --> 00:33:52,880
also there's performance improvement in

00:33:51,600 --> 00:33:56,080
all these versions

00:33:52,880 --> 00:33:57,440
of java so you'll get

00:33:56,080 --> 00:34:00,159
performance improvements just by

00:33:57,440 --> 00:34:02,320
upgrading your garbage collector

00:34:00,159 --> 00:34:03,200
and then you know think about i know

00:34:02,320 --> 00:34:06,000
everybody wants

00:34:03,200 --> 00:34:07,279
you know little anc and fast rupert uh

00:34:06,000 --> 00:34:08,240
something sometimes a little bit of a

00:34:07,279 --> 00:34:10,800
trade-off

00:34:08,240 --> 00:34:11,760
so something like maybe like shenandoah

00:34:10,800 --> 00:34:14,159
cgc

00:34:11,760 --> 00:34:15,280
a single generation might be great for

00:34:14,159 --> 00:34:18,240
latency

00:34:15,280 --> 00:34:18,960
uh cms is you know great for throughput

00:34:18,240 --> 00:34:21,280
uh

00:34:18,960 --> 00:34:22,560
zheng is you know actually can handle

00:34:21,280 --> 00:34:26,159
the in cnp

00:34:22,560 --> 00:34:28,480
uh fairly well and so does g1

00:34:26,159 --> 00:34:30,399
so you know so something something to

00:34:28,480 --> 00:34:35,119
think about

00:34:30,399 --> 00:34:37,280
and then test long enough i mean um

00:34:35,119 --> 00:34:39,679
don't just test for five minutes right

00:34:37,280 --> 00:34:41,760
don't just do cassandra stress

00:34:39,679 --> 00:34:42,800
write a million record and it's over in

00:34:41,760 --> 00:34:45,919
like a minute

00:34:42,800 --> 00:34:47,440
maybe even less than that in production

00:34:45,919 --> 00:34:49,760
cassandra is going to be running for a

00:34:47,440 --> 00:34:51,440
long time

00:34:49,760 --> 00:34:53,200
test your system like you would in

00:34:51,440 --> 00:34:54,879
production especially if you're testing

00:34:53,200 --> 00:34:57,040
a different garbage collector

00:34:54,879 --> 00:34:59,440
you wanted to go through several rounds

00:34:57,040 --> 00:35:02,720
of gc cycles

00:34:59,440 --> 00:35:04,640
also you know most java applications

00:35:02,720 --> 00:35:07,760
take a little bit of time for warm-up

00:35:04,640 --> 00:35:10,160
right um your first couple of

00:35:07,760 --> 00:35:10,960
writes won't be as fast as your

00:35:10,160 --> 00:35:12,560
thousandth

00:35:10,960 --> 00:35:14,240
write with java if you had just

00:35:12,560 --> 00:35:16,000
restarted your center note

00:35:14,240 --> 00:35:17,920
so keep that in mind maybe when you're

00:35:16,000 --> 00:35:18,800
doing you know benchmarking performance

00:35:17,920 --> 00:35:20,960
testing

00:35:18,800 --> 00:35:22,960
uh you know forget the first few minutes

00:35:20,960 --> 00:35:25,680
unless warm-up is important for you

00:35:22,960 --> 00:35:27,680
um but you know ultimately you should

00:35:25,680 --> 00:35:29,839
have cassandra running ideally

00:35:27,680 --> 00:35:31,040
a long time and so make sure you're

00:35:29,839 --> 00:35:34,320
running cassandra

00:35:31,040 --> 00:35:34,320
and your test long enough

00:35:34,560 --> 00:35:38,960
um and then let me leave you with some

00:35:36,640 --> 00:35:42,160
final thoughts

00:35:38,960 --> 00:35:44,960
so one is you know i went through

00:35:42,160 --> 00:35:46,480
uh there's a lot of tuning you can do

00:35:44,960 --> 00:35:47,839
whether it's for compaction from em

00:35:46,480 --> 00:35:50,240
tables right

00:35:47,839 --> 00:35:51,119
uh and i mean these are just two very

00:35:50,240 --> 00:35:53,280
specific

00:35:51,119 --> 00:35:55,520
uh but there's a lot more tuning you can

00:35:53,280 --> 00:35:55,520
do

00:35:55,680 --> 00:35:59,040
um and then also not just to for your

00:35:57,599 --> 00:36:02,079
current work like for your

00:35:59,040 --> 00:36:03,440
initial workload but also keep tuning as

00:36:02,079 --> 00:36:06,800
your workload

00:36:03,440 --> 00:36:09,839
changes as your your use case changes

00:36:06,800 --> 00:36:11,599
evolves as your data gets bigger

00:36:09,839 --> 00:36:13,440
um okay so i had to stick this one in

00:36:11,599 --> 00:36:14,079
there too increase your heat size i feel

00:36:13,440 --> 00:36:17,040
like

00:36:14,079 --> 00:36:17,359
um it's it's not a band-aid because it

00:36:17,040 --> 00:36:18,880
is

00:36:17,359 --> 00:36:20,560
you know sometimes having a bigger heap

00:36:18,880 --> 00:36:21,680
actually helps um

00:36:20,560 --> 00:36:23,280
just make sure that when you're

00:36:21,680 --> 00:36:23,680
increasing your heat size again you're

00:36:23,280 --> 00:36:26,079
not

00:36:23,680 --> 00:36:27,040
impacting your stop the world pauses

00:36:26,079 --> 00:36:30,079
especially like

00:36:27,040 --> 00:36:31,040
especially with g1 um also something to

00:36:30,079 --> 00:36:33,440
think about is

00:36:31,040 --> 00:36:34,800
you know you might want to stay at 31

00:36:33,440 --> 00:36:37,040
gig heat

00:36:34,800 --> 00:36:38,240
because of 32 you're gonna hit

00:36:37,040 --> 00:36:41,839
compressed oops

00:36:38,240 --> 00:36:44,000
um so just something to keep in mind

00:36:41,839 --> 00:36:44,960
um i mentioned you know tests long

00:36:44,000 --> 00:36:47,119
enough with

00:36:44,960 --> 00:36:48,880
garbage collectors well you know same

00:36:47,119 --> 00:36:52,320
thing with cassandra

00:36:48,880 --> 00:36:53,280
and um i mean you're especially your

00:36:52,320 --> 00:36:54,400
data model right

00:36:53,280 --> 00:36:56,079
you're not going to know if you have a

00:36:54,400 --> 00:36:56,880
white partition until you start

00:36:56,079 --> 00:36:59,680
ingesting

00:36:56,880 --> 00:37:01,760
real real world data you're not going to

00:36:59,680 --> 00:37:03,520
know if you're creating tombstones until

00:37:01,760 --> 00:37:04,800
you start going through your application

00:37:03,520 --> 00:37:06,480
regular cycles

00:37:04,800 --> 00:37:08,480
uh you're not going to know if maybe you

00:37:06,480 --> 00:37:10,079
should change your gc grade second

00:37:08,480 --> 00:37:13,119
period because you need to evict your

00:37:10,079 --> 00:37:15,680
tombstones faster

00:37:13,119 --> 00:37:16,160
and run it you know run it for a few

00:37:15,680 --> 00:37:18,400
hours

00:37:16,160 --> 00:37:19,599
make sure compaction is running make

00:37:18,400 --> 00:37:21,200
sure you're trading

00:37:19,599 --> 00:37:23,040
garbage collection and make sure you're

00:37:21,200 --> 00:37:24,720
going through you know hopefully you

00:37:23,040 --> 00:37:28,320
have repair services turned on right

00:37:24,720 --> 00:37:28,320
make sure your repairs are running

00:37:29,119 --> 00:37:33,440
continuously monitor your your

00:37:32,000 --> 00:37:36,000
environment

00:37:33,440 --> 00:37:38,320
take a look at you know cassandra system

00:37:36,000 --> 00:37:40,320
long but then also take a look look at

00:37:38,320 --> 00:37:43,280
your gc log right you can

00:37:40,320 --> 00:37:44,880
set your uh one of your jvm plugs to

00:37:43,280 --> 00:37:45,920
actually write to a gc log and then

00:37:44,880 --> 00:37:48,320
monitor your log

00:37:45,920 --> 00:37:49,280
right take a look to see how often

00:37:48,320 --> 00:37:51,599
you're doing

00:37:49,280 --> 00:37:52,720
garbage collection how long is it taking

00:37:51,599 --> 00:37:55,920
is there any

00:37:52,720 --> 00:37:59,200
um the optimization happening just

00:37:55,920 --> 00:38:00,240
monitor your environment and then uh the

00:37:59,200 --> 00:38:01,839
last one is

00:38:00,240 --> 00:38:04,000
you know as i mentioned there's

00:38:01,839 --> 00:38:07,520
different garbage collectors out there

00:38:04,000 --> 00:38:11,200
uh yeah shenandoah cgc

00:38:07,520 --> 00:38:13,839
they're they're ga right so uh

00:38:11,200 --> 00:38:15,200
i think shenandoah was released in java

00:38:13,839 --> 00:38:18,480
12 and they got back

00:38:15,200 --> 00:38:22,400
to java 8 and java 11. zgc

00:38:18,480 --> 00:38:25,760
is in java 15. so it's a linear but

00:38:22,400 --> 00:38:26,800
um you know take a look zang has been

00:38:25,760 --> 00:38:30,000
around since

00:38:26,800 --> 00:38:33,920
java 7. cms has been around forever

00:38:30,000 --> 00:38:37,680
clearly and so has juwon um

00:38:33,920 --> 00:38:37,680
so you have options

00:38:38,240 --> 00:38:42,560
and that's all i have

00:38:44,839 --> 00:38:49,920
um

00:38:46,720 --> 00:38:51,359
let me see what other questions uh which

00:38:49,920 --> 00:38:53,520
coverage collection are suitable for

00:38:51,359 --> 00:38:57,839
particular workloads

00:38:53,520 --> 00:39:00,640
um so you know it's

00:38:57,839 --> 00:39:01,280
it's actually really gonna depend of you

00:39:00,640 --> 00:39:04,720
know

00:39:01,280 --> 00:39:08,240
are you uh really

00:39:04,720 --> 00:39:09,760
um like are you conscious about latency

00:39:08,240 --> 00:39:11,200
and you can have slightly lower

00:39:09,760 --> 00:39:12,880
throughput then you know maybe take a

00:39:11,200 --> 00:39:14,960
look at shenandoah

00:39:12,880 --> 00:39:16,079
uh i'm not a data science anymore so i'm

00:39:14,960 --> 00:39:18,880
totally not plugging it

00:39:16,079 --> 00:39:20,320
but uh they just did a benchmark that

00:39:18,880 --> 00:39:22,079
was kind of interesting about

00:39:20,320 --> 00:39:23,839
it was actually very interesting because

00:39:22,079 --> 00:39:26,560
it also compares

00:39:23,839 --> 00:39:27,760
cassandra 311 with the center 4.0 and

00:39:26,560 --> 00:39:29,200
then different garbage collectors and

00:39:27,760 --> 00:39:32,079
different java versions

00:39:29,200 --> 00:39:33,440
right and so um take a look at their

00:39:32,079 --> 00:39:35,599
their results they can

00:39:33,440 --> 00:39:36,880
they show both uh what's the fastest

00:39:35,599 --> 00:39:37,920
throughput they got with the different

00:39:36,880 --> 00:39:40,000
garbage collectors

00:39:37,920 --> 00:39:41,440
as well as what was the lane the best

00:39:40,000 --> 00:39:45,280
latency they got

00:39:41,440 --> 00:39:48,640
some cool

00:39:45,280 --> 00:39:52,320
um i think i'm out of time

00:39:48,640 --> 00:39:57,839
but uh yeah thanks a lot

00:39:52,320 --> 00:39:57,839
hope uh hope it was helpful

00:41:46,640 --> 00:41:48,720

YouTube URL: https://www.youtube.com/watch?v=w0GFGu-8aXE


