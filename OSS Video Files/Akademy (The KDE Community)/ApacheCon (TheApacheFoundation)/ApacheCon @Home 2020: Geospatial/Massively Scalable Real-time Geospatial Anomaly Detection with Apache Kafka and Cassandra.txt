Title: Massively Scalable Real-time Geospatial Anomaly Detection with Apache Kafka and Cassandra
Publication date: 2020-10-22
Playlist: ApacheCon @Home 2020: Geospatial
Description: 
	Massively Scalable Real-time Geospatial Anomaly Detection with Apache Kafka and Cassandra
Paul Brebner

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

This presentation will explore how we added location data to a scalable real-time anomaly detection application, built around Apache Kafka, and Cassandra. Kafka and Cassandra are designed for time-series data, however, it’s not so obvious how they can efficiently process spatiotemporal data (space and time). In order to find location-specific anomalies, we need ways to represent locations, to index locations, and to query locations. We explore alternative geospatial representations including: Latitude/Longitude points, Bounding Boxes, Geohashes, and go vertical with 3D representations, including 3D Geohashes. For each representation we also explore possible Cassandra implementations including: Clustering columns, Secondary indexes, Denormalized tables, and the Cassandra Lucene Index Plugin. To conclude we measure and compare the query throughput of some of the solutions, and summarise the results in terms of accuracy vs. performance to answer the question “Which geospatial data representation and Cassandra implementation is best?”

Since learning to program on a VAX 11/780, Paul has extensive R&D and consulting experience in distributed systems, technology innovation, software architecture and engineering, software performance and scalability, grid and cloud computing, and data analytics and machine learning. Paul is the Technology Evangelist at Instaclustr. He’s been learning new scalable technologies, solving realistic problems and building applications, and blogging about Apache Cassandra, Spark, Zeppelin, Kafka, and Elasticsearch. Paul has worked at UNSW, several tech start-ups, CSIRO, UCL (London, UK), & NICTA. Paul has helped solve significant software architecture and performance problems for clients including Defence and NBN Co. Paul has an MSc in Machine Learning and a BSc (Computer Science and Philosophy).
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:24,080 --> 00:00:28,160
to be

00:00:24,800 --> 00:00:29,760
where everyone's watching from um

00:00:28,160 --> 00:00:31,760
so this talk is called massively

00:00:29,760 --> 00:00:33,520
scalable real-time geospatial data

00:00:31,760 --> 00:00:34,719
processing with apache kafka and

00:00:33,520 --> 00:00:36,880
cassandra

00:00:34,719 --> 00:00:38,399
uh and thanks for accepting it in the

00:00:36,880 --> 00:00:40,079
geospatial track i think this is the

00:00:38,399 --> 00:00:41,840
first time i've spoken at an apache

00:00:40,079 --> 00:00:44,239
country a spatial track

00:00:41,840 --> 00:00:46,719
um i've talked at a few other tracks uh

00:00:44,239 --> 00:00:46,719
last year

00:00:47,039 --> 00:00:51,360
that's it's always interesting at apache

00:00:48,800 --> 00:00:53,680
con i tend to jump around between tracks

00:00:51,360 --> 00:00:55,199
because i follow whatever is interesting

00:00:53,680 --> 00:00:56,079
so hopefully this talks interesting for

00:00:55,199 --> 00:00:57,760
you guys

00:00:56,079 --> 00:00:59,760
um i'm poor bret breton i'm actually a

00:00:57,760 --> 00:01:03,039
technology evangelist

00:00:59,760 --> 00:01:04,559
at insta cluster um in my previous life

00:01:03,039 --> 00:01:06,640
i used to be a computer scientist i

00:01:04,559 --> 00:01:07,119
worked for csiro and nicktor and a few

00:01:06,640 --> 00:01:10,240
other

00:01:07,119 --> 00:01:12,720
university-based organizations um

00:01:10,240 --> 00:01:14,799
and i have had some contact with the ogc

00:01:12,720 --> 00:01:16,400
technologies and standards

00:01:14,799 --> 00:01:18,240
um but that was quite a long time ago so

00:01:16,400 --> 00:01:20,320
this is my first attempt at been doing

00:01:18,240 --> 00:01:22,080
anything geospatial for about 15 years

00:01:20,320 --> 00:01:24,000
so i hope it's um

00:01:22,080 --> 00:01:26,640
interesting for you guys and sort of the

00:01:24,000 --> 00:01:28,560
right right level

00:01:26,640 --> 00:01:31,040
it was more or less about my experiences

00:01:28,560 --> 00:01:32,960
trying to add some geospatial

00:01:31,040 --> 00:01:35,200
aspects to a system that i had already

00:01:32,960 --> 00:01:37,040
built so let's go

00:01:35,200 --> 00:01:40,240
insta cluster is a company founded in

00:01:37,040 --> 00:01:41,280
canberra about seven years ago we've got

00:01:40,240 --> 00:01:43,360
most of our

00:01:41,280 --> 00:01:45,280
development staff here still but we do

00:01:43,360 --> 00:01:46,640
have quite a lot of people

00:01:45,280 --> 00:01:48,640
around the world and we're all about

00:01:46,640 --> 00:01:51,040
reliability at scale

00:01:48,640 --> 00:01:53,280
um we basically provide a managed

00:01:51,040 --> 00:01:54,960
service on cloud platforms for

00:01:53,280 --> 00:01:56,799
a whole bunch of open source software

00:01:54,960 --> 00:01:59,920
including cassandra and kafka which

00:01:56,799 --> 00:02:02,880
is the focus of today's talk and some

00:01:59,920 --> 00:02:08,080
new offerings include elasticsearch

00:02:02,880 --> 00:02:11,599
and redis and an old favorite is spark

00:02:08,080 --> 00:02:14,160
so this talks basically

00:02:11,599 --> 00:02:14,720
uh as follows um briefly we're going to

00:02:14,160 --> 00:02:17,760
have a look

00:02:14,720 --> 00:02:20,400
at a location in the news this year

00:02:17,760 --> 00:02:22,640
um have a look at the anonymity

00:02:20,400 --> 00:02:25,680
detection application

00:02:22,640 --> 00:02:27,040
and the baseline throughput we'll add

00:02:25,680 --> 00:02:28,959
some

00:02:27,040 --> 00:02:31,760
spatial data to that to turn it into a

00:02:28,959 --> 00:02:33,920
spatial and long-lead affection problem

00:02:31,760 --> 00:02:35,200
and then the bulk of the talk is really

00:02:33,920 --> 00:02:37,920
looking at some

00:02:35,200 --> 00:02:39,599
different solutions that i tried some of

00:02:37,920 --> 00:02:41,280
which

00:02:39,599 --> 00:02:43,360
were pretty bad and others which were a

00:02:41,280 --> 00:02:45,040
lot better but basically how did we add

00:02:43,360 --> 00:02:47,200
location

00:02:45,040 --> 00:02:48,400
for the querying and indexing part of

00:02:47,200 --> 00:02:49,920
the application

00:02:48,400 --> 00:02:53,280
and there's a whole bunch of alternative

00:02:49,920 --> 00:02:53,280
options that we'll have a look at there

00:02:53,519 --> 00:02:57,920
so in the news this year unfortunately

00:02:55,360 --> 00:03:00,720
the famous computer scientist

00:02:57,920 --> 00:03:01,920
john conwy passed away what was he fans

00:03:00,720 --> 00:03:04,159
for were lots of things

00:03:01,920 --> 00:03:05,599
but probably what he's best known for is

00:03:04,159 --> 00:03:07,920
the game of life

00:03:05,599 --> 00:03:10,000
so this is a cellular automata now the

00:03:07,920 --> 00:03:12,319
the next state for each cell depends

00:03:10,000 --> 00:03:14,400
entirely on the state of the immediate

00:03:12,319 --> 00:03:17,599
neighbors so that's a very uh

00:03:14,400 --> 00:03:19,200
locality based problem it's got very

00:03:17,599 --> 00:03:19,920
simple rules but you can end up with

00:03:19,200 --> 00:03:23,519
some

00:03:19,920 --> 00:03:23,519
quite complex patterns

00:03:24,000 --> 00:03:27,680
also in the news unfortunately of course

00:03:25,680 --> 00:03:30,080
with the pandemic

00:03:27,680 --> 00:03:32,319
this fellow here is demonstrating uncle

00:03:30,080 --> 00:03:34,480
ron's social distancing 3000

00:03:32,319 --> 00:03:36,560
invention that's a good example of new

00:03:34,480 --> 00:03:37,760
zealand ingenuity

00:03:36,560 --> 00:03:40,560
other countries have tried something a

00:03:37,760 --> 00:03:42,799
bit more sophisticated including lots of

00:03:40,560 --> 00:03:46,959
different

00:03:42,799 --> 00:03:49,760
tracing applications which all of course

00:03:46,959 --> 00:03:52,319
rely on either proximity or actual

00:03:49,760 --> 00:03:54,400
absolute location information to work

00:03:52,319 --> 00:03:55,920
uh probably something that people have

00:03:54,400 --> 00:03:57,519
forgotten about now but we almost all

00:03:55,920 --> 00:04:01,519
got wiped out by a planet

00:03:57,519 --> 00:04:03,439
killer asteroid which only dismissed us

00:04:01,519 --> 00:04:05,760
earlier in the year so location does

00:04:03,439 --> 00:04:05,760
matter

00:04:06,159 --> 00:04:10,319
so this time last year i was giving some

00:04:08,000 --> 00:04:11,760
talks at apachecon in the us and then

00:04:10,319 --> 00:04:14,080
later in berlin

00:04:11,760 --> 00:04:16,160
the title of that talk was kafka sandra

00:04:14,080 --> 00:04:18,639
and kubernetes at scale

00:04:16,160 --> 00:04:19,440
real time anonymity detection on 20

00:04:18,639 --> 00:04:22,800
billion

00:04:19,440 --> 00:04:24,000
events a day so this talk is basically

00:04:22,800 --> 00:04:28,000
an extension

00:04:24,000 --> 00:04:29,680
of that one so anonymity detection what

00:04:28,000 --> 00:04:32,400
was the problem well essentially i built

00:04:29,680 --> 00:04:34,080
a system to spot the difference at speed

00:04:32,400 --> 00:04:35,759
uh so it was real time we wanted to

00:04:34,080 --> 00:04:39,040
detect um if there was

00:04:35,759 --> 00:04:40,880
an anomaly in under one second and scale

00:04:39,040 --> 00:04:43,919
so it had to be very high throughput

00:04:40,880 --> 00:04:46,880
with lots of data and highly scalable

00:04:43,919 --> 00:04:48,400
it's a very simple algorithm that we use

00:04:46,880 --> 00:04:50,639
we wanted to emphasize the

00:04:48,400 --> 00:04:52,080
the data layer rather than the

00:04:50,639 --> 00:04:54,479
processing layer um

00:04:52,080 --> 00:04:55,360
there's a cumulative sum control chart

00:04:54,479 --> 00:04:58,720
so technically

00:04:55,360 --> 00:04:59,600
actually dating back to the 60s uh uses

00:04:58,720 --> 00:05:02,880
statistical

00:04:59,600 --> 00:05:06,240
analysis of historical data the data is

00:05:02,880 --> 00:05:08,320
for a single variable or key at a time

00:05:06,240 --> 00:05:11,360
which makes it highly efficient uh but

00:05:08,320 --> 00:05:13,120
there are potentially billions of keys

00:05:11,360 --> 00:05:14,639
so for every new event coming in you

00:05:13,120 --> 00:05:16,639
have to look at previous events

00:05:14,639 --> 00:05:18,479
and make a decision about whether the

00:05:16,639 --> 00:05:20,320
new one

00:05:18,479 --> 00:05:22,639
is significantly different to the old

00:05:20,320 --> 00:05:22,639
ones

00:05:22,960 --> 00:05:26,880
um the application that i built used

00:05:25,039 --> 00:05:29,600
kafka cassandra and

00:05:26,880 --> 00:05:31,360
kubernetes clusters kafka handles the

00:05:29,600 --> 00:05:33,280
streaming sort of the wheelton part

00:05:31,360 --> 00:05:34,639
cassandra ice for the data storage and

00:05:33,280 --> 00:05:38,240
cabin that is

00:05:34,639 --> 00:05:40,479
coped with the application scaling

00:05:38,240 --> 00:05:41,759
cassandra is very efficient for writes

00:05:40,479 --> 00:05:44,960
and reads

00:05:41,759 --> 00:05:45,759
with a simple key and i used a unique

00:05:44,960 --> 00:05:49,120
account id

00:05:45,759 --> 00:05:52,400
or something similar to that for an

00:05:49,120 --> 00:05:55,199
application domain

00:05:52,400 --> 00:05:56,639
the events are time series um so for

00:05:55,199 --> 00:05:58,479
cassandra it's very important to get the

00:05:56,639 --> 00:05:59,919
data model right i'm not a cassandra

00:05:58,479 --> 00:06:03,120
data model expert so i

00:05:59,919 --> 00:06:05,440
i did have to um make a few false starts

00:06:03,120 --> 00:06:07,039
to get this all working

00:06:05,440 --> 00:06:09,680
but for this problem the events are

00:06:07,039 --> 00:06:12,000
pretty obviously time series

00:06:09,680 --> 00:06:14,400
the id is a petition key in the

00:06:12,000 --> 00:06:16,400
cassandra terminology and time

00:06:14,400 --> 00:06:17,600
is the clustering key which is of the

00:06:16,400 --> 00:06:20,720
ordering part of the

00:06:17,600 --> 00:06:23,120
information um for every read of

00:06:20,720 --> 00:06:25,039
cassandra we get the most 50

00:06:23,120 --> 00:06:26,800
recent values for the idea it's very

00:06:25,039 --> 00:06:29,759
fast to be able to do that

00:06:26,800 --> 00:06:31,600
so here's an example of the um the table

00:06:29,759 --> 00:06:33,120
that we created in cassandra to support

00:06:31,600 --> 00:06:36,960
this

00:06:33,120 --> 00:06:40,000
and the query to get the 50 values back

00:06:36,960 --> 00:06:40,000
for a particular id

00:06:40,479 --> 00:06:44,160
um i thought it was interesting just to

00:06:42,720 --> 00:06:46,639
see how big the final

00:06:44,160 --> 00:06:48,080
setup was uh the previous talk went into

00:06:46,639 --> 00:06:50,080
a lot more detail about how we actually

00:06:48,080 --> 00:06:52,800
scaled it up from a very small

00:06:50,080 --> 00:06:54,319
system up to sort of an arbitrary size

00:06:52,800 --> 00:06:55,520
and this is where we stopped we could

00:06:54,319 --> 00:06:59,199
have kept on going

00:06:55,520 --> 00:07:01,120
but we used um 574 cores in total on

00:06:59,199 --> 00:07:03,840
running on aws

00:07:01,120 --> 00:07:06,080
cassandra by far used the bulk of those

00:07:03,840 --> 00:07:07,919
at 384 cores

00:07:06,080 --> 00:07:11,039
uh followed by the actual application

00:07:07,919 --> 00:07:12,880
pipeline running on kubernetes at 118

00:07:11,039 --> 00:07:14,319
and then kafka is by far the most

00:07:12,880 --> 00:07:14,720
efficient part of the system it's really

00:07:14,319 --> 00:07:17,199
all

00:07:14,720 --> 00:07:18,160
all it has to cope with is um the

00:07:17,199 --> 00:07:21,199
incoming events

00:07:18,160 --> 00:07:24,319
and then uh passing them on to the rest

00:07:21,199 --> 00:07:25,759
of the pipeline so that use 72 cores

00:07:24,319 --> 00:07:27,759
so that gives you a bit of a feel for

00:07:25,759 --> 00:07:30,319
the size of the system um

00:07:27,759 --> 00:07:31,840
it's certainly not the biggest system

00:07:30,319 --> 00:07:33,039
like this that we've built and a lot of

00:07:31,840 --> 00:07:35,360
our customers have

00:07:33,039 --> 00:07:36,800
even bigger systems as well and some

00:07:35,360 --> 00:07:38,880
other commercial

00:07:36,800 --> 00:07:41,759
users of cassandra and kafka have even

00:07:38,880 --> 00:07:41,759
bigger clusters again

00:07:42,319 --> 00:07:45,919
however that system uh without any

00:07:44,720 --> 00:07:48,800
geospatial

00:07:45,919 --> 00:07:51,120
key thus using the very simple key has a

00:07:48,800 --> 00:07:53,280
baseline throughput of 19 billion

00:07:51,120 --> 00:07:55,039
anomaly checks a day so we'll call that

00:07:53,280 --> 00:07:57,120
the normalized 100

00:07:55,039 --> 00:07:58,879
level and then any changes from now on

00:07:57,120 --> 00:08:01,919
we'll see whether it makes any

00:07:58,879 --> 00:08:04,000
difference to that baseline throughput

00:08:01,919 --> 00:08:05,919
so i thought an interesting um and

00:08:04,000 --> 00:08:06,960
potentially harder problem

00:08:05,919 --> 00:08:09,199
without knowing what i was getting

00:08:06,960 --> 00:08:11,919
myself into was to spot the differences

00:08:09,199 --> 00:08:13,039
in space so space is big um obviously

00:08:11,919 --> 00:08:15,199
really big

00:08:13,039 --> 00:08:16,720
um so it just adds another dimension to

00:08:15,199 --> 00:08:18,479
the temporal dimension that i already

00:08:16,720 --> 00:08:21,120
was dealing with

00:08:18,479 --> 00:08:22,240
and you can also have spatial anomalies

00:08:21,120 --> 00:08:25,120
according to the

00:08:22,240 --> 00:08:26,479
um star trek wikipedia there's quite a

00:08:25,120 --> 00:08:27,520
whole bunch that have appeared in star

00:08:26,479 --> 00:08:30,080
trek over the years

00:08:27,520 --> 00:08:32,240
they're always encountering spatial

00:08:30,080 --> 00:08:33,919
anomalies of some sort

00:08:32,240 --> 00:08:35,919
so i thought well there are some real

00:08:33,919 --> 00:08:39,039
historical examples

00:08:35,919 --> 00:08:42,880
jon snow for example not this one

00:08:39,039 --> 00:08:44,560
but a long time ago in london jon snow

00:08:42,880 --> 00:08:46,399
did something quite famous he built the

00:08:44,560 --> 00:08:48,720
um the cholera map

00:08:46,399 --> 00:08:49,680
which attempted to work out why people

00:08:48,720 --> 00:08:51,200
were dying

00:08:49,680 --> 00:08:52,880
from this terrible disease they didn't

00:08:51,200 --> 00:08:55,680
really understand that the

00:08:52,880 --> 00:08:57,680
transmission mechanisms so he took a um

00:08:55,680 --> 00:08:59,839
very scientific statistical

00:08:57,680 --> 00:09:01,120
approach he actually made a map of

00:08:59,839 --> 00:09:04,160
deaths per household

00:09:01,120 --> 00:09:06,480
and plotted that versus location

00:09:04,160 --> 00:09:07,519
and he used that map to then identify a

00:09:06,480 --> 00:09:09,839
polluted

00:09:07,519 --> 00:09:10,800
pump where x marks the spot and it was

00:09:09,839 --> 00:09:11,680
quite interesting because there were

00:09:10,800 --> 00:09:13,360
some

00:09:11,680 --> 00:09:14,959
outliers as well it turned out that

00:09:13,360 --> 00:09:16,080
there was a brewery right next to the

00:09:14,959 --> 00:09:18,000
pump

00:09:16,080 --> 00:09:22,640
but brewers actually don't drink pump

00:09:18,000 --> 00:09:25,600
water they drink beer not surprisingly

00:09:22,640 --> 00:09:26,560
um so with location you first have to

00:09:25,600 --> 00:09:28,800
know

00:09:26,560 --> 00:09:29,920
where you are and to usefully represent

00:09:28,800 --> 00:09:31,600
location

00:09:29,920 --> 00:09:34,640
you need a couple things a coordinate

00:09:31,600 --> 00:09:36,399
system a map and a scale this guy

00:09:34,640 --> 00:09:38,959
is not going to get much help from that

00:09:36,399 --> 00:09:41,600
map this is a better one

00:09:38,959 --> 00:09:42,959
it's got light long coordinates it's got

00:09:41,600 --> 00:09:44,640
a scale

00:09:42,959 --> 00:09:46,880
and it's got some interesting things

00:09:44,640 --> 00:09:49,920
like um the bulk of the treasure is here

00:09:46,880 --> 00:09:51,600
that's the treasure island map

00:09:49,920 --> 00:09:53,200
so i was thinking about geospatial

00:09:51,600 --> 00:09:55,360
anonymity detection

00:09:53,200 --> 00:09:57,200
as a sort of a new problem so rather

00:09:55,360 --> 00:09:58,959
than the single id

00:09:57,200 --> 00:10:01,360
the events coming into my system now

00:09:58,959 --> 00:10:02,959
have a location and the value

00:10:01,360 --> 00:10:05,120
so the problem now becomes finding the

00:10:02,959 --> 00:10:07,200
nearest 50 events

00:10:05,120 --> 00:10:08,880
to each new event coming in and still

00:10:07,200 --> 00:10:10,560
doing it quickly

00:10:08,880 --> 00:10:12,480
the problem is you can't really make any

00:10:10,560 --> 00:10:13,680
assumptions about geospatial properties

00:10:12,480 --> 00:10:15,920
of events

00:10:13,680 --> 00:10:17,279
including the actual location density or

00:10:15,920 --> 00:10:20,320
distribution

00:10:17,279 --> 00:10:22,320
i.e where or how many there are so you

00:10:20,320 --> 00:10:23,440
need to search from the smallest to

00:10:22,320 --> 00:10:26,880
increasingly large

00:10:23,440 --> 00:10:28,640
areas um so some anomalies

00:10:26,880 --> 00:10:30,480
special anomalies are actually enormous

00:10:28,640 --> 00:10:32,079
so the south atlantic geomagnetic

00:10:30,480 --> 00:10:35,680
anomaly on this picture here is

00:10:32,079 --> 00:10:37,440
is huge um at apache con us

00:10:35,680 --> 00:10:40,079
last year there was a very interesting

00:10:37,440 --> 00:10:42,640
talk by some of the the uber people

00:10:40,079 --> 00:10:44,560
um they actually have a very similar um

00:10:42,640 --> 00:10:47,120
sort of technology stack

00:10:44,560 --> 00:10:47,600
um and uh and a slightly different use

00:10:47,120 --> 00:10:50,560
case

00:10:47,600 --> 00:10:51,360
um but they actually try and forecast

00:10:50,560 --> 00:10:54,720
demand

00:10:51,360 --> 00:10:56,640
um the problem that they have is that

00:10:54,720 --> 00:10:58,399
they have to then increase the area

00:10:56,640 --> 00:11:00,000
um until they have sufficient data to

00:10:58,399 --> 00:11:02,800
make accurate predictions about where

00:11:00,000 --> 00:11:03,360
demand an hour or two ahead might might

00:11:02,800 --> 00:11:06,399
be

00:11:03,360 --> 00:11:08,480
so it's a similar sort of problem

00:11:06,399 --> 00:11:10,399
so i thought well can we use that long

00:11:08,480 --> 00:11:11,600
as the cassandra partition key that's

00:11:10,399 --> 00:11:14,320
the obvious

00:11:11,600 --> 00:11:16,000
way of introducing the the geospatial

00:11:14,320 --> 00:11:18,399
data to my problem

00:11:16,000 --> 00:11:19,279
well the answer is yes compound petition

00:11:18,399 --> 00:11:21,760
keys

00:11:19,279 --> 00:11:24,560
are allowed but you can only select the

00:11:21,760 --> 00:11:26,959
exact locations which

00:11:24,560 --> 00:11:28,560
may not be all that useful so you have

00:11:26,959 --> 00:11:30,480
to then introduce the concept of

00:11:28,560 --> 00:11:32,000
nearness how to compute nearness to

00:11:30,480 --> 00:11:33,839
compute mean the distance between

00:11:32,000 --> 00:11:34,800
locations you need a coordinate system

00:11:33,839 --> 00:11:36,959
obviously

00:11:34,800 --> 00:11:38,640
um you guys are familiar with lots of

00:11:36,959 --> 00:11:40,720
different coordinate systems the

00:11:38,640 --> 00:11:42,959
mercator map is a common one

00:11:40,720 --> 00:11:44,959
uh but unfortunately it's flat earth and

00:11:42,959 --> 00:11:48,079
introduces lots of nasty distortion like

00:11:44,959 --> 00:11:49,360
near the poles um the antarctic i don't

00:11:48,079 --> 00:11:52,800
think is actually that big

00:11:49,360 --> 00:11:55,839
in practice um so in reality the world

00:11:52,800 --> 00:11:57,200
is at least approximately spherical

00:11:55,839 --> 00:11:58,959
unfortunately the calculation of

00:11:57,200 --> 00:12:01,040
distance between two

00:11:58,959 --> 00:12:02,240
that long points is non-trivial and

00:12:01,040 --> 00:12:04,160
there's the maths

00:12:02,240 --> 00:12:05,839
databases aren't i'm particularly good

00:12:04,160 --> 00:12:09,200
at doing complicated maths

00:12:05,839 --> 00:12:11,360
like that so often there's a simpler

00:12:09,200 --> 00:12:14,079
approach use the bounding box

00:12:11,360 --> 00:12:15,519
this is an approximation of distance

00:12:14,079 --> 00:12:18,240
using inequalities

00:12:15,519 --> 00:12:20,720
it's a lot simpler to compute it's a lot

00:12:18,240 --> 00:12:20,720
faster

00:12:21,360 --> 00:12:25,040
so can you use bounding boxes and

00:12:23,040 --> 00:12:27,600
cassandra

00:12:25,040 --> 00:12:29,200
or you can you can use essentially i've

00:12:27,600 --> 00:12:32,240
already been using

00:12:29,200 --> 00:12:35,279
country as a petition key

00:12:32,240 --> 00:12:36,639
and the long time as the clustering keys

00:12:35,279 --> 00:12:38,959
but you can't run the query with

00:12:36,639 --> 00:12:42,079
multiple inequalities

00:12:38,959 --> 00:12:44,959
so there's an example of a table and the

00:12:42,079 --> 00:12:46,639
query to select data using a bounding

00:12:44,959 --> 00:12:48,079
box unfortunately you get an error

00:12:46,639 --> 00:12:51,680
message back

00:12:48,079 --> 00:12:53,279
from the server so it looked like it

00:12:51,680 --> 00:12:55,680
might work but it doesn't actually work

00:12:53,279 --> 00:12:57,920
in practice

00:12:55,680 --> 00:13:00,320
so cassandra has a whole bunch of uh

00:12:57,920 --> 00:13:03,839
secondary indexes they're called

00:13:00,320 --> 00:13:06,480
would they help us well possibly um

00:13:03,839 --> 00:13:08,160
the problem is choosing the right one

00:13:06,480 --> 00:13:11,279
the default secondary indexes

00:13:08,160 --> 00:13:12,720
enable you to create an index on

00:13:11,279 --> 00:13:15,279
say the latitude and then another

00:13:12,720 --> 00:13:16,399
separate index on the longitude but

00:13:15,279 --> 00:13:18,240
unfortunately we have the same

00:13:16,399 --> 00:13:20,480
restrictions as the clustering columns

00:13:18,240 --> 00:13:21,839
in the previous example

00:13:20,480 --> 00:13:25,519
there's a different type of secondary

00:13:21,839 --> 00:13:27,680
index system called sassy

00:13:25,519 --> 00:13:30,079
which stands for ss table attached

00:13:27,680 --> 00:13:32,959
secondary index a bit of a mouthful

00:13:30,079 --> 00:13:33,600
it does in theory support more complex

00:13:32,959 --> 00:13:36,399
queries

00:13:33,600 --> 00:13:38,399
more efficiently there's a couple of

00:13:36,399 --> 00:13:39,680
examples of creating two sassy indexes

00:13:38,399 --> 00:13:42,399
on the lat long

00:13:39,680 --> 00:13:42,399
and a query

00:13:42,800 --> 00:13:46,720
does it work well sort of and it turns

00:13:44,480 --> 00:13:48,320
out reading the documentation that

00:13:46,720 --> 00:13:50,160
you need this thing called allow

00:13:48,320 --> 00:13:50,800
filtering which in cassandra is

00:13:50,160 --> 00:13:53,360
considered

00:13:50,800 --> 00:13:54,880
quite bad in the production environment

00:13:53,360 --> 00:13:56,320
um so essentially the data has got to be

00:13:54,880 --> 00:13:57,440
filtered first before the results are

00:13:56,320 --> 00:13:58,560
returned so it can be horribly

00:13:57,440 --> 00:14:00,800
inefficient

00:13:58,560 --> 00:14:02,800
if many rows have to be retrieved prior

00:14:00,800 --> 00:14:04,720
to filtering

00:14:02,800 --> 00:14:06,160
but then oddly enough the sassy

00:14:04,720 --> 00:14:07,279
documents themselves that even though

00:14:06,160 --> 00:14:08,800
you have to have

00:14:07,279 --> 00:14:10,560
that allow filtering there's no

00:14:08,800 --> 00:14:11,600
filtering actually going on so i really

00:14:10,560 --> 00:14:14,880
didn't understand what

00:14:11,600 --> 00:14:16,000
what was happening there anyway we tried

00:14:14,880 --> 00:14:18,720
it and that was our

00:14:16,000 --> 00:14:19,120
first lot of results with the um the

00:14:18,720 --> 00:14:21,519
long

00:14:19,120 --> 00:14:22,639
data added as you can see the results

00:14:21,519 --> 00:14:24,560
from a performance

00:14:22,639 --> 00:14:26,079
perspective were not very encouraging we

00:14:24,560 --> 00:14:27,040
were getting less than one percent of

00:14:26,079 --> 00:14:29,839
the base level

00:14:27,040 --> 00:14:31,760
results at that point um so this is

00:14:29,839 --> 00:14:32,399
probably not the correct solution if you

00:14:31,760 --> 00:14:36,399
care about

00:14:32,399 --> 00:14:38,160
performance okay another approach that

00:14:36,399 --> 00:14:41,519
seemed pretty obvious

00:14:38,160 --> 00:14:43,680
initially at least was geohashes

00:14:41,519 --> 00:14:45,279
i'd already sort of divided the map into

00:14:43,680 --> 00:14:48,399
named hierarchical

00:14:45,279 --> 00:14:50,480
areas using the country partition

00:14:48,399 --> 00:14:52,160
uh other examples that are quite

00:14:50,480 --> 00:14:53,920
interesting include things like plate

00:14:52,160 --> 00:14:56,959
tectonics which are actually

00:14:53,920 --> 00:14:59,199
hierarchical ways of dividing up the um

00:14:56,959 --> 00:15:01,519
the world based on the plates which is

00:14:59,199 --> 00:15:04,079
pretty cool

00:15:01,519 --> 00:15:06,079
um so geo hashes essentially they're

00:15:04,079 --> 00:15:10,079
just rectangular areas

00:15:06,079 --> 00:15:12,160
with a variable length base 32 string

00:15:10,079 --> 00:15:13,760
a single character region is about five

00:15:12,160 --> 00:15:16,320
thousand kilometers by

00:15:13,760 --> 00:15:18,639
five thousand kilometers and each letter

00:15:16,320 --> 00:15:19,680
uh extra letter gives another 32 sub

00:15:18,639 --> 00:15:22,079
areas

00:15:19,680 --> 00:15:25,519
so an eight character long geohash is an

00:15:22,079 --> 00:15:27,440
area about 40 meters by 20 meters

00:15:25,519 --> 00:15:29,680
so what you have to do is encode or

00:15:27,440 --> 00:15:31,120
decode your long turn from the geohash

00:15:29,680 --> 00:15:33,839
before you use it

00:15:31,120 --> 00:15:35,199
um similar to other coordinate systems

00:15:33,839 --> 00:15:38,399
obviously there are other

00:15:35,199 --> 00:15:42,079
sort of edge cases and it is non-linear

00:15:38,399 --> 00:15:43,839
near the poles as well uh and so

00:15:42,079 --> 00:15:46,000
interestingly enough some geohashes are

00:15:43,839 --> 00:15:49,440
actual words so ketchup

00:15:46,000 --> 00:15:54,079
is uh in africa somewhere

00:15:49,440 --> 00:15:56,880
uh it's an area 153 meters by 153 meters

00:15:54,079 --> 00:15:58,320
trump is in kazakhstan uh he's not the

00:15:56,880 --> 00:15:58,959
scale in this picture he's five

00:15:58,320 --> 00:16:00,480
kilometers

00:15:58,959 --> 00:16:02,160
five kilometers yep about five

00:16:00,480 --> 00:16:05,120
kilometers

00:16:02,160 --> 00:16:05,680
um yep okay so what do i have to do to

00:16:05,120 --> 00:16:07,920
modify

00:16:05,680 --> 00:16:09,759
my application for geo hashes well it's

00:16:07,920 --> 00:16:12,160
pretty simple you just encode

00:16:09,759 --> 00:16:13,680
that long's geo hash the geo hash

00:16:12,160 --> 00:16:15,759
becomes the new key

00:16:13,680 --> 00:16:17,519
so everywhere in the application where i

00:16:15,759 --> 00:16:19,440
write data or read it i'm now using the

00:16:17,519 --> 00:16:21,040
geohash as the key

00:16:19,440 --> 00:16:23,839
yeah the geohash is used to query

00:16:21,040 --> 00:16:23,839
cassandra

00:16:24,079 --> 00:16:27,600
not surprisingly again there's a few

00:16:25,680 --> 00:16:31,759
different ways of actually using

00:16:27,600 --> 00:16:35,440
geo hashes and cassandra option one

00:16:31,759 --> 00:16:37,199
is multiple indexed geo hash columns

00:16:35,440 --> 00:16:39,600
look some of these um options in

00:16:37,199 --> 00:16:41,199
hindsight are a bit silly but i i

00:16:39,600 --> 00:16:42,959
at the time i was trying everything i

00:16:41,199 --> 00:16:44,160
could think of so it was sort of an

00:16:42,959 --> 00:16:46,160
exhaustive

00:16:44,160 --> 00:16:47,519
approach um people that were more expert

00:16:46,160 --> 00:16:48,959
in data modeling because some of it

00:16:47,519 --> 00:16:51,120
would have said well that's

00:16:48,959 --> 00:16:52,480
silly or this is the correct way right

00:16:51,120 --> 00:16:55,519
away but anyway

00:16:52,480 --> 00:16:57,120
um so in theory geohashes are well known

00:16:55,519 --> 00:16:58,800
as working quite well for database

00:16:57,120 --> 00:17:02,160
indexes so this was

00:16:58,800 --> 00:17:04,079
at least a half sensible approach um

00:17:02,160 --> 00:17:06,079
so there's an example of how you do that

00:17:04,079 --> 00:17:09,919
it's got multiple

00:17:06,079 --> 00:17:12,559
um indexes uh

00:17:09,919 --> 00:17:14,720
basically you to use it you then have to

00:17:12,559 --> 00:17:16,720
run multiple queries selecting from the

00:17:14,720 --> 00:17:18,640
smallest to the largest areas and the

00:17:16,720 --> 00:17:22,079
stock when you get 50 rows

00:17:18,640 --> 00:17:23,760
of data returned the trade-offs include

00:17:22,079 --> 00:17:24,319
having multiple secondary columns and

00:17:23,760 --> 00:17:27,360
indexes

00:17:24,319 --> 00:17:29,919
multiple queries the accuracy and the

00:17:27,360 --> 00:17:31,840
number of queries depends on the spatial

00:17:29,919 --> 00:17:33,760
distribution and density which is all a

00:17:31,840 --> 00:17:36,160
bit tricky

00:17:33,760 --> 00:17:37,679
the results however are slightly better

00:17:36,160 --> 00:17:39,840
than our first attempt

00:17:37,679 --> 00:17:43,919
so we're getting about 10 of the base

00:17:39,840 --> 00:17:43,919
level results now using this approach

00:17:44,480 --> 00:17:49,520
second option is denormalization

00:17:47,520 --> 00:17:51,520
they normalize multiple tables in fact

00:17:49,520 --> 00:17:53,280
um so denormalization is actually pretty

00:17:51,520 --> 00:17:54,559
normal in cassandra this is the the de

00:17:53,280 --> 00:17:57,039
facto

00:17:54,559 --> 00:17:59,600
correct solution in cassandra uh it

00:17:57,039 --> 00:18:00,559
doesn't have joins it's no sql database

00:17:59,600 --> 00:18:02,400
so every time

00:18:00,559 --> 00:18:04,000
you think i need data in a slightly

00:18:02,400 --> 00:18:05,440
different format or copies of it that's

00:18:04,000 --> 00:18:07,679
great that's exactly what cassandra's

00:18:05,440 --> 00:18:10,720
designed for it's got really efficient

00:18:07,679 --> 00:18:12,799
and cheap right performance

00:18:10,720 --> 00:18:14,160
so you really have to design it with the

00:18:12,799 --> 00:18:16,559
reads in mind

00:18:14,160 --> 00:18:18,080
so what i did was create eight tables

00:18:16,559 --> 00:18:21,440
one for each

00:18:18,080 --> 00:18:23,200
distinct geo hash length

00:18:21,440 --> 00:18:25,360
then you select from the smallest the

00:18:23,200 --> 00:18:27,440
largest areas using the corresponding

00:18:25,360 --> 00:18:29,360
table again there's some trade-offs

00:18:27,440 --> 00:18:30,559
involved in that as well

00:18:29,360 --> 00:18:32,960
all right and the results for getting

00:18:30,559 --> 00:18:36,240
better results we're now up to 20

00:18:32,960 --> 00:18:38,480
of the the base line throughput

00:18:36,240 --> 00:18:40,559
so we're heading in the right direction

00:18:38,480 --> 00:18:42,640
uh the final option with geohashes was

00:18:40,559 --> 00:18:44,640
to use clustering columns

00:18:42,640 --> 00:18:45,760
uh it's very similar to option one but

00:18:44,640 --> 00:18:47,120
using um

00:18:45,760 --> 00:18:49,039
the clustering feature which is

00:18:47,120 --> 00:18:51,440
essentially the ordering mechanism

00:18:49,039 --> 00:18:54,160
within petitions in cassandra so there's

00:18:51,440 --> 00:18:56,240
an example of creating the table

00:18:54,160 --> 00:18:58,400
i've got a query here i think that i'm

00:18:56,240 --> 00:18:59,760
going to explain how it works um

00:18:58,400 --> 00:19:02,559
clustering columns are really good for

00:18:59,760 --> 00:19:04,000
hierarchical data

00:19:02,559 --> 00:19:06,880
they're good for modeling and deficient

00:19:04,000 --> 00:19:09,039
querying of hierarchical or nested data

00:19:06,880 --> 00:19:10,000
there's a few constraints the query must

00:19:09,039 --> 00:19:12,559
include the higher level

00:19:10,000 --> 00:19:14,160
columns with the equality operator

00:19:12,559 --> 00:19:15,520
ranges are only allowed on the last

00:19:14,160 --> 00:19:17,200
column in the query and lower level

00:19:15,520 --> 00:19:18,880
columns don't have to be included so

00:19:17,200 --> 00:19:22,080
there's an example of

00:19:18,880 --> 00:19:23,440
a permitted query

00:19:22,080 --> 00:19:25,520
but then again why have multiple

00:19:23,440 --> 00:19:26,480
clustering columns when one is actually

00:19:25,520 --> 00:19:30,160
sufficient

00:19:26,480 --> 00:19:32,880
so a better solution is to use geohash 8

00:19:30,160 --> 00:19:34,160
and time as the clustering key so

00:19:32,880 --> 00:19:36,559
there's an example of that it's a lot

00:19:34,160 --> 00:19:36,559
simpler

00:19:37,520 --> 00:19:40,640
there's the inequality range queries

00:19:39,440 --> 00:19:43,120
again you have to start

00:19:40,640 --> 00:19:45,039
um with smaller areas and stop when you

00:19:43,120 --> 00:19:47,360
get 50 back again

00:19:45,039 --> 00:19:49,120
and this gives us quite a significantly

00:19:47,360 --> 00:19:50,160
uh better result than the previous

00:19:49,120 --> 00:19:53,520
attempt so we're up to

00:19:50,160 --> 00:19:55,760
34 of the base line throughput now with

00:19:53,520 --> 00:19:57,440
this approach

00:19:55,760 --> 00:19:58,799
uh there's a whole bunch of issues

00:19:57,440 --> 00:20:01,200
potentially

00:19:58,799 --> 00:20:03,760
um the main one really is this trade-off

00:20:01,200 --> 00:20:06,080
between space versus time

00:20:03,760 --> 00:20:07,840
you can have different scales for the

00:20:06,080 --> 00:20:11,280
temporal axis and the

00:20:07,840 --> 00:20:13,440
spatial scale um so you just have to

00:20:11,280 --> 00:20:15,039
watch out for that

00:20:13,440 --> 00:20:16,960
so the final option that we'll have a

00:20:15,039 --> 00:20:18,400
look at is another well-known solution

00:20:16,960 --> 00:20:23,200
for cassandra

00:20:18,400 --> 00:20:25,440
cassandra apache leucine index plugin

00:20:23,200 --> 00:20:28,240
uh because the cassandra leucine index

00:20:25,440 --> 00:20:29,919
is a plugin for apache cassandra

00:20:28,240 --> 00:20:31,280
basically extends the index

00:20:29,919 --> 00:20:33,039
functionality

00:20:31,280 --> 00:20:35,600
to provide near real-time search

00:20:33,039 --> 00:20:38,640
including full-text search capabilities

00:20:35,600 --> 00:20:40,880
uh multi-variable and geospatial and by

00:20:38,640 --> 00:20:43,360
temporal search so it's quite powerful

00:20:40,880 --> 00:20:45,600
um we actually support this plugin now

00:20:43,360 --> 00:20:49,760
we've taken it over and maintain it

00:20:45,600 --> 00:20:51,440
so it's available on our github there

00:20:49,760 --> 00:20:53,280
so it's got very rich geospatial

00:20:51,440 --> 00:20:54,640
semantics including a whole bunch of

00:20:53,280 --> 00:20:55,600
things which we'll have a look at a few

00:20:54,640 --> 00:20:57,520
examples

00:20:55,600 --> 00:20:59,280
again the we're sort of spoiled for

00:20:57,520 --> 00:21:00,320
choice here so it wasn't obvious which

00:20:59,280 --> 00:21:03,600
ones

00:21:00,320 --> 00:21:04,240
would work better um first of all the

00:21:03,600 --> 00:21:06,000
geopoint

00:21:04,240 --> 00:21:07,760
example under the hood indexing is done

00:21:06,000 --> 00:21:09,679
using a tree structure with geohashes

00:21:07,760 --> 00:21:11,360
anyway with configurable precision so

00:21:09,679 --> 00:21:13,280
we're actually using

00:21:11,360 --> 00:21:14,840
geohashes by using a geopoint and

00:21:13,280 --> 00:21:17,440
loosing

00:21:14,840 --> 00:21:18,799
uh there's multiple search options we

00:21:17,440 --> 00:21:20,559
can sort

00:21:18,799 --> 00:21:22,000
it's got very sophisticated but quite

00:21:20,559 --> 00:21:25,360
complex uh cement

00:21:22,000 --> 00:21:29,440
semantics for sorting uh we could build

00:21:25,360 --> 00:21:33,039
a um we could yeah we could use a

00:21:29,440 --> 00:21:35,039
building box it's called be box filter

00:21:33,039 --> 00:21:37,760
you have to then compute the box corners

00:21:35,039 --> 00:21:40,080
in order to use this of course

00:21:37,760 --> 00:21:41,200
or there's a geo distance filter as well

00:21:40,080 --> 00:21:43,360
which is um

00:21:41,200 --> 00:21:46,000
which is of arbitrary precision and

00:21:43,360 --> 00:21:48,000
therefore more accurate as well

00:21:46,000 --> 00:21:49,840
uh finally there's not yet again another

00:21:48,000 --> 00:21:51,919
option the prefix filter

00:21:49,840 --> 00:21:53,840
this is useful for searching large areas

00:21:51,919 --> 00:21:56,000
over a single geo hash

00:21:53,840 --> 00:21:57,919
column as you can search for a substring

00:21:56,000 --> 00:21:59,760
so it turns out that geo hashes and

00:21:57,919 --> 00:22:03,280
prefixes actually sort of

00:21:59,760 --> 00:22:06,480
made for each other in a sense uh

00:22:03,280 --> 00:22:08,559
so finally some results but the leucine

00:22:06,480 --> 00:22:09,200
results added to the previous ones gave

00:22:08,559 --> 00:22:12,559
us between

00:22:09,200 --> 00:22:13,520
2 and 25 of the base level results the

00:22:12,559 --> 00:22:15,280
best one

00:22:13,520 --> 00:22:16,640
is the prefix filter that i just

00:22:15,280 --> 00:22:20,159
mentioned

00:22:16,640 --> 00:22:23,679
um none of them are as good as um as the

00:22:20,159 --> 00:22:26,640
geo hash option three though

00:22:23,679 --> 00:22:28,720
as overall here are the results um the

00:22:26,640 --> 00:22:30,080
two geo hash options are certainly the

00:22:28,720 --> 00:22:33,520
best giving 25

00:22:30,080 --> 00:22:36,240
34 of the the initial throughput so

00:22:33,520 --> 00:22:37,840
at 34 that would give us 6.5 billion

00:22:36,240 --> 00:22:41,840
anonymity checks today which is

00:22:37,840 --> 00:22:41,840
isn't um too bad

00:22:42,159 --> 00:22:46,159
the leucine bounded box and geo distance

00:22:44,880 --> 00:22:47,919
approaches were certainly the most

00:22:46,159 --> 00:22:49,679
accurate but only gave 5

00:22:47,919 --> 00:22:52,640
for the baseline performance and not

00:22:49,679 --> 00:22:52,640
great unfortunately

00:22:52,880 --> 00:22:56,799
um how are we going for time we've got

00:22:54,720 --> 00:22:58,960
another few minutes

00:22:56,799 --> 00:23:00,960
um i'll just mention the 3d problem so

00:22:58,960 --> 00:23:04,240
the world isn't this flat although

00:23:00,960 --> 00:23:05,840
what the world's not flap no

00:23:04,240 --> 00:23:07,679
no sorry to break anyone's

00:23:05,840 --> 00:23:09,360
misconceptions here but yeah you do have

00:23:07,679 --> 00:23:11,039
to worry about the

00:23:09,360 --> 00:23:12,640
sort of other other things apart from

00:23:11,039 --> 00:23:13,600
getting in a minute to get ten minutes

00:23:12,640 --> 00:23:15,360
before the session

00:23:13,600 --> 00:23:17,679
oh okay i'll i'll be done in five so

00:23:15,360 --> 00:23:17,679
yeah

00:23:18,720 --> 00:23:22,159
great okay uh whether i'm awake enough

00:23:21,120 --> 00:23:24,000
that it's

00:23:22,159 --> 00:23:27,120
not so sure i think i've left my coffee

00:23:24,000 --> 00:23:29,039
go cold here actually no

00:23:27,120 --> 00:23:31,440
okay um so what have we got here

00:23:29,039 --> 00:23:34,720
location altitude and volume

00:23:31,440 --> 00:23:37,120
so you can actually have 3d geo hashes

00:23:34,720 --> 00:23:38,720
they represent 2d location and then

00:23:37,120 --> 00:23:40,480
adding altitude gives you volume which

00:23:38,720 --> 00:23:43,600
is quite useful potentially

00:23:40,480 --> 00:23:45,520
um here's an example of a potential 3d

00:23:43,600 --> 00:23:46,640
geohash i didn't work out what value

00:23:45,520 --> 00:23:49,039
would be but

00:23:46,640 --> 00:23:50,159
this is a cube of all the earth's water

00:23:49,039 --> 00:23:53,600
in one

00:23:50,159 --> 00:23:55,360
sort of suspended location

00:23:53,600 --> 00:23:56,880
uh what sort of applications would you

00:23:55,360 --> 00:23:59,520
have for a 3d

00:23:56,880 --> 00:24:00,240
geo hash well recently i think it was

00:23:59,520 --> 00:24:02,159
google was

00:24:00,240 --> 00:24:04,159
was doing the world's first trial of

00:24:02,159 --> 00:24:05,039
drone delivery in canberra so that was a

00:24:04,159 --> 00:24:07,919
slightly

00:24:05,039 --> 00:24:10,480
bizarre experience um so it's quite

00:24:07,919 --> 00:24:12,080
useful with drones to have proximity

00:24:10,480 --> 00:24:15,279
detection that are in 3d

00:24:12,080 --> 00:24:17,360
obviously and so i was looking at the

00:24:15,279 --> 00:24:18,960
the rules around the world for drone

00:24:17,360 --> 00:24:20,720
usage and there's an example i think

00:24:18,960 --> 00:24:23,600
this is from the uk

00:24:20,720 --> 00:24:25,600
um so there's a whole bunch of rules uh

00:24:23,600 --> 00:24:28,080
you can only be 50 meters from people

00:24:25,600 --> 00:24:28,640
and property 150 meters from congested

00:24:28,080 --> 00:24:31,440
areas

00:24:28,640 --> 00:24:32,240
etc etc and interestingly enough they

00:24:31,440 --> 00:24:34,559
correspond

00:24:32,240 --> 00:24:35,440
pretty closely to different link 3d geo

00:24:34,559 --> 00:24:38,480
hashes so that

00:24:35,440 --> 00:24:40,880
that could be a potential application uh

00:24:38,480 --> 00:24:41,840
how would we add 3d geo hashes to our

00:24:40,880 --> 00:24:44,159
application

00:24:41,840 --> 00:24:45,200
well essentially the 3d 3d geo hash

00:24:44,159 --> 00:24:47,520
works with

00:24:45,200 --> 00:24:48,640
all the geo hash index options that i've

00:24:47,520 --> 00:24:50,799
highlighted in green

00:24:48,640 --> 00:24:52,559
on that graph so they give you a

00:24:50,799 --> 00:24:55,679
reasonably fast way to compute

00:24:52,559 --> 00:24:58,400
3d proximity of course

00:24:55,679 --> 00:24:59,120
for any of these solutions if you if you

00:24:58,400 --> 00:25:00,880
did

00:24:59,120 --> 00:25:03,279
want to go for some of the slower ones

00:25:00,880 --> 00:25:04,960
due to accuracy or other reasons

00:25:03,279 --> 00:25:06,720
uh with cassandra of course it's very

00:25:04,960 --> 00:25:08,159
simple to improve performance you just

00:25:06,720 --> 00:25:09,919
add more nodes to the cluster and you

00:25:08,159 --> 00:25:11,520
get linear

00:25:09,919 --> 00:25:14,640
performance improvement so there is

00:25:11,520 --> 00:25:16,880
another sort of backup plan

00:25:14,640 --> 00:25:18,960
uh okay that's basically the end of the

00:25:16,880 --> 00:25:22,240
talk if you want more information

00:25:18,960 --> 00:25:23,279
i've got my demo 3d geohash java code in

00:25:22,240 --> 00:25:26,400
the github

00:25:23,279 --> 00:25:28,880
there it's not production ready but it

00:25:26,400 --> 00:25:31,120
does produce valid 3d geohashes for

00:25:28,880 --> 00:25:32,240
altitudes from 13 kilometers below this

00:25:31,120 --> 00:25:34,559
level

00:25:32,240 --> 00:25:35,600
up to geostationary satellite orbit

00:25:34,559 --> 00:25:38,240
altitudes

00:25:35,600 --> 00:25:39,200
um and it can be used with the cassandra

00:25:38,240 --> 00:25:42,880
indexes

00:25:39,200 --> 00:25:45,440
as i've demonstrated uh

00:25:42,880 --> 00:25:47,520
i've got about 54 blogs now on various

00:25:45,440 --> 00:25:49,760
apache technologies

00:25:47,520 --> 00:25:50,880
um that i've written over the last three

00:25:49,760 --> 00:25:52,240
years if you're interested in having a

00:25:50,880 --> 00:25:54,080
look and there's a lot more details on

00:25:52,240 --> 00:25:55,600
the geospatial aspect

00:25:54,080 --> 00:25:58,000
as well i think that we're about four

00:25:55,600 --> 00:26:00,320
blogs in fact that um

00:25:58,000 --> 00:26:02,159
that i went through some of the more

00:26:00,320 --> 00:26:03,440
details of how this works

00:26:02,159 --> 00:26:05,039
and finally if you want to try out some

00:26:03,440 --> 00:26:06,320
of these open source technologies in a

00:26:05,039 --> 00:26:08,799
slightly bigger

00:26:06,320 --> 00:26:09,919
um context to what you can run on on

00:26:08,799 --> 00:26:12,159
your your

00:26:09,919 --> 00:26:12,960
laptop you can spin up some trial

00:26:12,159 --> 00:26:16,480
clusters

00:26:12,960 --> 00:26:18,400
of cassandra and kafka and elasticsearch

00:26:16,480 --> 00:26:20,400
and cabana and things like that

00:26:18,400 --> 00:26:22,240
on our website i think there's a two

00:26:20,400 --> 00:26:23,600
week trial period and you just have to

00:26:22,240 --> 00:26:25,600
go to our website

00:26:23,600 --> 00:26:27,200
and click on the free trial button and

00:26:25,600 --> 00:26:30,799
away you go

00:26:27,200 --> 00:26:32,559
um that's all from me thanks

00:26:30,799 --> 00:26:34,400
for listening i hope that that was an

00:26:32,559 --> 00:26:36,960
interesting sort of

00:26:34,400 --> 00:26:37,520
crossover between geospatial stuff and

00:26:36,960 --> 00:26:40,799
some of the

00:26:37,520 --> 00:26:42,320
sort of the big data technologies um

00:26:40,799 --> 00:26:44,640
and hopefully some of that might be

00:26:42,320 --> 00:26:47,360
useful

00:26:44,640 --> 00:26:48,240
thank you very much yes thank you paul

00:26:47,360 --> 00:26:50,400
and uh

00:26:48,240 --> 00:26:52,159
not only for the technical content but

00:26:50,400 --> 00:26:54,880
also the color uh

00:26:52,159 --> 00:26:55,440
in terms of the interludes on different

00:26:54,880 --> 00:26:57,520
topics

00:26:55,440 --> 00:26:59,360
not just the flat earth one but uh i had

00:26:57,520 --> 00:27:02,400
a look at some of you your guys talks

00:26:59,360 --> 00:27:04,080
um in the google uh drive yesterday as

00:27:02,400 --> 00:27:05,600
well and yes i noticed the geospatial

00:27:04,080 --> 00:27:06,640
track has a lot more interesting

00:27:05,600 --> 00:27:08,720
pictures

00:27:06,640 --> 00:27:10,480
in general i think than some of the more

00:27:08,720 --> 00:27:12,159
more focused technical tracks so that's

00:27:10,480 --> 00:27:13,840
one of the attractions for me as well as

00:27:12,159 --> 00:27:15,120
um

00:27:13,840 --> 00:27:16,960
being able to do something a bit

00:27:15,120 --> 00:27:20,159
interesting visually so

00:27:16,960 --> 00:27:21,600
so we've got some chat um

00:27:20,159 --> 00:27:24,720
questions i don't know if you see those

00:27:21,600 --> 00:27:26,880
as well super cool

00:27:24,720 --> 00:27:29,200
but did you cover any of the boundary

00:27:26,880 --> 00:27:33,120
issues with geohashes such as

00:27:29,200 --> 00:27:34,720
crossing boundaries now look for the

00:27:33,120 --> 00:27:36,880
for the use case that i had and it was a

00:27:34,720 --> 00:27:38,559
synthetic one i admit that um

00:27:36,880 --> 00:27:40,159
so i didn't do any functional testing to

00:27:38,559 --> 00:27:42,240
see whether it was producing the correct

00:27:40,159 --> 00:27:45,120
results with the geohash

00:27:42,240 --> 00:27:46,559
uh edition um but it's certainly

00:27:45,120 --> 00:27:48,320
something you have to be aware of

00:27:46,559 --> 00:27:50,080
and and i guess for the anomaly

00:27:48,320 --> 00:27:52,000
detection use case um

00:27:50,080 --> 00:27:53,840
speed was of the essence and getting a

00:27:52,000 --> 00:27:57,200
few false positives and things

00:27:53,840 --> 00:27:58,399
may not be so critical um but yeah you

00:27:57,200 --> 00:28:01,039
would have i think you would certainly

00:27:58,399 --> 00:28:03,760
have to tune it for a real

00:28:01,039 --> 00:28:04,880
application based on on actual knowledge

00:28:03,760 --> 00:28:08,240
of the

00:28:04,880 --> 00:28:11,840
distribution and um location

00:28:08,240 --> 00:28:14,320
of of interest um

00:28:11,840 --> 00:28:16,399
yep that's certainly a trade-off and

00:28:14,320 --> 00:28:18,080
then you got one about uh have you tried

00:28:16,399 --> 00:28:21,120
h3 the uber uh

00:28:18,080 --> 00:28:22,640
discrete system now oh yeah so i heard

00:28:21,120 --> 00:28:23,520
about that last year at the uber talk so

00:28:22,640 --> 00:28:26,000
that's um

00:28:23,520 --> 00:28:27,520
yep yes h3 indexing sounded interesting

00:28:26,000 --> 00:28:31,520
um no i haven't tried it

00:28:27,520 --> 00:28:34,720
um yeah now that there certainly are

00:28:31,520 --> 00:28:36,880
a lot of other options um

00:28:34,720 --> 00:28:38,240
and so yes the answer is no to that one

00:28:36,880 --> 00:28:40,159
i'm i'm

00:28:38,240 --> 00:28:41,760
not quite sure what what the trade-offs

00:28:40,159 --> 00:28:44,320
would be again for that one but

00:28:41,760 --> 00:28:46,480
certainly worth looking at h3 is a good

00:28:44,320 --> 00:28:48,480
one and of course it's a

00:28:46,480 --> 00:28:50,799
one of a general class of what's called

00:28:48,480 --> 00:28:54,080
discrete global grid systems

00:28:50,799 --> 00:28:55,600
which is a actually australia

00:28:54,080 --> 00:28:57,600
has been the leader in international

00:28:55,600 --> 00:28:59,520
standards about

00:28:57,600 --> 00:29:00,640
and at this point is beginning to go

00:28:59,520 --> 00:29:02,960
beyond 2d

00:29:00,640 --> 00:29:03,679
surface of the earth you know cells on

00:29:02,960 --> 00:29:06,320
the surface

00:29:03,679 --> 00:29:07,279
and nice uniformly to what you're trying

00:29:06,320 --> 00:29:10,720
to do what you're doing

00:29:07,279 --> 00:29:14,799
in in 3d and also in 4d

00:29:10,720 --> 00:29:17,840
and so a gentleman out of uh new zealand

00:29:14,799 --> 00:29:20,080
um has uh uh done

00:29:17,840 --> 00:29:22,080
really good work and i i in fact i'll

00:29:20,080 --> 00:29:25,520
find the link and put it in the chat but

00:29:22,080 --> 00:29:27,279
uh okay applying that in um you know

00:29:25,520 --> 00:29:29,440
cassandra and the like that's i'm not

00:29:27,279 --> 00:29:30,080
aware of so that would be a great mashup

00:29:29,440 --> 00:29:33,600
of

00:29:30,080 --> 00:29:35,760
3d discrete global grids or even 40

00:29:33,600 --> 00:29:37,679
in cassandra as you've shown would be a

00:29:35,760 --> 00:29:41,039
very interesting

00:29:37,679 --> 00:29:42,799
activity okay sort of a

00:29:41,039 --> 00:29:44,640
curious question as well as i mean how

00:29:42,799 --> 00:29:46,399
many people in the geospatial community

00:29:44,640 --> 00:29:48,320
use some of the big data technologies

00:29:46,399 --> 00:29:51,440
like cassandra and kafka

00:29:48,320 --> 00:29:52,640
is the size of the problem um

00:29:51,440 --> 00:29:54,159
big enough to use some of these

00:29:52,640 --> 00:29:57,039
technologies or can you get away with

00:29:54,159 --> 00:30:00,640
using some of the slightly less scalable

00:29:57,039 --> 00:30:03,520
technologies uh yes and

00:30:00,640 --> 00:30:04,320
jason just came in as well and stephen

00:30:03,520 --> 00:30:07,039
um

00:30:04,320 --> 00:30:08,080
yeah and that's why you know this track

00:30:07,039 --> 00:30:10,559
i think

00:30:08,080 --> 00:30:11,840
uh in fact the first geospatial track

00:30:10,559 --> 00:30:15,120
began

00:30:11,840 --> 00:30:17,200
in apache big data back in 2016 and

00:30:15,120 --> 00:30:18,240
and so there was another you know back

00:30:17,200 --> 00:30:22,159
then uh

00:30:18,240 --> 00:30:23,039
clear that the the mashup of uh apache

00:30:22,159 --> 00:30:25,120
big data

00:30:23,039 --> 00:30:26,080
with geospatial and geospatial i'm a

00:30:25,120 --> 00:30:29,279
geospatial guy

00:30:26,080 --> 00:30:31,279
so um you know geospatial is the first

00:30:29,279 --> 00:30:31,840
original big data is what i will tell

00:30:31,279 --> 00:30:34,720
you

00:30:31,840 --> 00:30:35,120
uh that remote sensing okay data right

00:30:34,720 --> 00:30:37,919
and

00:30:35,120 --> 00:30:38,880
so uh absolutely uh not to say

00:30:37,919 --> 00:30:42,000
everything's done

00:30:38,880 --> 00:30:45,039
but uh you know things like uh geo mesa

00:30:42,000 --> 00:30:47,760
and others uh h basically

00:30:45,039 --> 00:30:50,080
uh you know a bunch of them um you know

00:30:47,760 --> 00:30:51,200
elastic presented last uh last year that

00:30:50,080 --> 00:30:53,440
kind of thing but

00:30:51,200 --> 00:30:55,440
um you know exactly the kinds of things

00:30:53,440 --> 00:30:58,640
you're pointing out is good uh

00:30:55,440 --> 00:31:03,120
a good indication um

00:30:58,640 --> 00:31:04,480
remote yeah before big data was

00:31:03,120 --> 00:31:05,679
yeah cool that that makes a lot of sense

00:31:04,480 --> 00:31:07,519
i mean as i discovered i mean it's quite

00:31:05,679 --> 00:31:10,559
hard adding geospatial stuff

00:31:07,519 --> 00:31:12,880
um to the big data technologies

00:31:10,559 --> 00:31:14,640
and even they struggle with the the

00:31:12,880 --> 00:31:17,919
throughput aspects

00:31:14,640 --> 00:31:18,799
um so yeah the more grunt you've got the

00:31:17,919 --> 00:31:22,080
better

00:31:18,799 --> 00:31:24,000
for a lot of the stuff so um yes i know

00:31:22,080 --> 00:31:25,120
about geometry i haven't tried geo mesa

00:31:24,000 --> 00:31:26,799
but it does seem to have a

00:31:25,120 --> 00:31:29,039
really nice fit with cassandra and i

00:31:26,799 --> 00:31:30,840
have mentioned this to some of our um

00:31:29,039 --> 00:31:32,720
people a few times whether it's worth us

00:31:30,840 --> 00:31:34,640
trying to

00:31:32,720 --> 00:31:36,080
support it or at least test it out as

00:31:34,640 --> 00:31:39,360
well so your thanks for that

00:31:36,080 --> 00:31:41,360
that suggestion oh and geo wave okay yep

00:31:39,360 --> 00:31:42,720
and yeah elastic um so actually the talk

00:31:41,360 --> 00:31:44,720
i gave yesterday morning was

00:31:42,720 --> 00:31:46,000
sort of like a sponsored talk but

00:31:44,720 --> 00:31:47,919
nevertheless i encountered some

00:31:46,000 --> 00:31:50,960
geospatial challenges getting some

00:31:47,919 --> 00:31:53,919
data from the the us noaa

00:31:50,960 --> 00:31:55,679
title rest services into uh

00:31:53,919 --> 00:31:56,480
elasticsearch cabana there was quite a

00:31:55,679 --> 00:32:00,159
lot of

00:31:56,480 --> 00:32:00,960
transformation required to actually make

00:32:00,159 --> 00:32:03,760
cabana

00:32:00,960 --> 00:32:04,799
aware of the the geospatial dimensions

00:32:03,760 --> 00:32:06,399
of the data

00:32:04,799 --> 00:32:08,080
and then show it on a map so that wasn't

00:32:06,399 --> 00:32:11,120
as straightforward as as a

00:32:08,080 --> 00:32:12,399
as i was hoping even for a technology

00:32:11,120 --> 00:32:14,000
like that

00:32:12,399 --> 00:32:15,840
where was that talk you said you did one

00:32:14,000 --> 00:32:18,000
yesterday oh that was so that was um an

00:32:15,840 --> 00:32:21,360
apache on sponsored talks that was done

00:32:18,000 --> 00:32:23,360
on our insta plus booth yesterday so

00:32:21,360 --> 00:32:24,960
okay yeah yeah yeah definitely

00:32:23,360 --> 00:32:26,960
interested in that talk uh

00:32:24,960 --> 00:32:28,000
there's a way to share that we can add

00:32:26,960 --> 00:32:32,000
it into the there

00:32:28,000 --> 00:32:33,440
is a geospatial geospatial apache con

00:32:32,000 --> 00:32:36,399
channel but that's going to disappear

00:32:33,440 --> 00:32:36,399
here in a few hours

00:32:36,640 --> 00:32:41,120
there is a geospatial apache.org mailing

00:32:40,320 --> 00:32:43,760
list

00:32:41,120 --> 00:32:45,120
and so if you want to join that and uh

00:32:43,760 --> 00:32:48,880
contribute

00:32:45,120 --> 00:32:50,159
to geospatial if somebody was asking in

00:32:48,880 --> 00:32:52,559
the last session that there ought to be

00:32:50,159 --> 00:32:54,240
a web page for apache geospatial

00:32:52,559 --> 00:32:56,799
that may end up happening but right now

00:32:54,240 --> 00:32:58,880
we got a reflector male reflector right

00:32:56,799 --> 00:33:02,559
so uh

00:32:58,880 --> 00:33:06,000
urge that yep okay

00:33:02,559 --> 00:33:07,760
so we got well maybe 15 well 15 seconds

00:33:06,000 --> 00:33:09,600
or something before we got a birds of a

00:33:07,760 --> 00:33:11,679
feather that'll start in five minutes

00:33:09,600 --> 00:33:13,120
okay okay anything else you want to

00:33:11,679 --> 00:33:15,360
bring to us paul

00:33:13,120 --> 00:33:16,480
i think that's about it from me um i

00:33:15,360 --> 00:33:18,799
don't know when i'll be doing anything

00:33:16,480 --> 00:33:20,799
specifically geospatial next but um

00:33:18,799 --> 00:33:22,559
i'll certainly try and uh keep track of

00:33:20,799 --> 00:33:24,480
what you guys are up to and

00:33:22,559 --> 00:33:26,799
might see you again in person hopefully

00:33:24,480 --> 00:33:29,200
maybe even next year we'll have to see

00:33:26,799 --> 00:33:30,799
what happens we can always dream that

00:33:29,200 --> 00:33:31,840
you know someday we'll get out of our

00:33:30,799 --> 00:33:35,120
caves right

00:33:31,840 --> 00:33:37,120
uh yes that's right

00:33:35,120 --> 00:33:38,480
all right well again thank you paul very

00:33:37,120 --> 00:33:39,840
entertaining all right well thanks for

00:33:38,480 --> 00:33:41,039
inviting me and that's a great

00:33:39,840 --> 00:33:43,760
experience patchycon

00:33:41,039 --> 00:33:45,120
and nice meeting people from everywhere

00:33:43,760 --> 00:33:46,320
and lots of different disciplines as

00:33:45,120 --> 00:33:49,760
well so thank you

00:33:46,320 --> 00:33:51,679
so go to the sessions page

00:33:49,760 --> 00:33:53,360
and go to the birds of a feather and

00:33:51,679 --> 00:34:07,840
everybody can join and talk there

00:33:53,360 --> 00:34:07,840
so we'll see okay see you bye everyone

00:34:17,200 --> 00:34:19,280

YouTube URL: https://www.youtube.com/watch?v=ETkz_1m59Wc


