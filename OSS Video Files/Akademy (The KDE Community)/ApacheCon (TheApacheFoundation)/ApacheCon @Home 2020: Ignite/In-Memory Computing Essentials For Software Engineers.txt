Title: In-Memory Computing Essentials For Software Engineers
Publication date: 2020-10-14
Playlist: ApacheCon @Home 2020: Ignite
Description: 
	In-Memory Computing Essentials For Software Engineers
Denis Magda

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Attendees will be introduced to the fundamental capabilities of in-memory computing platforms that are proven to boost application performance and solve scalability problems by storing and processing unlimited data sets distributed across a cluster of interconnected machines. The session is tailored for software engineers and architects seeking practical experience with in-memory computing technologies. You'll be given an overview (including code samples in Java) of in-memory concepts such as caches, databases, and data grids combined with a technical deep-dive based on Apache Ignite in-memory computing platform. In particular, we'll cover the following essentials of distributed in-memory systems: * Data partitioning: utilizing all memory and CPU resources of the cluster * Affinity co-location: avoiding data shuffling over the network and using highly-performant distributed SQL queries * Co-located processing: eliminating network impact on the performance of our applications

Denis Magda is an open-source enthusiast who started his journey in Sun Microsystems as a developer advocate and presently settled down at Apache Software Foundation in the roles of Apache Ignite committer and PMC member. He is an expert in distributed systems and platforms who actively contributes to Apache Ignite and helps companies to build successful open-source projects. You can be sure to come across Denis at conferences, workshops and other events sharing his knowledge about the open-source, community building, distributed systems.
Captions: 
	00:00:03,370 --> 00:00:08,089
[Music]

00:00:11,120 --> 00:00:14,190
[Music]

00:00:23,439 --> 00:00:27,920
all right let's do this

00:00:25,840 --> 00:00:29,599
during this presentation i think that i

00:00:27,920 --> 00:00:32,880
have only 40 minutes

00:00:29,599 --> 00:00:34,880
but i will try to you know save

00:00:32,880 --> 00:00:35,920
as much time as possible for the q a

00:00:34,880 --> 00:00:38,160
session

00:00:35,920 --> 00:00:39,280
while you're listening to me i'm going

00:00:38,160 --> 00:00:42,840
to kind of share

00:00:39,280 --> 00:00:44,079
some theory today and also i'm going to

00:00:42,840 --> 00:00:46,559
demonstrate

00:00:44,079 --> 00:00:47,920
uh some interesting demos but and

00:00:46,559 --> 00:00:49,440
throughout this presentation just go

00:00:47,920 --> 00:00:50,399
ahead and put your questions into the

00:00:49,440 --> 00:00:52,559
chat window

00:00:50,399 --> 00:00:53,520
and then my goal would be you know to

00:00:52,559 --> 00:00:55,920
keep at least

00:00:53,520 --> 00:00:57,039
10 minutes for the q a that's my my goal

00:00:55,920 --> 00:01:00,640
so that then they can

00:00:57,039 --> 00:01:04,080
a conversation here right let's start

00:01:00,640 --> 00:01:07,119
uh and memory computing essentials for

00:01:04,080 --> 00:01:07,600
software engineers so today you know

00:01:07,119 --> 00:01:09,600
that

00:01:07,600 --> 00:01:10,720
uh there is a myriad of different and

00:01:09,600 --> 00:01:12,479
memory technologies

00:01:10,720 --> 00:01:14,640
that they can use to speed up or

00:01:12,479 --> 00:01:16,960
accelerate our applications

00:01:14,640 --> 00:01:19,439
some of you might use caches the others

00:01:16,960 --> 00:01:21,119
can use memory databases

00:01:19,439 --> 00:01:22,400
and there is a huge difference between

00:01:21,119 --> 00:01:23,439
all those in memory computing

00:01:22,400 --> 00:01:25,439
technologies

00:01:23,439 --> 00:01:27,119
in regards to the feature set in regards

00:01:25,439 --> 00:01:29,360
to some other capabilities

00:01:27,119 --> 00:01:30,720
but there is always something that

00:01:29,360 --> 00:01:32,720
unites and

00:01:30,720 --> 00:01:34,560
all of those technologies that makes all

00:01:32,720 --> 00:01:36,320
those technologies universal

00:01:34,560 --> 00:01:38,079
and i define those universal

00:01:36,320 --> 00:01:40,079
characteristics as

00:01:38,079 --> 00:01:41,280
memory computing essentials something

00:01:40,079 --> 00:01:43,600
fundamental

00:01:41,280 --> 00:01:45,200
that exists in almost all the memory

00:01:43,600 --> 00:01:46,799
computing systems

00:01:45,200 --> 00:01:48,479
and the goal of this presentation is

00:01:46,799 --> 00:01:50,799
first to introduce you to those

00:01:48,479 --> 00:01:51,759
in memory computing essentials and

00:01:50,799 --> 00:01:54,320
second of all

00:01:51,759 --> 00:01:56,479
my goal is to ensure you that you need

00:01:54,320 --> 00:01:58,479
to keep those essentials in mind

00:01:56,479 --> 00:02:00,000
when you will be building any in-memory

00:01:58,479 --> 00:02:02,079
powered applications

00:02:00,000 --> 00:02:04,240
and then based on those essentials you

00:02:02,079 --> 00:02:05,119
can go further and you can select either

00:02:04,240 --> 00:02:07,520
a cache or

00:02:05,119 --> 00:02:10,640
in memory database depending on your on

00:02:07,520 --> 00:02:14,080
the required feature set

00:02:10,640 --> 00:02:17,120
uh a little bit about myself my name is

00:02:14,080 --> 00:02:18,720
denis magda for the last five years i've

00:02:17,120 --> 00:02:21,599
been studying and working with

00:02:18,720 --> 00:02:22,879
distributed memory systems i'm gaining

00:02:21,599 --> 00:02:25,200
practical experience

00:02:22,879 --> 00:02:27,200
by contributing to the apache ignite

00:02:25,200 --> 00:02:29,120
project which is a memory computing

00:02:27,200 --> 00:02:32,720
platform that is used as a cache

00:02:29,120 --> 00:02:34,160
or database and also i'm collaborating a

00:02:32,720 --> 00:02:36,000
lot with

00:02:34,160 --> 00:02:37,280
application developers and architects

00:02:36,000 --> 00:02:38,959
who are using ignite and other

00:02:37,280 --> 00:02:41,920
distributed systems

00:02:38,959 --> 00:02:44,160
and uh by working with uh by running

00:02:41,920 --> 00:02:45,840
developer relations group at great game

00:02:44,160 --> 00:02:48,000
at the same time before that i was

00:02:45,840 --> 00:02:50,239
involved in java

00:02:48,000 --> 00:02:51,040
gdk development and java virtual machine

00:02:50,239 --> 00:02:53,440
development

00:02:51,040 --> 00:02:55,200
i spent many years working for oracle

00:02:53,440 --> 00:02:57,440
and some microsystems and my zone of

00:02:55,200 --> 00:03:00,000
responsibilities in interest was

00:02:57,440 --> 00:03:01,120
java for mobile devices and embedded

00:03:00,000 --> 00:03:03,599
devices

00:03:01,120 --> 00:03:05,200
all right so our agenda for today now

00:03:03,599 --> 00:03:08,159
first thing first

00:03:05,200 --> 00:03:09,280
we i need to introduce you to their kind

00:03:08,159 --> 00:03:11,360
of rationale

00:03:09,280 --> 00:03:13,440
behind in memory computing why we need

00:03:11,360 --> 00:03:15,360
to um

00:03:13,440 --> 00:03:17,040
why why why it's essential why we are

00:03:15,360 --> 00:03:18,480
even you know deploying those in memory

00:03:17,040 --> 00:03:20,720
computing systems

00:03:18,480 --> 00:03:22,159
second of all i will spend three or five

00:03:20,720 --> 00:03:24,000
minutes uh

00:03:22,159 --> 00:03:25,599
covering apache ignite for you because

00:03:24,000 --> 00:03:26,400
apache ignite i will be using apache

00:03:25,599 --> 00:03:27,760
ignite

00:03:26,400 --> 00:03:29,599
for reference as a reference

00:03:27,760 --> 00:03:30,319
implementation i'm going to show you

00:03:29,599 --> 00:03:32,879
some

00:03:30,319 --> 00:03:33,840
applications that are using ignite uh

00:03:32,879 --> 00:03:35,360
but nevertheless

00:03:33,840 --> 00:03:37,200
all the rest of the essentials that we

00:03:35,360 --> 00:03:39,280
are going to dive into later such as

00:03:37,200 --> 00:03:41,120
data partitioning affinity collocation

00:03:39,280 --> 00:03:43,120
or calculated computations

00:03:41,120 --> 00:03:45,440
they are not characteristics of ignite

00:03:43,120 --> 00:03:47,599
only but you will find out that

00:03:45,440 --> 00:03:49,200
uh when we talk about data partitioning

00:03:47,599 --> 00:03:50,879
in your affinity collocation the same

00:03:49,200 --> 00:03:52,879
essential capabilities

00:03:50,879 --> 00:03:54,159
exist in other technologies that can

00:03:52,879 --> 00:03:57,519
keep data in memory

00:03:54,159 --> 00:04:00,959
all right so why memory computing so

00:03:57,519 --> 00:04:02,879
the question is quite

00:04:00,959 --> 00:04:04,480
straightforward and best and the answer

00:04:02,879 --> 00:04:06,000
is simple that's all about speed and

00:04:04,480 --> 00:04:07,680
scale

00:04:06,000 --> 00:04:09,439
the scale cramps comes from the

00:04:07,680 --> 00:04:12,000
horizontal scalability

00:04:09,439 --> 00:04:13,840
of distributed memory systems as any

00:04:12,000 --> 00:04:15,360
distributed database and then memory

00:04:13,840 --> 00:04:17,600
cache and memory database

00:04:15,360 --> 00:04:18,959
that can keep your data across the

00:04:17,600 --> 00:04:21,040
classroom machines

00:04:18,959 --> 00:04:23,280
for instance your very first instance of

00:04:21,040 --> 00:04:25,520
your application can communicate with a

00:04:23,280 --> 00:04:28,320
cluster that has only three nodes

00:04:25,520 --> 00:04:29,120
but then as long as your workload grows

00:04:28,320 --> 00:04:31,199
or you are

00:04:29,120 --> 00:04:33,360
about to keep much more data in your

00:04:31,199 --> 00:04:34,880
cluster what you do you just scale out

00:04:33,360 --> 00:04:37,199
your cluster you are adding

00:04:34,880 --> 00:04:38,639
third node like fourth node fifth node

00:04:37,199 --> 00:04:42,000
and you keep doing this

00:04:38,639 --> 00:04:45,440
as long as you need more machines

00:04:42,000 --> 00:04:47,360
and where does the speed come from so

00:04:45,440 --> 00:04:49,360
that's all about latency that's about

00:04:47,360 --> 00:04:52,479
access time we as software

00:04:49,360 --> 00:04:54,800
architects and engineers understand that

00:04:52,479 --> 00:04:56,479
memory access is much faster than disk

00:04:54,800 --> 00:04:58,320
but let's try to figure out what's the

00:04:56,479 --> 00:05:00,800
magnitude how how big is the difference

00:04:58,320 --> 00:05:03,440
between this axis and memory access

00:05:00,800 --> 00:05:05,360
i'm usually using this table to show the

00:05:03,440 --> 00:05:06,560
difference so what you have in the first

00:05:05,360 --> 00:05:09,120
column

00:05:06,560 --> 00:05:11,600
we have some various system events that

00:05:09,120 --> 00:05:13,120
our cpus need to process

00:05:11,600 --> 00:05:15,440
and to the right you have the actual

00:05:13,120 --> 00:05:17,840
latency time so basically how much time

00:05:15,440 --> 00:05:19,600
does it take for a cpu to complete any

00:05:17,840 --> 00:05:21,759
operation to the left

00:05:19,600 --> 00:05:23,680
and in the final third column we have

00:05:21,759 --> 00:05:26,320
scaled latencies so called like the

00:05:23,680 --> 00:05:28,800
latency that is adopted or translated

00:05:26,320 --> 00:05:30,000
into the our human universe because we

00:05:28,800 --> 00:05:32,960
as humans

00:05:30,000 --> 00:05:35,039
we can comprehend you know the time uh

00:05:32,960 --> 00:05:36,080
by measuring it in seconds days and

00:05:35,039 --> 00:05:37,759
years and then we can

00:05:36,080 --> 00:05:39,120
sense the difference between seconds or

00:05:37,759 --> 00:05:41,199
minutes and dates

00:05:39,120 --> 00:05:42,400
you cannot sense the difference you know

00:05:41,199 --> 00:05:44,639
like when they're talking about

00:05:42,400 --> 00:05:46,479
nanoseconds or microseconds

00:05:44,639 --> 00:05:48,720
that's why like what what happened in

00:05:46,479 --> 00:05:49,680
this table uh the author of this table

00:05:48,720 --> 00:05:52,160
assumed

00:05:49,680 --> 00:05:54,080
that if to put that four nanoseconds i

00:05:52,160 --> 00:05:55,440
equal to one second which is equal to

00:05:54,080 --> 00:05:57,280
one cpu cycle

00:05:55,440 --> 00:05:59,199
then the rest of the actual latencies

00:05:57,280 --> 00:06:02,000
will be translated to the

00:05:59,199 --> 00:06:04,240
values in the third column and after

00:06:02,000 --> 00:06:07,199
that if we pay attention to the

00:06:04,240 --> 00:06:08,240
latency time differences between main

00:06:07,199 --> 00:06:10,960
memory access

00:06:08,240 --> 00:06:13,280
and disk access you'll see that in our

00:06:10,960 --> 00:06:15,680
universe in the human universe there

00:06:13,280 --> 00:06:17,360
that latency is like the difference

00:06:15,680 --> 00:06:20,800
between minutes and days

00:06:17,360 --> 00:06:22,639
and that's why we are and as architects

00:06:20,800 --> 00:06:23,840
of developers we are going ahead and

00:06:22,639 --> 00:06:25,759
deploying

00:06:23,840 --> 00:06:27,440
distributed and memory systems that's

00:06:25,759 --> 00:06:28,160
why we are using in-memory computing

00:06:27,440 --> 00:06:30,240
software

00:06:28,160 --> 00:06:31,520
because it has provides two main

00:06:30,240 --> 00:06:34,800
characteristics first

00:06:31,520 --> 00:06:36,479
it's scalable and second it it stores

00:06:34,800 --> 00:06:38,720
all the data in memory and my

00:06:36,479 --> 00:06:40,160
main memory access is much faster it's

00:06:38,720 --> 00:06:40,560
like the difference between minutes and

00:06:40,160 --> 00:06:44,080
days

00:06:40,560 --> 00:06:45,840
if to compare to disk access all right

00:06:44,080 --> 00:06:47,919
and apache ignite as i said apache

00:06:45,840 --> 00:06:49,280
ignite we are going to use it as a

00:06:47,919 --> 00:06:50,800
reference platform

00:06:49,280 --> 00:06:53,360
to you know describe all those

00:06:50,800 --> 00:06:55,680
essentials in details and i'm going to

00:06:53,360 --> 00:06:57,440
show you some demos that use apache

00:06:55,680 --> 00:06:59,120
ignite but nevertheless

00:06:57,440 --> 00:07:01,039
most of the stuff that we are going to

00:06:59,120 --> 00:07:03,280
cover today you can apply this knowledge

00:07:01,039 --> 00:07:05,280
to other distributed memory systems that

00:07:03,280 --> 00:07:08,720
you are using for your projects

00:07:05,280 --> 00:07:10,319
all right apache ignite uh apache ignite

00:07:08,720 --> 00:07:12,400
is a memory computing platform and

00:07:10,319 --> 00:07:14,240
that's why on this slide you can see so

00:07:12,400 --> 00:07:17,680
many building blocks

00:07:14,240 --> 00:07:20,560
that comprise this project but uh to put

00:07:17,680 --> 00:07:22,720
things simple usually i explain ignite

00:07:20,560 --> 00:07:23,680
this way ignite consists of two primary

00:07:22,720 --> 00:07:25,599
components

00:07:23,680 --> 00:07:27,599
the first one is ignite distributed

00:07:25,599 --> 00:07:30,639
multi-tier storage

00:07:27,599 --> 00:07:31,280
uh ignite by definition can keep data in

00:07:30,639 --> 00:07:33,440
memory

00:07:31,280 --> 00:07:35,520
across a cluster of machines but at the

00:07:33,440 --> 00:07:37,840
same time ignite can persist

00:07:35,520 --> 00:07:40,240
your records on disk and when it comes

00:07:37,840 --> 00:07:42,560
to this ignite can persist your data in

00:07:40,240 --> 00:07:44,560
a third-party database such as postgres

00:07:42,560 --> 00:07:46,960
mysql oracle or cassandra

00:07:44,560 --> 00:07:49,199
why ignite can persist all the data in

00:07:46,960 --> 00:07:51,120
its own disk theories and ignite native

00:07:49,199 --> 00:07:52,000
persistence across again the cluster of

00:07:51,120 --> 00:07:53,520
machines

00:07:52,000 --> 00:07:55,919
i i'll show you the difference between

00:07:53,520 --> 00:07:56,879
those two persistence options on the

00:07:55,919 --> 00:07:58,479
next slide

00:07:56,879 --> 00:08:00,400
and that's like the first component in

00:07:58,479 --> 00:08:01,360
memory like distributed multi-tier

00:08:00,400 --> 00:08:03,120
storage

00:08:01,360 --> 00:08:05,840
and on top of that storage the second

00:08:03,120 --> 00:08:08,080
component is a variety of apis

00:08:05,840 --> 00:08:10,560
ignite negatively supports sql you can

00:08:08,080 --> 00:08:12,639
query data with sql you can transact on

00:08:10,560 --> 00:08:14,080
ignite using distributed transactions

00:08:12,639 --> 00:08:16,080
you can you know

00:08:14,080 --> 00:08:18,240
query data using keyword upis and you

00:08:16,080 --> 00:08:19,360
can run computations today we are going

00:08:18,240 --> 00:08:22,879
to explore

00:08:19,360 --> 00:08:26,400
some of these apis in particular sql um

00:08:22,879 --> 00:08:28,720
compute grid and kiwi and when it comes

00:08:26,400 --> 00:08:30,240
to apache ignite use cases

00:08:28,720 --> 00:08:32,320
uh i would say that there are two

00:08:30,240 --> 00:08:34,479
primary use cases even though i've

00:08:32,320 --> 00:08:35,599
talked to many people who use ignite for

00:08:34,479 --> 00:08:38,080
some you know

00:08:35,599 --> 00:08:39,039
unbelievable usage for unbelievable

00:08:38,080 --> 00:08:41,120
applications

00:08:39,039 --> 00:08:42,479
so the very first obvious use case is

00:08:41,120 --> 00:08:44,720
ignite as a cache

00:08:42,479 --> 00:08:45,839
in this case you can have let's say one

00:08:44,720 --> 00:08:48,000
database

00:08:45,839 --> 00:08:49,120
probably just that keeps all your

00:08:48,000 --> 00:08:50,640
primary records

00:08:49,120 --> 00:08:52,080
and then you have application and right

00:08:50,640 --> 00:08:54,320
now you need to accelerate your

00:08:52,080 --> 00:08:56,320
applications or offload that database

00:08:54,320 --> 00:08:58,959
and you deploy ignite as a distributed

00:08:56,320 --> 00:09:00,959
memory caching between your application

00:08:58,959 --> 00:09:02,240
and the database it's obvious right and

00:09:00,959 --> 00:09:04,399
then you kind of

00:09:02,240 --> 00:09:05,920
right now you might be sitting and

00:09:04,399 --> 00:09:08,080
thinking like then what's the difference

00:09:05,920 --> 00:09:09,120
between ignite and radius in this case i

00:09:08,080 --> 00:09:10,880
would say that

00:09:09,120 --> 00:09:13,279
uh you can you would use ignite as a

00:09:10,880 --> 00:09:15,680
cache if you need sql api so if you need

00:09:13,279 --> 00:09:17,200
transactions of you if you need compute

00:09:15,680 --> 00:09:18,959
otherwise you can go ahead and take

00:09:17,200 --> 00:09:21,040
credits but if you need sql if you need

00:09:18,959 --> 00:09:22,080
compute api so if you need transactions

00:09:21,040 --> 00:09:23,760
then

00:09:22,080 --> 00:09:25,360
ignite will be a natural choice for you

00:09:23,760 --> 00:09:28,399
for the cash in use case

00:09:25,360 --> 00:09:29,760
uh the other use case of ignite is the

00:09:28,399 --> 00:09:31,920
memory database

00:09:29,760 --> 00:09:33,680
in this scenario you can use the same

00:09:31,920 --> 00:09:35,680
apis you would use for the caching

00:09:33,680 --> 00:09:38,399
scenario it's no difference it's just

00:09:35,680 --> 00:09:40,000
a deployment option but when it comes to

00:09:38,399 --> 00:09:42,399
the persistence tier

00:09:40,000 --> 00:09:44,480
in this case you are not keeping data in

00:09:42,399 --> 00:09:46,080
a third-party database such as oracle

00:09:44,480 --> 00:09:48,800
cassandra but instead

00:09:46,080 --> 00:09:51,360
you are having all the data in ignite

00:09:48,800 --> 00:09:53,040
native persistence and your cluster

00:09:51,360 --> 00:09:55,920
and kind of you're getting a cluster of

00:09:53,040 --> 00:09:56,800
machines that stores data both in memory

00:09:55,920 --> 00:09:58,720
on this

00:09:56,800 --> 00:10:00,000
the difference here like why what what

00:09:58,720 --> 00:10:00,880
you're getting with this deployment

00:10:00,000 --> 00:10:03,760
configuration

00:10:00,880 --> 00:10:05,200
first thing uh ignite native persistence

00:10:03,760 --> 00:10:05,760
will keep hundred percent of your

00:10:05,200 --> 00:10:07,600
records

00:10:05,760 --> 00:10:09,519
which means that you don't need to cache

00:10:07,600 --> 00:10:10,240
everything in memory and that's ideal

00:10:09,519 --> 00:10:12,160
for

00:10:10,240 --> 00:10:14,000
let's say hybrid use cases when you keep

00:10:12,160 --> 00:10:15,839
operation and analytical data

00:10:14,000 --> 00:10:17,760
operational data can fully

00:10:15,839 --> 00:10:19,760
uh be located in memory but as for the

00:10:17,760 --> 00:10:20,880
analytical data only a subset of the

00:10:19,760 --> 00:10:24,079
data can be on

00:10:20,880 --> 00:10:26,079
uh in ram and as long as all the data is

00:10:24,079 --> 00:10:28,079
on disk if you need to restart your

00:10:26,079 --> 00:10:30,000
ignite cluster due to any maintenance

00:10:28,079 --> 00:10:31,600
needs you just you know reboot it

00:10:30,000 --> 00:10:33,839
and you don't need to wait while all

00:10:31,600 --> 00:10:35,920
your terabytes of petabytes of data get

00:10:33,839 --> 00:10:38,079
reloaded into the memory ignite can

00:10:35,920 --> 00:10:41,040
serve and read all the data from disk

00:10:38,079 --> 00:10:42,560
warming up memory tier and background

00:10:41,040 --> 00:10:44,079
and again it's like that's a pachacan

00:10:42,560 --> 00:10:46,560
conversation i i

00:10:44,079 --> 00:10:47,360
believe that many of you already know

00:10:46,560 --> 00:10:49,680
ignite but

00:10:47,360 --> 00:10:51,600
just in case ignite is one of the top uh

00:10:49,680 --> 00:10:53,279
five projects of the foundation if to

00:10:51,600 --> 00:10:55,519
judge by the day of listen

00:10:53,279 --> 00:10:57,440
my induced activity and it's being used

00:10:55,519 --> 00:10:59,279
in this open source project is being

00:10:57,440 --> 00:11:01,519
used by many well-known contents

00:10:59,279 --> 00:11:02,800
all right enough for the introduction so

00:11:01,519 --> 00:11:06,240
right now what we

00:11:02,800 --> 00:11:08,000
uh figure out right now we know the uh

00:11:06,240 --> 00:11:09,600
reasoning and rationale behind the

00:11:08,000 --> 00:11:11,440
memory computing

00:11:09,600 --> 00:11:14,560
uh systems why do we need that because

00:11:11,440 --> 00:11:16,560
those provide speeding scale and

00:11:14,560 --> 00:11:18,079
i've i've i made an introduction to

00:11:16,560 --> 00:11:20,640
ignite so right now let's

00:11:18,079 --> 00:11:22,720
uh follow the primary course of this

00:11:20,640 --> 00:11:23,680
precedence presentation let's talk about

00:11:22,720 --> 00:11:25,920
essentials

00:11:23,680 --> 00:11:26,959
and the first one is data partitioning

00:11:25,920 --> 00:11:29,120
this technique

00:11:26,959 --> 00:11:31,360
let's let's ask you know to distribute

00:11:29,120 --> 00:11:33,360
our records and use all the resources of

00:11:31,360 --> 00:11:35,680
our cluster

00:11:33,360 --> 00:11:37,200
so uh if to compare partitioning you

00:11:35,680 --> 00:11:38,880
know to

00:11:37,200 --> 00:11:40,560
kind of to the way how the data is

00:11:38,880 --> 00:11:42,320
stored by relational

00:11:40,560 --> 00:11:44,720
like legacy relational databases

00:11:42,320 --> 00:11:46,560
classical relational databases

00:11:44,720 --> 00:11:48,399
usually all the records will be stored

00:11:46,560 --> 00:11:50,320
on a single machine

00:11:48,399 --> 00:11:51,920
and at the goal of the partitioning is

00:11:50,320 --> 00:11:54,720
to take all those records

00:11:51,920 --> 00:11:55,600
and distribute them across a cluster of

00:11:54,720 --> 00:11:58,800
the nodes

00:11:55,600 --> 00:11:59,440
as it's shown on this slide and today

00:11:58,800 --> 00:12:02,160
i'm going to

00:11:59,440 --> 00:12:02,720
give you an example of one uh database

00:12:02,160 --> 00:12:05,760
schema

00:12:02,720 --> 00:12:06,320
role database that schema keeps all

00:12:05,760 --> 00:12:08,560
their

00:12:06,320 --> 00:12:10,399
countries that we have in this world and

00:12:08,560 --> 00:12:12,079
also it keeps all the cities that are

00:12:10,399 --> 00:12:14,000
located in these countries and also

00:12:12,079 --> 00:12:16,639
there is the table country language

00:12:14,000 --> 00:12:17,519
that basically records what languages

00:12:16,639 --> 00:12:19,360
people speak

00:12:17,519 --> 00:12:21,279
who live in let's say country a or

00:12:19,360 --> 00:12:22,800
country b

00:12:21,279 --> 00:12:24,639
and what will happen with the

00:12:22,800 --> 00:12:25,120
partitioning let's say right now i want

00:12:24,639 --> 00:12:27,600
to

00:12:25,120 --> 00:12:30,000
deploy the schema in my distributed in

00:12:27,600 --> 00:12:31,200
memory database such as apache ignite or

00:12:30,000 --> 00:12:33,839
anything else

00:12:31,200 --> 00:12:34,959
and what i as an as a developer our

00:12:33,839 --> 00:12:38,320
architect

00:12:34,959 --> 00:12:39,360
architect need to do first of all i just

00:12:38,320 --> 00:12:41,680
need to create

00:12:39,360 --> 00:12:42,880
table and i can use standard sql

00:12:41,680 --> 00:12:45,440
iteration for that

00:12:42,880 --> 00:12:46,399
here is i'm creating table country uh

00:12:45,440 --> 00:12:48,240
that's what i do

00:12:46,399 --> 00:12:50,160
and what happens internally internally

00:12:48,240 --> 00:12:52,160
the partitioning algorithm

00:12:50,160 --> 00:12:54,639
will create this table and split this

00:12:52,160 --> 00:12:57,279
table into a fixed number of partitions

00:12:54,639 --> 00:12:57,839
there will be partition one two like

00:12:57,279 --> 00:13:00,560
three

00:12:57,839 --> 00:13:01,839
four like up to some maximum number for

00:13:00,560 --> 00:13:03,920
instance in ignite

00:13:01,839 --> 00:13:06,240
the maximum default number of partitions

00:13:03,920 --> 00:13:08,480
is 1024

00:13:06,240 --> 00:13:10,079
once this partitioning one this once

00:13:08,480 --> 00:13:11,600
this step is completed all those

00:13:10,079 --> 00:13:14,320
partitions will be

00:13:11,600 --> 00:13:15,920
spread across uh the current cluster so

00:13:14,320 --> 00:13:16,959
some of the partitions will be assigned

00:13:15,920 --> 00:13:18,800
to node one

00:13:16,959 --> 00:13:20,560
the other partitions will be assigned to

00:13:18,800 --> 00:13:22,720
the other node the goal of this

00:13:20,560 --> 00:13:24,639
partitioning algorithm algorithm is not

00:13:22,720 --> 00:13:26,880
only to split the partition

00:13:24,639 --> 00:13:28,880
your table into partitions but also then

00:13:26,880 --> 00:13:32,720
assign all those partitions

00:13:28,880 --> 00:13:34,720
evenly across your existing cluster

00:13:32,720 --> 00:13:36,240
and the next obvious step once we

00:13:34,720 --> 00:13:39,279
created

00:13:36,240 --> 00:13:41,279
uh such such table

00:13:39,279 --> 00:13:44,880
and once the table was partitioned for

00:13:41,279 --> 00:13:47,440
us we as application developers

00:13:44,880 --> 00:13:48,000
would insert the very first record there

00:13:47,440 --> 00:13:49,920
and again

00:13:48,000 --> 00:13:52,639
here is what we are doing we just

00:13:49,920 --> 00:13:55,360
executing this insert into country

00:13:52,639 --> 00:13:57,199
command and then internally what happens

00:13:55,360 --> 00:14:00,240
the partitioning algorithm

00:13:57,199 --> 00:14:02,959
will take the primary key of

00:14:00,240 --> 00:14:04,160
your record will map this primary key to

00:14:02,959 --> 00:14:07,360
a partition number

00:14:04,160 --> 00:14:10,000
using special hash function and

00:14:07,360 --> 00:14:11,360
after that once the partition is found

00:14:10,000 --> 00:14:13,279
uh

00:14:11,360 --> 00:14:15,440
your application will connect to one of

00:14:13,279 --> 00:14:16,160
the cluster nodes and will put this

00:14:15,440 --> 00:14:18,720
record

00:14:16,160 --> 00:14:20,720
into like into the node that stores the

00:14:18,720 --> 00:14:22,880
primary copy of this partition

00:14:20,720 --> 00:14:25,519
so if we take this record into as an

00:14:22,880 --> 00:14:27,760
example we are inserting the value for

00:14:25,519 --> 00:14:30,320
the united states let's assume that we

00:14:27,760 --> 00:14:32,800
know that code is the primary key

00:14:30,320 --> 00:14:35,199
and let's assume that this primary key

00:14:32,800 --> 00:14:36,800
was mapped to partition number five and

00:14:35,199 --> 00:14:40,000
this partition right now

00:14:36,800 --> 00:14:42,000
is located on node on the third node and

00:14:40,000 --> 00:14:42,399
that's why that record will be placed

00:14:42,000 --> 00:14:45,199
there

00:14:42,399 --> 00:14:46,079
again what's our responsibility here we

00:14:45,199 --> 00:14:48,480
are just

00:14:46,079 --> 00:14:49,680
executing this insert statement command

00:14:48,480 --> 00:14:53,120
and our distributed

00:14:49,680 --> 00:14:55,279
memory platform okay database basically

00:14:53,120 --> 00:14:58,560
maps this record to a partition

00:14:55,279 --> 00:15:00,320
and then puts this record on the node

00:14:58,560 --> 00:15:03,279
that owns the primary copy of this

00:15:00,320 --> 00:15:05,360
partition it's all easy right

00:15:03,279 --> 00:15:06,320
uh let now let me before we are diving

00:15:05,360 --> 00:15:08,240
into the

00:15:06,320 --> 00:15:10,160
second essential capability of

00:15:08,240 --> 00:15:13,199
distributed memory systems

00:15:10,160 --> 00:15:15,680
let me show you how this partitioning uh

00:15:13,199 --> 00:15:18,240
works in practice so what i've prepared

00:15:15,680 --> 00:15:18,240
so far

00:15:18,639 --> 00:15:25,279
uh i'm going to start a distributed

00:15:22,959 --> 00:15:26,880
ignite cluster on my local machine i'm

00:15:25,279 --> 00:15:28,880
using one of the latest versions of a

00:15:26,880 --> 00:15:31,839
piece ignite

00:15:28,880 --> 00:15:33,440
all right so um i'm starting it right

00:15:31,839 --> 00:15:35,600
now

00:15:33,440 --> 00:15:37,519
the first node is ready so i have only

00:15:35,600 --> 00:15:38,560
one server node a server node is

00:15:37,519 --> 00:15:41,199
basically

00:15:38,560 --> 00:15:41,759
uh our container for data so that's

00:15:41,199 --> 00:15:44,160
actually

00:15:41,759 --> 00:15:45,600
a group of server nodes define and form

00:15:44,160 --> 00:15:48,240
a distributed cluster

00:15:45,600 --> 00:15:50,160
that's my first server node and let me

00:15:48,240 --> 00:15:53,920
start another node because at least i

00:15:50,160 --> 00:15:54,399
want to have two and two node cluster

00:15:53,920 --> 00:15:56,079
all right

00:15:54,399 --> 00:15:58,399
wonderful so right now i've got this

00:15:56,079 --> 00:16:02,959
cluster

00:15:58,399 --> 00:16:05,759
and let me see i also i'm going to use

00:16:02,959 --> 00:16:07,680
this management console that is

00:16:05,759 --> 00:16:09,920
available for ignite

00:16:07,680 --> 00:16:12,480
deployments if i'm going to the

00:16:09,920 --> 00:16:14,160
monitoring dashboard

00:16:12,480 --> 00:16:15,519
i should be able to connect to my

00:16:14,160 --> 00:16:17,600
locally running cluster

00:16:15,519 --> 00:16:19,360
this version of the tool is running

00:16:17,600 --> 00:16:22,639
somewhere

00:16:19,360 --> 00:16:25,600
in the cloud but what i see here yes

00:16:22,639 --> 00:16:27,360
here's a i've got two nodes cluster i

00:16:25,600 --> 00:16:29,440
don't have any data i don't think

00:16:27,360 --> 00:16:31,759
i have not created any caches or tables

00:16:29,440 --> 00:16:35,440
it's just just empty cluster that stays

00:16:31,759 --> 00:16:37,360
idle and then the next

00:16:35,440 --> 00:16:40,160
as long as we have just you know talked

00:16:37,360 --> 00:16:43,120
about partitioning

00:16:40,160 --> 00:16:45,199
let me load some data into this cluster

00:16:43,120 --> 00:16:46,639
especially that world database and then

00:16:45,199 --> 00:16:49,199
they can see how the data was

00:16:46,639 --> 00:16:50,959
distributed for us

00:16:49,199 --> 00:16:53,040
i'm going to connect to the cluster

00:16:50,959 --> 00:16:53,920
using this command i'm going to use sql

00:16:53,040 --> 00:16:57,440
line tool

00:16:53,920 --> 00:17:00,399
and uh ignite jdbc driver that's my

00:16:57,440 --> 00:17:02,160
cluster so let me connect to it

00:17:00,399 --> 00:17:04,480
all right it says that they are

00:17:02,160 --> 00:17:07,839
connected if i execute

00:17:04,480 --> 00:17:10,000
tables command i don't see any i don't

00:17:07,839 --> 00:17:14,640
have any tables for now

00:17:10,000 --> 00:17:14,640
and next let me load this script

00:17:15,520 --> 00:17:20,559
i'll show you its content well the

00:17:17,439 --> 00:17:23,039
script is being loaded

00:17:20,559 --> 00:17:24,959
so the script is as follows so generally

00:17:23,039 --> 00:17:26,959
we are creating that country table that

00:17:24,959 --> 00:17:28,000
i've already mentioned the creative city

00:17:26,959 --> 00:17:29,679
table others

00:17:28,000 --> 00:17:31,120
and then basically we are inserting all

00:17:29,679 --> 00:17:34,880
these records just

00:17:31,120 --> 00:17:36,960
standard loading procedure

00:17:34,880 --> 00:17:38,480
all right the table is loaded if i

00:17:36,960 --> 00:17:41,200
execute

00:17:38,480 --> 00:17:41,600
tables command again i've got them here

00:17:41,200 --> 00:17:44,840
and

00:17:41,600 --> 00:17:47,840
if i'm jumping back to their monitoring

00:17:44,840 --> 00:17:50,720
tool

00:17:47,840 --> 00:17:52,400
yep i can see them here under the caches

00:17:50,720 --> 00:17:53,600
it might sound confusing for you but

00:17:52,400 --> 00:17:56,559
generally in ignite

00:17:53,600 --> 00:17:58,000
cache and tables term i use like they

00:17:56,559 --> 00:18:00,559
are the same i mean

00:17:58,000 --> 00:18:02,480
you usually use caches if you're using

00:18:00,559 --> 00:18:04,640
key value apis and you use tables if

00:18:02,480 --> 00:18:06,960
you're running sql queries but anyway

00:18:04,640 --> 00:18:07,840
i've created these tables there are some

00:18:06,960 --> 00:18:10,080
records

00:18:07,840 --> 00:18:12,480
and the next step is partitioning how

00:18:10,080 --> 00:18:14,960
the data was partitioned to do that

00:18:12,480 --> 00:18:16,080
uh let me see the partitioning

00:18:14,960 --> 00:18:20,960
distribution for the

00:18:16,080 --> 00:18:20,960
city table i'm clicking on partitions

00:18:24,240 --> 00:18:29,120
and that's what we've got 514 partitions

00:18:27,200 --> 00:18:32,880
allocated on one node

00:18:29,120 --> 00:18:35,280
and the rest is placed on the other node

00:18:32,880 --> 00:18:37,280
so if you want to see how many keys or

00:18:35,280 --> 00:18:39,600
records are located in every partition

00:18:37,280 --> 00:18:44,240
you can use this table down below

00:18:39,600 --> 00:18:46,160
let me sort it by their partition number

00:18:44,240 --> 00:18:48,640
so like we have three records in

00:18:46,160 --> 00:18:50,640
partition zero four records in partition

00:18:48,640 --> 00:18:52,160
three etc so generally all this magic

00:18:50,640 --> 00:18:54,320
happened internally

00:18:52,160 --> 00:18:56,400
this is how it works in ignite and this

00:18:54,320 --> 00:18:56,799
is basically how it will be supported

00:18:56,400 --> 00:18:58,880
and

00:18:56,799 --> 00:19:00,640
working in any other distributed memory

00:18:58,880 --> 00:19:03,200
system and why should you know

00:19:00,640 --> 00:19:05,280
why should be aware about this partition

00:19:03,200 --> 00:19:05,600
so generally your goal the partitioning

00:19:05,280 --> 00:19:07,120
is

00:19:05,600 --> 00:19:08,880
kind of something that is supported

00:19:07,120 --> 00:19:10,559
internally and your goal is just

00:19:08,880 --> 00:19:14,400
basically you know to

00:19:10,559 --> 00:19:14,880
uh be aware that initially you can have

00:19:14,400 --> 00:19:16,720
just two

00:19:14,880 --> 00:19:18,000
two nodes cluster and then whenever you

00:19:16,720 --> 00:19:20,480
want to

00:19:18,000 --> 00:19:22,320
scale out just add new nodes and your

00:19:20,480 --> 00:19:24,400
distributed memory systems such as

00:19:22,320 --> 00:19:26,480
apache ignite will kind of

00:19:24,400 --> 00:19:28,400
redistribute these partitions and you

00:19:26,480 --> 00:19:31,520
will be able to utilize

00:19:28,400 --> 00:19:32,960
much more memory and many more cpus all

00:19:31,520 --> 00:19:35,679
right

00:19:32,960 --> 00:19:36,559
having said that let's move on the the

00:19:35,679 --> 00:19:40,080
second

00:19:36,559 --> 00:19:43,039
essential capability of

00:19:40,080 --> 00:19:45,039
distributed memory systems because uh

00:19:43,039 --> 00:19:46,480
you know partitioning does a lot of hard

00:19:45,039 --> 00:19:48,400
work

00:19:46,480 --> 00:19:50,480
by distributing our records and the

00:19:48,400 --> 00:19:51,440
partitioning algorithms are trying to do

00:19:50,480 --> 00:19:53,600
the seemingly

00:19:51,440 --> 00:19:56,000
but also there are some of the occasions

00:19:53,600 --> 00:19:56,880
when a distributed system such as apache

00:19:56,000 --> 00:20:00,400
ignite

00:19:56,880 --> 00:20:02,159
need your help to to kind of to help

00:20:00,400 --> 00:20:04,159
your help you know to distribute the

00:20:02,159 --> 00:20:05,679
records uh

00:20:04,159 --> 00:20:08,000
more naturally you have to put it this

00:20:05,679 --> 00:20:09,200
way so let's take this example

00:20:08,000 --> 00:20:12,159
what happens with the default

00:20:09,200 --> 00:20:14,400
partitioning uh algorithm

00:20:12,159 --> 00:20:16,400
uh in this example i have two tables i

00:20:14,400 --> 00:20:17,520
have country table and city table you

00:20:16,400 --> 00:20:20,320
can see that

00:20:17,520 --> 00:20:21,679
uh canada and france like the records of

00:20:20,320 --> 00:20:24,799
canada and france are okay

00:20:21,679 --> 00:20:27,039
allocated on two different nodes

00:20:24,799 --> 00:20:28,640
and when it comes to the city table also

00:20:27,039 --> 00:20:30,240
all those cities are distributed

00:20:28,640 --> 00:20:32,960
randomly

00:20:30,240 --> 00:20:34,000
and there is we can we might end up

00:20:32,960 --> 00:20:37,200
having one one

00:20:34,000 --> 00:20:39,600
problem so it might happen that some

00:20:37,200 --> 00:20:40,240
canadian cities such as monreal or a

00:20:39,600 --> 00:20:42,559
tower

00:20:40,240 --> 00:20:44,559
they are highlighted in yellow they are

00:20:42,559 --> 00:20:46,640
located on a different node they are not

00:20:44,559 --> 00:20:47,200
stored together with all these canadian

00:20:46,640 --> 00:20:50,080
cities

00:20:47,200 --> 00:20:51,039
and the same is true about uh french

00:20:50,080 --> 00:20:53,280
cities

00:20:51,039 --> 00:20:55,679
paris is not stored together on the same

00:20:53,280 --> 00:20:57,840
machine where we have the primary

00:20:55,679 --> 00:21:00,000
record to friends and this default

00:20:57,840 --> 00:21:00,480
distribution might be not a big deal for

00:21:00,000 --> 00:21:02,000
you

00:21:00,480 --> 00:21:03,679
especially if you are not using any

00:21:02,000 --> 00:21:05,760
complex queries but

00:21:03,679 --> 00:21:07,039
if it happens that you need to execute

00:21:05,760 --> 00:21:10,640
any complex queries

00:21:07,039 --> 00:21:12,640
such as sql with joins then you need to

00:21:10,640 --> 00:21:14,400
to do something about this distribution

00:21:12,640 --> 00:21:17,360
for instance what happens in this

00:21:14,400 --> 00:21:19,120
example let's say that all the cities

00:21:17,360 --> 00:21:20,880
were distributed randomly

00:21:19,120 --> 00:21:22,400
we were not involved in the data

00:21:20,880 --> 00:21:25,120
distribution

00:21:22,400 --> 00:21:26,159
and when i'm executing this sql query uh

00:21:25,120 --> 00:21:29,760
which returns

00:21:26,159 --> 00:21:31,840
the most populated cities across

00:21:29,760 --> 00:21:34,080
canada and france the following will

00:21:31,840 --> 00:21:35,039
happen our application will connect to

00:21:34,080 --> 00:21:37,039
the cluster

00:21:35,039 --> 00:21:40,799
it will send this query to those two

00:21:37,039 --> 00:21:43,760
nodes and then during the join phase

00:21:40,799 --> 00:21:45,120
uh paris ottawa and monreal will be

00:21:43,760 --> 00:21:47,440
shuffled between those right

00:21:45,120 --> 00:21:49,679
between those nodes because the first

00:21:47,440 --> 00:21:50,720
node need all the canadian cities to

00:21:49,679 --> 00:21:53,440
complete

00:21:50,720 --> 00:21:54,559
its joint phase and the second node

00:21:53,440 --> 00:21:56,880
needs all the

00:21:54,559 --> 00:21:57,679
french cities to complete its joint

00:21:56,880 --> 00:22:00,000
phase

00:21:57,679 --> 00:22:01,760
and this data shuffling thing can be

00:22:00,000 --> 00:22:04,000
really problematic for distributed

00:22:01,760 --> 00:22:05,679
memory systems because

00:22:04,000 --> 00:22:07,039
in this example we are shuffling just

00:22:05,679 --> 00:22:09,520
three records but

00:22:07,039 --> 00:22:11,360
usually in the real world you would be

00:22:09,520 --> 00:22:12,880
kind of joining thousands if not

00:22:11,360 --> 00:22:15,360
millions of records

00:22:12,880 --> 00:22:15,919
which can provoke the data shuffling of

00:22:15,360 --> 00:22:17,520
let's say

00:22:15,919 --> 00:22:19,840
like hundreds of thousands of other

00:22:17,520 --> 00:22:20,559
records and the network is extremely

00:22:19,840 --> 00:22:23,679
slow

00:22:20,559 --> 00:22:25,039
and uh basically how slow network the

00:22:23,679 --> 00:22:28,080
network is

00:22:25,039 --> 00:22:30,720
let's go back to the same

00:22:28,080 --> 00:22:32,080
table we used at the beginning of our

00:22:30,720 --> 00:22:35,039
conversation

00:22:32,080 --> 00:22:36,799
so that time i pointed out that memory

00:22:35,039 --> 00:22:39,520
is much faster than disk

00:22:36,799 --> 00:22:40,159
but this is much faster than network

00:22:39,520 --> 00:22:41,919
that's why

00:22:40,159 --> 00:22:44,159
let's say if it happens that you

00:22:41,919 --> 00:22:45,520
distribute it like fancy and speedy and

00:22:44,159 --> 00:22:47,440
memory system

00:22:45,520 --> 00:22:49,440
uh kind of executes some of the

00:22:47,440 --> 00:22:51,679
operations that

00:22:49,440 --> 00:22:54,159
shuffle a lot large data sets across the

00:22:51,679 --> 00:22:55,919
network you can diminish or kill all the

00:22:54,159 --> 00:22:58,159
memory benefits of your system because

00:22:55,919 --> 00:23:00,000
network is extremely slow

00:22:58,159 --> 00:23:01,760
and how can we fix this situation

00:23:00,000 --> 00:23:03,679
because in this case it's natural we

00:23:01,760 --> 00:23:04,799
know the relation between countries and

00:23:03,679 --> 00:23:07,120
cities

00:23:04,799 --> 00:23:09,600
and somehow i want to ensure that my

00:23:07,120 --> 00:23:12,640
cluster my distributed memory system

00:23:09,600 --> 00:23:15,520
will keep all the related

00:23:12,640 --> 00:23:17,360
cities on the same machine so i want to

00:23:15,520 --> 00:23:19,760
achieve this distribution

00:23:17,360 --> 00:23:21,919
like you see on this screen and all we

00:23:19,760 --> 00:23:22,400
need to do is application developers is

00:23:21,919 --> 00:23:25,440
to do

00:23:22,400 --> 00:23:25,679
one little change let's take a look at

00:23:25,440 --> 00:23:28,240
it

00:23:25,679 --> 00:23:30,640
so we have this country table that we

00:23:28,240 --> 00:23:32,960
it's all simple we just need to have

00:23:30,640 --> 00:23:34,799
the primary key which is the code but

00:23:32,960 --> 00:23:36,159
when it comes to the city table we need

00:23:34,799 --> 00:23:38,480
to do a little modification

00:23:36,159 --> 00:23:39,520
a small modification so in addition to

00:23:38,480 --> 00:23:42,799
the primary key

00:23:39,520 --> 00:23:44,720
which will be a compound primary key

00:23:42,799 --> 00:23:46,960
which consists of the id and country

00:23:44,720 --> 00:23:48,159
code values i am going to introduce the

00:23:46,960 --> 00:23:50,559
affinity key

00:23:48,159 --> 00:23:52,240
which is equal to the country code and

00:23:50,559 --> 00:23:54,799
the goal of the affinity key

00:23:52,240 --> 00:23:57,279
is to help our partitioning algorithm to

00:23:54,799 --> 00:23:59,840
decide where to place all the sieges

00:23:57,279 --> 00:24:01,840
so when you will be the next time when

00:23:59,840 --> 00:24:02,880
you will be inserting all these records

00:24:01,840 --> 00:24:04,799
cities

00:24:02,880 --> 00:24:06,159
in the cluster the partitioning

00:24:04,799 --> 00:24:09,120
algorithm

00:24:06,159 --> 00:24:10,400
will be the value of the affinity key to

00:24:09,120 --> 00:24:13,679
desire

00:24:10,400 --> 00:24:16,240
uh to put your uh city and it's not

00:24:13,679 --> 00:24:18,880
surprising that all the cities

00:24:16,240 --> 00:24:20,240
in the same country have the same value

00:24:18,880 --> 00:24:23,520
of the country code

00:24:20,240 --> 00:24:25,440
and as a result the algorithm will group

00:24:23,520 --> 00:24:26,960
together and place together all those

00:24:25,440 --> 00:24:28,080
cities on the same machine that's what

00:24:26,960 --> 00:24:31,520
we want to achieve

00:24:28,080 --> 00:24:32,080
okay once you do this once and once you

00:24:31,520 --> 00:24:35,200
execute

00:24:32,080 --> 00:24:37,919
the same query over

00:24:35,200 --> 00:24:38,320
this data set you will no longer have

00:24:37,919 --> 00:24:40,640
any

00:24:38,320 --> 00:24:42,080
data shafting phase because when those

00:24:40,640 --> 00:24:45,200
two nodes will be

00:24:42,080 --> 00:24:47,120
performing the joining join phase uh

00:24:45,200 --> 00:24:48,880
joining table and country tables all the

00:24:47,120 --> 00:24:50,880
data will be local for them

00:24:48,880 --> 00:24:52,559
and there is no any need to shuffle

00:24:50,880 --> 00:24:54,640
anything and this way

00:24:52,559 --> 00:24:55,919
the performance will be truly dramatic

00:24:54,640 --> 00:24:59,039
and as a result

00:24:55,919 --> 00:25:00,799
once you apply and once you take

00:24:59,039 --> 00:25:01,919
advantage of this affinity collocation

00:25:00,799 --> 00:25:04,480
concept

00:25:01,919 --> 00:25:06,080
uh you will be able to kind of use all

00:25:04,480 --> 00:25:07,520
the resources of your cluster and you

00:25:06,080 --> 00:25:09,440
will be able to run

00:25:07,520 --> 00:25:10,720
really fast sql queries so any other

00:25:09,440 --> 00:25:14,720
complex operations

00:25:10,720 --> 00:25:18,000
okay so right now let's uh

00:25:14,720 --> 00:25:18,559
kind of check another demo i'm going to

00:25:18,000 --> 00:25:22,960
use

00:25:18,559 --> 00:25:25,120
uh the same apache ignite cluster

00:25:22,960 --> 00:25:27,440
uh that i've started earlier i have two

00:25:25,120 --> 00:25:31,279
node cluster

00:25:27,440 --> 00:25:33,600
but the next thing i want to reload this

00:25:31,279 --> 00:25:34,960
table now let me do this let me first

00:25:33,600 --> 00:25:38,720
connect

00:25:34,960 --> 00:25:38,720
let me first show you

00:25:38,960 --> 00:25:42,000
some of the queries i prepared some of

00:25:41,279 --> 00:25:45,440
the queries for

00:25:42,000 --> 00:25:47,520
this uh specific world schema

00:25:45,440 --> 00:25:49,440
so the very first query let's use it

00:25:47,520 --> 00:25:51,760
just to double check that everything

00:25:49,440 --> 00:25:53,440
works as expected i am going to return

00:25:51,760 --> 00:25:54,640
the most populated countries in the

00:25:53,440 --> 00:25:57,520
world china india

00:25:54,640 --> 00:25:58,240
and the united states uh uh the rank

00:25:57,520 --> 00:26:01,039
first oh

00:25:58,240 --> 00:26:02,559
sorry my kid is my kid is trying to

00:26:01,039 --> 00:26:05,600
meddle in

00:26:02,559 --> 00:26:09,200
uh and next

00:26:05,600 --> 00:26:10,960
the second query is uh that's the query

00:26:09,200 --> 00:26:14,480
that we explored from the slides

00:26:10,960 --> 00:26:15,520
here is i want to get the most populated

00:26:14,480 --> 00:26:17,279
cities

00:26:15,520 --> 00:26:20,000
not only across the united states and

00:26:17,279 --> 00:26:24,000
france but across all these countries

00:26:20,000 --> 00:26:26,559
and this query involves the join phase

00:26:24,000 --> 00:26:28,240
okay there is some exception probably

00:26:26,559 --> 00:26:28,880
there is there was some issue with this

00:26:28,240 --> 00:26:31,039
tool

00:26:28,880 --> 00:26:32,640
yeah it's fixed so generally if i

00:26:31,039 --> 00:26:34,480
execute this query

00:26:32,640 --> 00:26:37,039
this is supposed to be a correct result

00:26:34,480 --> 00:26:39,600
set like sews and power

00:26:37,039 --> 00:26:40,960
and mexico city but in fact that's not

00:26:39,600 --> 00:26:42,400
the correct result set

00:26:40,960 --> 00:26:44,480
because i know that the data is not

00:26:42,400 --> 00:26:46,559
stored together it's not collocated

00:26:44,480 --> 00:26:47,679
if i want to see correct result set i

00:26:46,559 --> 00:26:49,600
need to allow

00:26:47,679 --> 00:26:52,240
apache ignite cluster the apache net

00:26:49,600 --> 00:26:54,000
cluster to do the data shuffling between

00:26:52,240 --> 00:26:56,960
the nodes during the join phase

00:26:54,000 --> 00:26:58,799
and i do this by enabling this option

00:26:56,960 --> 00:27:01,200
allow non-collocated joins

00:26:58,799 --> 00:27:01,919
it can sound it can sound odd but that's

00:27:01,200 --> 00:27:04,320
how

00:27:01,919 --> 00:27:06,960
how it's named right now and right now

00:27:04,320 --> 00:27:08,480
if i execute the same query first of all

00:27:06,960 --> 00:27:10,960
it took much more time for me to

00:27:08,480 --> 00:27:11,919
complete it but at least right now i see

00:27:10,960 --> 00:27:14,559
the correct

00:27:11,919 --> 00:27:16,720
answer cyrus and paul and shanghai are

00:27:14,559 --> 00:27:19,039
the most populated cities

00:27:16,720 --> 00:27:21,039
across those countries and usually on

00:27:19,039 --> 00:27:22,960
average it takes me like once one second

00:27:21,039 --> 00:27:26,399
to two seconds to complete this

00:27:22,960 --> 00:27:26,880
operation now let's fix that this

00:27:26,399 --> 00:27:30,080
happens

00:27:26,880 --> 00:27:32,080
like this performance is so poor because

00:27:30,080 --> 00:27:33,440
uh i'm shuffling the data between the

00:27:32,080 --> 00:27:36,960
nodes

00:27:33,440 --> 00:27:40,720
but i know that i can easily fix it

00:27:36,960 --> 00:27:45,039
i'm going to open

00:27:40,720 --> 00:27:46,000
this schema i've let me find this city

00:27:45,039 --> 00:27:47,919
table

00:27:46,000 --> 00:27:49,600
and here is i have primary key i see

00:27:47,919 --> 00:27:53,520
i'll already see that id

00:27:49,600 --> 00:27:56,480
and country code uh comprise my

00:27:53,520 --> 00:27:58,880
primary key uh but at the same time i

00:27:56,480 --> 00:28:02,320
don't have affinity key the affinity

00:27:58,880 --> 00:28:05,039
yet let me define it affinity key

00:28:02,320 --> 00:28:05,360
and i want the affinity key to be equal

00:28:05,039 --> 00:28:08,960
to

00:28:05,360 --> 00:28:10,960
country code once i do this then all the

00:28:08,960 --> 00:28:13,039
records of the cities that have the same

00:28:10,960 --> 00:28:14,880
value of the country code will be placed

00:28:13,039 --> 00:28:16,080
and grouped together on the same node

00:28:14,880 --> 00:28:19,200
that's my goal

00:28:16,080 --> 00:28:21,520
that's what i want to achieve

00:28:19,200 --> 00:28:24,080
all right and right now let me execute

00:28:21,520 --> 00:28:27,360
this script

00:28:24,080 --> 00:28:27,360
the name is different

00:28:27,600 --> 00:28:32,320
i'm restarting i drop the tables i am

00:28:30,080 --> 00:28:35,600
reloading these tables because i changed

00:28:32,320 --> 00:28:35,600
the data distribution

00:28:36,240 --> 00:28:40,240
and but right now if i go back to the

00:28:38,640 --> 00:28:42,559
screen so first of all

00:28:40,240 --> 00:28:44,320
remember that civil senpai and shanghai

00:28:42,559 --> 00:28:45,440
are the most populated cities that's the

00:28:44,320 --> 00:28:47,200
correct answer

00:28:45,440 --> 00:28:49,120
i no longer this data shuffling i no

00:28:47,200 --> 00:28:51,039
longer need this data shuffling option

00:28:49,120 --> 00:28:53,919
so i'm

00:28:51,039 --> 00:28:54,320
removing it just in case let me refresh

00:28:53,919 --> 00:28:59,760
this

00:28:54,320 --> 00:29:02,720
browser screen

00:28:59,760 --> 00:29:05,200
sql and right now if i execute the same

00:29:02,720 --> 00:29:05,200
query

00:29:05,840 --> 00:29:09,200
you can see that it takes me nine

00:29:07,440 --> 00:29:10,720
seconds but like like 40

00:29:09,200 --> 00:29:12,640
milliseconds so like like just

00:29:10,720 --> 00:29:13,520
milliseconds range to get the same

00:29:12,640 --> 00:29:15,679
result set

00:29:13,520 --> 00:29:17,440
see wilson paul and shanghai and what

00:29:15,679 --> 00:29:18,080
i've done i just you know calculated the

00:29:17,440 --> 00:29:19,840
data

00:29:18,080 --> 00:29:21,279
using the knowledge about the data

00:29:19,840 --> 00:29:22,880
relation that's it

00:29:21,279 --> 00:29:24,960
and that's actually how you need to

00:29:22,880 --> 00:29:26,159
approach all those distributed and

00:29:24,960 --> 00:29:28,320
memory systems

00:29:26,159 --> 00:29:29,760
because by definition they're designed

00:29:28,320 --> 00:29:31,919
to keep your data

00:29:29,760 --> 00:29:33,679
across a cluster of machines in memory

00:29:31,919 --> 00:29:36,000
and that promises a lot

00:29:33,679 --> 00:29:37,679
but if you also have to be involved and

00:29:36,000 --> 00:29:39,919
that's why the second that essential

00:29:37,679 --> 00:29:41,039
capability which is affinity collocation

00:29:39,919 --> 00:29:42,960
or data grouping

00:29:41,039 --> 00:29:46,480
have to be in your toolbox because you

00:29:42,960 --> 00:29:49,039
know only you know your kind of domain

00:29:46,480 --> 00:29:50,720
logic uh and you need to help the

00:29:49,039 --> 00:29:53,360
partitioning algorithm

00:29:50,720 --> 00:29:55,200
to distribute your records properly and

00:29:53,360 --> 00:29:57,520
once you collocate the records then you

00:29:55,200 --> 00:29:58,240
can run any complex operation let it be

00:29:57,520 --> 00:30:02,880
joined

00:29:58,240 --> 00:30:02,880
let it be any other compute tasks

00:30:03,360 --> 00:30:06,960
and that's how we are coming to the

00:30:05,440 --> 00:30:10,480
final

00:30:06,960 --> 00:30:13,200
topic uh calculated computations

00:30:10,480 --> 00:30:14,799
so with the previous example we've seen

00:30:13,200 --> 00:30:18,080
that we helped to speed up

00:30:14,799 --> 00:30:19,200
our sql operations that uh use joins but

00:30:18,080 --> 00:30:21,360
at the same time

00:30:19,200 --> 00:30:22,640
you might deal with some complex

00:30:21,360 --> 00:30:25,440
business operations

00:30:22,640 --> 00:30:27,120
which are multi-step operations what i

00:30:25,440 --> 00:30:27,840
mean here let's say that you're trying

00:30:27,120 --> 00:30:30,960
to

00:30:27,840 --> 00:30:33,200
uh do you like i can

00:30:30,960 --> 00:30:34,399
see here is i can speak about one one

00:30:33,200 --> 00:30:36,559
real use case

00:30:34,399 --> 00:30:38,559
one of the well-known banks uh they

00:30:36,559 --> 00:30:39,200
store millions and millions of savings

00:30:38,559 --> 00:30:41,760
account

00:30:39,200 --> 00:30:42,880
in a distributed in memory cluster and

00:30:41,760 --> 00:30:45,200
then once a month

00:30:42,880 --> 00:30:46,880
uh they need to perform one kind of

00:30:45,200 --> 00:30:48,720
financial alteration they need to

00:30:46,880 --> 00:30:51,440
traverse all those

00:30:48,720 --> 00:30:52,799
uh savings accounts do some checks do

00:30:51,440 --> 00:30:55,039
some calculations

00:30:52,799 --> 00:30:57,039
and then apply an interest rate for

00:30:55,039 --> 00:31:00,480
every account ever and write down all

00:30:57,039 --> 00:31:02,720
those changes back to the ignite cluster

00:31:00,480 --> 00:31:05,039
so generally that operation involves

00:31:02,720 --> 00:31:07,200
many kind of round trips like sql key

00:31:05,039 --> 00:31:10,080
value transactions etc

00:31:07,200 --> 00:31:11,360
and historically before that company

00:31:10,080 --> 00:31:15,039
moved to

00:31:11,360 --> 00:31:16,559
ignite they used oracle database or like

00:31:15,039 --> 00:31:18,880
any other relational database and they

00:31:16,559 --> 00:31:21,600
would run this operation once

00:31:18,880 --> 00:31:23,120
once a month late night when the load on

00:31:21,600 --> 00:31:25,360
the system was minimal

00:31:23,120 --> 00:31:26,960
and with oracle database what happened

00:31:25,360 --> 00:31:28,240
there was a special application that

00:31:26,960 --> 00:31:29,120
application would connect to the

00:31:28,240 --> 00:31:31,519
database

00:31:29,120 --> 00:31:32,480
it would read all those million savings

00:31:31,519 --> 00:31:34,720
accounts

00:31:32,480 --> 00:31:35,919
uh to the application side and would do

00:31:34,720 --> 00:31:38,240
some calculations

00:31:35,919 --> 00:31:40,000
uh some financial checks apply the

00:31:38,240 --> 00:31:41,519
interest rate and then write back

00:31:40,000 --> 00:31:43,440
everything to work

00:31:41,519 --> 00:31:45,600
it took that company you know like more

00:31:43,440 --> 00:31:47,919
than two hours to complete this

00:31:45,600 --> 00:31:49,600
operation over like like one like one

00:31:47,919 --> 00:31:51,120
petabyte data set

00:31:49,600 --> 00:31:52,720
when they moved to apache ignite they

00:31:51,120 --> 00:31:54,000
deployed everything distributed in

00:31:52,720 --> 00:31:55,919
memory cluster

00:31:54,000 --> 00:31:58,240
and what they've changed after that they

00:31:55,919 --> 00:32:00,080
just kind of instead of using oracle

00:31:58,240 --> 00:32:00,720
operation they started using ignite sql

00:32:00,080 --> 00:32:02,960
queries

00:32:00,720 --> 00:32:04,880
yes they could speed up the calculation

00:32:02,960 --> 00:32:06,080
let's say from two hours to one one hour

00:32:04,880 --> 00:32:09,039
30 minutes

00:32:06,080 --> 00:32:10,960
like with ignite so there was a some

00:32:09,039 --> 00:32:12,720
change but it was not dramatic that was

00:32:10,960 --> 00:32:13,679
not a breakthrough and then we decided

00:32:12,720 --> 00:32:15,919
you know to

00:32:13,679 --> 00:32:17,200
do one change we decided to take this

00:32:15,919 --> 00:32:20,159
logic

00:32:17,200 --> 00:32:21,840
and send that logic for the execution to

00:32:20,159 --> 00:32:22,640
the cluster machine so that we don't

00:32:21,840 --> 00:32:24,640
need to move

00:32:22,640 --> 00:32:26,559
all those millions accounts from the

00:32:24,640 --> 00:32:28,960
cluster to the application

00:32:26,559 --> 00:32:30,960
and once they did this uh the

00:32:28,960 --> 00:32:31,760
performance like kind of spiked

00:32:30,960 --> 00:32:33,679
dramatically

00:32:31,760 --> 00:32:35,120
it took them like 10 or 15 minutes to

00:32:33,679 --> 00:32:37,919
complete the separation

00:32:35,120 --> 00:32:38,320
and before that operation was executed

00:32:37,919 --> 00:32:40,159
like

00:32:38,320 --> 00:32:42,240
it took them it was taking them like two

00:32:40,159 --> 00:32:42,960
hours to complete it with a relational

00:32:42,240 --> 00:32:44,480
database

00:32:42,960 --> 00:32:46,240
and here is we are talking not about

00:32:44,480 --> 00:32:47,279
that was not the problem of the database

00:32:46,240 --> 00:32:49,039
oracle database

00:32:47,279 --> 00:32:51,679
that was the problem of the network

00:32:49,039 --> 00:32:53,919
because with the relational database

00:32:51,679 --> 00:32:56,480
they were transferring all the data back

00:32:53,919 --> 00:32:58,320
and forth between the application and

00:32:56,480 --> 00:33:00,399
oracle while with ignite they don't need

00:32:58,320 --> 00:33:03,200
to transfer they just can create their

00:33:00,399 --> 00:33:04,799
custom logic written in java.net and

00:33:03,200 --> 00:33:08,960
execute it

00:33:04,799 --> 00:33:11,679
and that's that's we all know those apis

00:33:08,960 --> 00:33:12,640
uh those are mapreduce like apis hadoop

00:33:11,679 --> 00:33:15,360
historically

00:33:12,640 --> 00:33:16,000
supported them it has mapreduce engine

00:33:15,360 --> 00:33:18,080
and memory

00:33:16,000 --> 00:33:20,399
in many memory distributed systems such

00:33:18,080 --> 00:33:21,440
as apache ignite or any other databases

00:33:20,399 --> 00:33:23,519
they also

00:33:21,440 --> 00:33:25,679
give you an ability to create to execute

00:33:23,519 --> 00:33:26,960
your custom tasks written on java or

00:33:25,679 --> 00:33:29,120
that net let's say

00:33:26,960 --> 00:33:31,840
on your cluster so the logic is simple

00:33:29,120 --> 00:33:34,159
let's say you're creating

00:33:31,840 --> 00:33:35,120
a calculation that reads all the savings

00:33:34,159 --> 00:33:39,039
accounts

00:33:35,120 --> 00:33:40,559
and then does some calculations and

00:33:39,039 --> 00:33:42,720
implies that interest rate

00:33:40,559 --> 00:33:43,679
that's the example i used then you

00:33:42,720 --> 00:33:45,279
created this

00:33:43,679 --> 00:33:47,279
calculation then you send this

00:33:45,279 --> 00:33:48,159
calculation for the execution for your

00:33:47,279 --> 00:33:50,320
cluster

00:33:48,159 --> 00:33:52,320
then the second step all this logic gets

00:33:50,320 --> 00:33:55,360
executed on your cluster machine

00:33:52,320 --> 00:33:57,840
hopefully no no single bit of data

00:33:55,360 --> 00:33:59,760
will be moved back and forth between the

00:33:57,840 --> 00:34:00,480
server nodes or your applications and

00:33:59,760 --> 00:34:02,480
that's it

00:34:00,480 --> 00:34:04,080
and then in the end your application

00:34:02,480 --> 00:34:05,919
will get probably some you know tiny

00:34:04,080 --> 00:34:08,000
small result set and that's it that's

00:34:05,919 --> 00:34:08,639
like you eliminated that heavy network

00:34:08,000 --> 00:34:10,800
usage

00:34:08,639 --> 00:34:12,480
is your computer tasks and you're good

00:34:10,800 --> 00:34:14,800
to go

00:34:12,480 --> 00:34:15,599
as a summary uh in memory computing

00:34:14,800 --> 00:34:17,760
essentials

00:34:15,599 --> 00:34:19,280
today my goal was you know briefly to

00:34:17,760 --> 00:34:21,919
introduce you to the

00:34:19,280 --> 00:34:22,879
three essential capabilities that define

00:34:21,919 --> 00:34:24,879
i would say almost

00:34:22,879 --> 00:34:26,079
all the memory computing systems not

00:34:24,879 --> 00:34:28,560
only apache ignite

00:34:26,079 --> 00:34:30,399
the first one is data partitioning

00:34:28,560 --> 00:34:32,560
that's a crucial algorithm

00:34:30,399 --> 00:34:34,320
that will help you to utilize all the

00:34:32,560 --> 00:34:36,000
resources of your cluster let it be

00:34:34,320 --> 00:34:38,000
memory disk recipes

00:34:36,000 --> 00:34:39,599
the partitioning takes care of the data

00:34:38,000 --> 00:34:41,520
distribution you just

00:34:39,599 --> 00:34:43,440
have to be aware of how the partitioning

00:34:41,520 --> 00:34:45,440
works and how it can

00:34:43,440 --> 00:34:47,040
help you with your kind of scalability

00:34:45,440 --> 00:34:49,520
goals second

00:34:47,040 --> 00:34:50,480
uh essential feature of distributed

00:34:49,520 --> 00:34:53,760
memory systems

00:34:50,480 --> 00:34:55,280
which usually exists in uh databases

00:34:53,760 --> 00:34:56,720
that supports sql at least

00:34:55,280 --> 00:34:58,640
and here is i can give you an example

00:34:56,720 --> 00:35:00,880
like main sql voldb

00:34:58,640 --> 00:35:03,200
uh like google spanner all of those also

00:35:00,880 --> 00:35:05,040
support like affinity collocation thing

00:35:03,200 --> 00:35:06,800
is affinity collocation you can help

00:35:05,040 --> 00:35:08,960
your partitioning algorithm

00:35:06,800 --> 00:35:10,079
to store some data sets properly

00:35:08,960 --> 00:35:12,160
together

00:35:10,079 --> 00:35:13,760
and remember this example with cities

00:35:12,160 --> 00:35:15,839
and countries cities

00:35:13,760 --> 00:35:17,119
have one common characteristic that they

00:35:15,839 --> 00:35:19,680
exist and

00:35:17,119 --> 00:35:20,640
allocated in one in one specific country

00:35:19,680 --> 00:35:22,560
and that's why

00:35:20,640 --> 00:35:24,320
if you apply this affinity collocation

00:35:22,560 --> 00:35:27,760
in practice you will be able to run

00:35:24,320 --> 00:35:31,040
complex calculations of your data sets

00:35:27,760 --> 00:35:33,680
avoiding uh network usage and with

00:35:31,040 --> 00:35:35,359
calculated computations that's the final

00:35:33,680 --> 00:35:39,119
and probably one of the

00:35:35,359 --> 00:35:42,560
most tremendous features in your toolbox

00:35:39,119 --> 00:35:44,240
with this you can basically write any

00:35:42,560 --> 00:35:45,359
custom logic let's say if you're talking

00:35:44,240 --> 00:35:47,680
about java

00:35:45,359 --> 00:35:49,359
you can use any features of jdk or any

00:35:47,680 --> 00:35:51,200
other third-party frameworks

00:35:49,359 --> 00:35:52,800
and you can create some complex java

00:35:51,200 --> 00:35:54,560
calculation

00:35:52,800 --> 00:35:56,000
and execute all that logic on your

00:35:54,560 --> 00:35:59,520
cluster nodes

00:35:56,000 --> 00:36:01,520
avoiding any data movement between your

00:35:59,520 --> 00:36:03,200
machines so generally by knowing this in

00:36:01,520 --> 00:36:05,760
memory computing essentials

00:36:03,200 --> 00:36:07,920
yes you you you know how like all those

00:36:05,760 --> 00:36:08,880
distributed capabilities are exploited

00:36:07,920 --> 00:36:12,000
but also

00:36:08,880 --> 00:36:13,839
your goal as a architect or developer

00:36:12,000 --> 00:36:16,320
you need to ensure that network is not

00:36:13,839 --> 00:36:18,320
utilized heavily

00:36:16,320 --> 00:36:19,359
and that's yeah that's like a wonderful

00:36:18,320 --> 00:36:20,640
summary because i i

00:36:19,359 --> 00:36:23,119
as i said i've been working with

00:36:20,640 --> 00:36:25,599
distributed memory systems for a while

00:36:23,119 --> 00:36:26,320
and one of the common problem that i see

00:36:25,599 --> 00:36:29,119
over the time

00:36:26,320 --> 00:36:29,920
that a lot of the companies they do a

00:36:29,119 --> 00:36:31,760
great job

00:36:29,920 --> 00:36:34,000
by selling in memory computing

00:36:31,760 --> 00:36:35,440
technologies but then once we start you

00:36:34,000 --> 00:36:37,760
know coding or architecting

00:36:35,440 --> 00:36:38,640
only then we figure out that the life is

00:36:37,760 --> 00:36:40,160
not the simple

00:36:38,640 --> 00:36:42,160
and that it's not just enough you know

00:36:40,160 --> 00:36:42,880
to put data in memory close the cluster

00:36:42,160 --> 00:36:45,359
of machines

00:36:42,880 --> 00:36:47,280
and achieve nirvana in fact yes you need

00:36:45,359 --> 00:36:50,160
to keep in mind that you

00:36:47,280 --> 00:36:51,680
need to work with your data partitioning

00:36:50,160 --> 00:36:53,280
algorithm you need to use affinity

00:36:51,680 --> 00:36:55,680
collocation and also

00:36:53,280 --> 00:36:57,760
never neglect the power of collocated

00:36:55,680 --> 00:37:00,320
computations

00:36:57,760 --> 00:37:01,920
if you want to learn more so my

00:37:00,320 --> 00:37:04,000
suggestion would be

00:37:01,920 --> 00:37:06,240
uh all those distributed memory systems

00:37:04,000 --> 00:37:06,800
they shared a lot of the characteristics

00:37:06,240 --> 00:37:09,440
with

00:37:06,800 --> 00:37:10,720
other disk based distributed systems so

00:37:09,440 --> 00:37:12,640
if you want to dig deeper

00:37:10,720 --> 00:37:14,160
and learn more just check out these

00:37:12,640 --> 00:37:16,720
books designing data intensive

00:37:14,160 --> 00:37:20,079
applications or database internals

00:37:16,720 --> 00:37:22,800
uh ignite also like kind of

00:37:20,079 --> 00:37:24,400
you will find something that defines

00:37:22,800 --> 00:37:26,400
ignite as well in those

00:37:24,400 --> 00:37:28,240
books and if you're interested about it

00:37:26,400 --> 00:37:30,800
distributed in memory systems

00:37:28,240 --> 00:37:33,200
you can always come to our website learn

00:37:30,800 --> 00:37:36,720
how ignite is designed how ignite works

00:37:33,200 --> 00:37:39,119
etc and feel free to contribute

00:37:36,720 --> 00:37:40,560
all right uh and now we are ready we

00:37:39,119 --> 00:37:42,480
have five minutes left

00:37:40,560 --> 00:37:44,480
like four minutes and 30 seconds and let

00:37:42,480 --> 00:37:47,440
me check uh the questions

00:37:44,480 --> 00:37:48,240
i see that we've got several uh the

00:37:47,440 --> 00:37:52,160
first one

00:37:48,240 --> 00:37:52,560
from mark andre can the affinity key be

00:37:52,160 --> 00:37:54,160
added

00:37:52,560 --> 00:37:55,599
without dropping the table and

00:37:54,160 --> 00:37:58,320
recreating it

00:37:55,599 --> 00:37:58,640
unfortunately not it's like uh you know

00:37:58,320 --> 00:38:01,440
like

00:37:58,640 --> 00:38:02,000
let's take this example we all know what

00:38:01,440 --> 00:38:04,800
uh

00:38:02,000 --> 00:38:06,560
the hash tables are hashmaps hash table

00:38:04,800 --> 00:38:07,520
basically internally how the hash table

00:38:06,560 --> 00:38:10,720
is designed

00:38:07,520 --> 00:38:12,960
it it maps every key to one of the

00:38:10,720 --> 00:38:15,040
buckets of this hash table

00:38:12,960 --> 00:38:16,160
and the what changes all the time your

00:38:15,040 --> 00:38:18,400
this

00:38:16,160 --> 00:38:20,720
the mapping like the hash code function

00:38:18,400 --> 00:38:23,760
that maps your key

00:38:20,720 --> 00:38:24,560
to a bucket of the hash table uh must

00:38:23,760 --> 00:38:27,200
never change

00:38:24,560 --> 00:38:27,680
otherwise like you can let's say if one

00:38:27,200 --> 00:38:30,640
time

00:38:27,680 --> 00:38:32,079
this hash function returns maps your key

00:38:30,640 --> 00:38:34,000
to one bucket

00:38:32,079 --> 00:38:35,680
but when you execute this hash function

00:38:34,000 --> 00:38:38,000
once again it will map it to the other

00:38:35,680 --> 00:38:39,599
bucket it will be kind of an overkill

00:38:38,000 --> 00:38:42,240
and the same situation applies to

00:38:39,599 --> 00:38:44,079
distributed memory systems this

00:38:42,240 --> 00:38:45,280
key to partition mapping always have to

00:38:44,079 --> 00:38:47,839
be consistent

00:38:45,280 --> 00:38:49,359
as long as your cluster is running so

00:38:47,839 --> 00:38:51,520
and here is what i've changed with the

00:38:49,359 --> 00:38:53,280
ct tables i generally changed the way

00:38:51,520 --> 00:38:56,320
the partitioning algorithm

00:38:53,280 --> 00:38:57,920
uh needs to distribute uh my cities so

00:38:56,320 --> 00:38:59,440
before all those cities before the

00:38:57,920 --> 00:39:04,480
partitioning algorithm

00:38:59,440 --> 00:39:04,480
let me show you on this example before

00:39:05,040 --> 00:39:08,480
before i added this

00:39:09,119 --> 00:39:13,119
parameter let me remove it when i had

00:39:11,440 --> 00:39:14,000
this stuff actually the partitioning

00:39:13,119 --> 00:39:16,480
algorithm

00:39:14,000 --> 00:39:18,079
was calculating the hash code based on

00:39:16,480 --> 00:39:20,400
this combination actually it was using

00:39:18,079 --> 00:39:22,720
the value of id and country code to

00:39:20,400 --> 00:39:25,200
find out what's the partition number and

00:39:22,720 --> 00:39:29,839
then when i've added

00:39:25,200 --> 00:39:32,400
uh when i've added this affinity key

00:39:29,839 --> 00:39:36,079
property i generally influence the way

00:39:32,400 --> 00:39:38,000
the partitioning algorithm calculates

00:39:36,079 --> 00:39:39,440
all those hash codes that map your key

00:39:38,000 --> 00:39:41,839
to the partition number

00:39:39,440 --> 00:39:43,760
so that's why i had to reload this table

00:39:41,839 --> 00:39:46,079
so in general

00:39:43,760 --> 00:39:47,680
probably some of the guys usually you

00:39:46,079 --> 00:39:49,040
can usually you don't have this problem

00:39:47,680 --> 00:39:52,160
in production because you

00:39:49,040 --> 00:39:53,040
you design all this warehead before you

00:39:52,160 --> 00:39:54,839
go

00:39:53,040 --> 00:39:56,560
you deploy the very first production

00:39:54,839 --> 00:39:58,000
option uh

00:39:56,560 --> 00:40:00,240
and that's why we are talking about this

00:39:58,000 --> 00:40:01,760
affinity collocation right now because

00:40:00,240 --> 00:40:04,640
that's something that you have to

00:40:01,760 --> 00:40:06,880
keep in mind initially and not like i'm

00:40:04,640 --> 00:40:07,599
i'm already in production and i forgot i

00:40:06,880 --> 00:40:10,640
forgot to

00:40:07,599 --> 00:40:13,200
you know define this affinity key

00:40:10,640 --> 00:40:14,880
hope that my my answer makes sense to

00:40:13,200 --> 00:40:17,680
you mark

00:40:14,880 --> 00:40:20,000
and the other question is so uh so you

00:40:17,680 --> 00:40:23,599
query ignite instead of the database

00:40:20,000 --> 00:40:24,160
uh directly is it right yes so in this

00:40:23,599 --> 00:40:26,880
case

00:40:24,160 --> 00:40:27,839
uh ignite is my database ignite right

00:40:26,880 --> 00:40:30,960
now ignite is my

00:40:27,839 --> 00:40:34,480
memory database so i have this

00:40:30,960 --> 00:40:37,040
now let me show ignite is my i have this

00:40:34,480 --> 00:40:39,040
two node ignite cluster

00:40:37,040 --> 00:40:40,480
they're running on my local laptop then

00:40:39,040 --> 00:40:42,240
you can go ahead and deploy them

00:40:40,480 --> 00:40:44,800
whenever you like

00:40:42,240 --> 00:40:46,240
and here is i connect it to to this

00:40:44,800 --> 00:40:48,880
ignite cluster you can see

00:40:46,240 --> 00:40:50,720
this line i'm using the jdbc driver of

00:40:48,880 --> 00:40:54,800
ignite i connect it to this

00:40:50,720 --> 00:40:56,400
local cluster running here and uh

00:40:54,800 --> 00:40:58,160
all the simple queries that i

00:40:56,400 --> 00:41:00,160
demonstrated to you

00:40:58,160 --> 00:41:02,079
uh this tool grid gain web console

00:41:00,160 --> 00:41:03,760
that's one of the legacy tools that has

00:41:02,079 --> 00:41:04,560
been replaced right now but anyway this

00:41:03,760 --> 00:41:08,720
tool also

00:41:04,560 --> 00:41:10,880
is connected to let me show you

00:41:08,720 --> 00:41:13,440
this tool is connected to this my local

00:41:10,880 --> 00:41:13,440
cluster

00:41:14,319 --> 00:41:18,560
here are my two cluster nodes these are

00:41:17,040 --> 00:41:20,960
the tables

00:41:18,560 --> 00:41:22,880
etc that i created in ignite that's it

00:41:20,960 --> 00:41:23,920
and all those operations were executed

00:41:22,880 --> 00:41:26,480
by ignite so

00:41:23,920 --> 00:41:29,839
right here as we have on the ignite but

00:41:26,480 --> 00:41:29,839
all the data is in memory right now

00:41:30,880 --> 00:41:34,079
all right folks any other questions i

00:41:33,359 --> 00:41:37,119
think that yes

00:41:34,079 --> 00:41:40,880
i think that we

00:41:37,119 --> 00:41:43,200
fit in time so thanks for attending

00:41:40,880 --> 00:41:44,880
if you have any other questions you can

00:41:43,200 --> 00:41:47,200
find me on there

00:41:44,880 --> 00:41:48,319
apache ignite user list dev list or you

00:41:47,200 --> 00:41:51,040
can always

00:41:48,319 --> 00:41:52,720
kind of pin me on twitter thanks for

00:41:51,040 --> 00:42:03,839
coming and enjoy the rest of the

00:41:52,720 --> 00:42:03,839
conference good luck

00:42:08,640 --> 00:42:10,720

YouTube URL: https://www.youtube.com/watch?v=4vvSBK3xCqg


