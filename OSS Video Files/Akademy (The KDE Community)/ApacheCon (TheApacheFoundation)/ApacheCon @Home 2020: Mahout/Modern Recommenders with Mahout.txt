Title: Modern Recommenders with Mahout
Publication date: 2020-10-16
Playlist: ApacheCon @Home 2020: Mahout
Description: 
	Modern Recommenders with Mahout
Patrick (Pat) Ferrel

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Mahout in years past was known for being the place to go for premium OSS recommenders. Time passed and recommender technology moved on. With Mahout 0.13+ Mahout is once contains a state-of-the-art modern recommender targeting broad use. This talk covers the the 3rd generation Correlated Cross Occurrence Algorithm as it is implemented in Spark-based Mahout. CCO will be explained via the mathematics and theory behind it as well as optimizations made in Mahout to produce a production worthy implementation. We call CCO a 3rd generation algorithm since it comes after Cooccurrence and Matrix Factorization and is fully multimodal, making it possible to use many indicators of user behavior as well as contextual and content or metadata based indicators. While Mahout implements the core of the algorithm we will discuss how Mahout can be integrated into a full end-to-end data ingestion and serving architecture. We will also review some comparative performance data.

Pat has worked in startups building apps based on Machine Learning since 2000. He has worked in NLP/NER, text mining, and recommenders. He became a committer to Apache Mahout in 2012, and Apache PredictionIO in 2017. He is currently the Chief Consultant at the OSS and ML consultancy ActionML where he has led nesarly 100 deployments of their Harness ML Server which makes use of Apache Mahout and Apache Spark.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:25,599 --> 00:00:30,880
so today we're going to talk about

00:00:27,760 --> 00:00:33,360
modern recommenders with apache mahout

00:00:30,880 --> 00:00:35,600
i use the term out you can call it what

00:00:33,360 --> 00:00:38,160
you will

00:00:35,600 --> 00:00:39,040
i'm going to talk mostly about the math

00:00:38,160 --> 00:00:42,480
and how

00:00:39,040 --> 00:00:45,280
it relates to the algorithm in

00:00:42,480 --> 00:00:45,920
inside of house but also about how it's

00:00:45,280 --> 00:00:49,120
used

00:00:45,920 --> 00:00:51,280
uh in an actual recommender i'm gonna

00:00:49,120 --> 00:00:53,360
have to go pretty quick today i

00:00:51,280 --> 00:00:55,680
prepared for almost an hour and only

00:00:53,360 --> 00:00:58,160
have about a half hour so

00:00:55,680 --> 00:00:58,879
um i put the slides up on the on the

00:00:58,160 --> 00:01:02,800
slideshare

00:00:58,879 --> 00:01:07,280
if anybody wants them so i'm pat

00:01:02,800 --> 00:01:12,240
um i did used to have a beard

00:01:07,280 --> 00:01:17,280
before uh trevor but uh

00:01:12,240 --> 00:01:17,280
it's gotten more christmassy of late

00:01:17,680 --> 00:01:24,720
you can see my uh email personal email

00:01:21,200 --> 00:01:28,080
is pat at octopusmachetti.com or

00:01:24,720 --> 00:01:31,119
um apache.org

00:01:28,080 --> 00:01:34,400
as you wish i've been a committer to

00:01:31,119 --> 00:01:37,600
apache mahout since uh

00:01:34,400 --> 00:01:40,880
actually i think it's 2012.

00:01:37,600 --> 00:01:45,680
not exactly sure but around then

00:01:40,880 --> 00:01:47,520
and during my time in uh mahoud i was

00:01:45,680 --> 00:01:50,159
primarily involved in recommender

00:01:47,520 --> 00:01:50,159
algorithms

00:01:50,320 --> 00:01:54,320
and worked on the one that we're going

00:01:51,759 --> 00:01:58,399
to talk about today

00:01:54,320 --> 00:02:01,360
also during the transition from

00:01:58,399 --> 00:02:03,119
mapreduce to spark so most of my work is

00:02:01,360 --> 00:02:05,920
in spark

00:02:03,119 --> 00:02:07,600
i'm also the founder of a consulting

00:02:05,920 --> 00:02:09,280
company that's based on

00:02:07,600 --> 00:02:11,120
at least partially on using maha and

00:02:09,280 --> 00:02:13,040
then

00:02:11,120 --> 00:02:15,120
and the recommender algorithm that i'm

00:02:13,040 --> 00:02:19,040
showing you

00:02:15,120 --> 00:02:22,720
we add action ml we use

00:02:19,040 --> 00:02:24,080
uh mount and spark and based on that

00:02:22,720 --> 00:02:25,760
created a thing called the universal

00:02:24,080 --> 00:02:28,879
recommender

00:02:25,760 --> 00:02:31,920
and a server called harness

00:02:28,879 --> 00:02:36,400
which is a machine learning server

00:02:31,920 --> 00:02:39,360
with plugable engines

00:02:36,400 --> 00:02:40,800
so a little bit about where this

00:02:39,360 --> 00:02:42,800
algorithm that i'm going to describe

00:02:40,800 --> 00:02:47,280
today came from

00:02:42,800 --> 00:02:50,720
um let's say

00:02:47,280 --> 00:02:53,760
more like six or eight years ago

00:02:50,720 --> 00:02:56,879
there were the early mahout recommenders

00:02:53,760 --> 00:02:58,800
they were almost to research projects

00:02:56,879 --> 00:03:00,159
a lot was happening at the time they

00:02:58,800 --> 00:03:01,440
were sort of first generation

00:03:00,159 --> 00:03:05,120
recommenders

00:03:01,440 --> 00:03:08,640
as far as availability and open source

00:03:05,120 --> 00:03:09,760
and several flavors of recommenders were

00:03:08,640 --> 00:03:13,519
created

00:03:09,760 --> 00:03:16,480
co-occurrence was the first major one

00:03:13,519 --> 00:03:17,760
and then there was the matrix factory

00:03:16,480 --> 00:03:21,360
factorization

00:03:17,760 --> 00:03:25,120
recommender that came later

00:03:21,360 --> 00:03:29,360
and then there's also an example of

00:03:25,120 --> 00:03:29,360
matrix factorization in sparks m live

00:03:29,599 --> 00:03:33,040
i was working at a recommender as a

00:03:31,840 --> 00:03:37,519
service company

00:03:33,040 --> 00:03:37,519
at the time and

00:03:37,920 --> 00:03:44,840
we used mahou to the the traditional

00:03:41,120 --> 00:03:49,200
mapreduce to improve precision

00:03:44,840 --> 00:03:52,480
of uh recommendations

00:03:49,200 --> 00:03:56,080
over their internal uh proprietary

00:03:52,480 --> 00:03:59,519
recommender by something like 12

00:03:56,080 --> 00:04:02,959
but it it showed up several problems

00:03:59,519 --> 00:04:06,239
with the most implementations

00:04:02,959 --> 00:04:09,680
of recommenders

00:04:06,239 --> 00:04:12,959
the biggest one is that we had

00:04:09,680 --> 00:04:16,320
a large e-commerce

00:04:12,959 --> 00:04:17,759
data set that had uh you know millions

00:04:16,320 --> 00:04:20,959
and millions of

00:04:17,759 --> 00:04:24,240
of uh events that were

00:04:20,959 --> 00:04:27,360
recorded things that uh indicate

00:04:24,240 --> 00:04:28,320
users preferences or actions purchase

00:04:27,360 --> 00:04:30,160
data

00:04:28,320 --> 00:04:32,720
but we also had a hundred times more

00:04:30,160 --> 00:04:35,440
data that was detailed views

00:04:32,720 --> 00:04:36,080
and it was kind of frustrating that at a

00:04:35,440 --> 00:04:38,960
basis

00:04:36,080 --> 00:04:40,080
none of the algorithms supported using

00:04:38,960 --> 00:04:43,199
different

00:04:40,080 --> 00:04:47,840
actions that the user took uh to

00:04:43,199 --> 00:04:51,120
make recommendations better uh and

00:04:47,840 --> 00:04:55,840
this was this hasn't gotten much better

00:04:51,120 --> 00:04:57,280
today the als recommenders which are

00:04:55,840 --> 00:04:58,639
kind of the most popular one that you

00:04:57,280 --> 00:05:01,280
see today

00:04:58,639 --> 00:05:02,400
is there at the top of the stack not

00:05:01,280 --> 00:05:05,600
necessarily because it's

00:05:02,400 --> 00:05:07,120
better um and in fact

00:05:05,600 --> 00:05:08,720
at this time when i was working at this

00:05:07,120 --> 00:05:10,560
company we found that it didn't perform

00:05:08,720 --> 00:05:12,800
as well as co-occurrence

00:05:10,560 --> 00:05:15,039
which was the you know sort of original

00:05:12,800 --> 00:05:15,039
uh

00:05:15,199 --> 00:05:21,919
seminal recommender ml

00:05:19,440 --> 00:05:25,759
but it's much easier to build into an

00:05:21,919 --> 00:05:28,800
application it's much easier to serve

00:05:25,759 --> 00:05:31,120
serve recommendations from it

00:05:28,800 --> 00:05:33,360
technology's changed since then and so

00:05:31,120 --> 00:05:37,120
that doesn't have to be the case anymore

00:05:33,360 --> 00:05:39,360
and in any case the the fundamental

00:05:37,120 --> 00:05:43,360
algorithm problem that we had

00:05:39,360 --> 00:05:45,120
was that you couldn't use

00:05:43,360 --> 00:05:46,880
in an e-commerce case let's say you

00:05:45,120 --> 00:05:51,280
couldn't use purchases

00:05:46,880 --> 00:05:54,240
as well as detailed views of a product

00:05:51,280 --> 00:05:55,520
that's the simple example but literally

00:05:54,240 --> 00:05:59,280
there was no way to use

00:05:55,520 --> 00:05:59,840
other behavior that the user engaged in

00:05:59,280 --> 00:06:05,520
like

00:05:59,840 --> 00:06:07,520
searches going to a category page

00:06:05,520 --> 00:06:10,720
those kinds of behaviors which didn't

00:06:07,520 --> 00:06:13,440
directly translate into

00:06:10,720 --> 00:06:15,440
conversions or purchases couldn't be

00:06:13,440 --> 00:06:19,520
used the algorithm didn't account for it

00:06:15,440 --> 00:06:22,560
so after this investigation that i did

00:06:19,520 --> 00:06:25,919
um and lots of talk with

00:06:22,560 --> 00:06:28,400
ted dunning who was uh the mentor for

00:06:25,919 --> 00:06:29,120
apache mount at the time sean owen which

00:06:28,400 --> 00:06:31,919
is one of the

00:06:29,120 --> 00:06:32,479
early he worked on the taste framework

00:06:31,919 --> 00:06:35,680
which

00:06:32,479 --> 00:06:38,880
uh was early incorporated into mount

00:06:35,680 --> 00:06:42,080
and implemented the uh the coal currents

00:06:38,880 --> 00:06:44,560
recommender uh used that collateral

00:06:42,080 --> 00:06:46,400
cloud air at the time uh sebastian

00:06:44,560 --> 00:06:49,440
skelter whose

00:06:46,400 --> 00:06:50,960
research to amazon

00:06:49,440 --> 00:06:55,120
we came up with the algorithm that

00:06:50,960 --> 00:06:55,120
you're going to see uh the basis of it

00:06:55,199 --> 00:06:59,360
it starts with the fact that co-op

00:06:56,880 --> 00:07:02,160
currents seem to be performing best in

00:06:59,360 --> 00:07:04,400
in the results we had at the at this

00:07:02,160 --> 00:07:07,840
recommender as a service company

00:07:04,400 --> 00:07:11,360
and it can be expressed compactly

00:07:07,840 --> 00:07:14,160
in this form using some matrix algebra

00:07:11,360 --> 00:07:14,160
linear algebra

00:07:14,479 --> 00:07:18,880
where recommendations as a vector so

00:07:17,520 --> 00:07:22,960
it's a list with

00:07:18,880 --> 00:07:25,599
uh weights list of let's say product ids

00:07:22,960 --> 00:07:25,599
with weights

00:07:25,919 --> 00:07:31,120
is actually the result of this bit of

00:07:29,280 --> 00:07:35,280
linear algebra

00:07:31,120 --> 00:07:37,840
the transpose of the table that

00:07:35,280 --> 00:07:39,520
let's let's talk about what p is i guess

00:07:37,840 --> 00:07:43,440
p is a table that can

00:07:39,520 --> 00:07:46,639
contains all um uh one line

00:07:43,440 --> 00:07:49,759
in the table is one user

00:07:46,639 --> 00:07:52,960
so the user id is effectively what

00:07:49,759 --> 00:07:56,160
keys align in that table so it has

00:07:52,960 --> 00:07:56,560
all users that you've observed and in

00:07:56,160 --> 00:08:00,080
each

00:07:56,560 --> 00:08:04,080
segment or each element of that table

00:08:00,080 --> 00:08:08,400
is a item id a product id

00:08:04,080 --> 00:08:11,919
so if you take that users in rows

00:08:08,400 --> 00:08:13,440
table you transpose it and multiply it

00:08:11,919 --> 00:08:17,199
by itself

00:08:13,440 --> 00:08:18,560
you'll get something that we call the

00:08:17,199 --> 00:08:21,199
model

00:08:18,560 --> 00:08:22,800
in co-occurrence and it's a item

00:08:21,199 --> 00:08:25,440
similarity matrix

00:08:22,800 --> 00:08:26,000
it gives a score for how similar one

00:08:25,440 --> 00:08:29,280
item is

00:08:26,000 --> 00:08:32,080
to another and if you multiply that

00:08:29,280 --> 00:08:32,800
times the user's history vector in other

00:08:32,080 --> 00:08:35,919
words what

00:08:32,800 --> 00:08:38,479
purchases have they made you'll get

00:08:35,919 --> 00:08:40,000
a set of recommendations and it's a very

00:08:38,479 --> 00:08:44,080
crude way

00:08:40,000 --> 00:08:47,440
of implementing the algorithm but

00:08:44,080 --> 00:08:50,480
it it actually works

00:08:47,440 --> 00:08:52,880
so in order to turn this bit of math

00:08:50,480 --> 00:08:54,800
which can't really be performed in

00:08:52,880 --> 00:08:58,800
anything like real time

00:08:54,800 --> 00:08:58,800
since we're multiplying

00:08:59,200 --> 00:09:07,120
a uh a bit of user history here times

00:09:02,880 --> 00:09:10,480
this large table this large matrix

00:09:07,120 --> 00:09:11,600
um we need to break this down into

00:09:10,480 --> 00:09:15,519
several steps

00:09:11,600 --> 00:09:18,640
and uh the first step the one that

00:09:15,519 --> 00:09:22,240
the mahout bit concentrates on the most

00:09:18,640 --> 00:09:26,480
is this uh matrix multiplication

00:09:22,240 --> 00:09:28,880
transposing p and multiplying time p

00:09:26,480 --> 00:09:30,240
this creates what we call a model and

00:09:28,880 --> 00:09:33,760
that can be

00:09:30,240 --> 00:09:35,760
used with other tools i'll talk about

00:09:33,760 --> 00:09:37,519
to do this final step and get

00:09:35,760 --> 00:09:40,240
recommendations out

00:09:37,519 --> 00:09:42,560
in queries so it needs to be scalable to

00:09:40,240 --> 00:09:45,839
very large data sets it needs to work

00:09:42,560 --> 00:09:46,480
in a way that can give queries in real

00:09:45,839 --> 00:09:50,000
time

00:09:46,480 --> 00:09:52,240
and that was the key problem with big

00:09:50,000 --> 00:09:54,160
implementations of mahou recommenders

00:09:52,240 --> 00:09:57,360
before this time

00:09:54,160 --> 00:09:59,519
um they they needed it just didn't work

00:09:57,360 --> 00:10:02,160
very well in real time

00:09:59,519 --> 00:10:02,720
um and then we need to add the ability

00:10:02,160 --> 00:10:05,839
to use

00:10:02,720 --> 00:10:08,240
more data so

00:10:05,839 --> 00:10:09,200
the the problem in at the algorithm

00:10:08,240 --> 00:10:11,519
level is

00:10:09,200 --> 00:10:13,040
that you only are looking at in this

00:10:11,519 --> 00:10:16,800
case ecom purchases

00:10:13,040 --> 00:10:21,200
so this um

00:10:16,800 --> 00:10:25,040
this uh first step in the recommender

00:10:21,200 --> 00:10:27,440
the early theory only went to one action

00:10:25,040 --> 00:10:29,279
which is a conversion or purchase

00:10:27,440 --> 00:10:31,600
however

00:10:29,279 --> 00:10:32,880
the theory really extends to any number

00:10:31,600 --> 00:10:36,640
of actions

00:10:32,880 --> 00:10:39,360
so if you had a table of conversions

00:10:36,640 --> 00:10:40,000
those are used at each step or each

00:10:39,360 --> 00:10:44,240
segment

00:10:40,000 --> 00:10:44,240
in the overall algorithm here

00:10:44,320 --> 00:10:50,880
and what it does if you then multiply

00:10:48,480 --> 00:10:52,079
times the user's history of some other

00:10:50,880 --> 00:10:55,680
action

00:10:52,079 --> 00:10:58,959
is it gives a cross occurrence

00:10:55,680 --> 00:11:01,120
table cross occurrence matrix

00:10:58,959 --> 00:11:02,480
so this is the co-occurrence matrix this

00:11:01,120 --> 00:11:04,320
is the cross-occurrence one

00:11:02,480 --> 00:11:06,640
cross-occurrence matrix this is another

00:11:04,320 --> 00:11:08,720
cross-occurrence matrix

00:11:06,640 --> 00:11:10,480
and in this example we're extending this

00:11:08,720 --> 00:11:15,040
with users purchases

00:11:10,480 --> 00:11:15,040
we're extending it with views or

00:11:15,519 --> 00:11:22,079
detail views category preferences

00:11:18,880 --> 00:11:25,279
and it could could go on and on

00:11:22,079 --> 00:11:25,279
i'm going to switch over to the

00:11:25,600 --> 00:11:32,240
the web just to make sure i am not

00:11:29,360 --> 00:11:32,240
losing anyone

00:11:32,880 --> 00:11:41,040
okay no one is complaining yet

00:11:37,680 --> 00:11:43,839
all right so um this is what

00:11:41,040 --> 00:11:45,760
turns out to be the big innovation that

00:11:43,839 --> 00:11:48,399
came about about this time

00:11:45,760 --> 00:11:49,680
uh primarily from some suggestions that

00:11:48,399 --> 00:11:53,440
ted made

00:11:49,680 --> 00:11:56,079
ted dunning that extended this to using

00:11:53,440 --> 00:11:59,120
many different actions

00:11:56,079 --> 00:12:01,360
so the step one

00:11:59,120 --> 00:12:03,279
in the algorithm the algorithm as

00:12:01,360 --> 00:12:05,920
opposed to the mathematics

00:12:03,279 --> 00:12:08,320
mathematics is sort of the idealized

00:12:05,920 --> 00:12:12,079
explanation for what's going on

00:12:08,320 --> 00:12:14,800
whereas the the mod the uh algorithm

00:12:12,079 --> 00:12:16,399
has to implement these steps and also

00:12:14,800 --> 00:12:19,040
adds things that make it

00:12:16,399 --> 00:12:20,399
better if you will than the simple

00:12:19,040 --> 00:12:22,639
mathematics

00:12:20,399 --> 00:12:23,760
uh and in this case the first thing is

00:12:22,639 --> 00:12:26,000
to create these

00:12:23,760 --> 00:12:27,200
models they're model segments if you

00:12:26,000 --> 00:12:31,360
will consider

00:12:27,200 --> 00:12:34,959
all of these matrices to be the model

00:12:31,360 --> 00:12:38,720
um and calculating each of these

00:12:34,959 --> 00:12:44,079
is the part that mahat does very well

00:12:38,720 --> 00:12:44,079
so we add some a little bit of

00:12:44,160 --> 00:12:51,200
sugar if you will frosting to make it

00:12:47,600 --> 00:12:52,160
perform even better first of all we do

00:12:51,200 --> 00:12:56,240
some

00:12:52,160 --> 00:12:58,240
down sampling because theory shows that

00:12:56,240 --> 00:13:00,399
after you get to a certain point the

00:12:58,240 --> 00:13:02,079
amount of data that you have

00:13:00,399 --> 00:13:04,399
contributes very little to better

00:13:02,079 --> 00:13:07,920
performance of the model

00:13:04,399 --> 00:13:10,880
so at the point that you get

00:13:07,920 --> 00:13:11,839
enough data you can start down sampling

00:13:10,880 --> 00:13:15,360
so that the data

00:13:11,839 --> 00:13:18,639
remains semi-constant so over time

00:13:15,360 --> 00:13:20,959
this will scale at order of n

00:13:18,639 --> 00:13:22,560
the calculation to create the model

00:13:20,959 --> 00:13:23,519
because after you get a certain amount

00:13:22,560 --> 00:13:26,639
of data

00:13:23,519 --> 00:13:29,680
it only increases if you have new users

00:13:26,639 --> 00:13:32,720
you don't downsample the users

00:13:29,680 --> 00:13:34,880
so um and the other thing that we wanted

00:13:32,720 --> 00:13:35,839
to do is instead of using the cartesian

00:13:34,880 --> 00:13:39,040
product

00:13:35,839 --> 00:13:42,000
instead of using uh rather than

00:13:39,040 --> 00:13:44,399
well instead of using just a product of

00:13:42,000 --> 00:13:45,920
two binary matrices

00:13:44,399 --> 00:13:48,240
we go through each of these model

00:13:45,920 --> 00:13:51,120
segments and replace any non-zero

00:13:48,240 --> 00:13:54,560
element with an llr score

00:13:51,120 --> 00:13:58,000
log likelihood scored we'll talk a

00:13:54,560 --> 00:14:00,000
little bit more about that in a minute

00:13:58,000 --> 00:14:01,040
so just to visualize what's happening

00:14:00,000 --> 00:14:04,240
here

00:14:01,040 --> 00:14:06,240
um you may have a data set

00:14:04,240 --> 00:14:07,440
early on this was all you could look at

00:14:06,240 --> 00:14:10,000
the data here

00:14:07,440 --> 00:14:11,199
just products and users and it was

00:14:10,000 --> 00:14:14,639
purchased

00:14:11,199 --> 00:14:15,360
let's say for e-com or you know views

00:14:14,639 --> 00:14:18,880
for

00:14:15,360 --> 00:14:22,000
um you know news or

00:14:18,880 --> 00:14:23,920
uh watches for video uh it all works the

00:14:22,000 --> 00:14:26,800
same it's basically the primary

00:14:23,920 --> 00:14:28,399
um conversion action that a user would

00:14:26,800 --> 00:14:31,040
take

00:14:28,399 --> 00:14:32,480
but um this new algorithm allows us to

00:14:31,040 --> 00:14:34,240
take detail views

00:14:32,480 --> 00:14:36,160
it actually allows us to use search

00:14:34,240 --> 00:14:39,040
terms and this is a

00:14:36,160 --> 00:14:40,480
this was surprising when we i first

00:14:39,040 --> 00:14:44,079
started to implement that

00:14:40,480 --> 00:14:44,079
this is that the

00:14:44,480 --> 00:14:49,120
the columns are id'd by products in the

00:14:47,360 --> 00:14:52,399
first two

00:14:49,120 --> 00:14:56,320
indicator types action types but

00:14:52,399 --> 00:14:59,760
the columns can be actual uh tokens

00:14:56,320 --> 00:15:00,320
uh for search terms and the math works

00:14:59,760 --> 00:15:02,880
out

00:15:00,320 --> 00:15:03,920
and it actually we've done uh tests on

00:15:02,880 --> 00:15:05,920
this and

00:15:03,920 --> 00:15:07,440
uh search terms turn out to be one of

00:15:05,920 --> 00:15:10,000
the better things to use

00:15:07,440 --> 00:15:11,839
in helping to make predictions better

00:15:10,000 --> 00:15:13,440
and by the way this has extensions to

00:15:11,839 --> 00:15:16,560
doing personalized search

00:15:13,440 --> 00:15:20,160
and um search that's

00:15:16,560 --> 00:15:21,920
uh that favors conversions

00:15:20,160 --> 00:15:24,880
but it also means that we can use things

00:15:21,920 --> 00:15:27,839
like categories

00:15:24,880 --> 00:15:28,959
to id columns in other words a category

00:15:27,839 --> 00:15:31,120
preference would say

00:15:28,959 --> 00:15:32,160
which category a user prefers which

00:15:31,120 --> 00:15:34,560
brand

00:15:32,160 --> 00:15:36,240
could even go as far as to use locations

00:15:34,560 --> 00:15:40,079
we've used locations before

00:15:36,240 --> 00:15:43,440
in news articles

00:15:40,079 --> 00:15:43,920
so um you always have the row equals a

00:15:43,440 --> 00:15:46,240
user

00:15:43,920 --> 00:15:47,040
and each of these segments the the

00:15:46,240 --> 00:15:50,959
segment is

00:15:47,040 --> 00:15:53,680
is identified by a set of ids that

00:15:50,959 --> 00:15:56,320
are defined by the indicator type by the

00:15:53,680 --> 00:15:56,320
action type

00:15:57,199 --> 00:16:00,560
so a little bit more belaboring what the

00:16:00,000 --> 00:16:03,839
actual

00:16:00,560 --> 00:16:03,839
math in my out is

00:16:04,079 --> 00:16:08,160
p transpose looks like this if you

00:16:07,040 --> 00:16:11,199
remember your linear

00:16:08,160 --> 00:16:14,240
linear algebra and what comes out is

00:16:11,199 --> 00:16:16,959
a matrix that has product ids by product

00:16:14,240 --> 00:16:20,240
ids and each of the elements

00:16:16,959 --> 00:16:21,279
you would read as product j is similar

00:16:20,240 --> 00:16:24,320
to product

00:16:21,279 --> 00:16:27,759
n or k by some amount

00:16:24,320 --> 00:16:28,320
and the amount is the lr score in our

00:16:27,759 --> 00:16:31,839
case

00:16:28,320 --> 00:16:35,279
we replace it it comes out of this math

00:16:31,839 --> 00:16:37,279
as being just a matrix dot product of

00:16:35,279 --> 00:16:40,320
two vectors

00:16:37,279 --> 00:16:41,759
uh becomes the score here but uh in in

00:16:40,320 --> 00:16:45,199
the actual algorithm we replace this

00:16:41,759 --> 00:16:47,600
with an llr score which turns out better

00:16:45,199 --> 00:16:48,560
uh so if you if you want to look at how

00:16:47,600 --> 00:16:50,160
that works with

00:16:48,560 --> 00:16:51,759
something like search terms which seems

00:16:50,160 --> 00:16:53,199
odd

00:16:51,759 --> 00:16:56,320
it actually works pretty well and what

00:16:53,199 --> 00:16:59,839
you end up with here is that product j

00:16:56,320 --> 00:17:03,440
is similar if you will to some search

00:16:59,839 --> 00:17:03,440
term by an amount by some amount

00:17:03,600 --> 00:17:07,520
and it'll give you that amount for every

00:17:06,880 --> 00:17:09,199
search term

00:17:07,520 --> 00:17:11,039
most of the time it's zero meaning

00:17:09,199 --> 00:17:12,799
there's no particular

00:17:11,039 --> 00:17:14,559
correlation between some product and

00:17:12,799 --> 00:17:17,120
some search

00:17:14,559 --> 00:17:17,760
but often it will tell you the type of

00:17:17,120 --> 00:17:19,520
search

00:17:17,760 --> 00:17:21,120
where the the user is actually looking

00:17:19,520 --> 00:17:24,959
for product j

00:17:21,120 --> 00:17:24,959
or any other product in this matrix

00:17:25,839 --> 00:17:32,880
so this is really the the core

00:17:29,200 --> 00:17:35,440
of the algorithm so i was going to

00:17:32,880 --> 00:17:38,000
take maybe one quick question if anybody

00:17:35,440 --> 00:17:38,000
has one

00:17:39,280 --> 00:17:48,720
about that mathematics

00:17:46,000 --> 00:17:48,720
looks like not

00:17:49,280 --> 00:17:54,960
okay i'll continue on

00:17:52,559 --> 00:17:55,840
uh so now the first major improvement

00:17:54,960 --> 00:17:58,960
was to

00:17:55,840 --> 00:18:00,640
swap out the dot product of two vectors

00:17:58,960 --> 00:18:04,400
for every element in that

00:18:00,640 --> 00:18:06,320
model matrix um and replace it with the

00:18:04,400 --> 00:18:08,799
llr score

00:18:06,320 --> 00:18:10,240
um this is a bit hard to explain but it

00:18:08,799 --> 00:18:12,640
uh

00:18:10,240 --> 00:18:14,240
i'll show you in a minute that the real

00:18:12,640 --> 00:18:17,440
the most important thing

00:18:14,240 --> 00:18:18,559
isn't so much the theory as how it

00:18:17,440 --> 00:18:21,760
actually performs

00:18:18,559 --> 00:18:22,880
and so we tested it what we did is we

00:18:21,760 --> 00:18:24,640
implemented the first

00:18:22,880 --> 00:18:27,360
uh the first thing i did as part of

00:18:24,640 --> 00:18:29,679
working on the how was to

00:18:27,360 --> 00:18:30,960
change the co-occurrence algorithm to

00:18:29,679 --> 00:18:34,880
allow for one other

00:18:30,960 --> 00:18:37,919
indicator a detailed view

00:18:34,880 --> 00:18:42,000
and we so we use that

00:18:37,919 --> 00:18:45,520
to run cross validation

00:18:42,000 --> 00:18:48,799
test and found that at the time

00:18:45,520 --> 00:18:52,080
mahat supported several different

00:18:48,799 --> 00:18:53,919
similarity metrics and so we just ran it

00:18:52,080 --> 00:18:54,960
around the same data set which is a very

00:18:53,919 --> 00:18:58,799
large

00:18:54,960 --> 00:19:00,640
ecom data set through the algorithms

00:18:58,799 --> 00:19:01,919
did cross validation came up with these

00:19:00,640 --> 00:19:05,600
scores

00:19:01,919 --> 00:19:08,320
we used map at k as the

00:19:05,600 --> 00:19:09,280
cross validation metric you can look up

00:19:08,320 --> 00:19:12,080
what that is

00:19:09,280 --> 00:19:13,200
it's basically a precision metric and

00:19:12,080 --> 00:19:15,679
found that

00:19:13,200 --> 00:19:16,640
log likelihood created by far the best

00:19:15,679 --> 00:19:20,400
scores

00:19:16,640 --> 00:19:23,679
by a significant amount so why

00:19:20,400 --> 00:19:26,960
track around those other metrics

00:19:23,679 --> 00:19:30,000
when llr kind of wins

00:19:26,960 --> 00:19:33,440
um now we talked about how

00:19:30,000 --> 00:19:35,440
we could have uh a purchase detail view

00:19:33,440 --> 00:19:36,480
you know yadda yadda there could be many

00:19:35,440 --> 00:19:38,960
different

00:19:36,480 --> 00:19:39,919
things that the user might do that that

00:19:38,960 --> 00:19:42,160
might indicate

00:19:39,919 --> 00:19:43,440
a preference but there's also a lot of

00:19:42,160 --> 00:19:47,120
things that they do that

00:19:43,440 --> 00:19:49,440
have no correlation with some preference

00:19:47,120 --> 00:19:50,880
uh for instance you could use their

00:19:49,440 --> 00:19:53,919
their first names

00:19:50,880 --> 00:19:57,120
uh as an indicator

00:19:53,919 --> 00:19:58,160
or some password their password hash or

00:19:57,120 --> 00:19:59,679
something

00:19:58,160 --> 00:20:01,200
and those would have no correlation so

00:19:59,679 --> 00:20:05,120
what we did

00:20:01,200 --> 00:20:05,120
on another data set where we had

00:20:05,200 --> 00:20:09,520
we mined rotten tomatoes for uh video

00:20:08,799 --> 00:20:12,640
likes

00:20:09,520 --> 00:20:14,080
and dislikes so they have this

00:20:12,640 --> 00:20:15,679
rating which is basically thumbs up

00:20:14,080 --> 00:20:18,720
thumbs down

00:20:15,679 --> 00:20:22,000
um on videos we found that

00:20:18,720 --> 00:20:24,720
by using the dislikes

00:20:22,000 --> 00:20:25,840
as well as the likes so this is the case

00:20:24,720 --> 00:20:28,960
where the likes

00:20:25,840 --> 00:20:30,240
uh was the primary

00:20:28,960 --> 00:20:32,240
action that we were using for

00:20:30,240 --> 00:20:35,440
recommended to recommend

00:20:32,240 --> 00:20:36,480
which makes sense if uh people like

00:20:35,440 --> 00:20:38,480
certain movies

00:20:36,480 --> 00:20:39,840
and you like certain movies then maybe

00:20:38,480 --> 00:20:42,559
we can use that data to

00:20:39,840 --> 00:20:44,400
suggest things to you but we found that

00:20:42,559 --> 00:20:46,400
um

00:20:44,400 --> 00:20:49,120
it was a little bit unintuitive at the

00:20:46,400 --> 00:20:51,360
time counter-intuitive but

00:20:49,120 --> 00:20:52,880
dislikes kind of make sense a little bit

00:20:51,360 --> 00:20:55,360
too you can think that

00:20:52,880 --> 00:20:58,880
think about your friends where you

00:20:55,360 --> 00:21:02,240
dislike the same movies or you dislike

00:20:58,880 --> 00:21:05,440
the same subjects in general

00:21:02,240 --> 00:21:06,240
and we found that when we ran this this

00:21:05,440 --> 00:21:08,640
map at k

00:21:06,240 --> 00:21:10,159
cross validation test on rotten tomatoes

00:21:08,640 --> 00:21:15,039
mine data

00:21:10,159 --> 00:21:15,039
that we could improve the results by 26

00:21:15,520 --> 00:21:20,559
using likes and dislikes and there's a

00:21:18,640 --> 00:21:22,080
reference at the end of this

00:21:20,559 --> 00:21:24,320
uh that talks a little bit more about

00:21:22,080 --> 00:21:24,320
that

00:21:24,559 --> 00:21:30,960
so this kind of proved out the idea that

00:21:26,559 --> 00:21:32,880
multiple indicators do indeed help

00:21:30,960 --> 00:21:34,080
and and you notice here by the way that

00:21:32,880 --> 00:21:36,080
we're assuming the

00:21:34,080 --> 00:21:37,919
the that there is an actual recommender

00:21:36,080 --> 00:21:39,840
that we can feed data into

00:21:37,919 --> 00:21:42,240
and get recommendations back with

00:21:39,840 --> 00:21:45,200
queries

00:21:42,240 --> 00:21:46,960
and uh so here's how we implemented that

00:21:45,200 --> 00:21:50,640
recommender

00:21:46,960 --> 00:21:53,280
here's that that same um

00:21:50,640 --> 00:21:55,919
equation that we had now we've got these

00:21:53,280 --> 00:21:59,200
model parts these model segments

00:21:55,919 --> 00:22:00,799
uh they're they're matrix in each case

00:21:59,200 --> 00:22:02,880
but now we have to take the user's

00:22:00,799 --> 00:22:04,080
history and we'd like to take the user's

00:22:02,880 --> 00:22:07,919
history

00:22:04,080 --> 00:22:09,679
in real time and if you

00:22:07,919 --> 00:22:11,360
think through and and actually do the

00:22:09,679 --> 00:22:14,000
math what you're asking here

00:22:11,360 --> 00:22:14,720
when you multiply the user's history as

00:22:14,000 --> 00:22:17,600
a vector

00:22:14,720 --> 00:22:18,400
times the this model segment you're

00:22:17,600 --> 00:22:23,600
asking

00:22:18,400 --> 00:22:23,600
what what

00:22:24,559 --> 00:22:31,600
items have the same

00:22:27,600 --> 00:22:34,880
um item similarity

00:22:31,600 --> 00:22:37,919
as the user's history of

00:22:34,880 --> 00:22:40,159
item purchases and over here you're

00:22:37,919 --> 00:22:43,200
asking which

00:22:40,159 --> 00:22:46,480
items were viewed that

00:22:43,200 --> 00:22:47,760
is most similar to the user's history of

00:22:46,480 --> 00:22:50,960
views

00:22:47,760 --> 00:22:54,799
and so on and it turns out

00:22:50,960 --> 00:22:58,880
that if you look through the math

00:22:54,799 --> 00:23:01,919
that this is exactly what lucine does

00:22:58,880 --> 00:23:04,720
lucine is a search engine

00:23:01,919 --> 00:23:06,720
is a search algorithm an implementation

00:23:04,720 --> 00:23:08,159
of search whatever you want to call it

00:23:06,720 --> 00:23:10,400
that's built into solar and

00:23:08,159 --> 00:23:13,840
elasticsearch

00:23:10,400 --> 00:23:16,000
we use elasticsearch but solar is also

00:23:13,840 --> 00:23:18,159
fine we've also used that

00:23:16,000 --> 00:23:19,200
but in any case they use lucine and that

00:23:18,159 --> 00:23:23,280
is a k n

00:23:19,200 --> 00:23:26,240
engine a k nearest neighbors engine

00:23:23,280 --> 00:23:28,559
it works with sparse data and its

00:23:26,240 --> 00:23:29,679
optimizations mean that it can work very

00:23:28,559 --> 00:23:32,720
quickly

00:23:29,679 --> 00:23:33,840
with this kind of sparse data so these

00:23:32,720 --> 00:23:37,679
matrices

00:23:33,840 --> 00:23:40,480
have one user p has one user per row

00:23:37,679 --> 00:23:41,760
but it may only have a couple elements

00:23:40,480 --> 00:23:43,520
in that row

00:23:41,760 --> 00:23:46,159
and so that's considered the rest are

00:23:43,520 --> 00:23:49,120
zero that's considered to be sparse

00:23:46,159 --> 00:23:50,960
and when you get to this model chunk

00:23:49,120 --> 00:23:54,080
this model uh

00:23:50,960 --> 00:23:55,200
segment it goes into leucine and you can

00:23:54,080 --> 00:23:58,320
do queries on it

00:23:55,200 --> 00:23:59,840
ask which uh which items are most

00:23:58,320 --> 00:24:03,200
similar to this user's history

00:23:59,840 --> 00:24:04,640
and get results in real time and you can

00:24:03,200 --> 00:24:07,919
also break that down

00:24:04,640 --> 00:24:08,240
into um well here's how that works with

00:24:07,919 --> 00:24:10,640
the

00:24:08,240 --> 00:24:12,000
the search engine here the question is

00:24:10,640 --> 00:24:15,200
okay you have a user

00:24:12,000 --> 00:24:17,120
they've purchased item two and three so

00:24:15,200 --> 00:24:19,840
what do you wanna recommend

00:24:17,120 --> 00:24:21,919
well here's the model that we calculated

00:24:19,840 --> 00:24:22,559
item one is most similar to item two and

00:24:21,919 --> 00:24:25,840
three

00:24:22,559 --> 00:24:28,880
item two is similar to one three and

00:24:25,840 --> 00:24:31,600
whatever and on and on so which

00:24:28,880 --> 00:24:32,480
item would you recommend here to user

00:24:31,600 --> 00:24:35,600
one

00:24:32,480 --> 00:24:37,919
they liked item two and three

00:24:35,600 --> 00:24:39,840
looks like item one is most similar to

00:24:37,919 --> 00:24:42,559
two and three

00:24:39,840 --> 00:24:43,120
so intuitively you would want to

00:24:42,559 --> 00:24:45,919
recommend

00:24:43,120 --> 00:24:47,279
item one and that's exactly what leucine

00:24:45,919 --> 00:24:49,279
does for us

00:24:47,279 --> 00:24:51,440
you would use item two and three as the

00:24:49,279 --> 00:24:53,279
query and item one would come back as

00:24:51,440 --> 00:24:57,760
the result

00:24:53,279 --> 00:25:00,799
magic and adding new

00:24:57,760 --> 00:25:03,840
uh adding new segments

00:25:00,799 --> 00:25:05,840
to this equation

00:25:03,840 --> 00:25:07,120
turns out to be quite easy with a search

00:25:05,840 --> 00:25:10,000
engine

00:25:07,120 --> 00:25:10,799
uh search engines allow you to segment

00:25:10,000 --> 00:25:14,000
documents

00:25:10,799 --> 00:25:16,080
into fields and you can take a

00:25:14,000 --> 00:25:17,600
different part of the query to apply to

00:25:16,080 --> 00:25:20,159
a different field so

00:25:17,600 --> 00:25:22,080
you use a part of the user's history on

00:25:20,159 --> 00:25:24,320
a purchase field

00:25:22,080 --> 00:25:26,559
a part of the user's history of views on

00:25:24,320 --> 00:25:28,240
the view field

00:25:26,559 --> 00:25:30,159
so we're actually taking these model

00:25:28,240 --> 00:25:32,880
bits and putting them into an index

00:25:30,159 --> 00:25:33,600
and using the user's history as the

00:25:32,880 --> 00:25:35,840
query

00:25:33,600 --> 00:25:37,440
this is for personalized uh

00:25:35,840 --> 00:25:39,279
recommendations

00:25:37,440 --> 00:25:41,279
and it actually does the sum and gives

00:25:39,279 --> 00:25:44,240
you a score that you can rank

00:25:41,279 --> 00:25:44,640
and in fact it does the ranking so it's

00:25:44,240 --> 00:25:47,039
uh

00:25:44,640 --> 00:25:49,360
it takes a lot of the effort out of

00:25:47,039 --> 00:25:52,159
making a recommender

00:25:49,360 --> 00:25:53,840
uh not sure what time it is here let me

00:25:52,159 --> 00:25:58,400
go back and see if i'm out of time

00:25:53,840 --> 00:26:01,039
nope not yet um

00:25:58,400 --> 00:26:03,520
so a few observations now about this

00:26:01,039 --> 00:26:06,240
overall system

00:26:03,520 --> 00:26:07,360
first of all the this little graphic is

00:26:06,240 --> 00:26:09,679
meant to show that

00:26:07,360 --> 00:26:11,919
if you have a one action recommender

00:26:09,679 --> 00:26:13,840
imagine it's an ecom recommender

00:26:11,919 --> 00:26:15,120
and you haven't bought anything you go

00:26:13,840 --> 00:26:18,559
to

00:26:15,120 --> 00:26:22,880
a new site you've never for a new

00:26:18,559 --> 00:26:25,200
ecom app and you see things that you've

00:26:22,880 --> 00:26:26,720
never purchased before online

00:26:25,200 --> 00:26:28,960
that's probably happening to a lot of us

00:26:26,720 --> 00:26:33,360
these days

00:26:28,960 --> 00:26:34,640
but we can't make any recommendations to

00:26:33,360 --> 00:26:35,120
you because you haven't bought anything

00:26:34,640 --> 00:26:36,640
yet

00:26:35,120 --> 00:26:38,640
even though you maybe have searched for

00:26:36,640 --> 00:26:40,080
things you've

00:26:38,640 --> 00:26:41,840
put some things in the shopping cart

00:26:40,080 --> 00:26:45,120
maybe even

00:26:41,840 --> 00:26:48,000
you've uh you know

00:26:45,120 --> 00:26:49,840
clicked on things viewed a lot of items

00:26:48,000 --> 00:26:52,880
um

00:26:49,840 --> 00:26:54,480
the big guys like netflix and amazon

00:26:52,880 --> 00:26:57,039
have similar technology

00:26:54,480 --> 00:26:57,840
and so when they follow your uh your

00:26:57,039 --> 00:26:59,200
click stream

00:26:57,840 --> 00:27:00,960
they can actually make real-time

00:26:59,200 --> 00:27:03,120
recommendations but

00:27:00,960 --> 00:27:04,799
these older recommenders like the one in

00:27:03,120 --> 00:27:08,240
spark als

00:27:04,799 --> 00:27:10,640
has a pretty hard time of this

00:27:08,240 --> 00:27:11,440
and it can only do that if you buy

00:27:10,640 --> 00:27:14,559
something

00:27:11,440 --> 00:27:18,240
if you've converted if you've done

00:27:14,559 --> 00:27:20,080
taken the primary action

00:27:18,240 --> 00:27:21,679
uh the universal recommender is the

00:27:20,080 --> 00:27:24,720
implementation where we've taken

00:27:21,679 --> 00:27:25,520
the cco algorithm correlated cross

00:27:24,720 --> 00:27:28,159
occurrence

00:27:25,520 --> 00:27:30,320
and uh of mount and put it into a an

00:27:28,159 --> 00:27:33,760
actual recommender engine

00:27:30,320 --> 00:27:35,360
and by using uh

00:27:33,760 --> 00:27:36,880
you know techniques like these this

00:27:35,360 --> 00:27:40,159
multi modality

00:27:36,880 --> 00:27:43,520
the use of multi multiple actions

00:27:40,159 --> 00:27:45,919
we can expand the scope of what of the

00:27:43,520 --> 00:27:48,480
users that we can recommend to

00:27:45,919 --> 00:27:49,279
so that there's only a few corner cases

00:27:48,480 --> 00:27:52,399
where

00:27:49,279 --> 00:27:54,240
we can't give recommendations and

00:27:52,399 --> 00:27:56,880
that means that the cold start problem

00:27:54,240 --> 00:28:00,240
is much less severe with

00:27:56,880 --> 00:28:00,240
with the universal recommender

00:28:01,039 --> 00:28:04,159
so this was implemented a couple years

00:28:03,200 --> 00:28:07,679
ago

00:28:04,159 --> 00:28:12,240
uh in the most stable versions in uh

00:28:07,679 --> 00:28:15,360
out 0.13 uh and it's also in the

00:28:12,240 --> 00:28:18,559
most latest release candidate

00:28:15,360 --> 00:28:19,919
1 and it's been in the universal

00:28:18,559 --> 00:28:20,399
recommender since the beginning we're

00:28:19,919 --> 00:28:25,679
now at

00:28:20,399 --> 00:28:25,679
uh 0.9 of that release working on 1-0

00:28:27,200 --> 00:28:31,279
so it should be said too that this

00:28:29,840 --> 00:28:34,600
entire approach

00:28:31,279 --> 00:28:37,120
can and has been been applied to lots of

00:28:34,600 --> 00:28:40,480
non-ecommerce applications

00:28:37,120 --> 00:28:44,159
uh all the way from making optimizing

00:28:40,480 --> 00:28:47,600
search to be more personalized

00:28:44,159 --> 00:28:50,880
in in some cases in a travel industry

00:28:47,600 --> 00:28:53,679
case to other cases where we're doing

00:28:50,880 --> 00:28:56,960
video recommendations based on

00:28:53,679 --> 00:29:00,240
what users have have watched

00:28:56,960 --> 00:29:01,200
um music recommendations all sorts of

00:29:00,240 --> 00:29:03,760
other

00:29:01,200 --> 00:29:03,760
domains

00:29:04,799 --> 00:29:08,799
so the the algorithm improves on the

00:29:07,760 --> 00:29:11,200
quality of rex

00:29:08,799 --> 00:29:12,000
we've shown that with cross validation

00:29:11,200 --> 00:29:14,159
tests

00:29:12,000 --> 00:29:16,080
and some a b tests but a b tests are

00:29:14,159 --> 00:29:18,880
usually proprietary to

00:29:16,080 --> 00:29:19,520
an application so i can't um share that

00:29:18,880 --> 00:29:21,120
data

00:29:19,520 --> 00:29:22,880
but i think we've got quite a bit of

00:29:21,120 --> 00:29:25,840
cross-validation

00:29:22,880 --> 00:29:27,760
verification of this uh you know it also

00:29:25,840 --> 00:29:28,880
improves user coverage so the number of

00:29:27,760 --> 00:29:31,360
users that can

00:29:28,880 --> 00:29:33,760
actually get recommendations is always

00:29:31,360 --> 00:29:33,760
greater

00:29:35,279 --> 00:29:41,520
and uh it uses real-time behavior so

00:29:38,720 --> 00:29:43,840
as you're clicking along maybe you're

00:29:41,520 --> 00:29:44,880
reviewing a movie or giving it thumbs up

00:29:43,840 --> 00:29:48,000
or something

00:29:44,880 --> 00:29:48,880
or just looking at the page as you go

00:29:48,000 --> 00:29:51,840
through

00:29:48,880 --> 00:29:54,320
the site within a few clicks you can get

00:29:51,840 --> 00:29:55,760
recommendations right away even though

00:29:54,320 --> 00:29:57,120
that's the first time you've gone to the

00:29:55,760 --> 00:30:00,000
site

00:29:57,120 --> 00:30:00,960
uh things are definitely scalable we've

00:30:00,000 --> 00:30:03,200
implemented this

00:30:00,960 --> 00:30:04,080
and deployed it in places where there

00:30:03,200 --> 00:30:08,320
are

00:30:04,080 --> 00:30:11,360
many millions of users and

00:30:08,320 --> 00:30:14,640
about a million product ids

00:30:11,360 --> 00:30:18,960
so a very large data set uh

00:30:14,640 --> 00:30:22,799
in that case um the queries are still

00:30:18,960 --> 00:30:25,679
in real time uh current system

00:30:22,799 --> 00:30:28,640
is returning results in on an order of

00:30:25,679 --> 00:30:31,919
20 to 30 milliseconds

00:30:28,640 --> 00:30:34,640
for you know fairly complex queries

00:30:31,919 --> 00:30:36,159
um a nice thing that we didn't even

00:30:34,640 --> 00:30:38,799
think about i think when we

00:30:36,159 --> 00:30:40,720
went down this road is that it if you

00:30:38,799 --> 00:30:42,399
implement the final query part

00:30:40,720 --> 00:30:44,000
in a search engine you can also

00:30:42,399 --> 00:30:47,120
implement a lot of really

00:30:44,000 --> 00:30:47,440
important business rules because lucine

00:30:47,120 --> 00:30:50,960
has

00:30:47,440 --> 00:30:53,120
things like filters and boosts and

00:30:50,960 --> 00:30:54,480
useful things like that so that you

00:30:53,120 --> 00:30:55,200
won't be recommend you don't have to

00:30:54,480 --> 00:30:57,600
recommend

00:30:55,200 --> 00:31:00,559
items that aren't in stock for instance

00:30:57,600 --> 00:31:00,559
or aren't available

00:31:00,720 --> 00:31:04,000
just by creating a business rule that

00:31:02,399 --> 00:31:06,720
says give me recommendations

00:31:04,000 --> 00:31:08,000
but make sure they're they have this

00:31:06,720 --> 00:31:11,200
available field

00:31:08,000 --> 00:31:12,320
true um

00:31:11,200 --> 00:31:14,880
i'm going to leave you with some

00:31:12,320 --> 00:31:16,320
resources

00:31:14,880 --> 00:31:18,640
and i think i'm probably out of time

00:31:16,320 --> 00:31:20,960
anyway so

00:31:18,640 --> 00:31:23,120
feel free to grab the the you know

00:31:20,960 --> 00:31:26,159
either contact me or get the

00:31:23,120 --> 00:31:27,679
presentation off the site

00:31:26,159 --> 00:31:33,840
just wondering if anybody has any

00:31:27,679 --> 00:31:33,840
questions now

00:31:35,200 --> 00:31:47,840
i am out of time right trevor

00:31:48,640 --> 00:31:52,080
okay people are there

00:31:58,399 --> 00:32:02,159
yeah you might wanna to eric you might

00:32:00,159 --> 00:32:03,840
want to come to the

00:32:02,159 --> 00:32:05,919
session a couple sessions from now where

00:32:03,840 --> 00:32:15,840
we're going to talk about

00:32:05,919 --> 00:32:15,840
uh history and future about

00:32:18,399 --> 00:32:32,480
when do i get cut off here trevor

00:32:29,679 --> 00:32:32,480
any other questions

00:32:36,240 --> 00:32:39,519
i can't imagine it was that

00:32:39,919 --> 00:32:43,840
that clear

00:32:47,440 --> 00:32:52,159
yeah i i was talking about the uh in the

00:32:50,399 --> 00:32:52,880
slides we talk about the universal

00:32:52,159 --> 00:32:55,519
recommender

00:32:52,880 --> 00:32:57,200
quote unquote it's the title of a

00:32:55,519 --> 00:32:59,919
recommender we've implemented

00:32:57,200 --> 00:33:01,840
with mahout it's in open source on

00:32:59,919 --> 00:33:04,080
github

00:33:01,840 --> 00:33:06,240
it's part of a project that when i say

00:33:04,080 --> 00:33:09,519
we i'm part of a consulting

00:33:06,240 --> 00:33:13,679
firm that implements recommenders

00:33:09,519 --> 00:33:16,399
and deploys them to commercial sites

00:33:13,679 --> 00:33:18,000
but it's in open source and the server

00:33:16,399 --> 00:33:20,720
that it's built

00:33:18,000 --> 00:33:24,080
that's that it's a plug-in to is also an

00:33:20,720 --> 00:33:26,799
open source um

00:33:24,080 --> 00:33:28,720
i'll put some more links in that or ping

00:33:26,799 --> 00:33:29,120
me on email and i'll send you some links

00:33:28,720 --> 00:33:33,279
that

00:33:29,120 --> 00:33:33,279
point to the code it's on github

00:33:37,440 --> 00:33:44,240
yes the server uses elasticsearch which

00:33:40,720 --> 00:33:48,159
is based on leucine

00:33:44,240 --> 00:33:49,679
so that's a key part of all of this

00:33:48,159 --> 00:33:51,440
one of the early problems with

00:33:49,679 --> 00:33:53,360
co-occurrence

00:33:51,440 --> 00:33:55,120
some of the recommenders in my out was

00:33:53,360 --> 00:33:57,600
that you basically had to

00:33:55,120 --> 00:33:58,880
in batch make all recommendations for

00:33:57,600 --> 00:34:00,240
all users

00:33:58,880 --> 00:34:01,840
and store them in a database or

00:34:00,240 --> 00:34:04,320
something and look them up when the user

00:34:01,840 --> 00:34:06,559
wanted them

00:34:04,320 --> 00:34:08,000
which i guess works but it made it

00:34:06,559 --> 00:34:09,839
really cumbersome

00:34:08,000 --> 00:34:12,000
and it didn't allow for real-time

00:34:09,839 --> 00:34:14,079
recommendations so

00:34:12,000 --> 00:34:15,200
uh one of the key innovations in this is

00:34:14,079 --> 00:34:18,879
that we're using

00:34:15,200 --> 00:34:19,679
lucene as a method for doing that query

00:34:18,879 --> 00:34:22,480
at the very end

00:34:19,679 --> 00:34:23,919
so you we can watch what you're doing in

00:34:22,480 --> 00:34:28,079
real time

00:34:23,919 --> 00:34:28,079
and use that to make recommendations

00:34:32,839 --> 00:34:35,839
thanks

00:34:49,040 --> 00:34:55,679
uh yes the okay uh

00:34:52,560 --> 00:34:58,400
lauren asks if we have any benchmarks

00:34:55,679 --> 00:34:59,280
um yeah there's several uh cross

00:34:58,400 --> 00:35:02,240
validation

00:34:59,280 --> 00:35:02,240
tests that we've run

00:35:02,400 --> 00:35:05,520
they're mentioned in the talk

00:35:07,599 --> 00:35:13,920
what we've benchmarked against is other

00:35:11,200 --> 00:35:15,200
recommender styles but it's a bit

00:35:13,920 --> 00:35:18,400
dangerous to use

00:35:15,200 --> 00:35:21,200
to take cross-validation results with

00:35:18,400 --> 00:35:23,839
two recommenders that use different

00:35:21,200 --> 00:35:23,839
technology

00:35:24,160 --> 00:35:31,359
the the benchmarks that we have

00:35:28,240 --> 00:35:36,000
use the most current

00:35:31,359 --> 00:35:38,510
algorithm that's built into wow

00:35:36,000 --> 00:35:39,760
so the most recent work is to

00:35:38,510 --> 00:35:43,440
[Music]

00:35:39,760 --> 00:35:46,480
turn that into a serving recommender so

00:35:43,440 --> 00:35:46,960
something that takes input creates a

00:35:46,480 --> 00:35:50,240
model

00:35:46,960 --> 00:35:52,720
and can take real time queries

00:35:50,240 --> 00:35:55,200
so that doesn't change the results that

00:35:52,720 --> 00:35:58,560
come back from that

00:35:55,200 --> 00:36:00,240
so those are all up-to-date and current

00:35:58,560 --> 00:36:02,480
many of the data sets that we have are

00:36:00,240 --> 00:36:07,839
not

00:36:02,480 --> 00:36:07,839
are proprietary but we continue

00:36:08,240 --> 00:36:12,000
continue to find that it performs very

00:36:10,839 --> 00:36:14,560
well

00:36:12,000 --> 00:36:16,640
and again this was based on early

00:36:14,560 --> 00:36:19,440
looking at the algorithms

00:36:16,640 --> 00:36:20,480
we found that core currents on one one

00:36:19,440 --> 00:36:22,800
action type

00:36:20,480 --> 00:36:25,280
performed better than als on one action

00:36:22,800 --> 00:36:26,560
type it's just a concurrence was hard to

00:36:25,280 --> 00:36:31,760
implement as a

00:36:26,560 --> 00:36:33,599
service so you could say that als was

00:36:31,760 --> 00:36:35,520
at least with the data we had was

00:36:33,599 --> 00:36:38,800
somewhat of a step backwards

00:36:35,520 --> 00:36:40,000
matrix factorization i'm sure that some

00:36:38,800 --> 00:36:42,560
data sets it works better

00:36:40,000 --> 00:36:44,400
on but the ones we had which are purely

00:36:42,560 --> 00:36:47,760
ecom

00:36:44,400 --> 00:36:47,760
it didn't seem to perform as well

00:36:50,000 --> 00:36:53,280
we've also done a b tests and those are

00:36:52,320 --> 00:36:55,119
proprietary

00:36:53,280 --> 00:36:57,520
because they're you know assume the use

00:36:55,119 --> 00:37:00,640
of a certain site

00:36:57,520 --> 00:37:04,160
the ones on rotten tomato

00:37:00,640 --> 00:37:06,839
we we used the universal recommender

00:37:04,160 --> 00:37:09,119
and we scraped rotten tomatoes for movie

00:37:06,839 --> 00:37:12,079
data so the results you see

00:37:09,119 --> 00:37:13,680
in the um when you look at a map of k

00:37:12,079 --> 00:37:14,720
result though it's not going to mean

00:37:13,680 --> 00:37:15,760
very much

00:37:14,720 --> 00:37:18,240
uh you're not going to be able to

00:37:15,760 --> 00:37:21,280
translate that into like how many people

00:37:18,240 --> 00:37:24,640
are going to click on a recommendation

00:37:21,280 --> 00:37:25,200
because that relates to your website or

00:37:24,640 --> 00:37:27,040
your app

00:37:25,200 --> 00:37:28,800
what your app looks like and a lot of

00:37:27,040 --> 00:37:32,400
visual things but

00:37:28,800 --> 00:37:35,599
um yeah that's that data is from

00:37:32,400 --> 00:37:37,920
uh recent scraping of rotten tomatoes

00:37:35,599 --> 00:37:40,240
and the current version of the universal

00:37:37,920 --> 00:37:41,839
recommender

00:37:40,240 --> 00:37:45,440
i'm belaboring that point any other

00:37:41,839 --> 00:37:45,440
questions before i get shut off here

00:37:46,880 --> 00:37:51,839
i may have already gotten shut off

00:37:58,400 --> 00:38:03,440
cross validation works offline so you

00:38:01,520 --> 00:38:07,119
take a static data set

00:38:03,440 --> 00:38:10,480
you put um

00:38:07,119 --> 00:38:12,960
you know 80 of the data in what you'll

00:38:10,480 --> 00:38:12,960
call the

00:38:14,960 --> 00:38:19,599
the baseline and then you'll take 20 of

00:38:18,000 --> 00:38:20,960
the data and put that in the probe set

00:38:19,599 --> 00:38:23,680
or the test set

00:38:20,960 --> 00:38:25,359
so there's no actual benefit calculation

00:38:23,680 --> 00:38:28,480
you could do

00:38:25,359 --> 00:38:31,440
on users because it's a static cross

00:38:28,480 --> 00:38:31,440
validation test

00:38:31,599 --> 00:38:34,960
i think benefit to the customer is a is

00:38:34,240 --> 00:38:38,079
a very

00:38:34,960 --> 00:38:42,000
very good way of putting this though um

00:38:38,079 --> 00:38:44,800
what with all the discussion of uh

00:38:42,000 --> 00:38:46,000
maybe the social media sites optimizing

00:38:44,800 --> 00:38:48,079
for clicks

00:38:46,000 --> 00:38:49,839
but it gives the user no benefit and in

00:38:48,079 --> 00:38:54,640
fact they end up being

00:38:49,839 --> 00:38:57,920
stressed out and annoyed by

00:38:54,640 --> 00:39:01,520
certain aspects of the site so

00:38:57,920 --> 00:39:04,400
so far we keep to does it

00:39:01,520 --> 00:39:05,839
increase conversions so if you're

00:39:04,400 --> 00:39:07,920
watching movies does it

00:39:05,839 --> 00:39:10,800
does it lead you to increase the number

00:39:07,920 --> 00:39:10,800
of movies you watch

00:39:11,119 --> 00:39:14,800
satisfaction rating is a stat that needs

00:39:13,760 --> 00:39:17,200
to be defined in

00:39:14,800 --> 00:39:19,119
uh maybe something like do your do you

00:39:17,200 --> 00:39:21,280
watch movies that you rate high

00:39:19,119 --> 00:39:22,880
but you tend to watch movies that you

00:39:21,280 --> 00:39:24,800
rate high you don't even finish ones

00:39:22,880 --> 00:39:29,200
that you don't rate high so

00:39:24,800 --> 00:39:31,280
um whether they convert

00:39:29,200 --> 00:39:32,640
is a is a or not is a pretty good

00:39:31,280 --> 00:39:36,160
indicator of

00:39:32,640 --> 00:39:40,000
uh customer satisfaction

00:39:36,160 --> 00:39:40,880
um but no nothing i wouldn't say that's

00:39:40,000 --> 00:39:44,800
a

00:39:40,880 --> 00:39:44,800
prime thing that we look at

00:39:45,040 --> 00:39:47,839
i think it should be

00:39:51,760 --> 00:39:56,079
yes exactly that's the github link if

00:39:54,480 --> 00:39:58,400
anyone cares

00:39:56,079 --> 00:40:00,720
um it has built the universal

00:39:58,400 --> 00:40:03,520
recommender is built into harness if you

00:40:00,720 --> 00:40:03,520
uh deploy it

00:40:03,839 --> 00:40:08,800
yeah ping me later uh lauren if you have

00:40:06,000 --> 00:40:08,800
any particular

00:40:09,119 --> 00:40:15,040
kpis for satisfaction that you'd like to

00:40:12,640 --> 00:40:15,040
talk about

00:40:20,000 --> 00:40:25,839
okay let's see

00:40:28,240 --> 00:40:39,839
trevor what time do we shut down here

00:40:31,520 --> 00:40:39,839
are we already shut down

00:40:42,000 --> 00:40:44,319
okay

00:40:45,040 --> 00:40:48,079
all right well every anybody uh thanks

00:40:47,040 --> 00:40:50,400
for showing up

00:40:48,079 --> 00:40:51,839
um if you have any questions ping me on

00:40:50,400 --> 00:40:55,359
uh

00:40:51,839 --> 00:40:55,359
and i'll do the best dancing

00:41:05,680 --> 00:41:10,720
i'm never done trevor i can babble on

00:41:08,160 --> 00:41:10,720
for hours

00:41:14,240 --> 00:41:21,839
all right good uh you guys enjoy the

00:41:16,560 --> 00:41:21,839
rest of the pachycon

00:41:36,720 --> 00:41:38,800

YouTube URL: https://www.youtube.com/watch?v=A-GzGYEYYsk


