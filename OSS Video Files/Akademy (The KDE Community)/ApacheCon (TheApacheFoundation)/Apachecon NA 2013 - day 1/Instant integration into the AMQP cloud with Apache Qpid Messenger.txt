Title: Instant integration into the AMQP cloud with Apache Qpid Messenger
Publication date: 2013-10-17
Playlist: Apachecon NA 2013 - day 1
Description: 
	Rafael Schloming ApacheCon NA 2013
Tapping the Stream
Captions: 
	00:00:00,000 --> 00:00:05,899
as matt said my name is Rafa shlomi I'm

00:00:03,810 --> 00:00:10,050
a principal software engineer Red Hat

00:00:05,899 --> 00:00:16,320
and i am one of the authors of the n QP

00:00:10,050 --> 00:00:22,710
specification and an editor in the TC at

00:00:16,320 --> 00:00:25,109
oasis so today I'm going to talk a

00:00:22,710 --> 00:00:30,240
little bit about messaging in general

00:00:25,109 --> 00:00:31,890
and what am cuba offers and sort of a

00:00:30,240 --> 00:00:37,770
little bit of its history how it came to

00:00:31,890 --> 00:00:41,879
be and then going to go into what proton

00:00:37,770 --> 00:00:43,710
is doing in the Apache cubed project for

00:00:41,879 --> 00:00:47,280
making it really easy to integrate with

00:00:43,710 --> 00:00:53,309
and work with amqp and build distributed

00:00:47,280 --> 00:00:54,480
systems based on this this standard and

00:00:53,309 --> 00:00:58,649
then at the end I'm going to do a little

00:00:54,480 --> 00:01:01,010
demo I'm like well okay see me the Wi-Fi

00:00:58,649 --> 00:01:03,989
holds up I'm going to do a little demo

00:01:01,010 --> 00:01:07,409
about integrating different different

00:01:03,989 --> 00:01:15,689
apps or parts of a nap together in the

00:01:07,409 --> 00:01:16,830
cloud so so mqp is it's an oasis

00:01:15,689 --> 00:01:20,400
standard for those of you who don't know

00:01:16,830 --> 00:01:25,799
it's a it's a standard messaging

00:01:20,400 --> 00:01:27,960
protocol and and proton is a toolkit for

00:01:25,799 --> 00:01:31,380
speaking amqp which includes two parts

00:01:27,960 --> 00:01:33,150
the the protocol engine and the

00:01:31,380 --> 00:01:36,990
messenger api i'm going to get a little

00:01:33,150 --> 00:01:41,869
bit more into that later on but first

00:01:36,990 --> 00:01:44,369
i'm going to talk about messaging so

00:01:41,869 --> 00:01:49,079
messaging really is something that

00:01:44,369 --> 00:01:52,350
inevitably comes out of the the process

00:01:49,079 --> 00:01:54,210
of building distributed systems and if

00:01:52,350 --> 00:01:56,159
you've ever built the distributed system

00:01:54,210 --> 00:01:59,000
you know that sort of tightly coupled

00:01:56,159 --> 00:02:02,009
distributed systems can be very very

00:01:59,000 --> 00:02:04,079
brittle right if you've got a storefront

00:02:02,009 --> 00:02:05,759
in a warehouse and your warehouse goes

00:02:04,079 --> 00:02:08,069
down and it's tightly coupled to the

00:02:05,759 --> 00:02:10,020
storefront suddenly you can't you can't

00:02:08,069 --> 00:02:12,090
take any orders anymore because your

00:02:10,020 --> 00:02:15,750
warehouse is down

00:02:12,090 --> 00:02:17,790
and that's bad so sort of the natural

00:02:15,750 --> 00:02:22,879
progression from that point is to

00:02:17,790 --> 00:02:26,700
introduce an order queue in between and

00:02:22,879 --> 00:02:30,000
create a more loosely coupled system and

00:02:26,700 --> 00:02:31,980
in this more loosely coupled system if

00:02:30,000 --> 00:02:34,200
your warehouse goes down the ordered Q

00:02:31,980 --> 00:02:36,360
can take up the slack while you have

00:02:34,200 --> 00:02:37,799
time to recover I mean you probably

00:02:36,360 --> 00:02:39,810
can't lot you probably can't last

00:02:37,799 --> 00:02:41,400
indefinitely in that state but at least

00:02:39,810 --> 00:02:42,540
you don't experience an outage and you

00:02:41,400 --> 00:02:45,150
have time to recover and if you

00:02:42,540 --> 00:02:47,790
provision your cues you know you order

00:02:45,150 --> 00:02:50,970
to you well enough then you can recover

00:02:47,790 --> 00:02:59,430
and no one will notice the back of our

00:02:50,970 --> 00:03:01,799
that your back end has gone down so in

00:02:59,430 --> 00:03:03,660
addition to being more robust you know

00:03:01,799 --> 00:03:06,030
systems that are more loosely coupled

00:03:03,660 --> 00:03:08,640
are more flexible right so instead of

00:03:06,030 --> 00:03:10,019
these sort of and you know directly tied

00:03:08,640 --> 00:03:13,230
together things you have through more

00:03:10,019 --> 00:03:15,209
more abstract communication patterns you

00:03:13,230 --> 00:03:18,690
can have n warehouses on the back end

00:03:15,209 --> 00:03:22,709
and storefronts you can you can put

00:03:18,690 --> 00:03:26,060
queues in between and and you can sort

00:03:22,709 --> 00:03:30,420
of scale out and have more flexible

00:03:26,060 --> 00:03:33,930
topologies so messaging really comes out

00:03:30,420 --> 00:03:35,970
of formalizing concepts like these and

00:03:33,930 --> 00:03:39,630
you know instead of an order to you you

00:03:35,970 --> 00:03:43,470
have a message queue right and a couple

00:03:39,630 --> 00:03:46,410
key things about messages messages are

00:03:43,470 --> 00:03:48,810
not they're not entirely opaque some

00:03:46,410 --> 00:03:50,609
properties are available for semantic

00:03:48,810 --> 00:03:54,870
routing for messaging infrastructure and

00:03:50,609 --> 00:03:56,880
in general the way addressing works in

00:03:54,870 --> 00:03:58,650
these messaging systems is that

00:03:56,880 --> 00:04:01,769
addresses our rendezvous point so it's

00:03:58,650 --> 00:04:04,859
not it's not really like TCP addressing

00:04:01,769 --> 00:04:07,470
or like well like IP addressing where

00:04:04,859 --> 00:04:11,400
you know the endpoints are what you're

00:04:07,470 --> 00:04:14,310
actually naming when you when you type

00:04:11,400 --> 00:04:16,440
out an IP address right it's more like

00:04:14,310 --> 00:04:19,320
you're saying I want to send a message

00:04:16,440 --> 00:04:20,640
to this rendezvous point and then

00:04:19,320 --> 00:04:22,590
someone else is saying i want to receive

00:04:20,640 --> 00:04:25,410
messages that are sent to that

00:04:22,590 --> 00:04:27,740
rendezvous point and so you have a

00:04:25,410 --> 00:04:29,790
brokering right you don't you don't have

00:04:27,740 --> 00:04:35,190
senders and receivers necessarily

00:04:29,790 --> 00:04:38,400
directly aware of each other and with

00:04:35,190 --> 00:04:39,650
this idea you can have a couple of

00:04:38,400 --> 00:04:43,740
different you know you have different

00:04:39,650 --> 00:04:45,570
semantics for for routing messages and

00:04:43,740 --> 00:04:50,400
different different communication

00:04:45,570 --> 00:04:53,580
patterns so you know the sort of message

00:04:50,400 --> 00:04:57,290
queue which is just sort of a more

00:04:53,580 --> 00:04:57,290
abstract form of that order queue right

00:04:57,350 --> 00:05:05,460
you can have many producers that that

00:05:00,540 --> 00:05:07,290
flow messages into it and then messages

00:05:05,460 --> 00:05:11,900
get distributed to one and only one

00:05:07,290 --> 00:05:11,900
consumer and that's queuing semantics

00:05:12,440 --> 00:05:21,420
topics are another common abstraction

00:05:16,740 --> 00:05:25,320
and for topics messages sort of they

00:05:21,420 --> 00:05:30,720
flow into the topic and then they flow

00:05:25,320 --> 00:05:33,930
to each producer or sorry each

00:05:30,720 --> 00:05:35,820
subscriber so each every subscriber gets

00:05:33,930 --> 00:05:37,260
every message so it's kind of like you

00:05:35,820 --> 00:05:38,880
know you're all your subscribers are

00:05:37,260 --> 00:05:45,210
logged into a chat room everyone sees

00:05:38,880 --> 00:05:47,640
everything that's said and you know

00:05:45,210 --> 00:05:49,860
because the messages have properties

00:05:47,640 --> 00:05:50,940
that are visible to the the

00:05:49,860 --> 00:05:54,540
infrastructure you can actually

00:05:50,940 --> 00:05:59,970
configure routing based on those topics

00:05:54,540 --> 00:06:02,760
so what you see here is a filter can you

00:05:59,970 --> 00:06:04,200
see the pointer yes what you see here is

00:06:02,760 --> 00:06:10,320
a filter that doesn't allow that

00:06:04,200 --> 00:06:13,680
messages through and as you can see on

00:06:10,320 --> 00:06:14,850
the fancy animation there the bottom

00:06:13,680 --> 00:06:19,770
little circle doesn't see any red

00:06:14,850 --> 00:06:24,450
messages so that's the basic sort of of

00:06:19,770 --> 00:06:26,400
of you know the messaging and it's a

00:06:24,450 --> 00:06:27,780
really powerful and flexible tool for

00:06:26,400 --> 00:06:30,590
building distributed systems and

00:06:27,780 --> 00:06:35,280
distributed systems by their very nature

00:06:30,590 --> 00:06:37,270
tend to be heterogeneous whether you

00:06:35,280 --> 00:06:44,470
want them to or not they sort of

00:06:37,270 --> 00:06:46,480
grow extra limbs and so you know an

00:06:44,470 --> 00:06:48,340
actual picture might look something more

00:06:46,480 --> 00:06:49,960
like this where you have you know

00:06:48,340 --> 00:06:53,380
different different clients and

00:06:49,960 --> 00:06:55,600
different platforms you know and and you

00:06:53,380 --> 00:06:56,650
don't have just sort of the messages

00:06:55,600 --> 00:06:58,450
flowing in one direction you have

00:06:56,650 --> 00:07:03,490
messages traveling around in circles and

00:06:58,450 --> 00:07:06,430
whatnot going back and forth and it sort

00:07:03,490 --> 00:07:13,210
of quickly becomes integrated into every

00:07:06,430 --> 00:07:15,820
aspect of of your of your business so

00:07:13,210 --> 00:07:20,190
the problem is when you take a picture

00:07:15,820 --> 00:07:22,270
like this and you build your your

00:07:20,190 --> 00:07:26,160
business on top of you know a

00:07:22,270 --> 00:07:30,250
proprietary messaging infrastructure you

00:07:26,160 --> 00:07:33,610
are now sort of tightly integrated into

00:07:30,250 --> 00:07:39,700
this proprietary messaging software and

00:07:33,610 --> 00:07:41,590
if it's speaking a vendor specific

00:07:39,700 --> 00:07:42,580
protocol on the wire then the only way

00:07:41,590 --> 00:07:43,890
to actually communicate with your

00:07:42,580 --> 00:07:46,810
messaging infrastructure is to actually

00:07:43,890 --> 00:07:52,360
integrate little pieces of proprietary

00:07:46,810 --> 00:07:54,570
code into your application and this

00:07:52,360 --> 00:07:57,880
pretty quickly becomes pervasive and

00:07:54,570 --> 00:07:59,830
soon you know every aspect of your

00:07:57,880 --> 00:08:04,980
business has some proprietary piece of

00:07:59,830 --> 00:08:09,640
code running into running in it and it

00:08:04,980 --> 00:08:13,240
if you you know if like your vendor

00:08:09,640 --> 00:08:14,980
doesn't have a a client available on on

00:08:13,240 --> 00:08:16,480
some given platform you might just be

00:08:14,980 --> 00:08:19,570
out of luck so this little blue square

00:08:16,480 --> 00:08:25,170
in the corner he might not be able to

00:08:19,570 --> 00:08:25,170
tie into your proprietary message bus

00:08:26,790 --> 00:08:34,690
so this is the this is the the this

00:08:33,220 --> 00:08:38,580
problem actually gets even worse if you

00:08:34,690 --> 00:08:41,140
say have to proprietary messaging

00:08:38,580 --> 00:08:43,150
systems right maybe maybe your business

00:08:41,140 --> 00:08:45,640
acquires another business and you know

00:08:43,150 --> 00:08:49,300
what do you do you can't port the other

00:08:45,640 --> 00:08:51,940
the other applications because it you

00:08:49,300 --> 00:08:55,270
know it's a lot of work to rewrite at

00:08:51,940 --> 00:08:57,490
all so different API and integrating is

00:08:55,270 --> 00:08:59,110
kind of difficult as well because you

00:08:57,490 --> 00:09:01,120
know they don't usually speak to each

00:08:59,110 --> 00:09:02,650
other so you need to do application

00:09:01,120 --> 00:09:07,300
level bridging and translation of

00:09:02,650 --> 00:09:09,520
message formats so it gets even worse

00:09:07,300 --> 00:09:13,570
with when you have when you have

00:09:09,520 --> 00:09:16,420
multiple proprietary systems involved so

00:09:13,570 --> 00:09:20,980
this is kind of the world in which amqp

00:09:16,420 --> 00:09:23,770
was born into and it started about what

00:09:20,980 --> 00:09:30,360
is it like five or six years ago inside

00:09:23,770 --> 00:09:33,850
jpmc the brainchild of John O Hara and

00:09:30,360 --> 00:09:38,170
he he and a bunch of other companies

00:09:33,850 --> 00:09:39,460
started the MTP working group and it was

00:09:38,170 --> 00:09:44,050
originally just an industry working

00:09:39,460 --> 00:09:46,990
group and after developing the protocol

00:09:44,050 --> 00:09:50,260
for a number of years actually it was in

00:09:46,990 --> 00:09:52,780
just octobe this past October that we

00:09:50,260 --> 00:09:54,250
voted through or we well actually last

00:09:52,780 --> 00:09:57,670
year we went to Oasis and then this

00:09:54,250 --> 00:10:02,560
October we voted through that one point

00:09:57,670 --> 00:10:03,730
0 version of the standard and just one

00:10:02,560 --> 00:10:06,730
thing I'd like to call out about this

00:10:03,730 --> 00:10:10,870
slide as you can see Microsoft Red Hat

00:10:06,730 --> 00:10:14,260
and vmware are all involved in this

00:10:10,870 --> 00:10:15,870
group and when the those three companies

00:10:14,260 --> 00:10:19,570
get in the room and agree on something

00:10:15,870 --> 00:10:22,920
you can tell that there's a some some

00:10:19,570 --> 00:10:22,920
strong motivation behind it

00:10:25,089 --> 00:10:32,170
so actually interestingly enough the the

00:10:29,740 --> 00:10:38,430
world has changed a lot since MGP was

00:10:32,170 --> 00:10:40,720
first was first conceived of and

00:10:38,430 --> 00:10:43,420
initially the idea was well you know

00:10:40,720 --> 00:10:47,980
create sort of a standard interface to a

00:10:43,420 --> 00:10:51,759
message broker but since since it was

00:10:47,980 --> 00:10:53,290
sort of originally conceived of the you

00:10:51,759 --> 00:10:56,709
know mobile networks mobile technology

00:10:53,290 --> 00:10:58,480
has just exploded and as we've developed

00:10:56,709 --> 00:11:02,529
the protocol over the years we've

00:10:58,480 --> 00:11:06,069
actually considered this and really try

00:11:02,529 --> 00:11:09,759
to to express core messaging semantics

00:11:06,069 --> 00:11:12,779
in a way that that are applicable beyond

00:11:09,759 --> 00:11:17,829
just sort of traditional message brokers

00:11:12,779 --> 00:11:22,269
so name could be 10 really it really

00:11:17,829 --> 00:11:26,410
captures the these these core messaging

00:11:22,269 --> 00:11:28,569
semantics that that any any message

00:11:26,410 --> 00:11:30,100
oriented application is going to

00:11:28,569 --> 00:11:32,290
encounter pretty much any distributed

00:11:30,100 --> 00:11:35,499
application and it's particularly

00:11:32,290 --> 00:11:38,679
well-suited for sort of store and

00:11:35,499 --> 00:11:41,259
forward taught you know style

00:11:38,679 --> 00:11:48,040
asynchronous interactions that that work

00:11:41,259 --> 00:11:50,439
well in in mobile networks so to take a

00:11:48,040 --> 00:11:54,959
look at our picture again with n QP in

00:11:50,439 --> 00:11:59,019
the picture we now instead of having a

00:11:54,959 --> 00:12:01,720
instead of having a proprietary piece

00:11:59,019 --> 00:12:06,610
embedded in our apps we actually invent

00:12:01,720 --> 00:12:09,879
in bed and open an open protocol

00:12:06,610 --> 00:12:13,360
implementation in our in our proprietary

00:12:09,879 --> 00:12:16,089
infrastructure and now all our apps can

00:12:13,360 --> 00:12:18,699
speak just standard amqp over the wire

00:12:16,089 --> 00:12:20,949
and if you know even if the vendor

00:12:18,699 --> 00:12:22,809
doesn't support you know our whatever

00:12:20,949 --> 00:12:25,899
platform our poor little blue square is

00:12:22,809 --> 00:12:28,980
running on you can always find you know

00:12:25,899 --> 00:12:32,199
some free implementation somewhere and

00:12:28,980 --> 00:12:36,250
get access to your messaging

00:12:32,199 --> 00:12:39,149
infrastructure from from wherever but

00:12:36,250 --> 00:12:39,149
that's not all actually

00:12:40,089 --> 00:12:47,029
you can in fact have heterogeneous

00:12:42,860 --> 00:12:49,370
infrastructure now you don't need to

00:12:47,029 --> 00:12:50,959
pick you know topics from and cues from

00:12:49,370 --> 00:12:52,550
the same vendor you can pick you know

00:12:50,959 --> 00:12:54,560
topics or one vendor to use from another

00:12:52,550 --> 00:12:57,620
right or you can pick you know one kind

00:12:54,560 --> 00:12:59,000
of cue that's that's that's very you

00:12:57,620 --> 00:13:02,300
know specially suited for your

00:12:59,000 --> 00:13:06,080
particular application so it really

00:13:02,300 --> 00:13:14,690
enables a much more diverse way of

00:13:06,080 --> 00:13:19,279
deploying messaging applications and on

00:13:14,690 --> 00:13:23,180
top of that because it's a standard and

00:13:19,279 --> 00:13:25,100
secure protocol we can actually create

00:13:23,180 --> 00:13:26,480
open deployments as well you know

00:13:25,100 --> 00:13:29,899
running keep you over the internet and

00:13:26,480 --> 00:13:39,740
this is where you get the idea of the

00:13:29,899 --> 00:13:41,779
mqp cloud and you know that's at this

00:13:39,740 --> 00:13:43,790
point it's not just about using amqp to

00:13:41,779 --> 00:13:52,180
you know talk to message queues you can

00:13:43,790 --> 00:13:54,589
use a MVP to talk to anything so the

00:13:52,180 --> 00:13:56,209
state of the world right now with

00:13:54,589 --> 00:13:57,950
respect to implementations they're

00:13:56,209 --> 00:14:01,250
actually a bunch of implementations out

00:13:57,950 --> 00:14:02,930
there already and these these are all

00:14:01,250 --> 00:14:04,910
sort of traditional broker type

00:14:02,930 --> 00:14:07,300
implementations you've gotten a patchy

00:14:04,910 --> 00:14:11,899
Cupid offers a C++ and Java broker

00:14:07,300 --> 00:14:19,880
activemq the latest one I think is 58 is

00:14:11,899 --> 00:14:23,420
a it now speaks amqp 10 microsoft office

00:14:19,880 --> 00:14:25,190
offers an amqp front end to service bus

00:14:23,420 --> 00:14:29,810
which is a platform as a service

00:14:25,190 --> 00:14:32,959
offering of message queuing Swift mq has

00:14:29,810 --> 00:14:38,320
a JMS broker and client and that both

00:14:32,959 --> 00:14:43,250
speak amqp RabbitMQ offers an amqp 10

00:14:38,320 --> 00:14:47,270
adapter as well and of course there's

00:14:43,250 --> 00:14:49,610
proton which is also named QP 10

00:14:47,270 --> 00:14:51,379
implementation but it's different from

00:14:49,610 --> 00:14:53,119
the rest of those

00:14:51,379 --> 00:14:57,919
all of those implementations i just

00:14:53,119 --> 00:14:59,989
spoke of are providing providing

00:14:57,919 --> 00:15:03,679
messaging infrastructure so accuse

00:14:59,989 --> 00:15:05,720
topics and the like proton is actually

00:15:03,679 --> 00:15:08,029
an implementation of just the protocol

00:15:05,720 --> 00:15:10,309
right it's really trying to be that

00:15:08,029 --> 00:15:15,649
little blue dot right it doesn't want to

00:15:10,309 --> 00:15:17,689
want to it it just wants to make it as

00:15:15,649 --> 00:15:18,979
easy as possible to speak in coupee

00:15:17,689 --> 00:15:21,049
doesn't want to be the thing that stores

00:15:18,979 --> 00:15:24,829
messages the thing that that does fancy

00:15:21,049 --> 00:15:28,220
routing or anything like that and this

00:15:24,829 --> 00:15:31,189
is something that that prior to MVP 10

00:15:28,220 --> 00:15:32,479
hasn't really been possible because so

00:15:31,189 --> 00:15:34,249
are they know all previous attempts to

00:15:32,479 --> 00:15:39,679
standardize messaging we're very sort of

00:15:34,249 --> 00:15:44,029
client server based right and whereas

00:15:39,679 --> 00:15:46,309
amqp 10 sort of takes a departure from

00:15:44,029 --> 00:15:48,289
that approach by being entirely

00:15:46,309 --> 00:15:51,769
symmetric very network oriented

00:15:48,289 --> 00:15:53,659
decentralized and it does provide the

00:15:51,769 --> 00:15:58,909
intermediated messaging semantics so

00:15:53,659 --> 00:16:04,249
it's it has that at that rendezvous

00:15:58,909 --> 00:16:06,259
concept but it doesn't restrict us to

00:16:04,249 --> 00:16:08,119
the sort of the hub and spoke topology

00:16:06,259 --> 00:16:13,100
that that traditional brokers tend to

00:16:08,119 --> 00:16:14,509
use so it's really it's really what

00:16:13,100 --> 00:16:17,470
makes a protocol implementation like

00:16:14,509 --> 00:16:17,470
proton possible

00:16:21,390 --> 00:16:31,290
so and one of the reasons proton is is

00:16:28,230 --> 00:16:34,350
valuable and and well you know we hope

00:16:31,290 --> 00:16:37,920
to sort of see the ecosystem is sort of

00:16:34,350 --> 00:16:41,160
in the traditional mom world you tend to

00:16:37,920 --> 00:16:44,730
get sort of very specialized application

00:16:41,160 --> 00:16:48,620
behaviors built into queues so you and

00:16:44,730 --> 00:16:50,670
this sort of conflates the application

00:16:48,620 --> 00:16:53,010
logic with the store and forward

00:16:50,670 --> 00:16:57,180
infrastructure so you get things like

00:16:53,010 --> 00:16:59,250
must value cues ring cues and you get

00:16:57,180 --> 00:17:05,070
message transformation I think I've even

00:16:59,250 --> 00:17:09,980
heard of a a sorted q implementation

00:17:05,070 --> 00:17:14,250
actually used in one particular business

00:17:09,980 --> 00:17:15,959
which is pretty much you know at that

00:17:14,250 --> 00:17:18,540
point it's you know you wonder why you

00:17:15,959 --> 00:17:25,589
aren't using a database and just

00:17:18,540 --> 00:17:26,930
speaking to it via amqp so the idea is

00:17:25,589 --> 00:17:29,760
that many different things not just

00:17:26,930 --> 00:17:34,730
topics and Q's what will benefit from

00:17:29,760 --> 00:17:37,560
speaking amqp but every message

00:17:34,730 --> 00:17:41,490
orientation needs to sort of factor in

00:17:37,560 --> 00:17:45,840
these these these messaging semantics

00:17:41,490 --> 00:17:47,490
right flow control very key you know if

00:17:45,840 --> 00:17:49,560
you keep pumping messages into a queue

00:17:47,490 --> 00:17:51,990
right eventually that's going to fill up

00:17:49,560 --> 00:17:53,820
right or if you keep you know pushing

00:17:51,990 --> 00:17:56,550
messages at an HTTP server it's going to

00:17:53,820 --> 00:17:58,950
get busy right and you know if you're if

00:17:56,550 --> 00:18:00,720
you're gonna you know you wouldn't ever

00:17:58,950 --> 00:18:02,430
you know type your credit card number

00:18:00,720 --> 00:18:03,720
into a web page and hit submit if you

00:18:02,430 --> 00:18:06,750
knew that that server was going to come

00:18:03,720 --> 00:18:09,060
back to you with a server busy error

00:18:06,750 --> 00:18:10,980
code right and so it's actually flow

00:18:09,060 --> 00:18:13,140
controls part of building row busting

00:18:10,980 --> 00:18:17,310
and reliable systems because you need a

00:18:13,140 --> 00:18:19,950
way to to keep the capacity at something

00:18:17,310 --> 00:18:22,440
the system was designed to handle and

00:18:19,950 --> 00:18:28,440
handle back pressure in the places where

00:18:22,440 --> 00:18:31,560
where where it's where it's intended to

00:18:28,440 --> 00:18:33,120
be handled so settlement really that's

00:18:31,560 --> 00:18:34,429
just all the different acknowledgment

00:18:33,120 --> 00:18:38,240
patterns

00:18:34,429 --> 00:18:41,299
you know at every every sort of

00:18:38,240 --> 00:18:44,710
messaging system you know 10 sets of

00:18:41,299 --> 00:18:46,309
support a different style of of

00:18:44,710 --> 00:18:48,080
acknowledgement you've got some sort of

00:18:46,309 --> 00:18:50,990
fire and forget and you've got you've

00:18:48,080 --> 00:18:54,019
got just simple acting and then you have

00:18:50,990 --> 00:18:56,539
sort of more more complicated three-way

00:18:54,019 --> 00:18:58,070
aking you've got locking semantics where

00:18:56,539 --> 00:19:00,619
you know you get up maybe you get a lock

00:18:58,070 --> 00:19:03,980
for the message and then it gets you

00:19:00,619 --> 00:19:07,159
know it gets timed out later on and so

00:19:03,980 --> 00:19:10,730
settlement basically handles or it is

00:19:07,159 --> 00:19:11,869
really about handling very precisely

00:19:10,730 --> 00:19:16,629
handling the transfer of responsibility

00:19:11,869 --> 00:19:19,610
of a message from one party to another

00:19:16,629 --> 00:19:23,090
and it captures all the various ways

00:19:19,610 --> 00:19:25,909
that you can do that transactions I mean

00:19:23,090 --> 00:19:28,850
inevitably you're distributed systems

00:19:25,909 --> 00:19:32,450
tend to run into these that the tricky

00:19:28,850 --> 00:19:33,830
thing here is finding a way to deal with

00:19:32,450 --> 00:19:36,440
them without making simple case is

00:19:33,830 --> 00:19:38,840
complicated and data binding all right i

00:19:36,440 --> 00:19:39,769
mean if you're sticking data into you

00:19:38,840 --> 00:19:41,600
know if you're if you're taking

00:19:39,769 --> 00:19:44,419
structured data and python and you want

00:19:41,600 --> 00:19:46,970
to you know process it in ruby or

00:19:44,419 --> 00:19:48,200
something right the the type systems

00:19:46,970 --> 00:19:49,940
don't quite match up there a little bit

00:19:48,200 --> 00:19:51,440
different you need to you need to deal

00:19:49,940 --> 00:19:54,200
with that in any kind of heterogeneous

00:19:51,440 --> 00:19:57,049
distributed system so you know these are

00:19:54,200 --> 00:19:58,429
all factors if you're building any

00:19:57,049 --> 00:20:00,409
distributed system but nobody really

00:19:58,429 --> 00:20:02,720
wants to implement every one of these

00:20:00,409 --> 00:20:05,899
things down to the wire and that's where

00:20:02,720 --> 00:20:08,419
that's where proton comes in so go here

00:20:05,899 --> 00:20:12,019
make it as easy as possible to speaking

00:20:08,419 --> 00:20:14,509
and QP all right which means we need to

00:20:12,019 --> 00:20:17,059
be super embeddable minimal dependencies

00:20:14,509 --> 00:20:18,379
we need to be embeddable in different

00:20:17,059 --> 00:20:20,509
kinds of environments so minimal

00:20:18,379 --> 00:20:21,799
threading assumptions you know you might

00:20:20,509 --> 00:20:23,419
be a client library you might be a

00:20:21,799 --> 00:20:26,210
server totally different threading and

00:20:23,419 --> 00:20:32,169
IO models but we want proton to be

00:20:26,210 --> 00:20:37,460
usable from both multilanguage of course

00:20:32,169 --> 00:20:38,960
and multi-platform obviously because I

00:20:37,460 --> 00:20:41,600
mean that's the heterogeneous part of

00:20:38,960 --> 00:20:44,630
heterogeneous systems

00:20:41,600 --> 00:20:45,919
so the way the basic architecture is

00:20:44,630 --> 00:20:48,980
built around this idea of a protocol

00:20:45,919 --> 00:20:50,870
engine which is something that that

00:20:48,980 --> 00:20:52,520
captures the the semantics of the

00:20:50,870 --> 00:20:55,250
protocol but doesn't actually do the i/o

00:20:52,520 --> 00:20:56,480
itself because the i/o is going to be

00:20:55,250 --> 00:21:01,400
different depending on what kind of

00:20:56,480 --> 00:21:04,940
environment you're in so a protocol

00:21:01,400 --> 00:21:07,429
engine sort of I'm first going to

00:21:04,940 --> 00:21:11,270
describe what it's not it's not the

00:21:07,429 --> 00:21:13,309
traditional RPC like pattern so in a

00:21:11,270 --> 00:21:15,340
traditional RPC pattern you sort of have

00:21:13,309 --> 00:21:20,299
this this call stack here where the app

00:21:15,340 --> 00:21:23,450
calls into the calls into the library

00:21:20,299 --> 00:21:25,220
which you know then encodes some data

00:21:23,450 --> 00:21:27,169
and writes it directly out into socket

00:21:25,220 --> 00:21:29,330
and that's on the client side and then

00:21:27,169 --> 00:21:33,650
on the server side you know you read

00:21:29,330 --> 00:21:35,240
that data you decode it you dispatch and

00:21:33,650 --> 00:21:36,740
then you call into the app so the call

00:21:35,240 --> 00:21:40,909
stack is completely different between

00:21:36,740 --> 00:21:43,400
the server and the client the i/o model

00:21:40,909 --> 00:21:48,530
is very different and the threading

00:21:43,400 --> 00:21:50,480
model is usually very different so in

00:21:48,530 --> 00:21:53,510
the engine pattern we take that call

00:21:50,480 --> 00:21:55,549
stack and sort of fold it if you can

00:21:53,510 --> 00:21:57,169
imagine that so in this case the

00:21:55,549 --> 00:21:59,360
application does the i/o and the engine

00:21:57,169 --> 00:22:01,340
encapsulates the protocol state so you

00:21:59,360 --> 00:22:03,380
invoke into the engine and then you see

00:22:01,340 --> 00:22:08,450
hey is there output and if there is

00:22:03,380 --> 00:22:11,240
output you write it and on you know the

00:22:08,450 --> 00:22:13,880
other side you do a read you pump that

00:22:11,240 --> 00:22:16,130
into the engine and then you see if

00:22:13,880 --> 00:22:18,890
there's anything to dispatch right and

00:22:16,130 --> 00:22:22,669
so in this way we can capture the the

00:22:18,890 --> 00:22:26,000
protocol semantics in a in a pure in a

00:22:22,669 --> 00:22:27,590
pure state machine and so we have sort

00:22:26,000 --> 00:22:29,750
of the top half and bottom half here

00:22:27,590 --> 00:22:31,490
where where the top where it's your sort

00:22:29,750 --> 00:22:34,820
of two aspects of the interface to an

00:22:31,490 --> 00:22:36,679
engine the top half is your traditional

00:22:34,820 --> 00:22:40,340
protocol interface in a non-blocking

00:22:36,679 --> 00:22:42,230
form it lets you do sort of the

00:22:40,340 --> 00:22:43,909
higher-level things like create senders

00:22:42,230 --> 00:22:45,830
receivers and in receive message data

00:22:43,909 --> 00:22:53,110
that kind of thing the bottom half is

00:22:45,830 --> 00:22:57,080
just a sort of a byte stream interface

00:22:53,110 --> 00:22:59,809
so to to sort of build this up from the

00:22:57,080 --> 00:23:06,530
other direction you can imagine sort of

00:22:59,809 --> 00:23:08,420
a simple a simple echo server right and

00:23:06,530 --> 00:23:11,300
something that just reads bytes in and

00:23:08,420 --> 00:23:16,280
and writes them back out directly to the

00:23:11,300 --> 00:23:17,360
to the same socket right so it's you

00:23:16,280 --> 00:23:18,920
know one of the classic things you write

00:23:17,360 --> 00:23:22,520
when you're trying to debug a server or

00:23:18,920 --> 00:23:27,410
you know create like a and an i/o

00:23:22,520 --> 00:23:28,820
framework right and so when you write

00:23:27,410 --> 00:23:31,010
one of these things inevitably somewhere

00:23:28,820 --> 00:23:32,780
in there is whether it's in a temporary

00:23:31,010 --> 00:23:35,480
variable and a member variable something

00:23:32,780 --> 00:23:36,650
like that right is a byte buffer and if

00:23:35,480 --> 00:23:38,750
you're to put an abstract interface

00:23:36,650 --> 00:23:40,010
around this thing you would have

00:23:38,750 --> 00:23:42,770
something that's pretty much an

00:23:40,010 --> 00:23:44,570
interface to a circular buffer or by Q

00:23:42,770 --> 00:23:47,240
and so that's the simplest possible

00:23:44,570 --> 00:23:50,059
engine just it's just a circularbuffer

00:23:47,240 --> 00:23:53,420
secure data structure no dependencies on

00:23:50,059 --> 00:23:55,760
threading or i/o we can augment that by

00:23:53,420 --> 00:23:57,950
adding a query interface and we have

00:23:55,760 --> 00:23:59,480
something that's slightly more

00:23:57,950 --> 00:24:00,950
interesting than a circularbuffer not

00:23:59,480 --> 00:24:02,210
terribly interesting we can count how

00:24:00,950 --> 00:24:05,059
many bytes go through maybe we can

00:24:02,210 --> 00:24:07,070
inspect and you know four frames kind of

00:24:05,059 --> 00:24:12,440
like Wireshark does but still not

00:24:07,070 --> 00:24:14,570
horribly interesting we we can make it

00:24:12,440 --> 00:24:16,540
slightly more interesting by turning it

00:24:14,570 --> 00:24:19,520
into a request-response engine which

00:24:16,540 --> 00:24:21,290
from the perspective of the i/o portion

00:24:19,520 --> 00:24:23,840
of your application looks exactly like a

00:24:21,290 --> 00:24:25,640
circular buffer but the bytes that are

00:24:23,840 --> 00:24:27,860
coming out we happen to transform them

00:24:25,640 --> 00:24:29,600
in some way some predefined transform

00:24:27,860 --> 00:24:31,790
maybe we're you know doing about 13

00:24:29,600 --> 00:24:37,160
maybe we're doing a UTF encoding or

00:24:31,790 --> 00:24:38,540
something I don't know so a little bit

00:24:37,160 --> 00:24:39,950
more interesting but still you don't

00:24:38,540 --> 00:24:42,860
really have control outside of the

00:24:39,950 --> 00:24:48,500
library of what's actually happening to

00:24:42,860 --> 00:24:50,540
your bites so you take the the this one

00:24:48,500 --> 00:24:53,900
step further you add a control interface

00:24:50,540 --> 00:24:55,850
on top of your query interface and or in

00:24:53,900 --> 00:24:59,360
addition to your query interface and now

00:24:55,850 --> 00:25:03,740
what comes out can be controlled it's

00:24:59,360 --> 00:25:07,429
actually by by the

00:25:03,740 --> 00:25:11,590
the thing using this library that is

00:25:07,429 --> 00:25:15,340
still a basic request response pattern

00:25:11,590 --> 00:25:17,690
so to generalize this a little bit more

00:25:15,340 --> 00:25:19,670
we say ok the base that come out our

00:25:17,690 --> 00:25:22,850
function of the bites in or the control

00:25:19,670 --> 00:25:26,540
interface and this is sort of a

00:25:22,850 --> 00:25:31,970
generalized engine for a server but in

00:25:26,540 --> 00:25:35,390
fact because because the bytes that are

00:25:31,970 --> 00:25:38,120
can be controlled by or the bites can be

00:25:35,390 --> 00:25:40,460
spontaneous if we produced when you when

00:25:38,120 --> 00:25:42,530
you access the control interface you can

00:25:40,460 --> 00:25:43,880
actually do a fully symmetric protocol

00:25:42,530 --> 00:25:46,760
here this is a generalized endpoint you

00:25:43,880 --> 00:25:48,830
could do you could do the client half of

00:25:46,760 --> 00:25:50,780
a request response as well because you

00:25:48,830 --> 00:25:56,360
know client the client half needs to be

00:25:50,780 --> 00:25:59,390
able to spontaneously produce bytes so

00:25:56,360 --> 00:26:01,010
the QP protocol engine takes this one

00:25:59,390 --> 00:26:04,429
step further I mean it's basically the

00:26:01,010 --> 00:26:07,370
same idea but in addition but we

00:26:04,429 --> 00:26:09,350
basically take that and and divide it we

00:26:07,370 --> 00:26:10,960
take the control portion the query

00:26:09,350 --> 00:26:12,860
control portion of the interface and

00:26:10,960 --> 00:26:15,800
split that out into something that's

00:26:12,860 --> 00:26:17,630
stateful and this sort of divides

00:26:15,800 --> 00:26:19,370
between sort of the high-level portion

00:26:17,630 --> 00:26:20,660
imager acts with your app and the

00:26:19,370 --> 00:26:24,410
low-level portion that's that's

00:26:20,660 --> 00:26:26,690
responsible for i/o and it it it allows

00:26:24,410 --> 00:26:30,020
you to track state across multiple

00:26:26,690 --> 00:26:33,700
connections as well as in you can learn

00:26:30,020 --> 00:26:33,700
multiple sequential connections that is

00:26:35,290 --> 00:26:41,390
so that's the idea of an engine the

00:26:38,240 --> 00:26:44,600
benefit is flexibility you can use the

00:26:41,390 --> 00:26:46,610
same protocol implementation in pretty

00:26:44,600 --> 00:26:50,450
much anywhere in a client you can embed

00:26:46,610 --> 00:26:52,910
it in existing servers it's totally

00:26:50,450 --> 00:26:55,460
thread agnostic because this thing is is

00:26:52,910 --> 00:26:58,690
basically a pure data structure Amon and

00:26:55,460 --> 00:27:01,280
most importantly it's very easy to swig

00:26:58,690 --> 00:27:03,230
which for those of you don't know swig

00:27:01,280 --> 00:27:06,350
is a simple what simple wrapper

00:27:03,230 --> 00:27:08,540
interphase generator it means you can

00:27:06,350 --> 00:27:11,090
take a see library and produce bindings

00:27:08,540 --> 00:27:13,280
very easily in Python Ruby PHP Perl

00:27:11,090 --> 00:27:15,090
there's like 20 different different

00:27:13,280 --> 00:27:20,540
things that supports

00:27:15,090 --> 00:27:23,640
um and and this lets you very quickly

00:27:20,540 --> 00:27:25,920
get access to a lot of different or get

00:27:23,640 --> 00:27:30,600
your protocol implementation access to a

00:27:25,920 --> 00:27:35,460
lot of different environments so now we

00:27:30,600 --> 00:27:37,170
take a look at our picture again we now

00:27:35,460 --> 00:27:41,300
have sort of a multi-platform

00:27:37,170 --> 00:27:45,840
multilingual implementation of amqp and

00:27:41,300 --> 00:27:48,180
we can we can actually bootstrap and

00:27:45,840 --> 00:27:57,480
realize this this picture of the MGP

00:27:48,180 --> 00:28:00,420
cloud with proton everywhere so that's

00:27:57,480 --> 00:28:05,460
that's sort of the the engine half of

00:28:00,420 --> 00:28:08,100
the story the easy way to use this is is

00:28:05,460 --> 00:28:10,890
messenger which is a very high level

00:28:08,100 --> 00:28:13,500
interface to this engine it's sort of

00:28:10,890 --> 00:28:17,490
your client half and what you see right

00:28:13,500 --> 00:28:20,100
here is some example code it's sort of

00:28:17,490 --> 00:28:23,070
the hello world you create a messenger

00:28:20,100 --> 00:28:26,070
you start it you create a message give

00:28:23,070 --> 00:28:29,370
it an address give it a body call put

00:28:26,070 --> 00:28:32,090
and send and then you know you stop the

00:28:29,370 --> 00:28:34,740
messenger when you're done receiving

00:28:32,090 --> 00:28:37,850
similar you create a messenger you

00:28:34,740 --> 00:28:42,330
subscribe you start the messenger and

00:28:37,850 --> 00:28:44,970
you receive and you get a message into

00:28:42,330 --> 00:28:47,130
your into your message that you've

00:28:44,970 --> 00:28:49,080
created then when you're done processing

00:28:47,130 --> 00:28:53,250
you can stop although it's an infinite

00:28:49,080 --> 00:28:54,540
loop so you would never stop but so a

00:28:53,250 --> 00:28:57,510
couple things to notice about this this

00:28:54,540 --> 00:29:00,300
interface is message oriented not

00:28:57,510 --> 00:29:03,060
connection oriented so it will create or

00:29:00,300 --> 00:29:04,500
recreate and it will pull the minimal

00:29:03,060 --> 00:29:06,750
number of connections behind the scenes

00:29:04,500 --> 00:29:08,790
to do whatever you want this simplifies

00:29:06,750 --> 00:29:12,630
failover a lot and it also means the

00:29:08,790 --> 00:29:14,700
topology of you know how your messaging

00:29:12,630 --> 00:29:17,250
infrastructure is is deployed is

00:29:14,700 --> 00:29:20,400
invisible to your application which can

00:29:17,250 --> 00:29:23,100
be quite handy and the idea behind

00:29:20,400 --> 00:29:25,260
messenger is to be simple but not a toy

00:29:23,100 --> 00:29:28,620
so you know one example of this is you

00:29:25,260 --> 00:29:33,809
see the batch oriented interface which

00:29:28,620 --> 00:29:38,880
it can actually achieve some some good

00:29:33,809 --> 00:29:45,090
performance good performance for for

00:29:38,880 --> 00:29:46,350
this style of client and well not only

00:29:45,090 --> 00:29:48,300
good performance it can also be very

00:29:46,350 --> 00:29:50,700
convenient you can you know create a

00:29:48,300 --> 00:29:55,950
message and modify it or receive a

00:29:50,700 --> 00:29:57,690
message modify and resend reliability

00:29:55,950 --> 00:30:01,650
adding reliability is pretty easy you

00:29:57,690 --> 00:30:03,570
just set your outgoing window here and

00:30:01,650 --> 00:30:06,600
that means it will track the status of

00:30:03,570 --> 00:30:11,130
outgoing messages and you can access

00:30:06,600 --> 00:30:16,350
that later in on the receiving side

00:30:11,130 --> 00:30:23,100
similarly you you can use except to to

00:30:16,350 --> 00:30:25,140
acknowledge messages so as I mentioned

00:30:23,100 --> 00:30:28,679
before message it's a mutable and

00:30:25,140 --> 00:30:32,490
reusable holder of content this works

00:30:28,679 --> 00:30:34,679
well with the batch send and and it

00:30:32,490 --> 00:30:38,460
doesn't conflate the notion of a

00:30:34,679 --> 00:30:41,760
delivery and a message right so you can

00:30:38,460 --> 00:30:45,950
you can as the yeas image before you can

00:30:41,760 --> 00:30:48,600
modify a received message and resend it

00:30:45,950 --> 00:30:50,490
it also supports automatic data binding

00:30:48,600 --> 00:30:52,530
from aim QP to native type so you can

00:30:50,490 --> 00:30:54,300
stick it like a Python dictionary in as

00:30:52,530 --> 00:30:57,059
the body it will come out in JMS as a

00:30:54,300 --> 00:31:00,600
map message or come out in ruby as a

00:30:57,059 --> 00:31:03,540
hash a LAN is decoupled these it

00:31:00,600 --> 00:31:05,730
basically is just a an authoring tool

00:31:03,540 --> 00:31:07,230
it's it's a way to author a chunk of

00:31:05,730 --> 00:31:08,610
bytes and you can use that chunk of

00:31:07,230 --> 00:31:14,150
bites with messenger you can use that

00:31:08,610 --> 00:31:17,870
chunk of bytes with the engine itself so

00:31:14,150 --> 00:31:17,870
let's see how am i doing on time

00:31:21,040 --> 00:31:29,500
I'm going to do a little demo now and

00:31:26,490 --> 00:31:32,320
show you some actual code live code of

00:31:29,500 --> 00:31:38,620
this stuff working so I'm going to first

00:31:32,320 --> 00:31:41,770
show how this demo setup what I've got

00:31:38,620 --> 00:31:44,380
is a an order this is kind of like what

00:31:41,770 --> 00:31:46,930
what what you saw earlier in the

00:31:44,380 --> 00:31:50,590
examples but a little bit a little bit

00:31:46,930 --> 00:31:52,860
different so I've got a messenger or an

00:31:50,590 --> 00:31:56,110
order database implemented in Python

00:31:52,860 --> 00:31:57,550
it's implemented with messenger the

00:31:56,110 --> 00:32:03,700
database is actually just an in-memory

00:31:57,550 --> 00:32:05,230
dictionary but it would be pretty easy

00:32:03,700 --> 00:32:08,770
to use sequel light or something if you

00:32:05,230 --> 00:32:12,970
wanted persistence and this messenger is

00:32:08,770 --> 00:32:17,200
actually listening for three feeds it's

00:32:12,970 --> 00:32:18,910
it's listening to an order q I well to

00:32:17,200 --> 00:32:25,510
order queues one of which lives in

00:32:18,910 --> 00:32:30,730
service bus that's Microsoft's platform

00:32:25,510 --> 00:32:34,540
as a service offering of queueing the

00:32:30,730 --> 00:32:39,550
other sits in actually it's in an

00:32:34,540 --> 00:32:44,500
activemq instance running on an ec2

00:32:39,550 --> 00:32:48,100
machine I've got a couple of submit and

00:32:44,500 --> 00:32:49,720
update scripts written in Python and an

00:32:48,100 --> 00:32:57,010
order tracking page which is written in

00:32:49,720 --> 00:32:59,230
PHP so I'm actually going to show you

00:32:57,010 --> 00:33:01,810
the code for this first so you'll have

00:32:59,230 --> 00:33:06,540
to bear with me and I hope you can see

00:33:01,810 --> 00:33:06,540
this stuff

00:33:09,380 --> 00:33:17,560
so this is the order database sir OOP

00:33:20,880 --> 00:33:28,750
alright I hope this is big enough for

00:33:23,050 --> 00:33:32,110
you to see so to give you an idea this

00:33:28,750 --> 00:33:35,220
thing is what 64 lines of code and

00:33:32,110 --> 00:33:41,950
that's counting the the obligatory

00:33:35,220 --> 00:33:44,560
license header so this is our order

00:33:41,950 --> 00:33:54,900
database right here just a Python

00:33:44,560 --> 00:33:54,900
dictionary we create ooh shrink it OOP

00:33:59,140 --> 00:34:08,290
that better okay so we've got an order

00:34:05,560 --> 00:34:11,020
our order database here create a

00:34:08,290 --> 00:34:13,899
messenger start it and subscribe to

00:34:11,020 --> 00:34:17,350
these three feeds right so this first

00:34:13,899 --> 00:34:24,909
long one is actually an QP over SSL and

00:34:17,350 --> 00:34:27,190
it's talking to my proton West q where

00:34:24,909 --> 00:34:32,100
my orders Q at my proton West namespace

00:34:27,190 --> 00:34:36,220
inside of service bus this is this other

00:34:32,100 --> 00:34:39,990
line here is talking to activemq on my

00:34:36,220 --> 00:34:43,600
ec2 instance they're both feeding

00:34:39,990 --> 00:34:47,399
they're both order cues that are being

00:34:43,600 --> 00:34:50,169
funneled into this one messenger and

00:34:47,399 --> 00:34:52,149
this one right here if you note that

00:34:50,169 --> 00:34:54,070
little twiddle there actually is telling

00:34:52,149 --> 00:35:01,510
the messenger just bind locally and

00:34:54,070 --> 00:35:06,400
accept direct connections and so I

00:35:01,510 --> 00:35:08,650
create two messages a message to process

00:35:06,400 --> 00:35:10,480
incoming messages and a reply so I can

00:35:08,650 --> 00:35:15,660
construct my replies then I have my

00:35:10,480 --> 00:35:18,220
ubiquitous infinite loop here and

00:35:15,660 --> 00:35:20,770
receive will just block until I have

00:35:18,220 --> 00:35:25,540
incoming messages and then I can process

00:35:20,770 --> 00:35:28,390
my incoming messages get will fill the

00:35:25,540 --> 00:35:32,290
the message with whatever's on the head

00:35:28,390 --> 00:35:34,840
of the incoming queue this prints it out

00:35:32,290 --> 00:35:37,990
for just for logging so I clear the

00:35:34,840 --> 00:35:41,170
reply message pull out the order ID and

00:35:37,990 --> 00:35:44,200
then just have a big ugly switch

00:35:41,170 --> 00:35:45,970
statement or well pythons version of a

00:35:44,200 --> 00:35:51,610
strip of a switch statement which is a

00:35:45,970 --> 00:35:53,770
big if else--if latter and so you know I

00:35:51,610 --> 00:35:57,790
check on the type if it's a submission I

00:35:53,770 --> 00:36:01,900
I update the status depending and stick

00:35:57,790 --> 00:36:03,940
it in the my database if if it's an

00:36:01,900 --> 00:36:07,150
update i'll update it based on the

00:36:03,940 --> 00:36:09,850
content of the body and if it's if it's

00:36:07,150 --> 00:36:11,440
a status request I actually construct a

00:36:09,850 --> 00:36:17,050
reply

00:36:11,440 --> 00:36:22,330
and send send the reply off to whatever

00:36:17,050 --> 00:36:26,380
was put in the reply to address and if I

00:36:22,330 --> 00:36:28,690
also support the query for just listing

00:36:26,380 --> 00:36:31,570
all of them all of the orders in the

00:36:28,690 --> 00:36:36,940
database which is mostly just for my

00:36:31,570 --> 00:36:38,920
debugging purposes so that's it that's

00:36:36,940 --> 00:36:45,370
the that's the order processing side of

00:36:38,920 --> 00:36:47,860
things submit has some random command

00:36:45,370 --> 00:36:50,620
line argument parsing oh and one

00:36:47,860 --> 00:36:53,050
interesting thing submit does is it it's

00:36:50,620 --> 00:36:55,630
going to randomly choose a queue to send

00:36:53,050 --> 00:36:58,450
to so I got this idea over the weekend

00:36:55,630 --> 00:37:01,990
when or well actually yeah over the

00:36:58,450 --> 00:37:06,970
weekend when I noticed or when service

00:37:01,990 --> 00:37:09,600
bus had its global outage and I was like

00:37:06,970 --> 00:37:12,760
hmm it's going to do a demo using that

00:37:09,600 --> 00:37:16,410
that that it would be unfortunate if

00:37:12,760 --> 00:37:20,170
that were to happen in the middle and so

00:37:16,410 --> 00:37:22,330
this way actually it's it's I've got

00:37:20,170 --> 00:37:26,080
redundant hughes between my front end

00:37:22,330 --> 00:37:30,660
and back end and I just had I just

00:37:26,080 --> 00:37:34,770
randomly pick one here to send it to and

00:37:30,660 --> 00:37:40,660
you know create my message send it

00:37:34,770 --> 00:37:43,480
that's it right update is pretty much

00:37:40,660 --> 00:37:46,780
the same thing except the message is

00:37:43,480 --> 00:37:52,800
slightly different so that's that's the

00:37:46,780 --> 00:37:52,800
code here and i'm going to show you you

00:37:53,400 --> 00:37:58,079
sorry

00:37:55,920 --> 00:38:00,950
I'm going to make sure it's still

00:37:58,079 --> 00:38:00,950
actually working

00:38:11,530 --> 00:38:15,860
alright so what you're seeing up here on

00:38:14,270 --> 00:38:20,240
the top right hand corner is the

00:38:15,860 --> 00:38:24,140
actually the just a log from that ec2

00:38:20,240 --> 00:38:31,760
instance from from the order database

00:38:24,140 --> 00:38:34,490
and we can go to the so this is this is

00:38:31,760 --> 00:38:36,290
the web page here there the tracking

00:38:34,490 --> 00:38:39,140
page so you can see that there are a

00:38:36,290 --> 00:38:46,270
couple of orders in there already so I

00:38:39,140 --> 00:38:46,270
can submit a new one say want you know

00:38:47,560 --> 00:39:01,850
10 units of some random skew the Wi-Fi

00:38:54,920 --> 00:39:05,170
here is a little bit slow but you can

00:39:01,850 --> 00:39:08,120
see that it goes this one went through

00:39:05,170 --> 00:39:09,710
this one went through service boss right

00:39:08,120 --> 00:39:16,990
and you can see it came out the other

00:39:09,710 --> 00:39:19,520
end be and you know let's submit just a

00:39:16,990 --> 00:39:27,700
couple more see if any of them go

00:39:19,520 --> 00:39:27,700
through the other end still service plus

00:39:30,900 --> 00:39:34,760
the mission have used random

00:39:43,730 --> 00:39:54,050
what's that yeah well here let me try

00:39:48,700 --> 00:39:59,330
all right so I'm just going to comment

00:39:54,050 --> 00:40:07,460
that out so that we force one to go

00:39:59,330 --> 00:40:09,890
through ec2 or the through activemq

00:40:07,460 --> 00:40:11,390
there we went through activemq activemq

00:40:09,890 --> 00:40:15,470
actually comes back a little faster than

00:40:11,390 --> 00:40:19,640
service bus for some reason so we can go

00:40:15,470 --> 00:40:24,560
check our status they're all pending you

00:40:19,640 --> 00:40:30,859
know click here look at the look at the

00:40:24,560 --> 00:40:33,130
details and let's let's update this last

00:40:30,859 --> 00:40:33,130
one

00:40:37,450 --> 00:40:45,700
let's say it's shipped and the fedex

00:40:41,560 --> 00:40:48,869
tracking number is you know five that's

00:40:45,700 --> 00:40:48,869
a good tracking number and

00:40:57,809 --> 00:41:03,299
we can see the status is now shipped

00:40:59,729 --> 00:41:09,499
fedex tracking number is five and there

00:41:03,299 --> 00:41:09,499
you go so that's

00:41:17,319 --> 00:41:24,509
so that's this picture it didn't take

00:41:20,019 --> 00:41:27,609
that long to throw together and in in a

00:41:24,509 --> 00:41:32,079
you know it you've got structured data

00:41:27,609 --> 00:41:37,390
passing between between PHP and Python

00:41:32,079 --> 00:41:39,880
you've got you've you've got dumb you've

00:41:37,390 --> 00:41:42,160
got the the front end in the back end

00:41:39,880 --> 00:41:44,769
talking through you know not only

00:41:42,160 --> 00:41:51,729
redundant cues but two completely

00:41:44,769 --> 00:41:54,519
different cloud providers and and it all

00:41:51,729 --> 00:42:06,130
took maybe a couple hours to put

00:41:54,519 --> 00:42:12,190
together so the I guess the takeaway is

00:42:06,130 --> 00:42:14,229
n QP is really intended to make it easy

00:42:12,190 --> 00:42:17,440
to build these kinds of distributed

00:42:14,229 --> 00:42:19,690
systems and it's really taking this

00:42:17,440 --> 00:42:21,849
messaging thing which sort of grew up in

00:42:19,690 --> 00:42:25,029
this sort of big heavyweight middleware

00:42:21,849 --> 00:42:26,289
II enterprise-e backend thing and bring

00:42:25,029 --> 00:42:29,499
it to the masses right and there's

00:42:26,289 --> 00:42:33,670
there's a really great synergy here with

00:42:29,499 --> 00:42:35,949
with mobile with mobile communication

00:42:33,670 --> 00:42:39,969
scenarios because this kind of store and

00:42:35,949 --> 00:42:41,859
forward asynchronous messaging our

00:42:39,969 --> 00:42:46,719
communication pattern is just a perfect

00:42:41,859 --> 00:42:48,640
fit for for mobile networks and proton

00:42:46,719 --> 00:42:50,799
the goal of proton is really to make

00:42:48,640 --> 00:42:52,299
that happen on two fronts protocol

00:42:50,799 --> 00:42:54,749
engine that you can embed in whatever

00:42:52,299 --> 00:42:57,339
server you have that wants to speak amqp

00:42:54,749 --> 00:42:59,559
doesn't need to be a queuing or

00:42:57,339 --> 00:43:03,160
messaging traditional messaging thing it

00:42:59,559 --> 00:43:05,469
could be anything and the messenger API

00:43:03,160 --> 00:43:07,930
which is you know dirt simple way to

00:43:05,469 --> 00:43:12,069
sort of get you know dirt simple on

00:43:07,930 --> 00:43:14,380
rampant for the amqp highway and so we

00:43:12,069 --> 00:43:18,880
think this kind of thing is going to be

00:43:14,380 --> 00:43:24,300
the basis of next-gen applications if

00:43:18,880 --> 00:43:28,210
you want to learn more there's there's

00:43:24,300 --> 00:43:30,490
information up here proton website amqp

00:43:28,210 --> 00:43:34,180
org you can read more about all this

00:43:30,490 --> 00:43:36,270
stuff and I guess I'll open up for

00:43:34,180 --> 00:43:36,270
questions

00:43:43,960 --> 00:43:52,250
how many people I I don't know how many

00:43:47,360 --> 00:43:56,180
people are using it projects so activemq

00:43:52,250 --> 00:44:01,970
uses the java implementation to provide

00:43:56,180 --> 00:44:04,270
their 10 support I know or the c++

00:44:01,970 --> 00:44:08,270
broker uses the sea implementation

00:44:04,270 --> 00:44:10,940
there's a couple of other other things

00:44:08,270 --> 00:44:13,540
in sort of in the works that are that

00:44:10,940 --> 00:44:19,220
are other projects that are there that

00:44:13,540 --> 00:44:21,650
are moving to it but don't currently use

00:44:19,220 --> 00:44:26,740
it and so that's what I know if I know

00:44:21,650 --> 00:44:28,760
there's there's a bunch that there's a

00:44:26,740 --> 00:44:30,560
from what I've seen on the list as

00:44:28,760 --> 00:44:32,330
there's a bunch of other people using it

00:44:30,560 --> 00:44:38,350
but I don't know actually what projects

00:44:32,330 --> 00:44:38,350
they belong to yeah

00:44:43,160 --> 00:44:48,809
it's natural types in that language so

00:44:45,930 --> 00:44:53,359
in Python you use a dictionary and so

00:44:48,809 --> 00:44:57,380
the MQB type system supports lists Maps

00:44:53,359 --> 00:45:01,190
arrays it supports all the basic

00:44:57,380 --> 00:45:07,799
primitive types are you know strings

00:45:01,190 --> 00:45:09,510
symbols binary data integers floating

00:45:07,799 --> 00:45:16,579
point it actually even has things like

00:45:09,510 --> 00:45:20,599
decimal decimal 64 decimal 128 in it and

00:45:16,579 --> 00:45:24,809
you you IDs as well timestamps right so

00:45:20,599 --> 00:45:26,760
basically you any it supports sufficient

00:45:24,809 --> 00:45:30,210
numbers of types that any language can

00:45:26,760 --> 00:45:33,359
map their type system into amqp type

00:45:30,210 --> 00:45:35,160
system that part's easy the the part

00:45:33,359 --> 00:45:37,680
that's a little bit harder when you're

00:45:35,160 --> 00:45:40,890
implementing a data binding which

00:45:37,680 --> 00:45:42,690
protons done for you but is mapping from

00:45:40,890 --> 00:45:45,420
aim could be types back out into the

00:45:42,690 --> 00:45:47,490
type system so for example if your and

00:45:45,420 --> 00:45:50,069
and this this becomes visible and you

00:45:47,490 --> 00:45:52,319
use it a little bit because even though

00:45:50,069 --> 00:45:55,859
you can say and see you can stick like

00:45:52,319 --> 00:45:56,910
an unsigned 64-bit integer and in MV is

00:45:55,859 --> 00:45:59,130
actually preserving that type

00:45:56,910 --> 00:46:00,839
information if it comes out in Python

00:45:59,130 --> 00:46:04,020
and you're just using the default

00:46:00,839 --> 00:46:05,220
mappings lucky actually pythons a bad

00:46:04,020 --> 00:46:09,680
example because in Python you can

00:46:05,220 --> 00:46:09,680
subclass like the basic integer types

00:46:10,369 --> 00:46:15,510
and so you actually will get a number

00:46:12,750 --> 00:46:16,559
that that is a subclass that deck so it

00:46:15,510 --> 00:46:19,579
actually preserves the type information

00:46:16,559 --> 00:46:22,200
Python but it will look to you like a

00:46:19,579 --> 00:46:24,569
just a regular integer all right because

00:46:22,200 --> 00:46:25,920
Python doesn't have job as a better

00:46:24,569 --> 00:46:28,140
example right so Java doesn't have

00:46:25,920 --> 00:46:31,049
unsigned integers right so if you want

00:46:28,140 --> 00:46:32,579
to stick yeah it into you know stick and

00:46:31,049 --> 00:46:34,920
unsigned integer and I'm like the sea

00:46:32,579 --> 00:46:38,010
end of a nap and and have it come out in

00:46:34,920 --> 00:46:40,530
Java you have a choice between having it

00:46:38,010 --> 00:46:43,319
come out as something that preserves the

00:46:40,530 --> 00:46:47,849
type information right so some kind of

00:46:43,319 --> 00:46:51,240
Java class you know rapper or you can

00:46:47,849 --> 00:46:53,790
have the data binding basically massage

00:46:51,240 --> 00:46:54,920
it for you into and whatever whatever

00:46:53,790 --> 00:47:04,099
type will

00:46:54,920 --> 00:47:06,440
so if it's like it yeah yes yes and so

00:47:04,099 --> 00:47:08,420
that's that's that's one of the trickier

00:47:06,440 --> 00:47:12,079
bits but that that's all that's all in

00:47:08,420 --> 00:47:13,460
the implementation as a user you just

00:47:12,079 --> 00:47:16,780
need to be aware that okay if you're

00:47:13,460 --> 00:47:19,549
talking between Java and C and your see

00:47:16,780 --> 00:47:21,290
application depends on on sign type

00:47:19,549 --> 00:47:23,660
information being preserved you're going

00:47:21,290 --> 00:47:27,309
to have to be careful there because Java

00:47:23,660 --> 00:47:30,829
doesn't naturally represent those types

00:47:27,309 --> 00:47:33,559
but if you stick to sort of a basic

00:47:30,829 --> 00:47:55,040
interoperable set of types it just all

00:47:33,559 --> 00:47:57,109
works seamlessly yep so there's well

00:47:55,040 --> 00:48:04,760
that's a that's a big question there's a

00:47:57,109 --> 00:48:07,490
couple of answers to that so the I mean

00:48:04,760 --> 00:48:09,950
one ways ssl you can use client-side and

00:48:07,490 --> 00:48:11,930
server-side certs right and and every

00:48:09,950 --> 00:48:14,599
amqp connection you make can be

00:48:11,930 --> 00:48:19,190
protected with ssl if you want to do

00:48:14,599 --> 00:48:23,799
that let's if you want to use that from

00:48:19,190 --> 00:48:28,040
a mobile device we actually support

00:48:23,799 --> 00:48:31,640
actually the proton engine itself embeds

00:48:28,040 --> 00:48:33,799
the open SSL protocol engine so it can

00:48:31,640 --> 00:48:36,770
actually speak ssl you don't have to do

00:48:33,799 --> 00:48:39,290
anything to get that and it'll actually

00:48:36,770 --> 00:48:42,109
support session resumption as well so

00:48:39,290 --> 00:48:44,420
you don't need to pay the cost of the

00:48:42,109 --> 00:48:50,270
expensive ssl handshake on mobile

00:48:44,420 --> 00:48:51,559
devices so that's that's one answer but

00:48:50,270 --> 00:48:56,390
ultimately if you're building a

00:48:51,559 --> 00:48:59,990
federated network of you know messaging

00:48:56,390 --> 00:49:03,380
intermediaries the point-to-point SSL

00:48:59,990 --> 00:49:06,319
protection is really just protecting at

00:49:03,380 --> 00:49:08,730
a lower layer then your app might

00:49:06,319 --> 00:49:12,810
necessarily want right and

00:49:08,730 --> 00:49:15,380
way you would probably do security if

00:49:12,810 --> 00:49:18,420
you're in that kind of environment is

00:49:15,380 --> 00:49:20,550
well ultimate answer is with message

00:49:18,420 --> 00:49:22,470
level signing so there's there's areas

00:49:20,550 --> 00:49:25,440
MTP gives you areas where you can stick

00:49:22,470 --> 00:49:27,210
a message level signature that travels

00:49:25,440 --> 00:49:28,650
with the message through the network so

00:49:27,210 --> 00:49:30,900
the message can actually flow through

00:49:28,650 --> 00:49:32,880
untrusted intermediaries and when you

00:49:30,900 --> 00:49:35,670
get it you can actually validate it kind

00:49:32,880 --> 00:49:38,520
of like email you know pgp signatures

00:49:35,670 --> 00:49:43,440
except except you're probably going to

00:49:38,520 --> 00:49:45,480
want to actually use it so that that's

00:49:43,440 --> 00:49:48,720
sort of the low end and the high end and

00:49:45,480 --> 00:49:51,390
there's sort of there's uh other answers

00:49:48,720 --> 00:49:55,040
in between you can you you can actually

00:49:51,390 --> 00:49:58,740
just last week I was at a and off-site

00:49:55,040 --> 00:50:01,320
at microsoft campus discussing sort of

00:49:58,740 --> 00:50:04,920
how to well or to map claims based

00:50:01,320 --> 00:50:09,270
security into mqp so that you can that

00:50:04,920 --> 00:50:10,410
you can use the things like OAuth within

00:50:09,270 --> 00:50:17,130
could be the same way to use it with

00:50:10,410 --> 00:50:22,110
HTTP so they're there and amqp that the

00:50:17,130 --> 00:50:24,390
10 standard actually supports sasal so

00:50:22,110 --> 00:50:28,560
you can any anything that works with SAS

00:50:24,390 --> 00:50:31,050
also Kerberos off you know plane and you

00:50:28,560 --> 00:50:33,720
know md5 all those all the standard

00:50:31,050 --> 00:50:38,010
sazzle mechanisms will work with MVP as

00:50:33,720 --> 00:50:40,160
well so it does that answer your

00:50:38,010 --> 00:50:40,160
question

00:50:40,300 --> 00:50:43,839
any other questions

00:50:59,920 --> 00:51:02,819
sorry

00:51:02,920 --> 00:51:06,580
what other areas

00:51:09,090 --> 00:51:19,000
well okay so he's asking what other

00:51:16,720 --> 00:51:24,240
areas as are the community looking for

00:51:19,000 --> 00:51:26,950
people to be involved in saying Oh

00:51:24,240 --> 00:51:30,010
probably one of the big areas is

00:51:26,950 --> 00:51:35,980
bindings so we've designed this

00:51:30,010 --> 00:51:37,000
architecture to be very amenable to you

00:51:35,980 --> 00:51:40,990
know creating bindings in other

00:51:37,000 --> 00:51:44,560
languages but in order to in order to

00:51:40,990 --> 00:51:45,820
take sort of the basic raw API that you

00:51:44,560 --> 00:51:47,920
get out of swag and turn it into

00:51:45,820 --> 00:51:50,200
something that looks natural and normal

00:51:47,920 --> 00:51:52,090
in that language there's a little bit of

00:51:50,200 --> 00:51:53,500
work you do to actually wrap it you

00:51:52,090 --> 00:51:56,440
don't need to be a protocol expert to do

00:51:53,500 --> 00:51:58,090
it you just need to have a little bit of

00:51:56,440 --> 00:52:00,160
familiarity with the language and and

00:51:58,090 --> 00:52:01,810
sort of know how things are typically

00:52:00,160 --> 00:52:03,490
done what standard libraries there are

00:52:01,810 --> 00:52:06,640
what standard types there are you know

00:52:03,490 --> 00:52:10,240
like mapping into like I did the PHP one

00:52:06,640 --> 00:52:12,940
and just figuring out okay I had never

00:52:10,240 --> 00:52:14,410
done PHP before anything with PHP before

00:52:12,940 --> 00:52:16,120
I did that and it took me a while just

00:52:14,410 --> 00:52:17,950
to figure out okay there doesn't seem to

00:52:16,120 --> 00:52:19,660
be a standard view ID type whereas in

00:52:17,950 --> 00:52:21,940
Python there is a standard view ID type

00:52:19,660 --> 00:52:23,560
so you know things like that figuring

00:52:21,940 --> 00:52:27,040
out how to map those types into the

00:52:23,560 --> 00:52:31,810
language that that's something that that

00:52:27,040 --> 00:52:34,210
there would definitely be a benefit from

00:52:31,810 --> 00:52:38,710
from sort of a diverse range of

00:52:34,210 --> 00:52:44,740
contributors there and also JavaScript

00:52:38,710 --> 00:52:47,290
so we have sort of the basis for for

00:52:44,740 --> 00:52:49,090
scripting language support is is the C

00:52:47,290 --> 00:52:50,830
implementation because that's kind of

00:52:49,090 --> 00:52:53,050
what you want for something that's

00:52:50,830 --> 00:52:54,130
you're going to be using from Python but

00:52:53,050 --> 00:52:56,230
we also have a pure Java implementation

00:52:54,130 --> 00:52:58,120
and we plan a pure JavaScript

00:52:56,230 --> 00:53:01,060
implementation for getting inside the

00:52:58,120 --> 00:53:05,560
browser and so the pure Java

00:53:01,060 --> 00:53:07,980
implementations is is is humming right

00:53:05,560 --> 00:53:11,290
along beside the c1 the JavaScript one

00:53:07,980 --> 00:53:12,880
has not yet been started and so well

00:53:11,290 --> 00:53:16,870
okay a little bit of works been done but

00:53:12,880 --> 00:53:19,000
it definitely needs more help and more

00:53:16,870 --> 00:53:20,369
people sort of familiar with that with

00:53:19,000 --> 00:53:24,809
that

00:53:20,369 --> 00:53:24,809

YouTube URL: https://www.youtube.com/watch?v=9qU3eB9EQQw


