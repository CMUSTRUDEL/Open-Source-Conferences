Title: SPDY in Apache Httpd
Publication date: 2013-10-17
Playlist: Apachecon NA 2013 - day 1
Description: 
	Matthew Steele
ApacheCon NA 2013
Track : A Patchy Web
Captions: 
	00:00:00,000 --> 00:00:08,010
hi I'm Matthew Steele let's talk about

00:00:03,240 --> 00:00:11,280
speedy so I work on Google's make the

00:00:08,010 --> 00:00:12,540
web fast team and I'm the primary author

00:00:11,280 --> 00:00:15,179
of mod speedy which I'm going to be

00:00:12,540 --> 00:00:17,070
talking about today can I get a quick

00:00:15,179 --> 00:00:18,900
show of hands how many of you are like

00:00:17,070 --> 00:00:22,170
pretty familiar already with the speedy

00:00:18,900 --> 00:00:25,529
protocol some hands how many of you are

00:00:22,170 --> 00:00:28,470
not so familiar with it okay I will I

00:00:25,529 --> 00:00:30,630
will give some introduction so speedy is

00:00:28,470 --> 00:00:32,969
a new protocol it's been around for a

00:00:30,630 --> 00:00:34,890
few years now but new ish that was

00:00:32,969 --> 00:00:36,870
designed with the explicit goal of

00:00:34,890 --> 00:00:39,989
making the web faster making pages load

00:00:36,870 --> 00:00:42,690
faster and essentially it's sort of a

00:00:39,989 --> 00:00:46,110
session layer protocol it fits in on top

00:00:42,690 --> 00:00:48,329
of secure TCP and then on top of speedy

00:00:46,110 --> 00:00:52,129
you can layer other protocols mainly hd2

00:00:48,329 --> 00:00:54,809
bth TTP but potentially other things and

00:00:52,129 --> 00:00:57,000
speedy does a few things for you sort of

00:00:54,809 --> 00:01:00,289
automatically so the biggest thing that

00:00:57,000 --> 00:01:02,430
it does is it allows you to multiplex

00:01:00,289 --> 00:01:06,479
multiple independent concurrent

00:01:02,430 --> 00:01:08,549
interleaved HTTP streams over a single

00:01:06,479 --> 00:01:10,500
TCP connection and this turns out to

00:01:08,549 --> 00:01:12,000
have huge latency winds in terms of

00:01:10,500 --> 00:01:14,090
saving on round trips and using the

00:01:12,000 --> 00:01:16,110
network more efficiently

00:01:14,090 --> 00:01:17,939
speedy also does a couple of other

00:01:16,110 --> 00:01:20,549
things it gives you header compression

00:01:17,939 --> 00:01:22,950
so with plain HTTP write you know all

00:01:20,549 --> 00:01:28,200
your request and response headers are

00:01:22,950 --> 00:01:29,700
sent sort of plain text and you send the

00:01:28,200 --> 00:01:31,110
same stuff over and over again for every

00:01:29,700 --> 00:01:33,930
request so with speedy all that gets

00:01:31,110 --> 00:01:36,450
compressed with gzip or possibly

00:01:33,930 --> 00:01:38,579
something else in the future and that

00:01:36,450 --> 00:01:40,229
cards are compressed accross requests so

00:01:38,579 --> 00:01:42,630
if you send similar headers into the

00:01:40,229 --> 00:01:44,009
same cookie same user agent over and

00:01:42,630 --> 00:01:45,509
over again for each request over time

00:01:44,009 --> 00:01:48,200
that shrinks down very small and again

00:01:45,509 --> 00:01:51,329
uses the network much more efficiently

00:01:48,200 --> 00:01:54,329
speedy also so multiplexing header

00:01:51,329 --> 00:01:56,219
compression request prioritization so

00:01:54,329 --> 00:01:57,960
because of the multiplexing even though

00:01:56,219 --> 00:02:00,930
you've only got a single TCP connection

00:01:57,960 --> 00:02:03,619
the client can make many requests even

00:02:00,930 --> 00:02:05,310
you know 100 requests all at once

00:02:03,619 --> 00:02:06,630
simultaneously and the server can

00:02:05,310 --> 00:02:10,530
respond to those in any order or

00:02:06,630 --> 00:02:11,849
interleave the responses so speedy also

00:02:10,530 --> 00:02:13,170
has its prioritization feature where the

00:02:11,849 --> 00:02:13,360
client can make all the requests but it

00:02:13,170 --> 00:02:14,440
can

00:02:13,360 --> 00:02:15,670
tell the server you know these are the

00:02:14,440 --> 00:02:17,710
important ones these ones are less

00:02:15,670 --> 00:02:19,150
important so do these important ones

00:02:17,710 --> 00:02:20,410
first but if those get stuck you know

00:02:19,150 --> 00:02:23,200
maybe one of them is blocked on some

00:02:20,410 --> 00:02:25,270
back-end database call and get stuck in

00:02:23,200 --> 00:02:27,280
the middle that's fine you know do

00:02:25,270 --> 00:02:29,290
something send something to me seems to

00:02:27,280 --> 00:02:30,550
me something lower priority but you know

00:02:29,290 --> 00:02:32,560
once the higher priority thing gets

00:02:30,550 --> 00:02:33,880
unstuck and stop what you're doing go

00:02:32,560 --> 00:02:35,320
back to the high priority thing send the

00:02:33,880 --> 00:02:37,840
rest of that and then and then move on

00:02:35,320 --> 00:02:39,130
down the line so this lets the client

00:02:37,840 --> 00:02:40,660
you know be very explicitly server

00:02:39,130 --> 00:02:41,920
exactly what it wants you know I want

00:02:40,660 --> 00:02:43,270
all these things I want them in this

00:02:41,920 --> 00:02:45,670
order and the server does its best to

00:02:43,270 --> 00:02:47,290
use the pipe efficiently and the last

00:02:45,670 --> 00:02:49,330
thing is this feature called server push

00:02:47,290 --> 00:02:50,980
so with HTTP the server has no way to

00:02:49,330 --> 00:02:53,320
send data to the client unless the

00:02:50,980 --> 00:02:54,520
client actually asks for it and when you

00:02:53,320 --> 00:02:55,840
think about it it's it's sort of a

00:02:54,520 --> 00:02:59,380
little silly right if the browser

00:02:55,840 --> 00:03:01,030
requests hm HTML file the server knows

00:02:59,380 --> 00:03:02,709
full well the very next thing the client

00:03:01,030 --> 00:03:05,200
is going to do is ask for like the first

00:03:02,709 --> 00:03:06,370
JavaScript file in the HTML but the

00:03:05,200 --> 00:03:08,440
server just sits there for an entire

00:03:06,370 --> 00:03:09,760
round-trip well this response goes back

00:03:08,440 --> 00:03:11,530
down to the client and the requests

00:03:09,760 --> 00:03:12,730
comes back up to the server and if the

00:03:11,530 --> 00:03:14,440
server knows the client neither why

00:03:12,730 --> 00:03:15,940
doesn't it just send it right away and

00:03:14,440 --> 00:03:19,090
then by the time the client knows it

00:03:15,940 --> 00:03:20,620
needs it'll already be there there are

00:03:19,090 --> 00:03:23,560
some caveats there obviously maybe the

00:03:20,620 --> 00:03:24,549
client already has it in cash so there's

00:03:23,560 --> 00:03:25,810
some issues here but you can sort of

00:03:24,549 --> 00:03:28,180
think of server pushes being a lot like

00:03:25,810 --> 00:03:31,780
a resource inlining but better and more

00:03:28,180 --> 00:03:34,989
flexible so those are sort of the core

00:03:31,780 --> 00:03:37,170
things that speedy gives you and you

00:03:34,989 --> 00:03:39,690
know again it's it's all geared towards

00:03:37,170 --> 00:03:41,970
making pages load faster on the web

00:03:39,690 --> 00:03:45,610
using the network more efficiently

00:03:41,970 --> 00:03:46,989
saving on round trips which is a big

00:03:45,610 --> 00:03:48,760
deal especially on mobile where

00:03:46,989 --> 00:03:51,150
bandwidth is limited and round trips are

00:03:48,760 --> 00:03:51,150
very expensive

00:03:51,370 --> 00:03:54,280
all right this all sounds great

00:03:52,540 --> 00:03:57,519
hopefully is anyone actually using this

00:03:54,280 --> 00:03:59,980
thing yes client-side Chrome Firefox

00:03:57,519 --> 00:04:01,330
Opera both desktop and mobile for all of

00:03:59,980 --> 00:04:04,090
those support as does the Android

00:04:01,330 --> 00:04:05,739
browser so right by browser market share

00:04:04,090 --> 00:04:07,870
that's over half of all users are using

00:04:05,739 --> 00:04:10,600
a speedy capable browser so if you go

00:04:07,870 --> 00:04:12,610
home today and you add speedy to support

00:04:10,600 --> 00:04:14,200
to your site you know your site will

00:04:12,610 --> 00:04:15,430
instantly get faster for you know

00:04:14,200 --> 00:04:17,829
roughly half of your users that's

00:04:15,430 --> 00:04:21,070
something to think about server side

00:04:17,829 --> 00:04:25,270
they're supporting for Apache using mod

00:04:21,070 --> 00:04:26,960
speedy there's also support either in

00:04:25,270 --> 00:04:29,240
beta or

00:04:26,960 --> 00:04:31,819
full support in nginx jetty nodejs

00:04:29,240 --> 00:04:33,199
probably some others I'm not aware of in

00:04:31,819 --> 00:04:35,690
terms of big players that are using this

00:04:33,199 --> 00:04:37,910
Google Akamai Facebook Twitter WordPress

00:04:35,690 --> 00:04:39,680
com probably other ones so this is

00:04:37,910 --> 00:04:43,430
gaining a lot of traction it's a big

00:04:39,680 --> 00:04:45,770
deal and just give you an idea of what's

00:04:43,430 --> 00:04:47,990
coming speedy wise so speedy three is

00:04:45,770 --> 00:04:50,690
sort of the current version speedy four

00:04:47,990 --> 00:04:52,009
is on its way soon it has some new

00:04:50,690 --> 00:04:53,479
improvements to the protocol that make

00:04:52,009 --> 00:04:55,430
it even more efficient a better header

00:04:53,479 --> 00:04:57,410
compression that are smarter

00:04:55,430 --> 00:04:59,000
prioritization some more push features

00:04:57,410 --> 00:04:59,889
you know lots of things to make it

00:04:59,000 --> 00:05:03,430
better

00:04:59,889 --> 00:05:07,520
more importantly though the IETF is

00:05:03,430 --> 00:05:10,520
talking now about HTTP 2.0 and forming

00:05:07,520 --> 00:05:12,320
that standard and I'm not part of that

00:05:10,520 --> 00:05:14,000
group I talked to some people who are

00:05:12,320 --> 00:05:17,810
and as I understand it they're using

00:05:14,000 --> 00:05:19,400
speedy as a starting point so HTTP 2.0

00:05:17,810 --> 00:05:20,539
probably won't look exactly like speedy

00:05:19,400 --> 00:05:22,039
but a lot of the same features their

00:05:20,539 --> 00:05:24,560
particular multiplexing are going to be

00:05:22,039 --> 00:05:25,610
there so everything I'm telling you

00:05:24,560 --> 00:05:27,139
today about speedy you should be

00:05:25,610 --> 00:05:29,090
thinking this is the future of the web

00:05:27,139 --> 00:05:32,389
this is what's coming and this is the

00:05:29,090 --> 00:05:34,789
kind of stuff that apache is going to

00:05:32,389 --> 00:05:38,659
need to support the apache web server is

00:05:34,789 --> 00:05:42,590
going to need to support to keep up with

00:05:38,659 --> 00:05:44,389
the next HTTP standard so mont speedy so

00:05:42,590 --> 00:05:46,490
this is a third-party speedy module that

00:05:44,389 --> 00:05:49,699
we developed it's free open source

00:05:46,490 --> 00:05:51,440
software Apache 2 license it's been out

00:05:49,699 --> 00:05:54,830
now for a little less than a year first

00:05:51,440 --> 00:05:56,570
launched in April of 2012 today it's got

00:05:54,830 --> 00:05:59,870
support full support for speedy 2 and

00:05:56,570 --> 00:06:01,969
speedy 3 once speedy 4 spec is done then

00:05:59,870 --> 00:06:04,669
we'll support that - it's a drop-in

00:06:01,969 --> 00:06:06,800
module just install it it works with

00:06:04,669 --> 00:06:10,759
your existing server configuration all

00:06:06,800 --> 00:06:12,139
your existing modules install it in your

00:06:10,759 --> 00:06:14,389
you know your Apache server immediately

00:06:12,139 --> 00:06:16,449
speak speedy and you can build it from

00:06:14,389 --> 00:06:21,949
source or we've got binary packages for

00:06:16,449 --> 00:06:23,479
Debian and Brett net so with that

00:06:21,949 --> 00:06:26,560
introduction I want to talk a little bit

00:06:23,479 --> 00:06:30,560
more in depth about how mod speedy works

00:06:26,560 --> 00:06:31,969
and in order to work in order to support

00:06:30,560 --> 00:06:33,139
speed in Apache there's basically four

00:06:31,969 --> 00:06:34,250
things it needs to be able to do and I'm

00:06:33,139 --> 00:06:36,050
going to go over each one of these in

00:06:34,250 --> 00:06:37,580
detail sort of what this is and then how

00:06:36,050 --> 00:06:39,039
what mod speedy needs to do to support

00:06:37,580 --> 00:06:41,439
it

00:06:39,039 --> 00:06:45,550
and some of these are going to be a

00:06:41,439 --> 00:06:47,580
little bit hacky so you'll you'll kind

00:06:45,550 --> 00:06:49,509
of get a little more gory detail I

00:06:47,580 --> 00:06:51,699
should say up front I'm like a little

00:06:49,509 --> 00:06:53,439
bit intimidated by this group I'm not an

00:06:51,699 --> 00:06:55,599
Apache expert in fact mod speedy is the

00:06:53,439 --> 00:06:59,020
first Apache module that I have ever

00:06:55,599 --> 00:07:00,159
written so maybe I will tell you about

00:06:59,020 --> 00:07:01,330
some of these things and some of you

00:07:00,159 --> 00:07:03,099
will tell me that I could be doing these

00:07:01,330 --> 00:07:06,990
in a much better way and I would love to

00:07:03,099 --> 00:07:09,129
hear that feedback at the break

00:07:06,990 --> 00:07:12,129
so let's go into each one of these so

00:07:09,129 --> 00:07:15,129
the first thing is this thing called

00:07:12,129 --> 00:07:17,560
next protocol negotiation or NPM so npn

00:07:15,129 --> 00:07:20,500
is a TLS extension this is not something

00:07:17,560 --> 00:07:23,199
that's specific to speedy this is a new

00:07:20,500 --> 00:07:25,330
TLS extension it's supported by recent

00:07:23,199 --> 00:07:28,270
versions of OpenSSL which means that if

00:07:25,330 --> 00:07:29,800
you build you know modest a cell with a

00:07:28,270 --> 00:07:31,870
recent enough version of OpenSSL than

00:07:29,800 --> 00:07:35,169
that support will be in there

00:07:31,870 --> 00:07:37,870
fundamentally and basically the way this

00:07:35,169 --> 00:07:41,289
works is that during the SSL handshake

00:07:37,870 --> 00:07:42,969
three-way handshake there is some

00:07:41,289 --> 00:07:44,919
additional data that gets sent by server

00:07:42,969 --> 00:07:46,389
and client in order to agree on once

00:07:44,919 --> 00:07:51,099
we've got the secure channel open what

00:07:46,389 --> 00:07:52,120
protocol are we going to use so the you

00:07:51,099 --> 00:07:53,199
know the client service ends the first

00:07:52,120 --> 00:07:55,599
phase the handshake and then when the

00:07:53,199 --> 00:07:57,580
server sends back its certificate it

00:07:55,599 --> 00:07:59,830
also sends back this NPN data where the

00:07:57,580 --> 00:08:03,009
server lists each of the protocols that

00:07:59,830 --> 00:08:06,250
it supports so HTTP 1.1 speedy - speedy

00:08:03,009 --> 00:08:07,870
3 maybe something else and then in the

00:08:06,250 --> 00:08:10,180
final phase of the handshake the client

00:08:07,870 --> 00:08:12,039
also sends back a little piece of data

00:08:10,180 --> 00:08:13,690
indicating which of those protocols it

00:08:12,039 --> 00:08:15,129
wants to pick and now the secure

00:08:13,690 --> 00:08:16,449
connection is open and as soon as it's

00:08:15,129 --> 00:08:18,699
open both endpoints have already agreed

00:08:16,449 --> 00:08:20,050
on which protocol to use and if it's

00:08:18,699 --> 00:08:21,460
speedy or something else they can

00:08:20,050 --> 00:08:22,419
immediately start spending that data and

00:08:21,460 --> 00:08:25,479
know that the other endpoint will

00:08:22,419 --> 00:08:26,860
understand them and if either endpoint

00:08:25,479 --> 00:08:28,089
sort of is older or doesn't understand

00:08:26,860 --> 00:08:30,039
NPN or something goes wrong it just

00:08:28,089 --> 00:08:32,820
falls back to HTTP 1.1 by default so

00:08:30,039 --> 00:08:34,570
this is very nicely backwards compatible

00:08:32,820 --> 00:08:36,490
now some of you might have already

00:08:34,570 --> 00:08:39,610
realized this means that speedy only

00:08:36,490 --> 00:08:41,740
works over SSL there's also some other

00:08:39,610 --> 00:08:44,410
deployment reasons for that and that is

00:08:41,740 --> 00:08:47,170
an unfortunate limitation but that's the

00:08:44,410 --> 00:08:50,410
current situation as I understand it as

00:08:47,170 --> 00:08:51,820
an aside with HTTP 2.0 there

00:08:50,410 --> 00:08:53,200
talking about some other possible

00:08:51,820 --> 00:08:55,600
upgrade mechanisms that could avoid that

00:08:53,200 --> 00:08:57,670
limitations that hopefully h-2b 2.0 will

00:08:55,600 --> 00:09:01,060
be able to work in places where you

00:08:57,670 --> 00:09:04,510
don't want to use SSL but for now speedy

00:09:01,060 --> 00:09:05,800
is SSL only so but NPN is this nice

00:09:04,510 --> 00:09:07,660
extension that means as long as you're

00:09:05,800 --> 00:09:09,700
doing this assess so an SSL handshake

00:09:07,660 --> 00:09:11,980
anyway you get to do this negotiation

00:09:09,700 --> 00:09:13,420
and get both endpoints on the same page

00:09:11,980 --> 00:09:18,310
without any extra round-trip so that's

00:09:13,420 --> 00:09:19,540
nice so how do we support this I should

00:09:18,310 --> 00:09:21,520
have gone over these earlier right okay

00:09:19,540 --> 00:09:22,690
so just again to give a quick overview

00:09:21,520 --> 00:09:24,340
look so you've got your client you've

00:09:22,690 --> 00:09:25,660
got your server client says hi the

00:09:24,340 --> 00:09:27,760
server says here's what I support and

00:09:25,660 --> 00:09:31,060
the client picks one that's sort of NPN

00:09:27,760 --> 00:09:32,590
in essence this is one thing I couldn't

00:09:31,060 --> 00:09:34,960
do purely in Mazda PD we needed some

00:09:32,590 --> 00:09:36,550
cooperation from modest a cell so open

00:09:34,960 --> 00:09:39,940
SSL supports NPN but we need some way to

00:09:36,550 --> 00:09:42,250
hook into that so what we went ahead and

00:09:39,940 --> 00:09:44,370
did is is added some new capability to

00:09:42,250 --> 00:09:47,710
want to sell essentially added two new

00:09:44,370 --> 00:09:49,960
hook functions you know sort of AP are

00:09:47,710 --> 00:09:52,240
optional hooks the first one basically

00:09:49,960 --> 00:09:54,520
goes out and asks modules please tell me

00:09:52,240 --> 00:09:56,560
what modules what protocols used to

00:09:54,520 --> 00:09:58,270
support that I should advertise to the

00:09:56,560 --> 00:09:59,890
client and then the second one reports

00:09:58,270 --> 00:10:01,900
back once the client it's chosen one and

00:09:59,890 --> 00:10:02,860
so mod speedy uses these hooks and of

00:10:01,900 --> 00:10:04,630
course other models could use these

00:10:02,860 --> 00:10:06,340
hooks too so let's kind of see what it

00:10:04,630 --> 00:10:07,630
looks like so we've got a client we've

00:10:06,340 --> 00:10:09,790
got an Apache server with several

00:10:07,630 --> 00:10:11,830
modules in it and the client says hi and

00:10:09,790 --> 00:10:13,270
then Madison cell fires off that first

00:10:11,830 --> 00:10:15,040
hook so it asks you know we got mob

00:10:13,270 --> 00:10:17,650
Speedy's some sort of hypothetical mod

00:10:15,040 --> 00:10:19,210
foo that supports the food protocol and

00:10:17,650 --> 00:10:21,280
it asks them you know what they support

00:10:19,210 --> 00:10:23,470
some on speedy says I support speeding -

00:10:21,280 --> 00:10:27,240
and speedy three mod foo supports foo

00:10:23,470 --> 00:10:29,440
1.1 and modest to sell with these with

00:10:27,240 --> 00:10:30,640
with this addition we'll pull this

00:10:29,440 --> 00:10:32,140
together something back to the client

00:10:30,640 --> 00:10:34,210
the client picks one say they pick

00:10:32,140 --> 00:10:38,980
speedy - and then that second hook fire

00:10:34,210 --> 00:10:41,560
so Monticello informs mod speedy Ahmad

00:10:38,980 --> 00:10:42,970
food that speedy - was selected and mod

00:10:41,560 --> 00:10:44,680
speedy says great I'll do my thing and

00:10:42,970 --> 00:10:48,310
mod foo says look that's not me I'll get

00:10:44,680 --> 00:10:49,510
out of the way so those changes tomorrow

00:10:48,310 --> 00:10:52,390
cell have been committed to trunk

00:10:49,510 --> 00:10:54,340
they're in there obviously unfortunately

00:10:52,390 --> 00:10:57,790
not everyone has a completely up-to-date

00:10:54,340 --> 00:11:00,190
trunk build of Apache so for the benefit

00:10:57,790 --> 00:11:01,540
of older installations if you install

00:11:00,190 --> 00:11:03,910
them on speedy today using the binary

00:11:01,540 --> 00:11:05,680
package it will install a

00:11:03,910 --> 00:11:08,890
updated modest itself for use that it

00:11:05,680 --> 00:11:10,780
has access to those hooks if for some

00:11:08,890 --> 00:11:12,160
reason you don't want that and you want

00:11:10,780 --> 00:11:13,510
to install it if you just don't install

00:11:12,160 --> 00:11:14,740
the mod speedy binary package it will

00:11:13,510 --> 00:11:16,000
put everything back for you and restore

00:11:14,740 --> 00:11:16,990
original amount of soul so it's nice and

00:11:16,000 --> 00:11:18,700
clean

00:11:16,990 --> 00:11:20,140
but that just makes it much easier to

00:11:18,700 --> 00:11:22,990
install mod speedy and make sure that

00:11:20,140 --> 00:11:24,610
you have access to those hooks

00:11:22,990 --> 00:11:27,070
so with those additions to montez's so

00:11:24,610 --> 00:11:30,460
we've got hooks into NPM so we can

00:11:27,070 --> 00:11:31,690
negotiate to use speedy and so the next

00:11:30,460 --> 00:11:35,860
thing we need to do is to actually read

00:11:31,690 --> 00:11:38,770
and write speedy frames to so do the

00:11:35,860 --> 00:11:40,330
speedy framing layer and deal with the

00:11:38,770 --> 00:11:45,220
speedy header compression right the

00:11:40,330 --> 00:11:46,540
compression across multiple requests so

00:11:45,220 --> 00:11:48,760
this one's actually easy right this is a

00:11:46,540 --> 00:11:51,100
perfect use case for HTTP filter chain

00:11:48,760 --> 00:11:53,680
right you know conceptually we just mod

00:11:51,100 --> 00:11:55,480
speedy just inserts filters to translate

00:11:53,680 --> 00:11:57,160
from speedy data to HTTP data on the

00:11:55,480 --> 00:12:01,510
input side and the reverse on the output

00:11:57,160 --> 00:12:03,160
side great and we we do this at the

00:12:01,510 --> 00:12:04,960
connection level we it's a connection

00:12:03,160 --> 00:12:06,220
filter rather than a request filter so

00:12:04,960 --> 00:12:07,900
that we could maintain this compression

00:12:06,220 --> 00:12:12,100
state across multiple requests on the

00:12:07,900 --> 00:12:13,390
same connection and all that means all

00:12:12,100 --> 00:12:15,820
our existing modules just see the

00:12:13,390 --> 00:12:19,860
decoded HTTP data and they work the same

00:12:15,820 --> 00:12:19,860
as before so this is great right easy

00:12:20,040 --> 00:12:24,280
we're actually about to see that that's

00:12:22,210 --> 00:12:25,360
not quite what mod speedy does because

00:12:24,280 --> 00:12:27,070
of complications of how it does

00:12:25,360 --> 00:12:31,420
multiplexing but that's the basic idea

00:12:27,070 --> 00:12:33,310
so next up is multiplexing and this is

00:12:31,420 --> 00:12:35,350
the hard one so when I first started

00:12:33,310 --> 00:12:37,780
doing mod speedy I was told that it

00:12:35,350 --> 00:12:40,570
could not be done there was no way to

00:12:37,780 --> 00:12:45,190
get speedy working in the Apache web

00:12:40,570 --> 00:12:48,640
server and this is why multiplexing so

00:12:45,190 --> 00:12:51,930
to see why this is hard I'm gonna go a

00:12:48,640 --> 00:12:54,130
little more into detail about how

00:12:51,930 --> 00:12:57,100
request and connection handling normally

00:12:54,130 --> 00:13:00,400
works in the Apache web server

00:12:57,100 --> 00:13:01,540
you know without mod speedy so let's

00:13:00,400 --> 00:13:01,900
kind of take a look at what how this

00:13:01,540 --> 00:13:04,330
works

00:13:01,900 --> 00:13:06,190
we have our NPM and it's sitting there

00:13:04,330 --> 00:13:08,860
with its server socket listening for

00:13:06,190 --> 00:13:09,910
incoming connections okay so connections

00:13:08,860 --> 00:13:12,290
come in we've got a bunch of client

00:13:09,910 --> 00:13:14,480
sockets bound to those remote

00:13:12,290 --> 00:13:15,950
and each one of those gets a connection

00:13:14,480 --> 00:13:17,300
object right a structure representing

00:13:15,950 --> 00:13:19,459
the TCP connection and it gets filled in

00:13:17,300 --> 00:13:21,410
with all that data and the NPM assigns

00:13:19,459 --> 00:13:24,649
each one of these to a separate thread

00:13:21,410 --> 00:13:27,440
or process depending on the NPM right so

00:13:24,649 --> 00:13:29,000
each one of these connection objects and

00:13:27,440 --> 00:13:30,529
its associated socket has a dedicated

00:13:29,000 --> 00:13:31,700
thread or process that is responsible

00:13:30,529 --> 00:13:32,720
for that connection and it will take

00:13:31,700 --> 00:13:34,640
care of that connection and when it's

00:13:32,720 --> 00:13:35,870
done with thread can terminate we don't

00:13:34,640 --> 00:13:38,899
or go back into the thread pool rather

00:13:35,870 --> 00:13:40,279
and you know pick up something else so

00:13:38,899 --> 00:13:41,510
let's look at just one of these at a

00:13:40,279 --> 00:13:42,890
time keep it in mind that there's other

00:13:41,510 --> 00:13:48,080
copies of this you know going on

00:13:42,890 --> 00:13:49,700
concurrently so the NPM now has a thread

00:13:48,080 --> 00:13:50,839
or process assigned to this connection

00:13:49,700 --> 00:13:52,910
we've got the connection object

00:13:50,839 --> 00:13:55,910
associated socket and then the NPM will

00:13:52,910 --> 00:13:57,770
run the AP process connection function

00:13:55,910 --> 00:14:01,730
so the first thing this function does is

00:13:57,770 --> 00:14:06,350
it calls the pre connection hook so the

00:14:01,730 --> 00:14:08,390
core module in httpd will insert the

00:14:06,350 --> 00:14:10,060
network level filters into the filter

00:14:08,390 --> 00:14:12,260
chain that will talk to the socket

00:14:10,060 --> 00:14:15,230
Modest to sell assuming you've got that

00:14:12,260 --> 00:14:17,899
and assuming that this is you know over

00:14:15,230 --> 00:14:20,630
an ssl port we'll use the pre connection

00:14:17,899 --> 00:14:21,920
hook to install its connection level SSL

00:14:20,630 --> 00:14:25,610
filters that will do decryption and

00:14:21,920 --> 00:14:27,529
encryption on the output side and once

00:14:25,610 --> 00:14:29,270
all the pre connection hooks are done ap

00:14:27,529 --> 00:14:31,520
process connection will call the

00:14:29,270 --> 00:14:33,620
connection handler hook and that will go

00:14:31,520 --> 00:14:36,440
out asking looking for a module that

00:14:33,620 --> 00:14:37,760
will take over this connection and take

00:14:36,440 --> 00:14:39,110
responsibility for doing all the

00:14:37,760 --> 00:14:41,300
processing on this connection until it's

00:14:39,110 --> 00:14:42,950
done in most cases obviously that's

00:14:41,300 --> 00:14:46,459
going to be the HTTP connection handler

00:14:42,950 --> 00:14:47,779
that's built into Apache so that

00:14:46,459 --> 00:14:50,390
connection Handler now takes over

00:14:47,779 --> 00:14:54,380
control of the thread it starts pulling

00:14:50,390 --> 00:14:56,180
data through the connection filter chain

00:14:54,380 --> 00:14:59,480
through modest SL and through the

00:14:56,180 --> 00:15:02,000
network and it parses out the first HTTP

00:14:59,480 --> 00:15:03,589
request that comes over the wire okay so

00:15:02,000 --> 00:15:04,820
now we've got this request object now

00:15:03,589 --> 00:15:06,680
the connection handler calls a bunch

00:15:04,820 --> 00:15:08,360
more hooks other modules get a chance to

00:15:06,680 --> 00:15:10,070
put in their request filters they get a

00:15:08,360 --> 00:15:11,959
chance to select an appropriate request

00:15:10,070 --> 00:15:13,130
handler for this particular request now

00:15:11,959 --> 00:15:14,570
the request Handler takes over the

00:15:13,130 --> 00:15:16,370
thread it starts pulling data through

00:15:14,570 --> 00:15:17,810
this long filter chain processes the

00:15:16,370 --> 00:15:18,950
request produces a response the response

00:15:17,810 --> 00:15:20,660
goes back through the filter chain back

00:15:18,950 --> 00:15:23,089
out to the network and once the request

00:15:20,660 --> 00:15:23,900
is done control then gets yielded back

00:15:23,089 --> 00:15:25,580
to the connection hand

00:15:23,900 --> 00:15:27,830
and if we've got keepalive on which we

00:15:25,580 --> 00:15:29,240
probably should then we can maybe

00:15:27,830 --> 00:15:34,820
process a second request on the same

00:15:29,240 --> 00:15:37,820
connection everyone with me so far so

00:15:34,820 --> 00:15:41,900
this works great for HDPE it doesn't

00:15:37,820 --> 00:15:45,320
work so great for speedy and the reason

00:15:41,900 --> 00:15:47,210
is that all along this route we've been

00:15:45,320 --> 00:15:49,910
assuming that we've got one thread and

00:15:47,210 --> 00:15:53,690
one connection and one request at a time

00:15:49,910 --> 00:15:55,190
and that's true for HTTP but it's not

00:15:53,690 --> 00:15:57,860
true for speedy right with speedy we've

00:15:55,190 --> 00:15:59,240
got you know one TCP connection that's

00:15:57,860 --> 00:16:02,030
got lots of requests going on

00:15:59,240 --> 00:16:03,530
concurrently and if we want concurrency

00:16:02,030 --> 00:16:07,390
maybe we need to have those on separate

00:16:03,530 --> 00:16:09,710
threads so how could we possibly do that

00:16:07,390 --> 00:16:12,710
well let me make two observations about

00:16:09,710 --> 00:16:14,210
how Apache works the first observation

00:16:12,710 --> 00:16:15,440
is that once that request handler takes

00:16:14,210 --> 00:16:16,880
over right and remember that request

00:16:15,440 --> 00:16:18,410
handler might be in some third party

00:16:16,880 --> 00:16:20,120
module that you know isn't in core that

00:16:18,410 --> 00:16:21,680
we can't easily change once the request

00:16:20,120 --> 00:16:23,600
handler takes over it doesn't yield

00:16:21,680 --> 00:16:25,550
control back until the request is

00:16:23,600 --> 00:16:26,930
finished okay

00:16:25,550 --> 00:16:29,180
what that means is that if we're in the

00:16:26,930 --> 00:16:30,710
middle of that request there's no way to

00:16:29,180 --> 00:16:32,360
sort of stop what we're doing in the

00:16:30,710 --> 00:16:33,470
middle go do something else for a while

00:16:32,360 --> 00:16:35,000
on the same connection and then come

00:16:33,470 --> 00:16:36,800
back and finish that request right

00:16:35,000 --> 00:16:39,110
this request Handler has full control

00:16:36,800 --> 00:16:41,720
you know control the thread until it's

00:16:39,110 --> 00:16:43,540
done so there's sort of no way to lunge

00:16:41,720 --> 00:16:46,640
this into being event-driven in some way

00:16:43,540 --> 00:16:49,520
and sort of switching contexts between

00:16:46,640 --> 00:16:51,590
requests on a single thread just because

00:16:49,520 --> 00:16:53,230
of Apaches architecture that's fine

00:16:51,590 --> 00:16:55,270
so we may need to be multi-threaded

00:16:53,230 --> 00:16:57,860
observation number two though is that

00:16:55,270 --> 00:16:59,000
deeply baked into a passion is this idea

00:16:57,860 --> 00:17:01,700
that there's one thread per connection

00:16:59,000 --> 00:17:02,840
and there's one one association between

00:17:01,700 --> 00:17:04,400
these and so all those core data

00:17:02,840 --> 00:17:05,630
structures in particular the connection

00:17:04,400 --> 00:17:06,860
and data structure isn't thread safe

00:17:05,630 --> 00:17:08,839
right there's no locking why would there

00:17:06,860 --> 00:17:10,820
need to be because every connection

00:17:08,839 --> 00:17:13,310
object has a dedicated thread that's

00:17:10,820 --> 00:17:14,360
responsible for it so we can't be

00:17:13,310 --> 00:17:17,900
event-driven but we can't be

00:17:14,360 --> 00:17:20,060
multi-threaded either and as I said this

00:17:17,900 --> 00:17:25,339
is why I was told there was no way to

00:17:20,060 --> 00:17:29,310
make speedy work in Apache so how do we

00:17:25,339 --> 00:17:31,910
do this the answer is that we cheat

00:17:29,310 --> 00:17:34,230
this is what we're going to do instead

00:17:31,910 --> 00:17:37,920
so let me go back aways just a little

00:17:34,230 --> 00:17:38,820
bit earlier in the process we've you

00:17:37,920 --> 00:17:41,310
know we've received a bunch of

00:17:38,820 --> 00:17:42,660
connections we've ran the pre connection

00:17:41,310 --> 00:17:43,740
hook and inserted all these filters and

00:17:42,660 --> 00:17:45,480
now it's time to pick a connection

00:17:43,740 --> 00:17:48,360
handler the first thing that mod speedy

00:17:45,480 --> 00:17:51,840
does is it hooks into the connection

00:17:48,360 --> 00:17:54,000
handler hook it asks to be run before

00:17:51,840 --> 00:17:54,990
the HTTP connection handler so as a

00:17:54,000 --> 00:17:57,300
chance to see if this is a speedy

00:17:54,990 --> 00:17:59,040
connection so the speedy connection

00:17:57,300 --> 00:18:02,100
handler runs the first thing that it

00:17:59,040 --> 00:18:04,890
does is it performs a speculative read

00:18:02,100 --> 00:18:06,600
of one byte basically just to force the

00:18:04,890 --> 00:18:09,150
SSL handshake to happen make sure SSL is

00:18:06,600 --> 00:18:11,220
all initialized and that will force NPM

00:18:09,150 --> 00:18:13,950
to happen if it's going to happen so if

00:18:11,220 --> 00:18:15,240
it's not speedy is not selected then the

00:18:13,950 --> 00:18:16,680
speed connection handler will return to

00:18:15,240 --> 00:18:17,910
client to get out of the way in the HTTP

00:18:16,680 --> 00:18:20,010
connection handler can do its thing as

00:18:17,910 --> 00:18:21,630
normal if speedy is selected by the

00:18:20,010 --> 00:18:24,480
client then the speedy connection

00:18:21,630 --> 00:18:26,880
handler takes over and it starts pulling

00:18:24,480 --> 00:18:29,520
data off the network and reading and

00:18:26,880 --> 00:18:31,440
decoding the speedy frames so the client

00:18:29,520 --> 00:18:32,670
is going to send write so speedy has

00:18:31,440 --> 00:18:34,050
this framing layer where where

00:18:32,670 --> 00:18:35,760
everything's broken up into chunks

00:18:34,050 --> 00:18:37,110
legolas stream and so the client will

00:18:35,760 --> 00:18:38,610
send a bunch of frames indicating that

00:18:37,110 --> 00:18:41,580
it wants to make a bunch of simultaneous

00:18:38,610 --> 00:18:43,110
requests so we get those and the speed

00:18:41,580 --> 00:18:45,840
connection handler in mod speedy will

00:18:43,110 --> 00:18:47,430
create a structure a speedy stream

00:18:45,840 --> 00:18:48,390
object representing each of these

00:18:47,430 --> 00:18:50,700
streams that we need to handle

00:18:48,390 --> 00:18:52,380
concurrently so we already kind of ruled

00:18:50,700 --> 00:18:53,820
out any kind of event-driven schemes so

00:18:52,380 --> 00:18:56,670
we're gonna put each of these on its own

00:18:53,820 --> 00:18:58,110
thread and so mod speedy maintains its

00:18:56,670 --> 00:19:01,440
own thread pool basically mod speedy

00:18:58,110 --> 00:19:03,420
acts like a little NPM of its own so it

00:19:01,440 --> 00:19:05,790
puts each of these speedy streams on a

00:19:03,420 --> 00:19:07,410
dedicated thread that can run

00:19:05,790 --> 00:19:08,430
concurrently so again let's look at just

00:19:07,410 --> 00:19:10,050
one of these at a time but remember

00:19:08,430 --> 00:19:13,890
there's you know multiple of these

00:19:10,050 --> 00:19:17,580
running all concurrently in mod Speedy's

00:19:13,890 --> 00:19:18,810
thread pool so what are we gonna do with

00:19:17,580 --> 00:19:20,760
a speedy stream well we already

00:19:18,810 --> 00:19:22,500
determined that each what we really want

00:19:20,760 --> 00:19:24,210
to do is handle a request write a single

00:19:22,500 --> 00:19:25,380
request on the speed stream but we

00:19:24,210 --> 00:19:26,880
already determined that each request

00:19:25,380 --> 00:19:28,440
needs to have an Associated connection

00:19:26,880 --> 00:19:30,240
object that other third-party modules

00:19:28,440 --> 00:19:31,140
handling the request can look at so

00:19:30,240 --> 00:19:33,180
we're going to need to make a connection

00:19:31,140 --> 00:19:35,070
object so we make one obviously it

00:19:33,180 --> 00:19:37,270
doesn't represent a real TCP connection

00:19:35,070 --> 00:19:40,390
and the fact it doesn't have any sock

00:19:37,270 --> 00:19:42,309
we just created a structure fine as it

00:19:40,390 --> 00:19:43,450
turns out in order to keep the Apache

00:19:42,309 --> 00:19:45,340
core happy

00:19:43,450 --> 00:19:47,950
we can't just set the socket to null so

00:19:45,340 --> 00:19:49,150
we have to put something there so we

00:19:47,950 --> 00:19:50,620
actually just sort of make this fake

00:19:49,150 --> 00:19:55,990
socket that isn't bound to anything

00:19:50,620 --> 00:19:57,490
which is gross but it works so we've got

00:19:55,990 --> 00:19:59,559
this socket that isn't bound to any port

00:19:57,490 --> 00:20:00,640
and doesn't go anywhere and now we've

00:19:59,559 --> 00:20:01,840
got this connection object great what

00:20:00,640 --> 00:20:04,809
are we gonna do with it we're gonna call

00:20:01,840 --> 00:20:06,520
AP process connection but that's a core

00:20:04,809 --> 00:20:08,170
private function you tell me well this

00:20:06,520 --> 00:20:11,559
is C and if you can forward declare it

00:20:08,170 --> 00:20:14,320
you can call it so we do so we call it

00:20:11,559 --> 00:20:18,250
like we were the NPM and we that goes

00:20:14,320 --> 00:20:19,870
ahead and calls the reconnection hook so

00:20:18,250 --> 00:20:21,250
the pre connection hook fires Monticello

00:20:19,870 --> 00:20:22,960
wants to do its thing modest to sell

00:20:21,250 --> 00:20:25,420
hooks into the pre connection hook with

00:20:22,960 --> 00:20:26,980
priority a PR hook middle so it's gonna

00:20:25,420 --> 00:20:29,500
run fairly early on and try to insert

00:20:26,980 --> 00:20:30,940
its SSL filters we don't want it to do

00:20:29,500 --> 00:20:32,170
that because that's just gonna add extra

00:20:30,940 --> 00:20:33,850
complication right there's no reason to

00:20:32,170 --> 00:20:35,200
have encryption in this fake connection

00:20:33,850 --> 00:20:37,500
that's not going anywhere that's in the

00:20:35,200 --> 00:20:39,670
middle of our server

00:20:37,500 --> 00:20:42,610
fortunately for reasons I'm not entirely

00:20:39,670 --> 00:20:44,410
clear on Monticello provides an AP our

00:20:42,610 --> 00:20:46,720
optional function that allows you to

00:20:44,410 --> 00:20:48,340
explicitly disable it on a connection by

00:20:46,720 --> 00:20:51,100
connection basis maybe someone here

00:20:48,340 --> 00:20:53,590
knows why that's there so great that's

00:20:51,100 --> 00:20:55,390
good for us so mod speedy also has its

00:20:53,590 --> 00:20:57,550
own pre connection hook that hooks in

00:20:55,390 --> 00:20:59,679
explicitly just before Modest a cell and

00:20:57,550 --> 00:21:01,150
explicitly tells Modest cell please

00:20:59,679 --> 00:21:04,270
don't touch this connection just get out

00:21:01,150 --> 00:21:09,160
of the way so the pre connection of hook

00:21:04,270 --> 00:21:11,200
moves on and now the apache core module

00:21:09,160 --> 00:21:13,570
wants to install its network filters to

00:21:11,200 --> 00:21:14,950
talk to his this socket just like it

00:21:13,570 --> 00:21:16,420
normally would because it has no idea

00:21:14,950 --> 00:21:19,090
that this isn't a real connection off

00:21:16,420 --> 00:21:20,290
the network so it's gonna install its

00:21:19,090 --> 00:21:21,640
network filters well we definitely don't

00:21:20,290 --> 00:21:24,580
want it to do that and try to talk to

00:21:21,640 --> 00:21:27,970
the socket that doesn't go anywhere so

00:21:24,580 --> 00:21:29,679
what are we gonna do about that well the

00:21:27,970 --> 00:21:32,170
core modules pre connection hook runs

00:21:29,679 --> 00:21:34,330
with priority a PR Huck really lasts

00:21:32,170 --> 00:21:36,580
it's the very last thing that runs in

00:21:34,330 --> 00:21:38,350
the pre connection hook so mod speedy

00:21:36,580 --> 00:21:40,150
has another pre connection hook function

00:21:38,350 --> 00:21:41,800
that hooks in just before that one and

00:21:40,150 --> 00:21:44,770
that pre Connection hook function

00:21:41,800 --> 00:21:47,110
returns done so some of you may remember

00:21:44,770 --> 00:21:49,210
some although not all Apache hook

00:21:47,110 --> 00:21:51,670
functions allow you to return

00:21:49,210 --> 00:21:52,900
which basically means I took care of

00:21:51,670 --> 00:21:55,420
everything don't run anymore hook

00:21:52,900 --> 00:21:56,890
functions for this hook just stop this

00:21:55,420 --> 00:21:58,300
is obviously critical for something like

00:21:56,890 --> 00:22:00,270
a connection and handler or request

00:21:58,300 --> 00:22:02,230
Handler hook where the first handler

00:22:00,270 --> 00:22:03,490
function that is able to handle it

00:22:02,230 --> 00:22:04,600
should take care of everything and then

00:22:03,490 --> 00:22:05,260
none of the other handlers should do

00:22:04,600 --> 00:22:09,010
anything right

00:22:05,260 --> 00:22:10,660
I have no idea why this why the pre

00:22:09,010 --> 00:22:12,250
connection hook also allows you to do

00:22:10,660 --> 00:22:13,420
this again I'm sure there's some reason

00:22:12,250 --> 00:22:15,760
I don't know what it is maybe one of you

00:22:13,420 --> 00:22:18,790
does but I'm sure glad it's there so mod

00:22:15,760 --> 00:22:20,380
speedy returns done so the core module

00:22:18,790 --> 00:22:23,230
doesn't insert in the network filters I

00:22:20,380 --> 00:22:25,330
hope that goes okay for you so the pre

00:22:23,230 --> 00:22:27,640
connection hook is done AP processed

00:22:25,330 --> 00:22:30,460
connection then looks for a connection

00:22:27,640 --> 00:22:32,560
handler speedy politely steps out of the

00:22:30,460 --> 00:22:34,480
way and lets the HTTP connection handler

00:22:32,560 --> 00:22:35,830
take over so it's going to try reading

00:22:34,480 --> 00:22:38,620
from the filter chain and parsing an

00:22:35,830 --> 00:22:40,630
HTTP request as normal which would be

00:22:38,620 --> 00:22:46,900
fine if there were any filters to read

00:22:40,630 --> 00:22:49,120
from so how is it going to do that so in

00:22:46,900 --> 00:22:51,340
one of those earlier pre connection

00:22:49,120 --> 00:22:53,440
hooks mod Spee inserts some filters of

00:22:51,340 --> 00:22:54,820
its own at the network level where the

00:22:53,440 --> 00:22:56,350
network filters that talk to the socket

00:22:54,820 --> 00:22:58,210
would normally be but instead of talking

00:22:56,350 --> 00:22:59,920
to the socket they talk to the speedy

00:22:58,210 --> 00:23:02,290
stream object which is connected via a

00:22:59,920 --> 00:23:03,400
thread safe queue back to the master

00:23:02,290 --> 00:23:05,200
thread that's been up there all this

00:23:03,400 --> 00:23:07,060
time hey what's the master thread doing

00:23:05,200 --> 00:23:08,770
so while all these speedy stream threads

00:23:07,060 --> 00:23:11,170
are doing this this all this complicated

00:23:08,770 --> 00:23:12,610
hook shenanigans the master thread is

00:23:11,170 --> 00:23:14,770
continuing to sit there continuing to

00:23:12,610 --> 00:23:16,900
read data off the network and parsing

00:23:14,770 --> 00:23:18,100
speedy frames and each speedy frame is

00:23:16,900 --> 00:23:20,620
labeled with the stream that it's

00:23:18,100 --> 00:23:22,060
supposed to be on so it muxes those out

00:23:20,620 --> 00:23:23,290
and puts them on to the appropriate

00:23:22,060 --> 00:23:26,530
queues for each speedy stream object

00:23:23,290 --> 00:23:29,200
that's keeping track of and when the

00:23:26,530 --> 00:23:31,450
HTTP connection handler tries to pull

00:23:29,200 --> 00:23:34,230
data through the filter chain to parse

00:23:31,450 --> 00:23:36,940
an HTTP request

00:23:34,230 --> 00:23:38,620
so it asks the speedy two HTTP

00:23:36,940 --> 00:23:39,910
conversion filter hey give me some data

00:23:38,620 --> 00:23:41,710
the speedy date should be a conversion

00:23:39,910 --> 00:23:44,190
filter goes to the speedy stream pulls

00:23:41,710 --> 00:23:45,940
some speedy frames off of that queue

00:23:44,190 --> 00:23:49,210
transliterate s-- them to equivalent

00:23:45,940 --> 00:23:50,950
HTTP data and then dumps those into the

00:23:49,210 --> 00:23:52,660
bucket brigade the connection a handler

00:23:50,950 --> 00:23:55,890
grabs that happily reparse a--'s all

00:23:52,660 --> 00:23:55,890
that HTTP data into a

00:23:56,790 --> 00:24:01,720
HTTP request object and then proceeds as

00:23:59,920 --> 00:24:02,860
normally write fires all its hooks all

00:24:01,720 --> 00:24:04,270
the existing modules get

00:24:02,860 --> 00:24:06,010
to insert the request filters in their

00:24:04,270 --> 00:24:07,870
connection handler and it handles that

00:24:06,010 --> 00:24:09,370
HTTP request produces a response that

00:24:07,870 --> 00:24:13,570
goes back out through the filter chain

00:24:09,370 --> 00:24:15,580
the core HTTP request filter serializes

00:24:13,570 --> 00:24:18,549
all those headers and things into HTTP

00:24:15,580 --> 00:24:19,870
data which the HTTP to speedy conversion

00:24:18,549 --> 00:24:21,549
filter on the output side happily

00:24:19,870 --> 00:24:22,929
reparse a--'s converts into speedy

00:24:21,549 --> 00:24:24,100
frames puts back on the freight safe

00:24:22,929 --> 00:24:25,870
queue sends it back to the master

00:24:24,100 --> 00:24:27,040
connection all these frames from all

00:24:25,870 --> 00:24:28,450
these speedy streams go back to the

00:24:27,040 --> 00:24:30,250
master connection which then de muck

00:24:28,450 --> 00:24:32,380
system compresses them all with the

00:24:30,250 --> 00:24:33,820
shared compression contacts and puts

00:24:32,380 --> 00:24:36,850
them back out through SSL back onto the

00:24:33,820 --> 00:24:42,419
wire back to the client and that's how

00:24:36,850 --> 00:24:42,419
on speedy works any questions so far

00:24:42,450 --> 00:24:47,169
some of you might have realized some

00:24:44,620 --> 00:24:49,870
possible problems this will cause and if

00:24:47,169 --> 00:24:52,900
so wait for a few slides format when I

00:24:49,870 --> 00:24:55,780
will spell all those out so that's

00:24:52,900 --> 00:24:58,570
multiplexing and once we've got that

00:24:55,780 --> 00:25:02,110
actually server pushes really easy so

00:24:58,570 --> 00:25:04,000
back in this picture that speedy Daisy

00:25:02,110 --> 00:25:06,250
actually the HTTP to speedy conversion

00:25:04,000 --> 00:25:07,840
filter that's parsing this HTTP data and

00:25:06,250 --> 00:25:09,250
translator into speedy frames well it's

00:25:07,840 --> 00:25:12,220
doing that it's also looking at the

00:25:09,250 --> 00:25:15,640
headers that go by and it looks to see

00:25:12,220 --> 00:25:17,770
if the request Handler decided to set an

00:25:15,640 --> 00:25:19,510
X associated content response header

00:25:17,770 --> 00:25:24,220
with some URLs that it would like to

00:25:19,510 --> 00:25:26,200
push so if it sees that then for each

00:25:24,220 --> 00:25:27,850
one of those URL in a do our l's in

00:25:26,200 --> 00:25:29,410
addition to all the speedy frames it's

00:25:27,850 --> 00:25:31,600
transliterated in the HTTP into and

00:25:29,410 --> 00:25:34,450
sending it also sends a speedy syn

00:25:31,600 --> 00:25:36,220
stream server push frame with minimal

00:25:34,450 --> 00:25:37,809
headers out to the client it basically

00:25:36,220 --> 00:25:39,130
just tells the client hey I'm about to

00:25:37,809 --> 00:25:42,130
push you something on a new stream that

00:25:39,130 --> 00:25:43,570
I'm creating so the stream thread does

00:25:42,130 --> 00:25:45,520
that and then the stream fed thread

00:25:43,570 --> 00:25:47,169
signals the master connection thread

00:25:45,520 --> 00:25:48,700
that's maintaining this thread pool hey

00:25:47,169 --> 00:25:51,970
I need you to initiate a new server push

00:25:48,700 --> 00:25:54,400
stream so the master connection thread

00:25:51,970 --> 00:25:56,559
you know grabs a new thread out of the

00:25:54,400 --> 00:25:58,929
thread pool and creates a new speedy

00:25:56,559 --> 00:25:59,890
stream so how are we supposed to respond

00:25:58,929 --> 00:26:01,540
to a request that was never actually

00:25:59,890 --> 00:26:04,090
sent to us well we just make one up

00:26:01,540 --> 00:26:05,890
so we synthesize a new HTTP request and

00:26:04,090 --> 00:26:07,809
just pretend that the client sent to us

00:26:05,890 --> 00:26:09,220
even though they didn't really and you

00:26:07,809 --> 00:26:11,020
know it just does normal we we turned

00:26:09,220 --> 00:26:12,700
that into HTTP data we send that off to

00:26:11,020 --> 00:26:14,110
Apache Apache says great a new request

00:26:12,700 --> 00:26:16,130
off the network that the client totally

00:26:14,110 --> 00:26:17,900
just sent us I'll respond to it

00:26:16,130 --> 00:26:19,220
it does its thing we turn that back into

00:26:17,900 --> 00:26:21,050
speedy and we send that back to the

00:26:19,220 --> 00:26:22,490
client and the client which understands

00:26:21,050 --> 00:26:23,990
speedy says oh great a punch stream all

00:26:22,490 --> 00:26:26,990
stick that into my cache and I assume

00:26:23,990 --> 00:26:29,120
I'll need it later so those are the four

00:26:26,990 --> 00:26:31,430
things we said we needed and now we're

00:26:29,120 --> 00:26:32,870
done we have a speedy module and go

00:26:31,430 --> 00:26:36,140
ahead and install that and your Apache

00:26:32,870 --> 00:26:38,750
server will speak speedy so there are

00:26:36,140 --> 00:26:44,420
some benefits and some drawbacks to how

00:26:38,750 --> 00:26:46,010
mod speedy works and let me go over

00:26:44,420 --> 00:26:48,230
those so the big benefit is that it

00:26:46,010 --> 00:26:50,270
works right I was told this couldn't be

00:26:48,230 --> 00:26:52,310
done I think the people that told me

00:26:50,270 --> 00:26:56,140
that speedy couldn't work in Apache

00:26:52,310 --> 00:26:56,140
we're not giving Apache enough credit

00:26:57,220 --> 00:27:02,210
Apaches module system and hook system is

00:26:59,870 --> 00:27:03,920
remarkably flexible and the existing

00:27:02,210 --> 00:27:05,780
hooks that are already there had I had

00:27:03,920 --> 00:27:07,250
added these NPN hooks because n cans a

00:27:05,780 --> 00:27:10,010
new thing but other than that all the

00:27:07,250 --> 00:27:11,600
existing hooks into Apaches core served

00:27:10,010 --> 00:27:13,700
me extremely well it turned out this was

00:27:11,600 --> 00:27:16,160
all entirely possible to do is actually

00:27:13,700 --> 00:27:19,670
not all that much skullduggery

00:27:16,160 --> 00:27:22,790
so it all works that's pretty great the

00:27:19,670 --> 00:27:24,740
fact that we sort of do this weird fake

00:27:22,790 --> 00:27:28,160
connection thing is a little squirrely

00:27:24,740 --> 00:27:29,330
we could have done loopback fetches but

00:27:28,160 --> 00:27:31,790
basically I didn't want to do loopback

00:27:29,330 --> 00:27:33,350
fetches it ties up ports it has its own

00:27:31,790 --> 00:27:34,760
problems you know you might have to deal

00:27:33,350 --> 00:27:36,950
with weird access control things

00:27:34,760 --> 00:27:38,390
basically this doing this thing although

00:27:36,950 --> 00:27:41,570
it's a little more squirrelly guarantees

00:27:38,390 --> 00:27:43,070
that you are going to respond to this

00:27:41,570 --> 00:27:45,140
speedy stream in exactly the same way

00:27:43,070 --> 00:27:46,850
you would have if it were a normal HTTP

00:27:45,140 --> 00:27:48,230
request come in and that was really my

00:27:46,850 --> 00:27:51,470
goal right I wanted speedy to be a drop

00:27:48,230 --> 00:27:52,730
in module that you know supports speedy

00:27:51,470 --> 00:27:53,900
but otherwise everything is going to

00:27:52,730 --> 00:27:55,220
behave exactly the same you're going to

00:27:53,900 --> 00:27:55,850
get the exact same results you don't

00:27:55,220 --> 00:27:57,890
have to change your existing

00:27:55,850 --> 00:28:00,080
configuration and so this gets us that

00:27:57,890 --> 00:28:01,220
which is great so it works with all your

00:28:00,080 --> 00:28:02,270
existing modules you don't need to

00:28:01,220 --> 00:28:03,560
rewrite them none of them need to know

00:28:02,270 --> 00:28:05,740
anything about speedy you don't need to

00:28:03,560 --> 00:28:09,080
change your existing configuration

00:28:05,740 --> 00:28:13,340
mostly I'll get to that two slides from

00:28:09,080 --> 00:28:16,880
now so this all works pretty well there

00:28:13,340 --> 00:28:20,240
are some drawbacks and let me talk about

00:28:16,880 --> 00:28:21,560
those so first some what I think are

00:28:20,240 --> 00:28:23,780
relatively minor drawbacks it does

00:28:21,560 --> 00:28:25,130
require an update too modest to sell but

00:28:23,780 --> 00:28:27,830
other than that it works even with sort

00:28:25,130 --> 00:28:29,420
of older versions of Apache so so mod

00:28:27,830 --> 00:28:33,470
speed right now targets

00:28:29,420 --> 00:28:35,030
to point to one of these days real soon

00:28:33,470 --> 00:28:36,620
now I'm gonna get around to making

00:28:35,030 --> 00:28:38,210
available for two for hopefully that'll

00:28:36,620 --> 00:28:41,090
be in the next release but for now it's

00:28:38,210 --> 00:28:42,560
2-2 there is some of that overhead for

00:28:41,090 --> 00:28:44,930
sort of this double parsing you may be

00:28:42,560 --> 00:28:47,060
wondering sort of you know well you know

00:28:44,930 --> 00:28:48,530
when we're turning speedy into HTTP why

00:28:47,060 --> 00:28:50,480
don't we parse the speedy frames then

00:28:48,530 --> 00:28:52,670
just like directly create an HTTP

00:28:50,480 --> 00:28:54,440
request object instead of serializing

00:28:52,670 --> 00:28:56,300
the speedy out to http data and then

00:28:54,440 --> 00:28:57,440
letting the patch leary parse all that

00:28:56,300 --> 00:29:00,080
and then doing the same on the output

00:28:57,440 --> 00:29:01,520
side you know we probably could have

00:29:00,080 --> 00:29:02,750
done it a little more efficiently but

00:29:01,520 --> 00:29:04,490
again you know I wanted to make sure

00:29:02,750 --> 00:29:07,850
really really sure that we exactly

00:29:04,490 --> 00:29:09,440
replicated you know the semantics of the

00:29:07,850 --> 00:29:12,350
existing Apache core that we didn't try

00:29:09,440 --> 00:29:13,550
to reimplemented Apache does to deal

00:29:12,350 --> 00:29:15,410
with things like content length and all

00:29:13,550 --> 00:29:16,910
these weird HTTP headers and things it

00:29:15,410 --> 00:29:20,270
already does that very well but that

00:29:16,910 --> 00:29:21,560
behavior is sort of tied up in the core

00:29:20,270 --> 00:29:23,750
module that deals with parsing in

00:29:21,560 --> 00:29:25,430
serializing HTTP so we decided I decided

00:29:23,750 --> 00:29:28,160
to just you know sort of let it do that

00:29:25,430 --> 00:29:29,420
it's very good at it and mod speedy will

00:29:28,160 --> 00:29:30,980
just sit a layer outside of that and

00:29:29,420 --> 00:29:33,080
that you know sort of make sure it'll be

00:29:30,980 --> 00:29:36,230
stable even if it's not you know quite

00:29:33,080 --> 00:29:37,160
as efficient as it maybe could be well

00:29:36,230 --> 00:29:39,470
that's not too bad it's a string

00:29:37,160 --> 00:29:40,940
manipulation there is that slight breach

00:29:39,470 --> 00:29:42,410
of abstraction I mentioned earlier where

00:29:40,940 --> 00:29:45,290
we have to call a couple of core private

00:29:42,410 --> 00:29:49,940
functions yeah it's not so bad but it's

00:29:45,290 --> 00:29:51,530
not ideal and then of course mod speedy

00:29:49,940 --> 00:29:52,820
has maintaining this thread pool which

00:29:51,530 --> 00:29:57,200
means it's not going to play nice with

00:29:52,820 --> 00:29:59,150
modules that are not thread safe so even

00:29:57,200 --> 00:30:00,440
if you're using pre fork if you're using

00:29:59,150 --> 00:30:02,030
mod speedy you're an on thread safe

00:30:00,440 --> 00:30:05,020
modules are going to break when you try

00:30:02,030 --> 00:30:08,270
to use them with speedy which is too bad

00:30:05,020 --> 00:30:11,930
they're sort of I mean there's not much

00:30:08,270 --> 00:30:13,610
we can do about it and you know

00:30:11,930 --> 00:30:15,650
especially as mention was mentioned

00:30:13,610 --> 00:30:16,910
earlier today you know threaded npm is a

00:30:15,650 --> 00:30:20,570
particularly event npm is sort of

00:30:16,910 --> 00:30:21,650
becoming the default so and there's not

00:30:20,570 --> 00:30:22,940
that many modules that are not thread

00:30:21,650 --> 00:30:24,650
safe and the ones that are in fact not

00:30:22,940 --> 00:30:26,360
thread safe many of them can already be

00:30:24,650 --> 00:30:28,670
worked around you know if if you if

00:30:26,360 --> 00:30:30,650
you're already using a worker or event

00:30:28,670 --> 00:30:33,820
and all your modules work fine then

00:30:30,650 --> 00:30:33,820
they'll work fine with mod speedy

00:30:33,970 --> 00:30:38,360
there's some other drawbacks though that

00:30:36,260 --> 00:30:38,960
unfortunately I do not know right now

00:30:38,360 --> 00:30:40,159
anyway

00:30:38,960 --> 00:30:41,809
workaround and if any of you have

00:30:40,159 --> 00:30:45,260
brilliant ideas on this I would love to

00:30:41,809 --> 00:30:47,149
hear them so the first one is that this

00:30:45,260 --> 00:30:48,380
fake connection thing although it's you

00:30:47,149 --> 00:30:51,080
know it's clever at all it really

00:30:48,380 --> 00:30:52,730
confuses mob SSL and in particular

00:30:51,080 --> 00:30:54,710
because we explicitly told modest to

00:30:52,730 --> 00:30:56,809
sell no no don't touch this connection

00:30:54,710 --> 00:30:58,549
turn yourself off for this connection it

00:30:56,809 --> 00:31:00,350
says great that means that this

00:30:58,549 --> 00:31:02,419
connection is not being served over SSL

00:31:00,350 --> 00:31:04,549
which isn't really true right because

00:31:02,419 --> 00:31:06,380
that connection isn't a real connection

00:31:04,549 --> 00:31:08,750
to the network and all of that data for

00:31:06,380 --> 00:31:10,730
that connection is going back to the

00:31:08,750 --> 00:31:11,960
master connection which is over SSL and

00:31:10,730 --> 00:31:13,159
all that data is being encrypted before

00:31:11,960 --> 00:31:15,140
it's going onto the network

00:31:13,159 --> 00:31:16,820
LeMond SSL doesn't know that now

00:31:15,140 --> 00:31:18,740
normally that's fine

00:31:16,820 --> 00:31:20,440
but if you happen to be using a couple

00:31:18,740 --> 00:31:23,480
of the stricter modest a cell

00:31:20,440 --> 00:31:26,299
configuration directives in particular

00:31:23,480 --> 00:31:28,190
SSL require SSL which for those of you

00:31:26,299 --> 00:31:29,809
who don't know basically says don't ever

00:31:28,190 --> 00:31:31,669
ever serve this resource unless it's

00:31:29,809 --> 00:31:33,470
over SSL no matter well so I screw up in

00:31:31,669 --> 00:31:35,120
my configuration this should be secure

00:31:33,470 --> 00:31:36,890
only and so if you're using that

00:31:35,120 --> 00:31:39,500
directive or a similar directive and

00:31:36,890 --> 00:31:41,299
then you try to use mod speedy modest

00:31:39,500 --> 00:31:43,039
cell will say this isn't served over SSL

00:31:41,299 --> 00:31:45,770
even though it kind of really is and

00:31:43,039 --> 00:31:47,570
that'll break things I would love to fix

00:31:45,770 --> 00:31:50,510
this this issue has been open on our bug

00:31:47,570 --> 00:31:52,669
tracker since launch basically but I

00:31:50,510 --> 00:31:54,860
can't figure out any way to fix this

00:31:52,669 --> 00:31:57,169
without a being extremely happy and

00:31:54,860 --> 00:31:58,789
gross and be probably opening up some

00:31:57,169 --> 00:32:00,350
you know weird potential security hole

00:31:58,789 --> 00:32:03,740
somewhere which obviously I do not want

00:32:00,350 --> 00:32:05,659
to do so I kind of want to touch you

00:32:03,740 --> 00:32:07,039
know muck with modest a cell as little

00:32:05,659 --> 00:32:08,240
as possible I you know I don't want to

00:32:07,039 --> 00:32:11,510
compromise anything there so

00:32:08,240 --> 00:32:16,010
unfortunately this bug remains open for

00:32:11,510 --> 00:32:17,630
the time being obviously since we're you

00:32:16,010 --> 00:32:19,010
know every speedy stream is on its own

00:32:17,630 --> 00:32:22,010
thread that means we're using a bunch of

00:32:19,010 --> 00:32:24,140
extra threads you know and if you're if

00:32:22,010 --> 00:32:26,270
you're throttling your server you say oh

00:32:24,140 --> 00:32:27,289
I can I can handle ten requests at once

00:32:26,270 --> 00:32:30,049
so let's ita

00:32:27,289 --> 00:32:31,970
allow ten connections at once you know

00:32:30,049 --> 00:32:33,409
this will break that because now each

00:32:31,970 --> 00:32:34,820
connection can have a hundred requests

00:32:33,409 --> 00:32:38,120
on it and that could mean lots and lots

00:32:34,820 --> 00:32:39,380
of threads so that's too bad again sort

00:32:38,120 --> 00:32:40,789
of not much we can do about it and mod

00:32:39,380 --> 00:32:43,039
speedy does let you tune the size of its

00:32:40,789 --> 00:32:43,970
thread pool so you can you can tune that

00:32:43,039 --> 00:32:47,539
to make sure you don't over well

00:32:43,970 --> 00:32:48,470
anything to make that a little bit worse

00:32:47,539 --> 00:32:50,539
so that we're using all these threads

00:32:48,470 --> 00:32:51,549
remember that mod speedy serve has to be

00:32:50,539 --> 00:32:53,169
its own NPM

00:32:51,549 --> 00:32:54,970
it's own thread pool do all this stuff

00:32:53,169 --> 00:32:56,649
by itself and that's a bad thing right

00:32:54,970 --> 00:32:57,970
the whole point of the NPM is that we

00:32:56,649 --> 00:33:00,429
have a single part of the server that's

00:32:57,970 --> 00:33:01,989
responsible for multi processing and the

00:33:00,429 --> 00:33:03,220
fact that mod speeds are assessed to

00:33:01,989 --> 00:33:06,820
duplicate some of that effort is not

00:33:03,220 --> 00:33:09,669
good so that's definitely not ideal and

00:33:06,820 --> 00:33:11,169
to make that even worse because the NPM

00:33:09,669 --> 00:33:12,489
has no knowledge of these other threads

00:33:11,169 --> 00:33:14,230
that are running these other requests on

00:33:12,489 --> 00:33:16,989
these fake connections that means that

00:33:14,230 --> 00:33:18,850
the NPM scoreboard has no knowledge of

00:33:16,989 --> 00:33:21,580
the requests that are being served on

00:33:18,850 --> 00:33:22,690
speedy streams so if you're using the

00:33:21,580 --> 00:33:24,129
scoreboard for any kind of stats

00:33:22,690 --> 00:33:26,350
collection or monitoring that kind of

00:33:24,129 --> 00:33:27,669
mess that up and basically all the

00:33:26,350 --> 00:33:28,509
speedy streams will be invisible to you

00:33:27,669 --> 00:33:29,980
because they're off on this other

00:33:28,509 --> 00:33:34,600
phantom thread pool that mod speedy is

00:33:29,980 --> 00:33:36,489
managing so that is unfortunate so those

00:33:34,600 --> 00:33:41,289
are kind of the drawbacks I'm aware with

00:33:36,489 --> 00:33:43,840
speedy with mod speedy I should say but

00:33:41,289 --> 00:33:45,220
it mostly works and if those problems

00:33:43,840 --> 00:33:46,359
are not an issue for your site it may

00:33:45,220 --> 00:33:49,139
well be worth a look I you know I would

00:33:46,359 --> 00:33:49,139
encourage you to check it out

00:33:49,590 --> 00:33:52,899
so that's kind of it for Mont speedy if

00:33:51,609 --> 00:33:54,340
you have more specific questions about

00:33:52,899 --> 00:33:56,230
it in the question portion that'd be

00:33:54,340 --> 00:33:58,149
happy to answer any of your questions

00:33:56,230 --> 00:34:02,470
but I want to talk a little bit more now

00:33:58,149 --> 00:34:04,419
about HTTP 2.0 before I finish up so as

00:34:02,470 --> 00:34:07,119
I mentioned the ITF is working on a

00:34:04,419 --> 00:34:08,409
should be - right now they're working

00:34:07,119 --> 00:34:09,909
out the specification for that I don't

00:34:08,409 --> 00:34:12,520
really know what the timeline is but

00:34:09,909 --> 00:34:15,819
it's it's on its way and they're using

00:34:12,520 --> 00:34:16,809
speed as a starting point so HTTP 2.0 is

00:34:15,819 --> 00:34:18,579
gonna have all these speedy like

00:34:16,809 --> 00:34:21,099
features including as I understand it

00:34:18,579 --> 00:34:22,389
multiplexing and so all these terrible

00:34:21,099 --> 00:34:23,740
issues and these terrible things that

00:34:22,389 --> 00:34:25,720
mod speedy had to do to get this to work

00:34:23,740 --> 00:34:29,500
at all this is going to be an issue for

00:34:25,720 --> 00:34:31,599
HTTP 2.0 which I assume Apache is going

00:34:29,500 --> 00:34:34,299
to want to support natively you know

00:34:31,599 --> 00:34:36,099
once that is a standard so the question

00:34:34,299 --> 00:34:38,559
in my mind is and and you know I hope

00:34:36,099 --> 00:34:40,000
some sort of the Apache core devs are

00:34:38,559 --> 00:34:41,500
thinking about already and I'd like to

00:34:40,000 --> 00:34:45,250
encourage you all to think about this

00:34:41,500 --> 00:34:47,740
more is you know as HTTP you comes down

00:34:45,250 --> 00:34:49,750
the line how are we going to support

00:34:47,740 --> 00:34:52,720
that and how are we going to support it

00:34:49,750 --> 00:34:55,089
well you know without sort of these

00:34:52,720 --> 00:34:57,339
problems that that mod speedy sometimes

00:34:55,089 --> 00:34:59,500
has but without having to you know

00:34:57,339 --> 00:35:00,970
rewrite all of Apache from scratch which

00:34:59,500 --> 00:35:02,859
you know presumably we don't want to do

00:35:00,970 --> 00:35:04,540
or have to rewrite all our existing

00:35:02,859 --> 00:35:04,940
modules from scratch because we change

00:35:04,540 --> 00:35:06,109
all the

00:35:04,940 --> 00:35:08,599
assumptions about how requests and

00:35:06,109 --> 00:35:15,700
connections relate to each other you

00:35:08,599 --> 00:35:19,069
know how can we do this so I don't know

00:35:15,700 --> 00:35:20,480
I have some ideas I don't know if

00:35:19,069 --> 00:35:22,730
they're good ideas I have not tried

00:35:20,480 --> 00:35:24,800
these I don't know if they will work and

00:35:22,730 --> 00:35:26,119
probably most of you if not all of you

00:35:24,800 --> 00:35:28,760
know a whole lot more about patchi's

00:35:26,119 --> 00:35:30,650
internals than I do but I'd like to

00:35:28,760 --> 00:35:32,750
humbly submit a couple of ideas here at

00:35:30,650 --> 00:35:34,010
least to get people thinking and you

00:35:32,750 --> 00:35:36,050
know maybe some of you will have some

00:35:34,010 --> 00:35:38,119
better ideas than this so in my mind

00:35:36,050 --> 00:35:40,280
there's sort of two issues here with

00:35:38,119 --> 00:35:41,569
this multiplexing thing you know that we

00:35:40,280 --> 00:35:43,040
just went over all the squirrely stuff

00:35:41,569 --> 00:35:44,480
we have to do make it work there's sort

00:35:43,040 --> 00:35:47,660
of two reasons why this is such a pain

00:35:44,480 --> 00:35:49,910
the first problem is that for a

00:35:47,660 --> 00:35:53,140
multiplex protocol like speedy or HTTP

00:35:49,910 --> 00:35:56,030
two we need a way to have multiple

00:35:53,140 --> 00:35:58,130
concurrent requests whereby concurrent

00:35:56,030 --> 00:35:59,089
in this case I mean on multiple threads

00:35:58,130 --> 00:36:00,589
right because that's just the way a

00:35:59,089 --> 00:36:02,480
Pachi works so we're gonna have multiple

00:36:00,589 --> 00:36:03,770
requests simultaneously on multiple

00:36:02,480 --> 00:36:05,869
threads but they all need to be

00:36:03,770 --> 00:36:08,450
associated with the same TCP connection

00:36:05,869 --> 00:36:10,099
and the problem is right that all the

00:36:08,450 --> 00:36:11,690
existing modules are assuming that every

00:36:10,099 --> 00:36:14,150
request has its own dedicated connection

00:36:11,690 --> 00:36:16,880
that only that thread touches so how can

00:36:14,150 --> 00:36:18,260
we deal with this so one idea that's

00:36:16,880 --> 00:36:19,520
maybe a little bit out there is we

00:36:18,260 --> 00:36:21,500
already have this concept of sub

00:36:19,520 --> 00:36:23,480
requests what if we had this concept of

00:36:21,500 --> 00:36:25,220
sub connections right this is basically

00:36:23,480 --> 00:36:28,089
what mod speedy is doing already except

00:36:25,220 --> 00:36:30,410
it sort of legitimizes it so my

00:36:28,089 --> 00:36:31,490
hypothesis here right is we'd have a sub

00:36:30,410 --> 00:36:33,890
connection object which is just a

00:36:31,490 --> 00:36:35,480
connection struct like any other but it

00:36:33,890 --> 00:36:36,680
would you know have a couple extra you

00:36:35,480 --> 00:36:38,480
know the connection struct would grow a

00:36:36,680 --> 00:36:39,980
couple extra fields right so a sub

00:36:38,480 --> 00:36:41,690
connection to have an associated parent

00:36:39,980 --> 00:36:43,670
connection representing sort of the real

00:36:41,690 --> 00:36:45,890
TCP connection but it wouldn't have a

00:36:43,670 --> 00:36:47,119
socket right and so the core would have

00:36:45,890 --> 00:36:48,500
to be made a little where if that so

00:36:47,119 --> 00:36:49,730
that it knows the socket might not be

00:36:48,500 --> 00:36:52,339
there if it's one of these sort of fake

00:36:49,730 --> 00:36:53,599
sub connections and then instead of a

00:36:52,339 --> 00:36:54,470
socket the sub connection would sort of

00:36:53,599 --> 00:36:56,630
have a you know a thread-safe

00:36:54,470 --> 00:36:57,950
bucket-brigade or something similar to

00:36:56,630 --> 00:36:59,390
communicate back to the master threat

00:36:57,950 --> 00:37:02,420
you know again sort of similar to what

00:36:59,390 --> 00:37:06,140
mod speedy is doing already the

00:37:02,420 --> 00:37:07,490
difference is what this fixes is each

00:37:06,140 --> 00:37:09,230
request still gets to have a dedicated

00:37:07,490 --> 00:37:10,190
connection object right so most models

00:37:09,230 --> 00:37:11,300
don't even need to know there's anything

00:37:10,190 --> 00:37:12,020
different going on they don't need to

00:37:11,300 --> 00:37:13,609
change

00:37:12,020 --> 00:37:14,660
it's just that in some cases it might be

00:37:13,609 --> 00:37:17,660
sort of one of these fake sub

00:37:14,660 --> 00:37:19,700
connections but by sort of you know

00:37:17,660 --> 00:37:21,079
making this part of the API this gives

00:37:19,700 --> 00:37:22,849
us a legitimate way to associate

00:37:21,079 --> 00:37:25,490
multiple concurrent requests as one TCP

00:37:22,849 --> 00:37:26,509
connection and the few places that would

00:37:25,490 --> 00:37:27,829
have to change they're mostly going to

00:37:26,509 --> 00:37:29,089
be in the core right so the core needs

00:37:27,829 --> 00:37:31,430
to be where some connections won't have

00:37:29,089 --> 00:37:33,319
sockets but instead have a pointer up to

00:37:31,430 --> 00:37:35,089
this parrot connection that's owned by a

00:37:33,319 --> 00:37:37,250
number thread and maybe at some locking

00:37:35,089 --> 00:37:38,750
needs to be there and then mod SSL needs

00:37:37,250 --> 00:37:40,039
to understand you know Oh a sub

00:37:38,750 --> 00:37:42,289
connection that doesn't really connect

00:37:40,039 --> 00:37:43,490
to the network you know if its parent

00:37:42,289 --> 00:37:44,809
connection is secure then the sub

00:37:43,490 --> 00:37:46,789
connection should be treated as secure

00:37:44,809 --> 00:37:48,049
and the request that's associated you

00:37:46,789 --> 00:37:50,059
know the unique request on that sub

00:37:48,049 --> 00:37:51,799
connection should be treated as secure

00:37:50,059 --> 00:37:53,869
so that's sort of one idea for

00:37:51,799 --> 00:37:55,400
associating multiple requests so the

00:37:53,869 --> 00:37:56,509
connection basically sort of doing what

00:37:55,400 --> 00:37:58,430
mod speedy is already doing but in a

00:37:56,509 --> 00:38:01,910
much you know cleaner way that the core

00:37:58,430 --> 00:38:03,859
understands and the second issue is this

00:38:01,910 --> 00:38:05,990
cooperation with the NPM right where mod

00:38:03,859 --> 00:38:07,339
speedy has to sort of be its own NPM

00:38:05,990 --> 00:38:08,990
which is kind of gross and gets much

00:38:07,339 --> 00:38:10,730
worse if there are other modules to

00:38:08,990 --> 00:38:12,109
support other multiplex protocols in the

00:38:10,730 --> 00:38:14,900
future we don't want every simple one of

00:38:12,109 --> 00:38:17,019
those duplicating this effort so you

00:38:14,900 --> 00:38:19,279
know once we have the sort of idea of

00:38:17,019 --> 00:38:20,599
additional requests on the same TCP

00:38:19,279 --> 00:38:22,460
connection we need some way to run them

00:38:20,599 --> 00:38:24,980
concurrently that the NPM understands

00:38:22,460 --> 00:38:26,150
and is aware of the problem is that NPMs

00:38:24,980 --> 00:38:27,349
don't provide any way to do that right

00:38:26,150 --> 00:38:28,339
they have complete control for the

00:38:27,349 --> 00:38:30,680
thread pool there's no way for some

00:38:28,339 --> 00:38:32,059
other module as far as I know to come in

00:38:30,680 --> 00:38:36,619
and say hey NPM I want one of your

00:38:32,059 --> 00:38:38,420
threads Guinea so solution provide that

00:38:36,619 --> 00:38:40,099
functionality give the NPM some kind of

00:38:38,420 --> 00:38:42,890
optional hook that would allow other

00:38:40,099 --> 00:38:45,710
modules to do this in particular the

00:38:42,890 --> 00:38:47,390
idea here is the is the other module

00:38:45,710 --> 00:38:49,490
would go to the NPM and say here's a sub

00:38:47,390 --> 00:38:50,900
connection please run this as though

00:38:49,490 --> 00:38:52,220
it's a real connection on one of your

00:38:50,900 --> 00:38:55,700
threads and do all the things you

00:38:52,220 --> 00:38:57,559
normally do so this is something that

00:38:55,700 --> 00:38:59,269
threaded NPM s could do I think without

00:38:57,559 --> 00:39:00,890
too much difficulty obviously pre fork

00:38:59,269 --> 00:39:02,720
might not be able to do it I mean I'm

00:39:00,890 --> 00:39:04,339
you know unless we're using like IPC to

00:39:02,720 --> 00:39:08,660
communicate between connections and sub

00:39:04,339 --> 00:39:10,490
connections too bad for pre Fork you

00:39:08,660 --> 00:39:11,839
know again that might be okay especially

00:39:10,490 --> 00:39:15,500
as threaded NPM seem to becoming more

00:39:11,839 --> 00:39:17,089
common you know but I don't know I would

00:39:15,500 --> 00:39:19,759
appreciate your feedback on this if this

00:39:17,089 --> 00:39:21,289
is a terrible idea or not but if we sort

00:39:19,759 --> 00:39:23,210
of did that again that sort of solves

00:39:21,289 --> 00:39:24,500
has probably had where you know we're

00:39:23,210 --> 00:39:26,089
duplicating the effort now we're back to

00:39:24,500 --> 00:39:28,039
a point where the NPM is the only thing

00:39:26,089 --> 00:39:29,809
handling multiprocessing it manages all

00:39:28,039 --> 00:39:31,859
the threads its scoreboard knows about

00:39:29,809 --> 00:39:35,040
all the requests that are going

00:39:31,859 --> 00:39:39,329
but other modules still get a chance to

00:39:35,040 --> 00:39:41,609
thanks to run these connections run

00:39:39,329 --> 00:39:43,829
these other requests concurrently and

00:39:41,609 --> 00:39:45,720
you know new future protocols can

00:39:43,829 --> 00:39:47,640
protocol models can use this to write

00:39:45,720 --> 00:39:51,300
this doesn't just have to benefit you

00:39:47,640 --> 00:39:53,010
know mod speedy or even just h-2b - and

00:39:51,300 --> 00:39:56,609
and we don't have serve duplicate this

00:39:53,010 --> 00:39:58,440
this effort so if this particular idea

00:39:56,609 --> 00:40:00,119
or some other idea that accomplishes it

00:39:58,440 --> 00:40:02,490
this these kinds of things in a better

00:40:00,119 --> 00:40:04,050
way if we could make that work

00:40:02,490 --> 00:40:05,400
you know what benefits that does that

00:40:04,050 --> 00:40:08,309
guess well it may come on speedy a whole

00:40:05,400 --> 00:40:09,839
lot cleaner a whole lot simpler and of

00:40:08,309 --> 00:40:11,880
course it more much more importantly

00:40:09,839 --> 00:40:13,500
than that it would get give us the

00:40:11,880 --> 00:40:17,099
ability to support HTTP - in the future

00:40:13,500 --> 00:40:18,960
in the near future in a clean way but I

00:40:17,099 --> 00:40:20,730
think actually this this kind of thing

00:40:18,960 --> 00:40:22,619
allowing us to run sub requests

00:40:20,730 --> 00:40:24,270
concurrently basically and associate

00:40:22,619 --> 00:40:25,680
them with the same connection this could

00:40:24,270 --> 00:40:28,440
actually benefit other modules I think

00:40:25,680 --> 00:40:29,940
right so we've already got we already

00:40:28,440 --> 00:40:32,280
have a concept of sub requests but those

00:40:29,940 --> 00:40:33,599
run basically in blocking fashion right

00:40:32,280 --> 00:40:34,619
like everything stops while you handle

00:40:33,599 --> 00:40:36,809
the sub requester then you go back to

00:40:34,619 --> 00:40:38,430
what you were doing and we've got

00:40:36,809 --> 00:40:39,750
existing modules like modern modern

00:40:38,430 --> 00:40:42,390
clued that possibly have to make

00:40:39,750 --> 00:40:43,710
multiple sub requests and might get a

00:40:42,390 --> 00:40:46,109
whole lot faster if we could make those

00:40:43,710 --> 00:40:48,720
all in parallel at the same time and

00:40:46,109 --> 00:40:50,579
then resume once they all come back so

00:40:48,720 --> 00:40:51,809
mod during mod include use the sub

00:40:50,579 --> 00:40:53,369
request functionality that might get

00:40:51,809 --> 00:40:55,650
better if that could be concurrent mod

00:40:53,369 --> 00:40:57,450
pagespeed uses loopback requests and

00:40:55,650 --> 00:40:59,160
could benefit from this kind of thing in

00:40:57,450 --> 00:41:00,930
fact if you use mod pagespeed in mod

00:40:59,160 --> 00:41:02,819
speedy together they will hook into each

00:41:00,930 --> 00:41:05,160
other and mod page people use this

00:41:02,819 --> 00:41:06,480
mechanism so but it would be great if

00:41:05,160 --> 00:41:10,079
that methods were part of core and all

00:41:06,480 --> 00:41:11,280
these modules could use that so it would

00:41:10,079 --> 00:41:12,720
benefit a lot of existing models I think

00:41:11,280 --> 00:41:14,970
it would obviously be great for HTTP -

00:41:12,720 --> 00:41:16,440
and you know who knows you know I feel

00:41:14,970 --> 00:41:19,740
like anything that adds to the server

00:41:16,440 --> 00:41:21,420
new abilities you know new flexibilities

00:41:19,740 --> 00:41:23,130
just opens up more possibilities for

00:41:21,420 --> 00:41:24,900
models in the future you know it just

00:41:23,130 --> 00:41:26,250
makes the Apache web server more

00:41:24,900 --> 00:41:30,240
powerful and more flexible and I think

00:41:26,250 --> 00:41:32,369
that's a good thing so something to

00:41:30,240 --> 00:41:34,349
think about for the future as hw2 comes

00:41:32,369 --> 00:41:36,890
down the line but in the meantime we

00:41:34,349 --> 00:41:38,869
have mod speedy it works pretty well

00:41:36,890 --> 00:41:41,069
give it a try

00:41:38,869 --> 00:41:43,589
we've got binary packages up on

00:41:41,069 --> 00:41:44,440
developers.google.com slash speed check

00:41:43,589 --> 00:41:46,030
out the open source

00:41:44,440 --> 00:41:47,770
on Google Code and if you do give it a

00:41:46,030 --> 00:41:50,140
try I'd encourage you to join our

00:41:47,770 --> 00:41:52,480
mailing list mod speedy discuss at goo

00:41:50,140 --> 00:41:53,920
groups comm where we announce new

00:41:52,480 --> 00:41:57,010
releases and we can answer any questions

00:41:53,920 --> 00:41:58,540
you have that's it for my slides can I

00:41:57,010 --> 00:42:17,350
answer any questions about mod speedy or

00:41:58,540 --> 00:42:18,640
speedy or http/2 in general anyone did

00:42:17,350 --> 00:42:22,030
you want to come in for the mic I think

00:42:18,640 --> 00:42:24,130
I just clarification did you say that if

00:42:22,030 --> 00:42:27,010
you if your if your website is only

00:42:24,130 --> 00:42:28,440
running us in secure mode only that mod

00:42:27,010 --> 00:42:31,810
speedy is not compatible

00:42:28,440 --> 00:42:33,100
so so mod speedy I mean speedy in

00:42:31,810 --> 00:42:37,000
general not just mont speedy speedy

00:42:33,100 --> 00:42:39,070
requires today that you're using ssl so

00:42:37,000 --> 00:42:41,470
if your site is secure your set if you

00:42:39,070 --> 00:42:43,990
are not using SSL at all if you have no

00:42:41,470 --> 00:42:45,760
HTTPS portions of your site then there's

00:42:43,990 --> 00:42:50,790
no way to use speedy with any

00:42:45,760 --> 00:42:50,790
implementation that clarify yeah

00:42:53,190 --> 00:42:58,900
I've got a couple questions on the

00:42:55,390 --> 00:43:01,750
letter for the the server push you're

00:42:58,900 --> 00:43:05,350
talking about yes when it does when it

00:43:01,750 --> 00:43:09,490
sends out the the your eyes to push

00:43:05,350 --> 00:43:12,130
is there another round of access control

00:43:09,490 --> 00:43:15,310
checks on those before the content is

00:43:12,130 --> 00:43:22,420
sent or does it assume that it's okay

00:43:15,310 --> 00:43:23,800
yes so mod speedy you know right so when

00:43:22,420 --> 00:43:27,130
you tell him on speedy to push something

00:43:23,800 --> 00:43:29,290
mod speedy basically acts exactly as

00:43:27,130 --> 00:43:31,630
though the client had actually requested

00:43:29,290 --> 00:43:33,130
that thing so it just it just submits

00:43:31,630 --> 00:43:34,390
the request to Apache and that goes

00:43:33,130 --> 00:43:37,510
through all the normal access control

00:43:34,390 --> 00:43:38,920
checks okay so that should be okay it

00:43:37,510 --> 00:43:41,620
should be okay yeah the other thing it

00:43:38,920 --> 00:43:47,380
was have you looked at seeing if it work

00:43:41,620 --> 00:43:49,600
with with event NPM instead of so I

00:43:47,380 --> 00:43:51,520
actually confessed to not being very

00:43:49,600 --> 00:43:57,130
well-versed in the event NPM but my

00:43:51,520 --> 00:43:59,230
understanding is that the event NPM sort

00:43:57,130 --> 00:44:02,050
of doesn't work or rather you know

00:43:59,230 --> 00:44:05,650
doesn't you can't get the NPM event M

00:44:02,050 --> 00:44:08,500
PM's benefits if there are any clogging

00:44:05,650 --> 00:44:09,550
filters in the chain is I don't know

00:44:08,500 --> 00:44:11,020
someone else in the audience probably

00:44:09,550 --> 00:44:13,360
knows much better than I do if that is

00:44:11,020 --> 00:44:15,520
correct but modest to sell in particular

00:44:13,360 --> 00:44:18,040
is a clogging filter as I understand it

00:44:15,520 --> 00:44:20,950
so I don't sort of really know any way

00:44:18,040 --> 00:44:23,260
to get mod speedy to benefit from the

00:44:20,950 --> 00:44:24,760
event NPM but I don't have a very solid

00:44:23,260 --> 00:44:27,010
understanding of it and if anyone wants

00:44:24,760 --> 00:44:30,160
to come up to me afterwards and explain

00:44:27,010 --> 00:44:35,020
to me how to do it or what I should be

00:44:30,160 --> 00:44:36,400
looking into yeah yeah I'm I'm Roy

00:44:35,020 --> 00:44:39,970
fielding and we've talked about briefly

00:44:36,400 --> 00:44:41,320
an email but I mean most of this is

00:44:39,970 --> 00:44:43,210
understandable from the perspective of

00:44:41,320 --> 00:44:46,120
changing the minimum amount of Apache

00:44:43,210 --> 00:44:48,360
right to get it done what are your

00:44:46,120 --> 00:44:51,910
feelings about joining the group and

00:44:48,360 --> 00:44:54,880
actually working on an Apache 3 where we

00:44:51,910 --> 00:44:56,650
wouldn't have the restriction of not

00:44:54,880 --> 00:45:00,990
changing everything you know or you

00:44:56,650 --> 00:45:00,990
could change everything yeah

00:45:03,270 --> 00:45:07,660
that might be the right way to go I I

00:45:05,410 --> 00:45:12,369
think that's a decision for the you know

00:45:07,660 --> 00:45:15,070
for the core developers you know as much

00:45:12,369 --> 00:45:17,740
as I the idea appeals to me potentially

00:45:15,070 --> 00:45:19,869
of sort of becoming a major contributor

00:45:17,740 --> 00:45:23,380
to patchy realistically I don't have the

00:45:19,869 --> 00:45:28,480
time so I'm gonna have to remain on the

00:45:23,380 --> 00:45:31,200
sidelines I think and and leave it in

00:45:28,480 --> 00:45:31,200
their capable hands

00:45:39,900 --> 00:45:44,490
any other questions just one just one

00:45:43,079 --> 00:45:47,519
question sure

00:45:44,490 --> 00:45:50,130
how much thought had you given or does

00:45:47,519 --> 00:45:53,970
the not the specific implementation but

00:45:50,130 --> 00:45:58,289
speedy in general had you given to sir

00:45:53,970 --> 00:46:01,170
poll or event based network layer since

00:45:58,289 --> 00:46:04,319
it seems like speedy is simultaneously

00:46:01,170 --> 00:46:06,809
playing layer five layer six layer seven

00:46:04,319 --> 00:46:08,279
all at the same time yeah how you know

00:46:06,809 --> 00:46:10,829
how much have you given thought because

00:46:08,279 --> 00:46:12,390
one thing you pointed out is that we

00:46:10,829 --> 00:46:14,549
don't really need to clog up five

00:46:12,390 --> 00:46:17,099
threads doing five requests if we're

00:46:14,549 --> 00:46:23,160
still blocking on two of those with like

00:46:17,099 --> 00:46:24,480
no requests bodies Sentret yeah I mean I

00:46:23,160 --> 00:46:25,680
so mod speedy is the speedy

00:46:24,480 --> 00:46:29,430
implementation I'm most familiar with

00:46:25,680 --> 00:46:30,960
obviously I think that most other

00:46:29,430 --> 00:46:32,849
implementations out there are probably

00:46:30,960 --> 00:46:35,849
working in more in a more event-driven

00:46:32,849 --> 00:46:37,289
way I kind of feel like speedy lends

00:46:35,849 --> 00:46:40,519
itself much more naturally to that kind

00:46:37,289 --> 00:46:42,900
of approach unfortunately that's not how

00:46:40,519 --> 00:46:49,950
HD BD was built because it was built for

00:46:42,900 --> 00:46:52,470
HDPE so I kind of I don't really know

00:46:49,950 --> 00:46:54,509
what to do there I mean even mod speedy

00:46:52,470 --> 00:46:57,869
if you send it a hundred requests it

00:46:54,509 --> 00:46:59,519
won't necessarily immediately put them

00:46:57,869 --> 00:47:01,380
on a hundred threads right it will look

00:46:59,519 --> 00:47:03,119
at the priorities of the requests and it

00:47:01,380 --> 00:47:05,670
will if it's thread pool is you know

00:47:03,119 --> 00:47:07,230
only five threads or whatever you know

00:47:05,670 --> 00:47:09,089
it will service the five most important

00:47:07,230 --> 00:47:11,309
things first and as those finish up it

00:47:09,089 --> 00:47:12,989
will move on to the next the next few so

00:47:11,309 --> 00:47:16,410
it doesn't have to hire a tie-up huge

00:47:12,989 --> 00:47:17,759
number of threads and you know meanwhile

00:47:16,410 --> 00:47:19,170
those other streams are open and the

00:47:17,759 --> 00:47:20,339
client can send data to them but it just

00:47:19,170 --> 00:47:25,380
buffers them until it's ready to take

00:47:20,339 --> 00:47:29,009
care of them so you can manage how many

00:47:25,380 --> 00:47:30,329
threads you're using up but yeah I mean

00:47:29,009 --> 00:47:33,509
especially in situations where you get

00:47:30,329 --> 00:47:34,920
partway into into handling a stream and

00:47:33,509 --> 00:47:36,089
you want to do blocking i/o and move on

00:47:34,920 --> 00:47:37,589
to another stream you know this kind of

00:47:36,089 --> 00:47:39,569
massive parallelism is what you know

00:47:37,589 --> 00:47:41,839
event-driven architectures are really

00:47:39,569 --> 00:47:41,839
good at

00:47:46,200 --> 00:47:50,359
I have a question hunts on a server push

00:47:49,290 --> 00:47:54,000
yes

00:47:50,359 --> 00:47:58,470
so mod speedy will look at X associated

00:47:54,000 --> 00:48:00,140
content to determine what to push what's

00:47:58,470 --> 00:48:05,579
your thinking on who would write that

00:48:00,140 --> 00:48:06,570
that is a great question and that is

00:48:05,579 --> 00:48:09,990
kind of an open question

00:48:06,570 --> 00:48:11,670
even among sort of the speedy folks who

00:48:09,990 --> 00:48:13,980
are you know designing the protocol

00:48:11,670 --> 00:48:16,920
which I'm not actually one of but you

00:48:13,980 --> 00:48:18,089
know again I talk to them so server push

00:48:16,920 --> 00:48:19,410
is a really interesting feature and it

00:48:18,089 --> 00:48:22,170
has a lot of potential but it's still

00:48:19,410 --> 00:48:24,750
kind of an open question what should be

00:48:22,170 --> 00:48:26,400
pushed because even though server push

00:48:24,750 --> 00:48:28,140
saves round-trips right it does use it

00:48:26,400 --> 00:48:29,609
bandwidth that might not have been

00:48:28,140 --> 00:48:33,210
necessary if it turns out the thing is

00:48:29,609 --> 00:48:34,619
the resources in the clients cache and

00:48:33,210 --> 00:48:35,820
by the way if you start pushing

00:48:34,619 --> 00:48:36,900
something and the client says oh I've

00:48:35,820 --> 00:48:38,040
already got this in cache they can

00:48:36,900 --> 00:48:40,710
cancel the stream and the server can

00:48:38,040 --> 00:48:42,060
quit but it's doing but in the meantime

00:48:40,710 --> 00:48:43,140
you were still using up some bandwidth

00:48:42,060 --> 00:48:45,839
that maybe could have been used in a

00:48:43,140 --> 00:48:46,950
more efficient way so it's still very

00:48:45,839 --> 00:48:49,770
much an open question what the right

00:48:46,950 --> 00:48:50,970
strategy there is and because I don't

00:48:49,770 --> 00:48:52,440
even know what the right thing is you

00:48:50,970 --> 00:48:54,359
know the capability is there but it's

00:48:52,440 --> 00:48:55,560
kind of leaving it up to people to

00:48:54,359 --> 00:48:58,349
experiment with it and try to decide

00:48:55,560 --> 00:49:00,300
what the best thing is it would be great

00:48:58,349 --> 00:49:01,950
to have a module either mod speedy or

00:49:00,300 --> 00:49:03,450
another module that just sort of was

00:49:01,950 --> 00:49:04,589
smart and figured out what the right

00:49:03,450 --> 00:49:07,800
thing to push was and made those

00:49:04,589 --> 00:49:10,109
decisions but I don't know what the

00:49:07,800 --> 00:49:12,690
right algorithm for that is so so that

00:49:10,109 --> 00:49:14,220
doesn't exist yet in the meantime you

00:49:12,690 --> 00:49:16,770
can kind of do it manually like I mean

00:49:14,220 --> 00:49:18,119
if you're writing like PHP or CGI script

00:49:16,770 --> 00:49:20,190
or something that's generating response

00:49:18,119 --> 00:49:21,930
dynamically and you've done some testing

00:49:20,190 --> 00:49:23,579
and you're pretty sure for this page you

00:49:21,930 --> 00:49:26,430
know you should push such-and-such a

00:49:23,579 --> 00:49:27,900
resource you know the idea with the X

00:49:26,430 --> 00:49:29,280
Associated content header is hopefully

00:49:27,900 --> 00:49:31,650
it's pretty easy and you know again a

00:49:29,280 --> 00:49:32,849
PHP or CGI or whatever you're using to

00:49:31,650 --> 00:49:36,030
generate responses it's hopefully pretty

00:49:32,849 --> 00:49:37,560
easy to just set a little header but

00:49:36,030 --> 00:49:38,430
it's you know for now it's kind of the

00:49:37,560 --> 00:49:40,109
things you have to do on a very

00:49:38,430 --> 00:49:43,770
case-by-case basis and that's important

00:49:40,109 --> 00:49:45,119
it would be better to have a automatic

00:49:43,770 --> 00:49:47,660
solution that just knew what the right

00:49:45,119 --> 00:49:47,660
thing to do was

00:49:51,500 --> 00:49:55,200
yeah I had a question about the

00:49:53,550 --> 00:49:57,860
connection streams and how they honor

00:49:55,200 --> 00:50:04,680
keep alive it's a speedy honor all that

00:49:57,860 --> 00:50:07,290
yes so speedy in general the idea is

00:50:04,680 --> 00:50:08,400
sort of the connection should is with

00:50:07,290 --> 00:50:09,660
speedy and general not specific time on

00:50:08,400 --> 00:50:11,010
speedy the idea is sort of the

00:50:09,660 --> 00:50:13,410
connection should should actually stay

00:50:11,010 --> 00:50:16,380
open as long as both sides are willing

00:50:13,410 --> 00:50:17,280
as long as possible right and this is

00:50:16,380 --> 00:50:19,740
actually one of the nice things about

00:50:17,280 --> 00:50:21,150
speed ease the connection stays open and

00:50:19,740 --> 00:50:23,340
not only do you have a warm TCP

00:50:21,150 --> 00:50:25,440
connection but you have a warm speedy

00:50:23,340 --> 00:50:27,030
compression context so you load one page

00:50:25,440 --> 00:50:29,190
and it's if the server is willing to

00:50:27,030 --> 00:50:30,480
leave that connection open you know when

00:50:29,190 --> 00:50:32,070
the user navigates to the next page

00:50:30,480 --> 00:50:34,410
that's still open and warm and the

00:50:32,070 --> 00:50:36,500
connection context is primed and and

00:50:34,410 --> 00:50:38,430
things are very fast for the next page

00:50:36,500 --> 00:50:39,360
obviously that's sort of a burden on the

00:50:38,430 --> 00:50:41,490
server to leave all these connections

00:50:39,360 --> 00:50:43,200
open and so it's sort of up to the

00:50:41,490 --> 00:50:45,600
server implementation to decide you know

00:50:43,200 --> 00:50:50,670
what it's willing to do in terms of what

00:50:45,600 --> 00:50:52,050
mod speedy actually does I'm actually

00:50:50,670 --> 00:50:53,310
not hundred percent sure off the top of

00:50:52,050 --> 00:50:55,230
my head but I think it will pretty much

00:50:53,310 --> 00:50:57,260
leave the connection open as long as the

00:50:55,230 --> 00:51:00,750
client is still sending it stuff to it

00:50:57,260 --> 00:51:02,100
but if the you know if the page finishes

00:51:00,750 --> 00:51:03,630
loading and the user doesn't do any more

00:51:02,100 --> 00:51:05,160
navigation and the connection is kind of

00:51:03,630 --> 00:51:09,030
sitting idle with no speedy streams on

00:51:05,160 --> 00:51:10,500
it I I think that the normal timeout

00:51:09,030 --> 00:51:15,150
mechanism will will kick in and a

00:51:10,500 --> 00:51:15,930
connection will close I'm actually not a

00:51:15,150 --> 00:51:17,990
hundred percent sure I'll - thought

00:51:15,930 --> 00:51:19,830
might have to go back and look at that

00:51:17,990 --> 00:51:20,970
but it's basically like an HTTP

00:51:19,830 --> 00:51:22,290
connection as long as it's active it

00:51:20,970 --> 00:51:25,880
stays open and when the client stops

00:51:22,290 --> 00:51:25,880
using it for a while then you drop it

00:51:31,200 --> 00:51:35,720

YouTube URL: https://www.youtube.com/watch?v=lHp-8_ND2Qg


