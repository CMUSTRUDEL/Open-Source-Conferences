Title: The future of the CloudStack Virtual Router
Publication date: 2019-09-20
Playlist: ApacheCon North America 2019
Description: 
	This talk surveys and explores the scopes and design for the next-generation network model consolidation in CloudStack and a new super-fast micro-vm based VR. The talk will discuss the scope and goals for the next-generation VR, consolidation of basic and advanced networks and zones, flexible networking topologies, UI based network designing, a standard systemvm patching mechanism and uniform VR programming interface with a lightweight secured agent, faster rules programming and zero-downtime upgrades. It will also explore new abilities to allow live/online patching, containerization of VR processes and pluggability of user-imported data/router appliances (bring your own X) such as pfsense, vyos etc for VPN, FTP, DNS, DHCP, etc.
Captions: 
	00:00:04,910 --> 00:00:09,440
flexibility of topologies and other

00:00:07,100 --> 00:00:12,980
things like that so let me start the

00:00:09,440 --> 00:00:15,349
presentation a bit about me for those of

00:00:12,980 --> 00:00:17,360
us who were not the yesterday

00:00:15,349 --> 00:00:20,300
I'm with the other I'm from Gurgaon

00:00:17,360 --> 00:00:22,900
India I had a joke yesterday which I'll

00:00:20,300 --> 00:00:24,980
try to repeat again I am one of the

00:00:22,900 --> 00:00:28,489
oldest like ancient people in the

00:00:24,980 --> 00:00:31,460
community my number of years seven years

00:00:28,489 --> 00:00:33,680
in the so the joke was I'm at I'm a

00:00:31,460 --> 00:00:35,270
seven year old dinosaur in the community

00:00:33,680 --> 00:00:37,970
the only change since last seven years

00:00:35,270 --> 00:00:39,860
is dinosaur has grown bigger growing a

00:00:37,970 --> 00:00:44,630
moustache lost some hair so of there has

00:00:39,860 --> 00:00:47,840
grown great and I love cats and these

00:00:44,630 --> 00:00:50,780
are my two cats bit about me so what I

00:00:47,840 --> 00:00:52,760
want to do in this talk is just give a

00:00:50,780 --> 00:00:54,610
survey in review of the current

00:00:52,760 --> 00:00:58,070
implementation of the virtual Reuter

00:00:54,610 --> 00:01:00,770
maybe the the network subsystem within

00:00:58,070 --> 00:01:03,140
cloud stack and then talk about some

00:01:00,770 --> 00:01:05,449
work I had done over the last one one

00:01:03,140 --> 00:01:08,600
off is around reducing the downtime

00:01:05,449 --> 00:01:10,369
because my kind of interaction with

00:01:08,600 --> 00:01:13,310
virtual route is started with my work

00:01:10,369 --> 00:01:15,170
around system you develops then some

00:01:13,310 --> 00:01:17,270
project on reducing the downtime when

00:01:15,170 --> 00:01:19,490
you upgrade system which will do this

00:01:17,270 --> 00:01:22,609
let's say after upgrading cloud stack

00:01:19,490 --> 00:01:24,289
and now what I want to do with this talk

00:01:22,609 --> 00:01:25,909
is propose some ideas keep it

00:01:24,289 --> 00:01:28,579
interactive so if you have anything to

00:01:25,909 --> 00:01:31,969
share ask questions or discuss I mean

00:01:28,579 --> 00:01:33,889
let's do that and then maybe discuss

00:01:31,969 --> 00:01:35,719
some ideas around how can they address

00:01:33,889 --> 00:01:37,159
the technical that how can we refactor

00:01:35,719 --> 00:01:39,979
the code base some of the things maybe

00:01:37,159 --> 00:01:42,229
anuraag mentioned and look at some

00:01:39,979 --> 00:01:46,789
complex use cases and how those ideas

00:01:42,229 --> 00:01:50,060
can solve such complex use cases so the

00:01:46,789 --> 00:01:52,939
current virtual route is based on a

00:01:50,060 --> 00:01:55,969
system template so this is true for for

00:01:52,939 --> 00:02:00,319
11 to for 13 at least it's a David 9

00:01:55,969 --> 00:02:03,170
based operating system uses Linux 4.9 we

00:02:00,319 --> 00:02:06,979
have a fixed kind of root disk size of

00:02:03,170 --> 00:02:08,750
two gigs it uses Java Runtime a 1.8

00:02:06,979 --> 00:02:11,450
version so it's kind of pre-installed

00:02:08,750 --> 00:02:16,160
and it has tons of packages which are

00:02:11,450 --> 00:02:18,590
pre-installed and the way we program the

00:02:16,160 --> 00:02:20,450
system template we can program it you

00:02:18,590 --> 00:02:22,489
couple of methodologies we use a

00:02:20,450 --> 00:02:25,640
matching so initially patching is done

00:02:22,489 --> 00:02:27,620
by passing a string we call a command

00:02:25,640 --> 00:02:29,209
line through various ways or different

00:02:27,620 --> 00:02:31,760
hypervisors we use different ways to

00:02:29,209 --> 00:02:33,920
pass this kamar line and then we use a

00:02:31,760 --> 00:02:37,069
static system women or ISO file which

00:02:33,920 --> 00:02:38,750
may have some payload scripts jar files

00:02:37,069 --> 00:02:41,629
and things like that to pass that sister

00:02:38,750 --> 00:02:43,610
VM template in that depending on the

00:02:41,629 --> 00:02:46,489
command line and thus assumed I so these

00:02:43,610 --> 00:02:49,370
two payloads we can graduate or patch a

00:02:46,489 --> 00:02:51,769
system template to become either of ssv

00:02:49,370 --> 00:02:54,769
NCP VMs or different kinds of vias like

00:02:51,769 --> 00:02:57,890
your redundant we are your shade network

00:02:54,769 --> 00:03:00,220
we are or your isolated network use VB

00:02:57,890 --> 00:03:03,260
scene based we are in things like that

00:03:00,220 --> 00:03:06,650
couple of issues that I would personally

00:03:03,260 --> 00:03:10,510
point out is around upgrade around hea

00:03:06,650 --> 00:03:12,920
and redundancies and the the whole

00:03:10,510 --> 00:03:14,599
mechanism that we have right now that

00:03:12,920 --> 00:03:17,629
programs they which will do this kind of

00:03:14,599 --> 00:03:19,549
fragmented their different scripts there

00:03:17,629 --> 00:03:26,420
is no consistency it's hard to maintain

00:03:19,549 --> 00:03:28,959
the bug test in whatnot if you look at

00:03:26,420 --> 00:03:33,260
this diagram is basically tries to

00:03:28,959 --> 00:03:35,870
denote I mean display like how we do

00:03:33,260 --> 00:03:38,540
patch the system's so we start with the

00:03:35,870 --> 00:03:42,380
template which is a diamond based system

00:03:38,540 --> 00:03:45,230
in template basically a disk we have

00:03:42,380 --> 00:03:47,780
some script that starts every time the

00:03:45,230 --> 00:03:50,510
voice boots up this script will try and

00:03:47,780 --> 00:03:53,599
read this command-line file based on

00:03:50,510 --> 00:03:55,459
different hypervisors so the the script

00:03:53,599 --> 00:03:57,769
will try to detect whether it is on KVM

00:03:55,459 --> 00:04:00,440
ramirez in server based on that there

00:03:57,769 --> 00:04:03,769
are different mechanism for example in

00:04:00,440 --> 00:04:07,069
case of cave and we right now we pass

00:04:03,769 --> 00:04:09,440
the command line parameter using serial

00:04:07,069 --> 00:04:12,049
vert I oh device which is attached to

00:04:09,440 --> 00:04:15,109
the virtual machine and inside of the VR

00:04:12,049 --> 00:04:18,200
we have aka stage in which which we used

00:04:15,109 --> 00:04:20,180
to basically pass and in write this file

00:04:18,200 --> 00:04:23,750
to a static location and we basically

00:04:20,180 --> 00:04:26,840
hope that the cloud early config file

00:04:23,750 --> 00:04:30,050
which is sort of the cloud in it this

00:04:26,840 --> 00:04:32,240
kind of hackish script we have will try

00:04:30,050 --> 00:04:32,870
to read this command line it will detect

00:04:32,240 --> 00:04:35,930
a sister

00:04:32,870 --> 00:04:37,460
or ISO files mounted within the ISO file

00:04:35,930 --> 00:04:39,620
you can see there are some payload is a

00:04:37,460 --> 00:04:42,050
table all this sometimes is the SSH

00:04:39,620 --> 00:04:44,600
authorized key file so that management

00:04:42,050 --> 00:04:46,070
server can SSH to the VR directly or

00:04:44,600 --> 00:04:48,470
indirectly through the hypervisor host

00:04:46,070 --> 00:04:51,770
and we have an agent Gaad zip file which

00:04:48,470 --> 00:04:55,190
has a bunch of jars to run the SS VMRC

00:04:51,770 --> 00:04:59,150
premium agent then depending on the type

00:04:55,190 --> 00:05:02,270
of system template or system VM

00:04:59,150 --> 00:05:04,250
appliance we have created we have bunch

00:05:02,270 --> 00:05:07,460
of script which will basically create a

00:05:04,250 --> 00:05:10,310
VR or SSP or a CPM or something else

00:05:07,460 --> 00:05:12,440
once we have that ready then CloudStack

00:05:10,310 --> 00:05:14,750
will basically pole in check whether are

00:05:12,440 --> 00:05:17,210
we able to SSH into the view if we do

00:05:14,750 --> 00:05:20,120
that multiple times once we are able to

00:05:17,210 --> 00:05:24,050
SSH into that appliance then the further

00:05:20,120 --> 00:05:26,330
programming does continue so my journey

00:05:24,050 --> 00:05:29,240
can have started with this question can

00:05:26,330 --> 00:05:31,310
we reduce so one of the issues I was

00:05:29,240 --> 00:05:34,910
trying to personally at this is when you

00:05:31,310 --> 00:05:37,220
are upgrading version of cloud stack the

00:05:34,910 --> 00:05:39,260
main pain point for a lot of users were

00:05:37,220 --> 00:05:42,320
especially in case of large environments

00:05:39,260 --> 00:05:45,580
very of like 16,000 VRS it can take

00:05:42,320 --> 00:05:48,140
hours to actually upgrade and an

00:05:45,580 --> 00:05:50,000
incorrect upgrade or a faulty upgrade

00:05:48,140 --> 00:05:52,310
would mean downtime for the for the

00:05:50,000 --> 00:05:53,990
users of that network of whatever kind

00:05:52,310 --> 00:05:56,090
of network that is that means downtown

00:05:53,990 --> 00:05:58,370
of services in case of shade networks

00:05:56,090 --> 00:06:00,470
for example and complete downtime of

00:05:58,370 --> 00:06:03,110
networking in case of isolated network

00:06:00,470 --> 00:06:05,570
via networks and whatnot so the idea was

00:06:03,110 --> 00:06:09,200
can we make upgrades more reliable and

00:06:05,570 --> 00:06:12,800
also can we make them as low as possible

00:06:09,200 --> 00:06:16,580
so this is a slide from the previous

00:06:12,800 --> 00:06:18,470
talk what we did was something I mean if

00:06:16,580 --> 00:06:21,830
you ask me it's kind of silly and it's

00:06:18,470 --> 00:06:24,470
it's not very intelligent so the

00:06:21,830 --> 00:06:25,970
approach was very simple in the previous

00:06:24,470 --> 00:06:28,880
versions of cloud stack when you

00:06:25,970 --> 00:06:31,520
upgraded your routers what we did was

00:06:28,880 --> 00:06:34,400
after the upgrade path to change the

00:06:31,520 --> 00:06:37,130
system template to the new one we would

00:06:34,400 --> 00:06:39,590
simply destroy the old order and then

00:06:37,130 --> 00:06:42,350
create the new router wait for it to

00:06:39,590 --> 00:06:44,540
come up then program the issues with

00:06:42,350 --> 00:06:45,140
this approach is when you destroy the

00:06:44,540 --> 00:06:46,590
old router

00:06:45,140 --> 00:06:49,230
you're perfectly

00:06:46,590 --> 00:06:51,900
running router is gone and then when you

00:06:49,230 --> 00:06:53,760
try to start a new one there steps

00:06:51,900 --> 00:06:56,280
involved to provision that that means

00:06:53,760 --> 00:06:58,110
first you will copy the disk then you if

00:06:56,280 --> 00:07:00,510
that is successful then you will try and

00:06:58,110 --> 00:07:02,970
start that VM on a host if that is

00:07:00,510 --> 00:07:04,500
successful then you will try to hope

00:07:02,970 --> 00:07:06,570
that patching works and there are no

00:07:04,500 --> 00:07:08,430
bugs in that then you'll SSH and do a

00:07:06,570 --> 00:07:12,060
lot of these things if you look at

00:07:08,430 --> 00:07:15,600
VMware for example without this sort of

00:07:12,060 --> 00:07:17,850
zero downtime upgrade thing if you I

00:07:15,600 --> 00:07:19,830
mean a typical test environment it took

00:07:17,850 --> 00:07:21,150
like two minutes in a large-scale

00:07:19,830 --> 00:07:23,340
environment it would be even bigger

00:07:21,150 --> 00:07:26,310
biggest of noisy neighbors and other

00:07:23,340 --> 00:07:28,050
issues so the general idea we

00:07:26,310 --> 00:07:31,050
implemented was let's not destroy the

00:07:28,050 --> 00:07:33,720
old order instead let's first deploy a

00:07:31,050 --> 00:07:35,460
new router if there are any issues with

00:07:33,720 --> 00:07:38,220
deploying the new order you fail early

00:07:35,460 --> 00:07:38,670
and you get rid of that new one so your

00:07:38,220 --> 00:07:40,830
old

00:07:38,670 --> 00:07:43,590
VR is still running in your networking

00:07:40,830 --> 00:07:45,930
all the services are still running the

00:07:43,590 --> 00:07:47,490
other thing is which will route is us

00:07:45,930 --> 00:07:51,290
kind of stateless so if you have

00:07:47,490 --> 00:07:54,810
multiple of them connecting to the same

00:07:51,290 --> 00:07:57,300
you know guest network mixin you may

00:07:54,810 --> 00:08:00,540
have the fusion created for guest beams

00:07:57,300 --> 00:08:02,160
but packets will not be lost so the idea

00:08:00,540 --> 00:08:04,920
is very simple you deploy a new via

00:08:02,160 --> 00:08:07,380
program it if it works then you destroy

00:08:04,920 --> 00:08:09,390
the old one and you reprogram it by

00:08:07,380 --> 00:08:12,120
reprogramming what I mean is the new we

00:08:09,390 --> 00:08:14,730
are will simply do a broadcast so like

00:08:12,120 --> 00:08:17,250
all the entities in that network

00:08:14,730 --> 00:08:18,630
connected to the bridges whatnot they

00:08:17,250 --> 00:08:22,050
are aware that ok your router has

00:08:18,630 --> 00:08:24,510
changed and the issue is that app can

00:08:22,050 --> 00:08:27,030
have a caching issue which can typically

00:08:24,510 --> 00:08:30,720
be up to 30 seconds so if you look at

00:08:27,030 --> 00:08:32,640
the the second column of the table you

00:08:30,720 --> 00:08:34,800
see they are around 30 seconds so like

00:08:32,640 --> 00:08:36,870
30 second is the max downtime you can

00:08:34,800 --> 00:08:38,700
have the in idle case I actually

00:08:36,870 --> 00:08:40,770
observed in some times let's say if

00:08:38,700 --> 00:08:43,590
you're old and new we are on the same

00:08:40,770 --> 00:08:45,150
host when they are when the new VR is

00:08:43,590 --> 00:08:49,260
deployed it will be like plugged into

00:08:45,150 --> 00:08:51,000
this existing bridge so in such cases

00:08:49,260 --> 00:08:54,510
actually observed in some cases like

00:08:51,000 --> 00:08:58,050
there was zero seconds downtime so this

00:08:54,510 --> 00:09:00,450
is okay I mean it's a quick win and it's

00:08:58,050 --> 00:09:04,950
available in four level two for a fourth

00:09:00,450 --> 00:09:06,510
and whatnot but and this is the slide to

00:09:04,950 --> 00:09:10,980
kind of explain what I've explained you

00:09:06,510 --> 00:09:12,900
already but the thing but the question

00:09:10,980 --> 00:09:17,160
still is can we still make it zero

00:09:12,900 --> 00:09:21,120
because even with this this approach I

00:09:17,160 --> 00:09:23,670
mean it still fixes a lot of operational

00:09:21,120 --> 00:09:26,160
issues and in downtime is definitely

00:09:23,670 --> 00:09:28,470
reduced and you fail fast early so

00:09:26,160 --> 00:09:30,480
instead of destroying the old one you

00:09:28,470 --> 00:09:31,980
you first try and create a new one if

00:09:30,480 --> 00:09:34,020
there is a problem with that you catch

00:09:31,980 --> 00:09:37,740
the problem early and you can still have

00:09:34,020 --> 00:09:40,350
a more rican syllable or fixable problem

00:09:37,740 --> 00:09:43,470
at hand so the problem is still can we

00:09:40,350 --> 00:09:45,630
still make it zero so let's look at what

00:09:43,470 --> 00:09:48,480
happens during system 'i'm of bait so

00:09:45,630 --> 00:09:50,520
the first thing we do is prior to the

00:09:48,480 --> 00:09:52,950
upgrade so before even you're upgrading

00:09:50,520 --> 00:09:55,470
of lot stack if the first register a

00:09:52,950 --> 00:09:59,360
template with a specific name as per the

00:09:55,470 --> 00:10:02,370
release update documentation and then

00:09:59,360 --> 00:10:04,440
when you do upgrade what the grade pass

00:10:02,370 --> 00:10:06,990
will do which is a database class which

00:10:04,440 --> 00:10:09,060
will simply see whether a template by a

00:10:06,990 --> 00:10:11,790
given name is of labor or not if you

00:10:09,060 --> 00:10:14,280
change some things in the in the in the

00:10:11,790 --> 00:10:17,520
database simply enable that template to

00:10:14,280 --> 00:10:20,490
be of type system and during upgrade a

00:10:17,520 --> 00:10:23,010
new system dot system v m dot iso files

00:10:20,490 --> 00:10:25,560
will be created replacing the old one

00:10:23,010 --> 00:10:28,080
which will have sort of the new patching

00:10:25,560 --> 00:10:29,760
code and the rolling we start the thing

00:10:28,080 --> 00:10:31,650
that I described you create a new one

00:10:29,760 --> 00:10:33,600
program it destroy the old one so

00:10:31,650 --> 00:10:38,850
rolling we start will kind of replace

00:10:33,600 --> 00:10:40,220
the the old we are with the new one

00:10:38,850 --> 00:10:45,030
eventually

00:10:40,220 --> 00:10:47,040
so the problem still is that it's ins in

00:10:45,030 --> 00:10:50,130
case and admin for gates to register the

00:10:47,040 --> 00:10:52,320
template after of radio pretty much you

00:10:50,130 --> 00:10:56,460
have to roll back or you have to fix the

00:10:52,320 --> 00:10:59,010
template manually so those are like

00:10:56,460 --> 00:11:01,380
couple of issues around the upgrade now

00:10:59,010 --> 00:11:03,750
let me talk about when is the system

00:11:01,380 --> 00:11:06,780
template upgrade necessary so if we look

00:11:03,750 --> 00:11:07,860
at the recent releases like 411 to 411

00:11:06,780 --> 00:11:10,680
three and four thirteen

00:11:07,860 --> 00:11:12,390
so between 411 three and four thirty and

00:11:10,680 --> 00:11:14,400
there is no system in template change so

00:11:12,390 --> 00:11:16,680
if you are if we are already

00:11:14,400 --> 00:11:20,280
4:11 three and you upgrade to the latest

00:11:16,680 --> 00:11:22,290
4:13 which should be out after the

00:11:20,280 --> 00:11:23,220
documentation work in couple of days in

00:11:22,290 --> 00:11:25,530
weeks

00:11:23,220 --> 00:11:27,450
there's no need of a new system VM

00:11:25,530 --> 00:11:29,790
template why because there are no

00:11:27,450 --> 00:11:32,040
changes in the packages this is Simeon

00:11:29,790 --> 00:11:35,150
template basically has a bunch of

00:11:32,040 --> 00:11:38,520
scripts tools Java Runtime environment

00:11:35,150 --> 00:11:41,280
some packages like passive observer H a

00:11:38,520 --> 00:11:44,130
proxy IP rot tools and all of those

00:11:41,280 --> 00:11:45,330
things and they don't I mean we as a

00:11:44,130 --> 00:11:49,200
project when we move to a different

00:11:45,330 --> 00:11:51,540
version when such changes are not

00:11:49,200 --> 00:11:53,400
necessary there's no security issue that

00:11:51,540 --> 00:11:55,680
require new packages to be installed in

00:11:53,400 --> 00:11:58,140
the template in those cases the template

00:11:55,680 --> 00:12:00,270
is not necessary and the last thing is

00:11:58,140 --> 00:12:02,130
when any if there is a fundamental

00:12:00,270 --> 00:12:05,340
change in the patching process it says

00:12:02,130 --> 00:12:07,770
for example between in 411 we had to

00:12:05,340 --> 00:12:09,960
there were some issues around making the

00:12:07,770 --> 00:12:13,920
patching work on kaymu evie so we had to

00:12:09,960 --> 00:12:16,380
move from an earlier much barebone way

00:12:13,920 --> 00:12:18,270
of talking to the serial port and then

00:12:16,380 --> 00:12:21,540
we moved to Cayuga stage agent-based

00:12:18,270 --> 00:12:23,130
approach we had to have like install a

00:12:21,540 --> 00:12:25,620
new template because we wanted to use

00:12:23,130 --> 00:12:28,770
the came against agent so those are

00:12:25,620 --> 00:12:31,380
places like situations where as a

00:12:28,770 --> 00:12:35,580
statement template is necessary let me

00:12:31,380 --> 00:12:39,210
actually now talk about how we program

00:12:35,580 --> 00:12:41,820
virtual looters of like to try to give

00:12:39,210 --> 00:12:43,980
you an end-to-end perspective so as a

00:12:41,820 --> 00:12:46,740
developer I start with a feature or a

00:12:43,980 --> 00:12:48,600
bug or an improvement and I have to

00:12:46,740 --> 00:12:51,930
first create a system iam template so I

00:12:48,600 --> 00:12:54,690
need to build that new template get it

00:12:51,930 --> 00:12:56,880
tested get it reviewed we go through the

00:12:54,690 --> 00:12:59,520
voting in testing cycle once that is

00:12:56,880 --> 00:13:01,470
done it is being hosted on a community

00:12:59,520 --> 00:13:03,870
service a community hosted server like

00:13:01,470 --> 00:13:07,170
download start outside dog or something

00:13:03,870 --> 00:13:08,970
like that and then once those things are

00:13:07,170 --> 00:13:13,140
done as a user you would install the

00:13:08,970 --> 00:13:14,730
system template lots tag will talk to

00:13:13,140 --> 00:13:17,250
the we'll work with the hypervisor and

00:13:14,730 --> 00:13:18,840
try to set up the networking and in

00:13:17,250 --> 00:13:20,970
terms of programming if you see on the

00:13:18,840 --> 00:13:22,770
right hand side we are programming of

00:13:20,970 --> 00:13:24,630
what I've done is I've listed on various

00:13:22,770 --> 00:13:27,030
features which are now provided by the

00:13:24,630 --> 00:13:28,350
virtual rooted very basic things like

00:13:27,030 --> 00:13:30,690
DHCP and DNS

00:13:28,350 --> 00:13:33,090
musk and in brackets you can see name of

00:13:30,690 --> 00:13:35,790
the sort of providing services like what

00:13:33,090 --> 00:13:38,880
is the thing that tender drive start

00:13:35,790 --> 00:13:41,280
feature like DHCP and DNS are provided

00:13:38,880 --> 00:13:43,440
by the DNS mask service in the virtual

00:13:41,280 --> 00:13:45,990
Rooter I'll pick a random one like

00:13:43,440 --> 00:13:47,910
static routes firewalls and all of those

00:13:45,990 --> 00:13:51,020
things are implemented by IP route to

00:13:47,910 --> 00:13:54,030
tools and then we have some specific

00:13:51,020 --> 00:13:57,030
cloud stack specific features which are

00:13:54,030 --> 00:13:58,920
which are for just ongoing monitoring

00:13:57,030 --> 00:14:00,660
and whatnot like health monitoring in

00:13:58,920 --> 00:14:02,310
network statistics so those are

00:14:00,660 --> 00:14:06,090
different scripts that do i implement

00:14:02,310 --> 00:14:08,220
that specific feature now this is just

00:14:06,090 --> 00:14:11,610
like what is the feature and how that is

00:14:08,220 --> 00:14:14,790
implemented the more I think challenging

00:14:11,610 --> 00:14:17,310
thing is to explain how the current VR

00:14:14,790 --> 00:14:18,720
is being programmed I don't intend I

00:14:17,310 --> 00:14:20,310
don't want you to go and read this

00:14:18,720 --> 00:14:22,320
because the point of this slide is to

00:14:20,310 --> 00:14:25,620
simply explain and make the point that

00:14:22,320 --> 00:14:27,750
it is complex it is hard to extend it is

00:14:25,620 --> 00:14:29,370
hard for a new engineer to learn

00:14:27,750 --> 00:14:32,390
something and implement something very

00:14:29,370 --> 00:14:34,590
quick long story short what happens is

00:14:32,390 --> 00:14:35,790
there is no standard way of patching

00:14:34,590 --> 00:14:37,440
there is no standard way of

00:14:35,790 --> 00:14:40,170
communicating to the via from the

00:14:37,440 --> 00:14:42,420
management server in case of VMware you

00:14:40,170 --> 00:14:43,650
can talk directly in case of XenServer

00:14:42,420 --> 00:14:46,980
and KVM you have to go through the

00:14:43,650 --> 00:14:48,330
hypervisor host and for each and every

00:14:46,980 --> 00:14:50,850
feature there are different ways you

00:14:48,330 --> 00:14:53,000
have to SSH and execute a script with

00:14:50,850 --> 00:14:55,230
some custom parts so there is no

00:14:53,000 --> 00:14:57,420
standardization of interface there is no

00:14:55,230 --> 00:15:01,080
standardization of how do you build this

00:14:57,420 --> 00:15:04,740
maintain manage administrate upgrade now

00:15:01,080 --> 00:15:06,840
all of these things and then the code is

00:15:04,740 --> 00:15:09,030
kind of fragmented it's hard to actually

00:15:06,840 --> 00:15:11,520
read the code and make sense out of that

00:15:09,030 --> 00:15:14,040
you cannot attach a debugging point it's

00:15:11,520 --> 00:15:16,740
hard to go through the logs so there are

00:15:14,040 --> 00:15:19,800
tons of issues around this now what I

00:15:16,740 --> 00:15:21,630
want to focus on is we are still

00:15:19,800 --> 00:15:24,060
thinking about what causes downtime

00:15:21,630 --> 00:15:26,220
right so the question still remains can

00:15:24,060 --> 00:15:28,650
we make the downtime zero so let's first

00:15:26,220 --> 00:15:30,720
think about what are the core services

00:15:28,650 --> 00:15:33,210
in cloud stack what you rooted versus

00:15:30,720 --> 00:15:35,910
non core so what I mean by core is that

00:15:33,210 --> 00:15:37,530
if you kill those services like things

00:15:35,910 --> 00:15:40,050
like firewall that these are all

00:15:37,530 --> 00:15:41,939
provided by your Linux kernel if a

00:15:40,050 --> 00:15:44,279
kernel kind of crashes you need

00:15:41,939 --> 00:15:46,589
working connectivity everything kind of

00:15:44,279 --> 00:15:49,229
goes down but let's say if your password

00:15:46,589 --> 00:15:51,679
server doesn't work your metadata server

00:15:49,229 --> 00:15:57,059
doesn't work as a proxy could be in that

00:15:51,679 --> 00:15:59,309
gray area just like VPN so those non

00:15:57,059 --> 00:16:01,709
core services if they have a slight

00:15:59,309 --> 00:16:02,759
downtime of let's say up to few seconds

00:16:01,709 --> 00:16:05,779
to a minute

00:16:02,759 --> 00:16:08,970
it doesn't actually cause a huge issue

00:16:05,779 --> 00:16:10,679
if a kernel crash is this connectivity

00:16:08,970 --> 00:16:13,319
the services that are going to be down

00:16:10,679 --> 00:16:15,839
if dns must crashes then maybe the new

00:16:13,319 --> 00:16:17,789
VMs that are being started or existing

00:16:15,839 --> 00:16:20,519
ones which are requesting for like a

00:16:17,789 --> 00:16:22,439
renewal may be affected but it's not

00:16:20,519 --> 00:16:25,249
that critical so that's sort of the

00:16:22,439 --> 00:16:27,989
point of co versus non core services

00:16:25,249 --> 00:16:28,679
let's also quickly look into recovery

00:16:27,989 --> 00:16:30,419
Prime's

00:16:28,679 --> 00:16:32,519
like say if there is an issue or of

00:16:30,419 --> 00:16:34,379
order of failure how much time it

00:16:32,519 --> 00:16:36,599
typically takes to recover so when you

00:16:34,379 --> 00:16:39,089
have an operating system service they

00:16:36,599 --> 00:16:41,609
are typically fast enough so this is

00:16:39,089 --> 00:16:43,799
with respect to the virtual routed maybe

00:16:41,609 --> 00:16:45,929
Java processes could be slow because

00:16:43,799 --> 00:16:47,759
they take time to load but typically

00:16:45,929 --> 00:16:51,449
most of the services they are fast

00:16:47,759 --> 00:16:54,149
enough to kind of load or restart or or

00:16:51,449 --> 00:16:56,759
recover the operating system itself is

00:16:54,149 --> 00:17:00,449
if it crashes can take a few minutes if

00:16:56,759 --> 00:17:02,359
a virtual machine can crash the fail for

00:17:00,449 --> 00:17:05,189
some reason because of faulty storage or

00:17:02,359 --> 00:17:07,139
faulty hosts and things like that it can

00:17:05,189 --> 00:17:09,209
be tricky and it can take a couple of

00:17:07,139 --> 00:17:11,039
seconds - couple of minutes and if your

00:17:09,209 --> 00:17:13,019
host hasn't if you your entire

00:17:11,039 --> 00:17:15,569
infrastructure cluster is gone a zone is

00:17:13,019 --> 00:17:17,309
affected the data center specific

00:17:15,569 --> 00:17:19,860
network infrastructure is gone that can

00:17:17,309 --> 00:17:21,689
take minutes two hours and I don't know

00:17:19,860 --> 00:17:24,839
maybe even days depending on what that

00:17:21,689 --> 00:17:28,079
issue this so the point of all of this

00:17:24,839 --> 00:17:32,009
is to answer the question can we reduce

00:17:28,079 --> 00:17:35,340
can we have zero downtime upgrades at

00:17:32,009 --> 00:17:38,129
all and the answer is actually yes but

00:17:35,340 --> 00:17:40,799
maybe no so it kind of depends on other

00:17:38,129 --> 00:17:42,539
things for example if you use redundant

00:17:40,799 --> 00:17:44,909
which will do this with lot side right

00:17:42,539 --> 00:17:47,429
now update is actually zero downtime

00:17:44,909 --> 00:17:50,490
because we have a rolling scheme where

00:17:47,429 --> 00:17:53,789
we always ensure that this one we are

00:17:50,490 --> 00:17:55,440
which is always off but there could be

00:17:53,789 --> 00:17:58,380
another answer to this which is

00:17:55,440 --> 00:18:00,360
a lot of people a lot of our customers

00:17:58,380 --> 00:18:02,400
and users I've interacted with our list

00:18:00,360 --> 00:18:03,960
and whatnot many of them are very

00:18:02,400 --> 00:18:05,610
risk-averse and they don't want to

00:18:03,960 --> 00:18:07,610
upgrade at all because they don't want

00:18:05,610 --> 00:18:11,220
to get rid of the virtual rooters and

00:18:07,610 --> 00:18:13,050
they some of them may as part of the

00:18:11,220 --> 00:18:17,100
upgrade process haven't touched let's

00:18:13,050 --> 00:18:19,350
say or they take some time to agree a

00:18:17,100 --> 00:18:20,700
let's say an upgrade maintenance window

00:18:19,350 --> 00:18:23,310
with the customer with their own

00:18:20,700 --> 00:18:25,380
customers with SaaS and whatnot so that

00:18:23,310 --> 00:18:27,960
they know when they are going to be

00:18:25,380 --> 00:18:30,060
affected and I think one of the answers

00:18:27,960 --> 00:18:32,790
could be don't destroy the VR so that

00:18:30,060 --> 00:18:34,890
means the best way to ensure that there

00:18:32,790 --> 00:18:38,820
is no downtime is to not you know touch

00:18:34,890 --> 00:18:41,570
the VR but that's fine but how do we

00:18:38,820 --> 00:18:44,820
still upgrade because is there a way to

00:18:41,570 --> 00:18:47,100
you know get all of this Siletz this

00:18:44,820 --> 00:18:49,590
gives some ideas around this so I think

00:18:47,100 --> 00:18:51,870
the first idea I would say is let's get

00:18:49,590 --> 00:18:54,240
rid of the system in Droid ISO 5 let's

00:18:51,870 --> 00:18:56,790
think what let's think aloud what system

00:18:54,240 --> 00:18:58,790
you know - the file is system MDOT ISO

00:18:56,790 --> 00:19:01,500
file is basically a small payload of

00:18:58,790 --> 00:19:03,720
strips packages software jars and

00:19:01,500 --> 00:19:06,960
whatnot that need to be installed in the

00:19:03,720 --> 00:19:09,240
VR I mean doing this through the ISO is

00:19:06,960 --> 00:19:12,720
one way can we think of some other ways

00:19:09,240 --> 00:19:14,430
to do this and the other thing is can we

00:19:12,720 --> 00:19:17,760
reduce the footprint of the system

00:19:14,430 --> 00:19:20,400
template which will come in in a slide

00:19:17,760 --> 00:19:22,560
shortly the other issue I think with

00:19:20,400 --> 00:19:25,500
systems or iso file is it's kind of

00:19:22,560 --> 00:19:27,810
non-standard why let's think about the

00:19:25,500 --> 00:19:29,580
software upgrade end delivery schedules

00:19:27,810 --> 00:19:31,410
for example in case of KVM this is

00:19:29,580 --> 00:19:33,840
delivered by the clots that common

00:19:31,410 --> 00:19:35,640
package so an admin has to make sure

00:19:33,840 --> 00:19:38,490
that cloth sack agent in classic on

00:19:35,640 --> 00:19:40,200
packages upgraded across its FF 10,000

00:19:38,490 --> 00:19:42,420
moves you have to do is on all those

00:19:40,200 --> 00:19:44,040
hosts now I'm not saying that's not

00:19:42,420 --> 00:19:47,610
possible I'm saying people have

00:19:44,040 --> 00:19:49,590
automation for that but but that still

00:19:47,610 --> 00:19:51,570
is an additional step you have to ensure

00:19:49,590 --> 00:19:53,970
and you have to verify as part of your

00:19:51,570 --> 00:19:55,590
upgrade process in case of VMware this

00:19:53,970 --> 00:19:58,980
is done through secondary storage that

00:19:55,590 --> 00:20:00,930
means just having this approach requires

00:19:58,980 --> 00:20:02,880
dependency of secondary storage if

00:20:00,930 --> 00:20:05,490
somebody doesn't want to use secondary

00:20:02,880 --> 00:20:07,200
storage they have to because the system

00:20:05,490 --> 00:20:08,380
um Durazo is hosted on the secondary

00:20:07,200 --> 00:20:10,330
storage

00:20:08,380 --> 00:20:12,100
in case of XenServer what CloudStack

00:20:10,330 --> 00:20:14,410
does is as part of the afraid it will

00:20:12,100 --> 00:20:17,050
copy the ISO file to each and every host

00:20:14,410 --> 00:20:19,330
at a specific location so the point is

00:20:17,050 --> 00:20:22,030
that there are multiple sources of truth

00:20:19,330 --> 00:20:24,340
um the solution right now is automation

00:20:22,030 --> 00:20:26,320
so you have written scripts to make sure

00:20:24,340 --> 00:20:28,060
that as part of your update process all

00:20:26,320 --> 00:20:32,950
those things are at the correct place

00:20:28,060 --> 00:20:34,810
and we have a non-standard patching

00:20:32,950 --> 00:20:37,870
process so we have our one script which

00:20:34,810 --> 00:20:40,300
will mount we'll check and it's kind of

00:20:37,870 --> 00:20:41,830
brittle if if there are issues the

00:20:40,300 --> 00:20:46,240
template is not at the correct position

00:20:41,830 --> 00:20:48,610
or for some reason it's the ISO file is

00:20:46,240 --> 00:20:50,620
not at the current is at the current

00:20:48,610 --> 00:20:53,080
path the other issue I would emphasize

00:20:50,620 --> 00:20:56,890
is as developers when we build tests in

00:20:53,080 --> 00:20:58,540
run CloudStack let's say these a lot of

00:20:56,890 --> 00:21:00,220
the code actually gets triggered when I

00:20:58,540 --> 00:21:01,840
when there is a change in the version of

00:21:00,220 --> 00:21:04,420
cloud stack for example if you have

00:21:01,840 --> 00:21:06,550
working with VMware as a developer and

00:21:04,420 --> 00:21:08,860
you have made some changes to the system

00:21:06,550 --> 00:21:10,690
data file it will not copy itself to the

00:21:08,860 --> 00:21:11,380
secondary storage because there's no

00:21:10,690 --> 00:21:12,940
change

00:21:11,380 --> 00:21:15,100
like fundamental change in the base

00:21:12,940 --> 00:21:16,930
version of cloud stack so as a developer

00:21:15,100 --> 00:21:19,510
you have to sometimes manually copy the

00:21:16,930 --> 00:21:20,980
ISO files the km host or VMware is in

00:21:19,510 --> 00:21:23,950
server you have to keep those things in

00:21:20,980 --> 00:21:27,460
mind and overall I should also mention

00:21:23,950 --> 00:21:29,320
that we have a dependency we kind of

00:21:27,460 --> 00:21:31,630
assume that system template will have a

00:21:29,320 --> 00:21:33,640
tower and time environment installed if

00:21:31,630 --> 00:21:35,530
there is a security bug in Java and time

00:21:33,640 --> 00:21:39,580
environment then you have to create a

00:21:35,530 --> 00:21:41,440
new template you have to do update for

00:21:39,580 --> 00:21:43,150
all the routers across your hardware you

00:21:41,440 --> 00:21:46,180
have to do security advisories there's a

00:21:43,150 --> 00:21:48,760
lot of process that is required when

00:21:46,180 --> 00:21:51,670
that happens so the proposal or idea

00:21:48,760 --> 00:21:53,950
could be can we think of ways of getting

00:21:51,670 --> 00:21:57,580
rid of this ISO file at the same time

00:21:53,950 --> 00:21:59,080
can we also think of reducing the impact

00:21:57,580 --> 00:22:00,520
layer in the system and template that

00:21:59,080 --> 00:22:02,710
means reducing software which is

00:22:00,520 --> 00:22:04,210
pre-installed in the template like don't

00:22:02,710 --> 00:22:07,450
install shower and time environment you

00:22:04,210 --> 00:22:09,160
can explore using Java Elevens j-link

00:22:07,450 --> 00:22:12,130
that allows you to bundle a custom

00:22:09,160 --> 00:22:13,930
runtime environment with the video

00:22:12,130 --> 00:22:15,940
application specific code that means

00:22:13,930 --> 00:22:18,790
you're kind of building is package which

00:22:15,940 --> 00:22:21,430
has the runtime environment and the

00:22:18,790 --> 00:22:22,240
agent Josh pre-installed and the last

00:22:21,430 --> 00:22:24,340
thing is

00:22:22,240 --> 00:22:27,070
how can you actually do this is can we

00:22:24,340 --> 00:22:29,200
have a live patching mechanism that

00:22:27,070 --> 00:22:30,880
means I mean right now it's kind of

00:22:29,200 --> 00:22:34,420
started right you have to reboot and the

00:22:30,880 --> 00:22:37,059
scripts will match only at the time of

00:22:34,420 --> 00:22:39,490
boot can we have some sort of an API

00:22:37,059 --> 00:22:42,820
like life packs this that means system

00:22:39,490 --> 00:22:44,950
is up and running you simply go in patch

00:22:42,820 --> 00:22:46,990
the payload patch the packages the

00:22:44,950 --> 00:22:49,929
scripts in whatnot maybe restart some

00:22:46,990 --> 00:22:52,030
services so those could be some I think

00:22:49,929 --> 00:22:55,809
some ways we can explore and try and

00:22:52,030 --> 00:22:58,360
solve this problem and let me talk about

00:22:55,809 --> 00:23:02,080
another thing but before I proceed

00:22:58,360 --> 00:23:08,860
anyone has any questions anything to ask

00:23:02,080 --> 00:23:11,200
or discuss all right so the next idea is

00:23:08,860 --> 00:23:14,140
how can we get rid of the VR codebase I

00:23:11,200 --> 00:23:17,110
think we have heard couple of complaints

00:23:14,140 --> 00:23:19,450
here that its non-standard way in order

00:23:17,110 --> 00:23:21,100
to get from the management server to the

00:23:19,450 --> 00:23:23,530
virtual with respect to we are

00:23:21,100 --> 00:23:24,580
programming it's different for different

00:23:23,530 --> 00:23:26,710
hypervisor

00:23:24,580 --> 00:23:28,660
if it's difficult to debug sometimes you

00:23:26,710 --> 00:23:32,679
have to go from management server to the

00:23:28,660 --> 00:23:35,440
host to the VR sometimes and I think

00:23:32,679 --> 00:23:37,240
what I would like to propose is to first

00:23:35,440 --> 00:23:39,160
understand what is the codebase right

00:23:37,240 --> 00:23:42,760
now it's mostly Python in shell script

00:23:39,160 --> 00:23:44,410
based it's custom non-standard the input

00:23:42,760 --> 00:23:46,330
outputs of all those scripts are

00:23:44,410 --> 00:23:48,610
different so you have to actually read

00:23:46,330 --> 00:23:51,850
and understand what that script does if

00:23:48,610 --> 00:23:53,830
you want to extend maintainer or do

00:23:51,850 --> 00:23:57,040
something with the an existing feature

00:23:53,830 --> 00:23:59,530
and it's hard to unit test you cannot

00:23:57,040 --> 00:24:01,809
test there we are code base or the

00:23:59,530 --> 00:24:05,309
virtual router in isolation you have to

00:24:01,809 --> 00:24:07,480
have like the entire cloud stack

00:24:05,309 --> 00:24:09,940
environment up and running and then you

00:24:07,480 --> 00:24:11,530
use Marvin to kind of kick tests in

00:24:09,940 --> 00:24:14,800
tandem with cloud sites so we are

00:24:11,530 --> 00:24:16,870
currently has no kind of place in

00:24:14,800 --> 00:24:20,050
isolation it works only with management

00:24:16,870 --> 00:24:22,059
server and as I mentioned maintenance

00:24:20,050 --> 00:24:25,300
and extension issues are there the code

00:24:22,059 --> 00:24:27,340
is fragmented when you do upgrade let us

00:24:25,300 --> 00:24:29,470
say as developers now this is an issue

00:24:27,340 --> 00:24:31,059
from developers when you when you are

00:24:29,470 --> 00:24:33,580
working on a we are related feature you

00:24:31,059 --> 00:24:35,049
have to kill these SCP vo- appear

00:24:33,580 --> 00:24:37,419
multiple times I

00:24:35,049 --> 00:24:39,970
if we saw if you remember ways talk from

00:24:37,419 --> 00:24:43,690
yesterday I remember what he did

00:24:39,970 --> 00:24:46,059
he changed some global settings I did

00:24:43,690 --> 00:24:48,009
like a certificate then he had to

00:24:46,059 --> 00:24:50,440
actually killing destroy those CPV aims

00:24:48,009 --> 00:24:51,989
to get those teasers apply that's a

00:24:50,440 --> 00:24:54,909
routine we have anything to do with

00:24:51,989 --> 00:24:56,679
certain global settings or features or

00:24:54,909 --> 00:24:58,360
adding a certificate you have to destroy

00:24:56,679 --> 00:25:02,619
the whole thing there's no way to live

00:24:58,360 --> 00:25:04,509
match those so that is fine but can we

00:25:02,619 --> 00:25:06,820
introduce versioning of the tools and

00:25:04,509 --> 00:25:09,100
scripts because as a developer when I'm

00:25:06,820 --> 00:25:11,830
working and changing things life I

00:25:09,100 --> 00:25:15,070
cannot kind of do a hot reload of the

00:25:11,830 --> 00:25:17,200
code if you catch my drift you cannot do

00:25:15,070 --> 00:25:19,179
sort of a hot reload of the code or hot

00:25:17,200 --> 00:25:21,129
patching based on cloud stack

00:25:19,179 --> 00:25:23,859
automatically detecting changes in file

00:25:21,129 --> 00:25:26,889
based on checksums showers and things

00:25:23,859 --> 00:25:29,049
like that and the last thing is it's all

00:25:26,889 --> 00:25:32,159
manually executed by management server

00:25:29,049 --> 00:25:35,350
via SSH so right now what we do is we

00:25:32,159 --> 00:25:38,139
some people have shared their complains

00:25:35,350 --> 00:25:40,480
that if there are 10000 IP table rules

00:25:38,139 --> 00:25:43,779
or 10,000 different things you want to

00:25:40,480 --> 00:25:46,210
configure to the VR they are done I

00:25:43,779 --> 00:25:48,429
think sequentially in some cases we have

00:25:46,210 --> 00:25:51,039
actually made improvement so we do

00:25:48,429 --> 00:25:53,590
aggregate a lot of those commands but

00:25:51,039 --> 00:25:56,049
overall if you have if you want to let's

00:25:53,590 --> 00:25:59,559
say program or the IP table rules static

00:25:56,049 --> 00:26:03,159
routes VPN all those things are matched

00:25:59,559 --> 00:26:06,850
by their by their application or utility

00:26:03,159 --> 00:26:11,139
type but not as a whole and the way we

00:26:06,850 --> 00:26:13,749
do program which will route it's totally

00:26:11,139 --> 00:26:15,879
weird when you when you are upgrading a

00:26:13,749 --> 00:26:17,980
virtual router it kind of creates a

00:26:15,879 --> 00:26:20,909
specific XML file which has this a

00:26:17,980 --> 00:26:24,879
minute with some another jason with some

00:26:20,909 --> 00:26:28,779
example separator so you know as a new

00:26:24,879 --> 00:26:30,519
person I've had experience with looking

00:26:28,779 --> 00:26:32,710
into how new people kind of perceive

00:26:30,519 --> 00:26:37,359
those codon and you can we can imagine

00:26:32,710 --> 00:26:39,580
they're the the sort of confusion and

00:26:37,359 --> 00:26:42,489
pain that this codebase would cause to

00:26:39,580 --> 00:26:44,499
them so here's the idea how do we

00:26:42,489 --> 00:26:46,779
implement life patch so what I'm

00:26:44,499 --> 00:26:48,550
proposing is let's have a small which

00:26:46,779 --> 00:26:50,770
will router agent that

00:26:48,550 --> 00:26:53,290
is like a server so you're kind of

00:26:50,770 --> 00:26:56,980
saying let's instead of ssh introduce a

00:26:53,290 --> 00:26:58,930
service that can use the thoughts taxi a

00:26:56,980 --> 00:27:01,270
framework so it's like everything is

00:26:58,930 --> 00:27:04,690
still secure authenticated but you are

00:27:01,270 --> 00:27:07,540
not using ssl the the the wild card

00:27:04,690 --> 00:27:11,290
general ssl ssh public key to assess it

00:27:07,540 --> 00:27:13,120
so many have virtual wrote this specific

00:27:11,290 --> 00:27:15,280
certificate you know for what it is

00:27:13,120 --> 00:27:18,400
falling forward IPS and whatnot and that

00:27:15,280 --> 00:27:21,070
can be more secure i think the other

00:27:18,400 --> 00:27:24,250
thing is why i thought about we are

00:27:21,070 --> 00:27:27,190
agent why because this is something you

00:27:24,250 --> 00:27:29,140
can actually try on our laptops open a

00:27:27,190 --> 00:27:30,790
python like try to write a Python script

00:27:29,140 --> 00:27:34,030
which will simply print hello world

00:27:30,790 --> 00:27:36,370
sleep and definitely try to run an EOC

00:27:34,030 --> 00:27:39,540
it will consume anywhere from 6 to 30 MB

00:27:36,370 --> 00:27:41,650
memory because the Python runtime

00:27:39,540 --> 00:27:43,300
environment will consume that amount of

00:27:41,650 --> 00:27:46,300
memory in a resource-constrained

00:27:43,300 --> 00:27:50,080
environment like virtual router you

00:27:46,300 --> 00:27:52,660
cannot run scripts that take 30 mb/s of

00:27:50,080 --> 00:27:53,410
memory because imagine thoughts I tried

00:27:52,660 --> 00:27:56,440
SSH

00:27:53,410 --> 00:27:57,430
to the VR in let's say 1 5 different

00:27:56,440 --> 00:28:01,810
scripts

00:27:57,430 --> 00:28:04,540
that's 150 megabytes of memory now when

00:28:01,810 --> 00:28:07,000
in a very large in normal when this does

00:28:04,540 --> 00:28:09,520
happen we see swapping in a lot of other

00:28:07,000 --> 00:28:11,590
issues do come up so the idea is can we

00:28:09,520 --> 00:28:15,070
have a small VR agent that has a light

00:28:11,590 --> 00:28:17,500
footprint and it kind of manages all the

00:28:15,070 --> 00:28:20,800
services and whatnot it supports live

00:28:17,500 --> 00:28:24,340
patching instead of hosting system you

00:28:20,800 --> 00:28:26,200
know ISO file attaching on the VR it is

00:28:24,340 --> 00:28:28,480
on the management server at some

00:28:26,200 --> 00:28:30,340
location the management server can poll

00:28:28,480 --> 00:28:32,200
using a background task every few

00:28:30,340 --> 00:28:34,480
minutes so is there a chain in the file

00:28:32,200 --> 00:28:38,410
if yes it can automatically connect to

00:28:34,480 --> 00:28:40,840
that single TLS connection or socket and

00:28:38,410 --> 00:28:43,090
basically wire all the new changes using

00:28:40,840 --> 00:28:46,630
something like our sink or BitTorrent or

00:28:43,090 --> 00:28:48,580
something or in using the existing you

00:28:46,630 --> 00:28:51,730
know connection socket which management

00:28:48,580 --> 00:28:54,010
server can can can track and that way we

00:28:51,730 --> 00:28:56,050
introduced a standard way that how fast

00:28:54,010 --> 00:28:57,670
when server it talks to a we are that it

00:28:56,050 --> 00:29:00,010
leads to the agent there's no need to

00:28:57,670 --> 00:29:02,770
actually go through the hosts in case of

00:29:00,010 --> 00:29:05,950
VMware we do this right now we ever does

00:29:02,770 --> 00:29:09,370
and support a concept of link global IP

00:29:05,950 --> 00:29:11,470
so you don't exercise into the ESXi host

00:29:09,370 --> 00:29:14,290
to go into the VI you directly go

00:29:11,470 --> 00:29:16,210
through the private IP address why

00:29:14,290 --> 00:29:18,460
because you're on a management network

00:29:16,210 --> 00:29:20,620
so we kind of zoom this is there must be

00:29:18,460 --> 00:29:22,570
some sort of security and isolation on

00:29:20,620 --> 00:29:24,880
top of that what we are saying is let's

00:29:22,570 --> 00:29:27,250
use the CA framework so the connection

00:29:24,880 --> 00:29:29,020
is secure enough and we are saying there

00:29:27,250 --> 00:29:32,710
is a single connection so if you still

00:29:29,020 --> 00:29:34,660
want to program 10,000 IP tables not SSA

00:29:32,710 --> 00:29:39,430
Qing 10,000 times there's only one

00:29:34,660 --> 00:29:41,680
single fat pipe TLS you know TCP TLS

00:29:39,430 --> 00:29:43,990
connection wave which you used to kind

00:29:41,680 --> 00:29:46,360
of program and talk to the VR agent when

00:29:43,990 --> 00:29:48,310
you do that the VR agent is much more in

00:29:46,360 --> 00:29:51,130
control nor can manage concurrency

00:29:48,310 --> 00:29:53,800
sequence synchronization because one of

00:29:51,130 --> 00:29:56,830
the issues in VR lot of the developers

00:29:53,800 --> 00:29:58,900
know is when you SSH try to IR on IP

00:29:56,830 --> 00:29:59,920
tables by three different scripts I mean

00:29:58,900 --> 00:30:02,770
the same script but three different

00:29:59,920 --> 00:30:05,620
executions they can have a lot of issues

00:30:02,770 --> 00:30:07,540
around sequence and synchronization and

00:30:05,620 --> 00:30:09,580
whatnot and we have harsh couple of

00:30:07,540 --> 00:30:13,420
issues at scale we have seen those

00:30:09,580 --> 00:30:16,120
things for example when you upgrade a

00:30:13,420 --> 00:30:17,950
cloud stack environment let's say you

00:30:16,120 --> 00:30:21,550
have an isolated Network but for some

00:30:17,950 --> 00:30:24,040
reason it has 10,000 VMs guest VM that

00:30:21,550 --> 00:30:27,220
means cloud stack will try to add 10,000

00:30:24,040 --> 00:30:29,350
DHCP and DNS rules to DNS mask and in

00:30:27,220 --> 00:30:32,050
its current form it kind of restart the

00:30:29,350 --> 00:30:33,610
DNS mosque every time it does that now

00:30:32,050 --> 00:30:37,750
there are ways to not do that you can

00:30:33,610 --> 00:30:39,730
use some sort of let's say you can pass

00:30:37,750 --> 00:30:41,260
a signal to simply say you know just

00:30:39,730 --> 00:30:43,240
reload yourselves instead of doing a

00:30:41,260 --> 00:30:45,850
restart you can reload the service and

00:30:43,240 --> 00:30:48,850
assume that it will program all those

00:30:45,850 --> 00:30:50,560
10,000 rules when you do restart even

00:30:48,850 --> 00:30:53,050
for let's say couple of milliseconds at

00:30:50,560 --> 00:30:54,760
large scale with 10,000 VMs some of the

00:30:53,050 --> 00:30:57,280
Venus may not get IP address leases

00:30:54,760 --> 00:30:59,830
renewal may fail so you had seen those

00:30:57,280 --> 00:31:03,870
issues so if there is a single VR agent

00:30:59,830 --> 00:31:06,220
which is at you know handling a single

00:31:03,870 --> 00:31:09,130
you know socket Pervis one server

00:31:06,220 --> 00:31:11,680
programming would be much faster and it

00:31:09,130 --> 00:31:16,150
can manage threading synchronization and

00:31:11,680 --> 00:31:18,790
n concurrency so that's sort of the idea

00:31:16,150 --> 00:31:21,880
and the other thing is the non-core

00:31:18,790 --> 00:31:25,030
services things like your Abacha VIP so

00:31:21,880 --> 00:31:26,920
things like H a proxy maybe your

00:31:25,030 --> 00:31:29,320
password server they can actually run

00:31:26,920 --> 00:31:31,930
inside of the VRS containers so that

00:31:29,320 --> 00:31:34,630
means they are they have some sort of

00:31:31,930 --> 00:31:38,140
isolation from the core code that means

00:31:34,630 --> 00:31:42,430
your kernel IP route IP tables or nft

00:31:38,140 --> 00:31:44,770
now and those kind of implement the core

00:31:42,430 --> 00:31:46,480
services in virtual routed that means

00:31:44,770 --> 00:31:50,020
when you have life patch you

00:31:46,480 --> 00:31:52,960
containerize couple of non core demons

00:31:50,020 --> 00:31:58,360
and services then as part of upgrade it

00:31:52,960 --> 00:32:00,790
should be possible to do have those have

00:31:58,360 --> 00:32:03,220
is almost zero downtime without actually

00:32:00,790 --> 00:32:05,710
getting out of the VR now for this I

00:32:03,220 --> 00:32:08,050
think I don't have time to show some

00:32:05,710 --> 00:32:10,210
demos but what I did was is this playing

00:32:08,050 --> 00:32:13,060
with the idea can we have a small we are

00:32:10,210 --> 00:32:15,520
agent with you know see a framework heal

00:32:13,060 --> 00:32:18,130
a secured connection and I came up with

00:32:15,520 --> 00:32:19,990
a gr PC based we are raising so idea

00:32:18,130 --> 00:32:22,000
about gr PC is you define a protocol

00:32:19,990 --> 00:32:24,610
buff file so it's a standard interface

00:32:22,000 --> 00:32:27,460
file that can the compiler can generate

00:32:24,610 --> 00:32:28,900
the Java library or code in go specific

00:32:27,460 --> 00:32:32,320
so in this example this was a go

00:32:28,900 --> 00:32:34,990
specific agent the reason I like go for

00:32:32,320 --> 00:32:38,620
this use case was you you have a static

00:32:34,990 --> 00:32:40,750
file single file that can use very less

00:32:38,620 --> 00:32:43,360
memory let's say about less than 1 MB in

00:32:40,750 --> 00:32:46,450
size and gives you ease as developers to

00:32:43,360 --> 00:32:48,670
developers it it is kind of ease it

00:32:46,450 --> 00:32:50,560
provides ease and it's easy to implement

00:32:48,670 --> 00:32:55,090
new feature handle concurrency and

00:32:50,560 --> 00:32:57,040
whatnot and how do we manage upgrade

00:32:55,090 --> 00:32:59,710
path for non core services in containers

00:32:57,040 --> 00:33:01,780
for this what we experimented a bit

00:32:59,710 --> 00:33:04,240
again I we experimented as part of the

00:33:01,780 --> 00:33:07,150
plots like container service is you can

00:33:04,240 --> 00:33:09,820
actually create custom docker images

00:33:07,150 --> 00:33:13,120
export them and tar and those star could

00:33:09,820 --> 00:33:14,800
either be sent to the to the VR through

00:33:13,120 --> 00:33:18,100
the system you know to ISO file or

00:33:14,800 --> 00:33:20,050
through the you know live patch API so

00:33:18,100 --> 00:33:21,970
you can actually you don't need to

00:33:20,050 --> 00:33:24,130
restart VR you it's like after data

00:33:21,970 --> 00:33:26,590
update but without the after you using

00:33:24,130 --> 00:33:29,260
container images and of course if you

00:33:26,590 --> 00:33:29,680
want to upgrade kernel there's a new

00:33:29,260 --> 00:33:32,560
feature

00:33:29,680 --> 00:33:34,930
you can live past the kernel itself now

00:33:32,560 --> 00:33:37,480
just an example like why I let go

00:33:34,930 --> 00:33:40,320
because you can actually compile go and

00:33:37,480 --> 00:33:42,610
you can use go as a script so the

00:33:40,320 --> 00:33:45,250
commenting if you put it in a go file

00:33:42,610 --> 00:33:47,260
and write a small go program and you say

00:33:45,250 --> 00:33:49,150
dot slash that script like you are

00:33:47,260 --> 00:33:52,260
executing by thinner shell script it

00:33:49,150 --> 00:33:54,520
kind of runs so go can give you the

00:33:52,260 --> 00:33:57,190
dynamic programming you don't need to

00:33:54,520 --> 00:33:59,110
compile at runtime you just send go

00:33:57,190 --> 00:34:00,610
files there's the go compiler and I'm in

00:33:59,110 --> 00:34:03,100
the we are and it can run scripts like

00:34:00,610 --> 00:34:05,830
this or you have a binary so it's it's a

00:34:03,100 --> 00:34:09,400
choice we can have but something like

00:34:05,830 --> 00:34:11,260
shell script or Python but with go now

00:34:09,400 --> 00:34:13,090
getting rid of system in tablet I did a

00:34:11,260 --> 00:34:15,670
small test I thought let's move to

00:34:13,090 --> 00:34:18,580
alpine Linux get rid of all the non core

00:34:15,670 --> 00:34:20,380
services I could got i could reduce the

00:34:18,580 --> 00:34:22,810
footprint of the disk image size to as

00:34:20,380 --> 00:34:25,060
low as 50 mb/s or about 100 mb/s in size

00:34:22,810 --> 00:34:28,030
when you go that low you don't need to

00:34:25,060 --> 00:34:29,500
host the files at a hosting service you

00:34:28,030 --> 00:34:32,350
can actually package this system

00:34:29,500 --> 00:34:35,680
template as Deb's and jars sorry rpms

00:34:32,350 --> 00:34:36,940
and that so that could be one way the

00:34:35,680 --> 00:34:38,920
other thing is one of my colleagues

00:34:36,940 --> 00:34:41,710
Darin has worked on a system template

00:34:38,920 --> 00:34:44,710
management API so that allows you to

00:34:41,710 --> 00:34:48,160
upload a new system template there's an

00:34:44,710 --> 00:34:50,200
API to register a template so you can do

00:34:48,160 --> 00:34:51,970
a lot of things system template

00:34:50,200 --> 00:34:55,330
management all those features you can

00:34:51,970 --> 00:34:58,780
actually do without just relying on that

00:34:55,330 --> 00:35:00,670
upgrade path the last may be a bold idea

00:34:58,780 --> 00:35:02,620
could be let's not have hypervisor

00:35:00,670 --> 00:35:06,760
specific templates at all let's do a

00:35:02,620 --> 00:35:09,310
custom live distribution that runs as a

00:35:06,760 --> 00:35:11,920
read-only root filesystem and then we

00:35:09,310 --> 00:35:14,590
attach the data disk for logs in

00:35:11,920 --> 00:35:17,050
configuration so that way cloud stack

00:35:14,590 --> 00:35:19,600
can only ship an iso file which runs as

00:35:17,050 --> 00:35:22,180
a live Linux distribution that's the

00:35:19,600 --> 00:35:24,760
router distribution and for any config

00:35:22,180 --> 00:35:27,490
for persistence it uses a data disk so

00:35:24,760 --> 00:35:29,890
that way we don't have to build tests

00:35:27,490 --> 00:35:33,160
and run hypervisor specific templates

00:35:29,890 --> 00:35:34,990
that we do right now let's also think

00:35:33,160 --> 00:35:37,990
about can you actually get rid of all

00:35:34,990 --> 00:35:39,640
those things that would be great so can

00:35:37,990 --> 00:35:41,650
we get rid of CP VM I think that's

00:35:39,640 --> 00:35:43,210
something we discussed yesterday I think

00:35:41,650 --> 00:35:45,970
yes if we can

00:35:43,210 --> 00:35:48,280
package the console proxy as a jar or

00:35:45,970 --> 00:35:49,960
rpm and let admins decide where they

00:35:48,280 --> 00:35:52,599
specifically want to host and run you

00:35:49,960 --> 00:35:55,570
can run DCP VM on the management server

00:35:52,599 --> 00:35:58,960
itself about SS VM I think the same you

00:35:55,570 --> 00:36:00,820
can have a s engine specific de Bourgh

00:35:58,960 --> 00:36:04,330
rpm package that can run on a separate

00:36:00,820 --> 00:36:06,339
host then let's say an SS VM itself how

00:36:04,330 --> 00:36:09,010
about the VR so the problem is except

00:36:06,339 --> 00:36:12,250
for VMware it is technically possible to

00:36:09,010 --> 00:36:14,440
run a bridge based sort of router and l3

00:36:12,250 --> 00:36:17,230
device on the hosts of that acts as a

00:36:14,440 --> 00:36:22,030
router and I'm aware of at least

00:36:17,230 --> 00:36:24,640
specifics though sorry forgot the name

00:36:22,030 --> 00:36:26,050
of the company but I know if one friend

00:36:24,640 --> 00:36:28,270
when the community who has done this and

00:36:26,050 --> 00:36:30,339
they have experimented where they are

00:36:28,270 --> 00:36:34,089
not running Vyasa at all they have all

00:36:30,339 --> 00:36:36,880
the core services on a l3 you know

00:36:34,089 --> 00:36:38,770
bridge and they program all the knot and

00:36:36,880 --> 00:36:41,260
IP table rules and everything on that on

00:36:38,770 --> 00:36:44,800
the host itself and if they don't need

00:36:41,260 --> 00:36:48,180
cold non core services like DHCP DNS and

00:36:44,800 --> 00:36:52,349
all that so that seems to be possible

00:36:48,180 --> 00:36:54,690
though there are challenges with the

00:36:52,349 --> 00:36:58,780
weather I think a lot of these ideas

00:36:54,690 --> 00:37:01,450
like I mean you have to get rid of the

00:36:58,780 --> 00:37:03,550
core concept of link local IPs that

00:37:01,450 --> 00:37:05,380
means part of the upgrade process we

00:37:03,550 --> 00:37:07,359
will have to work with the community and

00:37:05,380 --> 00:37:10,230
see if there's any anyone has a problem

00:37:07,359 --> 00:37:15,390
with upgrading and adding some IP ranges

00:37:10,230 --> 00:37:18,160
on their match meant high range because

00:37:15,390 --> 00:37:20,410
if we get rid of the link local IPS that

00:37:18,160 --> 00:37:23,950
means all the vias which are not taking

00:37:20,410 --> 00:37:28,000
any private IP will take an IP IP from

00:37:23,950 --> 00:37:29,410
the private IP pool and in general I

00:37:28,000 --> 00:37:31,810
mean a lot of this will require code

00:37:29,410 --> 00:37:34,450
base changes and again not all ideas are

00:37:31,810 --> 00:37:37,839
good idea so again let's discuss and see

00:37:34,450 --> 00:37:39,910
what makes sense I think I'm out of time

00:37:37,839 --> 00:37:41,680
so I will quickly go through some slides

00:37:39,910 --> 00:37:45,369
I mean these are different network types

00:37:41,680 --> 00:37:47,589
that loveSac supports my colleague in

00:37:45,369 --> 00:37:50,440
friend Polya has given a nice talk on

00:37:47,589 --> 00:37:53,800
complex networks there's a link to that

00:37:50,440 --> 00:37:55,960
here you can find on the slides where we

00:37:53,800 --> 00:37:56,440
want to introduce something called as an

00:37:55,960 --> 00:37:58,839
enterprise

00:37:56,440 --> 00:38:01,359
we are which is an ISP for order like

00:37:58,839 --> 00:38:03,490
purchase order you make it's like a wire

00:38:01,359 --> 00:38:05,079
with the blood you plug it in we want

00:38:03,490 --> 00:38:09,550
that same kind of functionality in cloud

00:38:05,079 --> 00:38:11,380
stack and I'll briefly talk about I mean

00:38:09,550 --> 00:38:14,410
what this et we are can provide like you

00:38:11,380 --> 00:38:16,599
have I mean it may or may not have a

00:38:14,410 --> 00:38:19,300
port forwarding firewall VPN and whatnot

00:38:16,599 --> 00:38:21,339
it can have chaining for example you can

00:38:19,300 --> 00:38:23,380
bring in your own water you don't want

00:38:21,339 --> 00:38:25,300
cloud stack we are to provide VPN you

00:38:23,380 --> 00:38:27,730
want to bring in your own appliance to

00:38:25,300 --> 00:38:30,310
do VPN or SSL offloading or something

00:38:27,730 --> 00:38:32,200
like that so it's just a mock the Bible

00:38:30,310 --> 00:38:34,630
on where you can sort of gain different

00:38:32,200 --> 00:38:37,300
like network devices so maybe those

00:38:34,630 --> 00:38:39,700
things can work the last thing is as a

00:38:37,300 --> 00:38:42,160
just a consumer of network I don't want

00:38:39,700 --> 00:38:43,780
to I mean it's hard to create networks

00:38:42,160 --> 00:38:45,069
in cloud side right now you have to go

00:38:43,780 --> 00:38:47,440
through the service offering and say

00:38:45,069 --> 00:38:50,020
what kind of combination of the VR you

00:38:47,440 --> 00:38:52,210
want maybe having a network designer a

00:38:50,020 --> 00:38:55,690
UI designer where you can drag things

00:38:52,210 --> 00:38:57,579
around it's like drawing a line between

00:38:55,690 --> 00:38:58,930
two VMs like adding them with the wire

00:38:57,579 --> 00:39:01,510
so it will automatically you plug in

00:38:58,930 --> 00:39:03,640
next you have an l2 network there then

00:39:01,510 --> 00:39:05,290
in there so those things may be may be

00:39:03,640 --> 00:39:07,569
possible and I think we can take

00:39:05,290 --> 00:39:09,700
inspiration from other portals including

00:39:07,569 --> 00:39:14,290
OpenStack curvature it's a project from

00:39:09,700 --> 00:39:17,050
Cisco on how they have done this to do

00:39:14,290 --> 00:39:19,619
all of this I guess there are some

00:39:17,050 --> 00:39:22,270
high-level proposals we need to refactor

00:39:19,619 --> 00:39:25,510
amalgamate the idea for zones so like

00:39:22,270 --> 00:39:27,339
sis zones doesn't matter what kind of I

00:39:25,510 --> 00:39:29,890
mean it says zones and then their

00:39:27,339 --> 00:39:32,380
networks the only two there are only two

00:39:29,890 --> 00:39:34,750
types of networks from a designing or

00:39:32,380 --> 00:39:37,540
you know admin point of view l2 and l3

00:39:34,750 --> 00:39:38,950
and what you provide on top of that are

00:39:37,540 --> 00:39:42,700
those additional features and services

00:39:38,950 --> 00:39:45,190
so we need to refactor in a lot of code

00:39:42,700 --> 00:39:46,750
base clean up technical debt which kind

00:39:45,190 --> 00:39:49,810
of has a lot of assumptions whether the

00:39:46,750 --> 00:39:51,520
network is a vbc network and isolated

00:39:49,810 --> 00:39:53,680
network whether it is redundant or not

00:39:51,520 --> 00:39:55,900
so there are four different code paths

00:39:53,680 --> 00:39:58,660
in cloud psych right now we implement a

00:39:55,900 --> 00:40:01,480
small feature as simple as program this

00:39:58,660 --> 00:40:03,819
IP address n DNS record for this guest

00:40:01,480 --> 00:40:05,650
VM is this actually implemented by these

00:40:03,819 --> 00:40:07,569
four different tracks whether depending

00:40:05,650 --> 00:40:09,400
on whether we are is the network is

00:40:07,569 --> 00:40:12,070
isolated we see

00:40:09,400 --> 00:40:14,740
whether it is redundant or non redundant

00:40:12,070 --> 00:40:16,720
and again there's some ideas on merging

00:40:14,740 --> 00:40:19,060
the concept of EPC and isolated because

00:40:16,720 --> 00:40:23,980
isolated Network is basically a one tier

00:40:19,060 --> 00:40:39,370
vbc with some lesser features network is

00:40:23,980 --> 00:41:24,430
basically an idea and again if you have

00:40:39,370 --> 00:41:27,910
any questions yes I think that's a good

00:41:24,430 --> 00:41:30,310
feedback so we currently do support sort

00:41:27,910 --> 00:41:32,320
of passing the baton from the old to the

00:41:30,310 --> 00:41:35,500
new in case of redundant virtual Rooter

00:41:32,320 --> 00:41:39,790
for that we use cable IV and which is

00:41:35,500 --> 00:41:41,440
vrrp based though I think what feed by a

00:41:39,790 --> 00:41:43,690
good feedback I think I'll take from

00:41:41,440 --> 00:41:45,550
that is make every we are written and

00:41:43,690 --> 00:41:47,800
capable so like even if you don't have

00:41:45,550 --> 00:41:49,720
like an active or a backup so if for

00:41:47,800 --> 00:41:52,330
every active we are we kind of consider

00:41:49,720 --> 00:41:54,970
every isolated we are to be an active

00:41:52,330 --> 00:41:57,720
and when the new one comes up treated as

00:41:54,970 --> 00:42:02,040
a backup and do sort of hot transfer of

00:41:57,720 --> 00:42:02,040
connections through like contract D I

00:42:20,160 --> 00:42:22,900
think that's a very hard problem to be

00:42:22,570 --> 00:42:26,079
honest

00:42:22,900 --> 00:42:28,119
vrrp keep a library tries to solve that

00:42:26,079 --> 00:42:29,349
in its it's really hard when you have

00:42:28,119 --> 00:43:49,029
different versions of the software

00:42:29,349 --> 00:43:51,039
trying to you know but I think it has

00:43:49,029 --> 00:43:53,349
come up with someone I had a discussion

00:43:51,039 --> 00:43:56,770
on this in the past but the thing where

00:43:53,349 --> 00:43:58,779
danceable is there is an existing code

00:43:56,770 --> 00:44:00,369
base so anything new you're trying to do

00:43:58,779 --> 00:44:03,579
that's going to take bandwidth in time

00:44:00,369 --> 00:44:05,589
so it has pros and cons like this a

00:44:03,579 --> 00:44:09,190
whole debate going on between fights in

00:44:05,589 --> 00:44:11,339
two and three so that's the first thing

00:44:09,190 --> 00:44:14,170
I can I can imagine the other thing is

00:44:11,339 --> 00:44:18,880
we want cloud stack to be the source of

00:44:14,170 --> 00:44:20,380
truth so so this cloud stack and the top

00:44:18,880 --> 00:44:22,390
stack is the control planes and that is

00:44:20,380 --> 00:44:24,640
the source of truth so all the rules

00:44:22,390 --> 00:44:26,319
should go from there and the mechanism

00:44:24,640 --> 00:44:31,390
you choose I mean that's fine if you use

00:44:26,319 --> 00:44:33,520
ansible or something is yeah all right

00:44:31,390 --> 00:44:35,950
guys any other questions

00:44:33,520 --> 00:44:38,680
all right so let's discuss in the

00:44:35,950 --> 00:44:40,240
hackathon and maybe outside if you have

00:44:38,680 --> 00:44:42,800
any questions or anything to discuss

00:44:40,240 --> 00:44:46,780
with me all right thank you guys

00:44:42,800 --> 00:44:46,780

YouTube URL: https://www.youtube.com/watch?v=C2PYSlFZI3Q


