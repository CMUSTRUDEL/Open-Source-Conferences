Title: Introduction to Apache Geode Through Spring Data
Publication date: 2020-10-15
Playlist: ApacheCon @Home 2020: Geode
Description: 
	Introduction to Apache Geode Through Spring Data
Patrick Johnson

A presentation from ApacheCon @Home 2020
https://apachecon.com/acah2020/

Apache Geode is a distributed in-memory data-grid designed with speed, concurrency, and scalability in mind. Apache Geode can be used as a system of record, cache, and much more. Spring Data is an extension of the Spring Framework that adds useful abstractions to make working with data simpler with less boilerplate code. In this presentation, Patrick will dive into what Apache Geode is, how it works, what it does, and how to get started using it with Spring Data for Apache Geode.

A (semi)recent graduate of Oregon Institute of Technology, Patrick is employed as a Software Engineer at VMware in Portland, Oregon, where he works primarily on Spring Data for Apache Geode.
Captions: 
	00:00:06,420 --> 00:00:10,640
[Music]

00:00:14,160 --> 00:00:17,230
[Music]

00:00:26,000 --> 00:00:31,039
okay well it looks like it's time

00:00:28,320 --> 00:00:31,599
so let's go ahead and get started i'm

00:00:31,039 --> 00:00:33,920
patrick

00:00:31,599 --> 00:00:35,520
i'm a software engineer at vmware and

00:00:33,920 --> 00:00:36,800
today i'm going to be introducing you to

00:00:35,520 --> 00:00:39,920
apache geode

00:00:36,800 --> 00:00:42,160
by way of spring so

00:00:39,920 --> 00:00:44,160
first let's start with the basics what

00:00:42,160 --> 00:00:46,800
is apache geode

00:00:44,160 --> 00:00:48,160
so geode is a distributed in-memory data

00:00:46,800 --> 00:00:50,160
management system

00:00:48,160 --> 00:00:52,239
distributed in the sense that geode is

00:00:50,160 --> 00:00:52,719
comprised of multiple data servers that

00:00:52,239 --> 00:00:55,600
will

00:00:52,719 --> 00:00:57,360
to work together to make up a cluster

00:00:55,600 --> 00:00:59,359
you can partition your data across the

00:00:57,360 --> 00:00:59,600
servers so that your data set is split

00:00:59,359 --> 00:01:02,480
up

00:00:59,600 --> 00:01:03,199
across them or you could replicate your

00:01:02,480 --> 00:01:05,760
data and have

00:01:03,199 --> 00:01:06,720
multiple redundant sets um on multiple

00:01:05,760 --> 00:01:10,000
servers

00:01:06,720 --> 00:01:13,280
or you could configure for both and it's

00:01:10,000 --> 00:01:15,200
in memory so unlike a traditional

00:01:13,280 --> 00:01:17,040
relational like sql database that's

00:01:15,200 --> 00:01:18,640
going to store things mostly on disk

00:01:17,040 --> 00:01:20,320
uh geode primarily is going to be

00:01:18,640 --> 00:01:22,960
storing things in memory um

00:01:20,320 --> 00:01:24,720
mostly for speed sake though it can also

00:01:22,960 --> 00:01:26,159
be configured to store things on disk if

00:01:24,720 --> 00:01:29,280
you need your data to be

00:01:26,159 --> 00:01:31,759
a little more permanent

00:01:29,280 --> 00:01:33,439
geode is also an object database so

00:01:31,759 --> 00:01:36,400
again unlike a traditional

00:01:33,439 --> 00:01:37,439
relational database that stores data as

00:01:36,400 --> 00:01:40,400
a row

00:01:37,439 --> 00:01:41,439
and a table geode stores your data in

00:01:40,400 --> 00:01:43,520
object form

00:01:41,439 --> 00:01:44,960
in what we call a region so a region is

00:01:43,520 --> 00:01:47,520
just a key value store

00:01:44,960 --> 00:01:50,640
that's got some object type as your key

00:01:47,520 --> 00:01:52,079
and some object type is your value

00:01:50,640 --> 00:01:54,720
and you can have multiple regions the

00:01:52,079 --> 00:01:58,240
same way a traditional database can have

00:01:54,720 --> 00:01:59,920
multiple tables so really

00:01:58,240 --> 00:02:01,600
geode is a bunch of maps because a

00:01:59,920 --> 00:02:03,920
region is just a key value store

00:02:01,600 --> 00:02:04,640
so geode is a bunch of distributed

00:02:03,920 --> 00:02:06,880
in-memory

00:02:04,640 --> 00:02:08,160
maps obviously there's a lot more to it

00:02:06,880 --> 00:02:09,759
than that but

00:02:08,160 --> 00:02:12,800
that's kind of the core if you really

00:02:09,759 --> 00:02:12,800
want to think about it that way

00:02:13,520 --> 00:02:19,840
okay so why would you want to use geode

00:02:17,840 --> 00:02:22,000
as i said before everything's stored in

00:02:19,840 --> 00:02:25,200
memory which is great for speed

00:02:22,000 --> 00:02:27,360
so performance intensive use cases

00:02:25,200 --> 00:02:29,040
geo's a great fit for it makes a great

00:02:27,360 --> 00:02:30,720
cache for speeding up your website or

00:02:29,040 --> 00:02:33,360
web service or whatever it is

00:02:30,720 --> 00:02:34,400
that's one really common use case

00:02:33,360 --> 00:02:36,400
scalability

00:02:34,400 --> 00:02:37,680
you can always just spin up more servers

00:02:36,400 --> 00:02:40,560
as you need more memory

00:02:37,680 --> 00:02:42,400
more disk space more computing resources

00:02:40,560 --> 00:02:44,400
and you can scale out

00:02:42,400 --> 00:02:46,000
geode clusters are capable of handling

00:02:44,400 --> 00:02:48,239
terabyte scale data

00:02:46,000 --> 00:02:49,120
and many thousands of operations per

00:02:48,239 --> 00:02:50,879
second so

00:02:49,120 --> 00:02:53,280
whatever workload you've got geode can

00:02:50,879 --> 00:02:55,440
handle that

00:02:53,280 --> 00:02:56,959
geode also provides strong consistency

00:02:55,440 --> 00:02:58,239
guarantees and database like

00:02:56,959 --> 00:03:01,200
transactionality

00:02:58,239 --> 00:03:02,480
which can be really critical for for

00:03:01,200 --> 00:03:04,400
applications where you have to be

00:03:02,480 --> 00:03:05,920
consistent all the time maybe if you're

00:03:04,400 --> 00:03:07,440
working with financial data where you're

00:03:05,920 --> 00:03:10,560
not allowed to just

00:03:07,440 --> 00:03:12,400
lose money or something like that

00:03:10,560 --> 00:03:14,159
and then there are a whole bunch of

00:03:12,400 --> 00:03:15,599
other really useful very powerful

00:03:14,159 --> 00:03:16,800
features to geode

00:03:15,599 --> 00:03:18,720
some of which i'm going to get to

00:03:16,800 --> 00:03:20,400
talking about here in a few minutes

00:03:18,720 --> 00:03:21,519
the majority of which i'm unfortunately

00:03:20,400 --> 00:03:24,000
not going to be able to fit into this

00:03:21,519 --> 00:03:26,239
presentation

00:03:24,000 --> 00:03:27,599
okay so we've talked about what geode is

00:03:26,239 --> 00:03:30,840
but that's only

00:03:27,599 --> 00:03:32,000
half the title of this talk so what is

00:03:30,840 --> 00:03:33,760
spring

00:03:32,000 --> 00:03:35,840
so spring is a java application

00:03:33,760 --> 00:03:37,680
framework that was originally

00:03:35,840 --> 00:03:39,519
created to make enterprise java

00:03:37,680 --> 00:03:40,640
development better it allowed you to

00:03:39,519 --> 00:03:43,920
deploy your app

00:03:40,640 --> 00:03:46,400
as a jar instead of a war file

00:03:43,920 --> 00:03:48,560
and allows you to run your application

00:03:46,400 --> 00:03:49,920
without an application server

00:03:48,560 --> 00:03:51,760
also provides a whole bunch of other

00:03:49,920 --> 00:03:53,840
useful utilities

00:03:51,760 --> 00:03:55,840
to make developing applications better

00:03:53,840 --> 00:03:57,120
and easier

00:03:55,840 --> 00:03:58,959
it's also an inversion of control

00:03:57,120 --> 00:04:00,879
container so one big

00:03:58,959 --> 00:04:02,959
feature of spring is dependency

00:04:00,879 --> 00:04:04,080
injection which is great for making your

00:04:02,959 --> 00:04:06,000
code more modular

00:04:04,080 --> 00:04:09,519
less tightly coupled more easily

00:04:06,000 --> 00:04:11,760
testable all very good things

00:04:09,519 --> 00:04:13,200
but more than just a framework spring is

00:04:11,760 --> 00:04:14,799
really an ecosystem

00:04:13,200 --> 00:04:16,239
of a bunch of related projects and

00:04:14,799 --> 00:04:17,280
related frameworks that kind of build

00:04:16,239 --> 00:04:20,239
off this core

00:04:17,280 --> 00:04:21,919
to provide a whole bunch of different

00:04:20,239 --> 00:04:25,360
different usefulness for different

00:04:21,919 --> 00:04:26,800
applications so

00:04:25,360 --> 00:04:28,479
we've talked about geode and we've

00:04:26,800 --> 00:04:30,479
talked about spring

00:04:28,479 --> 00:04:31,919
what do these two things have to do with

00:04:30,479 --> 00:04:33,840
each other

00:04:31,919 --> 00:04:35,600
so that ecosystem i talked about on the

00:04:33,840 --> 00:04:37,199
last slide at the core

00:04:35,600 --> 00:04:39,280
or the base however you want to picture

00:04:37,199 --> 00:04:40,080
the topology of that we have the spring

00:04:39,280 --> 00:04:41,520
framework

00:04:40,080 --> 00:04:43,360
and then off of that we have a bunch of

00:04:41,520 --> 00:04:44,479
different sub projects

00:04:43,360 --> 00:04:46,880
in this case we're going to be talking

00:04:44,479 --> 00:04:49,919
about two specifically spring data

00:04:46,880 --> 00:04:51,120
and spring boot so spring data makes it

00:04:49,919 --> 00:04:51,520
easier to work with different data

00:04:51,120 --> 00:04:53,600
stores

00:04:51,520 --> 00:04:55,040
provides an abstraction on top of them

00:04:53,600 --> 00:04:56,400
so that you can interact with

00:04:55,040 --> 00:04:58,080
any of your data stores whether it's a

00:04:56,400 --> 00:05:00,960
sql database or

00:04:58,080 --> 00:05:02,560
geode or some other nosql store you can

00:05:00,960 --> 00:05:04,960
interact with all of them in

00:05:02,560 --> 00:05:06,400
the same consistent way so you can

00:05:04,960 --> 00:05:07,680
switch out data storage without having

00:05:06,400 --> 00:05:08,800
to rewrite your whole app

00:05:07,680 --> 00:05:10,880
and you don't have to get into like all

00:05:08,800 --> 00:05:12,320
the nitty-gritty details of any specific

00:05:10,880 --> 00:05:15,039
store

00:05:12,320 --> 00:05:16,639
spring boot is a really powerful project

00:05:15,039 --> 00:05:18,720
it adds auto configuration

00:05:16,639 --> 00:05:20,479
on top of the spring framework what auto

00:05:18,720 --> 00:05:21,520
configuration does is it it'll

00:05:20,479 --> 00:05:23,919
automatically

00:05:21,520 --> 00:05:26,400
kind of like set defaults for you it'll

00:05:23,919 --> 00:05:28,080
take whatever configuration properties

00:05:26,400 --> 00:05:29,919
pick a sensible default that'll work for

00:05:28,080 --> 00:05:31,199
the majority case

00:05:29,919 --> 00:05:33,199
and just run with that so you don't have

00:05:31,199 --> 00:05:34,960
to explicitly set that

00:05:33,199 --> 00:05:36,400
so it'll allow you to write even less

00:05:34,960 --> 00:05:38,720
code than you would just using the

00:05:36,400 --> 00:05:40,240
spring framework

00:05:38,720 --> 00:05:42,080
now obviously if you're in the minority

00:05:40,240 --> 00:05:44,080
case there and you

00:05:42,080 --> 00:05:46,080
you don't want those default values you

00:05:44,080 --> 00:05:47,360
can override that auto configuration by

00:05:46,080 --> 00:05:48,639
just providing the explicit

00:05:47,360 --> 00:05:49,840
configuration

00:05:48,639 --> 00:05:52,000
just like you would with any other

00:05:49,840 --> 00:05:53,280
application but if it's not

00:05:52,000 --> 00:05:55,039
something you care about or if you are

00:05:53,280 --> 00:05:57,680
in that majority you don't have to worry

00:05:55,039 --> 00:06:00,160
about it which is great

00:05:57,680 --> 00:06:02,000
so under spring data we have spring data

00:06:00,160 --> 00:06:02,479
geode this is where the connection comes

00:06:02,000 --> 00:06:04,560
in

00:06:02,479 --> 00:06:05,520
so spring data geo just provides spring

00:06:04,560 --> 00:06:08,319
data support

00:06:05,520 --> 00:06:10,319
for geode allows you to interact with

00:06:08,319 --> 00:06:10,960
geode in that consistent abstracted way

00:06:10,319 --> 00:06:13,919
like i mentioned

00:06:10,960 --> 00:06:15,039
before and allows you to configure geode

00:06:13,919 --> 00:06:18,080
using

00:06:15,039 --> 00:06:19,759
springs springs annotations

00:06:18,080 --> 00:06:21,600
that's how you configure spring

00:06:19,759 --> 00:06:23,199
applications for the most part is via

00:06:21,600 --> 00:06:25,840
java annotations that i will show you

00:06:23,199 --> 00:06:26,639
later and now we're going to take it one

00:06:25,840 --> 00:06:29,360
step further

00:06:26,639 --> 00:06:31,280
with spring boot data geode this adds

00:06:29,360 --> 00:06:33,280
spring boots auto configuration

00:06:31,280 --> 00:06:35,919
on top of spring data geode which makes

00:06:33,280 --> 00:06:39,120
it even quicker and even easier

00:06:35,919 --> 00:06:40,800
to get off started writing geodapps

00:06:39,120 --> 00:06:42,319
which is great so this is the project

00:06:40,800 --> 00:06:43,120
that i'm going to be using for the rest

00:06:42,319 --> 00:06:44,240
of this talk

00:06:43,120 --> 00:06:46,880
this is what i'm going to be talking

00:06:44,240 --> 00:06:49,840
about so

00:06:46,880 --> 00:06:50,639
let's move on so now you might be

00:06:49,840 --> 00:06:52,479
thinking

00:06:50,639 --> 00:06:55,039
why spring like why does this project

00:06:52,479 --> 00:06:56,960
exist spring boot data geode

00:06:55,039 --> 00:06:58,319
why is that a thing why does geode want

00:06:56,960 --> 00:07:00,880
to be supported by spring

00:06:58,319 --> 00:07:02,400
why would you want to use spring in

00:07:00,880 --> 00:07:05,120
getting started with geode

00:07:02,400 --> 00:07:06,160
so there are a few reasons the first um

00:07:05,120 --> 00:07:08,240
the simplest reason

00:07:06,160 --> 00:07:10,160
really is that it it just makes

00:07:08,240 --> 00:07:11,919
developing geode applications easier

00:07:10,160 --> 00:07:13,599
it allows you to write less code

00:07:11,919 --> 00:07:14,240
configure less of the details on your

00:07:13,599 --> 00:07:15,599
own

00:07:14,240 --> 00:07:17,840
get up and running quicker without

00:07:15,599 --> 00:07:20,960
having to worry about um

00:07:17,840 --> 00:07:23,440
so many little things um

00:07:20,960 --> 00:07:24,800
and it's just a little less verbose than

00:07:23,440 --> 00:07:26,400
geod's native api

00:07:24,800 --> 00:07:28,240
and then of course it's portable if you

00:07:26,400 --> 00:07:28,720
ever needed to switch to some different

00:07:28,240 --> 00:07:31,840
store

00:07:28,720 --> 00:07:32,880
or something like that

00:07:31,840 --> 00:07:34,080
you don't have to re-architect

00:07:32,880 --> 00:07:35,120
everything because you've got the spring

00:07:34,080 --> 00:07:36,479
data abstractions

00:07:35,120 --> 00:07:39,520
so it's just a great way to architect

00:07:36,479 --> 00:07:41,199
your your app in the first place

00:07:39,520 --> 00:07:42,560
now this is really a reason of why geode

00:07:41,199 --> 00:07:45,599
would want to support

00:07:42,560 --> 00:07:48,879
this spring this project

00:07:45,599 --> 00:07:50,879
is spring has a really large user base

00:07:48,879 --> 00:07:53,360
some estimates would say something like

00:07:50,879 --> 00:07:55,120
60 of java developers use spring

00:07:53,360 --> 00:07:56,479
so obviously that's a lot of people and

00:07:55,120 --> 00:07:59,840
those people are going to want

00:07:56,479 --> 00:07:59,840
any data store they use

00:07:59,919 --> 00:08:03,840
to to support the spring data

00:08:02,319 --> 00:08:05,759
abstractions and to work in this

00:08:03,840 --> 00:08:06,960
spring environment the way they'd expect

00:08:05,759 --> 00:08:09,440
so obviously

00:08:06,960 --> 00:08:11,199
for that user base we want that to work

00:08:09,440 --> 00:08:14,000
for them

00:08:11,199 --> 00:08:15,280
and then this is really key building

00:08:14,000 --> 00:08:17,280
your geode application

00:08:15,280 --> 00:08:18,960
using spring boot data geode or spring

00:08:17,280 --> 00:08:21,280
data geode or any of those spring

00:08:18,960 --> 00:08:23,280
projects is going to enable a lot of the

00:08:21,280 --> 00:08:24,479
power of the broader spring ecosystem

00:08:23,280 --> 00:08:26,560
because there's a lot more to it than

00:08:24,479 --> 00:08:28,639
just spring data and spring boot

00:08:26,560 --> 00:08:30,960
there are projects that provide support

00:08:28,639 --> 00:08:32,159
for developing web applications tooling

00:08:30,960 --> 00:08:34,880
for microservices

00:08:32,159 --> 00:08:36,479
reactive programming security just to

00:08:34,880 --> 00:08:38,320
name a few there's a whole bunch of

00:08:36,479 --> 00:08:39,680
power of this system

00:08:38,320 --> 00:08:43,839
that you'll be able to just pull in at

00:08:39,680 --> 00:08:46,480
your fingertips um no problem

00:08:43,839 --> 00:08:47,120
so let's get started writing a basic

00:08:46,480 --> 00:08:50,959
geodap

00:08:47,120 --> 00:08:51,920
using spring so first things first we're

00:08:50,959 --> 00:08:54,320
going to need to pull in

00:08:51,920 --> 00:08:55,360
the dependency so this is my maven palm

00:08:54,320 --> 00:08:56,880
file

00:08:55,360 --> 00:08:58,959
you could use gradle in which case this

00:08:56,880 --> 00:09:00,080
would be your build.gradle but i'm using

00:08:58,959 --> 00:09:03,200
maven

00:09:00,080 --> 00:09:05,839
so down here in the dependencies section

00:09:03,200 --> 00:09:06,880
i've got this spring geode starter so

00:09:05,839 --> 00:09:07,600
that's the dependency you're going to

00:09:06,880 --> 00:09:09,519
want to pull in

00:09:07,600 --> 00:09:10,800
if you're trying to try to do this at

00:09:09,519 --> 00:09:12,240
home

00:09:10,800 --> 00:09:13,760
to get that's this is the dependency

00:09:12,240 --> 00:09:15,839
that's going to get you spring boot data

00:09:13,760 --> 00:09:18,800
geode

00:09:15,839 --> 00:09:18,800
pardon me just a second

00:09:20,640 --> 00:09:24,240
okay so we've got that now we're going

00:09:22,720 --> 00:09:25,440
to write our geode application

00:09:24,240 --> 00:09:27,040
first things first we're going to need

00:09:25,440 --> 00:09:28,560
something to store in geode we're going

00:09:27,040 --> 00:09:31,920
to need some kind of

00:09:28,560 --> 00:09:34,160
entity class to create instances of

00:09:31,920 --> 00:09:36,160
and store in geode so i've created this

00:09:34,160 --> 00:09:38,000
attendees class uh

00:09:36,160 --> 00:09:39,839
an attendee representing someone who's

00:09:38,000 --> 00:09:41,680
attending this conference

00:09:39,839 --> 00:09:43,519
so as you can see it's a pretty simple

00:09:41,680 --> 00:09:44,800
data class it's got three fields and an

00:09:43,519 --> 00:09:46,800
all args constructor

00:09:44,800 --> 00:09:48,560
it's just got an id first name last name

00:09:46,800 --> 00:09:50,640
and an overridden tostring just to make

00:09:48,560 --> 00:09:52,640
it prettier to print out

00:09:50,640 --> 00:09:55,040
but one thing you might notice is this

00:09:52,640 --> 00:09:57,279
at region annotation on the top

00:09:55,040 --> 00:09:58,399
so all that so this uh this annotation

00:09:57,279 --> 00:10:00,640
this is how spring

00:09:58,399 --> 00:10:02,399
is primarily configured via annotations

00:10:00,640 --> 00:10:04,880
like this

00:10:02,399 --> 00:10:08,000
and this is just telling spring that

00:10:04,880 --> 00:10:12,320
this attendees class is going to map to

00:10:08,000 --> 00:10:14,320
um the attendees region

00:10:12,320 --> 00:10:15,760
i'll get i'll talk more about that in a

00:10:14,320 --> 00:10:17,839
minute

00:10:15,760 --> 00:10:19,760
okay so now we've got a domain class we

00:10:17,839 --> 00:10:21,360
need a way to interact with geo to be

00:10:19,760 --> 00:10:24,399
able to store and retrieve

00:10:21,360 --> 00:10:26,079
uh instances of that that class so

00:10:24,399 --> 00:10:27,920
we're going to create what's called a

00:10:26,079 --> 00:10:30,160
repository now this is

00:10:27,920 --> 00:10:30,959
a spring data abstraction that spring

00:10:30,160 --> 00:10:32,720
data supports

00:10:30,959 --> 00:10:34,880
repositories like this for a whole bunch

00:10:32,720 --> 00:10:36,399
of different data stores

00:10:34,880 --> 00:10:37,519
so we're going to create an interface

00:10:36,399 --> 00:10:38,640
i'm going to call it attendees

00:10:37,519 --> 00:10:39,839
repository

00:10:38,640 --> 00:10:43,680
and we're going to extend crud

00:10:39,839 --> 00:10:45,360
repository which is a spring class

00:10:43,680 --> 00:10:47,279
and we're going to parameterize it with

00:10:45,360 --> 00:10:48,480
attendee and long so attendee is going

00:10:47,279 --> 00:10:50,399
to be our value type

00:10:48,480 --> 00:10:52,160
in our region and long is going to be

00:10:50,399 --> 00:10:53,519
our key type

00:10:52,160 --> 00:10:55,920
and that's all we have to do here we

00:10:53,519 --> 00:10:57,760
don't have to implement this interface

00:10:55,920 --> 00:10:59,440
we don't have to add any methods to it

00:10:57,760 --> 00:11:00,560
just by virtue of extending that cred

00:10:59,440 --> 00:11:03,200
repository

00:11:00,560 --> 00:11:05,279
we're going to get a bunch of basic data

00:11:03,200 --> 00:11:09,519
access operations to be able to

00:11:05,279 --> 00:11:09,519
put and get data out of geode

00:11:09,680 --> 00:11:14,160
so let's put this to work this is our

00:11:12,399 --> 00:11:15,440
main application class here

00:11:14,160 --> 00:11:17,839
up at the top you're going to see more

00:11:15,440 --> 00:11:19,680
annotations again this is how

00:11:17,839 --> 00:11:22,160
this is how spring is configured so this

00:11:19,680 --> 00:11:24,880
is this is the bulk of our configuration

00:11:22,160 --> 00:11:26,079
in this application so at spring boot

00:11:24,880 --> 00:11:28,240
application at the top

00:11:26,079 --> 00:11:29,680
that's not specific to geode that's just

00:11:28,240 --> 00:11:31,440
spring boot just telling it this is

00:11:29,680 --> 00:11:33,440
going to be a spring boot application

00:11:31,440 --> 00:11:35,760
enable auto configuration enable all

00:11:33,440 --> 00:11:38,320
that other spring boot power

00:11:35,760 --> 00:11:40,800
um at entity defined regions is the next

00:11:38,320 --> 00:11:42,000
one that's really powerful so

00:11:40,800 --> 00:11:43,519
that's going to go look at our entity

00:11:42,000 --> 00:11:44,880
class and look at that at region

00:11:43,519 --> 00:11:46,959
annotation

00:11:44,880 --> 00:11:49,040
that i showed you before and it's going

00:11:46,959 --> 00:11:49,440
to say oh we're going to need a region

00:11:49,040 --> 00:11:52,160
called

00:11:49,440 --> 00:11:54,160
attendees for this attendee class so

00:11:52,160 --> 00:11:56,399
i'll go automatically create that now

00:11:54,160 --> 00:11:58,880
we don't have to configure that it's

00:11:56,399 --> 00:12:01,200
just done for us which is great

00:11:58,880 --> 00:12:03,200
this next annotation enable cluster

00:12:01,200 --> 00:12:04,800
configuration again very powerful

00:12:03,200 --> 00:12:06,639
so this is going to allow our client to

00:12:04,800 --> 00:12:09,839
push its configuration

00:12:06,639 --> 00:12:11,600
up to the geode cluster so that region

00:12:09,839 --> 00:12:12,880
that's automatically being created for

00:12:11,600 --> 00:12:15,279
us

00:12:12,880 --> 00:12:16,320
is then going to also be created on the

00:12:15,279 --> 00:12:17,680
server side so we don't have to

00:12:16,320 --> 00:12:19,120
configure it on the client we don't have

00:12:17,680 --> 00:12:20,480
to configure it on the server spring's

00:12:19,120 --> 00:12:22,639
just going to look at our

00:12:20,480 --> 00:12:24,720
attendee class and set all of that up

00:12:22,639 --> 00:12:26,800
for us

00:12:24,720 --> 00:12:28,240
down here like all java applications

00:12:26,800 --> 00:12:30,760
we've got a main

00:12:28,240 --> 00:12:32,160
now our main is very simple

00:12:30,760 --> 00:12:33,440
springapplication.run

00:12:32,160 --> 00:12:35,200
and then we're handing it our

00:12:33,440 --> 00:12:36,800
application class so this is just going

00:12:35,200 --> 00:12:38,240
to start a spring application

00:12:36,800 --> 00:12:39,920
and tell it that this class is where it

00:12:38,240 --> 00:12:44,079
can find its configuration to go

00:12:39,920 --> 00:12:45,440
set itself up pretty simple down here

00:12:44,079 --> 00:12:47,279
is where it gets interesting we've got

00:12:45,440 --> 00:12:49,279
this application runner

00:12:47,279 --> 00:12:51,120
and we've got it annotated with at bean

00:12:49,279 --> 00:12:52,240
so what at bean does is it's going to

00:12:51,120 --> 00:12:55,200
register it

00:12:52,240 --> 00:12:56,720
in the spring context so that when the

00:12:55,200 --> 00:12:59,360
spring application starts up

00:12:56,720 --> 00:13:02,720
it's going to create all of these beans

00:12:59,360 --> 00:13:04,680
anything annotated with at bean

00:13:02,720 --> 00:13:05,839
and in this case when we call that

00:13:04,680 --> 00:13:07,920
springapplication.run

00:13:05,839 --> 00:13:08,959
it's going to go look for anything of

00:13:07,920 --> 00:13:10,720
type runner

00:13:08,959 --> 00:13:12,240
application runner there's some other

00:13:10,720 --> 00:13:13,279
kinds of runners it's going to go look

00:13:12,240 --> 00:13:15,200
for all of those

00:13:13,279 --> 00:13:17,839
create them and then run them so

00:13:15,200 --> 00:13:19,040
anything we put in this lambda here

00:13:17,839 --> 00:13:22,000
that's what's going to happen so this

00:13:19,040 --> 00:13:23,600
basically becomes our new main

00:13:22,000 --> 00:13:26,320
now if you look here at the arguments

00:13:23,600 --> 00:13:28,240
list for our runner

00:13:26,320 --> 00:13:29,519
we've got that attendees repository that

00:13:28,240 --> 00:13:31,680
created before

00:13:29,519 --> 00:13:33,519
we don't have to pass this in anywhere

00:13:31,680 --> 00:13:35,680
this is spring's dependency injection

00:13:33,519 --> 00:13:37,519
that i talked about a few slides back

00:13:35,680 --> 00:13:38,800
um when spring creates this application

00:13:37,519 --> 00:13:40,079
runner it's going to inject that

00:13:38,800 --> 00:13:41,279
repository in here

00:13:40,079 --> 00:13:42,800
so we don't have to create this

00:13:41,279 --> 00:13:44,639
explicitly we don't have to pass it in

00:13:42,800 --> 00:13:47,519
we don't have to create the repository

00:13:44,639 --> 00:13:50,000
that's all just taken care of for us and

00:13:47,519 --> 00:13:52,560
and wired in so we can use it

00:13:50,000 --> 00:13:53,360
so let's get to the business logic so in

00:13:52,560 --> 00:13:54,399
here we're just

00:13:53,360 --> 00:13:56,639
very simple we're going to create an

00:13:54,399 --> 00:13:58,079
attendee calling him jack black giving

00:13:56,639 --> 00:14:00,160
him an id of one

00:13:58,079 --> 00:14:02,720
uh i imagine jack black unfortunately is

00:14:00,160 --> 00:14:05,760
probably not attending this talk

00:14:02,720 --> 00:14:07,360
but that would be cool then down here

00:14:05,760 --> 00:14:07,839
we're going to use that repository that

00:14:07,360 --> 00:14:09,760
we're

00:14:07,839 --> 00:14:11,120
dependency injecting in and we're going

00:14:09,760 --> 00:14:14,399
to save

00:14:11,120 --> 00:14:17,040
mr jack black to geode and then

00:14:14,399 --> 00:14:18,720
we're going to do repository by id

00:14:17,040 --> 00:14:19,680
passing in the id that we created him

00:14:18,720 --> 00:14:21,360
with

00:14:19,680 --> 00:14:22,880
and it's going to go find him and return

00:14:21,360 --> 00:14:24,880
him to us

00:14:22,880 --> 00:14:27,040
um so that's that's all the code for

00:14:24,880 --> 00:14:30,240
this basic application so let's

00:14:27,040 --> 00:14:31,440
let's run this but before we can run it

00:14:30,240 --> 00:14:32,880
we're going to need to start a geode

00:14:31,440 --> 00:14:33,760
cluster and there's a couple ways to do

00:14:32,880 --> 00:14:34,880
that

00:14:33,760 --> 00:14:36,079
the first way i'm going to show you to

00:14:34,880 --> 00:14:36,800
do that is through this tool called

00:14:36,079 --> 00:14:38,880
gfish

00:14:36,800 --> 00:14:40,880
which is a cool shell utility for

00:14:38,880 --> 00:14:44,079
starting stopping and managing

00:14:40,880 --> 00:14:44,800
your geode clusters so first command

00:14:44,079 --> 00:14:47,199
we're gonna

00:14:44,800 --> 00:14:48,720
um we're gonna issue once we've got this

00:14:47,199 --> 00:14:50,959
opened up uh gfish will come with your

00:14:48,720 --> 00:14:52,639
installation of geode by the way

00:14:50,959 --> 00:14:54,320
um so once we've got this opened up

00:14:52,639 --> 00:14:56,560
we're gonna do start locator

00:14:54,320 --> 00:14:59,279
so a locator is another kind of member

00:14:56,560 --> 00:15:01,199
like a server but it doesn't store data

00:14:59,279 --> 00:15:02,399
it's mostly there for like service

00:15:01,199 --> 00:15:04,560
discovery so that

00:15:02,399 --> 00:15:06,079
client connecting can connect to the

00:15:04,560 --> 00:15:07,760
correct server

00:15:06,079 --> 00:15:09,440
um maybe the server that has

00:15:07,760 --> 00:15:10,880
specifically the piece of data that it's

00:15:09,440 --> 00:15:12,800
wanting

00:15:10,880 --> 00:15:14,880
for our case because what we're doing is

00:15:12,800 --> 00:15:15,920
so simple we don't technically need a

00:15:14,880 --> 00:15:18,399
locator

00:15:15,920 --> 00:15:19,760
but i'm going to start one anyway and

00:15:18,399 --> 00:15:21,040
then after that starts up we're going to

00:15:19,760 --> 00:15:22,560
do start server

00:15:21,040 --> 00:15:24,320
this server is where our data is going

00:15:22,560 --> 00:15:27,760
to actually live this is going to host

00:15:24,320 --> 00:15:28,720
our attendees region the other way to

00:15:27,760 --> 00:15:32,160
start

00:15:28,720 --> 00:15:33,680
uh geod server is through spring

00:15:32,160 --> 00:15:36,720
so just like we had a spring boot

00:15:33,680 --> 00:15:39,519
application uh to be our geode client

00:15:36,720 --> 00:15:40,000
we can also have one to be a geod server

00:15:39,519 --> 00:15:41,519
so

00:15:40,000 --> 00:15:43,040
this is going to look very similar from

00:15:41,519 --> 00:15:45,040
before except a lot shorter

00:15:43,040 --> 00:15:46,320
we've got the spring boot application

00:15:45,040 --> 00:15:48,000
annotation on top

00:15:46,320 --> 00:15:49,519
our main looks virtually identical to

00:15:48,000 --> 00:15:52,160
the client the difference

00:15:49,519 --> 00:15:53,680
is this annotation at cache server

00:15:52,160 --> 00:15:55,120
application which is just going to tell

00:15:53,680 --> 00:15:57,120
spring that this

00:15:55,120 --> 00:15:59,600
that this app is supposed to be a server

00:15:57,120 --> 00:16:01,040
so it'll create that accordingly

00:15:59,600 --> 00:16:02,320
so then once you've got either that

00:16:01,040 --> 00:16:03,680
started up or you've started it through

00:16:02,320 --> 00:16:05,600
gfish whichever

00:16:03,680 --> 00:16:07,120
you've got your cluster up and running

00:16:05,600 --> 00:16:12,160
let's oops

00:16:07,120 --> 00:16:12,160
let's run the application

00:16:13,680 --> 00:16:17,120
it's not auto playing for me

00:16:18,639 --> 00:16:23,839
okay so it's starting up we're saving

00:16:21,920 --> 00:16:26,959
jack black with id one

00:16:23,839 --> 00:16:28,480
and we've retrieved jack black for id

00:16:26,959 --> 00:16:31,199
one looks like the same guy so

00:16:28,480 --> 00:16:32,480
there it is very little code and we've

00:16:31,199 --> 00:16:35,040
done very basic

00:16:32,480 --> 00:16:37,040
put and get but you're probably going to

00:16:35,040 --> 00:16:40,639
want more advanced

00:16:37,040 --> 00:16:44,240
ways to access data than just put for id

00:16:40,639 --> 00:16:45,040
get for id so you can actually do a lot

00:16:44,240 --> 00:16:48,079
more with

00:16:45,040 --> 00:16:49,600
that repository than what we did so you

00:16:48,079 --> 00:16:51,920
can add

00:16:49,600 --> 00:16:53,839
you can add more methods like this we've

00:16:51,920 --> 00:16:55,199
got find all by last name

00:16:53,839 --> 00:16:56,560
it's going to return a list of attendee

00:16:55,199 --> 00:16:58,399
and it's going to take a string

00:16:56,560 --> 00:17:01,600
representing the last name

00:16:58,399 --> 00:17:04,000
now notice there's still no body to this

00:17:01,600 --> 00:17:04,799
so by following this naming convention

00:17:04,000 --> 00:17:06,799
find

00:17:04,799 --> 00:17:08,079
okay that's going to go get it's going

00:17:06,799 --> 00:17:09,520
to go get our data

00:17:08,079 --> 00:17:11,120
all that's telling it that we want all

00:17:09,520 --> 00:17:11,760
of them we want a list rather than just

00:17:11,120 --> 00:17:13,439
one

00:17:11,760 --> 00:17:15,199
by last name that's telling it a field

00:17:13,439 --> 00:17:16,559
that we want to match this naming

00:17:15,199 --> 00:17:18,880
convention is essentially

00:17:16,559 --> 00:17:20,559
kind of like a query language so if we

00:17:18,880 --> 00:17:22,319
name our methods accordingly

00:17:20,559 --> 00:17:25,679
spring will just figure out what we want

00:17:22,319 --> 00:17:27,600
and it's going to implement that for us

00:17:25,679 --> 00:17:29,520
which is really awesome really powerful

00:17:27,600 --> 00:17:31,840
and you can do more complicated things

00:17:29,520 --> 00:17:32,960
than just matching a single field like

00:17:31,840 --> 00:17:35,360
down here

00:17:32,960 --> 00:17:37,360
find all by first name starts with and

00:17:35,360 --> 00:17:39,039
then we pass in a substring that'll be

00:17:37,360 --> 00:17:41,039
the start of the first name and it'll

00:17:39,039 --> 00:17:43,360
return all attendees whose

00:17:41,039 --> 00:17:44,960
first name field starts with this

00:17:43,360 --> 00:17:47,360
substring

00:17:44,960 --> 00:17:49,120
this is very powerful because you can

00:17:47,360 --> 00:17:50,799
get a whole bunch of pretty advanced

00:17:49,120 --> 00:17:52,480
data access without having to write

00:17:50,799 --> 00:17:55,120
really any code

00:17:52,480 --> 00:17:57,039
um and this this can do a whole bunch of

00:17:55,120 --> 00:17:58,799
things more than i'm showcasing here

00:17:57,039 --> 00:18:01,120
but let's say you get into a scenario

00:17:58,799 --> 00:18:03,360
where you can't represent what you

00:18:01,120 --> 00:18:04,559
what you want the kind of query you want

00:18:03,360 --> 00:18:06,799
in this language

00:18:04,559 --> 00:18:08,799
so you can actually supply a custom

00:18:06,799 --> 00:18:11,840
query like i'm doing down here

00:18:08,799 --> 00:18:14,720
i've got this find all by id not

00:18:11,840 --> 00:18:16,080
using query and then it takes an id and

00:18:14,720 --> 00:18:18,559
returns a list of attendees

00:18:16,080 --> 00:18:19,360
so it's going to find everything all

00:18:18,559 --> 00:18:21,440
attendees that

00:18:19,360 --> 00:18:24,160
don't have that id that we're passing it

00:18:21,440 --> 00:18:25,280
now if i took off that using query

00:18:24,160 --> 00:18:28,080
spring would actually know what this

00:18:25,280 --> 00:18:30,080
means and be able to interpret that

00:18:28,080 --> 00:18:31,760
so i'm just messing up that naming

00:18:30,080 --> 00:18:34,160
convention for demonstration sake so i

00:18:31,760 --> 00:18:36,400
can provide my own query

00:18:34,160 --> 00:18:38,320
so the way we do that is through that at

00:18:36,400 --> 00:18:40,880
query annotation that you see

00:18:38,320 --> 00:18:42,160
up top there select star from attendees

00:18:40,880 --> 00:18:44,480
a where a dot id

00:18:42,160 --> 00:18:46,000
doesn't equal dollar sign one so dollar

00:18:44,480 --> 00:18:47,280
sign one is just referring to that id

00:18:46,000 --> 00:18:48,480
that we're passing in

00:18:47,280 --> 00:18:50,799
if we were passing in multiple

00:18:48,480 --> 00:18:52,320
parameters we could have dollar sign one

00:18:50,799 --> 00:18:53,520
dollar sign two dollar sign three to

00:18:52,320 --> 00:18:56,000
refer to

00:18:53,520 --> 00:18:58,880
the other parameters um as you go along

00:18:56,000 --> 00:18:58,880
but we've just got one

00:18:59,200 --> 00:19:02,320
so yeah that's it you provide that query

00:19:01,840 --> 00:19:03,760
and then

00:19:02,320 --> 00:19:06,160
when that method is called it's going to

00:19:03,760 --> 00:19:08,720
issue that query against geod

00:19:06,160 --> 00:19:09,600
so this query looks like sql but it's

00:19:08,720 --> 00:19:12,000
not

00:19:09,600 --> 00:19:14,080
it's oql object query language which is

00:19:12,000 --> 00:19:16,400
what geode uses for queries

00:19:14,080 --> 00:19:17,760
it is very similar to sql but it is not

00:19:16,400 --> 00:19:21,520
sql so just

00:19:17,760 --> 00:19:23,600
be aware of that so now that we've added

00:19:21,520 --> 00:19:25,440
these new methods to a repository let's

00:19:23,600 --> 00:19:28,240
make use of them

00:19:25,440 --> 00:19:31,039
so this is our applica excuse me our

00:19:28,240 --> 00:19:33,520
updated application runner

00:19:31,039 --> 00:19:34,400
so now we are creating three different

00:19:33,520 --> 00:19:36,559
attendees

00:19:34,400 --> 00:19:38,880
we're creating still jack black emily

00:19:36,559 --> 00:19:41,039
black and janet lee and we're saving all

00:19:38,880 --> 00:19:43,120
of them to the repository

00:19:41,039 --> 00:19:44,559
then down here we're going to do find

00:19:43,120 --> 00:19:46,720
all by last name black

00:19:44,559 --> 00:19:49,600
so we'd be expecting this to return us

00:19:46,720 --> 00:19:52,720
jack black and emily black

00:19:49,600 --> 00:19:55,039
then find all by first name starts with

00:19:52,720 --> 00:19:56,880
j so we'd be expecting jack black and

00:19:55,039 --> 00:19:58,799
janet lee

00:19:56,880 --> 00:20:01,520
and then down here we're doing find all

00:19:58,799 --> 00:20:03,760
by id not using query passing in

00:20:01,520 --> 00:20:05,280
one which is jack black's id so we would

00:20:03,760 --> 00:20:08,320
be expecting it to find

00:20:05,280 --> 00:20:11,600
emily black and janet lee so

00:20:08,320 --> 00:20:11,600
let's give this a shot

00:20:14,080 --> 00:20:19,520
starting up and

00:20:17,200 --> 00:20:22,400
there we've got it for last name black

00:20:19,520 --> 00:20:24,320
we've got emily black and jack black

00:20:22,400 --> 00:20:26,159
uh for all attendees with the first name

00:20:24,320 --> 00:20:26,880
starting with jay janet lee and jack

00:20:26,159 --> 00:20:28,240
black

00:20:26,880 --> 00:20:30,159
and then for all attendees that don't

00:20:28,240 --> 00:20:32,080
have the id one we've got

00:20:30,159 --> 00:20:33,520
emily black and janet lee just like we'd

00:20:32,080 --> 00:20:36,159
expect so

00:20:33,520 --> 00:20:37,200
awesome right there wrote basically no

00:20:36,159 --> 00:20:40,000
code

00:20:37,200 --> 00:20:42,240
got those new data access methods super

00:20:40,000 --> 00:20:42,240
cool

00:20:42,559 --> 00:20:47,440
but so far all that i've showed you is

00:20:45,120 --> 00:20:49,440
repository stuff which is actually

00:20:47,440 --> 00:20:50,880
spring data features it's not geode

00:20:49,440 --> 00:20:52,720
specific so

00:20:50,880 --> 00:20:55,440
let's go talk about some more geode

00:20:52,720 --> 00:20:56,799
specific features

00:20:55,440 --> 00:20:58,240
so what i'm going to talk about first

00:20:56,799 --> 00:20:59,120
i'm going to talk about continuous

00:20:58,240 --> 00:21:00,799
queries

00:20:59,120 --> 00:21:02,640
it's like a query but instead of just

00:21:00,799 --> 00:21:03,120
being fired once and returning a result

00:21:02,640 --> 00:21:05,120
set

00:21:03,120 --> 00:21:08,080
it's going to constantly update so every

00:21:05,120 --> 00:21:09,919
time something changes on the region

00:21:08,080 --> 00:21:12,080
that would change the results of that

00:21:09,919 --> 00:21:13,840
query it's going to go send over the new

00:21:12,080 --> 00:21:15,679
results

00:21:13,840 --> 00:21:16,960
so to do this we're going to start by

00:21:15,679 --> 00:21:19,280
adding a new annotation

00:21:16,960 --> 00:21:21,360
client cache application and then set

00:21:19,280 --> 00:21:23,280
subscription enabled equal to true

00:21:21,360 --> 00:21:24,799
subscription enabled is just a property

00:21:23,280 --> 00:21:27,120
that we can set within this annotation

00:21:24,799 --> 00:21:29,360
for configuration sake

00:21:27,120 --> 00:21:30,240
so this annotation the client cache

00:21:29,360 --> 00:21:31,760
application

00:21:30,240 --> 00:21:34,000
is something that was previously being

00:21:31,760 --> 00:21:37,200
automatically configured for us

00:21:34,000 --> 00:21:39,600
by spring boot however

00:21:37,200 --> 00:21:40,720
that subscription enabled uh defaults to

00:21:39,600 --> 00:21:42,080
being false

00:21:40,720 --> 00:21:44,240
and we want it to be true in this case

00:21:42,080 --> 00:21:47,360
because we need to like subscribe

00:21:44,240 --> 00:21:49,679
our query to the server

00:21:47,360 --> 00:21:50,640
so we're going to override that auto

00:21:49,679 --> 00:21:52,000
configuration

00:21:50,640 --> 00:21:54,080
by supplying that annotation

00:21:52,000 --> 00:21:56,400
specifically and setting the property as

00:21:54,080 --> 00:21:58,400
we want it

00:21:56,400 --> 00:22:00,000
now down here we actually create our

00:21:58,400 --> 00:22:01,120
continuous query on this method that

00:22:00,000 --> 00:22:03,360
we've annotated with

00:22:01,120 --> 00:22:04,720
at continuous query we give it a name

00:22:03,360 --> 00:22:06,880
and we give it a query

00:22:04,720 --> 00:22:08,400
very simple query just select star from

00:22:06,880 --> 00:22:10,000
attendees so it's going to go get

00:22:08,400 --> 00:22:12,240
everything in the region so that anytime

00:22:10,000 --> 00:22:13,520
anything new is added to that region

00:22:12,240 --> 00:22:15,360
we're going to get that new updated

00:22:13,520 --> 00:22:17,280
value and this method is going to be

00:22:15,360 --> 00:22:19,039
called

00:22:17,280 --> 00:22:20,640
so in this method very simple we're just

00:22:19,039 --> 00:22:22,240
we're getting the cq event

00:22:20,640 --> 00:22:24,159
which is going to contain a bunch of

00:22:22,240 --> 00:22:25,679
information the new value

00:22:24,159 --> 00:22:27,360
bunch of other stuff we're just using it

00:22:25,679 --> 00:22:28,720
for the new value and we're just going

00:22:27,360 --> 00:22:31,039
to print out that new value saying that

00:22:28,720 --> 00:22:32,880
we found it

00:22:31,039 --> 00:22:35,280
so up here in our runner we're now going

00:22:32,880 --> 00:22:37,200
to be creating six attendees

00:22:35,280 --> 00:22:39,360
um in a list and then we're going to

00:22:37,200 --> 00:22:41,440
iterate over that list

00:22:39,360 --> 00:22:43,280
and save them one by one with a two

00:22:41,440 --> 00:22:44,640
second delay between each

00:22:43,280 --> 00:22:46,960
so we should be able to see the

00:22:44,640 --> 00:22:49,200
application uh

00:22:46,960 --> 00:22:51,120
insert a new attendee and then see our

00:22:49,200 --> 00:22:52,799
continuous query update getting that new

00:22:51,120 --> 00:22:55,360
value

00:22:52,799 --> 00:22:57,120
now normally you might want to do this

00:22:55,360 --> 00:23:00,240
in separate applications

00:22:57,120 --> 00:23:02,480
because it's not terribly useful to be

00:23:00,240 --> 00:23:04,559
putting data into a into a region just

00:23:02,480 --> 00:23:05,760
to be getting it from a continuous query

00:23:04,559 --> 00:23:07,360
you could just

00:23:05,760 --> 00:23:09,039
call that method yourself when you're

00:23:07,360 --> 00:23:10,559
when you're inserting this value

00:23:09,039 --> 00:23:12,559
you might want a separate application to

00:23:10,559 --> 00:23:14,480
be getting updates when some other

00:23:12,559 --> 00:23:16,240
applications update the region

00:23:14,480 --> 00:23:17,919
but in this case just for demonstration

00:23:16,240 --> 00:23:19,919
sake it's easier to just show

00:23:17,919 --> 00:23:22,000
a single application running and we

00:23:19,919 --> 00:23:23,679
should see the interleaving of the

00:23:22,000 --> 00:23:26,480
attendee being added to the region

00:23:23,679 --> 00:23:27,760
and our cq firing so that's all we need

00:23:26,480 --> 00:23:37,840
to change to get this

00:23:27,760 --> 00:23:37,840
running so let's run it

00:23:39,440 --> 00:23:42,960
and there it is we've saved jack black

00:23:41,279 --> 00:23:45,279
and it found jack black we've saved

00:23:42,960 --> 00:23:46,880
emily black and it found emily black

00:23:45,279 --> 00:23:48,880
and you can see it doing that for all

00:23:46,880 --> 00:23:50,559
the rest of them it's updated

00:23:48,880 --> 00:23:52,320
after every time which is exactly what

00:23:50,559 --> 00:23:55,360
we would expect

00:23:52,320 --> 00:23:56,480
awesome the next feature we're going to

00:23:55,360 --> 00:23:57,360
talk about we're going to talk about

00:23:56,480 --> 00:23:58,960
functions

00:23:57,360 --> 00:24:00,559
so this is a really cool thing that

00:23:58,960 --> 00:24:03,039
geode provides geode lets you

00:24:00,559 --> 00:24:05,120
register a custom function on the server

00:24:03,039 --> 00:24:08,000
side so you can process data

00:24:05,120 --> 00:24:10,720
where the data lives you don't have to

00:24:08,000 --> 00:24:12,400
go send all of your data across the wire

00:24:10,720 --> 00:24:13,919
just to process it to get like an

00:24:12,400 --> 00:24:14,320
integer value out of it or something

00:24:13,919 --> 00:24:16,159
because

00:24:14,320 --> 00:24:18,480
if you have a large data set that can be

00:24:16,159 --> 00:24:20,799
very expensive to have to go retrieve

00:24:18,480 --> 00:24:21,679
you know terabytes of data just to

00:24:20,799 --> 00:24:23,279
process it

00:24:21,679 --> 00:24:25,600
so if you can go process it where your

00:24:23,279 --> 00:24:27,760
data lives awesome

00:24:25,600 --> 00:24:29,600
now if you've started your server in the

00:24:27,760 --> 00:24:31,440
spring way that i showed you before

00:24:29,600 --> 00:24:32,720
it's really really easy to register a

00:24:31,440 --> 00:24:33,919
function with just a couple of

00:24:32,720 --> 00:24:35,360
annotations

00:24:33,919 --> 00:24:37,360
if you didn't and you started your

00:24:35,360 --> 00:24:38,880
cluster with gfish you can still totally

00:24:37,360 --> 00:24:40,000
use this function feature

00:24:38,880 --> 00:24:42,480
you're just going to build your function

00:24:40,000 --> 00:24:44,320
into a jar and deploy it using a gfish

00:24:42,480 --> 00:24:46,240
command

00:24:44,320 --> 00:24:48,880
still very simple but i'm going to show

00:24:46,240 --> 00:24:51,200
you the spring way to do this

00:24:48,880 --> 00:24:52,480
so in that server application that we

00:24:51,200 --> 00:24:53,679
wrote earlier

00:24:52,480 --> 00:24:56,400
we're going to start by adding a new

00:24:53,679 --> 00:24:58,159
annotation enable gemfire functions

00:24:56,400 --> 00:25:00,320
so gemfire is just another name for

00:24:58,159 --> 00:25:02,000
geode it's the name the geode was under

00:25:00,320 --> 00:25:02,880
before it was open sourced and it's the

00:25:02,000 --> 00:25:04,880
name of

00:25:02,880 --> 00:25:06,080
a commercial offering but for this

00:25:04,880 --> 00:25:08,000
purpose you can just

00:25:06,080 --> 00:25:09,520
pretend that that says geode and then

00:25:08,000 --> 00:25:11,120
it's pretty self-explanatory it's just

00:25:09,520 --> 00:25:12,400
enabling geode functions it's going to

00:25:11,120 --> 00:25:16,320
enable us to go

00:25:12,400 --> 00:25:17,840
and register functions on the server

00:25:16,320 --> 00:25:19,120
and down here this is where we're

00:25:17,840 --> 00:25:20,400
actually creating the function we're

00:25:19,120 --> 00:25:22,080
giving it an id

00:25:20,400 --> 00:25:24,080
calculate average first name length

00:25:22,080 --> 00:25:26,080
which is just the same as the name of

00:25:24,080 --> 00:25:27,600
the function this id is just so that we

00:25:26,080 --> 00:25:28,559
have a way to refer to it on the client

00:25:27,600 --> 00:25:31,520
side so we can

00:25:28,559 --> 00:25:33,360
call this function specifically and then

00:25:31,520 --> 00:25:34,240
we're setting the has result property to

00:25:33,360 --> 00:25:36,400
true

00:25:34,240 --> 00:25:37,840
it defaults to false because you can

00:25:36,400 --> 00:25:38,480
avoid methods you could just do some

00:25:37,840 --> 00:25:39,760
kind of mass

00:25:38,480 --> 00:25:41,679
update across your data you don't need

00:25:39,760 --> 00:25:42,720
to return a result but in this case we

00:25:41,679 --> 00:25:44,159
are going to return a result we're going

00:25:42,720 --> 00:25:45,440
to return the average number of

00:25:44,159 --> 00:25:48,400
characters

00:25:45,440 --> 00:25:48,799
in uh all of our attendees first names

00:25:48,400 --> 00:25:51,279
so

00:25:48,799 --> 00:25:52,720
in this function here we would just put

00:25:51,279 --> 00:25:54,840
all of the logic for that and just

00:25:52,720 --> 00:25:56,720
return a result just like a normal

00:25:54,840 --> 00:25:58,640
function

00:25:56,720 --> 00:26:01,200
if you look at the arguments list of

00:25:58,640 --> 00:26:04,480
that function we've got this region data

00:26:01,200 --> 00:26:06,159
map and it's indicated with outreach and

00:26:04,480 --> 00:26:08,320
data so this is going to represent the

00:26:06,159 --> 00:26:11,039
contents of that region because a region

00:26:08,320 --> 00:26:12,320
is a key value store much like a map so

00:26:11,039 --> 00:26:13,840
this is how we're going to interact with

00:26:12,320 --> 00:26:14,799
those values to be able to process them

00:26:13,840 --> 00:26:17,679
in our function

00:26:14,799 --> 00:26:18,720
and the at region data annotation just

00:26:17,679 --> 00:26:20,400
tells spring

00:26:18,720 --> 00:26:22,080
that this data is something that isn't

00:26:20,400 --> 00:26:23,360
going to be explicitly passed in

00:26:22,080 --> 00:26:25,600
but something that's just going to be

00:26:23,360 --> 00:26:26,799
pulled from um

00:26:25,600 --> 00:26:28,799
that's just going to be pulled from our

00:26:26,799 --> 00:26:31,840
region so we can use it

00:26:28,799 --> 00:26:33,520
if you wanted to add more um

00:26:31,840 --> 00:26:35,120
if you wanted to add more parameters

00:26:33,520 --> 00:26:36,480
here you would just add them to the list

00:26:35,120 --> 00:26:37,919
and not annotate them with that region

00:26:36,480 --> 00:26:39,120
data or if you didn't need the region

00:26:37,919 --> 00:26:41,279
data you would just

00:26:39,120 --> 00:26:42,720
omit that and add whatever parameters

00:26:41,279 --> 00:26:44,559
you need

00:26:42,720 --> 00:26:45,840
so that's it for the server side it's

00:26:44,559 --> 00:26:47,039
just that simple just writing the

00:26:45,840 --> 00:26:49,039
function and adding those two

00:26:47,039 --> 00:26:51,840
annotations

00:26:49,039 --> 00:26:53,120
so now we need to to call this on the

00:26:51,840 --> 00:26:56,240
client side

00:26:53,120 --> 00:26:57,520
so we're going to create an interface uh

00:26:56,240 --> 00:26:59,840
we're going to call it attendee function

00:26:57,520 --> 00:27:00,480
executions plural executions because we

00:26:59,840 --> 00:27:02,960
could have

00:27:00,480 --> 00:27:04,559
multiple functions in this but we just

00:27:02,960 --> 00:27:06,320
have one right now

00:27:04,559 --> 00:27:08,000
so we're going to annotate it with on

00:27:06,320 --> 00:27:09,360
region and tell attendees that just

00:27:08,000 --> 00:27:10,799
tells spring

00:27:09,360 --> 00:27:13,279
what region this function is going to

00:27:10,799 --> 00:27:14,720
operate on

00:27:13,279 --> 00:27:16,159
and then down here we define the

00:27:14,720 --> 00:27:17,840
interface for the function just giving

00:27:16,159 --> 00:27:20,559
it the return value the name

00:27:17,840 --> 00:27:21,520
the arguments list excluding the region

00:27:20,559 --> 00:27:23,919
data field

00:27:21,520 --> 00:27:25,520
so in this case no arguments and then

00:27:23,919 --> 00:27:27,600
annotating it with that function id and

00:27:25,520 --> 00:27:28,880
giving it that same id on the server

00:27:27,600 --> 00:27:30,720
that we had on the server so it knows

00:27:28,880 --> 00:27:31,840
how to how to map those it knows what to

00:27:30,720 --> 00:27:34,720
invoke

00:27:31,840 --> 00:27:35,279
and this is all we have to do here back

00:27:34,720 --> 00:27:38,880
in our

00:27:35,279 --> 00:27:41,039
application runner class uh we've got

00:27:38,880 --> 00:27:43,520
the attendee function executions

00:27:41,039 --> 00:27:45,440
now being now being dependency injected

00:27:43,520 --> 00:27:46,640
in just like our attendees repository

00:27:45,440 --> 00:27:47,760
we don't have to implement it we don't

00:27:46,640 --> 00:27:48,640
have to create it we don't have to pass

00:27:47,760 --> 00:27:50,720
it in anywhere

00:27:48,640 --> 00:27:53,039
spring just finds it wires it in where

00:27:50,720 --> 00:27:55,600
it needs to be so we can use it

00:27:53,039 --> 00:27:56,960
so what we're doing now in this in this

00:27:55,600 --> 00:27:58,240
runner we're still creating those same

00:27:56,960 --> 00:27:59,679
six attendees

00:27:58,240 --> 00:28:00,960
but instead of adding them one by one in

00:27:59,679 --> 00:28:01,760
a loop we're just adding them all at

00:28:00,960 --> 00:28:02,799
once

00:28:01,760 --> 00:28:05,440
and then we're going to call the

00:28:02,799 --> 00:28:06,399
function so down here function

00:28:05,440 --> 00:28:08,559
executions dot

00:28:06,399 --> 00:28:09,919
calculate average first name that's

00:28:08,559 --> 00:28:11,279
going to go get the value or that's

00:28:09,919 --> 00:28:14,000
going to go execute the function on the

00:28:11,279 --> 00:28:17,840
server return the value back to us so

00:28:14,000 --> 00:28:17,840
let's go take a look

00:28:18,640 --> 00:28:22,159
it's running average first name length

00:28:21,360 --> 00:28:25,760
five

00:28:22,159 --> 00:28:27,679
bam there it is correct

00:28:25,760 --> 00:28:30,000
okay so it's pretty cool i've shown you

00:28:27,679 --> 00:28:32,960
some cool features of geode by no means

00:28:30,000 --> 00:28:33,840
all of them um and i hope you see how

00:28:32,960 --> 00:28:35,120
easy it is to

00:28:33,840 --> 00:28:36,960
actually do some of these things how

00:28:35,120 --> 00:28:38,960
little code we've written but

00:28:36,960 --> 00:28:40,399
so far all we've written are command

00:28:38,960 --> 00:28:42,080
line applications which

00:28:40,399 --> 00:28:43,760
in the real world is almost certainly

00:28:42,080 --> 00:28:45,679
not what you're going to be doing

00:28:43,760 --> 00:28:47,520
you're going to be writing maybe a web

00:28:45,679 --> 00:28:49,200
application so maybe you wanted to

00:28:47,520 --> 00:28:52,640
expose this function

00:28:49,200 --> 00:28:53,679
through a rest api so because we are in

00:28:52,640 --> 00:28:56,000
the spring

00:28:53,679 --> 00:28:57,039
ecosystem we can do that really easily

00:28:56,000 --> 00:28:59,679
we can just pull in

00:28:57,039 --> 00:29:01,840
springs web springs web framework and

00:28:59,679 --> 00:29:05,520
get a rest api set up really quick

00:29:01,840 --> 00:29:08,000
so first things first in our um

00:29:05,520 --> 00:29:09,520
in our palm.xml or build.gradle we're

00:29:08,000 --> 00:29:12,799
going to add a new dependency

00:29:09,520 --> 00:29:14,080
spring boot starter web that's all we're

00:29:12,799 --> 00:29:17,120
going to need and we can get started

00:29:14,080 --> 00:29:19,039
building our rest api

00:29:17,120 --> 00:29:21,039
so we're going to create a new class

00:29:19,039 --> 00:29:22,640
calling it attendees controller

00:29:21,039 --> 00:29:24,320
and we're going to annotate it with at

00:29:22,640 --> 00:29:25,440
rest controller just telling spring that

00:29:24,320 --> 00:29:27,520
this is going to be

00:29:25,440 --> 00:29:29,600
our rest api so it can create it for us

00:29:27,520 --> 00:29:32,000
and start this rest api

00:29:29,600 --> 00:29:33,440
started listening on port 8080 by

00:29:32,000 --> 00:29:37,039
default

00:29:33,440 --> 00:29:38,799
if we don't change it and down here

00:29:37,039 --> 00:29:40,880
we've got a constructor this constructor

00:29:38,799 --> 00:29:44,000
takes the attendee function execution

00:29:40,880 --> 00:29:45,600
and just stores that in a field

00:29:44,000 --> 00:29:47,039
this isn't anything we have to call we

00:29:45,600 --> 00:29:47,760
don't have to create an instance of this

00:29:47,039 --> 00:29:49,440
class

00:29:47,760 --> 00:29:51,679
spring is going to use this constructor

00:29:49,440 --> 00:29:54,159
to dependency inject

00:29:51,679 --> 00:29:55,200
that function execution just like it did

00:29:54,159 --> 00:29:58,480
into our runner

00:29:55,200 --> 00:30:00,640
and then we can use it down here

00:29:58,480 --> 00:30:02,559
we've got our endpoint mapping annotated

00:30:00,640 --> 00:30:06,080
with at git mapping

00:30:02,559 --> 00:30:08,320
there's also put mapping post mapping

00:30:06,080 --> 00:30:09,200
all those verbs but this is going to be

00:30:08,320 --> 00:30:11,120
get because we're just going to be

00:30:09,200 --> 00:30:13,840
returning the value from that function

00:30:11,120 --> 00:30:15,360
and then you give it that slash average

00:30:13,840 --> 00:30:16,480
name length to tell it where to find

00:30:15,360 --> 00:30:18,080
this endpoint that's going to be like

00:30:16,480 --> 00:30:20,000
the part of the url

00:30:18,080 --> 00:30:21,440
that it's going to go to and then

00:30:20,000 --> 00:30:22,000
whenever that endpoints it it's just

00:30:21,440 --> 00:30:25,440
going to call this

00:30:22,000 --> 00:30:26,720
function where we just call our remote

00:30:25,440 --> 00:30:27,840
function

00:30:26,720 --> 00:30:29,520
and it's going to return the value we

00:30:27,840 --> 00:30:31,760
don't have to do anything else we don't

00:30:29,520 --> 00:30:33,200
have to mess with like html or anything

00:30:31,760 --> 00:30:34,960
just a normal function that returns a

00:30:33,200 --> 00:30:37,840
float spring will take care of the rest

00:30:34,960 --> 00:30:37,840
and return it for us

00:30:38,000 --> 00:30:41,919
so that's all there is to right here so

00:30:40,480 --> 00:30:44,320
let's go ahead

00:30:41,919 --> 00:30:47,600
and start this up and then in postman

00:30:44,320 --> 00:30:51,600
we're going to try to hit that end point

00:30:47,600 --> 00:30:53,679
and there it is at localhost 8080

00:30:51,600 --> 00:30:54,960
average name length we hit that endpoint

00:30:53,679 --> 00:30:57,519
and we got five

00:30:54,960 --> 00:31:00,880
which as before is the correct value

00:30:57,519 --> 00:31:00,880
that's exactly what we're expecting

00:31:01,840 --> 00:31:05,360
so that's all i have to show you today

00:31:04,480 --> 00:31:06,880
um

00:31:05,360 --> 00:31:08,960
i'd like i hope that you've taken away

00:31:06,880 --> 00:31:10,720
just how how easy it is

00:31:08,960 --> 00:31:12,720
to start with geode how easy spring

00:31:10,720 --> 00:31:13,440
makes that and how easy it is to

00:31:12,720 --> 00:31:15,600
integrate

00:31:13,440 --> 00:31:17,200
the other powerful parts of the spring

00:31:15,600 --> 00:31:19,519
ecosystem with your app once you've

00:31:17,200 --> 00:31:21,440
started writing it this way

00:31:19,519 --> 00:31:23,279
so if you're interested in geode or in

00:31:21,440 --> 00:31:24,559
spring or any of this stuff

00:31:23,279 --> 00:31:27,679
here's some other resources you can

00:31:24,559 --> 00:31:29,279
check out geo.apache.org that's the home

00:31:27,679 --> 00:31:31,279
page for apache geode

00:31:29,279 --> 00:31:32,399
spring.io is the home of all the spring

00:31:31,279 --> 00:31:34,240
stuff

00:31:32,399 --> 00:31:36,000
under that you can find information on

00:31:34,240 --> 00:31:36,640
the spring framework spring data spring

00:31:36,000 --> 00:31:38,240
boot

00:31:36,640 --> 00:31:40,000
spring boot data geode any of these

00:31:38,240 --> 00:31:42,320
other projects or

00:31:40,000 --> 00:31:43,440
this last link at the bottom all of the

00:31:42,320 --> 00:31:45,120
demo code

00:31:43,440 --> 00:31:46,720
that i used in these slides is going to

00:31:45,120 --> 00:31:49,360
be available on my github if you want to

00:31:46,720 --> 00:31:49,360
check that out

00:31:50,320 --> 00:32:01,279
so that concludes my talk does anyone

00:31:53,039 --> 00:32:04,240
have any questions

00:32:01,279 --> 00:32:05,679
how do you do geode transactions uh so

00:32:04,240 --> 00:32:08,399
within spring there's a

00:32:05,679 --> 00:32:10,000
uh at transaction annotation so if you

00:32:08,399 --> 00:32:12,080
have some method that you need to be

00:32:10,000 --> 00:32:14,880
transactional you can just annotate that

00:32:12,080 --> 00:32:16,240
with at transaction um

00:32:14,880 --> 00:32:17,679
there's also another annotation that

00:32:16,240 --> 00:32:18,559
you're going to need to uh i think it's

00:32:17,679 --> 00:32:21,039
something like

00:32:18,559 --> 00:32:23,120
at enable gemfire transactions or at

00:32:21,039 --> 00:32:24,399
enable transactions

00:32:23,120 --> 00:32:26,480
and then you can just run that method

00:32:24,399 --> 00:32:28,159
like anything else and it'll be

00:32:26,480 --> 00:32:28,880
transactional automatically dealing with

00:32:28,159 --> 00:32:33,679
the

00:32:28,880 --> 00:32:33,679
commit and or rollback for you

00:32:41,679 --> 00:32:45,840
is it recommended running geode server a

00:32:44,080 --> 00:32:49,679
spring boot app now

00:32:45,840 --> 00:32:49,679
uh so

00:32:49,760 --> 00:32:53,519
it's not something we recommend but it's

00:32:51,840 --> 00:32:55,360
not something we recommend against

00:32:53,519 --> 00:32:56,960
um it's not something very common that

00:32:55,360 --> 00:32:58,720
we see in production for the most part

00:32:56,960 --> 00:33:02,080
people just start their servers

00:32:58,720 --> 00:33:04,240
the normal geode way um primarily i

00:33:02,080 --> 00:33:05,840
personally have used

00:33:04,240 --> 00:33:07,279
the spring boot application method for

00:33:05,840 --> 00:33:08,159
like for testing because you can just

00:33:07,279 --> 00:33:10,480
spin up

00:33:08,159 --> 00:33:12,000
the server process really easily you can

00:33:10,480 --> 00:33:13,360
see what's happening on the server you

00:33:12,000 --> 00:33:14,880
can register your functions really

00:33:13,360 --> 00:33:16,640
easily like that

00:33:14,880 --> 00:33:18,640
but for the most part in production

00:33:16,640 --> 00:33:20,000
you'd probably just want to start things

00:33:18,640 --> 00:33:22,840
through gfish

00:33:20,000 --> 00:33:25,840
but that totally depends on your use

00:33:22,840 --> 00:33:25,840
case

00:33:27,679 --> 00:33:30,399
yep no problem

00:33:35,760 --> 00:33:42,240
thank you

00:33:39,519 --> 00:33:42,240
any more questions

00:33:51,440 --> 00:33:53,840
thank you

00:34:00,690 --> 00:34:03,779
[Music]

00:34:14,159 --> 00:34:17,599
okay well uh hope you guys enjoyed the

00:34:17,040 --> 00:34:19,760
talk

00:34:17,599 --> 00:34:22,240
hope someone's interested in geode and

00:34:19,760 --> 00:34:25,520
or spring

00:34:22,240 --> 00:34:28,720
uh i guess if there's

00:34:25,520 --> 00:34:28,720
no more questions then

00:34:28,960 --> 00:34:35,839
that's it

00:34:35,919 --> 00:34:49,839
okay bye everybody

00:34:50,639 --> 00:34:52,720

YouTube URL: https://www.youtube.com/watch?v=2JIQumD65hQ


