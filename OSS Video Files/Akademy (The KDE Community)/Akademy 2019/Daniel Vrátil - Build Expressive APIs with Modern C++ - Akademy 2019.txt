Title: Daniel VrÃ¡til - Build Expressive APIs with Modern C++ - Akademy 2019
Publication date: 2020-05-25
Playlist: Akademy 2019
Description: 
	Qt has its own way of doing things, and we've been following that in our code and APIs since forever. However, since C++11 and on, the language itself started introducing more and more features to make the code safer and easier to understand. In this talk, I will show a few examples of what tools Modern C++ has to offer to make your code and your APIs more expressive and how to use those tools with Qt.
Captions: 
	00:00:00,450 --> 00:00:07,950
thank you so hi thank you for coming I

00:00:05,069 --> 00:00:11,460
was very lucky that for most of my

00:00:07,950 --> 00:00:14,969
professional life I was able to work

00:00:11,460 --> 00:00:16,680
with cute in one way or another we just

00:00:14,969 --> 00:00:19,320
changed about one and a half years ago

00:00:16,680 --> 00:00:22,740
when I moved on to a completely new job

00:00:19,320 --> 00:00:26,160
new project and we use Pier C bus bus

00:00:22,740 --> 00:00:28,590
and I was quite surprised that I found

00:00:26,160 --> 00:00:31,199
my way around the new codebase fairly

00:00:28,590 --> 00:00:33,750
quickly I could you know start using the

00:00:31,199 --> 00:00:38,040
eternal api's the libraries we have and

00:00:33,750 --> 00:00:40,290
it was it felt natural to me and I

00:00:38,040 --> 00:00:41,820
didn't think too much about it until a

00:00:40,290 --> 00:00:45,510
couple months later when I was doing

00:00:41,820 --> 00:00:47,940
some KDE hacking and for like the

00:00:45,510 --> 00:00:49,590
1,000th time I had to go to the queue

00:00:47,940 --> 00:00:52,739
documentation to check on the ownership

00:00:49,590 --> 00:00:55,530
of kin Network reply and that's when I

00:00:52,739 --> 00:00:57,210
realized that the reason why I was able

00:00:55,530 --> 00:01:00,870
to find my way around the new code base

00:00:57,210 --> 00:01:04,559
at my new work was because the API was

00:01:00,870 --> 00:01:08,040
very expressive it tell tells the intent

00:01:04,559 --> 00:01:10,380
that the developer of the API has so

00:01:08,040 --> 00:01:13,049
that for me as a newcomer it is very

00:01:10,380 --> 00:01:15,330
easy to understand oh so I'm supposed to

00:01:13,049 --> 00:01:17,430
take on take over the ownership or oh

00:01:15,330 --> 00:01:23,720
now I'm supposed to pass the ownership

00:01:17,430 --> 00:01:26,040
and so on so this talk is showing to

00:01:23,720 --> 00:01:27,600
really just two examples because

00:01:26,040 --> 00:01:31,110
otherwise I could we would be here all

00:01:27,600 --> 00:01:33,329
day but I share pick two examples from

00:01:31,110 --> 00:01:36,600
modern superpowers that I really really

00:01:33,329 --> 00:01:40,650
really like and I want to present them

00:01:36,600 --> 00:01:42,780
to you so you can see that this API SAR

00:01:40,650 --> 00:01:45,060
api's are similar but I don't really

00:01:42,780 --> 00:01:47,310
express the intention right the first

00:01:45,060 --> 00:01:49,320
one actually transfers ownership you are

00:01:47,310 --> 00:01:54,119
supposed to delete the key Network reply

00:01:49,320 --> 00:01:56,820
yourself the other one does not so this

00:01:54,119 --> 00:01:58,950
would be an easy fix right this already

00:01:56,820 --> 00:02:01,049
tells the intention that

00:01:58,950 --> 00:02:03,450
well the key network access manager

00:02:01,049 --> 00:02:05,899
actually gives you the network reply and

00:02:03,450 --> 00:02:08,459
you are supposed to delete it

00:02:05,899 --> 00:02:09,959
well the other one well you don't really

00:02:08,459 --> 00:02:11,970
know what to do with it because it's

00:02:09,959 --> 00:02:14,330
just a row pointer so you better not

00:02:11,970 --> 00:02:14,330
touch it

00:02:14,689 --> 00:02:23,900
the thing is cute is often heralded that

00:02:20,030 --> 00:02:27,420
it has its well-designed very stable

00:02:23,900 --> 00:02:30,150
consistent API and rightly so the

00:02:27,420 --> 00:02:35,269
problem is that lots of the parents are

00:02:30,150 --> 00:02:38,310
based on you know twenty years ago and

00:02:35,269 --> 00:02:41,430
even though we say that now we use C++

00:02:38,310 --> 00:02:43,560
11 or 14 if you really look around not

00:02:41,430 --> 00:02:45,359
just the cute code but also kiddie code

00:02:43,560 --> 00:02:49,470
base what do you find is we don't really

00:02:45,359 --> 00:02:51,329
use C++ 11 we use still use C++ o 3 and

00:02:49,470 --> 00:02:52,260
we just share picked out o and lambda

00:02:51,329 --> 00:02:55,500
and that's basically it

00:02:52,260 --> 00:03:00,599
we don't use much else from whatever the

00:02:55,500 --> 00:03:03,180
language has right so when I speak about

00:03:00,599 --> 00:03:05,340
C++ and modern C++ there are two parts

00:03:03,180 --> 00:03:08,430
of it there's the core language the

00:03:05,340 --> 00:03:11,970
language itself and the syntax that it

00:03:08,430 --> 00:03:14,790
has right so this needs to be supported

00:03:11,970 --> 00:03:18,690
by compilers so for instance was 11

00:03:14,790 --> 00:03:21,739
those were lambdas for C++ 14 this was

00:03:18,690 --> 00:03:24,260
function template arguments deduction

00:03:21,739 --> 00:03:28,349
the other part is the standard library

00:03:24,260 --> 00:03:30,120
right that's all the template classes

00:03:28,349 --> 00:03:33,090
and algorithms that are power that comes

00:03:30,120 --> 00:03:35,760
with your compiler and sometimes those

00:03:33,090 --> 00:03:38,220
do require the new API but sometimes

00:03:35,760 --> 00:03:40,650
they don't sorry the new language

00:03:38,220 --> 00:03:43,530
features but very often didn't library

00:03:40,650 --> 00:03:45,900
features that come with C++ 17 for

00:03:43,530 --> 00:03:52,409
instance they could fairly very well

00:03:45,900 --> 00:03:54,269
work with C++ 14 as well so the two

00:03:52,409 --> 00:03:59,129
examples I'm going to show they are from

00:03:54,269 --> 00:04:01,829
C++ 17 and since we do not use it was 17

00:03:59,129 --> 00:04:06,479
that Marcin KD that you can very easily

00:04:01,829 --> 00:04:08,370
find lots and lots of well not that many

00:04:06,479 --> 00:04:10,530
but you can find quite a few like a

00:04:08,370 --> 00:04:13,439
single header implementation on github

00:04:10,530 --> 00:04:16,440
that are compatible with C++ 17 but they

00:04:13,439 --> 00:04:21,209
can be used with C++ 11 or 14 very

00:04:16,440 --> 00:04:25,289
easily so here are the two cases what if

00:04:21,209 --> 00:04:26,310
so what if a function may or may not

00:04:25,289 --> 00:04:28,830
return a value

00:04:26,310 --> 00:04:31,650
so how do you express that you have a

00:04:28,830 --> 00:04:35,850
function and the function may not find

00:04:31,650 --> 00:04:38,970
something or it may fail you can imagine

00:04:35,850 --> 00:04:41,790
some settings class right that reads

00:04:38,970 --> 00:04:44,070
values and it may not find the option in

00:04:41,790 --> 00:04:46,560
the config file so how do you express

00:04:44,070 --> 00:04:49,100
that well we could throw an exception

00:04:46,560 --> 00:04:53,520
but we don't like exceptions that match

00:04:49,100 --> 00:04:55,860
so we could return a pointer right so if

00:04:53,520 --> 00:04:58,260
we find that option in the config file

00:04:55,860 --> 00:04:59,790
it would return a pointer to rectangle

00:04:58,260 --> 00:05:02,400
if it doesn't find the option it would

00:04:59,790 --> 00:05:04,080
return a null pointer this is annoying

00:05:02,400 --> 00:05:06,960
though first this is a value class

00:05:04,080 --> 00:05:08,430
because rectangle is just a value so why

00:05:06,960 --> 00:05:10,800
would you return a pointer to a value

00:05:08,430 --> 00:05:12,120
class and how would you return but and

00:05:10,800 --> 00:05:14,490
you wouldn't do this with integers right

00:05:12,120 --> 00:05:17,280
he would not return a pointer to integer

00:05:14,490 --> 00:05:22,889
just to be able to represent a lack of

00:05:17,280 --> 00:05:25,440
the value so what do you do well you

00:05:22,889 --> 00:05:27,090
could take a random value and say this

00:05:25,440 --> 00:05:29,300
is a special value and this special

00:05:27,090 --> 00:05:32,820
value means there is no value so

00:05:29,300 --> 00:05:38,340
sometimes we pick 0 sometimes we pick -1

00:05:32,820 --> 00:05:40,860
sometimes - - sometimes - marks int or -

00:05:38,340 --> 00:05:43,410
max in +1 or something like that but

00:05:40,860 --> 00:05:45,240
this is problematic because not always

00:05:43,410 --> 00:05:47,580
you can do it sometimes you have a

00:05:45,240 --> 00:05:50,789
function that can fail but it also

00:05:47,580 --> 00:05:53,100
doesn't fail it has to use it can use

00:05:50,789 --> 00:05:56,220
all the values from the range of the

00:05:53,100 --> 00:06:00,780
type this is a perfect example this is a

00:05:56,220 --> 00:06:03,030
horrendous C style 1970s API what the

00:06:00,780 --> 00:06:06,660
hell is just doing in my twenty nineteen

00:06:03,030 --> 00:06:09,750
codebase right I don't like this

00:06:06,660 --> 00:06:11,669
function at all I hate it first it

00:06:09,750 --> 00:06:15,120
doesn't actually force you to error

00:06:11,669 --> 00:06:16,979
check because because there's a null

00:06:15,120 --> 00:06:20,310
pointer as the default argument to the

00:06:16,979 --> 00:06:22,889
error checking right so basically if you

00:06:20,310 --> 00:06:25,470
are just lazy or a new programmer and

00:06:22,889 --> 00:06:29,910
you do not know about this you might be

00:06:25,470 --> 00:06:35,160
tempted to somewhat forget it so

00:06:29,910 --> 00:06:36,780
what I would do is probably well I think

00:06:35,160 --> 00:06:38,100
I'm missing some slides but normally you

00:06:36,780 --> 00:06:40,980
would probably get rid of the null

00:06:38,100 --> 00:06:43,680
pointer at least to actually force the

00:06:40,980 --> 00:06:45,210
developer to say well I know what I'm

00:06:43,680 --> 00:06:50,490
doing I'm passing in a lot of pointer

00:06:45,210 --> 00:06:52,980
explicitly the way we do this in cute

00:06:50,490 --> 00:06:56,610
very often is that we define an our

00:06:52,980 --> 00:06:59,490
state of the type right so we have Q

00:06:56,610 --> 00:07:04,500
string is now and correct is now and Q

00:06:59,490 --> 00:07:06,660
size is now this is also a bit

00:07:04,500 --> 00:07:08,310
problematic though because you have a

00:07:06,660 --> 00:07:13,260
function that actually returns a value

00:07:08,310 --> 00:07:15,660
of type Q string and now it doesn't tell

00:07:13,260 --> 00:07:17,850
you the intention that well it could it

00:07:15,660 --> 00:07:19,920
is a Q string but it is in our state so

00:07:17,850 --> 00:07:22,560
it actually is not a Q string because we

00:07:19,920 --> 00:07:25,680
haven't found it so this puts the burden

00:07:22,560 --> 00:07:27,900
on you as a user of the API to realize

00:07:25,680 --> 00:07:30,660
so - I have to do the error checking

00:07:27,900 --> 00:07:32,760
here or is this okay can this fail do I

00:07:30,660 --> 00:07:35,760
have to check if the Q string is now or

00:07:32,760 --> 00:07:38,520
will this always succeed and you can't

00:07:35,760 --> 00:07:40,230
really tell right and we are most

00:07:38,520 --> 00:07:44,130
trusted developers we don't want to

00:07:40,230 --> 00:07:47,070
reject everything and there are of

00:07:44,130 --> 00:07:50,250
course classes or types that cannot have

00:07:47,070 --> 00:07:52,620
an hour State right so I cannot have a

00:07:50,250 --> 00:07:56,060
now state of color because well what I

00:07:52,620 --> 00:07:59,850
fill for all the three colors all of the

00:07:56,060 --> 00:08:02,820
components because well if I put zeros

00:07:59,850 --> 00:08:05,790
in there it's not a normal color it's

00:08:02,820 --> 00:08:10,320
it's a black color right and black is a

00:08:05,790 --> 00:08:14,250
very cool color so I need something else

00:08:10,320 --> 00:08:17,880
and the thing that C++ offers is STD

00:08:14,250 --> 00:08:22,530
optional as the optional is the template

00:08:17,880 --> 00:08:26,310
class that either holds a null value or

00:08:22,530 --> 00:08:29,669
it holds a value of type T so this way I

00:08:26,310 --> 00:08:32,700
can so this is so this explicitly

00:08:29,669 --> 00:08:35,520
basically says that well there is either

00:08:32,700 --> 00:08:37,080
nothing or there's something in me then

00:08:35,520 --> 00:08:40,860
you have to check

00:08:37,080 --> 00:08:43,290
so we could have the same API as we had

00:08:40,860 --> 00:08:45,510
before to read some settings and we

00:08:43,290 --> 00:08:47,550
could have a function that reads string

00:08:45,510 --> 00:08:50,430
and returns an STD optional cube string

00:08:47,550 --> 00:08:54,000
right because this explicitly says this

00:08:50,430 --> 00:08:56,450
may fail and it may return nothing and

00:08:54,000 --> 00:08:58,770
you have to do the error checking and

00:08:56,450 --> 00:09:00,480
then you can have the alternative

00:08:58,770 --> 00:09:02,960
overload which like gets strike or

00:09:00,480 --> 00:09:05,790
default which takes the second argument

00:09:02,960 --> 00:09:07,200
the second argument and then if it

00:09:05,790 --> 00:09:09,480
doesn't find the option in the config

00:09:07,200 --> 00:09:11,820
file it will return the value of the

00:09:09,480 --> 00:09:13,650
default the default value so the

00:09:11,820 --> 00:09:16,200
function will never fail so it returns

00:09:13,650 --> 00:09:17,910
only a key string and you know okay so I

00:09:16,200 --> 00:09:20,430
don't have to do error checking here

00:09:17,910 --> 00:09:25,980
because I will always get a valid value

00:09:20,430 --> 00:09:28,680
that I continue to use I forgot to

00:09:25,980 --> 00:09:33,000
apologize beforehand for the amount of

00:09:28,680 --> 00:09:36,810
C++ code in these slides it will get

00:09:33,000 --> 00:09:40,710
worse so this is an example how you

00:09:36,810 --> 00:09:44,750
would use the API right the STD optional

00:09:40,710 --> 00:09:49,080
has a very nice getter called value or

00:09:44,750 --> 00:09:51,060
value underscore or so it either returns

00:09:49,080 --> 00:09:52,800
the value stored in the optional or if

00:09:51,060 --> 00:09:56,700
the optional is now it returns the value

00:09:52,800 --> 00:10:00,380
we give it so this actually means you

00:09:56,700 --> 00:10:00,380
would not need the second overload even

00:10:01,580 --> 00:10:08,850
you can also check if the name has value

00:10:05,370 --> 00:10:10,860
and then you can try to read the value

00:10:08,850 --> 00:10:13,980
or to reference it and you will get the

00:10:10,860 --> 00:10:15,870
value this really forces you to do the

00:10:13,980 --> 00:10:17,130
error checking because you got something

00:10:15,870 --> 00:10:20,430
that is not the keep string it is an

00:10:17,130 --> 00:10:22,470
optional cue string so you know you have

00:10:20,430 --> 00:10:25,530
to do error checking also because if you

00:10:22,470 --> 00:10:27,870
try to access the value and it contains

00:10:25,530 --> 00:10:30,210
a null value then it will throw an

00:10:27,870 --> 00:10:35,850
exception about your program so you do

00:10:30,210 --> 00:10:41,340
want to check the value so this was one

00:10:35,850 --> 00:10:44,450
example other example is what if a

00:10:41,340 --> 00:10:48,090
function wants to report an error

00:10:44,450 --> 00:10:50,550
so you have a function that I don't know

00:10:48,090 --> 00:10:54,900
tries to read a file access network

00:10:50,550 --> 00:10:57,840
whatever and it fails and you just don't

00:10:54,900 --> 00:10:59,400
want to fail solidly you want to tell

00:10:57,840 --> 00:11:01,830
the user that something went wrong or

00:10:59,400 --> 00:11:05,550
you need to pass some details about what

00:11:01,830 --> 00:11:08,670
went wrong to the calling code so how do

00:11:05,550 --> 00:11:10,440
you do this well you can throw an

00:11:08,670 --> 00:11:13,790
exception but it still don't like

00:11:10,440 --> 00:11:16,980
exceptions so let's try something else

00:11:13,790 --> 00:11:19,980
inspired by Q string to end we could use

00:11:16,980 --> 00:11:22,290
a return argument I've already mentioned

00:11:19,980 --> 00:11:26,490
before written arguments are evil and

00:11:22,290 --> 00:11:28,440
you should not use them especially not

00:11:26,490 --> 00:11:31,050
with a default value because then you're

00:11:28,440 --> 00:11:33,120
basically letting the developers be lazy

00:11:31,050 --> 00:11:37,290
and because developers are lazy you

00:11:33,120 --> 00:11:40,800
should do this so you have you forced

00:11:37,290 --> 00:11:44,340
them to explicitly say I know what I'm

00:11:40,800 --> 00:11:46,520
doing or I am explicitly have the

00:11:44,340 --> 00:11:50,180
developer to admit that he's lazy and

00:11:46,520 --> 00:11:52,740
pass in a null pointer ideally he would

00:11:50,180 --> 00:11:54,900
you won't even give them a choice and

00:11:52,740 --> 00:11:57,720
you actually forced them to pass in

00:11:54,900 --> 00:11:59,880
something it's up to them if they'd and

00:11:57,720 --> 00:12:05,340
check what's in the error afterwards but

00:11:59,880 --> 00:12:10,340
that's a different discussion so what if

00:12:05,340 --> 00:12:13,680
we do not want to use return argument

00:12:10,340 --> 00:12:16,890
well then we have only one option and

00:12:13,680 --> 00:12:20,670
that's we need we need to return somehow

00:12:16,890 --> 00:12:24,140
multiple values from the function so we

00:12:20,670 --> 00:12:27,390
could just return a struct which either

00:12:24,140 --> 00:12:30,150
optionally contains an error or it

00:12:27,390 --> 00:12:33,300
contains the JSON document for instance

00:12:30,150 --> 00:12:37,110
if it's a JSON parser the problem here

00:12:33,300 --> 00:12:38,850
is that it can sort of be an it has

00:12:37,110 --> 00:12:41,100
couple states which are not really

00:12:38,850 --> 00:12:44,130
sensible so what if the function fills

00:12:41,100 --> 00:12:46,170
in both right then that's not defined

00:12:44,130 --> 00:12:48,390
state or what it doesn't fill any of

00:12:46,170 --> 00:12:49,770
those that's also weird stay there was

00:12:48,390 --> 00:12:52,580
no error but there was no document

00:12:49,770 --> 00:12:56,000
either so what the hell happened

00:12:52,580 --> 00:13:00,230
so even so we need something even better

00:12:56,000 --> 00:13:03,500
right we want the function to be able to

00:13:00,230 --> 00:13:06,529
return two types but always only one of

00:13:03,500 --> 00:13:08,089
them right there is this thing that

00:13:06,529 --> 00:13:12,140
trusts some reason everybody hates

00:13:08,089 --> 00:13:14,390
that's Union and C++ 17 introduced a

00:13:12,140 --> 00:13:17,600
much smarter version of Union called STD

00:13:14,390 --> 00:13:20,390
variant do not confuse STD variant with

00:13:17,600 --> 00:13:23,029
Q variant those are different things

00:13:20,390 --> 00:13:23,680
while Q variant can hold literally

00:13:23,029 --> 00:13:26,930
anything

00:13:23,680 --> 00:13:29,870
STD variant can only hold one of the

00:13:26,930 --> 00:13:32,209
values of the type that is specified in

00:13:29,870 --> 00:13:34,940
the template right if you want something

00:13:32,209 --> 00:13:41,170
if you would want something like Q very

00:13:34,940 --> 00:13:44,390
end there's STD na which is weird so

00:13:41,170 --> 00:13:46,250
this is what the function would like so

00:13:44,390 --> 00:13:50,029
the function returns an STD very end of

00:13:46,250 --> 00:13:52,160
JSON document Q string so it returns a

00:13:50,029 --> 00:13:55,579
value which is either a JSON document or

00:13:52,160 --> 00:13:59,480
a key ring cannot be none can't be both

00:13:55,579 --> 00:14:02,089
it's always one or the other that of

00:13:59,480 --> 00:14:05,240
course can be more of those the variant

00:14:02,089 --> 00:14:08,180
can have any number of types but in this

00:14:05,240 --> 00:14:10,160
case my two makes sense but this is

00:14:08,180 --> 00:14:11,600
still not really expressive right this

00:14:10,160 --> 00:14:15,740
doesn't tell me what the Q string

00:14:11,600 --> 00:14:19,160
actually means is it I don't know is the

00:14:15,740 --> 00:14:21,230
hello world is it how long it took could

00:14:19,160 --> 00:14:25,520
be anything so I would do something like

00:14:21,230 --> 00:14:27,410
this define a type def - Q string call

00:14:25,520 --> 00:14:29,000
it error message and then I can see that

00:14:27,410 --> 00:14:32,990
the function either returns a JSON

00:14:29,000 --> 00:14:37,190
document or an error message right it's

00:14:32,990 --> 00:14:39,050
a single easy one line of code it has no

00:14:37,190 --> 00:14:41,480
compilation overhead no runtime overhead

00:14:39,050 --> 00:14:46,570
it just makes your API more expressive

00:14:41,480 --> 00:14:46,570
more easier to use for other developers

00:14:47,020 --> 00:14:54,769
the showcase another reason oh this is

00:14:52,519 --> 00:15:00,560
crazy but this is how we would lose it

00:14:54,769 --> 00:15:02,449
so STD variant has this get if thingy so

00:15:00,560 --> 00:15:02,990
you can ask if it contains an error

00:15:02,449 --> 00:15:05,570
message

00:15:02,990 --> 00:15:07,160
then return a pointer to it the other up

00:15:05,570 --> 00:15:10,279
the other way you can do it is you can

00:15:07,160 --> 00:15:11,089
check if it holds alternative then gives

00:15:10,279 --> 00:15:14,149
you true or false

00:15:11,089 --> 00:15:20,089
and you think s did he get you get the

00:15:14,149 --> 00:15:23,089
type it holds this is very similar to

00:15:20,089 --> 00:15:28,010
the API you know one of the things I

00:15:23,089 --> 00:15:31,040
like about the variant in C++ 17 is that

00:15:28,010 --> 00:15:33,649
it also introduced STD visit which

00:15:31,040 --> 00:15:36,709
allows you to write basically using the

00:15:33,649 --> 00:15:39,980
visitor pattern so at the end and I'm

00:15:36,709 --> 00:15:42,440
bit abusing it but it still worked very

00:15:39,980 --> 00:15:45,470
nicely because it allows you to put all

00:15:42,440 --> 00:15:48,649
the things into a single block so you

00:15:45,470 --> 00:15:52,310
you have your success and error hand

00:15:48,649 --> 00:15:54,320
link in one block of code right so at

00:15:52,310 --> 00:15:58,040
the end I will start from the end at the

00:15:54,320 --> 00:16:00,290
end is the the very end that you want to

00:15:58,040 --> 00:16:02,630
check and then you put in a lump down

00:16:00,290 --> 00:16:04,430
that is called when the variant contains

00:16:02,630 --> 00:16:06,529
the JSON document and then you put

00:16:04,430 --> 00:16:10,190
another lambda that is called if the

00:16:06,529 --> 00:16:11,779
variant contains the error message this

00:16:10,190 --> 00:16:14,930
doesn't work on its own you need to do

00:16:11,779 --> 00:16:17,060
this overload template magic if you want

00:16:14,930 --> 00:16:19,459
to look this is not part of the standard

00:16:17,060 --> 00:16:23,540
but just copy paste it from cpp

00:16:19,459 --> 00:16:28,399
reference like i do at the time it's a

00:16:23,540 --> 00:16:31,600
two line template and so this makes your

00:16:28,399 --> 00:16:31,600
life much easier as well

00:16:33,010 --> 00:16:39,680
so these were two examples of how you

00:16:36,590 --> 00:16:42,470
can make your API way more expressive

00:16:39,680 --> 00:16:44,240
than just returning a pointer or cue

00:16:42,470 --> 00:16:48,350
string without telling the user any more

00:16:44,240 --> 00:16:50,270
information the conclusion would be you

00:16:48,350 --> 00:16:51,950
smart pointers of the slave II should

00:16:50,270 --> 00:16:54,560
have been doing it for decades not in

00:16:51,950 --> 00:16:57,380
the past three years it's optional use

00:16:54,560 --> 00:17:02,330
variant use all the nice things that

00:16:57,380 --> 00:17:05,360
modern C++ has if you can switch to

00:17:02,330 --> 00:17:09,110
actual modern C++ so that means if you

00:17:05,360 --> 00:17:11,390
can leave C++ 11 behind which is eight

00:17:09,110 --> 00:17:13,730
years old by now and switch to something

00:17:11,390 --> 00:17:16,910
that is not so old maybe just two years

00:17:13,730 --> 00:17:20,600
old then switch to C++ 17 it has some

00:17:16,910 --> 00:17:22,220
very nice features that though made not

00:17:20,600 --> 00:17:25,100
necessarily can improve the

00:17:22,220 --> 00:17:27,140
expressiveness of your API or whatever

00:17:25,100 --> 00:17:32,900
but it can make your code in general

00:17:27,140 --> 00:17:38,140
more readable and oh that was fast

00:17:32,900 --> 00:17:38,140
so thank you and any questions

00:17:40,550 --> 00:17:46,550
I guess that's one of the features of

00:17:44,300 --> 00:17:50,960
C++ is you don't pay for you don't what

00:17:46,550 --> 00:17:53,240
you don't use and so we have lots of

00:17:50,960 --> 00:18:03,170
time for other questions on more

00:17:53,240 --> 00:18:08,390
techniques so we obviously are not using

00:18:03,170 --> 00:18:10,250
these things in frameworks how would you

00:18:08,390 --> 00:18:13,070
go on doing this because like that

00:18:10,250 --> 00:18:15,110
probably means breaking the API like

00:18:13,070 --> 00:18:16,700
like the ABI evan because you need to

00:18:15,110 --> 00:18:18,880
change the sure I don't know brittle

00:18:16,700 --> 00:18:21,920
times are part of the API or not but

00:18:18,880 --> 00:18:23,900
there's things to be changed right so do

00:18:21,920 --> 00:18:26,210
you think it makes sense to do it now

00:18:23,900 --> 00:18:29,060
wait for framework six if that ever

00:18:26,210 --> 00:18:31,450
happens yeah that's a great point I

00:18:29,060 --> 00:18:35,560
think now there's a really good time to

00:18:31,450 --> 00:18:38,750
go fix this in cute for kids six and

00:18:35,560 --> 00:18:44,540
start looking into doing this for

00:18:38,750 --> 00:18:46,160
frameworks and probably you know it's

00:18:44,540 --> 00:18:48,050
not like now go and change everything to

00:18:46,160 --> 00:18:49,130
optional you need to think about you

00:18:48,050 --> 00:18:51,770
know where this makes sense

00:18:49,130 --> 00:18:53,840
and probably need some guidelines some

00:18:51,770 --> 00:18:57,350
thinking how and when this should

00:18:53,840 --> 00:18:59,030
actually be used my initial initially I

00:18:57,350 --> 00:19:00,620
was really excited about this thing so I

00:18:59,030 --> 00:19:02,450
tried started putting it everywhere and

00:19:00,620 --> 00:19:06,260
then I realized this is not the right

00:19:02,450 --> 00:19:10,010
way to go so but yeah start putting in

00:19:06,260 --> 00:19:12,650
some where it breaks API but we have to

00:19:10,010 --> 00:19:18,920
at some point to move on otherwise we'll

00:19:12,650 --> 00:19:23,590
be stuck with C++ all three forever so

00:19:18,920 --> 00:19:26,630
just on comment regarding variant for

00:19:23,590 --> 00:19:28,370
okay so what do you think I'm going to

00:19:26,630 --> 00:19:30,800
rephrase it what do you think about

00:19:28,370 --> 00:19:33,590
libraries like boost outcome and boost

00:19:30,800 --> 00:19:36,890
expected as a replacement for the exact

00:19:33,590 --> 00:19:40,400
use case of variants that you had right

00:19:36,890 --> 00:19:42,680
as far as I know there was a CD expected

00:19:40,400 --> 00:19:46,040
proposed for seventeen but they not get

00:19:42,680 --> 00:19:49,840
in right so surely I use boost if you

00:19:46,040 --> 00:19:56,480
want to use boost boost awesome

00:19:49,840 --> 00:19:59,120
other questions at the keynote about

00:19:56,480 --> 00:20:01,700
cute six it was mentioned that

00:19:59,120 --> 00:20:06,290
containers will be wrapped in standard

00:20:01,700 --> 00:20:11,480
containers and I thought about all the

00:20:06,290 --> 00:20:14,300
cute pointers VF like Q pointer and Q

00:20:11,480 --> 00:20:17,540
shared pointer and all of these and when

00:20:14,300 --> 00:20:20,990
they're C++ equivalents of modern C++ so

00:20:17,540 --> 00:20:24,320
what's your opinion on these can they be

00:20:20,990 --> 00:20:27,590
also like share concepts or be replaced

00:20:24,320 --> 00:20:29,320
or not everything probably III don't

00:20:27,590 --> 00:20:33,560
know we're not enough about the

00:20:29,320 --> 00:20:35,390
differences if we can make Q shared

00:20:33,560 --> 00:20:37,610
pointer just a type def or wrapper

00:20:35,390 --> 00:20:42,160
around STD short pointer and stuff I

00:20:37,610 --> 00:20:47,420
don't know what thing I know is that we

00:20:42,160 --> 00:20:49,490
either should have a Q unique pointer or

00:20:47,420 --> 00:20:50,900
get rid of Q scope winter and forced

00:20:49,490 --> 00:20:54,050
everyone using STD unique pointer

00:20:50,900 --> 00:20:56,030
because right now we have Q scoped

00:20:54,050 --> 00:20:58,370
winter and unique pointer STD unique

00:20:56,030 --> 00:21:02,300
pointer which are very similar but not

00:20:58,370 --> 00:21:05,990
really right because there are no QQ

00:21:02,300 --> 00:21:07,700
scope weather is not movable and as far

00:21:05,990 --> 00:21:10,070
as I know they try to make it movable

00:21:07,700 --> 00:21:12,460
and realize this is stupid and reverted

00:21:10,070 --> 00:21:12,460
it so

00:21:21,600 --> 00:21:30,010
so uh which compilers can actually build

00:21:26,470 --> 00:21:33,520
code like this shirt JCCC can clanking

00:21:30,010 --> 00:21:35,470
what about em SVC and yeah what I'm

00:21:33,520 --> 00:21:38,470
aiming at is more like this is this is a

00:21:35,470 --> 00:21:41,470
new code and code like this tends to

00:21:38,470 --> 00:21:43,990
uncover compiler bugs and the next

00:21:41,470 --> 00:21:49,180
question is did your code ever find the

00:21:43,990 --> 00:21:52,780
compiler back so the supported compares

00:21:49,180 --> 00:21:55,840
is recent enough GCC and there's been

00:21:52,780 --> 00:22:00,700
GCC space for a couple years now so does

00:21:55,840 --> 00:22:03,400
clunk even on BSD don't make as well on

00:22:00,700 --> 00:22:06,670
Windows the latest version of my species

00:22:03,400 --> 00:22:08,740
has C++ 17 support I don't know what

00:22:06,670 --> 00:22:12,880
stayed there standard libraries in but

00:22:08,740 --> 00:22:15,240
because I don't care about Windows but

00:22:12,880 --> 00:22:18,100
well you can compile it on all platforms

00:22:15,240 --> 00:22:21,160
if you have a recent enough compiler

00:22:18,100 --> 00:22:23,110
that's I think B except for haiku and

00:22:21,160 --> 00:22:26,220
this weird stuff I have no idea they

00:22:23,110 --> 00:22:29,980
promise to a compiled by hand

00:22:26,220 --> 00:22:32,200
the second question no I don't think I

00:22:29,980 --> 00:22:34,810
found a compiler error I found a link or

00:22:32,200 --> 00:22:43,260
error in length time optimization that's

00:22:34,810 --> 00:22:43,260
fun to debug other questions

00:22:45,840 --> 00:22:54,650
if not thank you Dan for your

00:22:49,050 --> 00:22:54,650
[Applause]

00:23:00,900 --> 00:23:02,960

YouTube URL: https://www.youtube.com/watch?v=Bz4PA1iAniQ


