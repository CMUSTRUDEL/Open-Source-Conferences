Title: Berlin Buzzwords 2019: Guido Schmutz – Location Analytics - Real-Time Geofencing using Kafka #bbuzz
Publication date: 2019-06-18
Playlist: Berlin Buzzwords 2019 #bbuzz
Description: 
	An important underlying concept behind location-based applications is called geofencing. Geofencing is a process that allows acting on users and/or devices who enter/exit a specific geographical area, known as a geo-fence. A geo-fence can be dynamically generated—as in a radius around a point location, or a geo-fence can be a predefined set of boundaries (such as secured areas, buildings, boarders of counties, states or countries).

Geofencing lays the foundation for realizing use cases around fleet monitoring, asset tracking, phone tracking across cell sites, connected manufacturing, ride-sharing solutions and many others.

GPS tracking tells constantly and in real time where a device is located and forms the stream of events which needs to be analyzed against the much more static set of geo-fences. Many of the use cases mentioned above require low-latency actions taken place, if either a device enters or leaves a geo-fence or when it is approaching such a geo-fence. That’s where streaming data ingestion and streaming analytics and therefore the Kafka ecosystem comes into play.

This session will present how location analytics applications can be implemented using Kafka and KSQL & Kafka Streams. It highlights the exiting features available out-of-the-box and then shows how easy it is to extend it by custom defined functions (UDFs). The design of such solution so that it can scale with both an increasing amount of position events as well as geo-fences will be discussed as well. 

Read more:
https://2019.berlinbuzzwords.de/19/session/location-analytics-real-time-geofencing-using-kafka

About Guido Schmutz:
https://2019.berlinbuzzwords.de/users/guido-schmutz

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,230 --> 00:00:12,420
okay hello everybody welcome to my talk

00:00:09,510 --> 00:00:14,640
location analytics real-time geofencing

00:00:12,420 --> 00:00:18,660
using cough

00:00:14,640 --> 00:00:20,730
Motz I'm working for trevallies we're an

00:00:18,660 --> 00:00:22,650
IT service company or service provider

00:00:20,730 --> 00:00:24,800
company operating in Switzerland Germany

00:00:22,650 --> 00:00:28,680
and Austria

00:00:24,800 --> 00:00:32,850
so I'm from Switzerland as you might

00:00:28,680 --> 00:00:37,140
hear from my English already so what is

00:00:32,850 --> 00:00:38,460
my talk about today I will start with an

00:00:37,140 --> 00:00:40,950
introduction in motivation into

00:00:38,460 --> 00:00:43,050
geofencing what is it all about a little

00:00:40,950 --> 00:00:45,060
bit of about Kafka so I mean more an

00:00:43,050 --> 00:00:47,579
expert in the Kafka area and less an

00:00:45,060 --> 00:00:49,620
expert in geofencing if I say it's an

00:00:47,579 --> 00:00:53,489
introduction Eric talk I really mean

00:00:49,620 --> 00:00:57,989
introductory into geofencing a bit less

00:00:53,489 --> 00:01:01,289
into Kafka you will see I will use quite

00:00:57,989 --> 00:01:04,350
a lot in the case equal area so I have a

00:01:01,289 --> 00:01:06,020
lot of I wouldn't say code I have a lot

00:01:04,350 --> 00:01:09,450
of Kasey Kahl statements in my

00:01:06,020 --> 00:01:11,100
presentation in my slides where I will

00:01:09,450 --> 00:01:13,800
show you step by step what I have tried

00:01:11,100 --> 00:01:15,240
what you might go in there where you

00:01:13,800 --> 00:01:18,950
might go into into the wrong direction

00:01:15,240 --> 00:01:21,119
and which which parts actually work I

00:01:18,950 --> 00:01:23,340
will talk about an implementation in

00:01:21,119 --> 00:01:26,189
case equal I've also talked about an

00:01:23,340 --> 00:01:29,420
implementation using title 38 I will

00:01:26,189 --> 00:01:31,950
come back to that and last but not least

00:01:29,420 --> 00:01:36,119
visualization using Arkadia data so

00:01:31,950 --> 00:01:38,399
that's the agenda for today so um you

00:01:36,119 --> 00:01:40,439
know you know as I mentioned I work for

00:01:38,399 --> 00:01:43,320
two rallies more than 22 years I have

00:01:40,439 --> 00:01:46,890
experience in the area of Java in the

00:01:43,320 --> 00:01:49,290
last couple of years I mostly worked in

00:01:46,890 --> 00:01:51,810
the area of big data and fast data a lot

00:01:49,290 --> 00:01:54,689
of work with Kafka a lot of presentation

00:01:51,810 --> 00:01:57,119
with Kafka I'm an architect and have

00:01:54,689 --> 00:01:59,490
more than 30 years of software and

00:01:57,119 --> 00:02:03,360
experience I'm active on social media

00:01:59,490 --> 00:02:05,789
I'm not publishing out of my own content

00:02:03,360 --> 00:02:08,430
what I do is I have a weekly edition of

00:02:05,789 --> 00:02:10,320
what's new in stream processing so this

00:02:08,430 --> 00:02:12,240
this is a lot of links or links to

00:02:10,320 --> 00:02:15,360
presentation links of blog articles

00:02:12,240 --> 00:02:17,940
which just came out the previous week

00:02:15,360 --> 00:02:22,980
I'm doing that for more than three years

00:02:17,940 --> 00:02:24,870
so I'm around 160 editions so far so I'm

00:02:22,980 --> 00:02:25,890
doing it every Monday so tonight or

00:02:24,870 --> 00:02:28,350
maybe tomorrow

00:02:25,890 --> 00:02:29,490
the next addition there's some book have

00:02:28,350 --> 00:02:31,680
written but that's not really

00:02:29,490 --> 00:02:34,830
interesting for that talk so let's start

00:02:31,680 --> 00:02:38,190
with a talk it's a brand new talk I

00:02:34,830 --> 00:02:40,470
haven't done that before I just worked a

00:02:38,190 --> 00:02:44,010
lot last week on it including the

00:02:40,470 --> 00:02:47,940
weekend so I'm not pretty sure how it

00:02:44,010 --> 00:02:50,310
works out in terms of time so we'll see

00:02:47,940 --> 00:02:52,260
I just have to speak a bit faster but

00:02:50,310 --> 00:02:55,050
it's Monday morning still for me in a

00:02:52,260 --> 00:02:58,050
way so that's maybe hard so let's see so

00:02:55,050 --> 00:03:01,320
what is geofencing geofencing is you

00:02:58,050 --> 00:03:03,420
have a map you have areas on the map you

00:03:01,320 --> 00:03:06,090
have objects which move around and

00:03:03,420 --> 00:03:09,750
you're interested in is an object

00:03:06,090 --> 00:03:12,270
actually entering offense this is the

00:03:09,750 --> 00:03:14,190
fence is it near the fence is it

00:03:12,270 --> 00:03:16,890
entering the fence is it inside the

00:03:14,190 --> 00:03:20,190
fence or is it outside the fence so we

00:03:16,890 --> 00:03:22,380
have a lot of statuses which are it's

00:03:20,190 --> 00:03:25,110
outside then it's entering it it's

00:03:22,380 --> 00:03:28,140
inside it's exiting it and then it's

00:03:25,110 --> 00:03:29,520
outside again so this is pure fencing

00:03:28,140 --> 00:03:32,370
nothing more nothing less

00:03:29,520 --> 00:03:35,220
so you need a capability to have areas

00:03:32,370 --> 00:03:38,430
this is usually static although we will

00:03:35,220 --> 00:03:40,680
see there can also be moving areas but

00:03:38,430 --> 00:03:43,110
at the moment here at the beginning I'll

00:03:40,680 --> 00:03:45,239
just cover static areas or my whole talk

00:03:43,110 --> 00:03:46,440
of cover static areas and we have

00:03:45,239 --> 00:03:47,940
objects moving around

00:03:46,440 --> 00:03:51,540
it could be vehicles it could be

00:03:47,940 --> 00:03:56,010
passengers it could be a person's it

00:03:51,540 --> 00:03:58,110
could be good you deliver and so on and

00:03:56,010 --> 00:04:01,440
you're basically interested in these

00:03:58,110 --> 00:04:05,299
events inside entering exit event

00:04:01,440 --> 00:04:08,070
outside is maybe a bit less important

00:04:05,299 --> 00:04:11,549
what can you do with it you can do a lot

00:04:08,070 --> 00:04:13,980
of things so from delivery space so you

00:04:11,549 --> 00:04:16,650
want to send out which goods and you

00:04:13,980 --> 00:04:18,690
want to optimize that maybe you have sue

00:04:16,650 --> 00:04:21,479
doing some transportation taxiing over

00:04:18,690 --> 00:04:24,570
kind of things transportation management

00:04:21,479 --> 00:04:26,729
logistics you want track valuable goods

00:04:24,570 --> 00:04:29,669
you want to track when they leave your

00:04:26,729 --> 00:04:31,950
your your store and you want to make

00:04:29,669 --> 00:04:34,860
sure that they actually should leave and

00:04:31,950 --> 00:04:37,710
not somebody's dealing your valuable

00:04:34,860 --> 00:04:39,240
goods and so on so here a set of use

00:04:37,710 --> 00:04:44,340
cases I don't won't want to go

00:04:39,240 --> 00:04:46,530
to all of them what is geoprocessing so

00:04:44,340 --> 00:04:49,130
I'm still pretty new into that I would

00:04:46,530 --> 00:04:52,229
say but I was always interested in

00:04:49,130 --> 00:04:55,080
geofencing especially together with

00:04:52,229 --> 00:04:56,520
stream analytics because if you wanted

00:04:55,080 --> 00:04:59,160
to achieve a fencing use case then

00:04:56,520 --> 00:05:01,229
probably you're interested in in

00:04:59,160 --> 00:05:03,270
real-time or near real-time responses if

00:05:01,229 --> 00:05:05,550
something happens on a geofence it's not

00:05:03,270 --> 00:05:06,870
a bad use case where you find out the

00:05:05,550 --> 00:05:10,410
next day that sort of thing happened

00:05:06,870 --> 00:05:12,659
that's too late so there is well-known

00:05:10,410 --> 00:05:14,400
text we will see that that's why I have

00:05:12,659 --> 00:05:16,259
it here and here in the well-known text

00:05:14,400 --> 00:05:20,849
format so there's a format of how you

00:05:16,259 --> 00:05:23,550
can describe objects in geo space and

00:05:20,849 --> 00:05:26,720
you have points points form a line

00:05:23,550 --> 00:05:29,520
string so a route could be a lining

00:05:26,720 --> 00:05:32,460
consisting of multiple points and then

00:05:29,520 --> 00:05:34,650
you have polygons a polygon is an area

00:05:32,460 --> 00:05:37,020
with points I guess you know or the

00:05:34,650 --> 00:05:39,960
polygon is and this is the description

00:05:37,020 --> 00:05:43,349
of that polygon the polygon could also

00:05:39,960 --> 00:05:45,599
be empty in the middle I in my talk I

00:05:43,349 --> 00:05:48,270
only have filled polygons but it would

00:05:45,599 --> 00:05:50,430
work with the other one as well and the

00:05:48,270 --> 00:05:52,469
polygon is basically what you used to to

00:05:50,430 --> 00:05:54,719
specify your geofence it could also be a

00:05:52,469 --> 00:05:56,370
circle often it's even easier if it's a

00:05:54,719 --> 00:05:58,259
circle but of course more interesting

00:05:56,370 --> 00:06:00,840
are polygons because not everything is a

00:05:58,259 --> 00:06:03,509
circle you don't want to build your air

00:06:00,840 --> 00:06:05,610
houses in circles just to do geofencing

00:06:03,509 --> 00:06:08,639
you want to do the geofence according to

00:06:05,610 --> 00:06:10,770
your house or according to your space if

00:06:08,639 --> 00:06:12,900
you're in the java area and that's

00:06:10,770 --> 00:06:14,909
important because if I show you case

00:06:12,900 --> 00:06:16,800
equal then I will show you UDF's

00:06:14,909 --> 00:06:20,639
user-defined functions and there you

00:06:16,800 --> 00:06:24,330
need Java so I need some help in a Java

00:06:20,639 --> 00:06:26,819
space and geo tools is a free GIS

00:06:24,330 --> 00:06:31,830
toolkit which you can use to do

00:06:26,819 --> 00:06:33,810
geo processing each other then Kafka

00:06:31,830 --> 00:06:37,620
quickly it's not an introduction called

00:06:33,810 --> 00:06:39,539
talking to Kafka so we have two Kafka

00:06:37,620 --> 00:06:41,849
broker it's basically a message broker

00:06:39,539 --> 00:06:45,240
highly scalable message broker sitting

00:06:41,849 --> 00:06:47,550
in the middle here and Kafka small Kafka

00:06:45,240 --> 00:06:49,289
is actually streaming platform so Kafka

00:06:47,550 --> 00:06:51,510
can also do stream processing that's

00:06:49,289 --> 00:06:52,919
where we are where we have case equals

00:06:51,510 --> 00:06:54,870
so case equal I

00:06:52,919 --> 00:06:57,960
I will use to do the stream processing

00:06:54,870 --> 00:07:00,360
and K sequel is always consuming from

00:06:57,960 --> 00:07:03,779
cough current producing back into Kafka

00:07:00,360 --> 00:07:05,610
and K sequel sits on top of Kafka

00:07:03,779 --> 00:07:11,669
streams we will see that later as well

00:07:05,610 --> 00:07:13,439
and Kafka streams you you use Java to

00:07:11,669 --> 00:07:15,900
actually develop with it and with K

00:07:13,439 --> 00:07:17,099
sequel you have sequel like language

00:07:15,900 --> 00:07:19,439
which you can use to do stream

00:07:17,099 --> 00:07:21,689
processing so it's a quite or it's a

00:07:19,439 --> 00:07:24,749
rather quick and easy approach to do

00:07:21,689 --> 00:07:26,599
stream processing and then we have the

00:07:24,749 --> 00:07:29,069
green parts the green parts are actually

00:07:26,599 --> 00:07:30,990
Kafka connected so this is the interface

00:07:29,069 --> 00:07:33,229
to the outside world not everything is

00:07:30,990 --> 00:07:37,439
in Kafka of course if we talk about

00:07:33,229 --> 00:07:39,389
position messages position messages from

00:07:37,439 --> 00:07:42,599
vehicles then you can either send them

00:07:39,389 --> 00:07:46,349
directly to Kafka or maybe they reside

00:07:42,599 --> 00:07:48,240
in an MQTT broker and you want a bridge

00:07:46,349 --> 00:07:50,879
from mqtt to cough card then you could

00:07:48,240 --> 00:07:54,240
use a source connector to do that we

00:07:50,879 --> 00:07:58,289
will see later a sink connector in

00:07:54,240 --> 00:08:02,460
action to actually integrate the tile 38

00:07:58,289 --> 00:08:05,580
in the second part of the talk the use

00:08:02,460 --> 00:08:10,259
case I will present some water it's too

00:08:05,580 --> 00:08:14,219
hot here the use case I will present is

00:08:10,259 --> 00:08:17,639
quite simple we have vehicles or objects

00:08:14,219 --> 00:08:19,919
they just publish their position and we

00:08:17,639 --> 00:08:22,770
have geofences so the geofences are more

00:08:19,919 --> 00:08:25,500
static of course you could also think

00:08:22,770 --> 00:08:27,449
about a more dynamic approach where the

00:08:25,500 --> 00:08:30,689
weather service is actually providing

00:08:27,449 --> 00:08:33,089
you geofences about weather conditions

00:08:30,689 --> 00:08:35,370
where where it's dangerous maybe and you

00:08:33,089 --> 00:08:37,140
want to add them dynamically to geofence

00:08:35,370 --> 00:08:39,979
so the solution should cover that as

00:08:37,140 --> 00:08:42,839
well and then you basically want to join

00:08:39,979 --> 00:08:43,709
your position each position to all the

00:08:42,839 --> 00:08:45,060
geofences

00:08:43,709 --> 00:08:46,709
that's basically what you want to do and

00:08:45,060 --> 00:08:50,279
then you want to check is this pose is

00:08:46,709 --> 00:08:53,100
this object inside outside and so on and

00:08:50,279 --> 00:08:55,920
then you want to publish it as an event

00:08:53,100 --> 00:08:58,920
and maybe show it on a dashboard so what

00:08:55,920 --> 00:09:00,839
I will do now is by first using case

00:08:58,920 --> 00:09:03,540
equal I will show you step by step how

00:09:00,839 --> 00:09:06,410
you can implement that and I will also

00:09:03,540 --> 00:09:09,320
show you some steps which don't work

00:09:06,410 --> 00:09:11,060
I in some areas I really went that path

00:09:09,320 --> 00:09:13,040
and then I thought about who I have I

00:09:11,060 --> 00:09:14,960
thought about that path and I think it's

00:09:13,040 --> 00:09:17,360
important or interesting to document it

00:09:14,960 --> 00:09:20,570
and in some areas I'm just doing it so

00:09:17,360 --> 00:09:24,170
it's it builds step by step the whole

00:09:20,570 --> 00:09:26,480
solution is built step by step okay Kay

00:09:24,170 --> 00:09:29,900
sequel as I already mentioned Kay sequel

00:09:26,480 --> 00:09:32,900
is a it's the capability of doing stream

00:09:29,900 --> 00:09:35,120
processing in Kafka so you always read

00:09:32,900 --> 00:09:36,650
from a topic and you produce it back to

00:09:35,120 --> 00:09:39,320
your topic it sits on top of Kafka

00:09:36,650 --> 00:09:42,050
streams the Java library and it's just

00:09:39,320 --> 00:09:44,570
simplifies your work because you if you

00:09:42,050 --> 00:09:47,660
already know sequel it's a very simple

00:09:44,570 --> 00:09:49,850
similar dialect it's it's using sequel

00:09:47,660 --> 00:09:52,940
or the sequel dialect and it's just

00:09:49,850 --> 00:09:55,730
called cold case equal and you have two

00:09:52,940 --> 00:09:58,220
important concept in case equal one is

00:09:55,730 --> 00:10:01,310
streams or stream and the other one is

00:09:58,220 --> 00:10:04,730
table stream is your event stream that's

00:10:01,310 --> 00:10:06,560
your unbounded data so the facts are

00:10:04,730 --> 00:10:08,840
immutable when you get a fact it's an

00:10:06,560 --> 00:10:13,640
event based or it's it's an event kind

00:10:08,840 --> 00:10:16,970
and it cannot change so a position is an

00:10:13,640 --> 00:10:18,770
event a position at a certain amount of

00:10:16,970 --> 00:10:20,720
time or a certain second that your event

00:10:18,770 --> 00:10:23,270
and maybe a second later you get a new

00:10:20,720 --> 00:10:27,110
position so this is a new event so this

00:10:23,270 --> 00:10:30,500
is a stream a table is a collected state

00:10:27,110 --> 00:10:32,750
of a stream the source of a table is

00:10:30,500 --> 00:10:35,360
still a street it still is still a Kafka

00:10:32,750 --> 00:10:40,310
topic so in event stream but now we only

00:10:35,360 --> 00:10:43,490
keep the last value by key if you know

00:10:40,310 --> 00:10:45,680
Kafka you know that message is always

00:10:43,490 --> 00:10:48,800
consisting of a key and the value

00:10:45,680 --> 00:10:52,430
and if you want to work with tables you

00:10:48,800 --> 00:10:55,520
have to provide a key you can if you

00:10:52,430 --> 00:10:57,050
create that table you can map a value to

00:10:55,520 --> 00:10:57,320
the key you will just see that in a

00:10:57,050 --> 00:11:00,170
minute

00:10:57,320 --> 00:11:03,620
or in almost a second and that's very

00:11:00,170 --> 00:11:07,190
important so you only keep the last

00:11:03,620 --> 00:11:10,850
value the last state of a given object

00:11:07,190 --> 00:11:13,640
for example so this is what I will use

00:11:10,850 --> 00:11:16,130
for the geofences because the geofence

00:11:13,640 --> 00:11:19,130
has an ID and I'm only interested in the

00:11:16,130 --> 00:11:19,640
latest kind of value for HG events and

00:11:19,130 --> 00:11:20,960
all

00:11:19,640 --> 00:11:23,120
of course these geo fences will not

00:11:20,960 --> 00:11:27,920
change they'll they are very fixed very

00:11:23,120 --> 00:11:30,920
static so to begin what I need is I need

00:11:27,920 --> 00:11:33,230
a stream and I need a table or I will

00:11:30,920 --> 00:11:35,300
define a stream and the table the

00:11:33,230 --> 00:11:37,730
vehicle position so the CHEO positions

00:11:35,300 --> 00:11:40,430
the positions of the vehicles these are

00:11:37,730 --> 00:11:43,010
a stream so I'm doing create stream I

00:11:40,430 --> 00:11:46,100
specify the name of the stream and then

00:11:43,010 --> 00:11:48,890
the datatypes and on which topic on

00:11:46,100 --> 00:11:53,360
which kafka topic that stream should sit

00:11:48,890 --> 00:11:56,600
and in that case this is not really the

00:11:53,360 --> 00:11:58,970
hundred percent correct implementation

00:11:56,600 --> 00:12:01,160
but it works as well so this is the

00:11:58,970 --> 00:12:02,870
delimited version in my real

00:12:01,160 --> 00:12:05,960
implementation I'm using over all here

00:12:02,870 --> 00:12:08,690
so I copied the wrong statement over but

00:12:05,960 --> 00:12:10,640
you can see if I using delimited and

00:12:08,690 --> 00:12:13,730
delimit is basically comma separated the

00:12:10,640 --> 00:12:17,750
CSV format in your message then you have

00:12:13,730 --> 00:12:19,820
to specify the values because it's just

00:12:17,750 --> 00:12:21,920
doing the mapping so by using that

00:12:19,820 --> 00:12:24,380
create stream you basically bring

00:12:21,920 --> 00:12:27,020
structure to cough cough because cough

00:12:24,380 --> 00:12:30,050
car is just bites when you transport it

00:12:27,020 --> 00:12:33,830
over message broker and using the create

00:12:30,050 --> 00:12:37,400
stream a statement you basically specify

00:12:33,830 --> 00:12:40,160
what is the structure in that topic and

00:12:37,400 --> 00:12:42,020
then we have the geofence table and the

00:12:40,160 --> 00:12:44,000
geofence table sits on the topic

00:12:42,020 --> 00:12:46,520
geofence so this is the geofence topic

00:12:44,000 --> 00:12:49,220
which I'm using here I'm using Jason and

00:12:46,520 --> 00:12:52,040
I can specify which fields of the Jason

00:12:49,220 --> 00:12:53,840
message I want to provide as a table and

00:12:52,040 --> 00:12:57,800
what's important here is now the key

00:12:53,840 --> 00:13:00,860
it's keyed by ID so the ID determines

00:12:57,800 --> 00:13:02,540
which one determines kind of the

00:13:00,860 --> 00:13:07,310
grouping and just the latest value is

00:13:02,540 --> 00:13:09,350
kept so now how can i determine inside

00:13:07,310 --> 00:13:10,910
or outside of a geofence oh i have now

00:13:09,350 --> 00:13:14,150
to cheer friends in the table i have

00:13:10,910 --> 00:13:16,580
positions and i want to determine is it

00:13:14,150 --> 00:13:19,580
inside or outside there are some or

00:13:16,580 --> 00:13:21,680
there there are functions in encase

00:13:19,580 --> 00:13:23,780
equal there are functions for

00:13:21,680 --> 00:13:25,730
geoprocessing but there is only one it's

00:13:23,780 --> 00:13:28,580
called geo distance so you can basically

00:13:25,730 --> 00:13:30,590
define or or measure the distance

00:13:28,580 --> 00:13:32,410
between two points but there's no

00:13:30,590 --> 00:13:34,779
contains

00:13:32,410 --> 00:13:37,899
method but what you have you can

00:13:34,779 --> 00:13:40,600
basically extend the functions of K

00:13:37,899 --> 00:13:43,420
sequel by using user-defined function as

00:13:40,600 --> 00:13:45,279
you can do in all more or less sequel

00:13:43,420 --> 00:13:47,079
kind languages that you have a

00:13:45,279 --> 00:13:48,819
capability to extend it with your own

00:13:47,079 --> 00:13:51,250
functions at the moment this is just

00:13:48,819 --> 00:13:53,769
Java so you have to basically implement

00:13:51,250 --> 00:13:57,490
a function in Java and then you can

00:13:53,769 --> 00:13:59,589
register it as in as in UDF you can also

00:13:57,490 --> 00:14:02,350
define user-defined aggregate functions

00:13:59,589 --> 00:14:07,180
but here for the contains is a point

00:14:02,350 --> 00:14:09,310
inside a geometry or a polygon that's

00:14:07,180 --> 00:14:11,709
good enough to use it user-defined

00:14:09,310 --> 00:14:14,170
function so I have two functions here

00:14:11,709 --> 00:14:15,670
one is to offense using latitude

00:14:14,170 --> 00:14:21,629
longitude so this is my point

00:14:15,670 --> 00:14:24,459
and a geometry just using this wkt

00:14:21,629 --> 00:14:26,230
format I've shown before so I'm just

00:14:24,459 --> 00:14:28,180
passing a string what you can see here

00:14:26,230 --> 00:14:29,949
as a polygon and I'm just passing a

00:14:28,180 --> 00:14:32,350
string of course it's much longer if

00:14:29,949 --> 00:14:35,709
it's a large polygon so it will go on

00:14:32,350 --> 00:14:38,920
and then I'm getting back an outside or

00:14:35,709 --> 00:14:42,790
inside depending on the latitude or

00:14:38,920 --> 00:14:45,189
longitude I also have a bulk version

00:14:42,790 --> 00:14:47,769
where I can pass latitude longitude and

00:14:45,189 --> 00:14:49,959
the list of polygons you will see that

00:14:47,769 --> 00:14:53,079
later wider isn't is it already is

00:14:49,959 --> 00:14:54,910
necessarily necessary it's because it's

00:14:53,079 --> 00:14:58,439
Java it's quite simple to implement it

00:14:54,910 --> 00:15:00,819
all you need to know is is the Geo tools

00:14:58,439 --> 00:15:03,730
library so I'm using the Geo tools here

00:15:00,819 --> 00:15:06,209
and you have to know how that works so

00:15:03,730 --> 00:15:10,149
I'm using some code here to actually

00:15:06,209 --> 00:15:12,810
transform the wkt into a polygon and

00:15:10,149 --> 00:15:15,279
then I have the receipt to the within

00:15:12,810 --> 00:15:17,470
function so I can test if a point is

00:15:15,279 --> 00:15:19,389
within a polygon and the point of course

00:15:17,470 --> 00:15:21,730
I have to create as well based on the

00:15:19,389 --> 00:15:24,850
coordinates I get into here you cannot

00:15:21,730 --> 00:15:28,389
pass into a UDF objects you can only

00:15:24,850 --> 00:15:30,220
pass scalar as well as lists but you

00:15:28,389 --> 00:15:34,629
cannot pass your own objects that's why

00:15:30,220 --> 00:15:37,930
I can't pass a point into the UDF UDF on

00:15:34,629 --> 00:15:40,059
the method level so it's quite simple a

00:15:37,930 --> 00:15:42,519
few lines of code and by that you can

00:15:40,059 --> 00:15:45,189
easily extend the capability of case

00:15:42,519 --> 00:15:46,350
equal as you can do in other sequel

00:15:45,189 --> 00:15:47,730
languages as well

00:15:46,350 --> 00:15:50,940
so for that of course you have to be a

00:15:47,730 --> 00:15:53,700
Java programmer but if assume that is

00:15:50,940 --> 00:15:55,940
that UDF is register and all you have to

00:15:53,700 --> 00:15:58,200
do is just package it package it and

00:15:55,940 --> 00:16:00,420
deploy it to the right place

00:15:58,200 --> 00:16:02,310
to the right folder restart the case

00:16:00,420 --> 00:16:04,650
equal server and it will pick it up

00:16:02,310 --> 00:16:08,520
automatically and it's available so now

00:16:04,650 --> 00:16:10,860
let's use it before I can use it of

00:16:08,520 --> 00:16:11,430
course I need to bring the values

00:16:10,860 --> 00:16:14,250
together

00:16:11,430 --> 00:16:15,900
I need the polygons and I need the point

00:16:14,250 --> 00:16:19,520
as you have seen otherwise I cannot call

00:16:15,900 --> 00:16:22,770
the UDF so my first approach was

00:16:19,520 --> 00:16:24,480
probably bit naive but I'm a I have a

00:16:22,770 --> 00:16:27,360
huge background it with our DBMS

00:16:24,480 --> 00:16:30,450
relational databases and this is an I

00:16:27,360 --> 00:16:32,400
think this is a maybe a problem you

00:16:30,450 --> 00:16:35,130
could get into if you have that you

00:16:32,400 --> 00:16:38,070
immediately think about sequel it's case

00:16:35,130 --> 00:16:39,540
equal its sequel like so why not doing a

00:16:38,070 --> 00:16:41,700
cross join because that's what you

00:16:39,540 --> 00:16:43,650
really want you have a stream or I mean

00:16:41,700 --> 00:16:45,420
you have one position and all you want

00:16:43,650 --> 00:16:48,120
to do is check it against all the

00:16:45,420 --> 00:16:52,140
polygons you have so the cross join

00:16:48,120 --> 00:16:54,870
would be what you do in in enormous

00:16:52,140 --> 00:16:58,620
equal but that's not possible you don't

00:16:54,870 --> 00:17:01,020
have cross joining case equal the next

00:16:58,620 --> 00:17:04,709
step was I thought about why not doing

00:17:01,020 --> 00:17:05,220
in any inner join and for doing an inner

00:17:04,709 --> 00:17:08,400
join

00:17:05,220 --> 00:17:10,560
I just specify or I just provide some

00:17:08,400 --> 00:17:13,770
kind of artificial grouping I just say

00:17:10,560 --> 00:17:18,650
every every latitude longitude or Eve

00:17:13,770 --> 00:17:18,650
position belongs to group 1 and I'm also

00:17:19,370 --> 00:17:24,959
I'm also extending all the polygons with

00:17:23,100 --> 00:17:28,439
that Group 1 so I'm just saying all the

00:17:24,959 --> 00:17:30,210
polygons in one group and all the the

00:17:28,439 --> 00:17:32,970
vehicles are in one group and then I

00:17:30,210 --> 00:17:36,660
thought I can I can join it using an

00:17:32,970 --> 00:17:39,180
inner join but that also doesn't work I

00:17:36,660 --> 00:17:41,250
mean that doesn't work in in if the

00:17:39,180 --> 00:17:43,500
problem is not in the joint problem

00:17:41,250 --> 00:17:48,890
already starts here if I want an extend

00:17:43,500 --> 00:17:53,120
a stream before I insert it into a table

00:17:48,890 --> 00:17:55,680
then that will that fails as well but

00:17:53,120 --> 00:17:58,440
it's actually good that it fails because

00:17:55,680 --> 00:18:00,150
it will would also not work later on

00:17:58,440 --> 00:18:04,380
because what I already say

00:18:00,150 --> 00:18:06,840
it a key or a tables already key is

00:18:04,380 --> 00:18:09,720
always key and only one value will

00:18:06,840 --> 00:18:12,600
survive so let's say let's now see if I

00:18:09,720 --> 00:18:15,690
have like all the polygons in Group one

00:18:12,600 --> 00:18:18,120
and I would use them Group one as the

00:18:15,690 --> 00:18:20,640
key only one polygon would arrive the

00:18:18,120 --> 00:18:23,910
latest one the last one so this is not a

00:18:20,640 --> 00:18:26,880
good approach as well so you cannot do

00:18:23,910 --> 00:18:30,750
insert into table so that's that's the

00:18:26,880 --> 00:18:32,850
the problem before actually the join but

00:18:30,750 --> 00:18:34,500
even if I would have be able to do it in

00:18:32,850 --> 00:18:36,840
the join it will also not work because I

00:18:34,500 --> 00:18:41,610
would only have one polygon I actually

00:18:36,840 --> 00:18:43,500
tried to do all that stuff before in the

00:18:41,610 --> 00:18:45,810
database I had a database first and I

00:18:43,500 --> 00:18:47,820
try to do some joins in the database I

00:18:45,810 --> 00:18:50,250
thought that one clever and I'm just

00:18:47,820 --> 00:18:53,100
providing it exactly as it is here

00:18:50,250 --> 00:18:54,870
already from the database and I don't I

00:18:53,100 --> 00:18:57,090
don't need that enrichment group and I

00:18:54,870 --> 00:18:59,220
have the table here but I failed because

00:18:57,090 --> 00:19:02,940
yeah only one value will survive I only

00:18:59,220 --> 00:19:05,220
had one polygon at the end left so

00:19:02,940 --> 00:19:07,290
that's not a good idea either and what

00:19:05,220 --> 00:19:10,020
you can also not do is you cannot do one

00:19:07,290 --> 00:19:14,040
to end joints so one stream cannot be

00:19:10,020 --> 00:19:19,800
joined to multiple polygons that's not

00:19:14,040 --> 00:19:23,130
possible so the next approach and that's

00:19:19,800 --> 00:19:25,530
not where it starts to work or that that

00:19:23,130 --> 00:19:28,890
one actually works is still with the

00:19:25,530 --> 00:19:31,500
grouping so the grouping is is still

00:19:28,890 --> 00:19:33,510
done but I still have a stream here and

00:19:31,500 --> 00:19:35,580
then I do an aggregation and the

00:19:33,510 --> 00:19:38,900
aggregation is important that I can

00:19:35,580 --> 00:19:42,000
actually create the table after that and

00:19:38,900 --> 00:19:44,700
what I'm doing I still have all the

00:19:42,000 --> 00:19:47,310
polygons in Group one I still have all

00:19:44,700 --> 00:19:50,880
the the positions coming from the stream

00:19:47,310 --> 00:19:52,230
in Group one but now I'm doing before

00:19:50,880 --> 00:19:55,170
I'm doing a join I'm doing an

00:19:52,230 --> 00:19:56,700
aggregation by group so that is wrong is

00:19:55,170 --> 00:19:59,520
not aggregate by vehicle first had a

00:19:56,700 --> 00:20:02,040
vehicle but now I'm doing it by group so

00:19:59,520 --> 00:20:06,600
this is aggregation by group and what I

00:20:02,040 --> 00:20:09,890
get out of it is one row with Group 1

00:20:06,600 --> 00:20:14,100
this is also the key and a list of

00:20:09,890 --> 00:20:15,960
polygons so a rather long list

00:20:14,100 --> 00:20:18,900
of all the polygons of all night

00:20:15,960 --> 00:20:22,590
geofences I have defined are grouped

00:20:18,900 --> 00:20:26,340
together into one list and now because I

00:20:22,590 --> 00:20:29,010
only have one record left or one event

00:20:26,340 --> 00:20:33,780
left or one item left in that table I

00:20:29,010 --> 00:20:36,240
can join it with the stream and that's

00:20:33,780 --> 00:20:39,120
why I'm kneading the geofence bulk

00:20:36,240 --> 00:20:42,300
because now I have a list of polygons I

00:20:39,120 --> 00:20:45,270
have one position I join it together and

00:20:42,300 --> 00:20:47,430
then I call the UDF with the poly weight

00:20:45,270 --> 00:20:50,250
the position and all the polygons and

00:20:47,430 --> 00:20:53,100
the UDF is just looping through the list

00:20:50,250 --> 00:20:58,110
and checks each single polygon is it

00:20:53,100 --> 00:21:00,260
inside or outside I will come back to

00:20:58,110 --> 00:21:03,420
that that is actually the kind of the

00:21:00,260 --> 00:21:05,910
the definition or the rating of the

00:21:03,420 --> 00:21:08,790
solution but maybe first some code here

00:21:05,910 --> 00:21:10,560
as well just to give you an idea how it

00:21:08,790 --> 00:21:14,970
actually works I already explained it on

00:21:10,560 --> 00:21:17,640
kind of text form so this one here is

00:21:14,970 --> 00:21:20,760
the group by group ID so this is the the

00:21:17,640 --> 00:21:23,940
upper part where I do a collect set and

00:21:20,760 --> 00:21:26,220
the collect set is actually doing the

00:21:23,940 --> 00:21:29,610
work of just adding all the polygons

00:21:26,220 --> 00:21:32,130
together and because after if I only

00:21:29,610 --> 00:21:34,800
have one set I still want to know the ID

00:21:32,130 --> 00:21:36,960
of the the polygon that's why I'm

00:21:34,800 --> 00:21:40,760
comparing it together using the double

00:21:36,960 --> 00:21:44,550
point the column as a separator the

00:21:40,760 --> 00:21:47,400
enrichment of the stream is quite simple

00:21:44,550 --> 00:21:50,640
of the vehicle position stream it's just

00:21:47,400 --> 00:21:52,650
an create an auto stream as select from

00:21:50,640 --> 00:21:55,260
the vehicle position so vehicle position

00:21:52,650 --> 00:21:57,750
is my initial stream and I'm just

00:21:55,260 --> 00:22:00,750
enriching it and creating a new stream

00:21:57,750 --> 00:22:05,010
and what I'm doing is just adding that

00:22:00,750 --> 00:22:07,470
Group one and now with that I have the

00:22:05,010 --> 00:22:10,080
the grouped by as a table so this is a

00:22:07,470 --> 00:22:12,390
create table I select proved by and that

00:22:10,080 --> 00:22:13,860
works the insert into table doesn't work

00:22:12,390 --> 00:22:16,110
as I mentioned before but the create

00:22:13,860 --> 00:22:19,590
table I select works from a stream and

00:22:16,110 --> 00:22:21,090
the create stream statements these two

00:22:19,590 --> 00:22:24,600
together is two objects together

00:22:21,090 --> 00:22:26,640
I can now join and the good part of case

00:22:24,600 --> 00:22:27,750
equal because it's sequel dialect if you

00:22:26,640 --> 00:22:29,730
know sequel

00:22:27,750 --> 00:22:31,350
it's very easy to join because it

00:22:29,730 --> 00:22:34,230
doesn't really change a lot from

00:22:31,350 --> 00:22:35,520
relational so except of yeah of course

00:22:34,230 --> 00:22:37,380
of the semantics what you can do and

00:22:35,520 --> 00:22:41,010
what he can't do but this is that this

00:22:37,380 --> 00:22:43,770
syntax is the same you can't really see

00:22:41,010 --> 00:22:45,960
if this is a database or if its case

00:22:43,770 --> 00:22:49,290
equal so what I'm doing I'm joining

00:22:45,960 --> 00:22:51,600
vehicle position left joint to the to

00:22:49,290 --> 00:22:54,140
this aggregation by group showing you

00:22:51,600 --> 00:22:56,550
before and I'm calling the geofence bulk

00:22:54,140 --> 00:23:00,150
providing latitude longitude and that

00:22:56,550 --> 00:23:02,460
list of geometries so now what I'm

00:23:00,150 --> 00:23:05,880
getting back is I'm getting back for

00:23:02,460 --> 00:23:09,630
each geometry so in that case I only

00:23:05,880 --> 00:23:12,750
have to I get an out outside or inside

00:23:09,630 --> 00:23:17,040
the status for each geometry over each

00:23:12,750 --> 00:23:20,370
polygon and passing so this is my first

00:23:17,040 --> 00:23:22,860
approach for doing geofencing the

00:23:20,370 --> 00:23:26,250
problem here as you might already think

00:23:22,860 --> 00:23:29,760
about this is quite a challenge if you

00:23:26,250 --> 00:23:33,180
have a lot of geofences because it will

00:23:29,760 --> 00:23:37,140
just grow to the right as many as

00:23:33,180 --> 00:23:39,390
they're geofences you also get a list

00:23:37,140 --> 00:23:40,590
back of status information you have to

00:23:39,390 --> 00:23:45,780
treat that as well

00:23:40,590 --> 00:23:48,660
you have to yeah unless tit but that

00:23:45,780 --> 00:23:51,900
could be the client doing it but the

00:23:48,660 --> 00:23:56,430
problem is more it's just a lot and

00:23:51,900 --> 00:23:59,580
because you only have one one entry in

00:23:56,430 --> 00:24:02,670
the table to your friends aggregated by

00:23:59,580 --> 00:24:06,060
group it's also not very scalable that's

00:24:02,670 --> 00:24:08,850
why if I go back scalable is very low

00:24:06,060 --> 00:24:12,420
latency medium because I'm doing the

00:24:08,850 --> 00:24:16,260
bulk operation so I'm slow a slow down a

00:24:12,420 --> 00:24:19,310
little bit the whole process code smell

00:24:16,260 --> 00:24:21,330
is just meaning how good is the

00:24:19,310 --> 00:24:23,430
implementation you could also say a

00:24:21,330 --> 00:24:26,070
solution smell or architecture smell but

00:24:23,430 --> 00:24:28,860
code smell is is what we know or we

00:24:26,070 --> 00:24:31,590
would we know so how can we do it better

00:24:28,860 --> 00:24:34,440
or can we do it better we can do it

00:24:31,590 --> 00:24:36,990
better by introducing geohashes I'm not

00:24:34,440 --> 00:24:40,550
sure if you all know about Chu hashing

00:24:36,990 --> 00:24:40,550
to your hashing is basically a way

00:24:40,760 --> 00:24:50,300
200 Chea coat and coordinate or also a

00:24:45,840 --> 00:24:54,770
polygon so the whole world is actually

00:24:50,300 --> 00:24:59,720
separated or splitted into these

00:24:54,770 --> 00:25:03,330
quarters and depending on on the

00:24:59,720 --> 00:25:05,730
resolution they are smaller or larger so

00:25:03,330 --> 00:25:09,450
if you want to have a chi or hash with

00:25:05,730 --> 00:25:12,090
length one you get very large area if

00:25:09,450 --> 00:25:15,660
it's of length 3 it's already much

00:25:12,090 --> 00:25:19,080
smaller 156 kilometers

00:25:15,660 --> 00:25:20,730
156 kilometers and here I'm sure she so

00:25:19,080 --> 00:25:25,560
in Berlin because we're here

00:25:20,730 --> 00:25:29,100
so Berlin in in in for lengths for or

00:25:25,560 --> 00:25:31,260
these sizes and lengths 3 or resizes so

00:25:29,100 --> 00:25:34,050
if I would have a geofence around Berlin

00:25:31,260 --> 00:25:37,890
that geofence would just be if I'm using

00:25:34,050 --> 00:25:42,120
geo hash length 3 the whole polygon

00:25:37,890 --> 00:25:45,270
would be in one geo hash and if I using

00:25:42,120 --> 00:25:49,680
larger resolution lengths for then maybe

00:25:45,270 --> 00:25:55,410
a geofence could be in for geohashes so

00:25:49,680 --> 00:25:58,230
the overlap I'm also that's not there's

00:25:55,410 --> 00:26:01,920
no UTF for no function built-in into

00:25:58,230 --> 00:26:05,370
case equal so I just built my own UDF

00:26:01,920 --> 00:26:07,860
for two hashes as well again using a

00:26:05,370 --> 00:26:09,600
Java library which actually does all the

00:26:07,860 --> 00:26:13,020
work and I'm just calling Java library

00:26:09,600 --> 00:26:15,390
and by that I have capabilities to to

00:26:13,020 --> 00:26:16,920
space to get the geo hash so that's one

00:26:15,390 --> 00:26:21,150
thing I want to do with the lengths or

00:26:16,920 --> 00:26:23,700
resolution and I can also create a Chia

00:26:21,150 --> 00:26:26,040
hash list for the covering bounding box

00:26:23,700 --> 00:26:28,140
around the geometry around the polygon

00:26:26,040 --> 00:26:30,990
so I have a polygon I have a geofence

00:26:28,140 --> 00:26:33,660
and by that I can just determine how

00:26:30,990 --> 00:26:37,830
many geohashes do I need to actually

00:26:33,660 --> 00:26:43,320
cover the whole polygon and here you can

00:26:37,830 --> 00:26:45,570
see how it's called as an example and so

00:26:43,320 --> 00:26:47,340
this is now the the one with the two

00:26:45,570 --> 00:26:49,950
hash and the chuma tree so with a

00:26:47,340 --> 00:26:52,770
polygon I'm just getting back with

00:26:49,950 --> 00:26:55,190
lengths 5 I'm getting back a list of

00:26:52,770 --> 00:26:58,320
geohashes

00:26:55,190 --> 00:27:00,029
and how do they help they help and

00:26:58,320 --> 00:27:02,850
that's why I showed the group by

00:27:00,029 --> 00:27:04,850
grouping before they show they help in a

00:27:02,850 --> 00:27:08,159
similar way but now instead of just

00:27:04,850 --> 00:27:11,669
providing one single group I'm extending

00:27:08,159 --> 00:27:15,720
I'm enriching both the stream as well as

00:27:11,669 --> 00:27:19,289
the the Chia fences fences spider to

00:27:15,720 --> 00:27:21,299
your hash in that case in a point it's

00:27:19,289 --> 00:27:23,549
always only one two your hash because

00:27:21,299 --> 00:27:27,270
there's one point and it's only be links

00:27:23,549 --> 00:27:30,029
to one geo hash independent of the

00:27:27,270 --> 00:27:33,779
resolution here I'm using length three

00:27:30,029 --> 00:27:35,789
and force the lengths is basically you

00:27:33,779 --> 00:27:37,799
have to tune it according to the size of

00:27:35,789 --> 00:27:40,590
your geo fences if you have very small

00:27:37,799 --> 00:27:44,220
geofencing you might want to go larger

00:27:40,590 --> 00:27:46,649
if you have larger geo fences yeah you

00:27:44,220 --> 00:27:49,140
just have to have to tune it so now what

00:27:46,649 --> 00:27:52,679
I'm doing is I'm extending it here so

00:27:49,140 --> 00:27:58,950
what I get back is I get back the Geo

00:27:52,679 --> 00:28:02,360
hash for a certain geo fence and then

00:27:58,950 --> 00:28:05,820
I'm doing again a group by a group by

00:28:02,360 --> 00:28:08,039
the CHEO hash so it's now no longer a

00:28:05,820 --> 00:28:10,950
group with only a group by with only one

00:28:08,039 --> 00:28:14,700
group it's a group by with lots of

00:28:10,950 --> 00:28:17,399
groups just as many polygons as you have

00:28:14,700 --> 00:28:20,010
and how separated there are over the

00:28:17,399 --> 00:28:23,279
world and depending also of course how

00:28:20,010 --> 00:28:26,279
how small your resolution is or how big

00:28:23,279 --> 00:28:28,919
your resolution is and then again I'm

00:28:26,279 --> 00:28:31,470
doing the joint but now the join on Geo

00:28:28,919 --> 00:28:34,020
hash and no longer group and by that I

00:28:31,470 --> 00:28:36,899
can now make sure that the solution gets

00:28:34,020 --> 00:28:41,159
scalable because that's how the

00:28:36,899 --> 00:28:42,870
scalability works in cough cough because

00:28:41,159 --> 00:28:46,080
then at the end you have different

00:28:42,870 --> 00:28:49,470
partitions underneath and Kafka and Kay

00:28:46,080 --> 00:28:51,929
sequel is joining on a partition level

00:28:49,470 --> 00:28:53,580
and if you're multiple machines then

00:28:51,929 --> 00:28:58,529
multiple machines can actually do do

00:28:53,580 --> 00:29:04,760
work and if we check the code the code

00:28:58,529 --> 00:29:07,740
works like that I have I have my

00:29:04,760 --> 00:29:11,100
geocache with geometry I get a list

00:29:07,740 --> 00:29:12,570
of geohashes back so have a lot of maybe

00:29:11,100 --> 00:29:14,400
one to your hatch but it could also be

00:29:12,570 --> 00:29:16,910
multiple depending on the resolution

00:29:14,400 --> 00:29:20,000
until the size of the polygon and

00:29:16,910 --> 00:29:22,020
because case equal has no explode

00:29:20,000 --> 00:29:25,290
functionality and you can read more

00:29:22,020 --> 00:29:28,350
about here you have to do it a bit in a

00:29:25,290 --> 00:29:31,740
pure in a poorly way but you can do it

00:29:28,350 --> 00:29:34,429
it's a bit static so what you have to do

00:29:31,740 --> 00:29:38,370
is you have to just do it for the first

00:29:34,429 --> 00:29:41,040
entry in the in the array and you get

00:29:38,370 --> 00:29:42,570
that geo hash and add it to the stream

00:29:41,040 --> 00:29:44,460
and then you have to do it with an

00:29:42,570 --> 00:29:47,160
insert for the second one and insert for

00:29:44,460 --> 00:29:48,900
the third one and so on so that is

00:29:47,160 --> 00:29:51,900
static at the moment this is a bit the

00:29:48,900 --> 00:29:53,910
problem of of the solution so you have

00:29:51,900 --> 00:29:57,600
to know basically how many entries can

00:29:53,910 --> 00:29:59,700
you get back and tune it to that but I

00:29:57,600 --> 00:30:02,940
hope this is only a matter of time until

00:29:59,700 --> 00:30:09,179
we get explode functionality in case

00:30:02,940 --> 00:30:16,050
equal and then based on that I can do

00:30:09,179 --> 00:30:18,420
again the aggregation and in a similar

00:30:16,050 --> 00:30:22,620
way as before but now I have the CHEO

00:30:18,420 --> 00:30:25,100
hash with the joined later but the idea

00:30:22,620 --> 00:30:27,750
is the same I'm doing the CHEO hash

00:30:25,100 --> 00:30:30,030
enrichment for the stream similar to

00:30:27,750 --> 00:30:31,830
before and of course the resolution has

00:30:30,030 --> 00:30:35,250
to be the same otherwise we cannot join

00:30:31,830 --> 00:30:37,650
the stuff and then here is the join with

00:30:35,250 --> 00:30:41,490
the geofence bulk so I'm still having a

00:30:37,650 --> 00:30:44,910
list of because I'm aggregating so I

00:30:41,490 --> 00:30:48,840
still get a list of polygons and I join

00:30:44,910 --> 00:30:51,179
em together and now I get a similar

00:30:48,840 --> 00:30:53,429
result as before but now the size of

00:30:51,179 --> 00:30:55,590
course is not always the same the size

00:30:53,429 --> 00:30:58,590
really just depends on how many cheer

00:30:55,590 --> 00:31:02,010
fences you have in pergurt

00:30:58,590 --> 00:31:05,670
paper geocache and of course that's

00:31:02,010 --> 00:31:09,330
quite important in terms of how scalable

00:31:05,670 --> 00:31:11,280
solution is and that's why if I go back

00:31:09,330 --> 00:31:13,830
sorry I always have that on the first

00:31:11,280 --> 00:31:16,590
slide so that's why here the scalability

00:31:13,830 --> 00:31:18,210
of the solution is high latency is

00:31:16,590 --> 00:31:21,630
medium because we still have the bulk

00:31:18,210 --> 00:31:25,020
operation in it and code smell is medium

00:31:21,630 --> 00:31:27,150
because we have this kind of self-made

00:31:25,020 --> 00:31:29,690
explode functionality which is not so

00:31:27,150 --> 00:31:32,010
nice because it's freezing some static

00:31:29,690 --> 00:31:34,470
functionality inside it so we have to

00:31:32,010 --> 00:31:37,140
extend it based on the the young on the

00:31:34,470 --> 00:31:43,320
resolution but it works and it's it's

00:31:37,140 --> 00:31:46,440
it's it's not too bad I would say and

00:31:43,320 --> 00:31:48,660
then we we have some slight changes we

00:31:46,440 --> 00:31:52,380
could do without code only on the

00:31:48,660 --> 00:31:55,950
diagram instead of writing out or

00:31:52,380 --> 00:31:59,730
instead of returning the results from

00:31:55,950 --> 00:32:02,370
the UDF I thought about it but I

00:31:59,730 --> 00:32:04,710
immediately thought it's it's very it's

00:32:02,370 --> 00:32:06,690
very pure poor from a code smell

00:32:04,710 --> 00:32:11,640
perspective that's why it's very high I

00:32:06,690 --> 00:32:14,130
could also send publish my results

00:32:11,640 --> 00:32:18,690
directly to Kafka so instead of the UDF

00:32:14,130 --> 00:32:22,020
returning the status is the UDF it's

00:32:18,690 --> 00:32:26,220
just Java which do DF could publish into

00:32:22,020 --> 00:32:26,760
a Kafka topic and it works I have the

00:32:26,220 --> 00:32:29,520
solution

00:32:26,760 --> 00:32:32,550
I haven't implemented it works but I'm

00:32:29,520 --> 00:32:35,730
not really happy with it I think it's it

00:32:32,550 --> 00:32:38,970
doesn't look right to call Kafka from

00:32:35,730 --> 00:32:41,430
inside the UDF but by that you can avoid

00:32:38,970 --> 00:32:44,040
kind of the exploit or already do the

00:32:41,430 --> 00:32:46,350
explode inside your UDF in the UDF you

00:32:44,040 --> 00:32:51,150
just you have a loop anyway where are

00:32:46,350 --> 00:32:53,250
you where you calculate is the fence

00:32:51,150 --> 00:32:55,770
inside or outside and in that same loop

00:32:53,250 --> 00:32:58,650
I can basically just send a message for

00:32:55,770 --> 00:33:00,300
each status I'm having and by that and

00:32:58,650 --> 00:33:03,030
that's why we have just the UDF status

00:33:00,300 --> 00:33:06,690
here the statement which calls the

00:33:03,030 --> 00:33:09,320
geofence bulk is still getting a result

00:33:06,690 --> 00:33:11,970
back from the UDF but it's no longer

00:33:09,320 --> 00:33:13,740
it's no longer the status anymore it

00:33:11,970 --> 00:33:16,110
just basically has it worked or not

00:33:13,740 --> 00:33:18,390
that's why I'm just calling that the UDF

00:33:16,110 --> 00:33:21,330
status what you get back and by that

00:33:18,390 --> 00:33:23,520
it's also kind of you know a synchronous

00:33:21,330 --> 00:33:26,010
you have one flow which does all the

00:33:23,520 --> 00:33:28,860
work and then you you send it to another

00:33:26,010 --> 00:33:30,540
topic and you cannot continue

00:33:28,860 --> 00:33:32,690
you have to continue with that is every

00:33:30,540 --> 00:33:32,690
way

00:33:34,140 --> 00:33:39,539
the other version you can do the same

00:33:36,659 --> 00:33:41,490
explode as I've shown you before you can

00:33:39,539 --> 00:33:43,830
do also on the result so if I go back

00:33:41,490 --> 00:33:46,860
again sorry on that result I also have

00:33:43,830 --> 00:33:49,590
multiple statuses using the same

00:33:46,860 --> 00:33:53,399
technique with the explode I can bring

00:33:49,590 --> 00:33:56,460
it down to single rows so I get one row

00:33:53,399 --> 00:33:59,100
or one one message per status and that's

00:33:56,460 --> 00:34:01,440
what I'm showing here so that's the

00:33:59,100 --> 00:34:04,980
styles list the geometry did the result

00:34:01,440 --> 00:34:07,679
list I got back and I can just again by

00:34:04,980 --> 00:34:09,629
doing an first create stream as select

00:34:07,679 --> 00:34:12,240
and then an insert into that same stream

00:34:09,629 --> 00:34:14,700
as select I'm just going through all the

00:34:12,240 --> 00:34:16,679
statuses all the results and providing

00:34:14,700 --> 00:34:19,050
them but that's again of course static I

00:34:16,679 --> 00:34:22,980
have to have as many inserts as I have

00:34:19,050 --> 00:34:23,700
potential lengths of results which is it

00:34:22,980 --> 00:34:25,679
at the end

00:34:23,700 --> 00:34:28,290
how many polygons do I have per kilo

00:34:25,679 --> 00:34:30,570
hash as so many inserts I would have to

00:34:28,290 --> 00:34:32,960
do but then my result is clean that's

00:34:30,570 --> 00:34:37,980
what I basically would would like to get

00:34:32,960 --> 00:34:40,619
at the end of the geofencing and that

00:34:37,980 --> 00:34:42,899
brings me brings me to the second part I

00:34:40,619 --> 00:34:44,790
will have it rather short because I only

00:34:42,899 --> 00:34:47,520
have five minutes left but this is was

00:34:44,790 --> 00:34:49,800
my most the most important part showing

00:34:47,520 --> 00:34:52,589
it how we can do it with case equal how

00:34:49,800 --> 00:34:58,050
to extend case equal so do it in the

00:34:52,589 --> 00:35:01,530
Kafka world itself and and also show you

00:34:58,050 --> 00:35:04,500
the power of case equal with UDF's so

00:35:01,530 --> 00:35:07,560
I'm pretty happy with what I got but

00:35:04,500 --> 00:35:10,290
then I found a week ago something else I

00:35:07,560 --> 00:35:12,210
don't really know by how I think it was

00:35:10,290 --> 00:35:16,040
just an accident on Google that I

00:35:12,210 --> 00:35:18,690
certainly found tile 38 and tile 38 is

00:35:16,040 --> 00:35:21,510
its database which allows you to do

00:35:18,690 --> 00:35:24,750
cheers spatial and Chua fencing it's

00:35:21,510 --> 00:35:28,380
it's it's not absolutely new the product

00:35:24,750 --> 00:35:30,390
so it's exist for right a while and it's

00:35:28,380 --> 00:35:33,330
implementing in go it's an open source

00:35:30,390 --> 00:35:35,190
database it's very similar to Redis for

00:35:33,330 --> 00:35:36,750
those of you who know Redis the way you

00:35:35,190 --> 00:35:39,990
work with Redis you can also use any

00:35:36,750 --> 00:35:43,260
readies client to work with it and it

00:35:39,990 --> 00:35:45,930
supports actually not just geofencing so

00:35:43,260 --> 00:35:47,430
the the graphic actually before the

00:35:45,930 --> 00:35:49,829
animated gif as

00:35:47,430 --> 00:35:52,349
from telltale 38 they also have

00:35:49,829 --> 00:35:54,569
so-called roaming geofences so two

00:35:52,349 --> 00:35:58,589
points which move and you want to know

00:35:54,569 --> 00:36:01,050
when two points are near together maybe

00:35:58,589 --> 00:36:03,240
it's an airplane would not be good if

00:36:01,050 --> 00:36:05,579
they're too near maybe it's persons and

00:36:03,240 --> 00:36:08,190
you want to have a match then it's good

00:36:05,579 --> 00:36:11,130
if they're near and there there are many

00:36:08,190 --> 00:36:12,900
more things you can do especially also

00:36:11,130 --> 00:36:15,329
you have plottable event notification so

00:36:12,900 --> 00:36:17,730
if something happens or here if it

00:36:15,329 --> 00:36:20,099
happens then you can specify where do

00:36:17,730 --> 00:36:21,960
you want to send it you and that's what

00:36:20,099 --> 00:36:25,710
you have and especially you also have

00:36:21,960 --> 00:36:28,230
Kafka for it and how does it work you

00:36:25,710 --> 00:36:33,119
either have a channel and you specify

00:36:28,230 --> 00:36:35,670
the channel Berlin within an object so

00:36:33,119 --> 00:36:38,040
this is defense so this way you define

00:36:35,670 --> 00:36:40,109
offense and you can see set Chan for

00:36:38,040 --> 00:36:42,059
those of you have done work with Redis

00:36:40,109 --> 00:36:43,849
it's the same concept you have in

00:36:42,059 --> 00:36:47,550
command and then you have arguments

00:36:43,849 --> 00:36:49,530
where you specify your command and so

00:36:47,550 --> 00:36:51,599
this is the geofence defining a geofence

00:36:49,530 --> 00:36:55,859
and this is just the name of the of the

00:36:51,599 --> 00:36:59,579
channel and this is the key yeah which

00:36:55,859 --> 00:37:02,460
kind of groups your your work and then

00:36:59,579 --> 00:37:04,559
you can subscribe on Berlin and then

00:37:02,460 --> 00:37:07,230
somebody else would you and set vehicle

00:37:04,559 --> 00:37:10,020
at point so this is the ID of the

00:37:07,230 --> 00:37:12,180
vehicle at point this point here and

00:37:10,020 --> 00:37:14,040
this has to match way close the key I'm

00:37:12,180 --> 00:37:16,339
using the same key so it's kind of the

00:37:14,040 --> 00:37:19,859
partitioning I'm doing and if I'm

00:37:16,339 --> 00:37:21,359
setting that point I will get back in

00:37:19,859 --> 00:37:23,309
the other statement where the other

00:37:21,359 --> 00:37:26,880
session we have two on the subscribe I

00:37:23,309 --> 00:37:32,790
will get back a message telling me that

00:37:26,880 --> 00:37:36,540
I'm outside of that polygon you can do a

00:37:32,790 --> 00:37:40,290
similar statement with set hook set hook

00:37:36,540 --> 00:37:43,349
is just adding you don't you don't get

00:37:40,290 --> 00:37:46,069
it back on on the on the terminal or on

00:37:43,349 --> 00:37:49,770
the command line or on the tile 38

00:37:46,069 --> 00:37:52,230
standard API here with the set hook you

00:37:49,770 --> 00:37:54,750
specify also the hook in this case here

00:37:52,230 --> 00:37:57,329
it's a Kafka hook so I'm specifying the

00:37:54,750 --> 00:37:58,049
Kafka broker the Kafka topic and the

00:37:57,329 --> 00:38:00,420
rest is the same

00:37:58,049 --> 00:38:01,349
and now if I'm doing a set vehicle the

00:38:00,420 --> 00:38:04,049
same point

00:38:01,349 --> 00:38:06,269
I'm getting back on Kafka on that on

00:38:04,049 --> 00:38:09,170
that topic I'm getting back to say

00:38:06,269 --> 00:38:11,999
message but now the message isn't Kafka

00:38:09,170 --> 00:38:14,190
so how can you integrate it with the

00:38:11,999 --> 00:38:16,289
rest of the world or the rest of the

00:38:14,190 --> 00:38:18,900
solution I'll show you so far there are

00:38:16,289 --> 00:38:21,779
two ways I thought of and I implemented

00:38:18,900 --> 00:38:24,469
them as well there's one again with

00:38:21,779 --> 00:38:27,299
UDF's you just specify or implement your

00:38:24,469 --> 00:38:29,999
additional UDF another UDF which just

00:38:27,299 --> 00:38:32,459
communicates with tile over the readies

00:38:29,999 --> 00:38:34,249
client api or you can just use the

00:38:32,459 --> 00:38:37,410
normal java

00:38:34,249 --> 00:38:39,779
Redis or one of the java api s-- i can't

00:38:37,410 --> 00:38:42,539
remember which one and or java clients

00:38:39,779 --> 00:38:46,170
and and and and then i just specify the

00:38:42,539 --> 00:38:47,549
set position UDF did this set friends is

00:38:46,170 --> 00:38:49,739
actually not implemented I've only done

00:38:47,549 --> 00:38:52,440
that because this is kind of done once

00:38:49,739 --> 00:38:54,709
and then I just tested that it works and

00:38:52,440 --> 00:38:57,690
this actually works so I'm communicating

00:38:54,709 --> 00:38:59,969
now here with the service that's why I

00:38:57,690 --> 00:39:02,509
call it the geofence service so I'm no

00:38:59,969 --> 00:39:04,890
longer integrated into the flow I'm

00:39:02,509 --> 00:39:08,339
interfacing with the service and the

00:39:04,890 --> 00:39:12,859
service provides me the status so it's

00:39:08,339 --> 00:39:15,479
also decoupled and last but not least a

00:39:12,859 --> 00:39:17,369
better solution and I've implemented

00:39:15,479 --> 00:39:20,699
that half way as well I've implemented

00:39:17,369 --> 00:39:23,869
the set part here I'm still doing or

00:39:20,699 --> 00:39:25,079
working on it as I mentioned I just

00:39:23,869 --> 00:39:29,099
found

00:39:25,079 --> 00:39:31,499
12:38 a week ago and this is using Kafka

00:39:29,099 --> 00:39:33,839
Connect I just implemented my own Kafka

00:39:31,499 --> 00:39:36,509
connector I just took the one from Redis

00:39:33,839 --> 00:39:39,390
it's open source so I could use quite a

00:39:36,509 --> 00:39:42,059
lot from the radius connector and I just

00:39:39,390 --> 00:39:45,150
changed what is necessary for 10:38 and

00:39:42,059 --> 00:39:47,640
now it's properly in my way my point of

00:39:45,150 --> 00:39:50,069
view properly integrated so I have the

00:39:47,640 --> 00:39:55,170
position I'm just using that cover

00:39:50,069 --> 00:39:59,459
connect it integrates with tile 38 and

00:39:55,170 --> 00:40:02,910
the hook is sent the hook is doing the

00:39:59,459 --> 00:40:04,829
descent to two Kafka and what would be

00:40:02,910 --> 00:40:07,920
nice and you see that in the outlook is

00:40:04,829 --> 00:40:10,259
the way back this is a sink connector

00:40:07,920 --> 00:40:12,690
and I would like to implement that

00:40:10,259 --> 00:40:15,210
connector also as a source so I can pick

00:40:12,690 --> 00:40:17,970
up the message I'm getting from tile 38

00:40:15,210 --> 00:40:21,630
I might want to change it to my own

00:40:17,970 --> 00:40:25,170
format and then I have both ways I can

00:40:21,630 --> 00:40:27,660
integrate 238 as sync if I send it and I

00:40:25,170 --> 00:40:32,069
will get all the results back as as a

00:40:27,660 --> 00:40:34,650
source so that's ongoing work and this

00:40:32,069 --> 00:40:37,290
is how you call the connector and with

00:40:34,650 --> 00:40:39,690
all of that you can then also visualize

00:40:37,290 --> 00:40:42,270
it I'll skip that just to give you an

00:40:39,690 --> 00:40:44,400
impression or Qadir data I'm not selling

00:40:42,270 --> 00:40:46,950
area data have no connection to Arkadia

00:40:44,400 --> 00:40:49,770
data but what I like it's it's a

00:40:46,950 --> 00:40:51,390
standard bi tool or it's a it's around

00:40:49,770 --> 00:40:54,920
for a long time but what they've done

00:40:51,390 --> 00:40:57,960
they added the capability also integrate

00:40:54,920 --> 00:41:00,750
case equal because it's a standard tool

00:40:57,960 --> 00:41:02,940
bi tool from the old days of relational

00:41:00,750 --> 00:41:04,710
databases where you do sequel and they

00:41:02,940 --> 00:41:07,980
just implemented the same concept

00:41:04,710 --> 00:41:09,990
instead of doing sequel UK sequel and

00:41:07,980 --> 00:41:11,819
what you have I'm not f javac

00:41:09,990 --> 00:41:14,670
spectrograph and I've first tried to

00:41:11,819 --> 00:41:19,460
implement my own dashboard but I failed

00:41:14,670 --> 00:41:23,069
and I was not really wanna wanted to - -

00:41:19,460 --> 00:41:25,740
to work on it more and what you have

00:41:23,069 --> 00:41:28,920
here is just a map and this map is is

00:41:25,740 --> 00:41:30,720
kind of showing the points and the

00:41:28,920 --> 00:41:34,079
points are in real time so the changes

00:41:30,720 --> 00:41:36,359
you can add your fences and the idea is

00:41:34,079 --> 00:41:38,329
that on the right you have to the status

00:41:36,359 --> 00:41:41,609
of the fences sorry you can check it

00:41:38,329 --> 00:41:44,040
that's all have if you have questions

00:41:41,609 --> 00:41:47,450
I'm around it's its launch time anyway

00:41:44,040 --> 00:41:50,910
now so summary I've mentioned most of it

00:41:47,450 --> 00:41:52,770
and the outlook some permits performance

00:41:50,910 --> 00:41:54,869
tests are needed as well some clean up

00:41:52,770 --> 00:41:56,970
everything is on my github if you're

00:41:54,869 --> 00:41:59,190
interested I've done that for a customer

00:41:56,970 --> 00:42:02,099
it's a POC for a customer

00:41:59,190 --> 00:42:04,230
I'm it's ongoing work I'm not as far as

00:42:02,099 --> 00:42:06,270
I want it to be but that's normal

00:42:04,230 --> 00:42:08,849
project life but what I've presented

00:42:06,270 --> 00:42:10,170
today or what I have on my github I'm

00:42:08,849 --> 00:42:12,660
quite happy with it

00:42:10,170 --> 00:42:14,849
thanks a lot and if you have questions

00:42:12,660 --> 00:42:16,650
you just come to a podium right let's

00:42:14,849 --> 00:42:18,619
take the questions offline do a lunch

00:42:16,650 --> 00:42:20,680
break I'm told UWM

00:42:18,619 --> 00:42:20,680

YouTube URL: https://www.youtube.com/watch?v=f7fXTzd7u_Y


