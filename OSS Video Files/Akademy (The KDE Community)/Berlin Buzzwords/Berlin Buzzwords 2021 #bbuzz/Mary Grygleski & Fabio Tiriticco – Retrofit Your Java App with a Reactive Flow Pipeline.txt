Title: Mary Grygleski & Fabio Tiriticco – Retrofit Your Java App with a Reactive Flow Pipeline
Publication date: 2021-06-25
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	This presentation will be a lively discussion with hands-on coding to illustrate how to construct a reactive, event-driven data flow pipeline. We will use multiple library implementations of the Reactive Streams specification, such as Akka Streams, Eclipse Vert.x and RxJava. The sample use case will mimic a real-life example of data being collected from multiple distributed sources, which will then be fed to a legacy processor as «wrapped» by a reactive microservice. The resulting data will flow to a «sink» to be prepared for further processing. We will highlight the strength of the Reactive Streams in controlling backpressure during processing.

Speaker:
Mary Grygleski – https://2021.berlinbuzzwords.de/member/mary-grygleski
Fabio Tiriticco – https://2021.berlinbuzzwords.de/member/fabio-tiriticco

More: https://2021.berlinbuzzwords.de/session/retrofit-your-java-app-reactive-flow-pipeline
Captions: 
	00:00:08,720 --> 00:00:13,120
hello

00:00:09,599 --> 00:00:16,240
welcome to our talk uh talked

00:00:13,120 --> 00:00:17,279
today by myself mary grogleski and fabio

00:00:16,240 --> 00:00:19,600
teretico

00:00:17,279 --> 00:00:20,560
today is an interesting emerging topic

00:00:19,600 --> 00:00:23,279
presentation

00:00:20,560 --> 00:00:25,680
called retrofit your legacy java app

00:00:23,279 --> 00:00:26,720
with a reactive flow pipeline we'll take

00:00:25,680 --> 00:00:31,119
a look at how

00:00:26,720 --> 00:00:34,480
reactive can be applied to transforming

00:00:31,119 --> 00:00:36,719
an old traditional legacy java app

00:00:34,480 --> 00:00:38,160
and this is our agenda for today we'll

00:00:36,719 --> 00:00:40,640
have a quick introduction

00:00:38,160 --> 00:00:41,600
and then we'll go into talking a bit to

00:00:40,640 --> 00:00:43,920
about

00:00:41,600 --> 00:00:45,360
a bit of history as kind of give setting

00:00:43,920 --> 00:00:48,879
up the stage as to

00:00:45,360 --> 00:00:49,520
why we have this talk discussing from

00:00:48,879 --> 00:00:52,640
the

00:00:49,520 --> 00:00:56,000
perspective from an enterprise

00:00:52,640 --> 00:00:58,480
jvm applications point of view and then

00:00:56,000 --> 00:00:59,199
we also explore into a bit of the

00:00:58,480 --> 00:01:01,600
complex

00:00:59,199 --> 00:01:02,320
problems in today's world that's

00:01:01,600 --> 00:01:03,760
evolving

00:01:02,320 --> 00:01:07,040
that's becoming more and more

00:01:03,760 --> 00:01:09,920
complicated needing more and more data

00:01:07,040 --> 00:01:11,680
everything is just come in bulk we have

00:01:09,920 --> 00:01:14,880
so much to sort through

00:01:11,680 --> 00:01:17,360
so what would be a good approach is

00:01:14,880 --> 00:01:19,040
that what we're proposing here which is

00:01:17,360 --> 00:01:22,080
the fourth section is about

00:01:19,040 --> 00:01:24,880
some solutions that we can be using

00:01:22,080 --> 00:01:26,240
using uh and it's basically leveraging

00:01:24,880 --> 00:01:29,200
on the reactive

00:01:26,240 --> 00:01:30,560
approach and then fabio will then take

00:01:29,200 --> 00:01:33,920
us into an in-depth

00:01:30,560 --> 00:01:34,320
uh look into an experiment that we have

00:01:33,920 --> 00:01:37,360
done

00:01:34,320 --> 00:01:39,600
and mostly merits to

00:01:37,360 --> 00:01:41,920
fabio who spent a significant amount of

00:01:39,600 --> 00:01:44,960
time working through some of the

00:01:41,920 --> 00:01:47,600
inner things and so that will be

00:01:44,960 --> 00:01:48,880
fabio area he will spend more time with

00:01:47,600 --> 00:01:50,720
you on that

00:01:48,880 --> 00:01:52,159
and then after that we will come

00:01:50,720 --> 00:01:55,520
together and give

00:01:52,159 --> 00:01:58,799
a conclusion to this whole experiment

00:01:55,520 --> 00:02:01,360
um on the reactive java ex

00:01:58,799 --> 00:02:03,439
kind of experience that we have so all

00:02:01,360 --> 00:02:06,240
right so let's begin

00:02:03,439 --> 00:02:07,439
a quick introduction i'll just give my

00:02:06,240 --> 00:02:10,080
since i'm talking let me

00:02:07,439 --> 00:02:11,440
introduce myself i'm mary grigoleski

00:02:10,080 --> 00:02:13,520
that's my twitter handle

00:02:11,440 --> 00:02:14,480
and i'm a senior developer advocate at

00:02:13,520 --> 00:02:18,080
ibm

00:02:14,480 --> 00:02:21,040
in the java open source and cloud space

00:02:18,080 --> 00:02:23,040
i'm also by night president of the

00:02:21,040 --> 00:02:26,080
chicago java users group as well

00:02:23,040 --> 00:02:29,680
as well as a few other user groups um

00:02:26,080 --> 00:02:33,280
in the chicago area so now um

00:02:29,680 --> 00:02:36,640
to you fabio yes uh hi everybody

00:02:33,280 --> 00:02:38,160
um and thanks for having us um my name

00:02:36,640 --> 00:02:40,400
is fabio tiritiko

00:02:38,160 --> 00:02:42,239
and twitter handle is stikofab it's a

00:02:40,400 --> 00:02:45,360
lot easier to pronounce than my

00:02:42,239 --> 00:02:48,239
family name and i am based in amsterdam

00:02:45,360 --> 00:02:49,680
where i work as a software engineer now

00:02:48,239 --> 00:02:53,360
currently actually in an

00:02:49,680 --> 00:02:55,760
engineering manager position and i am

00:02:53,360 --> 00:02:56,959
the founder of this community reactive

00:02:55,760 --> 00:03:00,080
amsterdam

00:02:56,959 --> 00:03:04,080
um so yes the topics of today's talk

00:03:00,080 --> 00:03:07,440
are really really dear to my heart

00:03:04,080 --> 00:03:08,239
thank you man so with that without

00:03:07,440 --> 00:03:11,760
further ado

00:03:08,239 --> 00:03:13,360
i'm going to start so why right and i

00:03:11,760 --> 00:03:15,120
i've been speaking at a lot of

00:03:13,360 --> 00:03:18,239
conferences and so

00:03:15,120 --> 00:03:21,200
has uh fabio with a deeper experience

00:03:18,239 --> 00:03:22,239
in reactive too and i'm sure you know

00:03:21,200 --> 00:03:24,879
fabio too

00:03:22,239 --> 00:03:27,040
like myself we've constantly been asked

00:03:24,879 --> 00:03:30,159
by our audience as to

00:03:27,040 --> 00:03:33,519
well how can reactive be of use

00:03:30,159 --> 00:03:34,239
in today's world so one aspect that we

00:03:33,519 --> 00:03:37,840
have been

00:03:34,239 --> 00:03:40,799
exploring into is really uh looking into

00:03:37,840 --> 00:03:43,040
enterprise jvm applications these are

00:03:40,799 --> 00:03:46,480
applications that are

00:03:43,040 --> 00:03:49,680
powering the the world's you know

00:03:46,480 --> 00:03:53,200
huge um uh kind of back-end

00:03:49,680 --> 00:03:54,159
applications uh in production in big

00:03:53,200 --> 00:03:57,200
financial

00:03:54,159 --> 00:03:59,920
places in insurance company in

00:03:57,200 --> 00:04:00,640
um manufacturing places and you name it

00:03:59,920 --> 00:04:03,920
that they are

00:04:00,640 --> 00:04:06,000
there so they their mission is

00:04:03,920 --> 00:04:06,959
actually very important uh for the

00:04:06,000 --> 00:04:09,120
company

00:04:06,959 --> 00:04:11,040
they do a lot of things on for example

00:04:09,120 --> 00:04:13,920
very typical ones it's like

00:04:11,040 --> 00:04:14,640
e-commerce systems that essentially you

00:04:13,920 --> 00:04:17,199
have you

00:04:14,640 --> 00:04:19,120
have customers trying to shop for

00:04:17,199 --> 00:04:22,400
something catalog

00:04:19,120 --> 00:04:25,199
and then uh then you order to order

00:04:22,400 --> 00:04:26,160
as we all know it's not a simple thing

00:04:25,199 --> 00:04:28,240
and uh

00:04:26,160 --> 00:04:30,000
and then of course with this order and

00:04:28,240 --> 00:04:31,040
with today's world we are not just

00:04:30,000 --> 00:04:33,280
paying by cash

00:04:31,040 --> 00:04:35,120
and we are also doing credit card or now

00:04:33,280 --> 00:04:38,960
um even more like you know

00:04:35,120 --> 00:04:41,600
kind of uh what cashless uh payment or

00:04:38,960 --> 00:04:42,000
what cardless payment i'm sorry and so

00:04:41,600 --> 00:04:44,560
all these

00:04:42,000 --> 00:04:46,320
things they are very complicated and

00:04:44,560 --> 00:04:48,320
require a lot of security

00:04:46,320 --> 00:04:50,800
and all these things and as you can see

00:04:48,320 --> 00:04:52,720
is this is really complicated

00:04:50,800 --> 00:04:54,240
and but the traditional way of doing

00:04:52,720 --> 00:04:57,280
things is that before

00:04:54,240 --> 00:04:57,600
um hardware it's been able to get caught

00:04:57,280 --> 00:05:00,639
up

00:04:57,600 --> 00:05:02,639
um when we're having single cpu or

00:05:00,639 --> 00:05:05,199
having like parallel processing of

00:05:02,639 --> 00:05:07,840
multiple cpus but essentially

00:05:05,199 --> 00:05:08,639
kind of you know like a single thread

00:05:07,840 --> 00:05:12,479
handling

00:05:08,639 --> 00:05:12,479
per cpu type of scenario

00:05:12,720 --> 00:05:17,039
applications were developed in a very

00:05:14,800 --> 00:05:19,520
monolithic fashion

00:05:17,039 --> 00:05:21,280
so everything too we could be processing

00:05:19,520 --> 00:05:24,560
is all in the same jvm

00:05:21,280 --> 00:05:25,280
if it's taking java and they are all

00:05:24,560 --> 00:05:28,320
like

00:05:25,280 --> 00:05:29,280
doing things within the jvm um let's say

00:05:28,320 --> 00:05:32,000
order entry

00:05:29,280 --> 00:05:33,039
and if you have an order you need to

00:05:32,000 --> 00:05:36,080
talk to

00:05:33,039 --> 00:05:37,280
send your order over to your credit card

00:05:36,080 --> 00:05:39,280
verify

00:05:37,280 --> 00:05:41,199
audio transaction they will actually

00:05:39,280 --> 00:05:43,440
essentially hold up a thread and you

00:05:41,199 --> 00:05:46,240
just like have to sit there and wait

00:05:43,440 --> 00:05:48,000
and that type of it's just an example of

00:05:46,240 --> 00:05:50,880
some of these monolithic

00:05:48,000 --> 00:05:52,240
applications in their runtime the the

00:05:50,880 --> 00:05:54,000
effect of how it

00:05:52,240 --> 00:05:55,680
affects the whole system is just not

00:05:54,000 --> 00:05:58,880
designed to be very

00:05:55,680 --> 00:06:01,120
scalable not very flexible at all

00:05:58,880 --> 00:06:02,160
and not only that you know on the the

00:06:01,120 --> 00:06:04,960
design side

00:06:02,160 --> 00:06:06,800
um we run into that problem in runtime

00:06:04,960 --> 00:06:07,360
but the thing is too is that we also

00:06:06,800 --> 00:06:10,880
rely

00:06:07,360 --> 00:06:13,360
on a huge operation teams to help us

00:06:10,880 --> 00:06:14,240
too with the building part not not only

00:06:13,360 --> 00:06:17,120
building

00:06:14,240 --> 00:06:17,680
in the testing phase too we will be like

00:06:17,120 --> 00:06:20,880
having

00:06:17,680 --> 00:06:24,000
um you know a different uh

00:06:20,880 --> 00:06:27,520
development version of your

00:06:24,000 --> 00:06:30,000
code or have your qa running a separate

00:06:27,520 --> 00:06:32,240
version and then you have certifying all

00:06:30,000 --> 00:06:34,560
that before you go into production

00:06:32,240 --> 00:06:35,919
then so overall too the maintenance of

00:06:34,560 --> 00:06:38,560
such application is

00:06:35,919 --> 00:06:39,280
is very high and it's also not very

00:06:38,560 --> 00:06:41,199
flexible

00:06:39,280 --> 00:06:43,280
it almost seems like the world must stop

00:06:41,199 --> 00:06:44,319
if you need to upgrade any part of your

00:06:43,280 --> 00:06:46,639
system and that's

00:06:44,319 --> 00:06:47,600
kind of like the whole kind of issue

00:06:46,639 --> 00:06:50,319
with it

00:06:47,600 --> 00:06:51,599
and of course too the data aspect too

00:06:50,319 --> 00:06:54,960
you know it's kind of like

00:06:51,599 --> 00:06:57,039
um hard for it to be

00:06:54,960 --> 00:06:59,120
kind of like go through different states

00:06:57,039 --> 00:07:01,520
uh without being

00:06:59,120 --> 00:07:02,639
easily able to get updated the state

00:07:01,520 --> 00:07:04,720
changes between these

00:07:02,639 --> 00:07:05,840
these different parts so such and so

00:07:04,720 --> 00:07:08,080
let's go on

00:07:05,840 --> 00:07:09,199
and of course too not to mention uh the

00:07:08,080 --> 00:07:11,680
fact is that uh

00:07:09,199 --> 00:07:12,639
there's also the concurrency aspect of

00:07:11,680 --> 00:07:15,280
processing that

00:07:12,639 --> 00:07:16,960
that present itself a lot of challenges

00:07:15,280 --> 00:07:18,319
so those are kind of like some of the

00:07:16,960 --> 00:07:21,360
traditional enterprise

00:07:18,319 --> 00:07:22,560
applications uh that that uh we can kind

00:07:21,360 --> 00:07:25,919
of think of using

00:07:22,560 --> 00:07:28,880
a reactive approach to solve

00:07:25,919 --> 00:07:30,080
then we talk about the solutions uh that

00:07:28,880 --> 00:07:32,800
that

00:07:30,080 --> 00:07:34,400
that uh we're proposing is to use this

00:07:32,800 --> 00:07:37,120
reactive approach

00:07:34,400 --> 00:07:37,520
is that um in today's world and of

00:07:37,120 --> 00:07:40,400
course

00:07:37,520 --> 00:07:41,520
its microservices have has already been

00:07:40,400 --> 00:07:44,639
uh popular and

00:07:41,520 --> 00:07:45,840
you know since i'd say in the 2010s kind

00:07:44,639 --> 00:07:48,560
of time frame

00:07:45,840 --> 00:07:49,840
and so those are solutions of uh using

00:07:48,560 --> 00:07:52,879
this reactive approach

00:07:49,840 --> 00:07:56,000
and actually microservices itself too is

00:07:52,879 --> 00:07:58,960
is kind of perfect for um

00:07:56,000 --> 00:08:00,080
letting the reactive or be adopted by

00:07:58,960 --> 00:08:02,720
the reactive

00:08:00,080 --> 00:08:04,000
way they kind of both are kind of work

00:08:02,720 --> 00:08:07,199
together very well

00:08:04,000 --> 00:08:09,120
a reactive system itself is by nature uh

00:08:07,199 --> 00:08:11,280
not tightly coupled to um so

00:08:09,120 --> 00:08:12,479
microservices is like a perfect kind of

00:08:11,280 --> 00:08:14,879
architectural

00:08:12,479 --> 00:08:15,599
uh approach that reactive systems can

00:08:14,879 --> 00:08:17,919
use

00:08:15,599 --> 00:08:18,879
oh actually i should also add two is a

00:08:17,919 --> 00:08:21,120
also the

00:08:18,879 --> 00:08:23,280
serverless aspect too it deals with the

00:08:21,120 --> 00:08:26,400
deployment part two and and

00:08:23,280 --> 00:08:28,560
in the serverless cloud native world too

00:08:26,400 --> 00:08:30,240
it's also very suited for this reactive

00:08:28,560 --> 00:08:32,959
approach um

00:08:30,240 --> 00:08:35,360
and uh and of course too uh with

00:08:32,959 --> 00:08:36,560
microservices everything kind of broken

00:08:35,360 --> 00:08:39,200
out and not

00:08:36,560 --> 00:08:41,360
no longer like you know all together

00:08:39,200 --> 00:08:44,000
then you can essentially uh

00:08:41,360 --> 00:08:44,880
do your upgrading without one part can

00:08:44,000 --> 00:08:46,880
be down while

00:08:44,880 --> 00:08:49,040
other parts are still running so that

00:08:46,880 --> 00:08:52,240
kind of uh is is very

00:08:49,040 --> 00:08:55,279
very uh conducive uh for the reactive

00:08:52,240 --> 00:08:58,000
approach and of course too

00:08:55,279 --> 00:08:59,839
there's also the traditional operations

00:08:58,000 --> 00:09:01,680
part is no longer

00:08:59,839 --> 00:09:03,680
you know the the case we're kind of

00:09:01,680 --> 00:09:04,720
using modern uh devops and

00:09:03,680 --> 00:09:07,040
infrastructure

00:09:04,720 --> 00:09:09,519
to uh for the deployment building

00:09:07,040 --> 00:09:12,640
continuous integration

00:09:09,519 --> 00:09:16,160
and deployment part um

00:09:12,640 --> 00:09:17,440
and now too if you think of uh reactive2

00:09:16,160 --> 00:09:20,720
it's basically enable

00:09:17,440 --> 00:09:22,320
uh concurrency without us the developer

00:09:20,720 --> 00:09:23,440
still having to worry about the

00:09:22,320 --> 00:09:25,120
mechanics of

00:09:23,440 --> 00:09:27,680
threading concern because all the

00:09:25,120 --> 00:09:28,399
threadings are now being handled by the

00:09:27,680 --> 00:09:30,640
libraries

00:09:28,399 --> 00:09:31,680
by the reactive framework or libraries

00:09:30,640 --> 00:09:34,959
or toolkits

00:09:31,680 --> 00:09:36,320
so that developers can then focus on

00:09:34,959 --> 00:09:38,800
actually the business

00:09:36,320 --> 00:09:40,800
operational side now the thing is with

00:09:38,800 --> 00:09:41,839
you using reactive approach is basically

00:09:40,800 --> 00:09:44,880
we're proposing

00:09:41,839 --> 00:09:49,360
is to build and transform some

00:09:44,880 --> 00:09:52,399
legacy applications where identify

00:09:49,360 --> 00:09:54,320
identifying parts of it and allowing the

00:09:52,399 --> 00:09:55,279
data to be flowing through different

00:09:54,320 --> 00:09:58,560
pipelines

00:09:55,279 --> 00:10:01,760
and that's the area that

00:09:58,560 --> 00:10:05,279
fabio will be demonstrating for us is to

00:10:01,760 --> 00:10:09,120
uh a case in which we're building using

00:10:05,279 --> 00:10:11,200
different implementation of a reactive

00:10:09,120 --> 00:10:12,800
pipeline and different implementation

00:10:11,200 --> 00:10:14,560
different reactive libraries to

00:10:12,800 --> 00:10:17,440
implement this pipeline

00:10:14,560 --> 00:10:18,880
and uh so yeah so i will pass the baton

00:10:17,440 --> 00:10:21,920
over to

00:10:18,880 --> 00:10:25,279
fabio to talk about this

00:10:21,920 --> 00:10:29,200
particular use case yes

00:10:25,279 --> 00:10:32,320
uh thank you very much uh mary

00:10:29,200 --> 00:10:35,920
what we are going to look at is this

00:10:32,320 --> 00:10:38,079
this hypothetical situation where um

00:10:35,920 --> 00:10:40,399
we're talking about some data pipeline

00:10:38,079 --> 00:10:43,920
and there's going to be some processing

00:10:40,399 --> 00:10:47,040
happening the first

00:10:43,920 --> 00:10:50,000
legacy processor will

00:10:47,040 --> 00:10:51,120
read consume data from the first kafka

00:10:50,000 --> 00:10:54,000
topic

00:10:51,120 --> 00:10:55,760
and then the second processor will do

00:10:54,000 --> 00:10:58,399
some additional processing on it

00:10:55,760 --> 00:10:59,760
after it has received the output of the

00:10:58,399 --> 00:11:02,399
first processor

00:10:59,760 --> 00:11:03,279
and finally the second kafka topic will

00:11:02,399 --> 00:11:06,640
be where

00:11:03,279 --> 00:11:07,360
our process data will end up and what's

00:11:06,640 --> 00:11:11,279
important

00:11:07,360 --> 00:11:14,399
is in this entire pipeline

00:11:11,279 --> 00:11:17,839
we are using concepts coming from

00:11:14,399 --> 00:11:20,320
the reactive strings idea where

00:11:17,839 --> 00:11:22,160
you know reactive streams is a standard

00:11:20,320 --> 00:11:25,600
that has been part of the jdk

00:11:22,160 --> 00:11:29,040
since jdk 9 i believe

00:11:25,600 --> 00:11:32,640
and and one of the most important

00:11:29,040 --> 00:11:34,399
uh consequences and benefits of this of

00:11:32,640 --> 00:11:37,600
using this this standard

00:11:34,399 --> 00:11:40,839
is uh is is back pressure so

00:11:37,600 --> 00:11:42,480
what we'll see is that uh the the entire

00:11:40,839 --> 00:11:46,240
process only

00:11:42,480 --> 00:11:48,399
does actual something if there is demand

00:11:46,240 --> 00:11:49,360
from downstream so in this concrete

00:11:48,399 --> 00:11:52,480
example

00:11:49,360 --> 00:11:53,360
let's say if the legacy processor number

00:11:52,480 --> 00:11:56,480
two

00:11:53,360 --> 00:11:59,519
doesn't have enough capacity to process

00:11:56,480 --> 00:12:02,639
all the potential incoming data

00:11:59,519 --> 00:12:04,959
uh the the first processor legacy

00:12:02,639 --> 00:12:08,160
processor number one

00:12:04,959 --> 00:12:11,279
will be reacting to this situation

00:12:08,160 --> 00:12:13,760
by simply stop sending data and

00:12:11,279 --> 00:12:15,360
are waiting for legacy processor to be

00:12:13,760 --> 00:12:18,320
ready to process more

00:12:15,360 --> 00:12:20,320
more information and this is crucial in

00:12:18,320 --> 00:12:22,399
large systems where many many pieces

00:12:20,320 --> 00:12:25,839
interact with one another

00:12:22,399 --> 00:12:29,680
as uh you know fast producers might

00:12:25,839 --> 00:12:32,240
well you know uh boggle down

00:12:29,680 --> 00:12:32,720
uh slow consumers and so in order to

00:12:32,240 --> 00:12:36,079
avoid

00:12:32,720 --> 00:12:40,240
this sort of overflowing situation

00:12:36,079 --> 00:12:43,519
uh we have these pipelines that employ

00:12:40,240 --> 00:12:44,079
uh back pressure all the way up to the

00:12:43,519 --> 00:12:47,920
source

00:12:44,079 --> 00:12:52,000
of the data and now let's

00:12:47,920 --> 00:12:54,079
go look at some code and some demo

00:12:52,000 --> 00:12:55,200
uh here we are you should be seeing my

00:12:54,079 --> 00:12:57,680
screen now and

00:12:55,200 --> 00:12:59,839
uh what you are seeing now is in fact

00:12:57,680 --> 00:13:01,920
the github repository with the code for

00:12:59,839 --> 00:13:05,120
the demo that you're about to see

00:13:01,920 --> 00:13:07,839
and as you can see there is uh these

00:13:05,120 --> 00:13:09,120
two legacy processor one and legacy

00:13:07,839 --> 00:13:12,399
processor two

00:13:09,120 --> 00:13:14,720
are our uh projects um

00:13:12,399 --> 00:13:16,079
and then there's two other folders one

00:13:14,720 --> 00:13:18,320
is about infra

00:13:16,079 --> 00:13:20,720
it's a simple docker compose file that

00:13:18,320 --> 00:13:23,600
will spin up our

00:13:20,720 --> 00:13:25,040
you know kafka infrastructure and

00:13:23,600 --> 00:13:28,720
sources producer

00:13:25,040 --> 00:13:32,320
is a project that will simply uh

00:13:28,720 --> 00:13:35,440
put some some random data on kafka so

00:13:32,320 --> 00:13:39,519
the first legacy processor has something

00:13:35,440 --> 00:13:42,800
to consume now let's see this in action

00:13:39,519 --> 00:13:46,560
um here we are uh there's

00:13:42,800 --> 00:13:50,880
our infra directory

00:13:46,560 --> 00:13:50,880
let's pin up our infrastructure

00:13:52,079 --> 00:14:03,839
this is going to start our entire

00:13:56,240 --> 00:14:03,839
kafka backend

00:14:06,639 --> 00:14:10,800
yeah there it is now we have a run kafka

00:14:09,600 --> 00:14:13,760
cluster on my

00:14:10,800 --> 00:14:17,360
local machine and so let me start the

00:14:13,760 --> 00:14:20,720
sources provider which will start

00:14:17,360 --> 00:14:24,160
push data into our

00:14:20,720 --> 00:14:27,600
kafka topic this is going to be just

00:14:24,160 --> 00:14:30,720
let's see there it is one record per

00:14:27,600 --> 00:14:33,199
second containing just

00:14:30,720 --> 00:14:33,760
that specific timestamp as you can see

00:14:33,199 --> 00:14:36,720
and

00:14:33,760 --> 00:14:37,120
this guy is just going to keep producing

00:14:36,720 --> 00:14:42,240
as

00:14:37,120 --> 00:14:42,240
as we go so

00:14:42,480 --> 00:14:49,519
let's uh first look a little bit

00:14:45,760 --> 00:14:53,120
at the code before we started

00:14:49,519 --> 00:14:56,320
what you are seeing now on screen is

00:14:53,120 --> 00:14:57,680
a the first the implementation the

00:14:56,320 --> 00:15:01,279
actual starting point

00:14:57,680 --> 00:15:04,720
of the first legacy processor

00:15:01,279 --> 00:15:07,360
it's in scala and it uses

00:15:04,720 --> 00:15:08,720
a reactive stream implementation called

00:15:07,360 --> 00:15:11,760
akka strips

00:15:08,720 --> 00:15:14,000
aka streams is based on akka

00:15:11,760 --> 00:15:15,760
a product from lightbend an open source

00:15:14,000 --> 00:15:18,800
product from lightman

00:15:15,760 --> 00:15:21,519
and the idea of aka streams is

00:15:18,800 --> 00:15:23,839
uh to that implements in the the

00:15:21,519 --> 00:15:27,120
reactive stream specification

00:15:23,839 --> 00:15:29,519
so um there are a lot of different

00:15:27,120 --> 00:15:32,639
connectors that we can use

00:15:29,519 --> 00:15:35,360
in part of akka strings in particular

00:15:32,639 --> 00:15:37,600
here we are going to use the connector

00:15:35,360 --> 00:15:41,120
that allows us to connect

00:15:37,600 --> 00:15:43,120
to a kafka topic and consume events from

00:15:41,120 --> 00:15:46,720
it

00:15:43,120 --> 00:15:47,120
at the see this this this little snippet

00:15:46,720 --> 00:15:49,680
here

00:15:47,120 --> 00:15:50,240
this is the entire thing the whole thing

00:15:49,680 --> 00:15:52,399
that we

00:15:50,240 --> 00:15:54,800
really need to look at what this

00:15:52,399 --> 00:15:56,639
processor is going to do is going to

00:15:54,800 --> 00:15:58,399
okay after instantiating some

00:15:56,639 --> 00:16:00,800
configuration setting like

00:15:58,399 --> 00:16:02,720
which topic we are going to submit to to

00:16:00,800 --> 00:16:05,279
listen to

00:16:02,720 --> 00:16:05,920
here we are creating our stream which

00:16:05,279 --> 00:16:09,279
starts

00:16:05,920 --> 00:16:12,399
considering our kafka topic as a source

00:16:09,279 --> 00:16:13,360
of items and then for each item that

00:16:12,399 --> 00:16:16,480
comes in

00:16:13,360 --> 00:16:19,360
we are first simulating some processing

00:16:16,480 --> 00:16:20,720
in this case we are just extracting the

00:16:19,360 --> 00:16:24,399
string value

00:16:20,720 --> 00:16:27,440
and then a little uh a little

00:16:24,399 --> 00:16:28,320
step here to ex convert the string into

00:16:27,440 --> 00:16:31,839
bytes

00:16:28,320 --> 00:16:32,880
and then we are going to put this data

00:16:31,839 --> 00:16:36,079
into i

00:16:32,880 --> 00:16:38,240
into a r socket sync now

00:16:36,079 --> 00:16:39,759
a little introduction to our socket is

00:16:38,240 --> 00:16:42,880
necessary here

00:16:39,759 --> 00:16:46,160
our socket is a protocol

00:16:42,880 --> 00:16:48,480
alternative to http so

00:16:46,160 --> 00:16:50,959
at the same level in you know it's an

00:16:48,480 --> 00:16:54,000
application level protocol

00:16:50,959 --> 00:16:56,720
um basically built

00:16:54,000 --> 00:16:57,680
with the reactive stream concepts in

00:16:56,720 --> 00:17:00,800
mind

00:16:57,680 --> 00:17:03,680
so there are solutions that uh

00:17:00,800 --> 00:17:04,959
leverage the reactive streams idea into

00:17:03,680 --> 00:17:08,640
http

00:17:04,959 --> 00:17:11,360
making it a back pressure enabled

00:17:08,640 --> 00:17:14,400
transmission of data across services but

00:17:11,360 --> 00:17:17,439
our socket is born with it

00:17:14,400 --> 00:17:19,600
and this is this is all you need to know

00:17:17,439 --> 00:17:20,559
uh really for now but our socket is

00:17:19,600 --> 00:17:23,679
really in uh

00:17:20,559 --> 00:17:24,799
an interesting uh project in fact our

00:17:23,679 --> 00:17:27,199
socket stems from

00:17:24,799 --> 00:17:29,200
reactive socket that that that's what it

00:17:27,199 --> 00:17:32,960
was called in the beginning

00:17:29,200 --> 00:17:36,080
and um you know it's it's above tcp

00:17:32,960 --> 00:17:37,120
so it really it makes a good candidate

00:17:36,080 --> 00:17:39,120
for two

00:17:37,120 --> 00:17:40,240
into inter communication between two

00:17:39,120 --> 00:17:42,960
services

00:17:40,240 --> 00:17:45,440
and in this case uh this legacy

00:17:42,960 --> 00:17:48,799
processor one what we have done

00:17:45,440 --> 00:17:52,000
is let's say this process item function

00:17:48,799 --> 00:17:54,480
method here represents a

00:17:52,000 --> 00:17:54,480
legacy

00:17:55,039 --> 00:17:58,160
type of processing maybe we are dealing

00:17:57,840 --> 00:18:00,640
with

00:17:58,160 --> 00:18:02,240
indeed some legacy logic that we have

00:18:00,640 --> 00:18:03,280
and we don't want to change them all we

00:18:02,240 --> 00:18:06,320
want to do is

00:18:03,280 --> 00:18:08,400
wrap it inside a stream

00:18:06,320 --> 00:18:10,640
and then the data that comes out of it

00:18:08,400 --> 00:18:13,919
we are going to offer to this

00:18:10,640 --> 00:18:15,679
r socket sync it's uh

00:18:13,919 --> 00:18:16,960
uh we are going to look at the

00:18:15,679 --> 00:18:20,080
implementation of this

00:18:16,960 --> 00:18:20,559
a little bit later if we look for a

00:18:20,080 --> 00:18:23,760
second

00:18:20,559 --> 00:18:27,440
at the second legacy processor which

00:18:23,760 --> 00:18:30,799
you are seeing on my screen um

00:18:27,440 --> 00:18:34,320
this is a java application which again

00:18:30,799 --> 00:18:37,760
um it

00:18:34,320 --> 00:18:40,320
will create a kafka producer

00:18:37,760 --> 00:18:42,320
in this case because the output is

00:18:40,320 --> 00:18:45,440
producing data onto a

00:18:42,320 --> 00:18:48,880
second kafka topic and then this

00:18:45,440 --> 00:18:51,919
code that you see here is about

00:18:48,880 --> 00:18:57,360
let's say this block here

00:18:51,919 --> 00:19:01,919
is about creating a r socket receiver

00:18:57,360 --> 00:19:04,160
so once the first legacy processor finds

00:19:01,919 --> 00:19:05,039
a valid connection to the to the

00:19:04,160 --> 00:19:08,400
receiver

00:19:05,039 --> 00:19:11,600
it will start pushing data through

00:19:08,400 --> 00:19:12,240
and what happens with the data that we

00:19:11,600 --> 00:19:15,520
receive

00:19:12,240 --> 00:19:19,200
is is right here is this bit

00:19:15,520 --> 00:19:19,840
um for each item that we receive from

00:19:19,200 --> 00:19:22,840
the

00:19:19,840 --> 00:19:24,160
first legacy processor we are going to

00:19:22,840 --> 00:19:27,360
extract

00:19:24,160 --> 00:19:30,080
its string content and

00:19:27,360 --> 00:19:33,120
simulate some work this is again

00:19:30,080 --> 00:19:37,200
simulation of some legacy processing

00:19:33,120 --> 00:19:38,080
logic this processing actually is maybe

00:19:37,200 --> 00:19:41,760
a little interesting

00:19:38,080 --> 00:19:41,760
to look at it's just down here

00:19:42,000 --> 00:19:48,799
it will basically make our machine

00:19:45,840 --> 00:19:50,480
and our thread slipped for a random

00:19:48,799 --> 00:19:54,480
number of seconds

00:19:50,480 --> 00:19:58,400
we'll see uh later why are random

00:19:54,480 --> 00:20:02,080
and and after we are done processing

00:19:58,400 --> 00:20:06,080
we are going to publish the data

00:20:02,080 --> 00:20:08,320
onto a second kafka topic

00:20:06,080 --> 00:20:10,320
what's interesting oops what's

00:20:08,320 --> 00:20:13,360
interesting to notice here

00:20:10,320 --> 00:20:16,640
is that when only

00:20:13,360 --> 00:20:19,120
at the moment when we return

00:20:16,640 --> 00:20:22,559
from this method once the execution of

00:20:19,120 --> 00:20:26,240
this logic highlighted now as completed

00:20:22,559 --> 00:20:29,360
this is going to be the signal

00:20:26,240 --> 00:20:30,240
to the first legacy processor that we

00:20:29,360 --> 00:20:33,600
are ready

00:20:30,240 --> 00:20:36,799
to receive more data and this

00:20:33,600 --> 00:20:39,760
syntax here flux dot empty

00:20:36,799 --> 00:20:40,720
you are probably familiar with it if you

00:20:39,760 --> 00:20:44,080
have used the

00:20:40,720 --> 00:20:47,360
project reactor or

00:20:44,080 --> 00:20:49,120
spring boot spring boot esque

00:20:47,360 --> 00:20:51,200
applications you are probably familiar

00:20:49,120 --> 00:20:54,480
with this logic

00:20:51,200 --> 00:20:57,200
um and and this is all i want to say for

00:20:54,480 --> 00:21:00,240
the moment about this legacy processor

00:20:57,200 --> 00:21:04,080
um let's try and give these

00:21:00,240 --> 00:21:05,120
two guys a spin in this window here so

00:21:04,080 --> 00:21:08,159
let me first

00:21:05,120 --> 00:21:12,159
start let me just check that

00:21:08,159 --> 00:21:15,520
yes our our sources producer is

00:21:12,159 --> 00:21:19,039
still producing data on kafka so let's

00:21:15,520 --> 00:21:31,120
spin up our

00:21:19,039 --> 00:21:34,320
first legacy processor

00:21:31,120 --> 00:21:37,600
now this processor has started

00:21:34,320 --> 00:21:39,360
and it's trying to connect to a r socket

00:21:37,600 --> 00:21:40,159
receiver but at the moment there's none

00:21:39,360 --> 00:21:42,400
running

00:21:40,159 --> 00:21:44,799
so what's interesting already to notice

00:21:42,400 --> 00:21:49,039
is that because there is no

00:21:44,799 --> 00:21:52,000
server running then this entire stream

00:21:49,039 --> 00:21:53,520
is not consuming anything because this

00:21:52,000 --> 00:21:56,799
particular component

00:21:53,520 --> 00:21:59,200
is not asking for anything to consume so

00:21:56,799 --> 00:22:02,960
by going all the way back to the source

00:21:59,200 --> 00:22:06,559
we are not consuming anything from kafka

00:22:02,960 --> 00:22:09,760
this consumption will start when we

00:22:06,559 --> 00:22:09,760
trigger the second

00:22:10,480 --> 00:22:17,200
legacy processor what we

00:22:13,760 --> 00:22:20,240
should see if the demo gods help us

00:22:17,200 --> 00:22:22,799
is that this the first

00:22:20,240 --> 00:22:24,080
legacy processor will connect to the

00:22:22,799 --> 00:22:29,039
listener

00:22:24,080 --> 00:22:29,039
and start consuming events from kafka

00:22:30,640 --> 00:22:33,039
there it is

00:22:34,960 --> 00:22:39,520
so here what you could see is

00:22:39,600 --> 00:22:46,240
the when an item is received on the

00:22:43,600 --> 00:22:49,760
second processor

00:22:46,240 --> 00:22:51,360
then there is this random delay so you

00:22:49,760 --> 00:22:55,200
see two seconds

00:22:51,360 --> 00:22:58,159
uh three seconds and

00:22:55,200 --> 00:23:00,400
the first processor is only reading

00:22:58,159 --> 00:23:04,240
messages from kafka

00:23:00,400 --> 00:23:05,679
as there is availability from the second

00:23:04,240 --> 00:23:07,679
processor

00:23:05,679 --> 00:23:09,039
and so you see that they really go hand

00:23:07,679 --> 00:23:13,120
in hand

00:23:09,039 --> 00:23:15,520
the entire thing is is

00:23:13,120 --> 00:23:17,679
protected in this sense we are only

00:23:15,520 --> 00:23:20,799
consuming data when there is

00:23:17,679 --> 00:23:20,799
some need for it

00:23:20,960 --> 00:23:26,799
um and i just want to

00:23:24,880 --> 00:23:28,880
this this concludes our demo i just want

00:23:26,799 --> 00:23:31,440
to spend one more minute

00:23:28,880 --> 00:23:34,240
for those of you familiar with the akka

00:23:31,440 --> 00:23:36,320
streams is an incredibly powerful

00:23:34,240 --> 00:23:39,600
ecosystem incredibly rich there are

00:23:36,320 --> 00:23:42,480
kafka connectors http connectors or

00:23:39,600 --> 00:23:43,039
connectors um to connect to basically

00:23:42,480 --> 00:23:46,880
most

00:23:43,039 --> 00:23:47,919
of your uh potential technology

00:23:46,880 --> 00:23:51,360
underneath

00:23:47,919 --> 00:23:51,840
in a reactive way but interestingly

00:23:51,360 --> 00:23:54,559
enough

00:23:51,840 --> 00:23:56,080
there isn't an official connector for

00:23:54,559 --> 00:23:59,360
our socket

00:23:56,080 --> 00:24:02,000
so what i have done um i have

00:23:59,360 --> 00:24:03,279
created these two r socket sync and

00:24:02,000 --> 00:24:06,720
sources

00:24:03,279 --> 00:24:07,279
um get an inspiration there is a blog

00:24:06,720 --> 00:24:09,200
post

00:24:07,279 --> 00:24:11,840
actually on the liteman website which i

00:24:09,200 --> 00:24:14,000
used as a

00:24:11,840 --> 00:24:14,960
inspiration and and then built on top of

00:24:14,000 --> 00:24:18,080
that

00:24:14,960 --> 00:24:20,720
this code you see here is a are is the

00:24:18,080 --> 00:24:24,559
our socket sync that we are using

00:24:20,720 --> 00:24:24,559
and the idea is um

00:24:24,960 --> 00:24:32,159
this is the uh area where we create

00:24:28,559 --> 00:24:35,600
the uh the connection to the

00:24:32,159 --> 00:24:39,360
our socket receiver and then

00:24:35,600 --> 00:24:44,240
um what i want you to look at

00:24:39,360 --> 00:24:44,240
is basically two things

00:24:44,840 --> 00:24:48,320
this method here that we have

00:24:47,360 --> 00:24:51,679
overwritten

00:24:48,320 --> 00:24:53,600
on push lets us

00:24:51,679 --> 00:24:54,880
write the logic of when we should

00:24:53,600 --> 00:24:58,159
retrieve items

00:24:54,880 --> 00:25:01,840
from the stream and when we should

00:24:58,159 --> 00:25:01,840
get then the next one

00:25:01,919 --> 00:25:09,840
so in this case this grub

00:25:06,000 --> 00:25:13,279
is a is the signal to grab

00:25:09,840 --> 00:25:17,200
an item from upstream

00:25:13,279 --> 00:25:21,840
and then only

00:25:17,200 --> 00:25:23,919
uh so we are grabbing some payload here

00:25:21,840 --> 00:25:25,360
here this is the line where we are

00:25:23,919 --> 00:25:29,200
sending the payload

00:25:25,360 --> 00:25:30,640
further and then only when there is a

00:25:29,200 --> 00:25:33,679
request

00:25:30,640 --> 00:25:36,960
we are asking for

00:25:33,679 --> 00:25:40,880
a new item that will be triggered from

00:25:36,960 --> 00:25:44,559
above um

00:25:40,880 --> 00:25:46,159
and the the code is online so you can

00:25:44,559 --> 00:25:49,679
look at it

00:25:46,159 --> 00:25:52,480
um this is all for our little demo

00:25:49,679 --> 00:25:53,120
and now i would like to share with you a

00:25:52,480 --> 00:25:55,200
couple of

00:25:53,120 --> 00:25:56,960
conclusions about this experience from

00:25:55,200 --> 00:25:59,360
building these pipelines so the good

00:25:56,960 --> 00:26:00,960
things and the bad things i found

00:25:59,360 --> 00:26:02,400
well first of all i have some experience

00:26:00,960 --> 00:26:05,039
with reactive streams

00:26:02,400 --> 00:26:06,480
already but if you haven't been exposed

00:26:05,039 --> 00:26:09,039
to them to this kind of

00:26:06,480 --> 00:26:10,640
standard it really is incredible it it

00:26:09,039 --> 00:26:11,919
enables you to work with different

00:26:10,640 --> 00:26:14,960
technologies

00:26:11,919 --> 00:26:18,320
uh not only on the jbm you could

00:26:14,960 --> 00:26:19,360
have a reactive stream uh implementation

00:26:18,320 --> 00:26:22,240
in python

00:26:19,360 --> 00:26:24,000
for instance why not and and and still

00:26:22,240 --> 00:26:26,880
keep this streaming semantics

00:26:24,000 --> 00:26:28,640
of back pressure all the way through the

00:26:26,880 --> 00:26:31,279
pipeline

00:26:28,640 --> 00:26:31,840
but something that is not great is that

00:26:31,279 --> 00:26:34,640
different

00:26:31,840 --> 00:26:37,360
implementations as you can see are not

00:26:34,640 --> 00:26:40,159
yet very easy to get to work together

00:26:37,360 --> 00:26:41,360
in the same process our socket is a

00:26:40,159 --> 00:26:43,520
great technology

00:26:41,360 --> 00:26:45,600
but unfortunately documentation is very

00:26:43,520 --> 00:26:48,559
limited

00:26:45,600 --> 00:26:48,960
i asked some things online and i got

00:26:48,559 --> 00:26:52,640
help

00:26:48,960 --> 00:26:54,799
from the helpful contributors uh

00:26:52,640 --> 00:26:56,480
but mostly pointing to the examples

00:26:54,799 --> 00:26:58,960
online which are

00:26:56,480 --> 00:27:00,480
certainly useful but then again limited

00:26:58,960 --> 00:27:03,120
and you have to do a lot of work to

00:27:00,480 --> 00:27:06,559
figure things out as you go

00:27:03,120 --> 00:27:08,400
um i use i also didn't like very much

00:27:06,559 --> 00:27:10,640
that the java implementation relies on

00:27:08,400 --> 00:27:14,480
project reactor

00:27:10,640 --> 00:27:15,279
um because uh you might simply not want

00:27:14,480 --> 00:27:16,720
that

00:27:15,279 --> 00:27:18,399
you might want to use a different

00:27:16,720 --> 00:27:21,520
implementation and

00:27:18,399 --> 00:27:23,520
if you are in the spring sort of world

00:27:21,520 --> 00:27:24,880
this is perfect it is absolutely perfect

00:27:23,520 --> 00:27:28,080
for you it will

00:27:24,880 --> 00:27:28,960
just mix seamlessly with spring boot in

00:27:28,080 --> 00:27:32,720
fact there's

00:27:28,960 --> 00:27:35,520
books written about it but if you don't

00:27:32,720 --> 00:27:36,559
particularly like project reactor you're

00:27:35,520 --> 00:27:40,559
still stuck with it

00:27:36,559 --> 00:27:43,120
so it's you know just a dependency

00:27:40,559 --> 00:27:45,120
in fact my conclusion is that in fact

00:27:43,120 --> 00:27:46,320
while not built for this streaming

00:27:45,120 --> 00:27:49,520
purpose

00:27:46,320 --> 00:27:52,799
if you mix http with the

00:27:49,520 --> 00:27:54,320
with some underlying streaming semantics

00:27:52,799 --> 00:27:56,960
and there are some projects that have

00:27:54,320 --> 00:27:59,440
done that like http

00:27:56,960 --> 00:28:00,399
well this solution might be a more

00:27:59,440 --> 00:28:03,200
efficient

00:28:00,399 --> 00:28:05,600
and faster way for you to modernize your

00:28:03,200 --> 00:28:09,279
legacy application

00:28:05,600 --> 00:28:12,799
and um this is

00:28:09,279 --> 00:28:15,440
uh all for me and maybe we can

00:28:12,799 --> 00:28:16,799
have some share some conclusion together

00:28:15,440 --> 00:28:19,360
with mary at this point

00:28:16,799 --> 00:28:22,000
sure yeah thank you fabio it's a great

00:28:19,360 --> 00:28:25,279
uh demo and and very clearly

00:28:22,000 --> 00:28:27,360
explains thank you so yeah and um

00:28:25,279 --> 00:28:29,360
yeah we're kind of looking at this whole

00:28:27,360 --> 00:28:30,240
pipeline and we're wondering yeah this

00:28:29,360 --> 00:28:34,320
is like a

00:28:30,240 --> 00:28:36,880
sample uh implementation

00:28:34,320 --> 00:28:38,960
could we actually have uh other

00:28:36,880 --> 00:28:40,960
implementations i think as you mentioned

00:28:38,960 --> 00:28:43,279
about right we could actually write

00:28:40,960 --> 00:28:44,799
maybe the legacy processor too could be

00:28:43,279 --> 00:28:47,919
like in python

00:28:44,799 --> 00:28:48,720
in even javascript maybe node.js for

00:28:47,919 --> 00:28:50,960
sure

00:28:48,720 --> 00:28:53,039
please so i think it basically we're

00:28:50,960 --> 00:28:55,200
trying to illustrate this set with the

00:28:53,039 --> 00:28:58,480
reactive streams uh

00:28:55,200 --> 00:29:01,600
kind of approach it's it's actually uh

00:28:58,480 --> 00:29:04,480
make your application a lot more uh

00:29:01,600 --> 00:29:06,320
module so to speak like modularize uh if

00:29:04,480 --> 00:29:08,399
you're writing microservices you can

00:29:06,320 --> 00:29:09,679
actually have the legacy processor as

00:29:08,399 --> 00:29:11,760
one microservice

00:29:09,679 --> 00:29:14,000
and the other legacy processor is

00:29:11,760 --> 00:29:15,120
another one and so you can see that they

00:29:14,000 --> 00:29:16,960
all connect

00:29:15,120 --> 00:29:18,159
with each other through messaging and in

00:29:16,960 --> 00:29:20,799
this case we

00:29:18,159 --> 00:29:21,360
as fabio has illustrated will be in our

00:29:20,799 --> 00:29:23,600
socket

00:29:21,360 --> 00:29:24,960
and you can plug different things in

00:29:23,600 --> 00:29:27,840
plug-and-play so it

00:29:24,960 --> 00:29:28,880
it's actually a very flexible approach

00:29:27,840 --> 00:29:31,679
and that's what we

00:29:28,880 --> 00:29:33,679
also like about our reactive and it's

00:29:31,679 --> 00:29:35,440
because of that capability that kind of

00:29:33,679 --> 00:29:38,640
enables us to do things

00:29:35,440 --> 00:29:41,600
more efficiently too indeed yeah yeah

00:29:38,640 --> 00:29:42,000
exactly so yeah yeah and then also maybe

00:29:41,600 --> 00:29:43,840
one

00:29:42,000 --> 00:29:45,360
last kind of conclusion is that well how

00:29:43,840 --> 00:29:48,559
about like project loom

00:29:45,360 --> 00:29:49,520
that's kind of scheduled now for java 18

00:29:48,559 --> 00:29:51,440
i believe and

00:29:49,520 --> 00:29:52,640
that's right there's still a couple more

00:29:51,440 --> 00:29:55,919
versions before

00:29:52,640 --> 00:29:56,960
it will be released but we wonder right

00:29:55,919 --> 00:30:00,480
with virtual

00:29:56,960 --> 00:30:02,880
threads uh carrier threads too right and

00:30:00,480 --> 00:30:05,279
we wonder how you know how it would be

00:30:02,880 --> 00:30:06,880
and there i've also like heard about

00:30:05,279 --> 00:30:08,799
people talking about oh

00:30:06,880 --> 00:30:10,320
project looms coming out reactive is

00:30:08,799 --> 00:30:12,640
gonna be dead and

00:30:10,320 --> 00:30:13,600
but i really i don't think so right i

00:30:12,640 --> 00:30:15,919
mean how can

00:30:13,600 --> 00:30:16,960
i mean reactive so to speak we're

00:30:15,919 --> 00:30:18,720
handling

00:30:16,960 --> 00:30:20,480
uh the problem domain on a different

00:30:18,720 --> 00:30:23,039
level on a more abstract

00:30:20,480 --> 00:30:24,080
level but uh the virtual threads are a

00:30:23,039 --> 00:30:26,559
bit more of the

00:30:24,080 --> 00:30:28,080
lower level dealing with more of the uh

00:30:26,559 --> 00:30:31,360
towards more of the primitive

00:30:28,080 --> 00:30:33,919
kind of more threading kind of um

00:30:31,360 --> 00:30:34,559
that that direction so then it's more

00:30:33,919 --> 00:30:36,559
like they

00:30:34,559 --> 00:30:38,480
they both should be complementing each

00:30:36,559 --> 00:30:41,919
other is what i'm doing exactly

00:30:38,480 --> 00:30:43,679
i fully agree i think um project loom

00:30:41,919 --> 00:30:45,840
is definitely going to be a very very

00:30:43,679 --> 00:30:50,000
powerful uh

00:30:45,840 --> 00:30:52,240
addition to the jbm um in my personal uh

00:30:50,000 --> 00:30:53,840
opinion i think is going to be very

00:30:52,240 --> 00:30:57,519
useful for

00:30:53,840 --> 00:30:59,200
low-level uh logic so maybe if you are a

00:30:57,519 --> 00:31:00,720
library maintainer

00:30:59,200 --> 00:31:02,480
or uh well maybe if you're the

00:31:00,720 --> 00:31:03,440
maintainer of one of these reactive

00:31:02,480 --> 00:31:05,360
library

00:31:03,440 --> 00:31:06,880
yourself this is going to be really

00:31:05,360 --> 00:31:10,159
really useful

00:31:06,880 --> 00:31:13,919
but for a lot of users you know simple

00:31:10,159 --> 00:31:17,360
simple users of these libraries

00:31:13,919 --> 00:31:20,720
i think we will still prefer to

00:31:17,360 --> 00:31:22,159
operate at a higher level than you know

00:31:20,720 --> 00:31:24,159
going back to uh

00:31:22,159 --> 00:31:27,120
creating and speeding up threads

00:31:24,159 --> 00:31:30,159
ourselves even if they're virtual

00:31:27,120 --> 00:31:31,840
we'll see we'll see how it plays out

00:31:30,159 --> 00:31:34,080
but yeah certainly something to

00:31:31,840 --> 00:31:37,440
definitely keep keep an eye on

00:31:34,080 --> 00:31:38,960
yeah very true yeah wonderful yeah it's

00:31:37,440 --> 00:31:41,120
been a great uh

00:31:38,960 --> 00:31:42,960
conversation too in our presentation

00:31:41,120 --> 00:31:46,159
hope everybody enjoys it and

00:31:42,960 --> 00:31:48,640
uh yeah these are a couple of links to

00:31:46,159 --> 00:31:49,360
lots of things we've mentioned the first

00:31:48,640 --> 00:31:52,960
one is

00:31:49,360 --> 00:31:55,760
the sample code that i've shown you

00:31:52,960 --> 00:31:57,919
our socket quarkus docker lots of

00:31:55,760 --> 00:32:01,200
technologies that we mentioned

00:31:57,919 --> 00:32:01,679
and i believe this is uh offer from us

00:32:01,200 --> 00:32:04,960
so

00:32:01,679 --> 00:32:07,760
thank you very much these are our uh

00:32:04,960 --> 00:32:08,159
contacts and our and our links that's

00:32:07,760 --> 00:32:10,799
right

00:32:08,159 --> 00:32:11,840
yeah thank you all for attending our

00:32:10,799 --> 00:32:14,159
talk

00:32:11,840 --> 00:32:15,120
thank you mary and fabio uh there's

00:32:14,159 --> 00:32:19,039
there's a question

00:32:15,120 --> 00:32:22,000
um how are errors managed between

00:32:19,039 --> 00:32:24,000
the r socket producer and receiver uh

00:32:22,000 --> 00:32:26,000
acknowledgement for instance

00:32:24,000 --> 00:32:28,399
um what's happening if do some

00:32:26,000 --> 00:32:31,519
processing fails and

00:32:28,399 --> 00:32:34,399
flux.empty is not reached in the second

00:32:31,519 --> 00:32:34,399
legacy system

00:32:34,640 --> 00:32:39,120
yeah so um hi everybody i hope you can

00:32:37,600 --> 00:32:41,519
see me and hear me

00:32:39,120 --> 00:32:42,240
uh no problem thanks for attending our

00:32:41,519 --> 00:32:45,200
talk

00:32:42,240 --> 00:32:46,320
um and yes very good question what

00:32:45,200 --> 00:32:50,320
happens there

00:32:46,320 --> 00:32:51,519
um i think um if if you hang that thing

00:32:50,320 --> 00:32:53,679
forever

00:32:51,519 --> 00:32:56,000
uh because of some reason and that flux

00:32:53,679 --> 00:32:57,519
that empty line is never triggered and

00:32:56,000 --> 00:32:58,799
the entire chain will simply hang

00:32:57,519 --> 00:33:01,279
forever

00:32:58,799 --> 00:33:02,320
so it is really up to you to make sure

00:33:01,279 --> 00:33:05,600
that eventually

00:33:02,320 --> 00:33:07,600
you have a time out or uh your your

00:33:05,600 --> 00:33:11,039
resilient in that sense

00:33:07,600 --> 00:33:14,559
um i would imagine that if the

00:33:11,039 --> 00:33:17,760
if the entire process crashes um

00:33:14,559 --> 00:33:20,080
then the the other side uh

00:33:17,760 --> 00:33:21,919
wouldn't get a reply to that so probably

00:33:20,080 --> 00:33:25,519
there needs to be some time at that

00:33:21,919 --> 00:33:26,080
time out there as well but yeah this is

00:33:25,519 --> 00:33:39,840
i think

00:33:26,080 --> 00:33:39,840
it's really about your business logic

00:33:48,799 --> 00:33:50,880

YouTube URL: https://www.youtube.com/watch?v=KRIJ0LXFnDA


