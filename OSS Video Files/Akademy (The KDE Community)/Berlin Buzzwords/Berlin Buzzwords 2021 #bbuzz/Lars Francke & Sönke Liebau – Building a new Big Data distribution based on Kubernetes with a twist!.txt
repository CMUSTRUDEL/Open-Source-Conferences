Title: Lars Francke & Sönke Liebau – Building a new Big Data distribution based on Kubernetes with a twist!
Publication date: 2021-06-23
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	The need for companies to deploy and operate Big Data infrastructures hasn't gone away but their options to do so have dwindled in the past few years. That's why we decided to build a new Open Source Big Data distribution.

It includes the usual suspects like Apache Kafka, Apache Spark, Apache NiFi, etc.

We asked around and were told it's a crazy idea but we did it anyway: We implemented a Kubelet in Rust that uses systemd as its backend instead of a container runtime. We also started writing Operators that target these special kubelets.

This means we can deploy hybrid infrastructure (partly running in containers and partly on "bare metal") using the same stack, the same tools, the same description languages, the same knowledge, etc. getting the best of both worlds.

In this talk we'll share what we learned about writing Kubernetes Operators (in Rust) as well as gain insights into our new distribution.

Speaker:
Lars Francke – https://2021.berlinbuzzwords.de/member/lars-francke
Sönke Liebau – https://2021.berlinbuzzwords.de/member/sonke-liebau

More: https://2021.berlinbuzzwords.de/session/building-new-big-data-distribution-based-kubernetes-twist
Captions: 
	00:00:08,480 --> 00:00:11,840
hello everybody my name is

00:00:09,920 --> 00:00:13,200
zhang lieber i work with stackable and

00:00:11,840 --> 00:00:15,200
together with lars franke

00:00:13,200 --> 00:00:16,720
i'm here today to give you a brief

00:00:15,200 --> 00:00:19,600
insight into what our

00:00:16,720 --> 00:00:19,600
vision for the future

00:00:20,960 --> 00:00:24,240
yeah thank you zunker and yeah my name

00:00:23,519 --> 00:00:26,400
is

00:00:24,240 --> 00:00:28,560
uh las franca and as jungkook mentioned

00:00:26,400 --> 00:00:31,279
i'm also working at stackable

00:00:28,560 --> 00:00:33,600
and yeah we're talking about um a new

00:00:31,279 --> 00:00:36,480
kind of big data distribution

00:00:33,600 --> 00:00:37,760
as as zinke already mentioned uh

00:00:36,480 --> 00:00:38,879
obviously i don't know any of your

00:00:37,760 --> 00:00:41,440
backgrounds i don't know

00:00:38,879 --> 00:00:43,440
anyone who's listening so i'll give a

00:00:41,440 --> 00:00:45,440
super quick introduction

00:00:43,440 --> 00:00:46,800
uh what what we mean by big data

00:00:45,440 --> 00:00:49,760
distribution and

00:00:46,800 --> 00:00:50,960
and uh yeah what we're talking about so

00:00:49,760 --> 00:00:54,719
the whole big data

00:00:50,960 --> 00:00:57,360
ecosystem started around 2006 2008

00:00:54,719 --> 00:01:00,160
with the apache hadoop ecosystem i

00:00:57,360 --> 00:01:02,079
assume that some of you or most of you

00:01:00,160 --> 00:01:03,920
already know tools like apache kafka

00:01:02,079 --> 00:01:07,280
apache spark apache nifi

00:01:03,920 --> 00:01:09,280
apache hbase and so on and there's

00:01:07,280 --> 00:01:10,960
there's lots of tools out there in this

00:01:09,280 --> 00:01:12,720
big data space like if you want a

00:01:10,960 --> 00:01:15,040
process store uh visualize

00:01:12,720 --> 00:01:16,320
lots lots of data with open source tools

00:01:15,040 --> 00:01:18,560
you have to use

00:01:16,320 --> 00:01:19,360
more than more than one tool often tense

00:01:18,560 --> 00:01:21,680
or so

00:01:19,360 --> 00:01:22,880
so what what what happened is around

00:01:21,680 --> 00:01:25,680
00:01:22,880 --> 00:01:27,439
the first distributions happened so

00:01:25,680 --> 00:01:30,479
these are companies

00:01:27,439 --> 00:01:33,200
and these companies started building

00:01:30,479 --> 00:01:34,720
distributions basically they packaged

00:01:33,200 --> 00:01:38,159
the software

00:01:34,720 --> 00:01:40,240
or all the um all the open source tools

00:01:38,159 --> 00:01:42,399
they packaged them together made it easy

00:01:40,240 --> 00:01:42,640
to manage made it easy to deploy upgrade

00:01:42,399 --> 00:01:45,920
and

00:01:42,640 --> 00:01:47,520
and sell your support um

00:01:45,920 --> 00:01:49,439
these numbers might be off a bit it's

00:01:47,520 --> 00:01:51,840
not super easy to find find the

00:01:49,439 --> 00:01:53,439
find the exact yes but as you can see

00:01:51,840 --> 00:01:56,000
like back in 2008 or

00:01:53,439 --> 00:01:57,600
the 2011 and so on there were four or

00:01:56,000 --> 00:01:58,560
five different companies offering these

00:01:57,600 --> 00:02:01,840
kind of

00:01:58,560 --> 00:02:03,759
distributions um you can see that intel

00:02:01,840 --> 00:02:05,280
dropped off fairly early they invested

00:02:03,759 --> 00:02:07,119
in cloudera instead

00:02:05,280 --> 00:02:08,720
later ibm dropped off and pivotal

00:02:07,119 --> 00:02:11,520
dropped off they

00:02:08,720 --> 00:02:12,879
merged or migrated to hot works so these

00:02:11,520 --> 00:02:16,640
are all companies

00:02:12,879 --> 00:02:18,239
that that did offer or still offer um

00:02:16,640 --> 00:02:19,760
commercial distributions around there

00:02:18,239 --> 00:02:22,080
around the hadoop ecosystem

00:02:19,760 --> 00:02:23,680
now as you can see since 2019 there's

00:02:22,080 --> 00:02:24,160
only single distribution left so there's

00:02:23,680 --> 00:02:26,000
only

00:02:24,160 --> 00:02:28,480
the cloudera and they have their their

00:02:26,000 --> 00:02:31,360
own distribution and that's the only

00:02:28,480 --> 00:02:34,160
commercial distribution left for like

00:02:31,360 --> 00:02:36,239
on-premise big data stuff

00:02:34,160 --> 00:02:37,360
out there there is an obvious

00:02:36,239 --> 00:02:39,040
competition and that

00:02:37,360 --> 00:02:41,040
that are all the cloud vendors like you

00:02:39,040 --> 00:02:42,080
can obviously go to amazon and uh google

00:02:41,040 --> 00:02:45,599
and microsoft and

00:02:42,080 --> 00:02:48,720
and buy these things um uh in the cloud

00:02:45,599 --> 00:02:50,640
but you can't get it you can't get it on

00:02:48,720 --> 00:02:52,319
for on-premise in one package other than

00:02:50,640 --> 00:02:54,080
cloudera

00:02:52,319 --> 00:02:55,920
so cloudera and hortonworks merged in

00:02:54,080 --> 00:02:58,560
2019 and

00:02:55,920 --> 00:03:00,800
what happened then is is this this is

00:02:58,560 --> 00:03:03,920
not to scale it's just illustrative

00:03:00,800 --> 00:03:05,760
and the pricing for these distributions

00:03:03,920 --> 00:03:07,200
usually was like per node like if you

00:03:05,760 --> 00:03:08,640
had one node you paid this amount of

00:03:07,200 --> 00:03:11,040
money if you had two nodes

00:03:08,640 --> 00:03:11,840
you paid this amount of money and so on

00:03:11,040 --> 00:03:14,800
and

00:03:11,840 --> 00:03:15,599
the prices remained relatively stable

00:03:14,800 --> 00:03:18,159
for most

00:03:15,599 --> 00:03:19,760
of the of the time but when only a

00:03:18,159 --> 00:03:21,280
single company was left the prices

00:03:19,760 --> 00:03:23,599
skyrocketed from

00:03:21,280 --> 00:03:24,560
i think two thousand dollars per node

00:03:23,599 --> 00:03:28,080
per year to

00:03:24,560 --> 00:03:29,920
uh ten thousand per per node per year

00:03:28,080 --> 00:03:31,840
obviously before discounts and so on but

00:03:29,920 --> 00:03:34,080
anyway

00:03:31,840 --> 00:03:35,760
and both cloudera and hortonworks

00:03:34,080 --> 00:03:36,720
actually did provide a free version of

00:03:35,760 --> 00:03:40,560
their distribution

00:03:36,720 --> 00:03:43,040
up until 2019 or a bit later

00:03:40,560 --> 00:03:44,959
but after the merger the free version

00:03:43,040 --> 00:03:45,599
was removed and these pricing changes

00:03:44,959 --> 00:03:48,640
came

00:03:45,599 --> 00:03:50,879
came into effect and

00:03:48,640 --> 00:03:52,159
the fact is for people using this stuff

00:03:50,879 --> 00:03:53,920
on premise

00:03:52,159 --> 00:03:55,360
or even in the cloud obviously things

00:03:53,920 --> 00:03:56,080
have gotten much more much more

00:03:55,360 --> 00:03:59,200
expensive

00:03:56,080 --> 00:04:00,640
um so this is where we come in um while

00:03:59,200 --> 00:04:02,879
we're building what we're building

00:04:00,640 --> 00:04:04,080
uh both zuka and i already had like a

00:04:02,879 --> 00:04:06,000
small company with an

00:04:04,080 --> 00:04:07,120
open core like a big data consulting

00:04:06,000 --> 00:04:09,760
company

00:04:07,120 --> 00:04:12,159
and what happened in 2019 was that we

00:04:09,760 --> 00:04:14,080
got contacted by lots of our customers

00:04:12,159 --> 00:04:15,760
and they asked what what other what are

00:04:14,080 --> 00:04:17,600
your other customers doing now like we

00:04:15,760 --> 00:04:17,919
we used to pay this amount now we pay

00:04:17,600 --> 00:04:20,000
two

00:04:17,919 --> 00:04:22,160
three four five times or we used to use

00:04:20,000 --> 00:04:25,360
the free version and now we have to

00:04:22,160 --> 00:04:27,680
pay a lot of money out of a sudden so

00:04:25,360 --> 00:04:29,280
what what's everyone else doing now and

00:04:27,680 --> 00:04:30,320
what what we did is we organized a

00:04:29,280 --> 00:04:31,600
meeting

00:04:30,320 --> 00:04:34,720
or actually three or four this was

00:04:31,600 --> 00:04:37,919
before corona and it was in person

00:04:34,720 --> 00:04:39,440
and um yeah we organized a couple of

00:04:37,919 --> 00:04:42,720
meetings with like

00:04:39,440 --> 00:04:45,520
40 different companies and

00:04:42,720 --> 00:04:47,520
in germany and everyone was unhappy with

00:04:45,520 --> 00:04:49,120
the situation and so we decided to found

00:04:47,520 --> 00:04:52,160
stackable in 2020

00:04:49,120 --> 00:04:53,520
and um yeah we we are basically

00:04:52,160 --> 00:04:54,320
basically building our big data

00:04:53,520 --> 00:04:57,280
distribution

00:04:54,320 --> 00:04:58,800
but um yeah that's that's that's our

00:04:57,280 --> 00:05:00,240
super quick history

00:04:58,800 --> 00:05:02,160
uh the distribution that we're building

00:05:00,240 --> 00:05:04,880
is open source and um

00:05:02,160 --> 00:05:05,360
the things yeah we're building it on and

00:05:04,880 --> 00:05:07,759
our

00:05:05,360 --> 00:05:09,520
yeah foundation pieces are what we're

00:05:07,759 --> 00:05:11,199
going to talk about now and with that

00:05:09,520 --> 00:05:14,080
i'll hand over to zunker

00:05:11,199 --> 00:05:15,039
with what we actually do yes thank you

00:05:14,080 --> 00:05:17,360
guys

00:05:15,039 --> 00:05:19,039
so i have the same problem as last i

00:05:17,360 --> 00:05:21,039
don't know who's watching or what your

00:05:19,039 --> 00:05:23,120
background is so i'll start off with a

00:05:21,039 --> 00:05:25,120
very very brief introduction into

00:05:23,120 --> 00:05:26,000
kubernetes and i'll keep it really brief

00:05:25,120 --> 00:05:27,680
i promise

00:05:26,000 --> 00:05:29,360
because most of you probably know more

00:05:27,680 --> 00:05:32,000
about it than me

00:05:29,360 --> 00:05:33,680
um so when we started off we took a good

00:05:32,000 --> 00:05:36,479
look at what we actually need

00:05:33,680 --> 00:05:37,440
to to build a distribution of big data

00:05:36,479 --> 00:05:39,039
tools and

00:05:37,440 --> 00:05:41,280
it was fairly obvious that we would need

00:05:39,039 --> 00:05:42,880
something to sort of act as the central

00:05:41,280 --> 00:05:45,520
instance to a whole state

00:05:42,880 --> 00:05:47,440
but also something to decentrally manage

00:05:45,520 --> 00:05:48,880
the servers that we want to roll out

00:05:47,440 --> 00:05:52,479
these products on

00:05:48,880 --> 00:05:54,639
the the old or existing distributions

00:05:52,479 --> 00:05:56,639
all have some form of management tools

00:05:54,639 --> 00:05:57,520
so cloudera for example has the cloudera

00:05:56,639 --> 00:05:59,520
manager

00:05:57,520 --> 00:06:01,600
which has a web ui and you can click and

00:05:59,520 --> 00:06:04,240
add services and configure them

00:06:01,600 --> 00:06:05,520
for hortonworks it was ambari and every

00:06:04,240 --> 00:06:08,080
distribution pretty much had

00:06:05,520 --> 00:06:09,280
something to to manage and define your

00:06:08,080 --> 00:06:11,440
services in

00:06:09,280 --> 00:06:12,639
and um well we took a good look around

00:06:11,440 --> 00:06:14,720
at what's out there

00:06:12,639 --> 00:06:16,080
and kubernetes currently is fairly hard

00:06:14,720 --> 00:06:19,039
to miss it is

00:06:16,080 --> 00:06:19,520
one of the bigger projects in the uh

00:06:19,039 --> 00:06:22,319
pretty much

00:06:19,520 --> 00:06:22,800
any space currently so um we did take a

00:06:22,319 --> 00:06:25,919
good look

00:06:22,800 --> 00:06:26,319
hard look at kubernetes and um we've

00:06:25,919 --> 00:06:27,919
we've

00:06:26,319 --> 00:06:29,759
just pulled out a few of the basic

00:06:27,919 --> 00:06:31,440
principles of kubernetes here to give a

00:06:29,759 --> 00:06:32,800
brief introduction so um it's

00:06:31,440 --> 00:06:34,880
it's an orchestration framework to

00:06:32,800 --> 00:06:37,919
manage services

00:06:34,880 --> 00:06:41,280
um which is a fairly uh

00:06:37,919 --> 00:06:42,080
abstract thing to say it is declarative

00:06:41,280 --> 00:06:43,919
by nature so

00:06:42,080 --> 00:06:45,520
you don't tell kubernetes please do this

00:06:43,919 --> 00:06:47,440
please do that please do this

00:06:45,520 --> 00:06:48,639
but you simply tell it i would like my

00:06:47,440 --> 00:06:51,199
world to look like this

00:06:48,639 --> 00:06:53,199
go and make that happen so basically in

00:06:51,199 --> 00:06:55,199
in our world you would tell kubernetes

00:06:53,199 --> 00:06:58,319
i'd like a kafka cluster please

00:06:55,199 --> 00:07:00,479
on all nodes that match this descriptor

00:06:58,319 --> 00:07:02,160
and then you trust kubernetes to go and

00:07:00,479 --> 00:07:04,400
figure out what needs to happen to do

00:07:02,160 --> 00:07:04,400
that

00:07:04,479 --> 00:07:08,560
and to support that kubernetes offers a

00:07:06,319 --> 00:07:10,960
few basic data types so kubernetes has a

00:07:08,560 --> 00:07:12,880
few built-in data types things like

00:07:10,960 --> 00:07:14,080
ports which describe a workload to be

00:07:12,880 --> 00:07:16,400
executed

00:07:14,080 --> 00:07:17,759
nodes which describe you know a server

00:07:16,400 --> 00:07:19,120
that's out there that's ready to run a

00:07:17,759 --> 00:07:20,639
workload and

00:07:19,120 --> 00:07:22,960
lots and lots of other things around

00:07:20,639 --> 00:07:24,479
that like deployments and stateful sets

00:07:22,960 --> 00:07:25,919
and there's the secrets to store

00:07:24,479 --> 00:07:28,840
passwords and things like that

00:07:25,919 --> 00:07:30,639
so kubernetes offers lots of

00:07:28,840 --> 00:07:33,520
abstractions

00:07:30,639 --> 00:07:34,960
but and that's where it becomes really

00:07:33,520 --> 00:07:36,240
interesting kubernetes also offers

00:07:34,960 --> 00:07:37,039
something called custom resource

00:07:36,240 --> 00:07:40,080
descriptions

00:07:37,039 --> 00:07:41,599
which allows you to extend kubernetes to

00:07:40,080 --> 00:07:43,440
help you with what you exactly want to

00:07:41,599 --> 00:07:45,919
achieve so for us

00:07:43,440 --> 00:07:47,199
for example that's obviously we need to

00:07:45,919 --> 00:07:48,080
come up with a custom resource

00:07:47,199 --> 00:07:50,080
description

00:07:48,080 --> 00:07:52,560
to describe how an hdfs cluster should

00:07:50,080 --> 00:07:55,680
look like or a kafka cluster

00:07:52,560 --> 00:07:57,199
or going a bit more abstract for example

00:07:55,680 --> 00:08:00,319
a kafka topic

00:07:57,199 --> 00:08:02,160
or acls on a kafka topic and then those

00:08:00,319 --> 00:08:04,000
those resources can can relate to each

00:08:02,160 --> 00:08:06,160
other so for example you could define

00:08:04,000 --> 00:08:07,039
a kafka topic and an acl that relates to

00:08:06,160 --> 00:08:08,400
that topic

00:08:07,039 --> 00:08:10,400
and then deploy that to separate

00:08:08,400 --> 00:08:13,120
clusters so it's a very

00:08:10,400 --> 00:08:13,599
fairly flexible data model that you can

00:08:13,120 --> 00:08:16,879
build

00:08:13,599 --> 00:08:18,639
on top of kubernetes and i was listening

00:08:16,879 --> 00:08:21,680
to a podcast recently which there

00:08:18,639 --> 00:08:23,039
someone said comedy kubernetes is less a

00:08:21,680 --> 00:08:24,560
list of a deployment technology or

00:08:23,039 --> 00:08:25,840
something but it's a platform to build

00:08:24,560 --> 00:08:28,000
platforms

00:08:25,840 --> 00:08:29,759
which sounds a bit cheesy if we're

00:08:28,000 --> 00:08:30,879
honest but it is actually not too far

00:08:29,759 --> 00:08:33,120
from the truth

00:08:30,879 --> 00:08:34,159
because um using these abstraction

00:08:33,120 --> 00:08:36,800
layers you can actually

00:08:34,159 --> 00:08:38,320
just use the kubernetes control plane to

00:08:36,800 --> 00:08:40,719
create

00:08:38,320 --> 00:08:41,839
platforms of your own and um i actually

00:08:40,719 --> 00:08:43,039
had to look up the description of

00:08:41,839 --> 00:08:45,120
platform and it

00:08:43,039 --> 00:08:46,959
what i found was uh it's a layer of

00:08:45,120 --> 00:08:48,000
technology that makes software delivery

00:08:46,959 --> 00:08:50,399
possible

00:08:48,000 --> 00:08:51,839
which is pretty much exactly what we are

00:08:50,399 --> 00:08:53,519
trying to achieve so

00:08:51,839 --> 00:08:55,519
that that fits the build fairly well for

00:08:53,519 --> 00:08:58,640
us

00:08:55,519 --> 00:09:02,560
so if you take a look from very high up

00:08:58,640 --> 00:09:04,399
at kubernetes um what kubernetes is is

00:09:02,560 --> 00:09:05,839
at the center of it is the api server

00:09:04,399 --> 00:09:08,160
that's the central instance that you

00:09:05,839 --> 00:09:10,480
always interact with and

00:09:08,160 --> 00:09:11,279
you as the user on the left you simply

00:09:10,480 --> 00:09:13,120
declare

00:09:11,279 --> 00:09:15,040
what you want your world to look like

00:09:13,120 --> 00:09:18,959
and give that to the api server

00:09:15,040 --> 00:09:22,399
and the api server then persists that

00:09:18,959 --> 00:09:24,480
into lcd and at cd here it's

00:09:22,399 --> 00:09:26,320
a storage technology for for all intents

00:09:24,480 --> 00:09:27,839
and purposes um could also be a

00:09:26,320 --> 00:09:29,200
relational database so pretty much

00:09:27,839 --> 00:09:31,920
anything else

00:09:29,200 --> 00:09:33,120
um it is something with specialized for

00:09:31,920 --> 00:09:36,080
kubernetes but

00:09:33,120 --> 00:09:36,720
it is more of an implementation detail

00:09:36,080 --> 00:09:38,320
that

00:09:36,720 --> 00:09:41,200
we don't really need to talk about too

00:09:38,320 --> 00:09:43,360
much and what the api server then does

00:09:41,200 --> 00:09:45,839
is it informs everybody who's interested

00:09:43,360 --> 00:09:47,120
about what just changed

00:09:45,839 --> 00:09:48,959
and it doesn't really tell them what

00:09:47,120 --> 00:09:51,040
exactly changed it just tells them what

00:09:48,959 --> 00:09:53,279
the new state is so the cluster is now

00:09:51,040 --> 00:09:55,279
i don't know if if i change my cluster

00:09:53,279 --> 00:09:57,120
from three to five nodes it would simply

00:09:55,279 --> 00:09:59,760
tell everybody who's interested

00:09:57,120 --> 00:10:00,800
this cluster now should have five nodes

00:09:59,760 --> 00:10:03,440
but it won't tell them

00:10:00,800 --> 00:10:05,040
that it used to have three nodes so the

00:10:03,440 --> 00:10:07,120
the sort of general principle in

00:10:05,040 --> 00:10:09,600
kubernetes is always that you shouldn't

00:10:07,120 --> 00:10:10,560
know what has changed you should only

00:10:09,600 --> 00:10:13,040
need to know

00:10:10,560 --> 00:10:15,120
how does it look like now and that's the

00:10:13,040 --> 00:10:17,360
only input that your

00:10:15,120 --> 00:10:19,200
basically control plane should need and

00:10:17,360 --> 00:10:21,360
what the control plane then does is it

00:10:19,200 --> 00:10:22,399
triggers a so called reconciliation

00:10:21,360 --> 00:10:25,360
which means it

00:10:22,399 --> 00:10:26,800
tries to reconcile what is with what

00:10:25,360 --> 00:10:29,120
should be

00:10:26,800 --> 00:10:30,560
and then that reconciliation probably

00:10:29,120 --> 00:10:32,000
triggers stuff that gets written back to

00:10:30,560 --> 00:10:33,440
the api server again which gets

00:10:32,000 --> 00:10:34,959
persisted in hcd and

00:10:33,440 --> 00:10:36,480
then it just goes back and forth for a

00:10:34,959 --> 00:10:38,480
while probably because

00:10:36,480 --> 00:10:39,760
those changes will be node will notify

00:10:38,480 --> 00:10:42,000
the control plane again and

00:10:39,760 --> 00:10:43,920
that'll trigger changes again and so

00:10:42,000 --> 00:10:46,000
that reconciliation can

00:10:43,920 --> 00:10:48,560
happen quite a few times until it's

00:10:46,000 --> 00:10:48,560
actually done

00:10:49,440 --> 00:10:54,160
and at some point in time something will

00:10:52,480 --> 00:10:56,000
fall out of that that actually needs

00:10:54,160 --> 00:10:57,920
executing to make something happen and

00:10:56,000 --> 00:11:00,720
that will usually be a pot that is

00:10:57,920 --> 00:11:02,720
assigned to a cubelet and the cubelets

00:11:00,720 --> 00:11:04,480
then are the the decentralized

00:11:02,720 --> 00:11:06,640
things that run on servers to actually

00:11:04,480 --> 00:11:10,000
execute your workload

00:11:06,640 --> 00:11:11,760
in a container and

00:11:10,000 --> 00:11:13,279
i know everybody who knows anything

00:11:11,760 --> 00:11:15,120
about kubernetes will probably

00:11:13,279 --> 00:11:17,680
be aghast at this slide and and how

00:11:15,120 --> 00:11:20,079
simple this makes it look but um

00:11:17,680 --> 00:11:21,120
drilling going going very very very far

00:11:20,079 --> 00:11:22,640
back this is

00:11:21,120 --> 00:11:26,399
at least to me the the underlying

00:11:22,640 --> 00:11:26,399
principle of what kubernetes is about

00:11:26,560 --> 00:11:30,560
so after having taken a look at

00:11:28,240 --> 00:11:34,240
kubernetes of course we needed to define

00:11:30,560 --> 00:11:37,440
our relationship with kubernetes so um

00:11:34,240 --> 00:11:39,920
our first sort of um

00:11:37,440 --> 00:11:42,160
goal or mission that we came up with and

00:11:39,920 --> 00:11:44,560
we pitched this to the customers that

00:11:42,160 --> 00:11:46,160
last mentioned in the workshop was all

00:11:44,560 --> 00:11:47,920
right we'll just write a couple of

00:11:46,160 --> 00:11:51,040
operators to roll out these

00:11:47,920 --> 00:11:53,920
10 12 15 20 how many ever

00:11:51,040 --> 00:11:55,360
there are these big data products deploy

00:11:53,920 --> 00:11:56,880
them to an existing kubernetes cluster

00:11:55,360 --> 00:11:58,480
and then everybody can be happy

00:11:56,880 --> 00:12:00,480
because we add the least amount of

00:11:58,480 --> 00:12:02,560
effort because kubernetes takes a lot of

00:12:00,480 --> 00:12:05,440
a lot of work off our hands

00:12:02,560 --> 00:12:07,760
and you have your data big data tools

00:12:05,440 --> 00:12:10,160
running in a kubernetes cluster

00:12:07,760 --> 00:12:12,079
but most of our customers actually were

00:12:10,160 --> 00:12:15,279
not too keen on that

00:12:12,079 --> 00:12:17,360
because um and a lot of

00:12:15,279 --> 00:12:18,480
what i'm now saying might be prejud

00:12:17,360 --> 00:12:20,079
prejudice but that's

00:12:18,480 --> 00:12:22,480
as you really is probably a little bit

00:12:20,079 --> 00:12:25,120
of a kernel of a truth in there as well

00:12:22,480 --> 00:12:25,600
kubernetes is a fairly complex piece of

00:12:25,120 --> 00:12:27,680
software

00:12:25,600 --> 00:12:28,639
deploying kubernetes there's a reason

00:12:27,680 --> 00:12:30,079
why there's many kubernetes

00:12:28,639 --> 00:12:33,279
distributions and no one

00:12:30,079 --> 00:12:36,639
deploys it by hand anymore so

00:12:33,279 --> 00:12:37,360
it's got a lot of moving parts and and

00:12:36,639 --> 00:12:39,279
things that

00:12:37,360 --> 00:12:40,959
have grown over time have changed over

00:12:39,279 --> 00:12:42,959
time even people who work

00:12:40,959 --> 00:12:45,839
with the community and have been around

00:12:42,959 --> 00:12:48,880
from the start still say

00:12:45,839 --> 00:12:49,839
it's tough to keep up and on top of that

00:12:48,880 --> 00:12:52,959
kubernetes always

00:12:49,839 --> 00:12:54,240
also always has the sort of people

00:12:52,959 --> 00:12:56,240
always think that um

00:12:54,240 --> 00:12:58,079
it costs performance and some of our

00:12:56,240 --> 00:13:00,720
customers actually run a few tests and

00:12:58,079 --> 00:13:02,560
in their scenario the overlay network

00:13:00,720 --> 00:13:04,880
actually cost them lots of performance

00:13:02,560 --> 00:13:08,320
it might have improved since then but

00:13:04,880 --> 00:13:10,639
results like that stick with you i think

00:13:08,320 --> 00:13:12,320
so our solution to that was well we'll

00:13:10,639 --> 00:13:14,160
just use parts of kubernetes we'll use

00:13:12,320 --> 00:13:16,000
the control plane which gives us the

00:13:14,160 --> 00:13:17,360
back end that we need to orchestrate all

00:13:16,000 --> 00:13:19,600
our stuff

00:13:17,360 --> 00:13:21,279
but to run the workloads maybe we can

00:13:19,600 --> 00:13:24,560
simplify that a little bit

00:13:21,279 --> 00:13:26,399
and not use containers because again

00:13:24,560 --> 00:13:30,399
containers out of the equation

00:13:26,399 --> 00:13:33,680
makes the the performance problem

00:13:30,399 --> 00:13:34,079
if i want to call it that go away and it

00:13:33,680 --> 00:13:36,959
also

00:13:34,079 --> 00:13:37,839
allows you to to reuse your existing ops

00:13:36,959 --> 00:13:39,760
know-how because

00:13:37,839 --> 00:13:40,959
you can actually ssh into the machine

00:13:39,760 --> 00:13:43,440
you can log it uh

00:13:40,959 --> 00:13:45,199
you can tailor log file you can use vi

00:13:43,440 --> 00:13:47,920
to inspect the config file

00:13:45,199 --> 00:13:49,440
stuff like that so it's um it gives you

00:13:47,920 --> 00:13:50,800
everything that your ops people might be

00:13:49,440 --> 00:13:52,959
used to

00:13:50,800 --> 00:13:54,480
but on the other hand it also gives you

00:13:52,959 --> 00:13:55,600
the option to use existing kubernetes

00:13:54,480 --> 00:13:57,680
tools and know-how because

00:13:55,600 --> 00:13:59,040
kubernetes does give you in theory the

00:13:57,680 --> 00:14:01,839
chance to orchestrate

00:13:59,040 --> 00:14:02,320
and and control and manage your entire

00:14:01,839 --> 00:14:04,160
stack

00:14:02,320 --> 00:14:05,519
from one place which is the kubernetes

00:14:04,160 --> 00:14:07,920
api server

00:14:05,519 --> 00:14:08,959
and by sticking very close to kubernetes

00:14:07,920 --> 00:14:11,040
standards

00:14:08,959 --> 00:14:12,079
we make that possible to with with our

00:14:11,040 --> 00:14:13,839
tools as well

00:14:12,079 --> 00:14:15,279
and we'll actually have a demo later on

00:14:13,839 --> 00:14:18,320
where i'll show how we deploy

00:14:15,279 --> 00:14:19,600
our workloads on bare metal and i do

00:14:18,320 --> 00:14:21,760
realize that bare metal is

00:14:19,600 --> 00:14:22,800
probably a bit of a loaded term in this

00:14:21,760 --> 00:14:24,639
in this context but

00:14:22,800 --> 00:14:26,880
we've somehow somehow grown used to it

00:14:24,639 --> 00:14:29,360
so we keep using it

00:14:26,880 --> 00:14:31,199
um and looking a bit into the future

00:14:29,360 --> 00:14:32,480
what this also makes possible is hybrid

00:14:31,199 --> 00:14:34,639
architectures because for

00:14:32,480 --> 00:14:36,560
for some of our tools for example if we

00:14:34,639 --> 00:14:38,639
take hdfs as an example

00:14:36,560 --> 00:14:40,639
htfs runs two types of nodes it runs

00:14:38,639 --> 00:14:42,800
data nodes and it runs name nodes

00:14:40,639 --> 00:14:45,440
and data nodes are very very state-heavy

00:14:42,800 --> 00:14:47,360
they have terabytes of data

00:14:45,440 --> 00:14:48,480
that they that they manage ideally

00:14:47,360 --> 00:14:51,120
locally

00:14:48,480 --> 00:14:52,720
and if one of these data knows fails you

00:14:51,120 --> 00:14:53,360
wouldn't really want kubernetes to spin

00:14:52,720 --> 00:14:54,959
that up

00:14:53,360 --> 00:14:56,399
three machines over in a different data

00:14:54,959 --> 00:14:58,079
center on a different rack and then

00:14:56,399 --> 00:15:01,839
having to move all that data over there

00:14:58,079 --> 00:15:03,519
as well plus hdfs has redundancy built

00:15:01,839 --> 00:15:05,519
in so if that node fails

00:15:03,519 --> 00:15:07,519
it doesn't really matter because htfs

00:15:05,519 --> 00:15:08,320
has been built to accommodate that and

00:15:07,519 --> 00:15:10,880
simply

00:15:08,320 --> 00:15:12,000
keeps trucking along the name nodes in

00:15:10,880 --> 00:15:13,519
https on the other hand those

00:15:12,000 --> 00:15:15,920
don't have too much state they simply

00:15:13,519 --> 00:15:17,760
have metadata in memory that says well

00:15:15,920 --> 00:15:19,120
that file's there that file's there he's

00:15:17,760 --> 00:15:22,079
in charge of that

00:15:19,120 --> 00:15:23,519
if those die it they very much make

00:15:22,079 --> 00:15:24,639
sense to spin them up somewhere else

00:15:23,519 --> 00:15:28,480
because they can recover

00:15:24,639 --> 00:15:31,440
their state fairly easily and

00:15:28,480 --> 00:15:33,040
so that's having these hybrid

00:15:31,440 --> 00:15:36,240
architecture sort of allows

00:15:33,040 --> 00:15:39,040
us to do kubernetes where it makes sense

00:15:36,240 --> 00:15:40,880
just not everywhere and that's a very

00:15:39,040 --> 00:15:42,240
good thing

00:15:40,880 --> 00:15:44,079
so if you come back to the picture that

00:15:42,240 --> 00:15:45,440
i showed earlier from the kubernetes

00:15:44,079 --> 00:15:47,839
from orbit i think it was called

00:15:45,440 --> 00:15:48,880
from outer space um where do we fit in

00:15:47,839 --> 00:15:50,639
here

00:15:48,880 --> 00:15:52,480
so this is the unchanged picture what we

00:15:50,639 --> 00:15:54,240
did was we wrote a couple of operators

00:15:52,480 --> 00:15:58,320
which should hopefully now be uh

00:15:54,240 --> 00:15:58,959
exactly um up top it was the sort of

00:15:58,320 --> 00:16:00,720
unchanged

00:15:58,959 --> 00:16:02,000
original idea we just write a couple of

00:16:00,720 --> 00:16:03,920
operators that

00:16:02,000 --> 00:16:05,519
write stuff out to kubernetes and manage

00:16:03,920 --> 00:16:07,199
these tools and

00:16:05,519 --> 00:16:09,279
i'll leave those to last you'll say lots

00:16:07,199 --> 00:16:12,560
about them later on

00:16:09,279 --> 00:16:14,639
but what we also did was we wrote a

00:16:12,560 --> 00:16:16,079
a replacement for the kubernetes cubelet

00:16:14,639 --> 00:16:17,360
which is called the stackable agent at

00:16:16,079 --> 00:16:19,440
the moment

00:16:17,360 --> 00:16:21,360
we suck at naming things if anybody has

00:16:19,440 --> 00:16:22,560
a good idea what this should be called

00:16:21,360 --> 00:16:24,240
based on what it does

00:16:22,560 --> 00:16:25,600
and you'll learn what it does in the

00:16:24,240 --> 00:16:27,759
next five minutes

00:16:25,600 --> 00:16:30,639
please let us know because we we can't

00:16:27,759 --> 00:16:32,880
come up with anything better

00:16:30,639 --> 00:16:36,079
and what the stackable agent does is it

00:16:32,880 --> 00:16:37,600
gets pots assigned just like the cubelet

00:16:36,079 --> 00:16:39,759
but then it goes and downloads not a

00:16:37,600 --> 00:16:42,000
container image but actually a taji zip

00:16:39,759 --> 00:16:44,320
file which currently is the the

00:16:42,000 --> 00:16:46,240
official apache convenience binaries

00:16:44,320 --> 00:16:48,720
that are released

00:16:46,240 --> 00:16:49,920
and downloads those extracts them and

00:16:48,720 --> 00:16:53,279
then it creates a systemd

00:16:49,920 --> 00:16:54,880
service that runs off those binaries and

00:16:53,279 --> 00:16:56,560
with config files that it actually

00:16:54,880 --> 00:16:57,759
creates on disk so

00:16:56,560 --> 00:16:59,600
if you want to have a look at how your

00:16:57,759 --> 00:17:01,279
server is doing you can actually ssh

00:16:59,600 --> 00:17:02,720
into the machine look at a config file

00:17:01,279 --> 00:17:04,720
the one that is actually running

00:17:02,720 --> 00:17:06,240
currently not one that's

00:17:04,720 --> 00:17:08,079
hidden away in a container somewhere and

00:17:06,240 --> 00:17:10,079
you need to understand the init script

00:17:08,079 --> 00:17:13,919
that created it

00:17:10,079 --> 00:17:17,039
and also have a look at the logs

00:17:13,919 --> 00:17:18,160
so that sort of gives you both both

00:17:17,039 --> 00:17:21,760
worlds

00:17:18,160 --> 00:17:21,760
in the same at the same time

00:17:22,400 --> 00:17:26,400
and then if we move on

00:17:26,799 --> 00:17:30,720
um of course that you could say that

00:17:29,039 --> 00:17:32,400
this is the worst of both worlds

00:17:30,720 --> 00:17:33,679
we have the complexity of kubernetes but

00:17:32,400 --> 00:17:35,760
we don't have the flexibility of

00:17:33,679 --> 00:17:38,799
containers

00:17:35,760 --> 00:17:42,720
and to that i would say yes and no

00:17:38,799 --> 00:17:44,480
because kubernetes as i said

00:17:42,720 --> 00:17:46,240
if you take a look at the very core of

00:17:44,480 --> 00:17:50,160
it it's a very simple thing

00:17:46,240 --> 00:17:52,559
the api server is pretty much boils down

00:17:50,160 --> 00:17:54,960
to a rest web service that stores data

00:17:52,559 --> 00:17:57,120
and informs you if it changes that's

00:17:54,960 --> 00:17:58,720
that's not a terribly complex thing

00:17:57,120 --> 00:18:00,320
the complexity comes when you take a

00:17:58,720 --> 00:18:01,840
look at the control plane which has tens

00:18:00,320 --> 00:18:02,960
or even hundreds of controllers or

00:18:01,840 --> 00:18:06,320
operators

00:18:02,960 --> 00:18:09,360
and has this this complex web

00:18:06,320 --> 00:18:09,679
of objects that are dependent on each

00:18:09,360 --> 00:18:12,000
other

00:18:09,679 --> 00:18:13,600
trigger changes everywhere else but if

00:18:12,000 --> 00:18:16,799
you if you take that away

00:18:13,600 --> 00:18:18,240
the very core is pretty simply very very

00:18:16,799 --> 00:18:20,720
simple data model

00:18:18,240 --> 00:18:22,880
so what we said is that we explicitly

00:18:20,720 --> 00:18:24,080
limit ourselves to a very very small

00:18:22,880 --> 00:18:26,000
subset of the

00:18:24,080 --> 00:18:28,160
of the data model of kubernetes so we're

00:18:26,000 --> 00:18:29,840
using a port because that's

00:18:28,160 --> 00:18:32,080
pretty much no way getting around the

00:18:29,840 --> 00:18:33,280
port we're using a node because that's

00:18:32,080 --> 00:18:36,080
what you need to register

00:18:33,280 --> 00:18:37,440
so the agent registered itself as a node

00:18:36,080 --> 00:18:37,840
we're using a couple of config maps

00:18:37,440 --> 00:18:39,360
because

00:18:37,840 --> 00:18:41,039
that's where we generate config files

00:18:39,360 --> 00:18:43,679
from and secrets

00:18:41,039 --> 00:18:44,400
um but all of those are fairly fairly

00:18:43,679 --> 00:18:45,600
simple and

00:18:44,400 --> 00:18:47,120
low level abstraction so we're

00:18:45,600 --> 00:18:49,280
explicitly not using things like

00:18:47,120 --> 00:18:51,200
deployments or stateful sets or demon

00:18:49,280 --> 00:18:52,880
sets or things like that because

00:18:51,200 --> 00:18:56,240
that's that's where complexity starts

00:18:52,880 --> 00:18:58,240
creeping in

00:18:56,240 --> 00:18:59,520
um and we actually spoke to a team that

00:18:58,240 --> 00:19:02,160
develops uh an

00:18:59,520 --> 00:19:03,760
uh well-known operator and they said yes

00:19:02,160 --> 00:19:04,640
we are using deployments in stateful

00:19:03,760 --> 00:19:06,400
sets and

00:19:04,640 --> 00:19:07,679
we wish we hadn't taken that decision

00:19:06,400 --> 00:19:10,160
early on because

00:19:07,679 --> 00:19:11,919
what that does is it gives you quick

00:19:10,160 --> 00:19:14,960
benefits

00:19:11,919 --> 00:19:16,799
but once you move past that

00:19:14,960 --> 00:19:19,120
and you become you start looking at more

00:19:16,799 --> 00:19:22,160
complex workflows then it

00:19:19,120 --> 00:19:22,880
also puts you into the core set of doing

00:19:22,160 --> 00:19:24,640
stuff

00:19:22,880 --> 00:19:26,559
exactly the way that kubernetes wants

00:19:24,640 --> 00:19:30,559
you to do stuff

00:19:26,559 --> 00:19:32,559
and sometimes it can actually be very

00:19:30,559 --> 00:19:34,320
yeah it can be good to not use them

00:19:32,559 --> 00:19:34,720
because it gives you more freedom to do

00:19:34,320 --> 00:19:38,960
things

00:19:34,720 --> 00:19:40,960
exactly the way that you want to do them

00:19:38,960 --> 00:19:42,799
taking this even even a step further we

00:19:40,960 --> 00:19:45,520
could actually use something like

00:19:42,799 --> 00:19:47,679
kcp which is i think it's called the

00:19:45,520 --> 00:19:49,840
minimal kubernetes rp server

00:19:47,679 --> 00:19:51,520
it speaks the same api as the kubernetes

00:19:49,840 --> 00:19:53,600
api server but it doesn't know any of

00:19:51,520 --> 00:19:55,120
the objects that the the kubernetes api

00:19:53,600 --> 00:19:56,720
server knows so it doesn't know about a

00:19:55,120 --> 00:19:58,480
part it doesn't know about nodes

00:19:56,720 --> 00:20:00,320
you'd need to create all of those as

00:19:58,480 --> 00:20:01,840
custom resources and that that would

00:20:00,320 --> 00:20:04,080
actually allow you to

00:20:01,840 --> 00:20:05,440
really really stay very minimal in what

00:20:04,080 --> 00:20:09,520
you do

00:20:05,440 --> 00:20:10,880
and kubernetes itself is actually

00:20:09,520 --> 00:20:12,720
thinking about i'm not sure if they're

00:20:10,880 --> 00:20:14,159
actually actually considering moving

00:20:12,720 --> 00:20:16,000
into that direction but there's been

00:20:14,159 --> 00:20:18,400
talk about

00:20:16,000 --> 00:20:20,400
if they'd be doing it again they would

00:20:18,400 --> 00:20:22,559
implement everything as a cid

00:20:20,400 --> 00:20:23,760
pretty much namespaces and then maybe

00:20:22,559 --> 00:20:25,919
labels would be

00:20:23,760 --> 00:20:28,240
built in objects but the the tendency

00:20:25,919 --> 00:20:30,640
towards simply doing everything as a cid

00:20:28,240 --> 00:20:32,000
and not having anything pre-built and

00:20:30,640 --> 00:20:33,760
treated in a special way

00:20:32,000 --> 00:20:35,760
as something that kubernetes the

00:20:33,760 --> 00:20:37,200
kubernetes community is talking about as

00:20:35,760 --> 00:20:39,039
well

00:20:37,200 --> 00:20:41,200
and by doing that and limiting us to

00:20:39,039 --> 00:20:42,080
this this very very small subset of

00:20:41,200 --> 00:20:43,760
things

00:20:42,080 --> 00:20:46,159
and doing a lot of things ourselves

00:20:43,760 --> 00:20:47,440
which yes that created a bit of overhead

00:20:46,159 --> 00:20:51,200
in the beginning

00:20:47,440 --> 00:20:52,000
but it also gives us lots of freedom to

00:20:51,200 --> 00:20:54,080
implement things

00:20:52,000 --> 00:20:55,200
exactly the way we want them in our

00:20:54,080 --> 00:20:56,960
operators

00:20:55,200 --> 00:20:58,559
and for those operators i'll hand back

00:20:56,960 --> 00:21:00,640
over to lars and he'll give you a brief

00:20:58,559 --> 00:21:03,919
overview of what we are doing there

00:21:00,640 --> 00:21:05,679
yep thank you sir um

00:21:03,919 --> 00:21:07,120
yeah so what we do at stakeholders you

00:21:05,679 --> 00:21:09,280
can mention this we basically write a

00:21:07,120 --> 00:21:10,799
whole bunch of operators and as

00:21:09,280 --> 00:21:12,720
also mentioned these operators are

00:21:10,799 --> 00:21:14,640
basically pieces of software that

00:21:12,720 --> 00:21:18,000
control other pieces of software

00:21:14,640 --> 00:21:18,480
so um that's this is what it looks like

00:21:18,000 --> 00:21:21,679
at the

00:21:18,480 --> 00:21:23,440
pseudocode level um

00:21:21,679 --> 00:21:25,200
but because what we're doing is

00:21:23,440 --> 00:21:28,559
basically a we extract the

00:21:25,200 --> 00:21:30,720
the knowledge that that you like this

00:21:28,559 --> 00:21:31,919
admins ops people devops people human

00:21:30,720 --> 00:21:33,520
operators have

00:21:31,919 --> 00:21:35,039
and we try to extract all of that

00:21:33,520 --> 00:21:38,400
knowledge into into

00:21:35,039 --> 00:21:40,000
one piece of software and this piece of

00:21:38,400 --> 00:21:41,440
software is then responsible for

00:21:40,000 --> 00:21:43,760
managing a single thing

00:21:41,440 --> 00:21:45,760
like we have a kafka operator we have a

00:21:43,760 --> 00:21:47,039
kafka topic operator we have a kafka

00:21:45,760 --> 00:21:49,200
whatever operator

00:21:47,039 --> 00:21:50,159
so all of these extract extract the

00:21:49,200 --> 00:21:51,840
knowledge

00:21:50,159 --> 00:21:54,880
from humans so you don't need to do

00:21:51,840 --> 00:21:58,240
these repetitive tasks over and over

00:21:54,880 --> 00:22:00,480
so an operator

00:21:58,240 --> 00:22:02,000
basically as zinc also explained already

00:22:00,480 --> 00:22:04,080
watches the resource so we've got a

00:22:02,000 --> 00:22:06,880
kafka operator and that watches the api

00:22:04,080 --> 00:22:08,480
server for kafka cluster objects

00:22:06,880 --> 00:22:10,320
that you as an end user store on the

00:22:08,480 --> 00:22:12,559
system and then the operator takes over

00:22:10,320 --> 00:22:14,400
and it updates and or creates like parts

00:22:12,559 --> 00:22:16,400
config maps and so on so

00:22:14,400 --> 00:22:17,919
what it does it translates these high

00:22:16,400 --> 00:22:20,480
level concepts like in

00:22:17,919 --> 00:22:22,159
cluster into parts conflict maps

00:22:20,480 --> 00:22:24,240
whatever

00:22:22,159 --> 00:22:25,760
so when we started on this journey we

00:22:24,240 --> 00:22:26,000
wanted to know like how do other people

00:22:25,760 --> 00:22:27,440
do

00:22:26,000 --> 00:22:28,799
this like what are best practices and

00:22:27,440 --> 00:22:30,080
there are some blog posts out there

00:22:28,799 --> 00:22:31,760
there's some documentation

00:22:30,080 --> 00:22:33,200
google has a best practice page the red

00:22:31,760 --> 00:22:35,200
hat has one

00:22:33,200 --> 00:22:36,640
and this talk is a bit too short to go

00:22:35,200 --> 00:22:38,320
into all the details

00:22:36,640 --> 00:22:40,000
and you'll find them out there and what

00:22:38,320 --> 00:22:42,480
we found is that in in

00:22:40,000 --> 00:22:43,039
reality in our experience they all of

00:22:42,480 --> 00:22:45,760
these

00:22:43,039 --> 00:22:46,880
guides fall a bit short like they stop

00:22:45,760 --> 00:22:49,760
where it gets interesting

00:22:46,880 --> 00:22:51,360
most of the time and so what we found is

00:22:49,760 --> 00:22:53,440
that most people

00:22:51,360 --> 00:22:55,120
write a single operator or maybe maybe

00:22:53,440 --> 00:22:56,240
two like for one or two projects and and

00:22:55,120 --> 00:22:59,919
that's it so there's

00:22:56,240 --> 00:23:03,520
very little uh there's little code reuse

00:22:59,919 --> 00:23:05,520
there is some but not not a lot and um

00:23:03,520 --> 00:23:06,559
our problem is that we have to run away

00:23:05,520 --> 00:23:08,159
problem we like it

00:23:06,559 --> 00:23:10,159
but our problem is that we have to write

00:23:08,159 --> 00:23:12,559
dozens of operators and they

00:23:10,159 --> 00:23:13,679
should all be and feel consistent to the

00:23:12,559 --> 00:23:15,520
end user

00:23:13,679 --> 00:23:16,960
so what we found when looking at

00:23:15,520 --> 00:23:19,280
existing operators

00:23:16,960 --> 00:23:20,240
is that all of them do things slightly

00:23:19,280 --> 00:23:22,880
slightly

00:23:20,240 --> 00:23:23,600
slightly different so all of these

00:23:22,880 --> 00:23:25,520
operators

00:23:23,600 --> 00:23:27,520
uh consist of a reconcile loop and i'll

00:23:25,520 --> 00:23:28,480
go into that in the next and the next

00:23:27,520 --> 00:23:32,000
slide

00:23:28,480 --> 00:23:34,480
and then and what we like to do and what

00:23:32,000 --> 00:23:36,880
doesn't happen in in the

00:23:34,480 --> 00:23:38,080
broader ecosystem is we want to have

00:23:36,880 --> 00:23:39,440
common labels for everything so

00:23:38,080 --> 00:23:41,679
everything should be common

00:23:39,440 --> 00:23:42,720
have have common labels for pots objects

00:23:41,679 --> 00:23:46,159
and whatever

00:23:42,720 --> 00:23:47,679
we want of common nomenclature that like

00:23:46,159 --> 00:23:50,720
a role or conflict over there it's

00:23:47,679 --> 00:23:53,679
called the same in all our operators

00:23:50,720 --> 00:23:54,240
common status and events they should

00:23:53,679 --> 00:23:56,240
they should

00:23:54,240 --> 00:23:58,559
feel similar because they will plug into

00:23:56,240 --> 00:24:01,200
your into your monitoring

00:23:58,559 --> 00:24:03,200
the configuration and the cids should

00:24:01,200 --> 00:24:05,120
feel the same they should feel similar

00:24:03,200 --> 00:24:06,960
monitoring tracing metrics all of that

00:24:05,120 --> 00:24:08,960
stuff should be the same so it

00:24:06,960 --> 00:24:10,640
whether you manage a knife cluster or

00:24:08,960 --> 00:24:11,440
kafka cluster that shouldn't really

00:24:10,640 --> 00:24:13,279
matter

00:24:11,440 --> 00:24:15,760
um these things should have the same

00:24:13,279 --> 00:24:18,799
names and so on

00:24:15,760 --> 00:24:20,559
so basically common stuff like

00:24:18,799 --> 00:24:22,080
across the operators makes it easier and

00:24:20,559 --> 00:24:23,279
less surprising for the humans using

00:24:22,080 --> 00:24:26,320
this system and as

00:24:23,279 --> 00:24:28,480
also mentioned we also have common hacks

00:24:26,320 --> 00:24:30,320
because what we found is yes declarative

00:24:28,480 --> 00:24:32,960
is nice but

00:24:30,320 --> 00:24:34,799
in reality sometimes you do just need to

00:24:32,960 --> 00:24:35,360
restart this one stupid server over

00:24:34,799 --> 00:24:37,520
there

00:24:35,360 --> 00:24:39,200
and kubernetes makes that pretty hard

00:24:37,520 --> 00:24:39,919
and we there's other people out there

00:24:39,200 --> 00:24:42,159
who've uh

00:24:39,919 --> 00:24:43,360
invented workarounds for like please

00:24:42,159 --> 00:24:46,480
start their postgres

00:24:43,360 --> 00:24:47,440
backup uh i like this is a this is like

00:24:46,480 --> 00:24:49,200
a command

00:24:47,440 --> 00:24:50,559
that's hard to do in a declarative way

00:24:49,200 --> 00:24:53,200
or like a restart

00:24:50,559 --> 00:24:55,120
like the declarative this would i mean

00:24:53,200 --> 00:24:57,279
my goal state is started

00:24:55,120 --> 00:24:58,559
uh but just from started to start it i

00:24:57,279 --> 00:25:00,480
want to restart

00:24:58,559 --> 00:25:02,400
and so we we we worked around these

00:25:00,480 --> 00:25:04,080
things and our distribution should feel

00:25:02,400 --> 00:25:05,679
consistent so we decided to write our

00:25:04,080 --> 00:25:09,200
own framework around these things

00:25:05,679 --> 00:25:11,520
um okay the reconcile loop this is

00:25:09,200 --> 00:25:12,960
uh something i looked at over 20

00:25:11,520 --> 00:25:14,480
different operators in in three

00:25:12,960 --> 00:25:15,919
different programming languages and i

00:25:14,480 --> 00:25:17,600
found that there are two

00:25:15,919 --> 00:25:18,960
alternative styles to write this record

00:25:17,600 --> 00:25:21,279
side loop one is the

00:25:18,960 --> 00:25:22,640
one on the right with huge steps like

00:25:21,279 --> 00:25:24,320
the reconcile is called

00:25:22,640 --> 00:25:26,559
something changed my kafka cluster

00:25:24,320 --> 00:25:28,240
object changed now i'm going to do

00:25:26,559 --> 00:25:29,679
whatever work i need to do reconcile

00:25:28,240 --> 00:25:32,320
part one and i

00:25:29,679 --> 00:25:34,159
wait until it's uh stored and up and

00:25:32,320 --> 00:25:35,440
running then reconcile part two wait

00:25:34,159 --> 00:25:38,240
until it's up and running

00:25:35,440 --> 00:25:39,279
this is good um and it means that at the

00:25:38,240 --> 00:25:43,600
end of this loop

00:25:39,279 --> 00:25:46,080
i basically have um i don't know exactly

00:25:43,600 --> 00:25:47,279
what the state is like that the my

00:25:46,080 --> 00:25:50,000
target state will be

00:25:47,279 --> 00:25:50,720
the desired state and that's it right

00:25:50,000 --> 00:25:52,960
because

00:25:50,720 --> 00:25:54,000
nothing can interfere i just do start at

00:25:52,960 --> 00:25:56,400
the beginning and and

00:25:54,000 --> 00:25:58,559
end at the end but if you have like a

00:25:56,400 --> 00:26:00,320
300 400 node cluster these things can

00:25:58,559 --> 00:26:00,799
take time like restarts or these kind of

00:26:00,320 --> 00:26:02,720
things so

00:26:00,799 --> 00:26:05,360
this can take half an hour or so to run

00:26:02,720 --> 00:26:07,679
this one reconcile loop

00:26:05,360 --> 00:26:10,000
and if you change the object in between

00:26:07,679 --> 00:26:12,640
we won't notif uh notice because we we

00:26:10,000 --> 00:26:14,640
are not interrupting ourselves anywhere

00:26:12,640 --> 00:26:18,320
so what we can do instead is have this

00:26:14,640 --> 00:26:19,440
left uh the small step um approach where

00:26:18,320 --> 00:26:21,200
we do one thing

00:26:19,440 --> 00:26:22,880
and then check whether something changed

00:26:21,200 --> 00:26:26,240
and we need to re-queue

00:26:22,880 --> 00:26:28,400
this is um what's what what's depicted

00:26:26,240 --> 00:26:29,840
here so we reconcile part one and then

00:26:28,400 --> 00:26:32,640
check has something changed

00:26:29,840 --> 00:26:33,919
if if yes we re-queue which re-queue

00:26:32,640 --> 00:26:36,720
basically means

00:26:33,919 --> 00:26:39,840
read my object from kafka from from

00:26:36,720 --> 00:26:41,600
kubernetes again and then start over

00:26:39,840 --> 00:26:43,760
so if something changes in between we

00:26:41,600 --> 00:26:45,520
can immediately react to changes

00:26:43,760 --> 00:26:47,200
so we decided to go with this small

00:26:45,520 --> 00:26:48,480
steps approach these names are crap and

00:26:47,200 --> 00:26:49,600
we haven't come up with better ones as

00:26:48,480 --> 00:26:51,919
in goods that

00:26:49,600 --> 00:26:53,360
we have a huge naming problem but yeah

00:26:51,919 --> 00:26:55,840
this is a

00:26:53,360 --> 00:26:57,039
a style that we found in in lots of

00:26:55,840 --> 00:26:58,640
operators one one or

00:26:57,039 --> 00:27:00,080
one or the other is used in almost all

00:26:58,640 --> 00:27:02,640
of them

00:27:00,080 --> 00:27:03,679
so what we did is we have written a an

00:27:02,640 --> 00:27:06,240
operator framework

00:27:03,679 --> 00:27:07,760
that's pretty like yes there are some

00:27:06,240 --> 00:27:08,720
generic parts in there but it's pretty

00:27:07,760 --> 00:27:10,960
tight to

00:27:08,720 --> 00:27:12,240
uh to our company and our operators it

00:27:10,960 --> 00:27:15,279
it can be reused

00:27:12,240 --> 00:27:18,480
but yeah we haven't especially

00:27:15,279 --> 00:27:22,000
uh tried to make it reusable

00:27:18,480 --> 00:27:23,919
for people outside but yet um so what

00:27:22,000 --> 00:27:25,360
we added uh like lots of convenience

00:27:23,919 --> 00:27:28,240
functions and structures

00:27:25,360 --> 00:27:29,760
like retrieve all existing parts uh all

00:27:28,240 --> 00:27:31,600
existing parts that match a label

00:27:29,760 --> 00:27:33,120
retrieve and set conditions make sure

00:27:31,600 --> 00:27:35,120
that the conditions transition

00:27:33,120 --> 00:27:37,440
transition to the states that we want

00:27:35,120 --> 00:27:39,120
them remove parts and so on

00:27:37,440 --> 00:27:41,200
and often used higher level abstraction

00:27:39,120 --> 00:27:43,120
things like remove all pots that

00:27:41,200 --> 00:27:44,480
uh like orphaned that we don't need

00:27:43,120 --> 00:27:46,399
anymore find nodes

00:27:44,480 --> 00:27:47,840
that that should have a pot that that

00:27:46,399 --> 00:27:50,799
don't uh

00:27:47,840 --> 00:27:52,080
these kind of things this requires a few

00:27:50,799 --> 00:27:54,399
conventions about

00:27:52,080 --> 00:27:55,679
uh like what our object should look like

00:27:54,399 --> 00:27:57,120
but as i mentioned before this is

00:27:55,679 --> 00:27:59,760
exactly what we want because we want

00:27:57,120 --> 00:28:03,279
consistency across all our operators

00:27:59,760 --> 00:28:05,200
so um if you know how to use kafka

00:28:03,279 --> 00:28:06,559
you will also know how to use the knife

00:28:05,200 --> 00:28:08,480
operator

00:28:06,559 --> 00:28:09,679
so how does it look uh or work in real

00:28:08,480 --> 00:28:12,720
life this

00:28:09,679 --> 00:28:13,440
is uh almost real code like we i just

00:28:12,720 --> 00:28:16,320
removed

00:28:13,440 --> 00:28:17,360
a tiny bit of boilerplate in between but

00:28:16,320 --> 00:28:19,679
basically

00:28:17,360 --> 00:28:20,399
we have these these two things or these

00:28:19,679 --> 00:28:22,720
uh the

00:28:20,399 --> 00:28:23,760
the yeah we can basically change these

00:28:22,720 --> 00:28:25,679
commands

00:28:23,760 --> 00:28:27,200
everything in blue comes from our

00:28:25,679 --> 00:28:28,720
framework for example so we can

00:28:27,200 --> 00:28:30,480
basically

00:28:28,720 --> 00:28:32,240
create our own chain the way that we

00:28:30,480 --> 00:28:33,440
want it red is something you need to

00:28:32,240 --> 00:28:34,720
implement yourself

00:28:33,440 --> 00:28:36,640
at the moment we're working on

00:28:34,720 --> 00:28:38,640
extracting more and more functionality

00:28:36,640 --> 00:28:39,840
but here for example say in its status

00:28:38,640 --> 00:28:42,240
um and then

00:28:39,840 --> 00:28:44,159
please delete all illegal parts that

00:28:42,240 --> 00:28:45,520
don't match the required labels wait for

00:28:44,159 --> 00:28:46,000
terminating ports if there are any pots

00:28:45,520 --> 00:28:48,880
still

00:28:46,000 --> 00:28:50,080
terminating uh please just re-queue and

00:28:48,880 --> 00:28:51,679
we'll we'll wait

00:28:50,080 --> 00:28:53,360
wait for running and ready pots this is

00:28:51,679 --> 00:28:55,360
for things like a rolling restart we

00:28:53,360 --> 00:28:57,520
want in a rolling restart scenario

00:28:55,360 --> 00:28:58,480
we don't want to kick off that i create

00:28:57,520 --> 00:29:00,640
new

00:28:58,480 --> 00:29:01,600
new servers new new parts while there's

00:29:00,640 --> 00:29:04,559
still others

00:29:01,600 --> 00:29:06,799
that are that are restarting and then

00:29:04,559 --> 00:29:09,440
delete access ports

00:29:06,799 --> 00:29:10,399
like you change the uh the specification

00:29:09,440 --> 00:29:12,880
saying

00:29:10,399 --> 00:29:14,559
i don't want any more kafka clusters

00:29:12,880 --> 00:29:17,600
kafka brokers on that rack

00:29:14,559 --> 00:29:18,640
so now they are access delete them and

00:29:17,600 --> 00:29:21,679
so we'll delete them

00:29:18,640 --> 00:29:24,320
and next time we will probably end up in

00:29:21,679 --> 00:29:27,120
the wait for terminated pots

00:29:24,320 --> 00:29:27,679
state again and we q we req until we're

00:29:27,120 --> 00:29:30,960
done

00:29:27,679 --> 00:29:32,480
and this um like we're all the time

00:29:30,960 --> 00:29:34,159
extending this framework basically

00:29:32,480 --> 00:29:35,760
adding more and more methods to this

00:29:34,159 --> 00:29:37,919
framework which allows us to plug and

00:29:35,760 --> 00:29:40,240
play uh mix and match

00:29:37,919 --> 00:29:41,919
these these operators together so we

00:29:40,240 --> 00:29:42,799
only have to implement the core business

00:29:41,919 --> 00:29:44,799
logic

00:29:42,799 --> 00:29:46,559
and don't have to implement all the

00:29:44,799 --> 00:29:48,799
stuff around it

00:29:46,559 --> 00:29:50,640
and we found that uh lacking there's

00:29:48,799 --> 00:29:51,840
some some frameworks out there which do

00:29:50,640 --> 00:29:53,679
parts of it but we haven't found

00:29:51,840 --> 00:29:55,679
anything that that does all of what what

00:29:53,679 --> 00:29:57,440
we need

00:29:55,679 --> 00:29:58,799
and as i also mentioned we're using

00:29:57,440 --> 00:30:00,399
these lower level abstractions like

00:29:58,799 --> 00:30:02,399
parts and deployments and so on that

00:30:00,399 --> 00:30:04,000
makes it a bit harder to use

00:30:02,399 --> 00:30:05,440
but again we are moving lots of these

00:30:04,000 --> 00:30:07,760
things uh into

00:30:05,440 --> 00:30:09,039
into of our framework which gives us the

00:30:07,760 --> 00:30:12,720
full flexibility

00:30:09,039 --> 00:30:15,600
while still being able to uh yeah

00:30:12,720 --> 00:30:17,279
easy to use so i haven't talked about

00:30:15,600 --> 00:30:19,039
any programming languages but

00:30:17,279 --> 00:30:20,559
for for those of you who do know they

00:30:19,039 --> 00:30:21,679
might have recognized that this is not

00:30:20,559 --> 00:30:25,520
go this is actually

00:30:21,679 --> 00:30:26,799
rust so we decided to use rust for all

00:30:25,520 --> 00:30:29,120
our operators

00:30:26,799 --> 00:30:30,720
so that's the second twist basically the

00:30:29,120 --> 00:30:31,360
first is that we're running kubernetes

00:30:30,720 --> 00:30:32,880
and running

00:30:31,360 --> 00:30:34,240
this not with containers but with this

00:30:32,880 --> 00:30:35,760
system d and the second one is we

00:30:34,240 --> 00:30:38,320
decided to use rust for all our

00:30:35,760 --> 00:30:40,640
operators and the agent as well

00:30:38,320 --> 00:30:42,880
so kubernetes and most third-party

00:30:40,640 --> 00:30:46,159
operators are written in go or java

00:30:42,880 --> 00:30:47,600
why did we choose rust well when we

00:30:46,159 --> 00:30:49,279
started this whole thing

00:30:47,600 --> 00:30:50,399
this was very much a community driven

00:30:49,279 --> 00:30:51,440
thing everything that we're doing is

00:30:50,399 --> 00:30:53,120
open source as

00:30:51,440 --> 00:30:55,520
i mentioned we should have put a link up

00:30:53,120 --> 00:30:57,039
somewhere um

00:30:55,520 --> 00:30:59,120
we didn't know either language so we

00:30:57,039 --> 00:31:01,440
didn't know the go we didn't know rust

00:30:59,120 --> 00:31:03,679
our background was java the whole uh

00:31:01,440 --> 00:31:05,760
apache big data ecosystem is java so our

00:31:03,679 --> 00:31:07,279
background was java so we tried both we

00:31:05,760 --> 00:31:09,120
tried both languages

00:31:07,279 --> 00:31:11,360
and we looked at the library ecosystem

00:31:09,120 --> 00:31:13,200
and we like rest and we liked it

00:31:11,360 --> 00:31:14,399
better end of story there's not much

00:31:13,200 --> 00:31:18,159
like there's not no

00:31:14,399 --> 00:31:19,600
hate for for go it's just we like rust

00:31:18,159 --> 00:31:21,519
we like the error handling we like the

00:31:19,600 --> 00:31:22,159
enums we like generics no garbage

00:31:21,519 --> 00:31:24,399
collection

00:31:22,159 --> 00:31:25,760
security if it compiles it'll probably

00:31:24,399 --> 00:31:26,559
work and we're pretty happy with the

00:31:25,760 --> 00:31:28,480
decision

00:31:26,559 --> 00:31:30,320
so some things like go structural typing

00:31:28,480 --> 00:31:31,760
is pretty sweet so it's not like

00:31:30,320 --> 00:31:33,039
yeah we don't we don't hate go it's just

00:31:31,760 --> 00:31:34,880
we decided to go with the rust and we

00:31:33,039 --> 00:31:37,120
are pretty happy with it

00:31:34,880 --> 00:31:38,399
so the rust kubernetes ecosystem there

00:31:37,120 --> 00:31:42,080
there are three

00:31:38,399 --> 00:31:45,200
crates is what we're using uh k8s

00:31:42,080 --> 00:31:46,399
open rps1 and that's if you want to

00:31:45,200 --> 00:31:49,919
build

00:31:46,399 --> 00:31:51,760
if you build things and rest on top of

00:31:49,919 --> 00:31:53,679
a kubernetes this one you'll probably

00:31:51,760 --> 00:31:57,519
use because it generates

00:31:53,679 --> 00:31:59,200
uh rust structs and so on from the open

00:31:57,519 --> 00:32:02,080
rp spec for kubernetes

00:31:59,200 --> 00:32:03,600
which is super useful they feel native

00:32:02,080 --> 00:32:05,440
to rust everything works

00:32:03,600 --> 00:32:06,799
works with generics and so on so this is

00:32:05,440 --> 00:32:08,799
pretty pretty good

00:32:06,799 --> 00:32:10,159
the next one is cube rs and that's

00:32:08,799 --> 00:32:12,640
probably

00:32:10,159 --> 00:32:13,760
the most important one because this

00:32:12,640 --> 00:32:17,039
actually wraps

00:32:13,760 --> 00:32:20,320
the whole k8s open rp stuff and puts a

00:32:17,039 --> 00:32:20,640
client around it like uh this is yeah it

00:32:20,320 --> 00:32:23,840
gives

00:32:20,640 --> 00:32:24,880
gives you a as it says here a more

00:32:23,840 --> 00:32:28,559
generic client

00:32:24,880 --> 00:32:30,320
a go library because yeah generics exist

00:32:28,559 --> 00:32:31,840
in rust i know they do and go as well

00:32:30,320 --> 00:32:33,760
now but um

00:32:31,840 --> 00:32:35,919
it's it's really really easy to write

00:32:33,760 --> 00:32:36,799
generic things using cube rs and it's

00:32:35,919 --> 00:32:39,039
fantastic

00:32:36,799 --> 00:32:41,039
it's being developed all the time the

00:32:39,039 --> 00:32:42,720
community is super responsive every once

00:32:41,039 --> 00:32:44,640
everyone's super nice things that we

00:32:42,720 --> 00:32:45,919
were missing have been added super fast

00:32:44,640 --> 00:32:48,159
so if you want to build something in

00:32:45,919 --> 00:32:51,279
rust on top of kubernetes

00:32:48,159 --> 00:32:53,600
this is the way to go and the last one

00:32:51,279 --> 00:32:54,320
and the last slide for this presentation

00:32:53,600 --> 00:32:56,399
as well

00:32:54,320 --> 00:32:59,039
is something called crosslit and this is

00:32:56,399 --> 00:33:01,840
uh by the folks over at these labs

00:32:59,039 --> 00:33:03,360
which belongs to microsoft um that's

00:33:01,840 --> 00:33:04,960
called crosslit as the name implies it's

00:33:03,360 --> 00:33:07,440
a cubelet written in

00:33:04,960 --> 00:33:08,320
in rust and they initially developed it

00:33:07,440 --> 00:33:12,000
to run

00:33:08,320 --> 00:33:14,159
web assembly stuff so you can basically

00:33:12,000 --> 00:33:15,200
run webassembly stuff by assigning it

00:33:14,159 --> 00:33:17,200
pots as well

00:33:15,200 --> 00:33:18,720
but it is generic so it doesn't it

00:33:17,200 --> 00:33:20,000
doesn't matter you can plug

00:33:18,720 --> 00:33:21,760
plug in a different backend so we

00:33:20,000 --> 00:33:22,480
plugged in this our systemd backend and

00:33:21,760 --> 00:33:25,200
that works

00:33:22,480 --> 00:33:27,440
perfectly fine they actually as it says

00:33:25,200 --> 00:33:29,200
here crosstalk 1.0 is coming soon

00:33:27,440 --> 00:33:31,840
they actually i think in the process of

00:33:29,200 --> 00:33:33,200
donating this whole thing to the cncf um

00:33:31,840 --> 00:33:35,840
so this will become a more or less

00:33:33,200 --> 00:33:37,519
official project hopefully soon

00:33:35,840 --> 00:33:39,200
but i can't make any promises i don't

00:33:37,519 --> 00:33:41,679
know yeah so this is

00:33:39,200 --> 00:33:42,640
the quick summary um of what we're doing

00:33:41,679 --> 00:33:45,360
so we're doing a bit

00:33:42,640 --> 00:33:46,960
a few things uh special but we are super

00:33:45,360 --> 00:33:49,840
happy with the choices we made it's

00:33:46,960 --> 00:33:51,840
it's fun we learned a lot um rust and

00:33:49,840 --> 00:33:52,799
kubernetes have been treating us well

00:33:51,840 --> 00:33:54,559
and with that

00:33:52,799 --> 00:33:56,399
i'll be handing over to zinke because i

00:33:54,559 --> 00:33:58,320
think we're a bit short on time but yeah

00:33:56,399 --> 00:34:00,799
okay please take it away

00:33:58,320 --> 00:34:02,960
yeah that works i can stretch or shorten

00:34:00,799 --> 00:34:05,360
the demo as necessary

00:34:02,960 --> 00:34:06,720
so um what you're looking at here is

00:34:05,360 --> 00:34:08,320
pretty much just to set this up

00:34:06,720 --> 00:34:10,720
this is our infrastructure that we'll be

00:34:08,320 --> 00:34:12,159
using to deploy things on so we have

00:34:10,720 --> 00:34:14,159
an external network which is connected

00:34:12,159 --> 00:34:17,359
to the internet with one edge node

00:34:14,159 --> 00:34:19,200
and that also has a wireguard vpn which

00:34:17,359 --> 00:34:20,800
i'm logged into so that i can address

00:34:19,200 --> 00:34:23,200
all of the machines

00:34:20,800 --> 00:34:24,879
in the internal network just as if if i

00:34:23,200 --> 00:34:27,280
was in there as well

00:34:24,879 --> 00:34:29,440
and then we have the the orchestrator

00:34:27,280 --> 00:34:32,159
machine so this is running k3s

00:34:29,440 --> 00:34:33,679
as a lightweight kubernetes replacement

00:34:32,159 --> 00:34:35,359
actually it is like a kubernetes it's

00:34:33,679 --> 00:34:38,159
not a replacement

00:34:35,359 --> 00:34:38,960
um so we'll be using that to as our

00:34:38,159 --> 00:34:41,040
control plane

00:34:38,960 --> 00:34:42,000
and then we have worker one two and

00:34:41,040 --> 00:34:44,560
three and

00:34:42,000 --> 00:34:46,079
main one those are the the actual like

00:34:44,560 --> 00:34:46,639
proper machines that we want to manage

00:34:46,079 --> 00:34:49,359
and deploy

00:34:46,639 --> 00:34:51,440
services on um if you want to play

00:34:49,359 --> 00:34:54,879
around with this we we do offer

00:34:51,440 --> 00:34:56,480
um a we run a public rest service where

00:34:54,879 --> 00:34:58,160
you can download the terraform and

00:34:56,480 --> 00:35:01,040
ansible playbooks to

00:34:58,160 --> 00:35:02,800
stand this up just give us a shout after

00:35:01,040 --> 00:35:04,960
demonstration and i'll uh i'll send you

00:35:02,800 --> 00:35:07,119
a link where you can download things to

00:35:04,960 --> 00:35:08,400
to stand this up on your own and play

00:35:07,119 --> 00:35:10,720
around with it

00:35:08,400 --> 00:35:12,160
it's um fairly fabulous to be quite

00:35:10,720 --> 00:35:16,160
honest

00:35:12,160 --> 00:35:18,960
um so as i said our agent

00:35:16,160 --> 00:35:20,000
will register in kubernetes as a regular

00:35:18,960 --> 00:35:21,920
cubelet more or less

00:35:20,000 --> 00:35:24,240
so um these are the four machines that i

00:35:21,920 --> 00:35:25,040
just discussed uh this is k9s by the way

00:35:24,240 --> 00:35:27,440
it's a

00:35:25,040 --> 00:35:28,400
command line interface to kubernetes uh

00:35:27,440 --> 00:35:31,200
you could also use

00:35:28,400 --> 00:35:31,920
lens or oculus octane it's called or

00:35:31,200 --> 00:35:33,440
pretty much

00:35:31,920 --> 00:35:35,040
that that's that's a fabulous thing you

00:35:33,440 --> 00:35:38,560
can use whatever floats your boat

00:35:35,040 --> 00:35:39,119
and talks to kubernetes so um this one

00:35:38,560 --> 00:35:41,520
is

00:35:39,119 --> 00:35:42,480
this is actually a regular kubernetes

00:35:41,520 --> 00:35:44,640
cubelet which

00:35:42,480 --> 00:35:46,560
has been deployed by k3s so they they

00:35:44,640 --> 00:35:48,640
coexist quite nicely

00:35:46,560 --> 00:35:50,480
and then if you look in here you can see

00:35:48,640 --> 00:35:52,320
we have a type crosslit

00:35:50,480 --> 00:35:54,640
and then there's there's a few tanes in

00:35:52,320 --> 00:35:57,040
here which are pretty much just there to

00:35:54,640 --> 00:35:59,119
make sure that we don't get any

00:35:57,040 --> 00:36:00,720
regular kubernetes spots sent our way

00:35:59,119 --> 00:36:01,760
because our agent wouldn't know what to

00:36:00,720 --> 00:36:04,079
do with those

00:36:01,760 --> 00:36:05,599
those taints more or less control that

00:36:04,079 --> 00:36:09,040
we only get the ports that

00:36:05,599 --> 00:36:09,040
our operators write out

00:36:09,520 --> 00:36:15,359
and if i now want to deploy something

00:36:12,560 --> 00:36:16,640
a any of the big data services um what i

00:36:15,359 --> 00:36:19,839
would need to do

00:36:16,640 --> 00:36:21,839
is head over here so this is our

00:36:19,839 --> 00:36:23,680
also public this is the documentation

00:36:21,839 --> 00:36:24,800
repository and we have the demo requests

00:36:23,680 --> 00:36:25,359
in here so if you want to play around

00:36:24,800 --> 00:36:27,599
with those

00:36:25,359 --> 00:36:28,880
please by all means go and check them

00:36:27,599 --> 00:36:31,119
out

00:36:28,880 --> 00:36:31,920
and this is a zookeeper cluster

00:36:31,119 --> 00:36:33,760
definition

00:36:31,920 --> 00:36:34,960
what i was talking about earlier it's uh

00:36:33,760 --> 00:36:35,440
at this point in time it is fairly

00:36:34,960 --> 00:36:38,000
simple

00:36:35,440 --> 00:36:39,119
we simply say we want one instance per

00:36:38,000 --> 00:36:42,320
per server

00:36:39,119 --> 00:36:44,240
which you know we want for instance um

00:36:42,320 --> 00:36:45,440
we want a zookeeper in version three

00:36:44,240 --> 00:36:47,440
five eight

00:36:45,440 --> 00:36:48,480
and please uh deploy that on anything

00:36:47,440 --> 00:36:50,400
that matches this

00:36:48,480 --> 00:36:52,000
which as we just saw should be worker

00:36:50,400 --> 00:36:54,800
one two and three

00:36:52,000 --> 00:36:56,240
and if i now apply this to the

00:36:54,800 --> 00:36:56,640
kubernetes cluster we should see down

00:36:56,240 --> 00:36:59,920
here

00:36:56,640 --> 00:37:04,000
that's been created and

00:36:59,920 --> 00:37:05,760
i can now over here check out the

00:37:04,000 --> 00:37:07,440
the the object that we just created and

00:37:05,760 --> 00:37:08,720
if we go all the way down then you'll

00:37:07,440 --> 00:37:10,079
see in the status

00:37:08,720 --> 00:37:12,400
we are tracking what's happening in the

00:37:10,079 --> 00:37:14,160
background so this is currently doing an

00:37:12,400 --> 00:37:14,560
initial installation to version three

00:37:14,160 --> 00:37:17,680
five

00:37:14,560 --> 00:37:19,200
eight so if we

00:37:17,680 --> 00:37:20,800
have a look at the pots over here we can

00:37:19,200 --> 00:37:22,240
see two of them have already been

00:37:20,800 --> 00:37:24,880
written out and started

00:37:22,240 --> 00:37:26,960
and the third one is in the product

00:37:24,880 --> 00:37:30,079
process of being

00:37:26,960 --> 00:37:31,839
being uh started outside

00:37:30,079 --> 00:37:33,760
and if you wait a little bit yep so now

00:37:31,839 --> 00:37:36,240
that's running as well

00:37:33,760 --> 00:37:37,440
so what the the agent has now done in

00:37:36,240 --> 00:37:38,160
the background is it's gone and

00:37:37,440 --> 00:37:40,880
downloaded

00:37:38,160 --> 00:37:42,400
an apache zookeeper targets that file

00:37:40,880 --> 00:37:43,440
extracted that and i'll show that in a

00:37:42,400 --> 00:37:46,240
second

00:37:43,440 --> 00:37:47,440
and install that on the servers and then

00:37:46,240 --> 00:37:50,560
started a systemd

00:37:47,440 --> 00:37:53,599
service that runs that zookeeper

00:37:50,560 --> 00:37:56,480
and we can actually also uh

00:37:53,599 --> 00:37:57,040
use the kubernetes locks function so if

00:37:56,480 --> 00:37:58,400
i

00:37:57,040 --> 00:38:00,400
if i want to look at the locks and

00:37:58,400 --> 00:38:02,240
humanities what the agent does is it

00:38:00,400 --> 00:38:05,040
talks to journal control which is the

00:38:02,240 --> 00:38:06,800
systemd logging component on the machine

00:38:05,040 --> 00:38:07,680
and extracts the log and streams that

00:38:06,800 --> 00:38:10,000
back to me

00:38:07,680 --> 00:38:11,599
on my management machine over here so

00:38:10,000 --> 00:38:12,400
this is one of the instances where we

00:38:11,599 --> 00:38:13,760
have

00:38:12,400 --> 00:38:16,079
sort of the best of both worlds because

00:38:13,760 --> 00:38:19,119
i can in my kubernetes

00:38:16,079 --> 00:38:20,160
ui work with the logs and and see from

00:38:19,119 --> 00:38:22,160
one central point

00:38:20,160 --> 00:38:24,320
everything that's going on but i can

00:38:22,160 --> 00:38:27,839
also head out to the machine and do

00:38:24,320 --> 00:38:32,079
journal control minus you

00:38:27,839 --> 00:38:36,000
default zookeeper and see if the lock's

00:38:32,079 --> 00:38:39,280
uh going on here so you can see 77

00:38:36,000 --> 00:38:39,839
oh no yep that's what the two hours utc

00:38:39,280 --> 00:38:43,280
thingy

00:38:39,839 --> 00:38:43,280
that should be our current logs

00:38:44,640 --> 00:38:49,520
so i can do it the old-fashioned ops way

00:38:46,960 --> 00:38:51,440
but i can also do it the

00:38:49,520 --> 00:38:54,160
the way cool kids do it and use cube

00:38:51,440 --> 00:38:54,160
control logs

00:38:54,480 --> 00:38:58,079
and then just to give you one more

00:38:56,000 --> 00:39:00,320
example uh i'll also

00:38:58,079 --> 00:39:01,119
deploy a nifi cluster because this shows

00:39:00,320 --> 00:39:03,599
um

00:39:01,119 --> 00:39:06,000
our idea of sort of service composition

00:39:03,599 --> 00:39:09,440
so life in its cluster mode needs a

00:39:06,000 --> 00:39:09,440
zookeeper to

00:39:09,599 --> 00:39:13,040
orchestrate how their cluster nodes talk

00:39:11,760 --> 00:39:15,200
to each other so

00:39:13,040 --> 00:39:17,200
in our spec here we give it a zookeeper

00:39:15,200 --> 00:39:19,040
reference and this is

00:39:17,200 --> 00:39:21,200
this name the simple is actually

00:39:19,040 --> 00:39:23,760
something that we'll recognize from

00:39:21,200 --> 00:39:25,440
over here so if i now deploy this nifi

00:39:23,760 --> 00:39:27,839
cluster

00:39:25,440 --> 00:39:29,599
the operator will go out it'll go talk

00:39:27,839 --> 00:39:31,440
to kubernetes ask for the zookeeper

00:39:29,599 --> 00:39:32,880
cluster of name simple

00:39:31,440 --> 00:39:34,960
and retrieve the zookeeper connect

00:39:32,880 --> 00:39:36,960
string and then use that to configure

00:39:34,960 --> 00:39:40,839
nifi to find that

00:39:36,960 --> 00:39:43,040
zookeeper and use that for for its own

00:39:40,839 --> 00:39:45,359
orchestration

00:39:43,040 --> 00:39:46,560
so we should now see yep here's a couple

00:39:45,359 --> 00:39:49,359
of um

00:39:46,560 --> 00:39:50,880
of knife pods that have been written out

00:39:49,359 --> 00:39:52,880
this is fairly quick because i did the

00:39:50,880 --> 00:39:54,400
demo early on and the the download has

00:39:52,880 --> 00:39:55,599
already been done so um

00:39:54,400 --> 00:39:57,200
usually this would take a little bit

00:39:55,599 --> 00:39:58,960
longer but i figured no need for you to

00:39:57,200 --> 00:40:02,240
wait around for that

00:39:58,960 --> 00:40:06,160
uh what we can now do is

00:40:02,240 --> 00:40:08,000
head over to worker one stackable demo

00:40:06,160 --> 00:40:11,839
00:40:08,000 --> 00:40:11,839
as usual forget the slash nifi

00:40:13,359 --> 00:40:17,119
and then you can see that we do have a

00:40:15,359 --> 00:40:17,359
nifi deployed that should hopefully show

00:40:17,119 --> 00:40:20,960
us

00:40:17,359 --> 00:40:24,240
a canvas any second now

00:40:20,960 --> 00:40:26,400
and up here you can see uh it actually

00:40:24,240 --> 00:40:28,000
did form a cluster of three nodes

00:40:26,400 --> 00:40:29,760
that's using the the zookeeper we

00:40:28,000 --> 00:40:32,800
deployed just before that

00:40:29,760 --> 00:40:34,240
to coordinate with each other

00:40:32,800 --> 00:40:36,000
and with that i believe i'm actually

00:40:34,240 --> 00:40:39,520
already one minute over time and we'll

00:40:36,000 --> 00:40:53,839
wrap it up

00:40:39,520 --> 00:40:53,839
thank you yeah

00:41:00,079 --> 00:41:02,160

YouTube URL: https://www.youtube.com/watch?v=0ptB1REVKLw


