Title: Lauren Schaefer – From Tables to Documents—Changing Your Database Mindset
Publication date: 2021-06-24
Playlist: Berlin Buzzwords 2021 #bbuzz
Description: 
	Did you grow up on relational databases? Are document-based databases a bit of a mystery to you? This is the session for you! We’ll compare terms and concepts, explain the benefits of document-based databases, and walk through the 3 key ways you need to change your mindset to successfully use document-based databases.

Speaker:
Lauren Schaefer – https://2021.berlinbuzzwords.de/member/lauren-schaefer

More: https://2021.berlinbuzzwords.de/session/tables-documents-changing-your-database-mindset
Captions: 
	00:00:07,759 --> 00:00:11,440
welcome everyone

00:00:09,519 --> 00:00:13,679
i don't know about you but i've been

00:00:11,440 --> 00:00:17,039
eating a lot of comfort food

00:00:13,679 --> 00:00:19,680
and watching a lot of comfort tv lately

00:00:17,039 --> 00:00:21,279
my favorite comfort tv is the show parks

00:00:19,680 --> 00:00:23,199
and recreation

00:00:21,279 --> 00:00:25,279
one of the things that makes the show so

00:00:23,199 --> 00:00:29,039
amazing is the characters

00:00:25,279 --> 00:00:32,239
i want to introduce you to ron swanson

00:00:29,039 --> 00:00:34,719
this is ron he's an old school guy

00:00:32,239 --> 00:00:35,680
he's a bit set in his ways he likes his

00:00:34,719 --> 00:00:37,680
privacy

00:00:35,680 --> 00:00:39,120
and he likes to stay kind of off the

00:00:37,680 --> 00:00:42,239
grid

00:00:39,120 --> 00:00:42,960
now in season six episode 14 ron

00:00:42,239 --> 00:00:46,000
discovers

00:00:42,960 --> 00:00:48,320
yelp he loves the idea of being able to

00:00:46,000 --> 00:00:51,680
review places he's been

00:00:48,320 --> 00:00:54,719
however yelp is way too on the grid

00:00:51,680 --> 00:00:56,640
for ron so ron uses the internet to look

00:00:54,719 --> 00:00:58,000
up the physical addresses of where he

00:00:56,640 --> 00:01:00,719
wants to snail mail

00:00:58,000 --> 00:01:02,160
his reviews and then he pulls out his

00:01:00,719 --> 00:01:05,519
big old typewriter

00:01:02,160 --> 00:01:08,000
and he starts typing his reviews now

00:01:05,519 --> 00:01:10,479
ron writes some pretty great reviews

00:01:08,000 --> 00:01:13,520
here's one of my favorites

00:01:10,479 --> 00:01:15,119
dear frozen yogurt you are the celery of

00:01:13,520 --> 00:01:20,560
desserts

00:01:15,119 --> 00:01:22,880
be ice cream or be nothing zero stars

00:01:20,560 --> 00:01:26,000
now this is a pretty great review but i

00:01:22,880 --> 00:01:29,040
see three problems with this approach

00:01:26,000 --> 00:01:30,400
number one snail mail is way slower than

00:01:29,040 --> 00:01:33,119
posting the review to yelp

00:01:30,400 --> 00:01:34,159
where it will be instantly available

00:01:33,119 --> 00:01:36,240
number two

00:01:34,159 --> 00:01:37,920
the businesses he's reviewing may never

00:01:36,240 --> 00:01:39,600
open the review because they may just

00:01:37,920 --> 00:01:41,840
assume it's junk mail

00:01:39,600 --> 00:01:43,840
and number three no one else is going to

00:01:41,840 --> 00:01:46,079
benefit from the review

00:01:43,840 --> 00:01:47,840
i don't know about you but i live for

00:01:46,079 --> 00:01:49,520
these kinds of reviews online

00:01:47,840 --> 00:01:51,680
i love to see this sort of thing on

00:01:49,520 --> 00:01:53,920
amazon

00:01:51,680 --> 00:01:55,920
now ron was inspired by yelp and he saw

00:01:53,920 --> 00:01:57,600
the value in the technology

00:01:55,920 --> 00:02:00,000
but he didn't change his old school

00:01:57,600 --> 00:02:01,280
mindset in order to really get the value

00:02:00,000 --> 00:02:02,880
out of it

00:02:01,280 --> 00:02:05,200
and this is what we see sometimes as

00:02:02,880 --> 00:02:08,399
people move from tabular databases

00:02:05,200 --> 00:02:10,080
to document databases they see the value

00:02:08,399 --> 00:02:12,640
of document databases

00:02:10,080 --> 00:02:14,879
and are inspired by the technology but

00:02:12,640 --> 00:02:16,640
they bring with them their old mindsets

00:02:14,879 --> 00:02:18,560
so they don't get the full value of

00:02:16,640 --> 00:02:20,959
document databases

00:02:18,560 --> 00:02:23,120
now i don't want this to happen to you i

00:02:20,959 --> 00:02:26,959
want to see you be really successful

00:02:23,120 --> 00:02:26,959
as you work with document databases

00:02:27,840 --> 00:02:32,400
so before we dive in let me introduce

00:02:29,840 --> 00:02:34,239
myself my name is lauren shafer

00:02:32,400 --> 00:02:36,480
now i took a database course in college

00:02:34,239 --> 00:02:38,480
that was all about best practices for

00:02:36,480 --> 00:02:40,879
relational databases

00:02:38,480 --> 00:02:43,599
i began my career at ibm where i spent

00:02:40,879 --> 00:02:46,800
eight years as a software engineer

00:02:43,599 --> 00:02:48,560
for a lot of that time i used db2

00:02:46,800 --> 00:02:50,080
toward the end of my time there my team

00:02:48,560 --> 00:02:51,760
started getting flexibility in what

00:02:50,080 --> 00:02:55,360
database we wanted to use

00:02:51,760 --> 00:02:57,440
so i started trying out nosql databases

00:02:55,360 --> 00:02:58,959
to be honest with you i didn't really

00:02:57,440 --> 00:03:01,040
get the hype

00:02:58,959 --> 00:03:03,200
without a doubt nosql databases were

00:03:01,040 --> 00:03:04,959
easy to get started using

00:03:03,200 --> 00:03:06,959
but i brought with me my relational

00:03:04,959 --> 00:03:08,080
database mindset so i kept thinking

00:03:06,959 --> 00:03:10,640
about my data

00:03:08,080 --> 00:03:13,440
in rows and columns even though i wasn't

00:03:10,640 --> 00:03:16,480
using rows and columns anymore

00:03:13,440 --> 00:03:18,480
it worked but it wasn't great

00:03:16,480 --> 00:03:20,560
i joined mongodb about a year and a half

00:03:18,480 --> 00:03:22,720
ago and i've worked through the process

00:03:20,560 --> 00:03:24,720
of changing my mindset and how i think

00:03:22,720 --> 00:03:26,480
about storing data

00:03:24,720 --> 00:03:28,159
and i'm so happy i did because it's

00:03:26,480 --> 00:03:30,720
really easy to work with data

00:03:28,159 --> 00:03:31,920
in the apps that i build now so today

00:03:30,720 --> 00:03:33,680
i'm going to share with you what i've

00:03:31,920 --> 00:03:36,959
learned as i've gone on the journey

00:03:33,680 --> 00:03:39,360
of moving from tables to documents

00:03:36,959 --> 00:03:41,040
when i say tables i mean a tabular or

00:03:39,360 --> 00:03:42,879
relational database

00:03:41,040 --> 00:03:44,640
for example you might have experience

00:03:42,879 --> 00:03:47,599
using something like mysql

00:03:44,640 --> 00:03:50,560
or oracle we'll dive into what document

00:03:47,599 --> 00:03:52,319
databases are in just a few minutes

00:03:50,560 --> 00:03:54,080
so if you're here i'm going to assume

00:03:52,319 --> 00:03:55,200
one you have experience with relational

00:03:54,080 --> 00:03:57,280
databases

00:03:55,200 --> 00:04:01,680
and two you have minimal to no

00:03:57,280 --> 00:04:03,040
experience with document databases

00:04:01,680 --> 00:04:05,920
so today we're going to go on a mental

00:04:03,040 --> 00:04:07,519
journey from tables to documents

00:04:05,920 --> 00:04:09,280
i'm going to kick things off by mapping

00:04:07,519 --> 00:04:09,599
the terms and concepts you're familiar

00:04:09,280 --> 00:04:12,159
with

00:04:09,599 --> 00:04:15,040
in tabular databases to similar terms

00:04:12,159 --> 00:04:16,639
and concepts in document databases

00:04:15,040 --> 00:04:19,199
then i'll talk about the four major

00:04:16,639 --> 00:04:21,280
advantages of document databases

00:04:19,199 --> 00:04:23,199
and finally we'll wrap up with the three

00:04:21,280 --> 00:04:26,800
key ways you need to change your mindset

00:04:23,199 --> 00:04:28,960
when you move from tables to documents

00:04:26,800 --> 00:04:31,360
all right so let's jump in with terms

00:04:28,960 --> 00:04:34,800
and concepts

00:04:31,360 --> 00:04:38,639
let's talk about documents

00:04:34,800 --> 00:04:41,759
no i'm not talking about word documents

00:04:38,639 --> 00:04:44,160
i'm talking about json documents

00:04:41,759 --> 00:04:45,759
json stands for javascript object

00:04:44,160 --> 00:04:47,759
notation

00:04:45,759 --> 00:04:49,280
if you if you've used any of the c

00:04:47,759 --> 00:04:52,400
family of programming languages

00:04:49,280 --> 00:04:56,479
such as c c sharp go

00:04:52,400 --> 00:04:58,080
java javascript php or python

00:04:56,479 --> 00:04:59,919
documents will probably feel pretty

00:04:58,080 --> 00:05:01,680
comfortable to you

00:04:59,919 --> 00:05:03,360
documents typically store information

00:05:01,680 --> 00:05:05,360
about one object

00:05:03,360 --> 00:05:08,080
as well as any information related to

00:05:05,360 --> 00:05:08,080
that object

00:05:08,240 --> 00:05:13,759
every document begins and ends with

00:05:10,880 --> 00:05:13,759
curly braces

00:05:14,240 --> 00:05:17,280
inside of those curly braces are field

00:05:16,800 --> 00:05:20,240
value

00:05:17,280 --> 00:05:20,880
pairs the great thing about documents is

00:05:20,240 --> 00:05:24,000
they can be

00:05:20,880 --> 00:05:26,479
incredibly rich values can be a variety

00:05:24,000 --> 00:05:27,120
of types including strings numbers

00:05:26,479 --> 00:05:30,160
arrays

00:05:27,120 --> 00:05:32,000
dates timestamps or even objects

00:05:30,160 --> 00:05:33,840
so you can have objects within a

00:05:32,000 --> 00:05:36,160
document and you'll see what that looks

00:05:33,840 --> 00:05:37,680
like in just a moment

00:05:36,160 --> 00:05:40,160
now when people talk about document

00:05:37,680 --> 00:05:42,720
databases they'll often use the term

00:05:40,160 --> 00:05:44,240
non-relational but that doesn't mean

00:05:42,720 --> 00:05:47,120
document databases

00:05:44,240 --> 00:05:48,960
don't store relationships okay that was

00:05:47,120 --> 00:05:51,120
a double negative stick with me

00:05:48,960 --> 00:05:52,320
document databases store relationships

00:05:51,120 --> 00:05:53,919
really well

00:05:52,320 --> 00:05:57,440
it's just different than the way

00:05:53,919 --> 00:05:57,440
relational databases do

00:05:57,600 --> 00:06:01,039
so let's walk through an example of how

00:05:59,360 --> 00:06:02,000
you would model the same data in a

00:06:01,039 --> 00:06:04,840
relational

00:06:02,000 --> 00:06:06,800
tabular database versus a document

00:06:04,840 --> 00:06:10,080
database so let's say we need to store

00:06:06,800 --> 00:06:11,600
information about a user named leslie

00:06:10,080 --> 00:06:14,319
so let's begin with her contact

00:06:11,600 --> 00:06:17,600
information in a relational database

00:06:14,319 --> 00:06:19,840
we'll create a table named users

00:06:17,600 --> 00:06:22,160
we can create columns for each piece of

00:06:19,840 --> 00:06:23,840
contact information we need to store

00:06:22,160 --> 00:06:25,680
so as you can see we've got columns for

00:06:23,840 --> 00:06:28,880
first name last name

00:06:25,680 --> 00:06:31,520
cell phone number and city to ensure we

00:06:28,880 --> 00:06:35,280
have a unique way to identify each row

00:06:31,520 --> 00:06:37,600
we'll include an id column

00:06:35,280 --> 00:06:39,120
now let's store that same information in

00:06:37,600 --> 00:06:41,520
a document

00:06:39,120 --> 00:06:43,680
we can create a new document for leslie

00:06:41,520 --> 00:06:45,600
where we'll add field value pairs for

00:06:43,680 --> 00:06:47,199
each piece of contact information we

00:06:45,600 --> 00:06:49,440
need to store

00:06:47,199 --> 00:06:50,720
as you can see we have field value pairs

00:06:49,440 --> 00:06:54,000
for first name

00:06:50,720 --> 00:06:56,160
last name cell and city

00:06:54,000 --> 00:06:58,639
we'll use underscore id to uniquely

00:06:56,160 --> 00:07:00,240
identify each document

00:06:58,639 --> 00:07:01,680
we'll store this document in a

00:07:00,240 --> 00:07:05,599
collection named

00:07:01,680 --> 00:07:06,960
users so now that we've stored leslie's

00:07:05,599 --> 00:07:08,880
contact information

00:07:06,960 --> 00:07:10,720
let's store the coordinates of her

00:07:08,880 --> 00:07:12,479
current location

00:07:10,720 --> 00:07:14,639
when using a relational database we'll

00:07:12,479 --> 00:07:15,280
need to split the latitude and longitude

00:07:14,639 --> 00:07:19,599
between

00:07:15,280 --> 00:07:21,520
two columns document databases support

00:07:19,599 --> 00:07:22,960
arrays so we can store the latitude and

00:07:21,520 --> 00:07:25,599
longitude together

00:07:22,960 --> 00:07:28,160
in a single field we'll call that field

00:07:25,599 --> 00:07:28,160
location

00:07:29,199 --> 00:07:32,240
we're successfully storing leslie's

00:07:30,800 --> 00:07:34,960
contact information in

00:07:32,240 --> 00:07:36,400
current location now let's store her

00:07:34,960 --> 00:07:38,240
hobbies

00:07:36,400 --> 00:07:39,599
when using a relational database we

00:07:38,240 --> 00:07:43,039
could choose to add

00:07:39,599 --> 00:07:45,120
more columns to the users table

00:07:43,039 --> 00:07:46,479
however since a single user could have

00:07:45,120 --> 00:07:48,080
many hobbies

00:07:46,479 --> 00:07:50,000
meaning we need to represent a

00:07:48,080 --> 00:07:52,240
one-to-many relationship

00:07:50,000 --> 00:07:54,639
we're more likely to create a separate

00:07:52,240 --> 00:07:56,400
table just for hobbies

00:07:54,639 --> 00:07:58,400
each row in the table will contain

00:07:56,400 --> 00:08:01,120
information about one hobby

00:07:58,400 --> 00:08:02,800
for one user when we need to retrieve

00:08:01,120 --> 00:08:04,720
lesley's hobbies we're going to join the

00:08:02,800 --> 00:08:07,199
users table and our new hobbies table

00:08:04,720 --> 00:08:07,199
together

00:08:07,680 --> 00:08:12,080
since document databases support arrays

00:08:10,240 --> 00:08:14,560
we can simply add a new field

00:08:12,080 --> 00:08:16,160
named hobbies to our existing document

00:08:14,560 --> 00:08:18,560
for leslie

00:08:16,160 --> 00:08:20,560
the array can contain as many or as few

00:08:18,560 --> 00:08:21,919
hobbies as we need

00:08:20,560 --> 00:08:23,919
when we need to retrieve leslie's

00:08:21,919 --> 00:08:25,759
hobbies we don't need to do an expensive

00:08:23,919 --> 00:08:27,680
join to bring the data together

00:08:25,759 --> 00:08:31,520
we simply retrieve her document from the

00:08:27,680 --> 00:08:31,520
user's collection and we're good to go

00:08:32,159 --> 00:08:36,399
so let's say we also need to store

00:08:34,159 --> 00:08:38,719
leslie's job history

00:08:36,399 --> 00:08:40,560
how are we going to do that well just as

00:08:38,719 --> 00:08:42,320
we did with hobbies we're likely to

00:08:40,560 --> 00:08:45,680
create a separate table

00:08:42,320 --> 00:08:47,440
just for job history information

00:08:45,680 --> 00:08:49,360
each row in the table will contain

00:08:47,440 --> 00:08:52,720
information about one job

00:08:49,360 --> 00:08:54,800
for one user so far

00:08:52,720 --> 00:08:57,680
we've used arrays to store geolocation

00:08:54,800 --> 00:09:00,320
data and a list of strings

00:08:57,680 --> 00:09:02,720
arrays can contain values of any type

00:09:00,320 --> 00:09:05,120
including objects

00:09:02,720 --> 00:09:06,240
so let's create an object for each job

00:09:05,120 --> 00:09:09,600
leslie is held

00:09:06,240 --> 00:09:11,440
and store those objects in an array

00:09:09,600 --> 00:09:14,000
as you can see we have a job history

00:09:11,440 --> 00:09:16,080
field that stores an array

00:09:14,000 --> 00:09:18,399
inside of that array you have an object

00:09:16,080 --> 00:09:20,000
for when she was the deputy director

00:09:18,399 --> 00:09:22,560
an object for when she was a city

00:09:20,000 --> 00:09:23,200
councilor and an object for when she was

00:09:22,560 --> 00:09:25,440
director

00:09:23,200 --> 00:09:27,839
of the national park services midwest

00:09:25,440 --> 00:09:27,839
branch

00:09:28,480 --> 00:09:31,680
now that we've decided how we'll store

00:09:30,080 --> 00:09:33,920
information about our users in both

00:09:31,680 --> 00:09:37,120
tables and documents

00:09:33,920 --> 00:09:38,959
let's store information about ron

00:09:37,120 --> 00:09:40,880
now ron will have almost all the same

00:09:38,959 --> 00:09:43,519
information as leslie

00:09:40,880 --> 00:09:44,000
however as i mentioned earlier ron likes

00:09:43,519 --> 00:09:45,920
to stay

00:09:44,000 --> 00:09:50,080
off the grid so he's not going to be

00:09:45,920 --> 00:09:51,680
storing his location in the system

00:09:50,080 --> 00:09:53,360
let's begin by examining how we would

00:09:51,680 --> 00:09:54,880
store ron's information

00:09:53,360 --> 00:09:57,200
in the same tables that we used for

00:09:54,880 --> 00:09:58,959
leslie's when using a relational

00:09:57,200 --> 00:09:59,760
database we are required to input a

00:09:58,959 --> 00:10:02,320
value for

00:09:59,760 --> 00:10:02,959
every cell in the table so we'll

00:10:02,320 --> 00:10:06,880
represent

00:10:02,959 --> 00:10:08,640
ron's lack of location data with null

00:10:06,880 --> 00:10:10,800
the problem with using null is that it's

00:10:08,640 --> 00:10:13,200
unclear whether the data does not exist

00:10:10,800 --> 00:10:14,880
or the data is just unknown so many

00:10:13,200 --> 00:10:17,120
people actually discourage the use of

00:10:14,880 --> 00:10:17,120
null

00:10:17,519 --> 00:10:21,519
in document databases we have the option

00:10:19,600 --> 00:10:22,000
of representing ron's lack of location

00:10:21,519 --> 00:10:25,040
data

00:10:22,000 --> 00:10:27,519
in two ways so one way is we can omit

00:10:25,040 --> 00:10:29,040
the location field from the document

00:10:27,519 --> 00:10:31,120
the second way is we can set the

00:10:29,040 --> 00:10:33,040
location to null

00:10:31,120 --> 00:10:35,600
best practices suggest that we omit the

00:10:33,040 --> 00:10:37,120
location field to save space

00:10:35,600 --> 00:10:38,959
you can choose if you want omitted

00:10:37,120 --> 00:10:40,560
fields and fields set to null to

00:10:38,959 --> 00:10:41,519
represent different things in your

00:10:40,560 --> 00:10:43,120
applications

00:10:41,519 --> 00:10:45,360
you've got a little extra flexibility

00:10:43,120 --> 00:10:45,360
there

00:10:45,760 --> 00:10:50,079
ron has some hobbies in job history so

00:10:48,399 --> 00:10:52,560
let's add his information to those

00:10:50,079 --> 00:10:52,560
tables

00:10:53,120 --> 00:10:56,800
and we can add that information to his

00:10:54,959 --> 00:10:58,959
document as well

00:10:56,800 --> 00:11:03,120
so the structure of ron's document looks

00:10:58,959 --> 00:11:03,120
pretty similar to leslie's at this point

00:11:03,200 --> 00:11:06,880
so let's say we're feeling pretty good

00:11:04,720 --> 00:11:09,839
about our data models and we decide to

00:11:06,880 --> 00:11:12,880
launch our apps using them

00:11:09,839 --> 00:11:14,000
then requirements change we discover we

00:11:12,880 --> 00:11:17,440
need to store information

00:11:14,000 --> 00:11:19,440
about a new user lauren lauren is a

00:11:17,440 --> 00:11:22,000
fourth grade student who ron teaches

00:11:19,440 --> 00:11:24,079
about government we need to store a lot

00:11:22,000 --> 00:11:24,480
of the same information about leslie as

00:11:24,079 --> 00:11:28,000
we

00:11:24,480 --> 00:11:29,360
as with about lauren let me start again

00:11:28,000 --> 00:11:31,200
we need to store a lot of the same

00:11:29,360 --> 00:11:32,320
information about lauren as we did with

00:11:31,200 --> 00:11:33,920
leslie and ron

00:11:32,320 --> 00:11:35,600
things like her first name last name

00:11:33,920 --> 00:11:37,839
city and hobbies

00:11:35,600 --> 00:11:40,800
however lauren doesn't have a cell phone

00:11:37,839 --> 00:11:42,800
location data or job history

00:11:40,800 --> 00:11:44,480
we also discover that we need to store a

00:11:42,800 --> 00:11:48,240
new piece of information

00:11:44,480 --> 00:11:50,000
for school so let's begin by storing

00:11:48,240 --> 00:11:52,880
lauren's information in the tables as

00:11:50,000 --> 00:11:55,279
they already exist

00:11:52,880 --> 00:11:57,040
we can create a new document for lauren

00:11:55,279 --> 00:11:59,360
and include the data we have for her

00:11:57,040 --> 00:11:59,360
in it

00:12:00,320 --> 00:12:03,760
now let's talk about how to store

00:12:01,680 --> 00:12:04,720
information about lauren's school in our

00:12:03,760 --> 00:12:07,040
tables

00:12:04,720 --> 00:12:09,519
we've got two options we can choose to

00:12:07,040 --> 00:12:11,680
add a column to the existing users table

00:12:09,519 --> 00:12:13,440
or we can create a new table named

00:12:11,680 --> 00:12:15,040
schools

00:12:13,440 --> 00:12:17,600
so let's say we choose to add a column

00:12:15,040 --> 00:12:19,200
named school to the users table

00:12:17,600 --> 00:12:22,320
depending on our access rights to the

00:12:19,200 --> 00:12:24,480
database we may need to talk to the dba

00:12:22,320 --> 00:12:26,720
and do a little convincing to get them

00:12:24,480 --> 00:12:28,480
to add the column

00:12:26,720 --> 00:12:30,399
maybe we have to do a little begging to

00:12:28,480 --> 00:12:32,480
get our dba to add the column

00:12:30,399 --> 00:12:33,680
maybe we have to do a little bribing

00:12:32,480 --> 00:12:36,000
maybe we need to bring them

00:12:33,680 --> 00:12:37,680
their favorite donut or maybe we need to

00:12:36,000 --> 00:12:41,440
bring our manager along to really

00:12:37,680 --> 00:12:41,440
pressure the dba into agreeing

00:12:41,519 --> 00:12:45,519
if our dba agrees the database will

00:12:43,680 --> 00:12:47,519
likely need to be taken down

00:12:45,519 --> 00:12:48,880
the school column will need to be added

00:12:47,519 --> 00:12:50,639
null values will be stored in

00:12:48,880 --> 00:12:52,240
every row in the user's table where a

00:12:50,639 --> 00:12:53,600
user does not have a school

00:12:52,240 --> 00:12:56,160
and then the database will need to be

00:12:53,600 --> 00:12:59,680
brought back up it's doable

00:12:56,160 --> 00:13:00,880
it just can be you know a little painful

00:12:59,680 --> 00:13:04,079
now let's talk about how to store

00:13:00,880 --> 00:13:06,320
lauren's school in documents

00:13:04,079 --> 00:13:09,040
we can simply add a new field named

00:13:06,320 --> 00:13:11,200
school to lauren's document

00:13:09,040 --> 00:13:12,639
we do not need to make any modifications

00:13:11,200 --> 00:13:14,880
to leslie's document

00:13:12,639 --> 00:13:17,839
or ron's document when we add the new

00:13:14,880 --> 00:13:19,839
school fields to lauren's document

00:13:17,839 --> 00:13:20,880
document databases have a flexible

00:13:19,839 --> 00:13:23,200
schema

00:13:20,880 --> 00:13:24,800
so every document in a collection does

00:13:23,200 --> 00:13:28,639
not need to have the same

00:13:24,800 --> 00:13:30,639
fields now for those of you with years

00:13:28,639 --> 00:13:32,240
of experience using relational databases

00:13:30,639 --> 00:13:34,320
you might be starting to panic at the

00:13:32,240 --> 00:13:36,079
idea of a flexible schema

00:13:34,320 --> 00:13:38,880
i know i started to panic a little when

00:13:36,079 --> 00:13:41,760
i was introduced to the idea

00:13:38,880 --> 00:13:43,839
don't panic this flexibility can be

00:13:41,760 --> 00:13:44,639
hugely valuable as your application's

00:13:43,839 --> 00:13:48,160
requirements

00:13:44,639 --> 00:13:50,480
evolve and change also some document

00:13:48,160 --> 00:13:53,199
databases provide schema validation

00:13:50,480 --> 00:13:54,160
so you can lock down your schema as much

00:13:53,199 --> 00:13:56,800
or as little

00:13:54,160 --> 00:13:58,320
as you'd like when you're ready now that

00:13:56,800 --> 00:14:00,399
we're starting to get the idea of how

00:13:58,320 --> 00:14:01,519
tables and documents are similar and

00:14:00,399 --> 00:14:04,639
different

00:14:01,519 --> 00:14:06,160
let's do some explicit term mapping on

00:14:04,639 --> 00:14:08,720
the left side of the screen you'll see

00:14:06,160 --> 00:14:09,920
tabular or relational database terms

00:14:08,720 --> 00:14:13,120
and on the right side of the screen

00:14:09,920 --> 00:14:15,040
you'll see document database terms

00:14:13,120 --> 00:14:16,560
so first up we saw this a little bit in

00:14:15,040 --> 00:14:20,639
our earlier example

00:14:16,560 --> 00:14:20,639
a row maps to a document

00:14:21,360 --> 00:14:25,839
or depending on how you've normalized

00:14:23,199 --> 00:14:30,160
your data rows from multiple tables

00:14:25,839 --> 00:14:34,480
could map to a single document

00:14:30,160 --> 00:14:34,480
a column maps roughly to a field

00:14:35,839 --> 00:14:40,399
in a relational database groups of rows

00:14:38,320 --> 00:14:42,320
are stored in tables

00:14:40,399 --> 00:14:44,720
in a document database groups of

00:14:42,320 --> 00:14:48,079
documents are stored in collections

00:14:44,720 --> 00:14:50,079
so tables map to collections

00:14:48,079 --> 00:14:51,680
the next few terms will probably feel

00:14:50,079 --> 00:14:53,440
pretty comfortable to those of you with

00:14:51,680 --> 00:14:55,680
relational database backgrounds

00:14:53,440 --> 00:14:58,320
as the terminology is basically the same

00:14:55,680 --> 00:15:00,160
between the two

00:14:58,320 --> 00:15:01,440
just like you store groups of tables in

00:15:00,160 --> 00:15:03,760
a relational database

00:15:01,440 --> 00:15:06,880
you store groups of collections in a

00:15:03,760 --> 00:15:06,880
document database

00:15:07,360 --> 00:15:10,480
indexes are fairly similar between the

00:15:09,440 --> 00:15:15,440
two

00:15:10,480 --> 00:15:15,440
indexes help speed up your read queries

00:15:15,760 --> 00:15:19,519
views are pretty similar in both

00:15:20,160 --> 00:15:24,959
now there are a few different ways to

00:15:21,760 --> 00:15:27,680
handle joins in document databases

00:15:24,959 --> 00:15:29,360
the general recommendation is that if

00:15:27,680 --> 00:15:31,199
you have related information that you

00:15:29,360 --> 00:15:32,720
would typically put in a separate table

00:15:31,199 --> 00:15:34,480
in a relational database

00:15:32,720 --> 00:15:36,720
you should actually just embed that

00:15:34,480 --> 00:15:39,680
information in a single document

00:15:36,720 --> 00:15:40,000
when working in a document database the

00:15:39,680 --> 00:15:41,360
rule

00:15:40,000 --> 00:15:43,120
of thumb you're going to hear me say it

00:15:41,360 --> 00:15:46,079
multiple times today

00:15:43,120 --> 00:15:47,600
is that data that is accessed together

00:15:46,079 --> 00:15:49,839
should be stored together

00:15:47,600 --> 00:15:51,920
so let me just say it again right now

00:15:49,839 --> 00:15:54,639
data that is accessed together

00:15:51,920 --> 00:15:56,399
should be stored together so if you'll

00:15:54,639 --> 00:15:57,600
be frequently accessing information

00:15:56,399 --> 00:15:58,800
together that you would have put in

00:15:57,600 --> 00:16:00,800
separate tables

00:15:58,800 --> 00:16:02,720
you should likely just embed it in a

00:16:00,800 --> 00:16:04,160
document

00:16:02,720 --> 00:16:06,240
depending on the document database

00:16:04,160 --> 00:16:09,120
you're using there are other options for

00:16:06,240 --> 00:16:10,800
joins as well some databases support

00:16:09,120 --> 00:16:12,320
references between the documents

00:16:10,800 --> 00:16:15,519
similar to how you would use a foreign

00:16:12,320 --> 00:16:16,800
key some databases also have special

00:16:15,519 --> 00:16:19,600
operations to support

00:16:16,800 --> 00:16:21,279
a left outer join these options for

00:16:19,600 --> 00:16:22,079
joins get specific to the database

00:16:21,279 --> 00:16:23,759
you're using

00:16:22,079 --> 00:16:26,399
so i'm not going to go any deeper into

00:16:23,759 --> 00:16:26,399
it here today

00:16:27,120 --> 00:16:31,600
all right finally let's talk about acid

00:16:29,680 --> 00:16:33,680
transactions

00:16:31,600 --> 00:16:36,160
transactions group database operations

00:16:33,680 --> 00:16:37,920
together so they either all succeed or

00:16:36,160 --> 00:16:39,519
none succeed

00:16:37,920 --> 00:16:41,279
now if you did some research online

00:16:39,519 --> 00:16:43,040
about relational databases versus

00:16:41,279 --> 00:16:44,000
document databases before coming here

00:16:43,040 --> 00:16:45,680
today

00:16:44,000 --> 00:16:47,040
you probably saw something about

00:16:45,680 --> 00:16:49,839
document databases

00:16:47,040 --> 00:16:52,000
not supporting transactions as a major

00:16:49,839 --> 00:16:54,240
drawback

00:16:52,000 --> 00:16:55,920
if you care about data integrity and

00:16:54,240 --> 00:17:00,000
really who doesn't

00:16:55,920 --> 00:17:02,160
that's a pretty scary sounding drawback

00:17:00,000 --> 00:17:03,279
now some document databases support acid

00:17:02,160 --> 00:17:05,760
transactions

00:17:03,279 --> 00:17:06,559
while others do not in relational

00:17:05,760 --> 00:17:08,640
databases

00:17:06,559 --> 00:17:10,079
we call these multi-record acid

00:17:08,640 --> 00:17:12,319
transactions

00:17:10,079 --> 00:17:16,240
in document databases we call these

00:17:12,319 --> 00:17:18,559
multi-document asset transactions

00:17:16,240 --> 00:17:20,160
however when you model your data for

00:17:18,559 --> 00:17:22,079
document databases

00:17:20,160 --> 00:17:25,039
you'll find that most of the time you

00:17:22,079 --> 00:17:26,480
don't actually need to use a transaction

00:17:25,039 --> 00:17:28,640
now i'll explain why that is at the end

00:17:26,480 --> 00:17:30,320
of the presentation so

00:17:28,640 --> 00:17:31,360
what i want you to know now is don't get

00:17:30,320 --> 00:17:32,000
freaked out if you're looking at

00:17:31,360 --> 00:17:34,400
drawbacks

00:17:32,000 --> 00:17:36,480
of document databases and see no

00:17:34,400 --> 00:17:38,000
transactions listed

00:17:36,480 --> 00:17:40,720
some document databases support

00:17:38,000 --> 00:17:41,600
transactions but chances are good that

00:17:40,720 --> 00:17:44,880
either way

00:17:41,600 --> 00:17:44,880
you won't actually need them

00:17:45,039 --> 00:17:49,760
so to wrap up this section i created

00:17:46,960 --> 00:17:51,440
this term mapping summary for you

00:17:49,760 --> 00:17:52,880
it's way too much information for you to

00:17:51,440 --> 00:17:55,120
read now but

00:17:52,880 --> 00:17:56,320
go ahead take a screenshot feel free to

00:17:55,120 --> 00:17:58,160
tweet it

00:17:56,320 --> 00:18:00,640
um you can print it hang it up at your

00:17:58,160 --> 00:18:02,480
desk whatever you want to do

00:18:00,640 --> 00:18:04,400
but before we go on i want you to

00:18:02,480 --> 00:18:06,000
internalize the first three term

00:18:04,400 --> 00:18:09,760
mappings

00:18:06,000 --> 00:18:12,799
a row maps to a document a column

00:18:09,760 --> 00:18:16,080
maps to a field and a table

00:18:12,799 --> 00:18:17,360
maps to a collection all right so now

00:18:16,080 --> 00:18:18,640
that we have an understanding of the

00:18:17,360 --> 00:18:20,559
terms and concepts

00:18:18,640 --> 00:18:24,080
let's talk about the four major

00:18:20,559 --> 00:18:26,960
advantages of document databases

00:18:24,080 --> 00:18:28,559
let's jump back to ron for a moment ron

00:18:26,960 --> 00:18:30,240
loves his typewriter

00:18:28,559 --> 00:18:32,160
and unless you convince him otherwise

00:18:30,240 --> 00:18:33,440
there is no way he's going to change his

00:18:32,160 --> 00:18:35,919
mindset

00:18:33,440 --> 00:18:38,240
maybe that's you maybe you've been

00:18:35,919 --> 00:18:40,480
successful with relational databases

00:18:38,240 --> 00:18:42,160
you're comfortable with them maybe they

00:18:40,480 --> 00:18:44,400
aren't always the easiest but you've

00:18:42,160 --> 00:18:46,880
learned how to get the job done

00:18:44,400 --> 00:18:48,400
so let's answer the question is it worth

00:18:46,880 --> 00:18:49,679
changing your mindset from tables to

00:18:48,400 --> 00:18:50,960
documents

00:18:49,679 --> 00:18:52,720
so i'm going to walk you through the

00:18:50,960 --> 00:18:53,919
four advantages to using document

00:18:52,720 --> 00:18:57,840
databases

00:18:53,919 --> 00:19:00,960
so here they are no particular order

00:18:57,840 --> 00:19:02,880
let's begin by talking about scaling

00:19:00,960 --> 00:19:05,679
let's say ron has an app where he sells

00:19:02,880 --> 00:19:07,520
the chairs he makes in his workshop

00:19:05,679 --> 00:19:08,880
he's using a relational database behind

00:19:07,520 --> 00:19:10,880
the scenes

00:19:08,880 --> 00:19:13,039
when one of ron's chairs is nominated

00:19:10,880 --> 00:19:15,039
for an award from the indiana fine

00:19:13,039 --> 00:19:17,760
woodworking association

00:19:15,039 --> 00:19:19,919
orders start pouring in he desperately

00:19:17,760 --> 00:19:23,120
needs to scale his database

00:19:19,919 --> 00:19:25,919
now typically relational databases scale

00:19:23,120 --> 00:19:27,440
vertically when his database becomes too

00:19:25,919 --> 00:19:30,880
big for its server

00:19:27,440 --> 00:19:32,559
he has to migrate it to a larger server

00:19:30,880 --> 00:19:35,200
when ron's chair appears in blush

00:19:32,559 --> 00:19:36,960
magazine his chairs go viral

00:19:35,200 --> 00:19:38,720
and he needs to migrate to an even

00:19:36,960 --> 00:19:40,080
larger server

00:19:38,720 --> 00:19:42,160
now there are a few key problems with

00:19:40,080 --> 00:19:44,240
vertical scaling

00:19:42,160 --> 00:19:46,160
large servers tend to be more expensive

00:19:44,240 --> 00:19:48,559
than two smaller servers with the same

00:19:46,160 --> 00:19:50,880
total capacity

00:19:48,559 --> 00:19:52,720
large servers may not be available due

00:19:50,880 --> 00:19:54,960
to cost limitations

00:19:52,720 --> 00:19:57,600
cloud provider limitations and sometimes

00:19:54,960 --> 00:20:00,160
even technology limitations

00:19:57,600 --> 00:20:00,880
also migrating to a larger server may

00:20:00,160 --> 00:20:03,760
require

00:20:00,880 --> 00:20:05,360
application downtime all right let's

00:20:03,760 --> 00:20:07,280
take another example

00:20:05,360 --> 00:20:08,400
let's say tom has an app for his

00:20:07,280 --> 00:20:11,600
restaurant called

00:20:08,400 --> 00:20:13,600
tom's bistro he uses a document database

00:20:11,600 --> 00:20:15,520
behind the scenes

00:20:13,600 --> 00:20:17,840
after a feature in the pawnee journal

00:20:15,520 --> 00:20:20,400
his restaurant surges in popularity and

00:20:17,840 --> 00:20:22,400
he needs more space for his database

00:20:20,400 --> 00:20:24,159
since tom is using a document database

00:20:22,400 --> 00:20:27,440
he has the flexibility to scale

00:20:24,159 --> 00:20:29,120
horizontally through sharding

00:20:27,440 --> 00:20:31,760
sharding is a method for distributing

00:20:29,120 --> 00:20:33,600
data across multiple servers

00:20:31,760 --> 00:20:35,440
when his database exceeds the capacity

00:20:33,600 --> 00:20:37,520
of its current server

00:20:35,440 --> 00:20:39,360
he can be in sharding and split it over

00:20:37,520 --> 00:20:40,960
two servers

00:20:39,360 --> 00:20:43,039
when the shelter in place orders hit

00:20:40,960 --> 00:20:44,080
pawn e and everyone has to order food

00:20:43,039 --> 00:20:47,679
online

00:20:44,080 --> 00:20:49,440
tom can continue to add more servers

00:20:47,679 --> 00:20:52,159
the advantage is that these new servers

00:20:49,440 --> 00:20:55,280
don't need to be big expensive machines

00:20:52,159 --> 00:20:58,559
they can be cheaper commodity hardware

00:20:55,280 --> 00:21:00,840
plus no downtime is required

00:20:58,559 --> 00:21:03,120
so with document databases you can scale

00:21:00,840 --> 00:21:03,840
cheaper as the size of your database

00:21:03,120 --> 00:21:07,440
grows

00:21:03,840 --> 00:21:07,440
you can scale horizontally

00:21:08,640 --> 00:21:13,760
all right query faster your queries will

00:21:12,080 --> 00:21:15,280
typically be faster with document

00:21:13,760 --> 00:21:18,799
databases

00:21:15,280 --> 00:21:20,640
let's examine why even in our simple

00:21:18,799 --> 00:21:22,720
example that we worked through earlier

00:21:20,640 --> 00:21:24,320
where we modeled leslie's data in both

00:21:22,720 --> 00:21:26,240
tables and documents

00:21:24,320 --> 00:21:28,400
we saw that her information was spread

00:21:26,240 --> 00:21:30,000
across three tables

00:21:28,400 --> 00:21:31,600
whenever we want to query for leslie's

00:21:30,000 --> 00:21:33,760
information we're gonna have to join

00:21:31,600 --> 00:21:35,600
those three tables together

00:21:33,760 --> 00:21:37,360
now on these three small tables the join

00:21:35,600 --> 00:21:39,200
is going to be very fast

00:21:37,360 --> 00:21:41,520
however as the tables grow when our

00:21:39,200 --> 00:21:43,520
queries become more complex

00:21:41,520 --> 00:21:45,280
joining tables together can become very

00:21:43,520 --> 00:21:47,520
expensive

00:21:45,280 --> 00:21:49,200
so recall that rule of thumb i talked

00:21:47,520 --> 00:21:51,360
about earlier

00:21:49,200 --> 00:21:53,120
data that is accessed together should be

00:21:51,360 --> 00:21:55,280
stored together

00:21:53,120 --> 00:21:57,440
when you follow this rule of thumb most

00:21:55,280 --> 00:21:58,400
queries will not require you to join any

00:21:57,440 --> 00:22:01,440
day together

00:21:58,400 --> 00:22:02,559
any data together continuing with our

00:22:01,440 --> 00:22:03,840
earlier example

00:22:02,559 --> 00:22:06,000
if we want to retrieve leslie's

00:22:03,840 --> 00:22:07,919
information from a document database

00:22:06,000 --> 00:22:10,480
we can simply query for a single

00:22:07,919 --> 00:22:14,000
document in the user's collection

00:22:10,480 --> 00:22:15,840
as a result our query will be very fast

00:22:14,000 --> 00:22:17,840
as our collections grow larger we don't

00:22:15,840 --> 00:22:20,000
have to worry about queries slowing down

00:22:17,840 --> 00:22:21,360
as long as we are using indexes and

00:22:20,000 --> 00:22:23,840
continuing following

00:22:21,360 --> 00:22:24,480
that rule of thumb data that is accessed

00:22:23,840 --> 00:22:27,840
together

00:22:24,480 --> 00:22:30,960
should be stored together

00:22:27,840 --> 00:22:31,679
all right pivot easier requirements

00:22:30,960 --> 00:22:33,120
change

00:22:31,679 --> 00:22:35,039
it's a regular part of the software

00:22:33,120 --> 00:22:36,720
development life cycle

00:22:35,039 --> 00:22:38,840
sometimes the changes are simple and

00:22:36,720 --> 00:22:40,080
require only a few tweaks to the user

00:22:38,840 --> 00:22:42,799
interface

00:22:40,080 --> 00:22:45,440
but sometimes changes go all the way

00:22:42,799 --> 00:22:47,120
down to the database

00:22:45,440 --> 00:22:48,799
let's think back to our earlier example

00:22:47,120 --> 00:22:50,480
where we needed to update our database

00:22:48,799 --> 00:22:51,919
to store information about lauren's

00:22:50,480 --> 00:22:53,360
school

00:22:51,919 --> 00:22:55,200
to add a new school column in our

00:22:53,360 --> 00:22:57,679
relational database we're going to have

00:22:55,200 --> 00:22:59,440
to alter the users table

00:22:57,679 --> 00:23:01,120
executing the alter table command could

00:22:59,440 --> 00:23:03,600
take a couple of hours depending on how

00:23:01,120 --> 00:23:05,280
much data is in the table

00:23:03,600 --> 00:23:06,960
the performance of our application could

00:23:05,280 --> 00:23:09,520
be decreased while the table is being

00:23:06,960 --> 00:23:10,240
altered and we may need to schedule down

00:23:09,520 --> 00:23:13,600
time for

00:23:10,240 --> 00:23:15,200
our application now let's examine how we

00:23:13,600 --> 00:23:17,039
can do something similar in document

00:23:15,200 --> 00:23:19,120
databases

00:23:17,039 --> 00:23:20,799
when our requirements change and we need

00:23:19,120 --> 00:23:21,360
to begin storing the name of a user's

00:23:20,799 --> 00:23:24,159
school

00:23:21,360 --> 00:23:25,840
in a user document we can simply begin

00:23:24,159 --> 00:23:28,080
doing so

00:23:25,840 --> 00:23:31,200
we can choose if and when to update

00:23:28,080 --> 00:23:33,280
existing documents in the collection

00:23:31,200 --> 00:23:34,799
if we had implemented schema validation

00:23:33,280 --> 00:23:36,080
we would have the option of applying the

00:23:34,799 --> 00:23:38,640
validation to all

00:23:36,080 --> 00:23:40,400
inserts and updates or only to inserts

00:23:38,640 --> 00:23:42,799
and updates to documents that already

00:23:40,400 --> 00:23:44,080
meet the schema requirements

00:23:42,799 --> 00:23:46,320
we would also have the choice of

00:23:44,080 --> 00:23:49,120
throwing an error or a warning if a

00:23:46,320 --> 00:23:51,440
validation rule is violated

00:23:49,120 --> 00:23:53,279
with document databases you can easily

00:23:51,440 --> 00:23:56,559
change the shape of your data

00:23:53,279 --> 00:23:56,559
as your app evolves

00:23:56,880 --> 00:24:02,880
all right finally you can program faster

00:24:01,120 --> 00:24:05,679
now to be honest with you this advantage

00:24:02,880 --> 00:24:07,279
is one of the biggest surprises to me

00:24:05,679 --> 00:24:09,760
i figured that it didn't really matter

00:24:07,279 --> 00:24:11,440
what you used as your backend database

00:24:09,760 --> 00:24:13,840
the code that interacts with it would be

00:24:11,440 --> 00:24:16,720
basically the same

00:24:13,840 --> 00:24:18,880
i was wrong documents mapped data

00:24:16,720 --> 00:24:20,320
structures in most popular programming

00:24:18,880 --> 00:24:22,320
languages

00:24:20,320 --> 00:24:24,159
now this sounds like such a simple thing

00:24:22,320 --> 00:24:26,000
but it can make a huge difference when

00:24:24,159 --> 00:24:28,080
you're writing code

00:24:26,000 --> 00:24:29,679
a friend encouraged me to test this out

00:24:28,080 --> 00:24:31,520
so i did

00:24:29,679 --> 00:24:34,159
i implemented the code to retrieve and

00:24:31,520 --> 00:24:36,000
update user profile information

00:24:34,159 --> 00:24:37,679
now my code has some simplifications in

00:24:36,000 --> 00:24:39,520
it to enable me to focus on the

00:24:37,679 --> 00:24:42,159
interactions with the database

00:24:39,520 --> 00:24:44,159
rather than the user interface i also

00:24:42,159 --> 00:24:47,520
limited the user profile information to

00:24:44,159 --> 00:24:50,000
just contact information and hobbies

00:24:47,520 --> 00:24:52,559
so let's walk through my implementation

00:24:50,000 --> 00:24:56,000
i used mysql from my relational database

00:24:52,559 --> 00:24:58,240
and mongodb as my document database

00:24:56,000 --> 00:24:59,919
now i wrote the code in python but don't

00:24:58,240 --> 00:25:02,400
worry if you're not familiar with python

00:24:59,919 --> 00:25:04,000
i'll walk you through it step by step

00:25:02,400 --> 00:25:05,760
the concepts will be applicable no

00:25:04,000 --> 00:25:08,240
matter what your programming language of

00:25:05,760 --> 00:25:09,919
choice is

00:25:08,240 --> 00:25:11,520
so before i show you the code let's do a

00:25:09,919 --> 00:25:13,440
quick refresh of the data we're going to

00:25:11,520 --> 00:25:15,679
retrieve and update

00:25:13,440 --> 00:25:17,840
on the left we have a table for users

00:25:15,679 --> 00:25:19,600
and a table for hobbies

00:25:17,840 --> 00:25:21,520
on the right we have a document for our

00:25:19,600 --> 00:25:22,320
user that contains both contact

00:25:21,520 --> 00:25:25,039
information

00:25:22,320 --> 00:25:25,039
and hobbies

00:25:25,520 --> 00:25:29,039
so let's begin with that typical top of

00:25:27,360 --> 00:25:29,840
the file stuff we're going to import

00:25:29,039 --> 00:25:31,840
what we need

00:25:29,840 --> 00:25:33,120
connect the database and declare our

00:25:31,840 --> 00:25:35,039
variables

00:25:33,120 --> 00:25:36,320
i'm going to simplify things by hard

00:25:35,039 --> 00:25:38,320
coding the user id

00:25:36,320 --> 00:25:39,440
of the user whose profile we will be

00:25:38,320 --> 00:25:40,960
retrieving

00:25:39,440 --> 00:25:43,360
rather than pulling it dynamically from

00:25:40,960 --> 00:25:45,440
the front end code

00:25:43,360 --> 00:25:46,880
now if we look at the mongodb code it's

00:25:45,440 --> 00:25:48,880
basically the same

00:25:46,880 --> 00:25:52,000
importing connecting and setting the new

00:25:48,880 --> 00:25:52,000
user id variable

00:25:52,720 --> 00:25:56,240
so now that we have our database

00:25:54,080 --> 00:25:59,360
connections ready let's use them to

00:25:56,240 --> 00:26:01,520
retrieve our user profile information

00:25:59,360 --> 00:26:03,760
we'll store the profile information in a

00:26:01,520 --> 00:26:05,440
python dictionary

00:26:03,760 --> 00:26:07,279
dictionaries are a common data structure

00:26:05,440 --> 00:26:08,960
in python and provide an easy way to

00:26:07,279 --> 00:26:10,559
work with your data

00:26:08,960 --> 00:26:12,880
so let's begin by implementing the code

00:26:10,559 --> 00:26:14,480
for mysql

00:26:12,880 --> 00:26:16,159
since the user profile information is

00:26:14,480 --> 00:26:18,159
spread across the users table

00:26:16,159 --> 00:26:19,760
and the hobbies table we need to join

00:26:18,159 --> 00:26:22,559
them in our query

00:26:19,760 --> 00:26:23,200
so we'll say select everything from

00:26:22,559 --> 00:26:26,400
users

00:26:23,200 --> 00:26:29,600
left join hobbies we can use prepared

00:26:26,400 --> 00:26:31,120
statements to ensure our data stays safe

00:26:29,600 --> 00:26:33,520
we'll set the values in our prepared

00:26:31,120 --> 00:26:36,559
statement execute the query

00:26:33,520 --> 00:26:38,080
and fetch our result

00:26:36,559 --> 00:26:40,159
because we joined the users in the

00:26:38,080 --> 00:26:43,360
hobbies table we have a result for

00:26:40,159 --> 00:26:45,039
each hobby this user has to retrieve all

00:26:43,360 --> 00:26:46,320
the hobbies we need to iterate the

00:26:45,039 --> 00:26:48,400
cursor

00:26:46,320 --> 00:26:49,919
we'll append each hobby to a new hobbies

00:26:48,400 --> 00:26:51,440
array and then

00:26:49,919 --> 00:26:53,440
add the hobbies array to our user

00:26:51,440 --> 00:26:54,720
dictionary

00:26:53,440 --> 00:26:57,200
all right let's implement that same

00:26:54,720 --> 00:26:58,960
functionality from mongodb

00:26:57,200 --> 00:27:00,880
since we stored all of the user profile

00:26:58,960 --> 00:27:03,840
information in the user document

00:27:00,880 --> 00:27:06,000
we don't have to do any joins we can

00:27:03,840 --> 00:27:08,960
simply retrieve a single document

00:27:06,000 --> 00:27:09,600
in our collection here is where that big

00:27:08,960 --> 00:27:11,520
advantage

00:27:09,600 --> 00:27:13,840
that documents mapped to data structures

00:27:11,520 --> 00:27:16,880
in most popular programming language

00:27:13,840 --> 00:27:18,880
comes in i don't have to do any work to

00:27:16,880 --> 00:27:20,640
get my data into an easy to work with

00:27:18,880 --> 00:27:22,559
python dictionary

00:27:20,640 --> 00:27:24,880
i get all of the results in a python

00:27:22,559 --> 00:27:26,240
dictionary automatically

00:27:24,880 --> 00:27:29,760
and i don't need to manipulate the

00:27:26,240 --> 00:27:29,760
results i'm done

00:27:30,799 --> 00:27:35,520
our user dictionaries are now pretty

00:27:32,799 --> 00:27:37,039
similar in both pieces of code

00:27:35,520 --> 00:27:38,960
the one exception is how we're storing

00:27:37,039 --> 00:27:41,120
location data but this is really a

00:27:38,960 --> 00:27:42,399
pretty minor difference

00:27:41,120 --> 00:27:44,559
now that we've retrieved the user's

00:27:42,399 --> 00:27:45,679
profile information we'd likely send

00:27:44,559 --> 00:27:48,399
that information back

00:27:45,679 --> 00:27:49,760
up the stack to the front-end ui code

00:27:48,399 --> 00:27:52,159
when leslie views her profile

00:27:49,760 --> 00:27:53,919
information in our application

00:27:52,159 --> 00:27:55,840
she may discover she needs to update her

00:27:53,919 --> 00:27:57,840
profile information

00:27:55,840 --> 00:28:00,000
the front-end ui code would send that

00:27:57,840 --> 00:28:00,640
updated information in a python

00:28:00,000 --> 00:28:04,480
dictionary

00:28:00,640 --> 00:28:04,480
to the python files we've been writing

00:28:05,279 --> 00:28:08,320
so to simulate leslie updating your

00:28:06,880 --> 00:28:10,399
profile information i'm just going to

00:28:08,320 --> 00:28:14,480
manually update the python dictionary

00:28:10,399 --> 00:28:16,240
myself for both mysql and mongodb

00:28:14,480 --> 00:28:17,760
now these updates are basically the same

00:28:16,240 --> 00:28:20,880
with the exception of how the location

00:28:17,760 --> 00:28:20,880
data is being stored

00:28:22,640 --> 00:28:26,080
all right so now that our user

00:28:23,600 --> 00:28:28,799
dictionary is updated let's push that

00:28:26,080 --> 00:28:31,440
updated information down to our database

00:28:28,799 --> 00:28:32,880
so let's begin with mysql

00:28:31,440 --> 00:28:34,960
first we need to update the information

00:28:32,880 --> 00:28:38,240
that is stored in the users table

00:28:34,960 --> 00:28:39,840
we'll say update users set first name

00:28:38,240 --> 00:28:41,840
equal to this string last name equal to

00:28:39,840 --> 00:28:44,080
this string cell equivalent string

00:28:41,840 --> 00:28:46,240
all the way through then we'll set the

00:28:44,080 --> 00:28:49,360
values of all those strings

00:28:46,240 --> 00:28:52,399
is this complicated no not really

00:28:49,360 --> 00:28:53,440
is this error prone yep

00:28:52,399 --> 00:28:55,840
you have to make sure you get every

00:28:53,440 --> 00:28:56,720
string in just the right spot now to be

00:28:55,840 --> 00:28:58,880
honest with you

00:28:56,720 --> 00:28:59,840
i did not unit test this code i know i

00:28:58,880 --> 00:29:01,520
know

00:28:59,840 --> 00:29:03,039
so it's possible i've made a mistake

00:29:01,520 --> 00:29:05,279
without realizing it

00:29:03,039 --> 00:29:06,720
this is a pretty simple example so i

00:29:05,279 --> 00:29:09,279
probably got it right

00:29:06,720 --> 00:29:10,840
but sql queries can get really long so

00:29:09,279 --> 00:29:13,360
you can imagine this getting much more

00:29:10,840 --> 00:29:16,080
complicated

00:29:13,360 --> 00:29:18,000
next we need to update our hobbies for

00:29:16,080 --> 00:29:19,520
simplicity we'll delete any existing

00:29:18,000 --> 00:29:20,399
hobbies in the hobbies table for this

00:29:19,520 --> 00:29:22,159
user

00:29:20,399 --> 00:29:24,880
and then we'll insert the new hobbies

00:29:22,159 --> 00:29:26,720
into the hobbies table

00:29:24,880 --> 00:29:29,200
now let's update the user profile

00:29:26,720 --> 00:29:30,880
information in mongodb

00:29:29,200 --> 00:29:32,799
since the user's profile information is

00:29:30,880 --> 00:29:35,360
stored in a single document

00:29:32,799 --> 00:29:36,799
we only have to do a single update so

00:29:35,360 --> 00:29:38,720
once again we're going to benefit from

00:29:36,799 --> 00:29:41,200
documents mapping to data structures in

00:29:38,720 --> 00:29:43,520
most popular programming languages

00:29:41,200 --> 00:29:44,320
we can send our user python dictionary

00:29:43,520 --> 00:29:47,679
when we call

00:29:44,320 --> 00:29:50,320
update 1 which significantly simplifies

00:29:47,679 --> 00:29:50,320
our code

00:29:52,480 --> 00:29:55,679
in this example we write we wrote 27

00:29:54,880 --> 00:29:58,399
lines of code

00:29:55,679 --> 00:29:59,840
to interact with our data in mysql and

00:29:58,399 --> 00:30:02,080
two lines of code to interact with our

00:29:59,840 --> 00:30:03,760
data in mongodb

00:30:02,080 --> 00:30:05,440
now fewer lines of code does not always

00:30:03,760 --> 00:30:07,279
indicate better code

00:30:05,440 --> 00:30:08,640
but in this case we can probably agree

00:30:07,279 --> 00:30:11,279
that fewer lines of code

00:30:08,640 --> 00:30:13,520
will likely lead to easier maintenance

00:30:11,279 --> 00:30:15,440
and fewer bugs

00:30:13,520 --> 00:30:16,960
this example was relatively simple with

00:30:15,440 --> 00:30:19,039
small queries

00:30:16,960 --> 00:30:22,960
imagine how much bigger the differences

00:30:19,039 --> 00:30:24,720
would be for larger more complex queries

00:30:22,960 --> 00:30:26,640
documents mapping to data structures in

00:30:24,720 --> 00:30:29,039
most popular programming languages

00:30:26,640 --> 00:30:30,159
can be a huge advantage in terms of time

00:30:29,039 --> 00:30:34,080
to write

00:30:30,159 --> 00:30:34,080
debug and maintain code

00:30:34,640 --> 00:30:38,000
so is it worth changing your mindset and

00:30:36,559 --> 00:30:39,360
learning how to work with a document

00:30:38,000 --> 00:30:42,480
database

00:30:39,360 --> 00:30:43,039
i think so with a document database you

00:30:42,480 --> 00:30:46,320
can

00:30:43,039 --> 00:30:51,679
scale cheaper query faster

00:30:46,320 --> 00:30:53,279
pivot easier and program faster

00:30:51,679 --> 00:30:55,679
all right let's move on to our final

00:30:53,279 --> 00:30:57,440
section let's talk about the three key

00:30:55,679 --> 00:31:00,799
ways to change your mindset

00:30:57,440 --> 00:31:02,480
as you move from tables to documents

00:31:00,799 --> 00:31:03,840
people who pick up a document database

00:31:02,480 --> 00:31:04,399
and try to use it as a relational

00:31:03,840 --> 00:31:06,559
database

00:31:04,399 --> 00:31:07,919
are the ones who typically struggle and

00:31:06,559 --> 00:31:09,840
fail

00:31:07,919 --> 00:31:12,159
you can't keep doing things in the same

00:31:09,840 --> 00:31:14,159
way so let's talk about three key ways

00:31:12,159 --> 00:31:18,480
to change your mindset

00:31:14,159 --> 00:31:20,240
first up embrace document diversity

00:31:18,480 --> 00:31:21,679
let's think back to when we modeled

00:31:20,240 --> 00:31:24,480
documents for leslie

00:31:21,679 --> 00:31:25,760
ron and lauren we saw that not all

00:31:24,480 --> 00:31:28,720
documents in a collection

00:31:25,760 --> 00:31:30,159
need to have the same fields now for

00:31:28,720 --> 00:31:32,000
those of us with relational database

00:31:30,159 --> 00:31:34,000
backgrounds this is going to feel

00:31:32,000 --> 00:31:36,080
really uncomfortable and probably a

00:31:34,000 --> 00:31:39,120
little odd at first

00:31:36,080 --> 00:31:41,760
i promise it will be okay

00:31:39,120 --> 00:31:44,159
embrace document diversity it gives us

00:31:41,760 --> 00:31:45,519
so much flexibility and power to model

00:31:44,159 --> 00:31:47,440
our data

00:31:45,519 --> 00:31:49,679
in fact there's a schema design pattern

00:31:47,440 --> 00:31:50,640
that specifically focuses on documents

00:31:49,679 --> 00:31:52,960
not having the same

00:31:50,640 --> 00:31:53,919
fields it's called the polymorphic

00:31:52,960 --> 00:31:55,679
pattern

00:31:53,919 --> 00:31:56,960
we use the polymorphic pattern when

00:31:55,679 --> 00:31:59,519
documents in a collection

00:31:56,960 --> 00:32:01,360
are of similar but not identical

00:31:59,519 --> 00:32:04,720
structures

00:32:01,360 --> 00:32:05,600
so embrace document diversity resist the

00:32:04,720 --> 00:32:07,200
urge to force

00:32:05,600 --> 00:32:09,200
all of your documents to have identical

00:32:07,200 --> 00:32:11,679
structures just because it's what you've

00:32:09,200 --> 00:32:11,679
always done

00:32:11,760 --> 00:32:15,840
second way to change your mindset data

00:32:14,240 --> 00:32:17,519
that is accessed together should be

00:32:15,840 --> 00:32:19,519
stored together

00:32:17,519 --> 00:32:22,240
we've probably all heard over and over

00:32:19,519 --> 00:32:25,039
that you should normalize your data

00:32:22,240 --> 00:32:26,880
but why historically there are a couple

00:32:25,039 --> 00:32:28,399
different reasons for this

00:32:26,880 --> 00:32:30,240
one of them is that when relational

00:32:28,399 --> 00:32:32,720
databases became popular

00:32:30,240 --> 00:32:34,559
disk space was extremely expensive

00:32:32,720 --> 00:32:35,600
financially it made sense to reduce data

00:32:34,559 --> 00:32:38,799
duplication

00:32:35,600 --> 00:32:39,519
and save disk space as you can see from

00:32:38,799 --> 00:32:41,200
this chart

00:32:39,519 --> 00:32:43,840
and you probably know from buying flash

00:32:41,200 --> 00:32:45,679
drives if you even buy those anymore

00:32:43,840 --> 00:32:46,880
the price of storage has dramatically

00:32:45,679 --> 00:32:49,039
decreased

00:32:46,880 --> 00:32:51,840
our phones tablets laptops and flash

00:32:49,039 --> 00:32:53,840
drives have more storage capacity today

00:32:51,840 --> 00:32:56,799
than they did even five to ten years ago

00:32:53,840 --> 00:32:58,240
for a fraction of the cost

00:32:56,799 --> 00:32:59,840
when was the last time you deleted a

00:32:58,240 --> 00:33:02,080
photo

00:32:59,840 --> 00:33:04,080
i mean i can't even remember when i did

00:33:02,080 --> 00:33:06,960
i keep even the really horribly

00:33:04,080 --> 00:33:07,200
unflattering photos and i currently back

00:33:06,960 --> 00:33:08,960
up

00:33:07,200 --> 00:33:11,760
all my photos on two external hard

00:33:08,960 --> 00:33:15,200
drives and multiple cloud services

00:33:11,760 --> 00:33:17,360
storage is super cheap

00:33:15,200 --> 00:33:19,039
storage has become so cheap that we've

00:33:17,360 --> 00:33:20,399
seen a shift in the cost of software

00:33:19,039 --> 00:33:22,960
development

00:33:20,399 --> 00:33:24,399
30 to 40 years ago storage was a huge

00:33:22,960 --> 00:33:27,200
cost in software development

00:33:24,399 --> 00:33:27,840
and developers were relatively cheap

00:33:27,200 --> 00:33:30,399
today

00:33:27,840 --> 00:33:32,399
the costs have flipped storage is a

00:33:30,399 --> 00:33:35,600
small cost of software development

00:33:32,399 --> 00:33:37,039
and developers are expensive instead of

00:33:35,600 --> 00:33:39,919
optimizing for storage

00:33:37,039 --> 00:33:41,919
we need to optimize for developers time

00:33:39,919 --> 00:33:44,720
and productivity

00:33:41,919 --> 00:33:46,159
now as a developer i like this shift i

00:33:44,720 --> 00:33:48,320
want to be able to focus on

00:33:46,159 --> 00:33:49,440
implementing business logic and iterate

00:33:48,320 --> 00:33:50,799
quickly

00:33:49,440 --> 00:33:53,039
those are the things that matter to the

00:33:50,799 --> 00:33:54,240
business and move developers careers

00:33:53,039 --> 00:33:55,760
forward

00:33:54,240 --> 00:33:57,760
i don't want to be dragged down by data

00:33:55,760 --> 00:33:59,440
storage specifics

00:33:57,760 --> 00:34:01,360
think back to the early example where i

00:33:59,440 --> 00:34:03,279
coded retrieving and updating a user's

00:34:01,360 --> 00:34:05,279
profile information

00:34:03,279 --> 00:34:07,279
even in that simple example i was able

00:34:05,279 --> 00:34:10,480
to write fewer lines of code and move

00:34:07,279 --> 00:34:13,839
quicker when i used a document database

00:34:10,480 --> 00:34:14,879
so leverage embedding consider how you

00:34:13,839 --> 00:34:18,320
can use

00:34:14,879 --> 00:34:20,560
objects arrays

00:34:18,320 --> 00:34:22,000
and arrays of objects to store your data

00:34:20,560 --> 00:34:24,079
together

00:34:22,000 --> 00:34:25,200
resist that temptation to break up your

00:34:24,079 --> 00:34:27,040
data

00:34:25,200 --> 00:34:28,800
data that is accessed together should be

00:34:27,040 --> 00:34:30,560
stored together

00:34:28,800 --> 00:34:33,280
if you end up repeating data in your

00:34:30,560 --> 00:34:34,960
database that's okay

00:34:33,280 --> 00:34:37,599
especially if you won't be updating it

00:34:34,960 --> 00:34:37,599
very often

00:34:37,760 --> 00:34:40,800
all right last way to change your

00:34:39,040 --> 00:34:43,599
mindset tread

00:34:40,800 --> 00:34:45,280
carefully with transactions some

00:34:43,599 --> 00:34:46,320
document databases support acid

00:34:45,280 --> 00:34:49,440
transactions

00:34:46,320 --> 00:34:50,639
while others don't but here's the thing

00:34:49,440 --> 00:34:52,879
if you're modeling your data for the

00:34:50,639 --> 00:34:55,040
document model you're probably not going

00:34:52,879 --> 00:34:58,079
to need a transaction

00:34:55,040 --> 00:34:59,839
in fact relying on transactions is a bad

00:34:58,079 --> 00:35:02,400
design smell

00:34:59,839 --> 00:35:04,800
okay why is that well this really builds

00:35:02,400 --> 00:35:06,880
on our first two points in this section

00:35:04,800 --> 00:35:08,320
first not all documents need to have the

00:35:06,880 --> 00:35:09,839
same fields

00:35:08,320 --> 00:35:11,680
perhaps you're breaking up data between

00:35:09,839 --> 00:35:13,680
multiple collections because it's not

00:35:11,680 --> 00:35:14,960
all of identical structure

00:35:13,680 --> 00:35:16,880
if that's the only reason you've broken

00:35:14,960 --> 00:35:19,359
the data up you can probably put it back

00:35:16,880 --> 00:35:21,680
together in a single collection

00:35:19,359 --> 00:35:23,440
second data that is accessed together

00:35:21,680 --> 00:35:25,280
should be stored together

00:35:23,440 --> 00:35:28,320
if you're following this principle you

00:35:25,280 --> 00:35:30,960
actually won't need to use transactions

00:35:28,320 --> 00:35:32,320
some use cases call for transactions

00:35:30,960 --> 00:35:33,920
most do not

00:35:32,320 --> 00:35:36,000
if you find yourself frequently using

00:35:33,920 --> 00:35:36,480
transactions take a look at your data

00:35:36,000 --> 00:35:38,320
model

00:35:36,480 --> 00:35:40,160
and consider if you need to restructure

00:35:38,320 --> 00:35:41,839
it

00:35:40,160 --> 00:35:43,920
all right so to summarize the three key

00:35:41,839 --> 00:35:46,400
ways you need to change your mindset

00:35:43,920 --> 00:35:48,400
embrace document diversity

00:35:46,400 --> 00:35:50,320
data that is accessed together should be

00:35:48,400 --> 00:35:54,320
stored together

00:35:50,320 --> 00:35:54,320
tread carefully with transactions

00:35:54,480 --> 00:35:57,839
all right let's wrap up this

00:35:55,599 --> 00:35:59,119
presentation today we went on a mental

00:35:57,839 --> 00:36:02,640
journey from tables

00:35:59,119 --> 00:36:05,280
to documents we began by mapping terms

00:36:02,640 --> 00:36:06,960
and concepts from tables to documents

00:36:05,280 --> 00:36:08,560
the three that are most important are

00:36:06,960 --> 00:36:11,119
those first three

00:36:08,560 --> 00:36:12,400
rows mapped to documents columns mapped

00:36:11,119 --> 00:36:16,079
to fields

00:36:12,400 --> 00:36:16,079
tables map to collections

00:36:16,640 --> 00:36:21,200
then we talked about the four major

00:36:18,480 --> 00:36:22,880
advantages of documents

00:36:21,200 --> 00:36:25,040
you can scale cheaper because you can

00:36:22,880 --> 00:36:26,880
scale horizontally

00:36:25,040 --> 00:36:28,640
you can query faster because you aren't

00:36:26,880 --> 00:36:30,560
having to do expensive joins to bring

00:36:28,640 --> 00:36:32,400
your data together

00:36:30,560 --> 00:36:34,320
you can pivot easier because you have a

00:36:32,400 --> 00:36:36,000
flexible schema

00:36:34,320 --> 00:36:38,320
and finally you can program faster

00:36:36,000 --> 00:36:41,599
because documents map to objects in most

00:36:38,320 --> 00:36:43,119
popular programming languages

00:36:41,599 --> 00:36:45,680
alright we wrap things up with the three

00:36:43,119 --> 00:36:48,400
key ways you need to change your mindset

00:36:45,680 --> 00:36:50,000
first embrace document diversity not all

00:36:48,400 --> 00:36:50,480
of your documents need to be the same

00:36:50,000 --> 00:36:53,520
shape

00:36:50,480 --> 00:36:55,599
and that's perfectly okay

00:36:53,520 --> 00:36:58,000
second data that is accessed together

00:36:55,599 --> 00:37:00,240
should be stored together

00:36:58,000 --> 00:37:01,520
and third tread carefully with

00:37:00,240 --> 00:37:03,119
transactions

00:37:01,520 --> 00:37:04,880
relying on transactions when you're

00:37:03,119 --> 00:37:08,240
using a document database

00:37:04,880 --> 00:37:10,000
is a bad design smell

00:37:08,240 --> 00:37:12,480
so if i just sum this presentation up in

00:37:10,000 --> 00:37:14,480
one idea i would say this

00:37:12,480 --> 00:37:16,079
don't be ron swanson i mean in this

00:37:14,480 --> 00:37:18,320
particular case because ron swanson is

00:37:16,079 --> 00:37:21,280
amazing in so many other ways

00:37:18,320 --> 00:37:23,200
but don't be ron swanson change your

00:37:21,280 --> 00:37:37,839
mindset and get the full value of

00:37:23,200 --> 00:37:37,839
document databases

00:37:44,480 --> 00:37:46,560

YouTube URL: https://www.youtube.com/watch?v=IkjgiWYmUTI


