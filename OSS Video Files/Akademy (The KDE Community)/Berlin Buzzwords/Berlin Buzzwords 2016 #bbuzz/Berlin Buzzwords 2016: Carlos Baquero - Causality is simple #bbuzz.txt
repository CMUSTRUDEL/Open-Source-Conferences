Title: Berlin Buzzwords 2016: Carlos Baquero - Causality is simple #bbuzz
Publication date: 2016-06-13
Playlist: Berlin Buzzwords 2016 #bbuzz
Description: 
	Causality is an essential component of how we make sense of the physical world, and of our relations to other humans. If I put a cup on the table, and look back at it, I expect it to be there. I also expect to get a reply to my postcards, after I send them, and not before.  

These days hardly any service can claim not to have some form of distributed algorithm at its core. In a distributed scenario, if we are not careful, it is very easy to break the causal sense of things. In a key-value store my writes can be directed to a replica, and my subsequent reads served from an outdated one --- my cup might not be there when I look back. Message dissemination middleware might not always provide the ordering I expect --- I might receive some replies, before their leading questions. 

Luckily, most of these problems were already there 30 years ago, although in a much smaller scale, and lots of techniques have been developed to keep track of causality and make sense of the complex interactions in modern systems. However developers often look at techniques such as as replica synchronization with version vectors, or causal broadcasting algorithms, as black boxes; or as complex sets of rules that have to be followed and not questioned. 

This talk will focus on bringing back the intuition on causality, and show that keeping in mind some simple concepts, allows to understand how version vectors and vector clocks work, and were they differ, and how to use more sophisticated mechanisms to handle millions of concurrent clients in modern distributed data stores.

Read more:
https://2016.berlinbuzzwords.de/session/causality-simple

About Carlos Baquero:
https://2016.berlinbuzzwords.de/users/carlos-baquero

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:02,300 --> 00:00:10,080
so let's start this talk thank you for

00:00:04,980 --> 00:00:13,740
attending so I'm I'm a researcher and I

00:00:10,080 --> 00:00:16,170
teach distributed systems mainly in Ming

00:00:13,740 --> 00:00:18,029
University and we do research in the

00:00:16,170 --> 00:00:21,000
context of this lab that has lab the

00:00:18,029 --> 00:00:23,130
high assurance software lab and so my

00:00:21,000 --> 00:00:26,130
proposal is to to try to explain you

00:00:23,130 --> 00:00:28,019
that causality is simple and I've chosen

00:00:26,130 --> 00:00:29,910
this title but when I was doing the

00:00:28,019 --> 00:00:32,910
slides and looking at the content I had

00:00:29,910 --> 00:00:34,950
to do a little rewrite okay so it's

00:00:32,910 --> 00:00:37,140
going to be moderately simple but I'll

00:00:34,950 --> 00:00:41,540
try to make it as intuitive as possible

00:00:37,140 --> 00:00:46,289
cut that's the overall goal of the talk

00:00:41,540 --> 00:00:50,449
so let's let's start with that and why

00:00:46,289 --> 00:00:54,329
should we care about causality nowadays

00:00:50,449 --> 00:00:57,120
basically we should care because it's

00:00:54,329 --> 00:00:59,520
very hard nowadays to program and not be

00:00:57,120 --> 00:01:01,800
programming in the context of this UT

00:00:59,520 --> 00:01:05,100
System ok so what used to be a

00:01:01,800 --> 00:01:07,290
playground for academic researchers that

00:01:05,100 --> 00:01:09,420
were doing very nice algorithms and

00:01:07,290 --> 00:01:13,229
using nice math to impress each other

00:01:09,420 --> 00:01:15,930
now some of these things are really used

00:01:13,229 --> 00:01:17,970
nowadays and when they are not used some

00:01:15,930 --> 00:01:21,180
anomalies occur in the systems that we

00:01:17,970 --> 00:01:23,630
run okay so it's important to to try to

00:01:21,180 --> 00:01:25,710
work with them or at least use the

00:01:23,630 --> 00:01:29,939
libraries that implement these churches

00:01:25,710 --> 00:01:33,840
and know when we need to use them so

00:01:29,939 --> 00:01:34,860
let's let's get into that some of the

00:01:33,840 --> 00:01:37,890
anomalies that you might have

00:01:34,860 --> 00:01:40,259
experienced have some examples you're so

00:01:37,890 --> 00:01:42,210
suppose you didn't well your sound of

00:01:40,259 --> 00:01:45,420
the son of your telephone is probably

00:01:42,210 --> 00:01:47,399
off but you can feel a buzz so you get a

00:01:45,420 --> 00:01:49,229
notification from Twitter that there is

00:01:47,399 --> 00:01:52,020
a new interesting tweet that you should

00:01:49,229 --> 00:01:54,479
go and check and you could go and check

00:01:52,020 --> 00:01:56,430
it but it's not there yet so something

00:01:54,479 --> 00:01:58,229
strange happened what happened here is

00:01:56,430 --> 00:02:00,810
that we had two different notification

00:01:58,229 --> 00:02:02,850
channels one did a notification that

00:02:00,810 --> 00:02:06,090
something was available but it's still

00:02:02,850 --> 00:02:08,580
not cached locally on your or your local

00:02:06,090 --> 00:02:11,190
content provider for the application so

00:02:08,580 --> 00:02:12,930
you get a Miss when you go and fetch the

00:02:11,190 --> 00:02:13,650
tweet that you are interested in so this

00:02:12,930 --> 00:02:16,010
is something

00:02:13,650 --> 00:02:18,720
that could be prevented if there was a

00:02:16,010 --> 00:02:23,459
causal delivery precondition between the

00:02:18,720 --> 00:02:25,170
two the two events another example which

00:02:23,459 --> 00:02:28,560
is a classic one is that you want to

00:02:25,170 --> 00:02:30,569
post say somesome picture of you in

00:02:28,560 --> 00:02:32,250
vacations when you were supposed to be

00:02:30,569 --> 00:02:34,439
working or something like that so you

00:02:32,250 --> 00:02:36,180
remove your boss from from the list of

00:02:34,439 --> 00:02:37,829
people that are going to see pictures in

00:02:36,180 --> 00:02:40,019
that group then you post to the group

00:02:37,829 --> 00:02:42,060
but then he sees opposing so what

00:02:40,019 --> 00:02:43,950
happened is that there is a relation

00:02:42,060 --> 00:02:46,019
between the two events that was not

00:02:43,950 --> 00:02:47,760
enforced by the system and he was

00:02:46,019 --> 00:02:49,889
allowed to see the picture before the

00:02:47,760 --> 00:02:54,389
removal got into effect in the system

00:02:49,889 --> 00:02:56,819
and he was removed on another area if

00:02:54,389 --> 00:03:00,090
you systems based on last writer winds

00:02:56,819 --> 00:03:03,750
like Cassandra other types of anomalies

00:03:00,090 --> 00:03:04,859
also can happen so this used to happen I

00:03:03,750 --> 00:03:07,799
don't know if this has been fixed

00:03:04,859 --> 00:03:10,769
nowadays but the following think will

00:03:07,799 --> 00:03:13,950
happen that you you you could write into

00:03:10,769 --> 00:03:16,590
it or into an object in in Cassandra and

00:03:13,950 --> 00:03:18,810
if you if your clock was far ahead of

00:03:16,590 --> 00:03:21,569
all the other clocks that are using it

00:03:18,810 --> 00:03:24,900
you you actually actually writing that

00:03:21,569 --> 00:03:27,780
with the way the doom stone and this

00:03:24,900 --> 00:03:29,669
means that other users will be able to

00:03:27,780 --> 00:03:31,409
read what you have written and when they

00:03:29,669 --> 00:03:32,909
try to write back like a response they

00:03:31,409 --> 00:03:34,949
will not be able to do it because their

00:03:32,909 --> 00:03:36,449
time is behind the time of the time

00:03:34,949 --> 00:03:40,500
stamp that was used for the first

00:03:36,449 --> 00:03:42,690
writing so there's lots of problems with

00:03:40,500 --> 00:03:45,120
using clocks and other sort of the

00:03:42,690 --> 00:03:47,250
consistencies like for instance II did

00:03:45,120 --> 00:03:51,269
some tweet was favorited three times but

00:03:47,250 --> 00:03:53,819
only two are over there okay and so now

00:03:51,269 --> 00:03:57,060
you could think can't we use time steps

00:03:53,819 --> 00:04:00,030
to fix it or simply use a spanner and

00:03:57,060 --> 00:04:03,120
solve these issues well I'm going to

00:04:00,030 --> 00:04:06,000
spend some slides here trying to show

00:04:03,120 --> 00:04:08,400
you about some of the limitations of

00:04:06,000 --> 00:04:12,000
real time so even if we were able to

00:04:08,400 --> 00:04:15,599
have a perfect coordinated time

00:04:12,000 --> 00:04:19,530
everywhere we will still miss some

00:04:15,599 --> 00:04:22,409
information so the problem with time is

00:04:19,530 --> 00:04:24,840
that there is no no and I'm referencing

00:04:22,409 --> 00:04:27,480
these to a very nice article by Justin

00:04:24,840 --> 00:04:30,420
she that appears in a CM q

00:04:27,480 --> 00:04:34,740
last year that talks about these kind of

00:04:30,420 --> 00:04:37,500
problems so basically we ever now now

00:04:34,740 --> 00:04:40,620
that because we are in the same room and

00:04:37,500 --> 00:04:43,080
we might have more or less the same time

00:04:40,620 --> 00:04:45,300
reference but this thing doesn't

00:04:43,080 --> 00:04:50,520
translate to what is happening in in in

00:04:45,300 --> 00:04:53,850
other locations in general so for

00:04:50,520 --> 00:04:55,260
instance when everyone knows these that

00:04:53,850 --> 00:04:59,130
when we are looking at different events

00:04:55,260 --> 00:05:00,720
like if I think this is a Crab Nebula we

00:04:59,130 --> 00:05:03,030
are we are actually looking at the past

00:05:00,720 --> 00:05:04,790
so the more distance something is the

00:05:03,030 --> 00:05:09,720
more into the past we are looking and

00:05:04,790 --> 00:05:12,570
this is quite obvious in astronomy but

00:05:09,720 --> 00:05:14,640
this thing also happens in our rule so

00:05:12,570 --> 00:05:17,130
if i if I'm receiving a message that is

00:05:14,640 --> 00:05:20,550
coming from Australia there is a some

00:05:17,130 --> 00:05:22,440
milliseconds of delay in in relation to

00:05:20,550 --> 00:05:25,680
the time when that event occurred and

00:05:22,440 --> 00:05:28,140
actually light speed is the speed of

00:05:25,680 --> 00:05:29,880
causality ok so we need to discuss out

00:05:28,140 --> 00:05:34,470
to track the relations between events

00:05:29,880 --> 00:05:39,090
even in the real world so basically time

00:05:34,470 --> 00:05:41,520
is is inherently local so I that can be

00:05:39,090 --> 00:05:44,370
very useful if I have a wall clock that

00:05:41,520 --> 00:05:47,250
is close to me and if this wall clock is

00:05:44,370 --> 00:05:49,980
growing monotonically I can use this

00:05:47,250 --> 00:05:52,620
wall clock to do useful things and I

00:05:49,980 --> 00:05:55,200
might even not try to use some

00:05:52,620 --> 00:05:57,150
approximation of time I can do very

00:05:55,200 --> 00:05:59,190
useful things just by having a counter

00:05:57,150 --> 00:06:01,130
that starts at one and then I keep

00:05:59,190 --> 00:06:04,320
incrementing it as I need another

00:06:01,130 --> 00:06:06,240
reference to time but what will be

00:06:04,320 --> 00:06:07,950
tricky will be trying to use information

00:06:06,240 --> 00:06:10,950
from wall clocks at very different

00:06:07,950 --> 00:06:12,780
locations ok because will have different

00:06:10,950 --> 00:06:14,730
delays and it's really hard to relate

00:06:12,780 --> 00:06:16,890
the events that occur in multiple

00:06:14,730 --> 00:06:19,950
locations in terms of what would be real

00:06:16,890 --> 00:06:22,220
time a final thing about time because

00:06:19,950 --> 00:06:25,890
before i get into the causality tracking

00:06:22,220 --> 00:06:27,990
is that in order to track time we

00:06:25,890 --> 00:06:29,910
typically we need memory we need to have

00:06:27,990 --> 00:06:33,840
memory of what happened if you look at

00:06:29,910 --> 00:06:36,870
this image on the left and now this is

00:06:33,840 --> 00:06:38,810
before and this is after you noticed a

00:06:36,870 --> 00:06:41,840
transition

00:06:38,810 --> 00:06:43,810
but if you actually look at the same

00:06:41,840 --> 00:06:46,160
thing and you consider that one before

00:06:43,810 --> 00:06:49,070
you see the same transition and they are

00:06:46,160 --> 00:06:50,990
the same image so the this is showing

00:06:49,070 --> 00:06:54,200
that some events in the world inherently

00:06:50,990 --> 00:06:55,850
they don't have any notion of time so if

00:06:54,200 --> 00:06:57,590
we look at the two pictures we have no

00:06:55,850 --> 00:07:00,260
idea of knowing which came before the

00:06:57,590 --> 00:07:02,180
other we only know that the smoke is

00:07:00,260 --> 00:07:04,790
flowing in the given direction at this

00:07:02,180 --> 00:07:07,760
scale because we have this persistent

00:07:04,790 --> 00:07:09,350
memory in our eyes and brain of what we

00:07:07,760 --> 00:07:11,720
have seen before and this is what we

00:07:09,350 --> 00:07:14,030
need to do also in distributed systems

00:07:11,720 --> 00:07:16,340
because we have many states that I

00:07:14,030 --> 00:07:18,080
indistinguishable so in order to relight

00:07:16,340 --> 00:07:20,630
them we need to have some notion of

00:07:18,080 --> 00:07:23,690
memory so we need to basically memorize

00:07:20,630 --> 00:07:26,450
events so the overall motivation is that

00:07:23,690 --> 00:07:28,400
time is complicated it's not a straight

00:07:26,450 --> 00:07:30,979
timeline what we are looking really

00:07:28,400 --> 00:07:33,889
looking at in disputed systems is that a

00:07:30,979 --> 00:07:36,350
web of causes and effects that we need

00:07:33,889 --> 00:07:41,240
to be aware of in order to make sensible

00:07:36,350 --> 00:07:43,640
decisions so I'm going to cite the piper

00:07:41,240 --> 00:07:47,450
from the 70s very well-known one from

00:07:43,640 --> 00:07:51,789
westland port which is a physicists and

00:07:47,450 --> 00:07:55,820
that recently won a maturing award and

00:07:51,789 --> 00:07:57,260
he basically realized it or translated

00:07:55,820 --> 00:07:59,510
these notions from physics into

00:07:57,260 --> 00:08:01,880
distributed systems and introduces the

00:07:59,510 --> 00:08:03,770
notion of causality to the field of

00:08:01,880 --> 00:08:07,190
disputed systems in the late seventies

00:08:03,770 --> 00:08:10,100
so in order to introduce it i prepared a

00:08:07,190 --> 00:08:11,750
simple social interaction example to

00:08:10,100 --> 00:08:14,090
explain it a little bit and then we'll

00:08:11,750 --> 00:08:16,550
get into the time diagrams that some of

00:08:14,090 --> 00:08:19,130
you will be familiar with so in this

00:08:16,550 --> 00:08:21,740
social interaction Alice decides to to

00:08:19,130 --> 00:08:24,889
have dinner and then she tells that to

00:08:21,740 --> 00:08:26,630
Bob and Bob agrees to have dinner but

00:08:24,889 --> 00:08:28,550
meanwhile there is a third party which

00:08:26,630 --> 00:08:31,789
is Chris that he's bored here is nothing

00:08:28,550 --> 00:08:34,520
to do and finally he hears about the

00:08:31,789 --> 00:08:36,200
dinner plans and he asked to join so

00:08:34,520 --> 00:08:40,270
this is a social interaction and now

00:08:36,200 --> 00:08:43,940
let's see it in the space-time diagram

00:08:40,270 --> 00:08:47,240
so in order to to track these things we

00:08:43,940 --> 00:08:49,880
are going to assign unique event event

00:08:47,240 --> 00:08:52,640
is identifier to each action so when

00:08:49,880 --> 00:08:54,530
alice is asking if someone is interested

00:08:52,640 --> 00:08:57,350
for dinner we tag that thing with the a1

00:08:54,530 --> 00:08:59,810
so to do that and we often call this

00:08:57,350 --> 00:09:02,960
finger dot this unique track what we

00:08:59,810 --> 00:09:05,570
need is a location name here it is Alice

00:09:02,960 --> 00:09:08,990
and I'm just using the a letter and we

00:09:05,570 --> 00:09:10,670
have a monotonic counter so a counter

00:09:08,990 --> 00:09:13,430
that is always growing that we can use

00:09:10,670 --> 00:09:16,520
in a single location to distinguish

00:09:13,430 --> 00:09:19,010
different events so I'm using 1 2 3 etc

00:09:16,520 --> 00:09:21,470
and we do these things in the several

00:09:19,010 --> 00:09:25,640
locations so now we can talk about

00:09:21,470 --> 00:09:27,620
events and the arrows show message

00:09:25,640 --> 00:09:32,510
passing passing the arrows between

00:09:27,620 --> 00:09:35,720
locations I also included a timeline so

00:09:32,510 --> 00:09:38,570
this is what will be a global time if

00:09:35,720 --> 00:09:41,150
such thing existed so a global view of

00:09:38,570 --> 00:09:43,070
the system so one thing we can see here

00:09:41,150 --> 00:09:46,250
is that there are events that are

00:09:43,070 --> 00:09:49,900
actually concurrent so the fact that

00:09:46,250 --> 00:09:52,340
alice is wanting to have dinner is

00:09:49,900 --> 00:09:55,970
unrelated to the fact that chris is

00:09:52,340 --> 00:09:57,950
bored so this means that Alice didn't

00:09:55,970 --> 00:10:00,200
influence the set of crease in the event

00:09:57,950 --> 00:10:02,750
C 2 and the fact that Jesus bore it did

00:10:00,200 --> 00:10:05,900
not cost Alice to want to have dinner

00:10:02,750 --> 00:10:07,940
but if we look at fee at this thing and

00:10:05,900 --> 00:10:10,490
a real time if we think that real time

00:10:07,940 --> 00:10:13,520
is a solution what we will see is more

00:10:10,490 --> 00:10:16,940
relations that actually exists so in

00:10:13,520 --> 00:10:19,730
real time Alice wanting dinner was

00:10:16,940 --> 00:10:21,890
before in real time then Chris being

00:10:19,730 --> 00:10:23,960
bored so it might look at it cooled of

00:10:21,890 --> 00:10:26,060
interest but what we actually know from

00:10:23,960 --> 00:10:28,220
what information went through the system

00:10:26,060 --> 00:10:30,740
is that these two things are not related

00:10:28,220 --> 00:10:32,810
so actually causality brings us more

00:10:30,740 --> 00:10:37,190
information about what's happening that

00:10:32,810 --> 00:10:38,980
what is brought by real time so how are

00:10:37,190 --> 00:10:41,270
we going to track these we cannot be

00:10:38,980 --> 00:10:45,200
drawing arrows all the time in the

00:10:41,270 --> 00:10:48,260
system and so we could go and check the

00:10:45,200 --> 00:10:50,540
vector clock entry in wikipedia and you

00:10:48,260 --> 00:10:52,850
get all these nice formulas over there

00:10:50,540 --> 00:10:54,380
that you'll tell you all to use vector

00:10:52,850 --> 00:10:57,140
clocks but this is a little bit

00:10:54,380 --> 00:10:58,520
complicated and magic so now there's

00:10:57,140 --> 00:11:00,920
lots of people need to use these tools

00:10:58,520 --> 00:11:03,440
and they'd just go the check the rules

00:11:00,920 --> 00:11:05,600
and the rules kind of work or the user

00:11:03,440 --> 00:11:06,480
library but these always looks a little

00:11:05,600 --> 00:11:10,230
bit kind of

00:11:06,480 --> 00:11:12,570
magic so I will try to give you some

00:11:10,230 --> 00:11:15,449
intuition of how these rules are like

00:11:12,570 --> 00:11:16,800
that and where do they come from and to

00:11:15,449 --> 00:11:19,430
that end we'll start with something

00:11:16,800 --> 00:11:22,620
simple simpler call it causal victories

00:11:19,430 --> 00:11:27,480
which was a concept introduced it in

00:11:22,620 --> 00:11:31,290
1994 by Farzin matter and i'm going to

00:11:27,480 --> 00:11:33,120
show you what these things are so the

00:11:31,290 --> 00:11:35,639
basic intuition is again that we are

00:11:33,120 --> 00:11:37,949
collecting memories of the events that

00:11:35,639 --> 00:11:40,380
we have seen in the past and we do that

00:11:37,949 --> 00:11:43,920
by colette simply by collecting a set of

00:11:40,380 --> 00:11:46,589
events and if we collect if we have

00:11:43,920 --> 00:11:49,740
unique event tags dots and if we collect

00:11:46,589 --> 00:11:52,139
set of events we can use that inclusion

00:11:49,740 --> 00:11:54,449
to explain causalities so if I know

00:11:52,139 --> 00:11:57,540
something about an event I must seen all

00:11:54,449 --> 00:12:03,360
the events that is registered neck with

00:11:57,540 --> 00:12:05,250
it if I don't know if me and another

00:12:03,360 --> 00:12:08,519
entity if we don't know each other

00:12:05,250 --> 00:12:09,990
Easter e then we are congruent and if

00:12:08,519 --> 00:12:13,260
our in stories are the same we are the

00:12:09,990 --> 00:12:15,930
same so let's put these into the social

00:12:13,260 --> 00:12:18,089
interaction that we had there and here

00:12:15,930 --> 00:12:19,680
we are no longer we are doing two things

00:12:18,089 --> 00:12:22,380
we are assigning the events and we are

00:12:19,680 --> 00:12:24,959
collecting the set of events and now we

00:12:22,380 --> 00:12:29,100
can use this information to see what is

00:12:24,959 --> 00:12:31,019
happening in the graph so if we look at

00:12:29,100 --> 00:12:34,620
the first reception of a message in

00:12:31,019 --> 00:12:36,930
oadby we are receiving the message a1 a2

00:12:34,620 --> 00:12:40,380
the set of events are coming with a

00:12:36,930 --> 00:12:42,930
message we receive it when we were at

00:12:40,380 --> 00:12:45,170
the site B 1 in oadby and basically what

00:12:42,930 --> 00:12:47,519
we do is that we merge the two sets and

00:12:45,170 --> 00:12:49,410
after merging the two sets we know our

00:12:47,519 --> 00:12:51,480
past but since we have to register

00:12:49,410 --> 00:12:54,360
receive event then we need to create a

00:12:51,480 --> 00:12:57,269
new tag to be to tag and union that so

00:12:54,360 --> 00:13:00,600
this is what's happening in in this flow

00:12:57,269 --> 00:13:02,279
over here so i hope that everyone is

00:13:00,600 --> 00:13:04,139
getting this this interaction here we

00:13:02,279 --> 00:13:10,380
are just collecting sets of things and

00:13:04,139 --> 00:13:12,209
comparing sets of things and this is

00:13:10,380 --> 00:13:15,750
where we do the causalities checking so

00:13:12,209 --> 00:13:18,149
we just see for set inclusion so if we

00:13:15,750 --> 00:13:19,420
have set inclusion then we have an event

00:13:18,149 --> 00:13:24,070
that

00:13:19,420 --> 00:13:26,260
was a predecessor of another event but

00:13:24,070 --> 00:13:27,820
we still well checking set inclusion

00:13:26,260 --> 00:13:30,280
dragon I'm going to show you a little

00:13:27,820 --> 00:13:32,290
trick is a more or less complex

00:13:30,280 --> 00:13:34,810
operation because you have to compare

00:13:32,290 --> 00:13:38,490
the two sets so we can do a little trick

00:13:34,810 --> 00:13:40,770
if we take note of the last event that

00:13:38,490 --> 00:13:44,770
this thing is getting out of position

00:13:40,770 --> 00:13:47,230
okay it's okay so if we keep track of

00:13:44,770 --> 00:13:50,910
the last event that we have over there

00:13:47,230 --> 00:13:53,890
we can do it much more simpler we simply

00:13:50,910 --> 00:13:57,220
see if the last event is present in them

00:13:53,890 --> 00:13:58,900
in the same okay and this will give us

00:13:57,220 --> 00:14:01,030
the the same information because if we

00:13:58,900 --> 00:14:05,680
have the last event we must have all the

00:14:01,030 --> 00:14:15,790
other events that come with it it should

00:14:05,680 --> 00:14:17,530
be better now okay okay so basically

00:14:15,790 --> 00:14:19,000
what we we did is that we use this

00:14:17,530 --> 00:14:21,280
property that which we have the last

00:14:19,000 --> 00:14:22,930
event then we must have all the other

00:14:21,280 --> 00:14:29,470
events so we don't have to test the

00:14:22,930 --> 00:14:32,410
whole set and these are these there is

00:14:29,470 --> 00:14:34,660
another property over here is that if we

00:14:32,410 --> 00:14:37,690
have a given event in the history side

00:14:34,660 --> 00:14:40,560
if we have C 3 over there diesel also

00:14:37,690 --> 00:14:43,720
means that we need to have c1 and c2 so

00:14:40,560 --> 00:14:45,850
actually these histories here have a lot

00:14:43,720 --> 00:14:49,090
of redundancy and this is why these

00:14:45,850 --> 00:14:51,790
things are not used in in practice so

00:14:49,090 --> 00:14:54,040
how can we do better than this well we

00:14:51,790 --> 00:14:55,780
can use vector clocks which were the

00:14:54,040 --> 00:14:58,600
structures that I as shown in the

00:14:55,780 --> 00:15:02,380
wikipedia entry so actually plugs were

00:14:58,600 --> 00:15:06,640
created concurrently in 1998 by to

00:15:02,380 --> 00:15:10,360
research by fitch and matter and they

00:15:06,640 --> 00:15:12,870
are used in many subsystems nowadays for

00:15:10,360 --> 00:15:16,060
instance to do group communication to

00:15:12,870 --> 00:15:18,970
take a snapshot of a system there are

00:15:16,060 --> 00:15:21,010
really basic building blocks so how do

00:15:18,970 --> 00:15:22,870
we get from Castle histories to vector

00:15:21,010 --> 00:15:25,150
clocks hoping that you got intuition

00:15:22,870 --> 00:15:27,100
into causal histories so we have all

00:15:25,150 --> 00:15:29,350
these events over there and we are going

00:15:27,100 --> 00:15:32,320
just to take note of the last event from

00:15:29,350 --> 00:15:33,250
each location so from location a we are

00:15:32,320 --> 00:15:36,310
only interested

00:15:33,250 --> 00:15:39,670
on the number two on location beyond

00:15:36,310 --> 00:15:41,710
number three and on location see also on

00:15:39,670 --> 00:15:43,930
number three so we have this map from

00:15:41,710 --> 00:15:45,820
location to a natural counter and we

00:15:43,930 --> 00:15:48,910
could use this is actually what is used

00:15:45,820 --> 00:15:50,980
if the system is dynamic and we have

00:15:48,910 --> 00:15:54,670
many places that are not necessarily

00:15:50,980 --> 00:15:56,650
consecutive but if we can if you have

00:15:54,670 --> 00:15:59,530
the the lack of having places that are

00:15:56,650 --> 00:16:01,180
consecutive just like a B and C then we

00:15:59,530 --> 00:16:04,870
can simply put this thing into a vector

00:16:01,180 --> 00:16:07,690
we just making place it the location

00:16:04,870 --> 00:16:09,580
names so this is what the vector clock

00:16:07,690 --> 00:16:14,770
looks like so it's only a compression of

00:16:09,580 --> 00:16:16,750
a causal history so now if we put this

00:16:14,770 --> 00:16:19,090
thing back into the grid diagram we have

00:16:16,750 --> 00:16:21,280
this interaction here and I'm going to

00:16:19,090 --> 00:16:24,580
to show how we can read the interaction

00:16:21,280 --> 00:16:27,100
so when we are receiving a message again

00:16:24,580 --> 00:16:29,950
this is the recipient ought not be what

00:16:27,100 --> 00:16:31,720
we are receiving is a vector 200 and we

00:16:29,950 --> 00:16:35,380
need to merge it with a vector that we

00:16:31,720 --> 00:16:38,130
had 0 1 0 so what we do is a point wise

00:16:35,380 --> 00:16:41,589
maximum for each of the coordinates and

00:16:38,130 --> 00:16:45,430
the result of that is what we are going

00:16:41,589 --> 00:16:47,380
to use to increment the counter

00:16:45,430 --> 00:16:49,330
associated to not be so we do an

00:16:47,380 --> 00:16:53,290
increment on be in the end and we get

00:16:49,330 --> 00:16:56,770
the end result which is 220 so this is

00:16:53,290 --> 00:16:59,260
the basic mechanics to do the causality

00:16:56,770 --> 00:17:02,080
check before we did checking of

00:16:59,260 --> 00:17:05,500
inclusion between causal histories now

00:17:02,080 --> 00:17:09,189
what we do is we need to point wise core

00:17:05,500 --> 00:17:12,220
coordinate wise check if each coordinate

00:17:09,189 --> 00:17:14,079
as the corresponding value in the other

00:17:12,220 --> 00:17:16,510
coordinate is greater or equal than it

00:17:14,079 --> 00:17:19,030
so i have assigned it some calls to make

00:17:16,510 --> 00:17:22,120
it easier so we basically to check these

00:17:19,030 --> 00:17:25,030
two we need to check to with 20 with 2

00:17:22,120 --> 00:17:27,069
and 0 with 0 and since it happens in all

00:17:25,030 --> 00:17:30,850
the cases then there is a causality link

00:17:27,069 --> 00:17:32,650
between the two so can we make it faster

00:17:30,850 --> 00:17:34,420
that trick so this trick is not very

00:17:32,650 --> 00:17:37,720
well known so this is a new thing more

00:17:34,420 --> 00:17:39,370
or less we can again do it do the trick

00:17:37,720 --> 00:17:41,080
that we did before with the last event

00:17:39,370 --> 00:17:43,780
but this time we need to put it in bold

00:17:41,080 --> 00:17:45,490
over there that to win both means that

00:17:43,780 --> 00:17:47,110
that was the last event from replica a

00:17:45,490 --> 00:17:50,850
and we just need to test

00:17:47,110 --> 00:17:54,520
if it is known on the unload beam so

00:17:50,850 --> 00:17:57,100
it's not very easy to call old stuff and

00:17:54,520 --> 00:17:59,380
arrows in a programming language so we

00:17:57,100 --> 00:18:02,670
need another way to encode this thing so

00:17:59,380 --> 00:18:05,410
we can do this little trick where 200

00:18:02,670 --> 00:18:08,410
will now be decoupled we can decouple

00:18:05,410 --> 00:18:11,679
the last event and store it outside so

00:18:08,410 --> 00:18:14,950
now what we have is the causal past of

00:18:11,679 --> 00:18:17,530
it folks over event I to now we have the

00:18:14,950 --> 00:18:19,929
castle part of it which is 100 very

00:18:17,530 --> 00:18:22,360
compressed and we store the event itself

00:18:19,929 --> 00:18:24,850
outside and we call that thing a dot and

00:18:22,360 --> 00:18:26,260
we do the same thing over there for that

00:18:24,850 --> 00:18:29,049
vector so we could do these things for

00:18:26,260 --> 00:18:33,250
each vector as long as we do it when we

00:18:29,049 --> 00:18:36,549
are producing it and now I'll do a check

00:18:33,250 --> 00:18:38,980
well we just go there we pick the dot

00:18:36,549 --> 00:18:40,690
and we see if the dot is known on the

00:18:38,980 --> 00:18:42,070
other vector or the index is not only

00:18:40,690 --> 00:18:45,340
the corresponding position in the other

00:18:42,070 --> 00:18:47,740
vector so what was a linear operation in

00:18:45,340 --> 00:18:50,740
the in the number of elements in the

00:18:47,740 --> 00:18:56,679
vector now it's a probably constant time

00:18:50,740 --> 00:18:58,480
operation so up till now we have been

00:18:56,679 --> 00:19:00,610
registering all the events that are

00:18:58,480 --> 00:19:03,190
occurring okay so we are registering

00:19:00,610 --> 00:19:06,429
internal events send events receive

00:19:03,190 --> 00:19:09,640
events etc but for some systems it's not

00:19:06,429 --> 00:19:11,320
important to track all the events so we

00:19:09,640 --> 00:19:13,690
might be interested in very practical

00:19:11,320 --> 00:19:16,440
systems we are typically interested in

00:19:13,690 --> 00:19:20,290
only tracking events that changed item

00:19:16,440 --> 00:19:22,299
so vector clocks can be used for for

00:19:20,290 --> 00:19:24,429
instance for causal causal the ordered

00:19:22,299 --> 00:19:27,400
message dissemination but we are going

00:19:24,429 --> 00:19:28,960
to track only some events in order to

00:19:27,400 --> 00:19:31,690
get into another notion which is a

00:19:28,960 --> 00:19:34,090
version vector and in this case went

00:19:31,690 --> 00:19:35,590
rested on on on change events so these

00:19:34,090 --> 00:19:37,870
are applications in file system

00:19:35,590 --> 00:19:39,280
databases and version control and I

00:19:37,870 --> 00:19:42,970
think that probably everyone knows about

00:19:39,280 --> 00:19:46,000
this motivating example so in the in the

00:19:42,970 --> 00:19:49,299
dynamo Piper that describes that the

00:19:46,000 --> 00:19:51,840
amazon shopping cart system what they

00:19:49,299 --> 00:19:54,669
are doing is that they are tracking the

00:19:51,840 --> 00:19:56,679
events that change the shopping basket

00:19:54,669 --> 00:20:00,710
that is being managed so every every

00:19:56,679 --> 00:20:03,640
time given user is or

00:20:00,710 --> 00:20:05,960
boxee doing operations on his behalf are

00:20:03,640 --> 00:20:09,529
doing operations to the to the shopping

00:20:05,960 --> 00:20:12,260
cart the what is written is target with

00:20:09,529 --> 00:20:14,630
a with a vector so we are taking keeping

00:20:12,260 --> 00:20:16,940
track of all the right operations but we

00:20:14,630 --> 00:20:20,419
are not worrying about sending messages

00:20:16,940 --> 00:20:22,039
etc so what does it look like so to

00:20:20,419 --> 00:20:25,370
understand it we need to get back into

00:20:22,039 --> 00:20:27,320
the castle history so now we have this

00:20:25,370 --> 00:20:29,870
distinction between the events we are

00:20:27,320 --> 00:20:31,909
interested in which we are marking with

00:20:29,870 --> 00:20:33,679
a dot and we put a dot because those are

00:20:31,909 --> 00:20:38,179
the events where we need to put a unique

00:20:33,679 --> 00:20:40,549
tag and the other events that are that

00:20:38,179 --> 00:20:43,669
we don't need tracking so poor that one

00:20:40,549 --> 00:20:47,000
those ones we use an empty just an empty

00:20:43,669 --> 00:20:48,950
circle so in that case in this case here

00:20:47,000 --> 00:20:51,770
we have to write events one at node a

00:20:48,950 --> 00:20:54,289
and another at node B but then when we

00:20:51,770 --> 00:20:57,710
send a message at that point we are just

00:20:54,289 --> 00:20:59,029
propagating information so what are we

00:20:57,710 --> 00:21:02,870
talking about you we could be talking

00:20:59,029 --> 00:21:04,610
about a document and share it editing so

00:21:02,870 --> 00:21:07,010
these kind of things need to be using in

00:21:04,610 --> 00:21:11,899
things plus other technology in things

00:21:07,010 --> 00:21:14,870
lines such as Google Docs so we can be

00:21:11,899 --> 00:21:17,480
editing a document and note a is writing

00:21:14,870 --> 00:21:20,000
a given line and note B is writing an

00:21:17,480 --> 00:21:21,679
alternative line another line and when

00:21:20,000 --> 00:21:24,200
we propagate information we need to

00:21:21,679 --> 00:21:26,299
merge these into a single document so we

00:21:24,200 --> 00:21:29,240
need to realize that these things are

00:21:26,299 --> 00:21:31,700
concurrent and this is really easy to

00:21:29,240 --> 00:21:34,340
realize because one is not included in

00:21:31,700 --> 00:21:36,440
the other and neither happens vice versa

00:21:34,340 --> 00:21:38,720
so they are concurrent and when you

00:21:36,440 --> 00:21:40,580
receive concurrent things we typically

00:21:38,720 --> 00:21:44,090
need to ask the user for reconciliation

00:21:40,580 --> 00:21:45,799
okay so this is what happens in a

00:21:44,090 --> 00:21:47,690
version control system when you have a

00:21:45,799 --> 00:21:50,450
marsh conflict we ask the users to do

00:21:47,690 --> 00:21:53,539
something and since the user is is doing

00:21:50,450 --> 00:21:55,610
something the the decision or what we

00:21:53,539 --> 00:21:57,950
write back needs to be tagged it with

00:21:55,610 --> 00:22:00,080
with a new event because two different

00:21:57,950 --> 00:22:02,750
users can do different reconciliation

00:22:00,080 --> 00:22:04,669
decisions so we need to tie that so this

00:22:02,750 --> 00:22:06,980
is what happens over there in that case

00:22:04,669 --> 00:22:09,529
we had concurrency and we also the last

00:22:06,980 --> 00:22:11,299
interaction over there is just that we

00:22:09,529 --> 00:22:13,460
are sending information to a note see

00:22:11,299 --> 00:22:14,490
that was in an empty side states or with

00:22:13,460 --> 00:22:16,580
a blank page

00:22:14,490 --> 00:22:20,580
in that case it's very easy to see that

00:22:16,580 --> 00:22:22,890
this information at no be over rights

00:22:20,580 --> 00:22:25,530
the information on node C so we can

00:22:22,890 --> 00:22:27,090
simply overwrite over there after doing

00:22:25,530 --> 00:22:29,280
the test so when we do the causality

00:22:27,090 --> 00:22:31,080
test here we can either there is

00:22:29,280 --> 00:22:34,320
congruence and we need user intervention

00:22:31,080 --> 00:22:39,990
or some copies outdated and we simply

00:22:34,320 --> 00:22:43,290
overwrite it we can do another trick

00:22:39,990 --> 00:22:47,130
that actually happens in some databases

00:22:43,290 --> 00:22:48,780
and that is again think about the vinyl

00:22:47,130 --> 00:22:53,190
case this also happens in the react

00:22:48,780 --> 00:22:54,720
database sometimes we we don't want to

00:22:53,190 --> 00:22:57,150
do the reconciliation when we are

00:22:54,720 --> 00:22:59,370
handling the rights because it may take

00:22:57,150 --> 00:23:01,890
some time and we want to give a fast

00:22:59,370 --> 00:23:05,970
response to the right so we might want

00:23:01,890 --> 00:23:08,700
to have two copies at the database when

00:23:05,970 --> 00:23:11,070
we have congruent white and this is what

00:23:08,700 --> 00:23:13,470
happens here we we will have two copies

00:23:11,070 --> 00:23:15,630
of the state one is characterized by

00:23:13,470 --> 00:23:17,460
this causal v3a one and the other

00:23:15,630 --> 00:23:20,580
alternative one note that as the other

00:23:17,460 --> 00:23:23,970
alternative line is by causal beetle and

00:23:20,580 --> 00:23:27,480
we can defer so we have two siblings

00:23:23,970 --> 00:23:29,910
over there two states and we can refer

00:23:27,480 --> 00:23:32,520
differ the reconciliation of the states

00:23:29,910 --> 00:23:35,190
to let advice for instance these things

00:23:32,520 --> 00:23:38,360
sometimes I've done at the ridge ways in

00:23:35,190 --> 00:23:41,460
such as in react and at that point we

00:23:38,360 --> 00:23:44,400
typically have to register a new event

00:23:41,460 --> 00:23:51,830
to mark the reconciliation and the rest

00:23:44,400 --> 00:23:54,420
of the run is just the same thing so

00:23:51,830 --> 00:23:56,520
that was intuition with causal histories

00:23:54,420 --> 00:24:00,059
can we do the same thing in a compact

00:23:56,520 --> 00:24:03,150
way yes we can we can do it with the

00:24:00,059 --> 00:24:05,700
version vectors that interestingly they

00:24:03,150 --> 00:24:08,580
were invented before vector clocks so

00:24:05,700 --> 00:24:10,679
this is a paper from 1983 this is a very

00:24:08,580 --> 00:24:13,140
visionary Piper so I recommend everyone

00:24:10,679 --> 00:24:20,190
to read it even regarding things like

00:24:13,140 --> 00:24:23,640
gap etc so this is the the run when we

00:24:20,190 --> 00:24:26,190
look with version vectors as you see we

00:24:23,640 --> 00:24:27,480
only increment values when we have those

00:24:26,190 --> 00:24:29,220
bullets there

00:24:27,480 --> 00:24:32,610
and we are just passing out information

00:24:29,220 --> 00:24:36,360
in the system so in the end we have a

00:24:32,610 --> 00:24:39,780
120 that is more recent than 0 0 0 so we

00:24:36,360 --> 00:24:41,240
just overwrite information over there so

00:24:39,780 --> 00:24:46,760
I think this one should be clear by now

00:24:41,240 --> 00:24:46,760
giving done in the previous slides and

00:24:47,600 --> 00:24:58,500
sorry I'm missing one slide here okay we

00:24:53,760 --> 00:25:00,120
can also do the same trick in the guise

00:24:58,500 --> 00:25:04,650
of motion vectors we if we store the

00:25:00,120 --> 00:25:08,100
last version outside so I'm coming to

00:25:04,650 --> 00:25:10,530
the end of the of the talk in the last

00:25:08,100 --> 00:25:14,550
30 years there were a lot of causality

00:25:10,530 --> 00:25:16,110
mechanisms being developed some of them

00:25:14,550 --> 00:25:18,270
are useful some of them are not so

00:25:16,110 --> 00:25:21,870
useful there are libraries for some of

00:25:18,270 --> 00:25:23,760
them but all of them can be translated

00:25:21,870 --> 00:25:25,650
into this simple notion of a causal

00:25:23,760 --> 00:25:31,100
history where you have the events that

00:25:25,650 --> 00:25:33,780
you are interested so basically

00:25:31,100 --> 00:25:35,970
causality is important because time as

00:25:33,780 --> 00:25:38,190
limitations so it might look that the

00:25:35,970 --> 00:25:41,730
fact that you are ordering everything is

00:25:38,190 --> 00:25:43,320
the the best scenario but actually by

00:25:41,730 --> 00:25:46,080
ordering everything you are losing

00:25:43,320 --> 00:25:49,110
information so you actually have more

00:25:46,080 --> 00:25:52,260
information if you store the partial

00:25:49,110 --> 00:25:54,600
order the causal relationships then if

00:25:52,260 --> 00:25:57,300
you try to order everything because what

00:25:54,600 --> 00:26:03,810
is happening now in Australia is not

00:25:57,300 --> 00:26:06,270
influencing what we are doing here the

00:26:03,810 --> 00:26:08,130
other thing is that to track causality

00:26:06,270 --> 00:26:10,050
we need to memorize event and up the

00:26:08,130 --> 00:26:12,390
memorized events under the simplest way

00:26:10,050 --> 00:26:15,470
is just to collect sets of events so

00:26:12,390 --> 00:26:18,450
that was the basic building mechanism

00:26:15,470 --> 00:26:20,310
however these things although they are

00:26:18,450 --> 00:26:21,630
very simple in coatings of causality and

00:26:20,310 --> 00:26:24,570
they give you all the information that

00:26:21,630 --> 00:26:26,820
you need they are very they are highly

00:26:24,570 --> 00:26:28,860
inefficient so we cannot use typically

00:26:26,820 --> 00:26:30,510
caused all these trees in practice

00:26:28,860 --> 00:26:33,150
unless we were dealing with the system

00:26:30,510 --> 00:26:35,310
where very very few events are those

00:26:33,150 --> 00:26:37,560
that are of interest so if we have

00:26:35,310 --> 00:26:39,660
enough events we cannot use those things

00:26:37,560 --> 00:26:41,040
in products practice so we need to use

00:26:39,660 --> 00:26:42,990
particle mechanisms

00:26:41,040 --> 00:26:46,830
and these practical mechanisms include

00:26:42,990 --> 00:26:49,560
vector clocks version vectors dotted

00:26:46,830 --> 00:26:52,020
version vectors and what they are doing

00:26:49,560 --> 00:26:53,880
is simply doing an efficient encoding of

00:26:52,020 --> 00:26:56,010
causal mysteries they are not adding

00:26:53,880 --> 00:26:57,330
extra stuff they are just efficient

00:26:56,010 --> 00:26:59,340
encoding so most of the causal

00:26:57,330 --> 00:27:02,100
mechanisms are like that and when we

00:26:59,340 --> 00:27:04,530
look at the rules for comparing vector

00:27:02,100 --> 00:27:08,870
clocks what we are seeing is that just

00:27:04,530 --> 00:27:11,010
the set inclusion being mapped into the

00:27:08,870 --> 00:27:16,850
representation that the given mechanism

00:27:11,010 --> 00:27:20,360
is using nothing more than that so by

00:27:16,850 --> 00:27:23,280
take away the photo on this talk is that

00:27:20,360 --> 00:27:26,040
when you are faced with a with a needs

00:27:23,280 --> 00:27:28,170
either to design a new mechanism or to

00:27:26,040 --> 00:27:30,090
understand what kind of causality

00:27:28,170 --> 00:27:34,290
tracking you need to use in your system

00:27:30,090 --> 00:27:36,450
you should try to think out that thing

00:27:34,290 --> 00:27:38,160
tracks back to a simple causal history I

00:27:36,450 --> 00:27:42,060
understand the problem in terms of

00:27:38,160 --> 00:27:45,390
causal histories and anything else is

00:27:42,060 --> 00:27:48,330
just a coding strategy so most of the

00:27:45,390 --> 00:27:51,090
content here for those interested is

00:27:48,330 --> 00:27:53,850
also in an article that came in ACM cute

00:27:51,090 --> 00:27:54,960
is this one is freely available there's

00:27:53,850 --> 00:27:56,910
also a version that came in

00:27:54,960 --> 00:28:00,570
communications of ACM in April about

00:27:56,910 --> 00:28:03,750
this so you can follow through on this

00:28:00,570 --> 00:28:07,080
information and these are my contacts

00:28:03,750 --> 00:28:09,140
okay so thank you I'm open for for

00:28:07,080 --> 00:28:09,140
questions

00:28:14,140 --> 00:28:26,020
any question thanks a lot okay oh

00:28:19,630 --> 00:28:28,820
there's a question wait time for lunch

00:28:26,020 --> 00:28:31,040
since there aren't any other questions

00:28:28,820 --> 00:28:33,590
right now this one is more philosophical

00:28:31,040 --> 00:28:36,290
but during the talk which I found very

00:28:33,590 --> 00:28:38,510
interesting I found it hard to get my

00:28:36,290 --> 00:28:41,360
head around you using the word causality

00:28:38,510 --> 00:28:43,490
and maybe you can share an intuition

00:28:41,360 --> 00:28:46,040
about that to me it seems like saying

00:28:43,490 --> 00:28:48,890
your entire history is the cause of

00:28:46,040 --> 00:28:51,200
what's happening now is not informative

00:28:48,890 --> 00:28:55,390
enough in a way so how do you pick the

00:28:51,200 --> 00:28:59,480
things that are really the cause okay so

00:28:55,390 --> 00:29:01,610
so you are you are right so we are

00:28:59,480 --> 00:29:03,920
actually talking about something more

00:29:01,610 --> 00:29:07,670
precise with cheese potential causality

00:29:03,920 --> 00:29:10,430
so not necessarily causality so you are

00:29:07,670 --> 00:29:14,270
potentially influenced by everything

00:29:10,430 --> 00:29:17,330
that happened before you and that you

00:29:14,270 --> 00:29:19,730
are aware of so this is the the baseline

00:29:17,330 --> 00:29:21,470
of what you can do but we know that we

00:29:19,730 --> 00:29:23,300
are not influenced by everything that

00:29:21,470 --> 00:29:24,770
happening in our lives we are just

00:29:23,300 --> 00:29:28,060
influenced by the events that we

00:29:24,770 --> 00:29:32,710
memorize that happen before us so

00:29:28,060 --> 00:29:36,050
actually in some systems you can try to

00:29:32,710 --> 00:29:38,480
restrict the events that that you

00:29:36,050 --> 00:29:40,340
register as potential causes to what we

00:29:38,480 --> 00:29:43,580
are doing there's a paper called bolt on

00:29:40,340 --> 00:29:46,460
cause a consistency that that explores a

00:29:43,580 --> 00:29:48,580
little bit of this okay but in the end

00:29:46,460 --> 00:29:51,410
if you can encode all this information

00:29:48,580 --> 00:29:53,660
just in a version vector that is

00:29:51,410 --> 00:29:55,730
something that has interesting

00:29:53,660 --> 00:29:58,640
scalability properties if you don't have

00:29:55,730 --> 00:30:00,620
lots of notes then that might not really

00:29:58,640 --> 00:30:02,840
be a problem but otherwise you are

00:30:00,620 --> 00:30:04,850
correct so if you can have more semantic

00:30:02,840 --> 00:30:07,670
information in your system that tells

00:30:04,850 --> 00:30:11,480
you exactly which events you need to

00:30:07,670 --> 00:30:14,870
track you you can do better you can even

00:30:11,480 --> 00:30:16,190
track less events and we that have more

00:30:14,870 --> 00:30:18,290
information because you are only

00:30:16,190 --> 00:30:20,710
considering the relevant event to what

00:30:18,290 --> 00:30:20,710
you are doing

00:30:25,770 --> 00:30:32,770
could you please make some practical

00:30:28,840 --> 00:30:37,360
examples of this because well for me

00:30:32,770 --> 00:30:39,730
this sounds really interesting but I am

00:30:37,360 --> 00:30:41,890
striving to imagine how how these can be

00:30:39,730 --> 00:30:45,880
applied well in my day to day

00:30:41,890 --> 00:30:47,950
engineering job okay so I'm going to use

00:30:45,880 --> 00:30:51,220
an example that I don't more or less

00:30:47,950 --> 00:30:54,160
which is from the right database so from

00:30:51,220 --> 00:30:56,830
bio so they do kind of an implementation

00:30:54,160 --> 00:31:00,070
of dynamo with something so most things

00:30:56,830 --> 00:31:02,260
in common some variations so it is a no

00:31:00,070 --> 00:31:08,170
sequel database with a get put interface

00:31:02,260 --> 00:31:10,450
and they want to be always available and

00:31:08,170 --> 00:31:12,580
they don't they want they typically in

00:31:10,450 --> 00:31:16,320
the mode that I'm concerned with data

00:31:12,580 --> 00:31:20,230
onto coordination so users can go and

00:31:16,320 --> 00:31:21,760
fetch an object to a get then do some

00:31:20,230 --> 00:31:24,760
change to the object and then put

00:31:21,760 --> 00:31:27,520
something back so what happens if 2

00:31:24,760 --> 00:31:30,910
users get the same object and do

00:31:27,520 --> 00:31:33,460
concurrent changes you have two options

00:31:30,910 --> 00:31:35,650
well we have more more than two options

00:31:33,460 --> 00:31:39,640
but you can use something like last

00:31:35,650 --> 00:31:41,140
fighter wins where a user puts puts the

00:31:39,640 --> 00:31:43,300
information there and when the second

00:31:41,140 --> 00:31:44,890
user comes it will overwrite information

00:31:43,300 --> 00:31:47,230
but this is actually not correct because

00:31:44,890 --> 00:31:49,660
the update that wasn't by the first user

00:31:47,230 --> 00:31:50,980
is as important as the updated that was

00:31:49,660 --> 00:31:53,770
done by the second one it just got

00:31:50,980 --> 00:31:55,450
unlucky with the timing so databases

00:31:53,770 --> 00:31:57,430
that use last I to win when these things

00:31:55,450 --> 00:31:58,840
occur they are losing information and

00:31:57,430 --> 00:32:01,630
this information can be important so

00:31:58,840 --> 00:32:03,250
what they do mean in react is that when

00:32:01,630 --> 00:32:05,380
these things happen they start to

00:32:03,250 --> 00:32:07,330
siblings so they recognize the fact that

00:32:05,380 --> 00:32:09,310
that was a concurrent interaction with

00:32:07,330 --> 00:32:12,460
the system so you have two copies of the

00:32:09,310 --> 00:32:14,410
data and they need to somehow know that

00:32:12,460 --> 00:32:17,110
they are siblings and they can use

00:32:14,410 --> 00:32:19,240
version vectors for that and now they

00:32:17,110 --> 00:32:21,070
are using a more complex thing which are

00:32:19,240 --> 00:32:24,340
is dotted version vectors to track that

00:32:21,070 --> 00:32:26,470
because of scalability concerns and what

00:32:24,340 --> 00:32:28,480
you have when we have two siblings now

00:32:26,470 --> 00:32:31,030
the next user that is going to read the

00:32:28,480 --> 00:32:33,910
database will get these two copies and

00:32:31,030 --> 00:32:35,620
the application layer has a chance to do

00:32:33,910 --> 00:32:38,740
the reconciliation of the cop

00:32:35,620 --> 00:32:41,620
and then right back so these things can

00:32:38,740 --> 00:32:44,880
be used in this context to don't lose

00:32:41,620 --> 00:32:48,820
any update and twin the reconciliation

00:32:44,880 --> 00:32:51,780
at application level can be hard but you

00:32:48,820 --> 00:32:54,760
can also use another technology that I'm

00:32:51,780 --> 00:32:57,100
working with which is a conflict-free

00:32:54,760 --> 00:33:00,460
replication replicated data type square

00:32:57,100 --> 00:33:02,230
you can try to remove the burden of the

00:33:00,460 --> 00:33:03,970
reconciliation from the application and

00:33:02,230 --> 00:33:07,030
just use libraries that know how to

00:33:03,970 --> 00:33:09,460
reconcile set reconcile sequences

00:33:07,030 --> 00:33:11,440
counters etc so this is one of the

00:33:09,460 --> 00:33:24,240
practical uses off of these kind of

00:33:11,440 --> 00:33:24,240

YouTube URL: https://www.youtube.com/watch?v=paHhOD5zI0w


