Title: Berlin Buzzwords 2016: Roman Shaposhnik - OSv: Probably the best OS for Cloud workloads you've ...
Publication date: 2016-06-12
Playlist: Berlin Buzzwords 2016 #bbuzz
Description: 
	Roman Shaposhnik talking about "OSv: Probably the best OS for Cloud workloads you've never heard of"

With Docker Inc. buying Unikernel Systems and sparking renewed interest in unikernel technology, 2016 is shaping to be an undeniably year of unikernels. OSv is the revolutionary new open source technology that combines the power of virtualization and micro-services architecture. This combination allows unmodified applications deployed in a virtualized environment to outperform bare-metal deployments. 

Yes. You've heard it right: for the first time ever we can stop asking the question of how much performance would I lose if I virtualize. OSv lets you ask a different question: how much would my application gain in performance if I virtualize it. This talk will start by looking into the architecture of OSv and the kind of optimizations it makes possible for native, unmodified applications. 

We will then focus on JVM-specific optimizations and specifically on speedups available to big data and NoSQL projects when they are deployed on OSv. We will also cover a companion project Seastar that is now being used as a base for a hight performant replacement for Apache Cassandra, beating the Apache implementation on most of the benchmarks.

Read more:
https://2016.berlinbuzzwords.de/session/osv-probably-best-os-cloud-workloads-youve-never-heard

About
https://2016.berlinbuzzwords.de/users/roman-shaposhnik

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:02,300 --> 00:00:07,730
thanks thanks for coming can you hear me

00:00:05,130 --> 00:00:11,550
all right is it not too loud okay good

00:00:07,730 --> 00:00:14,759
so I actually started tinkering with the

00:00:11,550 --> 00:00:16,260
sort of this osv project that I'm going

00:00:14,759 --> 00:00:18,600
to talk about in about three years ago

00:00:16,260 --> 00:00:22,080
and I used to give this presentation you

00:00:18,600 --> 00:00:24,269
know from time to time but a beginning

00:00:22,080 --> 00:00:25,710
of this year something happened so

00:00:24,269 --> 00:00:29,429
basically good friend of mine Brian

00:00:25,710 --> 00:00:32,070
Coentrao you know reacted this way to

00:00:29,429 --> 00:00:33,809
the purchase of you know the

00:00:32,070 --> 00:00:36,870
microcurrent also sort of unit colonel

00:00:33,809 --> 00:00:38,790
group you know by docker company and you

00:00:36,870 --> 00:00:41,190
know his idea was that you know the unit

00:00:38,790 --> 00:00:43,590
kernels which osv is an example of is an

00:00:41,190 --> 00:00:45,059
absolutely bad idea he even you know

00:00:43,590 --> 00:00:48,270
wrote this blog post that I actually

00:00:45,059 --> 00:00:49,980
highly recommend to everyone because it

00:00:48,270 --> 00:00:53,309
actually touches upon some really

00:00:49,980 --> 00:00:54,510
interesting issues in how and what unit

00:00:53,309 --> 00:00:56,160
kernels are trying to do with the

00:00:54,510 --> 00:00:58,859
application you know deployment in the

00:00:56,160 --> 00:01:01,170
cloud but I think sort of the frame of

00:00:58,859 --> 00:01:03,270
reference that Brian is coming to is

00:01:01,170 --> 00:01:05,010
slightly different from maybe actually a

00:01:03,270 --> 00:01:06,600
lot different to the frame of reference

00:01:05,010 --> 00:01:08,580
that I will be trying to sort of

00:01:06,600 --> 00:01:10,500
perceive in my presentation because to

00:01:08,580 --> 00:01:12,420
him the application deployment in the

00:01:10,500 --> 00:01:13,439
cloud is basically old school it's kind

00:01:12,420 --> 00:01:14,909
of like how we used to build

00:01:13,439 --> 00:01:16,650
applications where you know sort of

00:01:14,909 --> 00:01:18,900
developers were really aware of the

00:01:16,650 --> 00:01:20,970
underlying operating system and what I

00:01:18,900 --> 00:01:23,549
will be talking about is something that

00:01:20,970 --> 00:01:24,630
happened only recently so my frame of

00:01:23,549 --> 00:01:27,030
reference is basically

00:01:24,630 --> 00:01:28,439
platform-as-a-service and i will be

00:01:27,030 --> 00:01:30,329
using one of the examples you know

00:01:28,439 --> 00:01:31,920
there's a few available sort of Cloud

00:01:30,329 --> 00:01:33,180
Foundry is a good one because it's you

00:01:31,920 --> 00:01:34,890
know pretty widely adopted by the

00:01:33,180 --> 00:01:36,540
industry i work at pivotal so obviously

00:01:34,890 --> 00:01:37,650
you know I have to give at least a

00:01:36,540 --> 00:01:39,960
couple of slides you know to Cloud

00:01:37,650 --> 00:01:41,729
Foundry but in general Cloud Foundry

00:01:39,960 --> 00:01:43,890
basically gives you a really different

00:01:41,729 --> 00:01:47,159
model of how developers interact with

00:01:43,890 --> 00:01:48,540
the sort of underlying platform and you

00:01:47,159 --> 00:01:50,310
know like I said sort of different

00:01:48,540 --> 00:01:51,829
companies are investing and you know

00:01:50,310 --> 00:01:54,960
most of the companies from this slide

00:01:51,829 --> 00:01:56,490
not just in sort of the companies

00:01:54,960 --> 00:01:57,869
supporting Cloud Foundry organization

00:01:56,490 --> 00:01:59,610
but they actually practitioners or cloud

00:01:57,869 --> 00:02:02,189
foundry so they have internal

00:01:59,610 --> 00:02:03,659
development teams essentially using the

00:02:02,189 --> 00:02:05,369
platform to basically develop and deploy

00:02:03,659 --> 00:02:08,489
applications you know day in and day out

00:02:05,369 --> 00:02:10,860
so how do they do this not seriously how

00:02:08,489 --> 00:02:13,890
do they do this so basically the

00:02:10,860 --> 00:02:15,840
application is sort of sliced into

00:02:13,890 --> 00:02:17,640
chunks that then gets pushed into the

00:02:15,840 --> 00:02:19,520
platform that's it done like there are

00:02:17,640 --> 00:02:22,170
no containers there are no doctor files

00:02:19,520 --> 00:02:24,150
there is nothing it's very similar you

00:02:22,170 --> 00:02:25,680
know conceptually to how sort of j2ee a

00:02:24,150 --> 00:02:27,990
application developer would interact

00:02:25,680 --> 00:02:29,910
with the you know application server

00:02:27,990 --> 00:02:31,440
where you know all you have to know is a

00:02:29,910 --> 00:02:33,330
developer is that you have to produce a

00:02:31,440 --> 00:02:34,830
war file and the rest you don't even

00:02:33,330 --> 00:02:36,930
know about it like you know whether your

00:02:34,830 --> 00:02:40,800
application server is deployed on unix o

00:02:36,930 --> 00:02:42,300
windows or maybe AIX you have no idea

00:02:40,800 --> 00:02:44,100
and you don't need to worry about any of

00:02:42,300 --> 00:02:45,959
them so Cloud Foundry is sort of the

00:02:44,100 --> 00:02:47,580
same you know similar approach and it

00:02:45,959 --> 00:02:49,830
works extremely well but it works

00:02:47,580 --> 00:02:52,470
extremely well for sort of a certain

00:02:49,830 --> 00:02:55,320
class of applications if you have your

00:02:52,470 --> 00:02:57,870
traditional j2ee type of application you

00:02:55,320 --> 00:02:59,880
actually a little bit out of luck you

00:02:57,870 --> 00:03:02,550
kind of have to refactor and re-engineer

00:02:59,880 --> 00:03:04,709
your application to be following sort of

00:03:02,550 --> 00:03:06,720
these principles so those types of

00:03:04,709 --> 00:03:08,400
applications are known as 12 factor

00:03:06,720 --> 00:03:09,930
applications and I won't go through all

00:03:08,400 --> 00:03:11,640
of the principles but for those of you

00:03:09,930 --> 00:03:13,200
interested I mean 12 factor the 12

00:03:11,640 --> 00:03:15,600
factor that lab gives a really good

00:03:13,200 --> 00:03:17,640
overview of what it means to be a 12

00:03:15,600 --> 00:03:20,760
factor application I mean most of this

00:03:17,640 --> 00:03:22,709
stuff is basically self-explanatory you

00:03:20,760 --> 00:03:24,120
know you basically have to have

00:03:22,709 --> 00:03:25,769
configuration that is separate from the

00:03:24,120 --> 00:03:27,480
applications you know you have to have

00:03:25,769 --> 00:03:28,769
pork binding that is outside of the

00:03:27,480 --> 00:03:30,540
application so you basically have to

00:03:28,769 --> 00:03:32,610
kind of communicate to the platform how

00:03:30,540 --> 00:03:34,769
your application needs to behave but

00:03:32,610 --> 00:03:36,810
most important of all your application

00:03:34,769 --> 00:03:38,370
has to be stateless which means that

00:03:36,810 --> 00:03:40,410
your application basically has no

00:03:38,370 --> 00:03:43,860
identity or parts of your application

00:03:40,410 --> 00:03:45,209
have no identity % that identity may be

00:03:43,860 --> 00:03:46,980
stored someplace else so your

00:03:45,209 --> 00:03:49,110
application may you know talk to the

00:03:46,980 --> 00:03:51,329
database or some kind of a persistent

00:03:49,110 --> 00:03:53,940
store outside of the application but the

00:03:51,329 --> 00:03:56,519
platform doesn't know anything about

00:03:53,940 --> 00:03:58,530
sort of what mean what it means to sort

00:03:56,519 --> 00:04:00,269
of hold a certain state and what will

00:03:58,530 --> 00:04:01,890
allows the platform to do it basically

00:04:00,269 --> 00:04:03,239
allows the platform to manipulate your

00:04:01,890 --> 00:04:05,340
applications and all sorts of ways you

00:04:03,239 --> 00:04:07,320
know scaling it up scaling it down you

00:04:05,340 --> 00:04:09,090
know doing sort of roll out without

00:04:07,320 --> 00:04:10,859
worrying about you know how to persist

00:04:09,090 --> 00:04:13,109
that states that may be unique to this

00:04:10,859 --> 00:04:15,900
chunk of application that you is you

00:04:13,109 --> 00:04:17,789
know being manipulated so in practice

00:04:15,900 --> 00:04:22,740
you know this sort of looks like this

00:04:17,789 --> 00:04:25,800
you typically have sort of a man this is

00:04:22,740 --> 00:04:40,390
looks awesome Wow

00:04:25,800 --> 00:04:42,010
hmm I guess yeah this is pretty bad so

00:04:40,390 --> 00:04:44,440
basically you know you have essentially

00:04:42,010 --> 00:04:46,150
a manifest three application which

00:04:44,440 --> 00:04:47,380
essentially is a gamma file that

00:04:46,150 --> 00:04:49,000
explains a few things about the

00:04:47,380 --> 00:04:50,950
application itself you know what sort of

00:04:49,000 --> 00:04:52,690
chunks of the database the application

00:04:50,950 --> 00:04:53,860
has to interact with you know what ports

00:04:52,690 --> 00:04:55,930
it expects you know what sort of

00:04:53,860 --> 00:04:57,430
configuration variables it expects you

00:04:55,930 --> 00:04:58,960
know the ya know file you know typically

00:04:57,430 --> 00:05:00,430
again you know hopefully maybe we can

00:04:58,960 --> 00:05:08,260
get at least a glimpse of it or maybe

00:05:00,430 --> 00:05:10,570
not ah right this is this is not going

00:05:08,260 --> 00:05:18,750
well you know what let me try something

00:05:10,570 --> 00:05:18,750
else let me quickly try something else

00:05:33,629 --> 00:05:43,629
yeah okay so let me let me see if you

00:05:41,409 --> 00:05:46,659
know maybe I'm pretty sure it's a laptop

00:05:43,629 --> 00:05:50,830
issue or you know sort of you know the

00:05:46,659 --> 00:06:09,039
issue with the buh buh buh buh buh okay

00:05:50,830 --> 00:06:16,389
view full screen this is just okay okay

00:06:09,039 --> 00:06:21,969
this is actually better in a way well

00:06:16,389 --> 00:06:24,430
maybe not this is i I just I haven't

00:06:21,969 --> 00:06:27,550
seen anything like that but basically so

00:06:24,430 --> 00:06:29,800
where I so this is you know sit now this

00:06:27,550 --> 00:06:36,479
is this is annoying this is now she's

00:06:29,800 --> 00:06:36,479
showing up yeah um huh

00:06:46,969 --> 00:06:55,009
nope does anybody have a different

00:06:52,860 --> 00:06:55,009
laptop

00:07:01,409 --> 00:07:47,179
oh yeah I've got it here do you get up

00:07:23,749 --> 00:07:50,699
boo oh you've got it anybody can peel

00:07:47,179 --> 00:08:05,779
yeah windows is fine I have a PDF scarce

00:07:50,699 --> 00:08:05,779
oh yes ah nope

00:08:11,190 --> 00:08:26,240
whoo they said you know we so this is oh

00:08:28,040 --> 00:08:35,159
man this is this is not going as I

00:08:30,930 --> 00:08:37,979
planned okay so let me try something

00:08:35,159 --> 00:08:40,140
else again so if you can try to find a

00:08:37,979 --> 00:08:42,349
laptop that would be appreciated well

00:08:40,140 --> 00:08:42,349
for now

00:08:56,400 --> 00:09:18,210
oh yeah I've got it already here mm-hmm

00:09:12,230 --> 00:09:20,270
so do you ever use me yeah thank you

00:09:18,210 --> 00:09:20,270
guys

00:09:33,339 --> 00:09:36,339
mmm

00:09:39,770 --> 00:09:45,980
sure are you gonna try all the laptop

00:09:43,020 --> 00:09:45,980
yeah yeah yeah yeah

00:09:59,920 --> 00:10:04,090
yeah well we have to display it first

00:10:05,560 --> 00:10:35,210
yeah first one okay which one it's yeah

00:10:30,950 --> 00:10:37,160
you can I there's this one so on that

00:10:35,210 --> 00:10:44,950
side that's will display across here

00:10:37,160 --> 00:10:48,380
okay so then we need we need this one

00:10:44,950 --> 00:10:53,200
and then this one yeah they have like a

00:10:48,380 --> 00:10:53,200
really convoluted oh I don't actually

00:10:56,290 --> 00:11:05,090
yeah I have him I'd like I haven't seen

00:10:59,030 --> 00:11:13,660
this this one ever in my life yep so

00:11:05,090 --> 00:11:13,660
what's ya okay

00:11:37,560 --> 00:11:47,430
oh okay yeah that's German system

00:11:42,570 --> 00:11:58,800
settings systems preferences yeah yeah

00:11:47,430 --> 00:12:03,720
yep not here not yet yeah yeah so when

00:11:58,800 --> 00:12:13,440
it's far yeah and just make it mirror if

00:12:03,720 --> 00:12:15,210
only understood German yeah it's still

00:12:13,440 --> 00:12:20,670
flickering but I think it's better it's

00:12:15,210 --> 00:12:27,680
way better than it used to be so yeah

00:12:20,670 --> 00:12:32,910
can you go fullscreen awesome ah ok

00:12:27,680 --> 00:12:34,920
thank you yep all right so I will try to

00:12:32,910 --> 00:12:36,060
talk real fast because you know we kind

00:12:34,920 --> 00:12:37,860
of lost a little bit of time but the

00:12:36,060 --> 00:12:39,540
good news is you can actually see it so

00:12:37,860 --> 00:12:41,460
this is how the manifest file looks like

00:12:39,540 --> 00:12:43,290
and basically what the developer has to

00:12:41,460 --> 00:12:45,390
do is just this right you know CF push

00:12:43,290 --> 00:12:47,670
and then using that manifest file what

00:12:45,390 --> 00:12:49,890
the system does is essentially it builds

00:12:47,670 --> 00:12:51,870
you know whole bunch of images and those

00:12:49,890 --> 00:12:53,460
images are known as droplets so those

00:12:51,870 --> 00:12:54,990
images are essentially the application

00:12:53,460 --> 00:12:56,730
source code something that is known as

00:12:54,990 --> 00:12:58,200
build pack basically all the sort of

00:12:56,730 --> 00:13:00,120
prerequisites for that source code and

00:12:58,200 --> 00:13:01,410
then a filesystem stack is kind of like

00:13:00,120 --> 00:13:02,670
Colonel and all these bits and pieces

00:13:01,410 --> 00:13:05,370
that blue you know everything together

00:13:02,670 --> 00:13:07,380
so then for example once you deploy your

00:13:05,370 --> 00:13:08,940
application and you want to scale it you

00:13:07,380 --> 00:13:10,950
know to a different number of instances

00:13:08,940 --> 00:13:12,990
you can actually do it automatically but

00:13:10,950 --> 00:13:14,310
you can do it manually as well and all

00:13:12,990 --> 00:13:17,339
the system needs to do is to basically

00:13:14,310 --> 00:13:18,930
sort of copy those droplets on two

00:13:17,339 --> 00:13:22,260
different you know sort of containers

00:13:18,930 --> 00:13:24,600
and off you go so the idea here is that

00:13:22,260 --> 00:13:26,610
the anatomy of the droplet is basically

00:13:24,600 --> 00:13:27,930
some of the microservices code you know

00:13:26,610 --> 00:13:30,390
sort of again that's the piece of your

00:13:27,930 --> 00:13:31,709
application some kind of a virtual

00:13:30,390 --> 00:13:33,750
machine you know most of the time it's

00:13:31,709 --> 00:13:35,820
typically java virtual machine but if

00:13:33,750 --> 00:13:37,410
you think about it you know go runtime

00:13:35,820 --> 00:13:40,050
could also be considered as a virtual

00:13:37,410 --> 00:13:41,520
machine then there is some stuff and you

00:13:40,050 --> 00:13:43,350
know obviously there has to be hardware

00:13:41,520 --> 00:13:45,390
you know for all of it to be executed on

00:13:43,350 --> 00:13:47,250
so how we doing it today with Cloud

00:13:45,390 --> 00:13:50,130
Foundry so most of it is basically done

00:13:47,250 --> 00:13:51,270
through essentially run see images so we

00:13:50,130 --> 00:13:52,710
don't actually use I

00:13:51,270 --> 00:13:56,310
we can run on docker but we can also

00:13:52,710 --> 00:13:59,460
just use run see images and we kind of

00:13:56,310 --> 00:14:02,310
put you know the sort of minimum version

00:13:59,460 --> 00:14:04,800
of a minimal version of ubuntu as a base

00:14:02,310 --> 00:14:07,530
image and put sort of the build pack and

00:14:04,800 --> 00:14:09,600
application code on top of them so a

00:14:07,530 --> 00:14:11,100
better way and I think you know that's

00:14:09,600 --> 00:14:12,540
what this presentation is about then

00:14:11,100 --> 00:14:14,340
again that's why I think you know Brian

00:14:12,540 --> 00:14:17,850
was a little bit off in his comments is

00:14:14,340 --> 00:14:20,190
that if we can reduce the amount of the

00:14:17,850 --> 00:14:21,930
operating system that we put into each

00:14:20,190 --> 00:14:24,000
of those containers you know we win

00:14:21,930 --> 00:14:26,610
because the image becomes much smaller

00:14:24,000 --> 00:14:29,010
and especially on the sort of already

00:14:26,610 --> 00:14:30,540
virtualized environments like you know

00:14:29,010 --> 00:14:32,760
public cloud and you know some of the

00:14:30,540 --> 00:14:34,710
OpenStack deployments we avoid sort of

00:14:32,760 --> 00:14:36,930
this double you know virtualization you

00:14:34,710 --> 00:14:38,400
know sort of we avoid virtual machines

00:14:36,930 --> 00:14:42,390
you know em containers within the

00:14:38,400 --> 00:14:45,300
virtual machines so basically this is

00:14:42,390 --> 00:14:46,920
the taxonomy of you know everything that

00:14:45,300 --> 00:14:49,170
you're sort of container platform could

00:14:46,920 --> 00:14:50,730
support so you know this image was you

00:14:49,170 --> 00:14:51,810
know done by Graham dumbleton and I

00:14:50,730 --> 00:14:53,820
really like it because you know

00:14:51,810 --> 00:14:54,930
basically you have the container image

00:14:53,820 --> 00:14:57,390
and there is nothing wrong with it you

00:14:54,930 --> 00:14:59,010
know you can still use it but the unique

00:14:57,390 --> 00:15:00,720
kernel-based container image is much

00:14:59,010 --> 00:15:03,330
smaller and thus much easier to manage

00:15:00,720 --> 00:15:05,970
and scale and that thing on the right is

00:15:03,330 --> 00:15:09,210
java runtime which is big either way you

00:15:05,970 --> 00:15:11,340
look at it so what is a unit colonel so

00:15:09,210 --> 00:15:12,840
unique kernel as a concept but actually

00:15:11,340 --> 00:15:17,820
around for quite some time but it got

00:15:12,840 --> 00:15:20,520
kind of sort of into the public view i

00:15:17,820 --> 00:15:23,160
would say in 2013 when this research

00:15:20,520 --> 00:15:24,780
paper was published and the whole notion

00:15:23,160 --> 00:15:27,930
of a library operating system was

00:15:24,780 --> 00:15:30,330
introduced so basically we all expect

00:15:27,930 --> 00:15:32,400
our operating system to beacon you know

00:15:30,330 --> 00:15:34,410
sort of a kernel and then I call bunch

00:15:32,400 --> 00:15:36,240
of user code so what these guys for the

00:15:34,410 --> 00:15:38,790
first time proposed is that why don't we

00:15:36,240 --> 00:15:40,740
put all of the operating system kernel

00:15:38,790 --> 00:15:43,050
and the application itself in the same

00:15:40,740 --> 00:15:45,870
sort of image and run everything within

00:15:43,050 --> 00:15:47,250
the essential ring 0 and of course you

00:15:45,870 --> 00:15:48,600
know there's a few things that we cannot

00:15:47,250 --> 00:15:50,760
really do you know we cannot for example

00:15:48,600 --> 00:15:53,040
have multiple processes you know sort of

00:15:50,760 --> 00:15:55,230
switching because you know that's sort

00:15:53,040 --> 00:15:59,220
of one image running within the you know

00:15:55,230 --> 00:16:01,380
one sort of address space and this

00:15:59,220 --> 00:16:03,330
executable because it really becomes an

00:16:01,380 --> 00:16:04,649
executable this executable can only be

00:16:03,330 --> 00:16:06,509
sort of run on

00:16:04,649 --> 00:16:09,389
of some kind of virtualization system so

00:16:06,509 --> 00:16:12,089
it's qmo you know virtualbox vmware is

00:16:09,389 --> 00:16:13,499
an public cloud you name it so how do we

00:16:12,089 --> 00:16:16,769
build it that question was actually

00:16:13,499 --> 00:16:18,480
answered by anti Conte through a

00:16:16,769 --> 00:16:20,970
different sort of work that he was doing

00:16:18,480 --> 00:16:22,860
within that bsd system and his work was

00:16:20,970 --> 00:16:25,170
focused on any Colonels so what he was

00:16:22,860 --> 00:16:29,160
trying to do with the net bsd is to

00:16:25,170 --> 00:16:31,319
basically kind of ria factor it into a

00:16:29,160 --> 00:16:32,970
set of components that can be leveraged

00:16:31,319 --> 00:16:34,829
you know in all different contexts right

00:16:32,970 --> 00:16:36,929
because if you think about it inside of

00:16:34,829 --> 00:16:38,610
your kernel implementation you basically

00:16:36,929 --> 00:16:40,980
have things like let's say tcp/ip stack

00:16:38,610 --> 00:16:43,649
now that piece of code could actually be

00:16:40,980 --> 00:16:45,389
useful stand alone as it is and there is

00:16:43,649 --> 00:16:47,939
absolutely no reason for it not to be

00:16:45,389 --> 00:16:50,129
able to sort of turn into a library and

00:16:47,939 --> 00:16:52,139
you know linked let's say a custom

00:16:50,129 --> 00:16:54,689
tcp/ip stack into an application that's

00:16:52,139 --> 00:16:55,679
running even user space mode so what and

00:16:54,689 --> 00:16:58,619
he was doing he was basically

00:16:55,679 --> 00:17:00,420
refactoring the build of the net bsd to

00:16:58,619 --> 00:17:02,550
make net bsd essential a much more

00:17:00,420 --> 00:17:04,699
granular and be able to expert those

00:17:02,550 --> 00:17:08,579
useful bits and pieces you know to other

00:17:04,699 --> 00:17:09,899
use cases so that's actually what i see

00:17:08,579 --> 00:17:11,520
when i talk about him because you know

00:17:09,899 --> 00:17:13,380
in a way for those of you who are

00:17:11,520 --> 00:17:15,870
familiar with futurama you know aunty is

00:17:13,380 --> 00:17:17,640
basically back le docteur of net bsd you

00:17:15,870 --> 00:17:20,100
kind of like just you know cut net bsd

00:17:17,640 --> 00:17:21,449
into a whole bunch of organs and you

00:17:20,100 --> 00:17:23,069
know you can actually still run their

00:17:21,449 --> 00:17:24,449
bsd that way you know you can kind of

00:17:23,069 --> 00:17:26,520
like put it back together and that would

00:17:24,449 --> 00:17:28,350
be a sort of an operating system or you

00:17:26,520 --> 00:17:32,700
can basically use it in all sorts of

00:17:28,350 --> 00:17:34,770
different places as well so Judy curls

00:17:32,700 --> 00:17:37,080
either way you build it either through

00:17:34,770 --> 00:17:39,179
any kernel or a specialized kernel is

00:17:37,080 --> 00:17:41,039
basically a couple of implementations

00:17:39,179 --> 00:17:42,779
that you can get today and you know you

00:17:41,039 --> 00:17:44,299
can start playing with it so the

00:17:42,779 --> 00:17:47,460
granddaddy of them all you know that's

00:17:44,299 --> 00:17:49,919
the implementation from which the 2013

00:17:47,460 --> 00:17:53,610
paper you know got a sort of published

00:17:49,919 --> 00:17:55,710
is in mirage eos it is sort of a Zen

00:17:53,610 --> 00:17:57,390
based you know thing that was actually

00:17:55,710 --> 00:17:59,279
developed you know by a group of people

00:17:57,390 --> 00:18:01,350
in cambridge you know around sort of a

00:17:59,279 --> 00:18:03,299
camel so everything that you do has to

00:18:01,350 --> 00:18:04,679
be a no camel but if you sort of

00:18:03,299 --> 00:18:06,270
subscribe to that notion you actually

00:18:04,679 --> 00:18:08,429
give a pretty decent amount of

00:18:06,270 --> 00:18:10,470
optimizations you know that you can pull

00:18:08,429 --> 00:18:12,720
off so again a good example would be so

00:18:10,470 --> 00:18:15,120
suppose your application doesn't need

00:18:12,720 --> 00:18:18,240
let's say UDP you know don't need to say

00:18:15,120 --> 00:18:20,160
you know send UDP packets right these

00:18:18,240 --> 00:18:21,570
compiler can analyze you know the

00:18:20,160 --> 00:18:24,570
dependency chain and basically figure

00:18:21,570 --> 00:18:26,070
out that the colonel doesn't need to

00:18:24,570 --> 00:18:28,170
have that part of the sort of tcp/ip

00:18:26,070 --> 00:18:29,940
stack and just like a static linker

00:18:28,170 --> 00:18:31,710
wouldn't link an object file that you

00:18:29,940 --> 00:18:33,059
don't need it wouldn't actually link you

00:18:31,710 --> 00:18:35,250
know the poor portion of the tcp/ip

00:18:33,059 --> 00:18:37,309
stack that deals with UDP so stuff like

00:18:35,250 --> 00:18:40,200
that but again you have to basically a

00:18:37,309 --> 00:18:42,300
kind of you know jump into o camel and

00:18:40,200 --> 00:18:43,590
certain people like it you know I don't

00:18:42,300 --> 00:18:45,809
really have an opinion one way or the

00:18:43,590 --> 00:18:47,370
other so then there is Clive again it's

00:18:45,809 --> 00:18:49,320
a research project out of university of

00:18:47,370 --> 00:18:53,070
madrid so they're trying to do a eunuch

00:18:49,320 --> 00:18:54,809
kernel based on a go operating system so

00:18:53,070 --> 00:18:56,490
you know there is some lineage you know

00:18:54,809 --> 00:18:57,809
going back to plan 9 so it's kind of

00:18:56,490 --> 00:19:00,809
like the same research group that did

00:18:57,809 --> 00:19:02,250
plan B it's a very nice system because

00:19:00,809 --> 00:19:03,600
at least it sort of deals with the

00:19:02,250 --> 00:19:05,820
language that everybody is familiar with

00:19:03,600 --> 00:19:08,820
but it's still pretty research in nature

00:19:05,820 --> 00:19:10,740
so like I said Rahm Colonels is sort of

00:19:08,820 --> 00:19:13,170
anti Conte's way of doing sort of you

00:19:10,740 --> 00:19:15,630
the kernels and then osv is what we will

00:19:13,170 --> 00:19:17,790
be talking today about but before I

00:19:15,630 --> 00:19:19,230
actually start talking about osv because

00:19:17,790 --> 00:19:20,970
you have this you know great collection

00:19:19,230 --> 00:19:23,309
of technology that provides you

00:19:20,970 --> 00:19:25,770
capabilities of doing unique kernels a

00:19:23,309 --> 00:19:28,710
way to essentially manage it emerged and

00:19:25,770 --> 00:19:30,710
this is the project of unique it's

00:19:28,710 --> 00:19:32,880
basically think of it as a GCC toolchain

00:19:30,710 --> 00:19:34,980
you know for different kind of unique

00:19:32,880 --> 00:19:36,840
URLs right so basically this project

00:19:34,980 --> 00:19:39,300
allows you to essentially focus your on

00:19:36,840 --> 00:19:40,470
your application instead of on focusing

00:19:39,300 --> 00:19:42,510
on sort of the differences between

00:19:40,470 --> 00:19:44,910
different unique kernels and how to run

00:19:42,510 --> 00:19:47,640
them so you get a decent sort of command

00:19:44,910 --> 00:19:51,270
line utility to basically play with all

00:19:47,640 --> 00:19:53,490
of them at once and today it supports

00:19:51,270 --> 00:19:55,620
osv and Trump but they actually building

00:19:53,490 --> 00:19:57,570
a lot of you know support into unique

00:19:55,620 --> 00:19:59,760
and actually really like it for two

00:19:57,570 --> 00:20:02,070
reasons first of all it has a docker API

00:19:59,760 --> 00:20:03,809
so a docker client can actually

00:20:02,070 --> 00:20:05,670
manipulate unique Colonel thinking that

00:20:03,809 --> 00:20:07,710
it's talking to the doctor demon and

00:20:05,670 --> 00:20:09,450
second of all this project is actually

00:20:07,710 --> 00:20:11,429
what we're prototyping as a back-end for

00:20:09,450 --> 00:20:13,800
cloud foundry so that sort of

00:20:11,429 --> 00:20:15,120
introduction that I've done around you

00:20:13,800 --> 00:20:16,860
know how cloud foundry scales the

00:20:15,120 --> 00:20:18,720
applications unique is likely to be the

00:20:16,860 --> 00:20:22,080
implementation that we will prototype it

00:20:18,720 --> 00:20:24,000
around so take a look at it now let's

00:20:22,080 --> 00:20:25,260
focus on osv because that's you know the

00:20:24,000 --> 00:20:26,850
subject of today's talk and that's

00:20:25,260 --> 00:20:29,340
actually to me the most interesting of

00:20:26,850 --> 00:20:31,360
the unique kernels out there so what is

00:20:29,340 --> 00:20:33,040
OS V so V is

00:20:31,360 --> 00:20:35,950
the colonel focusing on POSIX

00:20:33,040 --> 00:20:38,650
functionality so the idea behind osv is

00:20:35,950 --> 00:20:41,320
that you should be able to take anything

00:20:38,650 --> 00:20:44,140
that is a POSIX application completely

00:20:41,320 --> 00:20:46,900
unmodified and essentially link it with

00:20:44,140 --> 00:20:49,120
the library that hv gives you and turn

00:20:46,900 --> 00:20:50,710
the whole image into essentially an

00:20:49,120 --> 00:20:52,809
application that will be like i said

00:20:50,710 --> 00:20:55,600
running inside of the same address space

00:20:52,809 --> 00:20:57,190
you know enduring zero but any kind of

00:20:55,600 --> 00:20:59,920
POSIX system call that you do would

00:20:57,190 --> 00:21:01,780
still be supported it runs on top of kvm

00:20:59,920 --> 00:21:04,600
Zen VirtualBox vmware so basically full

00:21:01,780 --> 00:21:06,429
gamut and it's pretty fast you know it's

00:21:04,600 --> 00:21:08,140
unicron's go but it's not as small as

00:21:06,429 --> 00:21:09,910
something like Oh camo because again

00:21:08,140 --> 00:21:11,140
POSIX is actually pretty big standard

00:21:09,910 --> 00:21:14,679
you know you have to provide a lot of

00:21:11,140 --> 00:21:16,950
functionality to be POSIX compliant so

00:21:14,679 --> 00:21:19,299
we see manifesto you know very quickly

00:21:16,950 --> 00:21:21,340
they have an explicit goal of running

00:21:19,299 --> 00:21:22,780
existing Linux applications so the only

00:21:21,340 --> 00:21:24,130
thing and I will talk about it you know

00:21:22,780 --> 00:21:25,450
a little bit later the only thing you

00:21:24,130 --> 00:21:27,790
have to do to an existing Linux

00:21:25,450 --> 00:21:29,650
application is if you have a bill that

00:21:27,790 --> 00:21:31,690
produces you know a dot out you know

00:21:29,650 --> 00:21:33,549
kind of sort of elf executable you need

00:21:31,690 --> 00:21:36,040
to modify that bill to start producing

00:21:33,549 --> 00:21:37,870
shared object you know with the special

00:21:36,040 --> 00:21:39,880
entry point so that the dynamic linker

00:21:37,870 --> 00:21:42,010
that is running inside OS we can sort of

00:21:39,880 --> 00:21:43,510
you know dynamically load it and start

00:21:42,010 --> 00:21:46,360
executing it but that's literally the

00:21:43,510 --> 00:21:48,179
only change that you have to make so

00:21:46,360 --> 00:21:50,410
they're trying to make boot time

00:21:48,179 --> 00:21:52,360
comparable to the execution time so

00:21:50,410 --> 00:21:55,650
basically they're explicit ball is it

00:21:52,360 --> 00:21:58,210
should take osv unique colonel to boot

00:21:55,650 --> 00:22:00,250
the application you know the same amount

00:21:58,210 --> 00:22:01,840
of time that it takes the real operating

00:22:00,250 --> 00:22:03,700
system to actually execute the very same

00:22:01,840 --> 00:22:06,940
application and they are trying to stay

00:22:03,700 --> 00:22:09,370
open so the group that is doing it was

00:22:06,940 --> 00:22:11,890
actually the same group that did kvm

00:22:09,370 --> 00:22:13,510
implementation in Linux so they used to

00:22:11,890 --> 00:22:15,190
be really focused on Louis V they still

00:22:13,510 --> 00:22:16,150
pretty focused on ASV but i think you

00:22:15,190 --> 00:22:18,910
know they are now shifting their focus

00:22:16,150 --> 00:22:20,770
so if you guys are liking what i'm

00:22:18,910 --> 00:22:22,660
talking about today you know jump on the

00:22:20,770 --> 00:22:24,490
github and you know help sort of with

00:22:22,660 --> 00:22:25,870
voice v development because the focuses

00:22:24,490 --> 00:22:27,640
shifting a little bit again it's not

00:22:25,870 --> 00:22:29,520
that the project is being dropped it's

00:22:27,640 --> 00:22:32,710
just you know that we need more sort of

00:22:29,520 --> 00:22:34,600
volunteers to help OHV go along so

00:22:32,710 --> 00:22:35,980
what's inside so you know let's just

00:22:34,600 --> 00:22:37,840
talk about you know how it's all

00:22:35,980 --> 00:22:39,429
implemented so like I said you know it's

00:22:37,840 --> 00:22:42,160
basically an image right you know it's

00:22:39,429 --> 00:22:44,590
the same image that let's say you're

00:22:42,160 --> 00:22:45,070
sort of fool you know virtualization

00:22:44,590 --> 00:22:47,289
build with

00:22:45,070 --> 00:22:48,970
produced when you're producing vmdk or

00:22:47,289 --> 00:22:50,230
any kind of your disc image to be

00:22:48,970 --> 00:22:52,690
basically booted on one of those

00:22:50,230 --> 00:22:55,149
virtualization solutions so inside of

00:22:52,690 --> 00:22:56,889
that image you basically have C++ kernel

00:22:55,149 --> 00:22:58,389
code you know written from scratch so

00:22:56,889 --> 00:23:00,309
that's the difference between sort of an

00:22:58,389 --> 00:23:02,289
any colonel approach because in the end

00:23:00,309 --> 00:23:04,630
colonel approach that kernel code would

00:23:02,289 --> 00:23:07,000
be taken from neb bsd so that's sort of

00:23:04,630 --> 00:23:08,409
how they do it in the oil swiss case you

00:23:07,000 --> 00:23:10,480
know they wrote the kernel code from

00:23:08,409 --> 00:23:12,340
scratch it's c++ c plus plus 11 it's

00:23:10,480 --> 00:23:14,529
actually pretty clean sort of nice C++

00:23:12,340 --> 00:23:16,360
so again if you like you know C++ you

00:23:14,529 --> 00:23:19,899
know that's one of the nicer projects

00:23:16,360 --> 00:23:22,840
you know to get to get to go ad so then

00:23:19,899 --> 00:23:24,700
there's basically a dynamic linker that

00:23:22,840 --> 00:23:26,679
links you know a whole bunch of shared

00:23:24,700 --> 00:23:28,509
object remember how I told you that the

00:23:26,679 --> 00:23:30,340
only sort of change that you have to

00:23:28,509 --> 00:23:32,110
make to your existing application is to

00:23:30,340 --> 00:23:33,820
turn it into a shared object so

00:23:32,110 --> 00:23:36,490
basically there is a shared object for

00:23:33,820 --> 00:23:38,289
you know things like lib JVM if you're

00:23:36,490 --> 00:23:39,879
running a java application and then

00:23:38,289 --> 00:23:42,190
there is a whole bunch of modules that

00:23:39,879 --> 00:23:44,139
implement you know typical functionality

00:23:42,190 --> 00:23:46,440
of the operating system like being able

00:23:44,139 --> 00:23:49,870
for example to talk to a file system

00:23:46,440 --> 00:23:51,580
what's interesting about osv is that

00:23:49,870 --> 00:23:54,789
they decided to take a filesystem are

00:23:51,580 --> 00:23:57,100
you know from open ZFS project actually

00:23:54,789 --> 00:23:58,450
by the way of you know net bsd but still

00:23:57,100 --> 00:24:00,659
so it's a full-fledged EFS

00:23:58,450 --> 00:24:03,370
implementation wish again nowadays that

00:24:00,659 --> 00:24:05,679
ubuntu a shipping ZFS it's not sort of

00:24:03,370 --> 00:24:06,940
that super cool but it used to be that

00:24:05,679 --> 00:24:08,620
you can actually do a lot of cool things

00:24:06,940 --> 00:24:10,450
with ZFS like you know snapshot

00:24:08,620 --> 00:24:12,220
rollbacks sort of within this unique

00:24:10,450 --> 00:24:14,049
oral approach which again to me is you

00:24:12,220 --> 00:24:15,549
know really really cool and then there

00:24:14,049 --> 00:24:17,590
is a bunch of kernel threads and a bunch

00:24:15,549 --> 00:24:19,120
of user friends but again the point is

00:24:17,590 --> 00:24:21,159
all of them are running in the same user

00:24:19,120 --> 00:24:23,529
space right what does it mean it means

00:24:21,159 --> 00:24:25,840
that if you have a pointer arithmetic

00:24:23,529 --> 00:24:29,259
you know bug in your user code that can

00:24:25,840 --> 00:24:31,269
totally crash your colonel why it's not

00:24:29,259 --> 00:24:35,679
a problem because the colonel does not

00:24:31,269 --> 00:24:37,840
multiplex between different processes so

00:24:35,679 --> 00:24:41,019
speaking of which a couple of things

00:24:37,840 --> 00:24:42,669
that ways we absolutely cannot do so it

00:24:41,019 --> 00:24:44,500
is not a hundred percent replacement for

00:24:42,669 --> 00:24:46,419
linux kernel for obvious reasons so for

00:24:44,500 --> 00:24:48,220
example for king is not allowed because

00:24:46,419 --> 00:24:49,840
again the whole idea of working is to

00:24:48,220 --> 00:24:51,820
basically create a copy of the you know

00:24:49,840 --> 00:24:53,710
address space an essential started

00:24:51,820 --> 00:24:55,179
process with this sort of existing copy

00:24:53,710 --> 00:24:57,220
of the address space but started in a

00:24:55,179 --> 00:24:58,480
separate sort of every space so that the

00:24:57,220 --> 00:25:00,070
mediations the

00:24:58,480 --> 00:25:02,679
the child does you know are not visible

00:25:00,070 --> 00:25:03,970
to the parent so that is absolutely not

00:25:02,679 --> 00:25:05,260
allowed because we're still running in

00:25:03,970 --> 00:25:06,820
the same address space you know we're

00:25:05,260 --> 00:25:08,860
running everything in there so there's

00:25:06,820 --> 00:25:10,990
no process isolation there is no sort of

00:25:08,860 --> 00:25:13,270
process isolation not even just between

00:25:10,990 --> 00:25:15,490
processes but we between a process and a

00:25:13,270 --> 00:25:18,130
kernel again your process can crash the

00:25:15,490 --> 00:25:20,500
kernel which by the way means that the

00:25:18,130 --> 00:25:23,890
best things that are sort of voice v

00:25:20,500 --> 00:25:25,720
native things that don't allow you to do

00:25:23,890 --> 00:25:27,850
memory manipulation from the user code

00:25:25,720 --> 00:25:30,220
so things like Java ago I actually a

00:25:27,850 --> 00:25:32,200
really good fit for AC you can still run

00:25:30,220 --> 00:25:34,870
your C and C++ applications but like I

00:25:32,200 --> 00:25:36,910
said you know anything that would result

00:25:34,870 --> 00:25:38,260
a lake or a dump in a traditional

00:25:36,910 --> 00:25:41,410
operating system would result in the

00:25:38,260 --> 00:25:44,169
whole image crashing here again in this

00:25:41,410 --> 00:25:46,540
approach where you kind of sort of blast

00:25:44,169 --> 00:25:48,669
these droplets on the cloud platform

00:25:46,540 --> 00:25:50,830
that is not a problem because in that

00:25:48,669 --> 00:25:53,080
approach you know your container or your

00:25:50,830 --> 00:25:56,320
unique kernel or the you know process

00:25:53,080 --> 00:25:57,970
running on the traditional UNIX is

00:25:56,320 --> 00:26:00,490
basically doing one thing and one thing

00:25:57,970 --> 00:26:02,230
only so in a way a core dump is

00:26:00,490 --> 00:26:03,850
indistinguishable from the whole thing

00:26:02,230 --> 00:26:05,559
crashing because there is nothing else

00:26:03,850 --> 00:26:07,450
that is essential running within the

00:26:05,559 --> 00:26:09,130
same sort of container operating system

00:26:07,450 --> 00:26:12,220
or you know whatever it is that you're

00:26:09,130 --> 00:26:14,080
running and obviously you know this has

00:26:12,220 --> 00:26:15,490
the least amount of drivers because

00:26:14,080 --> 00:26:17,169
basically the only thing that it

00:26:15,490 --> 00:26:19,090
understands its central of virtualized

00:26:17,169 --> 00:26:21,070
drivers right so the Vorta yo is the

00:26:19,090 --> 00:26:23,200
only driver that this Unicron Oh

00:26:21,070 --> 00:26:25,450
understands again not a problem with the

00:26:23,200 --> 00:26:27,910
anti-countess approach because his idea

00:26:25,450 --> 00:26:30,730
is you know if you want a driver it is

00:26:27,910 --> 00:26:33,250
available in the net Bhd's source code

00:26:30,730 --> 00:26:35,320
base so once you run sort of linking the

00:26:33,250 --> 00:26:37,030
any colonel together you can totally

00:26:35,320 --> 00:26:41,950
just lift the driver and you know start

00:26:37,030 --> 00:26:44,710
using it ah it is actually pretty well

00:26:41,950 --> 00:26:47,919
suited for applications that are network

00:26:44,710 --> 00:26:49,990
intensive it is not you know that's much

00:26:47,919 --> 00:26:51,250
sort of suited for the applications that

00:26:49,990 --> 00:26:54,640
are compute intensive and for obvious

00:26:51,250 --> 00:26:56,620
reasons you know basically if all you do

00:26:54,640 --> 00:26:58,240
is compute you know any amount of

00:26:56,620 --> 00:27:00,549
virtualization without will only hurt

00:26:58,240 --> 00:27:02,230
you the real question is like why does

00:27:00,549 --> 00:27:06,309
it actually helped with the network so

00:27:02,230 --> 00:27:09,309
let me go through some of the point here

00:27:06,309 --> 00:27:11,710
so in a traditional Linux kernel two

00:27:09,309 --> 00:27:14,409
problems exist first of all the tea

00:27:11,710 --> 00:27:16,480
PAP stag has to explicitly allow for

00:27:14,409 --> 00:27:17,950
multiplexing between different processes

00:27:16,480 --> 00:27:21,039
essentially different clients on the

00:27:17,950 --> 00:27:23,049
system nothing like that is needed in

00:27:21,039 --> 00:27:25,270
the Oasis implementation because again

00:27:23,049 --> 00:27:30,279
remember there is only one process and

00:27:25,270 --> 00:27:33,039
only one every space also because they

00:27:30,279 --> 00:27:34,510
could implement it from scratch what

00:27:33,039 --> 00:27:37,390
they did they essentially took the idea

00:27:34,510 --> 00:27:39,190
that van jacobson sort of proposed as

00:27:37,390 --> 00:27:40,690
net channels and i think you know it

00:27:39,190 --> 00:27:42,279
kind of sort of got rejected in its

00:27:40,690 --> 00:27:43,330
entirety by the Linux community because

00:27:42,279 --> 00:27:45,429
it would just require too much

00:27:43,330 --> 00:27:46,779
modifications of the Linux kernel but

00:27:45,429 --> 00:27:48,880
the oils V guys you know could actually

00:27:46,779 --> 00:27:51,809
implement it and what it does it

00:27:48,880 --> 00:27:54,399
essentially allows them to run extremely

00:27:51,809 --> 00:27:56,860
quickly through the code that is

00:27:54,399 --> 00:27:59,980
typically part of the colonel you know

00:27:56,860 --> 00:28:01,390
tcp/ip stack code what it means is and

00:27:59,980 --> 00:28:03,070
you know that actually was a surprising

00:28:01,390 --> 00:28:05,830
result of one of the profiling what it

00:28:03,070 --> 00:28:09,309
means is that because the code path is

00:28:05,830 --> 00:28:12,850
sho short the data that arrived on

00:28:09,309 --> 00:28:15,220
unique doesn't actually leave the I cash

00:28:12,850 --> 00:28:17,350
by the time the application thread gets

00:28:15,220 --> 00:28:18,399
to see that data so what typically

00:28:17,350 --> 00:28:20,080
happens in a traditional operating

00:28:18,399 --> 00:28:22,210
system kernel is that by the time the

00:28:20,080 --> 00:28:24,190
application sees the data the data has

00:28:22,210 --> 00:28:25,720
already yellow sort of got evicted from

00:28:24,190 --> 00:28:27,159
I care for also the reason just because

00:28:25,720 --> 00:28:28,809
you know the code path is so long

00:28:27,159 --> 00:28:30,279
through the kernel right here it doesn't

00:28:28,809 --> 00:28:32,200
happen and that's one of the reasons

00:28:30,279 --> 00:28:34,240
that the i/o intensive applications

00:28:32,200 --> 00:28:36,760
actually running much faster and I see

00:28:34,240 --> 00:28:39,039
so memory management is also interesting

00:28:36,760 --> 00:28:40,779
on is V so again in a traditional sort

00:28:39,039 --> 00:28:42,669
of operating system you basically have

00:28:40,779 --> 00:28:44,649
an OS image and then you have different

00:28:42,669 --> 00:28:46,179
processes and then you have sort of like

00:28:44,649 --> 00:28:49,480
something like JVM you know sort of

00:28:46,179 --> 00:28:51,039
manipulating memory in its own right of

00:28:49,480 --> 00:28:52,270
course in osv we don't have the other

00:28:51,039 --> 00:28:55,000
process so the picture gets I'm

00:28:52,270 --> 00:28:55,960
simplified so we have just one process

00:28:55,000 --> 00:28:57,970
memory which is actually

00:28:55,960 --> 00:29:00,909
indistinguishable from the OS memory and

00:28:57,970 --> 00:29:02,500
we have something like JVM but a trick

00:29:00,909 --> 00:29:04,090
that the osv guys are pulling is

00:29:02,500 --> 00:29:06,190
actually kind of interesting so they

00:29:04,090 --> 00:29:08,230
decided to flip the relationship between

00:29:06,190 --> 00:29:11,350
the operating system and the client code

00:29:08,230 --> 00:29:14,710
so instead of trying to guess how much

00:29:11,350 --> 00:29:16,570
memory do you give to JVM you give all

00:29:14,710 --> 00:29:19,240
of the memory to JVM and then you

00:29:16,570 --> 00:29:21,850
essentially allocate a dummy a peck

00:29:19,240 --> 00:29:24,250
object that the operating system can use

00:29:21,850 --> 00:29:25,630
for its own needs why and how well

00:29:24,250 --> 00:29:27,700
because it's all in the same address

00:29:25,630 --> 00:29:30,010
days so basically from the standpoint of

00:29:27,700 --> 00:29:31,720
the JVM this is just a byte array that

00:29:30,010 --> 00:29:33,340
exists and it has a reference that

00:29:31,720 --> 00:29:35,380
cannot really be garbage collected ever

00:29:33,340 --> 00:29:37,330
from the operating system standpoint

00:29:35,380 --> 00:29:39,250
it's a chunk of memory that it can use

00:29:37,330 --> 00:29:40,540
for its own needs so basically again it

00:29:39,250 --> 00:29:42,100
completely flips the relationship

00:29:40,540 --> 00:29:43,720
between sort of how much memory is

00:29:42,100 --> 00:29:45,040
allocated to the application versus how

00:29:43,720 --> 00:29:49,000
much memory is allocated to the

00:29:45,040 --> 00:29:51,130
operating system kernel another thing

00:29:49,000 --> 00:29:54,190
that is actually pretty cool is because

00:29:51,130 --> 00:29:55,900
everything is running in ring 0 all of

00:29:54,190 --> 00:29:58,030
the CPU capabilities that are typically

00:29:55,900 --> 00:30:01,180
occupied by a real operating system

00:29:58,030 --> 00:30:04,300
kernel like let's say mm you are now

00:30:01,180 --> 00:30:06,040
available to the application code what

00:30:04,300 --> 00:30:07,900
it allows them to do is for example it

00:30:06,040 --> 00:30:09,670
allows them to do optimizations on the

00:30:07,900 --> 00:30:11,140
garbage collection side because again

00:30:09,670 --> 00:30:12,610
you know if you think about how garbage

00:30:11,140 --> 00:30:13,990
collection works in Java is basically

00:30:12,610 --> 00:30:17,230
you know we have object one you know

00:30:13,990 --> 00:30:19,600
keeping a reference on object to now if

00:30:17,230 --> 00:30:21,250
that reference breaks how could it

00:30:19,600 --> 00:30:23,470
possibly happen well you know the

00:30:21,250 --> 00:30:26,740
pointer that was pointing from you know

00:30:23,470 --> 00:30:29,020
object one to object to God nullified so

00:30:26,740 --> 00:30:31,860
that is a memory access and if we have

00:30:29,020 --> 00:30:34,690
an MMU capability available to us in the

00:30:31,860 --> 00:30:36,310
application we can actually track that

00:30:34,690 --> 00:30:38,640
memory access the same way that the

00:30:36,310 --> 00:30:42,130
operating system is tracking access for

00:30:38,640 --> 00:30:46,180
paging so essentially we can basically a

00:30:42,130 --> 00:30:48,250
trap inside of an MMU based on the

00:30:46,180 --> 00:30:50,380
memory access and thus essentially keep

00:30:48,250 --> 00:30:51,820
it bit vector of everything that ever

00:30:50,380 --> 00:30:53,410
got updated so that the garbage

00:30:51,820 --> 00:30:55,900
collector doesn't have to guess which

00:30:53,410 --> 00:30:59,530
object got updated and which ones didn't

00:30:55,900 --> 00:31:01,870
so again helps a really sort of a big

00:30:59,530 --> 00:31:04,090
time with garbage collection pauses all

00:31:01,870 --> 00:31:05,500
of what I'm talking about is still very

00:31:04,090 --> 00:31:06,880
much your research right you know it's

00:31:05,500 --> 00:31:09,820
kind of like cool capabilities that are

00:31:06,880 --> 00:31:11,470
possible now we haven't really sort of

00:31:09,820 --> 00:31:14,290
try to run it you know to the full

00:31:11,470 --> 00:31:17,050
possible extent essentially kind of like

00:31:14,290 --> 00:31:19,180
just stressing them right but what's

00:31:17,050 --> 00:31:25,270
available and at first what is possible

00:31:19,180 --> 00:31:27,370
is kind of cool in its own right so by

00:31:25,270 --> 00:31:31,270
the way how how am i doing on time is I

00:31:27,370 --> 00:31:32,980
can do five minutes left okay awesome so

00:31:31,270 --> 00:31:35,170
I mean yeah apologize for speaking in

00:31:32,980 --> 00:31:37,780
all really quickly but I'm actually sort

00:31:35,170 --> 00:31:39,430
of kind of almost done you know trying

00:31:37,780 --> 00:31:41,170
to impress you with our three so hopeful

00:31:39,430 --> 00:31:42,580
you know I've done enough of it so that

00:31:41,170 --> 00:31:44,580
you guys at least check out the code

00:31:42,580 --> 00:31:47,470
base and you know check out the examples

00:31:44,580 --> 00:31:48,700
the real question is we actually seen it

00:31:47,470 --> 00:31:50,650
before so I used to work for sun

00:31:48,700 --> 00:31:52,420
microsystems you know way back when sort

00:31:50,650 --> 00:31:54,130
of I didn't quite catch you know the

00:31:52,420 --> 00:31:56,440
time when Java got invented but you know

00:31:54,130 --> 00:31:57,850
I was reasonably close to it and son

00:31:56,440 --> 00:31:59,710
actually had a number of projects where

00:31:57,850 --> 00:32:01,210
we try to run Java on bare metal right

00:31:59,710 --> 00:32:03,490
you know we try to actually come up with

00:32:01,210 --> 00:32:05,410
the CPU that would try to run Java there

00:32:03,490 --> 00:32:07,360
was a company still is you know called

00:32:05,410 --> 00:32:10,090
Azul that is sort of trying to do that

00:32:07,360 --> 00:32:12,070
and nothing really stuck right you know

00:32:10,090 --> 00:32:14,140
we don't really have Java native CPUs

00:32:12,070 --> 00:32:16,450
Java is still very much of an

00:32:14,140 --> 00:32:18,640
application you know software thing so

00:32:16,450 --> 00:32:20,320
why should it work this time I think you

00:32:18,640 --> 00:32:21,670
know back when Sun was doing it we

00:32:20,320 --> 00:32:25,420
actually didn't have a couple of things

00:32:21,670 --> 00:32:27,400
so first of all um we actually didn't

00:32:25,420 --> 00:32:29,200
have you know as well developed

00:32:27,400 --> 00:32:31,150
hardware-assisted virtualization as we

00:32:29,200 --> 00:32:33,130
have today and what I mean by that is

00:32:31,150 --> 00:32:35,050
all of these sort of CPU capabilities

00:32:33,130 --> 00:32:37,180
that intel has pushed into the just you

00:32:35,050 --> 00:32:39,040
know run-of-the-mill you know intel

00:32:37,180 --> 00:32:42,580
chips that are now available and

00:32:39,040 --> 00:32:43,810
essentially making io especially you

00:32:42,580 --> 00:32:46,240
know efficient in virtualized

00:32:43,810 --> 00:32:48,190
environments we didn't have elastic

00:32:46,240 --> 00:32:50,380
infrastructure obviously you know back

00:32:48,190 --> 00:32:53,680
then something like cloud was not really

00:32:50,380 --> 00:32:56,500
you know available and to me the

00:32:53,680 --> 00:32:59,170
ultimate sort of point that i think will

00:32:56,500 --> 00:33:01,270
make a difference this time is we didn't

00:32:59,170 --> 00:33:03,430
have something like a platform as a

00:33:01,270 --> 00:33:05,620
service component that would actually

00:33:03,430 --> 00:33:08,110
completely hide all of that complexity

00:33:05,620 --> 00:33:10,060
of how the application gets linked into

00:33:08,110 --> 00:33:12,370
an executable image away from the

00:33:10,060 --> 00:33:13,810
application developer and we really need

00:33:12,370 --> 00:33:16,930
this piece of technology and you know

00:33:13,810 --> 00:33:19,960
why because what I'm talking about it's

00:33:16,930 --> 00:33:21,910
just this tiny portion inside of what a

00:33:19,960 --> 00:33:24,730
typical platform as a service you know

00:33:21,910 --> 00:33:26,620
software component does right so all I'm

00:33:24,730 --> 00:33:29,170
talking about today is how this stuff

00:33:26,620 --> 00:33:30,640
gets linked and how it runs but the

00:33:29,170 --> 00:33:32,400
platform is the service actually takes

00:33:30,640 --> 00:33:35,470
care of a lot of other developer needs

00:33:32,400 --> 00:33:37,150
routing you know log collection tracing

00:33:35,470 --> 00:33:39,370
and all of the capabilities that

00:33:37,150 --> 00:33:40,900
essentially Brian took an issue with

00:33:39,370 --> 00:33:43,420
when he was talking about unicorns

00:33:40,900 --> 00:33:45,160
because his idea is that unique kernels

00:33:43,420 --> 00:33:47,910
if you view them as a replacement for

00:33:45,160 --> 00:33:50,710
traditional applications are essentially

00:33:47,910 --> 00:33:52,930
completely unobservable and very

00:33:50,710 --> 00:33:53,799
difficult to debug and I actually

00:33:52,930 --> 00:33:56,230
absolutely agree

00:33:53,799 --> 00:33:57,879
that if you are trying to just run it as

00:33:56,230 --> 00:34:00,340
a replacement to your traditional sort

00:33:57,879 --> 00:34:02,830
of application you know life cycle it's

00:34:00,340 --> 00:34:03,999
not a particularly good idea but if

00:34:02,830 --> 00:34:05,889
you're already embracing

00:34:03,999 --> 00:34:07,960
platform-as-a-service then you are

00:34:05,889 --> 00:34:09,909
giving up on those capabilities anyway

00:34:07,960 --> 00:34:12,010
because in a platform of a service it's

00:34:09,909 --> 00:34:14,349
the platform itself that makes you

00:34:12,010 --> 00:34:15,909
observe the application that makes you

00:34:14,349 --> 00:34:17,799
see the logs that are coming from the

00:34:15,909 --> 00:34:19,599
application because in a platform as a

00:34:17,799 --> 00:34:22,089
service the application has been

00:34:19,599 --> 00:34:24,099
essentially sliced and diced in bits and

00:34:22,089 --> 00:34:26,440
pieces that only platform knows about

00:34:24,099 --> 00:34:28,540
and you have to query the platform there

00:34:26,440 --> 00:34:31,299
is no way you can ssh in one of those

00:34:28,540 --> 00:34:32,770
droplets that i was showing you so in a

00:34:31,299 --> 00:34:35,230
way if we're running platform as a

00:34:32,770 --> 00:34:37,119
service then all of the unique ronal

00:34:35,230 --> 00:34:38,919
capabilities can be used as optimization

00:34:37,119 --> 00:34:42,369
techniques for making our applications

00:34:38,919 --> 00:34:43,750
run faster so with that I will just

00:34:42,369 --> 00:34:46,149
spend you know two minutes essentially

00:34:43,750 --> 00:34:48,309
kind of sort of telling you about my

00:34:46,149 --> 00:34:50,859
yellow pipe dream vision of a

00:34:48,309 --> 00:34:52,599
next-generation data center to me it's

00:34:50,859 --> 00:34:54,159
basically a commodity Iraq provision

00:34:52,599 --> 00:34:55,540
hardware I mean that's kind of given you

00:34:54,159 --> 00:34:57,819
know that's how most of the data centers

00:34:55,540 --> 00:34:59,349
are built today just enough way s you

00:34:57,819 --> 00:35:01,750
know basically an operating system that

00:34:59,349 --> 00:35:04,690
runs on the hardware and is just a

00:35:01,750 --> 00:35:06,130
simple glorified device driver for all

00:35:04,690 --> 00:35:10,150
of the hardware that it needs to manage

00:35:06,130 --> 00:35:11,589
plus a capability that gives me some

00:35:10,150 --> 00:35:13,930
kind of virtualization could be Samm

00:35:11,589 --> 00:35:15,280
could be kvm I don't care so my

00:35:13,930 --> 00:35:17,140
operating system is something like

00:35:15,280 --> 00:35:19,960
Korres or smart ways you know that's

00:35:17,140 --> 00:35:23,109
sort of the Solaris you know equivalent

00:35:19,960 --> 00:35:25,720
of core OS and just enough functionality

00:35:23,109 --> 00:35:29,109
to essentially boot this new

00:35:25,720 --> 00:35:31,089
next-generation format that i would like

00:35:29,109 --> 00:35:33,030
to call dr plus plus because if you

00:35:31,089 --> 00:35:36,520
think about what daughter or you know a

00:35:33,030 --> 00:35:38,980
sort of run sea container really is it's

00:35:36,520 --> 00:35:41,020
a different sort of executable format

00:35:38,980 --> 00:35:42,579
and just like elf what's kinda a nice

00:35:41,020 --> 00:35:44,890
way to standardize all of the different

00:35:42,579 --> 00:35:47,079
executable formats on unix is we're now

00:35:44,890 --> 00:35:48,609
sort of having this format that can be

00:35:47,079 --> 00:35:50,619
used and all sorts of virtualized

00:35:48,609 --> 00:35:52,000
environments and then of course on top

00:35:50,619 --> 00:35:53,680
of that you actually have to have

00:35:52,000 --> 00:35:55,000
something like platform as a service so

00:35:53,680 --> 00:35:56,140
Cloud Foundry is a good example but

00:35:55,000 --> 00:35:58,180
there's a couple of other in there in

00:35:56,140 --> 00:36:00,339
the running and that is I think the

00:35:58,180 --> 00:36:02,619
vision of a next-generation datacenter

00:36:00,339 --> 00:36:04,720
and why does it matter I think you know

00:36:02,619 --> 00:36:08,099
because if we go that way then we can

00:36:04,720 --> 00:36:10,180
finally kill DevOps because the

00:36:08,099 --> 00:36:13,030
division of labor between the

00:36:10,180 --> 00:36:15,580
development and IT will be very clear

00:36:13,030 --> 00:36:17,650
the development developed something that

00:36:15,580 --> 00:36:20,740
the platform can manage and the IT

00:36:17,650 --> 00:36:22,630
basically wrecks and you know stacks and

00:36:20,740 --> 00:36:24,670
you know cables and there's really

00:36:22,630 --> 00:36:26,940
nothing in between because the platform

00:36:24,670 --> 00:36:29,290
itself is capable of essentially giving

00:36:26,940 --> 00:36:30,760
such an incredible amount of

00:36:29,290 --> 00:36:32,530
observability insight into your

00:36:30,760 --> 00:36:34,900
application that you don't have to have

00:36:32,530 --> 00:36:36,490
a third team telling you how your

00:36:34,900 --> 00:36:41,260
application behaving introduction or in

00:36:36,490 --> 00:36:43,900
testing snowflakes in this type of data

00:36:41,260 --> 00:36:45,460
center will not exist because again the

00:36:43,900 --> 00:36:48,099
platform will not allow for a snowflake

00:36:45,460 --> 00:36:50,020
you know how screwed up most of the

00:36:48,099 --> 00:36:51,550
doctor files are today developers don't

00:36:50,020 --> 00:36:54,340
actually have to deal with docker files

00:36:51,550 --> 00:36:55,690
in this type of environment so I you

00:36:54,340 --> 00:36:57,190
know I hear that they are already

00:36:55,690 --> 00:36:59,109
clapping in the other room so I guess

00:36:57,190 --> 00:37:00,400
with that I will just open it up for

00:36:59,109 --> 00:37:10,450
questions so thank you so much for

00:37:00,400 --> 00:37:18,339
listening thank you so much do we have

00:37:10,450 --> 00:37:20,230
questions all right maybe I didn't hear

00:37:18,339 --> 00:37:24,099
about everything but when you say you

00:37:20,230 --> 00:37:26,770
run the JVM you have a single core

00:37:24,099 --> 00:37:28,540
everything right no it's a it's actually

00:37:26,770 --> 00:37:30,220
capable capable of multi-core as well

00:37:28,540 --> 00:37:32,920
all right because that's what I went in

00:37:30,220 --> 00:37:36,760
good but by the garbage collector how it

00:37:32,920 --> 00:37:39,760
works if it's not so this particular

00:37:36,760 --> 00:37:43,690
implementation is essentially a set of

00:37:39,760 --> 00:37:45,160
patches on top of OpenJDK that make it

00:37:43,690 --> 00:37:47,530
possible like it's you know it's a

00:37:45,160 --> 00:37:51,160
pretty involved set of patches so you

00:37:47,530 --> 00:37:53,080
cannot really take so with osv because

00:37:51,160 --> 00:37:55,960
all you need is a shared object you do

00:37:53,080 --> 00:37:58,660
have an option of taking liebe liebe JVM

00:37:55,960 --> 00:38:00,520
do so from let's say an oracle you know

00:37:58,660 --> 00:38:02,380
jdk like that's totally an option and

00:38:00,520 --> 00:38:04,839
you can do that but then you won't be

00:38:02,380 --> 00:38:06,369
sort of experiencing all of these

00:38:04,839 --> 00:38:07,930
optimization techniques that i talked

00:38:06,369 --> 00:38:10,030
about you would still for example get

00:38:07,930 --> 00:38:12,490
the benefit of a much shorter code path

00:38:10,030 --> 00:38:14,589
through the tcp/ip stack so those guys

00:38:12,490 --> 00:38:16,720
you know did some measurements of

00:38:14,589 --> 00:38:19,119
Cassandra and Cassandra benefits quite a

00:38:16,720 --> 00:38:20,410
bit even on this talk oracle JVM but for

00:38:19,119 --> 00:38:21,339
the kind of optimizations that i was

00:38:20,410 --> 00:38:24,519
talking about sort of the

00:38:21,339 --> 00:38:26,349
garbage collection and the memory

00:38:24,519 --> 00:38:28,239
ballooning you actually have to get the

00:38:26,349 --> 00:38:31,059
OpenJDK you know with a set of patches

00:38:28,239 --> 00:38:32,920
yea i meant more of a when the garbage

00:38:31,059 --> 00:38:35,859
the garbage collection is running in

00:38:32,920 --> 00:38:38,049
multi cpu mode Oh in multi CPU more

00:38:35,859 --> 00:38:39,549
that's AMS or write that feature is

00:38:38,049 --> 00:38:41,559
actually available only on the single

00:38:39,549 --> 00:38:42,910
core so again in general osv is

00:38:41,559 --> 00:38:46,619
multi-core aware but this particular

00:38:42,910 --> 00:38:46,619
feature is only on the single core yeah

00:38:51,809 --> 00:38:57,150
thank you for the overview I only see

00:38:54,519 --> 00:39:02,859
one issue if you can manipulate

00:38:57,150 --> 00:39:04,299
something running in in a ring 0 from

00:39:02,859 --> 00:39:07,599
the java virtual machines and everything

00:39:04,299 --> 00:39:10,839
is open so you can manipulate every trap

00:39:07,599 --> 00:39:15,099
every low-level thing from from java and

00:39:10,839 --> 00:39:16,779
this is only allowing you running really

00:39:15,099 --> 00:39:21,789
friendly applications you cannot run

00:39:16,779 --> 00:39:26,319
from code because otherwise you get a

00:39:21,789 --> 00:39:28,119
major security well open doors yeah I I

00:39:26,319 --> 00:39:29,529
think we're having different frame of

00:39:28,119 --> 00:39:32,380
references right you know when you know

00:39:29,529 --> 00:39:34,779
if you're if you're on ring 0 you can do

00:39:32,380 --> 00:39:36,460
everything you can replace every trap in

00:39:34,779 --> 00:39:38,559
the operating system so and if you have

00:39:36,460 --> 00:39:40,359
memory manipulated from the Java Virtual

00:39:38,559 --> 00:39:42,640
Machine which is a good issue for a

00:39:40,359 --> 00:39:45,009
performance from the point of view of

00:39:42,640 --> 00:39:48,819
the Java Virtual Machine you can

00:39:45,009 --> 00:39:51,309
manipulate anything on the auditor you

00:39:48,819 --> 00:39:53,979
can replace traps in the operating

00:39:51,309 --> 00:39:56,799
system and this is only for your own

00:39:53,979 --> 00:40:00,549
code not multi-tenant nothing I would

00:39:56,799 --> 00:40:03,190
back nothing yeah you're absolutely

00:40:00,549 --> 00:40:05,710
correct if just random code is allowed

00:40:03,190 --> 00:40:07,839
into this image that because how the

00:40:05,710 --> 00:40:09,609
platform is doing it the platform is

00:40:07,839 --> 00:40:11,349
actually taking the source code and

00:40:09,609 --> 00:40:13,420
everything else is done by the platform

00:40:11,349 --> 00:40:15,670
so all of the bits all of the binary

00:40:13,420 --> 00:40:17,829
bits that I essentially getting into the

00:40:15,670 --> 00:40:19,719
droplet are the binary bits that only

00:40:17,829 --> 00:40:21,670
platform can put into a droplet again no

00:40:19,719 --> 00:40:23,229
more docker files like it's not a docker

00:40:21,670 --> 00:40:25,119
file approach where a developer is

00:40:23,229 --> 00:40:27,039
trying to tell the system how to build

00:40:25,119 --> 00:40:28,630
the image the only thing that developer

00:40:27,039 --> 00:40:30,700
is supplying is the source code for the

00:40:28,630 --> 00:40:32,760
application itself and again even like

00:40:30,700 --> 00:40:35,460
that source code can have bugs

00:40:32,760 --> 00:40:38,880
oh sure obviously but if you are talking

00:40:35,460 --> 00:40:40,650
about sort of exploits it is only if the

00:40:38,880 --> 00:40:42,930
developer puts those exploits in the

00:40:40,650 --> 00:40:45,210
code on purpose then that becomes a

00:40:42,930 --> 00:40:46,830
problem but that is a problem anyway so

00:40:45,210 --> 00:40:49,080
if a developer is basically sort of

00:40:46,830 --> 00:40:51,900
putting exploits inside of a talker

00:40:49,080 --> 00:40:54,750
container you're in trouble anyway

00:40:51,900 --> 00:40:56,490
because deb dr. container can you know

00:40:54,750 --> 00:40:58,200
open network connections that you know

00:40:56,490 --> 00:41:00,990
would send you know random traffic and

00:40:58,200 --> 00:41:02,340
do all sorts of your weird things even

00:41:00,990 --> 00:41:03,870
though within the docker container

00:41:02,340 --> 00:41:10,680
itself I mean there is nothing but the

00:41:03,870 --> 00:41:12,150
user code Thank You Ramon listen

00:41:10,680 --> 00:41:14,580
gentlemen will you please give a round

00:41:12,150 --> 00:41:16,080
of applause to yourself to for helping

00:41:14,580 --> 00:41:18,770
them yes I'm thank you for helping it

00:41:16,080 --> 00:41:18,770

YouTube URL: https://www.youtube.com/watch?v=bsFARLr8is8


