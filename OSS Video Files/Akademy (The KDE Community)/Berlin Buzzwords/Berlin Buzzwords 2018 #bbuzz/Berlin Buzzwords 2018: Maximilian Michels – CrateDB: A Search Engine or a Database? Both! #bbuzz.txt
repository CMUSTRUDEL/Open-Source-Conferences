Title: Berlin Buzzwords 2018: Maximilian Michels – CrateDB: A Search Engine or a Database? Both! #bbuzz
Publication date: 2018-06-18
Playlist: Berlin Buzzwords 2018 #bbuzz
Description: 
	Search engines are databases that specialize in retrieving information from a data corpus. Compared to traditional databases like PostgreSQL, search engines allow to work with text and other unstructured data more efficiently. Projects like Xapian and Apache Lucene can perform efficient indexing and querying of large amounts of documents. Apache Solr and Elasticsearch have added clustering and distributed query execution to scale out the search features.

The most obvious gap between traditional databases and search engines is the query language. Whereas relational databases can typically be queried with SQL, search engines usually implement a custom API.

At CrateDB, we don’t think you should have to give up SQL just because you’re using search engine features. That’s why we created a fully-functional SQL interface on top of Elasticsearch and Apache Lucene. You get all the benefits of traditional databases, as well as the features of a distributed search engine.

Do you want to store huge amounts of data and search it in real time? Do you have unstructured and structured data? Do you want to run distributed joins? Do you want to add nodes and scale your cluster horizontally? Do you want to leverage the power of SQL? If so, CrateDB is a great match.

In this talk, I will give an introduction to CrateDB, its architecture, and show what people have built with it.

Read more:

About Maximilian Michels:
https://2018.berlinbuzzwords.de/users/maximilian-michels-0

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:04,740 --> 00:00:10,920
Thank You Martin so yeah thank you all

00:00:09,610 --> 00:00:14,379
for coming

00:00:10,920 --> 00:00:16,860
so my name is Max as you already know

00:00:14,379 --> 00:00:19,300
and I'm a software engineer at great IO

00:00:16,860 --> 00:00:21,840
and today today I would like to present

00:00:19,300 --> 00:00:25,390
to you create EB it's an open-source

00:00:21,840 --> 00:00:27,369
real-time sequel database and it's

00:00:25,390 --> 00:00:31,240
actually built on top of elastic search

00:00:27,369 --> 00:00:34,060
and the scene and you might wonder if

00:00:31,240 --> 00:00:36,190
you know a life search or the scene why

00:00:34,060 --> 00:00:39,399
would you even do that and does that

00:00:36,190 --> 00:00:42,489
work and well I wouldn't be here if it

00:00:39,399 --> 00:00:45,219
if it didn't but well I can give you a

00:00:42,489 --> 00:00:50,289
hint it works like a charm and let's see

00:00:45,219 --> 00:00:53,440
and find out how it works and and why

00:00:50,289 --> 00:00:57,940
this is a good idea so and why are we

00:00:53,440 --> 00:00:59,320
talking about cry TB so we have on the

00:00:57,940 --> 00:01:01,480
one side we have the traditional

00:00:59,320 --> 00:01:03,340
databases which are very well researched

00:01:01,480 --> 00:01:05,790
they have been running in production for

00:01:03,340 --> 00:01:09,009
centuries and we have open source

00:01:05,790 --> 00:01:13,720
candidates like Postgres my sequel and

00:01:09,009 --> 00:01:15,939
also close ones like Oracle but these

00:01:13,720 --> 00:01:17,500
are not really meant for for search I

00:01:15,939 --> 00:01:19,900
mean you can do full-text search in

00:01:17,500 --> 00:01:22,030
Postgres of course but to do it at this

00:01:19,900 --> 00:01:24,909
in a scalable way and can be quite

00:01:22,030 --> 00:01:27,700
tricky and search engines on the other

00:01:24,909 --> 00:01:30,220
end are like similar kind of like

00:01:27,700 --> 00:01:32,439
specialized databases which are

00:01:30,220 --> 00:01:34,630
optimized for search and the prominent

00:01:32,439 --> 00:01:37,780
of them source ones are a leucine which

00:01:34,630 --> 00:01:39,759
is just well a search library and then

00:01:37,780 --> 00:01:44,369
we have solar or less exert which are

00:01:39,759 --> 00:01:46,960
like search servers search databases and

00:01:44,369 --> 00:01:49,899
these all have like their own career

00:01:46,960 --> 00:01:53,979
languages so they don't use sequel and

00:01:49,899 --> 00:01:55,990
really the question is why why are they

00:01:53,979 --> 00:01:59,049
not using sequel and why do we like

00:01:55,990 --> 00:02:02,259
diverge from from sequel so much just to

00:01:59,049 --> 00:02:06,340
solve like a more specialized database

00:02:02,259 --> 00:02:08,560
problem and well I'm just going to give

00:02:06,340 --> 00:02:11,680
you a brief history of sequel so the

00:02:08,560 --> 00:02:14,050
first sequel draft is actually from 1974

00:02:11,680 --> 00:02:17,710
and ladies's from 2016

00:02:14,050 --> 00:02:18,550
so that means sequel is actually 44

00:02:17,710 --> 00:02:21,730
years old

00:02:18,550 --> 00:02:24,700
I don't know about so much technology or

00:02:21,730 --> 00:02:26,950
software especially which survived that

00:02:24,700 --> 00:02:29,350
long so I think it's fair to say it's

00:02:26,950 --> 00:02:31,690
very mature standard and it is actually

00:02:29,350 --> 00:02:34,870
a great tree specification language so

00:02:31,690 --> 00:02:37,600
why why did we drop it so and the reason

00:02:34,870 --> 00:02:41,620
for that is when no sequel came about

00:02:37,600 --> 00:02:43,090
which is sort of like I mean I would

00:02:41,620 --> 00:02:47,620
consider elasticsearch in no sequel

00:02:43,090 --> 00:02:49,240
database so people basically engineers

00:02:47,620 --> 00:02:53,710
focused on an entirely different problem

00:02:49,240 --> 00:02:55,810
and the problem was more like yeah how

00:02:53,710 --> 00:02:58,570
do we distributed data how do we find it

00:02:55,810 --> 00:03:00,580
again make sure it's not lost the whole

00:02:58,570 --> 00:03:03,010
cap theorem with consistency

00:03:00,580 --> 00:03:06,520
availability petition tolerance I came

00:03:03,010 --> 00:03:09,790
into place and the truth is implementing

00:03:06,520 --> 00:03:12,250
sequel especially distributed sequel is

00:03:09,790 --> 00:03:16,360
very complex it's it's not an easy task

00:03:12,250 --> 00:03:18,970
and and it's way easier to say well

00:03:16,360 --> 00:03:21,850
let's focus on on something on some

00:03:18,970 --> 00:03:25,209
distributed technology and well we can

00:03:21,850 --> 00:03:27,250
just build an API that is well better

00:03:25,209 --> 00:03:30,010
because it's much simpler than sequel

00:03:27,250 --> 00:03:31,750
and after all put and get should be

00:03:30,010 --> 00:03:34,540
enough right I mean everything else you

00:03:31,750 --> 00:03:38,110
can handle in your application and we

00:03:34,540 --> 00:03:43,480
can leave all this old 1974 standard

00:03:38,110 --> 00:03:47,680
behind right and well not quite so easy

00:03:43,480 --> 00:03:49,390
because we actually see sequel returning

00:03:47,680 --> 00:03:52,330
in a lot of places we just saw in the

00:03:49,390 --> 00:03:55,780
Nico's talk about flink about the fling

00:03:52,330 --> 00:03:57,490
sequel API so the truth is that there

00:03:55,780 --> 00:03:59,410
are millions of developers and data

00:03:57,490 --> 00:04:01,990
scientists out there who know sequel

00:03:59,410 --> 00:04:04,330
very well and there are just endless

00:04:01,990 --> 00:04:09,100
tools which which you can use for sequel

00:04:04,330 --> 00:04:12,490
and also it is just very hard to to if

00:04:09,100 --> 00:04:15,010
you have something that does have you

00:04:12,490 --> 00:04:18,280
have sophisticated query it's very hard

00:04:15,010 --> 00:04:23,830
to model it just with some simple key

00:04:18,280 --> 00:04:25,990
value no sequel API and well it just

00:04:23,830 --> 00:04:29,470
moves the complexity to the application

00:04:25,990 --> 00:04:32,110
layer instead of giving you like well

00:04:29,470 --> 00:04:34,120
thought-through query syntax which

00:04:32,110 --> 00:04:36,220
you can use to retrieve your data so I

00:04:34,120 --> 00:04:39,670
think sequel makes sense I don't know if

00:04:36,220 --> 00:04:42,340
you if you disagreed at all but thought

00:04:39,670 --> 00:04:47,710
it would be good to give you this short

00:04:42,340 --> 00:04:53,500
introduction so with that being said let

00:04:47,710 --> 00:04:56,320
me show you a database called cry TV and

00:04:53,500 --> 00:04:58,780
I believe it's it's a very scalable

00:04:56,320 --> 00:05:00,430
sequel database which is optimized for

00:04:58,780 --> 00:05:02,980
search we will see a little bit later

00:05:00,430 --> 00:05:05,080
what that means and it doesn't have all

00:05:02,980 --> 00:05:07,750
the no sequel which makes it

00:05:05,080 --> 00:05:11,200
really really easy to use for people who

00:05:07,750 --> 00:05:13,660
just want to write the sequel and yeah

00:05:11,200 --> 00:05:15,550
it's a very powerful tool to tell you a

00:05:13,660 --> 00:05:17,380
bit more about creativity right give you

00:05:15,550 --> 00:05:20,080
a rough overview it's been around since

00:05:17,380 --> 00:05:23,920
2014 it's open source apache license in

00:05:20,080 --> 00:05:27,160
the community edition and it is built

00:05:23,920 --> 00:05:28,810
using elasticsearch leucine Nettie

00:05:27,160 --> 00:05:32,920
antler a bunch of other open-source

00:05:28,810 --> 00:05:36,160
libraries its sequel 99 compatible which

00:05:32,920 --> 00:05:38,620
sounds like really old but it's probably

00:05:36,160 --> 00:05:42,250
all the sequel you you ever want to use

00:05:38,620 --> 00:05:44,670
and it has a bunch of ways to interface

00:05:42,250 --> 00:05:48,190
so we have rest endpoint to submit your

00:05:44,670 --> 00:05:50,170
queries and we also are compatible with

00:05:48,190 --> 00:05:51,790
the post crosswire protocol which is

00:05:50,170 --> 00:05:54,370
really cool feature because lets you

00:05:51,790 --> 00:05:58,830
pretty much replace crazy be with any

00:05:54,370 --> 00:06:01,120
like post Chris if you have a capo stris

00:05:58,830 --> 00:06:02,770
adapter and connect with Postgres you

00:06:01,120 --> 00:06:04,740
can just pretty much plug in creative be

00:06:02,770 --> 00:06:08,650
there and it and it works perfectly

00:06:04,740 --> 00:06:10,330
because while sequel is a standard they

00:06:08,650 --> 00:06:12,430
are certainly two extensions to it like

00:06:10,330 --> 00:06:15,490
for post Chris with some special tables

00:06:12,430 --> 00:06:17,410
and and so if if you replace a post card

00:06:15,490 --> 00:06:20,620
it works really easy and of course we

00:06:17,410 --> 00:06:25,990
have JDBC and Python and PHP and

00:06:20,620 --> 00:06:29,170
whatever a bunch of adapters so what is

00:06:25,990 --> 00:06:32,830
great about creepy because I started off

00:06:29,170 --> 00:06:34,600
with a bit like like a magnum marketing

00:06:32,830 --> 00:06:36,490
talk now but I want to be honest with

00:06:34,600 --> 00:06:39,580
you so I think it's it's really easy to

00:06:36,490 --> 00:06:42,190
set up it it's just sequel and it has

00:06:39,580 --> 00:06:43,990
great performance great scale out and a

00:06:42,190 --> 00:06:45,910
great documentation you can use it with

00:06:43,990 --> 00:06:48,490
docker really easily because

00:06:45,910 --> 00:06:51,670
actually it's you don't need a dedicated

00:06:48,490 --> 00:06:54,040
master and it just any note can be a

00:06:51,670 --> 00:06:56,860
master so it makes it really easy to use

00:06:54,040 --> 00:06:59,590
with containers what is not so great

00:06:56,860 --> 00:07:02,260
about it it isn't supports transactions

00:06:59,590 --> 00:07:04,330
because so if you need a highly highly

00:07:02,260 --> 00:07:13,690
consistent data store for your bank

00:07:04,330 --> 00:07:15,430
transactions don't use crazy B so maybe

00:07:13,690 --> 00:07:20,350
it would be interesting to take a look

00:07:15,430 --> 00:07:21,970
now at how you would use crazy B since

00:07:20,350 --> 00:07:24,460
creative is the sequel database not

00:07:21,970 --> 00:07:26,860
surprising that you write sequel so if

00:07:24,460 --> 00:07:29,350
you have your table definitions here

00:07:26,860 --> 00:07:33,000
create table where you have the speakers

00:07:29,350 --> 00:07:35,710
passwords table and the talks table with

00:07:33,000 --> 00:07:39,340
speaker name and the talk names then you

00:07:35,710 --> 00:07:42,280
can just insert your data like you would

00:07:39,340 --> 00:07:44,320
with any other sequel DB and you can

00:07:42,280 --> 00:07:47,340
then join for example these two tables

00:07:44,320 --> 00:07:50,760
so we have full full support for joins

00:07:47,340 --> 00:07:55,720
that's that's really nice a lot of times

00:07:50,760 --> 00:07:58,960
what people do though is because the

00:07:55,720 --> 00:08:02,530
join after all is comes at some expense

00:07:58,960 --> 00:08:06,700
expense they store their data and

00:08:02,530 --> 00:08:11,020
denormalized so they have the same table

00:08:06,700 --> 00:08:12,460
here but they well it basically this is

00:08:11,020 --> 00:08:14,620
a combination of the two tables so you

00:08:12,460 --> 00:08:18,430
have the the speaker name there and you

00:08:14,620 --> 00:08:23,530
have a talk object so create supports

00:08:18,430 --> 00:08:24,880
sort of unstructured data but so you

00:08:23,530 --> 00:08:26,620
have the talk with the title and the

00:08:24,880 --> 00:08:32,260
abstract but the really cool thing is

00:08:26,620 --> 00:08:35,020
once you insert it your data you can

00:08:32,260 --> 00:08:38,410
just select the title from the speaker's

00:08:35,020 --> 00:08:40,719
table inside this object and it doesn't

00:08:38,410 --> 00:08:43,930
it doesn't come comment a performance

00:08:40,719 --> 00:08:47,130
impact so it's it's creatively handles

00:08:43,930 --> 00:08:49,480
all the indexing inside these objects so

00:08:47,130 --> 00:08:50,890
it really just makes doesn't make it

00:08:49,480 --> 00:08:53,890
different whether you select from this

00:08:50,890 --> 00:08:56,290
object or you have a dedicated column so

00:08:53,890 --> 00:08:58,810
that makes it really flexible in use

00:08:56,290 --> 00:08:59,800
cases where you have unstructured data

00:08:58,810 --> 00:09:05,739
and you want to

00:08:59,800 --> 00:09:08,860
we insert and query it because we are

00:09:05,739 --> 00:09:13,509
just a real database we need some way to

00:09:08,860 --> 00:09:15,220
to partition our tables in a cluster so

00:09:13,509 --> 00:09:19,709
if we have like a four node cluster here

00:09:15,220 --> 00:09:23,459
and we can petition by name by the name

00:09:19,709 --> 00:09:27,879
column with this clustered by syntax and

00:09:23,459 --> 00:09:31,299
for shards means for petitions and we

00:09:27,879 --> 00:09:33,549
can also add some replication for for

00:09:31,299 --> 00:09:35,980
torrents and also to increase our search

00:09:33,549 --> 00:09:37,779
speed with this number of replicas and

00:09:35,980 --> 00:09:39,790
of course then you have the replicas

00:09:37,779 --> 00:09:43,660
stored not on the same note as the the

00:09:39,790 --> 00:09:47,170
primary but the creativity takes care of

00:09:43,660 --> 00:09:49,660
handling that and then also what you can

00:09:47,170 --> 00:09:55,059
do which is really useful for time

00:09:49,660 --> 00:09:58,420
series data you can basically petition

00:09:55,059 --> 00:10:01,360
your table so it's a bit confusing I

00:09:58,420 --> 00:10:04,269
mean clustering is like the parts that

00:10:01,360 --> 00:10:06,249
that you're you divide your data and you

00:10:04,269 --> 00:10:08,350
distribute it in the cluster and then

00:10:06,249 --> 00:10:11,709
you have additionally partitioning which

00:10:08,350 --> 00:10:14,529
is basically creates if we here want to

00:10:11,709 --> 00:10:20,199
create a petition by year of that table

00:10:14,529 --> 00:10:24,939
which basically creates a new entity of

00:10:20,199 --> 00:10:27,189
that table so all the all the data of

00:10:24,939 --> 00:10:29,350
one year is grouped together which again

00:10:27,189 --> 00:10:31,720
if you have if you have time series data

00:10:29,350 --> 00:10:33,730
makes it really quick to to aggregate

00:10:31,720 --> 00:10:36,490
data from a year or a day if you have

00:10:33,730 --> 00:10:42,910
that petition set up so it's basically

00:10:36,490 --> 00:10:45,459
way to co-locate your data and we have

00:10:42,910 --> 00:10:47,470
many more features which I don't have

00:10:45,459 --> 00:10:51,459
time to go into I mention the post risk

00:10:47,470 --> 00:10:53,829
go to call we have analyzers for texts

00:10:51,459 --> 00:10:56,619
for full-text search we have user

00:10:53,829 --> 00:10:58,839
defined function geo search where you

00:10:56,619 --> 00:11:01,209
can backup your data with snapshots we

00:10:58,839 --> 00:11:05,919
have a bunch of authentication

00:11:01,209 --> 00:11:08,019
encryption built in and yeah and really

00:11:05,919 --> 00:11:11,560
cool web interface which I will show you

00:11:08,019 --> 00:11:14,889
a bit later

00:11:11,560 --> 00:11:19,329
so to make this talk a bit more

00:11:14,889 --> 00:11:23,620
interesting I wanted to give you like an

00:11:19,329 --> 00:11:28,240
overview of how creative works and how

00:11:23,620 --> 00:11:32,319
it's sort of layered and well this is

00:11:28,240 --> 00:11:35,319
the the RAF create EP tech spec so so we

00:11:32,319 --> 00:11:38,470
have the scene at the very bottom which

00:11:35,319 --> 00:11:42,009
is our document store because that's

00:11:38,470 --> 00:11:44,949
what what lucina is in the end and it

00:11:42,009 --> 00:11:47,499
managed all the indexing the the end

00:11:44,949 --> 00:11:50,740
which which gives you really fast lookup

00:11:47,499 --> 00:11:53,110
performance to define to find you find

00:11:50,740 --> 00:11:57,459
data and the column storage gives you

00:11:53,110 --> 00:12:02,769
very fast way to aggregate data once you

00:11:57,459 --> 00:12:06,490
once you found your data and um yeah

00:12:02,769 --> 00:12:09,850
basically you seen this does the the raw

00:12:06,490 --> 00:12:15,339
data handling and then on top of this we

00:12:09,850 --> 00:12:17,170
have elastic search which is we only use

00:12:15,339 --> 00:12:19,839
a part of elastic search obviously it's

00:12:17,170 --> 00:12:23,170
not the full copy but and we use it for

00:12:19,839 --> 00:12:25,569
for networking for the transport between

00:12:23,170 --> 00:12:28,480
the nodes for figuring out which row

00:12:25,569 --> 00:12:31,600
which node receive which data for

00:12:28,480 --> 00:12:34,779
snapshots and for routing through the

00:12:31,600 --> 00:12:37,540
Lucine requests and then on top of

00:12:34,779 --> 00:12:40,329
create eb not on top of trade on top of

00:12:37,540 --> 00:12:42,250
elastic search we have crative itself

00:12:40,329 --> 00:12:44,319
which is basically this sequel layer so

00:12:42,250 --> 00:12:48,480
it it does the query processing

00:12:44,319 --> 00:12:52,000
obviously but it also does compile

00:12:48,480 --> 00:12:54,189
leucine queries which which basically

00:12:52,000 --> 00:12:56,800
create an optimized version for leucine

00:12:54,189 --> 00:12:58,779
of your sequel query and sends it

00:12:56,800 --> 00:13:01,360
through through the elastic search layer

00:12:58,779 --> 00:13:03,610
and down to leucine and then of course

00:13:01,360 --> 00:13:07,990
we have the distributed query execution

00:13:03,610 --> 00:13:10,170
so for joins for for sap selects and all

00:13:07,990 --> 00:13:13,420
kinds of sequel statements we have

00:13:10,170 --> 00:13:16,749
optimized and this optimized layer which

00:13:13,420 --> 00:13:18,399
which creates operations and sends them

00:13:16,749 --> 00:13:20,679
down through from the scene and in the

00:13:18,399 --> 00:13:23,620
end so this is a very big part of our

00:13:20,679 --> 00:13:25,329
work and yeah I mentioned post Chris

00:13:23,620 --> 00:13:28,149
respite already

00:13:25,329 --> 00:13:30,819
and we have a very nice weapon to face

00:13:28,149 --> 00:13:32,040
on top of it which I will show you in a

00:13:30,819 --> 00:13:37,089
bit

00:13:32,040 --> 00:13:40,209
so leucine if you if you haven't heard

00:13:37,089 --> 00:13:41,709
about it just a quick introduction if

00:13:40,209 --> 00:13:45,189
you probably know what it is but I mean

00:13:41,709 --> 00:13:48,309
the scene stores documents and in crazy

00:13:45,189 --> 00:13:51,569
B we have rose so a document always

00:13:48,309 --> 00:13:54,939
corresponds to a row in creativi and

00:13:51,569 --> 00:13:59,709
this document has like fields which you

00:13:54,939 --> 00:14:04,199
which you define and you can also add

00:13:59,709 --> 00:14:08,019
more fields of course and the way

00:14:04,199 --> 00:14:10,360
leucine is just really fast is that it

00:14:08,019 --> 00:14:11,589
has this inverted index so if you if you

00:14:10,360 --> 00:14:14,019
want to if you're searching for the

00:14:11,589 --> 00:14:15,670
document which has the name a Bob you

00:14:14,019 --> 00:14:17,350
have you just look in the inverted index

00:14:15,670 --> 00:14:19,720
and you find your document really

00:14:17,350 --> 00:14:22,299
quickly and also if you then want for

00:14:19,720 --> 00:14:26,319
example aggregate sum up all the prices

00:14:22,299 --> 00:14:28,089
here of this talk of all the documents

00:14:26,319 --> 00:14:30,730
like this then you have this column

00:14:28,089 --> 00:14:32,889
storage which has basic stores your

00:14:30,730 --> 00:14:37,540
columns in a row so you can really

00:14:32,889 --> 00:14:43,899
quickly aggregate the data so yeah that

00:14:37,540 --> 00:14:46,959
makes queries just super fast and the

00:14:43,899 --> 00:14:49,149
elastic search layer and so an elastic

00:14:46,959 --> 00:14:50,799
search we have basically indeed in it

00:14:49,149 --> 00:14:54,790
sis charts and replicas these are like

00:14:50,799 --> 00:15:00,129
the main concepts and how you how you

00:14:54,790 --> 00:15:07,059
structure your data and again so Alexis

00:15:00,129 --> 00:15:10,679
search basically uses Lucine and creates

00:15:07,059 --> 00:15:14,499
this this index which is basically a

00:15:10,679 --> 00:15:19,749
leucine store store M or more

00:15:14,499 --> 00:15:22,989
specifically N and n times in the scene

00:15:19,749 --> 00:15:27,699
store and call charts and these charts

00:15:22,989 --> 00:15:30,160
have replicas and yeah replicas are

00:15:27,699 --> 00:15:32,290
actually not only useful for just

00:15:30,160 --> 00:15:34,539
replicating data and for alterans but

00:15:32,290 --> 00:15:36,819
also for increasing the search

00:15:34,539 --> 00:15:41,600
performance

00:15:36,819 --> 00:15:45,500
so how do tables then relay to images

00:15:41,600 --> 00:15:48,379
and charts so a table and create it be

00:15:45,500 --> 00:15:52,459
in the end is like like an index mapping

00:15:48,379 --> 00:15:56,060
which looks a bit like cryptic Jason

00:15:52,459 --> 00:15:57,319
stuff like like on the right and the

00:15:56,060 --> 00:16:00,170
good thing is you don't really need to

00:15:57,319 --> 00:16:05,420
deal with this with all the json api and

00:16:00,170 --> 00:16:09,649
when you use creativi and so actually

00:16:05,420 --> 00:16:13,250
and if you create a petition for foreign

00:16:09,649 --> 00:16:17,540
table then this actually becomes a

00:16:13,250 --> 00:16:20,149
separate index so the way this works is

00:16:17,540 --> 00:16:22,370
basically takes your your petition value

00:16:20,149 --> 00:16:25,490
for example the year or the day that we

00:16:22,370 --> 00:16:28,550
had previously and it encodes that into

00:16:25,490 --> 00:16:32,120
the index and name and then you you get

00:16:28,550 --> 00:16:34,399
just a new index from it so you can see

00:16:32,120 --> 00:16:39,110
here on the right you have for example

00:16:34,399 --> 00:16:42,230
two three tables T 1 2 2 3 3 and you see

00:16:39,110 --> 00:16:45,560
a t1 has like and and in index which was

00:16:42,230 --> 00:16:49,910
called t1 and for sharts then on then t2

00:16:45,560 --> 00:16:51,980
has also has basically separate indexes

00:16:49,910 --> 00:16:55,910
for every day for so you have like t2

00:16:51,980 --> 00:16:58,089
day 1 and and so on and this is how how

00:16:55,910 --> 00:17:05,659
it corresponds to so elastic search

00:16:58,089 --> 00:17:09,260
indexes so what actually happens when

00:17:05,659 --> 00:17:11,390
when you run a query with kratie B so

00:17:09,260 --> 00:17:13,520
here we we have a select statements

00:17:11,390 --> 00:17:18,439
where you group by the speaker name and

00:17:13,520 --> 00:17:22,789
M want to get the the the number of

00:17:18,439 --> 00:17:26,600
talks by by each speaker from this years

00:17:22,789 --> 00:17:28,700
passwords in the castle room and yeah

00:17:26,600 --> 00:17:31,730
when when when you execute a query like

00:17:28,700 --> 00:17:36,049
this we basically run through like these

00:17:31,730 --> 00:17:38,450
four phases and each phase has like

00:17:36,049 --> 00:17:38,929
different question on our problem to

00:17:38,450 --> 00:17:42,409
solve

00:17:38,929 --> 00:17:45,440
I try to formulate that so the first one

00:17:42,409 --> 00:17:49,670
is like the parser and it first looks at

00:17:45,440 --> 00:17:52,670
your query and divides it into

00:17:49,670 --> 00:17:55,610
two components so we know what what

00:17:52,670 --> 00:17:57,440
parts the curry is composed of so here

00:17:55,610 --> 00:17:59,930
we have a select which has a from and

00:17:57,440 --> 00:18:03,380
and in the way I pad group by in an

00:17:59,930 --> 00:18:05,480
order by and then then the analyzer

00:18:03,380 --> 00:18:08,150
comes into play and asks you know what

00:18:05,480 --> 00:18:09,860
these parts did you give me what what do

00:18:08,150 --> 00:18:16,360
they actually mean when what do they

00:18:09,860 --> 00:18:20,600
refer to so you so you basically

00:18:16,360 --> 00:18:25,820
annotate what you have from the parlor

00:18:20,600 --> 00:18:27,680
with so with what you know what you find

00:18:25,820 --> 00:18:29,020
in in creativity about it so you know

00:18:27,680 --> 00:18:31,820
okay

00:18:29,020 --> 00:18:34,430
in the from class the speaker's is a

00:18:31,820 --> 00:18:37,070
table and that exists in creative be it

00:18:34,430 --> 00:18:40,040
has and you actually try to select the

00:18:37,070 --> 00:18:43,840
name from the name from it to name field

00:18:40,040 --> 00:18:46,970
and you're doing a count aggregation and

00:18:43,840 --> 00:18:48,890
similarly also in the group by its order

00:18:46,970 --> 00:18:52,420
by its or the same field and the where

00:18:48,890 --> 00:18:55,670
clause it's all that you are actually

00:18:52,420 --> 00:18:59,300
you're looking for as a type of

00:18:55,670 --> 00:19:04,010
therefore the room castle and the year

00:18:59,300 --> 00:19:07,730
2018 and then what the planner actually

00:19:04,010 --> 00:19:12,050
does is and it figures out how do we

00:19:07,730 --> 00:19:15,050
this is this how do we plan how do we

00:19:12,050 --> 00:19:18,470
get results if we take this logical

00:19:15,050 --> 00:19:21,860
representation of the query and put it

00:19:18,470 --> 00:19:24,110
in to prepare it basically before the

00:19:21,860 --> 00:19:26,630
execution create a plan how to to select

00:19:24,110 --> 00:19:29,990
that data and here in this case it will

00:19:26,630 --> 00:19:32,090
will collect basically the the name from

00:19:29,990 --> 00:19:36,680
from the notes and then it will run a

00:19:32,090 --> 00:19:41,090
hash aggregate to group by the name and

00:19:36,680 --> 00:19:43,060
then in the end of will sort so and if

00:19:41,090 --> 00:19:45,980
we have this plan we need to somehow

00:19:43,060 --> 00:19:51,020
execute it also and this is what what

00:19:45,980 --> 00:19:55,310
the executor is for so if we look at the

00:19:51,020 --> 00:19:59,680
bigger picture here we can see that each

00:19:55,310 --> 00:19:59,680
node has these components built in and

00:20:01,000 --> 00:20:05,299
on top of this

00:20:03,710 --> 00:20:06,980
create distributed query execution

00:20:05,299 --> 00:20:08,690
runtime or

00:20:06,980 --> 00:20:11,149
actually Beneatha's we have the the

00:20:08,690 --> 00:20:14,179
transport layer of elastic search and

00:20:11,149 --> 00:20:17,179
the starch and so if you receive a quest

00:20:14,179 --> 00:20:20,480
request from any client you will go

00:20:17,179 --> 00:20:21,950
through and not any note can accept this

00:20:20,480 --> 00:20:24,649
request and you will go through these

00:20:21,950 --> 00:20:27,200
phases and distributed request the

00:20:24,649 --> 00:20:32,390
request in the cluster and and collect

00:20:27,200 --> 00:20:35,630
your results so what are the highlights

00:20:32,390 --> 00:20:40,309
of this architecture so obviously it's

00:20:35,630 --> 00:20:43,220
it's fully distributed and you also have

00:20:40,309 --> 00:20:46,490
this distributed execution which gives

00:20:43,220 --> 00:20:48,500
you really fast results and it's it's

00:20:46,490 --> 00:20:50,450
master list so you can just connect to

00:20:48,500 --> 00:20:55,220
any node in your cluster and execute

00:20:50,450 --> 00:20:58,549
your query yeah it's it's due to the

00:20:55,220 --> 00:21:01,899
replication we also have the end of the

00:20:58,549 --> 00:21:03,860
advantage that you don't need fixed

00:21:01,899 --> 00:21:07,640
durable storage so you can use a

00:21:03,860 --> 00:21:10,340
ephemeral storage and if you if a node

00:21:07,640 --> 00:21:14,149
goes down then the the data will still

00:21:10,340 --> 00:21:15,890
be replicated in the cluster and this

00:21:14,149 --> 00:21:17,690
makes it really good for containers

00:21:15,890 --> 00:21:21,890
actually where you might not always have

00:21:17,690 --> 00:21:25,640
access to durable storage but you rather

00:21:21,890 --> 00:21:28,580
take snapshots from time to time yeah

00:21:25,640 --> 00:21:31,940
and then actually all fields in in is

00:21:28,580 --> 00:21:33,980
assumable but all fields in creativi are

00:21:31,940 --> 00:21:38,450
indexed by default so you don't need to

00:21:33,980 --> 00:21:43,370
think about whether it's fast to create

00:21:38,450 --> 00:21:46,159
that data because it's it's it will be

00:21:43,370 --> 00:21:48,140
because it's indexed of course this is

00:21:46,159 --> 00:21:50,720
this is tunable it takes a bit more

00:21:48,140 --> 00:21:58,940
storage but it's what most people

00:21:50,720 --> 00:22:01,880
actually want so I want to show you a

00:21:58,940 --> 00:22:05,690
bit night next what people build with

00:22:01,880 --> 00:22:10,220
kratie B so the main use case for

00:22:05,690 --> 00:22:12,169
creative B is what we see a lot of

00:22:10,220 --> 00:22:16,250
people doing it with it is monitoring

00:22:12,169 --> 00:22:22,240
with real-time analysis especially

00:22:16,250 --> 00:22:29,150
in in in the IT industry you know 34.0

00:22:22,240 --> 00:22:31,880
many surveilling network events having

00:22:29,150 --> 00:22:36,140
sensors and factories which which sends

00:22:31,880 --> 00:22:38,510
like thousands of records a second and

00:22:36,140 --> 00:22:40,340
you want to be able to to have and gain

00:22:38,510 --> 00:22:43,970
an in real-time insight into what's

00:22:40,340 --> 00:22:47,300
happening obviously data signs because

00:22:43,970 --> 00:22:49,550
you can just run sequel and you don't

00:22:47,300 --> 00:22:52,580
need to know anything about databases

00:22:49,550 --> 00:22:55,280
otherwise and some people also doing

00:22:52,580 --> 00:22:57,560
stream analysis with it it's it's well

00:22:55,280 --> 00:22:59,980
not maybe not exactly stimulus is like

00:22:57,560 --> 00:23:03,530
flink but you can do a fairly amount of

00:22:59,980 --> 00:23:05,720
interesting cases where you where you

00:23:03,530 --> 00:23:08,870
take part where you extract data from a

00:23:05,720 --> 00:23:10,760
table on a regular basis and of course

00:23:08,870 --> 00:23:13,310
due to full-text search it's really

00:23:10,760 --> 00:23:14,840
useful for text analysis time series are

00:23:13,310 --> 00:23:15,440
due to the petition table it's really

00:23:14,840 --> 00:23:19,940
useful

00:23:15,440 --> 00:23:23,810
we have also people who use it to for

00:23:19,940 --> 00:23:26,330
example track their vehicle fleet and

00:23:23,810 --> 00:23:29,300
they need this geospatial career support

00:23:26,330 --> 00:23:32,660
there this comes in really handy just to

00:23:29,300 --> 00:23:36,770
give you an example of one one of great

00:23:32,660 --> 00:23:40,610
iOS customers it's called al play and

00:23:36,770 --> 00:23:43,400
it's manufacturers bottles for all kinds

00:23:40,610 --> 00:23:47,180
of purposes like food cosmetic or

00:23:43,400 --> 00:23:50,240
cleaning stuff and they are quite the

00:23:47,180 --> 00:23:52,490
company I would say so

00:23:50,240 --> 00:23:57,380
18,000 employees and all around the

00:23:52,490 --> 00:23:59,330
world and yeah so they also use crazy be

00:23:57,380 --> 00:24:01,460
for real-time insight into the manage of

00:23:59,330 --> 00:24:03,800
manufacturing process so the measure of

00:24:01,460 --> 00:24:07,070
throughput failure rates they can see if

00:24:03,800 --> 00:24:11,000
a machine is about to go to die and it's

00:24:07,070 --> 00:24:12,860
maintenance they can just add really

00:24:11,000 --> 00:24:14,900
real-time see what is going on their

00:24:12,860 --> 00:24:17,270
manufacturing process and they were

00:24:14,900 --> 00:24:19,700
previously doing that or starting to do

00:24:17,270 --> 00:24:21,980
that as well but it came as a much

00:24:19,700 --> 00:24:25,100
higher operational cost because they

00:24:21,980 --> 00:24:29,480
were basically had like this really big

00:24:25,100 --> 00:24:30,140
databases and to which with expensive

00:24:29,480 --> 00:24:32,030
software

00:24:30,140 --> 00:24:37,900
we've created be it yeah they can just

00:24:32,030 --> 00:24:39,230
run on commodity hardware and yeah

00:24:37,900 --> 00:24:41,450
that's it

00:24:39,230 --> 00:24:44,270
or yeah actually previously they would

00:24:41,450 --> 00:24:47,270
would run like nightly analysis which

00:24:44,270 --> 00:25:01,070
would give them like much later insights

00:24:47,270 --> 00:25:03,500
into their data okay this is how I don't

00:25:01,070 --> 00:25:05,510
know why it's written demo there I can

00:25:03,500 --> 00:25:11,780
give it to you as well but this is the

00:25:05,510 --> 00:25:13,880
creativi web interface so this is the

00:25:11,780 --> 00:25:15,590
overview page where you can give a get a

00:25:13,880 --> 00:25:16,940
quick overview of what's happening in

00:25:15,590 --> 00:25:21,679
your class or whether all your data is

00:25:16,940 --> 00:25:24,169
replicated you can see the load and um

00:25:21,679 --> 00:25:27,350
there's more of course we have also a

00:25:24,169 --> 00:25:31,160
table overview which gives you the

00:25:27,350 --> 00:25:36,250
number of records stored and an overview

00:25:31,160 --> 00:25:39,140
what petitions exists for a table and

00:25:36,250 --> 00:25:42,710
also there's an overview page for the

00:25:39,140 --> 00:25:44,780
notes where you can see how every note

00:25:42,710 --> 00:25:47,150
is doing we even have like a fancy a

00:25:44,780 --> 00:25:48,980
sharp overview table where you can see

00:25:47,150 --> 00:25:54,290
how your data is distributed for every

00:25:48,980 --> 00:25:56,210
table and yeah I I'm already at the end

00:25:54,290 --> 00:25:58,190
I feel like I maybe spoke too fast

00:25:56,210 --> 00:26:01,549
because it took me like 10 minutes

00:25:58,190 --> 00:26:02,919
longer when I practice talk but okay so

00:26:01,549 --> 00:26:06,169
what have we learned

00:26:02,919 --> 00:26:08,320
obviously elasticsearch built this

00:26:06,169 --> 00:26:11,270
search engine on top of leucine and

00:26:08,320 --> 00:26:14,390
kratie b took it well one step further

00:26:11,270 --> 00:26:16,640
and I built a sequel database on top of

00:26:14,390 --> 00:26:18,559
elastic search and leucine and I think

00:26:16,640 --> 00:26:21,559
creativity is perfect for you when you

00:26:18,559 --> 00:26:25,250
when you want to use yeah or have to use

00:26:21,559 --> 00:26:27,260
sequel and it's just scales out really

00:26:25,250 --> 00:26:33,320
well and you can store large amounts of

00:26:27,260 --> 00:26:36,100
data and now at the end of my talk so I

00:26:33,320 --> 00:26:39,980
just want you to encourage to try it out

00:26:36,100 --> 00:26:42,650
it's really easy so go to the download

00:26:39,980 --> 00:26:43,730
page or if you if you fancy and bash

00:26:42,650 --> 00:26:47,840
just pay

00:26:43,730 --> 00:26:51,169
and trust us that it runs the right

00:26:47,840 --> 00:26:53,870
thing so are you use docker docker run

00:26:51,169 --> 00:26:56,000
create mmm or built from source it's

00:26:53,870 --> 00:26:58,070
also possible if you are interested in

00:26:56,000 --> 00:27:02,360
the Ducks they're really good check them

00:26:58,070 --> 00:27:03,980
out and also contributions of course are

00:27:02,360 --> 00:27:04,970
welcome it's an open source project you

00:27:03,980 --> 00:27:07,909
can look at the developer documentation

00:27:04,970 --> 00:27:10,850
there are getting up issues Stack

00:27:07,909 --> 00:27:15,460
Overflow questions please ask or join

00:27:10,850 --> 00:27:15,460
our at slack Channel thank you very much

00:27:18,730 --> 00:27:22,450
so we have time for questions

00:27:23,860 --> 00:27:33,200
hello I actually have two questions so

00:27:28,090 --> 00:27:37,669
first one is about the JDBC driver that

00:27:33,200 --> 00:27:40,190
elastic released so they have also a way

00:27:37,669 --> 00:27:45,500
to launch sequel queries on top of

00:27:40,190 --> 00:27:52,250
elastic recently so how how does it

00:27:45,500 --> 00:27:54,019
compare to that I I've only actually

00:27:52,250 --> 00:27:57,620
recently they're open source their

00:27:54,019 --> 00:28:00,110
sequel layer so I took a look at it I

00:27:57,620 --> 00:28:03,200
have not played around with it much but

00:28:00,110 --> 00:28:06,950
as of now it's very basic so it lets you

00:28:03,200 --> 00:28:10,039
run simple select queries with with a

00:28:06,950 --> 00:28:13,070
where class it it seems to be more

00:28:10,039 --> 00:28:15,409
difficult or impossible to do more

00:28:13,070 --> 00:28:18,429
complex aggregation sub queries joints

00:28:15,409 --> 00:28:19,789
as far as I know it's not supported yet

00:28:18,429 --> 00:28:23,510
fair enough

00:28:19,789 --> 00:28:26,419
and so second question about joins what

00:28:23,510 --> 00:28:29,179
are the limitations that you have with

00:28:26,419 --> 00:28:34,720
joints on top of credi B because I guess

00:28:29,179 --> 00:28:37,429
there are some limitations of course so

00:28:34,720 --> 00:28:41,630
we recently did a lot of work there to

00:28:37,429 --> 00:28:47,720
improve joint performance so if you we

00:28:41,630 --> 00:28:49,370
have basically the the well we have an

00:28:47,720 --> 00:28:51,860
early times we just had like the nested

00:28:49,370 --> 00:28:54,289
loop joints which we're kind of is

00:28:51,860 --> 00:28:57,500
really slow way to do joints nowadays we

00:28:54,289 --> 00:29:00,410
have hashed joins so this is typically

00:28:57,500 --> 00:29:04,430
if you run like a equi-join this is this

00:29:00,410 --> 00:29:08,420
is very fast and in terms of limitations

00:29:04,430 --> 00:29:11,630
you are of course limited a bit by the

00:29:08,420 --> 00:29:13,760
RAM on your machine so if you for

00:29:11,630 --> 00:29:16,550
example in a hash join and you kind of

00:29:13,760 --> 00:29:20,540
need to need one of the side of your

00:29:16,550 --> 00:29:23,030
join to fit in memory so if you if that

00:29:20,540 --> 00:29:25,370
is not the case then of course great

00:29:23,030 --> 00:29:29,950
will not crash but you won't be able to

00:29:25,370 --> 00:29:32,690
execute the query so this is basically

00:29:29,950 --> 00:29:36,590
the only limitation that I'm aware of

00:29:32,690 --> 00:29:40,010
but yeah otherwise you can really join

00:29:36,590 --> 00:29:47,420
like huge data sets with like millions

00:29:40,010 --> 00:29:49,280
of rows yeah try it out okay I just

00:29:47,420 --> 00:29:54,350
started playing around with the elk

00:29:49,280 --> 00:29:58,900
stack and I was wondering does cabaña

00:29:54,350 --> 00:29:58,900
for example work on top of creative be

00:30:01,480 --> 00:30:09,110
good question

00:30:03,500 --> 00:30:11,300
in theory I mean I don't know is it's it

00:30:09,110 --> 00:30:16,070
doesn't just use the elastic search API

00:30:11,300 --> 00:30:18,350
I would assume right so it if that's the

00:30:16,070 --> 00:30:20,720
only if that's the case then actually

00:30:18,350 --> 00:30:24,290
you you can enable the elastic search

00:30:20,720 --> 00:30:25,970
API also with creative e so that might

00:30:24,290 --> 00:30:28,700
be an option if you really want to use

00:30:25,970 --> 00:30:31,190
Cabana and you also want the sequel part

00:30:28,700 --> 00:30:32,780
so that's theoretically I mean I don't

00:30:31,190 --> 00:30:40,490
know who I don't know somebody who does

00:30:32,780 --> 00:30:42,920
it but it's possible I've Nev I have

00:30:40,490 --> 00:30:45,680
leave a question for you when you're

00:30:42,920 --> 00:30:47,540
just great a DP and 2014 I was talking

00:30:45,680 --> 00:30:49,730
to your talk at your pass and four years

00:30:47,540 --> 00:30:51,500
ago and was pretty cool at that time

00:30:49,730 --> 00:30:53,360
because what's the first database which

00:30:51,500 --> 00:30:56,420
basically probably using a sequel

00:30:53,360 --> 00:30:59,030
nowadays we have you can scale Postgres

00:30:56,420 --> 00:31:01,340
with clusters we have stuff like

00:30:59,030 --> 00:31:04,070
cockroach TB pit provides just Richter's

00:31:01,340 --> 00:31:07,340
actions across data centers we have

00:31:04,070 --> 00:31:09,620
stuff like Arango DB which provides

00:31:07,340 --> 00:31:10,880
mighty mortal database with document

00:31:09,620 --> 00:31:14,450
store graph

00:31:10,880 --> 00:31:18,050
and so on we have lately ever released

00:31:14,450 --> 00:31:20,320
foundation DB which provides students oh

00:31:18,050 --> 00:31:23,090
what's the selling point

00:31:20,320 --> 00:31:26,800
how do you compare it with these surveys

00:31:23,090 --> 00:31:29,630
and what would be a key feature for

00:31:26,800 --> 00:31:33,980
making the decision use credit be

00:31:29,630 --> 00:31:39,500
compared or others yeah I think the key

00:31:33,980 --> 00:31:42,740
feature is probably that we have fairly

00:31:39,500 --> 00:31:45,050
complete sequel support so a lot of

00:31:42,740 --> 00:31:47,810
other solutions out there I think they

00:31:45,050 --> 00:31:50,200
implement only like a part of sequel and

00:31:47,810 --> 00:31:52,850
you run into a lot of limitations

00:31:50,200 --> 00:31:55,600
another advantage is I think that is

00:31:52,850 --> 00:31:59,210
it's really easy to set up and to scale

00:31:55,600 --> 00:32:02,930
you don't need to do much there you just

00:31:59,210 --> 00:32:04,910
add more notes and this behavior that

00:32:02,930 --> 00:32:07,310
everything is like index and file

00:32:04,910 --> 00:32:09,650
searchable really quickly I think makes

00:32:07,310 --> 00:32:12,800
it a very good use for just very good

00:32:09,650 --> 00:32:15,260
tool for analytics and I think it's

00:32:12,800 --> 00:32:16,040
generally bit harder to use it with the

00:32:15,260 --> 00:32:18,410
others I haven't

00:32:16,040 --> 00:32:20,990
honest to be honest I use Arango to be

00:32:18,410 --> 00:32:23,720
and I've used cockroach I know cockroach

00:32:20,990 --> 00:32:25,640
is just very for example due to the

00:32:23,720 --> 00:32:30,560
transaction support much slower than cry

00:32:25,640 --> 00:32:32,030
TB I've seen that so I mean I mean don't

00:32:30,560 --> 00:32:34,040
get me wrong a cockroach EP is great

00:32:32,030 --> 00:32:35,780
product but if you don't require

00:32:34,040 --> 00:32:41,050
transactions I think you're much better

00:32:35,780 --> 00:32:41,050
off with cry TB and for the yeah for the

00:32:41,740 --> 00:32:47,900
elastic sequel layer I mean I can only

00:32:44,180 --> 00:32:50,090
say it's it's not as complete yet so so

00:32:47,900 --> 00:32:52,670
I mean really what we've done the past

00:32:50,090 --> 00:32:54,980
years at creatively a crate i/o is to

00:32:52,670 --> 00:32:56,960
focus on the sequel part and we could do

00:32:54,980 --> 00:32:58,670
that really well due to the ice exerting

00:32:56,960 --> 00:33:01,990
the scene being kind of provided to us

00:32:58,670 --> 00:33:06,170
and building distributes equal layer is

00:33:01,990 --> 00:33:07,640
not so easy and to get it right so I

00:33:06,170 --> 00:33:14,720
think creatively does it does it very

00:33:07,640 --> 00:33:16,700
well hi I have a question regarding also

00:33:14,720 --> 00:33:19,490
which elasticsearch version are you

00:33:16,700 --> 00:33:25,190
using today and

00:33:19,490 --> 00:33:27,680
a few experienced also challenges across

00:33:25,190 --> 00:33:30,620
the versions about scalability so for

00:33:27,680 --> 00:33:35,540
example how about scaling or what trendy

00:33:30,620 --> 00:33:38,810
notes we you currently use elasticsearch

00:33:35,540 --> 00:33:44,120
version six one two or something in that

00:33:38,810 --> 00:33:46,100
yeah so I think is it later than almost

00:33:44,120 --> 00:33:49,280
the latest version we usually we track

00:33:46,100 --> 00:33:50,900
the elasticsearch written to to also get

00:33:49,280 --> 00:33:57,550
advantage of the improved performance

00:33:50,900 --> 00:34:02,110
improvements so it is true I think that

00:33:57,550 --> 00:34:05,660
scaling elasticsearch clusters so and

00:34:02,110 --> 00:34:08,930
that's also creative you clusters add to

00:34:05,660 --> 00:34:14,780
more than or to hundreds of nodes can be

00:34:08,930 --> 00:34:17,510
a bit challenging because it is it's not

00:34:14,780 --> 00:34:19,280
if I think the the network layer system

00:34:17,510 --> 00:34:22,880
meant to do that

00:34:19,280 --> 00:34:24,590
because every node stays connected with

00:34:22,880 --> 00:34:27,950
every other node so the number of

00:34:24,590 --> 00:34:30,350
connections really grow and just can get

00:34:27,950 --> 00:34:32,630
somewhere yeah but I and I've heard

00:34:30,350 --> 00:34:36,290
actually people using like 100 node

00:34:32,630 --> 00:34:38,030
cluster I know that it definitely

00:34:36,290 --> 00:34:42,980
doesn't stale to thousands of nodes or

00:34:38,030 --> 00:34:45,350
so most of our customers use actually

00:34:42,980 --> 00:34:47,600
rather small clusters like up to 20

00:34:45,350 --> 00:34:53,210
nodes or so and and they're really happy

00:34:47,600 --> 00:34:55,460
with it and but yeah I mean for huge

00:34:53,210 --> 00:34:56,960
clusters it can be challenging but we

00:34:55,460 --> 00:34:59,810
might do some summer work there in the

00:34:56,960 --> 00:35:01,670
future if more people ask for it and and

00:34:59,810 --> 00:35:04,460
have I understood you correctly so

00:35:01,670 --> 00:35:10,060
previously someone asked about joints so

00:35:04,460 --> 00:35:13,340
you are if the one of the data sites is

00:35:10,060 --> 00:35:16,850
you need a small data site right so that

00:35:13,340 --> 00:35:21,530
you can create this join in memory so to

00:35:16,850 --> 00:35:23,660
say and if one side is or if this sides

00:35:21,530 --> 00:35:26,030
get too big then you would somehow stop

00:35:23,660 --> 00:35:29,990
execution and say to your users know

00:35:26,030 --> 00:35:32,270
your data set is to pick your joining

00:35:29,990 --> 00:35:32,870
this is correct yeah that's correct

00:35:32,270 --> 00:35:40,490
okay

00:35:32,870 --> 00:35:42,440
thank you any other question and that is

00:35:40,490 --> 00:35:45,550
thank you very much we will continue

00:35:42,440 --> 00:35:46,730
from 2 p.m. after the break

00:35:45,550 --> 00:35:46,950
thank you

00:35:46,730 --> 00:35:50,600
[Music]

00:35:46,950 --> 00:35:50,600

YouTube URL: https://www.youtube.com/watch?v=7gjaY9SIZqQ


