Title: Berlin Buzzwords 2017: Alaa Elhadba & Mikio Braun - The modern architecture of search #bbuzz
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	Information Retrieval (IR) systems are a vital component in the core of successful modern web platforms. The main goal of IR systems is to provide a communication layer that enables customers to establish a retrieval dialogue with underlying data.

The immense explosion of unstructured data drives modern search application to go beyond just fuzzy string matching, to invest in deep understanding of user queries through interpretation of user intention in order to respond with a relevant result set. 

The modern architecture of search is a design of a data-driven IR system that covers the following: 
- Data ingestion pipelines from various sources
- Data retrieval and the lifecycle of a user search query
- Machine learned relevance ranking 
- Personalised search
- Search performance tracking and quality assessment

The talk will discuss the components needed to build an eco-system that is designed to solve the problems of IR in web platforms. What role can Machine learning play in search relevancy? how natural language processing can help provide a solid understanding of search phrases? How data can drive a personalized search experience? What are the challenges of maintaining such a complex system?  

Read more:
https://2017.berlinbuzzwords.de/17/session/modern-architecture-search

About Alaa Elhadba:
https://2017.berlinbuzzwords.de/users/alaa-elhadba

About Mikio Braun:
https://2017.berlinbuzzwords.de/users/mikio-braun

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,510 --> 00:00:10,440
all right good afternoon everybody I

00:00:07,800 --> 00:00:12,630
hope you had a good nice lunch break our

00:00:10,440 --> 00:00:15,270
talk is about the modern architecture of

00:00:12,630 --> 00:00:17,420
search and before I start I just want to

00:00:15,270 --> 00:00:20,070
say I don't want to impose any any

00:00:17,420 --> 00:00:22,080
methodology or technology on how to do

00:00:20,070 --> 00:00:24,779
things this is just a layout of

00:00:22,080 --> 00:00:27,060
components and architecture diagram of

00:00:24,779 --> 00:00:29,880
certain teams or certain components that

00:00:27,060 --> 00:00:31,619
are each dedicated to do a certain

00:00:29,880 --> 00:00:32,820
function and our teams are

00:00:31,619 --> 00:00:34,350
cross-functional teams between

00:00:32,820 --> 00:00:36,570
researchers and engineers and they're

00:00:34,350 --> 00:00:38,550
trying to find the best way to do this

00:00:36,570 --> 00:00:40,110
function so I hope there's a key

00:00:38,550 --> 00:00:42,360
learning for someone to see how we do

00:00:40,110 --> 00:00:44,040
things and we're changing the way we're

00:00:42,360 --> 00:00:45,450
doing things all the time but the

00:00:44,040 --> 00:00:49,380
function of each component remains the

00:00:45,450 --> 00:00:51,090
same all right so a quick introduction

00:00:49,380 --> 00:00:54,690
on who we are we're solando who knows

00:00:51,090 --> 00:00:57,210
solando or pretty much everybody I can

00:00:54,690 --> 00:00:59,070
cut the introduction then okay just

00:00:57,210 --> 00:01:01,320
quickly we're not a small company we're

00:00:59,070 --> 00:01:03,600
not a start-up we are used to be an

00:01:01,320 --> 00:01:05,369
online fashion retailer but we're

00:01:03,600 --> 00:01:08,310
becoming now an online platform for

00:01:05,369 --> 00:01:11,070
fashion so we're connecting brand

00:01:08,310 --> 00:01:13,200
stylist smashing bloggers customers

00:01:11,070 --> 00:01:14,610
offline stores everybody who's related

00:01:13,200 --> 00:01:17,610
to fashion on one platform that's what

00:01:14,610 --> 00:01:19,890
we're trying to build and we already are

00:01:17,610 --> 00:01:21,570
connected with 1,500 brands we serve 20

00:01:19,890 --> 00:01:24,560
million customers in 15 European

00:01:21,570 --> 00:01:27,480
countries so it's not a small company

00:01:24,560 --> 00:01:29,700
we'll be giving the talk myself my name

00:01:27,480 --> 00:01:31,200
is La Habra I'm part of two teams the

00:01:29,700 --> 00:01:32,370
query understanding an intention team

00:01:31,200 --> 00:01:34,440
which we're going to dive deeply into

00:01:32,370 --> 00:01:36,420
and also part of an architecture team

00:01:34,440 --> 00:01:37,800
was designing how this would work and

00:01:36,420 --> 00:01:42,090
look the vision aligned with the product

00:01:37,800 --> 00:01:45,420
vision in the end and my colleague NICU

00:01:42,090 --> 00:01:51,830
Bron and delivery lead for most of the

00:01:45,420 --> 00:01:54,750
search teams so yeah okay thank you so

00:01:51,830 --> 00:01:55,890
there's a first introduction so right so

00:01:54,750 --> 00:01:57,750
we'll be able you're not just building

00:01:55,890 --> 00:01:59,700
like searchers you think about it search

00:01:57,750 --> 00:02:02,190
is really very very central to any

00:01:59,700 --> 00:02:04,770
e-commerce offering right and and also

00:02:02,190 --> 00:02:06,420
so we are really we don't think of

00:02:04,770 --> 00:02:09,780
ourselves as just a search engine or as

00:02:06,420 --> 00:02:11,610
part of a web website but actually

00:02:09,780 --> 00:02:13,920
really as a platform for search across

00:02:11,610 --> 00:02:16,650
all of the land oh well so here we try

00:02:13,920 --> 00:02:18,629
to picture a bit like how we fit into

00:02:16,650 --> 00:02:19,319
this whole customer cycle and also

00:02:18,629 --> 00:02:22,349
articles like

00:02:19,319 --> 00:02:24,329
so in the lower left you have the

00:02:22,349 --> 00:02:26,189
customer and this is supposed to be a

00:02:24,329 --> 00:02:29,969
monitor this rectangle thing down here

00:02:26,189 --> 00:02:31,530
okay and usually the sort of the journey

00:02:29,969 --> 00:02:32,879
starts with search so they are looking

00:02:31,530 --> 00:02:35,010
for something for black t-shirts and

00:02:32,879 --> 00:02:36,540
then this query ends up with a search

00:02:35,010 --> 00:02:38,040
engine which somehow produces the

00:02:36,540 --> 00:02:41,129
results right but where does the data

00:02:38,040 --> 00:02:43,319
come from so actually some like a few

00:02:41,129 --> 00:02:45,239
steps back there is the factory which is

00:02:43,319 --> 00:02:48,120
producing all the articles and they get

00:02:45,239 --> 00:02:50,099
delivered to our warehouses and and then

00:02:48,120 --> 00:02:51,900
there also we are also taking our own

00:02:50,099 --> 00:02:53,879
photos like we create own content for

00:02:51,900 --> 00:02:55,680
the website and some somewhere during

00:02:53,879 --> 00:02:57,930
this process or the article data gets

00:02:55,680 --> 00:02:59,909
input and gets fed into our system so

00:02:57,930 --> 00:03:01,260
this is one important sort of data and

00:02:59,909 --> 00:03:02,849
then this ends up in search and can

00:03:01,260 --> 00:03:05,459
actually be then be made searchable

00:03:02,849 --> 00:03:08,250
right and of course so only after people

00:03:05,459 --> 00:03:10,319
found articles through search they can

00:03:08,250 --> 00:03:11,849
actually order it this goes back to the

00:03:10,319 --> 00:03:14,819
warehouse and then the delivery guy

00:03:11,849 --> 00:03:16,769
shows up and everybody's happy right and

00:03:14,819 --> 00:03:19,319
at the same time so this is like just

00:03:16,769 --> 00:03:21,239
the one one part of the cycle so article

00:03:19,319 --> 00:03:23,370
data goes to search people can actually

00:03:21,239 --> 00:03:25,470
use it look for it get the results buy

00:03:23,370 --> 00:03:27,930
something and then there are many many

00:03:25,470 --> 00:03:30,389
different things like so how actually

00:03:27,930 --> 00:03:32,220
how do we decide like what to show

00:03:30,389 --> 00:03:33,989
customers first right under we have a

00:03:32,220 --> 00:03:34,560
few hundred thousand articles online at

00:03:33,989 --> 00:03:36,599
all times

00:03:34,560 --> 00:03:37,949
and we need to have some kind of sorting

00:03:36,599 --> 00:03:39,329
to really show the most relevant stuff

00:03:37,949 --> 00:03:44,970
and that's of course also something

00:03:39,329 --> 00:03:47,849
which belongs to search ok they look at

00:03:44,970 --> 00:03:49,560
this all right so before we started with

00:03:47,849 --> 00:03:51,060
the architecture let's go to old-school

00:03:49,560 --> 00:03:54,030
search and how we used to do it in the

00:03:51,060 --> 00:03:56,159
past so in the past we were just doing

00:03:54,030 --> 00:03:58,019
normal string matching using the search

00:03:56,159 --> 00:04:00,329
engine right directly out of the box and

00:03:58,019 --> 00:04:01,829
the idea was that to get the customer

00:04:00,329 --> 00:04:03,810
input and try to match it across many

00:04:01,829 --> 00:04:06,419
fields and by doing that we just run

00:04:03,810 --> 00:04:08,519
smart multi match queries and we try to

00:04:06,419 --> 00:04:10,829
adjust way it's manually by the hand to

00:04:08,519 --> 00:04:13,560
find the better or the best combination

00:04:10,829 --> 00:04:15,030
that would reflect the customer what the

00:04:13,560 --> 00:04:16,829
customer expects to see from our result

00:04:15,030 --> 00:04:18,630
set and doing things manually by hand

00:04:16,829 --> 00:04:21,000
was always very cumbersome because when

00:04:18,630 --> 00:04:22,979
you fix one bug you make other ten and

00:04:21,000 --> 00:04:24,120
it was really hard to maintain adding to

00:04:22,979 --> 00:04:25,620
that so we're trying to do a lot of

00:04:24,120 --> 00:04:27,960
scoring functions that we also maintain

00:04:25,620 --> 00:04:29,580
by hand and then everything's become

00:04:27,960 --> 00:04:31,320
really fuzzy and we cannot keep track of

00:04:29,580 --> 00:04:33,150
things so that's why we needed a

00:04:31,320 --> 00:04:35,040
data-driven way to see how

00:04:33,150 --> 00:04:37,620
can turn this into use machine learning

00:04:35,040 --> 00:04:41,610
use NLP to improve our customer

00:04:37,620 --> 00:04:44,790
experience and that's why we wanted to

00:04:41,610 --> 00:04:46,620
move to a data-driven world all right so

00:04:44,790 --> 00:04:49,140
this is the layout of components I

00:04:46,620 --> 00:04:51,630
mentioned in the beginning I'm going to

00:04:49,140 --> 00:04:53,220
explain how data comes in how cui flows

00:04:51,630 --> 00:04:54,750
as well so how we can traverse this

00:04:53,220 --> 00:04:56,700
architecture or this layout of

00:04:54,750 --> 00:04:58,770
components together and we're going to

00:04:56,700 --> 00:05:01,200
dig deep in parts parts of it so it's a

00:04:58,770 --> 00:05:03,000
lot of a lot of different different

00:05:01,200 --> 00:05:04,380
things and we cannot go deep each one of

00:05:03,000 --> 00:05:05,430
them needs the talk on its own so we're

00:05:04,380 --> 00:05:07,770
going to try to get deep in the most

00:05:05,430 --> 00:05:11,310
important ones all right so let's talk

00:05:07,770 --> 00:05:13,110
about data ingestion first due to the

00:05:11,310 --> 00:05:14,430
nature of the data we're dealing with we

00:05:13,110 --> 00:05:16,920
have three different sources of data

00:05:14,430 --> 00:05:18,420
either we're using our product data or

00:05:16,920 --> 00:05:20,820
any data that's going to be searchable

00:05:18,420 --> 00:05:22,740
or using the logs which we're going to

00:05:20,820 --> 00:05:24,930
try to learn from and improve our models

00:05:22,740 --> 00:05:26,070
or we're crawling data from the web

00:05:24,930 --> 00:05:28,410
which you're going to teach us about the

00:05:26,070 --> 00:05:30,750
fashion language so the Internet is is

00:05:28,410 --> 00:05:32,190
rich with all kind of text and we want

00:05:30,750 --> 00:05:34,260
to learn from this text to improve the

00:05:32,190 --> 00:05:37,230
customer experience on how to search for

00:05:34,260 --> 00:05:38,520
fashion using the fashion language then

00:05:37,230 --> 00:05:40,620
we have another layer for the data

00:05:38,520 --> 00:05:43,650
ingestion we're trying to transform the

00:05:40,620 --> 00:05:48,990
incoming data into fit in our models or

00:05:43,650 --> 00:05:50,130
our data stores then our models are the

00:05:48,990 --> 00:05:51,900
different components so we have the

00:05:50,130 --> 00:05:53,220
fashion language where we try to I

00:05:51,900 --> 00:05:55,830
mention already we try to learn from

00:05:53,220 --> 00:05:57,570
from the web or phrases store which we

00:05:55,830 --> 00:06:00,180
try to help the customer write better

00:05:57,570 --> 00:06:01,950
queries or the named entities we would

00:06:00,180 --> 00:06:04,560
try to map fashion terms for example

00:06:01,950 --> 00:06:06,150
like blue is a color leather is a

00:06:04,560 --> 00:06:08,460
material and so on so we try to use

00:06:06,150 --> 00:06:10,260
named entity recognition through the

00:06:08,460 --> 00:06:11,760
store or the content so the searchable

00:06:10,260 --> 00:06:13,170
content we're trying to do and finally

00:06:11,760 --> 00:06:15,030
data-driven sorting so how we're going

00:06:13,170 --> 00:06:17,790
to sort these the results set is going

00:06:15,030 --> 00:06:19,500
to be shown to the customer all right

00:06:17,790 --> 00:06:22,110
now we go to the story of a query how

00:06:19,500 --> 00:06:24,600
would a query would traverse the path in

00:06:22,110 --> 00:06:27,210
this architecture and the customer

00:06:24,600 --> 00:06:29,490
journey would be he's writing a query so

00:06:27,210 --> 00:06:32,130
let's say he starts and write tips in in

00:06:29,490 --> 00:06:33,390
the search bar adidas and the first

00:06:32,130 --> 00:06:34,950
thing you will encounter is the query

00:06:33,390 --> 00:06:36,090
helper and refinement dialogue and this

00:06:34,950 --> 00:06:39,450
component is responsible for

00:06:36,090 --> 00:06:40,740
establishing a dialogue with the

00:06:39,450 --> 00:06:43,050
customer so that's what we're aiming for

00:06:40,740 --> 00:06:45,270
is to have a conversation with the data

00:06:43,050 --> 00:06:46,650
and not just full-text search or just

00:06:45,270 --> 00:06:48,090
we're trying to help him

00:06:46,650 --> 00:06:49,290
right the better query and if you didn't

00:06:48,090 --> 00:06:51,090
write the better query then asking

00:06:49,290 --> 00:06:52,710
questions that what would be the next

00:06:51,090 --> 00:06:55,229
step to make your query better or to

00:06:52,710 --> 00:06:57,210
find what you're looking for order

00:06:55,229 --> 00:06:58,979
completion is about so we want to

00:06:57,210 --> 00:07:00,870
correct spell we want to predict the

00:06:58,979 --> 00:07:03,000
next word we want to resolve synonyms or

00:07:00,870 --> 00:07:05,490
acronyms we want to disambiguate terms

00:07:03,000 --> 00:07:07,590
we want it to be even more personalized

00:07:05,490 --> 00:07:09,060
so depending on the customer affinity to

00:07:07,590 --> 00:07:10,560
certain brands or certain categories

00:07:09,060 --> 00:07:12,810
they would be ranked first as

00:07:10,560 --> 00:07:14,970
suggestions according to his input that

00:07:12,810 --> 00:07:16,949
is coming in and finally we want to use

00:07:14,970 --> 00:07:19,020
this user feedback to learn how to do

00:07:16,949 --> 00:07:20,430
that so how would you generate these

00:07:19,020 --> 00:07:22,590
phrases that the customers are looking

00:07:20,430 --> 00:07:24,000
at we have two different two different

00:07:22,590 --> 00:07:26,580
sources either we're using the our

00:07:24,000 --> 00:07:28,740
original product data or we're using the

00:07:26,580 --> 00:07:30,330
logs so for the product data we combine

00:07:28,740 --> 00:07:32,310
different fields together like brand

00:07:30,330 --> 00:07:35,190
color material category or product name

00:07:32,310 --> 00:07:36,630
and we generate all possible phrases but

00:07:35,190 --> 00:07:39,210
based on language rules that are

00:07:36,630 --> 00:07:41,639
predefined we store this in the phrases

00:07:39,210 --> 00:07:43,620
store and then retrieval is then using

00:07:41,639 --> 00:07:45,090
the scoring function which decides what

00:07:43,620 --> 00:07:46,410
will be shown to the customer first

00:07:45,090 --> 00:07:49,050
we're going to talk about the retrieving

00:07:46,410 --> 00:07:50,639
score function later adding Suzette's do

00:07:49,050 --> 00:07:53,639
we want to learn this person lies too

00:07:50,639 --> 00:07:55,320
based on the customer logs we can

00:07:53,639 --> 00:07:56,880
aggregate these together and know which

00:07:55,320 --> 00:07:58,560
brands and categories he prefers in

00:07:56,880 --> 00:08:02,130
order to decide this how we do this

00:07:58,560 --> 00:08:04,320
personalization so the scoring function

00:08:02,130 --> 00:08:05,970
of doing this suggestions we rely on hit

00:08:04,320 --> 00:08:08,280
position which means the word that the

00:08:05,970 --> 00:08:09,599
user is writing is it the first position

00:08:08,280 --> 00:08:11,550
in the sentence or the second we

00:08:09,599 --> 00:08:14,460
definitely prefer to be the first and

00:08:11,550 --> 00:08:16,800
turn frequencies also entity reference

00:08:14,460 --> 00:08:19,560
so if somebody's starting to write a

00:08:16,800 --> 00:08:21,840
brand name or just throw in two or three

00:08:19,560 --> 00:08:23,010
letters we prefer brands over colors for

00:08:21,840 --> 00:08:26,639
example because this is more relevant

00:08:23,010 --> 00:08:27,900
for us and also the Revathy where

00:08:26,639 --> 00:08:29,760
everything means how long is the

00:08:27,900 --> 00:08:31,650
customer input in comparison to the

00:08:29,760 --> 00:08:33,390
suggestions that are generated so you

00:08:31,650 --> 00:08:35,099
cannot enter just one or two words and

00:08:33,390 --> 00:08:36,810
then you have a six seven words as a

00:08:35,099 --> 00:08:38,969
suggestion so we're trying to keep it

00:08:36,810 --> 00:08:40,800
like a proportionate and finally user

00:08:38,969 --> 00:08:43,110
clicks and user clicks have a certain

00:08:40,800 --> 00:08:45,360
time decay function which decides okay

00:08:43,110 --> 00:08:46,740
so clicks that came from last year are

00:08:45,360 --> 00:08:51,089
less valuable that the same clicks

00:08:46,740 --> 00:08:52,650
amount that came from yesterday all

00:08:51,089 --> 00:08:54,570
right so after the customer gets some

00:08:52,650 --> 00:08:56,010
suggestions writes better query or maybe

00:08:54,570 --> 00:08:57,900
he doesn't use this correction at all

00:08:56,010 --> 00:08:59,579
and just write something and sometimes

00:08:57,900 --> 00:09:00,510
they don't use fashion terms that would

00:08:59,579 --> 00:09:01,830
be better for what there

00:09:00,510 --> 00:09:03,180
looking for so not all our customers

00:09:01,830 --> 00:09:05,220
know how to use fashion language and

00:09:03,180 --> 00:09:07,130
would they say something like language

00:09:05,220 --> 00:09:10,110
light which means like a long dress and

00:09:07,130 --> 00:09:13,500
we we try to learn from other customers

00:09:10,110 --> 00:09:14,580
who who know the fashion language based

00:09:13,500 --> 00:09:16,760
on the session domain and we use

00:09:14,580 --> 00:09:19,080
something called the query query

00:09:16,760 --> 00:09:21,180
similarity so when people are trying to

00:09:19,080 --> 00:09:22,800
refine their query we know that and we

00:09:21,180 --> 00:09:24,360
know it's within the same category we

00:09:22,800 --> 00:09:25,650
try to learn from it and then when

00:09:24,360 --> 00:09:28,310
people would search for something

00:09:25,650 --> 00:09:30,630
similar we would definitely suggest

00:09:28,310 --> 00:09:32,580
based on the semantic space we already

00:09:30,630 --> 00:09:34,140
know the semantic meaning of the user

00:09:32,580 --> 00:09:35,280
what is looking for and we try to match

00:09:34,140 --> 00:09:37,740
this with something that would get

00:09:35,280 --> 00:09:39,450
better results for the customer in this

00:09:37,740 --> 00:09:43,320
case maxi Clyde is the better term to

00:09:39,450 --> 00:09:44,790
describe these type of dresses and to

00:09:43,320 --> 00:09:46,440
add personalization I already mentioned

00:09:44,790 --> 00:09:48,090
so whatever the customers doing we're

00:09:46,440 --> 00:09:50,880
aggregating back in the search logs and

00:09:48,090 --> 00:09:53,940
we improve our scoring based on that so

00:09:50,880 --> 00:09:56,280
this was about suggestions and then

00:09:53,940 --> 00:09:58,170
let's go to full text search how we

00:09:56,280 --> 00:10:03,810
understand user queries and how we

00:09:58,170 --> 00:10:07,860
construct them all right so let's say

00:10:03,810 --> 00:10:10,230
the user starts with our money later

00:10:07,860 --> 00:10:12,570
yakin which means our money leather

00:10:10,230 --> 00:10:14,490
jackets and as you can see there's the

00:10:12,570 --> 00:10:16,740
type of already so the first thing the

00:10:14,490 --> 00:10:19,230
flow of query understanding is the first

00:10:16,740 --> 00:10:21,030
thing we spell check so we fix the user

00:10:19,230 --> 00:10:22,290
input and then we check against

00:10:21,030 --> 00:10:23,640
redirects and I'm going to talk about

00:10:22,290 --> 00:10:26,010
this later but let's say for now there

00:10:23,640 --> 00:10:28,080
are no redirects and then we do any our

00:10:26,010 --> 00:10:30,330
scoring so we ask the named entity store

00:10:28,080 --> 00:10:33,360
what are these terms what do they mean

00:10:30,330 --> 00:10:34,770
and for us they mean every term goes to

00:10:33,360 --> 00:10:36,480
the named entity stores are going to be

00:10:34,770 --> 00:10:37,620
checked for some scores so the term can

00:10:36,480 --> 00:10:39,720
be ambiguous can mean different things

00:10:37,620 --> 00:10:41,340
for example Aida which is leather can be

00:10:39,720 --> 00:10:43,500
a category can be a material and we

00:10:41,340 --> 00:10:45,330
score that in comparative like according

00:10:43,500 --> 00:10:46,680
to the customer input we get all

00:10:45,330 --> 00:10:48,570
possible scores and all possible

00:10:46,680 --> 00:10:50,940
entities and then the interpretation

00:10:48,570 --> 00:10:53,640
engine decides based on this course for

00:10:50,940 --> 00:10:56,430
every term to spawn all different

00:10:53,640 --> 00:11:01,740
interpretations combined so from every

00:10:56,430 --> 00:11:03,270
from every map of term to entity we

00:11:01,740 --> 00:11:04,560
spawn all possible interpretations so

00:11:03,270 --> 00:11:06,390
our money could be one-time a brand

00:11:04,560 --> 00:11:08,040
could be one-time a product name later

00:11:06,390 --> 00:11:10,890
can be immaterial another time can be a

00:11:08,040 --> 00:11:13,020
fallback can be a category and also we

00:11:10,890 --> 00:11:14,339
use compound words to split later yakin

00:11:13,020 --> 00:11:16,589
so we try to set

00:11:14,339 --> 00:11:18,540
these sorts in German one word but then

00:11:16,589 --> 00:11:20,610
if we if we want to search for later and

00:11:18,540 --> 00:11:22,709
yakin alone we have to split them and

00:11:20,610 --> 00:11:24,839
all these interpretations are spanned

00:11:22,709 --> 00:11:26,399
out and each one it's a stream of

00:11:24,839 --> 00:11:29,249
interpretations that each one has its

00:11:26,399 --> 00:11:31,079
own path and within this path we want to

00:11:29,249 --> 00:11:33,420
enrich more information based on this

00:11:31,079 --> 00:11:35,759
enrichment based on this interpretation

00:11:33,420 --> 00:11:38,730
so we would enrich stuff to try to

00:11:35,759 --> 00:11:39,959
capture what the customer it's the

00:11:38,730 --> 00:11:42,120
customer input is missing so we're

00:11:39,959 --> 00:11:44,069
trying to capture more improve his

00:11:42,120 --> 00:11:47,790
recall so some some stuff like for

00:11:44,069 --> 00:11:49,680
example la di akka is also cool Aida is

00:11:47,790 --> 00:11:51,300
also may be recommended for him or

00:11:49,680 --> 00:11:54,269
Valley akan and we do this as part of

00:11:51,300 --> 00:11:57,269
enrichment of this given stream in the

00:11:54,269 --> 00:11:59,129
end we collect all these streams in

00:11:57,269 --> 00:12:00,569
parallel everything is just happening in

00:11:59,129 --> 00:12:03,329
parallel and we have a scoring engine

00:12:00,569 --> 00:12:05,040
which decides what are the most what are

00:12:03,329 --> 00:12:06,740
the best interpretations and what can be

00:12:05,040 --> 00:12:10,019
the customer actually looking for and

00:12:06,740 --> 00:12:12,589
the problem is if you have a five terms

00:12:10,019 --> 00:12:15,149
query this could lead to 100,000

00:12:12,589 --> 00:12:16,920
interpretations and that's why before we

00:12:15,149 --> 00:12:19,410
do any calculation we try to use some

00:12:16,920 --> 00:12:22,019
rules to improve how we can make a good

00:12:19,410 --> 00:12:23,970
selection of interpretations and in the

00:12:22,019 --> 00:12:26,730
end our scoring engine will give us some

00:12:23,970 --> 00:12:28,529
confidence factors on each on each query

00:12:26,730 --> 00:12:30,120
that is constructed in the end so we we

00:12:28,529 --> 00:12:31,889
have a structured query out of the

00:12:30,120 --> 00:12:35,550
unstructured incoming text from the

00:12:31,889 --> 00:12:38,220
customer until now we bet high on one

00:12:35,550 --> 00:12:40,620
interpretation and we use it but we're

00:12:38,220 --> 00:12:41,970
now also evaluating to provide a result

00:12:40,620 --> 00:12:44,309
set that combines different

00:12:41,970 --> 00:12:45,959
interpretations together and then gather

00:12:44,309 --> 00:12:48,179
feedback from that and see what the

00:12:45,959 --> 00:12:49,259
customer is actually how we can learn

00:12:48,179 --> 00:12:54,959
from customer behavior what

00:12:49,259 --> 00:12:57,209
interpretation is better so back to the

00:12:54,959 --> 00:13:01,019
other example sometimes sometimes

00:12:57,209 --> 00:13:03,300
there's always this angry customer this

00:13:01,019 --> 00:13:05,279
gangster who comes to the store and just

00:13:03,300 --> 00:13:06,300
steps and blurs out one word to you and

00:13:05,279 --> 00:13:08,189
you don't know what to do with it so

00:13:06,300 --> 00:13:10,620
this guy comes to you and just say denim

00:13:08,189 --> 00:13:12,329
and and what is denim so you're looking

00:13:10,620 --> 00:13:15,089
for four jackets or pants

00:13:12,329 --> 00:13:16,410
is it like skinny fit is it a perfect

00:13:15,089 --> 00:13:18,600
what are you looking for how do I do

00:13:16,410 --> 00:13:20,819
with it how do I deal with it and that's

00:13:18,600 --> 00:13:22,649
why there is no data-driven way to deal

00:13:20,819 --> 00:13:26,459
with that denim is the most ambiguous

00:13:22,649 --> 00:13:27,990
term in in the fashion language and for

00:13:26,459 --> 00:13:30,270
that we we have read our

00:13:27,990 --> 00:13:32,640
so we try to capture we don't want to

00:13:30,270 --> 00:13:36,060
pick up this guy so we try to capture

00:13:32,640 --> 00:13:38,160
his his denim wishes by offering the

00:13:36,060 --> 00:13:40,290
redirect and the redirect is a way of

00:13:38,160 --> 00:13:43,470
doing guided search so we lend him on a

00:13:40,290 --> 00:13:44,880
page where he can go through a denim a

00:13:43,470 --> 00:13:46,680
different customer journey so it's not

00:13:44,880 --> 00:13:50,959
search anymore but at least he can still

00:13:46,680 --> 00:13:55,580
continue fulfilling his denim wishes

00:13:50,959 --> 00:13:55,580
yeah I'm going to hand over to Mickey oh

00:13:55,700 --> 00:14:02,339
thank you right right so this was the

00:13:59,490 --> 00:14:03,690
the basic pipeline which we have and the

00:14:02,339 --> 00:14:05,640
question and so but so far we haven't

00:14:03,690 --> 00:14:07,170
really talked about the data where does

00:14:05,640 --> 00:14:09,270
the data come from apart from the actual

00:14:07,170 --> 00:14:10,709
article data okay so I'm going to start

00:14:09,270 --> 00:14:12,450
there and then also explore a bit more

00:14:10,709 --> 00:14:15,149
the mode data different ways of

00:14:12,450 --> 00:14:16,709
enriching their data okay so as I said

00:14:15,149 --> 00:14:20,580
in the beginning like the most basic

00:14:16,709 --> 00:14:22,170
data you have is the article data which

00:14:20,580 --> 00:14:23,399
can tell you like what are brands that

00:14:22,170 --> 00:14:25,470
we have for our categories what are

00:14:23,399 --> 00:14:27,959
colors and that already can give you get

00:14:25,470 --> 00:14:30,990
you very far one problem is that this

00:14:27,959 --> 00:14:32,820
data is usually it's sort of collected

00:14:30,990 --> 00:14:34,470
by by people and it's not really it's

00:14:32,820 --> 00:14:35,520
not really optimized for the search use

00:14:34,470 --> 00:14:36,899
case right so there's some

00:14:35,520 --> 00:14:38,880
inconsistencies and so on that's

00:14:36,899 --> 00:14:41,010
original of work but then there is also

00:14:38,880 --> 00:14:42,750
stuff like like new trends like new

00:14:41,010 --> 00:14:44,579
vocabulary special vocabulary that comes

00:14:42,750 --> 00:14:46,920
up which is not in the article data

00:14:44,579 --> 00:14:49,230
right so like it was a trend like both

00:14:46,920 --> 00:14:50,850
red jeans or hobo or ad so these are all

00:14:49,230 --> 00:14:52,770
some some more concepts people use to

00:14:50,850 --> 00:14:54,329
talk about session but which is not

00:14:52,770 --> 00:14:56,910
really in the article data would be very

00:14:54,329 --> 00:14:58,529
costly to add to each item and then

00:14:56,910 --> 00:15:00,000
there is also stuff like occasions like

00:14:58,529 --> 00:15:01,649
you want to use looking for something

00:15:00,000 --> 00:15:03,510
for a wedding or for party right and you

00:15:01,649 --> 00:15:05,700
cannot really go ahead and like for each

00:15:03,510 --> 00:15:07,410
article decide which protects to put on

00:15:05,700 --> 00:15:10,050
there so what question is how can we

00:15:07,410 --> 00:15:13,079
actually in which our data using more

00:15:10,050 --> 00:15:17,459
data you know to to get good databases

00:15:13,079 --> 00:15:20,070
for for search so there are two things

00:15:17,459 --> 00:15:21,959
one on the left right the ideas so you

00:15:20,070 --> 00:15:23,940
could for example cross section blocks

00:15:21,959 --> 00:15:27,000
right so there's a lot of text being

00:15:23,940 --> 00:15:28,829
generated about fashion topics you could

00:15:27,000 --> 00:15:32,180
crawl all of that and then do natural

00:15:28,829 --> 00:15:34,350
language processing on that too - both

00:15:32,180 --> 00:15:35,850
detect your trends but also to

00:15:34,350 --> 00:15:37,860
understand like with which words are

00:15:35,850 --> 00:15:40,589
actually related to the trend or you

00:15:37,860 --> 00:15:41,329
could also will sort of say okay there's

00:15:40,589 --> 00:15:43,519
a bit

00:15:41,329 --> 00:15:45,649
stuff which is sort of no and we can try

00:15:43,519 --> 00:15:47,720
to build an ontology for that right so

00:15:45,649 --> 00:15:50,119
not like ontology and there's 19th kind

00:15:47,720 --> 00:15:51,860
of sense but more so like a curated list

00:15:50,119 --> 00:15:53,119
of words and you sort of know what they

00:15:51,860 --> 00:15:54,709
means and know how they relate to

00:15:53,119 --> 00:15:57,319
articles and also how they relate to one

00:15:54,709 --> 00:15:59,209
another and then if somebody types in

00:15:57,319 --> 00:16:00,439
denim right so you could either have in

00:15:59,209 --> 00:16:02,299
the trends you sort of know what it is

00:16:00,439 --> 00:16:04,459
or in the ontology actually has it then

00:16:02,299 --> 00:16:06,139
then and denim end point which then

00:16:04,459 --> 00:16:07,819
tells you how to expand that thing to

00:16:06,139 --> 00:16:11,149
map it back down to something which you

00:16:07,819 --> 00:16:13,459
can actually search right so one more

00:16:11,149 --> 00:16:15,769
one thing you can use this so you have

00:16:13,459 --> 00:16:18,019
all these words and one way sort of to

00:16:15,769 --> 00:16:20,089
automatically derive synonyms between

00:16:18,019 --> 00:16:23,929
words is an algorithm called word to

00:16:20,089 --> 00:16:25,699
work words to lick difficult to

00:16:23,929 --> 00:16:28,069
pronounce okay and so the basic idea of

00:16:25,699 --> 00:16:29,689
this is the following that the user does

00:16:28,069 --> 00:16:33,949
some kind of like beside deep learning

00:16:29,689 --> 00:16:36,319
approach to to learn a representation of

00:16:33,949 --> 00:16:39,350
the words in a vector space where

00:16:36,319 --> 00:16:41,089
similarities are semantic so right okay

00:16:39,350 --> 00:16:44,360
so what does it mean so the basic idea

00:16:41,089 --> 00:16:45,769
is so you have like stuff like friends

00:16:44,360 --> 00:16:48,350
with this capital pair so you have all

00:16:45,769 --> 00:16:51,199
these sentences talking about words okay

00:16:48,350 --> 00:16:54,470
and the idea is you sort of you take the

00:16:51,199 --> 00:16:56,629
weather two words occur together as a

00:16:54,470 --> 00:16:58,939
hint for whether they have similar

00:16:56,629 --> 00:17:01,639
meaning right so here both words friends

00:16:58,939 --> 00:17:04,429
pairs both occur with capital and that

00:17:01,639 --> 00:17:06,019
sort of says okay maybe this is if

00:17:04,429 --> 00:17:09,230
there's enough statistics to explain

00:17:06,019 --> 00:17:10,699
that or - right then there's some

00:17:09,230 --> 00:17:12,500
relationship between these things and

00:17:10,699 --> 00:17:15,260
what you essentially do is you construct

00:17:12,500 --> 00:17:17,120
you you sort of you take you encode all

00:17:15,260 --> 00:17:19,610
the words in this really long vector

00:17:17,120 --> 00:17:21,500
which has just all zeros except for one

00:17:19,610 --> 00:17:22,939
at the word which you're looking at so

00:17:21,500 --> 00:17:25,130
everything is zero except for the one

00:17:22,939 --> 00:17:27,110
place where that you have front and then

00:17:25,130 --> 00:17:28,459
what you want to get out of this is you

00:17:27,110 --> 00:17:33,110
want to have the probability that this

00:17:28,459 --> 00:17:36,019
word occurs together with France like in

00:17:33,110 --> 00:17:38,210
the same sentence okay and the model

00:17:36,019 --> 00:17:40,610
sort of internally you have a much

00:17:38,210 --> 00:17:42,470
smaller space let's say maybe yes I

00:17:40,610 --> 00:17:43,940
don't know fifty thousand words here but

00:17:42,470 --> 00:17:46,340
actually internally you you only have a

00:17:43,940 --> 00:17:48,679
thousand numbers you're trying to map

00:17:46,340 --> 00:17:51,640
this through right and then so there's a

00:17:48,679 --> 00:17:54,430
very nice post here by

00:17:51,640 --> 00:17:56,530
McCormick's and L which which explains

00:17:54,430 --> 00:17:58,030
this and steps but the basic idea is you

00:17:56,530 --> 00:17:59,980
sort of you're building a network which

00:17:58,030 --> 00:18:01,990
predicts these probabilities based on

00:17:59,980 --> 00:18:03,640
the input but in a way that it has to

00:18:01,990 --> 00:18:05,650
reduce the dimensionality and

00:18:03,640 --> 00:18:07,840
interestingly what comes out is that in

00:18:05,650 --> 00:18:09,580
this space you have so in this

00:18:07,840 --> 00:18:11,350
representation in this space words which

00:18:09,580 --> 00:18:13,900
has similar semantic meaning are also

00:18:11,350 --> 00:18:17,710
close and you can even do like a bit of

00:18:13,900 --> 00:18:20,580
arithmetic in there to sort of take do

00:18:17,710 --> 00:18:24,220
stuff like okay what is like friends to

00:18:20,580 --> 00:18:25,420
Paris is like London - hmm and then you

00:18:24,220 --> 00:18:27,610
do this kind of thing and you get out

00:18:25,420 --> 00:18:29,190
that this actually there to England okay

00:18:27,610 --> 00:18:32,170
and you can sort of you can do this

00:18:29,190 --> 00:18:33,760
right you can take all the the fashion

00:18:32,170 --> 00:18:35,380
blocks that you have and do this kind of

00:18:33,760 --> 00:18:37,210
analysis and then do something like a

00:18:35,380 --> 00:18:39,160
data-driven brand for placement or

00:18:37,210 --> 00:18:44,650
category replacement to sort of help

00:18:39,160 --> 00:18:46,180
extend the way the search works okay so

00:18:44,650 --> 00:18:48,310
once we have all of this so we have this

00:18:46,180 --> 00:18:51,610
big pipeline right we enriched our data

00:18:48,310 --> 00:18:55,120
from other data sources and we first

00:18:51,610 --> 00:18:56,350
helped sort of extend the searches with

00:18:55,120 --> 00:18:57,760
autosuggest and other things we

00:18:56,350 --> 00:19:00,160
understood the thing and have enough

00:18:57,760 --> 00:19:03,100
interpretation and then what you have in

00:19:00,160 --> 00:19:04,750
the end is so you start with this

00:19:03,100 --> 00:19:06,910
unstructured query which is essentially

00:19:04,750 --> 00:19:08,230
just the search text you do all this

00:19:06,910 --> 00:19:09,730
analysis and then you end up with a

00:19:08,230 --> 00:19:12,130
structured query and then you can fire

00:19:09,730 --> 00:19:15,070
this again like search of the context

00:19:12,130 --> 00:19:17,140
tent which would be more classical

00:19:15,070 --> 00:19:18,700
search engine like elastic search of

00:19:17,140 --> 00:19:21,160
solar and then all of that you get the

00:19:18,700 --> 00:19:22,960
result set and then the question is the

00:19:21,160 --> 00:19:28,120
next question is how do you actually

00:19:22,960 --> 00:19:29,410
present these results okay and that

00:19:28,120 --> 00:19:32,470
brings us to data different sorting

00:19:29,410 --> 00:19:35,460
right so usually when you do search like

00:19:32,470 --> 00:19:37,540
full-text search you have a lot of

00:19:35,460 --> 00:19:39,310
indicators of what is relevant to which

00:19:37,540 --> 00:19:40,960
word which are the documents which

00:19:39,310 --> 00:19:43,480
contain this word very often and so on

00:19:40,960 --> 00:19:44,710
but but in this context here because

00:19:43,480 --> 00:19:47,730
this is more or less a structured query

00:19:44,710 --> 00:19:49,960
right so this could be show me all

00:19:47,730 --> 00:19:52,000
articles which are in that category for

00:19:49,960 --> 00:19:54,100
that color for the brand well there

00:19:52,000 --> 00:19:55,510
isn't a lot of like the data itself

00:19:54,100 --> 00:19:56,860
doesn't tell you a lot what is actually

00:19:55,510 --> 00:20:00,760
relevant or not so what you want to do

00:19:56,860 --> 00:20:02,440
is you want to take the like all the

00:20:00,760 --> 00:20:04,300
user interactions and all of that to

00:20:02,440 --> 00:20:05,120
sort of determine what is what is most

00:20:04,300 --> 00:20:07,340
relevant

00:20:05,120 --> 00:20:09,680
okay and actually the problem is pretty

00:20:07,340 --> 00:20:11,630
so we often say like that that sorting

00:20:09,680 --> 00:20:13,340
is like the most political feature of

00:20:11,630 --> 00:20:14,870
search because there are many many

00:20:13,340 --> 00:20:16,790
stakeholders who want to influence that

00:20:14,870 --> 00:20:18,620
right so let's say you guys have this

00:20:16,790 --> 00:20:20,720
article grid and of course the lower you

00:20:18,620 --> 00:20:22,850
go the less relevant the article should

00:20:20,720 --> 00:20:24,380
be and then there are stakeholders right

00:20:22,850 --> 00:20:26,360
to say okay actually I want to push up

00:20:24,380 --> 00:20:27,800
this article because this is from a

00:20:26,360 --> 00:20:29,990
brand we made an arrangement we are

00:20:27,800 --> 00:20:31,970
pushing up stuff a bit right or they say

00:20:29,990 --> 00:20:33,440
the season has changed now we want to

00:20:31,970 --> 00:20:34,880
push up all the some articles you want

00:20:33,440 --> 00:20:36,440
to push down the other articles and all

00:20:34,880 --> 00:20:38,300
of that and all these people come by and

00:20:36,440 --> 00:20:42,680
say you know I want to change the

00:20:38,300 --> 00:20:44,330
sorting in this way or another way yes

00:20:42,680 --> 00:20:45,890
or actually so there are different ways

00:20:44,330 --> 00:20:48,200
what you can do about this so it's not

00:20:45,890 --> 00:20:51,410
just simply you know you look at what

00:20:48,200 --> 00:20:54,950
people are clicking it or what people

00:20:51,410 --> 00:20:57,080
are buying and you sort this up but so

00:20:54,950 --> 00:20:58,100
usually you have some so one thing we

00:20:57,080 --> 00:21:00,350
have for example doing we are

00:20:58,100 --> 00:21:01,850
introducing a bucketing logic on the

00:21:00,350 --> 00:21:03,530
sorting right so we're saying there are

00:21:01,850 --> 00:21:04,910
different kinds of articles or the

00:21:03,530 --> 00:21:07,550
articles which sell really well

00:21:04,910 --> 00:21:09,440
which are their articles where we had a

00:21:07,550 --> 00:21:10,730
lot of returns or something and we put

00:21:09,440 --> 00:21:12,740
them into different buckets and that

00:21:10,730 --> 00:21:14,600
already gives you like a very cause way

00:21:12,740 --> 00:21:16,460
to steer actually what's up and what so

00:21:14,600 --> 00:21:17,960
and then within these buckets you can

00:21:16,460 --> 00:21:21,020
actually use a fully data-driven

00:21:17,960 --> 00:21:22,760
approach which sort of again the user is

00:21:21,020 --> 00:21:24,680
the monitor and some from that you get

00:21:22,760 --> 00:21:28,100
locks which look like this so they're

00:21:24,680 --> 00:21:29,300
different articles and the the action

00:21:28,100 --> 00:21:31,550
back keep left clicked on a particular

00:21:29,300 --> 00:21:32,060
sport and this is the position where to

00:21:31,550 --> 00:21:33,950
turn

00:21:32,060 --> 00:21:35,150
occurred in the in the scene right and

00:21:33,950 --> 00:21:36,470
then what you want to do is you want of

00:21:35,150 --> 00:21:38,540
course have the articles which are

00:21:36,470 --> 00:21:41,180
clicked and bought often higher up than

00:21:38,540 --> 00:21:43,610
the rest and in the end you can use

00:21:41,180 --> 00:21:45,620
their learning to rank so there were a

00:21:43,610 --> 00:21:47,090
lot of talks already and this but

00:21:45,620 --> 00:21:49,610
essentially what you do is you get the

00:21:47,090 --> 00:21:51,530
the article itself so not the article

00:21:49,610 --> 00:21:54,980
itself but some representation of that

00:21:51,530 --> 00:21:57,080
article for example in terms of brands

00:21:54,980 --> 00:21:59,570
colors and all of that right so you're

00:21:57,080 --> 00:22:02,660
trying to describe the article to the

00:21:59,570 --> 00:22:04,460
learning algorithm and you you put in

00:22:02,660 --> 00:22:06,230
like the the rank where it was clicked

00:22:04,460 --> 00:22:08,210
and then based on that you're trying to

00:22:06,230 --> 00:22:11,480
learn a model which predicts well the

00:22:08,210 --> 00:22:13,040
rank of the like what in which in which

00:22:11,480 --> 00:22:15,050
order you want to present the articles

00:22:13,040 --> 00:22:17,030
and you combine all this with a bucket

00:22:15,050 --> 00:22:18,470
logic to be able to to steer the whole

00:22:17,030 --> 00:22:22,280
thing for you

00:22:18,470 --> 00:22:24,530
okay and is learning to rank so there

00:22:22,280 --> 00:22:28,370
are many different ways to do it there's

00:22:24,530 --> 00:22:31,010
a one paper from Torino fraeno who

00:22:28,370 --> 00:22:33,500
actually works and recommendation at the

00:22:31,010 --> 00:22:35,330
londo so I'm not definitely not going to

00:22:33,500 --> 00:22:38,630
explain this thing right but in the end

00:22:35,330 --> 00:22:39,980
so what you have to sasai w that's sort

00:22:38,630 --> 00:22:42,650
of your model it's a very simple model

00:22:39,980 --> 00:22:44,420
which sort of takes your your features

00:22:42,650 --> 00:22:47,450
and just puts different weights on there

00:22:44,420 --> 00:22:49,400
so it says okay this brand b if it's if

00:22:47,450 --> 00:22:51,320
it's this brand and actually it should

00:22:49,400 --> 00:22:52,910
get a weight of 0.5 and so on and in the

00:22:51,320 --> 00:22:54,620
sauna some of all these things and this

00:22:52,910 --> 00:22:56,240
gives you an ordering and the only

00:22:54,620 --> 00:22:58,250
interesting thing sort of is that the

00:22:56,240 --> 00:23:00,470
the loss function you're trying to

00:22:58,250 --> 00:23:02,840
minimize this piece down here right

00:23:00,470 --> 00:23:05,150
that's actually what it's trying to

00:23:02,840 --> 00:23:06,680
measure is if if this function you're

00:23:05,150 --> 00:23:08,210
predicting gives you the right order

00:23:06,680 --> 00:23:10,130
right so the main difference between

00:23:08,210 --> 00:23:12,740
learning to rank and other kinds of

00:23:10,130 --> 00:23:14,810
learning is the the how you are

00:23:12,740 --> 00:23:16,460
measuring the the fit of your model well

00:23:14,810 --> 00:23:18,230
then you don't measure it by whether you

00:23:16,460 --> 00:23:19,790
can correctly predict the rank or

00:23:18,230 --> 00:23:21,950
something but if you take the

00:23:19,790 --> 00:23:25,160
predictions and then sort your items

00:23:21,950 --> 00:23:26,630
according to this prediction then the

00:23:25,160 --> 00:23:28,130
the ordering should be the right thing

00:23:26,630 --> 00:23:30,020
and this is sort of what makes these

00:23:28,130 --> 00:23:31,820
things a bit complicated but this is a

00:23:30,020 --> 00:23:34,790
very interesting nice paper which is

00:23:31,820 --> 00:23:36,110
also very very schedule very well and

00:23:34,790 --> 00:23:39,220
you can really learn on millions of

00:23:36,110 --> 00:23:44,210
clicks with very little

00:23:39,220 --> 00:23:46,010
computation overhead ok so this sort of

00:23:44,210 --> 00:23:49,100
completes the whole pipeline right so we

00:23:46,010 --> 00:23:50,750
had to layer the query the extra query

00:23:49,100 --> 00:23:53,030
we went to different stages we got the

00:23:50,750 --> 00:23:56,620
results head we sorted it so the last

00:23:53,030 --> 00:23:56,620
question is what about personalization

00:23:56,800 --> 00:24:01,850
so personalization I mean very roughly

00:23:59,960 --> 00:24:05,630
the idea is sort of you're not they all

00:24:01,850 --> 00:24:08,240
have different different like

00:24:05,630 --> 00:24:09,350
preferences and so on and the goal is of

00:24:08,240 --> 00:24:10,940
course to find the most relevant

00:24:09,350 --> 00:24:13,490
articles for each user and there's a

00:24:10,940 --> 00:24:14,720
sort of sort of here but preferably also

00:24:13,490 --> 00:24:15,740
in a way that you have the feeling

00:24:14,720 --> 00:24:17,030
you're not just interacting with the

00:24:15,740 --> 00:24:20,090
database but actually something that

00:24:17,030 --> 00:24:22,310
just users trying to understand you ok

00:24:20,090 --> 00:24:23,570
indeed now the interesting thing is you

00:24:22,310 --> 00:24:25,610
should take this kind of data-driven

00:24:23,570 --> 00:24:28,010
approach then actually it's not that

00:24:25,610 --> 00:24:30,920
much it doesn't it's not that much more

00:24:28,010 --> 00:24:31,670
to to add the personalization to all of

00:24:30,920 --> 00:24:35,030
that

00:24:31,670 --> 00:24:36,590
right because let's say so you already

00:24:35,030 --> 00:24:39,680
have a data-driven approach where you

00:24:36,590 --> 00:24:40,520
put in the features of your articles but

00:24:39,680 --> 00:24:42,350
you could just enrich this

00:24:40,520 --> 00:24:44,240
representation also maybe with some of

00:24:42,350 --> 00:24:45,980
the features which you have on the user

00:24:44,240 --> 00:24:48,710
and then in the interaction between

00:24:45,980 --> 00:24:50,960
these things right it's very easy or

00:24:48,710 --> 00:24:54,650
it's very easily general generalizable

00:24:50,960 --> 00:24:56,240
so that you can also take into take into

00:24:54,650 --> 00:24:58,430
account like at all what your what the

00:24:56,240 --> 00:25:00,020
favorite brands of user or what what is

00:24:58,430 --> 00:25:08,090
past purchases were and so on and you

00:25:00,020 --> 00:25:12,290
can just extend it yes okay so this is

00:25:08,090 --> 00:25:22,580
actually on time this is it so thank you

00:25:12,290 --> 00:25:23,960
very much all right if we have some time

00:25:22,580 --> 00:25:25,790
for questions plenty of time for

00:25:23,960 --> 00:25:36,350
questions because there's one in the

00:25:25,790 --> 00:25:39,050
back minute hey thanks for your talk

00:25:36,350 --> 00:25:40,460
I was curious how do you train your what

00:25:39,050 --> 00:25:47,120
to Vic models which kind of knowledge

00:25:40,460 --> 00:25:49,460
space data sets or the one basis is to

00:25:47,120 --> 00:25:50,770
have all these these cross session

00:25:49,460 --> 00:25:53,000
blocks

00:25:50,770 --> 00:25:56,990
okay but you have a like a generic

00:25:53,000 --> 00:25:59,300
crawler or you just take like dedicated

00:25:56,990 --> 00:26:01,640
set of whitelisted sites and you just go

00:25:59,300 --> 00:26:03,830
through them yes they are no we have no

00:26:01,640 --> 00:26:06,500
it sort of the troll also expands itself

00:26:03,830 --> 00:26:08,600
and sort of takes in links and then

00:26:06,500 --> 00:26:10,910
discovers new blocks but they have this

00:26:08,600 --> 00:26:12,650
kind of infrastructure running which is

00:26:10,910 --> 00:26:14,300
I don't know how many blocks crawling

00:26:12,650 --> 00:26:17,150
right now but it's a few thousands I

00:26:14,300 --> 00:26:19,190
think but you can take that and then

00:26:17,150 --> 00:26:21,320
also expand it with like our Wikipedia

00:26:19,190 --> 00:26:24,910
dumps and all of that is it the same

00:26:21,320 --> 00:26:28,250
corpus you train your entity recognizer

00:26:24,910 --> 00:26:30,110
no think right not I mean the problem is

00:26:28,250 --> 00:26:31,730
you can it's not so then you have these

00:26:30,110 --> 00:26:33,950
session blocks but they are not really

00:26:31,730 --> 00:26:36,440
they are pretty unstructured right and

00:26:33,950 --> 00:26:40,130
for this entity recognizer you actually

00:26:36,440 --> 00:26:41,360
have to have like data which is labeled

00:26:40,130 --> 00:26:45,230
for example

00:26:41,360 --> 00:26:47,899
Thanks or yeah I mean it's a combination

00:26:45,230 --> 00:26:49,970
of both we have we mainly rely of course

00:26:47,899 --> 00:26:51,230
on the fashion content that we have so

00:26:49,970 --> 00:26:52,489
we have a lot of fashion content from

00:26:51,230 --> 00:26:54,980
our product data that we can learn from

00:26:52,489 --> 00:26:57,499
so this is the first generation of our

00:26:54,980 --> 00:26:59,450
model but we also can get similarities

00:26:57,499 --> 00:27:01,039
or we can get stuff that is related to

00:26:59,450 --> 00:27:02,419
it from from crawling the web as well

00:27:01,039 --> 00:27:04,940
and see how people would relate to stuff

00:27:02,419 --> 00:27:07,159
and these fashion blogs usually contain

00:27:04,940 --> 00:27:09,289
a lot of terms and a lot of things that

00:27:07,159 --> 00:27:10,399
explicitly describe how these fashion

00:27:09,289 --> 00:27:12,760
products would look like and it's

00:27:10,399 --> 00:27:14,259
another reference for us to learn from

00:27:12,760 --> 00:27:17,119
[Applause]

00:27:14,259 --> 00:27:19,249
you said.you training your models from

00:27:17,119 --> 00:27:21,499
curries can you talk a little bit about

00:27:19,249 --> 00:27:23,419
like how what's the reoccurrence

00:27:21,499 --> 00:27:25,820
frequency of a query like how often you

00:27:23,419 --> 00:27:28,549
see the same queries and what's the

00:27:25,820 --> 00:27:29,779
distribution of this can you remember it

00:27:28,549 --> 00:27:33,080
from your question I didn't get it clear

00:27:29,779 --> 00:27:34,279
like when if if all your query is that

00:27:33,080 --> 00:27:36,950
you're seeing at this thing

00:27:34,279 --> 00:27:39,980
learning is hard right so they need to

00:27:36,950 --> 00:27:41,690
react EUR to to infer some information

00:27:39,980 --> 00:27:43,609
from it yeah I mean there's of course

00:27:41,690 --> 00:27:45,529
the distribution of query so if you look

00:27:43,609 --> 00:27:47,509
at it as like the top queries and then

00:27:45,529 --> 00:27:49,129
there's a long tail of queries that are

00:27:47,509 --> 00:27:52,009
laid out and some of the queries are

00:27:49,129 --> 00:27:54,289
like coming very frequent so on that

00:27:52,009 --> 00:27:56,899
distribution I'm not sure how to ask you

00:27:54,289 --> 00:27:58,879
a question but maybe it isn't obvious

00:27:56,899 --> 00:28:01,340
with the pin distribution right the

00:27:58,879 --> 00:28:02,989
you're seeing and a lot of like a small

00:28:01,340 --> 00:28:06,049
amount of queries that are reappearing a

00:28:02,989 --> 00:28:07,850
lot of times if this enough to train

00:28:06,049 --> 00:28:10,850
your models or to trying to categorize

00:28:07,850 --> 00:28:13,970
queries together to increase the

00:28:10,850 --> 00:28:15,649
frequencies so okay can I talk about the

00:28:13,970 --> 00:28:19,999
query query similarity or I don't know

00:28:15,649 --> 00:28:22,999
as I can ship yeah okay so we in in a

00:28:19,999 --> 00:28:24,619
way we try to correlate queries together

00:28:22,999 --> 00:28:26,629
to find the similarities between them

00:28:24,619 --> 00:28:28,639
from the semantic meaning yeah so this

00:28:26,629 --> 00:28:31,190
this already exists in the logs and we

00:28:28,639 --> 00:28:33,590
know which queries are there and if we

00:28:31,190 --> 00:28:35,509
put this in the back to space model you

00:28:33,590 --> 00:28:36,679
already can correlate queries together

00:28:35,509 --> 00:28:39,379
and we can also do it the other way

00:28:36,679 --> 00:28:42,619
around that instead that we build a

00:28:39,379 --> 00:28:44,779
model that each product could point to a

00:28:42,619 --> 00:28:46,159
query as well so this is way where

00:28:44,779 --> 00:28:47,749
there's lots of ways that we're trying

00:28:46,159 --> 00:28:49,220
experimenting with to see how we could

00:28:47,749 --> 00:28:51,789
model this that's that's one way of

00:28:49,220 --> 00:28:51,789
doing it is welcome

00:28:52,440 --> 00:29:01,020
all right more questions this one

00:29:06,940 --> 00:29:15,549
I think you said you're serving 50 in 15

00:29:12,940 --> 00:29:18,759
different countries your company is

00:29:15,549 --> 00:29:21,210
operating how do you deal with 15

00:29:18,759 --> 00:29:24,309
different or possibly more languages

00:29:21,210 --> 00:29:27,309
always the same system with different

00:29:24,309 --> 00:29:29,950
input or how do you do that so there are

00:29:27,309 --> 00:29:32,259
10 languages because some some countries

00:29:29,950 --> 00:29:33,940
correlate on languages and we have

00:29:32,259 --> 00:29:35,229
different pipelines for example for

00:29:33,940 --> 00:29:36,580
analyzing each language we have

00:29:35,229 --> 00:29:38,169
different pipelines we have different

00:29:36,580 --> 00:29:39,429
challenges in dealing with each language

00:29:38,169 --> 00:29:41,289
hook down for example the German

00:29:39,429 --> 00:29:43,419
language has the compound words which

00:29:41,289 --> 00:29:45,159
this concept doesn't exist in English so

00:29:43,419 --> 00:29:47,349
that's why we try to deal with each

00:29:45,159 --> 00:29:52,029
language specifically on understanding

00:29:47,349 --> 00:29:56,669
on enrichment and on analysis and for

00:29:52,029 --> 00:30:00,389
search like then when you do the query

00:29:56,669 --> 00:30:02,919
processing so our our online shop is

00:30:00,389 --> 00:30:05,889
distributed as each country gets its own

00:30:02,919 --> 00:30:08,979
domain and each domain would talk its

00:30:05,889 --> 00:30:11,109
own direct language path so there they

00:30:08,979 --> 00:30:13,710
do not say they're not together on one

00:30:11,109 --> 00:30:21,369
on one query search bar for example

00:30:13,710 --> 00:30:24,279
Thanks after thanks for the told my

00:30:21,369 --> 00:30:26,080
questions about learning to rank if you

00:30:24,279 --> 00:30:27,940
have used a solar official

00:30:26,080 --> 00:30:30,369
implementation of the elasticsearch

00:30:27,940 --> 00:30:36,190
implementation or some custom solution

00:30:30,369 --> 00:30:38,289
with the announced sorry which again if

00:30:36,190 --> 00:30:40,629
you have used they officially last a

00:30:38,289 --> 00:30:42,700
solid learning today or the elastic

00:30:40,629 --> 00:30:44,799
stage plug-in or something will die now

00:30:42,700 --> 00:30:46,450
so okay so an official statement were

00:30:44,799 --> 00:30:50,139
big fans of elasticsearch first of all

00:30:46,450 --> 00:30:53,080
and second is we did we do not use them

00:30:50,139 --> 00:30:55,690
learning to rank from from any we built

00:30:53,080 --> 00:30:57,429
our own engine and in recommendation and

00:30:55,690 --> 00:30:59,129
in search and maybe make you could say

00:30:57,429 --> 00:31:01,450
language about it

00:30:59,129 --> 00:31:02,710
yes I mean I only know wrote the paper

00:31:01,450 --> 00:31:05,590
and of course he also did his own

00:31:02,710 --> 00:31:07,930
implementation of that okay

00:31:05,590 --> 00:31:11,920
and staying with their learning today

00:31:07,930 --> 00:31:14,110
about the goal set and about the number

00:31:11,920 --> 00:31:17,050
of issues that you can just give some

00:31:14,110 --> 00:31:21,250
numbers to an understanding about you

00:31:17,050 --> 00:31:24,130
ever deal with arson I think this is

00:31:21,250 --> 00:31:30,970
pretty detailed yeah maybe maybe we can

00:31:24,130 --> 00:31:33,610
talk about it like offstage yes yeah you

00:31:30,970 --> 00:31:36,910
had a slide with an ontology on it my

00:31:33,610 --> 00:31:39,850
question is what are you using ontology

00:31:36,910 --> 00:31:43,260
is for first and the second one which

00:31:39,850 --> 00:31:46,870
kind or which anthologies are you using

00:31:43,260 --> 00:31:49,330
so we are using so we're using it also

00:31:46,870 --> 00:31:52,030
to to sort of record additional fashion

00:31:49,330 --> 00:31:55,420
dictionaries or vocabulary like colors

00:31:52,030 --> 00:31:58,050
or something but it's I mean so we're

00:31:55,420 --> 00:32:01,030
still building that up but it's nothing

00:31:58,050 --> 00:32:03,220
it's again some so that is one of the

00:32:01,030 --> 00:32:06,610
companies which creates a lot of stuff

00:32:03,220 --> 00:32:08,620
writes a lot of stuff in-house right so

00:32:06,610 --> 00:32:10,270
but the idea sort of that you you can't

00:32:08,620 --> 00:32:11,530
find all kinds of words and then also

00:32:10,270 --> 00:32:18,970
know how they relate to each other and

00:32:11,530 --> 00:32:21,340
also our relate to articles and the

00:32:18,970 --> 00:32:24,850
second question second question is what

00:32:21,340 --> 00:32:26,560
what was it which ontology also these

00:32:24,850 --> 00:32:30,280
authorities are had to rated by

00:32:26,560 --> 00:32:32,350
ourselves on which level do they work so

00:32:30,280 --> 00:32:35,680
are they top level on top geez domain

00:32:32,350 --> 00:32:37,330
anthologies you know no I don't know

00:32:35,680 --> 00:32:39,430
so we have a dedicated team that built

00:32:37,330 --> 00:32:40,870
this ontology not letting you in Berlin

00:32:39,430 --> 00:32:42,730
and in Helsinki which should have

00:32:40,870 --> 00:32:44,590
supported and one of the use cases we

00:32:42,730 --> 00:32:46,330
want to use these ontology zin different

00:32:44,590 --> 00:32:48,160
things not just in search so this would

00:32:46,330 --> 00:32:50,650
would help the company in many different

00:32:48,160 --> 00:32:52,630
directions correlate terms and fashion

00:32:50,650 --> 00:32:55,960
fashion terms together and one of which

00:32:52,630 --> 00:32:57,310
is to try to enrich queries with with

00:32:55,960 --> 00:32:58,810
better understanding so if the customer

00:32:57,310 --> 00:33:00,130
writes something and we can we can

00:32:58,810 --> 00:33:02,050
correlate it for other different terms

00:33:00,130 --> 00:33:04,120
that can make a better understanding of

00:33:02,050 --> 00:33:09,310
these requir that's just one use case of

00:33:04,120 --> 00:33:10,870
how to use autologous okay thank you so

00:33:09,310 --> 00:33:13,150
a lot of these topics are quite diverse

00:33:10,870 --> 00:33:14,590
and many teams are working on it so

00:33:13,150 --> 00:33:15,610
definitely we cannot answer all the

00:33:14,590 --> 00:33:18,880
questions

00:33:15,610 --> 00:33:23,560
yeah chat one last question about the

00:33:18,880 --> 00:33:27,940
learning to rank maybe you said that

00:33:23,560 --> 00:33:30,400
from the generators query out of after

00:33:27,940 --> 00:33:32,500
the credit passing you're doing there's

00:33:30,400 --> 00:33:35,140
not much information you get back as a

00:33:32,500 --> 00:33:36,810
score from the search engine itself if

00:33:35,140 --> 00:33:39,400
you want to do learning to wank

00:33:36,810 --> 00:33:41,080
afterwards you need something like you

00:33:39,400 --> 00:33:43,240
can do that on three hundred thousand

00:33:41,080 --> 00:33:45,940
results that comes out of the search

00:33:43,240 --> 00:33:48,310
engine to calculate and really score

00:33:45,940 --> 00:33:53,140
them so how do you find something like

00:33:48,310 --> 00:33:55,780
the top results that then as using to

00:33:53,140 --> 00:33:57,610
produce better to produce pesticides for

00:33:55,780 --> 00:34:00,040
the customer because you cannot do that

00:33:57,610 --> 00:34:02,860
on oil the result yeah not also will the

00:34:00,040 --> 00:34:04,060
onion so that's what I meant with so we

00:34:02,860 --> 00:34:06,670
are of course not we ranking each

00:34:04,060 --> 00:34:08,230
individual item or article but we're

00:34:06,670 --> 00:34:10,330
actually mapping the article to certain

00:34:08,230 --> 00:34:13,270
features like the brand stuff like that

00:34:10,330 --> 00:34:15,250
you know and then the learning to rank

00:34:13,270 --> 00:34:17,710
works on these features I mean so what

00:34:15,250 --> 00:34:21,310
we're so that you're not trying to learn

00:34:17,710 --> 00:34:23,830
whether this this specific issue where

00:34:21,310 --> 00:34:25,750
this should be but more like the other

00:34:23,830 --> 00:34:28,990
features of the two so how would that

00:34:25,750 --> 00:34:31,150
rank because the very very simple thing

00:34:28,990 --> 00:34:32,290
is why do you want to show people some

00:34:31,150 --> 00:34:33,700
people are more interested in other

00:34:32,290 --> 00:34:35,920
brands and then you want to push these

00:34:33,700 --> 00:34:37,840
up but once you have these sort of

00:34:35,920 --> 00:34:39,940
things you can of course put this to

00:34:37,840 --> 00:34:43,420
this course also to the article data and

00:34:39,940 --> 00:34:45,460
then you know use use normal queries to

00:34:43,420 --> 00:34:50,290
compute the scoring function based on

00:34:45,460 --> 00:34:54,520
that for example all right any more

00:34:50,290 --> 00:34:57,030
questions one in the pepper is one of

00:34:54,520 --> 00:34:57,030
the father great

00:34:58,460 --> 00:35:02,850
then we would have time for one more

00:35:01,140 --> 00:35:05,359
question no we close it afterwards

00:35:02,850 --> 00:35:08,550
offline discussion

00:35:05,359 --> 00:35:09,990
hey my question was kind of more

00:35:08,550 --> 00:35:12,240
specific to where where do you actually

00:35:09,990 --> 00:35:14,010
fit in the word to Zack Porter

00:35:12,240 --> 00:35:15,660
because for your named entity

00:35:14,010 --> 00:35:17,700
recognition you essentially do I guess

00:35:15,660 --> 00:35:19,650
query expansion and that kind of made

00:35:17,700 --> 00:35:21,510
sense to me but do you essentially take

00:35:19,650 --> 00:35:24,090
the output of Ward Tyvek and enrich your

00:35:21,510 --> 00:35:25,740
data's offline do you also do query

00:35:24,090 --> 00:35:27,600
expansion with like France and Paris

00:35:25,740 --> 00:35:31,580
online with that how do you actually

00:35:27,600 --> 00:35:31,580
like use the output of word Tyvek

00:35:31,790 --> 00:35:36,720
no okay so yes it is part part of the

00:35:35,190 --> 00:35:38,340
enrichment process we do different types

00:35:36,720 --> 00:35:40,800
of enrichments one of them is to use the

00:35:38,340 --> 00:35:43,830
word Tuvok so for example for to enrich

00:35:40,800 --> 00:35:45,150
categories or or to find any anything

00:35:43,830 --> 00:35:47,130
that is similar so to find similar

00:35:45,150 --> 00:35:49,890
brands as well for stuff that have low

00:35:47,130 --> 00:35:52,410
result set so if we get like a zero or

00:35:49,890 --> 00:35:55,200
three to ten result set we can we can

00:35:52,410 --> 00:35:56,730
replace terms that defined to increase

00:35:55,200 --> 00:35:58,920
recall for example and this is part of

00:35:56,730 --> 00:36:00,869
the enrichment as well all right so that

00:35:58,920 --> 00:36:02,850
then you do this online essentially for

00:36:00,869 --> 00:36:04,740
like replacing the query terms in a

00:36:02,850 --> 00:36:07,740
query or categories that you filter on

00:36:04,740 --> 00:36:09,869
it's not an offline process that you

00:36:07,740 --> 00:36:11,760
then add more properties to your

00:36:09,869 --> 00:36:13,890
documents that you search on just there

00:36:11,760 --> 00:36:16,859
so it's sort of like a post-processing

00:36:13,890 --> 00:36:19,830
steps if sort of you have very small

00:36:16,859 --> 00:36:24,210
result sets right because otherwise it

00:36:19,830 --> 00:36:26,250
would explode the next expansion yeah so

00:36:24,210 --> 00:36:31,590
the model is pre learned and it on real

00:36:26,250 --> 00:36:33,540
time so in query time okay so thanks

00:36:31,590 --> 00:36:36,840
thanks a lot for your attention so we

00:36:33,540 --> 00:36:38,340
have a booth right around the corner and

00:36:36,840 --> 00:36:40,830
if you want to work for the Llano i'm

00:36:38,340 --> 00:36:41,860
talk to us yeah let's take the stick up

00:36:40,830 --> 00:36:44,180
again

00:36:41,860 --> 00:36:47,320
that is

00:36:44,180 --> 00:36:47,320

YouTube URL: https://www.youtube.com/watch?v=BhAGrenI_xE


