Title: Berlin Buzzwords 2017: Diego Ceccarelli, Michael Nilsson - Apache Solr Learning to Rank For The Win!
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	Learning to rank is a technique for automatically improving the quality of results produced by a search engine. It was initially proposed in academia around 17 years ago and almost all commercial web search engines  employ it in some form or other. 

At Bloomberg, we decided that it was time for an open source engine to support learning to rank, so we spent more than a year designing and implementing it. The results of our effort have been accepted by the community and our Learning to Rank plugin is now available in the latest release of Apache Solr (version 6.4). 

In this talk we will explain how learning to rank works, how we implemented and integrated it into Apache Solr, and how you can use it to improve the quality of the results in your search engine.

Read more:
https://2017.berlinbuzzwords.de/17/session/apache-solr-learning-rank-win

About Diego Ceccarelli:
https://2017.berlinbuzzwords.de/users/diego-ceccarelli

About Michael Nilsson:
https://2017.berlinbuzzwords.de/users/michael-nilsson

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,400 --> 00:00:11,070
all right thank you and first I want to

00:00:09,270 --> 00:00:13,770
welcome all of you guys thanks for

00:00:11,070 --> 00:00:15,780
coming and certainly I really want to

00:00:13,770 --> 00:00:17,010
thank everyone for hosting Berlin

00:00:15,780 --> 00:00:18,840
buzzwords and especially guys in the

00:00:17,010 --> 00:00:21,180
back helping us out hooking everything

00:00:18,840 --> 00:00:23,580
up so thank you and from there we'll

00:00:21,180 --> 00:00:25,099
really jump right in so my name is

00:00:23,580 --> 00:00:28,380
Michael Nelson I'm a software engineer

00:00:25,099 --> 00:00:30,359
here at Bloomberg and for those of you

00:00:28,380 --> 00:00:33,690
that don't know Bloomberg is a software

00:00:30,359 --> 00:00:35,130
company in the financial domain and on

00:00:33,690 --> 00:00:38,520
top of you know being able to of course

00:00:35,130 --> 00:00:39,870
do trading you can also use to analyze a

00:00:38,520 --> 00:00:41,850
lot of data one of the things that we

00:00:39,870 --> 00:00:45,630
really focus on Diego and I is in the

00:00:41,850 --> 00:00:47,720
search domain and for search really

00:00:45,630 --> 00:00:51,360
particularly news is one of the big ones

00:00:47,720 --> 00:00:53,490
we've got a huge collection we index

00:00:51,360 --> 00:00:56,220
about 500 million stories are in there

00:00:53,490 --> 00:00:59,250
it's really spiky at time we have value

00:00:56,220 --> 00:01:01,920
on 500 plus stories per second coming in

00:00:59,250 --> 00:01:04,589
we have some isolated constraints in

00:01:01,920 --> 00:01:07,560
terms of speed 180 millisecond response

00:01:04,589 --> 00:01:09,510
time so it's but it's not just search we

00:01:07,560 --> 00:01:11,490
also do alerting but really we're going

00:01:09,510 --> 00:01:12,480
to dive into the search space because

00:01:11,490 --> 00:01:14,910
you know this is what were gonna be

00:01:12,480 --> 00:01:17,370
talking about so what have we been doing

00:01:14,910 --> 00:01:21,300
in the past few years initially we had

00:01:17,370 --> 00:01:23,280
our own proprietary search system we got

00:01:21,300 --> 00:01:25,260
rid of that it was you know pretty much

00:01:23,280 --> 00:01:26,909
news and flexibility and scale so much

00:01:25,260 --> 00:01:28,470
and of course one of the things out

00:01:26,909 --> 00:01:30,720
there that really helps with this is

00:01:28,470 --> 00:01:34,110
leucine and solar so we actually

00:01:30,720 --> 00:01:36,210
migrated to that of course it provides a

00:01:34,110 --> 00:01:39,120
lot of features you know that we didn't

00:01:36,210 --> 00:01:40,740
have of course it's open source and one

00:01:39,120 --> 00:01:42,690
of the great things about that is that

00:01:40,740 --> 00:01:45,000
if you find something wrong with it you

00:01:42,690 --> 00:01:47,190
can contribute back if it doesn't have

00:01:45,000 --> 00:01:48,960
an improvement or enhancement you can

00:01:47,190 --> 00:01:50,610
write it up and you know if it works out

00:01:48,960 --> 00:01:52,080
and it works for you you have a chance

00:01:50,610 --> 00:01:54,720
of actually contributing it back and one

00:01:52,080 --> 00:01:56,549
of the things that we did is contribute

00:01:54,720 --> 00:01:59,180
the learning to rank plugin which is

00:01:56,549 --> 00:02:01,650
upstream Downs Apache Solr six for

00:01:59,180 --> 00:02:03,330
ranking is a really big deal for us and

00:02:01,650 --> 00:02:04,979
on top of that we actually wanted to

00:02:03,330 --> 00:02:07,710
rearrange our results to hopefully give

00:02:04,979 --> 00:02:09,599
us more relevant results so for those of

00:02:07,710 --> 00:02:11,310
you that don't know learning to rank

00:02:09,599 --> 00:02:15,420
really it's just another way of saying

00:02:11,310 --> 00:02:16,640
machine learn re-ranking and just to

00:02:15,420 --> 00:02:18,750
kind of give you quick

00:02:16,640 --> 00:02:20,430
overview you know why would you want to

00:02:18,750 --> 00:02:22,290
do learning to rank of course you have

00:02:20,430 --> 00:02:24,000
your search bar you have your documents

00:02:22,290 --> 00:02:26,640
that come in and one of the first steps

00:02:24,000 --> 00:02:28,290
that you do you kind of tune what you're

00:02:26,640 --> 00:02:30,120
going to search on you've got your

00:02:28,290 --> 00:02:32,310
normal score your documents come back if

00:02:30,120 --> 00:02:34,410
you search for solar here then you're

00:02:32,310 --> 00:02:36,480
like oh I want to tune the titles worth

00:02:34,410 --> 00:02:38,549
more the descriptions may be worth more

00:02:36,480 --> 00:02:40,080
or less and you kind of tweak that and

00:02:38,549 --> 00:02:41,930
your results get a little bit better and

00:02:40,080 --> 00:02:44,310
then you dive into that you're like oh

00:02:41,930 --> 00:02:46,290
maybe document length is important

00:02:44,310 --> 00:02:48,750
freshness you know how recent are these

00:02:46,290 --> 00:02:51,120
documents you know are these going to be

00:02:48,750 --> 00:02:53,730
published today where they published a

00:02:51,120 --> 00:02:55,829
month ago that that matters and you

00:02:53,730 --> 00:02:58,739
spend a lot of time tweaking this you

00:02:55,829 --> 00:03:01,680
got your solar query right but all that

00:02:58,739 --> 00:03:04,379
time you spent tuning it maybe your

00:03:01,680 --> 00:03:06,360
Lucene query now doesn't work you know

00:03:04,379 --> 00:03:07,920
London query doesn't work Bloomberg

00:03:06,360 --> 00:03:09,150
everything so it takes a lot of time you

00:03:07,920 --> 00:03:11,280
have to be a domain expert to really

00:03:09,150 --> 00:03:14,040
dive into this and actually get the

00:03:11,280 --> 00:03:15,660
ranking right so one of the goals with

00:03:14,040 --> 00:03:18,720
the learning to rank plugin essentially

00:03:15,660 --> 00:03:20,600
was to hopefully autumn ah optimize for

00:03:18,720 --> 00:03:22,769
relevancy of this ranking force and

00:03:20,600 --> 00:03:24,540
really get different machine learning

00:03:22,769 --> 00:03:26,069
models of pluggable into the system so

00:03:24,540 --> 00:03:27,750
if you really wanted to you know write

00:03:26,069 --> 00:03:29,760
your own or support new models that we

00:03:27,750 --> 00:03:32,880
don't support you know you can write a

00:03:29,760 --> 00:03:34,799
Java class and hook it in and on top of

00:03:32,880 --> 00:03:36,660
that since it's actually a part of solar

00:03:34,799 --> 00:03:38,819
you get access to a lot of the rich

00:03:36,660 --> 00:03:41,400
features that so it provides for feature

00:03:38,819 --> 00:03:43,260
engineering so what we're really going

00:03:41,400 --> 00:03:45,959
to get dive into here is essentially the

00:03:43,260 --> 00:03:47,760
pipeline to build out a learning to rank

00:03:45,959 --> 00:03:51,419
system and where the plug-in actually

00:03:47,760 --> 00:03:52,650
fits into this and just after that the

00:03:51,419 --> 00:03:55,049
first thing you has to do is actually

00:03:52,650 --> 00:03:57,620
collect query document judgments this is

00:03:55,049 --> 00:03:59,459
going to go into your training set and

00:03:57,620 --> 00:04:01,440
essentially what this is you have your

00:03:59,459 --> 00:04:03,690
query and your documents you really need

00:04:01,440 --> 00:04:06,329
to have someone judge where the

00:04:03,690 --> 00:04:09,299
documents are good or bad now that could

00:04:06,329 --> 00:04:10,829
be yes/no thumbs up thumbs down good

00:04:09,299 --> 00:04:13,889
document bad document for this query

00:04:10,829 --> 00:04:16,260
Apple you can use a star system in this

00:04:13,889 --> 00:04:19,410
case maybe Tim Cook for Apple is a 3 out

00:04:16,260 --> 00:04:21,539
of 5 stars the actual ticker itself five

00:04:19,410 --> 00:04:23,970
out of five and then others like apple

00:04:21,539 --> 00:04:25,800
seeds not really relevant at all but

00:04:23,970 --> 00:04:26,930
it's up to you to essentially collect

00:04:25,800 --> 00:04:28,580
that data

00:04:26,930 --> 00:04:32,240
and there's a couple ways you can do

00:04:28,580 --> 00:04:33,889
this you can pay judges experts to

00:04:32,240 --> 00:04:35,630
actually do this manually you can even

00:04:33,889 --> 00:04:37,160
crowdsource this there are other

00:04:35,630 --> 00:04:39,289
platforms out there we can use

00:04:37,160 --> 00:04:41,479
Mechanical Turk you can use CrowdFlower

00:04:39,289 --> 00:04:43,810
there are ways to actually you know get

00:04:41,479 --> 00:04:46,160
this kind of curation now another way is

00:04:43,810 --> 00:04:47,990
implicitly which you can kind of infer

00:04:46,160 --> 00:04:49,699
this through user behavior

00:04:47,990 --> 00:04:51,500
maybe you aggregate a bunch of result

00:04:49,699 --> 00:04:53,090
clicks you can use a few other things

00:04:51,500 --> 00:04:55,880
like query your formulation or dwell

00:04:53,090 --> 00:04:57,350
time to kind of imply what that

00:04:55,880 --> 00:05:00,289
relevance would be for that query

00:04:57,350 --> 00:05:02,270
document pair so now that you have a

00:05:00,289 --> 00:05:03,590
bunch of judgments for all your queries

00:05:02,270 --> 00:05:06,080
and documents that you think are

00:05:03,590 --> 00:05:08,539
important and a relevance judgment you

00:05:06,080 --> 00:05:11,780
neither need to extract the features for

00:05:08,539 --> 00:05:13,400
those documents and for this same query

00:05:11,780 --> 00:05:15,380
maybe a few of the features that you'd

00:05:13,400 --> 00:05:17,539
want to extract in this case I have the

00:05:15,380 --> 00:05:19,280
query match the title that's pretty

00:05:17,539 --> 00:05:21,970
important you know so that's a feature

00:05:19,280 --> 00:05:25,000
that you would write freshness how

00:05:21,970 --> 00:05:27,259
recent was this document published today

00:05:25,000 --> 00:05:28,550
yesterday you know that contributes to

00:05:27,259 --> 00:05:31,010
the score a lot of the things that you

00:05:28,550 --> 00:05:32,389
would put into your solar query those

00:05:31,010 --> 00:05:34,190
are typically features that you'd want

00:05:32,389 --> 00:05:35,870
in our case since were from Bloomberg

00:05:34,190 --> 00:05:37,370
maybe we want our Bloomberg documents to

00:05:35,870 --> 00:05:38,870
be up there so maybe I throw that in as

00:05:37,370 --> 00:05:40,880
a feature and how popular are these

00:05:38,870 --> 00:05:42,530
documents really this is where like the

00:05:40,880 --> 00:05:44,240
bread and butter comes in feature

00:05:42,530 --> 00:05:47,389
engineering is really really where a lot

00:05:44,240 --> 00:05:49,250
of the work goes in that you have to you

00:05:47,389 --> 00:05:52,310
know really pretty much write a lot of

00:05:49,250 --> 00:05:55,159
code or configure ization to essentially

00:05:52,310 --> 00:05:57,860
extract this information so in this

00:05:55,159 --> 00:05:59,960
particular case with the plugin you

00:05:57,860 --> 00:06:01,430
would define a file a features a JSON

00:05:59,960 --> 00:06:03,229
file and this would be a sample of what

00:06:01,430 --> 00:06:04,520
that would look like in this case for

00:06:03,229 --> 00:06:06,650
you know the features I just mentioned

00:06:04,520 --> 00:06:08,000
earlier did the query match the title

00:06:06,650 --> 00:06:10,250
what's the freshness is it from

00:06:08,000 --> 00:06:12,940
Bloomberg who popularity now this JSON

00:06:10,250 --> 00:06:14,810
file where you can fig the features

00:06:12,940 --> 00:06:16,370
essentially it's a list of these

00:06:14,810 --> 00:06:17,659
features that has a name so that way you

00:06:16,370 --> 00:06:20,449
can identify it when you're extracting

00:06:17,659 --> 00:06:22,550
the features you specify essentially the

00:06:20,449 --> 00:06:23,720
class that it's going to reference

00:06:22,550 --> 00:06:26,690
actually the code that's going to

00:06:23,720 --> 00:06:28,039
execute and inside the prams one of the

00:06:26,690 --> 00:06:31,159
good things about this is you can use

00:06:28,039 --> 00:06:32,900
solar queries to define your features so

00:06:31,159 --> 00:06:35,360
in this case for the match title I'm

00:06:32,900 --> 00:06:37,279
using the field feature to search on the

00:06:35,360 --> 00:06:37,770
title and then essentially whatever text

00:06:37,279 --> 00:06:39,479
is going to be

00:06:37,770 --> 00:06:41,910
sin I want to see if it matches that

00:06:39,479 --> 00:06:43,680
field and the output is going to be the

00:06:41,910 --> 00:06:45,960
score of that and I'll use that as a

00:06:43,680 --> 00:06:48,479
feature for freshness I'm actually using

00:06:45,960 --> 00:06:50,250
a function query and this is you know

00:06:48,479 --> 00:06:51,960
the standard one that you can see on the

00:06:50,250 --> 00:06:55,159
Wikipedia page and solar essentially

00:06:51,960 --> 00:06:57,330
that's what has a you know a descent of

00:06:55,159 --> 00:06:58,919
depending on how recent the document is

00:06:57,330 --> 00:07:00,419
to get a higher score the older it is

00:06:58,919 --> 00:07:01,590
the lower the score so that's

00:07:00,419 --> 00:07:04,590
essentially the equation there but you

00:07:01,590 --> 00:07:07,560
can use any function query and define it

00:07:04,590 --> 00:07:09,210
as your features among many others there

00:07:07,560 --> 00:07:11,759
so once you've actually defined this

00:07:09,210 --> 00:07:13,919
JSON file you would deploy the solar

00:07:11,759 --> 00:07:15,960
using a curl command taking the feature

00:07:13,919 --> 00:07:18,690
store endpoint so now your features are

00:07:15,960 --> 00:07:20,880
loaded up into solar and then to

00:07:18,690 --> 00:07:22,440
actually extract the features you'd copy

00:07:20,880 --> 00:07:23,819
paste this one line this transformer

00:07:22,440 --> 00:07:26,970
into your solar config so then you have

00:07:23,819 --> 00:07:30,539
access to the transformer which you then

00:07:26,970 --> 00:07:31,949
specify inside of the FL parameter which

00:07:30,539 --> 00:07:33,330
is where you actually want to which

00:07:31,949 --> 00:07:35,789
fields you want to return in this case

00:07:33,330 --> 00:07:38,159
we want to return a fake field which is

00:07:35,789 --> 00:07:40,020
our features field and the value is

00:07:38,159 --> 00:07:41,849
going to be the list of all the features

00:07:40,020 --> 00:07:43,740
and the feature values it will be the

00:07:41,849 --> 00:07:48,090
feature vector which then you can

00:07:43,740 --> 00:07:49,800
extract and then from there combine it

00:07:48,090 --> 00:07:52,560
together into training set for you to

00:07:49,800 --> 00:07:54,389
train your model now now you have your

00:07:52,560 --> 00:07:56,370
judgments your list of query documents

00:07:54,389 --> 00:07:58,979
and judgment relevance now you have the

00:07:56,370 --> 00:07:59,969
documents and the feature vectors next

00:07:58,979 --> 00:08:01,979
thing you need to do is combine them

00:07:59,969 --> 00:08:04,830
into a single file which then you feed

00:08:01,979 --> 00:08:06,539
to a ranking model now there are a

00:08:04,830 --> 00:08:08,039
couple different libraries you can use

00:08:06,539 --> 00:08:10,289
to train the model you can train ranked

00:08:08,039 --> 00:08:13,409
SVM using live linear you can train

00:08:10,289 --> 00:08:16,380
landmark using ranked live now for those

00:08:13,409 --> 00:08:17,729
of you that don't know a model is just

00:08:16,380 --> 00:08:19,949
essentially it's a function that you

00:08:17,729 --> 00:08:22,889
optimize in this case we want to

00:08:19,949 --> 00:08:24,060
optimize ranking over relevancy metrics

00:08:22,889 --> 00:08:27,719
so that way hopefully we get better

00:08:24,060 --> 00:08:29,550
results on top now these libraries that

00:08:27,719 --> 00:08:31,409
you use they're going to output a file

00:08:29,550 --> 00:08:33,630
which is the definition of your model

00:08:31,409 --> 00:08:35,550
and what you're going to have to do is

00:08:33,630 --> 00:08:37,050
essentially deploy that model to solar

00:08:35,550 --> 00:08:40,079
so now you can use it online and query

00:08:37,050 --> 00:08:42,360
time to be ranked your results now there

00:08:40,079 --> 00:08:44,970
is a model file similar to how you would

00:08:42,360 --> 00:08:46,860
write your features file and deploy it

00:08:44,970 --> 00:08:49,890
to solar it'd be the same process for

00:08:46,860 --> 00:08:51,329
defining that model file you essentially

00:08:49,890 --> 00:08:53,430
would just have to transform the output

00:08:51,329 --> 00:08:55,199
of whatever library are using into this

00:08:53,430 --> 00:08:56,970
where you specify the class of the model

00:08:55,199 --> 00:08:59,579
a name so you can identify it so you can

00:08:56,970 --> 00:09:02,010
use it and then the params section is

00:08:59,579 --> 00:09:04,260
essentially depending on which model

00:09:02,010 --> 00:09:06,720
class you're using the definition of the

00:09:04,260 --> 00:09:09,089
model itself in this case and I trained

00:09:06,720 --> 00:09:11,579
my model using lambda mark lamda Mart is

00:09:09,089 --> 00:09:14,040
essentially a force to freeze in a sense

00:09:11,579 --> 00:09:17,040
and so this is an array of trees and

00:09:14,040 --> 00:09:19,560
then you know it just branches out but

00:09:17,040 --> 00:09:21,600
the details essentially is just really

00:09:19,560 --> 00:09:22,740
when you train your model it's going to

00:09:21,600 --> 00:09:24,570
output a file and you're going to

00:09:22,740 --> 00:09:25,890
convert that file into format like this

00:09:24,570 --> 00:09:27,899
and deploy it to solar

00:09:25,890 --> 00:09:29,310
now one of the things that we have

00:09:27,899 --> 00:09:30,959
though is we're going to be doing a

00:09:29,310 --> 00:09:33,690
demonstration of all of these steps

00:09:30,959 --> 00:09:35,550
later on and we have code that does all

00:09:33,690 --> 00:09:38,010
this for you so you can kind of play

00:09:35,550 --> 00:09:39,600
around with that later on so just like I

00:09:38,010 --> 00:09:42,060
said with features you then deploy this

00:09:39,600 --> 00:09:44,339
file to solar so now you can actually

00:09:42,060 --> 00:09:46,110
rearrange your results and this is going

00:09:44,339 --> 00:09:49,920
to be online and this is also using the

00:09:46,110 --> 00:09:51,510
plug-in where you copy/paste is one line

00:09:49,920 --> 00:09:54,779
into your solar config to get access to

00:09:51,510 --> 00:09:56,459
learn to rank a parser plugin and now

00:09:54,779 --> 00:09:59,699
you can actually rewrite your results

00:09:56,459 --> 00:10:01,199
using the RQ query so whatever query

00:09:59,699 --> 00:10:02,520
you're using normally you have your Q

00:10:01,199 --> 00:10:03,990
with your EDA Smacks

00:10:02,520 --> 00:10:05,970
that's essentially going to give you

00:10:03,990 --> 00:10:08,490
your you know it's going to give you

00:10:05,970 --> 00:10:10,290
your top ten results that you see on the

00:10:08,490 --> 00:10:12,329
first page but it's going to score you

00:10:10,290 --> 00:10:14,490
know whatever thousands matched you're

00:10:12,329 --> 00:10:16,560
going to use this to rear Inc let's say

00:10:14,490 --> 00:10:19,170
the top five top ten in this case top

00:10:16,560 --> 00:10:21,660
100 documents now with the machine learn

00:10:19,170 --> 00:10:23,910
model it's a bit more expensive so you

00:10:21,660 --> 00:10:25,860
don't typically use your machine learn

00:10:23,910 --> 00:10:28,140
model to score all your documents in the

00:10:25,860 --> 00:10:31,140
collection you only use it on the top

00:10:28,140 --> 00:10:34,500
ten top end in this case just because

00:10:31,140 --> 00:10:36,270
it's a little bit more expensive so kind

00:10:34,500 --> 00:10:39,390
of diving into the actual request you

00:10:36,270 --> 00:10:40,709
make our Q equals you have the ltr' this

00:10:39,390 --> 00:10:42,899
essentially is the name of the parser

00:10:40,709 --> 00:10:45,449
they're going to use this is standard

00:10:42,899 --> 00:10:46,260
solar notation in this case LTR is just

00:10:45,449 --> 00:10:48,810
the name of the parser you're

00:10:46,260 --> 00:10:52,020
referencing which is what we named it in

00:10:48,810 --> 00:10:53,939
the solar config then the model name

00:10:52,020 --> 00:10:55,140
that you want to use model equals that's

00:10:53,939 --> 00:10:56,910
the name of the model that you deploy to

00:10:55,140 --> 00:10:58,980
solar so that's what I'm going to be

00:10:56,910 --> 00:11:01,380
using for rearranging this case I just

00:10:58,980 --> 00:11:02,190
called it my model name and then reran

00:11:01,380 --> 00:11:03,750
cox is the

00:11:02,190 --> 00:11:06,150
number of documents you want to rewrite

00:11:03,750 --> 00:11:10,290
as the top K in this case 100 that I

00:11:06,150 --> 00:11:11,640
specified and then efi this is a way for

00:11:10,290 --> 00:11:13,860
you to pass in external feature

00:11:11,640 --> 00:11:16,560
information not all features that you're

00:11:13,860 --> 00:11:18,840
going to use for training your model are

00:11:16,560 --> 00:11:21,600
going to exist inside of solar you might

00:11:18,840 --> 00:11:23,760
have a third party system that helps you

00:11:21,600 --> 00:11:25,910
identify maybe chlorine scent and maybe

00:11:23,760 --> 00:11:28,470
that's important the query that comes in

00:11:25,910 --> 00:11:30,540
didn't match the title that also kind of

00:11:28,470 --> 00:11:32,760
comes from your client that's something

00:11:30,540 --> 00:11:34,500
you want to pass in so this is a way for

00:11:32,760 --> 00:11:36,720
you to pass in essentially any list of

00:11:34,500 --> 00:11:38,490
key value pairs that you defined in your

00:11:36,720 --> 00:11:43,710
feature set that it's going to use in

00:11:38,490 --> 00:11:45,570
reference so now that you're rearranging

00:11:43,710 --> 00:11:46,950
your results of course the most

00:11:45,570 --> 00:11:49,140
important part really is are you doing

00:11:46,950 --> 00:11:51,240
better you need to evaluate your results

00:11:49,140 --> 00:11:52,530
I'm not going to dive into really all

00:11:51,240 --> 00:11:54,840
the different kinds of metrics there are

00:11:52,530 --> 00:11:56,600
this is just a very very small subset

00:11:54,840 --> 00:11:58,620
many of you I'm sure already know

00:11:56,600 --> 00:12:00,510
precision that of all the results that

00:11:58,620 --> 00:12:01,740
came back how many are good that's one

00:12:00,510 --> 00:12:02,010
way to figure out if things are good or

00:12:01,740 --> 00:12:04,800
bad

00:12:02,010 --> 00:12:06,030
recall out of all the good documents in

00:12:04,800 --> 00:12:08,280
your whole collection how many did you

00:12:06,030 --> 00:12:10,350
return that's another thing you can use

00:12:08,280 --> 00:12:11,940
to gauge how good things are F store

00:12:10,350 --> 00:12:13,290
it's the harmonically in between the two

00:12:11,940 --> 00:12:16,100
and you can kind of tune if you want a

00:12:13,290 --> 00:12:18,770
favor precision or recall nd CG

00:12:16,100 --> 00:12:21,090
normalize this kind of human lose gain

00:12:18,770 --> 00:12:24,150
this essentially takes in the order of

00:12:21,090 --> 00:12:25,860
the results into your ranking so that

00:12:24,150 --> 00:12:27,450
kind of also favors things that if you

00:12:25,860 --> 00:12:28,440
push to the top that's good if they

00:12:27,450 --> 00:12:31,530
don't make it all the way to the top

00:12:28,440 --> 00:12:33,510
that's not so good but this is not you

00:12:31,530 --> 00:12:35,580
know everything there are a lot of

00:12:33,510 --> 00:12:38,030
papers out there that really dive in to

00:12:35,580 --> 00:12:41,160
different metrics you can use em are are

00:12:38,030 --> 00:12:42,630
mean average decision er there's a lot

00:12:41,160 --> 00:12:43,500
of them a lot of these there's papers

00:12:42,630 --> 00:12:45,000
out there a lot of these are on

00:12:43,500 --> 00:12:46,380
Wikipedia you can kind of implement

00:12:45,000 --> 00:12:48,089
yourself there libraries out there that

00:12:46,380 --> 00:12:49,980
kind of implement this for you but

00:12:48,089 --> 00:12:52,110
really this is essentially what you want

00:12:49,980 --> 00:12:55,650
to use to measure how good your system

00:12:52,110 --> 00:12:58,050
is before ranking after re-ranking to

00:12:55,650 --> 00:13:00,180
really kind of gauge how things are so

00:12:58,050 --> 00:13:02,220
from there it's time for a demo I'm

00:13:00,180 --> 00:13:03,450
going to hand it over to Diego for us

00:13:02,220 --> 00:13:05,130
and he's actually going to step through

00:13:03,450 --> 00:13:07,800
everything that I kind of followed

00:13:05,130 --> 00:13:09,650
except with you know a real real code

00:13:07,800 --> 00:13:13,300
and real demonstration so

00:13:09,650 --> 00:13:13,300
good luck see mine

00:13:18,750 --> 00:13:24,030
so now I'm going to do something really

00:13:20,880 --> 00:13:26,790
dangerous that you should never do in a

00:13:24,030 --> 00:13:30,120
pole I'm gonna give you a live demo of

00:13:26,790 --> 00:13:31,890
the plug-in so it could be that I mess

00:13:30,120 --> 00:13:34,590
up but I'm quite confident because today

00:13:31,890 --> 00:13:36,180
I did a sacrifice a sacrifice to lots of

00:13:34,590 --> 00:13:37,560
the god of damage so I hope it will be

00:13:36,180 --> 00:13:39,210
fine

00:13:37,560 --> 00:13:42,120
before I start I just have a question

00:13:39,210 --> 00:13:44,100
for you how many of you know knew before

00:13:42,120 --> 00:13:47,400
what is precision record can you raise

00:13:44,100 --> 00:13:50,790
your hands okay out of the room okay

00:13:47,400 --> 00:13:53,220
thank you so so I'm gonna show you use

00:13:50,790 --> 00:13:54,960
this demo because with Mike we were

00:13:53,220 --> 00:13:56,400
discussing how to do the pole can we saw

00:13:54,960 --> 00:14:00,960
that it was nice to show that it

00:13:56,400 --> 00:14:03,380
actually works so this demo will be

00:14:00,960 --> 00:14:07,830
available on the Bloomberg guitar soon

00:14:03,380 --> 00:14:09,660
and it will be it the demo is a fork of

00:14:07,830 --> 00:14:12,510
loosing solo so it will be a branch in

00:14:09,660 --> 00:14:14,730
our the seen solar force so in a couple

00:14:12,510 --> 00:14:16,500
of weeks I will tweet about that and if

00:14:14,730 --> 00:14:20,720
you go on the Bloomberg github you can

00:14:16,500 --> 00:14:24,300
download the code and play with it so

00:14:20,720 --> 00:14:25,770
how that it's work so first of all so

00:14:24,300 --> 00:14:27,600
the demo will be automatic everything

00:14:25,770 --> 00:14:29,940
will go out but I just wanted to point

00:14:27,600 --> 00:14:31,320
out that if you want to use the plug-in

00:14:29,940 --> 00:14:34,260
the only thing that you have to do is

00:14:31,320 --> 00:14:37,140
take your solar schema and add these two

00:14:34,260 --> 00:14:38,520
lights so one will import the ranker so

00:14:37,140 --> 00:14:40,620
the guy that actually do their banking

00:14:38,520 --> 00:14:44,010
inside solar and use much learning and

00:14:40,620 --> 00:14:47,730
allows you to plug in the learning trend

00:14:44,010 --> 00:14:49,200
models and other features that are so if

00:14:47,730 --> 00:14:52,500
you feature to the Stormin that allows

00:14:49,200 --> 00:14:54,390
you to get in in the response together

00:14:52,500 --> 00:14:56,040
with your document the future vector of

00:14:54,390 --> 00:15:00,900
all the features I'm going to show you

00:14:56,040 --> 00:15:03,740
later how you use this so the example so

00:15:00,900 --> 00:15:07,200
first of all few words about the setup

00:15:03,740 --> 00:15:09,510
as you probably know in solar there are

00:15:07,200 --> 00:15:11,850
several examples that you can run and

00:15:09,510 --> 00:15:14,910
play with one that is quite popular is

00:15:11,850 --> 00:15:19,140
tech products and if you go on the

00:15:14,910 --> 00:15:20,880
learning to rank wiki page on solar you

00:15:19,140 --> 00:15:23,580
will see that we provide an example on

00:15:20,880 --> 00:15:25,770
tech product so you just run solar tech

00:15:23,580 --> 00:15:27,520
products and you get you can play with

00:15:25,770 --> 00:15:29,410
learning it's rank but the text

00:15:27,520 --> 00:15:32,140
that is really small so you can't really

00:15:29,410 --> 00:15:34,510
see outwards with a via connections so

00:15:32,140 --> 00:15:37,630
for this demo we decided to use the

00:15:34,510 --> 00:15:40,540
simple Wikipedia JSON down so it's a is

00:15:37,630 --> 00:15:42,730
the pump from Wikipedia

00:15:40,540 --> 00:15:45,280
we didn't use the English one because

00:15:42,730 --> 00:15:46,990
you know it's like four million article

00:15:45,280 --> 00:15:48,820
and it's several gigabytes one let you

00:15:46,990 --> 00:15:53,050
download it so it was not easy to like

00:15:48,820 --> 00:15:54,940
share and provide what we use it's a

00:15:53,050 --> 00:15:57,190
simple so I don't know if you know but

00:15:54,940 --> 00:15:58,810
there is a particular Wikipedia there

00:15:57,190 --> 00:16:00,760
are multiple languages you can see

00:15:58,810 --> 00:16:02,950
Wikipedia in Japanese in English but

00:16:00,760 --> 00:16:04,990
this one it is called simple and it

00:16:02,950 --> 00:16:06,760
contains only the most important article

00:16:04,990 --> 00:16:10,450
explained in a simple English for people

00:16:06,760 --> 00:16:16,590
that are not really yeah proficient with

00:16:10,450 --> 00:16:20,500
English like me so it contains only

00:16:16,590 --> 00:16:25,570
150,000 articles so it's reasonable to

00:16:20,500 --> 00:16:28,690
to ingest and we converted it in jasmine

00:16:25,570 --> 00:16:31,240
so we use a library that part the wiki

00:16:28,690 --> 00:16:35,410
text that it's not really an easy format

00:16:31,240 --> 00:16:37,270
to to process in solar so it parses the

00:16:35,410 --> 00:16:39,790
wiki text so like old a format that

00:16:37,270 --> 00:16:42,130
Wikipedia used for the articles and it

00:16:39,790 --> 00:16:44,020
produces a JSON with nice fields and

00:16:42,130 --> 00:16:45,460
then we index into solar in the demo

00:16:44,020 --> 00:16:46,930
deletes a script that does this and not

00:16:45,460 --> 00:16:48,400
going to show you now because I don't

00:16:46,930 --> 00:16:50,140
think it's really interesting but there

00:16:48,400 --> 00:16:52,180
is a script that you you download the

00:16:50,140 --> 00:16:57,760
JSON file you run index and it's done

00:16:52,180 --> 00:17:01,180
and and then I changed the way I provide

00:16:57,760 --> 00:17:03,370
a schema or for this for the Wikipedia

00:17:01,180 --> 00:17:04,959
articles that contains all the fields

00:17:03,370 --> 00:17:07,510
that you will see usually in Wikipedia

00:17:04,959 --> 00:17:09,820
and then there is a copy field tab so

00:17:07,510 --> 00:17:11,530
when you run a query you by default to

00:17:09,820 --> 00:17:14,380
read text and this completely contains

00:17:11,530 --> 00:17:17,890
all the textual field of Wikipedia

00:17:14,380 --> 00:17:19,600
article in Wikipedia so okay so now we

00:17:17,890 --> 00:17:22,839
can start actually doing things so I

00:17:19,600 --> 00:17:25,570
hope everything will work let me go yeah

00:17:22,839 --> 00:17:28,590
so first thing is just query the

00:17:25,570 --> 00:17:31,240
collection so if I go on Safari

00:17:28,590 --> 00:17:33,520
yes so here you see I'm just screening

00:17:31,240 --> 00:17:35,290
for all the documents and so this is

00:17:33,520 --> 00:17:38,260
good so I can show you that the size of

00:17:35,290 --> 00:17:40,150
the collection is really 150,000

00:17:38,260 --> 00:17:40,600
documents and here I'm just getting

00:17:40,150 --> 00:17:43,570
random

00:17:40,600 --> 00:17:46,120
document and I get glory as it does

00:17:43,570 --> 00:17:48,100
first one and you can see the schema we

00:17:46,120 --> 00:17:50,200
have like many things so we have the

00:17:48,100 --> 00:17:52,929
title we have things that I highlighted

00:17:50,200 --> 00:17:56,380
in the page we have the paragraph that

00:17:52,929 --> 00:17:57,970
is a list of strings one element for

00:17:56,380 --> 00:18:00,070
each paragraph we have if there is a

00:17:57,970 --> 00:18:04,390
list in the article we released we have

00:18:00,070 --> 00:18:07,270
this section the title ID and so on so

00:18:04,390 --> 00:18:10,090
this is our typical document in the

00:18:07,270 --> 00:18:13,110
collection so then what I can do now I

00:18:10,090 --> 00:18:16,059
can try a create so standard query

00:18:13,110 --> 00:18:18,490
babbling so here I'm just using the

00:18:16,059 --> 00:18:19,900
default ranking of solar they wanted to

00:18:18,490 --> 00:18:21,940
get when you stole it for the first time

00:18:19,900 --> 00:18:27,070
and at the moment in swordstick 6b and

00:18:21,940 --> 00:18:29,380
25 so yeah this is result I got 1000

00:18:27,070 --> 00:18:31,870
results back and the first one with

00:18:29,380 --> 00:18:35,530
score 10.6 six its

00:18:31,870 --> 00:18:37,299
east-berlin that could be fine I could

00:18:35,530 --> 00:18:39,520
say that I'm happy if I see spelling

00:18:37,299 --> 00:18:43,690
start looking for reading but maybe we

00:18:39,520 --> 00:18:45,220
can do better in this demo so we so my

00:18:43,690 --> 00:18:47,140
before show you all the steps so I'm

00:18:45,220 --> 00:18:48,760
going to go through all these steps when

00:18:47,140 --> 00:18:53,110
you train a model and show you so the

00:18:48,760 --> 00:18:55,090
first thing is run the demo I am

00:18:53,110 --> 00:18:57,130
cheating I've already done this I will

00:18:55,090 --> 00:19:04,299
skip this they're just running demo it

00:18:57,130 --> 00:19:08,200
will open up a web page and and the

00:19:04,299 --> 00:19:10,210
first thing that we want to see is a no

00:19:08,200 --> 00:19:12,130
data collection so we want to create our

00:19:10,210 --> 00:19:14,860
training set we want to have some quiz

00:19:12,130 --> 00:19:18,190
and say which documents were relevant or

00:19:14,860 --> 00:19:21,130
not for for the quiz so this is what the

00:19:18,190 --> 00:19:24,100
demo merely provides so I wrote this

00:19:21,130 --> 00:19:27,280
small prototype using flask in Python

00:19:24,100 --> 00:19:29,650
and so here on the Left I have a bunch

00:19:27,280 --> 00:19:32,669
of queries and for each query I have all

00:19:29,650 --> 00:19:34,900
the Wikipedia pages that they default

00:19:32,669 --> 00:19:37,090
ranking installer returned with me and

00:19:34,900 --> 00:19:39,549
then I can mark the results relevant or

00:19:37,090 --> 00:19:42,039
not I was choosing the query so I choose

00:19:39,549 --> 00:19:44,049
create on which I felt confident that I

00:19:42,039 --> 00:19:45,190
knew what was relevant or not there

00:19:44,049 --> 00:19:47,500
could be that there is something wrong

00:19:45,190 --> 00:19:49,990
I'm sorry so you can see here in green

00:19:47,500 --> 00:19:53,120
things are relevant in red things that

00:19:49,990 --> 00:19:55,340
are not relevant so I can show you

00:19:53,120 --> 00:19:57,320
actually I could say like bernadtom it's

00:19:55,340 --> 00:20:00,260
relevant so I click and I put it

00:19:57,320 --> 00:20:04,210
relevant yeah these are things that I

00:20:00,260 --> 00:20:07,580
know so Italian dishes Steve Jobs London

00:20:04,210 --> 00:20:11,660
flutes I like to play the flute learn

00:20:07,580 --> 00:20:13,640
Python and and so on okay so I have a

00:20:11,660 --> 00:20:15,140
bunch of queries not really much usually

00:20:13,640 --> 00:20:17,420
you want to have around 1,000 queries

00:20:15,140 --> 00:20:19,370
when you do a training set or more so

00:20:17,420 --> 00:20:23,540
the more you put the more the better it

00:20:19,370 --> 00:20:27,980
is okay so yeah I want to have only this

00:20:23,540 --> 00:20:31,010
at 8 by Isilon this year so that so now

00:20:27,980 --> 00:20:35,120
I have a training set so I have a set of

00:20:31,010 --> 00:20:37,610
queries and and judgments and I want to

00:20:35,120 --> 00:20:39,500
train a model from these so what do you

00:20:37,610 --> 00:20:42,410
do if you train a model what you need is

00:20:39,500 --> 00:20:44,330
to have developments and then for each

00:20:42,410 --> 00:20:47,380
document you want to produce a list of

00:20:44,330 --> 00:20:49,840
features so what is a feature again

00:20:47,380 --> 00:20:52,490
micro sorting about that before a

00:20:49,840 --> 00:20:55,490
picture in our plugin it's just a JSON

00:20:52,490 --> 00:20:57,320
snippet and one feature that is

00:20:55,490 --> 00:20:59,960
particularly interesting here is the

00:20:57,320 --> 00:21:02,120
freshness that tells us how when the

00:20:59,960 --> 00:21:04,580
document was created actually so the it

00:21:02,120 --> 00:21:07,930
was code that we want to give to fresh

00:21:04,580 --> 00:21:10,850
documents to boost them because usually

00:21:07,930 --> 00:21:14,720
something was created recently it could

00:21:10,850 --> 00:21:17,780
be that is relevant and so you can look

00:21:14,720 --> 00:21:19,850
these in the solar week it's explained

00:21:17,780 --> 00:21:21,800
it's as this is a standard function

00:21:19,850 --> 00:21:24,500
query that you use when you want to

00:21:21,800 --> 00:21:26,330
boost freshness and we are just reusing

00:21:24,500 --> 00:21:29,060
the Select code we don't have to write

00:21:26,330 --> 00:21:30,890
code to implement these and so all the

00:21:29,060 --> 00:21:32,600
feature that for the queries that you

00:21:30,890 --> 00:21:35,030
can do installer you can do it and the

00:21:32,600 --> 00:21:36,290
score that you get from solar out of the

00:21:35,030 --> 00:21:40,250
query will be the value of the feature

00:21:36,290 --> 00:21:43,010
and so you create this JSON file and

00:21:40,250 --> 00:21:45,380
then you just send it to solar to put

00:21:43,010 --> 00:21:47,090
request and solar will keep it in this

00:21:45,380 --> 00:21:51,110
scheme and you can actually browse it

00:21:47,090 --> 00:21:54,320
from solar I should have it open yeah

00:21:51,110 --> 00:21:58,490
so this is inside solar you can assure

00:21:54,320 --> 00:22:00,770
you so if I go on on solar at this part

00:21:58,490 --> 00:22:02,900
you you will see the feature

00:22:00,770 --> 00:22:05,110
specification file so as you can see I

00:22:02,900 --> 00:22:07,299
have the original score

00:22:05,110 --> 00:22:09,730
by the default ranking formula solar

00:22:07,299 --> 00:22:12,309
then I have a feature that tells me the

00:22:09,730 --> 00:22:15,010
length of the title because like if you

00:22:12,309 --> 00:22:16,900
have a an article that has a really long

00:22:15,010 --> 00:22:18,340
title it could be that is not what you

00:22:16,900 --> 00:22:20,170
really want to see you want to see short

00:22:18,340 --> 00:22:23,860
things that are probably good articles

00:22:20,170 --> 00:22:26,290
and and so on this score just if I eat

00:22:23,860 --> 00:22:28,630
on the thighs or the score is had just

00:22:26,290 --> 00:22:31,030
eat on the sections and so on and then I

00:22:28,630 --> 00:22:32,410
have freshness again you can see it

00:22:31,030 --> 00:22:37,450
sorry about that

00:22:32,410 --> 00:22:39,549
okay okay so another thing that is

00:22:37,450 --> 00:22:42,340
interesting is that some feature like

00:22:39,549 --> 00:22:45,190
these will tell you the score of the

00:22:42,340 --> 00:22:45,610
query if I match the query only on the

00:22:45,190 --> 00:22:48,340
list

00:22:45,610 --> 00:22:49,929
filled in in the article and you can see

00:22:48,340 --> 00:22:52,960
I don't know in advance what will be the

00:22:49,929 --> 00:22:55,090
query so in order to plug the query at

00:22:52,960 --> 00:22:57,549
run time we use the special syntax with

00:22:55,090 --> 00:22:59,230
the dollar so this means that at runtime

00:22:57,549 --> 00:23:02,530
in the query you will pass a special

00:22:59,230 --> 00:23:05,070
field called if F I and we put the query

00:23:02,530 --> 00:23:07,900
and then the query will be the place

00:23:05,070 --> 00:23:11,980
there are intact and you will get a good

00:23:07,900 --> 00:23:14,710
value so let's see this in action so if

00:23:11,980 --> 00:23:18,549
I want to retrieve now this feature for

00:23:14,710 --> 00:23:24,600
my query baylene I will just add ask for

00:23:18,549 --> 00:23:28,299
this special field so feature sorry yes

00:23:24,600 --> 00:23:30,130
please tell me if you can see so I will

00:23:28,299 --> 00:23:32,080
I'm just asking for particular field

00:23:30,130 --> 00:23:35,110
features and I of course and passing the

00:23:32,080 --> 00:23:37,600
query Valene so as you can see I will

00:23:35,110 --> 00:23:39,820
get the normal steal the title of the

00:23:37,600 --> 00:23:42,100
score of solar and then I start I get a

00:23:39,820 --> 00:23:45,910
string that contains of the feature so I

00:23:42,100 --> 00:23:48,280
get the original score Don roba all in

00:23:45,910 --> 00:23:51,160
one string so I can use these to query

00:23:48,280 --> 00:23:54,940
solar and create a training file to

00:23:51,160 --> 00:23:58,840
train my model so let me show you an

00:23:54,940 --> 00:24:02,590
example of training file now to do this

00:23:58,840 --> 00:24:05,020
okay this is a row training file so this

00:24:02,590 --> 00:24:08,799
is this format is quite usually used in

00:24:05,020 --> 00:24:11,559
Academy in academia so it's yeah it's

00:24:08,799 --> 00:24:13,410
quite sad to see but it's just contained

00:24:11,559 --> 00:24:15,540
so we have

00:24:13,410 --> 00:24:17,730
advanced then we have a query ID that

00:24:15,540 --> 00:24:19,590
represents the actual query for a

00:24:17,730 --> 00:24:23,220
particular query in the training set and

00:24:19,590 --> 00:24:27,480
then we have ajust a list of feature ID

00:24:23,220 --> 00:24:30,180
and the value of the feature okay so you

00:24:27,480 --> 00:24:31,890
get these two the two you're learning to

00:24:30,180 --> 00:24:33,600
rank methods that have many and the

00:24:31,890 --> 00:24:36,150
learning to rank method will try to

00:24:33,600 --> 00:24:38,400
learn a model that try to respect the

00:24:36,150 --> 00:24:40,410
value of the fit try to predict the

00:24:38,400 --> 00:24:42,690
developments on the Left based on the

00:24:40,410 --> 00:24:45,210
values on the right okay

00:24:42,690 --> 00:24:46,830
there are many ways to do that there's

00:24:45,210 --> 00:24:50,220
still people inventing new ways to do

00:24:46,830 --> 00:24:52,050
that and I'm going to issues show you

00:24:50,220 --> 00:24:55,410
something some of these methods before

00:24:52,050 --> 00:24:58,590
we dive into training models and deploy

00:24:55,410 --> 00:25:01,440
them let me just show you something in

00:24:58,590 --> 00:25:04,830
the demo page so you see here of my

00:25:01,440 --> 00:25:08,580
relevant sting and on the right I have

00:25:04,830 --> 00:25:10,470
metrics implemented so that was what

00:25:08,580 --> 00:25:12,300
micros talking about before so I have

00:25:10,470 --> 00:25:15,630
just one method here for now so is the

00:25:12,300 --> 00:25:17,400
default ranking and I have precision

00:25:15,630 --> 00:25:22,650
recall and that's major

00:25:17,400 --> 00:25:25,140
and so you see there is a nap after the

00:25:22,650 --> 00:25:28,530
position and they add them twice so

00:25:25,140 --> 00:25:30,450
precision as one and and then I have

00:25:28,530 --> 00:25:34,260
precision of ten the color tan and

00:25:30,450 --> 00:25:37,590
athleisure at 10 and the idea here is

00:25:34,260 --> 00:25:39,990
that when you the idea behind at one is

00:25:37,590 --> 00:25:43,170
that instead of just computing the

00:25:39,990 --> 00:25:45,270
precision considering all the responses

00:25:43,170 --> 00:25:47,250
that you get for your query you just cut

00:25:45,270 --> 00:25:50,670
the rest onto the first result it is one

00:25:47,250 --> 00:25:53,130
and you compute the precision as if your

00:25:50,670 --> 00:25:57,030
method was returning only the highest

00:25:53,130 --> 00:25:58,740
score result okay and this is a use case

00:25:57,030 --> 00:26:00,270
that is really important when you are

00:25:58,740 --> 00:26:02,250
implementing and feeling lucky

00:26:00,270 --> 00:26:03,840
basically because what you want is the

00:26:02,250 --> 00:26:05,520
user to type the query and then you

00:26:03,840 --> 00:26:07,020
redirects and straight to the article

00:26:05,520 --> 00:26:08,400
and as you can imagine if you are

00:26:07,020 --> 00:26:09,810
implementing the search function of

00:26:08,400 --> 00:26:11,310
Wikipedia you really want these you

00:26:09,810 --> 00:26:13,110
don't want people to go through the

00:26:11,310 --> 00:26:14,460
results page and then click on what they

00:26:13,110 --> 00:26:16,760
want you want to send them straight to

00:26:14,460 --> 00:26:19,920
the article that they are looking for

00:26:16,760 --> 00:26:23,300
while precision extends become at 10 and

00:26:19,920 --> 00:26:23,300
f-measure at 10 is

00:26:23,340 --> 00:26:28,800
it's a Google page basically you want to

00:26:26,040 --> 00:26:30,540
optimize the results page so you usually

00:26:28,800 --> 00:26:32,400
have send the results that the users see

00:26:30,540 --> 00:26:34,590
so you really want the top ten results

00:26:32,400 --> 00:26:36,450
to be good you don't care about what the

00:26:34,590 --> 00:26:38,310
user will see on the second page because

00:26:36,450 --> 00:26:41,100
probably is not gonna happen it will

00:26:38,310 --> 00:26:43,470
leave the search page or it will be

00:26:41,100 --> 00:26:45,390
appear so as you can see precision at

00:26:43,470 --> 00:26:47,760
one I'm not going to dive into the other

00:26:45,390 --> 00:26:51,570
measures but position as one means

00:26:47,760 --> 00:26:53,760
basically that only 40% of the results

00:26:51,570 --> 00:26:55,890
for the query contains something

00:26:53,760 --> 00:26:57,840
relevant on the first position so it

00:26:55,890 --> 00:27:01,470
means as I'm just counting here so this

00:26:57,840 --> 00:27:03,120
is good one this is that one bad

00:27:01,470 --> 00:27:05,970
and then I'm doing the ratio and this is

00:27:03,120 --> 00:27:08,550
just like it means that only 40% are

00:27:05,970 --> 00:27:10,890
good and 60% contain unknown relevant

00:27:08,550 --> 00:27:13,860
results on the first position so let's

00:27:10,890 --> 00:27:15,570
say that we want to do better here so

00:27:13,860 --> 00:27:19,830
the first thing that we want to do is

00:27:15,570 --> 00:27:22,890
train a linear model okay I'm fine

00:27:19,830 --> 00:27:25,590
train a linear model it means that I is

00:27:22,890 --> 00:27:28,980
the most easy thing so I want something

00:27:25,590 --> 00:27:31,410
that will take the values of the teacher

00:27:28,980 --> 00:27:34,020
we combine them as in the at the

00:27:31,410 --> 00:27:36,510
beginning like multiplying them for some

00:27:34,020 --> 00:27:38,940
magic number and we return me a score

00:27:36,510 --> 00:27:48,930
where they agree is the score the better

00:27:38,940 --> 00:27:52,200
it is and so so this will train a model

00:27:48,930 --> 00:27:55,110
and we produce a model file that is just

00:27:52,200 --> 00:27:57,870
something similar to this so it's just a

00:27:55,110 --> 00:28:00,210
magic number that multiplies the value

00:27:57,870 --> 00:28:02,010
of the feature and then some to the

00:28:00,210 --> 00:28:05,010
other magic number that multiplies the

00:28:02,010 --> 00:28:06,810
value of the feature and so on and and

00:28:05,010 --> 00:28:08,940
this is a linear model so this produces

00:28:06,810 --> 00:28:10,980
a linear model put it in a nice JSON and

00:28:08,940 --> 00:28:14,100
send it to solar and then from now on I

00:28:10,980 --> 00:28:16,800
can just call me banking giving the name

00:28:14,100 --> 00:28:19,590
of the model and solar we use this model

00:28:16,800 --> 00:28:21,780
to rank documents and as you can see I

00:28:19,590 --> 00:28:23,490
get some ways usually you don't we

00:28:21,780 --> 00:28:27,270
should not trust them with too much they

00:28:23,490 --> 00:28:29,790
don't mean much like you can say like oh

00:28:27,270 --> 00:28:33,480
these got highways it means that it's

00:28:29,790 --> 00:28:35,250
the most important feature but here we

00:28:33,480 --> 00:28:38,100
can say something there are two features

00:28:35,250 --> 00:28:40,260
that don't have a way so they are zero

00:28:38,100 --> 00:28:43,380
basically we are ignoring these two

00:28:40,260 --> 00:28:45,660
features which type of score and links

00:28:43,380 --> 00:28:48,210
length it means that the model things

00:28:45,660 --> 00:28:50,460
that we don't you know they are not

00:28:48,210 --> 00:28:51,929
useful for predicting the score and

00:28:50,460 --> 00:28:54,060
actually it makes sense because wiki

00:28:51,929 --> 00:28:55,470
title score contains underscore so it

00:28:54,060 --> 00:28:57,750
probably never match the query

00:28:55,470 --> 00:28:59,850
in my training set and links length I

00:28:57,750 --> 00:29:03,750
don't know how you can use link links

00:28:59,850 --> 00:29:06,210
length of the feature so now I loaded

00:29:03,750 --> 00:29:10,380
the model into solar and I go back here

00:29:06,210 --> 00:29:13,260
i refresh oh okay and you can see there

00:29:10,380 --> 00:29:16,610
is a new model if I click on it yes I

00:29:13,260 --> 00:29:19,470
get the new ranking using this model and

00:29:16,610 --> 00:29:21,929
it doesn't look really good yeah

00:29:19,470 --> 00:29:24,630
so as you can see if I will remember it

00:29:21,929 --> 00:29:26,250
doesn't look good but the matrix tells

00:29:24,630 --> 00:29:28,770
these as well so it's not just looking

00:29:26,250 --> 00:29:30,450
at the result it's really numbers we

00:29:28,770 --> 00:29:30,870
have numbers that confirm what we are

00:29:30,450 --> 00:29:32,550
seeing

00:29:30,870 --> 00:29:36,060
so you see precision at one it's worse

00:29:32,550 --> 00:29:37,950
actually and yeah the other numbers

00:29:36,060 --> 00:29:39,630
that'll look great too and the reason

00:29:37,950 --> 00:29:41,310
for this is that this is just a linear

00:29:39,630 --> 00:29:43,710
model it doesn't have any knowledge of

00:29:41,310 --> 00:29:45,390
the ranking is just considering each

00:29:43,710 --> 00:29:47,760
document stand alone and tries to

00:29:45,390 --> 00:29:49,910
predict this the final score out of the

00:29:47,760 --> 00:29:52,470
feature so we can do better there are

00:29:49,910 --> 00:29:53,970
learning to rank algorithm let's look at

00:29:52,470 --> 00:29:54,790
the world list that's why in the

00:29:53,970 --> 00:29:57,340
training set

00:29:54,790 --> 00:29:59,620
with the query ID and they try to push

00:29:57,340 --> 00:30:03,460
relevant results on the top and one of

00:29:59,620 --> 00:30:05,800
these models is rankly and if the model

00:30:03,460 --> 00:30:07,870
is not cleaner so it's not like that you

00:30:05,800 --> 00:30:10,420
can do a combination of stores and you

00:30:07,870 --> 00:30:13,240
get it it's something that is more

00:30:10,420 --> 00:30:15,400
complex and it's based on tweets so you

00:30:13,240 --> 00:30:17,320
browse through trees using the featured

00:30:15,400 --> 00:30:18,910
values and at the end you get that at

00:30:17,320 --> 00:30:21,760
the end of the tree you get scores that

00:30:18,910 --> 00:30:26,560
you combine together and these

00:30:21,760 --> 00:30:29,110
particular library frankly allows you to

00:30:26,560 --> 00:30:32,110
train your model to optimize a

00:30:29,110 --> 00:30:37,200
particular metric so in this case I can

00:30:32,110 --> 00:30:40,600
tell frankly to optimize train a model

00:30:37,200 --> 00:30:44,440
optimizing precision at one okay so I

00:30:40,600 --> 00:30:47,200
hope it will go fine so yes so a train a

00:30:44,440 --> 00:30:49,440
model it did several iteration to try

00:30:47,200 --> 00:30:52,120
try to optimize over the training set

00:30:49,440 --> 00:30:53,950
the model and in the end you gave

00:30:52,120 --> 00:30:55,450
obviously I think I reach the optimum on

00:30:53,950 --> 00:31:00,130
this training model and I got the

00:30:55,450 --> 00:31:03,040
precision of one 89% so if I now refresh

00:31:00,130 --> 00:31:06,700
here it's in solar and you can see

00:31:03,040 --> 00:31:08,620
position at one is now 89% if I click

00:31:06,700 --> 00:31:12,430
here and watch your results and you see

00:31:08,620 --> 00:31:14,470
now it looks better so if I go through

00:31:12,430 --> 00:31:17,190
you can see that actually many results

00:31:14,470 --> 00:31:20,320
are green on the top now so it's pushed

00:31:17,190 --> 00:31:21,790
relevant stuff on the top and if we look

00:31:20,320 --> 00:31:24,760
at the other metrics we see that now we

00:31:21,790 --> 00:31:26,290
are really good on precision upon recall

00:31:24,760 --> 00:31:29,140
that means the number of relevant

00:31:26,290 --> 00:31:32,470
results on the top increase but still

00:31:29,140 --> 00:31:34,540
like at 10 we are not looking great so

00:31:32,470 --> 00:31:38,590
like the default model is still doing

00:31:34,540 --> 00:31:43,780
better and we are not improving here so

00:31:38,590 --> 00:31:47,470
what we can do we can try to improve and

00:31:43,780 --> 00:31:49,870
ECG that is a measure that look really

00:31:47,470 --> 00:31:52,900
at the ranking so if you are just

00:31:49,870 --> 00:31:54,580
looking at position of 10 you're just

00:31:52,900 --> 00:31:57,190
computing the ratio between the relevant

00:31:54,580 --> 00:32:00,010
and then not relevant results so if you

00:31:57,190 --> 00:32:02,400
have 5 relevant results from position

00:32:00,010 --> 00:32:04,990
five to position 10 your precision is

00:32:02,400 --> 00:32:05,970
0.5 because alphas your results are

00:32:04,990 --> 00:32:08,610
relevant on the top

00:32:05,970 --> 00:32:11,789
but if they are on the top which is

00:32:08,610 --> 00:32:13,440
better yet precision is still at 0.5 so

00:32:11,789 --> 00:32:16,080
you don't really get the difference and

00:32:13,440 --> 00:32:17,759
this is G gives you different values so

00:32:16,080 --> 00:32:20,009
if they are on the top you will get an

00:32:17,759 --> 00:32:21,809
ECG one if they are on the bottom you

00:32:20,009 --> 00:32:24,210
will get I don't know how much probably

00:32:21,809 --> 00:32:30,320
0.3 or something like that so we want to

00:32:24,210 --> 00:32:36,450
optimize real ranking and the CG then

00:32:30,320 --> 00:32:41,129
and now I got NBC GSN 0 92 so if i

00:32:36,450 --> 00:32:43,559
refresh here I get like better I get

00:32:41,129 --> 00:32:45,570
precision at 1 1 it means that all the

00:32:43,559 --> 00:32:50,309
results on the top are always relevant

00:32:45,570 --> 00:32:56,190
you can see so always green not here

00:32:50,309 --> 00:32:59,639
well I didn't didn't press ok so back

00:32:56,190 --> 00:33:04,379
Green Green Green Green Green Green

00:32:59,639 --> 00:33:07,490
happy so as you can see now it's

00:33:04,379 --> 00:33:10,220
slightly better but still as measure

00:33:07,490 --> 00:33:14,669
repetition is slightly battery here

00:33:10,220 --> 00:33:16,529
recall it's the same and the at measure

00:33:14,669 --> 00:33:19,409
that is just the average of the two is

00:33:16,529 --> 00:33:21,480
still the same so again you can do

00:33:19,409 --> 00:33:23,909
better because there are a certain

00:33:21,480 --> 00:33:26,149
number of trees that these things use so

00:33:23,909 --> 00:33:30,649
we can increase the number of three and

00:33:26,149 --> 00:33:33,960
the model will become more specific so

00:33:30,649 --> 00:33:39,259
it's bigger now so it will take up some

00:33:33,960 --> 00:33:39,259
time to load yeah so if i refresh now

00:33:39,470 --> 00:33:42,629
yeah

00:33:40,710 --> 00:33:45,240
so here again like now I guess at

00:33:42,629 --> 00:33:49,080
measure 46 so improved improved

00:33:45,240 --> 00:33:54,299
precision of 10 by 6 percent which is

00:33:49,080 --> 00:33:56,240
good so sorry 7% and I'm happy so in

00:33:54,299 --> 00:34:00,539
real life if you see precision at one

00:33:56,240 --> 00:34:02,340
it's a precision at one equal to one it

00:34:00,539 --> 00:34:04,350
means that you have a problem because

00:34:02,340 --> 00:34:06,450
this is something that should never

00:34:04,350 --> 00:34:09,659
happen it means that you are God and you

00:34:06,450 --> 00:34:11,220
predict everything and in learning rank

00:34:09,659 --> 00:34:13,139
it means that you are always fitting the

00:34:11,220 --> 00:34:15,839
model that's what I am doing here

00:34:13,139 --> 00:34:17,200
basically basically it's learning for

00:34:15,839 --> 00:34:20,799
each query what to return

00:34:17,200 --> 00:34:22,299
and this will means that it's gonna work

00:34:20,799 --> 00:34:24,129
really well on your training set but

00:34:22,299 --> 00:34:26,139
then when real users start to ask

00:34:24,129 --> 00:34:29,169
different things you're probably retinol

00:34:26,139 --> 00:34:30,700
and crazy things so what you do in real

00:34:29,169 --> 00:34:33,450
life is that you don't have a small

00:34:30,700 --> 00:34:36,579
training set but you have different

00:34:33,450 --> 00:34:38,079
query set and you train on one and then

00:34:36,579 --> 00:34:40,119
you evaluate on a different one with

00:34:38,079 --> 00:34:40,899
different queries so you're sure that if

00:34:40,119 --> 00:34:42,399
you have a new query

00:34:40,899 --> 00:34:46,950
you're still going good and I have an

00:34:42,399 --> 00:34:49,450
example here so I have the query Rome

00:34:46,950 --> 00:34:52,389
pre Rome is not in the training set so I

00:34:49,450 --> 00:34:56,200
didn't train on this query and if I

00:34:52,389 --> 00:34:58,869
perform the query wrong here I will get

00:34:56,200 --> 00:35:00,700
the first result piece of state in in

00:34:58,869 --> 00:35:02,980
u.s. that is not really what I would

00:35:00,700 --> 00:35:07,500
expect if I search for Rome

00:35:02,980 --> 00:35:10,630
if I use a model that is NSG at 10:00

00:35:07,500 --> 00:35:13,599
using 1003 I get the first result is the

00:35:10,630 --> 00:35:15,640
city in Italy and then I also get like

00:35:13,599 --> 00:35:19,690
clothing in hands and thrown that still

00:35:15,640 --> 00:35:22,240
makes sense so it's actually better than

00:35:19,690 --> 00:35:25,569
the default also if I didn't train on to

00:35:22,240 --> 00:35:27,609
optimize this particular query so yes so

00:35:25,569 --> 00:35:30,819
that's all I hope you enjoyed the demo I

00:35:27,609 --> 00:35:33,569
didn't a very unhappy and now if you

00:35:30,819 --> 00:35:35,820
have questions we are ready to take down

00:35:33,569 --> 00:35:45,219
Thanks

00:35:35,820 --> 00:35:45,219
[Applause]

00:35:46,640 --> 00:35:50,609
hey thank you can you just talk a little

00:35:49,140 --> 00:35:52,740
bit about roadmap for learning to rank

00:35:50,609 --> 00:35:54,869
in terms of adding support for other

00:35:52,740 --> 00:36:01,200
models and new types of features like

00:35:54,869 --> 00:36:04,799
that say thanks again so there is this

00:36:01,200 --> 00:36:08,759
discussion like at the moment when we

00:36:04,799 --> 00:36:11,630
did when we designed the plugin we

00:36:08,759 --> 00:36:14,309
assert that a feature is a float and you

00:36:11,630 --> 00:36:16,859
cannot really have different types of

00:36:14,309 --> 00:36:20,940
feature and the reason for that is

00:36:16,859 --> 00:36:22,650
that's like also them like the file that

00:36:20,940 --> 00:36:24,720
you usually use to Train do the same

00:36:22,650 --> 00:36:28,470
assertion so a feature is always a float

00:36:24,720 --> 00:36:32,369
and models that I usually use after the

00:36:28,470 --> 00:36:36,259
same thing so I'm not sure it's like

00:36:32,369 --> 00:36:38,759
that if they need to to use different

00:36:36,259 --> 00:36:40,980
output of different types for a feature

00:36:38,759 --> 00:36:45,809
but I'm totally open to discuss this

00:36:40,980 --> 00:36:47,759
being and yes yes I have a ton more

00:36:45,809 --> 00:36:49,890
think so right now the features that you

00:36:47,759 --> 00:36:51,210
define it's kind of one-to-one with the

00:36:49,890 --> 00:36:54,210
features you define and the features you

00:36:51,210 --> 00:36:56,430
extract but in many instances maybe you

00:36:54,210 --> 00:36:58,470
want a single feature function to

00:36:56,430 --> 00:37:01,160
actually output multiple feature values

00:36:58,470 --> 00:37:03,749
in one go right now the plug-in itself

00:37:01,160 --> 00:37:05,849
doesn't easily support that it is

00:37:03,749 --> 00:37:07,769
one-to-one one feature in one feature

00:37:05,849 --> 00:37:09,869
out one thing we would definitely like

00:37:07,769 --> 00:37:11,339
to do because we use it as well is maybe

00:37:09,869 --> 00:37:14,369
we want to find you know ten features

00:37:11,339 --> 00:37:15,900
and then outputs 500 feature values that

00:37:14,369 --> 00:37:18,359
would really help in terms of you know

00:37:15,900 --> 00:37:20,220
us developers writing this stuff would

00:37:18,359 --> 00:37:22,980
also help in performance too so that's a

00:37:20,220 --> 00:37:24,869
big one too that we really want to do on

00:37:22,980 --> 00:37:27,480
top of that in many instances you want

00:37:24,869 --> 00:37:29,160
to Train chained together ranking models

00:37:27,480 --> 00:37:31,559
so you have solar that you know

00:37:29,160 --> 00:37:33,239
essentially ranks your first 10,000

00:37:31,559 --> 00:37:35,220
documents and then you use this to rear

00:37:33,239 --> 00:37:37,289
Inc maybe the top 1000 right now it's

00:37:35,220 --> 00:37:39,119
just a single second pass it would be

00:37:37,289 --> 00:37:40,980
nice if then you wanted to do a third

00:37:39,119 --> 00:37:43,619
pass or a fourth pass on top of the

00:37:40,980 --> 00:37:46,769
Arirang 1000 maybe you riri ranked top

00:37:43,619 --> 00:37:48,720
10 taking you know image quality or

00:37:46,769 --> 00:37:51,059
maybe figuring out the prices if that's

00:37:48,720 --> 00:37:52,230
low hitting your database you don't want

00:37:51,059 --> 00:37:53,460
to do that for all your documents so

00:37:52,230 --> 00:37:54,539
really chaining these together is

00:37:53,460 --> 00:37:55,530
another thing we would like to do as

00:37:54,539 --> 00:37:58,140
well

00:37:55,530 --> 00:38:00,570
yes does it to be a lot of work to do

00:37:58,140 --> 00:38:01,890
yeah for sure if you guys have ideas or

00:38:00,570 --> 00:38:05,570
you know you have a use case certainly

00:38:01,890 --> 00:38:13,890
please contribute back I'd be great yeah

00:38:05,570 --> 00:38:15,720
and lining the Machine can cover thank

00:38:13,890 --> 00:38:19,170
you actually I have two questions so

00:38:15,720 --> 00:38:20,340
first hope humbly we can answer

00:38:19,170 --> 00:38:22,500
questions to you afterwards we'll be

00:38:20,340 --> 00:38:25,020
around yeah Larry how much effort do you

00:38:22,500 --> 00:38:28,050
put in generating a gold standard that

00:38:25,020 --> 00:38:30,300
is if you go on your Wikipedia data you

00:38:28,050 --> 00:38:32,700
have your priests so do you really need

00:38:30,300 --> 00:38:35,280
the first 100 documents and to judge

00:38:32,700 --> 00:38:37,920
whether they are relevant do you look

00:38:35,280 --> 00:38:40,680
for other documents not on the first 100

00:38:37,920 --> 00:38:42,990
which might just be very relevant but

00:38:40,680 --> 00:38:45,810
only match because they contain similans

00:38:42,990 --> 00:38:47,760
of you free so how much everything is

00:38:45,810 --> 00:38:51,120
saying about really getting your

00:38:47,760 --> 00:38:53,100
training set it's like it's a big effort

00:38:51,120 --> 00:38:54,930
right the bigger your training set the

00:38:53,100 --> 00:38:56,940
better your model will be you use a

00:38:54,930 --> 00:38:58,380
combination of explicit data maybe you

00:38:56,940 --> 00:39:00,180
have your experts in house that judge

00:38:58,380 --> 00:39:02,310
things right maybe you also send stuff

00:39:00,180 --> 00:39:03,990
outside to the crowd maybe you have a

00:39:02,310 --> 00:39:05,640
bunch of popular documents maybe you

00:39:03,990 --> 00:39:07,370
send that out there too it's essentially

00:39:05,640 --> 00:39:09,840
you kind of really have to combine

00:39:07,370 --> 00:39:11,880
everything together to really get a good

00:39:09,840 --> 00:39:13,320
set of documents that are always on top

00:39:11,880 --> 00:39:15,120
documents that are always at the tail

00:39:13,320 --> 00:39:16,320
end something in the middle so that way

00:39:15,120 --> 00:39:17,970
your model can really pick out the

00:39:16,320 --> 00:39:19,020
things that are really good about a

00:39:17,970 --> 00:39:20,460
document and things that are really

00:39:19,020 --> 00:39:24,720
really bad and knows to push those down

00:39:20,460 --> 00:39:26,070
so really is it's an ongoing thing it's

00:39:24,720 --> 00:39:28,410
never like here's my training set and

00:39:26,070 --> 00:39:30,600
I'm done you always add to it every

00:39:28,410 --> 00:39:33,120
single time and really like if you find

00:39:30,600 --> 00:39:35,040
a query that's bad you should kind of

00:39:33,120 --> 00:39:37,080
curate that add it to your test set or

00:39:35,040 --> 00:39:39,240
training set so it's just always ongoing

00:39:37,080 --> 00:39:41,340
so it's a big effort and those I think

00:39:39,240 --> 00:39:43,710
how you do that depends really by the

00:39:41,340 --> 00:39:45,900
use case so based on which type of

00:39:43,710 --> 00:39:48,720
service you have which type of documents

00:39:45,900 --> 00:39:50,970
which type of users you you want to use

00:39:48,720 --> 00:39:53,370
different ways to create a training set

00:39:50,970 --> 00:39:57,630
you still need humans it's not all

00:39:53,370 --> 00:39:59,970
automatic now that's cool thank you very

00:39:57,630 --> 00:40:01,350
much we are really tight on schedule and

00:39:59,970 --> 00:40:02,790
as you know the rooms are quite far from

00:40:01,350 --> 00:40:05,780
each other so

00:40:02,790 --> 00:40:13,429
so thank you very much giggle Michael

00:40:05,780 --> 00:40:13,429

YouTube URL: https://www.youtube.com/watch?v=u8xLuxfMx98


