Title: Berlin Buzzwords 2017: John Hugg - The History and Future of the Blurring of Stream Processing
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	John Hugg talking about "The History and Future of the Blurring of Stream Processing & OLTP".

There has been so much noise surrounding advances in analytical systems lately that Online Transaction Processing (OLTP) problems may seem a bit overshadowed. Big data, streaming analytics, machine learning, and even deep learning have all changed the way businesses are run and problems are solved. Meanwhile, problems that require low latency, high write throughput and some consistency guarantees haven’t gone away.

Two of the biggest "new" ideas for operational workloads are:
1) Command Query Responsibility Segregation suggests splitting operations into parallel streams of queries and modifications.
2) System like Samza and Kafka Streams propose flipping the persistence mechanism around, using logs to store events and maintaining materializations on top of the logs. This idea is best introduced here.

While these approaches blur the line between stream processing and traditional operational databases, the fuzziness is coming to even the most stodgy systems. We now speak of "events" more than "transactions", even if the transaction hasn’t gone away. Systems are becoming more parallel and more and more asynchronous.

This talk will do something a little weird: compare streaming systems like Kafka, Flink, DataFlow, and Kinesis with traditional databases, like Postgres and Oracle, or newfangled databases like Cloud Spanner, HBase, MySQL Galera Cluster, or VoltDB. It’s going to be fun.

Read more:
https://2017.berlinbuzzwords.de/17/session/history-and-future-blurring-stream-processing-oltp

About John Hugg:
https://2017.berlinbuzzwords.de/users/john-hugg

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,540 --> 00:00:14,080
thanks everybody so I'm John hug and I'm

00:00:11,290 --> 00:00:16,480
from bowl TV I'm going to try and

00:00:14,080 --> 00:00:17,500
squeeze a lot of content into 20 minutes

00:00:16,480 --> 00:00:19,570
here so there's a lot of things I'm

00:00:17,500 --> 00:00:20,980
going to kind of gloss over but if you

00:00:19,570 --> 00:00:22,630
want to reach out to me later I'm here

00:00:20,980 --> 00:00:24,610
at the conference for us the conference

00:00:22,630 --> 00:00:26,950
you can email me reach me offline

00:00:24,610 --> 00:00:28,779
I love to go down rat holes and talk in

00:00:26,950 --> 00:00:29,860
depth about some of the stuff I love it

00:00:28,779 --> 00:00:32,980
when people tell me I'm wrong because

00:00:29,860 --> 00:00:34,470
that's how I learned so I'm going to

00:00:32,980 --> 00:00:36,460
start off with an example

00:00:34,470 --> 00:00:39,820
operational app and this is my

00:00:36,460 --> 00:00:41,470
Beetlejuice app the minimum viable

00:00:39,820 --> 00:00:44,290
product for the Beetlejuice app is I've

00:00:41,470 --> 00:00:45,760
got some Alexa serious device in my

00:00:44,290 --> 00:00:47,620
house it's a microphone that's always

00:00:45,760 --> 00:00:50,220
listening to me because it's not creepy

00:00:47,620 --> 00:00:52,690
it sends discernable words to my servers

00:00:50,220 --> 00:00:55,150
and if it hears the word Beetlejuice

00:00:52,690 --> 00:00:57,490
three times it plays sound clips for the

00:00:55,150 --> 00:00:58,990
movie that's sort of the idea of the

00:00:57,490 --> 00:01:00,850
movie is you call Beetlejuice by saying

00:00:58,990 --> 00:01:03,400
its name three times pretty classic

00:01:00,850 --> 00:01:04,750
horror movie trope so we're going to

00:01:03,400 --> 00:01:06,759
build that as an app and this is an

00:01:04,750 --> 00:01:09,070
operational app and we're talking about

00:01:06,759 --> 00:01:11,770
stream processing oil PTP in the context

00:01:09,070 --> 00:01:13,810
of these operational apps it's a little

00:01:11,770 --> 00:01:15,490
bit different than like a word count or

00:01:13,810 --> 00:01:17,649
something like that because there's

00:01:15,490 --> 00:01:19,420
there's an action I need to do something

00:01:17,649 --> 00:01:21,369
I need to do something in response I

00:01:19,420 --> 00:01:22,929
need to send a message back and play a

00:01:21,369 --> 00:01:24,399
sound clip and that's immediate so that

00:01:22,929 --> 00:01:26,049
separates out some stream processing

00:01:24,399 --> 00:01:29,439
apps that may not look like a low TV

00:01:26,049 --> 00:01:31,659
apps so the first thing everyone should

00:01:29,439 --> 00:01:33,369
do is just use Postgres right this is

00:01:31,659 --> 00:01:36,520
advice that people started giving in

00:01:33,369 --> 00:01:37,659
response to all of the no sequels stream

00:01:36,520 --> 00:01:39,549
processing there's a hundred different

00:01:37,659 --> 00:01:41,319
data processing frameworks and this is

00:01:39,549 --> 00:01:43,749
often a really good idea if you don't

00:01:41,319 --> 00:01:45,219
know where to start just use Postgres or

00:01:43,749 --> 00:01:46,929
my sequel or some other technology

00:01:45,219 --> 00:01:48,429
that's been beat on for twenty years and

00:01:46,929 --> 00:01:49,899
there's an incredible wealth of

00:01:48,429 --> 00:01:52,359
knowledge and tooling around it is not a

00:01:49,899 --> 00:01:54,670
bad idea so but how does this look so

00:01:52,359 --> 00:01:56,350
I've got some dumbest client they do one

00:01:54,670 --> 00:02:00,490
of these microphones in my bathroom and

00:01:56,350 --> 00:02:02,049
I send audio to some rich client logic

00:02:00,490 --> 00:02:03,520
in my data center there's a little bit

00:02:02,049 --> 00:02:05,829
of contrast lost here there's a box

00:02:03,520 --> 00:02:07,299
around this but and the rich client

00:02:05,829 --> 00:02:09,429
logic is going to do some speech-to-text

00:02:07,299 --> 00:02:11,080
any time it sees the word beetlejuice

00:02:09,429 --> 00:02:12,819
it's going to add a record into Postgres

00:02:11,080 --> 00:02:15,430
it's going to count how many times have

00:02:12,819 --> 00:02:16,750
I said Beetlejuice maybe it's three it's

00:02:15,430 --> 00:02:17,050
going to record that it's going to take

00:02:16,750 --> 00:02:18,940
an

00:02:17,050 --> 00:02:20,110
action reset the count and then it's

00:02:18,940 --> 00:02:22,950
going to send a message back to my

00:02:20,110 --> 00:02:27,130
speaker to play some clip from the movie

00:02:22,950 --> 00:02:28,540
so there's a presumably some table that

00:02:27,130 --> 00:02:29,530
you guys can all imagine this is what it

00:02:28,540 --> 00:02:31,870
looks like it's a fairly straightforward

00:02:29,530 --> 00:02:34,330
very traditional way of solving this

00:02:31,870 --> 00:02:36,460
problem if I'm looking at it from a

00:02:34,330 --> 00:02:37,780
streaming perspective let's just say

00:02:36,460 --> 00:02:41,440
what if I wanted to build this app with

00:02:37,780 --> 00:02:44,110
storm now you shouldn't use storm for

00:02:41,440 --> 00:02:46,330
new apps this is my opinion it's really

00:02:44,110 --> 00:02:48,700
there's so many better options than

00:02:46,330 --> 00:02:50,320
storm I'm picking storm because there's

00:02:48,700 --> 00:02:52,000
nothing really tricky to it it's kind of

00:02:50,320 --> 00:02:54,790
exemplars a stream processing framework

00:02:52,000 --> 00:02:57,640
you could insert many different kinds of

00:02:54,790 --> 00:02:58,900
things for storm in this example and you

00:02:57,640 --> 00:03:00,490
probably should again I'm losing

00:02:58,900 --> 00:03:04,680
contrast on the projector but that's a

00:03:00,490 --> 00:03:07,450
nice spark logo over there so so storm

00:03:04,680 --> 00:03:08,590
looks a lot like the Postgres app except

00:03:07,450 --> 00:03:10,330
some of the nice things I don't have

00:03:08,590 --> 00:03:11,830
that rich you that rich user code

00:03:10,330 --> 00:03:14,500
running somewhere else in my data center

00:03:11,830 --> 00:03:18,130
I can move that code into the processing

00:03:14,500 --> 00:03:19,480
framework but what I what I have also is

00:03:18,130 --> 00:03:22,209
I probably got a bunch of different

00:03:19,480 --> 00:03:25,180
storms running together but really I've

00:03:22,209 --> 00:03:26,890
got audio sent here storm might emit to

00:03:25,180 --> 00:03:29,020
play a sound once in a while if it says

00:03:26,890 --> 00:03:30,489
I've got three and I've got counts for

00:03:29,020 --> 00:03:34,450
my users maybe they're partitioned

00:03:30,489 --> 00:03:35,590
across all the storm nodes so the big

00:03:34,450 --> 00:03:38,170
difference when you're looking at

00:03:35,590 --> 00:03:41,340
architectures when things are hunky-dory

00:03:38,170 --> 00:03:43,239
when everything is working well then

00:03:41,340 --> 00:03:44,920
really there are a lot of different

00:03:43,239 --> 00:03:46,570
architectures that could work a lot of

00:03:44,920 --> 00:03:48,580
different fun things you could try but

00:03:46,570 --> 00:03:50,739
building for when the unexpected happens

00:03:48,580 --> 00:03:52,750
is where maybe the different choices you

00:03:50,739 --> 00:03:53,820
make can really be either inexpensive or

00:03:52,750 --> 00:03:56,650
expensive

00:03:53,820 --> 00:03:58,390
so when Postgres what are the different

00:03:56,650 --> 00:04:00,670
ways this app can fail certainly

00:03:58,390 --> 00:04:02,739
Postgres can go down and that's that's

00:04:00,670 --> 00:04:04,750
either software or hardware my app is

00:04:02,739 --> 00:04:06,250
going to become unavailable but I could

00:04:04,750 --> 00:04:08,230
also have problems like I could lose a

00:04:06,250 --> 00:04:09,640
network message right it's a really

00:04:08,230 --> 00:04:11,410
common problem that happens that people

00:04:09,640 --> 00:04:13,239
don't necessarily account for where

00:04:11,410 --> 00:04:15,010
maybe I said Beetlejuice three times and

00:04:13,239 --> 00:04:17,230
it sent a message back to play us down

00:04:15,010 --> 00:04:18,190
but that message got lost and it resets

00:04:17,230 --> 00:04:21,000
account and now I have to say

00:04:18,190 --> 00:04:22,990
Beetlejuice 6 times and that's awful

00:04:21,000 --> 00:04:25,690
that's another way that this kind of

00:04:22,990 --> 00:04:27,000
thing can fail in storm it's not really

00:04:25,690 --> 00:04:29,800
that different

00:04:27,000 --> 00:04:30,700
certainly a storm note can fail and I'm

00:04:29,800 --> 00:04:32,890
going to lose

00:04:30,700 --> 00:04:34,240
I'm going to lose maybe some Beetlejuice

00:04:32,890 --> 00:04:36,280
counts humming there I might have to say

00:04:34,240 --> 00:04:37,810
Beetlejuice 6 times I could lose the

00:04:36,280 --> 00:04:39,520
message that goes back to the the

00:04:37,810 --> 00:04:42,130
microphone on the speaker I could have

00:04:39,520 --> 00:04:43,780
to say Beetlejuice 6 times the benefit

00:04:42,130 --> 00:04:45,370
of storm and some of these things that

00:04:43,780 --> 00:04:47,140
are distributed this is goes for

00:04:45,370 --> 00:04:49,000
streaming or databases is that I can

00:04:47,140 --> 00:04:51,430
probably fail over to another storm note

00:04:49,000 --> 00:04:52,930
so the general availability my app

00:04:51,430 --> 00:04:56,590
doesn't go down just because a node

00:04:52,930 --> 00:04:57,640
failed some other things that are

00:04:56,590 --> 00:04:58,870
important to think about that I'm going

00:04:57,640 --> 00:05:01,120
to kind of gloss over because I don't

00:04:58,870 --> 00:05:03,460
have 40 minutes to do this is I can use

00:05:01,120 --> 00:05:04,810
item Potence with at least ones delivery

00:05:03,460 --> 00:05:06,310
that is I can have my clients send the

00:05:04,810 --> 00:05:08,710
thing over and over until it's confirmed

00:05:06,310 --> 00:05:10,510
to get exactly once processing that

00:05:08,710 --> 00:05:13,810
helps me get that exactly I want to

00:05:10,510 --> 00:05:14,890
count Beetlejuice three times and then

00:05:13,810 --> 00:05:16,420
other things you can think it's side

00:05:14,890 --> 00:05:19,000
effects ruin everything what's a side

00:05:16,420 --> 00:05:21,160
effect so playing the sound on a speaker

00:05:19,000 --> 00:05:23,140
is not a transaction it's not something

00:05:21,160 --> 00:05:25,090
I have control over if the speaker wire

00:05:23,140 --> 00:05:26,470
is cut and I tell it to play a sound and

00:05:25,090 --> 00:05:28,170
it thinks to play a sound but it didn't

00:05:26,470 --> 00:05:30,700
that's not anything I have control over

00:05:28,170 --> 00:05:32,680
so I consider that a side effect and

00:05:30,700 --> 00:05:34,870
good examples these are when you send an

00:05:32,680 --> 00:05:38,110
SMS message or you make a RESTful API

00:05:34,870 --> 00:05:39,940
call if those things fail it's very hard

00:05:38,110 --> 00:05:42,130
you basically have to pick I want to

00:05:39,940 --> 00:05:44,140
guarantee someone sees this maybe

00:05:42,130 --> 00:05:45,340
they'll see it more than once or I want

00:05:44,140 --> 00:05:47,380
to make sure that not someone no one

00:05:45,340 --> 00:05:49,150
ever sees this twice which means maybe

00:05:47,380 --> 00:05:50,530
they won't see it but with side effects

00:05:49,150 --> 00:05:54,220
I don't have control I can just sort of

00:05:50,530 --> 00:05:56,080
build it as robustly as I can so can I

00:05:54,220 --> 00:05:59,110
just sprinkle some Kafka on this and

00:05:56,080 --> 00:06:01,420
make these problems go away

00:05:59,110 --> 00:06:02,860
so in the Postgres example and it looks

00:06:01,420 --> 00:06:05,350
similar for the storm example and this

00:06:02,860 --> 00:06:07,660
is you know more and more common I can

00:06:05,350 --> 00:06:09,760
put Kafka here in terms of how this

00:06:07,660 --> 00:06:11,350
helps failure it does get me some some

00:06:09,760 --> 00:06:13,990
better back pressure it gets me a little

00:06:11,350 --> 00:06:16,420
bit some some robustness for failure in

00:06:13,990 --> 00:06:17,920
some ways but it doesn't fundamentally

00:06:16,420 --> 00:06:19,270
change things it doesn't fundamentally

00:06:17,920 --> 00:06:20,380
change how I handle side effect it

00:06:19,270 --> 00:06:22,480
doesn't fundamentally change what

00:06:20,380 --> 00:06:25,030
happens when Postgres goes down for an

00:06:22,480 --> 00:06:26,710
extended period of time the reasons I

00:06:25,030 --> 00:06:28,390
want to do this are largely not related

00:06:26,710 --> 00:06:29,590
to failure or things there's a lot of

00:06:28,390 --> 00:06:33,790
good reasons I've got a slide coming up

00:06:29,590 --> 00:06:35,410
on why you would do this but one of the

00:06:33,790 --> 00:06:36,970
things is if I look at this operational

00:06:35,410 --> 00:06:39,850
app again this is not some bulk

00:06:36,970 --> 00:06:42,070
analytics app streaming and databases

00:06:39,850 --> 00:06:44,260
have a lot in common right if I want to

00:06:42,070 --> 00:06:45,700
ensure delivery the original source

00:06:44,260 --> 00:06:47,590
has to be prepared to send it more than

00:06:45,700 --> 00:06:50,290
once whether I do streaming or databases

00:06:47,590 --> 00:06:51,760
that's true if I want to get exactly one

00:06:50,290 --> 00:06:54,610
semantics I have to build an idempotent

00:06:51,760 --> 00:06:56,590
operations it could be a little sub talk

00:06:54,610 --> 00:06:58,600
there but that that's true in both cases

00:06:56,590 --> 00:07:00,790
I can't guarantee that a side-effect

00:06:58,600 --> 00:07:03,220
happens exactly one so do your best and

00:07:00,790 --> 00:07:05,230
that systems that are flexible safe and

00:07:03,220 --> 00:07:07,600
accurate are really really hard to do

00:07:05,230 --> 00:07:09,550
doesn't matter what you put you what

00:07:07,600 --> 00:07:13,960
architecture you choose these things are

00:07:09,550 --> 00:07:15,460
hard that's why we get paid well so what

00:07:13,960 --> 00:07:16,960
makes a hard app obviously scale

00:07:15,460 --> 00:07:18,840
complexity these are things that

00:07:16,960 --> 00:07:21,130
everyone sort of jumps to immediately

00:07:18,840 --> 00:07:22,210
velocity requirements changes is

00:07:21,130 --> 00:07:23,530
something that you know if you've done

00:07:22,210 --> 00:07:26,200
product management that's something that

00:07:23,530 --> 00:07:27,640
can make an app hard some of the things

00:07:26,200 --> 00:07:29,890
that really matter for an operational

00:07:27,640 --> 00:07:31,870
app precision right if I want to do

00:07:29,890 --> 00:07:33,670
something exactly three times that's

00:07:31,870 --> 00:07:36,250
much much harder than about three times

00:07:33,670 --> 00:07:38,020
and how important exactly three times is

00:07:36,250 --> 00:07:39,310
to my app how much I'm willing to

00:07:38,020 --> 00:07:41,500
engineer to make sure that it's exactly

00:07:39,310 --> 00:07:44,410
three can make the app either not that

00:07:41,500 --> 00:07:46,270
hard or really hard chaining precise

00:07:44,410 --> 00:07:47,830
conditions in action so when something

00:07:46,270 --> 00:07:49,320
happens three times do something else

00:07:47,830 --> 00:07:52,390
that makes things hard and

00:07:49,320 --> 00:07:54,190
non-commutative math so if you have math

00:07:52,390 --> 00:07:56,020
like addition and things that's great

00:07:54,190 --> 00:07:57,430
aggregation some of those things but if

00:07:56,020 --> 00:07:59,470
you have math that doesn't commute where

00:07:57,430 --> 00:08:00,820
if the ops come in different orders you

00:07:59,470 --> 00:08:03,040
get a different result that can be

00:08:00,820 --> 00:08:04,690
tricky side effects as I mentioned and

00:08:03,040 --> 00:08:05,950
then partial control is a really common

00:08:04,690 --> 00:08:07,630
one I run into when I'm helping our

00:08:05,950 --> 00:08:09,070
customers where they don't control all

00:08:07,630 --> 00:08:10,600
of their app maybe there's two different

00:08:09,070 --> 00:08:13,120
groups that are working maybe it's an

00:08:10,600 --> 00:08:18,370
OEM and a cut and their customer but

00:08:13,120 --> 00:08:20,860
that makes absolute harder so why today

00:08:18,370 --> 00:08:24,660
in 2017 would you want to use one or the

00:08:20,860 --> 00:08:26,530
other for your operational app right

00:08:24,660 --> 00:08:28,000
streaming and logging and I've got a

00:08:26,530 --> 00:08:30,550
little cocktail logo up there because

00:08:28,000 --> 00:08:32,169
sort of defines the logging space in a

00:08:30,550 --> 00:08:34,410
lot of ways these days though there's

00:08:32,169 --> 00:08:36,550
more options than copy up Acosta's nice

00:08:34,410 --> 00:08:38,650
one of the my favorite things is you can

00:08:36,550 --> 00:08:40,000
easily tea that is you can split two

00:08:38,650 --> 00:08:42,160
identical streams into your production

00:08:40,000 --> 00:08:45,250
and your development production and your

00:08:42,160 --> 00:08:47,320
pre-production or even a/b testing data

00:08:45,250 --> 00:08:48,850
right you can you can take the stream

00:08:47,320 --> 00:08:51,010
and run it in a bunch of different ways

00:08:48,850 --> 00:08:53,860
and that makes developing the next

00:08:51,010 --> 00:08:56,350
version of your app a whole lot easier I

00:08:53,860 --> 00:08:58,460
often get really much simpler clients

00:08:56,350 --> 00:09:00,020
when I've got streaming and logging

00:08:58,460 --> 00:09:01,670
because I move more of that processing

00:09:00,020 --> 00:09:04,760
into the system itself I don't have a

00:09:01,670 --> 00:09:05,840
separate standalone client it's often

00:09:04,760 --> 00:09:07,550
easier to understand performance

00:09:05,840 --> 00:09:09,530
characteristics I've got more of a

00:09:07,550 --> 00:09:11,390
queuing 3or theory model than I do like

00:09:09,530 --> 00:09:14,810
a well what's the contention and

00:09:11,390 --> 00:09:16,610
shared-memory mess inside Postgres by

00:09:14,810 --> 00:09:18,080
replaying a log stream later I can do

00:09:16,610 --> 00:09:20,720
back testing like what did this have

00:09:18,080 --> 00:09:22,700
worked better in that situation oh no

00:09:20,720 --> 00:09:24,050
this is I've got some bad data here can

00:09:22,700 --> 00:09:26,570
I roll back to right before that

00:09:24,050 --> 00:09:28,220
happened that's really nice although you

00:09:26,570 --> 00:09:32,900
need truncating snapshots which is a

00:09:28,220 --> 00:09:34,520
whole nother rathole you can sometimes

00:09:32,900 --> 00:09:36,500
make multi data center stuff easier

00:09:34,520 --> 00:09:38,570
sometimes replicating a log is easier

00:09:36,500 --> 00:09:41,840
than replicating mutating State in like

00:09:38,570 --> 00:09:43,490
a Postgres or my sequel horizontal

00:09:41,840 --> 00:09:44,840
scalability and fault-tolerance can be

00:09:43,490 --> 00:09:46,760
easier although there are a lot of

00:09:44,840 --> 00:09:50,470
databases now that also do that kind of

00:09:46,760 --> 00:09:53,990
stuff so why would you use a database

00:09:50,470 --> 00:09:55,340
and these are also definitely subsets

00:09:53,990 --> 00:09:56,750
right there's a lot of reasons these are

00:09:55,340 --> 00:09:59,960
just some of the ones that came to my

00:09:56,750 --> 00:10:01,340
mind when you're using a stream you have

00:09:59,960 --> 00:10:03,170
to figure out some way to truncate the

00:10:01,340 --> 00:10:03,740
stream or you have to keep the stream

00:10:03,170 --> 00:10:05,480
forever

00:10:03,740 --> 00:10:07,550
right so a lot of times that's like a

00:10:05,480 --> 00:10:09,320
per app kind of snapshot and that's one

00:10:07,550 --> 00:10:12,560
of the complexities that trips up a lot

00:10:09,320 --> 00:10:13,700
of people databases you can query off

00:10:12,560 --> 00:10:15,050
the bat right if you've got your

00:10:13,700 --> 00:10:17,240
operational app you can build in

00:10:15,050 --> 00:10:18,500
periodic reporting period of queries you

00:10:17,240 --> 00:10:20,690
have to be careful if that doesn't

00:10:18,500 --> 00:10:21,320
impact your operational workloads but if

00:10:20,690 --> 00:10:22,880
it's something that you're doing

00:10:21,320 --> 00:10:24,740
routinely you can build that into your

00:10:22,880 --> 00:10:27,560
capacity planning and you can do a lot

00:10:24,740 --> 00:10:29,150
of really cool stuff that that is hard

00:10:27,560 --> 00:10:30,350
to do with streaming especially in

00:10:29,150 --> 00:10:32,690
development when you can just write

00:10:30,350 --> 00:10:35,240
sequel queries or whatever the database

00:10:32,690 --> 00:10:36,650
uses to understand what's going on and

00:10:35,240 --> 00:10:38,210
then you've got this great database

00:10:36,650 --> 00:10:40,040
stuff that we've built up over the years

00:10:38,210 --> 00:10:42,860
like secondary indexes materialized

00:10:40,040 --> 00:10:44,030
views constraints joins foreign keys and

00:10:42,860 --> 00:10:46,070
depending on the system some of them

00:10:44,030 --> 00:10:47,510
have more or less of that stuff but you

00:10:46,070 --> 00:10:50,570
get a lot of really mature tooling

00:10:47,510 --> 00:10:51,950
around databases and one of the nice

00:10:50,570 --> 00:10:53,300
things about them is that you typically

00:10:51,950 --> 00:10:55,580
they're more appropriate for apps that

00:10:53,300 --> 00:10:57,350
require lower latency because a lot more

00:10:55,580 --> 00:11:00,170
of these used like an RPC model where I

00:10:57,350 --> 00:11:02,660
make a call and then get a response more

00:11:00,170 --> 00:11:04,190
directly if I have things where I need

00:11:02,660 --> 00:11:06,800
to make decisions in milliseconds these

00:11:04,190 --> 00:11:08,330
are often a better fit caveats to

00:11:06,800 --> 00:11:10,980
everything but those are sort of my

00:11:08,330 --> 00:11:13,770
summary slides on those

00:11:10,980 --> 00:11:16,320
so why can't I just use a streaming

00:11:13,770 --> 00:11:18,750
system and a DB together and you can and

00:11:16,320 --> 00:11:20,400
lots of people do depending on your app

00:11:18,750 --> 00:11:21,900
your problem what you're trying to do a

00:11:20,400 --> 00:11:23,190
lot of people have a lot of success with

00:11:21,900 --> 00:11:26,100
this

00:11:23,190 --> 00:11:28,830
there is the big catch with this is that

00:11:26,100 --> 00:11:31,200
more integration points means there's

00:11:28,830 --> 00:11:33,420
more ways that things can fail and the

00:11:31,200 --> 00:11:36,300
integration point between say storm and

00:11:33,420 --> 00:11:38,670
Cassandra or storm and Redis is one of

00:11:36,300 --> 00:11:40,680
the more tricky things to get right than

00:11:38,670 --> 00:11:43,310
a lot of other systems and same thing if

00:11:40,680 --> 00:11:47,040
you're going to use you know storm and

00:11:43,310 --> 00:11:49,410
Postgres or Kostka clients and Postgres

00:11:47,040 --> 00:11:51,870
or whatever you're going to use that

00:11:49,410 --> 00:11:54,210
integration point is tricky but you

00:11:51,870 --> 00:11:55,860
should want this right like you should

00:11:54,210 --> 00:11:57,270
want the benefits of both all the things

00:11:55,860 --> 00:11:59,880
I put on those little slide on those

00:11:57,270 --> 00:12:01,470
last two slides I want all of that in my

00:11:59,880 --> 00:12:04,170
operational apps I don't want to have to

00:12:01,470 --> 00:12:09,779
choose so we get in a little bit of the

00:12:04,170 --> 00:12:11,670
blurring parts here ad database notes to

00:12:09,779 --> 00:12:13,620
streaming systems all right this is one

00:12:11,670 --> 00:12:15,000
way we can do sort of the blurring so if

00:12:13,620 --> 00:12:16,620
I've got this storm app this sort of

00:12:15,000 --> 00:12:18,959
glue code as I mentioned between the

00:12:16,620 --> 00:12:20,760
state and the user code storm totally

00:12:18,959 --> 00:12:23,070
punts on this a lot of other streaming

00:12:20,760 --> 00:12:25,260
systems have much better support for how

00:12:23,070 --> 00:12:27,150
you manage this kind of state but few of

00:12:25,260 --> 00:12:28,860
them are really databases right they

00:12:27,150 --> 00:12:30,209
don't have all the features I had on the

00:12:28,860 --> 00:12:33,089
other slide they have things like

00:12:30,209 --> 00:12:35,730
aggregation support and they're really

00:12:33,089 --> 00:12:37,290
good counters I'm doing them a

00:12:35,730 --> 00:12:39,029
disservice by saying that but they're

00:12:37,290 --> 00:12:41,400
not they're not Postgres they're not

00:12:39,029 --> 00:12:43,470
amateur sequel relational database or

00:12:41,400 --> 00:12:46,020
even amateur and a different data model

00:12:43,470 --> 00:12:48,060
database so one of the interesting

00:12:46,020 --> 00:12:49,740
products that's out now that's sort of a

00:12:48,060 --> 00:12:51,810
new product last year or so is this

00:12:49,740 --> 00:12:52,980
Kafka streams thing from the confluent

00:12:51,810 --> 00:12:54,060
people and there's a bunch of confluent

00:12:52,980 --> 00:12:55,860
people here so you can ask them

00:12:54,060 --> 00:12:57,990
questions I'm sure they know more about

00:12:55,860 --> 00:12:59,880
this than I do but you can take your

00:12:57,990 --> 00:13:02,580
client logic into a Kafka log and the

00:12:59,880 --> 00:13:05,640
Kafka streams library it's a library you

00:13:02,580 --> 00:13:09,720
put your client that manages how this

00:13:05,640 --> 00:13:12,810
log gets turned into tabular database II

00:13:09,720 --> 00:13:15,779
kind of data according to your user code

00:13:12,810 --> 00:13:18,209
and so it basically makes that glue code

00:13:15,779 --> 00:13:21,120
between data and streaming much much

00:13:18,209 --> 00:13:23,250
much much less fragile and then you can

00:13:21,120 --> 00:13:25,080
emit into a Kafka log or two

00:13:23,250 --> 00:13:28,290
Kafka logs into downstreams consumers

00:13:25,080 --> 00:13:30,570
and it's really I think taking streaming

00:13:28,290 --> 00:13:32,490
systems and moving them into how we add

00:13:30,570 --> 00:13:34,920
data business to that in a safer way

00:13:32,490 --> 00:13:36,360
it's really early days for this product

00:13:34,920 --> 00:13:38,490
there's a lot of things it doesn't do

00:13:36,360 --> 00:13:40,260
yet there's a lot of other systems like

00:13:38,490 --> 00:13:41,430
I said that have ways of integrating

00:13:40,260 --> 00:13:42,660
state with streams maybe I don't think

00:13:41,430 --> 00:13:45,150
any of them are as ambitious as this

00:13:42,660 --> 00:13:49,020
project but you know come talk to me

00:13:45,150 --> 00:13:50,520
tell me I'm wrong so this is sort of

00:13:49,020 --> 00:13:52,770
what I'm interested in make a database

00:13:50,520 --> 00:13:54,570
that's a lot more streaming how do we

00:13:52,770 --> 00:13:57,060
get the benefits of the database if we

00:13:54,570 --> 00:14:00,210
have a benefits of stream processing

00:13:57,060 --> 00:14:01,020
when we're building a database so one of

00:14:00,210 --> 00:14:03,480
the things we can do is we can put

00:14:01,020 --> 00:14:05,760
processing in the database I've got a

00:14:03,480 --> 00:14:08,100
rich client logic and a lot of RPC calls

00:14:05,760 --> 00:14:10,080
if I put my user logic in stored

00:14:08,100 --> 00:14:11,940
procedures then I've got a lot fewer our

00:14:10,080 --> 00:14:14,730
PC calls I've got some per client logic

00:14:11,940 --> 00:14:16,350
all right everyone says yeah but stored

00:14:14,730 --> 00:14:17,430
procedures are miserable and that is

00:14:16,350 --> 00:14:19,200
well deserved

00:14:17,430 --> 00:14:21,780
so some of the things we can do to make

00:14:19,200 --> 00:14:23,310
this better beyond sort of Postgres or

00:14:21,780 --> 00:14:25,020
Oracle or whatever store procedures

00:14:23,310 --> 00:14:27,120
you've been forced to suffer through we

00:14:25,020 --> 00:14:29,280
need better tools for managing user code

00:14:27,120 --> 00:14:31,260
in the database we need better tools for

00:14:29,280 --> 00:14:33,630
debugging user code in the database

00:14:31,260 --> 00:14:36,150
right when printf is even doesn't even

00:14:33,630 --> 00:14:38,040
work that well we need better monitoring

00:14:36,150 --> 00:14:39,450
and transparency for user code running

00:14:38,040 --> 00:14:41,660
in the database what is my code doing

00:14:39,450 --> 00:14:43,980
how long does it take and I sample it

00:14:41,660 --> 00:14:45,270
these are the kinds of things that that

00:14:43,980 --> 00:14:46,920
we can get a little bit of in stream

00:14:45,270 --> 00:14:48,420
processing some systems are better than

00:14:46,920 --> 00:14:50,700
others we can put this in a database

00:14:48,420 --> 00:14:52,350
it's just a technical challenge it's not

00:14:50,700 --> 00:14:55,380
because there's some fundamental reason

00:14:52,350 --> 00:14:56,790
we can't the other thing we can do is

00:14:55,380 --> 00:14:58,020
you got Postgres and they've got to

00:14:56,790 --> 00:14:59,940
write a head log and this has been

00:14:58,020 --> 00:15:03,839
standard in the industry for a bazillion

00:14:59,940 --> 00:15:06,270
years right I can take that right ahead

00:15:03,839 --> 00:15:09,060
log put it in front and I can create an

00:15:06,270 --> 00:15:10,589
opera or a logical log which looks a

00:15:09,060 --> 00:15:12,360
little bit like sticking Kafka in front

00:15:10,589 --> 00:15:14,250
of Postgres and in fact I could build

00:15:12,360 --> 00:15:16,200
this with Kafka and Postgres and glue

00:15:14,250 --> 00:15:17,670
code but there's no reason I can't

00:15:16,200 --> 00:15:21,210
integrate this into my database I can

00:15:17,670 --> 00:15:24,210
make this a part of my perfect database

00:15:21,210 --> 00:15:27,089
right and so this lets me do a lot of

00:15:24,210 --> 00:15:29,490
the things like teeing going to a point

00:15:27,089 --> 00:15:31,950
in time there's replicating between data

00:15:29,490 --> 00:15:33,480
centers using a logical a priori log

00:15:31,950 --> 00:15:35,520
there's a lot of benefits there's some

00:15:33,480 --> 00:15:37,740
trade-offs and downsides and if you want

00:15:35,520 --> 00:15:40,350
to know about those come talk to me

00:15:37,740 --> 00:15:42,240
the the post yari log which I probably

00:15:40,350 --> 00:15:42,900
can't pronounce it's sort of the same

00:15:42,240 --> 00:15:44,460
idea

00:15:42,900 --> 00:15:46,680
I want my database to be able to admit

00:15:44,460 --> 00:15:47,850
events I don't want to have to query my

00:15:46,680 --> 00:15:49,980
database and say hey does anything

00:15:47,850 --> 00:15:51,780
change I want in my stored procedure

00:15:49,980 --> 00:15:53,220
logic to be able to say hey this event

00:15:51,780 --> 00:15:56,540
happened you said Beetlejuice three

00:15:53,220 --> 00:15:59,520
times push an event out into my log and

00:15:56,540 --> 00:16:00,930
if I've got this a posterior log a

00:15:59,520 --> 00:16:03,030
downstream consumer one of the things I

00:16:00,930 --> 00:16:05,450
can do is if I don't want to I can

00:16:03,030 --> 00:16:08,190
de-emphasize sort of the RPC responses

00:16:05,450 --> 00:16:10,380
and I can actually consume the event

00:16:08,190 --> 00:16:12,330
from the client logic so I can use this

00:16:10,380 --> 00:16:13,980
in a more streaming kind of way where

00:16:12,330 --> 00:16:15,960
I've got the priority log and the

00:16:13,980 --> 00:16:19,550
posterior log everything moving through

00:16:15,960 --> 00:16:21,870
but I've got a database in the middle

00:16:19,550 --> 00:16:23,970
obviously I can horizontally partition

00:16:21,870 --> 00:16:25,230
the database a lot of databases do this

00:16:23,970 --> 00:16:27,120
now I'm not going to go in a lot of

00:16:25,230 --> 00:16:30,480
depth about this but you sort of pick a

00:16:27,120 --> 00:16:32,460
partition key but when you do this you

00:16:30,480 --> 00:16:34,680
want to throw out the the bathwater and

00:16:32,460 --> 00:16:36,660
keep the baby right so I've got now a

00:16:34,680 --> 00:16:38,370
whole bunch of databases but I need to

00:16:36,660 --> 00:16:40,650
present as a single managed entity I

00:16:38,370 --> 00:16:43,230
want global stats I want global reads

00:16:40,650 --> 00:16:44,940
without extra work I want it to be a

00:16:43,230 --> 00:16:47,820
database even though it's got all this

00:16:44,940 --> 00:16:48,930
other stuff in it and and this is

00:16:47,820 --> 00:16:51,900
something that I've learned a lot

00:16:48,930 --> 00:16:55,290
working at both TB excuse me working at

00:16:51,900 --> 00:16:57,390
vole TV is I want RPC why do I want that

00:16:55,290 --> 00:16:58,350
this RPC model where a client can call

00:16:57,390 --> 00:17:00,180
the database and get an immediate

00:16:58,350 --> 00:17:02,280
response because we work with a lot of

00:17:00,180 --> 00:17:05,010
apps where latency matters and that

00:17:02,280 --> 00:17:07,050
ability to to respond directly from the

00:17:05,010 --> 00:17:09,240
stored procedure says accept this call

00:17:07,050 --> 00:17:10,800
this transaction is fraudulent here's

00:17:09,240 --> 00:17:12,630
what to show the user on the next page

00:17:10,800 --> 00:17:16,200
allows us to build these real-time

00:17:12,630 --> 00:17:18,950
operational apps that are really cool ah

00:17:16,200 --> 00:17:20,940
so where is this going

00:17:18,950 --> 00:17:22,980
I'll say here this is sort of where I

00:17:20,940 --> 00:17:25,230
plug what I'm doing we're building a lot

00:17:22,980 --> 00:17:27,030
of this at full TV this is a lot of the

00:17:25,230 --> 00:17:28,650
ideas that sort of things that we are

00:17:27,030 --> 00:17:30,750
inspired by that we want to make a

00:17:28,650 --> 00:17:33,030
better product so we've got a

00:17:30,750 --> 00:17:34,020
horizontally partition database that

00:17:33,030 --> 00:17:36,750
acts as a single system

00:17:34,020 --> 00:17:39,060
we've got per partitioned ordered input

00:17:36,750 --> 00:17:41,280
and output right all based on an opera

00:17:39,060 --> 00:17:43,230
or a logical log just like we showed in

00:17:41,280 --> 00:17:46,800
the last couple slides we have

00:17:43,230 --> 00:17:48,630
debuggable Java stored procedures you

00:17:46,800 --> 00:17:50,550
could fire up IntelliJ or Eclipse and

00:17:48,630 --> 00:17:50,920
step through your code we've got all

00:17:50,550 --> 00:17:52,540
kinds

00:17:50,920 --> 00:17:55,060
stats about how long things are taking

00:17:52,540 --> 00:17:56,650
you can use third-party libraries we

00:17:55,060 --> 00:17:58,090
have the ability to emit events from

00:17:56,650 --> 00:18:00,880
those stored procedures that get put

00:17:58,090 --> 00:18:02,680
into a a posteriori log so then you can

00:18:00,880 --> 00:18:05,110
consume them from some downstream system

00:18:02,680 --> 00:18:06,640
and we've got all the database stuff I

00:18:05,110 --> 00:18:08,260
won't say all we don't do as much as

00:18:06,640 --> 00:18:09,730
Postgres but we've got a lot of the

00:18:08,260 --> 00:18:12,180
database stuff that people wants like

00:18:09,730 --> 00:18:15,430
secondary indexes ranking indexes views

00:18:12,180 --> 00:18:16,990
when doing functions transactions all

00:18:15,430 --> 00:18:20,910
that kind of stuff that you want out of

00:18:16,990 --> 00:18:22,990
a database but my conclusion here is

00:18:20,910 --> 00:18:24,340
I'll say we're working a lot of this

00:18:22,990 --> 00:18:25,600
stuff at volts I know

00:18:24,340 --> 00:18:26,800
confluence working on this there's ten

00:18:25,600 --> 00:18:28,840
other companies that are working on

00:18:26,800 --> 00:18:30,730
stuff sort of merging these kinds of

00:18:28,840 --> 00:18:32,290
things none of these systems volt

00:18:30,730 --> 00:18:35,080
included is going to solve every problem

00:18:32,290 --> 00:18:37,390
it's going to be mature enough a lot of

00:18:35,080 --> 00:18:39,580
this is not it's not that we can't it's

00:18:37,390 --> 00:18:40,990
that we haven't yet so I think there's a

00:18:39,580 --> 00:18:42,790
lot of opportunity I've got like my

00:18:40,990 --> 00:18:45,100
prospector here there's a lot of

00:18:42,790 --> 00:18:47,860
opportunity to build systems that don't

00:18:45,100 --> 00:18:49,180
have to compromise for operations we're

00:18:47,860 --> 00:18:51,220
engineers there's always trade-offs

00:18:49,180 --> 00:18:53,830
we're always making compromises but we

00:18:51,220 --> 00:18:55,420
can get a lot of the benefits of stream

00:18:53,830 --> 00:18:57,790
processing databases in a more

00:18:55,420 --> 00:18:59,680
integrated way we're really good at a

00:18:57,790 --> 00:19:02,920
lot of these things log stream State

00:18:59,680 --> 00:19:05,650
individually but but better integration

00:19:02,920 --> 00:19:07,540
is a really valuable thing for for

00:19:05,650 --> 00:19:09,100
operations and I've got a whole separate

00:19:07,540 --> 00:19:10,720
talk that explains why operations is

00:19:09,100 --> 00:19:13,120
different than a lot of the analytics

00:19:10,720 --> 00:19:15,520
and batch processing where the the UNIX

00:19:13,120 --> 00:19:17,550
philosophy of get one small tools that

00:19:15,520 --> 00:19:19,900
do things well and put them together

00:19:17,550 --> 00:19:21,580
turns out to be something of a nightmare

00:19:19,900 --> 00:19:23,200
for operations you really want the

00:19:21,580 --> 00:19:23,740
smaller number of tools to monitor as

00:19:23,200 --> 00:19:27,190
you can

00:19:23,740 --> 00:19:29,500
so go out you know if bolt works for you

00:19:27,190 --> 00:19:31,060
if Kafka streams work for you if link

00:19:29,500 --> 00:19:32,170
and beam and all these cool things that

00:19:31,060 --> 00:19:34,480
are out there works that's great

00:19:32,170 --> 00:19:36,960
make them better build new things I

00:19:34,480 --> 00:19:39,310
think that this is where we're going so

00:19:36,960 --> 00:19:41,430
that's it thank you very much you could

00:19:39,310 --> 00:19:44,580
reach out to me I'm here next two days

00:19:41,430 --> 00:19:44,580
thanks guys

00:19:49,669 --> 00:19:52,980
thank you for the talk are there any

00:19:52,230 --> 00:20:01,889
questions

00:19:52,980 --> 00:20:04,620
all questions oh thanks - it's a super

00:20:01,889 --> 00:20:06,450
interesting talk um so you you could

00:20:04,620 --> 00:20:08,399
obviously see that this is coming from a

00:20:06,450 --> 00:20:10,679
database adding more more streaming

00:20:08,399 --> 00:20:12,659
stuff that's where I'm coming from I try

00:20:10,679 --> 00:20:14,850
to see both perspectives like but yes

00:20:12,659 --> 00:20:15,990
yeah so I'm coming from the side I'm one

00:20:14,850 --> 00:20:17,279
of the things people that comes on the

00:20:15,990 --> 00:20:18,659
side of building the stream processor

00:20:17,279 --> 00:20:20,519
and making it more data they see oh yeah

00:20:18,659 --> 00:20:22,889
yeah and I found this comparison

00:20:20,519 --> 00:20:24,779
fascinating ways that they up a priori

00:20:22,889 --> 00:20:27,539
log and then the processing and then the

00:20:24,779 --> 00:20:30,330
a posteriori whatever how to pronounce

00:20:27,539 --> 00:20:33,179
log yeah I can't say that word event so

00:20:30,330 --> 00:20:35,700
that the interesting thing that we kind

00:20:33,179 --> 00:20:37,320
of observed is the the logic that in

00:20:35,700 --> 00:20:38,759
that case post crews would maintain if

00:20:37,320 --> 00:20:40,559
you really you know everything goes to

00:20:38,759 --> 00:20:42,450
that lock you have partition ordering

00:20:40,559 --> 00:20:44,039
everything and so on is you basically

00:20:42,450 --> 00:20:45,840
throw out most of the hard transactional

00:20:44,039 --> 00:20:48,179
logic right because you have you have

00:20:45,840 --> 00:20:50,220
per partition ordered you you kind of

00:20:48,179 --> 00:20:52,440
have a partition single right or model

00:20:50,220 --> 00:20:54,629
almost yeah thing like that and so on so

00:20:52,440 --> 00:20:56,909
how much of that actually really remains

00:20:54,629 --> 00:20:58,649
because if if you actually simplify that

00:20:56,909 --> 00:21:00,240
transactional model to too much of that

00:20:58,649 --> 00:21:01,830
and then you know yet the ability to

00:21:00,240 --> 00:21:03,570
look and some into something like that

00:21:01,830 --> 00:21:05,190
that's kind of what we how we built

00:21:03,570 --> 00:21:07,440
fling link today I would say it's almost

00:21:05,190 --> 00:21:11,940
that model actually and that that's

00:21:07,440 --> 00:21:13,980
question number one and let me get back

00:21:11,940 --> 00:21:16,980
the mic and come okay no matter I think

00:21:13,980 --> 00:21:18,860
that um I think that it really depends

00:21:16,980 --> 00:21:21,269
on the app that you're targeting and and

00:21:18,860 --> 00:21:23,610
also certainly on the mindset of the

00:21:21,269 --> 00:21:25,529
person who or the team that's looking at

00:21:23,610 --> 00:21:27,059
solutions for these kinds of things we

00:21:25,529 --> 00:21:30,269
see a lot of people who are really big

00:21:27,059 --> 00:21:31,499
into transactions because some of the

00:21:30,269 --> 00:21:33,450
things they're mixing is a lot of

00:21:31,499 --> 00:21:34,919
different access to the same system not

00:21:33,450 --> 00:21:37,049
everything comes in the front door

00:21:34,919 --> 00:21:40,139
through like a Kafka ingestion into

00:21:37,049 --> 00:21:41,610
Volpe B there's a mix of maybe I've got

00:21:40,139 --> 00:21:43,320
one client that's pushing an event

00:21:41,610 --> 00:21:45,059
stream through from from

00:21:43,320 --> 00:21:46,499
telecommunications but I've got other

00:21:45,059 --> 00:21:47,070
clients that are pushing monitoring

00:21:46,499 --> 00:21:49,080
streams

00:21:47,070 --> 00:21:51,659
I've got other clients that are that are

00:21:49,080 --> 00:21:53,639
making updating black lifts tables and

00:21:51,659 --> 00:21:57,389
things and having that transactional

00:21:53,639 --> 00:21:58,480
model of I can say that this is time T

00:21:57,389 --> 00:22:00,070
whatever

00:21:58,480 --> 00:22:01,299
and that before this here all the events

00:22:00,070 --> 00:22:03,280
that came in and after all the events

00:22:01,299 --> 00:22:04,510
that came in but it's not necessarily

00:22:03,280 --> 00:22:07,690
like everything gets shoved through a

00:22:04,510 --> 00:22:12,100
pipeline you know in our system I think

00:22:07,690 --> 00:22:13,540
that in some in you'd certainly I think

00:22:12,100 --> 00:22:16,360
it's interesting to think about in terms

00:22:13,540 --> 00:22:17,470
of a if you do shove everything's run to

00:22:16,360 --> 00:22:18,520
where can you get rid of a lot of the

00:22:17,470 --> 00:22:24,270
transaction stuff I think in many

00:22:18,520 --> 00:22:24,270
situations yes it's a satisfying answer

00:22:28,230 --> 00:22:32,830
yeah that's one of the places where I

00:22:30,760 --> 00:22:34,360
think we're interested in going more and

00:22:32,830 --> 00:22:37,330
and you know I say we're not for

00:22:34,360 --> 00:22:39,190
everybody in terms of building systems

00:22:37,330 --> 00:22:40,750
that chain one piece of logic after

00:22:39,190 --> 00:22:42,250
another that's something that we'd like

00:22:40,750 --> 00:22:46,090
to get a lot better at and it's not

00:22:42,250 --> 00:22:48,880
where we've started we might have time

00:22:46,090 --> 00:22:52,650
for one short question if not you can

00:22:48,880 --> 00:22:52,650
catch John after this talk

00:22:59,530 --> 00:23:04,490
just a question on the kind of

00:23:02,570 --> 00:23:06,470
partitioning that you need to use in a

00:23:04,490 --> 00:23:08,150
database like this like yeah I

00:23:06,470 --> 00:23:09,530
understand read transactions is easy

00:23:08,150 --> 00:23:12,140
because it doesn't really matter whether

00:23:09,530 --> 00:23:15,260
they come to different partitions but

00:23:12,140 --> 00:23:17,450
doesn't performance tank if you do write

00:23:15,260 --> 00:23:21,230
transactions across partitions and

00:23:17,450 --> 00:23:23,840
doesn't it or where do you see that I

00:23:21,230 --> 00:23:26,360
mean we began and working through doing

00:23:23,840 --> 00:23:28,880
a synchronous there that we fire out the

00:23:26,360 --> 00:23:30,440
thing on Kafka and then re partitioning

00:23:28,880 --> 00:23:32,390
and saying like let's make it an even

00:23:30,440 --> 00:23:34,970
potent operation and we lose the

00:23:32,390 --> 00:23:38,330
transactional thing then but where do

00:23:34,970 --> 00:23:40,750
you see both DB going with sauce

00:23:38,330 --> 00:23:43,370
partition transaction so we certainly

00:23:40,750 --> 00:23:45,680
most of the transactions that we run

00:23:43,370 --> 00:23:49,100
partition usually that the whatever

00:23:45,680 --> 00:23:51,470
customer user is doing they've got some

00:23:49,100 --> 00:23:53,810
big operation that partitions pretty

00:23:51,470 --> 00:23:55,730
well but they do often want to mix that

00:23:53,810 --> 00:23:57,020
with global writes and that's one of the

00:23:55,730 --> 00:23:58,760
things that separates both from some of

00:23:57,020 --> 00:24:01,340
these systems is we can do transactional

00:23:58,760 --> 00:24:02,780
global rights and a lot of times we see

00:24:01,340 --> 00:24:04,730
that is I want to transactionally update

00:24:02,780 --> 00:24:07,420
a lookup table everywhere at the same

00:24:04,730 --> 00:24:09,800
logical time across the whole system

00:24:07,420 --> 00:24:12,410
people want to occasionally there are

00:24:09,800 --> 00:24:14,720
things where there are less common

00:24:12,410 --> 00:24:17,270
operations but require transactional

00:24:14,720 --> 00:24:18,650
changes the one that we don't do a lot

00:24:17,270 --> 00:24:20,000
of but people you know the canonical

00:24:18,650 --> 00:24:22,460
example is like a debit credit

00:24:20,000 --> 00:24:25,580
transaction but we do have a lot of like

00:24:22,460 --> 00:24:27,170
you know read everywhere for where

00:24:25,580 --> 00:24:28,640
there's like an open seat or something

00:24:27,170 --> 00:24:32,150
and then book the seat in one place

00:24:28,640 --> 00:24:33,440
would be sort of a global transaction

00:24:32,150 --> 00:24:35,210
even if it only writes in one place

00:24:33,440 --> 00:24:37,160
there are some other cases where you

00:24:35,210 --> 00:24:38,810
want to re partition data so you need a

00:24:37,160 --> 00:24:40,640
transaction that touches two partitions

00:24:38,810 --> 00:24:43,040
and that's something that having that

00:24:40,640 --> 00:24:44,720
functionality helps with but there's a

00:24:43,040 --> 00:24:46,640
lot of research on how to make that

00:24:44,720 --> 00:24:47,690
faster and how to do that without being

00:24:46,640 --> 00:24:48,980
less invasive

00:24:47,690 --> 00:24:50,030
we're trailing a lot of that because

00:24:48,980 --> 00:24:52,130
we're trying to build a production

00:24:50,030 --> 00:24:55,250
system but it's something that is going

00:24:52,130 --> 00:24:56,780
to get easier and easier I think thank

00:24:55,250 --> 00:24:58,520
you thank you for the talk and if you

00:24:56,780 --> 00:25:00,860
want to if you have more questions can

00:24:58,520 --> 00:25:03,500
catch John after the you know in the

00:25:00,860 --> 00:25:10,359
breaks so yeah thank you

00:25:03,500 --> 00:25:10,359

YouTube URL: https://www.youtube.com/watch?v=GoJYZRKY5io


