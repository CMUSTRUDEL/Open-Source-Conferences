Title: Berlin Buzzwords 2017: Bastian Mathes - Did-you-mean #bbuzz
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	This talk gives an introduction to an often used but little thought about feature of fulltext search systems: did-you-mean (aka spellcheck). Whenever you misspell a query this useful feature kicks in and and will show you the query you really meant - or won't it?

We will highlight potential requirements to a did-you-mean feature and identify their difficulties. We will discuss the implementations available in Solr and Elasticsearch. But there are also alternative algorithms and data structures used in real world search projects which we will show. What is the difference between all these approaches and which one should you use when?

Read more:
https://2017.berlinbuzzwords.de/17/session/did-you-mean

About Bastian Mathes:
https://2017.berlinbuzzwords.de/users/bastian-mathes

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,490 --> 00:00:10,230
and yeah welcome everybody so this talk

00:00:08,250 --> 00:00:12,630
is about did you mean or spells like a

00:00:10,230 --> 00:00:14,910
feature in or an often overlooked

00:00:12,630 --> 00:00:16,980
feature in such systems it's not about

00:00:14,910 --> 00:00:20,160
containerized anything so if you have a

00:00:16,980 --> 00:00:21,989
printed program that has changed so I

00:00:20,160 --> 00:00:24,800
hope not half of you are leaving now but

00:00:21,989 --> 00:00:29,730
I just wanted to save mention it before

00:00:24,800 --> 00:00:31,619
so um yeah what I what do I want to show

00:00:29,730 --> 00:00:33,690
in the next 20 minutes I wanted to give

00:00:31,619 --> 00:00:35,820
you an introduction and what did you

00:00:33,690 --> 00:00:38,460
mean or spell check is it such systems I

00:00:35,820 --> 00:00:41,789
wanted to show some implementation

00:00:38,460 --> 00:00:44,010
approaches yeah I wrote nothing fancy so

00:00:41,789 --> 00:00:45,899
there's not anything machine learning or

00:00:44,010 --> 00:00:48,570
anything in there it's a basic data

00:00:45,899 --> 00:00:50,309
structures you can use existing

00:00:48,570 --> 00:00:52,829
implementations you can implement them

00:00:50,309 --> 00:00:56,129
yourself I did implement most of these

00:00:52,829 --> 00:00:59,399
myself that I will show you and yeah

00:00:56,129 --> 00:01:03,719
I'll give a short summary of what we've

00:00:59,399 --> 00:01:05,820
learned hopefully then and it's not

00:01:03,719 --> 00:01:08,780
about me slide so I'm working for

00:01:05,820 --> 00:01:10,890
rationed in Bihar in Dusseldorf we are

00:01:08,780 --> 00:01:14,520
specialized in such projects we are

00:01:10,890 --> 00:01:16,759
almost 50 people now and yeah doing at

00:01:14,520 --> 00:01:20,880
the price surge projects add product

00:01:16,759 --> 00:01:23,939
exclusively me myself since 2009 the

00:01:20,880 --> 00:01:27,479
company since 2001 and I've worked with

00:01:23,939 --> 00:01:29,100
a lot of such engine technology I listed

00:01:27,479 --> 00:01:32,880
them here of course the open source one

00:01:29,100 --> 00:01:35,030
they really and get get to speed on the

00:01:32,880 --> 00:01:38,640
last two or three years at least for our

00:01:35,030 --> 00:01:41,969
duplicate clients and some commercial

00:01:38,640 --> 00:01:43,500
ones and there are still some technology

00:01:41,969 --> 00:01:47,520
inside the company that my colleagues

00:01:43,500 --> 00:01:50,609
have used but I never saw and I left out

00:01:47,520 --> 00:01:52,829
something that vanished so in the last

00:01:50,609 --> 00:01:59,159
what is it 16 years there's a lot of

00:01:52,829 --> 00:02:01,890
technology vanishing so yeah let's start

00:01:59,159 --> 00:02:04,219
and with what is did you mean or spell

00:02:01,890 --> 00:02:07,950
check in search you probably know it and

00:02:04,219 --> 00:02:11,250
I took unfortunately a German example

00:02:07,950 --> 00:02:13,800
has if you write some search term or

00:02:11,250 --> 00:02:16,380
maybe some name like here when I did the

00:02:13,800 --> 00:02:17,620
screenshot she was there just newly

00:02:16,380 --> 00:02:19,480
reelected

00:02:17,620 --> 00:02:22,690
after that lunch so she has a long name

00:02:19,480 --> 00:02:26,440
you can misspell it and Google gives you

00:02:22,690 --> 00:02:29,530
the correct spelling of it and yeah you

00:02:26,440 --> 00:02:31,659
probably know that and so user

00:02:29,530 --> 00:02:34,150
misspelled there are no a few results

00:02:31,659 --> 00:02:36,790
they are almost never know results at

00:02:34,150 --> 00:02:38,590
Google but there are no results in your

00:02:36,790 --> 00:02:41,590
internet search showing your shop search

00:02:38,590 --> 00:02:44,230
or something like this and did you mean

00:02:41,590 --> 00:02:48,310
will suggest the most likely correction

00:02:44,230 --> 00:02:51,489
which we will see more clearly in in the

00:02:48,310 --> 00:02:53,230
next slides well that's basically it but

00:02:51,489 --> 00:02:56,099
still if you if you set up a search

00:02:53,230 --> 00:02:59,920
system you have some let's say usability

00:02:56,099 --> 00:03:03,940
decisions to make on how to implement

00:02:59,920 --> 00:03:06,250
and did you mean for example so let's

00:03:03,940 --> 00:03:08,170
let's take it a given we will get back

00:03:06,250 --> 00:03:10,269
to that in there in the rest of the talk

00:03:08,170 --> 00:03:13,090
that there are some that you mean module

00:03:10,269 --> 00:03:15,489
that delivers the correction and also

00:03:13,090 --> 00:03:17,470
preferably an estimated number of

00:03:15,489 --> 00:03:19,599
results for this correction because you

00:03:17,470 --> 00:03:21,790
have to to assess if this is a good

00:03:19,599 --> 00:03:24,099
correction or how good is the collection

00:03:21,790 --> 00:03:25,599
but then you still have to decide when

00:03:24,099 --> 00:03:27,579
do I want to show this did you mean at

00:03:25,599 --> 00:03:29,769
all like if I have a thousand hits and

00:03:27,579 --> 00:03:32,769
there's a there's a correction that has

00:03:29,769 --> 00:03:34,419
like more hits do I show it maybe it I

00:03:32,769 --> 00:03:37,540
don't show it because it's already in a

00:03:34,419 --> 00:03:40,120
sense and when maybe to redirect

00:03:37,540 --> 00:03:42,340
directly to the M to the correction that

00:03:40,120 --> 00:03:43,599
Google is doing this very often if you

00:03:42,340 --> 00:03:46,090
have very few hits and you have a

00:03:43,599 --> 00:03:48,010
correction then Google is redirecting

00:03:46,090 --> 00:03:49,480
you to the to the search result for the

00:03:48,010 --> 00:03:54,129
correction and just gives you a link

00:03:49,480 --> 00:03:56,049
back to your original query and another

00:03:54,129 --> 00:03:58,840
possibility is maybe to search for both

00:03:56,049 --> 00:04:00,579
here so Google did that some months ago

00:03:58,840 --> 00:04:03,579
and then they suddenly stopped doing

00:04:00,579 --> 00:04:07,329
this so they are also experimenting in

00:04:03,579 --> 00:04:09,280
this area and showing different things

00:04:07,329 --> 00:04:12,459
to different users I haven't seen it

00:04:09,280 --> 00:04:16,510
anymore but you could also say if you

00:04:12,459 --> 00:04:18,340
are like and you have a search result

00:04:16,510 --> 00:04:21,940
and you have a correction that maybe has

00:04:18,340 --> 00:04:24,099
a similar amount of results maybe you

00:04:21,940 --> 00:04:27,580
just search for both this can be correct

00:04:24,099 --> 00:04:29,320
or incorrect and it's it's hard to

00:04:27,580 --> 00:04:31,090
decide what to do in your project and

00:04:29,320 --> 00:04:33,100
either you can

00:04:31,090 --> 00:04:35,440
something like a be testing with the

00:04:33,100 --> 00:04:38,410
users if it's internet and you don't

00:04:35,440 --> 00:04:40,510
monetize it I don't know if you always

00:04:38,410 --> 00:04:43,240
find a good way to measure what's better

00:04:40,510 --> 00:04:45,850
sometimes it's just a matter of K a

00:04:43,240 --> 00:04:47,710
taste of the personal charge and they

00:04:45,850 --> 00:04:50,290
tell you I like that more than this one

00:04:47,710 --> 00:04:53,050
and then you implement like this and

00:04:50,290 --> 00:04:54,370
this just as a background this is

00:04:53,050 --> 00:04:56,410
something you have to decide in your

00:04:54,370 --> 00:04:58,510
project if you if you set up your search

00:04:56,410 --> 00:05:00,610
for your website for your website or for

00:04:58,510 --> 00:05:03,040
your internet this what we decide to do

00:05:00,610 --> 00:05:05,680
in in the next slides I want to look

00:05:03,040 --> 00:05:12,220
more at this module and how it delivers

00:05:05,680 --> 00:05:14,020
corrections to you so what's what's the

00:05:12,220 --> 00:05:17,710
requirement for for such additional

00:05:14,020 --> 00:05:19,389
model and module history so the

00:05:17,710 --> 00:05:22,810
requirement is to find a similar query

00:05:19,389 --> 00:05:25,240
with more results preferably this is

00:05:22,810 --> 00:05:28,120
already discussed below so first what

00:05:25,240 --> 00:05:30,760
what does sumela mean and I have to cut

00:05:28,120 --> 00:05:33,880
this a bit out of this table due to the

00:05:30,760 --> 00:05:35,590
time so there are distance functions

00:05:33,880 --> 00:05:37,270
between strings you you can have some

00:05:35,590 --> 00:05:40,060
multiple of them leaves time is like the

00:05:37,270 --> 00:05:41,560
most common used one you can look it up

00:05:40,060 --> 00:05:43,960
at Wikipedia there's a good article

00:05:41,560 --> 00:05:45,910
about it and so you you have two strings

00:05:43,960 --> 00:05:48,340
and you can come up with a number on how

00:05:45,910 --> 00:05:52,450
far away the strings are from each other

00:05:48,340 --> 00:05:56,800
and that's basically what you sorry what

00:05:52,450 --> 00:06:01,300
you need and to to say this is somehow

00:05:56,800 --> 00:06:04,360
similar correction so now and if you can

00:06:01,300 --> 00:06:07,690
come up with more than one possible

00:06:04,360 --> 00:06:09,520
correction for you use a query and then

00:06:07,690 --> 00:06:11,590
you somehow have to rank them or you

00:06:09,520 --> 00:06:14,710
have to to weight them and there are

00:06:11,590 --> 00:06:17,310
there may be even more factors that you

00:06:14,710 --> 00:06:19,330
you can come up with but the most

00:06:17,310 --> 00:06:21,820
important ones from from my perspective

00:06:19,330 --> 00:06:23,620
are the similarity we talked here before

00:06:21,820 --> 00:06:25,960
so there may be one correction is more

00:06:23,620 --> 00:06:28,960
similar than other correction but also

00:06:25,960 --> 00:06:31,419
the frequency or the occurrence or the

00:06:28,960 --> 00:06:33,100
number of results that you expect from

00:06:31,419 --> 00:06:35,650
your correction so a correction that

00:06:33,100 --> 00:06:38,139
delivers a million results may be better

00:06:35,650 --> 00:06:40,630
than a corrector to live a thousand

00:06:38,139 --> 00:06:43,940
results and just to weight them you you

00:06:40,630 --> 00:06:46,550
may have a more similar

00:06:43,940 --> 00:06:49,760
correction with less results and just to

00:06:46,550 --> 00:06:51,770
make the decisions - so what's the basis

00:06:49,760 --> 00:06:54,050
for for all what I want to show next as

00:06:51,770 --> 00:06:56,690
possible implementations and it's a

00:06:54,050 --> 00:07:00,890
dictionary of valid clear returns so

00:06:56,690 --> 00:07:03,020
somehow you you have a list of queries

00:07:00,890 --> 00:07:06,040
that do make sense and you want to get

00:07:03,020 --> 00:07:11,030
from this list a similar query to your

00:07:06,040 --> 00:07:13,760
entered user query and they may be one

00:07:11,030 --> 00:07:15,950
word or more but 95% of the searches are

00:07:13,760 --> 00:07:18,710
one word but you want to give the 5%

00:07:15,950 --> 00:07:21,620
that enter more than one word maybe it's

00:07:18,710 --> 00:07:23,300
only 90% I don't know and you want to

00:07:21,620 --> 00:07:25,400
give the small amount that enter more

00:07:23,300 --> 00:07:29,000
than one word also a good correction of

00:07:25,400 --> 00:07:31,370
course so and this list maybe one or

00:07:29,000 --> 00:07:34,280
more words and it should also include

00:07:31,370 --> 00:07:37,550
some kind of frequency so how often does

00:07:34,280 --> 00:07:39,050
this term cure and it possibly or

00:07:37,550 --> 00:07:41,150
normally it has also the language

00:07:39,050 --> 00:07:43,430
because this is totally separated by

00:07:41,150 --> 00:07:45,470
language and and you may have more

00:07:43,430 --> 00:07:47,930
separations like the search area you

00:07:45,470 --> 00:07:50,120
have multiple search interfaces or areas

00:07:47,930 --> 00:07:53,810
or tops or whatever and you only want to

00:07:50,120 --> 00:07:56,600
show Corrections from your area and the

00:07:53,810 --> 00:07:58,580
main goal is to never redirect the user

00:07:56,600 --> 00:08:00,590
to is your result page because this is

00:07:58,580 --> 00:08:03,169
just broken and error and you are in

00:08:00,590 --> 00:08:04,730
your search you maybe have ACL so access

00:08:03,169 --> 00:08:07,130
control list if you're doing secure

00:08:04,730 --> 00:08:08,120
search with which is a common case in an

00:08:07,130 --> 00:08:13,190
internet search

00:08:08,120 --> 00:08:15,140
then you should our idea is you should

00:08:13,190 --> 00:08:17,960
include this into your dick immune to

00:08:15,140 --> 00:08:19,910
because your correction may be from

00:08:17,960 --> 00:08:22,580
results that the user is allowed to see

00:08:19,910 --> 00:08:25,400
so that's not helping so you you have to

00:08:22,580 --> 00:08:28,580
UM reflect the permissions also in

00:08:25,400 --> 00:08:31,220
something like digi movie so where to

00:08:28,580 --> 00:08:32,690
get this dictionary from and single word

00:08:31,220 --> 00:08:34,190
for quite easy you have them in the

00:08:32,690 --> 00:08:37,750
index you normally already have the

00:08:34,190 --> 00:08:41,360
tokenize that's the the main and

00:08:37,750 --> 00:08:43,580
technique in a search index and and

00:08:41,360 --> 00:08:46,760
getting multiple terms is much more

00:08:43,580 --> 00:08:49,670
difficult you could take like

00:08:46,760 --> 00:08:53,870
co-occurrence in the index but your data

00:08:49,670 --> 00:08:56,630
and your amount of data explodes so and

00:08:53,870 --> 00:09:00,290
to get meaningful it multiple terms is

00:08:56,630 --> 00:09:02,390
much more difficult so often you come up

00:09:00,290 --> 00:09:04,550
with not having a good amount of

00:09:02,390 --> 00:09:06,890
multiple terms into your in your

00:09:04,550 --> 00:09:10,730
dictionary and and then you have to

00:09:06,890 --> 00:09:13,550
think about splitting up long long

00:09:10,730 --> 00:09:17,690
series and check or get corrections for

00:09:13,550 --> 00:09:22,010
only parts of these clothes and possibly

00:09:17,690 --> 00:09:23,780
by word and this is a the difficulty

00:09:22,010 --> 00:09:25,550
years and if you have a good correction

00:09:23,780 --> 00:09:27,620
for parts of the clue you don't know if

00:09:25,550 --> 00:09:30,140
the whole query still gives the result

00:09:27,620 --> 00:09:32,900
at all and you either have to test this

00:09:30,140 --> 00:09:35,330
or do a query but this gives you a mock

00:09:32,900 --> 00:09:37,670
the reload and all you have to accept

00:09:35,330 --> 00:09:40,310
that you may redirect the user to the

00:09:37,670 --> 00:09:42,740
zero results again and of course if you

00:09:40,310 --> 00:09:45,110
split up your user query you would like

00:09:42,740 --> 00:09:48,740
to test if the whole query sauce so that

00:09:45,110 --> 00:09:51,680
like half of five word query words one

00:09:48,740 --> 00:09:54,230
two four one two three one two two only

00:09:51,680 --> 00:09:56,480
one and two two five and so on you get a

00:09:54,230 --> 00:09:58,780
lot of lookups to your determine or

00:09:56,480 --> 00:10:00,800
spell check and it's a matter of the

00:09:58,780 --> 00:10:03,490
implementation if it's a memory if it's

00:10:00,800 --> 00:10:05,690
in the database if this is acceptable

00:10:03,490 --> 00:10:09,620
yeah that's that's basically what's

00:10:05,690 --> 00:10:11,570
what's around it and I want to have a

00:10:09,620 --> 00:10:13,730
quick walk through for possible

00:10:11,570 --> 00:10:18,800
implementations on how to look up

00:10:13,730 --> 00:10:23,030
Corrections and the one I caught naive

00:10:18,800 --> 00:10:25,640
is you have a list of terms knowledge

00:10:23,030 --> 00:10:28,880
and so in my examples on German but it's

00:10:25,640 --> 00:10:30,500
just a bag of words so you have a list

00:10:28,880 --> 00:10:32,420
of terms small s and you have a user

00:10:30,500 --> 00:10:35,300
query and then you run through the list

00:10:32,420 --> 00:10:40,520
of terms and calculate the distance with

00:10:35,300 --> 00:10:42,510
some metric you you define before and if

00:10:40,520 --> 00:10:44,940
you find

00:10:42,510 --> 00:10:47,070
a correction that's within some metric

00:10:44,940 --> 00:10:51,770
some distance limit so this is

00:10:47,070 --> 00:10:54,600
acceptable for you you return it if you

00:10:51,770 --> 00:10:56,730
if you are able to sort this by by

00:10:54,600 --> 00:10:58,800
frequency of our number of estimated

00:10:56,730 --> 00:11:02,970
results then your first results your

00:10:58,800 --> 00:11:04,950
best one if not you have to decide how

00:11:02,970 --> 00:11:08,370
long you will run through this list so

00:11:04,950 --> 00:11:10,110
maybe get the first result but then is

00:11:08,370 --> 00:11:12,390
that the best or get the first five

00:11:10,110 --> 00:11:16,580
possible or acceptable results that we

00:11:12,390 --> 00:11:19,280
turn the best one sub directives and the

00:11:16,580 --> 00:11:22,170
advantage of this method is that it can

00:11:19,280 --> 00:11:24,090
sometimes be done in place so you

00:11:22,170 --> 00:11:26,160
already have this data structure like if

00:11:24,090 --> 00:11:27,870
you think about a search engine you have

00:11:26,160 --> 00:11:29,640
a list of terms because that's exactly

00:11:27,870 --> 00:11:32,910
what your index is about you have a term

00:11:29,640 --> 00:11:34,770
vector or term iterator you can walk

00:11:32,910 --> 00:11:36,960
through this list of terms and it's very

00:11:34,770 --> 00:11:40,830
easy to implement without additional and

00:11:36,960 --> 00:11:43,110
disk space and it's obvious that this

00:11:40,830 --> 00:11:45,720
doesn't scale very well so if this list

00:11:43,110 --> 00:11:50,190
get off of your existing terms gets very

00:11:45,720 --> 00:11:54,630
long and it will take a lot of time to

00:11:50,190 --> 00:11:56,910
walk through it and this this comparison

00:11:54,630 --> 00:12:01,160
or this this distance calculation

00:11:56,910 --> 00:12:04,200
normally is this quadratic effort so um

00:12:01,160 --> 00:12:07,370
yeah it's a lot of effort if your index

00:12:04,200 --> 00:12:10,740
is large and one thing that's also

00:12:07,370 --> 00:12:14,460
implemented in in Latino and solar and

00:12:10,740 --> 00:12:16,290
domestic search and is getting down so

00:12:14,460 --> 00:12:18,540
it's it's more or less an improvement of

00:12:16,290 --> 00:12:22,380
the first one and getting down this time

00:12:18,540 --> 00:12:25,860
to compare your user query to the list

00:12:22,380 --> 00:12:29,100
of possible queries that you have I am

00:12:25,860 --> 00:12:33,570
producing an automation be up front so

00:12:29,100 --> 00:12:35,550
for your clear you produce this is a NFS

00:12:33,570 --> 00:12:37,650
or non-deterministic one you have to

00:12:35,550 --> 00:12:39,960
have a deterministic one in the end

00:12:37,650 --> 00:12:42,810
please also you have to look it up at

00:12:39,960 --> 00:12:45,210
Wikipedia so if for that time it gets

00:12:42,810 --> 00:12:48,930
very large so this this one is now quite

00:12:45,210 --> 00:12:50,520
and quite small but if you am expanded

00:12:48,930 --> 00:12:52,470
to a deterministic one it gets very

00:12:50,520 --> 00:12:55,890
large and you have to do this before and

00:12:52,470 --> 00:12:57,720
we take some memory per user query but

00:12:55,890 --> 00:13:00,750
then you can run through this listent

00:12:57,720 --> 00:13:03,060
and accept your words in linear time so

00:13:00,750 --> 00:13:05,010
it gets faster it's it's really

00:13:03,060 --> 00:13:06,900
implemented like in this direct spell

00:13:05,010 --> 00:13:09,470
checker and so now this time suggested

00:13:06,900 --> 00:13:12,690
main elasticsearch it works in place and

00:13:09,470 --> 00:13:15,210
of course in the scene index the terms

00:13:12,690 --> 00:13:18,240
are not sorted by by number of documents

00:13:15,210 --> 00:13:20,040
so you have to decide and want to stop

00:13:18,240 --> 00:13:23,580
and I think the default is whatever I

00:13:20,040 --> 00:13:25,680
said before to look for at most five

00:13:23,580 --> 00:13:27,870
acceptable Corrections and then take the

00:13:25,680 --> 00:13:29,250
best one but you can if you implement it

00:13:27,870 --> 00:13:33,630
yourself you can come up with other

00:13:29,250 --> 00:13:35,460
heuristics on how to do this again this

00:13:33,630 --> 00:13:37,140
can be done in place but you have a

00:13:35,460 --> 00:13:40,010
quite large data structure for every

00:13:37,140 --> 00:13:42,930
query that you have to build up front

00:13:40,010 --> 00:13:44,370
this is one possibility another very

00:13:42,930 --> 00:13:48,030
interesting data structure for doing

00:13:44,370 --> 00:13:50,820
that you mean M is a decay to evoke odd

00:13:48,030 --> 00:13:52,890
color tree and again if you look it up

00:13:50,820 --> 00:13:56,670
there's some good blog posts about it

00:13:52,890 --> 00:13:58,530
and the disadvantage is now you're

00:13:56,670 --> 00:14:00,780
building an additional data structure so

00:13:58,530 --> 00:14:05,010
you have an index m and with a list of

00:14:00,780 --> 00:14:07,050
words and you start to build another

00:14:05,010 --> 00:14:09,030
data structure for your de chimie and

00:14:07,050 --> 00:14:11,820
then you have to see how large is this

00:14:09,030 --> 00:14:15,780
data structure how many terms especially

00:14:11,820 --> 00:14:17,970
if you think about and putting multiple

00:14:15,780 --> 00:14:19,860
terms with occurrence like every three

00:14:17,970 --> 00:14:21,180
in every two terms that occur in the

00:14:19,860 --> 00:14:23,790
index next to each other in this

00:14:21,180 --> 00:14:25,800
dictionary it gets very large and then

00:14:23,790 --> 00:14:28,530
it maybe doesn't fit into memory anymore

00:14:25,800 --> 00:14:32,760
and then it gets slow to to query it and

00:14:28,530 --> 00:14:34,950
so on and so I've implemented that in

00:14:32,760 --> 00:14:37,350
memory notes in a relational database

00:14:34,950 --> 00:14:39,090
and in memory - are you fine of course

00:14:37,350 --> 00:14:41,790
it's fast but in a relational database

00:14:39,090 --> 00:14:45,390
there's a lot of yeah you have to have

00:14:41,790 --> 00:14:48,090
some and cancer conditions where you say

00:14:45,390 --> 00:14:53,460
okay now I search for 500 milliseconds

00:14:48,090 --> 00:14:55,200
and then I stop and and you also have a

00:14:53,460 --> 00:14:56,820
periodic effort to recreate this data

00:14:55,200 --> 00:14:59,730
structure from your index to keep it

00:14:56,820 --> 00:15:02,670
up-to-date so and how does it work and

00:14:59,730 --> 00:15:05,370
you you have again ideally the most

00:15:02,670 --> 00:15:07,570
common word term in the in the root and

00:15:05,370 --> 00:15:11,200
then and you have the distance

00:15:07,570 --> 00:15:14,320
on the next term in the and yet and so

00:15:11,200 --> 00:15:17,500
everything on this to edge from house

00:15:14,320 --> 00:15:19,720
has a distance of two two house and so

00:15:17,500 --> 00:15:25,240
on and then you can can use this

00:15:19,720 --> 00:15:28,120
triangle inequality so and every stop it

00:15:25,240 --> 00:15:31,930
between as longer than the direct the

00:15:28,120 --> 00:15:35,950
direct distance would say and to cut out

00:15:31,930 --> 00:15:38,980
a lot of a lot of notes that you don't

00:15:35,950 --> 00:15:41,530
have to expect so you you can just

00:15:38,980 --> 00:15:43,180
narrow down what you have to expect in

00:15:41,530 --> 00:15:45,520
your in your search tree and it works

00:15:43,180 --> 00:15:48,550
quite well in memory and is quite

00:15:45,520 --> 00:15:52,690
elegant and what comes out of it is a

00:15:48,550 --> 00:15:56,010
direct and hit with a given limit in in

00:15:52,690 --> 00:15:58,900
distance so that's best a nice one and

00:15:56,010 --> 00:16:02,620
another one that's very often used and

00:15:58,900 --> 00:16:07,300
it's an Engram dictionary so M Engram

00:16:02,620 --> 00:16:11,350
here means you split your words and also

00:16:07,300 --> 00:16:15,670
your fairly later into parts with one

00:16:11,350 --> 00:16:18,550
two so Unni graham Begum tricking one

00:16:15,670 --> 00:16:21,190
two or three letters and then you index

00:16:18,550 --> 00:16:23,020
them in a basically in a search engine

00:16:21,190 --> 00:16:27,310
or in a hash map if you do it in memory

00:16:23,020 --> 00:16:30,520
and I have an example on the next slide

00:16:27,310 --> 00:16:32,770
sonnet and they're the advantages

00:16:30,520 --> 00:16:34,480
compared to the substrate it's a it's

00:16:32,770 --> 00:16:37,600
again a specialized data structure just

00:16:34,480 --> 00:16:39,480
for it you mean but the advantage of the

00:16:37,600 --> 00:16:42,040
search tree is that there is sufficient

00:16:39,480 --> 00:16:44,080
infrastructure for search in excess here

00:16:42,040 --> 00:16:46,840
we have a lot of search engines and also

00:16:44,080 --> 00:16:50,020
for in memory and everything is there

00:16:46,840 --> 00:16:52,060
and it's also easy if you do a query

00:16:50,020 --> 00:16:54,760
against the scene index for example it's

00:16:52,060 --> 00:16:57,970
also easy to add additional filter

00:16:54,760 --> 00:17:01,060
criteria to M to your search in your

00:16:57,970 --> 00:17:03,130
document structure like you can can have

00:17:01,060 --> 00:17:05,620
access control lists in the structure

00:17:03,130 --> 00:17:10,329
and filter your possibility means by

00:17:05,620 --> 00:17:13,660
this and the disadvantage is that this

00:17:10,329 --> 00:17:15,400
mm distance that that comes out so what

00:17:13,660 --> 00:17:17,500
what comes out is I have a correction

00:17:15,400 --> 00:17:19,079
that where the query and the possible

00:17:17,500 --> 00:17:21,390
collectors share three and

00:17:19,079 --> 00:17:23,399
three three grams or something like this

00:17:21,390 --> 00:17:25,620
this is not very intuitive so you

00:17:23,399 --> 00:17:27,630
normally post check whether with a

00:17:25,620 --> 00:17:29,880
distance function like Levenstein

00:17:27,630 --> 00:17:31,529
afterwards and then it may be that you

00:17:29,880 --> 00:17:33,090
don't have enough result in your first

00:17:31,529 --> 00:17:35,370
10 results and then you have to fetch

00:17:33,090 --> 00:17:37,440
the next 10 and so on it's a bit more

00:17:35,370 --> 00:17:39,179
complicated to implement basically this

00:17:37,440 --> 00:17:40,620
this index based by checkers on our

00:17:39,179 --> 00:17:41,429
works like this but you can also

00:17:40,620 --> 00:17:43,620
implement it

00:17:41,429 --> 00:17:46,260
freshly on your own with the Lucene

00:17:43,620 --> 00:17:49,980
index for example and that's what I what

00:17:46,260 --> 00:17:52,139
I have shown here um so you're basically

00:17:49,980 --> 00:17:54,240
having as an index your documents are

00:17:52,139 --> 00:17:56,789
the words or the queries they could be

00:17:54,240 --> 00:17:59,909
multi-value a multi-term multi-word

00:17:56,789 --> 00:18:03,330
sorry I don't have it here and you you

00:17:59,909 --> 00:18:05,970
save the length of the word here and the

00:18:03,330 --> 00:18:10,710
frequency so half the Cure and then I I

00:18:05,970 --> 00:18:13,289
took Unni grams so letters in one field

00:18:10,710 --> 00:18:15,570
and also a search area here too to

00:18:13,289 --> 00:18:17,880
filter by an additional criteria and

00:18:15,570 --> 00:18:19,950
then you can formulate the same theory

00:18:17,880 --> 00:18:22,049
that's a bit more complicated so for

00:18:19,950 --> 00:18:25,019
example you want to have your correction

00:18:22,049 --> 00:18:28,679
for Laos again at most later studies

00:18:25,019 --> 00:18:31,409
tubes one and in your search area a and

00:18:28,679 --> 00:18:33,740
so you can formulate a query that s of

00:18:31,409 --> 00:18:37,409
course one criteria search every a and

00:18:33,740 --> 00:18:40,950
your length you you know how much it can

00:18:37,409 --> 00:18:44,039
differ yeah and then you see listen has

00:18:40,950 --> 00:18:46,799
a lot of good query and implemented

00:18:44,039 --> 00:18:49,230
queries you can say I want to have four

00:18:46,799 --> 00:18:50,610
matches out of these five matches for

00:18:49,230 --> 00:18:54,000
example this is this many more match

00:18:50,610 --> 00:18:55,529
what you can set how do you you can do

00:18:54,000 --> 00:19:00,029
this positionally queries where you say

00:18:55,529 --> 00:19:02,519
and I want to have the term air in in

00:19:00,029 --> 00:19:05,070
the field unit arms and but only from

00:19:02,519 --> 00:19:08,370
position 0 to 2 and then and you can

00:19:05,070 --> 00:19:10,380
calculate and what's possible for for an

00:19:08,370 --> 00:19:12,360
acceptable correction but you have to

00:19:10,380 --> 00:19:13,350
post check them with whether lives it's

00:19:12,360 --> 00:19:15,149
not directly

00:19:13,350 --> 00:19:17,490
Liam suggested that's better

00:19:15,149 --> 00:19:21,090
understandable for people and then load

00:19:17,490 --> 00:19:24,210
results and if you do not uni grams but

00:19:21,090 --> 00:19:26,220
B grams or 3 grams then the subscale a

00:19:24,210 --> 00:19:29,370
bit faster because you have more terms

00:19:26,220 --> 00:19:30,390
in this field and but your post checks

00:19:29,370 --> 00:19:33,750
are more

00:19:30,390 --> 00:19:37,670
and they are multiple checks because the

00:19:33,750 --> 00:19:41,600
results get more fuzzy so but yeah it is

00:19:37,670 --> 00:19:46,680
well being able to implement by your own

00:19:41,600 --> 00:19:48,510
so just one slide for the summary and so

00:19:46,680 --> 00:19:50,010
algorithms are there and they are

00:19:48,510 --> 00:19:52,200
implemented especially in the normal

00:19:50,010 --> 00:19:53,910
source so much but it's important to be

00:19:52,200 --> 00:19:55,770
able to customize them you have to see

00:19:53,910 --> 00:19:57,870
where where do I get my data from where

00:19:55,770 --> 00:20:00,360
do we get multi-word terms from can I do

00:19:57,870 --> 00:20:04,470
this decisions that I mentioned before

00:20:00,360 --> 00:20:05,850
and yeah these these usability decisions

00:20:04,470 --> 00:20:08,300
in the beginning they depend on the

00:20:05,850 --> 00:20:13,080
project and taste and and so on and

00:20:08,300 --> 00:20:15,260
again also here data is the key so where

00:20:13,080 --> 00:20:18,660
do you get valid searches from

00:20:15,260 --> 00:20:21,300
multi-term searches from good things

00:20:18,660 --> 00:20:23,310
search locks so searches that users have

00:20:21,300 --> 00:20:25,050
done and that deliver results if you are

00:20:23,310 --> 00:20:27,240
Google you can maybe just rely on that

00:20:25,050 --> 00:20:29,790
otherwise you have to come up with other

00:20:27,240 --> 00:20:31,650
sources co-occurrence in the index may

00:20:29,790 --> 00:20:33,510
be something there's a very suggestion

00:20:31,650 --> 00:20:36,750
elastic search that's exactly that and

00:20:33,510 --> 00:20:38,220
but it takes a lot of space and you

00:20:36,750 --> 00:20:40,590
could imagine to do part of speech

00:20:38,220 --> 00:20:43,980
tagging and then extract some patterns

00:20:40,590 --> 00:20:45,660
like article adjective adjective now and

00:20:43,980 --> 00:20:48,360
subject this way okay this is the term

00:20:45,660 --> 00:20:50,850
that's that's useful but it's expensive

00:20:48,360 --> 00:20:54,420
to in indexing it will slow down your

00:20:50,850 --> 00:20:57,270
indexing of full text for example and or

00:20:54,420 --> 00:21:00,360
you can look around in your project

00:20:57,270 --> 00:21:01,800
there are some cheaper sources like if

00:21:00,360 --> 00:21:04,440
you index people you have an address

00:21:01,800 --> 00:21:06,540
book you can put first name last name

00:21:04,440 --> 00:21:08,280
into your bit you mean dictionary

00:21:06,540 --> 00:21:09,840
because you can easily get them from

00:21:08,280 --> 00:21:14,690
your LDAP or something like this you can

00:21:09,840 --> 00:21:17,790
collect your sources of senseful queries

00:21:14,690 --> 00:21:18,420
yeah that's basically all for an

00:21:17,790 --> 00:21:22,350
introduction

00:21:18,420 --> 00:21:24,050
if there are any questions ok so thanks

00:21:22,350 --> 00:21:26,010
mark

00:21:24,050 --> 00:21:29,429
ok

00:21:26,010 --> 00:21:31,830
so if you have some question you can now

00:21:29,429 --> 00:21:40,770
he has commitment you have some

00:21:31,830 --> 00:21:44,910
questions understand okay the question

00:21:40,770 --> 00:21:47,010
if you do an index based solution have

00:21:44,910 --> 00:21:49,200
you ever tried to to make that your only

00:21:47,010 --> 00:21:51,780
index and basically always just do did

00:21:49,200 --> 00:21:54,530
you mean and your normal search result

00:21:51,780 --> 00:21:57,690
would be the zero-distance case and

00:21:54,530 --> 00:21:59,730
justice in one indexing and I mean this

00:21:57,690 --> 00:22:01,260
this in place thing like running through

00:21:59,730 --> 00:22:03,179
the list or with an ultimatum that's

00:22:01,260 --> 00:22:05,190
basically there you have just one index

00:22:03,179 --> 00:22:08,100
I was always wondering if you killed for

00:22:05,190 --> 00:22:09,960
the Engram case and then only search by

00:22:08,100 --> 00:22:13,440
Ingram for your nominal I've never done

00:22:09,960 --> 00:22:16,549
that so doing the regular search in this

00:22:13,440 --> 00:22:22,860
end web dictionary I haven't done it no

00:22:16,549 --> 00:22:25,380
other question mmm one of the last

00:22:22,860 --> 00:22:28,799
slides you showed it your search free on

00:22:25,380 --> 00:22:30,960
the Ingram index so which query part I

00:22:28,799 --> 00:22:34,530
have you been using so which I don't

00:22:30,960 --> 00:22:37,140
know the syntax or curious and I did it

00:22:34,530 --> 00:22:38,940
programmatically with Allison in it so

00:22:37,140 --> 00:22:41,309
not it's not solid it's not that is

00:22:38,940 --> 00:22:44,130
syntax but it's programmatically built

00:22:41,309 --> 00:22:46,830
and carry so they're just using the

00:22:44,130 --> 00:22:48,960
little C in Java API okay you can do it

00:22:46,830 --> 00:22:51,270
with that and then this is little

00:22:48,960 --> 00:22:53,520
smallest it's not exactly but it's kind

00:22:51,270 --> 00:22:56,580
of the format that you give if you print

00:22:53,520 --> 00:22:59,460
this big up career like with system out

00:22:56,580 --> 00:23:01,410
here so if if you print it together you

00:22:59,460 --> 00:23:03,510
get a syntax that you can add any

00:23:01,410 --> 00:23:05,549
anywhere I think and but you get a

00:23:03,510 --> 00:23:07,350
impression but this is only pewter code

00:23:05,549 --> 00:23:09,600
it's not exactly what you get if you

00:23:07,350 --> 00:23:12,240
printed out but the capabilities are

00:23:09,600 --> 00:23:17,260
there in the scene yeah okay thank you

00:23:12,240 --> 00:23:22,400
okay thank you

00:23:17,260 --> 00:23:22,400

YouTube URL: https://www.youtube.com/watch?v=aYg506sqHRs


