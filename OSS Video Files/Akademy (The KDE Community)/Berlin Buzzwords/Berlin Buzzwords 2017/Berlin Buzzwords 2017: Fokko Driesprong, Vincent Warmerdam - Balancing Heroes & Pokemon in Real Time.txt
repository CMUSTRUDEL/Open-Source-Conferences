Title: Berlin Buzzwords 2017: Fokko Driesprong, Vincent Warmerdam - Balancing Heroes & Pokemon in Real Time
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	In this talk we will demonstrate a matchmaking system for online video games that needs to work in a streaming setting. In particular we will demonstrate a solution to the following problems; 

- How can you estimate the skill of a video game player in an online setting? Note that this needs to work for one vs. one player games as well as games with a team setting. 

- Given these skill estimations, how can you match them such that each player is always playing against a similar skill leven and doesn't need to wait very long. Note that this needs to work in a distributed session as well. 

To demonstrate an easy setting we will demonstrate how we are able to rank Pokemon in one vs. one matches. To demonstrate a harder setting we will streaming game logs from heroes of the storm into our algorithm to show how it works. The stack we use is Apache Flink together with ElasticSearch and Kibana. We intend to demonstrate a solution to this problem both on an engineering perspective as well as a machine learning perspective. 

Read more:
https://2017.berlinbuzzwords.de/17/session/balancing-heroes-and-pokemon-real-time-streaming-variant-trueskill-online-ranking

About Fokko Driesprong:
https://2017.berlinbuzzwords.de/users/fokko-driesprong

About Vincent Warmerdam:
https://2017.berlinbuzzwords.de/users/vincent-warmerdam

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,340 --> 00:00:10,420
my name is Vincent and this is my dear

00:00:07,840 --> 00:00:11,530
colleague Foucault before we actually

00:00:10,420 --> 00:00:12,700
talk about the thing we want to talk

00:00:11,530 --> 00:00:14,890
about there's a couple of things we have

00:00:12,700 --> 00:00:16,510
to do for example we have to really make

00:00:14,890 --> 00:00:18,369
sure that you guys understand that we do

00:00:16,510 --> 00:00:19,420
not work for Blizzard you guys also have

00:00:18,369 --> 00:00:21,189
to understand that we do not work for

00:00:19,420 --> 00:00:22,090
Nintendo and you guys also have to

00:00:21,189 --> 00:00:24,790
understand that we do not work for

00:00:22,090 --> 00:00:26,650
Microsoft I used the words to scale in

00:00:24,790 --> 00:00:28,509
our title and to scale is a licensed

00:00:26,650 --> 00:00:30,730
algorithm and I'm not intent on finding

00:00:28,509 --> 00:00:31,810
out what that legally means so we don't

00:00:30,730 --> 00:00:34,510
work for Blizzard we don't work for a

00:00:31,810 --> 00:00:35,829
Nintendo we don't work for Microsoft I'm

00:00:34,510 --> 00:00:38,080
an algorithms guy Ã©poca was an

00:00:35,829 --> 00:00:39,490
engineering guy and we built a small

00:00:38,080 --> 00:00:40,390
hobby project together it is not

00:00:39,490 --> 00:00:41,560
something that really goes into

00:00:40,390 --> 00:00:43,270
production but we have some interesting

00:00:41,560 --> 00:00:46,090
lessons here and this project basically

00:00:43,270 --> 00:00:47,500
started as a mere nerd snack the main

00:00:46,090 --> 00:00:49,270
point I hope to get across to you today

00:00:47,500 --> 00:00:50,710
though is we're going to talk a bit

00:00:49,270 --> 00:00:52,420
about how machine learning is applied in

00:00:50,710 --> 00:00:54,100
sort of a lambda setting in kind of a

00:00:52,420 --> 00:00:55,390
streaming setting because why typically

00:00:54,100 --> 00:00:57,700
we have a machine learning algorithm

00:00:55,390 --> 00:00:59,020
like you see here I will call this some

00:00:57,700 --> 00:01:01,180
sort of function because most machine

00:00:59,020 --> 00:01:02,920
learning methods that have been trained

00:01:01,180 --> 00:01:04,720
can be seen as a lambda function and

00:01:02,920 --> 00:01:06,490
every time an event comes by we apply

00:01:04,720 --> 00:01:08,979
the machine learning function probably

00:01:06,490 --> 00:01:10,840
does predict some sort of tag and as

00:01:08,979 --> 00:01:12,490
these events come streaming in we apply

00:01:10,840 --> 00:01:14,049
the function and this is how usually

00:01:12,490 --> 00:01:15,249
things are brought to production and

00:01:14,049 --> 00:01:17,350
we're going to talk about today in

00:01:15,249 --> 00:01:18,759
particular is a situation where every

00:01:17,350 --> 00:01:21,039
point of data that the machine learning

00:01:18,759 --> 00:01:24,429
algorithm come gets will also allow the

00:01:21,039 --> 00:01:26,079
function to update so in the second

00:01:24,429 --> 00:01:27,670
situation the function changes for every

00:01:26,079 --> 00:01:28,929
single data point we see and this

00:01:27,670 --> 00:01:30,340
actually means that not only can we

00:01:28,929 --> 00:01:32,170
apply a machine learning function in

00:01:30,340 --> 00:01:34,899
streaming we can actually learn from it

00:01:32,170 --> 00:01:36,490
in streaming and because it's Berlin and

00:01:34,899 --> 00:01:38,289
you know flink people are here I don't

00:01:36,490 --> 00:01:39,369
think I have to explain to this group

00:01:38,289 --> 00:01:42,100
that streaming may actually be

00:01:39,369 --> 00:01:43,179
preferable because thinking about it if

00:01:42,100 --> 00:01:44,709
you can solve machine learning in a

00:01:43,179 --> 00:01:48,009
streaming setting that means you've also

00:01:44,709 --> 00:01:49,600
solved it in batch and we'll present a

00:01:48,009 --> 00:01:50,679
couple of general things where it's

00:01:49,600 --> 00:01:53,319
actually not too hard to apply this

00:01:50,679 --> 00:01:55,719
stuff so let's talk about an enterprise

00:01:53,319 --> 00:01:57,490
use case now this is our enterprise use

00:01:55,719 --> 00:01:58,840
case let's say we'll pretend that we're

00:01:57,490 --> 00:02:00,549
some sort of video game company and

00:01:58,840 --> 00:02:03,039
there's some queue if people really want

00:02:00,549 --> 00:02:04,149
to go and play these video games now

00:02:03,039 --> 00:02:05,770
there's a couple of things that

00:02:04,149 --> 00:02:07,990
immediately become a bit of a problem

00:02:05,770 --> 00:02:09,550
because you want these players to play

00:02:07,990 --> 00:02:11,770
against people that have the same skill

00:02:09,550 --> 00:02:13,180
if you are a super noob and the other

00:02:11,770 --> 00:02:15,370
guy that you're battling against is

00:02:13,180 --> 00:02:17,650
super awesome and great you're both

00:02:15,370 --> 00:02:19,450
going to have a bad time

00:02:17,650 --> 00:02:21,880
and we can only learn this from sort of

00:02:19,450 --> 00:02:23,710
a stream of mass outcomes so whatever we

00:02:21,880 --> 00:02:25,450
learn comes from events that say this

00:02:23,710 --> 00:02:27,220
player battled that player and this

00:02:25,450 --> 00:02:28,720
player was the winner and from this we

00:02:27,220 --> 00:02:30,430
have to get an impression for the skill

00:02:28,720 --> 00:02:32,800
is like such as we can maybe do some

00:02:30,430 --> 00:02:33,970
sort of matching and I hope that it's

00:02:32,800 --> 00:02:35,950
also kind of clear that will be

00:02:33,970 --> 00:02:37,090
definitely before a preferable if this

00:02:35,950 --> 00:02:38,709
works in some sort of a streaming

00:02:37,090 --> 00:02:40,840
setting and not so much in a batch

00:02:38,709 --> 00:02:43,209
setting preferably after every single

00:02:40,840 --> 00:02:44,500
game has been played the disbelief of

00:02:43,209 --> 00:02:48,970
the skill of both players will have been

00:02:44,500 --> 00:02:50,680
updated so let's talk about some

00:02:48,970 --> 00:02:54,010
thoughts that may allow us to think

00:02:50,680 --> 00:02:55,180
about a proper solution one thing you

00:02:54,010 --> 00:02:56,350
might want to do when you try to

00:02:55,180 --> 00:02:58,150
estimate the skill of the players you

00:02:56,350 --> 00:03:00,489
want to quantify that into a number so

00:02:58,150 --> 00:03:01,900
let's say a number between 0 & 1 people

00:03:00,489 --> 00:03:03,459
that are very bad you would push towards

00:03:01,900 --> 00:03:04,690
a 0 in the dispatch room people that are

00:03:03,459 --> 00:03:07,630
super good you'd push to the 1 in the

00:03:04,690 --> 00:03:09,190
despair and a common flaw I guess that

00:03:07,630 --> 00:03:10,750
you could say is that you really see

00:03:09,190 --> 00:03:12,820
this as a single number as you want to

00:03:10,750 --> 00:03:14,350
estimate it might actually be more

00:03:12,820 --> 00:03:16,360
useful that instead of your state being

00:03:14,350 --> 00:03:17,980
a single number that describes what the

00:03:16,360 --> 00:03:19,750
skill of a user is you actually keep

00:03:17,980 --> 00:03:22,570
track of the distribution of belief

00:03:19,750 --> 00:03:24,190
instead the idea is for example the blue

00:03:22,570 --> 00:03:26,260
player here that smack dab in the middle

00:03:24,190 --> 00:03:28,870
might be a player that only played one

00:03:26,260 --> 00:03:29,920
game in the entire lifetime that means

00:03:28,870 --> 00:03:31,810
that we might have an estimation of

00:03:29,920 --> 00:03:33,370
skill but there's a lot of noise around

00:03:31,810 --> 00:03:34,420
it we're not super sure what the skill

00:03:33,370 --> 00:03:36,420
this player is because they simply

00:03:34,420 --> 00:03:38,260
haven't seen as many games of it yet

00:03:36,420 --> 00:03:39,640
whereas for the green player in this

00:03:38,260 --> 00:03:41,620
case because it's a very peak

00:03:39,640 --> 00:03:43,200
distribution we're actually quite sure

00:03:41,620 --> 00:03:45,579
that it is this skill of this one player

00:03:43,200 --> 00:03:47,500
what I will argue is a keeping track of

00:03:45,579 --> 00:03:49,480
the skill as a distribution will allow

00:03:47,500 --> 00:03:50,980
us to do learning and streaming because

00:03:49,480 --> 00:03:52,600
the idea is we'll just update to the

00:03:50,980 --> 00:03:57,370
distribution instead of just updating

00:03:52,600 --> 00:03:59,380
this one single number so let's actually

00:03:57,370 --> 00:04:00,459
think about it this way and let's see

00:03:59,380 --> 00:04:02,620
what happens if we have two players

00:04:00,459 --> 00:04:04,299
@badlayouts against each other so here's

00:04:02,620 --> 00:04:06,310
a distribution for player 1 here's the

00:04:04,299 --> 00:04:07,900
distribution for player 2 this is a

00:04:06,310 --> 00:04:09,910
distribution of skill for both players

00:04:07,900 --> 00:04:11,320
separately what you could do is you can

00:04:09,910 --> 00:04:13,060
say instead of having two separate

00:04:11,320 --> 00:04:14,950
one-dimensional distributions of the

00:04:13,060 --> 00:04:17,979
where the skill might be we can also

00:04:14,950 --> 00:04:19,239
combine those you know very bluntly it's

00:04:17,979 --> 00:04:21,640
like we can also say we have one

00:04:19,239 --> 00:04:23,650
distribution that's two-dimensional this

00:04:21,640 --> 00:04:25,330
is the belief of one player and where

00:04:23,650 --> 00:04:27,810
the skill might be this is the belief

00:04:25,330 --> 00:04:30,100
where the skill of both players might be

00:04:27,810 --> 00:04:33,790
just like a 3d histogram that

00:04:30,100 --> 00:04:35,530
throughout the idea that is if then a

00:04:33,790 --> 00:04:37,270
game happens and one player one and the

00:04:35,530 --> 00:04:39,070
other one lost you can basically say

00:04:37,270 --> 00:04:40,690
whatever is on the raw so ever there's

00:04:39,070 --> 00:04:42,490
probability mass where we just saw it

00:04:40,690 --> 00:04:45,250
shouldn't be likely we just cut all the

00:04:42,490 --> 00:04:47,320
probability mass away so for example we

00:04:45,250 --> 00:04:48,730
have a diagonal line is player one wins

00:04:47,320 --> 00:04:50,500
then this side should be more likely

00:04:48,730 --> 00:04:52,690
than that side hence we can remove

00:04:50,500 --> 00:04:54,910
probability mass here the same thing we

00:04:52,690 --> 00:04:57,370
can do for player two and you know if

00:04:54,910 --> 00:04:59,080
we're thinking about it and apply some

00:04:57,370 --> 00:05:00,640
sort of nice little margin we can also

00:04:59,080 --> 00:05:02,350
accommodate for draws because the draw

00:05:00,640 --> 00:05:04,900
will basically say hey these players

00:05:02,350 --> 00:05:06,760
might actually have the same skill the

00:05:04,900 --> 00:05:09,100
idea behind this is that we first have a

00:05:06,760 --> 00:05:10,600
prior then we measure the game outcome

00:05:09,100 --> 00:05:11,860
we have some sort of two dimensional

00:05:10,600 --> 00:05:13,090
likelihood and the only thing we then

00:05:11,860 --> 00:05:15,670
need to do is map it back to a one

00:05:13,090 --> 00:05:17,470
dimensional likelihood so what we hope

00:05:15,670 --> 00:05:19,270
is that then something like this will

00:05:17,470 --> 00:05:20,890
happen where if this player wins this

00:05:19,270 --> 00:05:21,580
player skill is couch to the right which

00:05:20,890 --> 00:05:23,410
is what we want

00:05:21,580 --> 00:05:26,590
this one was couch to the left and vice

00:05:23,410 --> 00:05:27,970
versa if the other player wins and I go

00:05:26,590 --> 00:05:30,310
and again I hope it becomes fairly

00:05:27,970 --> 00:05:31,630
obvious in this particular example we

00:05:30,310 --> 00:05:33,100
couldn't do this if we just kept track

00:05:31,630 --> 00:05:34,450
of one single number the fact that we

00:05:33,100 --> 00:05:36,250
were keeping track of a distribution

00:05:34,450 --> 00:05:39,820
allows us to be able to update the

00:05:36,250 --> 00:05:41,590
distribution of skill now these are sort

00:05:39,820 --> 00:05:43,330
of I hope that you agree very pretty

00:05:41,590 --> 00:05:44,380
pictures but if you don't to turn this

00:05:43,330 --> 00:05:46,810
into an algorithm you have to do some

00:05:44,380 --> 00:05:47,800
prototyping if you go to my blog you'll

00:05:46,810 --> 00:05:48,910
actually have an interactive version

00:05:47,800 --> 00:05:50,440
where you could go ahead and play with

00:05:48,910 --> 00:05:52,120
this but I figured let's just do this

00:05:50,440 --> 00:05:54,550
very bluntly with a small R script and

00:05:52,120 --> 00:05:56,680
what you see here is just some random

00:05:54,550 --> 00:05:58,630
data so the distribution of skill that I

00:05:56,680 --> 00:06:00,190
have is some sort of histogram I'll

00:05:58,630 --> 00:06:01,510
pretend that if I've never seen a player

00:06:00,190 --> 00:06:03,160
before that this is sort of the prior

00:06:01,510 --> 00:06:04,690
that I might have of the player and

00:06:03,160 --> 00:06:06,580
again this is all a simulation exercise

00:06:04,690 --> 00:06:08,950
I'm not doing any math quite yet but I'm

00:06:06,580 --> 00:06:11,260
just saying this is a distribution of

00:06:08,950 --> 00:06:13,210
two players that I've just sampled if I

00:06:11,260 --> 00:06:14,890
then remove all the mass here again I'm

00:06:13,210 --> 00:06:16,510
keeping some sort of margin in mind and

00:06:14,890 --> 00:06:18,340
then you automatically see that these

00:06:16,510 --> 00:06:20,830
two distribution shift accordingly just

00:06:18,340 --> 00:06:22,450
the way that I kind of want it is more

00:06:20,830 --> 00:06:24,160
likely that this player is better than

00:06:22,450 --> 00:06:27,430
that player and that map's back into

00:06:24,160 --> 00:06:28,600
these single distributions so again to

00:06:27,430 --> 00:06:30,580
put all the steps in perspective we

00:06:28,600 --> 00:06:32,500
start up with these two priors we put

00:06:30,580 --> 00:06:34,480
that into a two dimensional prior then

00:06:32,500 --> 00:06:36,520
either this player wins or that player

00:06:34,480 --> 00:06:37,840
wins we remove the mass accordingly and

00:06:36,520 --> 00:06:40,300
then map it back into a one dimensional

00:06:37,840 --> 00:06:41,950
distribution there's some normalizations

00:06:40,300 --> 00:06:43,449
and stuff that I'm also doing but the

00:06:41,950 --> 00:06:45,669
idea is it's an update of our

00:06:43,449 --> 00:06:47,529
distribution some of the stuff you

00:06:45,669 --> 00:06:48,999
actually get for free and again this is

00:06:47,529 --> 00:06:50,680
not math I added in this is just what

00:06:48,999 --> 00:06:52,389
happens if you simulate this you can

00:06:50,680 --> 00:06:53,710
also simulate a situation where one of

00:06:52,389 --> 00:06:54,490
the players is actually a bit better

00:06:53,710 --> 00:06:56,379
than the other

00:06:54,490 --> 00:06:57,819
for example this might be a player where

00:06:56,379 --> 00:06:59,710
we've seen that we've seen played a

00:06:57,819 --> 00:07:01,029
bunch of games and this is a player that

00:06:59,710 --> 00:07:02,979
we haven't seen play a lot of games yet

00:07:01,029 --> 00:07:04,830
this distributions been more pinky and

00:07:02,979 --> 00:07:06,759
we think that this player should win

00:07:04,830 --> 00:07:09,039
what then happens is in a situation

00:07:06,759 --> 00:07:10,449
where this bad player just beat this

00:07:09,039 --> 00:07:12,969
good player that gives us more

00:07:10,449 --> 00:07:15,430
information the update from here to here

00:07:12,969 --> 00:07:17,139
is larger and then in the previous

00:07:15,430 --> 00:07:19,419
situation where this shift of the

00:07:17,139 --> 00:07:20,889
distribution was smaller and if you

00:07:19,419 --> 00:07:23,169
think about this in vs. also makes sense

00:07:20,889 --> 00:07:24,789
if you are super new and you just beat

00:07:23,169 --> 00:07:26,650
one of the best guys out there then

00:07:24,789 --> 00:07:27,729
probably you are very good it's probably

00:07:26,650 --> 00:07:29,110
not due the chance that you beat this

00:07:27,729 --> 00:07:31,529
guy and that means that we can give a

00:07:29,110 --> 00:07:33,159
bigger shift to the updater we're doing

00:07:31,529 --> 00:07:35,710
conversely what you will also

00:07:33,159 --> 00:07:37,120
automatically see is if I just if this

00:07:35,710 --> 00:07:37,749
person lost from someone that's supposed

00:07:37,120 --> 00:07:41,139
to be good

00:07:37,749 --> 00:07:43,449
we don't really update the prior as much

00:07:41,139 --> 00:07:45,009
simply because what we believed before

00:07:43,449 --> 00:07:50,560
the match has been confirmed by the

00:07:45,009 --> 00:07:52,060
match what you can then do if you prove

00:07:50,560 --> 00:07:53,349
that this indeed works in simulation

00:07:52,060 --> 00:07:54,580
settings you will then do another

00:07:53,349 --> 00:07:56,379
simulation where you actually try to

00:07:54,580 --> 00:07:57,849
simulate lots of different users and the

00:07:56,379 --> 00:07:59,319
way that I did this I basically said

00:07:57,849 --> 00:08:02,529
look there's a couple of users between

00:07:59,319 --> 00:08:04,389
user 0 and this user 100 user zero is

00:08:02,529 --> 00:08:05,830
the worst player user 100 is the best

00:08:04,389 --> 00:08:06,999
player and I just have these people play

00:08:05,830 --> 00:08:08,379
it out randomly and see if this

00:08:06,999 --> 00:08:10,959
algorithm performs in sort of a real

00:08:08,379 --> 00:08:12,580
life simulation example what you see on

00:08:10,959 --> 00:08:14,800
the x-axis here is the actual skill of

00:08:12,580 --> 00:08:16,270
the player and here is sort of the the

00:08:14,800 --> 00:08:18,129
most likely area where I believe the

00:08:16,270 --> 00:08:20,080
player to be and this I believe the

00:08:18,129 --> 00:08:22,060
first two charts that you see are for

00:08:20,080 --> 00:08:24,849
400 iterations it is I believe it's for

00:08:22,060 --> 00:08:27,909
1,000 iterations this is the most likely

00:08:24,849 --> 00:08:30,039
peak of the distribution given the true

00:08:27,909 --> 00:08:32,289
skill level and this is the histogram

00:08:30,039 --> 00:08:34,120
that's supposed to be attached to every

00:08:32,289 --> 00:08:35,709
single user here and one thing you see

00:08:34,120 --> 00:08:37,029
which is what we kind of like is it

00:08:35,709 --> 00:08:38,649
converges to the true distribution that

00:08:37,029 --> 00:08:40,329
we're interested in what we can also see

00:08:38,649 --> 00:08:42,550
is these distributions converge they

00:08:40,329 --> 00:08:43,959
become more peaky there is more still a

00:08:42,550 --> 00:08:45,790
little bit uncertainty for every player

00:08:43,959 --> 00:08:46,959
here in terms of skill but we do get

00:08:45,790 --> 00:08:48,579
this nice property that every game

00:08:46,959 --> 00:08:54,610
that's being played we do get a nice

00:08:48,579 --> 00:08:56,140
more spiky peak now of course okay I did

00:08:54,610 --> 00:08:57,310
this on the simulated data set now let's

00:08:56,140 --> 00:08:59,110
just see if I can apply to it

00:08:57,310 --> 00:09:01,660
data set and is where the Pokemon come

00:08:59,110 --> 00:09:03,610
that kind of comes in so the goal is we

00:09:01,660 --> 00:09:04,840
we want all these Pokemon the battle out

00:09:03,610 --> 00:09:06,130
to each other and let's pretend we're

00:09:04,840 --> 00:09:07,750
interested in finding out what the best

00:09:06,130 --> 00:09:09,010
pokemon is and what the worst pokemon is

00:09:07,750 --> 00:09:10,240
and we're going to do is we're going to

00:09:09,010 --> 00:09:11,590
be very scientific so we're going to

00:09:10,240 --> 00:09:15,100
test this algorithm that I just proved

00:09:11,590 --> 00:09:16,660
kind of works you know how do you do

00:09:15,100 --> 00:09:19,270
that well there's this website it's

00:09:16,660 --> 00:09:21,190
called poke API Co everyone knows this

00:09:19,270 --> 00:09:22,390
website you can scrape the website but

00:09:21,190 --> 00:09:23,950
nowadays actually easy to just go to

00:09:22,390 --> 00:09:25,750
kaggle because you could do the scraping

00:09:23,950 --> 00:09:27,490
and all the JSON parsing yourself or you

00:09:25,750 --> 00:09:29,200
just download the data set from kaggle

00:09:27,490 --> 00:09:30,730
well if this data set you can then go to

00:09:29,200 --> 00:09:33,270
fan websites where you can actually get

00:09:30,730 --> 00:09:35,410
the formula how the videogame of pokemon

00:09:33,270 --> 00:09:37,089
science damage from one Pokemon to the

00:09:35,410 --> 00:09:38,320
other again all this is sort of

00:09:37,089 --> 00:09:39,520
arbitrary it's in the slides but the

00:09:38,320 --> 00:09:40,870
main thing that I want to point out here

00:09:39,520 --> 00:09:42,160
is I can actually simulate match

00:09:40,870 --> 00:09:44,320
outcomes with a bit of assumptions in

00:09:42,160 --> 00:09:45,670
this basically what I do is I calculate

00:09:44,320 --> 00:09:47,200
the number of turns one pokemon with

00:09:45,670 --> 00:09:49,779
outlast the other with basic attacks and

00:09:47,200 --> 00:09:51,550
this feels like a genuinely ok-ish first

00:09:49,779 --> 00:09:55,180
order approach to see if this eyewear

00:09:51,550 --> 00:09:56,560
them works this is what we then get and

00:09:55,180 --> 00:09:58,060
again I play this tons and tons and tons

00:09:56,560 --> 00:10:00,160
of times and one of the things that I

00:09:58,060 --> 00:10:01,660
kind of like is that the algorithm

00:10:00,160 --> 00:10:03,550
automatically sort of homogeneously

00:10:01,660 --> 00:10:05,140
distributed skill of all players is that

00:10:03,550 --> 00:10:07,210
like all the players are on this side or

00:10:05,140 --> 00:10:08,350
on that side the algorithm automatically

00:10:07,210 --> 00:10:10,030
tries to map all the players between

00:10:08,350 --> 00:10:12,630
zero and one and also in sort of a

00:10:10,030 --> 00:10:15,040
linear way that it's spread out evenly

00:10:12,630 --> 00:10:16,540
if you're then interested then what my

00:10:15,040 --> 00:10:18,070
algorithm says is that magikarp is

00:10:16,540 --> 00:10:19,750
indeed the worst pokemon out there and

00:10:18,070 --> 00:10:21,670
that Mewtwo is actually one of the

00:10:19,750 --> 00:10:26,710
Pokemon that's supposed to be better so

00:10:21,670 --> 00:10:28,270
yeah scientific proof I guess I'm happy

00:10:26,710 --> 00:10:30,339
to see that you guys may have to laugh

00:10:28,270 --> 00:10:33,280
about this as well I I also thought this

00:10:30,339 --> 00:10:34,720
research was hilarious anyway and we've

00:10:33,280 --> 00:10:36,610
done Magikarp we've done Mewtwo there's

00:10:34,720 --> 00:10:38,110
all this fun and we have a nice little

00:10:36,610 --> 00:10:40,150
algorithm that kind of works but let's

00:10:38,110 --> 00:10:41,770
take a step back and check what this

00:10:40,150 --> 00:10:44,230
means because there is a general massed

00:10:41,770 --> 00:10:45,280
everything I've just shown you designing

00:10:44,230 --> 00:10:46,660
algorithms became a whole lot easier

00:10:45,280 --> 00:10:47,770
when we admitted that we didn't want to

00:10:46,660 --> 00:10:48,970
quantity that we didn't just want to

00:10:47,770 --> 00:10:50,709
have like the maximum likelihood the

00:10:48,970 --> 00:10:52,600
skill we actually wanted to quantify the

00:10:50,709 --> 00:10:54,339
uncertainty as well this means that the

00:10:52,600 --> 00:10:55,870
state we keep track of for player is a

00:10:54,339 --> 00:10:58,480
distribution of State and not just the

00:10:55,870 --> 00:11:00,370
mere statistic to put that in formula

00:10:58,480 --> 00:11:01,450
basically what we're doing is we're just

00:11:00,370 --> 00:11:03,310
applying Bayes rule

00:11:01,450 --> 00:11:04,510
the idea behind Bayes rule is we have

00:11:03,310 --> 00:11:06,070
some sort of parameter we want to

00:11:04,510 --> 00:11:07,990
estimate based on the data that we see

00:11:06,070 --> 00:11:10,060
in this case this is just a distribution

00:11:07,990 --> 00:11:12,280
of the skill that we have

00:11:10,060 --> 00:11:14,800
and what bays we will basically say is

00:11:12,280 --> 00:11:17,350
that we have some sort of prior and then

00:11:14,800 --> 00:11:19,540
basically we have an update probability

00:11:17,350 --> 00:11:21,130
for every data point that we see in

00:11:19,540 --> 00:11:24,700
situation before this update was the

00:11:21,130 --> 00:11:26,680
cutting of the two-dimensional prior if

00:11:24,700 --> 00:11:28,630
you write this out and let's say we take

00:11:26,680 --> 00:11:29,800
a very simple example where there's only

00:11:28,630 --> 00:11:32,020
a situation where we have three data

00:11:29,800 --> 00:11:34,570
points we take this formula and we write

00:11:32,020 --> 00:11:38,050
it out a pattern emerges because you can

00:11:34,570 --> 00:11:39,670
basically say if I only saw the first

00:11:38,050 --> 00:11:42,490
data point and I have to estimate the

00:11:39,670 --> 00:11:44,380
skill for the data point of two this is

00:11:42,490 --> 00:11:46,480
the prior before we see the second data

00:11:44,380 --> 00:11:47,620
point we do the same thing for the

00:11:46,480 --> 00:11:49,330
second data point and all of these

00:11:47,620 --> 00:11:52,060
things together become the prior for the

00:11:49,330 --> 00:11:54,040
third data point we can rewrite this

00:11:52,060 --> 00:11:55,780
again and then what you get is this nice

00:11:54,040 --> 00:11:57,250
little recursive relationship that

00:11:55,780 --> 00:11:58,930
basically says we have some sort of

00:11:57,250 --> 00:12:00,700
prior before a new data point gets in

00:11:58,930 --> 00:12:01,720
and then when we see a new data point we

00:12:00,700 --> 00:12:03,520
just make have to make sure that

00:12:01,720 --> 00:12:07,960
probablistic aliy we have an update rule

00:12:03,520 --> 00:12:09,970
that makes sense and this is a situation

00:12:07,960 --> 00:12:11,620
where in this case the parameters here

00:12:09,970 --> 00:12:13,000
are sort of static you can take an extra

00:12:11,620 --> 00:12:14,320
step by saying look these parameters

00:12:13,000 --> 00:12:16,840
might also be able to change over time

00:12:14,320 --> 00:12:18,820
oh let's just do a bit of sloppy math

00:12:16,840 --> 00:12:20,200
and say we sort of do this to the

00:12:18,820 --> 00:12:21,700
exponent of alpha this the exponent of

00:12:20,200 --> 00:12:22,180
beta we still through some sort of grid

00:12:21,700 --> 00:12:23,620
search

00:12:22,180 --> 00:12:25,420
but whatever algorithm that you have

00:12:23,620 --> 00:12:27,640
that sort of fits this it's

00:12:25,420 --> 00:12:29,560
automatically a streaming algorithm for

00:12:27,640 --> 00:12:33,040
free and that's what makes Bayesian

00:12:29,560 --> 00:12:34,480
machine learning so awesome in our

00:12:33,040 --> 00:12:35,650
example of course we're still interested

00:12:34,480 --> 00:12:37,600
in dealing with the histogram of skill

00:12:35,650 --> 00:12:40,120
but anything that's Galan has kind of a

00:12:37,600 --> 00:12:41,290
closed form solution and a thing for a

00:12:40,120 --> 00:12:46,960
lot of these things so you can actually

00:12:41,290 --> 00:12:49,930
do linear regression this way as well so

00:12:46,960 --> 00:12:51,700
in fact this is a general rule and I

00:12:49,930 --> 00:12:55,360
hope that I've just made clear we just

00:12:51,700 --> 00:12:56,920
gave an example of exactly this we're

00:12:55,360 --> 00:12:58,090
not done that we're not really done yet

00:12:56,920 --> 00:12:59,320
though because obviously I promised the

00:12:58,090 --> 00:13:00,850
second video game that we would do as

00:12:59,320 --> 00:13:03,310
well and this is a video game that's

00:13:00,850 --> 00:13:06,520
even more an enterprise situation who of

00:13:03,310 --> 00:13:08,470
you has played this game yeah you guys

00:13:06,520 --> 00:13:09,760
are liars this is an Internet so if this

00:13:08,470 --> 00:13:10,960
is a hacker conference and I don't

00:13:09,760 --> 00:13:11,440
believe the only three people play this

00:13:10,960 --> 00:13:13,360
video game

00:13:11,440 --> 00:13:15,100
this is heroes of the storm so if you've

00:13:13,360 --> 00:13:17,860
played blizzard games alright people

00:13:15,100 --> 00:13:20,650
have said that yeah yeah good people are

00:13:17,860 --> 00:13:22,180
admitting so the idea is in the Pokemon

00:13:20,650 --> 00:13:23,830
situation that we just had before it's

00:13:22,180 --> 00:13:25,360
always in one for just one game

00:13:23,830 --> 00:13:27,040
but in this situation things are a

00:13:25,360 --> 00:13:29,470
little bit different because this was

00:13:27,040 --> 00:13:31,090
the enterprise situation before but it

00:13:29,470 --> 00:13:32,920
now changes because now people will say

00:13:31,090 --> 00:13:35,140
hey I want to play a certain character

00:13:32,920 --> 00:13:37,570
they then get into a queue and then have

00:13:35,140 --> 00:13:40,390
to be matched up until a team and both

00:13:37,570 --> 00:13:41,860
from sort of this sort of an engineering

00:13:40,390 --> 00:13:43,870
as well as a machine learning

00:13:41,860 --> 00:13:44,980
perspective this changes a few things

00:13:43,870 --> 00:13:46,690
and actually makes a problem a whole lot

00:13:44,980 --> 00:13:48,940
harder because we need to update player

00:13:46,690 --> 00:13:50,440
skills after a team match that's

00:13:48,940 --> 00:13:51,670
different than just being able to say I

00:13:50,440 --> 00:13:54,460
have two players that need to be updated

00:13:51,670 --> 00:13:55,990
we also need to assign players in a team

00:13:54,460 --> 00:13:58,030
as well so we want to say these people

00:13:55,990 --> 00:13:59,620
have the same skill there's some sort of

00:13:58,030 --> 00:14:01,060
cueing system that ensures that whenever

00:13:59,620 --> 00:14:03,490
our game is started you're playing with

00:14:01,060 --> 00:14:04,990
the same skill we also need to worry

00:14:03,490 --> 00:14:06,340
about character imbalance because you

00:14:04,990 --> 00:14:08,080
can imagine if we have a team with all

00:14:06,340 --> 00:14:09,760
assassins playing against a team of all

00:14:08,080 --> 00:14:11,800
sort of healers the assassins will

00:14:09,760 --> 00:14:12,940
pretty much always win so in a situation

00:14:11,800 --> 00:14:17,890
where we're assigning a team we also

00:14:12,940 --> 00:14:19,180
have to keep track of this we figured

00:14:17,890 --> 00:14:20,410
though that in the end is not really

00:14:19,180 --> 00:14:22,840
that complicated you just have to think

00:14:20,410 --> 00:14:24,850
of the architecture beforehand so let's

00:14:22,840 --> 00:14:26,530
say there's some sort of queue and we

00:14:24,850 --> 00:14:28,150
had already some sort of player state so

00:14:26,530 --> 00:14:29,740
for every player that's sort of entering

00:14:28,150 --> 00:14:31,570
we have to map that to some sort of

00:14:29,740 --> 00:14:32,920
skill and again this skill will be some

00:14:31,570 --> 00:14:35,680
sort of distribution instead of a mere

00:14:32,920 --> 00:14:38,290
statistic the skill we can sort of then

00:14:35,680 --> 00:14:40,180
map into some queue where everyone that

00:14:38,290 --> 00:14:42,730
has roughly the same skill falls in the

00:14:40,180 --> 00:14:44,410
same queue if this queue then it has ten

00:14:42,730 --> 00:14:46,720
players let's say that's enough to make

00:14:44,410 --> 00:14:48,490
a team so your ristic wise we could say

00:14:46,720 --> 00:14:49,840
okay these players are the same skill we

00:14:48,490 --> 00:14:51,640
have to assign them into separate teams

00:14:49,840 --> 00:14:54,490
but this game can go ahead and get

00:14:51,640 --> 00:14:57,130
started after that some sort of battle

00:14:54,490 --> 00:14:58,810
happens and that battle basically should

00:14:57,130 --> 00:15:00,370
only really concern the update of the

00:14:58,810 --> 00:15:03,520
player state and maybe do some stuff of

00:15:00,370 --> 00:15:05,020
the logging this is a general pattern I

00:15:03,520 --> 00:15:06,340
guess so let's discuss some of the

00:15:05,020 --> 00:15:08,380
things in between that we need to be

00:15:06,340 --> 00:15:10,150
sure of that we do correct we have to be

00:15:08,380 --> 00:15:12,070
very sure that we map a scale to a queue

00:15:10,150 --> 00:15:14,260
or to be very sure that we assign teams

00:15:12,070 --> 00:15:16,180
to a after a queue I want to be very

00:15:14,260 --> 00:15:19,120
sure that we update individual skill

00:15:16,180 --> 00:15:20,680
after it's team fight appropriately now

00:15:19,120 --> 00:15:22,150
the updating of a skill to a queue is

00:15:20,680 --> 00:15:23,470
actually relatively easy you just take

00:15:22,150 --> 00:15:25,480
the player skill you take whatever is

00:15:23,470 --> 00:15:26,710
the most likely region and map that into

00:15:25,480 --> 00:15:28,950
one of the buckets that we've defined

00:15:26,710 --> 00:15:31,870
before beforehand we can say hey this

00:15:28,950 --> 00:15:33,790
instance of our app has eight buckets or

00:15:31,870 --> 00:15:35,020
16 or whatever is some sort of hyper

00:15:33,790 --> 00:15:36,370
parameter but it's relatively

00:15:35,020 --> 00:15:37,660
straightforward to map a player skill

00:15:36,370 --> 00:15:39,160
into such a bucket

00:15:37,660 --> 00:15:40,990
even if there's uncertainty and spread

00:15:39,160 --> 00:15:45,339
you just take the most likely one that's

00:15:40,990 --> 00:15:46,630
a reasonable heuristic if you want to

00:15:45,339 --> 00:15:48,670
assign teams so that's a little bit more

00:15:46,630 --> 00:15:50,380
tricky this is the all Assassin's versus

00:15:48,670 --> 00:15:51,399
old heater use case because what you

00:15:50,380 --> 00:15:53,019
could do is you could take all the

00:15:51,399 --> 00:15:54,550
characters that there exist in this game

00:15:53,019 --> 00:15:56,620
and all the combinations that possibly

00:15:54,550 --> 00:15:58,449
could exist it's you know it grows

00:15:56,620 --> 00:16:00,579
indefinitely you get into a nasty spot

00:15:58,449 --> 00:16:01,779
here so also here it'd be nice if you

00:16:00,579 --> 00:16:03,519
just come up with a bit of an easy hack

00:16:01,779 --> 00:16:05,350
turns out if you play the video game you

00:16:03,519 --> 00:16:06,850
get a bit of domain knowledge because

00:16:05,350 --> 00:16:09,040
let's say we have people that say this

00:16:06,850 --> 00:16:10,240
player wants to play Diablo we know that

00:16:09,040 --> 00:16:12,310
a certain character in this video game

00:16:10,240 --> 00:16:14,319
also maps to a certain type of character

00:16:12,310 --> 00:16:15,759
you can do this clustering yourself but

00:16:14,319 --> 00:16:17,529
in this particular case we already knew

00:16:15,759 --> 00:16:19,089
this so we know that they aval for

00:16:17,529 --> 00:16:20,709
example is a tank it's a person who can

00:16:19,089 --> 00:16:22,060
take a lot of damage Raynor is an

00:16:20,709 --> 00:16:22,690
assassin that someone who could do a lot

00:16:22,060 --> 00:16:24,730
of damage

00:16:22,690 --> 00:16:26,230
murky is a specialist mercury destroys

00:16:24,730 --> 00:16:28,240
all your towers so now he is a healer

00:16:26,230 --> 00:16:30,279
the healer make sure you people your

00:16:28,240 --> 00:16:31,690
characters don't die that means whenever

00:16:30,279 --> 00:16:33,490
we get a queue of ten people let's say

00:16:31,690 --> 00:16:34,660
we can first do a mapping that says is

00:16:33,490 --> 00:16:37,360
the character and this is the type of

00:16:34,660 --> 00:16:39,880
the character we can then sort on the

00:16:37,360 --> 00:16:41,380
character type and if this is sorted we

00:16:39,880 --> 00:16:43,449
can just do a heuristic that says okay

00:16:41,380 --> 00:16:44,680
let's do the odd ones and even ones in

00:16:43,449 --> 00:16:46,000
different teams and this gives us

00:16:44,680 --> 00:16:47,290
somewhat of a guarantee that at least

00:16:46,000 --> 00:16:49,779
every team has the same type of

00:16:47,290 --> 00:16:52,899
character the say let me put it this way

00:16:49,779 --> 00:16:54,009
the same consistency of types there will

00:16:52,899 --> 00:16:54,970
still be differences but there will be

00:16:54,009 --> 00:16:56,829
rather minimal

00:16:54,970 --> 00:16:59,019
you will never get all the sensors all

00:16:56,829 --> 00:17:00,370
healers this way there's just a

00:16:59,019 --> 00:17:01,750
heuristic I'm not saying this is the

00:17:00,370 --> 00:17:02,709
best one but this is one that's good

00:17:01,750 --> 00:17:05,049
enough that would fit our streaming

00:17:02,709 --> 00:17:07,630
situation the thing that actually

00:17:05,049 --> 00:17:09,250
becomes more tricky is then to say we

00:17:07,630 --> 00:17:11,110
know to map the skill into a bucket we

00:17:09,250 --> 00:17:12,640
know how to map the cube bucket into a

00:17:11,110 --> 00:17:14,559
team and from there on we can play a

00:17:12,640 --> 00:17:15,760
video game the hard part is really how

00:17:14,559 --> 00:17:18,130
do you have a team fight and then have

00:17:15,760 --> 00:17:20,110
everything update the blunt approach

00:17:18,130 --> 00:17:21,850
would be to say instead of so before we

00:17:20,110 --> 00:17:23,890
had a two dimensional distribution of

00:17:21,850 --> 00:17:24,970
two histograms we can all say if ten

00:17:23,890 --> 00:17:26,740
people plays just a 10 dimensional

00:17:24,970 --> 00:17:28,870
distribution and you have to be very

00:17:26,740 --> 00:17:29,980
consistent updating but then

00:17:28,870 --> 00:17:31,809
mathematically you'll still be

00:17:29,980 --> 00:17:34,870
equivalent the problem though is is

00:17:31,809 --> 00:17:36,820
supposed to histograms for the skill is

00:17:34,870 --> 00:17:37,450
100 buckets if you do that to the power

00:17:36,820 --> 00:17:39,280
of 10

00:17:37,450 --> 00:17:41,919
basically your computer's going to say

00:17:39,280 --> 00:17:43,809
no we also think we could also instead

00:17:41,919 --> 00:17:45,520
say hey let's cheat a bit let's say we

00:17:43,809 --> 00:17:47,890
say this is a player and this is the

00:17:45,520 --> 00:17:50,500
team of opponents we can also just say

00:17:47,890 --> 00:17:51,760
let's summarize that somehow a little

00:17:50,500 --> 00:17:51,940
term that we could do is we can have

00:17:51,760 --> 00:17:53,470
some

00:17:51,940 --> 00:17:55,649
sort of data scientists apply heavy maps

00:17:53,470 --> 00:17:57,909
for some sort of consistent update rule

00:17:55,649 --> 00:18:00,070
downside of this you may need to find a

00:17:57,909 --> 00:18:02,019
guy who has a sort of PhD in mass that's

00:18:00,070 --> 00:18:03,309
mathematical complexity and that leads

00:18:02,019 --> 00:18:05,049
to sort of some sort of maintenance risk

00:18:03,309 --> 00:18:06,850
if you think about it so we figured

00:18:05,049 --> 00:18:08,830
trying out heuristics might be the best

00:18:06,850 --> 00:18:09,909
solution and you know just for the top

00:18:08,830 --> 00:18:11,559
of the head you can come up with a few

00:18:09,909 --> 00:18:13,179
the averaging is something I just

00:18:11,559 --> 00:18:15,279
mentioned so let's say gold Dan is

00:18:13,179 --> 00:18:16,960
battling this team you can say take all

00:18:15,279 --> 00:18:18,370
these skills map them together some sort

00:18:16,960 --> 00:18:20,620
of average and then pretend it's a one

00:18:18,370 --> 00:18:22,179
versus one game again alternatively you

00:18:20,620 --> 00:18:24,009
can also say instead of mapping it back

00:18:22,179 --> 00:18:25,870
into the sort of an average skill you

00:18:24,009 --> 00:18:27,370
can also remind yourself the q bucket

00:18:25,870 --> 00:18:28,889
you were in and just say that sort of a

00:18:27,370 --> 00:18:30,759
uniform skill level and just apply that

00:18:28,889 --> 00:18:33,340
another thing you could even do is you

00:18:30,759 --> 00:18:35,019
could say look at every one from this if

00:18:33,340 --> 00:18:36,700
this team beat that team then we're at

00:18:35,019 --> 00:18:38,259
least very sure all the players in this

00:18:36,700 --> 00:18:40,509
team are better than the worst player

00:18:38,259 --> 00:18:41,830
from that team and this team then loses

00:18:40,509 --> 00:18:43,509
that we know all of these players are

00:18:41,830 --> 00:18:45,759
worse than the best person from this

00:18:43,509 --> 00:18:46,750
team I hope you understand is all these

00:18:45,759 --> 00:18:48,490
things are yer istic so they're not

00:18:46,750 --> 00:18:49,720
really giving us a guarantee but these

00:18:48,490 --> 00:18:50,980
are things we could try out and we could

00:18:49,720 --> 00:18:52,720
work with to deal with the numerical

00:18:50,980 --> 00:18:54,039
complexity and all these things should

00:18:52,720 --> 00:18:57,340
also still work in something of a

00:18:54,039 --> 00:18:58,600
streaming framework this is kind of the

00:18:57,340 --> 00:19:00,370
total architecture that were then left

00:18:58,600 --> 00:19:02,700
with and all the solutions I just

00:19:00,370 --> 00:19:05,230
mentioned how to go from a skill to a

00:19:02,700 --> 00:19:06,549
sort of a cube bucket how to go from a

00:19:05,230 --> 00:19:08,080
cube bucket to some sort of team

00:19:06,549 --> 00:19:09,519
assignment and how to go from a team

00:19:08,080 --> 00:19:11,710
assignment to how to update the priors

00:19:09,519 --> 00:19:12,909
these are all things that still allow us

00:19:11,710 --> 00:19:15,159
to do things in the streaming setting

00:19:12,909 --> 00:19:16,600
you can even consider we we are able to

00:19:15,159 --> 00:19:19,539
sort of play around because there's some

00:19:16,600 --> 00:19:21,190
degrees of freedom we will now go more

00:19:19,539 --> 00:19:23,500
to the realm of application which I will

00:19:21,190 --> 00:19:24,750
gladly give to my colleague Foca Thank

00:19:23,500 --> 00:19:27,399
You Vincent

00:19:24,750 --> 00:19:30,490
this is working yeah perfect

00:19:27,399 --> 00:19:31,690
so that was the data science loan let's

00:19:30,490 --> 00:19:33,850
go to the to the engineering part

00:19:31,690 --> 00:19:35,350
everything was written in a Jupiter

00:19:33,850 --> 00:19:38,950
notebook for the prototype into testing

00:19:35,350 --> 00:19:41,289
heuristics but I like writing but I love

00:19:38,950 --> 00:19:44,590
Scala and also flink so that was a great

00:19:41,289 --> 00:19:46,750
match so we decided to transform the

00:19:44,590 --> 00:19:49,320
algorithm into flink so we have to think

00:19:46,750 --> 00:19:52,720
of all the steps that are necessary to

00:19:49,320 --> 00:19:55,090
build this architecture onto flink

00:19:52,720 --> 00:19:57,549
the nice thing is about language you can

00:19:55,090 --> 00:20:00,669
do all these these individual function

00:19:57,549 --> 00:20:02,619
so for example a map a window and can

00:20:00,669 --> 00:20:04,790
just test them individually so that's

00:20:02,619 --> 00:20:06,680
you know so you have to add

00:20:04,790 --> 00:20:08,660
to tell this individual part you can

00:20:06,680 --> 00:20:13,400
test themselves you are sure that they

00:20:08,660 --> 00:20:14,840
work properly when we won the algorithm

00:20:13,400 --> 00:20:16,880
as you might have seen in the previous

00:20:14,840 --> 00:20:20,420
slide notes a lot of hydrophobic

00:20:16,880 --> 00:20:23,570
parameter that you can tune yeah we

00:20:20,420 --> 00:20:25,790
started with some some basic parameters

00:20:23,570 --> 00:20:28,580
from and prototyping that we before

00:20:25,790 --> 00:20:29,960
before but we want to tune this this

00:20:28,580 --> 00:20:33,410
parameter is also in the real

00:20:29,960 --> 00:20:37,220
application on top of link yeah might

00:20:33,410 --> 00:20:39,740
need some some great search first so but

00:20:37,220 --> 00:20:41,390
it's not necessarily be a bad thing that

00:20:39,740 --> 00:20:44,260
it has a lot of parama parametres

00:20:41,390 --> 00:20:49,190
because we go also tune it to get like a

00:20:44,260 --> 00:20:50,900
behavior that we like yeah and if you

00:20:49,190 --> 00:20:53,210
can scale this now we can get more

00:20:50,900 --> 00:20:55,700
people playing the game and this easier

00:20:53,210 --> 00:20:59,810
with fling and then with all the

00:20:55,700 --> 00:21:02,600
frameworks so let's talk fling let's see

00:20:59,810 --> 00:21:04,870
how we did it so we wrote a function

00:21:02,600 --> 00:21:07,690
that generates like random players

00:21:04,870 --> 00:21:12,830
players they're applying for the cube

00:21:07,690 --> 00:21:16,070
next we have we see them as Jason then

00:21:12,830 --> 00:21:18,920
we be deserialize them so we get a case

00:21:16,070 --> 00:21:21,080
object next step is to sample the skill

00:21:18,920 --> 00:21:23,180
distribution so if you have like a skill

00:21:21,080 --> 00:21:25,000
distribution of this player in the state

00:21:23,180 --> 00:21:27,710
then we use that skill distribution

00:21:25,000 --> 00:21:31,340
otherwise you just start with a with a

00:21:27,710 --> 00:21:33,500
with effort skill distribution so with a

00:21:31,340 --> 00:21:37,130
high uncertainty so the player will just

00:21:33,500 --> 00:21:38,930
play against efforts players next step

00:21:37,130 --> 00:21:41,390
is to do the window function so we get

00:21:38,930 --> 00:21:43,340
10 players in in the window it's a fixed

00:21:41,390 --> 00:21:46,430
length window so when they're 10 players

00:21:43,340 --> 00:21:49,600
will go to the next part of the of the

00:21:46,430 --> 00:21:51,710
pipeline and it will a simulated game

00:21:49,600 --> 00:21:53,960
after that we have to split the game

00:21:51,710 --> 00:21:55,610
again into individual users so we can do

00:21:53,960 --> 00:21:59,150
this mapping from the average of the

00:21:55,610 --> 00:22:02,240
team to an individual player and that's

00:21:59,150 --> 00:22:04,610
also hashed to the curable state that we

00:22:02,240 --> 00:22:05,480
leveraged from link so all the state is

00:22:04,610 --> 00:22:06,980
stored in flink

00:22:05,480 --> 00:22:08,960
in the description you might have read

00:22:06,980 --> 00:22:11,840
that we also want to use select

00:22:08,960 --> 00:22:13,760
elasticsearch for this but when I looked

00:22:11,840 --> 00:22:17,160
at this link yeah we didn't need it and

00:22:13,760 --> 00:22:20,040
I think it's very nice feature

00:22:17,160 --> 00:22:23,490
so we read the menu state from flink so

00:22:20,040 --> 00:22:25,590
all these states inside a fling the nice

00:22:23,490 --> 00:22:27,180
thing is that is charted by key so at

00:22:25,590 --> 00:22:29,820
the point that you get more players on

00:22:27,180 --> 00:22:31,710
your system you can scale up the Kerbal

00:22:29,820 --> 00:22:33,930
state apart and increase it parallelism

00:22:31,710 --> 00:22:37,260
and it will also increase the capacity

00:22:33,930 --> 00:22:42,060
and involves like like storage space but

00:22:37,260 --> 00:22:46,670
also in computational power it allows us

00:22:42,060 --> 00:22:49,350
if you say I want to have more more

00:22:46,670 --> 00:22:51,510
State I want to divide the key space

00:22:49,350 --> 00:22:54,090
into a smaller part so I can encompass

00:22:51,510 --> 00:22:55,410
more players and fling takes care of

00:22:54,090 --> 00:22:58,760
this it will redistribute the key space

00:22:55,410 --> 00:23:01,980
according to and increase the number of

00:22:58,760 --> 00:23:04,260
executors it allows you to snapshot the

00:23:01,980 --> 00:23:06,300
whole system so you can take snapshots

00:23:04,260 --> 00:23:08,310
and you can save the snapshot so if your

00:23:06,300 --> 00:23:11,010
system crashes or whatever then you can

00:23:08,310 --> 00:23:12,960
I want to launch an updated version of

00:23:11,010 --> 00:23:15,720
the application you can use the snapshot

00:23:12,960 --> 00:23:17,370
to start from again and the nice thing

00:23:15,720 --> 00:23:19,800
is that it eliminates external

00:23:17,370 --> 00:23:21,300
components so if you snaps your bit you

00:23:19,800 --> 00:23:23,700
don't have to take care of like external

00:23:21,300 --> 00:23:26,400
state that is there and you can just

00:23:23,700 --> 00:23:31,440
have a nice exactly one semantics as as

00:23:26,400 --> 00:23:33,990
fling provides them so this is the code

00:23:31,440 --> 00:23:36,930
this is the stream that we have so first

00:23:33,990 --> 00:23:40,500
we decode the player let me take the

00:23:36,930 --> 00:23:42,150
player skill we sample it from the state

00:23:40,500 --> 00:23:45,620
that's stored in the curable state of

00:23:42,150 --> 00:23:50,160
EarthLink then we take the key of the

00:23:45,620 --> 00:23:51,630
bucket so we have a notebook you see

00:23:50,160 --> 00:23:53,160
she's also in games like if the bronze

00:23:51,630 --> 00:23:56,540
League the silver league the gold League

00:23:53,160 --> 00:23:59,070
and you can distribute the by bucket

00:23:56,540 --> 00:24:02,790
then we wait for the appropriate number

00:23:59,070 --> 00:24:04,170
of players then we determine the team so

00:24:02,790 --> 00:24:06,090
it is the newer stick that Simpson

00:24:04,170 --> 00:24:10,290
talked about dying and getting a

00:24:06,090 --> 00:24:12,630
balanced team then we visualize the game

00:24:10,290 --> 00:24:14,520
over here simulated of course we're not

00:24:12,630 --> 00:24:18,560
Blizzard so we can not do it in real

00:24:14,520 --> 00:24:21,570
life so we and we do he played a game

00:24:18,560 --> 00:24:23,910
then we split this game again to date at

00:24:21,570 --> 00:24:25,710
the player state he hatched by the

00:24:23,910 --> 00:24:28,220
player ID so we do the key by

00:24:25,710 --> 00:24:34,340
so we get to the appropriate

00:24:28,220 --> 00:24:37,460
but whether in the state besides then we

00:24:34,340 --> 00:24:40,640
fault the new state into the old state

00:24:37,460 --> 00:24:43,580
so we take all stage we we make this

00:24:40,640 --> 00:24:45,710
two-dimensional matrix and then we

00:24:43,580 --> 00:24:48,770
negative are great the waiter and the

00:24:45,710 --> 00:24:51,650
master is a according if the player lost

00:24:48,770 --> 00:24:54,260
of one and then we updated state so yeah

00:24:51,650 --> 00:24:56,750
there's a bit more computational

00:24:54,260 --> 00:25:00,470
complexity part so we have to make this

00:24:56,750 --> 00:25:02,470
matrix in memory let's do a small demo

00:25:00,470 --> 00:25:08,900
let's see if it works

00:25:02,470 --> 00:25:10,549
bit small but I will explain it what I

00:25:08,900 --> 00:25:12,440
will do I will change the one of the

00:25:10,549 --> 00:25:15,679
configurations right now I have it in 1

00:25:12,440 --> 00:25:22,400
player mode and I will put it into 5

00:25:15,679 --> 00:25:25,210
versus 5 I will save it I will run the

00:25:22,400 --> 00:25:25,210
new jar of it

00:25:30,100 --> 00:25:37,340
it's a said yards or the epen design

00:25:33,559 --> 00:25:40,730
there and then it's really small then I

00:25:37,340 --> 00:25:44,570
run the new the new version in the

00:25:40,730 --> 00:25:46,909
background so we because he was the

00:25:44,570 --> 00:25:50,559
outcome of it later so but said start

00:25:46,909 --> 00:25:50,559
running so we simulate the games

00:25:58,690 --> 00:26:04,379
so let's get first to the notebook that

00:26:01,479 --> 00:26:07,840
this is the one that used for debugging

00:26:04,379 --> 00:26:09,849
all the statistics of the of the

00:26:07,840 --> 00:26:12,489
computation that are done are being done

00:26:09,849 --> 00:26:14,529
to the filesystem for us it's a nice

00:26:12,489 --> 00:26:18,789
using a Jupiter notebook you can easily

00:26:14,529 --> 00:26:22,029
debug the the game so we can see what's

00:26:18,789 --> 00:26:23,349
going on with the new numericals this is

00:26:22,029 --> 00:26:25,059
important otherwise you're just looking

00:26:23,349 --> 00:26:26,859
at at the black box you don't know

00:26:25,059 --> 00:26:28,570
what's going on if the if the

00:26:26,859 --> 00:26:30,669
computation are being done correctly or

00:26:28,570 --> 00:26:33,879
maybe there's a numeral numerical

00:26:30,669 --> 00:26:41,169
imbalance so that's really important if

00:26:33,879 --> 00:26:45,729
you look to this nice so if you look at

00:26:41,169 --> 00:26:47,590
it for said for example at this graph on

00:26:45,729 --> 00:26:49,869
the left hand side we see like the

00:26:47,590 --> 00:26:51,369
really bad players and on the right hand

00:26:49,869 --> 00:26:54,009
side we see like the really good players

00:26:51,369 --> 00:26:56,229
the x-axis is the number of games played

00:26:54,009 --> 00:26:58,869
so on the left is the first game and on

00:26:56,229 --> 00:27:01,690
the right it's the it's the the 50s game

00:26:58,869 --> 00:27:02,739
because we only take their first 50 the

00:27:01,690 --> 00:27:05,669
first hundred sorry

00:27:02,739 --> 00:27:08,470
and then we see like this distribution

00:27:05,669 --> 00:27:10,149
that's in begin it's a bit blue and then

00:27:08,470 --> 00:27:12,239
it converges to like the solid yellow

00:27:10,149 --> 00:27:15,489
line and it means like the scalar the

00:27:12,239 --> 00:27:22,960
skill of the player is converging into

00:27:15,489 --> 00:27:27,009
the game so now we see also the the 5

00:27:22,960 --> 00:27:31,149
versus 5 game running if I then refresh

00:27:27,009 --> 00:27:34,629
like the notebook then we can also see

00:27:31,149 --> 00:27:38,649
like with 5 versus 5 it converges much

00:27:34,629 --> 00:27:42,429
worse and mainly this is the problem is

00:27:38,649 --> 00:27:44,409
that if you have like a team of five

00:27:42,429 --> 00:27:47,349
players for them are really good and one

00:27:44,409 --> 00:27:49,149
is really bad then it's it averages out

00:27:47,349 --> 00:27:51,479
and that's the problem with conversions

00:27:49,149 --> 00:27:51,479
of course

00:27:55,380 --> 00:28:00,510
so there's a bit more bit bigger if we

00:27:58,140 --> 00:28:02,549
see it a bit better so we see like all

00:28:00,510 --> 00:28:04,890
the players in a phone first one game it

00:28:02,549 --> 00:28:06,809
converts really good you go to a to

00:28:04,890 --> 00:28:10,400
first do we see some more jitter but

00:28:06,809 --> 00:28:12,809
still we see like it works quite well

00:28:10,400 --> 00:28:15,840
and if you don't go to the five versus

00:28:12,809 --> 00:28:17,660
five then it really starts to have a lot

00:28:15,840 --> 00:28:20,130
of noise in there

00:28:17,660 --> 00:28:22,049
so this is most probably because like

00:28:20,130 --> 00:28:28,049
too bad players get into a keen with

00:28:22,049 --> 00:28:30,570
good players or not sort of liked it a

00:28:28,049 --> 00:28:33,090
workflow so this is one of the lessons

00:28:30,570 --> 00:28:34,140
learned that we that we had during this

00:28:33,090 --> 00:28:37,860
exercise

00:28:34,140 --> 00:28:39,650
so using Jupiter notebook we can do like

00:28:37,860 --> 00:28:42,780
aggregations you can do nice bloating

00:28:39,650 --> 00:28:45,480
you can summarize data it's really nice

00:28:42,780 --> 00:28:48,809
way to have to debug the the numerical

00:28:45,480 --> 00:28:50,640
system first you want to use elastic

00:28:48,809 --> 00:28:52,020
search in Cabana because it's also the

00:28:50,640 --> 00:28:55,380
or store for the external state but

00:28:52,020 --> 00:28:57,650
using the fling stairs shared state it's

00:28:55,380 --> 00:29:00,210
not necessary anymore

00:28:57,650 --> 00:29:03,570
and without visualisation is really hard

00:29:00,210 --> 00:29:09,480
to debug this this thing especially when

00:29:03,570 --> 00:29:14,520
you're in a distributed environment yeah

00:29:09,480 --> 00:29:16,409
also we had one other book so if you can

00:29:14,520 --> 00:29:20,490
imagine if the dispute gets really

00:29:16,409 --> 00:29:24,390
really sharp then it can happen that one

00:29:20,490 --> 00:29:25,890
of the buckets they go to 0 because the

00:29:24,390 --> 00:29:27,600
limit so we have to add some smoothing

00:29:25,890 --> 00:29:30,270
parameter because of one of the book is

00:29:27,600 --> 00:29:32,610
goes to zero it means that is moss is

00:29:30,270 --> 00:29:34,440
getting away but because it's zero and

00:29:32,610 --> 00:29:37,020
if you multiply by zero to always get

00:29:34,440 --> 00:29:39,450
there also you need to add some some

00:29:37,020 --> 00:29:41,820
smoothing there so this is a smoothing

00:29:39,450 --> 00:29:44,010
parameter that we tried and if you take

00:29:41,820 --> 00:29:49,320
a really small one you see everything

00:29:44,010 --> 00:29:52,200
reverses ok if you make it a bit bigger

00:29:49,320 --> 00:29:54,270
and it has a bigger problem with with

00:29:52,200 --> 00:29:57,210
converging and if you make it too big

00:29:54,270 --> 00:29:59,970
then just unfortunate it's been able to

00:29:57,210 --> 00:30:01,110
estimate the skill of the player so this

00:29:59,970 --> 00:30:03,809
is something that you might want to try

00:30:01,110 --> 00:30:05,520
out before moving into into flink and

00:30:03,809 --> 00:30:08,120
just do some simulation inside of

00:30:05,520 --> 00:30:08,120
Jupiter

00:30:13,630 --> 00:30:20,630
so yeah discerned this tuning of the how

00:30:19,250 --> 00:30:22,220
what I just said like if you

00:30:20,630 --> 00:30:23,809
multitudinous parametres just really

00:30:22,220 --> 00:30:26,150
nice to do it interpreter instead of on

00:30:23,809 --> 00:30:31,429
flank otherwise you're just looking at

00:30:26,150 --> 00:30:33,679
this is a bit of black hole and also

00:30:31,429 --> 00:30:35,600
another problem that we had and we first

00:30:33,679 --> 00:30:38,480
thought it was like a numerical problem

00:30:35,600 --> 00:30:41,210
but it turned out it was part of the way

00:30:38,480 --> 00:30:45,440
of link 1/2 link works is we had this

00:30:41,210 --> 00:30:48,770
simulator and we didn't trouble it so it

00:30:45,440 --> 00:30:51,230
was like pushing out tons of users and

00:30:48,770 --> 00:30:53,660
the mapping of the skill is not that

00:30:51,230 --> 00:30:56,120
hard so it would go further on and the

00:30:53,660 --> 00:30:58,760
Birkett mapping is also computationally

00:30:56,120 --> 00:31:02,390
not really complex team assignor is also

00:30:58,760 --> 00:31:03,590
yes simple heuristics but after the game

00:31:02,390 --> 00:31:05,720
has been played you want to make this

00:31:03,590 --> 00:31:09,230
two-dimensional matrix and that is

00:31:05,720 --> 00:31:11,420
really a computational intensive so what

00:31:09,230 --> 00:31:14,420
we had is for one game for one player

00:31:11,420 --> 00:31:16,220
that was playing a game it would also go

00:31:14,420 --> 00:31:18,590
into the queue again and then would

00:31:16,220 --> 00:31:21,110
sample like an old state and this is

00:31:18,590 --> 00:31:23,179
something that you in real life never

00:31:21,110 --> 00:31:24,860
would encounter because yeah if you're

00:31:23,179 --> 00:31:27,080
one player you only play one game at a

00:31:24,860 --> 00:31:29,210
time he will not do games in parallel

00:31:27,080 --> 00:31:30,920
otherwise maybe if you're really good

00:31:29,210 --> 00:31:34,730
you can do that but most people just

00:31:30,920 --> 00:31:37,309
play one game at a time so the same

00:31:34,730 --> 00:31:40,910
player was multiple times inside of the

00:31:37,309 --> 00:31:42,860
of the of the pipeline and that caused

00:31:40,910 --> 00:31:45,950
some problems because then a display was

00:31:42,860 --> 00:31:51,230
sampling all state and state was updated

00:31:45,950 --> 00:31:53,990
with all state so it was a problem we

00:31:51,230 --> 00:31:58,179
saw a we solve it by adding some

00:31:53,990 --> 00:31:58,179
throttling to the to the source function

00:32:01,830 --> 00:32:08,580
yeah civilization I cannot stress enough

00:32:03,690 --> 00:32:10,619
it's really important to debug this and

00:32:08,580 --> 00:32:13,200
also if you have like that many

00:32:10,619 --> 00:32:14,850
hyperparameters or heuristics you really

00:32:13,200 --> 00:32:17,580
want to make sure that they work well

00:32:14,850 --> 00:32:21,539
otherwise you will be maybe looking at

00:32:17,580 --> 00:32:24,059
the wrong problem and what helps for us

00:32:21,539 --> 00:32:27,149
is just starting first one first one and

00:32:24,059 --> 00:32:32,909
make NIC making that problem more

00:32:27,149 --> 00:32:36,090
complex in steps they add a final result

00:32:32,909 --> 00:32:39,059
yeah B I think it will work I do a 5 vs.

00:32:36,090 --> 00:32:42,029
1 a 5 vs. 5 but it still needs some

00:32:39,059 --> 00:32:43,409
tuning and also because it's just

00:32:42,029 --> 00:32:47,009
simulating we don't we're going to have

00:32:43,409 --> 00:32:51,299
a real data it's a bit of a it's a bit

00:32:47,009 --> 00:32:53,999
of a trying out and also what's really

00:32:51,299 --> 00:32:57,989
important is they are not served them

00:32:53,999 --> 00:33:00,779
many algorithmic people in the room but

00:32:57,989 --> 00:33:03,480
it's also a bit of a scheduling problem

00:33:00,779 --> 00:33:06,450
so you have a player able to sample the

00:33:03,480 --> 00:33:08,519
skill of it and get him to play as soon

00:33:06,450 --> 00:33:11,639
as possible what's also a bit of a soft

00:33:08,519 --> 00:33:12,899
side in here like an unperfect game you

00:33:11,639 --> 00:33:16,080
want to have like if you play this game

00:33:12,899 --> 00:33:17,789
you want to equally lose and win because

00:33:16,080 --> 00:33:19,470
then you are playing a nice game

00:33:17,789 --> 00:33:23,009
otherwise if you win away it's not fun

00:33:19,470 --> 00:33:25,200
and I'm saying if you lose always it's

00:33:23,009 --> 00:33:28,109
always you get a bit bored of the game

00:33:25,200 --> 00:33:30,149
and then you just uninstall it but you

00:33:28,109 --> 00:33:33,119
also don't want to wait very long until

00:33:30,149 --> 00:33:35,970
we have like yeah really nicely matched

00:33:33,119 --> 00:33:38,609
a set of of people who you can play with

00:33:35,970 --> 00:33:42,590
so this is a bit of a software trade-off

00:33:38,609 --> 00:33:42,590
that you want to take into account our

00:33:45,139 --> 00:33:54,359
conclusion to recap a bit yeah the

00:33:51,389 --> 00:33:56,909
numerix it's a if you have for example

00:33:54,359 --> 00:33:58,499
some two distributions who are really

00:33:56,909 --> 00:34:01,909
applied you get the strange results

00:33:58,499 --> 00:34:04,830
because of the way of how we normalize I

00:34:01,909 --> 00:34:07,830
really like the distributor status link

00:34:04,830 --> 00:34:10,409
it really helps you to have everything

00:34:07,830 --> 00:34:12,510
in within to one place and it's a works

00:34:10,409 --> 00:34:14,069
very well with updating and really

00:34:12,510 --> 00:34:14,950
elegant of following the the new state

00:34:14,069 --> 00:34:17,589
into the

00:34:14,950 --> 00:34:22,990
into this whole state so you always have

00:34:17,589 --> 00:34:26,619
like a big memory footprint and it's

00:34:22,990 --> 00:34:29,470
quite nice and that last one that we

00:34:26,619 --> 00:34:32,919
won't say if you want to do some beijing

00:34:29,470 --> 00:34:34,869
stuff or no merit complex stuff first

00:34:32,919 --> 00:34:36,339
make sure that it works into a simple

00:34:34,869 --> 00:34:39,149
setting so again if you implement it on

00:34:36,339 --> 00:34:41,619
the top of a distributed system it is a

00:34:39,149 --> 00:34:43,720
that you sure that it works at properly

00:34:41,619 --> 00:34:45,399
and you also can unit test against like

00:34:43,720 --> 00:34:52,599
the stuff that you developed in the in

00:34:45,399 --> 00:35:03,160
the prototype that's it thank you for

00:34:52,599 --> 00:35:08,260
listening hope you enjoyed it thank you

00:35:03,160 --> 00:35:14,170
we have time for questions I'll start it

00:35:08,260 --> 00:35:16,920
this way so why have you not already

00:35:14,170 --> 00:35:19,029
done this on real data like oh so the

00:35:16,920 --> 00:35:20,289
just like with the Pokemon I would first

00:35:19,029 --> 00:35:22,390
want to simulate and test that the

00:35:20,289 --> 00:35:23,950
algorithm works right and then I can

00:35:22,390 --> 00:35:25,809
apply it to Pokemon I already downloaded

00:35:23,950 --> 00:35:27,309
so there's this guy who has a website

00:35:25,809 --> 00:35:28,809
called hot slogs and you can sort of

00:35:27,309 --> 00:35:33,220
apply that on some of the game logs of

00:35:28,809 --> 00:35:35,650
actual data the focus main interest in

00:35:33,220 --> 00:35:37,390
this hobby project was applying the some

00:35:35,650 --> 00:35:39,009
of the flink internals and sort of doing

00:35:37,390 --> 00:35:41,109
more stuff with that my main hobby

00:35:39,009 --> 00:35:42,549
project sort of goal here was more to

00:35:41,109 --> 00:35:44,920
see if you can have a machine learning

00:35:42,549 --> 00:35:47,109
model the updates point by point and I

00:35:44,920 --> 00:35:49,029
do think the use case that we have here

00:35:47,109 --> 00:35:50,559
in terms for video games you kind of

00:35:49,029 --> 00:35:52,779
like a very nice use case where you can

00:35:50,559 --> 00:35:53,920
demonstrate that this idea of actually

00:35:52,779 --> 00:35:55,480
having a machine learning model learn

00:35:53,920 --> 00:35:57,460
data point per data point but that

00:35:55,480 --> 00:36:00,009
generally could work so that was more

00:35:57,460 --> 00:36:01,660
our interest if this out so we still

00:36:00,009 --> 00:36:03,579
through some ID parameter tweaking after

00:36:01,660 --> 00:36:04,930
that you just take the log file string

00:36:03,579 --> 00:36:06,099
through it and then you could say this

00:36:04,930 --> 00:36:08,410
player might be better than that player

00:36:06,099 --> 00:36:09,910
but you didn't actually do it on the

00:36:08,410 --> 00:36:13,180
data yet so we haven't done that yet

00:36:09,910 --> 00:36:16,210
mainly because we we didn't foresee that

00:36:13,180 --> 00:36:19,089
our team assignment heuristics would

00:36:16,210 --> 00:36:20,680
actually cause so much surgery okay

00:36:19,089 --> 00:36:21,849
there is also a solution for that which

00:36:20,680 --> 00:36:24,700
is probably what we're going to iterate

00:36:21,849 --> 00:36:26,799
on probably this Friday but yeah that's

00:36:24,700 --> 00:36:27,850
the main reason in a hijack this one

00:36:26,799 --> 00:36:29,440
more question

00:36:27,850 --> 00:36:31,390
do you have any idea what the matching

00:36:29,440 --> 00:36:35,170
algorithms are at the moment in Blizzard

00:36:31,390 --> 00:36:37,240
or for overwatch or so I have talked at

00:36:35,170 --> 00:36:40,920
like conferences like very gently to

00:36:37,240 --> 00:36:43,750
some of these game developer people the

00:36:40,920 --> 00:36:47,500
so I have not met a Blizzard person

00:36:43,750 --> 00:36:48,820
that's because I live in Europe but I

00:36:47,500 --> 00:36:52,090
have to talk to some more of the mobile

00:36:48,820 --> 00:36:53,350
game developer peoples and they the main

00:36:52,090 --> 00:36:54,880
thing in the end if you want to do like

00:36:53,350 --> 00:36:56,140
the super simple way like we're using a

00:36:54,880 --> 00:36:58,150
lot of master machine learning if you're

00:36:56,140 --> 00:36:59,680
just like an engineering company you can

00:36:58,150 --> 00:37:01,540
also consider what fifa does like hey

00:36:59,680 --> 00:37:03,130
just have these leagues and if you win a

00:37:01,540 --> 00:37:04,750
lot within a league you move up one and

00:37:03,130 --> 00:37:06,190
with a bunch of heuristics that might

00:37:04,750 --> 00:37:07,300
just go ahead and work and if that

00:37:06,190 --> 00:37:09,700
already works then why change the

00:37:07,300 --> 00:37:11,740
winning team so that's more the practice

00:37:09,700 --> 00:37:16,060
that I hear of again my interest was the

00:37:11,740 --> 00:37:18,010
Bayesian updating so when running your

00:37:16,060 --> 00:37:21,610
simulations or even interpreting your

00:37:18,010 --> 00:37:24,070
result data would it be possible to

00:37:21,610 --> 00:37:26,590
distinguish between layer skill and

00:37:24,070 --> 00:37:29,200
character balance for example given that

00:37:26,590 --> 00:37:32,230
our heroes of the storm it's somewhat of

00:37:29,200 --> 00:37:34,330
a rock paper scissor so the way we sort

00:37:32,230 --> 00:37:35,650
of solve that is by using the Aristocats

00:37:34,330 --> 00:37:37,690
says let just make sure there's as many

00:37:35,650 --> 00:37:39,700
assassins roughly in each game as many

00:37:37,690 --> 00:37:42,580
tanks and as many healers and obviously

00:37:39,700 --> 00:37:44,430
that doesn't necessarily hold always now

00:37:42,580 --> 00:37:47,140
there's also streaming way to hear that

00:37:44,430 --> 00:37:49,690
but that wouldn't fit this talk the idea

00:37:47,140 --> 00:37:51,400
would be you can't so we can't take all

00:37:49,690 --> 00:37:53,020
combinations of possible characters

00:37:51,400 --> 00:37:54,220
across each team and that we could

00:37:53,020 --> 00:37:55,690
probably calculate a score for that but

00:37:54,220 --> 00:37:57,610
just way too many combinations we'd have

00:37:55,690 --> 00:37:58,900
to consider what alternatively you could

00:37:57,610 --> 00:38:00,190
do is you could say hey let's take two

00:37:58,900 --> 00:38:02,380
players from this team two players from

00:38:00,190 --> 00:38:04,390
that team and calculate the probability

00:38:02,380 --> 00:38:05,980
that cinereous and Raynor versus another

00:38:04,390 --> 00:38:07,690
murder in any other what the probability

00:38:05,980 --> 00:38:10,180
is of one team winning versus the other

00:38:07,690 --> 00:38:11,740
do that for all characters yet still

00:38:10,180 --> 00:38:13,750
iterate quite a bit but that's stuff you

00:38:11,740 --> 00:38:14,560
can handle in memory so that will be a

00:38:13,750 --> 00:38:16,270
better EurAsEC

00:38:14,560 --> 00:38:17,710
but it was not as easy to implement and

00:38:16,270 --> 00:38:18,790
I think the main issue we have is more

00:38:17,710 --> 00:38:21,520
with how do we summarize a team

00:38:18,790 --> 00:38:24,730
statistic okay and then the the main use

00:38:21,520 --> 00:38:28,420
case would be matchmaking instead of

00:38:24,730 --> 00:38:29,800
balancing the character for example well

00:38:28,420 --> 00:38:33,340
it's a bit of both right and it's kind

00:38:29,800 --> 00:38:34,450
of this slide it is up to you I guess to

00:38:33,340 --> 00:38:36,040
figure out if it's more important that

00:38:34,450 --> 00:38:38,380
games are balanced or if people should

00:38:36,040 --> 00:38:39,010
wait in line longer my my former boss

00:38:38,380 --> 00:38:40,360
that

00:38:39,010 --> 00:38:42,100
was reviewing the slides he was actually

00:38:40,360 --> 00:38:43,780
saying that we were doing stuff kind of

00:38:42,100 --> 00:38:44,950
crazily because obviously the waiting

00:38:43,780 --> 00:38:46,900
time is the only thing that matters

00:38:44,950 --> 00:38:48,250
however I actually feel that the game

00:38:46,900 --> 00:38:50,200
bounds actually the thing is going to

00:38:48,250 --> 00:38:51,910
get you to stop playing the game instead

00:38:50,200 --> 00:38:53,230
so it depends on what you feel is more

00:38:51,910 --> 00:38:55,120
important but this is something you do

00:38:53,230 --> 00:38:57,610
by high parameter tuning looking at the

00:38:55,120 --> 00:38:58,870
plots and I personally feel that the

00:38:57,610 --> 00:39:00,310
only way to properly do this is not with

00:38:58,870 --> 00:39:02,740
Cubana you need to make your own custom

00:39:00,310 --> 00:39:04,180
plots the downside of this Bayesian sort

00:39:02,740 --> 00:39:06,510
of rhetoric is that you do get into this

00:39:04,180 --> 00:39:10,270
numerical territory it can get nasty

00:39:06,510 --> 00:39:14,470
cool other questions you can also ask us

00:39:10,270 --> 00:39:19,030
anything near the food yes that'll be

00:39:14,470 --> 00:39:20,780
fine cool thanks for listening I guess

00:39:19,030 --> 00:39:26,769
thank you fo yeah thank you

00:39:20,780 --> 00:39:26,769

YouTube URL: https://www.youtube.com/watch?v=1--5mIYyB9s


