Title: Berlin Buzzwords 17: Doug Turnbull & Jason Kowalewski - We built an Elasticsearch Learning to Rank..
Publication date: 2017-06-15
Playlist: Berlin Buzzwords 2017
Description: 
	Doug Turnbull and Jason Kowalewski talking about "We built an Elasticsearch Learning to Rank plugin. Then came the hard part".

Learning to Rank uses machine learning to improve the relevance of search results. In this talk, I discuss how we built a learning to rank plugin for Elasticsearch. But what's more interesting is what happened next. Learning to rank requires new ways of thinking about search relevance, and in this talk I go on to discuss the specific problems faced by production-ready learning to rank systems. We learned these hard way so you don't have to. These systems need to solve a variety of problems including:

- Correctly measuring, using analytics, what a user deems "relevant" or "irrelevant"
- Hypothesizing which features of users, queries, or documents (or query-user dependent features) might correlate to relevance
- Logging/Gathering hypothesized features using the search engine
- Training models in a scalable fashion
- Selecting and evaluate models for appropriateness and minimal error
- Integrating models in a live search system alongside business logic, and other non-relevance considerations
- A/B testing learning to rank models and avoiding future bias of training data

Each of these requires solving pretty tough problems. This talk will discuss our war stories, practical lessons, and the goings-on inside real life search implementations that can help you decide what pitfalls to avoid and decide whether learning to rank is the right direction for your search problem.

Read more:
https://2017.berlinbuzzwords.de/17/session/we-built-elasticsearch-learning-rank-plugin-then-came-hard-part

About Doug Turnbull:
https://2017.berlinbuzzwords.de/users/doug-turnbull

About Jason Kowalewski:
https://2017.berlinbuzzwords.de/users/jason-kowalewski

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,029 --> 00:00:13,380
so I'm Doug

00:00:08,290 --> 00:00:16,680
[Applause]

00:00:13,380 --> 00:00:20,430
talk I've ever given in my career I've

00:00:16,680 --> 00:00:23,010
dug and I'm Jason Jason and we're going

00:00:20,430 --> 00:00:26,189
to hear talk about learning to rank that

00:00:23,010 --> 00:00:29,010
we have been working on together in the

00:00:26,189 --> 00:00:30,779
context of job search and as a

00:00:29,010 --> 00:00:33,060
functionality we're adding to as a

00:00:30,779 --> 00:00:35,940
plugin to elastic search and not only

00:00:33,060 --> 00:00:38,300
that but the pain points in the sort of

00:00:35,940 --> 00:00:46,290
bruises that we earned along the way

00:00:38,300 --> 00:00:54,570
space space oh the first lesson we

00:00:46,290 --> 00:00:57,930
learned about learning to rank was oh we

00:00:54,570 --> 00:01:02,370
probably should have tested this huh it

00:00:57,930 --> 00:01:02,790
was working yeah we're engineers it's

00:01:02,370 --> 00:01:04,949
okay

00:01:02,790 --> 00:01:06,750
yeah I watch someone very smart

00:01:04,949 --> 00:01:10,740
yesterday spent about an hour trying to

00:01:06,750 --> 00:01:12,390
print badges so and if you know what's

00:01:10,740 --> 00:01:13,560
happening tomorrow in terms of a

00:01:12,390 --> 00:01:17,250
conference you'll know who I'm talking

00:01:13,560 --> 00:01:20,399
about so I work at open source

00:01:17,250 --> 00:01:22,109
connections I our company focuses pretty

00:01:20,399 --> 00:01:27,359
exclusively on solar and elasticsearch

00:01:22,109 --> 00:01:28,889
relevance problems so ranking how I like

00:01:27,359 --> 00:01:32,130
to tell people that don't know anything

00:01:28,889 --> 00:01:34,259
about search I try to match users to

00:01:32,130 --> 00:01:35,759
your products find the best products for

00:01:34,259 --> 00:01:42,380
them whether it's through search or

00:01:35,759 --> 00:01:45,420
recommendation systems and Jason so I

00:01:42,380 --> 00:01:47,429
work at a company called Snagajob and I

00:01:45,420 --> 00:01:49,289
put this slide up here for context not

00:01:47,429 --> 00:01:51,810
to hit you over the head with marketing

00:01:49,289 --> 00:01:53,310
stuff but probably none of you have

00:01:51,810 --> 00:01:55,649
heard of our company I'm going to take a

00:01:53,310 --> 00:01:57,779
guess but we are the largest marketplace

00:01:55,649 --> 00:02:00,119
for hourly work in the United States and

00:01:57,779 --> 00:02:01,649
so some of the statistics up there with

00:02:00,119 --> 00:02:03,659
four and a half million applications

00:02:01,649 --> 00:02:06,840
people applying to for jobs on our

00:02:03,659 --> 00:02:09,119
platform a month 5.3 million people were

00:02:06,840 --> 00:02:11,569
hired last year on our platform we get

00:02:09,119 --> 00:02:14,910
about a million new workers every month

00:02:11,569 --> 00:02:18,209
in about 75 million registered Lu that's

00:02:14,910 --> 00:02:20,220
around 80 million now on a platform and

00:02:18,209 --> 00:02:22,640
around 300 thousand employers on the

00:02:20,220 --> 00:02:22,640
other side

00:02:23,400 --> 00:02:31,840
making making funny noises sorry all

00:02:26,650 --> 00:02:34,599
right so I'm going to try to explain our

00:02:31,840 --> 00:02:37,030
problem to frame it up just with some

00:02:34,599 --> 00:02:38,980
some examples here and now sorry don't

00:02:37,030 --> 00:02:40,329
get in trouble we have good searches on

00:02:38,980 --> 00:02:41,739
our platform but I'm going to show you

00:02:40,329 --> 00:02:44,379
some really bad ones

00:02:41,739 --> 00:02:46,629
so here the query from McDonald's in

00:02:44,379 --> 00:02:50,319
Anaheim California that's just outside

00:02:46,629 --> 00:02:52,540
of Los Angeles ok

00:02:50,319 --> 00:02:56,049
the first three results are ok but what

00:02:52,540 --> 00:03:00,700
happened here I've returned to Starbucks

00:02:56,049 --> 00:03:02,590
results in the top five why is that well

00:03:00,700 --> 00:03:04,269
we're boosting on title we're saying

00:03:02,590 --> 00:03:06,250
that the title is the most important

00:03:04,269 --> 00:03:08,280
thing in this particular case but we

00:03:06,250 --> 00:03:11,560
also are boosting on things that are

00:03:08,280 --> 00:03:13,750
fresh we have a belief that if a job is

00:03:11,560 --> 00:03:16,629
new it's more likely than people apply

00:03:13,750 --> 00:03:18,970
and get hired to it but in this case the

00:03:16,629 --> 00:03:21,790
English analyzer has done a nice match

00:03:18,970 --> 00:03:24,040
for us on the title of McDonald's Avenue

00:03:21,790 --> 00:03:27,910
in Westminster California which is

00:03:24,040 --> 00:03:29,829
giving us a pretty poor result so let's

00:03:27,910 --> 00:03:32,889
go to Compton California and this result

00:03:29,829 --> 00:03:35,500
get way worse Starbucks is my first

00:03:32,889 --> 00:03:37,660
result the reason for that is because

00:03:35,500 --> 00:03:40,239
that zip code doesn't have any open

00:03:37,660 --> 00:03:43,930
positions so those things get boosted

00:03:40,239 --> 00:03:45,940
right to the top let's go across the

00:03:43,930 --> 00:03:46,510
country to New York City this is Carroll

00:03:45,940 --> 00:03:50,079
Gardens

00:03:46,510 --> 00:03:52,030
so same query so you can see here the

00:03:50,079 --> 00:03:57,010
first three results all five McDonald's

00:03:52,030 --> 00:04:00,669
it's relatively high recall those are 15

00:03:57,010 --> 00:04:02,410
to 20 miles away ok still seems like it

00:04:00,669 --> 00:04:08,079
could work except in this particular

00:04:02,410 --> 00:04:09,879
geography that's really bad if you've

00:04:08,079 --> 00:04:12,760
been to New York City no one's going to

00:04:09,879 --> 00:04:14,590
do this it's about 46 miles away it'd

00:04:12,760 --> 00:04:17,260
probably take you two hours or you could

00:04:14,590 --> 00:04:21,310
probably get a canoe across the Hudson

00:04:17,260 --> 00:04:25,360
Bay snow water taxi yeah it's not not

00:04:21,310 --> 00:04:27,340
good so this makes us sad let's look at

00:04:25,360 --> 00:04:28,960
some data so this is a distribution of

00:04:27,340 --> 00:04:31,120
key words on our platform over the

00:04:28,960 --> 00:04:33,070
course of a week you'll notice here that

00:04:31,120 --> 00:04:34,570
we're lucky when we get a brand so those

00:04:33,070 --> 00:04:36,550
queries that I just gave right there

00:04:34,570 --> 00:04:38,230
that I'd give an example of are

00:04:36,550 --> 00:04:39,580
even very common what's more common is

00:04:38,230 --> 00:04:40,390
that people are saying I want a

00:04:39,580 --> 00:04:43,840
part-time job

00:04:40,390 --> 00:04:45,310
I want full-time job the problem with

00:04:43,840 --> 00:04:47,950
that is that that matches almost every

00:04:45,310 --> 00:04:50,320
document that we have in our index so

00:04:47,950 --> 00:04:52,270
yes we can filter down by location but

00:04:50,320 --> 00:04:54,070
here's an example of this so this is a

00:04:52,270 --> 00:04:57,040
search that same search for part-time

00:04:54,070 --> 00:04:59,800
here and the first three results are

00:04:57,040 --> 00:05:01,690
special skills that I don't have so this

00:04:59,800 --> 00:05:04,960
search is extremely not personalized to

00:05:01,690 --> 00:05:07,870
me this is the real problem we have

00:05:04,960 --> 00:05:12,180
hand-tuned relevance the vector space

00:05:07,870 --> 00:05:14,590
model BM 25 etc doesn't work for us so

00:05:12,180 --> 00:05:16,540
field booths are extremely complicated

00:05:14,590 --> 00:05:18,820
they're difficult to maintain we have

00:05:16,540 --> 00:05:20,530
tons of rules when you fix one it

00:05:18,820 --> 00:05:22,450
creates a problem somewhere else when

00:05:20,530 --> 00:05:24,520
you fix that somewhere else it creates a

00:05:22,450 --> 00:05:26,860
problem in places that we don't know

00:05:24,520 --> 00:05:28,060
until we've delivered bad results to our

00:05:26,860 --> 00:05:30,970
workers and that's something that we

00:05:28,060 --> 00:05:33,700
don't want to do geography plays a very

00:05:30,970 --> 00:05:35,560
important factor in relevance so just

00:05:33,700 --> 00:05:37,960
like you saw in New York City that same

00:05:35,560 --> 00:05:40,480
40 mile commute could be okay if you're

00:05:37,960 --> 00:05:44,590
in a smaller or a smaller metropolitan

00:05:40,480 --> 00:05:47,440
area humans are complicated trying to

00:05:44,590 --> 00:05:50,200
create heuristics around psychology and

00:05:47,440 --> 00:05:55,570
human behavior is an incredibly hard

00:05:50,200 --> 00:05:57,490
thing to do so this is where we decided

00:05:55,570 --> 00:05:58,870
that learning to rank was something that

00:05:57,490 --> 00:06:01,300
we were interested in doing we saw the

00:05:58,870 --> 00:06:04,360
talk from Bloomberg leasing Revolution

00:06:01,300 --> 00:06:06,310
got inspired by that and then decided

00:06:04,360 --> 00:06:08,500
that we're a data-driven company to

00:06:06,310 --> 00:06:12,670
begin with we want to use our data to

00:06:08,500 --> 00:06:15,810
drive our user relevance so we partnered

00:06:12,670 --> 00:06:17,980
with Doug and open source connections to

00:06:15,810 --> 00:06:19,510
implement learning to rank in production

00:06:17,980 --> 00:06:22,600
to completely rebuild our whole search

00:06:19,510 --> 00:06:25,150
experience so now kick it over to Doug

00:06:22,600 --> 00:06:27,550
yeah sure so that kind of frames the

00:06:25,150 --> 00:06:29,350
picture and I want to talk more about

00:06:27,550 --> 00:06:31,840
learning to rank in general not just in

00:06:29,350 --> 00:06:33,220
terms of job search but often when

00:06:31,840 --> 00:06:36,010
you're doing these relevance problems

00:06:33,220 --> 00:06:39,070
you might start out trying to gather a

00:06:36,010 --> 00:06:40,450
sense of correctness for your search so

00:06:39,070 --> 00:06:42,850
in this case we're switching a movie

00:06:40,450 --> 00:06:45,310
search and we've got Ramba a bunch of

00:06:42,850 --> 00:06:49,390
Rambo searches and we've decided to

00:06:45,310 --> 00:06:50,300
grade them and grade here and usually in

00:06:49,390 --> 00:06:53,090
search you know you

00:06:50,300 --> 00:06:55,280
have four means it's an exact perfect

00:06:53,090 --> 00:06:59,300
match zero means it's a horrible match

00:06:55,280 --> 00:07:02,599
so we've got Rambo as a great match for

00:06:59,300 --> 00:07:05,419
the keyword search Rambo obviously first

00:07:02,599 --> 00:07:09,830
daughter is an absolute terrible result

00:07:05,419 --> 00:07:12,289
for Rambo same with rocky and this sort

00:07:09,830 --> 00:07:16,330
of forms the basis of how people might

00:07:12,289 --> 00:07:19,129
often tune relevance I call this a

00:07:16,330 --> 00:07:21,440
test-driven relevancy where you have

00:07:19,129 --> 00:07:23,389
some correctness data in some cases you

00:07:21,440 --> 00:07:24,979
might just have as little as 50 queries

00:07:23,389 --> 00:07:28,520
you might have thousands of queries and

00:07:24,979 --> 00:07:30,560
as you're testing and manually tuning

00:07:28,520 --> 00:07:33,259
search results you're getting a sense of

00:07:30,560 --> 00:07:36,139
okay when I tweaked this title boost

00:07:33,259 --> 00:07:37,940
Rambo got better but rocky got worse and

00:07:36,139 --> 00:07:40,610
you can get a sense as you're iterating

00:07:37,940 --> 00:07:42,110
on search how whether or not you're

00:07:40,610 --> 00:07:46,000
going in the right direction as a

00:07:42,110 --> 00:07:49,520
developer as your hand tuning so

00:07:46,000 --> 00:07:52,789
learning to rank differs because instead

00:07:49,520 --> 00:07:56,810
of focusing on tuning hand tuning this

00:07:52,789 --> 00:07:58,669
search engine you're focused on a model

00:07:56,810 --> 00:08:02,000
you're using the same kind of data as a

00:07:58,669 --> 00:08:03,919
training set for building a machine

00:08:02,000 --> 00:08:07,190
learning model that can rank results for

00:08:03,919 --> 00:08:09,380
you and instead of iterating offline or

00:08:07,190 --> 00:08:12,860
on a maybe tweaking boosted why not

00:08:09,380 --> 00:08:14,930
you're really getting at you're playing

00:08:12,860 --> 00:08:16,190
with a model separating training and

00:08:14,930 --> 00:08:18,259
test data if you've ever done any

00:08:16,190 --> 00:08:20,060
machine learning work training a model

00:08:18,259 --> 00:08:22,789
testing it out to see how accurate it is

00:08:20,060 --> 00:08:25,340
and the value is Jason kind of said for

00:08:22,789 --> 00:08:27,080
you is learning to rank I think is

00:08:25,340 --> 00:08:29,680
really valuable especially when you get

00:08:27,080 --> 00:08:33,140
into tree based and SVM based models on

00:08:29,680 --> 00:08:35,180
capturing a lot of context

00:08:33,140 --> 00:08:38,360
linear base where you're just tweaking

00:08:35,180 --> 00:08:41,300
the weights on boosts often can't get at

00:08:38,360 --> 00:08:43,459
the context of in this geography this

00:08:41,300 --> 00:08:45,140
certain skill yorkers have the certain

00:08:43,459 --> 00:08:48,230
skill more or this certain distance

00:08:45,140 --> 00:08:50,000
matters more or less because of how

00:08:48,230 --> 00:08:51,320
difficult the commute is so you really

00:08:50,000 --> 00:08:53,720
get at these sort of contextual

00:08:51,320 --> 00:08:58,320
situations that are really dependent on

00:08:53,720 --> 00:09:01,310
where you are so

00:08:58,320 --> 00:09:03,990
learning to rank with elasticsearch is

00:09:01,310 --> 00:09:06,269
basically baking that model that you

00:09:03,990 --> 00:09:09,540
trained into the search engine so you

00:09:06,269 --> 00:09:11,009
take the brains that you just trained

00:09:09,540 --> 00:09:14,190
maybe you feel like it's pretty accurate

00:09:11,009 --> 00:09:16,380
and if you solve the Bloomberg talk you

00:09:14,190 --> 00:09:18,750
basic you saw them do this at the demo

00:09:16,380 --> 00:09:22,110
with solar but you take that model and

00:09:18,750 --> 00:09:24,480
you give it to the search engine and you

00:09:22,110 --> 00:09:26,579
put it in there and you you have a

00:09:24,480 --> 00:09:29,430
baseline ranking function maybe you

00:09:26,579 --> 00:09:31,500
retrieve just do simple tf-idf scoring

00:09:29,430 --> 00:09:33,329
on a couple fields a little bit of hand

00:09:31,500 --> 00:09:36,259
tuning and then you use your model to

00:09:33,329 --> 00:09:38,190
rescore the top and search results

00:09:36,259 --> 00:09:39,899
elasticsearch and solar both have

00:09:38,190 --> 00:09:42,089
restoring capabilities or rewriting

00:09:39,899 --> 00:09:44,040
capabilities they'll let you execute a

00:09:42,089 --> 00:09:45,690
query on a window of your top search

00:09:44,040 --> 00:09:47,819
results and it gives you the chance to

00:09:45,690 --> 00:09:50,899
shuffle things up to the top based on

00:09:47,819 --> 00:09:54,300
the contextual clues of say geography

00:09:50,899 --> 00:09:58,079
personalization all kinds of signals

00:09:54,300 --> 00:09:59,459
that you can use during ranking so I was

00:09:58,079 --> 00:10:02,790
going to fix that that says judgment

00:09:59,459 --> 00:10:05,990
listed training set how learning to rank

00:10:02,790 --> 00:10:09,569
works in elasticsearch very briefly is

00:10:05,990 --> 00:10:11,459
our plugin we start with this CSV file

00:10:09,569 --> 00:10:13,380
that maybe we hand generated maybe it

00:10:11,459 --> 00:10:16,079
came from analytics maybe our domain

00:10:13,380 --> 00:10:20,040
experts told us about it and we use this

00:10:16,079 --> 00:10:22,980
to go off and gather relevant scores for

00:10:20,040 --> 00:10:25,199
features we hypothesize correlate with

00:10:22,980 --> 00:10:29,269
relevance now just like in the solar

00:10:25,199 --> 00:10:32,639
plug and features correspond here to a

00:10:29,269 --> 00:10:34,440
elastic search query so here this is a

00:10:32,639 --> 00:10:36,779
simple feature that's the type tf-idf

00:10:34,440 --> 00:10:39,180
score of the title field for the

00:10:36,779 --> 00:10:41,100
keywords and you can see here and this

00:10:39,180 --> 00:10:43,500
is a file format that's a sort of

00:10:41,100 --> 00:10:44,550
canonical way of doing these training

00:10:43,500 --> 00:10:47,730
sets for relevance

00:10:44,550 --> 00:10:50,189
we've given all our queries an ID we

00:10:47,730 --> 00:10:52,139
don't need the document ID anymore we

00:10:50,189 --> 00:10:54,810
left the grade in the Left column so

00:10:52,139 --> 00:10:56,880
Rambo is query ID one Rocky's query add

00:10:54,810 --> 00:10:58,709
a two and we started to fill in

00:10:56,880 --> 00:11:01,170
different features we hypothesize might

00:10:58,709 --> 00:11:02,699
correspond to relevance based on us

00:11:01,170 --> 00:11:04,889
going to the last exertion saying hey

00:11:02,699 --> 00:11:06,660
can you take this document do a title

00:11:04,889 --> 00:11:09,010
run this query on it and give me the

00:11:06,660 --> 00:11:10,720
score and you'd run this

00:11:09,010 --> 00:11:13,210
take this document run this other query

00:11:10,720 --> 00:11:16,360
and you can the with a lots of search

00:11:13,210 --> 00:11:18,460
query DSL you get your creative you have

00:11:16,360 --> 00:11:20,980
no bounds on your creativity you can go

00:11:18,460 --> 00:11:22,930
and use all kinds of query primitives to

00:11:20,980 --> 00:11:28,180
build up your your features that you

00:11:22,930 --> 00:11:30,790
might think are important now we have

00:11:28,180 --> 00:11:32,140
the elastic search query DSL or elastic

00:11:30,790 --> 00:11:35,620
search wanting to rank plugin works it

00:11:32,140 --> 00:11:39,190
integrates with rank Lib which is an

00:11:35,620 --> 00:11:43,270
academic developed learning to rank

00:11:39,190 --> 00:11:46,300
system library and what it does

00:11:43,270 --> 00:11:50,320
basically is takes these rank lid models

00:11:46,300 --> 00:11:53,110
and you can evaluate them and here we've

00:11:50,320 --> 00:11:55,420
taken our training set on the left and

00:11:53,110 --> 00:11:57,310
rank Lib can be run at the command line

00:11:55,420 --> 00:11:58,900
Java dash jar rank live with a bunch of

00:11:57,310 --> 00:12:01,210
command line parameters and we've

00:11:58,900 --> 00:12:02,800
trained a model we spit out a model and

00:12:01,210 --> 00:12:05,770
in this case it's an ensemble of

00:12:02,800 --> 00:12:09,130
decision trees a model a model News

00:12:05,770 --> 00:12:10,780
lambda mark and you can see here that in

00:12:09,130 --> 00:12:12,220
this case decision trees are actually

00:12:10,780 --> 00:12:14,920
really good at getting at different

00:12:12,220 --> 00:12:17,140
context because if you could say if in

00:12:14,920 --> 00:12:19,780
New York if the distances this look

00:12:17,140 --> 00:12:20,920
double check the commute distance do

00:12:19,780 --> 00:12:23,710
with all these other things and there's

00:12:20,920 --> 00:12:25,630
no way you as a hand tuning person could

00:12:23,710 --> 00:12:28,480
do that without an extensive amount of

00:12:25,630 --> 00:12:31,000
ridiculous number of rules so you can

00:12:28,480 --> 00:12:33,010
see here that we have the first two

00:12:31,000 --> 00:12:35,440
levels of this decision tree our feature

00:12:33,010 --> 00:12:37,600
to which was our body score

00:12:35,440 --> 00:12:40,330
it's basically go left if it's less than

00:12:37,600 --> 00:12:41,500
that threshold and then eventually we

00:12:40,330 --> 00:12:43,750
get to a title score and we have a

00:12:41,500 --> 00:12:46,500
threshold of zero and it'll output a

00:12:43,750 --> 00:12:49,000
score negative two

00:12:46,500 --> 00:12:50,770
interestingly in both cases which is

00:12:49,000 --> 00:12:54,130
sometimes the fun part of machine

00:12:50,770 --> 00:12:56,560
learning model so what is the last

00:12:54,130 --> 00:12:58,480
search wanting to rank plug into the

00:12:56,560 --> 00:13:00,640
first thing it does accepts these models

00:12:58,480 --> 00:13:03,010
basically using elastic searches

00:13:00,640 --> 00:13:05,320
scripting functionality and that has a

00:13:03,010 --> 00:13:07,000
lot of nice features like not having to

00:13:05,320 --> 00:13:08,980
us to have to think about clustering or

00:13:07,000 --> 00:13:11,500
anything scripts automatically get

00:13:08,980 --> 00:13:14,410
distributed around the cluster they get

00:13:11,500 --> 00:13:16,570
cached and you can store them in the

00:13:14,410 --> 00:13:18,700
file system you can post them you can

00:13:16,570 --> 00:13:20,380
even inline them which is for anything

00:13:18,700 --> 00:13:21,480
that's non-trivial you probably don't

00:13:20,380 --> 00:13:24,180
want to do

00:13:21,480 --> 00:13:26,880
in your query and I can give it a name

00:13:24,180 --> 00:13:28,649
so here I've got a scripting plug-in

00:13:26,880 --> 00:13:31,920
called rank Lib that the plugin has

00:13:28,649 --> 00:13:34,829
added and I'm sending that script I just

00:13:31,920 --> 00:13:37,260
showed you up to rank lip and you do

00:13:34,829 --> 00:13:39,480
need to crank up the setting on

00:13:37,260 --> 00:13:44,100
elasticsearch for the maximum size of a

00:13:39,480 --> 00:13:47,010
script so once you have a model the

00:13:44,100 --> 00:13:49,050
other thing the plug-in does is it gives

00:13:47,010 --> 00:13:50,579
you a model you can tell it the model

00:13:49,050 --> 00:13:52,980
you want to execute in this case Doug's

00:13:50,579 --> 00:13:55,320
model that we just created and you

00:13:52,980 --> 00:13:58,050
restate the features that you are using

00:13:55,320 --> 00:14:02,040
so feature one unfortunately ranked lip

00:13:58,050 --> 00:14:04,860
syncs in one based indexing and feature

00:14:02,040 --> 00:14:06,089
to go in the features list and then

00:14:04,860 --> 00:14:09,389
you're just telling it which model to

00:14:06,089 --> 00:14:12,180
execute the nice thing about this being

00:14:09,389 --> 00:14:15,630
a part of the query DSL is you can wrap

00:14:12,180 --> 00:14:17,220
it in business rules or do all kinds of

00:14:15,630 --> 00:14:19,500
stuff you have a lot of freedom you can

00:14:17,220 --> 00:14:21,570
add filters you can make it part of your

00:14:19,500 --> 00:14:23,730
solution potentially you could execute

00:14:21,570 --> 00:14:26,279
two or three learning to rank models if

00:14:23,730 --> 00:14:29,160
you wanted to sort of like open to your

00:14:26,279 --> 00:14:32,370
creativity but of course you ought to do

00:14:29,160 --> 00:14:34,199
use this in the context of restoring so

00:14:32,370 --> 00:14:36,810
we don't actually enforce in this plugin

00:14:34,199 --> 00:14:39,209
that you do restoring in fact our

00:14:36,810 --> 00:14:40,620
company's blog is done in learning to

00:14:39,209 --> 00:14:42,300
rank and I don't do any restoring

00:14:40,620 --> 00:14:44,819
because there's about seven or eight

00:14:42,300 --> 00:14:47,069
hundred blog posts and I don't worry

00:14:44,819 --> 00:14:49,260
about that and it works pretty fast in

00:14:47,069 --> 00:14:51,959
this case we're actually narrowing it

00:14:49,260 --> 00:14:55,560
down to the top 500 and you can see with

00:14:51,959 --> 00:14:57,720
elasticsearch we're getting at that the

00:14:55,560 --> 00:14:59,160
same query I said below and then up top

00:14:57,720 --> 00:15:00,990
wherever I query I've got my baseline

00:14:59,160 --> 00:15:05,100
relevant so that I maybe have hand to it

00:15:00,990 --> 00:15:07,470
a little bit so I think what's

00:15:05,100 --> 00:15:08,970
interesting is I see when people talk

00:15:07,470 --> 00:15:11,699
about learning to rank I generally see

00:15:08,970 --> 00:15:13,800
two solutions one is people baked

00:15:11,699 --> 00:15:15,600
something into the search engine and the

00:15:13,800 --> 00:15:17,310
other is maybe they have an API also the

00:15:15,600 --> 00:15:19,829
search engine where they prefetch like a

00:15:17,310 --> 00:15:21,120
bunch of results and I really like the

00:15:19,829 --> 00:15:24,839
approach of making it in the search

00:15:21,120 --> 00:15:27,000
engine even though it's you know you

00:15:24,839 --> 00:15:28,889
it's more challenging potentially if you

00:15:27,000 --> 00:15:30,209
don't have a plug-in to do this the

00:15:28,889 --> 00:15:32,060
reason I like baking this into the

00:15:30,209 --> 00:15:34,670
search engine is

00:15:32,060 --> 00:15:36,260
performance is one reason you can sort

00:15:34,670 --> 00:15:39,590
of pre-filter you don't to prefetch a

00:15:36,260 --> 00:15:42,350
thousand results and the second point is

00:15:39,590 --> 00:15:44,180
actually really important you search

00:15:42,350 --> 00:15:46,160
engines are basically built to do these

00:15:44,180 --> 00:15:48,890
query dependent features these ranking

00:15:46,160 --> 00:15:50,570
signals to get at like to measure the

00:15:48,890 --> 00:15:53,570
tf-idf score of different titles and

00:15:50,570 --> 00:15:55,490
it's really got this amazing rich DSL

00:15:53,570 --> 00:15:57,380
already built in for ranking and sorting

00:15:55,490 --> 00:16:01,250
things that people are already using to

00:15:57,380 --> 00:16:02,630
build sophisticated search systems and I

00:16:01,250 --> 00:16:04,100
already mentioned business rules so we

00:16:02,630 --> 00:16:05,810
could layer business rules on top of

00:16:04,100 --> 00:16:07,880
this or figure out a way to do that with

00:16:05,810 --> 00:16:09,440
a query a DSL and finally I think

00:16:07,880 --> 00:16:11,840
probably the thing that people take most

00:16:09,440 --> 00:16:14,270
for granted are just the dumb basic

00:16:11,840 --> 00:16:16,820
functionality that no one no one pulls

00:16:14,270 --> 00:16:18,680
their hair out of out about that gets

00:16:16,820 --> 00:16:21,590
excited about but you really still want

00:16:18,680 --> 00:16:22,700
facets paging grouping you want to do

00:16:21,590 --> 00:16:24,590
all these things you want to get

00:16:22,700 --> 00:16:26,180
autocomplete and spell checking and just

00:16:24,590 --> 00:16:28,940
get these bells and whistles that people

00:16:26,180 --> 00:16:31,520
expect from a search solution and

00:16:28,940 --> 00:16:32,510
building something maybe outside to do

00:16:31,520 --> 00:16:33,590
your rewriting

00:16:32,510 --> 00:16:37,610
you're going to have to take you all

00:16:33,590 --> 00:16:39,260
that to account so I'm going to go

00:16:37,610 --> 00:16:42,290
through a bunch of lessons that we

00:16:39,260 --> 00:16:45,170
learned so that was the happy path

00:16:42,290 --> 00:16:46,640
everything is great and yes it was not

00:16:45,170 --> 00:16:49,520
that hard to get this to work for our

00:16:46,640 --> 00:16:51,410
blog but when you go to a real

00:16:49,520 --> 00:16:54,830
production system that's not 800 blog

00:16:51,410 --> 00:16:58,660
posts like we did with Snagajob we

00:16:54,830 --> 00:17:02,140
started learning lessons the hard way so

00:16:58,660 --> 00:17:05,360
the first lesson I want to talk about is

00:17:02,140 --> 00:17:06,650
judgments are really hard to get really

00:17:05,360 --> 00:17:09,410
good judgments are really hard to get

00:17:06,650 --> 00:17:11,240
and I think people often don't take into

00:17:09,410 --> 00:17:13,310
account that the hard part about search

00:17:11,240 --> 00:17:15,890
is often measuring user behavior and

00:17:13,310 --> 00:17:17,750
measuring what good searches sometimes

00:17:15,890 --> 00:17:20,690
that's a lot more challenging than

00:17:17,750 --> 00:17:23,090
actually doing the whatever fancy

00:17:20,690 --> 00:17:25,190
relevance work you're going to do it's

00:17:23,090 --> 00:17:27,320
easy to get excited about solutions it's

00:17:25,190 --> 00:17:29,930
sometimes less exciting the less easy to

00:17:27,320 --> 00:17:32,590
get excited about okay was this good or

00:17:29,930 --> 00:17:35,060
bad or how can we figure this out and

00:17:32,590 --> 00:17:37,340
you know there's a lot of ways we could

00:17:35,060 --> 00:17:40,670
define what good searches that's like

00:17:37,340 --> 00:17:42,980
graphic from my book by mr. Berryman who

00:17:40,670 --> 00:17:46,399
is an ink scape

00:17:42,980 --> 00:17:48,289
and these you know you might have the

00:17:46,399 --> 00:17:50,419
developer say you know we have sue and

00:17:48,289 --> 00:17:52,190
marketing you CEO comes in and my

00:17:50,419 --> 00:17:53,750
colleague Eric Pugh likes to refer to

00:17:52,190 --> 00:17:56,360
the hippo the highest paid person's

00:17:53,750 --> 00:17:58,039
opinion the CEO comes in and says why is

00:17:56,360 --> 00:18:00,500
this broken you're like well it doesn't

00:17:58,039 --> 00:18:01,880
we no one ever searches for that people

00:18:00,500 --> 00:18:03,590
have pet peeve queries there's a

00:18:01,880 --> 00:18:06,320
bazillion read ways you can go about

00:18:03,590 --> 00:18:09,500
getting this data and there's really no

00:18:06,320 --> 00:18:11,809
one-size-fits-all and in my work doing

00:18:09,500 --> 00:18:13,340
relevance I've seen this sort of roughly

00:18:11,809 --> 00:18:16,909
and this isn't a hundred percent like

00:18:13,340 --> 00:18:19,370
perfect dichotomy but roughly the

00:18:16,909 --> 00:18:21,139
spectrum of search solutions on the Left

00:18:19,370 --> 00:18:23,360
which are very consumer facing that are

00:18:21,139 --> 00:18:25,340
focused on analytics they have a lot of

00:18:23,360 --> 00:18:26,840
ability to get analytics and search

00:18:25,340 --> 00:18:29,110
solutions on the right which are more

00:18:26,840 --> 00:18:31,460
focused on knowledge management where

00:18:29,110 --> 00:18:33,980
maybe there's 50 users and they're all

00:18:31,460 --> 00:18:35,539
doctors and trying to get five of them

00:18:33,980 --> 00:18:39,559
in the room to tell you why search is

00:18:35,539 --> 00:18:42,409
broken is really hard and on the left

00:18:39,559 --> 00:18:44,240
you have you have problems of trying to

00:18:42,409 --> 00:18:46,490
figure out like okay I've got all this

00:18:44,240 --> 00:18:48,350
analytics but I can't go and talk to

00:18:46,490 --> 00:18:50,450
that person and ask them why they

00:18:48,350 --> 00:18:52,190
clicked on this thing and so you're

00:18:50,450 --> 00:18:56,269
constantly looking at analytics trying

00:18:52,190 --> 00:18:58,549
to get at why why on the right with

00:18:56,269 --> 00:18:59,929
experts you can at least go to someone

00:18:58,549 --> 00:19:01,490
and talk to them and get them to tell

00:18:59,929 --> 00:19:03,860
you why something was relevant or

00:19:01,490 --> 00:19:06,409
irrelevant so you can get a better sense

00:19:03,860 --> 00:19:12,289
of how you should be constructing these

00:19:06,409 --> 00:19:14,149
judgment lists and the on the left the

00:19:12,289 --> 00:19:16,309
one of the big one of the big costs is

00:19:14,149 --> 00:19:18,679
really just infrastructure code for

00:19:16,309 --> 00:19:21,019
analytics like anyone who does a lot of

00:19:18,679 --> 00:19:22,460
really in-depth like I know Snagajob

00:19:21,019 --> 00:19:24,169
there's a lot of infrastructure to

00:19:22,460 --> 00:19:27,139
gather analytics about how people

00:19:24,169 --> 00:19:28,850
interacting research on the right of

00:19:27,139 --> 00:19:31,460
course as I said the cost is actually

00:19:28,850 --> 00:19:33,049
getting like a room of paying a dot five

00:19:31,460 --> 00:19:35,720
doctors to sit in a room for you for a

00:19:33,049 --> 00:19:36,980
day and then doing that every week until

00:19:35,720 --> 00:19:39,250
you get your search to where you want it

00:19:36,980 --> 00:19:39,250
to be

00:19:42,140 --> 00:19:48,230
yeah so one big takeaway is there's a

00:19:46,100 --> 00:19:50,330
lot of non-technical domain expertise to

00:19:48,230 --> 00:19:52,790
do either of these situations even

00:19:50,330 --> 00:19:54,830
analytics you sort of need to know your

00:19:52,790 --> 00:19:57,049
domain really well to understand why do

00:19:54,830 --> 00:20:00,350
hourly workers do certain things for

00:19:57,049 --> 00:20:04,220
example in Snagajob so the other thing

00:20:00,350 --> 00:20:05,540
we learned is grade consistency like you

00:20:04,220 --> 00:20:06,830
really need a good standard when you're

00:20:05,540 --> 00:20:09,200
building judgment lists for when

00:20:06,830 --> 00:20:11,570
something is a four versus something is

00:20:09,200 --> 00:20:14,600
a three and what you want to really

00:20:11,570 --> 00:20:17,840
avoid is having like relative grades so

00:20:14,600 --> 00:20:19,910
if something is this you may be on our

00:20:17,840 --> 00:20:22,940
blog for example I think I have an

00:20:19,910 --> 00:20:26,690
example of that we have someone searches

00:20:22,940 --> 00:20:28,130
for Enterprise Service bus and the best

00:20:26,690 --> 00:20:30,140
thing we might have when use your

00:20:28,130 --> 00:20:33,230
Enterprise Service bus is a bunch of old

00:20:30,140 --> 00:20:35,600
camel articles now when I'm saying

00:20:33,230 --> 00:20:39,530
what's my golden set for this query it's

00:20:35,600 --> 00:20:42,500
easy to say I think I'll make that a

00:20:39,530 --> 00:20:44,360
four that's the best I can do but in

00:20:42,500 --> 00:20:46,520
reality you sort of need to be really

00:20:44,360 --> 00:20:48,919
consistent on your criteria and be ok

00:20:46,520 --> 00:20:52,370
that you're going to have queries that

00:20:48,919 --> 00:20:53,870
the best thing might be a 2 out of 4 you

00:20:52,370 --> 00:20:56,600
just might not have good content for

00:20:53,870 --> 00:20:58,429
that query and to be really consistent

00:20:56,600 --> 00:21:00,140
because you're going to train something

00:20:58,429 --> 00:21:04,130
that's a function of a bunch of features

00:21:00,140 --> 00:21:05,780
so a for-real SP a lot easier for your

00:21:04,130 --> 00:21:09,080
models to predict like one of four is a

00:21:05,780 --> 00:21:10,580
4 and y 4 is a 4 so coming up with sort

00:21:09,080 --> 00:21:12,650
of consistent criteria whether you're

00:21:10,580 --> 00:21:15,380
using domain expertise or you're

00:21:12,650 --> 00:21:21,710
gathering analytics is really important

00:21:15,380 --> 00:21:23,390
for this kind of work so just change the

00:21:21,710 --> 00:21:25,429
background of that like upper right

00:21:23,390 --> 00:21:27,260
thing so what should you optimize for

00:21:25,429 --> 00:21:31,070
and there's a bunch of search metrics

00:21:27,260 --> 00:21:33,230
that you can think about precision is

00:21:31,070 --> 00:21:36,830
sort of like the proportion of good

00:21:33,230 --> 00:21:40,910
stuff I have in end results if I have a

00:21:36,830 --> 00:21:43,669
hundred floors and you show me the top

00:21:40,910 --> 00:21:46,370
100 and they're all twos that's a 50%

00:21:43,669 --> 00:21:48,559
precision right so that's a pretty rough

00:21:46,370 --> 00:21:51,950
metric it doesn't necessarily take into

00:21:48,559 --> 00:21:54,140
account the position bias you know just

00:21:51,950 --> 00:21:57,460
a basket of twos and

00:21:54,140 --> 00:22:01,880
how how far from good stuff is that and

00:21:57,460 --> 00:22:04,280
DCG is a metric not mystical normalize

00:22:01,880 --> 00:22:05,960
discount accumulating and it's a metric

00:22:04,280 --> 00:22:09,260
that can tell you the distance your

00:22:05,960 --> 00:22:10,970
search is from a golden set so if you

00:22:09,260 --> 00:22:13,130
take all those judgements and you get

00:22:10,970 --> 00:22:14,870
the ideal ordering you get four four

00:22:13,130 --> 00:22:17,360
four four three three three three and

00:22:14,870 --> 00:22:19,310
you're showing sort of like a to two to

00:22:17,360 --> 00:22:21,440
four to three

00:22:19,310 --> 00:22:22,880
it can give you a sense of how far

00:22:21,440 --> 00:22:26,210
what's the Delta between where you are

00:22:22,880 --> 00:22:28,580
and the best you could be doing and the

00:22:26,210 --> 00:22:31,460
downside to that is if the best you have

00:22:28,580 --> 00:22:34,010
four queries are to your ideal ordering

00:22:31,460 --> 00:22:35,570
might be like two to two to one and if

00:22:34,010 --> 00:22:37,790
you do two to two to one

00:22:35,570 --> 00:22:39,980
you're still going to get a score of one

00:22:37,790 --> 00:22:42,140
and end ECG these scores tend to go from

00:22:39,980 --> 00:22:44,150
zero to one so something to take into

00:22:42,140 --> 00:22:46,520
account is you might be thinking the

00:22:44,150 --> 00:22:47,600
search result is perfect but it's

00:22:46,520 --> 00:22:49,430
actually just saying that you're doing

00:22:47,600 --> 00:22:52,010
your best you can under the certain date

00:22:49,430 --> 00:22:54,890
under given data so that's a area where

00:22:52,010 --> 00:22:58,460
that can be misleading there's another

00:22:54,890 --> 00:23:00,980
statistic that I think is very useful

00:22:58,460 --> 00:23:03,740
that maybe if you've heard of end ECG

00:23:00,980 --> 00:23:06,890
this is even a step more obscure

00:23:03,740 --> 00:23:10,060
it's called expected reciprocal rank er

00:23:06,890 --> 00:23:12,350
R and what this really does is just says

00:23:10,060 --> 00:23:15,410
sort of gets it a sense of whether or

00:23:12,350 --> 00:23:18,860
not users can trust the results so if I

00:23:15,410 --> 00:23:21,530
scan down can I say this is a do I get a

00:23:18,860 --> 00:23:24,470
bunch of fours or do I get a why Nana

00:23:21,530 --> 00:23:26,570
for it has no concept of what the best

00:23:24,470 --> 00:23:28,130
is out there and if you put a it's

00:23:26,570 --> 00:23:30,050
really biased towards like if the top

00:23:28,130 --> 00:23:31,550
one is the top one's really bad you're

00:23:30,050 --> 00:23:34,250
going to have automatically a really bad

00:23:31,550 --> 00:23:36,920
er R so it's just focuses on life as

00:23:34,250 --> 00:23:39,320
user scan down results are you pretty

00:23:36,920 --> 00:23:42,290
close to having something that looks

00:23:39,320 --> 00:23:46,940
trustworthy good and this will actually

00:23:42,290 --> 00:23:48,410
think if there is a you know a - and the

00:23:46,940 --> 00:23:50,360
best you have for the search results

00:23:48,410 --> 00:23:52,220
search query is a - you'll still get

00:23:50,360 --> 00:23:55,880
like a low ARR and that will kind of

00:23:52,220 --> 00:23:57,460
point at where end ECG maybe doesn't

00:23:55,880 --> 00:24:00,020
tell give you this information

00:23:57,460 --> 00:24:02,300
so at Snagajob actually I think there's

00:24:00,020 --> 00:24:04,790
a balance of ND c g and e RR which Jason

00:24:02,300 --> 00:24:06,920
will talk about so of course what should

00:24:04,790 --> 00:24:09,500
we optimize for the answer is yes

00:24:06,920 --> 00:24:12,620
so this is pretty domain-specific if if

00:24:09,500 --> 00:24:15,770
you're pretty focused on showing experts

00:24:12,620 --> 00:24:19,730
all of the information that is possible

00:24:15,770 --> 00:24:21,860
sort of bore more recall focus you might

00:24:19,730 --> 00:24:24,290
folk you might think about nd CG over a

00:24:21,860 --> 00:24:25,820
certain set if you just care about

00:24:24,290 --> 00:24:27,920
whether or not results look good which

00:24:25,820 --> 00:24:30,110
is often good and when people are

00:24:27,920 --> 00:24:33,650
building trust with an application er R

00:24:30,110 --> 00:24:35,450
is really important so the other less

00:24:33,650 --> 00:24:40,130
painful lesson we learned is accuracy

00:24:35,450 --> 00:24:43,460
versus speed it's really easy we gave at

00:24:40,130 --> 00:24:46,850
Snagajob data science issue and had got

00:24:43,460 --> 00:24:48,290
extremely beefy ec2 machine you can

00:24:46,850 --> 00:24:50,660
imagine getting a spark cluster to do

00:24:48,290 --> 00:24:53,420
your training it's easy to be on the

00:24:50,660 --> 00:24:55,340
left here with your with your machine

00:24:53,420 --> 00:24:57,140
learning training infrastructure or

00:24:55,340 --> 00:24:58,850
you've got the Deathstar and you're

00:24:57,140 --> 00:25:00,950
going to build the world's most accurate

00:24:58,850 --> 00:25:03,650
perfect model with all the compute you

00:25:00,950 --> 00:25:05,180
have but your search infrastructure is

00:25:03,650 --> 00:25:07,100
very different than that when it

00:25:05,180 --> 00:25:08,450
executes models it sort of got to shoot

00:25:07,100 --> 00:25:10,700
all these little fighters out of the sky

00:25:08,450 --> 00:25:12,200
because it's got like very short amount

00:25:10,700 --> 00:25:13,400
of time to get rid of them all or else

00:25:12,200 --> 00:25:16,130
like the whole thing is going to crash

00:25:13,400 --> 00:25:18,050
down right so you have not a lot of time

00:25:16,130 --> 00:25:20,180
for research requests to evaluate these

00:25:18,050 --> 00:25:21,620
models so it was really important for us

00:25:20,180 --> 00:25:23,210
when we're doing this to sort of think

00:25:21,620 --> 00:25:26,090
through ok what's the right balance

00:25:23,210 --> 00:25:31,280
between accuracy and the performance

00:25:26,090 --> 00:25:33,200
actually in production a model selection

00:25:31,280 --> 00:25:35,090
what kinds of models I mean there's

00:25:33,200 --> 00:25:37,340
ranked SVM there's gradient boosting

00:25:35,090 --> 00:25:39,910
there's random forests of gradient

00:25:37,340 --> 00:25:42,890
boosted trees there's linear models

00:25:39,910 --> 00:25:44,300
linear MA the only I think this matters

00:25:42,890 --> 00:25:46,940
a lot less than people think cuz people

00:25:44,300 --> 00:25:48,620
get excited about models I think once I

00:25:46,940 --> 00:25:51,170
have a model that most people I think

00:25:48,620 --> 00:25:54,290
once they get a family of models they're

00:25:51,170 --> 00:25:56,350
familiar with they tend to worry more

00:25:54,290 --> 00:25:58,430
about sort of garbage in garbage out and

00:25:56,350 --> 00:25:59,630
tuning the hyper parameters of that

00:25:58,430 --> 00:26:02,240
model that in their way they're

00:25:59,630 --> 00:26:05,360
comfortable rather than necessarily like

00:26:02,240 --> 00:26:07,550
having a focusing too much on changing

00:26:05,360 --> 00:26:10,400
out different models I do think one area

00:26:07,550 --> 00:26:12,830
where that's not true is a forced linear

00:26:10,400 --> 00:26:14,570
models linear models are sort of like

00:26:12,830 --> 00:26:18,290
optimizing the boosts in your different

00:26:14,570 --> 00:26:20,380
queries of course like we said with with

00:26:18,290 --> 00:26:22,270
when Jason showed that example

00:26:20,380 --> 00:26:24,520
it's hard to get an optimal sense of

00:26:22,270 --> 00:26:26,380
like in New York you get this

00:26:24,520 --> 00:26:28,000
but in LA you get this you're just going

00:26:26,380 --> 00:26:30,250
to get the average of New York and LA

00:26:28,000 --> 00:26:32,620
and what you prefer is something that

00:26:30,250 --> 00:26:35,770
can get at context you're going to get

00:26:32,620 --> 00:26:36,789
down to like okay if LA do this if New

00:26:35,770 --> 00:26:40,360
York do this other thing

00:26:36,789 --> 00:26:44,770
and so gradient boosting rank SVM those

00:26:40,360 --> 00:26:46,980
sorts of models can get at that and I

00:26:44,770 --> 00:26:49,809
think Grant talked about this yesterday

00:26:46,980 --> 00:26:51,549
but one of the big things that I've sort

00:26:49,809 --> 00:26:54,220
of taken away from my learning to rank

00:26:51,549 --> 00:26:57,909
work is thinking about chaining models

00:26:54,220 --> 00:26:59,559
together both in performance so you know

00:26:57,909 --> 00:27:02,620
a simple linear model to maybe to

00:26:59,559 --> 00:27:04,720
improve precision and then maybe a

00:27:02,620 --> 00:27:07,840
slightly more complicated model to get

00:27:04,720 --> 00:27:09,940
nd CG over a larger set so that you're

00:27:07,840 --> 00:27:12,280
closer to your ideal ranking and then

00:27:09,940 --> 00:27:16,419
maybe er are over a very short set even

00:27:12,280 --> 00:27:18,580
ER at 3 or 2 or 4 to make the first page

00:27:16,419 --> 00:27:20,650
look trustworthy and as you go from left

00:27:18,580 --> 00:27:21,940
to right less the most actually off the

00:27:20,650 --> 00:27:24,039
screen would be like your baseline

00:27:21,940 --> 00:27:25,900
ranking you're getting extreme even more

00:27:24,039 --> 00:27:28,390
sophisticated even more complicated

00:27:25,900 --> 00:27:29,830
models that are slower but doesn't

00:27:28,390 --> 00:27:36,030
matter because you're only doing a

00:27:29,830 --> 00:27:36,030
couple of results even less each time so

00:27:36,210 --> 00:27:41,559
quality and accuracy so this gets out a

00:27:40,150 --> 00:27:45,130
lot of different things whether you're

00:27:41,559 --> 00:27:48,070
tuning model parameters or you're trying

00:27:45,130 --> 00:27:50,169
to figure out which features aka elastic

00:27:48,070 --> 00:27:54,250
search queries actually matter in your

00:27:50,169 --> 00:27:57,580
case and in the case of doing gradient

00:27:54,250 --> 00:27:59,520
boosting it's hard to isolate to one

00:27:57,580 --> 00:28:02,260
feature and say oh this is the thing

00:27:59,520 --> 00:28:04,690
this date boost is the thing that put us

00:28:02,260 --> 00:28:07,299
over the edge and made us that much

00:28:04,690 --> 00:28:10,390
better made us gave us a 90% precision

00:28:07,299 --> 00:28:13,120
or something the reason is is like I

00:28:10,390 --> 00:28:15,340
said showed before gradient boosting is

00:28:13,120 --> 00:28:17,890
a set of decision trees and so things

00:28:15,340 --> 00:28:21,700
often depend on each other it might be

00:28:17,890 --> 00:28:26,049
if you're in this position if you're

00:28:21,700 --> 00:28:28,960
searching for movies if use a strong

00:28:26,049 --> 00:28:31,270
title match may be the recency of the

00:28:28,960 --> 00:28:32,770
movie for example is really important

00:28:31,270 --> 00:28:33,950
because we want to show you the latest

00:28:32,770 --> 00:28:35,990
movie

00:28:33,950 --> 00:28:38,389
The Fast and Furious series for example

00:28:35,990 --> 00:28:41,480
but if you're searching for actors you

00:28:38,389 --> 00:28:42,769
match on actors maybe yours that doesn't

00:28:41,480 --> 00:28:44,779
matter as much and you just kind of want

00:28:42,769 --> 00:28:47,450
a random set of movies and date doesn't

00:28:44,779 --> 00:28:49,250
matter so getting at the figuring out

00:28:47,450 --> 00:28:51,769
what combination of features helps you

00:28:49,250 --> 00:28:53,630
the most is actually more important and

00:28:51,769 --> 00:28:56,929
there's an algorithm called best subset

00:28:53,630 --> 00:29:01,480
selection which sounds fancy but it's

00:28:56,929 --> 00:29:05,210
really a you know an extra four loop and

00:29:01,480 --> 00:29:06,500
my I've just my favorite saying is that

00:29:05,210 --> 00:29:08,240
every machine learning problem can be

00:29:06,500 --> 00:29:10,220
solved by just adding one more outer for

00:29:08,240 --> 00:29:11,600
loop by trying different hyper just

00:29:10,220 --> 00:29:14,029
trying different stuff more hyper

00:29:11,600 --> 00:29:21,980
parameters and of course spark pique a

00:29:14,029 --> 00:29:23,539
spark jobs so before I jump to Jason

00:29:21,980 --> 00:29:25,340
really quickly I want to point out that

00:29:23,539 --> 00:29:28,850
in my opinion this is actually harder

00:29:25,340 --> 00:29:30,200
than doing manual tuning so I think you

00:29:28,850 --> 00:29:31,549
shouldn't necessarily think that you're

00:29:30,200 --> 00:29:34,070
doing learning to rank because it makes

00:29:31,549 --> 00:29:36,860
things easier you have to do a lot more

00:29:34,070 --> 00:29:39,559
stuff on the right on the left we just

00:29:36,860 --> 00:29:41,090
got a fairly simple setup you might have

00:29:39,559 --> 00:29:43,190
some of the stuff on the right like your

00:29:41,090 --> 00:29:44,659
user click stream data but you actually

00:29:43,190 --> 00:29:45,830
need a fair amount of stuff to do

00:29:44,659 --> 00:29:47,539
learning to rank well you need data

00:29:45,830 --> 00:29:49,279
scientists you still need your search

00:29:47,539 --> 00:29:51,559
engineers you're in your state business

00:29:49,279 --> 00:29:52,970
stakeholders and you need to think about

00:29:51,559 --> 00:29:54,559
other problems like how am I going to

00:29:52,970 --> 00:29:58,190
train my models how am I going to get

00:29:54,559 --> 00:30:00,889
analytics or maybe user testing but I

00:29:58,190 --> 00:30:02,840
think this can be a lot more powerful so

00:30:00,889 --> 00:30:05,330
get into learning to rank because doing

00:30:02,840 --> 00:30:08,929
that is really going to get game changer

00:30:05,330 --> 00:30:11,630
to your business it's like it you think

00:30:08,929 --> 00:30:14,210
it's going to be for Snagajob so and

00:30:11,630 --> 00:30:16,580
this is one thought I I left you what I

00:30:14,210 --> 00:30:18,110
want to leave with is because we're

00:30:16,580 --> 00:30:20,450
doing such heavily personalized learning

00:30:18,110 --> 00:30:22,250
to rank we're often thinking about can

00:30:20,450 --> 00:30:24,889
we just use wanting to rank directly to

00:30:22,250 --> 00:30:25,940
do recommendation engines the only

00:30:24,889 --> 00:30:27,830
difference being a search engine a

00:30:25,940 --> 00:30:29,809
recommendation engine is really whether

00:30:27,830 --> 00:30:31,940
or not there's keyword they both rank

00:30:29,809 --> 00:30:33,260
things based on relevance and when

00:30:31,940 --> 00:30:35,870
you're doing heavily personalized search

00:30:33,260 --> 00:30:38,510
we might be at a point where we can say

00:30:35,870 --> 00:30:41,299
here are your recommendations here your

00:30:38,510 --> 00:30:43,010
search all driven by one system so

00:30:41,299 --> 00:30:44,260
that's one thing I'm personally excited

00:30:43,010 --> 00:30:48,760
about

00:30:44,260 --> 00:30:51,070
so I just want to go over kind of how we

00:30:48,760 --> 00:30:52,900
went about implementing learning to rank

00:30:51,070 --> 00:30:56,140
so that everybody here can have kind of

00:30:52,900 --> 00:30:58,120
a tangible plan of how somebody has done

00:30:56,140 --> 00:31:00,000
it in the past or currently we're going

00:30:58,120 --> 00:31:03,340
to hopefully be in production next week

00:31:00,000 --> 00:31:05,590
and and kind of get some ideas from that

00:31:03,340 --> 00:31:08,559
as well as some lessons that we learned

00:31:05,590 --> 00:31:10,390
so step zero before you do anything this

00:31:08,559 --> 00:31:12,460
is such an iterative process you have to

00:31:10,390 --> 00:31:15,090
be okay to fail we failed many many

00:31:12,460 --> 00:31:18,040
times first models did not perform well

00:31:15,090 --> 00:31:19,780
when you do the initial looking at

00:31:18,040 --> 00:31:22,600
results you have to trust your metrics

00:31:19,780 --> 00:31:24,160
it's kind of a kind of a mental shift

00:31:22,600 --> 00:31:26,980
from the way that we normally think of

00:31:24,160 --> 00:31:29,799
things with search relevance step one

00:31:26,980 --> 00:31:31,480
determine how to measure success Doug

00:31:29,799 --> 00:31:33,910
went over these metrics these are the

00:31:31,480 --> 00:31:35,590
two that we selected as far as our cost

00:31:33,910 --> 00:31:37,510
function for our model training we

00:31:35,590 --> 00:31:40,299
picked NDC G at 10 so we're actually

00:31:37,510 --> 00:31:42,520
optimizing for NDC G at 10 one

00:31:40,299 --> 00:31:45,250
interesting thing about this is that UX

00:31:42,520 --> 00:31:48,040
and UI actually have a big part in your

00:31:45,250 --> 00:31:49,809
metrics so our mobile team is developing

00:31:48,040 --> 00:31:51,850
kind of a next-generation application

00:31:49,809 --> 00:31:55,270
which does different groupings of jobs

00:31:51,850 --> 00:31:57,309
which end ECG is basically a positional

00:31:55,270 --> 00:31:59,020
metric and if you group things together

00:31:57,309 --> 00:32:01,059
you could have interesting cases where

00:31:59,020 --> 00:32:03,400
people are getting the search result but

00:32:01,059 --> 00:32:07,960
not even seeing it so something to

00:32:03,400 --> 00:32:10,210
definitely think about step two this is

00:32:07,960 --> 00:32:12,010
super important your baseline ranking

00:32:10,210 --> 00:32:13,600
function is essentially your first query

00:32:12,010 --> 00:32:15,370
that you do to elastic search or

00:32:13,600 --> 00:32:17,890
whatever search engine you're using and

00:32:15,370 --> 00:32:19,900
this is your best guess at getting the

00:32:17,890 --> 00:32:22,900
top K before you pass it into the Ries

00:32:19,900 --> 00:32:24,940
coring phase so our example is use the

00:32:22,900 --> 00:32:28,480
gaussian decay for distance for

00:32:24,940 --> 00:32:30,910
freshness we also use the m25 similarity

00:32:28,480 --> 00:32:32,530
across different fields and then we have

00:32:30,910 --> 00:32:35,860
a Geo radius because most of our

00:32:32,530 --> 00:32:37,419
searches are our geographical kind of

00:32:35,860 --> 00:32:38,890
what we found out is that the the

00:32:37,419 --> 00:32:40,690
distance decay wasn't actually

00:32:38,890 --> 00:32:42,309
aggressive enough and the same with the

00:32:40,690 --> 00:32:43,900
freshness decay so what was happening

00:32:42,309 --> 00:32:46,299
was as bad results we're getting into

00:32:43,900 --> 00:32:48,100
that top 1000 and then it doesn't matter

00:32:46,299 --> 00:32:51,820
once bad results get in there learning

00:32:48,100 --> 00:32:53,230
to rank won't help you so we also have

00:32:51,820 --> 00:32:55,840
some interesting edge cases with

00:32:53,230 --> 00:32:57,500
fastenings we have location facets where

00:32:55,840 --> 00:32:59,330
a user could type in a low

00:32:57,500 --> 00:33:01,100
station without a lot of context they

00:32:59,330 --> 00:33:03,050
could type in Arlington for instance

00:33:01,100 --> 00:33:04,220
well there's an Arlington Texas in the

00:33:03,050 --> 00:33:06,470
United States and there's an Arlington

00:33:04,220 --> 00:33:08,450
Virginia which one do they mean well we

00:33:06,470 --> 00:33:09,800
have to assume that they mean both so

00:33:08,450 --> 00:33:11,600
what that means is that you have the

00:33:09,800 --> 00:33:13,400
union of these two things which now goes

00:33:11,600 --> 00:33:15,920
in and that might be that you have

00:33:13,400 --> 00:33:17,660
10,000 results that are relevant but

00:33:15,920 --> 00:33:19,190
only 1000 that can make it into that

00:33:17,660 --> 00:33:20,930
rear anchor so you have to actually make

00:33:19,190 --> 00:33:24,830
decisions on what actually makes it into

00:33:20,930 --> 00:33:26,000
that top 1000 so current thinking is is

00:33:24,830 --> 00:33:28,340
that we're going to let the baseline

00:33:26,000 --> 00:33:30,170
rank or handle recall and then optimize

00:33:28,340 --> 00:33:33,170
for precision and the in the actual

00:33:30,170 --> 00:33:35,090
rescore saves start small with your

00:33:33,170 --> 00:33:38,060
feature engineering we picked five

00:33:35,090 --> 00:33:40,400
simple things each one of these a brand

00:33:38,060 --> 00:33:42,590
similarity zip code title job

00:33:40,400 --> 00:33:44,960
description and the location are all

00:33:42,590 --> 00:33:47,060
text similarity fields each one of these

00:33:44,960 --> 00:33:51,920
features is an elastic search query it

00:33:47,060 --> 00:33:53,570
each turns into a particular score which

00:33:51,920 --> 00:33:55,700
then that feature gets added into the

00:33:53,570 --> 00:33:58,180
model and these things don't involve a

00:33:55,700 --> 00:34:00,320
lot of complex feature engineering

00:33:58,180 --> 00:34:01,730
improve them constantly you're going to

00:34:00,320 --> 00:34:04,160
always be iterating with your future

00:34:01,730 --> 00:34:06,800
engineering features don't need to be

00:34:04,160 --> 00:34:08,360
searching things what I mean by that is

00:34:06,800 --> 00:34:10,820
they don't need to be similarity scores

00:34:08,360 --> 00:34:12,290
think about content profiles that could

00:34:10,820 --> 00:34:14,780
be learned via content recommender

00:34:12,290 --> 00:34:17,120
system it could be commute distance as a

00:34:14,780 --> 00:34:18,230
function of roads or transit they could

00:34:17,120 --> 00:34:20,179
be market forces

00:34:18,230 --> 00:34:22,159
we're largely in a market place so we're

00:34:20,179 --> 00:34:24,649
subject to macroeconomic forces we can

00:34:22,159 --> 00:34:25,940
model these as part of the the function

00:34:24,649 --> 00:34:29,510
of the search engine and also the

00:34:25,940 --> 00:34:31,700
workers query training models we

00:34:29,510 --> 00:34:33,649
selected lambda Mart we have an

00:34:31,700 --> 00:34:35,149
infrastructure where we have a robust

00:34:33,649 --> 00:34:37,460
data infrastructure collecting user

00:34:35,149 --> 00:34:39,560
signals so we get those user

00:34:37,460 --> 00:34:41,810
interactions we turn them into judgments

00:34:39,560 --> 00:34:43,879
with Apache spark getting future values

00:34:41,810 --> 00:34:46,100
from elasticsearch we then use the

00:34:43,879 --> 00:34:48,980
plugin from open source connections to

00:34:46,100 --> 00:34:50,899
generate those models and then post them

00:34:48,980 --> 00:34:52,940
into elasticsearch this right now is a

00:34:50,899 --> 00:34:55,129
manual process we're turning it into an

00:34:52,940 --> 00:34:58,940
automated process orchestrated with

00:34:55,129 --> 00:35:00,350
Apache air flow this is another thing

00:34:58,940 --> 00:35:03,140
that we're thinking about doing you

00:35:00,350 --> 00:35:06,080
don't also need to just have your user

00:35:03,140 --> 00:35:07,760
signals turn into judgments you can use

00:35:06,080 --> 00:35:10,160
things like waiting factor models to

00:35:07,760 --> 00:35:13,970
actually add additional data

00:35:10,160 --> 00:35:16,640
your to your judgments here's in real

00:35:13,970 --> 00:35:19,460
world considerations ranked live only

00:35:16,640 --> 00:35:20,930
runs on one machine so originally our

00:35:19,460 --> 00:35:24,049
data scientists were running it on their

00:35:20,930 --> 00:35:25,819
laptop that gave a limit to the hyper

00:35:24,049 --> 00:35:27,920
parameter size that they could use could

00:35:25,819 --> 00:35:30,589
only use I think like 2.7 million

00:35:27,920 --> 00:35:32,299
judgments max tree depth of 20 which has

00:35:30,589 --> 00:35:35,210
a limit to the precision of that model

00:35:32,299 --> 00:35:37,430
we moved up to relatively large ec2

00:35:35,210 --> 00:35:39,920
machines but we're always going to be

00:35:37,430 --> 00:35:41,630
constrained by one machine we've thought

00:35:39,920 --> 00:35:43,990
about using something like XG boost

00:35:41,630 --> 00:35:50,260
which is a parallel gradient boosting

00:35:43,990 --> 00:35:53,450
system but we haven't done that yet so

00:35:50,260 --> 00:35:56,650
Doug talked about this I think it's

00:35:53,450 --> 00:35:59,960
important we all know this right right

00:35:56,650 --> 00:36:02,960
if you have bad data it doesn't matter

00:35:59,960 --> 00:36:05,450
what you do doesn't matter you can have

00:36:02,960 --> 00:36:08,359
all the sunshine and unicorns you're

00:36:05,450 --> 00:36:11,329
going to have garbage results and so you

00:36:08,359 --> 00:36:13,640
need your data to be duplicated you need

00:36:11,329 --> 00:36:15,260
fraud controls you need to be able to

00:36:13,640 --> 00:36:16,789
have clean user signals and we've

00:36:15,260 --> 00:36:19,400
actually had to go back and correct some

00:36:16,789 --> 00:36:22,220
of this stuff within our system because

00:36:19,400 --> 00:36:26,839
you can't model your way out of a data

00:36:22,220 --> 00:36:29,089
problem so this is one thing that I'm

00:36:26,839 --> 00:36:31,250
not going to talk a lot about but query

00:36:29,089 --> 00:36:33,049
dependent features are interesting in

00:36:31,250 --> 00:36:34,940
that you're training offline and when

00:36:33,049 --> 00:36:37,069
they're evaluated at query time the

00:36:34,940 --> 00:36:38,779
state of your index could change so if

00:36:37,069 --> 00:36:40,039
you're using something like tf-idf your

00:36:38,779 --> 00:36:42,380
scores will actually be different at

00:36:40,039 --> 00:36:43,760
training time and query time so what we

00:36:42,380 --> 00:36:45,740
actually have talked about doing is

00:36:43,760 --> 00:36:48,770
logging query dependent features as a

00:36:45,740 --> 00:36:52,339
training set and something also to think

00:36:48,770 --> 00:36:55,039
about integrating with an existing

00:36:52,339 --> 00:36:58,760
platform we have a system that works

00:36:55,039 --> 00:37:00,349
drives money so no we don't want to

00:36:58,760 --> 00:37:03,349
integrate with it we want to just build

00:37:00,349 --> 00:37:04,700
a parallel system so what we're doing is

00:37:03,349 --> 00:37:07,099
we're building a completely parallel

00:37:04,700 --> 00:37:09,619
system putting it under a t-test to

00:37:07,099 --> 00:37:12,349
deploy it and then we're able to tune an

00:37:09,619 --> 00:37:13,789
analyze model until we are comfortable

00:37:12,349 --> 00:37:17,809
with the lift that we're getting in our

00:37:13,789 --> 00:37:21,200
core metrics last step profit hopefully

00:37:17,809 --> 00:37:22,700
so what we what we want so our version

00:37:21,200 --> 00:37:23,150
one of the model actually had lists of

00:37:22,700 --> 00:37:26,690
about

00:37:23,150 --> 00:37:28,550
percent in ND CD at 10:37 percent in ARR

00:37:26,690 --> 00:37:30,170
at ten this is our evaluation framework

00:37:28,550 --> 00:37:32,030
that we wrote by the way which takes a

00:37:30,170 --> 00:37:34,820
training test split so it's not

00:37:32,030 --> 00:37:37,660
overfitting don't worry but you know we

00:37:34,820 --> 00:37:41,420
real-world cases we'll see what happens

00:37:37,660 --> 00:37:43,850
your hyper parameters matter when we

00:37:41,420 --> 00:37:46,820
were able to train larger models we got

00:37:43,850 --> 00:37:49,040
really large increases in our core

00:37:46,820 --> 00:37:53,480
search metrics and this is a very

00:37:49,040 --> 00:37:54,680
promising for us that's it and if you

00:37:53,480 --> 00:37:56,930
have any questions I guess you're on

00:37:54,680 --> 00:37:57,890
time but there's also some of you might

00:37:56,930 --> 00:37:59,480
know I wrote a book and there's a

00:37:57,890 --> 00:38:02,540
discount code for you that I saved to

00:37:59,480 --> 00:38:04,430
the end so you have to stay here the

00:38:02,540 --> 00:38:05,990
whole time Peter discount code and if

00:38:04,430 --> 00:38:08,720
you're interested in the plugin that's

00:38:05,990 --> 00:38:10,280
the URL we're actually partnering both

00:38:08,720 --> 00:38:14,150
with Snagajob and the wikimedia

00:38:10,280 --> 00:38:18,230
foundation on 1.0 of the plugin which

00:38:14,150 --> 00:38:21,290
will be a lot more feature-rich and if

00:38:18,230 --> 00:38:22,370
you're just said check that out so thank

00:38:21,290 --> 00:38:32,340
you guys

00:38:22,370 --> 00:38:32,340

YouTube URL: https://www.youtube.com/watch?v=JqqtWfZQUTU


