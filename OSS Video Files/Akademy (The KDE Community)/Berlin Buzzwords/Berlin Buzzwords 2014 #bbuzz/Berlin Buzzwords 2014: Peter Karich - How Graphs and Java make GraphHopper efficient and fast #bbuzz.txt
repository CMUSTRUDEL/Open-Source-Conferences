Title: Berlin Buzzwords 2014: Peter Karich - How Graphs and Java make GraphHopper efficient and fast #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	GraphHopper is an Open Source road routing engine which imports OpenStreetMap data to find the best path from A to B e.g. for a car from Moscow to Madrid.

In this talk I'll explain how we made GraphHopper fast even for long distance paths on commodity servers with world wide data from OpenStreetMap. In contrast GraphHopper still handles indoor graphs efficiently and works on mobile devices such as Android or Raspberry Pi. For this it was necessary to tune the system and do research for fast road routing on graphs.

I'll give a brief overview of the system and talk about the problems we faced with Java when using lots of data while trying to offer a usable API. Then I'll describe our simple but flexible storage solution, which can be used to store graphs, lists and more. In the second part of the talk I'll talk about reducing execution time via memory tuning and will show some possible optimizations we use in our Java code. At the end a short demo is planned.

Read more:
https://2014.berlinbuzzwords.de/session/how-graphs-and-java-make-graphhopper-efficient-and-fast

About Peter Karich:
https://2014.berlinbuzzwords.de/user/158/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,490 --> 00:00:14,810
hello welcome to my talk I'm Peter and I

00:00:12,080 --> 00:00:19,160
would like to talk about a graph

00:00:14,810 --> 00:00:24,710
and well change slightly the title to

00:00:19,160 --> 00:00:27,380
fit the session at scale how an integer

00:00:24,710 --> 00:00:34,400
re or an area of integer Aires helped

00:00:27,380 --> 00:00:38,420
graph upscaling so first bit

00:00:34,400 --> 00:00:41,960
introduction and the components of an

00:00:38,420 --> 00:00:45,470
online map or of map in general or in

00:00:41,960 --> 00:00:48,260
your car navigation system is a some

00:00:45,470 --> 00:00:53,180
drawing component some geocoding and the

00:00:48,260 --> 00:00:55,850
routine component so and graph upper is

00:00:53,180 --> 00:01:01,630
all about routing it finds the best path

00:00:55,850 --> 00:01:06,320
between coordinates we have an online

00:01:01,630 --> 00:01:08,450
kind of a demonstration to show the

00:01:06,320 --> 00:01:11,390
capabilities of graph upper it's now a

00:01:08,450 --> 00:01:14,689
fully featured Maps application and we

00:01:11,390 --> 00:01:17,090
are using geocoding a forge a recording

00:01:14,689 --> 00:01:20,210
of a photon which is powered by a

00:01:17,090 --> 00:01:24,200
elastic search and maybe there are some

00:01:20,210 --> 00:01:27,259
guys here who have interests in in this

00:01:24,200 --> 00:01:30,170
project called photon but today I would

00:01:27,259 --> 00:01:36,530
like to speak about graph upper which is

00:01:30,170 --> 00:01:41,469
only about routing and here you see some

00:01:36,530 --> 00:01:44,539
typical maps application on left hand

00:01:41,469 --> 00:01:47,539
some address search and without

00:01:44,539 --> 00:01:50,869
suggestions and and then you have some

00:01:47,539 --> 00:01:52,700
tiles and and this tiny line is the

00:01:50,869 --> 00:01:55,420
important part its graph opera and the

00:01:52,700 --> 00:02:02,299
instructions on the left side also

00:01:55,420 --> 00:02:06,350
that's what graph a breeze and also

00:02:02,299 --> 00:02:09,200
graph upper and adept what graphical

00:02:06,350 --> 00:02:11,660
looks like and graph upper is an open

00:02:09,200 --> 00:02:13,910
source and fast wrote routing library

00:02:11,660 --> 00:02:17,150
and server so you can not only embed

00:02:13,910 --> 00:02:19,910
this into your products and but you can

00:02:17,150 --> 00:02:23,780
also use it as a black box routing

00:02:19,910 --> 00:02:27,470
server service it is completely written

00:02:23,780 --> 00:02:28,190
in Java it runs on the server on desktop

00:02:27,470 --> 00:02:34,040
on

00:02:28,190 --> 00:02:38,290
and read through normal Java a JVM and

00:02:34,040 --> 00:02:42,140
but there are also some experiments with

00:02:38,290 --> 00:02:46,510
with a JVM in the browser browser so we

00:02:42,140 --> 00:02:52,190
can run it offline in the browser which

00:02:46,510 --> 00:02:55,060
listen it's kind of a weird but a nice a

00:02:52,190 --> 00:02:58,700
use case would be for example hybrid

00:02:55,060 --> 00:03:01,010
routing we can offload the service and

00:02:58,700 --> 00:03:03,200
do the routing on the client if there's

00:03:01,010 --> 00:03:05,510
no internet connection or whatever else

00:03:03,200 --> 00:03:11,660
so it's not just an experiment it's also

00:03:05,510 --> 00:03:16,640
kind of yeah kind of an interesting use

00:03:11,660 --> 00:03:20,930
case and we also have not yet published

00:03:16,640 --> 00:03:24,230
poured off of graph above for iOS so we

00:03:20,930 --> 00:03:29,120
can run it offline on iOS spritz even

00:03:24,230 --> 00:03:33,110
pretty fast there and well we have a

00:03:29,120 --> 00:03:35,750
really memory efficient and data

00:03:33,110 --> 00:03:42,220
structures in build and and all the

00:03:35,750 --> 00:03:45,140
graphs are or the api's we we offer are

00:03:42,220 --> 00:03:47,540
mostly easy to use or we're trying as

00:03:45,140 --> 00:03:53,420
hard as possible to make them easy to

00:03:47,540 --> 00:03:55,700
use yeah and also the low-level API is

00:03:53,420 --> 00:03:57,620
built to be flexible so you can just

00:03:55,700 --> 00:04:00,440
grab one part and use it in your

00:03:57,620 --> 00:04:04,070
products for a completely different use

00:04:00,440 --> 00:04:05,930
case over their belts or replace the

00:04:04,070 --> 00:04:09,739
storage with your own storage system and

00:04:05,930 --> 00:04:11,900
something like this it handles

00:04:09,739 --> 00:04:14,810
OpenStreetMap data by default it is

00:04:11,900 --> 00:04:17,540
business friendly as it is apache

00:04:14,810 --> 00:04:20,450
license and we are for consulting and

00:04:17,540 --> 00:04:22,010
support for these it has many many unit

00:04:20,450 --> 00:04:25,280
and integration tests and also

00:04:22,010 --> 00:04:27,890
performance and and load tests so you're

00:04:25,280 --> 00:04:31,700
on the set aside if you hack and change

00:04:27,890 --> 00:04:34,930
something in graph over and you cannot

00:04:31,700 --> 00:04:37,039
only do this you cannot only replace

00:04:34,930 --> 00:04:40,970
component of graph above I can also

00:04:37,039 --> 00:04:41,780
answer that this mostly works as you can

00:04:40,970 --> 00:04:48,470
run

00:04:41,780 --> 00:04:50,000
unit tests for those components just an

00:04:48,470 --> 00:04:52,490
overview what you can do it you can do

00:04:50,000 --> 00:04:55,130
it use it for outer routing or for

00:04:52,490 --> 00:04:56,810
distance matrix calculations so it's you

00:04:55,130 --> 00:04:58,910
have lots of points you want know all

00:04:56,810 --> 00:05:02,889
the distances between all the points

00:04:58,910 --> 00:05:07,910
it's quite interesting for logistics or

00:05:02,889 --> 00:05:14,770
or ride sharing or something like this

00:05:07,910 --> 00:05:17,630
or taxi companies it can be even useful

00:05:14,770 --> 00:05:21,730
simulation or games think about a

00:05:17,630 --> 00:05:26,000
Scotland Yard as simulated game or in

00:05:21,730 --> 00:05:33,140
for virtual reality kind of games and so

00:05:26,000 --> 00:05:45,320
on how many of you have used a graph

00:05:33,140 --> 00:05:48,590
databases okay not that much um how many

00:05:45,320 --> 00:05:56,120
of you have experienced in NJ 0 stuff

00:05:48,590 --> 00:05:59,180
and like spatial okay also and march i

00:05:56,120 --> 00:06:03,169
would give you a bit of introduction and

00:05:59,180 --> 00:06:05,750
in an introduction of how we map real

00:06:03,169 --> 00:06:09,260
world into some some data structure so

00:06:05,750 --> 00:06:12,410
we are using graphs for this and we are

00:06:09,260 --> 00:06:13,880
mapping the Junction's two notes and the

00:06:12,410 --> 00:06:19,250
connections between two junctions are

00:06:13,880 --> 00:06:21,080
our streets and called edges and the

00:06:19,250 --> 00:06:27,580
nodes and edges have properties like

00:06:21,080 --> 00:06:27,580
coordinates or names and and so on and

00:06:28,479 --> 00:06:36,800
well now we need to find and now the the

00:06:34,430 --> 00:06:39,770
work for graph hopper is to find the

00:06:36,800 --> 00:06:43,610
best way from the road graph from A to B

00:06:39,770 --> 00:06:46,039
from one Junction to another and from

00:06:43,610 --> 00:06:50,349
one point to another point is a bit more

00:06:46,039 --> 00:06:53,590
complex but for the sake of simplicity I

00:06:50,349 --> 00:07:00,160
expect to be it a junction

00:06:53,590 --> 00:07:04,720
and another question is why we are doing

00:07:00,160 --> 00:07:06,790
this in Java and I was asked this a bit

00:07:04,720 --> 00:07:10,420
lot and so I normally are answer with

00:07:06,790 --> 00:07:12,940
why not at last at my first torque and

00:07:10,420 --> 00:07:17,170
this is my second talk and and and i

00:07:12,940 --> 00:07:20,200
answered why not but or yeah i answered

00:07:17,170 --> 00:07:22,060
with i'm stupid and lazy or even with

00:07:20,200 --> 00:07:25,840
and beach pay too many people would have

00:07:22,060 --> 00:07:28,680
contributed and well today we'll learn

00:07:25,840 --> 00:07:33,760
the truth it's all about tooling and and

00:07:28,680 --> 00:07:36,490
also my stupidity so as c++ compiling is

00:07:33,760 --> 00:07:39,310
really really slow and even if you

00:07:36,490 --> 00:07:42,070
execute job comply compiler through

00:07:39,310 --> 00:07:46,020
maven you're faster and yes you can

00:07:42,070 --> 00:07:49,180
optimize this for c++ but at the end

00:07:46,020 --> 00:07:53,530
javis java compiler is really faster and

00:07:49,180 --> 00:07:56,200
also job was a lot easier for me to run

00:07:53,530 --> 00:07:58,380
tests deployed back in profile and the

00:07:56,200 --> 00:08:02,740
combination so you can debug and

00:07:58,380 --> 00:08:05,290
production or profile in production with

00:08:02,740 --> 00:08:10,470
really no overhead in performance or in

00:08:05,290 --> 00:08:16,930
in usability and i tried to set up a

00:08:10,470 --> 00:08:22,840
similar tooling for c++ and and also d

00:08:16,930 --> 00:08:25,690
and for two weeks but i did not really

00:08:22,840 --> 00:08:28,630
find an open source ide or open source

00:08:25,690 --> 00:08:31,840
tools which gave me the same power and

00:08:28,630 --> 00:08:37,660
same quality i needed so yeah i'm lazy

00:08:31,840 --> 00:08:39,520
and well in 4d it's been an exception

00:08:37,660 --> 00:08:41,650
because these are really young language

00:08:39,520 --> 00:08:43,810
and but it's also an excellent language

00:08:41,650 --> 00:08:50,400
but that tooling was really not that

00:08:43,810 --> 00:08:55,090
good and two years ago so i gave up and

00:08:50,400 --> 00:08:58,060
you are often here or i was asked oh

00:08:55,090 --> 00:09:00,910
yeah but I was slow and and you know all

00:08:58,060 --> 00:09:06,490
the funny jokes about Java but slow

00:09:00,910 --> 00:09:07,300
compared to what and and graphic finds

00:09:06,490 --> 00:09:10,360
best roof

00:09:07,300 --> 00:09:14,140
through the entire Europe data in under

00:09:10,360 --> 00:09:17,680
15 milliseconds and for distance matrix

00:09:14,140 --> 00:09:23,769
calculation it's even a lot less so Java

00:09:17,680 --> 00:09:25,240
is not really slow and i get i will do a

00:09:23,769 --> 00:09:30,040
bit risky thing i will do a

00:09:25,240 --> 00:09:33,550
demonstration on the internet and and

00:09:30,040 --> 00:09:37,269
show you what i mean so we have

00:09:33,550 --> 00:09:42,029
graphical maps you know this and we are

00:09:37,269 --> 00:09:47,920
in the house this club called thin

00:09:42,029 --> 00:09:54,010
friends with mm i think this was yeah

00:09:47,920 --> 00:09:57,310
and we want to go to Marseille and we

00:09:54,010 --> 00:10:02,560
have the route and you can even

00:09:57,310 --> 00:10:06,700
calculate this for for for bikes and you

00:10:02,560 --> 00:10:10,300
will see the elevation data right here

00:10:06,700 --> 00:10:14,160
and yeah one funny thing is you can you

00:10:10,300 --> 00:10:17,440
can drag and zoom and see the hill there

00:10:14,160 --> 00:10:21,430
now what I really want to show you is or

00:10:17,440 --> 00:10:24,100
what I want to do to to give a a bit of

00:10:21,430 --> 00:10:32,470
feeling that graph upper is not really

00:10:24,100 --> 00:10:35,770
slow and it's enter in Java um yeah and

00:10:32,470 --> 00:10:38,320
and a new feature for example was in the

00:10:35,770 --> 00:10:43,390
last release that we now can i bought

00:10:38,320 --> 00:10:47,310
hills for for bikes and and for others

00:10:43,390 --> 00:10:51,220
as well which is interesting for

00:10:47,310 --> 00:10:57,040
electronic cars and so on so it's quite

00:10:51,220 --> 00:11:00,570
a short demonstration but i hope you got

00:10:57,040 --> 00:11:05,860
what i mean so now the question is or

00:11:00,570 --> 00:11:08,199
another yes another question was is java

00:11:05,860 --> 00:11:13,060
and memory hog or isn't java a memory

00:11:08,199 --> 00:11:17,440
hog and and yes it is compared to c c++

00:11:13,060 --> 00:11:19,590
and so on and the main reason is that we

00:11:17,440 --> 00:11:24,180
have no

00:11:19,590 --> 00:11:29,730
no error reference less classes in Java

00:11:24,180 --> 00:11:41,460
which is really pain and and now I would

00:11:29,730 --> 00:11:45,960
like to show you what structs are so in

00:11:41,460 --> 00:11:48,210
C++ and C I think you can store a point

00:11:45,960 --> 00:11:53,670
which consists of latitude longitude add

00:11:48,210 --> 00:11:57,630
in an area just really compact in this

00:11:53,670 --> 00:12:00,720
form where the point is really where the

00:11:57,630 --> 00:12:03,750
first porn comes before the second and

00:12:00,720 --> 00:12:06,180
so I'm so it's really am compact and in

00:12:03,750 --> 00:12:09,390
Java you have to always reference to

00:12:06,180 --> 00:12:12,170
some some some kind of memory elsewhere

00:12:09,390 --> 00:12:16,920
which is not really cash friendly and

00:12:12,170 --> 00:12:18,810
has the problem of this this area which

00:12:16,920 --> 00:12:22,980
which consists only of the reference

00:12:18,810 --> 00:12:25,680
which is waste of memory and and the

00:12:22,980 --> 00:12:28,710
problem is now why Java does not have

00:12:25,680 --> 00:12:33,390
these things is that it was introduced

00:12:28,710 --> 00:12:36,330
copy semantics in Java and for example

00:12:33,390 --> 00:12:38,730
if you would have would would add a

00:12:36,330 --> 00:12:42,240
point in another area then you have a

00:12:38,730 --> 00:12:44,910
kind of problem you think they are the

00:12:42,240 --> 00:12:47,340
same but you copy them you have you

00:12:44,910 --> 00:12:51,720
would have to copy them if you would use

00:12:47,340 --> 00:12:54,480
the C++ structs like thing and in Java 9

00:12:51,720 --> 00:12:56,940
we will help fully see some some kind of

00:12:54,480 --> 00:13:00,440
they are called well you types and you

00:12:56,940 --> 00:13:06,080
can read more about this from John rose

00:13:00,440 --> 00:13:09,420
in his in one blog post one month ago

00:13:06,080 --> 00:13:12,060
until then we do two things and

00:13:09,420 --> 00:13:16,070
grasshopper to a what wasting memory the

00:13:12,060 --> 00:13:19,680
first thing is we scale with an area of

00:13:16,070 --> 00:13:25,200
by door integer Aires and the second is

00:13:19,680 --> 00:13:27,660
to make all of this easy usable and for

00:13:25,200 --> 00:13:31,280
the 40 developer we are using the

00:13:27,660 --> 00:13:31,280
flyweight pattern and

00:13:31,670 --> 00:13:41,750
to introduce you why we are using some

00:13:34,240 --> 00:13:43,820
thing like an integer re I will yeah I

00:13:41,750 --> 00:13:47,900
will start with how would you implement

00:13:43,820 --> 00:13:50,450
a simple in memory storage key belly

00:13:47,900 --> 00:13:53,240
storage in Java you will just you just

00:13:50,450 --> 00:13:56,210
need the hash map with a string as key

00:13:53,240 --> 00:13:58,880
and an object as well you there they're

00:13:56,210 --> 00:14:01,100
quite some problems you have waste

00:13:58,880 --> 00:14:03,110
memory because you are storing the key

00:14:01,100 --> 00:14:05,120
for example for a list you do not need

00:14:03,110 --> 00:14:07,880
to store the integer value right you

00:14:05,120 --> 00:14:10,730
just just an index so here you're

00:14:07,880 --> 00:14:12,800
wasting or sometimes it's necessary to

00:14:10,730 --> 00:14:17,000
waste but you're you're kind of wasting

00:14:12,800 --> 00:14:20,720
memory for this and also you need the

00:14:17,000 --> 00:14:24,010
object reference which I explained in

00:14:20,720 --> 00:14:26,960
the previous slide because you are

00:14:24,010 --> 00:14:29,570
allocating a big array and then you have

00:14:26,960 --> 00:14:33,980
the area full of references pointing to

00:14:29,570 --> 00:14:37,970
the object additionally resizing of a

00:14:33,980 --> 00:14:39,980
hashmap requires rehashing and the

00:14:37,970 --> 00:14:43,700
coastal reallocation of the underlying

00:14:39,980 --> 00:14:46,840
data structure of the hash map and still

00:14:43,700 --> 00:14:52,850
this hash map is limited to two billion

00:14:46,840 --> 00:14:55,040
objects and some ideas as I said you can

00:14:52,850 --> 00:15:00,740
use a list to while storing the key and

00:14:55,040 --> 00:15:04,460
also your dressing and then you can use

00:15:00,740 --> 00:15:08,630
the byte array and D or n serialization

00:15:04,460 --> 00:15:12,970
to to store an object there and avoid

00:15:08,630 --> 00:15:15,560
the costly object references

00:15:12,970 --> 00:15:19,220
additionally you can use an area of bite

00:15:15,560 --> 00:15:22,580
Ares to append segments of byte array

00:15:19,220 --> 00:15:29,840
hour or as segment is a byte array and

00:15:22,580 --> 00:15:33,590
you append this area to to avoid Rico

00:15:29,840 --> 00:15:35,870
sleep reallocations for resizing so

00:15:33,590 --> 00:15:39,470
instead of here you have a big Arry and

00:15:35,870 --> 00:15:41,570
now you need to increase the size then

00:15:39,470 --> 00:15:44,450
you would need another really big Arry

00:15:41,570 --> 00:15:45,200
and think in terms of millions and that

00:15:44,450 --> 00:15:46,940
or

00:15:45,200 --> 00:15:48,860
billions or whatever and and then you

00:15:46,940 --> 00:15:52,430
would have to copy this and instead of

00:15:48,860 --> 00:15:54,770
this ghostly at em and memory wasting

00:15:52,430 --> 00:15:57,650
operation you're just appending one

00:15:54,770 --> 00:16:01,820
megabyte and then using the soul

00:15:57,650 --> 00:16:04,580
structure for your list and this also

00:16:01,820 --> 00:16:07,550
allows for more than 2 billion items or

00:16:04,580 --> 00:16:11,150
objects we have an interface called data

00:16:07,550 --> 00:16:15,710
access for this which solves all the

00:16:11,150 --> 00:16:21,620
problems additionally we can use arrays

00:16:15,710 --> 00:16:26,690
of byte buffers and to do this thing of

00:16:21,620 --> 00:16:29,450
heap or to do this on with a memory map

00:16:26,690 --> 00:16:34,310
technique so we can use it for offline

00:16:29,450 --> 00:16:37,070
navigation on mobile devices of course

00:16:34,310 --> 00:16:39,470
there are problems that this data access

00:16:37,070 --> 00:16:41,720
is like a really large array and then

00:16:39,470 --> 00:16:47,530
the and the excess is more complex than

00:16:41,720 --> 00:16:50,780
with a hash lab and so it's not really

00:16:47,530 --> 00:16:52,880
what what probably what you should do

00:16:50,780 --> 00:16:56,360
when you want to scale because there are

00:16:52,880 --> 00:16:58,820
lots of generic solutions for you it was

00:16:56,360 --> 00:17:01,820
a nice project called map DB which

00:16:58,820 --> 00:17:04,220
provides convenient access to a map

00:17:01,820 --> 00:17:06,680
interface and they're a bunch of other

00:17:04,220 --> 00:17:13,300
projects you can check out if you want

00:17:06,680 --> 00:17:18,050
to use some kind of large array or large

00:17:13,300 --> 00:17:20,930
data structures put in for java or of a

00:17:18,050 --> 00:17:25,310
flaw of heap data structures and so on

00:17:20,930 --> 00:17:28,060
and the technique i described and there

00:17:25,310 --> 00:17:31,580
the errors of integer Ares or errors of

00:17:28,060 --> 00:17:35,810
binaries or whatever it's it's used in

00:17:31,580 --> 00:17:41,000
nearly all know SQL databases written in

00:17:35,810 --> 00:17:47,660
java ya like like you seen HBase and and

00:17:41,000 --> 00:17:52,310
so on I think and yeah we use a

00:17:47,660 --> 00:17:55,580
flyweight pattern to yet reverse the

00:17:52,310 --> 00:17:58,580
graph which Awards creation of new

00:17:55,580 --> 00:18:01,279
objects due tues DZ realization now we

00:17:58,580 --> 00:18:02,990
we need to fetch an object and create an

00:18:01,279 --> 00:18:06,950
object from the bite area from the

00:18:02,990 --> 00:18:10,159
integer array and and create objects and

00:18:06,950 --> 00:18:13,700
and because we want to avoid this we are

00:18:10,159 --> 00:18:16,720
just reusing the objects and and apply

00:18:13,700 --> 00:18:20,899
the flyweight pattern like this crap

00:18:16,720 --> 00:18:23,269
here so we we are setting some the graph

00:18:20,899 --> 00:18:26,750
Explorer to some node and then we are

00:18:23,269 --> 00:18:30,230
iterating over all neighbors of those of

00:18:26,750 --> 00:18:33,380
this node and then we can then we have

00:18:30,230 --> 00:18:38,000
access to all the properties of the heir

00:18:33,380 --> 00:18:42,350
of the specific edge yeah I will skip

00:18:38,000 --> 00:18:44,570
this this is more important do your own

00:18:42,350 --> 00:18:47,210
benchmarks so what don't trust me or

00:18:44,570 --> 00:18:51,500
anyone on the web do your own benchmarks

00:18:47,210 --> 00:18:56,750
and do them correctly not like me as

00:18:51,500 --> 00:18:59,090
Alex a she believed in 2009's commented

00:18:56,750 --> 00:19:00,919
on my blog the technique described in

00:18:59,090 --> 00:19:03,620
this post is ultimately ultimately

00:19:00,919 --> 00:19:06,080
broking it also contradicts with the

00:19:03,620 --> 00:19:11,330
best practices of measuring the job

00:19:06,080 --> 00:19:16,610
performance so too wide learning by

00:19:11,330 --> 00:19:19,100
shame and pain you should really try to

00:19:16,610 --> 00:19:22,070
understand how you measure correctly and

00:19:19,100 --> 00:19:23,990
there are tools like jmh or use

00:19:22,070 --> 00:19:29,539
profilers and so on and should you

00:19:23,990 --> 00:19:34,370
really make use of them yes this is I

00:19:29,539 --> 00:19:40,940
have to skip sorry because I would like

00:19:34,370 --> 00:19:52,250
to thank you I think we have now some

00:19:40,940 --> 00:19:54,260
time for questions ok any questions

00:19:52,250 --> 00:19:59,809
unfortunately we don't have that much

00:19:54,260 --> 00:20:01,070
time for questions but I'm just going to

00:19:59,809 --> 00:20:02,539
say it look like you skipped over the

00:20:01,070 --> 00:20:03,980
bit that I was really interested in

00:20:02,539 --> 00:20:07,580
which was the actual algorithm for

00:20:03,980 --> 00:20:09,830
finding the paths in the massive network

00:20:07,580 --> 00:20:11,840
of nodes and edges that you've created

00:20:09,830 --> 00:20:12,559
in these data structures you just like

00:20:11,840 --> 00:20:15,950
really

00:20:12,559 --> 00:20:20,299
quickly explain the algorithm maybe well

00:20:15,950 --> 00:20:22,610
we are using a kind of Dykstra and and

00:20:20,299 --> 00:20:25,970
this is modified it sits there are some

00:20:22,610 --> 00:20:27,980
speed up at techniques for wrote graphs

00:20:25,970 --> 00:20:31,370
like we are using contraction

00:20:27,980 --> 00:20:34,850
hierarchies it's some it introduces some

00:20:31,370 --> 00:20:37,340
additional edges and on query tyne it

00:20:34,850 --> 00:20:39,950
can then ignore some some unimportant

00:20:37,340 --> 00:20:43,309
notes and so it avoids traversing all

00:20:39,950 --> 00:20:46,759
the notes and so it's a really boost for

00:20:43,309 --> 00:20:48,740
especially large queries so we can

00:20:46,759 --> 00:20:52,899
really scale not only for cities or

00:20:48,740 --> 00:20:52,899
countries but also for continental sighs

00:20:53,409 --> 00:21:01,639
okay any more questions otherwise you

00:20:58,340 --> 00:21:04,210
can always obviously talk just on the

00:21:01,639 --> 00:21:07,210
side as well okay thank you very much

00:21:04,210 --> 00:21:07,210

YouTube URL: https://www.youtube.com/watch?v=hfZJBRfYMxs


