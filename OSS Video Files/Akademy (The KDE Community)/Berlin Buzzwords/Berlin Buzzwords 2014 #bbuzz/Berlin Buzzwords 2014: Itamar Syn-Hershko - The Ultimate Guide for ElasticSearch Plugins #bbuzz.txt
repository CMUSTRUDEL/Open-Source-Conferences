Title: Berlin Buzzwords 2014: Itamar Syn-Hershko - The Ultimate Guide for ElasticSearch Plugins #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	ElasticSearch is a great product - for search, for scale, for analyzing data, and much more. But sometimes you need to do something that is not supported by ElasticSearch out of the box, and that's where plugins come into play.

Join me in this talk to explore the plugins land of ElasticSearch. We will discuss the various ways ElasticSearch can be extended, and the various types of plugins available to do that. By giving concrete examples and browsing the large selection of pre-made plugins, we will see how plugins can help us overcome various challenges. We will also discuss possible issues with plugins, and ways to work around them.

Finally, we will discuss scenarios in which custom plugin development is necessary and can really save the day. By showing a demo of one such scenario, and the way we built and debugged a plugin to solve it, we will complete the picture of the ElasticSearch plugin land, and hopefully inspire you to create your own!

Read more:
https://2014.berlinbuzzwords.de/session/ultimate-guide-elasticsearch-plugins

About Itamar Syn-Hershko:
https://2014.berlinbuzzwords.de/user/183/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,520 --> 00:00:12,540
yep okay hi guys just a little bit about

00:00:10,799 --> 00:00:16,440
me about this talk what we're going to

00:00:12,540 --> 00:00:18,529
do you today i'm currently freelancing

00:00:16,440 --> 00:00:23,700
doing a lot of consultancy and the

00:00:18,529 --> 00:00:25,200
custom development work I'm just in the

00:00:23,700 --> 00:00:27,980
10th committer I've been working on with

00:00:25,200 --> 00:00:30,810
us in back for a couple of years now

00:00:27,980 --> 00:00:34,440
I've been maintaining the solution

00:00:30,810 --> 00:00:36,930
project with which is the c++ port for

00:00:34,440 --> 00:00:41,940
leucine and then which is now dead and

00:00:36,930 --> 00:00:45,780
now a lost internet project and this

00:00:41,940 --> 00:00:48,270
talk is basically some view some birds

00:00:45,780 --> 00:00:49,710
eye view of elastic search plugins so

00:00:48,270 --> 00:00:53,130
I've been working with elastic search

00:00:49,710 --> 00:00:55,170
for about two years now and we've been

00:00:53,130 --> 00:00:57,719
doing some really nice interesting stuff

00:00:55,170 --> 00:01:00,899
with elastic search we've come to points

00:00:57,719 --> 00:01:03,360
where we had to extend it using various

00:01:00,899 --> 00:01:05,640
mechanisms and basically that's the talk

00:01:03,360 --> 00:01:07,710
where i'm going to show you where you

00:01:05,640 --> 00:01:10,859
can extend it how you can do that when

00:01:07,710 --> 00:01:12,630
you want to do this and so on so this

00:01:10,859 --> 00:01:14,700
talk because it's only 40 minutes it's

00:01:12,630 --> 00:01:17,219
going to be a very high level view of

00:01:14,700 --> 00:01:20,520
what you can do how you can do that i'm

00:01:17,219 --> 00:01:23,359
not going to drive too much into details

00:01:20,520 --> 00:01:28,399
but i am going to give references and

00:01:23,359 --> 00:01:28,399
basically where you can take this from

00:01:29,990 --> 00:01:36,479
yeah so the agenda is basically i am

00:01:34,560 --> 00:01:38,490
talking about the integration points

00:01:36,479 --> 00:01:42,240
where we where you can integrate with

00:01:38,490 --> 00:01:44,039
elastic search with loose in then i'm

00:01:42,240 --> 00:01:46,529
going to give you some some showcases

00:01:44,039 --> 00:01:50,069
where you can do that or how i did that

00:01:46,529 --> 00:01:52,109
for special for certain scenarios and

00:01:50,069 --> 00:01:54,679
then talk about some gotchas when you

00:01:52,109 --> 00:01:59,009
write your plug-in or when you integrate

00:01:54,679 --> 00:02:03,509
what what to watch for and then I hope

00:01:59,009 --> 00:02:06,060
we can get to do some Q&A so looking at

00:02:03,509 --> 00:02:08,310
elastic search on a high level no

00:02:06,060 --> 00:02:11,039
offense but elasticsearch generally

00:02:08,310 --> 00:02:14,070
speaking can be thought of as an HTTP

00:02:11,039 --> 00:02:16,170
server on top of leucine so what you can

00:02:14,070 --> 00:02:18,720
see here is basically the elastic search

00:02:16,170 --> 00:02:19,319
server and within that elastic search

00:02:18,720 --> 00:02:21,689
server

00:02:19,319 --> 00:02:23,459
we have loose in so this part here is a

00:02:21,689 --> 00:02:25,829
bit small we are going to zoom in in

00:02:23,459 --> 00:02:28,290
just a second but elasticsearch our

00:02:25,829 --> 00:02:31,189
server basically just takes in rest

00:02:28,290 --> 00:02:34,200
response at rest requests send back

00:02:31,189 --> 00:02:38,329
responses and you can either do indexing

00:02:34,200 --> 00:02:40,920
or querying and those commands or

00:02:38,329 --> 00:02:44,099
requests are going to be delegated to a

00:02:40,920 --> 00:02:48,260
leucine index data signetics has some

00:02:44,099 --> 00:02:54,120
logic happening within it and that logic

00:02:48,260 --> 00:02:56,969
looks a bit like this so we have request

00:02:54,120 --> 00:02:59,340
searching or indexing coming in and then

00:02:56,969 --> 00:03:01,650
you have the query parser you have the

00:02:59,340 --> 00:03:04,169
analysis chain you have the indexing you

00:03:01,650 --> 00:03:07,319
have the search parts we're losing

00:03:04,169 --> 00:03:08,939
actually does its its thing and then in

00:03:07,319 --> 00:03:14,879
the bottom you have the leucine index

00:03:08,939 --> 00:03:17,340
itself the actual files now the

00:03:14,879 --> 00:03:20,879
integration those things that Lucinda's

00:03:17,340 --> 00:03:22,980
can actually be integrated with so let's

00:03:20,879 --> 00:03:25,169
start with the most maybe not

00:03:22,980 --> 00:03:28,139
interesting example which is the query

00:03:25,169 --> 00:03:31,009
parser so when you send a request that

00:03:28,139 --> 00:03:34,229
request that search request can be

00:03:31,009 --> 00:03:37,019
basically a query string now the visual

00:03:34,229 --> 00:03:39,389
the official recommendation is usually

00:03:37,019 --> 00:03:41,970
not to use a query string basically

00:03:39,389 --> 00:03:44,000
because the query parser that comes with

00:03:41,970 --> 00:03:46,409
leucine can throw exceptions can do

00:03:44,000 --> 00:03:51,870
stuff that you don't really want it to

00:03:46,409 --> 00:03:54,150
do so you can either send use some some

00:03:51,870 --> 00:03:56,069
other query types which that elastic

00:03:54,150 --> 00:03:59,310
search provides or you can implement

00:03:56,069 --> 00:04:01,620
your own your own query parser so there

00:03:59,310 --> 00:04:04,590
is actually a simple query parser I

00:04:01,620 --> 00:04:08,189
think it's called that's sort of new to

00:04:04,590 --> 00:04:10,379
seen as well that is a custom query

00:04:08,189 --> 00:04:13,979
parser that actually takes a very

00:04:10,379 --> 00:04:15,780
relaxed syntax and it doesn't throw and

00:04:13,979 --> 00:04:18,209
basically if you want to write your own

00:04:15,780 --> 00:04:20,340
query parser you can do that and then

00:04:18,209 --> 00:04:22,740
you basically integrate that query

00:04:20,340 --> 00:04:24,449
parser with it within elasticsearch you

00:04:22,740 --> 00:04:27,270
tell astok search that whenever a query

00:04:24,449 --> 00:04:31,169
string query comes in to elasticsearch

00:04:27,270 --> 00:04:32,790
it should use that Corey parser and then

00:04:31,169 --> 00:04:34,980
you're pretty much done

00:04:32,790 --> 00:04:36,960
I think there is no way to actually have

00:04:34,980 --> 00:04:39,930
multiple query powers or implementations

00:04:36,960 --> 00:04:41,490
line side by side so if you provide

00:04:39,930 --> 00:04:45,120
acquire powers of your basically replace

00:04:41,490 --> 00:04:49,110
the existing one but that's the most I

00:04:45,120 --> 00:04:50,880
think simple integration point we can we

00:04:49,110 --> 00:04:54,240
can talk about how you do that will

00:04:50,880 --> 00:04:57,300
touch that in the end of the talk and

00:04:54,240 --> 00:05:00,240
then we have the analysis chain now

00:04:57,300 --> 00:05:03,390
whenever you have indexing coming in or

00:05:00,240 --> 00:05:06,810
searchers certain searches coming in for

00:05:03,390 --> 00:05:08,640
example query strings or equestrian

00:05:06,810 --> 00:05:11,580
queries or you have marked the match

00:05:08,640 --> 00:05:14,310
family Koreans coming in they're going

00:05:11,580 --> 00:05:16,460
to go through the analysis chain now

00:05:14,310 --> 00:05:19,740
what is the analysis chain it's

00:05:16,460 --> 00:05:23,010
basically probably the most important

00:05:19,740 --> 00:05:26,910
part of leucine just to demonstrate why

00:05:23,010 --> 00:05:29,700
so if we have you know one line of text

00:05:26,910 --> 00:05:33,540
the analysis chain is going to actually

00:05:29,700 --> 00:05:37,080
take care of tokenization and turn token

00:05:33,540 --> 00:05:38,910
filtering for you so you have that

00:05:37,080 --> 00:05:42,210
string that line a stream of one's three

00:05:38,910 --> 00:05:44,520
lines line of text it's going to be too

00:05:42,210 --> 00:05:47,070
keen eyes into multiple tokens that's

00:05:44,520 --> 00:05:48,990
the first part of the analysis chain and

00:05:47,070 --> 00:05:52,310
then you have the second part way you

00:05:48,990 --> 00:05:55,620
can have multiple filters doing multiple

00:05:52,310 --> 00:05:59,160
operations on top of that the entire

00:05:55,620 --> 00:06:01,470
talking stream or each individual token

00:05:59,160 --> 00:06:03,810
on itself so you can remove tokens you

00:06:01,470 --> 00:06:06,660
can add tokens you can manipulate tokens

00:06:03,810 --> 00:06:10,500
so that's one example there is another

00:06:06,660 --> 00:06:16,680
example for example that does some askew

00:06:10,500 --> 00:06:18,330
normalizations Laura casing and usually

00:06:16,680 --> 00:06:22,200
the analysis chain is going to match

00:06:18,330 --> 00:06:25,350
from both sides of the indexing and

00:06:22,200 --> 00:06:27,270
searching so you you're going to index

00:06:25,350 --> 00:06:29,490
this line of tech this line of text

00:06:27,270 --> 00:06:31,260
you're going to have multiple terms in

00:06:29,490 --> 00:06:33,690
the index and when you query you

00:06:31,260 --> 00:06:37,920
basically probably going to query on

00:06:33,690 --> 00:06:40,470
only moved on only single items terms

00:06:37,920 --> 00:06:42,810
and that is going to go through the same

00:06:40,470 --> 00:06:45,150
process and that basically ensures

00:06:42,810 --> 00:06:46,740
you're going to get the results that

00:06:45,150 --> 00:06:51,210
you're looking for all the document

00:06:46,740 --> 00:06:53,400
that were indexed sometimes however you

00:06:51,210 --> 00:06:56,069
want you will want to actually use

00:06:53,400 --> 00:06:58,310
different analyzers for the search part

00:06:56,069 --> 00:07:01,080
in the indexing part there are good

00:06:58,310 --> 00:07:04,470
samples for that as well so keep that in

00:07:01,080 --> 00:07:07,080
mind and there's also some times when

00:07:04,470 --> 00:07:11,250
you actually want different tokenization

00:07:07,080 --> 00:07:13,530
behaviors than what's provided so some

00:07:11,250 --> 00:07:16,139
analyzers some to analyze a solution or

00:07:13,530 --> 00:07:18,660
some tokenizer to be more exact are

00:07:16,139 --> 00:07:23,280
going for example to preserve email

00:07:18,660 --> 00:07:25,740
addresses some will not whatever the

00:07:23,280 --> 00:07:28,490
behavior that you want can actually

00:07:25,740 --> 00:07:33,780
change between corpuses and query types

00:07:28,490 --> 00:07:36,900
and to just finalize my case since we're

00:07:33,780 --> 00:07:39,240
in Berlin so you have this way of

00:07:36,900 --> 00:07:42,750
actually combine multiple words together

00:07:39,240 --> 00:07:44,940
so you do actually want to provide an

00:07:42,750 --> 00:07:48,240
analyzer that can understand your

00:07:44,940 --> 00:07:51,449
language your corpus or your whatever

00:07:48,240 --> 00:07:54,030
searches your users we want to do this

00:07:51,449 --> 00:07:57,150
is why basically you'd want to write

00:07:54,030 --> 00:07:59,610
your own analyzer so there are some

00:07:57,150 --> 00:08:03,449
analyzers that combined it bundled with

00:07:59,610 --> 00:08:06,300
loose in this is the most basic ones and

00:08:03,449 --> 00:08:09,900
then you have the ability to actually

00:08:06,300 --> 00:08:12,889
construct your own analyzer without

00:08:09,900 --> 00:08:16,110
doing actually any actual code work

00:08:12,889 --> 00:08:18,690
using just index settings so it's a j1

00:08:16,110 --> 00:08:22,380
JSON document that you put with as a

00:08:18,690 --> 00:08:25,110
settings are within your within your

00:08:22,380 --> 00:08:28,319
elastic search cluster or metadata

00:08:25,110 --> 00:08:31,409
cluster and that's how you can take

00:08:28,319 --> 00:08:33,469
token filters or tokenizer switch are

00:08:31,409 --> 00:08:37,260
the two steps that we have shown and

00:08:33,469 --> 00:08:39,959
construct an analyzer out of them so an

00:08:37,260 --> 00:08:42,959
analyzer basically is constructed of one

00:08:39,959 --> 00:08:45,839
tokenizer and one tokenizer and multiple

00:08:42,959 --> 00:08:48,149
talking streams or none at all and

00:08:45,839 --> 00:08:50,370
that's your choice what to do so this is

00:08:48,149 --> 00:08:53,490
one way you can integrate with elastic

00:08:50,370 --> 00:08:57,870
search constructing an analyzer out of

00:08:53,490 --> 00:09:00,460
those are those constructs and that's

00:08:57,870 --> 00:09:02,290
without doing any coding at all

00:09:00,460 --> 00:09:05,290
that's that feature here by the way is

00:09:02,290 --> 00:09:06,910
nearing elasticsearch in my mind in my

00:09:05,290 --> 00:09:09,370
opinion it's it's some sort of a game

00:09:06,910 --> 00:09:13,720
changer in terms of how you can actually

00:09:09,370 --> 00:09:15,190
do really interesting stuff with with

00:09:13,720 --> 00:09:19,900
basically with the scene with doing

00:09:15,190 --> 00:09:22,180
full-text searches look it up but you

00:09:19,900 --> 00:09:25,240
can actually go and write your own

00:09:22,180 --> 00:09:27,690
analyzer so if for example you want to

00:09:25,240 --> 00:09:30,280
have a tokenizer or you want to have

00:09:27,690 --> 00:09:33,160
talking filters or you want to have the

00:09:30,280 --> 00:09:34,960
whole deal that does not do you then

00:09:33,160 --> 00:09:37,180
don't have that in lucene currently or

00:09:34,960 --> 00:09:39,550
you don't have that in elasticsearch oh

00:09:37,180 --> 00:09:42,070
and any other plug-in does not allow you

00:09:39,550 --> 00:09:44,140
to do that you'll probably go and write

00:09:42,070 --> 00:09:46,480
this for yourself so I mentioned it's

00:09:44,140 --> 00:09:48,790
very language dependent and very corpus

00:09:46,480 --> 00:09:51,670
dependent so here's an example of a

00:09:48,790 --> 00:09:56,470
plug-in road which actually takes a big

00:09:51,670 --> 00:09:59,110
problem in the search world which is the

00:09:56,470 --> 00:10:00,910
Hebrew language it's basically you

00:09:59,110 --> 00:10:04,090
cannot really index and search on on

00:10:00,910 --> 00:10:07,870
Hebrew texts using any currently

00:10:04,090 --> 00:10:09,940
available tools and this is an elastic

00:10:07,870 --> 00:10:11,680
search plug that I wrote it's open

00:10:09,940 --> 00:10:13,360
source you can go and look up the code

00:10:11,680 --> 00:10:15,970
see how I do things there which

00:10:13,360 --> 00:10:18,070
basically gives you token filters and it

00:10:15,970 --> 00:10:23,070
gives you a custom tokenizer that lets

00:10:18,070 --> 00:10:25,990
you index and search Hebrew properly

00:10:23,070 --> 00:10:28,750
there is some gotcha here we'll get that

00:10:25,990 --> 00:10:31,870
are in the end basically I'm using a

00:10:28,750 --> 00:10:34,780
dictionary and that dictionary I need to

00:10:31,870 --> 00:10:37,180
have it available and that tends to have

00:10:34,780 --> 00:10:39,100
to present some problems and we are

00:10:37,180 --> 00:10:42,370
going to look at that in just a bit so

00:10:39,100 --> 00:10:44,530
going back to the loose in diagram for a

00:10:42,370 --> 00:10:46,570
second so we just talked about the

00:10:44,530 --> 00:10:49,750
analysis chain now once we have

00:10:46,570 --> 00:10:51,850
constructed a query out of a query

00:10:49,750 --> 00:10:53,830
string or whatever other query that went

00:10:51,850 --> 00:10:56,020
or needed to go through the analysis

00:10:53,830 --> 00:10:58,780
chain we're not going to perform the

00:10:56,020 --> 00:11:03,670
actual search using that query object

00:10:58,780 --> 00:11:06,700
internally in lucene now here is an ear

00:11:03,670 --> 00:11:09,520
is probably where the most of the

00:11:06,700 --> 00:11:12,700
extension points are so let's start with

00:11:09,520 --> 00:11:14,350
scripting so you can issue a lot of

00:11:12,700 --> 00:11:17,920
queries and

00:11:14,350 --> 00:11:20,830
and have filters and have custom scoring

00:11:17,920 --> 00:11:23,800
and do facets or aggregations do a lot

00:11:20,830 --> 00:11:25,270
of a lot of those stuff but you might

00:11:23,800 --> 00:11:27,610
get to a point where you're trying to do

00:11:25,270 --> 00:11:29,770
something and maybe your model doesn't

00:11:27,610 --> 00:11:33,940
allow you to do exactly what you want or

00:11:29,770 --> 00:11:36,000
maybe some scoring some kind you need to

00:11:33,940 --> 00:11:40,300
do some custom scoring or you need to do

00:11:36,000 --> 00:11:41,620
custom filtering and so on and that's

00:11:40,300 --> 00:11:45,610
where the scripting engine of

00:11:41,620 --> 00:11:48,220
elasticsearch comes into play generally

00:11:45,610 --> 00:11:52,030
speaking it's it's pretty slow so it

00:11:48,220 --> 00:11:55,570
works nicely and it is quite performing

00:11:52,030 --> 00:11:58,360
but you don't want to rely on that once

00:11:55,570 --> 00:12:01,210
you grow too big or you have many

00:11:58,360 --> 00:12:03,690
requests coming in and that's something

00:12:01,210 --> 00:12:05,590
to keep in mind you can definitely start

00:12:03,690 --> 00:12:08,260
working with that you can definitely

00:12:05,590 --> 00:12:10,390
write something working and working well

00:12:08,260 --> 00:12:14,410
with that but at some point you're going

00:12:10,390 --> 00:12:16,480
to notice it doesn't it doesn't take all

00:12:14,410 --> 00:12:19,170
you want it to take and that's where you

00:12:16,480 --> 00:12:21,820
should start looking for alternatives so

00:12:19,170 --> 00:12:25,360
basically the scripting in elasticsearch

00:12:21,820 --> 00:12:28,630
is is based on multiple scripting

00:12:25,360 --> 00:12:31,720
engines the one we used by default is

00:12:28,630 --> 00:12:34,720
mville you have groovy you have Python

00:12:31,720 --> 00:12:37,020
there are multiple other scripting

00:12:34,720 --> 00:12:39,310
languages scripting engines you can use

00:12:37,020 --> 00:12:41,470
you can obviously write your own

00:12:39,310 --> 00:12:45,700
scripting engine if for some reason you

00:12:41,470 --> 00:12:49,930
want to do that but again it's just a

00:12:45,700 --> 00:12:52,930
scripting engine and that's something to

00:12:49,930 --> 00:12:54,940
take note of and at some point you're

00:12:52,930 --> 00:12:57,310
going to get to a point where you want

00:12:54,940 --> 00:13:00,040
to make this more performant there are

00:12:57,310 --> 00:13:03,070
two ways to do that one is to go the

00:13:00,040 --> 00:13:05,380
native scripts route meaning you'll be

00:13:03,070 --> 00:13:09,880
writing some sort of a plug-in that

00:13:05,380 --> 00:13:11,590
basically does the actual actual work

00:13:09,880 --> 00:13:14,920
for you but it's written in Java and

00:13:11,590 --> 00:13:17,440
it's actually compiled and being an

00:13:14,920 --> 00:13:21,340
elastic search uses us as a native code

00:13:17,440 --> 00:13:24,280
or native java JVM code or you can go

00:13:21,340 --> 00:13:27,520
and in your in your case it makes sense

00:13:24,280 --> 00:13:30,940
to actually extend elasticsearch to do

00:13:27,520 --> 00:13:33,490
using some custom actions you might want

00:13:30,940 --> 00:13:38,290
to go that route although as we will see

00:13:33,490 --> 00:13:41,140
it has its own pitfalls continuing

00:13:38,290 --> 00:13:44,080
continuing on that point so basically if

00:13:41,140 --> 00:13:46,900
you want to do custom scoring or if you

00:13:44,080 --> 00:13:49,570
want to have an ability to search your

00:13:46,900 --> 00:13:51,550
corpus and get results ranked in a

00:13:49,570 --> 00:13:54,490
different way so you can integrate

00:13:51,550 --> 00:13:57,820
custom similarity which losing by

00:13:54,490 --> 00:14:00,040
default gives you as I tf-idf but there

00:13:57,820 --> 00:14:04,180
are other other ways to do that or for

00:14:00,040 --> 00:14:07,860
example the BM 25 or the DFR so you want

00:14:04,180 --> 00:14:10,990
to maybe integrate other similarity of

00:14:07,860 --> 00:14:14,770
similarity implementations that's really

00:14:10,990 --> 00:14:17,560
a expert expert feature use it only if

00:14:14,770 --> 00:14:20,140
you know what you're doing what is

00:14:17,560 --> 00:14:22,750
important i think is the function square

00:14:20,140 --> 00:14:24,430
which britta just previously talked

00:14:22,750 --> 00:14:26,560
about and that's a really powerful

00:14:24,430 --> 00:14:29,190
feature that's something that you should

00:14:26,560 --> 00:14:34,090
really look into if you want to do

00:14:29,190 --> 00:14:37,530
custom scoring and reflect results the

00:14:34,090 --> 00:14:41,230
results order based on really complex

00:14:37,530 --> 00:14:46,990
complex logic but again that's basically

00:14:41,230 --> 00:14:49,510
script and all that comes with it okay

00:14:46,990 --> 00:14:52,120
next point in the loose in integration

00:14:49,510 --> 00:14:54,610
part so you have we have the indexing

00:14:52,120 --> 00:14:56,650
part and it these are this next point is

00:14:54,610 --> 00:14:59,680
actually going to affect also searching

00:14:56,650 --> 00:15:03,310
so in loosing thought for we will soon

00:14:59,680 --> 00:15:05,110
for sorry we there there's been a new

00:15:03,310 --> 00:15:07,660
feature added it's called codex

00:15:05,110 --> 00:15:09,940
basically it means it's some sort of an

00:15:07,660 --> 00:15:12,970
abstraction layer on how the leucine

00:15:09,940 --> 00:15:15,120
indexes are going getting written into

00:15:12,970 --> 00:15:19,300
disc and how they are loaded back again

00:15:15,120 --> 00:15:21,190
and again expert feature there are some

00:15:19,300 --> 00:15:24,010
optimizations that you can achieve by

00:15:21,190 --> 00:15:27,310
actually switching codex so you define a

00:15:24,010 --> 00:15:30,490
codec basically like that you put a

00:15:27,310 --> 00:15:32,560
codec definition or you use an existing

00:15:30,490 --> 00:15:35,620
codec definition or which already you

00:15:32,560 --> 00:15:37,680
can already have and then in the mapping

00:15:35,620 --> 00:15:40,630
of your index you're going to tell

00:15:37,680 --> 00:15:41,390
elasticsearch that this field needs to

00:15:40,630 --> 00:15:44,060
use

00:15:41,390 --> 00:15:47,090
is codec and this is basically again an

00:15:44,060 --> 00:15:49,760
expert feature how you can improve

00:15:47,090 --> 00:15:51,590
performance because for example some

00:15:49,760 --> 00:15:53,780
fields make more sense to load them up

00:15:51,590 --> 00:15:56,030
at once and keep them in memory and some

00:15:53,780 --> 00:16:01,940
fields do not and that's what codecs

00:15:56,030 --> 00:16:04,460
let's let you do finishing up on the

00:16:01,940 --> 00:16:06,800
loose in part we've been seeing how the

00:16:04,460 --> 00:16:09,020
inner parts of the scene can be

00:16:06,800 --> 00:16:12,200
integrated with again we're going to see

00:16:09,020 --> 00:16:15,320
how we can actually do that in in the

00:16:12,200 --> 00:16:18,560
end but let's for now treat loose in as

00:16:15,320 --> 00:16:21,950
a black box so we have requests coming

00:16:18,560 --> 00:16:24,020
in and we want to just pass them to

00:16:21,950 --> 00:16:26,270
loosen get back the results and now

00:16:24,020 --> 00:16:28,460
let's look at what we can extend on that

00:16:26,270 --> 00:16:31,580
part that is elastic search that

00:16:28,460 --> 00:16:34,160
basically manages losing indexes for us

00:16:31,580 --> 00:16:38,620
now what I have in this slide is

00:16:34,160 --> 00:16:41,420
basically where rest query quest

00:16:38,620 --> 00:16:44,060
requests coming in and I'm basically

00:16:41,420 --> 00:16:46,850
assuming it's either indexing or queries

00:16:44,060 --> 00:16:50,830
but that's not true right so in elastic

00:16:46,850 --> 00:16:53,510
search we have stats and management and

00:16:50,830 --> 00:16:56,510
metadata custom metadata that we can

00:16:53,510 --> 00:16:58,820
manage so I left it out of the slide but

00:16:56,510 --> 00:17:02,150
obviously elasticsearch has that as well

00:16:58,820 --> 00:17:05,440
so that's zoom out let's now look at

00:17:02,150 --> 00:17:08,030
what elasticsearch can be extended with

00:17:05,440 --> 00:17:11,720
so the first thing that we're going to

00:17:08,030 --> 00:17:13,280
look at now is how once we have one or

00:17:11,720 --> 00:17:16,520
multiple seen indexes in our

00:17:13,280 --> 00:17:17,959
installation how we can control how they

00:17:16,520 --> 00:17:20,720
are moved around so we have one

00:17:17,959 --> 00:17:22,850
elasticsearch cluster which is one or

00:17:20,720 --> 00:17:24,620
more servers and assuming we have more

00:17:22,850 --> 00:17:28,130
than one server will now want to decide

00:17:24,620 --> 00:17:32,120
how to allocate those shards of you seen

00:17:28,130 --> 00:17:33,770
indexes between those those servers so

00:17:32,120 --> 00:17:37,670
that's basically where shall the

00:17:33,770 --> 00:17:40,160
location control comes into play so by

00:17:37,670 --> 00:17:42,500
default elastic search allows you gives

00:17:40,160 --> 00:17:44,330
you quite a lot of power so you can you

00:17:42,500 --> 00:17:47,260
can tell an index that you want it on a

00:17:44,330 --> 00:17:50,840
specific server by AP or by tag or

00:17:47,260 --> 00:17:54,650
specify a bunch of them using tags using

00:17:50,840 --> 00:17:55,420
blacklist whitelist approaches or you

00:17:54,650 --> 00:17:57,940
can you can

00:17:55,420 --> 00:17:59,770
fine-tune things like how many shards I

00:17:57,940 --> 00:18:02,800
want on a specific note how many shards

00:17:59,770 --> 00:18:06,570
of a specific index I want on a specific

00:18:02,800 --> 00:18:09,910
node I you can also tell it to consider

00:18:06,570 --> 00:18:12,850
disk space for example I want to make

00:18:09,910 --> 00:18:17,590
sure that disk only has 20 gigabytes

00:18:12,850 --> 00:18:23,040
used or only has always has this amount

00:18:17,590 --> 00:18:25,990
of space free et cetera now that's all

00:18:23,040 --> 00:18:28,750
already implemented for you and all you

00:18:25,990 --> 00:18:32,560
have to do is basically play with with

00:18:28,750 --> 00:18:35,710
some settings again you either using the

00:18:32,560 --> 00:18:37,960
JSON using JSON the settings the index

00:18:35,710 --> 00:18:41,290
settings or you can go and change the

00:18:37,960 --> 00:18:44,320
elastic settlement for most of that you

00:18:41,290 --> 00:18:46,840
may want in some cases implement your

00:18:44,320 --> 00:18:50,020
own shadow location logic but it's very

00:18:46,840 --> 00:18:52,600
very dangerous basically because a lot

00:18:50,020 --> 00:18:55,330
of times the shouting allocation

00:18:52,600 --> 00:18:58,030
strategy or the deciders that are in

00:18:55,330 --> 00:19:00,160
play there's generally more than one in

00:18:58,030 --> 00:19:02,680
play so you want to make sure that your

00:19:00,160 --> 00:19:04,960
decider that you if you decide to

00:19:02,680 --> 00:19:08,440
implement one I don't know taking into

00:19:04,960 --> 00:19:11,560
account ram usage for example if you

00:19:08,440 --> 00:19:13,420
cannot do that using tags or rock ideas

00:19:11,560 --> 00:19:15,730
or whatever and you decide to do this

00:19:13,420 --> 00:19:18,460
using your own custom code make sure it

00:19:15,730 --> 00:19:24,940
plays really really nicely again super

00:19:18,460 --> 00:19:28,780
expert feature one other interesting can

00:19:24,940 --> 00:19:30,850
you see that sorry about that one really

00:19:28,780 --> 00:19:33,180
interesting feature that I think worth

00:19:30,850 --> 00:19:36,190
noticing is that elastic search again is

00:19:33,180 --> 00:19:38,530
basically some is it's it's an HTTP

00:19:36,190 --> 00:19:41,560
server and it's a distributed one so

00:19:38,530 --> 00:19:43,120
once you have a logical deployed you and

00:19:41,560 --> 00:19:45,700
if you have a plug-in that actually

00:19:43,120 --> 00:19:48,460
gives you a rest endpoint you can

00:19:45,700 --> 00:19:51,400
basically go and approach the cluster to

00:19:48,460 --> 00:19:55,270
perform that for you now that that can

00:19:51,400 --> 00:19:57,580
have multiple usages one is for example

00:19:55,270 --> 00:19:59,980
to have your custom logic implemented

00:19:57,580 --> 00:20:02,800
for search or whatever and then you can

00:19:59,980 --> 00:20:05,440
expose that Thun on java consumers

00:20:02,800 --> 00:20:07,549
because Java Java clients you basically

00:20:05,440 --> 00:20:11,230
usually don't use the

00:20:07,549 --> 00:20:14,139
the rest api they using the custom

00:20:11,230 --> 00:20:18,289
serialization protocol of elastic search

00:20:14,139 --> 00:20:19,940
on another port but non Java clients are

00:20:18,289 --> 00:20:23,989
going to communicate with elastic search

00:20:19,940 --> 00:20:27,499
using the rest api so if you have if

00:20:23,989 --> 00:20:30,710
you've implemented your own logic for

00:20:27,499 --> 00:20:33,049
example custom search or custom whatever

00:20:30,710 --> 00:20:35,629
then integrating with the same for

00:20:33,049 --> 00:20:37,970
example so you may want to implement

00:20:35,629 --> 00:20:42,200
that rest endpoint so to expose it to

00:20:37,970 --> 00:20:45,889
consumers one other use case for example

00:20:42,200 --> 00:20:48,109
which I found actually useful one for

00:20:45,889 --> 00:20:51,379
example i implemented that custom hebrew

00:20:48,109 --> 00:20:53,419
search so i actually exposed an HTTP

00:20:51,379 --> 00:20:55,609
endpoint that lets see me let me peek

00:20:53,419 --> 00:20:58,429
into the dictionary that is being used

00:20:55,609 --> 00:21:00,889
now because that's basically an HTTP

00:20:58,429 --> 00:21:03,190
server I can implement whatever HTTP

00:21:00,889 --> 00:21:07,039
endpoint and I want in the cluster and

00:21:03,190 --> 00:21:09,109
basically expose business logic out of

00:21:07,039 --> 00:21:12,710
that cluster as well and that can prove

00:21:09,109 --> 00:21:15,409
very useful side note always put elastic

00:21:12,710 --> 00:21:17,269
search behind a proxy and that way you

00:21:15,409 --> 00:21:20,090
basically protect yourself from a lot of

00:21:17,269 --> 00:21:22,609
stuff but what I'm saying that to make

00:21:20,090 --> 00:21:25,009
sure that that advice doesn't go to

00:21:22,609 --> 00:21:27,340
exposing your website or whatever out of

00:21:25,009 --> 00:21:30,230
elastic search just you know internal

00:21:27,340 --> 00:21:34,759
business logic that you won't distribute

00:21:30,230 --> 00:21:37,489
it what's being shown here is actually

00:21:34,759 --> 00:21:39,590
very simplistic code when once you have

00:21:37,489 --> 00:21:42,259
a request coming in you're going to need

00:21:39,590 --> 00:21:44,480
to parse it then you need to process it

00:21:42,259 --> 00:21:46,999
to whatever logic you have to do and

00:21:44,480 --> 00:21:50,389
then build back the response and send it

00:21:46,999 --> 00:21:52,909
back now speaking about the rest

00:21:50,389 --> 00:21:55,340
endpoints or speaking about the rest

00:21:52,909 --> 00:21:58,340
capabilities of elastic search we can

00:21:55,340 --> 00:22:01,429
have multiple transports supporting that

00:21:58,340 --> 00:22:04,970
so by default elasticsearch uses the

00:22:01,429 --> 00:22:07,429
HTTP HTTP for transport you can you can

00:22:04,970 --> 00:22:09,350
use apache thrift you can have multiple

00:22:07,429 --> 00:22:12,649
other transports and elastic search

00:22:09,350 --> 00:22:16,100
already has its plugins at least you can

00:22:12,649 --> 00:22:19,460
actually install more transports some I

00:22:16,100 --> 00:22:20,580
don't actually know why they would be

00:22:19,460 --> 00:22:23,880
used at

00:22:20,580 --> 00:22:25,890
used for example the 0 and Q 1 i'm not

00:22:23,880 --> 00:22:27,870
quite sure of the use cases but

00:22:25,890 --> 00:22:32,519
apparently people have found use cases

00:22:27,870 --> 00:22:34,470
for that and that you can do that you

00:22:32,519 --> 00:22:37,830
can actually even write your own

00:22:34,470 --> 00:22:41,909
transport and use that so all of a

00:22:37,830 --> 00:22:44,580
lasting search REST API basically can be

00:22:41,909 --> 00:22:46,350
exposed via different protocols the

00:22:44,580 --> 00:22:49,110
thrift protocol for example is one

00:22:46,350 --> 00:22:54,539
that's often being used to speed up over

00:22:49,110 --> 00:22:58,649
the default HTTP protocol so let's let's

00:22:54,539 --> 00:23:01,159
talk about one use case that we had we

00:22:58,649 --> 00:23:04,440
were we deployed elasticsearch and

00:23:01,159 --> 00:23:07,230
basically we use it for search and in

00:23:04,440 --> 00:23:09,389
one project and we had a lot of search

00:23:07,230 --> 00:23:11,909
action going on but we also need to

00:23:09,389 --> 00:23:14,490
percolate now percolation basically

00:23:11,909 --> 00:23:16,470
means an alerting system of on top of

00:23:14,490 --> 00:23:18,210
elastic search that make sure that

00:23:16,470 --> 00:23:21,960
whenever you have new document coming in

00:23:18,210 --> 00:23:23,870
alerts will fire for a list of stored

00:23:21,960 --> 00:23:26,909
queries that you have in your system now

00:23:23,870 --> 00:23:29,669
they got back in the day I think it was

00:23:26,909 --> 00:23:31,980
a year ago elasticsearch didn't have a

00:23:29,669 --> 00:23:34,279
distributed percolator and we also

00:23:31,980 --> 00:23:37,260
wanted to make sure that that particular

00:23:34,279 --> 00:23:40,049
is highly optimized to our use cases

00:23:37,260 --> 00:23:43,470
because we had a lot of documents coming

00:23:40,049 --> 00:23:46,440
in regularly so what we did is basically

00:23:43,470 --> 00:23:48,929
we took the elastic search the actual

00:23:46,440 --> 00:23:53,250
elasticsearch speculator we pull it out

00:23:48,929 --> 00:23:55,080
we put it in our own jar file made our

00:23:53,250 --> 00:23:57,210
optimizations to it optimizations

00:23:55,080 --> 00:23:58,769
including highlighting again back in the

00:23:57,210 --> 00:24:01,950
day where the percolator didn't have I

00:23:58,769 --> 00:24:04,649
lighting we had a lot of query

00:24:01,950 --> 00:24:06,090
optimization so we basically filter out

00:24:04,649 --> 00:24:09,029
a lot of queries based on the language

00:24:06,090 --> 00:24:10,799
stuff like that we added a lot of logs

00:24:09,029 --> 00:24:13,889
because we really really needed to

00:24:10,799 --> 00:24:16,559
understand when an alert comes is going

00:24:13,889 --> 00:24:18,539
to be fired when it didn't we needed to

00:24:16,559 --> 00:24:20,940
track that so we did a lot of chemical

00:24:18,539 --> 00:24:23,159
customizations and then we basically

00:24:20,940 --> 00:24:27,899
compile it again and pushed it as a

00:24:23,159 --> 00:24:29,970
plug-in but that's a very easy to make

00:24:27,899 --> 00:24:33,539
plugin because basically all we had to

00:24:29,970 --> 00:24:34,320
do is take some existing code from

00:24:33,539 --> 00:24:37,919
elastic sir

00:24:34,320 --> 00:24:40,289
compile it and then pull pull it in to

00:24:37,919 --> 00:24:42,840
make elasticsearch detected and then

00:24:40,289 --> 00:24:44,880
fire it and let it run and again we are

00:24:42,840 --> 00:24:47,820
going to see how to do that in the end

00:24:44,880 --> 00:24:49,710
of the talk sometimes you really don't

00:24:47,820 --> 00:24:51,899
have any other choice but to dig deeper

00:24:49,710 --> 00:24:56,399
into the API and that's what happened to

00:24:51,899 --> 00:24:58,500
us here basically this is a we called it

00:24:56,399 --> 00:25:00,779
the bubble plugin because in the end you

00:24:58,500 --> 00:25:03,419
would have a visualization which looks

00:25:00,779 --> 00:25:06,360
like a lot of bubbles but what this is

00:25:03,419 --> 00:25:08,610
is basically a similar functionality to

00:25:06,360 --> 00:25:13,169
what you have now is the significant

00:25:08,610 --> 00:25:16,529
terms facet only it's we did this over a

00:25:13,169 --> 00:25:18,899
year ago and it has a lot of added logic

00:25:16,529 --> 00:25:20,250
within that so it's anagrams its

00:25:18,899 --> 00:25:25,679
approach 10 grams and lot of other stuff

00:25:20,250 --> 00:25:28,590
and basically that that emerged from the

00:25:25,679 --> 00:25:31,200
fact that if we wanted to have this in a

00:25:28,590 --> 00:25:33,629
distributed in a fast way we really have

00:25:31,200 --> 00:25:35,460
to dig too deep to dig deep into

00:25:33,629 --> 00:25:38,429
elasticsearch so the way this works

00:25:35,460 --> 00:25:40,549
basically you issue a query you get back

00:25:38,429 --> 00:25:44,190
and for example a thousand results so

00:25:40,549 --> 00:25:46,019
1500 results depends on the accuracy of

00:25:44,190 --> 00:25:48,600
the representation that you're looking

00:25:46,019 --> 00:25:51,480
for and then once you've got the results

00:25:48,600 --> 00:25:53,250
you're going to go one by one and you're

00:25:51,480 --> 00:25:56,639
going to do some sort of parsing and

00:25:53,250 --> 00:25:59,009
some sort of of computations on top of

00:25:56,639 --> 00:26:02,759
the text on the actual text that is

00:25:59,009 --> 00:26:06,000
coming back now some documents that's

00:26:02,759 --> 00:26:08,549
been done on by scraping social networks

00:26:06,000 --> 00:26:10,490
and websites and blogs some some content

00:26:08,549 --> 00:26:12,990
can be very very large so if we were

00:26:10,490 --> 00:26:16,409
querying elasticsearch which is a

00:26:12,990 --> 00:26:18,419
distributed search engine and you wanted

00:26:16,409 --> 00:26:20,100
to get back those results and then go

00:26:18,419 --> 00:26:22,559
one by one and do this pricing

00:26:20,100 --> 00:26:25,580
calculation that would basically mean

00:26:22,559 --> 00:26:29,340
you'd have you cannot scale so each such

00:26:25,580 --> 00:26:31,440
operation it's each such logic is going

00:26:29,340 --> 00:26:33,539
to take you quite quite a few minutes to

00:26:31,440 --> 00:26:35,970
perform and think what happens for

00:26:33,539 --> 00:26:38,879
example when you have multiple people

00:26:35,970 --> 00:26:41,429
doing this all together now even for one

00:26:38,879 --> 00:26:43,769
customers where one customer waiting for

00:26:41,429 --> 00:26:47,700
a couple of minutes for this graphic to

00:26:43,769 --> 00:26:50,580
show is a bit of the killer

00:26:47,700 --> 00:26:53,159
what we did we did we are we dug into

00:26:50,580 --> 00:26:56,659
elasticsearch and basically implemented

00:26:53,159 --> 00:26:58,919
our own search engine so instead of

00:26:56,659 --> 00:27:01,919
actually getting back the results and

00:26:58,919 --> 00:27:03,630
doing stuff we actually took the code

00:27:01,919 --> 00:27:06,240
from elasticsearch it does a search and

00:27:03,630 --> 00:27:08,100
returns back the results and instead of

00:27:06,240 --> 00:27:11,130
returning back results we did all the

00:27:08,100 --> 00:27:13,500
logic of the text processing on that on

00:27:11,130 --> 00:27:16,500
that phase now what that allowed us to

00:27:13,500 --> 00:27:18,809
do is actually have that that

00:27:16,500 --> 00:27:21,090
calculation or that computation text

00:27:18,809 --> 00:27:23,549
processing been done on each and every

00:27:21,090 --> 00:27:25,679
shot in parallel and then instead of

00:27:23,549 --> 00:27:28,260
returning back all of the documents we

00:27:25,679 --> 00:27:31,919
would have gotten gotten from this

00:27:28,260 --> 00:27:33,870
plugin just multiple buckets saying okay

00:27:31,919 --> 00:27:36,299
this is a significant term and this is a

00:27:33,870 --> 00:27:39,029
significant terms and those are the the

00:27:36,299 --> 00:27:40,980
count and then the master node accepting

00:27:39,029 --> 00:27:43,950
that requires would have just merged

00:27:40,980 --> 00:27:45,450
those buckets together and gave us this

00:27:43,950 --> 00:27:49,559
results back which and then we could

00:27:45,450 --> 00:27:53,700
have generated that graphic now that's a

00:27:49,559 --> 00:27:56,309
very very very tough to do it broke with

00:27:53,700 --> 00:27:58,620
every minor version because we dug so

00:27:56,309 --> 00:28:00,600
deep into the elastic search core but

00:27:58,620 --> 00:28:03,539
back in the time we didn't really have

00:28:00,600 --> 00:28:05,399
any other way of doing that also just

00:28:03,539 --> 00:28:07,919
you know debugging this was a really

00:28:05,399 --> 00:28:10,440
really really big pain we basically just

00:28:07,919 --> 00:28:14,010
write a lot of debugging or traces

00:28:10,440 --> 00:28:16,860
everywhere and then use relax sorry log

00:28:14,010 --> 00:28:18,630
stash and some Cabana to actually

00:28:16,860 --> 00:28:23,399
understand the timeline of what's going

00:28:18,630 --> 00:28:25,950
on very very painful so going back to

00:28:23,399 --> 00:28:28,980
elasticsearch again just an HTTP server

00:28:25,950 --> 00:28:30,840
so why not just serve static content out

00:28:28,980 --> 00:28:32,309
of it and that's where site plugins

00:28:30,840 --> 00:28:33,899
coming and those probably are the

00:28:32,309 --> 00:28:38,820
plugins that most of you are already

00:28:33,899 --> 00:28:42,179
familiar with so cabana marvel big disk

00:28:38,820 --> 00:28:44,610
and all of those and many others are

00:28:42,179 --> 00:28:48,419
basically plugins that are just static

00:28:44,610 --> 00:28:50,760
HTML files or static files in general

00:28:48,419 --> 00:28:53,070
that you can just tell a sixer to give

00:28:50,760 --> 00:28:55,230
give give you back once you get them

00:28:53,070 --> 00:28:57,960
back you can just communicate with the

00:28:55,230 --> 00:29:00,690
cluster use the with them or maybe

00:28:57,960 --> 00:29:01,470
sometimes you can just serve files which

00:29:00,690 --> 00:29:03,539
are not related to

00:29:01,470 --> 00:29:05,159
success at all and again don't use

00:29:03,539 --> 00:29:07,530
elasticsearch to serve your website

00:29:05,159 --> 00:29:11,940
don't expose the elastic search to the

00:29:07,530 --> 00:29:15,630
outside world some more advanced stuff

00:29:11,940 --> 00:29:18,900
includes discovery basically how elastic

00:29:15,630 --> 00:29:22,230
search finds other nodes within the

00:29:18,900 --> 00:29:25,590
cluster so my personal recommendation is

00:29:22,230 --> 00:29:28,860
never to use multicast in a production

00:29:25,590 --> 00:29:31,320
environment rarely are the cases where

00:29:28,860 --> 00:29:33,510
I've actually seen used to that you

00:29:31,320 --> 00:29:37,159
usually you would want to be familiar

00:29:33,510 --> 00:29:40,169
with your servers and then use unicast

00:29:37,159 --> 00:29:42,240
sometimes during development mostly it's

00:29:40,169 --> 00:29:45,059
not possible and then you want to have

00:29:42,240 --> 00:29:47,520
multicast basically auto-detection an

00:29:45,059 --> 00:29:51,270
auto forming of the cluster this is

00:29:47,520 --> 00:29:54,720
where you use discovery mechanisms which

00:29:51,270 --> 00:29:56,370
is in discovery the basic one does

00:29:54,720 --> 00:30:00,330
automatically for you but sometimes it

00:29:56,370 --> 00:30:03,659
needs some help with regards to various

00:30:00,330 --> 00:30:06,960
cloud implementations so those already

00:30:03,659 --> 00:30:09,690
implemented for the the major cloudy the

00:30:06,960 --> 00:30:11,760
major clouds already implemented and

00:30:09,690 --> 00:30:13,890
there is also the zookeeper plugin which

00:30:11,760 --> 00:30:16,590
I think with worth mentioning even

00:30:13,890 --> 00:30:18,960
though it's a bit out of date now it's a

00:30:16,590 --> 00:30:21,630
way for you to actually make sure that

00:30:18,960 --> 00:30:23,840
you don't get partial partitions which I

00:30:21,630 --> 00:30:29,909
know is currently being worked on but

00:30:23,840 --> 00:30:32,580
both noting the late recent versions of

00:30:29,909 --> 00:30:35,150
elastic search give you the ability to

00:30:32,580 --> 00:30:38,850
do snapshot and restore functionalities

00:30:35,150 --> 00:30:42,570
to various locations including file

00:30:38,850 --> 00:30:45,240
system various clouds and basically

00:30:42,570 --> 00:30:47,370
again all the major cloud

00:30:45,240 --> 00:30:50,520
implementations already implemented for

00:30:47,370 --> 00:30:53,909
you and but you can roll your own and

00:30:50,520 --> 00:30:59,039
then once you you do that you basically

00:30:53,909 --> 00:31:01,380
can restore an update sorry snapshot and

00:30:59,039 --> 00:31:04,590
restore from whatever other

00:31:01,380 --> 00:31:07,320
implementation you wish let's talk about

00:31:04,590 --> 00:31:10,710
rivers for a second rivers are being

00:31:07,320 --> 00:31:14,830
widely used rivers is basically a way

00:31:10,710 --> 00:31:16,659
for a sick search to digest data meaning

00:31:14,830 --> 00:31:18,309
you have an elastic search running so

00:31:16,659 --> 00:31:20,200
you are going to have some sort of a

00:31:18,309 --> 00:31:22,539
plugin with it within that elasticsearch

00:31:20,200 --> 00:31:25,570
instance that is going to digest data

00:31:22,539 --> 00:31:28,419
for example from curing servers from I

00:31:25,570 --> 00:31:30,100
don't know scraping the web and whatever

00:31:28,419 --> 00:31:33,250
other implementations are so many

00:31:30,100 --> 00:31:35,950
implementations out there Oh River

00:31:33,250 --> 00:31:38,549
plugins are obsolete or about to get

00:31:35,950 --> 00:31:42,549
obsolete you should as a general note

00:31:38,549 --> 00:31:46,029
not do that now the idea behind rivers I

00:31:42,549 --> 00:31:47,980
don't know it may may appeal for some so

00:31:46,029 --> 00:31:50,679
you have some logic that happens

00:31:47,980 --> 00:31:53,200
automatically to index data for you the

00:31:50,679 --> 00:31:56,320
problem with that is that this is very

00:31:53,200 --> 00:31:59,200
prone to failure as a general rule I

00:31:56,320 --> 00:32:01,779
will usually recommend people to use the

00:31:59,200 --> 00:32:04,299
pool based in change ingestion rather

00:32:01,779 --> 00:32:07,029
sorry push-based rather than pool based

00:32:04,299 --> 00:32:11,590
so river is pool based is I'm here just

00:32:07,029 --> 00:32:14,289
give me everything push-based oh I like

00:32:11,590 --> 00:32:17,110
calling these shoveling is basically I'm

00:32:14,289 --> 00:32:19,809
here I know my cluster is there and then

00:32:17,110 --> 00:32:21,639
I can push data to that cluster now when

00:32:19,809 --> 00:32:25,600
you use the push based you can scale out

00:32:21,639 --> 00:32:27,669
that pushing the shoveling operation so

00:32:25,600 --> 00:32:30,309
or you can if you have a backlog you can

00:32:27,669 --> 00:32:34,149
catch up on that and so on with rivers

00:32:30,309 --> 00:32:37,929
it's very very very it's more it's more

00:32:34,149 --> 00:32:39,549
complex than that now you can use log

00:32:37,929 --> 00:32:41,950
stash there is something that's called

00:32:39,549 --> 00:32:45,029
stream two years which I found actually

00:32:41,950 --> 00:32:48,130
very useful to to play with it a bit or

00:32:45,029 --> 00:32:50,880
sometimes extend sometimes just demo

00:32:48,130 --> 00:32:53,710
stuff or quickly come up with with

00:32:50,880 --> 00:32:55,750
shoveling mechanism which you should

00:32:53,710 --> 00:33:01,240
really look into whatever you do I

00:32:55,750 --> 00:33:05,049
recommend you don't use the rivers sorry

00:33:01,240 --> 00:33:07,149
about that so let's let's wrap probably

00:33:05,049 --> 00:33:10,799
a bit so we have multiple plugin types

00:33:07,149 --> 00:33:14,169
in elastic search some of them are

00:33:10,799 --> 00:33:18,220
losing parts which you can play with you

00:33:14,169 --> 00:33:20,830
can replace in some are some sort of

00:33:18,220 --> 00:33:23,590
elastic search functionalities that you

00:33:20,830 --> 00:33:27,909
can either enhance or just a do on your

00:33:23,590 --> 00:33:28,650
own and installing plugins and once you

00:33:27,909 --> 00:33:32,070
have a plug-in

00:33:28,650 --> 00:33:35,100
which has to be a jar basically JVM

00:33:32,070 --> 00:33:37,560
bytecode it can I it can be a site

00:33:35,100 --> 00:33:41,490
plugin but again it has to be within a

00:33:37,560 --> 00:33:43,710
jar and basically you install it using

00:33:41,490 --> 00:33:46,320
either manually basically unzipping it

00:33:43,710 --> 00:33:49,080
into the plugins folder of elastic

00:33:46,320 --> 00:33:51,300
search or using the existing tool that

00:33:49,080 --> 00:33:53,580
will let you do this that way it will do

00:33:51,300 --> 00:33:57,540
this for you so you can go and fetch

00:33:53,580 --> 00:34:02,400
using the tool from from github from

00:33:57,540 --> 00:34:04,710
maven from from obstacle maven the

00:34:02,400 --> 00:34:07,620
open-source maven repository so you can

00:34:04,710 --> 00:34:09,750
use Mary repositories or github or you

00:34:07,620 --> 00:34:12,270
can just point it to a URL and install

00:34:09,750 --> 00:34:16,110
from that URL if you cannot publish to

00:34:12,270 --> 00:34:17,669
github or or maven once you have those

00:34:16,110 --> 00:34:20,550
plugins installed you can get

00:34:17,669 --> 00:34:23,790
information about those plugins either

00:34:20,550 --> 00:34:26,100
using the tool or you can go to the

00:34:23,790 --> 00:34:28,169
cluster and ask it for using the

00:34:26,100 --> 00:34:30,030
knowledge info API you can get back a

00:34:28,169 --> 00:34:33,450
list of nodes and whatever plugins are

00:34:30,030 --> 00:34:36,270
installed on them once you get that info

00:34:33,450 --> 00:34:40,830
you can obviously remove plugins if need

00:34:36,270 --> 00:34:44,100
be so when do you want actually to write

00:34:40,830 --> 00:34:45,899
plugins don't be this guy don't come and

00:34:44,100 --> 00:34:49,830
say okay have a problem let's write a

00:34:45,899 --> 00:34:52,590
plugin that's really try to ignore the

00:34:49,830 --> 00:34:55,740
urge to write plugins that may be

00:34:52,590 --> 00:34:59,400
interesting but it can get very quickly

00:34:55,740 --> 00:35:03,150
very painful that's the next slide we'll

00:34:59,400 --> 00:35:04,680
see some pain pain points the defaults

00:35:03,150 --> 00:35:06,960
are pretty good and you can do a lot

00:35:04,680 --> 00:35:09,150
with description link mechanism you can

00:35:06,960 --> 00:35:11,010
do a lot with whatever else there is in

00:35:09,150 --> 00:35:13,470
elasticsearch the aggravations ramp

00:35:11,010 --> 00:35:17,430
framework just made a lot of faceting

00:35:13,470 --> 00:35:19,560
much more easier but sometimes you

00:35:17,430 --> 00:35:21,300
really don't have any other choice so

00:35:19,560 --> 00:35:25,680
when you do need to have some

00:35:21,300 --> 00:35:27,270
distributed behavior done and you cannot

00:35:25,680 --> 00:35:31,710
really achieve that by any of the

00:35:27,270 --> 00:35:34,200
elastic search ways of doing that like

00:35:31,710 --> 00:35:37,230
for example the bubble example just gave

00:35:34,200 --> 00:35:39,690
you this is where you go and do this

00:35:37,230 --> 00:35:42,060
distributed sorry this is where you go

00:35:39,690 --> 00:35:44,280
and write a plugin

00:35:42,060 --> 00:35:46,920
or when we you need to distribute some

00:35:44,280 --> 00:35:49,920
some rest functionality or when it's

00:35:46,920 --> 00:35:53,010
just a site plugin but other than that

00:35:49,920 --> 00:35:55,020
most of the most of the work that of

00:35:53,010 --> 00:35:56,850
writing a plug-in doesn't really work

00:35:55,020 --> 00:36:00,360
that that doesn't really work that and

00:35:56,850 --> 00:36:02,700
what is this work that's I would say

00:36:00,360 --> 00:36:04,260
it's basically for things so the first

00:36:02,700 --> 00:36:06,240
thing is really maintenance so once

00:36:04,260 --> 00:36:07,650
you've written code you will need to

00:36:06,240 --> 00:36:09,480
maintain it you need to make sure it

00:36:07,650 --> 00:36:12,570
runs we need to make sure it operates

00:36:09,480 --> 00:36:15,020
well and again it needs to operate well

00:36:12,570 --> 00:36:18,780
within the rest of the infrastructure

00:36:15,020 --> 00:36:21,270
and the deeper you go into the classic

00:36:18,780 --> 00:36:25,260
Search API the most likely it is to

00:36:21,270 --> 00:36:27,840
break very very soon once you have a

00:36:25,260 --> 00:36:29,670
plug-in it's it's a lot of times really

00:36:27,840 --> 00:36:32,910
paint to actually deploy that and

00:36:29,670 --> 00:36:35,580
actually version that although there are

00:36:32,910 --> 00:36:38,070
ways to overcome that using puppet for

00:36:35,580 --> 00:36:40,970
example it is still a very difficult

00:36:38,070 --> 00:36:43,160
sometimes to keep up with versioning i

00:36:40,970 --> 00:36:45,210
mentioned auxiliary data meaning

00:36:43,160 --> 00:36:47,610
dictionaries for example so if you have

00:36:45,210 --> 00:36:49,110
an analyzer that actually wants to load

00:36:47,610 --> 00:36:51,420
the dictionary and use the elastic

00:36:49,110 --> 00:36:54,150
search mechanism for that again thinking

00:36:51,420 --> 00:36:56,970
that those that data if it needs to be

00:36:54,150 --> 00:36:59,580
on the file system and not on some cloud

00:36:56,970 --> 00:37:01,740
that's going to be challenging there is

00:36:59,580 --> 00:37:04,770
an open open ticket on elasticsearch

00:37:01,740 --> 00:37:07,290
elastic repository for may be exposing

00:37:04,770 --> 00:37:11,220
that and allowing analyzers or plugins

00:37:07,290 --> 00:37:13,890
to load data out of the document store

00:37:11,220 --> 00:37:16,500
that is elastic search it's not being

00:37:13,890 --> 00:37:18,420
worked on currently so it may be may

00:37:16,500 --> 00:37:20,940
have it may take some time for that to

00:37:18,420 --> 00:37:23,400
actually come to the core and then you

00:37:20,940 --> 00:37:25,230
have all the headaches of testing and

00:37:23,400 --> 00:37:29,330
debugging and again making sure

00:37:25,230 --> 00:37:33,870
everything ticks and that's a big pain

00:37:29,330 --> 00:37:36,690
so one final slide how you do that so I

00:37:33,870 --> 00:37:39,630
know it's a bit small here but the idea

00:37:36,690 --> 00:37:42,270
is basically creating a plugin class

00:37:39,630 --> 00:37:45,780
which derives from abstract plug-in and

00:37:42,270 --> 00:37:48,750
that class basically points to a lot of

00:37:45,780 --> 00:37:51,390
different implementations that you can

00:37:48,750 --> 00:37:53,520
have for a plug-in so I would say the

00:37:51,390 --> 00:37:55,859
most basic one is a module so you say

00:37:53,520 --> 00:37:58,609
okay here is a module this module

00:37:55,859 --> 00:38:02,400
does this and that it defines its own

00:37:58,609 --> 00:38:03,809
tools for elasticsearch and bay and that

00:38:02,400 --> 00:38:06,509
once you have that module you can just

00:38:03,809 --> 00:38:09,239
inject it to elasticsearch using this

00:38:06,509 --> 00:38:12,720
plugin plugin class that plug in class

00:38:09,239 --> 00:38:14,880
basically is being referred to by some

00:38:12,720 --> 00:38:18,749
embedded resource within the jar that

00:38:14,880 --> 00:38:21,599
tells it where to bootstrap everything

00:38:18,749 --> 00:38:24,420
there there are other things that you

00:38:21,599 --> 00:38:26,819
can you can come up with so transport

00:38:24,420 --> 00:38:29,069
actions or rest actions and all of that

00:38:26,819 --> 00:38:30,359
kind of stuff are basically just classes

00:38:29,069 --> 00:38:32,640
that you can easily find the

00:38:30,359 --> 00:38:35,509
documentation just implement them and

00:38:32,640 --> 00:38:37,559
give this give them your own

00:38:35,509 --> 00:38:39,989
implementations we're pretty much out of

00:38:37,559 --> 00:38:55,890
time so I will take one two quick

00:38:39,989 --> 00:39:03,269
questions and let you all go okay great

00:38:55,890 --> 00:39:06,269
thanks so taking questions oh so it just

00:39:03,269 --> 00:39:09,569
a quick feedback on the discovery

00:39:06,269 --> 00:39:13,079
plugins I know you come from the dotnet

00:39:09,569 --> 00:39:16,430
world did you use the zero plugin

00:39:13,079 --> 00:39:20,099
discovery plugin discovery on the plant

00:39:16,430 --> 00:39:22,609
so it's the natto there are you sure

00:39:20,099 --> 00:39:26,099
yeah no I haven't I haven't tested it

00:39:22,609 --> 00:39:28,109
you know no I know I'm usually I'm

00:39:26,099 --> 00:39:30,569
usually when I'm even more when I'm

00:39:28,109 --> 00:39:32,579
working with the dead clients I usually

00:39:30,569 --> 00:39:34,829
just tell them use linux 24

00:39:32,579 --> 00:39:37,200
elasticsearch it feels much more natural

00:39:34,829 --> 00:39:39,569
for me to actually run elasticsearch on

00:39:37,200 --> 00:39:41,009
on Linux machines and then you know

00:39:39,569 --> 00:39:49,859
development you can just do and don't

00:39:41,009 --> 00:39:54,059
let it connect to that good any more

00:39:49,859 --> 00:39:55,259
questions okay great thank you very much

00:39:54,059 --> 00:39:57,380
again for your presentation thank you

00:39:55,259 --> 00:39:57,380
guys

00:39:57,920 --> 00:39:59,980

YouTube URL: https://www.youtube.com/watch?v=FbAO2k57bdg


