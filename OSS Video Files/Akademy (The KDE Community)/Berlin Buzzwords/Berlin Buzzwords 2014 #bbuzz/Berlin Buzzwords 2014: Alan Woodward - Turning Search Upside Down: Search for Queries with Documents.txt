Title: Berlin Buzzwords 2014: Alan Woodward - Turning Search Upside Down: Search for Queries with Documents
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	While normal search engines allow you to search over large document collections with individual queries, monitoring systems have different requirements: to run large numbers of stored queries over a stream of incoming documents, and provide exact matches for those queries that hit. This can be an expensive process, in terms of time, memory and hardware.  

In this talk I'll discuss the luwak open-source library, built by Flax to solve just this problem, and show how we reduce the problem space by turning the problem upside down, converting queries into documents, and documents into queries.

Read more:
https://2014.berlinbuzzwords.de/session/turning-search-upside-down-search-queries-documents

About Alan Woodward
https://2014.berlinbuzzwords.de/user/321/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:06,230 --> 00:00:13,810
okay okay hi everyone my name is Alan

00:00:10,380 --> 00:00:17,370
Woodward's I went with flax which is

00:00:13,810 --> 00:00:19,470
based in Cambridge in the UK I'm a

00:00:17,370 --> 00:00:21,550
listener seller committer

00:00:19,470 --> 00:00:25,090
and I'm going to talk to you today about

00:00:21,550 --> 00:00:27,910
turning search upside-down which is

00:00:25,090 --> 00:00:30,009
colored nonsensical so what does that

00:00:27,910 --> 00:00:33,750
actually mean so the use cases that we

00:00:30,009 --> 00:00:35,800
are using that we're looking at are

00:00:33,750 --> 00:00:37,810
circumstances where you have lots and

00:00:35,800 --> 00:00:39,190
lots and lots of queries and you want to

00:00:37,810 --> 00:00:41,890
run these queries over a stream of

00:00:39,190 --> 00:00:43,540
documents so in our use case it's four

00:00:41,890 --> 00:00:45,640
clippings companies it's for media

00:00:43,540 --> 00:00:48,820
monitoring but you can also use it for

00:00:45,640 --> 00:00:50,830
things like tagging or classification so

00:00:48,820 --> 00:00:52,420
what you want to do is you have your big

00:00:50,830 --> 00:00:53,620
set of stored queries for media

00:00:52,420 --> 00:00:57,640
monitoring in particular what you want

00:00:53,620 --> 00:00:59,050
to do is you want to identify media

00:00:57,640 --> 00:01:01,540
stories that are of interest to your

00:00:59,050 --> 00:01:04,420
client so you will create a large query

00:01:01,540 --> 00:01:06,460
which says okay if you have any of these

00:01:04,420 --> 00:01:07,900
terms in this document that I'm

00:01:06,460 --> 00:01:10,420
interested in it I want to find out

00:01:07,900 --> 00:01:12,340
about it so you have various different

00:01:10,420 --> 00:01:14,250
think there there is different bits of

00:01:12,340 --> 00:01:16,509
information that you want from these

00:01:14,250 --> 00:01:17,710
these queries you can say either I just

00:01:16,509 --> 00:01:19,200
want to know if this query matches or

00:01:17,710 --> 00:01:21,219
not so if you're tagging for example

00:01:19,200 --> 00:01:22,359
you've got a big query that's had

00:01:21,219 --> 00:01:26,320
anything that matches this query should

00:01:22,359 --> 00:01:27,189
be tagged with this term so it's going

00:01:26,320 --> 00:01:30,399
to say I just wanna know if it matches

00:01:27,189 --> 00:01:32,740
or not you might want scoring

00:01:30,399 --> 00:01:33,969
information you might want exact match

00:01:32,740 --> 00:01:35,619
position the information you wanted to

00:01:33,969 --> 00:01:37,780
say okay I've got this query I want to

00:01:35,619 --> 00:01:41,289
know the exact bits of this document

00:01:37,780 --> 00:01:42,789
that matched this query how we're going

00:01:41,289 --> 00:01:44,920
to do that well the easy answer is you

00:01:42,789 --> 00:01:49,689
use the memory index which is something

00:01:44,920 --> 00:01:53,170
a an object in Lusine which is an index

00:01:49,689 --> 00:01:55,539
for a single document and then you can

00:01:53,170 --> 00:01:57,039
get your so your index your document and

00:01:55,539 --> 00:01:58,270
then you get your any number of queries

00:01:57,039 --> 00:02:00,280
and you run all those queries against

00:01:58,270 --> 00:02:05,170
that document and you pull the results

00:02:00,280 --> 00:02:07,990
out and you respond which is fine it

00:02:05,170 --> 00:02:13,690
works and you can one problem with it

00:02:07,990 --> 00:02:16,350
which is that it's very slow we're

00:02:13,690 --> 00:02:21,580
talking about very very large queries

00:02:16,350 --> 00:02:24,340
these are very complex queries really

00:02:21,580 --> 00:02:26,530
very very big as you point out this

00:02:24,340 --> 00:02:27,560
isn't actually a real query because the

00:02:26,530 --> 00:02:30,590
queries are kind of

00:02:27,560 --> 00:02:32,030
but our client said quite protective

00:02:30,590 --> 00:02:34,069
Larry so this is made at one but anyway

00:02:32,030 --> 00:02:35,989
it gives you an idea of quite how big

00:02:34,069 --> 00:02:37,670
we're talking about and it's not just

00:02:35,989 --> 00:02:40,819
the size of them it's what they consist

00:02:37,670 --> 00:02:42,680
of they are very ugly queries these are

00:02:40,819 --> 00:02:45,290
not queries that are written by people

00:02:42,680 --> 00:02:46,280
who are coders they're not generally

00:02:45,290 --> 00:02:47,420
written by it's certainly not written by

00:02:46,280 --> 00:02:50,959
people who understand how search engines

00:02:47,420 --> 00:02:52,340
work so you'll have lots of world cards

00:02:50,959 --> 00:02:54,280
everywhere you'll have people putting

00:02:52,340 --> 00:02:57,260
the same term in with different

00:02:54,280 --> 00:02:58,730
capitalizations you'll get wild cards

00:02:57,260 --> 00:03:01,330
but at the end end at the beginning of

00:02:58,730 --> 00:03:03,319
terms even though that kills performance

00:03:01,330 --> 00:03:04,730
and that people don't don't really

00:03:03,319 --> 00:03:08,030
understand how stemming works so they

00:03:04,730 --> 00:03:09,350
stick a wild card in the end too to get

00:03:08,030 --> 00:03:11,330
all forms of a word even though there's

00:03:09,350 --> 00:03:13,640
already stemming built in there you'll

00:03:11,330 --> 00:03:14,690
get people who didn't work when you put

00:03:13,640 --> 00:03:19,099
it in once maybe we've put it in the

00:03:14,690 --> 00:03:20,870
query twice that'll work so these are

00:03:19,099 --> 00:03:22,700
enormous queries they have lots and lots

00:03:20,870 --> 00:03:24,410
of wild cards in them which means that

00:03:22,700 --> 00:03:26,360
if you're running one of these queries

00:03:24,410 --> 00:03:27,650
against running every single one of

00:03:26,360 --> 00:03:29,330
these queries against each document

00:03:27,650 --> 00:03:31,220
every one of those queries has to be

00:03:29,330 --> 00:03:36,290
rewritten for that document which takes

00:03:31,220 --> 00:03:38,510
time so typical document that passes

00:03:36,290 --> 00:03:41,390
through this is a client that we've just

00:03:38,510 --> 00:03:43,579
built this for you've got about 20,000

00:03:41,390 --> 00:03:47,750
queries and the typical document goes

00:03:43,579 --> 00:03:49,370
through will match maybe two that's

00:03:47,750 --> 00:03:51,799
nineteen thousand nine hundred and

00:03:49,370 --> 00:03:55,250
ninety eight ninety nine there for some

00:03:51,799 --> 00:03:57,319
reason the queries there which you're

00:03:55,250 --> 00:04:00,709
running for no reason whatsoever they're

00:03:57,319 --> 00:04:02,989
just taking up time and we want to be

00:04:00,709 --> 00:04:07,880
able to reduce the amount of time that's

00:04:02,989 --> 00:04:10,940
these useless queries take preferably to

00:04:07,880 --> 00:04:14,359
zero milliseconds and the best way to

00:04:10,940 --> 00:04:16,579
reduce the amount of time that a query

00:04:14,359 --> 00:04:20,510
takes is to not run it at all in the

00:04:16,579 --> 00:04:24,139
first case so what we want to do is we

00:04:20,510 --> 00:04:26,510
want to pre select the queries that we

00:04:24,139 --> 00:04:27,979
think are likely to get a hit and we

00:04:26,510 --> 00:04:32,479
want to filter out those queries that we

00:04:27,979 --> 00:04:34,850
know aren't going to get a hit it just

00:04:32,479 --> 00:04:36,710
kind like a search okay you've got a

00:04:34,850 --> 00:04:38,360
space of queries and you want to search

00:04:36,710 --> 00:04:40,930
those queries with your document it's a

00:04:38,360 --> 00:04:40,930
backward search

00:04:41,119 --> 00:04:45,439
and yes the aim is to get as few false

00:04:44,119 --> 00:04:47,539
positives as possible so we want to

00:04:45,439 --> 00:04:48,919
really restrict the number recruiters

00:04:47,539 --> 00:04:50,929
we're running you want to really only

00:04:48,919 --> 00:04:52,729
run ones that are have a very decent

00:04:50,929 --> 00:04:55,639
chance of hitting but you want zero

00:04:52,729 --> 00:04:57,859
false negatives you don't want to miss

00:04:55,639 --> 00:05:00,259
out any of those queries that might have

00:04:57,859 --> 00:05:01,519
got a hit because if you do that then

00:05:00,259 --> 00:05:03,529
you've got your getting inaccurate

00:05:01,519 --> 00:05:07,039
results and particularly in the case of

00:05:03,529 --> 00:05:08,149
media monitoring where now there's quite

00:05:07,039 --> 00:05:10,729
a lot of competition there

00:05:08,149 --> 00:05:13,279
if someone says if your client comes

00:05:10,729 --> 00:05:14,629
along and says this particular article

00:05:13,279 --> 00:05:16,819
came in that mentioned my name and you

00:05:14,629 --> 00:05:18,109
missed it why am i paying you this

00:05:16,819 --> 00:05:19,609
amount of money to do this I'm going to

00:05:18,109 --> 00:05:22,279
go to your competitor so it's very

00:05:19,609 --> 00:05:23,779
important that we get no false negatives

00:05:22,279 --> 00:05:25,909
that we actually retrieve everything we

00:05:23,779 --> 00:05:33,319
run every query that could possibly get

00:05:25,909 --> 00:05:37,009
a hit so what we've done is flax we

00:05:33,319 --> 00:05:40,999
built a Java library called Luwak which

00:05:37,009 --> 00:05:44,899
does just this it's stores a whole bag

00:05:40,999 --> 00:05:46,339
of leucine queries you registered them

00:05:44,899 --> 00:05:49,099
with your with the monitor it stores

00:05:46,339 --> 00:05:50,839
them in an internal index when a

00:05:49,099 --> 00:05:52,459
document comes into the monitor that

00:05:50,839 --> 00:05:54,589
document is then converted into a query

00:05:52,459 --> 00:05:56,839
which is run over that internal index

00:05:54,589 --> 00:05:59,689
and that selects which of those store

00:05:56,839 --> 00:06:02,719
queries to run then runs those queries

00:05:59,689 --> 00:06:04,279
and gives you gives you your results

00:06:02,719 --> 00:06:06,909
back from the queries that it has

00:06:04,279 --> 00:06:09,319
selected to run this is all pluggable

00:06:06,909 --> 00:06:11,569
there is something called a pre searcher

00:06:09,319 --> 00:06:13,269
which deals with translating the queries

00:06:11,569 --> 00:06:16,369
into terms that can be indexed and

00:06:13,269 --> 00:06:19,459
translates the document into something

00:06:16,369 --> 00:06:21,019
that could be queried and then the match

00:06:19,459 --> 00:06:23,299
reporting as well as all pluggable so

00:06:21,019 --> 00:06:24,859
you can say I just want to know you know

00:06:23,299 --> 00:06:26,839
is it a match or not I want to let the

00:06:24,859 --> 00:06:33,379
score they're different matches that you

00:06:26,839 --> 00:06:35,659
pass to it how does it work so we index

00:06:33,379 --> 00:06:37,279
queries by having a bunch of things

00:06:35,659 --> 00:06:40,339
called extractors which are

00:06:37,279 --> 00:06:42,289
parameterised by the query and you can

00:06:40,339 --> 00:06:43,699
have again these are pluggable so you

00:06:42,289 --> 00:06:45,049
can put in your own if you have your own

00:06:43,699 --> 00:06:49,099
queries and you can have put your own

00:06:45,049 --> 00:06:50,360
way of extracting terms from them term

00:06:49,099 --> 00:06:52,050
query is very easy would you say ok

00:06:50,360 --> 00:06:55,030
we'll just pull the term out

00:06:52,050 --> 00:06:56,980
numeric queries are turn queries as well

00:06:55,030 --> 00:06:59,890
underneath so again just pull the term

00:06:56,980 --> 00:07:01,210
out and a boolean query a boolean you

00:06:59,890 --> 00:07:04,660
can think of a boolean queries as a kind

00:07:01,210 --> 00:07:06,220
of tree and we recurse through that

00:07:04,660 --> 00:07:08,230
query tree and we pull out all the terms

00:07:06,220 --> 00:07:13,020
that we find within that query tree and

00:07:08,230 --> 00:07:17,380
we index those we can be a bit cleverer

00:07:13,020 --> 00:07:20,110
about how we do that ideally you want to

00:07:17,380 --> 00:07:22,210
be indexing as few terms as possible

00:07:20,110 --> 00:07:24,460
from a query because you want to only

00:07:22,210 --> 00:07:26,140
hit and the more terms you index them

00:07:24,460 --> 00:07:28,000
all likely is that query is going to get

00:07:26,140 --> 00:07:31,510
hit by any document that's coming in and

00:07:28,000 --> 00:07:32,620
so if you can if you can reduce the

00:07:31,510 --> 00:07:33,700
number of terms that you're indexing

00:07:32,620 --> 00:07:34,960
under then you're going to reduce the

00:07:33,700 --> 00:07:37,510
number of times it gets hit by a

00:07:34,960 --> 00:07:40,210
document so how can we do that well we

00:07:37,510 --> 00:07:42,460
can say obviously any must not Clause

00:07:40,210 --> 00:07:46,030
and a boolean query don't care about

00:07:42,460 --> 00:07:47,680
that if if it's a disjunction if it's

00:07:46,030 --> 00:07:50,200
just got should and must not queries

00:07:47,680 --> 00:07:52,990
then you do have to index all the

00:07:50,200 --> 00:07:55,330
various sub clauses also all be all the

00:07:52,990 --> 00:07:56,950
should clauses but if there are any must

00:07:55,330 --> 00:07:59,470
causes an if it's a conjunction of any

00:07:56,950 --> 00:08:02,380
kind then you can ignore everything else

00:07:59,470 --> 00:08:04,870
and you can say alright I just want to I

00:08:02,380 --> 00:08:06,880
just need to index one of those

00:08:04,870 --> 00:08:08,560
conjunction terms because every single

00:08:06,880 --> 00:08:10,690
one of these terms has to be present in

00:08:08,560 --> 00:08:12,600
a document for it to actually get a hit

00:08:10,690 --> 00:08:19,330
when you when you run a query over it

00:08:12,600 --> 00:08:20,560
you can say okay I only need one which

00:08:19,330 --> 00:08:23,110
means that we can we have a bit of

00:08:20,560 --> 00:08:27,340
leeway in how we decide which of these

00:08:23,110 --> 00:08:29,800
terms to index and you can say how did

00:08:27,340 --> 00:08:32,979
it well longer terms tend to be rarer so

00:08:29,800 --> 00:08:34,360
a term like the there is gonna be hid in

00:08:32,979 --> 00:08:36,760
every single document you don't really

00:08:34,360 --> 00:08:39,310
want to do that but a longer term like

00:08:36,760 --> 00:08:40,750
Jabberwock for example it's going to be

00:08:39,310 --> 00:08:43,270
fairly unusual so that's a better term

00:08:40,750 --> 00:08:44,950
to index that's gonna hit you know any

00:08:43,270 --> 00:08:46,210
document that comes in with Jabberwock

00:08:44,950 --> 00:08:47,980
and it needs to hit that one but

00:08:46,210 --> 00:08:49,990
anything else that has that in it is not

00:08:47,980 --> 00:08:52,810
going to match so we can open all that

00:08:49,990 --> 00:08:56,770
one when you're when you're requesting

00:08:52,810 --> 00:08:59,800
through the the query tree okay you

00:08:56,770 --> 00:09:01,030
might have some clauses that actually

00:08:59,800 --> 00:09:02,020
have quite a lot of terms underneath

00:09:01,030 --> 00:09:04,570
them so you've got should clause that

00:09:02,020 --> 00:09:05,620
has a bunch of other should clauses

00:09:04,570 --> 00:09:07,960
underneath it so you got

00:09:05,620 --> 00:09:10,540
two terms there on the other hand you've

00:09:07,960 --> 00:09:12,160
got should clause that's right you've

00:09:10,540 --> 00:09:13,390
got must cause that has lots of sugar

00:09:12,160 --> 00:09:14,380
causes underneath it on the other hand

00:09:13,390 --> 00:09:16,420
you've got a must close that it's got

00:09:14,380 --> 00:09:18,520
just one term underneath it then okay

00:09:16,420 --> 00:09:19,900
let's you'll tend to prefer the one with

00:09:18,520 --> 00:09:21,460
just a single term because again that's

00:09:19,900 --> 00:09:25,330
fewer terms to index and you're less

00:09:21,460 --> 00:09:27,970
likely to hit but there are fields that

00:09:25,330 --> 00:09:30,190
you want to avoid so for example if

00:09:27,970 --> 00:09:31,480
you've got quite a lot of the queries we

00:09:30,190 --> 00:09:35,560
can that we have are of the form

00:09:31,480 --> 00:09:37,570
category X and massive great query and

00:09:35,560 --> 00:09:38,830
if you're being naive about it then

00:09:37,570 --> 00:09:40,420
you're gonna say okay well the category

00:09:38,830 --> 00:09:42,820
X is actually that's the shorter term so

00:09:40,420 --> 00:09:44,350
let's just index that but it turns out

00:09:42,820 --> 00:09:49,450
that the category is something that is

00:09:44,350 --> 00:09:50,589
has very low cardinality and so say 50%

00:09:49,450 --> 00:09:52,740
of your documents coming through have

00:09:50,589 --> 00:09:54,940
category X they're all going to get run

00:09:52,740 --> 00:09:57,430
all those queries that are indexed under

00:09:54,940 --> 00:10:02,230
that are going to get run and in fact we

00:09:57,430 --> 00:10:03,850
did I came across this for a client that

00:10:02,230 --> 00:10:05,740
just working on now where we found that

00:10:03,850 --> 00:10:08,680
we were we were really not cutting out

00:10:05,740 --> 00:10:10,900
very many queries and it was because it

00:10:08,680 --> 00:10:13,240
was using this naive oh okay there are

00:10:10,900 --> 00:10:14,560
fewer terms and this Junction florist

00:10:13,240 --> 00:10:17,020
and this one so let's index everything

00:10:14,560 --> 00:10:21,100
under here and it ended up indexing a

00:10:17,020 --> 00:10:22,510
really really common term so we do this

00:10:21,100 --> 00:10:26,020
that we have something called a term

00:10:22,510 --> 00:10:27,730
waiter which will it takes as input all

00:10:26,020 --> 00:10:32,860
these various different sub clauses and

00:10:27,730 --> 00:10:35,050
it runs a number of thing of rules over

00:10:32,860 --> 00:10:36,640
those sub clauses and gets the score out

00:10:35,050 --> 00:10:38,860
and the one with the best score is

00:10:36,640 --> 00:10:40,660
indexed and again this is pluggable so

00:10:38,860 --> 00:10:43,870
you can choose you can tune it a lot of

00:10:40,660 --> 00:10:45,520
this stuff is it depends very much on

00:10:43,870 --> 00:10:49,900
your corpus of queries and on your

00:10:45,520 --> 00:10:51,670
corpus of documents so we can't say X is

00:10:49,900 --> 00:10:53,110
going to work for everything yeah some

00:10:51,670 --> 00:10:54,760
cases well these fields are better in

00:10:53,110 --> 00:10:56,200
these use cases these fields are better

00:10:54,760 --> 00:10:59,500
in these use cases so you need to tune

00:10:56,200 --> 00:11:00,970
it for for your use case and for your

00:10:59,500 --> 00:11:04,690
set of documents up for your set of

00:11:00,970 --> 00:11:06,459
queries more complex query things like

00:11:04,690 --> 00:11:08,430
proximity queries and phrase queries and

00:11:06,459 --> 00:11:10,750
you can just treat them as conjunctions

00:11:08,430 --> 00:11:12,940
so again you just need a single term out

00:11:10,750 --> 00:11:14,650
the phrase and it runs to the term

00:11:12,940 --> 00:11:17,350
waiter and it chooses that best term so

00:11:14,650 --> 00:11:19,959
again a phrase like the Jabberwock you

00:11:17,350 --> 00:11:22,480
can index jab or

00:11:19,959 --> 00:11:23,830
one cards of fun you saw in the the

00:11:22,480 --> 00:11:25,360
query earlier that we had lots of fun

00:11:23,830 --> 00:11:26,980
things with wild cards you had prefix

00:11:25,360 --> 00:11:28,810
wild cards and suffix wild cards

00:11:26,980 --> 00:11:31,360
how can you index something that is

00:11:28,810 --> 00:11:32,350
going to hit the it's going to hit the

00:11:31,360 --> 00:11:34,930
bits of the wild card that you're

00:11:32,350 --> 00:11:37,350
interested in what we do is whether

00:11:34,930 --> 00:11:39,850
there's actually two ways of doing it

00:11:37,350 --> 00:11:41,170
you can do it by there you can extract

00:11:39,850 --> 00:11:43,029
the longest in variant substring so if

00:11:41,170 --> 00:11:44,350
you've got a wild card that's got an

00:11:43,029 --> 00:11:45,850
asterisks with a beginning and ask first

00:11:44,350 --> 00:11:47,529
at the end you say okay we'll take the

00:11:45,850 --> 00:11:49,779
bit in the middle and we'll index that

00:11:47,529 --> 00:11:51,730
and then a document time when you're

00:11:49,779 --> 00:11:54,070
building your query out of the document

00:11:51,730 --> 00:11:56,050
as well as taking all the terms from

00:11:54,070 --> 00:11:57,339
that document you take all the engrams

00:11:56,050 --> 00:12:00,190
of all the terms from that document as

00:11:57,339 --> 00:12:01,480
well so you have the you're going to

00:12:00,190 --> 00:12:04,600
match any sub strings for the terms and

00:12:01,480 --> 00:12:06,130
the document all you can suit you can do

00:12:04,600 --> 00:12:07,630
you can say well actually we're not

00:12:06,130 --> 00:12:08,589
going to be able to we can't get

00:12:07,630 --> 00:12:10,240
anything useful out of this well card

00:12:08,589 --> 00:12:11,769
theory the wild card some query we're

00:12:10,240 --> 00:12:15,760
going to index it under a special token

00:12:11,769 --> 00:12:17,500
court on any token which means that all

00:12:15,760 --> 00:12:20,260
documents are going to match against

00:12:17,500 --> 00:12:21,459
this query thing is that normally this

00:12:20,260 --> 00:12:23,050
will appear within a conjunction

00:12:21,459 --> 00:12:25,690
somewhere so the term waiter is going to

00:12:23,050 --> 00:12:26,890
check out any tokens in preference it's

00:12:25,690 --> 00:12:28,660
going to select any other term in

00:12:26,890 --> 00:12:30,160
preference to an any token so quite

00:12:28,660 --> 00:12:31,120
often you'll find that even if you've

00:12:30,160 --> 00:12:31,959
got something with loads and loads of

00:12:31,120 --> 00:12:33,760
wildcards in it

00:12:31,959 --> 00:12:35,230
none of those well code tones actually

00:12:33,760 --> 00:12:39,899
get indexed they get thrown out by the

00:12:35,230 --> 00:12:42,100
term waiter again it depends on your

00:12:39,899 --> 00:12:44,440
your documents it depends on your query

00:12:42,100 --> 00:12:48,250
set all these things need to be measured

00:12:44,440 --> 00:12:52,810
in experimented with so on the other

00:12:48,250 --> 00:12:55,000
side how do you take this your input

00:12:52,810 --> 00:12:57,010
document and turn it into a query you've

00:12:55,000 --> 00:12:58,360
got this query index you have a bunch of

00:12:57,010 --> 00:13:00,190
queries which are indexed with against

00:12:58,360 --> 00:13:01,959
their individual terms and you need to

00:13:00,190 --> 00:13:04,050
now work out which of those queries are

00:13:01,959 --> 00:13:06,070
likely to match the documents coming in

00:13:04,050 --> 00:13:07,630
so the simple answer is you take your

00:13:06,070 --> 00:13:09,550
document you run it through your

00:13:07,630 --> 00:13:11,140
analyzer you pull out all the terms from

00:13:09,550 --> 00:13:13,209
that document and you make a massive

00:13:11,140 --> 00:13:15,130
great disjunction query and run that

00:13:13,209 --> 00:13:16,630
against the query index and everything

00:13:15,130 --> 00:13:18,640
that matches it's something that is

00:13:16,630 --> 00:13:22,300
likely to hit so you have a specialized

00:13:18,640 --> 00:13:23,800
collector which you so each each query

00:13:22,300 --> 00:13:25,449
that generates a hit you then pull that

00:13:23,800 --> 00:13:29,500
query out and run it against the

00:13:25,449 --> 00:13:31,120
document we can you can be fairly

00:13:29,500 --> 00:13:35,230
efficient about this

00:13:31,120 --> 00:13:36,430
in terms of generating the work pulling

00:13:35,230 --> 00:13:37,540
all the terms out of the document

00:13:36,430 --> 00:13:38,830
because the document is already going

00:13:37,540 --> 00:13:41,410
through analysis in order to be

00:13:38,830 --> 00:13:43,750
searchable you're creating your memory

00:13:41,410 --> 00:13:45,430
index that memory index will have a

00:13:43,750 --> 00:13:46,870
terms a name so you can just iterate

00:13:45,430 --> 00:13:49,410
through that and pull out all the terms

00:13:46,870 --> 00:13:52,270
build that into your disjunction query

00:13:49,410 --> 00:13:53,920
if you have wildcard queries there then

00:13:52,270 --> 00:13:55,480
you can run that through through the

00:13:53,920 --> 00:13:57,870
Engram filter so you're pulling out all

00:13:55,480 --> 00:13:59,860
the substrings of all the terms as well

00:13:57,870 --> 00:14:01,600
obviously then you also need to

00:13:59,860 --> 00:14:03,670
deduplicate it because otherwise you

00:14:01,600 --> 00:14:06,790
know subsequent terms may have they

00:14:03,670 --> 00:14:08,500
share lots of their substrings and you

00:14:06,790 --> 00:14:09,700
end up with a disjunction otherwise you

00:14:08,500 --> 00:14:13,560
end up with a dysfunction query that's

00:14:09,700 --> 00:14:13,560
actually got lots and lots of the same

00:14:13,740 --> 00:14:17,740
duplicate clauses in there so we run her

00:14:15,820 --> 00:14:21,220
we put a d-- duplicate deduplicating

00:14:17,740 --> 00:14:23,230
token filter on there and we also need

00:14:21,220 --> 00:14:27,310
to be careful about the the maximum

00:14:23,230 --> 00:14:28,870
length of terms we had so I had one

00:14:27,310 --> 00:14:30,700
particular document which was coming

00:14:28,870 --> 00:14:33,040
through and killing everything and just

00:14:30,700 --> 00:14:34,510
causing out of memory errors and slowing

00:14:33,040 --> 00:14:35,740
it all down I don't know work out what

00:14:34,510 --> 00:14:37,830
was happening it turned out it actually

00:14:35,740 --> 00:14:42,490
contained that base 64 encoded image

00:14:37,830 --> 00:14:44,140
which was you know 64 K of text with no

00:14:42,490 --> 00:14:45,610
spaces in it and it was going into the

00:14:44,140 --> 00:14:47,470
the Engram filter which was then

00:14:45,610 --> 00:14:51,640
dutifully creating all possible

00:14:47,470 --> 00:14:53,709
substrings of the 64 K long strings so

00:14:51,640 --> 00:14:54,550
yeah we you put a maximum on there the

00:14:53,709 --> 00:14:56,740
interesting thing about putting the

00:14:54,550 --> 00:14:58,060
maximum on of course is that what that

00:14:56,740 --> 00:14:59,589
maximum should be depends on what

00:14:58,060 --> 00:15:01,570
language you're using because something

00:14:59,589 --> 00:15:03,940
like English you can put it about 15

00:15:01,570 --> 00:15:05,350
terms and that's going to cover the vast

00:15:03,940 --> 00:15:07,390
majority if you're doing it German

00:15:05,350 --> 00:15:09,550
Germans like they're really really long

00:15:07,390 --> 00:15:12,040
words so you need to put it a bit bigger

00:15:09,550 --> 00:15:14,770
for different languages this was in fact

00:15:12,040 --> 00:15:16,120
for Danish which I don't speak at all so

00:15:14,770 --> 00:15:18,250
it's been quite interesting working with

00:15:16,120 --> 00:15:19,959
lots of Danish language stuff and people

00:15:18,250 --> 00:15:21,880
cut them up and saying this this clearly

00:15:19,959 --> 00:15:27,430
doesn't match I have to say doesn't it

00:15:21,880 --> 00:15:28,750
and I know you tell me and the other

00:15:27,430 --> 00:15:30,610
thing you can do is when you've got this

00:15:28,750 --> 00:15:33,790
you know obviously running a very a very

00:15:30,610 --> 00:15:36,520
large disjunction query over something

00:15:33,790 --> 00:15:37,540
over your query index if you have lots

00:15:36,520 --> 00:15:38,680
of terms in there that aren't going to

00:15:37,540 --> 00:15:40,900
match anything that's still a bit of a

00:15:38,680 --> 00:15:42,730
waste each one of these still has to you

00:15:40,900 --> 00:15:46,720
know it has to pull the terms in

00:15:42,730 --> 00:15:48,070
and create a scorer although lots of

00:15:46,720 --> 00:15:49,990
those scores will be null so in order to

00:15:48,070 --> 00:15:52,090
cut that down we can actually create a

00:15:49,990 --> 00:15:54,550
token filter that's based on the terms

00:15:52,090 --> 00:15:56,770
of name of the memory index and strip

00:15:54,550 --> 00:15:58,180
out anything that's any of the terms in

00:15:56,770 --> 00:16:00,070
the document generated by this that

00:15:58,180 --> 00:16:02,170
aren't I'm not going to match anything

00:16:00,070 --> 00:16:04,030
if they don't exist in them in the query

00:16:02,170 --> 00:16:05,200
index as well there's another way of you

00:16:04,030 --> 00:16:10,030
know just making everything slightly

00:16:05,200 --> 00:16:14,230
more efficient numbers this is the

00:16:10,030 --> 00:16:17,500
important bit so this is a benchmark I

00:16:14,230 --> 00:16:19,420
did a couple of weeks ago on a it's a

00:16:17,500 --> 00:16:20,530
representative corpus for a client that

00:16:19,420 --> 00:16:24,570
we're working with at the moment

00:16:20,530 --> 00:16:27,250
and they've got 22,000 queries and

00:16:24,570 --> 00:16:29,710
running it on this so you know this is

00:16:27,250 --> 00:16:32,740
not the hard work this is not server

00:16:29,710 --> 00:16:36,130
hardware this is just a MacBook it takes

00:16:32,740 --> 00:16:38,350
about five seconds to run 22 mm be ugly

00:16:36,130 --> 00:16:41,770
queries over an average document which

00:16:38,350 --> 00:16:43,870
is not bad but if we put the preacher on

00:16:41,770 --> 00:16:46,960
there exactly the same thing it'll do it

00:16:43,870 --> 00:16:49,960
in a quarter of a second so that's a 20

00:16:46,960 --> 00:16:51,340
times 30 times speed-up which if you

00:16:49,960 --> 00:16:52,840
have an SLA that says I need to do

00:16:51,340 --> 00:16:54,340
things in it approximately 1/4 of a

00:16:52,840 --> 00:16:56,530
second if you don't have the preacher on

00:16:54,340 --> 00:17:00,090
there then you need 20 times as many

00:16:56,530 --> 00:17:03,100
machines so this is a nice a nice saving

00:17:00,090 --> 00:17:04,300
and looking at what it's actually doing

00:17:03,100 --> 00:17:08,740
what the pre searcher is actually

00:17:04,300 --> 00:17:11,770
cutting out of those 22,000 queries it's

00:17:08,740 --> 00:17:13,750
running an average of 250

00:17:11,770 --> 00:17:18,880
they're still obviously there's a fixed

00:17:13,750 --> 00:17:22,320
cost to creating the disjunction query

00:17:18,880 --> 00:17:24,280
from a document that comes in so the

00:17:22,320 --> 00:17:26,590
without the pre search or with the match

00:17:24,280 --> 00:17:30,370
help researcher that says just get give

00:17:26,590 --> 00:17:32,290
me everything give me all the queries it

00:17:30,370 --> 00:17:34,150
it takes no time to build that to

00:17:32,290 --> 00:17:35,380
suction query it's not built in as its

00:17:34,150 --> 00:17:38,710
own query it's just running everything

00:17:35,380 --> 00:17:41,430
with the pre searcher it's taking of

00:17:38,710 --> 00:17:44,470
that point to five seconds

00:17:41,430 --> 00:17:46,090
about 50 millisecond 50 and 75

00:17:44,470 --> 00:17:47,620
milliseconds that is actually building

00:17:46,090 --> 00:17:51,970
the query so there's not it's not so

00:17:47,620 --> 00:17:54,460
completely free there are trade-offs

00:17:51,970 --> 00:17:55,900
there and again you need to judge that

00:17:54,460 --> 00:17:56,320
on you need to measure it you need to

00:17:55,900 --> 00:18:05,289
judge it

00:17:56,320 --> 00:18:09,669
your document set your query set getting

00:18:05,289 --> 00:18:10,899
matches out again is pluggable you have

00:18:09,669 --> 00:18:16,419
something called a candidate matter

00:18:10,899 --> 00:18:17,799
which is given so for each query that it

00:18:16,419 --> 00:18:19,990
matches it then passes it to the

00:18:17,799 --> 00:18:22,299
candidate matcher and you can then do

00:18:19,990 --> 00:18:23,769
you can run your own query and so that

00:18:22,299 --> 00:18:26,620
you can customize how exactly gonna run

00:18:23,769 --> 00:18:28,179
the query so it comes with your outcomes

00:18:26,620 --> 00:18:30,700
with a couple of standard ones we've got

00:18:28,179 --> 00:18:33,279
the simple matter which gives you a yes

00:18:30,700 --> 00:18:35,049
or a no answer did this match did this

00:18:33,279 --> 00:18:36,429
not match you've got a scoring match set

00:18:35,049 --> 00:18:40,090
which will go and do the calculate the

00:18:36,429 --> 00:18:42,960
score now this is this is useful in some

00:18:40,090 --> 00:18:45,549
cases just using the standards Lucine

00:18:42,960 --> 00:18:47,049
tf-idf scoring isn't actually going to

00:18:45,549 --> 00:18:50,289
help very much because you've got a

00:18:47,049 --> 00:18:57,309
single document there so IDF is always

00:18:50,289 --> 00:19:01,110
one so it can't depend you can create

00:18:57,309 --> 00:19:04,929
your own scoring which will generally be

00:19:01,110 --> 00:19:06,700
creating your own similarities and that

00:19:04,929 --> 00:19:07,899
will give you again you have to you have

00:19:06,700 --> 00:19:09,309
to be careful about how you look the

00:19:07,899 --> 00:19:13,240
about relying on scoring on what you're

00:19:09,309 --> 00:19:14,830
going to do with scoring but still it's

00:19:13,240 --> 00:19:19,690
there if you want to use it you can use

00:19:14,830 --> 00:19:22,240
it the the fun one is the interval

00:19:19,690 --> 00:19:24,070
matcher because this tells you the exact

00:19:22,240 --> 00:19:25,389
hit position of everything that matches

00:19:24,070 --> 00:19:27,730
and this is particularly useful for

00:19:25,389 --> 00:19:29,649
media monitoring particularly when you

00:19:27,730 --> 00:19:32,110
have you know if you have an absolutely

00:19:29,649 --> 00:19:33,820
gigantic query and it comes up with a

00:19:32,110 --> 00:19:36,370
hit against a document that's three

00:19:33,820 --> 00:19:37,360
sentences long it's very difficult to

00:19:36,370 --> 00:19:41,289
work out wait a particularly that

00:19:37,360 --> 00:19:44,500
document is wrong so in media monitoring

00:19:41,289 --> 00:19:46,509
this is normally a first pass you you

00:19:44,500 --> 00:19:48,220
run this you've got your document stream

00:19:46,509 --> 00:19:50,470
you run these queries against it now

00:19:48,220 --> 00:19:52,509
give you a set of things that it's found

00:19:50,470 --> 00:19:55,419
but it's normally then someone will

00:19:52,509 --> 00:19:56,620
actually go through and by hand check

00:19:55,419 --> 00:19:58,690
that all of these things make sense

00:19:56,620 --> 00:20:03,039
because you get false positives all the

00:19:58,690 --> 00:20:04,990
time and if you want to improve your

00:20:03,039 --> 00:20:06,220
reduce your false positive rate you want

00:20:04,990 --> 00:20:08,559
to improve your queries you want to

00:20:06,220 --> 00:20:10,690
refine your queries you need to know why

00:20:08,559 --> 00:20:13,149
something has matched

00:20:10,690 --> 00:20:14,049
and a standard highlighted that's kind

00:20:13,149 --> 00:20:15,039
of difficult because the standard

00:20:14,049 --> 00:20:18,549
highlights it doesn't tell you exactly

00:20:15,039 --> 00:20:21,700
what's matched it gives you a guess it

00:20:18,549 --> 00:20:23,799
kind of says this is what I think it

00:20:21,700 --> 00:20:27,399
might have matched but that's often not

00:20:23,799 --> 00:20:28,750
good enough so there is a branch there

00:20:27,399 --> 00:20:31,450
is a JIRA open on the scene called

00:20:28,750 --> 00:20:32,889
loosing two eight seven eight which was

00:20:31,450 --> 00:20:35,139
largely written by this guy down the

00:20:32,889 --> 00:20:37,000
front here Simon he did all the

00:20:35,139 --> 00:20:38,970
difficult stuff I did some boring stuff

00:20:37,000 --> 00:20:45,279
to make it fit in with everything else

00:20:38,970 --> 00:20:47,830
and it allows you to determine the exact

00:20:45,279 --> 00:20:51,610
exact positions of everything that has

00:20:47,830 --> 00:20:54,250
hit from from a leucine query it also

00:20:51,610 --> 00:20:56,799
uses something called minimum interval

00:20:54,250 --> 00:20:59,649
semantics to efficiently run proximity

00:20:56,799 --> 00:21:01,929
queries so the first iteration of this

00:20:59,649 --> 00:21:05,730
we were using span queries and spang

00:21:01,929 --> 00:21:08,649
queries work but they're kind of massive

00:21:05,730 --> 00:21:12,519
they take up enormous amounts of memory

00:21:08,649 --> 00:21:14,679
and they're quite slow whereas the

00:21:12,519 --> 00:21:16,799
minimum interval query ones used much

00:21:14,679 --> 00:21:20,950
less Ram and they're much quicker I

00:21:16,799 --> 00:21:22,809
don't have actual numbers in this slide

00:21:20,950 --> 00:21:24,039
deck about that but it's yeah on the

00:21:22,809 --> 00:21:26,110
order of four time four or five times

00:21:24,039 --> 00:21:28,840
faster and about half as much memory

00:21:26,110 --> 00:21:31,779
taken up with these particular documents

00:21:28,840 --> 00:21:34,210
in these particular queries and so yeah

00:21:31,779 --> 00:21:36,100
we have the intervals match which runs

00:21:34,210 --> 00:21:37,269
out this is this runs using a fork of

00:21:36,100 --> 00:21:40,600
leucine that I'm maintaining at the

00:21:37,269 --> 00:21:43,149
moment it will will get merged into

00:21:40,600 --> 00:21:46,200
trunk at some point really I've been

00:21:43,149 --> 00:21:47,350
saying it's from it's gonna happen

00:21:46,200 --> 00:21:51,639
tonight

00:21:47,350 --> 00:21:53,350
all right so but for the moment this is

00:21:51,639 --> 00:21:54,759
right so if you're using Luwak there are

00:21:53,350 --> 00:21:57,039
two versions of the work out there one

00:21:54,759 --> 00:21:58,059
of which runs off the of this fork that

00:21:57,039 --> 00:22:00,669
I'm maintaining which gives you the

00:21:58,059 --> 00:22:03,070
intervals match and another one which

00:22:00,669 --> 00:22:05,379
just runs off straight leucine for eight

00:22:03,070 --> 00:22:06,730
and doesn't have any intervals matching

00:22:05,379 --> 00:22:08,490
goodness but it also it does have a

00:22:06,730 --> 00:22:10,960
simple match from the scoring matcher

00:22:08,490 --> 00:22:12,370
and at some point I'll probably try and

00:22:10,960 --> 00:22:14,019
do a highlighting back sure in there as

00:22:12,370 --> 00:22:15,309
well so you'll run a highlighter over it

00:22:14,019 --> 00:22:17,440
and you can use the usual leucine

00:22:15,309 --> 00:22:18,700
highlighters in there and the other

00:22:17,440 --> 00:22:20,080
thing the intervals match therefore is

00:22:18,700 --> 00:22:22,160
useful for is actually if you're writing

00:22:20,080 --> 00:22:23,960
your own presets or implementation

00:22:22,160 --> 00:22:27,020
it's useful for debugging it because it

00:22:23,960 --> 00:22:31,160
will cut it can tell you which terms in

00:22:27,020 --> 00:22:33,230
a query have matched from from the so

00:22:31,160 --> 00:22:34,790
it'll tell you what what terms in the

00:22:33,230 --> 00:22:36,470
query made the pre search to select that

00:22:34,790 --> 00:22:38,600
particular query to run which is very

00:22:36,470 --> 00:22:40,810
useful when your so for things like the

00:22:38,600 --> 00:22:42,680
the wildcards when I was writing the

00:22:40,810 --> 00:22:44,240
various well collide implementation I

00:22:42,680 --> 00:22:48,560
was getting lots of spurious matches and

00:22:44,240 --> 00:22:50,090
it turns out that basically I tend that

00:22:48,560 --> 00:22:51,890
I'd done it horribly wrong

00:22:50,090 --> 00:22:53,030
and it wasn't obvious to me how I done

00:22:51,890 --> 00:22:54,830
it horribly wrong until you go and see

00:22:53,030 --> 00:22:56,870
which things it's actually matching on

00:22:54,830 --> 00:22:58,460
and say okay that that term is clearly

00:22:56,870 --> 00:23:03,200
wrong I can work out why it is that it's

00:22:58,460 --> 00:23:06,650
matching on that term so I said Luke is

00:23:03,200 --> 00:23:10,610
all pluggable it's all extendable you

00:23:06,650 --> 00:23:13,400
can create your own query extractors so

00:23:10,610 --> 00:23:14,570
at the moment it will fall back to if it

00:23:13,400 --> 00:23:15,860
encounters the query that it doesn't

00:23:14,570 --> 00:23:17,270
know how to get terms from it'll fall

00:23:15,860 --> 00:23:19,940
back to running just extract terms on

00:23:17,270 --> 00:23:22,150
the query bath and that doesn't make

00:23:19,940 --> 00:23:26,810
sense so for things like range queries

00:23:22,150 --> 00:23:29,450
there we have the Ameritrade queries in

00:23:26,810 --> 00:23:31,850
a lot of the the queries that I'm

00:23:29,450 --> 00:23:34,130
dealing with but they tend to be added

00:23:31,850 --> 00:23:36,050
on those filters so I can get away with

00:23:34,130 --> 00:23:37,670
not trying to work out how to index them

00:23:36,050 --> 00:23:39,290
I can just index them with an any token

00:23:37,670 --> 00:23:42,980
and then the term weights will throw

00:23:39,290 --> 00:23:44,930
that out this won't actually happen in

00:23:42,980 --> 00:23:46,550
all cases sometimes you really do need

00:23:44,930 --> 00:23:48,170
to work out how to index a new range

00:23:46,550 --> 00:23:50,480
filter when I talked about this in

00:23:48,170 --> 00:23:52,130
Dublin last November and someone came up

00:23:50,480 --> 00:23:54,770
with a really kind of cunning idea of

00:23:52,130 --> 00:23:56,240
how to do this unfortunately I was on

00:23:54,770 --> 00:23:57,320
loads of painkillers at the time and I

00:23:56,240 --> 00:23:59,720
couldn't I had near an inner ear

00:23:57,320 --> 00:24:01,640
infection I couldn't hear anything so if

00:23:59,720 --> 00:24:02,720
that would anybody hear or if anyone

00:24:01,640 --> 00:24:03,950
comes up with a good idea please come

00:24:02,720 --> 00:24:07,670
and tell me afterwards and write it down

00:24:03,950 --> 00:24:09,020
so I don't forget at this time but yeah

00:24:07,670 --> 00:24:10,550
if you sometimes you want to create your

00:24:09,020 --> 00:24:12,080
own custom queries then you can create

00:24:10,550 --> 00:24:13,520
your own custom query extractor as well

00:24:12,080 --> 00:24:16,460
and say ok this is how I want to index

00:24:13,520 --> 00:24:17,930
this query you can actually say I'm

00:24:16,460 --> 00:24:19,700
gonna create a completely different pre

00:24:17,930 --> 00:24:20,780
search or implementation I think your

00:24:19,700 --> 00:24:21,500
way of doing it is rubbish I've got a

00:24:20,780 --> 00:24:23,630
much better idea

00:24:21,500 --> 00:24:26,150
and it's preset so it's just it's two

00:24:23,630 --> 00:24:27,380
two methods its index query and build

00:24:26,150 --> 00:24:29,150
content index query for when you've got

00:24:27,380 --> 00:24:30,080
a query coming in and build query from

00:24:29,150 --> 00:24:32,150
when you're building a query from a

00:24:30,080 --> 00:24:33,380
document you have your own idea of doing

00:24:32,150 --> 00:24:35,359
that then you can just plug it in and

00:24:33,380 --> 00:24:38,690
everything else will work around it

00:24:35,359 --> 00:24:40,419
you can create your own matches there's

00:24:38,690 --> 00:24:42,529
a so the standard the candidate match

00:24:40,419 --> 00:24:44,210
again you just have to override a

00:24:42,529 --> 00:24:48,919
particular method which says here's a

00:24:44,210 --> 00:24:50,690
query here's a highlight query use these

00:24:48,919 --> 00:24:52,159
to do whatever you want whether using

00:24:50,690 --> 00:24:53,960
getting in any whatever information you

00:24:52,159 --> 00:24:56,749
want out pull requests are always

00:24:53,960 --> 00:24:58,369
welcome particularly if it's something

00:24:56,749 --> 00:25:00,350
complicated that I don't understand then

00:24:58,369 --> 00:25:02,419
you write it and give it to me and I'll

00:25:00,350 --> 00:25:03,859
pull it into my library that's that's

00:25:02,419 --> 00:25:06,559
how open-source works

00:25:03,859 --> 00:25:12,980
yeah and that's and there's the github

00:25:06,559 --> 00:25:14,539
repository there and yeah I think I've

00:25:12,980 --> 00:25:15,799
got loads of time for questions because

00:25:14,539 --> 00:25:17,419
I kind of run through that a little

00:25:15,799 --> 00:25:19,460
faster than I was expecting

00:25:17,419 --> 00:25:20,989
there's that's me as well you can

00:25:19,460 --> 00:25:23,570
contact me Ellen at flax or I'm on

00:25:20,989 --> 00:25:25,869
Twitter at Romsey anybody have any

00:25:23,570 --> 00:25:25,869
questions

00:25:32,280 --> 00:25:38,070
thanks for the talk if you have any

00:25:34,390 --> 00:25:54,070
questions please wait for the microphone

00:25:38,070 --> 00:25:56,830
and thank you for a talk one question I

00:25:54,070 --> 00:25:59,170
can't in not queries and if yes how are

00:25:56,830 --> 00:26:01,600
you doing this so if it not queer it so

00:25:59,170 --> 00:26:05,740
not queries in a billion basically we

00:26:01,600 --> 00:26:07,780
just ignore them because if you think

00:26:05,740 --> 00:26:11,650
about it a knock Clause is saying if

00:26:07,780 --> 00:26:13,450
this is present then don't match it in

00:26:11,650 --> 00:26:14,860
which case you know if so if it's

00:26:13,450 --> 00:26:16,990
present in the document that's coming in

00:26:14,860 --> 00:26:18,880
you don't want to match it so you don't

00:26:16,990 --> 00:26:26,440
want it to hit on that on the the query

00:26:18,880 --> 00:26:28,059
index so you can just ignore them only I

00:26:26,440 --> 00:26:31,870
want all the chemistry she does not

00:26:28,059 --> 00:26:35,920
contain some some time probably three

00:26:31,870 --> 00:26:38,920
case okay yeah but generally you'll have

00:26:35,920 --> 00:26:40,179
a so yeah in which case it'll end up

00:26:38,920 --> 00:26:41,980
being run against every single doctor

00:26:40,179 --> 00:26:43,330
but then you you kind of have to run

00:26:41,980 --> 00:26:44,860
that against every single document

00:26:43,330 --> 00:26:46,450
because every single document could

00:26:44,860 --> 00:26:48,610
conceivably match that there's not an

00:26:46,450 --> 00:26:50,559
easy way of cutting down the query space

00:26:48,610 --> 00:26:52,090
for that it's the quite often you'll

00:26:50,559 --> 00:26:54,420
find said things like wildcards

00:26:52,090 --> 00:26:57,160
someone's got a stand a asterisk or

00:26:54,420 --> 00:26:58,360
previous query of a you think well okay

00:26:57,160 --> 00:27:00,280
that's going to blow up and that's you

00:26:58,360 --> 00:27:02,410
know if you're storing a in your terms

00:27:00,280 --> 00:27:03,580
index then in your query indexed every

00:27:02,410 --> 00:27:06,309
simple documents going to match that

00:27:03,580 --> 00:27:07,600
which is true but every single document

00:27:06,309 --> 00:27:09,760
is probably actually going to get hit on

00:27:07,600 --> 00:27:11,920
that query as well so you do get

00:27:09,760 --> 00:27:13,690
pathological queries which are going to

00:27:11,920 --> 00:27:15,850
slow everything down unfortunately

00:27:13,690 --> 00:27:17,140
that's the nature of the situation and

00:27:15,850 --> 00:27:18,820
you know yet if you have a pathological

00:27:17,140 --> 00:27:20,290
query then there's not much you can do

00:27:18,820 --> 00:27:22,650
about it you do have to run that against

00:27:20,290 --> 00:27:22,650
everything

00:27:29,340 --> 00:27:37,119
um the question is more about scaling

00:27:33,159 --> 00:27:40,090
out if you have a huge stream of data a

00:27:37,119 --> 00:27:42,190
large large throughput you may need to

00:27:40,090 --> 00:27:44,710
share that out and break that stream and

00:27:42,190 --> 00:27:47,859
send it to multiple servers do it does

00:27:44,710 --> 00:27:50,289
have any capability for managing queries

00:27:47,859 --> 00:27:52,149
across a number of instances so yeah

00:27:50,289 --> 00:27:54,190
that that's the big question is how to

00:27:52,149 --> 00:27:56,529
shut out the queries at the moment so

00:27:54,190 --> 00:28:01,080
the bank itself is just a library it's

00:27:56,529 --> 00:28:03,879
not a full set full scale solution and

00:28:01,080 --> 00:28:06,789
so we built that the way I know we do is

00:28:03,879 --> 00:28:09,489
I build web services using drop wizard -

00:28:06,789 --> 00:28:14,499
which includes live like everyone could

00:28:09,489 --> 00:28:17,619
be some drop wizard love and yes so so

00:28:14,499 --> 00:28:20,019
far all the the crew sets we've dealt

00:28:17,619 --> 00:28:23,169
with have been sufficiently small that

00:28:20,019 --> 00:28:25,330
they will fit into RAM on a server but

00:28:23,169 --> 00:28:26,559
yeah I can see how yeah in certain cases

00:28:25,330 --> 00:28:30,369
you would want to say okay let's split

00:28:26,559 --> 00:28:31,779
this out the simple ways to say okay

00:28:30,369 --> 00:28:34,210
we'll just partition it bang down the

00:28:31,779 --> 00:28:37,239
middle and have these two you know you

00:28:34,210 --> 00:28:39,820
do something use a message queue or

00:28:37,239 --> 00:28:41,350
something like that to split your

00:28:39,820 --> 00:28:44,649
document screen into two and then

00:28:41,350 --> 00:28:47,320
recombine it at the end yeah Louet

00:28:44,649 --> 00:28:49,119
doesn't do that out of the box did if

00:28:47,320 --> 00:28:50,259
you want to do that then you can pay me

00:28:49,119 --> 00:29:02,710
to build something for you that will do

00:28:50,259 --> 00:29:05,529
that or somebody else but yeah I would

00:29:02,710 --> 00:29:08,919
do deal with geolocation queries how I

00:29:05,529 --> 00:29:10,720
deal with geolocation queries like so

00:29:08,919 --> 00:29:13,359
yeah so geolocation queries are kind of

00:29:10,720 --> 00:29:15,549
like that it's a generalization of

00:29:13,359 --> 00:29:20,200
numeric range query of any kind of range

00:29:15,549 --> 00:29:24,249
query and yeah at the moment we tended

00:29:20,200 --> 00:29:25,690
to ignore that primarily because these

00:29:24,249 --> 00:29:26,980
things normally you're not saying give

00:29:25,690 --> 00:29:28,929
me everything that's within this

00:29:26,980 --> 00:29:30,159
bounding box you're saying give me

00:29:28,929 --> 00:29:32,919
everything within this bounding box that

00:29:30,159 --> 00:29:34,149
also matches X so we can kind you can

00:29:32,919 --> 00:29:34,929
kind of say ignore it okay okay we'll

00:29:34,149 --> 00:29:36,519
get you over give everything that

00:29:34,929 --> 00:29:39,190
matches X and then you have to go and

00:29:36,519 --> 00:29:41,810
run run all those all those queries

00:29:39,190 --> 00:29:44,160
against it but

00:29:41,810 --> 00:29:46,020
with with the query sense that we've

00:29:44,160 --> 00:29:47,670
been dealing with and I don't think

00:29:46,020 --> 00:29:52,320
we've had to deal with anything that has

00:29:47,670 --> 00:29:53,820
a do geo-tagging and yet I've got

00:29:52,320 --> 00:29:56,400
someone's talking about it at the moment

00:29:53,820 --> 00:29:58,320
and yet that will probably involve us

00:29:56,400 --> 00:30:01,550
having to work out how to do the the

00:29:58,320 --> 00:30:04,140
reverse indexing of range queries I

00:30:01,550 --> 00:30:05,760
think the idea one possibility is to try

00:30:04,140 --> 00:30:07,200
and partition the range up and say okay

00:30:05,760 --> 00:30:09,840
well we can divide that range up into

00:30:07,200 --> 00:30:13,200
buckets and index terms from these

00:30:09,840 --> 00:30:15,420
buckets with different levels of

00:30:13,200 --> 00:30:19,080
granularity and then when the document

00:30:15,420 --> 00:30:22,520
comes in you you should have something

00:30:19,080 --> 00:30:26,400
that will match one of those buckets but

00:30:22,520 --> 00:30:29,390
which might work but it might not so

00:30:26,400 --> 00:30:32,520
obviously we need to need to test that

00:30:29,390 --> 00:30:34,020
and you know in most cases you can get

00:30:32,520 --> 00:30:35,130
away with just not indexing that but you

00:30:34,020 --> 00:30:37,290
might find yeah if you run a benchmark

00:30:35,130 --> 00:30:38,880
and find found that actually you're

00:30:37,290 --> 00:30:40,440
getting lots and lots of false hits

00:30:38,880 --> 00:30:42,270
because of that then yeah then it's

00:30:40,440 --> 00:30:44,460
worth putting the the time in to try and

00:30:42,270 --> 00:30:54,060
work out how to reverse in to do the

00:30:44,460 --> 00:31:00,480
reversing index of that anybody else got

00:30:54,060 --> 00:31:02,250
Seekers delight no more no okay Ellen

00:31:00,480 --> 00:31:05,210
thank you very thank you for your talk

00:31:02,250 --> 00:31:05,210
this

00:31:07,850 --> 00:31:09,910

YouTube URL: https://www.youtube.com/watch?v=M3c5_7DxpIk


