Title: Berli Buzzwords 2014: Britta Weber - Scoring for Human Beings #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	When you are running ElasticSearch for for free text search, you probably use Lucenes tf-idf scoring formula to determine the relevancy of a document. This is usually great because this formula is one-size-fits-most for free text queries. But what if you are not one of the most? And when are you not one of them?

In this talk I will explain the basics of determining relevancy of a document and how scores can be customized when using ElasticSearch.

I will start off by recapitulating the vector space model for scoring and how tf-idf works in detail - for human beings. This explanation will be accompanied with practical examples of pitfalls you might encounter when the scored text actually represents tags. I will then give an overview over the options in ElasticSearch to tweak scores arbitrarily by making use of numerical document values but also by using text features stored in the Lucene index. Finally I will show examples of how you can implement your own flavor of scoring functions like tf-idf, language model and cosine similarity without touching a single line of java code.

Read more:
https://2014.berlinbuzzwords.de/session/scoring-human-beings

About Britta Weber: 
https://2014.berlinbuzzwords.de/user/305/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,560 --> 00:00:12,400
all right no I'm pritam i work at

00:00:09,219 --> 00:00:15,160
elasticsearch and so I joined

00:00:12,400 --> 00:00:17,740
elasticsearch a year ago so there was

00:00:15,160 --> 00:00:19,539
the first of may but I come from a very

00:00:17,740 --> 00:00:22,720
different background so I came from

00:00:19,539 --> 00:00:25,269
academia and i was working mainly on

00:00:22,720 --> 00:00:28,960
image processing so before i came to

00:00:25,269 --> 00:00:30,669
elasticsearch um i did not actually knew

00:00:28,960 --> 00:00:32,980
what was going on in information

00:00:30,669 --> 00:00:35,200
retrieval right so i came to buzz words

00:00:32,980 --> 00:00:37,630
last year i was only at elastic search

00:00:35,200 --> 00:00:40,750
for one month i was talking to a guy and

00:00:37,630 --> 00:00:43,960
he said oh wow you work for that search

00:00:40,750 --> 00:00:45,970
cool so tell me something when i put in

00:00:43,960 --> 00:00:47,860
google when I put the quotes it gives me

00:00:45,970 --> 00:00:51,190
phrases how does that work with the

00:00:47,860 --> 00:00:56,170
inverted index right that was very

00:00:51,190 --> 00:00:58,210
embarrassing I didn't know I colleague

00:00:56,170 --> 00:01:01,510
saved me right so i went home and shame

00:00:58,210 --> 00:01:02,800
i thought what to do with myself and I

00:01:01,510 --> 00:01:04,269
thought hey I came from academia I'm

00:01:02,800 --> 00:01:07,210
good at reading books right so I read

00:01:04,269 --> 00:01:08,740
this book this is the book if you

00:01:07,210 --> 00:01:10,329
haven't read it and you don't know what

00:01:08,740 --> 00:01:11,590
information retrieval and scoring and

00:01:10,329 --> 00:01:13,600
all the things i'll be talking about is

00:01:11,590 --> 00:01:17,320
about this is a really good starting

00:01:13,600 --> 00:01:19,990
place and there was two or three

00:01:17,320 --> 00:01:23,170
chapters about scoring that were

00:01:19,990 --> 00:01:26,229
particularly interesting for me so what

00:01:23,170 --> 00:01:28,359
I mean by scoring is determine the

00:01:26,229 --> 00:01:30,429
relevance of a document given some

00:01:28,359 --> 00:01:33,249
search request for example given the

00:01:30,429 --> 00:01:35,920
keywords football World Cup what is the

00:01:33,249 --> 00:01:38,079
most relevant news article a user might

00:01:35,920 --> 00:01:41,079
want to read and note that this might

00:01:38,079 --> 00:01:43,030
not just be related to the search things

00:01:41,079 --> 00:01:45,189
the user types in but it might also be

00:01:43,030 --> 00:01:47,170
related to time right might be some you

00:01:45,189 --> 00:01:49,869
want to have a news and not the old so

00:01:47,170 --> 00:01:52,840
are given the criteria someone else job

00:01:49,869 --> 00:01:54,459
or has some expected income or release

00:01:52,840 --> 00:01:55,810
at some place would that be a good

00:01:54,459 --> 00:01:58,600
candidate for the job that I'm currently

00:01:55,810 --> 00:02:02,159
offering right so this is what i mean by

00:01:58,600 --> 00:02:04,420
scoring so anyway i read this book and

00:02:02,159 --> 00:02:06,009
then I thought okay now I know how

00:02:04,420 --> 00:02:10,149
scoring works right at least in theory

00:02:06,009 --> 00:02:11,620
but then I figured well if I'm to be a

00:02:10,149 --> 00:02:13,540
program and maybe I should also figure

00:02:11,620 --> 00:02:16,290
out how this works implementation wise

00:02:13,540 --> 00:02:19,500
how is it actually implemented

00:02:16,290 --> 00:02:20,609
um so so you have to understand if you

00:02:19,500 --> 00:02:22,170
only would actually want to know how

00:02:20,609 --> 00:02:23,010
scoring and elastic search works you

00:02:22,170 --> 00:02:25,109
have to know a little bit about

00:02:23,010 --> 00:02:27,750
elasticsearch and then particularly have

00:02:25,109 --> 00:02:29,879
to know the leucine code base to see

00:02:27,750 --> 00:02:33,569
where things are actually happening and

00:02:29,879 --> 00:02:36,000
I didn't know how to put my experience

00:02:33,569 --> 00:02:40,260
in words so I drew a little comic right

00:02:36,000 --> 00:02:42,450
so so this is me right this is the score

00:02:40,260 --> 00:02:45,599
and I know it comes out here

00:02:42,450 --> 00:02:55,379
miraculously right where does it happen

00:02:45,599 --> 00:02:59,909
oh there was a bummer alright so an AAA

00:02:55,379 --> 00:03:01,590
held on hold on no neither side so i

00:02:59,909 --> 00:03:03,930
will be online later so you can look at

00:03:01,590 --> 00:03:05,700
them intense so so anyway so this brings

00:03:03,930 --> 00:03:09,120
me to the purpose of the talk what's the

00:03:05,700 --> 00:03:11,700
purpose of my talk so our first of all i

00:03:09,120 --> 00:03:13,019
want to relieve you of the burden to

00:03:11,700 --> 00:03:15,389
find the point where to get started

00:03:13,019 --> 00:03:17,280
right after this experience I have the

00:03:15,389 --> 00:03:19,439
feeling it should be much easier to do

00:03:17,280 --> 00:03:20,940
it much easier to understand so this is

00:03:19,439 --> 00:03:22,979
what this talk is going to be about and

00:03:20,940 --> 00:03:25,019
it has basically two parts so the first

00:03:22,979 --> 00:03:26,819
is I will give a short introduction into

00:03:25,019 --> 00:03:29,479
the theory that is into the vector space

00:03:26,819 --> 00:03:31,290
model and this is the most common way

00:03:29,479 --> 00:03:32,669
documents are scored right now

00:03:31,290 --> 00:03:35,609
everywhere and especially if you use

00:03:32,669 --> 00:03:37,229
elastic search and then I will talk

00:03:35,609 --> 00:03:38,940
about how you can tweak scores with

00:03:37,229 --> 00:03:40,799
elastic search so what we have already

00:03:38,940 --> 00:03:45,000
and how also how you can implement new

00:03:40,799 --> 00:03:48,479
things right so at first a little bit of

00:03:45,000 --> 00:03:51,540
theory so tf-idf who have you heard of

00:03:48,479 --> 00:03:56,220
it Oh y'all know everything already

00:03:51,540 --> 00:03:58,169
right okay so okay tf-idf is the most

00:03:56,220 --> 00:04:00,299
common ways to score documents ever if

00:03:58,169 --> 00:04:01,829
you use elastic search and you do not

00:04:00,299 --> 00:04:03,629
define anything you didn't give anything

00:04:01,829 --> 00:04:06,540
then everything you get will be scored

00:04:03,629 --> 00:04:09,959
by TF IDF and that is text will be

00:04:06,540 --> 00:04:13,139
scored but tf-idf so how does it work so

00:04:09,959 --> 00:04:16,099
say you have some query and it would be

00:04:13,139 --> 00:04:18,509
in this case would be proud oops sorry

00:04:16,099 --> 00:04:19,949
brown and fox is the queries or

00:04:18,509 --> 00:04:21,840
somebody's looking for brown fox may be

00:04:19,949 --> 00:04:23,580
right and then you have two documents

00:04:21,840 --> 00:04:26,250
one is the quick brown fox likes brown

00:04:23,580 --> 00:04:28,409
eyes and the other is the red fox so the

00:04:26,250 --> 00:04:30,040
first thing you do is you count how

00:04:28,409 --> 00:04:32,350
often the query terms actually appear

00:04:30,040 --> 00:04:33,580
you're in the document right so in for

00:04:32,350 --> 00:04:36,430
document one this would be for example

00:04:33,580 --> 00:04:38,830
okay Brown appears twice fox appears

00:04:36,430 --> 00:04:42,550
once and for document one Fox appears

00:04:38,830 --> 00:04:44,410
once and rounder p0 times so one thing

00:04:42,550 --> 00:04:46,000
you should note here is that this does

00:04:44,410 --> 00:04:47,710
not respect any ordering of the terms

00:04:46,000 --> 00:04:48,880
right and this is also called as why

00:04:47,710 --> 00:04:50,980
it's sometimes called the bag of words

00:04:48,880 --> 00:04:52,660
model because there's no ordering left

00:04:50,980 --> 00:04:55,180
you just put it in your bag and then

00:04:52,660 --> 00:04:58,390
that's it so now the question is how do

00:04:55,180 --> 00:05:00,700
we put this into a score how do we give

00:04:58,390 --> 00:05:02,650
this a numeric value how do we actually

00:05:00,700 --> 00:05:04,000
say okay and this is the new ordering

00:05:02,650 --> 00:05:08,890
right you can just count these things

00:05:04,000 --> 00:05:11,020
but that would be pretty naive so I give

00:05:08,890 --> 00:05:13,240
you a hint already so you actually look

00:05:11,020 --> 00:05:14,680
at these things as a vector right and

00:05:13,240 --> 00:05:15,730
this is where the vector space model

00:05:14,680 --> 00:05:17,260
calm and this is really just like at

00:05:15,730 --> 00:05:19,480
school when you had factors and you let

00:05:17,260 --> 00:05:21,580
your x-axis and y-axis and then to draw

00:05:19,480 --> 00:05:23,590
your vector and that's it so you

00:05:21,580 --> 00:05:27,700
actually turn your documents and your

00:05:23,590 --> 00:05:29,800
query into a vector ok and then how does

00:05:27,700 --> 00:05:31,450
that look like so here's how this would

00:05:29,800 --> 00:05:33,670
look like so you would have instead of

00:05:31,450 --> 00:05:35,830
your x-axis you would have your fox axis

00:05:33,670 --> 00:05:39,300
and the y axis would become the brown

00:05:35,830 --> 00:05:42,910
axis and documents and query are both

00:05:39,300 --> 00:05:44,620
points in this vector space so here for

00:05:42,910 --> 00:05:47,920
example you would have document one that

00:05:44,620 --> 00:05:49,510
would be 10 at coordinate 10 and you

00:05:47,920 --> 00:05:51,310
would have document oh sorry document

00:05:49,510 --> 00:05:54,000
you as a human one would be a car at

00:05:51,310 --> 00:05:56,230
coordinate 12 and the query would be at

00:05:54,000 --> 00:05:58,180
coordinate 11 and then what you really

00:05:56,230 --> 00:06:00,750
want to figure out is what is the

00:05:58,180 --> 00:06:02,530
distance between these vectors right in

00:06:00,750 --> 00:06:04,630
distance I mean you could only just

00:06:02,530 --> 00:06:05,860
measure the distance of the tips but

00:06:04,630 --> 00:06:11,380
that doesn't make a whole lot of sense

00:06:05,860 --> 00:06:12,910
as you can imagine so the first thing

00:06:11,380 --> 00:06:15,970
people usually talk about when they talk

00:06:12,910 --> 00:06:18,790
about scoring is they talk about cosine

00:06:15,970 --> 00:06:21,180
similarity so this is a popular thing in

00:06:18,790 --> 00:06:24,520
theory not so much in practice I think

00:06:21,180 --> 00:06:26,260
and the way you look at this is you say

00:06:24,520 --> 00:06:27,880
okay if your query and you have your

00:06:26,260 --> 00:06:31,300
documents as a vector but you look at

00:06:27,880 --> 00:06:32,770
the angle between these two and then you

00:06:31,300 --> 00:06:34,660
don't actually take the angle as the

00:06:32,770 --> 00:06:36,430
score but to take the cosine and why the

00:06:34,660 --> 00:06:38,680
cosine well because the cosine starts at

00:06:36,430 --> 00:06:41,050
one and then decreases to zero as it

00:06:38,680 --> 00:06:42,729
approaches 90 degree so documents about

00:06:41,050 --> 00:06:46,539
be perpendicular to

00:06:42,729 --> 00:06:48,879
the query in this vector space ah well

00:06:46,539 --> 00:06:52,509
we'll just be score of zero and then get

00:06:48,879 --> 00:06:54,400
negative right so one thing I didn't

00:06:52,509 --> 00:06:57,819
mention before I just just realized this

00:06:54,400 --> 00:06:59,080
are if you would have a third term right

00:06:57,819 --> 00:07:01,599
and talking about vector spaces if you

00:06:59,080 --> 00:07:02,770
would have a third term the third axis

00:07:01,599 --> 00:07:05,259
would actually come out of the plane

00:07:02,770 --> 00:07:07,300
right and then if we would have a fourth

00:07:05,259 --> 00:07:09,189
term about of a four-dimensional space

00:07:07,300 --> 00:07:11,889
but I'm not sure how to put this one

00:07:09,189 --> 00:07:16,240
right answer wait ok this is cosine

00:07:11,889 --> 00:07:17,830
similarity it's not really well it might

00:07:16,240 --> 00:07:20,259
be useful for some cases right but if

00:07:17,830 --> 00:07:21,759
you have longer tags a really natural

00:07:20,259 --> 00:07:23,729
language text this does not really work

00:07:21,759 --> 00:07:25,719
out so there's a better way to do this

00:07:23,729 --> 00:07:28,089
another distance measure that you could

00:07:25,719 --> 00:07:30,129
think of is you could actually instead

00:07:28,089 --> 00:07:32,860
of they're doing this angular instead of

00:07:30,129 --> 00:07:35,499
just looking at the tips project this

00:07:32,860 --> 00:07:37,539
vector onto the axis that is spanned by

00:07:35,499 --> 00:07:40,059
the query and this is actually what

00:07:37,539 --> 00:07:42,219
tf-idf does so you have your query

00:07:40,059 --> 00:07:44,680
expense this axis here you project both

00:07:42,219 --> 00:07:46,779
documents perpendicular answer this axis

00:07:44,680 --> 00:07:48,909
and the score is actually the distance

00:07:46,779 --> 00:07:50,499
from the origin so document to would

00:07:48,909 --> 00:07:52,209
score a much lower than document one

00:07:50,499 --> 00:07:55,060
because the projections just farther

00:07:52,209 --> 00:07:58,389
away from the origin right and this is

00:07:55,060 --> 00:08:05,979
what tf-idf does and that's it no not

00:07:58,389 --> 00:08:07,149
really since no it goes on so so there's

00:08:05,979 --> 00:08:09,459
two things that are very important when

00:08:07,149 --> 00:08:11,050
you want to understand will seen scoring

00:08:09,459 --> 00:08:12,789
so the first is shorter text is more

00:08:11,050 --> 00:08:15,159
relevant than longer text now this is

00:08:12,789 --> 00:08:17,259
not completely true but the idea is this

00:08:15,159 --> 00:08:19,149
say for example you have if you're

00:08:17,259 --> 00:08:21,249
looking for I don't know holiday in

00:08:19,149 --> 00:08:23,669
china or something like that and your

00:08:21,249 --> 00:08:25,809
document basis actually contains tweets

00:08:23,669 --> 00:08:27,699
where somebody tweets about the holiday

00:08:25,809 --> 00:08:29,559
in china but it also contains articles

00:08:27,699 --> 00:08:30,939
and it also contains books may be right

00:08:29,559 --> 00:08:32,740
when somebody talks in the beginning

00:08:30,939 --> 00:08:34,389
that he's going to holiday and then the

00:08:32,740 --> 00:08:36,519
end he's going to a Chinese restaurant

00:08:34,389 --> 00:08:38,289
that he feels like in China well this

00:08:36,519 --> 00:08:40,539
wouldn't be too relevant for the Crimea

00:08:38,289 --> 00:08:42,459
right so what leucine does internally is

00:08:40,539 --> 00:08:45,990
actually taking this into account and

00:08:42,459 --> 00:08:49,300
making sure that longer documents are

00:08:45,990 --> 00:08:50,800
awaited lower depending on how the term

00:08:49,300 --> 00:08:53,319
frequency is in short the documents are

00:08:50,800 --> 00:08:56,040
sort of weighted higher okay Hannah how

00:08:53,319 --> 00:08:58,870
this actually looks is this

00:08:56,040 --> 00:09:01,029
so say you have your document here this

00:08:58,870 --> 00:09:03,310
is the original document vector and now

00:09:01,029 --> 00:09:05,230
it turns out that this document is very

00:09:03,310 --> 00:09:07,420
long than what you would do is you would

00:09:05,230 --> 00:09:09,279
shorten this vector depending on how

00:09:07,420 --> 00:09:11,019
long it is and now you can imagine if

00:09:09,279 --> 00:09:13,779
the term appears very often then this

00:09:11,019 --> 00:09:15,040
would be up here somewhere so if your

00:09:13,779 --> 00:09:18,009
shorten it would still be somewhere here

00:09:15,040 --> 00:09:19,360
right so it's just a trade of sort of so

00:09:18,009 --> 00:09:20,740
you shorten this vector is it's longer

00:09:19,360 --> 00:09:22,420
your length is it a little bit if it's

00:09:20,740 --> 00:09:25,690
shorter and then depending on that the

00:09:22,420 --> 00:09:27,100
score gets of course higher or lower now

00:09:25,690 --> 00:09:29,050
this is something that is independent of

00:09:27,100 --> 00:09:30,639
the term but there is another very

00:09:29,050 --> 00:09:33,069
important property that is dependent on

00:09:30,639 --> 00:09:37,779
the term and that is called the document

00:09:33,069 --> 00:09:40,360
frequency right and so so the idea is

00:09:37,779 --> 00:09:42,490
this the words that appear off men

00:09:40,360 --> 00:09:45,279
documents are less important that words

00:09:42,490 --> 00:09:48,970
that appear less often think for example

00:09:45,279 --> 00:09:50,380
of the or what or who aware or something

00:09:48,970 --> 00:09:52,870
like this right this is usually very

00:09:50,380 --> 00:09:55,209
completely independent on what you're

00:09:52,870 --> 00:09:58,269
querying and usually the user is what

00:09:55,209 --> 00:10:00,519
once they get their keywords done how do

00:09:58,269 --> 00:10:02,110
you identify the keywords well exactly

00:10:00,519 --> 00:10:04,420
that you look at the document frequency

00:10:02,110 --> 00:10:06,189
of this term and then you wait your

00:10:04,420 --> 00:10:08,740
terms accordingly and the way this would

00:10:06,189 --> 00:10:10,959
look like a vector space is like this so

00:10:08,740 --> 00:10:13,689
you have for example fox if fox appears

00:10:10,959 --> 00:10:15,870
very often in documents you would move

00:10:13,689 --> 00:10:18,819
the vector a little bit to the left and

00:10:15,870 --> 00:10:20,529
if it pairs very very rarely then this

00:10:18,819 --> 00:10:21,850
is a very important term so you would

00:10:20,529 --> 00:10:24,160
move it a little bit to the right and

00:10:21,850 --> 00:10:29,230
depending on where you move it the score

00:10:24,160 --> 00:10:30,730
gets higher and lower right okay so

00:10:29,230 --> 00:10:35,740
these are the two most important things

00:10:30,730 --> 00:10:37,810
for tf-idf right now now you probably

00:10:35,740 --> 00:10:39,459
won't know how it works but as you can

00:10:37,810 --> 00:10:41,259
imagine I mean there's these two factors

00:10:39,459 --> 00:10:44,439
that are very important so the questions

00:10:41,259 --> 00:10:47,199
how many factors are there right okay

00:10:44,439 --> 00:10:49,120
this is how it really looks like so if

00:10:47,199 --> 00:10:51,850
you go to the lysene web page there's a

00:10:49,120 --> 00:10:54,250
is a very nice home page our very nice

00:10:51,850 --> 00:10:56,290
documentation about how the actual score

00:10:54,250 --> 00:10:58,120
is computed but this year this for

00:10:56,290 --> 00:10:59,829
example this is just the term count they

00:10:58,120 --> 00:11:03,040
decided to put the square root but yeah

00:10:59,829 --> 00:11:05,860
this year is the document frequency so

00:11:03,040 --> 00:11:07,300
this is actually used in this formula

00:11:05,860 --> 00:11:08,589
here and you've probably heard of it

00:11:07,300 --> 00:11:09,529
this is the inverted document frequency

00:11:08,589 --> 00:11:12,319
by which you

00:11:09,529 --> 00:11:15,230
so you wait your terms respectively so

00:11:12,319 --> 00:11:17,600
this is the length here it is roughly 1

00:11:15,230 --> 00:11:18,649
divided by the square root and so on but

00:11:17,600 --> 00:11:20,959
then you have other factors like the

00:11:18,649 --> 00:11:23,240
booze there's some very norm they saw

00:11:20,959 --> 00:11:28,309
them to use but it's still there and so

00:11:23,240 --> 00:11:30,290
on and so forth right okay so so I hope

00:11:28,309 --> 00:11:32,839
now you have an idea of what tf-idf is

00:11:30,290 --> 00:11:34,670
for natural language text and if you

00:11:32,839 --> 00:11:37,100
ever try it out and you run to strange

00:11:34,670 --> 00:11:44,689
things maybe have an idea why this might

00:11:37,100 --> 00:11:47,329
be right there was tf-idf good so the

00:11:44,689 --> 00:11:49,040
heaven many talks about search on this

00:11:47,329 --> 00:11:51,439
conference already and you probably know

00:11:49,040 --> 00:11:53,569
or probably already knew before that as

00:11:51,439 --> 00:11:55,730
many more fancy equations with lots of

00:11:53,569 --> 00:11:57,680
Greek letters so so can we also use them

00:11:55,730 --> 00:12:00,319
and yes you can because elasticsearch is

00:11:57,680 --> 00:12:01,459
built on top of leucine so everything

00:12:00,319 --> 00:12:03,259
that is on the scene for scoring

00:12:01,459 --> 00:12:04,730
implemented you can also use an elastic

00:12:03,259 --> 00:12:08,149
search so we have language metal

00:12:04,730 --> 00:12:10,220
scouring the m25 if our similarity and

00:12:08,149 --> 00:12:12,800
so on and so forth so he's linked to the

00:12:10,220 --> 00:12:13,670
to the homepage to leucine home page if

00:12:12,800 --> 00:12:15,939
you want to know more about the

00:12:13,670 --> 00:12:18,350
implementation as you really want them

00:12:15,939 --> 00:12:22,879
good and how do you learn about this

00:12:18,350 --> 00:12:24,589
well you read this book you check out

00:12:22,879 --> 00:12:26,990
the similarity mucho documentation for

00:12:24,589 --> 00:12:28,790
elastic search and then you read

00:12:26,990 --> 00:12:33,079
elasticsearch the definite guide which

00:12:28,790 --> 00:12:35,180
is coming out soon right mm-hmm and then

00:12:33,079 --> 00:12:36,769
you're done mm-hmm so I'm not going to

00:12:35,180 --> 00:12:38,329
talk about how to actually put this in a

00:12:36,769 --> 00:12:39,559
mapping how to actually implement it and

00:12:38,329 --> 00:12:41,089
not going to sort Jason because you

00:12:39,559 --> 00:12:42,610
would not remember anyway right you can

00:12:41,089 --> 00:12:47,660
look this up on the documentation so

00:12:42,610 --> 00:12:49,819
okay that's right so so one more thing

00:12:47,660 --> 00:12:51,470
about tf-idf so tf-idf is actually used

00:12:49,819 --> 00:12:53,149
for for natural texts that is when

00:12:51,470 --> 00:12:55,309
people write articles when people really

00:12:53,149 --> 00:12:56,540
communicate when they write miles when

00:12:55,309 --> 00:12:58,670
they write books and so on and so forth

00:12:56,540 --> 00:13:00,679
this is what tf-idf is tuned for and

00:12:58,670 --> 00:13:02,899
this is also what the leucine tf-idf is

00:13:00,679 --> 00:13:05,449
tuned for so if you're doing usual

00:13:02,899 --> 00:13:08,569
natural legs queries and natural

00:13:05,449 --> 00:13:10,970
language text queries tf-idf will

00:13:08,569 --> 00:13:13,459
probably be sufficient for you so I knew

00:13:10,970 --> 00:13:15,050
know very few people who actually change

00:13:13,459 --> 00:13:17,209
the similarity because they had any

00:13:15,050 --> 00:13:21,500
problems if they are only looking for

00:13:17,209 --> 00:13:22,970
text right but you might not be

00:13:21,500 --> 00:13:24,889
satisfied with that

00:13:22,970 --> 00:13:27,079
you might need more so when what you

00:13:24,889 --> 00:13:29,209
need to actually tweet the score so

00:13:27,079 --> 00:13:30,379
first of all are you even have numerical

00:13:29,209 --> 00:13:33,050
values that you want to take into

00:13:30,379 --> 00:13:35,149
account say for example you have some

00:13:33,050 --> 00:13:37,069
popularity rating of some item right

00:13:35,149 --> 00:13:39,769
yeah I don't know a web page that shows

00:13:37,069 --> 00:13:41,959
movies for a certain actor then you

00:13:39,769 --> 00:13:43,279
probably do not just want to order them

00:13:41,959 --> 00:13:45,170
but you might want to order them maybe

00:13:43,279 --> 00:13:47,000
by how popular these movies are so to

00:13:45,170 --> 00:13:49,220
make sure that the user gets good movies

00:13:47,000 --> 00:13:50,959
and not bad movies right you might want

00:13:49,220 --> 00:13:52,970
to sell some item and you want to get

00:13:50,959 --> 00:13:54,980
rid of this item so you put it on top or

00:13:52,970 --> 00:13:56,569
you it's more caustic so you want to put

00:13:54,980 --> 00:13:58,839
it on top or its new and that's why you

00:13:56,569 --> 00:14:01,160
want to put it on top so if you have

00:13:58,839 --> 00:14:02,839
such an idea and it is in your document

00:14:01,160 --> 00:14:05,360
you actually want the score to be

00:14:02,839 --> 00:14:07,009
influenced by that so you might also

00:14:05,360 --> 00:14:08,660
want to have some distance of an

00:14:07,009 --> 00:14:11,810
American value say for example you want

00:14:08,660 --> 00:14:14,870
to book a hotel somewhere and you want

00:14:11,810 --> 00:14:17,870
to find out well how far is this hotel

00:14:14,870 --> 00:14:19,639
from this or that location and you want

00:14:17,870 --> 00:14:21,560
to score to act accordingly that it's

00:14:19,639 --> 00:14:23,379
been farther away you maybe want to

00:14:21,560 --> 00:14:25,220
score to be lower than if it's closer

00:14:23,379 --> 00:14:28,939
and other things you might want to

00:14:25,220 --> 00:14:30,439
contacts now I said before this this

00:14:28,939 --> 00:14:32,420
example with the program you're looking

00:14:30,439 --> 00:14:34,759
for a programmer writing the program are

00:14:32,420 --> 00:14:38,930
now several languages now suppose a

00:14:34,759 --> 00:14:40,160
programmer puts ten languages and you're

00:14:38,930 --> 00:14:43,250
searching for someone who knows java

00:14:40,160 --> 00:14:45,740
right so what you would actually get

00:14:43,250 --> 00:14:47,629
it's because of this field things that

00:14:45,740 --> 00:14:49,100
is taken into account what you will get

00:14:47,629 --> 00:14:52,160
is all the people that only know Java

00:14:49,100 --> 00:14:55,009
and nothing else and it's not desirable

00:14:52,160 --> 00:14:57,050
and also you also do not want the score

00:14:55,009 --> 00:14:58,879
to be tweaked by the fact that many

00:14:57,050 --> 00:15:00,589
other people know the language or few

00:14:58,879 --> 00:15:02,180
other people know the language right it

00:15:00,589 --> 00:15:03,769
doesn't make sense in this case because

00:15:02,180 --> 00:15:07,639
it's not natural language is actually

00:15:03,769 --> 00:15:09,110
text and then maybe you're crazy and you

00:15:07,639 --> 00:15:12,079
want to write your own text scoring

00:15:09,110 --> 00:15:13,279
function right this is also one place

00:15:12,079 --> 00:15:15,350
where you would actually need to treat

00:15:13,279 --> 00:15:18,379
your score or you want to combine all

00:15:15,350 --> 00:15:22,160
these right so when I give an example

00:15:18,379 --> 00:15:26,209
afraid this is actually used just to

00:15:22,160 --> 00:15:29,509
make sure you are your trust that it's

00:15:26,209 --> 00:15:32,050
really so can you see that yeah but so

00:15:29,509 --> 00:15:34,100
this is an example for us at so well but

00:15:32,050 --> 00:15:35,990
this is a neat little project that

00:15:34,100 --> 00:15:36,930
people use this actually for for image

00:15:35,990 --> 00:15:41,040
scoring so

00:15:36,930 --> 00:15:42,390
a data set of images and they're looking

00:15:41,040 --> 00:15:44,010
for images that are similar to a

00:15:42,390 --> 00:15:46,050
particular color so for example here and

00:15:44,010 --> 00:15:48,360
can click on and I don't know red and

00:15:46,050 --> 00:15:50,070
then will return me all the red images

00:15:48,360 --> 00:15:52,080
or images to contain a lot of red or you

00:15:50,070 --> 00:15:53,370
have green and then you will give me all

00:15:52,080 --> 00:15:55,260
the images that have something with

00:15:53,370 --> 00:15:56,580
green and them right so this is

00:15:55,260 --> 00:16:03,510
something where you would actually need

00:15:56,580 --> 00:16:04,800
to have your own score right okay so

00:16:03,510 --> 00:16:06,720
what we have an elastic search is a

00:16:04,800 --> 00:16:09,360
particular kind of query so that is the

00:16:06,720 --> 00:16:11,760
functions wearing and it works like

00:16:09,360 --> 00:16:13,850
this so first of all you put the query

00:16:11,760 --> 00:16:16,529
or the filter that it would have before

00:16:13,850 --> 00:16:19,140
just a regular thing and then you can

00:16:16,529 --> 00:16:21,300
define a bunch of functions and what's

00:16:19,140 --> 00:16:23,850
going to happen is this query a filter

00:16:21,300 --> 00:16:26,730
will be executed first I'd return some

00:16:23,850 --> 00:16:28,980
documents and then these documents will

00:16:26,730 --> 00:16:31,500
again be scored then reordered and only

00:16:28,980 --> 00:16:34,290
then will the result be returned now way

00:16:31,500 --> 00:16:36,330
is that song um all because scoring is a

00:16:34,290 --> 00:16:38,040
very expensive operation so you really

00:16:36,330 --> 00:16:40,790
want to filter or query before and sort

00:16:38,040 --> 00:16:43,740
that out right so you have this query

00:16:40,790 --> 00:16:45,330
these functions and these apply it well

00:16:43,740 --> 00:16:49,830
to the matching cups oh yeah and then

00:16:45,330 --> 00:16:51,180
you can also filter by function so there

00:16:49,830 --> 00:16:53,970
is many options for these for these

00:16:51,180 --> 00:16:56,850
functions so you have field value a

00:16:53,970 --> 00:16:58,860
factor for example uh that would do the

00:16:56,850 --> 00:17:00,570
thing I would that I said before you

00:16:58,860 --> 00:17:04,170
have a field for example popularity and

00:17:00,570 --> 00:17:07,770
you want to actually make this influence

00:17:04,170 --> 00:17:10,110
the score yes distance funny you have

00:17:07,770 --> 00:17:11,730
distance functions the way you can see

00:17:10,110 --> 00:17:13,890
an origin and some sort of scale and

00:17:11,730 --> 00:17:16,650
then it would tweak the scale according

00:17:13,890 --> 00:17:18,240
to more however far this field value of

00:17:16,650 --> 00:17:21,270
this document is from this or that given

00:17:18,240 --> 00:17:22,470
value we've random scoring if you want

00:17:21,270 --> 00:17:24,480
to shuffle your results a little bit

00:17:22,470 --> 00:17:29,429
boost factor which you can use for the

00:17:24,480 --> 00:17:32,429
tax for example okay and at this point I

00:17:29,429 --> 00:17:34,230
could give a nice demonstration on and

00:17:32,429 --> 00:17:36,510
artificial data set and explain how it

00:17:34,230 --> 00:17:38,540
all works and so on and so forth and but

00:17:36,510 --> 00:17:40,740
I already did that so I might have a

00:17:38,540 --> 00:17:42,240
screencast of that right it took me

00:17:40,740 --> 00:17:44,400
forever to do that I had to listen to my

00:17:42,240 --> 00:17:47,340
own wise for three days so please please

00:17:44,400 --> 00:17:48,390
go and watch it because and it's also

00:17:47,340 --> 00:17:50,880
i'm not going to talk about that right

00:17:48,390 --> 00:17:52,710
now right so can go and watch and s

00:17:50,880 --> 00:17:57,150
some some examples on how this can be

00:17:52,710 --> 00:17:59,370
used here but for the remainder of this

00:17:57,150 --> 00:18:01,110
talk I actually want to talk about this

00:17:59,370 --> 00:18:03,090
part so I want to talk about what do you

00:18:01,110 --> 00:18:05,970
want what do you do is you want to write

00:18:03,090 --> 00:18:09,560
your own scoring function how can you do

00:18:05,970 --> 00:18:11,760
that with elasticsearch so i said before

00:18:09,560 --> 00:18:14,100
you have all these different functions

00:18:11,760 --> 00:18:16,650
that you can apply and one of them is

00:18:14,100 --> 00:18:19,640
the script score okay so script culture

00:18:16,650 --> 00:18:23,100
says okay I take a bunch of parameters

00:18:19,640 --> 00:18:25,770
and I use these parameters and some

00:18:23,100 --> 00:18:29,760
values of my document to create my own

00:18:25,770 --> 00:18:32,550
score right so our parameters can be any

00:18:29,760 --> 00:18:35,360
constant that are independent of the

00:18:32,550 --> 00:18:40,320
document and that you can pre-compute

00:18:35,360 --> 00:18:42,960
language so we have Python groovy anvil

00:18:40,320 --> 00:18:44,550
native all sorts of things that you can

00:18:42,960 --> 00:18:47,250
do I mean I hope you find one of the

00:18:44,550 --> 00:18:48,570
languages you probably know all right

00:18:47,250 --> 00:18:50,720
another question is what will be in the

00:18:48,570 --> 00:18:54,420
script what options do you actually have

00:18:50,720 --> 00:18:55,920
so first of all of course you have the

00:18:54,420 --> 00:18:57,930
document values so if you want your

00:18:55,920 --> 00:18:59,490
score to be a sort of influenced by the

00:18:57,930 --> 00:19:00,900
document values you can access this by a

00:18:59,490 --> 00:19:04,110
specific variable that's called

00:19:00,900 --> 00:19:06,090
underscore talk or talk and you can

00:19:04,110 --> 00:19:08,880
access the actual value so this is your

00:19:06,090 --> 00:19:10,140
mville notation right it's similar and

00:19:08,880 --> 00:19:14,850
all the languages but this is the mville

00:19:10,140 --> 00:19:16,470
notation access the fields are by well

00:19:14,850 --> 00:19:17,910
by the name of the field and then that

00:19:16,470 --> 00:19:20,550
value just gives you the value of this

00:19:17,910 --> 00:19:21,870
field and then you can do all sorts of

00:19:20,550 --> 00:19:24,240
things with it for example you can say

00:19:21,870 --> 00:19:27,380
ok I want to square this for some reason

00:19:24,240 --> 00:19:29,480
or because the scene does it or whatever

00:19:27,380 --> 00:19:32,850
so this way you can access the talk

00:19:29,480 --> 00:19:34,200
values and then we have a new thing and

00:19:32,850 --> 00:19:36,630
this is the one thing I actually want to

00:19:34,200 --> 00:19:38,070
advertise today it is underscore index

00:19:36,630 --> 00:19:40,020
and this is a variable that actually

00:19:38,070 --> 00:19:42,870
allows you to get all the statistics

00:19:40,020 --> 00:19:44,280
that are in the low seen index and this

00:19:42,870 --> 00:19:45,600
is the thing that is new and it's super

00:19:44,280 --> 00:19:47,040
flexible and you can do many things with

00:19:45,600 --> 00:19:50,010
it so this is where I'm going to talk

00:19:47,040 --> 00:19:54,530
about it from now on right so what is it

00:19:50,010 --> 00:19:54,530
an index ok we were talking before about

00:19:55,220 --> 00:20:02,210
word counts right ooh 10 minutes haha

00:19:58,830 --> 00:20:04,170
really good Harry okay what counselor so

00:20:02,210 --> 00:20:04,830
and this is actually called the

00:20:04,170 --> 00:20:06,390
technical

00:20:04,830 --> 00:20:08,760
for this is term frequency so for

00:20:06,390 --> 00:20:10,710
example in this document here the quick

00:20:08,760 --> 00:20:12,630
brown fox likes brown eyes the term

00:20:10,710 --> 00:20:15,269
frequency of brown would be too and the

00:20:12,630 --> 00:20:18,240
term frequency of dark fox would

00:20:15,269 --> 00:20:20,039
actually be one sorry it is wrong okay

00:20:18,240 --> 00:20:21,690
but you get my meaning right okay and

00:20:20,039 --> 00:20:24,809
the way your access is really just an

00:20:21,690 --> 00:20:26,490
Oscar index at the field for this term

00:20:24,809 --> 00:20:27,929
give me the term frequency and if the

00:20:26,490 --> 00:20:29,820
term doesn't appear with it will just

00:20:27,929 --> 00:20:32,580
return 0 it'll not crash on you or

00:20:29,820 --> 00:20:35,970
anything hopefully right and this is how

00:20:32,580 --> 00:20:37,860
the query would look like so so your

00:20:35,970 --> 00:20:39,450
function score you define script scorer

00:20:37,860 --> 00:20:40,889
and if you define able and volume don't

00:20:39,450 --> 00:20:42,360
need anything else and this is the

00:20:40,889 --> 00:20:46,080
script so this for example would give

00:20:42,360 --> 00:20:48,990
you documents that contain the term in

00:20:46,080 --> 00:20:50,159
this case build in most often but you

00:20:48,990 --> 00:20:52,950
can go further than that you can say

00:20:50,159 --> 00:20:54,960
okay I want to define a field and in

00:20:52,950 --> 00:20:56,730
certain words and then I want to iterate

00:20:54,960 --> 00:20:58,649
over all these terms and some something

00:20:56,730 --> 00:21:00,659
up for example in this case in this very

00:20:58,649 --> 00:21:02,220
easy case I just want to sum up all the

00:21:00,659 --> 00:21:04,289
term frequencies and this will be my new

00:21:02,220 --> 00:21:07,710
score because I think this is good for

00:21:04,289 --> 00:21:09,179
some reason it I'd been right good

00:21:07,710 --> 00:21:11,159
document frequency so this is what I was

00:21:09,179 --> 00:21:13,860
talking before how often does a term

00:21:11,159 --> 00:21:15,779
appear in any document regardless of how

00:21:13,860 --> 00:21:17,580
often it actually appears in it right

00:21:15,779 --> 00:21:21,419
you can get this also in this case the

00:21:17,580 --> 00:21:23,779
function would PDF and I mean document

00:21:21,419 --> 00:21:26,760
frequency for example for I in these two

00:21:23,779 --> 00:21:29,610
sentences would be too even though the I

00:21:26,760 --> 00:21:31,230
appears four times right it's just

00:21:29,610 --> 00:21:35,340
depending on if it's in a document or

00:21:31,230 --> 00:21:37,080
not okay and there's more stuff I still

00:21:35,340 --> 00:21:38,610
the term frequency sum total term

00:21:37,080 --> 00:21:40,110
frequency I'm not going to go into

00:21:38,610 --> 00:21:41,789
details because it's really nice

00:21:40,110 --> 00:21:45,990
documented by this wonderful program or

00:21:41,789 --> 00:21:47,940
so go and check it out one thing that we

00:21:45,990 --> 00:21:50,309
cannot have in the leucine NX is the

00:21:47,940 --> 00:21:53,100
token count that is how many words does

00:21:50,309 --> 00:21:56,639
your document actually contain okay this

00:21:53,100 --> 00:21:59,330
is something that you have to do well

00:21:56,639 --> 00:22:03,330
not by yourself you can do it with a

00:21:59,330 --> 00:22:06,169
word count type so if you want to know

00:22:03,330 --> 00:22:08,220
more about it as a documentation here

00:22:06,169 --> 00:22:09,690
you can just configure that before

00:22:08,220 --> 00:22:12,720
indexing and then it will actually store

00:22:09,690 --> 00:22:15,270
with document the number of tokens that

00:22:12,720 --> 00:22:16,970
are in this field so that was Nick Nick

00:22:15,270 --> 00:22:20,659
sitting there he did that

00:22:16,970 --> 00:22:21,740
no it's really good all right okay and

00:22:20,659 --> 00:22:24,470
another thing you have is for example

00:22:21,740 --> 00:22:25,880
positions okay so together with your own

00:22:24,470 --> 00:22:28,970
frequencies and document frequencies and

00:22:25,880 --> 00:22:31,490
all that what is also scored stored or

00:22:28,970 --> 00:22:34,159
can be stored Palestine is stored by

00:22:31,490 --> 00:22:35,780
default it's the positions so say for

00:22:34,159 --> 00:22:38,299
example you have the sentence I am Sam

00:22:35,780 --> 00:22:41,059
Sam I am then the positions for I would

00:22:38,299 --> 00:22:43,460
be 04 and the positions for am would be

00:22:41,059 --> 00:22:46,039
15 and we will see in a mint what this

00:22:43,460 --> 00:22:47,929
is good for okay and there is more

00:22:46,039 --> 00:22:49,760
there's offsets and then there's all

00:22:47,929 --> 00:22:51,980
sorts of palos and you can all access

00:22:49,760 --> 00:22:53,480
this through the underscore index right

00:22:51,980 --> 00:22:56,270
but now I want to show some examples so

00:22:53,480 --> 00:22:59,390
right so remember T if I have this

00:22:56,270 --> 00:23:04,549
terrible equation here right you can do

00:22:59,390 --> 00:23:06,679
it in 17 lines check it out so you said

00:23:04,549 --> 00:23:07,970
go so this is amit is uppercase sigma

00:23:06,679 --> 00:23:09,679
it's just a summation right you iterate

00:23:07,970 --> 00:23:11,360
over all the terms so these are your

00:23:09,679 --> 00:23:16,340
terms here for example so this just

00:23:11,360 --> 00:23:18,620
means for each term next TF so the term

00:23:16,340 --> 00:23:20,539
frequency you can get this with the

00:23:18,620 --> 00:23:23,150
underscore in next year hold on here and

00:23:20,539 --> 00:23:26,750
here right and then you just put this

00:23:23,150 --> 00:23:28,640
here then x IDF so I the f is this

00:23:26,750 --> 00:23:31,520
horrible thing here but you can just put

00:23:28,640 --> 00:23:33,860
it in here so this would be that thing

00:23:31,520 --> 00:23:35,150
the norm this is not exactly the same

00:23:33,860 --> 00:23:37,570
it's not exactly how it works in the

00:23:35,150 --> 00:23:41,179
scene but it's a similar thing right

00:23:37,570 --> 00:23:44,299
right and then you're done GF IDF 17

00:23:41,179 --> 00:23:47,570
lines no sim score are no similarity no

00:23:44,299 --> 00:23:50,840
wait no nothing so write a phrase car

00:23:47,570 --> 00:23:52,340
and 30 lines also right so so this

00:23:50,840 --> 00:23:54,530
actually makes use of the positions so

00:23:52,340 --> 00:23:56,900
you can get the positions for for for

00:23:54,530 --> 00:23:59,690
example names for John and Smith and

00:23:56,900 --> 00:24:01,669
then you can just do a list intersection

00:23:59,690 --> 00:24:03,350
sort of and figure out when Smith

00:24:01,669 --> 00:24:04,669
appears after John and what's the

00:24:03,350 --> 00:24:10,490
minimal distance and you can do this in

00:24:04,669 --> 00:24:11,929
39 s as you can see here right ok I can

00:24:10,490 --> 00:24:16,010
give you a very rough estimate of the

00:24:11,929 --> 00:24:23,440
running time ah but maybe since the time

00:24:16,010 --> 00:24:25,840
is running low I'm not coming sorry 00

00:24:23,440 --> 00:24:30,610
all right you put up the 10-minute sign

00:24:25,840 --> 00:24:30,610
out there no problem no no problem okay

00:24:31,440 --> 00:24:38,980
okay no no it's a good all right all

00:24:36,460 --> 00:24:41,080
right so so tested for this put a little

00:24:38,980 --> 00:24:42,970
phrase Cora right I just ran it I don't

00:24:41,080 --> 00:24:44,080
know that it's it's really stupid right

00:24:42,970 --> 00:24:46,000
it was a really stupid run time

00:24:44,080 --> 00:24:47,980
estimation I just ran it five or ten

00:24:46,000 --> 00:24:50,230
times and then I just compared phrase

00:24:47,980 --> 00:24:52,150
Goran tf-idf and I try to compare to the

00:24:50,230 --> 00:24:53,410
scene but as you could sue before it's

00:24:52,150 --> 00:24:54,790
not really the same so please don't

00:24:53,410 --> 00:24:56,890
quote this anywhere right don't tweet

00:24:54,790 --> 00:24:58,780
Britta says elasticsearch can do or

00:24:56,890 --> 00:25:00,340
something because that's has to be

00:24:58,780 --> 00:25:03,010
evaluated properly but just to give you

00:25:00,340 --> 00:25:07,330
an idea what it can do so for this

00:25:03,010 --> 00:25:09,850
little thing tf-idf leucine is of course

00:25:07,330 --> 00:25:12,990
quickest 317 milliseconds it was a big

00:25:09,850 --> 00:25:15,820
data set a really huge sir Sean okay and

00:25:12,990 --> 00:25:18,040
while native script which just means you

00:25:15,820 --> 00:25:20,710
plug in your own Java thing was well

00:25:18,040 --> 00:25:24,700
roughly four times as much right or five

00:25:20,710 --> 00:25:28,030
times as much medium and mville well

00:25:24,700 --> 00:25:30,190
embolus is considerably slower however

00:25:28,030 --> 00:25:32,110
remember that ml is really easy to do

00:25:30,190 --> 00:25:34,030
our groovy or Python or whatever you

00:25:32,110 --> 00:25:35,620
have because you do not have to

00:25:34,030 --> 00:25:37,660
recompile or anything right you just

00:25:35,620 --> 00:25:40,240
type it there and then repair supply and

00:25:37,660 --> 00:25:42,880
then it'll it'll work so it still has

00:25:40,240 --> 00:25:45,250
its use as I will show in a minute right

00:25:42,880 --> 00:25:46,600
so practical advice if you actually want

00:25:45,250 --> 00:25:49,180
to use that if you want to have your own

00:25:46,600 --> 00:25:50,920
scoring function sort of what you do

00:25:49,180 --> 00:25:53,740
first thing check if it's already there

00:25:50,920 --> 00:25:54,910
so we have as I said before we have the

00:25:53,740 --> 00:25:56,770
field value effect or the distance

00:25:54,910 --> 00:25:59,830
function the random scoring the boost

00:25:56,770 --> 00:26:01,300
vector and you can combine all these and

00:25:59,830 --> 00:26:02,770
you can also combine these together with

00:26:01,300 --> 00:26:06,640
a leucine score and so on and so forth

00:26:02,770 --> 00:26:08,080
using the function score square e so so

00:26:06,640 --> 00:26:10,960
check if it's already there and if it's

00:26:08,080 --> 00:26:13,510
there with your done that's cool but

00:26:10,960 --> 00:26:15,250
about is not so use your favorite

00:26:13,510 --> 00:26:17,590
scripting language to try things out as

00:26:15,250 --> 00:26:20,770
I said we have plugins for Python groovy

00:26:17,590 --> 00:26:25,240
anvil JavaScript I'm sure if we have

00:26:20,770 --> 00:26:31,480
anything else anything ma Ruby really oh

00:26:25,240 --> 00:26:36,430
oh no this is taped right oh no ok

00:26:31,480 --> 00:26:37,990
anyway okay okay awesome food right use

00:26:36,430 --> 00:26:39,430
this to try it out because you will not

00:26:37,990 --> 00:26:41,140
have to restart you know you will not

00:26:39,430 --> 00:26:42,340
have to do anything you can just type it

00:26:41,140 --> 00:26:44,980
somewhere put it in the appropriate

00:26:42,340 --> 00:26:47,170
folder it will be reloaded automatically

00:26:44,980 --> 00:26:48,940
no matter how you can configure it that

00:26:47,170 --> 00:26:50,830
way and then just press apply and you

00:26:48,940 --> 00:26:52,450
will immediately see the result right it

00:26:50,830 --> 00:26:55,330
might be a little slower but you will

00:26:52,450 --> 00:26:58,390
see the result immediately okay so is it

00:26:55,330 --> 00:27:01,810
fast enough already then you're done if

00:26:58,390 --> 00:27:03,160
not you can use a native script so

00:27:01,810 --> 00:27:04,720
didn't I said before we have that I

00:27:03,160 --> 00:27:07,090
didn't say what it is so what it

00:27:04,720 --> 00:27:10,450
actually is it's a plug-in you can plug

00:27:07,090 --> 00:27:13,120
this into elasticsearch a precompiled

00:27:10,450 --> 00:27:15,700
thing so this is way faster than

00:27:13,120 --> 00:27:17,800
scripting or faster than scripting at

00:27:15,700 --> 00:27:19,420
least but because it's it's just in Java

00:27:17,800 --> 00:27:21,970
so there's no execution overhead

00:27:19,420 --> 00:27:23,560
whatsoever but it has a downside of

00:27:21,970 --> 00:27:26,770
course that is it needs to be maintained

00:27:23,560 --> 00:27:27,940
so whenever elasticsearch changes api or

00:27:26,770 --> 00:27:30,790
something you will have to you know

00:27:27,940 --> 00:27:32,200
adjust it somewhere you need to restart

00:27:30,790 --> 00:27:33,310
the note when you actually change this

00:27:32,200 --> 00:27:34,570
plugin so if you're actually running

00:27:33,310 --> 00:27:35,800
this in production or something you

00:27:34,570 --> 00:27:38,710
don't have to well restart each of the

00:27:35,800 --> 00:27:40,600
node and that's not a lot of fun right

00:27:38,710 --> 00:27:42,670
and of course it produces more quote

00:27:40,600 --> 00:27:45,700
because you have the whole plug-in

00:27:42,670 --> 00:27:48,070
mechanism overhead right and then you

00:27:45,700 --> 00:27:50,470
don't want more or less code if you want

00:27:48,070 --> 00:27:51,910
to see how this actually works there's a

00:27:50,470 --> 00:27:54,100
nice example by a colleague of mine so

00:27:51,910 --> 00:27:55,600
so ego motive did have native script

00:27:54,100 --> 00:27:57,430
example that's also where document that

00:27:55,600 --> 00:27:59,650
you can actually just check this out on

00:27:57,430 --> 00:28:02,380
github change your scoring function

00:27:59,650 --> 00:28:03,970
accordingly follow the advice on the and

00:28:02,380 --> 00:28:05,290
they really nice read me that explains

00:28:03,970 --> 00:28:08,710
everything what you have to do and then

00:28:05,290 --> 00:28:11,590
you're done right so it is fast enough

00:28:08,710 --> 00:28:15,430
again you're done what is not fast

00:28:11,590 --> 00:28:18,070
enough um so so this is a different way

00:28:15,430 --> 00:28:20,740
by which you can try to speed up things

00:28:18,070 --> 00:28:24,030
a little bit and that is it we have a

00:28:20,740 --> 00:28:25,780
rescore API so the way this works is

00:28:24,030 --> 00:28:26,920
usually in functions where you would

00:28:25,780 --> 00:28:28,870
have your query or filter that's

00:28:26,920 --> 00:28:31,300
executed than the documents that match

00:28:28,870 --> 00:28:33,670
the filter are scored by the function

00:28:31,300 --> 00:28:36,280
score but you could also have something

00:28:33,670 --> 00:28:38,620
maybe you have a really quick method to

00:28:36,280 --> 00:28:40,330
get maybe the top 1000 or something on

00:28:38,620 --> 00:28:42,040
top but they're not really older than

00:28:40,330 --> 00:28:44,530
the right ordering you want a more

00:28:42,040 --> 00:28:46,270
accurate ouran maybe with the top end

00:28:44,530 --> 00:28:49,120
and this is what we score AI is good for

00:28:46,270 --> 00:28:50,620
so if you know that the best results are

00:28:49,120 --> 00:28:52,570
within top end and the only one recourse

00:28:50,620 --> 00:28:55,330
Cordys and you know the scoring it's

00:28:52,570 --> 00:28:56,920
really heavy you use the risk or API so

00:28:55,330 --> 00:28:58,540
roughly this looks like this you would

00:28:56,920 --> 00:29:01,150
have your query and it would say rescore

00:28:58,540 --> 00:29:02,770
you can get the window size and then you

00:29:01,150 --> 00:29:05,770
can put your function screen here and

00:29:02,770 --> 00:29:10,240
this will only execute on a term 50 or

00:29:05,770 --> 00:29:16,120
top 100 or whatever right so this fast

00:29:10,240 --> 00:29:18,220
enough to school but what it's not so

00:29:16,120 --> 00:29:19,840
leucine is much quicker than than the

00:29:18,220 --> 00:29:22,180
implementation of the tf-idf as i showed

00:29:19,840 --> 00:29:25,180
before and the reason is that the scene

00:29:22,180 --> 00:29:28,720
actually makes use of p computed values

00:29:25,180 --> 00:29:30,130
so for example this document norm the

00:29:28,720 --> 00:29:33,010
length storm that i was talking about

00:29:30,130 --> 00:29:34,870
before is actually stored when indexing

00:29:33,010 --> 00:29:37,690
right so they put the square root and

00:29:34,870 --> 00:29:39,220
everything store it as a 8-bit float and

00:29:37,690 --> 00:29:41,260
then just saw it so they just have to

00:29:39,220 --> 00:29:42,520
retrieve it and multiply whereas I in my

00:29:41,260 --> 00:29:45,340
script had to put the square root

00:29:42,520 --> 00:29:46,720
actually which is of course an intensive

00:29:45,340 --> 00:29:49,480
operation because it has to be executed

00:29:46,720 --> 00:29:52,840
on each document so if you have any

00:29:49,480 --> 00:29:55,890
means to add a star some value with

00:29:52,840 --> 00:29:58,870
document or to pre-compute them somehow

00:29:55,890 --> 00:30:02,080
pre-compute them with them try to do

00:29:58,870 --> 00:30:04,120
this and pass it as a parameter okay so

00:30:02,080 --> 00:30:08,340
fast enough you're done again this

00:30:04,120 --> 00:30:14,170
Emperor I'm sorry or nothing no I'm I

00:30:08,340 --> 00:30:16,420
owe you one I think okay right if it's

00:30:14,170 --> 00:30:18,130
still not fast enough I'm sorry you have

00:30:16,420 --> 00:30:21,280
to wait until it all the to do seven or

00:30:18,130 --> 00:30:25,150
make a pull request for them so what

00:30:21,280 --> 00:30:26,620
other to do is right now so as I said I

00:30:25,150 --> 00:30:30,820
mean we do not really precompute any

00:30:26,620 --> 00:30:32,920
values on the fly or anything when

00:30:30,820 --> 00:30:34,570
indexing so you might want to have an

00:30:32,920 --> 00:30:36,430
option to actually precompute something

00:30:34,570 --> 00:30:38,380
before you index then store this with

00:30:36,430 --> 00:30:40,000
the document and retrieve it the moment

00:30:38,380 --> 00:30:42,100
you want to score so we don't have that

00:30:40,000 --> 00:30:43,540
right now we also don't have something

00:30:42,100 --> 00:30:45,850
like pre-compute values before search

00:30:43,540 --> 00:30:47,500
execution on a shard for example the IDF

00:30:45,850 --> 00:30:49,900
that I was talking about before this big

00:30:47,500 --> 00:30:51,460
one plus one divided by log and so on

00:30:49,900 --> 00:30:53,080
and so forth this is something that you

00:30:51,460 --> 00:30:55,570
could actually precompute per term

00:30:53,080 --> 00:30:57,040
before the script executes on all the

00:30:55,570 --> 00:30:57,910
documents and it will save you a lot of

00:30:57,040 --> 00:31:01,930
time

00:30:57,910 --> 00:31:03,820
okay we don't have to get currently also

00:31:01,930 --> 00:31:05,380
this only uses shot statistics so if you

00:31:03,820 --> 00:31:07,440
get the document frequency you will only

00:31:05,380 --> 00:31:10,720
get the document frequency of the shard

00:31:07,440 --> 00:31:12,670
we did not have the DFS crowd and fetch

00:31:10,720 --> 00:31:14,340
that we usually have yet so this is

00:31:12,670 --> 00:31:17,170
something we're missing right now

00:31:14,340 --> 00:31:19,510
another thing that might be good I'm not

00:31:17,170 --> 00:31:21,220
sure is if you could give address the

00:31:19,510 --> 00:31:22,900
full text and the parameters and would

00:31:21,220 --> 00:31:24,640
do the analysis for you depending on a

00:31:22,900 --> 00:31:27,190
foot field this is a break it down into

00:31:24,640 --> 00:31:31,720
tokens that would also be good wow yeah

00:31:27,190 --> 00:31:35,530
that's the to do's so right and then

00:31:31,720 --> 00:31:37,030
lasting so I spoke to some people on

00:31:35,530 --> 00:31:40,510
this conference and told them then dial

00:31:37,030 --> 00:31:42,340
up here face cover 30 lines and people

00:31:40,510 --> 00:31:43,960
didn't often didn't seem too interested

00:31:42,340 --> 00:31:45,280
and said you know this is all very cool

00:31:43,960 --> 00:31:46,990
and this is nice and nice to play around

00:31:45,280 --> 00:31:48,490
but I I really don't need to treat the

00:31:46,990 --> 00:31:50,860
score I'm I'm really good with tf-idf

00:31:48,490 --> 00:31:57,370
works perfect for me but there's more

00:31:50,860 --> 00:31:59,020
you can do okay so so one thing you can

00:31:57,370 --> 00:32:01,360
for example you do is you can use it in

00:31:59,020 --> 00:32:02,380
a script filled also and then a script

00:32:01,360 --> 00:32:03,790
filled you can do something very

00:32:02,380 --> 00:32:05,530
different you could for example say okay

00:32:03,790 --> 00:32:06,760
I want to compute my favorite value or

00:32:05,530 --> 00:32:09,070
maybe I want to compute my favorite

00:32:06,760 --> 00:32:10,630
class maybe a trained some naive bayes

00:32:09,070 --> 00:32:12,460
classifier before and i want to deploy

00:32:10,630 --> 00:32:14,050
this model inside the script filled and

00:32:12,460 --> 00:32:16,300
deliver the class on the fly once i

00:32:14,050 --> 00:32:18,810
retrieve the document right well you can

00:32:16,300 --> 00:32:22,330
do this if it's based on term statistics

00:32:18,810 --> 00:32:24,010
that's cool or maybe you haven't trained

00:32:22,330 --> 00:32:26,290
unit if based classifier yet and you

00:32:24,010 --> 00:32:27,670
really need to train it so well maybe

00:32:26,290 --> 00:32:29,590
you need all these time statistics and

00:32:27,670 --> 00:32:31,390
all that well then you can use it inside

00:32:29,590 --> 00:32:34,030
the aggregations for example in a script

00:32:31,390 --> 00:32:35,200
and you can do this for each class and

00:32:34,030 --> 00:32:39,190
thereby figure out what the term

00:32:35,200 --> 00:32:43,350
statistics are and train so this is why

00:32:39,190 --> 00:32:45,340
I find it really cool okay and then

00:32:43,350 --> 00:32:47,920
write this is more less the end of my

00:32:45,340 --> 00:32:49,120
talk if you know interested in scoring

00:32:47,920 --> 00:32:51,340
if you want to know more they were

00:32:49,120 --> 00:32:53,320
actually a very nice Alan passwords

00:32:51,340 --> 00:32:54,760
talks here so so Clinton gave a talk

00:32:53,320 --> 00:32:56,830
about how generally how the elastic

00:32:54,760 --> 00:32:59,620
search api worked and did also i think

00:32:56,830 --> 00:33:01,510
talk a little bit about scoring there

00:32:59,620 --> 00:33:04,270
was a nice talk about it from allison de

00:33:01,510 --> 00:33:06,240
cebu yakov it just before this one and

00:33:04,270 --> 00:33:08,440
it was about search quality in practice

00:33:06,240 --> 00:33:11,049
you can't have a talk on learning how to

00:33:08,440 --> 00:33:13,389
rank that's also very interest

00:33:11,049 --> 00:33:15,399
topic and really really broad yeah

00:33:13,389 --> 00:33:17,980
learning how to rank and if you want to

00:33:15,399 --> 00:33:19,269
know about implementation details it's

00:33:17,980 --> 00:33:21,519
the right after me is it a mess in high

00:33:19,269 --> 00:33:26,309
school and not sure how much is going to

00:33:21,519 --> 00:33:26,309
say but we'll see right and that was it

00:33:34,040 --> 00:33:38,790
great thank you very much I'm really

00:33:36,240 --> 00:33:44,180
sorry about the sign yeah don't please

00:33:38,790 --> 00:33:54,750
don't so raise your hands for questions

00:33:44,180 --> 00:33:58,440
okay at the back so what my question is

00:33:54,750 --> 00:33:59,970
how efficiently do you compile so what I

00:33:58,440 --> 00:34:01,410
mean is there is of course the

00:33:59,970 --> 00:34:03,450
efficiency programming language

00:34:01,410 --> 00:34:06,180
efficiency but what I what I mean is if

00:34:03,450 --> 00:34:08,790
you walk to invert it lists and see that

00:34:06,180 --> 00:34:11,730
the word appears in the in list 1 and

00:34:08,790 --> 00:34:13,500
then it leads to you know so to do it

00:34:11,730 --> 00:34:15,600
efficiently you just have to walk those

00:34:13,500 --> 00:34:18,330
least you don't have to jump randomly on

00:34:15,600 --> 00:34:22,380
disk to to get fields of the document so

00:34:18,330 --> 00:34:24,450
when you compile actually these scripts

00:34:22,380 --> 00:34:26,550
do they just walked in vertically so

00:34:24,450 --> 00:34:28,170
they touch something else on disk okay

00:34:26,550 --> 00:34:30,180
so so the way this works is actually

00:34:28,170 --> 00:34:33,630
operates on the leucine and necks so so

00:34:30,180 --> 00:34:36,690
what happens is that once the scoring is

00:34:33,630 --> 00:34:39,480
so okay it reverses all the documents

00:34:36,690 --> 00:34:41,220
that match your previous query right and

00:34:39,480 --> 00:34:42,870
this is directly on the loss union deck

00:34:41,220 --> 00:34:44,520
so it makes use of all the skip lists

00:34:42,870 --> 00:34:46,350
and everything and then once you reach

00:34:44,520 --> 00:34:49,200
the document that actually matched it

00:34:46,350 --> 00:34:51,000
again uses only the leucine index so

00:34:49,200 --> 00:34:52,770
it's really just a wrapper for all the

00:34:51,000 --> 00:34:55,980
you see in functionality that you know

00:34:52,770 --> 00:34:58,050
before so it will oh okay so yeah in

00:34:55,980 --> 00:34:59,940
fact it will be as quick as leucine in

00:34:58,050 --> 00:35:04,080
nexus if that I hope this was your

00:34:59,940 --> 00:35:05,340
question yeah okay but right I mean

00:35:04,080 --> 00:35:07,470
apart from the fact that we do not do

00:35:05,340 --> 00:35:10,470
these pre computations that well would

00:35:07,470 --> 00:35:12,360
save us a lot of time but yeah and then

00:35:10,470 --> 00:35:14,640
of course you have if you use a script I

00:35:12,360 --> 00:35:16,140
mean like Python or I'm not sure how

00:35:14,640 --> 00:35:18,540
this with GUI I didn't try it out I

00:35:16,140 --> 00:35:20,040
heard good things about it but with em

00:35:18,540 --> 00:35:23,510
we'll definitely have this execution

00:35:20,040 --> 00:35:23,510
overhead and yeah

00:35:24,480 --> 00:35:40,680
great any more questions wow so this is

00:35:38,280 --> 00:35:43,550
a question about implementation details

00:35:40,680 --> 00:35:46,710
I'm sorry it's not very scientific but

00:35:43,550 --> 00:35:50,400
so you mentioned that writing Java code

00:35:46,710 --> 00:35:54,359
it's like faster like writing your own

00:35:50,400 --> 00:36:00,330
plugin hmm but you have to write more

00:35:54,359 --> 00:36:04,710
code why is that okay so um I defer to

00:36:00,330 --> 00:36:07,290
my next speaker yeah so there's a the

00:36:04,710 --> 00:36:09,780
plugin mechanism in an elastic search it

00:36:07,290 --> 00:36:11,160
works wire via juice right so you have

00:36:09,780 --> 00:36:13,020
to register sort of the different

00:36:11,160 --> 00:36:14,910
functions you have the way this works is

00:36:13,020 --> 00:36:16,320
you you define your scoring function but

00:36:14,910 --> 00:36:19,170
this has to be inside a particular class

00:36:16,320 --> 00:36:21,450
that has to provide it by another class

00:36:19,170 --> 00:36:24,480
that is registered on runtime and loaded

00:36:21,450 --> 00:36:26,760
and and all that and this all over head

00:36:24,480 --> 00:36:28,800
the whole what is the name whereas it

00:36:26,760 --> 00:36:31,020
registered and so on this means you also

00:36:28,800 --> 00:36:32,609
have to write code for that and I mean

00:36:31,020 --> 00:36:34,020
it's not a big thing really to do I mean

00:36:32,609 --> 00:36:38,090
you can just go to the example as a set

00:36:34,020 --> 00:36:41,070
of eager and check it out yeah that's it

00:36:38,090 --> 00:36:43,109
it's more core but it's not a lot more

00:36:41,070 --> 00:36:46,140
code you can still do it it's not as

00:36:43,109 --> 00:36:48,480
much more code as probably might be when

00:36:46,140 --> 00:36:49,560
you write your own leucine similarity

00:36:48,480 --> 00:36:51,510
which you can also do you can also

00:36:49,560 --> 00:36:53,880
actually I didn't mention that before

00:36:51,510 --> 00:36:55,080
but you can also write your own leucine

00:36:53,880 --> 00:37:02,100
similarity and plug that in to

00:36:55,080 --> 00:37:03,630
elasticsearch so yeah I was just

00:37:02,100 --> 00:37:05,400
wondering if you want to use like a

00:37:03,630 --> 00:37:06,750
language one is scoring or something

00:37:05,400 --> 00:37:08,220
like this how much work would it be

00:37:06,750 --> 00:37:09,660
could you just briefly comment on i know

00:37:08,220 --> 00:37:12,090
i'll probably check out the link you

00:37:09,660 --> 00:37:13,830
head on your slide but if you want to

00:37:12,090 --> 00:37:15,570
have a language model skoura let's say

00:37:13,830 --> 00:37:17,100
from the scene do you have to write a

00:37:15,570 --> 00:37:19,260
plug-in for elasticsearch or how much

00:37:17,100 --> 00:37:20,550
work would it be to use that yeah so so

00:37:19,260 --> 00:37:21,930
language man scoring is implemented in

00:37:20,550 --> 00:37:23,940
lucene and you don't have to write

00:37:21,930 --> 00:37:26,010
anything to use that you can just plug

00:37:23,940 --> 00:37:28,350
it in and I'm not even plug it in you

00:37:26,010 --> 00:37:29,490
can just configure either when you index

00:37:28,350 --> 00:37:31,230
documents or when you search what

00:37:29,490 --> 00:37:33,600
actually when your index documents are

00:37:31,230 --> 00:37:36,690
what similarity you want to use and to

00:37:33,600 --> 00:37:37,950
scene has to so it has Mercer something

00:37:36,690 --> 00:37:40,170
smoothing and another one

00:37:37,950 --> 00:37:41,849
it's both language model modeling and

00:37:40,170 --> 00:37:45,359
you can just use that right away just

00:37:41,849 --> 00:37:47,040
from the Java Jason like configuration

00:37:45,359 --> 00:37:48,300
or exactly it's only just a JSON

00:37:47,040 --> 00:37:50,640
configuration you define it when you

00:37:48,300 --> 00:37:52,500
index the documents in your mapping what

00:37:50,640 --> 00:37:54,960
what what should be used and then that's

00:37:52,500 --> 00:37:56,520
it I mean the scene does for the

00:37:54,960 --> 00:37:58,290
language model modeling it as a little

00:37:56,520 --> 00:38:00,329
trick to make sure it's sup of zero

00:37:58,290 --> 00:38:01,740
right so usually language model scoring

00:38:00,329 --> 00:38:03,630
if it implemented by the book you but

00:38:01,740 --> 00:38:05,010
now get negative source you will not get

00:38:03,630 --> 00:38:08,190
that from the scene but it's not correct

00:38:05,010 --> 00:38:09,480
so yeah you can use that yeah it's all

00:38:08,190 --> 00:38:12,119
in the documentation maybe I should have

00:38:09,480 --> 00:38:19,740
shown an example that was a thing sir

00:38:12,119 --> 00:38:20,730
thanks good anyone else great well thank

00:38:19,740 --> 00:38:23,270
you very much again for your

00:38:20,730 --> 00:38:23,270

YouTube URL: https://www.youtube.com/watch?v=xg2pepPcBME


