Title: Berlin Buzzwords 2014: Martijn van Groningen - ElasticSearch - Percolator #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	One of ElasticSearch's core feature is the ability to do search in reverse with the percolator. The idea is that you ask your search engine if a document matches a set of stored queries rather than submit the query against your stored documents. This feature is very effective for things like classification, data aware routing, even alerting and monitoring of events. This session will focus on how to use the percolator, its features and how it internally works.

Read more:
https://2014.berlinbuzzwords.de/session/elasticsearch-percolator

About Martijn van Groningen:
https://2014.berlinbuzzwords.de/user/189/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,570 --> 00:00:13,340
okay uh let's begin

00:00:08,990 --> 00:00:15,150
hi I am Martin I work for lastic search

00:00:13,340 --> 00:00:20,670
and I'm going

00:00:15,150 --> 00:00:22,890
talk about the percolator so in this

00:00:20,670 --> 00:00:26,220
talk I'm going to give you overview of

00:00:22,890 --> 00:00:30,810
what the percolator is where you for

00:00:26,220 --> 00:00:38,610
what you can use it for how it works

00:00:30,810 --> 00:00:46,320
some tips and tricks oh yeah what is

00:00:38,610 --> 00:00:48,680
happing okay this is I'm not sure why

00:00:46,320 --> 00:00:48,680
this is happening

00:00:50,750 --> 00:01:16,009
come on not funny

00:01:01,739 --> 00:01:16,009
I am hopefully

00:01:41,759 --> 00:01:52,319
you see when I'm okay why is it okay

00:01:50,039 --> 00:02:03,220
thanks

00:01:52,319 --> 00:02:09,549
this is a very bad start I had no idea

00:02:03,220 --> 00:02:10,660
why is but some that settings so I will

00:02:09,549 --> 00:02:12,340
talk about the percolator what it is

00:02:10,660 --> 00:02:14,530
what you can do with its its features

00:02:12,340 --> 00:02:17,380
and how it works and some tips tips and

00:02:14,530 --> 00:02:19,750
tricks so before we talk about the

00:02:17,380 --> 00:02:23,829
percolator let's talk about the less

00:02:19,750 --> 00:02:25,900
exerts less research we index data we

00:02:23,829 --> 00:02:27,549
search that's what we're used to this is

00:02:25,900 --> 00:02:31,750
an example where we use the index and

00:02:27,549 --> 00:02:34,239
documents you see we do a puts we index

00:02:31,750 --> 00:02:36,370
in the name index in the index called my

00:02:34,239 --> 00:02:39,670
index with with the type and mapping my

00:02:36,370 --> 00:02:41,260
type and 90 and the payload of that call

00:02:39,670 --> 00:02:45,489
is the actual document with its fuels

00:02:41,260 --> 00:02:49,480
and values so if you add a document fine

00:02:45,489 --> 00:02:52,120
you can define query you say okay I want

00:02:49,480 --> 00:02:54,760
to search an index my index we use the

00:02:52,120 --> 00:02:57,579
search endpoints and we define a query

00:02:54,760 --> 00:03:02,500
as the payload in this case we define a

00:02:57,579 --> 00:03:04,450
match query which is it's the most most

00:03:02,500 --> 00:03:08,260
common use query in elasticsearch and

00:03:04,450 --> 00:03:11,799
used to match the document and we define

00:03:08,260 --> 00:03:13,239
the filled body with the with the value

00:03:11,799 --> 00:03:15,190
coffee and you know hopefully we get

00:03:13,239 --> 00:03:19,569
something back and obviously we can send

00:03:15,190 --> 00:03:21,880
it back so we we have index document to

00:03:19,569 --> 00:03:24,389
assert and we get we get back hits which

00:03:21,880 --> 00:03:28,420
are the documents we just have indexed

00:03:24,389 --> 00:03:32,260
but that was different now let's let's

00:03:28,420 --> 00:03:35,230
percolate so instead of

00:03:32,260 --> 00:03:38,739
of indexing and document we're going to

00:03:35,230 --> 00:03:40,329
index a query and if you come if you

00:03:38,739 --> 00:03:42,879
look at this this call it looks similar

00:03:40,329 --> 00:03:44,950
to the index call now in difference here

00:03:42,879 --> 00:03:50,319
is that we index into a dedicated type

00:03:44,950 --> 00:03:52,840
called dot percolator and we define the

00:03:50,319 --> 00:03:55,329
body of that of that called the payload

00:03:52,840 --> 00:03:59,470
is the query and not the data itself a

00:03:55,329 --> 00:04:02,230
document here we also defined the query

00:03:59,470 --> 00:04:07,510
the match query the similar query we saw

00:04:02,230 --> 00:04:09,909
in the Search API when we've added a

00:04:07,510 --> 00:04:13,989
query we can use the percolator

00:04:09,909 --> 00:04:16,329
percolate API in order to figure out if

00:04:13,989 --> 00:04:19,630
a query match with documents we want to

00:04:16,329 --> 00:04:22,180
percolate we want to verify and this is

00:04:19,630 --> 00:04:26,229
an different API than the Search API but

00:04:22,180 --> 00:04:28,889
it looks similar I mean the the URI is

00:04:26,229 --> 00:04:31,210
so we have to fire the index we want to

00:04:28,889 --> 00:04:34,120
we don't want to percolate the type and

00:04:31,210 --> 00:04:37,150
we used to percolate endpoints but as

00:04:34,120 --> 00:04:42,760
the the the payload of that of that call

00:04:37,150 --> 00:04:45,639
is not a query but the documents and if

00:04:42,760 --> 00:04:46,720
we run that we get back a match and it's

00:04:45,639 --> 00:04:48,250
the query that it matched with this

00:04:46,720 --> 00:04:52,000
document so we do the reverse it so

00:04:48,250 --> 00:04:54,340
instead of of searching for data we are

00:04:52,000 --> 00:04:59,289
looking for if our documents match with

00:04:54,340 --> 00:05:02,050
queries we have registered now if you

00:04:59,289 --> 00:05:03,580
look at this response we it's it tells

00:05:02,050 --> 00:05:07,449
you how many how many queries have

00:05:03,580 --> 00:05:09,190
matched how many how many matches there

00:05:07,449 --> 00:05:11,500
are so this is we only I only show the

00:05:09,190 --> 00:05:13,870
first match but in but by default it

00:05:11,500 --> 00:05:17,800
just returns the ID of a query that has

00:05:13,870 --> 00:05:19,270
matched and it returns from some general

00:05:17,800 --> 00:05:21,990
header information how long it took and

00:05:19,270 --> 00:05:25,030
how many shards that request Wenzhou

00:05:21,990 --> 00:05:30,789
which I will talk about a bit later but

00:05:25,030 --> 00:05:33,300
the essence is we Mets queries so what

00:05:30,789 --> 00:05:36,400
we did is we did the opposite we

00:05:33,300 --> 00:05:40,599
reversed our flow effectively of finding

00:05:36,400 --> 00:05:44,370
stuff and the reason why it works is

00:05:40,599 --> 00:05:46,090
that both data and documents and queries

00:05:44,370 --> 00:05:49,600
are defined

00:05:46,090 --> 00:05:51,250
Jason so for elasticsearch deaf

00:05:49,600 --> 00:05:53,500
community might as well has been the

00:05:51,250 --> 00:05:56,680
beam document but it just follows the

00:05:53,500 --> 00:05:59,650
structure of of the queer dsl alice

00:05:56,680 --> 00:06:01,930
absurd has and that's why it happens to

00:05:59,650 --> 00:06:04,540
use to to store it and because we put it

00:06:01,930 --> 00:06:07,720
in this special percolated type it gets

00:06:04,540 --> 00:06:10,570
treated as in special ways in that so

00:06:07,720 --> 00:06:12,790
that that query effectively gets loaded

00:06:10,570 --> 00:06:13,900
and when you percolate that korea gets

00:06:12,790 --> 00:06:16,360
checked with the document you motor

00:06:13,900 --> 00:06:20,830
purple eyes so that's in essence what

00:06:16,360 --> 00:06:22,600
the percolator is what question is why

00:06:20,830 --> 00:06:26,500
would you want to do this what what is

00:06:22,600 --> 00:06:32,950
useful for so let's look at some use

00:06:26,500 --> 00:06:38,400
cases the most obvious use case for the

00:06:32,950 --> 00:06:42,250
percolator is monitoring or alerting you

00:06:38,400 --> 00:06:45,400
you store queries you want to view you

00:06:42,250 --> 00:06:47,620
want to be alert alert it off and once

00:06:45,400 --> 00:06:50,110
data gets indexed you want to be

00:06:47,620 --> 00:06:53,169
notified by that it's the most obvious

00:06:50,110 --> 00:06:54,789
use case and you know that can be a lot

00:06:53,169 --> 00:06:56,500
of concrete examples for its price

00:06:54,789 --> 00:06:58,950
monitoring news monitoring weather

00:06:56,500 --> 00:07:02,200
monitoring stock alerts alert me when

00:06:58,950 --> 00:07:05,770
this particular stock is below or above

00:07:02,200 --> 00:07:12,430
a certain value that's that's the use

00:07:05,770 --> 00:07:15,430
case okay it's a big query i mean

00:07:12,430 --> 00:07:20,080
relatively big so here what we did here

00:07:15,430 --> 00:07:22,090
we i'm going to register a certain alert

00:07:20,080 --> 00:07:25,479
something i want to be notified of and

00:07:22,090 --> 00:07:27,250
i'm interested in certain TVs i I have

00:07:25,479 --> 00:07:30,639
my own a special a TV that I want to buy

00:07:27,250 --> 00:07:32,889
but I don't want to paid you know six or

00:07:30,639 --> 00:07:36,610
seven euros I want pay up to it for up

00:07:32,889 --> 00:07:38,590
to five hundred euros so we we in this

00:07:36,610 --> 00:07:40,450
case with an alerts index where we store

00:07:38,590 --> 00:07:42,910
the percolate Aquila scene it can be any

00:07:40,450 --> 00:07:47,260
index you don't are not any index can

00:07:42,910 --> 00:07:49,360
can contain the percolator type and we

00:07:47,260 --> 00:07:53,860
define the in this case a boolean query

00:07:49,360 --> 00:07:58,190
and we should be from notified if the

00:07:53,860 --> 00:08:01,370
price is lower than or equal to than 500

00:07:58,190 --> 00:08:03,020
and the product name is smile atrophy or

00:08:01,370 --> 00:08:06,290
something else I don't want to putting

00:08:03,020 --> 00:08:11,240
any brands here attractive stay turned

00:08:06,290 --> 00:08:12,800
out Tobias myself so you see we've

00:08:11,240 --> 00:08:14,690
arranged query and a match community and

00:08:12,800 --> 00:08:16,550
if you not familiar with like a that's

00:08:14,690 --> 00:08:18,230
asserts that the mask we just mentioned

00:08:16,550 --> 00:08:20,240
specific terms and arranged query just

00:08:18,230 --> 00:08:22,130
between a certain range it will it will

00:08:20,240 --> 00:08:24,430
you know match a document in this case

00:08:22,130 --> 00:08:27,440
they both need to match because we

00:08:24,430 --> 00:08:33,050
combine them in a bullying query with

00:08:27,440 --> 00:08:35,599
most mass classes okay where this query

00:08:33,050 --> 00:08:38,090
registered and now the document gets

00:08:35,599 --> 00:08:40,390
indexed at happens to have this Latifi

00:08:38,090 --> 00:08:44,540
below the specific price so this

00:08:40,390 --> 00:08:48,560
products with a name and price and yeah

00:08:44,540 --> 00:08:51,650
but now it's it's indexed but you know

00:08:48,560 --> 00:08:54,800
you know notified bias so you need to

00:08:51,650 --> 00:08:57,920
use the need to use the percolate API in

00:08:54,800 --> 00:09:01,250
order to get notified by it so we and

00:08:57,920 --> 00:09:03,560
this this case with index documents and

00:09:01,250 --> 00:09:05,270
now I'm actually sending the data twice

00:09:03,560 --> 00:09:08,090
but now to the percolator by in order to

00:09:05,270 --> 00:09:09,440
get notified when it's called returns it

00:09:08,090 --> 00:09:11,840
will it will obviously match by the

00:09:09,440 --> 00:09:13,550
query so I could have have logic in my

00:09:11,840 --> 00:09:16,100
application that I then notify the

00:09:13,550 --> 00:09:17,540
specific users send an email or send a

00:09:16,100 --> 00:09:19,510
private message in my application so

00:09:17,540 --> 00:09:22,040
that he is notified by the fact that

00:09:19,510 --> 00:09:26,870
there are that there is something that

00:09:22,040 --> 00:09:29,120
he's interested in but we are you know

00:09:26,870 --> 00:09:31,490
it's we are sending it twice

00:09:29,120 --> 00:09:34,880
so maybe the amended there's a better

00:09:31,490 --> 00:09:36,560
way to do this whenever you index

00:09:34,880 --> 00:09:39,020
something interested in returns response

00:09:36,560 --> 00:09:41,060
so we've indexed that the fact that you

00:09:39,020 --> 00:09:42,950
know we we update the document we index

00:09:41,060 --> 00:09:45,350
it again and the price is now four

00:09:42,950 --> 00:09:47,960
hundred ninety nine in this case it will

00:09:45,350 --> 00:09:50,800
return and what in there a nice response

00:09:47,960 --> 00:09:56,600
it contains the idea of documents and

00:09:50,800 --> 00:09:58,580
that can be used by the by a variant of

00:09:56,600 --> 00:10:01,280
the percolate API is called percolate

00:09:58,580 --> 00:10:03,470
existing document API apparently it's

00:10:01,280 --> 00:10:09,730
not you know it's not a very creative

00:10:03,470 --> 00:10:12,140
name but in this case I effectively say

00:10:09,730 --> 00:10:15,100
use this document as in this

00:10:12,140 --> 00:10:18,530
the index and use that to to percolate

00:10:15,100 --> 00:10:20,030
and it says in this case effective what

00:10:18,530 --> 00:10:21,830
happens is that to get API in a

00:10:20,030 --> 00:10:23,960
percolator APR emerge to get API in

00:10:21,830 --> 00:10:26,120
lastik certs is an API tells you that

00:10:23,960 --> 00:10:29,570
that allows you to retrieve a document

00:10:26,120 --> 00:10:32,810
ID and you know this you Scott's

00:10:29,570 --> 00:10:35,750
embedded with this API so in these cases

00:10:32,810 --> 00:10:40,760
we we index into the prices index so and

00:10:35,750 --> 00:10:44,150
put and with the tie price and I t1 so

00:10:40,760 --> 00:10:46,220
that's the the the first index we define

00:10:44,150 --> 00:10:48,410
and then a spirit index we define the

00:10:46,220 --> 00:10:53,540
alerts index which is where the query is

00:10:48,410 --> 00:10:56,990
stored and when we when we bring that it

00:10:53,540 --> 00:11:00,620
will obviously also be returned positive

00:10:56,990 --> 00:11:01,910
so it will tell that it match but the

00:11:00,620 --> 00:11:03,560
key is here that you don't need to

00:11:01,910 --> 00:11:05,360
specify it twice so the idea is that

00:11:03,560 --> 00:11:08,240
whenever you index your application

00:11:05,360 --> 00:11:10,700
index data into less desserts you get

00:11:08,240 --> 00:11:13,160
back the response and it folk one post

00:11:10,700 --> 00:11:17,630
post call effectively to figure out if

00:11:13,160 --> 00:11:21,260
any of of the saved searches or user

00:11:17,630 --> 00:11:23,540
saved queries to match without have to

00:11:21,260 --> 00:11:25,180
sending it twice and that is effectively

00:11:23,540 --> 00:11:28,460
how another sub search you can implement

00:11:25,180 --> 00:11:34,490
the the monitoring or the alerting use

00:11:28,460 --> 00:11:36,440
case with the percolator there's also no

00:11:34,490 --> 00:11:39,200
unused if you can use the last where you

00:11:36,440 --> 00:11:41,360
can use to percolate for and I like to

00:11:39,200 --> 00:11:44,030
refer to this the query feedback use

00:11:41,360 --> 00:11:48,950
case it's a bit cryptic but idea is that

00:11:44,030 --> 00:11:51,020
you are going to you know you kind of

00:11:48,950 --> 00:11:53,060
see you're storing the queries that

00:11:51,020 --> 00:11:56,900
users are executing on your system you

00:11:53,060 --> 00:12:01,040
store them nice obsess with some

00:11:56,900 --> 00:12:03,650
pre-processing I presume and by storing

00:12:01,040 --> 00:12:05,930
those queries you effectively are

00:12:03,650 --> 00:12:09,380
capturing valuable information you're

00:12:05,930 --> 00:12:11,870
capturing how users are searching in

00:12:09,380 --> 00:12:13,820
your site what they are interested

00:12:11,870 --> 00:12:15,740
interesting that is very important

00:12:13,820 --> 00:12:17,420
information not for you but also for

00:12:15,740 --> 00:12:18,860
users are using a system and in the use

00:12:17,420 --> 00:12:20,369
case of in this use case we're talking

00:12:18,860 --> 00:12:25,480
about

00:12:20,369 --> 00:12:28,660
like a marketplace or in and kind of

00:12:25,480 --> 00:12:30,730
ecommerce site where where consumers can

00:12:28,660 --> 00:12:32,889
sell products but obviously when you've

00:12:30,730 --> 00:12:34,360
when a consumer is going to sell

00:12:32,889 --> 00:12:38,529
products it's going to fill in some

00:12:34,360 --> 00:12:42,129
properties about it and a price of how

00:12:38,529 --> 00:12:44,920
much is cost but it's you know it can

00:12:42,129 --> 00:12:48,009
submit this advertisement and hoping

00:12:44,920 --> 00:12:50,529
that someone will find it but but if you

00:12:48,009 --> 00:12:53,920
are storing users users queries you can

00:12:50,529 --> 00:12:56,019
expectedly tell the user before you know

00:12:53,920 --> 00:13:00,989
before actually saving the advertisement

00:12:56,019 --> 00:13:04,119
is this going to match with something so

00:13:00,989 --> 00:13:06,040
by effectively in the Edit form by if

00:13:04,119 --> 00:13:07,809
someone changes the property on

00:13:06,040 --> 00:13:10,149
attribute if you learn the percolate API

00:13:07,809 --> 00:13:12,160
that whole edit from formation turned

00:13:10,149 --> 00:13:13,869
into a document you percolate against

00:13:12,160 --> 00:13:16,179
the users queries and it will tell how

00:13:13,869 --> 00:13:17,559
many queries have matched and that's

00:13:16,179 --> 00:13:20,829
very information so you can for example

00:13:17,559 --> 00:13:22,029
pick a price range where you know at

00:13:20,829 --> 00:13:24,490
least people are looking at your

00:13:22,029 --> 00:13:28,209
products looking at you know at the car

00:13:24,490 --> 00:13:29,559
you're selling at at at a real estate

00:13:28,209 --> 00:13:31,899
object you're selling something like

00:13:29,559 --> 00:13:35,759
that so this is a really practical use

00:13:31,899 --> 00:13:35,759
case where you can use the percolator

00:13:36,209 --> 00:13:41,589
and another use case of I don't have

00:13:40,059 --> 00:13:43,869
examples of the previous one but how to

00:13:41,589 --> 00:13:45,100
use it but it's similar how you use use

00:13:43,869 --> 00:13:47,379
to percolate that I you just have to

00:13:45,100 --> 00:13:51,759
store a queries another use case is a

00:13:47,379 --> 00:13:56,189
classification use case where you like

00:13:51,759 --> 00:13:59,019
to automatically categorize tag

00:13:56,189 --> 00:14:04,869
documents that are going into last

00:13:59,019 --> 00:14:07,329
exerts a factly what what a workflow is

00:14:04,869 --> 00:14:09,249
is that before you index it you you Pro

00:14:07,329 --> 00:14:11,649
collect the documents and the returned

00:14:09,249 --> 00:14:15,490
the IDS queries that match it uses IDs

00:14:11,649 --> 00:14:18,939
to categorize a document for example you

00:14:15,490 --> 00:14:24,339
can have a percolator community stored

00:14:18,939 --> 00:14:27,100
that they say h0 shape filter and allow

00:14:24,339 --> 00:14:31,049
to do some geo tagging that is custom to

00:14:27,100 --> 00:14:31,049
your to your to your application

00:14:31,510 --> 00:14:36,970
and automatically you know categorizing

00:14:34,060 --> 00:14:38,470
taking documents for example if you

00:14:36,970 --> 00:14:42,910
store percolate the queries that have

00:14:38,470 --> 00:14:45,339
certain terms that are unique to a

00:14:42,910 --> 00:14:46,959
specific category we just have to rent

00:14:45,339 --> 00:14:50,230
the document in the percolate API and

00:14:46,959 --> 00:14:51,790
you will know you can tell what what tax

00:14:50,230 --> 00:14:54,070
that don't get me need need to have this

00:14:51,790 --> 00:14:56,800
is a pre-processing step you obviously

00:14:54,070 --> 00:14:58,720
need to implement an application but you

00:14:56,800 --> 00:15:00,670
can use to percolate API in order to

00:14:58,720 --> 00:15:04,089
enrich your document before before

00:15:00,670 --> 00:15:05,680
saving it into elasticsearch obviously

00:15:04,089 --> 00:15:07,120
how to identify patterns that is

00:15:05,680 --> 00:15:09,040
something the pro guide doesn't do you

00:15:07,120 --> 00:15:12,820
need to store queries that identify

00:15:09,040 --> 00:15:15,459
patterns and you know you may need need

00:15:12,820 --> 00:15:18,220
to you know do some do some resource

00:15:15,459 --> 00:15:21,820
what are the appropriate terms or words

00:15:18,220 --> 00:15:25,180
that encapsulate certain certain

00:15:21,820 --> 00:15:26,800
categories of tax you you can I mean

00:15:25,180 --> 00:15:30,550
what I've seen is that you can you can

00:15:26,800 --> 00:15:34,420
use aggregations in order to find out

00:15:30,550 --> 00:15:38,019
for specific keywords or categories what

00:15:34,420 --> 00:15:41,920
are important values important terms and

00:15:38,019 --> 00:15:46,660
and and put that I will save that as a

00:15:41,920 --> 00:15:48,250
percolator query so let's not another

00:15:46,660 --> 00:15:52,839
use case when you can use the percolator

00:15:48,250 --> 00:15:54,850
form okay so we find out what what the

00:15:52,839 --> 00:15:58,060
percolator is what for what is useful

00:15:54,850 --> 00:15:59,890
for now let's let's dive into the

00:15:58,060 --> 00:16:06,930
percolator let's dive into how it

00:15:59,890 --> 00:16:12,370
actually works so the the percolator

00:16:06,930 --> 00:16:14,800
when you index a query what it does it's

00:16:12,370 --> 00:16:16,060
it stores that which effective document

00:16:14,800 --> 00:16:19,690
it stores a document on their skates

00:16:16,060 --> 00:16:22,329
there but it takes the whole the query

00:16:19,690 --> 00:16:26,019
you have to find in a document parses it

00:16:22,329 --> 00:16:34,540
and and saves the stores the first

00:16:26,019 --> 00:16:36,130
version of it in memory and and that

00:16:34,540 --> 00:16:37,779
happens in real time so whenever you

00:16:36,130 --> 00:16:38,649
you're adding queries you change the

00:16:37,779 --> 00:16:40,630
queries that happens in real time

00:16:38,649 --> 00:16:44,070
there's like a collection of quick of

00:16:40,630 --> 00:16:47,560
queries that that's that that's around

00:16:44,070 --> 00:16:52,150
when you then execute the percolate API

00:16:47,560 --> 00:16:54,160
a single dog that single donkey make

00:16:52,150 --> 00:16:57,010
you've defined in a percolate API gets

00:16:54,160 --> 00:17:00,400
index into a special in-memory inverted

00:16:57,010 --> 00:17:01,840
index one sets have happens all the

00:17:00,400 --> 00:17:04,810
queries that are stored

00:17:01,840 --> 00:17:08,380
are you actually are used linear I in in

00:17:04,810 --> 00:17:11,230
in serial are executed on this in memory

00:17:08,380 --> 00:17:13,690
index and it will use safe water it

00:17:11,230 --> 00:17:17,530
matches or heated matches that is in in

00:17:13,690 --> 00:17:20,199
you know what what it does after you've

00:17:17,530 --> 00:17:21,970
executed the prototype IDs in memory in

00:17:20,199 --> 00:17:27,339
it's the third up and you can do the

00:17:21,970 --> 00:17:30,580
next execution but the important thing

00:17:27,339 --> 00:17:35,200
is that you know on the shore level the

00:17:30,580 --> 00:17:38,260
execution is is linear because it

00:17:35,200 --> 00:17:40,570
evaluates its q1 met one there's not no

00:17:38,260 --> 00:17:41,920
special data structure that somehow can

00:17:40,570 --> 00:17:43,420
decide if it matches with this query

00:17:41,920 --> 00:17:44,590
then I don't need to execute these

00:17:43,420 --> 00:17:51,910
communities or something like that

00:17:44,590 --> 00:17:57,190
that's not not the case but ProGlide

00:17:51,910 --> 00:17:58,690
there is a distributed feature API when

00:17:57,190 --> 00:18:00,280
you store queries in the index they

00:17:58,690 --> 00:18:03,940
catch take it effectively physically

00:18:00,280 --> 00:18:06,370
stored in in shorts each index analysis

00:18:03,940 --> 00:18:09,760
has a number of charts partitions where

00:18:06,370 --> 00:18:11,080
the data gets divided between and the

00:18:09,760 --> 00:18:15,610
pro-qadhafi are executed in parallel

00:18:11,080 --> 00:18:18,520
across those charts and that's obviously

00:18:15,610 --> 00:18:20,860
very useful aspect and both can and does

00:18:18,520 --> 00:18:23,980
speed up the time it takes to percolate

00:18:20,860 --> 00:18:30,310
documents especially when you have a lot

00:18:23,980 --> 00:18:31,750
of queries also any index can never

00:18:30,310 --> 00:18:35,200
percolate index is not something

00:18:31,750 --> 00:18:37,840
something special so you can if if

00:18:35,200 --> 00:18:40,660
you're if you're queer sort of fighter

00:18:37,840 --> 00:18:42,040
between multiple indexes you you can use

00:18:40,660 --> 00:18:44,040
egg you can use percolate across

00:18:42,040 --> 00:18:47,320
multiple axes

00:18:44,040 --> 00:18:49,060
any elastic search there's a feature or

00:18:47,320 --> 00:18:52,270
like a distributed feature called

00:18:49,060 --> 00:18:54,880
routing which allows you to control you

00:18:52,270 --> 00:18:56,800
know what partition is not really what

00:18:54,880 --> 00:18:59,650
partition but what part of

00:18:56,800 --> 00:19:01,960
of the data set is being executed

00:18:59,650 --> 00:19:05,410
routing is something you use all the way

00:19:01,960 --> 00:19:09,670
from indexing till searching or or

00:19:05,410 --> 00:19:15,790
percolating and that that can can reduce

00:19:09,670 --> 00:19:17,730
the execution so here an small ID you

00:19:15,790 --> 00:19:22,630
know this is let's say with three nodes

00:19:17,730 --> 00:19:25,390
with three three shards and each each

00:19:22,630 --> 00:19:29,860
shard has a observe replica in this case

00:19:25,390 --> 00:19:32,650
green is a it's a primary short and and

00:19:29,860 --> 00:19:36,870
a wide small square in size a replica

00:19:32,650 --> 00:19:40,570
short the period API the small clients

00:19:36,870 --> 00:19:42,010
Quine square or is the client excuse me

00:19:40,570 --> 00:19:44,260
percolate request and that that

00:19:42,010 --> 00:19:45,970
privilege request gets divided across

00:19:44,260 --> 00:19:48,370
all your all your nodes in a cluster

00:19:45,970 --> 00:19:53,920
that that you know your programs with

00:19:48,370 --> 00:19:55,570
Chris was a target as for so the this

00:19:53,920 --> 00:20:02,260
does that mean how you how you can scale

00:19:55,570 --> 00:20:03,970
out with with a percolator this I can

00:20:02,260 --> 00:20:05,320
examples of the multi-tenancy of the

00:20:03,970 --> 00:20:07,840
percolate API you're going to find

00:20:05,320 --> 00:20:12,610
multiple indexes I can define aliases

00:20:07,840 --> 00:20:17,650
and percolate your your documents again

00:20:12,610 --> 00:20:19,210
against your registered queries you can

00:20:17,650 --> 00:20:21,430
define routing on top that's what I

00:20:19,210 --> 00:20:23,320
talked about routing obviously you need

00:20:21,430 --> 00:20:29,140
to use it an index time as well because

00:20:23,320 --> 00:20:32,530
what you need to route your queries with

00:20:29,140 --> 00:20:34,300
the same values you will route the pro

00:20:32,530 --> 00:20:38,830
credit request for or if you searching

00:20:34,300 --> 00:20:41,050
your search requests and if you if you

00:20:38,830 --> 00:20:43,000
do routing then effectively the

00:20:41,050 --> 00:20:46,360
percolate values need to go to one short

00:20:43,000 --> 00:20:47,770
an execute their it doesn't need to to

00:20:46,360 --> 00:20:50,110
look at all the queries and this is how

00:20:47,770 --> 00:20:56,640
you can reduce the amount of queries

00:20:50,110 --> 00:20:59,800
being executed during percolation time

00:20:56,640 --> 00:21:03,040
and you know this because it's a linear

00:20:59,800 --> 00:21:06,970
execution if you if you be smart with

00:21:03,040 --> 00:21:09,310
how you how you route what indexes you

00:21:06,970 --> 00:21:11,049
you send a program okay so you can it

00:21:09,310 --> 00:21:13,510
can be released

00:21:11,049 --> 00:21:15,490
you know first operation and not to say

00:21:13,510 --> 00:21:17,049
that you know if you have 20 queries you

00:21:15,490 --> 00:21:19,720
don't need to mean then this is you know

00:21:17,049 --> 00:21:21,850
doesn't matter but let's say you have

00:21:19,720 --> 00:21:25,120
five million queries something in that

00:21:21,850 --> 00:21:26,289
in us those in those numbers that's

00:21:25,120 --> 00:21:30,820
something that you should take an

00:21:26,289 --> 00:21:35,650
account because if executing one is you

00:21:30,820 --> 00:21:37,270
saying some members one executing one

00:21:35,650 --> 00:21:41,289
query on on the on the in memory index

00:21:37,270 --> 00:21:43,570
takes one milliseconds if we have fifty

00:21:41,289 --> 00:21:46,890
million queries it takes 50 million more

00:21:43,570 --> 00:21:46,890
more time than that

00:21:47,220 --> 00:21:51,429
so that's the distribute aspect act

00:21:49,840 --> 00:21:53,610
about that's that's you know how you how

00:21:51,429 --> 00:21:58,000
you can scale scale out with it

00:21:53,610 --> 00:22:00,250
the perkele yes so another aspect I

00:21:58,000 --> 00:22:01,780
talked about is death percolate the

00:22:00,250 --> 00:22:04,630
computer are stored in a special type a

00:22:01,780 --> 00:22:07,630
percolator type it's it's prefixed with

00:22:04,630 --> 00:22:13,929
dots percolate and that's emphasize the

00:22:07,630 --> 00:22:16,809
fact that it's a hidden type and and

00:22:13,929 --> 00:22:19,630
here in edit time means that if you by

00:22:16,809 --> 00:22:21,220
default search because any index can

00:22:19,630 --> 00:22:22,809
contain procreate the queries but can

00:22:21,220 --> 00:22:24,520
also contain normal data your documents

00:22:22,809 --> 00:22:28,600
and normally in if you use the

00:22:24,520 --> 00:22:30,700
percolator then those Procurator

00:22:28,600 --> 00:22:38,010
documents almost sorry

00:22:30,700 --> 00:22:40,870
that's I'm quickly dehydrating here so

00:22:38,010 --> 00:22:42,159
those those those percolator documents

00:22:40,870 --> 00:22:44,740
with our queries in memory eventually

00:22:42,159 --> 00:22:46,120
are not being being taken into cow into

00:22:44,740 --> 00:22:47,500
account in normal search operations

00:22:46,120 --> 00:22:49,000
because usually don't care about that

00:22:47,500 --> 00:22:50,530
like you care about you document where

00:22:49,000 --> 00:22:53,380
you search when percolating you only

00:22:50,530 --> 00:22:56,440
care about the percolator queries that

00:22:53,380 --> 00:22:58,690
are stored in the index so they're not

00:22:56,440 --> 00:23:00,429
returns so it can be surprising it I

00:22:58,690 --> 00:23:02,380
live in X a lot of documents which I

00:23:00,429 --> 00:23:04,150
provide but I'm not seeing them because

00:23:02,380 --> 00:23:06,010
they are hidden away by default if you

00:23:04,150 --> 00:23:09,039
want to see them you need to be specific

00:23:06,010 --> 00:23:11,610
about that and included in the site when

00:23:09,039 --> 00:23:15,100
you search in a search search request

00:23:11,610 --> 00:23:17,710
you know if you want everything also the

00:23:15,100 --> 00:23:18,990
hidden types you can you say type and no

00:23:17,710 --> 00:23:21,340
score all coma

00:23:18,990 --> 00:23:23,230
does percolator and you get all the

00:23:21,340 --> 00:23:24,650
results back but that's justice that

00:23:23,230 --> 00:23:26,690
that let's use the current

00:23:24,650 --> 00:23:29,200
case it's because queries and data can

00:23:26,690 --> 00:23:35,320
coexist in the same index if one if

00:23:29,200 --> 00:23:39,140
that's chosen a protractor also has a a

00:23:35,320 --> 00:23:42,320
civic mapping that prevents the query

00:23:39,140 --> 00:23:44,930
from being indexed into the inverted

00:23:42,320 --> 00:23:46,970
index it is available in the in a in the

00:23:44,930 --> 00:23:49,070
document in the JSON you sent to elastic

00:23:46,970 --> 00:23:52,040
search it remains in the JSON when you

00:23:49,070 --> 00:23:54,770
get back but on the query and all its

00:23:52,040 --> 00:23:55,850
subfields you cannot you you cannot

00:23:54,770 --> 00:23:58,540
search because that doesn't make sense

00:23:55,850 --> 00:24:00,650
to build infrared indices on top of this

00:23:58,540 --> 00:24:02,570
obviously you care about it you change

00:24:00,650 --> 00:24:03,770
the mapping and you know up to you but

00:24:02,570 --> 00:24:06,290
but if what we don't do this because

00:24:03,770 --> 00:24:09,200
it's not it's not needed they they are

00:24:06,290 --> 00:24:12,640
there are queries they are not document

00:24:09,200 --> 00:24:12,640
so that's why we disable that by default

00:24:13,000 --> 00:24:19,700
something else when you set a perk ID

00:24:18,590 --> 00:24:22,490
the query like I said it's just a

00:24:19,700 --> 00:24:24,430
document and the query field and also

00:24:22,490 --> 00:24:27,200
fields in a diskette treated differently

00:24:24,430 --> 00:24:28,880
but you're free to associate any other

00:24:27,200 --> 00:24:34,070
field with it and those tools do get

00:24:28,880 --> 00:24:36,440
indexed so in this case I add a fuel

00:24:34,070 --> 00:24:40,160
organization ID to it - eh - my

00:24:36,440 --> 00:24:41,840
percolate the query those fuels are met

00:24:40,160 --> 00:24:43,460
like I said to get index and there are

00:24:41,840 --> 00:24:45,170
certain features on top of the percolate

00:24:43,460 --> 00:24:49,280
API that can interact with those

00:24:45,170 --> 00:24:51,470
metadata fields in this case I told the

00:24:49,280 --> 00:24:56,210
percolator to percolate apical document

00:24:51,470 --> 00:24:58,730
but only progressive queries that have

00:24:56,210 --> 00:25:01,520
to feel organization ID with this XY set

00:24:58,730 --> 00:25:03,050
value also this can reduce the amount of

00:25:01,520 --> 00:25:05,690
queries being evaluated because in the

00:25:03,050 --> 00:25:07,190
end is a linear process it's very nice

00:25:05,690 --> 00:25:09,830
also if you don't care about other

00:25:07,190 --> 00:25:11,450
queries being evaluated just because you

00:25:09,830 --> 00:25:15,590
don't want I don't know

00:25:11,450 --> 00:25:16,520
organisation ABC to all those queries

00:25:15,590 --> 00:25:20,590
should not run on this particular

00:25:16,520 --> 00:25:20,590
document you can use filtering for that

00:25:22,200 --> 00:25:31,029
percolating is a CPU intensive process

00:25:28,710 --> 00:25:33,820
can take a lot of CPU I mean my

00:25:31,029 --> 00:25:37,840
experience this this this MacBook Air

00:25:33,820 --> 00:25:38,879
goes on fire when I evaluates millions

00:25:37,840 --> 00:25:40,990
of queries on a particular document

00:25:38,879 --> 00:25:46,720
there's no way of stopping them display

00:25:40,990 --> 00:25:48,309
this beast then but yeah so that's the

00:25:46,720 --> 00:25:50,440
important thing to remember so there are

00:25:48,309 --> 00:25:51,730
specific storing strategies you should

00:25:50,440 --> 00:25:52,389
keep in mind when when you see a

00:25:51,730 --> 00:25:54,820
percolator

00:25:52,389 --> 00:25:57,309
like I said locate data and documents

00:25:54,820 --> 00:25:59,200
can can coexist in the same index if the

00:25:57,309 --> 00:26:00,730
number of queries are small that's the

00:25:59,200 --> 00:26:04,690
way to go I mean it doesn't matter I

00:26:00,730 --> 00:26:06,820
mean it's fast but I think my experience

00:26:04,690 --> 00:26:08,590
when you know have growing over a

00:26:06,820 --> 00:26:10,320
hundred thousand two hundred thousand

00:26:08,590 --> 00:26:14,679
depending on your hardware of course

00:26:10,320 --> 00:26:17,110
queries then it will it start to take

00:26:14,679 --> 00:26:19,690
significant resources of the notes

00:26:17,110 --> 00:26:22,570
you're running with so then it's time to

00:26:19,690 --> 00:26:26,889
think about a dedicated percolator index

00:26:22,570 --> 00:26:28,450
where only the queries are in the the up

00:26:26,889 --> 00:26:30,909
side of hits you can have dedicated

00:26:28,450 --> 00:26:35,080
storing configurations for it you can

00:26:30,909 --> 00:26:36,820
even allocate specific notes and make

00:26:35,080 --> 00:26:39,070
sure that those percolator indexes are

00:26:36,820 --> 00:26:42,549
only allocated on those notes so to

00:26:39,070 --> 00:26:44,379
separate the resources being used

00:26:42,549 --> 00:26:47,049
between your normal search and your

00:26:44,379 --> 00:26:49,120
percolating and obviously you can just

00:26:47,049 --> 00:26:52,000
start up a second cluster I mean it's

00:26:49,120 --> 00:26:53,620
also possible when you go with a

00:26:52,000 --> 00:26:55,899
dedicated per Kleenex I haven't written

00:26:53,620 --> 00:26:59,049
it down here but it's important that the

00:26:55,899 --> 00:27:01,779
mapping that is in the regular index is

00:26:59,049 --> 00:27:03,730
also in in a dedicated percolate index

00:27:01,779 --> 00:27:06,820
because when those queries when you

00:27:03,730 --> 00:27:08,230
register a percolator query a lot of

00:27:06,820 --> 00:27:11,139
queries lie on settings in their

00:27:08,230 --> 00:27:12,789
mappings and if those mappings are not

00:27:11,139 --> 00:27:14,980
there it will it will assume a lot of

00:27:12,789 --> 00:27:16,960
defaults and your queries are not parsed

00:27:14,980 --> 00:27:18,100
as you expect them to be parsed so

00:27:16,960 --> 00:27:21,809
that's something to keep in mind when

00:27:18,100 --> 00:27:21,809
going with a dedicated percolator index

00:27:22,500 --> 00:27:25,360
okay

00:27:23,679 --> 00:27:27,750
let's talk about the progressive

00:27:25,360 --> 00:27:27,750
features

00:27:31,889 --> 00:27:39,149
on top of the you know to percolate API

00:27:35,279 --> 00:27:41,580
there's also a specific ape specific API

00:27:39,149 --> 00:27:44,009
used for counting it's called the

00:27:41,580 --> 00:27:45,450
percolate account API and the difference

00:27:44,009 --> 00:27:47,309
is that instead of inner scope regulator

00:27:45,450 --> 00:27:49,259
you to percolate underscore per ablators

00:27:47,309 --> 00:27:51,990
let's count and it you will just tell

00:27:49,259 --> 00:27:54,090
you how many percolator queries have

00:27:51,990 --> 00:27:55,919
matched in the case you only care about

00:27:54,090 --> 00:27:57,990
that obviously use this API evil you

00:27:55,919 --> 00:28:00,360
know obviously do things that you thank

00:27:57,990 --> 00:28:01,409
you that you don't need I mean it what

00:28:00,360 --> 00:28:09,659
poor friend doing thing she don't need

00:28:01,409 --> 00:28:11,279
to in the end I you showed that you can

00:28:09,659 --> 00:28:14,159
filter by a filter but you can also

00:28:11,279 --> 00:28:16,470
filter by query I can on the metadata of

00:28:14,159 --> 00:28:22,440
the author of the of the percolator

00:28:16,470 --> 00:28:24,869
query and yeah the the only editing on

00:28:22,440 --> 00:28:27,659
top of up top of the stuff using filter

00:28:24,869 --> 00:28:30,720
is that queries day they can be scored

00:28:27,659 --> 00:28:32,429
if he if you want to so that allows that

00:28:30,720 --> 00:28:36,139
that allows me to go to the next slide

00:28:32,429 --> 00:28:38,820
because there is some sorting scoring

00:28:36,139 --> 00:28:43,710
mechanism in the percolator api it's

00:28:38,820 --> 00:28:49,499
limited oh but it's there and it allows

00:28:43,710 --> 00:28:51,690
you to score the queries based on its

00:28:49,499 --> 00:28:54,299
method you define a query in this case

00:28:51,690 --> 00:28:59,009
click ID maybe not it's like a filter

00:28:54,299 --> 00:29:01,259
but let's say you just do another query

00:28:59,009 --> 00:29:03,659
which I'm going to show you here let's

00:29:01,259 --> 00:29:05,700
let's do something funky let's use the

00:29:03,659 --> 00:29:10,409
functions functions Co query which is

00:29:05,700 --> 00:29:15,869
really really cool and in this case what

00:29:10,409 --> 00:29:20,820
is functions really does is giving a

00:29:15,869 --> 00:29:25,610
relevance on owner on the only create

00:29:20,820 --> 00:29:29,190
date of a of a cooling being registered

00:29:25,610 --> 00:29:31,970
and in this case we have in this case we

00:29:29,190 --> 00:29:35,580
have metadata in the in a query called

00:29:31,970 --> 00:29:39,980
create and we want

00:29:35,580 --> 00:29:42,710
recent queries to be shown before the

00:29:39,980 --> 00:29:44,690
less recent queries

00:29:42,710 --> 00:29:48,500
and we do this in exponential skill and

00:29:44,690 --> 00:29:51,830
that starts from today and three years

00:29:48,500 --> 00:29:54,320
ago which is roughly 1,000 days and of

00:29:51,830 --> 00:29:56,799
course the queries of mean the queries

00:29:54,320 --> 00:29:59,929
of last month will end up on the top and

00:29:56,799 --> 00:30:02,899
that's nice when wait am i mean because

00:29:59,929 --> 00:30:08,330
the percolator api can't skill it

00:30:02,899 --> 00:30:09,710
doesn't it's I mean you there's no time

00:30:08,330 --> 00:30:11,360
to evaluate all those queries I mean if

00:30:09,710 --> 00:30:13,250
you are going to show something if

00:30:11,360 --> 00:30:15,289
there's not a machine consuming all the

00:30:13,250 --> 00:30:17,149
matching queries but a human located it

00:30:15,289 --> 00:30:18,950
it might be useful to have some some

00:30:17,149 --> 00:30:22,070
kind of ordering sorting on it then you

00:30:18,950 --> 00:30:27,080
can do it firefighter function score

00:30:22,070 --> 00:30:32,080
query and this is why why it's that's

00:30:27,080 --> 00:30:37,070
useful a normal query wouldn't match

00:30:32,080 --> 00:30:39,380
wouldn't match swell because in in in a

00:30:37,070 --> 00:30:41,539
security and of seen there's tf-idf when

00:30:39,380 --> 00:30:43,820
you have queries and documents it's fine

00:30:41,539 --> 00:30:45,440
but in a percolator case we and what

00:30:43,820 --> 00:30:50,330
this one documents is in is in memory

00:30:45,440 --> 00:30:51,830
index obviously the the text property

00:30:50,330 --> 00:30:55,460
steve idea there they don't make sense

00:30:51,830 --> 00:30:57,260
then that much TF may make sense but the

00:30:55,460 --> 00:31:03,260
IDF doesn't it definitely doesn't make

00:30:57,260 --> 00:31:09,350
sense when you ask you this the the

00:31:03,260 --> 00:31:13,010
matches also include score so that's you

00:31:09,350 --> 00:31:14,990
know make sense you can even do

00:31:13,010 --> 00:31:19,130
applications on top of the metadata of

00:31:14,990 --> 00:31:22,990
the queries in this case what what

00:31:19,130 --> 00:31:25,730
happens here we create a terms education

00:31:22,990 --> 00:31:27,590
on the click ID so it will show the top

00:31:25,730 --> 00:31:32,570
the top click IDs of all the queries

00:31:27,590 --> 00:31:34,789
that have matched it's for the terms

00:31:32,570 --> 00:31:36,919
aggregation does showing top terms based

00:31:34,789 --> 00:31:38,679
on on documents as match in this case

00:31:36,919 --> 00:31:42,200
documents our queries

00:31:38,679 --> 00:31:46,340
there's also highlighting support in

00:31:42,200 --> 00:31:50,720
this case we are we're registering two

00:31:46,340 --> 00:31:52,220
queries and I made a mistake here it

00:31:50,720 --> 00:31:54,399
should be does percolator instead of

00:31:52,220 --> 00:31:58,130
underscore percolator

00:31:54,399 --> 00:32:00,230
silly mistake and in this case we we

00:31:58,130 --> 00:32:04,039
have brown fox a lazy dog as to

00:32:00,230 --> 00:32:06,320
percolate the queries when we percolate

00:32:04,039 --> 00:32:08,510
the document with has a body field

00:32:06,320 --> 00:32:10,730
called quick brown fox jumps over the

00:32:08,510 --> 00:32:14,450
lazy dog and we tell the program to

00:32:10,730 --> 00:32:21,500
highlight on the body field it will

00:32:14,450 --> 00:32:23,090
highlight each match what highlight each

00:32:21,500 --> 00:32:26,059
each match so it will tell you how the

00:32:23,090 --> 00:32:28,870
documents or actually understand how the

00:32:26,059 --> 00:32:31,399
query will highlight the documents and

00:32:28,870 --> 00:32:32,929
in the first case it's it will highlight

00:32:31,399 --> 00:32:36,820
brown fox in the second case it will

00:32:32,929 --> 00:32:36,820
highlight the lazy dog

00:32:37,270 --> 00:32:43,850
and finally there's also API called a

00:32:41,570 --> 00:32:46,190
multi percolate API which allows you to

00:32:43,850 --> 00:32:48,830
combine multiple percolate requests into

00:32:46,190 --> 00:32:50,390
a single API call and double read you'd

00:32:48,830 --> 00:32:54,700
use the network overhead you have to a

00:32:50,390 --> 00:32:57,890
cluster so instead of is invoking

00:32:54,700 --> 00:33:00,470
hundreds of requests you can invoke one

00:32:57,890 --> 00:33:07,029
chromecast with one big body effectively

00:33:00,470 --> 00:33:13,909
and the way you send a request to the

00:33:07,029 --> 00:33:17,559
multi percolate endpoints is in in in

00:33:13,909 --> 00:33:21,100
such a way that each each line each line

00:33:17,559 --> 00:33:22,909
in the in the request body tells

00:33:21,100 --> 00:33:25,159
effectively instruction this case

00:33:22,909 --> 00:33:28,940
percolates and in the next line contains

00:33:25,159 --> 00:33:31,100
the document want to percolate the

00:33:28,940 --> 00:33:33,020
second the third line tells to procreate

00:33:31,100 --> 00:33:34,820
in existing documents so that you don't

00:33:33,020 --> 00:33:37,340
need to specify the body again in the

00:33:34,820 --> 00:33:38,480
next line it's just an empty bracket but

00:33:37,340 --> 00:33:40,760
should be line separated all the

00:33:38,480 --> 00:33:44,600
commands and it's just one one call to

00:33:40,760 --> 00:33:45,799
elasticsearch and this is it this is

00:33:44,600 --> 00:33:48,799
what I have talked about a percolator

00:33:45,799 --> 00:33:51,130
and its features and there is time for

00:33:48,799 --> 00:33:51,130
questions

00:33:58,539 --> 00:34:03,260
Thank You Martine for your talk if you

00:34:01,610 --> 00:34:07,270
have any questions please wait for the

00:34:03,260 --> 00:34:07,270
microphone raise your hand

00:34:11,379 --> 00:34:15,800
hi thank you

00:34:12,980 --> 00:34:18,200
how does replication of the percolate

00:34:15,800 --> 00:34:22,070
queries work does it follow the indexes

00:34:18,200 --> 00:34:25,310
themselves or how does replication work

00:34:22,070 --> 00:34:27,679
with so if one if one node fails for

00:34:25,310 --> 00:34:30,590
instance it's not those the percolate

00:34:27,679 --> 00:34:34,369
queries are held on another node yes a

00:34:30,590 --> 00:34:36,710
replica node yes so what a moment and

00:34:34,369 --> 00:34:38,750
and and an initial question Enterprise

00:34:36,710 --> 00:34:43,609
not used for percolator but using X

00:34:38,750 --> 00:34:46,909
requests this returns its indexed on

00:34:43,609 --> 00:34:48,649
both copies so so then another could say

00:34:46,909 --> 00:34:49,790
we go down and you know your your

00:34:48,649 --> 00:34:51,820
percolate the query still in your honor

00:34:49,790 --> 00:34:57,230
and your another available on that chart

00:34:51,820 --> 00:35:02,510
and yeah let's if it doesn't answer your

00:34:57,230 --> 00:35:06,650
question question okay okay I don't see

00:35:02,510 --> 00:35:11,630
anything on the lights so can you use a

00:35:06,650 --> 00:35:13,820
query to do a multi percolate so query

00:35:11,630 --> 00:35:17,869
for documents and do percolate on those

00:35:13,820 --> 00:35:20,180
documents yes yeah it's it's use the

00:35:17,869 --> 00:35:23,320
document right and you you can use query

00:35:20,180 --> 00:35:25,640
for it as well and a Search API okay so

00:35:23,320 --> 00:35:30,290
using a query to produce a list of

00:35:25,640 --> 00:35:32,420
documents in peril a dos I mean I didn't

00:35:30,290 --> 00:35:34,940
fill the last part so basically if I do

00:35:32,420 --> 00:35:36,560
a query for say every document indexed

00:35:34,940 --> 00:35:39,050
in the last five minutes and I want to

00:35:36,560 --> 00:35:40,490
percolate those with the work yes yes I

00:35:39,050 --> 00:35:42,740
mean sorry

00:35:40,490 --> 00:35:44,150
yeah the query part or the filter part

00:35:42,740 --> 00:35:45,910
you can make sure that you only Avella

00:35:44,150 --> 00:35:49,369
bite those documents in a time frame

00:35:45,910 --> 00:35:51,109
only your only the queries are only the

00:35:49,369 --> 00:35:53,320
queries are being evaluated in a time

00:35:51,109 --> 00:35:53,320
frame

00:35:58,080 --> 00:36:05,970
oh no no no okay then I'd misunderstood

00:36:04,410 --> 00:36:08,400
the questions yeah so the reason I was

00:36:05,970 --> 00:36:10,860
it was because you can percolate on a

00:36:08,400 --> 00:36:12,450
document ID so I was like okay what if I

00:36:10,860 --> 00:36:17,370
use the query to produce multiple

00:36:12,450 --> 00:36:19,050
document IDs no that's that's not okay

00:36:17,370 --> 00:36:28,950
no not anything might be icon right

00:36:19,050 --> 00:36:30,990
thank you we are an advertisement

00:36:28,950 --> 00:36:32,790
company and we have lots of keywords we

00:36:30,990 --> 00:36:35,280
have to match you know brands against

00:36:32,790 --> 00:36:38,730
those keywords is there a way like as

00:36:35,280 --> 00:36:41,670
data is indexed and if we percolate let

00:36:38,730 --> 00:36:45,720
against a brand like adidas or like to

00:36:41,670 --> 00:36:46,760
somehow get the results streamed like

00:36:45,720 --> 00:36:50,010
you know

00:36:46,760 --> 00:36:51,630
so you percolate against a query like

00:36:50,010 --> 00:36:54,360
you know all the cubes which have brand

00:36:51,630 --> 00:36:56,250
adidas but as indexing happens is there

00:36:54,360 --> 00:36:58,950
a way to actually get that by post or

00:36:56,250 --> 00:37:00,510
you have to do always pulling you have

00:36:58,950 --> 00:37:02,490
all you have to check it's nothing it's

00:37:00,510 --> 00:37:04,500
not pushed now now so if you want to

00:37:02,490 --> 00:37:07,080
know if something matches in assembly

00:37:04,500 --> 00:37:09,090
you need to invoke an API call so I did

00:37:07,080 --> 00:37:12,720
I have to like a percolate call and then

00:37:09,090 --> 00:37:15,690
again for each of my queries again query

00:37:12,720 --> 00:37:19,380
yeah if you want to do it after each in

00:37:15,690 --> 00:37:22,050
next call you should invoke the the

00:37:19,380 --> 00:37:24,390
percolate API okay so in and you know

00:37:22,050 --> 00:37:27,120
you can use the index response in order

00:37:24,390 --> 00:37:28,890
to to basically construct the percolate

00:37:27,120 --> 00:37:31,590
next prototype I call it should be cheap

00:37:28,890 --> 00:37:34,520
because you only have to find the ID

00:37:31,590 --> 00:37:34,520
okay

00:37:51,269 --> 00:37:55,089
so just a little follow-up on that

00:37:53,289 --> 00:37:57,369
question is there a reason why you can't

00:37:55,089 --> 00:37:59,049
just set a flag to say I want to index

00:37:57,369 --> 00:38:00,219
this but in the response I'd also like

00:37:59,049 --> 00:38:02,259
the the percolate

00:38:00,219 --> 00:38:05,400
I'd like you to percolate it well why do

00:38:02,259 --> 00:38:05,400
I need to make the second call

00:38:05,409 --> 00:38:11,140
II mean as as are you talking about part

00:38:08,109 --> 00:38:12,849
of the yeah I mean you mean as part of

00:38:11,140 --> 00:38:15,099
the index request is it a conscious

00:38:12,849 --> 00:38:16,749
design decision that that it's a concert

00:38:15,099 --> 00:38:19,900
design decision yes

00:38:16,749 --> 00:38:22,869
so because the percolator by itself is a

00:38:19,900 --> 00:38:26,140
distributed operation I mean it feels

00:38:22,869 --> 00:38:30,579
wrong to forcefully bind those two so

00:38:26,140 --> 00:38:34,089
let's find a post call I mean yeah so I

00:38:30,579 --> 00:38:35,439
mean but it it's as you know the pain is

00:38:34,089 --> 00:38:40,749
is less as little as possible

00:38:35,439 --> 00:38:43,359
yeah time is up so thank you very much

00:38:40,749 --> 00:38:45,789
for your talk Martine and one question

00:38:43,359 --> 00:38:50,380
if you guys are using Ferg later I'm how

00:38:45,789 --> 00:38:51,459
many not so many okay okay I should have

00:38:50,380 --> 00:38:53,609
asked it in the beginning but I wanted

00:38:51,459 --> 00:38:53,609
to know

00:39:00,390 --> 00:39:02,450

YouTube URL: https://www.youtube.com/watch?v=ETxJO2FQ_jw


