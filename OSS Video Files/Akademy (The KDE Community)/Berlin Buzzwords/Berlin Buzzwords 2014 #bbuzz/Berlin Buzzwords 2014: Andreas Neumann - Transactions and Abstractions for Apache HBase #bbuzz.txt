Title: Berlin Buzzwords 2014: Andreas Neumann - Transactions and Abstractions for Apache HBase #bbuzz
Publication date: 2014-05-28
Playlist: Berlin Buzzwords 2014 #bbuzz
Description: 
	When Apache Hadoop was first introduced to the Open Source, it was focused on implementing Google's Map/Reduce, a framework for batch processing of very large files in a distributed system. Built for running on large cluster of commodity hardware, Hadoop also included a cluster resource manager to divide the capacity of the cluster between the various Map/Reduce jobs that can run at a given time.  

A Hadoop cluster, however, is not always fully utilized, and idle resources would best be used for other compute-intensive tasks like real-time stream processing, message passing, or graph algorithms. Unfortunately, the cluster resource manager was specialized in Map/Reduce execution and did not allow other types of workloads.  

This situation changes with Apache Hadoop 2.0 and its resource manager, YARN, which is decoupled from the Map/Reduce execution engine. It allows running arbitrary workloads on a cluster, as long as they are built against YARN's application manager interface: YARN manages the cluster's resources as a set of "containers". Each application can obtain containers from YARN and is then free to use them for any type of computation. Hence different types of distributed applications can share a single cluster. This allows for more innovation, agility, and better hardware utilization. 

Read more:
https://2014.berlinbuzzwords.de/session/harnessing-power-yarn-apache-twill

About Andreas Neumann:
https://2014.berlinbuzzwords.de/user/279/event/1

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,709 --> 00:00:13,939
hello when the word no sequel became

00:00:10,849 --> 00:00:18,410
popular a few years ago it was a synonym

00:00:13,939 --> 00:00:22,550
for scalable efficient and most of all

00:00:18,410 --> 00:00:24,490
cheap distributed storage how could it

00:00:22,550 --> 00:00:27,619
be cheap how could it be cheaper than

00:00:24,490 --> 00:00:30,410
conventional relational databases by

00:00:27,619 --> 00:00:33,800
giving up asset guarantees of sequel

00:00:30,410 --> 00:00:36,129
transactions hence the word no sequel in

00:00:33,800 --> 00:00:38,539
the meantime we found out that

00:00:36,129 --> 00:00:41,059
transactions are an invaluable tool for

00:00:38,539 --> 00:00:42,920
developers they make our life so much

00:00:41,059 --> 00:00:46,100
easier when we try to build reliable

00:00:42,920 --> 00:00:49,089
data applications and as a consequence

00:00:46,100 --> 00:00:53,949
we are seeing a re-emergence of

00:00:49,089 --> 00:00:57,379
transactions in the no sequel world and

00:00:53,949 --> 00:01:00,170
nowadays the word no sequel doesn't mean

00:00:57,379 --> 00:01:03,889
no sequel anymore it means not only

00:01:00,170 --> 00:01:06,560
sequel I am andreas Norman I work for

00:01:03,889 --> 00:01:09,320
continuity and I will show you how we

00:01:06,560 --> 00:01:14,140
implemented transactions over one of

00:01:09,320 --> 00:01:16,640
these no sequel databases namely HBase

00:01:14,140 --> 00:01:19,910
I'm going to start with a quick

00:01:16,640 --> 00:01:22,730
motivation why do we need this I will

00:01:19,910 --> 00:01:26,660
show you how we implemented it and then

00:01:22,730 --> 00:01:28,730
I'll quickly do some abstractions future

00:01:26,660 --> 00:01:31,220
and if there's time for questions

00:01:28,730 --> 00:01:37,310
without eating into your lunch time i'll

00:01:31,220 --> 00:01:39,950
be happy to do that ok who are we my

00:01:37,310 --> 00:01:43,720
company is continuity it's this little

00:01:39,950 --> 00:01:46,670
little dark blue rectangle down here and

00:01:43,720 --> 00:01:50,090
what we do is we provide simple access

00:01:46,670 --> 00:01:52,370
to powerful technology what does that

00:01:50,090 --> 00:01:54,350
mean we have built an application server

00:01:52,370 --> 00:01:58,370
for big data it's called the continuity

00:01:54,350 --> 00:02:02,300
reactor and that makes it much easier to

00:01:58,370 --> 00:02:04,540
build big data applications then if you

00:02:02,300 --> 00:02:07,190
program directly over Hadoop and HBase

00:02:04,540 --> 00:02:09,950
what do you do in a big data application

00:02:07,190 --> 00:02:13,010
you do mainly for things you collect

00:02:09,950 --> 00:02:14,510
data you process it you want to store

00:02:13,010 --> 00:02:15,999
the results of the processing and you

00:02:14,510 --> 00:02:19,040
want to make it available for querying

00:02:15,999 --> 00:02:21,260
here in this talk I'm going to focus on

00:02:19,040 --> 00:02:26,870
one particular type of processing which

00:02:21,260 --> 00:02:29,379
is real time stream processing what is

00:02:26,870 --> 00:02:33,230
real time stream processing here we

00:02:29,379 --> 00:02:36,079
operate over real time streams of events

00:02:33,230 --> 00:02:38,840
and a stream processor typically

00:02:36,079 --> 00:02:42,730
consists of a bunch of agents servers or

00:02:38,840 --> 00:02:45,709
computers and each of these processes

00:02:42,730 --> 00:02:48,829
has an input queue that it reads events

00:02:45,709 --> 00:02:50,480
from and then it does some processing it

00:02:48,829 --> 00:02:53,150
may store some data it may read some

00:02:50,480 --> 00:02:55,129
data and then it emits new events on its

00:02:53,150 --> 00:02:58,700
output queues for the downstream

00:02:55,129 --> 00:03:01,250
processing of other other agents so it

00:02:58,700 --> 00:03:04,280
looks pretty much like that in in in the

00:03:01,250 --> 00:03:06,290
reactor a real time processing system is

00:03:04,280 --> 00:03:08,769
called the flow and every individual

00:03:06,290 --> 00:03:11,150
agent there is called the flow that and

00:03:08,769 --> 00:03:15,109
it's a very simple programming

00:03:11,150 --> 00:03:18,859
abstraction now this HP is table down

00:03:15,109 --> 00:03:21,739
here that might be shared with other

00:03:18,859 --> 00:03:23,569
stream processing applications so we

00:03:21,739 --> 00:03:25,729
might have another flow let that also

00:03:23,569 --> 00:03:30,859
writes to that table and this is all

00:03:25,729 --> 00:03:33,530
great until to flow let's try to write

00:03:30,859 --> 00:03:36,829
to the same cell at the same time and

00:03:33,530 --> 00:03:38,419
what do we get well we can we can flip a

00:03:36,829 --> 00:03:40,519
coin right we don't know who wins which

00:03:38,419 --> 00:03:42,769
which ride will prevail we're definitely

00:03:40,519 --> 00:03:48,409
going to lose one of the rights and what

00:03:42,769 --> 00:03:50,629
happens now is maybe this guy loses so

00:03:48,409 --> 00:03:53,599
his his right doesn't go through cuz

00:03:50,629 --> 00:03:56,750
gets overwritten by this one but he has

00:03:53,599 --> 00:03:58,489
admitted his output to it is output

00:03:56,750 --> 00:04:00,889
queues so now it's in an inconsistent

00:03:58,489 --> 00:04:02,419
State we have an event that looks like

00:04:00,889 --> 00:04:04,129
it's been processed but the effect of

00:04:02,419 --> 00:04:05,780
processing isn't there right and so now

00:04:04,129 --> 00:04:08,500
we can't rely on the behavior of our

00:04:05,780 --> 00:04:11,930
application anymore what's the solution

00:04:08,500 --> 00:04:14,269
many years ago decades ago that's what

00:04:11,930 --> 00:04:16,940
transactions were invented for in

00:04:14,269 --> 00:04:20,269
relational databases transactions

00:04:16,940 --> 00:04:22,729
protect us from that and our idea was

00:04:20,269 --> 00:04:24,530
that if we think about what if Lola does

00:04:22,729 --> 00:04:26,960
it it's fairly simple read an input

00:04:24,530 --> 00:04:30,529
event do some processing store some data

00:04:26,960 --> 00:04:32,810
amid some output event and so we

00:04:30,529 --> 00:04:35,600
implemented a way of doing transactions

00:04:32,810 --> 00:04:39,260
that encapsulate what we see in blue

00:04:35,600 --> 00:04:43,130
here in the transaction and we

00:04:39,260 --> 00:04:48,950
implemented that over HBase just a quick

00:04:43,130 --> 00:04:51,020
reminder who knows what acid means okay

00:04:48,950 --> 00:04:52,970
it's written there so what does it give

00:04:51,020 --> 00:04:54,860
us it gives us atomicity whatever we do

00:04:52,970 --> 00:04:58,100
in the transaction becomes visible at

00:04:54,860 --> 00:05:01,370
once we never see partial rights gives

00:04:58,100 --> 00:05:03,620
us consistency once it's written it's

00:05:01,370 --> 00:05:06,380
not going to change we're never going to

00:05:03,620 --> 00:05:09,830
see something like flickering we're not

00:05:06,380 --> 00:05:12,260
it gives us isolation isolation means

00:05:09,830 --> 00:05:14,210
we're never going to see rights that

00:05:12,260 --> 00:05:15,860
haven't been committed all right so this

00:05:14,210 --> 00:05:17,620
is also called dirty reads and they can

00:05:15,860 --> 00:05:20,810
be a pain when you write applications

00:05:17,620 --> 00:05:22,520
and they give us durability once we've

00:05:20,810 --> 00:05:26,780
written something it's guaranteed that

00:05:22,520 --> 00:05:28,490
we will never lose it okay now this is

00:05:26,780 --> 00:05:30,470
what we wanted to implement over HBase

00:05:28,490 --> 00:05:33,560
what is H place who knows what H places

00:05:30,470 --> 00:05:36,650
Oh everybody then I can skip this thread

00:05:33,560 --> 00:05:40,100
can skip this but very quick quickly

00:05:36,650 --> 00:05:42,410
it's a distributed columnar store it has

00:05:40,100 --> 00:05:46,760
named tables so you can have many tables

00:05:42,410 --> 00:05:49,490
and each table is essentially a mapping

00:05:46,760 --> 00:05:53,450
from rocky column key and timestamp

00:05:49,490 --> 00:05:55,910
that's a composite key to a value and

00:05:53,450 --> 00:05:57,830
how does it achieve its massive scale it

00:05:55,910 --> 00:06:00,289
partitions that key space into regions

00:05:57,830 --> 00:06:02,660
and each region is served autonomously

00:06:00,289 --> 00:06:03,950
by a regent server and these region

00:06:02,660 --> 00:06:05,750
servers don't talk to each other and

00:06:03,950 --> 00:06:07,250
that's why all the operations are

00:06:05,750 --> 00:06:11,200
self-contained and that's why they are

00:06:07,250 --> 00:06:14,000
very efficient now thinking about acid

00:06:11,200 --> 00:06:17,690
what does HBase give us does it give us

00:06:14,000 --> 00:06:20,060
any of the acid properties it does give

00:06:17,690 --> 00:06:23,210
us durability it writes everything to

00:06:20,060 --> 00:06:26,180
HDFS we know data is durable there it

00:06:23,210 --> 00:06:28,160
also does give us consistency but does

00:06:26,180 --> 00:06:31,580
it give us atomicity does it give us

00:06:28,160 --> 00:06:35,360
isolation no it doesn't it gives us a

00:06:31,580 --> 00:06:38,479
little bit of that so an operation on a

00:06:35,360 --> 00:06:41,229
single cell of the table is performed in

00:06:38,479 --> 00:06:45,229
an atomic way that's what HBase gives us

00:06:41,229 --> 00:06:46,990
it even allows us if we stay within the

00:06:45,229 --> 00:06:49,550
bounds of one region

00:06:46,990 --> 00:06:53,599
it allows us to perform a batch of

00:06:49,550 --> 00:06:56,319
operations within that regions region as

00:06:53,599 --> 00:07:01,039
a as an atomic operation an atomic veg

00:06:56,319 --> 00:07:03,289
so that's good unfortunately as a client

00:07:01,039 --> 00:07:04,370
I don't know what the regions are so I

00:07:03,289 --> 00:07:06,740
don't I don't even know whether my

00:07:04,370 --> 00:07:10,069
rights remains within one region or not

00:07:06,740 --> 00:07:11,569
so it doesn't really help me a lot what

00:07:10,069 --> 00:07:16,279
doesn't it what it what it doesn't give

00:07:11,569 --> 00:07:20,180
us is atomicity across regions atomicity

00:07:16,279 --> 00:07:23,409
across multiple tables or atomicity

00:07:20,180 --> 00:07:25,819
across multiple RPC calls multiple

00:07:23,409 --> 00:07:29,060
distinct operations we don't get that

00:07:25,819 --> 00:07:32,000
from HBase but in a real time stream

00:07:29,060 --> 00:07:34,699
processing environment we need that so

00:07:32,000 --> 00:07:40,370
we implemented it how did we implement

00:07:34,699 --> 00:07:42,949
it so we're using a transaction style

00:07:40,370 --> 00:07:45,860
that was first introduced under the name

00:07:42,949 --> 00:07:49,669
of Omid om ID and I don't even remember

00:07:45,860 --> 00:07:51,229
what it means and it has a flavor of

00:07:49,669 --> 00:07:56,779
isolation that's called snapshot

00:07:51,229 --> 00:08:00,379
isolation more precisely it uses multi

00:07:56,779 --> 00:08:03,319
version concurrency control to implement

00:08:00,379 --> 00:08:05,139
the isolation so we've seen that in

00:08:03,319 --> 00:08:08,629
HBase every cell has multiple values

00:08:05,139 --> 00:08:14,659
right the key space is row by column by

00:08:08,629 --> 00:08:17,990
time stem so we can use that timestamp

00:08:14,659 --> 00:08:19,669
we can hijack that we take that away

00:08:17,990 --> 00:08:21,349
from the application you don't get

00:08:19,669 --> 00:08:23,000
control over the timestamp anymore in

00:08:21,349 --> 00:08:26,149
exchange we give you transactions and

00:08:23,000 --> 00:08:28,129
now we generate transaction IDs that are

00:08:26,149 --> 00:08:31,219
timestamps and they'll be monotonically

00:08:28,129 --> 00:08:33,079
increasing and we use that transaction

00:08:31,219 --> 00:08:35,779
ideas the timestamp for all the rights

00:08:33,079 --> 00:08:37,820
that happen in the transaction and now

00:08:35,779 --> 00:08:41,060
the nice thing is that we know a

00:08:37,820 --> 00:08:43,459
transaction that's not committed all its

00:08:41,060 --> 00:08:46,550
rights have the same time stem and HBase

00:08:43,459 --> 00:08:48,980
allows us to exclude using a filter to

00:08:46,550 --> 00:08:51,589
exclude a particular version from reads

00:08:48,980 --> 00:08:57,220
and so we can very easily implement

00:08:51,589 --> 00:08:59,000
isolation in order to implement

00:08:57,220 --> 00:09:03,650
consistency

00:08:59,000 --> 00:09:06,740
to prevent multiple multiple clients

00:09:03,650 --> 00:09:09,890
from overriding each other's values we

00:09:06,740 --> 00:09:12,710
do not do locking like databases to

00:09:09,890 --> 00:09:14,420
right they lock somebody else locks you

00:09:12,710 --> 00:09:17,240
end up with a deadlock that's not what

00:09:14,420 --> 00:09:20,810
we want so we use optimistic concurrency

00:09:17,240 --> 00:09:23,120
control and why can we do that we know

00:09:20,810 --> 00:09:26,360
that two different transactions will use

00:09:23,120 --> 00:09:28,490
a different time stamp which means their

00:09:26,360 --> 00:09:30,490
rights will not conflict HBase will

00:09:28,490 --> 00:09:35,360
allow these rights to happen

00:09:30,490 --> 00:09:38,300
concurrently now when a transaction gets

00:09:35,360 --> 00:09:41,360
committed we need to check whether this

00:09:38,300 --> 00:09:43,100
transaction had a conflict with another

00:09:41,360 --> 00:09:44,600
transaction that happened at the same

00:09:43,100 --> 00:09:47,720
time another transaction that was

00:09:44,600 --> 00:09:50,030
overlapping in time and in that case we

00:09:47,720 --> 00:09:51,470
have to roll back the transaction that's

00:09:50,030 --> 00:09:54,650
what's known as optimistic concurrency

00:09:51,470 --> 00:09:58,250
control right so this is a right that

00:09:54,650 --> 00:10:00,620
would have been blocked by a lock if we

00:09:58,250 --> 00:10:01,940
were in a relational database right and

00:10:00,620 --> 00:10:04,339
this is a right that we let happen

00:10:01,940 --> 00:10:07,070
because we don't want anybody to wait in

00:10:04,339 --> 00:10:08,630
our distributed system all right so at

00:10:07,070 --> 00:10:11,030
the time of commits we need to detect

00:10:08,630 --> 00:10:13,130
that that happened and whoever comes

00:10:11,030 --> 00:10:18,860
later with his commit will be rolled

00:10:13,130 --> 00:10:21,470
back what's the advantage of this the

00:10:18,860 --> 00:10:25,160
advantage is we don't need to lock

00:10:21,470 --> 00:10:28,730
locking has a cost because when I lock a

00:10:25,160 --> 00:10:31,370
row of a table anybody else who wants to

00:10:28,730 --> 00:10:33,410
use that row will have to wait all right

00:10:31,370 --> 00:10:36,260
then what what does that do in the end a

00:10:33,410 --> 00:10:37,880
lot of my processes in my cluster aren't

00:10:36,260 --> 00:10:39,920
going to be idle waiting for a lock and

00:10:37,880 --> 00:10:43,310
I'm going to I'm not going to get good

00:10:39,920 --> 00:10:48,350
utilization of my cluster so avoiding

00:10:43,310 --> 00:10:50,330
the cost of locking is good we also by

00:10:48,350 --> 00:10:53,089
avoiding locking we also avoid that

00:10:50,330 --> 00:10:55,880
locks deadlox can never happen now of

00:10:53,089 --> 00:10:59,060
course there's a cost there's a cost of

00:10:55,880 --> 00:11:01,820
conflict detection and in the case that

00:10:59,060 --> 00:11:06,620
there's a conflict there is a cost of

00:11:01,820 --> 00:11:09,830
rollback this cost is higher than in a

00:11:06,620 --> 00:11:10,680
traditional database now why did we

00:11:09,830 --> 00:11:13,470
choose

00:11:10,680 --> 00:11:16,560
optimistic concurrency control anyway we

00:11:13,470 --> 00:11:19,140
chose it because if conflicts are rare

00:11:16,560 --> 00:11:21,300
if they don't happen often then

00:11:19,140 --> 00:11:22,920
optimistic concurrency control costs

00:11:21,300 --> 00:11:26,580
almost nothing the price is almost

00:11:22,920 --> 00:11:29,130
nothing and if you think about how you

00:11:26,580 --> 00:11:31,680
write a distributed application you're

00:11:29,130 --> 00:11:32,910
going to partition the work into buckets

00:11:31,680 --> 00:11:36,300
and you're going to send that two

00:11:32,910 --> 00:11:39,149
different processes and if you do that

00:11:36,300 --> 00:11:40,800
partitioning in a smart way you can you

00:11:39,149 --> 00:11:43,110
can do it in a way that you never get

00:11:40,800 --> 00:11:45,480
conflicts because you partition your key

00:11:43,110 --> 00:11:50,880
space and you partition your work in

00:11:45,480 --> 00:11:55,350
that same way all right so in in our

00:11:50,880 --> 00:11:59,279
case this was the optimal choice now how

00:11:55,350 --> 00:12:03,000
does it work in practice so we have the

00:11:59,279 --> 00:12:05,370
HBase database here it consists of many

00:12:03,000 --> 00:12:07,260
many regions servers and we have a

00:12:05,370 --> 00:12:09,930
client who wants to use HBase all rights

00:12:07,260 --> 00:12:11,580
now in order to get transactions the

00:12:09,930 --> 00:12:14,070
client needs to communicate with a

00:12:11,580 --> 00:12:15,779
transaction manager I'm going to go into

00:12:14,070 --> 00:12:17,880
more detail about transaction manager

00:12:15,779 --> 00:12:20,550
but this is an extra agent that's now

00:12:17,880 --> 00:12:23,040
running in your cluster and it manages

00:12:20,550 --> 00:12:26,790
maintains the state of all currently

00:12:23,040 --> 00:12:28,290
ongoing transactions once it has

00:12:26,790 --> 00:12:29,940
obtained the transaction from the

00:12:28,290 --> 00:12:33,120
transaction manager it can use that to

00:12:29,940 --> 00:12:36,060
write to hbase so we have an extra

00:12:33,120 --> 00:12:39,450
variable in the game here the

00:12:36,060 --> 00:12:42,570
transaction manager in order to avoid

00:12:39,450 --> 00:12:45,360
that if it crashes system becomes

00:12:42,570 --> 00:12:47,700
inconsistent or we would lose all states

00:12:45,360 --> 00:12:49,770
we have two of those and they do a

00:12:47,700 --> 00:12:53,490
leader election using zookeeper that's

00:12:49,770 --> 00:12:55,860
pretty much standard nowadays but let's

00:12:53,490 --> 00:12:58,529
take a closer look at how a transaction

00:12:55,860 --> 00:13:01,290
actually happens so the lifecycle of a

00:12:58,529 --> 00:13:03,089
transaction is client wants to start a

00:13:01,290 --> 00:13:05,010
transaction so it makes a call to the

00:13:03,089 --> 00:13:07,290
transaction manager transaction manager

00:13:05,010 --> 00:13:09,510
returns a transaction ID and remembers

00:13:07,290 --> 00:13:12,540
in its own memory this transaction is

00:13:09,510 --> 00:13:14,459
now in progress the client now does all

00:13:12,540 --> 00:13:15,959
its work it can do that autonomously it

00:13:14,459 --> 00:13:19,360
doesn't need to talk to the transaction

00:13:15,959 --> 00:13:21,980
manager anymore when it's done

00:13:19,360 --> 00:13:23,930
it talks to transaction manager again

00:13:21,980 --> 00:13:26,300
says I want to commit here are the

00:13:23,930 --> 00:13:28,610
changes that I've made the keys that

00:13:26,300 --> 00:13:30,470
I've written two and the transaction

00:13:28,610 --> 00:13:33,440
manager now because it knows about all

00:13:30,470 --> 00:13:34,850
other transactions can find out whether

00:13:33,440 --> 00:13:38,390
there's another transaction that has

00:13:34,850 --> 00:13:42,290
written to the same key and if so it's

00:13:38,390 --> 00:13:45,020
going to say you have a conflict if not

00:13:42,290 --> 00:13:47,540
it's going to say oh okay all right if

00:13:45,020 --> 00:13:49,040
it's okay the transaction is complete we

00:13:47,540 --> 00:13:52,600
can simply forget about it it's now

00:13:49,040 --> 00:13:55,130
visible in HBase but if it's not okay

00:13:52,600 --> 00:13:56,900
now we've made some rights to hbase

00:13:55,130 --> 00:13:59,480
right but our transaction has to roll

00:13:56,900 --> 00:14:02,600
back that responsibilities on the client

00:13:59,480 --> 00:14:04,430
side the client now needs to roll back

00:14:02,600 --> 00:14:07,280
its changes and we can do that each

00:14:04,430 --> 00:14:09,260
place has a way to undo or rights by

00:14:07,280 --> 00:14:13,040
simply issuing a delete for that

00:14:09,260 --> 00:14:17,240
particular version that's written now it

00:14:13,040 --> 00:14:19,550
may happen that that goes through fine

00:14:17,240 --> 00:14:21,320
Oh fine everything that happened in this

00:14:19,550 --> 00:14:22,850
transaction has disappeared has been

00:14:21,320 --> 00:14:24,440
deleted so we can forget about this

00:14:22,850 --> 00:14:26,810
transaction there's no more trace of it

00:14:24,440 --> 00:14:30,200
but it may happen that the rollback

00:14:26,810 --> 00:14:33,530
failed a region server is down a call

00:14:30,200 --> 00:14:35,540
times out who knows what happens maybe

00:14:33,530 --> 00:14:39,530
the client crashes before it can enroll

00:14:35,540 --> 00:14:41,840
back in that case the transaction gets

00:14:39,530 --> 00:14:45,890
invalidated and so this happens if the

00:14:41,840 --> 00:14:47,690
client doesn't crash but it encounters

00:14:45,890 --> 00:14:50,000
an error it can tell the transaction

00:14:47,690 --> 00:14:51,860
manager I could not roll back sonal

00:14:50,000 --> 00:14:53,660
transaction manager invalidates that

00:14:51,860 --> 00:14:55,850
transaction and it remembers that it

00:14:53,660 --> 00:14:57,980
needs to remember that because there are

00:14:55,850 --> 00:14:59,840
some rights and HBase that are not valid

00:14:57,980 --> 00:15:01,580
nobody is allowed to read them ever in

00:14:59,840 --> 00:15:04,430
the future so we have to exclude them

00:15:01,580 --> 00:15:06,050
from future rocks in future reads and

00:15:04,430 --> 00:15:08,090
transaction manager is responsible for

00:15:06,050 --> 00:15:10,730
that it could happen that the client

00:15:08,090 --> 00:15:12,800
crashed in that case transaction manager

00:15:10,730 --> 00:15:14,600
will eventually time out the transaction

00:15:12,800 --> 00:15:21,440
and when it turns out it becomes invalid

00:15:14,600 --> 00:15:26,360
to yes the state of transaction manager

00:15:21,440 --> 00:15:28,040
is in memory oh yes okay so the question

00:15:26,360 --> 00:15:30,290
was where's the state of transaction

00:15:28,040 --> 00:15:32,499
manager transaction manager keeps it

00:15:30,290 --> 00:15:36,159
state in memory but it also maintains

00:15:32,499 --> 00:15:38,499
right ahead log on HDFS so that in case

00:15:36,159 --> 00:15:41,169
of a crash we can recover and its rights

00:15:38,499 --> 00:15:45,639
periodic snapshots so that the recovery

00:15:41,169 --> 00:15:55,409
doesn't take long in case of crash very

00:15:45,639 --> 00:16:02,529
similar to hbase itself yes yes yeah

00:15:55,409 --> 00:16:04,569
we'll get there next slide hazard so

00:16:02,529 --> 00:16:06,879
what does it transaction is a dua I

00:16:04,569 --> 00:16:08,199
already talked about this on the

00:16:06,879 --> 00:16:11,049
important part here is what is the

00:16:08,199 --> 00:16:13,029
transaction a transaction consists of

00:16:11,049 --> 00:16:14,979
three things one is the right pointer

00:16:13,029 --> 00:16:18,129
the right pointer is the version the

00:16:14,979 --> 00:16:20,139
time stamp that the rights of this

00:16:18,129 --> 00:16:22,329
transaction have to happen with right

00:16:20,139 --> 00:16:23,949
the client needs to know that the second

00:16:22,329 --> 00:16:27,759
one is a read pointer the read pointer

00:16:23,949 --> 00:16:29,799
is it's like a high water mark for the

00:16:27,759 --> 00:16:33,099
client that it uses as an upper bound

00:16:29,799 --> 00:16:35,889
for for its read time stamps anything

00:16:33,099 --> 00:16:39,519
that is above must be a transaction that

00:16:35,889 --> 00:16:40,689
we started later and so for isolation I

00:16:39,519 --> 00:16:43,089
don't want to read that so I'm going to

00:16:40,689 --> 00:16:45,549
exclude that some reeds and then the

00:16:43,089 --> 00:16:47,949
third part is we have some transactions

00:16:45,549 --> 00:16:49,720
that are currently in progress they have

00:16:47,949 --> 00:16:51,819
a smaller transaction ID because they

00:16:49,720 --> 00:16:54,279
started earlier but they haven't been

00:16:51,819 --> 00:16:55,839
committed yet and so because we don't

00:16:54,279 --> 00:16:58,209
want dirty reads we have to exclude

00:16:55,839 --> 00:17:00,009
those two and the other ones that we

00:16:58,209 --> 00:17:03,369
have to execute other invalid ones right

00:17:00,009 --> 00:17:06,189
so that's the third part here and here

00:17:03,369 --> 00:17:08,409
is also one problem the execute list

00:17:06,189 --> 00:17:10,029
over time can become large if we have a

00:17:08,409 --> 00:17:11,829
lot of invalid transactions because they

00:17:10,029 --> 00:17:17,470
will never be cleaned up the clients

00:17:11,829 --> 00:17:21,339
have crashed so let me skip to that what

00:17:17,470 --> 00:17:26,289
we have for that is a coprocessor in

00:17:21,339 --> 00:17:27,879
HBase we call that the data janitor this

00:17:26,289 --> 00:17:30,519
is a coprocessor that sits in every

00:17:27,879 --> 00:17:31,869
region server and it it knows the

00:17:30,519 --> 00:17:33,039
transaction state because it

00:17:31,869 --> 00:17:36,279
communicates with the transaction

00:17:33,039 --> 00:17:38,919
manager and every time HBase does a does

00:17:36,279 --> 00:17:41,500
a mem store flush or a compaction it

00:17:38,919 --> 00:17:45,429
hooks into that and it removes all those

00:17:41,500 --> 00:17:46,150
invalids rights that nobody is ever

00:17:45,429 --> 00:17:48,670
going to read any

00:17:46,150 --> 00:17:51,250
and once that has happened we can remove

00:17:48,670 --> 00:17:54,660
those invalid transaction IDs from the

00:17:51,250 --> 00:17:54,660
invalid list and then it shrinks again

00:17:54,870 --> 00:18:01,720
it looks like I'm out of time so I'm

00:17:58,540 --> 00:18:03,820
going to skip this little section that i

00:18:01,720 --> 00:18:06,160
have about abstractions I'm only going

00:18:03,820 --> 00:18:08,230
to say 30 seconds about this to

00:18:06,160 --> 00:18:10,180
implement transactions data set or the

00:18:08,230 --> 00:18:12,910
storage engine only needs to implement

00:18:10,180 --> 00:18:15,670
for interfaces and none of these

00:18:12,910 --> 00:18:18,130
interfaces say anything about HBase and

00:18:15,670 --> 00:18:19,780
in fact we have implemented this for

00:18:18,130 --> 00:18:23,680
other data stores we've done it over a

00:18:19,780 --> 00:18:25,240
level DB over hyper sequel in memory and

00:18:23,680 --> 00:18:28,270
there's many others that could do this

00:18:25,240 --> 00:18:30,280
so what this gives us is we can now

00:18:28,270 --> 00:18:32,710
suddenly do transactions that span

00:18:30,280 --> 00:18:38,320
multiple different storage engines and

00:18:32,710 --> 00:18:41,230
that's quite powerful I'm going to skip

00:18:38,320 --> 00:18:44,860
this just going to tell you what's the

00:18:41,230 --> 00:18:48,040
future sir the transaction manager

00:18:44,860 --> 00:18:49,720
obviously is a bottleneck right there's

00:18:48,040 --> 00:18:51,400
a single transaction manager that needs

00:18:49,720 --> 00:18:53,170
to manage all the transactions in the

00:18:51,400 --> 00:18:57,070
system we've been able to do about

00:18:53,170 --> 00:18:59,350
30,000 per second but in a 500 node

00:18:57,070 --> 00:19:00,490
cluster that's not going to be enough so

00:18:59,350 --> 00:19:03,520
what we're going to have to do is

00:19:00,490 --> 00:19:05,380
partition the key space have distributed

00:19:03,520 --> 00:19:07,440
transactions with multiple transaction

00:19:05,380 --> 00:19:11,740
managers who will then over some

00:19:07,440 --> 00:19:13,180
consensus protocol do distributed

00:19:11,740 --> 00:19:16,480
transactions I don't want to go into

00:19:13,180 --> 00:19:18,400
detail right now we want to integrate

00:19:16,480 --> 00:19:20,890
this with other transactional stores

00:19:18,400 --> 00:19:22,960
like existing relational databases maybe

00:19:20,890 --> 00:19:24,370
Cassandra we've seen cassandra has some

00:19:22,960 --> 00:19:29,260
form of optimistic concurrency control

00:19:24,370 --> 00:19:31,900
who saw the last talked and finally

00:19:29,260 --> 00:19:33,370
we're going to open source this it's

00:19:31,900 --> 00:19:37,330
going to happen this summer I can't

00:19:33,370 --> 00:19:40,240
promise exactly when we have been at the

00:19:37,330 --> 00:19:42,070
at the last HBase meet up in San

00:19:40,240 --> 00:19:44,400
Francisco and discussed it with the

00:19:42,070 --> 00:19:47,170
community there are two or three

00:19:44,400 --> 00:19:48,610
competing approaches right now and we we

00:19:47,170 --> 00:19:51,010
don't know yet what the outcome is going

00:19:48,610 --> 00:19:53,400
to be but I think you're going to see it

00:19:51,010 --> 00:19:56,710
this summer and it's going to be awesome

00:19:53,400 --> 00:19:58,960
oh this I shouldn't say this we're

00:19:56,710 --> 00:20:01,550
hiring of course

00:19:58,960 --> 00:20:07,880
but actually I wanted to take questions

00:20:01,550 --> 00:20:10,310
oops and yeah so there's something this

00:20:07,880 --> 00:20:17,450
actually said questions but we have a

00:20:10,310 --> 00:20:22,060
display display problem it's gone all

00:20:17,450 --> 00:20:22,060
right so um questions please

00:20:32,400 --> 00:20:37,210
so you said you were going to open

00:20:34,630 --> 00:20:39,790
sources this summer are you planning on

00:20:37,210 --> 00:20:41,140
putting it in HBase proper on Apache or

00:20:39,790 --> 00:20:43,750
are you going to continue to maintain

00:20:41,140 --> 00:20:46,300
this on the side or what's what's the

00:20:43,750 --> 00:20:49,990
goal there ideally we can contribute

00:20:46,300 --> 00:20:53,020
this to Apache yes in HBase itself

00:20:49,990 --> 00:20:55,930
there's currently three competing

00:20:53,020 --> 00:20:59,410
approaches to do this and each one has

00:20:55,930 --> 00:21:01,420
its pros and cons right so it may be

00:20:59,410 --> 00:21:03,280
that none of them will actually become

00:21:01,420 --> 00:21:07,210
part of edge place and each of them will

00:21:03,280 --> 00:21:10,240
be separate projects sitting on top of

00:21:07,210 --> 00:21:13,060
HBase it's in the outcome isn't clear

00:21:10,240 --> 00:21:15,700
yet in the worst case we're going to

00:21:13,060 --> 00:21:17,710
open sources on github see whether we

00:21:15,700 --> 00:21:20,080
can build a community and if the

00:21:17,710 --> 00:21:28,810
community has traction we're going to go

00:21:20,080 --> 00:21:31,840
into Apache with it how do you know

00:21:28,810 --> 00:21:33,400
whether you can safely clean up versions

00:21:31,840 --> 00:21:35,410
of the data with old timestamps

00:21:33,400 --> 00:21:37,300
especially in this data janitor you

00:21:35,410 --> 00:21:41,350
mentioned how do you know if their

00:21:37,300 --> 00:21:44,650
transactions are definitely dead how do

00:21:41,350 --> 00:21:46,810
I know so the transaction manager knows

00:21:44,650 --> 00:21:49,300
the states of every ongoing transaction

00:21:46,810 --> 00:21:52,060
if the transaction is properly

00:21:49,300 --> 00:21:55,240
terminated either by doing a commit or

00:21:52,060 --> 00:21:58,690
rollback then we know that all the

00:21:55,240 --> 00:22:01,330
rights that have this timestamp have

00:21:58,690 --> 00:22:03,640
been deleted or they're valid right so

00:22:01,330 --> 00:22:05,970
then we can forget about this it only

00:22:03,640 --> 00:22:08,230
happens for transactions that time out

00:22:05,970 --> 00:22:10,510
whether we're the rollback doesn't

00:22:08,230 --> 00:22:13,090
happen properly the transaction manager

00:22:10,510 --> 00:22:16,860
knows about these transactions all right

00:22:13,090 --> 00:22:16,860
so these are the ones that we can delete

00:22:17,550 --> 00:22:24,220
now there's another another issue

00:22:21,700 --> 00:22:26,380
related to like version clean up because

00:22:24,220 --> 00:22:29,590
we only need to keep one version that is

00:22:26,380 --> 00:22:30,880
visible to all transactions and how do

00:22:29,590 --> 00:22:32,860
we know what is the what is the

00:22:30,880 --> 00:22:34,930
low-water mark of all ongoing

00:22:32,860 --> 00:22:37,630
transactions that might need to be

00:22:34,930 --> 00:22:39,550
visible right so transaction manager at

00:22:37,630 --> 00:22:41,550
any given time knows all the ongoing

00:22:39,550 --> 00:22:44,050
transactions and they're read pointer

00:22:41,550 --> 00:22:45,730
right so if you take the minimum of that

00:22:44,050 --> 00:22:48,010
read pointer you know

00:22:45,730 --> 00:22:57,310
that anything below that can be can be

00:22:48,010 --> 00:22:59,380
removed yeah the clients need to talk to

00:22:57,310 --> 00:23:01,510
the transaction manager in order to

00:22:59,380 --> 00:23:04,780
ensure that they don't read partially

00:23:01,510 --> 00:23:08,080
committed or part or partially committed

00:23:04,780 --> 00:23:11,770
transaction here how they do that I do

00:23:08,080 --> 00:23:13,570
they so is it mandatory that all clients

00:23:11,770 --> 00:23:14,560
use the transaction manager here is a

00:23:13,570 --> 00:23:16,930
lot of whether they using the

00:23:14,560 --> 00:23:18,700
transactions yeah it's not so this is

00:23:16,930 --> 00:23:22,660
one of the nice things that I skipped

00:23:18,700 --> 00:23:29,040
here so we have this abstraction that's

00:23:22,660 --> 00:23:29,040
called transaction aware where is this

00:23:32,040 --> 00:23:39,670
here so a data that can implement these

00:23:36,400 --> 00:23:41,110
four methods alright and then the system

00:23:39,670 --> 00:23:42,370
is going to call that right at the end

00:23:41,110 --> 00:23:44,500
of the transaction is going to call

00:23:42,370 --> 00:23:46,480
commit at the start of the transaction

00:23:44,500 --> 00:23:48,280
it's it's the the transaction itself

00:23:46,480 --> 00:23:51,460
will be communicated to the storage

00:23:48,280 --> 00:23:53,230
engine or to the client that that makes

00:23:51,460 --> 00:23:54,640
the call and it says here's your read

00:23:53,230 --> 00:23:57,010
point or here's your right pointer here

00:23:54,640 --> 00:23:59,170
your excludes but it's up to the client

00:23:57,010 --> 00:24:02,590
to decide whether it actually wants to

00:23:59,170 --> 00:24:05,590
exclude those versions ok so if another

00:24:02,590 --> 00:24:07,600
line if another client that isn't using

00:24:05,590 --> 00:24:09,010
transactions wants to read the data how

00:24:07,600 --> 00:24:12,670
does it guarantee that it doesn't start

00:24:09,010 --> 00:24:14,440
reading right from other clients that

00:24:12,670 --> 00:24:18,130
are in a transaction before they've

00:24:14,440 --> 00:24:20,440
committed you can't guarantee that if if

00:24:18,130 --> 00:24:22,510
a client ignores the excludes in a

00:24:20,440 --> 00:24:25,600
transaction then it's going to see dirty

00:24:22,510 --> 00:24:27,370
dirty rights but that's the choice of

00:24:25,600 --> 00:24:29,500
that client all right you could say I

00:24:27,370 --> 00:24:31,810
want more performance and I don't care

00:24:29,500 --> 00:24:35,860
so I have a good example for this right

00:24:31,810 --> 00:24:39,460
so take the stream of all tweets they

00:24:35,860 --> 00:24:41,710
have embedded URLs and these URLs are

00:24:39,460 --> 00:24:43,630
tiny urls so when you get when you get

00:24:41,710 --> 00:24:45,070
the fire host you have this this tiny

00:24:43,630 --> 00:24:47,350
URL and you don't know where it's

00:24:45,070 --> 00:24:49,150
actually pointing to you want to resolve

00:24:47,350 --> 00:24:51,370
that to the actual URL and that's an

00:24:49,150 --> 00:24:54,430
expensive call right so one of your

00:24:51,370 --> 00:24:56,260
floats is going to make an HTTP call to

00:24:54,430 --> 00:24:58,790
get that redirect and find out what the

00:24:56,260 --> 00:25:02,630
actual URL is and then store

00:24:58,790 --> 00:25:05,780
hbase now this is a case where dirty

00:25:02,630 --> 00:25:09,920
reads are totally fine because if that

00:25:05,780 --> 00:25:12,200
if that fetch is successful whether the

00:25:09,920 --> 00:25:14,870
transaction that writes it gets rolled

00:25:12,200 --> 00:25:17,210
back or not that's redirect is valid we

00:25:14,870 --> 00:25:19,100
know that this is valid and so we can

00:25:17,210 --> 00:25:21,500
afford to do dirty reads all right and

00:25:19,100 --> 00:25:24,110
in that case this is also an example

00:25:21,500 --> 00:25:26,090
where the data set implementation can

00:25:24,110 --> 00:25:27,710
choose not to do the roll by even though

00:25:26,090 --> 00:25:29,780
the transaction gets rolled back i leave

00:25:27,710 --> 00:25:36,910
my right there because it's still useful

00:25:29,780 --> 00:25:36,910

YouTube URL: https://www.youtube.com/watch?v=KIWrc7lQ18s


