Title: Berlin Buzzwords 2015: Nick Burch - What's with the 1s and 0s? Making sense of binary data at scale
Publication date: 2015-06-03
Playlist: Berlin Buzzwords 2015 #bbuzz
Description: 
	If you have one or two files, you can take the time to manually work out what they are, what they contain, and how to get the useful bits out (probably....). However, this approach really doesn't scale, mechanical turks or no! Luckily, there are open source projects and libraries out there which can help, and which can scale!

In this talk, we'll first look at how we can work out what a given blob of 1s and 0s actually is, be it textual or binary. We'll then see how to extract common metadata from it, along with text, embedded resources, images, and maybe even the kitchen sink! 

We'll see how to use things like Apache Tika to do this, along with some other libraries to complement it. Once that part's all sorted, we'll look at how to roll this all out for a large-scale Search or Big Data setup, helping you turn those 1s and 0s into useful content at scale!

Read more:
https://2015.berlinbuzzwords.de/session/whats-1s-and-0s-making-sense-binary-data-scale-0

About Nick Burch:
https://2015.berlinbuzzwords.de/users/gagravarr

Website: https://berlinbuzzwords.de/
Twitter: https://twitter.com/berlinbuzzwords
LinkedIn: https://www.linkedin.com/showcase/berlin-buzzwords/ 
Reddit: https://www.reddit.com/r/berlinbuzzwords/
Captions: 
	00:00:05,920 --> 00:00:13,430
so ones and zeroes so what I'm going to

00:00:11,120 --> 00:00:16,430
talk a little bit about first

00:00:13,430 --> 00:00:19,820
is how we can work out what kind of file

00:00:16,430 --> 00:00:22,190
we've got their little bit about the

00:00:19,820 --> 00:00:24,890
problems and challenges of detecting

00:00:22,190 --> 00:00:27,920
text the languages I'll talk a bit about

00:00:24,890 --> 00:00:30,350
apache tika and how we can use that to

00:00:27,920 --> 00:00:32,570
solve some of those problems then i'll

00:00:30,350 --> 00:00:34,010
talk about how it can all go wrong and

00:00:32,570 --> 00:00:35,900
scale and what you need to start

00:00:34,010 --> 00:00:39,920
thinking about if you've got more than a

00:00:35,900 --> 00:00:41,059
handful of documents and also one of the

00:00:39,920 --> 00:00:43,309
interesting things are doing in secret

00:00:41,059 --> 00:00:46,610
at the moment which is automatically

00:00:43,309 --> 00:00:49,550
trying to work out if things are getting

00:00:46,610 --> 00:00:52,100
better or worse as we make changes so I

00:00:49,550 --> 00:00:53,750
can get a sense of what people are

00:00:52,100 --> 00:00:57,710
interested in and know which things to

00:00:53,750 --> 00:01:02,270
focus on and who here is mostly

00:00:57,710 --> 00:01:05,540
interested in search stuff who here is

00:01:02,270 --> 00:01:07,460
more interested in the Hadoop for me

00:01:05,540 --> 00:01:10,399
sauce the storm that kind of thing and

00:01:07,460 --> 00:01:15,340
doing a bit of data binary stuff on the

00:01:10,399 --> 00:01:22,130
side okay who here has used tika before

00:01:15,340 --> 00:01:26,630
okay right that's fine so detecting file

00:01:22,130 --> 00:01:30,530
types should should be easy right so if

00:01:26,630 --> 00:01:31,909
the files on your computer surely surely

00:01:30,530 --> 00:01:35,810
you know what what it's going to be and

00:01:31,909 --> 00:01:38,930
it's only for you so it's easy and if

00:01:35,810 --> 00:01:43,490
it's not on your computer well you know

00:01:38,930 --> 00:01:45,439
people never rename things do they the

00:01:43,490 --> 00:01:49,220
internet everything on the internet is

00:01:45,439 --> 00:01:53,320
right isn't it and web servers would

00:01:49,220 --> 00:01:56,000
never lie they've never get confused a

00:01:53,320 --> 00:01:58,180
few percent of the internet it's not

00:01:56,000 --> 00:02:00,590
like that's worth worrying about

00:01:58,180 --> 00:02:03,470
operating systems they never help they

00:02:00,590 --> 00:02:06,650
never hide extensions rename extensions

00:02:03,470 --> 00:02:14,810
launch the wrong program so yeah it's

00:02:06,650 --> 00:02:19,100
easy isn't it so file names normally but

00:02:14,810 --> 00:02:21,290
not always have extensions but there

00:02:19,100 --> 00:02:23,180
aren't very many extension combinations

00:02:21,290 --> 00:02:24,760
there's a lot more file formats than

00:02:23,180 --> 00:02:26,620
there are extensions

00:02:24,760 --> 00:02:30,099
there's no place that you can go to

00:02:26,620 --> 00:02:32,519
register or bank see your extension so

00:02:30,099 --> 00:02:34,659
everyone just picks a sensible one and

00:02:32,519 --> 00:02:40,980
hopes that there aren't too many clashes

00:02:34,659 --> 00:02:43,120
who here uses windows isn't it fun when

00:02:40,980 --> 00:02:47,709
you've got three different programs that

00:02:43,120 --> 00:02:51,220
all want the same extension and isn't it

00:02:47,709 --> 00:02:55,150
fun when you rename something and all

00:02:51,220 --> 00:02:57,819
sorts of weird stuff happens and so the

00:02:55,150 --> 00:03:01,780
farm names are a really quick way to

00:02:57,819 --> 00:03:04,900
guess what a file type is but it's

00:03:01,780 --> 00:03:08,319
pretty dirty and it's not always right

00:03:04,900 --> 00:03:10,569
so if you've got ten files it's going to

00:03:08,319 --> 00:03:12,760
be close enough if you've got ten

00:03:10,569 --> 00:03:18,370
million files it's it's going to cause

00:03:12,760 --> 00:03:20,730
issues and my magic most file formats

00:03:18,370 --> 00:03:24,129
will have a well-known structure and

00:03:20,730 --> 00:03:26,920
most of them will have a nearly unique

00:03:24,129 --> 00:03:29,230
pattern at the start sometimes these are

00:03:26,920 --> 00:03:30,879
called my magic numbers sometimes they

00:03:29,230 --> 00:03:34,120
are actual numbers often it's just bite

00:03:30,879 --> 00:03:36,459
patterns or Oh bite masks and things now

00:03:34,120 --> 00:03:38,079
ideally every file would have a couple

00:03:36,459 --> 00:03:39,489
of unique bites at the start that would

00:03:38,079 --> 00:03:42,790
let us work out what they are or at

00:03:39,489 --> 00:03:46,359
least a couple of bites at a known

00:03:42,790 --> 00:03:49,859
position that will give us a hint so the

00:03:46,359 --> 00:03:53,019
PDF should start with percent PDF dash

00:03:49,859 --> 00:03:54,790
or sometimes though it starts with a

00:03:53,019 --> 00:03:57,370
byte order mark and then that or

00:03:54,790 --> 00:04:00,400
sometimes even a few random bytes of

00:03:57,370 --> 00:04:02,799
crap and then that only two documents

00:04:00,400 --> 00:04:08,709
should start with that a fun little

00:04:02,799 --> 00:04:13,269
number there zip files PK 34 except when

00:04:08,709 --> 00:04:17,229
it's pk-12 and iof have a sort of mass

00:04:13,269 --> 00:04:19,959
structure here p executables probably

00:04:17,229 --> 00:04:23,530
going to have penal lull at one of those

00:04:19,959 --> 00:04:27,990
two upsets except when it doesn't and if

00:04:23,530 --> 00:04:31,330
your file start 0xff fe that could be a

00:04:27,990 --> 00:04:35,020
utf-16 little-endian byte order mark or

00:04:31,330 --> 00:04:38,080
it could be an mp3 or it could be a raw

00:04:35,020 --> 00:04:43,270
camera image file or it could be

00:04:38,080 --> 00:04:46,150
something else so often but not always

00:04:43,270 --> 00:04:51,159
handy another challenge is if you see a

00:04:46,150 --> 00:04:54,969
file that starts PK x3 x4 that could be

00:04:51,159 --> 00:04:58,449
a zip file but it could also be an 00

00:04:54,969 --> 00:05:01,060
XML file a dot docx xlsx which is

00:04:58,449 --> 00:05:03,129
wrapped in a zip file could be and I

00:05:01,060 --> 00:05:04,479
works file it could be an audio file it

00:05:03,129 --> 00:05:06,729
could be a whole bunch of other things

00:05:04,479 --> 00:05:09,039
so just because we've got a magic number

00:05:06,729 --> 00:05:12,069
it doesn't always uniquely identify the

00:05:09,039 --> 00:05:15,039
file format and then if it's a

00:05:12,069 --> 00:05:18,039
text-based one an interesting ticker bug

00:05:15,039 --> 00:05:21,969
this last week which was how do i tell

00:05:18,039 --> 00:05:24,099
if this is a matlab file or a see macro

00:05:21,969 --> 00:05:26,110
file because they're both text-based

00:05:24,099 --> 00:05:28,900
file formats there's no header on the

00:05:26,110 --> 00:05:31,419
front the comments aren't always great

00:05:28,900 --> 00:05:36,129
so it can help especially on binary

00:05:31,419 --> 00:05:38,080
files but it's no magic bullet so I

00:05:36,129 --> 00:05:41,469
mentioned already container formats if

00:05:38,080 --> 00:05:44,740
it's a zip that's a challenge could be a

00:05:41,469 --> 00:05:48,789
no xml docx or something open document I

00:05:44,740 --> 00:05:51,009
works pub all that sort of thing if you

00:05:48,789 --> 00:05:54,699
get one of the media container formats

00:05:51,009 --> 00:05:57,069
like an org like an mp4 it could be text

00:05:54,699 --> 00:05:59,710
could be video could be audio could be

00:05:57,069 --> 00:06:01,960
combinations of them just because you

00:05:59,710 --> 00:06:03,520
found the mp4 magic number doesn't mean

00:06:01,960 --> 00:06:06,159
you can say all that's music or that's

00:06:03,520 --> 00:06:09,729
video immediately so it gets gets tricky

00:06:06,159 --> 00:06:11,589
to work out what's going on and there's

00:06:09,729 --> 00:06:14,250
also some fun stuff you can do if you

00:06:11,589 --> 00:06:18,219
like confusing people you can build a

00:06:14,250 --> 00:06:21,490
microsoft binary file early to structure

00:06:18,219 --> 00:06:24,909
that has multiple streams in it and then

00:06:21,490 --> 00:06:27,520
if you rename it from say xls to doc you

00:06:24,909 --> 00:06:30,550
get a different document that opens it's

00:06:27,520 --> 00:06:33,250
a sort of fun little practical joke for

00:06:30,550 --> 00:06:35,589
stena graphically hiding stuff but kind

00:06:33,250 --> 00:06:37,330
of throws up some interesting problems

00:06:35,589 --> 00:06:38,919
we're here the file extension on windows

00:06:37,330 --> 00:06:40,479
will cause it to open in different

00:06:38,919 --> 00:06:42,690
applications and show different

00:06:40,479 --> 00:06:42,690
information

00:06:44,270 --> 00:06:49,229
so what can we do with containers if

00:06:47,669 --> 00:06:51,419
we're trying to make sense them well the

00:06:49,229 --> 00:06:53,250
easiest one is that we can use a mind

00:06:51,419 --> 00:06:56,009
magic to work out what container is and

00:06:53,250 --> 00:06:57,449
then we have to open it up and start

00:06:56,009 --> 00:07:00,479
looking through so if it was a zip file

00:06:57,449 --> 00:07:03,810
and it contains an underscore rails rels

00:07:00,479 --> 00:07:05,729
it's probably our XML if it's an OGG

00:07:03,810 --> 00:07:07,680
file then we can look for a CMM meld

00:07:05,729 --> 00:07:09,509
stream and then pass that and start

00:07:07,680 --> 00:07:13,830
looking for descriptions that tell us

00:07:09,509 --> 00:07:15,990
what's going on but this isn't quick so

00:07:13,830 --> 00:07:18,780
when we had the filename stuff if we

00:07:15,990 --> 00:07:22,199
found that it was doc txt we can very

00:07:18,780 --> 00:07:26,550
quickly say it's probably txt if we

00:07:22,199 --> 00:07:29,039
found that it's it's an August ream we

00:07:26,550 --> 00:07:31,080
now have to stop passing all the old

00:07:29,039 --> 00:07:33,030
packets going through the page structure

00:07:31,080 --> 00:07:35,280
finding the streams finding the sea FML

00:07:33,030 --> 00:07:36,750
stream pass that look in it see where

00:07:35,280 --> 00:07:40,110
that tells us about whether this is

00:07:36,750 --> 00:07:41,669
going to be a video or an audio and

00:07:40,110 --> 00:07:43,650
hence what parts are you going to use to

00:07:41,669 --> 00:07:45,210
get the text out which is probably what

00:07:43,650 --> 00:07:47,610
you wanted in the first place because

00:07:45,210 --> 00:07:49,020
I'm assuming that most of you here what

00:07:47,610 --> 00:07:50,849
you've got is a whole load of files and

00:07:49,020 --> 00:07:53,340
what you want is a whole load of use of

00:07:50,849 --> 00:07:55,830
information so you're going to have to

00:07:53,340 --> 00:07:57,449
choose how much work you put in and

00:07:55,830 --> 00:07:58,650
that's going to be different for all of

00:07:57,449 --> 00:08:02,099
you it's can be different based on your

00:07:58,650 --> 00:08:04,020
needs but sadly it's not a quick thing

00:08:02,099 --> 00:08:05,009
you've got to tune the dial based on the

00:08:04,020 --> 00:08:06,630
amount of memory the amount of

00:08:05,009 --> 00:08:08,520
processing time to come up with the

00:08:06,630 --> 00:08:10,229
answer of what this thing is and only

00:08:08,520 --> 00:08:16,860
once we know what it is can we start

00:08:10,229 --> 00:08:18,509
getting the information out another one

00:08:16,860 --> 00:08:21,150
that you can sometimes do is look for

00:08:18,509 --> 00:08:23,219
patterns inside the file and there are

00:08:21,150 --> 00:08:26,190
some scientific data formats that don't

00:08:23,219 --> 00:08:28,319
appear to have any kind of known

00:08:26,190 --> 00:08:29,610
structure on them so there's some work

00:08:28,319 --> 00:08:31,590
that's going on at the moment where

00:08:29,610 --> 00:08:33,690
people are using histogram patterns and

00:08:31,590 --> 00:08:36,419
they analyze the the whole file and they

00:08:33,690 --> 00:08:37,919
look for certain common repeating

00:08:36,419 --> 00:08:40,050
patterns and repeating structures and

00:08:37,919 --> 00:08:43,200
use that to work out what the file might

00:08:40,050 --> 00:08:45,930
be that's also of use if you've maybe

00:08:43,200 --> 00:08:47,730
got corrupted files or truncated files

00:08:45,930 --> 00:08:49,709
so if there's anyone in the audience is

00:08:47,730 --> 00:08:52,320
doing any stuff around digital forensics

00:08:49,709 --> 00:08:54,600
where you may have eighty percent of the

00:08:52,320 --> 00:08:56,520
file if you've missed the first hundred

00:08:54,600 --> 00:08:58,620
and twenty eight bytes of it

00:08:56,520 --> 00:09:00,510
missed all that lovely magic number

00:08:58,620 --> 00:09:01,650
stuff so you won't have those there and

00:09:00,510 --> 00:09:04,260
then you're looking at this date renew

00:09:01,650 --> 00:09:06,180
going well is this most of a PDF or is

00:09:04,260 --> 00:09:10,590
this most of a text file or it's just

00:09:06,180 --> 00:09:14,640
the hard disk is dead so you can do some

00:09:10,590 --> 00:09:17,010
stuff around that finally what you're

00:09:14,640 --> 00:09:19,530
probably going to want to do is combine

00:09:17,010 --> 00:09:21,030
all of them you're going to take the

00:09:19,530 --> 00:09:23,190
filename and use that as a hint you'll

00:09:21,030 --> 00:09:24,390
take the my magic use that as a hint if

00:09:23,190 --> 00:09:27,840
you looked inside the file that's

00:09:24,390 --> 00:09:30,750
another hint it's going to have impacts

00:09:27,840 --> 00:09:33,120
on the speed and accuracy and another

00:09:30,750 --> 00:09:34,590
thing that's you maybe want to do is do

00:09:33,120 --> 00:09:37,230
a bit of machine learning and find out

00:09:34,590 --> 00:09:39,390
what's the right waiting for your target

00:09:37,230 --> 00:09:40,890
data set that means a bit of work up

00:09:39,390 --> 00:09:43,020
front because you're going to have to go

00:09:40,890 --> 00:09:45,150
through and say yes that really is a

00:09:43,020 --> 00:09:46,500
Word document whereas that thing that

00:09:45,150 --> 00:09:48,900
claims this a text file is actually a

00:09:46,500 --> 00:09:50,760
PDF and then learn the right combination

00:09:48,900 --> 00:09:54,930
so that your system will predict that

00:09:50,760 --> 00:09:56,670
from the given inputs which can I mean

00:09:54,930 --> 00:09:59,070
yes it's more work but it can increase

00:09:56,670 --> 00:10:01,530
your accuracy so it just depends on what

00:09:59,070 --> 00:10:03,270
you're going to care about okay so that

00:10:01,530 --> 00:10:06,180
was that was for our binary stuff what

00:10:03,270 --> 00:10:09,780
about text text is easy isn't it who

00:10:06,180 --> 00:10:12,570
thinks text is easy good the cynicism is

00:10:09,780 --> 00:10:16,230
working all you've fallen asleep so in

00:10:12,570 --> 00:10:18,780
coatings 101 if you find a letter A in

00:10:16,230 --> 00:10:19,710
your file or I'm sorry if you've got a

00:10:18,780 --> 00:10:24,390
letter A that you're going to be

00:10:19,710 --> 00:10:28,830
encoding you could write it as 0x40 10 X

00:10:24,390 --> 00:10:32,430
0 0 40 10 x 41 double zero so those are

00:10:28,830 --> 00:10:34,440
all your kind of typical pc ascii style

00:10:32,430 --> 00:10:36,420
formats or you could have a main frame

00:10:34,440 --> 00:10:41,520
in which case it's been written as 0 XC

00:10:36,420 --> 00:10:43,110
1 so that's just the letter A and if

00:10:41,520 --> 00:10:44,940
you're dealing with a lot of old file

00:10:43,110 --> 00:10:47,490
formats they're all going to be using

00:10:44,940 --> 00:10:48,840
one byte per character which just remaps

00:10:47,490 --> 00:10:51,390
it all sorts of different ways so if

00:10:48,840 --> 00:10:56,700
we've finder the first character in our

00:10:51,390 --> 00:10:58,830
file text valley 0 x e 1 well those are

00:10:56,700 --> 00:11:00,870
the most common characters that that

00:10:58,830 --> 00:11:03,930
could actually be from the most common

00:11:00,870 --> 00:11:06,790
single byte encoding things

00:11:03,930 --> 00:11:09,190
some file formats are helpful and

00:11:06,790 --> 00:11:11,830
they'll tell you what encoding the next

00:11:09,190 --> 00:11:13,930
stream of text is in but if it's a plain

00:11:11,830 --> 00:11:16,210
text file or a lot of the email file

00:11:13,930 --> 00:11:17,620
formats and stuff it's just a bunch of

00:11:16,210 --> 00:11:21,010
ones and zeros and you've got to work

00:11:17,620 --> 00:11:23,530
out what that's going to be so you can't

00:11:21,010 --> 00:11:24,880
actually extract the text from your txt

00:11:23,530 --> 00:11:26,800
file until you know what encoding it's

00:11:24,880 --> 00:11:29,170
in so how are we going to work out

00:11:26,800 --> 00:11:35,770
whether our file is going to be an

00:11:29,170 --> 00:11:38,860
Arabic or Hebrew or Greek or French the

00:11:35,770 --> 00:11:42,100
good news is that you can often find the

00:11:38,860 --> 00:11:47,130
language and the encoding at the same

00:11:42,100 --> 00:11:52,600
time so if we see some accents like that

00:11:47,130 --> 00:11:54,460
it's probably not going to be English if

00:11:52,600 --> 00:11:57,460
we see lots of words starting with s

00:11:54,460 --> 00:11:59,110
it's probably not going to be Spanish on

00:11:57,460 --> 00:12:01,360
the other hand if we see lots of words

00:11:59,110 --> 00:12:05,050
that start es it's much more likely to

00:12:01,360 --> 00:12:06,850
be Spanish so what we can do if we've

00:12:05,050 --> 00:12:08,860
got enough of a corpus of text available

00:12:06,850 --> 00:12:10,510
to us we can go through and find these

00:12:08,860 --> 00:12:12,490
common patterns for certain languages

00:12:10,510 --> 00:12:14,830
and we can find these common patterns

00:12:12,490 --> 00:12:18,610
for different encodings of the same

00:12:14,830 --> 00:12:22,060
language and then we can use that but we

00:12:18,610 --> 00:12:24,250
need a lot of text if I have one

00:12:22,060 --> 00:12:28,030
sentence it's going to be very hard to

00:12:24,250 --> 00:12:29,800
work out definitively what that is if I

00:12:28,030 --> 00:12:34,300
have a lot of text it's going to be

00:12:29,800 --> 00:12:38,350
easier if I have mixtures so if I've got

00:12:34,300 --> 00:12:42,370
this slide here and I save that as a

00:12:38,350 --> 00:12:43,720
text file some simple analysis tools

00:12:42,370 --> 00:12:45,190
might get confused and they'll go oh

00:12:43,720 --> 00:12:47,800
look there's all these accents in it it

00:12:45,190 --> 00:12:49,720
can't be English but it's mostly English

00:12:47,800 --> 00:12:52,150
but I put some accents in but if I've

00:12:49,720 --> 00:12:54,400
got the whole presentation saved as a

00:12:52,150 --> 00:12:56,260
text file then you can ignore those odd

00:12:54,400 --> 00:12:58,030
little rounding errors from the Act the

00:12:56,260 --> 00:13:01,300
odd accent I've put in and still work

00:12:58,030 --> 00:13:05,380
out most of what we've got okay who

00:13:01,300 --> 00:13:07,960
knows what an n-gram is Oh excellent

00:13:05,380 --> 00:13:10,300
everyone okay so all I'll say then is if

00:13:07,960 --> 00:13:12,150
you've got enough text you can build up

00:13:10,300 --> 00:13:17,110
the common in grams from each language

00:13:12,150 --> 00:13:18,910
you can use tools like I convey and I

00:13:17,110 --> 00:13:22,990
to you for J and that kind of thing to

00:13:18,910 --> 00:13:25,180
take your sample engrams translate them

00:13:22,990 --> 00:13:26,920
into all the different encodings that

00:13:25,180 --> 00:13:29,200
you might be dealing with and then you

00:13:26,920 --> 00:13:32,440
can do an n-gram match and say aha this

00:13:29,200 --> 00:13:34,990
is spanish in iso 8859 too because

00:13:32,440 --> 00:13:38,560
that's the highest likelihood for these

00:13:34,990 --> 00:13:41,860
given Engram patterns and so then what

00:13:38,560 --> 00:13:44,680
we can end up with when we started with

00:13:41,860 --> 00:13:46,660
something with a dot txt extension that

00:13:44,680 --> 00:13:48,670
may or may not have been text we can

00:13:46,660 --> 00:13:51,070
apply the engrams on it and go ah this

00:13:48,670 --> 00:13:53,350
is French and this encoding this is

00:13:51,070 --> 00:13:56,220
German in this encoding this is Korean

00:13:53,350 --> 00:14:00,910
in this to light eastern encoding which

00:13:56,220 --> 00:14:02,140
there means we can read it in because we

00:14:00,910 --> 00:14:04,630
know what encoding it since we know how

00:14:02,140 --> 00:14:06,579
to get the characters out and we know

00:14:04,630 --> 00:14:07,750
what language it's in which means if

00:14:06,579 --> 00:14:09,550
we're going to be indexing and searching

00:14:07,750 --> 00:14:12,160
based on it we know what kind of

00:14:09,550 --> 00:14:14,800
analyzers and stem is to apply to it

00:14:12,160 --> 00:14:15,940
because if it's in French you're going

00:14:14,800 --> 00:14:18,130
to need to use different techniques

00:14:15,940 --> 00:14:20,800
breaking it down into words than if it

00:14:18,130 --> 00:14:25,720
was in Korean so that's handy because we

00:14:20,800 --> 00:14:28,360
can tackle by at the same time it's a

00:14:25,720 --> 00:14:31,060
few things that it can go wrong with if

00:14:28,360 --> 00:14:33,040
you've only got that tiny little bit of

00:14:31,060 --> 00:14:35,740
text it's going to be hard to work out

00:14:33,040 --> 00:14:37,660
what it is if we've got a load of

00:14:35,740 --> 00:14:41,050
control characters and garbage at the

00:14:37,660 --> 00:14:43,240
start of the file you may mistakenly

00:14:41,050 --> 00:14:44,470
think it's not text so again that's for

00:14:43,240 --> 00:14:46,720
any of you in the room who are doing any

00:14:44,470 --> 00:14:49,240
forensic stuff or dealing with any weird

00:14:46,720 --> 00:14:51,250
files where a few random control

00:14:49,240 --> 00:14:52,990
characters end up on the front you might

00:14:51,250 --> 00:14:54,190
not you might think oh this is some

00:14:52,990 --> 00:14:59,140
random binary file when it's actually

00:14:54,190 --> 00:15:02,860
text some encodings are very similar so

00:14:59,140 --> 00:15:07,240
the difference between iso 8859 1 and 15

00:15:02,860 --> 00:15:08,980
is I believe the euro symbol so if

00:15:07,240 --> 00:15:10,660
you've not got any pricing information

00:15:08,980 --> 00:15:12,550
in there you can't tell the difference

00:15:10,660 --> 00:15:13,660
between them but on the other hand if

00:15:12,550 --> 00:15:15,820
you've not got any pricing information

00:15:13,660 --> 00:15:17,320
there does it matter if you pick one or

00:15:15,820 --> 00:15:23,480
the other because you're not using that

00:15:17,320 --> 00:15:26,180
Co point so

00:15:23,480 --> 00:15:28,610
those are the techniques for working out

00:15:26,180 --> 00:15:32,060
what our binary files are and what our

00:15:28,610 --> 00:15:33,320
text files are what what about if you

00:15:32,060 --> 00:15:39,529
don't want to coat all those up for

00:15:33,320 --> 00:15:41,720
yourself so Apache tikka is like a Babel

00:15:39,529 --> 00:15:44,690
Fish for content it helps you work out

00:15:41,720 --> 00:15:46,040
what your file is then it helps you

00:15:44,690 --> 00:15:48,740
extract the metadata from it in a

00:15:46,040 --> 00:15:50,839
consistent way so that you don't need to

00:15:48,740 --> 00:15:52,970
know that a word document calls it

00:15:50,839 --> 00:15:57,230
summary and a PDF calls it short title

00:15:52,970 --> 00:16:00,560
and an mp3 calls it title you can say

00:15:57,230 --> 00:16:03,290
tikka find out what this file is and

00:16:00,560 --> 00:16:05,959
then tell me the thing that most closely

00:16:03,290 --> 00:16:07,279
matches the dublin core subject and the

00:16:05,959 --> 00:16:10,190
teacher can go off and do that for you

00:16:07,279 --> 00:16:11,240
and give the information back and for a

00:16:10,190 --> 00:16:13,459
lot of you in the room you're interested

00:16:11,240 --> 00:16:18,560
in search it will give you back nice

00:16:13,459 --> 00:16:21,050
simple plain text which is handy so

00:16:18,560 --> 00:16:22,190
these are some of the the file formats

00:16:21,050 --> 00:16:26,300
that it's going to support out of the

00:16:22,190 --> 00:16:29,750
box what tikka does on the whole is wrap

00:16:26,300 --> 00:16:32,060
other libraries so that you don't need

00:16:29,750 --> 00:16:34,819
to know that the best library from PDF

00:16:32,060 --> 00:16:38,180
is PDF box and for a word document its

00:16:34,819 --> 00:16:42,319
POI on the whole tikka doesn't have its

00:16:38,180 --> 00:16:44,240
own code for handling given file formats

00:16:42,319 --> 00:16:45,889
what it tends to have is calls out to

00:16:44,240 --> 00:16:50,420
all the appropriate libraries that will

00:16:45,889 --> 00:16:54,170
do it for you so it's got all your usual

00:16:50,420 --> 00:16:55,850
office file formats and an HTML and PDF

00:16:54,170 --> 00:16:56,990
and all that sort of stuff but also

00:16:55,850 --> 00:16:59,510
increasingly it's got a lot of

00:16:56,990 --> 00:17:03,319
scientific file formats supported in it

00:16:59,510 --> 00:17:06,110
and then audio and video and image file

00:17:03,319 --> 00:17:09,410
formats as well and it's got hooks into

00:17:06,110 --> 00:17:12,860
the tesseract OCR tool that if you've

00:17:09,410 --> 00:17:14,390
got an image file you can then hand that

00:17:12,860 --> 00:17:17,449
off to tesseract which will give you the

00:17:14,390 --> 00:17:18,770
text and then you can give it to exit

00:17:17,449 --> 00:17:20,839
tool or something like that and get back

00:17:18,770 --> 00:17:23,000
the EXIF information that'll mean that

00:17:20,839 --> 00:17:26,990
you can work out that that particular

00:17:23,000 --> 00:17:29,120
photo was taken in front of brandenburg

00:17:26,990 --> 00:17:31,250
tour with someone wearing an i love

00:17:29,120 --> 00:17:33,409
Berlin t-shirt on it and so you can pull

00:17:31,250 --> 00:17:34,870
out the metadata and you can also get

00:17:33,409 --> 00:17:37,630
the text from it

00:17:34,870 --> 00:17:39,370
which is great because before you have

00:17:37,630 --> 00:17:40,540
that you just had an image file and you

00:17:39,370 --> 00:17:42,190
couldn't index it and you can do

00:17:40,540 --> 00:17:44,740
anything with it and now all of a sudden

00:17:42,190 --> 00:17:46,840
you can say give me all the images taken

00:17:44,740 --> 00:17:50,980
in Berlin that mentioned the word Berlin

00:17:46,840 --> 00:17:53,620
in them and get it that way so few

00:17:50,980 --> 00:17:55,660
different ways of cooling tikka there's

00:17:53,620 --> 00:17:59,890
a command-line tool you can call it from

00:17:55,660 --> 00:18:03,070
Java it's got osgi bundles as a network

00:17:59,890 --> 00:18:07,170
server and it has a solar plugin who

00:18:03,070 --> 00:18:10,240
here uses the solar plug-in fatiguer ok

00:18:07,170 --> 00:18:13,030
don't put too much data through it

00:18:10,240 --> 00:18:14,320
because it's in the same jvm so we're

00:18:13,030 --> 00:18:16,660
going to come on a bit later to the ways

00:18:14,320 --> 00:18:18,040
it can go horribly wrong I was having a

00:18:16,660 --> 00:18:20,140
chat with some of the the solar

00:18:18,040 --> 00:18:21,940
committers last night and they say that

00:18:20,140 --> 00:18:24,070
they absolutely love it for demos and

00:18:21,940 --> 00:18:26,020
they absolutely hate it when it gets put

00:18:24,070 --> 00:18:29,440
into production because then it falls

00:18:26,020 --> 00:18:34,059
over and wrecks everything so and you

00:18:29,440 --> 00:18:38,140
hit right stuff in Java you hear right

00:18:34,059 --> 00:18:43,570
stuff in a JVM language not java who

00:18:38,140 --> 00:18:46,900
here uses some other language ok so for

00:18:43,570 --> 00:18:49,420
those of you not using Java the main two

00:18:46,900 --> 00:18:52,240
ways I'd suggest you use our batik a nap

00:18:49,420 --> 00:18:53,740
and the network server for those of you

00:18:52,240 --> 00:18:56,500
in Java you can pick any of them

00:18:53,740 --> 00:19:00,700
whichever one you you prefer so the

00:18:56,500 --> 00:19:03,160
ticker app is a single runnable jar it's

00:19:00,700 --> 00:19:04,780
getting quite fat these days because

00:19:03,160 --> 00:19:07,300
it's got all of the dependencies bundled

00:19:04,780 --> 00:19:10,750
into it but you just take it you run it

00:19:07,300 --> 00:19:14,290
and it can give you the detection so you

00:19:10,750 --> 00:19:15,880
can say Tico what is this file if it's a

00:19:14,290 --> 00:19:17,230
text file you can also do the language a

00:19:15,880 --> 00:19:19,720
texture and say you know what white

00:19:17,230 --> 00:19:21,370
coating is this what language is it it

00:19:19,720 --> 00:19:22,870
will give you all the metadata back it

00:19:21,370 --> 00:19:27,490
will give you the plain text and the

00:19:22,870 --> 00:19:31,540
XHTML it's really good for testing it's

00:19:27,490 --> 00:19:35,230
really good for demos but you're

00:19:31,540 --> 00:19:37,230
spawning a new JVM each time so if

00:19:35,230 --> 00:19:41,200
you're going to be running this

00:19:37,230 --> 00:19:43,150
thousands of times an hour on a handful

00:19:41,200 --> 00:19:44,560
of machines that's maybe not going to

00:19:43,150 --> 00:19:45,940
work out so well because you're going to

00:19:44,560 --> 00:19:48,740
be paying

00:19:45,940 --> 00:19:52,190
yeah maybe a second to spawn a JVM and

00:19:48,740 --> 00:19:53,870
then 15 milliseconds to pass the file

00:19:52,190 --> 00:19:56,270
that's not necessarily going to be a

00:19:53,870 --> 00:19:59,179
great thing but on the other hand if

00:19:56,270 --> 00:20:01,460
your application is mostly dealing with

00:19:59,179 --> 00:20:03,020
simple plain text and only very rarely

00:20:01,460 --> 00:20:05,809
you're going to get these binary files

00:20:03,020 --> 00:20:08,299
maybe it is okay to spawn a new JVM once

00:20:05,809 --> 00:20:10,549
in a blue moon to pass the old file and

00:20:08,299 --> 00:20:13,279
increase your coverage that way it's a

00:20:10,549 --> 00:20:16,700
bit of a trade-off going on there the

00:20:13,279 --> 00:20:20,059
tikka server is a restful server you

00:20:16,700 --> 00:20:22,700
just put files to it and then it will

00:20:20,059 --> 00:20:25,760
give you back the results be that the

00:20:22,700 --> 00:20:28,730
detection or the text or the metadata so

00:20:25,760 --> 00:20:30,289
if you're running in a non Java language

00:20:28,730 --> 00:20:33,919
and you're going to want to put a lot of

00:20:30,289 --> 00:20:35,659
stuff through or even if you're running

00:20:33,919 --> 00:20:37,669
in a java language and you want it in a

00:20:35,659 --> 00:20:39,470
separate JVM so if it falls over it

00:20:37,669 --> 00:20:43,010
won't take out your main one it's worth

00:20:39,470 --> 00:20:45,260
running the server its standalone single

00:20:43,010 --> 00:20:47,899
jar you run it up comes the server you

00:20:45,260 --> 00:20:50,120
start putting resources to it but it's

00:20:47,899 --> 00:20:51,890
very easy to have a little watchdog that

00:20:50,120 --> 00:20:53,899
spots when that falls over and respawns

00:20:51,890 --> 00:20:56,120
it and then that's completely separate

00:20:53,899 --> 00:20:58,250
from your main application so if you are

00:20:56,120 --> 00:21:00,710
doing solar and you're doing

00:20:58,250 --> 00:21:02,899
elasticsearch at any kind of scale the

00:21:00,710 --> 00:21:04,940
generally recommended way is you find

00:21:02,899 --> 00:21:07,130
that you've got a binary file you post

00:21:04,940 --> 00:21:09,380
it to the tikka server get back the

00:21:07,130 --> 00:21:11,029
response hand that off to your search

00:21:09,380 --> 00:21:12,980
engine and then if it all goes horribly

00:21:11,029 --> 00:21:14,510
wrong you've not just wiped out a third

00:21:12,980 --> 00:21:19,490
of your elastic search cluster which is

00:21:14,510 --> 00:21:21,470
not ideal there's a fair bit of

00:21:19,490 --> 00:21:23,840
documentation available on the wiki

00:21:21,470 --> 00:21:25,039
about it or alternatively if you just

00:21:23,840 --> 00:21:27,140
launch it and go to it in your web

00:21:25,039 --> 00:21:30,399
browser it'll tell you in summary what

00:21:27,140 --> 00:21:33,049
all the endpoints are and what they do

00:21:30,399 --> 00:21:34,970
for those of you who are running in Java

00:21:33,049 --> 00:21:36,770
and want something nice and simple the

00:21:34,970 --> 00:21:38,929
tikka facade is the easiest way to call

00:21:36,770 --> 00:21:41,480
it it has methods there that say you

00:21:38,929 --> 00:21:44,419
know I have an input stream and I want

00:21:41,480 --> 00:21:47,210
plain text I have a file and I want

00:21:44,419 --> 00:21:50,929
XHTML so you're just very simple method

00:21:47,210 --> 00:21:53,000
calls the only downside of the tikka

00:21:50,929 --> 00:21:55,520
facade because it's all nicely wrapped

00:21:53,000 --> 00:21:58,490
up in for you is there's no easy way to

00:21:55,520 --> 00:21:59,739
say did I forget to give you half the

00:21:58,490 --> 00:22:01,789
jars

00:21:59,739 --> 00:22:05,450
what will happen is that you'll give

00:22:01,789 --> 00:22:08,119
tika an inputstream and get back nothing

00:22:05,450 --> 00:22:09,379
and the reason you got back nothing is

00:22:08,119 --> 00:22:11,090
you didn't have any of the required

00:22:09,379 --> 00:22:12,769
Giles there to handle that file format

00:22:11,090 --> 00:22:15,110
so TQ will have worked out what it was

00:22:12,769 --> 00:22:16,970
and then said well this is a PDF and

00:22:15,110 --> 00:22:21,889
I've got no PDF library so I can't help

00:22:16,970 --> 00:22:25,009
sorry the direct calls calling all to

00:22:21,889 --> 00:22:27,200
detect parser with ticker input streams

00:22:25,009 --> 00:22:29,299
with the Tiki config gives you full

00:22:27,200 --> 00:22:32,690
control lets you do exactly what you

00:22:29,299 --> 00:22:34,489
want to do and also you can ask the

00:22:32,690 --> 00:22:36,799
config object what passes did you find

00:22:34,489 --> 00:22:38,840
what mimetypes did you find and if he

00:22:36,799 --> 00:22:41,090
comes back and says I know about three

00:22:38,840 --> 00:22:43,669
mine types and you'd be like well where

00:22:41,090 --> 00:22:45,379
did the other 1400 mine pipes go maybe

00:22:43,669 --> 00:22:47,299
we stuff something up in the deployment

00:22:45,379 --> 00:22:48,799
or you ask you about what passes it

00:22:47,299 --> 00:22:50,869
supports and it comes back saying three

00:22:48,799 --> 00:22:52,159
not 70 again there's a reasonable chance

00:22:50,869 --> 00:22:57,320
that something went wrong in their

00:22:52,159 --> 00:22:59,749
deployment and you can then fix that as

00:22:57,320 --> 00:23:02,239
a mentioned because tikka wraps a lot of

00:22:59,749 --> 00:23:03,679
these other libraries for you there's a

00:23:02,239 --> 00:23:05,509
lot of these dependencies that need to

00:23:03,679 --> 00:23:07,759
be present at runtime for it to work and

00:23:05,509 --> 00:23:09,559
so a lot of the things that go wrong for

00:23:07,759 --> 00:23:12,080
people seem to be when their deployment

00:23:09,559 --> 00:23:15,259
system deploys ticker and mrs. all the

00:23:12,080 --> 00:23:17,690
rest now another thing you might be

00:23:15,259 --> 00:23:20,330
interested in is the forked parser which

00:23:17,690 --> 00:23:22,399
fires off a separate JVM to do the

00:23:20,330 --> 00:23:24,950
passing so that if something goes wrong

00:23:22,399 --> 00:23:32,899
with tika it's a set of a JVM that falls

00:23:24,950 --> 00:23:34,789
over not your main one okay another

00:23:32,899 --> 00:23:36,559
thing to flag off about tika is it tries

00:23:34,789 --> 00:23:38,210
to be consistent across all the file

00:23:36,559 --> 00:23:40,580
formats mapping all the different

00:23:38,210 --> 00:23:44,239
metadata onto their common things giving

00:23:40,580 --> 00:23:47,389
you simple HTML back simple plain text

00:23:44,239 --> 00:23:49,190
back so the word parser will tell you

00:23:47,389 --> 00:23:51,859
that it's a table it will tell you that

00:23:49,190 --> 00:23:55,220
this is a heading 1 but it won't do word

00:23:51,859 --> 00:23:58,549
style save as HTML all the bold italic

00:23:55,220 --> 00:24:00,139
random styling things which is probably

00:23:58,549 --> 00:24:02,509
a good thing for most of you because

00:24:00,139 --> 00:24:05,029
you're mostly interested in search but

00:24:02,509 --> 00:24:06,710
if you want to do a rich preview of the

00:24:05,029 --> 00:24:08,389
search results be aware that some of

00:24:06,710 --> 00:24:11,410
that information will have been thrown

00:24:08,389 --> 00:24:14,200
away by default and if you really need

00:24:11,410 --> 00:24:15,370
to show that that bit of text was in red

00:24:14,200 --> 00:24:20,230
then you might need to use a different

00:24:15,370 --> 00:24:21,880
different parser I won't mention too

00:24:20,230 --> 00:24:24,370
much on extending ticker just to mention

00:24:21,880 --> 00:24:26,260
that if you have your own mimetypes that

00:24:24,370 --> 00:24:27,820
aren't supported out the box you can

00:24:26,260 --> 00:24:30,070
just drop an extra file onto the glass

00:24:27,820 --> 00:24:35,230
path and take your pick that up and add

00:24:30,070 --> 00:24:37,780
in your Union mine types and the tikka

00:24:35,230 --> 00:24:39,910
has 70 formats with their own passes

00:24:37,780 --> 00:24:42,070
available out of the box and if you need

00:24:39,910 --> 00:24:44,620
to add a new one it's only 13 lines of

00:24:42,070 --> 00:24:46,540
code plus whatever is required for your

00:24:44,620 --> 00:24:48,850
file format which is going to be more

00:24:46,540 --> 00:24:50,440
work but if there's a particular file

00:24:48,850 --> 00:24:52,530
format that you're dealing with a lot in

00:24:50,440 --> 00:24:55,090
your environment where you've may be

00:24:52,530 --> 00:24:56,710
licensed in or written your own parser

00:24:55,090 --> 00:24:58,210
your own library for dealing that file

00:24:56,710 --> 00:25:02,710
format it's fairly easy to then plug

00:24:58,210 --> 00:25:05,920
that into tikka and start indexing okay

00:25:02,710 --> 00:25:08,830
quick note on embedded resources it's

00:25:05,920 --> 00:25:10,690
not just containers if you've got an

00:25:08,830 --> 00:25:12,760
office document you can put images in it

00:25:10,690 --> 00:25:17,830
you can put other office documents

00:25:12,760 --> 00:25:20,800
inside it teka will try and tell you

00:25:17,830 --> 00:25:22,180
where it found an embedded resource and

00:25:20,800 --> 00:25:24,460
give you a way to get that embedded

00:25:22,180 --> 00:25:27,190
resource and it's then up to you how you

00:25:24,460 --> 00:25:30,670
handle it maybe you'll want to inline

00:25:27,190 --> 00:25:32,470
all the text from that embedded office

00:25:30,670 --> 00:25:34,030
document in another office document or

00:25:32,470 --> 00:25:35,890
maybe you want to treat them as separate

00:25:34,030 --> 00:25:38,350
resources and index them separately or

00:25:35,890 --> 00:25:43,210
stall them separately that's that's a

00:25:38,350 --> 00:25:48,760
choice that you can make okay how does

00:25:43,210 --> 00:25:50,320
it all go wrong ok so at scale you're

00:25:48,760 --> 00:25:52,270
going to crumb across a lot of junk

00:25:50,320 --> 00:25:54,280
documents or the corrupt documents a lot

00:25:52,270 --> 00:25:56,770
of messed up documents you're going to

00:25:54,280 --> 00:25:58,930
hit a lot of edge cases and one percent

00:25:56,770 --> 00:26:01,390
of the internet is still a very large

00:25:58,930 --> 00:26:03,670
amount of data so you're going to have

00:26:01,390 --> 00:26:06,580
to plan for files that are going to be

00:26:03,670 --> 00:26:09,940
misidentified files that are going to

00:26:06,580 --> 00:26:13,470
trigger weird bugs in the libraries just

00:26:09,940 --> 00:26:17,020
going to have to plan for failure so as

00:26:13,470 --> 00:26:21,660
you're passing your particular set of

00:26:17,020 --> 00:26:24,340
data you're going to get a lot of files

00:26:21,660 --> 00:26:26,860
that are not supported

00:26:24,340 --> 00:26:28,900
that haven't actually got any mind type

00:26:26,860 --> 00:26:32,230
defined for them maybe a some new type

00:26:28,900 --> 00:26:34,830
of file so one thing I'd suggest is if

00:26:32,230 --> 00:26:38,380
tika can't work out what your file is

00:26:34,830 --> 00:26:39,820
log the first few bites there's a

00:26:38,380 --> 00:26:41,380
reasonable chance that they'll contain

00:26:39,820 --> 00:26:44,470
something a bit like a magic number and

00:26:41,380 --> 00:26:47,320
then maybe once a month once every six

00:26:44,470 --> 00:26:50,679
months go through and identify the most

00:26:47,320 --> 00:26:53,770
common bite patterns and use that to

00:26:50,679 --> 00:26:55,900
work out where to spend your time don't

00:26:53,770 --> 00:26:58,630
just say the first file that we couldn't

00:26:55,900 --> 00:27:01,779
identify was food up in so let's work on

00:26:58,630 --> 00:27:03,549
that you want to look at it and go three

00:27:01,779 --> 00:27:05,380
percent of the files couldn't be indexed

00:27:03,549 --> 00:27:06,880
but they all have the same white patent

00:27:05,380 --> 00:27:08,830
at the start so maybe that's a whole new

00:27:06,880 --> 00:27:11,110
file format that we want to go off and

00:27:08,830 --> 00:27:14,770
add supporting so then we can index it

00:27:11,110 --> 00:27:16,510
better search it better if Deacon knows

00:27:14,770 --> 00:27:17,770
what the file is but has no passes and

00:27:16,510 --> 00:27:19,899
that's easy you know just lock the mime

00:27:17,770 --> 00:27:21,549
type and then go on adding a parcel

00:27:19,899 --> 00:27:22,779
later but a lot of what you'll come

00:27:21,549 --> 00:27:25,330
across you'd be like I don't actually

00:27:22,779 --> 00:27:26,620
know what this is but I've got ten

00:27:25,330 --> 00:27:28,360
million of them so maybe it's worth

00:27:26,620 --> 00:27:34,000
spending some time finding out what's

00:27:28,360 --> 00:27:35,860
going on so sometimes teka will miss

00:27:34,000 --> 00:27:39,070
identify your file and will hand it off

00:27:35,860 --> 00:27:41,230
to the wrong passer and so some of those

00:27:39,070 --> 00:27:44,429
files can then cause the the passes to

00:27:41,230 --> 00:27:48,880
do silly things if you manage to break

00:27:44,429 --> 00:27:52,059
teka with a file you can share please

00:27:48,880 --> 00:27:53,590
tell us and we want to work on it the

00:27:52,059 --> 00:27:55,990
problem comes is we sometimes get bug

00:27:53,590 --> 00:27:58,330
reports sometimes a document you can't

00:27:55,990 --> 00:28:01,929
have that I can't even find sometimes

00:27:58,330 --> 00:28:03,399
breaks things not really an ideal bug

00:28:01,929 --> 00:28:04,929
report but if there's any of you out

00:28:03,399 --> 00:28:07,360
there who are crawling the internet if

00:28:04,929 --> 00:28:09,789
you can come to us and say sometimes

00:28:07,360 --> 00:28:11,679
this file here at this URL that's

00:28:09,789 --> 00:28:13,059
publicly available breaks that's awesome

00:28:11,679 --> 00:28:16,059
because we can use that in a test case

00:28:13,059 --> 00:28:17,980
we can build on top of that but do be

00:28:16,059 --> 00:28:21,370
aware that every so often you will get

00:28:17,980 --> 00:28:25,419
an out memory you will get a hang and if

00:28:21,370 --> 00:28:27,549
the file fails once because of one of

00:28:25,419 --> 00:28:29,500
these errors and you're running on top

00:28:27,549 --> 00:28:31,299
of a clustering system something like

00:28:29,500 --> 00:28:35,049
Hadoop or storm that's going to keep

00:28:31,299 --> 00:28:37,390
retrying if the problem is with the file

00:28:35,049 --> 00:28:38,269
then every time you give that file to

00:28:37,390 --> 00:28:40,009
another no

00:28:38,269 --> 00:28:43,190
you're going to wipe out that node as

00:28:40,009 --> 00:28:47,029
well so maybe you want to say for these

00:28:43,190 --> 00:28:48,469
kinds of errors just give up but look it

00:28:47,029 --> 00:28:49,940
because maybe when you upgrade to the

00:28:48,469 --> 00:28:52,580
new version of the library and we fix

00:28:49,940 --> 00:28:54,709
that bug then you want to retry all of

00:28:52,580 --> 00:28:57,169
those failed files so I know some

00:28:54,709 --> 00:28:59,719
content management systems that build on

00:28:57,169 --> 00:29:03,409
top of tika have a special marker where

00:28:59,719 --> 00:29:05,899
if they can't index the file they put a

00:29:03,409 --> 00:29:07,399
marker in the database that says there's

00:29:05,899 --> 00:29:09,559
stuff in this file that we can't handle

00:29:07,399 --> 00:29:11,299
so that when you do an upgrade you can

00:29:09,559 --> 00:29:13,009
then retry all of those files and see if

00:29:11,299 --> 00:29:16,489
you can now start indexing some more of

00:29:13,009 --> 00:29:19,309
them so don't think of it as a permanent

00:29:16,489 --> 00:29:21,289
failure be aware that mere maybe in six

00:29:19,309 --> 00:29:23,389
months time you can you get a search

00:29:21,289 --> 00:29:24,469
those files and especially if it was the

00:29:23,389 --> 00:29:26,269
file format that you couldn't identify

00:29:24,469 --> 00:29:28,549
before and you've now under support for

00:29:26,269 --> 00:29:30,379
you're going to want to go through re

00:29:28,549 --> 00:29:35,869
add them into your index and expand your

00:29:30,379 --> 00:29:38,059
index coverage and because occasionally

00:29:35,869 --> 00:29:39,979
t he will break your jvm seriously

00:29:38,059 --> 00:29:43,940
consider putting it in a in a separate

00:29:39,979 --> 00:29:46,159
and separate JVM separate process but

00:29:43,940 --> 00:29:48,829
then if it's a very rare thing maybe

00:29:46,159 --> 00:29:49,969
have a pool of tika servers if it's a

00:29:48,829 --> 00:29:51,259
really really rare thing that you're

00:29:49,969 --> 00:29:53,539
calling teak and maybe it's not the end

00:29:51,259 --> 00:29:55,789
of the world if every so often your jvm

00:29:53,539 --> 00:30:00,139
dies but if you're making heavy use of

00:29:55,789 --> 00:30:01,429
it if you're doing a web-scale cruel and

00:30:00,139 --> 00:30:02,779
a lot of the files you're coming across

00:30:01,429 --> 00:30:04,729
they're going to be binary that you

00:30:02,779 --> 00:30:06,379
going to be passing through tika think

00:30:04,729 --> 00:30:12,769
about separating an outfit when it all

00:30:06,379 --> 00:30:16,399
goes horribly wrong okay this is a bit

00:30:12,769 --> 00:30:21,559
of an extreme example the top is what it

00:30:16,399 --> 00:30:23,719
looks like in Adobe Acrobat the bottom

00:30:21,559 --> 00:30:26,059
is what it looked like when sent through

00:30:23,719 --> 00:30:28,549
Apache pdfbox when there was a

00:30:26,059 --> 00:30:32,659
particular nasty bug that was causing

00:30:28,549 --> 00:30:34,399
corruption and one of the things that

00:30:32,659 --> 00:30:37,309
PDF file format does to improve

00:30:34,399 --> 00:30:39,769
efficiency is it will remap some of the

00:30:37,309 --> 00:30:41,570
characters on to more common short forms

00:30:39,769 --> 00:30:44,209
so that it's a moral compressed encoding

00:30:41,570 --> 00:30:46,879
and then at extraction time you have to

00:30:44,209 --> 00:30:50,329
go bite position to actually maps onto

00:30:46,879 --> 00:30:52,039
this file this this character here and

00:30:50,329 --> 00:30:56,869
if that goes wrong then you end up with

00:30:52,039 --> 00:31:00,320
garbage coming out rare but not unheard

00:30:56,869 --> 00:31:01,970
of and it's going to be hard if you're

00:31:00,320 --> 00:31:06,109
just blindly indexing it to them make

00:31:01,970 --> 00:31:07,759
sense of it another problem don't know

00:31:06,109 --> 00:31:10,759
if you can see in the background here

00:31:07,759 --> 00:31:13,639
this is from someone CV so that there is

00:31:10,759 --> 00:31:19,039
their statement of work and then this is

00:31:13,639 --> 00:31:22,399
all of their job experience another PDF

00:31:19,039 --> 00:31:26,440
bug here the bit in bold is all that we

00:31:22,399 --> 00:31:26,440
were able to pull out of this person CV

00:31:26,889 --> 00:31:35,450
it's very hard to search for missing

00:31:30,499 --> 00:31:37,519
text searching for a negative is hard so

00:31:35,450 --> 00:31:40,309
if you were just running searches to

00:31:37,519 --> 00:31:41,479
check the data was coming through it's

00:31:40,309 --> 00:31:43,519
going to be a really tough problem to

00:31:41,479 --> 00:31:44,809
spot that something's gone wrong and you

00:31:43,519 --> 00:31:49,549
didn't get that piece of data in the

00:31:44,809 --> 00:31:51,470
first place obviously you can't look at

00:31:49,549 --> 00:31:56,509
every single document your indexing by I

00:31:51,470 --> 00:31:58,399
and compare it side-by-side but you need

00:31:56,509 --> 00:32:05,139
to be aware that if its information has

00:31:58,399 --> 00:32:07,190
been lost it's very hard to spot that so

00:32:05,139 --> 00:32:08,720
some of the things that will go wrong

00:32:07,190 --> 00:32:10,609
already mention all the out memory the

00:32:08,720 --> 00:32:12,979
infinite hangs memory leaks running out

00:32:10,609 --> 00:32:14,479
for our handles and stuff exceptions are

00:32:12,979 --> 00:32:18,950
easy because you can catch them and lock

00:32:14,479 --> 00:32:21,309
them if there is missing text or missing

00:32:18,950 --> 00:32:24,399
method ater that's hard to spot

00:32:21,309 --> 00:32:27,019
sometimes you'll get extra text and

00:32:24,399 --> 00:32:30,200
there was a bug recently in the power

00:32:27,019 --> 00:32:32,090
point extraction where we got bit

00:32:30,200 --> 00:32:34,519
overzealous and started pulling through

00:32:32,090 --> 00:32:38,960
all of the placeholder information from

00:32:34,519 --> 00:32:40,549
the slide masters it's not that bad

00:32:38,960 --> 00:32:43,460
really if you pull out extra information

00:32:40,549 --> 00:32:45,799
but it can then mess up some of your

00:32:43,460 --> 00:32:48,769
counts so if you say oh well the most

00:32:45,799 --> 00:32:52,580
common word in this PowerPoint used to

00:32:48,769 --> 00:32:56,299
be buzz words but now it's insert text

00:32:52,580 --> 00:32:58,399
here yeah it's going to mess with

00:32:56,299 --> 00:33:01,999
statistics that's not too bad the gobble

00:32:58,399 --> 00:33:04,269
text is a pretty bad one rare but does

00:33:01,999 --> 00:33:04,269
happen

00:33:05,399 --> 00:33:09,759
within tikka and hopefully within a lot

00:33:08,080 --> 00:33:11,710
of your applications as well you can

00:33:09,759 --> 00:33:14,320
have unit tests and they're going to

00:33:11,710 --> 00:33:17,769
tell you if anything really obvious has

00:33:14,320 --> 00:33:19,239
broken but probably you're earning on

00:33:17,769 --> 00:33:25,719
how handful of files available that you

00:33:19,239 --> 00:33:29,080
can test against really you're going to

00:33:25,719 --> 00:33:31,899
want to run testing on a much larger

00:33:29,080 --> 00:33:33,820
scale but if you've got 10 documents you

00:33:31,899 --> 00:33:36,039
can check them I i if you've got 10 gig

00:33:33,820 --> 00:33:37,419
you can't if you've got terabytes

00:33:36,039 --> 00:33:39,070
there's no way you've ever going to be

00:33:37,419 --> 00:33:42,339
able to check that except with another

00:33:39,070 --> 00:33:46,899
computer process you need to be aware

00:33:42,339 --> 00:33:48,789
that file distributions are uneven the

00:33:46,899 --> 00:33:50,710
kind of files that you are dealing with

00:33:48,789 --> 00:33:52,539
are not necessarily the kind of files

00:33:50,710 --> 00:33:54,219
that they're dealing with are not

00:33:52,539 --> 00:33:57,489
necessarily the kind of files that are

00:33:54,219 --> 00:33:59,830
in my unit test suite so something that

00:33:57,489 --> 00:34:02,789
will pass and go green for me is not

00:33:59,830 --> 00:34:06,339
necessarily going to be awesome for you

00:34:02,789 --> 00:34:07,690
so you can't completely share that the

00:34:06,339 --> 00:34:09,849
test systems and you are going to need

00:34:07,690 --> 00:34:11,349
to check even though teka have released

00:34:09,849 --> 00:34:12,970
it and it's all gone green and then

00:34:11,349 --> 00:34:14,260
notch included it and that was all grain

00:34:12,970 --> 00:34:19,329
that doesn't necessarily mean it's going

00:34:14,260 --> 00:34:22,960
to be error free so you can need to do

00:34:19,329 --> 00:34:25,750
automation of the running and of the

00:34:22,960 --> 00:34:27,339
analysis so if it's just a number of

00:34:25,750 --> 00:34:31,179
exceptions that's pretty easy because

00:34:27,339 --> 00:34:32,710
you can log them metadata is relatively

00:34:31,179 --> 00:34:34,480
easy because there's not much metadata

00:34:32,710 --> 00:34:36,549
right each file so you can maybe log

00:34:34,480 --> 00:34:38,889
that for a subset of your files and then

00:34:36,549 --> 00:34:40,299
check between two versions that you're

00:34:38,889 --> 00:34:45,339
still getting about the same amount of

00:34:40,299 --> 00:34:46,869
stuff out attachment counts easy this

00:34:45,339 --> 00:34:50,260
word document used to have three

00:34:46,869 --> 00:34:51,609
attachments now it's got none probably

00:34:50,260 --> 00:34:55,299
that's a bad thing or something's gone

00:34:51,609 --> 00:34:58,420
wrong and you need to look at it junk

00:34:55,299 --> 00:35:01,539
text is relatively easy because you can

00:34:58,420 --> 00:35:03,549
look at the entropy and you can look at

00:35:01,539 --> 00:35:07,420
the common words and if the common word

00:35:03,549 --> 00:35:11,510
for your document used to be forests and

00:35:07,420 --> 00:35:14,000
meadows and now it's Eirik

00:35:11,510 --> 00:35:19,610
work probably that's that's a sign that

00:35:14,000 --> 00:35:22,550
something's gone horribly wrong missing

00:35:19,610 --> 00:35:23,870
text is a real tough one if you look at

00:35:22,550 --> 00:35:26,000
it by eye you can spot that but

00:35:23,870 --> 00:35:32,600
otherwise and how are you going to work

00:35:26,000 --> 00:35:36,050
it out and at the moment for testing

00:35:32,600 --> 00:35:40,070
tikka we're using Gulf docks one which

00:35:36,050 --> 00:35:41,750
is from 2009 and therefore is missing a

00:35:40,070 --> 00:35:43,760
lot of the new file formats and we're

00:35:41,750 --> 00:35:47,410
using some stuff in common cruel but if

00:35:43,760 --> 00:35:50,500
any of you have large data sets of

00:35:47,410 --> 00:35:52,730
binary files that you can share with us

00:35:50,500 --> 00:35:54,320
we do really like them so that we can

00:35:52,730 --> 00:35:59,720
run the kind of automated analysis on

00:35:54,320 --> 00:36:01,430
them one of the things that um nope

00:35:59,720 --> 00:36:05,980
where are we one of the things we're

00:36:01,430 --> 00:36:09,590
doing is with the tikka eval tool is we

00:36:05,980 --> 00:36:12,140
run for hours and hours and hours of

00:36:09,590 --> 00:36:14,210
machine time tikka at different versions

00:36:12,140 --> 00:36:17,390
and we different proposed patches in

00:36:14,210 --> 00:36:20,060
against large corpuses and then we

00:36:17,390 --> 00:36:22,640
report the number of exceptions found

00:36:20,060 --> 00:36:24,440
and the occurrences of them and we

00:36:22,640 --> 00:36:26,180
report the most common words for certain

00:36:24,440 --> 00:36:31,250
file formats and then we check that

00:36:26,180 --> 00:36:33,770
between two different runs so if someone

00:36:31,250 --> 00:36:36,110
proposes a patch we can then see whether

00:36:33,770 --> 00:36:41,330
or not it is on the whole got better or

00:36:36,110 --> 00:36:43,340
worse which tends to mean ideally that

00:36:41,330 --> 00:36:45,590
we can catch a lot of these bugs which

00:36:43,340 --> 00:36:48,830
would cause the PDF to come out like

00:36:45,590 --> 00:36:51,770
that before we apply it and before you

00:36:48,830 --> 00:36:55,190
start deploying onto your cluster but if

00:36:51,770 --> 00:36:56,660
you've got a lot of custom passes that

00:36:55,190 --> 00:36:58,070
you're adding in for a custom file

00:36:56,660 --> 00:37:00,350
formats you might want to look at

00:36:58,070 --> 00:37:02,450
running this and just look at the

00:37:00,350 --> 00:37:04,040
results and say did it get better did it

00:37:02,450 --> 00:37:07,580
get worse how did it get rid of how did

00:37:04,040 --> 00:37:10,340
it get worse it's not going to tell you

00:37:07,580 --> 00:37:12,110
for certain if it's better but it's

00:37:10,340 --> 00:37:14,750
going to give you a very narrow set of

00:37:12,110 --> 00:37:17,540
things that you as a human can go and

00:37:14,750 --> 00:37:19,580
check the top ten most common problems

00:37:17,540 --> 00:37:21,560
the top ten most common differences

00:37:19,580 --> 00:37:23,510
between these two things that's great

00:37:21,560 --> 00:37:25,130
because you can look at it and go that's

00:37:23,510 --> 00:37:26,509
fine that's fine that's not

00:37:25,130 --> 00:37:28,609
end of the world or we need to solve

00:37:26,509 --> 00:37:31,490
that one you couldn't look at a million

00:37:28,609 --> 00:37:34,309
documents but you can look at 10 common

00:37:31,490 --> 00:37:37,309
repeating failures and analyze that and

00:37:34,309 --> 00:37:39,140
then decide what to work on so whatever

00:37:37,309 --> 00:37:41,119
you're doing with your kind of analysis

00:37:39,140 --> 00:37:44,210
pipelines and so on eating is worth

00:37:41,119 --> 00:37:46,160
trying to summarize them as you're going

00:37:44,210 --> 00:37:48,410
to have too many errors to look at but

00:37:46,160 --> 00:37:50,960
if you can get a common subset together

00:37:48,410 --> 00:37:52,880
and then once a month or once a week or

00:37:50,960 --> 00:37:54,650
once every six months you spend some

00:37:52,880 --> 00:37:56,000
time and look at that you can tackle the

00:37:54,650 --> 00:37:57,859
most important things and you can

00:37:56,000 --> 00:38:02,960
improve the quality that way rather than

00:37:57,859 --> 00:38:05,960
picking one at random teka batch is

00:38:02,960 --> 00:38:09,680
what's powering teka eval at the moment

00:38:05,960 --> 00:38:11,119
it's only running on a single machine it

00:38:09,680 --> 00:38:14,450
spawns off a whole bunch of different

00:38:11,119 --> 00:38:16,069
ones there is work on going at the

00:38:14,450 --> 00:38:18,140
moment we were hoping it was going to

00:38:16,069 --> 00:38:20,539
finish now but it hasn't been to get it

00:38:18,140 --> 00:38:24,319
working on Hadoop so that you could say

00:38:20,539 --> 00:38:26,210
tikka here is an HDFS area I want you to

00:38:24,319 --> 00:38:28,880
run do all the analysis and give me a

00:38:26,210 --> 00:38:30,559
nice summary out afterwards and there's

00:38:28,880 --> 00:38:33,049
also some work going on to make it work

00:38:30,559 --> 00:38:35,390
on storm the same kind of thing here is

00:38:33,049 --> 00:38:37,730
a million documents go off and process

00:38:35,390 --> 00:38:39,559
them and give me the text so I can then

00:38:37,730 --> 00:38:41,000
feed into and index and give me the

00:38:39,559 --> 00:38:43,759
metadata that can go into the index and

00:38:41,000 --> 00:38:45,740
tell me what went wrong if you're

00:38:43,759 --> 00:38:48,710
wanting to do that now and you wanting

00:38:45,740 --> 00:38:50,210
to run on top of Hadoop have a look at

00:38:48,710 --> 00:38:53,089
this wiki page here it's got a whole lot

00:38:50,210 --> 00:38:57,140
of pointers or alternatively just use

00:38:53,089 --> 00:38:58,880
BMS which is a text indexing and

00:38:57,140 --> 00:39:00,349
processing suite that can also do some

00:38:58,880 --> 00:39:02,809
natural language processing at the same

00:39:00,349 --> 00:39:04,700
time that starts off with very large

00:39:02,809 --> 00:39:09,190
collections documents and outputs very

00:39:04,700 --> 00:39:12,799
large collections of useful information

00:39:09,190 --> 00:39:14,509
um got mount a minute left so I'm just

00:39:12,799 --> 00:39:16,039
going to mention these are some of the

00:39:14,509 --> 00:39:19,220
other Apache projects you might be

00:39:16,039 --> 00:39:22,759
interested in notch is the Hadoop

00:39:19,220 --> 00:39:25,160
powered web crawler and then indexing

00:39:22,759 --> 00:39:26,809
analysis storm crawl there's a talk on

00:39:25,160 --> 00:39:30,440
that a bit later on that's looking to

00:39:26,809 --> 00:39:32,269
reimplement notch on top of storm ne23

00:39:30,440 --> 00:39:35,599
is great if you've got a lot of triples

00:39:32,269 --> 00:39:37,609
a lot of semantic data open NLP and you

00:39:35,599 --> 00:39:38,119
EEMA a great for the natural language

00:39:37,609 --> 00:39:40,309
processing

00:39:38,119 --> 00:39:42,230
so once you've taken your word document

00:39:40,309 --> 00:39:43,700
and you've pulled out some useful text

00:39:42,230 --> 00:39:45,890
you might then want to do some sentiment

00:39:43,700 --> 00:39:47,259
analysis and find what sort of things

00:39:45,890 --> 00:39:49,759
they're talking about in this document

00:39:47,259 --> 00:39:52,009
sea takes is great for anyone in the

00:39:49,759 --> 00:39:53,900
medical or farm of space that takes

00:39:52,009 --> 00:39:55,910
things like open NLP and you eema and

00:39:53,900 --> 00:39:57,920
has a training data set already

00:39:55,910 --> 00:40:00,200
available so that you can then just use

00:39:57,920 --> 00:40:03,460
it batteries included then if there's

00:40:00,200 --> 00:40:03,460
any other ones people want to suggest

00:40:03,579 --> 00:40:10,579
for non Apache stuff there's the

00:40:07,490 --> 00:40:12,980
hardened tikka project there's bmus if

00:40:10,579 --> 00:40:16,670
you're doing any of the language

00:40:12,980 --> 00:40:18,619
detection and encoding detection those

00:40:16,670 --> 00:40:21,460
three lengths the tools may be slightly

00:40:18,619 --> 00:40:21,460

YouTube URL: https://www.youtube.com/watch?v=oxiXxUtvgnQ


