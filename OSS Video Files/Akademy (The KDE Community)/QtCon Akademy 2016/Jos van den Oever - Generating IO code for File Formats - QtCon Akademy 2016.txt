Title: Jos van den Oever - Generating IO code for File Formats - QtCon Akademy 2016
Publication date: 2016-09-04
Playlist: QtCon Akademy 2016
Description: 
	New file formats are created every day and new programming languages come into being quickly. It is not feasible to write (de)serialization code for all formats in each language. It is better to generate code from a description of the file format.

vandenoever
Captions: 
	00:00:04,640 --> 00:00:10,849
welcome Yeltsin with this generating I

00:00:07,230 --> 00:00:10,849
yo code for farmall formats talk

00:00:13,419 --> 00:00:22,849
good morning everyone welcome to the

00:00:17,060 --> 00:00:24,140
sunday lecture I'm gonna yes I I will be

00:00:22,849 --> 00:00:27,529
like chewing it's Sunday morning that's

00:00:24,140 --> 00:00:32,000
just a coincidence I had a bit of deja

00:00:27,529 --> 00:00:34,070
vu just now because about 10 years ago I

00:00:32,000 --> 00:00:36,110
also gave a talk just after Marco when

00:00:34,070 --> 00:00:38,329
he was talking about Red River so it was

00:00:36,110 --> 00:00:40,879
a kind of interesting and it's good to

00:00:38,329 --> 00:00:43,640
see the that library is still going

00:00:40,879 --> 00:00:46,280
strong but now we go to a very different

00:00:43,640 --> 00:00:50,750
topic namely generating i/o code for

00:00:46,280 --> 00:00:53,239
file formats and in my opinion this is

00:00:50,750 --> 00:00:55,880
the main message of my lecture today do

00:00:53,239 --> 00:01:01,550
not write this utilization code just

00:00:55,880 --> 00:01:03,530
don't don't do it why well first let's

00:01:01,550 --> 00:01:05,239
talk about what is this organization I

00:01:03,530 --> 00:01:08,479
guess everybody knows you have a file

00:01:05,239 --> 00:01:12,110
which is a series of ones and zeros and

00:01:08,479 --> 00:01:21,979
you can read them I write them and that

00:01:12,110 --> 00:01:28,749
was the end I think this connector is a

00:01:21,979 --> 00:01:28,749
bit loose so yes I should hold it wow I

00:01:32,319 --> 00:01:42,409
try not to move ok man i'll be careful

00:01:37,219 --> 00:01:44,420
with the set this turned from its

00:01:42,409 --> 00:01:55,810
lecture from a sermon into a comedy act

00:01:44,420 --> 00:01:57,250
i'm afraid then ok yeah I'll just I

00:01:55,810 --> 00:01:58,930
studied it

00:01:57,250 --> 00:02:01,450
with the phone I hope that's good enough

00:01:58,930 --> 00:02:03,220
so yeah so you have a file with serious

00:02:01,450 --> 00:02:04,840
zeros or ones and you read it into a

00:02:03,220 --> 00:02:06,880
runtime structure in your program and

00:02:04,840 --> 00:02:11,470
you can write it out and then you

00:02:06,880 --> 00:02:13,570
serialize the data into a file again so

00:02:11,470 --> 00:02:17,800
in other words instead of saying you

00:02:13,570 --> 00:02:19,630
don't write this realization code you

00:02:17,800 --> 00:02:21,670
could also say do not write read write

00:02:19,630 --> 00:02:23,200
code but that's already a bit harder to

00:02:21,670 --> 00:02:25,060
pass because that's too right in there

00:02:23,200 --> 00:02:28,840
so you can see that even for simple

00:02:25,060 --> 00:02:30,940
sentences civilization can be tricky but

00:02:28,840 --> 00:02:33,040
why shouldn't you do it well first of

00:02:30,940 --> 00:02:36,459
all their security and we'll see some

00:02:33,040 --> 00:02:38,470
example an example of how security is

00:02:36,459 --> 00:02:42,070
problematic when you write your own io

00:02:38,470 --> 00:02:44,080
code efficiency can be higher if you do

00:02:42,070 --> 00:02:46,000
not write your own io code and it may

00:02:44,080 --> 00:02:48,220
sound counterintuitive but I think it's

00:02:46,000 --> 00:02:51,220
true the code will be more maintainable

00:02:48,220 --> 00:02:53,709
made more maintainable more readable

00:02:51,220 --> 00:02:56,050
more consistent and on top of that

00:02:53,709 --> 00:02:58,570
porting will be easier if you do not

00:02:56,050 --> 00:03:01,360
write your own io code how can we

00:02:58,570 --> 00:03:03,459
achieve something like that well first

00:03:01,360 --> 00:03:06,070
of all why we do we want to have higher

00:03:03,459 --> 00:03:08,590
security I think that almost all

00:03:06,070 --> 00:03:11,140
security issues today are related to IO

00:03:08,590 --> 00:03:14,980
code so you're reading some file and

00:03:11,140 --> 00:03:18,640
there's a problem in your reading code

00:03:14,980 --> 00:03:20,799
and does a buffer overflow or for

00:03:18,640 --> 00:03:22,600
there's something else going on because

00:03:20,799 --> 00:03:26,500
somebody can give you a file which is

00:03:22,600 --> 00:03:30,910
malicious and exploit just bugs in the

00:03:26,500 --> 00:03:33,579
handwritten IO code so yeah there's a

00:03:30,910 --> 00:03:37,120
good reason to to fix stuff so what's

00:03:33,579 --> 00:03:39,700
the buffer overflow we had a very famous

00:03:37,120 --> 00:03:43,540
buffer overflow a while back called

00:03:39,700 --> 00:03:46,570
heartbleed and here's a very simple XKCD

00:03:43,540 --> 00:03:49,630
explanation and that basically says

00:03:46,570 --> 00:03:52,630
somebody asks the server can you send me

00:03:49,630 --> 00:03:58,160
a message back that this hat and by the

00:03:52,630 --> 00:04:00,590
way hat is a 500 letter word yeah

00:03:58,160 --> 00:04:03,710
obviously had another 500 letter word

00:04:00,590 --> 00:04:06,200
but because the server didn't check that

00:04:03,710 --> 00:04:09,320
head was only five was really 500

00:04:06,200 --> 00:04:13,250
letters it sent 500 letters of a

00:04:09,320 --> 00:04:14,660
different space in memory so the person

00:04:13,250 --> 00:04:18,170
talking to the server could actually

00:04:14,660 --> 00:04:21,230
read chunks of memory out of the server

00:04:18,170 --> 00:04:27,590
very very easily so a huge huge bug

00:04:21,230 --> 00:04:29,480
because of handwritten i/o code can we

00:04:27,590 --> 00:04:32,600
do better yes of course we can do better

00:04:29,480 --> 00:04:35,720
and that's two approaches basically if

00:04:32,600 --> 00:04:39,250
you have a new format a new protocol or

00:04:35,720 --> 00:04:42,770
just a new file format you can use

00:04:39,250 --> 00:04:47,360
existing tools you could use potapov or

00:04:42,770 --> 00:04:51,320
d-bus xml based on which is binary Jason

00:04:47,360 --> 00:04:57,290
CSV I listed these in decreasing order

00:04:51,320 --> 00:05:00,220
of niceness the proto buff actually Maps

00:04:57,290 --> 00:05:04,040
quite well to run time data structures

00:05:00,220 --> 00:05:07,420
so does d-bus xml does not really and

00:05:04,040 --> 00:05:10,370
neither does Jason and see if he doesn't

00:05:07,420 --> 00:05:12,140
map nicely at all that's actually maybe

00:05:10,370 --> 00:05:15,320
that's not a good solution to put on the

00:05:12,140 --> 00:05:16,940
slide at all okay but what if you have

00:05:15,320 --> 00:05:19,190
an existing file format or existing

00:05:16,940 --> 00:05:22,220
protocol you can't just choose a tool

00:05:19,190 --> 00:05:26,030
which maps into it because well many

00:05:22,220 --> 00:05:27,919
file formats were well designed by

00:05:26,030 --> 00:05:30,710
somebody who wanted to get the data in a

00:05:27,919 --> 00:05:32,780
small amount of bytes and didn't

00:05:30,710 --> 00:05:37,820
necessarily think about how to actually

00:05:32,780 --> 00:05:40,330
read that into your computer and usually

00:05:37,820 --> 00:05:42,890
it's hint it's it's it's specified

00:05:40,330 --> 00:05:46,400
readable for humans so the human has to

00:05:42,890 --> 00:05:48,410
then write code to read this file format

00:05:46,400 --> 00:05:51,740
I don't think that's a good idea so what

00:05:48,410 --> 00:05:54,169
you can do better by writing a computer

00:05:51,740 --> 00:05:57,740
readable specification and I'm going to

00:05:54,169 --> 00:05:59,380
show how that works after in the next

00:05:57,740 --> 00:06:01,640
slide and then from that specification

00:05:59,380 --> 00:06:05,120
generate the code instead of writing in

00:06:01,640 --> 00:06:09,289
my hand and your program will look like

00:06:05,120 --> 00:06:10,400
this then you have a file and the file

00:06:09,289 --> 00:06:13,220
format has

00:06:10,400 --> 00:06:16,880
pacification you have generated code

00:06:13,220 --> 00:06:19,280
which is fairly safe at least much safer

00:06:16,880 --> 00:06:21,500
than the handwritten code and therefore

00:06:19,280 --> 00:06:23,900
it forms a security barrier to your

00:06:21,500 --> 00:06:26,990
application logic which just deals with

00:06:23,900 --> 00:06:28,430
the runtime structure so yeah the

00:06:26,990 --> 00:06:30,169
application should be easier to write

00:06:28,430 --> 00:06:34,850
easier to maintain and it should be

00:06:30,169 --> 00:06:37,460
safer by working in this way well let's

00:06:34,850 --> 00:06:40,820
come to a concrete example powerpoints

00:06:37,460 --> 00:06:44,180
binary format that's who's familiar with

00:06:40,820 --> 00:06:46,639
our format here nobody well obviously

00:06:44,180 --> 00:06:49,580
that's I can understand that because why

00:06:46,639 --> 00:06:51,740
would you be interested in this ah but

00:06:49,580 --> 00:06:54,229
it's a very very complex and large file

00:06:51,740 --> 00:06:58,520
format it has 500 different structures

00:06:54,229 --> 00:07:01,580
it's documented in two huge PDF files as

00:06:58,520 --> 00:07:04,310
650 page is approximately each so more

00:07:01,580 --> 00:07:06,410
than a thousand pages in total and to be

00:07:04,310 --> 00:07:10,220
able to read that file format you need a

00:07:06,410 --> 00:07:13,669
huge amount of code so the documentation

00:07:10,220 --> 00:07:15,560
is extensive it's quite detailed but

00:07:13,669 --> 00:07:19,240
also it's not always in accordance with

00:07:15,560 --> 00:07:24,470
the files you find in the wild yeah

00:07:19,240 --> 00:07:26,750
that's partially serialization bugs but

00:07:24,470 --> 00:07:28,490
also there are more programs that

00:07:26,750 --> 00:07:30,470
Microsoft Office trying to create

00:07:28,490 --> 00:07:32,479
PowerPoint files and there was a time

00:07:30,470 --> 00:07:36,310
when the documentation was not released

00:07:32,479 --> 00:07:38,539
and was actually guarded very well and

00:07:36,310 --> 00:07:40,610
still people were trying to write

00:07:38,539 --> 00:07:43,930
PowerPoint files but they were just

00:07:40,610 --> 00:07:46,490
guessing what you should be in them so

00:07:43,930 --> 00:07:51,500
yeah there are files which are slightly

00:07:46,490 --> 00:07:55,150
different than the real format yes I've

00:07:51,500 --> 00:08:02,210
seen situations with roots back yeah I

00:07:55,150 --> 00:08:03,949
predict you for that and will you yeah

00:08:02,210 --> 00:08:05,659
and the spigot in gene be written in

00:08:03,949 --> 00:08:10,580
builder digestion had to be adapted to

00:08:05,659 --> 00:08:13,840
reality yeah I'll just repeat this

00:08:10,580 --> 00:08:16,490
comment here's an observation that the

00:08:13,840 --> 00:08:17,750
people who wrote their own specification

00:08:16,490 --> 00:08:19,340
and were the only people implementing

00:08:17,750 --> 00:08:22,729
that specification still didn't always

00:08:19,340 --> 00:08:24,400
follow it and yeah that I think that's

00:08:22,729 --> 00:08:26,020
that's that's just life

00:08:24,400 --> 00:08:28,479
it happens so you have to build in

00:08:26,020 --> 00:08:31,570
safeguards for that now why am I talking

00:08:28,479 --> 00:08:33,880
about the PowerPoint binary format some

00:08:31,570 --> 00:08:37,120
years ago Loki I wanted to have

00:08:33,880 --> 00:08:39,789
smartphones and they want to have an

00:08:37,120 --> 00:08:41,979
office suite on their smartphones okay

00:08:39,789 --> 00:08:46,080
office at the time these days is called

00:08:41,979 --> 00:08:49,570
caligra was very nicely designed a

00:08:46,080 --> 00:08:51,040
office suite and that nice and small way

00:08:49,570 --> 00:08:52,870
and it should be able to run on a phone

00:08:51,040 --> 00:08:54,880
like this but it didn't have any support

00:08:52,870 --> 00:08:58,270
for PowerPoint files and obviously that

00:08:54,880 --> 00:09:01,300
was a showstopper so it had to be

00:08:58,270 --> 00:09:03,850
written from scratch and I was involved

00:09:01,300 --> 00:09:05,980
in this project so I was faced with all

00:09:03,850 --> 00:09:09,420
these huge pdfs and had to come up with

00:09:05,980 --> 00:09:14,140
a solution to actually read all those

00:09:09,420 --> 00:09:15,839
different structures here's an example

00:09:14,140 --> 00:09:20,170
of what this documentation looks like

00:09:15,839 --> 00:09:22,990
this is a very basic part of the of the

00:09:20,170 --> 00:09:26,279
documentation it's only a couple of

00:09:22,990 --> 00:09:29,200
bites so there's a record header and

00:09:26,279 --> 00:09:31,420
nearly all of the components in the

00:09:29,200 --> 00:09:33,850
PowerPoint file have a header like this

00:09:31,420 --> 00:09:36,610
so it's a very important one it has a

00:09:33,850 --> 00:09:40,120
version number which forbids then an

00:09:36,610 --> 00:09:42,040
instance number twelve bits then two

00:09:40,120 --> 00:09:43,839
bytes for the type of the record that

00:09:42,040 --> 00:09:45,640
follows the header and then the length

00:09:43,839 --> 00:09:48,370
of the header so it's a fairly simple

00:09:45,640 --> 00:09:50,920
and i'm starting with it to show you how

00:09:48,370 --> 00:09:53,580
you can generate codes and how you can

00:09:50,920 --> 00:09:58,420
document this in a computer-readable way

00:09:53,580 --> 00:10:01,300
so this is what i came up with very ad

00:09:58,420 --> 00:10:02,920
hoc for this particular problem i just

00:10:01,300 --> 00:10:05,770
had a bit of XML which said i have

00:10:02,920 --> 00:10:10,540
struct name is record header and here

00:10:05,770 --> 00:10:14,860
are four data components in this in this

00:10:10,540 --> 00:10:17,709
thing and yeah it has you n for which

00:10:14,860 --> 00:10:20,020
means it's these four bits so fairly

00:10:17,709 --> 00:10:22,470
simple and generating code for that is

00:10:20,020 --> 00:10:25,150
also very simple so you have a class

00:10:22,470 --> 00:10:28,839
which inherits from stream offset but

00:10:25,150 --> 00:10:32,410
that's just for debugging purposes and

00:10:28,839 --> 00:10:34,420
it has a queue it has data components

00:10:32,410 --> 00:10:36,530
which in this case a larger then the

00:10:34,420 --> 00:10:40,260
actual dates are reading

00:10:36,530 --> 00:10:41,850
but that could be improved upon actually

00:10:40,260 --> 00:10:44,130
now that I think about it but the code

00:10:41,850 --> 00:10:47,010
to read all of this is below it there's

00:10:44,130 --> 00:10:49,710
a input stream which can read on the on

00:10:47,010 --> 00:10:52,890
the bit level and just right into the

00:10:49,710 --> 00:10:56,130
into the data members so very very very

00:10:52,890 --> 00:10:58,340
simple but the file format is very

00:10:56,130 --> 00:11:01,320
convoluted so you can't get more complex

00:10:58,340 --> 00:11:05,940
situations and here is a mildly complex

00:11:01,320 --> 00:11:10,590
one this is for putting PNG files in

00:11:05,940 --> 00:11:14,730
your PowerPoint it starts with a record

00:11:10,590 --> 00:11:18,450
header that's crh at the top and then it

00:11:14,730 --> 00:11:20,220
has some RGB UID and I gbu 82 but the

00:11:18,450 --> 00:11:21,810
second one is optional so first

00:11:20,220 --> 00:11:24,720
complications some things can be

00:11:21,810 --> 00:11:27,120
optional and then the at the end it has

00:11:24,720 --> 00:11:31,590
a blip file data and that's a variable

00:11:27,120 --> 00:11:34,020
length now how do I know if the optional

00:11:31,590 --> 00:11:35,550
thing is present or not that depends on

00:11:34,020 --> 00:11:39,360
the data that comes before so there'll

00:11:35,550 --> 00:11:42,210
be a bit set which identifies if this

00:11:39,360 --> 00:11:45,060
component is present or not and the

00:11:42,210 --> 00:11:47,220
length of the file data also depends on

00:11:45,060 --> 00:11:51,660
the data before it and the relationship

00:11:47,220 --> 00:11:53,610
is quite complicated in fact if you look

00:11:51,660 --> 00:11:58,050
at the rec length so the length of the

00:11:53,610 --> 00:12:00,030
of this record it depends on some number

00:11:58,050 --> 00:12:01,980
somewhere in the record you don't need

00:12:00,030 --> 00:12:04,920
to understand what they are but you just

00:12:01,980 --> 00:12:06,390
need to understand weird situation this

00:12:04,920 --> 00:12:13,170
is probably going to go wrong if i write

00:12:06,390 --> 00:12:15,660
it by hand so we can capture this in xml

00:12:13,170 --> 00:12:18,900
so the first record you already know the

00:12:15,660 --> 00:12:22,650
second one basically puts limitations on

00:12:18,900 --> 00:12:24,660
what can be in the record so it says the

00:12:22,650 --> 00:12:29,940
first member of the struct office are

00:12:24,660 --> 00:12:32,010
blip should be a record header but it

00:12:29,940 --> 00:12:35,130
has to have a version number of 0 and

00:12:32,010 --> 00:12:37,200
the instance can only be two numbers so

00:12:35,130 --> 00:12:39,540
the pipe in there means either this

00:12:37,200 --> 00:12:42,510
number or that number and the type

00:12:39,540 --> 00:12:44,610
should be exactly this number so when

00:12:42,510 --> 00:12:46,980
you're reading and it you don't fit this

00:12:44,610 --> 00:12:48,130
limitation the parsing will simply stop

00:12:46,980 --> 00:12:51,250
I say I

00:12:48,130 --> 00:12:53,860
don't understand this data another

00:12:51,250 --> 00:12:55,690
useful this is you can have if you have

00:12:53,860 --> 00:12:58,030
an array of objects of which you don't

00:12:55,690 --> 00:13:00,670
know the type you can look at the value

00:12:58,030 --> 00:13:04,870
of the type to see if this structure

00:13:00,670 --> 00:13:10,360
matches the data which follows and then

00:13:04,870 --> 00:13:13,090
you see the RGB uad-2 member it has a

00:13:10,360 --> 00:13:16,000
condition on it so it's only present if

00:13:13,090 --> 00:13:18,970
req instance is equal to a magic number

00:13:16,000 --> 00:13:22,600
over there if it's not then the passing

00:13:18,970 --> 00:13:26,320
simply will skip will just continue

00:13:22,600 --> 00:13:29,920
reading the second or the following data

00:13:26,320 --> 00:13:33,610
structure and at the end we have a

00:13:29,920 --> 00:13:36,760
variable length amount of data and there

00:13:33,610 --> 00:13:39,640
you have actually a small formula which

00:13:36,760 --> 00:13:42,970
gives you what the count of bytes in

00:13:39,640 --> 00:13:48,490
this byte array is and it's also a

00:13:42,970 --> 00:13:51,520
fairly complex statement still it's

00:13:48,490 --> 00:13:54,490
relatively readable even though the

00:13:51,520 --> 00:13:56,320
structure is complex it's certainly more

00:13:54,490 --> 00:13:59,560
readable then the code which is

00:13:56,320 --> 00:14:01,360
generated from it this is the data

00:13:59,560 --> 00:14:04,210
structure so that's still fairly simple

00:14:01,360 --> 00:14:07,990
it's just a translation to C++ with cute

00:14:04,210 --> 00:14:11,170
of the data but if you have the pausing

00:14:07,990 --> 00:14:14,890
code that that's getting long quite long

00:14:11,170 --> 00:14:16,360
already ah it's Sunday morning so I

00:14:14,890 --> 00:14:18,400
don't expect you to read all of this

00:14:16,360 --> 00:14:19,900
it's just showing you that you don't

00:14:18,400 --> 00:14:21,540
want to write this by hand all the time

00:14:19,900 --> 00:14:24,040
and if you were to write this by hand

00:14:21,540 --> 00:14:29,140
either you'll have many bugs or you'll

00:14:24,040 --> 00:14:32,020
have many unit s so the PowerPoint

00:14:29,140 --> 00:14:35,200
binary format example lots of different

00:14:32,020 --> 00:14:38,380
structures and when we were done

00:14:35,200 --> 00:14:40,000
generating we had thirty thousand lines

00:14:38,380 --> 00:14:42,070
of code and colleague adjust to read the

00:14:40,000 --> 00:14:44,200
PowerPoint files and these were

00:14:42,070 --> 00:14:47,680
generated from six thousand lines of

00:14:44,200 --> 00:14:50,410
specification in XML now even that

00:14:47,680 --> 00:14:51,940
specification can add box but if you're

00:14:50,410 --> 00:14:55,840
debugging at least that's fairly

00:14:51,940 --> 00:14:57,940
readable and this is the kicker the code

00:14:55,840 --> 00:14:59,880
to create a thirty-two thousand lines of

00:14:57,940 --> 00:15:03,300
code is only seven hundred lines

00:14:59,880 --> 00:15:05,250
code so that's a very doable number

00:15:03,300 --> 00:15:06,930
right so you have this huge complex file

00:15:05,250 --> 00:15:11,040
format but there's only seven hundred

00:15:06,930 --> 00:15:15,060
lines of code which did determine what

00:15:11,040 --> 00:15:19,110
is actually written and how sorry how am

00:15:15,060 --> 00:15:21,360
i reading my file now if you go back to

00:15:19,110 --> 00:15:25,350
this generated code the way I'm reading

00:15:21,360 --> 00:15:26,790
it here and I'm using a particular type

00:15:25,350 --> 00:15:29,340
of buffering I'm using a particular

00:15:26,790 --> 00:15:32,610
class to read the stream all of this

00:15:29,340 --> 00:15:34,440
could be suboptimal and I might think

00:15:32,610 --> 00:15:35,910
about improving this but if this were

00:15:34,440 --> 00:15:38,460
handwritten code improving this would

00:15:35,910 --> 00:15:40,710
take forever however if I generate the

00:15:38,460 --> 00:15:43,860
code then I just have a few instances

00:15:40,710 --> 00:15:46,590
where I change out a few things and then

00:15:43,860 --> 00:15:48,990
I have suddenly very different code so

00:15:46,590 --> 00:15:51,330
by working in this way you can have a

00:15:48,990 --> 00:15:54,240
very quick turnaround of ideas for your

00:15:51,330 --> 00:15:57,320
reading code for example i implemented a

00:15:54,240 --> 00:15:59,850
reader which doesn't do any allocation

00:15:57,320 --> 00:16:01,470
it might be faster or might not be it

00:15:59,850 --> 00:16:04,380
might be convenient while working or not

00:16:01,470 --> 00:16:06,480
it's very easy to try that what I also

00:16:04,380 --> 00:16:09,320
implemented at the time was converted to

00:16:06,480 --> 00:16:11,970
xml this was just a talk XML which

00:16:09,320 --> 00:16:13,740
allowed me to have a binary format and

00:16:11,970 --> 00:16:15,840
quickly translate to something I could

00:16:13,740 --> 00:16:17,490
read while I was debugging I want you

00:16:15,840 --> 00:16:20,160
have that well you can also convert it

00:16:17,490 --> 00:16:21,960
to SVG and you can try to visualize your

00:16:20,160 --> 00:16:23,790
PowerPoint slide very quickly it

00:16:21,960 --> 00:16:25,620
wouldn't be production code but at least

00:16:23,790 --> 00:16:29,880
while developing you have something

00:16:25,620 --> 00:16:32,430
which you can quickly work with also i

00:16:29,880 --> 00:16:35,400
wrote a version that generated

00:16:32,430 --> 00:16:37,260
introspective code so at every point i

00:16:35,400 --> 00:16:40,230
could list the number of entries of

00:16:37,260 --> 00:16:42,240
every record and see what was in there

00:16:40,230 --> 00:16:43,920
that code actually was much more than

00:16:42,240 --> 00:16:46,860
30,000 lines it was over hundred

00:16:43,920 --> 00:16:48,480
thousand lights when generated and it

00:16:46,860 --> 00:16:50,670
wouldn't be efficient for a colleague

00:16:48,480 --> 00:16:53,010
rattle but it was very useful while

00:16:50,670 --> 00:16:55,410
writing while translating this

00:16:53,010 --> 00:16:57,150
documentation this hand written

00:16:55,410 --> 00:17:01,620
documentation for humans into the

00:16:57,150 --> 00:17:03,420
computer readable XML file and as a

00:17:01,620 --> 00:17:05,430
debugging tool you could also do

00:17:03,420 --> 00:17:08,670
round-trip cogeneration so go from

00:17:05,430 --> 00:17:12,000
binary to xml I'm back and check that

00:17:08,670 --> 00:17:13,169
you have the exact same binary what that

00:17:12,000 --> 00:17:15,179
allows is down

00:17:13,169 --> 00:17:17,519
just downloading a thousand thousands of

00:17:15,179 --> 00:17:19,109
PowerPoint files from the web and just

00:17:17,519 --> 00:17:20,759
seeing if they all round trip and if

00:17:19,109 --> 00:17:22,889
they don't round trip you have a bug

00:17:20,759 --> 00:17:28,439
somewhere and probably you should either

00:17:22,889 --> 00:17:29,970
fix the specification yeah well actually

00:17:28,439 --> 00:17:31,139
you should fix the specification or

00:17:29,970 --> 00:17:32,879
maybe there's a buck in the generator

00:17:31,139 --> 00:17:34,529
and usually it was a buck in the

00:17:32,879 --> 00:17:37,200
specification because the generated code

00:17:34,529 --> 00:17:40,230
is very small and that's how we found

00:17:37,200 --> 00:17:42,659
out that they're actually things that

00:17:40,230 --> 00:17:44,429
are not documented properly just bugs in

00:17:42,659 --> 00:17:46,889
the documentation and we manage to work

00:17:44,429 --> 00:17:49,739
around them and fix the xml description

00:17:46,889 --> 00:17:53,129
of the document so those are the

00:17:49,739 --> 00:17:55,409
advantages and here i was using this in

00:17:53,129 --> 00:18:00,149
an ad hoc way for my particular problem

00:17:55,409 --> 00:18:03,869
powerpoint files that's not always the

00:18:00,149 --> 00:18:07,850
optimal solution but you could extend it

00:18:03,869 --> 00:18:11,429
so this library is available separately

00:18:07,850 --> 00:18:13,499
it's quite old by now but it could be

00:18:11,429 --> 00:18:15,809
extended to also read PDF files or zip

00:18:13,499 --> 00:18:20,690
files I'd be three files and actually

00:18:15,809 --> 00:18:20,690
the PDF would be a fairly large

00:18:20,809 --> 00:18:27,840
undertaking I tried it and I didn't

00:18:23,309 --> 00:18:30,480
manage so another useful type of library

00:18:27,840 --> 00:18:32,600
like this is to convert the files to rdf

00:18:30,480 --> 00:18:35,609
and perhaps use it in desktop search

00:18:32,600 --> 00:18:39,359
this is also a unfinished project which

00:18:35,609 --> 00:18:41,070
i tried at some point and yet another

00:18:39,359 --> 00:18:43,049
use would be to use this for the

00:18:41,070 --> 00:18:45,230
document liberation project the document

00:18:43,049 --> 00:18:49,049
liberation project trials tries to

00:18:45,230 --> 00:18:51,149
document old file formats so that in the

00:18:49,049 --> 00:18:52,980
future we can still read them even when

00:18:51,149 --> 00:18:55,200
we're not using C++ anymore for example

00:18:52,980 --> 00:18:59,369
of or when the binaries don't work even

00:18:55,200 --> 00:19:01,379
in any emulator like I said this is ad

00:18:59,369 --> 00:19:05,869
hoc and there are people who are take

00:19:01,379 --> 00:19:08,970
doing this more seriously one project

00:19:05,869 --> 00:19:10,739
was to have a specification for doing

00:19:08,970 --> 00:19:13,200
this and that was called a data format

00:19:10,739 --> 00:19:15,980
description language it is inspired on

00:19:13,200 --> 00:19:19,769
XML schema which does is for XML and

00:19:15,980 --> 00:19:22,980
well in 2011 it was published as version

00:19:19,769 --> 00:19:26,310
one and you can pass files if you have a

00:19:22,980 --> 00:19:29,150
schema the implementation is in Java and

00:19:26,310 --> 00:19:31,350
uses the types from the xml schema

00:19:29,150 --> 00:19:33,330
specification so that's nice there's

00:19:31,350 --> 00:19:36,060
however one big downside this project

00:19:33,330 --> 00:19:38,280
isn't isn't has a very nice

00:19:36,060 --> 00:19:40,350
specification but the implementation

00:19:38,280 --> 00:19:42,720
isn't doesn't do too much so it doesn't

00:19:40,350 --> 00:19:45,780
do any cogeneration it just does life

00:19:42,720 --> 00:19:47,430
inspecting of documents so yeah there's

00:19:45,780 --> 00:19:50,250
a java program which reads the schema

00:19:47,430 --> 00:19:55,800
and then can also read a binary and

00:19:50,250 --> 00:19:58,890
that's what it does another recent more

00:19:55,800 --> 00:20:01,320
recent approach was some guys would a

00:19:58,890 --> 00:20:03,180
scientific paper and publish some code

00:20:01,320 --> 00:20:07,230
and they use this as a specification

00:20:03,180 --> 00:20:09,810
format and they show that you can have a

00:20:07,230 --> 00:20:12,270
parcel for zip files and they also

00:20:09,810 --> 00:20:14,640
implemented the fast and safe dns server

00:20:12,270 --> 00:20:16,800
by writing down the dns packet

00:20:14,640 --> 00:20:18,780
specification in this form so that

00:20:16,800 --> 00:20:21,450
wasn't nice nice paper to read and a

00:20:18,780 --> 00:20:22,950
nice project to do i'm not sure how far

00:20:21,450 --> 00:20:24,870
it will go because it was academic and

00:20:22,950 --> 00:20:27,540
academics when that once I prove a point

00:20:24,870 --> 00:20:31,250
they let everybody else figure the rest

00:20:27,540 --> 00:20:35,940
out but more commercially interesting

00:20:31,250 --> 00:20:39,030
approach was presented yes it was

00:20:35,940 --> 00:20:41,970
yesterday now the day before that which

00:20:39,030 --> 00:20:43,710
is by he can hack software this was a

00:20:41,970 --> 00:20:46,440
lightning talk and they are working and

00:20:43,710 --> 00:20:49,320
have version 1 of something called

00:20:46,440 --> 00:20:51,120
poplar and this is intended for network

00:20:49,320 --> 00:20:55,080
protocols not file formats but in

00:20:51,120 --> 00:21:00,170
principle it should be amenable to

00:20:55,080 --> 00:21:02,520
something like that as well yeah and

00:21:00,170 --> 00:21:04,260
andreas we're sitting there can answer

00:21:02,520 --> 00:21:08,520
any questions if you're interested in

00:21:04,260 --> 00:21:10,650
how popular works ok so that's what

00:21:08,520 --> 00:21:14,820
binary files but what about XML that's

00:21:10,650 --> 00:21:18,570
that should be safe shunned it hmm maybe

00:21:14,820 --> 00:21:22,680
what about this SVG file so it's

00:21:18,570 --> 00:21:25,850
perfectly fine xml but unload it has a

00:21:22,680 --> 00:21:28,230
handler which calls some javascript so

00:21:25,850 --> 00:21:29,970
anything can really happen and if you

00:21:28,230 --> 00:21:32,760
just have a general xml pass and put

00:21:29,970 --> 00:21:35,490
this into your Dom tree well magic can

00:21:32,760 --> 00:21:37,200
happen for somebody else perhaps so this

00:21:35,490 --> 00:21:40,020
is not always safe so you still need to

00:21:37,200 --> 00:21:40,710
be careful with XML or if you're writing

00:21:40,020 --> 00:21:42,840
XML

00:21:40,710 --> 00:21:46,620
writing xml code by hand can also be

00:21:42,840 --> 00:21:48,929
problematic this is a code I found a few

00:21:46,620 --> 00:21:50,520
weeks ago similar to code I found a few

00:21:48,929 --> 00:21:54,179
weeks ago in an unnamed office

00:21:50,520 --> 00:21:57,059
application it was a very serious back

00:21:54,179 --> 00:22:00,360
it was generating in so not well-formed

00:21:57,059 --> 00:22:02,970
XML on some token circumstances yeah

00:22:00,360 --> 00:22:04,710
because the if statement for the open

00:22:02,970 --> 00:22:10,799
tag and the if limit for the clothes egg

00:22:04,710 --> 00:22:15,960
is different so yeah I was very shocked

00:22:10,799 --> 00:22:18,510
when I saw this and so I think also in

00:22:15,960 --> 00:22:21,750
this case you should just generate code

00:22:18,510 --> 00:22:23,880
that just writes the entire XML and you

00:22:21,750 --> 00:22:28,289
shouldn't be passing strings to start

00:22:23,880 --> 00:22:30,029
element functions at all in fact here's

00:22:28,289 --> 00:22:32,279
some real world data which i got from

00:22:30,029 --> 00:22:36,960
8-11 early who is also at the conference

00:22:32,279 --> 00:22:39,390
here he analyzed the security

00:22:36,960 --> 00:22:43,500
vulnerabilities on LibreOffice and

00:22:39,390 --> 00:22:46,470
microsoft office and there are lots of

00:22:43,500 --> 00:22:48,720
them and these are mainly actually in

00:22:46,470 --> 00:22:51,960
the xml format not the binary format i

00:22:48,720 --> 00:22:54,809
asked him surely this big red bar is

00:22:51,960 --> 00:22:59,700
from the binary format nope it's mostly

00:22:54,809 --> 00:23:02,700
the XML yeah so the data comes from the

00:22:59,700 --> 00:23:04,710
CV database and it Alouette the

00:23:02,700 --> 00:23:06,690
descriptions of all the all the

00:23:04,710 --> 00:23:08,610
probabilities and categorize them and

00:23:06,690 --> 00:23:11,700
you see that the lower three are

00:23:08,610 --> 00:23:13,200
actuated to files and the top ones well

00:23:11,700 --> 00:23:15,000
actually the font one is also related to

00:23:13,200 --> 00:23:16,380
files of course but the lowest three are

00:23:15,000 --> 00:23:18,960
the most interesting ones and also the

00:23:16,380 --> 00:23:22,890
largest ones this is collected over

00:23:18,960 --> 00:23:24,510
three years so yeah over 100 for

00:23:22,890 --> 00:23:34,679
mobility in three years that's not too

00:23:24,510 --> 00:23:38,279
good yes yeah so from XML you can also

00:23:34,679 --> 00:23:40,890
do cogeneration the most widely used

00:23:38,279 --> 00:23:42,899
tool is Jack speed as for java it

00:23:40,890 --> 00:23:44,669
creates it reads an XML schema and

00:23:42,899 --> 00:23:46,500
generates classes for you and you can

00:23:44,669 --> 00:23:47,640
use the classes and that's of course if

00:23:46,500 --> 00:23:51,540
you're writing

00:23:47,640 --> 00:23:54,180
a bizarre scheme I was also using that

00:23:51,540 --> 00:23:56,550
because well I believe that that's the

00:23:54,180 --> 00:23:59,940
way to go for c++ though there's also a

00:23:56,550 --> 00:24:02,300
library it's called x SD it's / code

00:23:59,940 --> 00:24:05,640
synthesis it's available under GPL and

00:24:02,300 --> 00:24:09,150
it generates a C++ from an XML schema

00:24:05,640 --> 00:24:11,070
now even this last one I mentioning lip

00:24:09,150 --> 00:24:12,600
XML to which can do validation and

00:24:11,070 --> 00:24:15,450
almost nobody is using that in

00:24:12,600 --> 00:24:18,540
applications because it's too slow but

00:24:15,450 --> 00:24:20,490
it does at safety right so if you're so

00:24:18,540 --> 00:24:23,940
writing files I think you should also

00:24:20,490 --> 00:24:26,040
help a lip XML at the end to do xml

00:24:23,940 --> 00:24:28,350
schema validation it should be fairly

00:24:26,040 --> 00:24:32,370
cheap if you just pipe it through it's a

00:24:28,350 --> 00:24:34,380
it's just streaming validation so sure

00:24:32,370 --> 00:24:36,720
you need to have the past xml schema in

00:24:34,380 --> 00:24:39,120
memory but apart from that I don't think

00:24:36,720 --> 00:24:42,480
it's too much overhead for nicely added

00:24:39,120 --> 00:24:46,290
security so at the end of the sermon the

00:24:42,480 --> 00:24:48,810
screen held up yay for the rest of the

00:24:46,290 --> 00:24:50,820
talk and yeah conclusions I think you

00:24:48,810 --> 00:24:53,280
shouldn't write the ulus c.o.d

00:24:50,820 --> 00:24:57,060
serialization code directly write a

00:24:53,280 --> 00:24:59,910
schema instead and then if you need to

00:24:57,060 --> 00:25:01,980
write your own code generator because

00:24:59,910 --> 00:25:04,560
then you can adapt your IL code very

00:25:01,980 --> 00:25:07,620
quickly and you can move fast and you

00:25:04,560 --> 00:25:09,540
have more secure code so the generator

00:25:07,620 --> 00:25:13,230
is short it's heavily used so that not

00:25:09,540 --> 00:25:14,850
many bugs in there and I think in

00:25:13,230 --> 00:25:16,590
general it's a nicer way of working it

00:25:14,850 --> 00:25:19,770
requires some setup at the start of your

00:25:16,590 --> 00:25:21,330
project but when you should project is

00:25:19,770 --> 00:25:23,190
meant to live a bit longer this is a

00:25:21,330 --> 00:25:26,840
much more maintainable area of working

00:25:23,190 --> 00:25:29,430
so do not write this serialization code

00:25:26,840 --> 00:25:32,820
unless you write a deserialization tool

00:25:29,430 --> 00:25:37,160
oh wait there's a passing out there

00:25:32,820 --> 00:25:37,160
sorry this is not intentional

00:25:37,840 --> 00:25:55,539
oops questions did you publish your code

00:25:52,860 --> 00:26:04,870
for the PowerPoint and stuff somewhere

00:25:55,539 --> 00:26:07,840
yes I like these questions oh where it's

00:26:04,870 --> 00:26:10,059
well it's um get lab it's also indicated

00:26:07,840 --> 00:26:11,200
you get repositories so it's in a few

00:26:10,059 --> 00:26:14,860
places but that's the nice thing about

00:26:11,200 --> 00:26:17,440
it it's decentralized but and the the

00:26:14,860 --> 00:26:19,840
the actual generated code is simply

00:26:17,440 --> 00:26:21,250
committed to cali go directly but

00:26:19,840 --> 00:26:22,899
there's a note saying this code is

00:26:21,250 --> 00:26:24,970
generated if you want to change this

00:26:22,899 --> 00:26:27,429
code download this to change the

00:26:24,970 --> 00:26:36,130
specification and rerun it and upload it

00:26:27,429 --> 00:26:41,620
again tsumori but the difference is

00:26:36,130 --> 00:26:44,110
between xml schema and DF dl saudi FDL

00:26:41,620 --> 00:26:46,210
is meant for binary files if you have an

00:26:44,110 --> 00:26:49,840
existing file format you can then

00:26:46,210 --> 00:26:53,190
reverse engineer or after the fact

00:26:49,840 --> 00:26:56,260
describe this file format with gfdl and

00:26:53,190 --> 00:26:57,880
xml schema is meant for xml so then you

00:26:56,260 --> 00:26:59,980
can describe which XML elements are

00:26:57,880 --> 00:27:02,770
allowed which attributes are allowed how

00:26:59,980 --> 00:27:05,470
can you nest them in each other so it's

00:27:02,770 --> 00:27:14,409
similar in concept but one is for XML

00:27:05,470 --> 00:27:26,440
and the other is for binary data I had a

00:27:14,409 --> 00:27:28,870
question over there assuming you already

00:27:26,440 --> 00:27:30,520
have a code base with classes you want

00:27:28,870 --> 00:27:32,890
to sterilize do you know any tool that

00:27:30,520 --> 00:27:34,990
will generate civilization code based on

00:27:32,890 --> 00:27:38,470
the code and then generate some format

00:27:34,990 --> 00:27:40,330
which can read and write afterwards no I

00:27:38,470 --> 00:27:42,340
don't this sounds very complicated to do

00:27:40,330 --> 00:27:45,120
that's automatically yeah I'm afraid

00:27:42,340 --> 00:27:45,120
you'll have to do it by hand

00:27:52,230 --> 00:27:58,539
yeah so dftl the question is is that

00:27:54,970 --> 00:28:01,330
code to generate code for from a DD FDL

00:27:58,539 --> 00:28:03,010
description as far as I know there isn't

00:28:01,330 --> 00:28:06,039
so there was a lot of work put into

00:28:03,010 --> 00:28:09,520
having a large interesting and good

00:28:06,039 --> 00:28:12,250
specification ah but there's not a lot

00:28:09,520 --> 00:28:15,700
of code actually generating code from

00:28:12,250 --> 00:28:18,220
the FDL unfortunately but if you want to

00:28:15,700 --> 00:28:21,010
start documenting your own file format

00:28:18,220 --> 00:28:24,210
and then generating code for that it

00:28:21,010 --> 00:28:26,230
might be clever to still use the FDL

00:28:24,210 --> 00:28:28,870
because first of all you don't have to

00:28:26,230 --> 00:28:31,600
invent your own language you can just

00:28:28,870 --> 00:28:36,220
reuse that and there is this tool where

00:28:31,600 --> 00:28:39,429
you can do debugging so you can load a

00:28:36,220 --> 00:28:43,600
ddl description in the java tool that

00:28:39,429 --> 00:28:46,049
comes with it and then look at it so it

00:28:43,600 --> 00:28:48,520
there is a tooling available available

00:28:46,049 --> 00:28:51,960
there is tooling available for debugging

00:28:48,520 --> 00:28:55,720
but not for generating code already yeah

00:28:51,960 --> 00:28:58,530
yeah thanks for your talk and from what

00:28:55,720 --> 00:29:01,600
I have read the dftl can only

00:28:58,530 --> 00:29:06,039
deserialize your binary format you have

00:29:01,600 --> 00:29:08,049
no option to create a file well yes like

00:29:06,039 --> 00:29:10,570
I said there's no code for generating

00:29:08,049 --> 00:29:12,669
code so that if you have description of

00:29:10,570 --> 00:29:14,830
a format obviously you can read a write

00:29:12,669 --> 00:29:16,600
code or create code to read and write

00:29:14,830 --> 00:29:18,490
because you have the description of what

00:29:16,600 --> 00:29:21,429
it should look like but since they only

00:29:18,490 --> 00:29:23,350
have a tool which does inspection of an

00:29:21,429 --> 00:29:27,070
existing file that that's only for

00:29:23,350 --> 00:29:31,110
reading yes and did you write code that

00:29:27,070 --> 00:29:37,299
can also write to file yes but since

00:29:31,110 --> 00:29:40,030
well the use case for us was that we

00:29:37,299 --> 00:29:42,700
wanted to open PowerPoint files in cali

00:29:40,030 --> 00:29:44,590
gras and so we wanted to show them and

00:29:42,700 --> 00:29:46,480
we want to be able to save them but

00:29:44,590 --> 00:29:49,419
since we thought odf is a better format

00:29:46,480 --> 00:29:51,640
we converted them to ODF and we have

00:29:49,419 --> 00:29:55,840
code to save ODF but we don't have code

00:29:51,640 --> 00:29:58,299
to save to PowerPoint format yes so

00:29:55,840 --> 00:30:04,179
the short answer the genuine answer is

00:29:58,299 --> 00:30:05,890
no but we do convert it to a BF yeah I

00:30:04,179 --> 00:30:08,860
just wanted to check out I understood

00:30:05,890 --> 00:30:11,620
you were describing the tool for dftl as

00:30:08,860 --> 00:30:13,179
debugging is that a validation checking

00:30:11,620 --> 00:30:19,480
that an existing file does conform to

00:30:13,179 --> 00:30:22,450
what you think the spec is yes Oh again

00:30:19,480 --> 00:30:28,000
okay sorry okay kind of running late

00:30:22,450 --> 00:30:30,100
just to conclude so what we've seen so

00:30:28,000 --> 00:30:33,130
far in the wild we're the only one will

00:30:30,100 --> 00:30:34,779
try to generate deserializing and serve

00:30:33,130 --> 00:30:37,929
as a shin code from one specification

00:30:34,779 --> 00:30:40,360
for binary formats of all kinds so

00:30:37,929 --> 00:30:44,320
basically you can also text files and

00:30:40,360 --> 00:30:45,760
binary files combined and so far we are

00:30:44,320 --> 00:30:48,419
concentrating on network protocols

00:30:45,760 --> 00:30:51,399
because they're shorter and the

00:30:48,419 --> 00:30:54,059
generated code is not so sophisticated

00:30:51,399 --> 00:30:56,620
or adapted to your specific application

00:30:54,059 --> 00:30:59,230
because ya can basically do is utilize

00:30:56,620 --> 00:31:02,559
it in an instruction and profile formats

00:30:59,230 --> 00:31:05,260
it's quite easily possible but we have

00:31:02,559 --> 00:31:10,059
not taken care of that so concentrating

00:31:05,260 --> 00:31:12,580
on wheelie documenting it yeah thank you

00:31:10,059 --> 00:31:15,580
that was a comment by andreas who wrote

00:31:12,580 --> 00:31:18,250
the poorly the portly tool which I'm

00:31:15,580 --> 00:31:20,020
very impressed by so by all means go

00:31:18,250 --> 00:31:21,520
check that out and I'm sure you're going

00:31:20,020 --> 00:31:23,350
to pick the slides of your lightning

00:31:21,520 --> 00:31:27,820
talk online somewhere or maybe they're

00:31:23,350 --> 00:31:31,090
in the cute con description yeah but so

00:31:27,820 --> 00:31:32,440
poorly is a very it already exists so if

00:31:31,090 --> 00:31:34,000
you don't want to write the code to

00:31:32,440 --> 00:31:39,490
generate your code yourself you can use

00:31:34,000 --> 00:31:40,929
that yeah so check it out okay so i

00:31:39,490 --> 00:31:42,490
really have to cut it in right now

00:31:40,929 --> 00:31:46,049
because we're over running by almost 10

00:31:42,490 --> 00:31:46,049
minutes so thank you very much

00:31:50,020 --> 00:31:53,470
of course if you have additional

00:31:51,220 --> 00:31:55,830
questions grab them any time doing the

00:31:53,470 --> 00:31:55,830

YouTube URL: https://www.youtube.com/watch?v=Md8atR6i81k


