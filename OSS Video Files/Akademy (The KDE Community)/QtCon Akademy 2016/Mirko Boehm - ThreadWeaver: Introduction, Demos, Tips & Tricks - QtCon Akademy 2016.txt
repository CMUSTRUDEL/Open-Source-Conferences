Title: Mirko Boehm - ThreadWeaver: Introduction, Demos, Tips & Tricks - QtCon Akademy 2016
Publication date: 2016-09-04
Playlist: QtCon Akademy 2016
Description: 
	ThreadWeaver is the concurrency scheduler framework in KDE. The presentation will introduce the basics of ThreadWeaver, and demonstrate some fancy tricks.

miroslav
Captions: 
	00:00:04,700 --> 00:00:09,809
yep thanks everybody it's actually a

00:00:07,950 --> 00:00:12,960
pleasure to be able to present this year

00:00:09,809 --> 00:00:14,639
because literally the concepts of threat

00:00:12,960 --> 00:00:17,130
we were have been developed when cute

00:00:14,639 --> 00:00:19,710
was not yet able to do anything that he

00:00:17,130 --> 00:00:22,199
tried to do so the first proof of

00:00:19,710 --> 00:00:24,779
concept of what we were trying to build

00:00:22,199 --> 00:00:27,150
a threat Weaver was came up at the time

00:00:24,779 --> 00:00:30,510
of cute three when reference counting

00:00:27,150 --> 00:00:33,149
for example was not atomic and all these

00:00:30,510 --> 00:00:34,860
the old ad relatively simple and easy to

00:00:33,149 --> 00:00:36,390
use concepts that we wanted to have her

00:00:34,860 --> 00:00:38,550
back practically impossible without

00:00:36,390 --> 00:00:42,000
writing a new cute which didn't happen

00:00:38,550 --> 00:00:44,100
to it cute for and then that's why it

00:00:42,000 --> 00:00:46,200
has this long history you're looking

00:00:44,100 --> 00:00:47,460
probably at the fourth version of threat

00:00:46,200 --> 00:00:49,739
we were the concept of state the same

00:00:47,460 --> 00:00:51,870
and then the implementation has been

00:00:49,739 --> 00:00:55,379
redone and redone an acute for we needed

00:00:51,870 --> 00:00:58,379
quite a number of small helpers and tips

00:00:55,379 --> 00:00:59,940
and tricks to make things work and with

00:00:58,379 --> 00:01:02,309
the current cute the code is very

00:00:59,940 --> 00:01:04,710
straightforward so yeah it's really

00:01:02,309 --> 00:01:07,170
interesting to look at it today what's

00:01:04,710 --> 00:01:12,510
the presentation about we are going to

00:01:07,170 --> 00:01:13,950
have two main parts one will be just

00:01:12,510 --> 00:01:17,640
introducing the basic concepts of

00:01:13,950 --> 00:01:22,799
attractive everywhere is build off if

00:01:17,640 --> 00:01:24,570
you will and then the second part pretty

00:01:22,799 --> 00:01:28,829
equally distributed in terms of time

00:01:24,570 --> 00:01:32,600
will be well cute things you can do in

00:01:28,829 --> 00:01:36,180
threat viewer and things that other

00:01:32,600 --> 00:01:39,810
thread pool like concepts in include

00:01:36,180 --> 00:01:42,979
applications don't necessarily have in

00:01:39,810 --> 00:01:42,979
case you're wondering who that guy is

00:01:48,430 --> 00:01:57,490
yeah i've been using programming with

00:01:52,180 --> 00:02:00,280
cute and KDE since 97 I was on the KDE

00:01:57,490 --> 00:02:02,740
board for a couple of years i worked at

00:02:00,280 --> 00:02:06,070
kdub learn more about cute so I teaching

00:02:02,740 --> 00:02:11,410
cute a lot today my the focus of my work

00:02:06,070 --> 00:02:13,330
is less technical my main to main free

00:02:11,410 --> 00:02:14,830
software contributions today are working

00:02:13,330 --> 00:02:18,340
at the open adventure network where

00:02:14,830 --> 00:02:20,170
we're trying to build a a patent pool of

00:02:18,340 --> 00:02:22,600
cross-licensing that protects Linux

00:02:20,170 --> 00:02:24,640
another free software very successful

00:02:22,600 --> 00:02:28,840
2000 member companies and the sponsor of

00:02:24,640 --> 00:02:31,360
this conference by the way and then I'm

00:02:28,840 --> 00:02:32,860
working with the eff is a fee and part

00:02:31,360 --> 00:02:36,730
of the German team and I'm in the

00:02:32,860 --> 00:02:38,290
General Assembly and ass that also yeah

00:02:36,730 --> 00:02:40,270
and I teach the stuff so in case you

00:02:38,290 --> 00:02:42,640
live in Berlin and you want to take

00:02:40,270 --> 00:02:46,930
university course on source intellectual

00:02:42,640 --> 00:02:50,459
property you can take that here what is

00:02:46,930 --> 00:02:54,489
threat Weaver it's not a threat pool

00:02:50,459 --> 00:02:55,900
what kind of it is you can do everything

00:02:54,489 --> 00:02:57,730
with Fred we were that you could do with

00:02:55,900 --> 00:02:59,470
a flat pool but you can do a lot of more

00:02:57,730 --> 00:03:01,570
things with red river that you can't do

00:02:59,470 --> 00:03:04,810
with thread pool we call the concurrent

00:03:01,570 --> 00:03:08,230
execution scheduler it is written for

00:03:04,810 --> 00:03:09,820
cute kitty programs it's written for

00:03:08,230 --> 00:03:12,489
cute because that's its only dependency

00:03:09,820 --> 00:03:14,110
and it's good for kitty programs because

00:03:12,489 --> 00:03:16,330
it's a kiddie framework so you get

00:03:14,110 --> 00:03:18,400
threat we work by installing a KDE

00:03:16,330 --> 00:03:20,680
framework into your application built

00:03:18,400 --> 00:03:23,110
with see Meg um the only thing that you

00:03:20,680 --> 00:03:25,720
need extra from see make and cute are

00:03:23,110 --> 00:03:28,600
the KDE extra see make modules that are

00:03:25,720 --> 00:03:30,570
used to configure it and once you've

00:03:28,600 --> 00:03:33,010
done that it's very important to

00:03:30,570 --> 00:03:35,799
integrate preferir into your

00:03:33,010 --> 00:03:37,299
applications and all the code i'm going

00:03:35,799 --> 00:03:40,420
to show you today or I'm going to

00:03:37,299 --> 00:03:41,860
reference is in the original threat view

00:03:40,420 --> 00:03:43,420
of repository it's based either on the

00:03:41,860 --> 00:03:45,730
unit test or the examples of are in the

00:03:43,420 --> 00:03:48,790
repository and there you can also see

00:03:45,730 --> 00:03:49,900
kind of the three lines of build system

00:03:48,790 --> 00:03:51,820
code that you need to add to your

00:03:49,900 --> 00:03:54,549
project to for example you that we were

00:03:51,820 --> 00:03:56,680
in a ce mec project I'm assuming that if

00:03:54,549 --> 00:03:59,220
you do production code then you don't

00:03:56,680 --> 00:03:59,220
use connect

00:04:00,410 --> 00:04:04,280
so what's the focus of that we were

00:04:01,970 --> 00:04:08,140
first it provides high level

00:04:04,280 --> 00:04:11,690
functionality for concurrent execution

00:04:08,140 --> 00:04:13,790
high level in that it's not necessarily

00:04:11,690 --> 00:04:16,459
concerned with like something as small

00:04:13,790 --> 00:04:18,680
as a runnable I of course there's a

00:04:16,459 --> 00:04:20,390
basic unit of execution but we're

00:04:18,680 --> 00:04:24,200
looking at a higher level for example

00:04:20,390 --> 00:04:26,180
are saying I have this set of things

00:04:24,200 --> 00:04:29,300
that needs to get done and before this

00:04:26,180 --> 00:04:31,040
gets done some setup needs to be done it

00:04:29,300 --> 00:04:32,600
when that's all done some teardown needs

00:04:31,040 --> 00:04:34,810
to be done and this is something you can

00:04:32,600 --> 00:04:37,190
model in threat paper which i think is

00:04:34,810 --> 00:04:39,260
if you think about it probably matches

00:04:37,190 --> 00:04:41,540
the problem that you're trying to solve

00:04:39,260 --> 00:04:44,810
more then saying I want to apply this

00:04:41,540 --> 00:04:48,290
algorithm in a parallel way so this is

00:04:44,810 --> 00:04:50,350
also the differentiation form for

00:04:48,290 --> 00:04:54,830
example from something acute concurrent

00:04:50,350 --> 00:04:56,150
so threat we was written with the work

00:04:54,830 --> 00:04:58,100
of an application developer in mind

00:04:56,150 --> 00:04:59,840
whereas this Q concurrent was written by

00:04:58,100 --> 00:05:04,640
computer science beauties for computer

00:04:59,840 --> 00:05:07,370
science PhD thread Weaver is modular in

00:05:04,640 --> 00:05:10,250
a way that all the concepts that threat

00:05:07,370 --> 00:05:11,870
viewers applying kind of extend each

00:05:10,250 --> 00:05:13,580
other not necessarily building on each

00:05:11,870 --> 00:05:19,130
other you will see that so dark use and

00:05:13,580 --> 00:05:20,330
jobs and policies etc that you can

00:05:19,130 --> 00:05:25,040
understand each of these concepts

00:05:20,330 --> 00:05:27,470
separately and use them and I call it

00:05:25,040 --> 00:05:30,740
conceptual usability and so I want this

00:05:27,470 --> 00:05:33,410
to be relatively easy to use and an

00:05:30,740 --> 00:05:35,780
intuitive as well and the if you're

00:05:33,410 --> 00:05:38,240
interested in and seeing like kind of

00:05:35,780 --> 00:05:40,340
what it can do the tests are actually a

00:05:38,240 --> 00:05:42,350
very good way to to learn about it

00:05:40,340 --> 00:05:45,050
because the tests use all this kind of

00:05:42,350 --> 00:05:48,350
conceptual usability a lot so you can

00:05:45,050 --> 00:05:50,630
create a local pool as a local variable

00:05:48,350 --> 00:05:54,650
and you can sleeve that scope and the

00:05:50,630 --> 00:05:57,130
pool goes away etc so so things like

00:05:54,650 --> 00:06:02,480
that are I think pretty powerful

00:05:57,130 --> 00:06:03,890
concepts for parallel execution that for

00:06:02,480 --> 00:06:05,720
example q threat pool itself doesn't

00:06:03,890 --> 00:06:08,180
have at the app is I'm done want to I

00:06:05,720 --> 00:06:09,650
want to bash q threat pool it's a very

00:06:08,180 --> 00:06:12,860
good thing and a very good tool it's

00:06:09,650 --> 00:06:13,660
built into cute but it solves a very

00:06:12,860 --> 00:06:15,700
specific problem

00:06:13,660 --> 00:06:17,440
and it's very limited right there's one

00:06:15,700 --> 00:06:22,480
pool he understand she had another pool

00:06:17,440 --> 00:06:24,340
etc and this seems to be like you need a

00:06:22,480 --> 00:06:26,170
little more sometimes and then you can

00:06:24,340 --> 00:06:27,610
use threat viewer so in a way if you've

00:06:26,170 --> 00:06:30,820
ever looked into what Apple built with

00:06:27,610 --> 00:06:36,970
Grand Central I think we built what they

00:06:30,820 --> 00:06:41,740
wanted to do and didn't finish let's

00:06:36,970 --> 00:06:43,330
talk about basics the absolute essential

00:06:41,740 --> 00:06:47,860
thing that you need to know about in

00:06:43,330 --> 00:06:49,510
cute creeper is a job of course that's

00:06:47,860 --> 00:06:50,620
that's your runnable right if you want

00:06:49,510 --> 00:06:52,720
to implement something that does

00:06:50,620 --> 00:06:54,490
something you need to draw we call the

00:06:52,720 --> 00:06:57,340
basic unit of curing and execution and

00:06:54,490 --> 00:07:00,100
it works much like a runnable so you

00:06:57,340 --> 00:07:01,630
create it you can either sometimes you

00:07:00,100 --> 00:07:03,190
can provide payload for example there's

00:07:01,630 --> 00:07:05,380
a way to use a standard lambda function

00:07:03,190 --> 00:07:09,600
and and wrap that into a job and throw

00:07:05,380 --> 00:07:09,600
it away so and then it just is executed

00:07:11,340 --> 00:07:14,890
so that's basic intuitive you not only

00:07:13,600 --> 00:07:17,220
know how around above works so that's

00:07:14,890 --> 00:07:21,340
think of a drop like a runnable however

00:07:17,220 --> 00:07:24,670
memory management the one of the issues

00:07:21,340 --> 00:07:26,800
that you probably have seen as what the

00:07:24,670 --> 00:07:28,540
question of when is a job obsolete like

00:07:26,800 --> 00:07:30,250
when is the runnable done and you don't

00:07:28,540 --> 00:07:32,740
need it anymore total you solve this

00:07:30,250 --> 00:07:35,440
problem by queuing share pointers so

00:07:32,740 --> 00:07:37,360
you're creating a share pointer to a job

00:07:35,440 --> 00:07:39,700
and you're handing this over tore up to

00:07:37,360 --> 00:07:41,500
a threat Weaver if you keep a reference

00:07:39,700 --> 00:07:43,150
to that and the reference count as one

00:07:41,500 --> 00:07:44,980
right and then two and you pass it into

00:07:43,150 --> 00:07:46,660
your cue so this thing stays there if

00:07:44,980 --> 00:07:49,660
you don't keep one that's a

00:07:46,660 --> 00:07:52,030
fire-and-forget job are you q it you'll

00:07:49,660 --> 00:07:54,490
keep a reference and it gets destroyed

00:07:52,030 --> 00:07:57,730
immediately after it's finished and you

00:07:54,490 --> 00:07:59,919
don't have to worry about this that and

00:07:57,730 --> 00:08:02,940
alone I think if you look at the code

00:07:59,919 --> 00:08:05,440
and the management of the payload

00:08:02,940 --> 00:08:09,730
simplifies a lot of solutions that I've

00:08:05,440 --> 00:08:12,970
seen that used it jobs are also a little

00:08:09,730 --> 00:08:14,919
more no no they're not meant to be

00:08:12,970 --> 00:08:17,340
absolutely minimal like runnable like

00:08:14,919 --> 00:08:19,510
one virtual function no local variables

00:08:17,340 --> 00:08:21,729
because we're assuming that you do

00:08:19,510 --> 00:08:24,100
something with a job that is like

00:08:21,729 --> 00:08:27,120
substantial work so it arbitrates the

00:08:24,100 --> 00:08:28,979
cost of creating it as opposed to

00:08:27,120 --> 00:08:32,219
like the intention to create millions of

00:08:28,979 --> 00:08:36,150
them so it has things like success

00:08:32,219 --> 00:08:37,919
status it has a way to like a mechanism

00:08:36,150 --> 00:08:39,890
to request cancellation you know that

00:08:37,919 --> 00:08:42,690
cancellation is a very difficult issue

00:08:39,890 --> 00:08:45,150
you can't just go and delete a job it

00:08:42,690 --> 00:08:48,089
might be in progress you can call it and

00:08:45,150 --> 00:08:49,860
say dude stop what you're doing because

00:08:48,089 --> 00:08:51,420
there's no way to do not c plus we don't

00:08:49,860 --> 00:08:53,880
have interrupts or something that would

00:08:51,420 --> 00:08:55,800
implement that so all you can do is rig

00:08:53,880 --> 00:08:58,320
a stood as a job nicely to cancel and

00:08:55,800 --> 00:09:00,540
there's a mechanism for that and drops

00:08:58,320 --> 00:09:03,150
off priorities priorities here are not

00:09:00,540 --> 00:09:05,160
priorities for the threading scheduler

00:09:03,150 --> 00:09:07,800
like an operating system their

00:09:05,160 --> 00:09:10,620
priorities for scheduling in the queue

00:09:07,800 --> 00:09:11,850
so you can add jobs to dequeue in your

00:09:10,620 --> 00:09:13,830
status as a higher priorities low

00:09:11,850 --> 00:09:15,990
priority and they will just end up the

00:09:13,830 --> 00:09:18,000
particular sort of Q fever and the

00:09:15,990 --> 00:09:21,110
highest level priority jobs will be

00:09:18,000 --> 00:09:23,520
executed first that there's no order

00:09:21,110 --> 00:09:25,220
here in in terms of priorities there is

00:09:23,520 --> 00:09:28,020
no guarantee of order of execution

00:09:25,220 --> 00:09:30,120
because the higher quality job can still

00:09:28,020 --> 00:09:31,920
be done I like take a longer time and

00:09:30,120 --> 00:09:34,709
another one can be picked up by another

00:09:31,920 --> 00:09:35,910
thread right um so if you look at order

00:09:34,709 --> 00:09:42,540
of execution just a different mechanism

00:09:35,910 --> 00:09:45,000
for that this picture here shows

00:09:42,540 --> 00:09:46,320
somebody doing a job and then two other

00:09:45,000 --> 00:09:47,880
people looking at it this is also a

00:09:46,320 --> 00:09:51,240
metaphor for the decorators that we have

00:09:47,880 --> 00:09:53,490
right here you will see later how we can

00:09:51,240 --> 00:09:57,240
wrap drops into other jobs and therefore

00:09:53,490 --> 00:09:58,860
this way change the behavior job is a

00:09:57,240 --> 00:10:00,720
very central concept of threat viewer in

00:09:58,860 --> 00:10:03,150
that a lot of the things that we talk

00:10:00,720 --> 00:10:04,980
about later are actually jobs which

00:10:03,150 --> 00:10:06,630
means to is exactly one way to queue

00:10:04,980 --> 00:10:09,870
something in it in like link you some

00:10:06,630 --> 00:10:13,230
work as one method says in queue this

00:10:09,870 --> 00:10:15,690
job not to drop it vector of jobs why is

00:10:13,230 --> 00:10:17,700
it a vector because one of the standard

00:10:15,690 --> 00:10:21,120
issues that you have with using threat

00:10:17,700 --> 00:10:22,920
pools is atomic queuing of work you

00:10:21,120 --> 00:10:25,920
always have this like if you write a for

00:10:22,920 --> 00:10:27,600
loop and you Q things up then of course

00:10:25,920 --> 00:10:28,980
the first things get already done while

00:10:27,600 --> 00:10:30,900
you're still queuing and that's hard to

00:10:28,980 --> 00:10:32,220
manage sometimes in front of you what

00:10:30,900 --> 00:10:33,150
you do is you create a vector you put

00:10:32,220 --> 00:10:35,010
all your drops in there and then you

00:10:33,150 --> 00:10:37,540
have this one method we say do this

00:10:35,010 --> 00:10:41,649
please and then um

00:10:37,540 --> 00:10:44,980
yeah then that happens so because so

00:10:41,649 --> 00:10:47,110
much is based on John the API of the Q

00:10:44,980 --> 00:10:51,100
is super simple there's one thing you

00:10:47,110 --> 00:10:54,610
can put a vector of tops in there and I

00:10:51,100 --> 00:10:58,870
talked about cues so your Q is the

00:10:54,610 --> 00:11:01,089
threat pool sort of similar to QF at

00:10:58,870 --> 00:11:04,779
pool there is a global instance so when

00:11:01,089 --> 00:11:07,139
you have a QR occasion object and you

00:11:04,779 --> 00:11:12,430
link threat Weaver then you also have a

00:11:07,139 --> 00:11:15,610
global instance however you can create a

00:11:12,430 --> 00:11:18,610
local variable of type Q and say please

00:11:15,610 --> 00:11:24,279
have a twerk threats and that will be a

00:11:18,610 --> 00:11:27,699
local q there's functionality and in the

00:11:24,279 --> 00:11:30,759
q2 in the queue class to suspend an

00:11:27,699 --> 00:11:32,560
execution that means you call a function

00:11:30,759 --> 00:11:33,940
that that is all the working threats

00:11:32,560 --> 00:11:35,259
should finish what they do but they

00:11:33,940 --> 00:11:36,910
should not pick up new work and then

00:11:35,259 --> 00:11:38,970
after a couple of minutes seconds

00:11:36,910 --> 00:11:41,769
whatever long you talk takes drops take

00:11:38,970 --> 00:11:43,389
the q will send a signal I am now

00:11:41,769 --> 00:11:45,790
suspended that means it will not start

00:11:43,389 --> 00:11:48,610
new work sometimes that's very useful so

00:11:45,790 --> 00:11:51,459
um this is less this is what I meant

00:11:48,610 --> 00:11:53,860
with conceptual usability this is less

00:11:51,459 --> 00:11:57,040
something related to parallel execution

00:11:53,860 --> 00:11:59,139
but more related to managing the

00:11:57,040 --> 00:12:01,240
workload in your application so it's

00:11:59,139 --> 00:12:03,730
like a suspended Q is one other thing to

00:12:01,240 --> 00:12:05,500
work with because you can put up you can

00:12:03,730 --> 00:12:07,569
set up a complex structure of things

00:12:05,500 --> 00:12:10,600
that it should do and then you tell it

00:12:07,569 --> 00:12:13,510
to do it so that sometimes easier then

00:12:10,600 --> 00:12:14,920
to use lots of for example futures to

00:12:13,510 --> 00:12:18,760
make sure you wait at a specific point

00:12:14,920 --> 00:12:20,199
before something happens and then of

00:12:18,760 --> 00:12:23,050
course you can resume it and there's a

00:12:20,199 --> 00:12:25,060
function to finish what is in the queue

00:12:23,050 --> 00:12:27,490
which is blocking so for example

00:12:25,060 --> 00:12:30,040
something you can use before you exit

00:12:27,490 --> 00:12:31,839
your application one thing i have not on

00:12:30,040 --> 00:12:34,540
the science is the number of worker

00:12:31,839 --> 00:12:37,689
threats is dynamic that means you can

00:12:34,540 --> 00:12:40,149
set the target number at any time and it

00:12:37,689 --> 00:12:42,310
will adjust it so if you have eight

00:12:40,149 --> 00:12:44,680
worker threads running and they're doing

00:12:42,310 --> 00:12:47,769
something and you say the target is now

00:12:44,680 --> 00:12:48,880
six then two of them will as soon as

00:12:47,769 --> 00:12:50,660
they finish what they're currently doing

00:12:48,880 --> 00:12:52,850
they will exit

00:12:50,660 --> 00:12:57,940
and I will have a demo for that a little

00:12:52,850 --> 00:12:59,990
later so so we talked about jobs and Q's

00:12:57,940 --> 00:13:01,220
now we talked about a very central

00:12:59,990 --> 00:13:06,230
concept to threat of you and that's

00:13:01,220 --> 00:13:08,420
aggregation of jobs so the ad is central

00:13:06,230 --> 00:13:10,430
class here is called collection a nut as

00:13:08,420 --> 00:13:12,980
the name says a collection of jobs so

00:13:10,430 --> 00:13:15,889
you create a collection and you put 15

00:13:12,980 --> 00:13:17,509
jobs in it and that's now one unit they

00:13:15,889 --> 00:13:19,939
belong together interestingly the

00:13:17,509 --> 00:13:22,430
collection class is a job itself so you

00:13:19,939 --> 00:13:26,149
queue it as your cue a job so that's why

00:13:22,430 --> 00:13:29,600
we only have one method to queue so now

00:13:26,149 --> 00:13:32,480
you have a way to say i want all these

00:13:29,600 --> 00:13:34,850
things to be done together and for

00:13:32,480 --> 00:13:36,230
example decorate this with a Q object

00:13:34,850 --> 00:13:39,829
and send me a signal when all this is

00:13:36,230 --> 00:13:41,269
done so you see that the concepts and

00:13:39,829 --> 00:13:42,920
threat we've are made for people that

00:13:41,269 --> 00:13:45,350
are for example worried about managing

00:13:42,920 --> 00:13:46,699
use interfaces as well where you say I

00:13:45,350 --> 00:13:48,110
have all these things that need to be

00:13:46,699 --> 00:13:50,540
done i need to my user interface to

00:13:48,110 --> 00:13:52,279
update when that's done I don't want to

00:13:50,540 --> 00:13:55,430
implement code that counts how many

00:13:52,279 --> 00:13:58,610
things are done or etc because I can

00:13:55,430 --> 00:14:00,350
formulate with a river collection that

00:13:58,610 --> 00:14:06,980
this should all be done and when that's

00:14:00,350 --> 00:14:08,600
done please tell me the since it's a job

00:14:06,980 --> 00:14:11,540
the collection is a job it has a run

00:14:08,600 --> 00:14:12,860
method and the run method of the job

00:14:11,540 --> 00:14:16,220
itself of the collection sir was

00:14:12,860 --> 00:14:19,279
executed first it actually works to

00:14:16,220 --> 00:14:21,500
create payload like elements of the

00:14:19,279 --> 00:14:24,610
collection in the run method and I have

00:14:21,500 --> 00:14:26,750
an example for that later there's a

00:14:24,610 --> 00:14:28,579
special version of collection that's

00:14:26,750 --> 00:14:30,949
called sequence and it does exactly what

00:14:28,579 --> 00:14:32,509
sequence will do right so you put drops

00:14:30,949 --> 00:14:34,009
in there and they're executed in DC in

00:14:32,509 --> 00:14:44,779
the order in which you add them to do

00:14:34,009 --> 00:14:47,110
sequence now question now okay you can

00:14:44,779 --> 00:14:50,059
aggregate these think things so a

00:14:47,110 --> 00:14:51,920
collection or sequence is a job right so

00:14:50,059 --> 00:14:54,980
there's nothing as speaks against using

00:14:51,920 --> 00:14:56,600
a sequence to create and to add

00:14:54,980 --> 00:14:57,980
collections into that sequence and have

00:14:56,600 --> 00:14:59,959
elements into that collection in these

00:14:57,980 --> 00:15:01,550
collections and then you can draw a

00:14:59,959 --> 00:15:03,050
graph of how this should be executed and

00:15:01,550 --> 00:15:03,800
you can trust that we were to do that

00:15:03,050 --> 00:15:06,589
for you

00:15:03,800 --> 00:15:09,170
will happen a very common way to do to

00:15:06,589 --> 00:15:10,610
use this is to use a sequence for your

00:15:09,170 --> 00:15:15,740
like to be here for three steps to do

00:15:10,610 --> 00:15:22,430
set up main work um processing of the

00:15:15,740 --> 00:15:24,740
results and then since you're adding the

00:15:22,430 --> 00:15:26,060
main work as one collection you can be

00:15:24,740 --> 00:15:28,040
sure that the third step only gets

00:15:26,060 --> 00:15:29,899
executed when all the other steps have

00:15:28,040 --> 00:15:32,060
been unimpaired as fast as the pool can

00:15:29,899 --> 00:15:33,529
do it but only when they're done I think

00:15:32,060 --> 00:15:35,630
of some something like rendering a

00:15:33,529 --> 00:15:37,730
webpage where surpassingly or pausing

00:15:35,630 --> 00:15:39,110
the original text it contains lots of

00:15:37,730 --> 00:15:40,880
external references and now I have a

00:15:39,110 --> 00:15:42,950
collection that downloads all these

00:15:40,880 --> 00:15:44,300
external references and now i'm waiting

00:15:42,950 --> 00:15:47,990
for this collection to be finished and

00:15:44,300 --> 00:15:50,089
then i render the page so that's this is

00:15:47,990 --> 00:15:52,060
the kind of level of abstraction that

00:15:50,089 --> 00:15:55,250
you should think of don't think of

00:15:52,060 --> 00:16:00,019
programming the run method is a little

00:15:55,250 --> 00:16:01,570
too low level policies are your way to

00:16:00,019 --> 00:16:04,940
impose your will on the queue or

00:16:01,570 --> 00:16:06,440
multiple queues because policies work

00:16:04,940 --> 00:16:07,930
even if you assign them to multiple

00:16:06,440 --> 00:16:11,899
queues at the same time so for example

00:16:07,930 --> 00:16:14,510
there's already built in something

00:16:11,899 --> 00:16:16,610
called a resource restriction policy you

00:16:14,510 --> 00:16:19,730
can define any resource which is a

00:16:16,610 --> 00:16:23,329
counter so for example you say I would

00:16:19,730 --> 00:16:24,860
like to have this many jobs that access

00:16:23,329 --> 00:16:26,420
the network running at the same time at

00:16:24,860 --> 00:16:28,190
most then you create a resource

00:16:26,420 --> 00:16:30,770
restriction that says this is my network

00:16:28,190 --> 00:16:34,399
job resources friction and you assign it

00:16:30,770 --> 00:16:36,230
to the jobs and if you do not and this

00:16:34,399 --> 00:16:38,450
thing say is at maximum for at a time

00:16:36,230 --> 00:16:40,459
you can queue as many network requests

00:16:38,450 --> 00:16:44,779
as you like into the Q the Q will only

00:16:40,459 --> 00:16:46,970
process for at a time this is very

00:16:44,779 --> 00:16:49,310
interesting because one thing that I see

00:16:46,970 --> 00:16:52,339
repeatedly is that people use the work

00:16:49,310 --> 00:16:55,070
account of the pool to manage payload

00:16:52,339 --> 00:16:56,839
workload how much should be done the

00:16:55,070 --> 00:16:59,149
same time this is the absolute worst way

00:16:56,839 --> 00:17:01,279
to do it what you want is a pool with a

00:16:59,149 --> 00:17:03,230
lot of workers and you want to use

00:17:01,279 --> 00:17:05,870
policies to say what the workers should

00:17:03,230 --> 00:17:07,610
be able to do it not because that means

00:17:05,870 --> 00:17:10,280
for example that you have one pool and

00:17:07,610 --> 00:17:12,949
if you have for network jobs working you

00:17:10,280 --> 00:17:15,410
still have 12 threads waiting and the

00:17:12,949 --> 00:17:17,209
other things will just bypass that works

00:17:15,410 --> 00:17:18,890
much better than using like changing

00:17:17,209 --> 00:17:22,839
were using the sides of the work account

00:17:18,890 --> 00:17:24,829
to manage something interestingly

00:17:22,839 --> 00:17:26,390
dependencies as when we talked about

00:17:24,829 --> 00:17:29,240
sequence where things are done in a

00:17:26,390 --> 00:17:30,710
certain order you can also declare this

00:17:29,240 --> 00:17:33,440
job depends on that one and then the

00:17:30,710 --> 00:17:34,549
second one the second one will only be

00:17:33,440 --> 00:17:37,640
executed when the first one finished

00:17:34,549 --> 00:17:39,230
this is also a queue policy so it is

00:17:37,640 --> 00:17:40,820
kind of a modular concept here as well

00:17:39,230 --> 00:17:43,279
so internally that Weaver uses these

00:17:40,820 --> 00:17:45,710
policies as well I will have an example

00:17:43,279 --> 00:17:48,860
later where you can see that you can use

00:17:45,710 --> 00:17:50,419
Q policies to manage overall load so you

00:17:48,860 --> 00:17:56,450
implement something that reads the

00:17:50,419 --> 00:17:59,630
system load and then adapts the the

00:17:56,450 --> 00:18:01,880
number of say cpu intensive jobs using a

00:17:59,630 --> 00:18:03,830
resource restriction so sister note goes

00:18:01,880 --> 00:18:07,360
up that goes down and then you've

00:18:03,830 --> 00:18:12,679
managed that's your done over the system

00:18:07,360 --> 00:18:16,640
here question is a cpu heavy using the

00:18:12,679 --> 00:18:19,250
cpu is that also a take the same it's my

00:18:16,640 --> 00:18:20,659
job it's just yeah I can you cpu yeah so

00:18:19,250 --> 00:18:23,330
basically what you do is you create a

00:18:20,659 --> 00:18:25,820
recipe yeah so the question was how you

00:18:23,330 --> 00:18:28,309
can cpu is that a resource the answer is

00:18:25,820 --> 00:18:30,380
yes but you have to program that so you

00:18:28,309 --> 00:18:32,390
say his resources direction this is my

00:18:30,380 --> 00:18:34,520
cpu intensive resources friction i

00:18:32,390 --> 00:18:37,250
assigned us to like I have a job class

00:18:34,520 --> 00:18:39,529
at as image calculations and in their

00:18:37,250 --> 00:18:42,260
constructor they all assign this policy

00:18:39,529 --> 00:18:44,929
so it's like set it up two lines of code

00:18:42,260 --> 00:18:47,539
and now you can say whenever you cue one

00:18:44,929 --> 00:18:50,750
of these jobs the policy will make sure

00:18:47,539 --> 00:18:52,279
that only say eight of them we process

00:18:50,750 --> 00:18:53,659
at the same time this is a very good

00:18:52,279 --> 00:18:56,240
question because that's why you want to

00:18:53,659 --> 00:18:58,370
pay go to the net because you don't only

00:18:56,240 --> 00:19:00,950
do cpu intensive things you want your

00:18:58,370 --> 00:19:02,480
pool to be to be bypassing the cpu

00:19:00,950 --> 00:19:06,110
intensive work with network operations

00:19:02,480 --> 00:19:08,330
all the time so that's why you want a

00:19:06,110 --> 00:19:11,059
bit cool and the resource restrictions

00:19:08,330 --> 00:19:16,039
to manage work should be limited good

00:19:11,059 --> 00:19:18,020
question decorators if you read you a

00:19:16,039 --> 00:19:19,279
book about design patterns then you

00:19:18,020 --> 00:19:21,890
understand decorators they like the

00:19:19,279 --> 00:19:24,470
matroska puppets so you wrap one drop

00:19:21,890 --> 00:19:26,389
into another into another and and we use

00:19:24,470 --> 00:19:29,270
this to change all kinds of pro

00:19:26,389 --> 00:19:32,000
properties of jobs so for example

00:19:29,270 --> 00:19:34,930
if you want to adapt the priority job

00:19:32,000 --> 00:19:37,070
has and you don't have you don't have

00:19:34,930 --> 00:19:39,260
you're not creating the job somebody

00:19:37,070 --> 00:19:42,290
else created it you can change your pool

00:19:39,260 --> 00:19:44,810
to say everything that comes then this

00:19:42,290 --> 00:19:46,400
done prioritized immediately I have an

00:19:44,810 --> 00:19:48,740
example for that if you want to add

00:19:46,400 --> 00:19:50,930
logging to the run methods of all jobs

00:19:48,740 --> 00:19:52,360
you don't change the run methods of all

00:19:50,930 --> 00:19:54,710
drops you decorate them with a lager

00:19:52,360 --> 00:19:56,720
then you have a like a log message

00:19:54,710 --> 00:19:58,810
before the payload gets called and log

00:19:56,720 --> 00:20:02,300
message after and it where you want to

00:19:58,810 --> 00:20:04,610
collect time sequences time serious with

00:20:02,300 --> 00:20:07,970
Prometheus then you add a Prometheus

00:20:04,610 --> 00:20:13,460
data generator as a decorator there's an

00:20:07,970 --> 00:20:15,140
example that in a minute for Jamaica is

00:20:13,460 --> 00:20:17,120
all usable and you notice really you

00:20:15,140 --> 00:20:19,400
don't have to go right gazillion lines

00:20:17,120 --> 00:20:22,820
of code there's a stream like API like

00:20:19,400 --> 00:20:24,110
IO street um like API we're usin say

00:20:22,820 --> 00:20:26,560
here's a sequence and you have stream

00:20:24,110 --> 00:20:31,550
operators drop top top top top top top

00:20:26,560 --> 00:20:34,820
that reduces clutter I guarantee by this

00:20:31,550 --> 00:20:36,830
many percent you will see some examples

00:20:34,820 --> 00:20:38,930
of that one interesting aspect here is

00:20:36,830 --> 00:20:41,480
if you do that adesso something called

00:20:38,930 --> 00:20:43,100
to stream the tea they think that you

00:20:41,480 --> 00:20:45,220
stream into this action object you

00:20:43,100 --> 00:20:47,720
create that you reference that

00:20:45,220 --> 00:20:49,340
everything that you do in the set of

00:20:47,720 --> 00:20:51,470
streaming operations all the way to your

00:20:49,340 --> 00:20:53,420
finishing semicolon will be queued in an

00:20:51,470 --> 00:20:56,240
atomic operation from the cues

00:20:53,420 --> 00:20:58,340
perspective that means again the q does

00:20:56,240 --> 00:21:00,350
not start to process this while you're

00:20:58,340 --> 00:21:02,000
still queuing which is helpful because

00:21:00,350 --> 00:21:03,890
sometimes otherwise you already done

00:21:02,000 --> 00:21:07,790
halfway but then this instruction

00:21:03,890 --> 00:21:09,140
returns so that was a lot of basic and

00:21:07,790 --> 00:21:14,150
instruction all right let's look at some

00:21:09,140 --> 00:21:15,530
code this is the streaming API md this

00:21:14,150 --> 00:21:17,630
is from code that is ineffective

00:21:15,530 --> 00:21:21,110
repository so you create a sequence and

00:21:17,630 --> 00:21:23,570
then you for example use suing operators

00:21:21,110 --> 00:21:26,210
to add elements to the sequence make job

00:21:23,570 --> 00:21:29,270
is a function that creates a SharePoint

00:21:26,210 --> 00:21:31,040
or to job and this takes a lambda

00:21:29,270 --> 00:21:33,290
function so and this is a member

00:21:31,040 --> 00:21:34,580
function a calls a member function

00:21:33,290 --> 00:21:37,430
lambda function it calls a member

00:21:34,580 --> 00:21:39,590
function so did this way you can

00:21:37,430 --> 00:21:42,050
basically say in this sequence from the

00:21:39,590 --> 00:21:42,950
pool call these three functions so in

00:21:42,050 --> 00:21:46,160
this order

00:21:42,950 --> 00:21:49,580
three lines of code try that with Red

00:21:46,160 --> 00:21:52,660
Bull and then the you see last line is

00:21:49,580 --> 00:21:56,420
there's put this into the stream

00:21:52,660 --> 00:21:57,890
understood the other make make jobs

00:21:56,420 --> 00:21:59,330
where it makes your variance where you

00:21:57,890 --> 00:22:03,470
don't you have to use Lum tar so it's

00:21:59,330 --> 00:22:05,510
supposedly write a simple the pattern of

00:22:03,470 --> 00:22:07,190
calling back to an object that is in the

00:22:05,510 --> 00:22:09,730
main threat and calling number functions

00:22:07,190 --> 00:22:12,500
from the pool is quite common it's

00:22:09,730 --> 00:22:14,540
helpful to not have to copy lots of

00:22:12,500 --> 00:22:16,340
member variables of course then you have

00:22:14,540 --> 00:22:17,570
to make sure ayub number functions

00:22:16,340 --> 00:22:19,850
actually get called from a different

00:22:17,570 --> 00:22:21,590
thread but typically if you can

00:22:19,850 --> 00:22:24,830
synchronize that well it's a good

00:22:21,590 --> 00:22:26,510
approach because then you can create an

00:22:24,830 --> 00:22:27,500
object orders also good for testing as

00:22:26,510 --> 00:22:29,540
you have an object week of all the

00:22:27,500 --> 00:22:31,400
functions and if you write the functions

00:22:29,540 --> 00:22:33,440
reentrant and in fact safe then you can

00:22:31,400 --> 00:22:34,910
write the test but then using them you

00:22:33,440 --> 00:22:36,800
can pour them from a different thread so

00:22:34,910 --> 00:22:40,340
so it's good to keep all the logic in

00:22:36,800 --> 00:22:43,280
one object depailler object cool here

00:22:40,340 --> 00:22:45,320
are some decorator examples so this is

00:22:43,280 --> 00:22:47,090
the priority decorator the example that

00:22:45,320 --> 00:22:48,770
I gave where you get jobs and you want

00:22:47,090 --> 00:22:52,280
to adjust their priority without calling

00:22:48,770 --> 00:22:54,550
their functions so you have a job and

00:22:52,280 --> 00:22:57,410
you wrap it in a priority decorator

00:22:54,550 --> 00:23:00,080
classes up there DD's all will have

00:22:57,410 --> 00:23:02,210
priority too and the concept of

00:23:00,080 --> 00:23:04,250
decorators is that you wrap one object

00:23:02,210 --> 00:23:07,390
into another object and object they also

00:23:04,250 --> 00:23:09,710
delete what they hold there is a

00:23:07,390 --> 00:23:11,930
constructor parameter of the decorator

00:23:09,710 --> 00:23:13,460
if you don't want that so the idea is

00:23:11,930 --> 00:23:16,070
that in one line of code you can create

00:23:13,460 --> 00:23:20,300
three objects and there the result is

00:23:16,070 --> 00:23:23,180
what each queue as a job and then this

00:23:20,300 --> 00:23:25,160
is for example a self-made one that one

00:23:23,180 --> 00:23:29,090
you could implement that adopts their

00:23:25,160 --> 00:23:31,250
priorities that's a simple example let's

00:23:29,090 --> 00:23:34,370
look at this one q object decorate

00:23:31,250 --> 00:23:37,280
that's actually built in and it's very

00:23:34,370 --> 00:23:38,810
easy to use so jobs in that Fred Weaver

00:23:37,280 --> 00:23:40,930
are not Q object you cannot send a

00:23:38,810 --> 00:23:42,920
signal I'm done from the job itself

00:23:40,930 --> 00:23:48,200
because that would be a lot of overhead

00:23:42,920 --> 00:23:50,570
but um all you have to do is you in when

00:23:48,200 --> 00:23:52,010
you create your sequence right you mean

00:23:50,570 --> 00:23:57,860
II weapon in the queue object decorator

00:23:52,010 --> 00:24:00,299
and now you have a ton signal trees

00:23:57,860 --> 00:24:01,980
it's so simple that people looked at it

00:24:00,299 --> 00:24:04,490
didn't understand it and asked me to

00:24:01,980 --> 00:24:08,760
write a blog post about it but this

00:24:04,490 --> 00:24:10,529
three lines of code right just keep in

00:24:08,760 --> 00:24:12,990
mind that if with this you have to make

00:24:10,529 --> 00:24:15,210
sure that all to delete is like declare

00:24:12,990 --> 00:24:18,409
properly because the outside decorator

00:24:15,210 --> 00:24:22,649
assumes that it always the payload

00:24:18,409 --> 00:24:24,419
here's one interesting one we have this

00:24:22,649 --> 00:24:27,929
issue that you have a global instance

00:24:24,419 --> 00:24:29,220
and the global instance is hey what if

00:24:27,929 --> 00:24:30,299
you want to wrap the global instance

00:24:29,220 --> 00:24:33,630
into something or change its behavior

00:24:30,299 --> 00:24:36,950
it's created before you access it it's

00:24:33,630 --> 00:24:40,200
in a single so there's a factory that

00:24:36,950 --> 00:24:43,590
you can register and with that you can

00:24:40,200 --> 00:24:48,649
register a an object that will create

00:24:43,590 --> 00:24:51,090
your global q generally the queues are

00:24:48,649 --> 00:24:53,639
you can subclass the queue and change

00:24:51,090 --> 00:24:55,710
what it does for example top counting

00:24:53,639 --> 00:24:57,659
Weaver is a cue that counts how many

00:24:55,710 --> 00:24:59,850
jobs have been processed you can look at

00:24:57,659 --> 00:25:02,880
the code it's in the federal repository

00:24:59,850 --> 00:25:05,039
or if you want to add logging to the

00:25:02,880 --> 00:25:07,080
global q that's how you were doing now

00:25:05,039 --> 00:25:09,630
you would intercept when the queue is

00:25:07,080 --> 00:25:11,519
created and then you implement something

00:25:09,630 --> 00:25:13,620
that when whenever the cube performs a

00:25:11,519 --> 00:25:16,019
job would log and then that's how you

00:25:13,620 --> 00:25:18,510
add logging without changing the code or

00:25:16,019 --> 00:25:20,669
over the place and it's a very modular

00:25:18,510 --> 00:25:22,470
thing to do and then your two lines of

00:25:20,669 --> 00:25:24,720
code you set up a global q factory and

00:25:22,470 --> 00:25:27,720
then you create your q core application

00:25:24,720 --> 00:25:29,279
object here's an example of these we

00:25:27,720 --> 00:25:30,960
call the generator collections so a

00:25:29,279 --> 00:25:35,279
collection that when you execute it

00:25:30,960 --> 00:25:37,110
generates its own payload are you see

00:25:35,279 --> 00:25:40,110
this is the run method of the collection

00:25:37,110 --> 00:25:41,820
itself and it this is of course a stupid

00:25:40,110 --> 00:25:45,380
example it does something with the

00:25:41,820 --> 00:25:49,080
sequence element by element so it adds

00:25:45,380 --> 00:25:52,289
jobs to itself you see that this new job

00:25:49,080 --> 00:25:56,010
something and that means when the

00:25:52,289 --> 00:25:58,799
collection itself is done its elements

00:25:56,010 --> 00:26:01,590
or what you just queued now this is of

00:25:58,799 --> 00:26:04,500
course a very simple example I use this

00:26:01,590 --> 00:26:06,000
to implement HTTP download request set

00:26:04,500 --> 00:26:08,039
of in load you know these where you

00:26:06,000 --> 00:26:10,240
request a resource and then the response

00:26:08,039 --> 00:26:13,420
is there are 1000 I'm giving you

00:26:10,240 --> 00:26:16,750
is 20 and you do that in the run method

00:26:13,420 --> 00:26:18,900
and then you write a for loop that says

00:26:16,750 --> 00:26:24,220
it now with the window size i know i'm

00:26:18,900 --> 00:26:25,570
creating 19 other jobs that should

00:26:24,220 --> 00:26:27,790
download all the other elements and

00:26:25,570 --> 00:26:29,590
instead of now waiting and doing this in

00:26:27,790 --> 00:26:31,210
loop like you use as my collection

00:26:29,590 --> 00:26:35,110
elements which means they can all be

00:26:31,210 --> 00:26:36,490
done in parallel and and I'm done and so

00:26:35,110 --> 00:26:38,230
this way you can actually model things

00:26:36,490 --> 00:26:39,880
like I don't really know how many

00:26:38,230 --> 00:26:42,580
elements I need to execute before my

00:26:39,880 --> 00:26:45,130
first request is done you combine that

00:26:42,580 --> 00:26:46,690
with a resource restriction for network

00:26:45,130 --> 00:26:48,580
requests and you have modeled to your

00:26:46,690 --> 00:26:53,290
download manager in a couple of lines of

00:26:48,580 --> 00:26:56,830
code right load management this is an

00:26:53,290 --> 00:26:59,710
example so i will show it in in real

00:26:56,830 --> 00:27:01,900
life in a second load management means

00:26:59,710 --> 00:27:05,500
we want to for example some in some way

00:27:01,900 --> 00:27:13,000
dynamically react to the system state so

00:27:05,500 --> 00:27:16,740
me give a little demo here so imagine we

00:27:13,000 --> 00:27:23,170
have an application that scales images

00:27:16,740 --> 00:27:27,400
right so up to 16 workers and now we say

00:27:23,170 --> 00:27:33,940
managers to load automatically let me

00:27:27,400 --> 00:27:35,980
just add some files to it so i did the

00:27:33,940 --> 00:27:38,230
display quality is a bit difficult is

00:27:35,980 --> 00:27:39,940
not much a good here but now watch it it

00:27:38,230 --> 00:27:50,800
will start processing these images to

00:27:39,940 --> 00:27:52,780
generate companies 13 workers so

00:27:50,800 --> 00:27:54,040
basically what now happens is because we

00:27:52,780 --> 00:27:56,650
are doing something system though it

00:27:54,040 --> 00:27:59,830
goes up then the code i just showed you

00:27:56,650 --> 00:28:03,520
uses the standard UNIX get just get

00:27:59,830 --> 00:28:05,590
average i think a custom call calculates

00:28:03,520 --> 00:28:08,170
an ideal number of workers book based on

00:28:05,590 --> 00:28:11,320
that and emitted as a signal and we use

00:28:08,170 --> 00:28:14,140
that to adapt to maximum number of

00:28:11,320 --> 00:28:18,100
threats in a queue or in a coupon for

00:28:14,140 --> 00:28:22,990
cpu intensive threats jobs now see how

00:28:18,100 --> 00:28:24,490
it goes down to them so i said in the

00:28:22,990 --> 00:28:26,410
beginning that a lot of the things that

00:28:24,490 --> 00:28:29,470
providers are supposed to be like

00:28:26,410 --> 00:28:33,640
modular and composable and orthogonal

00:28:29,470 --> 00:28:35,200
and individually usable and here you see

00:28:33,640 --> 00:28:37,390
how things then start to come together

00:28:35,200 --> 00:28:41,830
and i don't think this is something you

00:28:37,390 --> 00:28:44,200
can easily do a cuvette or so and this

00:28:41,830 --> 00:28:46,000
is the code that you just saw in action

00:28:44,200 --> 00:28:47,740
except that way to say is Magic that

00:28:46,000 --> 00:28:50,880
computes talk a work it count work

00:28:47,740 --> 00:28:54,940
account there's actual codec does it and

00:28:50,880 --> 00:28:56,890
we've only the left and I'm done so this

00:28:54,940 --> 00:29:00,340
was we just an introduction so it was

00:28:56,890 --> 00:29:02,169
easy to understand if you use it it

00:29:00,340 --> 00:29:04,990
basically everything that you try to do

00:29:02,169 --> 00:29:06,790
is supposed to work as you imagine it

00:29:04,990 --> 00:29:09,550
should work if it doesn't it's a bug

00:29:06,790 --> 00:29:12,730
report so send me a unit test that fails

00:29:09,550 --> 00:29:13,990
now fix it enjoy it and if you have any

00:29:12,730 --> 00:29:22,419
questions I think we have made it or

00:29:13,990 --> 00:29:25,179
something to answer them any questions

00:29:22,419 --> 00:29:27,760
there's one example just so in the

00:29:25,179 --> 00:29:32,140
example you just showed you had 11

00:29:27,760 --> 00:29:34,120
workers I was wondering how many of

00:29:32,140 --> 00:29:36,820
course do you have why why do you think

00:29:34,120 --> 00:29:40,059
it comes to the number 11 um I actually

00:29:36,820 --> 00:29:41,650
had a top maximum of 16 that's just a

00:29:40,059 --> 00:29:45,490
restriction data set in the code this

00:29:41,650 --> 00:29:50,200
isn't a i 7 quad cores or eat virtual

00:29:45,490 --> 00:29:51,820
cores the general assumption is in queue

00:29:50,200 --> 00:29:53,830
thread pool I think the general

00:29:51,820 --> 00:29:55,570
recommendation is like used as many

00:29:53,830 --> 00:29:57,940
workers as they have CPUs +1 or

00:29:55,570 --> 00:29:59,500
something with Fred Weaver I would

00:29:57,940 --> 00:30:02,410
generally recommend to have a bigger

00:29:59,500 --> 00:30:05,800
pool so 16 or 32 is actually good

00:30:02,410 --> 00:30:07,330
because the new CDs phone numbers file

00:30:05,800 --> 00:30:09,760
orders image loaders etc these are

00:30:07,330 --> 00:30:12,840
resource restrictions so that is example

00:30:09,760 --> 00:30:15,220
implements saying I only want for four

00:30:12,840 --> 00:30:20,050
objects to write to disk at the same

00:30:15,220 --> 00:30:21,730
time or to scale the images so the

00:30:20,050 --> 00:30:24,040
Assumption here is that image scaling is

00:30:21,730 --> 00:30:27,850
CPU intensive by writing is I or

00:30:24,040 --> 00:30:29,740
intensive so you manage what happens at

00:30:27,850 --> 00:30:32,140
the same time using resources directions

00:30:29,740 --> 00:30:33,929
and use a large pool and this also shows

00:30:32,140 --> 00:30:37,049
of course how you can

00:30:33,929 --> 00:30:38,940
the image scalars are limited because

00:30:37,049 --> 00:30:40,289
you don't want to hog all the CPUs or

00:30:38,940 --> 00:30:42,480
you want to reduce them if the system

00:30:40,289 --> 00:30:44,159
that goes up but then the firefighters

00:30:42,480 --> 00:30:46,139
can bypass them because you didn't limit

00:30:44,159 --> 00:30:48,299
the number of worker threats you limited

00:30:46,139 --> 00:30:52,830
what how many cpu intensive things can

00:30:48,299 --> 00:30:54,480
run right so did I answer the question

00:30:52,830 --> 00:30:56,759
by the way you can see now that system

00:30:54,480 --> 00:31:04,950
that goes down and the recommended work

00:30:56,759 --> 00:31:06,840
account goes up again hi um at the

00:31:04,950 --> 00:31:08,309
beginning you've mentioned that how do

00:31:06,840 --> 00:31:10,619
you how can you tell what our job is

00:31:08,309 --> 00:31:12,720
finished and you said that you you're

00:31:10,619 --> 00:31:16,499
going to be using SharePoint to do that

00:31:12,720 --> 00:31:18,419
but after that you saw you adding some

00:31:16,499 --> 00:31:20,669
jobs into the queue using a upright or

00:31:18,419 --> 00:31:23,399
new so how does that work does it kit

00:31:20,669 --> 00:31:29,659
let's get rocked and a SharePoint inside

00:31:23,399 --> 00:31:32,549
and how does it work um yes no the

00:31:29,659 --> 00:31:35,190
there's one assumption here and that is

00:31:32,549 --> 00:31:38,669
if you give a raw pointer not a share

00:31:35,190 --> 00:31:40,769
pointer you are managing it which is an

00:31:38,669 --> 00:31:42,809
interesting idea because for example you

00:31:40,769 --> 00:31:45,659
can create jobs as local like stack

00:31:42,809 --> 00:31:48,360
variables in your code and as a remember

00:31:45,659 --> 00:31:50,820
variable for example of an object then

00:31:48,360 --> 00:31:52,230
you can queue this job and then you

00:31:50,820 --> 00:31:53,549
don't want it to be all to delete it and

00:31:52,230 --> 00:31:56,429
so you don't want to create a share

00:31:53,549 --> 00:31:58,980
pointer that doesn't destroy it so you q

00:31:56,429 --> 00:32:01,549
it as a non-shared pointer and then that

00:31:58,980 --> 00:32:04,080
waiver assumes that you're managing it

00:32:01,549 --> 00:32:13,769
so that's something to know actually

00:32:04,080 --> 00:32:14,410
yeah why should you ok so thank you very

00:32:13,769 --> 00:32:16,980
much

00:32:14,410 --> 00:32:16,980

YouTube URL: https://www.youtube.com/watch?v=1MSK4W2ZDDc


