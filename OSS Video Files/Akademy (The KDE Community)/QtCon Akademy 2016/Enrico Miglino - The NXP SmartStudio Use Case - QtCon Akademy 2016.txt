Title: Enrico Miglino - The NXP SmartStudio Use Case - QtCon Akademy 2016
Publication date: 2016-09-04
Playlist: QtCon Akademy 2016
Description: 
	In this talk, we will show the architecture design strategy adopted to create a desktop application interacting with audio hardware platforms through USB direct connection, Network over USB and Ethernet network. 
SmartStudio monitosr a wide range of complex DSP real-time data over a user friendly User Interface for the best User Experience, paying special attention to the usability ergonomics of the software. 
The key factors empowered by the Qt/QML platform are efficiency, reliability, flexibility and real-time data monitoring with a less than 15 ms expected delay response. 

.alicemirror
Captions: 
	00:00:04,790 --> 00:00:14,969
well well control when I was contacted

00:00:09,960 --> 00:00:17,279
by an exp to make in child to keep in

00:00:14,969 --> 00:00:19,859
charge of this job they told me about a

00:00:17,279 --> 00:00:22,380
challenge after the first week I

00:00:19,859 --> 00:00:25,619
discovered that they was not joking so

00:00:22,380 --> 00:00:28,289
this is a sort of cute adventure we're

00:00:25,619 --> 00:00:31,189
cute demonstrated in my opinion to be

00:00:28,289 --> 00:00:35,430
one of the most flexible platform

00:00:31,189 --> 00:00:38,300
adaptable to not only to to conventional

00:00:35,430 --> 00:00:42,020
situations but also to very very

00:00:38,300 --> 00:00:44,309
impressed unpredictable and difficult

00:00:42,020 --> 00:00:48,149
application environment and this is the

00:00:44,309 --> 00:00:54,239
reason that I propose it to to show this

00:00:48,149 --> 00:00:57,660
this use case just a word what is my

00:00:54,239 --> 00:01:03,480
studio is a big platform running on the

00:00:57,660 --> 00:01:06,420
stop that starts from your left the

00:01:03,480 --> 00:01:10,110
component that nxp developed for mobile

00:01:06,420 --> 00:01:12,270
out you also the small amplifying and

00:01:10,110 --> 00:01:15,840
ESP signal processor processor that had

00:01:12,270 --> 00:01:18,150
in his most of mass forms and then draw

00:01:15,840 --> 00:01:21,600
in hardware interface layer based on

00:01:18,150 --> 00:01:26,090
DLLs instead of shared library in linux

00:01:21,600 --> 00:01:30,590
and so on we're sending data to this

00:01:26,090 --> 00:01:33,360
application mass to do so is a totally

00:01:30,590 --> 00:01:38,310
monitoring and configuration system for

00:01:33,360 --> 00:01:42,479
the specific chief of nxp that are use

00:01:38,310 --> 00:01:49,290
it by few and but big customer like

00:01:42,479 --> 00:01:52,229
Samsung or away LG to calibrate and to

00:01:49,290 --> 00:01:56,909
analyze the response of these components

00:01:52,229 --> 00:02:00,750
inside of the smartphones and so an XP

00:01:56,909 --> 00:02:03,430
develop a series of small bars visit on

00:02:00,750 --> 00:02:06,520
embedded components for example

00:02:03,430 --> 00:02:11,320
I may be a raspberry p instead of big

00:02:06,520 --> 00:02:14,500
urban black or some similar to simulate

00:02:11,320 --> 00:02:17,160
the android phone contents in India

00:02:14,500 --> 00:02:20,980
smartphones and send this a data stream

00:02:17,160 --> 00:02:22,959
this is just to focus them desh the

00:02:20,980 --> 00:02:27,520
scenario the problem of this application

00:02:22,959 --> 00:02:30,220
what was was that you a series of

00:02:27,520 --> 00:02:35,950
developments of wrong solution wrong

00:02:30,220 --> 00:02:41,200
choices and so on it works started with

00:02:35,950 --> 00:02:46,140
a delay ethic every every sample of

00:02:41,200 --> 00:02:50,200
about 250 milliseconds this means

00:02:46,140 --> 00:02:53,620
absolutely unreliable timeline to

00:02:50,200 --> 00:02:57,580
acquire and check real-time data from

00:02:53,620 --> 00:03:01,420
audio audio sources so the challenge was

00:02:57,580 --> 00:03:05,620
just to find a way to optimize and

00:03:01,420 --> 00:03:10,570
change the timeline of the behavior of

00:03:05,620 --> 00:03:14,230
the this application that works in a day

00:03:10,570 --> 00:03:17,920
way I da way not a project configuration

00:03:14,230 --> 00:03:20,350
that is depends on the hardware and for

00:03:17,920 --> 00:03:22,510
every kind of component that the project

00:03:20,350 --> 00:03:25,180
is then used by the application to

00:03:22,510 --> 00:03:29,769
create the user interface environment

00:03:25,180 --> 00:03:31,090
showing a real-time data controls every

00:03:29,769 --> 00:03:36,780
every kind of controls that are

00:03:31,090 --> 00:03:40,269
available on the chip well the solution

00:03:36,780 --> 00:03:42,580
was not found ok this is the problem i

00:03:40,269 --> 00:03:46,480
propose the solution was not a linear

00:03:42,580 --> 00:03:50,290
path because it was a very difficult to

00:03:46,480 --> 00:03:53,739
understand software very Mick said with

00:03:50,290 --> 00:03:57,319
classes that don't

00:03:53,739 --> 00:04:01,790
without linearity developed in part also

00:03:57,319 --> 00:04:04,849
an interpreted language as the base of

00:04:01,790 --> 00:04:06,709
what word for the digital real-time

00:04:04,849 --> 00:04:10,069
sensing a perfect signal professor

00:04:06,709 --> 00:04:12,049
processing and then the other problem

00:04:10,069 --> 00:04:14,329
was that there was no documentation

00:04:12,049 --> 00:04:16,459
totally undocumented software thousand

00:04:14,329 --> 00:04:21,410
and thousand flights of software without

00:04:16,459 --> 00:04:25,940
documentation okay the initial idea was

00:04:21,410 --> 00:04:31,160
that this software was working in pike

00:04:25,940 --> 00:04:34,490
34 bases on Python 22 dot 7 and the

00:04:31,160 --> 00:04:40,340
first idea was to understand how the

00:04:34,490 --> 00:04:44,240
software was working so this task was it

00:04:40,340 --> 00:04:47,919
was done around the parting of the

00:04:44,240 --> 00:04:52,570
platform to qt5 the resin are almost

00:04:47,919 --> 00:04:56,210
obvious first of all because it is a

00:04:52,570 --> 00:04:58,130
long term support because a QT 4 is no

00:04:56,210 --> 00:05:01,460
more supported and distributing in

00:04:58,130 --> 00:05:04,280
documented in a queue to be abandoned

00:05:01,460 --> 00:05:08,659
and then also because it integrates

00:05:04,280 --> 00:05:13,130
better with any way with Python the most

00:05:08,659 --> 00:05:17,510
important problem I met was that this

00:05:13,130 --> 00:05:20,510
application was not ready to send on the

00:05:17,510 --> 00:05:23,810
market or anyway this big customer was

00:05:20,510 --> 00:05:27,349
already news so it was impossible to

00:05:23,810 --> 00:05:30,190
stop make some changes make some total

00:05:27,349 --> 00:05:33,470
revision and then go ahead in the

00:05:30,190 --> 00:05:36,830
release a new version it should the

00:05:33,470 --> 00:05:39,860
problem was to follow a path to identify

00:05:36,830 --> 00:05:42,500
strategy to make changes progressively

00:05:39,860 --> 00:05:49,400
inside the application that is already

00:05:42,500 --> 00:05:52,849
in use you working on the part in the

00:05:49,400 --> 00:05:54,889
activities the main important activities

00:05:52,849 --> 00:05:56,840
was to focus how the application works

00:05:54,889 --> 00:06:00,139
what are the issues that make this

00:05:56,840 --> 00:06:02,390
application so slow and identify the

00:06:00,139 --> 00:06:05,330
application logic so

00:06:02,390 --> 00:06:08,900
first the curious thing I work with

00:06:05,330 --> 00:06:13,550
almost two months porting from Beauty

00:06:08,900 --> 00:06:18,080
photo p.m. to 55 hi cutie 42 by 50 50 51

00:06:13,550 --> 00:06:21,320
and that the environment of Python 27 2

00:06:18,080 --> 00:06:23,540
dot 7 within a stronger operation of

00:06:21,320 --> 00:06:28,550
reverse engineering just discovering

00:06:23,540 --> 00:06:32,720
what the application was really so there

00:06:28,550 --> 00:06:35,780
was two phases reporting that is what

00:06:32,720 --> 00:06:40,820
should be changed at least to put the

00:06:35,780 --> 00:06:44,600
system in condition to be upgraded and a

00:06:40,820 --> 00:06:47,440
post porting were the real intervention

00:06:44,600 --> 00:06:52,520
year changes in the architecture can be

00:06:47,440 --> 00:06:55,280
applied it's important to note that just

00:06:52,520 --> 00:07:01,490
to give you a scenario estar starting

00:06:55,280 --> 00:07:05,830
scenario that one of the of the various

00:07:01,490 --> 00:07:10,940
issues was just wrong views of strings

00:07:05,830 --> 00:07:13,400
no no strings definitions or at a repeat

00:07:10,940 --> 00:07:16,870
repeat on repeating strings as a

00:07:13,400 --> 00:07:20,020
messages same information there was no

00:07:16,870 --> 00:07:24,830
correct management of the string

00:07:20,020 --> 00:07:28,580
themselves cute is a unique order python

00:07:24,830 --> 00:07:31,160
is a string and there was continuously

00:07:28,580 --> 00:07:34,100
an exchange between Unicode and string

00:07:31,160 --> 00:07:38,630
win unico dancing creating a tremendous

00:07:34,100 --> 00:07:44,300
delay so the first apparently simple

00:07:38,630 --> 00:07:48,680
easy operation also for me they find a

00:07:44,300 --> 00:07:54,160
wall and to crash again because it was

00:07:48,680 --> 00:07:58,010
very difficult without information when

00:07:54,160 --> 00:08:01,510
the porting was complete just only

00:07:58,010 --> 00:08:05,470
removing all the parts

00:08:01,510 --> 00:08:08,640
of redundant paths repeated functions

00:08:05,470 --> 00:08:12,430
and so on we gain either at least a

00:08:08,640 --> 00:08:17,860
25-percent of performances in the in the

00:08:12,430 --> 00:08:21,240
software then at this point we started

00:08:17,860 --> 00:08:25,570
preparing the user interface for the

00:08:21,240 --> 00:08:29,920
first drastic changes with all white but

00:08:25,570 --> 00:08:34,810
as you can see in the center the the

00:08:29,920 --> 00:08:37,390
design is the design like in iba like

00:08:34,810 --> 00:08:41,740
eclipse like a charm and this the

00:08:37,390 --> 00:08:43,419
application that exposes depending on

00:08:41,740 --> 00:08:45,790
the hardware and on the project

00:08:43,419 --> 00:08:50,590
characteristics the values we just

00:08:45,790 --> 00:08:53,740
values components why to do to show this

00:08:50,590 --> 00:08:57,130
because just to understand every part

00:08:53,740 --> 00:09:00,220
that you see if knowing a cuter is easy

00:08:57,130 --> 00:09:02,980
now also from python i create my cutie

00:09:00,220 --> 00:09:06,870
components that works by themselves and

00:09:02,980 --> 00:09:10,690
then a user inside the call a container

00:09:06,870 --> 00:09:12,360
nothing at all the issue in the

00:09:10,690 --> 00:09:16,930
architectural design of the previous

00:09:12,360 --> 00:09:22,690
application was to use q235 and cute

00:09:16,930 --> 00:09:25,390
like just a bunch of libraries so every

00:09:22,690 --> 00:09:27,880
user interface advantages that are the

00:09:25,390 --> 00:09:31,720
direct call back the signal for the user

00:09:27,880 --> 00:09:35,920
interface and the user interaction just

00:09:31,720 --> 00:09:39,790
the moving mouse over a over a widget

00:09:35,920 --> 00:09:43,030
was all managed on the python inside a

00:09:39,790 --> 00:09:48,330
mixes architecture that was using also

00:09:43,030 --> 00:09:53,580
the model part that control the hardware

00:09:48,330 --> 00:09:59,260
ask for hardware streaming and so on so

00:09:53,580 --> 00:10:02,320
the first idea was okay start with QT

00:09:59,260 --> 00:10:07,090
use an interface redesign step-by-step

00:10:02,320 --> 00:10:10,300
part by part using the fastest way and

00:10:07,090 --> 00:10:13,410
with the better granted results

00:10:10,300 --> 00:10:17,410
using a model view controller for

00:10:13,410 --> 00:10:20,110
explained in the exception of cute that

00:10:17,410 --> 00:10:22,860
is not exactly that the super standard

00:10:20,110 --> 00:10:27,820
model view controller but is more

00:10:22,860 --> 00:10:30,460
interactive between qml q10 C++ creating

00:10:27,820 --> 00:10:36,310
all the parts that are now was Evie and

00:10:30,460 --> 00:10:38,950
the very time consuming in the phyto

00:10:36,310 --> 00:10:43,090
environment exporting removing them and

00:10:38,950 --> 00:10:48,160
replacing with c++ plugins controlled by

00:10:43,090 --> 00:10:55,530
qml the problem is that this was not

00:10:48,160 --> 00:10:59,710
possible at all why because the

00:10:55,530 --> 00:11:03,670
application start with the Python run

00:10:59,710 --> 00:11:07,300
Python than Python I start the creation

00:11:03,670 --> 00:11:09,370
of the user interface divided in every

00:11:07,300 --> 00:11:11,020
widgets in everything continuously

00:11:09,370 --> 00:11:13,030
managing the widgets continuously

00:11:11,020 --> 00:11:15,940
managing every element of the user

00:11:13,030 --> 00:11:21,760
interaction so there is not a top level

00:11:15,940 --> 00:11:25,930
why they can be extracted to control the

00:11:21,760 --> 00:11:29,350
plugin and to manage a c++ plugin that

00:11:25,930 --> 00:11:33,130
in theory is faster we was obligated to

00:11:29,350 --> 00:11:35,050
start from Python receive the messages

00:11:33,130 --> 00:11:38,830
the information of the request from the

00:11:35,050 --> 00:11:42,430
Qt qml user interface and then from

00:11:38,830 --> 00:11:46,120
Python create a wrapper for the c++

00:11:42,430 --> 00:11:47,860
beginning so the time that we it was

00:11:46,120 --> 00:11:53,170
possible to gain with the c compiler

00:11:47,860 --> 00:11:57,300
components was totally lost and by the

00:11:53,170 --> 00:12:01,580
python creating this vicious circle now

00:11:57,300 --> 00:12:03,930
so non linearity

00:12:01,580 --> 00:12:07,110
the problem that the guy is controlled

00:12:03,930 --> 00:12:10,130
by Python and there is the entire

00:12:07,110 --> 00:12:13,860
feedback of the user interface by Python

00:12:10,130 --> 00:12:17,370
makes this impossible also another long

00:12:13,860 --> 00:12:22,020
time spent spent oh we're testing to be

00:12:17,370 --> 00:12:27,840
sure to be to trying everything possible

00:12:22,020 --> 00:12:31,320
to avoid this problem anyway we discover

00:12:27,840 --> 00:12:33,960
that it was not possible so remain the

00:12:31,320 --> 00:12:35,760
target that is to create an asset for

00:12:33,960 --> 00:12:40,920
the application where the user interface

00:12:35,760 --> 00:12:45,120
is robust but is fast and can't work at

00:12:40,920 --> 00:12:49,560
an acceptable value of 20 milliseconds

00:12:45,120 --> 00:12:51,720
or 150 milliseconds everything from an

00:12:49,560 --> 00:12:54,150
audio DSP also because there is a very

00:12:51,720 --> 00:12:57,870
long delay there are data that you can

00:12:54,150 --> 00:13:00,120
collect well you hearing the behavior of

00:12:57,870 --> 00:13:02,340
the of the board are absolutely

00:13:00,120 --> 00:13:05,990
unreliable is very difficult also in

00:13:02,340 --> 00:13:11,870
practice for the users to to make tests

00:13:05,990 --> 00:13:16,320
so at this point keeping in mind that

00:13:11,870 --> 00:13:18,240
the customers want any way to improve

00:13:16,320 --> 00:13:22,920
the briefers mast is to improve

00:13:18,240 --> 00:13:26,870
performances then we me and also that

00:13:22,920 --> 00:13:31,410
the team that I have cooperated with

00:13:26,870 --> 00:13:34,170
working strongly on the Python sign we

00:13:31,410 --> 00:13:39,390
need to optimize the code to two to have

00:13:34,170 --> 00:13:43,040
an idea of what we can do make faster

00:13:39,390 --> 00:13:47,250
the entire application so in some way we

00:13:43,040 --> 00:13:52,200
needed to become with an application in

00:13:47,250 --> 00:13:54,080
some way modular so the master is find a

00:13:52,200 --> 00:14:00,820
way to redesign the user interface

00:13:54,080 --> 00:14:04,370
components in QT just note that

00:14:00,820 --> 00:14:08,990
we have moved I moved the part in from

00:14:04,370 --> 00:14:12,770
QT 4 to QT five dot five instead of duty

00:14:08,990 --> 00:14:15,770
five dot six that is already that was

00:14:12,770 --> 00:14:21,800
already available and this again more

00:14:15,770 --> 00:14:26,390
reliable faster than the 35 it was also

00:14:21,800 --> 00:14:30,200
do another big limit the older graphic

00:14:26,390 --> 00:14:34,250
elements or the plotting areas of this

00:14:30,200 --> 00:14:38,630
application that we see later was not

00:14:34,250 --> 00:14:43,339
done in Python was not done in cute but

00:14:38,630 --> 00:14:47,570
was done with web view that using ATM

00:14:43,339 --> 00:14:53,180
HTML Javascript and CSS was receiving

00:14:47,570 --> 00:14:58,010
feedback from the Python side and was

00:14:53,180 --> 00:14:59,959
drawing the real real time data so it

00:14:58,010 --> 00:15:03,680
was in the mixes there was also a

00:14:59,959 --> 00:15:07,970
problem of three big blocks that was a

00:15:03,680 --> 00:15:12,680
website consider that this application

00:15:07,970 --> 00:15:15,680
we show 56 graph 10 different graphs

00:15:12,680 --> 00:15:19,930
that should plot real time every graph

00:15:15,680 --> 00:15:22,910
was epigraph was a webview instance

00:15:19,930 --> 00:15:29,050
shown in a widget all controlled by

00:15:22,910 --> 00:15:35,750
Python a track going very very very slow

00:15:29,050 --> 00:15:41,500
at this point the first thing after we

00:15:35,750 --> 00:15:47,870
had a version working on pike 85 at last

00:15:41,500 --> 00:15:51,560
real working just as it was before I've

00:15:47,870 --> 00:15:54,500
developed a lateral package another long

00:15:51,560 --> 00:15:59,410
time in this challenger consuming that

00:15:54,500 --> 00:16:02,209
is a profiler 10 the goal was to monitor

00:15:59,410 --> 00:16:05,920
without possibly without less

00:16:02,209 --> 00:16:11,209
interference as possible the Python side

00:16:05,920 --> 00:16:13,540
of this application because the Python

00:16:11,209 --> 00:16:17,380
side was working by itself

00:16:13,540 --> 00:16:20,079
the goal was to extract parts and create

00:16:17,380 --> 00:16:22,690
an independent element independent

00:16:20,079 --> 00:16:25,980
object just to manage the graphic user

00:16:22,690 --> 00:16:29,709
interface in the view controller

00:16:25,980 --> 00:16:33,399
environment work for specific parts at

00:16:29,709 --> 00:16:37,720
the different timing so while in the

00:16:33,399 --> 00:16:41,440
logic the user interface that is under

00:16:37,720 --> 00:16:44,800
the direct control of the user as it

00:16:41,440 --> 00:16:47,800
sounds timing and make requests to the

00:16:44,800 --> 00:16:49,329
model that may be okay in Python that is

00:16:47,800 --> 00:16:52,300
as low as not the best solution but

00:16:49,329 --> 00:16:57,339
maybe you use it Python itself was

00:16:52,300 --> 00:17:02,620
working with its own timing polling a

00:16:57,339 --> 00:17:06,429
continuously in a single thread with the

00:17:02,620 --> 00:17:10,959
hardware layer so the problem was to

00:17:06,429 --> 00:17:14,020
create interface managing then the

00:17:10,959 --> 00:17:16,630
entire user experience working at the

00:17:14,020 --> 00:17:20,049
fastest way possible the fastest speed

00:17:16,630 --> 00:17:23,530
possible and working with its sound

00:17:20,049 --> 00:17:28,990
frequency time independent task task and

00:17:23,530 --> 00:17:33,000
then keeping for now 4444 the first

00:17:28,990 --> 00:17:36,970
phase of this project the Python side

00:17:33,000 --> 00:17:39,520
working at it sound speed as much as

00:17:36,970 --> 00:17:41,530
fast as possible so totally a

00:17:39,520 --> 00:17:44,650
synchronous is 22 totally single

00:17:41,530 --> 00:17:48,659
essington systems that are managed only

00:17:44,650 --> 00:17:52,179
throughout the data flow so to know what

00:17:48,659 --> 00:17:55,299
where we was going the idea was to

00:17:52,179 --> 00:17:56,830
create integrating memory profile at the

00:17:55,299 --> 00:18:00,190
class the profit the standard profitless

00:17:56,830 --> 00:18:03,700
of Python and other features in in a

00:18:00,190 --> 00:18:06,700
system that is a package that can be

00:18:03,700 --> 00:18:10,630
added everywhere the packages is called

00:18:06,700 --> 00:18:13,150
the butter with a stupid trick if the

00:18:10,630 --> 00:18:15,460
package is disabled there is a anyway

00:18:13,150 --> 00:18:18,159
remains the call to the functions but

00:18:15,460 --> 00:18:21,820
there is no time consuming this is

00:18:18,159 --> 00:18:24,280
because always the difficult to make

00:18:21,820 --> 00:18:25,140
interventions direct interventions on

00:18:24,280 --> 00:18:29,670
the Susa

00:18:25,140 --> 00:18:32,550
of the item sources this as an

00:18:29,670 --> 00:18:36,660
architecture very easy to implement with

00:18:32,550 --> 00:18:41,190
a very simplified application than the

00:18:36,660 --> 00:18:44,340
common judges Titan profiler class and

00:18:41,190 --> 00:18:47,730
this is one of the parts that will be

00:18:44,340 --> 00:18:54,450
available to those interested in ong

00:18:47,730 --> 00:18:58,290
taba then at this point the original

00:18:54,450 --> 00:19:02,220
idea was the plug-in approach not

00:18:58,290 --> 00:19:05,910
applicable because this c++ classes was

00:19:02,220 --> 00:19:07,950
creating a trouble in the mechanism of

00:19:05,910 --> 00:19:12,470
call because it was not possible to call

00:19:07,950 --> 00:19:16,230
them directly driven by the QT qml

00:19:12,470 --> 00:19:19,860
design and design is very complex in

00:19:16,230 --> 00:19:22,740
terms of features so it was needed a tow

00:19:19,860 --> 00:19:27,030
to make this this is not applicable for

00:19:22,740 --> 00:19:31,370
now this means that until we reach the

00:19:27,030 --> 00:19:37,260
goal to remove all the parts that are

00:19:31,370 --> 00:19:41,940
user interface mix it with the mix it

00:19:37,260 --> 00:19:47,040
with the entire Python model if we if we

00:19:41,940 --> 00:19:49,710
can say this will be the final reel

00:19:47,040 --> 00:19:52,470
better solution and not in a further

00:19:49,710 --> 00:19:57,120
optimization step in this race I have

00:19:52,470 --> 00:20:01,610
already tried to develop a plotting and

00:19:57,120 --> 00:20:05,760
gene in C++ but tested and work it but

00:20:01,610 --> 00:20:07,410
as a matter of fact intervention using

00:20:05,760 --> 00:20:09,930
this as an intervention in the inter

00:20:07,410 --> 00:20:14,460
plication it was impossible at this

00:20:09,930 --> 00:20:18,300
point they actually the current solution

00:20:14,460 --> 00:20:21,900
adopted that will survive for a while

00:20:18,300 --> 00:20:24,660
until the entire challenge on this

00:20:21,900 --> 00:20:28,290
entire project cycle will be completed

00:20:24,660 --> 00:20:32,460
is to adopt the declarative approach the

00:20:28,290 --> 00:20:33,500
compromise was to create a very fast

00:20:32,460 --> 00:20:37,000
very

00:20:33,500 --> 00:20:40,580
as much optimize it as possible

00:20:37,000 --> 00:20:44,840
javascript the components that gives

00:20:40,580 --> 00:20:49,660
anyway a good frequency response in the

00:20:44,840 --> 00:20:52,070
user interface making it independent and

00:20:49,660 --> 00:20:55,580
totally under the control of the qml

00:20:52,070 --> 00:21:00,260
this app design in JavaScript so there

00:20:55,580 --> 00:21:04,340
is a sort of missing part that is what I

00:21:00,260 --> 00:21:09,080
was initially pointing the attention to

00:21:04,340 --> 00:21:12,410
that is this graph design parts done in

00:21:09,080 --> 00:21:16,210
C++ obviously to make them working in

00:21:12,410 --> 00:21:21,740
javascript is more difficult because

00:21:16,210 --> 00:21:25,340
it's a long job work of optimization to

00:21:21,740 --> 00:21:31,100
reach anyway the targeted it is required

00:21:25,340 --> 00:21:34,850
by the user so this is the compromise

00:21:31,100 --> 00:21:37,340
that it is not working and after parting

00:21:34,850 --> 00:21:42,350
after documenting the application after

00:21:37,340 --> 00:21:47,260
managing the entire system for a long

00:21:42,350 --> 00:21:53,170
time we have it was possible to focus

00:21:47,260 --> 00:21:56,480
the smarts to do parts that are not

00:21:53,170 --> 00:22:02,260
absolutely clear also now are not yet

00:21:56,480 --> 00:22:07,010
clear separately in a separate way but

00:22:02,260 --> 00:22:10,670
our focus it in a in a right way to keep

00:22:07,010 --> 00:22:16,370
them under control the user life

00:22:10,670 --> 00:22:20,750
interface is the design of parameters

00:22:16,370 --> 00:22:23,030
like big pages of switches parameters

00:22:20,750 --> 00:22:27,260
control so all all the settings that can

00:22:23,030 --> 00:22:31,070
be done on them on the cheaper and these

00:22:27,260 --> 00:22:34,850
are normal common widgets so it can be

00:22:31,070 --> 00:22:38,270
developed in in future in a QT QT quick

00:22:34,850 --> 00:22:41,510
too low to very very fast and very easy

00:22:38,270 --> 00:22:43,800
then there is user settings that is a

00:22:41,510 --> 00:22:46,950
set of file in

00:22:43,800 --> 00:22:50,550
I'll and xml file the project in the

00:22:46,950 --> 00:22:52,710
idea of the ID a application the project

00:22:50,550 --> 00:22:55,200
describing the entire behavior of the

00:22:52,710 --> 00:22:59,430
the component you load the project and

00:22:55,200 --> 00:23:02,160
the application setup the behavior and

00:22:59,430 --> 00:23:05,010
then the call and so on based on this

00:23:02,160 --> 00:23:08,520
component and done and then live data

00:23:05,010 --> 00:23:10,830
like data is the first part that we are

00:23:08,520 --> 00:23:14,330
we are presenting here because it was

00:23:10,830 --> 00:23:17,580
the most complex many graphics many

00:23:14,330 --> 00:23:25,500
different graphic elements to be plotted

00:23:17,580 --> 00:23:30,320
faster at reaching a frequency of at

00:23:25,500 --> 00:23:33,000
least 200 300 hours this mean 11

00:23:30,320 --> 00:23:38,060
interrogation too hard when one ticket

00:23:33,000 --> 00:23:40,830
to the hardware every 25 30 milliseconds

00:23:38,060 --> 00:23:45,990
give us the option to monitor components

00:23:40,830 --> 00:23:48,240
and then can be X should be extracted

00:23:45,990 --> 00:23:52,190
because it is also one of the first

00:23:48,240 --> 00:23:57,120
three bad blocks that are developed in

00:23:52,190 --> 00:23:59,660
web web components the reason that I was

00:23:57,120 --> 00:24:02,580
saying before we have not moved

00:23:59,660 --> 00:24:06,330
reporting to cutie dots five dot six

00:24:02,580 --> 00:24:09,600
because until this is not completed the

00:24:06,330 --> 00:24:12,600
web components are not removed so qt5

00:24:09,600 --> 00:24:17,220
that six adopted the new web engine

00:24:12,600 --> 00:24:21,090
faster but heavy to to to remaster again

00:24:17,220 --> 00:24:23,310
it was a part to disappear destined to

00:24:21,090 --> 00:24:27,000
disappeared so it was not the word to

00:24:23,310 --> 00:24:30,180
change this another idea that was not

00:24:27,000 --> 00:24:34,830
totally reliable no miss artists are the

00:24:30,180 --> 00:24:41,250
steps we continuously met problems and

00:24:34,830 --> 00:24:43,650
issues the problem to make this this

00:24:41,250 --> 00:24:46,380
kind of intervention is kind of revision

00:24:43,650 --> 00:24:49,240
to make it

00:24:46,380 --> 00:24:53,980
reusable strongly reusable is to create

00:24:49,240 --> 00:24:58,150
a sort of model templates and reapply

00:24:53,980 --> 00:25:01,390
the base elements not to the other all

00:24:58,150 --> 00:25:03,190
the other parts of the interface and the

00:25:01,390 --> 00:25:04,330
view controller not only the interface

00:25:03,190 --> 00:25:07,300
itself because there are also

00:25:04,330 --> 00:25:10,120
calculations and so on this was not

00:25:07,300 --> 00:25:13,570
possible because data flow is too

00:25:10,120 --> 00:25:16,140
fragmented reusable taking account just

00:25:13,570 --> 00:25:21,580
to have an idea you should consider that

00:25:16,140 --> 00:25:24,240
one of the wrong choices of this initial

00:25:21,580 --> 00:25:28,900
architecture was the use of the signals

00:25:24,240 --> 00:25:31,840
Python uses one signal class instead De

00:25:28,900 --> 00:25:34,270
Palma be this good the guys that have

00:25:31,840 --> 00:25:36,520
developed the replication discovered a

00:25:34,270 --> 00:25:38,920
debt by QT signal is fantastic because

00:25:36,520 --> 00:25:43,360
create a cutie signal the problem is

00:25:38,920 --> 00:25:46,270
dead this is used for speak from Python

00:25:43,360 --> 00:25:49,090
too cute I send a signal so cute

00:25:46,270 --> 00:25:51,610
intercepted and they can have separated

00:25:49,090 --> 00:25:54,610
two parts working instead the logic of

00:25:51,610 --> 00:25:58,330
using everything of the public utility

00:25:54,610 --> 00:26:00,820
elements as libraries they use it to see

00:25:58,330 --> 00:26:04,090
every but I a ball instead moving a

00:26:00,820 --> 00:26:05,620
pointer to a class the great signal so

00:26:04,090 --> 00:26:09,790
it's possible to use the signal

00:26:05,620 --> 00:26:14,530
somewhere else in Python the result was

00:26:09,790 --> 00:26:16,870
that there was about 170 signals managed

00:26:14,530 --> 00:26:21,070
in the application never used by the Qt

00:26:16,870 --> 00:26:24,460
framework but only use it in the Python

00:26:21,070 --> 00:26:30,070
environment creating an extremely

00:26:24,460 --> 00:26:32,710
complex path of data exchanges we're

00:26:30,070 --> 00:26:36,850
almost sixty seventy percent was

00:26:32,710 --> 00:26:40,930
redundant because undocumented without

00:26:36,850 --> 00:26:44,520
augmentation you can imagine so keeping

00:26:40,930 --> 00:26:48,820
in mind what are the goals another

00:26:44,520 --> 00:26:55,320
solution was found that is the solution

00:26:48,820 --> 00:26:55,320
that definitely it was it was used

00:26:59,610 --> 00:27:09,190
okay I don't see different things from

00:27:02,710 --> 00:27:12,340
there okay the creation offer a view

00:27:09,190 --> 00:27:16,750
controller element that is QT drivin

00:27:12,340 --> 00:27:18,910
leaving for now without plugins but can

00:27:16,750 --> 00:27:20,260
accept because it's a separate folders

00:27:18,910 --> 00:27:24,120
are physically separating the

00:27:20,260 --> 00:27:27,910
application then the only solution is

00:27:24,120 --> 00:27:30,370
for example one change involves not the

00:27:27,910 --> 00:27:33,430
class that manages that signal or that

00:27:30,370 --> 00:27:36,580
data but involves three four five

00:27:33,430 --> 00:27:40,990
classes that exchange data is almost

00:27:36,580 --> 00:27:44,440
randomly I have created a switch in

00:27:40,990 --> 00:27:47,410
Python a global switch that when you set

00:27:44,440 --> 00:27:50,710
the switch some classes that are

00:27:47,410 --> 00:27:53,080
normally used in the old version will be

00:27:50,710 --> 00:27:57,040
switching to the view controller

00:27:53,080 --> 00:28:00,220
component where I have totally clean the

00:27:57,040 --> 00:28:02,640
changes the Python classes and are

00:28:00,220 --> 00:28:07,420
exactly as the interface should work

00:28:02,640 --> 00:28:09,430
cutie framework elements view controller

00:28:07,420 --> 00:28:11,620
so all the interaction is under control

00:28:09,430 --> 00:28:14,170
of the graphic part of the user

00:28:11,620 --> 00:28:18,580
interface the user can manage things and

00:28:14,170 --> 00:28:21,250
so on exchange data with the Python

00:28:18,580 --> 00:28:25,360
component and this class are he breeds

00:28:21,250 --> 00:28:28,920
that are only with the need parts while

00:28:25,360 --> 00:28:32,380
the other are physically deleted and

00:28:28,920 --> 00:28:37,270
there is inside the modules which there

00:28:32,380 --> 00:28:40,240
is M an intermediate class that managed

00:28:37,270 --> 00:28:42,700
just the signals between the QT world

00:28:40,240 --> 00:28:45,850
and the Python world so the application

00:28:42,700 --> 00:28:49,960
can go ahead for the other all the other

00:28:45,850 --> 00:28:55,590
components by itself in in its original

00:28:49,960 --> 00:28:59,580
way while the single pass data under

00:28:55,590 --> 00:29:05,440
replacement are managed by the new area

00:28:59,580 --> 00:29:07,779
the goal is to reach this final final

00:29:05,440 --> 00:29:10,840
situation where all the elements

00:29:07,779 --> 00:29:14,249
oh that may be part of a user interface

00:29:10,840 --> 00:29:16,899
also flag also dialogue will be

00:29:14,249 --> 00:29:19,419
developed a completely working under

00:29:16,899 --> 00:29:22,679
cute and in this area this view

00:29:19,419 --> 00:29:28,179
controller folder is pure cutely while

00:29:22,679 --> 00:29:32,049
title remain at maybe almost read but

00:29:28,179 --> 00:29:35,169
anyway remain a model operational part

00:29:32,049 --> 00:29:38,799
of the software and we finally in that

00:29:35,169 --> 00:29:42,759
moment we are able to remove the problem

00:29:38,799 --> 00:29:45,580
the where the real original issue that

00:29:42,759 --> 00:29:48,099
is Piton launched in cute that starting

00:29:45,580 --> 00:29:52,779
discussing to python to asking python to

00:29:48,099 --> 00:29:57,279
send back data net makes dis dis trouble

00:29:52,779 --> 00:30:00,159
in the end application so QT qml

00:29:57,279 --> 00:30:03,909
components the connection class the

00:30:00,159 --> 00:30:05,589
framework to the python and then the

00:30:03,909 --> 00:30:09,070
python module architecture that is as a

00:30:05,589 --> 00:30:13,330
matter of fact how the software now is

00:30:09,070 --> 00:30:16,479
working in the original fire phase how

00:30:13,330 --> 00:30:18,969
to be broke this part because keeping

00:30:16,479 --> 00:30:20,799
hands on these classes discover what

00:30:18,969 --> 00:30:24,399
should be removed what can be removed

00:30:20,799 --> 00:30:29,649
without impacting in issues and so on is

00:30:24,399 --> 00:30:34,599
almost complex so first it was created

00:30:29,649 --> 00:30:39,099
with a complex complex randomizer trucks

00:30:34,599 --> 00:30:42,190
class in python a simulator that works

00:30:39,099 --> 00:30:44,200
just like how data are sent in the

00:30:42,190 --> 00:30:49,029
moment that should communicate between

00:30:44,200 --> 00:30:51,519
the python and the QT components in this

00:30:49,029 --> 00:30:54,489
simulator totally compatible with the

00:30:51,519 --> 00:30:57,429
kind of data that we really will will

00:30:54,489 --> 00:31:01,210
never to use when the application will

00:30:57,429 --> 00:31:04,899
work it has been created a test bench to

00:31:01,210 --> 00:31:11,349
calibrate and study this problem this

00:31:04,899 --> 00:31:14,320
graphics modules this is the idea and as

00:31:11,349 --> 00:31:17,510
you can imagine in cute this is almost

00:31:14,320 --> 00:31:20,790
easy creating every parts

00:31:17,510 --> 00:31:25,040
focusing in every part the component and

00:31:20,790 --> 00:31:29,880
then the graphic is totally parametric

00:31:25,040 --> 00:31:35,460
it is managed by a JSON configuration

00:31:29,880 --> 00:31:38,100
file so as well when the Python program

00:31:35,460 --> 00:31:40,710
starts and loading from the project

00:31:38,100 --> 00:31:45,630
discover what is the hardware in that

00:31:40,710 --> 00:31:48,900
moment working automatically it

00:31:45,630 --> 00:31:52,679
recognized that the hardware ID basic on

00:31:48,900 --> 00:31:54,570
the already lost the JSON file in the in

00:31:52,679 --> 00:31:58,140
the Python standard at the QT part

00:31:54,570 --> 00:32:00,870
loader JSON file and adapt the graphics

00:31:58,140 --> 00:32:03,750
with the limits the behavior the the

00:32:00,870 --> 00:32:09,570
title the x-axis the labels and so on

00:32:03,750 --> 00:32:13,890
depending on the hard one so just to

00:32:09,570 --> 00:32:19,700
give you an idea of the complexity just

00:32:13,890 --> 00:32:24,660
the plot elements are a set of almost 30

00:32:19,700 --> 00:32:28,050
50 different variables that are managed

00:32:24,660 --> 00:32:31,740
every call every time that dick has sent

00:32:28,050 --> 00:32:34,890
to a policy to the hardware layer the

00:32:31,740 --> 00:32:37,590
chip send back about eight kappa bytes

00:32:34,890 --> 00:32:42,740
of data that are all the variables that

00:32:37,590 --> 00:32:45,990
it is available so the QT part should

00:32:42,740 --> 00:32:50,520
identify what are the variable between

00:32:45,990 --> 00:32:54,559
these 5150 ones what other variables

00:32:50,520 --> 00:32:57,330
should be plot really limit this and

00:32:54,559 --> 00:33:02,670
optimize the plotting and the behavior

00:32:57,330 --> 00:33:04,830
to these variables one graph then the

00:33:02,670 --> 00:33:08,670
same model in the simulation a flawed

00:33:04,830 --> 00:33:10,800
approach was develop a simple a grid

00:33:08,670 --> 00:33:15,390
system with the control bar for users to

00:33:10,800 --> 00:33:18,059
manage zooming activating because you

00:33:15,390 --> 00:33:22,890
have 50 different graphs you have a pool

00:33:18,059 --> 00:33:25,350
of six visualization the same time the

00:33:22,890 --> 00:33:27,320
original version in the webview was

00:33:25,350 --> 00:33:30,260
viewing was showing it

00:33:27,320 --> 00:33:33,020
no idea why for three different graphs

00:33:30,260 --> 00:33:35,420
in the same time absolutely impossible

00:33:33,020 --> 00:33:38,510
to see because you can imagine what you

00:33:35,420 --> 00:33:42,260
you can obviously absolutely stop with

00:33:38,510 --> 00:33:45,620
the rubber very heavy with 40 different

00:33:42,260 --> 00:33:49,370
web instance under Q in the pike you two

00:33:45,620 --> 00:33:51,860
managers but directly by by Python this

00:33:49,370 --> 00:33:57,770
is the radial design of the new

00:33:51,860 --> 00:33:59,630
interface and then focus it clearly

00:33:57,770 --> 00:34:03,890
focusing the parameters that have the

00:33:59,630 --> 00:34:08,030
control of the user in partially

00:34:03,890 --> 00:34:10,580
manually partially automatic is obvious

00:34:08,030 --> 00:34:13,100
almost obvious gridlines one density

00:34:10,580 --> 00:34:17,890
what what do you want how many points

00:34:13,100 --> 00:34:22,210
and so on the interface at this point

00:34:17,890 --> 00:34:26,660
enters another part this is an opensuse

00:34:22,210 --> 00:34:30,350
framework that will be powerfully Lisa

00:34:26,660 --> 00:34:31,730
dhanji tab in this part of this of the

00:34:30,350 --> 00:34:34,310
attachment of this part of this

00:34:31,730 --> 00:34:37,660
conference that is a cutie complex I

00:34:34,310 --> 00:34:40,400
develop this a few years ago for nokia

00:34:37,660 --> 00:34:44,360
because it is a framework that optimizes

00:34:40,400 --> 00:34:48,020
the creation of toolbar Sabaton basis on

00:34:44,360 --> 00:34:50,960
themes and is it interesting it works on

00:34:48,020 --> 00:34:54,160
any platform but in times of Nokia words

00:34:50,960 --> 00:35:00,950
from Simeon Linux embedded Linux up to

00:34:54,160 --> 00:35:04,370
the desktop versions and then it's it

00:35:00,950 --> 00:35:08,240
makes easy for me very very very faster

00:35:04,370 --> 00:35:11,830
to development lifecycle of the graphic

00:35:08,240 --> 00:35:16,400
elements because most of the parts that

00:35:11,830 --> 00:35:19,780
are conventional standard the Qt Quick

00:35:16,400 --> 00:35:22,330
to the two components

00:35:19,780 --> 00:35:25,240
are already pre-built with the paramedic

00:35:22,330 --> 00:35:28,780
parameters the version that will be

00:35:25,240 --> 00:35:31,240
released is a version specifically

00:35:28,780 --> 00:35:32,920
adaptive because obviously this

00:35:31,240 --> 00:35:36,220
framework was working with it sound

00:35:32,920 --> 00:35:38,650
plugins in C++ that here are not

00:35:36,220 --> 00:35:44,170
possible to be used can be used so I'll

00:35:38,650 --> 00:35:47,500
replace it with a version that is a data

00:35:44,170 --> 00:35:50,370
to cutie five dot five dot one support

00:35:47,500 --> 00:35:53,860
you to the quick to the two and is

00:35:50,370 --> 00:35:57,310
JavaScript in qml only with anyway

00:35:53,860 --> 00:36:04,540
keeping a good a good results in terms

00:35:57,310 --> 00:36:08,230
of off speed so where we are arriving to

00:36:04,540 --> 00:36:11,260
create the things that should be avoided

00:36:08,230 --> 00:36:14,230
in there in any literature a parallel

00:36:11,260 --> 00:36:17,640
architecture support an architecture in

00:36:14,230 --> 00:36:21,910
version that is in progress by one side

00:36:17,640 --> 00:36:23,950
moving everything and cute and also

00:36:21,910 --> 00:36:26,110
simplifying removing classes removing

00:36:23,950 --> 00:36:30,100
objects removing parts Python becomes

00:36:26,110 --> 00:36:32,140
more under control and or is the

00:36:30,100 --> 00:36:36,400
original the traditional Welsh on port

00:36:32,140 --> 00:36:39,100
80 to 85 @ x 55 where the core of the

00:36:36,400 --> 00:36:43,830
application remain until we don't remove

00:36:39,100 --> 00:36:50,050
and move and push on the other side so

00:36:43,830 --> 00:36:53,320
this means two timelines and then there

00:36:50,050 --> 00:36:57,340
is a slide with some sample data almost

00:36:53,320 --> 00:36:59,530
clear but taking account that we have it

00:36:57,340 --> 00:37:03,130
was possible to create a fact attend

00:36:59,530 --> 00:37:06,010
factor between the interface ability to

00:37:03,130 --> 00:37:09,730
plot data the simulator is able to work

00:37:06,010 --> 00:37:12,820
with six graphs plotting every graph as

00:37:09,730 --> 00:37:14,950
two lines because audio is theory also

00:37:12,820 --> 00:37:18,940
left and right the parallel data that

00:37:14,950 --> 00:37:23,620
are sent so 12 plotting data in the

00:37:18,940 --> 00:37:26,550
meantime every one plot every 25

00:37:23,620 --> 00:37:30,360
milliseconds only in JavaScript

00:37:26,550 --> 00:37:34,050
support so I imagine what the result we

00:37:30,360 --> 00:37:37,830
will get in with their better plugins in

00:37:34,050 --> 00:37:43,200
C++ by the other side Python is able to

00:37:37,830 --> 00:37:45,390
send back data every now 125 150

00:37:43,200 --> 00:37:51,060
milliseconds depends on the kind of

00:37:45,390 --> 00:37:53,970
connection now this is the starting

00:37:51,060 --> 00:37:56,970
point of the porting after acquiring the

00:37:53,970 --> 00:37:59,280
knowledge after after all so you see

00:37:56,970 --> 00:38:02,100
that there is an app or Python an

00:37:59,280 --> 00:38:04,830
application entry point that is run just

00:38:02,100 --> 00:38:07,100
run is the name then immediately go to a

00:38:04,830 --> 00:38:09,930
creation of the windows user interface

00:38:07,100 --> 00:38:11,430
this interface design we just design

00:38:09,930 --> 00:38:14,760
dialogue design contains everything

00:38:11,430 --> 00:38:18,720
hidden oh sure then create a tree with

00:38:14,760 --> 00:38:21,150
view every every web you is custom so

00:38:18,720 --> 00:38:23,880
should be removed also because we need

00:38:21,150 --> 00:38:26,430
to make modular and adaptable to any

00:38:23,880 --> 00:38:29,900
kind of the of device as now for device

00:38:26,430 --> 00:38:32,820
new cheap new development of the new

00:38:29,900 --> 00:38:35,760
another web view specific for the chip

00:38:32,820 --> 00:38:38,220
then there are components that at one

00:38:35,760 --> 00:38:42,080
time and device interface that speak

00:38:38,220 --> 00:38:46,200
continuously Paul with the hardware and

00:38:42,080 --> 00:38:48,450
send data sea with throughout this 170

00:38:46,200 --> 00:38:52,980
pie cutie signals not use it by cute

00:38:48,450 --> 00:38:55,710
because cute is not used but only as a

00:38:52,980 --> 00:39:01,260
library to design things under the

00:38:55,710 --> 00:39:04,760
Python control so the live data in

00:39:01,260 --> 00:39:08,880
version the architectural inversion

00:39:04,760 --> 00:39:13,710
should start from one module first the

00:39:08,880 --> 00:39:15,900
most complex and the most issues and the

00:39:13,710 --> 00:39:19,169
slow

00:39:15,900 --> 00:39:23,739
plotting like uploading data and then as

00:39:19,169 --> 00:39:27,009
this is done every parts can be smooth

00:39:23,739 --> 00:39:28,719
and reusing use it the parts that we

00:39:27,009 --> 00:39:31,209
have already developed but because the

00:39:28,719 --> 00:39:34,989
quality complex is a standard framework

00:39:31,209 --> 00:39:39,549
that now it is used by tons of of users

00:39:34,989 --> 00:39:41,619
are almost a stable by years and is a

00:39:39,549 --> 00:39:47,019
well-known by beings i have created and

00:39:41,619 --> 00:39:50,769
documented also because the architecture

00:39:47,019 --> 00:39:56,650
in acute qml acute is is done stress

00:39:50,769 --> 00:39:59,799
strongly modular and also because we can

00:39:56,650 --> 00:40:01,719
manage inside of this sort of protective

00:39:59,799 --> 00:40:04,179
container that is the view controller in

00:40:01,719 --> 00:40:06,189
the new architecture manage also the

00:40:04,179 --> 00:40:09,489
python classes that has strong issues

00:40:06,189 --> 00:40:14,109
and remove the past that we know so the

00:40:09,489 --> 00:40:20,130
idea and my opinion is the only possible

00:40:14,109 --> 00:40:23,019
idea in a session so dramatic is just

00:40:20,130 --> 00:40:25,179
starting from the first web you removing

00:40:23,019 --> 00:40:28,479
the second moving the third and then

00:40:25,179 --> 00:40:33,219
step by step moving everything to the

00:40:28,479 --> 00:40:35,380
other side to have the final QT

00:40:33,219 --> 00:40:40,269
architecture really the view controller

00:40:35,380 --> 00:40:42,549
model dead act less like a corner to the

00:40:40,269 --> 00:40:44,439
Python instead Python course the

00:40:42,549 --> 00:40:48,669
architecture that should manage itself

00:40:44,439 --> 00:40:52,390
this is the the problem these are the

00:40:48,669 --> 00:40:55,509
advantages okay we base it on the tests

00:40:52,390 --> 00:40:59,529
physical tests done with the profiler in

00:40:55,509 --> 00:41:05,650
Python and with the simulator in in the

00:40:59,529 --> 00:41:09,849
QT design we have a range between 20 we

00:41:05,650 --> 00:41:12,959
have a change of 125 milliseconds with

00:41:09,849 --> 00:41:17,499
the ability to manage 25 milliseconds

00:41:12,959 --> 00:41:20,709
taking account that anyway for now we

00:41:17,499 --> 00:41:23,859
manage a call every 25 milliseconds but

00:41:20,709 --> 00:41:25,150
sure that are replicated because they

00:41:23,859 --> 00:41:29,619
are dwelling

00:41:25,150 --> 00:41:32,349
my python is not yet totally clean and

00:41:29,619 --> 00:41:35,740
it's not yet totally faster as we need

00:41:32,349 --> 00:41:37,839
so not always able to shift to send the

00:41:35,740 --> 00:41:40,480
data and the system the reason that

00:41:37,839 --> 00:41:44,559
should work totally synchronously cue to

00:41:40,480 --> 00:41:47,380
go and simply ask information if

00:41:44,559 --> 00:41:49,900
available change data as rip lot at the

00:41:47,380 --> 00:41:54,039
same point so we can have a constant

00:41:49,900 --> 00:41:58,029
pick a serial serious co static Python

00:41:54,039 --> 00:42:01,569
manage harder as it sound frequency in

00:41:58,029 --> 00:42:05,319
the optimization process with respect we

00:42:01,569 --> 00:42:08,859
can reach 15 16 milliseconds every

00:42:05,319 --> 00:42:11,740
everything in the polling and then when

00:42:08,859 --> 00:42:16,750
the entire project is moving we can

00:42:11,740 --> 00:42:22,089
reach the final this time lines are a

00:42:16,750 --> 00:42:26,020
bit I kept everything as low as possible

00:42:22,089 --> 00:42:29,260
now to be sure that then the application

00:42:26,020 --> 00:42:34,029
we work in a real environment so timing

00:42:29,260 --> 00:42:37,420
of 25 milliseconds instead of 125 and so

00:42:34,029 --> 00:42:40,660
on are all based on a virtual machine

00:42:37,420 --> 00:42:43,990
that is already a bit slower with

00:42:40,660 --> 00:42:49,660
configure Windows 10 a single core and

00:42:43,990 --> 00:42:53,829
only for 4000 kappa bites so is a very

00:42:49,660 --> 00:42:55,690
poor machine and anyway is far to be the

00:42:53,829 --> 00:42:58,930
machines that usually are you are

00:42:55,690 --> 00:43:05,109
managed by the only bite by the users to

00:42:58,930 --> 00:43:10,990
manage like live data so this is where

00:43:05,109 --> 00:43:16,270
we should be created a new architecture

00:43:10,990 --> 00:43:20,619
design that includes all the user

00:43:16,270 --> 00:43:26,200
interface and when the Python includes

00:43:20,619 --> 00:43:29,049
only the parts related to the model as

00:43:26,200 --> 00:43:31,960
we as we consider not but speaking with

00:43:29,049 --> 00:43:36,970
the hardware and so on we can also

00:43:31,960 --> 00:43:38,420
finally remove that perversion of the

00:43:36,970 --> 00:43:42,170
Python launching

00:43:38,420 --> 00:43:47,859
cute but maybe cute that start a fight

00:43:42,170 --> 00:43:51,319
oh model and the initial idea to have

00:43:47,859 --> 00:43:54,829
cutie view controller starts the

00:43:51,319 --> 00:43:57,319
interface not the project design the

00:43:54,829 --> 00:44:02,290
project based on the hardware this

00:43:57,319 --> 00:44:06,799
project describes set up everything then

00:44:02,290 --> 00:44:09,230
use Python just because it's useful for

00:44:06,799 --> 00:44:12,260
asthma it's already done is already

00:44:09,230 --> 00:44:16,240
working for now that's okay use Python

00:44:12,260 --> 00:44:20,000
as a Python plugin from cute as well as

00:44:16,240 --> 00:44:22,730
the first design object for the other

00:44:20,000 --> 00:44:28,549
part of the interface that are C++

00:44:22,730 --> 00:44:32,230
plugin this is the kind of job that is

00:44:28,549 --> 00:44:34,880
done I I plan to release according with

00:44:32,230 --> 00:44:36,650
the parts that can't be obviously

00:44:34,880 --> 00:44:39,680
release it because our property of Linux

00:44:36,650 --> 00:44:44,470
p anyway as open source the course

00:44:39,680 --> 00:44:51,099
triplets that I think that are useful if

00:44:44,470 --> 00:44:54,049
someone is interested to to show the

00:44:51,099 --> 00:44:56,500
Houthis approaches there is done for

00:44:54,049 --> 00:44:59,390
example that the graphic engine that is

00:44:56,500 --> 00:45:03,020
has been optimized they're spending a

00:44:59,390 --> 00:45:05,619
lot of time do the limitations is a pure

00:45:03,020 --> 00:45:08,270
qml in JavaScript engine self adapting

00:45:05,619 --> 00:45:11,210
uses the framework and this interesting

00:45:08,270 --> 00:45:14,329
to release itself as an independent

00:45:11,210 --> 00:45:17,990
object open source in this case is used

00:45:14,329 --> 00:45:20,599
by an XP but they almost almost open i

00:45:17,990 --> 00:45:22,970
appreciated also very much because

00:45:20,599 --> 00:45:24,890
working with that with the disc Rios was

00:45:22,970 --> 00:45:27,200
interesting because when I say okay this

00:45:24,890 --> 00:45:30,020
may be useful for all the question is

00:45:27,200 --> 00:45:32,569
this impact with the information of the

00:45:30,020 --> 00:45:34,190
company no is a generic element so

00:45:32,569 --> 00:45:36,609
programming and developing an

00:45:34,190 --> 00:45:39,799
architecture with a minimal of logic

00:45:36,609 --> 00:45:43,270
many paths can be in effect distributed

00:45:39,799 --> 00:45:43,270
and there's an advantage for all

00:45:43,779 --> 00:45:52,819
now I want to show you just a couple of

00:45:49,489 --> 00:45:56,959
minute of a video that is asking caster

00:45:52,819 --> 00:46:00,440
that they are producing with actual

00:45:56,959 --> 00:46:20,390
results to give an idea of what we have

00:46:00,440 --> 00:46:22,459
spoken and now the Tudor faces start at

00:46:20,390 --> 00:46:26,079
the paper conservator independents are

00:46:22,459 --> 00:46:26,079
totally different processes

00:46:26,740 --> 00:46:32,700
this is the original interface very all

00:46:30,250 --> 00:46:36,480
we just should everything disappear and

00:46:32,700 --> 00:46:39,880
their other okay other is recognizing

00:46:36,480 --> 00:46:44,230
system sets their hardware of organized

00:46:39,880 --> 00:46:46,750
optimized parameters then the part that

00:46:44,230 --> 00:46:50,020
should be initially shown here are shown

00:46:46,750 --> 00:46:53,410
there note that graph itself adapter and

00:46:50,020 --> 00:46:56,110
changes as the hardware is set okay it's

00:46:53,410 --> 00:46:58,090
recognized the kind of parameters that

00:46:56,110 --> 00:47:01,090
should be shown what are the very the

00:46:58,090 --> 00:47:05,460
limits of the graphics and so on faded

00:47:01,090 --> 00:47:09,100
and start plotting horizontal lines

00:47:05,460 --> 00:47:12,280
depends because the first plotting in

00:47:09,100 --> 00:47:15,310
the in the user interface ask more

00:47:12,280 --> 00:47:18,790
frequently to fight on data that is not

00:47:15,310 --> 00:47:27,369
yet available so data are replicated

00:47:18,790 --> 00:47:33,369
anyway with a reliable results of the

00:47:27,369 --> 00:47:35,650
return policy now seeing severe that I

00:47:33,369 --> 00:47:39,619
think is a self adjusting the specific

00:47:35,650 --> 00:47:42,750
user that ability

00:47:39,619 --> 00:47:47,010
elements of retaining city already done

00:47:42,750 --> 00:47:51,000
but it is just the last point Richard

00:47:47,010 --> 00:47:54,200
not to show now as a very pure de let

00:47:51,000 --> 00:47:58,490
the very first preview of this project

00:47:54,200 --> 00:48:01,800
that the stability matrix has also

00:47:58,490 --> 00:48:03,810
immediately the size because these are

00:48:01,800 --> 00:48:08,040
pieces that are all under control of

00:48:03,810 --> 00:48:11,760
beauty this is the Nisshin passenger

00:48:08,040 --> 00:48:17,060
interface as the elements are removable

00:48:11,760 --> 00:48:21,690
interface become more complex and with

00:48:17,060 --> 00:48:24,109
over menus over components and he's

00:48:21,690 --> 00:48:27,420
become one part of the view o Allah may

00:48:24,109 --> 00:48:30,840
now we see six verbs because i use c

00:48:27,420 --> 00:48:33,480
square originally if you have surfed a

00:48:30,840 --> 00:48:37,650
bar i have all of 25 reliable they was

00:48:33,480 --> 00:48:40,020
showing 25 different web view not only

00:48:37,650 --> 00:48:44,910
but plotting the graphs that you wasn't

00:48:40,020 --> 00:48:48,990
see what you wasn't seeing so it was

00:48:44,910 --> 00:48:53,660
very very heavy very dispersing very

00:48:48,990 --> 00:48:58,080
time-consuming mechanism okay this is a

00:48:53,660 --> 00:49:00,720
dictionary oh and the case that I am

00:48:58,080 --> 00:49:05,670
this is the first phase of the challenge

00:49:00,720 --> 00:49:09,450
I have survived it now okay thank you

00:49:05,670 --> 00:49:14,940
Mary go other questions from the

00:49:09,450 --> 00:49:18,440
audience on the nxp use case these raise

00:49:14,940 --> 00:49:18,440
your hands and I'll give you a mic and

00:49:18,859 --> 00:49:26,460
otherwise I have one question you're

00:49:22,619 --> 00:49:31,109
moving a lot of functionality from icon

00:49:26,460 --> 00:49:33,930
to C++ and traditionally we'd say python

00:49:31,109 --> 00:49:37,530
is a rapid development language and C++

00:49:33,930 --> 00:49:41,640
takes a lot more effort do you notice

00:49:37,530 --> 00:49:47,369
that in porting the application in a way

00:49:41,640 --> 00:49:49,790
that you're doing by tony is i think

00:49:47,369 --> 00:49:52,850
that the best definition of python use a

00:49:49,790 --> 00:49:56,480
in the cute doc this is a fast

00:49:52,850 --> 00:49:58,880
prototyping software now you can really

00:49:56,480 --> 00:50:03,620
develop very fast to develop very but

00:49:58,880 --> 00:50:05,870
it's a sort of me rage because you have

00:50:03,620 --> 00:50:08,270
five don't tighten do everything also

00:50:05,870 --> 00:50:10,430
specially in embedded system bigger than

00:50:08,270 --> 00:50:14,030
on raspberry any kind there is a library

00:50:10,430 --> 00:50:16,760
of title what is it is a strong C++

00:50:14,030 --> 00:50:20,090
component that someone that is able to

00:50:16,760 --> 00:50:21,860
program as developed and then you use

00:50:20,090 --> 00:50:25,060
Python because you have a rapper like

00:50:21,860 --> 00:50:27,530
just by 35 this is the big

00:50:25,060 --> 00:50:31,990
misunderstanding Python is nice because

00:50:27,530 --> 00:50:36,070
is useful to interface strong languages

00:50:31,990 --> 00:50:47,600
but if you think to develop in Python

00:50:36,070 --> 00:50:51,550
strong applications in Python this is

00:50:47,600 --> 00:50:54,890
essentially a an error a formal error

00:50:51,550 --> 00:50:59,360
because you make just like developing

00:50:54,890 --> 00:51:03,610
eaten interpreted basic depth avington

00:50:59,360 --> 00:51:07,000
infinite time now a very good big

00:51:03,610 --> 00:51:12,080
company group instead I was alone

00:51:07,000 --> 00:51:14,410
developing this okay guys desire the

00:51:12,080 --> 00:51:18,080
fashion develop the sea components and

00:51:14,410 --> 00:51:21,440
make the wrappers so extend the pie qt5

00:51:18,080 --> 00:51:24,320
library but as not so much sense because

00:51:21,440 --> 00:51:27,890
it's better that we use the standard as

00:51:24,320 --> 00:51:30,740
we should imply a maintenance of

00:51:27,890 --> 00:51:33,260
non-standard easy components that become

00:51:30,740 --> 00:51:35,570
heavy and very expensive in the future

00:51:33,260 --> 00:51:38,120
along the time of the of the of the

00:51:35,570 --> 00:51:41,540
application so it is better for now to

00:51:38,120 --> 00:51:44,330
adopt the compromise ok you p qm l with

00:51:41,540 --> 00:51:47,540
QT quick to dot to is anyway very fast

00:51:44,330 --> 00:51:50,870
and it's very flexible because this is a

00:51:47,540 --> 00:51:55,550
totally it for me it was every week

00:51:50,870 --> 00:51:58,400
totally unexpected no we have your

00:51:55,550 --> 00:52:01,370
unexpected thing a new issue things

00:51:58,400 --> 00:52:03,120
impossible to discover why reversing

00:52:01,370 --> 00:52:05,610
gene continues XO

00:52:03,120 --> 00:52:10,410
python okay remain until we can't remove

00:52:05,610 --> 00:52:13,250
or we'd be or we can use just like the

00:52:10,410 --> 00:52:17,730
rapid prototyping or rapid development

00:52:13,250 --> 00:52:20,070
but python calls anyway faster why

00:52:17,730 --> 00:52:21,420
because there is a dll the dll is the

00:52:20,070 --> 00:52:24,570
simulation of the android linux

00:52:21,420 --> 00:52:27,990
component and is the dll that works a

00:52:24,570 --> 00:52:29,910
low-level developers in c++ that asked

00:52:27,990 --> 00:52:34,860
to the hardware and send back

00:52:29,910 --> 00:52:39,240
information is not tighten it is a sort

00:52:34,860 --> 00:52:42,300
of false false vision that as many IC

00:52:39,240 --> 00:52:44,490
main user em they say uh also specially

00:52:42,300 --> 00:52:46,860
you raspberry p or embedded application

00:52:44,490 --> 00:52:48,570
users they love the python because with

00:52:46,860 --> 00:52:51,860
Python you can do everything you do

00:52:48,570 --> 00:52:55,440
nothing there because the producers

00:52:51,860 --> 00:52:58,140
release Python libraries that are any

00:52:55,440 --> 00:53:01,410
way rappers of C++ libraries this is

00:52:58,140 --> 00:53:04,890
good for teaching is good for new buys

00:53:01,410 --> 00:53:08,400
is great approaching program because if

00:53:04,890 --> 00:53:10,490
you are not not so used by my cube UK

00:53:08,400 --> 00:53:14,300
okay develop make a test with patent

00:53:10,490 --> 00:53:17,720
make a faster source but not an

00:53:14,300 --> 00:53:21,660
architect to complex that street

00:53:17,720 --> 00:53:24,030
streaking so many data enus in a cage

00:53:21,660 --> 00:53:29,100
fight in python that they have developed

00:53:24,030 --> 00:53:32,700
in the any file parsing it needs ten

00:53:29,100 --> 00:53:34,800
seconds to open a file just no sense but

00:53:32,700 --> 00:53:37,860
it's not a problem spider is the wrong

00:53:34,800 --> 00:53:40,650
usage of the language because it is

00:53:37,860 --> 00:53:44,460
using a finger with another function is

00:53:40,650 --> 00:53:46,950
like a user use a crystal glass as a

00:53:44,460 --> 00:53:50,820
hammer and then you can't complain that

00:53:46,950 --> 00:53:54,510
is a broken thank you yeah other

00:53:50,820 --> 00:53:57,360
questions if there are no other

00:53:54,510 --> 00:53:59,610
questions I'd like to thank any go for a

00:53:57,360 --> 00:54:05,630
stone

00:53:59,610 --> 00:54:05,630

YouTube URL: https://www.youtube.com/watch?v=ieEM3VKCcc8


