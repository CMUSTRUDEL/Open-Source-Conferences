Title: Barak Chamo: Hey presto, CSS!
Publication date: 2017-05-19
Playlist: CSSConf AU 2016
Description: 
	Thank you to Mozilla for making video recording possible.

The Houdini draft spec is perhaps the most exciting development in CSS since rounded corners! and while a magicians never reveal their secrets, the Houdini spec’s aim is to demystify and explain a lot of the “magic”that is CSS.

This collection of lower-level APIs included in the spec provides developers with access to the CSS engine itself and enables things like custom layouts, composition, writing our own properties and values and many more powerful features.

amazing: ‘absolutely!’;

While the Houdini draft spec is still in very early stages it is backed by all major browsers and it’s important for us, as the web community, to discuss the future of CSS, provide our feedback and push the web forward.
Captions: 
	00:00:05,910 --> 00:00:11,480
so hello everyone I'm Brock

00:00:09,389 --> 00:00:14,150
today we'll be talking about

00:00:11,480 --> 00:00:16,550
yeah the Houdini spec and will get

00:00:14,150 --> 00:00:19,550
exactly to what it is I'll start with

00:00:16,550 --> 00:00:21,320
the mandatory short introduction I'm a

00:00:19,550 --> 00:00:23,540
web developer based in London currently

00:00:21,320 --> 00:00:25,550
even though after being here for a few

00:00:23,540 --> 00:00:29,150
days I'm starting to reconsider my life

00:00:25,550 --> 00:00:30,650
decisions but I've been doing web in

00:00:29,150 --> 00:00:34,220
front-end development web development

00:00:30,650 --> 00:00:36,320
and design for a long time back when

00:00:34,220 --> 00:00:40,510
marquee and blink were still working and

00:00:36,320 --> 00:00:44,090
not deprecated and I've seen the web

00:00:40,510 --> 00:00:46,609
transition through different phases

00:00:44,090 --> 00:00:49,789
JavaScript and CSS through CSS 1 and 2

00:00:46,609 --> 00:00:53,000
and 3 and JavaScript yes five and six

00:00:49,789 --> 00:00:54,829
and now seven and our tools and our

00:00:53,000 --> 00:00:57,140
languages that we're using evolve all

00:00:54,829 --> 00:01:00,440
the time and what I want to talk to you

00:00:57,140 --> 00:01:02,359
about today is how can we deal with this

00:01:00,440 --> 00:01:04,879
ever-changing probably the most dynamic

00:01:02,359 --> 00:01:08,510
environment in programming and in

00:01:04,879 --> 00:01:11,690
development today so really what we're

00:01:08,510 --> 00:01:14,390
talking about is magic um it's the magic

00:01:11,690 --> 00:01:16,700
behind CSS how to understand it and how

00:01:14,390 --> 00:01:19,009
we can make our own magic but before

00:01:16,700 --> 00:01:21,259
that let's talk about the parts of CSS

00:01:19,009 --> 00:01:24,200
that are not as magical there's a term

00:01:21,259 --> 00:01:27,850
in Japanese called Ching Gogu inch

00:01:24,200 --> 00:01:30,500
indigo is the art and tradition of

00:01:27,850 --> 00:01:33,439
building over-engineered sometimes

00:01:30,500 --> 00:01:36,619
seemingly useless inventions to solve

00:01:33,439 --> 00:01:40,610
everyday problems yes so we can see come

00:01:36,619 --> 00:01:41,899
really great examples and they are you

00:01:40,610 --> 00:01:44,750
know at the end of the day these are

00:01:41,899 --> 00:01:46,969
useful but they're just seemingly over

00:01:44,750 --> 00:01:48,740
engineered and how does that relate to

00:01:46,969 --> 00:01:51,469
web development where can we see over

00:01:48,740 --> 00:01:53,930
engineering in our daily life well let's

00:01:51,469 --> 00:01:56,329
talk about rounded corners rounded

00:01:53,930 --> 00:01:58,520
corners up until a few years ago before

00:01:56,329 --> 00:02:00,890
border-radius became ubiquitous the way

00:01:58,520 --> 00:02:04,250
to dream of all web developers the

00:02:00,890 --> 00:02:06,939
entire web went rounded with web 2.0 and

00:02:04,250 --> 00:02:10,039
apple's inspired design we all wanted

00:02:06,939 --> 00:02:12,260
boarded border-radius on our divs and we

00:02:10,039 --> 00:02:15,890
used it everywhere but the problem was

00:02:12,260 --> 00:02:18,980
that the adoption of border-radius in

00:02:15,890 --> 00:02:22,400
browsers was not clear-cut it was not

00:02:18,980 --> 00:02:24,019
available across the web immediately so

00:02:22,400 --> 00:02:24,450
we were building our websites on our

00:02:24,019 --> 00:02:27,660
powerful

00:02:24,450 --> 00:02:29,849
MacBooks and fancy canary Chrome's and

00:02:27,660 --> 00:02:31,560
latest versions of everything and the

00:02:29,849 --> 00:02:33,690
latest and greatest of CSS was working

00:02:31,560 --> 00:02:38,069
perfectly about when we were work when

00:02:33,690 --> 00:02:41,280
you open a website on IE 6 or 7 or 8

00:02:38,069 --> 00:02:43,230
you'd be horrified and err all the work

00:02:41,280 --> 00:02:44,519
that you've put into your amazing

00:02:43,230 --> 00:02:46,680
website and it just looks like crap

00:02:44,519 --> 00:02:49,410
doesn't work the layout breaks it's a

00:02:46,680 --> 00:02:50,700
disaster so we started becoming

00:02:49,410 --> 00:02:55,340
inventive and you went at our own

00:02:50,700 --> 00:02:56,819
border-radius and you just find my mouse

00:02:55,340 --> 00:02:59,880
here we go

00:02:56,819 --> 00:03:01,980
we invented our own border-radius and if

00:02:59,880 --> 00:03:04,260
any of you recognize this we started

00:03:01,980 --> 00:03:05,940
using images to render them to the color

00:03:04,260 --> 00:03:06,870
of our divs and we created our own

00:03:05,940 --> 00:03:09,390
border-radius

00:03:06,870 --> 00:03:12,510
I think that qualifies to the definition

00:03:09,390 --> 00:03:14,160
of over-engineering and why do we have

00:03:12,510 --> 00:03:16,079
to deal with these problems why do we

00:03:14,160 --> 00:03:18,000
have to render images to pretend that we

00:03:16,079 --> 00:03:19,560
have border-radius to make sure that

00:03:18,000 --> 00:03:22,170
they're visible to everyone and the

00:03:19,560 --> 00:03:25,170
answer is the process of CSS standards

00:03:22,170 --> 00:03:26,910
how do new features of CSS end up on the

00:03:25,170 --> 00:03:29,609
web in the browsers available to

00:03:26,910 --> 00:03:31,799
everyone well we start by proposing a

00:03:29,609 --> 00:03:34,079
feature each part of CSS starts as a

00:03:31,799 --> 00:03:36,180
future proposal we can say I think

00:03:34,079 --> 00:03:38,519
border-radius is a great idea and we

00:03:36,180 --> 00:03:41,040
should have it well you go on to write a

00:03:38,519 --> 00:03:42,930
spec to detail an API to say why it's

00:03:41,040 --> 00:03:45,060
beneficial to give examples to write a

00:03:42,930 --> 00:03:47,730
mock implementation and then the vendors

00:03:45,060 --> 00:03:51,769
Chrome Firefox and Safari they go on to

00:03:47,730 --> 00:03:54,690
implement that spec the the CSS spec and

00:03:51,769 --> 00:03:57,359
then people update their browsers and

00:03:54,690 --> 00:03:59,489
they get better and better adoption of

00:03:57,359 --> 00:04:01,739
new features and only then can we use

00:03:59,489 --> 00:04:03,450
these features the problem is that

00:04:01,739 --> 00:04:06,750
between vendor implementation and

00:04:03,450 --> 00:04:08,549
browser adoption lies a chasm where CSS

00:04:06,750 --> 00:04:11,370
specs go to die

00:04:08,549 --> 00:04:12,569
and features can spend years there if

00:04:11,370 --> 00:04:13,290
you look at the implementation of

00:04:12,569 --> 00:04:16,470
fluxbox

00:04:13,290 --> 00:04:18,209
it was several years and we're still

00:04:16,470 --> 00:04:21,329
battling that today even though adoption

00:04:18,209 --> 00:04:24,930
is pretty good before at least majority

00:04:21,329 --> 00:04:27,090
of users above 70 or 80% had browsers

00:04:24,930 --> 00:04:29,010
supporting flexbox and the rounded

00:04:27,090 --> 00:04:31,680
corners is sort of a nice to have but if

00:04:29,010 --> 00:04:33,659
your layout is dependent on support for

00:04:31,680 --> 00:04:36,450
flexbox and it's not there everything is

00:04:33,659 --> 00:04:37,810
going to get my step and I'm sure you're

00:04:36,450 --> 00:04:41,440
familiar with this

00:04:37,810 --> 00:04:43,300
can I use charts that are often Li very

00:04:41,440 --> 00:04:44,860
depressing telling you that only your

00:04:43,300 --> 00:04:46,270
version of Chrome supports this one

00:04:44,860 --> 00:04:48,490
thing that you were hoping to use ever

00:04:46,270 --> 00:04:50,860
in your project um and it could be

00:04:48,490 --> 00:04:53,139
really disastrous to to our project if

00:04:50,860 --> 00:04:54,970
it's open and older browsers and

00:04:53,139 --> 00:04:58,240
everything is completely broken so what

00:04:54,970 --> 00:05:00,460
usually happens is that there's feature

00:04:58,240 --> 00:05:02,110
proposals someone comes up with some

00:05:00,460 --> 00:05:03,400
kind of workaround and we just go if

00:05:02,110 --> 00:05:08,250
that workaround because we're too afraid

00:05:03,400 --> 00:05:10,630
to just go with the fully fledged CSS

00:05:08,250 --> 00:05:13,360
implementation and then we use it the

00:05:10,630 --> 00:05:15,580
problem is that these implementations

00:05:13,360 --> 00:05:17,320
are often as we said over engineered

00:05:15,580 --> 00:05:19,600
using images for border-radius

00:05:17,320 --> 00:05:21,190
anywhere on your website is not feasible

00:05:19,600 --> 00:05:23,380
it's a lot of images it's a lot of

00:05:21,190 --> 00:05:25,300
weight it's a lot of work implementing

00:05:23,380 --> 00:05:27,340
flexbox in JavaScript can become very

00:05:25,300 --> 00:05:30,010
slow and very sluggish and can bring the

00:05:27,340 --> 00:05:31,990
performance of your application down so

00:05:30,010 --> 00:05:34,390
what I'm here to tell you now is that

00:05:31,990 --> 00:05:35,650
you can make your own magic you can with

00:05:34,390 --> 00:05:37,389
a new set of tools that will be

00:05:35,650 --> 00:05:39,960
available to us hopefully in the near

00:05:37,389 --> 00:05:43,020
future make your own CSS create your own

00:05:39,960 --> 00:05:45,520
implementations and not have to rely on

00:05:43,020 --> 00:05:47,020
polyfills or work around and when I

00:05:45,520 --> 00:05:48,640
first saw this it wasn't mind-blowing to

00:05:47,020 --> 00:05:50,770
me the kind of stuff that we will be

00:05:48,640 --> 00:05:52,630
talking about today and the API is that

00:05:50,770 --> 00:05:54,610
Houdini that is the codename for the

00:05:52,630 --> 00:05:57,789
task force in this collection of api's

00:05:54,610 --> 00:06:01,090
makes possible so yeah Houdini is the

00:05:57,789 --> 00:06:02,770
CSS spec that you'll give you web

00:06:01,090 --> 00:06:05,140
magical powers and we'll see exactly

00:06:02,770 --> 00:06:07,330
what that means but to be able to

00:06:05,140 --> 00:06:09,370
understand what Dini does we need to

00:06:07,330 --> 00:06:11,950
first understand how the web works and

00:06:09,370 --> 00:06:14,380
how CSS works and getting to the details

00:06:11,950 --> 00:06:16,510
that we usually avoid and we usually

00:06:14,380 --> 00:06:19,330
don't take that deep we know how to use

00:06:16,510 --> 00:06:20,710
CSS we know quirks mode we know behavior

00:06:19,330 --> 00:06:22,570
in different browsers but not

00:06:20,710 --> 00:06:24,640
necessarily the engine itself and what

00:06:22,570 --> 00:06:27,550
the browser does when you give it HTML

00:06:24,640 --> 00:06:30,430
in a stylesheet well what happens is a

00:06:27,550 --> 00:06:32,680
process with four stages you start with

00:06:30,430 --> 00:06:35,440
the style sheets with what's called the

00:06:32,680 --> 00:06:37,690
CSS object model which is how do we map

00:06:35,440 --> 00:06:39,039
a tree similar to a Dom of all of the

00:06:37,690 --> 00:06:42,610
different properties and classes and

00:06:39,039 --> 00:06:43,930
elements we propagate through the

00:06:42,610 --> 00:06:46,690
Cascade and we assign different

00:06:43,930 --> 00:06:49,300
properties of different importance to

00:06:46,690 --> 00:06:51,520
particular targets in our Dom we run

00:06:49,300 --> 00:06:52,060
through a layout phase which is where we

00:06:51,520 --> 00:06:54,820
organ

00:06:52,060 --> 00:06:56,919
all of the elements in the page in their

00:06:54,820 --> 00:06:58,840
final structure be it block elements or

00:06:56,919 --> 00:07:00,970
inline elements different kinds of

00:06:58,840 --> 00:07:02,440
displays we go through a paint phase

00:07:00,970 --> 00:07:06,010
where we actually render these

00:07:02,440 --> 00:07:08,380
components to to a visual to different

00:07:06,010 --> 00:07:10,150
layers and we go through composition and

00:07:08,380 --> 00:07:13,260
composition will place those layers on

00:07:10,150 --> 00:07:16,060
the screen and we'll end up with fully

00:07:13,260 --> 00:07:19,419
rendered web page so we'll go through a

00:07:16,060 --> 00:07:21,700
few examples of the Houdini spec api's

00:07:19,419 --> 00:07:24,280
and explain how they give you better

00:07:21,700 --> 00:07:27,639
access into the internals of CSS and the

00:07:24,280 --> 00:07:29,229
first one is the CSS parser API and

00:07:27,639 --> 00:07:32,229
might not seem very exciting at first

00:07:29,229 --> 00:07:34,510
but let's see what it looks like so that

00:07:32,229 --> 00:07:39,400
I can see that that's a bit small so I'm

00:07:34,510 --> 00:07:45,900
gonna zoom that in a bit you can't

00:07:39,400 --> 00:07:45,900
really see at the back right no okay

00:07:46,350 --> 00:07:50,340
what did I just do

00:07:52,270 --> 00:07:59,530
command P I'll feed what a long way back

00:08:01,030 --> 00:08:12,860
yeah more gifts here we go okay so and

00:08:07,190 --> 00:08:14,150
we'll carefully zoom this back okay so

00:08:12,860 --> 00:08:17,840
the first thing that you can see that we

00:08:14,150 --> 00:08:20,720
do is parse the stylesheet we have a an

00:08:17,840 --> 00:08:22,970
API in the browser in JavaScript to get

00:08:20,720 --> 00:08:25,250
a CSS rule and get back the properties

00:08:22,970 --> 00:08:28,100
and the values and we can do the same

00:08:25,250 --> 00:08:28,610
with a stylesheet we can fetch a

00:08:28,100 --> 00:08:31,550
stylesheet

00:08:28,610 --> 00:08:35,150
and pass it to a CSS parser which will

00:08:31,550 --> 00:08:37,580
be a function available to us in in

00:08:35,150 --> 00:08:38,810
JavaScript and we can parse the values

00:08:37,580 --> 00:08:41,930
of that stylesheet and I know that

00:08:38,810 --> 00:08:43,880
doesn't look very exciting but the the

00:08:41,930 --> 00:08:46,220
purpose of this API is not just to be

00:08:43,880 --> 00:08:48,920
able to parse style sheets is to be able

00:08:46,220 --> 00:08:52,130
to create our own really create our own

00:08:48,920 --> 00:08:54,340
additions to CSS itself and can you

00:08:52,130 --> 00:08:57,770
assume that back in a bit and we can see

00:08:54,340 --> 00:09:00,470
what you'll be able to do is implement

00:08:57,770 --> 00:09:03,620
your own constructs something like

00:09:00,470 --> 00:09:06,740
custom functions and we'll see what kind

00:09:03,620 --> 00:09:08,510
of possibilities that opens or custom at

00:09:06,740 --> 00:09:11,990
rules in the same way that we use

00:09:08,510 --> 00:09:14,180
typefaces or media queries and even if

00:09:11,990 --> 00:09:16,520
you've used the new feature for image

00:09:14,180 --> 00:09:21,650
sizes to have multiple sizes of images

00:09:16,520 --> 00:09:23,180
on one tag CSS like attribute values and

00:09:21,650 --> 00:09:24,890
I know that seems very technical but

00:09:23,180 --> 00:09:26,870
think about what could you possibly do

00:09:24,890 --> 00:09:28,970
with your own custom CSS functions and

00:09:26,870 --> 00:09:31,070
CSS rules and when I think about what's

00:09:28,970 --> 00:09:33,770
exciting to me and what I'd like to try

00:09:31,070 --> 00:09:35,660
when this API becomes available I think

00:09:33,770 --> 00:09:36,800
of for example chroma key imagine you

00:09:35,660 --> 00:09:38,090
could have something like Hollywood

00:09:36,800 --> 00:09:40,100
green screens and you could drop the

00:09:38,090 --> 00:09:42,140
background of an image and make it

00:09:40,100 --> 00:09:44,020
transparent with in CSS you could

00:09:42,140 --> 00:09:46,820
implement the rendering engine for that

00:09:44,020 --> 00:09:51,100
function and make it available within

00:09:46,820 --> 00:09:53,900
CSS it's not sass or less or any sort of

00:09:51,100 --> 00:09:56,630
JavaScript polyfill you're extending the

00:09:53,900 --> 00:09:58,340
CSS engine itself for example you could

00:09:56,630 --> 00:10:00,110
select a frame from a gif which is

00:09:58,340 --> 00:10:01,970
something I'd love to try you could

00:10:00,110 --> 00:10:04,800
create a selection of more interesting

00:10:01,970 --> 00:10:06,810
image filters if we're looking at

00:10:04,800 --> 00:10:09,300
at rules you could implement your own an

00:10:06,810 --> 00:10:11,069
area inheritance for classes and and

00:10:09,300 --> 00:10:13,980
properties in the same way that sass

00:10:11,069 --> 00:10:16,589
less or any CSS pre compiler does it we

00:10:13,980 --> 00:10:19,589
could create our own definitions in the

00:10:16,589 --> 00:10:21,449
same way that typeface is used to make

00:10:19,589 --> 00:10:23,310
fonts available globally in a document

00:10:21,449 --> 00:10:25,319
maybe we can create something like a

00:10:23,310 --> 00:10:28,110
color palette available widely in a

00:10:25,319 --> 00:10:30,269
document so you extend CSS itself this

00:10:28,110 --> 00:10:32,189
is loaded from a regular stylesheet into

00:10:30,269 --> 00:10:35,670
the browser and you have to you'll be

00:10:32,189 --> 00:10:37,439
able to define the behavior of the

00:10:35,670 --> 00:10:46,319
process and the parsing of each each of

00:10:37,439 --> 00:10:49,709
the rules on its own and to show to show

00:10:46,319 --> 00:10:51,600
you perhaps some of the more power of

00:10:49,709 --> 00:10:54,810
when these api's come together and it's

00:10:51,600 --> 00:10:56,699
all about the different api's and the I

00:10:54,810 --> 00:10:58,259
guess the the wide range of

00:10:56,699 --> 00:11:00,480
possibilities that they make available

00:10:58,259 --> 00:11:02,759
when they're combined I want to look

00:11:00,480 --> 00:11:04,110
into the properties and values API has

00:11:02,759 --> 00:11:07,319
anyone experimented with custom

00:11:04,110 --> 00:11:07,620
properties or CSS variables a few hands

00:11:07,319 --> 00:11:09,810
um

00:11:07,620 --> 00:11:14,040
so custom properties or CSS variables

00:11:09,810 --> 00:11:16,920
look something like this they allow you

00:11:14,040 --> 00:11:19,290
to define a custom custom looking

00:11:16,920 --> 00:11:21,089
attribute and assign a value to it now

00:11:19,290 --> 00:11:24,420
currently when you do this when you

00:11:21,089 --> 00:11:26,160
assign palette root in in the root level

00:11:24,420 --> 00:11:27,779
of or any level of your document it

00:11:26,160 --> 00:11:30,120
becomes a variable that that is

00:11:27,779 --> 00:11:31,620
available to you to use in other

00:11:30,120 --> 00:11:33,329
properties so you can define a caller

00:11:31,620 --> 00:11:35,430
and we use it everywhere but it's used

00:11:33,329 --> 00:11:37,259
as a string so it uses orange as a

00:11:35,430 --> 00:11:38,970
string it doesn't know what orange is it

00:11:37,259 --> 00:11:41,310
doesn't know what orange does and we'll

00:11:38,970 --> 00:11:44,639
just hope that when you feed orange into

00:11:41,310 --> 00:11:46,290
caller maybe or background caller CSS

00:11:44,639 --> 00:11:48,689
would know what to do with this well the

00:11:46,290 --> 00:11:50,819
property is the new properties API will

00:11:48,689 --> 00:11:53,069
give you an interface to define more

00:11:50,819 --> 00:11:55,130
robust properties for this example

00:11:53,069 --> 00:11:58,380
something like parallel to route we can

00:11:55,130 --> 00:12:01,170
tell see the CSS engine that palette

00:11:58,380 --> 00:12:03,209
root is a caller of a type caller and

00:12:01,170 --> 00:12:05,839
we'll see later on why it's important

00:12:03,209 --> 00:12:08,879
that CSS knows the type of our values

00:12:05,839 --> 00:12:10,829
that it inherits from its parents that

00:12:08,879 --> 00:12:13,589
it has a default value now what that

00:12:10,829 --> 00:12:16,019
means in terms of our development is

00:12:13,589 --> 00:12:17,700
that we can set this property once but

00:12:16,019 --> 00:12:20,130
the CSS engine is a

00:12:17,700 --> 00:12:22,320
the value so one advantage for example

00:12:20,130 --> 00:12:26,370
is that we'll be able to animate these

00:12:22,320 --> 00:12:28,740
values because if CSS the CSS engine is

00:12:26,370 --> 00:12:30,690
aware of a value being a caller if we

00:12:28,740 --> 00:12:32,910
transition to into another color it is

00:12:30,690 --> 00:12:34,320
able to create the curve of transition

00:12:32,910 --> 00:12:36,330
between these two things it's not just

00:12:34,320 --> 00:12:38,220
the separate unknown values that are

00:12:36,330 --> 00:12:40,710
either strings or numbers they're these

00:12:38,220 --> 00:12:42,720
are values with a meaning and if we're

00:12:40,710 --> 00:12:46,620
talking about values with meaning the

00:12:42,720 --> 00:12:49,680
third upcoming API is the typed CSS

00:12:46,620 --> 00:12:53,370
object model the type CSS object model

00:12:49,680 --> 00:12:54,750
is extended on top of the regular CSS

00:12:53,370 --> 00:12:57,840
object model and we'll see what that

00:12:54,750 --> 00:13:00,330
means to solve this problem and you

00:12:57,840 --> 00:13:04,890
might have been familiar with it and

00:13:00,330 --> 00:13:06,900
that is trying to get a value out of CSS

00:13:04,890 --> 00:13:09,300
into JavaScript let's say I want to know

00:13:06,900 --> 00:13:11,130
what is the width of an element well

00:13:09,300 --> 00:13:13,320
currently I have to get the stylesheet

00:13:11,130 --> 00:13:14,940
for that element get the property it'll

00:13:13,320 --> 00:13:16,710
be something like 100 pixels it'll be a

00:13:14,940 --> 00:13:18,930
string I'll have to split that string

00:13:16,710 --> 00:13:21,450
drop the pixel turn it into a number

00:13:18,930 --> 00:13:23,040
only to get the width and if I want to

00:13:21,450 --> 00:13:25,110
set the width back in let's say it's

00:13:23,040 --> 00:13:27,810
calculate I have to generate a string

00:13:25,110 --> 00:13:30,060
again pass it into the CSS engine which

00:13:27,810 --> 00:13:31,560
will parse it back into a number and all

00:13:30,060 --> 00:13:33,240
this loop was just because our

00:13:31,560 --> 00:13:35,190
interfaces strings which is a very poor

00:13:33,240 --> 00:13:37,080
interface so not only is this annoying

00:13:35,190 --> 00:13:38,520
if you do it a lot if you do it every

00:13:37,080 --> 00:13:40,830
time you scroll every time the browser

00:13:38,520 --> 00:13:43,260
window changes every time you hover over

00:13:40,830 --> 00:13:44,790
an element it really drops in

00:13:43,260 --> 00:13:46,740
performance if you had the experience of

00:13:44,790 --> 00:13:48,720
trying to create dynamically sized

00:13:46,740 --> 00:13:50,490
elements in reaction to mouse hovers or

00:13:48,720 --> 00:13:52,260
scroll something like the Twitter header

00:13:50,490 --> 00:13:55,410
which will see another implementation of

00:13:52,260 --> 00:13:58,860
later on it becomes very very slow so

00:13:55,410 --> 00:14:02,340
instead what Houdini proposes is a typed

00:13:58,860 --> 00:14:06,360
CSS object model meaning that values

00:14:02,340 --> 00:14:08,130
have values have a type they are numbers

00:14:06,360 --> 00:14:10,080
they are lengths they are transitions

00:14:08,130 --> 00:14:11,820
they are time they're degrees but they

00:14:10,080 --> 00:14:14,940
have they have a meaning and they have

00:14:11,820 --> 00:14:17,340
more context so for example if we want

00:14:14,940 --> 00:14:20,040
to set the width of an element we

00:14:17,340 --> 00:14:21,960
initialize a new CSS length value and it

00:14:20,040 --> 00:14:23,640
takes a number and it takes a unit and

00:14:21,960 --> 00:14:25,410
then we can set it back to the element

00:14:23,640 --> 00:14:27,780
meaning that we operate in a more rich

00:14:25,410 --> 00:14:29,610
and informed context we know that we

00:14:27,780 --> 00:14:31,440
operate in a width width unit and in

00:14:29,610 --> 00:14:34,560
pixels that we're dealing with we'd

00:14:31,440 --> 00:14:36,060
with widths or lengths in this case and

00:14:34,560 --> 00:14:39,660
what that means is that we can create

00:14:36,060 --> 00:14:41,910
more elaborate types or more elaborate

00:14:39,660 --> 00:14:43,800
values with less overhead for example

00:14:41,910 --> 00:14:46,500
the previous example of a calculation

00:14:43,800 --> 00:14:50,160
with two different units just becomes a

00:14:46,500 --> 00:14:51,870
new Sessler with a percent and a pixel

00:14:50,160 --> 00:14:54,330
value and these are automatically

00:14:51,870 --> 00:14:55,350
comprised into a calculation meaning we

00:14:54,330 --> 00:14:57,000
don't have to do any more string

00:14:55,350 --> 00:14:59,160
manipulation or concatenate or splitting

00:14:57,000 --> 00:15:01,770
or all that kind of stuff and it's a

00:14:59,160 --> 00:15:03,540
much better API and because we are aware

00:15:01,770 --> 00:15:05,670
of the type of the value because we know

00:15:03,540 --> 00:15:08,510
it's a length we can operate on it we

00:15:05,670 --> 00:15:11,250
can do things like addition or division

00:15:08,510 --> 00:15:12,210
in the case of lengths in case of a

00:15:11,250 --> 00:15:16,170
transform it's really interesting

00:15:12,210 --> 00:15:18,570
because the transform string itself the

00:15:16,170 --> 00:15:21,000
matrix of transformations if it's a

00:15:18,570 --> 00:15:23,100
rotation or a translation or ASCII or a

00:15:21,000 --> 00:15:26,100
spin it becomes very lengthy in

00:15:23,100 --> 00:15:28,110
processing that with a bunch of regular

00:15:26,100 --> 00:15:30,660
expressions or splits in JavaScript can

00:15:28,110 --> 00:15:31,950
become very a very lengthy process in

00:15:30,660 --> 00:15:34,080
this case we have a very strict

00:15:31,950 --> 00:15:36,780
interface we create a transform for

00:15:34,080 --> 00:15:39,000
example and we add transformations to it

00:15:36,780 --> 00:15:41,610
we can add a rotation and it has a type

00:15:39,000 --> 00:15:43,500
of angle it's a lot easier to understand

00:15:41,610 --> 00:15:46,110
what's going on it's a much more robust

00:15:43,500 --> 00:15:49,560
interface to describe our dynamic styles

00:15:46,110 --> 00:15:51,720
and we'll see that the the typed CSS

00:15:49,560 --> 00:15:57,090
object model really empowers a lot of

00:15:51,720 --> 00:15:58,680
the different new features of Houdini so

00:15:57,090 --> 00:16:00,450
now we're looking into more of these

00:15:58,680 --> 00:16:03,030
were all api's that are available in the

00:16:00,450 --> 00:16:04,890
in the Dom or in the in the main thread

00:16:03,030 --> 00:16:06,740
or in our main processing thread in

00:16:04,890 --> 00:16:09,900
JavaScript meaning that we can apply

00:16:06,740 --> 00:16:12,600
styles we can read values we can add

00:16:09,900 --> 00:16:15,000
some more features to CSS and I want to

00:16:12,600 --> 00:16:18,900
look through like we talked before how

00:16:15,000 --> 00:16:21,030
do we polyfill CSS how do we extend it

00:16:18,900 --> 00:16:23,970
how do we compensate for the lack of

00:16:21,030 --> 00:16:27,660
features in some browsers and really the

00:16:23,970 --> 00:16:29,700
layer API touches upon this first so the

00:16:27,660 --> 00:16:31,589
layout API allows you to create your own

00:16:29,700 --> 00:16:34,020
custom layouts and it might not sound

00:16:31,589 --> 00:16:36,420
exciting because we can do things do it

00:16:34,020 --> 00:16:38,460
with things like masonry today or we can

00:16:36,420 --> 00:16:42,440
just do it in JavaScript but it provides

00:16:38,460 --> 00:16:44,620
you with an interface that will be

00:16:42,440 --> 00:16:46,060
separate to the main thread and it will

00:16:44,620 --> 00:16:48,460
in sort of a worker will talk about

00:16:46,060 --> 00:16:51,279
worklets in a bit and it will allow you

00:16:48,460 --> 00:16:53,230
to define high-performance scripts that

00:16:51,279 --> 00:16:55,510
will run to generate the layout of your

00:16:53,230 --> 00:16:57,790
pages and you can use them straight from

00:16:55,510 --> 00:16:59,800
CSS so you can define a layout that

00:16:57,790 --> 00:17:02,529
compensates for the lack of flex box or

00:16:59,800 --> 00:17:04,660
grid or columns or whatever it is you

00:17:02,529 --> 00:17:07,329
can load it into you can load it along

00:17:04,660 --> 00:17:10,930
with your application and use CSS

00:17:07,329 --> 00:17:12,400
normally in these interference will be

00:17:10,930 --> 00:17:15,699
available to you so let's look at an

00:17:12,400 --> 00:17:18,240
example but before we look at a layout I

00:17:15,699 --> 00:17:20,890
just want to talk a bit about the way

00:17:18,240 --> 00:17:23,410
layouts are defined in CSS we operate

00:17:20,890 --> 00:17:25,209
with boxes and fragments meaning that

00:17:23,410 --> 00:17:27,280
even if we have a single line and it's

00:17:25,209 --> 00:17:29,080
within a single div there are a few

00:17:27,280 --> 00:17:30,700
different chunks and we can use it with

00:17:29,080 --> 00:17:33,370
for example pseudo selectors of first

00:17:30,700 --> 00:17:35,260
letter or first Ward or if we hand have

00:17:33,370 --> 00:17:36,670
a few different spans within a day of

00:17:35,260 --> 00:17:38,920
you can see in here we have over line

00:17:36,670 --> 00:17:41,020
underline an italic and they are

00:17:38,920 --> 00:17:43,450
separate elements they are all different

00:17:41,020 --> 00:17:47,170
fragments within one box within the

00:17:43,450 --> 00:17:48,820
context of the new structure of CSS so

00:17:47,170 --> 00:17:51,460
let's say that we want to create a

00:17:48,820 --> 00:17:54,670
simple layout that will order elements

00:17:51,460 --> 00:17:58,270
as blocks one after another well what

00:17:54,670 --> 00:18:00,160
we're given is a API where we define a

00:17:58,270 --> 00:18:03,250
class and this is done in JavaScript but

00:18:00,160 --> 00:18:05,679
the the end result the display layout is

00:18:03,250 --> 00:18:07,240
available through CSS so we'll just run

00:18:05,679 --> 00:18:10,320
briefly over what the code looks like

00:18:07,240 --> 00:18:12,820
and we'll talk about the benefits later

00:18:10,320 --> 00:18:16,120
we define a new class with the final

00:18:12,820 --> 00:18:19,210
layout and that layout is being called

00:18:16,120 --> 00:18:21,250
in the layout stage of CSS so right

00:18:19,210 --> 00:18:22,900
after we get all of the selectors we go

00:18:21,250 --> 00:18:25,900
through the Cascade and we want to start

00:18:22,900 --> 00:18:27,610
placing elements around the document so

00:18:25,900 --> 00:18:30,220
we get the properties of the elements we

00:18:27,610 --> 00:18:32,050
get their width in their height and this

00:18:30,220 --> 00:18:34,300
function basically runs through each of

00:18:32,050 --> 00:18:37,720
the elements and places them in

00:18:34,300 --> 00:18:39,910
coordinates inside a container once it

00:18:37,720 --> 00:18:42,220
does that it returns all of the values

00:18:39,910 --> 00:18:44,260
I'm not going to run through the through

00:18:42,220 --> 00:18:46,600
the particulars of the code because it

00:18:44,260 --> 00:18:49,420
matters less what matters is that we get

00:18:46,600 --> 00:18:51,160
the unsorted or unplaced list of

00:18:49,420 --> 00:18:53,890
fragments or elements within a container

00:18:51,160 --> 00:18:56,650
and we can place them within a bounding

00:18:53,890 --> 00:18:57,090
box we know that let's say a particular

00:18:56,650 --> 00:18:59,370
box

00:18:57,090 --> 00:19:02,070
100 pixels and the next one is each each

00:18:59,370 --> 00:19:03,660
one of the spans is 100 pixels we can

00:19:02,070 --> 00:19:04,560
draw them one after another we can draw

00:19:03,660 --> 00:19:07,050
them next to each other you have

00:19:04,560 --> 00:19:08,940
complete control over placements of

00:19:07,050 --> 00:19:12,240
elements and this entire class is

00:19:08,940 --> 00:19:13,560
exported and registered as a display but

00:19:12,240 --> 00:19:17,550
what that means is that you can later

00:19:13,560 --> 00:19:19,290
use it in CSS through the layout the

00:19:17,550 --> 00:19:20,670
layout function meaning that you can

00:19:19,290 --> 00:19:23,510
polyfill flexbox

00:19:20,670 --> 00:19:25,770
you can create your own layouts the

00:19:23,510 --> 00:19:29,310
reference implementation implements

00:19:25,770 --> 00:19:31,800
masonry if you're familiar with masonry

00:19:29,310 --> 00:19:34,650
layout library much like the windows box

00:19:31,800 --> 00:19:36,900
the windows paint blocks within CSS so

00:19:34,650 --> 00:19:39,690
you can just use these displays in CSS

00:19:36,900 --> 00:19:42,750
and we'll see later on where this code

00:19:39,690 --> 00:19:44,400
is actually executed to ensure that you

00:19:42,750 --> 00:19:46,470
don't have a performance set or a

00:19:44,400 --> 00:19:51,300
performance drop to be able to use

00:19:46,470 --> 00:19:54,150
custom layouts another interesting

00:19:51,300 --> 00:19:58,820
example is the paint API the penta API

00:19:54,150 --> 00:20:01,470
gives you control over backgrounds or

00:19:58,820 --> 00:20:03,570
any kind of visuals that you can draw in

00:20:01,470 --> 00:20:05,700
the dom and what it looks like again

00:20:03,570 --> 00:20:08,610
it's another class that is exported to

00:20:05,700 --> 00:20:12,870
make available in CSS so we register a

00:20:08,610 --> 00:20:15,300
new a new painter in this example let's

00:20:12,870 --> 00:20:16,950
say a circle and we get the input of an

00:20:15,300 --> 00:20:21,150
element and we want to draw a circle in

00:20:16,950 --> 00:20:23,910
the middle of it so much like a canvas

00:20:21,150 --> 00:20:25,680
interface we get a subset of a really

00:20:23,910 --> 00:20:27,300
canvas to be able to draw whatever we

00:20:25,680 --> 00:20:30,870
want within the element so if we ask for

00:20:27,300 --> 00:20:32,730
the properties let's say Circle caller

00:20:30,870 --> 00:20:34,920
we ask for a custom property or a

00:20:32,730 --> 00:20:37,500
variable from CSS so we're able to

00:20:34,920 --> 00:20:39,540
interface between different api's and

00:20:37,500 --> 00:20:40,830
then we get the dimensions of a

00:20:39,540 --> 00:20:42,810
particular element and we can draw a

00:20:40,830 --> 00:20:44,760
circle in the middle now I know this

00:20:42,810 --> 00:20:48,780
looks like canvas but this is the actual

00:20:44,760 --> 00:20:50,790
drawing of CSS layers so we can draw on

00:20:48,780 --> 00:20:53,820
elements it's not a canvas it's not a

00:20:50,790 --> 00:20:56,310
canvas container the way that it looks

00:20:53,820 --> 00:20:57,840
after you register a circle isn't just

00:20:56,310 --> 00:21:00,870
in CSS you can say that the background

00:20:57,840 --> 00:21:02,340
image is a paint you paint a circle and

00:21:00,870 --> 00:21:04,920
you will have a circle in the back and

00:21:02,340 --> 00:21:06,630
it will be in the sort of shadow dome it

00:21:04,920 --> 00:21:08,820
will be part of the layout it will not

00:21:06,630 --> 00:21:10,140
be another canvas layer or any other

00:21:08,820 --> 00:21:10,800
additional element it will just be the

00:21:10,140 --> 00:21:14,250
background that you

00:21:10,800 --> 00:21:15,630
can draw whatever you want on so I want

00:21:14,250 --> 00:21:19,110
to show you an example of what that

00:21:15,630 --> 00:21:21,240
paint API looks like from initial

00:21:19,110 --> 00:21:23,760
implementation of the chrome team you

00:21:21,240 --> 00:21:27,180
can see a few really interesting things

00:21:23,760 --> 00:21:30,450
is that one of the properties will zoom

00:21:27,180 --> 00:21:32,850
out a bit one of the properties offset

00:21:30,450 --> 00:21:35,130
is set as a custom variable at offset

00:21:32,850 --> 00:21:38,070
becomes available to the painter and

00:21:35,130 --> 00:21:40,560
then we feed off the radius and the fill

00:21:38,070 --> 00:21:42,300
in a few other custom properties to

00:21:40,560 --> 00:21:45,330
define the painter and that painter will

00:21:42,300 --> 00:21:48,540
draw sort of a chat bubble and you can

00:21:45,330 --> 00:21:50,970
see that it feeds off all of these

00:21:48,540 --> 00:21:53,430
parameters CSS custom properties into a

00:21:50,970 --> 00:21:56,220
custom paint function that draws the

00:21:53,430 --> 00:21:58,590
background of a text bubble and it's not

00:21:56,220 --> 00:22:00,120
done with additional elements it's not

00:21:58,590 --> 00:22:02,160
done with additional canvas or images

00:22:00,120 --> 00:22:03,780
it's drawn as the actual background of

00:22:02,160 --> 00:22:05,700
the element you can draw offsets for the

00:22:03,780 --> 00:22:07,170
caret you can do a lot of different

00:22:05,700 --> 00:22:09,270
things and this runs completely

00:22:07,170 --> 00:22:11,250
separately to the main thread so this is

00:22:09,270 --> 00:22:14,900
the same as setting a regular background

00:22:11,250 --> 00:22:18,300
image this is done as part of the CSS

00:22:14,900 --> 00:22:21,330
styling and rendering process another

00:22:18,300 --> 00:22:23,040
interesting example that when I saw this

00:22:21,330 --> 00:22:25,940
it was really it was really mind-blowing

00:22:23,040 --> 00:22:29,970
to me because it really underlines the

00:22:25,940 --> 00:22:32,310
how much access you get into the into

00:22:29,970 --> 00:22:35,520
this CSS API into the CSS engine you're

00:22:32,310 --> 00:22:37,470
able to control not just positioning or

00:22:35,520 --> 00:22:39,270
some additional properties that you then

00:22:37,470 --> 00:22:41,100
render with JavaScript but really the

00:22:39,270 --> 00:22:44,370
way your page is rendered you get really

00:22:41,100 --> 00:22:46,410
low-level access to the rendering engine

00:22:44,370 --> 00:22:48,000
to the layout engine to the positioning

00:22:46,410 --> 00:22:49,500
of all these elements you can see

00:22:48,000 --> 00:22:52,280
another example and this is very

00:22:49,500 --> 00:22:55,140
interesting we're drawing a QR code is

00:22:52,280 --> 00:22:59,070
completely in CSS so we define the paint

00:22:55,140 --> 00:23:00,900
function that renders generates a QR

00:22:59,070 --> 00:23:04,110
code and all we have to do is set a

00:23:00,900 --> 00:23:06,630
custom property of QR URL much like

00:23:04,110 --> 00:23:08,790
content in before after pseudo elements

00:23:06,630 --> 00:23:13,320
and we set the value and we generate a

00:23:08,790 --> 00:23:14,850
QR and we don't have to run SVG or any

00:23:13,320 --> 00:23:17,250
more JavaScript in the main thread it's

00:23:14,850 --> 00:23:19,740
not a bunch of divs or a table it's

00:23:17,250 --> 00:23:22,440
drawn to the background of the container

00:23:19,740 --> 00:23:23,340
and it's done in a very slimmed down

00:23:22,440 --> 00:23:26,250
version

00:23:23,340 --> 00:23:28,050
of the of a worker that is available to

00:23:26,250 --> 00:23:30,570
the painter ensuring that these

00:23:28,050 --> 00:23:33,000
processes even if processing a QR and

00:23:30,570 --> 00:23:35,910
painting it is a complex operation will

00:23:33,000 --> 00:23:39,870
run in very high performance another

00:23:35,910 --> 00:23:42,840
example and the third one is a famous

00:23:39,870 --> 00:23:45,480
google ripple effect from material

00:23:42,840 --> 00:23:48,240
design if you've ever tried to use any

00:23:45,480 --> 00:23:50,070
of the polyfills for these elements you

00:23:48,240 --> 00:23:52,170
know that the other used canvas or SVG

00:23:50,070 --> 00:23:54,450
they're a bit sluggish they're very hard

00:23:52,170 --> 00:23:57,270
to predict in terms of performance in

00:23:54,450 --> 00:24:00,150
this example image shows not just the

00:23:57,270 --> 00:24:02,490
ability to render static elements but to

00:24:00,150 --> 00:24:05,070
create dynamic animated backgrounds that

00:24:02,490 --> 00:24:07,200
respond to Mouse events click events

00:24:05,070 --> 00:24:08,760
positioning of the pointer and you can

00:24:07,200 --> 00:24:10,170
just click around and you get the ripple

00:24:08,760 --> 00:24:11,910
effect the ripple is completely

00:24:10,170 --> 00:24:14,340
contained within the element because

00:24:11,910 --> 00:24:18,750
it's within the background drawn of the

00:24:14,340 --> 00:24:20,610
element itself so you might ask at this

00:24:18,750 --> 00:24:22,290
point you've shown us a bunch of cool

00:24:20,610 --> 00:24:24,750
api's about what the what's the what's

00:24:22,290 --> 00:24:28,200
the point well there are three I'd say

00:24:24,750 --> 00:24:30,180
goals for the Houdini API or the you

00:24:28,200 --> 00:24:33,090
Dini spec and collection of api's the

00:24:30,180 --> 00:24:36,030
main one is cross browser compatibility

00:24:33,090 --> 00:24:38,820
let's talk about layout or box shadow

00:24:36,030 --> 00:24:41,460
for example or text shadow or any kind

00:24:38,820 --> 00:24:43,080
of visual API if it's missing if it's

00:24:41,460 --> 00:24:45,060
not available in browsers that you're

00:24:43,080 --> 00:24:49,290
targeting with your projects today you

00:24:45,060 --> 00:24:51,960
can write a very isolated snippet of

00:24:49,290 --> 00:24:55,260
JavaScript to feed it into a worker and

00:24:51,960 --> 00:24:57,720
make that interface available across

00:24:55,260 --> 00:24:59,670
browsers that's true it's only available

00:24:57,720 --> 00:25:02,940
across browsers that support Houdini but

00:24:59,670 --> 00:25:05,130
once we hit a baseline of support for

00:25:02,940 --> 00:25:07,800
the JavaScript API you will never have a

00:25:05,130 --> 00:25:09,630
problem of CSS compatibility again you

00:25:07,800 --> 00:25:12,180
can implement your own flexbox you can

00:25:09,630 --> 00:25:13,770
implement your own border-radius you can

00:25:12,180 --> 00:25:17,310
do whatever you want and you won't have

00:25:13,770 --> 00:25:19,440
to trust adoption of either vendor

00:25:17,310 --> 00:25:22,230
implementation or adoption by your users

00:25:19,440 --> 00:25:25,290
of later versions of browsers or maybe

00:25:22,230 --> 00:25:27,600
using greenfield browsers the other the

00:25:25,290 --> 00:25:29,130
other benefit is really high performance

00:25:27,600 --> 00:25:33,330
styles so like I mentioned these

00:25:29,130 --> 00:25:35,190
snippets these additional layout engines

00:25:33,330 --> 00:25:36,960
they run in completely separate threads

00:25:35,190 --> 00:25:38,429
they are registered as workers

00:25:36,960 --> 00:25:40,200
and I'm not going to get into workers

00:25:38,429 --> 00:25:42,000
now because that's more JavaScript land

00:25:40,200 --> 00:25:45,240
but they run separate to the main thread

00:25:42,000 --> 00:25:47,580
on a very slim down subset of JavaScript

00:25:45,240 --> 00:25:49,380
which ensures very high performance

00:25:47,580 --> 00:25:51,360
compared to running masonry on your own

00:25:49,380 --> 00:25:53,850
or trying to position elements with I

00:25:51,360 --> 00:25:56,630
don't know jQuery or react and doing

00:25:53,850 --> 00:26:00,809
this layout income in reaction to every

00:25:56,630 --> 00:26:04,020
browser refresh to every scroll or

00:26:00,809 --> 00:26:06,360
position of the mouse or resize of the

00:26:04,020 --> 00:26:08,429
window so they happen at a much earlier

00:26:06,360 --> 00:26:11,100
part of the process in a much lower

00:26:08,429 --> 00:26:13,440
level of the rendering interface in the

00:26:11,100 --> 00:26:14,970
browser in the last bit that's probably

00:26:13,440 --> 00:26:16,320
the most creative is that you can

00:26:14,970 --> 00:26:18,450
implement your own features you can

00:26:16,320 --> 00:26:20,669
really go wild and you can try maybe

00:26:18,450 --> 00:26:23,640
adding new things that might be exciting

00:26:20,669 --> 00:26:26,760
to the CSS spec and add them into a

00:26:23,640 --> 00:26:28,429
proposal to CSS four or five or six and

00:26:26,760 --> 00:26:30,600
you can really try and build your own

00:26:28,429 --> 00:26:35,130
styling your own style sheets your own

00:26:30,600 --> 00:26:38,279
CSS that will fit your projects so can

00:26:35,130 --> 00:26:42,510
you use it now well no you can't none of

00:26:38,279 --> 00:26:44,250
this is available some mock or reference

00:26:42,510 --> 00:26:47,190
implementations are available under the

00:26:44,250 --> 00:26:50,159
Canary Wharf Canary Wharf the canary

00:26:47,190 --> 00:26:52,380
flag in chrome and you can test them out

00:26:50,159 --> 00:26:53,760
you can see the videos you can see the

00:26:52,380 --> 00:26:56,220
code behind these reference

00:26:53,760 --> 00:26:57,750
implementations but most of this is in

00:26:56,220 --> 00:27:01,950
the development versions of Chrome and

00:26:57,750 --> 00:27:04,980
Firefox in Microsoft Safari Houdini is a

00:27:01,950 --> 00:27:06,899
very cross industry team and it's a lot

00:27:04,980 --> 00:27:08,640
of effort there's a lot of effort being

00:27:06,899 --> 00:27:12,090
made to to push the progress of these

00:27:08,640 --> 00:27:13,590
api's what you can do now though and

00:27:12,090 --> 00:27:15,870
that has to do with the fact that we are

00:27:13,590 --> 00:27:17,730
in a community conference really is to

00:27:15,870 --> 00:27:19,140
get involved otherwise I wouldn't be

00:27:17,730 --> 00:27:21,240
here talking to you about an API that's

00:27:19,140 --> 00:27:22,679
not available and this is important

00:27:21,240 --> 00:27:24,029
because at the end of the day we're the

00:27:22,679 --> 00:27:27,000
ones doing web development and web

00:27:24,029 --> 00:27:29,460
design will be the ones using Houdini so

00:27:27,000 --> 00:27:31,799
what we think what we want what we don't

00:27:29,460 --> 00:27:33,750
like really matters and it matters to

00:27:31,799 --> 00:27:35,429
developer advocates of these browsers it

00:27:33,750 --> 00:27:36,990
matters to the development teams

00:27:35,429 --> 00:27:42,720
building Chrome and Firefox and Safari

00:27:36,990 --> 00:27:44,880
and edge now so we should take active

00:27:42,720 --> 00:27:47,190
part we should say what we think this

00:27:44,880 --> 00:27:49,350
stuff is all on github all of the draft

00:27:47,190 --> 00:27:50,160
official draft report the repositories

00:27:49,350 --> 00:27:53,010
all of the

00:27:50,160 --> 00:27:54,600
minutes from the meetings you can go on

00:27:53,010 --> 00:27:56,220
and check it out you can make a pull

00:27:54,600 --> 00:27:59,240
request you can open an issue you can

00:27:56,220 --> 00:28:02,490
contribute or just say what you think

00:27:59,240 --> 00:28:05,250
yeah so this is coming I'd say probably

00:28:02,490 --> 00:28:06,990
in the next year or two but we can help

00:28:05,250 --> 00:28:09,720
steer the boat we can make sure that

00:28:06,990 --> 00:28:11,880
Houdini this really new and broad change

00:28:09,720 --> 00:28:13,770
to the way we do CSS is something that

00:28:11,880 --> 00:28:16,080
really answers our needs that is good

00:28:13,770 --> 00:28:17,490
for us to use as the community as the

00:28:16,080 --> 00:28:22,860
people who will be using it probably

00:28:17,490 --> 00:28:23,460
daily so yeah I mean just want to make a

00:28:22,860 --> 00:28:26,610
few thank-yous

00:28:23,460 --> 00:28:28,320
first of all to the CSS condom for

00:28:26,610 --> 00:28:31,020
having me it's a great honor for you for

00:28:28,320 --> 00:28:34,169
listening for the eugénie team obviously

00:28:31,020 --> 00:28:36,720
I'm not building this myself but I'm

00:28:34,169 --> 00:28:40,350
happy to share my excitement about where

00:28:36,720 --> 00:28:41,290
the web is going and that is it so thank

00:28:40,350 --> 00:28:48,470
you very much for listening

00:28:41,290 --> 00:28:48,470

YouTube URL: https://www.youtube.com/watch?v=3hpnI0_zvtw


