Title: Rob Crowley - Crafting compelling real-time web experiences with GraphQL
Publication date: 2018-04-11
Playlist: Decompress AU 2018
Description: 
	Users expect real-time data. They want their banking transaction notifications now. Their order confirmed now. They want their user experience to feel—connected. The world has moved to push and users are waiting for the data-driven experiences we create on the web to catch up. 

GraphQL is Facebook’s response to this challenge and it is quickly proving itself as an exciting alternative to RESTful APIs for a wide range of contexts. GraphQL is a query language that provides a clean and simple syntax for consumers to interrogate your APIs. These queries are strongly typed, hierarchical and enable clients to retrieve only the data they need. 

In addition to the familiar pull based request-response pattern, GraphQL provides a mechanism for clients to subscribe to real-time updates in the form of Subscriptions. Subscriptions are exciting as they represent the core ability we need to satisfy the connected push based experience that our users demand. 

In this talk, we will take a hands-on look at GraphQL and see how it can be used to build real-time APIs that are a joy to use. Additionally, we will see how we can integrate a React client with GraphQL using Relay Modern, Facebook's JavaScript framework for building data driven applications. By the end of the session you will understand what is required to craft a compelling real-time user experience with GraphQL, and have the knowledge to deliver on these requirements.
Captions: 
	00:00:11,289 --> 00:00:18,529
so wonderful intro so my name is John

00:00:15,799 --> 00:00:20,300
Crowley and I'm really excited to be

00:00:18,529 --> 00:00:22,789
able to talk to you today about graph QL

00:00:20,300 --> 00:00:25,730
this is a journey that I've personally

00:00:22,789 --> 00:00:29,540
been on and Bankwest have been on for

00:00:25,730 --> 00:00:32,090
about 18 months now so we moved from

00:00:29,540 --> 00:00:35,690
quite a traditional sort of like so

00:00:32,090 --> 00:00:37,760
mixed with rested phases to a new

00:00:35,690 --> 00:00:39,500
consolidated approach with graph QL so

00:00:37,760 --> 00:00:41,600
today's gonna be mainly about the

00:00:39,500 --> 00:00:45,079
technology and sort of like selling the

00:00:41,600 --> 00:00:47,360
idea of what I could do for you but then

00:00:45,079 --> 00:00:49,070
also as we go through or Turnitin chats

00:00:47,360 --> 00:00:51,079
later we can sort of pick out more the

00:00:49,070 --> 00:00:53,570
pertinent bits to say okay well what

00:00:51,079 --> 00:00:56,480
category of problems will it solve for

00:00:53,570 --> 00:00:58,340
you so specifically what we've got to do

00:00:56,480 --> 00:01:01,940
is kind of cover that initial step uh

00:00:58,340 --> 00:01:03,770
but like why graph QL even exists if

00:01:01,940 --> 00:01:06,729
you're facing a certain type of problems

00:01:03,770 --> 00:01:09,020
where can this help where will add value

00:01:06,729 --> 00:01:12,049
we're then going to move on to say okay

00:01:09,020 --> 00:01:14,659
well how can graph QL not only solve the

00:01:12,049 --> 00:01:16,939
the challenges of sort of like you know

00:01:14,659 --> 00:01:18,439
traditional request response type of

00:01:16,939 --> 00:01:20,600
architectures of you ask the questions

00:01:18,439 --> 00:01:23,270
of the server and you get your payload

00:01:20,600 --> 00:01:26,090
back but then also to more dynamic

00:01:23,270 --> 00:01:27,799
interfaces so you know we have chats

00:01:26,090 --> 00:01:29,329
that's coming pervasive you know chat

00:01:27,799 --> 00:01:32,079
bots we have a couple of workshops order

00:01:29,329 --> 00:01:35,329
today we are push notifications the

00:01:32,079 --> 00:01:39,139
designs and the experiences we wish to

00:01:35,329 --> 00:01:41,479
craft today require this blend of pull

00:01:39,139 --> 00:01:43,429
and push data and we'll see how graph QL

00:01:41,479 --> 00:01:43,999
can provide an elegant solution for both

00:01:43,429 --> 00:01:48,200
of them

00:01:43,999 --> 00:01:52,099
and finally realistic we only have 15

00:01:48,200 --> 00:01:54,020
minutes today you know I will not be

00:01:52,099 --> 00:01:55,969
able to make everyone in this room an

00:01:54,020 --> 00:01:58,099
expert in that period of time it could

00:01:55,969 --> 00:02:02,029
take days I could talk about it for days

00:01:58,099 --> 00:02:03,950
but if I can inspire you sufficiently to

00:02:02,029 --> 00:02:05,719
go away when you leave decompress and

00:02:03,950 --> 00:02:09,910
learn a little bit more about graph QL

00:02:05,719 --> 00:02:13,790
that would be an amazing outcome for me

00:02:09,910 --> 00:02:16,370
so first of all look why was graph QL

00:02:13,790 --> 00:02:18,400
born and this really a reflection of

00:02:16,370 --> 00:02:20,390
what's been happening in our industry so

00:02:18,400 --> 00:02:22,050
micro services have become pervasive

00:02:20,390 --> 00:02:24,370
cloud native root

00:02:22,050 --> 00:02:26,140
interfaces and all of these things

00:02:24,370 --> 00:02:30,600
combined has become a perfect storm to

00:02:26,140 --> 00:02:34,570
being able to deliver rich API

00:02:30,600 --> 00:02:37,750
experiences we know no longer builds

00:02:34,570 --> 00:02:39,730
just for websites we have mobile apps

00:02:37,750 --> 00:02:42,640
your company might have an opening line

00:02:39,730 --> 00:02:44,500
of wearables each one of those clients

00:02:42,640 --> 00:02:47,770
can have very different data

00:02:44,500 --> 00:02:49,870
requirements the data you could fit on a

00:02:47,770 --> 00:02:51,340
webpage very different to mobile and

00:02:49,870 --> 00:02:53,410
again very different to what your fate

00:02:51,340 --> 00:02:56,320
are your Apple watch so the question

00:02:53,410 --> 00:02:59,080
becomes then how can we efficiently

00:02:56,320 --> 00:03:02,200
deliver the data to each one of these

00:02:59,080 --> 00:03:04,480
channel applications and in fact I'd

00:03:02,200 --> 00:03:06,660
posit we could go a step better what we

00:03:04,480 --> 00:03:09,880
should be looking to do is deliver

00:03:06,660 --> 00:03:12,550
exactly the data that each one of those

00:03:09,880 --> 00:03:14,740
client experiences requires in one

00:03:12,550 --> 00:03:16,540
round-trip to the server and that's for

00:03:14,740 --> 00:03:19,870
me one of the things that you unpack the

00:03:16,540 --> 00:03:21,820
word compelling it means that you

00:03:19,870 --> 00:03:23,140
improve all the dom functional aspects

00:03:21,820 --> 00:03:24,670
of it should be performing it should be

00:03:23,140 --> 00:03:27,070
resilient it should be simply should be

00:03:24,670 --> 00:03:29,140
intuitive all of these that we can build

00:03:27,070 --> 00:03:32,769
into provided the compelling API

00:03:29,140 --> 00:03:34,269
experience and this is really one of the

00:03:32,769 --> 00:03:36,730
like the main use cases which will

00:03:34,269 --> 00:03:39,130
position graph QL today as this

00:03:36,730 --> 00:03:42,310
translation layer that will sit in front

00:03:39,130 --> 00:03:45,130
of all of your traditional interfaces so

00:03:42,310 --> 00:03:46,630
it could be your modern HTTP micro

00:03:45,130 --> 00:03:48,670
services it could be directly to a

00:03:46,630 --> 00:03:51,310
relational database a graph database

00:03:48,670 --> 00:03:54,130
over TCP and what we've got to do is

00:03:51,310 --> 00:03:56,560
we've got to retrieve exactly the data

00:03:54,130 --> 00:03:58,570
that your mobile app needs that your

00:03:56,560 --> 00:04:01,840
wearable app needs that your website

00:03:58,570 --> 00:04:05,110
needs in one roundtrip even more so

00:04:01,840 --> 00:04:06,459
we're spoiled with websites right I use

00:04:05,110 --> 00:04:08,620
it just clicks f5 and they've downloaded

00:04:06,459 --> 00:04:09,730
that new version that's not to say what

00:04:08,620 --> 00:04:11,620
mobile apps are where you actually have

00:04:09,730 --> 00:04:13,299
to push out a new version we want to

00:04:11,620 --> 00:04:15,190
make sure that the data requirements of

00:04:13,299 --> 00:04:20,320
each of version of that app is also

00:04:15,190 --> 00:04:24,250
optimized so as we go through today I've

00:04:20,320 --> 00:04:26,200
written a sample app that seeks to

00:04:24,250 --> 00:04:27,640
address the main challenges that you

00:04:26,200 --> 00:04:30,280
will face we're getting started with

00:04:27,640 --> 00:04:32,770
graph QL so no need to take a picture of

00:04:30,280 --> 00:04:35,950
this now I'll put up a reference slide

00:04:32,770 --> 00:04:37,210
at the end but the domain which we call

00:04:35,950 --> 00:04:38,530
in this a from one that will be going

00:04:37,210 --> 00:04:40,900
through with the demos today it's quite

00:04:38,530 --> 00:04:42,250
simple it's it's just about artists and

00:04:40,900 --> 00:04:43,840
albums I get no points for originality

00:04:42,250 --> 00:04:46,210
but it's a debate that we're all

00:04:43,840 --> 00:04:48,070
familiar with so should be sort of like

00:04:46,210 --> 00:04:50,650
able to graft as we're going through so

00:04:48,070 --> 00:04:52,780
effective for we have artists artists

00:04:50,650 --> 00:04:55,620
compose albums those albums are released

00:04:52,780 --> 00:04:58,510
on labels and then we also the idea of

00:04:55,620 --> 00:05:00,940
users which could then submit reviews of

00:04:58,510 --> 00:05:02,560
these albums and this is sort of the

00:05:00,940 --> 00:05:05,410
domain and the scheme at which we'll see

00:05:02,560 --> 00:05:06,790
as we go through the demos so rather

00:05:05,410 --> 00:05:09,670
than talk a bit more about graphic yo

00:05:06,790 --> 00:05:12,070
let's actually just see it in action so

00:05:09,670 --> 00:05:14,080
one of the slows it up here is graphical

00:05:12,070 --> 00:05:17,650
so you can think of graphical as being

00:05:14,080 --> 00:05:19,330
the IDE for graph QL it's not actually

00:05:17,650 --> 00:05:22,900
part of graphic yourself but if you

00:05:19,330 --> 00:05:25,300
download one of these servers you will

00:05:22,900 --> 00:05:27,040
generally get this component with it

00:05:25,300 --> 00:05:29,470
that's react component but what it lets

00:05:27,040 --> 00:05:32,290
you do is author queries as send them to

00:05:29,470 --> 00:05:35,170
the server so we can write our first

00:05:32,290 --> 00:05:36,730
query in graph QL and we could just

00:05:35,170 --> 00:05:38,590
start with an opening closing bracket

00:05:36,730 --> 00:05:40,680
and in this particular case we're going

00:05:38,590 --> 00:05:42,850
to say we're going to retrieve an artist

00:05:40,680 --> 00:05:44,650
and we're just going to retrieve the ads

00:05:42,850 --> 00:05:48,270
of the ID of one and for this particular

00:05:44,650 --> 00:05:50,590
they would just go to grab their name

00:05:48,270 --> 00:05:52,660
this wasn't gonna get nothing too fancy

00:05:50,590 --> 00:05:54,310
as yet but you're already seeing some

00:05:52,660 --> 00:05:57,010
similarities so we have a shape of a

00:05:54,310 --> 00:05:59,020
query on the left and then in the data

00:05:57,010 --> 00:06:01,870
side on the right again we see artists

00:05:59,020 --> 00:06:04,750
add name but so far nothing you wouldn't

00:06:01,870 --> 00:06:06,070
see it a REST API but again we now say

00:06:04,750 --> 00:06:09,280
okay well what happens if we wanted to

00:06:06,070 --> 00:06:12,670
retrieve each one of the album's for

00:06:09,280 --> 00:06:15,280
that particular artist and again we open

00:06:12,670 --> 00:06:16,810
closing brackets in graph QL vocabulary

00:06:15,280 --> 00:06:18,340
that's called a selection set and then

00:06:16,810 --> 00:06:21,010
each one of these items is here it's

00:06:18,340 --> 00:06:23,800
called a field and again in a single

00:06:21,010 --> 00:06:25,510
query we can now craft that we want to

00:06:23,800 --> 00:06:27,100
retrieve all of the albums of a trade on

00:06:25,510 --> 00:06:28,060
the right hand side so if you think

00:06:27,100 --> 00:06:29,800
about how you might have done that

00:06:28,060 --> 00:06:31,720
address you might have retrieved I've

00:06:29,800 --> 00:06:33,040
made one call to retrieve the artist and

00:06:31,720 --> 00:06:35,260
then another call to retrieve each one

00:06:33,040 --> 00:06:36,850
of the album's but again nothing

00:06:35,260 --> 00:06:39,130
earth-shattering here so we can go a

00:06:36,850 --> 00:06:42,160
little bit further so we said then that

00:06:39,130 --> 00:06:45,190
each one of these albums is released on

00:06:42,160 --> 00:06:47,650
a label so again let's say let's include

00:06:45,190 --> 00:06:49,670
the label there I know we get labels so

00:06:47,650 --> 00:06:52,910
we can see that the Wi-Fi

00:06:49,670 --> 00:06:54,830
relief goby we can even get a bit more

00:06:52,910 --> 00:06:58,310
interesting what happens if we no wanted

00:06:54,830 --> 00:07:00,260
to say retrieve all of the other albums

00:06:58,310 --> 00:07:02,090
that were a tree that were produced on

00:07:00,260 --> 00:07:03,910
that particular label and we could just

00:07:02,090 --> 00:07:06,290
keep on going

00:07:03,910 --> 00:07:07,940
so again retrieve all the albums

00:07:06,290 --> 00:07:10,430
retrieve the and then retrieve the

00:07:07,940 --> 00:07:12,560
artists for that and again retrieve the

00:07:10,430 --> 00:07:14,330
name so what you could see now is we

00:07:12,560 --> 00:07:16,640
think that arbitrarily build up these

00:07:14,330 --> 00:07:19,700
queries on the left-hand side all in one

00:07:16,640 --> 00:07:21,710
round-trip to the server so you also

00:07:19,700 --> 00:07:23,240
notice as I've gone through there's sort

00:07:21,710 --> 00:07:24,680
of like this type-ahead thing like

00:07:23,240 --> 00:07:27,530
that's that's pretty cool it seems like

00:07:24,680 --> 00:07:29,690
graticule knows what's a valid query or

00:07:27,530 --> 00:07:30,830
not so some of the spare of people in

00:07:29,690 --> 00:07:31,880
the room or if you use you go to

00:07:30,830 --> 00:07:33,500
production you're probably thinking

00:07:31,880 --> 00:07:35,870
there's some type system here you're

00:07:33,500 --> 00:07:38,500
absolutely spot-on and then that's what

00:07:35,870 --> 00:07:40,880
actually defines the ability to produce

00:07:38,500 --> 00:07:41,960
these solar type-ahead queries that

00:07:40,880 --> 00:07:44,330
there's actually a feature called

00:07:41,960 --> 00:07:47,030
introspection which lets you query the

00:07:44,330 --> 00:07:49,910
schema itself and that's exactly what

00:07:47,030 --> 00:07:51,890
graphical is doing likewise if I then

00:07:49,910 --> 00:07:53,990
typed in a field that doesn't exist I

00:07:51,890 --> 00:07:55,880
get this nice error to say this

00:07:53,990 --> 00:07:58,100
particular field doesn't exist at that

00:07:55,880 --> 00:08:00,890
type so again you could remove an entire

00:07:58,100 --> 00:08:02,270
category of problems that you might have

00:08:00,890 --> 00:08:03,590
with a weekly type system address

00:08:02,270 --> 00:08:06,230
because you could mathematically prove

00:08:03,590 --> 00:08:08,180
that any query a graph QL will either be

00:08:06,230 --> 00:08:10,490
able to be executed successfully on the

00:08:08,180 --> 00:08:13,430
server or not if it doesn't match the

00:08:10,490 --> 00:08:15,970
domain specific schema and the syntactic

00:08:13,430 --> 00:08:19,640
constraints defined by the graph QL

00:08:15,970 --> 00:08:21,110
specification so lot more 2d game at

00:08:19,640 --> 00:08:23,480
least I should give you a feeling that

00:08:21,110 --> 00:08:26,000
what we've no done instead of the server

00:08:23,480 --> 00:08:28,550
defining the various end points that the

00:08:26,000 --> 00:08:30,740
client can interact with the client

00:08:28,550 --> 00:08:32,540
takes on control we've inverted the

00:08:30,740 --> 00:08:35,450
responsibility where the client no

00:08:32,540 --> 00:08:37,580
defines exactly the data it needs which

00:08:35,450 --> 00:08:39,530
allows us to then satisfy the goal of

00:08:37,580 --> 00:08:41,420
each different version of each app or

00:08:39,530 --> 00:08:45,560
client experience to find it the query

00:08:41,420 --> 00:08:47,330
that it needs some people in the room

00:08:45,560 --> 00:08:49,490
began probably thinking I could

00:08:47,330 --> 00:08:53,300
absolutely have done that with rest at

00:08:49,490 --> 00:08:56,540
your eyes you could have boss graph QL

00:08:53,300 --> 00:08:58,730
makes it simple and trivial to do so

00:08:56,540 --> 00:09:01,010
there's no more bike shading about this

00:08:58,730 --> 00:09:02,750
is how we do a space feel set or this is

00:09:01,010 --> 00:09:06,020
how we do server side includes

00:09:02,750 --> 00:09:09,710
it makes it cheap a trivial to do so I

00:09:06,020 --> 00:09:11,330
get absolutely you could craft beautiful

00:09:09,710 --> 00:09:13,760
backends for front ends and optimize

00:09:11,330 --> 00:09:16,070
that but is that actually delivering

00:09:13,760 --> 00:09:17,450
business value or is that just creating

00:09:16,070 --> 00:09:19,070
an architecture to get around the put

00:09:17,450 --> 00:09:25,250
straight of the solution that you've

00:09:19,070 --> 00:09:26,930
addressed so again we've no sort of find

00:09:25,250 --> 00:09:28,820
a way that we could do synchronous

00:09:26,930 --> 00:09:30,860
client interactions irrespective of the

00:09:28,820 --> 00:09:33,200
client requirements in one road trip

00:09:30,860 --> 00:09:33,890
what about real-time interactions what a

00:09:33,200 --> 00:09:36,080
bug

00:09:33,890 --> 00:09:39,890
you know chaff push notifications what

00:09:36,080 --> 00:09:42,380
about them so so far we've been pulling

00:09:39,890 --> 00:09:44,750
data again the client asks a question

00:09:42,380 --> 00:09:48,590
that ad waits for the response from the

00:09:44,750 --> 00:09:50,330
server what if we could push data again

00:09:48,590 --> 00:09:52,610
in the similar way that we inverted the

00:09:50,330 --> 00:09:54,800
responsibility from the client created a

00:09:52,610 --> 00:09:57,170
query how's about the server could

00:09:54,800 --> 00:10:00,770
actually then push data to the client

00:09:57,170 --> 00:10:05,540
when a particular constraint or

00:10:00,770 --> 00:10:07,610
predicate resolves so again let's

00:10:05,540 --> 00:10:09,440
actually work through an example of

00:10:07,610 --> 00:10:11,480
where this might be valuable so again

00:10:09,440 --> 00:10:13,040
this use a story it says as a user I

00:10:11,480 --> 00:10:15,530
want to be notified with my favorite

00:10:13,040 --> 00:10:16,910
artists released albums so they like to

00:10:15,530 --> 00:10:19,520
keep up to date with the music that I

00:10:16,910 --> 00:10:21,200
love great that sounds like a wonderful

00:10:19,520 --> 00:10:22,610
thing there's sort of value adds that we

00:10:21,200 --> 00:10:24,050
could add to a system so again if

00:10:22,610 --> 00:10:27,440
there's something new we could ask them

00:10:24,050 --> 00:10:29,240
to create a review maybe on our site so

00:10:27,440 --> 00:10:32,200
again we have a number of options that

00:10:29,240 --> 00:10:34,310
we could do for building a real-time API

00:10:32,200 --> 00:10:36,800
traditionally we would've done polling

00:10:34,310 --> 00:10:40,010
and to be honest there is absolutely

00:10:36,800 --> 00:10:43,280
nothing wrong with polling providing a

00:10:40,010 --> 00:10:44,960
couple of you know things hold true

00:10:43,280 --> 00:10:47,480
polling is great when you know the

00:10:44,960 --> 00:10:49,910
refresh rate of your data so if you're

00:10:47,480 --> 00:10:52,220
looking at financial exchange rates and

00:10:49,910 --> 00:10:54,430
you know they update once a day that's

00:10:52,220 --> 00:10:57,560
fine just retrieve them once a day

00:10:54,430 --> 00:10:59,870
you're falling down though if you have

00:10:57,560 --> 00:11:02,390
an intermittent refresh rate because

00:10:59,870 --> 00:11:04,580
then you're trading off execute the

00:11:02,390 --> 00:11:07,720
query too many times versus having stale

00:11:04,580 --> 00:11:11,110
data so again that's that trade-off I

00:11:07,720 --> 00:11:13,610
get if we push if we adopt a push model

00:11:11,110 --> 00:11:16,130
and there's two main schools of thought

00:11:13,610 --> 00:11:16,649
for how we can achieve that in gravity

00:11:16,130 --> 00:11:18,899
well

00:11:16,649 --> 00:11:20,730
is live queries so you could effectively

00:11:18,899 --> 00:11:23,069
think of that is make a query and then

00:11:20,730 --> 00:11:25,319
if any one of the fields change in that

00:11:23,069 --> 00:11:29,189
particular query just push back that

00:11:25,319 --> 00:11:30,839
updated you know set of data sounds

00:11:29,189 --> 00:11:32,819
really simple but it yeah and it

00:11:30,839 --> 00:11:35,339
effectively equates to infinitely fast

00:11:32,819 --> 00:11:36,629
polling on the server side but very hard

00:11:35,339 --> 00:11:39,360
to implement

00:11:36,629 --> 00:11:40,199
you know efficiently and the other is

00:11:39,360 --> 00:11:44,160
subscriptions

00:11:40,199 --> 00:11:46,379
which are event based so effectively the

00:11:44,160 --> 00:11:49,619
idea from there is when a particular

00:11:46,379 --> 00:11:51,809
event or occurrence of something of

00:11:49,619 --> 00:11:55,050
interest to the business occurs you can

00:11:51,809 --> 00:11:57,929
then notify the client and a couple of

00:11:55,050 --> 00:11:59,790
properties of subscriptions they're

00:11:57,929 --> 00:12:02,610
read-only so you're not mutating or

00:11:59,790 --> 00:12:07,290
updating any data with that the real

00:12:02,610 --> 00:12:09,110
secret sauce though of subscriptions is

00:12:07,290 --> 00:12:12,899
that they're expressed in the graph QL

00:12:09,110 --> 00:12:16,170
syntax so again the client doesn't get

00:12:12,899 --> 00:12:18,990
served some arbitrary event structure

00:12:16,170 --> 00:12:21,449
the clients can actually express the

00:12:18,990 --> 00:12:24,629
query or data structure that they want

00:12:21,449 --> 00:12:27,029
to see when that event happens and again

00:12:24,629 --> 00:12:28,800
that's exactly the shape of the day they

00:12:27,029 --> 00:12:31,110
will retrieve so similar to the query

00:12:28,800 --> 00:12:32,910
it's not just a standard event you get

00:12:31,110 --> 00:12:35,910
to customize the set of data that you

00:12:32,910 --> 00:12:38,629
retrieve and again this is not something

00:12:35,910 --> 00:12:42,209
that we will use everywhere

00:12:38,629 --> 00:12:44,490
subscriptions are great Wade you have a

00:12:42,209 --> 00:12:46,319
large upfront dataset and then small

00:12:44,490 --> 00:12:50,029
incremental changes can be reflected on

00:12:46,319 --> 00:12:53,459
the yuan or you have a requirement for

00:12:50,029 --> 00:12:55,319
real time so like notifications to

00:12:53,459 --> 00:12:59,279
client I love you know like a chat

00:12:55,319 --> 00:13:00,839
interface where timeliness is key so how

00:12:59,279 --> 00:13:02,819
does this sort of work so in a typical

00:13:00,839 --> 00:13:04,290
call architecture we have down the left

00:13:02,819 --> 00:13:06,389
hand side that's the synchronous request

00:13:04,290 --> 00:13:08,579
response so again goes from the client

00:13:06,389 --> 00:13:09,749
dos graph to our server and returns up

00:13:08,579 --> 00:13:12,480
so effectively they're stateless

00:13:09,749 --> 00:13:16,069
interactions what we're looking to do

00:13:12,480 --> 00:13:18,299
with subscriptions is they're inherently

00:13:16,069 --> 00:13:20,249
stateful there is a long-lived

00:13:18,299 --> 00:13:21,959
connection between the client and the

00:13:20,249 --> 00:13:24,119
server of course there is you have to

00:13:21,959 --> 00:13:25,499
push data to it so if there's anything

00:13:24,119 --> 00:13:28,019
like signal or that you might have done

00:13:25,499 --> 00:13:29,990
like your ten years ago you know it's a

00:13:28,019 --> 00:13:32,270
similar sort of idea whereby

00:13:29,990 --> 00:13:35,540
there will be a client makes a

00:13:32,270 --> 00:13:38,300
subscription in this place you know sets

00:13:35,540 --> 00:13:40,520
their intent or interested hearing about

00:13:38,300 --> 00:13:41,750
updates with a server and then how does

00:13:40,520 --> 00:13:44,420
this actually then sort of like

00:13:41,750 --> 00:13:45,560
propagate back through so don't only

00:13:44,420 --> 00:13:48,649
business the way you will generally

00:13:45,560 --> 00:13:49,970
raise an event so that could come from

00:13:48,649 --> 00:13:51,800
your business the way no it can come

00:13:49,970 --> 00:13:55,100
from you know it could be a casket topic

00:13:51,800 --> 00:13:57,380
or you know a rabbitmq pub/sub sort of

00:13:55,100 --> 00:14:00,110
the minute ultimately that event will

00:13:57,380 --> 00:14:02,420
get propagated up into the subscriptions

00:14:00,110 --> 00:14:05,630
framework of graph QL and effectively

00:14:02,420 --> 00:14:08,870
that will be a stream of events what the

00:14:05,630 --> 00:14:11,149
subscriptions stream map will then do is

00:14:08,870 --> 00:14:12,470
take that input stream and map it to an

00:14:11,149 --> 00:14:14,600
output stream and that's the output

00:14:12,470 --> 00:14:16,940
stream for each one of those client

00:14:14,600 --> 00:14:20,810
queries and then that gets sent back to

00:14:16,940 --> 00:14:22,880
the kind so clear I think it I think a

00:14:20,810 --> 00:14:26,240
little example will will help sort of

00:14:22,880 --> 00:14:28,899
clarify what that flow looks like so in

00:14:26,240 --> 00:14:31,220
the first case the client will open up a

00:14:28,899 --> 00:14:32,630
WebSocket an endpoint in this particular

00:14:31,220 --> 00:14:34,670
case I've called the endpoint

00:14:32,630 --> 00:14:37,160
subscriptions it's not Paris aspect it's

00:14:34,670 --> 00:14:40,250
just what I chose and in this particular

00:14:37,160 --> 00:14:41,930
case they issue a subscription query to

00:14:40,250 --> 00:14:44,000
the server in this particular case

00:14:41,930 --> 00:14:45,740
they're saying well the when the album

00:14:44,000 --> 00:14:47,930
added event happens passing in their

00:14:45,740 --> 00:14:51,680
user ID they were to get the title of

00:14:47,930 --> 00:14:53,360
the album at the name of the artist so

00:14:51,680 --> 00:14:55,579
in this particular case stayed another

00:14:53,360 --> 00:15:00,130
user comes in in this case an admin user

00:14:55,579 --> 00:15:02,450
adds a new album what their happens is

00:15:00,130 --> 00:15:04,040
asynchronously that album added event

00:15:02,450 --> 00:15:06,680
with the shape of the data that they

00:15:04,040 --> 00:15:13,399
requested gets pushed back to the user

00:15:06,680 --> 00:15:17,060
so let's see that in action so what we

00:15:13,399 --> 00:15:19,820
have here is a very very very simple 1d

00:15:17,060 --> 00:15:21,770
interface this was meant to be something

00:15:19,820 --> 00:15:24,350
richer but I'll push a pull request over

00:15:21,770 --> 00:15:26,079
the next day or so to get updated so

00:15:24,350 --> 00:15:28,760
what we've got to do is go back to

00:15:26,079 --> 00:15:30,560
graphical and in this particular case so

00:15:28,760 --> 00:15:33,290
what I just did there was setting up the

00:15:30,560 --> 00:15:35,570
client to you know be interested in that

00:15:33,290 --> 00:15:38,900
particular subscription so no one played

00:15:35,570 --> 00:15:41,959
the role of the admin user who's now

00:15:38,900 --> 00:15:42,980
going to create that particular new

00:15:41,959 --> 00:15:45,050
album

00:15:42,980 --> 00:15:47,660
and then all things going well you will

00:15:45,050 --> 00:15:50,300
now see that that data in the same shape

00:15:47,660 --> 00:15:52,310
has been pushed back to the cloud

00:15:50,300 --> 00:15:53,510
so again just about to you to go on a

00:15:52,310 --> 00:15:55,340
journey with me and imagine that's a

00:15:53,510 --> 00:16:01,910
beauty rendered web page now and your

00:15:55,340 --> 00:16:05,030
significant pop up so what have you seen

00:16:01,910 --> 00:16:07,130
you have seen that graph QL had solved

00:16:05,030 --> 00:16:10,550
not only synchronous request response

00:16:07,130 --> 00:16:13,550
architectures but also service real-time

00:16:10,550 --> 00:16:16,160
push based architectures and the client

00:16:13,550 --> 00:16:18,140
only needs to understand graph QL it

00:16:16,160 --> 00:16:23,300
doesn't need to understand any other

00:16:18,140 --> 00:16:26,060
protocols there's a common interface so

00:16:23,300 --> 00:16:27,770
to wrap up really hope you've enjoyed

00:16:26,060 --> 00:16:29,960
sort of like this initial sort of brief

00:16:27,770 --> 00:16:31,760
intro to graph QL if you have any

00:16:29,960 --> 00:16:34,670
questions or would like to chat

00:16:31,760 --> 00:16:36,290
afterwards please do I absolutely love

00:16:34,670 --> 00:16:37,580
talking about this stuff I did see some

00:16:36,290 --> 00:16:39,290
hands up the back early you said they

00:16:37,580 --> 00:16:41,890
were using graph 2 also please come a

00:16:39,290 --> 00:16:41,890
chat thank you

00:16:45,640 --> 00:16:51,040
thank you so much Rob that was great

00:16:48,540 --> 00:16:53,200
I've just started having a little play

00:16:51,040 --> 00:16:55,480
with graph QL and it's it's such a cool

00:16:53,200 --> 00:16:56,920
lovely syntax it's pretty human readable

00:16:55,480 --> 00:16:58,180
which is great and like I love what

00:16:56,920 --> 00:17:01,360
you're saying before about making things

00:16:58,180 --> 00:17:04,360
just simple and like easy and cheap like

00:17:01,360 --> 00:17:06,580
non-trivial is not not valuable or not

00:17:04,360 --> 00:17:08,350
powerful yeah I can't agree more I think

00:17:06,580 --> 00:17:10,270
a lot of I think a lot of us treat

00:17:08,350 --> 00:17:12,220
problems that I'm guilty of myself for

00:17:10,270 --> 00:17:14,860
so achieving the approach with the

00:17:12,220 --> 00:17:16,420
technology that we chosen is success as

00:17:14,860 --> 00:17:18,190
opposed to the value of the product that

00:17:16,420 --> 00:17:20,140
you've delivered so yeah yeah and making

00:17:18,190 --> 00:17:22,690
it not maintainable by other people is

00:17:20,140 --> 00:17:25,500
not valuable pretty much I don't think

00:17:22,690 --> 00:17:25,500
so yep Thanks

00:17:31,520 --> 00:17:33,580

YouTube URL: https://www.youtube.com/watch?v=Vi6vsbm20oI


