Title: Jeremy Nagel - Attack of the mutants using mutation testing to improve your test suite
Publication date: 2018-04-11
Playlist: Decompress AU 2018
Description: 
	Code without tests is code that is going to sneak up behind you while you’re texting on your phone, put glue in your hair and steal your lucky horseshoe from your bag. Evil! But how can you find those dastardly lines? Traditionally we’ve used test coverage metrics (e.g. Istanbul) to track down those villains but coverage has a lot of gaps. A test can execute 100% of code without performing any assertions, giving you a false sense of security. 

What's the solution then? Fight back against those villains by unleashing mutants! Don't worry, you don't have to drink radioactive coolaid, we're talking about mutation testing. It involves using a tool like StrykerJS to programatically insert bugs (mutants) into your code and check whether the tests catch them. Having 100% test coverage is a noble goal but ultimately not very useful as it says nothing about the test suite's ability to catch bugs. On the other hand, having a 100% mutant kill score is a big deal. It means that your assertions can effectively pick up most potential bugs. 

Next time your manager asks for a risk analysis of the company's test suite, you'll know what to do: call in the mutants!
Captions: 
	00:00:13,030 --> 00:00:15,820
probably is a good description of what

00:00:15,009 --> 00:00:18,039
mutation

00:00:15,820 --> 00:00:19,840
years but it rather than operating on

00:00:18,039 --> 00:00:22,150
your infrastructure its operating on

00:00:19,840 --> 00:00:24,160
your code essentially the objective of

00:00:22,150 --> 00:00:26,529
mutation testing is to figure out

00:00:24,160 --> 00:00:28,900
whether your tests are actually good at

00:00:26,529 --> 00:00:31,660
testing your code because you can see

00:00:28,900 --> 00:00:35,890
code coverage but as I will present

00:00:31,660 --> 00:00:37,600
further it is not always reliable to

00:00:35,890 --> 00:00:39,670
kick things off I want to see whether

00:00:37,600 --> 00:00:42,190
you are listening to Jess's talk who

00:00:39,670 --> 00:00:43,930
here can shout out some characteristics

00:00:42,190 --> 00:00:45,670
of a good test suite that you might have

00:00:43,930 --> 00:00:53,460
picked up from her talk or from your own

00:00:45,670 --> 00:00:59,500
experience throw them out good coverage

00:00:53,460 --> 00:01:05,280
what else nice you must have seen my

00:00:59,500 --> 00:01:08,229
slide anything else

00:01:05,280 --> 00:01:13,420
very good all right we've got about

00:01:08,229 --> 00:01:16,509
three there I will I can get this to

00:01:13,420 --> 00:01:20,110
work okay high coverage that's what I

00:01:16,509 --> 00:01:21,970
used to think and BDD descriptions I'm a

00:01:20,110 --> 00:01:25,090
big fan of them I always liken code

00:01:21,970 --> 00:01:27,060
review to take people's BDD apart when

00:01:25,090 --> 00:01:30,240
they don't use given when then properly

00:01:27,060 --> 00:01:34,119
and it should mark everything and

00:01:30,240 --> 00:01:35,979
finally it can be a bit boring sometimes

00:01:34,119 --> 00:01:38,079
watching test runs so you should make

00:01:35,979 --> 00:01:41,220
sure that you use the nyan cat reporter

00:01:38,079 --> 00:01:41,220
makes it much more interesting

00:01:41,280 --> 00:01:46,270
fundamentally though I think even though

00:01:43,360 --> 00:01:48,399
those things are important the most

00:01:46,270 --> 00:01:51,100
important thing is that a test suite

00:01:48,399 --> 00:01:53,290
should be able to catch regressions if

00:01:51,100 --> 00:01:55,720
it can't do that then it serves no value

00:01:53,290 --> 00:01:57,310
you often have to spend quite a lot of

00:01:55,720 --> 00:02:00,040
time writing tests so if they don't

00:01:57,310 --> 00:02:04,960
actually help you to prevent bugs what's

00:02:00,040 --> 00:02:07,270
the point of them even though we might

00:02:04,960 --> 00:02:10,030
think that looking at coverage could be

00:02:07,270 --> 00:02:14,170
an effective way as just talked about

00:02:10,030 --> 00:02:16,239
it's not always completely reliable I'm

00:02:14,170 --> 00:02:19,870
gonna show you an example here I've got

00:02:16,239 --> 00:02:22,810
some code here very important code and

00:02:19,870 --> 00:02:25,180
as such I wrote some tests for it get

00:02:22,810 --> 00:02:27,520
100% coverage which means we should be

00:02:25,180 --> 00:02:30,830
pretty sweet with that code

00:02:27,520 --> 00:02:33,400
however how their closer look at the

00:02:30,830 --> 00:02:33,400
tests I wrote

00:02:33,490 --> 00:02:39,680
they definitely execute every branch of

00:02:36,560 --> 00:02:42,680
the code there however they're missing

00:02:39,680 --> 00:02:44,600
one crucial element they don't have any

00:02:42,680 --> 00:02:49,180
assertions they're completely useless

00:02:44,600 --> 00:02:51,950
and yet because Istanbul and alcove

00:02:49,180 --> 00:02:53,750
figure out coverage purely based on

00:02:51,950 --> 00:02:56,780
whether a line of code has been executed

00:02:53,750 --> 00:02:59,600
or not they can be fooled by situations

00:02:56,780 --> 00:03:01,459
like this where your code is being

00:02:59,600 --> 00:03:03,770
executed by the tests but you're not

00:03:01,459 --> 00:03:06,230
actually checking whether the expected

00:03:03,770 --> 00:03:08,989
thing happens or not that was a bit of a

00:03:06,230 --> 00:03:11,269
facetious example I'm sure that that

00:03:08,989 --> 00:03:14,330
wouldn't really pass code review but in

00:03:11,269 --> 00:03:18,050
the large project it's easy to fall into

00:03:14,330 --> 00:03:20,000
a trap like this here's NV b3 it's an

00:03:18,050 --> 00:03:23,239
open-source data visualization library a

00:03:20,000 --> 00:03:25,580
wrapper around d3 the Istanbul report

00:03:23,239 --> 00:03:27,200
indicates that some of it has decent

00:03:25,580 --> 00:03:30,620
coverage for example scatter chart

00:03:27,200 --> 00:03:32,000
you're looking at 84% statement coverage

00:03:30,620 --> 00:03:35,840
which sounds pretty good

00:03:32,000 --> 00:03:37,970
I mean Pareto principle 80% normally

00:03:35,840 --> 00:03:39,980
would catch most of the issues so you'd

00:03:37,970 --> 00:03:42,680
think based on that that that should be

00:03:39,980 --> 00:03:44,360
pretty solid but something about it

00:03:42,680 --> 00:03:46,700
doesn't feel right to me when I was

00:03:44,360 --> 00:03:48,709
looking through it the implementation

00:03:46,700 --> 00:03:50,900
code is about eleven hundred lines long

00:03:48,709 --> 00:03:53,840
but the tests are only two hundred and

00:03:50,900 --> 00:03:55,730
thirty ones and I don't know about you

00:03:53,840 --> 00:03:58,010
but I was always given the rule of thumb

00:03:55,730 --> 00:04:00,200
that the ratio between tests and

00:03:58,010 --> 00:04:03,200
implementation code it's generally about

00:04:00,200 --> 00:04:04,459
one to one if not double the amount of

00:04:03,200 --> 00:04:06,890
test code that you have for

00:04:04,459 --> 00:04:07,370
implementation code it felt a bit fishy

00:04:06,890 --> 00:04:10,310
to me

00:04:07,370 --> 00:04:14,750
the idea that an vd3 could be getting

00:04:10,310 --> 00:04:17,720
close to well over 80% coverage with

00:04:14,750 --> 00:04:19,250
only a quarter of the code for the tests

00:04:17,720 --> 00:04:21,229
and they're not doing anything fancy

00:04:19,250 --> 00:04:23,330
like snapshot tests which could reduce

00:04:21,229 --> 00:04:26,840
the amount of time or code that they'd

00:04:23,330 --> 00:04:29,600
need for the tests the other thing that

00:04:26,840 --> 00:04:32,810
made me feel a bit suspicious is that if

00:04:29,600 --> 00:04:34,160
tests are meant to stop regressions why

00:04:32,810 --> 00:04:37,010
there's so many bug reports first

00:04:34,160 --> 00:04:39,680
scatter chart I haven't checked recently

00:04:37,010 --> 00:04:40,910
but it seems like they're building up it

00:04:39,680 --> 00:04:44,480
doesn't seem

00:04:40,910 --> 00:04:46,880
like a scatter chart is able to maintain

00:04:44,480 --> 00:04:50,960
itself well and allow changes without

00:04:46,880 --> 00:04:56,560
regressions let's take on a different

00:04:50,960 --> 00:04:56,560
approach let's try mutation testing

00:04:58,870 --> 00:05:04,850
mutation testing it's not a new idea

00:05:01,220 --> 00:05:07,190
it's been around since the 1970s it's

00:05:04,850 --> 00:05:10,550
otherwise known as debugging a fault

00:05:07,190 --> 00:05:13,550
seeding or fault injection was first

00:05:10,550 --> 00:05:15,320
mentioned in 1971 they did it with

00:05:13,550 --> 00:05:18,080
Fortran back in the day it's a lot

00:05:15,320 --> 00:05:20,530
easier now than it was then the basic

00:05:18,080 --> 00:05:24,650
idea is that you take your nice code and

00:05:20,530 --> 00:05:26,420
then you inject some chaos into it you

00:05:24,650 --> 00:05:28,520
flip conditions around in this case we

00:05:26,420 --> 00:05:30,590
had some code which was very sensible it

00:05:28,520 --> 00:05:32,330
only fired missiles when provoked and

00:05:30,590 --> 00:05:34,880
now it is firing missiles

00:05:32,330 --> 00:05:37,460
indiscriminately we probably wouldn't

00:05:34,880 --> 00:05:39,170
want that to happen particularly if it

00:05:37,460 --> 00:05:42,100
was code that might be executed by a

00:05:39,170 --> 00:05:44,900
certain president of a certain country

00:05:42,100 --> 00:05:47,990
is the kind of mutations that are

00:05:44,900 --> 00:05:49,940
possible things like changing a plus to

00:05:47,990 --> 00:05:51,950
a minus a greater than 2 a less than and

00:05:49,940 --> 00:05:53,570
equals to a not equals or even

00:05:51,950 --> 00:05:56,900
completely deleting a function body

00:05:53,570 --> 00:05:59,180
these kind of changes to code alter the

00:05:56,900 --> 00:06:01,100
logic quite radically and therefore

00:05:59,180 --> 00:06:03,230
you'd expect that a decent test suite

00:06:01,100 --> 00:06:05,480
would be capable of picking up this

00:06:03,230 --> 00:06:09,080
deviation in logic and failing if it saw

00:06:05,480 --> 00:06:11,330
that in mutation testing parlance that

00:06:09,080 --> 00:06:13,760
is known as killing a mutant if your

00:06:11,330 --> 00:06:16,040
tests fail after a mutant is introduced

00:06:13,760 --> 00:06:19,040
that's good you want to be able to pick

00:06:16,040 --> 00:06:20,810
up changes like that if they pass then

00:06:19,040 --> 00:06:22,580
it means they weren't very good at

00:06:20,810 --> 00:06:25,640
stopping potential regressions from

00:06:22,580 --> 00:06:28,280
entering here's what the output of

00:06:25,640 --> 00:06:30,440
striker the main JavaScript mutation

00:06:28,280 --> 00:06:32,840
testing library looks like you get a

00:06:30,440 --> 00:06:35,090
HTML report which looks a bit similar to

00:06:32,840 --> 00:06:37,880
the coverage report you might get from

00:06:35,090 --> 00:06:41,750
karma or jasmine you see the areas in

00:06:37,880 --> 00:06:44,419
green where it seemed to do okay there

00:06:41,750 --> 00:06:47,840
weren't any mutants that survived there

00:06:44,419 --> 00:06:50,180
and then the bits in red that's where a

00:06:47,840 --> 00:06:53,510
mutant was introduced and it survived

00:06:50,180 --> 00:06:53,960
you can see here that one number 371 in

00:06:53,510 --> 00:06:55,789
blue

00:06:53,960 --> 00:06:57,800
I clicked on that one to reveal what the

00:06:55,789 --> 00:07:02,360
mutant was in this case

00:06:57,800 --> 00:07:04,970
it has changed a ternary expression

00:07:02,360 --> 00:07:07,099
there which used to check that the top

00:07:04,970 --> 00:07:09,979
property was defined and it's just

00:07:07,099 --> 00:07:11,810
changed it to true you can see here that

00:07:09,979 --> 00:07:14,180
the test still passed in that situation

00:07:11,810 --> 00:07:16,970
meaning that someone could probably go

00:07:14,180 --> 00:07:19,310
along and modify the code break the API

00:07:16,970 --> 00:07:23,030
for everyone else and you wouldn't get

00:07:19,310 --> 00:07:25,220
any indication at the end of a mutation

00:07:23,030 --> 00:07:28,160
testing run you get the mutant kill

00:07:25,220 --> 00:07:31,250
score which is a bit like coverage but

00:07:28,160 --> 00:07:33,620
potentially more robust the idea is that

00:07:31,250 --> 00:07:35,210
you generate a whole heap of mutants for

00:07:33,620 --> 00:07:38,210
scatter chart for example it generated

00:07:35,210 --> 00:07:41,000
about 500 mutants and then it runs the

00:07:38,210 --> 00:07:43,400
tests against each set of mutants and

00:07:41,000 --> 00:07:45,500
tries to kill them if it doesn't kill

00:07:43,400 --> 00:07:47,840
that mutant then that mutant has

00:07:45,500 --> 00:07:49,940
survived and you'll get the score at the

00:07:47,840 --> 00:07:53,270
end of how many you've killed it's a

00:07:49,940 --> 00:07:56,840
very violent activity that everyone

00:07:53,270 --> 00:07:59,570
hates mutants anyway let's actually get

00:07:56,840 --> 00:08:02,270
going and catch the mutants will use

00:07:59,570 --> 00:08:03,830
striker as I mentioned I really like

00:08:02,270 --> 00:08:07,460
this framework they're working on it

00:08:03,830 --> 00:08:09,530
actively it supports not everything that

00:08:07,460 --> 00:08:13,190
I'd like doesn't have react support yet

00:08:09,530 --> 00:08:16,340
but at does es6 typescript babel web

00:08:13,190 --> 00:08:20,449
pack angular for many projects that'll

00:08:16,340 --> 00:08:22,849
do the job when I ran it against NVDA 3

00:08:20,449 --> 00:08:25,039
this is the score I got at the end you

00:08:22,849 --> 00:08:27,979
will remember that the coverage score

00:08:25,039 --> 00:08:31,130
was 84% but the mutant kill score was

00:08:27,979 --> 00:08:33,820
only 21% which aligns with my personal

00:08:31,130 --> 00:08:38,060
intuition as to the quality of the tests

00:08:33,820 --> 00:08:40,310
to explain this discrepancy here's what

00:08:38,060 --> 00:08:42,649
the code for scatter chart looks like as

00:08:40,310 --> 00:08:45,680
I mentioned the code is about a thousand

00:08:42,649 --> 00:08:49,040
lines long 800 lines of that is 1 mega

00:08:45,680 --> 00:08:51,050
function what has happened is the tests

00:08:49,040 --> 00:08:54,410
have executed that function it's gone

00:08:51,050 --> 00:08:56,360
all the way through and instantly 80% it

00:08:54,410 --> 00:08:58,730
doesn't necessarily have any assertions

00:08:56,360 --> 00:09:01,070
in there but because it's executed the

00:08:58,730 --> 00:09:02,870
mega function which arguably is an

00:09:01,070 --> 00:09:05,240
anti-pattern when you're talking about

00:09:02,870 --> 00:09:06,370
writing code in general that's why I've

00:09:05,240 --> 00:09:08,379
written it

00:09:06,370 --> 00:09:13,209
that's the result you get you get misled

00:09:08,379 --> 00:09:17,769
by the coverage score mutation testing

00:09:13,209 --> 00:09:19,720
isn't so easily convinced as to the

00:09:17,769 --> 00:09:23,350
quality of the tests but there is one

00:09:19,720 --> 00:09:26,259
downside to it as just we're showing

00:09:23,350 --> 00:09:28,990
with the testing pyramid it can get

00:09:26,259 --> 00:09:31,720
quite expensive to run tests and even if

00:09:28,990 --> 00:09:33,730
your running unit tests because you have

00:09:31,720 --> 00:09:35,980
so many different mutants that you have

00:09:33,730 --> 00:09:37,629
to try and kill for example a scatter

00:09:35,980 --> 00:09:39,879
chart 500 mutants

00:09:37,629 --> 00:09:42,279
it's having to execute the test every

00:09:39,879 --> 00:09:44,259
time for every one of those mutants if

00:09:42,279 --> 00:09:45,639
you have fast tests that's not a big

00:09:44,259 --> 00:09:48,910
problem I've got a little side project

00:09:45,639 --> 00:09:51,490
test run in a doubt 5 500 milliseconds

00:09:48,910 --> 00:09:54,399
that can easily cope with hundreds of

00:09:51,490 --> 00:09:55,689
mutants but scatter chart even though

00:09:54,399 --> 00:09:58,149
they're meant to be unit tests they take

00:09:55,689 --> 00:10:00,309
one minute to run just for that one file

00:09:58,149 --> 00:10:01,569
which is also ridiculous I don't think

00:10:00,309 --> 00:10:03,970
they're really unit tests they're more

00:10:01,569 --> 00:10:07,660
like integration tests combined with UI

00:10:03,970 --> 00:10:10,899
tests for that reason you do have to be

00:10:07,660 --> 00:10:13,149
discerning about when to use it because

00:10:10,899 --> 00:10:16,029
in some situations if you have written

00:10:13,149 --> 00:10:18,309
good tests then coverage can do just as

00:10:16,029 --> 00:10:20,980
well as mutation testing there's been a

00:10:18,309 --> 00:10:23,740
bit of a battle off between mutation

00:10:20,980 --> 00:10:24,999
testing and coverage analysis at G tach

00:10:23,740 --> 00:10:27,819
the Google test automation conference

00:10:24,999 --> 00:10:30,160
over the last couple of years in 2015

00:10:27,819 --> 00:10:33,069
there was a talk that propounded the

00:10:30,160 --> 00:10:35,259
benefits of mutation testing making a

00:10:33,069 --> 00:10:37,600
compelling case based on all of the open

00:10:35,259 --> 00:10:39,579
source repositories that this researcher

00:10:37,600 --> 00:10:42,279
looked at she found that on Jen in

00:10:39,579 --> 00:10:45,220
general most of them didn't really have

00:10:42,279 --> 00:10:49,029
that high quality test coverage was not

00:10:45,220 --> 00:10:51,819
a good proxy for mutant cure score but

00:10:49,029 --> 00:10:53,649
in 2016 another researcher performed a

00:10:51,819 --> 00:10:56,499
slightly different analysis he had a

00:10:53,649 --> 00:10:58,990
larger sample set and he found that

00:10:56,499 --> 00:11:02,259
often there is quite a good correlation

00:10:58,990 --> 00:11:06,490
between coverage analysis and mutant

00:11:02,259 --> 00:11:09,040
kill score for that reason you probably

00:11:06,490 --> 00:11:11,290
want to have a hard look at your project

00:11:09,040 --> 00:11:14,620
and think about the consequences of a

00:11:11,290 --> 00:11:17,049
error if you're working on a little side

00:11:14,620 --> 00:11:18,850
project a little startup don't even

00:11:17,049 --> 00:11:19,810
bother writing tests it's probably not

00:11:18,850 --> 00:11:21,700
needed because

00:11:19,810 --> 00:11:24,670
your key metric of quality in that case

00:11:21,700 --> 00:11:26,950
is not how fancy your tests are or

00:11:24,670 --> 00:11:28,360
whether you're using flow tie for

00:11:26,950 --> 00:11:30,040
anything like that the only thing that

00:11:28,360 --> 00:11:32,050
really matters is do people want to use

00:11:30,040 --> 00:11:33,940
your app or not if you haven't got any

00:11:32,050 --> 00:11:35,529
users then forget about everything else

00:11:33,940 --> 00:11:37,900
forget about technical debt just get out

00:11:35,529 --> 00:11:39,520
there and sell more but once you do have

00:11:37,900 --> 00:11:41,170
some users and people are paying money

00:11:39,520 --> 00:11:43,510
for it then you probably should think

00:11:41,170 --> 00:11:44,830
about adding in tests to safeguard your

00:11:43,510 --> 00:11:47,500
app and make sure that it doesn't

00:11:44,830 --> 00:11:49,330
regress as it gets bigger and as you

00:11:47,500 --> 00:11:51,580
start working on really high-impact

00:11:49,330 --> 00:11:54,100
projects if you're working on an

00:11:51,580 --> 00:11:55,750
implanted device say a pacemaker or if

00:11:54,100 --> 00:11:58,480
you were the engineers that built the

00:11:55,750 --> 00:12:01,360
Mars landing rover that actually crashed

00:11:58,480 --> 00:12:03,100
in the early 2000s due to a faulty

00:12:01,360 --> 00:12:05,560
calculation between metric and imperial

00:12:03,100 --> 00:12:08,380
conversion you probably should be

00:12:05,560 --> 00:12:10,270
writing as many tests as possible and

00:12:08,380 --> 00:12:12,310
using mutation testing because the

00:12:10,270 --> 00:12:14,260
consequences of failure could be lives

00:12:12,310 --> 00:12:16,540
loss or millions of dollars lost in

00:12:14,260 --> 00:12:18,940
revenue I'm going to assume for the rest

00:12:16,540 --> 00:12:20,650
of the talk that you are or will one day

00:12:18,940 --> 00:12:22,390
work on a project like that and I'm

00:12:20,650 --> 00:12:25,350
going to show you how you can use

00:12:22,390 --> 00:12:27,970
mutation testing to help you with that

00:12:25,350 --> 00:12:29,500
before we actually run some mutation

00:12:27,970 --> 00:12:32,130
testing there's something that you need

00:12:29,500 --> 00:12:35,320
to do to get yourself into the mindset

00:12:32,130 --> 00:12:38,440
remember that you're killing mutants the

00:12:35,320 --> 00:12:42,640
person who best can do that is William

00:12:38,440 --> 00:12:44,770
Stryker from the x-men movies so get

00:12:42,640 --> 00:12:47,650
into his mind frame I'm gonna put on a

00:12:44,770 --> 00:12:49,300
wig to make me look a bit more like him

00:12:47,650 --> 00:12:53,589
I don't think it's quite the right color

00:12:49,300 --> 00:12:55,990
but it'll do the job now that I have

00:12:53,589 --> 00:12:59,589
taken that step I will configure Stryker

00:12:55,990 --> 00:13:01,660
if you've ever used karma you'll find

00:12:59,589 --> 00:13:04,260
there config relatively similar you

00:13:01,660 --> 00:13:06,610
specify which files you want to test

00:13:04,260 --> 00:13:10,209
which files you want to mutate in this

00:13:06,610 --> 00:13:12,850
case and you also set several other

00:13:10,209 --> 00:13:18,430
config parameters like the number of CPU

00:13:12,850 --> 00:13:21,940
caused two years and then you hit go it

00:13:18,430 --> 00:13:23,560
generates some mutants this is running

00:13:21,940 --> 00:13:25,870
against my little side project so it

00:13:23,560 --> 00:13:30,120
runs pretty quickly it's found eight

00:13:25,870 --> 00:13:33,280
files from mutate generated 400 mutants

00:13:30,120 --> 00:13:36,520
that's using four CPU cores

00:13:33,280 --> 00:13:38,230
and now it's going you can see the

00:13:36,520 --> 00:13:40,330
number that it's cured on the far left

00:13:38,230 --> 00:13:42,520
and the number that are surviving

00:13:40,330 --> 00:13:44,230
I really wish they had a yarn cat

00:13:42,520 --> 00:13:46,510
reporter as well because it's a bit slow

00:13:44,230 --> 00:13:49,690
here even though the test run relatively

00:13:46,510 --> 00:13:51,310
quickly once it's done you can open up

00:13:49,690 --> 00:13:54,160
the HTML report that I showed you

00:13:51,310 --> 00:13:56,740
earlier and it'll show you in greater

00:13:54,160 --> 00:13:59,260
detail which mutant survived and which

00:13:56,740 --> 00:14:01,720
were cured this can then help you to

00:13:59,260 --> 00:14:09,700
hone in on your tests and add more to

00:14:01,720 --> 00:14:12,250
back fuel where your missing tests just

00:14:09,700 --> 00:14:13,690
like what just was saying earlier there

00:14:12,250 --> 00:14:16,330
are some things that you want to avoid

00:14:13,690 --> 00:14:17,650
when it comes to mutation testing who

00:14:16,330 --> 00:14:20,140
can remember some of the things that

00:14:17,650 --> 00:14:21,820
just suggested as best practices for

00:14:20,140 --> 00:14:29,890
unit tests and perhaps some things to

00:14:21,820 --> 00:14:33,400
avoid shout them out again okay I'll

00:14:29,890 --> 00:14:37,030
have to help you all right number one

00:14:33,400 --> 00:14:40,150
slow tests if you have slow tests like

00:14:37,030 --> 00:14:43,089
MD D 3 be prepared for five hours of

00:14:40,150 --> 00:14:44,560
your machine running on four CPU cores

00:14:43,089 --> 00:14:47,260
meaning you can't really do anything

00:14:44,560 --> 00:14:49,000
else during that time it's good if it's

00:14:47,260 --> 00:14:51,880
wintertime and you want to heat the room

00:14:49,000 --> 00:14:54,280
but otherwise you probably don't want to

00:14:51,880 --> 00:14:56,230
work on a project like that you do want

00:14:54,280 --> 00:14:58,690
to before you even consider mutation

00:14:56,230 --> 00:15:01,480
testing you'll want to improve the speed

00:14:58,690 --> 00:15:04,300
of your tests the other thing that you

00:15:01,480 --> 00:15:06,790
absolutely don't want again I'm picking

00:15:04,300 --> 00:15:09,640
on NB 3 you don't want memory leaks it

00:15:06,790 --> 00:15:12,400
turns out that whilst one run of the n

00:15:09,640 --> 00:15:14,890
BB three tests seems fine when you run

00:15:12,400 --> 00:15:18,130
them 500 times in a row it ends up using

00:15:14,890 --> 00:15:20,800
four gigabytes of heap that's not really

00:15:18,130 --> 00:15:23,140
ideal it's more than the default memory

00:15:20,800 --> 00:15:25,420
that note is allocated I had to bump it

00:15:23,140 --> 00:15:27,490
up and I experienced major issues when I

00:15:25,420 --> 00:15:29,140
was trying to run it on CI so I was

00:15:27,490 --> 00:15:30,580
running it on a tee to micro instance

00:15:29,140 --> 00:15:32,950
which didn't actually have that much

00:15:30,580 --> 00:15:36,190
memory so you probably don't want to

00:15:32,950 --> 00:15:38,320
have that you also want to avoid

00:15:36,190 --> 00:15:39,910
dependent tests because ideally a good

00:15:38,320 --> 00:15:42,220
test Runner is not gonna run things

00:15:39,910 --> 00:15:44,890
exactly in sequence if you have tests

00:15:42,220 --> 00:15:46,839
where one test relies on the result of

00:15:44,890 --> 00:15:47,260
the previous test you're going to be in

00:15:46,839 --> 00:15:49,510
trouble

00:15:47,260 --> 00:15:51,520
because ideally that one at the top

00:15:49,510 --> 00:15:52,960
might be run on one core and the one

00:15:51,520 --> 00:15:56,650
blue might be run on another core

00:15:52,960 --> 00:15:58,630
anything to speed it up and finally

00:15:56,650 --> 00:16:01,690
forget about a hundred percent or 80

00:15:58,630 --> 00:16:04,630
percent none of that really matters at

00:16:01,690 --> 00:16:06,790
the end of the day quality is defined by

00:16:04,630 --> 00:16:08,620
many things one of them might be the

00:16:06,790 --> 00:16:11,290
quality of the test but you also need to

00:16:08,620 --> 00:16:13,120
factor in performance accessibility UI

00:16:11,290 --> 00:16:15,430
testing there are so many other things

00:16:13,120 --> 00:16:17,290
to consider this is just one tool in the

00:16:15,430 --> 00:16:20,470
tool kit that you should consider in

00:16:17,290 --> 00:16:22,810
certain projects things that you

00:16:20,470 --> 00:16:25,420
shouldn't avoid definitely go for the

00:16:22,810 --> 00:16:28,300
testing pyramid the antithesis of that

00:16:25,420 --> 00:16:31,080
is the testing ice cream cone where you

00:16:28,300 --> 00:16:33,790
have much more manual tests at the top

00:16:31,080 --> 00:16:36,340
then you have automated unit tests

00:16:33,790 --> 00:16:39,190
that's probably the situation that NV d3

00:16:36,340 --> 00:16:42,100
is in it has basically rather than unit

00:16:39,190 --> 00:16:43,720
tests they're all essential UI tests and

00:16:42,100 --> 00:16:45,370
you probably don't want to try mutate

00:16:43,720 --> 00:16:47,380
everything at once particularly if

00:16:45,370 --> 00:16:49,060
you're doing it on CI if you know that

00:16:47,380 --> 00:16:50,860
you've only changed one file there's no

00:16:49,060 --> 00:16:52,870
value in mutating everything else you

00:16:50,860 --> 00:16:55,110
want to get specific otherwise you're

00:16:52,870 --> 00:16:57,760
going to be waiting for hours on end and

00:16:55,110 --> 00:17:00,760
finally I highly recommend that you get

00:16:57,760 --> 00:17:03,160
a ROM BQ by octahedral core machine that

00:17:00,760 --> 00:17:08,830
will make your mutation testing run much

00:17:03,160 --> 00:17:13,650
faster also don't do what nd d3 is don't

00:17:08,830 --> 00:17:17,860
have mega functions that idea all right

00:17:13,650 --> 00:17:20,860
- y'all don't listen coverage analysis

00:17:17,860 --> 00:17:23,470
can be misleading if you create bugs

00:17:20,860 --> 00:17:26,490
customers will hate you and you've got

00:17:23,470 --> 00:17:28,660
to make sure that your tests run fast

00:17:26,490 --> 00:17:30,370
thank you very much if you're interested

00:17:28,660 --> 00:17:32,290
in talking about it more please come and

00:17:30,370 --> 00:17:33,740
talk to me I'll even let you wear that

00:17:32,290 --> 00:17:37,650
we give you one

00:17:33,740 --> 00:17:37,650
[Applause]

00:17:42,179 --> 00:17:44,240

YouTube URL: https://www.youtube.com/watch?v=W8UXlk-Ug_0


