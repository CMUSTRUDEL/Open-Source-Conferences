Title: Akademy 2021 -  Closing the distance between CPU and GPU with Signed Distance Fields
Publication date: 2021-06-28
Playlist: Akademy 2021
Description: 
	By Arjen Hiemstra
Traditional 2D rendering methods make use of the CPU. However, modern systems feature an increasingly powerful GPU. Unfortunately the traditional methods are not very suitable for running on the GPU. This means we need to reconsider how to render 2D elements. In this talk I will talk about one technique called Signed Distance Fields, which is used by the KQuickCharts framework as well as the ShadowedRectangle in Kirigami. Signed Distance Fields require some changes in how we deal with 2D elements, but once we have overcome those, they become a very powerful tool for advanced 2D rendering.
Captions: 
	00:00:01,130 --> 00:00:08,610
[Music]

00:00:10,639 --> 00:00:17,039
thank you

00:00:13,120 --> 00:00:20,160
so uh hello everyone i am

00:00:17,039 --> 00:00:24,240
my name is aryn himstra i have been

00:00:20,160 --> 00:00:27,599
involved with kde for

00:00:24,240 --> 00:00:27,920
a pretty long time currently i'm working

00:00:27,599 --> 00:00:31,359
at

00:00:27,920 --> 00:00:32,000
blue systems and one of my interest

00:00:31,359 --> 00:00:35,760
areas

00:00:32,000 --> 00:00:37,040
is graphics related graphics programming

00:00:35,760 --> 00:00:40,719
mostly

00:00:37,040 --> 00:00:42,879
and well that's actually what today's

00:00:40,719 --> 00:00:46,000
talk is about

00:00:42,879 --> 00:00:49,280
i've been working on some

00:00:46,000 --> 00:00:52,480
very much graphics related problems

00:00:49,280 --> 00:00:56,840
for the past two years and

00:00:52,480 --> 00:00:58,239
have found some interesting developments

00:00:56,840 --> 00:01:02,559
there

00:00:58,239 --> 00:01:05,600
um so this talk is about

00:01:02,559 --> 00:01:09,439
uh distance fields sign distance fields

00:01:05,600 --> 00:01:13,840
specifically um but first i would like

00:01:09,439 --> 00:01:19,439
to explain some content concepts behind

00:01:13,840 --> 00:01:21,119
well everything that is being

00:01:19,439 --> 00:01:23,920
are everything that underpins these

00:01:21,119 --> 00:01:23,920
distance fields

00:01:24,720 --> 00:01:32,240
so for starters the current

00:01:28,799 --> 00:01:36,000
uh major apis that use

00:01:32,240 --> 00:01:38,880
uh for 2d rendering on

00:01:36,000 --> 00:01:39,360
uh well everything basically are based

00:01:38,880 --> 00:01:41,439
on

00:01:39,360 --> 00:01:43,759
a model that's called the postscript

00:01:41,439 --> 00:01:43,759
model

00:01:44,560 --> 00:01:51,840
this model is has been developed

00:01:48,560 --> 00:01:52,840
in the end of the 1980s and essentially

00:01:51,840 --> 00:01:56,719
it models

00:01:52,840 --> 00:01:59,840
a 2d plotter

00:01:56,719 --> 00:02:03,439
and it has a list of commands

00:01:59,840 --> 00:02:06,399
where you go okay move from

00:02:03,439 --> 00:02:07,759
point a to point b then draw a line then

00:02:06,399 --> 00:02:10,959
do something else

00:02:07,759 --> 00:02:14,400
and that's how you end up

00:02:10,959 --> 00:02:16,400
rendering various shapes using this

00:02:14,400 --> 00:02:19,440
postscript model

00:02:16,400 --> 00:02:22,480
um and as i mentioned it's been

00:02:19,440 --> 00:02:25,599
the major api

00:02:22,480 --> 00:02:29,440
are the major model used by systems

00:02:25,599 --> 00:02:33,760
such as q painter also canvas on the web

00:02:29,440 --> 00:02:37,840
is using this and in fact svg models

00:02:33,760 --> 00:02:37,840
is modeled based on this

00:02:38,400 --> 00:02:41,680
which is all nice and everything but

00:02:40,480 --> 00:02:43,920
then

00:02:41,680 --> 00:02:46,560
we have a different thing these days

00:02:43,920 --> 00:02:49,599
which is called the gpu

00:02:46,560 --> 00:02:53,920
which is so ubiquitous

00:02:49,599 --> 00:02:56,959
these days that everything even

00:02:53,920 --> 00:03:00,159
mobile phones and a whole bunch of uh

00:02:56,959 --> 00:03:04,080
embedded systems even now

00:03:00,159 --> 00:03:06,480
feature this gpu um and it's a chip that

00:03:04,080 --> 00:03:08,080
has been designed for

00:03:06,480 --> 00:03:10,720
something completely different because

00:03:08,080 --> 00:03:14,400
it was originally meant to accelerate

00:03:10,720 --> 00:03:17,200
3d rendering um

00:03:14,400 --> 00:03:20,480
and because of that it's designed to be

00:03:17,200 --> 00:03:20,480
massively parallel

00:03:20,640 --> 00:03:28,720
so it's it's designed to process

00:03:25,040 --> 00:03:31,280
uh individual points and and everything

00:03:28,720 --> 00:03:32,000
in a parallel way which is completely

00:03:31,280 --> 00:03:36,080
different from

00:03:32,000 --> 00:03:39,519
how your cpu handles things actually

00:03:36,080 --> 00:03:42,319
um and uh

00:03:39,519 --> 00:03:43,760
a development that has been around for a

00:03:42,319 --> 00:03:46,799
long time now

00:03:43,760 --> 00:03:49,840
uh was to be able to

00:03:46,799 --> 00:03:50,959
execute different small programs on the

00:03:49,840 --> 00:03:54,959
cpu

00:03:50,959 --> 00:03:58,799
to do various tasks

00:03:54,959 --> 00:04:02,560
to render this

00:03:58,799 --> 00:04:04,239
to to render things on screen uh

00:04:02,560 --> 00:04:07,200
these programs are called programmable

00:04:04,239 --> 00:04:11,120
shaders or shaders usually

00:04:07,200 --> 00:04:13,920
um which are these days written

00:04:11,120 --> 00:04:15,519
in some kind of high level language for

00:04:13,920 --> 00:04:17,199
example

00:04:15,519 --> 00:04:19,040
and what i will be using in the rest of

00:04:17,199 --> 00:04:22,320
this talk glsl

00:04:19,040 --> 00:04:25,360
which is the main shading language of

00:04:22,320 --> 00:04:25,360
used by opengl

00:04:26,960 --> 00:04:34,560
these shaders will be executed

00:04:30,720 --> 00:04:37,680
used on uh during different stages

00:04:34,560 --> 00:04:40,639
of your rendering pipeline

00:04:37,680 --> 00:04:41,280
so for example uh in earth for in this

00:04:40,639 --> 00:04:45,520
example

00:04:41,280 --> 00:04:49,199
i have a vertex shader which converts

00:04:45,520 --> 00:04:51,360
points that you provide to the api

00:04:49,199 --> 00:04:51,360
to

00:04:52,720 --> 00:04:57,040
something that can then later on be

00:04:55,680 --> 00:04:59,440
rasterized

00:04:57,040 --> 00:05:00,560
and rendered using the fragment shader

00:04:59,440 --> 00:05:03,440
which i've also

00:05:00,560 --> 00:05:03,440
illustrated here

00:05:07,360 --> 00:05:13,759
which is very it's it's it's

00:05:10,720 --> 00:05:17,600
a different way of handling things and

00:05:13,759 --> 00:05:17,600
it comes with its own complexities

00:05:18,160 --> 00:05:22,000
so sign distance fields

00:05:22,800 --> 00:05:29,680
as i said we have

00:05:26,000 --> 00:05:30,479
this gpu and so but we have a problem

00:05:29,680 --> 00:05:32,160
here

00:05:30,479 --> 00:05:33,520
because it would be really nice if we

00:05:32,160 --> 00:05:37,759
can use this gpu

00:05:33,520 --> 00:05:41,520
for rendering much more complex 2d items

00:05:37,759 --> 00:05:44,240
then so that we don't

00:05:41,520 --> 00:05:45,360
stress our cpu and leave that over leave

00:05:44,240 --> 00:05:48,560
that up

00:05:45,360 --> 00:05:51,360
to do other tasks or because we simply

00:05:48,560 --> 00:05:52,880
have a gpu that's more capable of doing

00:05:51,360 --> 00:05:55,919
this

00:05:52,880 --> 00:05:59,440
however the postscript model as i

00:05:55,919 --> 00:06:00,160
illustrated before is very much a serial

00:05:59,440 --> 00:06:04,080
process

00:06:00,160 --> 00:06:07,120
it's executing tasks that go

00:06:04,080 --> 00:06:10,160
okay move line all that stuff

00:06:07,120 --> 00:06:13,199
and every previous task x

00:06:10,160 --> 00:06:17,759
step actually depends on our every step

00:06:13,199 --> 00:06:17,759
depends on the previous step so

00:06:18,319 --> 00:06:22,160
this is a problem for a gpu because the

00:06:21,440 --> 00:06:24,479
gpu

00:06:22,160 --> 00:06:25,840
is actually really really bad at doing

00:06:24,479 --> 00:06:28,400
serial

00:06:25,840 --> 00:06:30,000
tasks it's way better at doing massive

00:06:28,400 --> 00:06:32,800
parallel tasks

00:06:30,000 --> 00:06:34,000
because that's how it was designed which

00:06:32,800 --> 00:06:36,319
means that

00:06:34,000 --> 00:06:38,000
we kind of need a new rendering model if

00:06:36,319 --> 00:06:41,199
we're going to render 2d

00:06:38,000 --> 00:06:41,199
on the gpu

00:06:42,160 --> 00:06:45,840
and this is where distance fields come

00:06:44,560 --> 00:06:48,880
in

00:06:45,840 --> 00:06:52,479
so sine distance fields are

00:06:48,880 --> 00:06:55,919
at their most basic they are

00:06:52,479 --> 00:06:59,360
mass that describes the distance from

00:06:55,919 --> 00:07:02,880
a point to a shape

00:06:59,360 --> 00:07:06,400
in this example i'm using a circle

00:07:02,880 --> 00:07:07,840
which is the most basic distance field

00:07:06,400 --> 00:07:11,120
that you can get

00:07:07,840 --> 00:07:15,199
and the distance field for a circle

00:07:11,120 --> 00:07:20,000
is a is basically the length

00:07:15,199 --> 00:07:23,520
of the point to the center of the circle

00:07:20,000 --> 00:07:26,639
minus the radius of the circle now

00:07:23,520 --> 00:07:28,160
this is a bit complex uh if you're

00:07:26,639 --> 00:07:32,000
looking at

00:07:28,160 --> 00:07:34,319
added from the point of math

00:07:32,000 --> 00:07:35,599
however it does provide us with some

00:07:34,319 --> 00:07:38,960
properties because

00:07:35,599 --> 00:07:41,680
what we can do is we can sample

00:07:38,960 --> 00:07:43,599
that function that mathematical function

00:07:41,680 --> 00:07:46,560
at various points

00:07:43,599 --> 00:07:48,560
get a distance out of that and then for

00:07:46,560 --> 00:07:52,160
with that distance we can

00:07:48,560 --> 00:07:53,599
calculate other effects so for example

00:07:52,160 --> 00:07:56,639
here if we have

00:07:53,599 --> 00:07:57,599
three different points in this distance

00:07:56,639 --> 00:08:01,120
field

00:07:57,599 --> 00:08:04,160
where we have one point a

00:08:01,120 --> 00:08:06,479
which is on the edge

00:08:04,160 --> 00:08:07,280
where the distance is zero and then we

00:08:06,479 --> 00:08:10,240
have b which

00:08:07,280 --> 00:08:11,520
is outside of the shape which has a

00:08:10,240 --> 00:08:14,560
different distance

00:08:11,520 --> 00:08:18,319
and then we have c which is inside

00:08:14,560 --> 00:08:21,199
the shape which has a

00:08:18,319 --> 00:08:21,680
also a distance value and you'll notice

00:08:21,199 --> 00:08:24,800
here

00:08:21,680 --> 00:08:27,840
that this is where the signing comes in

00:08:24,800 --> 00:08:31,039
because b is outside the shape

00:08:27,840 --> 00:08:33,120
so it has a positive value whereas c

00:08:31,039 --> 00:08:36,080
is inside the shape and it has a

00:08:33,120 --> 00:08:36,080
negative value

00:08:36,880 --> 00:08:43,839
so this sampling is very useful

00:08:40,560 --> 00:08:44,560
because we can determine where things

00:08:43,839 --> 00:08:49,279
lie

00:08:44,560 --> 00:08:52,160
however and and this is actually where

00:08:49,279 --> 00:08:53,279
the gpu comes in because a fragment

00:08:52,160 --> 00:08:56,959
shader

00:08:53,279 --> 00:08:59,680
is effectively capable of

00:08:56,959 --> 00:09:00,240
sampling this distance function for each

00:08:59,680 --> 00:09:03,519
pixel

00:09:00,240 --> 00:09:06,240
on the screen which

00:09:03,519 --> 00:09:08,480
is something that basically comes for

00:09:06,240 --> 00:09:11,600
free if you're using a gpu

00:09:08,480 --> 00:09:14,800
because that's what your gpu does anyway

00:09:11,600 --> 00:09:17,839
for the final rendering step

00:09:14,800 --> 00:09:21,120
in your pipeline it needs to convert

00:09:17,839 --> 00:09:22,240
your points into something that's

00:09:21,120 --> 00:09:24,640
rendered on screen

00:09:22,240 --> 00:09:25,519
and there's a step called rasterization

00:09:24,640 --> 00:09:28,720
which

00:09:25,519 --> 00:09:30,800
turns these points into a grid of of

00:09:28,720 --> 00:09:32,080
individual pixels and then for each

00:09:30,800 --> 00:09:34,560
pixel

00:09:32,080 --> 00:09:35,760
it will it will execute your fragment

00:09:34,560 --> 00:09:38,240
shader

00:09:35,760 --> 00:09:39,680
to determine the final color so if you

00:09:38,240 --> 00:09:42,800
have a fragment shader

00:09:39,680 --> 00:09:45,279
that contains a

00:09:42,800 --> 00:09:46,240
sine distance field you can sample you

00:09:45,279 --> 00:09:50,800
you are

00:09:46,240 --> 00:09:52,480
you will get a sample for each pixel

00:09:50,800 --> 00:09:55,440
or you can sample this distance field

00:09:52,480 --> 00:09:55,440
for each pixel

00:10:01,760 --> 00:10:07,760
so in this case continuing with the

00:10:04,880 --> 00:10:07,760
circle example

00:10:07,839 --> 00:10:11,360
i have converted the

00:10:11,920 --> 00:10:19,440
math expression to something that's

00:10:16,320 --> 00:10:23,120
to something in glsl which is

00:10:19,440 --> 00:10:26,160
in fact very simple to do

00:10:23,120 --> 00:10:29,200
at least for a circle because you can

00:10:26,160 --> 00:10:31,360
glso simply has a length function so you

00:10:29,200 --> 00:10:34,240
can get the length of the point

00:10:31,360 --> 00:10:35,279
of the sample and then you subtract the

00:10:34,240 --> 00:10:39,279
radius

00:10:35,279 --> 00:10:43,440
and you get the distance to this shape

00:10:39,279 --> 00:10:45,839
in this case i'm rendering directly

00:10:43,440 --> 00:10:46,560
the distance to this point so you get a

00:10:45,839 --> 00:10:49,760
nice

00:10:46,560 --> 00:10:51,279
black blob of course that's not very

00:10:49,760 --> 00:10:54,480
useful

00:10:51,279 --> 00:10:55,120
so we need to do some extra operations

00:10:54,480 --> 00:11:01,760
with this

00:10:55,120 --> 00:11:05,360
distance field with its distance value

00:11:01,760 --> 00:11:10,240
and so as said uh distance fields

00:11:05,360 --> 00:11:10,240
signed distance builds specifically are

00:11:10,880 --> 00:11:15,360
signed for and which means that we can

00:11:13,839 --> 00:11:17,519
make use of this property

00:11:15,360 --> 00:11:18,720
to determine whether we're inside or

00:11:17,519 --> 00:11:21,839
outside of

00:11:18,720 --> 00:11:25,200
a shape in this case if we check

00:11:21,839 --> 00:11:28,959
hey is my distance bigger than zero

00:11:25,200 --> 00:11:30,959
then i know we're outside of this shape

00:11:28,959 --> 00:11:32,160
so we don't need to render anything and

00:11:30,959 --> 00:11:35,519
we can just return

00:11:32,160 --> 00:11:36,800
a transparent color whereas if we're

00:11:35,519 --> 00:11:40,079
inside the shape

00:11:36,800 --> 00:11:40,720
we can actually return the color that we

00:11:40,079 --> 00:11:44,240
use

00:11:40,720 --> 00:11:48,079
or that we want the shape to have

00:11:44,240 --> 00:11:52,000
well that said this test is very binary

00:11:48,079 --> 00:11:53,519
so it's it's not

00:11:52,000 --> 00:11:55,120
i don't know if it's clear in the

00:11:53,519 --> 00:11:57,600
picture but

00:11:55,120 --> 00:11:59,360
it leads to an uh some artifact that's

00:11:57,600 --> 00:12:01,680
called aliasing

00:11:59,360 --> 00:12:03,760
because right now we're saying either

00:12:01,680 --> 00:12:05,680
it's the pixel is inside the shape or

00:12:03,760 --> 00:12:08,959
it's outside the shape

00:12:05,680 --> 00:12:12,160
and there's no uh since we're

00:12:08,959 --> 00:12:13,120
rendering in a grid we get a grid as an

00:12:12,160 --> 00:12:16,320
output

00:12:13,120 --> 00:12:20,000
which doesn't lead to very nice shapes

00:12:16,320 --> 00:12:23,279
however since we have a distance

00:12:20,000 --> 00:12:26,240
we can make use of that distance

00:12:23,279 --> 00:12:27,200
to improve this result because rather

00:12:26,240 --> 00:12:30,560
than saying by

00:12:27,200 --> 00:12:33,360
just saying binary hey inside or outside

00:12:30,560 --> 00:12:34,880
we can actually use the gradient from

00:12:33,360 --> 00:12:38,160
the distance

00:12:34,880 --> 00:12:43,040
to to perform

00:12:38,160 --> 00:12:47,839
uh anti-aliasing uh almost for free

00:12:43,040 --> 00:12:50,480
uh as a as a example here

00:12:47,839 --> 00:12:51,600
uh where we previously simply checked

00:12:50,480 --> 00:12:55,200
the distance

00:12:51,600 --> 00:12:58,079
now we are doing a mix operation

00:12:55,200 --> 00:12:59,839
using the distance with a multiplier

00:12:58,079 --> 00:13:03,200
because we want a very

00:12:59,839 --> 00:13:06,560
short curve and then

00:13:03,200 --> 00:13:09,200
uh based on the the in this case a

00:13:06,560 --> 00:13:12,240
linear interpolation between

00:13:09,200 --> 00:13:16,000
uh transparent and our and

00:13:12,240 --> 00:13:16,000
our shape color we

00:13:16,160 --> 00:13:20,240
we render the shape which means that at

00:13:19,200 --> 00:13:23,920
some point

00:13:20,240 --> 00:13:27,279
close to the edge rather than having

00:13:23,920 --> 00:13:28,160
a few transparent or a fully colored

00:13:27,279 --> 00:13:31,920
pixel

00:13:28,160 --> 00:13:35,200
we get a pixel that's only

00:13:31,920 --> 00:13:38,480
like half of the color

00:13:35,200 --> 00:13:40,720
which is what effectively anti-aliasing

00:13:38,480 --> 00:13:40,720
is

00:13:41,360 --> 00:13:43,519
so

00:13:45,839 --> 00:13:50,720
that's all nice and everything but

00:13:48,800 --> 00:13:53,199
they're

00:13:50,720 --> 00:13:54,240
of course rendering just circles isn't

00:13:53,199 --> 00:13:56,000
very useful

00:13:54,240 --> 00:13:58,800
unless you really really would like to

00:13:56,000 --> 00:13:58,800
render circles

00:14:00,839 --> 00:14:06,399
so luckily there are many

00:14:04,240 --> 00:14:08,000
shapes that can be expressed as a

00:14:06,399 --> 00:14:11,360
distance field

00:14:08,000 --> 00:14:13,839
and next to that

00:14:11,360 --> 00:14:16,000
there are also many operations that can

00:14:13,839 --> 00:14:19,519
be done on these distance fields

00:14:16,000 --> 00:14:22,720
to give to achieve different results

00:14:19,519 --> 00:14:24,959
as as an example here there's a

00:14:22,720 --> 00:14:28,079
we have the basic transformations

00:14:24,959 --> 00:14:31,279
translate rotate scale

00:14:28,079 --> 00:14:35,440
which are already helpful but then

00:14:31,279 --> 00:14:38,160
there are uh three operations which are

00:14:35,440 --> 00:14:40,959
relate similar to a concept called

00:14:38,160 --> 00:14:40,959
constructive

00:14:41,040 --> 00:14:48,079
solid geometry which

00:14:44,079 --> 00:14:51,279
is a is something that cadd

00:14:48,079 --> 00:14:52,639
uses a lot which allows us to combine

00:14:51,279 --> 00:14:56,399
these shapes

00:14:52,639 --> 00:14:59,680
into different results

00:14:56,399 --> 00:15:02,720
so uh listen here these examples are are

00:14:59,680 --> 00:15:03,839
so union which combines both shapes we

00:15:02,720 --> 00:15:07,199
have a subtract

00:15:03,839 --> 00:15:09,519
where we subtract one shape from another

00:15:07,199 --> 00:15:10,240
leading to a new result and then we have

00:15:09,519 --> 00:15:12,639
intersect

00:15:10,240 --> 00:15:15,360
which provides an intersection between

00:15:12,639 --> 00:15:15,360
two shapes

00:15:19,600 --> 00:15:23,440
and finally we have a few operations

00:15:22,480 --> 00:15:26,399
that are

00:15:23,440 --> 00:15:28,480
unique to sign distance fields uh which

00:15:26,399 --> 00:15:32,079
is annular in this case which

00:15:28,480 --> 00:15:35,600
is um

00:15:32,079 --> 00:15:39,440
which best is is best described as using

00:15:35,600 --> 00:15:43,040
uh uh or outlining the

00:15:39,440 --> 00:15:46,399
current uh distance field we can easily

00:15:43,040 --> 00:15:48,639
round shapes by uh and finally we have

00:15:46,399 --> 00:15:51,759
we can just take the outline

00:15:48,639 --> 00:15:53,839
because wherever the distance is zero

00:15:51,759 --> 00:15:56,160
we know that we're exactly on the edge

00:15:53,839 --> 00:15:58,639
of the shape

00:15:56,160 --> 00:15:59,920
in this example outline and angular

00:15:58,639 --> 00:16:03,199
don't really

00:15:59,920 --> 00:16:05,920
provide different results but outline is

00:16:03,199 --> 00:16:05,920
useful for

00:16:07,279 --> 00:16:11,279
are for expanding for creating different

00:16:08,959 --> 00:16:11,279
shapes

00:16:14,320 --> 00:16:20,839
so we have these this

00:16:17,360 --> 00:16:23,680
technique called distance fields

00:16:20,839 --> 00:16:26,720
for and and

00:16:23,680 --> 00:16:26,720
this is all mice

00:16:27,600 --> 00:16:33,759
from a theory point of view uh but what

00:16:30,399 --> 00:16:33,759
practical use does it have

00:16:34,560 --> 00:16:39,040
well uh this i started with this entire

00:16:38,160 --> 00:16:42,560
thing

00:16:39,040 --> 00:16:45,759
uh about two years ago

00:16:42,560 --> 00:16:46,880
because uh i i had a specific problem to

00:16:45,759 --> 00:16:50,079
solve

00:16:46,880 --> 00:16:53,759
in in a traditional gpu

00:16:50,079 --> 00:16:57,120
rendered way

00:16:53,759 --> 00:17:01,279
you end up rendering a

00:16:57,120 --> 00:17:04,480
circle is actually somewhat tricky

00:17:01,279 --> 00:17:08,319
because your gpu works with

00:17:04,480 --> 00:17:11,039
points and lines between them and

00:17:08,319 --> 00:17:11,520
this means that it doesn't know anything

00:17:11,039 --> 00:17:13,919
like

00:17:11,520 --> 00:17:15,679
curves or anything so this means that if

00:17:13,919 --> 00:17:19,839
you want to render a circle

00:17:15,679 --> 00:17:24,160
you need to approximate this circle

00:17:19,839 --> 00:17:27,199
you need to come up with some way of

00:17:24,160 --> 00:17:30,240
effectively faking the circle

00:17:27,199 --> 00:17:32,400
and this is

00:17:30,240 --> 00:17:33,760
for example what uh what cute quick

00:17:32,400 --> 00:17:36,240
currently does when you're

00:17:33,760 --> 00:17:36,880
you have a rectangle uh with rounded

00:17:36,240 --> 00:17:40,160
corners

00:17:36,880 --> 00:17:41,440
it will use geometry uh to approximate

00:17:40,160 --> 00:17:44,080
the circle

00:17:41,440 --> 00:17:46,000
however if you uh you can actually test

00:17:44,080 --> 00:17:48,240
this out if you have a a

00:17:46,000 --> 00:17:50,240
cute quick rectangle at a very large

00:17:48,240 --> 00:17:52,480
size

00:17:50,240 --> 00:17:53,520
you will actually end up seeing the

00:17:52,480 --> 00:17:57,760
result of this

00:17:53,520 --> 00:17:59,679
approximation and i don't know if it's

00:17:57,760 --> 00:18:02,400
visible in the image but

00:17:59,679 --> 00:18:03,280
you end up with straight edges that

00:18:02,400 --> 00:18:06,480
approximate

00:18:03,280 --> 00:18:10,400
this circle instead of

00:18:06,480 --> 00:18:14,400
an actual circle so

00:18:10,400 --> 00:18:15,520
for my problem or for me this was a

00:18:14,400 --> 00:18:17,840
problem because i

00:18:15,520 --> 00:18:18,720
wanted to render something even a bit

00:18:17,840 --> 00:18:21,840
more complex

00:18:18,720 --> 00:18:21,840
which is pie charts

00:18:22,080 --> 00:18:28,799
and a geo geometric

00:18:25,600 --> 00:18:32,080
geometric approximation of a circle

00:18:28,799 --> 00:18:34,960
is easy enough to do

00:18:32,080 --> 00:18:36,720
for us for an actual circle however if

00:18:34,960 --> 00:18:40,320
you're rendering a pie chart

00:18:36,720 --> 00:18:43,840
you have multiple segments of

00:18:40,320 --> 00:18:46,080
circles are not even full circles uh

00:18:43,840 --> 00:18:48,400
necessarily you could actually have

00:18:46,080 --> 00:18:52,000
segments of a torus

00:18:48,400 --> 00:18:56,160
and that makes that geometric approach

00:18:52,000 --> 00:19:00,240
way way more complex

00:18:56,160 --> 00:19:03,440
whereas if we use design distance fields

00:19:00,240 --> 00:19:06,880
we can suddenly render

00:19:03,440 --> 00:19:11,840
actual circles actual shapes

00:19:06,880 --> 00:19:11,840
without needing any trickery for

00:19:12,000 --> 00:19:15,840
for for for approximations because

00:19:15,039 --> 00:19:18,400
another

00:19:15,840 --> 00:19:19,200
problem with the geometric approach is

00:19:18,400 --> 00:19:22,240
actually

00:19:19,200 --> 00:19:26,400
that those lines are

00:19:22,240 --> 00:19:30,000
by default you will have artifacts

00:19:26,400 --> 00:19:32,480
aliasing artifacts so you need to add

00:19:30,000 --> 00:19:34,000
additional approximations additional

00:19:32,480 --> 00:19:37,200
tricks on top of that

00:19:34,000 --> 00:19:40,240
geometry to

00:19:37,200 --> 00:19:43,600
actually render a nice

00:19:40,240 --> 00:19:47,840
circle whereas our uh

00:19:43,600 --> 00:19:51,440
sdf as seen it it provides a very

00:19:47,840 --> 00:19:55,600
natural way of rendering circles

00:19:51,440 --> 00:19:58,320
so uh this i i discovered this

00:19:55,600 --> 00:19:58,960
while researching this topic and then

00:19:58,320 --> 00:20:02,080
realized

00:19:58,960 --> 00:20:03,360
wait this is this is great for doing pie

00:20:02,080 --> 00:20:06,480
charts

00:20:03,360 --> 00:20:09,520
because we can actually have

00:20:06,480 --> 00:20:10,640
a signed distance field where we have

00:20:09,520 --> 00:20:13,600
each segment

00:20:10,640 --> 00:20:14,720
as its own distance field we render that

00:20:13,600 --> 00:20:17,919
segment

00:20:14,720 --> 00:20:21,840
uh we and then uh

00:20:17,919 --> 00:20:22,400
we have we we need no approximations

00:20:21,840 --> 00:20:25,200
because

00:20:22,400 --> 00:20:26,159
we can feed the shape the data to the

00:20:25,200 --> 00:20:30,000
gpu

00:20:26,159 --> 00:20:33,200
the gpu will go okay uh for each pixel

00:20:30,000 --> 00:20:35,440
is this within the segment yes no uh

00:20:33,200 --> 00:20:36,480
using all the gradients and everything

00:20:35,440 --> 00:20:40,080
and then we can get

00:20:36,480 --> 00:20:44,159
very nice looking pie charts

00:20:40,080 --> 00:20:44,159
fully accelerated on your gpu

00:20:45,520 --> 00:20:51,679
so this uh i i

00:20:49,600 --> 00:20:53,039
experimented with this and this proved

00:20:51,679 --> 00:20:56,080
quite successful

00:20:53,039 --> 00:20:59,760
uh my initial uh uh

00:20:56,080 --> 00:21:02,960
my initial implementation of this

00:20:59,760 --> 00:21:05,280
actually used a number

00:21:02,960 --> 00:21:05,280
of

00:21:06,159 --> 00:21:12,159
actually used a bunch of the

00:21:09,360 --> 00:21:13,360
csg operations that i mentioned before

00:21:12,159 --> 00:21:16,880
because it used

00:21:13,360 --> 00:21:19,679
a circle and then cut away the parts

00:21:16,880 --> 00:21:21,200
that are not so it ended up with a

00:21:19,679 --> 00:21:24,480
segment of a circle

00:21:21,200 --> 00:21:28,000
instead of using the full circle

00:21:24,480 --> 00:21:28,880
later on i found a distance field

00:21:28,000 --> 00:21:33,200
operation

00:21:28,880 --> 00:21:36,960
a distance field function for a

00:21:33,200 --> 00:21:40,320
for a par a part of an arc like this

00:21:36,960 --> 00:21:44,320
so that became unnecessary uh and

00:21:40,320 --> 00:21:47,840
the result would was better that way but

00:21:44,320 --> 00:21:48,240
even the the initial uh implementation

00:21:47,840 --> 00:21:51,120
was

00:21:48,240 --> 00:21:54,320
already better than an approximation in

00:21:51,120 --> 00:21:54,320
geometry would have been

00:21:55,360 --> 00:21:58,799
so using that information from the pie

00:21:57,919 --> 00:22:02,080
chart

00:21:58,799 --> 00:22:04,480
i went on and figured well what if we do

00:22:02,080 --> 00:22:06,559
the same with line charts

00:22:04,480 --> 00:22:08,720
line charts have similar problems you

00:22:06,559 --> 00:22:12,720
have lines that

00:22:08,720 --> 00:22:16,159
lead will have aliasing problems

00:22:12,720 --> 00:22:17,200
if you use geometry for them you want to

00:22:16,159 --> 00:22:20,400
be able to vary

00:22:17,200 --> 00:22:24,240
their thickness so

00:22:20,400 --> 00:22:26,880
you can't just render points

00:22:24,240 --> 00:22:28,880
or render line segments easily because

00:22:26,880 --> 00:22:32,000
you're you need to

00:22:28,880 --> 00:22:33,039
be able to control what these line

00:22:32,000 --> 00:22:36,320
segments look

00:22:33,039 --> 00:22:39,039
so you would need to generate geometry

00:22:36,320 --> 00:22:40,480
for the entire line segments which

00:22:39,039 --> 00:22:43,280
becomes complex

00:22:40,480 --> 00:22:43,280
rather quickly

00:22:44,000 --> 00:22:49,039
that said the the the the the distance

00:22:47,840 --> 00:22:52,000
field behind

00:22:49,039 --> 00:22:54,799
the line chart implementation turned out

00:22:52,000 --> 00:22:58,000
to be a bit more complex as well

00:22:54,799 --> 00:23:01,840
because it's hard

00:22:58,000 --> 00:23:05,840
to or it's it's tricky to make

00:23:01,840 --> 00:23:08,080
a a a set of

00:23:05,840 --> 00:23:08,960
of line segments this way so what i

00:23:08,080 --> 00:23:14,159
ended up doing

00:23:08,960 --> 00:23:14,159
instead is that rather than

00:23:16,720 --> 00:23:22,080
trying to chain a bunch of line segments

00:23:19,760 --> 00:23:23,360
because then you lose information about

00:23:22,080 --> 00:23:26,960
what is

00:23:23,360 --> 00:23:30,159
above or below the line this actually

00:23:26,960 --> 00:23:30,720
renders using a polygon effectively what

00:23:30,159 --> 00:23:33,520
it does

00:23:30,720 --> 00:23:35,760
is there is a polygon that is rendered

00:23:33,520 --> 00:23:35,760
this

00:23:35,840 --> 00:23:42,799
using about this shape

00:23:39,280 --> 00:23:43,200
and then if we need to fill it we can

00:23:42,799 --> 00:23:46,320
just

00:23:43,200 --> 00:23:48,240
fill that entire shape and

00:23:46,320 --> 00:23:50,000
using some of the other operations like

00:23:48,240 --> 00:23:53,360
the annular and outline

00:23:50,000 --> 00:23:57,520
we can get the just the line

00:23:53,360 --> 00:23:57,520
on the side and render that as well

00:24:02,159 --> 00:24:07,520
so this is all uh this is how it's all

00:24:05,360 --> 00:24:10,480
been implemented indicate quick charts

00:24:07,520 --> 00:24:11,760
uh framework and there's a bunch of

00:24:10,480 --> 00:24:14,640
other features there

00:24:11,760 --> 00:24:15,120
that i'm not going to into right now

00:24:14,640 --> 00:24:19,200
because

00:24:15,120 --> 00:24:22,400
those aren't related to distance fields

00:24:19,200 --> 00:24:25,520
the distance fields do power uh two of

00:24:22,400 --> 00:24:30,720
the main chart types though

00:24:25,520 --> 00:24:30,720
another use case for distance fields

00:24:31,120 --> 00:24:37,679
came later uh kirigami

00:24:34,480 --> 00:24:40,559
has a concept called cards uh

00:24:37,679 --> 00:24:41,520
they used to look approximately like

00:24:40,559 --> 00:24:44,559
this

00:24:41,520 --> 00:24:48,000
um which is okay

00:24:44,559 --> 00:24:50,159
visually but there's actually an a bit

00:24:48,000 --> 00:24:53,200
of an element missing here

00:24:50,159 --> 00:24:55,440
because these use sharp corners

00:24:53,200 --> 00:24:57,840
whereas a lot of elements within the

00:24:55,440 --> 00:25:00,000
breeze style and within our

00:24:57,840 --> 00:25:02,480
our general facial theming have rounded

00:25:00,000 --> 00:25:02,480
corners

00:25:03,279 --> 00:25:07,760
but there was another problem with these

00:25:05,360 --> 00:25:09,360
because their implementation was rather

00:25:07,760 --> 00:25:11,919
suboptimal

00:25:09,360 --> 00:25:13,120
it's not you can't see it from the

00:25:11,919 --> 00:25:15,279
visual result

00:25:13,120 --> 00:25:17,200
but in in the background what this did

00:25:15,279 --> 00:25:21,200
was actually create

00:25:17,200 --> 00:25:24,400
uh separate items for each shadowed edge

00:25:21,200 --> 00:25:27,039
so there is an

00:25:24,400 --> 00:25:28,880
an item here for the left edge one for

00:25:27,039 --> 00:25:32,799
the bottom edge one for the

00:25:28,880 --> 00:25:36,320
left bottom corner and all etc

00:25:32,799 --> 00:25:38,400
and that makes the

00:25:36,320 --> 00:25:41,120
uh implementation of this rather

00:25:38,400 --> 00:25:41,120
expensive

00:25:41,200 --> 00:25:46,960
so i i spent some time thinking

00:25:44,640 --> 00:25:49,200
what if i we could replace this entire

00:25:46,960 --> 00:25:54,559
background thing with all the items

00:25:49,200 --> 00:25:54,559
with just a single item to render this

00:25:54,840 --> 00:25:59,039
background

00:25:56,720 --> 00:26:01,200
and that's how i created an item that's

00:25:59,039 --> 00:26:04,240
now called shadowed rectangle

00:26:01,200 --> 00:26:09,120
which is a distance field

00:26:04,240 --> 00:26:12,240
of a rectangle with rounded corners

00:26:09,120 --> 00:26:14,960
that also includes

00:26:12,240 --> 00:26:14,960
a shadow

00:26:18,080 --> 00:26:23,840
which meant that i had one item

00:26:22,080 --> 00:26:26,720
that would allow me to render this

00:26:23,840 --> 00:26:30,799
entire background including its shadow

00:26:26,720 --> 00:26:36,080
without needing any other items and

00:26:30,799 --> 00:26:39,120
with a very an a fairly simple

00:26:36,080 --> 00:26:42,480
uh implementation in the shader actually

00:26:39,120 --> 00:26:44,720
because it's you you need the distance

00:26:42,480 --> 00:26:47,039
field for the rectangle but after that

00:26:44,720 --> 00:26:49,360
most of the other effects are simple

00:26:47,039 --> 00:26:51,200
operations on the distance field

00:26:49,360 --> 00:26:53,840
or on the distance that you get from the

00:26:51,200 --> 00:26:53,840
distance field

00:26:54,000 --> 00:27:01,760
so this allows this also

00:26:57,840 --> 00:27:04,480
allows extra features that current

00:27:01,760 --> 00:27:05,200
quick rectangle doesn't expose like

00:27:04,480 --> 00:27:08,480
having

00:27:05,200 --> 00:27:10,960
different radio radiuses for different

00:27:08,480 --> 00:27:10,960
corners

00:27:12,240 --> 00:27:16,480
well with this i could replace the

00:27:14,480 --> 00:27:17,600
background of the cards however there

00:27:16,480 --> 00:27:21,840
was a

00:27:17,600 --> 00:27:21,840
remaining problem because

00:27:22,960 --> 00:27:26,399
some of the cards have an image in the

00:27:24,880 --> 00:27:30,080
top and

00:27:26,399 --> 00:27:30,799
if we render the background with rounded

00:27:30,080 --> 00:27:32,799
corners

00:27:30,799 --> 00:27:34,399
that's all fine but if we just place an

00:27:32,799 --> 00:27:36,960
image on top of it

00:27:34,399 --> 00:27:37,760
either we lose the rounded corners on

00:27:36,960 --> 00:27:41,679
top

00:27:37,760 --> 00:27:41,679
or we

00:27:42,080 --> 00:27:48,240
we end up with some

00:27:45,679 --> 00:27:50,720
rather expensive needing to write some

00:27:48,240 --> 00:27:53,760
rather expensive

00:27:50,720 --> 00:27:55,760
code to cut off these corners of this

00:27:53,760 --> 00:27:58,960
image

00:27:55,760 --> 00:28:00,159
luckily again the the distance field

00:27:58,960 --> 00:28:03,200
implementation

00:28:00,159 --> 00:28:06,799
provides a fairly

00:28:03,200 --> 00:28:10,080
simple solution here

00:28:06,799 --> 00:28:13,200
because what we can do

00:28:10,080 --> 00:28:14,880
is rather than fill the distance fields

00:28:13,200 --> 00:28:17,679
with a solid color

00:28:14,880 --> 00:28:18,399
we can query a texture get a color from

00:28:17,679 --> 00:28:21,840
the texture

00:28:18,399 --> 00:28:25,600
and use that as the color if

00:28:21,840 --> 00:28:28,159
of the shape in one if we're inside the

00:28:25,600 --> 00:28:28,159
distance

00:28:28,720 --> 00:28:34,960
which means that rather than needing to

00:28:32,000 --> 00:28:35,679
uh do a whole complex set of operations

00:28:34,960 --> 00:28:39,279
to

00:28:35,679 --> 00:28:41,520
render a shape and query

00:28:39,279 --> 00:28:42,720
use that as an opacity mask to cut off

00:28:41,520 --> 00:28:47,120
these corners

00:28:42,720 --> 00:28:50,320
we can just use almost the same logic

00:28:47,120 --> 00:28:55,440
as the rectangle previously used

00:28:50,320 --> 00:28:55,440
and then use that to render a texture

00:28:56,840 --> 00:29:01,440
instead

00:28:58,240 --> 00:29:05,360
with that i managed i was able to

00:29:01,440 --> 00:29:08,399
recreate or replace the cards

00:29:05,360 --> 00:29:11,600
with a new background that used the

00:29:08,399 --> 00:29:14,799
shadowed rectangle and used the shadowed

00:29:11,600 --> 00:29:15,520
texture implementation to get rounded

00:29:14,799 --> 00:29:19,200
corners

00:29:15,520 --> 00:29:22,399
and also a slight and

00:29:19,200 --> 00:29:25,200
a new updated design for the cards

00:29:22,399 --> 00:29:25,600
and just generally looked a lot nicer

00:29:25,200 --> 00:29:29,039
than

00:29:25,600 --> 00:29:29,039
what we had before that

00:29:29,840 --> 00:29:35,840
and well both of these elements

00:29:32,960 --> 00:29:37,120
were very important because eventually

00:29:35,840 --> 00:29:39,520
what i did

00:29:37,120 --> 00:29:40,159
or what i was working on was a new

00:29:39,520 --> 00:29:43,200
version

00:29:40,159 --> 00:29:46,320
of our new system monitor for plasma

00:29:43,200 --> 00:29:49,679
and this system monitor is

00:29:46,320 --> 00:29:51,679
very heavy on charts because almost all

00:29:49,679 --> 00:29:55,279
the data sources you want to

00:29:51,679 --> 00:29:55,679
render as a chart so you don't want to

00:29:55,279 --> 00:29:58,720
be

00:29:55,679 --> 00:30:00,320
to have to relo constantly fall back on

00:29:58,720 --> 00:30:04,320
cpu rendering

00:30:00,320 --> 00:30:07,520
um you instead want to make sure that

00:30:04,320 --> 00:30:12,000
your charts can update

00:30:07,520 --> 00:30:13,840
at a smooth frame rate ideally

00:30:12,000 --> 00:30:16,480
whatever your refresh rate of your

00:30:13,840 --> 00:30:16,480
monitor is

00:30:16,880 --> 00:30:23,840
so that's what i

00:30:20,480 --> 00:30:26,960
where i put or what i did to

00:30:23,840 --> 00:30:26,960
make this all possible

00:30:27,120 --> 00:30:31,840
the pie charts are made are provided by

00:30:30,640 --> 00:30:33,840
quick charts

00:30:31,840 --> 00:30:34,880
the line charts are provided by quick

00:30:33,840 --> 00:30:37,600
charts

00:30:34,880 --> 00:30:38,799
and both use design distance fields for

00:30:37,600 --> 00:30:41,840
rendering

00:30:38,799 --> 00:30:43,840
and then the cards are provided by

00:30:41,840 --> 00:30:45,520
kirigami now

00:30:43,840 --> 00:30:48,720
but also use distance fields for

00:30:45,520 --> 00:30:48,720
rendering so

00:30:48,840 --> 00:30:52,880
approximately eighty percent of what's

00:30:51,279 --> 00:30:54,960
being rendered by

00:30:52,880 --> 00:31:04,159
plasma system monitor here is being

00:30:54,960 --> 00:31:08,000
rendered through distance fields

00:31:04,159 --> 00:31:08,960
uh well and that's where i want to end

00:31:08,000 --> 00:31:12,320
this talk

00:31:08,960 --> 00:31:17,120
uh i want to have a special

00:31:12,320 --> 00:31:19,519
say special thanks to uh i'm going to

00:31:17,120 --> 00:31:20,720
fiddle on the pronunciation but inigo

00:31:19,519 --> 00:31:23,840
quires

00:31:20,720 --> 00:31:25,760
who has a whole set of articles about

00:31:23,840 --> 00:31:29,279
distance fields on

00:31:25,760 --> 00:31:33,840
uh on his website and which is what

00:31:29,279 --> 00:31:33,840
most of this work has been based on

00:31:37,279 --> 00:31:42,720
any questions well yes thank you so much

00:31:40,799 --> 00:31:46,559
for your appreciation

00:31:42,720 --> 00:31:50,399
we do have a few questions

00:31:46,559 --> 00:31:50,399
um the first being

00:31:51,679 --> 00:31:57,519
might be misspelling but is this shader

00:31:55,519 --> 00:32:00,799
approach

00:31:57,519 --> 00:32:06,080
fully portable to cute's new rhi

00:32:00,799 --> 00:32:06,080
api or where do we have to be careful

00:32:06,799 --> 00:32:14,399
so cute rhi

00:32:10,880 --> 00:32:17,360
in qt6 requires

00:32:14,399 --> 00:32:18,159
using cute shader tool which wasn't

00:32:17,360 --> 00:32:21,679
available

00:32:18,159 --> 00:32:25,039
until q6 was released i haven't done

00:32:21,679 --> 00:32:28,880
actual parting yet but

00:32:25,039 --> 00:32:31,679
the shaders all that's needed is porting

00:32:28,880 --> 00:32:33,120
the shaders to vulcan dlsl instead of

00:32:31,679 --> 00:32:35,679
opengl sl

00:32:33,120 --> 00:32:36,960
and then building this with uh cute

00:32:35,679 --> 00:32:40,320
shader tools

00:32:36,960 --> 00:32:42,399
and then we should are

00:32:40,320 --> 00:32:45,679
as far as i know we should be able to

00:32:42,399 --> 00:32:45,679
build using q6

00:32:47,200 --> 00:32:51,039
so as far as i know it's it's fully

00:32:49,360 --> 00:32:55,440
portable and there isn't

00:32:51,039 --> 00:32:58,640
any uh any real limitations there

00:32:55,440 --> 00:33:00,640
in fact uh cute six rhi

00:32:58,640 --> 00:33:03,039
actually makes things easier because

00:33:00,640 --> 00:33:04,240
right now we have to maintain a separate

00:33:03,039 --> 00:33:07,600
set of shaders for

00:33:04,240 --> 00:33:10,880
core profiles and a whole bunch of other

00:33:07,600 --> 00:33:12,559
tweaks just to make sure that we can

00:33:10,880 --> 00:33:16,080
support a various set of

00:33:12,559 --> 00:33:17,840
opengl apis whereas in qt6

00:33:16,080 --> 00:33:20,159
shader tools will take care of all that

00:33:17,840 --> 00:33:20,159
for us

00:33:20,720 --> 00:33:27,840
all right the next question

00:33:24,640 --> 00:33:31,679
can we do these verbs

00:33:27,840 --> 00:33:34,240
with signed distance fields the j curves

00:33:31,679 --> 00:33:36,640
uh yes there is a distance field for bj

00:33:34,240 --> 00:33:36,640
curves

00:33:36,840 --> 00:33:42,159
um the

00:33:39,039 --> 00:33:45,120
that said uh this those

00:33:42,159 --> 00:33:46,240
implementations get uh expensive rather

00:33:45,120 --> 00:33:50,000
quickly

00:33:46,240 --> 00:33:53,440
uh so it depends a bit on how many uh

00:33:50,000 --> 00:33:57,919
many of these jackers you want to render

00:33:53,440 --> 00:33:57,919
whether that's feasible or not

00:34:00,080 --> 00:34:04,399
alternatively what i do in quick charts

00:34:03,279 --> 00:34:06,720
for

00:34:04,399 --> 00:34:07,600
the line chart smoothing is that

00:34:06,720 --> 00:34:10,960
actually the

00:34:07,600 --> 00:34:14,879
the the processing of the

00:34:10,960 --> 00:34:17,919
smoothing is done on the cpu and then

00:34:14,879 --> 00:34:21,839
this is rendered on the gpu as

00:34:17,919 --> 00:34:21,839
individual line segments

00:34:23,359 --> 00:34:30,560
one final question for you

00:34:27,119 --> 00:34:33,839
one of cubed quick's text renderers

00:34:30,560 --> 00:34:37,679
is also sdf based

00:34:33,839 --> 00:34:40,399
inspired by valve sig graph paper

00:34:37,679 --> 00:34:41,200
that popularized the technique is this

00:34:40,399 --> 00:34:44,240
usage

00:34:41,200 --> 00:34:48,879
broadly similar or has the

00:34:44,240 --> 00:34:52,240
sdf state of the art evolved

00:34:48,879 --> 00:34:54,800
so uh there i do know that

00:34:52,240 --> 00:34:55,839
uh the distance field rendering of

00:34:54,800 --> 00:34:59,040
cute's text

00:34:55,839 --> 00:35:03,040
is indeed also based on this uh

00:34:59,040 --> 00:35:03,040
the main difference there is that

00:35:03,119 --> 00:35:08,560
the text rendering uses pre-calculated

00:35:06,480 --> 00:35:12,079
values for the distance

00:35:08,560 --> 00:35:14,800
it will generate a texture

00:35:12,079 --> 00:35:17,839
where that encodes the distance for each

00:35:14,800 --> 00:35:17,839
point in the texture

00:35:18,720 --> 00:35:25,359
which is mostly

00:35:22,079 --> 00:35:27,760
because the actual text

00:35:25,359 --> 00:35:28,880
shapes would be way too complex to

00:35:27,760 --> 00:35:32,720
render

00:35:28,880 --> 00:35:35,119
directly on the gpu because

00:35:32,720 --> 00:35:37,760
you have all these features of of uh

00:35:35,119 --> 00:35:40,480
fonts that you need to take care of

00:35:37,760 --> 00:35:43,040
and as basically there are very a large

00:35:40,480 --> 00:35:46,240
collection of very complex bj parts

00:35:43,040 --> 00:35:49,920
which as i said previously you can do

00:35:46,240 --> 00:35:49,920
but it gets expensive

00:35:50,800 --> 00:35:58,320
so they're mostly similar

00:35:54,400 --> 00:36:00,480
with the the side note that

00:35:58,320 --> 00:36:02,560
distance field text is using

00:36:00,480 --> 00:36:05,599
pre-computed distance fields

00:36:02,560 --> 00:36:09,040
whereas what we're doing here is

00:36:05,599 --> 00:36:12,079
using the actual distance field function

00:36:09,040 --> 00:36:14,320
for for rendering

00:36:12,079 --> 00:36:22,880
which allows us to scale things much

00:36:14,320 --> 00:36:22,880

YouTube URL: https://www.youtube.com/watch?v=GfGys8WogZE


