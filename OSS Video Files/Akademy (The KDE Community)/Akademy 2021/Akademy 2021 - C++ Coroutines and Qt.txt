Title: Akademy 2021 - C++ Coroutines and Qt
Publication date: 2021-06-29
Playlist: Akademy 2021
Description: 
	By Daniel VrÃ¡til
Coroutines are one of the brand new features in C++20. In this talk I will introduce how coroutines in C++ work and I will present QCoro, my experimental library that makes it possible to use C++ coroutines with certain Qt operations, like DBus calls, network replies etc.
Captions: 
	00:00:01,130 --> 00:00:08,600
[Music]

00:00:13,679 --> 00:00:16,720
okay

00:00:14,080 --> 00:00:17,359
it's time so and now i'd like to

00:00:16,720 --> 00:00:18,960
introduce

00:00:17,359 --> 00:00:20,720
our next guest danville tills and

00:00:18,960 --> 00:00:22,960
everyone give a big round of applause

00:00:20,720 --> 00:00:24,080
dan's been a maintainer in kd for ages

00:00:22,960 --> 00:00:26,960
working

00:00:24,080 --> 00:00:28,840
on akanadi pyramid all sorts of places

00:00:26,960 --> 00:00:31,119
throughout the stack

00:00:28,840 --> 00:00:32,640
and now they're going to talk to us

00:00:31,119 --> 00:00:36,239
about sleepless plus curve routines

00:00:32,640 --> 00:00:38,559
and cute so hello

00:00:36,239 --> 00:00:40,320
thank you uh for the introduction david

00:00:38,559 --> 00:00:42,800
uh so my name is daniel i've

00:00:40,320 --> 00:00:43,360
been working on with cp's passing kitty

00:00:42,800 --> 00:00:46,399
for

00:00:43,360 --> 00:00:48,320
almost over a decade now and

00:00:46,399 --> 00:00:49,600
uh well lately i found interest in

00:00:48,320 --> 00:00:50,960
digging into interesting

00:00:49,600 --> 00:00:53,280
new features in the seaport's bus

00:00:50,960 --> 00:00:56,079
language so that's why i'm

00:00:53,280 --> 00:00:58,399
here today talking about coroutines and

00:00:56,079 --> 00:01:01,280
about cute uh

00:00:58,399 --> 00:01:03,120
word of warning before i begin uh

00:01:01,280 --> 00:01:03,600
curtins are a bit of complex topic to

00:01:03,120 --> 00:01:05,920
explain

00:01:03,600 --> 00:01:08,080
so uh there's a lot of things to talk

00:01:05,920 --> 00:01:10,159
about and not enough time and

00:01:08,080 --> 00:01:12,159
uh also there is a lot of code in this

00:01:10,159 --> 00:01:14,560
presentation so you have been warned

00:01:12,159 --> 00:01:15,840
i'm not kidding the first slide already

00:01:14,560 --> 00:01:17,840
if i can switch

00:01:15,840 --> 00:01:19,360
yes i can switch the first slide already

00:01:17,840 --> 00:01:21,040
is a piece of code

00:01:19,360 --> 00:01:23,840
because i think that's the best way how

00:01:21,040 --> 00:01:25,600
to explain what coroutines actually give

00:01:23,840 --> 00:01:28,799
us and what they are useful for

00:01:25,600 --> 00:01:29,520
so uh let's get into it uh what do we

00:01:28,799 --> 00:01:32,799
have here

00:01:29,520 --> 00:01:35,040
so um we have a fun we have a

00:01:32,799 --> 00:01:36,960
simple regular function as you know it's

00:01:35,040 --> 00:01:39,680
a member function called get title

00:01:36,960 --> 00:01:40,159
that returns a q string what does the

00:01:39,680 --> 00:01:42,320
function

00:01:40,159 --> 00:01:44,079
do well it creates a d bus interface so

00:01:42,320 --> 00:01:44,880
that can talk to some remote service

00:01:44,079 --> 00:01:47,200
somewhere

00:01:44,880 --> 00:01:49,759
uh else well also in your computer but

00:01:47,200 --> 00:01:52,560
still it's local so

00:01:49,759 --> 00:01:53,759
anyway so we have the interface now what

00:01:52,560 --> 00:01:56,000
we do is we do

00:01:53,759 --> 00:01:57,680
we call player.call so we call some

00:01:56,000 --> 00:01:59,200
remote function called title in the

00:01:57,680 --> 00:02:02,799
remote service

00:01:59,200 --> 00:02:05,040
and then we just uh convert the response

00:02:02,799 --> 00:02:06,240
to qdbus reply because that's how we can

00:02:05,040 --> 00:02:08,479
extract the

00:02:06,240 --> 00:02:09,280
the response which is type of type q

00:02:08,479 --> 00:02:11,200
string

00:02:09,280 --> 00:02:13,599
and then well then there's this thing

00:02:11,200 --> 00:02:14,560
right so one thing is we have qd bus

00:02:13,599 --> 00:02:15,920
reply on one

00:02:14,560 --> 00:02:17,360
side and then we have q string on the

00:02:15,920 --> 00:02:18,879
other how does the conversion happen

00:02:17,360 --> 00:02:21,120
well qd but reply

00:02:18,879 --> 00:02:22,879
does this magically but the thing is now

00:02:21,120 --> 00:02:24,959
i just said well we just did a remote

00:02:22,879 --> 00:02:27,920
call to a remote service

00:02:24,959 --> 00:02:29,280
so we can't possibly have the q string

00:02:27,920 --> 00:02:32,319
already available right

00:02:29,280 --> 00:02:34,640
it's a d bus right uh that thing

00:02:32,319 --> 00:02:36,080
does lots of things so if you do a d bus

00:02:34,640 --> 00:02:38,160
call here in the player

00:02:36,080 --> 00:02:40,080
dot call what happens is your

00:02:38,160 --> 00:02:41,680
applications needs to create a

00:02:40,080 --> 00:02:43,440
message send it to the debus demon the

00:02:41,680 --> 00:02:44,959
demon's demon must forward it to the

00:02:43,440 --> 00:02:46,879
actual service that you want to talk to

00:02:44,959 --> 00:02:48,720
the service must process the request

00:02:46,879 --> 00:02:50,319
calculate the response send the response

00:02:48,720 --> 00:02:51,599
back to the demon that demon must

00:02:50,319 --> 00:02:52,160
forward the response back to you you

00:02:51,599 --> 00:02:53,840
need to

00:02:52,160 --> 00:02:55,599
process it and then finally you might

00:02:53,840 --> 00:02:58,480
have the q string that you wanted

00:02:55,599 --> 00:03:00,319
right this all takes time in most cases

00:02:58,480 --> 00:03:02,319
you will just get away with doing this

00:03:00,319 --> 00:03:04,800
blocking call because what this equal

00:03:02,319 --> 00:03:06,319
sign does well in this case

00:03:04,800 --> 00:03:07,760
the operation behind that is when

00:03:06,319 --> 00:03:08,800
extracting the the string from the

00:03:07,760 --> 00:03:11,200
keyboard reply

00:03:08,800 --> 00:03:12,000
it will have to wait blocking it will

00:03:11,200 --> 00:03:14,959
have to block

00:03:12,000 --> 00:03:16,640
the main thread and wait for the for the

00:03:14,959 --> 00:03:18,159
response to arrive so that you can

00:03:16,640 --> 00:03:21,440
extract the q string and

00:03:18,159 --> 00:03:24,239
store it in the variable right so

00:03:21,440 --> 00:03:25,280
uh in most cases this will work just

00:03:24,239 --> 00:03:27,280
fine right it will

00:03:25,280 --> 00:03:29,040
take just a split of second users will

00:03:27,280 --> 00:03:30,319
not notice that you just did a blocking

00:03:29,040 --> 00:03:31,599
call in your main thread

00:03:30,319 --> 00:03:34,000
the application will still seem

00:03:31,599 --> 00:03:36,159
responsive except when you are

00:03:34,000 --> 00:03:38,000
presenting your awesome application in

00:03:36,159 --> 00:03:39,200
front of a huge crowd of 200 people and

00:03:38,000 --> 00:03:40,319
your boss is looking at you and then

00:03:39,200 --> 00:03:41,760
suddenly you are

00:03:40,319 --> 00:03:43,840
standing in front of a screen and your

00:03:41,760 --> 00:03:45,760
application is frozen for 20 seconds

00:03:43,840 --> 00:03:47,680
because the remote service has scratched

00:03:45,760 --> 00:03:49,760
or is not responding for some reason

00:03:47,680 --> 00:03:51,200
and now your application is doing a

00:03:49,760 --> 00:03:53,040
blocking call so it's blocked it's

00:03:51,200 --> 00:03:53,840
waiting for the debuss timeout to kick

00:03:53,040 --> 00:03:56,640
in and

00:03:53,840 --> 00:03:56,959
return an error instead of title so you

00:03:56,640 --> 00:03:59,360
see

00:03:56,959 --> 00:04:01,200
doing blocking calls in the main thread

00:03:59,360 --> 00:04:03,920
is not a good idea

00:04:01,200 --> 00:04:04,640
so how can we fix this um well one

00:04:03,920 --> 00:04:07,439
option

00:04:04,640 --> 00:04:08,480
is we could do player dot call with

00:04:07,439 --> 00:04:11,840
callback

00:04:08,480 --> 00:04:13,760
which would actually allow us to pass a

00:04:11,840 --> 00:04:15,360
callback that qt would eventually call

00:04:13,760 --> 00:04:18,239
when uh

00:04:15,360 --> 00:04:18,959
uh it receives the response this is a

00:04:18,239 --> 00:04:22,400
problem though

00:04:18,959 --> 00:04:23,520
the callback in order to be

00:04:22,400 --> 00:04:25,440
then we would need to change the

00:04:23,520 --> 00:04:25,840
signature of the get title function

00:04:25,440 --> 00:04:28,080
right

00:04:25,840 --> 00:04:29,120
it would no longer return q string it

00:04:28,080 --> 00:04:30,960
would be void

00:04:29,120 --> 00:04:32,240
and instead we would have to take some

00:04:30,960 --> 00:04:34,639
uh

00:04:32,240 --> 00:04:36,639
uh probably another callback from the

00:04:34,639 --> 00:04:39,040
caller that we would then call with the

00:04:36,639 --> 00:04:40,320
actual uh q string that we got from the

00:04:39,040 --> 00:04:42,240
remote service

00:04:40,320 --> 00:04:44,320
but unlikely the caller might need to

00:04:42,240 --> 00:04:45,840
adjust their signature as well to take

00:04:44,320 --> 00:04:48,560
call back from their caller so that they

00:04:45,840 --> 00:04:51,600
can propagate the response right so this

00:04:48,560 --> 00:04:53,199
do using a call with callback or or q

00:04:51,600 --> 00:04:54,639
debuzz pending call washer which is a

00:04:53,199 --> 00:04:55,600
really long name for a really simple

00:04:54,639 --> 00:04:58,479
class that

00:04:55,600 --> 00:04:59,680
also does just wait uh waiting for for a

00:04:58,479 --> 00:05:01,680
debuff reply

00:04:59,680 --> 00:05:03,360
in both those cases you would need to

00:05:01,680 --> 00:05:05,520
fundamentally change your api

00:05:03,360 --> 00:05:06,560
change your design and it would

00:05:05,520 --> 00:05:08,720
propagate to

00:05:06,560 --> 00:05:11,120
more layers of your of your application

00:05:08,720 --> 00:05:13,440
probably uh so that's not

00:05:11,120 --> 00:05:15,440
really cool right just because of this

00:05:13,440 --> 00:05:15,759
simple debus call we don't want to have

00:05:15,440 --> 00:05:20,000
to

00:05:15,759 --> 00:05:21,600
engineer or enter api so

00:05:20,000 --> 00:05:23,840
what are your options well one thing

00:05:21,600 --> 00:05:26,320
that you could do is you could create a

00:05:23,840 --> 00:05:28,560
nested q event loop inside this function

00:05:26,320 --> 00:05:30,639
and wait for the reply to arrive then

00:05:28,560 --> 00:05:32,479
you stop the event loop and you return

00:05:30,639 --> 00:05:34,800
so the signature of the function doesn't

00:05:32,479 --> 00:05:36,880
change the function still looks like

00:05:34,800 --> 00:05:38,960
it's not blocking

00:05:36,880 --> 00:05:40,400
it actually doesn't block your ui thread

00:05:38,960 --> 00:05:42,479
because the event loop will be running

00:05:40,400 --> 00:05:44,400
nested but then using nested event loops

00:05:42,479 --> 00:05:46,560
that's not that's not a good idea really

00:05:44,400 --> 00:05:49,360
right don't run nasty event loops

00:05:46,560 --> 00:05:49,680
especially if you're writing libraries

00:05:49,360 --> 00:05:52,639
so

00:05:49,680 --> 00:05:54,960
uh what are the options well let's let's

00:05:52,639 --> 00:05:56,880
see if core routines can help

00:05:54,960 --> 00:05:58,639
so this is the same function except it's

00:05:56,880 --> 00:06:01,759
a currently note

00:05:58,639 --> 00:06:03,680
uh let's see what has changed so

00:06:01,759 --> 00:06:05,280
there are three things that have changed

00:06:03,680 --> 00:06:06,240
from the previous version first is the

00:06:05,280 --> 00:06:08,639
return type

00:06:06,240 --> 00:06:09,360
the return type now is qcoral task q

00:06:08,639 --> 00:06:11,600
string

00:06:09,360 --> 00:06:12,800
uh let's not bother ourselves with what

00:06:11,600 --> 00:06:14,560
the queue color is

00:06:12,800 --> 00:06:16,720
or what the task is just think that it's

00:06:14,560 --> 00:06:17,600
a it's a return type that represents

00:06:16,720 --> 00:06:20,319
some sort of a

00:06:17,600 --> 00:06:22,000
asynchronous pending operation right

00:06:20,319 --> 00:06:23,039
then we have the call weight keyword

00:06:22,000 --> 00:06:25,039
which is

00:06:23,039 --> 00:06:26,479
the the main thing here the calculate

00:06:25,039 --> 00:06:30,000
keyword what it does

00:06:26,479 --> 00:06:32,639
it uh and then i'll get to that

00:06:30,000 --> 00:06:34,160
we have co-return as well uh we have

00:06:32,639 --> 00:06:35,199
co-weight and corrector and co-weight

00:06:34,160 --> 00:06:37,120
will wait

00:06:35,199 --> 00:06:38,720
for the reply to arrive i'll dig into

00:06:37,120 --> 00:06:40,319
that later and co-return that's

00:06:38,720 --> 00:06:41,440
basically just like return except for

00:06:40,319 --> 00:06:43,199
corrupting

00:06:41,440 --> 00:06:44,960
uh the reason we cannot use regular

00:06:43,199 --> 00:06:46,560
return is because title is q

00:06:44,960 --> 00:06:48,319
string but the return type of our

00:06:46,560 --> 00:06:50,880
function is something else so that

00:06:48,319 --> 00:06:52,639
wouldn't match so in fact what corrector

00:06:50,880 --> 00:06:55,199
does is it sort of

00:06:52,639 --> 00:06:56,479
calls something like task dot set return

00:06:55,199 --> 00:06:59,520
value or something like that

00:06:56,479 --> 00:07:01,520
and passes in the title anyway look at

00:06:59,520 --> 00:07:04,720
the code weight keyword

00:07:01,520 --> 00:07:06,880
so in this case what we do is we do the

00:07:04,720 --> 00:07:09,919
regulator debuss code like we did before

00:07:06,880 --> 00:07:11,840
we convert it to qdbus reply and then we

00:07:09,919 --> 00:07:13,360
pass the qb plus reply to the code

00:07:11,840 --> 00:07:14,960
weight keyword now what does the

00:07:13,360 --> 00:07:18,240
codewave keyword do

00:07:14,960 --> 00:07:18,960
the collate keyword uh will trigger a

00:07:18,240 --> 00:07:20,560
bunch of code

00:07:18,960 --> 00:07:22,400
that's hidden behind that partially

00:07:20,560 --> 00:07:23,120
generated by compiler partially provided

00:07:22,400 --> 00:07:26,319
by the current

00:07:23,120 --> 00:07:27,840
library developer in this case me so

00:07:26,319 --> 00:07:28,240
what the coldweight keyboard it will

00:07:27,840 --> 00:07:30,880
look

00:07:28,240 --> 00:07:32,800
at the qtbus reply and it will say huh

00:07:30,880 --> 00:07:34,880
the cutie bus reply is not finished yet

00:07:32,800 --> 00:07:36,880
i don't have the result yet so what it

00:07:34,880 --> 00:07:38,960
will do is it will suspend

00:07:36,880 --> 00:07:40,080
the core routine suspending the core

00:07:38,960 --> 00:07:42,479
routine means

00:07:40,080 --> 00:07:44,800
that it will take snapshot of all the

00:07:42,479 --> 00:07:47,120
local states so all the local variables

00:07:44,800 --> 00:07:48,000
and an instruction pointer and some

00:07:47,120 --> 00:07:49,440
other stuff

00:07:48,000 --> 00:07:51,120
it will take the snapshot and save it

00:07:49,440 --> 00:07:54,240
somewhere in the memory

00:07:51,120 --> 00:07:57,520
and then then it will return

00:07:54,240 --> 00:07:59,039
to the color of this function so even

00:07:57,520 --> 00:08:00,479
though the function has not finished yet

00:07:59,039 --> 00:08:03,039
it hasn't reached the end

00:08:00,479 --> 00:08:03,520
we are already returning to the caller

00:08:03,039 --> 00:08:05,360
and

00:08:03,520 --> 00:08:06,800
saving the intermediate state somewhere

00:08:05,360 --> 00:08:08,240
in the memory

00:08:06,800 --> 00:08:10,479
so now let's look at what the color

00:08:08,240 --> 00:08:11,759
might look like you might have a color

00:08:10,479 --> 00:08:13,759
that looks like this

00:08:11,759 --> 00:08:15,360
it's a simple function called player

00:08:13,759 --> 00:08:17,199
widget update

00:08:15,360 --> 00:08:19,520
and the player widget update what it

00:08:17,199 --> 00:08:20,879
does it calls the remote player against

00:08:19,520 --> 00:08:22,720
title

00:08:20,879 --> 00:08:24,720
and which gets the type which should get

00:08:22,720 --> 00:08:28,400
the title using the

00:08:24,720 --> 00:08:30,240
curtains or it's occurring right and

00:08:28,400 --> 00:08:31,599
we know that the core routine so it

00:08:30,240 --> 00:08:33,680
might return

00:08:31,599 --> 00:08:35,519
early right we know that it might return

00:08:33,680 --> 00:08:36,479
early because the debuff response is not

00:08:35,519 --> 00:08:38,399
ready but then we

00:08:36,479 --> 00:08:40,240
need we want the response here we want

00:08:38,399 --> 00:08:44,159
the title so we need to

00:08:40,240 --> 00:08:46,160
await again for that coroutine to finish

00:08:44,159 --> 00:08:47,760
so we have like two nested core routines

00:08:46,160 --> 00:08:48,720
so what happens when we call remote

00:08:47,760 --> 00:08:51,279
player get title

00:08:48,720 --> 00:08:52,080
it will get suspended it will return the

00:08:51,279 --> 00:08:54,399
task

00:08:52,080 --> 00:08:55,279
the cue corrupt task in some unfinished

00:08:54,399 --> 00:08:58,320
state

00:08:55,279 --> 00:08:59,360
and the koawait keyword here this

00:08:58,320 --> 00:09:00,959
codeweight keyword

00:08:59,360 --> 00:09:02,720
will look at the task and we'll say well

00:09:00,959 --> 00:09:04,080
the task is not finished so i will just

00:09:02,720 --> 00:09:06,320
suspend this routine

00:09:04,080 --> 00:09:08,320
and return to the caller and then the

00:09:06,320 --> 00:09:09,839
caller might be as welcoming this

00:09:08,320 --> 00:09:10,240
couradine and so on and so on they would

00:09:09,839 --> 00:09:12,480
be

00:09:10,240 --> 00:09:14,480
chaining up until it reaches a point

00:09:12,480 --> 00:09:16,720
where either someone blocks

00:09:14,480 --> 00:09:17,519
and waits until it is finished or they

00:09:16,720 --> 00:09:19,040
don't care that

00:09:17,519 --> 00:09:21,279
it's okay routine and it will just

00:09:19,040 --> 00:09:24,480
continue doing something else

00:09:21,279 --> 00:09:26,720
so and this is important this fact that

00:09:24,480 --> 00:09:29,200
it always returns to the caller

00:09:26,720 --> 00:09:31,279
means that what we can have this

00:09:29,200 --> 00:09:34,240
executed from the event loop

00:09:31,279 --> 00:09:34,800
and whenever the coroutine is suspends

00:09:34,240 --> 00:09:36,800
itself

00:09:34,800 --> 00:09:38,320
it means that the execution will return

00:09:36,800 --> 00:09:41,120
back into the event loop

00:09:38,320 --> 00:09:41,839
so as long so while the corrupting is

00:09:41,120 --> 00:09:44,160
being

00:09:41,839 --> 00:09:45,200
suspended waiting for a network reply or

00:09:44,160 --> 00:09:47,920
debus reply

00:09:45,200 --> 00:09:49,680
we might we can have uh our event loop

00:09:47,920 --> 00:09:51,519
perfectly looping

00:09:49,680 --> 00:09:53,120
let's look at this diagram uh this is

00:09:51,519 --> 00:09:56,320
state-of-the-art presentation

00:09:53,120 --> 00:09:59,040
painting uh event loop

00:09:56,320 --> 00:10:00,399
uh let's say it's cute in that loop it

00:09:59,040 --> 00:10:01,519
can be an event loop but let's assume

00:10:00,399 --> 00:10:03,120
it's cute event loop

00:10:01,519 --> 00:10:04,720
and this blue bar indicates that the

00:10:03,120 --> 00:10:07,040
event loop is running right it's doing

00:10:04,720 --> 00:10:08,720
its stuff it's event looping

00:10:07,040 --> 00:10:10,880
and now at some point for some reason it

00:10:08,720 --> 00:10:11,360
decides to call the player widget update

00:10:10,880 --> 00:10:13,920
function

00:10:11,360 --> 00:10:14,640
uh it could be a timer or any other

00:10:13,920 --> 00:10:17,600
reason

00:10:14,640 --> 00:10:20,079
simply calls or player vision update so

00:10:17,600 --> 00:10:21,760
the origin update starts running right

00:10:20,079 --> 00:10:23,200
and the event loop is blocked it's not

00:10:21,760 --> 00:10:24,959
running that's

00:10:23,200 --> 00:10:26,079
that's why it's lighter right here we

00:10:24,959 --> 00:10:26,800
can't have both things running at the

00:10:26,079 --> 00:10:28,320
same time

00:10:26,800 --> 00:10:31,440
one function called another function so

00:10:28,320 --> 00:10:33,839
the execution is now here

00:10:31,440 --> 00:10:35,839
and if you remember the function update

00:10:33,839 --> 00:10:37,200
called the get title function so the

00:10:35,839 --> 00:10:40,480
execution moves forward

00:10:37,200 --> 00:10:42,399
further down here and then if you

00:10:40,480 --> 00:10:44,800
remember the function get title it does

00:10:42,399 --> 00:10:46,240
it called the bus call so that sends

00:10:44,800 --> 00:10:48,000
some debuff message out

00:10:46,240 --> 00:10:49,440
and immediately almost immediately

00:10:48,000 --> 00:10:51,600
returned back

00:10:49,440 --> 00:10:52,959
so we are back in get title now what's

00:10:51,600 --> 00:10:56,480
next in get title

00:10:52,959 --> 00:10:58,079
was the co-weight keyword right

00:10:56,480 --> 00:11:00,320
so we are now in the co wait keywords

00:10:58,079 --> 00:11:01,760
that the red box down there and

00:11:00,320 --> 00:11:03,600
the cold weight keyword looks at the d

00:11:01,760 --> 00:11:05,440
bus response and it says well the

00:11:03,600 --> 00:11:06,800
response is not ready yet so i will

00:11:05,440 --> 00:11:09,920
suspend get title

00:11:06,800 --> 00:11:12,240
and i will return execution to my caller

00:11:09,920 --> 00:11:14,000
which was player widget update so now

00:11:12,240 --> 00:11:16,720
the execution is back in player widget

00:11:14,000 --> 00:11:18,720
update if you remember player reset

00:11:16,720 --> 00:11:23,120
update was co-waiting

00:11:18,720 --> 00:11:26,079
on the get title curtain as well so

00:11:23,120 --> 00:11:27,040
here we have the co-weight again the

00:11:26,079 --> 00:11:29,440
call weight looks

00:11:27,040 --> 00:11:31,519
at the get title and it says well the

00:11:29,440 --> 00:11:33,360
get title task is not finished yet so i

00:11:31,519 --> 00:11:33,920
will suspend myself as well and return

00:11:33,360 --> 00:11:36,800
to

00:11:33,920 --> 00:11:38,480
to my caller so now the player widget

00:11:36,800 --> 00:11:40,800
update is suspended as well and the

00:11:38,480 --> 00:11:42,720
execution is back in the event loop

00:11:40,800 --> 00:11:44,399
and now the event loop is happily

00:11:42,720 --> 00:11:47,279
running processing your events

00:11:44,399 --> 00:11:48,640
your ui is you know reacting to user

00:11:47,279 --> 00:11:51,920
input and so on

00:11:48,640 --> 00:11:53,839
while these two functions are suspended

00:11:51,920 --> 00:11:55,519
right they are state saved somewhere in

00:11:53,839 --> 00:11:57,279
the memory they are not actually being

00:11:55,519 --> 00:11:59,680
executed

00:11:57,279 --> 00:12:00,880
is the event loop that's running and now

00:11:59,680 --> 00:12:02,480
suddenly let's

00:12:00,880 --> 00:12:04,399
not go into details how that happens but

00:12:02,480 --> 00:12:06,160
let's assume that when the dbus reply

00:12:04,399 --> 00:12:07,600
arrives finally to your application it

00:12:06,160 --> 00:12:08,320
somehow gets triggered from the event

00:12:07,600 --> 00:12:10,720
loop

00:12:08,320 --> 00:12:12,079
goes into some magical debuffs handler

00:12:10,720 --> 00:12:15,440
and the debuff handler

00:12:12,079 --> 00:12:17,360
sets the response as finished and

00:12:15,440 --> 00:12:18,480
remember there is a routine that is

00:12:17,360 --> 00:12:22,320
bound to that

00:12:18,480 --> 00:12:25,360
uh to that uh response so what happens

00:12:22,320 --> 00:12:27,040
the coroutine is awakened so the

00:12:25,360 --> 00:12:28,560
coroutine is awakened we are now in the

00:12:27,040 --> 00:12:30,560
get title curtain which was waiting for

00:12:28,560 --> 00:12:32,720
the debuff response

00:12:30,560 --> 00:12:34,399
the core team does something uh whatever

00:12:32,720 --> 00:12:36,079
was after the co-weight keyboard so that

00:12:34,399 --> 00:12:37,040
was assigning it to q string and then

00:12:36,079 --> 00:12:41,120
co-returning

00:12:37,040 --> 00:12:43,760
that q string back to its color so

00:12:41,120 --> 00:12:45,120
the next step it returns the title to

00:12:43,760 --> 00:12:46,079
its caller which was player widget

00:12:45,120 --> 00:12:48,399
update

00:12:46,079 --> 00:12:50,160
derivation update might do some other

00:12:48,399 --> 00:12:52,560
stuff with that title you know set it as

00:12:50,160 --> 00:12:54,560
a title and some label or whatnot

00:12:52,560 --> 00:12:56,399
and then it reaches its end and it

00:12:54,560 --> 00:12:58,800
finishes

00:12:56,399 --> 00:12:59,680
so the execution now this is weird it

00:12:58,800 --> 00:13:01,760
doesn't

00:12:59,680 --> 00:13:03,440
necessarily return to the event loop

00:13:01,760 --> 00:13:05,040
because player widget update was called

00:13:03,440 --> 00:13:06,639
from the event loop it returns back to

00:13:05,040 --> 00:13:08,800
get title and then from get title it

00:13:06,639 --> 00:13:10,639
returns back to the dbos handler because

00:13:08,800 --> 00:13:12,480
the debug sensor is the one who actually

00:13:10,639 --> 00:13:14,399
resumed the core routine

00:13:12,480 --> 00:13:17,600
right so the execution after resuming

00:13:14,399 --> 00:13:19,600
follows from the one who resumed them

00:13:17,600 --> 00:13:20,880
finally the diplo center is finished and

00:13:19,600 --> 00:13:22,320
it returns back to the event loop and

00:13:20,880 --> 00:13:25,760
the event loop continues

00:13:22,320 --> 00:13:27,440
event looping happily so this is

00:13:25,760 --> 00:13:29,680
somewhat what happens when you use core

00:13:27,440 --> 00:13:30,480
routines right when you find a place

00:13:29,680 --> 00:13:33,120
where you

00:13:30,480 --> 00:13:34,000
sort of want to wait for a for approach

00:13:33,120 --> 00:13:36,800
for some for some

00:13:34,000 --> 00:13:38,000
uh operation asynchronously but you

00:13:36,800 --> 00:13:39,440
don't want to rewrite your entire code

00:13:38,000 --> 00:13:40,959
base to be asynchronous you can just use

00:13:39,440 --> 00:13:42,480
code weight

00:13:40,959 --> 00:13:44,240
and it's not that simple but we'll get

00:13:42,480 --> 00:13:48,000
to that later

00:13:44,240 --> 00:13:50,480
uh here is uh the same graph

00:13:48,000 --> 00:13:52,000
only if the debus call was blocking

00:13:50,480 --> 00:13:53,839
right if we if he did direct

00:13:52,000 --> 00:13:55,199
what basically the thing that we had in

00:13:53,839 --> 00:13:58,399
the original uh

00:13:55,199 --> 00:14:00,160
snippet which was waiting in a blocking

00:13:58,399 --> 00:14:02,720
manner for the response to arrive

00:14:00,160 --> 00:14:03,360
if you compare that when we are waiting

00:14:02,720 --> 00:14:04,959
in a

00:14:03,360 --> 00:14:07,199
blocking manner the event loop is not

00:14:04,959 --> 00:14:08,880
running at all the whole time

00:14:07,199 --> 00:14:11,279
while with core routines the event loop

00:14:08,880 --> 00:14:13,040
is executing most of the time

00:14:11,279 --> 00:14:14,959
uh those blocks are actually not

00:14:13,040 --> 00:14:17,440
proportional to the actual execution

00:14:14,959 --> 00:14:20,560
time so in reality it would be mostly

00:14:17,440 --> 00:14:23,600
dark blue and a very little very small

00:14:20,560 --> 00:14:25,279
you know the times when the event is not

00:14:23,600 --> 00:14:28,320
running or is blocked would be

00:14:25,279 --> 00:14:30,399
much smaller than this even so here we

00:14:28,320 --> 00:14:32,320
can see that uh

00:14:30,399 --> 00:14:33,920
by using curtins without actually

00:14:32,320 --> 00:14:36,160
changing the code right we just

00:14:33,920 --> 00:14:37,760
throw in a few keywords and magically

00:14:36,160 --> 00:14:41,199
our code does not block the event

00:14:37,760 --> 00:14:44,079
anymore so now let's look at it

00:14:41,199 --> 00:14:45,279
now let's look at caroutine's uh a bit

00:14:44,079 --> 00:14:48,000
more in general

00:14:45,279 --> 00:14:48,959
uh you may have heard about coroutines

00:14:48,000 --> 00:14:50,880
before if you

00:14:48,959 --> 00:14:52,160
use some other languages coridines are

00:14:50,880 --> 00:14:56,320
common in python

00:14:52,160 --> 00:14:57,760
javascript kotlin go rust

00:14:56,320 --> 00:14:59,120
they seem all to have carotenes it's

00:14:57,760 --> 00:15:00,320
almost sounds like c spots is locked to

00:14:59,120 --> 00:15:03,040
the party but it's

00:15:00,320 --> 00:15:03,760
it's not anyway carotene is a function

00:15:03,040 --> 00:15:06,399
uh

00:15:03,760 --> 00:15:08,000
it can be suspended at any point and

00:15:06,399 --> 00:15:10,160
then resumed again

00:15:08,000 --> 00:15:11,360
from that point where it was suspended

00:15:10,160 --> 00:15:13,360
when the curtain is suspended the

00:15:11,360 --> 00:15:13,760
execution returns to its caller which we

00:15:13,360 --> 00:15:16,160
just

00:15:13,760 --> 00:15:17,760
shown and when a curtain is resumed it's

00:15:16,160 --> 00:15:19,440
resumed as if it was called from the

00:15:17,760 --> 00:15:20,880
function that has resumed it

00:15:19,440 --> 00:15:23,120
uh we've shown that as well with the

00:15:20,880 --> 00:15:25,120
weird debus uh

00:15:23,120 --> 00:15:26,399
handler sort of calling the function

00:15:25,120 --> 00:15:28,800
right uh

00:15:26,399 --> 00:15:30,240
suspended function what's most important

00:15:28,800 --> 00:15:31,759
for me about corodines is that

00:15:30,240 --> 00:15:33,600
corrodings allow you to write

00:15:31,759 --> 00:15:34,560
asynchronous code in synchronous manner

00:15:33,600 --> 00:15:35,920
that means no

00:15:34,560 --> 00:15:38,000
you don't need to call back hell you

00:15:35,920 --> 00:15:38,880
don't need you know 15 different signal

00:15:38,000 --> 00:15:42,000
slots and

00:15:38,880 --> 00:15:43,519
then lots of connections between them it

00:15:42,000 --> 00:15:44,720
allows you to write the code as if it

00:15:43,519 --> 00:15:46,480
were asynchronous

00:15:44,720 --> 00:15:48,079
and then you just throw a cold weight

00:15:46,480 --> 00:15:49,759
keyword here and there and magically

00:15:48,079 --> 00:15:53,040
your code doesn't block the event loop

00:15:49,759 --> 00:15:54,160
and it's asynchronous what's the warning

00:15:53,040 --> 00:15:56,560
though

00:15:54,160 --> 00:15:58,160
it does not mean that it will improve

00:15:56,560 --> 00:16:00,240
your performance it will not make your

00:15:58,160 --> 00:16:02,959
application faster it might help make

00:16:00,240 --> 00:16:04,240
your application more responsive

00:16:02,959 --> 00:16:06,079
but coroutines will not make your

00:16:04,240 --> 00:16:09,199
application faster

00:16:06,079 --> 00:16:11,920
the reason is that uh

00:16:09,199 --> 00:16:12,880
uh not necessarily of course uh but in

00:16:11,920 --> 00:16:14,800
most cases the

00:16:12,880 --> 00:16:16,959
the the overhead of suspending and

00:16:14,800 --> 00:16:20,000
resuming uh coroutines

00:16:16,959 --> 00:16:22,720
is is small but there is some right

00:16:20,000 --> 00:16:24,639
so you know if you go wait for a network

00:16:22,720 --> 00:16:25,040
request a network reply here and there

00:16:24,639 --> 00:16:26,800
and then

00:16:25,040 --> 00:16:28,639
you know you call weight some debus

00:16:26,800 --> 00:16:30,399
debuss requests here and there

00:16:28,639 --> 00:16:32,320
it's not measurable the impact is not

00:16:30,399 --> 00:16:33,360
measurable but you know if you would do

00:16:32,320 --> 00:16:35,440
this in a tight loop

00:16:33,360 --> 00:16:36,880
then yeah that there would be a measure

00:16:35,440 --> 00:16:38,959
level slow down

00:16:36,880 --> 00:16:40,240
because of the the overhead of uh

00:16:38,959 --> 00:16:42,079
suspending and resuming the current

00:16:40,240 --> 00:16:45,040
dates

00:16:42,079 --> 00:16:46,560
so curtains in c plus plus in the c plus

00:16:45,040 --> 00:16:47,279
plus uh courtney's curtains were

00:16:46,560 --> 00:16:49,680
introduced in c

00:16:47,279 --> 00:16:52,240
plus 20 so in the last version it's

00:16:49,680 --> 00:16:52,800
perfectly fine supported by gcc and msvc

00:16:52,240 --> 00:16:56,079
in

00:16:52,800 --> 00:16:58,399
in latest versions uh clank v

00:16:56,079 --> 00:17:00,240
clank is a bit problematic so it's in in

00:16:58,399 --> 00:17:02,560
a way supported for a long time since

00:17:00,240 --> 00:17:04,240
clank five but clank still supports only

00:17:02,560 --> 00:17:05,600
the technical specification they still

00:17:04,240 --> 00:17:08,480
consider their implementation of

00:17:05,600 --> 00:17:10,319
coroutines to be experimental

00:17:08,480 --> 00:17:12,000
so that makes it kind of difficult

00:17:10,319 --> 00:17:13,679
because and if you use

00:17:12,000 --> 00:17:15,520
if you write your code to be portable to

00:17:13,679 --> 00:17:17,919
both all compilers then in

00:17:15,520 --> 00:17:18,880
for gcc you everything is in in the name

00:17:17,919 --> 00:17:21,199
space stood

00:17:18,880 --> 00:17:22,559
in the in the stud name space while then

00:17:21,199 --> 00:17:24,400
inclined everything is

00:17:22,559 --> 00:17:25,679
in the experimental name space so you

00:17:24,400 --> 00:17:27,919
need to do some type

00:17:25,679 --> 00:17:29,200
some some magic with macros usually to

00:17:27,919 --> 00:17:31,440
get it working

00:17:29,200 --> 00:17:32,799
the biggest disadvantage is that because

00:17:31,440 --> 00:17:35,440
it's experimental in clank

00:17:32,799 --> 00:17:36,720
it only works with the llvm lip c plus

00:17:35,440 --> 00:17:39,760
past standard library

00:17:36,720 --> 00:17:40,720
right you can't use clank and the

00:17:39,760 --> 00:17:43,600
standard canoe

00:17:40,720 --> 00:17:45,120
lip stdc plus plus and coridines that

00:17:43,600 --> 00:17:46,799
doesn't doesn't fly

00:17:45,120 --> 00:17:48,240
right and this becomes problematic when

00:17:46,799 --> 00:17:50,240
you try to use current teams with

00:17:48,240 --> 00:17:51,919
uh with some distribution provided

00:17:50,240 --> 00:17:53,360
packages because distributions linux

00:17:51,919 --> 00:17:57,200
distributions usually

00:17:53,360 --> 00:18:00,559
use the uh gcc standard library by the

00:17:57,200 --> 00:18:02,160
lib sddc plus plus while if you try to

00:18:00,559 --> 00:18:04,320
use clank and

00:18:02,160 --> 00:18:06,480
you build your application with curvings

00:18:04,320 --> 00:18:09,840
and the lip c plus plus there might be

00:18:06,480 --> 00:18:12,840
uh symbol problems because lip c plus

00:18:09,840 --> 00:18:14,240
plus and still lip c plus plus are not

00:18:12,840 --> 00:18:16,400
compatible

00:18:14,240 --> 00:18:17,520
uh on the api level uh what's

00:18:16,400 --> 00:18:20,720
interesting is that

00:18:17,520 --> 00:18:21,600
in c they uh the the committee they

00:18:20,720 --> 00:18:24,640
actually

00:18:21,600 --> 00:18:26,000
introduced mostly jazz the the la it was

00:18:24,640 --> 00:18:27,360
mostly the language extension they

00:18:26,000 --> 00:18:29,360
introduced the keywords

00:18:27,360 --> 00:18:30,880
and describe the machinery that's

00:18:29,360 --> 00:18:32,000
supposed to be hidden behind those

00:18:30,880 --> 00:18:35,840
keywords

00:18:32,000 --> 00:18:39,120
and the but what they did is they they

00:18:35,840 --> 00:18:41,760
only specify the bare minimum

00:18:39,120 --> 00:18:42,559
tools in the standard library that are

00:18:41,760 --> 00:18:44,720
needed

00:18:42,559 --> 00:18:46,720
by compiler developers to be able to

00:18:44,720 --> 00:18:49,440
implement corruptions and compilers

00:18:46,720 --> 00:18:51,120
and for library writers we want to write

00:18:49,440 --> 00:18:54,640
curtin libraries

00:18:51,120 --> 00:18:57,840
right it's not like there are no

00:18:54,640 --> 00:18:59,600
ready-made you know thing uh like tasks

00:18:57,840 --> 00:19:01,360
for instance that you see the key chord

00:18:59,600 --> 00:19:02,799
the task a return type

00:19:01,360 --> 00:19:04,320
there is no such thing in the sound

00:19:02,799 --> 00:19:05,200
library that you could just start using

00:19:04,320 --> 00:19:08,000
immediately as

00:19:05,200 --> 00:19:09,039
a programmer uh the reason is that the

00:19:08,000 --> 00:19:11,280
the idea was that

00:19:09,039 --> 00:19:12,160
the committee introduced all the tooling

00:19:11,280 --> 00:19:15,440
that's necessary

00:19:12,160 --> 00:19:17,679
to to write coroutine libraries

00:19:15,440 --> 00:19:18,880
and then they let the wider community to

00:19:17,679 --> 00:19:19,679
actually come up with some

00:19:18,880 --> 00:19:23,120
implementation

00:19:19,679 --> 00:19:25,440
so that we can see how coroutines are

00:19:23,120 --> 00:19:27,600
used in the real world in production

00:19:25,440 --> 00:19:29,120
how what is the best approach and then

00:19:27,600 --> 00:19:30,400
hopefully in the next version of cpu's

00:19:29,120 --> 00:19:31,679
password version after

00:19:30,400 --> 00:19:34,400
there will be some proposals to

00:19:31,679 --> 00:19:35,919
standardize one or two different

00:19:34,400 --> 00:19:38,960
approaches

00:19:35,919 --> 00:19:41,200
uh to curtin so that after that

00:19:38,960 --> 00:19:42,960
uh regular developers can just come

00:19:41,200 --> 00:19:43,440
include the current header and start

00:19:42,960 --> 00:19:45,039
using

00:19:43,440 --> 00:19:46,880
you know current things out of the box

00:19:45,039 --> 00:19:48,720
with the standard library for now that's

00:19:46,880 --> 00:19:50,960
not possible you need to write

00:19:48,720 --> 00:19:52,240
lots of the machinery or you need to

00:19:50,960 --> 00:19:54,320
write the glue

00:19:52,240 --> 00:19:57,120
uh that that can that can be used with

00:19:54,320 --> 00:20:00,320
the user code and the machinery

00:19:57,120 --> 00:20:03,360
for the machinery of coroutines

00:20:00,320 --> 00:20:03,360
uh in the language

00:20:04,480 --> 00:20:08,960
um so what has been introduced into cpus

00:20:07,760 --> 00:20:11,360
plus really

00:20:08,960 --> 00:20:13,120
there are three new keywords co-weight

00:20:11,360 --> 00:20:15,840
co-return and co-yield the

00:20:13,120 --> 00:20:16,799
core underscore prefix is there to avoid

00:20:15,840 --> 00:20:20,159
conflict with

00:20:16,799 --> 00:20:21,919
uh some other uh libraries that even

00:20:20,159 --> 00:20:23,600
before they were official proteins in c

00:20:21,919 --> 00:20:26,640
plus there were various implementations

00:20:23,600 --> 00:20:28,720
using threads and light threads

00:20:26,640 --> 00:20:30,559
uh in for instance in boost or other

00:20:28,720 --> 00:20:31,919
libraries and they have created macros

00:20:30,559 --> 00:20:34,960
called evade and

00:20:31,919 --> 00:20:36,400
yield for instance so that this was this

00:20:34,960 --> 00:20:38,400
would clash so

00:20:36,400 --> 00:20:39,760
they decided instead to use the code

00:20:38,400 --> 00:20:41,520
underscore uh

00:20:39,760 --> 00:20:43,039
prefix to make sure that this doesn't

00:20:41,520 --> 00:20:45,200
clash with some existing implementations

00:20:43,039 --> 00:20:47,200
of core teams in c plus bus

00:20:45,200 --> 00:20:49,280
uh the keywords what they do away we

00:20:47,200 --> 00:20:51,039
already saw go wait suspends

00:20:49,280 --> 00:20:52,640
the the curve routine and returns

00:20:51,039 --> 00:20:56,080
execution to

00:20:52,640 --> 00:20:57,679
uh to the caller uh co-return allows us

00:20:56,080 --> 00:20:58,880
to return a value from a car routine

00:20:57,679 --> 00:21:00,559
it's basically like return

00:20:58,880 --> 00:21:02,320
it just for current and then the

00:21:00,559 --> 00:21:04,480
interesting thing that uh i haven't

00:21:02,320 --> 00:21:06,400
dug very deep into yet but that's co

00:21:04,480 --> 00:21:07,520
yield which basically allows us to

00:21:06,400 --> 00:21:09,440
return

00:21:07,520 --> 00:21:10,960
repeatedly values from a function

00:21:09,440 --> 00:21:11,280
without the function actually ending

00:21:10,960 --> 00:21:13,039
right

00:21:11,280 --> 00:21:15,039
normally when you when you return a

00:21:13,039 --> 00:21:16,640
value from a function the function ends

00:21:15,039 --> 00:21:18,400
but with co yield you can actually

00:21:16,640 --> 00:21:21,520
return the value repeatedly

00:21:18,400 --> 00:21:23,919
whenever someone asks for it without

00:21:21,520 --> 00:21:27,200
ending the function this is useful for

00:21:23,919 --> 00:21:27,200
writing uh generators

00:21:27,440 --> 00:21:31,120
in the standard library we have a few

00:21:29,520 --> 00:21:31,679
things this is not exhaustive but there

00:21:31,120 --> 00:21:32,960
are only

00:21:31,679 --> 00:21:35,120
like one or two more things that i

00:21:32,960 --> 00:21:37,280
didn't mention here uh first is the

00:21:35,120 --> 00:21:38,240
stuttgarten handler handle which is a

00:21:37,280 --> 00:21:40,000
class that

00:21:38,240 --> 00:21:42,240
is a handle for croutin really as the

00:21:40,000 --> 00:21:42,720
name says uh it allows resuming the

00:21:42,240 --> 00:21:44,480
current

00:21:42,720 --> 00:21:46,559
and internally it holds pointers to

00:21:44,480 --> 00:21:47,840
where the stack is saved and whether

00:21:46,559 --> 00:21:49,679
the instruction pointer and some other

00:21:47,840 --> 00:21:51,440
stuff and then they'll suspend never

00:21:49,679 --> 00:21:53,280
suspend always helpers which

00:21:51,440 --> 00:21:55,120
allow to which allow the current team to

00:21:53,280 --> 00:21:56,000
indicate uh whether it shoot or should

00:21:55,120 --> 00:21:58,880
not suspend

00:21:56,000 --> 00:22:00,640
and when it should should not suspend uh

00:21:58,880 --> 00:22:03,440
this is customizable so curtin

00:22:00,640 --> 00:22:05,280
for instance can decide when it's called

00:22:03,440 --> 00:22:06,080
it can decide to immediately suspend

00:22:05,280 --> 00:22:08,080
itself

00:22:06,080 --> 00:22:09,280
and then only start executing the user

00:22:08,080 --> 00:22:11,520
code

00:22:09,280 --> 00:22:13,760
at the moment that someone starts

00:22:11,520 --> 00:22:15,520
co-awaiting that core routine

00:22:13,760 --> 00:22:17,200
right other coroutines can decide to

00:22:15,520 --> 00:22:18,799
start immediately executing the user

00:22:17,200 --> 00:22:21,120
code and then they run run run

00:22:18,799 --> 00:22:23,600
and well when someone co-writes them

00:22:21,120 --> 00:22:25,360
they might already get the result

00:22:23,600 --> 00:22:27,039
so so and the suspender assessment

00:22:25,360 --> 00:22:29,679
always allows to control this

00:22:27,039 --> 00:22:31,760
behavior so how do you make a current in

00:22:29,679 --> 00:22:33,760
sql spots well first you must use one of

00:22:31,760 --> 00:22:36,559
the keywords co-weight or co-wealth

00:22:33,760 --> 00:22:38,000
uh if you read the specific standard

00:22:36,559 --> 00:22:39,840
just adding the one of those two

00:22:38,000 --> 00:22:41,200
keywords into the into the code

00:22:39,840 --> 00:22:41,840
magically makes it quite routine by

00:22:41,200 --> 00:22:44,240
definition

00:22:41,840 --> 00:22:46,080
though it will not compile yet the

00:22:44,240 --> 00:22:47,840
current team must have a special return

00:22:46,080 --> 00:22:50,000
type the special written type

00:22:47,840 --> 00:22:51,600
or the return type is special because it

00:22:50,000 --> 00:22:54,400
must have a typedef

00:22:51,600 --> 00:22:56,159
called promise underscore type which uh

00:22:54,400 --> 00:22:57,039
well it's a tie death to some particular

00:22:56,159 --> 00:23:00,320
class

00:22:57,039 --> 00:23:02,159
uh to some class which must implement

00:23:00,320 --> 00:23:03,840
some sort of promise interface

00:23:02,159 --> 00:23:05,520
uh this has nothing to do with with

00:23:03,840 --> 00:23:06,000
stood promised or stood future right

00:23:05,520 --> 00:23:08,480
it's just

00:23:06,000 --> 00:23:09,280
the the naming is more of the the idea

00:23:08,480 --> 00:23:13,120
is the same

00:23:09,280 --> 00:23:14,640
so uh there must be some promise type

00:23:13,120 --> 00:23:16,320
usually the return type looks something

00:23:14,640 --> 00:23:20,080
like you know this task

00:23:16,320 --> 00:23:21,679
task t where t is actual type

00:23:20,080 --> 00:23:23,280
of the value you want to return so q

00:23:21,679 --> 00:23:26,400
string or integer

00:23:23,280 --> 00:23:28,640
uh and the way i think about is the task

00:23:26,400 --> 00:23:30,000
is like the the interface for the caller

00:23:28,640 --> 00:23:30,640
that's what the color of the curtain

00:23:30,000 --> 00:23:33,280
sees

00:23:30,640 --> 00:23:36,159
while the promise type is what is used

00:23:33,280 --> 00:23:37,760
internally within the core routine

00:23:36,159 --> 00:23:39,280
the problem is that that's what i

00:23:37,760 --> 00:23:41,200
mentioned initially is that

00:23:39,280 --> 00:23:43,360
there is no such return type already

00:23:41,200 --> 00:23:44,960
defined in the standard library

00:23:43,360 --> 00:23:46,799
right so you need to write it yourself

00:23:44,960 --> 00:23:49,679
first and in order to be able to write

00:23:46,799 --> 00:23:52,080
this return type you need to understand

00:23:49,679 --> 00:23:53,760
curatings a bit more in depth

00:23:52,080 --> 00:23:55,919
uh before you can just start using them

00:23:53,760 --> 00:23:57,679
which is why it's not so easy to get

00:23:55,919 --> 00:24:00,720
into curriculums immediately

00:23:57,679 --> 00:24:01,520
and of course you must use corresponding

00:24:00,720 --> 00:24:04,000
sort of returns

00:24:01,520 --> 00:24:05,520
rather than when you have coroutine so

00:24:04,000 --> 00:24:07,120
now um

00:24:05,520 --> 00:24:08,799
one thing that you might be might be

00:24:07,120 --> 00:24:11,039
wondering is

00:24:08,799 --> 00:24:11,840
uh this is back to one of slide five or

00:24:11,039 --> 00:24:15,039
six

00:24:11,840 --> 00:24:17,440
um when we had this code

00:24:15,039 --> 00:24:18,559
and i said well we have the qd bus reply

00:24:17,440 --> 00:24:20,799
and then we pass it

00:24:18,559 --> 00:24:22,559
to ko wait and ko wait looks at the

00:24:20,799 --> 00:24:24,000
debuff reply and it says well the dbos

00:24:22,559 --> 00:24:24,880
reply is not finished i will suspend the

00:24:24,000 --> 00:24:27,520
coroutine

00:24:24,880 --> 00:24:28,799
and i said what does c plus plus

00:24:27,520 --> 00:24:33,120
magically know about

00:24:28,799 --> 00:24:34,799
cute does c bus understand qd bus reply

00:24:33,120 --> 00:24:36,720
no it's it's it's not like that it's not

00:24:34,799 --> 00:24:38,720
that easy there has to be some

00:24:36,720 --> 00:24:39,919
point some integration point right

00:24:38,720 --> 00:24:41,840
someone must have taught

00:24:39,919 --> 00:24:43,600
what how to figure out that q that vls

00:24:41,840 --> 00:24:47,279
reply is finished or not

00:24:43,600 --> 00:24:49,760
and that someone is a

00:24:47,279 --> 00:24:50,480
the coroutine library developer in this

00:24:49,760 --> 00:24:55,039
case the

00:24:50,480 --> 00:24:56,640
library that i use is uh oh well i will

00:24:55,039 --> 00:24:59,600
get to that but the way it works is

00:24:56,640 --> 00:25:02,320
basically the colorway keyword requires

00:24:59,600 --> 00:25:04,400
uh an argument which is of a particular

00:25:02,320 --> 00:25:07,760
type

00:25:04,400 --> 00:25:09,200
and the type must either already

00:25:07,760 --> 00:25:10,080
implement an interface which is called

00:25:09,200 --> 00:25:12,480
available or

00:25:10,080 --> 00:25:14,320
it's like a concept rather so having a

00:25:12,480 --> 00:25:16,320
few few functions that uh the co-weight

00:25:14,320 --> 00:25:17,919
keyword will use to figure out okay is

00:25:16,320 --> 00:25:18,559
it finished yet or not or should i

00:25:17,919 --> 00:25:21,440
suspend

00:25:18,559 --> 00:25:22,960
and how should i spend or if you

00:25:21,440 --> 00:25:24,640
remember the promise type

00:25:22,960 --> 00:25:26,159
from the return from the previous slide

00:25:24,640 --> 00:25:28,799
from the return type of the

00:25:26,159 --> 00:25:30,400
of the of the corrupting if there is a

00:25:28,799 --> 00:25:32,240
function called a weight transform

00:25:30,400 --> 00:25:33,919
transform overloaded on that promise

00:25:32,240 --> 00:25:35,840
type for that particle type

00:25:33,919 --> 00:25:37,760
t so for instance in our case for the

00:25:35,840 --> 00:25:39,919
qdbus reply

00:25:37,760 --> 00:25:40,799
then the 08 will call this away

00:25:39,919 --> 00:25:42,799
transport function

00:25:40,799 --> 00:25:45,840
and it expects that in return it will

00:25:42,799 --> 00:25:47,679
get some sort of unavailable again

00:25:45,840 --> 00:25:50,880
right so this basically since the

00:25:47,679 --> 00:25:53,200
promise type is bound to the return type

00:25:50,880 --> 00:25:54,320
it's bound to direct it's bound to the

00:25:53,200 --> 00:25:57,600
return type of the

00:25:54,320 --> 00:25:59,760
routine so task in this case

00:25:57,600 --> 00:26:00,880
this means that if you pick the right

00:25:59,760 --> 00:26:04,159
return type

00:26:00,880 --> 00:26:07,840
so you can provide

00:26:04,159 --> 00:26:09,520
the uh weight transform overload for any

00:26:07,840 --> 00:26:11,919
type you want to support

00:26:09,520 --> 00:26:13,200
so in this case i have a little library

00:26:11,919 --> 00:26:15,840
that provides qr core

00:26:13,200 --> 00:26:17,440
task as a class that implements the

00:26:15,840 --> 00:26:19,760
available interface

00:26:17,440 --> 00:26:21,440
and internally it has the promise type

00:26:19,760 --> 00:26:24,080
defined to some custom

00:26:21,440 --> 00:26:25,919
class and this class has a weight

00:26:24,080 --> 00:26:27,200
transform overload specified for all

00:26:25,919 --> 00:26:29,200
different queues types

00:26:27,200 --> 00:26:31,440
including qd bus reply so that's how

00:26:29,200 --> 00:26:34,159
kowai learns about

00:26:31,440 --> 00:26:35,279
qd bus reply how how how it is able to

00:26:34,159 --> 00:26:38,640
determine that

00:26:35,279 --> 00:26:40,640
uh whether qbus reply is finished or not

00:26:38,640 --> 00:26:41,760
the library is surprise surprise i call

00:26:40,640 --> 00:26:44,159
it qchoro

00:26:41,760 --> 00:26:46,080
and it's a small library which provides

00:26:44,159 --> 00:26:46,720
custom available return type for current

00:26:46,080 --> 00:26:50,000
themes which

00:26:46,720 --> 00:26:52,400
that's the key curve task uh

00:26:50,000 --> 00:26:54,400
this qco task has the evade transform

00:26:52,400 --> 00:26:56,480
implementation for various queues types

00:26:54,400 --> 00:26:58,159
where it makes sense to have some ic

00:26:56,480 --> 00:27:00,240
which have some asynchronous implement

00:26:58,159 --> 00:27:02,000
uh some asynchronous operation that

00:27:00,240 --> 00:27:04,480
makes sense to wait for

00:27:02,000 --> 00:27:06,640
and it also provides some scene wrappers

00:27:04,480 --> 00:27:09,039
that provide various asynchronous

00:27:06,640 --> 00:27:11,039
operations for different types as well

00:27:09,039 --> 00:27:14,640
uh i'll i'll explain that in an

00:27:11,039 --> 00:27:16,640
example so here

00:27:14,640 --> 00:27:17,840
for some types i call these types like

00:27:16,640 --> 00:27:20,480
explicitly available

00:27:17,840 --> 00:27:22,720
those are types that uh they really have

00:27:20,480 --> 00:27:25,760
only one thing that makes sense to be

00:27:22,720 --> 00:27:28,559
uh awaited which for instance inc

00:27:25,760 --> 00:27:30,320
we have key future here uh future really

00:27:28,559 --> 00:27:31,919
has only one thing that you may want to

00:27:30,320 --> 00:27:34,480
asynchronously wait for and that's

00:27:31,919 --> 00:27:34,960
the future finishing right so in this

00:27:34,480 --> 00:27:36,720
case

00:27:34,960 --> 00:27:38,399
what we have here is a key concurrent

00:27:36,720 --> 00:27:40,720
run uh

00:27:38,399 --> 00:27:42,640
his concurrent run is basically what it

00:27:40,720 --> 00:27:46,960
does it starts this

00:27:42,640 --> 00:27:48,960
lambda in uh in a thread

00:27:46,960 --> 00:27:50,799
immediately return to cue future and

00:27:48,960 --> 00:27:52,720
then eventually when the thread finishes

00:27:50,799 --> 00:27:54,080
the cue future will be finished and it

00:27:52,720 --> 00:27:57,600
will provide the the

00:27:54,080 --> 00:27:59,919
the result to the caller uh

00:27:57,600 --> 00:28:02,000
when you use qcoro so if the if the

00:27:59,919 --> 00:28:02,320
coroutine returns q curve task you can

00:28:02,000 --> 00:28:05,279
just

00:28:02,320 --> 00:28:05,679
put co weight in there and magically uh

00:28:05,279 --> 00:28:07,360
the

00:28:05,679 --> 00:28:09,360
cold weight will know how to deal with

00:28:07,360 --> 00:28:12,240
cue future and it will be able to

00:28:09,360 --> 00:28:13,760
wait asynchronously again for the future

00:28:12,240 --> 00:28:15,120
to finish

00:28:13,760 --> 00:28:16,799
and while it's waiting the curtain

00:28:15,120 --> 00:28:18,720
suspended and you are possibly

00:28:16,799 --> 00:28:20,880
running in an event loop so you have can

00:28:18,720 --> 00:28:22,480
have this nice asynchronous code

00:28:20,880 --> 00:28:24,080
uh sorry synchronous like looking

00:28:22,480 --> 00:28:25,919
queries written in asynchronous way you

00:28:24,080 --> 00:28:27,200
don't need to use q future watcher and

00:28:25,919 --> 00:28:29,360
this kind of stuff

00:28:27,200 --> 00:28:31,279
uh same goes with q network reply really

00:28:29,360 --> 00:28:32,640
q network reply has just one thing that

00:28:31,279 --> 00:28:34,320
you usually want to wait for and that's

00:28:32,640 --> 00:28:36,480
the reply being finished

00:28:34,320 --> 00:28:37,760
although q network reply is also qio

00:28:36,480 --> 00:28:38,559
device which on its own has some

00:28:37,760 --> 00:28:40,240
interesting things

00:28:38,559 --> 00:28:42,320
you some interesting asynchronous

00:28:40,240 --> 00:28:44,320
operations i'll show it later

00:28:42,320 --> 00:28:45,760
so here we create a network access

00:28:44,320 --> 00:28:48,320
manager we call get

00:28:45,760 --> 00:28:50,480
and because again qcoral task has an

00:28:48,320 --> 00:28:52,320
overload for q network reply pointer

00:28:50,480 --> 00:28:53,840
you can just shuffle weight in here in

00:28:52,320 --> 00:28:55,919
here and magically

00:28:53,840 --> 00:28:57,200
this will suspend your routine and

00:28:55,919 --> 00:28:58,880
asynchronously resume

00:28:57,200 --> 00:29:01,039
when the reply is finished and it will

00:28:58,880 --> 00:29:02,559
return the reply again

00:29:01,039 --> 00:29:04,559
of course you don't have to always just

00:29:02,559 --> 00:29:05,200
put cold weight immediately before the

00:29:04,559 --> 00:29:06,480
operation

00:29:05,200 --> 00:29:08,240
what you could do here you could take

00:29:06,480 --> 00:29:09,679
the reply pointer

00:29:08,240 --> 00:29:11,440
and then you could do some more stuff

00:29:09,679 --> 00:29:13,200
like create a database and then

00:29:11,440 --> 00:29:14,240
do some computation and then finally

00:29:13,200 --> 00:29:14,640
when you reach the point where you

00:29:14,240 --> 00:29:17,120
really

00:29:14,640 --> 00:29:17,919
already need the the response from the

00:29:17,120 --> 00:29:20,000
server

00:29:17,919 --> 00:29:21,520
that's where you start co-waiting right

00:29:20,000 --> 00:29:23,120
so you can also use it the way that you

00:29:21,520 --> 00:29:24,159
fire off a nice current request then you

00:29:23,120 --> 00:29:25,520
do some processing

00:29:24,159 --> 00:29:27,840
and then when you reach a point where

00:29:25,520 --> 00:29:29,760
you need the data from the response

00:29:27,840 --> 00:29:31,279
then you start co-weighting this so it

00:29:29,760 --> 00:29:33,279
is it also allows some

00:29:31,279 --> 00:29:35,840
allows for some level of parallelism

00:29:33,279 --> 00:29:38,480
which is nice

00:29:35,840 --> 00:29:39,120
um here is more complex example with key

00:29:38,480 --> 00:29:41,039
process

00:29:39,120 --> 00:29:42,559
uh q processes multiple things that make

00:29:41,039 --> 00:29:44,080
sense to be co-awaited

00:29:42,559 --> 00:29:45,760
there it has multiple asynchronous

00:29:44,080 --> 00:29:48,480
operations uh for

00:29:45,760 --> 00:29:50,080
this case qcoro has a simple wrapper

00:29:48,480 --> 00:29:52,320
function called qcoro

00:29:50,080 --> 00:29:53,679
where you just put a process keeper then

00:29:52,320 --> 00:29:56,399
you pass the q process and

00:29:53,679 --> 00:29:58,080
it returns a thin wrapper class called q

00:29:56,399 --> 00:30:01,120
color process

00:29:58,080 --> 00:30:04,240
and uh this class implements part of the

00:30:01,120 --> 00:30:06,320
the the interface of a key process but

00:30:04,240 --> 00:30:09,200
it implements it in a way

00:30:06,320 --> 00:30:09,760
that you can again uh use co weight with

00:30:09,200 --> 00:30:12,320
it so

00:30:09,760 --> 00:30:13,279
in this case you just started some some

00:30:12,320 --> 00:30:15,200
process

00:30:13,279 --> 00:30:16,559
and then you asynchronously wait for the

00:30:15,200 --> 00:30:17,840
process to start

00:30:16,559 --> 00:30:19,120
then you write something in it and then

00:30:17,840 --> 00:30:20,880
again you asynchronously wait for the

00:30:19,120 --> 00:30:24,159
process to finish

00:30:20,880 --> 00:30:25,760
so you have a beautiful block of code

00:30:24,159 --> 00:30:27,679
in a single place that's easier to read

00:30:25,760 --> 00:30:29,679
easy to navigate you know you don't have

00:30:27,679 --> 00:30:31,279
to do any mental exercises about jumping

00:30:29,679 --> 00:30:34,720
through different functions or having

00:30:31,279 --> 00:30:37,279
nested lambdas and and stuff and

00:30:34,720 --> 00:30:39,200
but just by using uh coroutines this

00:30:37,279 --> 00:30:43,360
allows you to actually

00:30:39,200 --> 00:30:44,880
uh do to not block your your main thread

00:30:43,360 --> 00:30:46,799
uh i think this is the ultimate example

00:30:44,880 --> 00:30:50,240
that i have with that support for

00:30:46,799 --> 00:30:53,520
qtcp server dcp socket uh

00:30:50,240 --> 00:30:54,880
where we have uh we have a wrapper for a

00:30:53,520 --> 00:30:56,880
qtcp server

00:30:54,880 --> 00:30:58,559
where we can co-await new connection so

00:30:56,880 --> 00:31:00,720
this will suspend the routine

00:30:58,559 --> 00:31:01,600
until a new connection is available and

00:31:00,720 --> 00:31:03,840
then again

00:31:01,600 --> 00:31:04,640
when the connection comes it resumes the

00:31:03,840 --> 00:31:06,320
core routine

00:31:04,640 --> 00:31:08,240
and then again waits until the socket

00:31:06,320 --> 00:31:09,200
has anything to read and then ultimately

00:31:08,240 --> 00:31:11,200
it just reads the data

00:31:09,200 --> 00:31:13,279
and sends them back with punk before it

00:31:11,200 --> 00:31:15,519
so it's a simple pong server

00:31:13,279 --> 00:31:16,480
the thing is that this has a while loop

00:31:15,519 --> 00:31:18,159
right a server

00:31:16,480 --> 00:31:19,760
and basically an endless while loop and

00:31:18,159 --> 00:31:20,080
it seems like there's a lot of blocking

00:31:19,760 --> 00:31:21,760
but

00:31:20,080 --> 00:31:23,120
in fact you could just put this code

00:31:21,760 --> 00:31:24,640
into your main thread

00:31:23,120 --> 00:31:27,200
and your application would not get

00:31:24,640 --> 00:31:29,360
blocked right because whenever

00:31:27,200 --> 00:31:31,039
this needs to wait the cold weight would

00:31:29,360 --> 00:31:32,000
just suspend the protein and eventually

00:31:31,039 --> 00:31:35,120
chain up all the way to

00:31:32,000 --> 00:31:37,360
to your event loop right

00:31:35,120 --> 00:31:39,200
uh this is a list of all the classes

00:31:37,360 --> 00:31:40,720
that are supported right now i showed

00:31:39,200 --> 00:31:42,399
some of them there is also q timer

00:31:40,720 --> 00:31:43,200
support so you can call wait a timer to

00:31:42,399 --> 00:31:44,960
timeout

00:31:43,200 --> 00:31:46,320
you can await any arbitrary signal

00:31:44,960 --> 00:31:47,919
emission

00:31:46,320 --> 00:31:50,480
uh and there's general support for key

00:31:47,919 --> 00:31:53,600
io device as well

00:31:50,480 --> 00:31:56,559
so that's that uh that was a

00:31:53,600 --> 00:31:57,919
quick introduction to curtins and qcoro

00:31:56,559 --> 00:31:59,760
if you are interested more in

00:31:57,919 --> 00:32:02,399
the qcoro library there is a github

00:31:59,760 --> 00:32:04,640
repository github.comradio slash

00:32:02,399 --> 00:32:05,440
qcoro or you can read the documentation

00:32:04,640 --> 00:32:07,120
here

00:32:05,440 --> 00:32:09,440
or if you have any questions about

00:32:07,120 --> 00:32:12,960
curritins or the library just hit me

00:32:09,440 --> 00:32:16,799
email twitter or matrix

00:32:12,960 --> 00:32:19,600
thank you let's go give daniel a big

00:32:16,799 --> 00:32:19,600
round of applause

00:32:19,679 --> 00:32:23,200
i assume everyone's going to be clapping

00:32:21,120 --> 00:32:27,200
in the chat um

00:32:23,200 --> 00:32:29,120
so going through some questions jan asks

00:32:27,200 --> 00:32:31,360
have you tried debugging and reading the

00:32:29,120 --> 00:32:33,519
stack traces of code routines so if you

00:32:31,360 --> 00:32:35,519
have a crash what happens in gdb

00:32:33,519 --> 00:32:37,679
yes it's immediate it's horribly

00:32:35,519 --> 00:32:40,240
annoying because uh

00:32:37,679 --> 00:32:42,080
because uh the support in the tool link

00:32:40,240 --> 00:32:44,960
is not there yet so you see uh

00:32:42,080 --> 00:32:44,960
you see random

00:32:45,360 --> 00:32:48,399
there is a lot of generated code and

00:32:46,880 --> 00:32:50,480
generated frames and these are really

00:32:48,399 --> 00:32:53,840
hard to debug yeah so debugging crashes

00:32:50,480 --> 00:32:54,640
are debugging crashes and memory leaks

00:32:53,840 --> 00:32:58,559
especially that's

00:32:54,640 --> 00:33:00,640
it's annoying yeah okay

00:32:58,559 --> 00:33:02,399
so annoying is the answer so your next

00:33:00,640 --> 00:33:03,360
question which i think you just touched

00:33:02,399 --> 00:33:06,000
on at the end

00:33:03,360 --> 00:33:07,679
is does this work out for work out of

00:33:06,000 --> 00:33:10,320
the box for code that is based on

00:33:07,679 --> 00:33:11,600
signals and slots like k-job or do we

00:33:10,320 --> 00:33:13,440
need to do anything there to make it

00:33:11,600 --> 00:33:15,679
correct compatible

00:33:13,440 --> 00:33:17,279
uh you don't need to make you don't need

00:33:15,679 --> 00:33:20,880
to modify the classes

00:33:17,279 --> 00:33:22,880
to make them compatible with coroutines

00:33:20,880 --> 00:33:25,200
i did not patch anything in cute what

00:33:22,880 --> 00:33:28,480
you need to do is you need to introduce

00:33:25,200 --> 00:33:32,080
a wrapper uh and

00:33:28,480 --> 00:33:35,200
uh into the qcoro library possibly that

00:33:32,080 --> 00:33:36,960
that can handle kjob and then uh

00:33:35,200 --> 00:33:38,399
tell the coroutine's machinery when to

00:33:36,960 --> 00:33:40,000
suspense went to resume

00:33:38,399 --> 00:33:42,399
the key color is written in a way that

00:33:40,000 --> 00:33:44,880
it should be possible to even

00:33:42,399 --> 00:33:46,720
add support for things like kjob without

00:33:44,880 --> 00:33:48,559
having to patch qcoro even you just need

00:33:46,720 --> 00:33:51,200
to provide some template specializations

00:33:48,559 --> 00:33:55,919
and it should work

00:33:51,200 --> 00:33:55,919
so i haven't tried it but it should work

00:33:57,360 --> 00:34:01,360
that sounds amazing david is just

00:34:00,080 --> 00:34:04,320
writing reply now

00:34:01,360 --> 00:34:07,200
um so ask one more question one of the

00:34:04,320 --> 00:34:09,760
biggest challenges of asynchronous code

00:34:07,200 --> 00:34:11,359
is managing a lifespan of all the

00:34:09,760 --> 00:34:13,119
objects that you're going to use in your

00:34:11,359 --> 00:34:14,800
callbacks and then your lambda

00:34:13,119 --> 00:34:16,560
and your all your examples you use

00:34:14,800 --> 00:34:18,800
earlier like python and dart

00:34:16,560 --> 00:34:20,320
they just reference everything so it's a

00:34:18,800 --> 00:34:22,399
big problem c plus plus

00:34:20,320 --> 00:34:24,079
how do you resolve this nicely into

00:34:22,399 --> 00:34:25,440
plasma cubed

00:34:24,079 --> 00:34:26,960
well this is what the corrosion is

00:34:25,440 --> 00:34:28,879
really solved for you right because

00:34:26,960 --> 00:34:32,000
whenever you suspend the curtain

00:34:28,879 --> 00:34:32,720
the whole stack is safe to memory so you

00:34:32,000 --> 00:34:34,480
don't need to

00:34:32,720 --> 00:34:36,399
and then it's resumed everything is

00:34:34,480 --> 00:34:38,000
restored and then you use the regular

00:34:36,399 --> 00:34:40,079
like you know whenever you leave

00:34:38,000 --> 00:34:42,800
whenever you uh

00:34:40,079 --> 00:34:43,119
whenever you return from the function it

00:34:42,800 --> 00:34:45,599
uh

00:34:43,119 --> 00:34:47,520
destroys everything right so remember

00:34:45,599 --> 00:34:48,000
you suddenly can start allocating many

00:34:47,520 --> 00:34:51,280
things on

00:34:48,000 --> 00:34:52,639
stack because you don't have to bother

00:34:51,280 --> 00:34:54,720
you don't have to be worried that

00:34:52,639 --> 00:34:56,320
your function will finish and then you

00:34:54,720 --> 00:34:58,079
need to capture everything into lambda

00:34:56,320 --> 00:35:00,079
connected to some signal or

00:34:58,079 --> 00:35:01,680
or passing it to another function right

00:35:00,079 --> 00:35:03,760
so this actually i think makes

00:35:01,680 --> 00:35:05,599
things not only much easier but it

00:35:03,760 --> 00:35:07,680
doesn't allows us to write much

00:35:05,599 --> 00:35:08,720
safer code because you can allocate

00:35:07,680 --> 00:35:11,599
everything on stack so

00:35:08,720 --> 00:35:11,599
no memory leaks

00:35:11,839 --> 00:35:15,680
may be user interfaces where people are

00:35:14,240 --> 00:35:18,800
closing things

00:35:15,680 --> 00:35:21,520
okay um we've got one more question

00:35:18,800 --> 00:35:24,000
and we've got time for it uh ingo asks

00:35:21,520 --> 00:35:26,240
is it possible to cancel that update

00:35:24,000 --> 00:35:31,839
eg if your next title is needed form

00:35:26,240 --> 00:35:31,839
your original example with divorce

00:35:33,359 --> 00:35:38,960
uh you can well

00:35:37,200 --> 00:35:41,040
if you have some other code that's

00:35:38,960 --> 00:35:41,920
executing that that would cancel the bus

00:35:41,040 --> 00:35:44,960
message then

00:35:41,920 --> 00:35:45,839
the the the message would be the reply

00:35:44,960 --> 00:35:48,240
would finish

00:35:45,839 --> 00:35:49,920
and it would the the current team would

00:35:48,240 --> 00:35:53,520
be resumed and then he would have to

00:35:49,920 --> 00:35:55,520
have some error handling so in a way yes

00:35:53,520 --> 00:35:57,119
yes though it's not as straightforward

00:35:55,520 --> 00:35:57,680
this code the code i showed that doesn't

00:35:57,119 --> 00:36:01,119
really

00:35:57,680 --> 00:36:01,119
bother with error checking because

00:36:01,680 --> 00:36:04,640
errors don't happen right

00:36:04,960 --> 00:36:12,560
okay um and how does this interact with

00:36:08,400 --> 00:36:15,839
cpp collo compatibility or extension uh

00:36:12,560 --> 00:36:19,200
i i haven't uh tried the problem is that

00:36:15,839 --> 00:36:20,880
uh i i inspire i found a lot of

00:36:19,200 --> 00:36:23,760
inspiration in cpp corel

00:36:20,880 --> 00:36:25,280
uh but the thing is it depends on the

00:36:23,760 --> 00:36:28,320
return type right so you cannot

00:36:25,280 --> 00:36:30,800
like mix things from cppcoro and qcro

00:36:28,320 --> 00:36:31,920
in a single core routine so this will

00:36:30,800 --> 00:36:33,520
become a bit tricky

00:36:31,920 --> 00:36:36,079
uh which is one of the weaknesses i

00:36:33,520 --> 00:36:37,599
think of the current approach

00:36:36,079 --> 00:36:39,119
to curry teams that you you have to pick

00:36:37,599 --> 00:36:39,599
one library and then basically stick to

00:36:39,119 --> 00:36:42,560
it

00:36:39,599 --> 00:36:42,560
throughout your code base

00:36:47,440 --> 00:36:51,920
okay one more question i do keep coming

00:36:49,839 --> 00:36:53,760
in that's how does this relate to

00:36:51,920 --> 00:36:54,880
standard future and standard promise i

00:36:53,760 --> 00:36:55,599
think you're touching this a little bit

00:36:54,880 --> 00:36:59,040
in your slides

00:36:55,599 --> 00:36:59,040
not none at all not at all

00:37:02,000 --> 00:37:05,280
there is no threading involved right you

00:37:03,520 --> 00:37:07,599
can use threads but

00:37:05,280 --> 00:37:09,040
this you can call away the thread but

00:37:07,599 --> 00:37:11,520
there is inherently no threading in

00:37:09,040 --> 00:37:11,520
coroutines

00:37:12,480 --> 00:37:16,800
cool and i assume you're around for our

00:37:14,640 --> 00:37:18,880
academy to answer questions as they come

00:37:16,800 --> 00:37:18,880
in

00:37:20,079 --> 00:37:24,400
sure cool okay your next talk is in

00:37:23,520 --> 00:37:26,880
three minutes

00:37:24,400 --> 00:37:29,119
i will pass off to to even to be your

00:37:26,880 --> 00:37:32,800
next session host

00:37:29,119 --> 00:37:34,160
but please stay in room two

00:37:32,800 --> 00:37:37,839
thank you bye unless you want to see

00:37:34,160 --> 00:37:37,839

YouTube URL: https://www.youtube.com/watch?v=KKVqFqbXJaU


