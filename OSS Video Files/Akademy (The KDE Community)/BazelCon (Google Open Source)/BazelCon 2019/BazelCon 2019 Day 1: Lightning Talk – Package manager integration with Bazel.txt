Title: BazelCon 2019 Day 1: Lightning Talk â€“ Package manager integration with Bazel
Publication date: 2020-01-15
Playlist: BazelCon 2019
Description: 
	Andreas Herrmann, Tweag event: Bazelcon 2019; re_ty: Publish; product: Open Source - General; fullname: Andreas Herrmann;
Captions: 
	00:00:00,030 --> 00:00:04,799
right our last speaker today is undress

00:00:02,280 --> 00:00:06,720
who will talk about packaged medications

00:00:04,799 --> 00:00:09,410
basal that's the topic is dear to my

00:00:06,720 --> 00:00:12,929
heart take it away

00:00:09,410 --> 00:00:14,910
thank you my name is Andreas I work for

00:00:12,929 --> 00:00:17,100
Twiggy Oh we are a basal community

00:00:14,910 --> 00:00:20,189
expert one of the first basal adopters

00:00:17,100 --> 00:00:23,100
and developer of new features and

00:00:20,189 --> 00:00:25,920
extensions I assume everyone here knows

00:00:23,100 --> 00:00:28,260
about basal one of the great features of

00:00:25,920 --> 00:00:30,420
basal is its support for multi language

00:00:28,260 --> 00:00:31,710
development so you can define targets

00:00:30,420 --> 00:00:33,210
written in many different languages

00:00:31,710 --> 00:00:35,579
combine them together build them all

00:00:33,210 --> 00:00:39,030
with a single command and extend basil

00:00:35,579 --> 00:00:42,480
to support new languages this all works

00:00:39,030 --> 00:00:44,309
great as long as the sources are within

00:00:42,480 --> 00:00:46,559
the same repository but what about

00:00:44,309 --> 00:00:48,480
external dependencies most languages

00:00:46,559 --> 00:00:50,969
come with rich third-party library

00:00:48,480 --> 00:00:53,520
ecosystems many languages come with

00:00:50,969 --> 00:00:55,320
existing package managers dedicated to

00:00:53,520 --> 00:00:56,850
those languages with features like

00:00:55,320 --> 00:01:00,210
dependency resolution version

00:00:56,850 --> 00:01:07,020
compatibility and so on can we make use

00:01:00,210 --> 00:01:08,580
of those within basil so to set the

00:01:07,020 --> 00:01:10,140
stage I'm gonna demonstrate three

00:01:08,580 --> 00:01:12,780
different ways how you could handle

00:01:10,140 --> 00:01:14,460
external dependencies the first is to

00:01:12,780 --> 00:01:15,900
just vendor those dependencies so you

00:01:14,460 --> 00:01:18,689
just copy the source into your

00:01:15,900 --> 00:01:20,490
repository define custom basil targets

00:01:18,689 --> 00:01:22,770
for those this is a very flexible

00:01:20,490 --> 00:01:24,390
approach but it can have a very high

00:01:22,770 --> 00:01:26,100
maintenance cost especially if you want

00:01:24,390 --> 00:01:29,579
to do updates of your dependencies and

00:01:26,100 --> 00:01:32,040
such another way is to automatically

00:01:29,579 --> 00:01:34,020
generate basil targets so you have some

00:01:32,040 --> 00:01:36,119
way of parsing the package definitions

00:01:34,020 --> 00:01:38,369
of your external dependencies and then

00:01:36,119 --> 00:01:40,350
you automatically generate basil targets

00:01:38,369 --> 00:01:43,649
for those for the rules set for your

00:01:40,350 --> 00:01:45,360
language of choice and this is automatic

00:01:43,649 --> 00:01:47,850
so it has a lower maintenance burden on

00:01:45,360 --> 00:01:49,710
updates and such but it can be a lot of

00:01:47,850 --> 00:01:51,450
effort to implement the tool that does

00:01:49,710 --> 00:01:53,640
this automatic generation depending on

00:01:51,450 --> 00:01:57,540
how complex package definitions in your

00:01:53,640 --> 00:01:59,969
language are so the third approach and

00:01:57,540 --> 00:02:01,890
what we think is the best if possible is

00:01:59,969 --> 00:02:04,469
to just integrate the existing package

00:02:01,890 --> 00:02:06,030
manager for that language into basil so

00:02:04,469 --> 00:02:08,039
you just call out to the package manager

00:02:06,030 --> 00:02:11,819
to do dependency resolution version

00:02:08,039 --> 00:02:13,860
resolution and builds if necessary this

00:02:11,819 --> 00:02:15,930
is automatic so updates are

00:02:13,860 --> 00:02:17,850
very low-maintenance it's very

00:02:15,930 --> 00:02:19,860
compatible your package manager should

00:02:17,850 --> 00:02:22,560
work with most packages out there in

00:02:19,860 --> 00:02:24,030
their language a downside can be that

00:02:22,560 --> 00:02:25,620
the dependency graph this generates

00:02:24,030 --> 00:02:27,600
could be more coarse-grained than what

00:02:25,620 --> 00:02:31,860
you might define manually so you could

00:02:27,600 --> 00:02:33,990
lose out on some build parallelism so

00:02:31,860 --> 00:02:35,580
let me introduce rules Haskell at week

00:02:33,990 --> 00:02:37,590
we develop rules aesculus basel

00:02:35,580 --> 00:02:39,420
extension for haskell for those who

00:02:37,590 --> 00:02:41,070
don't know it's a strongly typed purely

00:02:39,420 --> 00:02:42,780
functional lazily really lazily

00:02:41,070 --> 00:02:46,740
evaluated general-purpose programming

00:02:42,780 --> 00:02:48,480
language historically we used to use the

00:02:46,740 --> 00:02:51,000
second approach from the previous slide

00:02:48,480 --> 00:02:53,580
so we parse the package definitions for

00:02:51,000 --> 00:02:55,800
Haskell dependencies we then generated

00:02:53,580 --> 00:02:58,530
regular rules Haskell asked library

00:02:55,800 --> 00:03:00,630
binary targets but we found that it is

00:02:58,530 --> 00:03:02,430
very difficult to emulate all the things

00:03:00,630 --> 00:03:04,590
the package manager does with an

00:03:02,430 --> 00:03:06,570
implementation in basil especially when

00:03:04,590 --> 00:03:09,720
it comes to supporting Linux Mac OS and

00:03:06,570 --> 00:03:11,040
windows simultaneously so what we do now

00:03:09,720 --> 00:03:14,280
is to integrate with the existing

00:03:11,040 --> 00:03:16,440
package manager there are two tools that

00:03:14,280 --> 00:03:19,260
are important here one is COBOL and the

00:03:16,440 --> 00:03:21,030
other one is stack for the purposes of

00:03:19,260 --> 00:03:24,660
this talk about is the Haskell build

00:03:21,030 --> 00:03:27,030
system we use to build external packages

00:03:24,660 --> 00:03:28,590
and stack is the package manager that we

00:03:27,030 --> 00:03:30,450
use to do a version resolution

00:03:28,590 --> 00:03:33,570
dependency resolution and fetching of

00:03:30,450 --> 00:03:36,390
external sources users interact with

00:03:33,570 --> 00:03:39,959
this with two different components one

00:03:36,390 --> 00:03:41,790
is cabal rules these are build rules

00:03:39,959 --> 00:03:43,980
that call out to the cabal build system

00:03:41,790 --> 00:03:46,980
to build third-party packages or any

00:03:43,980 --> 00:03:48,660
cabal packages really these are regular

00:03:46,980 --> 00:03:50,340
build rules so you can use them in any

00:03:48,660 --> 00:03:53,790
build file so you could use this for

00:03:50,340 --> 00:03:57,030
vendor packages or legacy packages and

00:03:53,790 --> 00:04:00,180
it integrates with the regular rules ask

00:03:57,030 --> 00:04:06,030
library in Haskell veneering and then

00:04:00,180 --> 00:04:11,610
the second interface is the repository

00:04:06,030 --> 00:04:13,350
rule stack snapshot where we call out to

00:04:11,610 --> 00:04:14,970
the stack package manager to do

00:04:13,350 --> 00:04:17,250
resolution of dependencies and

00:04:14,970 --> 00:04:19,079
inversions and fetching those external

00:04:17,250 --> 00:04:22,470
sources and then this is a repository

00:04:19,079 --> 00:04:24,800
rule so it defines basil it generates

00:04:22,470 --> 00:04:27,510
build files with basil targets in them

00:04:24,800 --> 00:04:30,510
generating these cabal rule targets that

00:04:27,510 --> 00:04:35,040
before if you're familiar with rules jvm

00:04:30,510 --> 00:04:37,710
external this is somewhat similar and

00:04:35,040 --> 00:04:39,120
yeah annex use case example is this on

00:04:37,710 --> 00:04:41,990
the right side of the slide so you can

00:04:39,120 --> 00:04:47,370
also introduce the library dependencies

00:04:41,990 --> 00:04:49,320
stack has curated lists of compatible

00:04:47,370 --> 00:04:55,890
versions you can pick the snapshot that

00:04:49,320 --> 00:04:57,840
you want to use for an example of what a

00:04:55,890 --> 00:04:59,430
dependency graph might look like this is

00:04:57,840 --> 00:05:01,200
a subset of the dependency graph

00:04:59,430 --> 00:05:04,470
generated from the call on the right

00:05:01,200 --> 00:05:07,470
side of the slide pros to this approach

00:05:04,470 --> 00:05:09,120
we are using the existing package

00:05:07,470 --> 00:05:12,900
manager infrastructure for the huskily

00:05:09,120 --> 00:05:15,390
co system so this is very compatible

00:05:12,900 --> 00:05:18,180
most packages should work with this and

00:05:15,390 --> 00:05:19,950
it's relatively low maintenance burden

00:05:18,180 --> 00:05:22,470
because all these package manager tools

00:05:19,950 --> 00:05:25,110
are already implemented the dependency

00:05:22,470 --> 00:05:26,820
graph on the level of packages is still

00:05:25,110 --> 00:05:28,380
visible to basil so basil can do

00:05:26,820 --> 00:05:30,660
parallelization and caching and all

00:05:28,380 --> 00:05:32,460
those things on that level but of course

00:05:30,660 --> 00:05:33,780
it's more or well it can be more

00:05:32,460 --> 00:05:35,430
coarse-grained than what you might write

00:05:33,780 --> 00:05:37,710
by hand so you're losing potentially

00:05:35,430 --> 00:05:40,230
losing out on some build parallelism but

00:05:37,710 --> 00:05:42,120
we find that for third party haskell

00:05:40,230 --> 00:05:51,000
dependencies at least this is a a good

00:05:42,120 --> 00:05:53,070
trade-off so finally our key insights in

00:05:51,000 --> 00:05:55,290
this if the package manager for your

00:05:53,070 --> 00:05:57,690
language can be made to avoid local

00:05:55,290 --> 00:05:59,580
state then it can be called in a built

00:05:57,690 --> 00:06:02,070
action just like any other build tool

00:05:59,580 --> 00:06:04,320
like the compiler or something else and

00:06:02,070 --> 00:06:05,970
we find that the most efficient way to

00:06:04,320 --> 00:06:09,210
integrate with the existing library

00:06:05,970 --> 00:06:11,310
ecosystem for for your language of

00:06:09,210 --> 00:06:12,750
choice is to just wrap the existing

00:06:11,310 --> 00:06:16,190
package manager into basil instead of

00:06:12,750 --> 00:06:19,200
trying to re-implement it within basil

00:06:16,190 --> 00:06:21,840
yep that's all I had to say if you're

00:06:19,200 --> 00:06:23,730
interested in any of the rule sets we

00:06:21,840 --> 00:06:26,220
are implementing that's rules haskell

00:06:23,730 --> 00:06:27,720
rules next packages and rules sh and

00:06:26,220 --> 00:06:30,340
also check out how skilled have built in

00:06:27,720 --> 00:06:36,920
tweak that i oh thanks

00:06:30,340 --> 00:06:36,920
[Applause]

00:06:56,330 --> 00:07:03,630
so the question is what about very large

00:07:00,930 --> 00:07:05,040
sets of external dependencies if you

00:07:03,630 --> 00:07:07,320
change the dependency in there you're

00:07:05,040 --> 00:07:08,730
going to invalidate a lot of targets and

00:07:07,320 --> 00:07:11,910
rebuilt them and and how do we deal with

00:07:08,730 --> 00:07:13,170
this so we have use cases with I don't

00:07:11,910 --> 00:07:18,330
know the exact number but on the order

00:07:13,170 --> 00:07:21,030
of 100 dependencies and I mean the

00:07:18,330 --> 00:07:23,370
problem exists either way really like if

00:07:21,030 --> 00:07:24,810
you change the package deepen the

00:07:23,370 --> 00:07:26,100
dependency graph of your external

00:07:24,810 --> 00:07:33,690
dependencies you're going to have to

00:07:26,100 --> 00:07:37,050
rebuild it in some form no but I mean

00:07:33,690 --> 00:07:38,910
those generate regular basil targets the

00:07:37,050 --> 00:07:40,590
Haskell cabal library is a regular basil

00:07:38,910 --> 00:07:42,780
rule so all the regular caching and

00:07:40,590 --> 00:07:45,090
everything applies so if you only change

00:07:42,780 --> 00:07:46,800
something at the leaf of the dependency

00:07:45,090 --> 00:07:56,700
graph it's not going to rebuild anything

00:07:46,800 --> 00:07:57,960
else yeah so that works right I didn't

00:07:56,700 --> 00:07:59,820
mention that so that's a fairly recent

00:07:57,960 --> 00:08:02,010
thing we did there was a discussion on

00:07:59,820 --> 00:08:05,610
the issue tracker of basil Skylab about

00:08:02,010 --> 00:08:09,630
this it's a tool chain for POSIX like

00:08:05,610 --> 00:08:10,710
standard shell tools and especially for

00:08:09,630 --> 00:08:14,010
this work

00:08:10,710 --> 00:08:15,810
Haskell allows custom build scripts so

00:08:14,010 --> 00:08:17,310
you can have packages which call out to

00:08:15,810 --> 00:08:19,290
auto tools configure files and stuff

00:08:17,310 --> 00:08:21,479
like that and if we want to do this in

00:08:19,290 --> 00:08:22,919
regular build actions then we somehow

00:08:21,479 --> 00:08:26,010
need these standard shell tools

00:08:22,919 --> 00:08:27,510
available for configure to find so with

00:08:26,010 --> 00:08:30,140
rules as age we defined a tool chain

00:08:27,510 --> 00:08:32,490
that wraps the standard shell tools

00:08:30,140 --> 00:08:33,960
currently it assumes that they are

00:08:32,490 --> 00:08:35,490
installed globally somewhere so it gives

00:08:33,960 --> 00:08:36,690
you just a list of paths and then

00:08:35,490 --> 00:08:39,780
generates a path environment variable

00:08:36,690 --> 00:08:44,089
that is passed on to the configure

00:08:39,780 --> 00:08:44,089
script and then it just works

00:08:45,840 --> 00:08:57,100
but pardon me we well the question is do

00:08:54,130 --> 00:08:58,810
we trim unused dependencies I mean if

00:08:57,100 --> 00:09:00,970
none of the targets you're building

00:08:58,810 --> 00:09:03,279
depends transitively on a particular

00:09:00,970 --> 00:09:05,560
external library it's not going to be

00:09:03,279 --> 00:09:07,360
built the definition is still going to

00:09:05,560 --> 00:09:14,350
be there somewhere but it's not going to

00:09:07,360 --> 00:09:15,940
be built no so so they use the user

00:09:14,350 --> 00:09:18,279
interface - this is for the external

00:09:15,940 --> 00:09:20,020
packages you're using you define you

00:09:18,279 --> 00:09:22,210
list the targets that you are directly

00:09:20,020 --> 00:09:23,470
depending on and then we call it - stack

00:09:22,210 --> 00:09:25,390
which generates the transitive

00:09:23,470 --> 00:09:27,790
dependency graph of Basel targets and

00:09:25,390 --> 00:09:29,170
then if in your actual build files

00:09:27,790 --> 00:09:32,950
somewhere you depend on say in this

00:09:29,170 --> 00:09:34,240
example servant and you build this then

00:09:32,950 --> 00:09:35,560
it's going to build all transitive

00:09:34,240 --> 00:09:38,430
dependencies that come through servant

00:09:35,560 --> 00:09:40,330
but it's not going to build any

00:09:38,430 --> 00:09:43,020
dependency that is not in this

00:09:40,330 --> 00:09:43,020
transitive closure

00:09:58,350 --> 00:10:03,550
you mean the version of it right so here

00:10:01,870 --> 00:10:06,040
we exploit actually feature of stack

00:10:03,550 --> 00:10:08,140
itself which is that it has snapshots of

00:10:06,040 --> 00:10:10,120
pinned versions that are all compatible

00:10:08,140 --> 00:10:13,600
so in the very bottom of this it says

00:10:10,120 --> 00:10:16,200
LTS - thirteen point eight what this is

00:10:13,600 --> 00:10:19,360
is a long list of packaged versions

00:10:16,200 --> 00:10:20,530
there's numbers that are known to work

00:10:19,360 --> 00:10:23,530
together

00:10:20,530 --> 00:10:24,850
so this pins the versions of all the

00:10:23,530 --> 00:10:27,910
transitive dependencies you're going to

00:10:24,850 --> 00:10:29,290
use and you can do manual overrides if

00:10:27,910 --> 00:10:31,300
you want to overwrite a version or a

00:10:29,290 --> 00:10:34,140
vendor package or whatever so that

00:10:31,300 --> 00:10:34,140
that's flexible enough

00:10:43,390 --> 00:10:49,210
all right ladies and gentleman that

00:10:45,620 --> 00:10:51,590
concludes our first day of basic one

00:10:49,210 --> 00:10:53,090
thank you for great talks and and great

00:10:51,590 --> 00:10:55,910
participation I really enjoyed it

00:10:53,090 --> 00:10:58,970
hope you did too and we will have a

00:10:55,910 --> 00:11:03,080
reception there in the cafeteria over

00:10:58,970 --> 00:11:06,350
there Liberia from now from 5:30 until

00:11:03,080 --> 00:11:10,180
7:30 so the drinks snacks thing like

00:11:06,350 --> 00:11:10,180
that welcome

00:11:18,010 --> 00:11:24,440

YouTube URL: https://www.youtube.com/watch?v=_7IIc3ZTwKk


