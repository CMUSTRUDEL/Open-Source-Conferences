Title: BazelCon 2019 Day 1: Lightning Talk â€“ Why Not To Have Bazel Dependencies
Publication date: 2020-01-15
Playlist: BazelCon 2019
Description: 
	Alex Eagle and Greg Magolan, Google event: Bazelcon 2019; re_ty: Publish; product: Open Source - General; fullname: Alex Eagle, Greg Magolan;
Captions: 
	00:00:01,639 --> 00:00:06,750
hello everyone thanks for coming we're

00:00:04,680 --> 00:00:10,650
gonna talk today about why not to have

00:00:06,750 --> 00:00:13,679
basal dependencies my name is Greg

00:00:10,650 --> 00:00:15,750
mobile and I am co-founder of aspect dev

00:00:13,679 --> 00:00:18,720
and we are a basal focused consulting

00:00:15,750 --> 00:00:20,279
company we work with small to large

00:00:18,720 --> 00:00:23,250
companies to help them plan and execute

00:00:20,279 --> 00:00:27,359
basal migrations I am also a container

00:00:23,250 --> 00:00:30,779
of rules nodejs so anyone using it talk

00:00:27,359 --> 00:00:32,279
to me after my name is Alex I work at

00:00:30,779 --> 00:00:36,750
Google I'm also working on rules nodejs

00:00:32,279 --> 00:00:38,010
with Greg and so before we can talk

00:00:36,750 --> 00:00:39,809
about dependencies we have to talk about

00:00:38,010 --> 00:00:41,489
how you release rule sets so to give a

00:00:39,809 --> 00:00:42,780
little bit of context as authors of

00:00:41,489 --> 00:00:44,610
rules nodejs we're pretty familiar with

00:00:42,780 --> 00:00:45,510
how to write a rule set for basel I know

00:00:44,610 --> 00:00:46,860
you're probably not all rule set

00:00:45,510 --> 00:00:48,989
maintainer x' but even if your users I

00:00:46,860 --> 00:00:50,879
hope this is interesting for you so how

00:00:48,989 --> 00:00:52,680
does a rule set publish itself for you

00:00:50,879 --> 00:00:54,390
to use it so this a very simple way

00:00:52,680 --> 00:00:57,210
which Florian talked about earlier in

00:00:54,390 --> 00:00:59,190
the talked about the Federation is that

00:00:57,210 --> 00:01:01,770
you simply have an HTTP archive or a git

00:00:59,190 --> 00:01:04,140
repository rule that a user fetches and

00:01:01,770 --> 00:01:05,610
it just gets a commit or a tag something

00:01:04,140 --> 00:01:06,479
from the read from the archive and you

00:01:05,610 --> 00:01:07,860
end up with getting the whole source

00:01:06,479 --> 00:01:09,270
tree every time

00:01:07,860 --> 00:01:10,979
whatever transitive dependencies are in

00:01:09,270 --> 00:01:12,299
that project you get them there's no

00:01:10,979 --> 00:01:13,380
semantic versioning there so it's kind

00:01:12,299 --> 00:01:14,820
of hard to understand whether the

00:01:13,380 --> 00:01:16,140
version is even greater or less than

00:01:14,820 --> 00:01:19,770
something else that you see or whether

00:01:16,140 --> 00:01:21,840
it's safe to upgrade the the checksum

00:01:19,770 --> 00:01:22,950
can be unstable like if github changes

00:01:21,840 --> 00:01:25,380
their front ends which they did once

00:01:22,950 --> 00:01:26,670
then all the check sums change and so

00:01:25,380 --> 00:01:29,220
like we think this is kind of hard for

00:01:26,670 --> 00:01:30,540
users to use even if even if you're okay

00:01:29,220 --> 00:01:32,189
with using them this way

00:01:30,540 --> 00:01:34,860
Florine mentioned at the Federation is

00:01:32,189 --> 00:01:35,490
going to require that you instead start

00:01:34,860 --> 00:01:37,770
using semver

00:01:35,490 --> 00:01:40,439
and so what we proposed here is that

00:01:37,770 --> 00:01:41,939
it's better to have a release archive so

00:01:40,439 --> 00:01:43,619
some sort of packaging rule like like

00:01:41,939 --> 00:01:44,729
florian talked about you have a smaller

00:01:43,619 --> 00:01:47,119
download size because you're not

00:01:44,729 --> 00:01:49,770
fetching tests and documentation and

00:01:47,119 --> 00:01:52,229
things like that you get the stable shot

00:01:49,770 --> 00:01:53,520
256 which is handy because it means that

00:01:52,229 --> 00:01:55,649
part of our release process can actually

00:01:53,520 --> 00:01:57,000
give you the new snippet that goes in

00:01:55,649 --> 00:01:58,320
your workspace file including the

00:01:57,000 --> 00:02:00,689
checksum because we know it before we

00:01:58,320 --> 00:02:02,460
publish it and we can use cember which

00:02:00,689 --> 00:02:04,259
is nice semantic versioning means that

00:02:02,460 --> 00:02:05,280
users can rely on like they can have a

00:02:04,259 --> 00:02:07,439
keep on the stay on the stable release

00:02:05,280 --> 00:02:08,759
you can publish our CS and betas

00:02:07,439 --> 00:02:10,979
basically you can put information in the

00:02:08,759 --> 00:02:12,239
version number that's useful and we like

00:02:10,979 --> 00:02:13,599
to put release notes there too and

00:02:12,239 --> 00:02:15,189
mention the breaking changes

00:02:13,599 --> 00:02:16,659
so the reason we're talking about this

00:02:15,189 --> 00:02:18,069
and the dependency talk is simply that

00:02:16,659 --> 00:02:20,590
that's a prerequisite for what we want

00:02:18,069 --> 00:02:21,579
to get to so the problem we really

00:02:20,590 --> 00:02:23,230
wanted to walk talk about is this

00:02:21,579 --> 00:02:24,819
dependency problem and it's the basic

00:02:23,230 --> 00:02:25,930
motivating thing that the Federation is

00:02:24,819 --> 00:02:27,670
talking about and you can go back and

00:02:25,930 --> 00:02:29,469
watch Florian's talk where he did a

00:02:27,670 --> 00:02:31,359
great job explaining the problem i can

00:02:29,469 --> 00:02:32,950
add a little bit of color there in

00:02:31,359 --> 00:02:35,590
google internal we don't have this

00:02:32,950 --> 00:02:37,480
problem we do have a workspace file

00:02:35,590 --> 00:02:40,030
which most Googlers maybe have never

00:02:37,480 --> 00:02:41,709
seen it only contains toolchain config

00:02:40,030 --> 00:02:42,730
rules and it's like eight of them and

00:02:41,709 --> 00:02:43,810
that's the entire thing for all of

00:02:42,730 --> 00:02:46,150
Google engineers that's the workspace

00:02:43,810 --> 00:02:47,290
file so your workspace files are much

00:02:46,150 --> 00:02:48,609
more complicated and you have these

00:02:47,290 --> 00:02:50,230
problems and it's basically a less

00:02:48,609 --> 00:02:52,299
mature solution because we haven't been

00:02:50,230 --> 00:02:53,739
using it ourselves Googlers are also

00:02:52,299 --> 00:02:55,419
sort of biased that because we can

00:02:53,739 --> 00:02:56,500
depend on everything and we're we're

00:02:55,419 --> 00:02:58,629
sure that all the tool trains are wired

00:02:56,500 --> 00:02:59,919
up correctly we do and so we build lots

00:02:58,629 --> 00:03:01,739
of things from source we have remote

00:02:59,919 --> 00:03:04,689
execution remote caching it works fine

00:03:01,739 --> 00:03:06,010
but our model when we approach rule sets

00:03:04,689 --> 00:03:07,329
would be oh well sure just make

00:03:06,010 --> 00:03:09,370
dependencies on all the languages that

00:03:07,329 --> 00:03:10,510
you might need and those transitive

00:03:09,370 --> 00:03:12,010
dependencies are of course a burden on

00:03:10,510 --> 00:03:16,329
you the users your workspace file is

00:03:12,010 --> 00:03:18,129
complicated there's no way if even if we

00:03:16,329 --> 00:03:19,269
had a better way to write the workspace

00:03:18,129 --> 00:03:21,370
file we're missing a lot of information

00:03:19,269 --> 00:03:23,079
which is that we don't know what range

00:03:21,370 --> 00:03:24,879
of a certain dependency has supported so

00:03:23,079 --> 00:03:27,310
Florian talked about rules go depending

00:03:24,879 --> 00:03:28,720
on basil skylib for example rules go

00:03:27,310 --> 00:03:29,979
probably works with a range of skylib

00:03:28,720 --> 00:03:31,030
versions but you only know one of them

00:03:29,979 --> 00:03:32,349
which is the one that I currently says

00:03:31,030 --> 00:03:34,720
it depends on which makes it harder for

00:03:32,349 --> 00:03:38,379
you to do the computation to resolve

00:03:34,720 --> 00:03:39,609
what what version you can use and so the

00:03:38,379 --> 00:03:41,349
Federation we're looking forward to the

00:03:39,609 --> 00:03:43,060
Federation I love that the basil team is

00:03:41,349 --> 00:03:44,439
attacking this problem there's a lot of

00:03:43,060 --> 00:03:46,120
limitations as Florian said they're

00:03:44,439 --> 00:03:47,530
really just trying to find like a small

00:03:46,120 --> 00:03:49,599
thing that they can do in the current

00:03:47,530 --> 00:03:50,919
semantics that makes things better but

00:03:49,599 --> 00:03:52,479
users still run in the dependency hell

00:03:50,919 --> 00:03:53,859
either you're using a rule sets that

00:03:52,479 --> 00:03:56,290
it's not part of the Federation you

00:03:53,859 --> 00:03:57,579
decide not to use the Federation or the

00:03:56,290 --> 00:03:58,870
other problem is that rule sets with

00:03:57,579 --> 00:04:00,669
complicated dependencies will make it

00:03:58,870 --> 00:04:01,689
hard for the Federation to find a single

00:04:00,669 --> 00:04:03,549
version of all the stuff that works

00:04:01,689 --> 00:04:05,650
together and so the problem may move

00:04:03,549 --> 00:04:06,729
from you as users to the Federation but

00:04:05,650 --> 00:04:08,199
it's looking to be impossible for them

00:04:06,729 --> 00:04:10,000
to cut a release if the dependency graph

00:04:08,199 --> 00:04:13,719
just can't be resolved down to a single

00:04:10,000 --> 00:04:15,250
version so we have a few insights that

00:04:13,719 --> 00:04:16,509
we think are useful the main one is that

00:04:15,250 --> 00:04:18,729
development versus runtime dependencies

00:04:16,509 --> 00:04:21,310
this is not really a concept that that

00:04:18,729 --> 00:04:24,610
Mazal has built in other other

00:04:21,310 --> 00:04:25,719
ecosystems do and so the idea is not all

00:04:24,610 --> 00:04:27,070
users actually want it to build

00:04:25,719 --> 00:04:27,450
everything from source and so if you

00:04:27,070 --> 00:04:29,850
ship

00:04:27,450 --> 00:04:31,680
then you don't need the the dependency

00:04:29,850 --> 00:04:33,900
that you have to show up for users and

00:04:31,680 --> 00:04:35,430
so for example we use go and some of the

00:04:33,900 --> 00:04:36,810
stuff that in rules nodejs but

00:04:35,430 --> 00:04:39,900
javascript developers do not want to

00:04:36,810 --> 00:04:41,580
download the go SDK it's 120 Meg's so we

00:04:39,900 --> 00:04:44,460
ship little 5 megabyte binaries for each

00:04:41,580 --> 00:04:45,450
of the 3 supported platforms this means

00:04:44,460 --> 00:04:48,420
that users don't have to download that

00:04:45,450 --> 00:04:50,940
stuff we also do other tricks so in our

00:04:48,420 --> 00:04:53,580
build files we have a range like a begin

00:04:50,940 --> 00:04:54,930
and end internal fence as comments and

00:04:53,580 --> 00:04:56,760
then we cut those out when we publish

00:04:54,930 --> 00:04:59,190
the archive that allows us to cut depths

00:04:56,760 --> 00:05:00,900
like basil like Star doc so we generate

00:04:59,190 --> 00:05:02,430
documentation from api's we don't want

00:05:00,900 --> 00:05:04,080
users to have load statements show up in

00:05:02,430 --> 00:05:05,370
the files that they fetch that require

00:05:04,080 --> 00:05:07,050
Star doc because then users need to

00:05:05,370 --> 00:05:08,700
fetch I don't know Java and Python and

00:05:07,050 --> 00:05:09,840
like everything else very quickly you

00:05:08,700 --> 00:05:13,380
spaghetti out to get all of the

00:05:09,840 --> 00:05:14,850
dependencies so very quickly if you're a

00:05:13,380 --> 00:05:16,470
rule author and you introduce a

00:05:14,850 --> 00:05:17,790
transitive DEP but you know this happens

00:05:16,470 --> 00:05:19,170
because your integration test you had to

00:05:17,790 --> 00:05:21,240
updated workspace file that's a red flag

00:05:19,170 --> 00:05:22,320
maybe you shouldn't do that or you have

00:05:21,240 --> 00:05:24,030
to update you read me maybe you

00:05:22,320 --> 00:05:25,230
shouldn't do that so we like basically

00:05:24,030 --> 00:05:27,540
try not to take to penance ease if you

00:05:25,230 --> 00:05:28,770
can avoid it also there's a problem that

00:05:27,540 --> 00:05:29,760
you it's easy to accidentally see it

00:05:28,770 --> 00:05:31,230
dependency on something that's less

00:05:29,760 --> 00:05:32,550
stable than your package and then that

00:05:31,230 --> 00:05:34,470
just doesn't work because users end up

00:05:32,550 --> 00:05:37,890
needing the unstable bits to run your

00:05:34,470 --> 00:05:39,930
stable thing there's a separate approach

00:05:37,890 --> 00:05:41,640
I should have pointed out that that

00:05:39,930 --> 00:05:43,410
fencing obviously requires that you you

00:05:41,640 --> 00:05:46,470
run a packaging tool you can't just just

00:05:43,410 --> 00:05:47,310
have users download your sources so in

00:05:46,470 --> 00:05:49,200
other approaches you can have a

00:05:47,310 --> 00:05:50,460
third-party directory basil itself does

00:05:49,200 --> 00:05:51,720
this for some things so one example

00:05:50,460 --> 00:05:53,970
would be if you just need some function

00:05:51,720 --> 00:05:55,620
some skylib don't have a dependency on

00:05:53,970 --> 00:05:57,000
skylib that usually shows up for users

00:05:55,620 --> 00:05:58,500
just copy the functions in that you need

00:05:57,000 --> 00:06:00,660
and put them and properly vendor them

00:05:58,500 --> 00:06:02,040
into your repo with licensing protocol

00:06:00,660 --> 00:06:03,780
buffers like the worker protocol is a

00:06:02,040 --> 00:06:04,860
good example for this obviously you

00:06:03,780 --> 00:06:06,420
can't do this all the time it's pretty

00:06:04,860 --> 00:06:07,890
limited providers have to come as

00:06:06,420 --> 00:06:09,660
symbols from the repository that it says

00:06:07,890 --> 00:06:12,600
so if you make a copy of a skylib file

00:06:09,660 --> 00:06:14,850
with a provider it's not gonna work and

00:06:12,600 --> 00:06:16,560
the case study so way I work in rolls

00:06:14,850 --> 00:06:18,030
closure and a bunch of people from

00:06:16,560 --> 00:06:19,080
tensorflow happened to depend on it just

00:06:18,030 --> 00:06:20,430
because there's a load statement in

00:06:19,080 --> 00:06:21,630
there probably shouldn't have been it

00:06:20,430 --> 00:06:24,840
breaks our ability to make breaking

00:06:21,630 --> 00:06:26,250
changes and so I have an issue open for

00:06:24,840 --> 00:06:31,020
that and I'll like Greg talk about some

00:06:26,250 --> 00:06:33,960
more case studies thanks Alex so I'm

00:06:31,020 --> 00:06:36,150
just gonna that's an example of a issue

00:06:33,960 --> 00:06:37,920
intense flow I will quickly run you

00:06:36,150 --> 00:06:39,450
through what we do at ROS know just

00:06:37,920 --> 00:06:40,430
about everything else talks about right

00:06:39,450 --> 00:06:42,290
there

00:06:40,430 --> 00:06:43,850
we want to ship fewer translated ester

00:06:42,290 --> 00:06:45,460
users and we want to make it easier for

00:06:43,850 --> 00:06:48,199
them to manage the tips that we do have

00:06:45,460 --> 00:06:50,360
this is our workspace we have lots of

00:06:48,199 --> 00:06:51,770
depths which is fine I'll just point on

00:06:50,360 --> 00:06:54,110
one of them there's the rules go DEP

00:06:51,770 --> 00:06:54,680
which we use to build the dev server and

00:06:54,110 --> 00:06:56,330
go

00:06:54,680 --> 00:06:59,210
so it's performant I actually share that

00:06:56,330 --> 00:07:02,120
code with g3 Google 3 and we don't want

00:06:59,210 --> 00:07:03,320
to pass that to our users because our

00:07:02,120 --> 00:07:04,970
user said they don't want to build a go

00:07:03,320 --> 00:07:06,410
program they just want to build the

00:07:04,970 --> 00:07:09,050
binary so when we started really seeing

00:07:06,410 --> 00:07:12,229
artifacts so we actually put the output

00:07:09,050 --> 00:07:13,490
go binaries into our artifacts so users

00:07:12,229 --> 00:07:16,520
can just use the binaries instead of

00:07:13,490 --> 00:07:18,680
depending on rules go we also put the

00:07:16,520 --> 00:07:21,139
guards in as Alice mentioned and this is

00:07:18,680 --> 00:07:22,850
an example of what that looks like which

00:07:21,139 --> 00:07:24,050
a package until would take out that load

00:07:22,850 --> 00:07:28,340
statement you wouldn't see that and

00:07:24,050 --> 00:07:29,600
they're really sort of fact so we

00:07:28,340 --> 00:07:32,419
actually do release multiple release

00:07:29,600 --> 00:07:33,919
artifice I should mention we over we

00:07:32,419 --> 00:07:36,289
hijacked NPM we published some of our

00:07:33,919 --> 00:07:37,130
rules via NPM so if you want to get

00:07:36,289 --> 00:07:39,139
Tia's library you would actually

00:07:37,130 --> 00:07:43,880
download the basil typescript NPM

00:07:39,139 --> 00:07:45,080
package and this means that users can

00:07:43,880 --> 00:07:47,210
use the package manager that they

00:07:45,080 --> 00:07:50,419
already know namely NPM and yarn to get

00:07:47,210 --> 00:07:51,650
the rules that they want so the result

00:07:50,419 --> 00:07:53,120
of this is this is what a user would see

00:07:51,650 --> 00:07:55,789
in their workspace this is from our

00:07:53,120 --> 00:07:58,150
repository and there's not a lot of

00:07:55,789 --> 00:08:00,650
depth rules nodejs has no transit adepts

00:07:58,150 --> 00:08:04,340
there's a yarn install right there which

00:08:00,650 --> 00:08:07,280
is a repository rule the rules that come

00:08:04,340 --> 00:08:09,169
from NPM our there's a step there dunst

00:08:07,280 --> 00:08:10,639
all those and in this case basil

00:08:09,169 --> 00:08:12,110
protractor which is a protractor rule

00:08:10,639 --> 00:08:13,940
actually depends on rules web testing

00:08:12,110 --> 00:08:15,470
and there's some initialization steps

00:08:13,940 --> 00:08:18,500
there so you can't get rid of every kind

00:08:15,470 --> 00:08:21,919
of DEP but you can make it better for

00:08:18,500 --> 00:08:24,349
users this is an example package JSON

00:08:21,919 --> 00:08:26,449
file there's four packages there of

00:08:24,349 --> 00:08:28,130
rules that we publish there's also a

00:08:26,449 --> 00:08:30,820
couple of rules that come in

00:08:28,130 --> 00:08:35,300
automatically because we auto generate

00:08:30,820 --> 00:08:38,089
rules based on bin at the bin attribute

00:08:35,300 --> 00:08:39,050
and the package JSON for some packages

00:08:38,089 --> 00:08:40,729
so if you get the Mokka

00:08:39,050 --> 00:08:46,209
package you automatically get a mocha

00:08:40,729 --> 00:08:48,230
test rule without any extra effort so

00:08:46,209 --> 00:08:50,150
it's a bit strange to override your

00:08:48,230 --> 00:08:51,950
package manager but we found that NPM is

00:08:50,150 --> 00:08:52,690
already great at fetching dependencies

00:08:51,950 --> 00:08:55,330
and handling

00:08:52,690 --> 00:08:58,020
peps and so we utilize this for the

00:08:55,330 --> 00:09:01,930
Basel rules and it also means that

00:08:58,020 --> 00:09:03,790
because we have my teeth at transit of

00:09:01,930 --> 00:09:06,160
depths not leaked so for example if a

00:09:03,790 --> 00:09:07,420
user is using the typescript rule it's

00:09:06,160 --> 00:09:08,740
pretty easy to be sure that they're not

00:09:07,420 --> 00:09:11,050
going to depend on rules web testing if

00:09:08,740 --> 00:09:12,400
they don't need the karma rule also

00:09:11,050 --> 00:09:15,180
means we have smaller release artifacts

00:09:12,400 --> 00:09:18,190
because there's there's more of those

00:09:15,180 --> 00:09:19,810
and for us that means that we only need

00:09:18,190 --> 00:09:21,490
to maintain a small set of rules for the

00:09:19,810 --> 00:09:25,270
key packages that really need special

00:09:21,490 --> 00:09:26,800
cases such as roll-up and cursor and the

00:09:25,270 --> 00:09:28,870
community can actually contribute rules

00:09:26,800 --> 00:09:30,550
just the NPM without actually overriding

00:09:28,870 --> 00:09:34,450
or without polar best thing is a

00:09:30,550 --> 00:09:39,100
repository okay so to quickly wrap

00:09:34,450 --> 00:09:40,630
things up I think as rule offers we

00:09:39,100 --> 00:09:42,940
should think about making rules easy to

00:09:40,630 --> 00:09:44,770
consume and to use which means think

00:09:42,940 --> 00:09:46,570
about which transmitter depths you're

00:09:44,770 --> 00:09:49,080
going to push on to your users and don't

00:09:46,570 --> 00:09:52,360
push more than necessary and we want to

00:09:49,080 --> 00:09:54,670
if possible provide users with Sun bar

00:09:52,360 --> 00:09:56,560
releases with changelogs and that makes

00:09:54,670 --> 00:09:59,890
it possible to reduce the transmitter

00:09:56,560 --> 00:10:01,330
depths as well in that case as users you

00:09:59,890 --> 00:10:02,940
should know that not all recessed you

00:10:01,330 --> 00:10:05,680
have really started fast at this point

00:10:02,940 --> 00:10:08,440
and don't be afraid to make

00:10:05,680 --> 00:10:11,340
contributions or issues to rule sets if

00:10:08,440 --> 00:10:14,320
you have issues the translator tips and

00:10:11,340 --> 00:10:15,790
moving forward I think oh we think the

00:10:14,320 --> 00:10:17,550
ecosystem is maturing different rule

00:10:15,790 --> 00:10:19,720
sets are in different levels of maturity

00:10:17,550 --> 00:10:21,550
as though as mentioned the Federation is

00:10:19,720 --> 00:10:24,190
a great step in the right direction to

00:10:21,550 --> 00:10:26,110
make it easier for users to manage their

00:10:24,190 --> 00:10:28,780
transitive dips and to clean up the

00:10:26,110 --> 00:10:31,930
worstest file but there's probably lots

00:10:28,780 --> 00:10:33,460
of room for improvement and hopefully

00:10:31,930 --> 00:10:37,480
we'll all converge on best practices the

00:10:33,460 --> 00:10:39,490
rule offers so thank you very much and

00:10:37,480 --> 00:10:45,809
that's everything

00:10:39,490 --> 00:10:45,809

YouTube URL: https://www.youtube.com/watch?v=2KzOLddhdoI


