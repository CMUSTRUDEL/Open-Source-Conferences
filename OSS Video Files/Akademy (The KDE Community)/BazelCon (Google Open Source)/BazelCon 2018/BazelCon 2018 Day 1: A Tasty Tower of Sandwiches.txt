Title: BazelCon 2018 Day 1: A Tasty Tower of Sandwiches
Publication date: 2018-11-01
Playlist: BazelCon 2018
Description: 
	From C++ to Haskell to Java and back
Mathieu Boespflug (Tweag) event: Bazelcon 2018; re_ty: Publish; product: Open Source - General; fullname: Mathieu Boespflug;
Captions: 
	00:00:02,240 --> 00:00:08,670
hi folks so I I'm Matthew I'm the

00:00:05,549 --> 00:00:11,250
founder of twee guy oh and I'm pretty

00:00:08,670 --> 00:00:13,500
excited to be here because since the

00:00:11,250 --> 00:00:18,029
beginning of tweed when we started at

00:00:13,500 --> 00:00:22,650
end of 2013 we had a slogan and that

00:00:18,029 --> 00:00:26,400
slogan since 2013 has been fast correct

00:00:22,650 --> 00:00:31,529
maintainable truths any three so when we

00:00:26,400 --> 00:00:34,559
saw a basal and so this was a little bit

00:00:31,529 --> 00:00:38,100
before basal got open sourced I think

00:00:34,559 --> 00:00:41,219
was in 2015 first time and so when we

00:00:38,100 --> 00:00:42,660
saw you know this this new arrival in

00:00:41,219 --> 00:00:46,620
the scene of the open source software

00:00:42,660 --> 00:00:50,100
and you know we thought this was

00:00:46,620 --> 00:00:51,480
probably going to be a good fit and you

00:00:50,100 --> 00:00:53,730
know if basil could take care of the

00:00:51,480 --> 00:00:56,390
fast and correct part our engineers

00:00:53,730 --> 00:00:58,829
would take care of the maintainable part

00:00:56,390 --> 00:01:00,359
alright so what's our mission our

00:00:58,829 --> 00:01:01,590
mission and let me you know I'd tell you

00:01:00,359 --> 00:01:03,239
a little bit about our mission because

00:01:01,590 --> 00:01:05,189
it's going to be relevant for to

00:01:03,239 --> 00:01:08,549
motivate a lot about what I'm going to

00:01:05,189 --> 00:01:12,030
be talking about today a lot of people

00:01:08,549 --> 00:01:13,890
have been talking about scalability you

00:01:12,030 --> 00:01:15,630
know scaling to very large code bases

00:01:13,890 --> 00:01:17,070
and the kinds of performance problems

00:01:15,630 --> 00:01:19,710
for example elite I was talking about

00:01:17,070 --> 00:01:21,030
that just earlier you know the kind of

00:01:19,710 --> 00:01:22,890
performance problems that you encounter

00:01:21,030 --> 00:01:25,770
as you're as you're dealing with a large

00:01:22,890 --> 00:01:27,540
amounts of code but what also what I'm

00:01:25,770 --> 00:01:29,540
gonna tell me talking about is the fact

00:01:27,540 --> 00:01:32,310
that what also happens when you have

00:01:29,540 --> 00:01:33,420
large amounts of code you have a lot of

00:01:32,310 --> 00:01:37,799
developers in the room that are

00:01:33,420 --> 00:01:41,490
developing this code and you know as

00:01:37,799 --> 00:01:43,590
they say small teams small problems big

00:01:41,490 --> 00:01:44,820
teams big problems and one of the

00:01:43,590 --> 00:01:47,369
problems is that it becomes a Tower of

00:01:44,820 --> 00:01:49,229
Babel none none of the developers all

00:01:47,369 --> 00:01:51,659
agreeing on the you know using a single

00:01:49,229 --> 00:01:53,970
language and you end up you know you

00:01:51,659 --> 00:01:56,040
have to make peace with that fact which

00:01:53,970 --> 00:01:57,299
is that you're going to have a lot of

00:01:56,040 --> 00:01:59,780
different programming languages that are

00:01:57,299 --> 00:02:02,850
going to be using on your project and

00:01:59,780 --> 00:02:04,229
you're going to have to that that's a

00:02:02,850 --> 00:02:08,190
problem but that's a problem that you

00:02:04,229 --> 00:02:10,440
have to kind of manage and you have to

00:02:08,190 --> 00:02:11,940
manage the fact that different pieces

00:02:10,440 --> 00:02:13,319
different components are going to be in

00:02:11,940 --> 00:02:15,269
different languages and in track

00:02:13,319 --> 00:02:16,799
with other components and if you're

00:02:15,269 --> 00:02:20,489
going to have lots of different build

00:02:16,799 --> 00:02:22,680
tools that don't talk to each other then

00:02:20,489 --> 00:02:24,599
you're going to be in a lot of trouble

00:02:22,680 --> 00:02:29,959
in this minute our experience in the

00:02:24,599 --> 00:02:33,060
past so what we do is we build software

00:02:29,959 --> 00:02:36,180
and we try to focus on building software

00:02:33,060 --> 00:02:38,640
that lasts now I know that sounds like

00:02:36,180 --> 00:02:40,799
an oxymoron in some parts of our

00:02:38,640 --> 00:02:42,870
industry but this is a type of software

00:02:40,799 --> 00:02:47,670
they're great and not all software needs

00:02:42,870 --> 00:02:49,970
to last and not all problems need

00:02:47,670 --> 00:02:52,379
lasting solutions in fact most do not

00:02:49,970 --> 00:02:56,040
but let me tell you about some of the

00:02:52,379 --> 00:02:58,169
types of problems we work on and how Bay

00:02:56,040 --> 00:02:59,669
is because you know basil helps a lot we

00:02:58,169 --> 00:03:05,790
think in those types of software they

00:02:59,669 --> 00:03:08,689
were right sorry to reactivate my phone

00:03:05,790 --> 00:03:08,689
to get the clicker to work

00:03:12,980 --> 00:03:18,300
okay so an example of something that

00:03:16,500 --> 00:03:21,390
we've been working on over the past

00:03:18,300 --> 00:03:23,489
couple years is accurately simulating

00:03:21,390 --> 00:03:24,930
the human physiology to inform the

00:03:23,489 --> 00:03:28,019
design of clinical trials or help

00:03:24,930 --> 00:03:30,239
doctors personalized treatments and this

00:03:28,019 --> 00:03:31,590
is something you know that you develop

00:03:30,239 --> 00:03:34,650
these models you develop over the course

00:03:31,590 --> 00:03:37,260
of many years and then they get put in

00:03:34,650 --> 00:03:39,269
front of doctors who do things with them

00:03:37,260 --> 00:03:41,819
and you know these are things that you

00:03:39,269 --> 00:03:42,900
want to get right and you want to make

00:03:41,819 --> 00:03:43,950
sure that you get it right and once you

00:03:42,900 --> 00:03:46,170
get it right you know you don't want to

00:03:43,950 --> 00:03:48,269
touch it too much and this is something

00:03:46,170 --> 00:03:50,730
that's going to be deployed in all kinds

00:03:48,269 --> 00:03:54,810
of places for a long time

00:03:50,730 --> 00:03:56,579
you know another example is designing a

00:03:54,810 --> 00:03:59,129
new storage paradigm that scales to

00:03:56,579 --> 00:04:01,590
exabytes worth of data for scientific

00:03:59,129 --> 00:04:03,450
computer clothes so for example there

00:04:01,590 --> 00:04:06,079
are radio telescopes that are being

00:04:03,450 --> 00:04:10,200
built in southern Africa Australia

00:04:06,079 --> 00:04:13,410
generating exabytes of data raw data

00:04:10,200 --> 00:04:16,500
every 10 hours that's peanuts for Google

00:04:13,410 --> 00:04:17,579
of course but you know in the scientific

00:04:16,500 --> 00:04:20,160
world this is starting to become quite

00:04:17,579 --> 00:04:21,630
big and bigger than what most tools in

00:04:20,160 --> 00:04:24,210
the scientific computing world I know

00:04:21,630 --> 00:04:26,100
how to cope with at this point other

00:04:24,210 --> 00:04:27,780
things that we've done is inventing

00:04:26,100 --> 00:04:30,240
languages for modeling financial

00:04:27,780 --> 00:04:33,270
contracts and platforms execute these

00:04:30,240 --> 00:04:34,740
financial contracts tools to check that

00:04:33,270 --> 00:04:37,200
these contracts accurately capture the

00:04:34,740 --> 00:04:40,979
spirit of the agreements between Oviatt

00:04:37,200 --> 00:04:42,780
of the parties of the contract this is

00:04:40,979 --> 00:04:44,729
the type of software that we work on and

00:04:42,780 --> 00:04:47,849
I want to focus today on the first one

00:04:44,729 --> 00:04:54,479
of these examples and show you how we

00:04:47,849 --> 00:04:56,760
used basil and in that project so the

00:04:54,479 --> 00:04:58,620
first thing to note is that you know

00:04:56,760 --> 00:05:01,289
what's in common to all these projects

00:04:58,620 --> 00:05:04,250
is that they're all large they need to

00:05:01,289 --> 00:05:06,690
last a long time and they're all

00:05:04,250 --> 00:05:10,139
polyglot projects where we have a lot of

00:05:06,690 --> 00:05:12,720
different programming languages that are

00:05:10,139 --> 00:05:18,770
being used and in the case of this first

00:05:12,720 --> 00:05:21,599
example we have basically three major

00:05:18,770 --> 00:05:24,240
components let's say that are really of

00:05:21,599 --> 00:05:26,670
interest one is first of all you need to

00:05:24,240 --> 00:05:32,310
implement a model model of

00:05:26,670 --> 00:05:34,260
I think item if part of the physiology

00:05:32,310 --> 00:05:37,800
of your body this is a metabolism for

00:05:34,260 --> 00:05:40,800
example and how do you implement these

00:05:37,800 --> 00:05:43,230
models while typically these models are

00:05:40,800 --> 00:05:46,740
based on reading the literature in

00:05:43,230 --> 00:05:49,140
biology and seeing what biology the

00:05:46,740 --> 00:05:52,890
biologists characterization of these

00:05:49,140 --> 00:05:54,300
models and the biologists you know they

00:05:52,890 --> 00:05:56,070
typically come up with all kinds of

00:05:54,300 --> 00:05:58,410
differential equations that say okay

00:05:56,070 --> 00:05:59,580
here's the population of this particular

00:05:58,410 --> 00:06:02,880
type of cells is going to evolve over

00:05:59,580 --> 00:06:05,430
time and so it's a fair amount of math

00:06:02,880 --> 00:06:08,540
that's involved and so it's a good idea

00:06:05,430 --> 00:06:12,000
for us to actually implement the model

00:06:08,540 --> 00:06:13,920
in Haskell and the reason we do that is

00:06:12,000 --> 00:06:15,330
because we're really interested in being

00:06:13,920 --> 00:06:17,870
able to implement the model in a way

00:06:15,330 --> 00:06:20,070
that's very close to the paper

00:06:17,870 --> 00:06:22,890
description of that model so that you

00:06:20,070 --> 00:06:25,050
can at least inspect that you know

00:06:22,890 --> 00:06:26,670
essentially the differential equation so

00:06:25,050 --> 00:06:29,160
they're on paper and the stuff that

00:06:26,670 --> 00:06:33,210
you're writing on the computer kind of

00:06:29,160 --> 00:06:35,190
looked the same now you don't want to be

00:06:33,210 --> 00:06:39,450
doing everything in high school there's

00:06:35,190 --> 00:06:41,790
a lot of you know numerical integration

00:06:39,450 --> 00:06:45,600
that you want to be doing for example as

00:06:41,790 --> 00:06:47,310
part of executing this model and what

00:06:45,600 --> 00:06:49,170
you really don't want to do is reinvent

00:06:47,310 --> 00:06:51,990
all these low-level will be tuned so for

00:06:49,170 --> 00:06:54,690
example you know find the area under a

00:06:51,990 --> 00:06:56,940
curve this is something that people have

00:06:54,690 --> 00:07:02,660
been working on for many many years 30

00:06:56,940 --> 00:07:05,550
40 years using C using Fortran and

00:07:02,660 --> 00:07:07,830
you're never going to manage to get

00:07:05,550 --> 00:07:10,620
anything that runs nearly as fast as as

00:07:07,830 --> 00:07:14,640
what these get folks have been working

00:07:10,620 --> 00:07:16,860
on for all this time so we want at least

00:07:14,640 --> 00:07:19,860
two languages now we want Haskell for

00:07:16,860 --> 00:07:22,440
the model for the reasons I explained we

00:07:19,860 --> 00:07:25,680
want C or Fortran for the low-level

00:07:22,440 --> 00:07:29,610
numerical routines and of course these

00:07:25,680 --> 00:07:31,620
models you need to train them you need

00:07:29,610 --> 00:07:34,650
to tune them you need to tune them based

00:07:31,620 --> 00:07:36,930
on for example you know clinical trial

00:07:34,650 --> 00:07:39,960
data data that you might have on at hand

00:07:36,930 --> 00:07:41,100
this data you might have that somewhere

00:07:39,960 --> 00:07:46,620
on s3

00:07:41,100 --> 00:07:49,169
hdfs and you it takes a long time to to

00:07:46,620 --> 00:07:51,030
train these models and so this is

00:07:49,169 --> 00:07:54,260
something that you want to be able to do

00:07:51,030 --> 00:07:57,990
on large clusters with lots of machines

00:07:54,260 --> 00:08:01,949
and one way to do that is to use spark

00:07:57,990 --> 00:08:04,410
Apache spark to you know take your take

00:08:01,949 --> 00:08:06,750
your code distribute that on a lot of

00:08:04,410 --> 00:08:08,400
different machines and run run these

00:08:06,750 --> 00:08:11,880
parallel computations for example if

00:08:08,400 --> 00:08:14,280
you're creating the model spark is

00:08:11,880 --> 00:08:18,870
itself implemented in Scala and offers

00:08:14,280 --> 00:08:21,419
java api s-- and so now we're in a state

00:08:18,870 --> 00:08:24,000
where we want three languages we want

00:08:21,419 --> 00:08:27,030
Haskell that's talking to Joe it's a

00:08:24,000 --> 00:08:35,930
scholar via the Java API and then the

00:08:27,030 --> 00:08:35,930
Haskell code is itself using scene sorry

00:08:41,390 --> 00:08:44,840
so then the other thing to note is that

00:08:43,130 --> 00:08:47,210
you know I won't rehearse all the

00:08:44,840 --> 00:08:48,920
benefits of basil here but I do want to

00:08:47,210 --> 00:08:51,080
mention this if we're going to build

00:08:48,920 --> 00:08:52,370
software the last a long time it's

00:08:51,080 --> 00:08:55,030
particularly important that the build

00:08:52,370 --> 00:08:58,310
description are easy to understand

00:08:55,030 --> 00:09:01,040
uniform across the projects and ours

00:08:58,310 --> 00:09:03,260
declare it as possible because years

00:09:01,040 --> 00:09:07,400
from now impenetrable build system logic

00:09:03,260 --> 00:09:10,310
is going to be just that impenetrable so

00:09:07,400 --> 00:09:14,960
you know lasting software crucially

00:09:10,310 --> 00:09:17,120
depends on lasting build systems and so

00:09:14,960 --> 00:09:18,470
this is why we turn to you know we had

00:09:17,120 --> 00:09:21,380
these two problems we want to build a

00:09:18,470 --> 00:09:24,260
build system that's for for our project

00:09:21,380 --> 00:09:26,780
that's very simple to understand in

00:09:24,260 --> 00:09:28,280
which we can that can cope with

00:09:26,780 --> 00:09:30,590
combining lots of different programming

00:09:28,280 --> 00:09:34,850
languages really well and so that we

00:09:30,590 --> 00:09:36,830
turn to basil basil nearly fit the bill

00:09:34,850 --> 00:09:41,210
just as is why because it already

00:09:36,830 --> 00:09:46,070
supports Java already building Java code

00:09:41,210 --> 00:09:48,680
already supports building C C++ code but

00:09:46,070 --> 00:09:50,890
it didn't support at least not in the

00:09:48,680 --> 00:09:54,350
open-source version it didn't support

00:09:50,890 --> 00:09:58,370
building Haskell and so we went ahead

00:09:54,350 --> 00:10:01,400
and added Haskell support to basil using

00:09:58,370 --> 00:10:02,600
a star like the extension language so

00:10:01,400 --> 00:10:07,070
just to give you a taste of what it

00:10:02,600 --> 00:10:10,610
looks like for the user you know let's

00:10:07,070 --> 00:10:13,070
say you want to define the the binary

00:10:10,610 --> 00:10:15,860
for the for the simulator so you're

00:10:13,070 --> 00:10:17,540
gonna list a bunch of source files and

00:10:15,860 --> 00:10:18,680
then you might have some some libraries

00:10:17,540 --> 00:10:21,650
that you depend on and some of these

00:10:18,680 --> 00:10:24,770
libraries are built in wired into the to

00:10:21,650 --> 00:10:28,520
the compiler so for example in this

00:10:24,770 --> 00:10:31,490
example you know we have base which is

00:10:28,520 --> 00:10:35,150
just wired in and it can't be built that

00:10:31,490 --> 00:10:37,850
library can't be built by basil so the

00:10:35,150 --> 00:10:39,350
way to bring it into the basil world is

00:10:37,850 --> 00:10:41,810
to use the the Haskell import

00:10:39,350 --> 00:10:47,510
declaration which is so Haskell import

00:10:41,810 --> 00:10:50,240
is - Haskell what CC import is - - c++

00:10:47,510 --> 00:10:53,840
CC import being one of the native rules

00:10:50,240 --> 00:10:54,380
in basil of course you can refactor all

00:10:53,840 --> 00:10:56,360
of this and

00:10:54,380 --> 00:10:57,770
I'm gonna take the the model part of my

00:10:56,360 --> 00:10:59,810
simulator and I'm gonna split it out and

00:10:57,770 --> 00:11:02,330
it's a separate library so then you have

00:10:59,810 --> 00:11:04,330
a half school binary which is

00:11:02,330 --> 00:11:06,200
self-defense on a half school library

00:11:04,330 --> 00:11:09,340
and then you know the high school

00:11:06,200 --> 00:11:11,480
librarian that binary both both use

00:11:09,340 --> 00:11:14,120
sometimes you know built at built-in

00:11:11,480 --> 00:11:16,670
libraries the thing to note about these

00:11:14,120 --> 00:11:18,680
binaries is that they're just regular

00:11:16,670 --> 00:11:20,750
elf executables just like if your code

00:11:18,680 --> 00:11:22,610
was actually C++ you know what we're

00:11:20,750 --> 00:11:26,900
building here is native code we're not

00:11:22,610 --> 00:11:29,180
targeting the JVM here the way you would

00:11:26,900 --> 00:11:32,330
in a lot of projects that use basil and

00:11:29,180 --> 00:11:33,710
that we've heard about today same with

00:11:32,330 --> 00:11:37,610
the ghost for the libraries the

00:11:33,710 --> 00:11:41,390
libraries are essentially just shared

00:11:37,610 --> 00:11:44,990
objects dhatus those okay

00:11:41,390 --> 00:11:46,640
so we support importing built-in

00:11:44,990 --> 00:11:49,250
libraries we support defining our own

00:11:46,640 --> 00:11:52,880
libraries we support writing your own

00:11:49,250 --> 00:11:57,560
binaries and then of you know just to

00:11:52,880 --> 00:12:00,500
give you a bit of a broad overview we we

00:11:57,560 --> 00:12:04,310
can define tests for for example for a

00:12:00,500 --> 00:12:06,290
model so just a quick recap of all the

00:12:04,310 --> 00:12:10,040
features we have binaries libraries

00:12:06,290 --> 00:12:11,840
tests pre-built libraries something that

00:12:10,040 --> 00:12:13,640
I didn't talk about so far and I'm kind

00:12:11,840 --> 00:12:15,740
of gonna leave off the table here but

00:12:13,640 --> 00:12:17,900
that's been tremendously useful is to be

00:12:15,740 --> 00:12:21,770
able to generate binding libraries for

00:12:17,900 --> 00:12:23,650
for for Haskell using a program from

00:12:21,770 --> 00:12:28,430
based on starting from pota breath just

00:12:23,650 --> 00:12:31,700
protobuf descriptions sorry and we

00:12:28,430 --> 00:12:33,530
support mostly static so you know beta

00:12:31,700 --> 00:12:36,830
building binaries and most libraries are

00:12:33,530 --> 00:12:39,440
linked in statically but then some are

00:12:36,830 --> 00:12:40,850
still linked dynamically just like is I

00:12:39,440 --> 00:12:46,370
think the default in the supercilious

00:12:40,850 --> 00:12:49,400
rules currently and you know static and

00:12:46,370 --> 00:12:50,990
dynamic linking so if you look at this

00:12:49,400 --> 00:12:53,570
feature set this looks very much like

00:12:50,990 --> 00:12:55,250
the feature set for the C++ rules in

00:12:53,570 --> 00:12:58,460
fact I think we're pretty much in future

00:12:55,250 --> 00:13:02,000
parity at this point with the C++ rules

00:12:58,460 --> 00:13:05,480
but for Haskell so the then the obvious

00:13:02,000 --> 00:13:06,560
questions become if we had this that's a

00:13:05,480 --> 00:13:09,740
you know

00:13:06,560 --> 00:13:12,290
let's say short example over here we

00:13:09,740 --> 00:13:14,839
have a binary that depends on two C++

00:13:12,290 --> 00:13:16,629
libraries you know the very natural

00:13:14,839 --> 00:13:20,810
question to ask is could we just

00:13:16,629 --> 00:13:24,680
substitute a Haskell library in place of

00:13:20,810 --> 00:13:28,129
one of the C libraries hoping it would

00:13:24,680 --> 00:13:31,009
just work it turns out it's a little bit

00:13:28,129 --> 00:13:33,170
more difficult it used to be quite a

00:13:31,009 --> 00:13:34,189
little bit it used to be a little bit

00:13:33,170 --> 00:13:36,170
difficult to make that work and I'll

00:13:34,189 --> 00:13:39,920
tell you a bit about how we did it it's

00:13:36,170 --> 00:13:42,410
becoming easier this is this is a

00:13:39,920 --> 00:13:44,329
dependency graph that I'm showing you so

00:13:42,410 --> 00:13:46,519
let me just switch switch the arrows

00:13:44,329 --> 00:13:48,410
into the other direction and you know

00:13:46,519 --> 00:13:51,079
now I'm assuming a information flow

00:13:48,410 --> 00:13:53,839
graph and what this tells you is that it

00:13:51,079 --> 00:13:56,839
tells you who's providing information to

00:13:53,839 --> 00:13:59,420
who and start like Basil's essential

00:13:56,839 --> 00:14:01,040
language to write new rules typically

00:13:59,420 --> 00:14:03,970
you can communicate through so-called

00:14:01,040 --> 00:14:07,399
providers for native rules I don't know

00:14:03,970 --> 00:14:10,220
how things work under the hood but so

00:14:07,399 --> 00:14:11,750
here you have the C++ library sorry the

00:14:10,220 --> 00:14:13,250
binary that will normally need

00:14:11,750 --> 00:14:15,889
information passed up from its

00:14:13,250 --> 00:14:17,930
dependencies so for example where to

00:14:15,889 --> 00:14:19,189
find header files exported from one of

00:14:17,930 --> 00:14:23,569
the two libraries that it depends upon

00:14:19,189 --> 00:14:26,269
that's that's shipped up upstream so if

00:14:23,569 --> 00:14:30,170
you put in a Haskell library in place of

00:14:26,269 --> 00:14:33,230
one of the C libraries well now the

00:14:30,170 --> 00:14:37,160
Haskell library needs to be able to get

00:14:33,230 --> 00:14:40,279
that information from from the C library

00:14:37,160 --> 00:14:41,480
much like you know the once the library

00:14:40,279 --> 00:14:42,860
was depending on the other C library

00:14:41,480 --> 00:14:47,180
needed information from it in order to

00:14:42,860 --> 00:14:49,429
compile and here we're basically

00:14:47,180 --> 00:14:53,149
crossing some kind of boundary because

00:14:49,429 --> 00:14:55,069
the C++ rules right now in basil their

00:14:53,149 --> 00:14:57,500
input their native they're implemented

00:14:55,069 --> 00:14:59,750
in Java they're not implemented in

00:14:57,500 --> 00:15:05,269
Starlog whereas the Haskell library that

00:14:59,750 --> 00:15:07,670
we implemented that's star lark code so

00:15:05,269 --> 00:15:09,379
you need to have some mechanism for the

00:15:07,670 --> 00:15:12,319
the native rules to be able to

00:15:09,379 --> 00:15:14,259
communicate information they export some

00:15:12,319 --> 00:15:18,290
information in the star luck world

00:15:14,259 --> 00:15:19,970
through you know stable api's and so

00:15:18,290 --> 00:15:23,480
that's all kind of you

00:15:19,970 --> 00:15:24,319
you been you over the past year in

00:15:23,480 --> 00:15:29,139
Baselworld

00:15:24,319 --> 00:15:33,379
but we can just about make it work so

00:15:29,139 --> 00:15:36,740
just to give you some example very you

00:15:33,379 --> 00:15:38,060
know have a little bit of code here you

00:15:36,740 --> 00:15:40,220
know typically as a haskell library what

00:15:38,060 --> 00:15:42,379
I would do is that I would you know look

00:15:40,220 --> 00:15:46,879
at all the dependencies that I have and

00:15:42,379 --> 00:15:48,079
if I need you know I'll typically need

00:15:46,879 --> 00:15:50,689
definitions that come from the header

00:15:48,079 --> 00:15:52,129
files of the of the C libraries and to

00:15:50,689 --> 00:15:55,250
find all the C libraries that are part

00:15:52,129 --> 00:15:58,670
of my dependencies I look at which which

00:15:55,250 --> 00:16:01,370
ones of my dependencies export a

00:15:58,670 --> 00:16:03,560
provider that's specifically for for C

00:16:01,370 --> 00:16:06,889
libraries so this is the code that I

00:16:03,560 --> 00:16:08,629
would want to write it turns out and

00:16:06,889 --> 00:16:11,990
then in practice this is I just copy

00:16:08,629 --> 00:16:14,269
pasted verbatim the code that does the

00:16:11,990 --> 00:16:16,699
same thing as it stands today and the

00:16:14,269 --> 00:16:18,500
Haskell code base it's been that

00:16:16,699 --> 00:16:22,399
comments been there for for nine months

00:16:18,500 --> 00:16:24,170
but I think I can now I'm now in a

00:16:22,399 --> 00:16:25,970
position since the latest release in

00:16:24,170 --> 00:16:27,559
Basel or may perhaps the one after I'll

00:16:25,970 --> 00:16:28,579
be able to remove that comment and do

00:16:27,559 --> 00:16:33,559
things kind of like in the previous

00:16:28,579 --> 00:16:35,959
slide so and this is because there isn't

00:16:33,559 --> 00:16:38,149
really or there wasn't really a real

00:16:35,959 --> 00:16:40,819
provider that was given to me by the by

00:16:38,149 --> 00:16:44,059
the C++ rules and so I could find that

00:16:40,819 --> 00:16:47,540
information I had to fake it so this was

00:16:44,059 --> 00:16:50,660
some hacks that I had to use area me to

00:16:47,540 --> 00:16:54,199
use moving back to the picture that we

00:16:50,660 --> 00:16:55,490
had before it's nice to have a high

00:16:54,199 --> 00:16:56,800
school library that depends on a C

00:16:55,490 --> 00:17:00,620
library but what about the other around

00:16:56,800 --> 00:17:03,259
if you know we want to go full circle

00:17:00,620 --> 00:17:06,380
here we'd like to have a C++ library

00:17:03,259 --> 00:17:08,179
that's depending on ask a library and if

00:17:06,380 --> 00:17:11,539
you can achieve that if you can achieve

00:17:08,179 --> 00:17:14,809
both directions then you really do have

00:17:11,539 --> 00:17:16,400
you can really just drop in a Haskell

00:17:14,809 --> 00:17:18,740
library wherever you had a C++ library

00:17:16,400 --> 00:17:20,870
before okay

00:17:18,740 --> 00:17:22,490
turns out there were more hacks arrests

00:17:20,870 --> 00:17:22,970
area there I won't bore you with the

00:17:22,490 --> 00:17:24,679
details

00:17:22,970 --> 00:17:27,260
let's just look at the overall picture

00:17:24,679 --> 00:17:32,240
here what are we doing why does this

00:17:27,260 --> 00:17:33,960
look like a sandwich that's what the

00:17:32,240 --> 00:17:36,510
basil developers call it

00:17:33,960 --> 00:17:40,920
and they call it a sandwich because you

00:17:36,510 --> 00:17:44,910
have a C++ library a native sorry right

00:17:40,920 --> 00:17:49,470
so so a native rule at the bottom then

00:17:44,910 --> 00:17:51,420
you have a half school a Serie A star

00:17:49,470 --> 00:17:53,910
lark rule in the middle and then a

00:17:51,420 --> 00:17:55,260
native rule again on top and this is

00:17:53,910 --> 00:18:01,350
something that we can actually achieve

00:17:55,260 --> 00:18:04,350
today with hacks in at the boundaries

00:18:01,350 --> 00:18:09,150
between the layers here the butter for

00:18:04,350 --> 00:18:11,040
the sandwich if you will and you know we

00:18:09,150 --> 00:18:12,240
needed a lot of butter this year in

00:18:11,040 --> 00:18:15,600
order to do this but that's just because

00:18:12,240 --> 00:18:18,510
we jumped the gun because back in

00:18:15,600 --> 00:18:20,250
January we asked the we asked basil

00:18:18,510 --> 00:18:24,450
developer take and we do this and they

00:18:20,250 --> 00:18:26,550
said sure just wait for q3 of 2018 and

00:18:24,450 --> 00:18:29,070
we were impatient and you know decided

00:18:26,550 --> 00:18:32,640
well maybe we can do it now and it turns

00:18:29,070 --> 00:18:35,370
out yes we can but in the future there

00:18:32,640 --> 00:18:37,380
will be you know proper api's to do this

00:18:35,370 --> 00:18:41,280
and we'll get would be able to remove

00:18:37,380 --> 00:18:45,030
all of our hacks so I focus on the

00:18:41,280 --> 00:18:50,880
haskell java sorry yeah the Haskell C++

00:18:45,030 --> 00:18:51,960
story but it turns out that if we look

00:18:50,880 --> 00:18:54,570
at the Haskell support that we added

00:18:51,960 --> 00:18:58,740
basil as a sense today it supports a

00:18:54,570 --> 00:19:03,990
little bit more than that we can do we

00:18:58,740 --> 00:19:06,450
can have for example a a java binary so

00:19:03,990 --> 00:19:09,870
what's the java binary it's a it's a jar

00:19:06,450 --> 00:19:12,650
file that has a main function and what

00:19:09,870 --> 00:19:15,090
we can do is that we can inject a

00:19:12,650 --> 00:19:20,510
Haskell code so it's shared Haskell

00:19:15,090 --> 00:19:23,400
shared object dot Esso into that jar and

00:19:20,510 --> 00:19:26,340
that jar that that Haskell code that I

00:19:23,400 --> 00:19:31,559
so might itself include code that was

00:19:26,340 --> 00:19:34,020
built from C and this this all works I

00:19:31,559 --> 00:19:37,800
could also go the other way around if I

00:19:34,020 --> 00:19:40,620
liked and you know you might think well

00:19:37,800 --> 00:19:42,660
that's all a lot of fun but what's the

00:19:40,620 --> 00:19:43,830
purpose of all this well going back to

00:19:42,660 --> 00:19:46,770
our simulator that I was talking about

00:19:43,830 --> 00:19:47,700
before what we want to be doing is

00:19:46,770 --> 00:19:52,580
ultimately we want

00:19:47,700 --> 00:19:56,450
to be providing a Java binary an app to

00:19:52,580 --> 00:19:59,639
spark spark his definition of an app is

00:19:56,450 --> 00:20:01,830
whatever is is a jar a self-contained

00:19:59,639 --> 00:20:06,330
jar that you can ship across the cluster

00:20:01,830 --> 00:20:07,710
has a main function that that main main

00:20:06,330 --> 00:20:09,809
function that it can call and then it

00:20:07,710 --> 00:20:12,510
expects that the jar that's being

00:20:09,809 --> 00:20:15,269
shipped across the cluster is something

00:20:12,510 --> 00:20:19,320
that is ultimately calling the spark

00:20:15,269 --> 00:20:21,090
api's so if part of the application is

00:20:19,320 --> 00:20:24,179
going to be written in Haskell then we

00:20:21,090 --> 00:20:26,250
needed the Haskell code to be written

00:20:24,179 --> 00:20:28,049
against these java api so you see that

00:20:26,250 --> 00:20:30,120
there's going to be a dependency here

00:20:28,049 --> 00:20:31,500
between the the middle layer in orange

00:20:30,120 --> 00:20:34,830
and the and the java library at the

00:20:31,500 --> 00:20:39,380
bottom also on numerical routines that's

00:20:34,830 --> 00:20:41,850
that's the C part for the numerix and

00:20:39,380 --> 00:20:44,130
this whole thing you know ultimately

00:20:41,850 --> 00:20:46,559
what we do is that we we end up with a

00:20:44,130 --> 00:20:50,010
self-contained jar and that's gets

00:20:46,559 --> 00:20:55,710
shipped around and it just works so that

00:20:50,010 --> 00:20:58,440
that was our original use case sorry

00:20:55,710 --> 00:21:00,740
this keep on having remote control

00:20:58,440 --> 00:21:00,740
problems

00:21:03,830 --> 00:21:07,860
okay so there were a few challenges

00:21:06,570 --> 00:21:10,050
along the way and it won't be a bore you

00:21:07,860 --> 00:21:13,080
with the details but I did want to zoom

00:21:10,050 --> 00:21:16,080
in on just one of the challenges that we

00:21:13,080 --> 00:21:19,380
faced and this is going to I think it's

00:21:16,080 --> 00:21:21,900
interesting because it kind of shows you

00:21:19,380 --> 00:21:25,890
how pretty fundamental design choices

00:21:21,900 --> 00:21:29,160
and basel itself ultimately had a pretty

00:21:25,890 --> 00:21:33,030
big impact in the way we write rules for

00:21:29,160 --> 00:21:34,710
a language like haskell and this was

00:21:33,030 --> 00:21:38,760
something that we didn't expect at first

00:21:34,710 --> 00:21:40,170
so there's multiple ways to write build

00:21:38,760 --> 00:21:41,760
systems one thing that you can do is

00:21:40,170 --> 00:21:44,340
that you could say I have one source

00:21:41,760 --> 00:21:46,140
file I'm going for each source file that

00:21:44,340 --> 00:21:52,920
I have I'm going to define one target

00:21:46,140 --> 00:21:56,550
and Basel and you know this quickly

00:21:52,920 --> 00:21:59,670
becomes hard to manage so I I want some

00:21:56,550 --> 00:22:03,540
kind of dynamic dependencies dynamic

00:21:59,670 --> 00:22:05,730
dependency detection so so basically I

00:22:03,540 --> 00:22:08,340
have some other system that's inferring

00:22:05,730 --> 00:22:10,950
the the graph between the targets

00:22:08,340 --> 00:22:12,630
dependency graph out of the box we can't

00:22:10,950 --> 00:22:14,670
really do that in basil basil Kant

00:22:12,630 --> 00:22:18,270
doesn't allow us to detect dependencies

00:22:14,670 --> 00:22:21,870
dynamically it only allows static

00:22:18,270 --> 00:22:24,360
dependencies so essentially all we can

00:22:21,870 --> 00:22:26,970
really do is have one file one time for

00:22:24,360 --> 00:22:28,500
each file a target and you know we're

00:22:26,970 --> 00:22:29,850
basically defining all the dependencies

00:22:28,500 --> 00:22:35,940
between each of the targets manually

00:22:29,850 --> 00:22:38,880
this is hard to maintain and ultimately

00:22:35,940 --> 00:22:41,010
there are build systems that allow this

00:22:38,880 --> 00:22:43,020
but these builds are symptoms don't have

00:22:41,010 --> 00:22:47,250
the performance track record that basil

00:22:43,020 --> 00:22:49,559
has let's put it that way so what you

00:22:47,250 --> 00:22:51,450
can also do is to say all right look I

00:22:49,559 --> 00:22:53,280
don't want to deal with hard to maintain

00:22:51,450 --> 00:22:55,980
stuff remember what we were saying

00:22:53,280 --> 00:22:59,100
before about a long lasting software and

00:22:55,980 --> 00:23:01,380
long lasting build systems so we want

00:22:59,100 --> 00:23:03,630
something that's easy to maintain and we

00:23:01,380 --> 00:23:06,120
do want to fast build system we do want

00:23:03,630 --> 00:23:07,800
to stick with basil so what we're gonna

00:23:06,120 --> 00:23:11,640
do is that we're going to have one

00:23:07,800 --> 00:23:15,710
target many source files but if we do

00:23:11,640 --> 00:23:18,929
that we ultimately lose incrementality

00:23:15,710 --> 00:23:20,700
incremental 'ti means ideally what I

00:23:18,929 --> 00:23:25,080
would want is that whenever I change

00:23:20,700 --> 00:23:26,669
just one source file only the object

00:23:25,080 --> 00:23:30,419
code corresponding to that one source

00:23:26,669 --> 00:23:36,500
file gets rebuilt not everything that

00:23:30,419 --> 00:23:39,390
was part of the of the target there's

00:23:36,500 --> 00:23:41,760
there's other reasons for in the case of

00:23:39,390 --> 00:23:42,690
languages like Haskell and I believe you

00:23:41,760 --> 00:23:45,540
know there's a lot of other languages

00:23:42,690 --> 00:23:47,460
that have super slow compilers and the

00:23:45,540 --> 00:23:49,559
problem with slow compilers means is

00:23:47,460 --> 00:23:51,450
that if you try to have one file or one

00:23:49,559 --> 00:23:53,669
target you're also going to make the

00:23:51,450 --> 00:23:55,410
build a lot slower so here I have a

00:23:53,669 --> 00:23:58,260
table I show you a few experiments that

00:23:55,410 --> 00:24:00,870
I made very recently there's a package

00:23:58,260 --> 00:24:03,800
called binary which is a package that

00:24:00,870 --> 00:24:06,950
ships with the compiler in Haskell and

00:24:03,800 --> 00:24:10,320
there's about 3,200 lines of code and

00:24:06,950 --> 00:24:12,360
compared to GCC first of all we're

00:24:10,320 --> 00:24:15,540
basically we have a compiler that's an

00:24:12,360 --> 00:24:18,300
order of magnitude slower or even more

00:24:15,540 --> 00:24:20,700
and even when you're just compiling you

00:24:18,300 --> 00:24:24,270
know the empty module it's already in

00:24:20,700 --> 00:24:28,290
order of magnitude slower and if you try

00:24:24,270 --> 00:24:31,320
to compile the packaged binary you try

00:24:28,290 --> 00:24:34,140
to compile it one file at a time then

00:24:31,320 --> 00:24:36,300
that's going to take ten seconds whereas

00:24:34,140 --> 00:24:37,800
if you just hand all of the files over

00:24:36,300 --> 00:24:39,660
to the compiler and the compiler just

00:24:37,800 --> 00:24:43,950
spawns one process for the entire

00:24:39,660 --> 00:24:46,580
compilation unit the entire target then

00:24:43,950 --> 00:24:50,850
then you actually get fairly substantial

00:24:46,580 --> 00:24:52,460
performance boost so something that

00:24:50,850 --> 00:24:57,480
would be nice and I you know I would

00:24:52,460 --> 00:24:59,309
love to talk to basil developers at some

00:24:57,480 --> 00:25:01,580
point you know today or tomorrow I think

00:24:59,309 --> 00:25:07,140
something that we should consider is

00:25:01,580 --> 00:25:09,500
better support for slow compilers so

00:25:07,140 --> 00:25:12,020
that we can have

00:25:09,500 --> 00:25:16,580
in Scala or these are the scallops

00:25:12,020 --> 00:25:18,740
collar creditor yeah okay better support

00:25:16,580 --> 00:25:20,900
for slow compilers because you know this

00:25:18,740 --> 00:25:23,150
is there there are trade-offs to make

00:25:20,900 --> 00:25:25,250
here that are a little bit not ideal in

00:25:23,150 --> 00:25:28,669
the case of Haskell

00:25:25,250 --> 00:25:30,860
we had a way out what we do now is that

00:25:28,669 --> 00:25:32,450
we say when do we really care about

00:25:30,860 --> 00:25:34,490
incrementality we really care about

00:25:32,450 --> 00:25:36,409
incremental 'ti when we're doing

00:25:34,490 --> 00:25:39,080
interactive development when we're

00:25:36,409 --> 00:25:41,000
saying I have this module I'm gonna

00:25:39,080 --> 00:25:44,120
write a function and then I'm going to

00:25:41,000 --> 00:25:45,860
play ping-pong with my compiler with the

00:25:44,120 --> 00:25:48,320
type checker of the compiler to get the

00:25:45,860 --> 00:25:50,270
codes of type check and you know when

00:25:48,320 --> 00:25:52,340
I'm doing when I'm playing that pimp on

00:25:50,270 --> 00:25:53,870
game I you know if I have 10 files in my

00:25:52,340 --> 00:25:55,400
target I really don't want those whole

00:25:53,870 --> 00:25:58,370
10 files to be we compile every time to

00:25:55,400 --> 00:26:00,380
change one line in one file but

00:25:58,370 --> 00:26:02,990
fortunately in the case of Haskell you

00:26:00,380 --> 00:26:05,090
actually have a pretty decent rebel in

00:26:02,990 --> 00:26:06,620
this case you know when we're doing

00:26:05,090 --> 00:26:08,059
interactive development something that

00:26:06,620 --> 00:26:11,780
we added to the Haskell support for

00:26:08,059 --> 00:26:13,669
basil is that we added this magic target

00:26:11,780 --> 00:26:15,770
that you can invoke at any time which

00:26:13,669 --> 00:26:17,900
basically spawns a ripple for you

00:26:15,770 --> 00:26:19,549
with all of the dependencies that you

00:26:17,900 --> 00:26:21,679
need in order to compile the particular

00:26:19,549 --> 00:26:23,900
module that you're interested in loaded

00:26:21,679 --> 00:26:26,510
in and so then you can just you know go

00:26:23,900 --> 00:26:29,929
about and do your your your play your

00:26:26,510 --> 00:26:31,520
ping-pong game inside the rebel but you

00:26:29,929 --> 00:26:33,679
know this is kind of a workaround to

00:26:31,520 --> 00:26:35,900
that the fundamental problem that was

00:26:33,679 --> 00:26:39,169
talking about earlier ok

00:26:35,900 --> 00:26:41,240
key takeaways before you know something

00:26:39,169 --> 00:26:44,059
I want to know is before we started on

00:26:41,240 --> 00:26:46,630
basil we considered other systems which

00:26:44,059 --> 00:26:51,010
are all essentially descendants of

00:26:46,630 --> 00:26:54,380
Blaise and so for example consider buck

00:26:51,010 --> 00:26:56,750
but the the thing that's interesting

00:26:54,380 --> 00:26:58,039
about basil is that it has an extension

00:26:56,750 --> 00:27:01,130
language and the fact that you have an

00:26:58,039 --> 00:27:02,690
extension language means that in for it

00:27:01,130 --> 00:27:05,390
kind of forced the basil developers to

00:27:02,690 --> 00:27:08,539
offer a fairly stable API so that people

00:27:05,390 --> 00:27:11,990
could fairly stable so that people could

00:27:08,539 --> 00:27:14,960
extend it it could extend basil whereas

00:27:11,990 --> 00:27:19,399
if I'm just given all of the gots all of

00:27:14,960 --> 00:27:22,490
the internals of of the Java code that

00:27:19,399 --> 00:27:23,270
is the implementation of basil or the

00:27:22,490 --> 00:27:26,020
implementation

00:27:23,270 --> 00:27:29,030
of buck that's a lot harder to work with

00:27:26,020 --> 00:27:31,310
so that was a really crucial design

00:27:29,030 --> 00:27:33,290
choice of Basel and something that

00:27:31,310 --> 00:27:36,620
really allowed you know spawning this

00:27:33,290 --> 00:27:38,060
entire ecosystem of rules that interact

00:27:36,620 --> 00:27:39,590
with each other if it hadn't been for

00:27:38,060 --> 00:27:42,410
this substantial language did I think it

00:27:39,590 --> 00:27:44,240
wouldn't it never have happened what's

00:27:42,410 --> 00:27:45,620
really important is for these rules to

00:27:44,240 --> 00:27:47,330
be able to interact you know I showed a

00:27:45,620 --> 00:27:49,880
shared a use case where that's important

00:27:47,330 --> 00:27:51,380
and you know Basel is already ready for

00:27:49,880 --> 00:27:55,100
this and the good news is that it's only

00:27:51,380 --> 00:27:57,200
going to get easier and you know as I

00:27:55,100 --> 00:27:59,170
said some core design principles

00:27:57,200 --> 00:28:02,660
actually have a pretty big influence and

00:27:59,170 --> 00:28:05,450
you know we'll see in the future just

00:28:02,660 --> 00:28:08,420
last kind of bonus that I wanted to show

00:28:05,450 --> 00:28:11,750
you is that the main reason why we

00:28:08,420 --> 00:28:13,940
embarked on this endeavor was to fix

00:28:11,750 --> 00:28:16,940
this Tower of Babel situation they were

00:28:13,940 --> 00:28:18,650
talking about all along but it turns out

00:28:16,940 --> 00:28:21,740
you know we also worked with one of our

00:28:18,650 --> 00:28:24,920
clients formation that a I great company

00:28:21,740 --> 00:28:27,700
based out of California who had an

00:28:24,920 --> 00:28:29,750
entirely Haskell code base they had one

00:28:27,700 --> 00:28:32,360
one language that they were using for

00:28:29,750 --> 00:28:35,090
everything so different use case and it

00:28:32,360 --> 00:28:39,290
turns out that with the Haskell specific

00:28:35,090 --> 00:28:41,900
tools they were getting our along CI

00:28:39,290 --> 00:28:44,600
times and the developers were getting

00:28:41,900 --> 00:28:46,250
quite upset some of that was for the

00:28:44,600 --> 00:28:47,990
many reasons that you know melody talked

00:28:46,250 --> 00:28:49,640
about this morning the fact that cache

00:28:47,990 --> 00:28:51,380
test results weren't being cached and

00:28:49,640 --> 00:28:54,170
all of that but there were other reasons

00:28:51,380 --> 00:28:57,170
and just by switching to basil they

00:28:54,170 --> 00:28:59,750
already have that time and they one of

00:28:57,170 --> 00:29:01,940
their developers told me actually so 30

00:28:59,750 --> 00:29:03,500
minutes is still quite long but the vast

00:29:01,940 --> 00:29:05,090
majority those 30 minutes is just

00:29:03,500 --> 00:29:06,980
because on this particular study I

00:29:05,090 --> 00:29:09,020
provider that we have we're completely

00:29:06,980 --> 00:29:10,340
network bound we're just loading from

00:29:09,020 --> 00:29:13,000
the build cache and that's what takes

00:29:10,340 --> 00:29:16,910
all the time but it's much easier to

00:29:13,000 --> 00:29:20,360
optimize the build cache than it is to

00:29:16,910 --> 00:29:22,100
be optimizing a build system that also

00:29:20,360 --> 00:29:23,900
some happens to sometimes do the wrong

00:29:22,100 --> 00:29:25,700
thing that's a quote from one of the

00:29:23,900 --> 00:29:27,320
developers for information today thank

00:29:25,700 --> 00:29:28,800
you for your listening and I'll be happy

00:29:27,320 --> 00:29:30,860
to take questions

00:29:28,800 --> 00:29:30,860

YouTube URL: https://www.youtube.com/watch?v=20fYYDwiNqw


