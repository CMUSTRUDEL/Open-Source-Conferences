Title: BazelCon 2018 Day 2: Collecting Code Coverage With Bazel
Publication date: 2018-11-02
Playlist: BazelCon 2018
Description: 
	Irina Iancu (Google) event: Bazelcon 2018; re_ty: Publish; product: Open Source - General; fullname: Irina Iancu;
Captions: 
	00:00:05,200 --> 00:00:09,040
hi

00:00:06,000 --> 00:00:11,759
hello everyone my name is irina

00:00:09,040 --> 00:00:13,599
i'm a software engineer at google i work

00:00:11,759 --> 00:00:15,679
on the bazel team

00:00:13,599 --> 00:00:16,960
some of you may know me from github

00:00:15,679 --> 00:00:18,960
already

00:00:16,960 --> 00:00:20,720
today i want to talk to you about code

00:00:18,960 --> 00:00:22,080
coverage and how we collect it with

00:00:20,720 --> 00:00:23,840
bazel

00:00:22,080 --> 00:00:25,680
so i've heard that some of you are

00:00:23,840 --> 00:00:27,920
excited about this talk

00:00:25,680 --> 00:00:31,840
and i hope you will be excited after the

00:00:27,920 --> 00:00:31,840
talk is over as well

00:00:32,640 --> 00:00:37,120
okay so i know that most of you already

00:00:34,640 --> 00:00:39,280
know but just to cover the basics

00:00:37,120 --> 00:00:42,239
code coverage shows you how much of your

00:00:39,280 --> 00:00:44,960
code was executed when some particular

00:00:42,239 --> 00:00:47,840
tests run

00:00:44,960 --> 00:00:48,480
there are several types of coverage some

00:00:47,840 --> 00:00:50,480
tell you

00:00:48,480 --> 00:00:51,760
how many lines or functions were

00:00:50,480 --> 00:00:53,840
executed

00:00:51,760 --> 00:00:55,039
some tell you which of the branches were

00:00:53,840 --> 00:00:57,520
taken

00:00:55,039 --> 00:00:58,239
and some tell you which conditions of

00:00:57,520 --> 00:01:02,719
your code

00:00:58,239 --> 00:01:02,719
were evaluated to both true and false

00:01:02,960 --> 00:01:07,760
if we consider this very simple c plus

00:01:05,840 --> 00:01:09,600
plus example

00:01:07,760 --> 00:01:11,200
and we also assume that somewhere we

00:01:09,600 --> 00:01:14,400
have a test that runs the

00:01:11,200 --> 00:01:16,000
method full with parameters minus one

00:01:14,400 --> 00:01:17,759
and one

00:01:16,000 --> 00:01:19,200
then let's see what coverage will tell

00:01:17,759 --> 00:01:22,000
us

00:01:19,200 --> 00:01:24,640
well it tells us that eighty percent of

00:01:22,000 --> 00:01:27,280
the lines were covered

00:01:24,640 --> 00:01:28,560
all of the methods and functions were

00:01:27,280 --> 00:01:32,240
executed

00:01:28,560 --> 00:01:33,840
only 25 of the branches were taken

00:01:32,240 --> 00:01:36,799
but none of the conditions were

00:01:33,840 --> 00:01:39,119
evaluated to both true and false

00:01:36,799 --> 00:01:40,560
so if you look at this information

00:01:39,119 --> 00:01:42,399
individually

00:01:40,560 --> 00:01:44,000
you might draw some conflicting

00:01:42,399 --> 00:01:47,680
conclusions from them

00:01:44,000 --> 00:01:50,079
because some have very high percentage

00:01:47,680 --> 00:01:51,759
of coverage while others have it very

00:01:50,079 --> 00:01:54,720
low

00:01:51,759 --> 00:01:56,240
so you have to use some or all of this

00:01:54,720 --> 00:02:00,159
information together

00:01:56,240 --> 00:02:04,159
to draw some more meaningful conclusion

00:02:00,159 --> 00:02:04,159
about your source code and your tests

00:02:04,240 --> 00:02:11,280
this leads me to my next point why

00:02:07,600 --> 00:02:11,280
why is code coverage important

00:02:11,920 --> 00:02:16,560
well it gives you the confidence that

00:02:14,959 --> 00:02:19,680
when you add new code

00:02:16,560 --> 00:02:21,760
where when you just do big refactorings

00:02:19,680 --> 00:02:24,319
you have a smaller chance of introducing

00:02:21,760 --> 00:02:24,319
new bugs

00:02:24,640 --> 00:02:31,280
or they are just easier to detect

00:02:29,280 --> 00:02:32,400
you also know how all of your exceptions

00:02:31,280 --> 00:02:35,440
are handled

00:02:32,400 --> 00:02:38,879
and also that all of your edge cases

00:02:35,440 --> 00:02:39,599
are well tested you're also more

00:02:38,879 --> 00:02:41,599
confident

00:02:39,599 --> 00:02:42,800
that all your components are working

00:02:41,599 --> 00:02:44,800
well together

00:02:42,800 --> 00:02:45,840
for example when you do integration

00:02:44,800 --> 00:02:48,160
testing

00:02:45,840 --> 00:02:48,959
and also that they are just functioning

00:02:48,160 --> 00:02:52,560
properly

00:02:48,959 --> 00:02:52,560
when you do unit tests

00:02:55,760 --> 00:03:02,080
so there are mostly three types

00:02:58,879 --> 00:03:02,080
of computing coverage

00:03:02,159 --> 00:03:05,840
most of the time you would use either

00:03:04,400 --> 00:03:08,720
one of the first two

00:03:05,840 --> 00:03:11,120
in combination with the third one to get

00:03:08,720 --> 00:03:13,360
coverage information

00:03:11,120 --> 00:03:15,280
so you either instrument the source code

00:03:13,360 --> 00:03:18,400
or some intermediate code

00:03:15,280 --> 00:03:20,159
for example the class files in java

00:03:18,400 --> 00:03:21,440
and then you use that to collect

00:03:20,159 --> 00:03:24,159
coverage information

00:03:21,440 --> 00:03:24,159
at runtime

00:03:25,040 --> 00:03:30,000
so since this is such a nice feature we

00:03:27,360 --> 00:03:32,560
decided to add it to bazel

00:03:30,000 --> 00:03:34,159
however some of you already know we

00:03:32,560 --> 00:03:37,040
weren't very successful

00:03:34,159 --> 00:03:39,519
when we decided to open source it there

00:03:37,040 --> 00:03:41,760
were some problems

00:03:39,519 --> 00:03:42,959
for java coverage it only worked with

00:03:41,760 --> 00:03:45,920
one worker

00:03:42,959 --> 00:03:47,280
so you couldn't use the parallelism in

00:03:45,920 --> 00:03:50,159
bazel

00:03:47,280 --> 00:03:53,280
for c plus plus it was even worse

00:03:50,159 --> 00:03:53,280
because it was buggy

00:03:53,439 --> 00:03:59,439
bazel would randomly crash you would get

00:03:57,200 --> 00:04:01,120
either incomplete or incorrect coverage

00:03:59,439 --> 00:04:03,920
reports

00:04:01,120 --> 00:04:07,519
it was very slow and it had some other

00:04:03,920 --> 00:04:07,519
issues that i will not bore you with

00:04:09,200 --> 00:04:16,400
so we decided to improve it

00:04:13,280 --> 00:04:19,040
and now we have big goals

00:04:16,400 --> 00:04:20,799
and good intentions our mission is to

00:04:19,040 --> 00:04:22,079
generate and collect code coverage

00:04:20,799 --> 00:04:24,160
information

00:04:22,079 --> 00:04:25,600
and make it universal and useful to

00:04:24,160 --> 00:04:28,160
everybody

00:04:25,600 --> 00:04:29,040
yes if that sounds familiar that's the

00:04:28,160 --> 00:04:32,560
google mission

00:04:29,040 --> 00:04:35,520
and we adopted it to coverage

00:04:32,560 --> 00:04:37,360
okay but what does it actually mean so

00:04:35,520 --> 00:04:40,000
when i say it's universal

00:04:37,360 --> 00:04:41,440
i mean it's universal for all languages

00:04:40,000 --> 00:04:44,720
so it has to be

00:04:41,440 --> 00:04:47,759
language agnostic but at the same time

00:04:44,720 --> 00:04:50,240
it has to be useful so you have to have

00:04:47,759 --> 00:04:50,960
enough information to tell you something

00:04:50,240 --> 00:04:52,720
meaningful

00:04:50,960 --> 00:04:55,680
about your source code and about your

00:04:52,720 --> 00:04:57,759
tests so you have to have the

00:04:55,680 --> 00:04:59,520
all of the types of coverage i talked

00:04:57,759 --> 00:05:03,440
about before for line

00:04:59,520 --> 00:05:05,680
lines functions and branches

00:05:03,440 --> 00:05:06,960
but you should also be able to read it

00:05:05,680 --> 00:05:09,039
if you just want to

00:05:06,960 --> 00:05:11,680
quickly check it you have to be able to

00:05:09,039 --> 00:05:14,720
read it in a human readable format

00:05:11,680 --> 00:05:18,240
so it has to be a way to generate html

00:05:14,720 --> 00:05:18,240
reports from it for example

00:05:18,479 --> 00:05:22,639
and of course we want to keep the bazel

00:05:20,400 --> 00:05:25,360
standards so it has to be fast and

00:05:22,639 --> 00:05:28,639
correct as well

00:05:25,360 --> 00:05:30,720
so going back to being language agnostic

00:05:28,639 --> 00:05:32,080
for that to happen we need to have one

00:05:30,720 --> 00:05:35,120
coverage format

00:05:32,080 --> 00:05:37,919
for many languages

00:05:35,120 --> 00:05:40,320
so imagine your code base has sources in

00:05:37,919 --> 00:05:41,840
java and c plus plus and python

00:05:40,320 --> 00:05:43,840
you don't want to end up with three

00:05:41,840 --> 00:05:45,840
different coverage formats because that

00:05:43,840 --> 00:05:47,919
means more work

00:05:45,840 --> 00:05:49,919
you have to know how to handle all of

00:05:47,919 --> 00:05:52,320
them how to check them into your ci

00:05:49,919 --> 00:05:54,080
how to parse them how to make sense of

00:05:52,320 --> 00:05:58,240
them and so on

00:05:54,080 --> 00:05:58,240
so just let bazel deal with it

00:05:59,120 --> 00:06:05,360
so we needed a language agnostic format

00:06:02,319 --> 00:06:07,680
and finally we went for alcove

00:06:05,360 --> 00:06:09,919
there are several reasons why we chose

00:06:07,680 --> 00:06:11,520
it but here are the first one the main

00:06:09,919 --> 00:06:15,120
ones

00:06:11,520 --> 00:06:17,039
it's easy to parse and to understand

00:06:15,120 --> 00:06:19,039
you can also express most of the

00:06:17,039 --> 00:06:20,960
coverage information that i talked about

00:06:19,039 --> 00:06:22,960
in the beginnings for lines functions

00:06:20,960 --> 00:06:26,160
and branches

00:06:22,960 --> 00:06:29,440
and you can also check for

00:06:26,160 --> 00:06:31,600
nice summaries just to see if your

00:06:29,440 --> 00:06:34,319
tests pass some coverage standards that

00:06:31,600 --> 00:06:36,880
your project chose

00:06:34,319 --> 00:06:39,120
it's also very compact so it doesn't

00:06:36,880 --> 00:06:42,400
just annotate on the source code

00:06:39,120 --> 00:06:45,440
directly in the end

00:06:42,400 --> 00:06:48,319
there is a popular tool gen html

00:06:45,440 --> 00:06:50,479
that allows you to get html reports from

00:06:48,319 --> 00:06:50,479
it

00:06:51,599 --> 00:06:56,319
okay so let's go back to our previous

00:06:54,000 --> 00:06:59,680
example

00:06:56,319 --> 00:07:02,560
here is the elko file for it

00:06:59,680 --> 00:07:03,759
it might not tell you much but i really

00:07:02,560 --> 00:07:08,479
like how simple

00:07:03,759 --> 00:07:11,840
it is and how every line has a meaning

00:07:08,479 --> 00:07:14,479
so for every source in your code base

00:07:11,840 --> 00:07:16,080
you would get a record like this one it

00:07:14,479 --> 00:07:19,039
always starts with the file

00:07:16,080 --> 00:07:21,120
name and ends with the end of record

00:07:19,039 --> 00:07:23,199
marker

00:07:21,120 --> 00:07:25,599
so afterwards you will have information

00:07:23,199 --> 00:07:28,800
about function coverage

00:07:25,599 --> 00:07:29,440
for each of them it will tell you the

00:07:28,800 --> 00:07:32,639
name

00:07:29,440 --> 00:07:33,599
how many times it was executed and then

00:07:32,639 --> 00:07:37,759
a nice summary

00:07:33,599 --> 00:07:37,759
how many functions were found versus hit

00:07:38,160 --> 00:07:41,599
afterwards you have the same information

00:07:40,080 --> 00:07:44,639
about the lines

00:07:41,599 --> 00:07:46,479
the da lines actually tell you for each

00:07:44,639 --> 00:07:48,240
line number how many times it was

00:07:46,479 --> 00:07:50,800
executed

00:07:48,240 --> 00:07:54,240
and then the same nice summary how many

00:07:50,800 --> 00:07:54,240
lines were hit versus found

00:07:54,720 --> 00:07:58,080
of course you can also get the same data

00:07:56,960 --> 00:08:01,680
for branches but

00:07:58,080 --> 00:08:01,680
i just didn't include it here

00:08:02,720 --> 00:08:07,680
okay so you want to if you want to run

00:08:06,000 --> 00:08:11,039
basal coverage

00:08:07,680 --> 00:08:14,639
on your test target what bazel will do

00:08:11,039 --> 00:08:17,759
is it will output a coverage report

00:08:14,639 --> 00:08:19,360
for that test target but what you

00:08:17,759 --> 00:08:22,000
actually want to do

00:08:19,360 --> 00:08:22,960
is to run coverage over all of your

00:08:22,000 --> 00:08:25,120
tests

00:08:22,960 --> 00:08:26,160
so let's just assume here that all your

00:08:25,120 --> 00:08:28,800
tests for your

00:08:26,160 --> 00:08:31,440
whole code base is under the test

00:08:28,800 --> 00:08:31,440
directory

00:08:31,599 --> 00:08:35,519
let's also assume for simplicity that

00:08:33,599 --> 00:08:38,560
under the test directory we have

00:08:35,519 --> 00:08:38,560
and test targets

00:08:38,959 --> 00:08:44,240
so as i've said earlier bazel will

00:08:42,000 --> 00:08:46,399
output one coverage report per test

00:08:44,240 --> 00:08:48,959
target

00:08:46,399 --> 00:08:49,920
that is good is definitely better than

00:08:48,959 --> 00:08:53,120
ending up with

00:08:49,920 --> 00:08:54,240
n different coverage formats but we

00:08:53,120 --> 00:08:58,800
still have

00:08:54,240 --> 00:09:02,640
n reports and that may be too many

00:08:58,800 --> 00:09:06,080
so to fix this issue

00:09:02,640 --> 00:09:07,519
you could just specify the combined

00:09:06,080 --> 00:09:11,120
report flag

00:09:07,519 --> 00:09:13,680
and that will tell bazel hey just

00:09:11,120 --> 00:09:15,040
use all the coverage information you

00:09:13,680 --> 00:09:19,360
already computed

00:09:15,040 --> 00:09:19,360
and give it to me in one single report

00:09:19,440 --> 00:09:24,000
and it will do just that and for example

00:09:23,200 --> 00:09:27,360
afterward

00:09:24,000 --> 00:09:29,839
afterwards you could use gen html

00:09:27,360 --> 00:09:31,120
on that coverage report and get a nice

00:09:29,839 --> 00:09:34,399
html

00:09:31,120 --> 00:09:37,839
view of all the coverage

00:09:34,399 --> 00:09:37,839
in all your source code

00:09:39,120 --> 00:09:44,480
just to show you how that will look like

00:09:41,360 --> 00:09:46,959
on our previous example

00:09:44,480 --> 00:09:49,519
here it is you can easily see which of

00:09:46,959 --> 00:09:52,640
the lines were executed and not

00:09:49,519 --> 00:09:53,120
and in the top right corner you can also

00:09:52,640 --> 00:09:57,040
see

00:09:53,120 --> 00:09:57,040
a nice summary for your code

00:10:02,640 --> 00:10:06,800
now i want to talk to you about a

00:10:04,640 --> 00:10:08,640
different use case

00:10:06,800 --> 00:10:10,240
and now it's not about bash code

00:10:08,640 --> 00:10:12,690
coverage although that would be

00:10:10,240 --> 00:10:14,240
interesting as well

00:10:12,690 --> 00:10:17,360
[Music]

00:10:14,240 --> 00:10:19,920
so the use case is you have one test

00:10:17,360 --> 00:10:20,880
that invokes different binaries and the

00:10:19,920 --> 00:10:24,160
binaries

00:10:20,880 --> 00:10:26,160
correspond to different languages

00:10:24,160 --> 00:10:29,120
so in the end you would want the

00:10:26,160 --> 00:10:30,800
coverage report for that test to include

00:10:29,120 --> 00:10:33,839
all the information about all the

00:10:30,800 --> 00:10:35,680
sources that were executed

00:10:33,839 --> 00:10:39,519
so i'm going to choose the shell test

00:10:35,680 --> 00:10:42,320
here because it's just more convenient

00:10:39,519 --> 00:10:43,200
so let's look at this example on the

00:10:42,320 --> 00:10:45,519
right side

00:10:43,200 --> 00:10:46,640
we have the build file and we define the

00:10:45,519 --> 00:10:49,040
shell test

00:10:46,640 --> 00:10:51,600
we have the name and the source and then

00:10:49,040 --> 00:10:54,640
we have two data dependencies

00:10:51,600 --> 00:11:00,079
the first one is a c plus plus binary

00:10:54,640 --> 00:11:01,519
and the second one is a java binary on

00:11:00,079 --> 00:11:04,720
the left side

00:11:01,519 --> 00:11:08,959
we have the actual test

00:11:04,720 --> 00:11:08,959
we have two test methods

00:11:09,279 --> 00:11:16,959
each of them is invoking

00:11:12,720 --> 00:11:19,440
each of the binaries we also assume

00:11:16,959 --> 00:11:21,440
that we have a test framework in place

00:11:19,440 --> 00:11:23,440
that when you actually run

00:11:21,440 --> 00:11:26,160
the shell test it will run these two

00:11:23,440 --> 00:11:26,160
test methods

00:11:27,680 --> 00:11:31,440
so the problem here is we have one test

00:11:30,079 --> 00:11:34,560
target

00:11:31,440 --> 00:11:37,120
but we will also we will actually

00:11:34,560 --> 00:11:37,680
end up with two different reports one

00:11:37,120 --> 00:11:40,959
for c

00:11:37,680 --> 00:11:43,519
plus plus and one for java

00:11:40,959 --> 00:11:46,079
the good news is that bazel we detect

00:11:43,519 --> 00:11:48,720
this under the hood

00:11:46,079 --> 00:11:49,600
and we'll merge them together giving you

00:11:48,720 --> 00:11:52,480
the

00:11:49,600 --> 00:11:54,240
final output file so in the end you will

00:11:52,480 --> 00:11:57,200
have your coverage report

00:11:54,240 --> 00:11:58,000
that contains information for both c

00:11:57,200 --> 00:12:00,959
plus plus

00:11:58,000 --> 00:12:00,959
and java files

00:12:01,279 --> 00:12:06,160
okay but what do we actually support

00:12:04,480 --> 00:12:09,120
right now

00:12:06,160 --> 00:12:10,800
so currently we have built-in support

00:12:09,120 --> 00:12:14,000
for java

00:12:10,800 --> 00:12:16,240
for c plus plus we are currently working

00:12:14,000 --> 00:12:17,920
on fixing the issues that i've mentioned

00:12:16,240 --> 00:12:19,839
in the beginning

00:12:17,920 --> 00:12:21,360
and we also have plans to add the

00:12:19,839 --> 00:12:24,399
general mechanism

00:12:21,360 --> 00:12:28,800
so you could have you could add support

00:12:24,399 --> 00:12:28,800
coverage support for your starlark rules

00:12:30,720 --> 00:12:38,800
let's see how coverage actually works

00:12:32,800 --> 00:12:39,760
for java test so if you don't know

00:12:38,800 --> 00:12:43,440
already

00:12:39,760 --> 00:12:45,760
when we just run the java test in bazel

00:12:43,440 --> 00:12:47,440
for every java library on the dependency

00:12:45,760 --> 00:12:52,560
graph

00:12:47,440 --> 00:12:54,800
we would build a library jar

00:12:52,560 --> 00:12:55,920
so for every every java library we get

00:12:54,800 --> 00:12:58,000
the sources

00:12:55,920 --> 00:13:01,200
we compile them to class files we pack

00:12:58,000 --> 00:13:03,120
them together into the library jar

00:13:01,200 --> 00:13:06,480
when in coverage mode we also do the

00:13:03,120 --> 00:13:10,240
same with an additional step

00:13:06,480 --> 00:13:14,160
we instrument the class files using

00:13:10,240 --> 00:13:17,680
yakoco which is a popular tool for

00:13:14,160 --> 00:13:18,800
java coverage and then we pack

00:13:17,680 --> 00:13:22,320
everything together

00:13:18,800 --> 00:13:22,320
into the library jar

00:13:23,120 --> 00:13:26,639
when we actually create a test

00:13:24,959 --> 00:13:30,000
executable

00:13:26,639 --> 00:13:32,320
we will use we will wrap it in a yakoco

00:13:30,000 --> 00:13:35,360
coverage runner

00:13:32,320 --> 00:13:36,000
what that does is it only executes the

00:13:35,360 --> 00:13:38,800
test

00:13:36,000 --> 00:13:40,959
and immediately after it receives

00:13:38,800 --> 00:13:42,560
coverage information from the yakoco

00:13:40,959 --> 00:13:44,880
plugin

00:13:42,560 --> 00:13:46,320
and it immediately converts it to the

00:13:44,880 --> 00:13:49,279
alco format

00:13:46,320 --> 00:13:52,399
so we will end up with the coverage file

00:13:49,279 --> 00:13:52,399
in elko format

00:13:53,440 --> 00:13:58,320
we also have this experimental java

00:13:56,399 --> 00:14:03,839
coverage flag

00:13:58,320 --> 00:14:03,839
which should be non-experimental soon

00:14:04,000 --> 00:14:10,959
what what this does it it allows

00:14:07,600 --> 00:14:13,680
starlark rules for jvm languages

00:14:10,959 --> 00:14:14,720
like kathleen or scala to add coverage

00:14:13,680 --> 00:14:17,360
support

00:14:14,720 --> 00:14:18,959
and it interoperates very well with the

00:14:17,360 --> 00:14:22,880
native java library

00:14:18,959 --> 00:14:26,320
so if you use the javascript starlark

00:14:22,880 --> 00:14:29,279
api so the java sandwich

00:14:26,320 --> 00:14:29,680
you would get coverage information for

00:14:29,279 --> 00:14:33,120
your

00:14:29,680 --> 00:14:35,519
jvm languages and also for the java

00:14:33,120 --> 00:14:35,519
files

00:14:37,600 --> 00:14:41,680
this is this currently works on all

00:14:40,480 --> 00:14:45,839
three platforms

00:14:41,680 --> 00:14:45,839
so all is well here

00:14:46,480 --> 00:14:53,920
let's see now for c plus plus for c

00:14:49,680 --> 00:14:57,360
plus plus the story is quite different

00:14:53,920 --> 00:15:00,560
and let's see first how the workflow

00:14:57,360 --> 00:15:03,680
is what i'm going to present next is

00:15:00,560 --> 00:15:05,279
how it actually works for bazel at head

00:15:03,680 --> 00:15:07,839
because we decided to go with a

00:15:05,279 --> 00:15:12,639
different approach to fix all the issues

00:15:07,839 --> 00:15:17,360
i've mentioned before in a separate way

00:15:12,639 --> 00:15:20,560
okay so it's only a few steps so

00:15:17,360 --> 00:15:22,880
let's go over them together so for every

00:15:20,560 --> 00:15:25,440
cc library we'll get the sources

00:15:22,880 --> 00:15:26,160
and we will compile and link them using

00:15:25,440 --> 00:15:29,680
some

00:15:26,160 --> 00:15:29,680
coverage specific flags

00:15:30,160 --> 00:15:33,600
afterwards we get the test binary in the

00:15:32,800 --> 00:15:38,160
end

00:15:33,600 --> 00:15:41,120
and also some gcno files along the way

00:15:38,160 --> 00:15:42,720
the gcno files are just notes about

00:15:41,120 --> 00:15:46,720
coverage

00:15:42,720 --> 00:15:49,519
that we will use later so we execute the

00:15:46,720 --> 00:15:49,519
test binary

00:15:49,839 --> 00:15:54,000
and after that this step will also

00:15:52,959 --> 00:15:59,440
generate the second

00:15:54,000 --> 00:16:01,759
type of metadata files the gcda files

00:15:59,440 --> 00:16:04,800
these are basically files containing

00:16:01,759 --> 00:16:04,800
profiling data

00:16:05,680 --> 00:16:10,240
so until now we just compiled and

00:16:08,959 --> 00:16:13,279
executed

00:16:10,240 --> 00:16:16,320
the test now we ended up with some

00:16:13,279 --> 00:16:19,040
metadata coverage files but not with

00:16:16,320 --> 00:16:19,759
some coverage information so we have to

00:16:19,040 --> 00:16:23,519
extract

00:16:19,759 --> 00:16:26,079
extract that and additionally we will

00:16:23,519 --> 00:16:29,839
run the gcov

00:16:26,079 --> 00:16:32,800
tool having inputs pairs of gcno and

00:16:29,839 --> 00:16:35,360
gcda files

00:16:32,800 --> 00:16:36,160
what that will bring us is an

00:16:35,360 --> 00:16:40,880
intermediate

00:16:36,160 --> 00:16:43,600
gco file that one of our tools

00:16:40,880 --> 00:16:44,320
coverage output generator knows how to

00:16:43,600 --> 00:16:47,440
parse

00:16:44,320 --> 00:16:50,560
and eventually convert to alcove format

00:16:47,440 --> 00:16:54,480
so you will also in the end

00:16:50,560 --> 00:16:54,480
end up with an elko format file

00:16:56,480 --> 00:17:04,400
as you have probably noticed

00:17:00,000 --> 00:17:07,520
the previous workflow only works for gcc

00:17:04,400 --> 00:17:08,880
we are currently working on adding llvm

00:17:07,520 --> 00:17:12,559
support

00:17:08,880 --> 00:17:12,559
that will use prof data

00:17:12,640 --> 00:17:21,120
that should be available this quarter

00:17:19,199 --> 00:17:23,600
so as i've mentioned everything that i

00:17:21,120 --> 00:17:24,400
presented here for c plus plus happens

00:17:23,600 --> 00:17:27,679
under the

00:17:24,400 --> 00:17:31,039
experimental cc coverage flag

00:17:27,679 --> 00:17:35,919
this should become non-experimental

00:17:31,039 --> 00:17:35,919
when llvm support will also arrive

00:17:38,240 --> 00:17:42,000
unfortunately this only works for linux

00:17:41,200 --> 00:17:45,120
but

00:17:42,000 --> 00:17:48,720
we hope that the llvm support will

00:17:45,120 --> 00:17:48,720
work on all three platforms

00:17:49,600 --> 00:17:54,640
okay but what happens when i want to run

00:17:52,320 --> 00:17:58,799
coverage on my random

00:17:54,640 --> 00:18:01,919
test well we are working for

00:17:58,799 --> 00:18:04,000
on it as i've said in the beginning we

00:18:01,919 --> 00:18:05,919
plan to add a general mechanism

00:18:04,000 --> 00:18:09,600
that will allow you to add coverage

00:18:05,919 --> 00:18:13,760
support to your starlark rules

00:18:09,600 --> 00:18:16,320
our plan is to add a coverage tool chain

00:18:13,760 --> 00:18:17,520
that will tell bazel how to embed your

00:18:16,320 --> 00:18:19,840
coverage tools

00:18:17,520 --> 00:18:20,880
and also how to get intermediate

00:18:19,840 --> 00:18:23,440
coverage reports

00:18:20,880 --> 00:18:24,720
and eventually convert them to alcove

00:18:23,440 --> 00:18:28,320
because that's how

00:18:24,720 --> 00:18:31,919
it has to be in the end

00:18:28,320 --> 00:18:32,960
okay that was very specific for java and

00:18:31,919 --> 00:18:35,600
c plus plus

00:18:32,960 --> 00:18:36,559
but let's see here what the bigger

00:18:35,600 --> 00:18:39,600
picture is

00:18:36,559 --> 00:18:43,840
how does bazel actually

00:18:39,600 --> 00:18:43,840
compute coverage

00:18:46,559 --> 00:18:52,880
so instead of just running the test

00:18:49,679 --> 00:18:56,559
we wrap it in a script

00:18:52,880 --> 00:18:59,520
the script has these three steps

00:18:56,559 --> 00:19:00,720
it says the environment it runs the test

00:18:59,520 --> 00:19:02,799
and eventually

00:19:00,720 --> 00:19:04,880
runs an additional script to generate

00:19:02,799 --> 00:19:07,440
some coverage formats

00:19:04,880 --> 00:19:07,919
and then it runs the tool i've mentioned

00:19:07,440 --> 00:19:10,960
before

00:19:07,919 --> 00:19:13,600
coverage output generator

00:19:10,960 --> 00:19:15,760
for people that already are familiar

00:19:13,600 --> 00:19:18,080
with how bazel coverage works

00:19:15,760 --> 00:19:19,440
this tool was formally known as elk of

00:19:18,080 --> 00:19:22,000
merger

00:19:19,440 --> 00:19:23,440
we rebranded it because now it does so

00:19:22,000 --> 00:19:26,720
much more than just

00:19:23,440 --> 00:19:26,720
merging alcohols

00:19:27,760 --> 00:19:31,520
so just to go over all these steps in

00:19:30,240 --> 00:19:33,840
more details

00:19:31,520 --> 00:19:36,840
the first one is very simple you just

00:19:33,840 --> 00:19:38,320
make sure that the test nose is runs in

00:19:36,840 --> 00:19:41,280
coverage

00:19:38,320 --> 00:19:43,600
so just to give you an example sm sets

00:19:41,280 --> 00:19:45,520
some environment variables

00:19:43,600 --> 00:19:48,320
some tell the test where to place

00:19:45,520 --> 00:19:51,200
intermediate files

00:19:48,320 --> 00:19:52,080
and for some languages like c plus plus

00:19:51,200 --> 00:19:54,880
it needs to know

00:19:52,080 --> 00:19:59,600
where to place intermediate metadata

00:19:54,880 --> 00:19:59,600
files so the gcno and gcda files

00:20:00,960 --> 00:20:06,240
then we just execute the test and maybe

00:20:04,480 --> 00:20:07,840
we also execute another script to

00:20:06,240 --> 00:20:11,360
generate coverage

00:20:07,840 --> 00:20:16,480
this 2a corresponds

00:20:11,360 --> 00:20:16,480
to running gcov in the c plus workflow

00:20:16,799 --> 00:20:23,520
whatever it does when this step is done

00:20:20,159 --> 00:20:25,520
it has to generate at least one file

00:20:23,520 --> 00:20:26,720
that the coverage output generator will

00:20:25,520 --> 00:20:28,480
know how to parse

00:20:26,720 --> 00:20:31,120
and it has to be under the coverage

00:20:28,480 --> 00:20:31,120
directory

00:20:31,679 --> 00:20:36,559
and then we run the coverage output

00:20:33,919 --> 00:20:36,559
generator

00:20:37,520 --> 00:20:42,080
so what it does it just looks under the

00:20:40,640 --> 00:20:44,960
coverage directory

00:20:42,080 --> 00:20:45,919
and it tries to make sense out of it so

00:20:44,960 --> 00:20:48,960
it looks for

00:20:45,919 --> 00:20:52,080
files that he knows how to parse

00:20:48,960 --> 00:20:54,960
right now it only knows the elko format

00:20:52,080 --> 00:20:56,880
which is the dat files here and also the

00:20:54,960 --> 00:20:59,760
gig of intermediate format that i've

00:20:56,880 --> 00:20:59,760
already mentioned

00:20:59,919 --> 00:21:03,120
after it finds the file it will parse

00:21:02,000 --> 00:21:05,200
them

00:21:03,120 --> 00:21:06,720
it will store them in an internal data

00:21:05,200 --> 00:21:08,640
structure

00:21:06,720 --> 00:21:11,679
and eventually it filters out some of

00:21:08,640 --> 00:21:12,960
the unwanted sources

00:21:11,679 --> 00:21:15,120
for example if you use the

00:21:12,960 --> 00:21:17,360
instrumentation filter flag

00:21:15,120 --> 00:21:19,360
you will tell bazel that you only want

00:21:17,360 --> 00:21:21,039
coverage for some parts of your source

00:21:19,360 --> 00:21:25,200
code

00:21:21,039 --> 00:21:27,360
so then we have to filter some out

00:21:25,200 --> 00:21:28,320
after all this is done it merges

00:21:27,360 --> 00:21:31,520
together all the

00:21:28,320 --> 00:21:35,120
coverage information that was found

00:21:31,520 --> 00:21:37,840
and it writes it to the final coverage

00:21:35,120 --> 00:21:37,840
output file

00:21:39,280 --> 00:21:45,840
so that was mostly how coverage works

00:21:43,120 --> 00:21:45,840
right now

00:21:46,559 --> 00:21:53,280
you can find our roadmap at this link

00:21:51,440 --> 00:21:55,200
and thank you very much for your

00:21:53,280 --> 00:21:57,520
attention

00:21:55,200 --> 00:22:00,159
if you have questions i can also take

00:21:57,520 --> 00:22:02,720
them now or you can find me afterwards

00:22:00,159 --> 00:22:06,080
you can also assign all the coverage

00:22:02,720 --> 00:22:06,080
bugs to me on github

00:22:08,720 --> 00:22:17,200
so thank you

00:22:13,150 --> 00:22:19,280
[Applause]

00:22:17,200 --> 00:22:19,280

YouTube URL: https://www.youtube.com/watch?v=P51Rgcbxhyk


