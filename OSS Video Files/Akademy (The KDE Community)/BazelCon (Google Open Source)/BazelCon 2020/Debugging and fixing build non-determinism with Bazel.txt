Title: Debugging and fixing build non-determinism with Bazel
Publication date: 2021-01-25
Playlist: BazelCon 2020
Description: 
	Bazel has many great features — an extensible, declarative build language, super-fast incremental builds, and a remote build cache — but in order to take full advantage of the build cache the build has to be deterministic. Migrating Square’s iOS applications from Xcode’s build system allows us to use Bazel’s bevvy of tools to track down where the build is yielding nondeterministic outputs in order to speed up our builds. In this talk, we explore how to use Bazel tools to track down non-deterministic actions, go over a few tricks to find out why they are non-deterministic; and come up with concrete fixes to make builds (more) deterministic and take full advantage of caching.

Resources:
GitHub → http://goo.gle/39U9dnu
Build with Bazel → http://goo.gle/2NuVRXm

Speaker: Samuel Giddins

Watch more:
BazelCon post event sessions → http://goo.gle/2YfIvAx
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Samuel Giddins;
Captions: 
	00:00:01,040 --> 00:00:07,120
[Music]

00:00:06,080 --> 00:00:09,120
hi there

00:00:07,120 --> 00:00:11,040
i'm going to be talking a bit today

00:00:09,120 --> 00:00:14,320
about finding causes of

00:00:11,040 --> 00:00:17,440
build non-determinism in bazel

00:00:14,320 --> 00:00:19,600
so first a bit about me

00:00:17,440 --> 00:00:21,439
my name is samuel and i work on the

00:00:19,600 --> 00:00:22,320
mobile developer experience team at

00:00:21,439 --> 00:00:24,080
square

00:00:22,320 --> 00:00:26,080
and over the past year we've been

00:00:24,080 --> 00:00:29,439
working on migrating our builds from

00:00:26,080 --> 00:00:33,040
xcode over to bazel and that migration

00:00:29,439 --> 00:00:35,840
is what's inspired this talk bazel

00:00:33,040 --> 00:00:36,880
is an awesome build system bazel

00:00:35,840 --> 00:00:40,239
promises both

00:00:36,880 --> 00:00:42,320
performance and correctness and

00:00:40,239 --> 00:00:43,520
honestly what more could you ask for in

00:00:42,320 --> 00:00:46,320
your builds

00:00:43,520 --> 00:00:46,800
but the fact is fast and correct are

00:00:46,320 --> 00:00:49,440
both

00:00:46,800 --> 00:00:49,920
highly related to each other and bazel

00:00:49,440 --> 00:00:53,280
would be

00:00:49,920 --> 00:00:56,840
unable to deliver one without the other

00:00:53,280 --> 00:00:58,000
so what does it mean for a build to be

00:00:56,840 --> 00:01:00,800
fast

00:00:58,000 --> 00:01:02,559
well when you do a clean build you

00:01:00,800 --> 00:01:05,119
download the source code for the first

00:01:02,559 --> 00:01:07,040
time and run build for the first time

00:01:05,119 --> 00:01:08,240
you don't want to do any unnecessary

00:01:07,040 --> 00:01:10,400
work

00:01:08,240 --> 00:01:11,439
and similarly when you change a single

00:01:10,400 --> 00:01:14,560
source file

00:01:11,439 --> 00:01:15,040
and run build again you still don't want

00:01:14,560 --> 00:01:18,080
to do

00:01:15,040 --> 00:01:21,280
any unnecessary work

00:01:18,080 --> 00:01:21,920
and you want to be able to use all the

00:01:21,280 --> 00:01:26,000
cores

00:01:21,920 --> 00:01:28,320
available on your machine or even better

00:01:26,000 --> 00:01:29,360
on someone else's machine that you're

00:01:28,320 --> 00:01:32,479
able to run

00:01:29,360 --> 00:01:34,479
compute on and last

00:01:32,479 --> 00:01:35,600
but certainly not least like any good

00:01:34,479 --> 00:01:38,000
programmer you

00:01:35,600 --> 00:01:39,200
just don't want to do work when it's

00:01:38,000 --> 00:01:41,280
avoidable

00:01:39,200 --> 00:01:44,880
don't run things that don't need to be

00:01:41,280 --> 00:01:44,880
run to finish the build

00:01:45,119 --> 00:01:48,240
now correctness is a lot simpler to

00:01:47,200 --> 00:01:50,399
define

00:01:48,240 --> 00:01:52,880
correctness from a build system simply

00:01:50,399 --> 00:01:56,000
means that given the same inputs

00:01:52,880 --> 00:01:58,719
you're going to produce the same outputs

00:01:56,000 --> 00:02:00,640
and bazel's entire design is based

00:01:58,719 --> 00:02:03,200
around these principles

00:02:00,640 --> 00:02:04,880
fast and correct are not only goals but

00:02:03,200 --> 00:02:07,439
they're core assumptions made

00:02:04,880 --> 00:02:08,399
in bazel and they help reinforce each

00:02:07,439 --> 00:02:11,599
other

00:02:08,399 --> 00:02:15,040
so fast how do we get there

00:02:11,599 --> 00:02:16,160
oh first off we want to cache artifacts

00:02:15,040 --> 00:02:18,560
as much as possible

00:02:16,160 --> 00:02:19,840
when you compile a source file you want

00:02:18,560 --> 00:02:23,120
to take the outputs

00:02:19,840 --> 00:02:25,840
of that and save them so when you

00:02:23,120 --> 00:02:26,319
go to compile the same exact source file

00:02:25,840 --> 00:02:28,879
again

00:02:26,319 --> 00:02:30,480
well you can skip doing the work because

00:02:28,879 --> 00:02:31,760
you already know what the output is

00:02:30,480 --> 00:02:33,920
going to be

00:02:31,760 --> 00:02:35,280
and those artifacts you want to cache

00:02:33,920 --> 00:02:37,920
them locally

00:02:35,280 --> 00:02:40,879
for the benefit of your future self you

00:02:37,920 --> 00:02:43,440
also want to cash them remotely

00:02:40,879 --> 00:02:46,239
for the benefit of your teammates or

00:02:43,440 --> 00:02:49,280
build machines that you may have running

00:02:46,239 --> 00:02:52,800
so now we're going to try and motivate

00:02:49,280 --> 00:02:56,080
why we care about deterministic aka

00:02:52,800 --> 00:02:57,680
correct builds and it's because of this

00:02:56,080 --> 00:03:00,959
caching

00:02:57,680 --> 00:03:04,159
to be able to use cached artifacts

00:03:00,959 --> 00:03:07,840
and now here's a

00:03:04,159 --> 00:03:11,360
fancy computer science term warning um

00:03:07,840 --> 00:03:13,840
builds in basil or merkle trees

00:03:11,360 --> 00:03:14,720
which is a fancy way of saying it's

00:03:13,840 --> 00:03:17,599
checksums

00:03:14,720 --> 00:03:19,360
all the way down so to be able to use

00:03:17,599 --> 00:03:21,920
cached artifacts

00:03:19,360 --> 00:03:24,159
all the inputs in that merkle tree need

00:03:21,920 --> 00:03:26,879
to be the same

00:03:24,159 --> 00:03:27,440
bazel's caching is entirely dependent

00:03:26,879 --> 00:03:30,879
upon

00:03:27,440 --> 00:03:33,599
file checksums sha-256 checksums to be

00:03:30,879 --> 00:03:35,920
precise rather than the timestamps that

00:03:33,599 --> 00:03:39,040
a lot of local only build systems

00:03:35,920 --> 00:03:42,080
such as make use now

00:03:39,040 --> 00:03:44,640
caching in bazel works on

00:03:42,080 --> 00:03:46,319
two levels and i i hope you'll forgive

00:03:44,640 --> 00:03:49,680
this quick digression

00:03:46,319 --> 00:03:52,480
as to how caching works and this

00:03:49,680 --> 00:03:53,920
explanation holds for both a remote and

00:03:52,480 --> 00:03:58,000
a local cache

00:03:53,920 --> 00:04:00,319
so the first level is the action cache

00:03:58,000 --> 00:04:01,040
bazel will look at each action it would

00:04:00,319 --> 00:04:04,080
want to run

00:04:01,040 --> 00:04:06,080
and compute its hash this hash contains

00:04:04,080 --> 00:04:09,040
the definition of the action

00:04:06,080 --> 00:04:09,680
think the environment variables that it

00:04:09,040 --> 00:04:11,920
uses

00:04:09,680 --> 00:04:12,879
the list of output files it's going to

00:04:11,920 --> 00:04:14,720
create

00:04:12,879 --> 00:04:16,079
the command line to actually run the

00:04:14,720 --> 00:04:18,239
action

00:04:16,079 --> 00:04:20,799
and also a combined hash of all the

00:04:18,239 --> 00:04:23,919
input files to the action

00:04:20,799 --> 00:04:25,360
and when you get a cache hit the action

00:04:23,919 --> 00:04:28,400
cache will tell you

00:04:25,360 --> 00:04:31,360
what the digest of the outputs are

00:04:28,400 --> 00:04:33,840
so you can go and look them up where are

00:04:31,360 --> 00:04:36,880
you going to look those outputs up

00:04:33,840 --> 00:04:37,840
in the content addressable storage the

00:04:36,880 --> 00:04:40,880
cas

00:04:37,840 --> 00:04:42,400
is much simpler it's called content

00:04:40,880 --> 00:04:45,600
addressable because

00:04:42,400 --> 00:04:49,440
the cache key for each object is derived

00:04:45,600 --> 00:04:52,639
you guessed it solely from its content

00:04:49,440 --> 00:04:53,600
and this helps make it resilient to hash

00:04:52,639 --> 00:04:56,400
collisions

00:04:53,600 --> 00:04:58,080
and it also makes integrity verification

00:04:56,400 --> 00:05:01,199
really easy

00:04:58,080 --> 00:05:04,160
another benefit is that if

00:05:01,199 --> 00:05:05,120
the same file shows up multiple times in

00:05:04,160 --> 00:05:08,160
your build

00:05:05,120 --> 00:05:09,120
it can share a cache entry and one place

00:05:08,160 --> 00:05:11,440
where this comes up

00:05:09,120 --> 00:05:12,960
really really frequently is with the

00:05:11,440 --> 00:05:15,680
empty file

00:05:12,960 --> 00:05:17,600
it turns out that files everywhere in

00:05:15,680 --> 00:05:20,800
everyone's builds

00:05:17,600 --> 00:05:22,560
so you might be thinking thanks for the

00:05:20,800 --> 00:05:26,400
background samuel

00:05:22,560 --> 00:05:29,919
but i'm not exactly sure why i'd care

00:05:26,400 --> 00:05:32,240
where's the problem and

00:05:29,919 --> 00:05:34,400
well it's not really a problem but

00:05:32,240 --> 00:05:36,880
bazel's model requires that

00:05:34,400 --> 00:05:38,400
the content of each output be

00:05:36,880 --> 00:05:42,080
deterministic

00:05:38,400 --> 00:05:44,520
this is a gross over simplification

00:05:42,080 --> 00:05:45,680
bazel can work just fine with

00:05:44,520 --> 00:05:48,240
non-deterministic

00:05:45,680 --> 00:05:51,120
outputs but you want fast and

00:05:48,240 --> 00:05:54,240
predictable builds right

00:05:51,120 --> 00:05:56,759
right so here's

00:05:54,240 --> 00:05:59,280
a really simple example of a

00:05:56,759 --> 00:06:02,319
non-deterministic action

00:05:59,280 --> 00:06:05,039
this is a general that is valid

00:06:02,319 --> 00:06:07,199
according to bazel it'll even work with

00:06:05,039 --> 00:06:10,560
sandboxing enabled

00:06:07,199 --> 00:06:14,400
but if you get bazel to run it twice

00:06:10,560 --> 00:06:16,960
it'll give you two outputs for the same

00:06:14,400 --> 00:06:19,520
set of inputs in this case it's the

00:06:16,960 --> 00:06:22,560
empty set of inputs

00:06:19,520 --> 00:06:24,080
now there are a couple of common sources

00:06:22,560 --> 00:06:27,440
of non-determinism

00:06:24,080 --> 00:06:30,720
that i've run into over and over

00:06:27,440 --> 00:06:33,520
the first one of them is random numbers

00:06:30,720 --> 00:06:35,199
um it shouldn't be much of a surprise

00:06:33,520 --> 00:06:39,680
that randomness

00:06:35,199 --> 00:06:43,360
is kind of the enemy of determinism

00:06:39,680 --> 00:06:46,319
the next is sorting of hash maps

00:06:43,360 --> 00:06:48,000
and dictionaries many programming

00:06:46,319 --> 00:06:51,599
languages use

00:06:48,000 --> 00:06:53,680
random sorting of dictionaries

00:06:51,599 --> 00:06:54,800
and so when those dictionaries get

00:06:53,680 --> 00:06:58,720
written out

00:06:54,800 --> 00:07:01,280
as outputs their contents can be jumbled

00:06:58,720 --> 00:07:03,280
from run to run

00:07:01,280 --> 00:07:05,120
another common source of non-determinism

00:07:03,280 --> 00:07:06,720
is time stamps

00:07:05,120 --> 00:07:09,680
when we talk about running multiple

00:07:06,720 --> 00:07:12,800
builds we mostly mean builds run

00:07:09,680 --> 00:07:15,599
at different times and so if you run

00:07:12,800 --> 00:07:18,400
multiple builds the time stamps

00:07:15,599 --> 00:07:20,479
that can get embedded into output files

00:07:18,400 --> 00:07:23,520
will be different

00:07:20,479 --> 00:07:24,960
and finally incorrect rule

00:07:23,520 --> 00:07:29,039
implementations

00:07:24,960 --> 00:07:32,160
can lead to non-deterministic builds

00:07:29,039 --> 00:07:34,880
a really common example of this is if

00:07:32,160 --> 00:07:38,639
you have sandboxing disabled

00:07:34,880 --> 00:07:41,120
and one of your actions uses a file

00:07:38,639 --> 00:07:43,199
that it hasn't declared as an input

00:07:41,120 --> 00:07:46,560
bazel won't know about that

00:07:43,199 --> 00:07:47,840
and so it might run actions in different

00:07:46,560 --> 00:07:49,280
orders

00:07:47,840 --> 00:07:51,120
and you may end up with different

00:07:49,280 --> 00:07:53,759
results now

00:07:51,120 --> 00:07:55,680
that one's not really bazel's fault um

00:07:53,759 --> 00:07:59,039
the the fix there is sort of

00:07:55,680 --> 00:08:01,680
fix the rule implementation so

00:07:59,039 --> 00:08:02,879
cool we now know that there's a bunch of

00:08:01,680 --> 00:08:05,680
ways to make a build

00:08:02,879 --> 00:08:06,800
non-deterministic but knowing that it's

00:08:05,680 --> 00:08:08,560
possible in a build

00:08:06,800 --> 00:08:11,280
is different from finding out where it's

00:08:08,560 --> 00:08:13,440
happening and putting a stop to it

00:08:11,280 --> 00:08:15,599
but how can we tell when it's happening

00:08:13,440 --> 00:08:16,960
otherwise we'll just suffer a broken

00:08:15,599 --> 00:08:20,160
build for

00:08:16,960 --> 00:08:20,960
approximately forever and take my word

00:08:20,160 --> 00:08:24,160
for it

00:08:20,960 --> 00:08:25,199
that's no fun a couple of common

00:08:24,160 --> 00:08:28,240
symptoms that will

00:08:25,199 --> 00:08:31,680
point to a non-deterministic build

00:08:28,240 --> 00:08:34,479
have to do unsurprisingly with caching

00:08:31,680 --> 00:08:35,919
the first is when we see a cache just

00:08:34,479 --> 00:08:37,760
keep on growing

00:08:35,919 --> 00:08:39,680
we keep running builds on the same

00:08:37,760 --> 00:08:42,080
commit over and over and over and the

00:08:39,680 --> 00:08:45,120
cache keeps growing

00:08:42,080 --> 00:08:47,600
similarly we can see that

00:08:45,120 --> 00:08:48,399
rebuilding the same commit is running

00:08:47,600 --> 00:08:51,600
actions

00:08:48,399 --> 00:08:52,399
over and over again even though the

00:08:51,600 --> 00:08:56,320
build

00:08:52,399 --> 00:08:59,440
action output should be cached

00:08:56,320 --> 00:09:01,760
now the last way would be the best

00:08:59,440 --> 00:09:02,640
but unfortunately it isn't as easy as it

00:09:01,760 --> 00:09:06,000
should be

00:09:02,640 --> 00:09:08,519
bazel could just tell us somehow

00:09:06,000 --> 00:09:10,720
magically that our build is

00:09:08,519 --> 00:09:14,160
non-deterministic

00:09:10,720 --> 00:09:14,560
it doesn't but fear not bazel actually

00:09:14,160 --> 00:09:17,920
has

00:09:14,560 --> 00:09:19,600
all the tools you need to figure it out

00:09:17,920 --> 00:09:21,600
and we're about to walk through how to

00:09:19,600 --> 00:09:23,600
stitch them together

00:09:21,600 --> 00:09:24,880
so to get started we're going to want to

00:09:23,600 --> 00:09:27,360
set up a cache

00:09:24,880 --> 00:09:29,440
not to make our builds faster though

00:09:27,360 --> 00:09:29,920
this work will help in that department

00:09:29,440 --> 00:09:32,560
too

00:09:29,920 --> 00:09:33,680
i promise but so we have a good place

00:09:32,560 --> 00:09:35,279
set up to store

00:09:33,680 --> 00:09:37,040
all the artifacts we're about to

00:09:35,279 --> 00:09:39,279
generate now

00:09:37,040 --> 00:09:41,200
unfortunately doing this investigation

00:09:39,279 --> 00:09:42,560
is going to require some bespoke

00:09:41,200 --> 00:09:44,959
configuration

00:09:42,560 --> 00:09:46,240
by default bazel doesn't spit out all of

00:09:44,959 --> 00:09:48,880
the info we need

00:09:46,240 --> 00:09:50,320
nor behave in the way we need now this

00:09:48,880 --> 00:09:53,120
is actually a good thing

00:09:50,320 --> 00:09:54,000
we don't want to do fill full builds all

00:09:53,120 --> 00:09:56,240
the time

00:09:54,000 --> 00:09:57,279
we don't want to generate massive logs

00:09:56,240 --> 00:10:00,080
all the time

00:09:57,279 --> 00:10:01,760
um but for this particular inves

00:10:00,080 --> 00:10:03,120
investigation we're going to need to

00:10:01,760 --> 00:10:06,320
configure bazel to do

00:10:03,120 --> 00:10:07,760
just that so now that we've done the

00:10:06,320 --> 00:10:10,560
configuration

00:10:07,760 --> 00:10:12,800
it's time to build we're going to want

00:10:10,560 --> 00:10:13,600
to start off by running a bazel clean

00:10:12,800 --> 00:10:16,720
dash dash

00:10:13,600 --> 00:10:18,240
expunge we want all of our actions to

00:10:16,720 --> 00:10:20,079
get executed and

00:10:18,240 --> 00:10:21,519
yes i promise this is one of the few

00:10:20,079 --> 00:10:24,399
times that anyone

00:10:21,519 --> 00:10:26,000
is going to tell you that you need to do

00:10:24,399 --> 00:10:28,399
a basil clean

00:10:26,000 --> 00:10:29,440
so we're running our bill to go grab a

00:10:28,399 --> 00:10:31,360
nice cup of tea

00:10:29,440 --> 00:10:33,839
if your project is anything like ours

00:10:31,360 --> 00:10:35,040
you're going to be building a very large

00:10:33,839 --> 00:10:37,440
application

00:10:35,040 --> 00:10:38,720
and have to wait maybe around half an

00:10:37,440 --> 00:10:41,680
hour

00:10:38,720 --> 00:10:42,000
and when you come back your build is

00:10:41,680 --> 00:10:43,839
done

00:10:42,000 --> 00:10:45,440
remember to save the experimental

00:10:43,839 --> 00:10:47,200
execution log file

00:10:45,440 --> 00:10:49,600
that you just configured bazel to

00:10:47,200 --> 00:10:50,399
generate this is the file we're really

00:10:49,600 --> 00:10:52,480
after

00:10:50,399 --> 00:10:53,920
it contains a record of every action

00:10:52,480 --> 00:10:55,839
bazel is executed

00:10:53,920 --> 00:10:58,160
along with some details about that

00:10:55,839 --> 00:10:58,160
action

00:10:58,320 --> 00:11:04,880
so that exec log file contains

00:11:01,680 --> 00:11:07,920
the uh environment variables the

00:11:04,880 --> 00:11:09,120
command line the input files and the

00:11:07,920 --> 00:11:12,160
output files of

00:11:09,120 --> 00:11:14,880
every single action that bazel has run

00:11:12,160 --> 00:11:17,680
in your build

00:11:14,880 --> 00:11:19,279
it's a super handy tool and you can also

00:11:17,680 --> 00:11:21,839
use it to tell you if you're

00:11:19,279 --> 00:11:24,000
invoking things with let's say different

00:11:21,839 --> 00:11:25,360
command lines on different platforms or

00:11:24,000 --> 00:11:27,839
something like that

00:11:25,360 --> 00:11:29,920
but most importantly for us we'll be

00:11:27,839 --> 00:11:32,320
able to use it to tell when inputs

00:11:29,920 --> 00:11:33,680
and outputs of actions have different

00:11:32,320 --> 00:11:37,920
contents

00:11:33,680 --> 00:11:40,800
aka when our build is non-deterministic

00:11:37,920 --> 00:11:41,360
so now we're going to build again and

00:11:40,800 --> 00:11:44,240
yes

00:11:41,360 --> 00:11:46,560
we're going to need to clean first and

00:11:44,240 --> 00:11:48,320
we're also going to need to change the

00:11:46,560 --> 00:11:50,720
remote instance name

00:11:48,320 --> 00:11:52,959
so we can tell the cached artifacts from

00:11:50,720 --> 00:11:56,000
our two different builds apart

00:11:52,959 --> 00:11:59,040
so we come back and we now have two

00:11:56,000 --> 00:12:00,320
massive exec log files you did remember

00:11:59,040 --> 00:12:02,560
to save the first one

00:12:00,320 --> 00:12:04,000
right now if you were to go and crack

00:12:02,560 --> 00:12:06,079
them open right now

00:12:04,000 --> 00:12:09,040
you'd find that they're binary files

00:12:06,079 --> 00:12:11,920
they're not the easiest thing to diff

00:12:09,040 --> 00:12:13,279
and here bazel swoops in to save a day

00:12:11,920 --> 00:12:16,720
there is a built-in tool

00:12:13,279 --> 00:12:17,760
to parse these logs you never guessed it

00:12:16,720 --> 00:12:20,880
but it's called the

00:12:17,760 --> 00:12:22,800
exact log parser

00:12:20,880 --> 00:12:24,160
now this is the tool that i use to

00:12:22,800 --> 00:12:26,959
convert that log file

00:12:24,160 --> 00:12:29,120
from a few slides back into text you can

00:12:26,959 --> 00:12:30,320
feed it one of those binary log files

00:12:29,120 --> 00:12:33,360
and it'll spit out

00:12:30,320 --> 00:12:36,160
a plain text conversion for you

00:12:33,360 --> 00:12:36,880
but the parser has one last trick up its

00:12:36,160 --> 00:12:39,920
sleeve

00:12:36,880 --> 00:12:40,720
and we save the best for last if you

00:12:39,920 --> 00:12:45,519
pass in

00:12:40,720 --> 00:12:48,320
not one but two binary exec logs

00:12:45,519 --> 00:12:49,760
the exact log parser will spit out two

00:12:48,320 --> 00:12:52,320
plain text files

00:12:49,760 --> 00:12:54,399
with the actions in the second text file

00:12:52,320 --> 00:12:57,760
reordered so they match up

00:12:54,399 --> 00:12:59,440
with actions in the first file now when

00:12:57,760 --> 00:13:00,079
running this you may need to give the

00:12:59,440 --> 00:13:03,680
jvm

00:13:00,079 --> 00:13:04,000
a ludicrous amount of ram it required

00:13:03,680 --> 00:13:07,519
like

00:13:04,000 --> 00:13:08,720
20 gigs to run in our repo and i had to

00:13:07,519 --> 00:13:10,720
do some googling to

00:13:08,720 --> 00:13:13,360
figure out the mac you know the the

00:13:10,720 --> 00:13:15,200
magic jvm flags to make that work

00:13:13,360 --> 00:13:17,600
um but after it chugged away for a

00:13:15,200 --> 00:13:20,720
little bit we had

00:13:17,600 --> 00:13:23,680
a large plain text file

00:13:20,720 --> 00:13:25,839
we actually had a pair of them and

00:13:23,680 --> 00:13:27,760
because we have a pair of files

00:13:25,839 --> 00:13:29,600
and they're plain text we can diff them

00:13:27,760 --> 00:13:31,839
now we can use the

00:13:29,600 --> 00:13:33,279
plain old diff command to show what's

00:13:31,839 --> 00:13:35,920
happening

00:13:33,279 --> 00:13:36,639
now this is going to work best when most

00:13:35,920 --> 00:13:40,160
actions

00:13:36,639 --> 00:13:42,320
between the two builds are the same

00:13:40,160 --> 00:13:44,959
otherwise the plain text diffs might not

00:13:42,320 --> 00:13:48,399
have enough anchor points to

00:13:44,959 --> 00:13:50,240
not be all jumbled up

00:13:48,399 --> 00:13:52,800
and running the stiff command will

00:13:50,240 --> 00:13:54,880
output a combined log for us

00:13:52,800 --> 00:13:57,600
that'll contain the contents of both

00:13:54,880 --> 00:13:58,399
logs but with a prefix denoting the

00:13:57,600 --> 00:14:00,959
build number

00:13:58,399 --> 00:14:03,760
on lines where there is a difference

00:14:00,959 --> 00:14:06,560
between the two log files

00:14:03,760 --> 00:14:08,560
so this diff is going to be massive

00:14:06,560 --> 00:14:09,279
scrolling through it won't be very

00:14:08,560 --> 00:14:12,560
helpful

00:14:09,279 --> 00:14:16,320
it can be like 10 gigs of text

00:14:12,560 --> 00:14:16,959
so i did what any good lazy programmer

00:14:16,320 --> 00:14:19,519
would do

00:14:16,959 --> 00:14:20,560
and i wrote a script to go through this

00:14:19,519 --> 00:14:24,720
and

00:14:20,560 --> 00:14:28,079
group the actions that had differences

00:14:24,720 --> 00:14:31,199
in them by their mnemonics you know and

00:14:28,079 --> 00:14:35,440
sort of point out which rules

00:14:31,199 --> 00:14:35,440
essentially had issues

00:14:35,600 --> 00:14:42,800
so i threw up on my github account

00:14:39,680 --> 00:14:44,560
v2 of the hacky tool i built to help me

00:14:42,800 --> 00:14:46,639
read through these diffs

00:14:44,560 --> 00:14:48,880
i originally wrote it in ruby and then

00:14:46,639 --> 00:14:50,880
decided it would be fun to stretch my

00:14:48,880 --> 00:14:52,480
rust muscles

00:14:50,880 --> 00:14:54,560
because rust is supposed to make

00:14:52,480 --> 00:14:55,680
everything go faster or something like

00:14:54,560 --> 00:14:59,600
that

00:14:55,680 --> 00:15:02,240
now warning this is not production code

00:14:59,600 --> 00:15:03,600
but hopefully it's a helpful example of

00:15:02,240 --> 00:15:06,880
the ways you might want to dig

00:15:03,600 --> 00:15:09,839
into these diffs yourself and can help

00:15:06,880 --> 00:15:10,240
point out places where you frequently

00:15:09,839 --> 00:15:13,760
have

00:15:10,240 --> 00:15:16,800
actions that are non-deterministic

00:15:13,760 --> 00:15:19,440
or have non-deterministic inputs

00:15:16,800 --> 00:15:20,000
now i say non-deterministic inputs

00:15:19,440 --> 00:15:22,880
because

00:15:20,000 --> 00:15:24,639
it's non-deterministic inputs that can

00:15:22,880 --> 00:15:27,120
really poison your build

00:15:24,639 --> 00:15:29,839
and force you to rerun actions over and

00:15:27,120 --> 00:15:33,040
over and over when using a cache

00:15:29,839 --> 00:15:34,720
yes ultimately it's the outputs that are

00:15:33,040 --> 00:15:37,360
different

00:15:34,720 --> 00:15:38,959
but depending on where that output then

00:15:37,360 --> 00:15:41,519
gets used later on

00:15:38,959 --> 00:15:42,639
in the build will determine how big a

00:15:41,519 --> 00:15:44,399
deal that is

00:15:42,639 --> 00:15:46,720
if an output is different but doesn't

00:15:44,399 --> 00:15:47,839
get propagated to intermediary targets

00:15:46,720 --> 00:15:51,920
as an input

00:15:47,839 --> 00:15:51,920
it won't really poison the build as much

00:15:52,320 --> 00:15:59,360
so we've run the tool we've found

00:15:56,320 --> 00:16:00,399
an action that has differing inputs and

00:15:59,360 --> 00:16:01,920
differing outputs

00:16:00,399 --> 00:16:03,680
and now we want to see where the

00:16:01,920 --> 00:16:05,759
difference is coming from

00:16:03,680 --> 00:16:06,800
so we're going to download the files

00:16:05,759 --> 00:16:09,920
that are used as

00:16:06,800 --> 00:16:11,519
inputs but have different contents this

00:16:09,920 --> 00:16:12,720
is where setting different remote

00:16:11,519 --> 00:16:16,160
instance names can

00:16:12,720 --> 00:16:18,880
be helpful so in our cache we can tell

00:16:16,160 --> 00:16:20,240
which we can tell which build the

00:16:18,880 --> 00:16:25,040
different files have come

00:16:20,240 --> 00:16:28,399
from and now we're going to want to

00:16:25,040 --> 00:16:30,720
diff these different files and this is

00:16:28,399 --> 00:16:33,120
where your domain expertise can come in

00:16:30,720 --> 00:16:34,480
you know the different files that your

00:16:33,120 --> 00:16:37,519
build is producing

00:16:34,480 --> 00:16:40,560
so i'm really familiar with ios builds

00:16:37,519 --> 00:16:43,040
so i'm looking uh with

00:16:40,560 --> 00:16:45,199
tools that i'm already familiar with to

00:16:43,040 --> 00:16:48,160
inspect these files

00:16:45,199 --> 00:16:50,240
so looking at object files i'm running

00:16:48,160 --> 00:16:54,240
the strings command or

00:16:50,240 --> 00:16:57,759
nm or o tool to figure out what their

00:16:54,240 --> 00:17:00,639
semantic contents is and then running

00:16:57,759 --> 00:17:03,040
diff based on this snippet against the

00:17:00,639 --> 00:17:05,120
two of them

00:17:03,040 --> 00:17:06,160
so i could use my knowledge to figure

00:17:05,120 --> 00:17:09,600
out where

00:17:06,160 --> 00:17:12,559
those differences were coming from oh

00:17:09,600 --> 00:17:14,959
cool neat trick sam i'm glad you got

00:17:12,559 --> 00:17:17,760
your build to be deterministic

00:17:14,959 --> 00:17:19,520
but what else is this sort of approach

00:17:17,760 --> 00:17:22,319
useful for

00:17:19,520 --> 00:17:23,760
kind of the sky's the limit you can use

00:17:22,319 --> 00:17:26,799
it to compare

00:17:23,760 --> 00:17:28,960
runs of your build on different machines

00:17:26,799 --> 00:17:32,160
in different environments or with

00:17:28,960 --> 00:17:35,440
different tool chains

00:17:32,160 --> 00:17:38,000
now here are a pair of

00:17:35,440 --> 00:17:39,039
really quick examples of findings that i

00:17:38,000 --> 00:17:42,480
had going through

00:17:39,039 --> 00:17:44,799
our build both of these come from the

00:17:42,480 --> 00:17:46,880
rules apple rule set that are used for

00:17:44,799 --> 00:17:49,360
building ios apps

00:17:46,880 --> 00:17:50,080
but i'm sure there are similar stories

00:17:49,360 --> 00:17:52,799
for

00:17:50,080 --> 00:17:53,360
all sorts of different rule sets the

00:17:52,799 --> 00:17:55,840
first

00:17:53,360 --> 00:17:58,320
was the storyboard link action in the

00:17:55,840 --> 00:18:01,039
resource rules in rules apple

00:17:58,320 --> 00:18:02,880
what this does is it takes nib files

00:18:01,039 --> 00:18:06,240
that have been compiled

00:18:02,880 --> 00:18:09,120
and links them together and

00:18:06,240 --> 00:18:09,919
what we found was every single time this

00:18:09,120 --> 00:18:12,080
showed up

00:18:09,919 --> 00:18:14,559
in the execution log the inputs were

00:18:12,080 --> 00:18:17,280
always different

00:18:14,559 --> 00:18:17,919
and downloading those inputs we could

00:18:17,280 --> 00:18:21,440
see

00:18:17,919 --> 00:18:23,840
that things were jumbled around

00:18:21,440 --> 00:18:26,080
the files looked mostly the same but

00:18:23,840 --> 00:18:29,120
different blocks of the binaries were

00:18:26,080 --> 00:18:30,080
reordered and diving in a bit further we

00:18:29,120 --> 00:18:33,919
could tell

00:18:30,080 --> 00:18:35,200
that this was because it was serializing

00:18:33,919 --> 00:18:37,600
dictionaries

00:18:35,200 --> 00:18:38,880
that had non-deterministic ordering to

00:18:37,600 --> 00:18:42,640
them

00:18:38,880 --> 00:18:44,480
and so because we couldn't go and fix

00:18:42,640 --> 00:18:45,840
the tool that does the storyboard

00:18:44,480 --> 00:18:48,080
linking or the nib

00:18:45,840 --> 00:18:50,080
uh compilation to be deterministic

00:18:48,080 --> 00:18:51,280
because those are in xcode and we don't

00:18:50,080 --> 00:18:53,520
control them

00:18:51,280 --> 00:18:56,080
we sort of threw our hands up and said

00:18:53,520 --> 00:18:58,240
okay there's nothing we can do

00:18:56,080 --> 00:18:59,840
we'll continue to cache these things

00:18:58,240 --> 00:19:03,200
continue to allow them to run

00:18:59,840 --> 00:19:06,000
remotely because these outputs

00:19:03,200 --> 00:19:08,000
aren't used for any other compilation

00:19:06,000 --> 00:19:11,280
they're only used for bundling

00:19:08,000 --> 00:19:13,760
the final application now

00:19:11,280 --> 00:19:15,520
the second example is from the imported

00:19:13,760 --> 00:19:18,080
dynamic framework processor

00:19:15,520 --> 00:19:19,200
action again from rules apple and what

00:19:18,080 --> 00:19:21,360
this does is it

00:19:19,200 --> 00:19:22,240
it takes dynamic frameworks that you're

00:19:21,360 --> 00:19:24,960
importing

00:19:22,240 --> 00:19:25,280
and packages them up into a zip before

00:19:24,960 --> 00:19:29,039
then

00:19:25,280 --> 00:19:32,640
processing it and what we were seeing

00:19:29,039 --> 00:19:34,799
is that those zip files were different

00:19:32,640 --> 00:19:36,799
even though the inputs to them were

00:19:34,799 --> 00:19:39,360
always the same

00:19:36,799 --> 00:19:40,400
so we downloaded the zip files and

00:19:39,360 --> 00:19:43,600
dipped

00:19:40,400 --> 00:19:47,200
uh the output of running unzip dash v

00:19:43,600 --> 00:19:50,480
on them and what that

00:19:47,200 --> 00:19:51,120
showed was that the timestamps in the

00:19:50,480 --> 00:19:54,400
zip

00:19:51,120 --> 00:19:57,120
were different for directory entries

00:19:54,400 --> 00:19:58,559
but they were the same for file entries

00:19:57,120 --> 00:20:01,679
now the good news was

00:19:58,559 --> 00:20:04,000
we could go and fix this and

00:20:01,679 --> 00:20:04,880
indeed i sent a pull request into rules

00:20:04,000 --> 00:20:07,919
apple

00:20:04,880 --> 00:20:09,120
to set a consistent time stamp not only

00:20:07,919 --> 00:20:11,919
for file entries

00:20:09,120 --> 00:20:14,000
but also for directory entries before

00:20:11,919 --> 00:20:16,720
creating the zip

00:20:14,000 --> 00:20:17,880
i'm sorry that i couldn't come and give

00:20:16,720 --> 00:20:21,120
you a magic

00:20:17,880 --> 00:20:21,760
experimental basal flag that would go

00:20:21,120 --> 00:20:24,880
and

00:20:21,760 --> 00:20:27,440
make all your builds deterministic but

00:20:24,880 --> 00:20:30,400
hopefully i've helped motivate a bit why

00:20:27,440 --> 00:20:33,039
deterministic builds matter

00:20:30,400 --> 00:20:33,840
and shown a bit of the ways that you can

00:20:33,039 --> 00:20:36,559
figure out

00:20:33,840 --> 00:20:36,880
where your build is non-deterministic

00:20:36,559 --> 00:20:40,960
and

00:20:36,880 --> 00:20:44,720
really dive in so you can go and fix it

00:20:40,960 --> 00:20:46,960
and hopefully moving forward the common

00:20:44,720 --> 00:20:48,320
tool chains that we all rely on for

00:20:46,960 --> 00:20:51,679
builds will

00:20:48,320 --> 00:20:54,960
default to being deterministic

00:20:51,679 --> 00:20:58,000
by default without us having to set

00:20:54,960 --> 00:21:00,640
special flags or environment variables

00:20:58,000 --> 00:21:03,200
or do post-processing to make them be

00:21:00,640 --> 00:21:06,320
that way

00:21:03,200 --> 00:21:10,000
but until then you know

00:21:06,320 --> 00:21:13,360
we we know what work we have to do so

00:21:10,000 --> 00:21:28,559
i hope you've enjoyed this talk

00:21:13,360 --> 00:21:28,559

YouTube URL: https://www.youtube.com/watch?v=XItY0LmdiFA


