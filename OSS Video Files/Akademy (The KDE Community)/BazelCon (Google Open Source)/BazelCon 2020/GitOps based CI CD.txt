Title: GitOps based CI CD
Publication date: 2021-01-25
Playlist: BazelCon 2020
Description: 
	For the last few years the Adobe Ad Cloud team was on a journey to achieve continuous deployment for hundreds of services and data pipelines. In this presentation we explain how the Bazel build reproducibility and scalability properties were crucial for implementing 100% GitOps based CI/CD workflow.

Resources:
GitHub → http://goo.gle/39U9dnu
Build with Bazel → http://goo.gle/2NuVRXm

Speaker: Justin Sung

Watch more:
BazelCon post event sessions → http://goo.gle/2YfIvAx
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Justin Sung;
Captions: 
	00:00:01,040 --> 00:00:07,120
[Music]

00:00:06,080 --> 00:00:09,440
hello

00:00:07,120 --> 00:00:11,759
my name is justin sung i'm a team lead

00:00:09,440 --> 00:00:13,920
at adobe's ad cloud engineering division

00:00:11,759 --> 00:00:17,279
and i'm here today to tell you about our

00:00:13,920 --> 00:00:18,800
journey implementing ci cd with bazel

00:00:17,279 --> 00:00:20,720
like most engineering organizations

00:00:18,800 --> 00:00:22,480
adobe ad cloud reached a position where

00:00:20,720 --> 00:00:24,800
it needed to meet ever-growing demand

00:00:22,480 --> 00:00:26,160
of rapid business value delivery the

00:00:24,800 --> 00:00:26,880
organization wanted more frequent

00:00:26,160 --> 00:00:28,640
releases

00:00:26,880 --> 00:00:30,560
faster turnaround times for features and

00:00:28,640 --> 00:00:33,520
patches and ultimately

00:00:30,560 --> 00:00:34,320
faster delivery of value to end users

00:00:33,520 --> 00:00:36,399
however

00:00:34,320 --> 00:00:38,320
common frustrations such as long build

00:00:36,399 --> 00:00:40,399
times and unreliable tests

00:00:38,320 --> 00:00:42,480
individually seemed manageable but in

00:00:40,399 --> 00:00:44,239
aggregate impeded progress

00:00:42,480 --> 00:00:45,920
no resolution targeted at specific

00:00:44,239 --> 00:00:47,120
frustrations granted meaningful

00:00:45,920 --> 00:00:49,600
improvements

00:00:47,120 --> 00:00:51,120
hence the approach shifted toward

00:00:49,600 --> 00:00:53,600
identifying fundamental

00:00:51,120 --> 00:00:55,600
underlying issues made manifest in

00:00:53,600 --> 00:00:57,840
aforementioned frustrations

00:00:55,600 --> 00:00:59,280
ultimately it decided to adopt and

00:00:57,840 --> 00:01:00,000
implement a well-known engineering

00:00:59,280 --> 00:01:03,440
paradigm

00:01:00,000 --> 00:01:04,080
ci cd prior to ci cd each of our many

00:01:03,440 --> 00:01:06,320
services

00:01:04,080 --> 00:01:07,840
on which our developers worked on had

00:01:06,320 --> 00:01:09,600
its own repository

00:01:07,840 --> 00:01:11,520
maven build and deploy pipelines and

00:01:09,600 --> 00:01:13,040
dependency tree

00:01:11,520 --> 00:01:15,200
code consolidation reduced build

00:01:13,040 --> 00:01:15,840
fragmentation build times increased

00:01:15,200 --> 00:01:17,840
however

00:01:15,840 --> 00:01:19,439
because our build system maven did not

00:01:17,840 --> 00:01:20,720
have incremental builds these builds

00:01:19,439 --> 00:01:23,200
could take hours

00:01:20,720 --> 00:01:24,799
deployed ply friend fragmentation led to

00:01:23,200 --> 00:01:26,000
complex environment deployments

00:01:24,799 --> 00:01:28,880
requiring extensive

00:01:26,000 --> 00:01:30,400
human coordination such circumstances

00:01:28,880 --> 00:01:32,240
made automated end-to-end tests

00:01:30,400 --> 00:01:33,920
prohibitedly expensive to write

00:01:32,240 --> 00:01:36,079
they also made releases complicated

00:01:33,920 --> 00:01:37,040
rituals with large checklists and many

00:01:36,079 --> 00:01:39,200
participants

00:01:37,040 --> 00:01:40,720
these releases replete with human error

00:01:39,200 --> 00:01:43,920
became time-consuming

00:01:40,720 --> 00:01:45,680
and infrequent rituals instead ad cloud

00:01:43,920 --> 00:01:48,079
wanted a simple development process

00:01:45,680 --> 00:01:49,520
developers push prs triggering builds

00:01:48,079 --> 00:01:50,640
and validation with both unit

00:01:49,520 --> 00:01:52,640
integration tests

00:01:50,640 --> 00:01:54,159
pr merges with approval create git ops

00:01:52,640 --> 00:01:56,000
generated deploy prs

00:01:54,159 --> 00:01:58,399
each pr corresponds to environment

00:01:56,000 --> 00:02:00,640
production staging etc

00:01:58,399 --> 00:02:02,320
and contains a kubernetes manifest of

00:02:00,640 --> 00:02:04,240
change services to deploy

00:02:02,320 --> 00:02:06,320
merging and deploy pr promotes changes

00:02:04,240 --> 00:02:07,680
to the targeted environment

00:02:06,320 --> 00:02:09,440
this minimal amount of human

00:02:07,680 --> 00:02:10,800
coordination and hence increase in

00:02:09,440 --> 00:02:12,720
developer efficiency

00:02:10,800 --> 00:02:15,120
became one of the driving motivations

00:02:12,720 --> 00:02:17,360
for our bazel-based ci pipeline

00:02:15,120 --> 00:02:19,040
we also wanted the pipeline to execute

00:02:17,360 --> 00:02:20,879
quickly with fast build

00:02:19,040 --> 00:02:22,160
automated tests and simple dependency

00:02:20,879 --> 00:02:24,560
management

00:02:22,160 --> 00:02:25,840
lastly we wanted frictionless rollouts

00:02:24,560 --> 00:02:28,239
using declarative deployments to

00:02:25,840 --> 00:02:29,760
kubernetes would provide traceability

00:02:28,239 --> 00:02:31,280
the implementation of this process

00:02:29,760 --> 00:02:32,239
starts with a relatively straightforward

00:02:31,280 --> 00:02:34,720
build process

00:02:32,239 --> 00:02:36,319
literally basal build and bazel test

00:02:34,720 --> 00:02:37,599
bazel here gives us two notable

00:02:36,319 --> 00:02:39,680
advantages

00:02:37,599 --> 00:02:41,599
firstly incremental builds and tests

00:02:39,680 --> 00:02:44,000
keep execution time low

00:02:41,599 --> 00:02:45,840
secondly bazel's reproducible builds

00:02:44,000 --> 00:02:48,560
generate content addressable images

00:02:45,840 --> 00:02:51,280
for example sha 256 image names which

00:02:48,560 --> 00:02:53,440
end up in our kubernetes manifests

00:02:51,280 --> 00:02:54,800
with the images the pipeline can proceed

00:02:53,440 --> 00:02:57,040
to set up git ops deployments

00:02:54,800 --> 00:02:58,640
using customize to create manifests it

00:02:57,040 --> 00:03:00,640
will also create deploy pr's

00:02:58,640 --> 00:03:02,239
render manifest into the code repository

00:03:00,640 --> 00:03:04,720
and push images

00:03:02,239 --> 00:03:06,400
lastly when a deployed pr merges a

00:03:04,720 --> 00:03:08,560
watcher pulls the code repository and

00:03:06,400 --> 00:03:10,720
renders those manifests

00:03:08,560 --> 00:03:12,560
now the implementation first starts with

00:03:10,720 --> 00:03:13,519
binaries which then become container

00:03:12,560 --> 00:03:16,480
images

00:03:13,519 --> 00:03:18,800
customized then creates manifests next a

00:03:16,480 --> 00:03:20,959
custom bazel rule called rules get ops

00:03:18,800 --> 00:03:22,959
creates deploy prs renders manifest into

00:03:20,959 --> 00:03:24,000
the code repository then pushes those

00:03:22,959 --> 00:03:26,080
images

00:03:24,000 --> 00:03:27,920
notably because the image hashes only

00:03:26,080 --> 00:03:29,760
change with content changes

00:03:27,920 --> 00:03:31,440
the pr will only have updates to

00:03:29,760 --> 00:03:34,159
modified images

00:03:31,440 --> 00:03:36,080
also because the code repository stores

00:03:34,159 --> 00:03:38,640
render manifest by namespace

00:03:36,080 --> 00:03:41,599
one single pipeline suffices and this

00:03:38,640 --> 00:03:43,120
custom rule has since been open sourced

00:03:41,599 --> 00:03:45,519
to illustrate the practical usage of

00:03:43,120 --> 00:03:47,280
this let us first consider two teams

00:03:45,519 --> 00:03:48,879
they both have some number of services

00:03:47,280 --> 00:03:50,480
deployed simultaneously to some

00:03:48,879 --> 00:03:53,040
namespace

00:03:50,480 --> 00:03:54,000
team one first introduces a change to

00:03:53,040 --> 00:03:56,000
service two

00:03:54,000 --> 00:03:57,439
this in turn updates service twos get

00:03:56,000 --> 00:03:59,200
ops targets and deploy

00:03:57,439 --> 00:04:01,360
creates deploy prs for configured

00:03:59,200 --> 00:04:03,280
environments team one

00:04:01,360 --> 00:04:04,400
decides to deploy to dev by merging the

00:04:03,280 --> 00:04:07,360
dev deploy pr

00:04:04,400 --> 00:04:09,200
the other deployed prs remain open now

00:04:07,360 --> 00:04:11,120
team one updates service one

00:04:09,200 --> 00:04:13,439
service one now has updated get ops

00:04:11,120 --> 00:04:15,599
targets service two remains unchanged

00:04:13,439 --> 00:04:17,280
a new dev deployed pr is now open and

00:04:15,599 --> 00:04:19,120
the other deployed prs receive new

00:04:17,280 --> 00:04:20,079
commits with service 1 to manifest

00:04:19,120 --> 00:04:22,240
changes

00:04:20,079 --> 00:04:24,160
team 1 deploys both dev and stage by

00:04:22,240 --> 00:04:27,199
merging those respective pr's

00:04:24,160 --> 00:04:29,040
the prod deploy pr remains open now team

00:04:27,199 --> 00:04:31,360
two which has been quite so far

00:04:29,040 --> 00:04:33,199
updates service four servers four gets

00:04:31,360 --> 00:04:35,199
get off's targets and team two seats

00:04:33,199 --> 00:04:36,880
deploy prs for its environments

00:04:35,199 --> 00:04:39,280
since team one and team two have their

00:04:36,880 --> 00:04:40,960
own name spaces their deploy prs do not

00:04:39,280 --> 00:04:42,960
overlap

00:04:40,960 --> 00:04:44,639
the developer's interaction model with

00:04:42,960 --> 00:04:46,560
the pipeline represents a radical

00:04:44,639 --> 00:04:47,440
departure from orthodox build and deploy

00:04:46,560 --> 00:04:49,759
pipelines

00:04:47,440 --> 00:04:51,680
classically each deployable has its own

00:04:49,759 --> 00:04:54,000
build test and deploy pipeline

00:04:51,680 --> 00:04:55,440
and promoting changes into environment

00:04:54,000 --> 00:04:57,120
requires coordinating multiple

00:04:55,440 --> 00:04:58,880
deployables pipelines

00:04:57,120 --> 00:05:00,560
our model obviates all of that and

00:04:58,880 --> 00:05:02,960
instead presents a single

00:05:00,560 --> 00:05:03,759
simple question to the developer which

00:05:02,960 --> 00:05:05,680
namespace

00:05:03,759 --> 00:05:08,080
should receive the latest update

00:05:05,680 --> 00:05:10,320
everything else is already handled

00:05:08,080 --> 00:05:12,960
and rollout of this cicd process

00:05:10,320 --> 00:05:14,800
provided useful lessons for the future

00:05:12,960 --> 00:05:16,400
firstly while we expected quality of

00:05:14,800 --> 00:05:18,800
life improvements they proved

00:05:16,400 --> 00:05:19,520
far greater than anticipated stories of

00:05:18,800 --> 00:05:21,280
teams

00:05:19,520 --> 00:05:23,360
eagerly ditching their two-hour builds

00:05:21,280 --> 00:05:25,600
regaled our ears

00:05:23,360 --> 00:05:26,639
additionally rollout demonstrated the

00:05:25,600 --> 00:05:28,240
need for constant

00:05:26,639 --> 00:05:30,000
and active communication to help

00:05:28,240 --> 00:05:30,960
developers understand this new build and

00:05:30,000 --> 00:05:33,120
deploy model

00:05:30,960 --> 00:05:35,039
while they understood ci cd many had

00:05:33,120 --> 00:05:36,080
grown accustomed to pipelines with high

00:05:35,039 --> 00:05:39,280
user interactions

00:05:36,080 --> 00:05:41,039
and thus needed hands-on onboarding

00:05:39,280 --> 00:05:42,800
now fully implemented and rolled out to

00:05:41,039 --> 00:05:44,800
and cloud's 200 engineers

00:05:42,800 --> 00:05:46,320
the ci cd pipeline allows developers to

00:05:44,800 --> 00:05:48,639
push their changes to environments

00:05:46,320 --> 00:05:50,400
quickly with minimal intervention

00:05:48,639 --> 00:05:51,120
post-pr merge the pipeline handles

00:05:50,400 --> 00:05:53,360
builds

00:05:51,120 --> 00:05:54,560
runs about 2 000 tests registers

00:05:53,360 --> 00:05:56,479
artifacts and

00:05:54,560 --> 00:05:58,319
handles deployment marshalling the

00:05:56,479 --> 00:05:58,880
developer interacts with the system only

00:05:58,319 --> 00:06:00,960
once

00:05:58,880 --> 00:06:02,160
to identify and merge the deployed pr

00:06:00,960 --> 00:06:04,960
corresponding to the

00:06:02,160 --> 00:06:05,440
desired environment this entire process

00:06:04,960 --> 00:06:08,080
takes

00:06:05,440 --> 00:06:09,360
roughly 10 minutes and at most 30

00:06:08,080 --> 00:06:11,199
minutes

00:06:09,360 --> 00:06:13,120
thank you very much for listening if you

00:06:11,199 --> 00:06:13,919
too are looking at implementing ci cd

00:06:13,120 --> 00:06:16,000
with bazel

00:06:13,919 --> 00:06:17,280
using git ops deployments feel free to

00:06:16,000 --> 00:06:20,350
check out our open source

00:06:17,280 --> 00:06:26,310
project called rules get ops

00:06:20,350 --> 00:06:26,310

YouTube URL: https://www.youtube.com/watch?v=HBijqfAJICw


