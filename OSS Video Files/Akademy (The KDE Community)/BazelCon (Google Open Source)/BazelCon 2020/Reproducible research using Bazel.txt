Title: Reproducible research using Bazel
Publication date: 2020-11-13
Playlist: BazelCon 2020
Description: 
	Reproducibility of research can be an overwhelming challenge for research labs of any discipline dealing with the complexity of modern software. Uber Elevate's research arm ATCP has been working on a reproducible Research Platform based on Bazel allowing us to confidently explore new research ideas - while mitigating technical debt, incrementally and sustainably build upon previous work, create scalable experimental designs and build reproducible research artifacts. 
Our team shares this methodology at the intersection of modern software and research engineering, our recent contributions to the Bazel ecosystem as well as lessons learnt as we battled through difficulties along the way. We also share our vision as we plan out the next steps: share our work to everybody interested and keep extending our use of Bazel as a generic build tool beyond software artifacts.

Resources:
Research on Reproducibility crisis: https://goo.gle/3ll1u6p
Introducing Maneage: https://goo.gle/32tNQGU
Artificial intelligence faces reproducibility crisis: https://goo.gle/35hGjN1

Speakers: Sebastien Mamessier & Romain Pennec

Watch more:
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Sebastien Mamessier, Romain Pennec;
Captions: 
	00:00:01,040 --> 00:00:07,680
[Music]

00:00:05,600 --> 00:00:10,160
hello basil khan i'm sebastian i'm an

00:00:07,680 --> 00:00:12,719
autonomy engineer at uber elevate

00:00:10,160 --> 00:00:13,759
in the advanced technology center and

00:00:12,719 --> 00:00:16,400
today we're going to talk about

00:00:13,759 --> 00:00:18,640
reproducible research with bazel

00:00:16,400 --> 00:00:20,320
this is the result of a little bit more

00:00:18,640 --> 00:00:21,680
than a year of work together with my

00:00:20,320 --> 00:00:23,359
colleague goldman pinek

00:00:21,680 --> 00:00:25,279
and i'm very excited to show you what

00:00:23,359 --> 00:00:28,160
we've come up with today

00:00:25,279 --> 00:00:30,640
so first we'll introduce uh really

00:00:28,160 --> 00:00:33,200
quickly what reproducible

00:00:30,640 --> 00:00:34,320
research is about and how bazel can help

00:00:33,200 --> 00:00:36,880
with that

00:00:34,320 --> 00:00:38,640
then we'll show you the capabilities

00:00:36,880 --> 00:00:39,920
that we've packed into our research

00:00:38,640 --> 00:00:42,960
platform

00:00:39,920 --> 00:00:45,360
before we go on

00:00:42,960 --> 00:00:47,280
to talk about some of the pain points we

00:00:45,360 --> 00:00:48,559
encountered along the way and how we

00:00:47,280 --> 00:00:50,879
solve them

00:00:48,559 --> 00:00:53,120
finally i'll quickly talk about the

00:00:50,879 --> 00:00:56,079
future work that we're planning for

00:00:53,120 --> 00:00:58,559
for the foreseeable future so what are

00:00:56,079 --> 00:01:01,680
the challenges of reproducible research

00:00:58,559 --> 00:01:04,000
and how can we use bazel to help

00:01:01,680 --> 00:01:04,960
so replaceability in research as being

00:01:04,000 --> 00:01:07,439
an historical

00:01:04,960 --> 00:01:08,320
challenge especially in life sciences

00:01:07,439 --> 00:01:11,680
such as

00:01:08,320 --> 00:01:13,760
psychology and biology you can imagine

00:01:11,680 --> 00:01:14,720
how hard it is to reproduce those

00:01:13,760 --> 00:01:17,280
experiments that

00:01:14,720 --> 00:01:18,000
involve human subjects well it turned

00:01:17,280 --> 00:01:20,799
out that

00:01:18,000 --> 00:01:22,640
software-driven research is also hard to

00:01:20,799 --> 00:01:23,360
reproduce and we're actually in the

00:01:22,640 --> 00:01:25,439
middle

00:01:23,360 --> 00:01:28,000
of what some people call the

00:01:25,439 --> 00:01:32,159
reproducibility crisis

00:01:28,000 --> 00:01:35,200
so this research platform

00:01:32,159 --> 00:01:39,119
is trying to help with solving

00:01:35,200 --> 00:01:41,360
this new crises in reproducibility

00:01:39,119 --> 00:01:42,720
that involves more and more complex

00:01:41,360 --> 00:01:46,560
software

00:01:42,720 --> 00:01:48,720
so how can we use bezel to help as

00:01:46,560 --> 00:01:49,920
many of us know bezel is a great tool to

00:01:48,720 --> 00:01:52,240
build software

00:01:49,920 --> 00:01:53,439
well it turns out it can build more than

00:01:52,240 --> 00:01:55,200
just software it

00:01:53,439 --> 00:01:56,560
can build pretty much anything that you

00:01:55,200 --> 00:01:59,439
can represent

00:01:56,560 --> 00:02:01,200
as a directed acyclical graph and when

00:01:59,439 --> 00:02:04,399
you look at a research pipeline

00:02:01,200 --> 00:02:07,840
it's actually very a very good

00:02:04,399 --> 00:02:09,599
example of such a directed at the

00:02:07,840 --> 00:02:10,560
clinical graph so on the right hand side

00:02:09,599 --> 00:02:13,680
of this slide

00:02:10,560 --> 00:02:15,040
you'll see that the research pipeline

00:02:13,680 --> 00:02:17,920
usually starts with

00:02:15,040 --> 00:02:19,760
some data you write some research code

00:02:17,920 --> 00:02:23,280
you use someone else's

00:02:19,760 --> 00:02:23,840
previous research combine the resulting

00:02:23,280 --> 00:02:26,560
models

00:02:23,840 --> 00:02:28,400
you have to depend on some configuration

00:02:26,560 --> 00:02:30,000
parameters and in the end

00:02:28,400 --> 00:02:32,000
depending on the research you end up

00:02:30,000 --> 00:02:34,160
with the simulation

00:02:32,000 --> 00:02:35,200
and finally you get your research

00:02:34,160 --> 00:02:38,480
results

00:02:35,200 --> 00:02:42,000
and the end product is a research paper

00:02:38,480 --> 00:02:43,840
so keeping that in mind

00:02:42,000 --> 00:02:45,440
you may think that we can just tell

00:02:43,840 --> 00:02:46,000
researchers okay now we're going to use

00:02:45,440 --> 00:02:48,000
bazel

00:02:46,000 --> 00:02:50,319
and everything will be reproducible well

00:02:48,000 --> 00:02:52,879
it's a bit harder than that and there is

00:02:50,319 --> 00:02:56,400
a lot to do to bridge the gap between

00:02:52,879 --> 00:02:57,920
bazel and our researchers audience

00:02:56,400 --> 00:03:00,480
and that's what this research platform

00:02:57,920 --> 00:03:02,840
is about so let me talk to you about the

00:03:00,480 --> 00:03:04,239
capabilities of uber ivs research

00:03:02,840 --> 00:03:06,080
platform

00:03:04,239 --> 00:03:07,920
so when i first started to think about

00:03:06,080 --> 00:03:10,319
this a year ago

00:03:07,920 --> 00:03:11,519
i tried to identify the specific

00:03:10,319 --> 00:03:14,480
constraints of

00:03:11,519 --> 00:03:14,879
research engineering and the first one

00:03:14,480 --> 00:03:17,360
that

00:03:14,879 --> 00:03:18,080
was fairly obvious is that when you

00:03:17,360 --> 00:03:20,640
write research

00:03:18,080 --> 00:03:22,959
code you're constantly interacting with

00:03:20,640 --> 00:03:26,159
an unstable code base

00:03:22,959 --> 00:03:28,720
you need to be able to

00:03:26,159 --> 00:03:29,360
pick an external repo and build upon it

00:03:28,720 --> 00:03:32,239
you build

00:03:29,360 --> 00:03:34,640
you need to be able to accommodate some

00:03:32,239 --> 00:03:39,040
requests for new tools new libraries

00:03:34,640 --> 00:03:41,200
on an almost daily basis so

00:03:39,040 --> 00:03:42,720
this is a bit different from the

00:03:41,200 --> 00:03:45,120
traditional software engineering where

00:03:42,720 --> 00:03:48,799
things are usually a bit more stable

00:03:45,120 --> 00:03:51,440
the other thing is that you are

00:03:48,799 --> 00:03:53,360
interacting with people that are not

00:03:51,440 --> 00:03:55,519
software engineers so

00:03:53,360 --> 00:03:58,000
like researchers intern that are writing

00:03:55,519 --> 00:03:59,439
code that will be part of your code base

00:03:58,000 --> 00:04:01,599
but they're not software engineers so

00:03:59,439 --> 00:04:04,319
you need to interact

00:04:01,599 --> 00:04:06,159
with them in a different way uh the

00:04:04,319 --> 00:04:09,439
second point i'd like to make

00:04:06,159 --> 00:04:11,120
is that the research workflow itself

00:04:09,439 --> 00:04:13,439
is very different so you need to be able

00:04:11,120 --> 00:04:17,040
to accommodate

00:04:13,439 --> 00:04:19,680
a lot of introspection capabilities

00:04:17,040 --> 00:04:20,959
the the the ability to extract things

00:04:19,680 --> 00:04:23,280
out of the sandbox

00:04:20,959 --> 00:04:24,080
in in a way that you wouldn't need with

00:04:23,280 --> 00:04:28,000
a traditional

00:04:24,080 --> 00:04:30,240
software engineering setup uh finally

00:04:28,000 --> 00:04:32,880
when it comes to data science workflows

00:04:30,240 --> 00:04:36,080
and machine learning you need to be

00:04:32,880 --> 00:04:37,600
providing interactive interfaces and

00:04:36,080 --> 00:04:39,440
development environments that data

00:04:37,600 --> 00:04:42,560
scientists are used to working with such

00:04:39,440 --> 00:04:45,280
as jupiter notebooks and the

00:04:42,560 --> 00:04:46,560
the last thing that is in my opinion

00:04:45,280 --> 00:04:49,600
very important is

00:04:46,560 --> 00:04:50,240
how do you actually sell this new way of

00:04:49,600 --> 00:04:53,440
working

00:04:50,240 --> 00:04:56,080
how do you make people out of bazel

00:04:53,440 --> 00:04:56,639
and the basal graph it's not only going

00:04:56,080 --> 00:04:59,040
to be

00:04:56,639 --> 00:04:59,840
about reproducibility you need to add

00:04:59,040 --> 00:05:04,160
additional

00:04:59,840 --> 00:05:07,520
benefits and one of them is

00:05:04,160 --> 00:05:09,280
the ability to scale their experiments

00:05:07,520 --> 00:05:11,440
to the cloud and we'll talk a little bit

00:05:09,280 --> 00:05:14,800
more about it in the next couple slides

00:05:11,440 --> 00:05:17,360
the right the key element to tackle this

00:05:14,800 --> 00:05:19,520
problem and address these constraints

00:05:17,360 --> 00:05:23,680
was to find the right dose

00:05:19,520 --> 00:05:24,320
of pragmatism pragmatism and aromaticity

00:05:23,680 --> 00:05:27,520
and

00:05:24,320 --> 00:05:30,560
we achieved that using docker

00:05:27,520 --> 00:05:34,240
for the pragmatic side of things

00:05:30,560 --> 00:05:34,880
so anytime we need to react quickly we

00:05:34,240 --> 00:05:38,240
use

00:05:34,880 --> 00:05:41,039
docker to track dependencies and when

00:05:38,240 --> 00:05:41,680
we're shooting for more reproducibility

00:05:41,039 --> 00:05:44,479
and

00:05:41,680 --> 00:05:46,320
mitigating more technical debt then

00:05:44,479 --> 00:05:47,120
we'll pick the way of aromaticity and

00:05:46,320 --> 00:05:49,680
that's where

00:05:47,120 --> 00:05:50,400
we try to track everything using bazel

00:05:49,680 --> 00:05:52,560
so

00:05:50,400 --> 00:05:53,440
by using both docker and bazel in the

00:05:52,560 --> 00:05:55,520
smart way

00:05:53,440 --> 00:05:58,000
that's how we can address the constraint

00:05:55,520 --> 00:05:59,759
the constraint that i just mentioned

00:05:58,000 --> 00:06:01,199
so what are the issues of being

00:05:59,759 --> 00:06:04,240
pragmatic

00:06:01,199 --> 00:06:05,440
it it comes with slight compatibility

00:06:04,240 --> 00:06:07,199
issues

00:06:05,440 --> 00:06:08,960
when you declare dependencies in the

00:06:07,199 --> 00:06:10,800
docker file and that's because when

00:06:08,960 --> 00:06:12,000
you're going to package an application

00:06:10,800 --> 00:06:15,039
using bazel

00:06:12,000 --> 00:06:17,400
it won't be aware of those dependencies

00:06:15,039 --> 00:06:19,600
so there is a slight risk of reduced

00:06:17,400 --> 00:06:21,600
reproducibility

00:06:19,600 --> 00:06:22,639
but we have strategies to mitigate this

00:06:21,600 --> 00:06:25,360
we'll talk about it

00:06:22,639 --> 00:06:26,880
a little bit later in the presentation

00:06:25,360 --> 00:06:30,080
in terms of advantages

00:06:26,880 --> 00:06:32,880
uh this setup allows us to address most

00:06:30,080 --> 00:06:35,039
of our research engineering constraints

00:06:32,880 --> 00:06:36,400
on top of that it adds a layer of

00:06:35,039 --> 00:06:38,000
control

00:06:36,400 --> 00:06:42,080
to make the research platform more

00:06:38,000 --> 00:06:43,919
portable across operating systems

00:06:42,080 --> 00:06:46,080
so now let's look in the guts of the

00:06:43,919 --> 00:06:49,280
research platform

00:06:46,080 --> 00:06:51,120
so we we start with uh interacting with

00:06:49,280 --> 00:06:53,280
the research platform using make and we

00:06:51,120 --> 00:06:56,639
don't use mac to build software but just

00:06:53,280 --> 00:06:59,759
as a convenient way of interacting

00:06:56,639 --> 00:07:02,160
with our docker machinery

00:06:59,759 --> 00:07:04,319
once you've built and logged into the

00:07:02,160 --> 00:07:07,039
research environment you can use bazel

00:07:04,319 --> 00:07:08,160
and here we integrated most of the

00:07:07,039 --> 00:07:10,960
useful

00:07:08,160 --> 00:07:12,000
language rules that allow you to build

00:07:10,960 --> 00:07:14,960
research software

00:07:12,000 --> 00:07:17,039
in pretty much any language we make

00:07:14,960 --> 00:07:18,960
heavy use of the docker rules and the

00:07:17,039 --> 00:07:21,039
kubernetes rules as well

00:07:18,960 --> 00:07:23,360
in orange you can see those are some

00:07:21,039 --> 00:07:26,880
homemade rule sets that we developed to

00:07:23,360 --> 00:07:29,120
address some specific research use cases

00:07:26,880 --> 00:07:31,120
finally we integrate all those rules

00:07:29,120 --> 00:07:34,400
inside of a workspace

00:07:31,120 --> 00:07:35,039
and we already have several research

00:07:34,400 --> 00:07:38,080
projects

00:07:35,039 --> 00:07:38,800
that are working on top of this research

00:07:38,080 --> 00:07:41,680
platform

00:07:38,800 --> 00:07:43,120
and one of the biggest advantages of

00:07:41,680 --> 00:07:44,400
this setup is that it allows our

00:07:43,120 --> 00:07:47,520
researchers to

00:07:44,400 --> 00:07:49,120
directly scale their experimentation on

00:07:47,520 --> 00:07:51,919
the google cloud platform

00:07:49,120 --> 00:07:53,520
using bazel so how do you use the

00:07:51,919 --> 00:07:55,440
research platform

00:07:53,520 --> 00:07:57,680
first you need to clone it so as soon as

00:07:55,440 --> 00:07:59,680
you've got the git repo of the research

00:07:57,680 --> 00:08:02,319
platform clone on your dev machine

00:07:59,680 --> 00:08:04,240
you can start using make project so mac

00:08:02,319 --> 00:08:06,160
project will prompt you for a title for

00:08:04,240 --> 00:08:07,520
your research project and then it will

00:08:06,160 --> 00:08:10,400
create for you

00:08:07,520 --> 00:08:12,960
all the boilerplate you need to start

00:08:10,400 --> 00:08:14,960
writing research code so that means

00:08:12,960 --> 00:08:16,479
ready to use git repo with all the

00:08:14,960 --> 00:08:19,840
docker file and the

00:08:16,479 --> 00:08:22,720
boilerplate workspace to get ready

00:08:19,840 --> 00:08:24,960
as soon as you have that you use mac run

00:08:22,720 --> 00:08:28,639
and it will build the development image

00:08:24,960 --> 00:08:31,520
and gets you inside of a base already

00:08:28,639 --> 00:08:32,080
research container so now you can use

00:08:31,520 --> 00:08:34,800
bazel

00:08:32,080 --> 00:08:36,159
bazel build and bazel run to build your

00:08:34,800 --> 00:08:38,240
research software

00:08:36,159 --> 00:08:40,240
machine learning model and to interact

00:08:38,240 --> 00:08:43,120
with gcp

00:08:40,240 --> 00:08:43,680
the dependencies you need to run it are

00:08:43,120 --> 00:08:45,920
fairly

00:08:43,680 --> 00:08:46,880
straightforward you need git mac and

00:08:45,920 --> 00:08:50,240
docker

00:08:46,880 --> 00:08:51,519
and this runs on linux and mac os

00:08:50,240 --> 00:08:53,120
all right so now i'm going to talk to

00:08:51,519 --> 00:08:53,600
you a little bit about the pain points

00:08:53,120 --> 00:08:56,000
that we

00:08:53,600 --> 00:08:56,959
encountered along the way and what are

00:08:56,000 --> 00:08:59,760
the solutions

00:08:56,959 --> 00:09:01,360
that we put together to work around them

00:08:59,760 --> 00:09:03,519
and the first use case

00:09:01,360 --> 00:09:05,600
i'd like to mention is machine learning

00:09:03,519 --> 00:09:09,040
and how do we represent

00:09:05,600 --> 00:09:12,240
machine learning models as a bazel graph

00:09:09,040 --> 00:09:13,360
so as you can see here a model that has

00:09:12,240 --> 00:09:15,680
been trained

00:09:13,360 --> 00:09:16,959
has three different types of

00:09:15,680 --> 00:09:19,519
dependencies

00:09:16,959 --> 00:09:21,200
the first one is the data the data set

00:09:19,519 --> 00:09:22,160
the second one is the training code

00:09:21,200 --> 00:09:24,959
which is

00:09:22,160 --> 00:09:26,720
in our case usually python code and then

00:09:24,959 --> 00:09:28,800
you have a training configuration that

00:09:26,720 --> 00:09:30,640
you can represent as a yaml file for

00:09:28,800 --> 00:09:32,800
example

00:09:30,640 --> 00:09:34,959
the nice thing of representing this as a

00:09:32,800 --> 00:09:38,080
bazel target

00:09:34,959 --> 00:09:40,800
is that you can then reuse

00:09:38,080 --> 00:09:41,839
this bazel target as an input to a

00:09:40,800 --> 00:09:44,320
downstream

00:09:41,839 --> 00:09:45,440
uh research experiment so in our case we

00:09:44,320 --> 00:09:47,200
may want to use

00:09:45,440 --> 00:09:48,560
this trained model in an aircraft

00:09:47,200 --> 00:09:51,920
simulation

00:09:48,560 --> 00:09:54,720
to then build

00:09:51,920 --> 00:09:57,040
downstream research results and you can

00:09:54,720 --> 00:09:58,480
easily do this using a general for

00:09:57,040 --> 00:10:00,640
example

00:09:58,480 --> 00:10:03,440
we also have to be careful about those

00:10:00,640 --> 00:10:06,000
data sets because they may not fit

00:10:03,440 --> 00:10:08,399
on the developer machine so that's why

00:10:06,000 --> 00:10:11,760
we develop some rules around around

00:10:08,399 --> 00:10:13,279
google cloud storage as well once you

00:10:11,760 --> 00:10:15,519
have this setup you can go

00:10:13,279 --> 00:10:17,040
a bit further and do what we call hyper

00:10:15,519 --> 00:10:18,800
parameter tuning

00:10:17,040 --> 00:10:20,959
for those not familiar with that term

00:10:18,800 --> 00:10:23,519
hyper parameter tuning just means

00:10:20,959 --> 00:10:24,560
the ability to explore a very large

00:10:23,519 --> 00:10:27,200
number

00:10:24,560 --> 00:10:28,240
of config parameters for the training

00:10:27,200 --> 00:10:30,160
process

00:10:28,240 --> 00:10:32,640
so we can represent this in the bazel

00:10:30,160 --> 00:10:34,079
graph as a training configuration

00:10:32,640 --> 00:10:36,959
template

00:10:34,079 --> 00:10:38,800
which is a templated ml file as well as

00:10:36,959 --> 00:10:41,600
a design of experiments

00:10:38,800 --> 00:10:43,680
that represent how you want to explore

00:10:41,600 --> 00:10:45,920
the parameter space

00:10:43,680 --> 00:10:47,839
once we have that setup you basically

00:10:45,920 --> 00:10:51,120
generate as many

00:10:47,839 --> 00:10:55,120
bezel target as combinations and

00:10:51,120 --> 00:10:57,920
you inject those into our homemade doe

00:10:55,120 --> 00:10:58,880
gke rule that allows you to then launch

00:10:57,920 --> 00:11:02,560
all your jobs

00:10:58,880 --> 00:11:04,880
on gcp so what does it look like

00:11:02,560 --> 00:11:08,000
in code so on the right hand side you

00:11:04,880 --> 00:11:10,880
have our example yaml template file

00:11:08,000 --> 00:11:12,240
where you find two parameters algo and

00:11:10,880 --> 00:11:14,480
layers

00:11:12,240 --> 00:11:15,279
in the build file now you refer to those

00:11:14,480 --> 00:11:18,640
parameters

00:11:15,279 --> 00:11:21,839
using the doe config param rule

00:11:18,640 --> 00:11:22,720
so there is an argo target and a layers

00:11:21,839 --> 00:11:24,800
target

00:11:22,720 --> 00:11:25,839
then you bring those together inside the

00:11:24,800 --> 00:11:28,000
config target

00:11:25,839 --> 00:11:29,360
which is basically declaring a full

00:11:28,000 --> 00:11:31,279
factorial

00:11:29,360 --> 00:11:32,880
parameter exploration for those

00:11:31,279 --> 00:11:35,920
parameters

00:11:32,880 --> 00:11:36,399
and the last step is to use our doe gk

00:11:35,920 --> 00:11:39,440
rule

00:11:36,399 --> 00:11:41,680
which is taking in an

00:11:39,440 --> 00:11:44,079
image which is another bazel target

00:11:41,680 --> 00:11:47,200
which has packaged your software

00:11:44,079 --> 00:11:50,000
uh gcs bucket to upload the results

00:11:47,200 --> 00:11:50,800
and the doe configuration that i just

00:11:50,000 --> 00:11:53,120
mentioned

00:11:50,800 --> 00:11:53,920
you can also specify an output that

00:11:53,120 --> 00:11:57,120
you've set up

00:11:53,920 --> 00:11:59,440
on gk and this way in

00:11:57,120 --> 00:12:01,120
less than 15 lines of code you're ready

00:11:59,440 --> 00:12:04,160
to basil run

00:12:01,120 --> 00:12:08,560
thousands of experiments on the clouds

00:12:04,160 --> 00:12:10,399
with no more coding needed

00:12:08,560 --> 00:12:12,160
so let's talk a little bit more about

00:12:10,399 --> 00:12:15,040
pragmatic versus aromatic

00:12:12,160 --> 00:12:16,240
and how do we handle the pragmatic

00:12:15,040 --> 00:12:18,320
dependencies

00:12:16,240 --> 00:12:21,120
so as i said earlier those dependencies

00:12:18,320 --> 00:12:24,000
are declared in a docker file so bazel

00:12:21,120 --> 00:12:25,920
is not aware of them so when we use

00:12:24,000 --> 00:12:27,120
bazel docker rules to package our

00:12:25,920 --> 00:12:28,639
application

00:12:27,120 --> 00:12:31,200
those dependencies are not going to get

00:12:28,639 --> 00:12:34,079
picked up automatically

00:12:31,200 --> 00:12:34,800
so what we use for this is a homemade

00:12:34,079 --> 00:12:37,600
rule

00:12:34,800 --> 00:12:39,680
that we developed called extended python

00:12:37,600 --> 00:12:40,880
image for example for python application

00:12:39,680 --> 00:12:44,000
where you can

00:12:40,880 --> 00:12:44,800
specify a number of debian packages in a

00:12:44,000 --> 00:12:48,240
simple

00:12:44,800 --> 00:12:50,800
array and create then

00:12:48,240 --> 00:12:51,440
an image that includes those debian

00:12:50,800 --> 00:12:54,320
packages

00:12:51,440 --> 00:12:56,720
installed and the way you use it

00:12:54,320 --> 00:12:57,839
eventually is by using your favorite pi

00:12:56,720 --> 00:13:00,880
3 image rule

00:12:57,839 --> 00:13:02,480
and using the base attributes together

00:13:00,880 --> 00:13:04,240
with the target

00:13:02,480 --> 00:13:05,680
that you define with extended python

00:13:04,240 --> 00:13:09,040
image that makes it very

00:13:05,680 --> 00:13:11,279
easy to ship those dependencies

00:13:09,040 --> 00:13:12,880
even though they're not tracked by bazel

00:13:11,279 --> 00:13:16,000
last but not least

00:13:12,880 --> 00:13:17,279
let's talk about traceability this is

00:13:16,000 --> 00:13:19,200
very important because

00:13:17,279 --> 00:13:21,120
a lot of researchers will share their

00:13:19,200 --> 00:13:23,680
research results

00:13:21,120 --> 00:13:25,600
share the per email send some archives

00:13:23,680 --> 00:13:29,279
around and we want to be able to

00:13:25,600 --> 00:13:32,480
maintain this reproducibility outside

00:13:29,279 --> 00:13:33,040
of the basal graph so the way we do this

00:13:32,480 --> 00:13:36,000
is by

00:13:33,040 --> 00:13:36,959
integrating the stamping step in our

00:13:36,000 --> 00:13:39,279
bazel graph

00:13:36,959 --> 00:13:41,680
so as you can see on this diagram when

00:13:39,279 --> 00:13:44,880
you use the workspace status command

00:13:41,680 --> 00:13:46,399
option of bazel build you basically add

00:13:44,880 --> 00:13:49,680
an additional node

00:13:46,399 --> 00:13:51,519
that will be re-executed every time and

00:13:49,680 --> 00:13:53,839
this way we're able to include for

00:13:51,519 --> 00:13:55,760
example the git commit hash as part of

00:13:53,839 --> 00:13:57,680
the simulation results

00:13:55,760 --> 00:13:58,880
so what can we do to keep improving

00:13:57,680 --> 00:14:01,279
reproducibility

00:13:58,880 --> 00:14:03,920
of research software well the first

00:14:01,279 --> 00:14:06,399
thing we want to do is to open source

00:14:03,920 --> 00:14:08,079
our research platform and that will have

00:14:06,399 --> 00:14:11,440
a global impact hopefully

00:14:08,079 --> 00:14:13,680
and help other teams have their own

00:14:11,440 --> 00:14:15,040
bazel-powered reproducible research

00:14:13,680 --> 00:14:16,720
environment

00:14:15,040 --> 00:14:18,560
you know in our team we're going to try

00:14:16,720 --> 00:14:19,040
to put more and more things in the build

00:14:18,560 --> 00:14:22,079
graph

00:14:19,040 --> 00:14:24,320
use less docker and more bazel

00:14:22,079 --> 00:14:25,920
and so that's it thank you a lot for

00:14:24,320 --> 00:14:26,720
your attention i hope you enjoyed the

00:14:25,920 --> 00:14:28,959
presentation

00:14:26,720 --> 00:14:30,079
and we looking forward to seeing more

00:14:28,959 --> 00:14:44,880
and more people using

00:14:30,079 --> 00:14:44,880

YouTube URL: https://www.youtube.com/watch?v=aXXuBvNcpQg


