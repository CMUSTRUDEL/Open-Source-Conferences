Title: Designing a language Agnostic CI using Bazel queries
Publication date: 2020-11-10
Playlist: BazelCon 2020
Description: 
	Okay, so your company has adopted Bazel as the build system of choice—running it in a Continuous Integration environment should just be ‘Bazel test …’ and ‘Bazel run …’ right? Not so fast! How does the pipeline determine which targets to run? How do you scale that logic to multiple repos and their pipelines? At Pinterest, we developed a tool that leverages the Bazel query language to pull together a set of targets to run a language agnostic pipeline. We go over the details of how we use Bazel in our CI system and the impact it has in our ability to run scalable, multi-language pipelines.

Speaker: Urvashi Reddy

Watch more:
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Urvashi Reddy;
Captions: 
	00:00:01,040 --> 00:00:06,319
[Music]

00:00:05,839 --> 00:00:08,080
hi

00:00:06,319 --> 00:00:09,760
my name is arvasha reddy and i am a

00:00:08,080 --> 00:00:10,960
software engineer at pinterest

00:00:09,760 --> 00:00:13,200
today i'm going to be talking to you

00:00:10,960 --> 00:00:14,559
about designing ci pipelines with bazel

00:00:13,200 --> 00:00:16,240
queries in mind

00:00:14,559 --> 00:00:18,640
pinterest is an application that allows

00:00:16,240 --> 00:00:20,560
users to save ideas from the internet

00:00:18,640 --> 00:00:22,160
our company mission is to bring everyone

00:00:20,560 --> 00:00:22,960
the inspiration to create the life they

00:00:22,160 --> 00:00:25,119
love

00:00:22,960 --> 00:00:26,480
we have over 400 million users using the

00:00:25,119 --> 00:00:28,080
application today

00:00:26,480 --> 00:00:29,679
and within our engineering org we have

00:00:28,080 --> 00:00:30,080
about a thousand engineers helping to

00:00:29,679 --> 00:00:33,680
develop

00:00:30,080 --> 00:00:35,200
pinterest the team that i work on

00:00:33,680 --> 00:00:37,840
is called the engineering productivity

00:00:35,200 --> 00:00:39,760
team our mission is to build a developer

00:00:37,840 --> 00:00:40,960
platform that inspires developers to do

00:00:39,760 --> 00:00:42,320
their best work

00:00:40,960 --> 00:00:44,000
we like to think of a developer's

00:00:42,320 --> 00:00:46,480
journey as one that boils down

00:00:44,000 --> 00:00:47,440
into three main pillars code build and

00:00:46,480 --> 00:00:49,680
deploy

00:00:47,440 --> 00:00:51,520
in this talk i'll focus on what code and

00:00:49,680 --> 00:00:53,199
build is at pinterest and how we use

00:00:51,520 --> 00:00:54,640
bazel to create a better experience for

00:00:53,199 --> 00:00:57,199
our developers

00:00:54,640 --> 00:00:59,520
we decided to migrate over from using

00:00:57,199 --> 00:01:00,960
maven to bazel a couple years ago

00:00:59,520 --> 00:01:02,960
and there were a lot of lessons learned

00:01:00,960 --> 00:01:04,799
during that process i highly encourage

00:01:02,960 --> 00:01:06,080
you to check out my colleague eden jean

00:01:04,799 --> 00:01:07,840
baptiste's talk

00:01:06,080 --> 00:01:09,600
on pinterest's journey to a bazel

00:01:07,840 --> 00:01:10,720
monorepo so you can learn all about

00:01:09,600 --> 00:01:12,159
those lessons and have it

00:01:10,720 --> 00:01:13,920
have a deep dive into what that journey

00:01:12,159 --> 00:01:15,840
was like for us that talk

00:01:13,920 --> 00:01:17,200
will be available at base on con

00:01:15,840 --> 00:01:18,799
tomorrow morning

00:01:17,200 --> 00:01:20,240
okay so let's talk about what coding and

00:01:18,799 --> 00:01:21,920
building looks like at pinterest

00:01:20,240 --> 00:01:23,360
and where we first were when we migrated

00:01:21,920 --> 00:01:26,320
to bazel

00:01:23,360 --> 00:01:28,400
pinterest uses uh monorepos it's what i

00:01:26,320 --> 00:01:30,320
call monorepo-ish

00:01:28,400 --> 00:01:31,439
technically the word monorepos is an

00:01:30,320 --> 00:01:33,840
oxymoron

00:01:31,439 --> 00:01:35,680
since a monorepo is a single repository

00:01:33,840 --> 00:01:36,880
that stores all of your code and assets

00:01:35,680 --> 00:01:39,200
for every project

00:01:36,880 --> 00:01:40,240
but what we have is a few repos that are

00:01:39,200 --> 00:01:42,479
grouped by language

00:01:40,240 --> 00:01:44,159
and they're fairly large for example our

00:01:42,479 --> 00:01:46,880
java monorepo

00:01:44,159 --> 00:01:48,560
monorepo houses 250 services and they

00:01:46,880 --> 00:01:49,840
have common code that is shared between

00:01:48,560 --> 00:01:51,200
those services

00:01:49,840 --> 00:01:53,759
this java repo is actually where we

00:01:51,200 --> 00:01:55,840
first started our bazel migration

00:01:53,759 --> 00:01:57,680
moving over to build rt manages

00:01:55,840 --> 00:01:59,680
continuous integration environments and

00:01:57,680 --> 00:02:01,840
it outputs the build artifacts

00:01:59,680 --> 00:02:03,360
our ci uses what we call a dispatcher

00:02:01,840 --> 00:02:05,040
model which is really simple

00:02:03,360 --> 00:02:06,880
all the dispatcher model means is that

00:02:05,040 --> 00:02:08,239
it the first step the ci is going to

00:02:06,880 --> 00:02:09,520
take is to figure out what are the

00:02:08,239 --> 00:02:11,280
incoming changes

00:02:09,520 --> 00:02:13,840
what we need to run and dispatch that

00:02:11,280 --> 00:02:15,280
work to workers that run in parallel

00:02:13,840 --> 00:02:17,599
what this looked like when we migrated

00:02:15,280 --> 00:02:18,480
to bazel was in our java repo

00:02:17,599 --> 00:02:20,640
specifically

00:02:18,480 --> 00:02:22,160
was a really large python script that

00:02:20,640 --> 00:02:24,080
needed to figure out which

00:02:22,160 --> 00:02:25,280
projects were affected by the incoming

00:02:24,080 --> 00:02:26,959
code changes

00:02:25,280 --> 00:02:28,800
the script would then call the targets

00:02:26,959 --> 00:02:31,280
defined within the particular

00:02:28,800 --> 00:02:32,080
project there were a few problems with

00:02:31,280 --> 00:02:33,680
this approach

00:02:32,080 --> 00:02:35,599
for one the python script was really

00:02:33,680 --> 00:02:36,560
complicated it had to handle a lot of

00:02:35,599 --> 00:02:38,480
edge cases

00:02:36,560 --> 00:02:40,640
like what to do when there's a change in

00:02:38,480 --> 00:02:41,760
the shared code and so it quickly became

00:02:40,640 --> 00:02:43,360
very unwieldy

00:02:41,760 --> 00:02:45,360
it also did not help that it was

00:02:43,360 --> 00:02:46,160
untested it was difficult for our team

00:02:45,360 --> 00:02:48,560
to make changes

00:02:46,160 --> 00:02:49,440
and to update it when we needed to

00:02:48,560 --> 00:02:50,720
secondly

00:02:49,440 --> 00:02:52,720
when the script could not determine

00:02:50,720 --> 00:02:54,080
which projects were which projects

00:02:52,720 --> 00:02:55,280
targets were to run

00:02:54,080 --> 00:02:57,440
it would fall back to building

00:02:55,280 --> 00:03:00,159
everything which was really expensive

00:02:57,440 --> 00:03:00,959
so in our java repo we had 250 services

00:03:00,159 --> 00:03:03,599
and over

00:03:00,959 --> 00:03:04,400
7 000 bazel targets frequently building

00:03:03,599 --> 00:03:06,319
all of those

00:03:04,400 --> 00:03:08,159
was causing an unnecessarily delay in

00:03:06,319 --> 00:03:11,440
our ci feedback cycle and not bringing

00:03:08,159 --> 00:03:14,239
our developers a whole lot of joy

00:03:11,440 --> 00:03:15,920
lastly we couldn't apply the the script

00:03:14,239 --> 00:03:17,519
to any of our other larger repos that we

00:03:15,920 --> 00:03:18,159
were migrating to bazel with it was

00:03:17,519 --> 00:03:20,400
specific

00:03:18,159 --> 00:03:21,840
to this java repo and it was specific to

00:03:20,400 --> 00:03:23,519
some of the projects within them because

00:03:21,840 --> 00:03:25,440
of its approach to figure out which

00:03:23,519 --> 00:03:27,440
which project was affected and then thus

00:03:25,440 --> 00:03:29,120
running the targets within them

00:03:27,440 --> 00:03:30,720
so it was very much time to update our

00:03:29,120 --> 00:03:33,120
query tooling and our ci

00:03:30,720 --> 00:03:34,640
for bazel we had a few requirements that

00:03:33,120 --> 00:03:37,120
we already knew going into the

00:03:34,640 --> 00:03:39,120
going into the new approach one of them

00:03:37,120 --> 00:03:40,480
would be that we needed to continue to

00:03:39,120 --> 00:03:42,080
be self-service

00:03:40,480 --> 00:03:43,760
we did not want to have our developers

00:03:42,080 --> 00:03:44,959
have to write any special config that

00:03:43,760 --> 00:03:47,360
dictated what

00:03:44,959 --> 00:03:48,560
about their service would run in ci we

00:03:47,360 --> 00:03:49,840
only wanted them to focus on

00:03:48,560 --> 00:03:51,440
implementing their service and have

00:03:49,840 --> 00:03:53,120
enough bazel knowledge to be able to

00:03:51,440 --> 00:03:54,959
construct their build file

00:03:53,120 --> 00:03:56,560
and also this information about what

00:03:54,959 --> 00:03:57,920
they wanted to run in the build file

00:03:56,560 --> 00:03:59,680
literally existed in the build file

00:03:57,920 --> 00:04:01,040
itself so we should have been able to we

00:03:59,680 --> 00:04:02,319
should be able to leverage that without

00:04:01,040 --> 00:04:04,400
having them to write additional

00:04:02,319 --> 00:04:06,000
functionality for ci

00:04:04,400 --> 00:04:07,920
we also needed faster build and

00:04:06,000 --> 00:04:09,840
reproducible builds um i mentioned that

00:04:07,920 --> 00:04:10,959
we were frequently building all and also

00:04:09,840 --> 00:04:12,879
if we need to do any sort of

00:04:10,959 --> 00:04:13,680
investigations about why a ci failure

00:04:12,879 --> 00:04:15,200
was happening

00:04:13,680 --> 00:04:17,680
reproducibility was going to be really

00:04:15,200 --> 00:04:19,519
important

00:04:17,680 --> 00:04:21,120
and lastly in order for us to scale our

00:04:19,519 --> 00:04:23,040
migration to bazel and just to have

00:04:21,120 --> 00:04:24,400
consistent tooling across that would

00:04:23,040 --> 00:04:25,360
make it really easy for our team to

00:04:24,400 --> 00:04:26,720
manage

00:04:25,360 --> 00:04:28,479
we needed to be able to apply this

00:04:26,720 --> 00:04:29,680
neutral link to any any of our major

00:04:28,479 --> 00:04:31,280
repos

00:04:29,680 --> 00:04:33,600
regardless of anything that was inside

00:04:31,280 --> 00:04:33,600
of them

00:04:33,919 --> 00:04:37,600
so the first thing that we did was

00:04:35,440 --> 00:04:39,840
replace the python script with a golang

00:04:37,600 --> 00:04:41,600
cli called build collector

00:04:39,840 --> 00:04:43,360
build collector takes in two git commit

00:04:41,600 --> 00:04:45,040
shaws and outputs the minimal set of

00:04:43,360 --> 00:04:46,880
affected bazel targets

00:04:45,040 --> 00:04:49,280
it does this by running bazel queries to

00:04:46,880 --> 00:04:51,360
figure out which targets were affected

00:04:49,280 --> 00:04:52,479
it's much simpler and it's not repo

00:04:51,360 --> 00:04:54,000
project specific

00:04:52,479 --> 00:04:55,440
and the best part is that it's tested so

00:04:54,000 --> 00:04:57,840
we can make changes and not worry about

00:04:55,440 --> 00:04:57,840
regression

00:04:58,560 --> 00:05:02,560
so the way build collector works is that

00:05:00,880 --> 00:05:04,000
it has an understanding of what types of

00:05:02,560 --> 00:05:06,160
files have changed

00:05:04,000 --> 00:05:07,120
and this boils down for us into five

00:05:06,160 --> 00:05:09,199
change types

00:05:07,120 --> 00:05:11,280
so we have if the workspace file changed

00:05:09,199 --> 00:05:12,400
the build file change or the extension

00:05:11,280 --> 00:05:14,320
file changed

00:05:12,400 --> 00:05:16,400
those three are just starlock rules that

00:05:14,320 --> 00:05:18,320
are common in the repository

00:05:16,400 --> 00:05:19,840
the other thing we want to handle for is

00:05:18,320 --> 00:05:21,199
deleted files what which

00:05:19,840 --> 00:05:23,120
set of targets should be run if a file

00:05:21,199 --> 00:05:24,400
is deleted and lastly the most common

00:05:23,120 --> 00:05:24,880
one which is just a source file has

00:05:24,400 --> 00:05:26,400
changed

00:05:24,880 --> 00:05:28,320
let's figure out the affected targets

00:05:26,400 --> 00:05:30,080
for that change

00:05:28,320 --> 00:05:31,919
so let's take a closer look at what

00:05:30,080 --> 00:05:34,080
bazel queries build collector is running

00:05:31,919 --> 00:05:35,840
for each type of file change

00:05:34,080 --> 00:05:37,120
um i should also mention that the

00:05:35,840 --> 00:05:38,720
queries on the slide deck are not

00:05:37,120 --> 00:05:39,360
necessarily syntactically correct and

00:05:38,720 --> 00:05:41,360
have been

00:05:39,360 --> 00:05:43,280
uh very much simplified to just make

00:05:41,360 --> 00:05:46,320
sure that everything fits on the slider

00:05:43,280 --> 00:05:48,320
and looks nice but okay so let's look at

00:05:46,320 --> 00:05:50,160
if a workspace file was changed

00:05:48,320 --> 00:05:51,680
the scope of impact for one a workspace

00:05:50,160 --> 00:05:53,520
file change is pretty much everything in

00:05:51,680 --> 00:05:55,360
the repo so we run a very simple query

00:05:53,520 --> 00:05:56,880
that returns all the test targets

00:05:55,360 --> 00:05:59,440
um that's outlined there so that's just

00:05:56,880 --> 00:06:01,120
bazel query everything in the repo

00:05:59,440 --> 00:06:02,720
if it's a build file that's changed then

00:06:01,120 --> 00:06:03,039
the scope of impact that we care about

00:06:02,720 --> 00:06:05,039
is

00:06:03,039 --> 00:06:06,960
every target that's defined within the

00:06:05,039 --> 00:06:07,759
build file and anything that depends on

00:06:06,960 --> 00:06:10,000
them

00:06:07,759 --> 00:06:11,039
so to get that information we need to

00:06:10,000 --> 00:06:13,440
run two queries

00:06:11,039 --> 00:06:15,520
the first one is a set query that just

00:06:13,440 --> 00:06:17,120
returns the build labels this is

00:06:15,520 --> 00:06:18,720
tell me i'm giving you the build files

00:06:17,120 --> 00:06:20,080
that have changed bazel query tell me

00:06:18,720 --> 00:06:22,319
what the build labels are what

00:06:20,080 --> 00:06:23,840
the corresponding ones are we can then

00:06:22,319 --> 00:06:25,680
take that first part of the build label

00:06:23,840 --> 00:06:26,000
that was returned to us and suffix it

00:06:25,680 --> 00:06:28,000
with

00:06:26,000 --> 00:06:29,680
a colon all in order to get all of the

00:06:28,000 --> 00:06:30,800
targets that were defined within that

00:06:29,680 --> 00:06:33,120
build file

00:06:30,800 --> 00:06:34,720
notice we are also using the rdeps query

00:06:33,120 --> 00:06:37,440
function which returns the reverse

00:06:34,720 --> 00:06:39,280
dependencies of those targets

00:06:37,440 --> 00:06:40,800
these two set of queries is what ends up

00:06:39,280 --> 00:06:42,400
being the basis of what we run for our

00:06:40,800 --> 00:06:43,919
next two queries as well

00:06:42,400 --> 00:06:45,520
which is nice for us to be able to reuse

00:06:43,919 --> 00:06:48,560
a lot of this logic in build collector

00:06:45,520 --> 00:06:50,720
making sure that it's still simple

00:06:48,560 --> 00:06:52,639
okay so let's look at extension changes

00:06:50,720 --> 00:06:54,080
we need to know what bill files are

00:06:52,639 --> 00:06:55,680
loading the extension files and that

00:06:54,080 --> 00:06:57,919
will give us the scope of impact

00:06:55,680 --> 00:06:59,199
that we're looking for in this case we

00:06:57,919 --> 00:07:01,680
use what's called a sky

00:06:59,199 --> 00:07:03,039
query and a sky query is just like a

00:07:01,680 --> 00:07:05,039
basil query but it has a couple extra

00:07:03,039 --> 00:07:06,240
flags on it to make it into a sky query

00:07:05,039 --> 00:07:08,000
and what we use it for

00:07:06,240 --> 00:07:09,440
is to be able to find all the build

00:07:08,000 --> 00:07:12,160
files that

00:07:09,440 --> 00:07:13,520
are loading this extension once we have

00:07:12,160 --> 00:07:15,199
the list of build files we can simply

00:07:13,520 --> 00:07:16,080
run the same set of build change queries

00:07:15,199 --> 00:07:17,599
that we have above

00:07:16,080 --> 00:07:19,680
to be able to know what targets were in

00:07:17,599 --> 00:07:21,950
them and what were what if any targets

00:07:19,680 --> 00:07:23,599
are depending on them

00:07:21,950 --> 00:07:26,000
[Music]

00:07:23,599 --> 00:07:27,680
okay for deleted files we find all of

00:07:26,000 --> 00:07:29,360
the parent directories of the deleted

00:07:27,680 --> 00:07:31,120
file and the build files within each

00:07:29,360 --> 00:07:31,599
directory so we're simply walking up the

00:07:31,120 --> 00:07:33,199
tree

00:07:31,599 --> 00:07:35,360
and finding all the build files that

00:07:33,199 --> 00:07:36,160
could have been referencing this deleted

00:07:35,360 --> 00:07:38,000
file

00:07:36,160 --> 00:07:39,440
we then run the build change queries

00:07:38,000 --> 00:07:41,280
from the previous side because

00:07:39,440 --> 00:07:42,479
we've gotten now pretty much the same

00:07:41,280 --> 00:07:43,520
thing we needed which was the build

00:07:42,479 --> 00:07:45,280
files and

00:07:43,520 --> 00:07:47,120
the targets within them and then

00:07:45,280 --> 00:07:49,520
anything that depended on them

00:07:47,120 --> 00:07:50,720
lastly the simplest query we run is for

00:07:49,520 --> 00:07:52,479
the source file changes

00:07:50,720 --> 00:07:55,440
we take the list of files that i've

00:07:52,479 --> 00:07:57,199
changed and pass them to rdep's

00:07:55,440 --> 00:07:58,800
query function in order to get all of

00:07:57,199 --> 00:07:59,680
the targets dependent on that source

00:07:58,800 --> 00:08:01,360
file

00:07:59,680 --> 00:08:03,360
and that's pretty much it those are the

00:08:01,360 --> 00:08:04,800
the meat of what build collector is

00:08:03,360 --> 00:08:08,240
running

00:08:04,800 --> 00:08:10,800
let's take a step back and go to ci

00:08:08,240 --> 00:08:11,680
and think about what stages we want to

00:08:10,800 --> 00:08:13,039
to achieve

00:08:11,680 --> 00:08:14,319
in order to have confidence in the

00:08:13,039 --> 00:08:15,840
changes that are coming in the code

00:08:14,319 --> 00:08:17,440
changes that are coming in

00:08:15,840 --> 00:08:18,879
so the first thing we want to do is we

00:08:17,440 --> 00:08:20,479
want to test the code and we want to

00:08:18,879 --> 00:08:21,280
test the right targets that are coming

00:08:20,479 --> 00:08:23,680
in

00:08:21,280 --> 00:08:25,280
we only want to run test targets then we

00:08:23,680 --> 00:08:27,280
need to compile the release

00:08:25,280 --> 00:08:28,720
artifacts that we then plan to publish

00:08:27,280 --> 00:08:30,400
in a later stage

00:08:28,720 --> 00:08:32,479
this is important feedback to have as a

00:08:30,400 --> 00:08:34,080
second stage since our repos have shared

00:08:32,479 --> 00:08:36,399
common code so we want to make sure that

00:08:34,080 --> 00:08:38,080
they are all compiled together correctly

00:08:36,399 --> 00:08:39,919
and that there aren't any issues where

00:08:38,080 --> 00:08:42,240
one change in a shared library code has

00:08:39,919 --> 00:08:44,159
impacted other artifacts that

00:08:42,240 --> 00:08:46,240
are not able to compile and thus later

00:08:44,159 --> 00:08:47,920
on failing in the published stage

00:08:46,240 --> 00:08:49,519
and lastly once we have that confidence

00:08:47,920 --> 00:08:51,920
we can finally just publish the

00:08:49,519 --> 00:08:53,519
artifacts that we care about nci

00:08:51,920 --> 00:08:55,600
so how do we construct our queries for

00:08:53,519 --> 00:08:57,839
the stages that we want and the outcomes

00:08:55,600 --> 00:09:00,240
that should happen in each of the stages

00:08:57,839 --> 00:09:01,680
for the test stage we can actually take

00:09:00,240 --> 00:09:03,600
the queries that we have

00:09:01,680 --> 00:09:05,519
uh previously before for each file

00:09:03,600 --> 00:09:07,839
change type and wrap them

00:09:05,519 --> 00:09:09,680
around a filter query that will only

00:09:07,839 --> 00:09:11,360
give us back test targets

00:09:09,680 --> 00:09:12,880
and there's two ways that we can do that

00:09:11,360 --> 00:09:15,279
we can either uh

00:09:12,880 --> 00:09:17,839
filter these out by using a kind query

00:09:15,279 --> 00:09:19,440
function and say and give it a simple

00:09:17,839 --> 00:09:20,959
regular expression that says i want

00:09:19,440 --> 00:09:23,760
everything that has underscore

00:09:20,959 --> 00:09:24,399
test uh that is an underscore test rule

00:09:23,760 --> 00:09:27,519
type

00:09:24,399 --> 00:09:28,640
because that's what uh bazel has a for

00:09:27,519 --> 00:09:33,200
test targets

00:09:28,640 --> 00:09:34,160
or we can um we can use the tests query

00:09:33,200 --> 00:09:36,000
function

00:09:34,160 --> 00:09:37,600
which will basically do exactly the same

00:09:36,000 --> 00:09:38,560
thing it will filter out only test

00:09:37,600 --> 00:09:40,560
targets

00:09:38,560 --> 00:09:42,080
but either one will get get us the the

00:09:40,560 --> 00:09:43,440
outcome that we're looking for

00:09:42,080 --> 00:09:45,760
and that will give us the test targets

00:09:43,440 --> 00:09:47,279
that we care about for the test stage

00:09:45,760 --> 00:09:49,760
for build and release targets we do have

00:09:47,279 --> 00:09:51,279
something a little bit more interesting

00:09:49,760 --> 00:09:53,519
notice that our query is doing the same

00:09:51,279 --> 00:09:55,279
thing we're taking the queries that were

00:09:53,519 --> 00:09:56,720
before the file change queries and we're

00:09:55,279 --> 00:09:58,399
wrapping them around a kind

00:09:56,720 --> 00:10:01,440
kind function but what we're filtering

00:09:58,399 --> 00:10:03,440
out instead is artifact ci release rules

00:10:01,440 --> 00:10:05,920
what's artifact ci release rules this is

00:10:03,440 --> 00:10:07,200
actually a custom release macro that we

00:10:05,920 --> 00:10:09,120
have written for publishing release

00:10:07,200 --> 00:10:12,240
artifacts at pinterest

00:10:09,120 --> 00:10:13,680
so how does that work exactly um in

00:10:12,240 --> 00:10:14,399
order to explain that i kind of have to

00:10:13,680 --> 00:10:16,480
explain

00:10:14,399 --> 00:10:18,399
a lot more about what we've done in

00:10:16,480 --> 00:10:19,920
customer in the custom release macro

00:10:18,399 --> 00:10:22,000
space at pinterest

00:10:19,920 --> 00:10:23,920
so our pinterest developers are creating

00:10:22,000 --> 00:10:26,959
a wide range of release artifacts

00:10:23,920 --> 00:10:27,680
we have jars case manifest files docker

00:10:26,959 --> 00:10:31,040
images

00:10:27,680 --> 00:10:32,320
and deployment tarballs in order for

00:10:31,040 --> 00:10:35,360
them to be able to

00:10:32,320 --> 00:10:36,880
publish uh the in pinterest fashion and

00:10:35,360 --> 00:10:38,880
all these different things that they

00:10:36,880 --> 00:10:40,000
uh all these different types of release

00:10:38,880 --> 00:10:41,279
that we have

00:10:40,000 --> 00:10:42,800
their build file would end up being

00:10:41,279 --> 00:10:44,160
really long and so we wanted to make

00:10:42,800 --> 00:10:45,040
sure that they had a better experience

00:10:44,160 --> 00:10:46,640
writing those

00:10:45,040 --> 00:10:49,120
those rules in their build files so we

00:10:46,640 --> 00:10:52,240
created custom release mana

00:10:49,120 --> 00:10:53,440
macros that essentially generated all of

00:10:52,240 --> 00:10:55,440
these rules

00:10:53,440 --> 00:10:57,120
and these rules boil down to two types

00:10:55,440 --> 00:11:00,240
of rules which are the push

00:10:57,120 --> 00:11:01,120
and manifest rules so push rules are the

00:11:00,240 --> 00:11:02,720
actual

00:11:01,120 --> 00:11:05,440
things that we're uploading the the

00:11:02,720 --> 00:11:08,480
artifacts themselves for example

00:11:05,440 --> 00:11:12,079
a docker image going to a registry or

00:11:08,480 --> 00:11:14,480
a jar that's being uploaded to s3

00:11:12,079 --> 00:11:15,680
those push rules are often referenced by

00:11:14,480 --> 00:11:18,800
a manifest rule

00:11:15,680 --> 00:11:20,880
so manifest rule is like a k-8s spec

00:11:18,800 --> 00:11:21,920
um that is referencing the docker image

00:11:20,880 --> 00:11:24,320
that it cares about

00:11:21,920 --> 00:11:26,320
and is versioned at specifically so we

00:11:24,320 --> 00:11:28,079
have this constraint happening

00:11:26,320 --> 00:11:29,839
where we need to make sure that push

00:11:28,079 --> 00:11:32,320
rules are uploaded

00:11:29,839 --> 00:11:33,200
are run first before manifest rules are

00:11:32,320 --> 00:11:35,680
run

00:11:33,200 --> 00:11:36,320
um so now we can simply do this in bazel

00:11:35,680 --> 00:11:38,399
bazel

00:11:36,320 --> 00:11:39,839
we could query uh the rules and we can

00:11:38,399 --> 00:11:41,279
set up the dependencies

00:11:39,839 --> 00:11:43,760
correctly and make sure that all these

00:11:41,279 --> 00:11:44,720
push rules are run right after manifest

00:11:43,760 --> 00:11:46,959
rules

00:11:44,720 --> 00:11:48,000
but what we found was that it was

00:11:46,959 --> 00:11:49,120
getting real

00:11:48,000 --> 00:11:50,639
what we found was that things were

00:11:49,120 --> 00:11:52,560
getting really slow and it was harder

00:11:50,639 --> 00:11:54,000
for build collector to be performant in

00:11:52,560 --> 00:11:55,839
in querying these things because there

00:11:54,000 --> 00:11:57,120
was a lot of different push and release

00:11:55,839 --> 00:11:58,800
rules that were generated by our

00:11:57,120 --> 00:12:00,000
customer macros

00:11:58,800 --> 00:12:01,760
the other thing i want to mention is

00:12:00,000 --> 00:12:03,360
that all of these release rules have two

00:12:01,760 --> 00:12:05,440
use cases

00:12:03,360 --> 00:12:06,560
they have the ci use case which is the

00:12:05,440 --> 00:12:08,079
one that we're talking about and this

00:12:06,560 --> 00:12:09,279
talking we care about which is

00:12:08,079 --> 00:12:11,279
you know creating these blessed

00:12:09,279 --> 00:12:12,639
artifacts that are mainly for production

00:12:11,279 --> 00:12:16,079
environments and

00:12:12,639 --> 00:12:17,440
production cd uh stages but there's also

00:12:16,079 --> 00:12:20,639
the dev use case where

00:12:17,440 --> 00:12:22,320
uh people who are at the at their local

00:12:20,639 --> 00:12:24,720
developers who are using it locally want

00:12:22,320 --> 00:12:28,320
to be able to just create a local build

00:12:24,720 --> 00:12:29,760
and um be able to uh not

00:12:28,320 --> 00:12:31,050
not deploy it on production but do some

00:12:29,760 --> 00:12:33,600
local testing of their own

00:12:31,050 --> 00:12:35,200
[Music]

00:12:33,600 --> 00:12:36,560
so once we found out that these release

00:12:35,200 --> 00:12:37,440
queries were taking a really long time

00:12:36,560 --> 00:12:39,040
in build collector

00:12:37,440 --> 00:12:40,880
we thought okay we need another release

00:12:39,040 --> 00:12:41,920
abstraction that's specific for ci but

00:12:40,880 --> 00:12:44,079
still has that same

00:12:41,920 --> 00:12:45,680
outcome for the for users who are using

00:12:44,079 --> 00:12:47,680
this at the local level and that's when

00:12:45,680 --> 00:12:50,000
we came up with artifact ci release and

00:12:47,680 --> 00:12:52,000
artifact dev release

00:12:50,000 --> 00:12:53,279
both artifact ci release and artifact

00:12:52,000 --> 00:12:55,200
dev release

00:12:53,279 --> 00:12:56,480
control the execution of push and

00:12:55,200 --> 00:12:58,399
manifest rules

00:12:56,480 --> 00:13:00,399
so now we're no longer relying as much

00:12:58,399 --> 00:13:02,240
on bazel to be able to tell us what is

00:13:00,399 --> 00:13:04,880
the dependency order because we have a

00:13:02,240 --> 00:13:06,560
a clear understanding of push rules and

00:13:04,880 --> 00:13:06,880
manifest rules at pinterest that need to

00:13:06,560 --> 00:13:08,480
run

00:13:06,880 --> 00:13:10,639
in that order and so we can simply

00:13:08,480 --> 00:13:13,360
subdivide them pass them

00:13:10,639 --> 00:13:15,920
to artifact ci or dev release and they

00:13:13,360 --> 00:13:18,000
can do that execution for us

00:13:15,920 --> 00:13:19,440
this made querying and build collector a

00:13:18,000 --> 00:13:22,000
lot faster

00:13:19,440 --> 00:13:23,440
so let's take a look at what the build

00:13:22,000 --> 00:13:25,279
file looks like

00:13:23,440 --> 00:13:26,720
and what developers are actually writing

00:13:25,279 --> 00:13:28,800
here we have a custom

00:13:26,720 --> 00:13:29,760
release rule called container release

00:13:28,800 --> 00:13:31,839
and it's actually

00:13:29,760 --> 00:13:33,760
achieving a lot of things the first

00:13:31,839 --> 00:13:34,079
thing is you'll see in that images key

00:13:33,760 --> 00:13:36,480
value

00:13:34,079 --> 00:13:37,200
map is a reference to a docker image

00:13:36,480 --> 00:13:40,160
that

00:13:37,200 --> 00:13:40,880
they want to publish over to a registry

00:13:40,160 --> 00:13:43,360
the

00:13:40,880 --> 00:13:44,480
second item there is a teletran tar ball

00:13:43,360 --> 00:13:47,519
which is an

00:13:44,480 --> 00:13:48,000
open source deployment environment that

00:13:47,519 --> 00:13:50,560
we have

00:13:48,000 --> 00:13:52,480
called teletran and uh that tarball

00:13:50,560 --> 00:13:53,760
helps us to deploy things to ec2

00:13:52,480 --> 00:13:57,199
instances

00:13:53,760 --> 00:13:57,920
and uh the third thing is a k-8's

00:13:57,199 --> 00:14:00,160
workload

00:13:57,920 --> 00:14:02,079
a yaml file that is being given to

00:14:00,160 --> 00:14:03,600
hermes so it's called hermes yamas and

00:14:02,079 --> 00:14:06,000
hermes is our

00:14:03,600 --> 00:14:06,720
pinterest solution for deploying k8's

00:14:06,000 --> 00:14:08,240
workloads

00:14:06,720 --> 00:14:09,440
right so this developer has this

00:14:08,240 --> 00:14:11,199
container release rule it's really

00:14:09,440 --> 00:14:13,600
common they have a cadets workload they

00:14:11,199 --> 00:14:14,720
have an ec2 deploy that they need to do

00:14:13,600 --> 00:14:17,199
and they have a docker image that they

00:14:14,720 --> 00:14:17,760
need to publish so all of that gets just

00:14:17,199 --> 00:14:19,199
defined

00:14:17,760 --> 00:14:20,959
right here and what actually gets

00:14:19,199 --> 00:14:24,320
generated is then consumed by

00:14:20,959 --> 00:14:26,720
rci what's generated here is

00:14:24,320 --> 00:14:28,560
um the release target that it

00:14:26,720 --> 00:14:28,959
corresponds to what the developer wrote

00:14:28,560 --> 00:14:30,240
in

00:14:28,959 --> 00:14:32,000
the build file themselves so this is the

00:14:30,240 --> 00:14:33,680
one that they'll recognize and we always

00:14:32,000 --> 00:14:36,480
alias that to the dev rule just to make

00:14:33,680 --> 00:14:38,800
sure that they are running the devil

00:14:36,480 --> 00:14:41,120
if they do run this target locally then

00:14:38,800 --> 00:14:43,680
we also have the ci version of this rule

00:14:41,120 --> 00:14:45,279
which is run by build collector so bill

00:14:43,680 --> 00:14:46,000
collector is the only thing that cares

00:14:45,279 --> 00:14:47,760
about this

00:14:46,000 --> 00:14:49,279
ci rule so that abstraction is hidden

00:14:47,760 --> 00:14:52,000
away from users

00:14:49,279 --> 00:14:52,959
we also have the the dev rule as well

00:14:52,000 --> 00:14:55,920
which is just

00:14:52,959 --> 00:14:58,639
the redundant role that is created from

00:14:55,920 --> 00:14:59,360
artifact dev release let's put that all

00:14:58,639 --> 00:15:03,279
together

00:14:59,360 --> 00:15:06,079
so we have the ci we have the ci stages

00:15:03,279 --> 00:15:07,600
and we have build collector but we need

00:15:06,079 --> 00:15:10,800
to now construct rci

00:15:07,600 --> 00:15:12,320
itself so the first stage that we want

00:15:10,800 --> 00:15:14,480
to do is actually run build collectors

00:15:12,320 --> 00:15:16,800
so we know which targets we need to run

00:15:14,480 --> 00:15:18,160
and so for this we have two commands

00:15:16,800 --> 00:15:20,160
that we're running in what i call the

00:15:18,160 --> 00:15:22,720
analysis stage

00:15:20,160 --> 00:15:24,399
build collector get test targets and we

00:15:22,720 --> 00:15:26,000
simply pass the directory which is the

00:15:24,399 --> 00:15:28,079
directory to the repo path

00:15:26,000 --> 00:15:30,079
the two git commit shaws which are

00:15:28,079 --> 00:15:32,160
previous and latest commit

00:15:30,079 --> 00:15:33,839
as well as where we want build collector

00:15:32,160 --> 00:15:35,279
to output its list of targets

00:15:33,839 --> 00:15:36,720
and that's always going to be a json

00:15:35,279 --> 00:15:39,199
file that we've listed as test

00:15:36,720 --> 00:15:41,279
targets.json for the test targets and

00:15:39,199 --> 00:15:43,040
release targets.json for the release

00:15:41,279 --> 00:15:44,399
targets

00:15:43,040 --> 00:15:46,560
we then can actually get to the meat of

00:15:44,399 --> 00:15:47,279
rci which is the test build and release

00:15:46,560 --> 00:15:48,880
stages

00:15:47,279 --> 00:15:51,120
and what we'll do is pull the list of

00:15:48,880 --> 00:15:52,160
targets out from that json file and pass

00:15:51,120 --> 00:15:54,720
it over to

00:15:52,160 --> 00:15:56,240
bazel test for the test stage bazel

00:15:54,720 --> 00:15:59,360
build for the build stage

00:15:56,240 --> 00:16:01,040
and bazel run for the release stage

00:15:59,360 --> 00:16:03,120
all right so stepping back and looking

00:16:01,040 --> 00:16:05,120
at what we've been able to achieve

00:16:03,120 --> 00:16:07,360
we maintained that the build file is the

00:16:05,120 --> 00:16:08,800
contract between developers and ci this

00:16:07,360 --> 00:16:10,720
is where they are dictating what needs

00:16:08,800 --> 00:16:12,560
to run in ci and we're leveraging that

00:16:10,720 --> 00:16:14,079
and not asking them to have to learn

00:16:12,560 --> 00:16:15,199
more things or specify more things for

00:16:14,079 --> 00:16:16,480
ci

00:16:15,199 --> 00:16:19,279
the other thing we've been able to do is

00:16:16,480 --> 00:16:21,759
to decrease ci build times

00:16:19,279 --> 00:16:22,720
um we're no longer frequently building

00:16:21,759 --> 00:16:24,399
all and we're

00:16:22,720 --> 00:16:26,399
building the minimal set of bazel

00:16:24,399 --> 00:16:27,839
targets in ci which uh has

00:16:26,399 --> 00:16:29,440
had a lot faster feedback for our

00:16:27,839 --> 00:16:32,160
developers

00:16:29,440 --> 00:16:33,839
we've also simplified publishing release

00:16:32,160 --> 00:16:34,959
artifacts we talked about the custom

00:16:33,839 --> 00:16:36,000
rules

00:16:34,959 --> 00:16:38,959
and the ways that we've built

00:16:36,000 --> 00:16:40,399
obstructions for ci and the dev use case

00:16:38,959 --> 00:16:42,160
and lastly and something that's really

00:16:40,399 --> 00:16:44,160
going to help our team to be able to

00:16:42,160 --> 00:16:46,079
uh continue with this approach is by

00:16:44,160 --> 00:16:47,600
having consistent ci tooling that we can

00:16:46,079 --> 00:16:49,600
apply to any of our repos that are

00:16:47,600 --> 00:16:51,600
migrating over to bazel

00:16:49,600 --> 00:16:53,199
so what's next for us um one of the

00:16:51,600 --> 00:16:56,240
things that we really want to look into

00:16:53,199 --> 00:16:58,160
is automatic steps for uh

00:16:56,240 --> 00:17:00,000
determining when flaky test targets are

00:16:58,160 --> 00:17:01,680
running and being able to tag them using

00:17:00,000 --> 00:17:04,000
basal tags and remove them out of the

00:17:01,680 --> 00:17:05,679
rotation for what ones in ci um

00:17:04,000 --> 00:17:07,280
bazel lends itself nicely for doing

00:17:05,679 --> 00:17:09,120
something like this so

00:17:07,280 --> 00:17:10,640
um we're that's probably the next thing

00:17:09,120 --> 00:17:11,679
that we're going to explore

00:17:10,640 --> 00:17:13,439
the other thing that we'd eventually

00:17:11,679 --> 00:17:14,720
like to get to is just to have one

00:17:13,439 --> 00:17:16,480
monorepo and truly

00:17:14,720 --> 00:17:18,319
use the definition of what monorepo is

00:17:16,480 --> 00:17:20,640
and have all repos in one space

00:17:18,319 --> 00:17:22,240
once we do that we'll have uh pretty

00:17:20,640 --> 00:17:23,919
much hit

00:17:22,240 --> 00:17:26,079
a scale in which we'll need to improve

00:17:23,919 --> 00:17:27,039
the query analysis performance in build

00:17:26,079 --> 00:17:28,480
collector

00:17:27,039 --> 00:17:29,760
and there's a couple of ways that people

00:17:28,480 --> 00:17:30,559
are already actually doing this in the

00:17:29,760 --> 00:17:33,440
bazel

00:17:30,559 --> 00:17:34,559
community i know of one at least in the

00:17:33,440 --> 00:17:35,760
open source community where they're

00:17:34,559 --> 00:17:39,200
using

00:17:35,760 --> 00:17:40,480
hashing to be able to get these targets

00:17:39,200 --> 00:17:42,160
a lot faster so that's something we'll

00:17:40,480 --> 00:17:44,080
probably explore in the later stages as

00:17:42,160 --> 00:17:45,840
well

00:17:44,080 --> 00:17:49,520
thank you so much for watching this talk

00:17:45,840 --> 00:17:51,280
um i also want to say a big thank you to

00:17:49,520 --> 00:17:52,720
our senior technical lead at pinterest

00:17:51,280 --> 00:17:53,679
james fesh who really helped a lot with

00:17:52,720 --> 00:17:55,200
these projects

00:17:53,679 --> 00:17:56,720
as well as my team the engineering

00:17:55,200 --> 00:17:58,400
productivity team

00:17:56,720 --> 00:18:00,240
both past and present members have

00:17:58,400 --> 00:18:14,320
really contributed a lot to make

00:18:00,240 --> 00:18:14,320

YouTube URL: https://www.youtube.com/watch?v=vZcckIaoTPU


