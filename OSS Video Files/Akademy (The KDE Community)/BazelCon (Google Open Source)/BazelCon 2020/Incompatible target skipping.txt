Title: Incompatible target skipping
Publication date: 2020-11-13
Playlist: BazelCon 2020
Description: 
	Let's fix bazel test //... to work again for all projects!  We provide a quick overview of platforms, and introduce the new target_compatible_with argument. We also cover how both the platform and toolchain should be thought of as interfaces for configuring your builds.

Resources:
Github: https://goo.gle/35hJ0hN

Speakers: Austin Schuh & Philipp Schrader

Watch more:
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Austin Schuh, Philipp Schrader;
Captions: 
	00:00:01,040 --> 00:00:06,319
[Music]

00:00:05,839 --> 00:00:08,080
hi

00:00:06,319 --> 00:00:10,080
my name is phil schrader and i'll be

00:00:08,080 --> 00:00:11,120
talking to you today about incompatible

00:00:10,080 --> 00:00:12,960
target skipping

00:00:11,120 --> 00:00:14,880
this is a feature that austin shu

00:00:12,960 --> 00:00:16,240
proposed last year together with greg

00:00:14,880 --> 00:00:18,720
estrin from google

00:00:16,240 --> 00:00:20,000
since about march or so of this year we

00:00:18,720 --> 00:00:20,800
have been slowly working on the

00:00:20,000 --> 00:00:22,800
implementation

00:00:20,800 --> 00:00:24,800
and this should be available for you on

00:00:22,800 --> 00:00:27,039
master i am joined today

00:00:24,800 --> 00:00:29,039
by austin who will host the second half

00:00:27,039 --> 00:00:31,439
of the presentation

00:00:29,039 --> 00:00:32,719
the two of us mentor the mountain view

00:00:31,439 --> 00:00:34,640
high school robotics team

00:00:32,719 --> 00:00:36,079
where we encounter the motivating

00:00:34,640 --> 00:00:38,960
examples for this proposal

00:00:36,079 --> 00:00:39,920
quite often so talking about motivating

00:00:38,960 --> 00:00:42,160
examples what

00:00:39,920 --> 00:00:44,160
is incompatible target skipping well

00:00:42,160 --> 00:00:45,920
let's explore this with a very innocuous

00:00:44,160 --> 00:00:47,760
example which should hopefully make it

00:00:45,920 --> 00:00:50,480
pretty obvious

00:00:47,760 --> 00:00:51,039
let your imagination go wild and picture

00:00:50,480 --> 00:00:54,160
yourself

00:00:51,039 --> 00:00:54,559
wanting to fix a basal bug crazy idea i

00:00:54,160 --> 00:00:57,840
know

00:00:54,559 --> 00:00:59,680
but bear with me so what do you do you

00:00:57,840 --> 00:01:02,079
check out the bazel repo

00:00:59,680 --> 00:01:04,320
you make your change and because you're

00:01:02,079 --> 00:01:05,360
a good developer you want to run all the

00:01:04,320 --> 00:01:08,159
tests

00:01:05,360 --> 00:01:09,760
how do you do that well obviously the re

00:01:08,159 --> 00:01:13,840
the right answer is to

00:01:09,760 --> 00:01:13,840
run bazel test slash dot dot

00:01:13,920 --> 00:01:18,320
unfortunately as you can see no good

00:01:15,759 --> 00:01:21,280
developer goes unpunished

00:01:18,320 --> 00:01:22,080
on the screenshot you can see that test

00:01:21,280 --> 00:01:24,400
bazel test

00:01:22,080 --> 00:01:25,280
slash dot dot doesn't actually work

00:01:24,400 --> 00:01:27,759
because

00:01:25,280 --> 00:01:28,320
it'll build targets and run tests that

00:01:27,759 --> 00:01:30,960
will

00:01:28,320 --> 00:01:32,479
just never work for your platform in

00:01:30,960 --> 00:01:35,040
this case we're running on

00:01:32,479 --> 00:01:36,000
a linux machine and this windows only

00:01:35,040 --> 00:01:39,600
target

00:01:36,000 --> 00:01:40,960
will not compile so the goal of

00:01:39,600 --> 00:01:43,040
incompatible target skipping

00:01:40,960 --> 00:01:44,880
is to recognize targets like this and

00:01:43,040 --> 00:01:46,880
just skip them during the build or the

00:01:44,880 --> 00:01:49,520
test whatever you're doing

00:01:46,880 --> 00:01:51,520
okay let's do a quick recap of what

00:01:49,520 --> 00:01:53,439
platforms and tool chains look like in

00:01:51,520 --> 00:01:55,200
case you haven't made that jump yet for

00:01:53,439 --> 00:01:57,600
your own project

00:01:55,200 --> 00:02:00,159
formally a platform is a collection of

00:01:57,600 --> 00:02:02,640
constraint value targets

00:02:00,159 --> 00:02:04,000
these targets describe the properties of

00:02:02,640 --> 00:02:06,560
the platform

00:02:04,000 --> 00:02:07,119
the bazel build platforms repo contains

00:02:06,560 --> 00:02:09,599
the most

00:02:07,119 --> 00:02:10,879
common constraints that you will need it

00:02:09,599 --> 00:02:13,840
defines things like

00:02:10,879 --> 00:02:14,800
running on an arm cpu or running on a

00:02:13,840 --> 00:02:17,120
linux os

00:02:14,800 --> 00:02:18,959
stuff like that and they're happy to

00:02:17,120 --> 00:02:19,680
accept more contributions for other

00:02:18,959 --> 00:02:22,160
constraints

00:02:19,680 --> 00:02:24,239
the repo is really meant to serve all

00:02:22,160 --> 00:02:26,400
authors to express constraints with a

00:02:24,239 --> 00:02:28,959
common vocabulary

00:02:26,400 --> 00:02:30,160
the repo does ship with bazel but it may

00:02:28,959 --> 00:02:32,400
be outdated so you

00:02:30,160 --> 00:02:34,959
might have to import your own version

00:02:32,400 --> 00:02:37,440
for what you need

00:02:34,959 --> 00:02:38,239
at a high level bazel knows about three

00:02:37,440 --> 00:02:40,400
platforms

00:02:38,239 --> 00:02:42,400
the host platform the target platform

00:02:40,400 --> 00:02:45,440
and the execution platform

00:02:42,400 --> 00:02:47,760
the host is what you run bazel on the

00:02:45,440 --> 00:02:49,920
target is what you're compiling for

00:02:47,760 --> 00:02:52,239
and the execution platform is what the

00:02:49,920 --> 00:02:54,560
compiler is running on

00:02:52,239 --> 00:02:56,319
these can in simple cases all be the

00:02:54,560 --> 00:02:58,080
same but they can also

00:02:56,319 --> 00:03:00,080
all be different for example on the

00:02:58,080 --> 00:03:00,959
robotics team we have five target

00:03:00,080 --> 00:03:03,680
platforms

00:03:00,959 --> 00:03:05,040
that we compile for here we have two

00:03:03,680 --> 00:03:06,959
example platforms

00:03:05,040 --> 00:03:09,440
they each list the constraints that

00:03:06,959 --> 00:03:11,280
describe that platform

00:03:09,440 --> 00:03:13,519
even though they're both linux like you

00:03:11,280 --> 00:03:14,400
can see with the add platforms os linux

00:03:13,519 --> 00:03:16,959
constraint

00:03:14,400 --> 00:03:18,239
the cpu constraint makes them different

00:03:16,959 --> 00:03:21,840
so we have a linux

00:03:18,239 --> 00:03:24,720
x86 platform and a linux arm platform

00:03:21,840 --> 00:03:26,799
and when invoking bazel you tell it you

00:03:24,720 --> 00:03:28,159
specify the host platform and the target

00:03:26,799 --> 00:03:31,280
platform so you can say

00:03:28,159 --> 00:03:32,560
i'm compiling on x86 linux and i'm

00:03:31,280 --> 00:03:35,840
compiling four

00:03:32,560 --> 00:03:36,319
arm linux you can then define a tool

00:03:35,840 --> 00:03:38,799
chain

00:03:36,319 --> 00:03:41,680
that describes what platform it can run

00:03:38,799 --> 00:03:43,519
on and what platform it can compile for

00:03:41,680 --> 00:03:46,480
and what you see here in this example is

00:03:43,519 --> 00:03:47,840
that is a tool chain that can run on x86

00:03:46,480 --> 00:03:51,440
linux and compiles

00:03:47,840 --> 00:03:54,080
for x86 linux similarly you can

00:03:51,440 --> 00:03:55,040
define a cross compiler notice here that

00:03:54,080 --> 00:03:56,640
the tool chain

00:03:55,040 --> 00:03:58,959
targets a different platform than the

00:03:56,640 --> 00:04:01,840
one it runs on so we're running we're

00:03:58,959 --> 00:04:03,280
running on x86 linux and we're targeting

00:04:01,840 --> 00:04:05,040
arm linux

00:04:03,280 --> 00:04:07,040
and really what i want you to take away

00:04:05,040 --> 00:04:07,599
here is that the platforms and tool

00:04:07,040 --> 00:04:09,840
chains

00:04:07,599 --> 00:04:11,280
use constraints to communicate about

00:04:09,840 --> 00:04:13,519
compatibility

00:04:11,280 --> 00:04:14,319
notice that we're using the constraints

00:04:13,519 --> 00:04:17,600
from the at

00:04:14,319 --> 00:04:19,600
platforms repo and again i really want

00:04:17,600 --> 00:04:21,120
to emphasize that these are the ones

00:04:19,600 --> 00:04:21,680
that you should be using in your own

00:04:21,120 --> 00:04:24,400
project

00:04:21,680 --> 00:04:26,479
don't try to redefine them on your own

00:04:24,400 --> 00:04:29,600
and there are ways that you can already

00:04:26,479 --> 00:04:31,280
use constraints to influence the build

00:04:29,600 --> 00:04:33,120
one of the workarounds for example that

00:04:31,280 --> 00:04:34,560
we have to teach the kids for slash

00:04:33,120 --> 00:04:37,759
slash dot dot building

00:04:34,560 --> 00:04:39,199
everything is to use select on the c ops

00:04:37,759 --> 00:04:41,280
and the sources

00:04:39,199 --> 00:04:43,360
and these are perfectly legitimate use

00:04:41,280 --> 00:04:44,560
cases i'm really just showing them here

00:04:43,360 --> 00:04:48,160
for

00:04:44,560 --> 00:04:48,880
completeness all right so how can we do

00:04:48,160 --> 00:04:50,880
better

00:04:48,880 --> 00:04:52,400
well let's start with a universally

00:04:50,880 --> 00:04:54,840
compatible target

00:04:52,400 --> 00:04:57,040
this binary here will compile for all

00:04:54,840 --> 00:04:59,199
platforms when you see this in a build

00:04:57,040 --> 00:05:02,720
file that's the first conclusion that

00:04:59,199 --> 00:05:02,720
you should be able to draw

00:05:02,800 --> 00:05:06,880
let's introduce the new attribute called

00:05:05,039 --> 00:05:08,800
target compatible with

00:05:06,880 --> 00:05:10,000
in this attribute you can specify

00:05:08,800 --> 00:05:12,400
constraints that the

00:05:10,000 --> 00:05:14,320
target platform must satisfy for the

00:05:12,400 --> 00:05:16,160
target to get built

00:05:14,320 --> 00:05:18,720
an empty list like the one that you see

00:05:16,160 --> 00:05:20,720
here means that there are no constraints

00:05:18,720 --> 00:05:23,280
on the target and it's therefore

00:05:20,720 --> 00:05:25,120
compatible with every platform

00:05:23,280 --> 00:05:26,960
this might be a bit awkward to interpret

00:05:25,120 --> 00:05:28,320
at first but it will make more sense

00:05:26,960 --> 00:05:30,080
once you start using it

00:05:28,320 --> 00:05:32,400
and it'll come in handy later in the

00:05:30,080 --> 00:05:34,800
slides

00:05:32,400 --> 00:05:36,320
so let's modify the example slightly

00:05:34,800 --> 00:05:39,039
here we restrict the target

00:05:36,320 --> 00:05:41,039
to the windows platform that means that

00:05:39,039 --> 00:05:43,600
bazel will skip over this target when

00:05:41,039 --> 00:05:45,680
building for say linux

00:05:43,600 --> 00:05:47,680
going back to our original motivating

00:05:45,680 --> 00:05:50,479
example with bazel test

00:05:47,680 --> 00:05:51,360
slash dot dot on the bazel repo this is

00:05:50,479 --> 00:05:53,919
what we would have

00:05:51,360 --> 00:05:56,479
wanted that windows only target to be

00:05:53,919 --> 00:05:56,479
marked with

00:05:56,880 --> 00:05:59,919
you can also get more specific as

00:05:58,720 --> 00:06:02,319
specific as you like

00:05:59,919 --> 00:06:02,960
really on the constraints so here we're

00:06:02,319 --> 00:06:06,240
saying that

00:06:02,960 --> 00:06:10,560
bin is only compatible with x86 64

00:06:06,240 --> 00:06:13,680
windows and the attribute is

00:06:10,560 --> 00:06:15,600
transitive if a target is incompatible

00:06:13,680 --> 00:06:16,639
and should be skipped then all targets

00:06:15,600 --> 00:06:19,039
that depend

00:06:16,639 --> 00:06:20,479
on it are also themselves considered

00:06:19,039 --> 00:06:23,360
incompatible

00:06:20,479 --> 00:06:24,720
for example the sh binary target here

00:06:23,360 --> 00:06:27,360
will only be built

00:06:24,720 --> 00:06:29,280
for windows on all other platforms the

00:06:27,360 --> 00:06:30,240
target will simply be skipped during the

00:06:29,280 --> 00:06:32,400
build

00:06:30,240 --> 00:06:33,280
here we have a screenshot of bazel

00:06:32,400 --> 00:06:35,919
skipping that

00:06:33,280 --> 00:06:37,759
incompatible target and you can see that

00:06:35,919 --> 00:06:39,840
we're building on linux here

00:06:37,759 --> 00:06:40,880
and that the windows only target is

00:06:39,840 --> 00:06:42,880
skipped

00:06:40,880 --> 00:06:44,800
on the other hand when you explicitly

00:06:42,880 --> 00:06:47,360
specify an incompatible target

00:06:44,800 --> 00:06:48,000
then bazel will yell at you here you see

00:06:47,360 --> 00:06:50,319
what bazel

00:06:48,000 --> 00:06:52,319
is unhappy about and tell you exactly

00:06:50,319 --> 00:06:55,039
which target is incompatible

00:06:52,319 --> 00:06:56,800
and why so it lists the constraint that

00:06:55,039 --> 00:06:58,240
was violated

00:06:56,800 --> 00:06:59,680
and while we were working on the

00:06:58,240 --> 00:07:01,520
implementation for this we actually

00:06:59,680 --> 00:07:02,000
discovered a few neat things that you

00:07:01,520 --> 00:07:03,919
can do

00:07:02,000 --> 00:07:05,919
with select statements when used

00:07:03,919 --> 00:07:07,919
together with target compatible with

00:07:05,919 --> 00:07:10,000
i'll show you one of those neat things

00:07:07,919 --> 00:07:12,400
in the next couple slides

00:07:10,000 --> 00:07:14,160
first let's create a constraint that no

00:07:12,400 --> 00:07:17,520
platform satisfies

00:07:14,160 --> 00:07:19,039
we're giving it the name not compatible

00:07:17,520 --> 00:07:20,560
the next few slides will show you why

00:07:19,039 --> 00:07:23,440
this is useful

00:07:20,560 --> 00:07:24,000
with this not compatible constraint you

00:07:23,440 --> 00:07:27,360
can use

00:07:24,000 --> 00:07:29,199
select to express or logic here we're

00:07:27,360 --> 00:07:30,160
saying that the binary is compatible

00:07:29,199 --> 00:07:34,639
with linux

00:07:30,160 --> 00:07:36,800
or mac os but not with anything else

00:07:34,639 --> 00:07:38,720
the empty lists can be interpreted to

00:07:36,800 --> 00:07:39,919
mean that no constraints need to be

00:07:38,720 --> 00:07:42,639
satisfied

00:07:39,919 --> 00:07:43,440
on linux and mac os therefore we have no

00:07:42,639 --> 00:07:45,759
constraints

00:07:43,440 --> 00:07:47,520
and the target is considered compatible

00:07:45,759 --> 00:07:50,400
it will be built

00:07:47,520 --> 00:07:51,759
on anything other than linux and mac os

00:07:50,400 --> 00:07:53,919
say windows

00:07:51,759 --> 00:07:56,000
we require that the not compatible

00:07:53,919 --> 00:07:58,960
constraint be satisfied

00:07:56,000 --> 00:08:00,080
but since no platform actually satisfies

00:07:58,960 --> 00:08:01,680
this constraint

00:08:00,080 --> 00:08:04,319
the target will be considered

00:08:01,680 --> 00:08:06,240
incompatible and will thus be skipped

00:08:04,319 --> 00:08:07,599
on all platforms other than the nixon

00:08:06,240 --> 00:08:10,720
mac os so

00:08:07,599 --> 00:08:12,560
on windows bazel will skip this target

00:08:10,720 --> 00:08:16,000
when building with slash slash

00:08:12,560 --> 00:08:17,840
dot dot you can also invert

00:08:16,000 --> 00:08:19,759
the compatibility by switching the

00:08:17,840 --> 00:08:22,479
results of the select

00:08:19,759 --> 00:08:23,039
so on linux and mac os this new target

00:08:22,479 --> 00:08:25,919
is

00:08:23,039 --> 00:08:27,520
not compatible an all plot on all other

00:08:25,919 --> 00:08:30,800
platforms the target is

00:08:27,520 --> 00:08:32,080
compatible theoretically anything that

00:08:30,800 --> 00:08:34,800
you can select on

00:08:32,080 --> 00:08:36,320
can be used to express compatibility and

00:08:34,800 --> 00:08:38,719
that is definitely something we're

00:08:36,320 --> 00:08:40,959
thinking about a lot

00:08:38,719 --> 00:08:43,200
again this is available to you at bazel

00:08:40,959 --> 00:08:44,640
head and we really hope that this is

00:08:43,200 --> 00:08:46,880
useful to you guys and

00:08:44,640 --> 00:08:50,320
we'd love to hear your feedback on this

00:08:46,880 --> 00:08:50,320
and of course bug reports

00:08:50,880 --> 00:08:55,040
and now i'll hand it off to austin

00:08:52,560 --> 00:08:58,160
who'll expand on these concepts

00:08:55,040 --> 00:08:59,920
thank you okay thank you phil so let's

00:08:58,160 --> 00:09:01,360
go over what goes into a platform

00:08:59,920 --> 00:09:03,279
so these should be properties of the

00:09:01,360 --> 00:09:03,920
physical machine this is things like the

00:09:03,279 --> 00:09:06,000
cpu

00:09:03,920 --> 00:09:07,920
or the operating system or the glibe c

00:09:06,000 --> 00:09:08,320
version these really tell you kind of

00:09:07,920 --> 00:09:09,680
what

00:09:08,320 --> 00:09:12,080
software is going to be able to run on

00:09:09,680 --> 00:09:13,279
the machine cpu both like which

00:09:12,080 --> 00:09:14,640
instruction set

00:09:13,279 --> 00:09:17,120
operating system will tell you kind of

00:09:14,640 --> 00:09:17,519
which is which disk calls and glibc is

00:09:17,120 --> 00:09:19,600
going to

00:09:17,519 --> 00:09:21,360
help you with a lot of the compatibility

00:09:19,600 --> 00:09:23,279
these are not properties of build

00:09:21,360 --> 00:09:25,600
so things like clang and gcc those two

00:09:23,279 --> 00:09:28,560
compilers they will target most major

00:09:25,600 --> 00:09:30,000
systems it is not a property of the

00:09:28,560 --> 00:09:31,120
target whether or not it will work with

00:09:30,000 --> 00:09:33,760
clang or gcc

00:09:31,120 --> 00:09:35,600
and the same goes with versions clang in

00:09:33,760 --> 00:09:36,000
gcc the version shouldn't really matter

00:09:35,600 --> 00:09:37,680
especially

00:09:36,000 --> 00:09:39,440
in more modern versions for most

00:09:37,680 --> 00:09:41,360
platforms

00:09:39,440 --> 00:09:43,040
so let's go through another example so

00:09:41,360 --> 00:09:45,360
say we want to use protobuf and c

00:09:43,040 --> 00:09:46,640
plus well let's say it's on an embedded

00:09:45,360 --> 00:09:48,320
system

00:09:46,640 --> 00:09:50,240
these will typically require a custom

00:09:48,320 --> 00:09:51,360
compiler so there's gonna be a little

00:09:50,240 --> 00:09:53,839
bit more setup there

00:09:51,360 --> 00:09:54,480
or maybe on windows we just want it to

00:09:53,839 --> 00:09:56,320
work

00:09:54,480 --> 00:09:57,600
well this is probably gonna require some

00:09:56,320 --> 00:09:59,279
custom flags

00:09:57,600 --> 00:10:00,959
for each of those targets to make

00:09:59,279 --> 00:10:02,240
everything work correctly

00:10:00,959 --> 00:10:04,160
so let's look at some examples from

00:10:02,240 --> 00:10:06,560
protobuf this is on

00:10:04,160 --> 00:10:07,440
master so here we can see there's a

00:10:06,560 --> 00:10:09,680
select statement

00:10:07,440 --> 00:10:11,200
for setting the c ops so in the

00:10:09,680 --> 00:10:13,920
microsoft compiler here

00:10:11,200 --> 00:10:15,519
we're picking one set of flags whereas

00:10:13,920 --> 00:10:16,880
for the rest of the systems we have a

00:10:15,519 --> 00:10:18,480
different set of flags

00:10:16,880 --> 00:10:21,279
i'm looking at these flags this looks

00:10:18,480 --> 00:10:23,120
like it's mostly post-6 flags

00:10:21,279 --> 00:10:24,480
and if we go into another example here

00:10:23,120 --> 00:10:26,480
we're looking at link options

00:10:24,480 --> 00:10:28,240
so here we're saying android none of

00:10:26,480 --> 00:10:29,120
these three variants needs any extra

00:10:28,240 --> 00:10:30,880
flags

00:10:29,120 --> 00:10:32,240
but that microsoft compiler again it

00:10:30,880 --> 00:10:34,160
needs a certain set

00:10:32,240 --> 00:10:37,600
and then the rest of the systems need an

00:10:34,160 --> 00:10:40,079
even different set of flags

00:10:37,600 --> 00:10:40,640
so if we look into how that works this

00:10:40,079 --> 00:10:42,320
isn't

00:10:40,640 --> 00:10:44,399
stellar so here we're going and we're

00:10:42,320 --> 00:10:44,880
saying if the crosstool top flag has

00:10:44,399 --> 00:10:47,920
been

00:10:44,880 --> 00:10:50,320
specified as android ntk

00:10:47,920 --> 00:10:51,920
that string then we must be running on

00:10:50,320 --> 00:10:54,399
this type of android

00:10:51,920 --> 00:10:56,000
otherwise if the crosstalk top is set to

00:10:54,399 --> 00:10:57,360
this other magical string

00:10:56,000 --> 00:10:59,600
then that means we're running on this

00:10:57,360 --> 00:11:00,000
other version of android so there's a

00:10:59,600 --> 00:11:02,240
little

00:11:00,000 --> 00:11:04,079
too much magic strings here floating

00:11:02,240 --> 00:11:05,360
around and this is not really going to

00:11:04,079 --> 00:11:08,480
scale up to a bunch of

00:11:05,360 --> 00:11:10,800
bunch of different systems so if we look

00:11:08,480 --> 00:11:12,959
at a grpc example here

00:11:10,800 --> 00:11:14,079
this is a test case that does not work

00:11:12,959 --> 00:11:16,880
on ios

00:11:14,079 --> 00:11:18,560
it does not work on windows and here's a

00:11:16,880 --> 00:11:20,560
new concept here that we haven't

00:11:18,560 --> 00:11:21,680
haven't introduced so far it does not

00:11:20,560 --> 00:11:23,440
work with msan

00:11:21,680 --> 00:11:25,200
so msan is this property of how our

00:11:23,440 --> 00:11:27,120
compiler is configured

00:11:25,200 --> 00:11:28,640
and we're saying that this test doesn't

00:11:27,120 --> 00:11:29,760
really work when it's configured that

00:11:28,640 --> 00:11:31,839
way

00:11:29,760 --> 00:11:33,760
so what do we really want as a user well

00:11:31,839 --> 00:11:36,320
i just want protobuf to work

00:11:33,760 --> 00:11:38,240
i don't think about any of this and if i

00:11:36,320 --> 00:11:40,480
am forced to think about it so say

00:11:38,240 --> 00:11:41,600
i find an issue or find a flag i need to

00:11:40,480 --> 00:11:43,519
make my build work

00:11:41,600 --> 00:11:45,120
i want to be able to take that flag and

00:11:43,519 --> 00:11:46,800
i want to be able to upstream it

00:11:45,120 --> 00:11:48,160
and send it up to protobuf so that i

00:11:46,800 --> 00:11:49,600
don't have to do it again

00:11:48,160 --> 00:11:51,519
and that means i need to do it in a way

00:11:49,600 --> 00:11:52,880
that's reasonably robust and will work

00:11:51,519 --> 00:11:54,079
for other people and not break other

00:11:52,880 --> 00:11:56,079
people's build

00:11:54,079 --> 00:11:57,120
so what's building a library look like

00:11:56,079 --> 00:11:58,560
in bazel well

00:11:57,120 --> 00:12:00,639
we start with bazel we're going to

00:11:58,560 --> 00:12:01,920
specify a bunch of flags this is things

00:12:00,639 --> 00:12:04,320
like compiler

00:12:01,920 --> 00:12:06,240
options potentially even cross tools top

00:12:04,320 --> 00:12:08,399
that we saw above

00:12:06,240 --> 00:12:10,959
all sorts of things we're going to

00:12:08,399 --> 00:12:13,519
specify a tool chain so we can

00:12:10,959 --> 00:12:14,320
register various different c or c plus

00:12:13,519 --> 00:12:16,880
compilers

00:12:14,320 --> 00:12:18,639
go compilers all sorts of things there

00:12:16,880 --> 00:12:20,880
we're going to tell bazel a platform

00:12:18,639 --> 00:12:22,560
that we're trying to target

00:12:20,880 --> 00:12:25,040
this tells it like what we're building

00:12:22,560 --> 00:12:27,440
for are we building for our robot here

00:12:25,040 --> 00:12:29,440
or are we trying to build for you know

00:12:27,440 --> 00:12:32,079
the the hardware that bazel is running

00:12:29,440 --> 00:12:33,839
on or some other piece of hardware

00:12:32,079 --> 00:12:35,440
so then from there tool chain selection

00:12:33,839 --> 00:12:37,360
is going to happen so that's where bazel

00:12:35,440 --> 00:12:38,959
takes all that information into account

00:12:37,360 --> 00:12:41,040
and tries to figure out exactly which

00:12:38,959 --> 00:12:42,399
compiler we want to use

00:12:41,040 --> 00:12:44,079
from there it's going to produce a cc

00:12:42,399 --> 00:12:45,680
toolchain info so this contains all the

00:12:44,079 --> 00:12:48,800
information about our compiler

00:12:45,680 --> 00:12:50,320
to tell us exactly how to do that build

00:12:48,800 --> 00:12:52,399
and then that's used to really configure

00:12:50,320 --> 00:12:53,920
the graph here so protobuf we're going

00:12:52,399 --> 00:12:56,079
to change the select statements

00:12:53,920 --> 00:12:58,000
and change how it's built and generate

00:12:56,079 --> 00:12:59,600
the build commands for that

00:12:58,000 --> 00:13:01,279
and then if we go down and we're

00:12:59,600 --> 00:13:02,000
building our now binary that depends on

00:13:01,279 --> 00:13:03,839
protobuf

00:13:02,000 --> 00:13:05,279
that's going to be configured the same

00:13:03,839 --> 00:13:07,120
way so

00:13:05,279 --> 00:13:08,880
there's a small asterisk here the arrow

00:13:07,120 --> 00:13:10,240
is not always quite that simple there's

00:13:08,880 --> 00:13:11,519
some cases where it will

00:13:10,240 --> 00:13:12,880
a slightly different behavior will

00:13:11,519 --> 00:13:14,240
happen but this is a useful enough

00:13:12,880 --> 00:13:15,600
approximation that

00:13:14,240 --> 00:13:18,320
it's really you can think about it this

00:13:15,600 --> 00:13:19,600
way and really those approximations for

00:13:18,320 --> 00:13:21,920
that fails that will make this

00:13:19,600 --> 00:13:24,639
discussion even more relevant

00:13:21,920 --> 00:13:25,600
so uh what can change well user can come

00:13:24,639 --> 00:13:28,160
with a bunch of custom

00:13:25,600 --> 00:13:29,760
compilers with embedded systems and c

00:13:28,160 --> 00:13:30,480
and c plus plus compilers this is quite

00:13:29,760 --> 00:13:32,560
common

00:13:30,480 --> 00:13:34,320
most embedded systems will come with a c

00:13:32,560 --> 00:13:37,519
plus compiler that's been

00:13:34,320 --> 00:13:38,800
configured to work for them users will

00:13:37,519 --> 00:13:39,519
also want to build for many different

00:13:38,800 --> 00:13:41,199
platforms

00:13:39,519 --> 00:13:42,480
especially in embedded worlds where you

00:13:41,199 --> 00:13:45,360
have a bunch of different targets

00:13:42,480 --> 00:13:47,279
sometimes multiple of them in a build

00:13:45,360 --> 00:13:49,199
and then the user is going to really

00:13:47,279 --> 00:13:51,760
select a bunch of different flags

00:13:49,199 --> 00:13:52,959
and change how bazel is configured and

00:13:51,760 --> 00:13:55,120
that's really going to influence

00:13:52,959 --> 00:13:56,959
tool chain selection and with all the

00:13:55,120 --> 00:13:58,480
number of inputs here it is really not

00:13:56,959 --> 00:14:00,000
reasonable to be able to reproduce the

00:13:58,480 --> 00:14:01,760
logic inside tool chain selection

00:14:00,000 --> 00:14:04,639
downstream

00:14:01,760 --> 00:14:05,120
so the user can or the library writer

00:14:04,639 --> 00:14:07,760
here

00:14:05,120 --> 00:14:08,959
so this is someone like protobuf they're

00:14:07,760 --> 00:14:10,560
not going to be able to know

00:14:08,959 --> 00:14:13,040
all of the various users of their

00:14:10,560 --> 00:14:14,800
library so it is not reasonable for

00:14:13,040 --> 00:14:16,480
protobuf to know everybody using it

00:14:14,800 --> 00:14:18,399
and so that's that's going to make it

00:14:16,480 --> 00:14:19,920
hard on them

00:14:18,399 --> 00:14:22,160
and really in the end we want this to

00:14:19,920 --> 00:14:23,360
not be brittle we want to be able to

00:14:22,160 --> 00:14:24,800
change things in this and have

00:14:23,360 --> 00:14:26,000
everything continue to work reasonably

00:14:24,800 --> 00:14:27,519
reliably

00:14:26,000 --> 00:14:29,199
so this means we need reasonable

00:14:27,519 --> 00:14:31,680
interfaces we need to be able to

00:14:29,199 --> 00:14:34,000
describe how information is communicated

00:14:31,680 --> 00:14:35,120
so um i will argue that our interfaces

00:14:34,000 --> 00:14:37,040
here are the platform

00:14:35,120 --> 00:14:38,639
this really is talking about the the

00:14:37,040 --> 00:14:40,560
physical aspects of the target

00:14:38,639 --> 00:14:43,839
and then also the compiler as we've seen

00:14:40,560 --> 00:14:45,440
that's useful for configuring our graph

00:14:43,839 --> 00:14:46,800
and that means that these fields

00:14:45,440 --> 00:14:48,000
in the tool chain become part of our

00:14:46,800 --> 00:14:48,880
interface and that means there's a

00:14:48,000 --> 00:14:50,000
contract

00:14:48,880 --> 00:14:52,079
where there's an interface there's a

00:14:50,000 --> 00:14:52,800
contract so we need to agree on what

00:14:52,079 --> 00:14:56,160
fields there

00:14:52,800 --> 00:14:58,000
are public and private and also

00:14:56,160 --> 00:14:59,839
what the various values are so if we're

00:14:58,000 --> 00:15:02,160
trying to figure out if something's gcc

00:14:59,839 --> 00:15:04,000
and we spell it two different ways gcc

00:15:02,160 --> 00:15:05,360
or gcc

00:15:04,000 --> 00:15:06,959
that's not going to be very good for the

00:15:05,360 --> 00:15:08,079
software downstream if we don't have a

00:15:06,959 --> 00:15:09,920
good contract there

00:15:08,079 --> 00:15:11,360
so we really need to agree both as the

00:15:09,920 --> 00:15:12,959
people defining the tool chain in the

00:15:11,360 --> 00:15:16,160
community what's useful

00:15:12,959 --> 00:15:17,120
and make sure that's captured is this

00:15:16,160 --> 00:15:19,360
enough

00:15:17,120 --> 00:15:21,120
well things like the compiler name

00:15:19,360 --> 00:15:25,199
various settings

00:15:21,120 --> 00:15:26,959
the configurations for it msan ubsan

00:15:25,199 --> 00:15:28,399
all those various types of things those

00:15:26,959 --> 00:15:29,920
can come through the tool chain

00:15:28,399 --> 00:15:32,160
that's a very natural place to put those

00:15:29,920 --> 00:15:33,920
type of properties and then

00:15:32,160 --> 00:15:36,399
things like our target architecture so

00:15:33,920 --> 00:15:38,399
like what target we're targeting

00:15:36,399 --> 00:15:39,440
those can come through the platform it's

00:15:38,399 --> 00:15:41,600
a good fit for those

00:15:39,440 --> 00:15:42,720
so let's revisit our grpc example from

00:15:41,600 --> 00:15:44,800
before

00:15:42,720 --> 00:15:46,079
so we can take the windows and ios

00:15:44,800 --> 00:15:47,839
constraints where we were saying that

00:15:46,079 --> 00:15:49,120
the test did not work on those platforms

00:15:47,839 --> 00:15:50,480
and we can put that in the target

00:15:49,120 --> 00:15:52,079
compatible with

00:15:50,480 --> 00:15:53,839
so that's pretty awesome got that part

00:15:52,079 --> 00:15:55,680
solved and now we're left really with

00:15:53,839 --> 00:15:57,440
the no msan part

00:15:55,680 --> 00:15:59,040
so that's really a property of the tool

00:15:57,440 --> 00:16:01,839
chain and a property of how the

00:15:59,040 --> 00:16:02,800
compiler is configured so how do we

00:16:01,839 --> 00:16:04,720
represent that

00:16:02,800 --> 00:16:06,800
if we look here we can actually pull the

00:16:04,720 --> 00:16:09,360
compiler field out of the tool chain

00:16:06,800 --> 00:16:11,519
we can place it in a feature flag info

00:16:09,360 --> 00:16:13,440
and return that

00:16:11,519 --> 00:16:15,759
we're pulling that out of the cc tool

00:16:13,440 --> 00:16:17,680
chain you can see that down below

00:16:15,759 --> 00:16:20,240
and then how can we use that well here

00:16:17,680 --> 00:16:22,079
we can pass that into a config setting

00:16:20,240 --> 00:16:24,800
and we can detect when the compiler is

00:16:22,079 --> 00:16:26,560
gcc and use that to configure behavior

00:16:24,800 --> 00:16:29,600
so at the bottom here we're able to take

00:16:26,560 --> 00:16:31,680
is gcc and specify a different flag than

00:16:29,600 --> 00:16:34,000
when it is not gcc

00:16:31,680 --> 00:16:35,759
so that's pretty cool how can we apply

00:16:34,000 --> 00:16:37,440
it here well we can actually add it in

00:16:35,759 --> 00:16:38,959
with skipping so we can use the trick

00:16:37,440 --> 00:16:41,360
that phil showed before

00:16:38,959 --> 00:16:42,079
and say that if it is gcc then there is

00:16:41,360 --> 00:16:43,680
nothing

00:16:42,079 --> 00:16:45,440
so that means it's compatible with

00:16:43,680 --> 00:16:47,040
otherwise it's not compatible

00:16:45,440 --> 00:16:50,160
so this makes a target that only works

00:16:47,040 --> 00:16:51,839
on gcc so this doesn't fully solve our

00:16:50,160 --> 00:16:54,399
msan case

00:16:51,839 --> 00:16:56,160
we still need to be able to pass the

00:16:54,399 --> 00:16:59,279
settings in there to try and conf

00:16:56,160 --> 00:17:01,199
to try and detect if we're on a compiler

00:16:59,279 --> 00:17:02,720
configured for msn or not

00:17:01,199 --> 00:17:04,640
but this really gives us the tools to

00:17:02,720 --> 00:17:06,160
build that up we can pass

00:17:04,640 --> 00:17:07,919
specify that information through the

00:17:06,160 --> 00:17:10,079
same routes so

00:17:07,919 --> 00:17:11,199
where did we start before this well we

00:17:10,079 --> 00:17:12,880
started with inconsistent

00:17:11,199 --> 00:17:14,640
representations of the platforms and

00:17:12,880 --> 00:17:16,559
constraints

00:17:14,640 --> 00:17:19,199
we're able to configure our build with

00:17:16,559 --> 00:17:21,760
select based on the platform

00:17:19,199 --> 00:17:23,439
we're able to do some limited stuff with

00:17:21,760 --> 00:17:24,799
selecting based on the tool chain but

00:17:23,439 --> 00:17:26,400
really that was not being thought of as

00:17:24,799 --> 00:17:29,760
a strong interface

00:17:26,400 --> 00:17:31,679
and now we have added in skipping so we

00:17:29,760 --> 00:17:33,280
can now skip based on the platform and

00:17:31,679 --> 00:17:34,640
there are also tricks so we can skip

00:17:33,280 --> 00:17:36,400
based on the tool chain depending on

00:17:34,640 --> 00:17:37,760
which compilers are selected

00:17:36,400 --> 00:17:40,480
and really have introduced the tool

00:17:37,760 --> 00:17:42,640
chain as a stronger interface to discuss

00:17:40,480 --> 00:17:43,600
and our hope is this is enough to make

00:17:42,640 --> 00:17:45,760
bazel test

00:17:43,600 --> 00:17:47,520
slash dot dot dot work again on the most

00:17:45,760 --> 00:17:49,440
tricky projects

00:17:47,520 --> 00:17:50,720
so thank you all for coming and joining

00:17:49,440 --> 00:17:52,320
us with this talk

00:17:50,720 --> 00:17:54,080
i'd like to thank phil for presenting

00:17:52,320 --> 00:17:57,320
the first half and for greg for all his

00:17:54,080 --> 00:17:58,840
advice and help when implementing this

00:17:57,320 --> 00:18:01,840
[Music]

00:17:58,840 --> 00:18:01,840
feature

00:18:06,080 --> 00:18:08,160

YouTube URL: https://www.youtube.com/watch?v=01BHJT7GL9o


