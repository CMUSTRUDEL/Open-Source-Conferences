Title: Grazel - A Gradle plugin to automate Bazel migration for Android projects
Publication date: 2020-11-11
Playlist: BazelCon 2020
Description: 
	Grab's Android Passenger app is a Super App with hundreds of modules owned by different teams serving millions of users every day. As our multi-module project continued to grow at a healthy pace, we experienced linear growth in build times and decided to switch to Bazel to take advantage of strong caching and parallel execution capabilities. 
To reduce the migration effort and avoid impact on feature delivery, we took a programmatic approach and built Grazel (Gradle + Bazel), a Gradle plugin that can generate equivalent Bazel build rules from Gradle scripts for a given Android project. Grazel is also capable of performing hybrid builds where certain modules are built with Bazel while non migrated modules are built with Gradle. In this talk, we discuss the architecture and design decisions we took to build the plugin.

Speaker: Arunkumar Sampathkumar

Watch more:
BazelCon 2020 playlist → http://goo.gle/BazelCon2020

Subscribe to Google Open Source → http://goo.gle/GOpenSource

#bazelcon #bazel event: Bazelcon 2020; re_ty: Publish; product: Open Source - General; fullname: Arunkumar Sampathkumar;
Captions: 
	00:00:01,040 --> 00:00:06,640
[Music]

00:00:06,080 --> 00:00:08,400
hello

00:00:06,640 --> 00:00:10,320
i'm arun kumar an android software

00:00:08,400 --> 00:00:11,360
engineer working on the appcore team at

00:00:10,320 --> 00:00:14,160
grab

00:00:11,360 --> 00:00:15,839
today i am here to talk about grazel a

00:00:14,160 --> 00:00:16,240
gradle plugin we have developed our

00:00:15,839 --> 00:00:18,160
graph

00:00:16,240 --> 00:00:20,400
to assist with our consumer android

00:00:18,160 --> 00:00:21,600
applications migration to bazel build

00:00:20,400 --> 00:00:23,279
system

00:00:21,600 --> 00:00:24,960
grab initially started as a right

00:00:23,279 --> 00:00:26,800
healing app but since then

00:00:24,960 --> 00:00:28,080
it has grown to support different

00:00:26,800 --> 00:00:30,880
services like

00:00:28,080 --> 00:00:32,640
food and payments in different markets

00:00:30,880 --> 00:00:36,800
primarily in southeast asia

00:00:32,640 --> 00:00:39,280
and we serve millions of users every day

00:00:36,800 --> 00:00:40,239
our consumer android application is a

00:00:39,280 --> 00:00:42,559
super app

00:00:40,239 --> 00:00:44,000
providing entry points to different

00:00:42,559 --> 00:00:47,840
services owned by different

00:00:44,000 --> 00:00:48,960
tech families it is a highly modular

00:00:47,840 --> 00:00:52,160
application

00:00:48,960 --> 00:00:54,160
currently on gradle build system and has

00:00:52,160 --> 00:00:55,840
hundreds of modules and has

00:00:54,160 --> 00:00:59,199
contributions from hundreds of

00:00:55,840 --> 00:01:01,359
engineers every day

00:00:59,199 --> 00:01:03,600
we liked bazel's strong caching and

00:01:01,359 --> 00:01:06,240
parallel execution capabilities

00:01:03,600 --> 00:01:07,360
and believed that we could benefit from

00:01:06,240 --> 00:01:10,240
better build times

00:01:07,360 --> 00:01:13,840
by migrating to bazel as our code base

00:01:10,240 --> 00:01:13,840
grew at a healthy pace

00:01:14,080 --> 00:01:19,119
but having such a large code base poses

00:01:16,479 --> 00:01:21,200
a number of challenges

00:01:19,119 --> 00:01:23,520
as it stands today we might not have

00:01:21,200 --> 00:01:26,479
one-on-one feature parity between gradle

00:01:23,520 --> 00:01:28,240
and bazel

00:01:26,479 --> 00:01:30,159
on the gradle side we have android

00:01:28,240 --> 00:01:33,200
gradle plugin to compile

00:01:30,159 --> 00:01:36,880
android projects and similarly we have

00:01:33,200 --> 00:01:36,880
native build rules in bazel

00:01:37,439 --> 00:01:40,960
so when we use an exclusive build system

00:01:40,159 --> 00:01:43,600
feature

00:01:40,960 --> 00:01:45,200
we might need to spend additional time

00:01:43,600 --> 00:01:47,360
refactoring the code base

00:01:45,200 --> 00:01:50,079
to make it compatible with both the

00:01:47,360 --> 00:01:50,079
build systems

00:01:50,799 --> 00:01:55,280
for example build config fields in

00:01:53,520 --> 00:01:58,000
android gradle plugin

00:01:55,280 --> 00:01:59,280
provide a neat way to inject values into

00:01:58,000 --> 00:02:01,600
the runtime

00:01:59,280 --> 00:02:04,640
and this is not something present out of

00:02:01,600 --> 00:02:04,640
the box in bazel

00:02:04,960 --> 00:02:08,640
however it can be easily achieved with a

00:02:07,360 --> 00:02:11,440
custom macro

00:02:08,640 --> 00:02:11,440
that we can build

00:02:11,920 --> 00:02:14,959
so when we talk about such refactoring

00:02:14,160 --> 00:02:18,000
tasks

00:02:14,959 --> 00:02:18,959
naturally this takes effort from feature

00:02:18,000 --> 00:02:21,599
development

00:02:18,959 --> 00:02:22,080
and there was a push back from engineers

00:02:21,599 --> 00:02:24,080
because

00:02:22,080 --> 00:02:26,959
this effort could be instant spent on

00:02:24,080 --> 00:02:26,959
feature development

00:02:27,760 --> 00:02:32,879
apart from such refactors writing equal

00:02:31,360 --> 00:02:36,239
and bazel bill scripts

00:02:32,879 --> 00:02:37,360
is a manual task and as per our internal

00:02:36,239 --> 00:02:39,360
estimations

00:02:37,360 --> 00:02:41,200
we required considerable effort to

00:02:39,360 --> 00:02:43,280
migrate the project

00:02:41,200 --> 00:02:45,210
considering all these challenges we had

00:02:43,280 --> 00:02:46,879
a couple of goals for the migration

00:02:45,210 --> 00:02:49,519
[Music]

00:02:46,879 --> 00:02:50,640
while for a simple application it might

00:02:49,519 --> 00:02:52,879
be possible

00:02:50,640 --> 00:02:54,239
to migrate the entire application in a

00:02:52,879 --> 00:02:56,959
couple of days

00:02:54,239 --> 00:02:57,519
but given the large code base such as

00:02:56,959 --> 00:03:00,879
ours

00:02:57,519 --> 00:03:02,879
and the blockers we just discussed above

00:03:00,879 --> 00:03:05,440
this is not something that is easily

00:03:02,879 --> 00:03:07,840
possible for us

00:03:05,440 --> 00:03:09,920
so we wanted this migration to be

00:03:07,840 --> 00:03:12,640
incremental

00:03:09,920 --> 00:03:13,120
by incremental we mean that we are able

00:03:12,640 --> 00:03:15,680
to

00:03:13,120 --> 00:03:17,120
gradually migrate the project and look

00:03:15,680 --> 00:03:19,680
into resolving

00:03:17,120 --> 00:03:21,920
blockers discussed previously along the

00:03:19,680 --> 00:03:21,920
way

00:03:22,400 --> 00:03:26,080
the main reason for this is that it can

00:03:25,280 --> 00:03:28,959
happen

00:03:26,080 --> 00:03:30,560
parallel to feature development and this

00:03:28,959 --> 00:03:34,239
need not be a blocker

00:03:30,560 --> 00:03:37,440
and can be done like any other pr

00:03:34,239 --> 00:03:40,560
to the main branch that we have

00:03:37,440 --> 00:03:43,680
this way we can also ensure that we can

00:03:40,560 --> 00:03:46,799
establish strong feedback loops

00:03:43,680 --> 00:03:50,159
and such as having parallel ca bills

00:03:46,799 --> 00:03:51,680
on the main branch on pr and also we

00:03:50,159 --> 00:03:55,680
could look into building

00:03:51,680 --> 00:03:59,200
dashboards etc to help with these goals

00:03:55,680 --> 00:04:01,840
we built grazel grazel stands for

00:03:59,200 --> 00:04:04,560
gradle to bazel today i am really

00:04:01,840 --> 00:04:06,640
excited to talk about the architecture

00:04:04,560 --> 00:04:08,239
the functionality the design decisions

00:04:06,640 --> 00:04:12,319
we took to build the plugin

00:04:08,239 --> 00:04:14,000
and how it has helped grab so far

00:04:12,319 --> 00:04:16,639
grazel is the core of our migration

00:04:14,000 --> 00:04:17,440
strategy and helps us in reducing the

00:04:16,639 --> 00:04:20,720
overall

00:04:17,440 --> 00:04:22,639
migration effort in a variety of ways

00:04:20,720 --> 00:04:24,880
firstly it allows us to take a

00:04:22,639 --> 00:04:27,120
programmatic approach to migration

00:04:24,880 --> 00:04:28,000
where majority of manual and repetitive

00:04:27,120 --> 00:04:31,919
work can be

00:04:28,000 --> 00:04:34,080
automated it allows us to keep

00:04:31,919 --> 00:04:35,280
gradle scripts as a source of truth for

00:04:34,080 --> 00:04:37,680
build scripts

00:04:35,280 --> 00:04:39,360
thereby reducing the maintenance effort

00:04:37,680 --> 00:04:43,600
when we have multiple

00:04:39,360 --> 00:04:44,560
build scripts at its core it is a gradle

00:04:43,600 --> 00:04:46,960
plugin

00:04:44,560 --> 00:04:49,759
that works on any android kotlin or a

00:04:46,960 --> 00:04:49,759
java code base

00:04:50,240 --> 00:04:54,800
when applied to a project it registers

00:04:52,880 --> 00:04:59,520
few tasks that can generate

00:04:54,800 --> 00:05:01,840
valid build.bazel and workspace files

00:04:59,520 --> 00:05:04,240
and finally it adds incremental

00:05:01,840 --> 00:05:05,919
migration capabilities to the project

00:05:04,240 --> 00:05:07,440
which we will discuss later in the

00:05:05,919 --> 00:05:11,840
presentation

00:05:07,440 --> 00:05:11,840
now let's see how the plugin can be used

00:05:12,160 --> 00:05:16,240
in the rootbuild.gradle file we can

00:05:14,720 --> 00:05:18,080
apply the plugin with the given

00:05:16,240 --> 00:05:20,639
coordinates

00:05:18,080 --> 00:05:22,840
and then configure grazel with a couple

00:05:20,639 --> 00:05:26,000
of things like rules version

00:05:22,840 --> 00:05:28,320
etc doing so will add

00:05:26,000 --> 00:05:29,440
couple of tasks to the project such as

00:05:28,320 --> 00:05:32,639
migrator bazel

00:05:29,440 --> 00:05:34,080
and format bazel files now let's take a

00:05:32,639 --> 00:05:36,639
quick demo on

00:05:34,080 --> 00:05:40,560
google's topeka sample application which

00:05:36,639 --> 00:05:43,039
is a kotlin based multimodule project

00:05:40,560 --> 00:05:44,240
firstly running migrate to bazel task

00:05:43,039 --> 00:05:46,880
would generate

00:05:44,240 --> 00:05:48,000
all bazel build scripts and then we can

00:05:46,880 --> 00:05:50,639
even run the app

00:05:48,000 --> 00:05:51,600
using bazel mobile install which is a

00:05:50,639 --> 00:05:54,880
neat way to run

00:05:51,600 --> 00:05:56,800
incremental bills here in the generated

00:05:54,880 --> 00:05:59,919
bill script for quiz module

00:05:56,800 --> 00:06:02,240
we can see that grazel is able to infer

00:05:59,919 --> 00:06:03,440
various things like package names cotton

00:06:02,240 --> 00:06:06,960
in library

00:06:03,440 --> 00:06:08,880
and dependencies the same goes for other

00:06:06,960 --> 00:06:12,000
modules as well

00:06:08,880 --> 00:06:14,319
while this works for simple applications

00:06:12,000 --> 00:06:16,080
what about unsupported android gradle

00:06:14,319 --> 00:06:18,560
plugin features

00:06:16,080 --> 00:06:20,080
that might require refactoring our

00:06:18,560 --> 00:06:23,280
solutions to this problem

00:06:20,080 --> 00:06:23,840
is what we call hybrid bills hybrid

00:06:23,280 --> 00:06:26,240
bills

00:06:23,840 --> 00:06:27,840
works on the premise that a large

00:06:26,240 --> 00:06:30,720
project's model dependency

00:06:27,840 --> 00:06:31,919
graph can contain a variety of modules

00:06:30,720 --> 00:06:34,160
ranging from

00:06:31,919 --> 00:06:36,960
simple java or kotlin library to

00:06:34,160 --> 00:06:39,600
advanced android libraries

00:06:36,960 --> 00:06:42,720
among these modules some simple modules

00:06:39,600 --> 00:06:44,960
can be safely migrated to bazel

00:06:42,720 --> 00:06:45,919
grazel can scan the dependency graph of

00:06:44,960 --> 00:06:48,479
a project

00:06:45,919 --> 00:06:50,560
and find such modules by performing a

00:06:48,479 --> 00:06:53,039
compatibility check

00:06:50,560 --> 00:06:55,039
and then generates bazel build scripts

00:06:53,039 --> 00:06:57,680
for them

00:06:55,039 --> 00:06:59,840
once bill scripts are generated these

00:06:57,680 --> 00:07:02,080
modules can be built with bazel

00:06:59,840 --> 00:07:04,560
while rest of the unmigrated modules can

00:07:02,080 --> 00:07:07,440
be built with gradle

00:07:04,560 --> 00:07:09,840
now let's see how this can be achieved

00:07:07,440 --> 00:07:11,599
similar to bazel's loading analysis and

00:07:09,840 --> 00:07:15,039
execution phases

00:07:11,599 --> 00:07:17,120
gradle has three distinct faces

00:07:15,039 --> 00:07:19,440
initialization configuration and

00:07:17,120 --> 00:07:22,240
execution phases

00:07:19,440 --> 00:07:24,319
configuration phase is where the gradle

00:07:22,240 --> 00:07:26,479
execution plan is constructed

00:07:24,319 --> 00:07:29,120
and naturally grazel hooks into the

00:07:26,479 --> 00:07:31,199
configuration phase

00:07:29,120 --> 00:07:33,360
and since gradle allows untracked

00:07:31,199 --> 00:07:34,639
arbitrary i o during the configuration

00:07:33,360 --> 00:07:37,199
phase

00:07:34,639 --> 00:07:38,560
grazel does bazel build on all the

00:07:37,199 --> 00:07:40,880
migrated targets

00:07:38,560 --> 00:07:41,919
thereby generating corresponding build

00:07:40,880 --> 00:07:45,840
artifacts like

00:07:41,919 --> 00:07:45,840
aar file or a jar file

00:07:46,160 --> 00:07:50,400
then it does something we call

00:07:48,000 --> 00:07:52,319
dependency substitution

00:07:50,400 --> 00:07:54,840
for example if a quiz module was

00:07:52,319 --> 00:07:57,840
migrated it would either produce

00:07:54,840 --> 00:08:01,599
quiz.air or a quiz.jar file

00:07:57,840 --> 00:08:03,360
when built when a project dependency in

00:08:01,599 --> 00:08:05,440
gradle is resolved

00:08:03,360 --> 00:08:06,560
we check whether a build artifact

00:08:05,440 --> 00:08:10,160
already exists

00:08:06,560 --> 00:08:11,199
for the project if not we leave it as it

00:08:10,160 --> 00:08:13,759
is

00:08:11,199 --> 00:08:15,280
however if we do have a build artifact

00:08:13,759 --> 00:08:17,599
for the project

00:08:15,280 --> 00:08:19,120
we remove the project dependency and

00:08:17,599 --> 00:08:22,319
then replace them with

00:08:19,120 --> 00:08:24,639
already compiled artifacts

00:08:22,319 --> 00:08:26,400
grazel does this on the entire project

00:08:24,639 --> 00:08:29,199
graph and finally

00:08:26,400 --> 00:08:31,280
when the execution phase begins we use

00:08:29,199 --> 00:08:35,440
already compiled bazel targets

00:08:31,280 --> 00:08:37,919
and then the non-migrated gradle modules

00:08:35,440 --> 00:08:41,360
the entire process can be controlled via

00:08:37,919 --> 00:08:44,240
a single flag called bazel enabled

00:08:41,360 --> 00:08:44,880
having a such a flag also means that we

00:08:44,240 --> 00:08:47,279
can run

00:08:44,880 --> 00:08:48,959
parallel builds on our ci and then have

00:08:47,279 --> 00:08:51,680
strong feedback loops

00:08:48,959 --> 00:08:53,279
on whether the whole bazel migration

00:08:51,680 --> 00:08:55,920
scripts are correct

00:08:53,279 --> 00:08:57,839
having a hybrid build adds ability to

00:08:55,920 --> 00:09:00,000
incrementally migrate the project

00:08:57,839 --> 00:09:01,600
and then have feedback loops along the

00:09:00,000 --> 00:09:04,000
way

00:09:01,600 --> 00:09:05,519
hybrid build also helps in resolving

00:09:04,000 --> 00:09:08,000
blockers

00:09:05,519 --> 00:09:10,080
for example build config functionality

00:09:08,000 --> 00:09:12,160
that we discussed earlier

00:09:10,080 --> 00:09:13,519
can be implemented with a custom bazel

00:09:12,160 --> 00:09:16,560
macro

00:09:13,519 --> 00:09:17,200
and then grazel can be modified to

00:09:16,560 --> 00:09:20,560
generate

00:09:17,200 --> 00:09:22,000
rules containing this macro now when we

00:09:20,560 --> 00:09:24,560
run the migration again

00:09:22,000 --> 00:09:25,839
the new capability check would cover

00:09:24,560 --> 00:09:28,800
more modules

00:09:25,839 --> 00:09:29,839
and they also can be migrated for

00:09:28,800 --> 00:09:33,519
example

00:09:29,839 --> 00:09:35,680
bazel bill config macros

00:09:33,519 --> 00:09:38,240
when we do this consistently at one

00:09:35,680 --> 00:09:41,839
point it should be possible to have

00:09:38,240 --> 00:09:43,920
100 migration hybrid bills also don't

00:09:41,839 --> 00:09:45,279
require any changes on the gradle build

00:09:43,920 --> 00:09:47,760
scripts

00:09:45,279 --> 00:09:49,519
now that we have covered hybrid build i

00:09:47,760 --> 00:09:52,320
want to talk in detail about

00:09:49,519 --> 00:09:53,440
bazel build file generation generally

00:09:52,320 --> 00:09:56,240
when we talk about

00:09:53,440 --> 00:09:58,000
build file translation we can think of

00:09:56,240 --> 00:10:01,120
three distinct stages

00:09:58,000 --> 00:10:02,959
a parser to read the source data

00:10:01,120 --> 00:10:04,399
and then convert it to an intermediate

00:10:02,959 --> 00:10:06,000
representation

00:10:04,399 --> 00:10:07,440
and once we have the intermediate

00:10:06,000 --> 00:10:09,440
representation

00:10:07,440 --> 00:10:10,880
we can adapt it to the format that we

00:10:09,440 --> 00:10:14,720
require

00:10:10,880 --> 00:10:14,720
in this case bazel build files

00:10:14,959 --> 00:10:18,800
however gradient plugins already have

00:10:17,360 --> 00:10:22,000
this parsed project

00:10:18,800 --> 00:10:24,720
information as java objects

00:10:22,000 --> 00:10:27,839
and through the plugins api we can infer

00:10:24,720 --> 00:10:30,000
the project information as needed

00:10:27,839 --> 00:10:32,000
this way we are able to avoid a category

00:10:30,000 --> 00:10:33,440
of problems that would arise if we

00:10:32,000 --> 00:10:36,800
choose to write a custom

00:10:33,440 --> 00:10:39,680
gradle scripts parser for example

00:10:36,800 --> 00:10:41,600
let's take a configuration for gradle as

00:10:39,680 --> 00:10:44,560
shown above

00:10:41,600 --> 00:10:46,079
we could get details such as plugins and

00:10:44,560 --> 00:10:49,519
extensions from the project

00:10:46,079 --> 00:10:51,680
object and once we have this information

00:10:49,519 --> 00:10:52,560
the remaining bit is generating the

00:10:51,680 --> 00:10:55,440
corresponding

00:10:52,560 --> 00:10:56,480
bazel rules so when we talk about code

00:10:55,440 --> 00:11:00,320
generation

00:10:56,480 --> 00:11:02,160
we had a couple of goals for the design

00:11:00,320 --> 00:11:04,240
firstly we wanted the ability to

00:11:02,160 --> 00:11:06,000
programmatically manipulate the rules

00:11:04,240 --> 00:11:08,079
from a programming language

00:11:06,000 --> 00:11:09,760
so that we can adapt the rules as we

00:11:08,079 --> 00:11:13,200
need

00:11:09,760 --> 00:11:13,440
also we wanted the dsl to be flexible

00:11:13,200 --> 00:11:16,240
and

00:11:13,440 --> 00:11:19,600
extendable so that new rules can be

00:11:16,240 --> 00:11:22,240
easily added with minimal effort

00:11:19,600 --> 00:11:24,240
since we are working with gradle plugins

00:11:22,240 --> 00:11:26,880
we wanted it to be jvm based

00:11:24,240 --> 00:11:29,440
so that we can directly invoke it from

00:11:26,880 --> 00:11:32,160
grader plugins

00:11:29,440 --> 00:11:32,880
we also wanted the code generator to be

00:11:32,160 --> 00:11:35,519
concise

00:11:32,880 --> 00:11:39,279
so that it is easy to work with and does

00:11:35,519 --> 00:11:43,200
not have any noise such as such would be

00:11:39,279 --> 00:11:45,120
present otherwise

00:11:43,200 --> 00:11:48,399
for correctness and formatting we could

00:11:45,120 --> 00:11:51,680
use existing tools such as buildifier

00:11:48,399 --> 00:11:53,760
and grazel already uses buildifier for

00:11:51,680 --> 00:11:56,800
ensuring the generated bill scripts are

00:11:53,760 --> 00:11:58,959
correct and then also formats them

00:11:56,800 --> 00:12:01,360
to achieve these goals we chose to

00:11:58,959 --> 00:12:02,880
utilize kotlin a modern programming

00:12:01,360 --> 00:12:06,639
language from jetbrings

00:12:02,880 --> 00:12:09,200
for creating a typesafe starlark dsl

00:12:06,639 --> 00:12:10,079
it allows us to write valid star code

00:12:09,200 --> 00:12:13,200
naturally from

00:12:10,079 --> 00:12:15,760
kotlin as shown here

00:12:13,200 --> 00:12:17,120
i am using http archive and maven

00:12:15,760 --> 00:12:21,680
install functions

00:12:17,120 --> 00:12:23,760
naturally as part of jvm rules

00:12:21,680 --> 00:12:26,800
we can see that it is very similar to

00:12:23,760 --> 00:12:28,399
the generated star log code

00:12:26,800 --> 00:12:31,440
that would appear on the bazel build

00:12:28,399 --> 00:12:32,639
files at the core of the dsl we have a

00:12:31,440 --> 00:12:34,240
statement interface

00:12:32,639 --> 00:12:36,320
that represents a valid starlark

00:12:34,240 --> 00:12:38,079
statement

00:12:36,320 --> 00:12:39,360
from there we have multiple

00:12:38,079 --> 00:12:43,360
implementations like

00:12:39,360 --> 00:12:45,040
assignment array functions and objects

00:12:43,360 --> 00:12:47,279
so the idea here is that we could

00:12:45,040 --> 00:12:47,680
utilize the provided abstractions and

00:12:47,279 --> 00:12:50,720
create

00:12:47,680 --> 00:12:53,040
new statements as needed now let's take

00:12:50,720 --> 00:12:54,959
a small example

00:12:53,040 --> 00:12:56,880
an object statement is typically a

00:12:54,959 --> 00:12:59,680
collection of assignment statements

00:12:56,880 --> 00:13:01,440
separated by a comma and then guarded by

00:12:59,680 --> 00:13:03,440
a parenthesis

00:13:01,440 --> 00:13:05,920
the core api is designed to be

00:13:03,440 --> 00:13:08,000
extendable for adding new rules on top

00:13:05,920 --> 00:13:10,320
of this

00:13:08,000 --> 00:13:12,720
for example let's consider writing a

00:13:10,320 --> 00:13:15,200
load function

00:13:12,720 --> 00:13:15,760
we first start by writing an extension

00:13:15,200 --> 00:13:18,639
function

00:13:15,760 --> 00:13:19,440
on statements builder the statements

00:13:18,639 --> 00:13:21,680
builder class

00:13:19,440 --> 00:13:23,279
is an abstraction that allows managing

00:13:21,680 --> 00:13:26,560
multiple statements

00:13:23,279 --> 00:13:29,760
and also can finally write the generated

00:13:26,560 --> 00:13:29,760
statements to build file

00:13:29,839 --> 00:13:33,839
extension functions are a kotlin

00:13:31,440 --> 00:13:35,760
language feature that allows us to add

00:13:33,839 --> 00:13:37,040
functions and properties to existing

00:13:35,760 --> 00:13:39,680
types

00:13:37,040 --> 00:13:41,360
so this way using the statements builder

00:13:39,680 --> 00:13:45,440
we can extend the

00:13:41,360 --> 00:13:45,440
dsl to cover more cases

00:13:45,680 --> 00:13:48,959
so in the body we simply add a function

00:13:48,160 --> 00:13:51,040
statement

00:13:48,959 --> 00:13:53,040
and the function statement here would

00:13:51,040 --> 00:13:55,839
take care of writing a typical function

00:13:53,040 --> 00:13:58,160
syntax in star log

00:13:55,839 --> 00:13:59,360
similarly we can add a function another

00:13:58,160 --> 00:14:03,040
extension function

00:13:59,360 --> 00:14:05,199
for load this time in the body

00:14:03,040 --> 00:14:07,519
since we know the function name we can

00:14:05,199 --> 00:14:10,000
simply delegate to the function method

00:14:07,519 --> 00:14:12,160
that we just wrote above

00:14:10,000 --> 00:14:13,839
the idea here is that we can compose

00:14:12,160 --> 00:14:17,440
complex rules from the core

00:14:13,839 --> 00:14:19,279
dsl api here we see the implementation

00:14:17,440 --> 00:14:20,560
of maven install rule that we saw

00:14:19,279 --> 00:14:22,639
earlier

00:14:20,560 --> 00:14:24,959
as we can see the load statement here

00:14:22,639 --> 00:14:27,199
can be naturally used due to the way the

00:14:24,959 --> 00:14:30,000
extension functions work

00:14:27,199 --> 00:14:31,839
and the function abstraction here allows

00:14:30,000 --> 00:14:33,040
us to interact with it in a typesafe

00:14:31,839 --> 00:14:35,040
manner

00:14:33,040 --> 00:14:36,800
so when we talk about code generation we

00:14:35,040 --> 00:14:38,480
want to limit the number of each cases

00:14:36,800 --> 00:14:39,600
that we might discover and have to deal

00:14:38,480 --> 00:14:41,600
with

00:14:39,600 --> 00:14:45,279
one way to do that is to establish

00:14:41,600 --> 00:14:47,680
strong conventions that we can follow

00:14:45,279 --> 00:14:50,320
for example firstly we want the bazel

00:14:47,680 --> 00:14:54,079
target name to be always derivable from

00:14:50,320 --> 00:14:54,959
gradle project name this way it would be

00:14:54,079 --> 00:14:58,000
easy to map

00:14:54,959 --> 00:15:00,399
dependencies and bill files then

00:14:58,000 --> 00:15:01,839
we wanted to have a single build.bazel

00:15:00,399 --> 00:15:05,040
file adjacent to a

00:15:01,839 --> 00:15:06,000
existing build.gradle file this allows

00:15:05,040 --> 00:15:09,040
us to

00:15:06,000 --> 00:15:12,480
easily map bazel target name from

00:15:09,040 --> 00:15:14,240
gradle project name finally we wanted to

00:15:12,480 --> 00:15:15,120
have build gradle build scripts as

00:15:14,240 --> 00:15:18,160
source of truth

00:15:15,120 --> 00:15:20,320
until the migration is complete to do

00:15:18,160 --> 00:15:22,320
this we prefer to regenerate the

00:15:20,320 --> 00:15:24,480
build scripts when we want to make any

00:15:22,320 --> 00:15:26,959
changes

00:15:24,480 --> 00:15:28,639
this way it forces us to handle the edge

00:15:26,959 --> 00:15:30,959
case within grazel

00:15:28,639 --> 00:15:32,320
and ensures that future invocations of

00:15:30,959 --> 00:15:34,000
grazel are

00:15:32,320 --> 00:15:36,560
does not require any changes and is

00:15:34,000 --> 00:15:36,560
compatible

00:15:37,519 --> 00:15:42,160
grazel forms the core of our migration

00:15:39,519 --> 00:15:43,600
strategy and helps in bringing

00:15:42,160 --> 00:15:45,519
the overall migration effort

00:15:43,600 --> 00:15:47,360
considerably down

00:15:45,519 --> 00:15:49,360
in the future we want to explore the

00:15:47,360 --> 00:15:50,560
possibility of generating granular

00:15:49,360 --> 00:15:53,440
build.bezel files

00:15:50,560 --> 00:15:54,639
as per bazel's best practices for a java

00:15:53,440 --> 00:15:58,079
project

00:15:54,639 --> 00:16:00,399
granule build.bazel file also helps in

00:15:58,079 --> 00:16:03,360
parallelization and caching and thereby

00:16:00,399 --> 00:16:05,600
helps in better build times

00:16:03,360 --> 00:16:09,759
we're also excited to open source grazel

00:16:05,600 --> 00:16:11,519
soon in q4 2020

00:16:09,759 --> 00:16:13,839
well currently we are focused on

00:16:11,519 --> 00:16:16,399
generating build rules

00:16:13,839 --> 00:16:18,880
we also want to explore generating test

00:16:16,399 --> 00:16:22,740
rules as well

00:16:18,880 --> 00:16:25,940
thank you

00:16:22,740 --> 00:16:25,940
[Music]

00:16:29,440 --> 00:16:31,519

YouTube URL: https://www.youtube.com/watch?v=NVmxQCpov5s


