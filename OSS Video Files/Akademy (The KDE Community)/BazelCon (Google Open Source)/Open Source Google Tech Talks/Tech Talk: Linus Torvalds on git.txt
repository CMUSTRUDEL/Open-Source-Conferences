Title: Tech Talk: Linus Torvalds on git
Publication date: 2011-03-09
Playlist: Open Source Google Tech Talks
Description: 
	Linus Torvalds visits Google to share his thoughts on git, the source control management system he created two years ago.
Captions: 
	00:00:00,000 --> 00:00:00,000


00:00:00,000 --> 00:00:03,950
MALE SPEAKER: Thank you for coming, everybody.

00:00:03,950 --> 00:00:05,160
Some of you have probably already

00:00:05,160 --> 00:00:07,720
heard of Linus Torvalds.

00:00:07,720 --> 00:00:09,130
Those of you who haven't, you're the people with

00:00:09,130 --> 00:00:10,380
Macintoshes on your laps.

00:00:10,380 --> 00:00:12,710


00:00:12,710 --> 00:00:16,370
He's a guy who delights in being cruel to people.

00:00:16,370 --> 00:00:18,570
His latest cruel act is to create a revision control

00:00:18,570 --> 00:00:21,270
system which is expressly designed to make you feel less

00:00:21,270 --> 00:00:25,200
intelligent than you thought you were.

00:00:25,200 --> 00:00:27,500
Thank you for coming down today, Linus.

00:00:27,500 --> 00:00:29,600
I've been getting emails for the past few days from people

00:00:29,600 --> 00:00:30,540
saying, where's Linus?

00:00:30,540 --> 00:00:31,960
Why hasn't he measured my tree?

00:00:31,960 --> 00:00:33,530
Doesn't he love me anymore?

00:00:33,530 --> 00:00:34,750
And he walked into my office this afternoon.

00:00:34,750 --> 00:00:36,610
What are you doing here?

00:00:36,610 --> 00:00:38,610
But thank you for taking the time off.

00:00:38,610 --> 00:00:41,595
So Linus is here today to explain to us why on Earth he

00:00:41,595 --> 00:00:45,030
would write a software tool which only he is smart enough

00:00:45,030 --> 00:00:45,880
to know how to use.

00:00:45,880 --> 00:00:47,130
Thanks, Linus.

00:00:47,130 --> 00:00:56,836


00:00:56,836 --> 00:01:00,610
LINUS TORVALDS: So I have a few words of warning, which is

00:01:00,610 --> 00:01:03,420
I don't actually do speaking very much, partly because I

00:01:03,420 --> 00:01:05,730
don't like speaking, partly because over the last few

00:01:05,730 --> 00:01:09,860
years everybody actually wants me to talk about nebulous

00:01:09,860 --> 00:01:13,210
visions for the next century about Linux.

00:01:13,210 --> 00:01:16,990
And I'm a tech geek, so I actually prefer talking about

00:01:16,990 --> 00:01:18,270
technology.

00:01:18,270 --> 00:01:21,150
So that's why I am not talking about the kernel, because it's

00:01:21,150 --> 00:01:24,380
just too big to cram into a one-hour talk.

00:01:24,380 --> 00:01:29,910
Although apparently, Andrew did that two days ago.

00:01:29,910 --> 00:01:32,450
And I'm instead talking about Git, which is the source

00:01:32,450 --> 00:01:34,860
control management system that we use for the kernel.

00:01:34,860 --> 00:01:37,790


00:01:37,790 --> 00:01:44,010
I'm really, really, really bad at doing slides, which means

00:01:44,010 --> 00:01:47,400
that if we actually end up following these slides, you

00:01:47,400 --> 00:01:51,150
will be bored out of your mind and the talk will probably not

00:01:51,150 --> 00:01:53,560
be very good anyway.

00:01:53,560 --> 00:01:57,010
So I am the kind of speaker who really

00:01:57,010 --> 00:01:58,760
enjoys getting questions.

00:01:58,760 --> 00:02:03,330
And if that means that we kind of veer off in a tangent,

00:02:03,330 --> 00:02:05,430
you'll be happier, I'll be happier, the talk will

00:02:05,430 --> 00:02:07,510
probably be more interesting anyway.

00:02:07,510 --> 00:02:10,620
I don't know how you do things here at the Google talks, but

00:02:10,620 --> 00:02:14,050
I'm just saying don't feel shy as far as I'm concerned.

00:02:14,050 --> 00:02:18,510
If your manager will shoot you, that's your problem.

00:02:18,510 --> 00:02:22,310
So next slide.

00:02:22,310 --> 00:02:26,080
I want to give a few credits before I start.

00:02:26,080 --> 00:02:32,960
Credit CVS in a very, very negative way because in many

00:02:32,960 --> 00:02:38,310
ways when I designed Git, it's the what would Jesus do?

00:02:38,310 --> 00:02:43,010
Except it's what would CVS never, ever do kind of

00:02:43,010 --> 00:02:46,590
approach to source control management.

00:02:46,590 --> 00:02:50,020
I've never actually used CVS for the kernel.

00:02:50,020 --> 00:02:53,680
For the first 10 years of kernel maintenance, we

00:02:53,680 --> 00:02:57,260
literally used tarballs and patches, which is a much

00:02:57,260 --> 00:03:02,840
superior source control management system than CVS is.

00:03:02,840 --> 00:03:06,010
But I did end up using CVS for seven years at a commercial

00:03:06,010 --> 00:03:10,170
company and I hated it with a passion.

00:03:10,170 --> 00:03:13,760
When I say I hate CVS with a passion, I have to also say

00:03:13,760 --> 00:03:17,760
that if there are any SVN users in Subversion, users in

00:03:17,760 --> 00:03:24,520
the audience, you might want to leave because my hatred of

00:03:24,520 --> 00:03:29,120
CVS has meant that I see Subversion as being the most

00:03:29,120 --> 00:03:34,800
pointless project ever started, because the slogan

00:03:34,800 --> 00:03:39,470
for Subversion for a while was, CVS done right or

00:03:39,470 --> 00:03:42,060
something like that.

00:03:42,060 --> 00:03:45,790
And if you start with that kind of slogan, there's

00:03:45,790 --> 00:03:48,920
nowhere you can go.

00:03:48,920 --> 00:03:51,960
There is no way to do CVS right.

00:03:51,960 --> 00:03:55,350
So that's the negative kind of credit.

00:03:55,350 --> 00:03:57,970
The positive credit is BitKeeper.

00:03:57,970 --> 00:04:00,900
And I realize that a lot of people thought there was a lot

00:04:00,900 --> 00:04:04,540
of strife over BitKeeper and that the parting was very

00:04:04,540 --> 00:04:06,120
painful in many ways.

00:04:06,120 --> 00:04:12,200
As far as I'm concerned, the parting was amicable, even

00:04:12,200 --> 00:04:16,890
though it looked very non-amical to outsiders.

00:04:16,890 --> 00:04:23,410
And BitKeeper was not only the first source control system

00:04:23,410 --> 00:04:27,820
that I ever felt was worth using at all, it was also the

00:04:27,820 --> 00:04:30,770
source control system that taught me why there's a point

00:04:30,770 --> 00:04:33,780
to them and how you actually can do things.

00:04:33,780 --> 00:04:37,200
So Git in many ways, even though from a technical angle

00:04:37,200 --> 00:04:40,490
it is very, very different from BitKeeper, which was

00:04:40,490 --> 00:04:43,490
another design goal because I wanted to make it clear that

00:04:43,490 --> 00:04:48,240
it wasn't a BitKeeper clone, a lot of the flows we use with

00:04:48,240 --> 00:04:52,630
Git come directly from the flows we

00:04:52,630 --> 00:04:55,550
learned from BitKeeper.

00:04:55,550 --> 00:05:01,320
And I don't think you use BitKeeper here inside Google.

00:05:01,320 --> 00:05:05,140
As far as I know, BitKeeper is the only commercial source

00:05:05,140 --> 00:05:08,630
control management system that actually does distribution.

00:05:08,630 --> 00:05:11,810
And if you need a commercial run, that's the one you should

00:05:11,810 --> 00:05:13,910
use, for that reason.

00:05:13,910 --> 00:05:18,470
I'd also like to point out that I've been doing Git now

00:05:18,470 --> 00:05:24,640
for slightly over two years, but while I started it and I

00:05:24,640 --> 00:05:27,990
made all the initial coding design, it's actually being

00:05:27,990 --> 00:05:32,310
maintained by a much more pleasant person, Junior

00:05:32,310 --> 00:05:34,260
Hermano, for the last year and a half.

00:05:34,260 --> 00:05:39,530
And he's really the person who actually made it more

00:05:39,530 --> 00:05:42,360
approachable for mere mortals.

00:05:42,360 --> 00:05:46,060
Early versions of Git did require a certain amount of

00:05:46,060 --> 00:05:50,210
brainpower to really wrap your mind around.

00:05:50,210 --> 00:05:53,500
It's gotten much, much easier since.

00:05:53,500 --> 00:05:57,440
Obviously the way I always do everything is I try to get

00:05:57,440 --> 00:05:59,910
everybody else to do as much as possible so that I can sit

00:05:59,910 --> 00:06:03,160
back and sip my pina colada, so there's been a lot of other

00:06:03,160 --> 00:06:04,860
people involved, too.

00:06:04,860 --> 00:06:06,270
That's the credits.

00:06:06,270 --> 00:06:07,680
With those out of the way.

00:06:07,680 --> 00:06:10,660


00:06:10,660 --> 00:06:17,010
So this slide is now one day old, and I didn't actually do

00:06:17,010 --> 00:06:20,550
the slides last night because last night I was out carousing

00:06:20,550 --> 00:06:22,360
and eating sushi.

00:06:22,360 --> 00:06:29,370
But the slides will talk about implementation of a high

00:06:29,370 --> 00:06:31,900
performance distributed content management thing.

00:06:31,900 --> 00:06:35,320
And the keyword here is actually the distributed part.

00:06:35,320 --> 00:06:37,960
I will start off trying to explain why

00:06:37,960 --> 00:06:40,160
distribution is so important.

00:06:40,160 --> 00:06:42,530
If we never get past that point, I

00:06:42,530 --> 00:06:44,530
will actually be happy.

00:06:44,530 --> 00:06:47,550
If we never get to actually what Git implementation

00:06:47,550 --> 00:06:51,080
internally is, it's fine.

00:06:51,080 --> 00:06:54,490
I am not also trying to teach you how to use Git.

00:06:54,490 --> 00:06:57,600
There is this thing called google.com.

00:06:57,600 --> 00:07:00,640


00:07:00,640 --> 00:07:02,030
You may have seen it.

00:07:02,030 --> 00:07:04,640
It has this thing you can type things into.

00:07:04,640 --> 00:07:07,720
You type Git and then you press the I'm Feeling Lucky

00:07:07,720 --> 00:07:11,450
button, and you will actually get the home page.

00:07:11,450 --> 00:07:17,260
The home page has tutorials, it has the user manual,

00:07:17,260 --> 00:07:20,460
they're all in HTML.

00:07:20,460 --> 00:07:23,980
If you actually want to learn to use Git, that's where you

00:07:23,980 --> 00:07:26,530
should start, not at this talk.

00:07:26,530 --> 00:07:30,110
But as mentioned, if we actually start veering off

00:07:30,110 --> 00:07:31,940
topic into other tangents because of

00:07:31,940 --> 00:07:36,200
questions, it's all good.

00:07:36,200 --> 00:07:40,780
I already gave you kind of a heads up warning on this.

00:07:40,780 --> 00:07:45,800
I use the SCM, which I consider to mean Source Code

00:07:45,800 --> 00:07:48,750
Management, that is, revision control.

00:07:48,750 --> 00:07:52,810
Some other people think SCM means Software Configuration

00:07:52,810 --> 00:07:56,370
Management and see it as a much bigger feature, including

00:07:56,370 --> 00:07:58,280
release management and stuff like that.

00:07:58,280 --> 00:08:01,080
That's not what I'm talking about, although Git is clearly

00:08:01,080 --> 00:08:04,330
relevant in that setting, too.

00:08:04,330 --> 00:08:07,020
CVS, we already went there.

00:08:07,020 --> 00:08:11,690
You can disagree with me as much as you want, but during

00:08:11,690 --> 00:08:15,830
this talk, by definition anybody who disagrees is

00:08:15,830 --> 00:08:18,056
stupid and ugly.

00:08:18,056 --> 00:08:20,320
So keep that in mind.

00:08:20,320 --> 00:08:23,470
When I'm done speaking, you can go on with their lives.

00:08:23,470 --> 00:08:26,070
Right now, yes.

00:08:26,070 --> 00:08:32,400
I have strong opinions and CVS users, if you actually like

00:08:32,400 --> 00:08:36,320
using CVS, you shouldn't be here.

00:08:36,320 --> 00:08:41,320
You should be in some mental institution somewhere else.

00:08:41,320 --> 00:08:44,550


00:08:44,550 --> 00:08:47,040
So before actually go and talk about the whole distribution

00:08:47,040 --> 00:08:50,010
thing, which I think is the most important part, I'll talk

00:08:50,010 --> 00:08:53,170
a bit about the background because it invariably comes up

00:08:53,170 --> 00:08:57,260
because people, if they have heard about Git, a lot of the

00:08:57,260 --> 00:09:00,670
things they've heard about is the background for doing it in

00:09:00,670 --> 00:09:01,890
the first place.

00:09:01,890 --> 00:09:06,411
One piece of background information is I really am not

00:09:06,411 --> 00:09:07,850
an SCM person.

00:09:07,850 --> 00:09:09,510
I have never been very

00:09:09,510 --> 00:09:10,920
interested in revision control.

00:09:10,920 --> 00:09:14,730
I thought it was evil until I met BitKeeper.

00:09:14,730 --> 00:09:18,100
I actually credit that to some degree for why Git is so much

00:09:18,100 --> 00:09:19,750
better than everything else.

00:09:19,750 --> 00:09:22,840
It's because my brain did not rot from years and years of

00:09:22,840 --> 00:09:26,260
thinking CVS did something sane.

00:09:26,260 --> 00:09:28,000
I needed a replacement for BitKeeper.

00:09:28,000 --> 00:09:30,550
The reason for that was BitKeeper is a commercial

00:09:30,550 --> 00:09:34,500
product, but BitMover and Larry McVoy allowed it to be

00:09:34,500 --> 00:09:36,570
used freely for open source projects, as

00:09:36,570 --> 00:09:38,710
some of you may know.

00:09:38,710 --> 00:09:41,860
The only restriction was you were not supposed to reverse

00:09:41,860 --> 00:09:44,990
engineer it and you weren't supposed to try to create a

00:09:44,990 --> 00:09:46,980
competing product.

00:09:46,980 --> 00:09:49,040
And I was happy with that because, quite frankly, as far

00:09:49,040 --> 00:09:52,110
as I'm concerned I do open source because I think it's

00:09:52,110 --> 00:09:54,010
the only right way to do software.

00:09:54,010 --> 00:09:57,740
But at the same time, I'll use the best tool for the job and,

00:09:57,740 --> 00:10:00,730
quite frankly, BitKeeper was it.

00:10:00,730 --> 00:10:03,780
However, not everybody agreed with me.

00:10:03,780 --> 00:10:05,490
They are ugly and stupid.

00:10:05,490 --> 00:10:11,790
But they cause problems and it resulted in the fact that

00:10:11,790 --> 00:10:15,170
Larry and I had several telephone conversations which

00:10:15,170 --> 00:10:20,130
ended up saying we'll all be much happier if we just part

00:10:20,130 --> 00:10:22,630
ways and don't make this any worse.

00:10:22,630 --> 00:10:24,190
So we did.

00:10:24,190 --> 00:10:30,610
And I made the Linux 2.6.12-rc2 release about two

00:10:30,610 --> 00:10:34,400
years ago and said, I'm not going to touch Linux until I

00:10:34,400 --> 00:10:40,140
have a replacement for BitKeeper for doing source

00:10:40,140 --> 00:10:41,250
code maintenance.

00:10:41,250 --> 00:10:43,990
And one of the replacement options was going back to

00:10:43,990 --> 00:10:45,790
tarballs and patches, but nobody

00:10:45,790 --> 00:10:48,400
really liked that anymore.

00:10:48,400 --> 00:10:53,370
So I actually looked at a lot of alternatives.

00:10:53,370 --> 00:10:58,600
Most of them I could discard without even trying them out.

00:10:58,600 --> 00:11:01,330
If you're not distributed, you're not worth using.

00:11:01,330 --> 00:11:02,340
It's that simple.

00:11:02,340 --> 00:11:05,060
If you perform badly, you're not worth using.

00:11:05,060 --> 00:11:06,620
It's that simple.

00:11:06,620 --> 00:11:10,530
And if you cannot guarantee that the stuff I put into an

00:11:10,530 --> 00:11:16,060
SCM comes out exactly the same, you're not worth using.

00:11:16,060 --> 00:11:19,100
Quite frankly, that pretty much took care of

00:11:19,100 --> 00:11:20,760
everything out there.

00:11:20,760 --> 00:11:24,120
There's a lot of SCM systems that do not guarantee that

00:11:24,120 --> 00:11:28,410
what you get out of it again is the same thing you put in.

00:11:28,410 --> 00:11:33,370
If you have memory corruption, if you have disk corruption,

00:11:33,370 --> 00:11:34,790
you may never know.

00:11:34,790 --> 00:11:38,700
The only way you'll know is you notice that there's

00:11:38,700 --> 00:11:42,360
corruption in the files when you check them out.

00:11:42,360 --> 00:11:45,800
The source control management system does not protect you at

00:11:45,800 --> 00:11:48,410
all, and this is not even uncommon.

00:11:48,410 --> 00:11:51,550
It is very, very common.

00:11:51,550 --> 00:11:55,840
The performance issue, one of the things I kind of liked was

00:11:55,840 --> 00:11:59,770
a system called monotone, which actually, I think there

00:11:59,770 --> 00:12:02,260
was a talk at Google about them some time

00:12:02,260 --> 00:12:05,200
ago, I'm not sure.

00:12:05,200 --> 00:12:08,170
It had a lot of interesting ideas, but performance was so

00:12:08,170 --> 00:12:14,390
horrendously bad that I tried it for a day and realized that

00:12:14,390 --> 00:12:16,230
I cannot use it.

00:12:16,230 --> 00:12:19,690
The end result was I decided I can write something better

00:12:19,690 --> 00:12:23,700
than anything out there in two weeks, and I was right.

00:12:23,700 --> 00:12:28,730
So now we get to distribution.

00:12:28,730 --> 00:12:31,280
And this is the worst slide of them all, and I'm not very

00:12:31,280 --> 00:12:32,410
proud of it.

00:12:32,410 --> 00:12:34,550
And the problem is distribution is really, really

00:12:34,550 --> 00:12:37,290
important, but when I tried to make slides about it I

00:12:37,290 --> 00:12:38,760
could not do it.

00:12:38,760 --> 00:12:42,690
And part of it is my obvious artistic talents, which are on

00:12:42,690 --> 00:12:45,660
display for all of you, but part of it is that it's really

00:12:45,660 --> 00:12:48,400
hard to explain.

00:12:48,400 --> 00:12:51,810
So before you can start, I'd like to know how many people

00:12:51,810 --> 00:12:55,710
are used to the notion of a truly distributed source

00:12:55,710 --> 00:12:56,990
control management system?

00:12:56,990 --> 00:13:01,460


00:13:01,460 --> 00:13:04,300
Are most of you kernel developers?

00:13:04,300 --> 00:13:05,470
No, OK.

00:13:05,470 --> 00:13:09,080
So there were maybe 10 hands coming up.

00:13:09,080 --> 00:13:15,920
Being distributed very much means that you do not have one

00:13:15,920 --> 00:13:20,010
central location that keeps track of your data.

00:13:20,010 --> 00:13:23,800
No single place is more important than any other

00:13:23,800 --> 00:13:25,310
single place.

00:13:25,310 --> 00:13:28,240
So for example, this is why I would never touch Subversion

00:13:28,240 --> 00:13:29,940
with a 10 foot pole.

00:13:29,940 --> 00:13:34,240
There is a massive Subversion repository, and it's where

00:13:34,240 --> 00:13:38,040
everybody has to write.

00:13:38,040 --> 00:13:41,540
The centralized model just doesn't work when you want to

00:13:41,540 --> 00:13:47,270
be-- let's look at a few of the cases.

00:13:47,270 --> 00:13:52,190
I say it's so much more than just offline work, but the

00:13:52,190 --> 00:13:56,040
offline work part is actually maybe the most obvious thing,

00:13:56,040 --> 00:13:59,820
which is that you can take a truly distributed source

00:13:59,820 --> 00:14:02,530
control management system, you can take it on a plane and

00:14:02,530 --> 00:14:06,960
even if they don't offer Wi-Fi and satellite hookups, you

00:14:06,960 --> 00:14:09,940
just continue working, you can look at all your logs, you can

00:14:09,940 --> 00:14:12,680
commit, you can do everything you would do even if you were

00:14:12,680 --> 00:14:15,430
connected to a nice gigabit ethernet

00:14:15,430 --> 00:14:17,820
directly to the backbone.

00:14:17,820 --> 00:14:19,830
And that is really important.

00:14:19,830 --> 00:14:24,610
It is doubly important when you have hundreds or thousands

00:14:24,610 --> 00:14:30,060
of people working on the same project and they may not be

00:14:30,060 --> 00:14:33,920
literally disconnected, but in practice they aren't really

00:14:33,920 --> 00:14:36,050
well-connected either.

00:14:36,050 --> 00:14:40,560
So part of distribution is this offline work theme.

00:14:40,560 --> 00:14:43,860
Even if it's not completely offline, it is important to be

00:14:43,860 --> 00:14:47,340
able to do everything you want to do from any location

00:14:47,340 --> 00:14:49,640
without having to be able to access the server.

00:14:49,640 --> 00:14:53,520


00:14:53,520 --> 00:15:00,820
What that basic fact actually results in is that you

00:15:00,820 --> 00:15:04,630
effectively have a lot more branching because everybody

00:15:04,630 --> 00:15:09,260
who has a complete repository and can do commits on his own

00:15:09,260 --> 00:15:13,020
will effectively have his own branch, even if you don't

00:15:13,020 --> 00:15:13,690
realize it.

00:15:13,690 --> 00:15:17,650
Even if you think of your project as just having a

00:15:17,650 --> 00:15:20,750
single branch, every single time you disconnect your

00:15:20,750 --> 00:15:23,630
laptop and start working with it, you

00:15:23,630 --> 00:15:25,590
are on your own branch.

00:15:25,590 --> 00:15:28,680
And this is really, really important and is very

00:15:28,680 --> 00:15:32,820
different from anybody who's used CVS, where branching is

00:15:32,820 --> 00:15:36,280
considered something that only true gurus do.

00:15:36,280 --> 00:15:40,110
How many of you have ever used CVS?

00:15:40,110 --> 00:15:41,040
OK, everybody.

00:15:41,040 --> 00:15:43,890
How many of you have really done a branch and ever

00:15:43,890 --> 00:15:46,910
merged it in CVS?

00:15:46,910 --> 00:15:48,310
Good job.

00:15:48,310 --> 00:15:52,370
I mean, it wasn't everybody but it was actually more than

00:15:52,370 --> 00:15:53,140
I expected.

00:15:53,140 --> 00:15:57,420
How many of you enjoyed the experience?

00:15:57,420 --> 00:15:59,930
OK, so there were a couple.

00:15:59,930 --> 00:16:02,550
But it is considered hard.

00:16:02,550 --> 00:16:07,400
In CVS, when you merge a branch--

00:16:07,400 --> 00:16:09,440
I've done it as little as possible, but

00:16:09,440 --> 00:16:10,470
I've had to do it--

00:16:10,470 --> 00:16:13,640
what you do is you plan ahead for a week and then you

00:16:13,640 --> 00:16:16,320
basically set aside one day for doing it.

00:16:16,320 --> 00:16:18,380
Am I wrong?

00:16:18,380 --> 00:16:21,560
I'm not seeing a lot of people say no, it was easy.

00:16:21,560 --> 00:16:23,390
I liked it.

00:16:23,390 --> 00:16:25,340
It's horrible.

00:16:25,340 --> 00:16:27,790
If you're distributed, you have to realize that every

00:16:27,790 --> 00:16:30,640
single person has his own branch.

00:16:30,640 --> 00:16:31,850
It's horrible.

00:16:31,850 --> 00:16:35,680
It's not something you even have to set up.

00:16:35,680 --> 00:16:37,190
It just is.

00:16:37,190 --> 00:16:40,060
In fact, in Git, we like branches so much that a lot of

00:16:40,060 --> 00:16:42,850
people just have five or ten or fifteen of them.

00:16:42,850 --> 00:16:46,750
Just because once you realize that you have to have a

00:16:46,750 --> 00:16:49,650
special branch anyway, you might as well have many.

00:16:49,650 --> 00:16:53,870
And one of the branches you do some experimental work on and

00:16:53,870 --> 00:16:59,230
one of the branches you do maintenance on.

00:16:59,230 --> 00:17:02,390
So branching is much more inherent when you do

00:17:02,390 --> 00:17:03,640
distribution.

00:17:03,640 --> 00:17:05,740


00:17:05,740 --> 00:17:10,339
One of the other things that, to me, is very important is

00:17:10,339 --> 00:17:15,710
that by being distributed, you also automatically get to be

00:17:15,710 --> 00:17:18,349
slightly more trustworthy.

00:17:18,349 --> 00:17:20,490
I have a theory of backup switches.

00:17:20,490 --> 00:17:21,560
I don't do them.

00:17:21,560 --> 00:17:25,540
I put stuff up on one side and everybody else mirrors it.

00:17:25,540 --> 00:17:30,240
And if I crash my own machine I don't really care, because I

00:17:30,240 --> 00:17:33,920
can just download my own work right back.

00:17:33,920 --> 00:17:36,520
And it works beautifully well, and I don't have to have an

00:17:36,520 --> 00:17:37,470
MIS department.

00:17:37,470 --> 00:17:41,370
I heartily suggest everybody else do the same.

00:17:41,370 --> 00:17:46,370
But this only really works in a distributed environment.

00:17:46,370 --> 00:17:51,500
If you use CVS, you can't do this.

00:17:51,500 --> 00:17:52,380
What do you use here?

00:17:52,380 --> 00:17:53,910
Perforce?

00:17:53,910 --> 00:17:55,150
Perforce.

00:17:55,150 --> 00:17:58,020
I'm sorry.

00:17:58,020 --> 00:18:05,370
I'm sure it's better than CVS. [WHISPERS].

00:18:05,370 --> 00:18:06,990
So that's part of it.

00:18:06,990 --> 00:18:11,870
One of the really nice things which is also--

00:18:11,870 --> 00:18:15,010
maybe you don't have this issue inside a company, but we

00:18:15,010 --> 00:18:17,770
certainly have it in every single open source community

00:18:17,770 --> 00:18:20,250
I've ever seen that uses CVS or Subversion or something

00:18:20,250 --> 00:18:24,140
like that-- is you have this notion of commit access.

00:18:24,140 --> 00:18:26,280
Because you have a central repository, it means that

00:18:26,280 --> 00:18:29,370
everybody who is working on that project needs to write to

00:18:29,370 --> 00:18:33,480
the central repository, which means that since you don't

00:18:33,480 --> 00:18:36,090
want everybody to write to the central repository because

00:18:36,090 --> 00:18:40,830
most people are morons, you create this class of people

00:18:40,830 --> 00:18:43,610
who are ostensibly not morons.

00:18:43,610 --> 00:18:47,980
And most of the time, what happens is you make that class

00:18:47,980 --> 00:18:52,550
too small because it's really hard to know if a person is

00:18:52,550 --> 00:18:56,740
smart or not, and even when you make it too small, you

00:18:56,740 --> 00:19:02,030
will have problems. So this whole commit access issue,

00:19:02,030 --> 00:19:04,710
which some companies are able to ignore by just giving

00:19:04,710 --> 00:19:08,950
everybody commit access, is a huge psychological barrier and

00:19:08,950 --> 00:19:12,140
causes endless hours of politics in

00:19:12,140 --> 00:19:14,400
most open source projects.

00:19:14,400 --> 00:19:18,230
If you have a distributed model, it goes away.

00:19:18,230 --> 00:19:19,650
Everybody has commit access.

00:19:19,650 --> 00:19:23,100
You can do whatever you want to your project.

00:19:23,100 --> 00:19:27,790
You just get your own branch, you do great work or you do

00:19:27,790 --> 00:19:28,810
stupid work.

00:19:28,810 --> 00:19:29,720
Nobody cares.

00:19:29,720 --> 00:19:32,780
It's your copy, it's your branch.

00:19:32,780 --> 00:19:37,120
And later on, if it turns out you did a good job, you can

00:19:37,120 --> 00:19:39,170
tell people hey, here's my branch.

00:19:39,170 --> 00:19:42,640
And by the way, it performs 10 times faster than anybody

00:19:42,640 --> 00:19:46,310
else's branch, so nyah nyah nyah, how about

00:19:46,310 --> 00:19:48,040
pulling from me?

00:19:48,040 --> 00:19:49,060
And people do.

00:19:49,060 --> 00:19:50,820
And that's actually how it works, and we

00:19:50,820 --> 00:19:52,410
never have any politics.

00:19:52,410 --> 00:19:57,420
That's not quite true, but we have other politics.

00:19:57,420 --> 00:19:59,900
We don't have to worry about the commit access thing.

00:19:59,900 --> 00:20:05,770
And I think this is a huge issue and that alone should

00:20:05,770 --> 00:20:09,590
mean that every single open source system should never use

00:20:09,590 --> 00:20:11,320
anything but a distributed model.

00:20:11,320 --> 00:20:14,460
You get rid of a lot of issues.

00:20:14,460 --> 00:20:17,610
One of the things that commercial companies,

00:20:17,610 --> 00:20:19,550
distributed models actually help also

00:20:19,550 --> 00:20:21,330
with the release process.

00:20:21,330 --> 00:20:25,210
You can have a verification team that has its own tree,

00:20:25,210 --> 00:20:27,490
and they pull from people and they verify it.

00:20:27,490 --> 00:20:30,320
And when they've verified it, they can push it to the

00:20:30,320 --> 00:20:34,740
release team and say, hey, we have now verified our version.

00:20:34,740 --> 00:20:38,120
And the development people, they can go on playing with

00:20:38,120 --> 00:20:39,480
their head.

00:20:39,480 --> 00:20:43,170
Instead of having to create tagged branches, whatever you

00:20:43,170 --> 00:20:48,600
do to try to keep off each other's toes, again, you keep

00:20:48,600 --> 00:20:52,370
off each other's toes by just every single group can have

00:20:52,370 --> 00:20:59,380
its own tree and track its work and what they want done.

00:20:59,380 --> 00:21:06,100
So distributed is really, really central to any SCM you

00:21:06,100 --> 00:21:08,060
should ever use.

00:21:08,060 --> 00:21:11,856
So get rid of Perforce now.

00:21:11,856 --> 00:21:15,850
[APPLAUSE]

00:21:15,850 --> 00:21:20,350
LINUS TORVALDS: It's sad, but it is so, so true.

00:21:20,350 --> 00:21:22,735
That was my only real slide about distribution.

00:21:22,735 --> 00:21:25,950


00:21:25,950 --> 00:21:30,640
I'd love to get questions, because we're now moving into

00:21:30,640 --> 00:21:34,000
other areas that--

00:21:34,000 --> 00:21:37,330
AUDIENCE: So how would you do it?

00:21:37,330 --> 00:21:41,870
If you had this monstrously awesomely big code base, and

00:21:41,870 --> 00:21:45,280
you wanted to use this without stopping business for six

00:21:45,280 --> 00:21:48,640
months, how would you do it?

00:21:48,640 --> 00:21:52,850
LINUS TORVALDS: Stay by the mic because I couldn't quite

00:21:52,850 --> 00:21:54,840
make out your question.

00:21:54,840 --> 00:21:56,540
OK, he went away.

00:21:56,540 --> 00:21:57,670
How would you do this?

00:21:57,670 --> 00:21:59,875
AUDIENCE: [INAUDIBLE].

00:21:59,875 --> 00:22:06,790
LINUS TORVALDS: So an example of actual distribution is you

00:22:06,790 --> 00:22:09,820
have a group of five people working on one small,

00:22:09,820 --> 00:22:11,820
particular feature.

00:22:11,820 --> 00:22:16,120
And that means that for a while, that feature will be

00:22:16,120 --> 00:22:18,550
very, very broken, right?

00:22:18,550 --> 00:22:21,800
Because nobody actually creates perfect code the first

00:22:21,800 --> 00:22:25,990
time around except me, but there's only one of me.

00:22:25,990 --> 00:22:31,200
So what happens is they need to have their own tree that

00:22:31,200 --> 00:22:35,180
they can work in without affecting other people.

00:22:35,180 --> 00:22:37,420
You can do this many different ways.

00:22:37,420 --> 00:22:41,110
In CVS, one of the most common ways, because branches are so

00:22:41,110 --> 00:22:44,650
painful, is that you don't actually commit.

00:22:44,650 --> 00:22:49,380
You never commit until it passes every single test. For

00:22:49,380 --> 00:22:53,260
example, at your company you have a very strict committing

00:22:53,260 --> 00:22:58,130
rule saying you will never, ever commit until it's past

00:22:58,130 --> 00:22:59,310
the whole test suite.

00:22:59,310 --> 00:23:02,230
And by the way, the fact that the test suite takes two hours

00:23:02,230 --> 00:23:05,250
to run, tough.

00:23:05,250 --> 00:23:07,490
You cannot afford to commit.

00:23:07,490 --> 00:23:09,150
And this is something that happens at

00:23:09,150 --> 00:23:10,290
every single company.

00:23:10,290 --> 00:23:13,530
I bet it happens even here at Google.

00:23:13,530 --> 00:23:16,420
You probably have a strict test suite, and you are not

00:23:16,420 --> 00:23:19,150
supposed to commit unless it passes.

00:23:19,150 --> 00:23:22,760
And then in practice, people make one-liner changes and

00:23:22,760 --> 00:23:24,730
ignore the test suite because they know the one-liner

00:23:24,730 --> 00:23:25,980
changes can't possibly break.

00:23:25,980 --> 00:23:28,340


00:23:28,340 --> 00:23:31,870
This happens.

00:23:31,870 --> 00:23:34,580
This is a horrible, horrible model.

00:23:34,580 --> 00:23:36,890
It just means that you make huge commits because you

00:23:36,890 --> 00:23:40,040
commit something after you've worked on it for two weeks,

00:23:40,040 --> 00:23:44,040
and you have three people working in the same sandbox

00:23:44,040 --> 00:23:47,980
because before they commit, they can't see the changes

00:23:47,980 --> 00:23:49,530
that the other people made.

00:23:49,530 --> 00:23:50,230
This is common.

00:23:50,230 --> 00:23:52,220
It happens everywhere, it's scary.

00:23:52,220 --> 00:23:54,980
The other alternative is to use branches even in a

00:23:54,980 --> 00:23:56,090
centralized environment.

00:23:56,090 --> 00:23:59,880
But branches always end up being pretty expensive to do,

00:23:59,880 --> 00:24:02,015
so you can't do them for experimental features.

00:24:02,015 --> 00:24:05,320


00:24:05,320 --> 00:24:07,520
You don't know beforehand if it's something that's going to

00:24:07,520 --> 00:24:11,940
take one day or two weeks, but most of the time most

00:24:11,940 --> 00:24:16,760
programmers say, hey, I can do this in 48 hours.

00:24:16,760 --> 00:24:20,660
And it turns out, yeah, no you couldn't.

00:24:20,660 --> 00:24:24,050
But because you feel you can do it in 48 hours, creating a

00:24:24,050 --> 00:24:26,380
branch, even in systems that are better at creating

00:24:26,380 --> 00:24:29,210
branches than CVS, is a big pain.

00:24:29,210 --> 00:24:32,680
So you don't do it because you think you can get it resolved

00:24:32,680 --> 00:24:35,360
and you're back to case number one.

00:24:35,360 --> 00:24:38,350
But if you decide to create a branch, you will affect

00:24:38,350 --> 00:24:40,890
everybody else's repository because in a centralized

00:24:40,890 --> 00:24:43,290
environment, branches are global.

00:24:43,290 --> 00:24:45,340
So you're kind of screwing with everybody else, but at

00:24:45,340 --> 00:24:49,100
least you're not screwing with their main, head branch.

00:24:49,100 --> 00:24:54,010
You are adding stuff to their repositories, but hopefully in

00:24:54,010 --> 00:24:56,060
a way that they won't notice.

00:24:56,060 --> 00:25:01,390
But it does make everybody's repositories bigger.

00:25:01,390 --> 00:25:03,440
So either way, you can't win.

00:25:03,440 --> 00:25:06,520
In contrast, in a distributed environment, what you do is

00:25:06,520 --> 00:25:09,700
you have five people, they pull the current head, which

00:25:09,700 --> 00:25:13,120
is hopefully good and tested, and they start working on it

00:25:13,120 --> 00:25:14,670
and they start committing on it.

00:25:14,670 --> 00:25:18,970
And you don't need to wait for two weeks until your commits

00:25:18,970 --> 00:25:22,670
are stable because your commits are always local.

00:25:22,670 --> 00:25:25,420
And what happens is within that group of five people, you

00:25:25,420 --> 00:25:27,910
can pull from each other.

00:25:27,910 --> 00:25:29,920
That's what distributed means.

00:25:29,920 --> 00:25:33,620
There's no central location, it means everybody's the same.

00:25:33,620 --> 00:25:35,910
So you can merge between yourself.

00:25:35,910 --> 00:25:40,220
So not only can you commit every single line if you want

00:25:40,220 --> 00:25:43,610
to without having to run the two-hour test suite, but you

00:25:43,610 --> 00:25:46,770
can then communicate by pulling and merging each

00:25:46,770 --> 00:25:51,360
other's work and one person finds the bug again commits it

00:25:51,360 --> 00:25:54,190
and tells the other four people, hey, my repository has

00:25:54,190 --> 00:25:55,750
a fix for this.

00:25:55,750 --> 00:26:00,130
And then when that group is done two weeks later, they can

00:26:00,130 --> 00:26:03,700
tell their manager, hey, we've done this.

00:26:03,700 --> 00:26:08,260
Can you ask the main group to pull, and they'll get this new

00:26:08,260 --> 00:26:12,080
feature and by the way, we've tested it over two weeks and

00:26:12,080 --> 00:26:15,450
it works and it performs this much better because we have

00:26:15,450 --> 00:26:19,270
actually been able to time it before we even ask anybody

00:26:19,270 --> 00:26:21,790
else to look at it.

00:26:21,790 --> 00:26:25,270
And that's a hugely better model for doing development.

00:26:25,270 --> 00:26:29,080
And this is the model that the kernel uses.

00:26:29,080 --> 00:26:32,880
It turns out in many places, we don't need all that power,

00:26:32,880 --> 00:26:35,160
even in the kernel.

00:26:35,160 --> 00:26:45,730
So people usually don't pull within one group, but does it

00:26:45,730 --> 00:26:46,430
does happen.

00:26:46,430 --> 00:26:48,820
For example, the networking people sometimes affect the

00:26:48,820 --> 00:26:51,340
NFS people, and the fact that they can

00:26:51,340 --> 00:26:55,120
synchronize actually helps.

00:26:55,120 --> 00:26:58,290
So this is a real, practical advantage.

00:26:58,290 --> 00:26:59,340
Somebody else has a question.

00:26:59,340 --> 00:27:02,840
AUDIENCE: So it feels like the politics has just been moved

00:27:02,840 --> 00:27:04,700
to an indirect political question.

00:27:04,700 --> 00:27:07,070
If everyone's got access and they're all playing with their

00:27:07,070 --> 00:27:08,840
branches and they have their sandbox and they're having

00:27:08,840 --> 00:27:11,170
fun, at the end of the day there has to be merging and

00:27:11,170 --> 00:27:13,990
resolving unless you have 80 billion flavors

00:27:13,990 --> 00:27:14,930
of every Linux kernel.

00:27:14,930 --> 00:27:16,180
LINUS TORVALDS: Absolutely.

00:27:16,180 --> 00:27:18,340


00:27:18,340 --> 00:27:21,920
There will be 1,000 or maybe 20,000 different branches, but

00:27:21,920 --> 00:27:24,820
in practice you won't ever see them because they won't care.

00:27:24,820 --> 00:27:27,220
You will see like a few main branches, maybe

00:27:27,220 --> 00:27:28,580
you'll see only one.

00:27:28,580 --> 00:27:31,280
In the case of the kernel, a lot of people they only really

00:27:31,280 --> 00:27:32,790
look at my branch.

00:27:32,790 --> 00:27:34,800
So even though there are lots of branches,

00:27:34,800 --> 00:27:36,340
you can ignore them.

00:27:36,340 --> 00:27:40,180
What happens is the way merging is done is the way

00:27:40,180 --> 00:27:44,970
real security is done, by a network of trust. If you have

00:27:44,970 --> 00:27:48,670
ever done any security work and it did not involve the

00:27:48,670 --> 00:27:51,770
concept of network of trust, it wasn't security work.

00:27:51,770 --> 00:27:54,230
It was masturbation.

00:27:54,230 --> 00:27:57,190
I don't know what you were doing, but trust me, it's the

00:27:57,190 --> 00:28:00,560
only way you can do security, it's the only way you can do

00:28:00,560 --> 00:28:01,780
development.

00:28:01,780 --> 00:28:05,620
The way I work, I don't trust everybody.

00:28:05,620 --> 00:28:09,850
In fact, I am a very cynical and untrusting person.

00:28:09,850 --> 00:28:13,920
I think most of you are completely incompetent.

00:28:13,920 --> 00:28:16,390
The whole point of being distributed is I don't

00:28:16,390 --> 00:28:17,200
have to trust you.

00:28:17,200 --> 00:28:19,360
I don't have to give you commit access.

00:28:19,360 --> 00:28:24,400
But I know that among the multitude of average people,

00:28:24,400 --> 00:28:28,100
there are some people that just stand out, that I trust

00:28:28,100 --> 00:28:30,890
because I've been working with them.

00:28:30,890 --> 00:28:36,840
I only need to trust 5, 10, 15 people.

00:28:36,840 --> 00:28:40,740
If I have a network of trust that covers those 5, 10, 15

00:28:40,740 --> 00:28:43,810
people that are outstanding and I know they're

00:28:43,810 --> 00:28:48,060
outstanding, I can pull from them.

00:28:48,060 --> 00:28:51,420
I don't have to spend a lot of brain power on the question.

00:28:51,420 --> 00:28:54,530
When Andrew sends me patches-- he doesn't actually use Git,

00:28:54,530 --> 00:28:57,240
it's some kind of defect--

00:28:57,240 --> 00:29:01,650
other than that, he's a very solid person.

00:29:01,650 --> 00:29:04,650
When he asks me to pull, he does it by sending me a

00:29:04,650 --> 00:29:05,340
million patches.

00:29:05,340 --> 00:29:08,040
Instead, I just do it.

00:29:08,040 --> 00:29:11,910
Sometimes I disagree with some of these patches, but at some

00:29:11,910 --> 00:29:16,450
point, trust means never having to say you're sorry.

00:29:16,450 --> 00:29:17,410
I don't know.

00:29:17,410 --> 00:29:20,030
It basically means you have to accept

00:29:20,030 --> 00:29:23,100
other people's decisions.

00:29:23,100 --> 00:29:26,640
The nice thing about trust is it does network, that's where

00:29:26,640 --> 00:29:28,510
the network of trust comes in.

00:29:28,510 --> 00:29:31,450
I only need to trust a few people that much.

00:29:31,450 --> 00:29:34,620
They have other people, they have determined, hey, that guy

00:29:34,620 --> 00:29:36,050
is actually smarter than I am.

00:29:36,050 --> 00:29:39,500
That's actually a really good measure of who

00:29:39,500 --> 00:29:40,870
you should pull from.

00:29:40,870 --> 00:29:43,240
If you have determined that somebody else is smarter than

00:29:43,240 --> 00:29:45,540
you, go for it.

00:29:45,540 --> 00:29:48,060
You can't lose, right?

00:29:48,060 --> 00:29:50,510
Even if it turns out you pulled crap and somebody else

00:29:50,510 --> 00:29:53,630
starts complaining, you know who you pulled from and you

00:29:53,630 --> 00:29:55,270
can just point to the other person and

00:29:55,270 --> 00:29:57,450
say, hey, I just pulled.

00:29:57,450 --> 00:29:59,390
Go to him, he knows what he's doing.

00:29:59,390 --> 00:30:00,440
So that's how I work.

00:30:00,440 --> 00:30:02,580
That's probably most of my lieutenants work.

00:30:02,580 --> 00:30:05,210


00:30:05,210 --> 00:30:09,600
I pull the networking changes from one person, he gets them

00:30:09,600 --> 00:30:13,070
from many other people that he's worked with over time.

00:30:13,070 --> 00:30:15,260
So this is how it all comes together.

00:30:15,260 --> 00:30:18,580
It doesn't have to come together to one point.

00:30:18,580 --> 00:30:21,370
In the kernel, it comes together to one point largely

00:30:21,370 --> 00:30:23,150
I think for historical reasons.

00:30:23,150 --> 00:30:27,480
And actually, I've always tried to encourage people to

00:30:27,480 --> 00:30:29,090
have more trees.

00:30:29,090 --> 00:30:33,620
So we do have vendor trees, we do have -mm trees, we have

00:30:33,620 --> 00:30:37,680
multiple one points, and it happens to be that my one

00:30:37,680 --> 00:30:39,760
point is getting maybe more attention

00:30:39,760 --> 00:30:41,760
than it always should.

00:30:41,760 --> 00:30:44,590
But even if it doesn't come down to one point, it means

00:30:44,590 --> 00:30:47,630
that you can take these thousands of branches and

00:30:47,630 --> 00:30:50,860
ignore 99.9% of them.

00:30:50,860 --> 00:30:53,470
And you know that, hey, there are five branches that are

00:30:53,470 --> 00:30:55,760
really interesting to follow because I'm interested in

00:30:55,760 --> 00:30:57,310
those sub-areas.

00:30:57,310 --> 00:30:59,380
And it all works very naturally.

00:30:59,380 --> 00:31:02,460
One of the nice things about this whole network of trust is

00:31:02,460 --> 00:31:06,040
it's not just easy to do technically, it's actually how

00:31:06,040 --> 00:31:09,330
every single person in this room is very fundamentally

00:31:09,330 --> 00:31:11,120
wired to work.

00:31:11,120 --> 00:31:12,780
It is how we think.

00:31:12,780 --> 00:31:15,440
We don't know 100 people.

00:31:15,440 --> 00:31:20,940
We have five, seven, ten close, personal friends.

00:31:20,940 --> 00:31:22,710
Well, we're geeks, so we have two.

00:31:22,710 --> 00:31:26,440
But I mean, that's basically how humans work, is that we

00:31:26,440 --> 00:31:29,290
have these people that we really trust. It's family,

00:31:29,290 --> 00:31:31,170
it's close friends.

00:31:31,170 --> 00:31:34,600
And it really fits.

00:31:34,600 --> 00:31:36,230
You don't even have to have a mental model.

00:31:36,230 --> 00:31:39,390
It fits how we are wired up.

00:31:39,390 --> 00:31:42,270
So there's huge advantages to this whole model network of

00:31:42,270 --> 00:31:45,350
trust.

00:31:45,350 --> 00:31:47,330
AUDIENCE: Do you know any companies that are using

00:31:47,330 --> 00:31:48,870
distributed systems internally?

00:31:48,870 --> 00:31:52,790
It seems like there might be a risk of vulcanizing the code

00:31:52,790 --> 00:31:56,350
base as people not being in the same sandbox don't

00:31:56,350 --> 00:31:56,940
contribute back.

00:31:56,940 --> 00:31:58,890
LINUS TORVALDS: So quite frankly, there aren't that

00:31:58,890 --> 00:32:02,900
many distributed systems. There is BitKeeper.

00:32:02,900 --> 00:32:06,080
It is clearly being used at commercial companies.

00:32:06,080 --> 00:32:10,080
We might have somebody in the audience who actually knows.

00:32:10,080 --> 00:32:10,570
What?

00:32:10,570 --> 00:32:12,194
AUDIENCE: [INAUDIBLE].

00:32:12,194 --> 00:32:15,700
LINUS TORVALDS: So HP is using things like BitKeeper for the

00:32:15,700 --> 00:32:16,580
printer project.

00:32:16,580 --> 00:32:19,200
I'm sure they have a lot more companies.

00:32:19,200 --> 00:32:23,910
In the open source world, there are two distributed

00:32:23,910 --> 00:32:26,690
systems that are worth looking at right now.

00:32:26,690 --> 00:32:30,040
One of them is obviously Git and you really should pick

00:32:30,040 --> 00:32:33,510
that one, but the other one is Mercurial, which actually has

00:32:33,510 --> 00:32:36,650
pretty much the same time design.

00:32:36,650 --> 00:32:40,460
There are huge differences in implementation and there are

00:32:40,460 --> 00:32:44,490
some differences in details, but it boils down to a very

00:32:44,490 --> 00:32:45,165
similar model.

00:32:45,165 --> 00:32:48,070
Git just does it better.

00:32:48,070 --> 00:32:51,600
Everything else, it's either centralized or it is too

00:32:51,600 --> 00:32:54,750
unstable or too slow to use for anything big.

00:32:54,750 --> 00:32:58,040
AUDIENCE: Right, but is there an advantage for a company to

00:32:58,040 --> 00:33:00,010
have everybody playing in the same sandbox?

00:33:00,010 --> 00:33:02,170
LINUS TORVALDS: I think a lot of companies think there is an

00:33:02,170 --> 00:33:03,950
advantage to that.

00:33:03,950 --> 00:33:06,790
I know that inside companies, I don't think a lot of

00:33:06,790 --> 00:33:10,180
companies use Git knowingly in the sense that it

00:33:10,180 --> 00:33:13,530
is a company decision.

00:33:13,530 --> 00:33:17,600
I know several companies who use Git internally, not

00:33:17,600 --> 00:33:19,900
knowing that they do so because they actually have

00:33:19,900 --> 00:33:23,410
their main repository in Subversion and a lot of

00:33:23,410 --> 00:33:26,700
developers then import it into Git because Git can actually

00:33:26,700 --> 00:33:28,430
merge things for you.

00:33:28,430 --> 00:33:34,780
So you can take a Subversion tree, just import it into Git,

00:33:34,780 --> 00:33:38,666
let Git do the merge, which would be a major headache to

00:33:38,666 --> 00:33:41,550
do in Subversion, create a merge commit, and actually

00:33:41,550 --> 00:33:45,710
export it back to Subversion, and nobody else even

00:33:45,710 --> 00:33:47,940
knew you used Git.

00:33:47,940 --> 00:33:53,100
It's kind of sad, but we have cases of people talking about

00:33:53,100 --> 00:33:56,570
doing exactly that inside companies.

00:33:56,570 --> 00:34:01,380
Git has not been around in a form where a lot of people

00:34:01,380 --> 00:34:06,570
will be comfortable using it for more than

00:34:06,570 --> 00:34:08,750
half a year or so.

00:34:08,750 --> 00:34:14,110
We have had so huge improvements to the user

00:34:14,110 --> 00:34:17,800
interfaces that realistically, a year ago at a commercial

00:34:17,800 --> 00:34:20,370
company a lot of people would just have said

00:34:20,370 --> 00:34:22,159
it's too hard to use.

00:34:22,159 --> 00:34:24,570
I think we're way past that hump.

00:34:24,570 --> 00:34:27,199
Git is much easier to use than CVS, really.

00:34:27,199 --> 00:34:29,909


00:34:29,909 --> 00:34:32,170
It's easier to use than anything else.

00:34:32,170 --> 00:34:34,199
Just get over it.

00:34:34,199 --> 00:34:36,330
You don't have to use all the powerful tools.

00:34:36,330 --> 00:34:42,699
Some of them might be things you want to explain and

00:34:42,699 --> 00:34:45,870
introduce to people only after they got over the initial hump

00:34:45,870 --> 00:34:48,250
of understanding what distribution really means.

00:34:48,250 --> 00:34:53,838
But the basic stuff is really easy to do.

00:34:53,838 --> 00:34:57,050
AUDIENCE: One characteristic of a centralized system is

00:34:57,050 --> 00:34:59,610
that it's the original developer who has to resolve

00:34:59,610 --> 00:35:01,510
any merges, who has to fix merges.

00:35:01,510 --> 00:35:02,880
How do you do that in Git and how do you

00:35:02,880 --> 00:35:04,070
minimize merge conflicts?

00:35:04,070 --> 00:35:06,050
LINUS TORVALDS: Thank you for asking me that question.

00:35:06,050 --> 00:35:08,660
Did I tell you to ask that question first?

00:35:08,660 --> 00:35:13,480
One of the really nice parts of Git is A, it does make

00:35:13,480 --> 00:35:19,030
things much easier to merge than a lot of other systems.

00:35:19,030 --> 00:35:24,190
Merging a branch in CVS tends to be really painful.

00:35:24,190 --> 00:35:27,840
One of my main statistics is the kernel is actually one of

00:35:27,840 --> 00:35:29,360
the biggest open source projects.

00:35:29,360 --> 00:35:31,320
We have 22,000 files.

00:35:31,320 --> 00:35:33,460
We've used Git for two years.

00:35:33,460 --> 00:35:36,990
During those two years, we have averaged 4.5 merges a

00:35:36,990 --> 00:35:39,980
day, every single day.

00:35:39,980 --> 00:35:41,930
That's not something you'd do in something

00:35:41,930 --> 00:35:43,450
where merging was hard.

00:35:43,450 --> 00:35:48,140
So Git makes merging easy, but you will in inevitably have

00:35:48,140 --> 00:35:55,440
cases where two maintainers send me the question to please

00:35:55,440 --> 00:35:56,160
pull my stuff.

00:35:56,160 --> 00:35:59,100
And I pick one of them at random usually, because their

00:35:59,100 --> 00:36:02,470
mail happened to be first in my mailbox, and I have pull

00:36:02,470 --> 00:36:03,710
their stuff.

00:36:03,710 --> 00:36:08,090
And another person had made changes that--

00:36:08,090 --> 00:36:12,000
it doesn't happen that often, but it does happen--

00:36:12,000 --> 00:36:18,390
just clashed so much that I said, I could fix this up but

00:36:18,390 --> 00:36:19,830
I really don't want to.

00:36:19,830 --> 00:36:23,400
I didn't write the code, it's not my area of expertise, its

00:36:23,400 --> 00:36:26,490
networking or something like that, I can't really judge it,

00:36:26,490 --> 00:36:30,200
I can't test it, so asking me to resolve the

00:36:30,200 --> 00:36:31,290
merge is just crazy.

00:36:31,290 --> 00:36:35,050
It's not how you should do things.

00:36:35,050 --> 00:36:37,350
OK, the Windows machine flaked out again.

00:36:37,350 --> 00:36:41,120


00:36:41,120 --> 00:36:44,620
Remember, distribution means nobody is special.

00:36:44,620 --> 00:36:49,430
So instead of me merging, I just push out my first tree

00:36:49,430 --> 00:36:52,880
that didn't have any merge issues and I tell the second

00:36:52,880 --> 00:36:58,250
person, hey, I tried to pull from you but I had merge

00:36:58,250 --> 00:37:00,990
conflicts and they weren't completely trivial, so I

00:37:00,990 --> 00:37:04,180
decided you get to do the honors instead.

00:37:04,180 --> 00:37:05,390
And they do.

00:37:05,390 --> 00:37:07,000
And they know what they're doing

00:37:07,000 --> 00:37:08,650
because it's their changes.

00:37:08,650 --> 00:37:11,310
So they can do the merge and they probably think I'm a

00:37:11,310 --> 00:37:14,340
moron because the merge was so easy and it was obvious I

00:37:14,340 --> 00:37:17,090
should have taken their code.

00:37:17,090 --> 00:37:20,670
But they do the merge and then they update their tree and

00:37:20,670 --> 00:37:22,710
say, hey, can you pull from me now?

00:37:22,710 --> 00:37:25,650
And I pull from them and they did all the work for me.

00:37:25,650 --> 00:37:27,160
That's what it's all about.

00:37:27,160 --> 00:37:30,370
They did all the work for me.

00:37:30,370 --> 00:37:33,560
And I take the credit.

00:37:33,560 --> 00:37:35,975
Now I just need to figure out step three, profit.

00:37:35,975 --> 00:37:39,570


00:37:39,570 --> 00:37:43,450
But that's another thing that comes very naturally from

00:37:43,450 --> 00:37:44,520
being distributed.

00:37:44,520 --> 00:37:49,200
It's not something that is special to Git.

00:37:49,200 --> 00:37:55,150
Git makes merging easier than anything else, but Git does it

00:37:55,150 --> 00:37:57,030
exactly because Git is distributed.

00:37:57,030 --> 00:37:57,825
Yes.

00:37:57,825 --> 00:38:00,940
AUDIENCE: So I guess I don't entirely understand why you

00:38:00,940 --> 00:38:06,290
think that its necessary to have a distributed system--

00:38:06,290 --> 00:38:11,510
it seems like you get a lot of the good effects, at least for

00:38:11,510 --> 00:38:12,120
corporate development.

00:38:12,120 --> 00:38:13,930
For open source development, it seems very useful that

00:38:13,930 --> 00:38:15,620
everybody can work on their own.

00:38:15,620 --> 00:38:20,430
But when you really have a centralized, corporate tree,

00:38:20,430 --> 00:38:23,500
then a centralized system with really cheap branches,

00:38:23,500 --> 00:38:25,972
wouldn't that give you pretty much the same effect?

00:38:25,972 --> 00:38:28,520
Or is that just impossible to do?

00:38:28,520 --> 00:38:29,770
LINUS TORVALDS: No.

00:38:29,770 --> 00:38:32,470


00:38:32,470 --> 00:38:35,900
I will argue that centralized systems can't work.

00:38:35,900 --> 00:38:39,380
But it is clearly true that if you're in a tightly controlled

00:38:39,380 --> 00:38:41,510
corporate environment, centralized

00:38:41,510 --> 00:38:42,900
systems work better.

00:38:42,900 --> 00:38:45,540
And it's unquestionably true that people have been able to

00:38:45,540 --> 00:38:49,010
use centralized system for the last 35 years.

00:38:49,010 --> 00:38:51,490
Nobody's really arguing that centralized

00:38:51,490 --> 00:38:53,940
systems cannot work.

00:38:53,940 --> 00:38:57,530
They cannot work as well as distributed systems. One of

00:38:57,530 --> 00:39:01,440
the issues you tend to have is centralized systems inevitably

00:39:01,440 --> 00:39:05,690
have problems when you have groups in different locations.

00:39:05,690 --> 00:39:08,280
It tends to work really well if you have a really beefy

00:39:08,280 --> 00:39:09,420
background fiber.

00:39:09,420 --> 00:39:12,740
And I guess for Google, you probably do have some kind of

00:39:12,740 --> 00:39:13,690
network going.

00:39:13,690 --> 00:39:14,680
I don't know.

00:39:14,680 --> 00:39:18,090
And maybe it's not as big of an issue as it is for other

00:39:18,090 --> 00:39:21,770
projects, but trust me.

00:39:21,770 --> 00:39:25,550
Not having to go over the network for everything is a

00:39:25,550 --> 00:39:26,820
huge performance saver.

00:39:26,820 --> 00:39:29,850


00:39:29,850 --> 00:39:32,160
I can't show you demonstrations and it's not a

00:39:32,160 --> 00:39:35,130
very interesting demonstration anyway, but this is a laptop

00:39:35,130 --> 00:39:38,270
that is what, four or five years old.

00:39:38,270 --> 00:39:41,790
It's like a Pentium M 1.6 gigahertz thing.

00:39:41,790 --> 00:39:47,210
I could show you me doing a full diff of the kernel on

00:39:47,210 --> 00:39:53,080
that laptop in whatever, just over a second.

00:39:53,080 --> 00:39:57,400
On my main machine, it takes less than 1/10 of a second.

00:39:57,400 --> 00:40:03,170
That's the kind of performance you simply cannot get if you

00:40:03,170 --> 00:40:05,260
have to go over a network.

00:40:05,260 --> 00:40:08,370
We're talking a couple of packets going over the network

00:40:08,370 --> 00:40:11,300
and you just blew the performance.

00:40:11,300 --> 00:40:15,820
So if you have a decentralized system and you're used to

00:40:15,820 --> 00:40:20,140
having something like commit or diffing the whole source

00:40:20,140 --> 00:40:24,400
tree taking 30 seconds.

00:40:24,400 --> 00:40:27,460
Maybe 30 seconds doesn't sound that bad to you.

00:40:27,460 --> 00:40:30,940
Trust me, when you're used to taking 1/10 of a second, 30

00:40:30,940 --> 00:40:33,750
seconds sounds pretty bad.

00:40:33,750 --> 00:40:37,490
So there are huge performance issues even if you have a good

00:40:37,490 --> 00:40:41,260
network, nevermind the fact that most people don't have a

00:40:41,260 --> 00:40:42,680
good network.

00:40:42,680 --> 00:40:45,550
The other thing is branches, even if you make them

00:40:45,550 --> 00:40:49,010
technically very cheap to create, just the fact that you

00:40:49,010 --> 00:40:54,050
create them and everybody sees them because everybody will

00:40:54,050 --> 00:40:57,050
see them since they're centralized, basically means

00:40:57,050 --> 00:41:00,550
that you don't want to make branches willy nilly.

00:41:00,550 --> 00:41:02,710
You will have namespace issues.

00:41:02,710 --> 00:41:04,120
What do you call your branch?

00:41:04,120 --> 00:41:05,350
Would you call it Test?

00:41:05,350 --> 00:41:09,230
Oh by the way, there's 5,000 other branches called Test 1

00:41:09,230 --> 00:41:11,410
through 5,000.

00:41:11,410 --> 00:41:14,480
So now you have to make up all these naming rules for your

00:41:14,480 --> 00:41:17,570
branches because you have a centralized system that has a

00:41:17,570 --> 00:41:21,400
centralized branch namespace, which is kind of inevitable

00:41:21,400 --> 00:41:23,970
when you have a centralized system.

00:41:23,970 --> 00:41:27,640
How does that work in distributed environments?

00:41:27,640 --> 00:41:30,710
You call your branch test, and it's that easy.

00:41:30,710 --> 00:41:32,210
Actually, you shouldn't call it tests.

00:41:32,210 --> 00:41:34,710
You should basically name your branches the way

00:41:34,710 --> 00:41:36,000
you name your functions.

00:41:36,000 --> 00:41:37,730
You should call them something short and

00:41:37,730 --> 00:41:38,840
sweet and to the point.

00:41:38,840 --> 00:41:40,510
What is that branch doing?

00:41:40,510 --> 00:41:44,630
Git, by default, gives you one branch that is called master.

00:41:44,630 --> 00:41:46,210
It's short and sweet and to the point.

00:41:46,210 --> 00:41:47,790
It's the master branch.

00:41:47,790 --> 00:41:52,000
But you can make a branch that is called Experimental Feature

00:41:52,000 --> 00:41:54,700
X and it will be obvious.

00:41:54,700 --> 00:41:57,450
But this is something you simply cannot do in a

00:41:57,450 --> 00:41:58,390
centralized environment.

00:41:58,390 --> 00:42:01,390
You cannot call branches Experimental Feature X. You

00:42:01,390 --> 00:42:04,740
have to make up stupid, idiotic names.

00:42:04,740 --> 00:42:07,930
I worked for a company that had nice--

00:42:07,930 --> 00:42:12,750
as nice as you probably can make them-- scripts around CVS

00:42:12,750 --> 00:42:14,790
that helped you make branches.

00:42:14,790 --> 00:42:16,280
You could actually make branches

00:42:16,280 --> 00:42:17,710
with a simple command.

00:42:17,710 --> 00:42:19,680
It didn't take that long.

00:42:19,680 --> 00:42:24,730
It picked a name for you, exactly because it would pick

00:42:24,730 --> 00:42:25,580
the number.

00:42:25,580 --> 00:42:29,830
So you'd give it a base name and you would say, this is my

00:42:29,830 --> 00:42:32,540
branch for doing so and so and it would call your

00:42:32,540 --> 00:42:36,100
branch So and So-56.

00:42:36,100 --> 00:42:38,630
And it would tag where you started that branch because in

00:42:38,630 --> 00:42:41,890
CVS you need to do that, too.

00:42:41,890 --> 00:42:43,970
It took a while, but it worked.

00:42:43,970 --> 00:42:47,210
You can do these things in centralized systems, but you

00:42:47,210 --> 00:42:49,100
don't need to.

00:42:49,100 --> 00:42:53,470
If your system is decentralized, it just works.

00:42:53,470 --> 00:42:55,940
That is how it should work.

00:42:55,940 --> 00:43:00,730
So I'm not going to force you to switch over to

00:43:00,730 --> 00:43:02,370
decentralized, I'm just going to call you

00:43:02,370 --> 00:43:04,670
you ugly and stupid.

00:43:04,670 --> 00:43:06,790
That's the deal.

00:43:06,790 --> 00:43:09,516
Anyway, we are on the performance slide.

00:43:09,516 --> 00:43:11,746
AUDIENCE: Can I ask a question?

00:43:11,746 --> 00:43:12,580
LINUS TORVALDS: Yes.

00:43:12,580 --> 00:43:14,340
AUDIENCE: Two questions, actually.

00:43:14,340 --> 00:43:19,510
So one is how many files will Git take.

00:43:19,510 --> 00:43:22,300
And then the second one, let's say if you have a humongous

00:43:22,300 --> 00:43:25,170
tree under Git, would it be possible to check

00:43:25,170 --> 00:43:26,610
out part of the tree?

00:43:26,610 --> 00:43:27,860
LINUS TORVALDS: Great questions.

00:43:27,860 --> 00:43:30,090


00:43:30,090 --> 00:43:33,420
Those questions actually kind of dovetail into a different

00:43:33,420 --> 00:43:36,480
issue, even though they are performance related.

00:43:36,480 --> 00:43:40,350
One of the things that Git is really special about, and this

00:43:40,350 --> 00:43:43,710
special even with regards to things like Mercurial which is

00:43:43,710 --> 00:43:48,970
otherwise fairly similar, Git tracks your content.

00:43:48,970 --> 00:43:51,440
It never, ever tracks a single file.

00:43:51,440 --> 00:43:55,450
You cannot track a file in Git.

00:43:55,450 --> 00:43:58,230
What you can do is you can track a project that has a

00:43:58,230 --> 00:44:02,180
single file, but if your project has a single file,

00:44:02,180 --> 00:44:04,730
sure do that, and you can do it.

00:44:04,730 --> 00:44:11,090
But if you track 10,000 files, Git never, ever sees those as

00:44:11,090 --> 00:44:12,740
individual files.

00:44:12,740 --> 00:44:16,100
Git thinks of everything as the full content.

00:44:16,100 --> 00:44:19,520
All history in Git is based on the content of all of the

00:44:19,520 --> 00:44:21,870
history of the whole project.

00:44:21,870 --> 00:44:26,350
This has implications for performance.

00:44:26,350 --> 00:44:29,200
When you use CVS it's perfectly fine.

00:44:29,200 --> 00:44:32,260
It's stupid, but it's perfectly fine to have one

00:44:32,260 --> 00:44:36,470
huge repository that has a million files in it because at

00:44:36,470 --> 00:44:39,140
the end of the day, CVS actually thinks of all those

00:44:39,140 --> 00:44:41,320
million files as a single file.

00:44:41,320 --> 00:44:44,570
And you can actually ask CVS to only update that one file

00:44:44,570 --> 00:44:47,300
because CVS really thinks in those terms. And that's

00:44:47,300 --> 00:44:49,960
actually true of pretty much everything else too.

00:44:49,960 --> 00:44:51,720
It is actually even true of BitKeeper.

00:44:51,720 --> 00:44:56,110
That was one of the mistakes in BitKeeper.

00:44:56,110 --> 00:44:59,590
The problem with thinking in terms of single files is that

00:44:59,590 --> 00:45:02,080
quite often, especially if you're a high level maintainer

00:45:02,080 --> 00:45:06,840
like me, I have 22,000 files to track, I don't care about

00:45:06,840 --> 00:45:08,010
one of them.

00:45:08,010 --> 00:45:13,150
I might care about a sub-collection of them that

00:45:13,150 --> 00:45:14,780
contains maybe 1,000 thousand files.

00:45:14,780 --> 00:45:18,470
I might care about the USB subsystem, but I never care

00:45:18,470 --> 00:45:20,240
about the single file.

00:45:20,240 --> 00:45:23,620
So Git tracks everything as a collection of files, and if

00:45:23,620 --> 00:45:26,550
you ask for the history of a single file, Git will

00:45:26,550 --> 00:45:28,670
literally start from the global history

00:45:28,670 --> 00:45:30,345
and simplify it.

00:45:30,345 --> 00:45:33,510
It's a fairly efficient system.

00:45:33,510 --> 00:45:34,820
It's a very efficient system.

00:45:34,820 --> 00:45:37,420
You would normally not even realize that it does that.

00:45:37,420 --> 00:45:42,160
But it does mean that if you try to track a million files

00:45:42,160 --> 00:45:46,170
in one repository, when you then ask for a single file

00:45:46,170 --> 00:45:48,620
history it's going to be slower.

00:45:48,620 --> 00:45:51,470
So it has different scaling properties than a lot of other

00:45:51,470 --> 00:45:55,670
systems for this very fundamental design reason.

00:45:55,670 --> 00:45:58,390
We have used big repositories.

00:45:58,390 --> 00:46:08,770
We've imported things like something like 3/4 of the

00:46:08,770 --> 00:46:11,360
Subversion history of the whole KDE project.

00:46:11,360 --> 00:46:12,620
And the KDE people are--

00:46:12,620 --> 00:46:19,110


00:46:19,110 --> 00:46:23,150
I like KDE but trust me, they put every single component in

00:46:23,150 --> 00:46:25,630
one repository.

00:46:25,630 --> 00:46:27,920
Not very smart.

00:46:27,920 --> 00:46:31,170
What you ended up with, you had a repository that took I

00:46:31,170 --> 00:46:36,770
think eight gigabytes under the CVS tree and Subversion

00:46:36,770 --> 00:46:40,090
blew it up to like three times that size.

00:46:40,090 --> 00:46:42,060
Maybe it wasn't quite eight gigabytes in

00:46:42,060 --> 00:46:43,540
CVS, but it was big.

00:46:43,540 --> 00:46:46,560
It was more than four gigabytes.

00:46:46,560 --> 00:46:48,710
Git would actually compress it down to

00:46:48,710 --> 00:46:50,160
something like 1.3 gigabytes.

00:46:50,160 --> 00:46:53,650
So Git is actually very efficient at taking this

00:46:53,650 --> 00:46:57,370
project and just smushing it together and most things

00:46:57,370 --> 00:46:58,980
perform very well.

00:46:58,980 --> 00:47:00,490
But certain things did not.

00:47:00,490 --> 00:47:02,910
The things that do not perform very well, if you put a

00:47:02,910 --> 00:47:06,280
million files in one repository, initial clones,

00:47:06,280 --> 00:47:08,780
when you get it, you get it all.

00:47:08,780 --> 00:47:13,540
You put it in one repository, Git thinks of it as one thing.

00:47:13,540 --> 00:47:14,930
Don't do that.

00:47:14,930 --> 00:47:17,540
If you have multiple components, do them as

00:47:17,540 --> 00:47:19,000
separate repositories.

00:47:19,000 --> 00:47:22,180
You can actually have what we call a super project that

00:47:22,180 --> 00:47:25,210
contains pointers to other projects and the user

00:47:25,210 --> 00:47:28,060
interfaces there are some lacking.

00:47:28,060 --> 00:47:31,920
But you keep separate projects separate, and then you avoid

00:47:31,920 --> 00:47:35,200
the problem of, OK, you have to get it all.

00:47:35,200 --> 00:47:37,100
Because with Git, you do have to get it all.

00:47:37,100 --> 00:47:40,042
AUDIENCE: Why don't they all share code?

00:47:40,042 --> 00:47:42,447
[INAUDIBLE]?

00:47:42,447 --> 00:47:45,410
LINUS TORVALDS: If they all shared code.

00:47:45,410 --> 00:47:47,830
What you can do with Git, if you actually have a lot of

00:47:47,830 --> 00:47:50,690
shared stuff, since Git actually internally uses a

00:47:50,690 --> 00:47:54,970
content-addressable file system, if there are files

00:47:54,970 --> 00:47:57,800
with identical content, Git will actually use the exact

00:47:57,800 --> 00:48:01,580
same object for them and save you tons of space.

00:48:01,580 --> 00:48:06,380
You can have these shared objects and still have them as

00:48:06,380 --> 00:48:07,670
separate entities.

00:48:07,670 --> 00:48:10,220
You can still see them at separate repositories that

00:48:10,220 --> 00:48:13,260
just have a shared file system backing the

00:48:13,260 --> 00:48:16,190
data, you can do that.

00:48:16,190 --> 00:48:18,480
If you actually have shared code in the sense that you,

00:48:18,480 --> 00:48:22,320
for example, have a library that is used by five different

00:48:22,320 --> 00:48:26,870
things, that's when you use the super project support,

00:48:26,870 --> 00:48:30,290
where you have one Git repository that just tracks

00:48:30,290 --> 00:48:31,740
all the other Git repositories.

00:48:31,740 --> 00:48:34,450
It may contain stuff like a shared build

00:48:34,450 --> 00:48:36,340
infrastructure, too.

00:48:36,340 --> 00:48:39,690
But then the individual pieces are individual.

00:48:39,690 --> 00:48:42,000
These are like CVS modules.

00:48:42,000 --> 00:48:47,990
In CVS, modules aren't really individual but that's because

00:48:47,990 --> 00:48:52,810
in CVS, the directory is a thing of its own anyway.

00:48:52,810 --> 00:48:58,080
So CVS modules are kind of a combination of this and just

00:48:58,080 --> 00:48:59,250
tracking them all.

00:48:59,250 --> 00:49:02,350
But you can basically think of it as CVS modules.

00:49:02,350 --> 00:49:05,460
And we do support it but I do have to admit, that code is

00:49:05,460 --> 00:49:09,430
fairly recent and that's one area where our user interfaces

00:49:09,430 --> 00:49:13,890
right now are definitely lacking some.

00:49:13,890 --> 00:49:16,410
There was probably some other part to that question that I

00:49:16,410 --> 00:49:18,470
completely forgot.

00:49:18,470 --> 00:49:19,720
AUDIENCE: [INAUDIBLE].

00:49:19,720 --> 00:49:22,547


00:49:22,547 --> 00:49:26,160
LINUS TORVALDS: I can't hear that.

00:49:26,160 --> 00:49:29,430
AUDIENCE: The question was, can you have just part of the

00:49:29,430 --> 00:49:32,750
files pulled out of the repository, not the entire

00:49:32,750 --> 00:49:35,198
repository?

00:49:35,198 --> 00:49:38,110
LINUS TORVALDS: You can export things as tarballs, you can

00:49:38,110 --> 00:49:40,170
export things as individual files.

00:49:40,170 --> 00:49:44,510
You can rewrite the whole history to say, I want a new

00:49:44,510 --> 00:49:47,320
version of that repository that only contains that part.

00:49:47,320 --> 00:49:48,210
You can do that.

00:49:48,210 --> 00:49:50,090
It's a fairly expensive operation.

00:49:50,090 --> 00:49:53,550
It's something you would do, for example, if you import an

00:49:53,550 --> 00:49:57,430
old repository into one huge Git repository and then you

00:49:57,430 --> 00:50:01,300
can split it later on to be multiple, smaller ones.

00:50:01,300 --> 00:50:03,650
You can do it.

00:50:03,650 --> 00:50:05,630
What I'm trying to say, you should generally

00:50:05,630 --> 00:50:08,030
try to avoid it.

00:50:08,030 --> 00:50:12,440
It's not that Git can't handle huge projects, it's that Git

00:50:12,440 --> 00:50:17,430
won't perform as well as it would otherwise and you will

00:50:17,430 --> 00:50:22,710
have issues that you wish you didn't have.

00:50:22,710 --> 00:50:26,200
I'm skipping this and going back to the performance issue.

00:50:26,200 --> 00:50:29,200
One of the things I want to say about performance is a lot

00:50:29,200 --> 00:50:32,120
of people seem to think that performance is about doing the

00:50:32,120 --> 00:50:34,230
same thing, just doing it faster.

00:50:34,230 --> 00:50:35,440
And that's not true.

00:50:35,440 --> 00:50:37,720
That's not what performance is all about.

00:50:37,720 --> 00:50:42,050
If you can do something really fast really well, people start

00:50:42,050 --> 00:50:44,860
using it differently.

00:50:44,860 --> 00:50:48,510
One of the things I wanted to make sure is that merges go

00:50:48,510 --> 00:50:51,920
really, really quickly because I want people to merge often

00:50:51,920 --> 00:50:55,790
and merge early because it turns out it

00:50:55,790 --> 00:50:57,140
becomes easier to merge.

00:50:57,140 --> 00:51:00,950
If you merge every day, suddenly you never get to the

00:51:00,950 --> 00:51:02,730
point where you have huge conflicts

00:51:02,730 --> 00:51:04,290
that are hard to resolve.

00:51:04,290 --> 00:51:10,260
If you actually make branching and merging easy, you actually

00:51:10,260 --> 00:51:13,450
avoid a whole class of problems that you otherwise

00:51:13,450 --> 00:51:15,720
have a really, really hard time avoiding.

00:51:15,720 --> 00:51:20,360
So for example, let's go back to one of the things where I

00:51:20,360 --> 00:51:22,160
think the designers of Subversion

00:51:22,160 --> 00:51:24,870
were complete morons.

00:51:24,870 --> 00:51:25,860
Strong opinions.

00:51:25,860 --> 00:51:27,656
That's me, right?

00:51:27,656 --> 00:51:31,960
There's a few of them in the room today, I suspect.

00:51:31,960 --> 00:51:34,550
You're stupid.

00:51:34,550 --> 00:51:39,990
Subversion, for example, talks very loudly about how they do

00:51:39,990 --> 00:51:44,890
CVS right by making branching really cheap.

00:51:44,890 --> 00:51:47,830
It's probably on their main web page where they probably

00:51:47,830 --> 00:51:51,770
say that branching in Subversion is an 01 operation.

00:51:51,770 --> 00:51:54,480
You can do as many cheap branches as you want.

00:51:54,480 --> 00:51:56,810
Nevermind that the 01 is actually a

00:51:56,810 --> 00:51:58,260
pretty large 0 I think.

00:51:58,260 --> 00:52:03,510
But even if it takes a millionth of a second to do

00:52:03,510 --> 00:52:06,900
branching, who cares?

00:52:06,900 --> 00:52:09,300
It's the wrong thing you're measuring.

00:52:09,300 --> 00:52:11,340
Nobody is interest in branching.

00:52:11,340 --> 00:52:14,230
Branches are completely useless unless you merge them,

00:52:14,230 --> 00:52:19,300
and CVS cannot merge anything at all.

00:52:19,300 --> 00:52:23,170
You can merge things once, but because CVS then forgets what

00:52:23,170 --> 00:52:27,190
you did, you can never, ever merge anything again without

00:52:27,190 --> 00:52:30,210
getting horrible, horrible conflicts.

00:52:30,210 --> 00:52:34,020
Merging in Subversion is a complete disaster.

00:52:34,020 --> 00:52:36,760
The Subversion people kind of acknowledge this and they have

00:52:36,760 --> 00:52:40,190
a plan and their plan sucks, too.

00:52:40,190 --> 00:52:43,960
It is incredible how stupid these people are.

00:52:43,960 --> 00:52:47,690
They've been looking at the wrong problem all the time.

00:52:47,690 --> 00:52:51,950
Branching is not the issue, merging is, and merging they

00:52:51,950 --> 00:52:56,080
didn't do squat for five years after the fact.

00:52:56,080 --> 00:52:57,780
That is sad.

00:52:57,780 --> 00:53:00,670
So performance is important, but you need to

00:53:00,670 --> 00:53:03,360
look at what matters.

00:53:03,360 --> 00:53:07,000
Performance for making a branch under Git, literally

00:53:07,000 --> 00:53:11,220
you create a new file that is 41 bytes in size.

00:53:11,220 --> 00:53:13,980
How fast do you think that is?

00:53:13,980 --> 00:53:16,710
I don't think you can measure it.

00:53:16,710 --> 00:53:18,320
If you use Windows you can probably

00:53:18,320 --> 00:53:19,650
measure it because file--

00:53:19,650 --> 00:53:20,910
but whatever.

00:53:20,910 --> 00:53:23,810
It is so fast you can't really measure it.

00:53:23,810 --> 00:53:25,900
That's creating a branch.

00:53:25,900 --> 00:53:28,330
Nobody cares.

00:53:28,330 --> 00:53:30,420
It's not an issue.

00:53:30,420 --> 00:53:32,690
That's not it.

00:53:32,690 --> 00:53:36,910
The only thing that matters is how fast can you merge?

00:53:36,910 --> 00:53:43,080
In Git I merge 22,000 several times a day and I get unhappy

00:53:43,080 --> 00:53:45,720
if a merge takes more than five seconds.

00:53:45,720 --> 00:53:49,580
And all of those five seconds are just the downloading of

00:53:49,580 --> 00:53:53,830
the deltas between the two trees.

00:53:53,830 --> 00:53:58,190
The merge itself takes less than half a second, and I

00:53:58,190 --> 00:54:00,910
don't have to think about it.

00:54:00,910 --> 00:54:04,220
What takes longer than the merge is after every merge by

00:54:04,220 --> 00:54:06,720
default, Git will do a diff stat of everything that

00:54:06,720 --> 00:54:09,570
changed as a result of that merge because I

00:54:09,570 --> 00:54:10,990
do care about that.

00:54:10,990 --> 00:54:13,580
When I merged from somebody, I trust them.

00:54:13,580 --> 00:54:16,140
But on the other hand, hey, they might have stopped using

00:54:16,140 --> 00:54:17,940
their medication.

00:54:17,940 --> 00:54:22,020
I mean, I trust them, but let's just be honest here.

00:54:22,020 --> 00:54:23,630
They might have been OK yesterday,

00:54:23,630 --> 00:54:25,380
today not a good day.

00:54:25,380 --> 00:54:28,500
So I do a diff stat and Git does that by default.

00:54:28,500 --> 00:54:30,530
You can turn it off if you really want to, but you

00:54:30,530 --> 00:54:31,330
probably shouldn't.

00:54:31,330 --> 00:54:34,230
It's fast enough anyway.

00:54:34,230 --> 00:54:37,210
If it's a big merge, the diff stat usually takes a second or

00:54:37,210 --> 00:54:40,990
two because creating a diff and actually doing all the

00:54:40,990 --> 00:54:44,620
stats on how many lines changed, that actually is much

00:54:44,620 --> 00:54:47,310
more expensive than doing the merge itself.

00:54:47,310 --> 00:54:49,520
That is the kind of performance that actually

00:54:49,520 --> 00:54:51,230
changes how you work.

00:54:51,230 --> 00:54:54,990
It's no longer doing the same thing faster, it's allowing

00:54:54,990 --> 00:54:58,440
you to work in a completely different manner, and that is

00:54:58,440 --> 00:55:01,660
why performance matters and why you really shouldn't look

00:55:01,660 --> 00:55:03,380
at anything but Git.

00:55:03,380 --> 00:55:08,850
Hg's Mercurial is pretty good, but Git is better.

00:55:08,850 --> 00:55:12,270
I think I'm running out of time.

00:55:12,270 --> 00:55:14,680
OK, this one is still interesting.

00:55:14,680 --> 00:55:16,300
We never got to the implementation part, you

00:55:16,300 --> 00:55:17,970
really don't care.

00:55:17,970 --> 00:55:20,130
I will say so much about implementation is the

00:55:20,130 --> 00:55:22,000
implementation is really simple.

00:55:22,000 --> 00:55:26,700
The code data structures are really, really, really simple.

00:55:26,700 --> 00:55:32,950
If you then look at the source code and realize it's 80,000

00:55:32,950 --> 00:55:37,370
lines and mostly in C. And the kind of C I write most people

00:55:37,370 --> 00:55:40,410
don't understand, but I commented.

00:55:40,410 --> 00:55:43,640
The source code may sometimes look complicated because we

00:55:43,640 --> 00:55:46,800
are very performance-centric.

00:55:46,800 --> 00:55:48,180
I am, I really care.

00:55:48,180 --> 00:55:51,680
And sometimes to make things go really fast, you have to

00:55:51,680 --> 00:55:54,690
use more complicated algorithms than just checking

00:55:54,690 --> 00:55:56,060
one file at the time.

00:55:56,060 --> 00:55:59,300
When you're doing 22,000-file merges, you don't want to

00:55:59,300 --> 00:56:00,630
check one file at a time.

00:56:00,630 --> 00:56:03,320
You want to check the whole three in one go and say,

00:56:03,320 --> 00:56:06,470
they're the same, I didn't need to do anything.

00:56:06,470 --> 00:56:08,760
So Git does things like that and that kind of blows the

00:56:08,760 --> 00:56:12,650
source code up a bit because doing it well is complicated.

00:56:12,650 --> 00:56:16,360
But the basics are really, really simple, and one of the

00:56:16,360 --> 00:56:20,040
basics is this trust and reliability thing.

00:56:20,040 --> 00:56:25,600
Every single piece of data, when Git tracks your content,

00:56:25,600 --> 00:56:28,430
we compress it, we delta it against everything else.

00:56:28,430 --> 00:56:33,190
But we also do a SHA-1 hash of the content, and we actually

00:56:33,190 --> 00:56:35,230
check it when we use it.

00:56:35,230 --> 00:56:39,100
If you have disk corruption, if you have DRAM corruption,

00:56:39,100 --> 00:56:43,140
if you have any kind of problems at all, Git will

00:56:43,140 --> 00:56:44,110
notice them.

00:56:44,110 --> 00:56:47,830
It's not a question of if, it's a guarantee.

00:56:47,830 --> 00:56:51,100
You can have people who try to be malicious.

00:56:51,100 --> 00:56:53,560
They won't succeed.

00:56:53,560 --> 00:56:57,850
You need to know exactly 20 bytes, you need to know the

00:56:57,850 --> 00:57:04,480
160-bit SHA-1 name of your top of tree, and if you know that,

00:57:04,480 --> 00:57:06,950
you can trust your tree all the way

00:57:06,950 --> 00:57:08,520
down, the whole history.

00:57:08,520 --> 00:57:11,450
You can have 10 years of history, you can have 100,000

00:57:11,450 --> 00:57:14,440
files, you can have millions of revisions, and you can

00:57:14,440 --> 00:57:20,560
trust every single piece of it because Git is so reliable and

00:57:20,560 --> 00:57:24,060
all the basic data structures are really, really simple.

00:57:24,060 --> 00:57:26,300
And we check checksums.

00:57:26,300 --> 00:57:32,650
And we don't just check some piddly UDP packet checksum

00:57:32,650 --> 00:57:36,180
that is a 16-bit sum of all the bytes.

00:57:36,180 --> 00:57:39,430
We check a checksum that is considered

00:57:39,430 --> 00:57:41,610
cryptographically secure.

00:57:41,610 --> 00:57:45,290
Nobody has been able to break SHA-1, but the point is the

00:57:45,290 --> 00:57:47,950
SHA-1, as far as Git is concerned, isn't even a

00:57:47,950 --> 00:57:49,570
security feature.

00:57:49,570 --> 00:57:53,530
It's purely a consistency check.

00:57:53,530 --> 00:57:58,380
The security parts are elsewhere, so a lot of people

00:57:58,380 --> 00:58:03,240
assume that since Git uses SHA-1 and SHA-1 is used for

00:58:03,240 --> 00:58:06,040
cryptographically secure stuff, they think that, OK,

00:58:06,040 --> 00:58:08,840
it's a huge security feature.

00:58:08,840 --> 00:58:11,330
It has nothing at all to do with security, it's just the

00:58:11,330 --> 00:58:14,090
best hash you can get.

00:58:14,090 --> 00:58:17,685
Having a good hash is good for being able to trust your data.

00:58:17,685 --> 00:58:21,360
It happens to have some other good features, too.

00:58:21,360 --> 00:58:23,630
It means that when we hash objects, we know that the

00:58:23,630 --> 00:58:26,600
hashes are actually well-distributed and we don't

00:58:26,600 --> 00:58:28,530
have to worry about certain distribution issues.

00:58:28,530 --> 00:58:32,130
So internally, it means from an implementation standpoint

00:58:32,130 --> 00:58:36,600
we can trust that the hashes are so good that we can use

00:58:36,600 --> 00:58:39,750
hashing algorithms and know that there are no bad cases.

00:58:39,750 --> 00:58:43,000
So there are some reasons to like the

00:58:43,000 --> 00:58:44,830
cryptographic site, too.

00:58:44,830 --> 00:58:50,040
But it's really about the ability to trust your data.

00:58:50,040 --> 00:58:55,590
I guarantee you, if you put your data in Git, you can

00:58:55,590 --> 00:58:58,850
trust the fact that five years later, after it was converted

00:58:58,850 --> 00:59:03,580
from your hard disk to DVD to whatever new technology and

00:59:03,580 --> 00:59:06,990
you copied it along, five years later you can verify

00:59:06,990 --> 00:59:10,610
that the data you get back out is the exact same

00:59:10,610 --> 00:59:11,680
data you put in.

00:59:11,680 --> 00:59:13,910
And that's something you really should look for in a

00:59:13,910 --> 00:59:16,030
source control management system.

00:59:16,030 --> 00:59:20,370
One of the reasons I care is for the kernel, we had a break

00:59:20,370 --> 00:59:27,550
in on one of the BitKeeper sites where people tried to

00:59:27,550 --> 00:59:30,410
corrupt the kernel source code repositories.

00:59:30,410 --> 00:59:31,970
And BitKeeper actually caught it.

00:59:31,970 --> 00:59:35,760
BitKeeper did not have a really fancy hash at all.

00:59:35,760 --> 00:59:40,370
I think it's a 16-bit CRC, something like that.

00:59:40,370 --> 00:59:46,750
But it was good enough that you could actually see clumsy.

00:59:46,750 --> 00:59:49,830
It was not cryptographically secure, but it was hard enough

00:59:49,830 --> 00:59:55,695
in practice to overcome that it was caught immediately.

00:59:55,695 --> 00:59:58,800


00:59:58,800 --> 01:00:04,470
When that happens once to you, you got burnt once, you don't

01:00:04,470 --> 01:00:06,140
ever want to get burnt again.

01:00:06,140 --> 01:00:08,770
Maybe your projects aren't that important.

01:00:08,770 --> 01:00:12,220
My projects, they're important.

01:00:12,220 --> 01:00:14,780
There's a reason I care.

01:00:14,780 --> 01:00:17,470
This is also one of the reasons to go back to the

01:00:17,470 --> 01:00:20,290
distribution angle a bit.

01:00:20,290 --> 01:00:23,670
When you do Google, for example, Google code, you have

01:00:23,670 --> 01:00:28,100
your source repositories that you help people maintain, and

01:00:28,100 --> 01:00:29,450
I think you do so under Subversion.

01:00:29,450 --> 01:00:32,750


01:00:32,750 --> 01:00:36,030
I would never, ever trust Google to maintain my source

01:00:36,030 --> 01:00:37,130
code for me.

01:00:37,130 --> 01:00:38,030
I'm sorry.

01:00:38,030 --> 01:00:39,325
You're just not that trustworthy.

01:00:39,325 --> 01:00:42,030


01:00:42,030 --> 01:00:46,820
The reason I really prefer a distributed system is I can

01:00:46,820 --> 01:00:51,600
keep my source code behind three firewalls on a system

01:00:51,600 --> 01:00:55,530
that does not allow SSH in at all.

01:00:55,530 --> 01:00:59,450
When I'm here, I cannot read my email because my email goes

01:00:59,450 --> 01:01:03,550
onto my machine, and the only way I can get into that

01:01:03,550 --> 01:01:06,390
machine is when I'm physically on that network.

01:01:06,390 --> 01:01:09,780
So maybe I'm cuckoo, maybe I'm a bit crazy and I care about

01:01:09,780 --> 01:01:12,330
security more than most people do.

01:01:12,330 --> 01:01:17,700
But this whole notion that I would give the master copy of

01:01:17,700 --> 01:01:21,260
source code that I trust and I care about so much, and I

01:01:21,260 --> 01:01:25,080
would give it to a third party is ludicrous.

01:01:25,080 --> 01:01:29,170
Not even Google, not a way in hell would I do that.

01:01:29,170 --> 01:01:33,160
I allow Google to have a copy of it, but I want to have

01:01:33,160 --> 01:01:36,930
something that I know nobody touched.

01:01:36,930 --> 01:01:39,885
And by the way, I'm not a great MIS person, so the disk

01:01:39,885 --> 01:01:43,310
corruption issue is definitely a case that I might worry

01:01:43,310 --> 01:01:45,190
about because I don't do backups.

01:01:45,190 --> 01:01:50,640
So it's OK if I can then download it again from

01:01:50,640 --> 01:01:52,340
multiple trusted parties.

01:01:52,340 --> 01:01:54,680
I can verify them against each other, that

01:01:54,680 --> 01:01:55,700
part is really easy.

01:01:55,700 --> 01:01:58,790
I can verify them against hopefully that 20 bytes that I

01:01:58,790 --> 01:02:00,240
really, really cared about.

01:02:00,240 --> 01:02:02,460
Hopefully I have that in a few places.

01:02:02,460 --> 01:02:07,200
20 bytes is easier to track than 180 megabytes and

01:02:07,200 --> 01:02:09,440
corruption is less likely to hit those 20 bytes.

01:02:09,440 --> 01:02:14,040
If I have those 20 bytes, I can download a Git repository

01:02:14,040 --> 01:02:19,390
form a completely untrusted source and I can guarantee

01:02:19,390 --> 01:02:22,140
that they didn't do anything bad to it.

01:02:22,140 --> 01:02:24,520
That's a huge thing, and that's something that when you

01:02:24,520 --> 01:02:28,950
do hosted repositories for other people, if you use

01:02:28,950 --> 01:02:32,260
Subversion you're just not doing it right.

01:02:32,260 --> 01:02:36,230
You're not allowing them to sleep well at night.

01:02:36,230 --> 01:02:42,290
Of course, if you do it for 75,000 projects, most of them

01:02:42,290 --> 01:02:43,560
are probably pretty small and not very

01:02:43,560 --> 01:02:44,810
important, so it's OK.

01:02:44,810 --> 01:02:47,420


01:02:47,420 --> 01:02:50,600
That should make people feel better.

01:02:50,600 --> 01:02:51,660
I have a few more slides.

01:02:51,660 --> 01:02:54,610
I think we're over time.

01:02:54,610 --> 01:02:56,860
I'm not even going to bother showing them, they're not that

01:02:56,860 --> 01:02:58,110
interesting I think.

01:02:58,110 --> 01:03:00,820


01:03:00,820 --> 01:03:07,630
I talked a bit about this, about content versus

01:03:07,630 --> 01:03:08,840
individual files.

01:03:08,840 --> 01:03:10,090
Git tracks content.

01:03:10,090 --> 01:03:12,940


01:03:12,940 --> 01:03:18,240
There is the only sample command line in the whole

01:03:18,240 --> 01:03:19,550
presentation.

01:03:19,550 --> 01:03:24,430
Gitk is the graphical viewer of history of a Git project.

01:03:24,430 --> 01:03:28,280
It's a [UNINTELLIGIBLE]

01:03:28,280 --> 01:03:32,980
script that is really only doing viewing of stuff that

01:03:32,980 --> 01:03:35,890
Git is really good at showing you.

01:03:35,890 --> 01:03:39,560
And this is the kind of command line I use as a

01:03:39,560 --> 01:03:41,310
top-level maintainer.

01:03:41,310 --> 01:03:46,760
I want to be able to say what changed since a particular

01:03:46,760 --> 01:03:49,270
version, maybe since a particular date, I can do that

01:03:49,270 --> 01:03:53,250
easily, in those two directories or in those two

01:03:53,250 --> 01:03:55,420
directories and that file.

01:03:55,420 --> 01:04:01,010
And what this will show me is the global history as it

01:04:01,010 --> 01:04:04,480
pertains to those parts of the repository.

01:04:04,480 --> 01:04:08,920
It is more expensive to compute than the global,

01:04:08,920 --> 01:04:16,180
global history, but if my laptop was actually connected

01:04:16,180 --> 01:04:18,570
to the A/V system, I could show you.

01:04:18,570 --> 01:04:22,430
Even on that laptop, it comes up in seconds.

01:04:22,430 --> 01:04:24,350
It is that expensive, but we are that good.

01:04:24,350 --> 01:04:27,110


01:04:27,110 --> 01:04:29,470
This is something that is really, really unique to get.

01:04:29,470 --> 01:04:30,880
Nobody else can do it.

01:04:30,880 --> 01:04:34,120
And it's a hugely important feature.

01:04:34,120 --> 01:04:37,300
Maybe it's not so important to individual developers because

01:04:37,300 --> 01:04:41,070
individual developers often do think in terms of single

01:04:41,070 --> 01:04:48,590
files, but it is important for the people who merge stuff, it

01:04:48,590 --> 01:04:52,060
is important for people like me and the people I work with

01:04:52,060 --> 01:04:55,200
directly because they never basically care

01:04:55,200 --> 01:04:56,230
about a single file.

01:04:56,230 --> 01:04:58,500
And they do care about these kinds of features.

01:04:58,500 --> 01:05:01,820
Somebody sends a bug report, which bug reports are usually

01:05:01,820 --> 01:05:02,760
not very good.

01:05:02,760 --> 01:05:05,530
But maybe the bug report is good enough that you can

01:05:05,530 --> 01:05:08,150
pinpoint, OK, scuzzy subsystem.

01:05:08,150 --> 01:05:10,090
That's the command line.

01:05:10,090 --> 01:05:14,700
You can't say which file, but you can do this and say, OK,

01:05:14,700 --> 01:05:21,230
that will cut it down from the 15,000 commits we've had since

01:05:21,230 --> 01:05:24,620
last week, it will cut it down to 50.

01:05:24,620 --> 01:05:26,380
That's a huge deal.

01:05:26,380 --> 01:05:30,040
That is something that nobody else can do, I guarantee you.

01:05:30,040 --> 01:05:32,620


01:05:32,620 --> 01:05:35,000
So that's the reason you want to use Git.

01:05:35,000 --> 01:05:36,170
That's what it all boils down to.

01:05:36,170 --> 01:05:39,430
It's safe, it is so fast that you can do things that nobody

01:05:39,430 --> 01:05:43,770
else can do, it does things that nobody else can do, even

01:05:43,770 --> 01:05:46,940
slowly, and it's distributed.

01:05:46,940 --> 01:05:49,180
So go and spread the word.

01:05:49,180 --> 01:05:50,850
We have one more question, I guess.

01:05:50,850 --> 01:05:51,980
What is the timing like?

01:05:51,980 --> 01:05:53,691
I don't know.

01:05:53,691 --> 01:05:55,160
AUDIENCE: Quickly.

01:05:55,160 --> 01:05:59,080
So one of the reasons why we would switch from Perforce is

01:05:59,080 --> 01:06:01,500
release capability and performance.

01:06:01,500 --> 01:06:05,710
Otherwise, people would just say, keep using it.

01:06:05,710 --> 01:06:08,870
Would we be exchanging one set of scalability performance

01:06:08,870 --> 01:06:13,720
problems for other scalability performance problems?

01:06:13,720 --> 01:06:16,450
LINUS TORVALDS: I already mentioned the fact that I

01:06:16,450 --> 01:06:20,260
don't know how you maintain stuff in Perforce, but when

01:06:20,260 --> 01:06:23,370
and if you do a switchover to Git, what you want to make

01:06:23,370 --> 01:06:26,810
sure is because of this content model, you need to do

01:06:26,810 --> 01:06:30,510
it at same content boundaries.

01:06:30,510 --> 01:06:32,890
The content boundaries usually are actually pretty

01:06:32,890 --> 01:06:33,710
self-obvious.

01:06:33,710 --> 01:06:35,000
I mean, they really are.

01:06:35,000 --> 01:06:39,730
You have the compiler, you have the main source, you have

01:06:39,730 --> 01:06:41,230
the documentation.

01:06:41,230 --> 01:06:43,880
Well, you probably have the documentation spread out, but

01:06:43,880 --> 01:06:48,030
you may have some user visible documentation.

01:06:48,030 --> 01:06:49,190
Or maybe Google doesn't.

01:06:49,190 --> 01:06:52,580
But a lot of companies have a separate set of documentation

01:06:52,580 --> 01:06:55,010
that they give to customers, and then they have the

01:06:55,010 --> 01:06:58,630
documentation that goes into each individual package, is

01:06:58,630 --> 01:07:00,590
package-based.

01:07:00,590 --> 01:07:04,250
So one of the things you do have to think about with Git

01:07:04,250 --> 01:07:09,080
is you want to make sure it is in a somewhat sane hierarchy.

01:07:09,080 --> 01:07:11,750


01:07:11,750 --> 01:07:14,690
Git can easily handle larger projects.

01:07:14,690 --> 01:07:20,090
You can have 10,000 files and that's not a problem.

01:07:20,090 --> 01:07:25,850
The kernel is 22, we've done tests with 100, it's fine.

01:07:25,850 --> 01:07:28,480
It's faster than anything else.

01:07:28,480 --> 01:07:33,440
With a million files, I suspect other systems will be

01:07:33,440 --> 01:07:35,290
faster at some things.

01:07:35,290 --> 01:07:36,850
And that's the kind of situation I don't

01:07:36,850 --> 01:07:38,820
want you to get into.

01:07:38,820 --> 01:07:42,950
But if you do that basic setup correctly, it will be

01:07:42,950 --> 01:07:47,430
basically faster at pretty much everything, than anything

01:07:47,430 --> 01:07:48,540
anybody else will.

01:07:48,540 --> 01:07:52,010
I am very confident about Git performance.

01:07:52,010 --> 01:07:56,185
One of the things we don't necessarily do really well is

01:07:56,185 --> 01:07:58,410
the CVS Annotate.

01:07:58,410 --> 01:08:01,800
People use CVS Annotate a lot if they use CVS. I'm told it

01:08:01,800 --> 01:08:05,380
sucks under Perforce, too, so you probably don't use the

01:08:05,380 --> 01:08:09,280
Perforce version of Annotate, I'm not sure.

01:08:09,280 --> 01:08:11,660
But CVS users are used to CVS Annotate.

01:08:11,660 --> 01:08:15,520
It's the one operation that CVS can do faster than Git,

01:08:15,520 --> 01:08:19,140
because CVS does track things one file at a time.

01:08:19,140 --> 01:08:20,069
Git doesn't.

01:08:20,069 --> 01:08:26,920
Git has an annotate, but if you moved a function from one

01:08:26,920 --> 01:08:32,359
file to another, Git will literally tell you the history

01:08:32,359 --> 01:08:35,010
of that function even across that move.

01:08:35,010 --> 01:08:38,970
Not to file move, a function within a file.

01:08:38,970 --> 01:08:41,970
It will go and dig back and say, hey, those two lines

01:08:41,970 --> 01:08:44,689
actually came from that other file five years ago.

01:08:44,689 --> 01:08:47,140
That is, again, something nobody else can do and it

01:08:47,140 --> 01:08:48,560
boils down to the same thing.

01:08:48,560 --> 01:08:51,380
It's the content that matter, it's not actually the files.

01:08:51,380 --> 01:08:54,350
But it does make it a much more expensive operation, so

01:08:54,350 --> 01:08:57,620
if you go back five years maybe it takes 30 seconds.

01:08:57,620 --> 01:09:01,460
On the kernel, it takes a second for any file I have. We

01:09:01,460 --> 01:09:05,220
started from no history two years ago because we just made

01:09:05,220 --> 01:09:08,080
the decision that let's not make it more complicated than

01:09:08,080 --> 01:09:08,660
it needs to be.

01:09:08,660 --> 01:09:10,580
So right now, we only have two years of

01:09:10,580 --> 01:09:12,359
history in the kernel.

01:09:12,359 --> 01:09:16,149
We have more history in other projects that we've done

01:09:16,149 --> 01:09:16,930
timings on.

01:09:16,930 --> 01:09:20,700
So we've done timings on importing the KDE and things

01:09:20,700 --> 01:09:21,950
like that with more history.

01:09:21,950 --> 01:09:25,470


01:09:25,470 --> 01:09:30,165
There are performance issues, but most of them are, Git is

01:09:30,165 --> 01:09:32,229
one or two orders of magnitude faster.

01:09:32,229 --> 01:09:36,520
So most of them are the good kind.

01:09:36,520 --> 01:09:39,359
And if you find something, we actually have a really, really

01:09:39,359 --> 01:09:40,640
good community.

01:09:40,640 --> 01:09:45,810
The Git mailing list is fairly high signal to noise.

01:09:45,810 --> 01:09:49,040
It does get a fair amount of emails, but it's actually a

01:09:49,040 --> 01:09:52,970
very pleasant mailing list. If anybody is interested, read

01:09:52,970 --> 01:09:55,440
the sources first, but start looking at the

01:09:55,440 --> 01:09:58,120
mailing list archives.

01:09:58,120 --> 01:10:00,740
We have our flames, we have are pointless discussions, but

01:10:00,740 --> 01:10:02,170
most of it is actually very good.

01:10:02,170 --> 01:10:05,190


01:10:05,190 --> 01:10:06,690
OK.

01:10:06,690 --> 01:10:07,940
Thanks.


YouTube URL: https://www.youtube.com/watch?v=4XpnKHJAok8


