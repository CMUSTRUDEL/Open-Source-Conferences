Title: Future-proofing Collections: From Mutable to Persistent to Parallel
Publication date: 2010-12-13
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talk
November 30, 2010

Presented by Martin Odersky
http://people.epfl.ch/martin.odersky

ABSTRACT

Multicore processors are on every desk now. How are we going to make use of the extra power they provide? Some think that actors or transactional memory will save the day by making concurrent programming easier and safer. Even though these are welcome, I am skeptical about their ultimate success. Concurrency is fundamentally hard and no dressing up will be able to hide that fact completely.

A safer and for the programmer much simpler alternative is to treat parallel execution as essentially an optimization. A promising application area are collections. Programing by transforming and aggregating collections is simple, powerful, and can optimized by executing bulk operations in parallel. To be able to do this in practice, any side effects of parallel operations need to be carefully controlled. This means that immutable, persistent collections are more suitable than mutable ones.

In this talk I will describe the new Scala collections framework, and show how it allows a seamless migration from traditional mutable collections to persistent collections, and from there to parallel collections. I show how the same vocabulary of methods can be used for either type of collection, and how one have parallel as well as sequential views on the same underlying collection.
Captions: 
	00:00:24,470 --> 00:00:33,120
welcome they professor of their ski in

00:00:28,910 --> 00:00:35,820
SD is your speaker's busco about future

00:00:33,120 --> 00:00:45,870
proofing collections um so I don't want

00:00:35,820 --> 00:00:47,670
to waste any time on me okay thanks we

00:00:45,870 --> 00:00:49,710
directly over here so I guess your heads

00:00:47,670 --> 00:00:53,519
with go ping pongs on this ticket to the

00:00:49,710 --> 00:00:55,710
screen but we'll make it work okay so my

00:00:53,519 --> 00:00:57,660
talk is about future cooking collections

00:00:55,710 --> 00:01:00,180
from you able to persistent in however

00:00:57,660 --> 00:01:03,120
and it's essentially a story of what we

00:01:00,180 --> 00:01:06,119
will be scholar collections have taken

00:01:03,120 --> 00:01:07,860
the development of those collections so

00:01:06,119 --> 00:01:11,070
I say a couple of words about Scala

00:01:07,860 --> 00:01:15,180
first how many of in this room actually

00:01:11,070 --> 00:01:18,090
have already witnessed calico of them

00:01:15,180 --> 00:01:21,750
and carry good hidden valley wall

00:01:18,090 --> 00:01:24,060
surface so widely used in Google okay so

00:01:21,750 --> 00:01:26,220
but a little bit of his career so I

00:01:24,060 --> 00:01:29,340
believe it's now one of the main

00:01:26,220 --> 00:01:31,619
alternative languages on the JVM the way

00:01:29,340 --> 00:01:34,020
it started was that very early in the

00:01:31,619 --> 00:01:35,549
90s I got involved with Java actually I

00:01:34,020 --> 00:01:39,630
got involved before let's get Corey

00:01:35,549 --> 00:01:42,659
Wallace Java and the reason was that we

00:01:39,630 --> 00:01:44,280
found that would be probably a very cool

00:01:42,659 --> 00:01:46,470
platform for functional programming

00:01:44,280 --> 00:01:47,970
because Java was a firm mainstream first

00:01:46,470 --> 00:01:49,890
mainstream platform that had a habit

00:01:47,970 --> 00:01:52,080
collector and at the time it was a

00:01:49,890 --> 00:01:54,420
really big thing today of course it's

00:01:52,080 --> 00:01:56,189
completely standard so what we did was a

00:01:54,420 --> 00:01:58,619
language called pizza that took some

00:01:56,189 --> 00:02:00,900
elements of function for Graeme added

00:01:58,619 --> 00:02:03,420
those into Java and that was a moderate

00:02:00,900 --> 00:02:06,299
success but the big thing afterwards was

00:02:03,420 --> 00:02:08,369
that some simple examining me get a plan

00:02:06,299 --> 00:02:11,160
and it's not my pickling to us and said

00:02:08,369 --> 00:02:12,750
no but you did the pizza we don't care

00:02:11,160 --> 00:02:17,280
for higher-order functions we don't care

00:02:12,750 --> 00:02:19,260
foreclosures well Java is still doesn't

00:02:17,280 --> 00:02:21,720
have todos but it might acquire it soon

00:02:19,260 --> 00:02:23,880
finally we don't care for palin matching

00:02:21,720 --> 00:02:25,890
but these the generic types is that you

00:02:23,880 --> 00:02:28,350
have that's interesting and so we

00:02:25,890 --> 00:02:31,650
developed GJ which was the predecessor

00:02:28,350 --> 00:02:35,710
of generic java and java 5

00:02:31,650 --> 00:02:37,900
2003 and in the same course of action

00:02:35,710 --> 00:02:39,430
son actually took over the Java C

00:02:37,900 --> 00:02:41,680
compiler that I wrote which was a

00:02:39,430 --> 00:02:45,040
compiler for GJ and made it their

00:02:41,680 --> 00:02:47,860
standard compiler so there was only 90s

00:02:45,040 --> 00:02:51,100
and in the last ten years when i joined

00:02:47,860 --> 00:02:53,140
epfl i thought i'd take a step back and

00:02:51,100 --> 00:02:55,390
said well what could we come up with if

00:02:53,140 --> 00:02:57,760
we are not backward compatible

00:02:55,390 --> 00:03:00,090
constraint ajara so if he could start

00:02:57,760 --> 00:03:02,170
from a clean sheet and it's the only

00:03:00,090 --> 00:03:04,420
requirement that we had was that we

00:03:02,170 --> 00:03:06,790
should be fully interoperable but if we

00:03:04,420 --> 00:03:08,890
didn't meet to have actually an extended

00:03:06,790 --> 00:03:11,320
syntax for these things and that became

00:03:08,890 --> 00:03:14,500
is Gaara and I think I got a google Tech

00:03:11,320 --> 00:03:16,900
Talk About 2006-2007 which was called

00:03:14,500 --> 00:03:19,660
the Escada experiment that was here in

00:03:16,900 --> 00:03:21,910
this building and so that was sort of

00:03:19,660 --> 00:03:23,170
the end of the experimental phase over

00:03:21,910 --> 00:03:25,930
the last three years we've been very

00:03:23,170 --> 00:03:28,300
busy essentially driving and supporting

00:03:25,930 --> 00:03:30,070
industrial adoption because it actually

00:03:28,300 --> 00:03:33,730
turned out that the experiment worked

00:03:30,070 --> 00:03:37,300
pretty well so here's if you look at the

00:03:33,730 --> 00:03:39,100
current state of traction then we have

00:03:37,300 --> 00:03:41,740
about a hundred thousand visitors a

00:03:39,100 --> 00:03:43,630
month on our website forty thousand

00:03:41,740 --> 00:03:46,360
downloads a month that represents the

00:03:43,630 --> 00:03:48,850
five times growth over last year there's

00:03:46,360 --> 00:03:51,400
a steady steadily increasing stream of

00:03:48,850 --> 00:03:53,560
folks out and more in the pipeline at

00:03:51,400 --> 00:03:56,020
many user groups and we have about sixty

00:03:53,560 --> 00:03:58,570
percent of the traffic comes from the US

00:03:56,020 --> 00:04:00,880
thirty percent hero and ten percent rest

00:03:58,570 --> 00:04:02,890
of the world the not a nice thing is

00:04:00,880 --> 00:04:05,590
that we just got voted most popular non

00:04:02,890 --> 00:04:07,540
Java language in an informal whiteboard

00:04:05,590 --> 00:04:09,460
pole at gearbox which is the biggest

00:04:07,540 --> 00:04:13,440
independent Java conference in Europe

00:04:09,460 --> 00:04:16,150
and just out there a couple weeks ago

00:04:13,440 --> 00:04:19,299
okay so these are some of the companies

00:04:16,150 --> 00:04:23,770
that are using skaara so it's a big list

00:04:19,299 --> 00:04:25,810
growing so it's not all of them so and I

00:04:23,770 --> 00:04:27,580
think the important point there is that

00:04:25,810 --> 00:04:29,290
they're using Scala not as a side

00:04:27,580 --> 00:04:31,660
project of a single guy or something

00:04:29,290 --> 00:04:33,610
like that but a lot of them are really

00:04:31,660 --> 00:04:35,680
using it for their backbone for the

00:04:33,610 --> 00:04:37,960
backbone infrastructure so for instance

00:04:35,680 --> 00:04:39,520
if you look at Twitter they started to

00:04:37,960 --> 00:04:42,220
migrate deformation tensor

00:04:39,520 --> 00:04:44,050
from Ruby to sustain the three orders of

00:04:42,220 --> 00:04:45,879
magnitude growth since two thousand

00:04:44,050 --> 00:04:48,550
times when they switched them and now

00:04:45,879 --> 00:04:52,139
essentially almost all the api's

00:04:48,550 --> 00:04:55,030
customer-facing AP is our scada aprs

00:04:52,139 --> 00:04:56,620
linkedin again it was two years ago it

00:04:55,030 --> 00:04:59,050
was to two guys or something like that

00:04:56,620 --> 00:05:01,240
now it's I think to four groups of more

00:04:59,050 --> 00:05:03,550
than 20 developers doing four times

00:05:01,240 --> 00:05:05,710
Gaara among others it drives their

00:05:03,550 --> 00:05:09,569
social graph service between undated 24

00:05:05,710 --> 00:05:12,039
million transactions per day foursquare

00:05:09,569 --> 00:05:14,349
startup is the entire website and all

00:05:12,039 --> 00:05:16,270
services within sagara so they had a big

00:05:14,349 --> 00:05:18,490
outage recently you might have read

00:05:16,270 --> 00:05:20,050
about it and I'm very glad we leave from

00:05:18,490 --> 00:05:22,419
my site that the outage was due to

00:05:20,050 --> 00:05:25,150
MongoDB and not to Scott so it's gala

00:05:22,419 --> 00:05:27,520
cannabis worked well for them it was

00:05:25,150 --> 00:05:30,340
another reason so all these are web

00:05:27,520 --> 00:05:33,069
companies and that's such a big adoption

00:05:30,340 --> 00:05:35,229
vector another one which is very strong

00:05:33,069 --> 00:05:38,590
now and growing strong as in finance so

00:05:35,229 --> 00:05:41,590
when since EDF it's the e use large of

00:05:38,590 --> 00:05:44,289
energy energy firms they may try to 300k

00:05:41,590 --> 00:05:47,139
lines of contract modeling code from

00:05:44,289 --> 00:05:50,259
Java to Skara and another interesting

00:05:47,139 --> 00:05:54,909
thing is that UBS the one of the ten

00:05:50,259 --> 00:05:56,919
both ten biggest banks just approved

00:05:54,909 --> 00:05:59,199
skala for general production usage shunt

00:05:56,919 --> 00:06:01,419
if you know banks is you know that this

00:05:59,199 --> 00:06:04,270
is actually a very very big step for a

00:06:01,419 --> 00:06:06,039
bank to do that and there are lots of

00:06:04,270 --> 00:06:07,960
others as well so if you want to more

00:06:06,039 --> 00:06:10,630
stories we can take them to the question

00:06:07,960 --> 00:06:13,599
time so why Scala what do these

00:06:10,630 --> 00:06:16,330
companies find in skaara so I think the

00:06:13,599 --> 00:06:18,639
most important slide divided on one side

00:06:16,330 --> 00:06:21,520
it would be this one to say well what's

00:06:18,639 --> 00:06:24,219
god I really is it's a unifier and it's

00:06:21,520 --> 00:06:27,789
a unifier in two on two to two

00:06:24,219 --> 00:06:30,069
dimensions in the vertical axis here you

00:06:27,789 --> 00:06:32,110
say well it's only one hand it's almost

00:06:30,069 --> 00:06:34,240
a scripting language it's so much a

00:06:32,110 --> 00:06:36,250
scripting language that we got invited

00:06:34,240 --> 00:06:37,990
for the third year running to the Java

00:06:36,250 --> 00:06:40,090
one script bowl which is essentially a

00:06:37,990 --> 00:06:42,460
popularity contest for scripting

00:06:40,090 --> 00:06:45,680
languages so there we go up against

00:06:42,460 --> 00:06:48,470
groovy and jruby and other

00:06:45,680 --> 00:06:50,449
scripting languages on the JV on the

00:06:48,470 --> 00:06:52,039
other hand you could say well nothing is

00:06:50,449 --> 00:06:53,990
further from the truth that this is a

00:06:52,039 --> 00:06:55,820
scripting language because it is a very

00:06:53,990 --> 00:06:57,979
very strong type system and there's a

00:06:55,820 --> 00:07:00,080
very perform at runtime so it's really a

00:06:57,979 --> 00:07:02,300
workhorse language just like Java it's

00:07:00,080 --> 00:07:05,030
only more so because the type system

00:07:02,300 --> 00:07:07,190
actually lets you compose things in more

00:07:05,030 --> 00:07:12,500
interesting ways in more robust ways

00:07:07,190 --> 00:07:14,630
than what jealousy so it's a big change

00:07:12,500 --> 00:07:16,970
from a scripting language program with

00:07:14,630 --> 00:07:20,240
where you maybe have one line of code 10

00:07:16,970 --> 00:07:21,500
lines of code to a workhorse systems

00:07:20,240 --> 00:07:24,110
language where you have hundreds of

00:07:21,500 --> 00:07:25,669
thousands of lines of code and how do we

00:07:24,110 --> 00:07:28,699
how can we do that with one language

00:07:25,669 --> 00:07:32,599
both of these music screams so I think

00:07:28,699 --> 00:07:34,699
the secret sauce is that Scarlett rice

00:07:32,599 --> 00:07:36,919
like no other language we need to be a

00:07:34,699 --> 00:07:39,349
fusion of functional object oriented

00:07:36,919 --> 00:07:41,300
languages function object in the

00:07:39,349 --> 00:07:44,750
programming concepts so what I mean by

00:07:41,300 --> 00:07:47,000
that is not having to concert side by

00:07:44,750 --> 00:07:49,130
side but really try to unify those

00:07:47,000 --> 00:07:51,680
concepts in interesting ways for in for

00:07:49,130 --> 00:07:55,610
instance functions in skala are objects

00:07:51,680 --> 00:07:57,770
that one of the same thing okay so let's

00:07:55,610 --> 00:08:00,199
see an example enough talk here so

00:07:57,770 --> 00:08:02,330
that's of course a class you can all

00:08:00,199 --> 00:08:06,770
read that I assume get on you all know

00:08:02,330 --> 00:08:08,659
Java so class of persons but if you look

00:08:06,770 --> 00:08:10,639
at it then you don't let's say you don't

00:08:08,659 --> 00:08:12,620
know Java by heart and you say i just

00:08:10,639 --> 00:08:14,360
looks strange because everything is

00:08:12,620 --> 00:08:16,729
repeated three times there are three

00:08:14,360 --> 00:08:20,659
names that's weak ages in here why do

00:08:16,729 --> 00:08:23,270
people stutter so much so here's the

00:08:20,659 --> 00:08:25,190
same classes cut out the CD the petition

00:08:23,270 --> 00:08:28,250
is gone so everything is mentioned once

00:08:25,190 --> 00:08:30,639
it means more less exactly the same

00:08:28,250 --> 00:08:33,440
thing so you have a class of persons and

00:08:30,639 --> 00:08:35,719
it takes two parameters which you pass

00:08:33,440 --> 00:08:39,229
directly to the class a name and an age

00:08:35,719 --> 00:08:42,709
and the vow in front of the name and ph

00:08:39,229 --> 00:08:44,959
duvall here that tells you that it's

00:08:42,709 --> 00:08:46,760
actually a field of the same class with

00:08:44,959 --> 00:08:48,500
the same name josh so many reasons that

00:08:46,760 --> 00:08:52,490
constructor is packaged private in the

00:08:48,500 --> 00:08:54,370
java version no now it should be public

00:08:52,490 --> 00:08:59,529
you're right

00:08:54,370 --> 00:09:01,839
one yet okay and so the vowel means it's

00:08:59,529 --> 00:09:03,430
a field and the field furthermore it

00:09:01,839 --> 00:09:05,620
means that the field is in your journal

00:09:03,430 --> 00:09:08,290
which sequence Cara as a strong

00:09:05,620 --> 00:09:10,150
functional tradition is the recommended

00:09:08,290 --> 00:09:12,339
way to right field unless you have a

00:09:10,150 --> 00:09:14,110
good reason to make a mutable if they

00:09:12,339 --> 00:09:16,360
should be mutable you just write war

00:09:14,110 --> 00:09:20,260
instead as well and that would give you

00:09:16,360 --> 00:09:22,029
a mutable okay you might say big deal if

00:09:20,260 --> 00:09:23,650
I use Eclipse then that code will be

00:09:22,029 --> 00:09:27,490
written for me so that's how a big

00:09:23,650 --> 00:09:29,589
savings and that might be true but let's

00:09:27,490 --> 00:09:32,020
have a usage of this look of a look at

00:09:29,589 --> 00:09:42,610
our usage of this last so what does this

00:09:32,020 --> 00:09:46,029
thing do here after art so seems to

00:09:42,610 --> 00:09:47,890
split the right of people if you are an

00:09:46,029 --> 00:09:50,680
array of miners and in the way of

00:09:47,890 --> 00:09:52,900
balance right and i was a bit mean that

00:09:50,680 --> 00:09:55,540
i've specified arrays as the input

00:09:52,900 --> 00:09:57,339
output their structures a widget type

00:09:55,540 --> 00:10:00,130
you can't let them grow as you need to

00:09:57,339 --> 00:10:02,620
so internally it goes over array lists

00:10:00,130 --> 00:10:05,380
and then in the end it puts these things

00:10:02,620 --> 00:10:08,890
back into organs so that's the same

00:10:05,380 --> 00:10:11,770
thing written in column have the array

00:10:08,890 --> 00:10:14,230
of P persons people and then you say

00:10:11,770 --> 00:10:18,580
minus adults equals people partition

00:10:14,230 --> 00:10:20,140
with age less than 18 so I think it has

00:10:18,580 --> 00:10:24,070
no contest to say which of these

00:10:20,140 --> 00:10:26,260
solutions is Kira and even if you if you

00:10:24,070 --> 00:10:27,520
used to leaving java code that they tell

00:10:26,260 --> 00:10:29,770
you what you would conceive the

00:10:27,520 --> 00:10:32,860
diversion down here is why clear and

00:10:29,770 --> 00:10:34,959
easy to read and it's also it turns out

00:10:32,860 --> 00:10:37,150
much much easier as you get right or

00:10:34,959 --> 00:10:39,310
otherwise put if you don't get it right

00:10:37,150 --> 00:10:40,870
you have a much much higher a chance

00:10:39,310 --> 00:10:42,730
that the type checker will actually

00:10:40,870 --> 00:10:47,380
catch you out than in the java version

00:10:42,730 --> 00:10:50,020
so it's more of us so this thing here

00:10:47,380 --> 00:10:52,420
shows in a nutshell three of the

00:10:50,020 --> 00:10:55,029
important concepts that gala has over

00:10:52,420 --> 00:10:56,650
java the first thing is here on the left

00:10:55,029 --> 00:10:59,260
hand side of the assignment you see

00:10:56,650 --> 00:11:01,660
killer actually there are two variables

00:10:59,260 --> 00:11:04,390
being defined minus and adults so that's

00:11:01,660 --> 00:11:05,970
a very simple example of a pattern match

00:11:04,390 --> 00:11:07,850
which we

00:11:05,970 --> 00:11:10,529
that's what was one of the things that

00:11:07,850 --> 00:11:14,069
there's some people at the time didn't

00:11:10,529 --> 00:11:17,519
want it all coming from pizza so the

00:11:14,069 --> 00:11:19,889
next thing you see here is the partition

00:11:17,519 --> 00:11:21,720
operator that's actually just an in

00:11:19,889 --> 00:11:25,319
fixed method call so it's a phone call

00:11:21,720 --> 00:11:27,720
it invocation of a method on the people

00:11:25,319 --> 00:11:30,600
all right you might say well wait a

00:11:27,720 --> 00:11:32,430
minute what kind of array is this and in

00:11:30,600 --> 00:11:34,319
fact it's exactly the same array that

00:11:32,430 --> 00:11:37,170
you have in Java there's no wrapping

00:11:34,319 --> 00:11:39,899
going on so you might say well last time

00:11:37,170 --> 00:11:42,360
I saw erase didn't have a partition

00:11:39,899 --> 00:11:47,069
method and that's true so there's some

00:11:42,360 --> 00:11:49,050
serious magic not in the compiler but in

00:11:47,069 --> 00:11:52,319
the library is to actually inject these

00:11:49,050 --> 00:11:54,029
methods we so called implicit or so

00:11:52,319 --> 00:11:56,069
called pattern called pit my library

00:11:54,029 --> 00:11:59,699
which is very common in China prov it's

00:11:56,069 --> 00:12:02,040
kind of a problem and the last element

00:11:59,699 --> 00:12:04,620
here well that's our closure the

00:12:02,040 --> 00:12:07,079
function value very simple form of one

00:12:04,620 --> 00:12:10,470
where you say okay you have a parameter

00:12:07,079 --> 00:12:13,769
and that is the right by the underscore

00:12:10,470 --> 00:12:15,870
here and you take the H value of the

00:12:13,769 --> 00:12:17,879
parameter which is a person and you

00:12:15,870 --> 00:12:20,040
compare with 18 so that's the function

00:12:17,879 --> 00:12:23,309
that you pass into the partition method

00:12:20,040 --> 00:12:25,199
and the type of the parameter signified

00:12:23,309 --> 00:12:27,300
by the underscore that's inferred

00:12:25,199 --> 00:12:29,459
because God has a pretty powerful type

00:12:27,300 --> 00:12:33,680
inference you don't need to write the

00:12:29,459 --> 00:12:36,569
type of these closures as a general rule

00:12:33,680 --> 00:12:39,149
okay so the bottom line of that is that

00:12:36,569 --> 00:12:41,550
if you go from Java to scala you can

00:12:39,149 --> 00:12:43,199
expect at least a factor of 2 reduction

00:12:41,550 --> 00:12:46,800
in light of hope and I'm really being

00:12:43,199 --> 00:12:48,990
conservative so to just take one witness

00:12:46,800 --> 00:12:51,750
guys steal they ported the fortress

00:12:48,990 --> 00:12:54,300
compiler from Java to scala they

00:12:51,750 --> 00:12:55,740
reported a 4 x reduction of lines of

00:12:54,300 --> 00:12:59,850
code and that's somebody who's actually

00:12:55,740 --> 00:13:01,980
employed person or oracle now and so so

00:12:59,850 --> 00:13:05,160
I think factor of 2 is really something

00:13:01,980 --> 00:13:06,779
you can always extend yes so what I

00:13:05,160 --> 00:13:08,490
believe you factor of two should point

00:13:06,779 --> 00:13:10,180
out that if i ported it from java to

00:13:08,490 --> 00:13:12,339
java he would have gotten a factor

00:13:10,180 --> 00:13:19,180
you there as well ok put each other back

00:13:12,339 --> 00:13:21,430
for understanding Asia petty ok so but

00:13:19,180 --> 00:13:23,890
the other much possible objection is

00:13:21,430 --> 00:13:25,779
well that's that really matter doesn't

00:13:23,890 --> 00:13:28,060
Eclipse right these extra lines for me

00:13:25,779 --> 00:13:30,310
and I think the correct answer to that

00:13:28,060 --> 00:13:32,080
is well maybe someone sometimes

00:13:30,310 --> 00:13:34,570
sometimes not but it certainly won't

00:13:32,080 --> 00:13:36,279
read those extra lines for you and after

00:13:34,570 --> 00:13:38,050
all we know that reading is more

00:13:36,279 --> 00:13:40,720
important than writing software at least

00:13:38,050 --> 00:13:43,149
should be so the question is now reading

00:13:40,720 --> 00:13:45,430
10 can we leave those after the lines

00:13:43,149 --> 00:13:48,279
faster and that we actually do an

00:13:45,430 --> 00:13:50,110
experiment on that so we set a lot a

00:13:48,279 --> 00:13:52,750
bunch of subjects in front of a computer

00:13:50,110 --> 00:13:55,089
screen and ask them to understand two

00:13:52,750 --> 00:13:57,330
versions of the same library code that

00:13:55,089 --> 00:14:01,540
was I think some relational algebra

00:13:57,330 --> 00:14:03,520
routines and one of the one half of the

00:14:01,540 --> 00:14:06,790
sample was within a way you would write

00:14:03,520 --> 00:14:08,740
it in Java it was both gala to keep the

00:14:06,790 --> 00:14:10,360
language constant but one way was

00:14:08,740 --> 00:14:12,100
written in the same way you would have

00:14:10,360 --> 00:14:14,709
written it in Java which you can do in

00:14:12,100 --> 00:14:16,470
kind of course and the other was written

00:14:14,709 --> 00:14:18,880
in a way which made use of the

00:14:16,470 --> 00:14:21,220
functional capabilities of scale and

00:14:18,880 --> 00:14:24,430
what we found out in this experiment is

00:14:21,220 --> 00:14:27,850
that the average time spent per word of

00:14:24,430 --> 00:14:29,980
source code / token was constant for the

00:14:27,850 --> 00:14:32,830
program understand that means fewer

00:14:29,980 --> 00:14:34,779
words indeed faster I understanding it

00:14:32,830 --> 00:14:36,640
doesn't mean that the fastest language

00:14:34,779 --> 00:14:39,430
to understand is 80 hour because well

00:14:36,640 --> 00:14:41,110
maybe el programa very short every

00:14:39,430 --> 00:14:42,940
talking is a single character so it

00:14:41,110 --> 00:14:45,430
didn't its first word of source code

00:14:42,940 --> 00:14:48,390
nostril canister that you could either

00:14:45,430 --> 00:14:50,770
be beat this relationship was its damage

00:14:48,390 --> 00:14:53,860
ok you might say well that's very good

00:14:50,770 --> 00:14:57,250
and ok I believe it's a more concise may

00:14:53,860 --> 00:14:59,050
be more productive Java but actually if

00:14:57,250 --> 00:15:00,550
it stopped there that would be half of

00:14:59,050 --> 00:15:02,950
the story because there's much more to

00:15:00,550 --> 00:15:05,890
it and the more to it has all to do with

00:15:02,950 --> 00:15:08,920
domain-specific languages so Scala is

00:15:05,890 --> 00:15:11,440
really good at embedding a lot of

00:15:08,920 --> 00:15:13,240
domain-specific languages that just then

00:15:11,440 --> 00:15:16,149
take the form of high-level libraries

00:15:13,240 --> 00:15:18,779
high-level api's so just as a single

00:15:16,149 --> 00:15:21,420
example you see here on the right the

00:15:18,779 --> 00:15:24,360
actress abstractions that I you

00:15:21,420 --> 00:15:26,910
including Scott actor's library and that

00:15:24,360 --> 00:15:29,460
are in similar form in the aqha version

00:15:26,910 --> 00:15:32,430
for distributed actor so actors we

00:15:29,460 --> 00:15:34,980
shamelessly stole from era along has

00:15:32,430 --> 00:15:37,290
used actors for 20 years very

00:15:34,980 --> 00:15:41,250
successfully in telecoms and now

00:15:37,290 --> 00:15:43,080
internet systems so the idea of actors

00:15:41,250 --> 00:15:46,380
is very essential you have an

00:15:43,080 --> 00:15:48,510
asynchronous message send expressed the

00:15:46,380 --> 00:15:50,550
right actor bang message so you send

00:15:48,510 --> 00:15:52,620
this message to the actor and then on

00:15:50,550 --> 00:15:56,490
the other hand side the actor can decide

00:15:52,620 --> 00:15:57,930
when they want to receive messages and

00:15:56,490 --> 00:15:59,790
what kind of messages they want to

00:15:57,930 --> 00:16:01,770
handle at any one point well that's

00:15:59,790 --> 00:16:04,650
expressed with this receive method which

00:16:01,770 --> 00:16:06,360
thanks a bunch of pattern matches so it

00:16:04,650 --> 00:16:09,240
takes a bunch of message patterns and

00:16:06,360 --> 00:16:12,150
associated actions and the idea is that

00:16:09,240 --> 00:16:14,520
it would scan the sorts of messages that

00:16:12,150 --> 00:16:16,230
are pending and if any message matches

00:16:14,520 --> 00:16:18,510
one of these patterns it will pick the

00:16:16,230 --> 00:16:20,760
first of those messages execute the

00:16:18,510 --> 00:16:22,800
corresponding action and if no message

00:16:20,760 --> 00:16:26,400
matches then it would just suspended

00:16:22,800 --> 00:16:28,830
made for further messages okay so the

00:16:26,400 --> 00:16:30,570
point in this example is you might think

00:16:28,830 --> 00:16:32,190
that this is something that's in this

00:16:30,570 --> 00:16:34,190
got out the language but that's actually

00:16:32,190 --> 00:16:36,540
not true scholar doesn't have any

00:16:34,190 --> 00:16:38,760
concurrency primitives except that it

00:16:36,540 --> 00:16:42,690
works with suspended javathread salute

00:16:38,760 --> 00:16:45,480
SMS just as good as java is incorrect so

00:16:42,690 --> 00:16:47,910
all these things are constructs that are

00:16:45,480 --> 00:16:49,680
written as methods so when since a bang

00:16:47,910 --> 00:16:51,870
well it's just another in fixed method

00:16:49,680 --> 00:16:53,670
that happens to be called bang and the

00:16:51,870 --> 00:16:55,850
receive here it's a more evolved thing

00:16:53,670 --> 00:16:58,920
it's a high order method that takes

00:16:55,850 --> 00:17:01,830
another function value which is this

00:16:58,920 --> 00:17:04,020
hannah matching expression so that's

00:17:01,830 --> 00:17:06,210
just one example that demonstrates how

00:17:04,020 --> 00:17:09,210
one can really organically grow the

00:17:06,210 --> 00:17:11,580
language into new into completely new

00:17:09,210 --> 00:17:14,160
directions and do so in a way which

00:17:11,580 --> 00:17:15,870
makes it not to look like something that

00:17:14,160 --> 00:17:17,130
is strange and more difficult to use

00:17:15,870 --> 00:17:19,539
than the face language it looks

00:17:17,130 --> 00:17:21,279
completely organic and it

00:17:19,539 --> 00:17:24,069
it has been done in many many different

00:17:21,279 --> 00:17:26,799
instances so acha actors are one example

00:17:24,069 --> 00:17:29,109
so that they used in a cart with us

00:17:26,799 --> 00:17:30,820
message queues and so on there are lots

00:17:29,109 --> 00:17:32,830
and lots of really nice testing

00:17:30,820 --> 00:17:35,590
frameworks the specs and skaara check is

00:17:32,830 --> 00:17:38,739
just just two examples there are lots of

00:17:35,590 --> 00:17:41,019
very interesting database with matters

00:17:38,739 --> 00:17:44,080
that scallop very perilous from Twitter

00:17:41,019 --> 00:17:46,090
and so on so all these things is

00:17:44,080 --> 00:17:48,940
essentially there's a whole ecosystem of

00:17:46,090 --> 00:17:54,129
doing embedded languages on top of

00:17:48,940 --> 00:17:55,359
Scylla is the base language now that was

00:17:54,129 --> 00:17:58,599
sort of a quick introduction was

00:17:55,359 --> 00:18:01,899
galleries and since we had concurrency I

00:17:58,599 --> 00:18:03,940
now come to essentially why concurrency

00:18:01,899 --> 00:18:05,859
is interesting and what how we how we

00:18:03,940 --> 00:18:07,599
took this further well of course

00:18:05,859 --> 00:18:11,200
concurrency is interesting because we

00:18:07,599 --> 00:18:13,210
have a big complex shift now the speed

00:18:11,200 --> 00:18:15,700
of processors isn't increasing any more

00:18:13,210 --> 00:18:17,889
or any since five years it has remained

00:18:15,700 --> 00:18:19,899
largely constant so what we get instead

00:18:17,889 --> 00:18:24,460
for increasing transistor budgets is

00:18:19,899 --> 00:18:26,559
more course and that basic fact

00:18:24,460 --> 00:18:29,139
everybody knows about it but it has been

00:18:26,559 --> 00:18:31,570
ignored in every day programming to a

00:18:29,139 --> 00:18:33,159
large degree I mean what people do is

00:18:31,570 --> 00:18:35,559
they say when I'm service the thing is

00:18:33,159 --> 00:18:37,809
simple i just distribute my users of

00:18:35,559 --> 00:18:40,570
them over more course and that's true on

00:18:37,809 --> 00:18:42,669
clients well I might get faster graphics

00:18:40,570 --> 00:18:44,649
because I know how to paralyze that and

00:18:42,669 --> 00:18:47,200
for the rest well these cores are mostly

00:18:44,649 --> 00:18:50,139
idle and maybe that's defensible if you

00:18:47,200 --> 00:18:53,200
have to force of four cores but what if

00:18:50,139 --> 00:18:55,359
you had like like 24,000 parallel

00:18:53,200 --> 00:18:58,359
threads so this processor here that's an

00:18:55,359 --> 00:19:00,779
nvidia thermite that will keep to keep

00:18:58,359 --> 00:19:03,279
that fully the phone busy you need

00:19:00,779 --> 00:19:05,259
24,000 running threats otherwise it

00:19:03,279 --> 00:19:08,649
wouldn't it wouldn't would just not be

00:19:05,259 --> 00:19:10,720
fully loaded so that's now being really

00:19:08,649 --> 00:19:12,909
a big big problem I mean how our kind of

00:19:10,720 --> 00:19:14,229
people how people are going to find all

00:19:12,909 --> 00:19:16,929
these parallel threads and how I'm

00:19:14,229 --> 00:19:19,570
either going to organize them little has

00:19:16,929 --> 00:19:21,940
been called the PPP grand challenge by

00:19:19,570 --> 00:19:24,129
the computer architecture community so

00:19:21,940 --> 00:19:25,599
PPP is short for popular parallel

00:19:24,129 --> 00:19:27,700
programming and essentially it means

00:19:25,599 --> 00:19:30,129
that the computer I picture people they

00:19:27,700 --> 00:19:30,850
throw all these chips on our site and

00:19:30,129 --> 00:19:32,920
says well you

00:19:30,850 --> 00:19:34,840
figure out how to program them we call

00:19:32,920 --> 00:19:38,310
it a grand challenge and that's that our

00:19:34,840 --> 00:19:42,280
contribution for the whole thing okay so

00:19:38,310 --> 00:19:44,260
how do we do that well one thing that

00:19:42,280 --> 00:19:46,440
you often hear today is concurrent

00:19:44,260 --> 00:19:49,270
program so because of parallelism

00:19:46,440 --> 00:19:52,570
suddenly Allen has got a renaissance and

00:19:49,270 --> 00:19:55,870
all these fancy things like actors with

00:19:52,570 --> 00:19:58,780
messages agents SDM leg and also says

00:19:55,870 --> 00:20:00,430
second a safe safe the name and I mean

00:19:58,780 --> 00:20:02,230
if all these concepts are really useful

00:20:00,430 --> 00:20:03,550
I mean there's a right abstraction some

00:20:02,230 --> 00:20:05,830
they're much better than threads and

00:20:03,550 --> 00:20:07,840
blocks no doubt about it but by

00:20:05,830 --> 00:20:10,060
themselves I won't solve this PPP

00:20:07,840 --> 00:20:13,600
challenge simply because no matter how

00:20:10,060 --> 00:20:15,910
you do it you will always have a hard

00:20:13,600 --> 00:20:17,860
time doing concurrent program that's

00:20:15,910 --> 00:20:20,140
because there's this fundamental problem

00:20:17,860 --> 00:20:22,360
of non determinacy whenever you have a

00:20:20,140 --> 00:20:24,790
program which is not determinist around

00:20:22,360 --> 00:20:27,400
feministic it's just painful you'll have

00:20:24,790 --> 00:20:29,920
Kenneth Heisenberg ZF different behavior

00:20:27,400 --> 00:20:31,840
different hardware's I had I had crushes

00:20:29,920 --> 00:20:33,580
on max that won't reproduce around

00:20:31,840 --> 00:20:37,180
windows and so on and so it's just

00:20:33,580 --> 00:20:39,400
painful so what do you do that well the

00:20:37,180 --> 00:20:44,260
root of the problem is non determinism

00:20:39,400 --> 00:20:46,960
so concurrent threads accessing taste as

00:20:44,260 --> 00:20:49,270
shared mutable state are inherently

00:20:46,960 --> 00:20:50,830
non-deterministic so in this simple

00:20:49,270 --> 00:20:53,470
example here on the right you have just

00:20:50,830 --> 00:20:56,170
to asynchronous computations a shared

00:20:53,470 --> 00:20:59,830
mutable variable and that can give you

00:20:56,170 --> 00:21:02,080
zero one or two and even if you say well

00:20:59,830 --> 00:21:04,360
the essence are in fact atomic so you

00:21:02,080 --> 00:21:06,010
will not actually have any cleaving

00:21:04,360 --> 00:21:09,100
between these drops it still

00:21:06,010 --> 00:21:11,680
non-deterministic because one can run it

00:21:09,100 --> 00:21:14,130
one can run before the other so you

00:21:11,680 --> 00:21:19,890
don't have an order of these two things

00:21:14,130 --> 00:21:22,420
ok so if non determinism arises almost

00:21:19,890 --> 00:21:25,150
inevitably from parallel processing

00:21:22,420 --> 00:21:26,710
immutable stake and we say we can't do

00:21:25,150 --> 00:21:29,470
with our parallel processing because

00:21:26,710 --> 00:21:31,900
well hardware forces us to do parallel

00:21:29,470 --> 00:21:34,420
processing and it's axiomatic that they

00:21:31,900 --> 00:21:35,690
have to eliminate or off let's say we

00:21:34,420 --> 00:21:37,129
use mutable state

00:21:35,690 --> 00:21:38,840
because I think otherwise we will just

00:21:37,129 --> 00:21:41,360
run into this problem head on those are

00:21:38,840 --> 00:21:43,970
the solution so to get to deterministic

00:21:41,360 --> 00:21:46,610
problem processing minimize the mutable

00:21:43,970 --> 00:21:48,259
state and avoiding mutable state means

00:21:46,610 --> 00:21:50,149
programming functionally so that's

00:21:48,259 --> 00:21:51,470
essentially the secret of saying well

00:21:50,149 --> 00:21:53,779
essentially if you want to deal with

00:21:51,470 --> 00:21:55,490
that that's why function programming has

00:21:53,779 --> 00:21:59,509
this sort of Renaissance to this to say

00:21:55,490 --> 00:22:01,070
about it addresses this problem so

00:21:59,509 --> 00:22:03,440
another way to look at that and that's

00:22:01,070 --> 00:22:06,259
another student philosophical is to

00:22:03,440 --> 00:22:07,730
savor if you program functional it's

00:22:06,259 --> 00:22:10,429
really a completely different mindset

00:22:07,730 --> 00:22:12,200
from programming imperatively social

00:22:10,429 --> 00:22:14,480
programming paratively you program in

00:22:12,200 --> 00:22:16,009
time you think about God first I do this

00:22:14,480 --> 00:22:17,960
they cook you to bust this and then it

00:22:16,009 --> 00:22:20,659
does that and then then then this other

00:22:17,960 --> 00:22:22,970
thing happened so it's really you align

00:22:20,659 --> 00:22:24,200
things on a time axis in functional

00:22:22,970 --> 00:22:26,000
programming you're not concerned with

00:22:24,200 --> 00:22:27,500
time it off it doesn't matter one of

00:22:26,000 --> 00:22:30,080
these things run what you're concerned

00:22:27,500 --> 00:22:31,610
with is what do you construct and out of

00:22:30,080 --> 00:22:34,159
what are the things you construct this

00:22:31,610 --> 00:22:36,440
thing so the mental model is much more a

00:22:34,159 --> 00:22:38,149
space oriented model that you say well I

00:22:36,440 --> 00:22:40,309
construct this interesting thing from

00:22:38,149 --> 00:22:42,110
That and then and that and then this

00:22:40,309 --> 00:22:44,690
other thing into it it has to be

00:22:42,110 --> 00:22:47,090
experienced to to really sink in but

00:22:44,690 --> 00:22:49,399
that's that's really what it is so if

00:22:47,090 --> 00:22:51,500
you look at that now to say well if I go

00:22:49,399 --> 00:22:53,629
in space then I can have lots of

00:22:51,500 --> 00:22:55,279
parallel computations that essentially

00:22:53,629 --> 00:22:58,340
build different parts of the same thing

00:22:55,279 --> 00:23:00,230
it's not it's not problem there so for

00:22:58,340 --> 00:23:02,269
instance if I build a cathedral then I

00:23:00,230 --> 00:23:03,740
can build a cathedral with with many

00:23:02,269 --> 00:23:05,600
many different workers that they all

00:23:03,740 --> 00:23:08,210
will could build a different part at the

00:23:05,600 --> 00:23:11,299
end I have a cathedral on the other end

00:23:08,210 --> 00:23:13,669
if I go in time then while I had this

00:23:11,299 --> 00:23:15,139
one thread and as the second thread we

00:23:13,669 --> 00:23:17,000
never third thread and a fourth row and

00:23:15,139 --> 00:23:18,620
the more threads I have and more fiddly

00:23:17,000 --> 00:23:20,750
it becomes because they might actually

00:23:18,620 --> 00:23:23,000
want to access the same things at the

00:23:20,750 --> 00:23:26,179
same time I have these races I might

00:23:23,000 --> 00:23:28,850
have deadlock sensor so that sort of a

00:23:26,179 --> 00:23:30,889
very rough approximation but I think one

00:23:28,850 --> 00:23:33,559
which is fundamentally true to say why

00:23:30,889 --> 00:23:36,980
I'm sure programming is really the right

00:23:33,559 --> 00:23:38,809
way to do things here okay so what does

00:23:36,980 --> 00:23:40,279
it all have to do with collections well

00:23:38,809 --> 00:23:43,039
connections essentially build

00:23:40,279 --> 00:23:44,899
interesting things in space if you want

00:23:43,039 --> 00:23:45,680
to build something which is just not

00:23:44,899 --> 00:23:47,330
more than

00:23:45,680 --> 00:23:49,520
the single value of a single class that

00:23:47,330 --> 00:23:52,910
is defined you will inevitably have

00:23:49,520 --> 00:23:55,730
something like collections and I give

00:23:52,910 --> 00:23:58,280
you a quick way to show your house god I

00:23:55,730 --> 00:24:00,350
deals with collections so in fact

00:23:58,280 --> 00:24:02,900
scatter light as often it doesn't really

00:24:00,350 --> 00:24:04,910
take a single standard says well if you

00:24:02,900 --> 00:24:07,250
want mutable collections we have those

00:24:04,910 --> 00:24:10,220
and you can program them in pretty much

00:24:07,250 --> 00:24:12,380
the same way as in Java but there's also

00:24:10,220 --> 00:24:14,570
the new a different set of immutable

00:24:12,380 --> 00:24:16,730
collections where destructive updates

00:24:14,570 --> 00:24:18,290
are not possible so and generally these

00:24:16,730 --> 00:24:20,420
immutable collections they are more

00:24:18,290 --> 00:24:23,030
popular that you could be faulted in

00:24:20,420 --> 00:24:25,280
skala programs so that means we

00:24:23,030 --> 00:24:28,070
emphasize destructive up there and

00:24:25,280 --> 00:24:30,620
instead of having this crud thing create

00:24:28,070 --> 00:24:32,240
read update delete bin collections we

00:24:30,620 --> 00:24:34,070
essentially have collection transformers

00:24:32,240 --> 00:24:35,480
we create new collections out of all

00:24:34,070 --> 00:24:37,610
connections let's see that's a

00:24:35,480 --> 00:24:39,200
functional way and to make that

00:24:37,610 --> 00:24:41,630
efficient we have a complete range of

00:24:39,200 --> 00:24:43,430
persistent connections but when since

00:24:41,630 --> 00:24:46,250
what you do here is you have a list and

00:24:43,430 --> 00:24:49,790
then you map a function over the list of

00:24:46,250 --> 00:24:53,000
gives you a new list and better so the

00:24:49,790 --> 00:24:55,610
collection properties that we have is

00:24:53,000 --> 00:24:57,860
that their object oriented so they are

00:24:55,610 --> 00:24:59,710
fit into a natural hierarchy you can see

00:24:57,860 --> 00:25:03,500
a bit more of the hierarchy later on

00:24:59,710 --> 00:25:05,540
their generic of course so its list of T

00:25:03,500 --> 00:25:08,240
of some element type T or map of key

00:25:05,540 --> 00:25:10,670
value their optionally persistence of

00:25:08,240 --> 00:25:13,070
all connections in the immutable package

00:25:10,670 --> 00:25:15,830
of the system and it there higher-order

00:25:13,070 --> 00:25:17,960
so typical methods you deal with

00:25:15,830 --> 00:25:22,220
collections are things like for each map

00:25:17,960 --> 00:25:24,170
filter and the last one seems kind of

00:25:22,220 --> 00:25:26,210
natural but it's actually very hard to

00:25:24,170 --> 00:25:28,370
achieve this it what we call the uniform

00:25:26,210 --> 00:25:30,590
return type principle and that's that

00:25:28,370 --> 00:25:33,440
operations should return collections of

00:25:30,590 --> 00:25:35,900
the same type as the operand their work

00:25:33,440 --> 00:25:37,910
out so if you let's say do a map over a

00:25:35,900 --> 00:25:40,520
set you guys like I said if you do a map

00:25:37,910 --> 00:25:42,410
over list you get that guys to do a map

00:25:40,520 --> 00:25:45,920
or a vector and you get that effect so

00:25:42,410 --> 00:25:47,660
I'm not not just a standard without type

00:25:45,920 --> 00:25:50,060
but you always map back into the same

00:25:47,660 --> 00:25:52,940
and that actually turns out to make a

00:25:50,060 --> 00:25:54,770
very elegant and powerful combination so

00:25:52,940 --> 00:25:56,240
I quickly run you down to some of the

00:25:54,770 --> 00:25:59,420
basic things and then I want to

00:25:56,240 --> 00:26:02,300
would one complete coding thing because

00:25:59,420 --> 00:26:04,670
here at Google I mean it'd be called

00:26:02,300 --> 00:26:07,250
CODIS code is King Boris what matter son

00:26:04,670 --> 00:26:08,990
I do a little bit of knife cutting it ok

00:26:07,250 --> 00:26:11,179
so the collection so what you have is

00:26:08,990 --> 00:26:13,940
you can build a construct a collection

00:26:11,179 --> 00:26:17,809
like that list 1 2 3 list is the name of

00:26:13,940 --> 00:26:20,270
the collection here and the scarlet so

00:26:17,809 --> 00:26:22,520
what I do here is I simulate this gun

00:26:20,270 --> 00:26:24,080
interpreters gotta read so that would

00:26:22,520 --> 00:26:26,480
then be the answer of this color

00:26:24,080 --> 00:26:30,230
interpreter throws back at me so then I

00:26:26,480 --> 00:26:31,850
can map that by implementing every value

00:26:30,230 --> 00:26:35,480
in the list so it would give me back to

00:26:31,850 --> 00:26:38,290
this 2 3 4 then that's another way to

00:26:35,480 --> 00:26:40,970
write the incrementation only shorter I

00:26:38,290 --> 00:26:42,830
can also have a filter which says well

00:26:40,970 --> 00:26:44,900
now I want to get all the elements that

00:26:42,830 --> 00:26:48,170
are even in the list so that could be

00:26:44,900 --> 00:26:50,420
that and here's another one which is a

00:26:48,170 --> 00:26:52,490
bit more involved that I have another

00:26:50,420 --> 00:26:54,860
form of creating special kind of

00:26:52,490 --> 00:26:58,429
collections called ranges with the two

00:26:54,860 --> 00:27:00,080
methods on integers so 02 this parameter

00:26:58,429 --> 00:27:02,570
which would give me a range from 0 to

00:27:00,080 --> 00:27:04,820
whatever the parameter was if I do that

00:27:02,570 --> 00:27:10,220
then I get a list of three ranges you

00:27:04,820 --> 00:27:13,070
know 12 you want to 30 12 okay other

00:27:10,220 --> 00:27:15,650
operations I have is I have an operation

00:27:13,070 --> 00:27:17,870
flatten it takes a list of other

00:27:15,650 --> 00:27:20,780
collections and just concatenate all the

00:27:17,870 --> 00:27:23,240
elements so doing that on the last list

00:27:20,780 --> 00:27:26,720
would give me this long illness and I

00:27:23,240 --> 00:27:29,540
can actually join the map and the

00:27:26,720 --> 00:27:31,640
flattened to a flat map so flat map just

00:27:29,540 --> 00:27:34,130
takes a function that returns a

00:27:31,640 --> 00:27:37,010
collection in this case this thing here

00:27:34,130 --> 00:27:38,360
and it would just take apply the

00:27:37,010 --> 00:27:40,760
function to each element in the list

00:27:38,360 --> 00:27:43,250
concatenate all the results so that's a

00:27:40,760 --> 00:27:49,490
flat map gives me the same thing as na

00:27:43,250 --> 00:27:52,370
conflict ok and the last one is grouped

00:27:49,490 --> 00:27:55,880
by which is also a nice operation that

00:27:52,370 --> 00:27:59,390
we work with databases you know that so

00:27:55,880 --> 00:28:01,280
group x goes from 8 takes a collection

00:27:59,390 --> 00:28:03,670
in this case to change things a little

00:28:01,280 --> 00:28:09,160
bit I gave you a vector another this

00:28:03,670 --> 00:28:11,680
and the group by now gives you a map by

00:28:09,160 --> 00:28:14,410
that's constructed so essentially you

00:28:11,680 --> 00:28:16,570
have a function here in this case head

00:28:14,410 --> 00:28:19,420
takes a fit so it takes the first

00:28:16,570 --> 00:28:22,630
character of every element here and just

00:28:19,420 --> 00:28:24,580
thick skin so that you see that and then

00:28:22,630 --> 00:28:28,330
it would just map back it would say well

00:28:24,580 --> 00:28:31,030
from the AI get the Apple and from the P

00:28:28,330 --> 00:28:34,290
I get parent pineapple so essentially i

00:28:31,030 --> 00:28:37,210
take take the function and then map

00:28:34,290 --> 00:28:39,190
generate a map that maps back into a sub

00:28:37,210 --> 00:28:41,680
collection that's a standard function

00:28:39,190 --> 00:28:46,450
that you know by in SQL so I group by

00:28:41,680 --> 00:28:48,100
justices okay so that's one side of

00:28:46,450 --> 00:28:52,270
collections the other side is

00:28:48,100 --> 00:28:54,760
fornication so for notation is a very

00:28:52,270 --> 00:28:57,220
convenient way to essentially right with

00:28:54,760 --> 00:28:59,050
certain collection operations so the

00:28:57,220 --> 00:29:01,330
first one for instance is this year so

00:28:59,050 --> 00:29:03,100
it looks like a for loop but it ends in

00:29:01,330 --> 00:29:05,710
you then it always gives you back a new

00:29:03,100 --> 00:29:07,300
value so for every element so when since

00:29:05,710 --> 00:29:09,280
this one here is the same as map it

00:29:07,300 --> 00:29:12,190
would just add one to each element and

00:29:09,280 --> 00:29:15,070
return the list this one here is the

00:29:12,190 --> 00:29:16,960
same as filter so no you would take a

00:29:15,070 --> 00:29:19,930
collection you will have an if and you

00:29:16,960 --> 00:29:21,880
will then use the thing and finally this

00:29:19,930 --> 00:29:24,220
one here which has two generators and

00:29:21,880 --> 00:29:25,900
excess and there's the range so that's

00:29:24,220 --> 00:29:28,570
the same as flat map so you go through

00:29:25,900 --> 00:29:30,190
it says go through the range every

00:29:28,570 --> 00:29:34,480
element you pull out the or out of the

00:29:30,190 --> 00:29:36,040
range you return from this okay so that

00:29:34,480 --> 00:29:39,360
was the primer that I had to introduce

00:29:36,040 --> 00:29:42,670
to so that you can now or follow the the

00:29:39,360 --> 00:29:45,250
uh no sir I need one more maybe using

00:29:42,670 --> 00:29:48,700
maps in the applicant at maps yet so

00:29:45,250 --> 00:29:50,620
maps are written like that so you start

00:29:48,700 --> 00:29:52,300
with the name of what you want map if

00:29:50,620 --> 00:29:55,510
you want to be more specific in its a

00:29:52,300 --> 00:29:58,360
hashmap or Trina and then you give a lot

00:29:55,510 --> 00:30:01,480
of associations findings from keys to

00:29:58,360 --> 00:30:05,350
values and in this form here so one maps

00:30:01,480 --> 00:30:08,710
to HC 2 maps to near cleanups ugh i

00:30:05,350 --> 00:30:10,750
should say again none of this is syntax

00:30:08,710 --> 00:30:11,970
so Scott has no idea of what a

00:30:10,750 --> 00:30:14,910
collection literal

00:30:11,970 --> 00:30:18,120
what a binding is so all of that is its

00:30:14,910 --> 00:30:21,060
library show basically the right arrow

00:30:18,120 --> 00:30:23,910
is a method that's that can be injected

00:30:21,060 --> 00:30:26,430
on any object in Scala and it will just

00:30:23,910 --> 00:30:27,960
return a pair of its left operand

00:30:26,430 --> 00:30:30,960
endings right okay so that's how you

00:30:27,960 --> 00:30:34,920
construct these okay so that gives you a

00:30:30,960 --> 00:30:37,320
map of whatever you've written so it now

00:30:34,920 --> 00:30:40,320
you can select in the map and that gives

00:30:37,320 --> 00:30:45,120
you the string that corresponds to the

00:30:40,320 --> 00:30:47,490
number two you can also add new bindings

00:30:45,120 --> 00:30:49,650
to the map with class or it gives you

00:30:47,490 --> 00:30:52,920
the map that just has that this new

00:30:49,650 --> 00:30:55,110
binding so none of this changes the map

00:30:52,920 --> 00:30:58,110
they all trick generate new maps out of

00:30:55,110 --> 00:31:01,050
old ones and you can also for instance

00:30:58,110 --> 00:31:03,630
apply a function to the map so this

00:31:01,050 --> 00:31:06,180
function here just changes the keys and

00:31:03,630 --> 00:31:09,630
values so now you go you get an app that

00:31:06,180 --> 00:31:14,220
goes from strings two digits up the

00:31:09,630 --> 00:31:16,080
other way ok yeah and plus create a new

00:31:14,220 --> 00:31:17,940
map one creates a new map that's right

00:31:16,080 --> 00:31:20,040
if you want to modify it map you write

00:31:17,940 --> 00:31:22,860
plus equals and plus equals it would be

00:31:20,040 --> 00:31:24,870
kept could be applied only to a mutable

00:31:22,860 --> 00:31:27,150
map and it would do we update any place

00:31:24,870 --> 00:31:29,250
the systematic convention that whenever

00:31:27,150 --> 00:31:33,300
you have an update the operations within

00:31:29,250 --> 00:31:34,800
equals ok so now I want to take you

00:31:33,300 --> 00:31:36,510
through a little example and the example

00:31:34,800 --> 00:31:39,030
is interesting because it's actually

00:31:36,510 --> 00:31:42,360
being done before being done before in a

00:31:39,030 --> 00:31:45,420
systematic study of essentially

00:31:42,360 --> 00:31:50,480
programmer productivity and programming

00:31:45,420 --> 00:31:56,780
language gap productivity and efficiency

00:31:50,480 --> 00:31:59,100
so the task is to invent memmer onyx

00:31:56,780 --> 00:32:01,560
phrases catchphrases for telephone

00:31:59,100 --> 00:32:02,970
numbers so far in this is something that

00:32:01,560 --> 00:32:05,190
you've given a number and then you want

00:32:02,970 --> 00:32:07,470
to find a phrase something like 1 800

00:32:05,190 --> 00:32:09,330
core meany or something back like to

00:32:07,470 --> 00:32:11,460
find a phrase that matches your

00:32:09,330 --> 00:32:13,830
telephone number so for instance if you

00:32:11,460 --> 00:32:15,810
had this number here then you should

00:32:13,830 --> 00:32:19,560
have as one of the possible phrases

00:32:15,810 --> 00:32:20,910
color rocks because 7 contains the

00:32:19,560 --> 00:32:25,870
letter S

00:32:20,910 --> 00:32:27,760
to contents letter C and also contains

00:32:25,870 --> 00:32:30,370
the letter A and so on so you find you

00:32:27,760 --> 00:32:32,500
find Christians so what you want to do

00:32:30,370 --> 00:32:35,230
is you want to you're given a dictionary

00:32:32,500 --> 00:32:37,540
at a list of words and you want to

00:32:35,230 --> 00:32:40,480
design a class coder with a method

00:32:37,540 --> 00:32:43,960
translate such that new color of

00:32:40,480 --> 00:32:46,270
dictionary translate phone number gives

00:32:43,960 --> 00:32:48,430
you all phrases that match to this one

00:32:46,270 --> 00:32:51,250
so cold a dictionary gives you the class

00:32:48,430 --> 00:32:53,500
and then you'll involve translate method

00:32:51,250 --> 00:32:56,260
the vodka translate method with a phone

00:32:53,500 --> 00:33:00,130
number and you should get back then for

00:32:56,260 --> 00:33:03,730
each each time all the phrases so that

00:33:00,130 --> 00:33:05,290
example was taken from a paper called an

00:33:03,730 --> 00:33:07,360
empirical comparison of seven

00:33:05,290 --> 00:33:09,910
programming languages it appears an ITV

00:33:07,360 --> 00:33:11,980
computer or in ten years ago but it

00:33:09,910 --> 00:33:13,810
actually turns out because these studies

00:33:11,980 --> 00:33:15,430
are rather expensive they're very few of

00:33:13,810 --> 00:33:17,860
them today actually that's still the

00:33:15,430 --> 00:33:20,140
last one of general programming language

00:33:17,860 --> 00:33:22,270
comparison the back seat at the time

00:33:20,140 --> 00:33:26,380
they tested it with tickle Python Perl

00:33:22,270 --> 00:33:28,300
Rex Java C++ and C and then of course

00:33:26,380 --> 00:33:31,780
they asked interesting questions like

00:33:28,300 --> 00:33:34,180
which one which languages language

00:33:31,780 --> 00:33:35,980
yields the fastest programs what do you

00:33:34,180 --> 00:33:48,310
think which one is fastest in all these

00:33:35,980 --> 00:33:51,460
things just almost + apples the every

00:33:48,310 --> 00:33:54,130
everyone had every language head I think

00:33:51,460 --> 00:33:56,710
overall ever I think about a hundred

00:33:54,130 --> 00:33:58,300
ropes split over those languages and

00:33:56,710 --> 00:33:59,920
there they were free to pick any

00:33:58,300 --> 00:34:01,870
algorithm that would find so it's really

00:33:59,920 --> 00:34:04,330
essentially what did people come up with

00:34:01,870 --> 00:34:05,830
no I written was given through asking to

00:34:04,330 --> 00:34:09,429
the smartest programmer time unless

00:34:05,830 --> 00:34:10,810
answer because and it isn't feel that

00:34:09,429 --> 00:34:13,030
you have a statistical sample within

00:34:10,810 --> 00:34:13,919
each language because seven languages

00:34:13,030 --> 00:34:16,810
under

00:34:13,919 --> 00:34:18,970
I think it was good enough so they did

00:34:16,810 --> 00:34:21,250
that in a bit statistic analysis and did

00:34:18,970 --> 00:34:23,590
it which I think it stood up reasonably

00:34:21,250 --> 00:34:27,360
so the answer is it actually depend

00:34:23,590 --> 00:34:32,020
depend what exactly you want to know so

00:34:27,360 --> 00:34:34,510
the fastest program was in CEO C++ no

00:34:32,020 --> 00:34:40,210
doubt about it the slowest program was

00:34:34,510 --> 00:34:42,040
also in cincy it went further toes you

00:34:40,210 --> 00:34:43,840
said well not so fast as average and

00:34:42,040 --> 00:34:45,909
actually the fastest average where the

00:34:43,840 --> 00:34:47,740
scripting languages what's the fastest

00:34:45,909 --> 00:34:49,450
median the fastest media and we

00:34:47,740 --> 00:34:52,150
understand that languages like Java C++

00:34:49,450 --> 00:34:55,780
and C so how that well it actually

00:34:52,150 --> 00:34:57,640
turned out that the scripting languages

00:34:55,780 --> 00:34:59,770
all head standard collection libraries

00:34:57,640 --> 00:35:02,800
that are well-known to programmers at

00:34:59,770 --> 00:35:04,660
good syntax for them so people used that

00:35:02,800 --> 00:35:07,840
and so they use pretty much standard

00:35:04,660 --> 00:35:10,330
preach and solutions where people in C++

00:35:07,840 --> 00:35:12,490
C and at the time Java didn't really

00:35:10,330 --> 00:35:14,770
have then have those languages and

00:35:12,490 --> 00:35:16,450
ordered libraries or didn't know that it

00:35:14,770 --> 00:35:19,300
is immediately so they're on their own

00:35:16,450 --> 00:35:20,590
and you can imagine that sometimes when

00:35:19,300 --> 00:35:23,200
you roll your own you do a brilliant

00:35:20,590 --> 00:35:25,330
thing which beats early DP camp to the

00:35:23,200 --> 00:35:27,460
solution by a wide margin but imagine

00:35:25,330 --> 00:35:29,530
that I doing collections associative

00:35:27,460 --> 00:35:31,710
maps with linked lists and I'm sure the

00:35:29,530 --> 00:35:34,120
program is did there as well so you add

00:35:31,710 --> 00:35:36,460
orders of magnitude factors to your

00:35:34,120 --> 00:35:38,050
performance and those calculate those

00:35:36,460 --> 00:35:40,660
gave you really absolutely rotten

00:35:38,050 --> 00:35:42,460
solutions which room the average for the

00:35:40,660 --> 00:35:45,220
four do you forgive you for the standard

00:35:42,460 --> 00:35:46,810
languages more stable was the code size

00:35:45,220 --> 00:35:48,640
medians which were about hundred lines

00:35:46,810 --> 00:35:50,830
for scripting languages to three hundred

00:35:48,640 --> 00:35:52,360
lines of code for the others so I'm

00:35:50,830 --> 00:35:55,960
going to do that now the skyline that we

00:35:52,360 --> 00:35:57,640
kind of do it together so that's

00:35:55,960 --> 00:35:59,650
essentially the outline of our class

00:35:57,640 --> 00:36:01,810
code app so I've given you them in mem

00:35:59,650 --> 00:36:03,700
onyx map which says to is I be seen

00:36:01,810 --> 00:36:05,320
through UCF it's just what you have on

00:36:03,700 --> 00:36:08,410
it on the keyboard of your phone and

00:36:05,320 --> 00:36:11,850
then I essentially have kind of progress

00:36:08,410 --> 00:36:14,200
through four methods the first says well

00:36:11,850 --> 00:36:17,200
well i'm going to show you the methods

00:36:14,200 --> 00:36:20,590
11 after we ever afterwards so the first

00:36:17,200 --> 00:36:22,680
method it says well we want to invert

00:36:20,590 --> 00:36:25,320
the mnemonics map to give a map

00:36:22,680 --> 00:36:27,210
characters a tube a to z two digits to

00:36:25,320 --> 00:36:30,120
drama but I could just write down the

00:36:27,210 --> 00:36:31,380
map it's a finite mapper but i'm lazy I

00:36:30,120 --> 00:36:33,750
don't want to write down all these

00:36:31,380 --> 00:36:36,300
bindings so let me quickly have a have a

00:36:33,750 --> 00:36:39,510
method warm-up method to just do that so

00:36:36,300 --> 00:36:41,880
how do I do that well is how you will do

00:36:39,510 --> 00:36:44,970
it you would just go through the map mmm

00:36:41,880 --> 00:36:47,670
onyx and that would give you pairs of

00:36:44,970 --> 00:36:50,310
keys and values called digit and the

00:36:47,670 --> 00:36:53,070
values is a string of letters and then

00:36:50,310 --> 00:36:55,770
you go through that string every letter

00:36:53,070 --> 00:36:57,870
that you get gives you a new binding

00:36:55,770 --> 00:37:00,240
from the Atlanta two digits I that's

00:36:57,870 --> 00:37:03,120
really simple that's all you need to do

00:37:00,240 --> 00:37:05,310
for that the next thing is work code so

00:37:03,120 --> 00:37:07,350
that should map a word to the digit

00:37:05,310 --> 00:37:10,140
string it can represent or not a single

00:37:07,350 --> 00:37:14,310
character but a whole way what do you do

00:37:10,140 --> 00:37:16,650
then so for instance Java you now want

00:37:14,310 --> 00:37:18,510
to map to the word 5282 because that's

00:37:16,650 --> 00:37:21,660
it Richard string that represents the

00:37:18,510 --> 00:37:24,450
word child so that's what you do you

00:37:21,660 --> 00:37:26,310
just have a map but you notice that

00:37:24,450 --> 00:37:28,860
their car coat only works for uppercase

00:37:26,310 --> 00:37:30,510
letters or you we want to convert the

00:37:28,860 --> 00:37:32,910
word first to uppercase that's just the

00:37:30,510 --> 00:37:35,160
java method and then we just say well

00:37:32,910 --> 00:37:37,320
for each one of them apply car coat and

00:37:35,160 --> 00:37:40,260
give you this straight so one thing you

00:37:37,320 --> 00:37:42,240
notice here is swings are collections

00:37:40,260 --> 00:37:44,660
and you have the uniform in turn type

00:37:42,240 --> 00:37:46,740
principle so if you map a string

00:37:44,660 --> 00:37:49,380
character to character function over

00:37:46,740 --> 00:37:52,770
string you get back a string so that's

00:37:49,380 --> 00:37:55,260
what it gives yet third one where it's

00:37:52,770 --> 00:37:58,320
for num so it's a map from digit strings

00:37:55,260 --> 00:37:59,640
to the words that represent them what do

00:37:58,320 --> 00:38:02,220
you do there so for instance now you

00:37:59,640 --> 00:38:05,250
want to say so the previous one said

00:38:02,220 --> 00:38:06,690
Java goes to five two and two now now we

00:38:05,250 --> 00:38:09,000
want to turn it around and say what

00:38:06,690 --> 00:38:11,820
words that's five to eight to correspond

00:38:09,000 --> 00:38:14,520
to and the answer will be a set Java but

00:38:11,820 --> 00:38:16,310
also cutter our lava they all nap to 5

00:38:14,520 --> 00:38:20,100
282 and you want the set of all of them

00:38:16,310 --> 00:38:21,630
so what do you do here you first it's

00:38:20,100 --> 00:38:23,370
actually good to write down the type

00:38:21,630 --> 00:38:27,600
what you want you want a map from string

00:38:23,370 --> 00:38:28,160
to list of strength here these things

00:38:27,600 --> 00:38:32,450
actually

00:38:28,160 --> 00:38:35,539
represented as a as a disease okay so

00:38:32,450 --> 00:38:37,640
that actually it takes some some time to

00:38:35,539 --> 00:38:40,910
wrap your head around it but if you look

00:38:37,640 --> 00:38:43,099
at it it's just that it's words group by

00:38:40,910 --> 00:38:45,170
embed code so that's it's a group but

00:38:43,099 --> 00:38:48,740
it's nothing but that so I just go by

00:38:45,170 --> 00:38:50,900
strand eternity stator okay and now we

00:38:48,740 --> 00:38:53,750
come to this final method then that will

00:38:50,900 --> 00:38:56,270
be not a one liner and simple that's how

00:38:53,750 --> 00:38:59,240
the encode method so we want to return

00:38:56,270 --> 00:39:03,920
all ways to encounter number as a list

00:38:59,240 --> 00:39:07,490
of words so the signature is it takes a

00:39:03,920 --> 00:39:09,619
number digital string and we list of

00:39:07,490 --> 00:39:11,329
words sets of phrase so every phrase is

00:39:09,619 --> 00:39:14,240
a list of strings every strings a word

00:39:11,329 --> 00:39:16,579
and we want to set of all solutions so

00:39:14,240 --> 00:39:18,700
I'm not just one but so we've got the

00:39:16,579 --> 00:39:21,410
user type is set of list of strength

00:39:18,700 --> 00:39:22,730
okay so let's get started so the first

00:39:21,410 --> 00:39:24,230
thing is to say well let's do the

00:39:22,730 --> 00:39:27,079
borderline case first a number might be

00:39:24,230 --> 00:39:29,030
empty in that case there is a solution

00:39:27,079 --> 00:39:31,039
that corresponds to that that's just the

00:39:29,030 --> 00:39:33,559
empty frames the empty frame corresponds

00:39:31,039 --> 00:39:36,170
to the empty number our solution that

00:39:33,559 --> 00:39:39,559
case is a set of an imperious set of

00:39:36,170 --> 00:39:42,980
real stuff now the next thing is to say

00:39:39,559 --> 00:39:45,710
well what what are my choices so the

00:39:42,980 --> 00:39:47,329
first choice I have is to say well how

00:39:45,710 --> 00:39:49,549
long is the first word in that phrase

00:39:47,329 --> 00:39:50,900
because the phrase might consist of more

00:39:49,549 --> 00:39:52,730
than one word so the question is how

00:39:50,900 --> 00:39:54,650
long will the first worth be four

00:39:52,730 --> 00:39:56,900
possible choices are it might be just a

00:39:54,650 --> 00:39:58,880
single character or it might go up to

00:39:56,900 --> 00:40:00,589
the whole length of the number so in

00:39:58,880 --> 00:40:03,049
that case I would have a single word in

00:40:00,589 --> 00:40:04,880
my friends so I say okay let's go from

00:40:03,049 --> 00:40:08,029
one to the length of the number we

00:40:04,880 --> 00:40:10,849
convert this dangerous okay now I do do

00:40:08,029 --> 00:40:13,700
that thing with a 4 i'd say okay let's

00:40:10,849 --> 00:40:16,279
take every one of those consider every

00:40:13,700 --> 00:40:19,420
one of those call it my split point what

00:40:16,279 --> 00:40:22,819
do i need to do now i need to say well

00:40:19,420 --> 00:40:25,010
give me all words that correspond to the

00:40:22,819 --> 00:40:26,930
first digits that I've selected

00:40:25,010 --> 00:40:28,940
different first digits that I've

00:40:26,930 --> 00:40:31,369
selected that way I can express this

00:40:28,940 --> 00:40:32,990
number take split pump take as a method

00:40:31,369 --> 00:40:35,450
that works on all collections including

00:40:32,990 --> 00:40:38,359
sports strengths I could also have

00:40:35,450 --> 00:40:39,119
written number substring zeros per point

00:40:38,359 --> 00:40:42,809
it would

00:40:39,119 --> 00:40:44,400
same thing then the next thing is to say

00:40:42,809 --> 00:40:47,009
okay now I have all the words that

00:40:44,400 --> 00:40:48,960
correspond to my first digit string now

00:40:47,009 --> 00:40:50,819
I have to still in code the rest of my

00:40:48,960 --> 00:40:53,609
afraid so that would be number drops

00:40:50,819 --> 00:40:56,700
good point and I do anything because of

00:40:53,609 --> 00:40:59,249
core to encode and I let rest iterate

00:40:56,700 --> 00:41:01,559
over all of these things and now to

00:40:59,249 --> 00:41:05,039
finally to assemble my friends I say

00:41:01,559 --> 00:41:06,569
well I give you back the work all all

00:41:05,039 --> 00:41:09,480
possibilities for words that i have

00:41:06,569 --> 00:41:11,400
found here and all possibilities for the

00:41:09,480 --> 00:41:13,799
rest of the phrases that i found in this

00:41:11,400 --> 00:41:15,990
line i compose them so this double

00:41:13,799 --> 00:41:20,400
column is a list component list cause

00:41:15,990 --> 00:41:22,920
operator into a newness and that's it so

00:41:20,400 --> 00:41:25,680
overall this thing is maybe 20 or 25

00:41:22,920 --> 00:41:28,470
lines and i think it had to do with the

00:41:25,680 --> 00:41:30,690
fact why could we get this much more

00:41:28,470 --> 00:41:32,670
concise and i would argue elegant

00:41:30,690 --> 00:41:34,200
program than the other solutions and i

00:41:32,670 --> 00:41:39,630
think it really had to do to say well

00:41:34,200 --> 00:41:41,369
from c to python and take off the big

00:41:39,630 --> 00:41:43,440
thing why they wear shorter was the

00:41:41,369 --> 00:41:45,210
introduction of collections and here i

00:41:43,440 --> 00:41:46,529
think the big thing why we are still a

00:41:45,210 --> 00:41:48,059
lot shorter than that is the

00:41:46,529 --> 00:41:49,410
introduction of these functional

00:41:48,059 --> 00:41:51,450
collections that are these these

00:41:49,410 --> 00:41:54,150
powerful operators that these definitely

00:41:51,450 --> 00:41:57,599
transform one to the other so this was a

00:41:54,150 --> 00:41:59,789
program that was pretty hard and groups

00:41:57,599 --> 00:42:01,739
needed i think an afternoon or something

00:41:59,789 --> 00:42:03,450
to like that and we just did it in five

00:42:01,739 --> 00:42:06,150
minutes or ten minutes well of course it

00:42:03,450 --> 00:42:07,529
was rehearsed and everything but I mean

00:42:06,150 --> 00:42:09,299
did the general thing is once you get

00:42:07,529 --> 00:42:11,309
the hang of it it's really very very

00:42:09,299 --> 00:42:13,799
simple and that's the beauty of it this

00:42:11,309 --> 00:42:15,630
is not rocket science it's really it's

00:42:13,799 --> 00:42:17,880
extremely simple to come up with

00:42:15,630 --> 00:42:20,880
solutions using this powerful set of

00:42:17,880 --> 00:42:24,119
combinations I have for instance I have

00:42:20,880 --> 00:42:26,519
given a lot of scallop forces recently

00:42:24,119 --> 00:42:29,329
to industrial programmers and to their

00:42:26,519 --> 00:42:31,499
horses it looks like that and the

00:42:29,329 --> 00:42:33,299
difficulty of course is always that they

00:42:31,499 --> 00:42:34,859
get to reckon wrap the head around this

00:42:33,299 --> 00:42:37,559
new thing functional programming because

00:42:34,859 --> 00:42:39,359
that's what I don't know and by my

00:42:37,559 --> 00:42:41,099
experience always was I teach them the

00:42:39,359 --> 00:42:42,960
basics which is essential color matching

00:42:41,099 --> 00:42:44,970
and recursion and all these things and

00:42:42,960 --> 00:42:45,710
it's very very hard so they find that

00:42:44,970 --> 00:42:48,920
really hard

00:42:45,710 --> 00:42:50,660
because it's completely new to them and

00:42:48,920 --> 00:42:52,820
recursion is difficult we know it's

00:42:50,660 --> 00:42:55,609
difficult have a matching something new

00:42:52,820 --> 00:42:57,500
and so and then I the first time I said

00:42:55,609 --> 00:42:59,630
it I said oh that didn't go too well so

00:42:57,500 --> 00:43:01,250
now the now for comes to essentially the

00:42:59,630 --> 00:43:04,220
second level that I teach them these

00:43:01,250 --> 00:43:06,740
these high order operations I say oh I'm

00:43:04,220 --> 00:43:09,080
gonna lose them all but in fact EE the

00:43:06,740 --> 00:43:11,030
opposite was true they cook they started

00:43:09,080 --> 00:43:13,160
to fly immediately with their they got

00:43:11,030 --> 00:43:14,839
it immediately and they died cooking the

00:43:13,160 --> 00:43:17,210
exercises very quickly and they got a

00:43:14,839 --> 00:43:19,760
great cooking and I was really surprised

00:43:17,210 --> 00:43:22,970
that a data but first today talked i met

00:43:19,760 --> 00:43:24,859
the butter lamps and afterwards and i

00:43:22,970 --> 00:43:27,470
talked to him about it and he said no no

00:43:24,859 --> 00:43:30,410
he's not surprised at all actually if we

00:43:27,470 --> 00:43:32,330
think back to our first blue the first

00:43:30,410 --> 00:43:35,180
time we wrote a look that was very hard

00:43:32,330 --> 00:43:37,550
to and the reason why it's hard is that

00:43:35,180 --> 00:43:40,400
there are many many steps steps in time

00:43:37,550 --> 00:43:42,710
recursion is also many many steps and

00:43:40,400 --> 00:43:45,140
then and actually controlling many steps

00:43:42,710 --> 00:43:46,880
is hard whereas these things they're

00:43:45,140 --> 00:43:48,830
very very few steps because every

00:43:46,880 --> 00:43:51,020
operation does a whole lot to your

00:43:48,830 --> 00:43:53,780
collections so if you want to get to a

00:43:51,020 --> 00:43:56,180
fixed distance and you want to do it

00:43:53,780 --> 00:43:57,619
simply then the best way first thing you

00:43:56,180 --> 00:43:59,330
can get there is you have very very

00:43:57,619 --> 00:44:01,220
powerful operators that you are loved

00:43:59,330 --> 00:44:03,260
because that means you need fewer steps

00:44:01,220 --> 00:44:04,849
to get there fewer mental steps and

00:44:03,260 --> 00:44:06,470
that's why the people actually found

00:44:04,849 --> 00:44:09,589
something program was founded actually

00:44:06,470 --> 00:44:11,750
rather nice and simple the other thing

00:44:09,589 --> 00:44:13,550
that's really nice about this that's a

00:44:11,750 --> 00:44:16,190
style of programming that gives you an

00:44:13,550 --> 00:44:18,560
extremely dense safety net for the type

00:44:16,190 --> 00:44:21,080
checker that if anything goes wrong your

00:44:18,560 --> 00:44:23,599
chances are overwhelming that the type

00:44:21,080 --> 00:44:25,310
checker will catch you this is about

00:44:23,599 --> 00:44:26,869
more about the fact that it's functional

00:44:25,310 --> 00:44:28,940
and learn more about the fact that you

00:44:26,869 --> 00:44:32,069
added those

00:44:28,940 --> 00:44:34,170
the same feeling to do the same thing by

00:44:32,069 --> 00:44:40,230
adding a bunch of methods to the string

00:44:34,170 --> 00:44:42,029
class in Java set classes both so they

00:44:40,230 --> 00:44:43,890
are very powerful methods so you can't

00:44:42,029 --> 00:44:45,839
get them wrong and you anymore because

00:44:43,890 --> 00:44:49,349
they have been done for you but the

00:44:45,839 --> 00:44:51,450
other importance is that since they are

00:44:49,349 --> 00:44:53,430
functional essentially all the

00:44:51,450 --> 00:44:55,950
interactions of these methods with the

00:44:53,430 --> 00:44:58,019
context that the rest take the form of

00:44:55,950 --> 00:44:59,789
parameters or results and all the

00:44:58,019 --> 00:45:03,900
parameters and results are subject to

00:44:59,789 --> 00:45:05,759
the type checker whereas it's not the

00:45:03,900 --> 00:45:07,200
life I was thinking about you know you

00:45:05,759 --> 00:45:09,359
can obviously write any function like

00:45:07,200 --> 00:45:10,740
that yeah I guess the way I'm thinking

00:45:09,359 --> 00:45:13,559
about what you said functional I was

00:45:10,740 --> 00:45:16,579
thinking about your hands it's more like

00:45:13,559 --> 00:45:20,430
a functional language more like an ml or

00:45:16,579 --> 00:45:21,359
that's not that's not thing you're

00:45:20,430 --> 00:45:22,529
trying to stress that they can try to

00:45:21,359 --> 00:45:23,609
stress is that there aren't any side

00:45:22,529 --> 00:45:27,180
effects and you don't have to worry

00:45:23,609 --> 00:45:29,130
enough yeah and because that no side

00:45:27,180 --> 00:45:31,859
effects essentially so for instance you

00:45:29,130 --> 00:45:33,869
forget you get the order of parameters

00:45:31,859 --> 00:45:36,420
wrong or something like that very likely

00:45:33,869 --> 00:45:38,150
the type checker will catch you up you

00:45:36,420 --> 00:45:40,589
get the order of two assignments wrong

00:45:38,150 --> 00:45:42,900
no way to type to check out with help

00:45:40,589 --> 00:45:44,519
you so strong right so so you will you

00:45:42,900 --> 00:45:46,470
will find out that run that so that's

00:45:44,519 --> 00:45:48,839
why what I mean that the type checker

00:45:46,470 --> 00:45:51,450
really gives you a much denser safety

00:45:48,839 --> 00:45:53,339
net for this list form of program okay

00:45:51,450 --> 00:45:55,769
so you might say well what does it all

00:45:53,339 --> 00:45:59,099
have to do with power parallelism and

00:45:55,769 --> 00:46:02,670
its like the beauty is that essentially

00:45:59,099 --> 00:46:06,210
we're almost there so you see here too

00:46:02,670 --> 00:46:08,789
small things in red and these two each

00:46:06,210 --> 00:46:11,400
of these essentially paralyzes one half

00:46:08,789 --> 00:46:13,769
of the program so the first one is to

00:46:11,400 --> 00:46:17,250
say well to actually generate this map

00:46:13,769 --> 00:46:19,950
worse for now in parallel all I need to

00:46:17,250 --> 00:46:22,049
do is I shouldn't pass in a list doesn't

00:46:19,950 --> 00:46:25,140
inherently sequential data structure I

00:46:22,049 --> 00:46:27,150
asked in a parallel already the ones i

00:46:25,140 --> 00:46:29,670
do that all these operations that i have

00:46:27,150 --> 00:46:31,140
math flat map filter or the four

00:46:29,670 --> 00:46:33,630
expressions that map into these

00:46:31,140 --> 00:46:35,059
operations they work run in power so

00:46:33,630 --> 00:46:38,130
there's nothing more you need to do and

00:46:35,059 --> 00:46:39,809
the second part here is when we actually

00:46:38,130 --> 00:46:40,150
do the encode thing if you want to do

00:46:39,809 --> 00:46:42,849
that

00:46:40,150 --> 00:46:45,910
now then I could do it at any point here

00:46:42,849 --> 00:46:49,119
but here just say my split said I want

00:46:45,910 --> 00:46:50,859
to turn that into a parallel set so on

00:46:49,119 --> 00:46:52,569
sequential collections you have this

00:46:50,859 --> 00:46:54,250
metal part which turns the same

00:46:52,569 --> 00:46:56,470
collection into a parallel collection

00:46:54,250 --> 00:46:57,700
and then again afterwards all the

00:46:56,470 --> 00:47:00,819
operations that you have on this

00:46:57,700 --> 00:47:04,270
collection would work in power yeah it's

00:47:00,819 --> 00:47:07,000
me Sam flip but if you tested it is it

00:47:04,270 --> 00:47:08,859
run faster in parallel this one here

00:47:07,000 --> 00:47:11,140
yeah I haven't tested this one here

00:47:08,859 --> 00:47:13,690
because my picture is not fully enough

00:47:11,140 --> 00:47:16,180
but the henna 200,000 rejection

00:47:13,690 --> 00:47:17,920
reactions thank you ok cool we'll just

00:47:16,180 --> 00:47:22,020
it right now we have to give them a

00:47:17,920 --> 00:47:25,660
pretty long oh that was kind of my point

00:47:22,020 --> 00:47:28,180
like that's not the phone yeah yeah I

00:47:25,660 --> 00:47:30,700
mean in general if you have a large

00:47:28,180 --> 00:47:35,859
datasets guess I mean it paralyzes quite

00:47:30,700 --> 00:47:37,329
nicely ok so that's a parallel

00:47:35,859 --> 00:47:39,250
collection and that's a mapping from

00:47:37,329 --> 00:47:43,089
sequential collection hello and that's

00:47:39,250 --> 00:47:45,880
essentially all there is to it so in

00:47:43,089 --> 00:47:47,950
summary in the original experiment with

00:47:45,880 --> 00:47:50,170
15 languages where shoulder and often

00:47:47,950 --> 00:47:52,180
faster because the developers used

00:47:50,170 --> 00:47:54,730
tended to use standard collections and

00:47:52,180 --> 00:47:57,039
in skala solution we obtained a further

00:47:54,730 --> 00:47:59,619
five times reduction in size to lose

00:47:57,039 --> 00:48:03,839
function connections and that easy peasy

00:47:59,619 --> 00:48:06,130
lemon try to go to parallel so these the

00:48:03,839 --> 00:48:09,220
advice I would give here is thick

00:48:06,130 --> 00:48:13,690
collection transformers not cry yeah so

00:48:09,220 --> 00:48:15,760
for the five times is it's just not fair

00:48:13,690 --> 00:48:19,510
to compare you to their group of

00:48:15,760 --> 00:48:21,549
programmers also true yeah so you can

00:48:19,510 --> 00:48:23,230
like like you did with fortress you can

00:48:21,549 --> 00:48:24,970
deduct half with the distribute through

00:48:23,230 --> 00:48:33,579
them oh let me try it in job and what

00:48:24,970 --> 00:48:38,890
we'll see her ok so you could do that ok

00:48:33,579 --> 00:48:40,660
oh yeah I'm to the heart addition that

00:48:38,890 --> 00:48:44,230
you added to make a working parent

00:48:40,660 --> 00:48:46,059
now is this telling the train I'm going

00:48:44,230 --> 00:48:47,410
to break these operations there are

00:48:46,059 --> 00:48:49,180
multiple threads or they're just making

00:48:47,410 --> 00:48:50,380
it parallelizable you have to be

00:48:49,180 --> 00:48:51,819
something else to make that one in

00:48:50,380 --> 00:48:55,000
parallel so essentially there's an

00:48:51,819 --> 00:48:56,170
there's another set of collections which

00:48:55,000 --> 00:48:59,770
are parallel collections which

00:48:56,170 --> 00:49:01,200
essentially work with with splits and

00:48:59,770 --> 00:49:04,270
join so that's good two collections

00:49:01,200 --> 00:49:06,609
repeatedly to smaller collections after

00:49:04,270 --> 00:49:11,140
the chunk size is a big chunk size is

00:49:06,609 --> 00:49:12,819
adaptive uses sir but I got this country

00:49:11,140 --> 00:49:14,140
with the works because they get the

00:49:12,819 --> 00:49:16,210
chance that is right and then it's

00:49:14,140 --> 00:49:18,460
rejoins them so it's essentially a

00:49:16,210 --> 00:49:20,260
standard state-of-the-art way to do

00:49:18,460 --> 00:49:23,589
these parallel connection and I think

00:49:20,260 --> 00:49:25,030
the new part here is that in other

00:49:23,589 --> 00:49:26,530
languages you might have a single

00:49:25,030 --> 00:49:28,930
collection which is power like para

00:49:26,530 --> 00:49:30,579
right that leaves our arrival in jail so

00:49:28,930 --> 00:49:32,260
this is a framework this you can just

00:49:30,579 --> 00:49:34,510
drop it and you can do anything with

00:49:32,260 --> 00:49:36,400
that you can be used all the stuff you

00:49:34,510 --> 00:49:38,859
know from successful and it would just

00:49:36,400 --> 00:49:40,510
work the same way however does that make

00:49:38,859 --> 00:49:43,859
a big deal about what I'm going to do is

00:49:40,510 --> 00:49:46,630
add that spread stop far no me some

00:49:43,859 --> 00:49:49,990
wedding thread whole background stages

00:49:46,630 --> 00:49:51,910
yeah there's a pool and you can you can

00:49:49,990 --> 00:49:53,980
you can actually pass the thread pool

00:49:51,910 --> 00:50:01,319
you wanted to use and if you don't pass

00:49:53,980 --> 00:50:01,319
a flat for you to be four okay so

00:50:03,170 --> 00:50:10,200
so yeah question is loading so the part

00:50:08,130 --> 00:50:13,440
of it does it vary people or is this

00:50:10,200 --> 00:50:16,079
carlos optional if he grabs I've

00:50:13,440 --> 00:50:18,599
inherited part of the cottage leaves to

00:50:16,079 --> 00:50:23,719
get to our guarantees that they would

00:50:18,599 --> 00:50:26,789
run we got there looking at each other

00:50:23,719 --> 00:50:29,940
they won't deadlock but you might have

00:50:26,789 --> 00:50:31,349
get beautiful races because I mean the

00:50:29,940 --> 00:50:33,479
point is if you run these things in

00:50:31,349 --> 00:50:35,880
parallel they would be run power there's

00:50:33,479 --> 00:50:37,890
no there's no analysis which says well

00:50:35,880 --> 00:50:41,009
actually you're stepping on it so for

00:50:37,890 --> 00:50:43,289
instance if you did in parallel a thing

00:50:41,009 --> 00:50:45,150
that averages out the elements

00:50:43,289 --> 00:50:47,219
consecutive elements of an array let's

00:50:45,150 --> 00:50:48,960
say right and you would run them all in

00:50:47,219 --> 00:50:50,460
parallel and you might rather get the

00:50:48,960 --> 00:50:52,380
wrong answer because you might actually

00:50:50,460 --> 00:50:54,450
think you have an element of an array

00:50:52,380 --> 00:50:57,210
but you actually already got the average

00:50:54,450 --> 00:51:01,160
I mean if you do that by mutating the

00:50:57,210 --> 00:51:03,180
same of it so there's no there's no

00:51:01,160 --> 00:51:05,519
there's nothing that prevents you from

00:51:03,180 --> 00:51:07,079
doing this thing the way you prevented

00:51:05,519 --> 00:51:09,299
from doing this thing is to say well

00:51:07,079 --> 00:51:11,549
actually I want to do that with a little

00:51:09,299 --> 00:51:16,499
collection so I'm not actually updating

00:51:11,549 --> 00:51:18,269
the collections that idea to move if you

00:51:16,499 --> 00:51:21,420
are fully admitted with everything is

00:51:18,269 --> 00:51:22,859
easy just like a lot of things are in

00:51:21,420 --> 00:51:24,930
the real world it is the immutable

00:51:22,859 --> 00:51:26,400
substances paralyzed Bureau and then yes

00:51:24,930 --> 00:51:28,529
and you just get it in parallel

00:51:26,400 --> 00:51:30,989
essentially paralyzed same thing is

00:51:28,529 --> 00:51:32,849
lucky for Java which is essentially the

00:51:30,989 --> 00:51:34,469
same the same outgrowth of the same

00:51:32,849 --> 00:51:38,430
efficiency the same of the same

00:51:34,469 --> 00:51:40,619
underlying fortunes scheduler so they

00:51:38,430 --> 00:51:44,809
had to ask EDG writer from scratch or do

00:51:40,619 --> 00:51:48,940
you set this code we wrote a huge punch

00:51:44,809 --> 00:51:52,729
we measured against Disko graduates

00:51:48,940 --> 00:51:55,190
okay another question yeah there's

00:51:52,729 --> 00:51:58,729
another major source of immutable

00:51:55,190 --> 00:52:03,170
activity non-determinism in java light

00:51:58,729 --> 00:52:05,509
languages you sort of paper over here I

00:52:03,170 --> 00:52:08,690
often paper over it myself and I'm

00:52:05,509 --> 00:52:10,309
wondering if you had a sense of how it

00:52:08,690 --> 00:52:13,039
impacts here and the major source of

00:52:10,309 --> 00:52:15,259
non-determinism here is worse than it is

00:52:13,039 --> 00:52:17,900
in Java code is a lengthy preamble it's

00:52:15,259 --> 00:52:20,989
its object allocation and garbage

00:52:17,900 --> 00:52:23,059
collection you don't see you don't see

00:52:20,989 --> 00:52:28,849
it but it's creating a hell of alot of

00:52:23,059 --> 00:52:30,589
objects and and every time you do I make

00:52:28,849 --> 00:52:32,989
more objects you're likely aware you've

00:52:30,589 --> 00:52:36,680
enjoyed our fun I've been myself i push

00:52:32,989 --> 00:52:40,190
internally that if usual data structures

00:52:36,680 --> 00:52:43,509
everywhere but now there's new data

00:52:40,190 --> 00:52:45,619
there's a big customer in turn means

00:52:43,509 --> 00:52:47,690
she's trying to switch over to using

00:52:45,619 --> 00:52:49,249
immutable data structures will be having

00:52:47,690 --> 00:52:51,349
a hard time to go to the garden because

00:52:49,249 --> 00:52:53,569
of cows collection yellow so how do you

00:52:51,349 --> 00:52:56,539
how do you try to attract what what what

00:52:53,569 --> 00:52:58,249
is the way that you can i interject

00:52:56,539 --> 00:53:00,349
anything which is it's not just

00:52:58,249 --> 00:53:03,109
performance this is actually something

00:53:00,349 --> 00:53:06,049
easing into a clarification but you can

00:53:03,109 --> 00:53:08,900
observe different results you know based

00:53:06,049 --> 00:53:11,920
on a lot of sake different hash codes no

00:53:08,900 --> 00:53:13,999
because of garbage collection yeah oh

00:53:11,920 --> 00:53:15,979
you because of because of funny

00:53:13,999 --> 00:53:18,049
conversation then I'm kitchen and the

00:53:15,979 --> 00:53:20,930
fact that the hair coat if you don't

00:53:18,049 --> 00:53:22,279
override object for the hash code is a

00:53:20,930 --> 00:53:26,839
functional exactly when the object

00:53:22,279 --> 00:53:29,269
itself Yeah Yeah right so let me address

00:53:26,839 --> 00:53:33,229
the performance problem first so that I

00:53:29,269 --> 00:53:35,390
agree so performance I mean you create a

00:53:33,229 --> 00:53:37,160
lot of immutable objects and the garbage

00:53:35,390 --> 00:53:39,079
collectors to keep up with it may be

00:53:37,160 --> 00:53:40,940
something that mitigates that is that

00:53:39,079 --> 00:53:44,239
actually in skaara if you have

00:53:40,940 --> 00:53:46,099
collections / primitive types what you

00:53:44,239 --> 00:53:48,259
will be able to do what they may be

00:53:46,099 --> 00:53:50,569
mechanisms is there to actually have

00:53:48,259 --> 00:53:52,519
them specialized so that you won't box

00:53:50,569 --> 00:53:54,769
the primitive types of these things in

00:53:52,519 --> 00:53:57,079
function values it's the same thing so

00:53:54,769 --> 00:53:58,260
so that helps but on the other end of

00:53:57,079 --> 00:54:00,480
year of collection for spring

00:53:58,260 --> 00:54:02,190
yeah well yeah so these are garbage

00:54:00,480 --> 00:54:04,770
these are deep allocated and there's

00:54:02,190 --> 00:54:07,710
nothing we can do in terms of the hash

00:54:04,770 --> 00:54:09,800
codes again I think the the answer is

00:54:07,710 --> 00:54:12,540
well I guess you should probably

00:54:09,800 --> 00:54:13,980
discourage having inheriting just the

00:54:12,540 --> 00:54:15,510
hash code from object that's probably

00:54:13,980 --> 00:54:17,250
not a good way to do it you should just

00:54:15,510 --> 00:54:19,740
calculate them out of the structure

00:54:17,250 --> 00:54:21,390
which is what if you use case classes in

00:54:19,740 --> 00:54:26,790
Scala the compiler actually does for you

00:54:21,390 --> 00:54:41,280
there are obviously families of classes

00:54:26,790 --> 00:54:43,590
for which it's appropriate currently no

00:54:41,280 --> 00:54:46,830
we just rely on essentially escape

00:54:43,590 --> 00:54:48,810
analysis in the JVM s which is as has

00:54:46,830 --> 00:54:51,420
gotten pretty pretty good recently so

00:54:48,810 --> 00:54:53,430
data once we find there's a lot of

00:54:51,420 --> 00:54:55,320
improvement and maybe you see something

00:54:53,430 --> 00:54:58,020
else for you I think we're done in a

00:54:55,320 --> 00:55:03,170
propaganda and now it's on the way after

00:54:58,020 --> 00:55:06,600
6 16 21 or so it's on other thing okay

00:55:03,170 --> 00:55:09,000
okay in functional compilers there's a

00:55:06,600 --> 00:55:11,910
lot of effort going into analysis for

00:55:09,000 --> 00:55:14,490
deforestation get avoid the creation of

00:55:11,910 --> 00:55:17,100
the intermediate it just are you looking

00:55:14,490 --> 00:55:20,210
at that dirt poor scholar hey while

00:55:17,100 --> 00:55:24,060
we're looking at it in a more

00:55:20,210 --> 00:55:25,920
fundamental context so what we do

00:55:24,060 --> 00:55:28,080
actually with the Stanford guys are not

00:55:25,920 --> 00:55:30,150
far from here looka looka tuna and pat

00:55:28,080 --> 00:55:31,830
hanrahan have a very big project it

00:55:30,150 --> 00:55:34,530
looks at the so-called language

00:55:31,830 --> 00:55:38,760
virtualization which means that you

00:55:34,530 --> 00:55:41,070
write this stuff here and what job is

00:55:38,760 --> 00:55:43,170
essentially in these collections what

00:55:41,070 --> 00:55:45,270
what what this connection here does to

00:55:43,170 --> 00:55:48,200
say how did it turn parallel basically

00:55:45,270 --> 00:55:51,000
it says well my first generator here was

00:55:48,200 --> 00:55:52,680
became from it was a sequential

00:55:51,000 --> 00:55:54,390
collection now is a parallel connection

00:55:52,680 --> 00:55:58,230
so the whole thing rests on the type of

00:55:54,390 --> 00:56:00,510
the generators here so you and actually

00:55:58,230 --> 00:56:02,370
that syntax is very very general so you

00:56:00,510 --> 00:56:05,190
can have another type of generator that

00:56:02,370 --> 00:56:07,230
means that instead of executing anything

00:56:05,190 --> 00:56:07,790
it just construct a representation of

00:56:07,230 --> 00:56:09,380
itself

00:56:07,790 --> 00:56:11,630
which is actually this thing does and

00:56:09,380 --> 00:56:13,790
then a drum time would actually optimize

00:56:11,630 --> 00:56:15,560
this thing so what we do is essentially

00:56:13,790 --> 00:56:17,480
to say well to take this to the next

00:56:15,560 --> 00:56:18,680
level when you say well this part of the

00:56:17,480 --> 00:56:20,660
collections they're probably good as

00:56:18,680 --> 00:56:21,970
long as you have maybe ten course or

00:56:20,660 --> 00:56:24,140
twenty course or something like that

00:56:21,970 --> 00:56:27,110
24,000 course even that is not good

00:56:24,140 --> 00:56:29,870
enough right 2000 4000 shirts so that

00:56:27,110 --> 00:56:31,130
then I believe you need this next level

00:56:29,870 --> 00:56:33,020
which says well you really need

00:56:31,130 --> 00:56:35,270
introspection and compilers that look at

00:56:33,020 --> 00:56:36,920
the code deforestation is one very

00:56:35,270 --> 00:56:38,510
trivial part of that but there many many

00:56:36,920 --> 00:56:41,720
other things that you have to do that

00:56:38,510 --> 00:56:43,340
yeah so in terms of the functional

00:56:41,720 --> 00:56:44,630
programming there are certain kinds of

00:56:43,340 --> 00:56:46,670
applications that I just can't figure

00:56:44,630 --> 00:56:48,680
out how to write in a functional style

00:56:46,670 --> 00:56:50,150
and two examples that come to mind is

00:56:48,680 --> 00:56:51,890
some sort of interactive editor for

00:56:50,150 --> 00:56:54,110
structured drawings and the second one

00:56:51,890 --> 00:56:56,240
is like games like World of Warcraft or

00:56:54,110 --> 00:56:59,570
wait where you have a large data set

00:56:56,240 --> 00:57:00,920
where any given player can only affect a

00:56:59,570 --> 00:57:02,510
small number of variables for each

00:57:00,920 --> 00:57:03,710
turnin so you're only mutating a small

00:57:02,510 --> 00:57:05,930
part of the world and it's too expensive

00:57:03,710 --> 00:57:08,360
to process the entire virtual world

00:57:05,930 --> 00:57:10,490
every video frame right and so you want

00:57:08,360 --> 00:57:11,570
to be able to patch changes to the world

00:57:10,490 --> 00:57:14,240
I can't figure out how to do that

00:57:11,570 --> 00:57:17,270
functionally my initials usually use

00:57:14,240 --> 00:57:18,800
imperative that's also my this case

00:57:17,270 --> 00:57:21,080
Ghana is not a few function language

00:57:18,800 --> 00:57:22,730
that you can perfectly well use the

00:57:21,080 --> 00:57:24,710
imperative code in Scala you can write

00:57:22,730 --> 00:57:27,200
it just as you could java code but the

00:57:24,710 --> 00:57:29,690
point is why you can do it functionally

00:57:27,200 --> 00:57:31,040
I believe you should I think there are

00:57:29,690 --> 00:57:33,770
more and more reasons why you should and

00:57:31,040 --> 00:57:35,390
sort of this sort of thing is a clear

00:57:33,770 --> 00:57:37,010
thing that you say well yes of course I

00:57:35,390 --> 00:57:38,930
could do it with single updates and

00:57:37,010 --> 00:57:40,820
connections modifying collections but

00:57:38,930 --> 00:57:43,190
that way is both clear and mobile

00:57:40,820 --> 00:57:46,060
risible so I think you should but not I

00:57:43,190 --> 00:57:47,870
fully agree that there are some some

00:57:46,060 --> 00:57:49,340
applications where it's just not very

00:57:47,870 --> 00:57:52,190
suitable and then you shouldn't use it

00:57:49,340 --> 00:57:54,830
yeah will you permit me to manatee how

00:57:52,190 --> 00:57:57,080
to do room oh ok well if they also i

00:57:54,830 --> 00:57:59,900
think the most important and the most

00:57:57,080 --> 00:58:02,480
controversial of sentencing said in your

00:57:59,900 --> 00:58:05,240
whole talk was once you get this really

00:58:02,480 --> 00:58:08,350
really soon quoting word for work the

00:58:05,240 --> 00:58:12,080
first place i read that about this

00:58:08,350 --> 00:58:14,060
language with this sort of trinsic

00:58:12,080 --> 00:58:15,620
complexity was structure and a

00:58:14,060 --> 00:58:17,270
traditional computer programmed

00:58:15,620 --> 00:58:19,250
he pretty much says the same thing look

00:58:17,270 --> 00:58:21,950
it's 25 years old or something like that

00:58:19,250 --> 00:58:25,010
and I've also found that if you get a

00:58:21,950 --> 00:58:27,620
MIT home remedy under what is withdrawn

00:58:25,010 --> 00:58:28,970
and talk to him he'll tell you I didn't

00:58:27,620 --> 00:58:31,130
really understand that class in my

00:58:28,970 --> 00:58:32,980
freshman year I love that both in their

00:58:31,130 --> 00:58:36,140
back and reread it when I was a junior

00:58:32,980 --> 00:58:38,050
so what I'm skeptical that without you

00:58:36,140 --> 00:58:42,920
to teach them or someone of her caliber

00:58:38,050 --> 00:58:46,250
the masses will understand two core

00:58:42,920 --> 00:58:48,200
concepts okay so so maybe two two

00:58:46,250 --> 00:58:50,750
arguments so the first one is talking

00:58:48,200 --> 00:58:53,420
tree I I wasn't teaching in my tea

00:58:50,750 --> 00:58:55,370
students i was teaching really pretty

00:58:53,420 --> 00:58:58,310
run-of-the-mill java program nothing

00:58:55,370 --> 00:59:01,370
mighty students when you get him drunk

00:58:58,310 --> 00:59:04,400
and yeah what I shouldn't be talking

00:59:01,370 --> 00:59:06,530
about this nation even admit that when

00:59:04,400 --> 00:59:10,010
they were freshmen this was many years

00:59:06,530 --> 00:59:12,260
ago he's King had a hard time but I was

00:59:10,010 --> 00:59:14,330
advocating neither scheme structure and

00:59:12,260 --> 00:59:15,710
interpretation of computer programs even

00:59:14,330 --> 00:59:18,260
though I must say it's a very fine book

00:59:15,710 --> 00:59:20,240
I really like what I'm not advocating it

00:59:18,260 --> 00:59:22,540
as for for for general consumption not

00:59:20,240 --> 00:59:25,370
not at all but this is these are really

00:59:22,540 --> 00:59:27,560
standard Java programmers not

00:59:25,370 --> 00:59:29,690
particularly I did that didn't seem

00:59:27,560 --> 00:59:31,520
particularly different from the ones you

00:59:29,690 --> 00:59:33,650
find and they didn't have a problem with

00:59:31,520 --> 00:59:36,860
it and maybe it's me teaching them and

00:59:33,650 --> 00:59:38,360
then I guess I'd you have to teach many

00:59:36,860 --> 00:59:40,040
more teachers that can do it the same

00:59:38,360 --> 00:59:44,870
thing but I think fundamentally no it's

00:59:40,040 --> 00:59:47,240
not hard it's not hard to do that this

00:59:44,870 --> 00:59:48,860
is what that something for stuff this in

00:59:47,240 --> 00:59:50,810
the last year and a half I've seen more

00:59:48,860 --> 00:59:52,580
and more groups that helped a lot

00:59:50,810 --> 00:59:54,440
because the first time I run into Scala

00:59:52,580 --> 00:59:56,870
I was waiting online documentation three

00:59:54,440 --> 00:59:59,570
years ago an eggy but after two weeks

00:59:56,870 --> 01:00:01,820
and two years ago I run into a couple of

00:59:59,570 --> 01:00:04,180
books and that would take off I could do

01:00:01,820 --> 01:00:07,970
it myself and I knew anything special

01:00:04,180 --> 01:00:11,150
yeah I'm not I'm not debating that you

01:00:07,970 --> 01:00:13,040
you know anyone in this room can you

01:00:11,150 --> 01:00:17,700
learn it and learn it quickly I'm

01:00:13,040 --> 01:00:20,380
wondering if it scales up into

01:00:17,700 --> 01:00:22,150
been good what screams okay maybe I

01:00:20,380 --> 01:00:25,060
should quickly go to the end and I

01:00:22,150 --> 01:00:31,290
because I am excited so I have to chop a

01:00:25,060 --> 01:00:35,890
lot of the more technical stuff sequel

01:00:31,290 --> 01:00:37,500
let's do another talk okay so but I

01:00:35,890 --> 01:00:40,120
think that that's why it's also

01:00:37,500 --> 01:00:42,850
something to that kept you said can I

01:00:40,120 --> 01:00:45,730
feel radically different for producers

01:00:42,850 --> 01:00:47,950
and consumers of those libraries so for

01:00:45,730 --> 01:00:49,840
the consumer I maintain this really

01:00:47,950 --> 01:00:52,270
typically if the libraries are done well

01:00:49,840 --> 01:00:54,010
it's really easy it works intuitively

01:00:52,270 --> 01:00:56,830
and you can't concentrate on the domain

01:00:54,010 --> 01:01:00,370
documentation as an extreme case I have

01:00:56,830 --> 01:01:02,530
the case of Kodjoe Kodjoe is essentially

01:01:00,370 --> 01:01:06,100
an learning environment to program

01:01:02,530 --> 01:01:08,620
programming written in SCADA using SCADA

01:01:06,100 --> 01:01:10,810
as the teaching language being used by

01:01:08,620 --> 01:01:13,390
hundreds of girls in an indian school

01:01:10,810 --> 01:01:14,890
for for disadvantaged children and it's

01:01:13,390 --> 01:01:17,680
a beautiful environment that works with

01:01:14,890 --> 01:01:20,140
it so she builds on NetBeans and it's

01:01:17,680 --> 01:01:22,930
actually uses a scholar sort of a logo

01:01:20,140 --> 01:01:25,240
like subset of sky but it doesn't

01:01:22,930 --> 01:01:28,720
momentum believe you this argument and I

01:01:25,240 --> 01:01:31,660
in fact we made this for you i'm going

01:01:28,720 --> 01:01:34,450
to say six seven years here about a

01:01:31,660 --> 01:01:36,940
bunch of the job of five changes and

01:01:34,450 --> 01:01:38,560
agrat ibly in after the world has fought

01:01:36,940 --> 01:01:41,380
with these things for years I've come to

01:01:38,560 --> 01:01:43,870
believe it I was dead wrong when someone

01:01:41,380 --> 01:01:45,790
who need new names added wild cards to

01:01:43,870 --> 01:01:48,190
your type system you know the claim was

01:01:45,790 --> 01:01:51,070
yeah library writers will have to deal

01:01:48,190 --> 01:01:53,530
with this but they'll be invisible to

01:01:51,070 --> 01:01:57,040
users those libraries and that turned

01:01:53,530 --> 01:01:59,230
out to be not but I remember the very

01:01:57,040 --> 01:02:01,300
same time it was writing males after

01:01:59,230 --> 01:02:03,160
measurement after Mason said don't do

01:02:01,300 --> 01:02:05,140
wild cards because users will see this

01:02:03,160 --> 01:02:06,760
stuff it will be in the face of users

01:02:05,140 --> 01:02:08,680
and you should do it the way its color

01:02:06,760 --> 01:02:10,660
does it because it's got ed really is

01:02:08,680 --> 01:02:13,690
part of the new language besides when I

01:02:10,660 --> 01:02:16,150
argument it was precisely my argument to

01:02:13,690 --> 01:02:18,460
say why cards push complexity in for the

01:02:16,150 --> 01:02:20,950
users hands and they do your phone you

01:02:18,460 --> 01:02:23,710
absolutely right but in

01:02:20,950 --> 01:02:27,640
so you still believe that it is possible

01:02:23,710 --> 01:02:29,410
to isolate the complexity to the library

01:02:27,640 --> 01:02:32,619
writers and that's college achieve your

01:02:29,410 --> 01:02:36,670
duties we I think we are a good way to

01:02:32,619 --> 01:02:41,050
do it I think the easy if you know what

01:02:36,670 --> 01:02:43,300
to use them then yes so if they are to

01:02:41,050 --> 01:02:45,550
me there are a growing number of

01:02:43,300 --> 01:02:47,770
libraries that are really a pleasure to

01:02:45,550 --> 01:02:50,260
use and that i extremely simple to use

01:02:47,770 --> 01:02:52,270
much simpler than the alternatives the

01:02:50,260 --> 01:02:53,829
one question that I have right now is

01:02:52,270 --> 01:02:56,560
essentially how do we bottle it up how

01:02:53,829 --> 01:02:58,270
do we prevent a casual user of a library

01:02:56,560 --> 01:03:00,670
to do all the advanced stuff that they

01:02:58,270 --> 01:03:02,470
have to do all the advanced tools that

01:03:00,670 --> 01:03:04,450
they have to do to do that and my

01:03:02,470 --> 01:03:07,150
current answer to that is probably

01:03:04,450 --> 01:03:08,950
profits or limp like things to say well

01:03:07,150 --> 01:03:10,750
there would be some things where you

01:03:08,950 --> 01:03:12,369
would get a warning if you let's say use

01:03:10,750 --> 01:03:14,530
an implicit or things like that there

01:03:12,369 --> 01:03:16,240
would be user categories to signal the

01:03:14,530 --> 01:03:19,540
beginning scholar user should never

01:03:16,240 --> 01:03:21,760
define an implicit just show a place

01:03:19,540 --> 01:03:23,560
it's a brilliant that amazingly because

01:03:21,760 --> 01:03:24,849
it's essentially implicit are they the

01:03:23,560 --> 01:03:26,920
key why we could have a same

01:03:24,849 --> 01:03:28,510
implementations of arrays it's kind of

01:03:26,920 --> 01:03:30,040
not not like the mess that's in Java

01:03:28,510 --> 01:03:32,980
without impresses it would have been

01:03:30,040 --> 01:03:35,710
possible so I you bring them out of my

01:03:32,980 --> 01:03:38,530
hands over my dead body maybe I needed

01:03:35,710 --> 01:03:40,480
lessons but I fully agree a casual user

01:03:38,530 --> 01:03:42,940
shouldn't you sir and our challenge now

01:03:40,480 --> 01:03:44,680
is to really be able to distinguish

01:03:42,940 --> 01:03:46,240
clearly between one of the other so I

01:03:44,680 --> 01:03:47,589
think profiles is probably the way to

01:03:46,240 --> 01:03:51,540
get there right now it's just

01:03:47,589 --> 01:03:51,540
essentially good taste and good advice

01:03:52,859 --> 01:03:58,529
yep so you took me earlier about

01:03:55,799 --> 01:03:59,849
building cathedrals now get ability

01:03:58,529 --> 01:04:02,009
people you can't say that were working

01:03:59,849 --> 01:04:03,869
apparently many words as possible to

01:04:02,009 --> 01:04:05,999
build the walls and then when it or not

01:04:03,869 --> 01:04:07,940
to bear something off til the rooms and

01:04:05,999 --> 01:04:11,249
throughout the gargoyles and so forth

01:04:07,940 --> 01:04:23,150
camas can handle piece of complicated

01:04:11,249 --> 01:04:25,470
pipeline where you and then I

01:04:23,150 --> 01:04:28,140
automatically from Wisconsin apology to

01:04:25,470 --> 01:04:31,710
st. actually a roof needs leave the

01:04:28,140 --> 01:04:33,749
balls inductance L is going into it's

01:04:31,710 --> 01:04:35,819
actually you have to pass the border

01:04:33,749 --> 01:04:39,390
that you to pass the balls to the rope

01:04:35,819 --> 01:04:41,099
to the low filler so is the red pool

01:04:39,390 --> 01:04:42,509
that handles you're paralyzed a shin can

01:04:41,099 --> 01:04:45,059
to ensure the results of the crappy

01:04:42,509 --> 01:04:46,470
allocated setting as major as possible

01:04:45,059 --> 01:04:49,380
the first class and there's some petals

01:04:46,470 --> 01:04:52,829
are conservative ever tells us what does

01:04:49,380 --> 01:04:54,599
that mean Daniel intervention I think we

01:04:52,829 --> 01:04:56,130
need to avoid clear to find out that

01:04:54,599 --> 01:04:58,769
it's certainly something that lift

01:04:56,130 --> 01:05:00,630
during we'll get there at the m I mean

01:04:58,769 --> 01:05:02,999
this whole thing i should say isn't it's

01:05:00,630 --> 01:05:04,799
got a 219 it's not released yet so right

01:05:02,999 --> 01:05:08,220
now we have the basic implementations

01:05:04,799 --> 01:05:11,849
will be released and probably january in

01:05:08,220 --> 01:05:14,039
first rc and only then people will build

01:05:11,849 --> 01:05:16,109
the applications that then we find out

01:05:14,039 --> 01:05:19,200
essentially what we need to do to make

01:05:16,109 --> 01:05:21,210
this work over bigger but it's a bit of

01:05:19,200 --> 01:05:24,720
a gift to the future videos of future

01:05:21,210 --> 01:05:27,569
first album also there there's library

01:05:24,720 --> 01:05:30,840
work going on right now in both in from

01:05:27,569 --> 01:05:33,420
jdk 7 something called phaser and

01:05:30,840 --> 01:05:36,360
in other languages as well that price to

01:05:33,420 --> 01:05:38,670
make easier to create such things that

01:05:36,360 --> 01:05:40,710
we have multiple phases of work and you

01:05:38,670 --> 01:05:43,620
have your pedal is improving a certain

01:05:40,710 --> 01:05:44,940
phase and then everyone rendevouz and

01:05:43,620 --> 01:05:48,510
then they go on to the next space and

01:05:44,940 --> 01:05:50,970
there are some languages like x10 and

01:05:48,510 --> 01:05:56,120
habanero are both Java like languages

01:05:50,970 --> 01:05:56,120
back I try to do have syntactic support

01:05:59,990 --> 01:06:05,940
there are you anyway restricted by your

01:06:02,400 --> 01:06:07,529
choice you java TM the design of

01:06:05,940 --> 01:06:11,450
language we do have done some to date

01:06:07,529 --> 01:06:11,450
from teachers will come up in Lothian

01:06:15,020 --> 01:06:19,619
yeah probably would have had full care

01:06:17,819 --> 01:06:22,970
for elimination which we don't have

01:06:19,619 --> 01:06:25,380
because of machardie em it's just

01:06:22,970 --> 01:06:27,750
impossible to do it with falling for

01:06:25,380 --> 01:06:29,849
ability it's not just that the vm but

01:06:27,750 --> 01:06:32,099
also the fact that we need to really

01:06:29,849 --> 01:06:34,230
have a very transparent interoperability

01:06:32,099 --> 01:06:36,240
with java programs that in a sense was

01:06:34,230 --> 01:06:37,770
there are no description because they

01:06:36,240 --> 01:06:40,619
are ways to actually print some stupid

01:06:37,770 --> 01:06:43,079
for an elimination reason is being

01:06:40,619 --> 01:06:44,700
efficient efficiently but it means that

01:06:43,079 --> 01:06:46,289
you have to fiddle with the interfaces

01:06:44,700 --> 01:06:47,880
of all your methods essentially give

01:06:46,289 --> 01:06:50,250
them a trampoline parameter we have a

01:06:47,880 --> 01:06:51,720
paper on that a long time ago but it

01:06:50,250 --> 01:06:53,819
means that essentially your java methods

01:06:51,720 --> 01:06:55,559
can't really reasonably corneal scholar

01:06:53,819 --> 01:06:58,109
method samuel so we didn't want to do

01:06:55,559 --> 01:07:00,150
that otherwise i mean there's some

01:06:58,109 --> 01:07:02,750
things that were are a bit unfortunate

01:07:00,150 --> 01:07:06,390
like that every class gets a full

01:07:02,750 --> 01:07:08,279
concept and this is a separate file that

01:07:06,390 --> 01:07:10,380
there's no useful notion of weeks in

01:07:08,279 --> 01:07:11,970
composition I mean even the defender

01:07:10,380 --> 01:07:14,339
methods that I have been proposed for

01:07:11,970 --> 01:07:17,670
java 8 that don't quite have it for

01:07:14,339 --> 01:07:19,230
about 40 me but i mean overall i mean

01:07:17,670 --> 01:07:20,940
that's basically it has been extremely

01:07:19,230 --> 01:07:23,640
beneficial because the kind of

01:07:20,940 --> 01:07:25,049
optimizations are evangelion for large

01:07:23,640 --> 01:07:28,520
to an article ii exactly the

01:07:25,049 --> 01:07:28,520

YouTube URL: https://www.youtube.com/watch?v=R9a4MO0EKH0


