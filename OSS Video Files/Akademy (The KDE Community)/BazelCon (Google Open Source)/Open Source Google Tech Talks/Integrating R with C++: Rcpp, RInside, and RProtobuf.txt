Title: Integrating R with C++: Rcpp, RInside, and RProtobuf
Publication date: 2010-10-27
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talk
October 22, 2010

Presented by Dirk Eddelbuettel and Romain Francois.

ABSTRACT

The R Intergrouplet has invited long-time R contributors Dirk and Romain to give a joint tech talk about some of the recent developments on their open-source R packages. The Rcpp package provides a consistent C++ class hierarchy that maps various types of R objects to dedicated C++ classes. Object interchange between R and C++ is managed by simple, flexible, and extensible concepts which include broad support for popular C++ idioms from the Standard Template Library. RInside is used to embed R in C++ applications, and RProtobuf is the Protocol Buffers API for R.
Captions: 
	00:00:20,849 --> 00:00:26,039
well first of all I'd like to thank

00:00:22,679 --> 00:00:28,739
Google for the opportunity to share some

00:00:26,039 --> 00:00:34,530
of the work we've been doing around RN

00:00:28,739 --> 00:00:36,870
C++ on a personal note I you know I've

00:00:34,530 --> 00:00:41,010
been using our for for so many years now

00:00:36,870 --> 00:00:43,290
for about 10 years and the joke I

00:00:41,010 --> 00:00:46,589
usually say now is that it almost feels

00:00:43,290 --> 00:00:50,760
like I'm married to to language to our

00:00:46,589 --> 00:00:52,620
language I am I I keep having fun with

00:00:50,760 --> 00:00:55,640
the language I keep learning new things

00:00:52,620 --> 00:00:57,900
about about you know about our I keep

00:00:55,640 --> 00:01:00,269
being really interested in this language

00:00:57,900 --> 00:01:03,150
although it doesn't mean though that I

00:01:00,269 --> 00:01:04,739
don't often like to spend time with

00:01:03,150 --> 00:01:08,400
other languages you know having a few

00:01:04,739 --> 00:01:10,380
indiscretions with with you know other

00:01:08,400 --> 00:01:14,490
other sorts of languages I've had a long

00:01:10,380 --> 00:01:18,000
long-term story on the side with Java we

00:01:14,490 --> 00:01:21,240
sort of we're not talking too much to

00:01:18,000 --> 00:01:24,630
each other anymore these days but this

00:01:21,240 --> 00:01:31,170
was a nice relationship so when Doug

00:01:24,630 --> 00:01:33,780
introduced me to C++ last year I really

00:01:31,170 --> 00:01:35,850
spend a lot of time now with C++ and I'm

00:01:33,780 --> 00:01:38,580
really happy to to learn this language

00:01:35,850 --> 00:01:43,020
and and and now what we want to do today

00:01:38,580 --> 00:01:45,299
is share some of the work we've done and

00:01:43,020 --> 00:01:48,659
show this indiscretion obviously Dirk

00:01:45,299 --> 00:01:50,909
has spent much more time than me over

00:01:48,659 --> 00:01:53,520
the years with C++ ah I've just started

00:01:50,909 --> 00:01:57,330
a year ago but we've managed to do quite

00:01:53,520 --> 00:02:01,080
a substantial amount of work since then

00:01:57,330 --> 00:02:09,360
and so this is what we want to share

00:02:01,080 --> 00:02:11,610
with you today okay Jinyu yeah let me

00:02:09,360 --> 00:02:13,680
just briefly share what romance said and

00:02:11,610 --> 00:02:16,230
say thank you to to Google for having us

00:02:13,680 --> 00:02:18,390
and Marie for making this this happen

00:02:16,230 --> 00:02:23,450
this is this is really nice we're

00:02:18,390 --> 00:02:27,629
sorting going to talk about I and C++

00:02:23,450 --> 00:02:29,400
and connections in a large sense the

00:02:27,629 --> 00:02:31,529
bridge that was on the previous example

00:02:29,400 --> 00:02:33,749
will come again as a metaphor and here's

00:02:31,529 --> 00:02:34,680
just a few points sort of what we

00:02:33,749 --> 00:02:36,510
assuming so

00:02:34,680 --> 00:02:38,099
generally speaking everything should

00:02:36,510 --> 00:02:40,920
work with current packages on all

00:02:38,099 --> 00:02:43,349
supported operating systems exceptions

00:02:40,920 --> 00:02:45,659
noted so we didn't have a protocol

00:02:43,349 --> 00:02:49,650
buffer binary on Windows that's

00:02:45,659 --> 00:02:53,519
something that we may sort out and some

00:02:49,650 --> 00:02:55,400
of the most recent slides assume the

00:02:53,519 --> 00:02:58,430
version of other was released last week

00:02:55,400 --> 00:03:00,900
and also we made shortcuts and things so

00:02:58,430 --> 00:03:03,420
then as an introduction we weren't quite

00:03:00,900 --> 00:03:06,750
sure who we'd be talking to experienced

00:03:03,420 --> 00:03:08,730
long time I users or you know otherwise

00:03:06,750 --> 00:03:10,799
computer scientists interested by us so

00:03:08,730 --> 00:03:14,459
you know just just to get warmed up

00:03:10,799 --> 00:03:16,829
here's a really simple example on why

00:03:14,459 --> 00:03:20,400
you would want to work with our that

00:03:16,829 --> 00:03:21,599
that crossed sort of my daily readings

00:03:20,400 --> 00:03:23,939
that was on the mailing list the other

00:03:21,599 --> 00:03:25,709
day and in the beginning it's just sort

00:03:23,939 --> 00:03:27,480
of three statements sort of we assign

00:03:25,709 --> 00:03:28,829
from one of the given data sets it's

00:03:27,480 --> 00:03:31,170
sort of a bit like a running joke that

00:03:28,829 --> 00:03:33,209
in are many things are on standard data

00:03:31,170 --> 00:03:34,889
sets so eruptions of the faithful

00:03:33,209 --> 00:03:36,180
Ricardo are one so we're just assigning

00:03:34,889 --> 00:03:37,769
those we're fitting a density function

00:03:36,180 --> 00:03:39,900
we plot those with three standards

00:03:37,769 --> 00:03:41,879
nothing special about that but the

00:03:39,900 --> 00:03:44,220
actual example that was shown was the

00:03:41,879 --> 00:03:46,500
following so with just four more

00:03:44,220 --> 00:03:49,220
statements you get you know a Monte

00:03:46,500 --> 00:03:51,449
Carlo replication over 10,000 repeats of

00:03:49,220 --> 00:03:55,139
estimating this density then taking

00:03:51,449 --> 00:03:56,579
quantiles out and hence seeing the the

00:03:55,139 --> 00:03:59,129
uncertainty around that density

00:03:56,579 --> 00:04:01,319
estimates as well as the fit itself and

00:03:59,129 --> 00:04:03,989
that you know why we keep using R

00:04:01,319 --> 00:04:05,310
because it's not that easy to do this in

00:04:03,989 --> 00:04:08,760
certain statements with another language

00:04:05,310 --> 00:04:10,949
so with that let's sort of take R as a

00:04:08,760 --> 00:04:12,690
given and once you work with it in our

00:04:10,949 --> 00:04:14,310
curious about pushing it a little you

00:04:12,690 --> 00:04:16,470
think about extending it so that's

00:04:14,310 --> 00:04:21,030
that's how we got here sort of extending

00:04:16,470 --> 00:04:23,760
@yr C++ extending our is covered in two

00:04:21,030 --> 00:04:27,570
chapters in John Chambers most recent

00:04:23,760 --> 00:04:29,280
book and that sort of really spoke to me

00:04:27,570 --> 00:04:31,320
when I first read that so I just want to

00:04:29,280 --> 00:04:33,659
highlight what what he's set here which

00:04:31,320 --> 00:04:35,520
is you know it's it's I itself the

00:04:33,659 --> 00:04:38,280
interpreter is the C language program so

00:04:35,520 --> 00:04:40,800
you can extend it easily from C but it

00:04:38,280 --> 00:04:42,389
may not be as easy as it seems so he

00:04:40,800 --> 00:04:44,130
says there are some edit dangers and

00:04:42,389 --> 00:04:47,910
then maybe a substantial amount of

00:04:44,130 --> 00:04:49,290
programming and debugging involved so he

00:04:47,910 --> 00:04:51,210
discusses this a little bit more and

00:04:49,290 --> 00:04:54,120
puts a road map up with a couple of

00:04:51,210 --> 00:04:56,250
points against if you do this it's more

00:04:54,120 --> 00:04:59,820
work than programming enough if you get

00:04:56,250 --> 00:05:01,050
bugs they will be nasty if this may

00:04:59,820 --> 00:05:03,090
introduce potential platform

00:05:01,050 --> 00:05:06,090
dependencies and your code may be less

00:05:03,090 --> 00:05:10,500
readable may or may not be however if

00:05:06,090 --> 00:05:12,540
you do this you can go and into

00:05:10,500 --> 00:05:13,800
uncharted waters there's the directive

00:05:12,540 --> 00:05:15,630
and the mission of course all throughout

00:05:13,800 --> 00:05:17,160
the book so you know can you can you can

00:05:15,630 --> 00:05:19,500
boldly go and try things that haven't

00:05:17,160 --> 00:05:21,630
been done before you may also just reap

00:05:19,500 --> 00:05:24,270
speed and there was something already

00:05:21,630 --> 00:05:26,700
about object references we will come

00:05:24,270 --> 00:05:28,770
back to that but basically one of the

00:05:26,700 --> 00:05:32,130
two extension paradigms in our made that

00:05:28,770 --> 00:05:33,600
relatively easy so you know I grew up

00:05:32,130 --> 00:05:35,220
with a lot of soccer around me if I look

00:05:33,600 --> 00:05:37,500
at that it's the score of four to three

00:05:35,220 --> 00:05:39,030
towards the end so it's the deck stacked

00:05:37,500 --> 00:05:41,160
against err should we do this or should

00:05:39,030 --> 00:05:42,840
we not do this and what we want to do

00:05:41,160 --> 00:05:44,820
with this talk is to convince you that

00:05:42,840 --> 00:05:46,680
absolutely you should do this because

00:05:44,820 --> 00:05:49,050
you pick the half that you're playing in

00:05:46,680 --> 00:05:50,280
and we hope to convince you that we're

00:05:49,050 --> 00:05:52,650
sort of some of the tools that we've

00:05:50,280 --> 00:05:54,870
worked on it gets a lot easier so

00:05:52,650 --> 00:05:57,750
remember from the opening slide there

00:05:54,870 --> 00:05:59,520
was a bridge bridge as a metaphor to get

00:05:57,750 --> 00:06:02,070
from one language to the other and that

00:05:59,520 --> 00:06:04,290
bridge we'll come back to it briefly is

00:06:02,070 --> 00:06:06,030
sort of a dangerous bridge what we are

00:06:04,290 --> 00:06:07,560
sort of trying to think is that you know

00:06:06,030 --> 00:06:08,940
the work that we're putting together of

00:06:07,560 --> 00:06:10,530
course it's not quite as impressive as

00:06:08,940 --> 00:06:12,960
Norman Foster's work but it's more sort

00:06:10,530 --> 00:06:15,930
of along the lines of this and this is

00:06:12,960 --> 00:06:19,410
actually something relatively close to

00:06:15,930 --> 00:06:22,080
to where o man lives in Montpelier and

00:06:19,410 --> 00:06:24,270
it shapes an hour or more than an hour

00:06:22,080 --> 00:06:26,460
office office travel time so you know it

00:06:24,270 --> 00:06:28,680
gets you different places it's well

00:06:26,460 --> 00:06:31,650
engineered it's safe travels and a lot

00:06:28,680 --> 00:06:32,970
faster so works for us so what are we

00:06:31,650 --> 00:06:36,840
going to talk about it's mostly about

00:06:32,970 --> 00:06:39,450
our CPP and a couple of other projects

00:06:36,840 --> 00:06:42,050
that came along with it the goal is to

00:06:39,450 --> 00:06:47,220
make the integration between R and C++

00:06:42,050 --> 00:06:49,980
easier and more seamless this uses a

00:06:47,220 --> 00:06:53,340
standard interface in the our system the

00:06:49,980 --> 00:06:55,680
DOT call interface on longer talks are

00:06:53,340 --> 00:06:57,300
sometimes mention also the the preceding

00:06:55,680 --> 00:06:59,400
ones but let's just let's just work on

00:06:57,300 --> 00:07:01,020
this and basically it operates on a

00:06:59,400 --> 00:07:03,090
standard you

00:07:01,020 --> 00:07:05,900
in style data of structure on inputs as

00:07:03,090 --> 00:07:09,449
well as outputs we do come back to that

00:07:05,900 --> 00:07:11,699
what a CV offers then is the natural

00:07:09,449 --> 00:07:13,949
mapping between objects in sort of the

00:07:11,699 --> 00:07:19,199
programming sense between R and C++

00:07:13,949 --> 00:07:21,210
using C++ classes we've also did some

00:07:19,199 --> 00:07:22,889
work that helps tremendously for

00:07:21,210 --> 00:07:25,830
prototyping using a package called

00:07:22,889 --> 00:07:29,750
inline work by somebody else that we've

00:07:25,830 --> 00:07:32,699
extended to use it in this context it

00:07:29,750 --> 00:07:34,229
also heavily used by us we have over 700

00:07:32,699 --> 00:07:36,630
unit tests in the package and they

00:07:34,229 --> 00:07:38,490
basically all use use inline we will

00:07:36,630 --> 00:07:40,409
show how that works

00:07:38,490 --> 00:07:43,470
this puts no additional hurdles and

00:07:40,409 --> 00:07:45,330
burdens on you for package building and

00:07:43,470 --> 00:07:47,610
you know some extensions that came along

00:07:45,330 --> 00:07:50,759
helped with other things like highly

00:07:47,610 --> 00:07:52,770
efficient math using other recent C++

00:07:50,759 --> 00:07:55,009
tricks and I think we'll come to that as

00:07:52,770 --> 00:07:55,009
well

00:07:56,330 --> 00:08:05,490
shall we why don't you do to him so okay

00:08:03,330 --> 00:08:07,229
so essentially what what what Dirk said

00:08:05,490 --> 00:08:09,889
before with with the other side is that

00:08:07,229 --> 00:08:16,139
there is an existing bridge I mean are

00:08:09,889 --> 00:08:19,590
already lets you connect to C or C++ out

00:08:16,139 --> 00:08:21,270
of the box but we feel that to be able

00:08:19,590 --> 00:08:25,520
to cross this bridge you have to wear a

00:08:21,270 --> 00:08:28,800
nice fedora hat and and another web and

00:08:25,520 --> 00:08:31,830
well not everybody you know does that so

00:08:28,800 --> 00:08:36,990
we believe we can make a better bridge I

00:08:31,830 --> 00:08:39,930
am there so this this is sort of a

00:08:36,990 --> 00:08:44,310
comeback from previous slides so R is a

00:08:39,930 --> 00:08:51,350
C program and then so quite easily lets

00:08:44,310 --> 00:08:56,160
you hook mount our with with our other C

00:08:51,350 --> 00:08:57,899
extensions and any easily extends to C++

00:08:56,160 --> 00:09:01,700
as well all you have to do is include

00:08:57,899 --> 00:09:04,620
adult CPP file in a specific place in

00:09:01,700 --> 00:09:09,360
your package and and you're able to use

00:09:04,620 --> 00:09:12,360
C++ but you do this through a C API

00:09:09,360 --> 00:09:14,670
which is essentially you know C

00:09:12,360 --> 00:09:17,490
functions and n macros and

00:09:14,670 --> 00:09:20,700
we believe we can encapsulate things

00:09:17,490 --> 00:09:24,030
much more nicely and then with what

00:09:20,700 --> 00:09:30,110
we've done with our CPP so the sort of

00:09:24,030 --> 00:09:33,000
the sort of function we will see here a

00:09:30,110 --> 00:09:36,440
function that all looked the same they

00:09:33,000 --> 00:09:43,710
that take one well they take zero one or

00:09:36,440 --> 00:09:48,090
up to 65 our object any our object is s

00:09:43,710 --> 00:09:50,340
exp and they return another one and to

00:09:48,090 --> 00:09:52,440
be able to call them you do dot call the

00:09:50,340 --> 00:09:55,500
name of the function and then you pass

00:09:52,440 --> 00:09:59,280
arguments to it so that's the classic

00:09:55,500 --> 00:10:03,810
sort of how to call C or C++ function

00:09:59,280 --> 00:10:07,290
from from and then the sort of things

00:10:03,810 --> 00:10:12,690
you do is not sure everybody can read

00:10:07,290 --> 00:10:16,440
this but yeah yeah you see the you see

00:10:12,690 --> 00:10:19,530
the sort of C API you able to do to

00:10:16,440 --> 00:10:22,140
manipulate there so we get a and B from

00:10:19,530 --> 00:10:26,820
from are the two parameters of this

00:10:22,140 --> 00:10:32,340
function and then we sort of carefully

00:10:26,820 --> 00:10:35,850
coerce them to two numeric vectors on

00:10:32,340 --> 00:10:39,780
the fourth and fifth line with the

00:10:35,850 --> 00:10:42,800
protect statement then we create a new

00:10:39,780 --> 00:10:45,930
numeric vector of a given size that we

00:10:42,800 --> 00:10:53,640
you know that it is the size of the of

00:10:45,930 --> 00:10:56,730
the a object and then we grab the actual

00:10:53,640 --> 00:11:00,840
data pointer double double pointer and

00:10:56,730 --> 00:11:04,260
then we manipulate this to do some

00:11:00,840 --> 00:11:07,050
really simple computation there the the

00:11:04,260 --> 00:11:12,560
sort of thing I probably want to

00:11:07,050 --> 00:11:15,840
highlight there is the the protect when

00:11:12,560 --> 00:11:17,520
when you create new objects you need to

00:11:15,840 --> 00:11:20,100
protect them so that the garbage

00:11:17,520 --> 00:11:24,390
collector doesn't come and steal them

00:11:20,100 --> 00:11:26,040
from you and then when you're done with

00:11:24,390 --> 00:11:28,540
these object when you want return back

00:11:26,040 --> 00:11:32,540
to the outside you need to unprotect

00:11:28,540 --> 00:11:36,980
right this asks a lot of work from the

00:11:32,540 --> 00:11:39,680
program and and we believe we we can do

00:11:36,980 --> 00:11:43,579
nicer than this and well we know we can

00:11:39,680 --> 00:11:46,220
do nicer than this some other example to

00:11:43,579 --> 00:11:49,790
manipulate character vectors so you have

00:11:46,220 --> 00:11:53,990
to again protect you don't have to call

00:11:49,790 --> 00:11:58,279
a locker vector to create a new cracked

00:11:53,990 --> 00:12:01,040
vector of two strings and then to set

00:11:58,279 --> 00:12:04,579
the strings you call an another macro

00:12:01,040 --> 00:12:09,649
set string element the object position

00:12:04,579 --> 00:12:13,990
and this funny MK car function again and

00:12:09,649 --> 00:12:23,199
so on so you this is typical let's see

00:12:13,990 --> 00:12:23,199
examples you use when you extend yes M

00:12:26,649 --> 00:12:34,760
and another function I'm not even going

00:12:31,130 --> 00:12:36,350
to talk about this too much but the what

00:12:34,760 --> 00:12:38,810
if you want to call an hour function

00:12:36,350 --> 00:12:43,069
directly from C well you can do things

00:12:38,810 --> 00:12:47,000
like this it makes a lisp people really

00:12:43,069 --> 00:12:51,139
happy but it makes me you know going to

00:12:47,000 --> 00:12:53,449
the pharmacy too much though so there

00:12:51,139 --> 00:12:57,440
you go that's the kind of examples of C

00:12:53,449 --> 00:12:59,089
code you can embed in an R package if

00:12:57,440 --> 00:13:02,029
you don't have our CPP and if you do

00:12:59,089 --> 00:13:07,940
have our CPP now well this is what we

00:13:02,029 --> 00:13:09,850
will talk now if you want to so just to

00:13:07,940 --> 00:13:11,779
summarize what we're offering is

00:13:09,850 --> 00:13:14,120
encapsulation of these s expression

00:13:11,779 --> 00:13:16,579
objects that's a union type and it's

00:13:14,120 --> 00:13:18,920
it's the thing that gets passed no

00:13:16,579 --> 00:13:20,750
matter what is represented as something

00:13:18,920 --> 00:13:27,410
you generated in an our session our

00:13:20,750 --> 00:13:29,089
program we represent those then as you

00:13:27,410 --> 00:13:30,949
know vectors of numerics or ins as a

00:13:29,089 --> 00:13:34,040
function as an environment language lots

00:13:30,949 --> 00:13:36,410
of them there's two very important work

00:13:34,040 --> 00:13:40,750
of functions s and Raph which help you

00:13:36,410 --> 00:13:40,750
to go from our

00:13:41,620 --> 00:13:46,340
you know the wording is still wrong and

00:13:43,730 --> 00:13:49,580
yeah so as actually the other way around

00:13:46,340 --> 00:13:52,490
it's from C++ to R and it's rap for

00:13:49,580 --> 00:13:55,040
sending it back and the way we've said

00:13:52,490 --> 00:13:57,170
the classes up it also cooperates quite

00:13:55,040 --> 00:14:00,140
nicely with with current programming

00:13:57,170 --> 00:14:01,880
standards it uses a lot of you know

00:14:00,140 --> 00:14:03,830
things from the STL like like iterators

00:14:01,880 --> 00:14:06,470
so here's a bit of a long table we'll

00:14:03,830 --> 00:14:08,630
stay too long on it but basically what

00:14:06,470 --> 00:14:10,490
you have on the right you may know as an

00:14:08,630 --> 00:14:12,890
AR programmer you know there's integers

00:14:10,490 --> 00:14:15,200
numerix logical expression characters

00:14:12,890 --> 00:14:17,360
there's more advanced things that you

00:14:15,200 --> 00:14:18,860
may have used you know I once worked a

00:14:17,360 --> 00:14:20,930
lot with external pointers to overcome

00:14:18,860 --> 00:14:22,610
some memory limitations there's as for

00:14:20,930 --> 00:14:25,850
classes functions environments all that

00:14:22,610 --> 00:14:27,620
we have that if you're a script has one

00:14:25,850 --> 00:14:29,270
of these you can pass them down and you

00:14:27,620 --> 00:14:33,320
have them in C++ and you can work on

00:14:29,270 --> 00:14:34,910
them that's a good thing just a quick

00:14:33,320 --> 00:14:36,770
example about how this works there's

00:14:34,910 --> 00:14:38,990
there's different ways to go about the

00:14:36,770 --> 00:14:41,510
business we don't prescribe a single one

00:14:38,990 --> 00:14:43,490
so suppose that you've you know gotten

00:14:41,510 --> 00:14:47,000
through call or otherwise and s

00:14:43,490 --> 00:14:49,280
expression X you can immediately use a

00:14:47,000 --> 00:14:52,550
constructor from an SE XP to create a

00:14:49,280 --> 00:14:54,200
numeric vector Y of X a really important

00:14:52,550 --> 00:14:57,470
point that we'll be coming back to is

00:14:54,200 --> 00:14:59,450
this tests for type the SX P is a union

00:14:57,470 --> 00:15:01,550
type and it could be anything so you

00:14:59,450 --> 00:15:03,530
could be writing down a function and

00:15:01,550 --> 00:15:06,880
want to construct a numeric vector from

00:15:03,530 --> 00:15:09,470
it that won't work and that gets called

00:15:06,880 --> 00:15:10,880
properly I know that you're programming

00:15:09,470 --> 00:15:12,920
guidelines sort of argue against

00:15:10,880 --> 00:15:15,680
exceptions we found it helps us for sort

00:15:12,920 --> 00:15:17,330
of cases like that that you know may be

00:15:15,680 --> 00:15:18,500
a point where you guys need to need to

00:15:17,330 --> 00:15:23,630
differ in the code if you want to avoid

00:15:18,500 --> 00:15:26,720
that other things are deep copies of the

00:15:23,630 --> 00:15:29,060
object we're using what sometimes it's

00:15:26,720 --> 00:15:31,460
called proxy classes because these are

00:15:29,060 --> 00:15:33,050
objects really are pointers we're having

00:15:31,460 --> 00:15:36,620
relatively shallow and efficient

00:15:33,050 --> 00:15:38,210
wrapping around them so if you're not

00:15:36,620 --> 00:15:40,820
careful and we had some examples like

00:15:38,210 --> 00:15:42,140
that on the mailing list if you create

00:15:40,820 --> 00:15:44,780
two objects they're actually not

00:15:42,140 --> 00:15:46,940
distinct if you want the same sort of

00:15:44,780 --> 00:15:48,980
content twice you have to use clone

00:15:46,940 --> 00:15:51,110
that's you know common with some other

00:15:48,980 --> 00:15:53,390
C++ frameworks too so in essence we

00:15:51,110 --> 00:15:56,120
offer a deep copy you can also of

00:15:53,390 --> 00:15:58,220
construct just from a numeric if you

00:15:56,120 --> 00:15:59,899
just give one for vectors and semantic

00:15:58,220 --> 00:16:02,720
is then oh you want a vector of that

00:15:59,899 --> 00:16:04,850
size likewise you can also create offset

00:16:02,720 --> 00:16:06,680
size and have it filled that works if

00:16:04,850 --> 00:16:08,360
you have a numeric vector which by its

00:16:06,680 --> 00:16:09,890
type is constrained to be of a single

00:16:08,360 --> 00:16:12,110
dimension if we give two arguments

00:16:09,890 --> 00:16:15,529
that's into a British size and payload

00:16:12,110 --> 00:16:18,320
you can also have sort of an internal

00:16:15,529 --> 00:16:20,660
sweep if you wish over it and have it

00:16:18,320 --> 00:16:23,360
filled for example with uniform randoms

00:16:20,660 --> 00:16:26,620
what happens is you see sort of coolant

00:16:23,360 --> 00:16:31,730
: RF there are itself

00:16:26,620 --> 00:16:33,560
capi see header files over the years

00:16:31,730 --> 00:16:35,480
that I've used that I've often combined

00:16:33,560 --> 00:16:37,220
it with you know other software that may

00:16:35,480 --> 00:16:39,829
have an elder header files and an erisa

00:16:37,220 --> 00:16:41,180
is a little generous at times about what

00:16:39,829 --> 00:16:43,399
it defines in macros there are things

00:16:41,180 --> 00:16:45,380
like lengths max and you can run into

00:16:43,399 --> 00:16:47,990
accidents with that and the best way

00:16:45,380 --> 00:16:49,579
around it there is of course everything

00:16:47,990 --> 00:16:51,019
can be done with other is it this way

00:16:49,579 --> 00:16:53,510
around it so you basically have to

00:16:51,019 --> 00:16:55,579
define no remap which we do for you but

00:16:53,510 --> 00:16:58,190
the the consequence of that then is that

00:16:55,579 --> 00:17:00,350
you need to basically explicitly the way

00:16:58,190 --> 00:17:02,360
it's done in C prefix your namespace

00:17:00,350 --> 00:17:04,160
with our F underscore for all functions

00:17:02,360 --> 00:17:05,870
so instead of having lengths that may

00:17:04,160 --> 00:17:08,150
conflict with somebody else's length now

00:17:05,870 --> 00:17:12,250
you have our F underscore length so this

00:17:08,150 --> 00:17:17,419
fills you with with the uniform and then

00:17:12,250 --> 00:17:19,459
likewise you can also use the colon

00:17:17,419 --> 00:17:21,439
colon create that that's often used on

00:17:19,459 --> 00:17:23,329
return from functions to have existing

00:17:21,439 --> 00:17:26,949
options basically just just placed in

00:17:23,329 --> 00:17:30,140
there we showed you other examples

00:17:26,949 --> 00:17:31,429
character vectors how to call a function

00:17:30,140 --> 00:17:33,140
he is just something that we hadn't

00:17:31,429 --> 00:17:34,700
shown at the I example but environments

00:17:33,140 --> 00:17:36,740
are something very important for

00:17:34,700 --> 00:17:38,870
advanced sort of our programming there's

00:17:36,740 --> 00:17:40,070
a few constructors for environments that

00:17:38,870 --> 00:17:41,900
your our session will already have

00:17:40,070 --> 00:17:43,760
global environment empty room and bays

00:17:41,900 --> 00:17:45,740
and so on you can create new

00:17:43,760 --> 00:17:48,290
environments you can inherit them from

00:17:45,740 --> 00:17:50,270
existing packages you can refer to

00:17:48,290 --> 00:17:53,690
parent and child environments so it's

00:17:50,270 --> 00:18:01,220
it's basically what you may need to

00:17:53,690 --> 00:18:04,610
encounter is is provided here is an

00:18:01,220 --> 00:18:07,400
example from

00:18:04,610 --> 00:18:11,780
I think the first user package that I

00:18:07,400 --> 00:18:13,850
had when I started working on this again

00:18:11,780 --> 00:18:15,140
after sort of the rebirth of our CPP

00:18:13,850 --> 00:18:17,060
that's that's from someone else housed

00:18:15,140 --> 00:18:20,200
Africa who wanted something really

00:18:17,060 --> 00:18:23,090
simple he just wanted to create a new

00:18:20,200 --> 00:18:24,920
new distance metric on vectors and he

00:18:23,090 --> 00:18:26,660
had a C++ function that did that and

00:18:24,920 --> 00:18:28,070
came to our help or other valent didn't

00:18:26,660 --> 00:18:29,270
quite know what to do so I told him well

00:18:28,070 --> 00:18:31,160
you know there's this package that makes

00:18:29,270 --> 00:18:32,390
it really really easy and at the time

00:18:31,160 --> 00:18:34,760
there weren't that many other existing

00:18:32,390 --> 00:18:37,040
packages to point to so just gave him a

00:18:34,760 --> 00:18:39,110
hand and it's still only an hour Fortran

00:18:37,040 --> 00:18:40,160
not on cran because the underlying C++

00:18:39,110 --> 00:18:42,380
function I think has a corporate

00:18:40,160 --> 00:18:44,030
copyright from Siemens on it and with

00:18:42,380 --> 00:18:45,230
that it's not sort of really open source

00:18:44,030 --> 00:18:47,630
so we didn't feel like it's worth

00:18:45,230 --> 00:18:49,880
putting on cran but we may I put that up

00:18:47,630 --> 00:18:52,310
here to show that if you have something

00:18:49,880 --> 00:18:54,110
that wraps say you have a certain

00:18:52,310 --> 00:18:56,090
library function summer and you want to

00:18:54,110 --> 00:18:58,250
bind them this is sort of the minimally

00:18:56,090 --> 00:19:00,580
sufficient framework in this for this

00:18:58,250 --> 00:19:02,960
particular function earthmoving distance

00:19:00,580 --> 00:19:04,310
L one measure they're sort of two

00:19:02,960 --> 00:19:06,470
vectors in there it computes the

00:19:04,310 --> 00:19:08,690
distance between the two and the sex for

00:19:06,470 --> 00:19:10,280
parents the way it's used then is that

00:19:08,690 --> 00:19:12,500
you instantiate the two vectors that's

00:19:10,280 --> 00:19:14,480
very straightforward just just as we did

00:19:12,500 --> 00:19:16,520
on the previous slide then there's also

00:19:14,480 --> 00:19:17,840
parents which we stick on a list and

00:19:16,520 --> 00:19:20,750
this slide sort of works as a reminder

00:19:17,840 --> 00:19:25,100
what lists can do lists this our

00:19:20,750 --> 00:19:26,810
you know catch-all for all purposes data

00:19:25,100 --> 00:19:28,700
structure in our it's the one data

00:19:26,810 --> 00:19:30,320
structure that can contain lots of

00:19:28,700 --> 00:19:32,540
different objects of different types and

00:19:30,320 --> 00:19:34,880
it allows us basically to do key value

00:19:32,540 --> 00:19:36,740
lookups so here we then just looking for

00:19:34,880 --> 00:19:39,140
parameters that should be passed in in

00:19:36,740 --> 00:19:42,470
an our list parameter called verbose

00:19:39,140 --> 00:19:43,970
which we expect to be a bool an

00:19:42,470 --> 00:19:45,200
exception will be thrown if that's not

00:19:43,970 --> 00:19:48,230
the case and with that we can just

00:19:45,200 --> 00:19:51,320
assign it to bool you could have one two

00:19:48,230 --> 00:19:54,170
or two dozen such lookup parameters and

00:19:51,320 --> 00:19:55,730
it also allows nesting because lists can

00:19:54,170 --> 00:19:57,260
contain lists contain this basically

00:19:55,730 --> 00:19:59,960
it's a data structure that is a list of

00:19:57,260 --> 00:20:01,970
s exp s each element can be in S exp so

00:19:59,960 --> 00:20:04,640
we could also have passed those two

00:20:01,970 --> 00:20:05,900
vectors inside that that parameters had

00:20:04,640 --> 00:20:08,030
we cared for it but it's less obvious

00:20:05,900 --> 00:20:11,270
the same thing happens when you return

00:20:08,030 --> 00:20:13,400
so here we're using the create member

00:20:11,270 --> 00:20:16,720
function for numeric vector to send the

00:20:13,400 --> 00:20:16,720
the distance value

00:20:17,790 --> 00:20:21,390
which is actually at that point of scale

00:20:19,800 --> 00:20:27,390
I believe so we could have sent a double

00:20:21,390 --> 00:20:29,130
crochet with the names with the name

00:20:27,390 --> 00:20:31,860
disk back so it's a it's a vector that

00:20:29,130 --> 00:20:33,570
you can use named lock up on s and R and

00:20:31,860 --> 00:20:36,270
at the bottom is the standard framework

00:20:33,570 --> 00:20:39,030
to catch exceptions of that inherit from

00:20:36,270 --> 00:20:40,260
standard exceptions um and then the text

00:20:39,030 --> 00:20:41,970
gets passed back and you actually get

00:20:40,260 --> 00:20:43,770
that at the operand or if it's an

00:20:41,970 --> 00:20:49,350
unknown exception you just get a get a

00:20:43,770 --> 00:20:55,140
stanza you want to take from here that

00:20:49,350 --> 00:20:57,120
leads to shorter thing um so some some

00:20:55,140 --> 00:21:00,510
other example I'll quickly go through

00:20:57,120 --> 00:21:06,480
wit because I have a lot more things to

00:21:00,510 --> 00:21:09,290
cover this is the same example that we

00:21:06,480 --> 00:21:15,840
did show before with it with a macros so

00:21:09,290 --> 00:21:17,670
as you can see with they're not well the

00:21:15,840 --> 00:21:19,440
code is much much shorter and then we

00:21:17,670 --> 00:21:20,880
can use larger font so that you can

00:21:19,440 --> 00:21:25,500
actually see what's happening

00:21:20,880 --> 00:21:28,680
the so what are we doing we from the s

00:21:25,500 --> 00:21:32,700
exp we grab from from our we create

00:21:28,680 --> 00:21:36,300
numeric vectors objects from from our

00:21:32,700 --> 00:21:39,180
CPP and then we can start using them

00:21:36,300 --> 00:21:40,920
using them so we can grab the size of

00:21:39,180 --> 00:21:43,170
the object with number of elements in

00:21:40,920 --> 00:21:46,830
the vector create a new vector of that

00:21:43,170 --> 00:21:52,100
size and then and then it's just regular

00:21:46,830 --> 00:21:55,260
sort of c++ business I mean we grab the

00:21:52,100 --> 00:21:58,530
each element from from each vector and

00:21:55,260 --> 00:22:00,090
then do some really simple computation

00:21:58,530 --> 00:22:03,360
there as you can see there's no more

00:22:00,090 --> 00:22:08,630
macros there's no more protect and

00:22:03,360 --> 00:22:11,070
unprotect the DRC PPI API takes care of

00:22:08,630 --> 00:22:14,010
making sure that your object is

00:22:11,070 --> 00:22:18,240
protected when when you create it and

00:22:14,010 --> 00:22:20,670
then just relieved to the garbage

00:22:18,240 --> 00:22:25,260
collector when it's no more needed so

00:22:20,670 --> 00:22:31,710
for this we use we use the regular sort

00:22:25,260 --> 00:22:36,020
of C++ life cycle and and it makes code

00:22:31,710 --> 00:22:39,270
more easy to write and debug and and

00:22:36,020 --> 00:22:42,899
while it makes a bit fun to use as well

00:22:39,270 --> 00:22:44,690
so some some of the examples there so

00:22:42,899 --> 00:22:47,399
creating a list so imagine you have a

00:22:44,690 --> 00:22:52,590
STD vector from from some other library

00:22:47,399 --> 00:22:56,279
you get and you want to return the list

00:22:52,590 --> 00:22:59,669
you also list that will contain the

00:22:56,279 --> 00:23:04,110
first item will be a numeric vector of

00:22:59,669 --> 00:23:08,419
two objects so a numeric vector create

00:23:04,110 --> 00:23:14,190
one two and then the other one is is

00:23:08,419 --> 00:23:16,799
integer vector with 1 one element 3 and

00:23:14,190 --> 00:23:21,690
then string and then and then the vector

00:23:16,799 --> 00:23:23,580
and all that makes it really easy to to

00:23:21,690 --> 00:23:27,419
create data structure that you can just

00:23:23,580 --> 00:23:29,399
ship back to the outside with a really

00:23:27,419 --> 00:23:32,730
nice syntax there and then you can

00:23:29,399 --> 00:23:37,020
assign a class to it if whether you want

00:23:32,730 --> 00:23:39,840
to use a s3 object and then return the

00:23:37,020 --> 00:23:43,320
object I mean if you wanted to write the

00:23:39,840 --> 00:23:46,320
same code with the our classic sort of C

00:23:43,320 --> 00:23:48,779
API you you you would have to use a much

00:23:46,320 --> 00:23:52,950
smaller font to be able to show this on

00:23:48,779 --> 00:23:56,100
the on the slides some of the examples

00:23:52,950 --> 00:23:57,570
this isn't an example that came fairly

00:23:56,100 --> 00:24:00,029
recently on the mailing list

00:23:57,570 --> 00:24:04,679
I was actually came on the our help

00:24:00,029 --> 00:24:07,679
mailing list but some someone picked it

00:24:04,679 --> 00:24:10,200
up well Doug Bates picked it up and send

00:24:07,679 --> 00:24:12,090
it to us on the our CPP mailing list and

00:24:10,200 --> 00:24:15,960
said well can we do something about this

00:24:12,090 --> 00:24:21,000
to make it to make it faster on the our

00:24:15,960 --> 00:24:24,659
CPP slide so we oughtta go with that so

00:24:21,000 --> 00:24:29,059
the idea is that we want to go from the

00:24:24,659 --> 00:24:32,029
first matrix to the second one which

00:24:29,059 --> 00:24:36,090
well for people familiar with applying

00:24:32,029 --> 00:24:38,760
comes and did this so that the second

00:24:36,090 --> 00:24:40,919
column is the sum of the second column

00:24:38,760 --> 00:24:42,750
of the output is the sum of the first

00:24:40,919 --> 00:24:44,679
and second column of the input and the

00:24:42,750 --> 00:24:49,570
third one is the sum of the

00:24:44,679 --> 00:24:53,980
first second and third column grab so

00:24:49,570 --> 00:24:58,470
you get the picture so in our if you

00:24:53,980 --> 00:25:01,840
want to write this in our you go either

00:24:58,470 --> 00:25:04,869
using apply or you can do it directly

00:25:01,840 --> 00:25:07,869
using a for loop turns out that the for

00:25:04,869 --> 00:25:11,169
loop is quite it's quite an efficient

00:25:07,869 --> 00:25:13,169
way to do it on this example as opposed

00:25:11,169 --> 00:25:19,230
to what I initially thought it would be

00:25:13,169 --> 00:25:22,299
but can we do better using using C++

00:25:19,230 --> 00:25:25,299
that's that's the function we we ended

00:25:22,299 --> 00:25:29,049
up writing so we grab we grab the

00:25:25,299 --> 00:25:31,749
objects as a numeric matrix as Doug

00:25:29,049 --> 00:25:35,019
pointed out before when we create a

00:25:31,749 --> 00:25:38,110
matrix if it's not a matrix on the

00:25:35,019 --> 00:25:42,610
outside then we'll this will not fly

00:25:38,110 --> 00:25:46,029
this will throw an exception and let let

00:25:42,610 --> 00:25:48,279
us go back to the outside but then here

00:25:46,029 --> 00:25:50,320
we know it's a matrix and then we grab

00:25:48,279 --> 00:25:53,230
them off row number of columns of the

00:25:50,320 --> 00:25:59,190
matrix we cloned this matrix to create

00:25:53,230 --> 00:25:59,190
the result and then we can then just

00:25:59,220 --> 00:26:07,149
scan the matrix so the the current

00:26:02,590 --> 00:26:11,139
column is then the sum of the previous

00:26:07,149 --> 00:26:12,399
column and the current column of the

00:26:11,139 --> 00:26:16,629
input that it makes really

00:26:12,399 --> 00:26:24,429
straightforward sort of a yeah

00:26:16,629 --> 00:26:26,879
vectorized code in in c++ so does it

00:26:24,429 --> 00:26:29,320
actually make it better in terms of

00:26:26,879 --> 00:26:32,440
benchmarking it turns out that it does

00:26:29,320 --> 00:26:35,110
well when we started working on these

00:26:32,440 --> 00:26:37,419
slides a few days ago that the version I

00:26:35,110 --> 00:26:41,379
add was not better than than the R

00:26:37,419 --> 00:26:44,440
version and so we've been able to to do

00:26:41,379 --> 00:26:47,980
some work there on optimizing things but

00:26:44,440 --> 00:26:50,980
yes the the in that example the C++

00:26:47,980 --> 00:26:53,169
version turns out to be faster not by a

00:26:50,980 --> 00:26:55,830
big margin but we have other example

00:26:53,169 --> 00:26:58,620
where the margin is quite more

00:26:55,830 --> 00:27:06,519
impressive

00:26:58,620 --> 00:27:09,429
stl is a fairly used library in the c++

00:27:06,519 --> 00:27:18,299
world all of our data structures you

00:27:09,429 --> 00:27:18,299
know vectors list all expose STL sort of

00:27:19,740 --> 00:27:28,840
interface so we will have begin and end

00:27:23,500 --> 00:27:30,970
to to be able to scan a list and we've

00:27:28,840 --> 00:27:38,799
used this in this in this example to

00:27:30,970 --> 00:27:40,990
implement a a C++ equivalent of the L

00:27:38,799 --> 00:27:43,120
apply function in R we have actually

00:27:40,990 --> 00:27:46,149
another one that that's better than this

00:27:43,120 --> 00:27:48,909
now but this came fairly early on the

00:27:46,149 --> 00:27:52,990
project so we grabbed a list from our we

00:27:48,909 --> 00:27:55,570
grabbed a function we create a new list

00:27:52,990 --> 00:27:57,820
of the same size and then we just scan

00:27:55,570 --> 00:28:07,590
the input with the our function using

00:27:57,820 --> 00:28:07,590
your STD transform really easy and

00:28:09,350 --> 00:28:22,200
yeah it's sort of self-explanatory she

00:28:17,760 --> 00:28:23,400
do this this is from something that I've

00:28:22,200 --> 00:28:26,010
worked on the last couple of days or

00:28:23,400 --> 00:28:28,440
weeks I I got interested in taking an

00:28:26,010 --> 00:28:31,020
old actually implemented in C optimize

00:28:28,440 --> 00:28:33,240
it not old current package but plain C

00:28:31,020 --> 00:28:35,640
optimization function where the user can

00:28:33,240 --> 00:28:37,920
send in a function and this is what what

00:28:35,640 --> 00:28:39,810
looks like if you were to evaluate the

00:28:37,920 --> 00:28:43,470
vector of parameters par underscore

00:28:39,810 --> 00:28:46,530
given a function that map's from a

00:28:43,470 --> 00:28:48,450
vector to a to a real to do vector

00:28:46,530 --> 00:28:51,090
valued numeric to a single numeric in an

00:28:48,450 --> 00:28:52,980
environment row with our CPP that's

00:28:51,090 --> 00:28:54,510
pretty straightforward you just decide

00:28:52,980 --> 00:28:57,300
the numeric vector you assign a function

00:28:54,510 --> 00:29:00,890
you assign environment you then create a

00:28:57,300 --> 00:29:03,080
language object that's the function that

00:29:00,890 --> 00:29:05,430
combines the functions of parameters and

00:29:03,080 --> 00:29:09,480
evaluate that in the given environment

00:29:05,430 --> 00:29:11,700
and return the scalar but as I found

00:29:09,480 --> 00:29:13,620
this particular one if you do that in

00:29:11,700 --> 00:29:15,870
the context of function evaluation make

00:29:13,620 --> 00:29:17,610
it call 10,000 times there's a little

00:29:15,870 --> 00:29:19,770
bit of overhead in this and you know

00:29:17,610 --> 00:29:21,780
these are just good exercises for us to

00:29:19,770 --> 00:29:24,780
find where bottlenecks it just as we did

00:29:21,780 --> 00:29:27,720
with the the preceding example on the

00:29:24,780 --> 00:29:29,430
cumulative sums of the columns of the

00:29:27,720 --> 00:29:32,070
matrix where at first we weren't

00:29:29,430 --> 00:29:33,660
actually faster than an already

00:29:32,070 --> 00:29:35,880
vectorized version and a so this this

00:29:33,660 --> 00:29:38,370
isn't as good but you know if that's the

00:29:35,880 --> 00:29:39,900
case or shucks I mean we will get there

00:29:38,370 --> 00:29:41,580
so I settled essentially for something

00:29:39,900 --> 00:29:43,670
like that even though I was working with

00:29:41,580 --> 00:29:49,800
aa CPP in the rest of it you can also

00:29:43,670 --> 00:29:52,470
just use the the standard are functions

00:29:49,800 --> 00:29:53,820
so there's there's length to which helps

00:29:52,470 --> 00:29:57,240
you a little with the Lisp headaches

00:29:53,820 --> 00:29:58,590
Romain was kindly referring to unone as

00:29:57,240 --> 00:30:01,110
the earlier slides the things you have

00:29:58,590 --> 00:30:03,600
to do for for function and likewise eval

00:30:01,110 --> 00:30:05,160
both of these here prefix with the RF

00:30:03,600 --> 00:30:08,010
underscore can be evaluated that's

00:30:05,160 --> 00:30:10,110
that's the same thing which then is when

00:30:08,010 --> 00:30:11,730
we're using our CPP the same as the in

00:30:10,110 --> 00:30:14,730
speed and performance as a si version

00:30:11,730 --> 00:30:16,800
because it really is the same other

00:30:14,730 --> 00:30:18,210
things that we're having so this is this

00:30:16,800 --> 00:30:20,610
is a slide that details the

00:30:18,210 --> 00:30:22,800
aforementioned s conversion function s

00:30:20,610 --> 00:30:24,060
is basically what you do at the input

00:30:22,800 --> 00:30:27,300
to your C function when you come from

00:30:24,060 --> 00:30:31,710
our it's templated so the templates type

00:30:27,300 --> 00:30:33,990
T it converts to an S exp and it's

00:30:31,710 --> 00:30:35,760
pretty feature-rich there's just about

00:30:33,990 --> 00:30:39,840
anything you may encounter now sort of

00:30:35,760 --> 00:30:42,630
primitive C++ types recall again this is

00:30:39,840 --> 00:30:45,240
for passage from C++ from our to your

00:30:42,630 --> 00:30:47,460
C++ context so you're mapping into an in

00:30:45,240 --> 00:30:50,400
double blue long in any of the standard

00:30:47,460 --> 00:30:52,830
C++ types anything that already can be

00:30:50,400 --> 00:30:56,120
constructed with an X anything that

00:30:52,830 --> 00:30:59,610
further specializes this template or

00:30:56,120 --> 00:31:01,020
containers from the STL we speak a

00:30:59,610 --> 00:31:03,990
little bit more about that in the

00:31:01,020 --> 00:31:06,870
extending vignette because it has to do

00:31:03,990 --> 00:31:08,850
with some of the wrapping the converse

00:31:06,870 --> 00:31:12,960
is then wrap which goes the other way

00:31:08,850 --> 00:31:14,730
around in goes the template type T out

00:31:12,960 --> 00:31:19,550
comes the s expression that's what you

00:31:14,730 --> 00:31:23,280
do at the end it can again take any

00:31:19,550 --> 00:31:25,830
atomistic C++ type in double bool any s

00:31:23,280 --> 00:31:28,050
exp anything that further specializes

00:31:25,830 --> 00:31:32,900
the template anything that has iterators

00:31:28,050 --> 00:31:35,910
and begin an end as well as STL objects

00:31:32,900 --> 00:31:38,850
that you use STL containers around the

00:31:35,910 --> 00:31:40,350
wrapper ball type and there's plenty of

00:31:38,850 --> 00:31:43,050
examples now in the documentation in

00:31:40,350 --> 00:31:45,240
other places here's how you would use it

00:31:43,050 --> 00:31:47,190
for example suppose that you had a

00:31:45,240 --> 00:31:51,470
vector of doubles which we're just

00:31:47,190 --> 00:31:51,470
creating a type def shorthand here

00:31:52,050 --> 00:31:57,990
so if then a vector Z comes in you can

00:31:56,100 --> 00:32:00,750
assign it to vak just as before the

00:31:57,990 --> 00:32:04,470
depleting example in doubles you can

00:32:00,750 --> 00:32:08,250
also wrap them on the way back and you

00:32:04,470 --> 00:32:14,820
can create relatively complex maps of

00:32:08,250 --> 00:32:20,280
string or vector but by putting all of

00:32:14,820 --> 00:32:27,590
those together so there's yeah two two

00:32:20,280 --> 00:32:29,670
vectors and a scalar likewise we have

00:32:27,590 --> 00:32:32,790
implicit conversion that works for

00:32:29,670 --> 00:32:35,399
environments lists functions you can

00:32:32,790 --> 00:32:38,519
look up my name from environment and

00:32:35,399 --> 00:32:41,779
lists the way you would do it in in

00:32:38,519 --> 00:32:49,320
scripting languages with you know

00:32:41,779 --> 00:32:52,109
dictionary or hashes some of the

00:32:49,320 --> 00:32:54,869
expressions get by with implicit calls

00:32:52,109 --> 00:32:56,940
to wrap that sort of not really clearly

00:32:54,869 --> 00:32:58,409
demarked in the in the documentation I

00:32:56,940 --> 00:33:00,119
find myself sort of that way sort of

00:32:58,409 --> 00:33:01,859
trying sometimes and then you get one of

00:33:00,119 --> 00:33:02,789
those fairly verbose compiler messages

00:33:01,859 --> 00:33:07,080
back and then you have to put an

00:33:02,789 --> 00:33:08,729
explicit wrap there so I'm not really

00:33:07,080 --> 00:33:10,289
sure how I would describe to how to use

00:33:08,729 --> 00:33:14,759
it I mean if in doubt I I most often

00:33:10,289 --> 00:33:17,009
just actually put a wrap around with

00:33:14,759 --> 00:33:20,099
that we have a few slides about the

00:33:17,009 --> 00:33:22,049
inline package that I started to refer

00:33:20,099 --> 00:33:24,059
to a lot in a couple of tours I gave one

00:33:22,049 --> 00:33:26,009
on on our and high-performance computing

00:33:24,059 --> 00:33:27,929
because it was a super useful package

00:33:26,009 --> 00:33:29,159
and it later occurred to me I was

00:33:27,929 --> 00:33:31,080
talking about inline and then I was

00:33:29,159 --> 00:33:32,759
talking about a CPP and I did that a

00:33:31,080 --> 00:33:34,469
couple of times and then I realized wait

00:33:32,759 --> 00:33:36,239
wait wait I should stick those together

00:33:34,469 --> 00:33:38,190
so I did a patch to it and then later

00:33:36,239 --> 00:33:40,200
remanded another patch to make it making

00:33:38,190 --> 00:33:44,609
it better still this describes the way

00:33:40,200 --> 00:33:46,679
it's now in the current version after

00:33:44,609 --> 00:33:48,899
after after or two sets of changes so

00:33:46,679 --> 00:33:50,909
now you have a function CSX function

00:33:48,899 --> 00:33:53,460
that extends the original c function by

00:33:50,909 --> 00:33:55,049
oleg what this does is it picks up an

00:33:53,460 --> 00:33:57,179
idea that i had first seen i think in

00:33:55,049 --> 00:33:58,830
the perl world essentially in your

00:33:57,179 --> 00:34:00,960
scripting language you have what is a

00:33:58,830 --> 00:34:03,029
character string it just so happens that

00:34:00,960 --> 00:34:05,369
inside the character string is a valid

00:34:03,029 --> 00:34:07,799
program in the language you want to use

00:34:05,369 --> 00:34:11,760
this package then does the housekeeping

00:34:07,799 --> 00:34:13,349
it sets this program body as well as any

00:34:11,760 --> 00:34:15,179
other management it needs around it

00:34:13,349 --> 00:34:17,399
additional headers make files

00:34:15,179 --> 00:34:19,559
environment variables puts it down on

00:34:17,399 --> 00:34:21,419
your operating system calls the compiler

00:34:19,559 --> 00:34:23,520
for you called the linker and loads it

00:34:21,419 --> 00:34:25,529
it does is really really cleverly

00:34:23,520 --> 00:34:27,000
because once you know your a system in

00:34:25,529 --> 00:34:29,039
environment there things that you can

00:34:27,000 --> 00:34:30,929
take advantage of every our session is

00:34:29,039 --> 00:34:33,149
guaranteed to have a unique temp

00:34:30,929 --> 00:34:35,399
directory that will get cleaned at the

00:34:33,149 --> 00:34:37,079
end so it's really natural with that to

00:34:35,399 --> 00:34:39,000
write your temporary file in the temp

00:34:37,079 --> 00:34:40,799
directory put your object file in there

00:34:39,000 --> 00:34:42,659
load from that because whatever else

00:34:40,799 --> 00:34:47,549
happens when this our session terminates

00:34:42,659 --> 00:34:49,580
this will all be picked up so it's it's

00:34:47,549 --> 00:34:51,650
literally as simple as it is there

00:34:49,580 --> 00:34:55,160
so you can you know sit in your our

00:34:51,650 --> 00:34:56,810
she'll install in line for the second

00:34:55,160 --> 00:34:58,220
example you also need ask BP because we

00:34:56,810 --> 00:34:59,600
use it but I get to that in a second for

00:34:58,220 --> 00:35:01,130
the first one you don't need anything

00:34:59,600 --> 00:35:02,780
else but having a compiler on your

00:35:01,130 --> 00:35:04,670
system so you know that differentiates a

00:35:02,780 --> 00:35:06,200
little bit with say the Windows users

00:35:04,670 --> 00:35:08,270
don't always have the tool trained so

00:35:06,200 --> 00:35:10,370
what happens is there's a bunch of

00:35:08,270 --> 00:35:12,290
arguments we will see a few you don't

00:35:10,370 --> 00:35:14,570
need that many the first one always is

00:35:12,290 --> 00:35:16,460
signature so you want to dynamically

00:35:14,570 --> 00:35:19,280
load a function so you have to tell it

00:35:16,460 --> 00:35:21,890
what goes in here we're saying I want to

00:35:19,280 --> 00:35:23,780
have something that's a variable named X

00:35:21,890 --> 00:35:26,660
in my program and it'll be an int and

00:35:23,780 --> 00:35:30,410
there will be variable Y that'll be a

00:35:26,660 --> 00:35:31,850
numeric so int and floats in C++ and

00:35:30,410 --> 00:35:33,440
what we're doing here I mean it's of

00:35:31,850 --> 00:35:36,200
course it's a trivial example we're just

00:35:33,440 --> 00:35:38,780
you know returning a product so that I

00:35:36,200 --> 00:35:40,580
can have it in a simple simple line that

00:35:38,780 --> 00:35:42,740
is the second argument to see execs

00:35:40,580 --> 00:35:46,450
function it goes from the apostrophe to

00:35:42,740 --> 00:35:49,070
the other apostrophe it's a character

00:35:46,450 --> 00:35:50,870
vector that gets passed down and if you

00:35:49,070 --> 00:35:52,940
were to turn an additional optional

00:35:50,870 --> 00:35:54,830
argument verbose on with the value of

00:35:52,940 --> 00:35:56,360
two you would see the temporary source

00:35:54,830 --> 00:35:58,790
code that's being put out there it's

00:35:56,360 --> 00:36:00,800
compiled it's being loaded and you get

00:35:58,790 --> 00:36:02,570
it back and for simple programs like

00:36:00,800 --> 00:36:04,250
this it just takes a second or two

00:36:02,570 --> 00:36:07,040
because that's the time to write this

00:36:04,250 --> 00:36:09,020
mini function compiling loaded and then

00:36:07,040 --> 00:36:10,790
you have a new function FX because the

00:36:09,020 --> 00:36:12,890
result of C X X function gets assigned

00:36:10,790 --> 00:36:15,290
to FX and you can call FX with an

00:36:12,890 --> 00:36:17,480
argument to which you know with one of

00:36:15,290 --> 00:36:19,790
the newer features we force to be an int

00:36:17,480 --> 00:36:23,600
rather than cast up to numeric and the

00:36:19,790 --> 00:36:26,660
numeric 5 you can do the exact same

00:36:23,600 --> 00:36:28,130
thing now with something very clever

00:36:26,660 --> 00:36:30,400
that romaine came up with with with

00:36:28,130 --> 00:36:35,750
plugins that certain packages can then

00:36:30,400 --> 00:36:37,370
make use of and talk back so our CPP has

00:36:35,750 --> 00:36:38,990
a bit more in terms of requirements if

00:36:37,370 --> 00:36:40,190
you have looked at it because our CPP if

00:36:38,990 --> 00:36:41,930
you want to build against that it has

00:36:40,190 --> 00:36:43,610
headers so now we have to tell the

00:36:41,930 --> 00:36:45,290
compiler where to find these headers so

00:36:43,610 --> 00:36:47,330
that it can happen for the original

00:36:45,290 --> 00:36:48,950
program all it did was using our headers

00:36:47,330 --> 00:36:50,570
and you can inquire are about where

00:36:48,950 --> 00:36:52,520
those sit that's always in the file tree

00:36:50,570 --> 00:36:54,680
now we have to do the same for us VP and

00:36:52,520 --> 00:36:56,420
we have to provide a library too so

00:36:54,680 --> 00:36:58,310
that's basically what plug-in does and

00:36:56,420 --> 00:37:00,380
what you then get in the simple example

00:36:58,310 --> 00:37:02,380
min long we excuse me for stepping back

00:37:00,380 --> 00:37:05,590
from the Mike for a second

00:37:02,380 --> 00:37:11,160
instead of using plain old school Metro

00:37:05,590 --> 00:37:13,150
API in CNI you now get a rap as

00:37:11,160 --> 00:37:14,560
templated functions that we just talked

00:37:13,150 --> 00:37:18,430
about and that does the same thing now

00:37:14,560 --> 00:37:20,350
with our CPP and you know it was there

00:37:18,430 --> 00:37:23,080
before us we've just found it extremely

00:37:20,350 --> 00:37:26,230
useful we use it extensively in the

00:37:23,080 --> 00:37:28,510
package over 770 unit tests of last

00:37:26,230 --> 00:37:31,810
count and many of the collaborators that

00:37:28,510 --> 00:37:34,420
we've now found since we went full force

00:37:31,810 --> 00:37:36,070
onto this including John do most of the

00:37:34,420 --> 00:37:39,100
prototyping this way it's it's really

00:37:36,070 --> 00:37:40,900
quite nice but even if you don't want to

00:37:39,100 --> 00:37:44,950
use our stuff it's really neat for C C++

00:37:40,900 --> 00:37:47,680
and Fortran and sometimes present some

00:37:44,950 --> 00:37:51,430
up so I have a friend in New York who's

00:37:47,680 --> 00:37:54,340
also in finance who puts a lot of trial

00:37:51,430 --> 00:37:55,570
and testing packages onto github and one

00:37:54,340 --> 00:37:57,460
of the things you've recently played

00:37:55,570 --> 00:37:59,320
with was that he wanted to replace users

00:37:57,460 --> 00:38:01,120
of bugs with something that's very

00:37:59,320 --> 00:38:03,460
popular in the Pisan world called PI MC

00:38:01,120 --> 00:38:05,470
so he was doing a lot of Montecarlo a

00:38:03,460 --> 00:38:06,910
simulation with pi MC and then he kind

00:38:05,470 --> 00:38:08,590
of figured well wait a second can i do

00:38:06,910 --> 00:38:10,330
that with your stuff what about

00:38:08,590 --> 00:38:12,250
templates and be sure but yes of course

00:38:10,330 --> 00:38:15,160
we can and I and I quickly cooked up the

00:38:12,250 --> 00:38:17,110
same a simple example where a template

00:38:15,160 --> 00:38:18,310
tape is type is defined and used and

00:38:17,110 --> 00:38:21,000
we're basically doing the same thing

00:38:18,310 --> 00:38:24,250
here and it's because it's a full

00:38:21,000 --> 00:38:26,610
program I had to cut it short but if I

00:38:24,250 --> 00:38:31,690
go back a slide whoopsie

00:38:26,610 --> 00:38:35,530
this the body argument this is signature

00:38:31,690 --> 00:38:38,080
equal then body out an optional argument

00:38:35,530 --> 00:38:41,320
is Inc four includes which we're using

00:38:38,080 --> 00:38:44,650
here so I have valid C++ code that just

00:38:41,320 --> 00:38:46,660
you know goes to some other headers he's

00:38:44,650 --> 00:38:49,000
on a linux box so those are being found

00:38:46,660 --> 00:38:51,520
a module we'll talk about later cpp bugs

00:38:49,000 --> 00:38:54,070
is his program on on github

00:38:51,520 --> 00:38:55,210
he really very much like booth we use

00:38:54,070 --> 00:38:59,950
the boost random number generators

00:38:55,210 --> 00:39:03,250
rather than ours or ours or or Matias

00:38:59,950 --> 00:39:05,680
even and you know sets up his model and

00:39:03,250 --> 00:39:07,570
then go on and that's all he had to do I

00:39:05,680 --> 00:39:09,400
haven't shown that the core here but

00:39:07,570 --> 00:39:11,440
it's public he posted it to us if you

00:39:09,400 --> 00:39:15,160
need available while ago and with really

00:39:11,440 --> 00:39:16,030
simple example here's something that

00:39:15,160 --> 00:39:18,310
then render

00:39:16,030 --> 00:39:21,850
around pi MC and n bugs because it's

00:39:18,310 --> 00:39:23,620
just templated c++ what i should add is

00:39:21,850 --> 00:39:25,660
that he's a big fan of doing everything

00:39:23,620 --> 00:39:28,360
templated and having no library so for

00:39:25,660 --> 00:39:32,140
him just to also declare the include

00:39:28,360 --> 00:39:35,440
files was what was critical so it really

00:39:32,140 --> 00:39:37,780
works as a framework with that we are

00:39:35,440 --> 00:39:40,540
now sort of closing in line and we got a

00:39:37,780 --> 00:39:41,650
lot of the preliminaries out and no man

00:39:40,540 --> 00:39:42,970
will take it now and talk about

00:39:41,650 --> 00:39:51,330
something we added in the summer called

00:39:42,970 --> 00:39:58,000
sugar right so sugar comes from from

00:39:51,330 --> 00:40:01,720
from desires we so we spend a lot of

00:39:58,000 --> 00:40:03,820
time with c++ and and we don't liked the

00:40:01,720 --> 00:40:09,820
way we program in c++ and some of the

00:40:03,820 --> 00:40:12,550
benefits but it turns out eventually

00:40:09,820 --> 00:40:15,490
that we miss a few things from from the

00:40:12,550 --> 00:40:18,430
our language and the our syntax in

00:40:15,490 --> 00:40:21,700
general so sugar is a is an experiment

00:40:18,430 --> 00:40:24,610
to bring some of the our syntax back

00:40:21,700 --> 00:40:31,960
into c++ so that we can sort of up both

00:40:24,610 --> 00:40:34,360
of best of both worlds so how did it all

00:40:31,960 --> 00:40:37,420
started it started from a few questions

00:40:34,360 --> 00:40:41,530
on arm and our mailing list about how to

00:40:37,420 --> 00:40:44,380
do certain things and so this this

00:40:41,530 --> 00:40:46,450
example there is a is again the same

00:40:44,380 --> 00:40:48,100
example i've shown before with with a

00:40:46,450 --> 00:40:51,130
bit more with a bit more care with

00:40:48,100 --> 00:40:55,270
missing values so what I essentially

00:40:51,130 --> 00:40:58,750
want to scan a numeric vector and and do

00:40:55,270 --> 00:41:01,230
something with it it it's all nice I

00:40:58,750 --> 00:41:04,720
mean it's it's really sort of pedestrian

00:41:01,230 --> 00:41:07,450
C++ coding exercises there's nothing

00:41:04,720 --> 00:41:10,420
nothing wrong about this but we sort of

00:41:07,450 --> 00:41:13,960
missed the our syntax they are way to do

00:41:10,420 --> 00:41:16,890
it the if we want to express that kind

00:41:13,960 --> 00:41:20,920
of code in our you would just do if else

00:41:16,890 --> 00:41:24,700
explore lower than Y then x times X or

00:41:20,920 --> 00:41:29,020
minus y times y obviously this is really

00:41:24,700 --> 00:41:29,740
silly example but anyway so what we do

00:41:29,020 --> 00:41:33,400
with sugar

00:41:29,740 --> 00:41:35,710
we bring F else back into C++ so that

00:41:33,400 --> 00:41:38,910
the function you-you-you write is

00:41:35,710 --> 00:41:42,490
essentially the same as the one in our

00:41:38,910 --> 00:41:47,020
so we grab numeric vectors so that we

00:41:42,490 --> 00:41:49,330
have object of the appropriate class and

00:41:47,020 --> 00:41:53,380
then the expression is exactly the same

00:41:49,330 --> 00:41:55,330
as in the our expression and and we we

00:41:53,380 --> 00:41:59,460
have a lot of feedback and people really

00:41:55,330 --> 00:42:03,339
enjoy using this some other example

00:41:59,460 --> 00:42:06,070
using our for so many years people love

00:42:03,339 --> 00:42:08,920
to use L apply or I supply or things

00:42:06,070 --> 00:42:12,940
like this and now we can use them in C++

00:42:08,920 --> 00:42:15,460
so assume you have a really complicated

00:42:12,940 --> 00:42:19,930
function there called square that takes

00:42:15,460 --> 00:42:22,900
a double and squares it many years of a

00:42:19,930 --> 00:42:27,280
you know engineering in C++ to come up

00:42:22,900 --> 00:42:29,800
with this one you you then can s apply

00:42:27,280 --> 00:42:32,109
this function directly in C++ so you

00:42:29,800 --> 00:42:36,160
grab the numeric vector and then you say

00:42:32,109 --> 00:42:40,960
s apply X square and then it will do it

00:42:36,160 --> 00:42:43,089
for you and some of the magic we've put

00:42:40,960 --> 00:42:47,320
there is that if the function was

00:42:43,089 --> 00:42:49,210
returning I don't know some something

00:42:47,320 --> 00:42:53,320
something else for example a numeric

00:42:49,210 --> 00:42:54,970
vector instead of you would get exactly

00:42:53,320 --> 00:42:57,400
the same behavior as you would get in

00:42:54,970 --> 00:42:59,710
our that so that it would create a list

00:42:57,400 --> 00:43:03,089
of numeric vector for you and all of

00:42:59,710 --> 00:43:06,010
that happening at compile time thanks to

00:43:03,089 --> 00:43:09,339
template metaprogramming and things like

00:43:06,010 --> 00:43:13,510
this so what's in the sugar box we we

00:43:09,339 --> 00:43:15,190
have logical operators is is a vector

00:43:13,510 --> 00:43:19,800
lower than another vector greater

00:43:15,190 --> 00:43:22,690
different equals we obviously have

00:43:19,800 --> 00:43:24,849
arithmetic and we have many many

00:43:22,690 --> 00:43:27,880
functions that we are borrowing from

00:43:24,849 --> 00:43:31,030
from our we obviously can't bring

00:43:27,880 --> 00:43:33,820
everything but we quite confident that

00:43:31,030 --> 00:43:36,490
we bring in a sufficient subset to be

00:43:33,820 --> 00:43:39,250
able to do some things and people are

00:43:36,490 --> 00:43:43,619
quite getting happy with this so you

00:43:39,250 --> 00:43:43,619
know Rev or

00:43:43,700 --> 00:43:51,590
power men l apply air supply this

00:43:48,210 --> 00:43:57,210
function really allow you to write

00:43:51,590 --> 00:44:04,230
concise code in C++ functions to operate

00:43:57,210 --> 00:44:07,550
on matrices so out cold row the lower

00:44:04,230 --> 00:44:11,370
triangle of a matrix and so on and

00:44:07,550 --> 00:44:15,540
lately with a tremendous help from Doug

00:44:11,370 --> 00:44:19,920
Bates we've added all of the statistical

00:44:15,540 --> 00:44:22,020
functions you know our norm the norm Q

00:44:19,920 --> 00:44:25,710
nom P nom and so on for every

00:44:22,020 --> 00:44:28,230
distribution that's in our but these

00:44:25,710 --> 00:44:31,620
function on our C++ functions in that

00:44:28,230 --> 00:44:35,010
that allows us to to embed a few

00:44:31,620 --> 00:44:38,070
optimizations also in them you'll find

00:44:35,010 --> 00:44:42,270
much more information on the AR CPP

00:44:38,070 --> 00:44:48,030
sugar vignette because we can't cover

00:44:42,270 --> 00:44:53,850
everything everything in in one

00:44:48,030 --> 00:44:56,760
presentation and I wanted to close the

00:44:53,850 --> 00:45:00,750
the sugar part with with a few

00:44:56,760 --> 00:45:05,790
benchmarks of of this it's all very nice

00:45:00,750 --> 00:45:07,440
to have a nice syntax but if if we have

00:45:05,790 --> 00:45:08,790
to pay the price some somewhere else

00:45:07,440 --> 00:45:13,170
then it's not interesting

00:45:08,790 --> 00:45:16,380
so what we wanted to to see here is that

00:45:13,170 --> 00:45:21,090
does it actually work is it faster than

00:45:16,380 --> 00:45:24,000
the R version and so on so we tested

00:45:21,090 --> 00:45:25,920
this with the with a few expressions and

00:45:24,000 --> 00:45:33,360
well we've introduced a bit of bias

00:45:25,920 --> 00:45:37,380
there so the first expression you see

00:45:33,360 --> 00:45:41,310
quite quite enormous benefit there well

00:45:37,380 --> 00:45:43,440
the where the sugar version is about ten

00:45:41,310 --> 00:45:47,550
thousand times faster than the our

00:45:43,440 --> 00:45:51,470
version and I can explain you why in a

00:45:47,550 --> 00:45:55,710
second then if else which works about

00:45:51,470 --> 00:45:56,700
fifteen to twenty times faster depending

00:45:55,710 --> 00:45:59,250
on

00:45:56,700 --> 00:46:02,810
on the information we embed with one

00:45:59,250 --> 00:46:09,000
version we have we are allowed we we can

00:46:02,810 --> 00:46:11,579
embed in in the India expression the

00:46:09,000 --> 00:46:13,950
fact that the vector does not does does

00:46:11,579 --> 00:46:16,770
not contain any missing value and this

00:46:13,950 --> 00:46:23,160
allows us to calculate the the project

00:46:16,770 --> 00:46:25,920
or any other expression faster and and

00:46:23,160 --> 00:46:28,619
then as supply as you can see there

00:46:25,920 --> 00:46:32,369
without the overhead of the our

00:46:28,619 --> 00:46:35,280
interpreter can get much faster now why

00:46:32,369 --> 00:46:38,310
why do we get such huge benefits on the

00:46:35,280 --> 00:46:41,570
on the first one that what essentially

00:46:38,310 --> 00:46:46,530
happens is that the evaluation goes lazy

00:46:41,570 --> 00:46:50,250
so in in our if we had to evaluate any x

00:46:46,530 --> 00:46:51,510
times y lower than zero what what would

00:46:50,250 --> 00:46:55,589
have to happen is that we would have to

00:46:51,510 --> 00:47:01,290
calculate x times y allocate new data

00:46:55,589 --> 00:47:03,480
for this wall vector and then we'll have

00:47:01,290 --> 00:47:06,690
to allocate another logical vector to

00:47:03,480 --> 00:47:10,410
host is x times y lower than zero and

00:47:06,690 --> 00:47:13,680
then we scan this in C++ we do it

00:47:10,410 --> 00:47:19,530
totally differently with compile time we

00:47:13,680 --> 00:47:23,480
allowed to compare the first x times the

00:47:19,530 --> 00:47:25,920
first Y with zero and if this is already

00:47:23,480 --> 00:47:28,410
true then we can stop there there's

00:47:25,920 --> 00:47:30,930
nothing more to do so this is why in

00:47:28,410 --> 00:47:34,050
this example though we get so much

00:47:30,930 --> 00:47:37,829
faster because there's no extra memory

00:47:34,050 --> 00:47:39,660
allocated and and and and the first true

00:47:37,829 --> 00:47:42,599
condition this is where the bias was

00:47:39,660 --> 00:47:44,910
sort of introduced by by us is really

00:47:42,599 --> 00:47:49,500
early in the vectors so this is why we

00:47:44,910 --> 00:47:52,349
get such improvements somewhat some of

00:47:49,500 --> 00:47:54,690
the benchmarks they're in there writing

00:47:52,349 --> 00:47:58,950
our extension deser notorious so example

00:47:54,690 --> 00:48:02,099
about convolution and so in in a

00:47:58,950 --> 00:48:05,250
forthcoming well hopefully paper in the

00:48:02,099 --> 00:48:08,010
in the our journal we've we've came up

00:48:05,250 --> 00:48:10,420
with another na CPP version of the

00:48:08,010 --> 00:48:14,230
convolution and we wanted to see

00:48:10,420 --> 00:48:16,690
we could do better than the than the

00:48:14,230 --> 00:48:20,529
usual example in and it turns out that

00:48:16,690 --> 00:48:24,039
we can we can make a version that's

00:48:20,529 --> 00:48:26,200
about 1/3 faster than than the than the

00:48:24,039 --> 00:48:38,010
benchmark so we quite thrilled about

00:48:26,200 --> 00:48:40,839
this that covered a lot of our CPP

00:48:38,010 --> 00:48:44,079
there's two more extension modules that

00:48:40,839 --> 00:48:45,609
Romain will talk to towards the end and

00:48:44,079 --> 00:48:47,769
I hope we'll have enough time to do that

00:48:45,609 --> 00:48:50,349
but I want to break a little and talk a

00:48:47,769 --> 00:48:52,269
bit about our inside that was something

00:48:50,349 --> 00:48:56,019
that we also had on the on the title

00:48:52,269 --> 00:49:00,910
page so this is something completely

00:48:56,019 --> 00:49:03,039
different with Monty Python um you know

00:49:00,910 --> 00:49:04,750
if it was out about a decade and every

00:49:03,039 --> 00:49:06,339
couple of years someone came up and sort

00:49:04,750 --> 00:49:08,680
of said well we should really have

00:49:06,339 --> 00:49:10,240
something for shebang scripting because

00:49:08,680 --> 00:49:12,730
you know with our you could do our

00:49:10,240 --> 00:49:15,369
command badge for redirecting the sort

00:49:12,730 --> 00:49:17,799
of crutches it's all awful at some point

00:49:15,369 --> 00:49:20,440
maybe around our 1/6 or 1/7 there was

00:49:17,799 --> 00:49:22,180
someone from RD in Detroit at the time

00:49:20,440 --> 00:49:24,039
they still had our D I think who had a

00:49:22,180 --> 00:49:25,450
patch that did something to the engine I

00:49:24,039 --> 00:49:27,190
think Duncan temple laying also had

00:49:25,450 --> 00:49:28,809
something but sort of it never happened

00:49:27,190 --> 00:49:30,160
that they asked a guy he sent me that

00:49:28,809 --> 00:49:33,400
pitch I never really looked at it it

00:49:30,160 --> 00:49:36,490
then so happened that a friend at

00:49:33,400 --> 00:49:38,289
Vanderbilt the Jeff Horner had learned a

00:49:36,490 --> 00:49:40,269
lot about embedding are for using our

00:49:38,289 --> 00:49:44,829
Apache which is a wonderful product that

00:49:40,269 --> 00:49:46,839
he authored and I think in response to

00:49:44,829 --> 00:49:49,029
one yet another email about that with

00:49:46,839 --> 00:49:51,940
the shebang started doing something and

00:49:49,029 --> 00:49:53,319
you know by that time I learned sort of

00:49:51,940 --> 00:49:54,670
some tricks just about the ropes was

00:49:53,319 --> 00:49:56,259
config you and other things so I I

00:49:54,670 --> 00:49:56,740
helped and we started working on this

00:49:56,259 --> 00:49:59,289
together

00:49:56,740 --> 00:50:01,150
that led to littler so littler then

00:49:59,289 --> 00:50:02,950
that's the one time in my life that I

00:50:01,150 --> 00:50:04,539
was a little faster and sooner out was

00:50:02,950 --> 00:50:06,099
something that worked and Brian Ripley

00:50:04,539 --> 00:50:08,529
Brian Ripley being ultra competitive

00:50:06,099 --> 00:50:11,559
will never admit to that littler is now

00:50:08,529 --> 00:50:13,180
shadowed by our script but you know we

00:50:11,559 --> 00:50:14,859
were there it works it still has sort of

00:50:13,180 --> 00:50:17,140
some examples and some adventures to the

00:50:14,859 --> 00:50:19,390
internal so long story short little

00:50:17,140 --> 00:50:21,279
embeds are it's it's it's sort of a

00:50:19,390 --> 00:50:23,230
shebang piping front and it's really

00:50:21,279 --> 00:50:24,190
really good you guys will like it on

00:50:23,230 --> 00:50:26,319
large systems I

00:50:24,190 --> 00:50:28,810
used it a lot for some of the HPC

00:50:26,319 --> 00:50:30,339
exercises and you know doing that what

00:50:28,810 --> 00:50:32,200
it does there is it just runs through

00:50:30,339 --> 00:50:33,880
our files picks them up line by line

00:50:32,200 --> 00:50:36,970
sent them to the interpreter so then

00:50:33,880 --> 00:50:38,800
kind of figured ha that would be useful

00:50:36,970 --> 00:50:40,780
and I needed something like that for

00:50:38,800 --> 00:50:43,180
just back testing operations that I was

00:50:40,780 --> 00:50:45,520
doing at a time that I had I had data

00:50:43,180 --> 00:50:47,140
that are accumulated in C++ programs and

00:50:45,520 --> 00:50:48,609
I wanted to do all over it and what you

00:50:47,140 --> 00:50:50,349
then commonly do is that you know you

00:50:48,609 --> 00:50:52,030
cook something out that writes out a CSV

00:50:50,349 --> 00:50:54,339
file you call our you bring the results

00:50:52,030 --> 00:50:56,349
back in it all works it's all very

00:50:54,339 --> 00:50:58,060
pedestrian it's really boring you have

00:50:56,349 --> 00:51:00,369
no oral control and it doesn't perform

00:50:58,060 --> 00:51:02,319
well so I kind of figured wait what what

00:51:00,369 --> 00:51:04,480
littler does is exactly what I should do

00:51:02,319 --> 00:51:07,030
for really simple exercise in creating

00:51:04,480 --> 00:51:08,650
and class that embeds are all the

00:51:07,030 --> 00:51:11,200
functionalities there things to argue

00:51:08,650 --> 00:51:13,480
about how to embed it and then we we did

00:51:11,200 --> 00:51:15,700
that and that's so so I released that a

00:51:13,480 --> 00:51:18,220
while ago and that because it interfaces

00:51:15,700 --> 00:51:20,589
between R and C++ also got a lot better

00:51:18,220 --> 00:51:22,990
now with our CPP it's a nice little

00:51:20,589 --> 00:51:24,460
package now we're co-authors on it and

00:51:22,990 --> 00:51:26,680
there's this tremendous number of

00:51:24,460 --> 00:51:28,359
examples in the package it's pretty

00:51:26,680 --> 00:51:30,579
straightforward and sort of this is what

00:51:28,359 --> 00:51:33,099
it does you instantiate an object or

00:51:30,579 --> 00:51:35,650
inside you give it oxy and Acme that's

00:51:33,099 --> 00:51:39,550
it you now have an interpreter in your

00:51:35,650 --> 00:51:42,220
C++ program and thanks to our CPP and

00:51:39,550 --> 00:51:44,500
the explicit implicit representing

00:51:42,220 --> 00:51:46,270
things back and forth is a lot easier I

00:51:44,500 --> 00:51:48,280
had something relatively pedestrian now

00:51:46,270 --> 00:51:49,630
we have something high-end so just how

00:51:48,280 --> 00:51:51,609
we showed example earlier for the

00:51:49,630 --> 00:51:54,130
environments you can just assign you

00:51:51,609 --> 00:51:56,079
just have a key value lookup you know

00:51:54,130 --> 00:51:58,390
you have an object text in the eye

00:51:56,079 --> 00:51:59,950
interpreter that gets assigned and it's

00:51:58,390 --> 00:52:01,359
the our semantics on the other side that

00:51:59,950 --> 00:52:03,640
find the proper type to it because we

00:52:01,359 --> 00:52:06,450
sent a string to it it's you know it's a

00:52:03,640 --> 00:52:08,950
character in our behind it and then the

00:52:06,450 --> 00:52:13,480
basic hook to get everything out is

00:52:08,950 --> 00:52:15,010
passed eval or pass eval q for quiet it

00:52:13,480 --> 00:52:16,900
doesn't return anything so if I just

00:52:15,010 --> 00:52:18,849
want to say hello world well that's my

00:52:16,900 --> 00:52:20,800
three lines of hello world so that's you

00:52:18,849 --> 00:52:22,240
know the silliest hello world the two of

00:52:20,800 --> 00:52:23,770
us could come up with so it doesn't do a

00:52:22,240 --> 00:52:25,750
hell of a lot but it shows you already

00:52:23,770 --> 00:52:28,810
what it can do

00:52:25,750 --> 00:52:32,230
other examples are that you know you can

00:52:28,810 --> 00:52:34,180
assign two numbers evaluate an

00:52:32,230 --> 00:52:37,540
expression and get the result out and

00:52:34,180 --> 00:52:40,750
point it in so it goes really easily

00:52:37,540 --> 00:52:42,130
directional this is something I don't

00:52:40,750 --> 00:52:43,870
want to spend too much time on it that

00:52:42,130 --> 00:52:45,520
was sort of one of those oh my god why

00:52:43,870 --> 00:52:48,850
are they doing this way there was

00:52:45,520 --> 00:52:51,130
someone on either a develop maybe on the

00:52:48,850 --> 00:52:52,720
asset finance list that I'd share who

00:52:51,130 --> 00:52:54,280
wanted to do something that had to do

00:52:52,720 --> 00:52:56,260
with service with standard finance using

00:52:54,280 --> 00:52:58,480
one of the wonderful a metrics packages

00:52:56,260 --> 00:52:59,890
basically just calculate something to

00:52:58,480 --> 00:53:01,120
portfolio on a constraint you see it

00:52:59,890 --> 00:53:03,100
here thanks to the beauty of of

00:53:01,120 --> 00:53:05,260
highlighting in red I don't want to get

00:53:03,100 --> 00:53:07,750
into the detail but but he was you know

00:53:05,260 --> 00:53:09,910
trying basically to milk our

00:53:07,750 --> 00:53:12,940
computations from a standalone C C++

00:53:09,910 --> 00:53:14,620
program but he he had great difficulties

00:53:12,940 --> 00:53:15,700
there he and he kept emailing for weeks

00:53:14,620 --> 00:53:17,350
and then I just want evening I just

00:53:15,700 --> 00:53:20,020
cooked that up and it became you know

00:53:17,350 --> 00:53:21,730
sample sample for in our insider just

00:53:20,020 --> 00:53:24,250
the editor ten brackets just means I had

00:53:21,730 --> 00:53:25,540
to sort of shorten something to to fit

00:53:24,250 --> 00:53:28,570
it on the page but otherwise the same

00:53:25,540 --> 00:53:30,250
example and it it works if there's you

00:53:28,570 --> 00:53:34,420
know a functionality in packages you

00:53:30,250 --> 00:53:36,130
want to load you just like were you at

00:53:34,420 --> 00:53:37,840
portfolio and off you go and you use it

00:53:36,130 --> 00:53:40,180
so if you have internal or external

00:53:37,840 --> 00:53:45,790
packages they available now to your C++

00:53:40,180 --> 00:53:48,250
program last example we added its

00:53:45,790 --> 00:53:52,930
relates to the embedding suppose you

00:53:48,250 --> 00:53:55,180
have a multi you know highly performing

00:53:52,930 --> 00:53:57,160
C++ function about as powerful as a

00:53:55,180 --> 00:53:59,230
square example that we had earlier so

00:53:57,160 --> 00:54:01,630
this one takes hello and concatenates a

00:53:59,230 --> 00:54:07,270
given string to it just to show you this

00:54:01,630 --> 00:54:10,090
is a standard C plus plus plus equal

00:54:07,270 --> 00:54:13,600
couldn't do that in C function we can

00:54:10,090 --> 00:54:15,580
now assign that to an operator in our -

00:54:13,600 --> 00:54:17,920
excuse me to a value in our so that

00:54:15,580 --> 00:54:21,070
function because we take the function

00:54:17,920 --> 00:54:26,140
pointer assign it to an our object hello

00:54:21,070 --> 00:54:29,820
and then just pass an eval hello world

00:54:26,140 --> 00:54:29,820
so we're calling the hello function

00:54:33,630 --> 00:54:36,610
answers are due at the end of class just

00:54:36,100 --> 00:54:38,650
kidding

00:54:36,610 --> 00:54:41,230
obviously it tells you hello world so

00:54:38,650 --> 00:54:46,120
even in the embedding you get back to

00:54:41,230 --> 00:54:47,800
basic C++ it's it's nice but you know

00:54:46,120 --> 00:54:49,150
one of the greatest things about open

00:54:47,800 --> 00:54:50,660
source is that every now and then you

00:54:49,150 --> 00:54:52,730
sort of you put yourself out there on

00:54:50,660 --> 00:54:54,260
shingle and wonder whether people find

00:54:52,730 --> 00:54:58,610
it use it extend it and then sometimes

00:54:54,260 --> 00:55:00,380
people come back so jumping whoo I hope

00:54:58,610 --> 00:55:02,630
I pronounced that right is I think at U

00:55:00,380 --> 00:55:05,060
of Arizona last winter sent me something

00:55:02,630 --> 00:55:07,430
back that made me just go wow that is

00:55:05,060 --> 00:55:09,770
really clever so what had she done she

00:55:07,430 --> 00:55:12,620
just taken your basic MPI hello world

00:55:09,770 --> 00:55:14,630
example and use that together with our

00:55:12,620 --> 00:55:17,390
inside so now you're in the environment

00:55:14,630 --> 00:55:20,270
of say autorun for the openmpi

00:55:17,390 --> 00:55:23,090
environment you spawn a large number of

00:55:20,270 --> 00:55:25,550
c++ programs and lo and behold they all

00:55:23,090 --> 00:55:28,820
have our insight now you're taking the

00:55:25,550 --> 00:55:30,260
advantage of our well advantage that

00:55:28,820 --> 00:55:32,930
it's single threaded doesn't have many

00:55:30,260 --> 00:55:35,330
large requirements is the way we're

00:55:32,930 --> 00:55:37,250
dimension system these days a reasonably

00:55:35,330 --> 00:55:39,140
small application and you just throw it

00:55:37,250 --> 00:55:41,180
out to a thousand nodes and each of

00:55:39,140 --> 00:55:43,670
those things to the metric of MPI just

00:55:41,180 --> 00:55:45,470
works so you get you know twenty years

00:55:43,670 --> 00:55:47,330
of our truth and test and it just works

00:55:45,470 --> 00:55:49,250
and you get you know 25 years of MPI

00:55:47,330 --> 00:55:50,810
they work together and it just works I

00:55:49,250 --> 00:55:53,210
haven't really had a chance to really

00:55:50,810 --> 00:55:56,750
crank this but this is this tremendously

00:55:53,210 --> 00:55:59,600
clever and we take no credit for it I

00:55:56,750 --> 00:56:03,500
think I reworked it a little I think she

00:55:59,600 --> 00:56:05,150
sent that as an MPI example with the C

00:56:03,500 --> 00:56:08,510
API and then I kind of just figured out

00:56:05,150 --> 00:56:11,990
may as well make it C++ API that's how

00:56:08,510 --> 00:56:14,960
to examples became for so why is our

00:56:11,990 --> 00:56:16,340
insight interesting you may have C++

00:56:14,960 --> 00:56:17,810
programs that compute gather or

00:56:16,340 --> 00:56:18,800
aggregate data go figure

00:56:17,810 --> 00:56:21,170
I mean that's why we've write C++

00:56:18,800 --> 00:56:22,610
programs or do something with data so

00:56:21,170 --> 00:56:24,200
you have data so then you want to

00:56:22,610 --> 00:56:26,150
program with data so you want to benefit

00:56:24,200 --> 00:56:27,740
from our because you need to you know

00:56:26,150 --> 00:56:29,300
save and analyze your data and you may

00:56:27,740 --> 00:56:30,470
have to do that you know in the cycle

00:56:29,300 --> 00:56:33,050
you don't want to dump it out of files

00:56:30,470 --> 00:56:34,790
so with our inside we can now skip this

00:56:33,050 --> 00:56:37,040
dumping and launching and what-have-you

00:56:34,790 --> 00:56:39,260
step we just collect our data in the

00:56:37,040 --> 00:56:41,150
beginning I was just using STL vectors

00:56:39,260 --> 00:56:44,120
of STL vectors to approximate matrices

00:56:41,150 --> 00:56:46,220
because I had nothing better with little

00:56:44,120 --> 00:56:48,980
time we can send those two are very

00:56:46,220 --> 00:56:52,790
easily things to the RTP wrappers s and

00:56:48,980 --> 00:56:54,380
wrap and all that have short simple our

00:56:52,790 --> 00:56:55,940
expressions maybe they load another

00:56:54,380 --> 00:56:58,010
package maybe this was another file you

00:56:55,940 --> 00:56:59,780
ever encoded somewhere evaluate and get

00:56:58,010 --> 00:57:02,870
the results back and it just works like

00:56:59,780 --> 00:57:03,890
that we shipped nine examples in the

00:57:02,870 --> 00:57:06,549
standard sub directory

00:57:03,890 --> 00:57:10,660
of examples and for sort of two-by-two

00:57:06,549 --> 00:57:18,650
for MPI with with that so that's a

00:57:10,660 --> 00:57:19,760
really short run through for our let me

00:57:18,650 --> 00:57:22,490
do that and when I give it to you for

00:57:19,760 --> 00:57:24,230
object protobuf this is sort of really

00:57:22,490 --> 00:57:26,930
funny because s Romain alluded to this

00:57:24,230 --> 00:57:29,660
is how we got started with this and that

00:57:26,930 --> 00:57:31,910
is what are we now yeah October it's

00:57:29,660 --> 00:57:34,250
just about a year ago and you know if if

00:57:31,910 --> 00:57:36,380
I could milk this power that I have to

00:57:34,250 --> 00:57:38,029
transform lives you'd see me on

00:57:36,380 --> 00:57:40,010
late-night TV because I sort of

00:57:38,029 --> 00:57:41,390
suggested to remain well you know you

00:57:40,010 --> 00:57:43,010
want to learn something profess with

00:57:41,390 --> 00:57:45,200
these Meyers books and you know weeks

00:57:43,010 --> 00:57:48,400
later he comes back and does wonders

00:57:45,200 --> 00:57:50,630
with it if only knew how I did that um

00:57:48,400 --> 00:57:52,010
you know now I stand here explain proto

00:57:50,630 --> 00:57:54,019
buffers to you guys so I don't really

00:57:52,010 --> 00:57:57,230
have to so you know I often refer to it

00:57:54,019 --> 00:57:59,630
as you know binary better faster XML

00:57:57,230 --> 00:58:02,950
hence hence you know I example with

00:57:59,630 --> 00:58:06,260
those icebergs these glacial large

00:58:02,950 --> 00:58:07,789
horrible icebergs I XML to us so now now

00:58:06,260 --> 00:58:09,650
we're photograph we describe data

00:58:07,789 --> 00:58:11,809
structures and code gets generated for

00:58:09,650 --> 00:58:15,190
us wonderful so there is a really simple

00:58:11,809 --> 00:58:18,559
proto definition you get the C++ code

00:58:15,190 --> 00:58:21,019
from your standard documentation for

00:58:18,559 --> 00:58:26,299
protobuf and on the right you get what

00:58:21,019 --> 00:58:28,579
we can do with that it's really sort of

00:58:26,299 --> 00:58:31,759
quite an achievement because we almost

00:58:28,579 --> 00:58:34,880
have full introspection inside of C++

00:58:31,759 --> 00:58:37,940
now because of the way our CPP the

00:58:34,880 --> 00:58:41,839
object model the our protobuf library

00:58:37,940 --> 00:58:43,490
all interact there's no code generation

00:58:41,839 --> 00:58:45,589
and compiling and linking going on

00:58:43,490 --> 00:58:48,619
that's what my very basic first example

00:58:45,589 --> 00:58:50,450
did what we're doing now is proto files

00:58:48,619 --> 00:58:53,150
get analyzed and the rest of it just

00:58:50,450 --> 00:58:56,210
just flows it's it's it's quite

00:58:53,150 --> 00:58:58,730
impressive there's the second example

00:58:56,210 --> 00:59:01,490
but you know with 28 minutes left I'll

00:58:58,730 --> 00:59:02,990
just skip that and oh sorry meant to

00:59:01,490 --> 00:59:07,039
take this one too and then I'll pass it

00:59:02,990 --> 00:59:09,279
to a row man so one of the things that

00:59:07,039 --> 00:59:12,769
are done then with our CPP was you know

00:59:09,279 --> 00:59:14,930
how can we do things faster I grew up as

00:59:12,769 --> 00:59:17,360
an econometrician econometricians often

00:59:14,930 --> 00:59:19,070
write papers by doing Monte Carlo

00:59:17,360 --> 00:59:22,070
elation of small sample properties you

00:59:19,070 --> 00:59:24,260
know you want estimators as well as as

00:59:22,070 --> 00:59:26,330
the estimated standard errors are has a

00:59:24,260 --> 00:59:29,330
couple of really fast functions to do

00:59:26,330 --> 00:59:30,830
linear models or LS estimation quickly

00:59:29,330 --> 00:59:32,360
but for the fast ones you don't

00:59:30,830 --> 00:59:34,700
necessarily get the standard errors back

00:59:32,360 --> 00:59:36,770
so we figured okay what can we do to do

00:59:34,700 --> 00:59:39,770
that really quickly this was the first

00:59:36,770 --> 00:59:40,250
version again it just this is all it

00:59:39,770 --> 00:59:42,620
takes

00:59:40,250 --> 00:59:44,780
thanks to inline I guess we're still

00:59:42,620 --> 00:59:49,100
using CPP function there rather than CX

00:59:44,780 --> 00:59:52,760
x function what happens is we're getting

00:59:49,100 --> 00:59:54,860
some numeric vectors that's the type or

00:59:52,760 --> 00:59:56,930
that should be oh no well it's a really

00:59:54,860 --> 00:59:58,760
old code so then we we still used in

00:59:56,930 --> 01:00:00,410
America we call it America corn with

00:59:58,760 --> 01:00:03,500
matrix so don't want to stick here too

01:00:00,410 --> 01:00:05,990
long there's some passage going on into

01:00:03,500 --> 01:00:08,690
our data structure over to our module

01:00:05,990 --> 01:00:13,880
data structures a module is a maybe two

01:00:08,690 --> 01:00:15,350
year old lovely project out of ni CTA or

01:00:13,880 --> 01:00:16,580
maybe they call it NICTA which is sort

01:00:15,350 --> 01:00:19,600
of a government-sponsored research

01:00:16,580 --> 01:00:22,820
organization in Australia really clever

01:00:19,600 --> 01:00:25,340
heavily templated linear algebra stuff

01:00:22,820 --> 01:00:26,750
with really clever benchmark examples

01:00:25,340 --> 01:00:28,430
how it outperforms other C++

01:00:26,750 --> 01:00:30,560
implementation so it's it's a bit like

01:00:28,430 --> 01:00:32,480
like Blitz plus plus which no longer

01:00:30,560 --> 01:00:33,980
lives and it is a bit better I find them

01:00:32,480 --> 01:00:36,920
them them the boost linear algebra stuff

01:00:33,980 --> 01:00:38,210
so we use something like that we started

01:00:36,920 --> 01:00:39,950
working with that and then created a

01:00:38,210 --> 01:00:41,750
little bit of glue so we can do better

01:00:39,950 --> 01:00:43,400
than sort of the basic example now

01:00:41,750 --> 01:00:47,120
there's a package our CPP i'ma deal

01:00:43,400 --> 01:00:50,900
which basically sends our types through

01:00:47,120 --> 01:00:52,610
efficiently so we're using armor which

01:00:50,900 --> 01:00:55,280
basically take a memory point of the

01:00:52,610 --> 01:00:57,740
dimension and the false boolean saying

01:00:55,280 --> 01:00:59,750
that don't do a copy just just pass it

01:00:57,740 --> 01:01:01,960
through trust us this object has N by K

01:00:59,750 --> 01:01:05,270
dimension work with it and then

01:01:01,960 --> 01:01:08,360
estimating your linear model is nothing

01:01:05,270 --> 01:01:11,090
more than solve X in Y so that in our

01:01:08,360 --> 01:01:15,250
lingo fits why tell the X then you're

01:01:11,090 --> 01:01:18,920
calculating residuals we're calculating

01:01:15,250 --> 01:01:21,470
as we're really quickly and with that

01:01:18,920 --> 01:01:23,780
can return the coefficient

01:01:21,470 --> 01:01:25,910
Aaron the degrees of freedom that you

01:01:23,780 --> 01:01:27,200
know what's motivated once by by a

01:01:25,910 --> 01:01:28,880
question where someone wanted to do

01:01:27,200 --> 01:01:31,730
something really really quickly we

01:01:28,880 --> 01:01:33,500
started doing it with armor in the HPC

01:01:31,730 --> 01:01:36,380
tutorials I did it with armor and before

01:01:33,500 --> 01:01:37,609
that with GSL as well given the time

01:01:36,380 --> 01:01:39,770
constraint I won't stay here for too

01:01:37,609 --> 01:01:41,420
long this is sort of a half-finished

01:01:39,770 --> 01:01:43,430
package that we have on our Forge that

01:01:41,420 --> 01:01:45,140
this this takes these sort of the

01:01:43,430 --> 01:01:47,630
wrapping the glue the access to other

01:01:45,140 --> 01:01:49,670
given data structures to GSL which a lot

01:01:47,630 --> 01:01:51,170
of people use it's unfortunate it's not

01:01:49,670 --> 01:01:52,369
as slick as Armour because it can't be

01:01:51,170 --> 01:01:54,920
because the underlying data structures

01:01:52,369 --> 01:01:56,810
are see and not C++ so but we still want

01:01:54,920 --> 01:01:58,550
to get back and finish it eventually but

01:01:56,810 --> 01:02:00,560
I'm not going to say much about it that

01:01:58,550 --> 01:02:04,369
was so basically just there's three fast

01:02:00,560 --> 01:02:06,349
examples for say you want to run a

01:02:04,369 --> 01:02:07,640
million gazillion linear models and you

01:02:06,349 --> 01:02:08,930
want to do it fast these are choices

01:02:07,640 --> 01:02:11,840
that you have the best one for that

01:02:08,930 --> 01:02:18,470
definitely it's fast LM now in the MIDI

01:02:11,840 --> 01:02:24,410
or package okay so we have about twenty

01:02:18,470 --> 01:02:26,720
minutes to two to finish now so I'll go

01:02:24,410 --> 01:02:31,280
fairly quickly through this did the idea

01:02:26,720 --> 01:02:37,490
was to to give a short preview of how to

01:02:31,280 --> 01:02:42,130
do objects in in R and and and so using

01:02:37,490 --> 01:02:45,410
this as a sort of a thread to link to

01:02:42,130 --> 01:02:49,420
new developments we've put in in in in

01:02:45,410 --> 01:02:53,960
our cpp recently with with John's help

01:02:49,420 --> 01:02:54,830
so I'll go quickly because some of this

01:02:53,960 --> 01:02:57,380
material

01:02:54,830 --> 01:03:00,920
you probably already know a fair bit

01:02:57,380 --> 01:03:05,150
about so there's many many more ways in

01:03:00,920 --> 01:03:07,880
in R to to to come up with ways to

01:03:05,150 --> 01:03:12,440
represent objects and you and you'll see

01:03:07,880 --> 01:03:14,690
the list there with pencils so I'll I'll

01:03:12,440 --> 01:03:17,330
quickly go through them the thread I'll

01:03:14,690 --> 01:03:20,359
used there as a fairly sort of old

01:03:17,330 --> 01:03:26,660
example which is the bank account

01:03:20,359 --> 01:03:30,530
example a fairly well really schematic

01:03:26,660 --> 01:03:32,030
view of a bank bank account is the

01:03:30,530 --> 01:03:34,560
balance you have on your account and

01:03:32,030 --> 01:03:37,110
perhaps the authorized the offered

01:03:34,560 --> 01:03:38,940
and then what you want to do with the

01:03:37,110 --> 01:03:42,590
account is do you want to open it

01:03:38,940 --> 01:03:45,900
check the balloons put some money on it

01:03:42,590 --> 01:03:48,990
get some money out of it and so on so

01:03:45,900 --> 01:03:53,240
the first way to sort of do this comes

01:03:48,990 --> 01:03:57,560
from comes from a demo that's in our

01:03:53,240 --> 01:04:00,720
demo scoping uses a feature that's

01:03:57,560 --> 01:04:05,040
perhaps not as known as it should be in

01:04:00,720 --> 01:04:07,560
art for me it's one of the best features

01:04:05,040 --> 01:04:14,570
of the of the our language the lexical

01:04:07,560 --> 01:04:17,040
scoping it works it essentially works

01:04:14,570 --> 01:04:20,490
because you define a function within

01:04:17,040 --> 01:04:26,250
another function and and the way objects

01:04:20,490 --> 01:04:29,340
are being looked up if an object is not

01:04:26,250 --> 01:04:33,060
found in the in the environment of this

01:04:29,340 --> 01:04:37,110
function you're creating it looks up in

01:04:33,060 --> 01:04:40,620
the other in the enclosing function and

01:04:37,110 --> 01:04:44,940
so on and this this simple mechanism

01:04:40,620 --> 01:04:50,760
lets you encapsulate data in a really

01:04:44,940 --> 01:04:55,980
simple way which there so for example in

01:04:50,760 --> 01:05:00,420
the deposit you query and set total

01:04:55,980 --> 01:05:02,250
there in the enclosing environment but

01:05:00,420 --> 01:05:06,810
but the but the actual account you

01:05:02,250 --> 01:05:10,590
create after that does not let you well

01:05:06,810 --> 01:05:13,950
does not let you easily modify the total

01:05:10,590 --> 01:05:17,340
variable but but you get access to it

01:05:13,950 --> 01:05:20,340
through through the elements of the of

01:05:17,340 --> 01:05:22,170
the list you do return and this this is

01:05:20,340 --> 01:05:27,420
fairly nice that there's there's a few a

01:05:22,170 --> 01:05:30,360
sort of small problems with it and will

01:05:27,420 --> 01:05:35,880
maybe cover this so on top of that

01:05:30,360 --> 01:05:37,920
there's a as three classes so which hope

01:05:35,880 --> 01:05:41,680
I'm not saying anything sort of a stupid

01:05:37,920 --> 01:05:45,970
hair but so as three was the

01:05:41,680 --> 01:05:50,230
so the first object-oriented way of

01:05:45,970 --> 01:05:52,569
representing a data any object in our

01:05:50,230 --> 01:05:54,279
can can become an s3 object the only

01:05:52,569 --> 01:05:57,309
thing you have to do is assign the class

01:05:54,279 --> 01:06:00,220
attribute to it and for that reason it's

01:05:57,309 --> 01:06:02,529
really easy you just grab an object give

01:06:00,220 --> 01:06:04,960
a class and that's it but for that

01:06:02,529 --> 01:06:08,140
reason is really also very dangerous

01:06:04,960 --> 01:06:11,499
because you you cannot just grab any

01:06:08,140 --> 01:06:14,740
sort of you know garbage from anywhere

01:06:11,499 --> 01:06:21,009
and say that's a GLM or that's LM or

01:06:14,740 --> 01:06:23,499
that's density fit or whatever so that

01:06:21,009 --> 01:06:26,529
there's there's no restriction there and

01:06:23,499 --> 01:06:29,170
this is why it's really dangerous but it

01:06:26,529 --> 01:06:31,960
gets the work done so how do you do this

01:06:29,170 --> 01:06:35,309
as I said you just assign a class to

01:06:31,960 --> 01:06:38,410
your object in and then it works with

01:06:35,309 --> 01:06:41,049
generic functions and implementation of

01:06:38,410 --> 01:06:44,470
this generic function that our cool

01:06:41,049 --> 01:06:47,680
methods and so on so the balanced

01:06:44,470 --> 01:06:49,960
generic function there you recognize it

01:06:47,680 --> 01:06:54,720
generic because it calls use method and

01:06:49,960 --> 01:06:58,799
then the implementation of balance for

01:06:54,720 --> 01:07:03,089
the particular s3 class is given there

01:06:58,799 --> 01:07:06,220
so I'm going really quickly on this but

01:07:03,089 --> 01:07:09,970
anyway so other functions as well so

01:07:06,220 --> 01:07:13,420
little checking of consistency of

01:07:09,970 --> 01:07:15,670
arguments and so on you and and and then

01:07:13,420 --> 01:07:20,739
you would use this like this so you

01:07:15,670 --> 01:07:21,519
create an account check the balance put

01:07:20,739 --> 01:07:25,239
money on it

01:07:21,519 --> 01:07:27,279
withdraw money from it the the only

01:07:25,239 --> 01:07:30,789
thing I'd like to highlight probably

01:07:27,279 --> 01:07:34,450
there is that because of the way date is

01:07:30,789 --> 01:07:37,450
being passed you if you modify the

01:07:34,450 --> 01:07:41,259
object you have to grab the result from

01:07:37,450 --> 01:07:44,499
it if I if I cycle back there you see

01:07:41,259 --> 01:07:47,680
that I do X dollar balance equals x

01:07:44,499 --> 01:07:52,790
dollar balance plus something well that

01:07:47,680 --> 01:07:56,440
actually creates a new X right right

01:07:52,790 --> 01:07:59,510
and and so you need to grab this this

01:07:56,440 --> 01:08:02,750
this this new X because it it will be

01:07:59,510 --> 01:08:05,720
different then than the so for example

01:08:02,750 --> 01:08:07,280
I'm passing myself to the deposit

01:08:05,720 --> 01:08:12,680
function and the results I'm getting

01:08:07,280 --> 01:08:16,460
that's not the same object and and it's

01:08:12,680 --> 01:08:18,529
it's it's nice enough I mean if you want

01:08:16,460 --> 01:08:20,980
to create for example a GLM and then do

01:08:18,529 --> 01:08:24,080
something from it

01:08:20,980 --> 01:08:27,290
s3 is nice enough but once you really

01:08:24,080 --> 01:08:30,950
start to want to do object you know oh

01:08:27,290 --> 01:08:35,000
oh P then it probably you want you want

01:08:30,950 --> 01:08:41,350
something else right so s4 classes I'll

01:08:35,000 --> 01:08:41,350
go even even faster on this it's it

01:08:42,940 --> 01:08:48,109
gives you much more control of your of

01:08:46,400 --> 01:08:50,210
your classes so you have formal

01:08:48,109 --> 01:08:54,819
definition of the class you you're able

01:08:50,210 --> 01:08:59,350
to embed validity so that you're able to

01:08:54,819 --> 01:09:03,830
define if this object is valid and

01:08:59,350 --> 01:09:05,810
dispatches is much more powerful but I

01:09:03,830 --> 01:09:08,239
mean I don't want to be insulting or

01:09:05,810 --> 01:09:12,020
anything but it it's a system that

01:09:08,239 --> 01:09:15,589
requires to write a lot of code and and

01:09:12,020 --> 01:09:17,660
and more annoyingly a lot of

01:09:15,589 --> 01:09:22,970
documentation I mean there are helpers

01:09:17,660 --> 01:09:25,850
that that are nice but when you start

01:09:22,970 --> 01:09:28,400
writing a substantial package using s

01:09:25,850 --> 01:09:30,620
for that you end up writing tons and

01:09:28,400 --> 01:09:34,100
tons of documentation and well people

01:09:30,620 --> 01:09:38,960
like this people don't like this I'll

01:09:34,100 --> 01:09:41,960
let you choose your side anyway so yeah

01:09:38,960 --> 01:09:43,730
the class is more formally defined so

01:09:41,960 --> 01:09:46,040
you define a class you define the slug

01:09:43,730 --> 01:09:48,020
soft of the of the year of the object so

01:09:46,040 --> 01:09:50,420
the balance is a numeric vector the

01:09:48,020 --> 01:09:52,370
overdraft authorized overdraft is a

01:09:50,420 --> 01:09:55,280
numeric vector you're able to give a

01:09:52,370 --> 01:09:59,350
prototype of the of the object and then

01:09:55,280 --> 01:10:04,489
the validity function there it and then

01:09:59,350 --> 01:10:06,620
it sits about the same thing as s3 in

01:10:04,489 --> 01:10:08,690
respect that you define generic for

01:10:06,620 --> 01:10:11,420
action and and implementation of these

01:10:08,690 --> 01:10:13,370
generic well you can go much further

01:10:11,420 --> 01:10:15,320
than necessary because you can do

01:10:13,370 --> 01:10:18,200
multiple dispatch and things like this

01:10:15,320 --> 01:10:20,600
but the idea is the same that it's the

01:10:18,200 --> 01:10:26,540
verb that controls everything it you

01:10:20,600 --> 01:10:28,310
don't say objects you know you don't

01:10:26,540 --> 01:10:33,140
invoke a method of an object but you

01:10:28,310 --> 01:10:38,660
invoke a generic function and you get

01:10:33,140 --> 01:10:41,930
this part from yeah so the syntax is a

01:10:38,660 --> 01:10:48,110
bit different but then once you have

01:10:41,930 --> 01:10:53,300
done all of this the you use them about

01:10:48,110 --> 01:10:56,510
the same way so fairly recently appeared

01:10:53,300 --> 01:10:59,110
reference classes which some of us call

01:10:56,510 --> 01:11:02,270
our five it's not the official name but

01:10:59,110 --> 01:11:06,010
which we're trying to get jump to to

01:11:02,270 --> 01:11:06,010
agree on this name anyway

01:11:06,130 --> 01:11:13,910
the the way I see them are five well

01:11:10,910 --> 01:11:17,870
reference classes are let you have both

01:11:13,910 --> 01:11:21,110
advantages of s4 and of something simple

01:11:17,870 --> 01:11:26,410
as lexical scoping there are real actual

01:11:21,110 --> 01:11:29,120
classes but you know which implies

01:11:26,410 --> 01:11:32,330
formalism and and dispatch and and you

01:11:29,120 --> 01:11:34,220
know in all the rest of it quite a bit

01:11:32,330 --> 01:11:40,190
of documentation but not as much as this

01:11:34,220 --> 01:11:43,310
for at the moment like at least me maybe

01:11:40,190 --> 01:11:45,560
John will change his mind other but the

01:11:43,310 --> 01:11:49,640
real interest thing is that the these

01:11:45,560 --> 01:11:52,400
objects are passed by reference which is

01:11:49,640 --> 01:11:55,460
quite different than what whatever else

01:11:52,400 --> 01:11:59,810
I presented before and this this is

01:11:55,460 --> 01:12:02,960
really easy to use so the way you would

01:11:59,810 --> 01:12:08,740
create a new reference class is about

01:12:02,960 --> 01:12:12,500
similar to it's a bit between s4 and

01:12:08,740 --> 01:12:16,640
lexical scoping way of doing things so

01:12:12,500 --> 01:12:20,390
you give a name to the to the class and

01:12:16,640 --> 01:12:25,520
give the definition of the fields

01:12:20,390 --> 01:12:28,040
so and and the fields is really what

01:12:25,520 --> 01:12:30,170
defers from S 4 in s for you you call

01:12:28,040 --> 01:12:33,680
them and those are passed by value

01:12:30,170 --> 01:12:38,240
in a reference classes they're called

01:12:33,680 --> 01:12:38,870
fields and this is what is passed by by

01:12:38,240 --> 01:12:40,880
reference

01:12:38,870 --> 01:12:43,460
so the balance and the other draft and

01:12:40,880 --> 01:12:46,820
so on and then the the other argument is

01:12:43,460 --> 01:12:50,960
the methods so a I'm defining two

01:12:46,820 --> 01:12:54,200
methods withdraw and deposit this

01:12:50,960 --> 01:12:56,180
doesn't appear there but one really nice

01:12:54,200 --> 01:13:00,830
thing about this is that one method can

01:12:56,180 --> 01:13:03,680
call another method and well this dis

01:13:00,830 --> 01:13:08,450
also as inheritance and everything I

01:13:03,680 --> 01:13:09,980
mean this was just a quick a quick view

01:13:08,450 --> 01:13:12,020
of it if you're interested in learning

01:13:09,980 --> 01:13:16,610
more about this this just came out in

01:13:12,020 --> 01:13:19,580
212 just go questionmark reference

01:13:16,610 --> 01:13:23,090
classes and and really encourage people

01:13:19,580 --> 01:13:26,050
to have a look at this right so once you

01:13:23,090 --> 01:13:31,850
create a new object they're using the

01:13:26,050 --> 01:13:36,530
generator then you then it it sounds

01:13:31,850 --> 01:13:40,990
look more like usual Opie systems you do

01:13:36,530 --> 01:13:46,670
object dollar we cannot do dot because

01:13:40,990 --> 01:13:49,490
we cannot anyway we do dollar so object

01:13:46,670 --> 01:13:52,760
dollar method and then parameters of the

01:13:49,490 --> 01:13:55,820
of the method and as I said before those

01:13:52,760 --> 01:13:57,650
apart by reference so if I were to

01:13:55,820 --> 01:13:59,840
create a ball roll function so that

01:13:57,650 --> 01:14:03,080
dough can borrow

01:13:59,840 --> 01:14:08,300
maybe not money but perhaps time from me

01:14:03,080 --> 01:14:10,280
I go like this so I'd what what the ball

01:14:08,300 --> 01:14:13,400
roll function would do is that withdraw

01:14:10,280 --> 01:14:15,590
money from one account to deposit on on

01:14:13,400 --> 01:14:20,780
some other accounts and what what I

01:14:15,590 --> 01:14:23,360
wanted to show there is that since

01:14:20,780 --> 01:14:27,800
objects are passed by reference the they

01:14:23,360 --> 01:14:31,100
are you know modified in place so you

01:14:27,800 --> 01:14:33,800
don't have to grab the result of the

01:14:31,100 --> 01:14:35,930
function so so to make sure that you

01:14:33,800 --> 01:14:40,300
you're still in sync the your object is

01:14:35,930 --> 01:14:43,790
really a reference that's that changes a

01:14:40,300 --> 01:14:45,830
lot of things you could do it

01:14:43,790 --> 01:14:48,860
differently you could dynamically add a

01:14:45,830 --> 01:14:52,460
method to the reference class by calling

01:14:48,860 --> 01:14:54,740
the the methods function of the

01:14:52,460 --> 01:14:58,160
generator there that's another way to do

01:14:54,740 --> 01:15:02,180
it but much more documentation to read

01:14:58,160 --> 01:15:04,780
on on the question mark reference

01:15:02,180 --> 01:15:10,250
classes in our 2.12

01:15:04,780 --> 01:15:15,440
anyway so going further i what we want

01:15:10,250 --> 01:15:18,850
to do is rather than use our object we

01:15:15,440 --> 01:15:26,570
perhaps want to use C++ classes directly

01:15:18,850 --> 01:15:28,580
in our and for that for that we we came

01:15:26,570 --> 01:15:32,900
up with something we call our CPP

01:15:28,580 --> 01:15:36,250
modules that's inspired from from

01:15:32,900 --> 01:15:40,370
another library called boost bison that

01:15:36,250 --> 01:15:45,320
does something similar for C++ and

01:15:40,370 --> 01:15:49,070
Python so we want to expose this fairly

01:15:45,320 --> 01:15:53,360
simple C++ class so that people can use

01:15:49,070 --> 01:15:55,850
it directly in our so the class itself

01:15:53,360 --> 01:15:57,770
is sort of self-explanatory and well

01:15:55,850 --> 01:16:01,940
that's the same example we've seen all

01:15:57,770 --> 01:16:03,170
along so so what if we want to expose

01:16:01,940 --> 01:16:08,470
this to the eye level

01:16:03,170 --> 01:16:13,000
all we have to do is write this piece of

01:16:08,470 --> 01:16:17,210
declarative code there so we create a

01:16:13,000 --> 01:16:20,540
module using the are CPP module macro

01:16:17,210 --> 01:16:22,610
there of which we give a name yadda

01:16:20,540 --> 01:16:29,110
I hope the Seinfeld fan would appreciate

01:16:22,610 --> 01:16:33,020
the the reference and then we

01:16:29,110 --> 01:16:37,160
essentially say that we expose through

01:16:33,020 --> 01:16:40,490
the template argument the account class

01:16:37,160 --> 01:16:43,370
and then the argument of the constructor

01:16:40,490 --> 01:16:45,560
of class underscore is the name we want

01:16:43,370 --> 01:16:47,599
to give to this class on the outside and

01:16:45,560 --> 01:16:50,060
then we declare

01:16:47,599 --> 01:16:52,849
Woodfield and what methods we want to

01:16:50,060 --> 01:16:57,710
expose to the outside so we want to

01:16:52,849 --> 01:16:59,750
explore the read-only field balance so

01:16:57,710 --> 01:17:03,530
we give the name balance and we give the

01:16:59,750 --> 01:17:09,710
the pointer of the C++ field and

01:17:03,530 --> 01:17:11,840
similarly for the methods we we give the

01:17:09,710 --> 01:17:16,070
name we want to use on the outside for

01:17:11,840 --> 01:17:17,960
the method and the method pointer right

01:17:16,070 --> 01:17:22,340
once this is done compiled and

01:17:17,960 --> 01:17:28,420
everything we can directly use this on

01:17:22,340 --> 01:17:30,170
the on the outside so we grab account

01:17:28,420 --> 01:17:33,590
from the module

01:17:30,170 --> 01:17:36,739
well yadda is the module the module will

01:17:33,590 --> 01:17:40,489
let you expose either C++ functions or

01:17:36,739 --> 01:17:44,300
C++ classes we might have to skip this

01:17:40,489 --> 01:17:47,530
later then we create a new count deposit

01:17:44,300 --> 01:17:50,719
money withdraw money check the balance

01:17:47,530 --> 01:17:52,369
everything there that the only thing

01:17:50,719 --> 01:17:55,130
that's on the outside is really a

01:17:52,369 --> 01:17:57,320
pointer to the data structure the data

01:17:55,130 --> 01:17:59,989
structure that lives on the c++ side

01:17:57,320 --> 01:18:03,070
there's nothing else on the outside and

01:17:59,989 --> 01:18:06,020
all of this is is sits on top of

01:18:03,070 --> 01:18:12,110
reference classes that have been

01:18:06,020 --> 01:18:14,659
introduced in in our 2.12 yeah so that

01:18:12,110 --> 01:18:16,790
that that's a quick way to obviously

01:18:14,659 --> 01:18:20,090
this example is really sort of simplest

01:18:16,790 --> 01:18:22,969
and stupid but if you add a fairly

01:18:20,090 --> 01:18:27,349
complex C++ class and you didn't want to

01:18:22,969 --> 01:18:30,920
manage this in our directly but just do

01:18:27,349 --> 01:18:35,420
a few operations on the instances of

01:18:30,920 --> 01:18:38,570
this class then modules lets you do this

01:18:35,420 --> 01:18:41,840
quite efficiently well we've already

01:18:38,570 --> 01:18:46,219
covered this but another way perhaps to

01:18:41,840 --> 01:18:48,469
do objects protocol buffers it's not

01:18:46,219 --> 01:18:51,469
totally appropriate for object because

01:18:48,469 --> 01:18:54,320
protocol buffers really dumb data

01:18:51,469 --> 01:18:58,190
collect data structures that you cannot

01:18:54,320 --> 01:19:01,040
associate methods to them but as a quick

01:18:58,190 --> 01:19:01,800
way to encapsulate a certain type of

01:19:01,040 --> 01:19:05,820
data

01:19:01,800 --> 01:19:09,570
not as possible right there was a there

01:19:05,820 --> 01:19:12,660
was a bit of a few slides on directly

01:19:09,570 --> 01:19:14,730
modules but I'll really go quickly on

01:19:12,660 --> 01:19:18,990
them so as I said before modules lets

01:19:14,730 --> 01:19:24,540
you expose C++ functions in classes back

01:19:18,990 --> 01:19:28,350
to our so let well again the most

01:19:24,540 --> 01:19:33,150
engineered function of the of the of the

01:19:28,350 --> 01:19:37,170
slideshow hello so as you can see there

01:19:33,150 --> 01:19:38,520
there's no there's nothing are related

01:19:37,170 --> 01:19:43,130
in this function there's no macro

01:19:38,520 --> 01:19:46,320
there's no sex there's no even our CPP

01:19:43,130 --> 01:19:50,610
thing is just a function that takes a

01:19:46,320 --> 01:19:57,270
string reference and sends back a C

01:19:50,610 --> 01:19:59,300
string and and I want to expose this

01:19:57,270 --> 01:20:02,700
back to our so I want to use this

01:19:59,300 --> 01:20:04,980
dysfunction in our and module lets you

01:20:02,700 --> 01:20:06,390
do they do this quite quite easily the

01:20:04,980 --> 01:20:08,220
only thing you have to do is declare

01:20:06,390 --> 01:20:10,200
that you want to use it so you go

01:20:08,220 --> 01:20:13,860
function give the name of the function

01:20:10,200 --> 01:20:15,960
and give the function point to that and

01:20:13,860 --> 01:20:20,340
and then you're just able to use the

01:20:15,960 --> 01:20:23,760
function by grabbing the reference of

01:20:20,340 --> 01:20:25,320
the module and call the function and

01:20:23,760 --> 01:20:27,000
obviously there's a lot of type checking

01:20:25,320 --> 01:20:29,550
and everything to make sure that you're

01:20:27,000 --> 01:20:31,500
not passing something that it's not

01:20:29,550 --> 01:20:34,140
appropriate for for this particular

01:20:31,500 --> 01:20:38,600
function exposing classes we have

01:20:34,140 --> 01:20:38,600
covered this already so I'll skip

01:20:42,219 --> 01:20:48,489
do you want to finish up with this and

01:20:45,169 --> 01:20:48,489
you have two minutes

01:20:49,449 --> 01:20:55,429
so getting towards the end so we just

01:20:53,119 --> 01:20:57,769
thought we hadn't really said how how

01:20:55,429 --> 01:20:59,659
you use this in your package other than

01:20:57,769 --> 01:21:02,119
pointing though the fact that among the

01:20:59,659 --> 01:21:03,860
eight vignettes included in the Seb

01:21:02,119 --> 01:21:06,349
package vignette as a sort of

01:21:03,860 --> 01:21:09,289
self-contained PDF document is one RCP

01:21:06,349 --> 01:21:13,669
package that has details but one really

01:21:09,289 --> 01:21:15,679
nice trick is to prototype using inline

01:21:13,669 --> 01:21:17,869
which we advertised earlier it really

01:21:15,679 --> 01:21:19,579
works quite well and then the object

01:21:17,869 --> 01:21:21,800
returned by si execs function the

01:21:19,579 --> 01:21:23,629
function that you can call it has a lot

01:21:21,800 --> 01:21:25,489
of baggage behind the scenes about how

01:21:23,629 --> 01:21:27,379
it was being built which we can then

01:21:25,489 --> 01:21:30,559
pick up or which you know pecker

01:21:27,379 --> 01:21:33,320
skeleton picks up to basically generate

01:21:30,559 --> 01:21:35,679
yourself a picture a package out of it

01:21:33,320 --> 01:21:38,329
so you use inline you call packaged

01:21:35,679 --> 01:21:40,369
skeleton on on the generated function

01:21:38,329 --> 01:21:42,499
and you know magic happens as with

01:21:40,369 --> 01:21:44,300
Disney sort of killing inside the thing

01:21:42,499 --> 01:21:46,280
that happens is that we we overloaded

01:21:44,300 --> 01:21:48,590
packaged skeleton and made that do stuff

01:21:46,280 --> 01:21:50,059
for us so but you know as it then goes

01:21:48,590 --> 01:21:52,129
as we were debugging that in the hotel

01:21:50,059 --> 01:21:54,409
this morning actually turns out that it

01:21:52,129 --> 01:21:55,909
got a hiccup with the single one so

01:21:54,409 --> 01:21:57,709
that's a good excuse to show you see

01:21:55,909 --> 01:21:59,419
execs function for several functions at

01:21:57,709 --> 01:22:02,030
the time these are now once again

01:21:59,419 --> 01:22:03,499
nonsensical but the nice thing that goes

01:22:02,030 --> 01:22:05,780
back I think to earlier versions of C

01:22:03,499 --> 01:22:07,760
function is that it generalizes to lists

01:22:05,780 --> 01:22:09,320
of everything so if you just want to

01:22:07,760 --> 01:22:11,269
generate several functions instead of

01:22:09,320 --> 01:22:13,519
passing in a signature and a function

01:22:11,269 --> 01:22:15,769
body you just pass in a list of

01:22:13,519 --> 01:22:18,199
signatures and a list of function bodies

01:22:15,769 --> 01:22:20,599
these are named lists so we're creating

01:22:18,199 --> 01:22:22,219
tick and tack and between signatures and

01:22:20,599 --> 01:22:25,489
bodies the names have posed to be

01:22:22,219 --> 01:22:27,739
present or it just returns empty so you

01:22:25,489 --> 01:22:30,199
want to do it this way so this this is a

01:22:27,739 --> 01:22:32,059
real life example we ran this so this

01:22:30,199 --> 01:22:33,769
then generates you foo which has a

01:22:32,059 --> 01:22:36,679
function tick and a function tag is

01:22:33,769 --> 01:22:39,199
defined there by the code you can test

01:22:36,679 --> 01:22:40,939
them it you know I was doing some simple

01:22:39,199 --> 01:22:44,149
sort of distant measure like things in

01:22:40,939 --> 01:22:46,010
all the computing that it does but if

01:22:44,149 --> 01:22:48,829
you know want to create a package all

01:22:46,010 --> 01:22:50,450
you do is call echo skeleton with the

01:22:48,829 --> 01:22:52,970
name of an art maker if you want

01:22:50,450 --> 01:22:54,770
me and the web packaged skeleton

01:22:52,970 --> 01:22:56,030
generally works you pass it a list of

01:22:54,770 --> 01:22:58,040
our objects that should be in the

01:22:56,030 --> 01:23:01,130
package and in this case we just give it

01:22:58,040 --> 01:23:02,930
to I guess as the code is in the report

01:23:01,130 --> 01:23:04,250
as of today it wants list there so now

01:23:02,930 --> 01:23:09,290
you have a package that generates two

01:23:04,250 --> 01:23:12,020
functions that's really all there is bit

01:23:09,290 --> 01:23:14,990
off further reading in case this sort of

01:23:12,020 --> 01:23:16,220
whetted your appetite the package as I

01:23:14,990 --> 01:23:18,020
mentioned has eight vignettes

01:23:16,220 --> 01:23:20,510
the first one is an introduction that's

01:23:18,020 --> 01:23:23,060
that's reasonably full-featured now

01:23:20,510 --> 01:23:24,530
revised and you know resubmitted and

01:23:23,060 --> 01:23:26,720
hopefully forthcoming it's

01:23:24,530 --> 01:23:29,210
self-contained and and current things to

01:23:26,720 --> 01:23:30,950
the review process we also have an FAQ

01:23:29,210 --> 01:23:33,590
document for a couple of things that

01:23:30,950 --> 01:23:35,930
have come up on the mailing list we tell

01:23:33,590 --> 01:23:37,880
you how to use it in your own package as

01:23:35,930 --> 01:23:40,070
I just did there's a document that talks

01:23:37,880 --> 01:23:43,280
a little about the glue that we use for

01:23:40,070 --> 01:23:45,830
a MIDI you and GSL reps then we have

01:23:43,280 --> 01:23:48,170
three further vignettes that are in a

01:23:45,830 --> 01:23:49,880
half-baked state that isn't fully

01:23:48,170 --> 01:23:53,750
finished sort of one on sugar one on

01:23:49,880 --> 01:23:55,730
modules which still chain which is a lot

01:23:53,750 --> 01:23:58,190
we borrowed sort of something from other

01:23:55,730 --> 01:24:00,020
FSF documents we want a quick graph that

01:23:58,190 --> 01:24:01,130
just shows you the API but you know

01:24:00,020 --> 01:24:03,500
there's so much there we haven't written

01:24:01,130 --> 01:24:04,940
that one either and always generated

01:24:03,500 --> 01:24:07,190
that that's an idea I think we got from

01:24:04,940 --> 01:24:08,900
some other packages is this there's unit

01:24:07,190 --> 01:24:11,110
tests in the package in our unit tests

01:24:08,900 --> 01:24:14,330
and shows you the result of all of them

01:24:11,110 --> 01:24:16,520
the unit tests generally also double up

01:24:14,330 --> 01:24:19,100
as hard to read documentation sort of

01:24:16,520 --> 01:24:21,260
kidding aside we try to stress every

01:24:19,100 --> 01:24:23,840
relevant facts if you think about can

01:24:21,260 --> 01:24:25,160
you do this or that that's unfortunately

01:24:23,840 --> 01:24:27,530
what we do ourselves every now and then

01:24:25,160 --> 01:24:30,350
we just grab among those so that that's

01:24:27,530 --> 01:24:32,480
sort of there are CPP is being picked up

01:24:30,350 --> 01:24:34,940
then all fifteen packages on cran

01:24:32,480 --> 01:24:37,700
including our crane and bioconductor

01:24:34,940 --> 01:24:38,840
some some of those our own but but not

01:24:37,700 --> 01:24:40,730
too many there are a couple of other

01:24:38,840 --> 01:24:43,760
people who we didn't coerce to use our

01:24:40,730 --> 01:24:45,230
stuff and they still do and then there's

01:24:43,760 --> 01:24:48,920
the mailing list which was also growing

01:24:45,230 --> 01:24:50,960
in has has archives and with that we're

01:24:48,920 --> 01:24:53,210
sort of at the end this is a final slide

01:24:50,960 --> 01:24:56,000
from one of the other presentations

01:24:53,210 --> 01:24:57,830
given this year so if you want you know

01:24:56,000 --> 01:25:00,170
paid support for that I think Romain

01:24:57,830 --> 01:25:02,420
would be happy to help I do have a job

01:25:00,170 --> 01:25:05,120
so I don't really offer that but

01:25:02,420 --> 01:25:07,940
again thanks for having us are we happy

01:25:05,120 --> 01:25:20,660
to take questions now and or later

01:25:07,940 --> 01:25:23,000
oh yes and microphone was recommended so

01:25:20,660 --> 01:25:25,610
that it gets recorded yes so this may be

01:25:23,000 --> 01:25:27,530
a question is a little premature given

01:25:25,610 --> 01:25:30,380
the rapid pace at which you guys are

01:25:27,530 --> 01:25:32,390
doing things but trying to play around a

01:25:30,380 --> 01:25:37,340
bit with this lately what I've been

01:25:32,390 --> 01:25:39,860
doing is to look at pieces of C++ code

01:25:37,340 --> 01:25:42,080
particularly pieces of C++ code that are

01:25:39,860 --> 01:25:45,940
already interface to R which of course

01:25:42,080 --> 01:25:49,219
biases it and what I tend to see is

01:25:45,940 --> 01:25:52,670
often interesting stuff but of course

01:25:49,219 --> 01:25:54,230
it's very C++ oriented and so to take

01:25:52,670 --> 01:25:56,600
one example which apparently isn't too

01:25:54,230 --> 01:25:58,429
popular around here the boost library

01:25:56,600 --> 01:26:02,780
for we're dealing with graph structures

01:25:58,429 --> 01:26:05,620
it's very nice but internally and even

01:26:02,780 --> 01:26:09,140
in terms of its interface it's very C++

01:26:05,620 --> 01:26:12,429
so the challenge then is how do you go

01:26:09,140 --> 01:26:15,350
about taking something like that and

01:26:12,429 --> 01:26:18,440
presumably adding something to it that

01:26:15,350 --> 01:26:21,350
then makes it compatible with something

01:26:18,440 --> 01:26:24,230
like module or or even even somewhat

01:26:21,350 --> 01:26:26,719
lower-level RCPD code and ends up with

01:26:24,230 --> 01:26:28,429
something with a few hooks that our

01:26:26,719 --> 01:26:31,429
programmer can deal with now in the

01:26:28,429 --> 01:26:33,679
existing code of course is done by pages

01:26:31,429 --> 01:26:36,080
and pages of C code and pages and pages

01:26:33,679 --> 01:26:37,820
of our code you guys have a way of I

01:26:36,080 --> 01:26:39,710
think getting around a lot of that but

01:26:37,820 --> 01:26:43,370
it's getting from here to there seem

01:26:39,710 --> 01:26:45,860
still to be quite difficult yeah that's

01:26:43,370 --> 01:26:49,670
a that's a great and relevant question I

01:26:45,860 --> 01:26:52,969
mean I am I recall that I think in in in

01:26:49,670 --> 01:26:55,670
soda you also review the gbn code which

01:26:52,969 --> 01:26:57,800
is sort of you know pretty nice C++ code

01:26:55,670 --> 01:27:00,110
that all existed even though it had to

01:26:57,800 --> 01:27:02,360
do protect and uppercase macros and all

01:27:00,110 --> 01:27:04,760
the Eglinton you know ugliness is bad

01:27:02,360 --> 01:27:07,640
but Greg Greg did ages ago it's really

01:27:04,760 --> 01:27:09,679
good code Torsten Horne has some

01:27:07,640 --> 01:27:11,330
fantastic code you know for his tree

01:27:09,679 --> 01:27:13,340
base of stuff it's also filters that's

01:27:11,330 --> 01:27:15,610
sort of there we haven't really thought

01:27:13,340 --> 01:27:19,180
about boost

01:27:15,610 --> 01:27:20,890
we did think about QT I liked QT and you

01:27:19,180 --> 01:27:23,200
know depay in and Michael have done a

01:27:20,890 --> 01:27:25,330
lot of work sort of redoing some of the

01:27:23,200 --> 01:27:29,440
graphical infrastructure that say in in

01:27:25,330 --> 01:27:32,590
G go be in and have possibly answers to

01:27:29,440 --> 01:27:35,290
finally having dynamic you know graphics

01:27:32,590 --> 01:27:36,790
devices in on sort of all that it's yeah

01:27:35,290 --> 01:27:38,350
it's not clear because if there's a lot

01:27:36,790 --> 01:27:40,690
of baggage and a lot of head splitting

01:27:38,350 --> 01:27:42,940
and a lot of you know trips for romaine

01:27:40,690 --> 01:27:45,880
to the pharmacy to get more volume and

01:27:42,940 --> 01:27:48,850
in Tylenol and it's yeah not not not

01:27:45,880 --> 01:27:51,520
clear because at the end of the day the

01:27:48,850 --> 01:27:53,410
you may remember this that that back

01:27:51,520 --> 01:27:55,330
when Borland was still sort of a market

01:27:53,410 --> 01:27:56,860
reigning compiler I think the expression

01:27:55,330 --> 01:27:58,750
was that there's five people on the

01:27:56,860 --> 01:28:00,910
planet who can write a C++ compiler you

01:27:58,750 --> 01:28:02,800
know and the language is there I I

01:28:00,910 --> 01:28:04,270
sometimes joke that the language now is

01:28:02,800 --> 01:28:05,860
no longer the language I learned twenty

01:28:04,270 --> 01:28:07,330
years ago which is why I'm beg you zhing

01:28:05,860 --> 01:28:09,580
it because it's rich and it's changing

01:28:07,330 --> 01:28:10,960
but it's it's Mike Myers calls it sort

01:28:09,580 --> 01:28:13,210
of four different facets there are so

01:28:10,960 --> 01:28:14,980
many different ones to support that you

01:28:13,210 --> 01:28:17,620
know going out boldly and claiming that

01:28:14,980 --> 01:28:19,060
you can do all of them you know we can I

01:28:17,620 --> 01:28:21,760
mean we sort of do that part-time here

01:28:19,060 --> 01:28:23,260
so I mean it's just it's a great

01:28:21,760 --> 01:28:25,240
initiative and I think it should get

01:28:23,260 --> 01:28:26,860
tackled but we may need a plan and help

01:28:25,240 --> 01:28:30,130
I think it's sort of it's sort of doable

01:28:26,860 --> 01:28:31,990
but some of the staff boost which is a

01:28:30,130 --> 01:28:35,320
good example it's fantastic it's rich

01:28:31,990 --> 01:28:38,260
it's peer-reviewed it's fast but lots of

01:28:35,320 --> 01:28:39,940
interdependencies and and lots of you

01:28:38,260 --> 01:28:41,560
know coding baggage and intricacies

01:28:39,940 --> 01:28:44,530
which which you can't really with a

01:28:41,560 --> 01:28:46,450
scalpel take out so it's great question

01:28:44,530 --> 01:28:50,350
great challenge maybe we will meet it I

01:28:46,450 --> 01:28:55,140
don't know yet I I don't really have

01:28:50,350 --> 01:28:55,140
much to add to to what Dirk said but the

01:28:55,590 --> 01:29:02,950
what tends to happen is that we've done

01:29:00,310 --> 01:29:05,280
this with a few with a few library as

01:29:02,950 --> 01:29:09,340
we've shown we done armadillo with on

01:29:05,280 --> 01:29:13,090
GSL sort of making wrappers around these

01:29:09,340 --> 01:29:15,640
libraries so that did yeah so that so

01:29:13,090 --> 01:29:18,490
that they sort of talk to our CBP and

01:29:15,640 --> 01:29:21,490
then talk to our we there's there's no

01:29:18,490 --> 01:29:24,610
real recipe and every time we do it it

01:29:21,490 --> 01:29:25,739
is sort of changed what we do in our CBP

01:29:24,610 --> 01:29:30,390
itself

01:29:25,739 --> 01:29:34,860
and we we try to embed this information

01:29:30,390 --> 01:29:36,780
in a vignette but you know with with a

01:29:34,860 --> 01:29:40,700
new library you'll have different

01:29:36,780 --> 01:29:45,989
challenges and that there's no real

01:29:40,700 --> 01:29:49,530
recipe there adds yeah this is sort of

01:29:45,989 --> 01:29:57,750
what I had to say about this any anyone

01:29:49,530 --> 01:29:59,670
else Oh John again so I think there's

01:29:57,750 --> 01:30:02,040
some chance I might repeat John's

01:29:59,670 --> 01:30:03,630
question but I want to repeat it in a

01:30:02,040 --> 01:30:06,780
different context and maybe it's a

01:30:03,630 --> 01:30:09,780
different question I don't know so let's

01:30:06,780 --> 01:30:11,610
suppose I've got a C++ library and I've

01:30:09,780 --> 01:30:13,050
got an object and you know we can call

01:30:11,610 --> 01:30:16,500
it a foo or we can call it maybe a

01:30:13,050 --> 01:30:19,230
capital M model right and I've got

01:30:16,500 --> 01:30:21,600
another object and its capital D data

01:30:19,230 --> 01:30:23,600
right and maybe these are abstract

01:30:21,600 --> 01:30:25,950
classes or something or maybe there's

01:30:23,600 --> 01:30:31,050
actual instantiations of them in

01:30:25,950 --> 01:30:33,630
concrete classes if I use your objects

01:30:31,050 --> 01:30:35,910
framework and instantiate a model kind

01:30:33,630 --> 01:30:39,630
of swig it or whatever boost Python it

01:30:35,910 --> 01:30:43,350
into R and then I have a data can the R

01:30:39,630 --> 01:30:46,560
version of the model construct itself

01:30:43,350 --> 01:30:48,690
using the R version of the data do the

01:30:46,560 --> 01:30:50,190
different do you sort of you have to

01:30:48,690 --> 01:30:51,930
assume that all these things are

01:30:50,190 --> 01:30:54,030
freestanding things and they're only

01:30:51,930 --> 01:30:56,730
going to operate on ants and doubles or

01:30:54,030 --> 01:30:59,280
once you've instead two different things

01:30:56,730 --> 01:31:01,170
that play together nicely in C++ do they

01:30:59,280 --> 01:31:03,719
continue to play together nicely once

01:31:01,170 --> 01:31:06,120
they're in our well there really is

01:31:03,719 --> 01:31:08,940
nothing in the outside the outside only

01:31:06,120 --> 01:31:13,550
holds pointer to the internal data

01:31:08,940 --> 01:31:16,080
structure so I love to say yes this hmm

01:31:13,550 --> 01:31:19,020
yes it would work yes definitely

01:31:16,080 --> 01:31:21,930
obviously I didn't try it on this

01:31:19,020 --> 01:31:25,140
particular example so my word is as good

01:31:21,930 --> 01:31:27,930
as no but I'd have to say that yes it

01:31:25,140 --> 01:31:32,460
would would work because what's on the

01:31:27,930 --> 01:31:35,239
outside is really just plumbing to to

01:31:32,460 --> 01:31:39,539
let you access methods and fields so

01:31:35,239 --> 01:31:42,750
yeah the you only really have a pointer

01:31:39,539 --> 01:31:45,090
other than a few no I really agree I

01:31:42,750 --> 01:31:47,219
think for as long as it's compatible and

01:31:45,090 --> 01:31:49,079
linkable it happens because that just

01:31:47,219 --> 01:31:52,110
means that you know the unit's come

01:31:49,079 --> 01:31:57,900
busting the C++ code generate what it's

01:31:52,110 --> 01:32:00,329
needed to to run it the way this started

01:31:57,900 --> 01:32:02,789
a long time ago was I used to call this

01:32:00,329 --> 01:32:04,590
sort of vertical you know I I had had a

01:32:02,789 --> 01:32:06,269
prompt in I wanted to get something done

01:32:04,590 --> 01:32:09,090
that wasn't C++ so I just wrote

01:32:06,269 --> 01:32:10,559
accessors and returned us and we're much

01:32:09,090 --> 01:32:12,900
richer now and you know it sometimes

01:32:10,559 --> 01:32:14,489
call that horizontal it's not the

01:32:12,900 --> 01:32:15,840
greatest metaphor but but now it sort of

01:32:14,489 --> 01:32:17,699
goes this way and that's sort of where

01:32:15,840 --> 01:32:19,320
you coming can you sort of come in here

01:32:17,699 --> 01:32:20,940
somewhere and come out on the other side

01:32:19,320 --> 01:32:23,489
and at the end of the day we're still

01:32:20,940 --> 01:32:25,440
building you know a single program so if

01:32:23,489 --> 01:32:26,730
something allows us to compile and Link

01:32:25,440 --> 01:32:29,150
this together then then it should be

01:32:26,730 --> 01:32:29,150

YouTube URL: https://www.youtube.com/watch?v=UZkaZhsOfT4


