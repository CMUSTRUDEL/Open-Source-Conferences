Title: OSS Speaker Series - Java on Guice: Dependency Injection,...
Publication date: 2010-10-27
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talks
June 5, 2007

ABSTRACT



Guice is a new open-source dependency-injection framework for Java 5. It's small, fast, and typesafe. It doesn't require you to write XML, and it is already in use in several Google projects. Come learn how Guice can help make your applications simpler and easier to test.  Credits: Speaker:Bob Lee
Captions: 
	00:00:26,240 --> 00:00:32,630
hi everyone welcome to the open source

00:00:29,750 --> 00:00:34,160
developers at Google speaker series my

00:00:32,630 --> 00:00:37,930
name is Kevin Burrell ian and bob lee

00:00:34,160 --> 00:00:40,820
and i built this framework called juice

00:00:37,930 --> 00:00:42,980
by which I mean Bob did most of it and I

00:00:40,820 --> 00:00:44,900
helped and so it's my pleasure to

00:00:42,980 --> 00:00:46,370
introduce Bob to you who's going to talk

00:00:44,900 --> 00:00:50,720
about the Jews dependency injection

00:00:46,370 --> 00:00:52,900
framework and that's about it lovely is

00:00:50,720 --> 00:00:57,050
this thing on can everybody hear me ok

00:00:52,900 --> 00:01:01,909
ok I started it but Kevin made it what

00:00:57,050 --> 00:01:03,530
it is today so today I'm going to tell

00:01:01,909 --> 00:01:04,820
you about juice I'm gonna start off

00:01:03,530 --> 00:01:06,260
telling you about dependency injection

00:01:04,820 --> 00:01:09,020
in general and we're going to get into

00:01:06,260 --> 00:01:12,350
how you can use juice to make dependency

00:01:09,020 --> 00:01:14,180
injection even easier why are we here

00:01:12,350 --> 00:01:16,909
why are we even interested in dependency

00:01:14,180 --> 00:01:19,760
injection and juice specifically the

00:01:16,909 --> 00:01:22,070
main reason is to make unit testing easy

00:01:19,760 --> 00:01:25,010
easier so makes a unit test easier to

00:01:22,070 --> 00:01:26,570
write less friction kind of a secondary

00:01:25,010 --> 00:01:29,150
reason is you can use this to get some

00:01:26,570 --> 00:01:31,219
more decoupling in your code if you want

00:01:29,150 --> 00:01:35,539
to break down your code into compile

00:01:31,219 --> 00:01:36,859
time independent modules juice not

00:01:35,539 --> 00:01:38,990
necessarily dependency injection in

00:01:36,859 --> 00:01:41,479
general juice can help you write less

00:01:38,990 --> 00:01:44,240
boilerplate code which I personally love

00:01:41,479 --> 00:01:45,740
I mean a lot of times we write this same

00:01:44,240 --> 00:01:47,600
code over and over again we re implement

00:01:45,740 --> 00:01:49,130
these same design patterns without even

00:01:47,600 --> 00:01:50,359
realizing we're doing it our eyes it's

00:01:49,130 --> 00:01:52,909
kind of glazed over and we don't see the

00:01:50,359 --> 00:01:54,469
code anymore and then I guess kind of

00:01:52,909 --> 00:01:56,990
the overarching theme here is going to

00:01:54,469 --> 00:01:59,600
be getting better maintainability so

00:01:56,990 --> 00:02:02,329
juice was built for what I consider a

00:01:59,600 --> 00:02:05,869
huge project millions of lines hundreds

00:02:02,329 --> 00:02:09,920
of mott developers code going back as

00:02:05,869 --> 00:02:11,540
long as and longer than five years so

00:02:09,920 --> 00:02:13,640
maintain abilities of the utmost concern

00:02:11,540 --> 00:02:17,780
I mean you write the code once people

00:02:13,640 --> 00:02:20,420
read it thousands of times the way I

00:02:17,780 --> 00:02:21,830
like to explain dependency injection and

00:02:20,420 --> 00:02:25,640
pretty much any programming topic is

00:02:21,830 --> 00:02:27,170
through code examples so we're gonna I'm

00:02:25,640 --> 00:02:30,560
going to start off with a very simple

00:02:27,170 --> 00:02:31,880
example unbelievably simple but just

00:02:30,560 --> 00:02:33,980
enough to kind of illustrate the

00:02:31,880 --> 00:02:35,270
concepts this is going to be a

00:02:33,980 --> 00:02:37,760
high-level designed for our example

00:02:35,270 --> 00:02:39,500
we're going to have these are this is

00:02:37,760 --> 00:02:43,130
just kind of like a class diagram

00:02:39,500 --> 00:02:44,210
we have the kind of central concept that

00:02:43,130 --> 00:02:45,950
central thing we're going to be worrying

00:02:44,210 --> 00:02:47,710
about through this example is a class

00:02:45,950 --> 00:02:50,690
will call client could be anything and

00:02:47,710 --> 00:02:52,490
we're going to be testing client as you

00:02:50,690 --> 00:02:54,530
can see by we have our client test over

00:02:52,490 --> 00:02:56,510
here and clients going to have a

00:02:54,530 --> 00:02:58,340
dependency on an interface will call

00:02:56,510 --> 00:02:59,810
service and we'll have one

00:02:58,340 --> 00:03:02,780
implementation of service which will

00:02:59,810 --> 00:03:03,860
call service simple pretty simple we

00:03:02,780 --> 00:03:05,209
don't really care what these things do

00:03:03,860 --> 00:03:08,840
we just care that about the fact that we

00:03:05,209 --> 00:03:11,510
have a dependency I'm going to take

00:03:08,840 --> 00:03:13,790
three approaches whenever we're three

00:03:11,510 --> 00:03:14,930
approaches to solving this problem the

00:03:13,790 --> 00:03:15,800
first one I'm going to start off with

00:03:14,930 --> 00:03:17,959
it's something where I'm sure

00:03:15,800 --> 00:03:20,360
everybody's familiar with the factory

00:03:17,959 --> 00:03:21,980
pattern the second one i'm going to show

00:03:20,360 --> 00:03:23,780
you is dependency injection by hand

00:03:21,980 --> 00:03:25,550
dependency injection is this kind of a

00:03:23,780 --> 00:03:27,350
variation of the factory pattern the way

00:03:25,550 --> 00:03:29,780
i look at it you don't necessarily need

00:03:27,350 --> 00:03:31,310
a framework and the third example is

00:03:29,780 --> 00:03:33,680
going to be dependency injection with

00:03:31,310 --> 00:03:35,360
juice i'm going to show you how juice

00:03:33,680 --> 00:03:37,760
benefits you over doing dependency

00:03:35,360 --> 00:03:39,260
injection by hand and for those of you

00:03:37,760 --> 00:03:40,910
that don't know what dependency

00:03:39,260 --> 00:03:43,040
injection is you're going to find out

00:03:40,910 --> 00:03:44,720
and for those of you that do i promise

00:03:43,040 --> 00:03:45,890
you won't be too bored because it's kind

00:03:44,720 --> 00:03:50,930
of fun to take a step back and examine

00:03:45,890 --> 00:03:52,580
what we know and identify exactly where

00:03:50,930 --> 00:03:55,940
and how and how much dependency

00:03:52,580 --> 00:03:57,830
injection helps your code so throughout

00:03:55,940 --> 00:03:59,420
this example well as we go down these

00:03:57,830 --> 00:04:02,570
three paths we're going to have one

00:03:59,420 --> 00:04:04,070
variable and that's going to be one

00:04:02,570 --> 00:04:06,049
thing that's going to change that's

00:04:04,070 --> 00:04:08,329
going to be how client gets access to an

00:04:06,049 --> 00:04:09,709
instance of service and then a couple

00:04:08,329 --> 00:04:10,850
things are going to stay the same we're

00:04:09,709 --> 00:04:12,799
going to have like I said we have this

00:04:10,850 --> 00:04:14,690
service interface we're going to have a

00:04:12,799 --> 00:04:15,799
single implementation of service we

00:04:14,690 --> 00:04:17,750
don't really care what this interface

00:04:15,799 --> 00:04:20,359
looks like or what the implementation

00:04:17,750 --> 00:04:22,010
does for the purposes of this purpose is

00:04:20,359 --> 00:04:23,900
of this example but let's just assume

00:04:22,010 --> 00:04:24,890
that it's something expensive or

00:04:23,900 --> 00:04:26,810
something we don't want to do during

00:04:24,890 --> 00:04:28,280
tests right like it could be like

00:04:26,810 --> 00:04:29,690
charging a credit card we don't want to

00:04:28,280 --> 00:04:32,390
charge a credit card or send off emails

00:04:29,690 --> 00:04:34,610
during our unit tests right so within

00:04:32,390 --> 00:04:36,440
that respect we're going to have a mock

00:04:34,610 --> 00:04:38,810
implementation of service that we can

00:04:36,440 --> 00:04:41,960
swap in for unit tests and that's pretty

00:04:38,810 --> 00:04:43,160
much what we're going to do so the first

00:04:41,960 --> 00:04:45,890
approach we're going to take a look at

00:04:43,160 --> 00:04:48,140
is using the factory pattern so here's

00:04:45,890 --> 00:04:51,110
our implementation a client like I said

00:04:48,140 --> 00:04:52,860
this is stupid simple and the way client

00:04:51,110 --> 00:04:58,020
gets access to a fat

00:04:52,860 --> 00:04:59,370
service using this approach is via a

00:04:58,020 --> 00:05:00,419
service factory and in this case we're

00:04:59,370 --> 00:05:01,949
just kinda like a static we're just

00:05:00,419 --> 00:05:03,270
going to call out to a static method and

00:05:01,949 --> 00:05:05,099
we'll call that our factory method and

00:05:03,270 --> 00:05:10,169
then client does what it needs to do

00:05:05,099 --> 00:05:11,669
with service and to support this we need

00:05:10,169 --> 00:05:13,199
to write this service factory and this

00:05:11,669 --> 00:05:15,210
is kind of what I was talking about when

00:05:13,199 --> 00:05:17,129
I mentioned boilerplate code we all

00:05:15,210 --> 00:05:18,960
right this same factory code over and

00:05:17,129 --> 00:05:20,879
over again we have to make this upfront

00:05:18,960 --> 00:05:23,129
decision whether we just want to new up

00:05:20,879 --> 00:05:24,689
an instance of service and defend

00:05:23,129 --> 00:05:25,830
directly on the concrete class or

00:05:24,689 --> 00:05:28,020
whether we want to go through the pain

00:05:25,830 --> 00:05:31,289
of the coupling client from service

00:05:28,020 --> 00:05:33,360
using factory in this case I just wrote

00:05:31,289 --> 00:05:35,250
the code to implement a singleton I mean

00:05:33,360 --> 00:05:37,080
I'm sure we all follows pattern hundreds

00:05:35,250 --> 00:05:39,900
of times you know you might write some

00:05:37,080 --> 00:05:42,180
lazy loading code or you know if this

00:05:39,900 --> 00:05:46,740
wasn't a singleton you this code might

00:05:42,180 --> 00:05:48,779
be a little more complex and so as you

00:05:46,740 --> 00:05:50,699
can see here we have this is the client

00:05:48,779 --> 00:05:52,139
that this is the method that the client

00:05:50,699 --> 00:05:54,360
used we have this kid instance method

00:05:52,139 --> 00:05:56,370
this is what clients used to get access

00:05:54,360 --> 00:05:59,069
to our service and I guess the main

00:05:56,370 --> 00:06:01,229
point of this is that client doesn't

00:05:59,069 --> 00:06:02,879
depend directly on the service

00:06:01,229 --> 00:06:06,690
implementation anymore at least he

00:06:02,879 --> 00:06:07,860
doesn't seem too so all client knows

00:06:06,690 --> 00:06:10,379
about his service it doesn't know about

00:06:07,860 --> 00:06:12,810
the actual concrete implementation and

00:06:10,379 --> 00:06:15,930
then if we want to be able to test this

00:06:12,810 --> 00:06:17,789
thing or test things that run against

00:06:15,930 --> 00:06:18,750
sir this service factory we need to be

00:06:17,789 --> 00:06:20,430
able to swap in an alternate

00:06:18,750 --> 00:06:22,169
implementation so that's what this final

00:06:20,430 --> 00:06:27,569
method this set instance method down

00:06:22,169 --> 00:06:29,879
here allows us to do so this is the

00:06:27,569 --> 00:06:31,949
thing we're going to be most interested

00:06:29,879 --> 00:06:36,150
in throughout these examples and that's

00:06:31,949 --> 00:06:39,599
the unit test so as you can see in this

00:06:36,150 --> 00:06:41,699
unit test we so let's look at the middle

00:06:39,599 --> 00:06:43,949
part first we're creating a mock

00:06:41,699 --> 00:06:46,139
instance of service and we're passing

00:06:43,949 --> 00:06:48,449
that into the factory then we're running

00:06:46,139 --> 00:06:50,939
client and then we're testing that

00:06:48,449 --> 00:06:52,740
client did what we expected it to do and

00:06:50,939 --> 00:06:57,509
this kind of like outside stuff up here

00:06:52,740 --> 00:06:59,339
is us kind of saving off the previous

00:06:57,509 --> 00:07:01,680
state of the factory and then restoring

00:06:59,339 --> 00:07:04,919
it at the end and does anybody know why

00:07:01,680 --> 00:07:06,270
we do that why we have to restore the

00:07:04,919 --> 00:07:08,630
factory to its previous state at the end

00:07:06,270 --> 00:07:08,630
of our test

00:07:09,440 --> 00:07:14,760
there you go so you don't break other

00:07:11,610 --> 00:07:17,430
tests and by that we mean many of us

00:07:14,760 --> 00:07:18,870
have run into that situation where you

00:07:17,430 --> 00:07:20,190
run your tests in one order and they all

00:07:18,870 --> 00:07:21,920
pass or you run your tests in a

00:07:20,190 --> 00:07:24,210
different order and they fail because

00:07:21,920 --> 00:07:26,460
maybe a test that rain after this picks

00:07:24,210 --> 00:07:27,630
up our mock implementation well that's

00:07:26,460 --> 00:07:36,060
not the case since we're cleaning up in

00:07:27,630 --> 00:07:38,010
a finally block I'm sorry so you just

00:07:36,060 --> 00:07:39,570
made another great point what if we have

00:07:38,010 --> 00:07:41,880
a test running concurrently on another

00:07:39,570 --> 00:07:43,110
thread yes these two tests would step on

00:07:41,880 --> 00:07:48,300
each other that's another reason the

00:07:43,110 --> 00:07:50,250
factory pattern sex um so I already

00:07:48,300 --> 00:07:52,050
pointed out that so what are the

00:07:50,250 --> 00:07:53,700
consequences or the observations that we

00:07:52,050 --> 00:07:55,650
can make about using the factory pattern

00:07:53,700 --> 00:07:58,169
here I already pointed out that we have

00:07:55,650 --> 00:07:59,669
to kind of set up and make sure we clean

00:07:58,169 --> 00:08:01,320
up at the end and if we forget to clean

00:07:59,669 --> 00:08:02,340
up once then we can get mysterious test

00:08:01,320 --> 00:08:05,400
failures and those are really hard to

00:08:02,340 --> 00:08:08,400
track down one of the things that kind

00:08:05,400 --> 00:08:10,320
of strikes me is that when we're setting

00:08:08,400 --> 00:08:12,479
out to test client well in this case

00:08:10,320 --> 00:08:14,100
it's simple then it's it's easy to know

00:08:12,479 --> 00:08:16,530
that we need to swap in an

00:08:14,100 --> 00:08:19,169
implementation of service because the

00:08:16,530 --> 00:08:21,300
client implementations so simple but

00:08:19,169 --> 00:08:22,800
it's not always that simple right you

00:08:21,300 --> 00:08:24,540
know it's our dependency on service

00:08:22,800 --> 00:08:27,810
might have been nested like ten levels

00:08:24,540 --> 00:08:29,460
deep at our implementation and we'd have

00:08:27,810 --> 00:08:32,010
no way of really knowing that we needed

00:08:29,460 --> 00:08:33,870
to swap that in and I guess kind of the

00:08:32,010 --> 00:08:35,849
consequence of that is you end up having

00:08:33,870 --> 00:08:37,740
slow unit tests because you have random

00:08:35,849 --> 00:08:39,330
code out accessing remote servers and

00:08:37,740 --> 00:08:40,650
slowing things down hitting databases

00:08:39,330 --> 00:08:44,280
and that sort of thing and it's really

00:08:40,650 --> 00:08:45,839
hard to track those things down and so I

00:08:44,280 --> 00:08:48,270
guess the crux of that is the only way

00:08:45,839 --> 00:08:49,620
we can know from our test that client

00:08:48,270 --> 00:08:53,220
depends on service is by digging through

00:08:49,620 --> 00:08:56,550
the implementation reusing client

00:08:53,220 --> 00:08:58,920
different contexts is difficult so as

00:08:56,550 --> 00:09:01,500
someone pointed out using it from

00:08:58,920 --> 00:09:04,200
different threads we can't we can't use

00:09:01,500 --> 00:09:07,400
different service implementations from

00:09:04,200 --> 00:09:11,790
two different threats or if we want to

00:09:07,400 --> 00:09:13,560
just put that if we want to pass in a

00:09:11,790 --> 00:09:15,750
different service implementation to

00:09:13,560 --> 00:09:16,830
client and one part of our application

00:09:15,750 --> 00:09:20,310
and different one into the other one

00:09:16,830 --> 00:09:21,270
it's really tricky we have to

00:09:20,310 --> 00:09:23,580
I already pointed out that we have to

00:09:21,270 --> 00:09:25,170
write that same factory code for every

00:09:23,580 --> 00:09:27,450
dependency and that's a huge pain it

00:09:25,170 --> 00:09:29,190
forces us to make this upfront decision

00:09:27,450 --> 00:09:31,620
whether we want to be tightly coupled or

00:09:29,190 --> 00:09:34,740
loosely coupled and a lot of times the

00:09:31,620 --> 00:09:36,270
thing i don't like about that is that we

00:09:34,740 --> 00:09:37,620
make that we make the decision based on

00:09:36,270 --> 00:09:39,240
the wrong reasons you know we make it

00:09:37,620 --> 00:09:40,680
based on effort when we should make it

00:09:39,240 --> 00:09:43,650
based on whether we want this to be

00:09:40,680 --> 00:09:46,560
tightly coupled or loosely coupled and

00:09:43,650 --> 00:09:48,900
finally we decoupled client from service

00:09:46,560 --> 00:09:52,200
in pull directly but the way this is set

00:09:48,900 --> 00:09:54,839
up is client still depends on service

00:09:52,200 --> 00:09:56,460
simple at compile time because client

00:09:54,839 --> 00:09:58,350
depends on service factory and service

00:09:56,460 --> 00:09:59,760
factory depends on service simple so we

00:09:58,350 --> 00:10:02,130
need to compile everything together and

00:09:59,760 --> 00:10:04,589
we could kind of alleviate that using

00:10:02,130 --> 00:10:07,020
the service locator pattern or something

00:10:04,589 --> 00:10:08,580
like that but the service locator

00:10:07,020 --> 00:10:11,820
pattern has its own problems like for

00:10:08,580 --> 00:10:13,980
example if we were specifying the

00:10:11,820 --> 00:10:17,100
implementation service and a properties

00:10:13,980 --> 00:10:18,870
file or in an XML file well with a lot

00:10:17,100 --> 00:10:20,910
of service locator implementations we

00:10:18,870 --> 00:10:22,830
wouldn't know whether we configured that

00:10:20,910 --> 00:10:24,150
service that implementation properly

00:10:22,830 --> 00:10:26,280
until we want to actually use it and

00:10:24,150 --> 00:10:28,260
that's too late for most times

00:10:26,280 --> 00:10:31,920
considering you have to have like one

00:10:28,260 --> 00:10:33,930
hundred percent covered test coverage so

00:10:31,920 --> 00:10:37,130
now let's look at how things change when

00:10:33,930 --> 00:10:39,980
we follow dependency injection by hand

00:10:37,130 --> 00:10:41,730
so if you remember in the last example

00:10:39,980 --> 00:10:45,540
client just called out to service

00:10:41,730 --> 00:10:47,760
factory well in this example instead of

00:10:45,540 --> 00:10:49,230
calling out somewhere to get its

00:10:47,760 --> 00:10:51,210
dependency client is going to have its

00:10:49,230 --> 00:10:53,550
dependency provided to it and in this

00:10:51,210 --> 00:10:55,140
case we're going to provide service to

00:10:53,550 --> 00:10:56,339
the client through its constructor and

00:10:55,140 --> 00:10:58,830
then client just hold on to that

00:10:56,339 --> 00:11:00,390
dependency and use it as needed and this

00:10:58,830 --> 00:11:02,670
is what we call dependency injection

00:11:00,390 --> 00:11:04,920
that's all that's it it's as simple as

00:11:02,670 --> 00:11:10,320
this a lot of people refer to it as

00:11:04,920 --> 00:11:12,030
don't call me I'll call you so what does

00:11:10,320 --> 00:11:13,320
this do for us well this is the same

00:11:12,030 --> 00:11:16,200
unit test we just looked at a couple

00:11:13,320 --> 00:11:17,550
minutes ago based on the factory design

00:11:16,200 --> 00:11:19,950
pattern and as you can see we have to

00:11:17,550 --> 00:11:21,330
set up we have to save off the previous

00:11:19,950 --> 00:11:23,610
implementation and do all this setup and

00:11:21,330 --> 00:11:24,930
teardown which really sucks well if we

00:11:23,610 --> 00:11:26,550
have this implementation a client where

00:11:24,930 --> 00:11:28,350
we can just pass any service to the

00:11:26,550 --> 00:11:30,150
constructor we can simplify our test

00:11:28,350 --> 00:11:31,230
considerably we can get rid of all that

00:11:30,150 --> 00:11:32,970
code

00:11:31,230 --> 00:11:35,040
we can get rid of this kind of

00:11:32,970 --> 00:11:38,820
dependency on a third party our tests no

00:11:35,040 --> 00:11:42,510
longer worries about about service

00:11:38,820 --> 00:11:45,030
factory it doesn't have to this makes

00:11:42,510 --> 00:11:46,350
the dependency explicit from our test to

00:11:45,030 --> 00:11:49,290
you can't even create a client without

00:11:46,350 --> 00:11:50,790
providing a service right so we're not

00:11:49,290 --> 00:11:52,050
going to pass enough slow service in our

00:11:50,790 --> 00:11:55,440
unit test we're gonna pass on a mac

00:11:52,050 --> 00:11:58,050
version so really this cuts the test

00:11:55,440 --> 00:12:00,750
down to like the minimal amount possible

00:11:58,050 --> 00:12:03,750
the minimal amount necessary and this

00:12:00,750 --> 00:12:05,820
reduces the amount of the amount of

00:12:03,750 --> 00:12:07,770
friction to writing unit tests so people

00:12:05,820 --> 00:12:10,110
are going to do it more often people

00:12:07,770 --> 00:12:14,850
going to have less problems tests are

00:12:10,110 --> 00:12:18,270
more readable so now in the production

00:12:14,850 --> 00:12:19,770
code how does client get a an instance

00:12:18,270 --> 00:12:22,170
of service and the answer to that is

00:12:19,770 --> 00:12:24,690
like I said in the beginning of the talk

00:12:22,170 --> 00:12:25,950
I see the dependency injection pattern

00:12:24,690 --> 00:12:28,650
is just kind of a variation of the

00:12:25,950 --> 00:12:30,510
factory pattern so as we'll see here as

00:12:28,650 --> 00:12:32,370
we can see here we just introduced this

00:12:30,510 --> 00:12:33,870
client factory so now we have that we

00:12:32,370 --> 00:12:35,850
already have the service factory but now

00:12:33,870 --> 00:12:38,040
we have the client factory and instead

00:12:35,850 --> 00:12:39,480
of creating client directly in our

00:12:38,040 --> 00:12:43,410
production code we go through the client

00:12:39,480 --> 00:12:46,110
factory and now just it's really simple

00:12:43,410 --> 00:12:48,660
instead of client depending directly on

00:12:46,110 --> 00:12:51,960
the factory we just move the dependency

00:12:48,660 --> 00:12:56,400
on the factory up into our factory des a

00:12:51,960 --> 00:12:58,440
factory enough times so the idea here is

00:12:56,400 --> 00:13:00,600
that we can have all these nice

00:12:58,440 --> 00:13:02,670
dependency injected business objects

00:13:00,600 --> 00:13:04,920
that are easy to test and then on a

00:13:02,670 --> 00:13:06,840
layer above that we can have all these

00:13:04,920 --> 00:13:08,310
factories and the factories depend on

00:13:06,840 --> 00:13:10,770
each other and they depend on our nice

00:13:08,310 --> 00:13:12,720
business objects but the important thing

00:13:10,770 --> 00:13:14,520
is our business objects are easy to test

00:13:12,720 --> 00:13:18,000
and that's what dependency injection

00:13:14,520 --> 00:13:21,330
does for you so compared to the factory

00:13:18,000 --> 00:13:22,800
pattern the test is a lot simpler we

00:13:21,330 --> 00:13:27,180
don't have to deal with middlemen in

00:13:22,800 --> 00:13:29,730
this case service factory anymore we

00:13:27,180 --> 00:13:32,940
it's painfully clear that client depends

00:13:29,730 --> 00:13:34,110
on service it's it's kind of a we can

00:13:32,940 --> 00:13:36,240
tell that information directly from the

00:13:34,110 --> 00:13:39,630
API now we don't have to deal God crawl

00:13:36,240 --> 00:13:41,340
down into the implementation anymore we

00:13:39,630 --> 00:13:44,819
can use client in multiple different

00:13:41,340 --> 00:13:46,319
contexts somebody mentioned using client

00:13:44,819 --> 00:13:47,759
with different service implementations

00:13:46,319 --> 00:13:49,199
and multiple threats that's trivial to

00:13:47,759 --> 00:13:50,850
do now right I mean we could just new up

00:13:49,199 --> 00:13:51,989
a client pet so that its own service

00:13:50,850 --> 00:13:57,629
instance or service implementation

00:13:51,989 --> 00:13:58,499
instance this is a really big one this

00:13:57,629 --> 00:14:01,350
was one of the reasons i originally

00:13:58,499 --> 00:14:04,289
created juice client no longer depends

00:14:01,350 --> 00:14:06,720
on service in pull at compile time so we

00:14:04,289 --> 00:14:08,639
can actually have compile or client in a

00:14:06,720 --> 00:14:11,369
separate compile time unit from server

00:14:08,639 --> 00:14:13,889
simple so if i wanted to just check out

00:14:11,369 --> 00:14:16,259
client and compile it and run some unit

00:14:13,889 --> 00:14:18,209
tests against it I could do do that

00:14:16,259 --> 00:14:20,699
right so I could take like a big

00:14:18,209 --> 00:14:22,769
monolithic multi-million line app and

00:14:20,699 --> 00:14:24,839
break it down into separate compile time

00:14:22,769 --> 00:14:26,519
units just kind of and then just run

00:14:24,839 --> 00:14:29,459
these faster unit tests on those and

00:14:26,519 --> 00:14:30,869
then when it comes time to like later on

00:14:29,459 --> 00:14:32,939
in the development process I can do

00:14:30,869 --> 00:14:34,410
those bigger slower integration tests

00:14:32,939 --> 00:14:35,910
but the important part is i get this

00:14:34,410 --> 00:14:41,129
quick development turnaround time

00:14:35,910 --> 00:14:42,959
upfront a kind of the downside to do in

00:14:41,129 --> 00:14:44,759
dependency injection by hand is we have

00:14:42,959 --> 00:14:46,319
to write even more factories as you saw

00:14:44,759 --> 00:14:49,379
here we had to even introduce a factory

00:14:46,319 --> 00:14:50,429
where we didn't need one before and that

00:14:49,379 --> 00:14:52,109
means we have to write even more

00:14:50,429 --> 00:14:56,339
boilerplate code even though it's not

00:14:52,109 --> 00:14:57,359
quite very much so this final approach

00:14:56,339 --> 00:14:58,949
we're going to look at is how we can

00:14:57,359 --> 00:15:02,909
take this dependency injection example

00:14:58,949 --> 00:15:04,529
and implement it using juice so why

00:15:02,909 --> 00:15:08,069
would we want to do this as I already

00:15:04,529 --> 00:15:09,569
said writing factories is tedious with

00:15:08,069 --> 00:15:11,549
these simple Singleton's that we've been

00:15:09,569 --> 00:15:13,649
writing I mean it doesn't seem so bad

00:15:11,549 --> 00:15:15,839
but it's I mean it's still pretty bad

00:15:13,649 --> 00:15:19,470
you could generate that code right but

00:15:15,839 --> 00:15:20,489
as you get into dealing with scoping and

00:15:19,470 --> 00:15:22,019
that sort of thing you know it's like

00:15:20,489 --> 00:15:23,249
okay I don't want this to be a singleton

00:15:22,019 --> 00:15:25,379
anymore I want to return a new instance

00:15:23,249 --> 00:15:28,199
every time or I want to return the

00:15:25,379 --> 00:15:29,189
instance from the HD HTTP session or I

00:15:28,199 --> 00:15:30,539
want to return an instance from a

00:15:29,189 --> 00:15:32,850
threadlocal you know it's like you got

00:15:30,539 --> 00:15:36,119
to write that same boilerplate code over

00:15:32,850 --> 00:15:40,079
and over again we want more upfront type

00:15:36,119 --> 00:15:43,169
checking so when our application boots

00:15:40,079 --> 00:15:44,189
up if we forget to kind of configure a

00:15:43,169 --> 00:15:47,850
dependency we want to know about that

00:15:44,189 --> 00:15:48,720
right away as soon as possible which you

00:15:47,850 --> 00:15:49,769
don't get if you're trying to use

00:15:48,720 --> 00:15:57,060
something like the service locator

00:15:49,769 --> 00:16:01,840
pattern we want more flexibility so

00:15:57,060 --> 00:16:03,910
part we want to be able to I guess how

00:16:01,840 --> 00:16:05,590
do I say do more stuff kind of like

00:16:03,910 --> 00:16:07,090
analogous to be able to do reflection in

00:16:05,590 --> 00:16:08,770
Java we want to be able to define

00:16:07,090 --> 00:16:10,690
dependencies automatically and that sort

00:16:08,770 --> 00:16:13,720
of thing so we can cut down coat and do

00:16:10,690 --> 00:16:15,580
some more dynamic things and this is

00:16:13,720 --> 00:16:16,780
kind of this last point is one of the

00:16:15,580 --> 00:16:18,730
biggest things for me is we want to make

00:16:16,780 --> 00:16:20,410
it easy to do the right thing I mean we

00:16:18,730 --> 00:16:21,880
can't we could see the benefits of doing

00:16:20,410 --> 00:16:26,050
dependency injection by hand but the

00:16:21,880 --> 00:16:28,660
truth is if your developers don't really

00:16:26,050 --> 00:16:30,160
kind of get or buy into dependency

00:16:28,660 --> 00:16:31,960
injection I mean it's kind of hard to

00:16:30,160 --> 00:16:33,160
stick with you know the easier thing to

00:16:31,960 --> 00:16:35,410
do is just to kind of hard code the

00:16:33,160 --> 00:16:37,990
dependency in your code right it's not

00:16:35,410 --> 00:16:39,580
easy to remember to limit your

00:16:37,990 --> 00:16:41,970
dependencies to the factory level it's

00:16:39,580 --> 00:16:44,290
it's not it's hard to remember to

00:16:41,970 --> 00:16:45,640
abstract that stuff out well with using

00:16:44,290 --> 00:16:48,910
a framework one of the things you'll see

00:16:45,640 --> 00:16:50,530
is it's easiest to have things injected

00:16:48,910 --> 00:16:52,180
it's almost just as easy to have things

00:16:50,530 --> 00:16:58,980
injected as it is to just knew it up in

00:16:52,180 --> 00:17:02,650
your code so instead of having these

00:16:58,980 --> 00:17:03,820
factory classes in juice and service

00:17:02,650 --> 00:17:07,480
factory and client factory all that

00:17:03,820 --> 00:17:09,610
boilerplate code in juice you configure

00:17:07,480 --> 00:17:11,860
things declaratively so instead of

00:17:09,610 --> 00:17:13,360
having service factory and juice I just

00:17:11,860 --> 00:17:15,730
have this I implement this interface

00:17:13,360 --> 00:17:18,190
called module and this is how i

00:17:15,730 --> 00:17:20,430
configure juice and I I can use this

00:17:18,190 --> 00:17:23,470
what we call a domain-specific language

00:17:20,430 --> 00:17:25,720
to communicate with juice and all that

00:17:23,470 --> 00:17:28,300
basically means is that we have this

00:17:25,720 --> 00:17:31,750
kind of like nice little English spoken

00:17:28,300 --> 00:17:35,440
language sort of thing the that's that's

00:17:31,750 --> 00:17:38,110
very readable and so in this case we

00:17:35,440 --> 00:17:39,880
want to tell juice that whenever you see

00:17:38,110 --> 00:17:41,650
somebody that needs service we want to

00:17:39,880 --> 00:17:43,450
give them a service simple and we want

00:17:41,650 --> 00:17:46,840
it to be a singleton so the way you do

00:17:43,450 --> 00:17:50,470
that is you say bind service to service

00:17:46,840 --> 00:17:52,720
imple in scopes that singleton so we're

00:17:50,470 --> 00:17:55,260
saying bye into the service interface to

00:17:52,720 --> 00:17:58,270
service simple and make it a singleton

00:17:55,260 --> 00:18:01,540
and this replaces all the factory code

00:17:58,270 --> 00:18:05,050
we just had so client changes just a

00:18:01,540 --> 00:18:07,720
little bit from our previous approach we

00:18:05,050 --> 00:18:08,960
have to tell juice where we want things

00:18:07,720 --> 00:18:10,370
to be injected and

00:18:08,960 --> 00:18:12,649
that when we were doing this stuff by

00:18:10,370 --> 00:18:14,419
hand we knew and we call we did the

00:18:12,649 --> 00:18:15,950
injection manually but now we have to be

00:18:14,419 --> 00:18:18,470
able to tell juice where to inject

00:18:15,950 --> 00:18:21,080
things so in the way you do that is you

00:18:18,470 --> 00:18:22,850
use a net inject a notation and you can

00:18:21,080 --> 00:18:24,380
place that on constructors methods or

00:18:22,850 --> 00:18:26,720
fields in this case we're injecting

00:18:24,380 --> 00:18:29,750
constructor so this inject annotation

00:18:26,720 --> 00:18:30,860
tells juice okay when you knew me up an

00:18:29,750 --> 00:18:33,500
instance a client when you create an

00:18:30,860 --> 00:18:36,500
instance a client pass me and

00:18:33,500 --> 00:18:38,779
implementation of service and juice got

00:18:36,500 --> 00:18:40,669
juice looks at our module that we

00:18:38,779 --> 00:18:42,649
configure and it says oh hey client

00:18:40,669 --> 00:18:43,789
needs a service well I'm going to go get

00:18:42,649 --> 00:18:48,159
him a service simple and I'm going to

00:18:43,789 --> 00:18:48,159
reuse this same instance every time yes

00:18:52,419 --> 00:18:56,149
he asked if juice only supports one

00:18:54,590 --> 00:18:57,710
argument or multiple arguments and the

00:18:56,149 --> 00:19:00,110
answer is juice support supports

00:18:57,710 --> 00:19:02,870
multiple arguments so an ordering

00:19:00,110 --> 00:19:04,460
doesn't matter because it matches things

00:19:02,870 --> 00:19:05,960
based on type it looks at service it

00:19:04,460 --> 00:19:07,399
doesn't care work whether it's the first

00:19:05,960 --> 00:19:10,960
argument or the third argument it's

00:19:07,399 --> 00:19:10,960
always going to bind to the same thing

00:19:11,049 --> 00:19:15,289
so our test looks exactly the same as

00:19:14,059 --> 00:19:16,520
when we're doing dependency injection by

00:19:15,289 --> 00:19:18,140
hand and this was kind of our end goal

00:19:16,520 --> 00:19:20,390
we want to make unit testing easy I

00:19:18,140 --> 00:19:22,100
guess kind of the one thing to notice

00:19:20,390 --> 00:19:23,570
here is that we don't use juice in the

00:19:22,100 --> 00:19:25,399
units we don't need to we don't need

00:19:23,570 --> 00:19:27,020
that complexity the simplest possible

00:19:25,399 --> 00:19:32,169
thing is just create our mock can pass

00:19:27,020 --> 00:19:34,820
it directly to client right so

00:19:32,169 --> 00:19:38,120
conclusions based on this simple

00:19:34,820 --> 00:19:41,029
unrealistic example even in this little

00:19:38,120 --> 00:19:42,440
example juice melted away like twenty

00:19:41,029 --> 00:19:44,779
percent of the boilerplate code and

00:19:42,440 --> 00:19:47,419
that's over the initial example with a

00:19:44,779 --> 00:19:50,450
more concise example because we didn't

00:19:47,419 --> 00:19:52,429
have to write all that factory code and

00:19:50,450 --> 00:19:54,380
one of the really nice things about

00:19:52,429 --> 00:19:57,200
juice especially compared to other

00:19:54,380 --> 00:19:59,240
frameworks and this approach to using of

00:19:57,200 --> 00:20:04,100
using annotations for dependency

00:19:59,240 --> 00:20:05,779
injection is that we already saved that

00:20:04,100 --> 00:20:07,850
twenty percent in this little example

00:20:05,779 --> 00:20:10,250
but we're juice really shines is the

00:20:07,850 --> 00:20:12,020
more you use your dependencies so you're

00:20:10,250 --> 00:20:15,020
not going to go to all this effort just

00:20:12,020 --> 00:20:16,640
to use a dependency once right I mean

00:20:15,020 --> 00:20:18,950
some dependencies we use hundreds and

00:20:16,640 --> 00:20:20,720
hundreds of times so but each of those

00:20:18,950 --> 00:20:22,310
times now the only thing you have to do

00:20:20,720 --> 00:20:24,920
is put at inject on your

00:20:22,310 --> 00:20:26,060
and take service so you don't have to go

00:20:24,920 --> 00:20:28,760
and set up the module anymore or

00:20:26,060 --> 00:20:30,350
anything like that so a lot of times

00:20:28,760 --> 00:20:32,780
you're dependent if in a application

00:20:30,350 --> 00:20:35,890
your dependencies are already set up so

00:20:32,780 --> 00:20:38,600
you don't have to worry about it so much

00:20:35,890 --> 00:20:41,900
we get more startup checks over using a

00:20:38,600 --> 00:20:43,280
service locator so one of the things

00:20:41,900 --> 00:20:45,170
that's really nice about juice in

00:20:43,280 --> 00:20:49,130
particular is kind of the quality of its

00:20:45,170 --> 00:20:50,660
error messages so if you're missing if

00:20:49,130 --> 00:20:53,060
you're missing a dependency like for

00:20:50,660 --> 00:20:55,130
example if we didn't bind something to

00:20:53,060 --> 00:20:56,630
service juice would fail right away it

00:20:55,130 --> 00:20:59,390
start up before running any of your code

00:20:56,630 --> 00:21:00,650
and it would tell you that client

00:20:59,390 --> 00:21:02,380
depends on service and it would even

00:21:00,650 --> 00:21:04,550
give you the line number so your IDE can

00:21:02,380 --> 00:21:08,420
link it in your log and you can click

00:21:04,550 --> 00:21:10,910
and jump right to it jus supports this

00:21:08,420 --> 00:21:12,770
notion of declarative scopes and what I

00:21:10,910 --> 00:21:14,780
mean by that is remember in our binding

00:21:12,770 --> 00:21:17,090
we said okay this is in singleton scope

00:21:14,780 --> 00:21:20,270
we only want one instance of this for

00:21:17,090 --> 00:21:22,880
our application and you can implement

00:21:20,270 --> 00:21:24,560
your own scopes using juice it already

00:21:22,880 --> 00:21:26,630
comes with scopes for handling servlet

00:21:24,560 --> 00:21:30,200
code which will we'll get into that a

00:21:26,630 --> 00:21:32,690
little more we have a lot of flexibility

00:21:30,200 --> 00:21:34,730
here so you could imagine that I mean

00:21:32,690 --> 00:21:36,830
we're this is just a Java API so you can

00:21:34,730 --> 00:21:39,650
write special code to create your

00:21:36,830 --> 00:21:41,360
bindings however you want right you

00:21:39,650 --> 00:21:42,920
could loop through a list of interfaces

00:21:41,360 --> 00:21:44,720
and automatically create bindings for

00:21:42,920 --> 00:21:47,300
all those right imagine like your data

00:21:44,720 --> 00:21:48,920
access objects if you're able to if you

00:21:47,300 --> 00:21:50,300
just had data access object interfaces

00:21:48,920 --> 00:21:51,860
and you're able to generate hibernating

00:21:50,300 --> 00:21:54,980
implementations for those some people do

00:21:51,860 --> 00:21:57,800
this sort of thing and I guess like my

00:21:54,980 --> 00:22:00,140
favorite part is just this makes that

00:21:57,800 --> 00:22:01,760
gives us makes for easier up front

00:22:00,140 --> 00:22:03,650
design decisions whereas before we had

00:22:01,760 --> 00:22:05,150
to decide whether we wanted to new up

00:22:03,650 --> 00:22:08,300
the class directly and have this

00:22:05,150 --> 00:22:09,530
concrete concrete dependency or if we

00:22:08,300 --> 00:22:12,380
wanted to write all this factory code

00:22:09,530 --> 00:22:14,690
well now it's just as easy to just have

00:22:12,380 --> 00:22:20,090
the concrete class injected to begin

00:22:14,690 --> 00:22:23,060
with so it's like so client depends on

00:22:20,090 --> 00:22:24,740
service we could start off with service

00:22:23,060 --> 00:22:26,780
just being a concrete class to begin

00:22:24,740 --> 00:22:27,890
with and client doesn't care right it

00:22:26,780 --> 00:22:29,690
doesn't care if it's an interface or

00:22:27,890 --> 00:22:31,460
concrete class then when we come by

00:22:29,690 --> 00:22:33,740
later and decide to abstract out an

00:22:31,460 --> 00:22:35,810
interface from service well we just do

00:22:33,740 --> 00:22:37,850
that and client doesn't have to change

00:22:35,810 --> 00:22:39,050
so we changed we make our change in one

00:22:37,850 --> 00:22:43,130
place and none of the clients have to

00:22:39,050 --> 00:22:46,250
change so that's it makes it easy to do

00:22:43,130 --> 00:22:48,590
the right thing so now that we're all oh

00:22:46,250 --> 00:22:58,940
we have another question feel free to

00:22:48,590 --> 00:23:00,200
interrupt me at any time please um so

00:22:58,940 --> 00:23:02,000
we'll actually we'll get into that right

00:23:00,200 --> 00:23:03,710
now he he asked a question about a

00:23:02,000 --> 00:23:09,560
inject so you're wondering how juice

00:23:03,710 --> 00:23:11,930
knows to inject that or okay so this is

00:23:09,560 --> 00:23:13,310
a I'm sorry about that I kind of jumped

00:23:11,930 --> 00:23:16,190
ahead a little too much so he's asking

00:23:13,310 --> 00:23:18,230
about this at inject here so one of the

00:23:16,190 --> 00:23:20,330
main reasons i created juice when I did

00:23:18,230 --> 00:23:22,040
I started a little over a year ago was

00:23:20,330 --> 00:23:24,140
because Java five was had been around

00:23:22,040 --> 00:23:26,360
and none of the other frameworks really

00:23:24,140 --> 00:23:27,800
took advantage of that one of the things

00:23:26,360 --> 00:23:29,960
that were introduced in Java five were

00:23:27,800 --> 00:23:32,330
annotations and that's what this is this

00:23:29,960 --> 00:23:35,870
is basically just kind of type safe

00:23:32,330 --> 00:23:38,720
metadata that you can attach two methods

00:23:35,870 --> 00:23:42,380
fields classes whatever you want and so

00:23:38,720 --> 00:23:43,790
at runtime juice can look at this client

00:23:42,380 --> 00:23:46,900
class and see that there's an inject a

00:23:43,790 --> 00:23:53,360
notation on here and no to inject that

00:23:46,900 --> 00:23:56,680
yes it's actually so he asked how this

00:23:53,360 --> 00:23:59,540
compares to seen juice is actually

00:23:56,680 --> 00:24:00,650
similar and a lot of ways to seem we're

00:23:59,540 --> 00:24:02,480
going to see some ways where it's really

00:24:00,650 --> 00:24:08,360
different seem is a great framework to

00:24:02,480 --> 00:24:10,340
and I'm actually on a ASR called web

00:24:08,360 --> 00:24:12,620
beans with Gavin king who created the

00:24:10,340 --> 00:24:15,890
scene project and we're combining juice

00:24:12,620 --> 00:24:18,860
and scene for web beans so we're gonna

00:24:15,890 --> 00:24:21,170
it's actually there's happens to be very

00:24:18,860 --> 00:24:24,650
little overlap between the two but you

00:24:21,170 --> 00:24:26,270
need both the way we look at it so if

00:24:24,650 --> 00:24:27,590
you're interested in this stuff and

00:24:26,270 --> 00:24:28,820
you're interested in the future you

00:24:27,590 --> 00:24:30,950
don't want to depend on a proprietary

00:24:28,820 --> 00:24:32,330
framework right now then introduced you

00:24:30,950 --> 00:24:36,740
to or I encourage you to keep an eye on

00:24:32,330 --> 00:24:38,990
the web beans API but there's definitely

00:24:36,740 --> 00:24:42,620
a lot of synergy between semen juice

00:24:38,990 --> 00:24:46,100
right now I'm sorry about that I jumped

00:24:42,620 --> 00:24:48,679
ahead too far so now that we're sold on

00:24:46,100 --> 00:24:49,850
the virtues of dependency injection

00:24:48,679 --> 00:24:54,259
going to show you how to get started

00:24:49,850 --> 00:24:56,330
with juice and sold on juice so what is

00:24:54,259 --> 00:24:59,330
a basic juice application look like we

00:24:56,330 --> 00:25:00,769
looked at that simple example but we

00:24:59,330 --> 00:25:02,929
kind of we left a little bit out it's

00:25:00,769 --> 00:25:04,850
like how does juice create an incense a

00:25:02,929 --> 00:25:06,759
client for us right well so that's what

00:25:04,850 --> 00:25:09,649
we're going to look at right here I

00:25:06,759 --> 00:25:14,809
guess kind of the central object in

00:25:09,649 --> 00:25:16,340
juice it's called the injector this

00:25:14,809 --> 00:25:17,960
other frameworks might call this like a

00:25:16,340 --> 00:25:20,559
container or something like that but the

00:25:17,960 --> 00:25:24,019
injector is what creates our objects and

00:25:20,559 --> 00:25:26,299
so if we wanted to use juice to create

00:25:24,019 --> 00:25:28,309
an instance of client we just ask juice

00:25:26,299 --> 00:25:30,139
to create the injector we pass at our

00:25:28,309 --> 00:25:31,669
module this is the same module from our

00:25:30,139 --> 00:25:34,639
example you know the modulus says buying

00:25:31,669 --> 00:25:36,169
service to serve a simple so we pass

00:25:34,639 --> 00:25:37,999
juice the module and then it gives us

00:25:36,169 --> 00:25:39,619
back an injector and you can pass it any

00:25:37,999 --> 00:25:42,049
number of modules you want and the

00:25:39,619 --> 00:25:44,509
modules can all be independent then we

00:25:42,049 --> 00:25:47,269
take that injector and we ask juice we

00:25:44,509 --> 00:25:48,590
say get instance of client class and

00:25:47,269 --> 00:25:50,419
juice will give us an instance a client

00:25:48,590 --> 00:25:52,190
it'll call that constructor inject

00:25:50,419 --> 00:25:54,289
whatever client needs and give it back

00:25:52,190 --> 00:25:56,119
to us in this case we didn't need an

00:25:54,289 --> 00:25:58,279
explicit binding for client because

00:25:56,119 --> 00:26:00,860
clients a concrete class and juice knows

00:25:58,279 --> 00:26:02,450
how to create it if client was an inner

00:26:00,860 --> 00:26:05,090
week also passed you said interface here

00:26:02,450 --> 00:26:08,210
but we need to tell it what's bound to

00:26:05,090 --> 00:26:10,279
that interface somewhere and then we can

00:26:08,210 --> 00:26:13,490
just call in this case we just call

00:26:10,279 --> 00:26:15,259
client go in a real world application

00:26:13,490 --> 00:26:16,610
say this was like the command line

00:26:15,259 --> 00:26:19,279
application this would be kind of like

00:26:16,610 --> 00:26:21,799
our this would be our main method look

00:26:19,279 --> 00:26:25,850
very much like this this was a web

00:26:21,799 --> 00:26:27,470
application and you like to have a

00:26:25,850 --> 00:26:29,149
direct control of your servlet container

00:26:27,470 --> 00:26:30,830
you might have juice create your servlet

00:26:29,149 --> 00:26:33,230
container and then call start on your

00:26:30,830 --> 00:26:36,350
servlet container here there's also ways

00:26:33,230 --> 00:26:38,210
to wire web applications that a little

00:26:36,350 --> 00:26:44,840
more you just kind of drop them in and

00:26:38,210 --> 00:26:49,220
use them so one thing I want to kind of

00:26:44,840 --> 00:26:51,200
point out here is that what kind of

00:26:49,220 --> 00:26:55,380
situation would we have if we always ask

00:26:51,200 --> 00:26:57,270
the injector for our objects

00:26:55,380 --> 00:26:59,820
we wouldn't have dependency injection

00:26:57,270 --> 00:27:02,940
we'd have a service locator right which

00:26:59,820 --> 00:27:04,740
is what we're trying to avoid so that's

00:27:02,940 --> 00:27:06,810
where this idea of like to call this

00:27:04,740 --> 00:27:09,360
bootstrapping so this is really the only

00:27:06,810 --> 00:27:10,560
time that we're gonna ideally this is

00:27:09,360 --> 00:27:12,840
the only time that we're going to deal

00:27:10,560 --> 00:27:15,740
directly with injector is in this kind

00:27:12,840 --> 00:27:17,760
of bootstrapping code right here and

00:27:15,740 --> 00:27:19,320
this is kind of one of the things that

00:27:17,760 --> 00:27:20,490
are really cool about dependency

00:27:19,320 --> 00:27:22,050
injection and this was kind of like an

00:27:20,490 --> 00:27:25,890
aha moment for me whenever I started

00:27:22,050 --> 00:27:28,230
using it was so we used juice to create

00:27:25,890 --> 00:27:30,270
in a sense a client and then juice

00:27:28,230 --> 00:27:32,610
creates objects to inject into client

00:27:30,270 --> 00:27:35,130
and then it juice has to create those

00:27:32,610 --> 00:27:37,050
objects too and then so juice creates

00:27:35,130 --> 00:27:38,730
objects to inject into those you kind of

00:27:37,050 --> 00:27:41,460
have this recursive object graph that

00:27:38,730 --> 00:27:43,170
juice can create well we only depend on

00:27:41,460 --> 00:27:45,300
injector here we only ask it to create

00:27:43,170 --> 00:27:46,980
client but from that root object juice

00:27:45,300 --> 00:27:50,070
can construct our entire object graph

00:27:46,980 --> 00:27:52,050
and then from our perspective all of our

00:27:50,070 --> 00:27:53,310
code is nice clean and unit testable

00:27:52,050 --> 00:27:55,170
right we have these nice you know

00:27:53,310 --> 00:27:57,210
testable business objects that just

00:27:55,170 --> 00:27:59,700
depend on interfaces and whatnot and

00:27:57,210 --> 00:28:00,930
then we have these really simple modules

00:27:59,700 --> 00:28:04,980
where we just kind of describe the

00:28:00,930 --> 00:28:06,330
dependencies so juice gets rid of all

00:28:04,980 --> 00:28:12,020
that boilerplate code makes things

00:28:06,330 --> 00:28:12,020
easier to test and that's how it does it

00:28:14,510 --> 00:28:19,560
so we asked if this means that our

00:28:17,700 --> 00:28:21,810
entire object graph is created at

00:28:19,560 --> 00:28:26,130
startup and the answer to that is no

00:28:21,810 --> 00:28:28,650
juice does provide ways to delay object

00:28:26,130 --> 00:28:31,410
creation and I'll definitely get into

00:28:28,650 --> 00:28:34,920
that so you kind of lazily create

00:28:31,410 --> 00:28:37,350
objects as you want to so Kevin be kind

00:28:34,920 --> 00:28:40,740
of so the idea here is one thing I kind

00:28:37,350 --> 00:28:42,510
of want you to note is that for an

00:28:40,740 --> 00:28:45,120
object to be injected juice has to

00:28:42,510 --> 00:28:46,470
create it right Kevin be calls us into

00:28:45,120 --> 00:28:48,840
Club the objects have to be in the club

00:28:46,470 --> 00:28:53,940
and so if you see new in your code

00:28:48,840 --> 00:28:55,920
that's kind of bad so let's say we want

00:28:53,940 --> 00:28:58,010
to introduce a new dependency based on

00:28:55,920 --> 00:29:01,170
kind of like this idea is talking about

00:28:58,010 --> 00:29:02,970
bootstrapping well let's say service we

00:29:01,170 --> 00:29:04,890
want to add some emailing capabilities

00:29:02,970 --> 00:29:06,280
to our server simple all we have to do

00:29:04,890 --> 00:29:09,230
there is

00:29:06,280 --> 00:29:12,440
first we have we have to create our

00:29:09,230 --> 00:29:13,400
emailer and this could be in this case

00:29:12,440 --> 00:29:17,600
we're just going to make email our

00:29:13,400 --> 00:29:19,520
concrete class and in serve a simple we

00:29:17,600 --> 00:29:20,540
can create a field for email or in this

00:29:19,520 --> 00:29:22,100
case we're going to use field because

00:29:20,540 --> 00:29:24,170
he's method or constructor injection and

00:29:22,100 --> 00:29:25,340
we put at inject on that field so now

00:29:24,170 --> 00:29:27,650
whenever juice goes to create an

00:29:25,340 --> 00:29:29,270
instance a service simple so that it can

00:29:27,650 --> 00:29:31,309
jected into client it's going to create

00:29:29,270 --> 00:29:34,309
an instance of emailer and then inject

00:29:31,309 --> 00:29:35,570
it into service simple so notice we

00:29:34,309 --> 00:29:38,929
didn't have to deal with the injector at

00:29:35,570 --> 00:29:41,660
all directly here so then service simple

00:29:38,929 --> 00:29:42,799
at the end it's going to its so it's

00:29:41,660 --> 00:29:44,150
going to do whatever it was doing before

00:29:42,799 --> 00:29:45,530
and then is going to send a confirmation

00:29:44,150 --> 00:29:49,490
at the end using the email or that we

00:29:45,530 --> 00:29:52,610
injected so there's some situations

00:29:49,490 --> 00:29:55,160
where so far what we've seen we've had

00:29:52,610 --> 00:29:57,470
one implementation / type there's going

00:29:55,160 --> 00:29:58,640
to be other situations where our

00:29:57,470 --> 00:29:59,419
applications a little more complex we're

00:29:58,640 --> 00:30:02,960
going to have multiple implementations

00:29:59,419 --> 00:30:05,270
of the same type so hypothetically we

00:30:02,960 --> 00:30:06,980
might have our regular email or and we

00:30:05,270 --> 00:30:07,910
might have a transactional emailer and

00:30:06,980 --> 00:30:09,650
why the heck would we want to

00:30:07,910 --> 00:30:12,320
transactional you Miller well let's say

00:30:09,650 --> 00:30:13,549
we're processing orders you don't want

00:30:12,320 --> 00:30:15,470
your order to go through if you didn't

00:30:13,549 --> 00:30:16,700
send the client or receipt right if you

00:30:15,470 --> 00:30:19,400
know if you didn't validate the email

00:30:16,700 --> 00:30:22,400
address and that sort of thing and you

00:30:19,400 --> 00:30:23,600
don't want the receipt to go out if you

00:30:22,400 --> 00:30:24,500
didn't actually process the order so

00:30:23,600 --> 00:30:28,070
we're going to we're going to need a

00:30:24,500 --> 00:30:29,510
transactional email or in this case this

00:30:28,070 --> 00:30:32,059
is kind of one of the big innovations

00:30:29,510 --> 00:30:33,950
juice dust compared to seem and some

00:30:32,059 --> 00:30:37,750
other frameworks a lot of frameworks you

00:30:33,950 --> 00:30:41,720
might have seen rely on string tokens to

00:30:37,750 --> 00:30:44,929
identify the dependencies juice uses

00:30:41,720 --> 00:30:47,840
this idea of binding annotations and so

00:30:44,929 --> 00:30:50,410
in addition to saying at jecht emailer

00:30:47,840 --> 00:30:53,210
well now we're going to say at inject at

00:30:50,410 --> 00:30:54,650
transactional email and juice is going

00:30:53,210 --> 00:30:56,299
to look at this and say oh you know you

00:30:54,650 --> 00:30:59,720
need a transactional emailer and it's

00:30:56,299 --> 00:31:01,040
the idea here is that the eat the thing

00:30:59,720 --> 00:31:02,960
that's going to identify this dependency

00:31:01,040 --> 00:31:05,720
is it's an emailer and it's

00:31:02,960 --> 00:31:08,600
transactional so the way we can figure

00:31:05,720 --> 00:31:13,160
this in our module is we say bind

00:31:08,600 --> 00:31:14,690
emailer annotated with transactional to

00:31:13,160 --> 00:31:16,910
transactional email or transactional

00:31:14,690 --> 00:31:18,480
emailers our implementation everybody

00:31:16,910 --> 00:31:24,030
follow that

00:31:18,480 --> 00:31:25,980
so the transactional so yes if

00:31:24,030 --> 00:31:28,080
transactional comes with juice and the

00:31:25,980 --> 00:31:29,760
answer is no juice does come with some

00:31:28,080 --> 00:31:31,740
by Nady annotations but you can just

00:31:29,760 --> 00:31:34,140
define these things on your own you

00:31:31,740 --> 00:31:35,640
don't have to create one every time you

00:31:34,140 --> 00:31:38,040
have two implementations of something

00:31:35,640 --> 00:31:40,380
your annotation your binding annotations

00:31:38,040 --> 00:31:41,549
can be kind of general and reusable like

00:31:40,380 --> 00:31:43,020
this is transactional we can use

00:31:41,549 --> 00:31:45,419
transactional with an email or we can

00:31:43,020 --> 00:31:49,620
use it with a service we can use it with

00:31:45,419 --> 00:31:51,210
a database connection whatever right and

00:31:49,620 --> 00:31:54,380
that's from our experience we find that

00:31:51,210 --> 00:31:56,970
that's all from the case yep this is a

00:31:54,380 --> 00:31:59,220
yes that this is an empty annotation and

00:31:56,970 --> 00:32:02,070
yes this is like a marker annotation it

00:31:59,220 --> 00:32:05,970
doesn't really in this case it's a mark

00:32:02,070 --> 00:32:08,190
or annotation but in reality juice also

00:32:05,970 --> 00:32:09,929
supports you can have attribute values

00:32:08,190 --> 00:32:11,460
on these annotations to so that saves

00:32:09,929 --> 00:32:13,559
you from having to create new

00:32:11,460 --> 00:32:15,450
annotations all the time also like you

00:32:13,559 --> 00:32:17,549
can have one a notation and you can kind

00:32:15,450 --> 00:32:18,929
of get have like a string value and pass

00:32:17,549 --> 00:32:22,980
it to it or that sort of thing so you

00:32:18,929 --> 00:32:27,740
can reuse it that way so and this is

00:32:22,980 --> 00:32:29,669
actually an example of that so in

00:32:27,740 --> 00:32:32,370
addition to having multiple

00:32:29,669 --> 00:32:35,990
implementations of the things sometimes

00:32:32,370 --> 00:32:35,990
we need to get another question

00:32:40,370 --> 00:32:53,100
does the name of the annotation does it

00:32:47,370 --> 00:32:55,470
match the annotation class name um no so

00:32:53,100 --> 00:32:56,880
he asked if the annotation class name

00:32:55,470 --> 00:33:05,070
has to be the same as the implementation

00:32:56,880 --> 00:33:06,750
class name Oh pointed out that i forgot

00:33:05,070 --> 00:33:08,610
to see right here sorry about that so

00:33:06,750 --> 00:33:11,640
yes this would have to be the same as

00:33:08,610 --> 00:33:12,600
that okay and you'll get that's one of

00:33:11,640 --> 00:33:14,220
the nice things about you so you'll get

00:33:12,600 --> 00:33:15,090
a compile-time error actually you

00:33:14,220 --> 00:33:17,010
wouldn't make that mistake because

00:33:15,090 --> 00:33:22,530
you're a tu an autocomplete keynote

00:33:17,010 --> 00:33:24,270
doesn't auto complete so sometimes so we

00:33:22,530 --> 00:33:26,520
just looked at the example where you

00:33:24,270 --> 00:33:28,830
have multiple concrete implementations

00:33:26,520 --> 00:33:31,080
of a single interface well sometimes

00:33:28,830 --> 00:33:33,720
you're dealing with third-party code

00:33:31,080 --> 00:33:34,710
where you can't apply at inject or you

00:33:33,720 --> 00:33:36,840
know you just have some code where it

00:33:34,710 --> 00:33:39,360
wouldn't make sense and you need to

00:33:36,840 --> 00:33:40,410
create these out or maybe you can't let

00:33:39,360 --> 00:33:41,640
juice create the objects maybe they're

00:33:40,410 --> 00:33:45,980
already created you don't have control

00:33:41,640 --> 00:33:47,910
of that so you need to have some way of

00:33:45,980 --> 00:33:50,580
you still want to be able to inject

00:33:47,910 --> 00:33:53,180
these things into other classes right so

00:33:50,580 --> 00:33:55,830
here's an example of that let's say we

00:33:53,180 --> 00:33:57,120
couldn't that we couldn't let juice

00:33:55,830 --> 00:33:59,940
create an instance of emailer and we

00:33:57,120 --> 00:34:02,100
wanted to create it ourselves so that's

00:33:59,940 --> 00:34:04,110
where juice provides this interface

00:34:02,100 --> 00:34:05,970
called provider and all provider is a

00:34:04,110 --> 00:34:08,429
simple interface with a get method that

00:34:05,970 --> 00:34:12,360
returns an object it's as simple as that

00:34:08,429 --> 00:34:13,740
and to tell juice that you want to write

00:34:12,360 --> 00:34:15,179
a custom provider in this case we're

00:34:13,740 --> 00:34:18,899
going to provide an instance of emailer

00:34:15,179 --> 00:34:20,610
you just say bind emailer to provider

00:34:18,899 --> 00:34:24,360
and you give it a provider of emailer

00:34:20,610 --> 00:34:26,429
and kind of the nice thing about this is

00:34:24,360 --> 00:34:30,020
that even though we can't inject email

00:34:26,429 --> 00:34:32,940
or directly we can inject our provider

00:34:30,020 --> 00:34:35,220
so we can inject our provider and in

00:34:32,940 --> 00:34:37,139
this case we're going to inject the name

00:34:35,220 --> 00:34:38,940
of the email host like the email server

00:34:37,139 --> 00:34:43,139
name and then we can take those values

00:34:38,940 --> 00:34:46,560
and pass them on to the class so the

00:34:43,139 --> 00:34:48,300
interesting thing here is that service

00:34:46,560 --> 00:34:49,770
info wouldn't have to change it doesn't

00:34:48,300 --> 00:34:51,000
care whether juice is creating emailer

00:34:49,770 --> 00:34:52,470
or whether

00:34:51,000 --> 00:34:54,750
we are creating it manually in our

00:34:52,470 --> 00:34:58,350
custom provider it doesn't matter it's

00:34:54,750 --> 00:35:01,590
completely decoupled a couple things to

00:34:58,350 --> 00:35:03,300
note here one more here's one thing that

00:35:01,590 --> 00:35:06,780
scopes can still apply to your custom

00:35:03,300 --> 00:35:09,060
providers so even though I want a email

00:35:06,780 --> 00:35:10,380
or to be a singleton I still don't have

00:35:09,060 --> 00:35:13,170
to write that boy i'll create plate code

00:35:10,380 --> 00:35:16,080
in my custom factory right i can apply i

00:35:13,170 --> 00:35:19,560
can still apply this same scope to my

00:35:16,080 --> 00:35:22,560
cusin provider and then this gentleman

00:35:19,560 --> 00:35:23,760
here asked about whether binding

00:35:22,560 --> 00:35:25,200
annotations always had to be up mark or

00:35:23,760 --> 00:35:26,880
interpretations and this is an example

00:35:25,200 --> 00:35:28,470
of when it doesn't have to be juice

00:35:26,880 --> 00:35:30,990
comes with this annotation called at

00:35:28,470 --> 00:35:32,280
named and this is an annotation you can

00:35:30,990 --> 00:35:33,660
use if you don't want to create a custom

00:35:32,280 --> 00:35:36,720
annotation all the time if you just want

00:35:33,660 --> 00:35:40,680
to kind of refer back and use string

00:35:36,720 --> 00:35:42,210
names to identify your things and so you

00:35:40,680 --> 00:35:45,710
can kind of see here will you add named

00:35:42,210 --> 00:35:45,710
and then we just have emailed that host

00:35:46,010 --> 00:35:50,460
so i kind of i touched on scopes i'm

00:35:49,530 --> 00:35:53,670
just kind of go into a little more

00:35:50,460 --> 00:35:56,340
detail on that the definition of a scope

00:35:53,670 --> 00:35:59,100
is it's a policy for reusing objects by

00:35:56,340 --> 00:36:00,720
default juice uses no scope for your

00:35:59,100 --> 00:36:02,340
objects and that basically means that it

00:36:00,720 --> 00:36:04,230
creates a new instance every time passes

00:36:02,340 --> 00:36:06,750
in a new instance every time which makes

00:36:04,230 --> 00:36:09,690
things very kind of keeps your object

00:36:06,750 --> 00:36:13,140
separate and makes it next in object

00:36:09,690 --> 00:36:17,700
oriented there's two ways to specify a

00:36:13,140 --> 00:36:20,250
scope for a given binding kind of the my

00:36:17,700 --> 00:36:22,080
preferred way is to use an annotation

00:36:20,250 --> 00:36:24,390
that's this example down here so if we

00:36:22,080 --> 00:36:26,670
wanted to tell juice that emailer is

00:36:24,390 --> 00:36:30,330
always a singleton you can just put at

00:36:26,670 --> 00:36:31,650
singleton on email and you can define

00:36:30,330 --> 00:36:34,260
your own annotations like this for your

00:36:31,650 --> 00:36:37,220
custom scope so if you were using juices

00:36:34,260 --> 00:36:39,690
serve up module you could say at each

00:36:37,220 --> 00:36:40,980
request scoped and that would tell juice

00:36:39,690 --> 00:36:42,630
that you want it to be stored on the

00:36:40,980 --> 00:36:45,390
request and just we just automatically

00:36:42,630 --> 00:36:46,740
do that for you sometimes it doesn't

00:36:45,390 --> 00:36:48,150
work like i said in cases where you have

00:36:46,740 --> 00:36:51,030
like a custom provider and juice can't

00:36:48,150 --> 00:36:55,230
doesn't create your classes or if it in

00:36:51,030 --> 00:36:58,290
those cases you can specify the scope in

00:36:55,230 --> 00:36:59,670
the module so even if email is a

00:36:58,290 --> 00:37:01,560
concrete class like it is here you can

00:36:59,670 --> 00:37:04,910
just say bind email or in session scope

00:37:01,560 --> 00:37:04,910
and juice will do that for you

00:37:05,850 --> 00:37:12,130
alright so somebody asks a little

00:37:08,980 --> 00:37:13,660
earlier in the talk whether whenever we

00:37:12,130 --> 00:37:14,950
do that initial bootstrapping is just

00:37:13,660 --> 00:37:17,320
going to create all my objects and

00:37:14,950 --> 00:37:19,600
construct my entire object graph and the

00:37:17,320 --> 00:37:21,840
answer to that is no and it's for this

00:37:19,600 --> 00:37:25,030
reason right here you can for any type

00:37:21,840 --> 00:37:26,710
foo you can also inject a provider of

00:37:25,030 --> 00:37:28,450
foo and this is just the same interface

00:37:26,710 --> 00:37:30,100
just reused here the same interface we

00:37:28,450 --> 00:37:31,530
used to provide objects to juice juice

00:37:30,100 --> 00:37:35,110
is going to use to provide objects to us

00:37:31,530 --> 00:37:37,450
so in this example I'm just instead of

00:37:35,110 --> 00:37:39,010
injecting money directly injecting a

00:37:37,450 --> 00:37:41,410
provider of money and as you can see

00:37:39,010 --> 00:37:42,850
here we can call get and get two

00:37:41,410 --> 00:37:44,680
instances from that provider instead of

00:37:42,850 --> 00:37:46,000
heaven you know normally juice would

00:37:44,680 --> 00:37:48,010
only inject one instance well in this

00:37:46,000 --> 00:37:51,490
case we can get two instances out so

00:37:48,010 --> 00:37:52,660
there's a few cases for using injecting

00:37:51,490 --> 00:37:56,440
a provider instead of the object

00:37:52,660 --> 00:37:58,750
directly and those cases are one if you

00:37:56,440 --> 00:38:00,130
want to get multiple instances like this

00:37:58,750 --> 00:38:02,260
you know normally juice only would

00:38:00,130 --> 00:38:03,970
inject one instance directly a second

00:38:02,260 --> 00:38:06,040
one is if you don't necessarily want to

00:38:03,970 --> 00:38:07,840
create an object maybe you have multiple

00:38:06,040 --> 00:38:09,730
dependencies that you may or may not

00:38:07,840 --> 00:38:10,870
need and you don't want juice to be

00:38:09,730 --> 00:38:12,430
creating all these objects that you're

00:38:10,870 --> 00:38:14,020
not going to use so you can inject the

00:38:12,430 --> 00:38:16,120
provider and then kind of like lazily

00:38:14,020 --> 00:38:18,970
ask juice for that object only whip if

00:38:16,120 --> 00:38:21,730
you need it and then the third reason is

00:38:18,970 --> 00:38:23,920
a what what I kind of call transcending

00:38:21,730 --> 00:38:25,150
scopes so you know sometimes you might

00:38:23,920 --> 00:38:26,980
want to be able to access a request

00:38:25,150 --> 00:38:29,620
scoped object from a session scoped

00:38:26,980 --> 00:38:32,320
object right but session scope is bigger

00:38:29,620 --> 00:38:34,360
so if you just injected a request scoped

00:38:32,320 --> 00:38:35,530
object into a session scoped object well

00:38:34,360 --> 00:38:37,030
you wouldn't you would hold on to that

00:38:35,530 --> 00:38:39,670
object from the first request the entire

00:38:37,030 --> 00:38:42,130
time right and you'd be out of scope of

00:38:39,670 --> 00:38:43,780
the original request well so instead of

00:38:42,130 --> 00:38:46,060
doing that you can inject a provider of

00:38:43,780 --> 00:38:47,860
that object and then the session scoped

00:38:46,060 --> 00:38:50,800
object can just ask it what it needs it

00:38:47,860 --> 00:38:52,630
so and then a juice will behind the

00:38:50,800 --> 00:38:55,420
scenes so we can just ask for it says it

00:38:52,630 --> 00:38:57,070
can say provider get me this give me

00:38:55,420 --> 00:38:58,270
this request scoped object and juice

00:38:57,070 --> 00:38:59,710
will just dynamically in the background

00:38:58,270 --> 00:39:02,010
look up the object from the current

00:38:59,710 --> 00:39:02,010
request

00:39:03,230 --> 00:39:07,960
I mentioned that juice supports

00:39:06,290 --> 00:39:10,340
constructor method and field injection

00:39:07,960 --> 00:39:12,950
let's kind of talk about the pros and

00:39:10,340 --> 00:39:14,930
cons of beef my personal favorite is

00:39:12,950 --> 00:39:16,310
constructor injection and it's because I

00:39:14,930 --> 00:39:18,440
like to make everything immutable that

00:39:16,310 --> 00:39:20,090
makes thread safety easy makes your code

00:39:18,440 --> 00:39:21,740
nice and maintainable because you can

00:39:20,090 --> 00:39:22,820
see right away that this field can't

00:39:21,740 --> 00:39:24,170
change so you don't have to worry about

00:39:22,820 --> 00:39:25,790
it anymore you know exactly what it's

00:39:24,170 --> 00:39:29,480
going to what what its value is going to

00:39:25,790 --> 00:39:31,280
be but there sometimes when constructor

00:39:29,480 --> 00:39:33,740
injection won't work and that's when

00:39:31,280 --> 00:39:36,320
method injection is a good is a good

00:39:33,740 --> 00:39:39,950
option sometimes I've run into cases

00:39:36,320 --> 00:39:42,290
where I don't want us where somebody

00:39:39,950 --> 00:39:43,970
maybe extends my class and I don't want

00:39:42,290 --> 00:39:46,369
them to know about might have to worry

00:39:43,970 --> 00:39:49,609
about my dependencies and the reason for

00:39:46,369 --> 00:39:51,320
that is as you know if you extend

00:39:49,609 --> 00:39:55,520
somebody's class you have to call their

00:39:51,320 --> 00:39:56,600
constructor right well if if they have

00:39:55,520 --> 00:39:57,920
to call my constructor I think my

00:39:56,600 --> 00:39:59,720
dependencies in the constructor well

00:39:57,920 --> 00:40:00,890
that means my sub class has to be

00:39:59,720 --> 00:40:02,660
responsible for past Mueller's

00:40:00,890 --> 00:40:04,490
dependencies right and if I add a new

00:40:02,660 --> 00:40:06,109
dependency I'm going to have to go

00:40:04,490 --> 00:40:07,970
through and change all my sub classes

00:40:06,109 --> 00:40:09,020
which is kind of contrary to what we're

00:40:07,970 --> 00:40:11,480
trying to accomplish here we want to

00:40:09,020 --> 00:40:13,640
kind of isolate changes so that's where

00:40:11,480 --> 00:40:15,200
method injection is a good option juice

00:40:13,640 --> 00:40:17,090
will just call like your setter method

00:40:15,200 --> 00:40:19,430
or whatever you want your method can be

00:40:17,090 --> 00:40:22,010
named whatever you want without the

00:40:19,430 --> 00:40:23,510
subclass happen to be the wiser another

00:40:22,010 --> 00:40:26,240
case where method injection is good are

00:40:23,510 --> 00:40:28,010
these cases where juice can't create

00:40:26,240 --> 00:40:29,600
your objects so maybe the object already

00:40:28,010 --> 00:40:31,730
exists or it's a third-party object

00:40:29,600 --> 00:40:32,960
something like that or what I guess this

00:40:31,730 --> 00:40:34,609
one work in the third party situation

00:40:32,960 --> 00:40:35,570
but if your object already exists and

00:40:34,609 --> 00:40:37,400
you don't want juice to call your

00:40:35,570 --> 00:40:39,170
constructor you can still ask juice to

00:40:37,400 --> 00:40:40,280
inject your methods and fields obviously

00:40:39,170 --> 00:40:43,160
can't inject the constructor after the

00:40:40,280 --> 00:40:45,380
fact cuz it's already run and the final

00:40:43,160 --> 00:40:48,500
case we have is a field field injection

00:40:45,380 --> 00:40:51,920
and I find that that's good for custom

00:40:48,500 --> 00:40:53,359
providers we saw that BEC here I used

00:40:51,920 --> 00:40:54,770
field injection right here I mean we're

00:40:53,359 --> 00:40:55,970
not really going to unit test this code

00:40:54,770 --> 00:40:57,710
this code will get covered in our

00:40:55,970 --> 00:40:59,290
integration test but we're not gonna

00:40:57,710 --> 00:41:02,930
bother unit testing us so it's ok to use

00:40:59,290 --> 00:41:04,940
field injection here and then the other

00:41:02,930 --> 00:41:07,490
cases slides for your talk because it's

00:41:04,940 --> 00:41:09,280
the most concise and takes a plus we

00:41:07,490 --> 00:41:13,270
space

00:41:09,280 --> 00:41:15,070
alright so I'm just going to talk about

00:41:13,270 --> 00:41:18,340
some more features that we didn't get

00:41:15,070 --> 00:41:20,320
too deeply into that you might want to

00:41:18,340 --> 00:41:24,340
check out after the talk the first one

00:41:20,320 --> 00:41:28,300
is type conversion for constants and so

00:41:24,340 --> 00:41:30,670
this is where you might ask ok I'm hard

00:41:28,300 --> 00:41:32,110
coding all this in Java you know I want

00:41:30,670 --> 00:41:33,880
some of the configuration information to

00:41:32,110 --> 00:41:35,020
be externalized you know like something

00:41:33,880 --> 00:41:36,490
like spring or something like that it

00:41:35,020 --> 00:41:37,210
would be like an XML file right and

00:41:36,490 --> 00:41:39,640
you'll be able to change it without

00:41:37,210 --> 00:41:41,620
recompiling well jus support step 2 and

00:41:39,640 --> 00:41:43,840
a slightly different way we think you

00:41:41,620 --> 00:41:45,220
should only externalize which what

00:41:43,840 --> 00:41:46,390
should be externalized you should only

00:41:45,220 --> 00:41:48,550
externalize the stuff that can actually

00:41:46,390 --> 00:41:49,840
change right you know it makes things a

00:41:48,550 --> 00:41:51,690
little more readable and keeps from

00:41:49,840 --> 00:41:55,180
people from breaking your application

00:41:51,690 --> 00:41:56,860
makes it more usable so juice has some

00:41:55,180 --> 00:41:58,800
support for doing things like you can

00:41:56,860 --> 00:42:01,540
slurp in an entire properties file and

00:41:58,800 --> 00:42:04,030
juice will create bindings for every

00:42:01,540 --> 00:42:06,850
property and the way does it is it

00:42:04,030 --> 00:42:08,950
creates bindings to type string and it

00:42:06,850 --> 00:42:11,470
uses that ain't at named annotation that

00:42:08,950 --> 00:42:15,040
we saw already and it uses the property

00:42:11,470 --> 00:42:17,620
name with that named annotation and so

00:42:15,040 --> 00:42:20,500
this is then this is where the type

00:42:17,620 --> 00:42:21,910
conversion comes in for these types of

00:42:20,500 --> 00:42:24,010
values you don't necessarily just have

00:42:21,910 --> 00:42:25,180
to inject string into your classes juice

00:42:24,010 --> 00:42:27,460
can take that string from your

00:42:25,180 --> 00:42:29,860
properties file and convert it to an int

00:42:27,460 --> 00:42:34,090
convert it to a class convert it to an a

00:42:29,860 --> 00:42:36,250
new moon in teresting one and what's

00:42:34,090 --> 00:42:39,070
really interesting about this is that

00:42:36,250 --> 00:42:40,150
juice does this all at startup because

00:42:39,070 --> 00:42:42,070
you know juice can look at all your

00:42:40,150 --> 00:42:43,630
classes and know that it depends on

00:42:42,070 --> 00:42:45,280
these constants right and it converts

00:42:43,630 --> 00:42:47,410
that value once its startup and if that

00:42:45,280 --> 00:42:49,660
conversion fails juice blows up you know

00:42:47,410 --> 00:42:52,870
and it says hey you know you this value

00:42:49,660 --> 00:42:56,080
forgot to fail or failed to failed to

00:42:52,870 --> 00:42:59,170
convert another feature that juice has

00:42:56,080 --> 00:43:01,870
is I've been a big fan of aop in the

00:42:59,170 --> 00:43:03,970
past but the truth is I even wrote an

00:43:01,870 --> 00:43:06,580
AOP framework which was even one of the

00:43:03,970 --> 00:43:09,190
simpler ones at the time the truth is

00:43:06,580 --> 00:43:12,010
what do most people use aop for applying

00:43:09,190 --> 00:43:14,320
transactions right you know so you just

00:43:12,010 --> 00:43:16,780
put a transactional on your method and

00:43:14,320 --> 00:43:18,180
it tells the framework that you want

00:43:16,780 --> 00:43:20,620
that method to be run in a transaction

00:43:18,180 --> 00:43:23,260
well juice has support for this sort of

00:43:20,620 --> 00:43:24,970
thing and it uses the aop alliance api

00:43:23,260 --> 00:43:26,650
which means you can take like Springs

00:43:24,970 --> 00:43:28,510
transaction interceptor and use it

00:43:26,650 --> 00:43:30,160
directly with juice so and you can just

00:43:28,510 --> 00:43:32,500
apply at transactional your method and

00:43:30,160 --> 00:43:36,040
just like spring just like ejb that map

00:43:32,500 --> 00:43:38,440
that will be run in a transaction juice

00:43:36,040 --> 00:43:40,480
introduces a new concept for I guess

00:43:38,440 --> 00:43:43,600
kind of this class of framework it's

00:43:40,480 --> 00:43:44,770
what we call development stages and so

00:43:43,600 --> 00:43:48,070
one of things I noticed about other

00:43:44,770 --> 00:43:49,480
frameworks were they make you specified

00:43:48,070 --> 00:43:51,790
code in the configuration file whether

00:43:49,480 --> 00:43:53,350
you wanted your objects to be your

00:43:51,790 --> 00:43:58,690
single tends to be lazy loaded or not

00:43:53,350 --> 00:44:00,850
right well to me it depends it's during

00:43:58,690 --> 00:44:02,440
development I want all my Singleton's to

00:44:00,850 --> 00:44:04,660
be lazy or as many of my Singleton's as

00:44:02,440 --> 00:44:07,030
possible to be lazy loaded so that I'm

00:44:04,660 --> 00:44:08,380
only initializing parts of the

00:44:07,030 --> 00:44:09,670
application that I care about the parts

00:44:08,380 --> 00:44:11,590
that I'm working on the parts that I

00:44:09,670 --> 00:44:13,450
want to test so my server starts up as

00:44:11,590 --> 00:44:14,950
fast as possible and I can do my testing

00:44:13,450 --> 00:44:16,500
you know make some changes start it

00:44:14,950 --> 00:44:19,390
again make some changes started again

00:44:16,500 --> 00:44:22,840
whereas in production I want the exact

00:44:19,390 --> 00:44:26,110
opposite I want all my Singleton's to be

00:44:22,840 --> 00:44:28,060
eagerly initialized its start up so that

00:44:26,110 --> 00:44:29,440
I know that whether there's any errors

00:44:28,060 --> 00:44:30,790
whether I missing anything or whether

00:44:29,440 --> 00:44:33,490
you know a single that's going to fail

00:44:30,790 --> 00:44:35,080
to instantiate and so that client my

00:44:33,490 --> 00:44:38,110
first clients that hit my server don't

00:44:35,080 --> 00:44:40,390
pay the performance penalty right so you

00:44:38,110 --> 00:44:41,890
get consistent performance so juice lets

00:44:40,390 --> 00:44:44,530
you specify right now letís specified

00:44:41,890 --> 00:44:46,390
development and production stages and it

00:44:44,530 --> 00:44:48,190
does it has that behavior for

00:44:46,390 --> 00:44:49,510
Singleton's like I just explained but it

00:44:48,190 --> 00:44:51,640
also makes this information available if

00:44:49,510 --> 00:44:52,750
it available to your modules so you can

00:44:51,640 --> 00:44:55,830
write custom code based on whether

00:44:52,750 --> 00:44:55,830
you're running in development production

00:44:57,000 --> 00:45:00,550
so I'm going to kind of glaze over

00:44:59,020 --> 00:45:01,660
optional injection we're not really that

00:45:00,550 --> 00:45:04,920
worried about it's not something to use

00:45:01,660 --> 00:45:07,330
that often but let's just say that a

00:45:04,920 --> 00:45:08,590
juice will fail fast if you're missing a

00:45:07,330 --> 00:45:10,090
dependency so that's one of the things I

00:45:08,590 --> 00:45:13,960
kind of really like that makes it really

00:45:10,090 --> 00:45:15,460
maintainable if you forget to define a

00:45:13,960 --> 00:45:17,520
dependency you know juice is going to

00:45:15,460 --> 00:45:20,920
tell you it's gonna make it very clear

00:45:17,520 --> 00:45:22,090
juice also comes with integration out of

00:45:20,920 --> 00:45:24,880
the box that comes with integration with

00:45:22,090 --> 00:45:27,490
JD I pretty good integration with spring

00:45:24,880 --> 00:45:31,000
the Java management extensions jmx and

00:45:27,490 --> 00:45:32,770
struts to stretch to is kind of one of

00:45:31,000 --> 00:45:34,540
the main reasons it that I created juice

00:45:32,770 --> 00:45:35,500
I was working on stretch too whenever I

00:45:34,540 --> 00:45:36,079
kind of came up with a lot of these

00:45:35,500 --> 00:45:38,959
ideas

00:45:36,079 --> 00:45:40,160
decided on what I want so juice comes

00:45:38,959 --> 00:45:42,589
with a great struts to plug in you just

00:45:40,160 --> 00:45:44,180
drop in your classpath and everybody

00:45:42,589 --> 00:45:45,559
remembers or you might remember when I

00:45:44,180 --> 00:45:47,269
was talking about bootstrapping before

00:45:45,559 --> 00:45:49,759
well the struts two equivalent of

00:45:47,269 --> 00:45:52,609
bootstrapping is that juice injects all

00:45:49,759 --> 00:45:55,759
your actions so instead of whereas with

00:45:52,609 --> 00:45:57,229
struts or web work or struts 2 instead

00:45:55,759 --> 00:45:58,880
of your actions just having these no

00:45:57,229 --> 00:45:59,930
argument constructors well now you can

00:45:58,880 --> 00:46:01,160
take all your dependencies in your

00:45:59,930 --> 00:46:03,380
constructors and actually make use of

00:46:01,160 --> 00:46:08,719
your actions it makes your struts 2

00:46:03,380 --> 00:46:11,930
applications a lot nicer he has someone

00:46:08,719 --> 00:46:15,170
asked if if juice depends on all these

00:46:11,930 --> 00:46:16,519
things and the answer is no so juice is

00:46:15,170 --> 00:46:18,709
broken down into separate modules so you

00:46:16,519 --> 00:46:22,099
can kind of take what you need the jndi

00:46:18,709 --> 00:46:24,469
one is in the core juice because JD isin

00:46:22,099 --> 00:46:25,819
the core jdk already but the spring one

00:46:24,469 --> 00:46:27,140
is just a separate jar that you conclude

00:46:25,819 --> 00:46:29,180
what if you want to use that same with

00:46:27,140 --> 00:46:30,979
the struts to JM x is and the cords are

00:46:29,180 --> 00:46:32,150
else's that's that's one of the kind of

00:46:30,979 --> 00:46:33,890
philosophies and one of the things I'm

00:46:32,150 --> 00:46:37,219
trying to do with juice I want to keep

00:46:33,890 --> 00:46:38,749
it really simple and stick to for the

00:46:37,219 --> 00:46:41,900
most part to pure dependency injection

00:46:38,749 --> 00:46:43,249
and I want to provide the hooks and the

00:46:41,900 --> 00:46:45,079
capability so that other people can

00:46:43,249 --> 00:46:46,219
build third-party frameworks on top of

00:46:45,079 --> 00:46:48,680
juice which people are already doing a

00:46:46,219 --> 00:46:51,170
lot I mean there's already people

00:46:48,680 --> 00:46:54,410
working on hibernate integration dynamic

00:46:51,170 --> 00:46:56,569
web remoting integration you can if you

00:46:54,410 --> 00:46:57,769
join the mailing list you'll see that

00:46:56,569 --> 00:47:00,769
there's a lot of traffic a lot of people

00:46:57,769 --> 00:47:03,430
working on different things give you a

00:47:00,769 --> 00:47:05,719
little taste of some upcoming features

00:47:03,430 --> 00:47:06,829
Kevin and I should be pushing another

00:47:05,719 --> 00:47:10,190
release probably in the next couple

00:47:06,829 --> 00:47:12,829
months one of the things that's kind of

00:47:10,190 --> 00:47:14,749
annoyed me is we looked at that custom

00:47:12,829 --> 00:47:16,489
provider even using an anonymous inner

00:47:14,749 --> 00:47:18,979
class it's kind of a pain right it's

00:47:16,489 --> 00:47:20,029
it's more code than we want to write you

00:47:18,979 --> 00:47:21,619
don't really have to write that code all

00:47:20,029 --> 00:47:23,209
the time that's probably like the maybe

00:47:21,619 --> 00:47:25,180
less than five percent case where you

00:47:23,209 --> 00:47:27,170
have to manually configure your objects

00:47:25,180 --> 00:47:28,339
but in the next release we're going to

00:47:27,170 --> 00:47:30,920
make that even easier you're gonna be

00:47:28,339 --> 00:47:32,269
able to have one class with multiple and

00:47:30,920 --> 00:47:34,249
where you can just have a bunch of

00:47:32,269 --> 00:47:37,849
factory methods we call those provider

00:47:34,249 --> 00:47:39,890
methods and you'll those methods will

00:47:37,849 --> 00:47:41,959
take in their dependencies as parameters

00:47:39,890 --> 00:47:46,950
and then they'll return the thing to be

00:47:41,959 --> 00:47:48,720
injected as a result and

00:47:46,950 --> 00:47:50,339
so that'll definitely they'll cut down

00:47:48,720 --> 00:47:54,210
on a lot of boilerplate there and give

00:47:50,339 --> 00:47:55,589
you really nice nice kind of a nice way

00:47:54,210 --> 00:47:59,160
to configure your objects that sort of

00:47:55,589 --> 00:48:01,079
thing the next one is mixed to automatic

00:47:59,160 --> 00:48:03,540
and cost mixed automatic and custom

00:48:01,079 --> 00:48:04,589
injections so right now in juice you

00:48:03,540 --> 00:48:06,000
have to make this decision you either

00:48:04,589 --> 00:48:08,700
have to let you create your object and

00:48:06,000 --> 00:48:10,859
inject it or you have to configure it

00:48:08,700 --> 00:48:11,970
100% manually well in the next version

00:48:10,859 --> 00:48:15,030
of juice you're going to be able to kind

00:48:11,970 --> 00:48:15,839
of do a little bit of both juice is

00:48:15,030 --> 00:48:18,869
going to be you're going to be able to

00:48:15,839 --> 00:48:20,420
say hey juice inject server simple for

00:48:18,869 --> 00:48:22,740
me and then let me do some kind of like

00:48:20,420 --> 00:48:25,079
post-injection initialization on it

00:48:22,740 --> 00:48:27,119
we're gonna make that really easy in the

00:48:25,079 --> 00:48:28,770
third thing that's going to be really

00:48:27,119 --> 00:48:31,349
important is this idea of construction

00:48:28,770 --> 00:48:33,599
listeners so juice is going to provide a

00:48:31,349 --> 00:48:35,040
hook for you which and you can also do

00:48:33,599 --> 00:48:37,829
your own checking its start up with this

00:48:35,040 --> 00:48:40,650
where you can listen to the creation of

00:48:37,829 --> 00:48:43,200
any objects you want and what that means

00:48:40,650 --> 00:48:45,329
is that if anybody's familiar with like

00:48:43,200 --> 00:48:48,480
ejb3 well you'll be able to implement

00:48:45,329 --> 00:48:50,160
ejb3 on top of juice now because you'll

00:48:48,480 --> 00:48:51,990
be able to write a custom construction

00:48:50,160 --> 00:48:54,000
listener that looks at the objects and

00:48:51,990 --> 00:48:55,619
says oh hey I see aunt resource a

00:48:54,000 --> 00:48:57,089
notation here well I can get my

00:48:55,619 --> 00:48:58,470
dependency out of juice and then pass

00:48:57,089 --> 00:49:00,599
that into that method with that resource

00:48:58,470 --> 00:49:02,790
sanitation and you'll be able to write

00:49:00,599 --> 00:49:04,650
like custom code for like registering

00:49:02,790 --> 00:49:05,760
your objects with listeners and doing

00:49:04,650 --> 00:49:07,230
pretty much whatever you want I mean you

00:49:05,760 --> 00:49:09,990
have your own hook in deck construction

00:49:07,230 --> 00:49:11,400
and it's going to be a general thing too

00:49:09,990 --> 00:49:14,250
so you'll have to repeat that code over

00:49:11,400 --> 00:49:17,460
and over you does anybody have any

00:49:14,250 --> 00:49:27,140
questions or actually I think Michael

00:49:17,460 --> 00:49:27,140
had an announcement right grounded

00:49:28,890 --> 00:49:34,780
so I wrote one of the jump user groups

00:49:31,900 --> 00:49:36,430
meet sear on the 13th any luck I'm going

00:49:34,780 --> 00:49:40,450
to have been here for the Japanese a

00:49:36,430 --> 00:49:41,890
group meeting okay well rest of you want

00:49:40,450 --> 00:49:43,960
to find out about it which is one real

00:49:41,890 --> 00:49:46,150
easy way we have a gallon at project and

00:49:43,960 --> 00:49:47,950
join our manual list or if you want to

00:49:46,150 --> 00:49:51,670
be really easy you can just subscribe to

00:49:47,950 --> 00:49:54,040
the RSS feed you know constellations up

00:49:51,670 --> 00:49:55,000
here and hopefully we'll see you in two

00:49:54,040 --> 00:49:57,490
weeks we actually don't have an

00:49:55,000 --> 00:50:03,280
announcement up yet turn this week this

00:49:57,490 --> 00:50:07,540
month we are cool thank you very much

00:50:03,280 --> 00:50:11,970
two weeks please do week same time same

00:50:07,540 --> 00:50:11,970
place two weeks chubbies distributed

00:50:19,099 --> 00:50:25,160
um so he asked if we have any more

00:50:22,339 --> 00:50:26,450
integration efforts upcoming like I said

00:50:25,160 --> 00:50:29,019
there's some people working on the

00:50:26,450 --> 00:50:32,140
mailing list on various things like

00:50:29,019 --> 00:50:35,150
specifically JPA hibernate integration

00:50:32,140 --> 00:50:36,920
was one of them that I noticed I'm not

00:50:35,150 --> 00:50:38,720
personally working on any integration

00:50:36,920 --> 00:50:40,069
things my goal right now is to implement

00:50:38,720 --> 00:50:41,989
like construction listeners because

00:50:40,069 --> 00:50:43,069
that's going to open the door to a lot

00:50:41,989 --> 00:50:44,599
more integration things like I said

00:50:43,069 --> 00:50:46,130
you're able to implement age 83 on top

00:50:44,599 --> 00:50:52,999
of juice and pretty much anything

00:50:46,130 --> 00:50:55,400
anybody else wants so yes he has how

00:50:52,999 --> 00:50:57,829
many people are using juice our

00:50:55,400 --> 00:50:59,210
downloads are we released it just like

00:50:57,829 --> 00:51:01,670
two months ago now something like that

00:50:59,210 --> 00:51:02,869
our downloads are well over 30,000

00:51:01,670 --> 00:51:04,700
downloads already so we're really

00:51:02,869 --> 00:51:06,589
excited there's a lot of interest the

00:51:04,700 --> 00:51:08,299
mailing list gets regular traffic every

00:51:06,589 --> 00:51:09,650
day so I think it's just going to get

00:51:08,299 --> 00:51:15,229
better like when we released the next

00:51:09,650 --> 00:51:20,180
one will release the next version I'm

00:51:15,229 --> 00:51:22,009
sorry oh yeah yeah we that's the primary

00:51:20,180 --> 00:51:24,950
reason that we develop the juice was for

00:51:22,009 --> 00:51:26,359
unit testing and that that's kind of

00:51:24,950 --> 00:51:28,219
like the main driver behind it is it

00:51:26,359 --> 00:51:31,690
makes your code EG the unit test there's

00:51:28,219 --> 00:51:31,690
any reason to use it that's the reason

00:51:35,769 --> 00:51:40,369
so he said that ejb3 heads dependency

00:51:38,479 --> 00:51:42,170
injection and why would you want to use

00:51:40,369 --> 00:51:43,700
juice well ejb3 has kind of a

00:51:42,170 --> 00:51:45,410
domain-specific version of dependency

00:51:43,700 --> 00:51:48,289
injection with that resource annotation

00:51:45,410 --> 00:51:50,299
and juice implements a more general and

00:51:48,289 --> 00:51:52,519
type safe approach to dependency

00:51:50,299 --> 00:51:57,950
injection and you can actually build

00:51:52,519 --> 00:52:01,009
ejb3 and support its domain specific

00:51:57,950 --> 00:52:03,259
version on top of juice so and actually

00:52:01,009 --> 00:52:06,619
i mentioned web beans really you're on

00:52:03,259 --> 00:52:08,029
and that's an effort where we're kind of

00:52:06,619 --> 00:52:09,469
standardizing on this stuff we're

00:52:08,029 --> 00:52:10,910
pulling in like the best of juice and

00:52:09,469 --> 00:52:12,920
the best of seem and so like from the

00:52:10,910 --> 00:52:14,299
juice world you're going to get like

00:52:12,920 --> 00:52:16,099
these binding annotations and stuff

00:52:14,299 --> 00:52:17,630
which ejb3 doesn't have an equivalent to

00:52:16,099 --> 00:52:18,950
with ejb3 still use like string

00:52:17,630 --> 00:52:20,089
identifier in that sort of thing and

00:52:18,950 --> 00:52:21,859
you're going to have the string

00:52:20,089 --> 00:52:23,719
identifier approach like seeing many jb3

00:52:21,859 --> 00:52:26,390
and that sort of thing and then the idea

00:52:23,719 --> 00:52:27,440
is hopefully with a web beans that web

00:52:26,390 --> 00:52:29,210
means is going to be kind of a generic

00:52:27,440 --> 00:52:30,210
component model it's called web beans

00:52:29,210 --> 00:52:33,119
but it's kind of a missing

00:52:30,210 --> 00:52:34,770
we're going to be more general ejb3

00:52:33,119 --> 00:52:37,980
you'll be able to use web beans as its

00:52:34,770 --> 00:52:39,210
component model and jsf will be able to

00:52:37,980 --> 00:52:40,140
use web beans is its component model so

00:52:39,210 --> 00:52:42,180
you're going to have like these two

00:52:40,140 --> 00:52:44,310
disparate ways of configuring objects

00:52:42,180 --> 00:52:46,290
and creating objects between two

00:52:44,310 --> 00:52:47,430
different specs anymore you can have

00:52:46,290 --> 00:52:57,630
some more it's gonna be a little more

00:52:47,430 --> 00:52:59,220
cohesive yes I'm actually I don't know

00:52:57,630 --> 00:53:01,260
that much about ejb3 but Paul pointed

00:52:59,220 --> 00:53:05,580
out that ejb3 doesn't support

00:53:01,260 --> 00:53:08,339
constructor dependency injection normal

00:53:05,580 --> 00:53:10,560
ejb 3.1 and like I said so there that's

00:53:08,339 --> 00:53:12,420
a great point right there I'm a huge fan

00:53:10,560 --> 00:53:13,830
of constructor injection it's the one

00:53:12,420 --> 00:53:16,230
that I use probably ninety percent of

00:53:13,830 --> 00:53:19,050
the time just because you know such a

00:53:16,230 --> 00:53:26,070
big fan of immutability it's a great

00:53:19,050 --> 00:53:27,990
it's a great way to yes so yes if juice

00:53:26,070 --> 00:53:29,580
is part of Google's codebase it was born

00:53:27,990 --> 00:53:31,470
in Google's code base but then I open

00:53:29,580 --> 00:53:34,170
sourced it and now I host it on google

00:53:31,470 --> 00:53:35,940
code which anybody can use its kind of

00:53:34,170 --> 00:53:38,839
you can host your own source on there

00:53:35,940 --> 00:53:38,839
just go on and create your project

00:53:46,140 --> 00:53:50,760
injected

00:53:48,210 --> 00:53:53,160
so he asked where I draw the line

00:53:50,760 --> 00:53:57,660
between calling new constructing objects

00:53:53,160 --> 00:54:00,359
manually and between injecting the

00:53:57,660 --> 00:54:02,040
answer was it used to be my answer used

00:54:00,359 --> 00:54:03,750
to be that I would use dependency

00:54:02,040 --> 00:54:05,099
injection with juice a little more often

00:54:03,750 --> 00:54:06,810
than I would have used factors before

00:54:05,099 --> 00:54:08,730
because there's less friction and it's

00:54:06,810 --> 00:54:11,910
easier to use but now I would almost

00:54:08,730 --> 00:54:14,730
always have everything injected because

00:54:11,910 --> 00:54:18,780
it's not just the fact that I want that

00:54:14,730 --> 00:54:20,609
I want to decouple myself like maybe I

00:54:18,780 --> 00:54:23,790
don't necessarily wanted a couple client

00:54:20,609 --> 00:54:26,220
from service but maybe I want service to

00:54:23,790 --> 00:54:28,050
still be injected and by having service

00:54:26,220 --> 00:54:29,820
injected juice has the opportunity to

00:54:28,050 --> 00:54:31,080
inject it and inject dependencies in the

00:54:29,820 --> 00:54:35,130
service and client doesn't have to know

00:54:31,080 --> 00:54:37,130
about those so a lot it makes sense to

00:54:35,130 --> 00:54:39,150
use this stuff a lot I mean even now

00:54:37,130 --> 00:54:40,470
somebody released an intelligible ugh

00:54:39,150 --> 00:54:41,640
and I haven't had that much some time to

00:54:40,470 --> 00:54:43,140
check it out but even now even though

00:54:41,640 --> 00:54:46,230
that the tools reducer immature it's

00:54:43,140 --> 00:54:47,820
still it's it's very maintainable still

00:54:46,230 --> 00:54:50,790
right because look in your IDE when you

00:54:47,820 --> 00:54:52,500
depend on an interfacer class you can

00:54:50,790 --> 00:54:56,609
just jump right to it well what you see

00:54:52,500 --> 00:54:59,369
can still do that so so is the decision

00:54:56,609 --> 00:55:00,780
as to which version of the service it's

00:54:59,369 --> 00:55:03,390
going to be objective is that decision

00:55:00,780 --> 00:55:06,710
need at compile time to run time so II

00:55:03,390 --> 00:55:10,500
asked if the win the decision for which

00:55:06,710 --> 00:55:11,880
service to inject is made whether it's

00:55:10,500 --> 00:55:16,230
made at compile time ur run time it's

00:55:11,880 --> 00:55:17,700
made it early run time so we didn't we

00:55:16,230 --> 00:55:19,530
kind of some wanted to do this stuff at

00:55:17,700 --> 00:55:21,900
runtime but we wanted to know right away

00:55:19,530 --> 00:55:23,400
right you could theoretically do this

00:55:21,900 --> 00:55:25,859
stuff at compile time once we get like

00:55:23,400 --> 00:55:27,450
Java 6 in the annotation processing API

00:55:25,859 --> 00:55:33,330
and stuff but I I still think you kind

00:55:27,450 --> 00:55:37,650
of want some more dinama City and so the

00:55:33,330 --> 00:55:39,330
idea is that we saw these module classes

00:55:37,650 --> 00:55:40,560
and you pass those to the injector or

00:55:39,330 --> 00:55:42,240
you pass those to juice to create the

00:55:40,560 --> 00:55:44,310
injector where you can include different

00:55:42,240 --> 00:55:45,599
sets of modules whenever you're in your

00:55:44,310 --> 00:55:46,859
main method whenever you start up your

00:55:45,599 --> 00:55:49,200
application that's how you make the

00:55:46,859 --> 00:55:50,730
decision so as soon as that starts it's

00:55:49,200 --> 00:55:52,230
very fast juice is very fast about

00:55:50,730 --> 00:55:53,880
validating everything and running

00:55:52,230 --> 00:55:56,500
through your modules you'll find out

00:55:53,880 --> 00:55:58,120
right away if you're missing any

00:55:56,500 --> 00:55:59,530
institute or whatnot and one of the also

00:55:58,120 --> 00:56:01,420
the interesting things that juice does

00:55:59,530 --> 00:56:02,980
is kind of blurs the line between

00:56:01,420 --> 00:56:05,710
compile time in the runtime a little bit

00:56:02,980 --> 00:56:07,420
and respect that normally run time if

00:56:05,710 --> 00:56:10,480
you run into a problem you blow up and

00:56:07,420 --> 00:56:11,800
you have an exception well juice doesn't

00:56:10,480 --> 00:56:14,500
blow up at the first thing it does it

00:56:11,800 --> 00:56:16,150
feels early but not too early right it's

00:56:14,500 --> 00:56:17,950
so what it does is it goes through your

00:56:16,150 --> 00:56:19,270
entire configuration and it doesn't just

00:56:17,950 --> 00:56:20,830
stop at the first air it goes through

00:56:19,270 --> 00:56:22,300
and collects all the airs and keeps

00:56:20,830 --> 00:56:23,950
track of all the line numbers for these

00:56:22,300 --> 00:56:25,540
airs it gives you line numbers into your

00:56:23,950 --> 00:56:26,470
module gives you line numbers into your

00:56:25,540 --> 00:56:27,580
classes where you're missing

00:56:26,470 --> 00:56:29,230
dependencies and that sort of thing and

00:56:27,580 --> 00:56:31,390
it presents them very nicely the same

00:56:29,230 --> 00:56:32,680
way a compiler would so you don't have

00:56:31,390 --> 00:56:34,630
to keep restarting your application

00:56:32,680 --> 00:56:35,770
fixing every little air you can get the

00:56:34,630 --> 00:56:49,780
whole list them fix them all on your

00:56:35,770 --> 00:56:51,340
application will hopefully right so yes

00:56:49,780 --> 00:56:52,420
how mature juice is whether it's safe to

00:56:51,340 --> 00:56:58,300
use right now and the answer is

00:56:52,420 --> 00:57:01,840
emphatically yes no no yeah no no how

00:56:58,300 --> 00:57:04,150
much so now is actually it's a great

00:57:01,840 --> 00:57:05,620
time one point I was very stable we had

00:57:04,150 --> 00:57:06,730
a lot of experience with it I mean we're

00:57:05,620 --> 00:57:09,010
using this stuff in production for

00:57:06,730 --> 00:57:10,840
months before we even released it we've

00:57:09,010 --> 00:57:14,170
been using it since I started developing

00:57:10,840 --> 00:57:15,820
it well over a year ago and one point

00:57:14,170 --> 00:57:17,710
out pretty much has everything that

00:57:15,820 --> 00:57:19,780
you're going to need and there's little

00:57:17,710 --> 00:57:22,030
workarounds for the couple edge cases

00:57:19,780 --> 00:57:24,300
that you might run into the next version

00:57:22,030 --> 00:57:26,050
is really just kind of nice to have and

00:57:24,300 --> 00:57:27,760
enhancements maybe making the code a

00:57:26,050 --> 00:57:29,110
little more concise like I said we're

00:57:27,760 --> 00:57:31,630
making the custom providers a little

00:57:29,110 --> 00:57:33,340
more concise but even even though you

00:57:31,630 --> 00:57:34,570
write those maybe less than five percent

00:57:33,340 --> 00:57:37,060
at a time so it's like you know it's

00:57:34,570 --> 00:57:42,510
nice it's nice savings but you got it's

00:57:37,060 --> 00:57:42,510
not the end of the world yes

00:57:43,050 --> 00:57:46,810
so yes if it's going to be compatible

00:57:45,130 --> 00:57:49,030
with web beans it's still too early to

00:57:46,810 --> 00:57:51,310
tell but web beans is going to look very

00:57:49,030 --> 00:57:52,570
much like like juice and like I said

00:57:51,310 --> 00:57:53,800
it's gonna look like juice and seen

00:57:52,570 --> 00:57:55,750
combined and it's really interesting

00:57:53,800 --> 00:57:57,369
because juice and seeing had two very

00:57:55,750 --> 00:57:58,510
different injection approaches so it'll

00:57:57,369 --> 00:58:00,550
be interesting to see how those fit

00:57:58,510 --> 00:58:02,500
together but juice will implement web

00:58:00,550 --> 00:58:04,510
beans okay and I'll continue to

00:58:02,500 --> 00:58:07,740
implement its current API we care a

00:58:04,510 --> 00:58:07,740
whole lot about backward compatibility

00:58:15,700 --> 00:58:21,820
I would also give me anything is fine

00:58:19,390 --> 00:58:29,579
basically I want to see what God

00:58:21,820 --> 00:58:29,579
rejected ah yes so yes you have

00:58:36,400 --> 00:58:40,750
so he asked one weather what kind of

00:58:39,670 --> 00:58:42,040
reporting juice give you one

00:58:40,750 --> 00:58:44,110
everything's fine and that's when

00:58:42,040 --> 00:58:47,590
there's errors and two how the IDE

00:58:44,110 --> 00:58:49,510
integration is so to answer your first

00:58:47,590 --> 00:58:51,520
question that's kind of where the jmx

00:58:49,510 --> 00:58:53,380
integration comes in right now juice has

00:58:51,520 --> 00:58:55,810
an API where you can kind of introspect

00:58:53,380 --> 00:58:58,990
on your bindings and one example of

00:58:55,810 --> 00:59:01,150
using that API is a jmx integration for

00:58:58,990 --> 00:59:03,370
those of you that don't know jmx is a

00:59:01,150 --> 00:59:05,290
standard management interface where you

00:59:03,370 --> 00:59:07,300
can have multiple clients that i'll kind

00:59:05,290 --> 00:59:10,030
of speak this that know about the same

00:59:07,300 --> 00:59:13,000
API and like a look so and Java even

00:59:10,030 --> 00:59:14,830
comes with a little jmx client so you

00:59:13,000 --> 00:59:16,030
can connect to your application if

00:59:14,830 --> 00:59:17,980
you're using the jmx integration you can

00:59:16,030 --> 00:59:20,410
connect to your application that's using

00:59:17,980 --> 00:59:22,570
juice and in your day in your console

00:59:20,410 --> 00:59:23,920
your jmx console you can kind of see

00:59:22,570 --> 00:59:25,930
like a nice little gooey that shows you

00:59:23,920 --> 00:59:27,850
all your different bindings and you know

00:59:25,930 --> 00:59:30,670
you can drill down based on type or

00:59:27,850 --> 00:59:32,500
based on finding annotation and find

00:59:30,670 --> 00:59:35,200
everything that way then he asked about

00:59:32,500 --> 00:59:36,640
IDE integration like I said about a week

00:59:35,200 --> 00:59:38,560
after juice came out somebody came out

00:59:36,640 --> 00:59:40,720
with an intelligent plug-in for juice I

00:59:38,560 --> 00:59:43,090
haven't tried it myself very much you

00:59:40,720 --> 00:59:45,640
don't really I mean I love IDs don't get

00:59:43,090 --> 00:59:47,770
me wrong i use the heck out of my use

00:59:45,640 --> 00:59:49,300
every feature of IntelliJ but the way

00:59:47,770 --> 00:59:54,390
juice is set up is it set up to be

00:59:49,300 --> 00:59:58,240
maintainable even without an IDE so a

00:59:54,390 --> 01:00:00,700
lot of cases the harder cases whenever

00:59:58,240 --> 01:00:02,020
my whenever you depend on an interface

01:00:00,700 --> 01:00:03,790
right and that's already hard with or

01:00:02,020 --> 01:00:04,960
without juice right it's like how do I

01:00:03,790 --> 01:00:07,660
know what implementation of that

01:00:04,960 --> 01:00:09,280
interface am I didn't well most time in

01:00:07,660 --> 01:00:10,750
your ideas I just use the feature where

01:00:09,280 --> 01:00:12,190
you can kind of a you can go to the

01:00:10,750 --> 01:00:13,810
implementation you can heard the

01:00:12,190 --> 01:00:14,920
interface and then you can it can show

01:00:13,810 --> 01:00:16,570
you all the implementations that

01:00:14,920 --> 01:00:18,220
interface usually it's pretty clear

01:00:16,570 --> 01:00:20,170
which one you get but I also think it

01:00:18,220 --> 01:00:21,910
would be nice if we had an IDE plugin

01:00:20,170 --> 01:00:24,040
where you could say okay I'm going to

01:00:21,910 --> 01:00:26,290
use this set of modules to configure my

01:00:24,040 --> 01:00:27,640
application and then based on that tell

01:00:26,290 --> 01:00:28,420
me what implementation is service i'm

01:00:27,640 --> 01:00:30,280
going to get and that's totally

01:00:28,420 --> 01:00:32,440
plausible that's one of things were

01:00:30,280 --> 01:00:34,770
working on to make even easier in the

01:00:32,440 --> 01:00:34,770
next version

01:00:37,010 --> 01:00:40,770
he asked if the constructors and methods

01:00:39,240 --> 01:00:43,350
have to be public and the answer is no

01:00:40,770 --> 01:00:45,630
and the reason I made that design

01:00:43,350 --> 01:00:46,950
decision they could even be private the

01:00:45,630 --> 01:00:49,410
reason I made that design design

01:00:46,950 --> 01:00:51,480
decision is so you still want to control

01:00:49,410 --> 01:00:54,060
access you can tell by looking at the

01:00:51,480 --> 01:00:55,890
juice API that I only expose what needs

01:00:54,060 --> 01:00:57,690
to be exposed to clients and the reasons

01:00:55,890 --> 01:01:00,960
for that is one to make your API simpler

01:00:57,690 --> 01:01:05,280
and two so that you can feasibly

01:01:00,960 --> 01:01:08,310
maintain backward compatibility and then

01:01:05,280 --> 01:01:09,750
so based on that and the fact that you

01:01:08,310 --> 01:01:11,280
have you have to have that inject

01:01:09,750 --> 01:01:12,960
annotation so even though it's private

01:01:11,280 --> 01:01:17,070
you still see that inject a notation and

01:01:12,960 --> 01:01:22,680
know that it's going to be injected the

01:01:17,070 --> 01:01:24,060
situation so this is so yes if there's

01:01:22,680 --> 01:01:26,970
ever a situation where you have like two

01:01:24,060 --> 01:01:28,770
services that are codependent and yes

01:01:26,970 --> 01:01:30,690
that's another great reason that I did

01:01:28,770 --> 01:01:32,730
mention to use a framework like juice is

01:01:30,690 --> 01:01:34,500
that it automatically handles circular

01:01:32,730 --> 01:01:37,050
dependencies so this is the idea when

01:01:34,500 --> 01:01:38,730
you have two implementations that depend

01:01:37,050 --> 01:01:40,950
on each other and with juice it actually

01:01:38,730 --> 01:01:43,050
even does some fancy stuff it's I don't

01:01:40,950 --> 01:01:45,600
like to encourage it necessarily but

01:01:43,050 --> 01:01:47,100
even if you have two constructors that

01:01:45,600 --> 01:01:48,630
depend on each other just can handle

01:01:47,100 --> 01:01:51,510
that case and the way it does that is

01:01:48,630 --> 01:01:54,330
it'll inject a proxy into one for you

01:01:51,510 --> 01:01:55,680
automatically and swap in an

01:01:54,330 --> 01:01:57,930
implementation of that proxy after

01:01:55,680 --> 01:02:03,500
construct the other object so you can

01:01:57,930 --> 01:02:03,500
make everything final yes

01:02:29,450 --> 01:02:32,050
yep

01:02:39,319 --> 01:02:45,569
so we asked how you can handle a remote

01:02:44,279 --> 01:02:48,630
services that aren't implemented in Java

01:02:45,569 --> 01:02:51,720
with juice God can I assume that well I

01:02:48,630 --> 01:02:53,609
would assume that you're using a Java

01:02:51,720 --> 01:02:56,099
API to communicate with those services

01:02:53,609 --> 01:02:59,339
and not the XML directly so the idea is

01:02:56,099 --> 01:03:00,990
that so that's one of the things that I

01:02:59,339 --> 01:03:03,839
really like about the way you can figure

01:03:00,990 --> 01:03:05,339
modules in juice too is you can easily

01:03:03,839 --> 01:03:06,809
make these little utility methods and

01:03:05,339 --> 01:03:09,150
stuff in your modules so that I could

01:03:06,809 --> 01:03:11,339
say I could create a method called bind

01:03:09,150 --> 01:03:12,990
web service and I would give it the

01:03:11,339 --> 01:03:14,279
interface that I wanted to use like the

01:03:12,990 --> 01:03:16,200
Java interface and then I would give it

01:03:14,279 --> 01:03:18,930
may be kind of like the URL to the Wiz

01:03:16,200 --> 01:03:20,339
dolor something like that or to the B

01:03:18,930 --> 01:03:21,720
URL to the remote service and then which

01:03:20,339 --> 01:03:22,859
is automatically just put that one

01:03:21,720 --> 01:03:26,839
method call it would create a binding

01:03:22,859 --> 01:03:26,839
for that service for me

01:03:37,230 --> 01:03:41,240
oh can you repeat the question I'm sorry

01:03:51,380 --> 01:04:07,289
so he he asked about testing of a larger

01:03:55,049 --> 01:04:14,390
application so in the great that's a

01:04:07,289 --> 01:04:14,390
great question right

01:04:26,670 --> 01:04:33,760
so he's asking them so I think you're

01:04:30,250 --> 01:04:36,880
asking about how you implement kinda

01:04:33,760 --> 01:04:37,930
like medium sized tests maybe so on the

01:04:36,880 --> 01:04:40,450
one into the spectrum you have these

01:04:37,930 --> 01:04:42,490
unit tests where you don't use juice at

01:04:40,450 --> 01:04:44,020
all we showed that and use pass and mock

01:04:42,490 --> 01:04:46,270
implementation on the other end of the

01:04:44,020 --> 01:04:47,350
spectrum you have full-blown integration

01:04:46,270 --> 01:04:48,640
tests where your test against your

01:04:47,350 --> 01:04:51,070
production configuration which you want

01:04:48,640 --> 01:04:52,390
definitely still need to do but then in

01:04:51,070 --> 01:04:53,920
the middle there's kind of this middle

01:04:52,390 --> 01:04:55,390
ground where it's still hard to

01:04:53,920 --> 01:04:57,310
construct your objects and then juice is

01:04:55,390 --> 01:04:58,570
great for that I mean you saw kind of

01:04:57,310 --> 01:05:01,120
the bootstrapping code and Jews how

01:04:58,570 --> 01:05:02,890
simple it was right it's just a couple

01:05:01,120 --> 01:05:04,300
lines of code to kind of bootstrapping

01:05:02,890 --> 01:05:07,480
juice configuration right there in your

01:05:04,300 --> 01:05:11,320
test and in a medium-sized test you know

01:05:07,480 --> 01:05:12,790
like say I wanted to swap in a fake

01:05:11,320 --> 01:05:14,260
billing service or something I guess I'm

01:05:12,790 --> 01:05:15,220
not actually charging credit cards but I

01:05:14,260 --> 01:05:16,720
still want to test like a bunch of

01:05:15,220 --> 01:05:19,300
objects together like four or five

01:05:16,720 --> 01:05:22,270
objects that all interact well juice is

01:05:19,300 --> 01:05:24,910
great for that so and the idea is where

01:05:22,270 --> 01:05:27,100
as in my production configuration I used

01:05:24,910 --> 01:05:29,890
one set of modules well in this test

01:05:27,100 --> 01:05:31,420
configuration i can use kind of some of

01:05:29,890 --> 01:05:32,950
the same modules but i can also swap in

01:05:31,420 --> 01:05:34,570
like a fake billing module which will

01:05:32,950 --> 01:05:36,820
install all the fake billing services

01:05:34,570 --> 01:05:38,970
and that's what it so yeah juice is very

01:05:36,820 --> 01:05:38,970
good

01:05:54,069 --> 01:05:57,739
inviting configuration do you mean like

01:05:56,269 --> 01:06:06,769
the properties file if you wanted to use

01:05:57,739 --> 01:06:08,149
that or so he asked if juice kind of

01:06:06,769 --> 01:06:11,630
mandates where your properties file has

01:06:08,149 --> 01:06:13,099
to be and the answer's no it's the

01:06:11,630 --> 01:06:14,089
utility method that lets you kind of

01:06:13,099 --> 01:06:15,619
generate the bindings off your

01:06:14,089 --> 01:06:16,849
properties file all I think it just

01:06:15,619 --> 01:06:18,739
takes like a breeder or something like

01:06:16,849 --> 01:06:20,509
that so you can get the URL using like a

01:06:18,739 --> 01:06:23,119
file reader if you wanted to get off the

01:06:20,509 --> 01:06:24,589
file system or a URL reader if you

01:06:23,119 --> 01:06:25,489
wanted to get it out of the jar whatever

01:06:24,589 --> 01:06:28,429
or if you want to get off the remote

01:06:25,489 --> 01:06:30,109
servers you could do that right so and

01:06:28,429 --> 01:06:32,329
you could even float you could even kind

01:06:30,109 --> 01:06:35,799
of switch it based on whether you're in

01:06:32,329 --> 01:06:35,799
development from production mode too

01:06:40,630 --> 01:06:43,579
that's what I'm gonna give the juice

01:06:42,469 --> 01:06:45,409
pattern stock I think I'm gonna leave

01:06:43,579 --> 01:06:52,219
that one to Kevin because he's a better

01:06:45,409 --> 01:06:55,249
speaker than I oh yeah yep example which

01:06:52,219 --> 01:06:58,549
ensured you had the bindings were like

01:06:55,249 --> 01:07:00,919
in the code so you said fine service not

01:06:58,549 --> 01:07:04,729
class to servicing finger yep how would

01:07:00,919 --> 01:07:07,880
I can be cases where my uncle would not

01:07:04,729 --> 01:07:10,459
be known okay that's a great question so

01:07:07,880 --> 01:07:12,439
he's asking what if he doesn't know a

01:07:10,459 --> 01:07:14,899
coding time then he wants to use service

01:07:12,439 --> 01:07:19,189
simple maybe he wants the client to be

01:07:14,899 --> 01:07:20,349
able to specify that class in a

01:07:19,189 --> 01:07:22,729
properties file or something like that

01:07:20,349 --> 01:07:25,099
well that's why I specifically mentioned

01:07:22,729 --> 01:07:27,259
that Jews could configure well no I mean

01:07:25,099 --> 01:07:28,519
I didn't mention it enough that you

01:07:27,259 --> 01:07:30,499
might be able to figure it out but I

01:07:28,519 --> 01:07:32,329
mentioned that with the constant type

01:07:30,499 --> 01:07:35,749
conversion juice can also convert to

01:07:32,329 --> 01:07:37,519
classes so you can specify a class name

01:07:35,749 --> 01:07:39,139
in your properties file and then have

01:07:37,519 --> 01:07:40,639
that injected as a class somewhere like

01:07:39,139 --> 01:07:42,859
in a custom provider or something like

01:07:40,639 --> 01:07:44,839
that and then s juice for an instance of

01:07:42,859 --> 01:07:47,630
that class and then juice will blow up

01:07:44,839 --> 01:07:51,229
at startup if it can't inject that class

01:07:47,630 --> 01:07:53,389
instance so you can specify you can

01:07:51,229 --> 01:07:55,369
specify and it let your clients specify

01:07:53,389 --> 01:07:58,430
an implementation dynamically

01:07:55,369 --> 01:08:00,950
um many of the frameworks I look at that

01:07:58,430 --> 01:08:03,319
you instruct for example they have like

01:08:00,950 --> 01:08:05,420
one start start our Commons language or

01:08:03,319 --> 01:08:08,150
they star that event is like 10-20 jars

01:08:05,420 --> 01:08:09,890
by the time I the way development

01:08:08,150 --> 01:08:11,240
environment be working right now these

01:08:09,890 --> 01:08:14,119
things have to be checked in senior

01:08:11,240 --> 01:08:16,460
right I don't know I cannot control how

01:08:14,119 --> 01:08:21,080
many dependents is do you get yeah so

01:08:16,460 --> 01:08:22,699
he's a skiing how we deal with kind of

01:08:21,080 --> 01:08:25,489
like this dependency explosion whereas

01:08:22,699 --> 01:08:28,310
all these frameworks depend on 15 jars

01:08:25,489 --> 01:08:29,870
she doesn't help you there okay it's a

01:08:28,310 --> 01:08:31,279
you know it's if you depend on a lot of

01:08:29,870 --> 01:08:33,100
things you're gonna have a lot of which

01:08:31,279 --> 01:08:36,170
are dependencies how many does juice be

01:08:33,100 --> 01:08:37,850
none well you have the aop Alliance API

01:08:36,170 --> 01:08:40,639
juice is very self-contained it's very

01:08:37,850 --> 01:08:41,779
small and it has no external

01:08:40,639 --> 01:08:44,089
dependencies that you need to worry

01:08:41,779 --> 01:08:45,949
about besides aop lanes API so as two

01:08:44,089 --> 01:08:47,900
jars as the juice jar and the alp

01:08:45,949 --> 01:08:51,940
Alliance truck so because I hate all

01:08:47,900 --> 01:08:51,940
those dependencies too yes

01:08:55,060 --> 01:08:59,990
I'm so really version one of Aoki lights

01:08:58,460 --> 01:09:01,339
really only specifies method

01:08:59,990 --> 01:09:03,920
interception anyway so it was just like

01:09:01,339 --> 01:09:05,450
a couple interfaces in there so but that

01:09:03,920 --> 01:09:08,900
is the only interface to supports anyway

01:09:05,450 --> 01:09:10,279
oh yeah it's really small yeah there's

01:09:08,900 --> 01:09:20,029
like maybe one or two interfaces in

01:09:10,279 --> 01:09:21,529
there oh so yep you could eject what

01:09:20,029 --> 01:09:26,510
when you do in the unit testing can you

01:09:21,529 --> 01:09:28,130
inject data yeah you can do yeah you can

01:09:26,510 --> 01:09:29,000
do whatever you want I mean it's like I

01:09:28,130 --> 01:09:30,920
said it's kind of a nice thing about

01:09:29,000 --> 01:09:32,870
having this programmatic API figuring

01:09:30,920 --> 01:09:34,970
bindings you know you can build whatever

01:09:32,870 --> 01:09:37,069
you want on top of like you could have a

01:09:34,970 --> 01:09:38,839
utility method that reads in an XML file

01:09:37,069 --> 01:09:49,940
it makes you can inject it like inject

01:09:38,839 --> 01:09:52,310
the Dom right he asked on a big

01:09:49,940 --> 01:09:58,750
application how complicated your modules

01:09:52,310 --> 01:10:01,880
get um and you know it really depends

01:09:58,750 --> 01:10:05,900
you only have to explicitly define

01:10:01,880 --> 01:10:06,950
bindings whenever you have an interface

01:10:05,900 --> 01:10:08,030
whenever you're depending on an

01:10:06,950 --> 01:10:09,710
interface so it depends how many

01:10:08,030 --> 01:10:12,110
interfaces and implementations you use

01:10:09,710 --> 01:10:13,940
right so but compared to other

01:10:12,110 --> 01:10:16,520
frameworks it's a lot less than you

01:10:13,940 --> 01:10:18,920
typically have slow yes from our

01:10:16,520 --> 01:10:21,470
experience Kevin knows better than I do

01:10:18,920 --> 01:10:23,240
the edges that we've been developing in

01:10:21,470 --> 01:10:25,760
Edwards don't really get more

01:10:23,240 --> 01:10:30,370
complicated you just get more of them so

01:10:25,760 --> 01:10:32,750
we are now you know we have maybe 50

01:10:30,370 --> 01:10:35,810
and when they one starts to get too big

01:10:32,750 --> 01:10:37,670
then we usually chop it up and that

01:10:35,810 --> 01:10:39,530
makes that makes it usually like the

01:10:37,670 --> 01:10:41,300
unit of granularity for module is like

01:10:39,530 --> 01:10:42,980
the set of things that you would

01:10:41,300 --> 01:10:47,510
typically want to test together as a

01:10:42,980 --> 01:10:50,390
unit in like sort of a functional test

01:10:47,510 --> 01:10:52,640
so if you'd say like I want to test how

01:10:50,390 --> 01:10:54,920
the these pages work but I want to mock

01:10:52,640 --> 01:10:56,870
out the entire building subsystem with

01:10:54,920 --> 01:11:02,210
the building subsystem in one module and

01:10:56,870 --> 01:11:08,080
the UI for this section it's great

01:11:02,210 --> 01:11:08,080
advice oh yes

01:11:15,540 --> 01:11:25,050
uh no see if there's any cases of it GS

01:11:23,730 --> 01:11:28,140
if there's any cases where you would

01:11:25,050 --> 01:11:31,130
discourage you seduce and well it

01:11:28,140 --> 01:11:32,970
doesn't work on a mobile phone yet

01:11:31,130 --> 01:11:35,100
outside of that I mean it's just really

01:11:32,970 --> 01:11:37,710
so simple it's not you know it's it's

01:11:35,100 --> 01:11:40,770
not really dead there's not a lot of

01:11:37,710 --> 01:11:42,480
risk to it you know so and it's always

01:11:40,770 --> 01:11:50,070
good to write unit tests so and juice

01:11:42,480 --> 01:11:52,920
helps you do that measurements on the

01:11:50,070 --> 01:11:57,120
performance if not using diction versus

01:11:52,920 --> 01:11:59,160
not he asked how's the performance we

01:11:57,120 --> 01:12:02,160
care very much about performance and

01:11:59,160 --> 01:12:03,840
it's the difference between doing this

01:12:02,160 --> 01:12:06,150
stuff by hand and using juice to do it

01:12:03,840 --> 01:12:07,710
is litter it's very it's negligible like

01:12:06,150 --> 01:12:10,740
you could like you really couldn't tell

01:12:07,710 --> 01:12:13,620
I mean it's it's so close you're talking

01:12:10,740 --> 01:12:15,180
like nano seconds apart so you can

01:12:13,620 --> 01:12:18,560
create millions of objects in a loop

01:12:15,180 --> 01:12:18,560
with juice and it'll still be fast

01:12:22,410 --> 01:12:27,510
cool oh it's are there any listeners

01:12:26,010 --> 01:12:30,050
that you can apply to this case I'd be

01:12:27,510 --> 01:12:30,050
on the customs

01:12:32,750 --> 01:12:37,970
um he asked if there's any listeners for

01:12:35,380 --> 01:12:40,430
whenever the scope get stared down and

01:12:37,970 --> 01:12:43,250
we do get that request a lot but we

01:12:40,430 --> 01:12:47,690
don't support it yet so I'm not quite

01:12:43,250 --> 01:12:49,430
sure exactly how that's going to work

01:12:47,690 --> 01:12:50,780
it's part of the reason right so

01:12:49,430 --> 01:12:53,330
actually we could use like more use

01:12:50,780 --> 01:13:02,690
cases for that too so where you'd like

01:12:53,330 --> 01:13:05,390
say exactly what you want he asked about

01:13:02,690 --> 01:13:06,770
the fact that we named the provider

01:13:05,390 --> 01:13:10,130
interface provider that is kind of a

01:13:06,770 --> 01:13:12,680
strange name right we named it that's

01:13:10,130 --> 01:13:14,420
Kevin no that's good it was good it was

01:13:12,680 --> 01:13:16,970
a good rename Kevin is great at coming

01:13:14,420 --> 01:13:18,590
up with names for the api's and the

01:13:16,970 --> 01:13:20,510
juice API looks very much like it does

01:13:18,590 --> 01:13:24,050
because of Kevin's influence and

01:13:20,510 --> 01:13:25,160
provider is one of those things and it's

01:13:24,050 --> 01:13:26,180
it I think it makes sense i think

01:13:25,160 --> 01:13:27,440
there's kind of this connotation with

01:13:26,180 --> 01:13:29,240
factories that it creates a new object

01:13:27,440 --> 01:13:30,350
every time whereas that's not

01:13:29,240 --> 01:13:32,930
necessarily the case with providers

01:13:30,350 --> 01:13:34,340
right but it could be returning the same

01:13:32,930 --> 01:13:38,120
object every time in case of single

01:13:34,340 --> 01:13:40,750
train or whatever we wanted to be a

01:13:38,120 --> 01:13:40,750
little more generic

01:13:42,290 --> 01:13:49,570
bunch of Marvel the gist context is

01:13:46,130 --> 01:13:49,570
burning Margot

01:13:50,970 --> 01:13:58,690
so he asked if there's any relationship

01:13:54,100 --> 01:14:01,270
between modules and hopefully no Kevin

01:13:58,690 --> 01:14:03,010
do you ever have any situation with so

01:14:01,270 --> 01:14:05,470
you can structure your modules in a tree

01:14:03,010 --> 01:14:07,720
structure oh yeah that's just a

01:14:05,470 --> 01:14:09,910
convenient way if you have 100 of them

01:14:07,720 --> 01:14:11,200
and 50 of them tend to go together you

01:14:09,910 --> 01:14:14,920
can make another module that includes

01:14:11,200 --> 01:14:16,239
all those and actually in juice 1.1 we

01:14:14,920 --> 01:14:18,250
fixed it so it doesn't even have to be a

01:14:16,239 --> 01:14:19,870
tree if the same module wants to get

01:14:18,250 --> 01:14:21,630
included twice it will just realize that

01:14:19,870 --> 01:14:24,100
it's already been installed in move on

01:14:21,630 --> 01:14:26,560
but I would encourage you to think of

01:14:24,100 --> 01:14:28,239
these structure like your J unit test

01:14:26,560 --> 01:14:29,440
cases and your test Suites where you

01:14:28,239 --> 01:14:30,700
either have something that contains

01:14:29,440 --> 01:14:32,739
other things or you have something

01:14:30,700 --> 01:14:34,600
that's a leaf because if you go too far

01:14:32,739 --> 01:14:36,580
with like having modules that both

01:14:34,600 --> 01:14:38,830
define bindings to implementations and

01:14:36,580 --> 01:14:40,420
include other modules then you're

01:14:38,830 --> 01:14:42,010
creating compile-time dependencies

01:14:40,420 --> 01:14:54,630
between modules which is exactly what

01:14:42,010 --> 01:14:54,630
juice is trying to help you basically so

01:14:58,560 --> 01:15:04,480
um when you say put together can you be

01:15:02,140 --> 01:15:12,210
a little worse maybe maybe like with an

01:15:04,480 --> 01:15:12,210
example great so this module has

01:15:20,270 --> 01:15:25,619
yes so you're saying like you're asking

01:15:23,070 --> 01:15:28,650
so we have module a and module B module

01:15:25,619 --> 01:15:32,369
a has classes that depend on interfaces

01:15:28,650 --> 01:15:34,440
bound by module B and module B might

01:15:32,369 --> 01:15:37,320
have classes which depend on interface

01:15:34,440 --> 01:15:38,309
is defined by module a and yet juices

01:15:37,320 --> 01:15:40,500
that think it brings these models

01:15:38,309 --> 01:15:42,239
together and makes all that possible

01:15:40,500 --> 01:15:44,340
without module a and mods will be having

01:15:42,239 --> 01:15:45,750
to depend on each other so the idea is

01:15:44,340 --> 01:15:47,400
you could take module a and reuse it

01:15:45,750 --> 01:15:48,840
with an alternate like a fake

01:15:47,400 --> 01:15:50,639
implementation philosophy if you wanted

01:15:48,840 --> 01:15:53,309
one other thing I wanted to talk about

01:15:50,639 --> 01:15:55,590
there well first Kevin needs to give a

01:15:53,309 --> 01:15:58,530
talk on design patterns related to juice

01:15:55,590 --> 01:16:00,239
but second so module is a really generic

01:15:58,530 --> 01:16:03,090
interface and one of the things that I

01:16:00,239 --> 01:16:05,040
had in mind whenever I defined it was

01:16:03,090 --> 01:16:06,449
being able to kind of write these

01:16:05,040 --> 01:16:08,849
utility methods that you can use in your

01:16:06,449 --> 01:16:11,099
configuration too so you can write Q

01:16:08,849 --> 01:16:12,960
tility methods that return providers and

01:16:11,099 --> 01:16:17,340
they just can create those but you can

01:16:12,960 --> 01:16:18,750
also write utility methods that are

01:16:17,340 --> 01:16:21,119
implemented as modules and then call

01:16:18,750 --> 01:16:23,190
those from your other modules so like

01:16:21,119 --> 01:16:25,199
you could you could provide like for the

01:16:23,190 --> 01:16:26,610
web service thing like so you had to

01:16:25,199 --> 01:16:29,190
create a couple bindings to make that

01:16:26,610 --> 01:16:30,630
happen well you could give me you can

01:16:29,190 --> 01:16:33,090
give a factory method where I give you

01:16:30,630 --> 01:16:35,280
interface and the URL and then you give

01:16:33,090 --> 01:16:36,809
me back a module that creates those 33

01:16:35,280 --> 01:16:39,170
bindings well let me having to know

01:16:36,809 --> 01:16:39,170
about it

01:16:41,219 --> 01:16:50,469
cool ok this is on all right cool I just

01:16:47,679 --> 01:16:52,389
wanted to make sure that we plug we're

01:16:50,469 --> 01:16:54,010
how to find the project page and get on

01:16:52,389 --> 01:16:55,420
the mailing list because I always forget

01:16:54,010 --> 01:16:57,699
to do that when I've done these talks

01:16:55,420 --> 01:17:00,130
and bob was forgetting to do it too I

01:16:57,699 --> 01:17:02,469
did forget I told myself I wouldn't so

01:17:00,130 --> 01:17:06,189
all you have to do is is type in juice g

01:17:02,469 --> 01:17:08,709
u IC e to your favorite search engine on

01:17:06,189 --> 01:17:10,780
the internet whatever that may be and on

01:17:08,709 --> 01:17:12,670
the one that I use our project page

01:17:10,780 --> 01:17:16,239
comes up first it's hosted on code

01:17:12,670 --> 01:17:17,829
google com and fright from that page

01:17:16,239 --> 01:17:20,559
there's a link to the downloads to the

01:17:17,829 --> 01:17:22,119
javadocs and to mailing lists there's

01:17:20,559 --> 01:17:23,619
the regular mailing list and the

01:17:22,119 --> 01:17:25,539
developers mailing list the developers

01:17:23,619 --> 01:17:27,849
mailing list is very chatty you'll get

01:17:25,539 --> 01:17:31,030
email every time we update the wiki it's

01:17:27,849 --> 01:17:33,010
really silly but the the main user list

01:17:31,030 --> 01:17:35,739
has a couple hundred subscribers and we

01:17:33,010 --> 01:17:39,219
have lots of good traffic users helping

01:17:35,739 --> 01:17:41,199
users so I recommend getting on there

01:17:39,219 --> 01:17:43,630
and giving us your feature requests and

01:17:41,199 --> 01:17:45,340
stuff and if you speak Chinese we have a

01:17:43,630 --> 01:17:48,670
chinese translation of the user guide to

01:17:45,340 --> 01:17:50,380
and portuguese and portuguese maybe not

01:17:48,670 --> 01:17:52,449
if the users guide it's like the

01:17:50,380 --> 01:17:58,150
somebody wrote a tutorial in portuguese

01:17:52,449 --> 01:18:00,999
call we linked it cool never realize all

01:17:58,150 --> 01:18:03,420
right thank you very much for everybody

01:18:00,999 --> 01:18:03,420

YouTube URL: https://www.youtube.com/watch?v=l81T1AQWX84


