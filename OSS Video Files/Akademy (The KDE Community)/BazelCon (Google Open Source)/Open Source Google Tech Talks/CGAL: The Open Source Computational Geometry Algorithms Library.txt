Title: CGAL: The Open Source Computational Geometry Algorithms Library
Publication date: 2011-03-09
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talks
March,  3 2008

ABSTRACT

Introduction
Project mission statement, history, internal organization, partners, CGAL in numbers.

What's in CGAL
A survey on available data structures and algorithms, as well as examples how and by whom they are used. Topics include Triangulations, Voronoi diagrams, Boolean operations on polygons and polyhedra, arrangements of curves and their applications, Mesh generation, Geometry processing, Alpha shapes, Convex hull algorithms, Operations on polygons, Search structures, Interpolation, Shape analysis, fitting, and distances, Kinetic data structures...

Generic Programming Paradigm
CGAL data structures are C++ template classes and functions, usually taking several template parameters (with default values for ease of use). This gives developers an incredible flexibility to adapt the data structures to their needs, which is important internally for code reuse, and important for end users, as they typically integrate CGAL in already existing applications. Parts of CGAL are also interfaced with languages and software like Python, Java, Scilab, Qt and the Ipe drawing editor.

Exact Geometric Computing Paradigm
We present how to make geometric algorithms correct, robust, and nevertheless fast, by combining floating point arithmetic with exact arithmetic, and clever filtering mechanisms to switch between these two modes. These mechanisms can be used for geometric predicates, as well as for geometric constructions, which instead of a discrete return value generate new geometric entities.

Conclusion and Outlook
A wrapup, and a sneak preview on algorithms that might make it into  future releases of CGAL.

Speaker: Andreas Fabri, PhD, GeometryFactory
As member of the initial development team of the CGAL project, Andreas is one of the architects of the CGAL software. For several years he chaired the CGAL Editorial Board. In 2003, Andreas founded the GeometryFactory as spin-off of the CGAL project, offering licenses, service and support to commercial users. Andreas received his PhD in 1994 from the Ecole des Mines de Paris, while working on geometric algorithms for parallel machines at INRIA.


Speaker: Sylvain Pion, PhD, INRIA Sophia-Antipolis
Sylvain got involved in the CGAL project during his PhD, which he received in 1999 at INRIA. He worked then on providing generic solutions to numerical robustness issues arising in geometric algorithms. Later on he worked on the efficiency of some fundamental geometric algorithms such as 3D Delaunay triangulations. He is now also involved in C++ standardization, and is working on parallel geometric algorithms. He is employed as researcher at INRIA, and is the current chair of the CGAL Editorial Board.
Captions: 
	00:00:23,920 --> 00:00:29,289
so thank you Lawrence and this is a

00:00:27,699 --> 00:00:31,689
great opportunity for us we are very

00:00:29,289 --> 00:00:36,730
happy to be able to to give this talk at

00:00:31,689 --> 00:00:40,089
Google so the the talk will be organized

00:00:36,730 --> 00:00:42,400
by different parts which we will

00:00:40,089 --> 00:00:44,170
alternately present so I will first give

00:00:42,400 --> 00:00:46,839
you another view of how the project

00:00:44,170 --> 00:00:51,030
works and then undress will give you

00:00:46,839 --> 00:00:54,400
some corridor tour of what is in CR and

00:00:51,030 --> 00:00:57,070
then I will go into more technical

00:00:54,400 --> 00:00:59,850
details concerning the generic

00:00:57,070 --> 00:01:02,829
programming aspects as well as the exact

00:00:59,850 --> 00:01:04,960
geometric computing that we use overall

00:01:02,829 --> 00:01:13,899
in cigar and unrest will finally

00:01:04,960 --> 00:01:17,740
conclude so the Siegel project is now 12

00:01:13,899 --> 00:01:19,899
years old it was originally originally

00:01:17,740 --> 00:01:22,660
guided by this mission statement which

00:01:19,899 --> 00:01:25,240
is to make a large body of geometric

00:01:22,660 --> 00:01:27,540
algorithms developed in the field the

00:01:25,240 --> 00:01:31,290
research field of computational geometry

00:01:27,540 --> 00:01:34,750
available for industrial applications

00:01:31,290 --> 00:01:39,460
what it is now is a an open-source

00:01:34,750 --> 00:01:42,040
project there are a few institutional

00:01:39,460 --> 00:01:45,960
members which make long-term commitments

00:01:42,040 --> 00:01:48,670
and which are supported by sequent

00:01:45,960 --> 00:01:51,610
subsequent European research project

00:01:48,670 --> 00:01:53,740
these are in ariya in France the Max

00:01:51,610 --> 00:01:56,770
Planck Institute in Germany Tel Aviv

00:01:53,740 --> 00:02:00,040
University uterus University and a few

00:01:56,770 --> 00:02:02,979
others in particular geometry Factory

00:02:00,040 --> 00:02:07,329
which is a spin-off company of our

00:02:02,979 --> 00:02:11,380
project which started in 2003 and which

00:02:07,329 --> 00:02:13,989
was funded by unrest I would say that

00:02:11,380 --> 00:02:16,269
like for any open-source project we have

00:02:13,989 --> 00:02:20,230
some development infrastructures so an

00:02:16,269 --> 00:02:23,049
SVN repository bug tractors etc and some

00:02:20,230 --> 00:02:26,290
nightly distributed test suite to check

00:02:23,049 --> 00:02:30,850
that our C++ code is portable on various

00:02:26,290 --> 00:02:33,640
compilers and we also tried to make to

00:02:30,850 --> 00:02:35,740
developer meetings a year in Europe

00:02:33,640 --> 00:02:38,660
mostly

00:02:35,740 --> 00:02:43,040
the typical workflow of the product of

00:02:38,660 --> 00:02:45,200
the project is that we receive some new

00:02:43,040 --> 00:02:47,960
contributions in the form of submission

00:02:45,200 --> 00:02:52,010
of specifications and these are reviewed

00:02:47,960 --> 00:02:56,780
by an editorial board of about 12% now

00:02:52,010 --> 00:02:59,180
and this board decides and checked for

00:02:56,780 --> 00:03:01,940
uniformity of the specifications with

00:02:59,180 --> 00:03:05,090
the rest of the library now the value

00:03:01,940 --> 00:03:07,670
for the contributors is that while they

00:03:05,090 --> 00:03:10,280
get integrated into this larger seagull

00:03:07,670 --> 00:03:13,430
community they gain visibility in this

00:03:10,280 --> 00:03:16,880
material project and we also try to push

00:03:13,430 --> 00:03:19,490
for model where accepted contributions

00:03:16,880 --> 00:03:22,220
have a value equivalent to a publication

00:03:19,490 --> 00:03:27,440
which is important for the research

00:03:22,220 --> 00:03:29,930
domain now some commercial users which

00:03:27,440 --> 00:03:35,000
have both parts of sigil for various

00:03:29,930 --> 00:03:37,490
applications they come from lots of

00:03:35,000 --> 00:03:42,320
different application domains so like

00:03:37,490 --> 00:03:45,860
GIS VLSI medical imaging and this are

00:03:42,320 --> 00:03:48,290
all in needs of geometric computing so

00:03:45,860 --> 00:03:52,970
we provide fundamental geometric

00:03:48,290 --> 00:03:56,450
building blocks let's say now let me

00:03:52,970 --> 00:03:59,840
give some numbers to summarize this the

00:03:56,450 --> 00:04:02,450
project as of the current public release

00:03:59,840 --> 00:04:05,540
three point three so this is a pretty

00:04:02,450 --> 00:04:08,690
large C++ project now so about six

00:04:05,540 --> 00:04:11,030
hundred thousand lines of code it gets

00:04:08,690 --> 00:04:13,970
downloaded ten thousand times a year

00:04:11,030 --> 00:04:18,020
plus it is also part of some major Linux

00:04:13,970 --> 00:04:21,049
distributions the manual is also pretty

00:04:18,020 --> 00:04:23,300
extensive so three thousand and five

00:04:21,049 --> 00:04:25,790
hundred pages and there are also a few

00:04:23,300 --> 00:04:27,200
thousands of subscribers to the the

00:04:25,790 --> 00:04:31,160
announcement and discussion mailing

00:04:27,200 --> 00:04:32,900
lists which are directive the library

00:04:31,160 --> 00:04:35,950
itself is not really monolithic it's

00:04:32,900 --> 00:04:39,440
more collection of classes of functions

00:04:35,950 --> 00:04:42,680
for individual data structures which

00:04:39,440 --> 00:04:46,789
Andris will detail later and we count

00:04:42,680 --> 00:04:49,030
them as roughly 100 there are now 60

00:04:46,789 --> 00:04:52,390
commercial customers of Siegen

00:04:49,030 --> 00:04:57,040
and currently about 20 active developers

00:04:52,390 --> 00:05:00,190
part-time so and we try to issue when we

00:04:57,040 --> 00:05:03,100
use a year more or less that is what we

00:05:00,190 --> 00:05:06,190
are heading for and as far as licenses

00:05:03,100 --> 00:05:08,350
concern so sigil is open-source there is

00:05:06,190 --> 00:05:10,960
an open-source license which is split

00:05:08,350 --> 00:05:13,780
between the LGPL and the qpl depending

00:05:10,960 --> 00:05:16,420
on the parts and additionally to that

00:05:13,780 --> 00:05:18,820
there are some commercial licenses which

00:05:16,420 --> 00:05:23,380
are available through a geometry

00:05:18,820 --> 00:05:30,550
factoring okay so I will know that one

00:05:23,380 --> 00:05:32,470
dress gives you a to our CG on from the

00:05:30,550 --> 00:05:34,300
manual pages squeezing that in twenty

00:05:32,470 --> 00:05:37,120
minutes will kind of be difficult so

00:05:34,300 --> 00:05:41,169
what I will do instead is I give you a

00:05:37,120 --> 00:05:43,210
Taurus Eagle picking out of some of the

00:05:41,169 --> 00:05:44,620
data structures we have and giving a

00:05:43,210 --> 00:05:47,820
kind of highlight of what's special

00:05:44,620 --> 00:05:51,130
about this particular data structure so

00:05:47,820 --> 00:05:53,260
in the Siegel manual they are kinda they

00:05:51,130 --> 00:05:54,610
are kind of chapters so we regrouped all

00:05:53,260 --> 00:05:56,590
these packages we have in say

00:05:54,610 --> 00:05:57,100
triangulations boolean operation six

00:05:56,590 --> 00:06:01,390
like that

00:05:57,100 --> 00:06:02,890
okay when we say a package is over when

00:06:01,390 --> 00:06:05,169
we say your software components of

00:06:02,890 --> 00:06:08,740
building box itself it's C++ classes

00:06:05,169 --> 00:06:10,750
with very rich API so right I mean the

00:06:08,740 --> 00:06:14,169
manual pages are about the API okay

00:06:10,750 --> 00:06:15,790
don't be afraid about 3,500 manual pages

00:06:14,169 --> 00:06:18,550
there are 100 packages so in average

00:06:15,790 --> 00:06:20,590
it's a 30 manual pages per package so

00:06:18,550 --> 00:06:22,870
it's not a huge thing that you have to

00:06:20,590 --> 00:06:26,800
study first in order to get started okay

00:06:22,870 --> 00:06:28,600
so these data structures what they based

00:06:26,800 --> 00:06:31,000
on what they were the kind of foundation

00:06:28,600 --> 00:06:33,550
what they run run on is in The Seagull

00:06:31,000 --> 00:06:37,030
kernel and we will speak about that next

00:06:33,550 --> 00:06:40,060
so the kernel it kind of wraps up the

00:06:37,030 --> 00:06:42,220
elementary types like points segments

00:06:40,060 --> 00:06:44,950
are so elementary geometric entities

00:06:42,220 --> 00:06:47,110
okay then next and you have predicates

00:06:44,950 --> 00:06:49,479
and so predicates are things like a an

00:06:47,110 --> 00:06:52,479
orientation test so as a Mauser so we

00:06:49,479 --> 00:06:54,400
have three points P Q R they perform a

00:06:52,479 --> 00:06:56,380
left turn when you are from P to Q to R

00:06:54,400 --> 00:07:00,160
it's a left on those 3 are collinear

00:06:56,380 --> 00:07:03,020
okay or things like an incircle

00:07:00,160 --> 00:07:07,370
predicate so you have three points

00:07:03,020 --> 00:07:09,890
you are you have which define a triangle

00:07:07,370 --> 00:07:12,110
which defines the circumcircle and you

00:07:09,890 --> 00:07:14,300
want to know four point s does it lie

00:07:12,110 --> 00:07:16,310
inside the circumcircle of the triangle

00:07:14,300 --> 00:07:17,990
does it like outside or is it Co

00:07:16,310 --> 00:07:21,200
circular is it on the is it on the

00:07:17,990 --> 00:07:22,700
circle okay then the third category of

00:07:21,200 --> 00:07:24,440
things you find in the kernel its

00:07:22,700 --> 00:07:28,370
constructions constructions means that

00:07:24,440 --> 00:07:31,160
you take you take several geometric

00:07:28,370 --> 00:07:33,800
object and you compute new entities like

00:07:31,160 --> 00:07:36,170
an intersection point or given three

00:07:33,800 --> 00:07:38,240
points you compute the center of the

00:07:36,170 --> 00:07:41,900
circumcircle okay these are predicate

00:07:38,240 --> 00:07:43,400
constructions called random those things

00:07:41,900 --> 00:07:45,260
are they're a little bit tricky to deal

00:07:43,400 --> 00:07:47,810
with with floating-point arithmetic and

00:07:45,260 --> 00:07:51,290
so then later we'll speak about how to

00:07:47,810 --> 00:07:54,140
how to get that stuff stuff down so now

00:07:51,290 --> 00:07:56,090
let's let's start with this guided tour

00:07:54,140 --> 00:07:59,690
through Siegel so there's one big

00:07:56,090 --> 00:08:02,450
chapters triangulations so triangulation

00:07:59,690 --> 00:08:04,160
so you have these people you have the s

00:08:02,450 --> 00:08:06,080
input these blue points there are points

00:08:04,160 --> 00:08:10,460
in the plane and you hook them up with

00:08:06,080 --> 00:08:11,570
triangles so that's the the that it's

00:08:10,460 --> 00:08:13,280
all covered with triangles

00:08:11,570 --> 00:08:15,440
okay that you have the decomposition in

00:08:13,280 --> 00:08:17,690
triangles anthem so there are many

00:08:15,440 --> 00:08:19,550
possible triangles and one which is

00:08:17,690 --> 00:08:21,260
which is interesting it's the dual only

00:08:19,550 --> 00:08:25,340
triangulation which has the property

00:08:21,260 --> 00:08:26,960
data for all triangles for all triangles

00:08:25,340 --> 00:08:28,460
of the triangulation if you draw the

00:08:26,960 --> 00:08:30,680
circum circle around and what we just

00:08:28,460 --> 00:08:32,390
defined before there is no other of

00:08:30,680 --> 00:08:36,080
these blue points which lies inside the

00:08:32,390 --> 00:08:37,880
circle so which makes the triangles kind

00:08:36,080 --> 00:08:40,340
of nicely shaped on so they are not

00:08:37,880 --> 00:08:42,200
elongated because let's have a look if

00:08:40,340 --> 00:08:44,720
you if you flipped this edge so we

00:08:42,200 --> 00:08:46,430
replace this one by that one this one is

00:08:44,720 --> 00:08:48,260
not the lonely because if you take this

00:08:46,430 --> 00:08:50,420
triangle you draw on the circumcircle

00:08:48,260 --> 00:08:52,250
this this point this vertex of the

00:08:50,420 --> 00:08:54,790
triangulation lies lies inside it okay

00:08:52,250 --> 00:08:57,770
that's not that's not a lonely okay

00:08:54,790 --> 00:08:59,810
the data structures we provide they are

00:08:57,770 --> 00:09:02,990
they are fully dynamic that means you

00:08:59,810 --> 00:09:04,820
can insert remove a vertices oh and the

00:09:02,990 --> 00:09:09,620
data structure gets updated on the fly

00:09:04,820 --> 00:09:11,360
so they are decently fast there are can

00:09:09,620 --> 00:09:13,640
kinetic versions which means that the

00:09:11,360 --> 00:09:16,220
points they can fly along trajectories

00:09:13,640 --> 00:09:16,910
and at discrete time steps the data

00:09:16,220 --> 00:09:20,540
structure gets

00:09:16,910 --> 00:09:22,400
data okay then there are versions of

00:09:20,540 --> 00:09:26,080
triangulations which can incorporate

00:09:22,400 --> 00:09:28,580
constraints so say a brake line sir in

00:09:26,080 --> 00:09:30,980
brake lines in maps or road networks or

00:09:28,580 --> 00:09:32,600
things like that and the 2d

00:09:30,980 --> 00:09:35,030
triangulations they can use for terrain

00:09:32,600 --> 00:09:37,490
so terrains are not really 3d date they

00:09:35,030 --> 00:09:40,220
are two and a half D so they're in the

00:09:37,490 --> 00:09:42,500
plane and it's at each XY coordinate you

00:09:40,220 --> 00:09:45,080
have elevation okay which which defines

00:09:42,500 --> 00:09:49,460
right the terrain okay let's have a look

00:09:45,080 --> 00:09:51,800
at some some application of one of our

00:09:49,460 --> 00:09:55,370
users who provided us screenshots what

00:09:51,800 --> 00:09:57,560
they do is on a train modeling and they

00:09:55,370 --> 00:10:00,230
do watershed analysis so what you see

00:09:57,560 --> 00:10:03,710
here is the mouth as a it's a hill in a

00:10:00,230 --> 00:10:08,150
mind you know enter you see the ramp so

00:10:03,710 --> 00:10:12,080
where the lorries go up or to to deposit

00:10:08,150 --> 00:10:15,410
material okay and so what they have as

00:10:12,080 --> 00:10:17,840
input is very regular a very regular

00:10:15,410 --> 00:10:20,030
grid plus elevation so yeah digital

00:10:17,840 --> 00:10:22,550
elevation model plus constraints so

00:10:20,030 --> 00:10:24,830
these are the kind of the road networks

00:10:22,550 --> 00:10:26,570
on this on this hill and what they do

00:10:24,830 --> 00:10:29,030
with them they use our dallona

00:10:26,570 --> 00:10:32,500
triangulation to to kind of re measure

00:10:29,030 --> 00:10:35,030
this quad mesh to a triangular measure

00:10:32,500 --> 00:10:37,010
which has which has less faces okay

00:10:35,030 --> 00:10:40,040
because of the watershed analysis needs

00:10:37,010 --> 00:10:43,310
a spouse as possible model which is

00:10:40,040 --> 00:10:48,320
still good enough to represent her the

00:10:43,310 --> 00:10:49,970
real terrain I mentioned constraints so

00:10:48,320 --> 00:10:52,160
when you have a triangulation like this

00:10:49,970 --> 00:10:54,590
one which is rather regular and if you

00:10:52,160 --> 00:10:56,360
insert constraints now in red so these

00:10:54,590 --> 00:10:58,730
constraints have to be respect that you

00:10:56,360 --> 00:11:00,260
cannot have triangles that that that

00:10:58,730 --> 00:11:02,690
cross or constraint so in red you have

00:11:00,260 --> 00:11:04,510
to constraint when the constraints are

00:11:02,690 --> 00:11:06,950
rather large compared to the average

00:11:04,510 --> 00:11:09,290
triangle the average edge of the

00:11:06,950 --> 00:11:11,060
triangulation you end up with nasty

00:11:09,290 --> 00:11:13,340
triangles so if you run simulations so

00:11:11,060 --> 00:11:15,320
so these are not these flattish

00:11:13,340 --> 00:11:17,930
triangles are not very good so therefore

00:11:15,320 --> 00:11:22,940
for numr well for numerical reasons okay

00:11:17,930 --> 00:11:24,670
so what what one user of us what of the

00:11:22,940 --> 00:11:28,610
secret software what he did he used our

00:11:24,670 --> 00:11:29,930
conforming algorithm so which which has

00:11:28,610 --> 00:11:32,090
the freedom to add additional

00:11:29,930 --> 00:11:34,580
on the constraint to make the triangles

00:11:32,090 --> 00:11:36,710
looking nice okay but still if you look

00:11:34,580 --> 00:11:39,200
here for example you have you still have

00:11:36,710 --> 00:11:42,170
elongated triangles so what you also

00:11:39,200 --> 00:11:43,820
have in sigil is deal only meshes now

00:11:42,170 --> 00:11:46,340
the additional degree of freedom is ER

00:11:43,820 --> 00:11:48,710
the algorithm is allowed to to add more

00:11:46,340 --> 00:11:51,170
points so not only on the constraints

00:11:48,710 --> 00:11:52,150
but also inside the triangles okay enter

00:11:51,170 --> 00:11:54,740
now

00:11:52,150 --> 00:11:56,660
now all the triangles have this deal

00:11:54,740 --> 00:11:59,870
only property so which which makes the

00:11:56,660 --> 00:12:03,320
triangles nicely shaped okay now let's

00:11:59,870 --> 00:12:05,180
zoom you can end up with many points

00:12:03,320 --> 00:12:06,770
because it can be necessary to to add

00:12:05,180 --> 00:12:09,350
many points to enforce this tool only

00:12:06,770 --> 00:12:11,480
property so just assume shows because

00:12:09,350 --> 00:12:13,580
the constraint was was very close to one

00:12:11,480 --> 00:12:15,710
of these grid points you end up with

00:12:13,580 --> 00:12:16,970
many small triangles but I mean it's

00:12:15,710 --> 00:12:20,960
unavoidable that so it's kind of

00:12:16,970 --> 00:12:26,660
intrinsic to to that okay another

00:12:20,960 --> 00:12:30,020
example so of of a measure so doing odd

00:12:26,660 --> 00:12:31,910
on North America in the chapter

00:12:30,020 --> 00:12:34,180
triangulations we have the same thing in

00:12:31,910 --> 00:12:37,730
3d in 3d

00:12:34,180 --> 00:12:41,360
well again it's fully dynamic it's it's

00:12:37,730 --> 00:12:43,190
very fast and enter in 3d you don't hook

00:12:41,360 --> 00:12:45,290
up triangles but you hook up a

00:12:43,190 --> 00:12:47,300
tetrahedron okay the the tetrahedron

00:12:45,290 --> 00:12:49,130
that they what they do they decompose

00:12:47,300 --> 00:12:51,650
space okay you you have a space with

00:12:49,130 --> 00:12:54,260
cetra Hydra that that are connected so

00:12:51,650 --> 00:12:56,170
you have neighboring tetrahedra and

00:12:54,260 --> 00:12:58,910
neighboring tetrahedra they somehow

00:12:56,170 --> 00:13:01,970
sandwich in between triangles okay and

00:12:58,910 --> 00:13:04,790
so that's very nice the thing is what

00:13:01,970 --> 00:13:07,010
what met what some several uses of 3d

00:13:04,790 --> 00:13:09,830
triangulations do they want to model

00:13:07,010 --> 00:13:11,360
surfaces embedded in space okay then

00:13:09,830 --> 00:13:13,280
what they want to do is they want to

00:13:11,360 --> 00:13:15,200
construct surfaces that are not self

00:13:13,280 --> 00:13:16,760
intersecting because well that does not

00:13:15,200 --> 00:13:18,740
really exist self intersecting surfaces

00:13:16,760 --> 00:13:20,630
at least when we speak about something

00:13:18,740 --> 00:13:23,150
that is material okay that that you want

00:13:20,630 --> 00:13:25,280
to avoid so the fact that the triangles

00:13:23,150 --> 00:13:28,610
are sandwiched between tetrahedra makes

00:13:25,280 --> 00:13:30,590
that when for the surface you construct

00:13:28,610 --> 00:13:33,830
you take those two a subset of those

00:13:30,590 --> 00:13:36,260
triangles but by construction they

00:13:33,830 --> 00:13:39,110
cannot intersect ER so they have a nice

00:13:36,260 --> 00:13:41,540
at least you have a nice soft surface ER

00:13:39,110 --> 00:13:43,800
with with with this respecter okay

00:13:41,540 --> 00:13:46,470
let's see at some examples

00:13:43,800 --> 00:13:48,440
in Seagal you find them something that

00:13:46,470 --> 00:13:55,530
computes surface meshes here you see a

00:13:48,440 --> 00:14:02,100
part of Cologne : input medical data

00:13:55,530 --> 00:14:05,190
so just voxels or 3d images output the D

00:14:02,100 --> 00:14:08,250
mesh for an ISO value in the image okay

00:14:05,190 --> 00:14:10,770
and this thing competes with marching

00:14:08,250 --> 00:14:13,290
hoops only that it's nicer because it's

00:14:10,770 --> 00:14:14,700
not that you you you you generate many

00:14:13,290 --> 00:14:16,470
many triangles and then you run

00:14:14,700 --> 00:14:18,030
simplification algorithms where you have

00:14:16,470 --> 00:14:20,850
almost no chance to get them

00:14:18,030 --> 00:14:23,430
topologically topological erected so

00:14:20,850 --> 00:14:25,680
this one kind of starts with a small

00:14:23,430 --> 00:14:27,990
mesh and refines where it's necessary to

00:14:25,680 --> 00:14:30,030
refine it okay so it's a that's very

00:14:27,990 --> 00:14:30,990
nice property and well it's important

00:14:30,030 --> 00:14:34,110
for getting this a topological

00:14:30,990 --> 00:14:36,750
correctness center in an example from

00:14:34,110 --> 00:14:39,000
one of our commercial users also while

00:14:36,750 --> 00:14:40,680
State University what they do they don't

00:14:39,000 --> 00:14:43,200
have as they also want to produce a

00:14:40,680 --> 00:14:44,940
surface mesh as input they don't have

00:14:43,200 --> 00:14:47,970
voxel data but they have a surface mesh

00:14:44,940 --> 00:14:50,400
they have for this very yeah I mean if

00:14:47,970 --> 00:14:53,250
you it's a very dense it's a very dense

00:14:50,400 --> 00:14:55,650
surface mesh okay enter here you see

00:14:53,250 --> 00:14:57,930
kind of the superposition offer the

00:14:55,650 --> 00:15:00,690
three did the 3d triangulation of the

00:14:57,930 --> 00:15:02,280
space of so in gray you see all these

00:15:00,690 --> 00:15:05,190
edges of the tetrahedra ization and

00:15:02,280 --> 00:15:07,170
these lie like facets these violet

00:15:05,190 --> 00:15:08,610
facets they are they are just embedded

00:15:07,170 --> 00:15:11,040
they are they are just sandwiched

00:15:08,610 --> 00:15:13,320
between between tetrahedra enter now

00:15:11,040 --> 00:15:15,690
they use this decomposition of space

00:15:13,320 --> 00:15:17,490
also to navigate around because the

00:15:15,690 --> 00:15:19,170
composition allows you just to to to to

00:15:17,490 --> 00:15:19,440
to explore neighborhoods or things like

00:15:19,170 --> 00:15:22,080
that

00:15:19,440 --> 00:15:23,640
okay enter so they produce so things

00:15:22,080 --> 00:15:25,950
like that so it's a rematching algorithm

00:15:23,640 --> 00:15:29,160
innocence in the chapter Voronoi

00:15:25,950 --> 00:15:32,010
diagrams so Voronoi diagrams are data

00:15:29,160 --> 00:15:34,590
structures for for encoding distances

00:15:32,010 --> 00:15:36,810
and for for for encoding proximity okay

00:15:34,590 --> 00:15:39,780
what you have here in the in red is the

00:15:36,810 --> 00:15:43,350
input it's a utility say a u.s. post

00:15:39,780 --> 00:15:45,870
office okay and now you it decomposes

00:15:43,350 --> 00:15:47,430
the plane in a kind of cells and so all

00:15:45,870 --> 00:15:49,590
those people who live in this cell

00:15:47,430 --> 00:15:51,210
should go to that that's the closest

00:15:49,590 --> 00:15:53,340
post office for them okay everybody

00:15:51,210 --> 00:15:54,600
living in this cell that's the closest

00:15:53,340 --> 00:15:57,480
post office okay that's that's what

00:15:54,600 --> 00:15:59,249
Voronoi for no diagrams about we have

00:15:57,480 --> 00:16:01,259
four points well we have it in 2d and 3d

00:15:59,249 --> 00:16:04,199
I mean on the on slide - you have a new

00:16:01,259 --> 00:16:08,790
today we have it we have it for circles

00:16:04,199 --> 00:16:11,519
four circles the kind of the the the

00:16:08,790 --> 00:16:14,279
arcs which which Express equidistance

00:16:11,519 --> 00:16:17,759
between two objects okay they become

00:16:14,279 --> 00:16:20,160
arcs of hyperbolas not straight segments

00:16:17,759 --> 00:16:23,040
so and we have it for four segments so

00:16:20,160 --> 00:16:27,749
when the inputs you have points or or

00:16:23,040 --> 00:16:30,629
segments on it again in blue it's a the

00:16:27,749 --> 00:16:32,639
I mean in in blue you see the boundaries

00:16:30,629 --> 00:16:36,269
the the edges of the runner diagram and

00:16:32,639 --> 00:16:38,579
so what a Voronoi edge is it's the the

00:16:36,269 --> 00:16:40,259
separate the boundary of two of two

00:16:38,579 --> 00:16:41,819
neighboring of two neighboring areas so

00:16:40,259 --> 00:16:43,829
when you are here so you're equally far

00:16:41,819 --> 00:16:48,119
away from this guy and from from this

00:16:43,829 --> 00:16:51,209
line okay that's and yeah remember basic

00:16:48,119 --> 00:16:53,129
math so parabola is defined by by a

00:16:51,209 --> 00:16:56,879
point and by by by this by this

00:16:53,129 --> 00:16:59,579
supporting line okay and the thing in

00:16:56,879 --> 00:17:02,039
siga what's nice about it is that this

00:16:59,579 --> 00:17:04,139
parabola it's um it's thought in a

00:17:02,039 --> 00:17:05,699
symbolic way so we do not discretize

00:17:04,139 --> 00:17:08,760
things and say okay well it's a parabola

00:17:05,699 --> 00:17:10,709
but let's let's polygon eyes it lets on

00:17:08,760 --> 00:17:14,069
the screen is polygons eyes because okay

00:17:10,709 --> 00:17:16,319
ultimately it's a that's but in memory

00:17:14,069 --> 00:17:18,809
and the data structure itself it's a

00:17:16,319 --> 00:17:22,819
it's an exact parabola okay and it's

00:17:18,809 --> 00:17:22,819
compact because it's just described by a

00:17:22,909 --> 00:17:27,480
defining line plus a plus this one point

00:17:25,709 --> 00:17:30,419
or a plus a start and an end pointer so

00:17:27,480 --> 00:17:32,220
it's a it's a it's a compact

00:17:30,419 --> 00:17:33,809
representation which is important if you

00:17:32,220 --> 00:17:35,820
want to treat big models and then then

00:17:33,809 --> 00:17:41,519
it must be compact you cannot describe

00:17:35,820 --> 00:17:42,990
the the Voronoi diagrams for segments

00:17:41,519 --> 00:17:45,510
they are also interesting because when

00:17:42,990 --> 00:17:49,649
you when you have segments that form up

00:17:45,510 --> 00:17:51,960
a polygon then the Voronoi diagram is a

00:17:49,649 --> 00:17:55,110
medial axis okay which is a well-known

00:17:51,960 --> 00:17:58,440
structure of morphology image and

00:17:55,110 --> 00:18:01,769
morphology things like that okay so the

00:17:58,440 --> 00:18:03,360
medial axis well it has it has this

00:18:01,769 --> 00:18:05,010
parabola arcs and for many people they

00:18:03,360 --> 00:18:06,720
don't like parabola arcs so much because

00:18:05,010 --> 00:18:09,029
well when you run see when you try to

00:18:06,720 --> 00:18:10,470
control CNC machines or so then well

00:18:09,029 --> 00:18:12,290
parabola access somehow they are not

00:18:10,470 --> 00:18:15,960
built into

00:18:12,290 --> 00:18:18,870
how you can move move tools so what what

00:18:15,960 --> 00:18:21,150
many people I mean we're several users

00:18:18,870 --> 00:18:23,280
which use an alternative to medial axis

00:18:21,150 --> 00:18:26,220
it's called straight skeleton so it's

00:18:23,280 --> 00:18:29,280
also a skeleton of an input object okay

00:18:26,220 --> 00:18:32,370
but the other thing is that here are no

00:18:29,280 --> 00:18:34,380
parabola axial so which yeah which makes

00:18:32,370 --> 00:18:35,970
it which makes it interesting as I said

00:18:34,380 --> 00:18:38,220
before for CNC for milling machines

00:18:35,970 --> 00:18:40,950
printing machines okay and people use it

00:18:38,220 --> 00:18:43,110
for computing offsets and they need

00:18:40,950 --> 00:18:47,190
offsets because they want to move a

00:18:43,110 --> 00:18:50,010
machine around to to mill okay to to

00:18:47,190 --> 00:18:53,280
produce something which has this given

00:18:50,010 --> 00:18:57,180
this different shape in the chapter

00:18:53,280 --> 00:18:58,830
bounding volume so the fundamental

00:18:57,180 --> 00:19:00,450
course on computer geometry starts with

00:18:58,830 --> 00:19:01,830
convex hull what's a convex hull you are

00:19:00,450 --> 00:19:03,120
given an object and you want to know

00:19:01,830 --> 00:19:06,030
what's the smallest polyhedron

00:19:03,120 --> 00:19:08,190
containing it which is something

00:19:06,030 --> 00:19:10,860
important because when you when you want

00:19:08,190 --> 00:19:13,830
to say you you have collision detection

00:19:10,860 --> 00:19:16,080
so before figuring out do I hit this

00:19:13,830 --> 00:19:19,500
bunny in the game with my with my hands

00:19:16,080 --> 00:19:21,860
if you better first test do I hit the

00:19:19,500 --> 00:19:24,330
bounding box of the bunny or do I hit

00:19:21,860 --> 00:19:26,550
the convex hull of the bunny because

00:19:24,330 --> 00:19:29,460
that's computationally much cheaper okay

00:19:26,550 --> 00:19:31,680
and so then we have things like the

00:19:29,460 --> 00:19:34,830
bounding sphere it's a smallest sphere

00:19:31,680 --> 00:19:37,260
containing a point set or we have things

00:19:34,830 --> 00:19:39,300
like a bounding sphere of spheres you

00:19:37,260 --> 00:19:40,830
have a collection of input sphere center

00:19:39,300 --> 00:19:47,040
okay and you want to know what's the

00:19:40,830 --> 00:19:49,650
smallest sphere so there yeah in the

00:19:47,040 --> 00:19:51,510
chapter boolean operation so we have we

00:19:49,650 --> 00:19:53,790
have an eighth Pole etre they are also

00:19:51,510 --> 00:19:57,570
it's a professor in Switzerland called

00:19:53,790 --> 00:19:59,600
some professor nayfeh so it's it's a

00:19:57,570 --> 00:20:05,760
it's a very sound mathematical

00:19:59,600 --> 00:20:07,860
definition of how how objects how

00:20:05,760 --> 00:20:10,320
objects should be should be represented

00:20:07,860 --> 00:20:12,300
it's sounds which makes that it's closed

00:20:10,320 --> 00:20:14,490
on the boolean operations which has

00:20:12,300 --> 00:20:16,590
implication that you can have you can

00:20:14,490 --> 00:20:19,230
have an object within a 1d antenna

00:20:16,590 --> 00:20:21,150
sticking out things that that usually

00:20:19,230 --> 00:20:23,550
modeling tools are kind of regular eyes

00:20:21,150 --> 00:20:24,690
away they just throw it away because if

00:20:23,550 --> 00:20:26,190
you want to manufacture

00:20:24,690 --> 00:20:28,679
so well something which is

00:20:26,190 --> 00:20:30,330
one-dimensional it makes no sense right

00:20:28,679 --> 00:20:32,070
you cannot you can open factor it but

00:20:30,330 --> 00:20:34,619
there are applications where you want to

00:20:32,070 --> 00:20:37,649
you want to maintain a one dimensional

00:20:34,619 --> 00:20:39,720
features or two or to the L or two

00:20:37,649 --> 00:20:42,479
dimensional features so we don't enforce

00:20:39,720 --> 00:20:44,549
this this regular read a curation and

00:20:42,479 --> 00:20:46,799
well boolean operations is you have that

00:20:44,549 --> 00:20:49,349
object and you want to subtract this

00:20:46,799 --> 00:20:50,759
object and you obtain that object okay

00:20:49,349 --> 00:20:52,259
that's that's what will your operations

00:20:50,759 --> 00:20:58,200
about so I should have shown that before

00:20:52,259 --> 00:21:00,599
I progress the thing is because we use

00:20:58,200 --> 00:21:03,629
the exact computing paradigm so when we

00:21:00,599 --> 00:21:05,820
speak later bout deter these operations

00:21:03,629 --> 00:21:08,460
so that they are kind of you can give

00:21:05,820 --> 00:21:09,869
whatever Ness the input it will it will

00:21:08,460 --> 00:21:13,710
not crash and it will produce a result

00:21:09,869 --> 00:21:16,649
okay that's all it's kind of well that's

00:21:13,710 --> 00:21:18,149
what it's supposed to let's switch to

00:21:16,649 --> 00:21:20,429
another thing our boolean operations

00:21:18,149 --> 00:21:23,879
what we see here is a printed circuit

00:21:20,429 --> 00:21:26,940
board ok enter but given given as a

00:21:23,879 --> 00:21:29,609
given as CAD file let's so let's let's

00:21:26,940 --> 00:21:32,309
zoom in on enter what we see is that

00:21:29,609 --> 00:21:34,529
what looked like a little black daughter

00:21:32,309 --> 00:21:36,210
is in reality I mean that was a little

00:21:34,529 --> 00:21:38,309
black dot we saw in the the contact that

00:21:36,210 --> 00:21:40,529
we saw in the very beginning so when you

00:21:38,309 --> 00:21:42,269
zoom in then you see that the little

00:21:40,529 --> 00:21:44,820
black dot consists of lots of little

00:21:42,269 --> 00:21:47,220
cigars which are again tooling parser so

00:21:44,820 --> 00:21:50,070
it's a sense it's a tool moving around

00:21:47,220 --> 00:21:51,869
like that stopping here and the tool has

00:21:50,070 --> 00:21:54,570
a round cap and that's why whites round

00:21:51,869 --> 00:21:56,249
at the end ok now this this printed

00:21:54,570 --> 00:21:58,859
circuit board was kind of constructed by

00:21:56,249 --> 00:22:00,840
moving this pen with which has a certain

00:21:58,859 --> 00:22:04,580
weight around and covering the thing in

00:22:00,840 --> 00:22:10,019
term what we offer is boolean operations

00:22:04,580 --> 00:22:12,179
on polygons where where the the edges of

00:22:10,019 --> 00:22:13,889
the polygon can be arbitrary curves

00:22:12,179 --> 00:22:16,619
well it can be can be colleagues okay so

00:22:13,889 --> 00:22:18,179
it can be a arcs of circles for example

00:22:16,619 --> 00:22:19,859
and again the important thing is we

00:22:18,179 --> 00:22:21,090
don't do it with discretization the

00:22:19,859 --> 00:22:23,099
thing is that when you start

00:22:21,090 --> 00:22:25,649
discretizing or the model you saw

00:22:23,099 --> 00:22:27,989
initially or well you need to you need

00:22:25,649 --> 00:22:31,559
not you need a lot of memory okay and so

00:22:27,989 --> 00:22:33,239
you also you have no guarantee that that

00:22:31,559 --> 00:22:35,690
I mean you have to pay attention that

00:22:33,239 --> 00:22:38,720
you use sample you

00:22:35,690 --> 00:22:40,129
you approximate the circular arc dense

00:22:38,720 --> 00:22:43,690
enough for so that you guarantee that

00:22:40,129 --> 00:22:45,620
the output is is corrected

00:22:43,690 --> 00:22:49,250
parameterization parameterization is

00:22:45,620 --> 00:22:51,019
about flattening cows it's a if you want

00:22:49,250 --> 00:22:54,049
to put it in front of your chimney or if

00:22:51,019 --> 00:22:57,950
you want to put texture mapping on an

00:22:54,049 --> 00:23:01,460
object now here what we did is we you

00:22:57,950 --> 00:23:03,830
there's the there's a cup there's a cut

00:23:01,460 --> 00:23:06,139
line cut line under the cow enter so

00:23:03,830 --> 00:23:07,820
flattened it looks like that here are

00:23:06,139 --> 00:23:10,159
the eyes because the things when you

00:23:07,820 --> 00:23:12,049
flatten something out there's there is

00:23:10,159 --> 00:23:14,029
distortion okay you cannot I mean take a

00:23:12,049 --> 00:23:19,039
half of an orange so you cannot if you

00:23:14,029 --> 00:23:21,590
press it down it just yeah just it

00:23:19,039 --> 00:23:23,960
doesn't stay here that doesn't keep as

00:23:21,590 --> 00:23:25,399
this so the same here so if you if you

00:23:23,960 --> 00:23:27,529
flatten objects are you

00:23:25,399 --> 00:23:29,299
you have to distort so color coded you

00:23:27,529 --> 00:23:32,299
see how big this distortion is so it's

00:23:29,299 --> 00:23:35,480
very it was very big cutter at the icer

00:23:32,299 --> 00:23:38,269
okay so now in Siegel you find her the

00:23:35,480 --> 00:23:40,519
major we find implementations for the

00:23:38,269 --> 00:23:44,120
major methods of surface

00:23:40,519 --> 00:23:46,009
parameterization then mesh

00:23:44,120 --> 00:23:49,220
simplification you have an input mesh on

00:23:46,009 --> 00:23:51,799
your on the left and if you only want to

00:23:49,220 --> 00:23:53,450
to put texture on it

00:23:51,799 --> 00:23:55,580
then this is an overkill you don't need

00:23:53,450 --> 00:23:57,590
that fine triangles so simplification

00:23:55,580 --> 00:23:59,690
algorithms what they do is they can't

00:23:57,590 --> 00:24:02,000
they they construct a new surface

00:23:59,690 --> 00:24:05,240
measure which has far less triangles but

00:24:02,000 --> 00:24:08,509
which maintains the the essential

00:24:05,240 --> 00:24:13,100
features okay I mean you see that this

00:24:08,509 --> 00:24:15,169
I'd say this this V color of it kind of

00:24:13,100 --> 00:24:17,480
you you you find it again or the nose

00:24:15,169 --> 00:24:21,799
remains you know so the wing you have

00:24:17,480 --> 00:24:24,590
elongated edges at the at this at this

00:24:21,799 --> 00:24:29,450
card at this part of the wing so here

00:24:24,590 --> 00:24:30,950
maybe two two highlights as well now the

00:24:29,450 --> 00:24:33,110
highlight here is that the way it was

00:24:30,950 --> 00:24:34,490
implemented so we were inspired when we

00:24:33,110 --> 00:24:37,070
did it we were inspired by the boost

00:24:34,490 --> 00:24:40,399
graph library which which very nicely

00:24:37,070 --> 00:24:42,919
separates algorithms running on graphs

00:24:40,399 --> 00:24:45,460
are from data structures representing

00:24:42,919 --> 00:24:47,840
graphs so we applied the same thing to

00:24:45,460 --> 00:24:49,250
physical I mean if just if you know if

00:24:47,840 --> 00:24:51,110
you know what

00:24:49,250 --> 00:24:52,580
if you know a little bit about bgl then

00:24:51,110 --> 00:24:56,600
this speaks to you otherwise that you

00:24:52,580 --> 00:24:59,000
want in the section detection the things

00:24:56,600 --> 00:25:00,740
when you simplify then you have a high

00:24:59,000 --> 00:25:03,470
chance that you end up with triangles

00:25:00,740 --> 00:25:05,930
that intersect so what you have and what

00:25:03,470 --> 00:25:08,030
you have and see so let's so let's look

00:25:05,930 --> 00:25:10,760
at this model let's zoom in color-coded

00:25:08,030 --> 00:25:12,850
here you see an area which is which is

00:25:10,760 --> 00:25:14,990
red so let's zoom in again you see that

00:25:12,850 --> 00:25:16,850
what happens there that the

00:25:14,990 --> 00:25:19,100
simplification algorithm somehow it

00:25:16,850 --> 00:25:21,080
mists the surface up and so the surface

00:25:19,100 --> 00:25:23,270
became self intersecting by by the

00:25:21,080 --> 00:25:26,660
simplification so in Syria what you have

00:25:23,270 --> 00:25:28,310
is an intersection detection algorithm

00:25:26,660 --> 00:25:33,170
which is rather generic in the sense

00:25:28,310 --> 00:25:36,950
that the user provides a provides the

00:25:33,170 --> 00:25:39,410
bounding box for the object so you want

00:25:36,950 --> 00:25:41,600
her to interested to to detect the

00:25:39,410 --> 00:25:44,780
intersection of the user provides a

00:25:41,600 --> 00:25:47,270
callback that the algorithm calls for

00:25:44,780 --> 00:25:51,740
for any pair of objects entities like I

00:25:47,270 --> 00:25:54,440
mean in this case two triangles who over

00:25:51,740 --> 00:25:58,070
Yahoo overlapping and so it comes in two

00:25:54,440 --> 00:26:00,050
flavors one for just the set of objects

00:25:58,070 --> 00:26:02,180
and you get all pairwise intersections

00:26:00,050 --> 00:26:04,670
or you have a flavor webcam so you have

00:26:02,180 --> 00:26:07,940
you have two sets a and B and you get

00:26:04,670 --> 00:26:09,680
you get all objects from one set and

00:26:07,940 --> 00:26:12,440
from the other set which are kind of in

00:26:09,680 --> 00:26:14,180
conflict enter the callback gets gets

00:26:12,440 --> 00:26:16,010
applied and this is the single sir it's

00:26:14,180 --> 00:26:20,360
tuned for spittin so it's so it's yeah

00:26:16,010 --> 00:26:21,890
it's tuned for speed things we have

00:26:20,360 --> 00:26:24,350
integral things like estimation of

00:26:21,890 --> 00:26:27,410
curvatures so I mean here you see a well

00:26:24,350 --> 00:26:28,880
on the model we saw before the maximum

00:26:27,410 --> 00:26:30,980
curvature here you see it on the lip so

00:26:28,880 --> 00:26:33,170
if you see if it goes it goes around the

00:26:30,980 --> 00:26:34,640
lips and min curvature goes along the

00:26:33,170 --> 00:26:37,760
lips on the same here on the wing so you

00:26:34,640 --> 00:26:40,400
see it goes it goes around to this the

00:26:37,760 --> 00:26:44,030
cylindrical part and this goes along the

00:26:40,400 --> 00:26:46,430
cylinder the pocket part so what what

00:26:44,030 --> 00:26:48,560
these kind of estimators are used for is

00:26:46,430 --> 00:26:50,870
for rich detection when you when you

00:26:48,560 --> 00:26:52,820
have a you have models so you have

00:26:50,870 --> 00:26:55,280
scanned them with a scanning device you

00:26:52,820 --> 00:26:57,050
have a polyhedral model of that and now

00:26:55,280 --> 00:26:59,360
you want to figure out where is the rich

00:26:57,050 --> 00:27:02,040
where's the sharp edge huh so as rich of

00:26:59,360 --> 00:27:06,270
a table things like that

00:27:02,040 --> 00:27:08,940
okay yeah the the last example natural

00:27:06,270 --> 00:27:12,420
neighbor interpolation so some so what

00:27:08,940 --> 00:27:15,150
you see here on the right is a it's

00:27:12,420 --> 00:27:19,260
weather data it's a every red dot is a

00:27:15,150 --> 00:27:20,490
city in Japan enter the L enter it's a

00:27:19,260 --> 00:27:22,170
little bit higher if it's a little bit

00:27:20,490 --> 00:27:24,090
warmer enter what weather news wanted

00:27:22,170 --> 00:27:26,040
you to do is they wanted to interpolate

00:27:24,090 --> 00:27:28,370
weather data on a regular grater so on

00:27:26,040 --> 00:27:30,930
this on this white pointer and they used

00:27:28,370 --> 00:27:32,400
natural neighbor interpolation from from

00:27:30,930 --> 00:27:34,070
seagull for data so again here you have

00:27:32,400 --> 00:27:37,260
your you have your points which define

00:27:34,070 --> 00:27:39,090
temperatures and what you do if you want

00:27:37,260 --> 00:27:42,300
to interpolate for this guy the

00:27:39,090 --> 00:27:45,840
temperature at this point so you take in

00:27:42,300 --> 00:27:48,960
account those who are who are neighbors

00:27:45,840 --> 00:27:51,120
in the vernal diagram you first compute

00:27:48,960 --> 00:27:53,340
the Voronoi diagram here in black of of

00:27:51,120 --> 00:27:56,760
only the red guys and you see this guy

00:27:53,340 --> 00:27:59,670
influences this zone so that that's city

00:27:56,760 --> 00:28:01,740
influences this zone and so on and now

00:27:59,670 --> 00:28:05,100
you kind of virtually are you simulator

00:28:01,740 --> 00:28:07,530
inserting this this black this black

00:28:05,100 --> 00:28:10,890
daughter this new well the point for

00:28:07,530 --> 00:28:13,560
which you want to interpolate it claims

00:28:10,890 --> 00:28:16,170
this it claims influencing this zone or

00:28:13,560 --> 00:28:22,230
so it's Voronoi zone and now with the

00:28:16,170 --> 00:28:24,840
fraction offer of the area yeah the

00:28:22,230 --> 00:28:27,270
fraction of area contributed by by this

00:28:24,840 --> 00:28:29,790
city kind of info welders and says how

00:28:27,270 --> 00:28:31,950
how we have we waiter the temperature

00:28:29,790 --> 00:28:35,700
here to computer the the temperature at

00:28:31,950 --> 00:28:37,800
that point okay now to at least see some

00:28:35,700 --> 00:28:40,650
code in the beginning I said it's a C++

00:28:37,800 --> 00:28:44,040
class library so where's the C++ here we

00:28:40,650 --> 00:28:46,620
go hello world and Siegel as in any

00:28:44,040 --> 00:28:48,780
c-plus program you first includes some

00:28:46,620 --> 00:28:50,400
header files I told you that our day I

00:28:48,780 --> 00:28:52,500
mean you you include the Denali

00:28:50,400 --> 00:28:54,900
triangulation so the data structures you

00:28:52,500 --> 00:28:57,060
are interested in I told you that all

00:28:54,900 --> 00:28:58,950
our data structures need kernels or some

00:28:57,060 --> 00:29:01,020
providing points or orientation tests

00:28:58,950 --> 00:29:06,390
and such so we also have to include a

00:29:01,020 --> 00:29:07,830
kernel yeah we we make the longer name a

00:29:06,390 --> 00:29:09,630
little bit shorter using a type

00:29:07,830 --> 00:29:12,450
therefore so in the car the kernel

00:29:09,630 --> 00:29:13,740
provides us a point type there's the

00:29:12,450 --> 00:29:15,750
Delauney triangulation which is

00:29:13,740 --> 00:29:19,830
parameterize by by you colonel

00:29:15,750 --> 00:29:21,930
enter the Delauney triangulation it has

00:29:19,830 --> 00:29:24,870
vertices faces so it needs the entities

00:29:21,930 --> 00:29:27,690
to to refer to an T to two vertices and

00:29:24,870 --> 00:29:30,060
faces now the main routine comes and we

00:29:27,690 --> 00:29:35,790
allocated the lonely triangulation we

00:29:30,060 --> 00:29:37,800
insert points coming from standard in so

00:29:35,790 --> 00:29:41,070
this builds up the triangulation we saw

00:29:37,800 --> 00:29:45,690
on this very first slide now for the

00:29:41,070 --> 00:29:48,420
erection point 0 0 we determine the

00:29:45,690 --> 00:29:51,030
nearest vertex the closest vertex to the

00:29:48,420 --> 00:29:53,010
origin ok and we print that out I mean

00:29:51,030 --> 00:29:55,320
it's a stupid example you wouldn't run n

00:29:53,010 --> 00:29:57,510
log n algorithm for linear time problem

00:29:55,320 --> 00:30:01,520
it's only to illustrator to think so one

00:29:57,510 --> 00:30:05,040
thing is a templates all over the place

00:30:01,520 --> 00:30:07,200
so C will speak about templates and then

00:30:05,040 --> 00:30:09,960
this thing I said they are kernels so

00:30:07,200 --> 00:30:12,630
enter then the kernels come in different

00:30:09,960 --> 00:30:16,200
flavors for exact predicates in exact

00:30:12,630 --> 00:30:18,350
constructions and well Silvan will shed

00:30:16,200 --> 00:30:26,520
more light on that aspect

00:30:18,350 --> 00:30:29,460
thank you ok so now let me show you

00:30:26,520 --> 00:30:32,820
exactly how we use generic programming

00:30:29,460 --> 00:30:35,670
in Siegen and what is specific to sigil

00:30:32,820 --> 00:30:37,470
in generic programming so let me

00:30:35,670 --> 00:30:40,520
highlight the differences in overall

00:30:37,470 --> 00:30:47,190
general design between the STL and cigar

00:30:40,520 --> 00:30:49,770
in the STL you have algorithms you have

00:30:47,190 --> 00:30:54,450
some free-standing algorithms like STD

00:30:49,770 --> 00:30:59,370
sort for example and so this is this

00:30:54,450 --> 00:31:02,510
orange box here and these free-standing

00:30:59,370 --> 00:31:06,870
algorithms are completely decoupled from

00:31:02,510 --> 00:31:09,690
the underlying data structure sequence

00:31:06,870 --> 00:31:14,070
on which they run the interface with

00:31:09,690 --> 00:31:18,060
that through the iterator concept and so

00:31:14,070 --> 00:31:20,430
the iterator is representing a sequence

00:31:18,060 --> 00:31:23,250
which is usually stored in a container

00:31:20,430 --> 00:31:26,790
for example and this container store

00:31:23,250 --> 00:31:29,640
stores values the algorithm can query

00:31:26,790 --> 00:31:30,000
some properties on the values like an

00:31:29,640 --> 00:31:32,880
order

00:31:30,000 --> 00:31:36,720
for example through some factors which

00:31:32,880 --> 00:31:39,570
is also a concept this way you also have

00:31:36,720 --> 00:31:42,600
another set of algorithms which are more

00:31:39,570 --> 00:31:46,440
tightly coupled to the containers there

00:31:42,600 --> 00:31:48,120
are less generic I refer here to for

00:31:46,440 --> 00:31:50,670
example the sought member function of a

00:31:48,120 --> 00:31:55,170
standard list or the insert function of

00:31:50,670 --> 00:31:59,370
a standard set now with this picture in

00:31:55,170 --> 00:32:02,760
mind the reference the differences that

00:31:59,370 --> 00:32:05,760
we have in sigil is that the objects

00:32:02,760 --> 00:32:08,700
that we that we manipulate are not only

00:32:05,760 --> 00:32:13,410
sequences we have more complicated

00:32:08,700 --> 00:32:16,050
graphs and the geometry is also the

00:32:13,410 --> 00:32:18,150
geometry of points or curves in the

00:32:16,050 --> 00:32:22,590
plane or space is more complicated than

00:32:18,150 --> 00:32:26,610
just an ordering so the first main

00:32:22,590 --> 00:32:28,490
change is that we have to query the

00:32:26,610 --> 00:32:32,940
properties of the objects the points

00:32:28,490 --> 00:32:35,550
through several functors predicates when

00:32:32,940 --> 00:32:39,210
we have an algorithm usually one is not

00:32:35,550 --> 00:32:42,720
enough so we have some bundles of front

00:32:39,210 --> 00:32:44,660
rows typically which we gather in what

00:32:42,720 --> 00:32:49,140
we called the geometric traits class

00:32:44,660 --> 00:32:54,270
concept which is property of each

00:32:49,140 --> 00:32:57,510
algorithm another difference as I

00:32:54,270 --> 00:32:59,880
mentioned is that we do not only many

00:32:57,510 --> 00:33:01,920
great sequences so for example a convex

00:32:59,880 --> 00:33:03,780
all into these on your sequence but if

00:33:01,920 --> 00:33:05,970
you think of it in 3d it's already more

00:33:03,780 --> 00:33:08,940
complicated or triangulation in 2d is

00:33:05,970 --> 00:33:11,520
also more complicated so for some

00:33:08,940 --> 00:33:14,040
algorithms we have a graph interface

00:33:11,520 --> 00:33:16,920
which we have tried to base on the boost

00:33:14,040 --> 00:33:19,220
graph library concepts for graphs this

00:33:16,920 --> 00:33:23,070
allows to run the boost graph library

00:33:19,220 --> 00:33:28,410
algorithms on The Seagull data

00:33:23,070 --> 00:33:29,910
structures and we also have some let's

00:33:28,410 --> 00:33:32,850
say algorithms which are tightly coupled

00:33:29,910 --> 00:33:35,440
to data structures like the insert

00:33:32,850 --> 00:33:38,440
function of triangulations

00:33:35,440 --> 00:33:41,530
for example another refinement which we

00:33:38,440 --> 00:33:45,070
have just like in the BGA is that some

00:33:41,530 --> 00:33:47,110
algorithms provide visitors that are

00:33:45,070 --> 00:33:51,820
some code backs which are available to

00:33:47,110 --> 00:33:54,430
users to be to be called at specific

00:33:51,820 --> 00:33:57,100
events within the execution of each

00:33:54,430 --> 00:33:59,910
algorithm so this is the overall picture

00:33:57,100 --> 00:34:04,060
so we try to stick to something familiar

00:33:59,910 --> 00:34:08,620
which is the STL and extended it to our

00:34:04,060 --> 00:34:11,740
specific needs so now let me show you

00:34:08,620 --> 00:34:14,950
some some code so this is what we have

00:34:11,740 --> 00:34:17,380
in the STL so the class set which is

00:34:14,950 --> 00:34:20,560
parameterized by the key type and the

00:34:17,380 --> 00:34:24,370
comparison functor or less which provide

00:34:20,560 --> 00:34:27,490
the the ordering so you you internally

00:34:24,370 --> 00:34:29,679
store an object of this function type

00:34:27,490 --> 00:34:33,429
here and you call it since it's a

00:34:29,679 --> 00:34:34,810
function object on the the key types so

00:34:33,429 --> 00:34:38,919
the one that you want to insert in the

00:34:34,810 --> 00:34:43,570
in the set so in sigil we have something

00:34:38,919 --> 00:34:45,780
very similar to that so as I said the

00:34:43,570 --> 00:34:49,390
geometric trait class here is gathering

00:34:45,780 --> 00:34:51,370
the point types and the values functors

00:34:49,390 --> 00:34:52,840
specifying the predicates so in this

00:34:51,370 --> 00:34:56,080
example here for the Dylan a

00:34:52,840 --> 00:35:00,550
triangulation we use two functors the

00:34:56,080 --> 00:35:02,260
orientation factor and the incircle test

00:35:00,550 --> 00:35:04,930
which undress showed at the beginning

00:35:02,260 --> 00:35:05,770
and when you insert a point in this

00:35:04,930 --> 00:35:07,530
triangulation

00:35:05,770 --> 00:35:10,810
you will need somewhere in the code

00:35:07,530 --> 00:35:16,990
calls to this orientation functor and

00:35:10,810 --> 00:35:20,380
interval test so this is very similar in

00:35:16,990 --> 00:35:22,300
design to the STA let me now give more

00:35:20,380 --> 00:35:25,390
details on this geometric traits last

00:35:22,300 --> 00:35:26,860
parameter the idea of having this as a

00:35:25,390 --> 00:35:29,860
template parameter is that you can

00:35:26,860 --> 00:35:32,200
easily change it and you want to do that

00:35:29,860 --> 00:35:33,940
because you would like to change the

00:35:32,200 --> 00:35:36,370
point type let's say you want to use a

00:35:33,940 --> 00:35:38,110
cigarette item within your application

00:35:36,370 --> 00:35:41,320
which already has a point type for

00:35:38,110 --> 00:35:43,630
example and you are now able to use

00:35:41,320 --> 00:35:47,080
cigarette UM's on your point types

00:35:43,630 --> 00:35:48,490
because of this flexibility you can also

00:35:47,080 --> 00:35:50,530
exchange the

00:35:48,490 --> 00:35:52,210
the predicates that run on these point

00:35:50,530 --> 00:35:56,080
types so computing the orientation of

00:35:52,210 --> 00:35:58,869
three points for example Siegel itself

00:35:56,080 --> 00:36:01,630
provides several models for this

00:35:58,869 --> 00:36:04,390
geometric trades class actually we call

00:36:01,630 --> 00:36:09,640
them kernels they are some kind of

00:36:04,390 --> 00:36:11,230
superset of the needs of geometric

00:36:09,640 --> 00:36:13,630
traits classes of many algorithms in

00:36:11,230 --> 00:36:16,480
Siegel so they are gathering basic

00:36:13,630 --> 00:36:20,730
functionality on on point segments etc

00:36:16,480 --> 00:36:22,810
and the models that we provide are

00:36:20,730 --> 00:36:25,869
parameterised themselves by the

00:36:22,810 --> 00:36:27,400
arithmetic that is you can change you

00:36:25,869 --> 00:36:31,540
can use for example doubles as

00:36:27,400 --> 00:36:33,670
coordinates or floats or inch or more

00:36:31,540 --> 00:36:36,540
involve number types like multiplication

00:36:33,670 --> 00:36:38,920
integers which I will describe later

00:36:36,540 --> 00:36:41,140
there is here some kind of speed

00:36:38,920 --> 00:36:44,350
precision trade-off and some

00:36:41,140 --> 00:36:46,600
adaptability reasons to give you a

00:36:44,350 --> 00:36:50,440
practical example of another thing that

00:36:46,600 --> 00:36:53,380
it is useful for Andres described the

00:36:50,440 --> 00:36:55,810
application of terrains which is made

00:36:53,380 --> 00:36:57,940
using the Siegel 2d Dylan a

00:36:55,810 --> 00:37:01,030
triangulation and this is simply

00:36:57,940 --> 00:37:04,600
achieved by using some kind of implicit

00:37:01,030 --> 00:37:09,100
projection trade class which takes three

00:37:04,600 --> 00:37:11,560
points and applies to D predicates to

00:37:09,100 --> 00:37:13,890
them so it's it's very easy to plug in a

00:37:11,560 --> 00:37:19,050
specific trade class implementing this

00:37:13,890 --> 00:37:23,109
within the 2d Dylan a triangulation ok

00:37:19,050 --> 00:37:24,940
now let me give more detail on the exact

00:37:23,109 --> 00:37:26,890
geometric computing paradigm that we use

00:37:24,940 --> 00:37:29,230
in many places in signal to achieve your

00:37:26,890 --> 00:37:31,330
business so there are some issues which

00:37:29,230 --> 00:37:34,770
are especially important in geometric

00:37:31,330 --> 00:37:37,780
computations if you naively use

00:37:34,770 --> 00:37:40,980
floating-point arithmetic in geometric

00:37:37,780 --> 00:37:44,590
algorithms then you may have some

00:37:40,980 --> 00:37:48,010
unexpected consequences you may for

00:37:44,590 --> 00:37:49,780
example produce some wrong output or

00:37:48,010 --> 00:37:52,030
slightly wrong output let's say convex

00:37:49,780 --> 00:37:53,170
hull is not really convex that may or

00:37:52,030 --> 00:37:56,680
may not be a problem for your

00:37:53,170 --> 00:37:59,350
application worse you could have a crush

00:37:56,680 --> 00:38:01,319
because your algorithm or data structure

00:37:59,350 --> 00:38:04,289
is going to encounter

00:38:01,319 --> 00:38:06,719
an invariant variation or even worse you

00:38:04,289 --> 00:38:09,059
could also have an infinite loop in the

00:38:06,719 --> 00:38:12,559
algorithm due to this this this can

00:38:09,059 --> 00:38:14,719
happen very easily and the thing is that

00:38:12,559 --> 00:38:17,579
fundamentally there is a gap between the

00:38:14,719 --> 00:38:19,140
geometry which is used in theory which

00:38:17,579 --> 00:38:21,809
is the one that you use to build your

00:38:19,140 --> 00:38:24,690
algorithm in the in the literature and

00:38:21,809 --> 00:38:26,069
the geometry which is actually provided

00:38:24,690 --> 00:38:30,109
when you use for the in point arithmetic

00:38:26,069 --> 00:38:33,749
so let me give more insight on this

00:38:30,109 --> 00:38:39,509
typically algorithms are proved at least

00:38:33,749 --> 00:38:42,119
a contest is proved based on some basic

00:38:39,509 --> 00:38:44,130
theorems of geometry here I have an

00:38:42,119 --> 00:38:47,999
example if you take 4 points in the

00:38:44,130 --> 00:38:50,819
plane P Q R and s and you have the I

00:38:47,999 --> 00:38:53,609
pathogens that the three small triangles

00:38:50,819 --> 00:38:57,690
are oriented the counter clockwise so

00:38:53,609 --> 00:39:02,719
that that's what the CCW means so the

00:38:57,690 --> 00:39:06,410
three small triangles sqr p sr and PQ s

00:39:02,719 --> 00:39:11,309
then you have a theorem that says that

00:39:06,410 --> 00:39:14,400
the larger triangle PQR is also oriented

00:39:11,309 --> 00:39:17,069
contact law wise so it's a theorem that

00:39:14,400 --> 00:39:22,559
is used to prove the correctness of some

00:39:17,069 --> 00:39:26,130
algorithms now what happens with with

00:39:22,559 --> 00:39:28,319
doubles this counter clockwise test is

00:39:26,130 --> 00:39:31,559
the orientation test or three points PQ

00:39:28,319 --> 00:39:34,589
R and this is actually the sine of a two

00:39:31,559 --> 00:39:36,989
dimensional determinant when you refer

00:39:34,589 --> 00:39:40,949
to the Cartesian coordinates of the

00:39:36,989 --> 00:39:45,049
points so pxrx etc you have the formula

00:39:40,949 --> 00:39:48,930
here now if we pick a particular example

00:39:45,049 --> 00:39:50,549
you pick the point P and Q on the main

00:39:48,930 --> 00:39:54,359
diagonal with these coordinates so

00:39:50,549 --> 00:39:57,749
one-half one-half for p and 24 24 for Q

00:39:54,359 --> 00:40:02,549
and you pick a third point R which is a

00:39:57,749 --> 00:40:06,299
very close to P and we actually zoom in

00:40:02,549 --> 00:40:08,369
on this area and we paint the color of

00:40:06,299 --> 00:40:11,940
the result of this orientation test that

00:40:08,369 --> 00:40:15,350
we get with doubles so R is actually

00:40:11,940 --> 00:40:22,210
very close to P very close being that

00:40:15,350 --> 00:40:24,260
the zoom square here corresponds to 256

00:40:22,210 --> 00:40:26,480
consecutive values of floating-point

00:40:24,260 --> 00:40:31,510
numbers so this is very close to the

00:40:26,480 --> 00:40:34,760
point P and you see that the computed

00:40:31,510 --> 00:40:37,070
orientation value using floating points

00:40:34,760 --> 00:40:40,430
is actually very far from where it

00:40:37,070 --> 00:40:42,500
should be with the exact theoretical

00:40:40,430 --> 00:40:45,440
geometry which should be only one main

00:40:42,500 --> 00:40:48,410
diagonal of yellow squares so here you

00:40:45,440 --> 00:40:50,840
have some kind of random area along the

00:40:48,410 --> 00:40:52,520
diagonal which means that here you have

00:40:50,840 --> 00:40:55,190
some values you which you hardly can

00:40:52,520 --> 00:40:57,140
predict you will you even have some

00:40:55,190 --> 00:41:02,060
inversions if you look at some specific

00:40:57,140 --> 00:41:04,790
cases here so this means that with such

00:41:02,060 --> 00:41:07,340
an orientation test you absolutely

00:41:04,790 --> 00:41:09,620
cannot rely on some theorems to prove to

00:41:07,340 --> 00:41:12,110
prove your correctness of the algorithms

00:41:09,620 --> 00:41:15,290
and you actually run into into trouble

00:41:12,110 --> 00:41:17,600
in practice as well so the solution that

00:41:15,290 --> 00:41:20,000
we try to advocate in Seigle because

00:41:17,600 --> 00:41:25,760
it's general is the exact geometric

00:41:20,000 --> 00:41:28,340
computation it means that we do not

00:41:25,760 --> 00:41:30,620
strictly rely on exact arithmetic which

00:41:28,340 --> 00:41:33,050
means costly computation but it is a

00:41:30,620 --> 00:41:36,170
refined scheme of this the idea is that

00:41:33,050 --> 00:41:39,320
you can guarantee the robustness of your

00:41:36,170 --> 00:41:41,660
algorithms if your predicates are exact

00:41:39,320 --> 00:41:43,670
because your algorithms are going to

00:41:41,660 --> 00:41:45,710
take decisions during the execution

00:41:43,670 --> 00:41:49,130
based on the results of these predicates

00:41:45,710 --> 00:41:51,710
and as soon as you guarantee the

00:41:49,130 --> 00:41:54,920
exactness of the predicates as a whole

00:41:51,710 --> 00:41:58,600
then it is it is okay you are going to

00:41:54,920 --> 00:42:01,640
you are going to have robust algorithms

00:41:58,600 --> 00:42:04,760
sometimes you observes that construction

00:42:01,640 --> 00:42:06,800
geometric constructions can have more

00:42:04,760 --> 00:42:09,170
approximation and it may not be a

00:42:06,800 --> 00:42:11,540
problem so for example in meshing

00:42:09,170 --> 00:42:15,350
algorithms if you construct a new point

00:42:11,540 --> 00:42:18,620
it need not be exactly let's say the

00:42:15,350 --> 00:42:22,540
circumcenter of or three or three other

00:42:18,620 --> 00:42:22,540
points it may have a little bit of error

00:42:22,960 --> 00:42:30,859
we use for this some arithmetic tools

00:42:27,770 --> 00:42:32,630
Milty precision integer and rational

00:42:30,859 --> 00:42:34,820
numbers multiplication floating-point

00:42:32,630 --> 00:42:37,970
numbers so there are libraries like GMP

00:42:34,820 --> 00:42:39,890
and PFR which provide this and also some

00:42:37,970 --> 00:42:43,490
more involve the algebraic numbers of

00:42:39,890 --> 00:42:46,490
low degree interval arithmetic is also

00:42:43,490 --> 00:42:48,109
used to control in an efficient way the

00:42:46,490 --> 00:42:51,080
round off error of floating point

00:42:48,109 --> 00:42:53,710
numbers fourteen point operations and in

00:42:51,080 --> 00:42:55,880
some places we even use some static

00:42:53,710 --> 00:43:01,000
analysis of the round off error

00:42:55,880 --> 00:43:06,560
propagation within the predicates code

00:43:01,000 --> 00:43:09,220
so let me give just a review of what how

00:43:06,560 --> 00:43:12,440
you use this in practice in seagull so

00:43:09,220 --> 00:43:14,869
typically we have generic functor

00:43:12,440 --> 00:43:18,320
adaptors so there is this example of the

00:43:14,869 --> 00:43:22,970
filtered pretty predicate class which is

00:43:18,320 --> 00:43:26,089
actually producing a predicate based on

00:43:22,970 --> 00:43:28,190
two instantiations of a given predicate

00:43:26,089 --> 00:43:30,890
code so if you have the orientation

00:43:28,190 --> 00:43:34,640
predicate instantiate it with interval

00:43:30,890 --> 00:43:36,170
arithmetic you can run it first and the

00:43:34,640 --> 00:43:39,010
interval arithmetic is going to tell you

00:43:36,170 --> 00:43:42,170
if the sine computation inside is

00:43:39,010 --> 00:43:45,080
certain or not if it's not certain then

00:43:42,170 --> 00:43:47,380
you can instantiate the orientation

00:43:45,080 --> 00:43:52,099
predicate again with some more precise

00:43:47,380 --> 00:43:56,420
arithmetic like rationals the idea is

00:43:52,099 --> 00:43:57,890
that the the average speed the expedite

00:43:56,420 --> 00:43:59,420
speed is going to be the one of

00:43:57,890 --> 00:44:01,790
intervals rather than the multi

00:43:59,420 --> 00:44:06,050
precision but you still always have the

00:44:01,790 --> 00:44:08,000
exact result so as I said before there

00:44:06,050 --> 00:44:10,119
are some refinements of this which are

00:44:08,000 --> 00:44:13,690
faster than just interval arithmetic

00:44:10,119 --> 00:44:20,290
using some static error propagation

00:44:13,690 --> 00:44:20,290
analysis and also some more progressive

00:44:20,380 --> 00:44:29,510
precision increase than just switching

00:44:24,109 --> 00:44:33,230
to fully rational numbers now a typical

00:44:29,510 --> 00:44:35,480
benchmark that illustrates exactly what

00:44:33,230 --> 00:44:38,510
what kind of speed we we get with that

00:44:35,480 --> 00:44:41,119
if you compute a 3d DNA translations of

00:44:38,510 --> 00:44:41,840
1 million random points if you use

00:44:41,119 --> 00:44:45,350
doubles

00:44:41,840 --> 00:44:48,110
you can do it in 13 seconds if you use

00:44:45,350 --> 00:44:52,250
naive multi precision then this is much

00:44:48,110 --> 00:44:54,980
much slower so 800 seconds if you use

00:44:52,250 --> 00:44:57,350
the the filtering scheme based on

00:44:54,980 --> 00:45:00,050
interval arithmetic and then rational

00:44:57,350 --> 00:45:02,120
numbers then you go down to 63 seconds

00:45:00,050 --> 00:45:03,830
which is already much more interesting

00:45:02,120 --> 00:45:07,520
so it's only four or five times slower

00:45:03,830 --> 00:45:10,250
than doubles and with more refinements

00:45:07,520 --> 00:45:13,850
you can use these static filters which

00:45:10,250 --> 00:45:18,290
are approximately 20% slower than

00:45:13,850 --> 00:45:21,410
doubles overall so which is very good

00:45:18,290 --> 00:45:24,830
for an exact granted result on

00:45:21,410 --> 00:45:26,600
non-random data sets then this can be a

00:45:24,830 --> 00:45:32,270
little bit slower but you have

00:45:26,600 --> 00:45:35,090
guarantees so this was for geometric

00:45:32,270 --> 00:45:38,300
predicate but we also have some scheme

00:45:35,090 --> 00:45:41,870
to have exact constructions in case you

00:45:38,300 --> 00:45:45,950
need them this is what we call filtered

00:45:41,870 --> 00:45:48,020
constructions that is when you compute

00:45:45,950 --> 00:45:52,640
for example this figure you start from

00:45:48,020 --> 00:45:55,880
four points P Q R and s their form each

00:45:52,640 --> 00:45:57,800
two segments T and u and then you

00:45:55,880 --> 00:46:01,670
compute the intersection I between these

00:45:57,800 --> 00:46:05,000
two segments we provide actually a

00:46:01,670 --> 00:46:07,610
mechanism to compute this exactly but in

00:46:05,000 --> 00:46:09,350
a lazy way that is we first computed

00:46:07,610 --> 00:46:11,720
with interval coordinates for example

00:46:09,350 --> 00:46:14,800
for the intersection points and we

00:46:11,720 --> 00:46:17,360
remember in a directed at cyclic graph

00:46:14,800 --> 00:46:20,320
the way that it was constructed in case

00:46:17,360 --> 00:46:23,210
we need me later more precision

00:46:20,320 --> 00:46:26,390
now this scheme of exact geometric

00:46:23,210 --> 00:46:27,940
computation is a not bullet proof there

00:46:26,390 --> 00:46:31,310
are some cases that it cannot handle

00:46:27,940 --> 00:46:34,580
there is some work still on going on

00:46:31,310 --> 00:46:38,810
topology preserving random there are

00:46:34,580 --> 00:46:41,120
some issues with algorithms that use

00:46:38,810 --> 00:46:43,010
cascaded constructions so repeated

00:46:41,120 --> 00:46:43,550
constructions because then the size of

00:46:43,010 --> 00:46:49,070
your DAGs

00:46:43,550 --> 00:46:51,020
is growing and finally there are there

00:46:49,070 --> 00:46:53,510
is work ongoing on improving the

00:46:51,020 --> 00:46:54,890
efficiency of exact computation with

00:46:53,510 --> 00:46:56,000
algebraic numbers

00:46:54,890 --> 00:46:58,700
that you encounter when you manipulate

00:46:56,000 --> 00:47:02,890
curves for example so intersections of

00:46:58,700 --> 00:47:12,099
Seattle's that unrest should previously

00:47:02,890 --> 00:47:14,420
okay I will let unrest conclude so we

00:47:12,099 --> 00:47:16,760
let me just report on what are we

00:47:14,420 --> 00:47:19,190
currently working on what what you what

00:47:16,760 --> 00:47:22,190
can you expect in the future

00:47:19,190 --> 00:47:25,099
so one thing is a parallelization so

00:47:22,190 --> 00:47:27,289
there are multi core processes outer so

00:47:25,099 --> 00:47:29,329
it's kind of obvious to look at how to

00:47:27,289 --> 00:47:31,130
get triangle eight well to get data

00:47:29,329 --> 00:47:35,260
structures and algorithms

00:47:31,130 --> 00:47:38,059
well algorithms faster by by using

00:47:35,260 --> 00:47:40,279
things like open MP there are things

00:47:38,059 --> 00:47:43,359
like other language bindings so for the

00:47:40,279 --> 00:47:46,640
python language and things like making

00:47:43,359 --> 00:47:49,130
toolbox for scilab which is a an

00:47:46,640 --> 00:47:51,109
environment comparable to 2 metal happen

00:47:49,130 --> 00:47:52,819
and there are plugins for for drawing

00:47:51,109 --> 00:47:55,130
tools and more algorithms and data

00:47:52,819 --> 00:48:00,140
structure Center well the man with

00:47:55,130 --> 00:48:03,170
screenshots is Beckham here what we see

00:48:00,140 --> 00:48:06,230
is not generation of surface measures

00:48:03,170 --> 00:48:09,289
out of voxel input data of medical data

00:48:06,230 --> 00:48:11,089
but a generation of volume measures so

00:48:09,289 --> 00:48:13,160
what you want to do is you have octal

00:48:11,089 --> 00:48:16,759
data the tissue so the different tissues

00:48:13,160 --> 00:48:19,400
are marked and for example for for

00:48:16,759 --> 00:48:21,970
simulating of how does radiation go

00:48:19,400 --> 00:48:23,950
through the body and how do cells

00:48:21,970 --> 00:48:28,910
[Music]

00:48:23,950 --> 00:48:30,109
receive energy so people that do these

00:48:28,910 --> 00:48:34,000
kind of simulations they need

00:48:30,109 --> 00:48:36,769
decompositions of the tissues in in

00:48:34,000 --> 00:48:39,650
measure so what is particularly is that

00:48:36,769 --> 00:48:41,150
the entire thing is computed in one shot

00:48:39,650 --> 00:48:44,660
it's not that

00:48:41,150 --> 00:48:47,450
marching cube is running on one tissue

00:48:44,660 --> 00:48:50,420
after the other and then you try to to

00:48:47,450 --> 00:48:52,369
glue the tissues together with with with

00:48:50,420 --> 00:48:54,319
problem setter at the boundary so all

00:48:52,369 --> 00:48:58,789
the thing is constructed in one single

00:48:54,319 --> 00:49:00,650
shorter if you are of my age you maybe

00:48:58,789 --> 00:49:03,829
know as through eaten so it was an a

00:49:00,650 --> 00:49:07,339
card game you have a little space

00:49:03,829 --> 00:49:08,430
tripper and when you fly to the left it

00:49:07,339 --> 00:49:10,050
just wraps around

00:49:08,430 --> 00:49:12,480
and your IV again the same for these

00:49:10,050 --> 00:49:14,820
asteroids they flow out on the top so it

00:49:12,480 --> 00:49:17,660
comes back then the thing is a it's

00:49:14,820 --> 00:49:20,330
called periodic spaces and what we do is

00:49:17,660 --> 00:49:22,530
there's work underway on offering

00:49:20,330 --> 00:49:25,650
geometric algorithms and pie or attic

00:49:22,530 --> 00:49:29,400
spaces so that's interesting for for

00:49:25,650 --> 00:49:31,670
people who who don't like who don't like

00:49:29,400 --> 00:49:34,410
boundary conditions so the things that

00:49:31,670 --> 00:49:36,810
that's kind of the equivalent to the

00:49:34,410 --> 00:49:38,970
screen we saw before what we do in this

00:49:36,810 --> 00:49:40,830
in this area we have points in there and

00:49:38,970 --> 00:49:43,440
we triangulate them and instead of

00:49:40,830 --> 00:49:45,570
triangulating the convex hull what we do

00:49:43,440 --> 00:49:48,360
is so we connect the triangles outer to

00:49:45,570 --> 00:49:51,000
the right coming in back the edge coming

00:49:48,360 --> 00:49:54,420
coming back on the left okay so if you

00:49:51,000 --> 00:49:56,610
look at this triangle here it's it's the

00:49:54,420 --> 00:49:58,380
same triangle then this triangle here

00:49:56,610 --> 00:50:00,900
okay that they are connected it's it's

00:49:58,380 --> 00:50:04,410
the same triangle in memory in the data

00:50:00,900 --> 00:50:07,440
structure yourself okay and now this

00:50:04,410 --> 00:50:09,570
allows so now we just if we follow our

00:50:07,440 --> 00:50:11,820
pointer would move in such a

00:50:09,570 --> 00:50:14,070
triangulation now we see it enters a

00:50:11,820 --> 00:50:16,020
triangle and it kind of wraps around so

00:50:14,070 --> 00:50:18,120
it jumps to the other side enter the

00:50:16,020 --> 00:50:22,100
work and the triangulation can kind of

00:50:18,120 --> 00:50:24,930
continues so here you saw it in 3d in 2d

00:50:22,100 --> 00:50:27,150
it's in it's under development for in in

00:50:24,930 --> 00:50:29,340
3d enter there people like cosmologists

00:50:27,150 --> 00:50:31,460
which which are interested in this kind

00:50:29,340 --> 00:50:34,020
of kind of applications

00:50:31,460 --> 00:50:37,740
another thing is a geometry on the

00:50:34,020 --> 00:50:41,490
sphere so it's not geometry in the plane

00:50:37,740 --> 00:50:46,110
but on the sphere so here you see an

00:50:41,490 --> 00:50:49,290
arrangement so yeah a planar graph and

00:50:46,110 --> 00:50:50,190
the edges here they they are straight

00:50:49,290 --> 00:50:53,820
there they are

00:50:50,190 --> 00:50:55,710
arcs of great circles okay so they are

00:50:53,820 --> 00:50:57,960
round but they are not round to say a

00:50:55,710 --> 00:51:00,450
like like a half circle but they around

00:50:57,960 --> 00:51:02,850
on this on this on this run surface okay

00:51:00,450 --> 00:51:05,550
then there are algorithms like a Voronoi

00:51:02,850 --> 00:51:08,130
diagram so on the sphere and things like

00:51:05,550 --> 00:51:11,310
and map overlay so let's take the two

00:51:08,130 --> 00:51:13,170
the two planar maps we saw before the

00:51:11,310 --> 00:51:14,730
overlay would computer the the new

00:51:13,170 --> 00:51:18,200
intersection points and decompose it

00:51:14,730 --> 00:51:18,200
further in in faces on

00:51:18,339 --> 00:51:25,779
okay - to sum it up so what we try to do

00:51:22,630 --> 00:51:27,430
yeah what we try to tell you so sigil

00:51:25,779 --> 00:51:29,140
it's a it's a large collection of data

00:51:27,430 --> 00:51:30,999
structures and algorithms so with a very

00:51:29,140 --> 00:51:33,069
uniform design because well there's a

00:51:30,999 --> 00:51:34,719
that's the there's kind of process of

00:51:33,069 --> 00:51:36,249
you silver mentioned that to this

00:51:34,719 --> 00:51:38,019
reviewing process where we pay very

00:51:36,249 --> 00:51:40,239
careful attention to that things are

00:51:38,019 --> 00:51:42,249
very uniform enter that it's kind of

00:51:40,239 --> 00:51:44,859
your homogeneous for for the users huh

00:51:42,249 --> 00:51:47,140
another important point is a it's a dual

00:51:44,859 --> 00:51:49,390
licensing scheme so it's not a purely

00:51:47,140 --> 00:51:52,539
religious open-source it must be open

00:51:49,390 --> 00:51:54,160
source so for those who cannot we cannot

00:51:52,539 --> 00:51:57,400
respect such license there are there

00:51:54,160 --> 00:51:59,109
alternatives in the project we folk we

00:51:57,400 --> 00:52:01,959
focus on geometry so we don't try to

00:51:59,109 --> 00:52:03,819
have a general purpose library what we

00:52:01,959 --> 00:52:05,829
do instead we try to interface to make

00:52:03,819 --> 00:52:07,839
it as easy as possible to interface with

00:52:05,829 --> 00:52:11,130
existing stuff like post graph library

00:52:07,839 --> 00:52:13,900
the STL I mean you saw examples for that

00:52:11,130 --> 00:52:15,999
there are two paradigms we adhere to

00:52:13,900 --> 00:52:18,039
generate programming the main purpose

00:52:15,999 --> 00:52:20,199
for adhering to it is make it easy for

00:52:18,039 --> 00:52:21,900
users to integrate stuff it's rich

00:52:20,199 --> 00:52:25,539
generic programming is really about

00:52:21,900 --> 00:52:28,150
adaptability about make it easy to

00:52:25,539 --> 00:52:31,119
integrate and the other paradigm the

00:52:28,150 --> 00:52:33,849
exact genetic computing make it robust

00:52:31,119 --> 00:52:34,839
make it really that it doesn't crash I

00:52:33,849 --> 00:52:37,269
mean if there's a bug then it crashes

00:52:34,839 --> 00:52:38,979
but it will not crash for problems with

00:52:37,269 --> 00:52:41,589
floating-point arithmetic things like

00:52:38,979 --> 00:52:44,170
that and this filtering to have it fast

00:52:41,589 --> 00:52:46,509
at the same time robust and faster and

00:52:44,170 --> 00:52:48,279
so we end here thanks a lot for your

00:52:46,509 --> 00:52:52,719
attention any questions so Silvan mia

00:52:48,279 --> 00:52:58,719
are ready to take your questions they'll

00:52:52,719 --> 00:53:01,809
take we'll take questions now this talk

00:52:58,719 --> 00:53:04,809
is being broadcast the public so keep

00:53:01,809 --> 00:53:06,339
that in mind and if anybody's interested

00:53:04,809 --> 00:53:07,959
in lunch with the speakers will be

00:53:06,339 --> 00:53:10,949
having lunch as soon as we're done with

00:53:07,959 --> 00:53:10,949
the questions thank you

00:53:16,859 --> 00:53:20,119
I had a question

00:53:24,019 --> 00:53:31,410
so I had a question about the exact

00:53:26,789 --> 00:53:33,329
computation the when do you decide to

00:53:31,410 --> 00:53:34,529
move from one computational domain to

00:53:33,329 --> 00:53:40,920
the other like from rational arithmetic

00:53:34,529 --> 00:53:43,469
to the algebraic so the the need is

00:53:40,920 --> 00:53:46,109
actually triggered because when you use

00:53:43,469 --> 00:53:48,479
for example interval arithmetic to to to

00:53:46,109 --> 00:53:50,279
compute your predicates inside your

00:53:48,479 --> 00:53:52,829
predicate you have this sine function or

00:53:50,279 --> 00:53:57,900
comparisons and when you compare two

00:53:52,829 --> 00:54:01,589
intervals you may not always have a

00:53:57,900 --> 00:54:06,839
certain result output so if two interval

00:54:01,589 --> 00:54:09,660
overlaps then what is done is that so it

00:54:06,839 --> 00:54:11,849
may trigger an exception a C++ exception

00:54:09,660 --> 00:54:14,729
or you may also report this through

00:54:11,849 --> 00:54:18,390
another mechanism by your special return

00:54:14,729 --> 00:54:22,769
type we actually use both methods for

00:54:18,390 --> 00:54:25,950
efficiency and in this case then we

00:54:22,769 --> 00:54:27,979
actually call the same the same

00:54:25,950 --> 00:54:30,239
algebraic code so when you saw the

00:54:27,979 --> 00:54:32,640
expression for the orientation predicate

00:54:30,239 --> 00:54:35,910
sine of BX so this is encoded in a

00:54:32,640 --> 00:54:38,400
templated function so you you had this

00:54:35,910 --> 00:54:40,319
instantiated with the rational number

00:54:38,400 --> 00:54:43,469
type for example and you call this again

00:54:40,319 --> 00:54:46,519
and in in this case in it cannot fail so

00:54:43,469 --> 00:54:50,329
you have the finally the exact result

00:54:46,519 --> 00:54:50,329

YouTube URL: https://www.youtube.com/watch?v=3DLfkWWw_Tg


