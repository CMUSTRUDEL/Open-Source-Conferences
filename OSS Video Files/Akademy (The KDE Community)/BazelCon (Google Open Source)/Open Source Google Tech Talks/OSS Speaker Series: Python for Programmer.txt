Title: OSS Speaker Series: Python for Programmer
Publication date: 2010-10-27
Playlist: Open Source Google Tech Talks
Description: 
	Google Tech Talks
April 10, 2007

ABSTRACT

Python is a popular very-high-level programming language, with a clean and spare syntax, simple and regular semantics, a large standard library and a wealth of third-party extensions, libraries and tools. With several production-quality open-source implementations available, many excellent books, and growing acceptance in both industry and academia, Python can play some useful role within a huge variety of software development projects.

Moreover, Python is really easy to learn, particularly (though not exclusively) for programmers who are skilled at such languages as Java, C++ and C. This talk addresses software developers who are experienced in other...
Captions: 
	00:00:26,769 --> 00:00:31,150
my name is Jeremy Allison with Google's

00:00:28,990 --> 00:00:33,100
open source program office I'm actually

00:00:31,150 --> 00:00:34,320
substituting for Leslie Hawthorne who

00:00:33,100 --> 00:00:36,579
can't be here tonight

00:00:34,320 --> 00:00:38,199
which means unfortunately I'm gonna have

00:00:36,579 --> 00:00:40,360
to miss the talk which is a real pain

00:00:38,199 --> 00:00:43,690
because I think I might really enjoy

00:00:40,360 --> 00:00:47,829
this one so just a couple of questions

00:00:43,690 --> 00:00:51,100
first who how did people find out about

00:00:47,829 --> 00:00:54,040
this talk did find it by I think I think

00:00:51,100 --> 00:00:55,870
it was on Google code blog or something

00:00:54,040 --> 00:00:59,710
how many internal Google people are

00:00:55,870 --> 00:01:01,660
there here are quite a few so and so

00:00:59,710 --> 00:01:03,969
that the non Googlers did you find out

00:01:01,660 --> 00:01:08,440
about it on the Google code blog raise

00:01:03,969 --> 00:01:11,020
your hands oh one okay we need to

00:01:08,440 --> 00:01:13,600
advertise more I think anyway this is a

00:01:11,020 --> 00:01:17,800
series of talks it will be going up on

00:01:13,600 --> 00:01:20,200
Google video probably in a week or so as

00:01:17,800 --> 00:01:21,759
time so if you have frettin if you

00:01:20,200 --> 00:01:23,470
really enjoy it and you have friends who

00:01:21,759 --> 00:01:26,050
missed it they can they can always tune

00:01:23,470 --> 00:01:29,140
into the video anyway so I'd like to

00:01:26,050 --> 00:01:33,610
introduce our speaker tonight who's Alex

00:01:29,140 --> 00:01:35,380
Martelli and Alex works as an uber tech

00:01:33,610 --> 00:01:37,600
lead I don't quite know what that is but

00:01:35,380 --> 00:01:39,520
sounds very important uber tech lead for

00:01:37,600 --> 00:01:41,140
production systems at Google that is

00:01:39,520 --> 00:01:43,149
very important

00:01:41,140 --> 00:01:45,189
he wrote Python in a nutshell and

00:01:43,149 --> 00:01:47,140
co-edited the Python cookbook both of

00:01:45,189 --> 00:01:49,750
which I have so I should have brought

00:01:47,140 --> 00:01:52,060
one for you to sign and he's a member of

00:01:49,750 --> 00:01:55,600
the Python Software Foundation and won

00:01:52,060 --> 00:01:59,039
the 2002 activated activators Choice

00:01:55,600 --> 00:02:02,289
Award and the 2006 Frank will allow

00:01:59,039 --> 00:02:13,090
Willison Memorial Award anyway please

00:02:02,289 --> 00:02:15,640
welcome Alex martelly thank you

00:02:13,090 --> 00:02:17,829
everybody and welcome so this talk is a

00:02:15,640 --> 00:02:19,959
very brief introduction to the Python

00:02:17,829 --> 00:02:21,760
language and a mention of its few

00:02:19,959 --> 00:02:23,739
libraries for people who are already

00:02:21,760 --> 00:02:26,709
experienced programmer in some other

00:02:23,739 --> 00:02:28,239
language that is the summary so if this

00:02:26,709 --> 00:02:30,250
doesn't describe you if you already know

00:02:28,239 --> 00:02:32,500
Python very well or if you don't know

00:02:30,250 --> 00:02:37,810
programming at all I will not be

00:02:32,500 --> 00:02:40,510
offended if you leave so essentially I'd

00:02:37,810 --> 00:02:43,209
like to have here very experienced

00:02:40,510 --> 00:02:47,439
programmer in some widespread language

00:02:43,209 --> 00:02:49,450
at a C++ or Java or C no need for any

00:02:47,439 --> 00:02:51,489
previous exposure to Python if you have

00:02:49,450 --> 00:02:56,079
some it will hurt if you have a lot

00:02:51,489 --> 00:02:58,690
you'll be rather bored tonight you must

00:02:56,079 --> 00:03:00,970
be kind of prepared for me to be very

00:02:58,690 --> 00:03:03,819
fast in some of the parts others will be

00:03:00,970 --> 00:03:08,200
more relaxed but a few hard stuff I'll

00:03:03,819 --> 00:03:11,890
be hundred a lot about and I apologize

00:03:08,200 --> 00:03:14,739
in advance I have a lot of slides with

00:03:11,890 --> 00:03:17,799
code example to squeeze more code per

00:03:14,739 --> 00:03:19,810
slide my formatting isn't exactly

00:03:17,799 --> 00:03:22,870
elegant and some of my names are too

00:03:19,810 --> 00:03:25,900
short I don't do that unless you have

00:03:22,870 --> 00:03:29,440
two codons lives of course so what's

00:03:25,900 --> 00:03:31,870
Python we probably heard about it but

00:03:29,440 --> 00:03:34,060
let's summarize it's a very high-level

00:03:31,870 --> 00:03:37,150
language that I put that in double quote

00:03:34,060 --> 00:03:39,489
because it's a technical term low-level

00:03:37,150 --> 00:03:42,099
language is assembler high-level

00:03:39,489 --> 00:03:44,919
language is C or Java very high-level

00:03:42,099 --> 00:03:50,829
language is Python Ruby pearl it's

00:03:44,919 --> 00:03:53,949
basically got more power per line of

00:03:50,829 --> 00:03:55,989
code you write essentially it takes you

00:03:53,949 --> 00:03:58,750
far away from the machine which has

00:03:55,989 --> 00:04:01,810
disadvantages but it makes you more

00:03:58,750 --> 00:04:04,480
productive in coding the syntax is

00:04:01,810 --> 00:04:06,220
particularly notable as clean in spare

00:04:04,480 --> 00:04:10,239
as we'll see comparing it with other

00:04:06,220 --> 00:04:14,680
languages the semantics we have striven

00:04:10,239 --> 00:04:16,389
to keep very regular meaning simple and

00:04:14,680 --> 00:04:18,340
powerful at the same time and without a

00:04:16,389 --> 00:04:20,229
lot of special cases and exception for

00:04:18,340 --> 00:04:22,810
example we don't have two types of

00:04:20,229 --> 00:04:25,030
integers depending on whether it's a

00:04:22,810 --> 00:04:28,510
real integer or an object integer that's

00:04:25,030 --> 00:04:35,110
a typical Java or C sharp issue like see

00:04:28,510 --> 00:04:37,479
we have integer that's much simpler it's

00:04:35,110 --> 00:04:39,159
object oriented but also suitable for

00:04:37,479 --> 00:04:41,349
other paradigms of programming we'll

00:04:39,159 --> 00:04:42,610
again we'll contrast that with the

00:04:41,349 --> 00:04:47,590
compare and contrast with other

00:04:42,610 --> 00:04:49,599
languages to help you cite it its main

00:04:47,590 --> 00:04:51,700
focus is on the productivity of the

00:04:49,599 --> 00:04:53,470
programmer we want the programmer to be

00:04:51,700 --> 00:04:57,730
able to do a lot of work

00:04:53,470 --> 00:05:00,010
fast how do we do that well maybe I'm

00:04:57,730 --> 00:05:03,820
not using the right order here because

00:05:00,010 --> 00:05:08,770
like number one is simplicity simplicity

00:05:03,820 --> 00:05:13,210
is the best feature of any complex

00:05:08,770 --> 00:05:15,130
design as Santa's very best known as the

00:05:13,210 --> 00:05:17,740
author of the novel the little prince

00:05:15,130 --> 00:05:20,470
but actually a stronger in attic

00:05:17,740 --> 00:05:22,900
engineer said you know you reach

00:05:20,470 --> 00:05:24,460
perfection in design not when there's

00:05:22,900 --> 00:05:27,190
nothing to add but when there's nothing

00:05:24,460 --> 00:05:29,230
to take away now Python isn't exactly

00:05:27,190 --> 00:05:31,090
that perfect but we're going to take

00:05:29,230 --> 00:05:34,180
away a lot of things very soon in Python

00:05:31,090 --> 00:05:36,910
3000 which you can expect to see out in

00:05:34,180 --> 00:05:38,920
less than a year so far we haven't been

00:05:36,910 --> 00:05:41,470
able to take away anything once it was

00:05:38,920 --> 00:05:44,770
in because of the well-known demon known

00:05:41,470 --> 00:05:47,260
as backwards compatibility they the life

00:05:44,770 --> 00:05:48,610
of a new language or a new company or a

00:05:47,260 --> 00:05:50,500
new anything is always easier because

00:05:48,610 --> 00:05:52,360
you have no customers and therefore

00:05:50,500 --> 00:05:54,070
there is no problem with offending your

00:05:52,360 --> 00:05:56,230
customers but as soon as you have a few

00:05:54,070 --> 00:05:58,180
million people using the language or

00:05:56,230 --> 00:06:02,560
buying products from the company you

00:05:58,180 --> 00:06:05,650
can't really be too innovative except on

00:06:02,560 --> 00:06:08,620
major releases and Python will have its

00:06:05,650 --> 00:06:11,200
first major release in a decade this

00:06:08,620 --> 00:06:13,570
very year will take away a lot of the

00:06:11,200 --> 00:06:15,910
things I explained now because they're

00:06:13,570 --> 00:06:20,350
not strictly needed uniformity is

00:06:15,910 --> 00:06:23,729
another strong Python value we'll come

00:06:20,350 --> 00:06:28,090
back to it but basically the dream is

00:06:23,729 --> 00:06:29,710
that things work the same way in in

00:06:28,090 --> 00:06:33,640
different contexts so you don't have to

00:06:29,710 --> 00:06:36,010
remember a comunitaria complexity of

00:06:33,640 --> 00:06:38,520
explosion of rules of okay how does this

00:06:36,010 --> 00:06:40,660
work in this case versus that case

00:06:38,520 --> 00:06:46,150
modularity is very important of course

00:06:40,660 --> 00:06:50,680
and pragmatism is engineers rule number

00:06:46,150 --> 00:06:52,210
one they all of these theoretical

00:06:50,680 --> 00:06:54,190
considerations are absolutely crucial

00:06:52,210 --> 00:06:55,720
but pragmatism Trump's them all

00:06:54,190 --> 00:06:59,740
sometimes something is just too

00:06:55,720 --> 00:07:01,419
important to not have it's got a rich

00:06:59,740 --> 00:07:04,720
standard library maybe not very Java

00:07:01,419 --> 00:07:06,820
standard Java standards but pretty rich

00:07:04,720 --> 00:07:09,540
compared with most other language

00:07:06,820 --> 00:07:12,250
and lots of third-party tools additions

00:07:09,540 --> 00:07:14,500
extensions and so on and it's got

00:07:12,250 --> 00:07:17,530
several good implementations the one

00:07:14,500 --> 00:07:20,860
most people think about when they say

00:07:17,530 --> 00:07:23,410
python is known as C Python for classic

00:07:20,860 --> 00:07:26,590
Python there's also an implementation

00:07:23,410 --> 00:07:28,480
which was just released as a result of a

00:07:26,590 --> 00:07:30,850
two-year project financed by the

00:07:28,480 --> 00:07:33,490
European community known as pi pi which

00:07:30,850 --> 00:07:38,380
is basically a Python implemented in

00:07:33,490 --> 00:07:42,090
Python itself the siren Python which has

00:07:38,380 --> 00:07:44,650
just reached released 1.1 and is

00:07:42,090 --> 00:07:47,590
Microsoft's product but I believe it's

00:07:44,650 --> 00:07:49,750
the one or at least was one of the first

00:07:47,590 --> 00:07:51,880
to Microsoft product which is open

00:07:49,750 --> 00:07:55,090
source so you can download it it will

00:07:51,880 --> 00:07:57,930
only run on dotnet of course and then

00:07:55,090 --> 00:08:00,040
although the project state is a bit

00:07:57,930 --> 00:08:02,950
uncertain right now there's something

00:08:00,040 --> 00:08:06,250
called JSON which is an implementation

00:08:02,950 --> 00:08:09,400
of Python for the java virtual machine

00:08:06,250 --> 00:08:11,350
unfortunately the 2.2 release has been

00:08:09,400 --> 00:08:12,310
in alpha then beta for like four or five

00:08:11,350 --> 00:08:15,640
years now

00:08:12,310 --> 00:08:18,430
the main architect of that project has

00:08:15,640 --> 00:08:20,380
moved to be a Microsoft employee and as

00:08:18,430 --> 00:08:22,420
being the driving force behind

00:08:20,380 --> 00:08:25,590
ironpython so I don't know what to

00:08:22,420 --> 00:08:30,310
predict for jarton at this point in time

00:08:25,590 --> 00:08:32,020
but beyond the technical aspects of

00:08:30,310 --> 00:08:34,810
Python is a language and if its

00:08:32,020 --> 00:08:37,720
libraries Python is also and this is

00:08:34,810 --> 00:08:41,140
very important a vibrant open-source

00:08:37,720 --> 00:08:44,500
community you will find in just about

00:08:41,140 --> 00:08:48,010
any field of programming some more

00:08:44,500 --> 00:08:51,900
represented others less a lot of

00:08:48,010 --> 00:08:55,840
companies and individuals using Python

00:08:51,900 --> 00:08:59,200
the Python Software Foundation is the

00:08:55,840 --> 00:09:01,780
nonprofit organization which holds all

00:08:59,200 --> 00:09:05,110
the intellectual property rights to

00:09:01,780 --> 00:09:07,570
Python and it's organized in a series of

00:09:05,110 --> 00:09:08,980
sub communities that pursue special

00:09:07,570 --> 00:09:11,680
interests there's a special interest

00:09:08,980 --> 00:09:13,180
group on databases one on matrix

00:09:11,680 --> 00:09:15,040
computation

00:09:13,180 --> 00:09:16,630
when an image processing and so on and

00:09:15,040 --> 00:09:20,290
so forth

00:09:16,630 --> 00:09:22,270
there are a lot of local interest group

00:09:20,290 --> 00:09:25,420
wherever you live there's likely to be a

00:09:22,270 --> 00:09:27,850
active Python interest group meeting

00:09:25,420 --> 00:09:30,430
once a month or so I'd like to put in a

00:09:27,850 --> 00:09:32,320
plug for Bay Piggy's which is the local

00:09:30,430 --> 00:09:35,010
interest group for the Bay Area San

00:09:32,320 --> 00:09:38,260
Francisco Bay Area which meets at Google

00:09:35,010 --> 00:09:40,810
every month on Thursday and the next

00:09:38,260 --> 00:09:42,460
meeting is two days from now so you're

00:09:40,810 --> 00:09:45,460
all welcome to show up

00:09:42,460 --> 00:09:47,710
it's a beginners night meet-and-greet

00:09:45,460 --> 00:09:49,930
night so there's no specific theme this

00:09:47,710 --> 00:09:52,330
time but it's certain to be an

00:09:49,930 --> 00:09:55,210
interesting experience and there's an

00:09:52,330 --> 00:09:58,030
enormous wealth of websites news groups

00:09:55,210 --> 00:10:00,400
and mailing lists or all sort of general

00:09:58,030 --> 00:10:04,090
and specialized discussions there's

00:10:00,400 --> 00:10:06,100
plenty of courses worship tutorials just

00:10:04,090 --> 00:10:08,410
in the Bay Area over the last year I've

00:10:06,100 --> 00:10:11,680
seen something like four or five

00:10:08,410 --> 00:10:14,520
different courses offered by various

00:10:11,680 --> 00:10:17,620
local universities plus other offered

00:10:14,520 --> 00:10:21,820
privately anderson is inexhaustible

00:10:17,620 --> 00:10:24,250
array of books that includes online only

00:10:21,820 --> 00:10:25,840
books a few of them paper only books a

00:10:24,250 --> 00:10:30,160
few of them and most of them of course

00:10:25,840 --> 00:10:32,380
available in both ways so I will spend

00:10:30,160 --> 00:10:34,330
the rest of the talk is explaining the

00:10:32,380 --> 00:10:37,990
good and bad points of each of this

00:10:34,330 --> 00:10:41,860
books not really but I wanted to

00:10:37,990 --> 00:10:46,210
threaten you of course I think the best

00:10:41,860 --> 00:10:48,270
one is this the Python cookbook it's the

00:10:46,210 --> 00:10:50,890
best one because I wrote it with my wife

00:10:48,270 --> 00:10:53,380
but the second best is Python inertia

00:10:50,890 --> 00:10:55,570
which I wrote on my own now seriously

00:10:53,380 --> 00:10:57,010
they're not well the pattern inertia is

00:10:55,570 --> 00:10:59,430
not ready a book for beginners it's a

00:10:57,010 --> 00:11:01,330
reference book Python book book is

00:10:59,430 --> 00:11:04,330
reasonably suitable for beginners

00:11:01,330 --> 00:11:07,150
because it shows you how to do hundreds

00:11:04,330 --> 00:11:09,340
hundreds of tasks for beginners there's

00:11:07,150 --> 00:11:11,410
a lot of other great choices for example

00:11:09,340 --> 00:11:17,200
Python for dummies written by two other

00:11:11,410 --> 00:11:20,320
Bay piggys members and another one I

00:11:17,200 --> 00:11:23,110
know very well is core Python written by

00:11:20,320 --> 00:11:26,740
yet another Bay Area make biggy member

00:11:23,110 --> 00:11:28,089
and of course some are about Python

00:11:26,740 --> 00:11:31,420
in general some are much more

00:11:28,089 --> 00:11:33,250
specialized for example Python network

00:11:31,420 --> 00:11:35,740
programming is about using Python

00:11:33,250 --> 00:11:38,020
specifically to program network to book

00:11:35,740 --> 00:11:41,770
years is a specific Python framework for

00:11:38,020 --> 00:11:46,930
websites or jython is an implementation

00:11:41,770 --> 00:11:49,779
I already mentioned data crunching is

00:11:46,930 --> 00:11:52,270
essentially about using Python and other

00:11:49,779 --> 00:11:58,709
tools to take data files and do useful

00:11:52,270 --> 00:12:02,920
stuff with them so choose wisely so I

00:11:58,709 --> 00:12:04,990
claim the stock is addressed to people

00:12:02,920 --> 00:12:07,360
who already know to program in various

00:12:04,990 --> 00:12:10,029
other languages and therefore I like at

00:12:07,360 --> 00:12:13,170
this point to introduce how does Python

00:12:10,029 --> 00:12:17,080
resemble some of them in different ways

00:12:13,170 --> 00:12:21,100
they most important similarity to Java

00:12:17,080 --> 00:12:23,170
is in the typical implementation Python

00:12:21,100 --> 00:12:25,140
like Java is normally compiled to

00:12:23,170 --> 00:12:28,690
bytecode it doesn't need to be you can

00:12:25,140 --> 00:12:31,480
make machine code with Python you do

00:12:28,690 --> 00:12:35,260
that using pi pi 1.0 which has a lot of

00:12:31,480 --> 00:12:38,920
backends including I believe Intel only

00:12:35,260 --> 00:12:40,959
machine code but it doesn't really buy

00:12:38,920 --> 00:12:45,270
you much as people have tried to compile

00:12:40,959 --> 00:12:48,820
Java with the GCC Java compiler now

00:12:45,270 --> 00:12:51,970
compared to a well-tuned virtual machine

00:12:48,820 --> 00:12:54,570
it doesn't really buy you much one

00:12:51,970 --> 00:12:56,920
crucial difference in operation between

00:12:54,570 --> 00:12:59,230
Python and Java is that in Python

00:12:56,920 --> 00:13:01,480
computation is implicit you don't

00:12:59,230 --> 00:13:03,430
normally bother to explicitly compile

00:13:01,480 --> 00:13:05,740
your files you just leave the sources

00:13:03,430 --> 00:13:10,089
laying around and whenever you import

00:13:05,740 --> 00:13:11,920
one the Python runtime system founds

00:13:10,089 --> 00:13:14,140
it's not being compiled yet it composite

00:13:11,920 --> 00:13:15,940
on the fly it's a very fast compiler you

00:13:14,140 --> 00:13:18,490
don't you hardly notice the fact and

00:13:15,940 --> 00:13:21,579
then it saves the object file to disk so

00:13:18,490 --> 00:13:24,430
next time it won't have to everything

00:13:21,579 --> 00:13:27,630
inherits from object except the it's

00:13:24,430 --> 00:13:30,520
lower case o versus the upper case but

00:13:27,630 --> 00:13:31,170
the difference is that we do mean

00:13:30,520 --> 00:13:34,240
everything

00:13:31,170 --> 00:13:36,870
numbers in URLs from object functions or

00:13:34,240 --> 00:13:39,710
object classes or objects every

00:13:36,870 --> 00:13:41,790
his first class there's no need to make

00:13:39,710 --> 00:13:43,910
strengthing just take a function object

00:13:41,790 --> 00:13:46,320
a second integer object and stick it

00:13:43,910 --> 00:13:50,220
anywhere else where he would stick any

00:13:46,320 --> 00:13:52,170
instance you wish like Java Python as

00:13:50,220 --> 00:13:55,290
you know uniform object reference I'm

00:13:52,170 --> 00:13:59,700
antics anytime you assign a to be you're

00:13:55,290 --> 00:14:02,760
not copying all the bits of a into a box

00:13:59,700 --> 00:14:05,400
called B rather you're attaching a label

00:14:02,760 --> 00:14:08,370
called B to wherever label a was already

00:14:05,400 --> 00:14:10,320
attached so same goes for argument

00:14:08,370 --> 00:14:12,450
passing same goes for return the

00:14:10,320 --> 00:14:13,980
difference again is that this does apply

00:14:12,450 --> 00:14:15,990
universally in Python we don't have

00:14:13,980 --> 00:14:20,370
special cases whereby this is almost

00:14:15,990 --> 00:14:22,820
always true except for numbers it's got

00:14:20,370 --> 00:14:27,029
a vast and powerful standard library

00:14:22,820 --> 00:14:29,910
Java's is like twice as big a thing but

00:14:27,029 --> 00:14:32,100
after job is maybe the largest and

00:14:29,910 --> 00:14:34,410
library of any language in what used

00:14:32,100 --> 00:14:35,850
today is called garbage collection again

00:14:34,410 --> 00:14:38,100
there's a little difference in

00:14:35,850 --> 00:14:41,220
implementation if you look at

00:14:38,100 --> 00:14:43,110
implementations such as Aaron Python it

00:14:41,220 --> 00:14:45,120
will of course piggyback on whatever

00:14:43,110 --> 00:14:48,150
garbage collection semantics are offered

00:14:45,120 --> 00:14:50,430
by the underlying platform or J or or

00:14:48,150 --> 00:14:54,120
jython will use exactly the garbage

00:14:50,430 --> 00:14:57,150
collection semantics of the JVM classic

00:14:54,120 --> 00:15:00,060
Python tends to have a dual system of

00:14:57,150 --> 00:15:02,670
garbage collection to collect garbage as

00:15:00,060 --> 00:15:04,380
soon as possible it uses both reference

00:15:02,670 --> 00:15:06,660
count and mark-and-sweep if you're

00:15:04,380 --> 00:15:08,910
familiar with the issue but that's an

00:15:06,660 --> 00:15:10,920
implementation detail and then it's got

00:15:08,910 --> 00:15:13,110
all sort of cool stuff at least for

00:15:10,920 --> 00:15:15,740
people coming from CMC plus parcel to

00:15:13,110 --> 00:15:18,779
use to adding them such as introspection

00:15:15,740 --> 00:15:21,690
which I believe Java called reflections

00:15:18,779 --> 00:15:28,230
that serialization threads as part of

00:15:21,690 --> 00:15:33,540
the library and so on in other respects

00:15:28,230 --> 00:15:37,560
Python is rather more similar to C++ for

00:15:33,540 --> 00:15:39,390
example number one is multi-paradigm in

00:15:37,560 --> 00:15:42,480
Java you want to write hello world you

00:15:39,390 --> 00:15:45,870
have to write a class even though there

00:15:42,480 --> 00:15:47,520
is no conceptual need for any class you

00:15:45,870 --> 00:15:51,150
still have to write one because Java

00:15:47,520 --> 00:15:53,160
forces you to in Python like in C++ or C

00:15:51,150 --> 00:15:54,690
for that matter if you want to write

00:15:53,160 --> 00:15:57,870
just a function you write just a

00:15:54,690 --> 00:16:02,880
function though need to force a class

00:15:57,870 --> 00:16:06,240
around it besides like you can do

00:16:02,880 --> 00:16:08,460
object-oriented or procedural you can

00:16:06,240 --> 00:16:12,930
also do generic programming essentially

00:16:08,460 --> 00:16:17,520
in in C++ you have to do that explicitly

00:16:12,930 --> 00:16:19,740
through templates in in Python

00:16:17,520 --> 00:16:21,840
essentially it comes for free as will

00:16:19,740 --> 00:16:23,340
point out later and the little

00:16:21,840 --> 00:16:25,260
functional programming because you can

00:16:23,340 --> 00:16:28,410
pass function of functions around which

00:16:25,260 --> 00:16:31,470
is notoriously a problem in in Java it's

00:16:28,410 --> 00:16:34,080
much easier in Python because you don't

00:16:31,470 --> 00:16:36,630
have to extinct in terms of pointers to

00:16:34,080 --> 00:16:38,400
function you can actually think in terms

00:16:36,630 --> 00:16:40,140
of passing a function returning a

00:16:38,400 --> 00:16:41,820
function from another function just like

00:16:40,140 --> 00:16:43,920
you do in functional programming

00:16:41,820 --> 00:16:46,950
languages there's multiple inheritance

00:16:43,920 --> 00:16:49,740
it can be used in structural ways but

00:16:46,950 --> 00:16:51,840
that's a very controversial theme in any

00:16:49,740 --> 00:16:55,050
language supporting multiple inheritance

00:16:51,840 --> 00:16:59,210
or it can be used in a very nice way

00:16:55,050 --> 00:17:03,000
which is they mix in if you go to the

00:16:59,210 --> 00:17:07,140
web on the Google Video site you'll find

00:17:03,000 --> 00:17:09,839
my talk on design patterns for Python

00:17:07,140 --> 00:17:12,780
second part I show how to use mixing

00:17:09,839 --> 00:17:16,950
inheritance for a very powerful class

00:17:12,780 --> 00:17:18,780
level implementation of is what's

00:17:16,950 --> 00:17:22,110
essentially the template method design

00:17:18,780 --> 00:17:24,000
pattern extended to a whole class ok

00:17:22,110 --> 00:17:25,890
signature based polymorphism is

00:17:24,000 --> 00:17:29,910
basically the same thing as generic

00:17:25,890 --> 00:17:30,900
programming at some level except again

00:17:29,910 --> 00:17:34,050
that in Python

00:17:30,900 --> 00:17:36,300
everything is a template the features

00:17:34,050 --> 00:17:38,130
needed from a certain argument or

00:17:36,300 --> 00:17:40,560
certain function are defined but what

00:17:38,130 --> 00:17:42,660
the function actually does with it what

00:17:40,560 --> 00:17:48,540
methods it calls on it or operations

00:17:42,660 --> 00:17:53,640
doesn't it in in C++ you explicitly say

00:17:48,540 --> 00:17:56,550
which type parameters are in play also

00:17:53,640 --> 00:17:58,410
what C++ and Python have in common is

00:17:56,550 --> 00:18:00,190
that for just about anything that is a

00:17:58,410 --> 00:18:04,059
core issue of the

00:18:00,190 --> 00:18:05,860
the language itself things which we

00:18:04,059 --> 00:18:07,860
could call side dishes except that

00:18:05,860 --> 00:18:10,120
they're typically at the core of any

00:18:07,860 --> 00:18:12,549
serious programming you may ever do

00:18:10,120 --> 00:18:14,169
you've got even too many choices what

00:18:12,549 --> 00:18:16,269
you want to use as a graphical user

00:18:14,169 --> 00:18:19,299
interface in Python you can basically

00:18:16,269 --> 00:18:22,539
use anything you can use from C++ plus

00:18:19,299 --> 00:18:24,129
anything you can use from dotnet if you

00:18:22,539 --> 00:18:26,769
if you're using our own Python path

00:18:24,129 --> 00:18:30,129
anything you can use from Java if you're

00:18:26,769 --> 00:18:32,409
using jython plus more so you have even

00:18:30,129 --> 00:18:33,669
too many choices for a graphical user

00:18:32,409 --> 00:18:36,850
interface framework

00:18:33,669 --> 00:18:39,220
similarly for how do I go on the web how

00:18:36,850 --> 00:18:43,529
do I do other network operations how to

00:18:39,220 --> 00:18:46,200
interface to databases I do I do

00:18:43,529 --> 00:18:48,789
communication between processes

00:18:46,200 --> 00:18:51,429
distributed computing and so on and so

00:18:48,789 --> 00:18:53,909
forth for all of these things some

00:18:51,429 --> 00:18:57,279
languages offer you very strong guidance

00:18:53,909 --> 00:18:59,850
Python like C++ basically tells you to

00:18:57,279 --> 00:19:04,059
do your own choices

00:18:59,850 --> 00:19:08,919
one of the most interesting similarities

00:19:04,059 --> 00:19:11,519
to me is that even though a sufficiently

00:19:08,919 --> 00:19:15,129
superficial observer would claim that

00:19:11,519 --> 00:19:17,230
C++ or Java are very similar to C and

00:19:15,129 --> 00:19:22,450
Python is difference because basically

00:19:17,230 --> 00:19:25,120
scrub is got no braces or it doesn't use

00:19:22,450 --> 00:19:27,519
braces for structure the way these are

00:19:25,120 --> 00:19:31,090
those languages do if you look at what

00:19:27,519 --> 00:19:31,629
defines C the situation is actually very

00:19:31,090 --> 00:19:36,279
different

00:19:31,629 --> 00:19:38,259
fortunately the iso standard for the c

00:19:36,279 --> 00:19:42,789
language in its pressure in its

00:19:38,259 --> 00:19:45,940
rationale offers a five-point definition

00:19:42,789 --> 00:19:49,809
of what is c all about what is the

00:19:45,940 --> 00:19:54,279
spirit of c one trust to the programmer

00:19:49,809 --> 00:19:56,250
to don't prevent the programmer from

00:19:54,279 --> 00:20:00,600
doing what needs to be done

00:19:56,250 --> 00:20:05,200
three keep the language small and simple

00:20:00,600 --> 00:20:08,230
four provide only one way to do an

00:20:05,200 --> 00:20:12,009
operation and five make it fast okay on

00:20:08,230 --> 00:20:13,720
point five unfortunately Python isn't

00:20:12,009 --> 00:20:20,710
all that

00:20:13,720 --> 00:20:24,220
dear into the spirit of see but on four

00:20:20,710 --> 00:20:26,740
out of five of the points pythons

00:20:24,220 --> 00:20:29,740
principles are exactly the same sees

00:20:26,740 --> 00:20:32,230
principle we don't put a lot of

00:20:29,740 --> 00:20:36,040
infrastructure in place because we don't

00:20:32,230 --> 00:20:39,070
trust the programmer like Java does like

00:20:36,040 --> 00:20:40,990
C++ do all those private public

00:20:39,070 --> 00:20:44,500
semi-private semi public if you trust

00:20:40,990 --> 00:20:46,660
the programmer that useless baggage so

00:20:44,500 --> 00:20:49,720
we don't have them and therefore we keep

00:20:46,660 --> 00:20:51,940
the language small and simple and we

00:20:49,720 --> 00:20:53,830
never stop the programmer from doing

00:20:51,940 --> 00:20:56,530
what needs to be done because anytime

00:20:53,830 --> 00:20:57,820
you try to make something well first of

00:20:56,530 --> 00:20:59,860
all you cannot make something foolproof

00:20:57,820 --> 00:21:02,440
because fools are so ingenious that's

00:20:59,860 --> 00:21:05,440
the well-known fact but anytime you put

00:21:02,440 --> 00:21:06,910
in place as something to constrain the

00:21:05,440 --> 00:21:09,640
programmer because you don't trust the

00:21:06,910 --> 00:21:11,980
programmer you are in certain

00:21:09,640 --> 00:21:16,180
sufficiently nasty situation stopping

00:21:11,980 --> 00:21:18,100
the programming programmer who you

00:21:16,180 --> 00:21:21,940
should have trusted from doing something

00:21:18,100 --> 00:21:24,910
that needs to be done so 0.123 go very

00:21:21,940 --> 00:21:29,170
well together in point for the first

00:21:24,910 --> 00:21:32,200
time I read that design principle for

00:21:29,170 --> 00:21:34,480
Python it's it's very contentious in

00:21:32,200 --> 00:21:37,030
today's world the way the principle

00:21:34,480 --> 00:21:39,310
reads in Python is there should be one

00:21:37,030 --> 00:21:44,380
and preferably only one obvious way to

00:21:39,310 --> 00:21:46,720
do it for any do it anytime you have you

00:21:44,380 --> 00:21:49,270
do have a way to do task X having

00:21:46,720 --> 00:21:52,320
another one is sheer waste you're just

00:21:49,270 --> 00:21:54,880
making the language bigger don't of

00:21:52,320 --> 00:21:57,700
course it's a target it's a dream even

00:21:54,880 --> 00:22:00,460
in C there's often more than one way to

00:21:57,700 --> 00:22:02,530
do an operation you can I don't know

00:22:00,460 --> 00:22:04,710
have a pointer walk through an array or

00:22:02,530 --> 00:22:08,790
use an index to walk through their a

00:22:04,710 --> 00:22:11,920
they trust you to do the right thing but

00:22:08,790 --> 00:22:15,550
these are never desired the way they are

00:22:11,920 --> 00:22:18,070
in some other languages I for example

00:22:15,550 --> 00:22:19,870
there's one language which is generally

00:22:18,070 --> 00:22:22,600
very similar to Python but with very

00:22:19,870 --> 00:22:24,160
different philosophy which decide the

00:22:22,600 --> 00:22:27,910
since programmer

00:22:24,160 --> 00:22:30,790
never can remember if an array has a dot

00:22:27,910 --> 00:22:32,230
size or a dot length well they would

00:22:30,790 --> 00:22:36,700
offer both with exactly the same

00:22:32,230 --> 00:22:39,190
semantics that is exactly the reverse of

00:22:36,700 --> 00:22:41,710
pythons philosophy having several ways

00:22:39,190 --> 00:22:43,600
to do something fights against

00:22:41,710 --> 00:22:47,350
uniformity at all the uniformity is a

00:22:43,600 --> 00:22:50,290
present value if we all manage to only

00:22:47,350 --> 00:22:52,000
have one way to do it then everybody

00:22:50,290 --> 00:22:54,820
would be doing it the same way which

00:22:52,000 --> 00:23:00,210
means maintenance and teamwork would be

00:22:54,820 --> 00:23:04,600
vastly enhanced this part isn't exactly

00:23:00,210 --> 00:23:07,150
exactly met and fortunately it's there

00:23:04,600 --> 00:23:09,360
are some choices which may not be all

00:23:07,150 --> 00:23:13,410
that important today but for example

00:23:09,360 --> 00:23:17,410
Python does not define the semantics of

00:23:13,410 --> 00:23:19,360
14-point numbers exactly like C or C++

00:23:17,410 --> 00:23:21,670
it says the semantics of floating-point

00:23:19,360 --> 00:23:24,580
number is whatever this Hardware says it

00:23:21,670 --> 00:23:27,340
is nowadays this isn't very important

00:23:24,580 --> 00:23:30,430
because basically all reasonable pieces

00:23:27,340 --> 00:23:32,710
of hardware of similar semantics but it

00:23:30,430 --> 00:23:36,160
used to be a big deal because for

00:23:32,710 --> 00:23:38,620
example all the Christ supercomputer had

00:23:36,160 --> 00:23:40,630
their own semantics for for floating

00:23:38,620 --> 00:23:42,790
point along with such a job I would say

00:23:40,630 --> 00:23:44,380
this is exactly what the semantics of

00:23:42,790 --> 00:23:47,070
floating point numbers is going to be

00:23:44,380 --> 00:23:50,860
could never have run on a Cray

00:23:47,070 --> 00:23:54,880
supercomputer at a speed faster than a

00:23:50,860 --> 00:23:56,770
snail for Python or C we'd rather give

00:23:54,880 --> 00:23:58,480
up some portability so therefore in

00:23:56,770 --> 00:24:00,040
point computations are not guaranteed to

00:23:58,480 --> 00:24:05,610
work the same way on an old IBM

00:24:00,040 --> 00:24:10,870
mainframe Cray supercomputer versus VMs

00:24:05,610 --> 00:24:14,220
vac CMS machine so in this sense we have

00:24:10,870 --> 00:24:18,520
made exactly the same design choices see

00:24:14,220 --> 00:24:19,750
it's truth be told it's partly laziness

00:24:18,520 --> 00:24:21,720
because this way we don't have to

00:24:19,750 --> 00:24:23,620
provide a complete software

00:24:21,720 --> 00:24:26,140
implementation of floating point on

00:24:23,620 --> 00:24:31,380
those machines whose semantics are not

00:24:26,140 --> 00:24:31,380
entirely precise so

00:24:32,010 --> 00:24:35,400
so far as trying to stress some

00:24:33,630 --> 00:24:40,230
similarities and only minor differences

00:24:35,400 --> 00:24:42,540
but of course we can also go the same

00:24:40,230 --> 00:24:45,929
way and see how it's been different from

00:24:42,540 --> 00:24:49,010
all of Java C++ and C here the big deal

00:24:45,929 --> 00:24:52,380
is that typing is strong but dynamic

00:24:49,010 --> 00:24:54,299
strong much stronger than in in C for

00:24:52,380 --> 00:24:57,630
example you see you can basically use a

00:24:54,299 --> 00:25:00,240
cast to say these bits whatever they may

00:24:57,630 --> 00:25:02,010
be make believe that a float which

00:25:00,240 --> 00:25:06,179
basically destroys your type system you

00:25:02,010 --> 00:25:08,910
cannot do that in in Python on the other

00:25:06,179 --> 00:25:09,450
hand the typing is dynamic another way

00:25:08,910 --> 00:25:11,790
to put it

00:25:09,450 --> 00:25:15,179
a name has no type a name is the name is

00:25:11,790 --> 00:25:17,790
a name the type belongs to the object

00:25:15,179 --> 00:25:19,740
and the name may refer to an object but

00:25:17,790 --> 00:25:22,790
that it may change and refer to a

00:25:19,740 --> 00:25:25,679
different object so the type may change

00:25:22,790 --> 00:25:27,390
there are no declarations just

00:25:25,679 --> 00:25:30,000
statements basically there's no

00:25:27,390 --> 00:25:32,010
distinction or some no conceptual

00:25:30,000 --> 00:25:35,460
distinction between compile-time and

00:25:32,010 --> 00:25:37,290
run-time compile-time where the

00:25:35,460 --> 00:25:39,419
declarations are something that guides

00:25:37,290 --> 00:25:41,610
the compiler and runtime where the

00:25:39,419 --> 00:25:43,919
statements are actually executed we

00:25:41,610 --> 00:25:46,380
don't draw the distinction things are

00:25:43,919 --> 00:25:48,030
just executed as you go conceptually

00:25:46,380 --> 00:25:52,049
speaking even though of course there is

00:25:48,030 --> 00:25:53,580
a computational stage for speed syntax

00:25:52,049 --> 00:25:56,190
is very spare ornamentation is

00:25:53,580 --> 00:25:58,980
absolutely minimal or no braces for

00:25:56,190 --> 00:26:00,540
blocks just indentation no parentheses

00:25:58,980 --> 00:26:04,850
around the conditions innocent while

00:26:00,540 --> 00:26:06,990
statements bless punctuation in general

00:26:04,850 --> 00:26:09,210
interesting observation I've heard of

00:26:06,990 --> 00:26:11,429
this point is that pythons the only

00:26:09,210 --> 00:26:14,400
programming language designed according

00:26:11,429 --> 00:26:16,200
to the principle of edward tufte if you

00:26:14,400 --> 00:26:19,080
read the visualization of quantitative

00:26:16,200 --> 00:26:23,250
information you know that his core

00:26:19,080 --> 00:26:25,500
principle is no wasted pixel one pixel

00:26:23,250 --> 00:26:28,350
that is there just because it looks nice

00:26:25,500 --> 00:26:31,370
is a waste take it out

00:26:28,350 --> 00:26:34,799
Python doesn't have any extra pixels

00:26:31,370 --> 00:26:36,510
well we do we have some full colons

00:26:34,799 --> 00:26:39,960
which could be removed but there's very

00:26:36,510 --> 00:26:42,210
tiny pixels so everything is the first

00:26:39,960 --> 00:26:44,020
cost object by everything I mean classes

00:26:42,210 --> 00:26:47,830
functions methods

00:26:44,020 --> 00:26:51,870
Jools packages just about anything you

00:26:47,830 --> 00:26:54,790
can think of it doesn't exist just at

00:26:51,870 --> 00:26:57,490
compile-time for the benefit of the

00:26:54,790 --> 00:26:59,440
compiler if it exists at all it's a

00:26:57,490 --> 00:27:01,120
full-fledged object it is just a runtime

00:26:59,440 --> 00:27:03,220
you can put it in a list you can return

00:27:01,120 --> 00:27:08,260
from a function you can pass it as an

00:27:03,220 --> 00:27:10,090
argument also the while Python lets you

00:27:08,260 --> 00:27:13,630
twiddle bits it's not really what it's

00:27:10,090 --> 00:27:15,550
meant to do the focus where it really

00:27:13,630 --> 00:27:21,120
shows its strength is on the high and

00:27:15,550 --> 00:27:23,050
very high levels of us abstraction so

00:27:21,120 --> 00:27:25,510
fundamentals there's an interactive

00:27:23,050 --> 00:27:29,080
interpreter it's not the main normal way

00:27:25,510 --> 00:27:31,720
to use Python but it will it's nice to

00:27:29,080 --> 00:27:34,570
try things out and explore things the

00:27:31,720 --> 00:27:37,900
prompt is 3 greater than science or the

00:27:34,570 --> 00:27:41,140
secondary prompter like in in bash in

00:27:37,900 --> 00:27:44,710
here it's a dot the dot means statement

00:27:41,140 --> 00:27:48,280
continuation normally you write source

00:27:44,710 --> 00:27:50,530
file food of py first time you import

00:27:48,280 --> 00:27:54,100
them we'll see what import means in the

00:27:50,530 --> 00:27:56,950
language in a while it gets compiled to

00:27:54,100 --> 00:28:00,580
py see the object code and there for

00:27:56,950 --> 00:28:03,700
after that it's simply loaded from there

00:28:00,580 --> 00:28:05,470
the simplest instruction in the world is

00:28:03,700 --> 00:28:09,610
a plain assignment which just says a

00:28:05,470 --> 00:28:13,150
name equals expression it binds a row

00:28:09,610 --> 00:28:16,420
binds name this is not an like it would

00:28:13,150 --> 00:28:18,670
be in C and or C++ an operation between

00:28:16,420 --> 00:28:20,740
objects it's an operation between an

00:28:18,670 --> 00:28:24,130
object whatever the expression means and

00:28:20,740 --> 00:28:26,350
upward of your name variables just name

00:28:24,130 --> 00:28:28,150
that's like it would be in Java this has

00:28:26,350 --> 00:28:31,210
absolutely no effect on whatever name

00:28:28,150 --> 00:28:33,250
used to indicate previously it just

00:28:31,210 --> 00:28:35,830
means that from now our name indicates

00:28:33,250 --> 00:28:37,870
this one there is no declaration of name

00:28:35,830 --> 00:28:40,000
whenever you bind something to a name

00:28:37,870 --> 00:28:42,100
the name springs into existence and

00:28:40,000 --> 00:28:44,560
names don't have ax types object to

00:28:42,100 --> 00:28:46,060
other service aid there's a special

00:28:44,560 --> 00:28:48,850
object called nun which is a place

00:28:46,060 --> 00:28:50,980
louder placeholder value meaning there's

00:28:48,850 --> 00:28:53,890
nothing here that would be roughly the

00:28:50,980 --> 00:28:56,429
equivalent of nool or lowercase moving

00:28:53,890 --> 00:29:02,110
java application moving sea

00:28:56,429 --> 00:29:04,029
we're meaning there's nothing except I'm

00:29:02,110 --> 00:29:05,890
still holding the place or something to

00:29:04,029 --> 00:29:07,210
come in the future for example a

00:29:05,890 --> 00:29:11,100
function that doesn't have an explicit

00:29:07,210 --> 00:29:14,080
return statement will return on however

00:29:11,100 --> 00:29:16,269
none is a full-fledged object again you

00:29:14,080 --> 00:29:18,159
can pass it as an argument returned from

00:29:16,269 --> 00:29:19,929
a function put it in a list and so on

00:29:18,159 --> 00:29:24,190
everything is first class including the

00:29:19,929 --> 00:29:26,470
nothingness very zen concept the

00:29:24,190 --> 00:29:29,559
elementary yo which you never use in

00:29:26,470 --> 00:29:31,840
real programs that is nice in some -

00:29:29,559 --> 00:29:34,269
like right short example state acting

00:29:31,840 --> 00:29:39,490
example there's two simple built-in ways

00:29:34,269 --> 00:29:41,019
to do input one is the function called

00:29:39,490 --> 00:29:43,929
input which basically lets the user

00:29:41,019 --> 00:29:46,120
input any expression whatsoever compute

00:29:43,929 --> 00:29:48,130
the expression on the fly and inputs the

00:29:46,120 --> 00:29:49,990
result of your program of course that's

00:29:48,130 --> 00:29:51,970
not something you'd ever want to do in a

00:29:49,990 --> 00:29:55,330
real program because if there's a syntax

00:29:51,970 --> 00:29:58,450
error him for the user is typing you're

00:29:55,330 --> 00:30:00,130
going to crash a row input which is the

00:29:58,450 --> 00:30:01,990
same thing that just returns the string

00:30:00,130 --> 00:30:04,659
that the user of staff just trims the

00:30:01,990 --> 00:30:06,850
training new line in front of mentary

00:30:04,659 --> 00:30:09,190
output there's a statement called print

00:30:06,850 --> 00:30:10,690
followed by zero or more comma separated

00:30:09,190 --> 00:30:13,720
expression which just puts them out on

00:30:10,690 --> 00:30:15,639
standard output one after the other in a

00:30:13,720 --> 00:30:17,200
new line at the end unless you have a

00:30:15,639 --> 00:30:19,539
trailing comma there's no fancy

00:30:17,200 --> 00:30:21,250
formatting there if you want to do find

00:30:19,539 --> 00:30:23,620
some formatting you can have your comma

00:30:21,250 --> 00:30:25,269
separated expression via string

00:30:23,620 --> 00:30:28,600
formatting expression as we'll see but

00:30:25,269 --> 00:30:30,789
print itself you just copied stuff with

00:30:28,600 --> 00:30:34,600
this absolutely minimal formatting the

00:30:30,789 --> 00:30:36,250
space in the new line of course again

00:30:34,600 --> 00:30:38,139
it's not meant for professional that

00:30:36,250 --> 00:30:41,799
allowed to does a bazillion other ways

00:30:38,139 --> 00:30:44,460
to do that okay so here's some trivial

00:30:41,799 --> 00:30:47,289
example of what we've seen so far of

00:30:44,460 --> 00:30:50,320
whatever name X meant before including

00:30:47,289 --> 00:30:53,080
nothing it now means the number 23 so if

00:30:50,320 --> 00:30:55,899
you print X then 23 is what you get on

00:30:53,080 --> 00:30:59,409
Sandra output and then X is now the

00:30:55,899 --> 00:31:01,929
string foo so nothing nothing bad

00:30:59,409 --> 00:31:04,389
happens to 23 it's not damaged in any

00:31:01,929 --> 00:31:08,780
way just not referred to by name X

00:31:04,389 --> 00:31:10,790
anymore now print X image foo so see

00:31:08,780 --> 00:31:14,150
the name Express a doesn't have a site

00:31:10,790 --> 00:31:16,550
at this point the object is shown by X

00:31:14,150 --> 00:31:19,160
is an integer and at this point is a

00:31:16,550 --> 00:31:20,660
string but also one thing you can do in

00:31:19,160 --> 00:31:22,790
Python which is typically not available

00:31:20,660 --> 00:31:24,980
in other languages is to delete a name

00:31:22,790 --> 00:31:27,590
that doesn't damage the object in any

00:31:24,980 --> 00:31:29,750
way again it just takes the name out of

00:31:27,590 --> 00:31:32,360
the other issue so the name X doesn't

00:31:29,750 --> 00:31:34,460
refer to nothing anything and if you are

00:31:32,360 --> 00:31:37,340
print X you get an error at that point

00:31:34,460 --> 00:31:40,010
on the other hand if you want the name Y

00:31:37,340 --> 00:31:44,600
to be around be usable but not mean

00:31:40,010 --> 00:31:46,850
anything special you can assign none to

00:31:44,600 --> 00:31:48,470
it that's the place holder and now you

00:31:46,850 --> 00:31:52,720
can if you want print it and you will

00:31:48,470 --> 00:31:55,220
see the letter n or n e no big deal

00:31:52,720 --> 00:31:57,410
Python is flow control there are three

00:31:55,220 --> 00:31:59,000
will so we'll see how one of them is

00:31:57,410 --> 00:32:03,560
defined in terms of the others but

00:31:59,000 --> 00:32:08,480
that's a bit later if while and four if

00:32:03,560 --> 00:32:12,170
is the only way we do conditional

00:32:08,480 --> 00:32:14,840
operations you may have else if which is

00:32:12,170 --> 00:32:18,710
build Elif you may have an else meaning

00:32:14,840 --> 00:32:23,720
in every other case there's wild while

00:32:18,710 --> 00:32:25,880
except inside its loop body breaking

00:32:23,720 --> 00:32:29,210
continue same semantics as in all the

00:32:25,880 --> 00:32:31,610
other three languages and it can also

00:32:29,210 --> 00:32:34,760
have an else this is not common to the

00:32:31,610 --> 00:32:39,650
other languages essentially and else in

00:32:34,760 --> 00:32:41,960
a loop in Python means if the loop is

00:32:39,650 --> 00:32:44,570
terminated normally has not been

00:32:41,960 --> 00:32:49,070
prematurely interrupted essentially a

00:32:44,570 --> 00:32:52,670
break terminates a loop prematurely the

00:32:49,070 --> 00:32:55,640
else is what happens if they if no break

00:32:52,670 --> 00:32:58,130
has executed during the loop and then

00:32:55,640 --> 00:33:00,680
this for which is basically having a

00:32:58,130 --> 00:33:02,600
name step through a sequence and I

00:33:00,680 --> 00:33:04,970
trouble recall it if you need can have

00:33:02,600 --> 00:33:08,750
break continuing else just like while

00:33:04,970 --> 00:33:11,330
can here's some simple for control

00:33:08,750 --> 00:33:16,360
example after a couple of preliminary

00:33:11,330 --> 00:33:20,120
assignment let's see which one of these

00:33:16,360 --> 00:33:21,570
statements this print statements would

00:33:20,120 --> 00:33:24,840
you expect

00:33:21,570 --> 00:33:29,220
be printed who thinks it will say a is

00:33:24,840 --> 00:33:33,600
greater than B nobody who think it will

00:33:29,220 --> 00:33:36,690
say a is equal to B who think it will

00:33:33,600 --> 00:33:39,090
say a is smaller than me well somebody

00:33:36,690 --> 00:33:40,620
most of them most of you don't believe

00:33:39,090 --> 00:33:42,270
it will do any of these things it will

00:33:40,620 --> 00:33:44,640
do one in yes it is of course the last

00:33:42,270 --> 00:33:48,570
one just to show how easy it is to

00:33:44,640 --> 00:33:53,010
understand the semantics here and let's

00:33:48,570 --> 00:33:57,120
see if after that we have this loop what

00:33:53,010 --> 00:34:00,150
will happen well is a less than B yes 23

00:33:57,120 --> 00:34:08,370
is less than 45 so we pray in 2345 and

00:34:00,150 --> 00:34:09,990
this makes a refers to twice if the wire

00:34:08,370 --> 00:34:12,390
add an else it would execute because

00:34:09,990 --> 00:34:16,380
there is no break the wild terminates

00:34:12,390 --> 00:34:18,990
naturally because a becomes 46 46 is not

00:34:16,380 --> 00:34:21,180
less than 45 so that's it that's a

00:34:18,990 --> 00:34:22,950
natural exit there's no breaking it

00:34:21,180 --> 00:34:25,410
makes no sense to have an else if you

00:34:22,950 --> 00:34:28,260
have no break in the body because it

00:34:25,410 --> 00:34:30,390
will never execute okay there's some

00:34:28,260 --> 00:34:33,240
simple types or scalars so to speak

00:34:30,390 --> 00:34:35,700
which are a lot of numbers there's

00:34:33,240 --> 00:34:38,940
integers long floating complex I don't

00:34:35,700 --> 00:34:40,560
know why I'm an old Fortran programmer I

00:34:38,940 --> 00:34:42,570
don't know why other languages after

00:34:40,560 --> 00:34:45,320
Fortran drop the complex numbers they're

00:34:42,570 --> 00:34:50,460
so handy for all sort of computation oh

00:34:45,320 --> 00:34:53,340
here's some example of numbers 23 is a

00:34:50,460 --> 00:34:55,410
number and so it says you may notice

00:34:53,340 --> 00:34:58,530
that this number is kind of long but

00:34:55,410 --> 00:35:02,640
it's far from too long for Python you

00:34:58,530 --> 00:35:04,680
just keep typing digits until you manage

00:35:02,640 --> 00:35:06,420
to exhaust your available memory which

00:35:04,680 --> 00:35:09,020
will take you a long time with a typical

00:35:06,420 --> 00:35:11,100
machine of today with a few gigabytes

00:35:09,020 --> 00:35:14,160
Python is quite happy to store your

00:35:11,100 --> 00:35:18,260
integer it has multi precision implicit

00:35:14,160 --> 00:35:21,990
or we're going to use like XO decimal or

00:35:18,260 --> 00:35:28,200
2.3 is of course a float which would be

00:35:21,990 --> 00:35:31,500
called a double in in C and 4.5 plus 6.7

00:35:28,200 --> 00:35:32,130
J is a complex we've used james like in

00:35:31,500 --> 00:35:35,400
electric

00:35:32,130 --> 00:35:38,370
jeering rather than I like in like

00:35:35,400 --> 00:35:40,530
mathematicians usually do but it's one

00:35:38,370 --> 00:35:42,000
of the to recognize notation there's all

00:35:40,530 --> 00:35:44,400
sort of operators again

00:35:42,000 --> 00:35:46,020
Fortran lovers will note we do have the

00:35:44,400 --> 00:35:48,350
double star meaning raised to power

00:35:46,020 --> 00:35:52,440
again I don't understand why it's not a

00:35:48,350 --> 00:35:55,050
widespread use this to form of division

00:35:52,440 --> 00:35:59,510
one means with truncation the other

00:35:55,050 --> 00:36:03,120
without truncations and there's modulus

00:35:59,510 --> 00:36:04,740
shift bit operations and so on and

00:36:03,120 --> 00:36:07,260
there's a few built-ins we'll

00:36:04,740 --> 00:36:09,420
compactable things later but pretty

00:36:07,260 --> 00:36:13,320
obvious like absolute value minimum

00:36:09,420 --> 00:36:15,210
number okay it's not entirely obvious to

00:36:13,320 --> 00:36:17,010
most people why should we have powers

00:36:15,210 --> 00:36:20,000
built-in if we already have star star

00:36:17,010 --> 00:36:25,110
the reason is that the built-in powers

00:36:20,000 --> 00:36:32,180
potentially three arguments it does X to

00:36:25,110 --> 00:36:35,010
the Y modulo Z and if you're really into

00:36:32,180 --> 00:36:37,560
number theory you know that can be

00:36:35,010 --> 00:36:39,540
extremely faster but that's really the

00:36:37,560 --> 00:36:42,890
only concession concession to strange

00:36:39,540 --> 00:36:45,960
things we have in the built-ins okay

00:36:42,890 --> 00:36:49,620
some takes any array of numbers and sums

00:36:45,960 --> 00:36:51,750
them up and strings we have to kind

00:36:49,620 --> 00:36:54,030
unfortunately here's an example where a

00:36:51,750 --> 00:36:55,980
backward compatibility fights against

00:36:54,030 --> 00:36:57,600
simplicity will remedy that in Python

00:36:55,980 --> 00:37:00,270
three zero

00:36:57,600 --> 00:37:02,820
it's obviously simpler like in Java to

00:37:00,270 --> 00:37:03,800
have only unicode and it's obviously the

00:37:02,820 --> 00:37:06,030
right way to do it

00:37:03,800 --> 00:37:08,370
unfortunately for backward compatibility

00:37:06,030 --> 00:37:11,640
we still have plain strengths meaning

00:37:08,370 --> 00:37:14,910
strings made of bytes and Unicode

00:37:11,640 --> 00:37:18,060
strings as well so we have to explicitly

00:37:14,910 --> 00:37:20,820
indicate with you Cole on something

00:37:18,060 --> 00:37:23,700
sorry for something quote that this is a

00:37:20,820 --> 00:37:26,940
unicode string otherwise all the others

00:37:23,700 --> 00:37:28,620
are byte strings in the current version

00:37:26,940 --> 00:37:33,360
and then there's all sort of escape

00:37:28,620 --> 00:37:36,420
sequences and you can do catenation you

00:37:33,360 --> 00:37:38,250
can do repetition of strings and you can

00:37:36,420 --> 00:37:40,040
do formatting which uses a very rich

00:37:38,250 --> 00:37:44,460
format language very similar to the

00:37:40,040 --> 00:37:45,539
printf function of c off you built in

00:37:44,460 --> 00:37:49,079
such as

00:37:45,539 --> 00:37:51,479
chr which goal or any unit CHR depending

00:37:49,079 --> 00:37:53,729
on type you want go from a number an

00:37:51,479 --> 00:37:56,339
integer number to the corresponding

00:37:53,729 --> 00:37:59,269
character and/or goes from a character

00:37:56,339 --> 00:38:02,519
to its ask your unicode code number

00:37:59,269 --> 00:38:05,759
sequence strings are read only sequences

00:38:02,519 --> 00:38:08,039
will see what a sequence means shortly

00:38:05,759 --> 00:38:09,929
meaning you can take the length you can

00:38:08,039 --> 00:38:13,409
index and slice them you can loop over

00:38:09,929 --> 00:38:15,299
them and strings have so many methods it

00:38:13,409 --> 00:38:18,209
would take several slides just to list

00:38:15,299 --> 00:38:20,159
their names but stuff like capitalize

00:38:18,209 --> 00:38:22,769
the strings Center the string in a field

00:38:20,159 --> 00:38:27,209
of arbitrary length all sort of cool

00:38:22,769 --> 00:38:29,159
stream manipulation stuff so we have the

00:38:27,209 --> 00:38:33,689
built in simple type scalars if you will

00:38:29,159 --> 00:38:36,299
and then we have containers only a few

00:38:33,689 --> 00:38:38,099
containers are built in most of the

00:38:36,299 --> 00:38:39,899
container types are in the library but

00:38:38,099 --> 00:38:42,719
these are the ones which we have deemed

00:38:39,899 --> 00:38:45,299
so important that it's worth having them

00:38:42,719 --> 00:38:47,909
as built in a tuple is an elementary

00:38:45,299 --> 00:38:51,059
mutable sequence it doesn't do just

00:38:47,909 --> 00:38:55,289
about anything except it holds immutably

00:38:51,059 --> 00:38:59,039
a small secret typically small sequence

00:38:55,289 --> 00:39:04,019
of objects of any type or it notated

00:38:59,039 --> 00:39:06,449
with parentheses and commas and or you

00:39:04,019 --> 00:39:09,499
can build one by explicitly using the

00:39:06,449 --> 00:39:13,139
word tuple with the sequence argument

00:39:09,499 --> 00:39:14,999
basically it's a essentially a

00:39:13,139 --> 00:39:18,449
mathematical concept that it's typical

00:39:14,999 --> 00:39:22,019
use is very similar to a struct in c

00:39:18,449 --> 00:39:23,039
except instead of having they the fields

00:39:22,019 --> 00:39:28,739
be named

00:39:23,039 --> 00:39:31,559
they're just numbered a list is a

00:39:28,739 --> 00:39:34,439
mutable sequence don't let the name list

00:39:31,559 --> 00:39:37,319
who you it's not a linkedlist it's

00:39:34,439 --> 00:39:40,409
implemented as a vector it's in

00:39:37,319 --> 00:39:41,789
contiguous memory so that tells you if

00:39:40,409 --> 00:39:44,630
you're an experienced programmer all you

00:39:41,789 --> 00:39:46,679
need to know about its performance

00:39:44,630 --> 00:39:48,509
characteristic is notated with square

00:39:46,679 --> 00:39:51,989
brackets again you can build one

00:39:48,509 --> 00:39:54,449
explicitly by calling the type with a

00:39:51,989 --> 00:39:57,359
sequence argument certain frozen set are

00:39:54,449 --> 00:39:59,310
the mutable and immutable versions of

00:39:57,359 --> 00:40:02,790
sets which are basically implemented

00:39:59,310 --> 00:40:05,970
- tables our dick is a key value mapping

00:40:02,790 --> 00:40:08,880
also implemented with a mesh table again

00:40:05,970 --> 00:40:12,480
this indicates the notation you can

00:40:08,880 --> 00:40:13,890
always call the type in the case of

00:40:12,480 --> 00:40:17,820
dictionary you don't call it with a

00:40:13,890 --> 00:40:19,590
sequence but with keyword all containers

00:40:17,820 --> 00:40:22,380
have a length being the number of items

00:40:19,590 --> 00:40:24,630
they contain all containers of looping

00:40:22,380 --> 00:40:26,490
you can loop over all their items and

00:40:24,630 --> 00:40:28,830
all containers allowed membership

00:40:26,490 --> 00:40:32,400
testing if something isn't the container

00:40:28,830 --> 00:40:34,350
most of the containers tuple is the

00:40:32,400 --> 00:40:36,930
exception also have methods that let you

00:40:34,350 --> 00:40:39,330
do all sort of cool stuff set all those

00:40:36,930 --> 00:40:42,870
operators because that's the most

00:40:39,330 --> 00:40:45,060
natural way to express operations on set

00:40:42,870 --> 00:40:48,000
for example intersection you can spell

00:40:45,060 --> 00:40:53,820
ampersand Union you can spelled vertical

00:40:48,000 --> 00:40:56,100
bar sequences are a subset of containers

00:40:53,820 --> 00:40:58,590
specifically strings tuples and lists

00:40:56,100 --> 00:41:02,850
plus a lot of other stuff in the sender

00:40:58,590 --> 00:41:05,040
library which have some extra things you

00:41:02,850 --> 00:41:07,110
can do compared with what you can do to

00:41:05,040 --> 00:41:09,840
with other containers first of all you

00:41:07,110 --> 00:41:13,200
can ask for the repetition in catenation

00:41:09,840 --> 00:41:16,380
so given any two sequences a and b at

00:41:13,200 --> 00:41:18,840
the same time a plus b is the sequence

00:41:16,380 --> 00:41:20,370
which has oh I Tunes have been or a nor

00:41:18,840 --> 00:41:22,770
they're followed by all items of being

00:41:20,370 --> 00:41:24,540
order it's a very natural concept you

00:41:22,770 --> 00:41:26,930
can concatenate lists you can cut any

00:41:24,540 --> 00:41:29,150
strings you can concatenate tuples

00:41:26,930 --> 00:41:32,610
repetition is basically the same thing

00:41:29,150 --> 00:41:35,700
you could write a plus a plus a but you

00:41:32,610 --> 00:41:37,950
can write a times 3 or 3 times a it

00:41:35,700 --> 00:41:41,390
means exactly the same just like it

00:41:37,950 --> 00:41:44,760
would for numbers then you have indexing

00:41:41,390 --> 00:41:48,060
just write the index from the index all

00:41:44,760 --> 00:41:50,040
starts from 0 in square brackets you

00:41:48,060 --> 00:41:52,890
have slicing you write the two indices

00:41:50,040 --> 00:41:57,810
with a colon and you can have slicing

00:41:52,890 --> 00:42:01,860
with a step we write to start stop step

00:41:57,810 --> 00:42:05,970
the for example given the sequence e

00:42:01,860 --> 00:42:10,080
chow CIA o cho do a is a because we

00:42:05,970 --> 00:42:11,650
always start from 0 12 3 2 1 by minus 1

00:42:10,080 --> 00:42:14,830
meaning minus 1 so

00:42:11,650 --> 00:42:18,400
backwards so we started three zero one

00:42:14,830 --> 00:42:21,250
two three it's a no and we go up to down

00:42:18,400 --> 00:42:24,450
to one which would be the I excluded so

00:42:21,250 --> 00:42:27,940
we do oh and a in reverse order away

00:42:24,450 --> 00:42:31,450
always first bound included last bound

00:42:27,940 --> 00:42:34,050
excluded if you've read under screenings

00:42:31,450 --> 00:42:37,210
masterpiece see traps and pitfalls

00:42:34,050 --> 00:42:39,460
there's a whole chapter or why all of

00:42:37,210 --> 00:42:43,660
your loops should be first index

00:42:39,460 --> 00:42:45,370
included last ended excluded read that

00:42:43,660 --> 00:42:47,950
book even if you never program and see

00:42:45,370 --> 00:42:49,870
it's a great book just you like you

00:42:47,950 --> 00:42:51,840
should read KN air for they just because

00:42:49,870 --> 00:42:54,430
it's a great book so it's clinics and

00:42:51,840 --> 00:42:56,800
basically in Python you get it you get

00:42:54,430 --> 00:42:58,840
that concept built into the language and

00:42:56,800 --> 00:43:01,930
it's built-ins so this are mutable

00:42:58,840 --> 00:43:05,050
sequence so given an indexing or a slide

00:43:01,930 --> 00:43:06,790
you can assign to it moreover if you

00:43:05,050 --> 00:43:09,130
assign to uh slide you don't have to

00:43:06,790 --> 00:43:11,230
assign a list of the same length as the

00:43:09,130 --> 00:43:13,540
one at slide your assignment you can

00:43:11,230 --> 00:43:16,540
assign a shorter list with will collapse

00:43:13,540 --> 00:43:19,740
the list you will you can assign a

00:43:16,540 --> 00:43:23,020
longer one it will automatically extend

00:43:19,740 --> 00:43:25,060
that of course does mean that these kind

00:43:23,020 --> 00:43:27,640
of assignments can be very costly

00:43:25,060 --> 00:43:29,650
because as I said the thing is

00:43:27,640 --> 00:43:31,560
contiguous in memory so it has to move

00:43:29,650 --> 00:43:34,030
everything around to make space

00:43:31,560 --> 00:43:36,820
dictionaries insects are not sequences

00:43:34,030 --> 00:43:39,130
or so it makes no sense for example to

00:43:36,820 --> 00:43:41,230
multiply a set by three doesn't make any

00:43:39,130 --> 00:43:46,540
sense at all so button doesn't let you

00:43:41,230 --> 00:43:48,580
do it okay there's several comparison so

00:43:46,540 --> 00:43:51,790
you if you're familiar with the

00:43:48,580 --> 00:43:54,790
comparisons in Java you know why equal

00:43:51,790 --> 00:43:57,850
is different from what in in Python we

00:43:54,790 --> 00:44:01,960
spell is it's about the being the same

00:43:57,850 --> 00:44:04,740
object versus being same or distinct

00:44:01,960 --> 00:44:07,480
objects with the same contents

00:44:04,740 --> 00:44:11,590
containment is also test2 spelled in

00:44:07,480 --> 00:44:15,400
with operators in or not in comparisons

00:44:11,590 --> 00:44:19,360
can change so for example three less

00:44:15,400 --> 00:44:21,640
than a less equal X less than nine reads

00:44:19,360 --> 00:44:24,400
in exactly the natural way every time

00:44:21,640 --> 00:44:25,990
you teach any other language

00:44:24,400 --> 00:44:27,490
beginners you have to explain that this

00:44:25,990 --> 00:44:29,019
doesn't work with the way everybody

00:44:27,490 --> 00:44:32,170
thinks it would because it first

00:44:29,019 --> 00:44:34,539
computes three less than X which is

00:44:32,170 --> 00:44:36,990
maybe one and then it computes one less

00:44:34,539 --> 00:44:40,359
than nine which is true at least in see

00:44:36,990 --> 00:44:43,630
where comparisons are zero and one

00:44:40,359 --> 00:44:46,059
in Python it works exactly as everybody

00:44:43,630 --> 00:44:49,630
thinks it should work meaning X is

00:44:46,059 --> 00:44:54,759
greater than or equal to 3 and less than

00:44:49,630 --> 00:44:57,299
9 what is false in Python for purposes

00:44:54,759 --> 00:45:00,420
of if and while and other tests all

00:44:57,299 --> 00:45:04,539
numbers that equal zero are false

00:45:00,420 --> 00:45:08,019
empty strings are false none is false

00:45:04,539 --> 00:45:10,690
every empty container is false and false

00:45:08,019 --> 00:45:15,460
is false false with the uppercase F is

00:45:10,690 --> 00:45:18,039
the boolean construct equivalent to 0 so

00:45:15,460 --> 00:45:19,210
if you need something that is false and

00:45:18,039 --> 00:45:21,210
doesn't need to have any other

00:45:19,210 --> 00:45:22,980
characteristic you can know that

00:45:21,210 --> 00:45:26,740
everything else is true

00:45:22,980 --> 00:45:28,240
you see Python is a very belief oriented

00:45:26,740 --> 00:45:31,720
language because almost everything is

00:45:28,240 --> 00:45:33,009
true but if you need something that's

00:45:31,720 --> 00:45:34,660
only true another absolutely another

00:45:33,009 --> 00:45:39,309
interesting characteristic you can use

00:45:34,660 --> 00:45:42,489
true spelled with an uppercase T not is

00:45:39,309 --> 00:45:45,279
an operator which always gives you a

00:45:42,489 --> 00:45:48,309
boolean so not X is always the same as

00:45:45,279 --> 00:45:52,180
not bollocks so not of an empty sequence

00:45:48,309 --> 00:45:53,680
is true with another case T not of a

00:45:52,180 --> 00:45:58,059
non-empty sequence is false

00:45:53,680 --> 00:46:00,519
I keep seeing people who come to Python

00:45:58,059 --> 00:46:02,710
from other languages check if a sequence

00:46:00,519 --> 00:46:05,769
is empty by asking if length of that

00:46:02,710 --> 00:46:10,450
sequence equal equal 0 and that is wrong

00:46:05,769 --> 00:46:12,880
it's simply if not that sequence for

00:46:10,450 --> 00:46:15,190
example say members is the set of

00:46:12,880 --> 00:46:17,049
members of your association to do

00:46:15,190 --> 00:46:19,599
something like close the Association if

00:46:17,049 --> 00:46:22,239
it does November if not members close

00:46:19,599 --> 00:46:25,529
association that's Reese pretty natural

00:46:22,239 --> 00:46:28,900
not if Len of members equal equal 0 in

00:46:25,529 --> 00:46:31,390
the nor operator short-circuit like

00:46:28,900 --> 00:46:33,940
ampersand ampersand vertical bar

00:46:31,390 --> 00:46:35,950
vertical bar but very usefully they

00:46:33,940 --> 00:46:39,339
always return one of the operands

00:46:35,950 --> 00:46:41,559
so not necessarily true or false but any

00:46:39,339 --> 00:46:43,900
operand you've passed to them by

00:46:41,559 --> 00:46:48,099
short-circuit it means they don't bother

00:46:43,900 --> 00:46:49,630
to evaluate the right-hand operand if by

00:46:48,099 --> 00:46:53,920
the left hand they already know for

00:46:49,630 --> 00:46:58,599
example false and anything is false true

00:46:53,920 --> 00:47:02,049
or anything is true they right-hand

00:46:58,599 --> 00:47:04,510
operator might potentially even cause

00:47:02,049 --> 00:47:06,819
any kind of side effect that side effect

00:47:04,510 --> 00:47:09,400
won't happen that's guaranteed by the

00:47:06,819 --> 00:47:11,260
language there's also built-in functions

00:47:09,400 --> 00:47:13,240
any and all which can be called with any

00:47:11,260 --> 00:47:15,250
number of arguments which do essentially

00:47:13,240 --> 00:47:17,410
the same thing but on sequences of

00:47:15,250 --> 00:47:19,890
arbitrary length basically they

00:47:17,410 --> 00:47:22,990
terminate as soon as the result is known

00:47:19,890 --> 00:47:25,770
unfortunately there is no way to do that

00:47:22,990 --> 00:47:28,119
on empty sequences and still ensure that

00:47:25,770 --> 00:47:30,190
something is returned that is in the

00:47:28,119 --> 00:47:34,270
sequence because nothing is in an empty

00:47:30,190 --> 00:47:36,040
sequence so therefore any and all don't

00:47:34,270 --> 00:47:40,140
have this handy feature of always

00:47:36,040 --> 00:47:48,609
returning an operand a return a bool so

00:47:40,140 --> 00:47:50,530
it's potentially useful like in C++ or

00:47:48,609 --> 00:47:54,099
Java errors are handled through a

00:47:50,530 --> 00:47:55,809
concept known as exceptions not only

00:47:54,099 --> 00:47:59,170
errors but also anomalies that aren't

00:47:55,809 --> 00:48:01,990
errors Python uses a lot more exceptions

00:47:59,170 --> 00:48:07,119
than would be considered good style in

00:48:01,990 --> 00:48:09,280
either C++ or Java exceptions are

00:48:07,119 --> 00:48:11,740
instances of built-in type exception or

00:48:09,280 --> 00:48:14,260
any subtype of it there's a statement

00:48:11,740 --> 00:48:17,650
raised if you want to make noise

00:48:14,260 --> 00:48:19,750
explicitly they propagate along the

00:48:17,650 --> 00:48:21,099
stack of function calls terminating the

00:48:19,750 --> 00:48:22,690
function because they go until they're

00:48:21,099 --> 00:48:25,500
finally caught or if they're never

00:48:22,690 --> 00:48:29,760
caught your program is history and

00:48:25,500 --> 00:48:33,130
typically with a trace of the error that

00:48:29,760 --> 00:48:36,010
wasn't code you can use statum try

00:48:33,130 --> 00:48:38,140
except to catch exceptions you can just

00:48:36,010 --> 00:48:39,670
try finally to not catch obsession let

00:48:38,140 --> 00:48:41,920
you propagate the guarantees that some

00:48:39,670 --> 00:48:45,130
termination operation is done you can

00:48:41,920 --> 00:48:46,670
use the nicer form with which lets you

00:48:45,130 --> 00:48:51,940
implement the rest

00:48:46,670 --> 00:48:51,940
or allocation is initialization idiom

00:48:53,470 --> 00:48:58,070
now

00:48:54,800 --> 00:49:00,950
I mentioned a for statement as being

00:48:58,070 --> 00:49:03,650
separate for a while but the interesting

00:49:00,950 --> 00:49:06,290
thing is that the semantics are for are

00:49:03,650 --> 00:49:09,020
defined in terms of those of while and a

00:49:06,290 --> 00:49:12,070
concept known as a iterators so

00:49:09,020 --> 00:49:14,540
basically for I in see something means

00:49:12,070 --> 00:49:17,720
make a temporary variable which is the

00:49:14,540 --> 00:49:19,790
ITER of C ITER is a built-in function

00:49:17,720 --> 00:49:26,360
that returns the iterator for any

00:49:19,790 --> 00:49:31,390
container and start looping try getting

00:49:26,360 --> 00:49:34,280
the next item from the T then it's I if

00:49:31,390 --> 00:49:38,060
there's a stop iteration exception

00:49:34,280 --> 00:49:39,740
that's it and then do the body they're

00:49:38,060 --> 00:49:42,890
not exactly the same because an else

00:49:39,740 --> 00:49:45,710
clause in this for might execute well an

00:49:42,890 --> 00:49:47,780
else clause here would not execute

00:49:45,710 --> 00:49:52,310
because the only exit is via break but

00:49:47,780 --> 00:49:55,270
this is the sense of the equivalence and

00:49:52,310 --> 00:49:57,590
you can also build you can also have for

00:49:55,270 --> 00:49:59,990
embedded in an expression in other

00:49:57,590 --> 00:50:03,380
parenthesis to just make an iteration or

00:49:59,990 --> 00:50:06,170
square brackets to make a list this is

00:50:03,380 --> 00:50:08,300
known as a list comprehension and this

00:50:06,170 --> 00:50:11,540
is known as a generator expression or

00:50:08,300 --> 00:50:13,970
for short gain expo the optional closers

00:50:11,540 --> 00:50:18,910
mean you can nest further for and if

00:50:13,970 --> 00:50:24,590
closest to nest looping or or selecting

00:50:18,910 --> 00:50:27,290
whatever your you're doing with so the

00:50:24,590 --> 00:50:29,000
main way to organize your code is

00:50:27,290 --> 00:50:32,650
function is highly recommended to have

00:50:29,000 --> 00:50:35,960
all of your executable coding function

00:50:32,650 --> 00:50:37,670
among other things so since a function

00:50:35,960 --> 00:50:39,260
is a welder limited unit particularly if

00:50:37,670 --> 00:50:42,140
you write small functions Python can

00:50:39,260 --> 00:50:45,620
optimize much better try making exactly

00:50:42,140 --> 00:50:46,010
the same code at the global level in a

00:50:45,620 --> 00:50:48,770
module

00:50:46,010 --> 00:50:50,720
versus inside functions in the module

00:50:48,770 --> 00:50:53,090
and you see what I mean you can go two

00:50:50,720 --> 00:50:55,520
or three times faster if you have

00:50:53,090 --> 00:50:58,369
everything properly organizing

00:50:55,520 --> 00:51:02,060
so there's an a death which start the

00:50:58,369 --> 00:51:04,849
function name parameters in parentheses

00:51:02,060 --> 00:51:06,589
in a body the point is that when death

00:51:04,849 --> 00:51:08,180
executes and remember death is an

00:51:06,589 --> 00:51:10,130
executable statement there are no

00:51:08,180 --> 00:51:12,829
declaration when the statement death

00:51:10,130 --> 00:51:15,290
executes the body doesn't execute it

00:51:12,829 --> 00:51:18,349
gets compiled but then the compiled form

00:51:15,290 --> 00:51:22,130
is saved as part of the function object

00:51:18,349 --> 00:51:27,260
as generator and that function object is

00:51:22,130 --> 00:51:31,010
assigned it name name the parameters are

00:51:27,260 --> 00:51:35,480
zero or more local variables which get

00:51:31,010 --> 00:51:37,540
initialized by the color so like in C

00:51:35,480 --> 00:51:39,829
and it's the derivative languages

00:51:37,540 --> 00:51:41,030
parameters are the same thing so slow

00:51:39,829 --> 00:51:45,740
chol bearable s-- except their

00:51:41,030 --> 00:51:48,130
initialization happens at call time you

00:51:45,740 --> 00:51:50,660
could have default values like in c++

00:51:48,130 --> 00:51:55,310
only two trading parameters again like

00:51:50,660 --> 00:51:58,339
in c++ by writing equal sum expression

00:51:55,310 --> 00:52:01,310
to the name however the expression is

00:51:58,339 --> 00:52:03,650
evaluated only once the expression that

00:52:01,310 --> 00:52:08,030
makes up the default value is evaluated

00:52:03,650 --> 00:52:11,359
when the DEF statement executes and so

00:52:08,030 --> 00:52:13,460
therefore anytime you make use of a

00:52:11,359 --> 00:52:16,940
default value for a parameter is going

00:52:13,460 --> 00:52:19,790
to be exactly the same object parameters

00:52:16,940 --> 00:52:22,640
may end with star name to take a tuple

00:52:19,790 --> 00:52:25,000
of arbitrary positional argument or star

00:52:22,640 --> 00:52:29,359
surname to take a dictionary of

00:52:25,000 --> 00:52:31,430
arbitrary named argument which is

00:52:29,359 --> 00:52:33,650
basically useful when you want to make

00:52:31,430 --> 00:52:36,680
function what even the c are called very

00:52:33,650 --> 00:52:39,109
attic functions which take a arbitrary

00:52:36,680 --> 00:52:42,770
number of parameters here's an example

00:52:39,109 --> 00:52:47,630
of function first of all the most simple

00:52:42,770 --> 00:52:50,240
obvious way to do a sum of square take a

00:52:47,630 --> 00:52:53,569
and b there are the parameters and do a

00:52:50,240 --> 00:52:55,790
times a plus B times B by the way as any

00:52:53,569 --> 00:52:57,319
old time fortune programmer will tell

00:52:55,790 --> 00:53:00,200
you the fact that you have the race to

00:52:57,319 --> 00:53:04,310
power operator doesn't mean you should

00:53:00,200 --> 00:53:07,550
use it to do squares a times a is

00:53:04,310 --> 00:53:10,790
actually faster than a star star do

00:53:07,550 --> 00:53:12,380
- it's probably not true unfortunate

00:53:10,790 --> 00:53:14,180
anymore because the Fortune compilers

00:53:12,380 --> 00:53:15,890
have become pretty smart but Python

00:53:14,180 --> 00:53:18,110
compiler never tries to be till tomorrow

00:53:15,890 --> 00:53:21,710
sighs gotta be a reason this guy is

00:53:18,110 --> 00:53:23,870
right I was written a stanza - I'm going

00:53:21,710 --> 00:53:27,140
to compile exactly the bytecode to

00:53:23,870 --> 00:53:29,570
compute the power and that's slower than

00:53:27,140 --> 00:53:32,300
the one that computes the multiplication

00:53:29,570 --> 00:53:35,990
so remember do it as if you didn't have

00:53:32,300 --> 00:53:37,820
the raise to power so you can just print

00:53:35,990 --> 00:53:40,400
the sum squares then you get the area

00:53:37,820 --> 00:53:43,100
that of the square built on the

00:53:40,400 --> 00:53:45,020
hypotenuse but why limit yourself to two

00:53:43,100 --> 00:53:47,240
sides I mean Pythagoras would be happy

00:53:45,020 --> 00:53:48,800
because this is what you're doing but

00:53:47,240 --> 00:53:52,900
you don't have to because you can take

00:53:48,800 --> 00:53:55,790
an arbitrary number of parameters and

00:53:52,900 --> 00:53:59,330
this is how you send them all sum all of

00:53:55,790 --> 00:54:04,510
the square remember our syntax for the

00:53:59,330 --> 00:54:09,260
generator expression expression for some

00:54:04,510 --> 00:54:12,830
item in a container here's exactly what

00:54:09,260 --> 00:54:16,100
we have expression X 10 X 4 X arbitrary

00:54:12,830 --> 00:54:17,810
name for an item in the container a the

00:54:16,100 --> 00:54:20,420
tuple of all arguments passed to the

00:54:17,810 --> 00:54:22,970
function so this works just as well if

00:54:20,420 --> 00:54:24,860
you print as soon as Q 23:45 but you can

00:54:22,970 --> 00:54:28,940
keep passing arguments and we work just

00:54:24,860 --> 00:54:32,120
as fine this is the low level occurring

00:54:28,940 --> 00:54:37,250
it's okay I mean it works but Python

00:54:32,120 --> 00:54:39,380
tends to have a okay there's a concert

00:54:37,250 --> 00:54:42,620
very important constantly in C++ known

00:54:39,380 --> 00:54:44,720
as the abstraction penalty something dr.

00:54:42,620 --> 00:54:47,360
Stepanov has been measuring for decades

00:54:44,720 --> 00:54:49,040
now basically how much does it cost me

00:54:47,360 --> 00:54:52,390
to do things right and work at a high

00:54:49,040 --> 00:54:55,390
level of abstraction rather than very

00:54:52,390 --> 00:54:58,970
lower level closer to the machine and

00:54:55,390 --> 00:55:00,290
slowly gradually a C++ compiler become

00:54:58,970 --> 00:55:03,160
more and more complicated and

00:55:00,290 --> 00:55:05,360
sophisticated it's slowly going down

00:55:03,160 --> 00:55:07,790
Python does things differently we

00:55:05,360 --> 00:55:10,550
typically have an abstraction reward

00:55:07,790 --> 00:55:12,410
they more abstractly you program the

00:55:10,550 --> 00:55:14,870
further from the machine than the closer

00:55:12,410 --> 00:55:16,049
to mathematics into your problem the

00:55:14,870 --> 00:55:18,779
faster your code

00:55:16,049 --> 00:55:21,719
go try it's very easy get a Python

00:55:18,779 --> 00:55:25,019
interpreter check how long will this

00:55:21,719 --> 00:55:28,410
take for a dozen arguments versus how

00:55:25,019 --> 00:55:33,410
long will this elementary lower-level

00:55:28,410 --> 00:55:35,969
closer to the machine expression thing

00:55:33,410 --> 00:55:38,009
since we're on the subject of loops and

00:55:35,969 --> 00:55:39,839
end functions I should mention

00:55:38,009 --> 00:55:42,779
generators derivatives of functions

00:55:39,839 --> 00:55:45,719
which instead of return to give a value

00:55:42,779 --> 00:55:47,459
and you know return gives the value in

00:55:45,719 --> 00:55:49,609
terminates the function of the same time

00:55:47,459 --> 00:55:54,359
that's true in any of these languages

00:55:49,609 --> 00:55:58,109
they use yield yield gives a value but

00:55:54,359 --> 00:56:00,809
suspends the function ready for the next

00:55:58,109 --> 00:56:04,650
time and by the next time we mean that

00:56:00,809 --> 00:56:07,170
when the function is called it returns

00:56:04,650 --> 00:56:10,229
some an object which has a method called

00:56:07,170 --> 00:56:12,509
next every time you call next the

00:56:10,229 --> 00:56:14,579
function restarts from wherever it last

00:56:12,509 --> 00:56:17,189
yielded the first time it starts from

00:56:14,579 --> 00:56:19,140
the start and then every time it starts

00:56:17,189 --> 00:56:22,140
from the last yield where it got

00:56:19,140 --> 00:56:24,390
suspended its but this is particularly

00:56:22,140 --> 00:56:26,309
suitable for looping in a for because of

00:56:24,390 --> 00:56:30,119
what I mentioned before an iterator

00:56:26,309 --> 00:56:34,439
having the next method means you can use

00:56:30,119 --> 00:56:36,359
it in a loop just to complete that when

00:56:34,439 --> 00:56:39,539
the function ends it has yielded all it

00:56:36,359 --> 00:56:42,349
and it runs of the end or hits a return

00:56:39,539 --> 00:56:45,119
statement then it raises a stop iterator

00:56:42,349 --> 00:56:47,519
so if you're using it in a four it

00:56:45,119 --> 00:56:50,099
exists normally for example this is

00:56:47,519 --> 00:56:53,339
actually a built-in but if it werent

00:56:50,099 --> 00:56:55,920
this is how you would make something

00:56:53,339 --> 00:56:58,410
which even a sequence gives back one

00:56:55,920 --> 00:57:01,380
after all of the items of the sequence

00:56:58,410 --> 00:57:06,239
each with its proper index zero one two

00:57:01,380 --> 00:57:10,170
three so you pass it quote ciao quote it

00:57:06,239 --> 00:57:13,079
yields first time zero C then one I then

00:57:10,170 --> 00:57:15,900
to a then three oh and then raises top

00:57:13,079 --> 00:57:19,559
duration it's not very difficult you

00:57:15,900 --> 00:57:22,859
start with n equals zero loop over the

00:57:19,559 --> 00:57:25,739
sequence and yield N and the item at

00:57:22,859 --> 00:57:27,590
this point the function suspends once

00:57:25,739 --> 00:57:30,060
yielded the first

00:57:27,590 --> 00:57:33,480
still ready all of its local variables

00:57:30,060 --> 00:57:37,080
and in particular are still perfect

00:57:33,480 --> 00:57:40,050
intact when you call next or at the next

00:57:37,080 --> 00:57:43,650
iteration and gets incremented and you

00:57:40,050 --> 00:57:45,600
do the next stop so you're suspending in

00:57:43,650 --> 00:57:49,740
the middle of a loop ready for the next

00:57:45,600 --> 00:57:53,190
time very handy this is an example of

00:57:49,740 --> 00:57:57,270
how and it can be a generator I said

00:57:53,190 --> 00:57:59,100
they function or a stop I just did the

00:57:57,270 --> 00:58:03,090
object returned by the function will

00:57:59,100 --> 00:58:04,920
raise a stop iteration when there's

00:58:03,090 --> 00:58:07,800
nothing more to yield but I should have

00:58:04,920 --> 00:58:10,230
said if it went because this is a case

00:58:07,800 --> 00:58:12,180
in which it just keeps going well it

00:58:10,230 --> 00:58:16,520
will eventually fill up your memory

00:58:12,180 --> 00:58:19,440
since at some point you will have

00:58:16,520 --> 00:58:22,860
integers that take about a gigabyte each

00:58:19,440 --> 00:58:24,860
to represent and you will be running out

00:58:22,860 --> 00:58:32,100
of memory but it will take quite a while

00:58:24,860 --> 00:58:37,350
so this is a Fibonacci sequence from my

00:58:32,100 --> 00:58:40,010
compatriot well known as one of the

00:58:37,350 --> 00:58:43,830
first arithmetician

00:58:40,010 --> 00:58:45,390
it sounds as I&J to one and while true

00:58:43,830 --> 00:58:46,950
all this is by the way something I

00:58:45,390 --> 00:58:47,640
didn't really mention is a multiple

00:58:46,950 --> 00:58:50,430
assignment

00:58:47,640 --> 00:58:55,290
I'm simultaneously assigning to are I

00:58:50,430 --> 00:58:58,770
and J the expressions IJ and I plus J so

00:58:55,290 --> 00:59:01,980
the whole everything on the right hand

00:58:58,770 --> 00:59:03,300
side is computed first and then

00:59:01,980 --> 00:59:05,310
everything on the left hand side is

00:59:03,300 --> 00:59:09,060
assigned so you don't have to worry

00:59:05,310 --> 00:59:11,910
about I and J changing on you when

00:59:09,060 --> 00:59:13,830
you're still using them here it's a

00:59:11,910 --> 00:59:16,670
simple multiple it's just a multiple

00:59:13,830 --> 00:59:22,920
assignment if you've ever used

00:59:16,670 --> 00:59:24,780
SNL or or Haskell R is what ever used to

00:59:22,920 --> 00:59:29,570
be na is the number of rabbits actually

00:59:24,780 --> 00:59:32,070
and so we yield it and we never end the

00:59:29,570 --> 00:59:34,440
problem that Fibonacci was discussing in

00:59:32,070 --> 00:59:38,400
his book is I have this farm raising

00:59:34,440 --> 00:59:40,190
rabbits and I start with one only one

00:59:38,400 --> 00:59:44,569
rabbit and

00:59:40,190 --> 00:59:47,420
after 2e when his 2 years old I get as

00:59:44,569 --> 00:59:52,910
many rabbits as I had in the previous

00:59:47,420 --> 00:59:55,430
two years so this is how the sequence so

00:59:52,910 --> 00:59:57,530
this is how we use it we have to

00:59:55,430 --> 00:59:59,750
explicitly break out of the loop at some

00:59:57,530 --> 01:00:01,550
point in this case I'm doing it I'm

00:59:59,750 --> 01:00:05,030
going to sell the farm when I have more

01:00:01,550 --> 01:00:11,270
than 100 rabbits and retire to some less

01:00:05,030 --> 01:00:13,430
stressful job and this tells you how

01:00:11,270 --> 01:00:18,859
many rubbish you'll have to house every

01:00:13,430 --> 01:00:22,700
year closures well known to every

01:00:18,859 --> 01:00:24,829
functional programmer but just I did

01:00:22,700 --> 01:00:28,790
mention very briefly that closures are a

01:00:24,829 --> 01:00:30,530
natural in in Python actually said like

01:00:28,790 --> 01:00:33,380
in C++ they're actually much handier

01:00:30,530 --> 01:00:34,849
here that in C++ because we exploit the

01:00:33,380 --> 01:00:37,790
fact that death is an executable

01:00:34,849 --> 01:00:40,280
statement that creates a new function

01:00:37,790 --> 01:00:42,170
object and we also exploit lexical

01:00:40,280 --> 01:00:45,880
scoping you can't have nested function

01:00:42,170 --> 01:00:48,970
in C so it's not really so this is the

01:00:45,880 --> 01:00:52,190
trivial example we want to make an adder

01:00:48,970 --> 01:00:54,319
with a given add end I'll simply make a

01:00:52,190 --> 01:00:56,060
function which take the other Samand

01:00:54,319 --> 01:00:59,060
which is known as the ouch end nobody

01:00:56,060 --> 01:01:01,910
knows that though but I do and which is

01:00:59,060 --> 01:01:05,240
your gender class here then and from the

01:01:01,910 --> 01:01:08,690
make adder we return harder so make up

01:01:05,240 --> 01:01:12,680
variable here is looked at here so we

01:01:08,690 --> 01:01:15,040
can print a 20 through 100 a 42 of 100

01:01:12,680 --> 01:01:17,900
or one of the other and everything works

01:01:15,040 --> 01:01:20,270
there's no interference like they're

01:01:17,900 --> 01:01:21,920
kind of like is that kind of like in

01:01:20,270 --> 01:01:24,560
some shading a class except that it only

01:01:21,920 --> 01:01:26,740
applies to a very narrow set of use

01:01:24,560 --> 01:01:28,640
cases but it's very useful to have

01:01:26,740 --> 01:01:31,369
because it's so much simpler

01:01:28,640 --> 01:01:33,319
our decorators are purely syntactical

01:01:31,369 --> 01:01:35,780
form to apply higher-order functions

01:01:33,319 --> 01:01:37,550
basically to wrap a function into

01:01:35,780 --> 01:01:42,440
another function or function of function

01:01:37,550 --> 01:01:45,500
and assign it it's kind of handy okay

01:01:42,440 --> 01:01:47,119
there's two styles of classes in Python

01:01:45,500 --> 01:01:48,589
for backwards compatibility reason I'm

01:01:47,119 --> 01:01:49,190
only going to talk about the new style

01:01:48,589 --> 01:01:52,710
process

01:01:49,190 --> 01:01:56,800
forget the existence of legacy classes

01:01:52,710 --> 01:01:59,080
you have to give some basil's all the

01:01:56,800 --> 01:02:00,880
time there are other methods but if you

01:01:59,080 --> 01:02:02,950
don't have any bases you care about just

01:02:00,880 --> 01:02:05,110
right open paren object closed paren

01:02:02,950 --> 01:02:06,960
have you ever eating in Aries from

01:02:05,110 --> 01:02:10,240
objects so you're not going to break it

01:02:06,960 --> 01:02:12,700
so its class name basis and a body and

01:02:10,240 --> 01:02:15,640
the body is just a series of statements

01:02:12,700 --> 01:02:17,460
of your choice but they're invariably

01:02:15,640 --> 01:02:19,870
death and assignment statements

01:02:17,460 --> 01:02:21,910
everything is your defining or assigning

01:02:19,870 --> 01:02:26,710
in the body becomes an attribute of the

01:02:21,910 --> 01:02:28,660
class object and also all the attributes

01:02:26,710 --> 01:02:30,640
of the bayes's are attributes of the

01:02:28,660 --> 01:02:32,350
nucleus object unless the nucleus object

01:02:30,640 --> 01:02:36,970
overrides them with something else in

01:02:32,350 --> 01:02:39,070
the same way so to create an instance

01:02:36,970 --> 01:02:41,290
you just call the class that's very

01:02:39,070 --> 01:02:43,570
handy because basically you can easily

01:02:41,290 --> 01:02:46,660
make a function that takes as one of

01:02:43,570 --> 01:02:49,390
these argument something which gives it

01:02:46,660 --> 01:02:50,830
something else just calling it it

01:02:49,390 --> 01:02:52,750
doesn't have to know whether it's a

01:02:50,830 --> 01:02:58,620
class object or a function object it

01:02:52,750 --> 01:03:02,080
just calls it so this is an example

01:02:58,620 --> 01:03:06,580
which is why I'm calling it eg or exams

01:03:02,080 --> 01:03:09,040
given we have a class attribute a simple

01:03:06,580 --> 01:03:12,100
list empty initially and this is an

01:03:09,040 --> 01:03:14,650
attribute of the class so shared if you

01:03:12,100 --> 01:03:16,720
will by every instance of the class this

01:03:14,650 --> 01:03:20,170
on the other hand we assign as an

01:03:16,720 --> 01:03:22,750
attribute of self which is the way we

01:03:20,170 --> 01:03:27,480
refer to the object the instance and

01:03:22,750 --> 01:03:27,480
this is an empty dictionary as an

01:03:27,630 --> 01:03:32,800
variable of the instance we have a

01:03:30,520 --> 01:03:36,730
method which append something to the

01:03:32,800 --> 01:03:38,400
class CLA the class variable and we have

01:03:36,730 --> 01:03:41,680
another method which assigned something

01:03:38,400 --> 01:03:46,690
some item to the dictionary and we make

01:03:41,680 --> 01:03:49,240
two of these instances then okay in the

01:03:46,690 --> 01:03:51,640
beginning everything is empty then we

01:03:49,240 --> 01:03:55,720
call the methods a few time and now we

01:03:51,640 --> 01:03:58,990
see that the class attribute is actually

01:03:55,720 --> 01:04:01,600
being modified twice by one and then by

01:03:58,990 --> 01:04:04,820
four while the instance attributes are

01:04:01,600 --> 01:04:07,550
separate so we can check with the ears

01:04:04,820 --> 01:04:09,470
are they the same object well in terms

01:04:07,550 --> 01:04:11,360
of the class attribute es because these

01:04:09,470 --> 01:04:13,510
are two instances of the same class in

01:04:11,360 --> 01:04:17,320
terms of the instance attributes no

01:04:13,510 --> 01:04:22,250
because their instance attitude

01:04:17,320 --> 01:04:24,050
whenever you look up a method or an

01:04:22,250 --> 01:04:25,760
instance in order to call it or for

01:04:24,050 --> 01:04:29,350
whatever other purposes they look up in

01:04:25,760 --> 01:04:29,350
the caller totally separate operations

01:04:29,710 --> 01:04:35,930
we go to the type of the instance which

01:04:32,780 --> 01:04:37,910
would be class if you'd rather call the

01:04:35,930 --> 01:04:39,860
method and implicitly pass the instance

01:04:37,910 --> 01:04:42,980
of the first argument of the one we have

01:04:39,860 --> 01:04:44,870
called self previously whenever we do

01:04:42,980 --> 01:04:46,370
the lookup well this is what happens

01:04:44,870 --> 01:04:48,830
except for descriptors which are not

01:04:46,370 --> 01:04:51,230
going into here with very important

01:04:48,830 --> 01:04:52,910
mechanism first of all we look in the

01:04:51,230 --> 01:04:55,160
dictionary which belongs to an instance

01:04:52,910 --> 01:04:57,290
every instance as a dictionary and we

01:04:55,160 --> 01:05:00,020
just can look up the name if that

01:04:57,290 --> 01:05:02,870
doesn't work well we are going to look

01:05:00,020 --> 01:05:06,710
in the dictionary of the title the

01:05:02,870 --> 01:05:08,480
instance the class or it's not there we

01:05:06,710 --> 01:05:12,710
do the same thing for each of the basis

01:05:08,480 --> 01:05:14,810
if not we try the special art special

01:05:12,710 --> 01:05:17,120
method called get outer in case somebody

01:05:14,810 --> 01:05:20,000
else defined it which can essentially

01:05:17,120 --> 01:05:22,370
build dynamically just in time whatever

01:05:20,000 --> 01:05:23,870
is meant to correspond to that thing and

01:05:22,370 --> 01:05:27,680
if everything fails to raise an

01:05:23,870 --> 01:05:30,800
exception an attribute our this our

01:05:27,680 --> 01:05:33,610
example of sub classing remember that

01:05:30,800 --> 01:05:37,280
class EG well we're overriding method

01:05:33,610 --> 01:05:40,430
we're overriding it simply to give Y a

01:05:37,280 --> 01:05:43,010
default value then we just call our

01:05:40,430 --> 01:05:46,280
superclass or we can also use a word

01:05:43,010 --> 01:05:48,860
super to do that but I honestly find

01:05:46,280 --> 01:05:52,100
this more readable this is pre abysm

01:05:48,860 --> 01:05:57,260
calling the method on mr. eg and passing

01:05:52,100 --> 01:06:00,350
it so this isn't so obvious another

01:05:57,260 --> 01:06:02,360
example we can overwrite data suppose we

01:06:00,350 --> 01:06:05,950
have a subclass of list which each time

01:06:02,360 --> 01:06:10,610
you append something offense it twice a

01:06:05,950 --> 01:06:14,840
repeater well then they we can suppress

01:06:10,610 --> 01:06:16,970
sub and override the class variable so

01:06:14,840 --> 01:06:17,460
that all the methods are the same but

01:06:16,970 --> 01:06:22,290
the class

01:06:17,460 --> 01:06:26,609
is a separate one another important

01:06:22,290 --> 01:06:29,130
concept our properties I said I wouldn't

01:06:26,609 --> 01:06:31,680
talk about descriptors but these are of

01:06:29,130 --> 01:06:33,450
all the descriptor types this are the

01:06:31,680 --> 01:06:38,160
most important built-in descriptor type

01:06:33,450 --> 01:06:40,440
the property say you have a getter

01:06:38,160 --> 01:06:43,560
method which without any argument

01:06:40,440 --> 01:06:46,170
returns a value and a setter method

01:06:43,560 --> 01:06:48,180
which given a value does something with

01:06:46,170 --> 01:06:51,060
it presumably assigns it somewhere

01:06:48,180 --> 01:06:52,770
somehow stores it in the class then you

01:06:51,060 --> 01:06:55,950
can wrap the getter and the setter in a

01:06:52,770 --> 01:06:57,960
property and assign it to a name now if

01:06:55,950 --> 01:07:00,540
you have an instance of this class every

01:06:57,960 --> 01:07:03,990
time you access the name you actually

01:07:00,540 --> 01:07:06,540
call the getter and every time you

01:07:03,990 --> 01:07:12,349
assign to the name you actually call the

01:07:06,540 --> 01:07:14,790
setter instead so this is basically

01:07:12,349 --> 01:07:18,080
property of basically offers you syntax

01:07:14,790 --> 01:07:21,780
sugar so that instead of calling an

01:07:18,080 --> 01:07:23,460
appropriate method you can just act as

01:07:21,780 --> 01:07:26,550
if you were accessing an attribute or

01:07:23,460 --> 01:07:28,200
setting an attribute why this matters is

01:07:26,550 --> 01:07:29,849
that in this way you never need to hide

01:07:28,200 --> 01:07:34,020
attributes behind the getters and

01:07:29,849 --> 01:07:36,150
setters anytime your class has an

01:07:34,020 --> 01:07:38,640
interesting attribute you just expose it

01:07:36,150 --> 01:07:40,580
forget encapsulation it was invented

01:07:38,640 --> 01:07:44,250
before the concept of property was

01:07:40,580 --> 01:07:46,380
invented the point is if you're in the

01:07:44,250 --> 01:07:48,450
next series of your code suddenly

01:07:46,380 --> 01:07:51,869
doesn't have that attribute anymore it

01:07:48,450 --> 01:07:53,430
needs to compute it rather just write

01:07:51,869 --> 01:07:55,859
your getter method and rub it in a

01:07:53,430 --> 01:07:56,339
property by that name you're done no

01:07:55,859 --> 01:08:00,300
problem

01:07:56,339 --> 01:08:02,130
all of the code keeps working all of the

01:08:00,300 --> 01:08:04,670
code that using the class doesn't need

01:08:02,130 --> 01:08:08,040
to do anything special it just works

01:08:04,670 --> 01:08:11,040
avoid boilerplate if in Python you ever

01:08:08,040 --> 01:08:13,109
see somebody writing death get through

01:08:11,040 --> 01:08:16,490
self return self foo you know this guy

01:08:13,109 --> 01:08:16,490
hasn't learned Python yet

01:08:19,100 --> 01:08:24,660
Python like C++ a force operator

01:08:21,630 --> 01:08:29,730
overloading those legions and legions of

01:08:24,660 --> 01:08:30,960
methods we have to underscore right at

01:08:29,730 --> 01:08:33,509
the beginning and end of the name

01:08:30,960 --> 01:08:36,719
because basically these aren't meant to

01:08:33,509 --> 01:08:38,940
be called directly the Python will call

01:08:36,719 --> 01:08:40,739
the special methods on the type as

01:08:38,940 --> 01:08:44,069
appropriate don't call them yourself

01:08:40,739 --> 01:08:46,620
with rare exception so that's why we

01:08:44,069 --> 01:08:52,529
made them ugly so they wouldn't be

01:08:46,620 --> 01:08:55,199
tempted to call it for example this

01:08:52,529 --> 01:08:59,310
method these methods lets you define the

01:08:55,199 --> 01:09:01,529
semantics of comparisons these as you

01:08:59,310 --> 01:09:06,600
define the semantics offereth medic

01:09:01,529 --> 01:09:09,180
operation or these define semantics

01:09:06,600 --> 01:09:12,089
basically defining how is your type a

01:09:09,180 --> 01:09:14,370
container how you get items that item

01:09:12,089 --> 01:09:18,020
delete item how you know how Lang how

01:09:14,370 --> 01:09:22,830
long is an instance and so on

01:09:18,020 --> 01:09:27,120
for example this is the equivalent

01:09:22,830 --> 01:09:29,190
written out in full as a class of that

01:09:27,120 --> 01:09:32,549
handy Fibonacci generator I showed

01:09:29,190 --> 01:09:35,190
before this doesn't use the suspended

01:09:32,549 --> 01:09:37,799
function concept and so on it just those

01:09:35,190 --> 01:09:40,920
things plotting Li it uses the init

01:09:37,799 --> 01:09:42,930
method to do initialization the I J

01:09:40,920 --> 01:09:46,109
which I used to have are now explicitly

01:09:42,930 --> 01:09:48,509
indicated as instance variables it uses

01:09:46,109 --> 01:09:51,719
the iteration special method returning

01:09:48,509 --> 01:09:54,239
itself because it is an iterator and it

01:09:51,719 --> 01:09:56,250
has the next that this is meant possibly

01:09:54,239 --> 01:09:59,160
for calling yourself so it doesn't have

01:09:56,250 --> 01:10:01,140
the the underscores the still special

01:09:59,160 --> 01:10:04,050
method and it does basically the same

01:10:01,140 --> 01:10:05,670
computation as we did of course you can

01:10:04,050 --> 01:10:09,390
of course it's using exactly the same

01:10:05,670 --> 01:10:11,370
way you see why we draw the writer

01:10:09,390 --> 01:10:13,860
generator which was like three lines

01:10:11,370 --> 01:10:15,090
instead of seven but this the point is

01:10:13,860 --> 01:10:18,830
that internally the generator

01:10:15,090 --> 01:10:18,830
essentially builds something like that

01:10:19,040 --> 01:10:23,520
so don't call special method directly

01:10:21,420 --> 01:10:27,360
built-in functions and other operations

01:10:23,520 --> 01:10:29,190
do it right for you for example definite

01:10:27,360 --> 01:10:31,440
example somebody doesn't know Python if

01:10:29,190 --> 01:10:31,890
he gets the absolute value by explicitly

01:10:31,440 --> 01:10:34,410
calling

01:10:31,890 --> 01:10:36,360
under under under under what you should

01:10:34,410 --> 01:10:38,820
do is called ABS absolutely do whatever

01:10:36,360 --> 01:10:41,040
is proper because that may include like

01:10:38,820 --> 01:10:42,480
I try this special method if that

01:10:41,040 --> 01:10:44,580
special method is not there try

01:10:42,480 --> 01:10:46,920
comparing with zero possibly change the

01:10:44,580 --> 01:10:49,230
sign also the staff that happens under

01:10:46,920 --> 01:10:51,540
the cover and you don't normally want to

01:10:49,230 --> 01:10:54,600
bypass it all those plenty of

01:10:51,540 --> 01:10:57,180
interesting built-ins and most of the

01:10:54,600 --> 01:11:00,390
other interesting stuff is in the

01:10:57,180 --> 01:11:03,800
standard library okay here's an example

01:11:00,390 --> 01:11:08,250
using three built-ins I have highlighted

01:11:03,800 --> 01:11:12,270
them we want to build in index for a

01:11:08,250 --> 01:11:14,490
text file meaning we want to print in

01:11:12,270 --> 01:11:16,920
alphabetical order all the words in the

01:11:14,490 --> 01:11:24,120
text file for each word the list of line

01:11:16,920 --> 01:11:26,850
numbers where that word occurs so first

01:11:24,120 --> 01:11:30,870
of all we build a dictionary which maps

01:11:26,850 --> 01:11:33,720
a word to a list of line numbers we

01:11:30,870 --> 01:11:35,340
start with an empty dictionary we use

01:11:33,720 --> 01:11:37,830
the with statement because that

01:11:35,340 --> 01:11:41,190
guarantees is like a try finally except

01:11:37,830 --> 01:11:44,790
this nicer syntax it will open the file

01:11:41,190 --> 01:11:47,790
name give us the results as file F and

01:11:44,790 --> 01:11:50,760
then intrinsically close that when we

01:11:47,790 --> 01:11:53,370
exit by any means whatsoever then we use

01:11:50,760 --> 01:11:56,520
enumerate which gives you line number

01:11:53,370 --> 01:11:58,440
and in the text of the line split the

01:11:56,520 --> 01:12:00,090
line that's one of the many methods of

01:11:58,440 --> 01:12:03,720
strings which I mentioned which splits

01:12:00,090 --> 01:12:06,720
them into words set default is a method

01:12:03,720 --> 01:12:08,490
of the dictionaries which basically

01:12:06,720 --> 01:12:10,830
assigned something if it wasn't already

01:12:08,490 --> 01:12:13,470
assigned a value if there wasn't already

01:12:10,830 --> 01:12:15,810
anything assigned for that value here's

01:12:13,470 --> 01:12:19,200
our default is the empty string for that

01:12:15,810 --> 01:12:21,360
given word so the empty list I'm sorry

01:12:19,200 --> 01:12:22,860
so we can just append the line number so

01:12:21,360 --> 01:12:25,740
we're building up our list of line

01:12:22,860 --> 01:12:28,050
numbers okay when we're done with these

01:12:25,740 --> 01:12:31,200
five lines we have our dictionary and

01:12:28,050 --> 01:12:33,600
now we only need to display it so we

01:12:31,200 --> 01:12:36,020
wanted sorted versions the natural

01:12:33,600 --> 01:12:40,260
comparison of courses alphabetical well

01:12:36,020 --> 01:12:41,460
may not be like all all lowercase comes

01:12:40,260 --> 01:12:43,050
before a sorry

01:12:41,460 --> 01:12:46,380
uppercase come before

01:12:43,050 --> 01:12:47,309
kay is a typical ascii order but good

01:12:46,380 --> 01:12:49,980
enough for me

01:12:47,309 --> 01:12:52,889
and we just use print with a little bit

01:12:49,980 --> 01:12:56,790
of formatting and a comma to not break

01:12:52,889 --> 01:12:58,739
line yet we loop over lo all the line

01:12:56,790 --> 01:13:00,570
numbers for the index of the world and

01:12:58,739 --> 01:13:02,730
print them again with a comma to not

01:13:00,570 --> 01:13:04,710
break and finally we do an empty print

01:13:02,730 --> 01:13:07,050
just to break the line so there it is

01:13:04,710 --> 01:13:10,579
this is a complete index and and display

01:13:07,050 --> 01:13:16,440
of the index of the text file I once

01:13:10,579 --> 01:13:19,650
tried coding it for C++ in C++ goes for

01:13:16,440 --> 01:13:22,110
fun but I gave up because it was just a

01:13:19,650 --> 01:13:25,770
joke they code is totally unreadable in

01:13:22,110 --> 01:13:30,320
a slide and the funny thing is that this

01:13:25,770 --> 01:13:30,320
is actually typically faster in Python

01:13:32,540 --> 01:13:39,300
this is printed multiple times yes we

01:13:35,219 --> 01:13:41,130
are carefully doing that here's the

01:13:39,300 --> 01:13:43,559
alternative of course would be to

01:13:41,130 --> 01:13:46,980
essentially map a word instead of a list

01:13:43,559 --> 01:13:49,020
of lines map it to a set of lines so

01:13:46,980 --> 01:13:51,929
sets intrinsically are not application

01:13:49,020 --> 01:13:55,650
so if you only want one occurrence well

01:13:51,929 --> 01:13:58,530
instead of of these square bracket use a

01:13:55,650 --> 01:14:02,040
set open close print and instead of a

01:13:58,530 --> 01:14:06,989
pen called ad which is how you add items

01:14:02,040 --> 01:14:10,199
and here you would have the to use

01:14:06,989 --> 01:14:14,550
sorted if you want the line number to be

01:14:10,199 --> 01:14:16,619
sorted so you'd have to change two tiny

01:14:14,550 --> 01:14:19,380
spots here and one tiny spot there and

01:14:16,619 --> 01:14:24,599
you would avoid duplications if that's

01:14:19,380 --> 01:14:27,480
what you want okay

01:14:24,599 --> 01:14:30,239
so I do say Python points a lot of

01:14:27,480 --> 01:14:32,010
modularity so how do you import the

01:14:30,239 --> 01:14:34,860
modules the library is full of them you

01:14:32,010 --> 01:14:37,770
just import module name or from some dot

01:14:34,860 --> 01:14:40,020
package import module name and then you

01:14:37,770 --> 01:14:41,309
just use module name dot whatever you

01:14:40,020 --> 01:14:43,409
want

01:14:41,309 --> 01:14:45,989
there are shortcuts available but

01:14:43,409 --> 01:14:50,489
they're never recommended you don't

01:14:45,989 --> 01:14:52,930
don't just inject an alien namespace

01:14:50,489 --> 01:14:55,860
into your own it's it's not

01:14:52,930 --> 01:15:01,380
good idea namespaces are good use them

01:14:55,860 --> 01:15:03,520
you may short a name using as dis

01:15:01,380 --> 01:15:05,800
understandably if your file is called

01:15:03,520 --> 01:15:07,270
long module name and you need to use it

01:15:05,800 --> 01:15:09,400
a lot you don't really want to type it

01:15:07,270 --> 01:15:11,140
many times so important on what your

01:15:09,400 --> 01:15:13,750
name is Zed and then you use that dot

01:15:11,140 --> 01:15:15,940
whatever or you can import whatever

01:15:13,750 --> 01:15:17,410
directly from the module name but then

01:15:15,940 --> 01:15:18,790
it's not obvious to all the reader

01:15:17,410 --> 01:15:21,430
supporting where does this whatever

01:15:18,790 --> 01:15:23,500
comes from and this is the worst of them

01:15:21,430 --> 01:15:26,950
the import star and for everything you

01:15:23,500 --> 01:15:29,950
basically inject all all the namespace

01:15:26,950 --> 01:15:35,020
into yours that's like if you're into

01:15:29,950 --> 01:15:38,580
C++ is like using namespace who it's

01:15:35,020 --> 01:15:41,680
evil it's it's about idea don't use it

01:15:38,580 --> 01:15:46,240
okay this is an example we use the item

01:15:41,680 --> 01:15:49,090
to function we import math and then use

01:15:46,240 --> 01:15:52,060
math dot atom to if we try to use a bear

01:15:49,090 --> 01:15:54,490
as in to we get a name error we could

01:15:52,060 --> 01:15:56,890
but we shouldn't import the function

01:15:54,490 --> 01:15:58,570
from the module or import everything

01:15:56,890 --> 01:16:03,040
from the module now math is one example

01:15:58,570 --> 01:16:06,000
where I can see you doing because you

01:16:03,040 --> 01:16:08,710
need to do a lot of mathematics but

01:16:06,000 --> 01:16:11,170
avoid the temptation it's an interactive

01:16:08,710 --> 01:16:12,910
session if you're using Python as a

01:16:11,170 --> 01:16:14,800
calculator you can define your own

01:16:12,910 --> 01:16:16,870
module so straight do every Python

01:16:14,800 --> 01:16:17,170
source file is a module you just import

01:16:16,870 --> 01:16:20,890
it

01:16:17,170 --> 01:16:22,930
it must reside in the import path you

01:16:20,890 --> 01:16:24,940
can also have their bytecode files which

01:16:22,930 --> 01:16:26,770
is what Python meant for you or you can

01:16:24,940 --> 01:16:29,890
have binary extension which you can

01:16:26,770 --> 01:16:32,290
write and see or use Pyrex swig and a

01:16:29,890 --> 01:16:34,660
lot of other tools so ammonia is a

01:16:32,290 --> 01:16:36,910
simple object with attributes are no

01:16:34,660 --> 01:16:38,350
methods and it may have functions but

01:16:36,910 --> 01:16:43,120
they're not methods there's no implicit

01:16:38,350 --> 01:16:44,680
self the attributes you are also what

01:16:43,120 --> 01:16:47,170
you inside the modules here the

01:16:44,680 --> 01:16:49,690
top-level names are they're bound by

01:16:47,170 --> 01:16:52,150
assignments class def important from

01:16:49,690 --> 01:16:55,090
statements they're also known as global

01:16:52,150 --> 01:16:57,430
variables a little not only variable not

01:16:55,090 --> 01:17:01,000
all of them are going to be very mobile

01:16:57,430 --> 01:17:02,800
still and you may bind or bind them from

01:17:01,000 --> 01:17:05,729
the outside there's nothing stopping you

01:17:02,800 --> 01:17:08,729
from doing it but don't don't do it

01:17:05,729 --> 01:17:12,030
and unless you're doing tests or like

01:17:08,729 --> 01:17:13,829
mock object and the like a package is a

01:17:12,030 --> 01:17:17,249
collection of modules organizing another

01:17:13,829 --> 01:17:18,840
module it's mapped to a directory to

01:17:17,249 --> 01:17:22,349
distinguish which director is just

01:17:18,840 --> 01:17:24,719
directories which are packages you tear

01:17:22,349 --> 01:17:27,150
packages they need to have an init py

01:17:24,719 --> 01:17:30,479
spelled with the user double underscore

01:17:27,150 --> 01:17:32,190
which is a module body and the modules

01:17:30,479 --> 01:17:34,079
are all the py files which are in the

01:17:32,190 --> 01:17:36,510
directory and the sub packages are

01:17:34,079 --> 01:17:38,610
subdirectories which have their own init

01:17:36,510 --> 01:17:41,340
py the parent directory must be in sis

01:17:38,610 --> 01:17:45,780
path and you can import foo bar or from

01:17:41,340 --> 01:17:47,760
foo import bar this is basically all I

01:17:45,780 --> 01:17:50,969
have to say about the language Python

01:17:47,760 --> 01:17:55,530
and then there's a library which back

01:17:50,969 --> 01:17:57,780
before Java started spreading Python is

01:17:55,530 --> 01:18:01,159
a few years older than Java back in 92

01:17:57,780 --> 01:18:03,809
93 the size of a Python standard library

01:18:01,159 --> 01:18:06,630
was scarily bigger than any other

01:18:03,809 --> 01:18:09,360
standard library ever released even when

01:18:06,630 --> 01:18:12,209
even with java 1.0 python was still

01:18:09,360 --> 01:18:12,570
still larger with java today okay I give

01:18:12,209 --> 01:18:16,260
up

01:18:12,570 --> 01:18:17,369
Java in a nutshell is 1,600 pages I was

01:18:16,260 --> 01:18:22,409
criticized because Python

01:18:17,369 --> 01:18:26,429
internationally 700 pages our can't beat

01:18:22,409 --> 01:18:29,219
them so we have 190 modules at the top

01:18:26,429 --> 01:18:32,340
level so to speak of doing anything from

01:18:29,219 --> 01:18:36,900
math to system operations random numbers

01:18:32,340 --> 01:18:41,219
sockets RFC 8 to 2 or 20 to 80 Turing by

01:18:36,900 --> 01:18:43,949
now 28 we have 13 top level packages

01:18:41,219 --> 01:18:47,670
organizing 300 modules so having to do

01:18:43,949 --> 01:18:51,570
with the Berkeley database pythons own

01:18:47,670 --> 01:18:54,150
built-in compiler and so on we have a

01:18:51,570 --> 01:18:56,670
lot of encodings for a sort of Unicode

01:18:54,150 --> 01:19:00,209
operation sort of unit tests included in

01:18:56,670 --> 01:19:02,630
the library or and a lot of stuff that

01:19:00,209 --> 01:19:05,849
is not normally distributed with binary

01:19:02,630 --> 01:19:07,880
distributions which are very nice you

01:19:05,849 --> 01:19:10,110
should get from the source distribution

01:19:07,880 --> 01:19:13,050
demonstrations of how to best use this

01:19:10,110 --> 01:19:15,079
in that feature and tools which actually

01:19:13,050 --> 01:19:19,400
very help little

01:19:15,079 --> 01:19:23,119
like ah then beyond what comes with

01:19:19,400 --> 01:19:25,250
Python there's a site cheese shop Python

01:19:23,119 --> 01:19:27,440
orga Python is named in honor of Monty

01:19:25,250 --> 01:19:31,400
Python and a cheese shop is named in

01:19:27,440 --> 01:19:34,250
honor off the cheese shop sketch heat I

01:19:31,400 --> 01:19:35,809
checked Sunday how many modules do we

01:19:34,250 --> 01:19:38,540
have packages do we have today

01:19:35,809 --> 01:19:41,210
and yet exactly two thousand one hundred

01:19:38,540 --> 01:19:43,429
and twenty two which I took as a good

01:19:41,210 --> 01:19:45,739
omen whatever and these are the main

01:19:43,429 --> 01:19:46,909
subjects of course software development

01:19:45,739 --> 01:19:49,909
everything is about software development

01:19:46,909 --> 01:19:51,770
some very helpful there are other but

01:19:49,909 --> 01:19:54,050
these are the popular ones this are

01:19:51,770 --> 01:19:56,329
possibly a better more useful way to

01:19:54,050 --> 01:19:58,790
organize things there's all the way to

01:19:56,329 --> 01:20:03,230
write graphical user interfaces sequel

01:19:58,790 --> 01:20:05,090
databases and wrappers object on on top

01:20:03,230 --> 01:20:08,420
of relational databases or sort of

01:20:05,090 --> 01:20:10,699
computation stuff or sort of net and web

01:20:08,420 --> 01:20:13,610
stars development environments and tools

01:20:10,699 --> 01:20:14,840
games games meaning frameworks to write

01:20:13,610 --> 01:20:18,170
games don't know if you've heard about

01:20:14,840 --> 01:20:21,920
the PI weak context it runs a few times

01:20:18,170 --> 01:20:25,579
a year you have one week to write a

01:20:21,920 --> 01:20:27,469
video game from scratch from the moment

01:20:25,579 --> 01:20:29,559
the thing everything happens on the

01:20:27,469 --> 01:20:33,650
internet so you can have a team whatever

01:20:29,559 --> 01:20:35,540
everybody uses by game and the Python

01:20:33,650 --> 01:20:38,239
programming language is some pretty cool

01:20:35,540 --> 01:20:40,280
game I've come up people give you the

01:20:38,239 --> 01:20:42,110
theme this revealed at the start of the

01:20:40,280 --> 01:20:43,909
competition and then the clock runs for

01:20:42,110 --> 01:20:46,190
a week the only problem is you probably

01:20:43,909 --> 01:20:47,929
want to take a week off whatever you

01:20:46,190 --> 01:20:50,510
normally do study or work because

01:20:47,929 --> 01:20:53,840
otherwise other teams are going to do

01:20:50,510 --> 01:20:55,820
that and they'll destroy you multi other

01:20:53,840 --> 01:20:58,429
multi medium visualization scientific

01:20:55,820 --> 01:21:02,829
visualization mostly an integration with

01:20:58,429 --> 01:21:05,750
those sort of languages and platforms

01:21:02,829 --> 01:21:08,659
let's go 1 micron deeper to see what's

01:21:05,750 --> 01:21:10,099
in the in the standard library there are

01:21:08,659 --> 01:21:12,800
some fundamental things things that

01:21:10,099 --> 01:21:16,130
would be in the language possibly in

01:21:12,800 --> 01:21:19,190
many languages like bisection algorithms

01:21:16,130 --> 01:21:22,550
how to copy things more collections

01:21:19,190 --> 01:21:26,840
beside the built-in ones tools that heap

01:21:22,550 --> 01:21:28,180
functional functional programming an

01:21:26,840 --> 01:21:33,240
implementation of

01:21:28,180 --> 01:21:37,330
he priority queues to city's iteration

01:21:33,240 --> 01:21:39,700
regular expressions threading in the cue

01:21:37,330 --> 01:21:41,400
thread a lot of tools for testing and

01:21:39,700 --> 01:21:44,680
debugging file in text processing

01:21:41,400 --> 01:21:47,380
persistence and databases time and date

01:21:44,680 --> 01:21:49,960
but there's one crucial category missing

01:21:47,380 --> 01:21:54,060
here none of the standard time and date

01:21:49,960 --> 01:21:56,680
module deals with daylight saving time

01:21:54,060 --> 01:22:01,510
essentially the Python core developers

01:21:56,680 --> 01:22:04,930
punted we just can't bear to release a

01:22:01,510 --> 01:22:09,630
new Python release in a hurry because

01:22:04,930 --> 01:22:12,130
some legislative body has decided that

01:22:09,630 --> 01:22:14,980
daylight saving time will actually start

01:22:12,130 --> 01:22:17,530
there and finish there remember there

01:22:14,980 --> 01:22:20,110
are a hundred and sixty-five legislation

01:22:17,530 --> 01:22:24,580
in the world we would basically have to

01:22:20,110 --> 01:22:28,390
do nothing for this huge package that is

01:22:24,580 --> 01:22:31,480
Python except following news for 165

01:22:28,390 --> 01:22:33,160
countries and states and things in the

01:22:31,480 --> 01:22:35,920
world to know what are they doing with

01:22:33,160 --> 01:22:38,680
her so you absolutely need a third-party

01:22:35,920 --> 01:22:39,970
helper either one that uses the stuff

01:22:38,680 --> 01:22:41,770
that comes with typical Linux

01:22:39,970 --> 01:22:44,470
distributions or a standalone one

01:22:41,770 --> 01:22:48,520
they're both pretty good okay then we

01:22:44,470 --> 01:22:50,110
have computation stars in terms of net

01:22:48,520 --> 01:22:52,330
and web stuff I've given up on

01:22:50,110 --> 01:22:57,370
summarizing how many tools we have for

01:22:52,330 --> 01:22:59,560
net and web okay this is when asked the

01:22:57,370 --> 01:23:02,470
what do you think is the best example of

01:22:59,560 --> 01:23:04,740
Python what the creator of Python Widow

01:23:02,470 --> 01:23:09,490
van Rossum currently a Google employee

01:23:04,740 --> 01:23:11,770
gives he says I never like sitting down

01:23:09,490 --> 01:23:13,570
at a machine and try W get something

01:23:11,770 --> 01:23:15,850
because I get my precision it doesn't

01:23:13,570 --> 01:23:19,210
have W get well it does usually have

01:23:15,850 --> 01:23:22,810
Python and it takes me much less time to

01:23:19,210 --> 01:23:25,420
code up W get a simple version then to

01:23:22,810 --> 01:23:27,670
find it and download it install it and

01:23:25,420 --> 01:23:30,370
run it and this is how you do W get in

01:23:27,670 --> 01:23:33,100
Python essentially there's three uses of

01:23:30,370 --> 01:23:35,770
the standard library so you need to

01:23:33,100 --> 01:23:38,920
import the module cysts you are Lib

01:23:35,770 --> 01:23:39,659
which deals with urals and OS which does

01:23:38,920 --> 01:23:41,550
in the operator

01:23:39,659 --> 01:23:44,280
system you need to define a hook

01:23:41,550 --> 01:23:47,280
function in this case we just print a

01:23:44,280 --> 01:23:50,280
file name followed by whatever feed

01:23:47,280 --> 01:23:53,309
become argument or given this is what

01:23:50,280 --> 01:23:56,039
the your lab you retrieve calls every

01:23:53,309 --> 01:23:59,070
time it gets a bunch of stuff from the

01:23:56,039 --> 01:24:02,429
net and so we do pover all the arguments

01:23:59,070 --> 01:24:05,789
script them their URL so we strip them

01:24:02,429 --> 01:24:07,800
to their base name and we download them

01:24:05,789 --> 01:24:12,559
to this file name with a little printout

01:24:07,800 --> 01:24:17,869
and your retrieve does the the job and

01:24:12,559 --> 01:24:30,479
calls once in a while cause the hook and

01:24:17,869 --> 01:24:33,900
this where does what oh it's a it's

01:24:30,479 --> 01:24:37,709
right here global it's remember def is

01:24:33,900 --> 01:24:40,289
executable and the body is not executed

01:24:37,709 --> 01:24:43,499
at the time Sony compiled so there's no

01:24:40,289 --> 01:24:47,400
need to look up at them by the time who

01:24:43,499 --> 01:24:49,889
gets cold FM has been assigned here you

01:24:47,400 --> 01:24:52,019
don't need to declare a fan anywhere

01:24:49,889 --> 01:24:54,360
everything is executable and the order

01:24:52,019 --> 01:24:56,789
of execution is def executive at this

01:24:54,360 --> 01:24:58,800
doesn't need a fan then the for executed

01:24:56,789 --> 01:25:01,769
in this assignment and then this which

01:24:58,800 --> 01:25:04,019
calls back and this is where the body

01:25:01,769 --> 01:25:07,469
gets executed yeah I see a lot of people

01:25:04,019 --> 01:25:09,570
in cases like this say FN equal known as

01:25:07,469 --> 01:25:11,999
if it was a declaration don't there's no

01:25:09,570 --> 01:25:13,949
such thing as a declaration this is the

01:25:11,999 --> 01:25:15,659
exact equivalent I mean my

01:25:13,949 --> 01:25:17,669
multi-threaded version is not quite as

01:25:15,659 --> 01:25:20,939
similar but then multi-threaded is

01:25:17,669 --> 01:25:24,809
neveress it almost stays because thanks

01:25:20,939 --> 01:25:30,150
to they thread safe first in first out

01:25:24,809 --> 01:25:32,610
queue basically this has just a little

01:25:30,150 --> 01:25:35,309
bit of extra to declare itself a demon

01:25:32,610 --> 01:25:37,619
so it won't keep the program alive but

01:25:35,309 --> 01:25:39,929
then basically the body is essentially

01:25:37,619 --> 01:25:42,959
identical except cube gets the URL from

01:25:39,929 --> 01:25:45,300
from the queue and then the main program

01:25:42,959 --> 01:25:49,919
so to speak only needs to build a pool

01:25:45,300 --> 01:25:51,809
of workers and put everything all the

01:25:49,919 --> 01:25:55,770
work requests in the queue

01:25:51,809 --> 01:25:57,239
and they'll just do their job I measured

01:25:55,770 --> 01:25:59,789
this is actually much faster

01:25:57,239 --> 01:26:03,360
particularly in multi multi-core

01:25:59,789 --> 01:26:05,730
machines because the other version

01:26:03,360 --> 01:26:08,610
basically spends all its time waiting

01:26:05,730 --> 01:26:10,469
for the internet so that's a case where

01:26:08,610 --> 01:26:13,949
multi-threading is definitely worth it

01:26:10,469 --> 01:26:18,239
and this is just a few more packages on

01:26:13,949 --> 01:26:19,530
on the standard library I'm not really

01:26:18,239 --> 01:26:22,139
able to do it justice

01:26:19,530 --> 01:26:24,199
except I'll mention one they are

01:26:22,139 --> 01:26:28,679
essentially the foreign functional

01:26:24,199 --> 01:26:31,800
library for Python C types c types you

01:26:28,679 --> 01:26:33,960
need to know which platform you're using

01:26:31,800 --> 01:26:35,730
because basically you can call arbitrary

01:26:33,960 --> 01:26:37,289
c function from a dynamically load

01:26:35,730 --> 01:26:39,840
library but you need to know which then

01:26:37,289 --> 01:26:42,449
any library you want so for example if

01:26:39,840 --> 01:26:46,079
you're on Windows you want to load n is

01:26:42,449 --> 01:26:50,130
VCR t the common runtime library that

01:26:46,079 --> 01:26:52,500
comes with Microsoft stood is your

01:26:50,130 --> 01:26:56,010
studio if you're on Darwin which means

01:26:52,500 --> 01:26:58,260
Mac OS then you want to leave seed are

01:26:56,010 --> 01:27:00,840
live else your presumably on Linux or

01:26:58,260 --> 01:27:02,670
otherwise you need to keep testing and

01:27:00,840 --> 01:27:05,070
then you'll want to read blips are

01:27:02,670 --> 01:27:08,309
fortunately any of these deep-sea object

01:27:05,070 --> 01:27:10,289
will have a printf function in c2 which

01:27:08,309 --> 01:27:11,909
you can pass a string and will return

01:27:10,289 --> 01:27:14,460
the number of characters printed and

01:27:11,909 --> 01:27:16,349
that'll better be 12 so this is just an

01:27:14,460 --> 01:27:20,280
example of how you can call arbitrary

01:27:16,349 --> 01:27:22,770
arbitrary C function from Python and

01:27:20,280 --> 01:27:29,969
that concludes my talk thank you very

01:27:22,770 --> 01:27:33,199
much I think we do have time for a

01:27:29,969 --> 01:27:33,199
little question and answer

01:27:40,660 --> 01:27:47,540
no it implies the colonel can remember

01:27:44,360 --> 01:27:50,570
that dealing with the tcp/ip stack is

01:27:47,540 --> 01:27:52,280
not exactly zero cpu load so if I have

01:27:50,570 --> 01:27:54,470
two cores I haven't actually tried with

01:27:52,280 --> 01:27:59,090
more than two - is what I have in my in

01:27:54,470 --> 01:28:02,750
my macbook then it means the kernel can

01:27:59,090 --> 01:28:05,990
be running the internals of socket

01:28:02,750 --> 01:28:09,470
reception Nagle algorithms whatever else

01:28:05,990 --> 01:28:14,140
while the application is preparing to

01:28:09,470 --> 01:28:14,140
request write it as the nest

01:28:21,340 --> 01:28:29,690
essentially there's many I to convince

01:28:27,140 --> 01:28:31,250
the European Union to finance the

01:28:29,690 --> 01:28:33,890
project to the tune of two million

01:28:31,250 --> 01:28:37,340
dollars we had to present about two

01:28:33,890 --> 01:28:40,250
million dollars worth of paper now I say

01:28:37,340 --> 01:28:42,170
we because I used to be before I joined

01:28:40,250 --> 01:28:47,780
Google I was part of that group in

01:28:42,170 --> 01:28:49,280
Europe so number one to facilitate

01:28:47,780 --> 01:28:49,970
experimentation with programming

01:28:49,280 --> 01:28:52,190
languages

01:28:49,970 --> 01:28:55,760
so the standard implementations of

01:28:52,190 --> 01:28:58,460
Python are written in C Java C sharp so

01:28:55,760 --> 01:29:00,650
to experiment to make us different

01:28:58,460 --> 01:29:04,100
language that similar to Python

01:29:00,650 --> 01:29:09,680
you basically have to know beyond Python

01:29:04,100 --> 01:29:11,960
also C or C sharp or or Java with pi PI

01:29:09,680 --> 01:29:15,470
you can do your experimentation Python

01:29:11,960 --> 01:29:17,870
itself so it's easier to experiment in

01:29:15,470 --> 01:29:20,510
even if you do know we claimed that

01:29:17,870 --> 01:29:21,950
Python makes you more productive so even

01:29:20,510 --> 01:29:22,820
if you do know the other language you

01:29:21,950 --> 01:29:24,770
should be able to do your

01:29:22,820 --> 01:29:28,520
experimentation twice as fast if you can

01:29:24,770 --> 01:29:31,280
do everything in Python also freeing the

01:29:28,520 --> 01:29:33,610
backend from the specific constraints

01:29:31,280 --> 01:29:37,100
existing in the existing implementation

01:29:33,610 --> 01:29:39,650
basically by coding the output so to

01:29:37,100 --> 01:29:42,910
speak to an abstract back-end which is

01:29:39,650 --> 01:29:45,800
suitable for computation to either

01:29:42,910 --> 01:29:47,930
higher level byte code engines or

01:29:45,800 --> 01:29:51,290
machine code

01:29:47,930 --> 01:29:55,070
basically freeze up to your back end if

01:29:51,290 --> 01:29:57,620
you look at pi pi 1.0 is released it's

01:29:55,070 --> 01:29:59,390
got a funny collection of back ends for

01:29:57,620 --> 01:30:02,780
example it has a back end which compiles

01:29:59,390 --> 01:30:06,380
Python to JavaScript the reason are

01:30:02,780 --> 01:30:10,130
obvious you can pump that on they put

01:30:06,380 --> 01:30:12,170
that somehow as part of your webpages

01:30:10,130 --> 01:30:14,270
and basically do the logic behind your

01:30:12,170 --> 01:30:17,810
webpages on the user's browser but in

01:30:14,270 --> 01:30:20,360
Python there's an implement the one

01:30:17,810 --> 01:30:24,320
back-end generates Common Lisp which

01:30:20,360 --> 01:30:26,690
then can has some pretty strong

01:30:24,320 --> 01:30:28,969
compilers around mostly commercial ones

01:30:26,690 --> 01:30:31,940
other implementations generate machine

01:30:28,969 --> 01:30:34,730
code that's not in very satisfactory to

01:30:31,940 --> 01:30:36,680
me so bloated generates not not very

01:30:34,730 --> 01:30:38,239
efficient machine code another one

01:30:36,680 --> 01:30:41,660
generate code for something called the

01:30:38,239 --> 01:30:43,520
LLVM the low-level virtual machine you

01:30:41,660 --> 01:30:45,830
should read up on that on the webisode

01:30:43,520 --> 01:30:47,630
so basically it's got a lot of backends

01:30:45,830 --> 01:30:48,620
because it can it's designed to have

01:30:47,630 --> 01:30:51,969
multiple backends

01:30:48,620 --> 01:30:56,080
and part of what it does have to enable

01:30:51,969 --> 01:30:58,070
specifically the easy generation of

01:30:56,080 --> 01:31:00,739
machine code or the equivalent of

01:30:58,070 --> 01:31:03,949
machine code is got type inference built

01:31:00,739 --> 01:31:06,730
in so we don't really need that to

01:31:03,949 --> 01:31:09,530
generate JavaScript or Common Lisp but

01:31:06,730 --> 01:31:11,690
but it's still handy and it's

01:31:09,530 --> 01:31:13,550
particularly handy if you want to

01:31:11,690 --> 01:31:16,070
generate machine code even though it

01:31:13,550 --> 01:31:17,960
comes out very bloated you need to know

01:31:16,070 --> 01:31:19,940
whether something is an integer or float

01:31:17,960 --> 01:31:25,779
because it may occupy different number

01:31:19,940 --> 01:31:30,789
of bytes in memory so any other yes

01:31:25,779 --> 01:31:36,839
I presumably can although it will take a

01:31:30,789 --> 01:31:40,499
while actually itself repeat school

01:31:36,839 --> 01:31:40,499
well only for a while

01:31:49,880 --> 01:31:56,650
which one 21:33

01:32:06,019 --> 01:32:13,099
if Connery is going to yield one item

01:32:08,869 --> 01:32:13,880
and suspend the next time is going your

01:32:13,099 --> 01:32:18,050
the next item

01:32:13,880 --> 01:32:25,610
so take one example of enumerator that I

01:32:18,050 --> 01:32:32,929
have thinking when I do the indexing

01:32:25,610 --> 01:32:37,880
example I'm using enumerate there so

01:32:32,929 --> 01:32:41,090
enumerate is called once but then we

01:32:37,880 --> 01:32:43,460
loop on it so we get 0 and the first

01:32:41,090 --> 01:32:44,929
line 1 and the second line 2 and the

01:32:43,460 --> 01:32:48,070
third line so we're getting the line

01:32:44,929 --> 01:32:51,110
number as well as the line as we go

01:32:48,070 --> 01:32:54,050
without having to deal ourselves with

01:32:51,110 --> 01:32:56,960
low-level logics such as N equals 0 and

01:32:54,050 --> 01:33:01,670
n plus equal 1 so that's what enumerate

01:32:56,960 --> 01:33:03,289
does for us if I iterate over my

01:33:01,670 --> 01:33:07,010
sequence I don't get the line number I

01:33:03,289 --> 01:33:09,320
get lines but I don't know what line

01:33:07,010 --> 01:33:28,159
number I am and I need to to save the

01:33:09,320 --> 01:33:32,869
line numbers by problem definition there

01:33:28,159 --> 01:33:36,409
is it just just passed in a slightly

01:33:32,869 --> 01:33:39,309
different syntactic position but it is

01:33:36,409 --> 01:33:39,309
definitely passing

01:33:40,730 --> 01:33:44,940
you you have to pass it explicitly to

01:33:43,500 --> 01:33:47,280
the method because you call the method

01:33:44,940 --> 01:33:49,950
on the class while this basically wraps

01:33:47,280 --> 01:33:52,320
it up so it gives you an virtual

01:33:49,950 --> 01:33:53,850
instance of your superclass so you're

01:33:52,320 --> 01:33:55,440
calling a method than an insect which

01:33:53,850 --> 01:34:12,900
implicitly passes itself

01:33:55,440 --> 01:34:16,350
yes setting what sorry it's fine I'm

01:34:12,900 --> 01:34:18,420
just saying that in the example I was

01:34:16,350 --> 01:34:21,330
giving there's absolutely no use of that

01:34:18,420 --> 01:34:41,160
variable until much later so why should

01:34:21,330 --> 01:34:42,200
I set it yes make sense more you're

01:34:41,160 --> 01:34:44,460
welcome

01:34:42,200 --> 01:34:45,900
if you don't have control over the

01:34:44,460 --> 01:34:48,300
source code then you will take whatever

01:34:45,900 --> 01:34:50,400
source code you're given but if you do

01:34:48,300 --> 01:34:53,580
have them then in system making them a

01:34:50,400 --> 01:34:56,130
reasonable length it's really no reason

01:34:53,580 --> 01:34:58,140
to do otherwise you can't you can tell

01:34:56,130 --> 01:35:01,380
me you have no control to to split them

01:34:58,140 --> 01:35:04,350
down into reasonable length say a couple

01:35:01,380 --> 01:35:07,470
hundred lines at most but you can

01:35:04,350 --> 01:35:10,380
control which 200 lines they are that

01:35:07,470 --> 01:35:12,720
doesn't make sense if I did have to

01:35:10,380 --> 01:35:15,750
maintain a thousand line script I

01:35:12,720 --> 01:35:17,850
probably would refuse to use any global

01:35:15,750 --> 01:35:21,480
variables at all I would wrap everything

01:35:17,850 --> 01:35:23,790
in two classes so if I can't have a

01:35:21,480 --> 01:35:26,790
decent source code control that way I

01:35:23,790 --> 01:35:29,010
can't how many people will be editing a

01:35:26,790 --> 01:35:31,590
thousand line file at a time I can just

01:35:29,010 --> 01:35:34,550
see the conflicts in your source code

01:35:31,590 --> 01:35:37,080
control system and people resolving

01:35:34,550 --> 01:35:40,650
conflicts by hand all the time it's

01:35:37,080 --> 01:35:42,240
going to be hell so anyway at least the

01:35:40,650 --> 01:35:48,570
conflicts will be in different classes

01:35:42,240 --> 01:36:03,540
with any mark I think we have

01:35:48,570 --> 01:36:06,900
one more question no there isn't there

01:36:03,540 --> 01:36:09,960
isn't there are there are tools such as

01:36:06,900 --> 01:36:11,760
pie checker which will cancel your typos

01:36:09,960 --> 01:36:13,200
that they're completely separate from

01:36:11,760 --> 01:36:22,650
Python you don't load them separately

01:36:13,200 --> 01:36:25,590
yes okay not for the language but the

01:36:22,650 --> 01:36:28,140
libraries are not identical so you have

01:36:25,590 --> 01:36:30,780
to realize that the main motivation for

01:36:28,140 --> 01:36:33,180
somebody to port fight on to dotnet was

01:36:30,780 --> 01:36:37,470
to make available windows forms if you

01:36:33,180 --> 01:36:40,110
do use them don't expect that you run

01:36:37,470 --> 01:36:42,180
the same script on Mon or under Linux

01:36:40,110 --> 01:36:46,370
windows form will appears they want

01:36:42,180 --> 01:36:50,610
their Microsoft crown jewels so

01:36:46,370 --> 01:36:53,070
essentially the language is totally

01:36:50,610 --> 01:36:55,440
portable but you never do anything with

01:36:53,070 --> 01:36:57,840
the language alone you're always calling

01:36:55,440 --> 01:37:00,110
some library or other be careful which

01:36:57,840 --> 01:37:02,880
library you call because if you call a

01:37:00,110 --> 01:37:05,430
proprietary library that only exists on

01:37:02,880 --> 01:37:08,010
this platform well then you know they

01:37:05,430 --> 01:37:11,130
say you're you're using sequel as part

01:37:08,010 --> 01:37:15,030
of your your Python script if you're

01:37:11,130 --> 01:37:17,220
developing for Microsoft sequel using

01:37:15,030 --> 01:37:20,040
all of its specific dialects and

01:37:17,220 --> 01:37:21,270
features then moving to Oracle will be

01:37:20,040 --> 01:37:26,270
help and it's not

01:37:21,270 --> 01:37:26,270
pythons problem it's your problem yes

01:37:31,360 --> 01:37:47,179
yes generators okay if you cut when you

01:37:44,659 --> 01:37:50,090
call the function the function returns

01:37:47,179 --> 01:37:52,460
an object so if the two if two threads

01:37:50,090 --> 01:37:57,289
call the function you get two separate

01:37:52,460 --> 01:38:01,760
objects no interference every time you

01:37:57,289 --> 01:38:04,159
call next you consume a an item no

01:38:01,760 --> 01:38:06,229
matter how thread safe you can make it

01:38:04,159 --> 01:38:10,729
internally you will still be consuming

01:38:06,229 --> 01:38:12,800
one item so if there will be a race

01:38:10,729 --> 01:38:14,989
condition for calling next between the

01:38:12,800 --> 01:38:18,440
two threads that's assuming they in your

01:38:14,989 --> 01:38:21,679
body is safe between successive yields

01:38:18,440 --> 01:38:22,880
being simultaneously in execution so

01:38:21,679 --> 01:38:24,739
you're going to get some non

01:38:22,880 --> 01:38:26,119
deterministic effects sometimes the

01:38:24,739 --> 01:38:27,889
first thread will get the first two

01:38:26,119 --> 01:38:31,300
items and then a couple for the other

01:38:27,889 --> 01:38:35,329
and then by other times different

01:38:31,300 --> 01:38:38,690
interleavings it's kind of like what if

01:38:35,329 --> 01:38:41,329
the threads what did printer standard

01:38:38,690 --> 01:38:42,559
output well the lines coming from one

01:38:41,329 --> 01:38:46,749
and the lines coming from the other

01:38:42,559 --> 01:38:46,749
would be mixed in about random

01:38:54,540 --> 01:39:00,280
if we call it twice so then we get two

01:38:57,820 --> 01:39:10,240
different objects which don't interfere

01:39:00,280 --> 01:39:12,930
with each other I don't understand we

01:39:10,240 --> 01:39:16,690
have a method which is defined with that

01:39:12,930 --> 01:39:19,120
okay okay then in run time when this

01:39:16,690 --> 01:39:21,580
death statement is executed an object is

01:39:19,120 --> 01:39:24,490
basically a function object Escrima

01:39:21,580 --> 01:39:29,170
factional yes is created then we call

01:39:24,490 --> 01:39:33,520
maybe put a method we basically use this

01:39:29,170 --> 01:39:36,280
function object if that contains a

01:39:33,520 --> 01:39:38,560
yielder then it's the generator and what

01:39:36,280 --> 01:39:40,660
it returns is an iterator object but it

01:39:38,560 --> 01:39:47,920
returns when you call it is an iterator

01:39:40,660 --> 01:39:49,720
object exactly thank you very much I

01:39:47,920 --> 01:39:51,990
think it's getting a bit late so we

01:39:49,720 --> 01:39:51,990
should be

01:40:14,650 --> 01:40:16,710

YouTube URL: https://www.youtube.com/watch?v=ujkzfC2lebA


