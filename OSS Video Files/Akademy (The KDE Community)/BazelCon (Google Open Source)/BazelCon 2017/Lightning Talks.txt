Title: Lightning Talks
Publication date: 2018-03-04
Playlist: BazelCon 2017
Description: 
	A series of 5-minute lightning talks on Bazel topics by Laurent Le Brun, Fabian Zaiser, Jay Conrod, Julie Xia, Danna Kelmer, Paul Johnston, Harvey Tuch, Xun Lai, Terry Braschi, P. Oscar Boykin
Captions: 
	00:00:00,000 --> 00:00:08,010
um so we will go through lightning talks

00:00:02,929 --> 00:00:09,929
those one are five minutes long and so

00:00:08,010 --> 00:00:13,160
I'm going to cut like people if they're

00:00:09,929 --> 00:00:16,590
they go over time and so be nice to them

00:00:13,160 --> 00:00:22,080
it might be stressful if someone does

00:00:16,590 --> 00:00:24,330
that we will have light 9 stalks the

00:00:22,080 --> 00:00:27,779
first of the first for them

00:00:24,330 --> 00:00:30,779
Albert tools that from the Basel team

00:00:27,779 --> 00:00:34,640
and some was a team at Google that made

00:00:30,779 --> 00:00:37,980
to you to make basil easier to use and

00:00:34,640 --> 00:00:40,320
also some new feature of basil and then

00:00:37,980 --> 00:00:45,030
we will enter like most prospective to

00:00:40,320 --> 00:00:48,780
talks and we have some interesting build

00:00:45,030 --> 00:00:55,739
system and and also some new idea that

00:00:48,780 --> 00:00:59,550
are going to be pitched well so just a

00:00:55,739 --> 00:01:02,579
note for the speakers if you're next

00:00:59,550 --> 00:01:04,680
just come next to me so I know where

00:01:02,579 --> 00:01:07,680
he's the next speaker and right now

00:01:04,680 --> 00:01:10,020
we're going to start with Lowell was

00:01:07,680 --> 00:01:12,290
going to talk about Bill defiant

00:01:10,020 --> 00:01:12,290
billdozer

00:01:12,470 --> 00:01:23,750
on it working so I am i working on

00:01:19,920 --> 00:01:27,119
Scylla and tools for build files and

00:01:23,750 --> 00:01:29,549
files so this talk is about building

00:01:27,119 --> 00:01:32,340
fire in billdozer so just a quick

00:01:29,549 --> 00:01:34,040
question how many of you know about to

00:01:32,340 --> 00:01:37,259
build a fire

00:01:34,040 --> 00:01:45,149
Wow a lot and how many of you are using

00:01:37,259 --> 00:01:46,890
it yeah ok simple to do don't you

00:01:45,149 --> 00:01:48,780
we don't know about it build if I you

00:01:46,890 --> 00:01:51,630
know just a code formatter for the build

00:01:48,780 --> 00:01:53,939
files to just do something like go

00:01:51,630 --> 00:01:57,329
format cling format or other things you

00:01:53,939 --> 00:01:59,100
have another languages so you just write

00:01:57,329 --> 00:02:01,020
your build file you won't build if I go

00:01:59,100 --> 00:02:05,640
and it will format it in Nice and

00:02:01,020 --> 00:02:07,740
standard way and so also so that means

00:02:05,640 --> 00:02:11,640
that all the build files will will look

00:02:07,740 --> 00:02:13,060
the same so it's much easier to to

00:02:11,640 --> 00:02:15,040
weight them but

00:02:13,060 --> 00:02:16,780
so most important thing is that since

00:02:15,040 --> 00:02:18,670
all the bill files are formatted in the

00:02:16,780 --> 00:02:22,780
same way that means that they can be

00:02:18,670 --> 00:02:24,880
modified automatically and so tools that

00:02:22,780 --> 00:02:28,690
modify the bill files don't have to care

00:02:24,880 --> 00:02:30,360
about indent indentation or keeping the

00:02:28,690 --> 00:02:35,170
document in the right place or

00:02:30,360 --> 00:02:37,750
everything like this and so so yeah so

00:02:35,170 --> 00:02:39,069
that's just an example of Bill file

00:02:37,750 --> 00:02:42,420
formatted with Billy foyer

00:02:39,069 --> 00:02:48,430
so that's simple and so tool is builder

00:02:42,420 --> 00:02:51,790
which which is used to actually modify

00:02:48,430 --> 00:02:54,910
the build files automatically so I will

00:02:51,790 --> 00:02:56,950
just go through a few examples you you

00:02:54,910 --> 00:02:59,140
can later look at the documentation to

00:02:56,950 --> 00:03:01,870
to know all the details with just a

00:02:59,140 --> 00:03:05,140
quick overview but if you just call

00:03:01,870 --> 00:03:08,950
build a fire builder that the command

00:03:05,140 --> 00:03:10,959
called the ad and then you specify which

00:03:08,950 --> 00:03:14,519
in which attribute you want to add

00:03:10,959 --> 00:03:20,920
something and so in this example you add

00:03:14,519 --> 00:03:25,150
a dependency on the slash slash base for

00:03:20,920 --> 00:03:26,680
the tools page : Hall and picnics : - so

00:03:25,150 --> 00:03:32,230
you just want this command and it will

00:03:26,680 --> 00:03:34,840
automatically update the build files so

00:03:32,230 --> 00:03:38,560
this is to add one dependency you can

00:03:34,840 --> 00:03:40,720
also modify an existing attribute so he

00:03:38,560 --> 00:03:45,030
has to modify the default visibility

00:03:40,720 --> 00:03:48,280
visibility in a build file so it will

00:03:45,030 --> 00:03:51,609
modifies on the package in the package

00:03:48,280 --> 00:03:53,650
line so it will check if you have

00:03:51,609 --> 00:03:55,299
already declared package or not and if

00:03:53,650 --> 00:03:59,350
not it will quite a new one and it will

00:03:55,299 --> 00:04:02,530
modify the different visibility so this

00:03:59,350 --> 00:04:06,370
one is to replace some attributes so if

00:04:02,530 --> 00:04:10,079
you have the depth which is a lit of

00:04:06,370 --> 00:04:13,959
dependencies and you want to replace

00:04:10,079 --> 00:04:16,150
dependency on PHP one and to update it

00:04:13,959 --> 00:04:18,280
to package v2 you just want this command

00:04:16,150 --> 00:04:21,250
and so there is a nice thing is that if

00:04:18,280 --> 00:04:22,659
you rename a package we name it I get or

00:04:21,250 --> 00:04:26,849
if you want to update it to a new

00:04:22,659 --> 00:04:26,849
version you can just want this command

00:04:26,940 --> 00:04:33,360
on every bill filing in your code base

00:04:29,130 --> 00:04:37,560
and it will update everything so oh oh

00:04:33,360 --> 00:04:40,950
in this example we just add the yen to

00:04:37,560 --> 00:04:44,520
say oh if we wait I get in the build

00:04:40,950 --> 00:04:47,730
file and so this example will remove

00:04:44,520 --> 00:04:53,580
test only attribute so every diet in the

00:04:47,730 --> 00:04:56,100
bill file so everywhere let's define you

00:04:53,580 --> 00:04:58,320
can also add some comments so here if

00:04:56,100 --> 00:05:04,200
you want to add command duplicate it to

00:04:58,320 --> 00:05:06,810
some target you can also print some

00:05:04,200 --> 00:05:10,370
information so bill design is not just

00:05:06,810 --> 00:05:13,140
about updating the build files it's also

00:05:10,370 --> 00:05:15,060
useful to point information from the

00:05:13,140 --> 00:05:18,000
from the bill file so if you want to

00:05:15,060 --> 00:05:19,530
print the name of every CC by newest tie

00:05:18,000 --> 00:05:22,860
get in the fight you can run this

00:05:19,530 --> 00:05:23,910
command so this percent means if we tie

00:05:22,860 --> 00:05:28,230
get of the kind

00:05:23,910 --> 00:05:30,690
CC by now here in this example you can

00:05:28,230 --> 00:05:33,060
also print with the information like the

00:05:30,690 --> 00:05:35,430
start start line and end line of the

00:05:33,060 --> 00:05:38,610
definition in the bill file you could

00:05:35,430 --> 00:05:40,380
also print it to label or print the

00:05:38,610 --> 00:05:42,450
whole which which is a complete

00:05:40,380 --> 00:05:48,360
definition or print in the attribute

00:05:42,450 --> 00:05:51,720
from the on which I get you can also do

00:05:48,360 --> 00:05:56,640
the same example before so I you can

00:05:51,720 --> 00:06:01,500
also insert a new load statements in a

00:05:56,640 --> 00:06:07,260
file so here if you want to to load my

00:06:01,500 --> 00:06:11,580
microphones from this PCL file you can

00:06:07,260 --> 00:06:15,450
also the third command is to what's also

00:06:11,580 --> 00:06:18,270
here so here said kind my Michael is to

00:06:15,450 --> 00:06:22,770
replace every Java library in the bill

00:06:18,270 --> 00:06:29,010
file and and and we place a Java library

00:06:22,770 --> 00:06:32,130
with a Michael and this is to delay it

00:06:29,010 --> 00:06:35,400
some sort I get to so this is the end of

00:06:32,130 --> 00:06:38,070
my examples I don't know if we have time

00:06:35,400 --> 00:06:38,910
for questions so yeah so the next slide

00:06:38,070 --> 00:06:42,450
just

00:06:38,910 --> 00:06:53,560
the bigoted page

00:06:42,450 --> 00:06:55,420
Thank You Laurel so no phobia yes Fabian

00:06:53,560 --> 00:07:03,040
is going to talk about a linter for

00:06:55,420 --> 00:07:05,110
Skylark oh okay

00:07:03,040 --> 00:07:07,600
hi everyone my name is Fabian sizer and

00:07:05,110 --> 00:07:09,850
I have been an intern on the Basel team

00:07:07,600 --> 00:07:12,010
and over the last three months

00:07:09,850 --> 00:07:13,270
I have been implementing linter for this

00:07:12,010 --> 00:07:15,580
catalogue language like a static

00:07:13,270 --> 00:07:17,620
analyzer and this time I just want to

00:07:15,580 --> 00:07:21,700
show you quickly what is capable of and

00:07:17,620 --> 00:07:23,200
how we can use it so I made up this

00:07:21,700 --> 00:07:25,330
artificial example of a Skylark file

00:07:23,200 --> 00:07:27,880
sorry for me it's artificial but yeah

00:07:25,330 --> 00:07:30,070
it's it to showcase all what the minute

00:07:27,880 --> 00:07:33,730
can do there's a lot of things that are

00:07:30,070 --> 00:07:37,060
bad about this for example it's missing

00:07:33,730 --> 00:07:38,320
all kinds of dog strings so um first of

00:07:37,060 --> 00:07:40,810
all we need a doc string at the top of

00:07:38,320 --> 00:07:43,300
the file describe does also we have a

00:07:40,810 --> 00:07:44,950
public function foo ah this should also

00:07:43,300 --> 00:07:47,950
have a doc string at least at least if

00:07:44,950 --> 00:07:50,590
it's longer than yeah usually function

00:07:47,950 --> 00:07:52,110
no longer than this so yeah also those

00:07:50,590 --> 00:07:53,950
certainly should be at the top of a file

00:07:52,110 --> 00:08:00,190
because they're just like in first

00:07:53,950 --> 00:08:01,360
statement and in addition we have a

00:08:00,190 --> 00:08:03,730
couple of naming conventions in sky dark

00:08:01,360 --> 00:08:05,350
so usually variable names should be

00:08:03,730 --> 00:08:09,250
snake case so all the words are

00:08:05,350 --> 00:08:12,370
separated by underscores so the first

00:08:09,250 --> 00:08:14,230
global variable violates this rule um

00:08:12,370 --> 00:08:16,990
providers are different provider names

00:08:14,230 --> 00:08:18,370
should be upper camel case because

00:08:16,990 --> 00:08:20,470
they're basically like type names in

00:08:18,370 --> 00:08:23,790
Python and they should also have the

00:08:20,470 --> 00:08:25,900
suffix info but also one's brothers and

00:08:23,790 --> 00:08:29,050
if you look down below we have a

00:08:25,900 --> 00:08:30,640
variable there that um shadows are

00:08:29,050 --> 00:08:32,020
built-in so those functions are built-in

00:08:30,640 --> 00:08:34,780
and that's not a good thing to do

00:08:32,020 --> 00:08:35,979
because it's just confusing um - good

00:08:34,780 --> 00:08:42,010
so doesn't tell us the ones about this

00:08:35,979 --> 00:08:44,950
and a bit more complicated examples so

00:08:42,010 --> 00:08:46,240
the variable at the top starts with an

00:08:44,950 --> 00:08:48,940
underscore that means it's a private

00:08:46,240 --> 00:08:50,440
variable it's not exported and it's

00:08:48,940 --> 00:08:52,760
never using the file so we can just say

00:08:50,440 --> 00:08:56,420
it's useless and yeah

00:08:52,760 --> 00:08:57,620
reporters also in the load statement

00:08:56,420 --> 00:08:59,810
reloading a function that's never used

00:08:57,620 --> 00:09:04,040
in that file that was also something

00:08:59,810 --> 00:09:06,560
does make sense into ones about it the

00:09:04,040 --> 00:09:08,500
next thing is a bit special so we see

00:09:06,560 --> 00:09:11,120
that the function is to return

00:09:08,500 --> 00:09:13,280
statements and in one in return the

00:09:11,120 --> 00:09:15,290
value and the other one there is no

00:09:13,280 --> 00:09:17,960
value which might indicate it back in

00:09:15,290 --> 00:09:20,180
the program so if you actually want to

00:09:17,960 --> 00:09:21,950
return none which is what the return

00:09:20,180 --> 00:09:25,400
statement does it just write return none

00:09:21,950 --> 00:09:27,410
to make it clear what your intent is and

00:09:25,400 --> 00:09:30,380
the final problem whose thing here is

00:09:27,410 --> 00:09:31,700
that the variable list is may not have

00:09:30,380 --> 00:09:33,940
been initialized it's just in this less

00:09:31,700 --> 00:09:39,620
than one branch of the excitement and

00:09:33,940 --> 00:09:42,380
the Lynch also catches on yes those are

00:09:39,620 --> 00:09:43,970
some examples of what it can do and if

00:09:42,380 --> 00:09:46,040
you want to use it the interest part of

00:09:43,970 --> 00:09:48,290
the base repository to run it you just

00:09:46,040 --> 00:09:52,010
use basil run and then this long target

00:09:48,290 --> 00:09:55,490
name just just search for scallions and

00:09:52,010 --> 00:09:57,170
you find it yeah documentation is also

00:09:55,490 --> 00:10:00,800
available since like two days ago I

00:09:57,170 --> 00:10:03,230
think on that address or just search

00:10:00,800 --> 00:10:05,180
ascandent again feedback on the usual

00:10:03,230 --> 00:10:07,640
channels issue tracker basil discuss

00:10:05,180 --> 00:10:09,850
school groups yeah thank you for your

00:10:07,640 --> 00:10:09,850
attention

00:10:13,240 --> 00:10:20,330
so next is chair convert from the go

00:10:16,580 --> 00:10:23,120
team at Google so we have a few people

00:10:20,330 --> 00:10:25,280
might innings agarose for basil it's

00:10:23,120 --> 00:10:26,900
like oh there's a between Zuka team and

00:10:25,280 --> 00:10:31,150
check is one of them and he's going to

00:10:26,900 --> 00:10:34,240
talk about Kaiser that's for you and

00:10:31,150 --> 00:10:37,130
your thoughts that can everyone hear me

00:10:34,240 --> 00:10:39,620
everyone my name is J Conrad I work at

00:10:37,130 --> 00:10:41,660
Google on the go rules for basil today

00:10:39,620 --> 00:10:43,970
I'll be talking about gazelle it's a

00:10:41,660 --> 00:10:46,250
command-line tool for generating and

00:10:43,970 --> 00:10:48,130
updating build files for go projects it

00:10:46,250 --> 00:10:52,550
can generate rules that look like this

00:10:48,130 --> 00:10:54,430
there we go how many people here use go

00:10:52,550 --> 00:10:57,320
or have used go in the pest

00:10:54,430 --> 00:10:59,900
alright quite a few go build is pretty

00:10:57,320 --> 00:11:03,200
great right pretty simple to use really

00:10:59,900 --> 00:11:07,670
nice thing about go know

00:11:03,200 --> 00:11:09,139
let's talk afterward a really nice thing

00:11:07,670 --> 00:11:12,950
about NGO is that you don't have to

00:11:09,139 --> 00:11:14,959
write build files go builds just figures

00:11:12,950 --> 00:11:17,540
everything out for you as long as you

00:11:14,959 --> 00:11:19,760
follow the certain conventions I guess

00:11:17,540 --> 00:11:22,660
it is a little bit opinionated but they

00:11:19,760 --> 00:11:22,660
usually it works pretty well

00:11:23,050 --> 00:11:27,649
obviously go build has certain

00:11:24,920 --> 00:11:29,420
limitations compared with Basel can't

00:11:27,649 --> 00:11:31,850
build multi-language projects

00:11:29,420 --> 00:11:34,310
it handles generated code fairly poorly

00:11:31,850 --> 00:11:36,350
and it doesn't do distributed build or

00:11:34,310 --> 00:11:39,920
cache so there are still a lot of

00:11:36,350 --> 00:11:41,839
reasons to use basil but for go-go users

00:11:39,920 --> 00:11:43,430
looking at basil for the first time it's

00:11:41,839 --> 00:11:44,750
kind of a hard sell because you have to

00:11:43,430 --> 00:11:47,839
you have to write all this configuration

00:11:44,750 --> 00:11:49,730
that people aren't used to so this is

00:11:47,839 --> 00:11:51,560
where gazelle comes in because out can

00:11:49,730 --> 00:11:54,470
generate build files for any project

00:11:51,560 --> 00:11:55,880
that follows go build conventions it

00:11:54,470 --> 00:11:58,279
walks over the directories in a

00:11:55,880 --> 00:12:01,130
repository looks at all the go files and

00:11:58,279 --> 00:12:04,160
then writes a build file with go library

00:12:01,130 --> 00:12:06,440
go binary and go test rules it can also

00:12:04,160 --> 00:12:10,120
generate proto rules if you have proto

00:12:06,440 --> 00:12:12,800
files in your repository go proto rules

00:12:10,120 --> 00:12:15,230
if there's already a build file in that

00:12:12,800 --> 00:12:17,300
directory gazelle will merge the

00:12:15,230 --> 00:12:18,890
generated rules with the build file

00:12:17,300 --> 00:12:22,339
that's already there and it'll leave

00:12:18,890 --> 00:12:23,570
existing rules alone in addition to

00:12:22,339 --> 00:12:25,760
generating build files for your own

00:12:23,570 --> 00:12:29,120
repository gazelle also works on

00:12:25,760 --> 00:12:31,250
external repositories so we provide a go

00:12:29,120 --> 00:12:35,269
repository rule that downloads a repo

00:12:31,250 --> 00:12:36,890
and runs gazelle on it so you can use

00:12:35,269 --> 00:12:39,440
any library or package out in the go

00:12:36,890 --> 00:12:45,339
ecosystem just by adding go repository

00:12:39,440 --> 00:12:47,420
to your workspace file this is a

00:12:45,339 --> 00:12:49,940
particularly cool thing that gazelle can

00:12:47,420 --> 00:12:52,339
do that I wanted to show you gazelle can

00:12:49,940 --> 00:12:54,500
handle platform specific sources and

00:12:52,339 --> 00:12:56,750
imports so in go

00:12:54,500 --> 00:13:00,860
you can add suffixes on your file names

00:12:56,750 --> 00:13:03,519
like Linux or amd64 and that makes them

00:13:00,860 --> 00:13:06,350
platform specific according to go build

00:13:03,519 --> 00:13:07,880
you can also put the special comments at

00:13:06,350 --> 00:13:10,100
the at the top of a file that do the

00:13:07,880 --> 00:13:12,649
same thing gazelle knows about these

00:13:10,100 --> 00:13:14,510
conventions and it will put the sources

00:13:12,649 --> 00:13:18,010
and their imports the dependencies for

00:13:14,510 --> 00:13:20,300
their imports in appropriate select case

00:13:18,010 --> 00:13:22,250
it's important that gizelle does this

00:13:20,300 --> 00:13:24,940
and not the go rules themselves although

00:13:22,250 --> 00:13:26,780
they also recognize these conventions

00:13:24,940 --> 00:13:29,900
the reason is if you have a

00:13:26,780 --> 00:13:31,340
platform-specific dependency for example

00:13:29,900 --> 00:13:35,060
let's say you have a graphics library

00:13:31,340 --> 00:13:37,100
that only compiles on windows basel will

00:13:35,060 --> 00:13:40,190
not attempt to compile that library if

00:13:37,100 --> 00:13:41,900
you're not using windows so there's a

00:13:40,190 --> 00:13:44,690
huge chunk of code that won't get

00:13:41,900 --> 00:13:47,360
compiled that you won't see errors from

00:13:44,690 --> 00:13:52,550
if it's behind hidden behind a select

00:13:47,360 --> 00:13:54,230
case before before I wrap up I wanted to

00:13:52,550 --> 00:13:56,120
mention some upcoming changes in gizelle

00:13:54,230 --> 00:13:58,250
but first we're looking at supporting

00:13:56,120 --> 00:14:01,040
more NGO platforms the NGO rules can

00:13:58,250 --> 00:14:04,460
cross compile to any platform that the

00:14:01,040 --> 00:14:06,110
go SDK supports when the next version of

00:14:04,460 --> 00:14:08,510
basil is released we'll be able to

00:14:06,110 --> 00:14:10,370
express all those platforms using config

00:14:08,510 --> 00:14:14,450
settings with the new constraint value

00:14:10,370 --> 00:14:16,910
support gazelle will generate select

00:14:14,450 --> 00:14:18,620
expressions that match those so today

00:14:16,910 --> 00:14:22,300
gazelle only supports three platforms

00:14:18,620 --> 00:14:22,300
which are matched using the CPU flag

00:14:22,480 --> 00:14:28,880
second we're working on better

00:14:26,390 --> 00:14:30,770
dependency resolution currently we just

00:14:28,880 --> 00:14:33,320
do a textual transformation from go

00:14:30,770 --> 00:14:36,200
import path to a basil label for for the

00:14:33,320 --> 00:14:38,510
depths in the future gazelle will build

00:14:36,200 --> 00:14:42,320
an index of all of the go rules within a

00:14:38,510 --> 00:14:44,030
repository and use that index to do

00:14:42,320 --> 00:14:47,330
dependency resolution that'll be keyed

00:14:44,030 --> 00:14:49,280
by import path this should make ven

00:14:47,330 --> 00:14:53,060
during and mono repos much easier to

00:14:49,280 --> 00:14:55,100
support and go third we're thinking

00:14:53,060 --> 00:14:57,710
about better external dependency

00:14:55,100 --> 00:14:59,870
management when a go project has 50-plus

00:14:57,710 --> 00:15:02,390
transitive dependencies it's a real pain

00:14:59,870 --> 00:15:03,740
to build a workspace file for that this

00:15:02,390 --> 00:15:06,050
is actually a problem at every language

00:15:03,740 --> 00:15:09,310
has I think so we're planning on having

00:15:06,050 --> 00:15:11,600
gazelle be able to add update and remove

00:15:09,310 --> 00:15:13,520
dependencies based on which import paths

00:15:11,600 --> 00:15:16,910
could or could not be resolved in the

00:15:13,520 --> 00:15:19,190
current repository overall gazelles made

00:15:16,910 --> 00:15:21,980
developing go code within basil a lot

00:15:19,190 --> 00:15:23,720
simpler I hope we can eventually make

00:15:21,980 --> 00:15:25,940
migrating go projects to basil as

00:15:23,720 --> 00:15:27,710
painless as possible because I was part

00:15:25,940 --> 00:15:30,290
of rules go so it's it's in this

00:15:27,710 --> 00:15:39,520
repository now so if you're building go

00:15:30,290 --> 00:15:43,010
check us out okay on the right on time

00:15:39,520 --> 00:15:49,520
so next is a journey so Shirley's

00:15:43,010 --> 00:15:51,290
working on our team inside so bizarre

00:15:49,520 --> 00:15:53,060
team and she's going to talk about a

00:15:51,290 --> 00:15:57,200
platform and selection or how you you

00:15:53,060 --> 00:16:00,200
can make multiple at home walks hi

00:15:57,200 --> 00:16:02,089
everyone my name is Julie like Diane

00:16:00,200 --> 00:16:04,120
said I work on the Basel team in New

00:16:02,089 --> 00:16:06,680
York and today I'll be talking about

00:16:04,120 --> 00:16:09,020
basically what Jay just mentioned in

00:16:06,680 --> 00:16:11,990
terms of adding platforms to slide so if

00:16:09,020 --> 00:16:13,279
you're unfamiliar with select or

00:16:11,990 --> 00:16:14,990
configurable attributes in general

00:16:13,279 --> 00:16:16,610
configurable attributes is a really cool

00:16:14,990 --> 00:16:18,529
feature that blaze has that allows you

00:16:16,610 --> 00:16:20,959
to select some of the values of your

00:16:18,529 --> 00:16:25,130
builder attributes based on command line

00:16:20,959 --> 00:16:26,959
flex so as you can see here select

00:16:25,130 --> 00:16:28,670
statements are maps of labels to

00:16:26,959 --> 00:16:32,270
potential values your attributes could

00:16:28,670 --> 00:16:33,980
have and the labels are representative

00:16:32,270 --> 00:16:36,350
of config settings which are essentially

00:16:33,980 --> 00:16:39,050
just collections of command line flags

00:16:36,350 --> 00:16:42,860
so this particular invocation is how you

00:16:39,050 --> 00:16:45,079
would get the x86 or SSH file for your

00:16:42,860 --> 00:16:49,370
sources attribute so what we've added

00:16:45,079 --> 00:16:50,390
that Jay mentioned is platforms so a lot

00:16:49,370 --> 00:16:52,670
of people today I've already talked

00:16:50,390 --> 00:16:54,440
about platforms but just to nail down

00:16:52,670 --> 00:16:58,310
what I'm talking about in this

00:16:54,440 --> 00:17:00,260
particular instance a platform is just a

00:16:58,310 --> 00:17:02,390
device that you can run program on right

00:17:00,260 --> 00:17:05,089
so like basil a compiler or an

00:17:02,390 --> 00:17:07,250
executable and it's particularly

00:17:05,089 --> 00:17:09,160
important for us to be able to talk

00:17:07,250 --> 00:17:15,020
about platforms in our built roles today

00:17:09,160 --> 00:17:17,059
because we not only have traditional

00:17:15,020 --> 00:17:19,250
fields where your basil and your

00:17:17,059 --> 00:17:22,910
compiler run on the same device as your

00:17:19,250 --> 00:17:25,220
executable but we now have builds where

00:17:22,910 --> 00:17:26,630
your basil and your compiler are

00:17:25,220 --> 00:17:29,900
actually compiling for a different

00:17:26,630 --> 00:17:33,470
device as is the case in Android and iOS

00:17:29,900 --> 00:17:35,059
apps so those devices are just platforms

00:17:33,470 --> 00:17:37,820
right and the way that we've defined

00:17:35,059 --> 00:17:38,929
platforms in build rules is with these

00:17:37,820 --> 00:17:40,809
three new rules called platform

00:17:38,929 --> 00:17:43,700
constraint setting and constraint value

00:17:40,809 --> 00:17:45,559
and

00:17:43,700 --> 00:17:46,760
constraint settings are variables you

00:17:45,559 --> 00:17:48,890
might care about that might affect your

00:17:46,760 --> 00:17:51,049
build such as the operating system or a

00:17:48,890 --> 00:17:53,299
particular version of a compiler or the

00:17:51,049 --> 00:17:54,679
presence of a GPU something like that in

00:17:53,299 --> 00:17:56,809
the example I have here's operating

00:17:54,679 --> 00:17:58,220
system and cosmic values are just

00:17:56,809 --> 00:18:00,350
potential values those settings could

00:17:58,220 --> 00:18:03,320
have and platforms are just collections

00:18:00,350 --> 00:18:06,260
of those constraint values so the way

00:18:03,320 --> 00:18:08,450
platform links into traditional config

00:18:06,260 --> 00:18:09,679
settings is if you saw this config

00:18:08,450 --> 00:18:11,390
heading and wanted to see if it was a

00:18:09,679 --> 00:18:13,370
match you would just check if it had the

00:18:11,390 --> 00:18:16,220
same constraint values as a platform you

00:18:13,370 --> 00:18:18,289
have in your build files and if it does

00:18:16,220 --> 00:18:20,240
if that platform has the contained

00:18:18,289 --> 00:18:21,950
constraints or a superset you see if

00:18:20,240 --> 00:18:23,510
it's the same one that's triggered by

00:18:21,950 --> 00:18:26,960
your experiments of platforms flag and

00:18:23,510 --> 00:18:29,510
if so it's considered a match um so

00:18:26,960 --> 00:18:31,909
we've seen a lot of complicated selects

00:18:29,510 --> 00:18:33,890
in the presentations already today and I

00:18:31,909 --> 00:18:35,809
don't think anybody here has like an

00:18:33,890 --> 00:18:37,820
innate love for complicated build files

00:18:35,809 --> 00:18:40,120
so you may be wondering why is is so

00:18:37,820 --> 00:18:42,530
important and J already mentioned it but

00:18:40,120 --> 00:18:45,409
this is actually the same slide he just

00:18:42,530 --> 00:18:48,530
used so the go world's team at Google is

00:18:45,409 --> 00:18:50,240
using this particularly for tool chain

00:18:48,530 --> 00:18:52,640
selection and that's a huge use case for

00:18:50,240 --> 00:18:54,049
platforms in general because if you

00:18:52,640 --> 00:18:57,500
choose the wrong tool chain like as we

00:18:54,049 --> 00:18:58,610
know your bill just fails because it

00:18:57,500 --> 00:19:01,429
looks at a source that doesn't really

00:18:58,610 --> 00:19:03,860
work out so before platforms existed

00:19:01,429 --> 00:19:06,500
this selection was done on the CPU flag

00:19:03,860 --> 00:19:08,990
and sometimes the CPU flag is a good

00:19:06,500 --> 00:19:10,970
proxy for which tool chain you want and

00:19:08,990 --> 00:19:13,070
sometimes it's aw and when it fails it's

00:19:10,970 --> 00:19:14,570
really annoying to figure out what

00:19:13,070 --> 00:19:16,940
happened and how to debug your build

00:19:14,570 --> 00:19:18,620
because it will only fail for a certain

00:19:16,940 --> 00:19:20,630
like operating system architecture

00:19:18,620 --> 00:19:22,610
combinations you don't really know what

00:19:20,630 --> 00:19:25,730
that one was and often the CPU flag is

00:19:22,610 --> 00:19:28,580
just inferred from the basic

00:19:25,730 --> 00:19:31,280
architecture so it's really annoying and

00:19:28,580 --> 00:19:33,049
now you have the specificity to just

00:19:31,280 --> 00:19:35,659
decide exactly which tool chain you want

00:19:33,049 --> 00:19:36,830
or which tool you want in other

00:19:35,659 --> 00:19:38,780
scenarios where you might want a

00:19:36,830 --> 00:19:41,179
platform if you want to hear more about

00:19:38,780 --> 00:19:42,620
platforms I think like four people have

00:19:41,179 --> 00:19:44,659
already plugged this talk but John cater

00:19:42,620 --> 00:19:46,360
will be talking about it tomorrow in a

00:19:44,659 --> 00:19:49,429
breakout session and that should be

00:19:46,360 --> 00:19:52,960
really awesome and I think that's all I

00:19:49,429 --> 00:19:52,960
have for you

00:19:57,170 --> 00:20:08,760
when I was walking annoyed arose in the

00:20:02,390 --> 00:20:11,100
desert okay hi everyone I hope you've

00:20:08,760 --> 00:20:12,870
been having a good day as Damian said my

00:20:11,100 --> 00:20:16,260
name is Donna I work on the Basel

00:20:12,870 --> 00:20:18,630
Android rules at Google as many people

00:20:16,260 --> 00:20:21,230
have mentioned today testing is very

00:20:18,630 --> 00:20:23,970
important but right now there are no

00:20:21,230 --> 00:20:26,580
Android rules Android testing rules in

00:20:23,970 --> 00:20:29,030
Basel but I'm going to be talking about

00:20:26,580 --> 00:20:31,590
a new rule that will be released soon

00:20:29,030 --> 00:20:34,440
that will enable you to unit test your

00:20:31,590 --> 00:20:37,740
Android apps this rule is called Android

00:20:34,440 --> 00:20:39,990
local tests yeah

00:20:37,740 --> 00:20:41,940
so Android local tests works closely

00:20:39,990 --> 00:20:45,960
with a testing framework called

00:20:41,940 --> 00:20:49,110
robolectric Android apps run on your

00:20:45,960 --> 00:20:52,650
phone on a device and so generally you

00:20:49,110 --> 00:20:55,710
would want to test your app on the

00:20:52,650 --> 00:20:58,200
device however this is often very slow

00:20:55,710 --> 00:21:01,460
and so it would be great if there was an

00:20:58,200 --> 00:21:03,510
additional alternative and that is where

00:21:01,460 --> 00:21:06,240
robolectric comes in

00:21:03,510 --> 00:21:09,660
so robolectric runs android framework

00:21:06,240 --> 00:21:12,090
code directly inside of the JVM on your

00:21:09,660 --> 00:21:15,750
computer which enables you to run tests

00:21:12,090 --> 00:21:17,310
much faster than on a device in a

00:21:15,750 --> 00:21:21,330
similar environment to the one that's on

00:21:17,310 --> 00:21:24,120
your phone so let's take a look at what

00:21:21,330 --> 00:21:26,970
an actual rule looks like so here we

00:21:24,120 --> 00:21:29,940
have an Android local test in the

00:21:26,970 --> 00:21:32,010
sources you have the test code itself

00:21:29,940 --> 00:21:33,990
and in the depths you have all of your

00:21:32,010 --> 00:21:37,020
dependencies including the code that you

00:21:33,990 --> 00:21:38,760
want to be testing and if anyone's ever

00:21:37,020 --> 00:21:41,460
written a java test this might look

00:21:38,760 --> 00:21:44,100
suspiciously similar and so you may

00:21:41,460 --> 00:21:47,540
wonder why not just use Java tests but

00:21:44,100 --> 00:21:50,640
as I mentioned this rule enables you to

00:21:47,540 --> 00:21:53,100
test your Android code and a critical

00:21:50,640 --> 00:21:56,460
difference between Android code and Java

00:21:53,100 --> 00:21:58,260
code is that Android has resources and

00:21:56,460 --> 00:22:02,280
manifests that need to be treated

00:21:58,260 --> 00:22:04,470
specially and this rule treats those

00:22:02,280 --> 00:22:06,240
things as equal citizens to the Java

00:22:04,470 --> 00:22:12,780
code itself

00:22:06,240 --> 00:22:16,200
um yes so previously previous versions

00:22:12,780 --> 00:22:19,140
of robolectric did its own custom

00:22:16,200 --> 00:22:21,000
resource processing but the resource

00:22:19,140 --> 00:22:23,130
processing that it did was often

00:22:21,000 --> 00:22:26,250
different than the resource processing

00:22:23,130 --> 00:22:29,460
that the build system did and so with

00:22:26,250 --> 00:22:31,290
this rule the rule itself does the

00:22:29,460 --> 00:22:33,900
resource processing and then hands off

00:22:31,290 --> 00:22:36,480
those artifacts to robolectric and so

00:22:33,900 --> 00:22:38,070
now this rule does this resource

00:22:36,480 --> 00:22:40,080
processing in the same way that your

00:22:38,070 --> 00:22:42,540
Android library and your Android binary

00:22:40,080 --> 00:22:44,550
does resource processing and so you know

00:22:42,540 --> 00:22:47,040
that you are testing the same thing that

00:22:44,550 --> 00:22:49,650
you're going to be releasing moreover

00:22:47,040 --> 00:22:51,450
when robolectric did the resource

00:22:49,650 --> 00:22:54,000
processing it had to do this with every

00:22:51,450 --> 00:22:55,650
single test invocation but with the rule

00:22:54,000 --> 00:22:58,170
doing it we can take advantage of

00:22:55,650 --> 00:23:03,590
basil's incrementality and so your tests

00:22:58,170 --> 00:23:06,809
are not only correct but also faster oh

00:23:03,590 --> 00:23:08,490
yes okay now I'm going to attempt to do

00:23:06,809 --> 00:23:12,800
a live demo does this microphone also

00:23:08,490 --> 00:23:17,780
work because I need both my hands okay

00:23:12,800 --> 00:23:30,210
can everyone still hear me create okay

00:23:17,780 --> 00:23:33,690
and it's tiny okay so it's this visible

00:23:30,210 --> 00:23:37,080
at all great okay so this is an example

00:23:33,690 --> 00:23:39,929
robolectric test and what it's testing

00:23:37,080 --> 00:23:42,360
if you look at line 25 that's where the

00:23:39,929 --> 00:23:44,520
interesting stuff starts so it's testing

00:23:42,360 --> 00:23:46,590
that you have this button and when you

00:23:44,520 --> 00:23:48,150
click on this button it asserts that the

00:23:46,590 --> 00:23:53,429
app informs us that the ice cream is

00:23:48,150 --> 00:23:56,820
ready so here we have this test that's

00:23:53,429 --> 00:24:07,590
what we want it to do and so if we run

00:23:56,820 --> 00:24:12,030
our test so well test it and oh this one

00:24:07,590 --> 00:24:17,490
you can't see okay well haha okay well

00:24:12,030 --> 00:24:19,450
it just it just failed so if we go and

00:24:17,490 --> 00:24:22,420
we look

00:24:19,450 --> 00:24:25,330
at what the code is doing huh

00:24:22,420 --> 00:24:27,910
well on line 20 it seems like someone

00:24:25,330 --> 00:24:30,490
forgot to actually implement the ice

00:24:27,910 --> 00:24:48,940
cream generation and so if we do this

00:24:30,490 --> 00:24:58,300
and save it and run the test again yay

00:24:48,940 --> 00:25:01,530
okay so right so test-driven development

00:24:58,300 --> 00:25:03,910
is something that's pretty useful so

00:25:01,530 --> 00:25:10,630
this hopefully will make it possible

00:25:03,910 --> 00:25:12,670
thank you so we are going to stop a bit

00:25:10,630 --> 00:25:19,180
for a wave cause I think you've got

00:25:12,670 --> 00:25:21,460
enough of them so Paul is walking for

00:25:19,180 --> 00:25:30,670
progress which is a publication or

00:25:21,460 --> 00:25:32,890
service yes clicker yes if they're okay

00:25:30,670 --> 00:25:34,300
I'm all set thank you my name is Paul so

00:25:32,890 --> 00:25:37,210
I'm going to talk briefly about the

00:25:34,300 --> 00:25:39,250
build event protocol so as you might

00:25:37,210 --> 00:25:41,410
imagine the build event protocol is a

00:25:39,250 --> 00:25:44,050
specification for producing and

00:25:41,410 --> 00:25:47,050
consuming build events so in this case

00:25:44,050 --> 00:25:48,550
basil is the producer of these events

00:25:47,050 --> 00:25:50,800
and if you want to integrate with it

00:25:48,550 --> 00:25:52,510
you build an application to consume

00:25:50,800 --> 00:25:54,970
these events and basil will publish them

00:25:52,510 --> 00:25:57,100
to you so in my case experimenting with

00:25:54,970 --> 00:25:58,540
alternative user interface to basil but

00:25:57,100 --> 00:25:59,650
you can imagine it might be useful in a

00:25:58,540 --> 00:26:02,200
number of different scenarios

00:25:59,650 --> 00:26:02,950
I listed here or whatever is you know in

00:26:02,200 --> 00:26:07,000
your on your mind

00:26:02,950 --> 00:26:08,830
so for my little demo application this

00:26:07,000 --> 00:26:11,320
is what we have there's pretty much two

00:26:08,830 --> 00:26:13,180
takeaways one is that if you have anyone

00:26:11,320 --> 00:26:17,790
else to make diagrams for your slides

00:26:13,180 --> 00:26:20,920
you should do that I didn't know is that

00:26:17,790 --> 00:26:23,350
writing or drawing the Go gopher in

00:26:20,920 --> 00:26:25,090
colored pencil it's super fun and it

00:26:23,350 --> 00:26:28,060
will totally improve your day so I

00:26:25,090 --> 00:26:28,870
encourage everyone to do that so what

00:26:28,060 --> 00:26:32,380
we're doing here is we're basically

00:26:28,870 --> 00:26:33,190
making a quest from the browser using G

00:26:32,380 --> 00:26:35,770
RPC web

00:26:33,190 --> 00:26:37,540
just kind of a new protocol and what

00:26:35,770 --> 00:26:40,900
we're doing on server then is we're

00:26:37,540 --> 00:26:44,680
going to use OS execute to call basil

00:26:40,900 --> 00:26:46,960
build with this BES back-end flag which

00:26:44,680 --> 00:26:49,330
is going to name the host and port

00:26:46,960 --> 00:26:52,210
number where we want events to be posted

00:26:49,330 --> 00:26:54,010
to so in basil runs it's going to it's

00:26:52,210 --> 00:26:56,920
going to publish those events over to g

00:26:54,010 --> 00:26:58,540
RPC end points and then we'll use

00:26:56,920 --> 00:27:00,550
channels to kind of funnel those back to

00:26:58,540 --> 00:27:04,600
our original requests and then push

00:27:00,550 --> 00:27:07,210
those back up to the browser so if you

00:27:04,600 --> 00:27:08,650
want to use it there's kind of two

00:27:07,210 --> 00:27:10,960
different ways to invoke it here and I

00:27:08,650 --> 00:27:13,480
would encourage if you have no interest

00:27:10,960 --> 00:27:16,120
in the build of nth protocol at all

00:27:13,480 --> 00:27:18,130
try build something at least once with

00:27:16,120 --> 00:27:20,890
this basil build build event JSON file

00:27:18,130 --> 00:27:22,150
and just give it any file name and then

00:27:20,890 --> 00:27:23,950
look at the output because there's a

00:27:22,150 --> 00:27:25,150
kind of a wealth of information in there

00:27:23,950 --> 00:27:27,640
you're gonna learn something you didn't

00:27:25,150 --> 00:27:29,230
know before I would also encourage

00:27:27,640 --> 00:27:31,240
everyone to check out there's a pretty

00:27:29,230 --> 00:27:33,670
decent blog post on the basil

00:27:31,240 --> 00:27:36,520
documentation about the protocol so you

00:27:33,670 --> 00:27:38,440
should read that as well

00:27:36,520 --> 00:27:40,300
one of the confusing aspects about the

00:27:38,440 --> 00:27:41,650
build event protocol is that it's

00:27:40,300 --> 00:27:44,260
defined really in two different places

00:27:41,650 --> 00:27:46,300
so when you invoke basil with this BES

00:27:44,260 --> 00:27:47,770
but back in flag you're getting events

00:27:46,300 --> 00:27:50,050
that are defining this published build

00:27:47,770 --> 00:27:52,900
event proto file which is housed in the

00:27:50,050 --> 00:27:55,180
google api s-- repo whereas if you

00:27:52,900 --> 00:27:58,410
invoke it with these this other flag

00:27:55,180 --> 00:28:00,760
build a mint text file you get events

00:27:58,410 --> 00:28:02,830
it's more represent sort of a build

00:28:00,760 --> 00:28:04,690
graph in this build immense stream proto

00:28:02,830 --> 00:28:06,610
file which is in the basil repo itself

00:28:04,690 --> 00:28:08,320
so I think you know it's a little a

00:28:06,610 --> 00:28:10,870
moving target at work in progress I

00:28:08,320 --> 00:28:11,980
would defer to a basil team member to

00:28:10,870 --> 00:28:12,820
kind of you know give us more

00:28:11,980 --> 00:28:16,570
information about where it's going

00:28:12,820 --> 00:28:19,900
eventually but so these are some of the

00:28:16,570 --> 00:28:21,700
kind of events you will get the

00:28:19,900 --> 00:28:24,690
lifecycle events are sort of these sort

00:28:21,700 --> 00:28:26,860
of generic builds has been queued

00:28:24,690 --> 00:28:29,980
various things and then there's these

00:28:26,860 --> 00:28:31,300
tool events which is this ordered build

00:28:29,980 --> 00:28:35,440
event it's kind of a generic wrapper

00:28:31,300 --> 00:28:38,590
that you can extract these other events

00:28:35,440 --> 00:28:40,510
which are a build graph and those are

00:28:38,590 --> 00:28:42,340
pretty interesting have a lot of

00:28:40,510 --> 00:28:45,550
information in them

00:28:42,340 --> 00:28:47,790
so here's just our animated gif of the

00:28:45,550 --> 00:28:49,890
of the application going and

00:28:47,790 --> 00:28:52,270
demonstrating that yet indeed we can

00:28:49,890 --> 00:28:56,170
consume the bill event protocol from

00:28:52,270 --> 00:28:58,660
within a browser and build targets you

00:28:56,170 --> 00:29:01,210
know so there's a lot more information I

00:28:58,660 --> 00:29:03,910
haven't shown here so with that I'm

00:29:01,210 --> 00:29:07,540
happy to answer any questions and my

00:29:03,910 --> 00:29:08,920
github if you help I open sources at

00:29:07,540 --> 00:29:19,210
some point but it's still a little dirty

00:29:08,920 --> 00:29:21,940
so thank you next is FS or RA is

00:29:19,210 --> 00:29:25,240
actually a Googler but is working in the

00:29:21,940 --> 00:29:28,320
Envoy team it's right it's going to talk

00:29:25,240 --> 00:29:30,240
about a commission of envoy to Basel

00:29:28,320 --> 00:29:33,430
okay

00:29:30,240 --> 00:29:35,140
hi yeah so I'm Harvey toca I work at

00:29:33,430 --> 00:29:37,270
Google and we talked a little bit about

00:29:35,140 --> 00:29:40,660
the trials and tribulations that we went

00:29:37,270 --> 00:29:43,360
through converting envoy to Basel so

00:29:40,660 --> 00:29:47,620
first of all what is envoy well it's an

00:29:43,360 --> 00:29:50,650
open source project it's purely a sort

00:29:47,620 --> 00:29:53,560
of service mesh proxy design for modern

00:29:50,650 --> 00:29:56,050
micro service architectures also used as

00:29:53,560 --> 00:29:59,080
an edge proxy it's developed on github

00:29:56,050 --> 00:30:03,010
by Google lyft and other contributors

00:29:59,080 --> 00:30:05,890
like Apple strike very it's just growing

00:30:03,010 --> 00:30:10,090
all the time it's a midsize C++ project

00:30:05,890 --> 00:30:16,900
and we use what I consider modern C++

00:30:10,090 --> 00:30:19,330
best practices so yes before I address

00:30:16,900 --> 00:30:20,440
the right-hand side of this slide one

00:30:19,330 --> 00:30:22,480
thing I like to say is like working

00:30:20,440 --> 00:30:23,830
Google is like really awesome and one of

00:30:22,480 --> 00:30:25,300
the reasons it's awesome is because we

00:30:23,830 --> 00:30:28,480
get to work with great infrastructure

00:30:25,300 --> 00:30:29,980
including amazing code search these sort

00:30:28,480 --> 00:30:31,930
of remote execution farms we've talked

00:30:29,980 --> 00:30:34,750
about today and technology like basil

00:30:31,930 --> 00:30:37,510
and blaze which was like pretty sort of

00:30:34,750 --> 00:30:38,620
or inspiring coming into for industry on

00:30:37,510 --> 00:30:41,350
the right-hand side of this slide is

00:30:38,620 --> 00:30:42,790
Matt Klein he's the project founder and

00:30:41,350 --> 00:30:45,940
chief of on boy

00:30:42,790 --> 00:30:47,560
he works at lift he is exasperated

00:30:45,940 --> 00:30:50,350
probably looking one of my pull request

00:30:47,560 --> 00:30:53,380
as we made this transition and so the

00:30:50,350 --> 00:30:56,169
question is you know how this experience

00:30:53,380 --> 00:30:58,899
goes so this took place over about

00:30:56,169 --> 00:31:00,489
two months transition there's about a

00:30:58,899 --> 00:31:03,279
hundred commits about twenty four

00:31:00,489 --> 00:31:05,080
thousand lines of code of churn and

00:31:03,279 --> 00:31:07,090
quite a lot of hair pulling along the

00:31:05,080 --> 00:31:08,470
way now there's some things which are

00:31:07,090 --> 00:31:09,970
sort of inherent in any of these

00:31:08,470 --> 00:31:12,100
migrations and we've heard about them

00:31:09,970 --> 00:31:15,159
today in the various examples that we've

00:31:12,100 --> 00:31:17,350
seen these include things like you know

00:31:15,159 --> 00:31:18,639
expressing your dependency graph is

00:31:17,350 --> 00:31:20,919
built files and we wanted to come up

00:31:18,639 --> 00:31:22,749
with a very sort of tight set of

00:31:20,919 --> 00:31:24,759
dependencies that have fine granularity

00:31:22,749 --> 00:31:26,950
we built some tooling to help with this

00:31:24,759 --> 00:31:28,570
along the way we needed to make our test

00:31:26,950 --> 00:31:31,710
hermetic so they would execute with

00:31:28,570 --> 00:31:35,019
bezels parallel execution architecture

00:31:31,710 --> 00:31:36,850
hermetic tests are a good thing . we

00:31:35,019 --> 00:31:39,220
accepted that this was necessary work

00:31:36,850 --> 00:31:40,629
and all this actually wasn't too bad

00:31:39,220 --> 00:31:42,879
this was actually pretty straightforward

00:31:40,629 --> 00:31:44,649
and once we had done a few manual

00:31:42,879 --> 00:31:47,830
examples we could automate most of this

00:31:44,649 --> 00:31:48,999
away so where things were a bit tougher

00:31:47,830 --> 00:31:50,980
and this is again we've heard this

00:31:48,999 --> 00:31:53,649
across many languages today dealing with

00:31:50,980 --> 00:31:56,259
external dependencies so these are the

00:31:53,649 --> 00:31:57,730
transitive dependencies of envoy and you

00:31:56,259 --> 00:31:59,379
can see it's it's just really confusing

00:31:57,730 --> 00:32:02,440
and complex in particular because it's a

00:31:59,379 --> 00:32:04,419
C++ we have various build systems that

00:32:02,440 --> 00:32:06,429
work here and this isn't just a

00:32:04,419 --> 00:32:08,499
homogeneous thing like a maven for

00:32:06,429 --> 00:32:09,879
example you know we have C mate we have

00:32:08,499 --> 00:32:11,320
auto called some of these dependencies

00:32:09,879 --> 00:32:12,940
of basil native dependencies already

00:32:11,320 --> 00:32:14,830
some of these are trivial any

00:32:12,940 --> 00:32:17,049
convertible to basil we took the

00:32:14,830 --> 00:32:20,679
approach similar to SpaceX and not

00:32:17,049 --> 00:32:23,679
similar to tensor flow where we wanted

00:32:20,679 --> 00:32:25,330
to express these Silla dependencies

00:32:23,679 --> 00:32:27,220
using the native build systems we

00:32:25,330 --> 00:32:29,080
thought that would be more scalable and

00:32:27,220 --> 00:32:31,330
also it's more correct fundamentally you

00:32:29,080 --> 00:32:32,619
know many of these ad hoc are build

00:32:31,330 --> 00:32:34,899
rules that are written for external

00:32:32,619 --> 00:32:36,519
dependencies don't cover tests and so

00:32:34,899 --> 00:32:38,440
it's and there's very subtle bugs that

00:32:36,519 --> 00:32:41,320
can in creep in what do you basically

00:32:38,440 --> 00:32:43,929
try and build a parallel build system

00:32:41,320 --> 00:32:47,859
which isn't you know vetted by CI and so

00:32:43,929 --> 00:32:49,570
on okay other fun things so this was

00:32:47,859 --> 00:32:52,210
essentially the long tail trying to hit

00:32:49,570 --> 00:32:54,399
parity with C makes so you know

00:32:52,210 --> 00:32:56,950
introducing the get char for the

00:32:54,399 --> 00:32:58,480
provenance of the build surprisingly

00:32:56,950 --> 00:33:01,299
tricky and a buzzer we actually deride

00:32:58,480 --> 00:33:03,549
at all which did rewriting of elf has a

00:33:01,299 --> 00:33:05,830
binary rewriting tool to do one and C

00:33:03,549 --> 00:33:08,929
makers one-line coverage was a bigger

00:33:05,830 --> 00:33:12,469
pain point for us C++ coverages not

00:33:08,929 --> 00:33:14,389
or today in Basel and involves heroics

00:33:12,469 --> 00:33:16,669
to make work it's really important for

00:33:14,389 --> 00:33:20,029
any serious C++ project in particular

00:33:16,669 --> 00:33:22,549
one which values correctness and code

00:33:20,029 --> 00:33:25,460
quality we run on a bunch of different

00:33:22,549 --> 00:33:28,099
platforms limits primarily Mac OS

00:33:25,460 --> 00:33:30,080
involves us forking the basil the C++

00:33:28,099 --> 00:33:31,909
will train Auto configure scripts

00:33:30,080 --> 00:33:33,739
because of some of the limitations there

00:33:31,909 --> 00:33:37,219
with certain kinds of stripping and

00:33:33,739 --> 00:33:39,589
Static library builds today there's very

00:33:37,219 --> 00:33:41,690
same d60 for Strings hard coded into

00:33:39,589 --> 00:33:44,239
various thing there are rules that we've

00:33:41,690 --> 00:33:46,669
consumed for puzzles being a problem for

00:33:44,239 --> 00:33:49,009
folks working with a PowerPC the IBM

00:33:46,669 --> 00:33:52,249
we're hopefully gonna be using browser

00:33:49,009 --> 00:33:54,109
windows soon so this is an average

00:33:52,249 --> 00:33:56,029
onward developer who is not a Googler

00:33:54,109 --> 00:33:57,559
there's not an expert in basil they just

00:33:56,029 --> 00:34:00,529
want to debug the build when things go

00:33:57,559 --> 00:34:01,879
wrong they want to extend it in the same

00:34:00,529 --> 00:34:04,849
way that they would do a hack on make

00:34:01,879 --> 00:34:07,009
and so on very confused so while they're

00:34:04,849 --> 00:34:08,240
confused well error is like this this is

00:34:07,009 --> 00:34:11,119
kind of what you get when things go

00:34:08,240 --> 00:34:12,889
wrong in basil today the root cause for

00:34:11,119 --> 00:34:14,450
example is up there at the top what we

00:34:12,889 --> 00:34:16,250
actually is manifest and we see in our

00:34:14,450 --> 00:34:18,529
issues open and github is at the bottom

00:34:16,250 --> 00:34:20,929
there so I want to actually just wrap

00:34:18,529 --> 00:34:22,549
this up by again reiterating that basil

00:34:20,929 --> 00:34:24,020
is awesome sauce

00:34:22,549 --> 00:34:26,720
it is technologies for future when it

00:34:24,020 --> 00:34:28,970
and when it works and it does work most

00:34:26,720 --> 00:34:30,649
of the time we need to do things around

00:34:28,970 --> 00:34:33,619
the rough edges to make this better for

00:34:30,649 --> 00:34:35,659
the open source C++ community okay with

00:34:33,619 --> 00:34:38,929
that said um we're probably out of time

00:34:35,659 --> 00:34:40,760
for questions but um yeah I'd love to

00:34:38,929 --> 00:34:49,569
talk more about this at drinks or else

00:34:40,760 --> 00:34:53,029
we're at the conference thanks next as

00:34:49,569 --> 00:34:55,250
soon I saw is coming from PayPal and is

00:34:53,029 --> 00:35:05,720
going to present their home system

00:34:55,250 --> 00:35:08,510
and so yeah my name is Sheila from

00:35:05,720 --> 00:35:11,299
PayPal butene so sitting there teri

00:35:08,510 --> 00:35:14,539
program manager and coral project

00:35:11,299 --> 00:35:17,390
manager so you guys are lucky if you are

00:35:14,539 --> 00:35:19,940
able to migrate to Basel but that's not

00:35:17,390 --> 00:35:21,950
the case with us we have a 40 million

00:35:19,940 --> 00:35:23,150
lines of code in legacy super

00:35:21,950 --> 00:35:30,799
moscow-based

00:35:23,150 --> 00:35:33,349
back to 1999 so in 2014 we ran out of

00:35:30,799 --> 00:35:37,160
all the solutions to reduce the real

00:35:33,349 --> 00:35:39,380
time further so we have to the build

00:35:37,160 --> 00:35:41,660
time we have two types of builds so the

00:35:39,380 --> 00:35:45,770
phobia of the whole code base which

00:35:41,660 --> 00:35:49,329
consists of 900 rpms it took 30 minutes

00:35:45,770 --> 00:35:51,619
on a monster machine with 80 CPUs and

00:35:49,329 --> 00:35:54,559
developer built of individual

00:35:51,619 --> 00:35:59,240
applications on smaller machines took 45

00:35:54,559 --> 00:36:02,119
minutes so we have to redesign a new

00:35:59,240 --> 00:36:04,190
build system from ground up but we have

00:36:02,119 --> 00:36:06,770
the requirement we cannot change a

00:36:04,190 --> 00:36:08,809
single lie of the source codes we

00:36:06,770 --> 00:36:11,630
continue to support the existing bill

00:36:08,809 --> 00:36:13,849
definition language so we have a wrapper

00:36:11,630 --> 00:36:15,950
around the make file system so people

00:36:13,849 --> 00:36:17,869
don't maintain make files but they have

00:36:15,950 --> 00:36:20,480
to maintain that bill definition

00:36:17,869 --> 00:36:22,039
language so we continue to support that

00:36:20,480 --> 00:36:24,410
we have to so it's a drop-in replacement

00:36:22,039 --> 00:36:28,730
of the existing view system

00:36:24,410 --> 00:36:31,130
in 2015 we achieved the goal we release

00:36:28,730 --> 00:36:34,579
the new build system we brought down the

00:36:31,130 --> 00:36:38,270
Pugh time to be less than 5 minutes for

00:36:34,579 --> 00:36:41,660
all the big activities and one thing is

00:36:38,270 --> 00:36:44,510
the design was greatly influenced and

00:36:41,660 --> 00:36:47,270
inspired by Basel every not pace of

00:36:44,510 --> 00:36:50,299
place we went through a couple of

00:36:47,270 --> 00:36:53,299
articles published by Google in 2011 I

00:36:50,299 --> 00:36:57,049
think I rarely read them through like 50

00:36:53,299 --> 00:37:00,289
times yeah so it worked the whole design

00:36:57,049 --> 00:37:03,200
but it's it's very difficult for

00:37:00,289 --> 00:37:05,480
challenging for our code base and early

00:37:03,200 --> 00:37:08,390
this year we started piloting the

00:37:05,480 --> 00:37:11,359
distributed build so we have a solution

00:37:08,390 --> 00:37:14,329
bill on missiles and the distributed

00:37:11,359 --> 00:37:15,890
bill with now any incremental it's below

00:37:14,329 --> 00:37:18,680
10 minutes to build the whole codebase

00:37:15,890 --> 00:37:21,319
and my reason is just because some files

00:37:18,680 --> 00:37:23,809
took a minutes to compile so it's not

00:37:21,319 --> 00:37:28,609
about the parallelism it's just limited

00:37:23,809 --> 00:37:32,119
by some terrible files so we apply the

00:37:28,609 --> 00:37:34,990
same technology to to the functional

00:37:32,119 --> 00:37:36,609
tests written in moment SNG

00:37:34,990 --> 00:37:39,760
we don't like maven but we have to

00:37:36,609 --> 00:37:41,650
continue to support it and we brought

00:37:39,760 --> 00:37:47,530
down many functional tests from hours

00:37:41,650 --> 00:37:49,720
down to minutes so the main desire

00:37:47,530 --> 00:37:51,309
behind basil is all about rule level

00:37:49,720 --> 00:37:55,240
dependencies so you define with the

00:37:51,309 --> 00:37:57,430
rules but we our code base is a still

00:37:55,240 --> 00:38:00,250
make file oriented so everything is

00:37:57,430 --> 00:38:03,480
Fowler will depend dependencies so how

00:38:00,250 --> 00:38:06,670
do we convert file level to rule level

00:38:03,480 --> 00:38:09,099
one way is we can row sum we can write

00:38:06,670 --> 00:38:11,710
some to to convert them ones and then

00:38:09,099 --> 00:38:13,630
ask developers to maintain later but

00:38:11,710 --> 00:38:14,470
that's impossible for us with their 40

00:38:13,630 --> 00:38:17,559
million lines of code

00:38:14,470 --> 00:38:20,530
and also one time you wrote it to to try

00:38:17,559 --> 00:38:23,290
to make me CC library as the smallest

00:38:20,530 --> 00:38:25,420
unit that didn't work we ended up with

00:38:23,290 --> 00:38:28,030
libraries with circular dependencies

00:38:25,420 --> 00:38:30,609
which one needs held of far from each

00:38:28,030 --> 00:38:33,220
other or just logical library with a

00:38:30,609 --> 00:38:36,220
single head I found nothing else then we

00:38:33,220 --> 00:38:38,020
relax the the relation to the smallest

00:38:36,220 --> 00:38:40,660
unit in our system measuring stress

00:38:38,020 --> 00:38:43,540
object file it's not library and we

00:38:40,660 --> 00:38:45,460
convert all the root file with

00:38:43,540 --> 00:38:47,859
dependencies on the fly to rule our

00:38:45,460 --> 00:38:49,990
dependencies so this we continue to

00:38:47,859 --> 00:38:55,119
support everything existing but we

00:38:49,990 --> 00:38:58,480
convert them internally on the flag then

00:38:55,119 --> 00:39:01,059
this is a way the approach we did like I

00:38:58,480 --> 00:39:04,000
call it defer discovery of rule

00:39:01,059 --> 00:39:07,660
dependencies in most of the build

00:39:04,000 --> 00:39:10,230
systems today you have you pass the

00:39:07,660 --> 00:39:12,730
dependency then you have the tag and

00:39:10,230 --> 00:39:15,099
then you start the execution but in our

00:39:12,730 --> 00:39:16,750
case we cannot do there either it's too

00:39:15,099 --> 00:39:19,119
slow to have the whole day or it's

00:39:16,750 --> 00:39:21,579
impossible for some cases for example

00:39:19,119 --> 00:39:23,710
rule one it depends on the file then you

00:39:21,579 --> 00:39:25,480
ask the framework which Roo can give me

00:39:23,710 --> 00:39:28,240
their father then the framework will ask

00:39:25,480 --> 00:39:30,069
all the rules in pair path you need to

00:39:28,240 --> 00:39:33,040
tell me the exact list of your generated

00:39:30,069 --> 00:39:35,339
files then rule two is easy to tell it

00:39:33,040 --> 00:39:38,260
immediately knows a rule three needs

00:39:35,339 --> 00:39:40,839
actual execution to keep the list of the

00:39:38,260 --> 00:39:43,000
files so that's the main idea then

00:39:40,839 --> 00:39:46,839
content based incremental bear similar

00:39:43,000 --> 00:39:48,380
to Google's design and like meta system

00:39:46,839 --> 00:39:51,740
to metadata system to Main

00:39:48,380 --> 00:39:54,880
action has artifact storage then share

00:39:51,740 --> 00:39:57,529
across all users develop abuse CI bills

00:39:54,880 --> 00:39:59,720
then distribute appeal we are piloting

00:39:57,529 --> 00:40:03,960
that and it's a it's a working solution

00:39:59,720 --> 00:40:08,650
naturally yeah then I think that's it

00:40:03,960 --> 00:40:14,750
[Applause]

00:40:08,650 --> 00:40:16,549
next it's all last talk by Oscar by Kane

00:40:14,750 --> 00:40:19,819
so I don't need to reintroduce you

00:40:16,549 --> 00:40:23,619
because you're it's going to talk about

00:40:19,819 --> 00:40:27,710
to purpose or II asked to improve result

00:40:23,619 --> 00:40:29,059
yeah so um I don't know if I have to you

00:40:27,710 --> 00:40:31,579
know hold this think of them based

00:40:29,059 --> 00:40:33,619
around um does anyone here use a

00:40:31,579 --> 00:40:35,809
programming language you really like it

00:40:33,619 --> 00:40:38,029
isn't currently supported by basil like

00:40:35,809 --> 00:40:39,319
you know a raise your hand if you like

00:40:38,029 --> 00:40:41,750
like some programming language there

00:40:39,319 --> 00:40:43,250
isn't word about basil just like a

00:40:41,750 --> 00:40:45,319
couple of people so we're like weirdos

00:40:43,250 --> 00:40:47,690
maybe you like Haskell or you know you

00:40:45,319 --> 00:40:49,970
want you know I don't know like Erlang

00:40:47,690 --> 00:40:54,230
or something but if you go to try to

00:40:49,970 --> 00:40:56,269
implement rules for for Basel III worked

00:40:54,230 --> 00:40:57,500
on this with Scala you find it's pretty

00:40:56,269 --> 00:40:59,660
painful so I'm gonna talk about two

00:40:57,500 --> 00:41:00,980
things that like I I think it would

00:40:59,660 --> 00:41:02,809
really help I would really like to see

00:41:00,980 --> 00:41:06,019
at it so the main thing is it's really

00:41:02,809 --> 00:41:08,059
hard to add compiler rules so here's the

00:41:06,019 --> 00:41:09,619
thing to get reasonable performance you

00:41:08,059 --> 00:41:11,180
need this somewhat C like model I

00:41:09,619 --> 00:41:13,099
alluded to this earlier that you have

00:41:11,180 --> 00:41:15,200
some separation between an interface and

00:41:13,099 --> 00:41:17,269
like generated code most languages

00:41:15,200 --> 00:41:18,470
actually don't have that like Python

00:41:17,269 --> 00:41:19,700
doesn't have that if you think about it

00:41:18,470 --> 00:41:21,529
like just certain like almost no

00:41:19,700 --> 00:41:23,240
language has except other than C so I

00:41:21,529 --> 00:41:25,130
guess they had make and everything and C

00:41:23,240 --> 00:41:27,049
had this property and they were like oh

00:41:25,130 --> 00:41:29,599
everything will just have this property

00:41:27,049 --> 00:41:32,990
it's not actually true so if you work

00:41:29,599 --> 00:41:35,329
around this like say in Java like you

00:41:32,990 --> 00:41:35,750
know kind of like maybe you can make it

00:41:35,329 --> 00:41:38,329
work

00:41:35,750 --> 00:41:39,980
uh if you've got a jar sitting around

00:41:38,329 --> 00:41:42,470
it's like this tool I mentioned earlier

00:41:39,980 --> 00:41:44,150
but if you go to try to use it like for

00:41:42,470 --> 00:41:45,799
instance there's some haskell like

00:41:44,150 --> 00:41:50,089
programming language of the JVM called

00:41:45,799 --> 00:41:51,829
Frigga from Frigga some magician it

00:41:50,089 --> 00:41:53,089
compiles to Java so I'm like oh

00:41:51,829 --> 00:41:54,859
shouldn't be that hard it's important

00:41:53,089 --> 00:41:56,630
Bayes also just whip it up and so

00:41:54,859 --> 00:41:58,069
actually though like for like in

00:41:56,630 --> 00:41:59,660
different reasons this became extremely

00:41:58,069 --> 00:42:01,640
hard and it like totally sucks

00:41:59,660 --> 00:42:03,440
so like Basil's answer

00:42:01,640 --> 00:42:05,150
- this are like oh no problem just like

00:42:03,440 --> 00:42:06,920
get the compiler author to change the

00:42:05,150 --> 00:42:08,539
way it works which the by the father

00:42:06,920 --> 00:42:10,299
doesn't care about bees also they like

00:42:08,539 --> 00:42:13,430
screw you not gonna do it

00:42:10,299 --> 00:42:15,559
option 2 is build a new eye jar like

00:42:13,430 --> 00:42:17,210
yeah ok like no problem again like this

00:42:15,559 --> 00:42:18,529
is like a huge amount of effort to build

00:42:17,210 --> 00:42:20,329
something that works as well as that

00:42:18,529 --> 00:42:23,239
like that's not such a great answer and

00:42:20,329 --> 00:42:25,160
that's still fooling the compiler so so

00:42:23,239 --> 00:42:26,630
the the a jar trick is to fool the

00:42:25,160 --> 00:42:28,609
compiler into like I'll give you

00:42:26,630 --> 00:42:30,680
something other than like binary code

00:42:28,609 --> 00:42:32,960
but somehow when the compiler reads it

00:42:30,680 --> 00:42:34,640
it thinks it is binary code and somehow

00:42:32,960 --> 00:42:37,099
it doesn't trip over the fact that there

00:42:34,640 --> 00:42:38,390
is no binary there so Java happens to be

00:42:37,099 --> 00:42:39,589
full of all in this way a lot of

00:42:38,390 --> 00:42:42,259
compilers are not going to be full of

00:42:39,589 --> 00:42:43,640
all in that way or the last answer is

00:42:42,259 --> 00:42:45,529
you just live with transmits transitive

00:42:43,640 --> 00:42:47,390
rebuilt you make some private change to

00:42:45,529 --> 00:42:48,980
a comment some random file and then like

00:42:47,390 --> 00:42:51,109
no problem it just like recompile your

00:42:48,980 --> 00:42:52,970
graph like that's really really sad so

00:42:51,109 --> 00:42:54,799
what I would really like to see which

00:42:52,970 --> 00:42:56,779
buck already has so like I don't know if

00:42:54,799 --> 00:42:59,210
I competition like gets people upset or

00:42:56,779 --> 00:43:01,339
something is the ability to configure

00:42:59,210 --> 00:43:03,890
the rule key so what I want to be able

00:43:01,339 --> 00:43:05,869
to say is in my rule and my skylark rule

00:43:03,890 --> 00:43:08,059
is is ok here's how you compile Scala I

00:43:05,869 --> 00:43:10,009
want to be able to say ok by default we

00:43:08,059 --> 00:43:12,470
leave it the way it is sha-256 the

00:43:10,009 --> 00:43:15,049
artifact or whatever but I want to be

00:43:12,470 --> 00:43:18,769
able to say here is an object which is a

00:43:15,049 --> 00:43:21,680
key object for this object code and then

00:43:18,769 --> 00:43:23,960
basil is free to give me any object code

00:43:21,680 --> 00:43:26,869
which has the exact same key value if

00:43:23,960 --> 00:43:29,210
this existed I could use this SBT tool

00:43:26,869 --> 00:43:31,910
that already has this notion of

00:43:29,210 --> 00:43:33,920
extracting an API for Scala though it

00:43:31,910 --> 00:43:36,170
cannot compile against it it can extract

00:43:33,920 --> 00:43:37,609
it I could just plug that in boom I can

00:43:36,170 --> 00:43:39,920
get like really awesome rebuilds it

00:43:37,609 --> 00:43:41,239
would be amazing buck has it let's do

00:43:39,920 --> 00:43:44,539
that that would be amazing

00:43:41,239 --> 00:43:46,369
ok problem 2 as I mentioned before is

00:43:44,539 --> 00:43:47,930
that I love languages the smoke so

00:43:46,369 --> 00:43:50,779
compilers this really sucks

00:43:47,930 --> 00:43:53,269
basil wants a static graph for a lot of

00:43:50,779 --> 00:43:56,269
reasons for instance basil the query

00:43:53,269 --> 00:43:57,890
which is like pretty awesome so what do

00:43:56,269 --> 00:43:59,809
i you want to do about this so what I

00:43:57,890 --> 00:44:01,249
want is something like this I would love

00:43:59,809 --> 00:44:03,680
for this if you're interested in like

00:44:01,249 --> 00:44:05,150
C++ pretty slow compiler rust pretty

00:44:03,680 --> 00:44:06,890
slow compiler Haskell pretty slow

00:44:05,150 --> 00:44:08,749
compiler what I want to be able to do is

00:44:06,890 --> 00:44:11,749
declare my inputs and outputs I depend

00:44:08,749 --> 00:44:13,970
on these libraries these sources and I'm

00:44:11,749 --> 00:44:15,250
going to produce this library output but

00:44:13,970 --> 00:44:17,140
I want to rule too

00:44:15,250 --> 00:44:19,630
be able to dynamically after running

00:44:17,140 --> 00:44:21,940
inspecting the sources produce more

00:44:19,630 --> 00:44:23,800
transit more of a little hidden black

00:44:21,940 --> 00:44:25,720
box note inside the basal could

00:44:23,800 --> 00:44:26,890
understand the depths for if basil could

00:44:25,720 --> 00:44:28,810
understand the depths for it could

00:44:26,890 --> 00:44:30,730
managed the caching there and I wouldn't

00:44:28,810 --> 00:44:32,200
get a benefit like basil could give me

00:44:30,730 --> 00:44:34,540
the whole benefit that I get for other

00:44:32,200 --> 00:44:35,740
build tools that know about this if we

00:44:34,540 --> 00:44:37,270
could add this we can kind of get the

00:44:35,740 --> 00:44:39,190
best of both worlds of like a fairly

00:44:37,270 --> 00:44:42,190
static graph that we could query but

00:44:39,190 --> 00:44:44,950
also basil earning like like sub target

00:44:42,190 --> 00:44:46,990
like you know like sub module notions of

00:44:44,950 --> 00:44:48,910
a graph that would be awesome so those

00:44:46,990 --> 00:44:49,930
are my two like proposals I would love

00:44:48,910 --> 00:44:52,060
to like work with anybody who's

00:44:49,930 --> 00:44:54,100
interested in this on maybe some design

00:44:52,060 --> 00:44:56,620
Doc's and if like maybe we can work

00:44:54,100 --> 00:44:58,090
together for some PRS or maybe just the

00:44:56,620 --> 00:44:59,950
Google the Google Erzebet cat that's

00:44:58,090 --> 00:45:02,700
awesome I'll just do that next week and

00:44:59,950 --> 00:45:02,700

YouTube URL: https://www.youtube.com/watch?v=jzNWH2o6XXw


