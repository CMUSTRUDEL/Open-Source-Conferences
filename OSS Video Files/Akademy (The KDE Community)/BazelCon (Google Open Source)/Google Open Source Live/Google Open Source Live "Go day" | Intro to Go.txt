Title: Google Open Source Live "Go day" | Intro to Go
Publication date: 2021-01-27
Playlist: Google Open Source Live
Description: 
	
Captions: 
	00:00:10,400 --> 00:00:12,640
Hello and welcome to Google Open-Source Live.

00:00:12,640 --> 00:00:14,160
We're excited to have you here

00:00:14,160 --> 00:00:16,320
and share a few things with you about Go.

00:00:18,240 --> 00:00:20,880
I'm Matt, and I'll be talking a bit about Go as a language

00:00:20,880 --> 00:00:25,120
and why it's a great fit to build fast, reliable, and efficient software at scale.

00:00:25,120 --> 00:00:26,800
Then, my colleagues Steve and Carmen

00:00:26,800 --> 00:00:29,760
will cover the most common use cases for the language.

00:00:29,760 --> 00:00:30,640
So, let's get started.

00:00:32,080 --> 00:00:33,360
So, why choose Go?

00:00:33,920 --> 00:00:36,960
Let's start with the basics, covering the foundation of a language

00:00:36,960 --> 00:00:39,680
and give you an idea of what to expect when using Go.

00:00:41,280 --> 00:00:44,880
At a high level, Go is designed to be simple and reliable

00:00:44,880 --> 00:00:46,480
in the era of multicore computing.

00:00:47,120 --> 00:00:49,280
It's easy to learn and get started with

00:00:49,280 --> 00:00:52,560
with many developers becoming productive in just a few days

00:00:52,560 --> 00:00:53,760
and sometimes even hours.

00:00:55,200 --> 00:00:57,280
Go is also a cloud-native language

00:00:57,280 --> 00:00:58,640
designed to operate at scale.

00:00:59,200 --> 00:01:01,440
It was built with micro services in mind

00:01:01,440 --> 00:01:04,000
and its standard library and performing design

00:01:04,000 --> 00:01:06,560
make it perfect for large distributed systems.

00:01:08,080 --> 00:01:10,160
And Go has a thriving ecosystem

00:01:10,160 --> 00:01:12,720
with a growing set of partners, communities, and tools.

00:01:13,280 --> 00:01:15,840
Gophers around the world are constantly adding new packages

00:01:16,400 --> 00:01:18,320
organizing events to share knowledge

00:01:18,320 --> 00:01:20,400
or contributing to the core language.

00:01:20,400 --> 00:01:23,680
And if you are new to Go, chances are there's a gopher out there

00:01:23,680 --> 00:01:26,160
ready and waiting to answer your questions.

00:01:26,160 --> 00:01:30,480
These three pillars of Go, simplicity, scalability, and community

00:01:30,480 --> 00:01:32,160
make working with Go a great experience.

00:01:32,720 --> 00:01:35,440
So, let's take a moment to talk a bit more about the language itself.

00:01:36,960 --> 00:01:38,320
So, what makes Go great?

00:01:38,880 --> 00:01:43,760
As a language, Go is everything you need right out of the box or binary.

00:01:43,760 --> 00:01:46,400
And that starts with its robust standard library.

00:01:47,920 --> 00:01:50,880
Go standard library is incredibly comprehensive

00:01:50,880 --> 00:01:52,160
and of excellent quality.

00:01:52,720 --> 00:01:57,040
It's extensible and includes packages that cover the basics of almost any project.

00:01:57,920 --> 00:01:59,520
For building web servers

00:01:59,520 --> 00:02:02,480
with Go's built-in high-performance HTTP package

00:02:02,480 --> 00:02:04,880
to handling files and other programs

00:02:04,880 --> 00:02:07,200
to managing encryption with the crypto package.

00:02:07,760 --> 00:02:09,040
For whatever you're building

00:02:09,040 --> 00:02:12,080
chances are there's a package or two in the standard library that will help.

00:02:13,440 --> 00:02:18,080
Go also helps keep things maintainable with automatic formatting and documentation.

00:02:18,080 --> 00:02:21,920
And this is an addition to Go syntax that focuses on readability.

00:02:21,920 --> 00:02:24,720
Many projects are built solely relying on the standard library

00:02:24,720 --> 00:02:26,800
without having to look elsewhere for support.

00:02:26,800 --> 00:02:28,880
And while the standard library is expensive

00:02:28,880 --> 00:02:30,160
if your needs aren't met there

00:02:30,160 --> 00:02:32,160
there's definitely a solution in the ecosystem.

00:02:34,640 --> 00:02:36,240
Now let's talk about building with Go.

00:02:36,960 --> 00:02:38,000
Building with Go is easy.

00:02:38,640 --> 00:02:40,080
When working with a language

00:02:40,080 --> 00:02:45,360
every Go program compiles to a single binary including any system code required to run it

00:02:45,360 --> 00:02:48,640
which keeps things simple as projects progress in complexity.

00:02:49,360 --> 00:02:50,720
And as they progress

00:02:50,720 --> 00:02:53,040
you can leverage Go's built-in concurrency mechanisms

00:02:53,040 --> 00:02:54,080
or Go routines

00:02:54,080 --> 00:02:56,800
which make it really simple to build concurrent programs

00:02:56,800 --> 00:02:59,600
all while taking advantage of Go's fantastic memory

00:02:59,600 --> 00:03:02,400
CPU management, and instant startup times.

00:03:03,120 --> 00:03:05,840
Additionally, Go's dependency management

00:03:05,840 --> 00:03:07,520
is tightly integrated and seamless

00:03:08,240 --> 00:03:12,080
with modules which we'll cover a bit more in detail later today.

00:03:12,080 --> 00:03:14,880
Go helps you keep packages secure and compatible

00:03:14,880 --> 00:03:17,440
helping you avoid the diamond dependency problem

00:03:17,440 --> 00:03:18,400
and dependency hell.

00:03:20,240 --> 00:03:23,360
And to top it off, Go is supported by the Go team at Google

00:03:23,360 --> 00:03:26,080
who work every day to continue to improve the Go experience.

00:03:28,240 --> 00:03:30,240
From leading our biannual release process

00:03:30,960 --> 00:03:33,040
to directly triaging security reports

00:03:33,680 --> 00:03:36,400
to working collaboratively with the contributor community

00:03:36,400 --> 00:03:39,360
to ensure feedback is front and center of the development process.

00:03:39,920 --> 00:03:43,120
And their work leads to great results for all Go users.

00:03:43,120 --> 00:03:46,000
Just recently, in the latest release of Go 1.15

00:03:46,000 --> 00:03:49,520
we saw a sample of Go programs compile around 20% faster

00:03:49,520 --> 00:03:53,120
and take around 30% less memory on average for all projects

00:03:53,120 --> 00:03:56,320
but especially large, distributed projects built in Go.

00:03:56,320 --> 00:03:58,800
That can lead to a solid reduction in compute cost.

00:03:59,360 --> 00:04:02,560
And this is just one example of many changes the teams worked on

00:04:02,560 --> 00:04:04,640
and will continue to work on with the community's help.

00:04:05,280 --> 00:04:07,440
This kind of performance increase

00:04:08,480 --> 00:04:09,840
fifteen versions in

00:04:09,840 --> 00:04:13,920
is what the team aims for with every major release.

00:04:13,920 --> 00:04:16,240
And as we continue to improve the functionality

00:04:16,240 --> 00:04:18,320
performance, and productivity of Go

00:04:18,320 --> 00:04:20,400
we make sure that every Go program

00:04:20,400 --> 00:04:22,960
written since the original release of Go 1.0

00:04:22,960 --> 00:04:25,600
will compile with newer versions up to our latest release.

00:04:26,240 --> 00:04:28,560
This is our 1.0 compatibility promise.

00:04:28,560 --> 00:04:29,520
It's awesome.

00:04:29,520 --> 00:04:31,680
And it's part of what makes Go so easy to maintain.

00:04:33,920 --> 00:04:36,800
So, let's take a step back and look at the ecosystem

00:04:36,800 --> 00:04:42,080
which continues to grow with more developers using Go every day.

00:04:42,080 --> 00:04:43,680
Just to get a quick sense

00:04:43,680 --> 00:04:47,920
we took a look at growth in pull requests of Go programs on GitHub.

00:04:47,920 --> 00:04:50,880
Over the last five years that amount has nearly tripled.

00:04:50,880 --> 00:04:52,000
And it continues to grow.

00:04:53,440 --> 00:04:58,720
Additionally, several surveys cite Go as the number one language in several areas.

00:04:58,720 --> 00:05:01,520
Go shows up as the top language that developers want to learn

00:05:02,080 --> 00:05:03,360
and also is the top language

00:05:03,360 --> 00:05:06,160
that developer teams are looking to adopt or migrate to.

00:05:06,800 --> 00:05:09,440
Go also shows up as the highest-paying language

00:05:09,440 --> 00:05:11,920
and the language with the most demand for employers.

00:05:11,920 --> 00:05:15,040
And this comes as more companies are increasingly seeking Go developers.

00:05:15,680 --> 00:05:18,720
In short, it's a great time to be a Go developer

00:05:18,720 --> 00:05:20,400
and a great time to start building with Go.

00:05:22,160 --> 00:05:24,160
And when it comes to building with Go

00:05:24,160 --> 00:05:26,000
many companies around the world use Go

00:05:26,000 --> 00:05:28,800
and they're often sharing their insights with the community.

00:05:28,800 --> 00:05:32,560
PayPal, Facebook, Microsoft, Mercado Libre, Netflix

00:05:32,560 --> 00:05:34,800
and many more companies are using Go.

00:05:35,440 --> 00:05:39,440
A great example, which you'll hear much more about later today, is Khan Academy

00:05:39,440 --> 00:05:42,480
who began migrating their infrastructure from Python to Go

00:05:42,480 --> 00:05:44,960
and have already begun to see the benefits of doing so.

00:05:45,840 --> 00:05:47,920
And of course, we use Go here at Google

00:05:49,040 --> 00:05:51,760
from the web indexing pipeline that powers Google Search

00:05:51,760 --> 00:05:54,000
to the backend of firebase hosting

00:05:54,000 --> 00:05:56,240
which powers thousands of websites around the world.

00:05:57,280 --> 00:06:00,800
We also use Go on teams like Chrome, messaging, and many more.

00:06:01,440 --> 00:06:03,280
And in line with companies using Go

00:06:03,280 --> 00:06:06,960
we're seeing folks choose Go to build software in the cloud.

00:06:07,920 --> 00:06:11,760
And the three pillars of Go, simplicity, scalability, and community

00:06:11,760 --> 00:06:14,240
are the reasons why many of these companies keep choosing Go.

00:06:15,520 --> 00:06:17,440
If you want to learn a bit more about who's using Go

00:06:17,440 --> 00:06:19,200
or how to get started with the language

00:06:19,200 --> 00:06:20,320
you can visit Go.dev.

00:06:22,400 --> 00:06:24,480
Finally, I wanted to touch on the community

00:06:24,480 --> 00:06:27,120
which in many ways is the beating heart of Go.

00:06:27,120 --> 00:06:30,000
The community is what keeps gophers active, connected

00:06:30,000 --> 00:06:32,240
and up to date on the latest changes with Go

00:06:32,240 --> 00:06:34,320
and related tooling and support.

00:06:34,320 --> 00:06:37,120
The community also actively contributes to Go releases

00:06:37,840 --> 00:06:40,960
helping the Go team at Google make the best decisions for the ecosystem.

00:06:43,280 --> 00:06:44,800
To get a sense of scale

00:06:44,800 --> 00:06:48,800
today the gopher community has grown to reach over 180 groups

00:06:48,800 --> 00:06:50,560
in nearly 50 countries.

00:06:50,560 --> 00:06:52,960
These groups host events almost every week

00:06:52,960 --> 00:06:54,480
and are now doing so virtually.

00:06:55,760 --> 00:06:59,120
Over the last year, there have also been 32 conferences.

00:06:59,120 --> 00:07:01,360
One conference is taking place very soon.

00:07:01,360 --> 00:07:04,400
Just next week, many gophers will be attending GopherCon

00:07:04,400 --> 00:07:06,480
in a new all-virtual experience.

00:07:07,520 --> 00:07:08,720
The gopher community

00:07:08,720 --> 00:07:12,320
whether it be meet-ups, listers, or smaller groups of developers

00:07:12,320 --> 00:07:14,720
are all enthusiastic and inspiring.

00:07:14,720 --> 00:07:17,040
Joining one is a great way to meet other developers

00:07:17,040 --> 00:07:19,920
jump into Go, and share your knowledge with others.

00:07:19,920 --> 00:07:21,360
The swag is pretty cool too.

00:07:23,040 --> 00:07:25,440
So, I've talked a bit about what makes Go great

00:07:25,440 --> 00:07:26,960
where the language is heading

00:07:26,960 --> 00:07:30,800
and who is using Go, ranging from individual devs to enterprises.

00:07:30,800 --> 00:07:32,560
I also touched on the community

00:07:32,560 --> 00:07:35,120
and how gophers around the world stay connected and informed.

00:07:35,920 --> 00:07:39,360
Hopefully, this has helped you to answer the question, "Why Go?"

00:07:39,360 --> 00:07:42,640
But to take it one step further, my colleagues Steve and Carmen

00:07:42,640 --> 00:07:45,120
are going to cover the top four use cases for the language.

00:07:46,640 --> 00:07:51,360
These are Command Line Applications, APIs, Web Apps, and Dev Ops.

00:07:52,160 --> 00:07:53,040
So, take it away!

00:07:54,400 --> 00:07:57,840
Go is a great fit for Command Line or CLI applications.

00:07:58,400 --> 00:08:01,360
Over the past decade these have made a huge comeback

00:08:01,360 --> 00:08:05,280
and firmly have a place alongside server, web, desktop, and mobile apps.

00:08:06,960 --> 00:08:10,800
With CLI applications there are a few factors that are really important.

00:08:10,800 --> 00:08:14,240
You want the application to seamlessly work cross-platform.

00:08:14,240 --> 00:08:16,160
You want the application to load instantly.

00:08:16,800 --> 00:08:20,320
You want it to be easily installed and updated without local dependencies.

00:08:21,040 --> 00:08:23,120
You want the app to have good performance

00:08:23,120 --> 00:08:26,400
and you want it to be easy to write an app with good usability.

00:08:27,760 --> 00:08:29,200
Go checks every box.

00:08:30,880 --> 00:08:32,320
Go natively supports

00:08:32,320 --> 00:08:35,680
every modern operating system and architecture

00:08:35,680 --> 00:08:36,880
and many legacy ones.

00:08:38,320 --> 00:08:44,320
Go makes it trivial to build Windows, Mac, Linux, etc. versions

00:08:44,320 --> 00:08:47,600
for various architectures right from your development machine.

00:08:48,720 --> 00:08:51,440
Most applications build around one second.

00:08:51,440 --> 00:08:55,120
For anyone who's used C or C++-based applications

00:08:55,120 --> 00:08:56,960
this is unbelievably simple.

00:08:58,960 --> 00:09:01,840
Go applications have zero dependencies on the host.

00:09:01,840 --> 00:09:04,160
There is no fighting with incompatible libraries

00:09:04,160 --> 00:09:05,680
or runtime versions

00:09:05,680 --> 00:09:07,840
and no runtimes or interpreters to install.

00:09:08,560 --> 00:09:10,080
Once the application is built

00:09:10,080 --> 00:09:13,760
installing it is as simple as copying a single file to another machine.

00:09:13,760 --> 00:09:17,600
It just works, compared to Java, JavaScript, Python, Ruby

00:09:17,600 --> 00:09:19,600
and even C-based applications.

00:09:19,600 --> 00:09:20,880
This is incredibly smooth.

00:09:21,600 --> 00:09:23,440
Upgrading is just as easy.

00:09:23,440 --> 00:09:25,920
Simply replace the old file with the new one.

00:09:25,920 --> 00:09:27,040
It's a single file.

00:09:27,040 --> 00:09:28,400
What could be easier than that?

00:09:29,920 --> 00:09:33,120
Applications written in Go benefit from instant startup times

00:09:33,120 --> 00:09:34,720
and fast performance.

00:09:34,720 --> 00:09:38,240
Unlike Java, JavaScript, Python, Ruby, etc.

00:09:38,240 --> 00:09:41,280
there is no need to load up a virtual machine or interpreter

00:09:41,280 --> 00:09:43,040
so they are able to start instantly.

00:09:43,760 --> 00:09:45,360
Go's performance and concurrency

00:09:45,360 --> 00:09:48,480
take full advantage of modern multicore processors

00:09:48,480 --> 00:09:51,520
to easily write applications with great performance.

00:09:51,520 --> 00:09:52,720
Are you sold yet?

00:09:52,720 --> 00:09:53,760
But wait. There's more.

00:09:55,040 --> 00:09:59,040
There's a robust ecosystem built around Go CLI applications.

00:09:59,040 --> 00:10:02,400
Go.dev lists popular libraries and books to get you started.

00:10:03,760 --> 00:10:07,920
Learn.go.dev also has a workshop on building CLIs in Go.

00:10:09,040 --> 00:10:11,920
The most popular CLI library is Cobra

00:10:11,920 --> 00:10:15,920
which includes a generator that effectively builds your application for you

00:10:15,920 --> 00:10:20,400
using intuitive design patterns including subcommand parameters and flags.

00:10:20,400 --> 00:10:24,160
It also automatically generates help, autocompletion, and documentation.

00:10:25,920 --> 00:10:29,600
When GitHub wanted to build a new CLI, they chose Cobra and Go

00:10:29,600 --> 00:10:31,920
and the response has been fantastic.

00:10:31,920 --> 00:10:34,240
They joined thousands of companies and projects

00:10:34,240 --> 00:10:36,240
who have built CLI apps in Go.

00:10:37,760 --> 00:10:40,640
To understand why Go is good for DevOps

00:10:40,640 --> 00:10:42,160
I find this quote works well.

00:10:43,200 --> 00:10:45,840
Go is not designed to be an academic language.

00:10:46,400 --> 00:10:48,960
It was meant for large production systems

00:10:49,600 --> 00:10:52,480
to quickly onboard many inexperienced engineers

00:10:52,480 --> 00:10:53,280
to a code base

00:10:53,920 --> 00:10:57,120
providing continuity across the software lifecycle

00:10:57,120 --> 00:11:00,320
from development, to production, to maintenance.

00:11:00,320 --> 00:11:03,040
This is the essence of the DevOps movement

00:11:03,040 --> 00:11:06,000
and the adoption of site reliability engineering at Google.

00:11:09,040 --> 00:11:10,160
Before going further

00:11:10,160 --> 00:11:13,600
I'd like to briefly talk about site reliability engineering

00:11:13,600 --> 00:11:15,120
also called SRE

00:11:15,120 --> 00:11:15,840
and DevOps.

00:11:16,560 --> 00:11:17,440
What's the difference?

00:11:20,320 --> 00:11:23,360
DevOps and SRE are two trending disciplines

00:11:23,360 --> 00:11:24,720
with quite a bit of overlap.

00:11:25,360 --> 00:11:29,440
In the past, some have called SRE a competing set of practices

00:11:30,080 --> 00:11:32,720
but it's not so different from DevOps.

00:11:32,720 --> 00:11:35,200
To read more, visit the link at the bottom.

00:11:36,320 --> 00:11:40,960
The key thing is DevOps and SRE are both organizational practices.

00:11:41,680 --> 00:11:45,760
Go was designed to simplify practices around developing software

00:11:45,760 --> 00:11:47,280
for the entire lifecycle.

00:11:47,840 --> 00:11:52,400
Given similar philosophies and goals, Go is clearly a match for DevOps.

00:11:55,120 --> 00:11:58,480
Let's go over nine reasons why Go is good for DevOps and SRE.

00:11:59,040 --> 00:12:02,080
Mentioned interchangeably are all the practitioners

00:12:02,080 --> 00:12:03,920
which include software engineers

00:12:03,920 --> 00:12:07,360
site reliability engineers, systems administrators

00:12:07,360 --> 00:12:09,840
operations engineers, and production engineers.

00:12:12,000 --> 00:12:14,960
As mentioned before, Go is made to be readable

00:12:14,960 --> 00:12:18,160
designed for onboarding programmers to teams quickly.

00:12:18,160 --> 00:12:21,760
It strikes a good balance between expressiveness and brevity.

00:12:22,880 --> 00:12:26,320
Even error-handling, an oft-critiqued aspect of the language

00:12:26,320 --> 00:12:28,160
has benefits of this explicitness.

00:12:28,880 --> 00:12:31,040
It's particularly for when those errors

00:12:31,040 --> 00:12:34,000
hit programs running in large production systems.

00:12:36,480 --> 00:12:38,880
A small but strong standard library.

00:12:39,840 --> 00:12:43,120
A smaller footprint makes it easy for learning, developing

00:12:43,120 --> 00:12:48,080
and maintaining software across the stack and lifecycle

00:12:48,080 --> 00:12:51,840
without getting bogged down in choice.

00:12:53,520 --> 00:12:58,480
As mentioned in the talk on CLIs, Go has minimal runtime dependencies.

00:12:58,480 --> 00:13:02,160
If you're a systems administrator, operations or production engineer

00:13:02,160 --> 00:13:03,520
you don't need to worry

00:13:03,520 --> 00:13:07,600
as all runtime libraries are included in the compiled executable

00:13:08,480 --> 00:13:09,840
so you can distribute your app

00:13:09,840 --> 00:13:12,720
the way you would any other statically linked binary.

00:13:15,360 --> 00:13:17,600
Speaking of binaries, you don't need to worry

00:13:17,600 --> 00:13:20,880
about what version of Go is installed on your systems

00:13:20,880 --> 00:13:24,160
or even if it is installed in your systems at all if you're in ops.

00:13:24,880 --> 00:13:28,480
This makes it easy for doing migrations, upgrades, and deploys.

00:13:29,840 --> 00:13:33,840
It's great for these types of operation tasks.

00:13:35,120 --> 00:13:39,040
Also, if you're an ops, you'll often run into the chicken-egg problem

00:13:39,040 --> 00:13:41,840
needing dependencies installed before running tools

00:13:41,840 --> 00:13:44,240
or scripts for your infrastructure, where your app lives.

00:13:44,880 --> 00:13:46,960
Go is great for this bootstrap tooling

00:13:46,960 --> 00:13:49,680
where you don't yet have your dependencies installed.

00:13:51,920 --> 00:13:53,600
Garbage collection built-in

00:13:53,600 --> 00:13:55,600
means that operators don't have to be burdened

00:13:55,600 --> 00:13:57,520
with memory management

00:13:57,520 --> 00:14:01,840
making Go both easier to use and more reliable.

00:14:03,760 --> 00:14:06,640
Easy concurrency support via Goroutines.

00:14:07,200 --> 00:14:09,680
This is a first-class feature of Go

00:14:09,680 --> 00:14:13,120
and vastly simplifies distributed systems operations.

00:14:13,760 --> 00:14:16,560
Codebases today are becoming larger and larger

00:14:16,560 --> 00:14:18,480
with huge amounts of concurrency

00:14:18,480 --> 00:14:21,680
due to networking requirements that didn't exist 20 years ago.

00:14:22,640 --> 00:14:27,200
Go is the right balance of trade-offs needed to solve modern productivity issues.

00:14:27,760 --> 00:14:31,360
It's the modern-day bottleneck for running distributed systems

00:14:31,360 --> 00:14:33,760
which isn't performance, it's human cognition.

00:14:34,560 --> 00:14:37,040
Go addresses this human cognition issue

00:14:37,040 --> 00:14:39,280
without sacrificing performance.

00:14:39,280 --> 00:14:43,840
Go is also more explicit and better "glue" than shell languages.

00:14:43,840 --> 00:14:46,320
Glue refers to those connector bits of code

00:14:46,320 --> 00:14:48,160
you write to put your system together.

00:14:49,040 --> 00:14:51,760
The lack of data types in Bash or PowerShell

00:14:51,760 --> 00:14:53,840
start to come apart after 100 lines.

00:14:54,720 --> 00:14:57,840
For articulating more complex scripts for your infrastructure

00:14:58,400 --> 00:15:00,640
you'll need something strongly typed.

00:15:00,640 --> 00:15:01,200
Use Go.

00:15:03,840 --> 00:15:07,280
And finally, Go is still very performant

00:15:07,280 --> 00:15:08,640
particularly at scale.

00:15:11,440 --> 00:15:14,800
To finish off, there's a saying that software is never done.

00:15:15,360 --> 00:15:19,120
This is equally true for development and production and maintenance.

00:15:19,680 --> 00:15:22,720
Use Go for the entire software lifecycle

00:15:22,720 --> 00:15:25,440
and implement DevOps practices into your organization

00:15:25,440 --> 00:15:28,000
to improve your system and your business.

00:15:30,080 --> 00:15:31,760
Developers love using Go.

00:15:32,560 --> 00:15:35,520
Ninety percent of developers prefer to use it for the next project.

00:15:36,080 --> 00:15:38,400
Web applications are one of the most popular things

00:15:38,400 --> 00:15:40,080
developers build in Go.

00:15:40,080 --> 00:15:42,880
With half of Go developers using it for web apps

00:15:42,880 --> 00:15:46,240
Go's concurrency, speed, and excellent library support

00:15:46,240 --> 00:15:49,280
make an ideal environment for today's web applications.

00:15:50,080 --> 00:15:51,600
Today I'm going to introduce you

00:15:51,600 --> 00:15:55,200
to Go's cloud support, database support, web security

00:15:55,200 --> 00:15:57,200
web frameworks, and learning resources.

00:15:58,160 --> 00:16:01,520
As is common today, many web apps are hosted in the cloud.

00:16:01,520 --> 00:16:04,720
Go has first-tier support on all major cloud platforms

00:16:04,720 --> 00:16:08,240
including Google Cloud, Amazon, Azure, and AliCloud.

00:16:08,800 --> 00:16:12,400
This includes serverless offerings like Google's App Engine and Cloud Run

00:16:12,400 --> 00:16:13,520
and Amazon's Lambda.

00:16:14,160 --> 00:16:17,520
And as you'd expect, Go has great support for databases.

00:16:17,520 --> 00:16:18,800
From relational databases

00:16:18,800 --> 00:16:21,520
to document storage like Mongo DB and Elasticsearch

00:16:22,080 --> 00:16:25,760
time series like Influx DB, and memory storage like Redis

00:16:25,760 --> 00:16:28,800
all have excellent support in Go and several are written in Go.

00:16:30,160 --> 00:16:31,680
Being a web developer is hard.

00:16:31,680 --> 00:16:35,200
You need to master everything from sysops, server-side programming

00:16:35,200 --> 00:16:38,880
client-side scripting, visual design, CSS, and SQL

00:16:38,880 --> 00:16:40,480
and all the other things listed here.

00:16:41,040 --> 00:16:43,600
Not only do these cross many paradigms and styles

00:16:43,600 --> 00:16:45,040
but they're constantly changing.

00:16:45,680 --> 00:16:50,080
You also have to be current on the latest security trends

00:16:50,080 --> 00:16:52,320
and even if you've done all this perfectly

00:16:52,320 --> 00:16:55,280
you also need to keep on top of the latest network system

00:16:55,280 --> 00:16:56,400
and container security.

00:16:56,960 --> 00:16:58,480
It should not come as a surprise

00:16:58,480 --> 00:17:01,600
that web applications are notorious for security vulnerabilities.

00:17:02,480 --> 00:17:05,120
Go is leading the way to better security encryption

00:17:05,120 --> 00:17:06,960
with its secure by default approach.

00:17:08,720 --> 00:17:11,440
The latest encryption standards are written in Go

00:17:11,440 --> 00:17:13,520
often ahead of any other language.

00:17:13,520 --> 00:17:15,360
And ship is part of the standard library.

00:17:15,920 --> 00:17:18,240
Google Let's Encrypt and Cloud Flair

00:17:18,240 --> 00:17:20,800
are all heavy Go users for exactly this reason.

00:17:22,160 --> 00:17:23,600
Unlike other applications…

00:17:24,160 --> 00:17:25,440
unlike other languages

00:17:25,440 --> 00:17:29,680
Go applications don't just reuse the host operating system security libraries.

00:17:30,400 --> 00:17:31,760
For most web applications

00:17:31,760 --> 00:17:35,360
the authors need to not only write a secure application

00:17:35,360 --> 00:17:38,800
but also ensure that the host operating system is fully secure.

00:17:39,440 --> 00:17:42,480
With Go, the security is built right into the application

00:17:42,480 --> 00:17:45,520
so it automatically supports the latest security standards

00:17:45,520 --> 00:17:46,560
independent of the host.

00:17:48,160 --> 00:17:51,840
Go ships with a powerful and friendly templating system.

00:17:51,840 --> 00:17:56,000
Among my favorite of its many features is the built-in sanitization.

00:17:56,000 --> 00:17:59,760
It understands HTML, CSS, JavaScript, and URIs

00:17:59,760 --> 00:18:03,840
and automatically sanitizes any variable used in these contexts.

00:18:03,840 --> 00:18:07,280
This built-in safety prevents most cross-site scripting problems.

00:18:08,480 --> 00:18:11,920
Go comes with its own web framework built into the standard library of Go.

00:18:12,480 --> 00:18:14,720
This is the most popular web framework for Go.

00:18:15,360 --> 00:18:18,880
However, if your needs exceed what the standard library provides

00:18:18,880 --> 00:18:21,360
there are many web frameworks readily available

00:18:21,360 --> 00:18:26,000
and Go's modular nature of favoring composition

00:18:26,000 --> 00:18:29,280
means that Go's web frameworks and libraries all play well together.

00:18:29,920 --> 00:18:34,720
Go.dev has a book tutorial, library, and framework recommendations

00:18:34,720 --> 00:18:35,680
to get you started.

00:18:36,880 --> 00:18:40,960
Popular web developer projects, from Smashing Magazine to Vote.gov

00:18:41,520 --> 00:18:45,040
to Bootstrap, to Let's Encrypt, all use Go for their websites.

00:18:46,400 --> 00:18:50,320
Let's outline out why Go is great for application program interfaces

00:18:50,320 --> 00:18:51,200
or APIs.

00:18:52,000 --> 00:18:56,160
APIs allow the capabilities of one program to be used by another

00:18:56,160 --> 00:19:00,400
and they are essentially tools for bridging businesses in all industries.

00:19:01,600 --> 00:19:04,480
Go is a language with a formal specification

00:19:04,480 --> 00:19:06,320
and it doesn't have undefined behavior.

00:19:07,040 --> 00:19:11,280
The API behaviors outlined in the spec can be read in under an hour.

00:19:11,920 --> 00:19:15,040
So, even if you're new to Go coming from another language

00:19:15,040 --> 00:19:16,320
you can most likely know

00:19:16,320 --> 00:19:19,200
what an API definition does in very little time.

00:19:20,000 --> 00:19:24,480
This specification, or spec, extends to decoding third-party

00:19:24,480 --> 00:19:26,560
or non-standard library packages.

00:19:27,200 --> 00:19:30,240
Speaking of third-party packages, Go is simple enough

00:19:30,240 --> 00:19:32,080
but if you want to find out what's really going on

00:19:32,080 --> 00:19:34,080
in some unfamiliar codebase, you can.

00:19:34,640 --> 00:19:36,880
And often that's by inspecting the code itself.

00:19:37,600 --> 00:19:41,520
This simplicity allows for quick building all over the Go ecosystem.

00:19:42,160 --> 00:19:44,240
With the Go Package Discovery site

00:19:44,240 --> 00:19:47,440
which you'll learn about in the Go ecosystem session

00:19:47,440 --> 00:19:51,680
finding which packages and APIs are best for the job is easy

00:19:51,680 --> 00:19:53,440
and an almost trivial task.

00:19:55,280 --> 00:19:57,760
For those of you interested in specifics

00:19:57,760 --> 00:20:02,560
Go is a simple yet robust for containing all the primitives you need for APIs

00:20:02,560 --> 00:20:05,840
including strings, lists, maps, and concurrency.

00:20:07,760 --> 00:20:10,160
I'd like to focus on concurrency here.

00:20:10,160 --> 00:20:14,480
Concurrency describes the concept of running several tasks at the same time.

00:20:14,480 --> 00:20:17,360
And this can either happen in a time-shared manner

00:20:17,360 --> 00:20:19,840
or parallel, if you have multiple cores.

00:20:20,640 --> 00:20:24,720
For APIs, concurrent programming is a very difficult subject

00:20:24,720 --> 00:20:28,720
but in Go, we have concurrency built right in

00:20:28,720 --> 00:20:30,880
as a first-class feature of the language.

00:20:31,600 --> 00:20:35,760
This is important for some types of high-level APIs, like streams.

00:20:35,760 --> 00:20:38,640
And the native concurrency is a big deal for APIs

00:20:38,640 --> 00:20:43,600
on both the server and the client side, right-balanced for all APIs.

00:20:43,600 --> 00:20:46,320
If you care about low-level or performant APIs

00:20:46,320 --> 00:20:48,400
Go can help you with the bare bones

00:20:49,040 --> 00:20:52,960
but also is complex and heavy enough to be useful for high-level APIs

00:20:52,960 --> 00:20:56,080
especially ones that come from object-oriented languages

00:20:56,080 --> 00:20:59,280
where everything is boxed and there's a heavy use of generics.

00:21:00,480 --> 00:21:03,520
Also, there are multiple paradigms for APIs

00:21:03,520 --> 00:21:06,560
including REST, RPC, and GRAPHQL.

00:21:07,200 --> 00:21:11,440
Go maps well to encodings like JSON and protocol buffers

00:21:11,440 --> 00:21:17,520
and the 1.0 compatibility promise meshes well with API consistency over time.

00:21:18,400 --> 00:21:22,800
In conclusion, Go is good for APIs due to simplicity

00:21:22,800 --> 00:21:24,560
a small but strong language

00:21:25,120 --> 00:21:28,880
for easy on-boarding and compatible usage across paradigms

00:21:28,880 --> 00:21:33,040
robust built-in functionality, particularly for concurrency

00:21:33,040 --> 00:21:34,880
and a thoughtfully designed middle ground

00:21:34,880 --> 00:21:43,840

YouTube URL: https://www.youtube.com/watch?v=B8il-RRkZq0


