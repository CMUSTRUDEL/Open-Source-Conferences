Title: Google Open Source Live "Bazel day" | Full Event
Publication date: 2021-04-01
Playlist: Google Open Source Live
Description: 
	
Captions: 
	00:00:00,610 --> 00:00:10,240
[Music]

00:00:08,720 --> 00:00:10,719
good morning good afternoon and good

00:00:10,240 --> 00:00:12,240
evening

00:00:10,719 --> 00:00:14,160
thank you for joining basil day on

00:00:12,240 --> 00:00:15,920
google open source live

00:00:14,160 --> 00:00:18,000
this is a monthly series of sessions led

00:00:15,920 --> 00:00:19,680
by open source experts from google and

00:00:18,000 --> 00:00:21,359
community leaders

00:00:19,680 --> 00:00:23,119
we really appreciate everyone taking the

00:00:21,359 --> 00:00:25,039
time to come here together digitally to

00:00:23,119 --> 00:00:27,039
learn more about bazel

00:00:25,039 --> 00:00:28,400
my name is joe hicks and i'm a product

00:00:27,039 --> 00:00:30,640
manager here at google

00:00:28,400 --> 00:00:32,880
and i'm based in the new york city i'm

00:00:30,640 --> 00:00:35,280
also here with sylvia

00:00:32,880 --> 00:00:37,440
hi folks my name is sylvia isler also

00:00:35,280 --> 00:00:38,960
known as sylvia isler1 on twitter

00:00:37,440 --> 00:00:42,719
i'm an engineering manager here at

00:00:38,960 --> 00:00:44,079
google i'm located in new york as well

00:00:42,719 --> 00:00:45,920
we have some really interesting topics

00:00:44,079 --> 00:00:47,200
for you all today if you're looking to

00:00:45,920 --> 00:00:48,640
learn more about bazel you're in the

00:00:47,200 --> 00:00:50,320
right place

00:00:48,640 --> 00:00:51,760
we'll kick it off with a talk from doug

00:00:50,320 --> 00:00:55,039
parker walking us through how he

00:00:51,760 --> 00:00:56,960
migrated 2500 apps to angular ivy

00:00:55,039 --> 00:00:58,480
which is really a case study on bazel

00:00:56,960 --> 00:00:59,600
transitions

00:00:58,480 --> 00:01:02,000
before that we have a couple

00:00:59,600 --> 00:01:03,520
housekeeping items

00:01:02,000 --> 00:01:05,680
don't forget to put your questions in

00:01:03,520 --> 00:01:06,560
the live q a form below the live stream

00:01:05,680 --> 00:01:08,000
window

00:01:06,560 --> 00:01:10,320
speakers are ready to answer your

00:01:08,000 --> 00:01:10,720
questions live if you're viewing in full

00:01:10,320 --> 00:01:12,560
screen

00:01:10,720 --> 00:01:14,320
you'll need to exit full screen to see

00:01:12,560 --> 00:01:16,400
the live q a forum

00:01:14,320 --> 00:01:18,080
our sessions have been pre-recorded to

00:01:16,400 --> 00:01:20,240
allow for accurate transcripts

00:01:18,080 --> 00:01:21,680
and so that speakers can answer your

00:01:20,240 --> 00:01:22,880
questions live

00:01:21,680 --> 00:01:24,560
we would love to hear your thoughts on

00:01:22,880 --> 00:01:26,159
these sessions so feel free to make

00:01:24,560 --> 00:01:28,159
comments in the live forum

00:01:26,159 --> 00:01:29,360
and we'll check them throughout the show

00:01:28,159 --> 00:01:31,200
once we're done

00:01:29,360 --> 00:01:32,560
don't forget to join us at the after

00:01:31,200 --> 00:01:34,000
party on google meet

00:01:32,560 --> 00:01:36,799
we'll share a link at the end of the

00:01:34,000 --> 00:01:39,200
last session and one last thing

00:01:36,799 --> 00:01:41,600
use the hashtag google os live to share

00:01:39,200 --> 00:01:55,840
your experience on social channel

00:01:41,600 --> 00:01:55,840
anything else joe with that enjoy

00:04:53,280 --> 00:04:56,400
hello basilers my name is doug and i'm

00:04:55,120 --> 00:04:58,560
here to talk to you today about how

00:04:56,400 --> 00:05:01,199
we're migrating over 2500 applications

00:04:58,560 --> 00:05:02,479
to angular ivy using bazel transitions

00:05:01,199 --> 00:05:04,479
i'll be telling you what the iv

00:05:02,479 --> 00:05:06,240
migration is why it's so tricky

00:05:04,479 --> 00:05:07,520
what basal transitions are and how we're

00:05:06,240 --> 00:05:10,160
able to leverage them to scale this

00:05:07,520 --> 00:05:11,759
migration safely to so many applications

00:05:10,160 --> 00:05:13,120
my name is doug parker i'm a software

00:05:11,759 --> 00:05:14,240
engineer at google specifically on the

00:05:13,120 --> 00:05:15,600
angular team

00:05:14,240 --> 00:05:16,880
if you're not familiar with it angular

00:05:15,600 --> 00:05:18,320
is an open source framework for building

00:05:16,880 --> 00:05:19,520
high quality web applications and i

00:05:18,320 --> 00:05:20,960
definitely recommend you check that out

00:05:19,520 --> 00:05:22,400
if you build web apps

00:05:20,960 --> 00:05:24,240
not only do we have support for bazel

00:05:22,400 --> 00:05:25,919
but we even use bazel in our core github

00:05:24,240 --> 00:05:27,120
repository where external open source

00:05:25,919 --> 00:05:27,919
developers contribute their code to

00:05:27,120 --> 00:05:30,240
angular so

00:05:27,919 --> 00:05:31,600
we really love bazel on the angular team

00:05:30,240 --> 00:05:32,880
but today i'm here to talk to you about

00:05:31,600 --> 00:05:34,800
google 3 migration

00:05:32,880 --> 00:05:36,479
google 3 is the model repository which

00:05:34,800 --> 00:05:37,039
stores most of google's internal source

00:05:36,479 --> 00:05:38,800
code

00:05:37,039 --> 00:05:40,560
it's a massive bazel workspace with

00:05:38,800 --> 00:05:42,720
millions of lines of code and we want to

00:05:40,560 --> 00:05:45,039
upgrade it to angular id

00:05:42,720 --> 00:05:46,479
ivy itself is a new new version of our

00:05:45,039 --> 00:05:47,520
rendering engine recently released by

00:05:46,479 --> 00:05:48,960
the angular team

00:05:47,520 --> 00:05:50,560
the specifics of it aren't too important

00:05:48,960 --> 00:05:52,400
for this talk but it's a smaller

00:05:50,560 --> 00:05:54,800
faster and generally better than our old

00:05:52,400 --> 00:05:55,840
system it also makes puppies and kittens

00:05:54,800 --> 00:05:57,520
happy so we're really pushing

00:05:55,840 --> 00:05:59,840
applications to use it

00:05:57,520 --> 00:06:01,759
we've got over 2 500 angular

00:05:59,840 --> 00:06:02,720
applications in google three so we want

00:06:01,759 --> 00:06:05,759
to upgrade them to iv

00:06:02,720 --> 00:06:07,199
as quickly and easily as possible iv

00:06:05,759 --> 00:06:09,039
itself is a re-implementation of

00:06:07,199 --> 00:06:10,400
existing angular apis

00:06:09,039 --> 00:06:12,000
which means that applications generally

00:06:10,400 --> 00:06:13,280
shouldn't have to change their code in

00:06:12,000 --> 00:06:15,120
order to work with ivy

00:06:13,280 --> 00:06:17,039
making a migration much simpler since

00:06:15,120 --> 00:06:17,919
turning on iv is as simple as a flag

00:06:17,039 --> 00:06:19,680
flip

00:06:17,919 --> 00:06:22,560
so if what we want to do is flip a flag

00:06:19,680 --> 00:06:24,720
then this should be an easy change right

00:06:22,560 --> 00:06:26,319
well let's see how this might work in

00:06:24,720 --> 00:06:27,680
angular we have our own build rule for

00:06:26,319 --> 00:06:30,560
compiling code

00:06:27,680 --> 00:06:32,319
ng module is our equivalent of ts

00:06:30,560 --> 00:06:34,080
library java library or

00:06:32,319 --> 00:06:37,039
whatever your preferred language's

00:06:34,080 --> 00:06:39,360
library rule is it's just our version

00:06:37,039 --> 00:06:41,039
iv itself is a compiler flag so it needs

00:06:39,360 --> 00:06:43,520
to be provided to the compiler action

00:06:41,039 --> 00:06:44,720
that runs under the energy module rule

00:06:43,520 --> 00:06:46,560
this means that the easiest way of

00:06:44,720 --> 00:06:48,400
enabling iv is to simply add it to our

00:06:46,560 --> 00:06:51,120
ng module starlark implementation

00:06:48,400 --> 00:06:53,120
passing it is iv equals true to our

00:06:51,120 --> 00:06:54,639
compiler actions arguments

00:06:53,120 --> 00:06:56,479
since we're working in a monorepo and we

00:06:54,639 --> 00:06:58,000
only have one version of ng module

00:06:56,479 --> 00:06:59,599
if i merge this change then all

00:06:58,000 --> 00:07:00,479
applications will immediately build with

00:06:59,599 --> 00:07:02,880
ivy

00:07:00,479 --> 00:07:04,319
that's incredibly easy and it's also

00:07:02,880 --> 00:07:05,680
incredibly terrifying

00:07:04,319 --> 00:07:07,919
for one simple reason it's best

00:07:05,680 --> 00:07:09,360
described by hiram's law

00:07:07,919 --> 00:07:11,599
hiram's law if you're not familiar with

00:07:09,360 --> 00:07:12,960
it it essentially states that if a

00:07:11,599 --> 00:07:14,560
system has a sufficient number of

00:07:12,960 --> 00:07:16,000
dependents then eventually all

00:07:14,560 --> 00:07:17,919
observable behaviors of that

00:07:16,000 --> 00:07:19,759
system will eventually be dependent upon

00:07:17,919 --> 00:07:22,160
by somebody

00:07:19,759 --> 00:07:22,960
and while ivy is theoretically backwards

00:07:22,160 --> 00:07:24,400
compatible

00:07:22,960 --> 00:07:26,479
it is a re-implementation of these

00:07:24,400 --> 00:07:27,680
existing apis there are subtle

00:07:26,479 --> 00:07:29,520
differences in them that were never

00:07:27,680 --> 00:07:30,720
officially in the api contract

00:07:29,520 --> 00:07:33,039
but applications have nonetheless

00:07:30,720 --> 00:07:34,800
managed to depend upon with thousands of

00:07:33,039 --> 00:07:37,199
angular applications enabling iv

00:07:34,800 --> 00:07:38,880
would inevitably break somebody no

00:07:37,199 --> 00:07:40,319
matter how backwards compatible we try

00:07:38,880 --> 00:07:42,240
to make it

00:07:40,319 --> 00:07:44,319
if we enable this globally as i showed a

00:07:42,240 --> 00:07:45,360
moment ago then when one application has

00:07:44,319 --> 00:07:48,000
a production issue

00:07:45,360 --> 00:07:48,479
we'll have to roll it back for everyone

00:07:48,000 --> 00:07:50,319
and

00:07:48,479 --> 00:07:52,560
that can cause outages increase friction

00:07:50,319 --> 00:07:52,879
for developers negatively impact users

00:07:52,560 --> 00:07:54,720
and

00:07:52,879 --> 00:07:57,280
it makes puppies and kittens sad so we

00:07:54,720 --> 00:07:59,120
need to reevaluate our rollout strategy

00:07:57,280 --> 00:08:01,039
rather than roll out as one giant flag

00:07:59,120 --> 00:08:02,800
flip we want to roll out incrementally

00:08:01,039 --> 00:08:04,639
specifically applications should be able

00:08:02,800 --> 00:08:06,800
to opt into ib individually

00:08:04,639 --> 00:08:08,639
enabling ib for one application should

00:08:06,800 --> 00:08:10,160
not affect any other applications in the

00:08:08,639 --> 00:08:11,599
workspace

00:08:10,160 --> 00:08:13,280
the angular team should still control

00:08:11,599 --> 00:08:14,960
the default value

00:08:13,280 --> 00:08:16,479
because with thousands of applications

00:08:14,960 --> 00:08:18,319
asking them to migrate individually

00:08:16,479 --> 00:08:19,759
wastes a lot of time for everyone

00:08:18,319 --> 00:08:21,199
we want to be able to just migrate those

00:08:19,759 --> 00:08:22,479
applications for them hopefully without

00:08:21,199 --> 00:08:24,560
them even noticing

00:08:22,479 --> 00:08:25,599
even if this makes my job 100 times

00:08:24,560 --> 00:08:27,120
harder it stops

00:08:25,599 --> 00:08:29,120
thousands of other teams from doing the

00:08:27,120 --> 00:08:30,400
same work so it's still a huge win for

00:08:29,120 --> 00:08:32,080
the company

00:08:30,400 --> 00:08:34,000
in order to safely flip this default

00:08:32,080 --> 00:08:35,519
value though we need to be able to opt

00:08:34,000 --> 00:08:38,320
out any applications that would be

00:08:35,519 --> 00:08:40,479
broken by ivy by doing so we're

00:08:38,320 --> 00:08:41,919
able to safely enable iv by default for

00:08:40,479 --> 00:08:43,919
the vast majority of applications

00:08:41,919 --> 00:08:46,080
without causing any breakages

00:08:43,919 --> 00:08:47,680
we'll also need a rollback strategy if

00:08:46,080 --> 00:08:48,560
someone encounters a production outage

00:08:47,680 --> 00:08:50,080
when we flip this

00:08:48,560 --> 00:08:51,600
default value they should be able to

00:08:50,080 --> 00:08:54,320
roll themselves back without

00:08:51,600 --> 00:08:56,160
affecting any other angular application

00:08:54,320 --> 00:08:57,360
there's also one other unique constraint

00:08:56,160 --> 00:08:59,200
that this brings up

00:08:57,360 --> 00:09:00,640
angular ib was originally developed with

00:08:59,200 --> 00:09:02,720
the expectation that an application is

00:09:00,640 --> 00:09:05,040
either entirely built with iv

00:09:02,720 --> 00:09:06,640
or not at all built with iv you can't

00:09:05,040 --> 00:09:08,480
mix part of the application compiled

00:09:06,640 --> 00:09:08,959
with iv and part of it compiled without

00:09:08,480 --> 00:09:10,320
iv

00:09:08,959 --> 00:09:12,399
that just doesn't work at runtime and

00:09:10,320 --> 00:09:14,080
it's not the way the system was designed

00:09:12,399 --> 00:09:16,080
what this means is that our builds need

00:09:14,080 --> 00:09:17,920
to be consistent either the entire

00:09:16,080 --> 00:09:19,360
application builds with ib or none of it

00:09:17,920 --> 00:09:20,640
does

00:09:19,360 --> 00:09:21,600
and if you're experienced in bazel you

00:09:20,640 --> 00:09:22,640
might be thinking about how you can

00:09:21,600 --> 00:09:24,080
implement this rollout

00:09:22,640 --> 00:09:26,240
so let's look at a couple approaches

00:09:24,080 --> 00:09:28,800
that immediately come to mind

00:09:26,240 --> 00:09:30,800
firstly bazel provides dash dash define

00:09:28,800 --> 00:09:32,640
in order to specify custom bill flex

00:09:30,800 --> 00:09:34,640
where developers can add desktop define

00:09:32,640 --> 00:09:36,240
some flag name and then the value and

00:09:34,640 --> 00:09:36,959
you can read this at build time and

00:09:36,240 --> 00:09:38,399
start lurk

00:09:36,959 --> 00:09:40,399
we could use one of these to implement

00:09:38,399 --> 00:09:42,160
ivy the tricky part here is that

00:09:40,399 --> 00:09:44,080
developers must always provide this flag

00:09:42,160 --> 00:09:45,440
manually so you have to remember to add

00:09:44,080 --> 00:09:46,800
it at the end of every bazel build

00:09:45,440 --> 00:09:47,920
command

00:09:46,800 --> 00:09:49,519
i don't know about you but i can't

00:09:47,920 --> 00:09:51,279
remember to check the test pass before i

00:09:49,519 --> 00:09:53,440
send a pr for review so i'm definitely

00:09:51,279 --> 00:09:54,880
not going to remember to do this

00:09:53,440 --> 00:09:57,040
alternatively we can add this flag to

00:09:54,880 --> 00:09:58,800
our bazelrc configuration file so it's

00:09:57,040 --> 00:10:00,240
automatically applied on every build

00:09:58,800 --> 00:10:01,920
that at least saves me from embarrassing

00:10:00,240 --> 00:10:03,440
myself in front of my co-workers

00:10:01,920 --> 00:10:05,440
however this also means that it applies

00:10:03,440 --> 00:10:07,120
to all applications in the workspace so

00:10:05,440 --> 00:10:08,959
we can't apply this flag on an

00:10:07,120 --> 00:10:10,160
application by application basis like we

00:10:08,959 --> 00:10:11,440
really want to

00:10:10,160 --> 00:10:13,360
the problem here is that these flags

00:10:11,440 --> 00:10:15,120
apply to the entire compilation

00:10:13,360 --> 00:10:17,519
which is just too broad for our purposes

00:10:15,120 --> 00:10:20,480
we want this to be application specific

00:10:17,519 --> 00:10:21,920
so this just doesn't quite work for us

00:10:20,480 --> 00:10:23,440
another way of employing this flag would

00:10:21,920 --> 00:10:24,959
be to simply make it an attribute on the

00:10:23,440 --> 00:10:26,560
ng module rule

00:10:24,959 --> 00:10:28,399
we can propagate this attribute to the

00:10:26,560 --> 00:10:30,480
compiler action and

00:10:28,399 --> 00:10:32,320
build and invoke that action with ivy

00:10:30,480 --> 00:10:34,000
this could be a little awkward as we'd

00:10:32,320 --> 00:10:36,399
have to put iv equals true on all of our

00:10:34,000 --> 00:10:37,760
ng module rules and that could be a lot

00:10:36,399 --> 00:10:39,760
but we could automate this or use a

00:10:37,760 --> 00:10:40,880
clever macro we could make that scale if

00:10:39,760 --> 00:10:42,880
we really needed to

00:10:40,880 --> 00:10:44,880
so this actually sounds pretty good but

00:10:42,880 --> 00:10:46,640
let's look a little bit closer

00:10:44,880 --> 00:10:48,480
let's say as an example we have

00:10:46,640 --> 00:10:49,760
workspace with two applications each of

00:10:48,480 --> 00:10:52,320
those have a couple targets

00:10:49,760 --> 00:10:53,120
and both of them depend on angular core

00:10:52,320 --> 00:10:55,760
cores are

00:10:53,120 --> 00:10:56,800
standard library core functionality uh

00:10:55,760 --> 00:10:58,640
and for our purposes

00:10:56,800 --> 00:11:00,240
everything depends on core because if it

00:10:58,640 --> 00:11:01,680
didn't then it wouldn't be an angular

00:11:00,240 --> 00:11:02,000
app and we wouldn't care to migrate it

00:11:01,680 --> 00:11:03,279
so

00:11:02,000 --> 00:11:05,680
we can just pretend everything depends

00:11:03,279 --> 00:11:07,120
on core each of these boxes is a

00:11:05,680 --> 00:11:08,480
different bazel target and they're all

00:11:07,120 --> 00:11:10,240
ng module rules

00:11:08,480 --> 00:11:11,760
so each one has its own invocation of

00:11:10,240 --> 00:11:13,760
the angular compiler and its own version

00:11:11,760 --> 00:11:15,760
of the id flag

00:11:13,760 --> 00:11:17,360
since we're rolling out incrementally we

00:11:15,760 --> 00:11:18,800
only want to change one application to

00:11:17,360 --> 00:11:20,000
use iv and the other one should just be

00:11:18,800 --> 00:11:22,959
left alone

00:11:20,000 --> 00:11:25,200
we can compile app1 as ivy but then

00:11:22,959 --> 00:11:27,519
leave app2 without it

00:11:25,200 --> 00:11:29,440
but this immediately brings up a tricky

00:11:27,519 --> 00:11:30,959
problem which is how do we compile

00:11:29,440 --> 00:11:32,720
angular core

00:11:30,959 --> 00:11:34,560
since it's just a regular ng module

00:11:32,720 --> 00:11:36,720
there's nothing special about it

00:11:34,560 --> 00:11:39,040
if we enable iv then app one will work

00:11:36,720 --> 00:11:41,360
but app2 will break and if we disable iv

00:11:39,040 --> 00:11:42,800
then app1 fails but app2 works so we're

00:11:41,360 --> 00:11:43,920
really stuck between a rock and a hard

00:11:42,800 --> 00:11:45,680
place here

00:11:43,920 --> 00:11:48,320
this is that shared library requirement

00:11:45,680 --> 00:11:49,920
in action a library can be used by

00:11:48,320 --> 00:11:51,760
multiple applications using different

00:11:49,920 --> 00:11:53,839
values for ivy and the library needs to

00:11:51,760 --> 00:11:55,360
somehow be compatible with both of these

00:11:53,839 --> 00:11:58,000
but that's just not how the compilation

00:11:55,360 --> 00:12:01,120
works what we really need are

00:11:58,000 --> 00:12:01,920
two different builds of angular core one

00:12:01,120 --> 00:12:03,600
that uses iv

00:12:01,920 --> 00:12:05,760
and one that doesn't there are a few

00:12:03,600 --> 00:12:07,440
ways you can sort of make this work

00:12:05,760 --> 00:12:09,680
you could split angular core into two

00:12:07,440 --> 00:12:10,720
targets via some kind of clever macro

00:12:09,680 --> 00:12:12,399
and make sure that all these

00:12:10,720 --> 00:12:13,279
applications depend on the correct

00:12:12,399 --> 00:12:14,880
version

00:12:13,279 --> 00:12:16,800
uh this actually becomes quite difficult

00:12:14,880 --> 00:12:17,440
for a number of reasons uh for instance

00:12:16,800 --> 00:12:19,600
keeping

00:12:17,440 --> 00:12:20,800
your dependency edges consistent between

00:12:19,600 --> 00:12:21,839
the two applications can actually be

00:12:20,800 --> 00:12:23,600
quite tricky

00:12:21,839 --> 00:12:25,120
and not to mention in your actual source

00:12:23,600 --> 00:12:26,639
code if you're importing things

00:12:25,120 --> 00:12:28,000
referenced by the file name

00:12:26,639 --> 00:12:29,519
the file name would then be changed and

00:12:28,000 --> 00:12:30,639
so all your imports would be wrong you'd

00:12:29,519 --> 00:12:32,000
have to update those

00:12:30,639 --> 00:12:33,680
so this actually becomes quite tricky

00:12:32,000 --> 00:12:35,040
very quickly

00:12:33,680 --> 00:12:37,120
ultimately the problem here is that

00:12:35,040 --> 00:12:39,680
we're opting out individual

00:12:37,120 --> 00:12:40,959
targets which is just too specific it's

00:12:39,680 --> 00:12:41,920
kind of the opposite problem from what

00:12:40,959 --> 00:12:43,200
we had earlier

00:12:41,920 --> 00:12:45,920
and it just doesn't support shared

00:12:43,200 --> 00:12:48,079
libraries in the way that we need to

00:12:45,920 --> 00:12:50,320
so how do we want this to work what i

00:12:48,079 --> 00:12:52,079
want to do is add iv equals true to the

00:12:50,320 --> 00:12:53,839
top level application target just

00:12:52,079 --> 00:12:57,200
modifying it in one place because

00:12:53,839 --> 00:12:58,720
i'm a bit lazy then when we bazel build

00:12:57,200 --> 00:13:00,959
the first app it should compile

00:12:58,720 --> 00:13:02,639
everything with ivy for itself and all

00:13:00,959 --> 00:13:05,040
of its transitive dependencies

00:13:02,639 --> 00:13:06,000
including angular core however when i

00:13:05,040 --> 00:13:07,440
bazel built the second

00:13:06,000 --> 00:13:10,160
app that should compile everything

00:13:07,440 --> 00:13:11,680
without iv again for itself and all of

00:13:10,160 --> 00:13:13,120
its transit dependencies

00:13:11,680 --> 00:13:14,959
the lesson here is really that angular

00:13:13,120 --> 00:13:16,000
core doesn't care whether it's built

00:13:14,959 --> 00:13:17,519
with iv or not

00:13:16,000 --> 00:13:18,720
it's happy to build with iv if that's

00:13:17,519 --> 00:13:20,079
what the application wants and it's

00:13:18,720 --> 00:13:21,519
happy not to build with ivy if the

00:13:20,079 --> 00:13:23,680
application doesn't

00:13:21,519 --> 00:13:25,200
but is this kind of design actually

00:13:23,680 --> 00:13:26,720
possible with bazel

00:13:25,200 --> 00:13:28,720
you may be surprised to learn that the

00:13:26,720 --> 00:13:30,480
answer is actually yes

00:13:28,720 --> 00:13:31,839
this is done with bazel configurations

00:13:30,480 --> 00:13:33,360
and transitions which are the way in

00:13:31,839 --> 00:13:34,959
which we're able to configure builds to

00:13:33,360 --> 00:13:36,399
provide this kind of functionality

00:13:34,959 --> 00:13:38,720
first i'll explain some rough

00:13:36,399 --> 00:13:40,480
definitions every target gets

00:13:38,720 --> 00:13:41,839
built with a configuration and you can

00:13:40,480 --> 00:13:43,279
think of a configuration as the set of

00:13:41,839 --> 00:13:45,680
compile time flags

00:13:43,279 --> 00:13:47,279
and their values every target has a

00:13:45,680 --> 00:13:48,000
configuration which contains all of the

00:13:47,279 --> 00:13:49,760
flag values

00:13:48,000 --> 00:13:51,360
that target can read when it's executing

00:13:49,760 --> 00:13:53,040
its rule

00:13:51,360 --> 00:13:54,720
transitions are the means of

00:13:53,040 --> 00:13:56,959
transitioning the

00:13:54,720 --> 00:13:59,199
build graph from one configuration to

00:13:56,959 --> 00:14:00,880
another this allows you to modify flags

00:13:59,199 --> 00:14:02,240
for a particular set of targets

00:14:00,880 --> 00:14:04,639
effectively changing those slacks

00:14:02,240 --> 00:14:06,560
dynamically based on the build graph

00:14:04,639 --> 00:14:08,399
a target's configuration gets inherited

00:14:06,560 --> 00:14:09,760
by all of its transitive dependencies

00:14:08,399 --> 00:14:11,839
this means that transitioning even a

00:14:09,760 --> 00:14:13,839
single target to a new configuration

00:14:11,839 --> 00:14:15,600
will also apply to that target's entire

00:14:13,839 --> 00:14:17,120
transitive dependencies

00:14:15,600 --> 00:14:18,480
those dependencies will also use the new

00:14:17,120 --> 00:14:20,160
flag values that were changed by the

00:14:18,480 --> 00:14:21,199
transition and this is a really powerful

00:14:20,160 --> 00:14:22,800
feature which we'll be taking full

00:14:21,199 --> 00:14:24,160
advantage of for ivy

00:14:22,800 --> 00:14:26,000
so hopefully that gives you some rough

00:14:24,160 --> 00:14:27,199
idea of what these terms mean at an

00:14:26,000 --> 00:14:28,480
abstract level so let's look at

00:14:27,199 --> 00:14:30,880
something a little more concrete to help

00:14:28,480 --> 00:14:32,320
clarify these concepts

00:14:30,880 --> 00:14:33,839
first let's consider a simple build

00:14:32,320 --> 00:14:34,720
graph that has three targets depending

00:14:33,839 --> 00:14:36,720
on each other

00:14:34,720 --> 00:14:38,240
each target has its own configuration

00:14:36,720 --> 00:14:39,040
and the set of flags that it compiles

00:14:38,240 --> 00:14:40,560
with

00:14:39,040 --> 00:14:42,000
in this case they are all using the

00:14:40,560 --> 00:14:43,519
default configuration meaning that they

00:14:42,000 --> 00:14:44,399
use the default values for all of their

00:14:43,519 --> 00:14:46,160
flags

00:14:44,399 --> 00:14:47,600
in particular the test flag uses the

00:14:46,160 --> 00:14:49,839
default value of hello

00:14:47,600 --> 00:14:51,760
for all targets in this graph we can

00:14:49,839 --> 00:14:53,519
introduce a transition to the bar target

00:14:51,760 --> 00:14:54,320
which will transition its flag value

00:14:53,519 --> 00:14:56,880
from hello

00:14:54,320 --> 00:14:58,639
to world what this means is that when

00:14:56,880 --> 00:15:00,800
bar executes its rule

00:14:58,639 --> 00:15:02,240
it will see the test flag now has the

00:15:00,800 --> 00:15:03,920
value world

00:15:02,240 --> 00:15:06,399
this transition has effectively changed

00:15:03,920 --> 00:15:08,720
the value of this flag for bar

00:15:06,399 --> 00:15:10,320
baz will also see the value world

00:15:08,720 --> 00:15:11,360
because it inherits this configuration

00:15:10,320 --> 00:15:12,880
from its parent

00:15:11,360 --> 00:15:15,600
this means that all transit dependencies

00:15:12,880 --> 00:15:17,120
of bar will see the new value of world

00:15:15,600 --> 00:15:18,560
foo on the other hand is unaffected and

00:15:17,120 --> 00:15:20,000
it continues to compile with hello

00:15:18,560 --> 00:15:21,680
because it's sort of above all of this

00:15:20,000 --> 00:15:23,199
in the build graph

00:15:21,680 --> 00:15:25,279
now that's a lot of high level concepts

00:15:23,199 --> 00:15:27,199
so how might we be able to apply this to

00:15:25,279 --> 00:15:28,880
solve our problems with ivy

00:15:27,199 --> 00:15:30,399
so let's revisit the original design we

00:15:28,880 --> 00:15:32,160
came up with a moment ago and how we can

00:15:30,399 --> 00:15:34,240
use transitions to implement it

00:15:32,160 --> 00:15:35,839
we can add a new attribute called ib to

00:15:34,240 --> 00:15:38,000
ng module and set it on

00:15:35,839 --> 00:15:39,199
f1 binary the top level target for that

00:15:38,000 --> 00:15:41,199
application

00:15:39,199 --> 00:15:43,519
this will enable a transition which sets

00:15:41,199 --> 00:15:45,680
the ib flag on the configuration

00:15:43,519 --> 00:15:47,279
this means that when we build app 1 ib

00:15:45,680 --> 00:15:49,120
is transitively inherited for all

00:15:47,279 --> 00:15:50,560
targets in an application

00:15:49,120 --> 00:15:53,199
as well as any shared libraries like

00:15:50,560 --> 00:15:54,959
angular core when we build app 2 binary

00:15:53,199 --> 00:15:56,880
on the other hand is left alone because

00:15:54,959 --> 00:15:58,480
it did not set the ib attribute

00:15:56,880 --> 00:16:00,000
so it does not have a transition and

00:15:58,480 --> 00:16:01,680
have2 continues to build using the

00:16:00,000 --> 00:16:03,519
default value of false passed all the

00:16:01,680 --> 00:16:05,759
way down to angular core

00:16:03,519 --> 00:16:07,199
and built correctly without ivy with

00:16:05,759 --> 00:16:08,240
this architecture we're able to use

00:16:07,199 --> 00:16:09,120
transitions to isolate these

00:16:08,240 --> 00:16:10,959
applications from

00:16:09,120 --> 00:16:12,720
each other while still using the correct

00:16:10,959 --> 00:16:14,240
id file for each application

00:16:12,720 --> 00:16:16,160
even for libraries shared between the

00:16:14,240 --> 00:16:17,600
two we're also working at the right

00:16:16,160 --> 00:16:19,759
level of abstraction now

00:16:17,600 --> 00:16:21,600
we're opting in applications rather than

00:16:19,759 --> 00:16:22,880
individual targets like earlier so this

00:16:21,600 --> 00:16:23,920
is much closer to what we originally

00:16:22,880 --> 00:16:25,199
wanted

00:16:23,920 --> 00:16:27,120
by now you're probably sick and tired of

00:16:25,199 --> 00:16:28,240
box diagrams so let's take a look at

00:16:27,120 --> 00:16:30,000
some of the actual code we would use to

00:16:28,240 --> 00:16:32,320
implement this

00:16:30,000 --> 00:16:33,519
we start by defining a simple flag we

00:16:32,320 --> 00:16:34,880
load this from skyloop which is a

00:16:33,519 --> 00:16:36,639
library that has a lot of great basal

00:16:34,880 --> 00:16:38,639
utilities flags being one of them

00:16:36,639 --> 00:16:40,160
we pick some build file to define this

00:16:38,639 --> 00:16:42,480
flag and we simply add

00:16:40,160 --> 00:16:43,759
wool flag as a rule since this is a

00:16:42,480 --> 00:16:46,240
simple build file it

00:16:43,759 --> 00:16:49,040
actually has a target this one exists at

00:16:46,240 --> 00:16:50,800
slash angular colon ib flag

00:16:49,040 --> 00:16:52,639
it's a little strange that it sort of

00:16:50,800 --> 00:16:53,920
has a position in the build graph and

00:16:52,639 --> 00:16:56,320
you can depend upon it but that's

00:16:53,920 --> 00:16:57,920
actually how we're going to use it here

00:16:56,320 --> 00:16:59,920
so now that we have this flag we need to

00:16:57,920 --> 00:17:01,680
update our ng module rule in order to

00:16:59,920 --> 00:17:03,440
depend on this iv flag

00:17:01,680 --> 00:17:04,640
because bazel's bazel we need to

00:17:03,440 --> 00:17:07,120
explicitly declare all of our

00:17:04,640 --> 00:17:08,400
dependencies and that does include flags

00:17:07,120 --> 00:17:10,559
in this case we're creating a new

00:17:08,400 --> 00:17:11,199
attribute which depends on this flag by

00:17:10,559 --> 00:17:12,640
default

00:17:11,199 --> 00:17:14,480
this essentially means that all ng

00:17:12,640 --> 00:17:16,640
module roles will now implicitly depend

00:17:14,480 --> 00:17:18,480
on this new flag

00:17:16,640 --> 00:17:19,679
finally it's time to actually read this

00:17:18,480 --> 00:17:21,439
flag's value

00:17:19,679 --> 00:17:23,039
in our rules implementation we can use

00:17:21,439 --> 00:17:24,799
the context object to

00:17:23,039 --> 00:17:27,039
find the ib flag attribute that we just

00:17:24,799 --> 00:17:27,919
declared and read its value as a simple

00:17:27,039 --> 00:17:29,120
boolean

00:17:27,919 --> 00:17:30,320
for now i'm just going to print it out

00:17:29,120 --> 00:17:32,000
with the target's name but you can

00:17:30,320 --> 00:17:34,880
certainly imagine passing this flag to

00:17:32,000 --> 00:17:36,160
your compiler as an argument or even

00:17:34,880 --> 00:17:37,200
choosing between two completely

00:17:36,160 --> 00:17:39,440
different actions

00:17:37,200 --> 00:17:41,200
maybe you want to have one action

00:17:39,440 --> 00:17:42,720
specifically for iv code and another

00:17:41,200 --> 00:17:44,400
action that invokes a separate compiler

00:17:42,720 --> 00:17:46,480
for non-iv code and that's entirely

00:17:44,400 --> 00:17:48,400
possible with this design

00:17:46,480 --> 00:17:50,320
finally when i'm able to build any ng

00:17:48,400 --> 00:17:51,840
module rule this code will execute and

00:17:50,320 --> 00:17:54,080
it will print out the flag

00:17:51,840 --> 00:17:55,760
for now building app 1 binary shows that

00:17:54,080 --> 00:17:57,600
it and all of its transit dependencies

00:17:55,760 --> 00:17:59,440
are built with ib set to false

00:17:57,600 --> 00:18:01,600
so we successfully read the default

00:17:59,440 --> 00:18:04,240
value of this flag now we need to set it

00:18:01,600 --> 00:18:06,240
via transition now what we want to be

00:18:04,240 --> 00:18:07,280
able to do is add ib attribute equals

00:18:06,240 --> 00:18:08,960
true to the top

00:18:07,280 --> 00:18:10,240
level engine module rule and trust that

00:18:08,960 --> 00:18:11,440
all of its transit dependencies will

00:18:10,240 --> 00:18:13,120
build with iv

00:18:11,440 --> 00:18:15,440
we shouldn't need to add ib equals true

00:18:13,120 --> 00:18:16,640
to all ng module rules because in a real

00:18:15,440 --> 00:18:19,280
app that'd be a lot and

00:18:16,640 --> 00:18:21,120
frankly i just can't be bothered with it

00:18:19,280 --> 00:18:22,799
now i'm calling this one iv

00:18:21,120 --> 00:18:25,280
attribute that's just to distinguish it

00:18:22,799 --> 00:18:26,640
from the iv flag that we defined earlier

00:18:25,280 --> 00:18:28,559
it's just to drive home these are two

00:18:26,640 --> 00:18:29,760
completely distinct boolean values

00:18:28,559 --> 00:18:32,480
they're going to be working together to

00:18:29,760 --> 00:18:35,200
create the behavior that we want

00:18:32,480 --> 00:18:36,480
we start by declaring an id attribute

00:18:35,200 --> 00:18:38,000
defined as a simple boolean and

00:18:36,480 --> 00:18:39,840
defaulting to false this is because we

00:18:38,000 --> 00:18:41,360
expect applications to opt into iv

00:18:39,840 --> 00:18:42,640
this works just like any other attribute

00:18:41,360 --> 00:18:44,240
you would use on a rule and if you've

00:18:42,640 --> 00:18:45,600
done rules in bazel before you've done

00:18:44,240 --> 00:18:46,799
this countless times and there's nothing

00:18:45,600 --> 00:18:48,640
special here

00:18:46,799 --> 00:18:51,440
now we get on to the actual mean and

00:18:48,640 --> 00:18:53,120
potatoes of this the actual transition

00:18:51,440 --> 00:18:54,880
we use the transition function in order

00:18:53,120 --> 00:18:56,480
to create a new transition much like the

00:18:54,880 --> 00:18:57,520
rule or aspect functions if you've used

00:18:56,480 --> 00:18:58,960
those before

00:18:57,520 --> 00:19:00,000
we need an implementation function that

00:18:58,960 --> 00:19:01,440
i'll show you in a moment which will

00:19:00,000 --> 00:19:03,679
perform our actual

00:19:01,440 --> 00:19:05,520
business logic for this transition we

00:19:03,679 --> 00:19:07,039
also need a list of input flags and a

00:19:05,520 --> 00:19:08,799
list of output flags

00:19:07,039 --> 00:19:10,240
because again basil is bazel we need to

00:19:08,799 --> 00:19:10,960
explicitly declare dependencies on

00:19:10,240 --> 00:19:12,240
everything

00:19:10,960 --> 00:19:14,320
you thought we were going to get away

00:19:12,240 --> 00:19:15,679
with it for once but that's just not the

00:19:14,320 --> 00:19:17,760
case here

00:19:15,679 --> 00:19:19,600
the inputs are the flags that we want to

00:19:17,760 --> 00:19:21,679
read into our transition while the

00:19:19,600 --> 00:19:23,760
outputs are flags we want to write to

00:19:21,679 --> 00:19:25,679
from our transition in this case we want

00:19:23,760 --> 00:19:27,440
to read and write the same iv flag so

00:19:25,679 --> 00:19:30,160
that's the only one here

00:19:27,440 --> 00:19:31,520
for the actual implementation we define

00:19:30,160 --> 00:19:33,360
a new function that was referenced in

00:19:31,520 --> 00:19:35,840
the implementation parameter earlier

00:19:33,360 --> 00:19:37,679
this function receives two parameters

00:19:35,840 --> 00:19:39,360
first it gets a settings dictionary

00:19:37,679 --> 00:19:41,440
which contains the input configuration

00:19:39,360 --> 00:19:43,760
flags which we declared as inputs

00:19:41,440 --> 00:19:45,120
mapped to their current values in this

00:19:43,760 --> 00:19:46,640
case it would be a dictionary with the

00:19:45,120 --> 00:19:48,320
angular iv flag

00:19:46,640 --> 00:19:49,919
mapped to whatever its value in the

00:19:48,320 --> 00:19:51,280
configuration that we inherited

00:19:49,919 --> 00:19:54,640
this is essentially whatever the

00:19:51,280 --> 00:19:56,559
inherited value for iv flag is

00:19:54,640 --> 00:19:58,080
we also get an attributes object which

00:19:56,559 --> 00:19:59,360
contains all of the attributes of the

00:19:58,080 --> 00:20:02,240
current target such as

00:19:59,360 --> 00:20:03,919
name depths and most importantly the iv

00:20:02,240 --> 00:20:06,400
attribute

00:20:03,919 --> 00:20:08,080
for the actual implementation we start

00:20:06,400 --> 00:20:10,720
by checking if the user provided

00:20:08,080 --> 00:20:11,280
iv attribute and if so we want to change

00:20:10,720 --> 00:20:13,679
the iv

00:20:11,280 --> 00:20:15,840
flag and set it to true in order to do

00:20:13,679 --> 00:20:18,000
that we return the new configuration in

00:20:15,840 --> 00:20:20,400
the same format as the settings object

00:20:18,000 --> 00:20:21,120
in this case we just said slash angular

00:20:20,400 --> 00:20:25,120
iv flag

00:20:21,120 --> 00:20:27,280
to true now if iv attribute is not set

00:20:25,120 --> 00:20:29,440
we simply pass through or propagate the

00:20:27,280 --> 00:20:31,520
input configuration with no changes

00:20:29,440 --> 00:20:33,440
this is essentially saying just use the

00:20:31,520 --> 00:20:34,000
same configuration as my parent i don't

00:20:33,440 --> 00:20:36,960
want to change

00:20:34,000 --> 00:20:37,760
anything so transition logic is actually

00:20:36,960 --> 00:20:39,760
really simple

00:20:37,760 --> 00:20:41,039
and all it does is read flag values and

00:20:39,760 --> 00:20:42,480
return new values

00:20:41,039 --> 00:20:45,280
this whole talk is on transitions and

00:20:42,480 --> 00:20:48,400
yet the actual code fits on one slide

00:20:45,280 --> 00:20:49,600
i am lying a little bit uh there's one

00:20:48,400 --> 00:20:50,320
more thing we need to do which is that

00:20:49,600 --> 00:20:53,440
we need to

00:20:50,320 --> 00:20:55,200
simply add this to any affected rules in

00:20:53,440 --> 00:20:56,799
this case we need to update ngmodule and

00:20:55,200 --> 00:20:58,240
say that its configuration

00:20:56,799 --> 00:21:00,400
sets to the transition that we just

00:20:58,240 --> 00:21:03,039
created this will execute the transition

00:21:00,400 --> 00:21:04,559
for all ng module rules

00:21:03,039 --> 00:21:06,080
so now let's try it out in order to

00:21:04,559 --> 00:21:08,320
switch an application to iv all we need

00:21:06,080 --> 00:21:11,120
to do is add ib attribute equals true

00:21:08,320 --> 00:21:12,559
to its top level ng module then when we

00:21:11,120 --> 00:21:14,240
build this application we'll see that

00:21:12,559 --> 00:21:16,080
the binary the library and most

00:21:14,240 --> 00:21:17,760
importantly angular core all

00:21:16,080 --> 00:21:19,039
successfully built with ivy

00:21:17,760 --> 00:21:20,640
all of these targets are in agreement

00:21:19,039 --> 00:21:21,840
about the ib flag they will all build

00:21:20,640 --> 00:21:23,919
the same and they'll be able to work

00:21:21,840 --> 00:21:26,000
together at runtime

00:21:23,919 --> 00:21:27,200
separately if i build an entirely

00:21:26,000 --> 00:21:29,840
distinct application

00:21:27,200 --> 00:21:31,360
like app2 which does not set ivy then

00:21:29,840 --> 00:21:34,240
we'll find that it's binary

00:21:31,360 --> 00:21:35,760
its library and even angular core are

00:21:34,240 --> 00:21:36,880
all built without ivy

00:21:35,760 --> 00:21:38,240
again they're all in agreement and

00:21:36,880 --> 00:21:40,320
they're all able to build correctly and

00:21:38,240 --> 00:21:41,600
work together at runtime

00:21:40,320 --> 00:21:42,840
so let's back up a little bit and review

00:21:41,600 --> 00:21:45,120
what we were originally trying to

00:21:42,840 --> 00:21:45,360
accomplish we wanted to be able to opt

00:21:45,120 --> 00:21:47,360
in

00:21:45,360 --> 00:21:48,960
applications individually and we've

00:21:47,360 --> 00:21:50,880
successfully done that by enabling id

00:21:48,960 --> 00:21:53,120
for app one but by leaving app2

00:21:50,880 --> 00:21:54,720
alone the angular team also still

00:21:53,120 --> 00:21:56,320
controls ib attribute and we can

00:21:54,720 --> 00:21:58,159
manipulate its default value

00:21:56,320 --> 00:21:59,840
we can easily switch its default to true

00:21:58,159 --> 00:22:02,640
and make everybody build with iv

00:21:59,840 --> 00:22:02,960
when we're ready similarly we can opt

00:22:02,640 --> 00:22:04,640
out

00:22:02,960 --> 00:22:06,799
broken applications by having them just

00:22:04,640 --> 00:22:07,679
explicitly pass iv attribute equals

00:22:06,799 --> 00:22:08,960
false

00:22:07,679 --> 00:22:11,280
and they will be protected from the

00:22:08,960 --> 00:22:13,039
change in default value we can also

00:22:11,280 --> 00:22:15,200
leverage this as a rollback strategy

00:22:13,039 --> 00:22:17,120
when the default changes everyone moves

00:22:15,200 --> 00:22:18,240
to iv but if one application finds a

00:22:17,120 --> 00:22:19,840
production outage

00:22:18,240 --> 00:22:21,760
then they can simply add iv attribute

00:22:19,840 --> 00:22:23,600
equals false and it will roll them back

00:22:21,760 --> 00:22:25,520
without affecting anybody else

00:22:23,600 --> 00:22:27,440
the other 2500 applications still

00:22:25,520 --> 00:22:29,039
successfully roll out with ivy

00:22:27,440 --> 00:22:31,360
in both cases we're able to be

00:22:29,039 --> 00:22:32,080
consistent either everything is iv or

00:22:31,360 --> 00:22:33,280
nothing is

00:22:32,080 --> 00:22:35,919
and we've successfully solved that

00:22:33,280 --> 00:22:37,760
shared library problem from earlier

00:22:35,919 --> 00:22:39,440
so where are we right now as of the time

00:22:37,760 --> 00:22:41,039
of recording we have about 27

00:22:39,440 --> 00:22:42,320
applications which have launched ib2

00:22:41,039 --> 00:22:43,280
production using our transition

00:22:42,320 --> 00:22:44,799
infrastructure

00:22:43,280 --> 00:22:46,400
currently we're resolving a few of the

00:22:44,799 --> 00:22:48,000
remaining blockers and hoping to enable

00:22:46,400 --> 00:22:49,679
ivy by default soon

00:22:48,000 --> 00:22:51,280
one day you may soon see that all your

00:22:49,679 --> 00:22:53,120
favorite google angular applications are

00:22:51,280 --> 00:22:54,400
suddenly running much smaller and faster

00:22:53,120 --> 00:22:56,640
and all of this is enabled with the

00:22:54,400 --> 00:22:58,000
magical powers of bazel transitions

00:22:56,640 --> 00:22:59,360
so i hope this was informative and

00:22:58,000 --> 00:23:00,799
interesting and i look forward to seeing

00:22:59,360 --> 00:23:02,000
what the rest of the bazel community can

00:23:00,799 --> 00:23:09,840
do with transitions

00:23:02,000 --> 00:23:09,840
thanks for watching

00:23:21,039 --> 00:23:25,919
well thanks doug i'm super impressed

00:23:24,080 --> 00:23:27,600
with the power of bazel to help angular

00:23:25,919 --> 00:23:29,440
with their difficult problems migrating

00:23:27,600 --> 00:23:31,520
to ivy

00:23:29,440 --> 00:23:32,720
also today we have folks joining from

00:23:31,520 --> 00:23:34,880
across the globe

00:23:32,720 --> 00:23:36,640
i want to shout out to folks from canada

00:23:34,880 --> 00:23:38,799
germany belize

00:23:36,640 --> 00:23:39,679
and everyone connecting from asia it's

00:23:38,799 --> 00:23:43,039
pretty late there

00:23:39,679 --> 00:23:44,720
thanks for joining fun fact about belize

00:23:43,039 --> 00:23:46,080
you can get rice and beans at every

00:23:44,720 --> 00:23:49,279
restaurant no matter

00:23:46,080 --> 00:23:50,880
what else they serve and in belgium it's

00:23:49,279 --> 00:23:52,640
critical that beer be served in the

00:23:50,880 --> 00:23:54,720
proper glass so that that it was

00:23:52,640 --> 00:23:58,240
designed specifically for

00:23:54,720 --> 00:23:59,840
so as to ensure the best tasting beer

00:23:58,240 --> 00:24:01,760
there's not many questions in the live q

00:23:59,840 --> 00:24:04,799
a yet so feel free to

00:24:01,760 --> 00:24:08,480
add some or ask questions of the

00:24:04,799 --> 00:24:10,880
the speakers next we'll hear from lukash

00:24:08,480 --> 00:24:12,320
berkey about bazel for android open

00:24:10,880 --> 00:24:19,840
source platform

00:24:12,320 --> 00:24:19,840
take it away lukas

00:25:18,080 --> 00:25:22,480
hello there i'm lukasz berkey the tech

00:25:20,640 --> 00:25:24,080
lead of the bazel build tool

00:25:22,480 --> 00:25:26,720
today i would like to talk to you about

00:25:24,080 --> 00:25:27,520
one of the more significant significant

00:25:26,720 --> 00:25:29,440
projects

00:25:27,520 --> 00:25:30,720
which is to build android platform with

00:25:29,440 --> 00:25:32,640
bazel that is to say

00:25:30,720 --> 00:25:33,760
not individual android applications we

00:25:32,640 --> 00:25:36,320
can already do that

00:25:33,760 --> 00:25:38,000
but the operating system itself first i

00:25:36,320 --> 00:25:41,279
would like to talk to you a bit

00:25:38,000 --> 00:25:43,120
about the history and why we are doing

00:25:41,279 --> 00:25:43,679
this then i would like to talk to you

00:25:43,120 --> 00:25:46,080
about

00:25:43,679 --> 00:25:47,279
the difficulties there are and then i

00:25:46,080 --> 00:25:50,159
would like to talk

00:25:47,279 --> 00:25:51,279
to you about what exactly is happening

00:25:50,159 --> 00:25:54,400
and what

00:25:51,279 --> 00:25:58,000
accomplishments there are

00:25:54,400 --> 00:25:59,200
history long and storied i would like to

00:25:58,000 --> 00:26:02,159
not dwell too much

00:25:59,200 --> 00:26:03,919
on the individual items on this slide

00:26:02,159 --> 00:26:06,720
what is important is that

00:26:03,919 --> 00:26:08,240
both our both the internal monorepo and

00:26:06,720 --> 00:26:10,559
both android platform

00:26:08,240 --> 00:26:11,520
have a story that's almost two decades

00:26:10,559 --> 00:26:15,360
old

00:26:11,520 --> 00:26:18,720
both of them started out from make um

00:26:15,360 --> 00:26:21,440
and since then they have diverged aren't

00:26:18,720 --> 00:26:22,080
repo is using the internet version of

00:26:21,440 --> 00:26:24,799
bazel

00:26:22,080 --> 00:26:26,159
called blaze android is currently using

00:26:24,799 --> 00:26:28,799
a version of

00:26:26,159 --> 00:26:30,240
a bespoke built to code soon and still

00:26:28,799 --> 00:26:33,360
bits of make

00:26:30,240 --> 00:26:34,960
so why build android platform with bazel

00:26:33,360 --> 00:26:36,880
there are mathematicians both

00:26:34,960 --> 00:26:39,600
organizational and technical

00:26:36,880 --> 00:26:40,400
the organizational reasons are simpler

00:26:39,600 --> 00:26:42,159
which is to have

00:26:40,400 --> 00:26:44,559
one is sponsoring the solution to the

00:26:42,159 --> 00:26:45,840
same problem and not two

00:26:44,559 --> 00:26:47,679
this digit and the health of parallel

00:26:45,840 --> 00:26:49,679
development resulted in different

00:26:47,679 --> 00:26:52,159
solutions to the same problems

00:26:49,679 --> 00:26:53,600
and developers do find it hard to move

00:26:52,159 --> 00:26:55,360
from one word to the other

00:26:53,600 --> 00:26:57,440
i speak from experience i spent a whole

00:26:55,360 --> 00:26:59,120
lot of time in our internal monorepo

00:26:57,440 --> 00:27:01,360
and then when i started working on

00:26:59,120 --> 00:27:04,559
android it took me quite a bit of time

00:27:01,360 --> 00:27:06,159
to learn all the separate tools and

00:27:04,559 --> 00:27:07,840
it's better for other developers not to

00:27:06,159 --> 00:27:10,080
have the same experience or the opposite

00:27:07,840 --> 00:27:13,440
of it

00:27:10,080 --> 00:27:16,480
the technical benefits are also many

00:27:13,440 --> 00:27:20,000
first off we do a we do provide a

00:27:16,480 --> 00:27:22,320
way to execute these actions remotely

00:27:20,000 --> 00:27:23,760
which is important because android is a

00:27:22,320 --> 00:27:25,279
big operating system

00:27:23,760 --> 00:27:27,279
and one of the biggest companies there

00:27:25,279 --> 00:27:30,080
are is that

00:27:27,279 --> 00:27:31,679
builds are slow distributing the build

00:27:30,080 --> 00:27:34,640
over multiple computers

00:27:31,679 --> 00:27:35,360
helps with that bazel also provides a

00:27:34,640 --> 00:27:37,039
sandbox

00:27:35,360 --> 00:27:38,880
for individual actions which is

00:27:37,039 --> 00:27:39,760
important for incrementality that is to

00:27:38,880 --> 00:27:42,720
say

00:27:39,760 --> 00:27:44,960
this this is how bazel makes sure that

00:27:42,720 --> 00:27:47,200
when an input file is changed

00:27:44,960 --> 00:27:48,000
only those actions are redone that are

00:27:47,200 --> 00:27:50,480
actually affected

00:27:48,000 --> 00:27:51,679
by the change nothing more and nothing

00:27:50,480 --> 00:27:54,880
less

00:27:51,679 --> 00:27:56,720
this creates trust in the build tool

00:27:54,880 --> 00:27:59,600
because as anyone has ever said may

00:27:56,720 --> 00:28:02,799
clean knows that

00:27:59,600 --> 00:28:04,880
when this happens it can when

00:28:02,799 --> 00:28:06,240
incorrect incremental bills happen that

00:28:04,880 --> 00:28:08,159
can give rise to

00:28:06,240 --> 00:28:10,320
hours and hours of wasted time of

00:28:08,159 --> 00:28:12,799
debugging bayesia also provides

00:28:10,320 --> 00:28:14,159
a number of tools to look at the

00:28:12,799 --> 00:28:16,799
structure of the build

00:28:14,159 --> 00:28:18,640
for example to look at the structure of

00:28:16,799 --> 00:28:22,000
the action graph that is to say

00:28:18,640 --> 00:28:24,799
the graph that is composed by

00:28:22,000 --> 00:28:25,840
the actions and the input and the output

00:28:24,799 --> 00:28:28,240
files

00:28:25,840 --> 00:28:31,440
and the individual targets for example

00:28:28,240 --> 00:28:34,640
cpass or java binaries or libraries

00:28:31,440 --> 00:28:35,200
last but not least bazel has a vibrant

00:28:34,640 --> 00:28:37,520
community

00:28:35,200 --> 00:28:38,960
both inside and outside google which is

00:28:37,520 --> 00:28:40,159
useful for one to get started with

00:28:38,960 --> 00:28:42,720
building android

00:28:40,159 --> 00:28:44,640
of course life is not simple the next

00:28:42,720 --> 00:28:47,440
few slides will be about

00:28:44,640 --> 00:28:48,480
the difficulties that are on the way the

00:28:47,440 --> 00:28:50,080
root cause of almost all the

00:28:48,480 --> 00:28:52,880
difficulties there are

00:28:50,080 --> 00:28:53,600
is that uh as said before android

00:28:52,880 --> 00:28:56,880
platform

00:28:53,600 --> 00:29:00,320
and our internal model repo have

00:28:56,880 --> 00:29:00,720
different long histories now the good

00:29:00,320 --> 00:29:03,200
part

00:29:00,720 --> 00:29:05,200
is that song the build system for the

00:29:03,200 --> 00:29:05,679
majority of android was modeled after

00:29:05,200 --> 00:29:07,679
bazel

00:29:05,679 --> 00:29:09,440
and was developed with full knowledge of

00:29:07,679 --> 00:29:11,919
beta structure

00:29:09,440 --> 00:29:13,600
and the other good part is that

00:29:11,919 --> 00:29:15,200
android's build does not need to be

00:29:13,600 --> 00:29:19,200
fully converted to bazel

00:29:15,200 --> 00:29:21,200
to see benefits the best part is that

00:29:19,200 --> 00:29:22,720
even though song borrows some concept

00:29:21,200 --> 00:29:26,240
from bazel

00:29:22,720 --> 00:29:28,960
it's just not quite the same

00:29:26,240 --> 00:29:29,919
which makes the integration between the

00:29:28,960 --> 00:29:33,120
two tools

00:29:29,919 --> 00:29:33,679
hard and there will be a long migration

00:29:33,120 --> 00:29:36,320
phase

00:29:33,679 --> 00:29:37,120
because we cannot just wave a magic wand

00:29:36,320 --> 00:29:41,120
to

00:29:37,120 --> 00:29:44,159
turn soon into bazel even worse

00:29:41,120 --> 00:29:45,360
is that the migration to song has not

00:29:44,159 --> 00:29:48,159
been finished yet

00:29:45,360 --> 00:29:50,159
and therefore for a while there are

00:29:48,159 --> 00:29:52,880
going to be three build systems

00:29:50,159 --> 00:29:53,600
in android platform that is to say song

00:29:52,880 --> 00:29:56,880
make

00:29:53,600 --> 00:29:59,200
and bazel which makes interoperability

00:29:56,880 --> 00:29:59,919
not so easy of course there is a reason

00:29:59,200 --> 00:30:02,559
why song is

00:29:59,919 --> 00:30:04,159
different from bazel and that is mostly

00:30:02,559 --> 00:30:05,200
because the world of android is also

00:30:04,159 --> 00:30:08,559
different

00:30:05,200 --> 00:30:12,320
than the world of the internal monorepo

00:30:08,559 --> 00:30:12,880
bazel grew up in the international repo

00:30:12,320 --> 00:30:15,840
is a

00:30:12,880 --> 00:30:16,799
monorepo which means among other things

00:30:15,840 --> 00:30:18,640
that

00:30:16,799 --> 00:30:20,480
it's much more informed we have a

00:30:18,640 --> 00:30:23,520
uniform testing environment

00:30:20,480 --> 00:30:24,720
we have a uniform environment to deploy

00:30:23,520 --> 00:30:27,520
to okay not

00:30:24,720 --> 00:30:28,880
completely uniform but clearly it's much

00:30:27,520 --> 00:30:31,279
simpler

00:30:28,880 --> 00:30:33,279
than the land of android where there are

00:30:31,279 --> 00:30:35,600
many many different devices

00:30:33,279 --> 00:30:36,640
which all need to work in addition to

00:30:35,600 --> 00:30:38,880
that

00:30:36,640 --> 00:30:40,799
when one talks about android platform

00:30:38,880 --> 00:30:43,679
it's not really one codebase

00:30:40,799 --> 00:30:44,399
it's more like many different code bases

00:30:43,679 --> 00:30:47,760
the

00:30:44,399 --> 00:30:50,080
biggest difference is that there is aosp

00:30:47,760 --> 00:30:51,279
which is a large part of android but not

00:30:50,080 --> 00:30:53,440
all of it

00:30:51,279 --> 00:30:55,200
and there's the full android source 3

00:30:53,440 --> 00:30:57,840
but in addition to that

00:30:55,200 --> 00:30:59,440
different partners google works with

00:30:57,840 --> 00:31:01,200
that is to say

00:30:59,440 --> 00:31:02,799
companies who make chipsets or companies

00:31:01,200 --> 00:31:04,320
who make the actual devices

00:31:02,799 --> 00:31:06,080
have their own code they add or remove

00:31:04,320 --> 00:31:09,519
to android

00:31:06,080 --> 00:31:11,519
and there is also the effort to build

00:31:09,519 --> 00:31:13,679
to build parts of android separately

00:31:11,519 --> 00:31:16,880
such that they can be deployed

00:31:13,679 --> 00:31:18,799
separately to the actual devices

00:31:16,880 --> 00:31:20,559
that is to say to do partial system

00:31:18,799 --> 00:31:22,080
updates which is which is called project

00:31:20,559 --> 00:31:24,480
mainline

00:31:22,080 --> 00:31:25,519
in order to be to be certain that a part

00:31:24,480 --> 00:31:27,200
of the operating system

00:31:25,519 --> 00:31:29,120
can be deployed separately it also has

00:31:27,200 --> 00:31:30,080
to build separately which is yet another

00:31:29,120 --> 00:31:33,120
way to slice and

00:31:30,080 --> 00:31:33,600
dice the source tree android also comes

00:31:33,120 --> 00:31:35,919
from a

00:31:33,600 --> 00:31:37,840
hardware background unlike our monorepo

00:31:35,919 --> 00:31:40,480
which comes from a software background

00:31:37,840 --> 00:31:42,399
which is a salient in a number of ways

00:31:40,480 --> 00:31:46,320
for example

00:31:42,399 --> 00:31:50,159
android puts so much puts much more

00:31:46,320 --> 00:31:51,039
stress on integration testing that is to

00:31:50,159 --> 00:31:52,799
say

00:31:51,039 --> 00:31:55,200
uploading software to a natural piece of

00:31:52,799 --> 00:31:58,840
hardware and see

00:31:55,200 --> 00:32:01,039
if it works and less emphasis on unit

00:31:58,840 --> 00:32:03,039
testing that is to say testing

00:32:01,039 --> 00:32:04,640
a small piece of code separately this is

00:32:03,039 --> 00:32:07,600
the exact opposite what we have in

00:32:04,640 --> 00:32:08,480
our internal monorepo where the rule is

00:32:07,600 --> 00:32:11,279
unit testing

00:32:08,480 --> 00:32:12,000
with a few integration tests spin

00:32:11,279 --> 00:32:13,519
between

00:32:12,000 --> 00:32:15,760
and of course we have the biggest

00:32:13,519 --> 00:32:19,279
problem which is the problem of

00:32:15,760 --> 00:32:20,799
every developer that has ever maintained

00:32:19,279 --> 00:32:23,440
our code base with a long life

00:32:20,799 --> 00:32:24,080
which is legacy code now in the

00:32:23,440 --> 00:32:27,120
background

00:32:24,080 --> 00:32:28,720
you see cobol that we don't have but

00:32:27,120 --> 00:32:30,880
those almost two decades of history have

00:32:28,720 --> 00:32:34,000
resulted in code

00:32:30,880 --> 00:32:38,000
that is sometimes not so easy

00:32:34,000 --> 00:32:39,200
to live with so what's happening

00:32:38,000 --> 00:32:41,279
there are three projects that are

00:32:39,200 --> 00:32:42,320
happening at the moment the first is

00:32:41,279 --> 00:32:45,360
executing actions

00:32:42,320 --> 00:32:47,279
through bazel the second is uh

00:32:45,360 --> 00:32:49,600
doing the product configuration through

00:32:47,279 --> 00:32:52,640
stralak basis configuration language

00:32:49,600 --> 00:32:54,799
and the third is to run mixed builds

00:32:52,640 --> 00:32:58,000
with swung bezel and cutty

00:32:54,799 --> 00:33:01,279
kati is a term of art in android land

00:32:58,000 --> 00:33:06,880
it's a re-implementation of make that

00:33:01,279 --> 00:33:06,880
was done a few years ago for performance

00:33:07,039 --> 00:33:12,559
i would like to show the state of uh

00:33:10,320 --> 00:33:14,320
and androids builds before beta came

00:33:12,559 --> 00:33:16,559
around

00:33:14,320 --> 00:33:18,000
i understand this graph is somewhat

00:33:16,559 --> 00:33:20,480
complicated

00:33:18,000 --> 00:33:22,559
but the as but the essence is that the

00:33:20,480 --> 00:33:24,960
build consists of three steps

00:33:22,559 --> 00:33:26,480
first what you see on the left is the

00:33:24,960 --> 00:33:29,519
product configuration part

00:33:26,480 --> 00:33:31,120
where it is decided what exactly needs

00:33:29,519 --> 00:33:33,360
to be built

00:33:31,120 --> 00:33:35,200
its input is a bunch of make files that

00:33:33,360 --> 00:33:38,320
is processed by katy that is to say

00:33:35,200 --> 00:33:40,480
the rimpac make android has

00:33:38,320 --> 00:33:42,240
which turns it into a set of

00:33:40,480 --> 00:33:44,720
configuration variables

00:33:42,240 --> 00:33:46,480
these variables are ingested by song

00:33:44,720 --> 00:33:49,039
androids bespoke build tool

00:33:46,480 --> 00:33:51,279
and another instance of cutie which also

00:33:49,039 --> 00:33:52,960
take blueprint files and make files

00:33:51,279 --> 00:33:55,600
that is to say the configuration files

00:33:52,960 --> 00:33:58,640
of soon and cut it respectively

00:33:55,600 --> 00:34:00,320
and turn them into ninja files which

00:33:58,640 --> 00:34:02,000
are the description of the action graph

00:34:00,320 --> 00:34:05,440
that is to say the command lines

00:34:02,000 --> 00:34:08,240
that need to be done to do the build and

00:34:05,440 --> 00:34:09,679
their input and output files then after

00:34:08,240 --> 00:34:11,440
this

00:34:09,679 --> 00:34:14,720
a tool called ninja takes the ninja

00:34:11,440 --> 00:34:16,480
files and actually executes the builds

00:34:14,720 --> 00:34:18,320
where you want to be well where we want

00:34:16,480 --> 00:34:20,079
to be is much simpler

00:34:18,320 --> 00:34:21,839
we want to have build files that is to

00:34:20,079 --> 00:34:24,320
say the configuration files of bazel

00:34:21,839 --> 00:34:25,919
that describe both how to build things

00:34:24,320 --> 00:34:28,960
and what to build

00:34:25,919 --> 00:34:30,560
have it ingested by bazel and have

00:34:28,960 --> 00:34:32,079
executed resulting actions and output

00:34:30,560 --> 00:34:35,440
the system image

00:34:32,079 --> 00:34:37,440
so what is the state of the affairs now

00:34:35,440 --> 00:34:40,159
it's slightly more complicated because

00:34:37,440 --> 00:34:43,440
it's an intermediate phase

00:34:40,159 --> 00:34:45,760
on this diagram the green boxes

00:34:43,440 --> 00:34:46,839
are the pieces of code that are

00:34:45,760 --> 00:34:49,599
implemented for

00:34:46,839 --> 00:34:50,879
migration firstly for the product

00:34:49,599 --> 00:34:52,960
configuration

00:34:50,879 --> 00:34:54,000
there are two new tools one is to

00:34:52,960 --> 00:34:57,520
convert

00:34:54,000 --> 00:35:00,839
the make files to starlock files

00:34:57,520 --> 00:35:02,160
with the extension bcl that is to say

00:35:00,839 --> 00:35:04,000
bazel

00:35:02,160 --> 00:35:05,280
and a tool to interpret those busy

00:35:04,000 --> 00:35:08,320
alphas

00:35:05,280 --> 00:35:11,440
to emit the configuration variables that

00:35:08,320 --> 00:35:13,839
used to be emitted by kathy

00:35:11,440 --> 00:35:14,880
then in addition to sung and kathy we

00:35:13,839 --> 00:35:17,200
have bazel

00:35:14,880 --> 00:35:18,480
and build files it's config files and a

00:35:17,200 --> 00:35:21,280
tool to convert

00:35:18,480 --> 00:35:22,000
the configuration files of song to build

00:35:21,280 --> 00:35:24,720
files

00:35:22,000 --> 00:35:26,560
we call this tool bp to build that is to

00:35:24,720 --> 00:35:29,200
say bluepin to build

00:35:26,560 --> 00:35:31,040
currently bazel also emits ninja files

00:35:29,200 --> 00:35:33,839
in order to facilitate two different

00:35:31,040 --> 00:35:37,440
ways of executing actions

00:35:33,839 --> 00:35:40,400
the legacy mode with ninja and the

00:35:37,440 --> 00:35:40,960
new mode with bazel which gives one

00:35:40,400 --> 00:35:45,280
access

00:35:40,960 --> 00:35:47,839
to all the goodies beta provides

00:35:45,280 --> 00:35:49,599
these three work streams are in various

00:35:47,839 --> 00:35:50,960
tests of completion

00:35:49,599 --> 00:35:52,640
we are the further along with action

00:35:50,960 --> 00:35:55,359
execution

00:35:52,640 --> 00:35:57,359
bazel can run a full android build as

00:35:55,359 --> 00:35:59,200
the action executor

00:35:57,359 --> 00:36:00,800
what remains is to make sure that the

00:35:59,200 --> 00:36:01,280
action graph is well specified that is

00:36:00,800 --> 00:36:02,800
to say

00:36:01,280 --> 00:36:04,960
each action has its inputs and outputs

00:36:02,800 --> 00:36:06,720
declared properly which is important for

00:36:04,960 --> 00:36:09,119
incremental builds

00:36:06,720 --> 00:36:09,760
and to integrate baza's remote execution

00:36:09,119 --> 00:36:11,680
client

00:36:09,760 --> 00:36:13,359
into the build currently there's a way

00:36:11,680 --> 00:36:16,560
to run builds remotely

00:36:13,359 --> 00:36:18,160
using a code tool called reclient which

00:36:16,560 --> 00:36:20,400
is a common line tool that can be called

00:36:18,160 --> 00:36:21,599
either by ninja or by bazel

00:36:20,400 --> 00:36:23,359
the second workstream product

00:36:21,599 --> 00:36:25,440
configuration is also seeing good

00:36:23,359 --> 00:36:28,160
progress

00:36:25,440 --> 00:36:29,760
the make to starla conversion tool has

00:36:28,160 --> 00:36:32,800
been implemented

00:36:29,760 --> 00:36:33,760
and there are no numbers in it and there

00:36:32,800 --> 00:36:37,200
is good progress

00:36:33,760 --> 00:36:40,240
on integrating it into the actual build

00:36:37,200 --> 00:36:42,800
what remains is actually converting

00:36:40,240 --> 00:36:45,440
the make files to that bzr files and

00:36:42,800 --> 00:36:47,440
checking them into the source tree

00:36:45,440 --> 00:36:49,040
the largest challenges there are in the

00:36:47,440 --> 00:36:50,960
third works team that is to say

00:36:49,040 --> 00:36:54,000
integrating bazel into a build

00:36:50,960 --> 00:36:56,240
with sung and katie

00:36:54,000 --> 00:36:57,280
because that's when there need to be a

00:36:56,240 --> 00:36:58,720
conceptual mapping

00:36:57,280 --> 00:37:00,640
between the concepts on these three

00:36:58,720 --> 00:37:01,280
build systems and it turns out that all

00:37:00,640 --> 00:37:04,320
three

00:37:01,280 --> 00:37:07,599
have a complicated conceptual model

00:37:04,320 --> 00:37:10,400
that need to be reconciled somehow

00:37:07,599 --> 00:37:11,920
current work is being done on finding a

00:37:10,400 --> 00:37:13,200
mapping between the concepts of song and

00:37:11,920 --> 00:37:15,040
bazel

00:37:13,200 --> 00:37:17,040
cathy not so much because the world of

00:37:15,040 --> 00:37:19,599
cut is much simpler

00:37:17,040 --> 00:37:22,560
and there's progress on implementing an

00:37:19,599 --> 00:37:24,640
automatic conversion tool

00:37:22,560 --> 00:37:26,880
checking in build files instead of

00:37:24,640 --> 00:37:29,839
bluefin pies haven't been started yet

00:37:26,880 --> 00:37:30,880
we'll start once there's enough

00:37:29,839 --> 00:37:35,040
confidence about

00:37:30,880 --> 00:37:37,359
the the finality of set conversion tool

00:37:35,040 --> 00:37:39,200
i would like to talk about uh action

00:37:37,359 --> 00:37:42,560
execution that is to say

00:37:39,200 --> 00:37:44,720
using bazel as a better ninja this was a

00:37:42,560 --> 00:37:46,560
work that was much easier than expected

00:37:44,720 --> 00:37:48,560
mostly because the interface to action

00:37:46,560 --> 00:37:50,160
execution is pretty narrow

00:37:48,560 --> 00:37:52,880
an action after all is a very simple

00:37:50,160 --> 00:37:54,000
thing it has input files output files

00:37:52,880 --> 00:37:57,119
and a command line that one needs to

00:37:54,000 --> 00:38:00,079
execute the work required some

00:37:57,119 --> 00:38:00,480
design compromises in bazel but nothing

00:38:00,079 --> 00:38:04,079
too

00:38:00,480 --> 00:38:06,800
serious and it actually worked

00:38:04,079 --> 00:38:08,560
while by requiring only very small

00:38:06,800 --> 00:38:10,480
changes to another platform

00:38:08,560 --> 00:38:12,960
mostly to specify a missing input or

00:38:10,480 --> 00:38:15,760
outputs uh here and there

00:38:12,960 --> 00:38:16,800
this is not default yet but i'm very

00:38:15,760 --> 00:38:18,640
confident that

00:38:16,800 --> 00:38:20,880
beza can actually work as an action

00:38:18,640 --> 00:38:23,200
executor and it provides a bunch of

00:38:20,880 --> 00:38:25,839
benefits already

00:38:23,200 --> 00:38:26,640
one can use bazel's remote execution

00:38:25,839 --> 00:38:29,359
engine

00:38:26,640 --> 00:38:31,440
one can use basis action sandbox one can

00:38:29,359 --> 00:38:34,400
use bazel to query the action graph

00:38:31,440 --> 00:38:35,119
of the build and bazel also provides

00:38:34,400 --> 00:38:37,760
change pruning

00:38:35,119 --> 00:38:39,119
that is to say the ability not to

00:38:37,760 --> 00:38:41,200
re-execute an action

00:38:39,119 --> 00:38:43,200
when it's abstinence have been executed

00:38:41,200 --> 00:38:45,839
but did not change their output files

00:38:43,200 --> 00:38:47,599
for example when you add a comment to a

00:38:45,839 --> 00:38:50,720
setup a source file

00:38:47,599 --> 00:38:52,240
then the compile is executed but the

00:38:50,720 --> 00:38:54,480
object file it emits

00:38:52,240 --> 00:38:56,720
is not changed therefore you don't need

00:38:54,480 --> 00:38:58,480
to actually rerun the linker

00:38:56,720 --> 00:39:00,160
the product configuration is a more

00:38:58,480 --> 00:39:04,480
interesting part because

00:39:00,160 --> 00:39:07,599
it's unique to android it's uh

00:39:04,480 --> 00:39:10,560
a part of android that is not

00:39:07,599 --> 00:39:11,359
touched very frequently and therefore

00:39:10,560 --> 00:39:13,200
there is

00:39:11,359 --> 00:39:14,480
there is not a lot of knowledge spread

00:39:13,200 --> 00:39:17,839
about it

00:39:14,480 --> 00:39:19,200
at google and that partners it drives

00:39:17,839 --> 00:39:22,000
it's a way to

00:39:19,200 --> 00:39:23,599
describe in a modular fashion what

00:39:22,000 --> 00:39:24,480
exactly needs to be part of a system

00:39:23,599 --> 00:39:27,520
image

00:39:24,480 --> 00:39:31,119
and it's built on the 1976 vintage

00:39:27,520 --> 00:39:33,200
make build tool the idea is to

00:39:31,119 --> 00:39:35,280
say things like i want to build this

00:39:33,200 --> 00:39:38,720
device and this device should be

00:39:35,280 --> 00:39:42,000
have an aosp image but with this

00:39:38,720 --> 00:39:42,880
android app in addition and with a few

00:39:42,000 --> 00:39:48,400
parts

00:39:42,880 --> 00:39:51,680
removed since it's built on top of make

00:39:48,400 --> 00:39:55,359
there isn't a lot of error checking

00:39:51,680 --> 00:39:57,680
in there and it's not very well tested

00:39:55,359 --> 00:39:59,839
but on the flip side the make files

00:39:57,680 --> 00:40:02,880
describing the product configuration

00:39:59,839 --> 00:40:04,400
are well structured and kind of easy to

00:40:02,880 --> 00:40:07,200
understand what they want to do

00:40:04,400 --> 00:40:08,640
which is to our advantage because it

00:40:07,200 --> 00:40:12,240
makes it easy

00:40:08,640 --> 00:40:13,760
to build a parser actually i'm saying

00:40:12,240 --> 00:40:16,400
parser but sometimes

00:40:13,760 --> 00:40:16,960
one doesn't actually need to pass make

00:40:16,400 --> 00:40:20,400
one can

00:40:16,960 --> 00:40:22,800
only use a text based method to

00:40:20,400 --> 00:40:25,040
understand them and to turn them into

00:40:22,800 --> 00:40:27,599
stalk files

00:40:25,040 --> 00:40:29,200
here's an example of how a make file

00:40:27,599 --> 00:40:32,000
looks like

00:40:29,200 --> 00:40:32,560
that is to say this product should be

00:40:32,000 --> 00:40:35,359
like

00:40:32,560 --> 00:40:37,359
cuttlefish with a package called

00:40:35,359 --> 00:40:40,079
craftsvm

00:40:37,359 --> 00:40:41,119
in addition and so on and here is how

00:40:40,079 --> 00:40:43,280
the same concept

00:40:41,119 --> 00:40:45,440
would look like when described instant

00:40:43,280 --> 00:40:45,440
arc

00:40:48,319 --> 00:40:51,920
the last thing i would like to talk

00:40:49,440 --> 00:40:52,400
about is mixed mode mobiles that is to

00:40:51,920 --> 00:40:54,720
say

00:40:52,400 --> 00:40:56,079
making sung and bezel and today sergey

00:40:54,720 --> 00:40:58,480
katie

00:40:56,079 --> 00:41:00,400
interoperate with each other the end is

00:40:58,480 --> 00:41:02,079
out of this system

00:41:00,400 --> 00:41:04,400
will be a tool to convert the

00:41:02,079 --> 00:41:07,119
configuration configuration files of

00:41:04,400 --> 00:41:09,200
song that is to say blueprint files into

00:41:07,119 --> 00:41:12,240
those of bazel that is to say

00:41:09,200 --> 00:41:15,760
busy files we wanted this tool to be

00:41:12,240 --> 00:41:16,960
mostly automatic because that's the only

00:41:15,760 --> 00:41:20,000
way we can migrate

00:41:16,960 --> 00:41:20,720
the code scale it will probably not

00:41:20,000 --> 00:41:22,960
happen

00:41:20,720 --> 00:41:23,760
it will probably need some some manual

00:41:22,960 --> 00:41:26,160
help

00:41:23,760 --> 00:41:27,440
because uh both sung and bezel have rich

00:41:26,160 --> 00:41:30,400
conceptual models

00:41:27,440 --> 00:41:31,920
and there is no no point in implementing

00:41:30,400 --> 00:41:32,640
an automatic mechanism for migrating

00:41:31,920 --> 00:41:34,240
things

00:41:32,640 --> 00:41:37,680
that is used just once or twice in the

00:41:34,240 --> 00:41:39,920
code base but we do want to

00:41:37,680 --> 00:41:42,800
the overall majority of the migration to

00:41:39,920 --> 00:41:42,800
be automatic

00:41:42,880 --> 00:41:46,720
the reason why this is difficult is that

00:41:44,960 --> 00:41:48,960
because

00:41:46,720 --> 00:41:50,640
sung and bazel are extensible in

00:41:48,960 --> 00:41:53,040
different ways

00:41:50,640 --> 00:41:53,839
soon is extremely extensible in go which

00:41:53,040 --> 00:41:56,960
means that

00:41:53,839 --> 00:41:59,280
extensions can use the full power of go

00:41:56,960 --> 00:42:00,079
and bazel is accessible in starlark

00:41:59,280 --> 00:42:01,680
which is a

00:42:00,079 --> 00:42:03,920
very limited programming language with a

00:42:01,680 --> 00:42:06,960
very limited api

00:42:03,920 --> 00:42:11,040
we want to market code that

00:42:06,960 --> 00:42:13,119
can do more to a system that can do less

00:42:11,040 --> 00:42:14,160
now stalac has limitations for a very

00:42:13,119 --> 00:42:16,079
good reason

00:42:14,160 --> 00:42:17,520
this is what provides opportunities for

00:42:16,079 --> 00:42:20,720
bezel to

00:42:17,520 --> 00:42:22,319
do sophisticated ways of caching but

00:42:20,720 --> 00:42:24,400
it's a difficulty

00:42:22,319 --> 00:42:25,680
the other difficulty we are facing is

00:42:24,400 --> 00:42:27,599
that we don't want to make

00:42:25,680 --> 00:42:28,720
the lives of people who work with

00:42:27,599 --> 00:42:32,319
android

00:42:28,720 --> 00:42:34,319
hardware not even temporarily

00:42:32,319 --> 00:42:37,040
which means that we have to be careful

00:42:34,319 --> 00:42:38,400
to slot bazel into the blade process in

00:42:37,040 --> 00:42:40,240
such a way

00:42:38,400 --> 00:42:42,000
that it doesn't make build slower or

00:42:40,240 --> 00:42:45,200
less comprehensible

00:42:42,000 --> 00:42:48,160
admittedly is difficult so what is it

00:42:45,200 --> 00:42:49,119
that has already been accomplished on

00:42:48,160 --> 00:42:50,960
bionic

00:42:49,119 --> 00:42:52,720
there's good progress we can build

00:42:50,960 --> 00:42:56,160
bionic you know in such a way

00:42:52,720 --> 00:42:59,520
that is a bit by bit the same as

00:42:56,160 --> 00:43:03,200
the build done without bazel

00:42:59,520 --> 00:43:06,400
what remains however is building bionic

00:43:03,200 --> 00:43:08,880
in all the various ways that

00:43:06,400 --> 00:43:10,560
in which it's built within the build for

00:43:08,880 --> 00:43:13,440
example

00:43:10,560 --> 00:43:14,160
it's built with various sanitizers acn

00:43:13,440 --> 00:43:17,200
ubison

00:43:14,160 --> 00:43:18,560
and so and so forth it's built

00:43:17,200 --> 00:43:21,040
so as to provide the interface for

00:43:18,560 --> 00:43:23,599
various android api levels

00:43:21,040 --> 00:43:24,640
such that it can be against by

00:43:23,599 --> 00:43:27,760
applications

00:43:24,640 --> 00:43:31,119
requiring those various api levels

00:43:27,760 --> 00:43:32,720
all this remains executing

00:43:31,119 --> 00:43:36,000
the actions comprising the build with

00:43:32,720 --> 00:43:38,240
bazel is mostly risk free

00:43:36,000 --> 00:43:41,359
the pixel 3 system image can be built

00:43:38,240 --> 00:43:43,040
with bezel without problems

00:43:41,359 --> 00:43:45,119
which means that i'm pretty confident

00:43:43,040 --> 00:43:49,520
that everything else can be do

00:43:45,119 --> 00:43:52,880
but it's pixel 3 we tested it with

00:43:49,520 --> 00:43:54,160
and now one can start adding edges to

00:43:52,880 --> 00:43:56,720
the action graph

00:43:54,160 --> 00:43:59,040
to make it fully declared and

00:43:56,720 --> 00:44:01,680
incremental

00:43:59,040 --> 00:44:02,960
i also consider product configuration a

00:44:01,680 --> 00:44:06,160
source problem

00:44:02,960 --> 00:44:09,200
it's not integrated yet into the build

00:44:06,160 --> 00:44:11,200
but the translator is not operational

00:44:09,200 --> 00:44:12,960
and there are no known bags on a full

00:44:11,200 --> 00:44:13,680
build which means that there are

00:44:12,960 --> 00:44:16,640
probably no

00:44:13,680 --> 00:44:18,400
serious bugs that remain so it appears

00:44:16,640 --> 00:44:22,480
that most of the risk in the past

00:44:18,400 --> 00:44:24,240
there is some risk left and i think that

00:44:22,480 --> 00:44:26,160
a large part of the disk will begin by

00:44:24,240 --> 00:44:27,680
the time we can build bionic

00:44:26,160 --> 00:44:30,720
in all the ways that it needs to be

00:44:27,680 --> 00:44:32,720
built during a full build

00:44:30,720 --> 00:44:34,400
but all in all i'm happy with the

00:44:32,720 --> 00:44:37,359
progress so far

00:44:34,400 --> 00:44:38,480
on to the future thank you for listening

00:44:37,359 --> 00:44:40,160
to this talk

00:44:38,480 --> 00:44:51,839
and i hope you will follow further

00:44:40,160 --> 00:44:51,839
developments on this project

00:44:58,319 --> 00:45:03,440
thank you lukash bazel for android

00:45:01,040 --> 00:45:05,280
platform is an ambitious project

00:45:03,440 --> 00:45:06,640
that will have lots of great impact on

00:45:05,280 --> 00:45:07,280
android platform developers their

00:45:06,640 --> 00:45:09,599
workflow

00:45:07,280 --> 00:45:10,800
and build and test times next we'll hear

00:45:09,599 --> 00:45:13,920
from alex eagle

00:45:10,800 --> 00:45:19,839
on that one api to help accelerate

00:45:13,920 --> 00:45:19,839
your migration to bazel take it away

00:46:44,400 --> 00:46:48,240
hi everyone i'm so excited to be with

00:46:46,079 --> 00:46:50,000
you today my name is alex eagle i'm the

00:46:48,240 --> 00:46:51,359
author and one of the co-maintainers for

00:46:50,000 --> 00:46:53,040
rules node.js

00:46:51,359 --> 00:46:54,720
i also recently became a maintainer for

00:46:53,040 --> 00:46:56,400
rules python uh

00:46:54,720 --> 00:46:57,839
formerly i was at google on the angular

00:46:56,400 --> 00:46:58,400
team and i was one of the team that

00:46:57,839 --> 00:47:00,640
rolled out

00:46:58,400 --> 00:47:02,400
typescript language into blaze google's

00:47:00,640 --> 00:47:04,079
internal version of bazel

00:47:02,400 --> 00:47:05,839
and now i'm working to migrate

00:47:04,079 --> 00:47:07,599
enterprises to bazel

00:47:05,839 --> 00:47:09,119
uh before i start i just want to say how

00:47:07,599 --> 00:47:10,960
much i miss interacting with all of you

00:47:09,119 --> 00:47:12,480
at bazelcon in the hallway track like we

00:47:10,960 --> 00:47:13,839
did the last three years and i hope we

00:47:12,480 --> 00:47:16,160
get to do that again soon

00:47:13,839 --> 00:47:17,599
so my talk today is about migrations and

00:47:16,160 --> 00:47:18,160
how to make them easier for your

00:47:17,599 --> 00:47:20,640
business

00:47:18,160 --> 00:47:22,640
and as we observed last year in my talk

00:47:20,640 --> 00:47:24,960
with greg mcgolan at basil con

00:47:22,640 --> 00:47:26,319
bazel migrations have a lot of risks so

00:47:24,960 --> 00:47:27,680
you might introduce a bug

00:47:26,319 --> 00:47:29,920
because you made a change in the build

00:47:27,680 --> 00:47:30,480
system it can certainly take longer than

00:47:29,920 --> 00:47:31,760
you thought

00:47:30,480 --> 00:47:34,480
it can cause problems for your

00:47:31,760 --> 00:47:36,400
developers and in our talk we were

00:47:34,480 --> 00:47:38,000
we went over ways to mitigate risks and

00:47:36,400 --> 00:47:41,119
today i want to dive deeply into

00:47:38,000 --> 00:47:43,359
one of those which is only change

00:47:41,119 --> 00:47:44,880
one thing at a time the reason we do

00:47:43,359 --> 00:47:46,480
that is that it's much easier if

00:47:44,880 --> 00:47:48,160
something breaks then we know what

00:47:46,480 --> 00:47:49,839
caused it and we can keep things simple

00:47:48,160 --> 00:47:52,400
and it's easier to reduce that breakage

00:47:49,839 --> 00:47:54,720
down to one precise cause but what we

00:47:52,400 --> 00:47:56,400
often find is that it's hard to avoid

00:47:54,720 --> 00:47:58,720
being forced to change something in your

00:47:56,400 --> 00:47:59,920
build you may find that there's some

00:47:58,720 --> 00:48:01,280
existing part of your legacy build

00:47:59,920 --> 00:48:02,640
system that just doesn't seem to work

00:48:01,280 --> 00:48:04,400
with bazel

00:48:02,640 --> 00:48:06,880
and in my experience there's one api

00:48:04,400 --> 00:48:08,480
that we can learn that helps us to

00:48:06,880 --> 00:48:10,559
to avoid having to make those kinds of

00:48:08,480 --> 00:48:13,839
changes in the tools that we call

00:48:10,559 --> 00:48:15,440
and that api is simply the process

00:48:13,839 --> 00:48:16,880
you're probably used to seeing processes

00:48:15,440 --> 00:48:18,319
on your machine you may not think about

00:48:16,880 --> 00:48:20,319
them that much

00:48:18,319 --> 00:48:21,920
but there is actually an api here it's

00:48:20,319 --> 00:48:24,240
available everywhere

00:48:21,920 --> 00:48:25,839
um and it's this is how bazel interacts

00:48:24,240 --> 00:48:27,280
with the tools that you're running

00:48:25,839 --> 00:48:29,200
so if you can think in terms of this

00:48:27,280 --> 00:48:31,599
process api i think that helps you

00:48:29,200 --> 00:48:33,119
to adapt bazel and the and the way that

00:48:31,599 --> 00:48:34,640
you're calling your tools

00:48:33,119 --> 00:48:36,160
rather than having to change the tools

00:48:34,640 --> 00:48:38,079
that you run

00:48:36,160 --> 00:48:40,079
so briefly let's just remind ourselves

00:48:38,079 --> 00:48:40,480
what a process is this is how programs

00:48:40,079 --> 00:48:42,160
are run

00:48:40,480 --> 00:48:43,760
on your computer every tool that you're

00:48:42,160 --> 00:48:45,359
running today in your build in your

00:48:43,760 --> 00:48:46,640
legacy build is running inside of a

00:48:45,359 --> 00:48:48,880
process

00:48:46,640 --> 00:48:50,160
a process works everywhere in every

00:48:48,880 --> 00:48:52,000
language has great support for

00:48:50,160 --> 00:48:54,079
interacting with processes

00:48:52,000 --> 00:48:55,760
and it works on unix type systems

00:48:54,079 --> 00:48:57,040
including mac and also everything i'm

00:48:55,760 --> 00:49:00,079
going to talk about is almost

00:48:57,040 --> 00:49:02,400
translatable to windows

00:49:00,079 --> 00:49:03,680
and so i think this is a great general

00:49:02,400 --> 00:49:06,720
purpose um

00:49:03,680 --> 00:49:08,319
way to think about the problem the one

00:49:06,720 --> 00:49:09,599
slide i want you to remember from this

00:49:08,319 --> 00:49:11,760
talk

00:49:09,599 --> 00:49:13,280
is that you may hear someone say that

00:49:11,760 --> 00:49:15,599
tool doesn't work with bazel

00:49:13,280 --> 00:49:17,280
and this should be uh the sign to you

00:49:15,599 --> 00:49:19,119
this is this is a this is a trigger

00:49:17,280 --> 00:49:22,319
uh and you say why not is that really

00:49:19,119 --> 00:49:24,720
true i find that it's often not true

00:49:22,319 --> 00:49:26,319
the main reason you can tell that uh you

00:49:24,720 --> 00:49:28,000
can challenge that statement

00:49:26,319 --> 00:49:30,240
is to simply ask how can the tool tell

00:49:28,000 --> 00:49:32,319
that it was called by bazel

00:49:30,240 --> 00:49:34,480
um how was it called before in the

00:49:32,319 --> 00:49:37,280
legacy build system

00:49:34,480 --> 00:49:39,200
and if we can figure out all the parts

00:49:37,280 --> 00:49:40,720
of this process api and make everything

00:49:39,200 --> 00:49:41,839
look the same way it did when the tool

00:49:40,720 --> 00:49:43,280
was called under the old

00:49:41,839 --> 00:49:44,960
build system then it should work exactly

00:49:43,280 --> 00:49:46,720
the same way

00:49:44,960 --> 00:49:48,400
so in this talk i'll give some practical

00:49:46,720 --> 00:49:50,079
workarounds for some scenarios that we

00:49:48,400 --> 00:49:52,559
ran into while we were developing

00:49:50,079 --> 00:49:53,839
rules uh node.js and applying them at

00:49:52,559 --> 00:49:56,640
companies

00:49:53,839 --> 00:49:57,040
um but i do want to call out that this

00:49:56,640 --> 00:49:58,319
is not

00:49:57,040 --> 00:50:01,119
all there's there are trade-offs being

00:49:58,319 --> 00:50:02,240
made here um in some cases in order to

00:50:01,119 --> 00:50:03,760
make your tools work

00:50:02,240 --> 00:50:05,280
you're going to give up some of bazel's

00:50:03,760 --> 00:50:06,480
goodness in some part of your build

00:50:05,280 --> 00:50:09,040
graph so we're going to trade off

00:50:06,480 --> 00:50:10,160
compatibility for optimizations

00:50:09,040 --> 00:50:11,760
this is something you have to think

00:50:10,160 --> 00:50:12,800
about in the in the context of your

00:50:11,760 --> 00:50:14,240
migration

00:50:12,800 --> 00:50:15,920
it might make sense to have these sort

00:50:14,240 --> 00:50:17,440
of d optimizations at the beginning in

00:50:15,920 --> 00:50:17,839
order to get everything working the same

00:50:17,440 --> 00:50:20,400
way

00:50:17,839 --> 00:50:22,160
and then you can find the slowest parts

00:50:20,400 --> 00:50:25,119
of your build and then just evolve those

00:50:22,160 --> 00:50:26,960
uh those sub parts of the graph so one

00:50:25,119 --> 00:50:29,839
example of a trade-off

00:50:26,960 --> 00:50:31,520
is that the swift compiler can be much

00:50:29,839 --> 00:50:33,280
much slower by orders of magnitude if it

00:50:31,520 --> 00:50:34,480
doesn't find the incrementality bits

00:50:33,280 --> 00:50:36,480
from its previous run

00:50:34,480 --> 00:50:37,680
and so if we think about simply running

00:50:36,480 --> 00:50:38,800
the swift compiler as just some

00:50:37,680 --> 00:50:41,200
arbitrary process

00:50:38,800 --> 00:50:42,480
then it may be a lot slower that's the

00:50:41,200 --> 00:50:43,599
kind of trade-off that we may need to

00:50:42,480 --> 00:50:46,800
make

00:50:43,599 --> 00:50:48,640
so uh let's just look at one example of

00:50:46,800 --> 00:50:50,559
how bazel calls a tool

00:50:48,640 --> 00:50:52,000
i'm using general here because i love

00:50:50,559 --> 00:50:53,680
gen rule but

00:50:52,000 --> 00:50:55,200
really any time bazel calls a tool you

00:50:53,680 --> 00:50:56,960
can think of it this way it may just be

00:50:55,200 --> 00:50:58,800
that if you're using a custom rule

00:50:56,960 --> 00:51:00,319
you don't see the tool spelled out like

00:50:58,800 --> 00:51:02,000
it is here and you don't see the command

00:51:00,319 --> 00:51:03,520
line that it's calling but if you unwrap

00:51:02,000 --> 00:51:04,880
the implementation of a rule

00:51:03,520 --> 00:51:06,200
you'll always find somewhere that it's

00:51:04,880 --> 00:51:07,599
calling something like

00:51:06,200 --> 00:51:11,599
context.action.run

00:51:07,599 --> 00:51:11,599
and calling out to a tool in this way

00:51:12,480 --> 00:51:18,160
so for this example the tool is yq this

00:51:15,760 --> 00:51:19,920
is a variant of jq the popular json

00:51:18,160 --> 00:51:22,559
manipulation library

00:51:19,920 --> 00:51:23,920
application and it handles yaml files

00:51:22,559 --> 00:51:25,040
and so this one is just converting yaml

00:51:23,920 --> 00:51:26,559
to json

00:51:25,040 --> 00:51:28,240
and it happens here you can see that the

00:51:26,559 --> 00:51:29,760
command line um

00:51:28,240 --> 00:51:31,359
has some flags that we're passing to

00:51:29,760 --> 00:51:32,880
this tool and those are sufficient in

00:51:31,359 --> 00:51:34,559
this case to make the tool work the way

00:51:32,880 --> 00:51:36,880
you expect under bazel to read inputs

00:51:34,559 --> 00:51:38,240
and produce outputs so this example is

00:51:36,880 --> 00:51:39,119
fine but we're going to go through the

00:51:38,240 --> 00:51:42,319
rest of this talk

00:51:39,119 --> 00:51:44,079
with imagining that we're running a tool

00:51:42,319 --> 00:51:47,760
where this is not the case and something

00:51:44,079 --> 00:51:49,200
is not possible to run so one option for

00:51:47,760 --> 00:51:49,599
how to change the way the program is

00:51:49,200 --> 00:51:51,119
called

00:51:49,599 --> 00:51:53,359
is to find some way to change the

00:51:51,119 --> 00:51:56,559
behavior of the existing run time

00:51:53,359 --> 00:51:58,079
so this is a little hacky but one

00:51:56,559 --> 00:51:59,920
example under node is that there's a

00:51:58,079 --> 00:52:01,520
flag dash dash required that lets you

00:51:59,920 --> 00:52:03,040
run some bit of arbitrary script right

00:52:01,520 --> 00:52:04,960
before the program starts

00:52:03,040 --> 00:52:07,040
another example is in java you can pass

00:52:04,960 --> 00:52:08,559
the class path argument to the jvm which

00:52:07,040 --> 00:52:10,400
allows you to

00:52:08,559 --> 00:52:12,640
do something like maybe shadow an

00:52:10,400 --> 00:52:15,599
existing class to change its behavior

00:52:12,640 --> 00:52:17,440
this is obviously risky because it's

00:52:15,599 --> 00:52:18,720
easy for monkey patching to cause weird

00:52:17,440 --> 00:52:20,640
action at a distance

00:52:18,720 --> 00:52:21,839
bugs in the program so be really careful

00:52:20,640 --> 00:52:23,680
doing this option

00:52:21,839 --> 00:52:25,359
do like a single one-liner i'll show an

00:52:23,680 --> 00:52:27,440
example of this later

00:52:25,359 --> 00:52:29,200
another option is to change the entry

00:52:27,440 --> 00:52:31,440
point of the program

00:52:29,200 --> 00:52:33,359
but staying within the same process so

00:52:31,440 --> 00:52:35,119
essentially you take that tool and

00:52:33,359 --> 00:52:36,800
instead of calling it as a process you

00:52:35,119 --> 00:52:38,960
call it as a library you find wherever

00:52:36,800 --> 00:52:39,760
that cli entry point is and as close as

00:52:38,960 --> 00:52:41,839
possible

00:52:39,760 --> 00:52:44,160
try to invoke it the same way and that

00:52:41,839 --> 00:52:46,000
gives you just a little bit of room to

00:52:44,160 --> 00:52:48,000
swap in your own logic at the top of the

00:52:46,000 --> 00:52:50,160
program to change the way it runs

00:52:48,000 --> 00:52:51,839
this is nice because it allows you to

00:52:50,160 --> 00:52:53,520
have more power inside of that same

00:52:51,839 --> 00:52:55,599
process you can do things like mutate

00:52:53,520 --> 00:52:58,880
the arguments

00:52:55,599 --> 00:52:59,760
and that would be harder to do in the

00:52:58,880 --> 00:53:01,680
third option

00:52:59,760 --> 00:53:03,599
which is the most common option where

00:53:01,680 --> 00:53:05,280
you'll just run some extra program as a

00:53:03,599 --> 00:53:06,720
parent process

00:53:05,280 --> 00:53:08,640
this is typically something like a bash

00:53:06,720 --> 00:53:10,160
script and it just

00:53:08,640 --> 00:53:11,839
does some sort of tweaks to the way the

00:53:10,160 --> 00:53:14,480
process is being run and then it invokes

00:53:11,839 --> 00:53:15,760
the original tool as a child process

00:53:14,480 --> 00:53:17,680
for the rest of the talk i'm going to

00:53:15,760 --> 00:53:18,880
dive into the specifics of the process

00:53:17,680 --> 00:53:20,319
api

00:53:18,880 --> 00:53:22,880
and how to use one of those three

00:53:20,319 --> 00:53:24,480
wrapper approaches to make the execution

00:53:22,880 --> 00:53:25,680
match the way it ran under your legacy

00:53:24,480 --> 00:53:27,520
build

00:53:25,680 --> 00:53:29,280
so the first things i'll group is as

00:53:27,520 --> 00:53:31,280
roughly the inputs to the process

00:53:29,280 --> 00:53:32,880
so it takes a list of arguments

00:53:31,280 --> 00:53:34,160
obviously here you must take a lot of

00:53:32,880 --> 00:53:35,599
care with things like spaces and

00:53:34,160 --> 00:53:37,280
escaping so that the arguments are

00:53:35,599 --> 00:53:38,400
preserved exactly when bazel calls the

00:53:37,280 --> 00:53:40,400
program

00:53:38,400 --> 00:53:42,160
it can read a dictionary of key value

00:53:40,400 --> 00:53:44,400
pairs from the environment

00:53:42,160 --> 00:53:46,160
it can run in a working directory and

00:53:44,400 --> 00:53:46,960
usually most of the paths that that the

00:53:46,160 --> 00:53:48,640
tool are going to

00:53:46,960 --> 00:53:51,119
work with are relative to that working

00:53:48,640 --> 00:53:52,480
directory and it reads bytes from its

00:53:51,119 --> 00:53:54,480
standard input

00:53:52,480 --> 00:53:55,839
so let's dive into a few of those i'm

00:53:54,480 --> 00:53:57,520
just going to give a few examples here

00:53:55,839 --> 00:53:58,880
this is not meant to be an exhaustive

00:53:57,520 --> 00:54:00,319
list but this is sort of how

00:53:58,880 --> 00:54:02,240
in rules node.js we've thought about

00:54:00,319 --> 00:54:04,240
using this process api to fix some of

00:54:02,240 --> 00:54:06,240
the compatibility issues

00:54:04,240 --> 00:54:08,319
so uh when dealing with arguments for

00:54:06,240 --> 00:54:10,319
example you might find that your rapper

00:54:08,319 --> 00:54:12,240
needs some of its own arguments

00:54:10,319 --> 00:54:14,160
so if you're in process you can just

00:54:12,240 --> 00:54:15,839
mutate the arg v just strip some things

00:54:14,160 --> 00:54:17,680
off of it

00:54:15,839 --> 00:54:20,720
assuming that your language runtime has

00:54:17,680 --> 00:54:22,800
a mutable version of the arcv

00:54:20,720 --> 00:54:24,000
or an apparent process you can just take

00:54:22,800 --> 00:54:25,440
some of the arguments yourself

00:54:24,000 --> 00:54:27,280
and then selectively forward some of

00:54:25,440 --> 00:54:28,880
them onto the child process

00:54:27,280 --> 00:54:30,800
so one example we've had is a test

00:54:28,880 --> 00:54:33,040
runner where we needed to pass some

00:54:30,800 --> 00:54:34,800
bazel arguments to the test runner

00:54:33,040 --> 00:54:36,799
but then the user might want to pass

00:54:34,800 --> 00:54:38,400
their own args to their tests

00:54:36,799 --> 00:54:39,920
and we need to keep those two things

00:54:38,400 --> 00:54:41,200
separate and make sure that the test

00:54:39,920 --> 00:54:42,319
runner doesn't see the arguments that

00:54:41,200 --> 00:54:46,160
are meant for bazel to

00:54:42,319 --> 00:54:47,839
to control the program the next example

00:54:46,160 --> 00:54:49,520
is environment variables

00:54:47,839 --> 00:54:50,839
so this is a little confusing and i'm

00:54:49,520 --> 00:54:53,040
going to have to point you to the bazel

00:54:50,839 --> 00:54:53,599
documentation you should look up the use

00:54:53,040 --> 00:54:57,680
default

00:54:53,599 --> 00:54:59,359
shell end argument which changes the

00:54:57,680 --> 00:55:01,280
behavior of a given tool

00:54:59,359 --> 00:55:03,520
so that it uses the action environment

00:55:01,280 --> 00:55:06,160
around it and then you can use dash dash

00:55:03,520 --> 00:55:08,640
action end to change the environment for

00:55:06,160 --> 00:55:10,480
all of the actions that run

00:55:08,640 --> 00:55:11,760
so and keep in mind when you're changing

00:55:10,480 --> 00:55:13,839
the environment for an action that this

00:55:11,760 --> 00:55:15,520
will be part of the action's input hash

00:55:13,839 --> 00:55:17,920
and so it will bust the cache when it

00:55:15,520 --> 00:55:17,920
changes

00:55:18,000 --> 00:55:21,359
for things that are runnable like tests

00:55:19,520 --> 00:55:22,720
there's the dash dash test end which

00:55:21,359 --> 00:55:25,839
doesn't have as many caveats

00:55:22,720 --> 00:55:27,440
and generally works fine um then you

00:55:25,839 --> 00:55:29,760
also have a few rules that have an

00:55:27,440 --> 00:55:31,520
end attribute so this is a really nice

00:55:29,760 --> 00:55:32,880
uh easy way to pass some additional

00:55:31,520 --> 00:55:34,559
environment variables

00:55:32,880 --> 00:55:36,000
but it's not typically on most bazel

00:55:34,559 --> 00:55:37,680
rules that i've seen

00:55:36,000 --> 00:55:39,440
and of course as a last resort you can

00:55:37,680 --> 00:55:40,240
imagine if you write a wrapper then you

00:55:39,440 --> 00:55:42,559
can just

00:55:40,240 --> 00:55:44,240
take an input file which expresses all

00:55:42,559 --> 00:55:46,000
of the environment variables

00:55:44,240 --> 00:55:47,599
and then you can just set those either

00:55:46,000 --> 00:55:48,880
in process or in a parent process

00:55:47,599 --> 00:55:51,599
wrapper so that they're available when

00:55:48,880 --> 00:55:51,599
the tool runs

00:55:51,839 --> 00:55:54,079
the next one i'll talk about is the

00:55:52,880 --> 00:55:55,119
working directory we have a couple

00:55:54,079 --> 00:55:57,920
different examples here

00:55:55,119 --> 00:56:00,559
so the first is that of course bazel

00:55:57,920 --> 00:56:02,640
always runs tools in the workspace root

00:56:00,559 --> 00:56:04,319
and this is usually different from how

00:56:02,640 --> 00:56:06,160
most tools expect to be run

00:56:04,319 --> 00:56:07,680
especially in the javascript ecosystem

00:56:06,160 --> 00:56:09,200
tools tools tend to expect that the

00:56:07,680 --> 00:56:11,920
configuration file is going to be in the

00:56:09,200 --> 00:56:15,040
same directory as the working directory

00:56:11,920 --> 00:56:16,799
so again here we can wrap the program

00:56:15,040 --> 00:56:18,240
with a parent process that changes the

00:56:16,799 --> 00:56:20,079
working directory and then spawns the

00:56:18,240 --> 00:56:22,319
original as a sub process

00:56:20,079 --> 00:56:24,000
or we can do it in process so in node i

00:56:22,319 --> 00:56:24,559
mentioned there's this dash dash require

00:56:24,000 --> 00:56:26,799
option

00:56:24,559 --> 00:56:28,559
so here's an example where we take dash

00:56:26,799 --> 00:56:30,880
dash node options

00:56:28,559 --> 00:56:32,960
which is a way to wrap the arguments so

00:56:30,880 --> 00:56:34,880
we're going to strip that off in bazel

00:56:32,960 --> 00:56:36,400
and then the dash dash require part is

00:56:34,880 --> 00:56:38,079
going to get passed to node

00:56:36,400 --> 00:56:39,760
and then the argument to that is a

00:56:38,079 --> 00:56:42,000
little javascript file that's a

00:56:39,760 --> 00:56:43,599
one-liner that just a ch der

00:56:42,000 --> 00:56:44,880
and so this is a cute way that we can

00:56:43,599 --> 00:56:46,240
change the working directory of a

00:56:44,880 --> 00:56:47,599
process without having to write or make

00:56:46,240 --> 00:56:48,880
a wrapper around it

00:56:47,599 --> 00:56:50,480
keeping in mind that wrappers have that

00:56:48,880 --> 00:56:52,160
extra expense of having an extra process

00:56:50,480 --> 00:56:53,280
and possibly an extra dependency on

00:56:52,160 --> 00:56:54,880
something like bash

00:56:53,280 --> 00:56:58,000
so this can be a nice minimal way to do

00:56:54,880 --> 00:56:59,680
it if you need it to run everywhere i'm

00:56:58,000 --> 00:57:01,280
not sure if other language runtimes

00:56:59,680 --> 00:57:03,760
have a feature like this but it's worth

00:57:01,280 --> 00:57:03,760
looking for

00:57:04,160 --> 00:57:08,400
the next example is where the working

00:57:05,760 --> 00:57:09,920
directory needs to be in the output tree

00:57:08,400 --> 00:57:11,760
so this may seem strange but there are

00:57:09,920 --> 00:57:14,079
actually tools in the react ecosystem

00:57:11,760 --> 00:57:15,760
for example where the output always goes

00:57:14,079 --> 00:57:17,280
into dot slash build and it's not

00:57:15,760 --> 00:57:19,040
controllable by the user

00:57:17,280 --> 00:57:20,079
so to make this tool work under bazel

00:57:19,040 --> 00:57:21,920
you're going to have to switch

00:57:20,079 --> 00:57:23,599
directories to the output tree

00:57:21,920 --> 00:57:24,960
and then run the tool and then the

00:57:23,599 --> 00:57:26,400
outputs that it writes will just happen

00:57:24,960 --> 00:57:29,680
to match up with where bazel expects

00:57:26,400 --> 00:57:29,680
them to be written and it will work

00:57:30,240 --> 00:57:33,520
the next section is about the output

00:57:31,920 --> 00:57:35,440
parts of the process api

00:57:33,520 --> 00:57:36,720
so this is the exit code which is just

00:57:35,440 --> 00:57:38,480
generally saying whether things went

00:57:36,720 --> 00:57:40,079
okay when the program ran

00:57:38,480 --> 00:57:41,359
and the standard out and standard error

00:57:40,079 --> 00:57:44,240
which are two byte streams that the

00:57:41,359 --> 00:57:46,559
program can write to

00:57:44,240 --> 00:57:48,319
so for the exit code most tools will

00:57:46,559 --> 00:57:50,559
just exit zero on success

00:57:48,319 --> 00:57:52,079
and bazel fails if they exit non-zero

00:57:50,559 --> 00:57:54,480
and that's typically what you want

00:57:52,079 --> 00:57:55,440
there are some cases where the exit code

00:57:54,480 --> 00:57:57,760
actually does matter

00:57:55,440 --> 00:57:59,760
so one of them is if the tool exits with

00:57:57,760 --> 00:58:00,960
some other novel exit code like how many

00:57:59,760 --> 00:58:02,079
changes it made

00:58:00,960 --> 00:58:03,280
because the programmer felt like they

00:58:02,079 --> 00:58:04,640
were being clever and they were allowed

00:58:03,280 --> 00:58:06,720
to return whatever exit code they wanted

00:58:04,640 --> 00:58:08,960
so they added some information in there

00:58:06,720 --> 00:58:10,559
um the more common example we've seen is

00:58:08,960 --> 00:58:12,240
that we want to write a test under bazel

00:58:10,559 --> 00:58:14,559
that's a negative test it asserts that

00:58:12,240 --> 00:58:15,680
the build fails with some error message

00:58:14,559 --> 00:58:17,119
and this can be important in your

00:58:15,680 --> 00:58:19,119
migration you want to have a way to

00:58:17,119 --> 00:58:20,799
express that as you're writing

00:58:19,119 --> 00:58:22,000
the bazel wrappers for your code that

00:58:20,799 --> 00:58:23,200
you want to know that the error handling

00:58:22,000 --> 00:58:25,599
case is going to work correctly you want

00:58:23,200 --> 00:58:28,480
to write a test for that

00:58:25,599 --> 00:58:30,160
so one way to do this is to write a

00:58:28,480 --> 00:58:31,920
parent process wrapper that captures the

00:58:30,160 --> 00:58:33,839
exit code

00:58:31,920 --> 00:58:35,520
another way under rules node.js is

00:58:33,839 --> 00:58:36,000
actually matt mckay one of our contri

00:58:35,520 --> 00:58:38,400
one of our

00:58:36,000 --> 00:58:39,760
co-maintainers added a feature so you

00:58:38,400 --> 00:58:41,839
can just request that the exit code be

00:58:39,760 --> 00:58:43,520
one of the outputs rather than

00:58:41,839 --> 00:58:45,280
being seen by bazel so it will always

00:58:43,520 --> 00:58:48,160
exit zero and you can reference the exit

00:58:45,280 --> 00:58:49,599
code as an output file

00:58:48,160 --> 00:58:51,839
standard out and standard error are very

00:58:49,599 --> 00:58:53,359
similar again there can be things that a

00:58:51,839 --> 00:58:54,880
tool wants to produce on centered out

00:58:53,359 --> 00:58:56,079
and you want to grab those as an action

00:58:54,880 --> 00:58:58,720
output

00:58:56,079 --> 00:59:01,200
um so you can use general for this as we

00:58:58,720 --> 00:59:03,040
showed with the yq example earlier

00:59:01,200 --> 00:59:04,319
or you can use a parent process wrapper

00:59:03,040 --> 00:59:06,079
they can just read the read from

00:59:04,319 --> 00:59:07,200
standard out and convert it to being an

00:59:06,079 --> 00:59:09,119
output file

00:59:07,200 --> 00:59:10,960
and again matt mckay built this into

00:59:09,119 --> 00:59:12,480
rules node.js so in our case you can

00:59:10,960 --> 00:59:15,520
just ask for this centered out to be a

00:59:12,480 --> 00:59:17,280
to be an action output file

00:59:15,520 --> 00:59:18,960
the other obvious caveat here if you've

00:59:17,280 --> 00:59:20,960
done anything with persistent workers or

00:59:18,960 --> 00:59:22,160
with ibazal which is the watch mode for

00:59:20,960 --> 00:59:23,760
bazel

00:59:22,160 --> 00:59:25,680
those both expect to communicate with

00:59:23,760 --> 00:59:26,240
the tool over standard in and centered

00:59:25,680 --> 00:59:27,920
out

00:59:26,240 --> 00:59:30,240
and so you may need to patch the runtime

00:59:27,920 --> 00:59:31,280
in some way to assign standard out to

00:59:30,240 --> 00:59:32,640
standard error

00:59:31,280 --> 00:59:33,680
in both cases you're free to write to

00:59:32,640 --> 00:59:35,040
standard error but you don't want to

00:59:33,680 --> 00:59:36,319
have to go through this whole tool and

00:59:35,040 --> 00:59:37,599
figure out all the places that it writes

00:59:36,319 --> 00:59:39,440
to standard out and change them

00:59:37,599 --> 00:59:40,640
so usually you'll find some way in your

00:59:39,440 --> 00:59:43,040
runtime to be able to patch that

00:59:40,640 --> 00:59:43,040
behavior

00:59:43,680 --> 00:59:47,200
the last category of api i want to talk

00:59:45,440 --> 00:59:48,240
about is interactions outside of the

00:59:47,200 --> 00:59:50,000
process

00:59:48,240 --> 00:59:51,680
so there are parent and child processes

00:59:50,000 --> 00:59:53,760
that can know about each other

00:59:51,680 --> 00:59:55,200
and there's obviously the program can

00:59:53,760 --> 00:59:57,040
write to the file system and read from

00:59:55,200 --> 00:59:58,480
the file system it has open file handles

00:59:57,040 --> 01:00:00,480
called descriptors

00:59:58,480 --> 01:00:03,119
and also it can receive signals telling

01:00:00,480 --> 01:00:03,119
it what to do

01:00:03,200 --> 01:00:06,640
so for the first of those there's this

01:00:04,799 --> 01:00:07,359
concept of a union file system under

01:00:06,640 --> 01:00:09,200
bazel

01:00:07,359 --> 01:00:10,960
so bazel is very opinionated about

01:00:09,200 --> 01:00:12,559
putting the outputs into the just into

01:00:10,960 --> 01:00:14,640
this distinct tree bazel out

01:00:12,559 --> 01:00:16,480
and not next to the source files but a

01:00:14,640 --> 01:00:18,160
lot of tools expect to be able to

01:00:16,480 --> 01:00:20,319
make relative references between a

01:00:18,160 --> 01:00:23,040
generated file and another source file

01:00:20,319 --> 01:00:24,720
so i call this union fs because our

01:00:23,040 --> 01:00:26,160
solution for this has typically been to

01:00:24,720 --> 01:00:27,359
to convince the program that those

01:00:26,160 --> 01:00:28,640
things are actually next to each other

01:00:27,359 --> 01:00:29,599
or change the way that these relative

01:00:28,640 --> 01:00:31,200
references work

01:00:29,599 --> 01:00:33,359
but that again is an example of needing

01:00:31,200 --> 01:00:34,640
to make significant changes to the tool

01:00:33,359 --> 01:00:37,599
instead of just making it compatible

01:00:34,640 --> 01:00:38,160
under bazel so this one is a cool trick

01:00:37,599 --> 01:00:40,079
you may

01:00:38,160 --> 01:00:41,680
think that bazel disallows you from

01:00:40,079 --> 01:00:43,119
having the same file be in the input

01:00:41,680 --> 01:00:44,799
tree and the output tree

01:00:43,119 --> 01:00:46,799
but this is actually only true if the

01:00:44,799 --> 01:00:49,119
output is labeled which is to say it was

01:00:46,799 --> 01:00:51,040
a pre-declared output of some rule

01:00:49,119 --> 01:00:52,799
as long as you just reference a target

01:00:51,040 --> 01:00:54,559
and that target does some copies and it

01:00:52,799 --> 01:00:55,520
happens to put copies of your files into

01:00:54,559 --> 01:00:56,880
the output tree

01:00:55,520 --> 01:00:59,520
bazel doesn't know about that and it

01:00:56,880 --> 01:01:00,880
works fine so you can just copy your

01:00:59,520 --> 01:01:02,559
sources to the output tree and make

01:01:00,880 --> 01:01:04,079
itself contained and then your tool will

01:01:02,559 --> 01:01:04,960
run and see the files next to each other

01:01:04,079 --> 01:01:07,359
like they were

01:01:04,960 --> 01:01:09,200
intended to be we actually have this

01:01:07,359 --> 01:01:10,799
built into rules node.js

01:01:09,200 --> 01:01:13,520
so you can see here's a documentation

01:01:10,799 --> 01:01:14,640
link to our copy to bin rule

01:01:13,520 --> 01:01:16,720
and if you feel like this would be

01:01:14,640 --> 01:01:19,040
useful for you outside of node.js which

01:01:16,720 --> 01:01:21,599
i imagine it would be you can find this

01:01:19,040 --> 01:01:22,960
pull request number 217 on bazel skylab

01:01:21,599 --> 01:01:24,799
and comment there they're actually

01:01:22,960 --> 01:01:25,599
asking whether it's useful generally

01:01:24,799 --> 01:01:28,640
outside of the

01:01:25,599 --> 01:01:31,359
the node.js use case um let's talk about

01:01:28,640 --> 01:01:32,799
signals for a minute signals are

01:01:31,359 --> 01:01:34,559
an interesting way to affect the

01:01:32,799 --> 01:01:35,920
processor's behavior normally under

01:01:34,559 --> 01:01:37,280
bazel you don't think about signals

01:01:35,920 --> 01:01:39,520
being part of the api

01:01:37,280 --> 01:01:41,599
when you call a tool but if you're

01:01:39,520 --> 01:01:43,119
writing a parent process

01:01:41,599 --> 01:01:45,440
then this can be a really clever way to

01:01:43,119 --> 01:01:47,520
control the child process

01:01:45,440 --> 01:01:48,960
so let's take for example watch mode so

01:01:47,520 --> 01:01:49,920
watch mode is where a tool expects that

01:01:48,960 --> 01:01:51,599
it's going to watch the

01:01:49,920 --> 01:01:53,119
source files or something in the output

01:01:51,599 --> 01:01:54,960
tree and then it's going to rebuild them

01:01:53,119 --> 01:01:57,119
every time it changes

01:01:54,960 --> 01:01:58,720
so this can be a problem because the

01:01:57,119 --> 01:01:59,200
intermediate state in the bazel out

01:01:58,720 --> 01:02:02,000
folder

01:01:59,200 --> 01:02:03,760
is very uh it's disruptive the bazel

01:02:02,000 --> 01:02:05,039
will actually unlink the files meaning

01:02:03,760 --> 01:02:06,720
like they appear to be deleted and then

01:02:05,039 --> 01:02:08,160
re-added and so tools can freak out and

01:02:06,720 --> 01:02:09,200
they can also see intermediate state

01:02:08,160 --> 01:02:11,359
where not all of the things have been

01:02:09,200 --> 01:02:14,319
written to the output tree yet

01:02:11,359 --> 01:02:15,760
so i want to give credit to dan muller

01:02:14,319 --> 01:02:17,039
from the rules node.js team who came up

01:02:15,760 --> 01:02:17,920
with this approach for running watch

01:02:17,039 --> 01:02:21,280
mode tools

01:02:17,920 --> 01:02:22,559
what we can do is instead of having to

01:02:21,280 --> 01:02:25,520
make the tool aware

01:02:22,559 --> 01:02:26,000
of the bazel worker persistent worker

01:02:25,520 --> 01:02:27,599
api

01:02:26,000 --> 01:02:28,960
or the ibazal api which write to

01:02:27,599 --> 01:02:30,079
standard in and tell the tool that it's

01:02:28,960 --> 01:02:31,839
time to work

01:02:30,079 --> 01:02:33,359
we can actually intercept that part of

01:02:31,839 --> 01:02:34,559
the communication with bazel so

01:02:33,359 --> 01:02:36,079
intercept standard in and write to

01:02:34,559 --> 01:02:37,680
standard out to communicate with bazel

01:02:36,079 --> 01:02:38,960
from our wrapper process

01:02:37,680 --> 01:02:41,119
and then the wrapper can control the

01:02:38,960 --> 01:02:43,200
style process by sending it a sig stop

01:02:41,119 --> 01:02:44,480
to pause it and a sig continue to resume

01:02:43,200 --> 01:02:45,920
which is the same thing as if you press

01:02:44,480 --> 01:02:49,200
ctrl z on the command line and

01:02:45,920 --> 01:02:50,480
type and then fg to resume the program

01:02:49,200 --> 01:02:52,000
so this is really cool it just pauses

01:02:50,480 --> 01:02:53,119
the program while bazel is running so

01:02:52,000 --> 01:02:54,400
you can get that same watch mode

01:02:53,119 --> 01:02:55,920
behavior without having to change the

01:02:54,400 --> 01:02:58,079
program you're calling

01:02:55,920 --> 01:02:59,760
sim links are a common source of trouble

01:02:58,079 --> 01:03:00,480
especially in the javascript ecosystem

01:02:59,760 --> 01:03:03,520
because

01:03:00,480 --> 01:03:05,039
bazel runs tools in a simlink forest if

01:03:03,520 --> 01:03:06,480
it's an action this is called the exact

01:03:05,039 --> 01:03:07,520
route and if it's a test it's called the

01:03:06,480 --> 01:03:10,000
run files root

01:03:07,520 --> 01:03:11,680
and under the default spawn strategy

01:03:10,000 --> 01:03:13,200
there's a bunch of sim links here out to

01:03:11,680 --> 01:03:15,280
the rest of the file system

01:03:13,200 --> 01:03:16,480
and if the tool follows those sim links

01:03:15,280 --> 01:03:17,680
then they can find inputs that they

01:03:16,480 --> 01:03:19,359
weren't supposed to read

01:03:17,680 --> 01:03:20,880
that makes your build non-hermetic but

01:03:19,359 --> 01:03:22,400
it also can make

01:03:20,880 --> 01:03:24,559
the tool behave wrong because it may

01:03:22,400 --> 01:03:27,200
find some input that conflicts with some

01:03:24,559 --> 01:03:28,720
input that you wanted it to find

01:03:27,200 --> 01:03:30,640
one tip here is to go check out the

01:03:28,720 --> 01:03:32,079
sandbox fs which was this effort by

01:03:30,640 --> 01:03:34,559
julio and some others to

01:03:32,079 --> 01:03:36,240
make a better sandbox it doesn't just

01:03:34,559 --> 01:03:38,799
based on on sim links i don't know what

01:03:36,240 --> 01:03:40,079
the state of that project is

01:03:38,799 --> 01:03:41,839
you might be able to configure your tool

01:03:40,079 --> 01:03:43,280
to avoid following some links and note

01:03:41,839 --> 01:03:44,079
it's pretty typical that you can pass a

01:03:43,280 --> 01:03:47,440
couple of options

01:03:44,079 --> 01:03:49,680
to the node interpreter and actually in

01:03:47,440 --> 01:03:52,400
rules node.js we went so far as to

01:03:49,680 --> 01:03:54,240
have a patch written by ryan day which

01:03:52,400 --> 01:03:55,839
changes the file system api so that the

01:03:54,240 --> 01:03:57,359
sim links actually appear to be regular

01:03:55,839 --> 01:03:58,799
files and directories rather than sim

01:03:57,359 --> 01:04:02,079
links so the program can't tell it's

01:03:58,799 --> 01:04:03,920
running in this bazel environment

01:04:02,079 --> 01:04:05,359
um the last thing i'll mention is

01:04:03,920 --> 01:04:08,960
sometimes you can just back off

01:04:05,359 --> 01:04:10,799
from the from the sort of basil idioms

01:04:08,960 --> 01:04:12,960
so one idiom is to run things in a

01:04:10,799 --> 01:04:13,760
sandbox but bazel makes input files

01:04:12,960 --> 01:04:15,280
read-only

01:04:13,760 --> 01:04:17,039
and if your tool expects that it's going

01:04:15,280 --> 01:04:18,240
to write to the input files

01:04:17,039 --> 01:04:19,920
you may have to just give up on

01:04:18,240 --> 01:04:20,799
sandboxing you can always mark this as

01:04:19,920 --> 01:04:23,039
local and

01:04:20,799 --> 01:04:24,720
you can find a way to make that tool run

01:04:23,039 --> 01:04:26,480
again this is a trade-off between

01:04:24,720 --> 01:04:28,720
the basal idioms and making things more

01:04:26,480 --> 01:04:30,079
compatible so those are all the examples

01:04:28,720 --> 01:04:31,119
i have time for today i just want to

01:04:30,079 --> 01:04:33,280
remind you

01:04:31,119 --> 01:04:35,359
that i think in a migration it's wise to

01:04:33,280 --> 01:04:37,280
try to change only one thing at a time

01:04:35,359 --> 01:04:38,799
and you should always challenge the

01:04:37,280 --> 01:04:39,440
notion of this tool doesn't work under

01:04:38,799 --> 01:04:40,880
bazel

01:04:39,440 --> 01:04:44,799
to find a way to run your tools the same

01:04:40,880 --> 01:04:44,799
way you did before thanks so much for

01:04:52,839 --> 01:04:55,839
watching

01:04:58,960 --> 01:05:02,160
thanks alex i love that you brought your

01:05:00,799 --> 01:05:03,039
experience from working with rules

01:05:02,160 --> 01:05:04,640
nodejs

01:05:03,039 --> 01:05:07,200
to be able to help the community with

01:05:04,640 --> 01:05:10,240
their migration to bazel

01:05:07,200 --> 01:05:13,359
next we'll hear from yoon peng and

01:05:10,240 --> 01:05:15,359
olek voynar about debian ubuntu

01:05:13,359 --> 01:05:23,839
packaging for basil

01:05:15,359 --> 01:05:23,839
take it away yunanolk

01:07:26,720 --> 01:07:30,640
hello thanks for joining this talk on

01:07:28,400 --> 01:07:32,720
debian packaging for bazel i'm yun

01:07:30,640 --> 01:07:33,839
i work on the bazel team from the google

01:07:32,720 --> 01:07:36,319
munich office

01:07:33,839 --> 01:07:38,240
and i'm olek i am a debian developer and

01:07:36,319 --> 01:07:39,680
the lead for the debian packaging effort

01:07:38,240 --> 01:07:41,680
for bazel

01:07:39,680 --> 01:07:42,799
in this session we want to talk about

01:07:41,680 --> 01:07:44,400
how we manage

01:07:42,799 --> 01:07:46,240
to package bazel for the debian

01:07:44,400 --> 01:07:48,400
distribution first

01:07:46,240 --> 01:07:49,599
we'll show you what situation net to our

01:07:48,400 --> 01:07:52,079
collaboration

01:07:49,599 --> 01:07:53,599
then we'll talk about how we overcame

01:07:52,079 --> 01:07:55,920
some of the challenges

01:07:53,599 --> 01:07:57,440
we've had from both the bazel side and

01:07:55,920 --> 01:07:59,359
the debian side

01:07:57,440 --> 01:08:01,119
last we'll see what's the outcome of

01:07:59,359 --> 01:08:03,680
this joint effort so far

01:08:01,119 --> 01:08:05,440
and what's the remaining work olek we'll

01:08:03,680 --> 01:08:07,599
start with some background of this

01:08:05,440 --> 01:08:09,599
effort

01:08:07,599 --> 01:08:11,520
thank you so this all started when i

01:08:09,599 --> 01:08:12,640
joined the debian med team in spring of

01:08:11,520 --> 01:08:14,079
01:08:12,640 --> 01:08:15,760
because of their efforts to package

01:08:14,079 --> 01:08:17,679
software that could help experts

01:08:15,760 --> 01:08:19,520
fighting cobit 19.

01:08:17,679 --> 01:08:21,040
one of their highest priority packages

01:08:19,520 --> 01:08:23,359
was tensorflow

01:08:21,040 --> 01:08:25,120
however that package was also marked as

01:08:23,359 --> 01:08:27,279
extraordinarily difficult

01:08:25,120 --> 01:08:29,440
at this time basil was not available in

01:08:27,279 --> 01:08:30,319
debian therefore previous packaging

01:08:29,440 --> 01:08:32,799
efforts

01:08:30,319 --> 01:08:35,440
had unsuccessfully attempted to

01:08:32,799 --> 01:08:37,920
implement a custom build system

01:08:35,440 --> 01:08:40,960
the solution was obvious to me packaged

01:08:37,920 --> 01:08:43,359
basil for debian how hard could it be

01:08:40,960 --> 01:08:44,640
unfortunately neither the debbie team

01:08:43,359 --> 01:08:46,799
nor the bazel team

01:08:44,640 --> 01:08:49,199
individually possessed all the required

01:08:46,799 --> 01:08:51,279
expertise to make that happen

01:08:49,199 --> 01:08:53,040
therefore we rapidly put together an

01:08:51,279 --> 01:08:56,640
effort to leverage each team's

01:08:53,040 --> 01:08:59,040
unique abilities to achieve this goal

01:08:56,640 --> 01:09:00,239
now the primary goal was simple

01:08:59,040 --> 01:09:02,080
introduce bazel

01:09:00,239 --> 01:09:03,679
into debian so that it can be used to

01:09:02,080 --> 01:09:05,679
build tensorflow

01:09:03,679 --> 01:09:06,799
because the pandemic implications we

01:09:05,679 --> 01:09:10,159
wanted to proceed as

01:09:06,799 --> 01:09:11,679
quickly as possible therefore we agreed

01:09:10,159 --> 01:09:14,159
that we were willing to accept

01:09:11,679 --> 01:09:15,920
temporary workarounds if it helped us to

01:09:14,159 --> 01:09:17,440
achieve our goal faster

01:09:15,920 --> 01:09:18,960
we didn't know exactly how long this

01:09:17,440 --> 01:09:21,199
effort would take but we wanted to

01:09:18,960 --> 01:09:23,679
finish within a couple months

01:09:21,199 --> 01:09:25,279
however the previous packaging effort

01:09:23,679 --> 01:09:28,480
had lasted five years

01:09:25,279 --> 01:09:31,040
and had ultimately been unsuccessful

01:09:28,480 --> 01:09:31,920
that was a sobering reality yuna will

01:09:31,040 --> 01:09:35,040
now tell you more

01:09:31,920 --> 01:09:37,759
about our collaboration on this project

01:09:35,040 --> 01:09:39,679
so the debian team first reached out to

01:09:37,759 --> 01:09:42,000
the bazel team on github

01:09:39,679 --> 01:09:43,120
we soon had a video conference in april

01:09:42,000 --> 01:09:45,359
01:09:43,120 --> 01:09:46,400
a task force was set up with me being

01:09:45,359 --> 01:09:48,480
the contact point

01:09:46,400 --> 01:09:50,480
from the bazel team and oleg from the

01:09:48,480 --> 01:09:52,319
diving team in the first few weeks we

01:09:50,480 --> 01:09:54,640
had frequent email exchanges

01:09:52,319 --> 01:09:56,640
and video meetings to understand what

01:09:54,640 --> 01:09:58,960
problems we had to solve

01:09:56,640 --> 01:09:59,920
and finally we came up with a viable

01:09:58,960 --> 01:10:01,840
work plan

01:09:59,920 --> 01:10:03,760
so what challenges do we have to

01:10:01,840 --> 01:10:06,239
overcome exactly

01:10:03,760 --> 01:10:08,239
i'll first talk from the bezel side to

01:10:06,239 --> 01:10:09,520
comply with the debian policy for

01:10:08,239 --> 01:10:11,520
packaging software

01:10:09,520 --> 01:10:13,840
we have to bootstrap and build bazel

01:10:11,520 --> 01:10:14,480
without any boundary dependencies in

01:10:13,840 --> 01:10:16,719
source

01:10:14,480 --> 01:10:17,679
or any downloaded dependencies from the

01:10:16,719 --> 01:10:20,159
internet

01:10:17,679 --> 01:10:21,360
also we have to install bazel following

01:10:20,159 --> 01:10:24,960
debian standards

01:10:21,360 --> 01:10:24,960
i'll talk more in detail

01:10:25,040 --> 01:10:28,159
bazel bundles some of its dependencies

01:10:27,280 --> 01:10:30,159
as source code

01:10:28,159 --> 01:10:31,199
and jar files under the third-party

01:10:30,159 --> 01:10:33,440
directory

01:10:31,199 --> 01:10:34,560
in the debian build those dependencies

01:10:33,440 --> 01:10:36,880
should be replaced

01:10:34,560 --> 01:10:38,960
with their corresponding debian packages

01:10:36,880 --> 01:10:43,360
which are installed on the system

01:10:38,960 --> 01:10:46,000
so for example json 2.8 is checked in

01:10:43,360 --> 01:10:46,640
beta source and used by a java input

01:10:46,000 --> 01:10:49,360
rule

01:10:46,640 --> 01:10:50,480
so how did we make use of the json jar

01:10:49,360 --> 01:10:53,520
installed by the

01:10:50,480 --> 01:10:55,040
debian package first we created a new

01:10:53,520 --> 01:10:57,679
local repository rule

01:10:55,040 --> 01:10:59,360
pointing to user share java because

01:10:57,679 --> 01:11:00,239
that's where all java libraries are

01:10:59,360 --> 01:11:02,960
installed

01:11:00,239 --> 01:11:03,840
we name this repo as the debian java

01:11:02,960 --> 01:11:05,760
devs

01:11:03,840 --> 01:11:07,840
of course we have to write a build file

01:11:05,760 --> 01:11:10,800
for this repo so that bazel knows

01:11:07,840 --> 01:11:13,360
what targets are available here we write

01:11:10,800 --> 01:11:16,960
a java input rule for the json

01:11:13,360 --> 01:11:17,840
note that this notes that the name of

01:11:16,960 --> 01:11:20,400
these targets

01:11:17,840 --> 01:11:22,000
is exactly the same as the one in the

01:11:20,400 --> 01:11:24,400
third party directory

01:11:22,000 --> 01:11:25,040
to be able to replace the original json

01:11:24,400 --> 01:11:27,360
target

01:11:25,040 --> 01:11:28,800
with the one in the local repository

01:11:27,360 --> 01:11:31,600
debian java devs

01:11:28,800 --> 01:11:32,080
we wrote a macro for the java input rule

01:11:31,600 --> 01:11:35,520
called

01:11:32,080 --> 01:11:38,480
distrib java import it is essentially an

01:11:35,520 --> 01:11:39,120
allies rule with a select statement by

01:11:38,480 --> 01:11:41,679
default

01:11:39,120 --> 01:11:42,640
it dedicates to a native java input rule

01:11:41,679 --> 01:11:45,199
that uses

01:11:42,640 --> 01:11:46,320
the checked in jar file we use an

01:11:45,199 --> 01:11:48,560
attribute called

01:11:46,320 --> 01:11:50,320
enable distributions to indicate what

01:11:48,560 --> 01:11:53,440
these distributions are

01:11:50,320 --> 01:11:56,400
supported if debian is in the list

01:11:53,440 --> 01:11:58,480
of enabled distributions it means there

01:11:56,400 --> 01:11:59,920
is a target in the debian java depth

01:11:58,480 --> 01:12:02,800
repo with the same name

01:11:59,920 --> 01:12:03,199
that can replace the original target

01:12:02,800 --> 01:12:05,920
then

01:12:03,199 --> 01:12:07,280
a condition of the debian build for this

01:12:05,920 --> 01:12:09,760
target is added

01:12:07,280 --> 01:12:11,440
so when the config setting for the

01:12:09,760 --> 01:12:14,159
debian build is matched

01:12:11,440 --> 01:12:16,159
it redirects the target to the one in

01:12:14,159 --> 01:12:18,000
the debian java depth repo

01:12:16,159 --> 01:12:20,640
we also created a similar local

01:12:18,000 --> 01:12:23,440
repositories and raw similar macros

01:12:20,640 --> 01:12:24,320
for cc library cc binary so that

01:12:23,440 --> 01:12:27,040
dependencies

01:12:24,320 --> 01:12:28,719
like zenith or the protoc compiler can

01:12:27,040 --> 01:12:31,199
also be replaced

01:12:28,719 --> 01:12:33,040
so with not so intrusive changes in

01:12:31,199 --> 01:12:35,440
bezels build file we added

01:12:33,040 --> 01:12:37,760
the ability to build bazel with

01:12:35,440 --> 01:12:40,640
libraries installed on the system

01:12:37,760 --> 01:12:41,600
which can be enabled by the defined

01:12:40,640 --> 01:12:44,560
distribution

01:12:41,600 --> 01:12:45,280
you call debian flag and we can safely

01:12:44,560 --> 01:12:49,440
strip out

01:12:45,280 --> 01:12:52,480
the bundled dependencies in bazel's

01:12:49,440 --> 01:12:53,040
debian source package note that this

01:12:52,480 --> 01:12:55,679
approach

01:12:53,040 --> 01:12:56,640
can be easily extended for other linux

01:12:55,679 --> 01:12:59,520
distributions

01:12:56,640 --> 01:13:01,679
as needed the other part of bazel's

01:12:59,520 --> 01:13:02,159
dependencies come from the workspace

01:13:01,679 --> 01:13:03,920
file

01:13:02,159 --> 01:13:06,000
which needs to be downloaded at the

01:13:03,920 --> 01:13:09,679
build time for example

01:13:06,000 --> 01:13:11,600
we have bazel skyleaf rules java etc

01:13:09,679 --> 01:13:12,800
obviously they are not packaged for

01:13:11,600 --> 01:13:15,520
debian by the time

01:13:12,800 --> 01:13:17,440
we were trying to patch bazel but they

01:13:15,520 --> 01:13:19,600
are used in many build files so we

01:13:17,440 --> 01:13:22,800
cannot simply remove them

01:13:19,600 --> 01:13:25,360
to work around this we have to write a

01:13:22,800 --> 01:13:26,320
patch file to create mock repositories

01:13:25,360 --> 01:13:29,760
which contain

01:13:26,320 --> 01:13:32,560
the build files and bgl files required

01:13:29,760 --> 01:13:34,960
then with the override repository flag

01:13:32,560 --> 01:13:35,840
we can tell bazel not to download those

01:13:34,960 --> 01:13:38,080
dependencies

01:13:35,840 --> 01:13:39,679
but to use a given directory for a

01:13:38,080 --> 01:13:42,159
certain repo

01:13:39,679 --> 01:13:44,080
admit this is kind of a hack but in

01:13:42,159 --> 01:13:46,480
order to get bazel packaged

01:13:44,080 --> 01:13:47,440
as soon as possible this is still

01:13:46,480 --> 01:13:49,440
acceptable

01:13:47,440 --> 01:13:50,960
the last challenge is about installing

01:13:49,440 --> 01:13:53,360
bazel bazel is

01:13:50,960 --> 01:13:54,640
implemented in the client server

01:13:53,360 --> 01:13:56,880
architecture

01:13:54,640 --> 01:13:58,640
users usually download bazel as a single

01:13:56,880 --> 01:14:00,560
binary which is in fact a

01:13:58,640 --> 01:14:03,040
self-extracting archive

01:14:00,560 --> 01:14:05,520
the first time you run bazel it it

01:14:03,040 --> 01:14:07,760
extracts itself to an install base

01:14:05,520 --> 01:14:09,920
somewhere under your home directory

01:14:07,760 --> 01:14:11,360
which contains the bezel server and the

01:14:09,920 --> 01:14:14,320
embedded tools

01:14:11,360 --> 01:14:15,280
then the binary itself serves as a

01:14:14,320 --> 01:14:17,920
client

01:14:15,280 --> 01:14:18,719
however this behavior is not allowed in

01:14:17,920 --> 01:14:21,199
debian

01:14:18,719 --> 01:14:22,239
the user being bazel binary must be

01:14:21,199 --> 01:14:25,280
stripped

01:14:22,239 --> 01:14:27,760
while creating the debian package so

01:14:25,280 --> 01:14:28,880
it will only be the bazel client and

01:14:27,760 --> 01:14:32,000
will not contain

01:14:28,880 --> 01:14:34,320
any additional data

01:14:32,000 --> 01:14:35,840
therefore we actually have to create the

01:14:34,320 --> 01:14:38,400
whole bazel install base

01:14:35,840 --> 01:14:38,880
in the debian package so on the left

01:14:38,400 --> 01:14:41,440
side

01:14:38,880 --> 01:14:42,000
it is a normal install base for bezel on

01:14:41,440 --> 01:14:45,040
the right

01:14:42,000 --> 01:14:48,239
side it is a installer base in debian

01:14:45,040 --> 01:14:50,719
which is under user share bezel however

01:14:48,239 --> 01:14:52,800
the c plus class binaries should be

01:14:50,719 --> 01:14:55,360
installed in certain directories because

01:14:52,800 --> 01:14:58,000
they are architecture dependent

01:14:55,360 --> 01:14:59,920
so we use sim links to reconstruct the

01:14:58,000 --> 01:15:03,040
complete directory structure

01:14:59,920 --> 01:15:05,840
for the install base

01:15:03,040 --> 01:15:06,560
and finally with the global base rc file

01:15:05,840 --> 01:15:08,800
we can tell

01:15:06,560 --> 01:15:10,400
the beta client where the install base

01:15:08,800 --> 01:15:13,520
is so that users

01:15:10,400 --> 01:15:15,520
can just invoke bazel as normal

01:15:13,520 --> 01:15:16,560
so that's the major challenges from the

01:15:15,520 --> 01:15:18,880
bezel side

01:15:16,560 --> 01:15:20,159
next olek will tell you more from the

01:15:18,880 --> 01:15:22,000
debian side

01:15:20,159 --> 01:15:24,239
thank you i'd like to highlight the

01:15:22,000 --> 01:15:26,320
challenges for both teams were discussed

01:15:24,239 --> 01:15:28,560
and addressed together no matter which

01:15:26,320 --> 01:15:30,800
team took the lead on a solution

01:15:28,560 --> 01:15:32,480
and the up-to-date flexible work plan

01:15:30,800 --> 01:15:34,000
that you mentioned earlier was

01:15:32,480 --> 01:15:35,840
critical in keeping our efforts

01:15:34,000 --> 01:15:38,080
synchronized also

01:15:35,840 --> 01:15:39,360
having a common understanding of our

01:15:38,080 --> 01:15:42,320
mutual desired

01:15:39,360 --> 01:15:43,199
end states and constraints made things

01:15:42,320 --> 01:15:45,920
much easier

01:15:43,199 --> 01:15:47,840
when the plan inevitably changed

01:15:45,920 --> 01:15:49,920
regarding some specific challenges that

01:15:47,840 --> 01:15:51,760
the debian team took the lead on

01:15:49,920 --> 01:15:54,320
we found that we had significantly more

01:15:51,760 --> 01:15:56,080
dependencies than we had expected

01:15:54,320 --> 01:15:57,840
each of these dependencies had to be

01:15:56,080 --> 01:15:59,280
packaged for debian before we could

01:15:57,840 --> 01:16:01,600
package basil

01:15:59,280 --> 01:16:02,560
now the bazel team was very helpful in

01:16:01,600 --> 01:16:04,880
determining

01:16:02,560 --> 01:16:06,800
which were absolutely needed and which

01:16:04,880 --> 01:16:08,719
could be worked around

01:16:06,800 --> 01:16:10,239
some of these dependencies were fairly

01:16:08,719 --> 01:16:13,360
trivial and

01:16:10,239 --> 01:16:15,199
some were not on the difficult side some

01:16:13,360 --> 01:16:18,159
dependencies needed to be built with

01:16:15,199 --> 01:16:20,480
gradle which is not very well supported

01:16:18,159 --> 01:16:24,000
in debian to say the least

01:16:20,480 --> 01:16:25,440
also the grpc java and open census

01:16:24,000 --> 01:16:28,560
circular dependency

01:16:25,440 --> 01:16:30,640
caused quite a few headaches our second

01:16:28,560 --> 01:16:33,199
challenge was that debian contributors

01:16:30,640 --> 01:16:34,159
are all volunteers we had to plan for

01:16:33,199 --> 01:16:36,480
extra time

01:16:34,159 --> 01:16:37,679
as both packagers and supporting debian

01:16:36,480 --> 01:16:41,360
contributors

01:16:37,679 --> 01:16:44,000
often have rapidly changing time budgets

01:16:41,360 --> 01:16:45,679
for example even once we had completed

01:16:44,000 --> 01:16:48,000
our initial packaging effort

01:16:45,679 --> 01:16:50,159
we had to allow significant time for

01:16:48,000 --> 01:16:51,600
debian's quality control team to review

01:16:50,159 --> 01:16:53,360
the packaging

01:16:51,600 --> 01:16:54,960
and more importantly to review the

01:16:53,360 --> 01:16:57,600
licensing

01:16:54,960 --> 01:16:59,280
now licensing issues are critical for

01:16:57,600 --> 01:17:01,520
distribution

01:16:59,280 --> 01:17:03,360
we wanted to identify anything that

01:17:01,520 --> 01:17:05,120
could present a problem for debian

01:17:03,360 --> 01:17:07,760
distributing the software

01:17:05,120 --> 01:17:09,040
for example we discovered a json license

01:17:07,760 --> 01:17:10,880
in the bazel source

01:17:09,040 --> 01:17:12,159
that we had to investigate since it

01:17:10,880 --> 01:17:14,719
could not be included

01:17:12,159 --> 01:17:16,320
in debian we also had to clarify some

01:17:14,719 --> 01:17:18,320
licensing issues

01:17:16,320 --> 01:17:19,920
that our quality control team caught

01:17:18,320 --> 01:17:21,840
related to checker framework

01:17:19,920 --> 01:17:23,760
which is one of the bazel dependencies

01:17:21,840 --> 01:17:25,520
that we needed to package

01:17:23,760 --> 01:17:27,440
this effort quickly grew beyond the

01:17:25,520 --> 01:17:28,560
debian med team that originally spawned

01:17:27,440 --> 01:17:31,440
it

01:17:28,560 --> 01:17:33,280
and now it has its own team endeavour

01:17:31,440 --> 01:17:36,000
while the scope of the debian

01:17:33,280 --> 01:17:38,159
bazel team's efforts has grown the core

01:17:36,000 --> 01:17:40,000
purpose of the team is still the same as

01:17:38,159 --> 01:17:42,880
in our original project

01:17:40,000 --> 01:17:44,320
that is to enable tensorflow and

01:17:42,880 --> 01:17:47,360
pandemic related packages

01:17:44,320 --> 01:17:48,320
in debian after almost exactly six

01:17:47,360 --> 01:17:50,400
months

01:17:48,320 --> 01:17:52,000
the bazel bootstrap package was in the

01:17:50,400 --> 01:17:53,760
debian repositories

01:17:52,000 --> 01:17:55,199
it is scheduled to release with debian

01:17:53,760 --> 01:17:58,640
11 later this

01:17:55,199 --> 01:18:01,600
year and with ubuntu 21.04

01:17:58,640 --> 01:18:02,239
in april now this is a great time to

01:18:01,600 --> 01:18:04,640
point out

01:18:02,239 --> 01:18:05,360
that bazel has a capability to bootstrap

01:18:04,640 --> 01:18:08,400
itself

01:18:05,360 --> 01:18:10,560
from source that is a killer feature

01:18:08,400 --> 01:18:12,239
and that is the variant that we packaged

01:18:10,560 --> 01:18:14,880
initially in debian

01:18:12,239 --> 01:18:16,480
because it was the easiest to start with

01:18:14,880 --> 01:18:18,080
i can't imagine how difficult this

01:18:16,480 --> 01:18:19,920
process would have been to implement

01:18:18,080 --> 01:18:21,280
if we had had to request permission to

01:18:19,920 --> 01:18:24,320
start with a pre-built

01:18:21,280 --> 01:18:26,880
bazel binary endeavour

01:18:24,320 --> 01:18:28,480
now our tensorflow packaging is ongoing

01:18:26,880 --> 01:18:28,960
and we're working with that packaging

01:18:28,480 --> 01:18:30,800
team

01:18:28,960 --> 01:18:32,480
to help with any workarounds that they

01:18:30,800 --> 01:18:34,960
may need to help accelerate their

01:18:32,480 --> 01:18:36,880
packaging efforts

01:18:34,960 --> 01:18:38,080
most importantly we have developed a

01:18:36,880 --> 01:18:40,880
solid relationship

01:18:38,080 --> 01:18:42,800
between the bazel and the debian teams

01:18:40,880 --> 01:18:43,840
and that relationship is continuing to

01:18:42,800 --> 01:18:46,719
bear fruit

01:18:43,840 --> 01:18:48,560
as we tackle new challenges and you and

01:18:46,719 --> 01:18:50,159
you saw some benefits upstream as well

01:18:48,560 --> 01:18:53,120
correct

01:18:50,159 --> 01:18:54,000
yeah besides the impact we had in debian

01:18:53,120 --> 01:18:56,719
the effort

01:18:54,000 --> 01:18:58,400
this effort also directly benefited the

01:18:56,719 --> 01:19:01,040
bazel project itself

01:18:58,400 --> 01:19:03,120
first we had our dependencies published

01:19:01,040 --> 01:19:06,080
we deleted unused dependencies

01:19:03,120 --> 01:19:07,199
upgraded outdated ones and as mentioned

01:19:06,080 --> 01:19:09,760
before

01:19:07,199 --> 01:19:10,640
we also fixed some problematic license

01:19:09,760 --> 01:19:13,600
issues

01:19:10,640 --> 01:19:15,440
besides the solution we developed for

01:19:13,600 --> 01:19:18,719
packaging bazel for debian

01:19:15,440 --> 01:19:19,920
can also be extended for other linux

01:19:18,719 --> 01:19:22,800
distributions

01:19:19,920 --> 01:19:24,719
therefore the bazel project became more

01:19:22,800 --> 01:19:27,679
distribution friendly

01:19:24,719 --> 01:19:29,280
next oh look at that i will talk about

01:19:27,679 --> 01:19:32,480
the remaining work

01:19:29,280 --> 01:19:36,640
yes now we are targeting debian 12

01:19:32,480 --> 01:19:38,239
and ubuntu 22.04 for our next steps

01:19:36,640 --> 01:19:40,640
we've already started the first part of

01:19:38,239 --> 01:19:42,400
that plan which is to remove the hacks

01:19:40,640 --> 01:19:44,800
and the workarounds which we initially

01:19:42,400 --> 01:19:46,800
implemented for expediency

01:19:44,800 --> 01:19:48,480
a key part of that is to properly

01:19:46,800 --> 01:19:51,120
package additional elements

01:19:48,480 --> 01:19:52,320
of the bazel infrastructure such such as

01:19:51,120 --> 01:19:55,920
java tools

01:19:52,320 --> 01:19:58,080
java rules cc rules and others

01:19:55,920 --> 01:19:59,199
currently we have bazel platforms and

01:19:58,080 --> 01:20:01,280
basal skylab

01:19:59,199 --> 01:20:04,080
packaged and awaiting the start of the

01:20:01,280 --> 01:20:05,440
debian 12 development cycle we are

01:20:04,080 --> 01:20:08,000
planning to add the others

01:20:05,440 --> 01:20:09,280
in the coming months we also want to

01:20:08,000 --> 01:20:12,239
enable dev helper

01:20:09,280 --> 01:20:13,760
to natively support bazel builds dev

01:20:12,239 --> 01:20:16,239
helper is the tool that we use

01:20:13,760 --> 01:20:18,880
in debian to make upstream software into

01:20:16,239 --> 01:20:20,480
debian packages in contrast to the

01:20:18,880 --> 01:20:23,360
workarounds that we're using

01:20:20,480 --> 01:20:25,520
for tensorflow we want dev helper to

01:20:23,360 --> 01:20:27,120
automatically detect that software is

01:20:25,520 --> 01:20:28,960
using bazel's build

01:20:27,120 --> 01:20:31,679
dev helper will then be able to call

01:20:28,960 --> 01:20:34,159
bazel to build that software

01:20:31,679 --> 01:20:35,360
find the resulting built files and

01:20:34,159 --> 01:20:37,520
install them properly

01:20:35,360 --> 01:20:39,760
into a debian package this will be

01:20:37,520 --> 01:20:40,800
further facilitated by some ongoing

01:20:39,760 --> 01:20:43,360
efforts in bazel

01:20:40,800 --> 01:20:44,159
that yoon will share with you as you may

01:20:43,360 --> 01:20:46,639
have noticed

01:20:44,159 --> 01:20:48,480
the issues of building a project offline

01:20:46,639 --> 01:20:50,400
with system installed libraries

01:20:48,480 --> 01:20:52,719
are not unique to the bazel project

01:20:50,400 --> 01:20:53,440
itself but also applied to other

01:20:52,719 --> 01:20:56,320
projects

01:20:53,440 --> 01:20:58,960
that are built with bazel this is one of

01:20:56,320 --> 01:21:01,600
the pain points of how bazel currently

01:20:58,960 --> 01:21:02,400
deals with external dependencies and

01:21:01,600 --> 01:21:04,880
solving this

01:21:02,400 --> 01:21:07,920
will be very helpful for the effort to

01:21:04,880 --> 01:21:10,320
integrate bazel with dev helper

01:21:07,920 --> 01:21:12,400
improving the dependency management in

01:21:10,320 --> 01:21:15,040
bazel is an ongoing effort

01:21:12,400 --> 01:21:15,760
and also a priority of the bazel open

01:21:15,040 --> 01:21:18,480
source team

01:21:15,760 --> 01:21:20,000
this year that's all for this talk thank

01:21:18,480 --> 01:21:22,960
you all for joining us

01:21:20,000 --> 01:21:24,960
at google open source live i would like

01:21:22,960 --> 01:21:27,679
to especially thank olek and

01:21:24,960 --> 01:21:28,000
other debian developers for initiating

01:21:27,679 --> 01:21:31,120
this

01:21:28,000 --> 01:21:32,800
effort and driving it forward and

01:21:31,120 --> 01:21:35,120
i would like to thank you and the rest

01:21:32,800 --> 01:21:36,960
of the bazel team for all their support

01:21:35,120 --> 01:21:38,239
in helping us to complete this very

01:21:36,960 --> 01:21:43,840
ambitious project

01:21:38,239 --> 01:21:43,840
thank you all for joining us

01:21:56,080 --> 01:21:59,440
thank you yona nolek i want to thank you

01:21:58,719 --> 01:22:01,120
both

01:21:59,440 --> 01:22:03,520
for your work making it easier for covet

01:22:01,120 --> 01:22:04,480
19 researchers to use both basal and

01:22:03,520 --> 01:22:06,639
tensorflow

01:22:04,480 --> 01:22:08,560
to find you new and better treatments

01:22:06,639 --> 01:22:10,320
for covet and other diseases

01:22:08,560 --> 01:22:12,000
i know that it was a team effort over

01:22:10,320 --> 01:22:12,800
some months but i really appreciate your

01:22:12,000 --> 01:22:14,960
leadership

01:22:12,800 --> 01:22:17,520
and the positive impact you're having on

01:22:14,960 --> 01:22:19,760
making the world a better place

01:22:17,520 --> 01:22:21,440
okay with that it's a wrap and now it's

01:22:19,760 --> 01:22:23,120
time for the after party

01:22:21,440 --> 01:22:25,040
come join us at the after party by

01:22:23,120 --> 01:22:27,280
clicking the watch live button

01:22:25,040 --> 01:22:29,280
on the events agenda page to be

01:22:27,280 --> 01:22:32,159
redirected to google meet

01:22:29,280 --> 01:22:33,840
anything else joe well today's speakers

01:22:32,159 --> 01:22:35,120
will also be joining the after party and

01:22:33,840 --> 01:22:37,199
we'll have some quizzes

01:22:35,120 --> 01:22:38,159
interactive activities and surprise

01:22:37,199 --> 01:22:52,239
guests

01:22:38,159 --> 01:22:54,320
we hope to see you all there thanks

01:22:52,239 --> 01:22:54,320

YouTube URL: https://www.youtube.com/watch?v=8dnTclL9A1k


