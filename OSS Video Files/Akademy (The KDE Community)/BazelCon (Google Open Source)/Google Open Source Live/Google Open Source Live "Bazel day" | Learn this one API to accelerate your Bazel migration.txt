Title: Google Open Source Live "Bazel day" | Learn this one API to accelerate your Bazel migration
Publication date: 2021-04-01
Playlist: Google Open Source Live
Description: 
	
Captions: 
	00:00:10,480 --> 00:00:12,560
Hi everyone, I'm so excited to be with you today.

00:00:12,560 --> 00:00:13,840
My name is Alex Eagle.

00:00:13,840 --> 00:00:17,440
I'm the author and one of the co-maintainers for rules_nodejs

00:00:17,440 --> 00:00:19,840
Also recently became a maintainer for rules_python.

00:00:20,720 --> 00:00:22,640
Formerly I was at Google on the Angular team

00:00:22,640 --> 00:00:26,240
and I was one of the team that rolled out type script language into Blaze

00:00:26,240 --> 00:00:27,760
Google's internal version of Bazel.

00:00:28,400 --> 00:00:31,520
And now I'm working to migrate enterprises to Bazel.

00:00:32,080 --> 00:00:33,520
Before I start I just want to say

00:00:33,520 --> 00:00:36,720
how much I miss interacting with you at BazelCon in the hallway track

00:00:36,720 --> 00:00:39,840
like we did the last three years, I hope we get to do that again soon.

00:00:39,840 --> 00:00:42,080
So, my talk today is about migrations

00:00:42,080 --> 00:00:44,160
and how to make them easier for your business.

00:00:44,160 --> 00:00:48,640
And, as we observed last year in my talk with Greg Magolan at BazelCon,

00:00:48,640 --> 00:00:50,400
Bazel migrations have a lot of risks:

00:00:50,960 --> 00:00:54,480
you might introduce a bug because you made a change in the build system;

00:00:54,480 --> 00:00:56,480
it can certainly take longer than you thought;

00:00:56,480 --> 00:00:58,400
it can cause problems for your developers.

00:00:58,960 --> 00:01:02,320
And, in our talk, we went over ways to mitigate risks.

00:01:02,320 --> 00:01:04,640
And, today, I want to dive deeply into one of those

00:01:05,760 --> 00:01:08,080
which is only change one thing at a time.

00:01:08,720 --> 00:01:11,840
The reason we do that is it's much easier if something breaks.

00:01:11,840 --> 00:01:14,160
Then we know what caused it, we can keep things simple

00:01:14,160 --> 00:01:17,280
and it's easier to reduce that breakage down to one precise cause.

00:01:17,920 --> 00:01:20,720
But what we often find is that it's hard to avoid

00:01:20,720 --> 00:01:22,720
being forced to change something in your build.

00:01:23,680 --> 00:01:26,240
You may find there's some existing part of your legacy builds system

00:01:26,240 --> 00:01:27,840
that just doesn't seem to work with Bazel.

00:01:28,640 --> 00:01:31,280
And, in my experience, there 's one API that we can learn

00:01:31,280 --> 00:01:34,960
that helps us to avoid having to make those kinds of changes

00:01:34,960 --> 00:01:36,560
in the tools that we call.

00:01:36,560 --> 00:01:38,640
And that API is simply the process.

00:01:39,840 --> 00:01:42,080
You're probably used to seeing processes on your machine

00:01:42,080 --> 00:01:43,520
you may not think about them that much.

00:01:44,320 --> 00:01:47,280
But there is actually an API here: it's available everywhere

00:01:48,400 --> 00:01:51,280
and this is how Bazel interacts with the tools that you're running.

00:01:51,840 --> 00:01:54,160
So, if you can think in terms of this process API

00:01:54,160 --> 00:01:56,400
I think that helps you to adapt Bazel

00:01:57,120 --> 00:01:58,560
and the way that you're calling your tools

00:01:59,120 --> 00:02:01,120
rather than having to change the tools that you run.

00:02:02,160 --> 00:02:04,880
So briefly, let's just remind ourselves what a process is.

00:02:04,880 --> 00:02:07,360
This is how programs are run on your computer.

00:02:07,360 --> 00:02:10,400
Every tool that you're running today in your legacy build

00:02:10,400 --> 00:02:11,840
is running inside of a process.

00:02:12,640 --> 00:02:15,360
A process works everywhere, in every language

00:02:15,360 --> 00:02:17,360
has great support for interacting with processes

00:02:18,000 --> 00:02:20,880
and it works on UNIX-type systems including Mac

00:02:20,880 --> 00:02:22,320
and also everything I'm going to talk about

00:02:22,320 --> 00:02:24,400
is almost translatable to Windows.

00:02:26,080 --> 00:02:30,560
And so I think this is a great general purpose way to think

00:02:30,560 --> 00:02:31,360
about the problem.

00:02:32,160 --> 00:02:34,640
The one slide I want you to remember from this talk

00:02:35,600 --> 00:02:39,280
is that you may hear someone say 'That tool doesn't work with Bazel.'

00:02:39,280 --> 00:02:43,040
And this should be the sign to you, this is a trigger...

00:02:43,680 --> 00:02:45,520
And you say, 'Why not? Is that really true?'

00:02:45,520 --> 00:02:46,960
I find that it's often not true.

00:02:48,320 --> 00:02:52,320
The main reason you can challenge that statement

00:02:52,320 --> 00:02:55,200
is to simply ask 'How can the tool tell that was called by Bazel?'

00:02:57,120 --> 00:02:59,360
'How was it called before, in the legacy build system?'

00:03:00,480 --> 00:03:04,560
And, if we can figure out all the parts of this process API

00:03:04,560 --> 00:03:06,160
and make everything look the same way it did

00:03:06,160 --> 00:03:08,320
when the tool was called under the old build system

00:03:08,320 --> 00:03:09,920
then it should work exactly the same way.

00:03:10,960 --> 00:03:13,280
So, in this talk I'll give some practical workarounds

00:03:13,280 --> 00:03:17,600
for some scenarios that we ran into while we were developing rules_nodejs

00:03:17,600 --> 00:03:19,120
and applying them at companies.

00:03:20,160 --> 00:03:21,920
But I do want to call out that

00:03:23,440 --> 00:03:24,800
there are trade-offs being made here.

00:03:25,920 --> 00:03:28,240
In some cases, in order to make your tools work

00:03:28,240 --> 00:03:30,240
you're going to give up some of Bazel's goodness

00:03:30,240 --> 00:03:31,520
in some part of your build graph.

00:03:31,520 --> 00:03:34,320
So, we're going to trade off compatibility for optimizations.

00:03:35,040 --> 00:03:38,800
This is something you have to think about in the context of your migration.

00:03:38,800 --> 00:03:41,840
It might make sense to have these de-optimizations at the beginning

00:03:41,840 --> 00:03:43,840
in order to get everything working the same way.

00:03:43,840 --> 00:03:46,880
And then you can find the slowest parts of your build

00:03:46,880 --> 00:03:49,920
and then just evolve those sub-parts of the graph.

00:03:50,800 --> 00:03:55,120
So, one example of a trade-off is that the swift compiler

00:03:55,120 --> 00:03:57,360
can be much, much slower by orders of magnitude

00:03:57,360 --> 00:04:00,480
if it doesn't find the incrementality bits from its previous run.

00:04:00,480 --> 00:04:03,280
And so, if we think about simply running the swift compiler

00:04:03,280 --> 00:04:06,160
as just some arbitrary process, then it may be a lot slower.

00:04:06,880 --> 00:04:08,720
That's the kind of trade-off that we may need to make.

00:04:09,600 --> 00:04:14,640
So, let's just look at one example of how Bazel calls a tool.

00:04:14,640 --> 00:04:17,520
I'm using genrule here, because I love genrule

00:04:17,520 --> 00:04:20,640
but, really, anytime Bazel calls a tool, you can think of it this way.

00:04:20,640 --> 00:04:22,960
It may just be that if you're using a custom rule

00:04:22,960 --> 00:04:25,280
you don't see the tool spelled out like it is here

00:04:25,280 --> 00:04:27,200
and you don't see the command line it's calling.

00:04:27,200 --> 00:04:29,520
But, if you unwrap the implementation of a rule

00:04:29,520 --> 00:04:33,680
you'll always find somewhere that it's calling something like context.action.run

00:04:33,680 --> 00:04:35,600
and calling out to a tool in this way.

00:04:38,480 --> 00:04:41,600
So, for this example the tool is "yq".

00:04:41,600 --> 00:04:42,960
This is a variant of "jq"

00:04:42,960 --> 00:04:46,640
the popular JSON manipulation library application

00:04:46,640 --> 00:04:48,560
and it handles yaml files.

00:04:48,560 --> 00:04:51,040
And so this one is just converting yaml to JSON.

00:04:51,040 --> 00:04:55,040
And it happens here, you can see that the command line has some flags

00:04:55,040 --> 00:04:56,320
that we're passing to this tool

00:04:56,320 --> 00:04:57,760
and those are sufficient in this case

00:04:57,760 --> 00:04:59,840
to make the tool work how you expect under Bazel

00:04:59,840 --> 00:05:01,920
to read inputs and produce outputs.

00:05:01,920 --> 00:05:03,280
So, this example is fine,

00:05:03,280 --> 00:05:05,120
but we're going to go to the rest of this talk

00:05:05,120 --> 00:05:09,440
with imagining that they were running a tool where this is not the case

00:05:09,440 --> 00:05:11,120
and something is not possible to run.

00:05:12,240 --> 00:05:15,600
So, one option for how to change the way the program is called

00:05:15,600 --> 00:05:18,800
is to find some way to change the behavior of the existing runtime.

00:05:19,360 --> 00:05:20,800
So, this is a little hacky

00:05:21,440 --> 00:05:25,440
but one example under Node is that there's a flag --require,

00:05:25,440 --> 00:05:27,360
that lets you run some bit of arbitrary script

00:05:27,360 --> 00:05:29,040
right before the program starts.

00:05:29,040 --> 00:05:30,400
Another example is in Java

00:05:30,400 --> 00:05:32,880
you can pass the class path argument to the JVM

00:05:32,880 --> 00:05:37,040
which allows you to do something like maybe shadow an existing class

00:05:37,040 --> 00:05:37,840
to change its behavior.

00:05:38,640 --> 00:05:42,720
This is obviously risky, because it's easy for monkey patching

00:05:42,720 --> 00:05:45,760
to cause weird action at a distance bugs in the program.

00:05:45,760 --> 00:05:47,840
So, be really careful doing this option.

00:05:47,840 --> 00:05:50,640
Do a single one-liner, I'll show an example of this later.

00:05:51,360 --> 00:05:54,320
Another option is to change the entry point of the program

00:05:55,200 --> 00:05:57,040
but staying within the same process.

00:05:57,040 --> 00:06:00,880
So, essentially, you take that tool and instead of calling it as a process

00:06:00,880 --> 00:06:02,160
you call it as a library.

00:06:02,160 --> 00:06:04,160
You find wherever that CLI entry point is

00:06:04,160 --> 00:06:07,600
and, as close as possible, try to invoke it the same way.

00:06:07,600 --> 00:06:09,280
And that gives you just a little bit of room

00:06:09,280 --> 00:06:12,400
to swap in your own logic at the top of the program

00:06:12,400 --> 00:06:13,920
to change the way it runs.

00:06:13,920 --> 00:06:15,520
This is nice because it allows you

00:06:15,520 --> 00:06:18,320
to have more power inside of that same process.

00:06:18,320 --> 00:06:20,160
You can do things like mutate the arguments

00:06:21,600 --> 00:06:25,760
and that would be harder to do in the third option

00:06:25,760 --> 00:06:27,440
which is the most common option

00:06:27,440 --> 00:06:30,400
where you'll just run some extra program as a parent process.

00:06:31,280 --> 00:06:33,120
This is typically something like a bash script

00:06:33,120 --> 00:06:37,120
and it just does some sort of tweaks to the way the process is being run

00:06:37,120 --> 00:06:39,680
and then it invokes the original tool as a child process.

00:06:40,480 --> 00:06:44,080
For the rest of the talk I'm going to dive into the specifics of the process API

00:06:44,880 --> 00:06:47,360
and how to use one of those three wrapper-approaches

00:06:47,360 --> 00:06:50,800
to make the execution match the way it ran under your legacy build.

00:06:51,680 --> 00:06:55,280
So, the first things I'll group as roughly the inputs to the process.

00:06:55,280 --> 00:06:57,280
So, it takes a list of arguments.

00:06:57,280 --> 00:06:59,120
Obviously here you must take a lot of care

00:06:59,120 --> 00:07:00,640
with things like spaces and escaping

00:07:00,640 --> 00:07:02,480
so the arguments are preserved exactly

00:07:02,480 --> 00:07:03,680
when Bazel calls the program.

00:07:04,400 --> 00:07:08,160
It can read a dictionary of keyvalue pairs from the environment.

00:07:08,160 --> 00:07:10,240
It can run in a working directory

00:07:10,240 --> 00:07:13,520
and usually most of the paths that the tool are going to work with

00:07:13,520 --> 00:07:15,920
are relative to that working directory.

00:07:15,920 --> 00:07:17,760
And it reads bytes from its standard input.

00:07:18,560 --> 00:07:20,320
So, let's dive into a few of those.

00:07:20,320 --> 00:07:21,840
I'm just going to give a few examples.

00:07:21,840 --> 00:07:23,760
This is not meant to be an exhaustive list

00:07:23,760 --> 00:07:25,760
but this is sort of how in rules_nodejs

00:07:25,760 --> 00:07:30,240
we've thought about using this process API to fix some of the compatibility issues.

00:07:30,240 --> 00:07:32,960
So, when dealing with arguments, for example

00:07:32,960 --> 00:07:35,760
you might find that your wrapper needs some of its own arguments.

00:07:36,320 --> 00:07:39,280
So, if you're in process, you can just mutate the argv

00:07:39,280 --> 00:07:40,560
just strip some things off of it

00:07:41,840 --> 00:07:45,520
assuming that your language runtime has a mutable version of the argv.

00:07:46,720 --> 00:07:50,000
Or, in a parent process you can just take some of the arguments yourself

00:07:50,000 --> 00:07:52,720
and then selectively forward some of them onto the child process.

00:07:53,280 --> 00:07:55,600
So, one example we've had is a test runner

00:07:55,600 --> 00:07:57,520
where we needed to pass some Bazel arguments

00:07:57,520 --> 00:07:58,480
to the test runner,

00:07:59,040 --> 00:08:02,800
but then the user might want to pass their own args to their tests

00:08:02,800 --> 00:08:04,800
and we need to keep those two things separate

00:08:04,800 --> 00:08:07,120
and make sure the test runner doesn't see the arguments

00:08:07,120 --> 00:08:09,600
that are meant for Bazel to control the program.

00:08:11,200 --> 00:08:13,840
The next example is environment variables.

00:08:13,840 --> 00:08:15,360
So, this is a little confusing.

00:08:15,360 --> 00:08:17,840
I'm going to have to point you to the Bazel documentation.

00:08:17,840 --> 00:08:21,760
You should look up the use_default_shell_env argument

00:08:22,560 --> 00:08:25,360
which changes the behavior of a given tool

00:08:25,360 --> 00:08:28,080
so that it uses the action environment around it.

00:08:28,080 --> 00:08:30,640
And then you can use --action_env

00:08:30,640 --> 00:08:33,840
to change the environment for all of the actions that run.

00:08:35,040 --> 00:08:37,600
And keep in mind when you're changing the environment for an action

00:08:37,600 --> 00:08:39,840
this will be part of the action's input hash

00:08:39,840 --> 00:08:41,920
and so it will bust the cache when it changes.

00:08:44,000 --> 00:08:45,600
For things that are runnable like tests,

00:08:45,600 --> 00:08:48,720
there's --test_env, which doesn't have as many caveats

00:08:48,720 --> 00:08:49,760
and generally works fine.

00:08:51,520 --> 00:08:54,480
Then you also have a few rules that have an "env" attribute.

00:08:54,480 --> 00:08:58,880
So, this is a really nice easy way to pass some additional environment variables

00:08:58,880 --> 00:09:01,280
but it's not typically on most Bazel rules that I've seen.

00:09:02,000 --> 00:09:05,360
And, of course, as a last resort, you can imagine if you write a wrapper

00:09:05,360 --> 00:09:07,440
you can just take an input file

00:09:07,440 --> 00:09:10,240
which expresses all of the environment variables

00:09:10,240 --> 00:09:11,600
and then you can just set those

00:09:11,600 --> 00:09:14,000
either in process or in a parent process wrapper

00:09:14,000 --> 00:09:15,600
so that they're available when the tool runs.

00:09:17,840 --> 00:09:19,600
The next one I'll talk about is the working directory.

00:09:19,600 --> 00:09:21,040
We have a couple of different examples here.

00:09:21,760 --> 00:09:24,960
The first is that of course Bazel always runs tools

00:09:24,960 --> 00:09:26,560
in the workspace route

00:09:26,560 --> 00:09:30,320
and this is usually different from how most tools expect to be run.

00:09:30,320 --> 00:09:31,920
Especially in the JavaScript ecosystem

00:09:32,480 --> 00:09:34,640
tools tend to expect that the configuration file

00:09:34,640 --> 00:09:37,040
is going to be in the same directory as the working directory.

00:09:37,920 --> 00:09:42,160
So, again, here we can wrap the program with a parent process

00:09:42,160 --> 00:09:43,520
that changes the working directory

00:09:43,520 --> 00:09:45,440
and then spawns the original as a sub process.

00:09:46,080 --> 00:09:47,760
Or we can do it in-process.

00:09:47,760 --> 00:09:50,720
In Node I mentioned there's this --require option.

00:09:50,720 --> 00:09:54,640
Here's an example where we take --node options

00:09:54,640 --> 00:09:56,720
which is a way to wrap the arguments

00:09:56,720 --> 00:09:58,320
so, we're going to strip that off in Bazel.

00:09:58,960 --> 00:10:02,480
and then the --require part is going to get passed to Node

00:10:02,480 --> 00:10:05,440
and then the argument to that is a little JavaScript file

00:10:05,440 --> 00:10:07,440
that's a one-liner, just a chdir.

00:10:08,000 --> 00:10:09,120
And so this is a key way

00:10:09,120 --> 00:10:11,200
we can change the working directory of a process

00:10:11,200 --> 00:10:13,600
without having to make a wrapper around it

00:10:13,600 --> 00:10:16,480
keeping in mind wrappers have the extra expense of having an extra process

00:10:16,480 --> 00:10:19,280
and possibly an extra dependency on something like Bash

00:10:19,280 --> 00:10:22,080
so this can be a nice minimal way to do it if you need it to run everywhere.

00:10:23,840 --> 00:10:26,800
I'm not sure if other language runtimes have a feature like this

00:10:26,800 --> 00:10:27,760
but it's worth looking for.

00:10:30,160 --> 00:10:31,120
The next example

00:10:31,120 --> 00:10:34,000
is where the working directory needs to be in the output tree.

00:10:34,560 --> 00:10:38,480
This may seem strange but there are tools in the react ecosystem, for example

00:10:38,480 --> 00:10:41,280
where the output always goes into "./build"

00:10:41,280 --> 00:10:42,960
and it's not controllable by the user.

00:10:43,520 --> 00:10:44,960
To make this tool work under Bazel

00:10:44,960 --> 00:10:47,920
you're going to have to switch directories to the output tree

00:10:47,920 --> 00:10:49,200
and then run the tool.

00:10:49,200 --> 00:10:51,360
Then the outputs that it writes will just happen to match up

00:10:51,360 --> 00:10:53,680
with where Bazel expects them to be written and it will work.

00:10:56,240 --> 00:10:59,680
The next section is about the output parts of the process API.

00:10:59,680 --> 00:11:02,080
This is the exit code, which is just generally saying

00:11:02,080 --> 00:11:03,840
whether things went okay when the program ran

00:11:04,480 --> 00:11:06,080
and the stdout out and stderr

00:11:06,080 --> 00:11:08,320
which are two byte streams that the program can write to.

00:11:10,560 --> 00:11:14,320
For the exit code, most tools will just exit zero on success

00:11:14,320 --> 00:11:16,560
and Bazel fails if they exit non-zero.

00:11:16,560 --> 00:11:18,080
And that's typically what you want.

00:11:18,080 --> 00:11:19,120
There are some cases

00:11:19,120 --> 00:11:21,600
where the exit code actually does matter.

00:11:21,600 --> 00:11:25,200
One of them is if the tool exits with some other novel exit code

00:11:25,200 --> 00:11:26,960
like how many changes it made

00:11:26,960 --> 00:11:28,720
because the programmer felt they were being clever

00:11:28,720 --> 00:11:30,640
and were allowed to return whatever exit code they wanted

00:11:30,640 --> 00:11:32,000
so, they added some information in there.

00:11:33,440 --> 00:11:34,880
The more common example we've seen

00:11:34,880 --> 00:11:37,680
is we want to write a test under Bazel that's a negative test.

00:11:37,680 --> 00:11:40,640
It asserts that the build fails with some error message.

00:11:40,640 --> 00:11:42,080
This can be important in your migration.

00:11:42,080 --> 00:11:43,680
You want a way to express that

00:11:43,680 --> 00:11:46,800
as you're writing the Bazel wrappers for your code

00:11:46,800 --> 00:11:49,040
you want to know the error handling case is going to work correctly.

00:11:49,040 --> 00:11:50,160
You want to write a test for that.

00:11:51,840 --> 00:11:55,520
One way to do this is to write a parent process wrapper

00:11:55,520 --> 00:11:56,800
that captures the exit code.

00:11:57,920 --> 00:12:02,720
Another way, under rules_nodejs, is Matt McKay, one of our co-maintainers

00:12:03,520 --> 00:12:06,640
added a feature so you can request the exit code be one of the outputs

00:12:06,640 --> 00:12:08,800
rather than being seen by Bazel.

00:12:08,800 --> 00:12:10,160
So, it will always exit zero

00:12:10,160 --> 00:12:12,560
and you can reference the exit code as an output file.

00:12:14,560 --> 00:12:16,560
Stdout and stderr are very similar.

00:12:16,560 --> 00:12:19,360
Again, there can be things a tool wants to produce on stdout

00:12:19,360 --> 00:12:21,280
and you want to grab those as an action output.

00:12:23,040 --> 00:12:24,400
You can use genrule for this

00:12:24,400 --> 00:12:27,200
as we showed with "yq" example earlier

00:12:27,200 --> 00:12:29,040
or you can use a parent process wrapper

00:12:29,040 --> 00:12:33,200
that can just read from stdout and convert it to being an output file.

00:12:33,200 --> 00:12:35,920
And, again, Matt McKay built this in the rules_nodejs.

00:12:35,920 --> 00:12:39,840
So, in our case you can just ask for the stdout to be an action output file.

00:12:41,520 --> 00:12:42,880
The other obvious caveat here

00:12:42,880 --> 00:12:45,680
if you've done anything with persistent workers, or ibazel

00:12:45,680 --> 00:12:47,360
which is the watch mode for Bazel

00:12:48,160 --> 00:12:52,240
those both expect to communicate with the tool over stdin and stdout

00:12:52,240 --> 00:12:54,480
and so you may need to patch the runtime in some way

00:12:54,480 --> 00:12:56,560
to assign stdout to stderr.

00:12:57,280 --> 00:12:59,200
In both cases you're free to write to stderr

00:12:59,200 --> 00:13:00,960
but you don't want to have to go through this whole tool

00:13:00,960 --> 00:13:03,600
find all the places it writes to stdout and change them

00:13:03,600 --> 00:13:05,760
so usually you'll find a way in your runtime

00:13:05,760 --> 00:13:07,040
to be able to patch that behavior.

00:13:09,680 --> 00:13:11,680
The last category of API I want to talk about

00:13:11,680 --> 00:13:13,680
is interactions outside of the process.

00:13:14,400 --> 00:13:17,040
There are parent and child processes that can know about each other

00:13:17,680 --> 00:13:20,720
and, obviously, the program can write to the file system

00:13:20,720 --> 00:13:21,840
and read from the file system

00:13:21,840 --> 00:13:23,920
and has open file handles called descriptors.

00:13:24,480 --> 00:13:27,120
And also it can receive signals telling it what to do.

00:13:29,440 --> 00:13:30,400
For the first of those

00:13:30,400 --> 00:13:33,040
there's this concept of a union file system under Bazel.

00:13:33,600 --> 00:13:36,000
Bazel is very opinionated about putting the outputs

00:13:36,720 --> 00:13:40,400
into this distinct tree, Bazel out and not next to the source files.

00:13:40,400 --> 00:13:43,760
But a lot of tools expect to be able to make relative references

00:13:43,760 --> 00:13:46,320
between a generated file and another source file.

00:13:46,320 --> 00:13:49,760
So, I called this Union FS, because our solution for this

00:13:49,760 --> 00:13:52,000
has typically been to convince the program

00:13:52,000 --> 00:13:53,360
those things are actually next to each other

00:13:53,360 --> 00:13:55,600
or change the way these relative references work.

00:13:55,600 --> 00:13:59,360
But that, again, is an example of needing to make significant changes to the tool

00:13:59,360 --> 00:14:01,840
instead of just making it compatible under Bazel.

00:14:02,400 --> 00:14:05,920
This one is a cool trick: you may think that Bazel disallows you

00:14:05,920 --> 00:14:09,120
from having the same file be in the input tree and the output tree.

00:14:09,120 --> 00:14:11,840
But, this is actually only true if the output is labeled.

00:14:11,840 --> 00:14:15,120
which is to say it was a pre-declared output of some rule.

00:14:15,120 --> 00:14:18,560
As long as you just reference a target and that target does some copies

00:14:18,560 --> 00:14:21,600
and it happens to put copies of your files into the output tree

00:14:21,600 --> 00:14:23,440
Bazel doesn't know about that and it works fine.

00:14:24,560 --> 00:14:26,560
So you can just copy your sources to the output tree

00:14:26,560 --> 00:14:28,720
and make it self-contained and then your tool will run

00:14:28,720 --> 00:14:31,600
and see the files next to each other like they were intended to be.

00:14:32,400 --> 00:14:34,720
We actually have this built into rules_nodejs.

00:14:35,360 --> 00:14:38,480
You can see, here's a documentation link to our copy_to_bin rule.

00:14:39,680 --> 00:14:42,400
If you feel this would be useful for you outside of node_js

00:14:42,400 --> 00:14:44,320
which I imagine it would be

00:14:44,320 --> 00:14:48,400
you can find this pull request no.217 on Bazel Skylib, and comment there.

00:14:48,400 --> 00:14:50,800
They're actually asking whether it's useful generally

00:14:50,800 --> 00:14:52,800
outside of the nodejs use case.

00:14:54,080 --> 00:14:55,600
Let's talk about signals for a minute.

00:14:55,600 --> 00:15:00,080
Signals are an interesting way to affect the process' behavior.

00:15:00,080 --> 00:15:03,280
Normally under Bazel you don't think about signals being part of the API

00:15:03,280 --> 00:15:04,320
when you call a tool

00:15:04,960 --> 00:15:06,880
but, if you're writing a parent process

00:15:07,600 --> 00:15:10,400
then this can be a really clever way to control the child process.

00:15:11,840 --> 00:15:13,520
Let's take, for example, watch mode.

00:15:13,520 --> 00:15:16,640
Watch mode is where a tool expects it's going to watch the source files

00:15:16,640 --> 00:15:18,160
or something in the output tree

00:15:18,160 --> 00:15:20,080
and then it's going to rebuild them every time it changes.

00:15:20,960 --> 00:15:22,720
So, this can be a problem

00:15:22,720 --> 00:15:27,680
because the intermediate state in the Bazel out folder is disruptive.

00:15:27,680 --> 00:15:29,520
Bazel will actually unlink the files,

00:15:29,520 --> 00:15:31,680
meaning they'll appear to be deleted and then re-added

00:15:31,680 --> 00:15:32,720
so tools can freak out.

00:15:32,720 --> 00:15:34,160
They can also see intermediate state

00:15:34,160 --> 00:15:36,400
where not all of the things have been written to the output tree yet.

00:15:38,560 --> 00:15:41,360
I want to give credit to Dan Muller from the rules_nodejs team

00:15:41,360 --> 00:15:43,920
who came up with this approach for running watch mode tools.

00:15:43,920 --> 00:15:49,040
What we can do is, instead of having to make the tool aware of

00:15:49,040 --> 00:15:54,058
the Bazel persistent worker API or the ibazel API which writes to stdin

00:15:54,058 --> 00:15:55,520
which writes to stdin and tells the tool that it's time to work,

00:15:56,080 --> 00:15:59,120
we can actually intercept that part of the communication with Bazel.

00:15:59,120 --> 00:16:01,040
So intercept stdin and write to stdout

00:16:01,040 --> 00:16:03,200
to communicate with Bazel from our wrapper process.

00:16:03,760 --> 00:16:05,680
Then the wrapper can control the silent process

00:16:05,680 --> 00:16:09,440
by sending it a SIGSTP to pause it and a SIGCONT to resume it.

00:16:09,440 --> 00:16:11,680
It's the same thing as if you press ctrl+z on the command line

00:16:12,400 --> 00:16:14,240
then FG to resume the program.

00:16:15,360 --> 00:16:15,920
This is really cool.

00:16:15,920 --> 00:16:17,760
It just pauses the program while Bazel is running

00:16:17,760 --> 00:16:19,440
so you can get that same watch mode behavior

00:16:19,440 --> 00:16:21,920
without having to change the program you're calling.

00:16:21,920 --> 00:16:24,080
Symlinks are a common source of trouble

00:16:24,080 --> 00:16:25,760
especially in the JavaScript ecosystem

00:16:25,760 --> 00:16:29,360
because Bazel runs tools in a Symlink forest.

00:16:29,360 --> 00:16:31,360
If it's an action this is called the exec root

00:16:31,360 --> 00:16:33,520
and if it's a test it's called the runfiles root.

00:16:33,520 --> 00:16:36,000
And under the default spawn strategy

00:16:36,000 --> 00:16:39,200
there're a bunch of symlinks here out to the rest of the file system.

00:16:39,200 --> 00:16:41,440
And if the tool follows those symlinks

00:16:41,440 --> 00:16:43,680
they can find inputs they weren't supposed to read.

00:16:43,680 --> 00:16:45,200
That makes your build non hermetic

00:16:45,200 --> 00:16:47,920
but it also can make the tool behave wrong

00:16:47,920 --> 00:16:49,440
because it may find some input

00:16:49,440 --> 00:16:51,760
that conflicts with some input that you wanted it to find.

00:16:53,200 --> 00:16:55,680
One tip here is to go check out the sandbox FS

00:16:55,680 --> 00:16:57,760
which was this effort by Julio and some others

00:16:57,760 --> 00:17:01,760
to make a better sandbox that doesn't just base on symlinks.

00:17:01,760 --> 00:17:03,840
I don't know what the state of that project is.

00:17:04,800 --> 00:17:07,440
You might be able to configure your tool to avoid following symlinks.

00:17:07,440 --> 00:17:10,080
In Node it's pretty typical that you can pass a couple of options

00:17:10,080 --> 00:17:11,920
to the Node interpreter.

00:17:12,880 --> 00:17:14,000
And, actually, in rules_nodejs

00:17:14,000 --> 00:17:18,160
we went so far as to have a patch written by Ryan Day,

00:17:18,160 --> 00:17:19,840
which changes the file system API

00:17:19,840 --> 00:17:22,720
so that the symlinks actually appear to be regular files and directories

00:17:22,720 --> 00:17:23,680
rather than symlinks

00:17:23,680 --> 00:17:26,080
so the program can't tell it's running in this Bazel environment.

00:17:28,320 --> 00:17:29,440
The last thing I'll mention

00:17:29,440 --> 00:17:34,480
is sometimes you can just back off from the Bazel idioms.

00:17:35,440 --> 00:17:37,440
One idiom is to run things in the sandbox,

00:17:37,440 --> 00:17:39,760
but Bazel makes input files read-only

00:17:39,760 --> 00:17:43,040
and if your tool expects it's going to write to the input files

00:17:43,040 --> 00:17:44,880
you may have to just give up on sandboxing.

00:17:44,880 --> 00:17:46,400
You can always mark this as local

00:17:46,400 --> 00:17:48,320
and you can find a way to make that tool run.

00:17:49,040 --> 00:17:51,760
Again, this is a trade-off between the Bazel idioms

00:17:51,760 --> 00:17:53,040
and making things more compatible.

00:17:53,760 --> 00:17:55,600
Those are all the examples I have time for today.

00:17:55,600 --> 00:17:58,480
I just want to remind you that I think, in a migration

00:17:58,480 --> 00:18:01,360
it's wise to try to change only one thing at a time.

00:18:01,360 --> 00:18:05,440
And you should always challenge the notion of "This tool doesn't work under Bazel"

00:18:05,440 --> 00:18:08,240
to find a way to run your tools the same way you did before.

00:18:08,240 --> 00:18:13,840

YouTube URL: https://www.youtube.com/watch?v=nf9mOUvLkjE


