Title: Meet MariaDB 10.2
Publication date: 2017-12-05
Playlist: DebConf 16
Description: 
	by Sergei Golubchik

At: Debconf 16 video RSS feed
https://debconf16.debconf.org/
Room: Menzies 9
Scheduled start: 2016-07-05 14:00:00
Captions: 
	00:00:00,030 --> 00:00:07,109
okay so the next session will be from

00:00:03,240 --> 00:00:12,599
Sega go look check roughly the meat

00:00:07,109 --> 00:00:14,849
MariaDB 10.2 yeah yeah so listen my

00:00:12,599 --> 00:00:18,359
session meet me may need to be 10.2

00:00:14,849 --> 00:00:33,870
about the upcoming milady be released

00:00:18,359 --> 00:00:36,899
endpoint Oh oops let me yeah sorry so

00:00:33,870 --> 00:00:39,329
first are those are stickers marine

00:00:36,899 --> 00:00:41,129
image tickets the small ones and larger

00:00:39,329 --> 00:00:43,079
ones and just the tip I found yesterday

00:00:41,129 --> 00:00:45,239
those large ones have very good to keep

00:00:43,079 --> 00:00:45,930
from keeping your from unlocking

00:00:45,239 --> 00:00:48,270
all the time

00:00:45,930 --> 00:00:50,190
and they're also ones that looks very

00:00:48,270 --> 00:00:56,039
good on the laptop but there are a few

00:00:50,190 --> 00:00:58,469
of them anyway so let's get going

00:00:56,039 --> 00:01:01,260
is anyone who doesn't know what marine

00:00:58,469 --> 00:01:03,180
debris is going into when war famine

00:01:01,260 --> 00:01:06,030
that a little time on that oh not at all

00:01:03,180 --> 00:01:10,650
ok so I'll go quickly so it's a fork of

00:01:06,030 --> 00:01:12,420
my squirrel drop-in replacement but the

00:01:10,650 --> 00:01:15,180
meaning of the drop-in replacement it's

00:01:12,420 --> 00:01:17,400
changes over time so when we just fork

00:01:15,180 --> 00:01:19,200
it it was like exactly exact copy you

00:01:17,400 --> 00:01:21,479
could swap it nobody would notice

00:01:19,200 --> 00:01:24,630
anything but over time we were adding

00:01:21,479 --> 00:01:26,610
more features and fix in some box that

00:01:24,630 --> 00:01:28,890
married my spell didn't and metal was

00:01:26,610 --> 00:01:31,290
adding features that we ported and some

00:01:28,890 --> 00:01:32,820
features that we didn't port so now we

00:01:31,290 --> 00:01:35,820
say that it's well drop-in replacement

00:01:32,820 --> 00:01:37,439
for like practical purposes but if you'd

00:01:35,820 --> 00:01:39,210
like to make a point that it's different

00:01:37,439 --> 00:01:41,610
you could create some contract

00:01:39,210 --> 00:01:43,140
application where you will see the

00:01:41,610 --> 00:01:44,880
difference between masculine mini DB for

00:01:43,140 --> 00:01:47,060
example the version is different you'll

00:01:44,880 --> 00:01:50,670
see I'll talk about it later

00:01:47,060 --> 00:01:52,049
but when a DB in certain sense its mum

00:01:50,670 --> 00:01:54,360
is called compatible than my skull

00:01:52,049 --> 00:01:56,250
itself because for every major version

00:01:54,360 --> 00:01:59,130
in my school they make big changes that

00:01:56,250 --> 00:02:00,810
break complete compatibility so for

00:01:59,130 --> 00:02:03,780
example my DB is more compatible with my

00:02:00,810 --> 00:02:06,750
squirrel v 5m SQL 5 6 in many DB's more

00:02:03,780 --> 00:02:11,640
compatible with mysql 5 6 then MySQL 5 7

00:02:06,750 --> 00:02:13,410
so drop-in replacement is depends on can

00:02:11,640 --> 00:02:17,820
perturbation how you look at it

00:02:13,410 --> 00:02:21,510
it is in Debian since 2013 and now it's

00:02:17,820 --> 00:02:23,070
in Jesse at version 10 0 25 and the

00:02:21,510 --> 00:02:25,500
packaging of multi-beam Debian is

00:02:23,070 --> 00:02:28,920
maintained by Auto key Colin he'll have

00:02:25,500 --> 00:02:32,190
he'll talk about it later today and the

00:02:28,920 --> 00:02:33,240
melody be is as a project is managed may

00:02:32,190 --> 00:02:34,670
need to be serviced the project is

00:02:33,240 --> 00:02:39,720
managed by a nonprofit organization

00:02:34,670 --> 00:02:42,420
maybe foundation by the way talk rules

00:02:39,720 --> 00:02:45,330
so I might tend to talk too fast

00:02:42,420 --> 00:02:47,940
although I'll try not to and I might get

00:02:45,330 --> 00:02:50,640
technical too technical sometimes if you

00:02:47,940 --> 00:02:52,860
have questions interrupt me right away

00:02:50,640 --> 00:02:58,890
don't wait till the end of the talk so

00:02:52,860 --> 00:03:00,540
okay yeah oh you can shout then you

00:02:58,890 --> 00:03:04,710
won't need the mic or you can take a mic

00:03:00,540 --> 00:03:07,140
whatever yeah so whoever I'm talking

00:03:04,710 --> 00:03:09,840
about MIDI be so my DB is based on my

00:03:07,140 --> 00:03:14,790
spell code base and I was a comic my

00:03:09,840 --> 00:03:16,760
spell developer since 1998 and since it

00:03:14,790 --> 00:03:20,280
was before my school it was created and

00:03:16,760 --> 00:03:21,600
I'm in mariadb since 2010 that was

00:03:20,280 --> 00:03:23,280
before my really big corporation was

00:03:21,600 --> 00:03:25,560
okay now I work in Meribah corporation

00:03:23,280 --> 00:03:28,460
as chief architect milady be on some

00:03:25,560 --> 00:03:33,300
responsible for security at medieval org

00:03:28,460 --> 00:03:36,170
so what is ten - ten - is now about nine

00:03:33,300 --> 00:03:39,300
months in active development Soviet

00:03:36,170 --> 00:03:43,350
agent features into it and currently

00:03:39,300 --> 00:03:47,100
it's ten point two point one alpha which

00:03:43,350 --> 00:03:49,260
was released yesterday and we are going

00:03:47,100 --> 00:03:52,500
to make it better very soon like nine

00:03:49,260 --> 00:03:54,600
months should be enough and by the end

00:03:52,500 --> 00:03:56,250
of the year the plan is to make a J and

00:03:54,600 --> 00:04:07,410
then it'll be in straight in Debian

00:03:56,250 --> 00:04:11,400
stretch yes then what so practically

00:04:07,410 --> 00:04:14,730
it's for 21 it was one in the half year

00:04:11,400 --> 00:04:17,580
between the we started developing and up

00:04:14,730 --> 00:04:18,060
to the J and then we maintain it for

00:04:17,580 --> 00:04:20,580
five years

00:04:18,060 --> 00:04:24,260
so if ten two will be in stretch than

00:04:20,580 --> 00:04:24,260
it's five years we will have to do that

00:04:26,310 --> 00:04:33,610
but because I said in JC this 10-0 so

00:04:31,060 --> 00:04:37,390
I'll quickly talk about 10:1 simply

00:04:33,610 --> 00:04:41,350
because 10:1 was not in any Debian so 21

00:04:37,390 --> 00:04:44,890
when GA in October October 2015

00:04:41,350 --> 00:04:47,080
currently it's well our latest GA we do

00:04:44,890 --> 00:04:50,200
one release every month and the next

00:04:47,080 --> 00:04:52,660
release will be 10 116 it'll be in two

00:04:50,200 --> 00:04:54,940
weeks hopefully you actually pretty good

00:04:52,660 --> 00:04:58,710
now with release scheduler so it'll be

00:04:54,940 --> 00:05:03,430
in two weeks no folks above that and

00:04:58,710 --> 00:05:05,380
again I won't do a big talk about 10:1

00:05:03,430 --> 00:05:07,870
features because it only it'll need

00:05:05,380 --> 00:05:11,440
another hour and I've done this talk so

00:05:07,870 --> 00:05:14,190
just very quickly just some major

00:05:11,440 --> 00:05:18,400
features of 10:1 that are not ingesting

00:05:14,190 --> 00:05:20,650
it's on the replication front its Galera

00:05:18,400 --> 00:05:22,840
cluster replication and optimistic

00:05:20,650 --> 00:05:24,370
parallel replication optimistic power

00:05:22,840 --> 00:05:27,400
application means that then master

00:05:24,370 --> 00:05:30,460
replicates to slave slave optimistically

00:05:27,400 --> 00:05:32,050
assumes that those events do not

00:05:30,460 --> 00:05:34,540
conflict and don't depend on each other

00:05:32,050 --> 00:05:36,400
and tries to him to execute as many

00:05:34,540 --> 00:05:38,530
events impossible in parallel and when

00:05:36,400 --> 00:05:40,270
it notices in conflict it can roll back

00:05:38,530 --> 00:05:43,360
and conflict in event and do it well

00:05:40,270 --> 00:05:45,010
later so it allows the slave to achieve

00:05:43,360 --> 00:05:49,330
much higher parallelism than master has

00:05:45,010 --> 00:05:53,190
so it helps slave not to lag behind the

00:05:49,330 --> 00:05:55,540
master on the security front there was

00:05:53,190 --> 00:05:58,690
encryption and I mean that data at rest

00:05:55,540 --> 00:06:00,790
encryption so data are encrypted on disk

00:05:58,690 --> 00:06:02,920
energy be tables are encrypted in a DB

00:06:00,790 --> 00:06:04,900
logs are encrypted binary logs encrypted

00:06:02,920 --> 00:06:06,520
or temporary files that the server might

00:06:04,900 --> 00:06:09,450
need to write to disk are also encrypted

00:06:06,520 --> 00:06:12,100
if everything is done properly the data

00:06:09,450 --> 00:06:14,350
on disk will never be unencrypted so

00:06:12,100 --> 00:06:15,700
anytime one can pull off the plug and in

00:06:14,350 --> 00:06:17,650
Simon's the disk as much as you want

00:06:15,700 --> 00:06:20,080
there should be no plaintext data on

00:06:17,650 --> 00:06:23,380
there that's also password validation

00:06:20,080 --> 00:06:26,380
that uses different plugins and one can

00:06:23,380 --> 00:06:28,180
enable lib correct plug-in and then be a

00:06:26,380 --> 00:06:30,070
password in Murray DB will be validated

00:06:28,180 --> 00:06:32,830
the same rules that you probably have

00:06:30,070 --> 00:06:34,480
for your normal UNIX passwords latest

00:06:32,830 --> 00:06:35,950
carbon is more useful when you don't

00:06:34,480 --> 00:06:37,780
have encryption but can also be used

00:06:35,950 --> 00:06:38,870
with encryption it means that when the

00:06:37,780 --> 00:06:40,490
data are deleted

00:06:38,870 --> 00:06:41,990
that's a separate background thread that

00:06:40,490 --> 00:06:43,400
goes and physically delete them from the

00:06:41,990 --> 00:06:45,380
table instead of just marking them

00:06:43,400 --> 00:06:47,510
deleted it may be useful if you well

00:06:45,380 --> 00:06:49,729
make sure weren't sure that to be sure

00:06:47,510 --> 00:06:52,660
that deleted data are actually really

00:06:49,729 --> 00:06:56,630
deleted and are not present anywhere

00:06:52,660 --> 00:06:59,290
there were extension of SQL syntax a

00:06:56,630 --> 00:07:01,280
statement which allows to change

00:06:59,290 --> 00:07:03,500
configuration variable for duration of

00:07:01,280 --> 00:07:05,990
one statement automatically changing it

00:07:03,500 --> 00:07:08,510
back when the statement ends analyze

00:07:05,990 --> 00:07:11,900
statement which works similar to explain

00:07:08,510 --> 00:07:14,450
but online explain explain guesses what

00:07:11,900 --> 00:07:16,130
the execution plan will be internalized

00:07:14,450 --> 00:07:18,380
actually runs the statement and then

00:07:16,130 --> 00:07:20,660
shows what the execution plan actually

00:07:18,380 --> 00:07:23,270
was which exact row numbers and

00:07:20,660 --> 00:07:24,260
everything compound statements then

00:07:23,270 --> 00:07:27,139
optimizer

00:07:24,260 --> 00:07:28,760
enhancements in protocol ability

00:07:27,139 --> 00:07:31,100
improvements like log three algorithms

00:07:28,760 --> 00:07:35,419
in table cache so that it shouldn't be a

00:07:31,100 --> 00:07:41,680
bottleneck and many other features but

00:07:35,419 --> 00:07:44,150
let's rather talk about Gento so

00:07:41,680 --> 00:07:48,260
different features intend to can be

00:07:44,150 --> 00:07:50,419
roughly grouped in different groups like

00:07:48,260 --> 00:07:52,370
advanced something but that I call

00:07:50,419 --> 00:07:54,650
advanced data query that's a more

00:07:52,370 --> 00:07:56,660
complex way of where in your data doing

00:07:54,650 --> 00:07:59,680
queries that we are not possible with

00:07:56,660 --> 00:08:03,260
Maree DB before and there's another

00:07:59,680 --> 00:08:05,510
initiative of removing historic or

00:08:03,260 --> 00:08:07,789
limitations something that my square

00:08:05,510 --> 00:08:10,639
meri DB and its predecessor MySQL had

00:08:07,789 --> 00:08:11,300
for like forever well at least for

00:08:10,639 --> 00:08:13,539
eighteen years

00:08:11,300 --> 00:08:16,250
that's as much as I remember and

00:08:13,539 --> 00:08:18,590
different optimizations to make maybe

00:08:16,250 --> 00:08:21,530
work faster and other features that

00:08:18,590 --> 00:08:23,810
don't fit in any particular group and I

00:08:21,530 --> 00:08:25,490
also briefly talk about currently

00:08:23,810 --> 00:08:27,470
running google Summer of Code and my adb

00:08:25,490 --> 00:08:30,860
yeah in google Summer of Code for like

00:08:27,470 --> 00:08:33,440
four years maybe and this one is loops

00:08:30,860 --> 00:08:35,479
very successful so it hasn't finished

00:08:33,440 --> 00:08:37,310
yet but it looks like we'll have we'll

00:08:35,479 --> 00:08:41,539
have good many good features coming from

00:08:37,310 --> 00:08:44,810
it so I'll mention them talk so about

00:08:41,539 --> 00:08:47,180
first one feature about data query let's

00:08:44,810 --> 00:08:51,140
what SQL standard called common table

00:08:47,180 --> 00:08:52,700
expressions and this is one simple query

00:08:51,140 --> 00:08:55,070
that uses a derived table

00:08:52,700 --> 00:08:57,530
or SQL standard calls it sub-query in

00:08:55,070 --> 00:08:59,360
the from clause and using common table

00:08:57,530 --> 00:09:02,000
expression syntax this is with keyboard

00:08:59,360 --> 00:09:03,650
it can be rewritten this way which is

00:09:02,000 --> 00:09:04,970
pretty practically identical it's not

00:09:03,650 --> 00:09:07,190
interesting at all just different way of

00:09:04,970 --> 00:09:10,280
writing the same thing when it becomes

00:09:07,190 --> 00:09:12,950
interesting when we support recursive

00:09:10,280 --> 00:09:16,580
common table expressions and here you

00:09:12,950 --> 00:09:20,360
see the ancestor common table expression

00:09:16,580 --> 00:09:22,820
is defined using itself because select

00:09:20,360 --> 00:09:26,450
from itself well it used to define

00:09:22,820 --> 00:09:28,970
itself using itself and that basically

00:09:26,450 --> 00:09:34,060
works like first it selects on the folks

00:09:28,970 --> 00:09:39,140
table by a name for me and then it

00:09:34,060 --> 00:09:42,350
selects from folks and itself for well

00:09:39,140 --> 00:09:47,450
ancestors parents and then again and

00:09:42,350 --> 00:09:48,950
again so this can select all this can

00:09:47,450 --> 00:09:51,050
select all the ancestors graph all

00:09:48,950 --> 00:09:53,120
parents all fathers and mothers and

00:09:51,050 --> 00:09:55,630
fathers and month until the table ends

00:09:53,120 --> 00:09:58,430
as if it's a spell standard way of

00:09:55,630 --> 00:10:01,430
querying graphs and recursive data

00:09:58,430 --> 00:10:04,940
structures employees bosses fathers

00:10:01,430 --> 00:10:07,250
mothers kids and any graphs relations

00:10:04,940 --> 00:10:09,560
graph whatever this is how a school

00:10:07,250 --> 00:10:11,240
standard wants us to do that and we now

00:10:09,560 --> 00:10:13,430
support it and publish scale supported

00:10:11,240 --> 00:10:17,240
and Oracle supported well and we now

00:10:13,430 --> 00:10:19,660
suppose that term there was not not

00:10:17,240 --> 00:10:25,280
possible with Maree DB before and

00:10:19,660 --> 00:10:28,640
another feature in this area of doing

00:10:25,280 --> 00:10:32,840
more complex queries so it should have

00:10:28,640 --> 00:10:34,910
brought some border so let's so I

00:10:32,840 --> 00:10:37,910
I'll be using stage table on this slide

00:10:34,910 --> 00:10:39,350
and to explain it let's imagine a

00:10:37,910 --> 00:10:41,600
complex process that consists of

00:10:39,350 --> 00:10:43,520
different stages and some and every

00:10:41,600 --> 00:10:46,280
stage takes some time for example I

00:10:43,520 --> 00:10:48,380
don't know user clicks on a link in his

00:10:46,280 --> 00:10:51,550
browser so the browser processes the

00:10:48,380 --> 00:10:53,570
click and send some HTTP request to the

00:10:51,550 --> 00:10:56,600
Apache and Apache

00:10:53,570 --> 00:10:58,160
fires people and loads a PHP page that

00:10:56,600 --> 00:11:00,110
does something as M connects with the

00:10:58,160 --> 00:11:02,030
database and database that it some data

00:11:00,110 --> 00:11:04,070
from the g-scan does something and send

00:11:02,030 --> 00:11:06,110
the data back to PHP in PHP sends it

00:11:04,070 --> 00:11:09,200
back to the client and the

00:11:06,110 --> 00:11:11,660
to the browser and browser displays

00:11:09,200 --> 00:11:13,519
another page and then the user finally

00:11:11,660 --> 00:11:15,350
gets what he actually wanted there are

00:11:13,519 --> 00:11:19,310
many stages every stage takes some time

00:11:15,350 --> 00:11:23,180
and what if we want to see all the

00:11:19,310 --> 00:11:26,500
stages when every stage has started how

00:11:23,180 --> 00:11:31,760
long the stage was and this is the

00:11:26,500 --> 00:11:33,230
rolling total of how much time passed in

00:11:31,760 --> 00:11:36,380
the very beginning till the current

00:11:33,230 --> 00:11:40,370
stage this is the joint that shows that

00:11:36,380 --> 00:11:42,920
and using window functions which is also

00:11:40,370 --> 00:11:46,399
part of SQL standard one can show the

00:11:42,920 --> 00:11:49,640
role in total this way so select name

00:11:46,399 --> 00:11:51,470
start time and duration and sum over the

00:11:49,640 --> 00:11:53,839
window that starts from the beginning

00:11:51,470 --> 00:11:55,459
and ends at the start time which is

00:11:53,839 --> 00:11:56,959
again not exactly interesting because

00:11:55,459 --> 00:11:59,420
you can do the same with the join or sub

00:11:56,959 --> 00:12:01,870
query but this one you cannot can no

00:11:59,420 --> 00:12:06,920
longer do with the sub query or a join

00:12:01,870 --> 00:12:09,860
this one displays for every stage it

00:12:06,920 --> 00:12:12,230
displays that role in average that

00:12:09,860 --> 00:12:14,810
includes zero two rows before in two

00:12:12,230 --> 00:12:16,670
rows after so that's current row every

00:12:14,810 --> 00:12:19,339
row it considers a window of five rows

00:12:16,670 --> 00:12:22,250
and averages over them this is something

00:12:19,339 --> 00:12:24,199
you can do with window functions Oh

00:12:22,250 --> 00:12:26,390
for example the user complaints that

00:12:24,199 --> 00:12:27,769
this mouse click and show in the page

00:12:26,390 --> 00:12:30,500
takes too long and you want to optimize

00:12:27,769 --> 00:12:31,850
the whole process the logical you need

00:12:30,500 --> 00:12:36,410
to start optimizing from the most

00:12:31,850 --> 00:12:40,010
time-consuming stages and this one with

00:12:36,410 --> 00:12:44,029
the until function it splits all the

00:12:40,010 --> 00:12:47,680
stages into buckets and if so if you

00:12:44,029 --> 00:12:50,930
look at the tenth until 10th quantal

00:12:47,680 --> 00:12:53,329
it'll be all the queries that all the

00:12:50,930 --> 00:12:55,730
stages that takes longer than 90% of all

00:12:53,329 --> 00:12:58,430
other stages so there are be more most

00:12:55,730 --> 00:13:00,320
expensive stages will be and they turns

00:12:58,430 --> 00:13:02,959
quintile and then you will know what

00:13:00,320 --> 00:13:03,560
they just start optimizing from this is

00:13:02,959 --> 00:13:05,740
splits

00:13:03,560 --> 00:13:11,750
this is calculates until function

00:13:05,740 --> 00:13:15,210
calculates coin tails about

00:13:11,750 --> 00:13:17,240
removing limitations any questions so

00:13:15,210 --> 00:13:17,240
far

00:13:17,840 --> 00:13:28,380
okay this this is something that my

00:13:22,800 --> 00:13:30,270
school has like forever and why it might

00:13:28,380 --> 00:13:32,550
look like an arbitrary limitation it was

00:13:30,270 --> 00:13:35,040
rooted deep into the how things worked

00:13:32,550 --> 00:13:38,730
in and were designed internally you can

00:13:35,040 --> 00:13:42,150
do a self join like on like on this

00:13:38,730 --> 00:13:43,530
slide with four normal tables but not

00:13:42,150 --> 00:13:45,750
for temporary tables because you cannot

00:13:43,530 --> 00:13:48,450
use the same temper table twice in the

00:13:45,750 --> 00:13:51,510
same query not with sub queries not with

00:13:48,450 --> 00:13:53,130
self joints nowhere and it's kind of

00:13:51,510 --> 00:13:56,520
silly but that's how to use the book and

00:13:53,130 --> 00:13:58,650
we have fixed now so starting from ten

00:13:56,520 --> 00:14:00,660
to this limitation is removed and you

00:13:58,650 --> 00:14:06,660
can use temper table just as any other

00:14:00,660 --> 00:14:11,540
normal table this extension allows to

00:14:06,660 --> 00:14:15,030
use expressions in the default clause

00:14:11,540 --> 00:14:17,970
until now there was only default can be

00:14:15,030 --> 00:14:20,430
either a constant or current time or now

00:14:17,970 --> 00:14:24,560
for timestamps and now that it could be

00:14:20,430 --> 00:14:30,600
any arbitrary function for any column oh

00:14:24,560 --> 00:14:34,200
thank you very much it could be any

00:14:30,600 --> 00:14:36,180
arbitrary function for any column this

00:14:34,200 --> 00:14:38,700
feature is also supported by Oracle and

00:14:36,180 --> 00:14:40,680
Postgres and db2 and so on but this

00:14:38,700 --> 00:14:42,120
extension is not actually Google and

00:14:40,680 --> 00:14:44,220
couldn't find any other database that

00:14:42,120 --> 00:14:46,260
that can do that so you can also use

00:14:44,220 --> 00:14:48,480
default in defaults you can refer to any

00:14:46,260 --> 00:14:53,010
other columns so if you insert like

00:14:48,480 --> 00:14:56,010
three into column a the default would be

00:14:53,010 --> 00:14:58,740
in the same row we'll before so you can

00:14:56,010 --> 00:15:05,640
use any expressions in defaults almost

00:14:58,740 --> 00:15:08,160
any and as a nice side effect of this

00:15:05,640 --> 00:15:11,370
you can also have default for blobs this

00:15:08,160 --> 00:15:14,940
is all part of them too and check

00:15:11,370 --> 00:15:18,420
constraints so my squirrel used to

00:15:14,940 --> 00:15:21,270
support the support base for again

00:15:18,420 --> 00:15:22,920
forever it always was you can always

00:15:21,270 --> 00:15:24,630
create a table you specified check

00:15:22,920 --> 00:15:25,110
constraint and the parser was happy to

00:15:24,630 --> 00:15:26,610
parcel

00:15:25,110 --> 00:15:28,680
and then the show would throw it away

00:15:26,610 --> 00:15:32,070
and not even store it and of course not

00:15:28,680 --> 00:15:34,290
enforcer and so it wasn't really support

00:15:32,070 --> 00:15:36,660
but the syntax was supported and now we

00:15:34,290 --> 00:15:38,580
have well fixed this properly

00:15:36,660 --> 00:15:41,040
it's not checking strained apart they

00:15:38,580 --> 00:15:43,140
are recognized the store and they are

00:15:41,040 --> 00:15:45,060
enforced so this table if I would create

00:15:43,140 --> 00:15:47,700
it I would not be able to insert

00:15:45,060 --> 00:15:50,040
anything in the table where a is not

00:15:47,700 --> 00:15:54,990
greater than B this is also Pauline

00:15:50,040 --> 00:16:00,079
gentle virtual columns may need to be

00:15:54,990 --> 00:16:00,079
supported virtual column since sorry

00:16:00,920 --> 00:16:08,279
since the since version 5.2 but they

00:16:05,610 --> 00:16:10,950
were they were subject to many

00:16:08,279 --> 00:16:14,459
limitations some of them are removed now

00:16:10,950 --> 00:16:16,560
in turn to for example now virtual

00:16:14,459 --> 00:16:18,420
columns can refer to other virtual

00:16:16,560 --> 00:16:21,329
columns like column C refers to column B

00:16:18,420 --> 00:16:24,980
which was not allowed before they can be

00:16:21,329 --> 00:16:28,740
indexes which also didn't work until now

00:16:24,980 --> 00:16:30,570
also I didn't have example for that but

00:16:28,740 --> 00:16:32,790
the maximum expression length was

00:16:30,570 --> 00:16:34,440
increased number for the set of

00:16:32,790 --> 00:16:36,360
functions that can be used in virtual

00:16:34,440 --> 00:16:38,279
columns is increased so you don't

00:16:36,360 --> 00:16:40,560
necessarily have to use deterministic

00:16:38,279 --> 00:16:42,300
functions for original columns so there

00:16:40,560 --> 00:16:45,510
are many limitations removed

00:16:42,300 --> 00:16:48,420
I have only mentioned a few the lights

00:16:45,510 --> 00:16:50,279
of decimal type decimal numbers they got

00:16:48,420 --> 00:16:55,020
larger precision now they can store up

00:16:50,279 --> 00:16:57,810
to 38 digits after the decimal coma and

00:16:55,020 --> 00:17:00,630
this feature was actually for reason I

00:16:57,810 --> 00:17:03,660
don't quite understand the most highly

00:17:00,630 --> 00:17:05,900
voted feature in our future tracker but

00:17:03,660 --> 00:17:08,939
well now it's possible you can use

00:17:05,900 --> 00:17:12,240
sub-queries in the from clause inside

00:17:08,939 --> 00:17:14,100
views which was what which was

00:17:12,240 --> 00:17:15,809
prohibited before this kaveri wolf

00:17:14,100 --> 00:17:18,600
create table would have failed great

00:17:15,809 --> 00:17:24,540
view and jan 1 and now in turn 2 it

00:17:18,600 --> 00:17:25,500
works so we also worked on different

00:17:24,540 --> 00:17:27,720
optimizations

00:17:25,500 --> 00:17:35,700
making many be faster or different

00:17:27,720 --> 00:17:37,940
levels the faster the best benefits be

00:17:35,700 --> 00:17:40,820
speed-up like for spent development

00:17:37,940 --> 00:17:43,460
or whatever you get of course from my

00:17:40,820 --> 00:17:46,399
define other ISM significantly so they

00:17:43,460 --> 00:17:50,419
were changes in order by for example in

00:17:46,399 --> 00:17:53,480
this is in this example let's assume

00:17:50,419 --> 00:17:55,700
that t1 ID that look like a primary key

00:17:53,480 --> 00:17:59,840
so let's say it's a primary key and this

00:17:55,700 --> 00:18:01,490
one let's say it's not index at all so

00:17:59,840 --> 00:18:04,850
in turn one optimizer would have tried

00:18:01,490 --> 00:18:06,559
to order by by this not index column and

00:18:04,850 --> 00:18:08,690
that would require file sort so another

00:18:06,559 --> 00:18:11,360
sorting path which could be very slow

00:18:08,690 --> 00:18:13,309
and then tend to optimizer would notice

00:18:11,360 --> 00:18:15,379
that there is to come to well is

00:18:13,309 --> 00:18:18,409
actually identical and it could simply

00:18:15,379 --> 00:18:20,000
order by by the primary key of G 1 and

00:18:18,409 --> 00:18:23,450
then it doesn't need to file so they can

00:18:20,000 --> 00:18:27,830
just use the existing index which could

00:18:23,450 --> 00:18:31,279
be much much faster also I was saying

00:18:27,830 --> 00:18:36,500
that in 10:1 we've made a log free table

00:18:31,279 --> 00:18:38,389
cache this was apparently not enough so

00:18:36,500 --> 00:18:41,090
now we intend to be additional to that

00:18:38,389 --> 00:18:46,279
we want to partition it to make it well

00:18:41,090 --> 00:18:49,039
even more concurrent first to connect

00:18:46,279 --> 00:18:51,139
times there was some work done on make

00:18:49,039 --> 00:18:52,850
connection time faster but whether you

00:18:51,139 --> 00:18:56,570
will be affected that depends on your

00:18:52,850 --> 00:18:59,690
application so if you actually see the

00:18:56,570 --> 00:19:02,360
connection time which means you do like

00:18:59,690 --> 00:19:04,399
connect run some simple query disconnect

00:19:02,360 --> 00:19:06,049
and then repeat again then part of the

00:19:04,399 --> 00:19:09,200
whole process connection tie will be

00:19:06,049 --> 00:19:10,519
noticeable and you can see up to two

00:19:09,200 --> 00:19:12,860
times speed-up that's what we saw in our

00:19:10,519 --> 00:19:14,779
benchmarks if you connect once and then

00:19:12,860 --> 00:19:16,940
run many long queries then disconnect

00:19:14,779 --> 00:19:19,159
and connection time is very small anyway

00:19:16,940 --> 00:19:21,379
so you will probably won't notice

00:19:19,159 --> 00:19:24,409
anything at all it won't it won't be

00:19:21,379 --> 00:19:26,360
slower but it will not be fast either we

00:19:24,409 --> 00:19:28,669
have added some budget some more

00:19:26,360 --> 00:19:31,960
batching into the protocol so one can

00:19:28,669 --> 00:19:34,009
batch many protocol commands into one

00:19:31,960 --> 00:19:36,559
without and the server will batch

00:19:34,009 --> 00:19:38,750
replies as well reducing number of

00:19:36,559 --> 00:19:41,659
number of round trips it can be done for

00:19:38,750 --> 00:19:44,450
me for any command but more practical

00:19:41,659 --> 00:19:46,759
examples is to do prepare and execute in

00:19:44,450 --> 00:19:48,679
one big packet instead of sending

00:19:46,759 --> 00:19:50,480
prepare okay execute okay so it will

00:19:48,679 --> 00:19:53,330
reduce to one arm trip

00:19:50,480 --> 00:19:56,300
and also many application connect to the

00:19:53,330 --> 00:19:58,100
database in most cases the username is

00:19:56,300 --> 00:20:00,830
patent are correct in most cases you

00:19:58,100 --> 00:20:01,970
don't get a incorrect password because

00:20:00,830 --> 00:20:04,940
everything's had caught it anyway

00:20:01,970 --> 00:20:06,980
somewhere in your application so it

00:20:04,940 --> 00:20:09,050
makes sense not to wait for sure

00:20:06,980 --> 00:20:10,880
acknowledging the password but just send

00:20:09,050 --> 00:20:12,620
username the password and the first

00:20:10,880 --> 00:20:14,110
statement if you want to do in the first

00:20:12,620 --> 00:20:16,940
packet and the server will either

00:20:14,110 --> 00:20:19,430
execute it and send the reply right away

00:20:16,940 --> 00:20:22,220
or it'll say incorrect password whatever

00:20:19,430 --> 00:20:24,230
but it's also says one round-trip and I

00:20:22,220 --> 00:20:26,780
don't have any scientifically good

00:20:24,230 --> 00:20:28,940
benchmarks for that we done only some

00:20:26,780 --> 00:20:30,320
simple months in benchmarks and it'll

00:20:28,940 --> 00:20:32,990
have better results will blog about it

00:20:30,320 --> 00:20:37,010
but we did see some huge speed up

00:20:32,990 --> 00:20:39,320
because of that as well there are many

00:20:37,010 --> 00:20:42,530
other statement any other extensions

00:20:39,320 --> 00:20:44,360
that either done or we are currently

00:20:42,530 --> 00:20:48,560
working on and they're ready to be

00:20:44,360 --> 00:20:51,440
pushed so JSON functions datatype

00:20:48,560 --> 00:20:53,240
plugins that allow to well write plugin

00:20:51,440 --> 00:20:56,360
for data types and the first three will

00:20:53,240 --> 00:21:00,920
be your ID data type ipv6 ipv4 data type

00:20:56,360 --> 00:21:02,540
and json data type and this is a simple

00:21:00,920 --> 00:21:06,470
feature they do surprisingly what

00:21:02,540 --> 00:21:09,080
requested many times and well you can

00:21:06,470 --> 00:21:10,940
specify tell Authority returned any

00:21:09,080 --> 00:21:14,120
versions thing you want and why is it

00:21:10,940 --> 00:21:16,160
needed because there are quite a few

00:21:14,120 --> 00:21:20,750
applications it turns out that do not

00:21:16,160 --> 00:21:22,910
support Mary DB and the vendor does not

00:21:20,750 --> 00:21:26,000
want to support MariaDB security

00:21:22,910 --> 00:21:28,970
scanners that complain that the version

00:21:26,000 --> 00:21:31,820
of Murray DB if you compare compare five

00:21:28,970 --> 00:21:34,190
six and ten turn to as the strings than

00:21:31,820 --> 00:21:35,990
ten to in be less than five six so

00:21:34,190 --> 00:21:37,970
because one is less than five so they'll

00:21:35,990 --> 00:21:40,270
complain that it's too old version that

00:21:37,970 --> 00:21:44,510
has too many security vulnerabilities or

00:21:40,270 --> 00:21:47,780
for example my squirrel workbench I

00:21:44,510 --> 00:21:49,700
believe it will check the version to see

00:21:47,780 --> 00:21:51,440
what features you support and if it's

00:21:49,700 --> 00:21:53,540
less than five six it says that you

00:21:51,440 --> 00:21:55,310
don't have this and this performance

00:21:53,540 --> 00:21:57,860
schema tables and that won't allow you

00:21:55,310 --> 00:22:00,910
to run this date to run these queries

00:21:57,860 --> 00:22:03,680
and won't show you these pages so again

00:22:00,910 --> 00:22:04,679
the in the ideal world the users would

00:22:03,680 --> 00:22:06,539
complain to venden

00:22:04,679 --> 00:22:10,379
we'll fix that and we actually tried

00:22:06,539 --> 00:22:12,809
that it didn't work so we finally had to

00:22:10,379 --> 00:22:15,450
implement this workaround so that our

00:22:12,809 --> 00:22:21,899
users those who wanted could hack around

00:22:15,450 --> 00:22:24,659
the unsupportive vendors and now what we

00:22:21,899 --> 00:22:28,379
have in the google Summer of Code we

00:22:24,659 --> 00:22:30,600
have actually had 10 students not all of

00:22:28,379 --> 00:22:32,869
them for the server but those who were

00:22:30,600 --> 00:22:36,090
for the show is actually pretty good and

00:22:32,869 --> 00:22:39,029
we will have I would estimate that out

00:22:36,090 --> 00:22:40,580
of five bullet points in here we will

00:22:39,029 --> 00:22:45,990
have at least four features pushed

00:22:40,580 --> 00:22:50,279
that's what I predict when those

00:22:45,990 --> 00:22:54,299
features are no paid collation mean so

00:22:50,279 --> 00:22:56,100
SQL standard supports or dictates two

00:22:54,299 --> 00:22:57,720
different types of collations two

00:22:56,100 --> 00:22:59,879
different ways of comparing strings

00:22:57,720 --> 00:23:01,289
there are pad pad space collations which

00:22:59,879 --> 00:23:03,600
means if you compare two strings of

00:23:01,289 --> 00:23:05,580
different lengths the shorter one will

00:23:03,600 --> 00:23:07,529
be played with spaces to the length of

00:23:05,580 --> 00:23:09,690
the longer one and this is how MIDI be

00:23:07,529 --> 00:23:13,110
currently works every now and then users

00:23:09,690 --> 00:23:14,369
ask us to support no pad collations wear

00:23:13,110 --> 00:23:16,860
the shorter student is not paid for

00:23:14,369 --> 00:23:19,440
spaces and this is part of the google

00:23:16,860 --> 00:23:23,519
Summer of Code and so fight looks good

00:23:19,440 --> 00:23:25,049
so we will probably have it in and yeah

00:23:23,519 --> 00:23:27,059
we have create a create function where

00:23:25,049 --> 00:23:29,549
one can create a function SQL and then

00:23:27,059 --> 00:23:32,129
call it from select and other queries

00:23:29,549 --> 00:23:34,080
just like any normal function and that's

00:23:32,129 --> 00:23:36,539
another google Summer of Code project to

00:23:34,080 --> 00:23:38,129
create to implement create aggregate

00:23:36,539 --> 00:23:39,600
function statement so that one could

00:23:38,129 --> 00:23:40,289
create aggregate functions in a scale

00:23:39,600 --> 00:23:42,539
just as well

00:23:40,289 --> 00:23:44,100
this is non-standard doesn't support

00:23:42,539 --> 00:23:45,690
every database that it does it

00:23:44,100 --> 00:23:48,749
differently so there's no standards

00:23:45,690 --> 00:23:52,499
about that I betrayed a long dealing

00:23:48,749 --> 00:23:55,100
constraints Mario DB has I think pretty

00:23:52,499 --> 00:23:58,080
much every database has a limit on the

00:23:55,100 --> 00:23:59,610
maximal key length length of the index

00:23:58,080 --> 00:24:02,159
which makes the perfect sense because

00:23:59,610 --> 00:24:04,860
the index is just a help for the

00:24:02,159 --> 00:24:08,490
optimizer to execute the query faster

00:24:04,860 --> 00:24:10,710
and key is needed to be able to

00:24:08,490 --> 00:24:11,549
distinguish between rows and starting

00:24:10,710 --> 00:24:16,049
from the certain length

00:24:11,549 --> 00:24:17,620
keys stop being loose is discriminative

00:24:16,049 --> 00:24:19,270
power and short keys is as

00:24:17,620 --> 00:24:22,600
for distinguishing between rows as the

00:24:19,270 --> 00:24:25,299
long one but it takes more space on disk

00:24:22,600 --> 00:24:28,659
and it's a lot takes more time to read

00:24:25,299 --> 00:24:31,750
so for optimizing the aquarius there's

00:24:28,659 --> 00:24:33,970
certain key lengths in which it makes no

00:24:31,750 --> 00:24:35,679
sense to have longer keys that's why we

00:24:33,970 --> 00:24:38,440
don't support that on the other hand

00:24:35,679 --> 00:24:40,419
unique constraints they're not just help

00:24:38,440 --> 00:24:41,980
to the optimizer they are actual

00:24:40,419 --> 00:24:43,900
constraints logical constraints on the

00:24:41,980 --> 00:24:46,029
data and for those logical constraints

00:24:43,900 --> 00:24:49,090
and may make can make perfect sense to

00:24:46,029 --> 00:24:52,870
have very long constraints for example I

00:24:49,090 --> 00:24:54,940
don't know if you upload your file

00:24:52,870 --> 00:24:57,010
gigabyte movie on Dropbox five times

00:24:54,940 --> 00:24:59,590
it'll do the duplication it'll store

00:24:57,010 --> 00:25:02,850
this file once and other three will be

00:24:59,590 --> 00:25:05,590
remembered like it's the same file so

00:25:02,850 --> 00:25:07,690
sometimes it makes sense to do to have

00:25:05,590 --> 00:25:11,140
unique constraints of a very large data

00:25:07,690 --> 00:25:12,549
and we will imply but because unique

00:25:11,140 --> 00:25:14,830
constraints was implemented just as a

00:25:12,549 --> 00:25:16,299
regular key in MIDI be it wasn't

00:25:14,830 --> 00:25:20,020
possible and now we are removing this

00:25:16,299 --> 00:25:21,730
limitation and in turn 2 it looks like

00:25:20,020 --> 00:25:24,970
we all have unique constraints which

00:25:21,730 --> 00:25:26,919
could be of arbitrary length invisible

00:25:24,970 --> 00:25:29,049
columns is something that is very

00:25:26,919 --> 00:25:30,940
similar to what Oracle has you can mark

00:25:29,049 --> 00:25:32,860
any column in the data in the table it's

00:25:30,940 --> 00:25:35,409
invisible and then if you do select star

00:25:32,860 --> 00:25:36,850
it won't be there if you do insert

00:25:35,409 --> 00:25:39,340
without column names

00:25:36,850 --> 00:25:41,610
you won't insert into it but if you

00:25:39,340 --> 00:25:44,500
mention it by name then you will see and

00:25:41,610 --> 00:25:45,640
why it is needed if you have an old

00:25:44,500 --> 00:25:47,980
application that you cannot really

00:25:45,640 --> 00:25:49,950
change but you want to extend the table

00:25:47,980 --> 00:25:53,110
for some I don't know put a timestamp to

00:25:49,950 --> 00:25:55,539
keep track of time on those or extended

00:25:53,110 --> 00:25:57,010
slump somewhat then you can add an

00:25:55,539 --> 00:25:58,929
invisible column this application will

00:25:57,010 --> 00:26:01,270
not see it but your specific queries

00:25:58,929 --> 00:26:03,940
will see it and that's another type of

00:26:01,270 --> 00:26:05,620
invisible columns if those that you do

00:26:03,940 --> 00:26:07,779
not create explicitly for example like

00:26:05,620 --> 00:26:09,610
row ID it's kind of a column on the

00:26:07,779 --> 00:26:11,409
table but you don't see it if you look

00:26:09,610 --> 00:26:13,570
at the table structure you don't see it

00:26:11,409 --> 00:26:15,039
if you do select star but if you mention

00:26:13,570 --> 00:26:17,080
it by name you will see it that's

00:26:15,039 --> 00:26:21,399
another kind of invisible columns so

00:26:17,080 --> 00:26:23,620
we'll have both and the last feature

00:26:21,399 --> 00:26:25,780
which is google Summer of Code but it's

00:26:23,620 --> 00:26:28,750
practically done so it's well as good is

00:26:25,780 --> 00:26:30,610
already in it needs a bit more

00:26:28,750 --> 00:26:35,529
explanation

00:26:30,610 --> 00:26:37,539
so this is a derived table

00:26:35,529 --> 00:26:41,200
it's a general table at sub-query in the

00:26:37,539 --> 00:26:44,559
from clause and normal there are two

00:26:41,200 --> 00:26:45,820
ways of executing it for for the views

00:26:44,559 --> 00:26:47,740
and for the rough tables at the same

00:26:45,820 --> 00:26:51,100
logic it can be merged into the main

00:26:47,740 --> 00:26:52,990
query and then it'll basically disappear

00:26:51,100 --> 00:26:54,700
is a individual query it'll be part of

00:26:52,990 --> 00:26:56,409
the main credit or it can be executed

00:26:54,700 --> 00:26:58,630
separately result is stored in a

00:26:56,409 --> 00:27:03,730
temporary table and then the Stemper

00:26:58,630 --> 00:27:05,980
table is substituted in here and this

00:27:03,730 --> 00:27:07,809
particular example it has a group by so

00:27:05,980 --> 00:27:10,750
it cannot be merged so it will always be

00:27:07,809 --> 00:27:16,570
executed in a temporary table but if you

00:27:10,750 --> 00:27:18,820
look at the where condition this where

00:27:16,570 --> 00:27:21,610
condition can be actually moved inside

00:27:18,820 --> 00:27:23,649
the parenthesis and executed together

00:27:21,610 --> 00:27:25,929
with a in the query and stored in the

00:27:23,649 --> 00:27:31,120
temporary table as well and in

00:27:25,929 --> 00:27:34,210
particular this condition seems to be

00:27:31,120 --> 00:27:35,740
very limiting so it will if it'll be

00:27:34,210 --> 00:27:37,269
executed as a part of the inner query

00:27:35,740 --> 00:27:39,789
the inner query will be much much faster

00:27:37,269 --> 00:27:42,070
you know tectal much much less time on D

00:27:39,789 --> 00:27:44,289
to execute and much much less space and

00:27:42,070 --> 00:27:46,620
this it will be have a lot less rows

00:27:44,289 --> 00:27:49,570
then if you do that without a condition

00:27:46,620 --> 00:27:52,269
now this task is about moving these

00:27:49,570 --> 00:27:54,309
conditions inside the non-measurable

00:27:52,269 --> 00:27:56,649
views on and non-measurable direct

00:27:54,309 --> 00:27:58,870
tables it it's expected to provide a

00:27:56,649 --> 00:28:00,940
great benefits for the cases when the

00:27:58,870 --> 00:28:02,710
query cannot be merged submergent is

00:28:00,940 --> 00:28:04,600
ideal but if it's cannot be much is

00:28:02,710 --> 00:28:09,700
basically the second best thing we can

00:28:04,600 --> 00:28:11,470
do to optimize those kind of queries but

00:28:09,700 --> 00:28:12,669
yeah so that was about google Summer of

00:28:11,470 --> 00:28:14,409
Code but you don't need to wait for

00:28:12,669 --> 00:28:18,730
google Summer of Code you don't need to

00:28:14,409 --> 00:28:22,419
by the way you can contribute anytime

00:28:18,730 --> 00:28:24,730
and you can you can contribute with the

00:28:22,419 --> 00:28:30,309
code so we are on github github slash

00:28:24,730 --> 00:28:33,549
married slash server slash server you

00:28:30,309 --> 00:28:35,950
can fork it and hack away and submit

00:28:33,549 --> 00:28:39,159
pull requests we have a knowledge base

00:28:35,950 --> 00:28:41,080
which is we can like and you can edit

00:28:39,159 --> 00:28:43,620
knowledge base you can contribute pages

00:28:41,080 --> 00:28:48,280
there you can correct mistakes there

00:28:43,620 --> 00:28:50,350
you can report bugs at 0.90 build org or

00:28:48,280 --> 00:28:54,010
you can handgun or hang around on IRC

00:28:50,350 --> 00:28:57,880
and help people on MIDI

00:28:54,010 --> 00:29:03,190
marry a channel on freenode on MIDI

00:28:57,880 --> 00:29:05,170
discuss mailing list well the simplest

00:29:03,190 --> 00:29:07,150
way is the simplest way to help us that

00:29:05,170 --> 00:29:10,960
will only take half a minute is to put

00:29:07,150 --> 00:29:15,420
enable feedback into your - CNF this is

00:29:10,960 --> 00:29:17,680
similar to the Debian - popcorn in Devon

00:29:15,420 --> 00:29:21,010
it will enable feedback plugins that

00:29:17,680 --> 00:29:24,460
will once a week send us a minimized

00:29:21,010 --> 00:29:26,110
statistics about how use melody be what

00:29:24,460 --> 00:29:29,290
exactly it'll send it's in the knowledge

00:29:26,110 --> 00:29:30,760
base you can see and you can prove I can

00:29:29,290 --> 00:29:33,370
prove that it's anonymize that it

00:29:30,760 --> 00:29:36,400
doesn't send anything that we don't say

00:29:33,370 --> 00:29:39,790
it does and then it'll help us to make a

00:29:36,400 --> 00:29:41,860
more informed decision of what we need

00:29:39,790 --> 00:29:44,320
to work on what we need to optimize what

00:29:41,860 --> 00:29:46,810
credits are important and what we don't

00:29:44,320 --> 00:29:48,970
need to waste our time on what features

00:29:46,810 --> 00:29:54,300
are say nobody uses and can be removed

00:29:48,970 --> 00:29:57,300
only features cannot be removed yeah

00:29:54,300 --> 00:29:57,300
questions

00:30:05,630 --> 00:30:11,419
well I have a question now you mentioned

00:30:07,490 --> 00:30:14,390
about the explaining thing that the plan

00:30:11,419 --> 00:30:17,030
would be explained and now would analyze

00:30:14,390 --> 00:30:19,850
is it always the same plan but you get

00:30:17,030 --> 00:30:21,919
the additional if numbers or can it be a

00:30:19,850 --> 00:30:30,020
different plan either on the way can be

00:30:21,919 --> 00:30:32,510
so every time when in most cases when it

00:30:30,020 --> 00:30:34,429
should be the same in some cases when

00:30:32,510 --> 00:30:36,410
it's not the same we would consider it a

00:30:34,429 --> 00:30:40,370
balk and we would fix explain to show

00:30:36,410 --> 00:30:42,530
the same plan but sometimes and at some

00:30:40,370 --> 00:30:44,330
decision that I made on the way when the

00:30:42,530 --> 00:30:49,039
query is being executed and this is

00:30:44,330 --> 00:30:55,120
explained simply can you do other

00:30:49,039 --> 00:30:55,120
questions should check on IRC another

00:31:01,840 --> 00:31:08,250
okay so if there's no more questions

00:31:04,450 --> 00:31:08,250
then let's thank the speaker

00:31:12,780 --> 00:31:18,150
another database session in here after

00:31:15,820 --> 00:31:18,150

YouTube URL: https://www.youtube.com/watch?v=B07PfijgpaM


