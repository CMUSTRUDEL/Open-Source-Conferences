Title: What's new in the Linux kernel (and what's missing in Debian)
Publication date: 2020-10-23
Playlist: DebConf 20
Description: 
	by Ben Hutchings

At: DebConf20
https://debconf20.debconf.org/talks/19-whats-new-in-the-linux-kernel-and-whats-missing-in-debian/

The Linux kernel has a very active development community, constantly adding not only new hardware support but new features. Some of these features can simply be enabled by the configuration in the Debian package, but some also require support from other user-space packages. This talk will cover some of the more interesting changes made in the past year, and any work thatâ€™s still needed to support these in Debian.

Room: Talks
Scheduled start: 2020-08-25 11:00:00
Captions: 
	00:00:05,200 --> 00:00:09,599
welcome to

00:00:06,160 --> 00:00:12,960
my now annual talk about new features

00:00:09,599 --> 00:00:13,759
in the linux kernel and what works still

00:00:12,960 --> 00:00:16,400
has to be done

00:00:13,759 --> 00:00:18,880
to enable those or integrate those in

00:00:16,400 --> 00:00:18,880
debian

00:00:19,920 --> 00:00:24,640
i've been working on the linux kernel

00:00:22,640 --> 00:00:26,720
and various code around that

00:00:24,640 --> 00:00:28,160
both for debian and in my paid

00:00:26,720 --> 00:00:31,199
employment

00:00:28,160 --> 00:00:33,520
for something over 10 years now

00:00:31,199 --> 00:00:34,480
i'm a member of debian's kernel team and

00:00:33,520 --> 00:00:38,399
the lts

00:00:34,480 --> 00:00:41,840
team so i work both on kernel packaging

00:00:38,399 --> 00:00:46,239
and in backboarding fixes as necessary

00:00:41,840 --> 00:00:49,680
to our stable and older releases

00:00:46,239 --> 00:00:50,399
i used to maintain long-term stable

00:00:49,680 --> 00:00:54,160
branches

00:00:50,399 --> 00:00:54,879
at galen.org for the linux versions that

00:00:54,160 --> 00:00:58,879
were used

00:00:54,879 --> 00:01:01,920
in debian wheezy and jesse releases

00:00:58,879 --> 00:01:04,320
as you may know there are

00:01:01,920 --> 00:01:06,880
several linux releases every year in

00:01:04,320 --> 00:01:10,720
fact about five or six

00:01:06,880 --> 00:01:12,560
at uh intervals of nine or ten weeks

00:01:10,720 --> 00:01:14,159
and then every week or two there are

00:01:12,560 --> 00:01:19,439
stable updates

00:01:14,159 --> 00:01:21,200
that uh apply important perk fixes

00:01:19,439 --> 00:01:22,799
sometimes features are added in one

00:01:21,200 --> 00:01:23,680
kernel release but they're not really

00:01:22,799 --> 00:01:26,320
complete

00:01:23,680 --> 00:01:27,360
or usable and then they take several

00:01:26,320 --> 00:01:30,640
more releases

00:01:27,360 --> 00:01:34,320
to grow into

00:01:30,640 --> 00:01:35,600
features we can use and sometimes they

00:01:34,320 --> 00:01:36,479
need changes elsewhere in the

00:01:35,600 --> 00:01:39,920
distribution

00:01:36,479 --> 00:01:41,600
to be useful for example there might be

00:01:39,920 --> 00:01:42,320
a need for a user space tool to

00:01:41,600 --> 00:01:45,600
configure

00:01:42,320 --> 00:01:47,840
the feature uh it might need an update

00:01:45,600 --> 00:01:49,680
to an existing tool

00:01:47,840 --> 00:01:51,840
uh it may be something that needs to be

00:01:49,680 --> 00:01:53,200
used in various applications and

00:01:51,840 --> 00:01:55,840
libraries

00:01:53,200 --> 00:01:59,439
so those will need to be changed to take

00:01:55,840 --> 00:01:59,439
advantage of the new api

00:02:00,719 --> 00:02:03,600
and in some cases it will require

00:02:02,240 --> 00:02:06,840
changes to the way the kernel is

00:02:03,600 --> 00:02:08,479
packaged or even to distribution

00:02:06,840 --> 00:02:10,959
infrastructure

00:02:08,479 --> 00:02:12,239
i'm mostly going to be talking about new

00:02:10,959 --> 00:02:15,360
features that were added

00:02:12,239 --> 00:02:18,640
since last year so in

00:02:15,360 --> 00:02:21,840
linux releases 5.3 and

00:02:18,640 --> 00:02:24,000
up to 5.8

00:02:21,840 --> 00:02:26,800
hopefully will be in at least an

00:02:24,000 --> 00:02:30,239
experimental by the time this talk is

00:02:26,800 --> 00:02:30,239
uh as shown

00:02:31,440 --> 00:02:35,920
i'm gonna first going to recap what's

00:02:34,400 --> 00:02:39,200
happened with several features that i

00:02:35,920 --> 00:02:41,760
talked about in previous years

00:02:39,200 --> 00:02:44,959
that's a new cpu frequency governor

00:02:41,760 --> 00:02:44,959
called schedule

00:02:45,599 --> 00:02:49,519
which is properly integrated with a task

00:02:48,319 --> 00:02:53,280
scheduler and so

00:02:49,519 --> 00:02:57,040
should do a better job of setting

00:02:53,280 --> 00:03:00,239
uh cpu frequency than others

00:02:57,040 --> 00:03:01,760
that were available but that needs

00:03:00,239 --> 00:03:06,000
what's called

00:03:01,760 --> 00:03:08,239
frequency independent cpu load tracking

00:03:06,000 --> 00:03:09,280
that has been properly implemented for

00:03:08,239 --> 00:03:11,519
arm architectures

00:03:09,280 --> 00:03:15,120
and we've now made that the default for

00:03:11,519 --> 00:03:15,120
arm64 and mhf

00:03:16,080 --> 00:03:24,720
it's now usable for x86 since linux 5.7

00:03:20,959 --> 00:03:24,720
but we haven't made it the default yet

00:03:28,319 --> 00:03:35,760
the newest large uh

00:03:31,599 --> 00:03:37,440
very high capacity hard drives uh use

00:03:35,760 --> 00:03:40,959
what's called shingled magnetic

00:03:37,440 --> 00:03:44,319
recording which means that you can't

00:03:40,959 --> 00:03:46,480
uh you you can't write

00:03:44,319 --> 00:03:48,159
to them at random places like you could

00:03:46,480 --> 00:03:50,400
with all the hard drives

00:03:48,159 --> 00:03:51,599
at least not with a huge uh performance

00:03:50,400 --> 00:03:53,840
penalty

00:03:51,599 --> 00:03:54,799
so to take advantage of of those you

00:03:53,840 --> 00:03:58,560
might want to use

00:03:54,799 --> 00:04:01,840
dm zoned uh

00:03:58,560 --> 00:04:02,720
but the uh user space needed to

00:04:01,840 --> 00:04:05,439
configure that

00:04:02,720 --> 00:04:07,760
dm zones tools is still not in debian

00:04:05,439 --> 00:04:09,519
and still waiting for a sponsor

00:04:07,760 --> 00:04:12,000
so if you're interested in support for

00:04:09,519 --> 00:04:15,040
those very large hard drives

00:04:12,000 --> 00:04:17,440
uh please have a look at that

00:04:15,040 --> 00:04:18,400
the risk five open architecture that

00:04:17,440 --> 00:04:20,880
i've talked about

00:04:18,400 --> 00:04:21,919
in previous years uh support for that in

00:04:20,880 --> 00:04:25,680
the kernel has

00:04:21,919 --> 00:04:27,840
increased uh now includes support for

00:04:25,680 --> 00:04:28,800
uh huge pages in the memory management

00:04:27,840 --> 00:04:32,080
layer

00:04:28,800 --> 00:04:35,600
secure computing or set comp which is

00:04:32,080 --> 00:04:36,320
important for sandboxing and cpu hot

00:04:35,600 --> 00:04:41,040
plug

00:04:36,320 --> 00:04:44,560
and it can boot through efi there's a

00:04:41,040 --> 00:04:45,919
that should work with uh u-boats efi

00:04:44,560 --> 00:04:47,840
implementation

00:04:45,919 --> 00:04:50,160
however there's still limited support

00:04:47,840 --> 00:04:52,960
for different socs and boards i think

00:04:50,160 --> 00:04:57,120
only a couple of socs are supported by

00:04:52,960 --> 00:04:59,919
mainline linux

00:04:57,120 --> 00:05:00,880
the ongoing work to make those two

00:04:59,919 --> 00:05:05,120
architectures

00:05:00,880 --> 00:05:08,240
uh able to tell the time after 2038

00:05:05,120 --> 00:05:11,680
is pretty much done in the colonel

00:05:08,240 --> 00:05:15,120
uh and in the new c library

00:05:11,680 --> 00:05:18,880
um but that's that's a

00:05:15,120 --> 00:05:22,000
significant abi change uh

00:05:18,880 --> 00:05:23,520
and we'll need to uh

00:05:22,000 --> 00:05:26,960
if we want to keep any thursday with

00:05:23,520 --> 00:05:29,280
architectures running past 2038

00:05:26,960 --> 00:05:32,479
then we're going to need to do a

00:05:29,280 --> 00:05:33,840
complete rebuild those for the new api

00:05:32,479 --> 00:05:36,080
so deviant really needs to make a

00:05:33,840 --> 00:05:38,400
decision on whether it's going to do

00:05:36,080 --> 00:05:42,160
that and which

00:05:38,400 --> 00:05:45,759
architect just to support and

00:05:42,160 --> 00:05:45,759
how the migration is going to work

00:05:50,400 --> 00:05:54,720
so asynchronous i o is a useful

00:05:53,840 --> 00:05:59,199
mechanism

00:05:54,720 --> 00:06:03,520
for improving the performance of

00:05:59,199 --> 00:06:03,520
programs that do a lot of i o

00:06:03,759 --> 00:06:06,880
and also do a significant amount of

00:06:05,840 --> 00:06:09,840
computing

00:06:06,880 --> 00:06:10,800
ideally you want the uh i o and

00:06:09,840 --> 00:06:13,520
computing to run

00:06:10,800 --> 00:06:15,680
in parallel and that's the promise of

00:06:13,520 --> 00:06:19,840
asynchronous io

00:06:15,680 --> 00:06:22,720
linux has supported aio since

00:06:19,840 --> 00:06:23,360
2.5 development series but it's

00:06:22,720 --> 00:06:25,600
restricted

00:06:23,360 --> 00:06:27,360
to direct file layout so you can't use

00:06:25,600 --> 00:06:30,560
it with sockets

00:06:27,360 --> 00:06:31,520
and if you use it with files then you

00:06:30,560 --> 00:06:34,800
have to do

00:06:31,520 --> 00:06:38,080
a whole page whole pages at the time

00:06:34,800 --> 00:06:41,440
and that more or less bypasses

00:06:38,080 --> 00:06:44,639
page caching so it's only

00:06:41,440 --> 00:06:47,600
really useful and only used by database

00:06:44,639 --> 00:06:48,000
managers that manage their own cache and

00:06:47,600 --> 00:06:51,360
in fact

00:06:48,000 --> 00:06:53,039
i think very few of the free database

00:06:51,360 --> 00:06:55,759
managers

00:06:53,039 --> 00:06:57,680
uh do this but it's mostly oracle in

00:06:55,759 --> 00:07:02,880
fact

00:06:57,680 --> 00:07:04,479
it's the old linux ii api is not very

00:07:02,880 --> 00:07:06,639
efficient you actually need to carry out

00:07:04,479 --> 00:07:08,000
more system calls with the consequent

00:07:06,639 --> 00:07:10,000
overhead than if you were doing

00:07:08,000 --> 00:07:11,840
synchronous i o

00:07:10,000 --> 00:07:14,160
only a small set of file operations are

00:07:11,840 --> 00:07:15,039
supported and it's not even fully

00:07:14,160 --> 00:07:18,000
asynchronous

00:07:15,039 --> 00:07:18,720
sometimes the i o submit system call

00:07:18,000 --> 00:07:21,280
which

00:07:18,720 --> 00:07:22,720
uh starts off on appropriate starts an

00:07:21,280 --> 00:07:26,639
asynchronous operation

00:07:22,720 --> 00:07:28,560
will block there is a project standard

00:07:26,639 --> 00:07:29,599
for aio and that's implemented in the

00:07:28,560 --> 00:07:31,440
new c library

00:07:29,599 --> 00:07:32,720
because it doesn't really match what the

00:07:31,440 --> 00:07:36,080
kernel does

00:07:32,720 --> 00:07:37,919
uh it's sort of emulated um

00:07:36,080 --> 00:07:39,520
using a pool of threads that do

00:07:37,919 --> 00:07:42,000
signature system calls

00:07:39,520 --> 00:07:43,440
and because of all the context switching

00:07:42,000 --> 00:07:46,479
between threads it's not at all

00:07:43,440 --> 00:07:46,479
efficient or useful

00:07:47,360 --> 00:07:55,120
so the new feature introduced in 5.1

00:07:50,720 --> 00:07:56,560
is called io underscore u-ring

00:07:55,120 --> 00:07:58,639
this is something i could have actually

00:07:56,560 --> 00:07:59,919
covered last year but i didn't realize

00:07:58,639 --> 00:08:02,639
at the time

00:07:59,919 --> 00:08:04,160
how useful or important this was going

00:08:02,639 --> 00:08:07,360
to be

00:08:04,160 --> 00:08:08,000
it's been extended repeatedly in each

00:08:07,360 --> 00:08:12,000
new

00:08:08,000 --> 00:08:14,720
feature release so

00:08:12,000 --> 00:08:16,639
it supports direct finance but also

00:08:14,720 --> 00:08:17,759
buffered file io which takes advantage

00:08:16,639 --> 00:08:21,280
of the page cache

00:08:17,759 --> 00:08:24,400
and it can do socket i o it uses

00:08:21,280 --> 00:08:27,440
uh a submission ring in

00:08:24,400 --> 00:08:29,680
shared memory where so

00:08:27,440 --> 00:08:31,199
the memory is shared between the kernel

00:08:29,680 --> 00:08:34,320
and user space

00:08:31,199 --> 00:08:36,479
user space adds operations into there

00:08:34,320 --> 00:08:39,039
one by one

00:08:36,479 --> 00:08:40,479
but it can tell the kernel about them

00:08:39,039 --> 00:08:43,360
about multiple operations

00:08:40,479 --> 00:08:45,279
at once and similarly there's a

00:08:43,360 --> 00:08:47,200
completion ring shared between the

00:08:45,279 --> 00:08:50,560
user space and the kernel where the

00:08:47,200 --> 00:08:52,000
results of those operations will show up

00:08:50,560 --> 00:08:54,399
this is the same sort of pattern that's

00:08:52,000 --> 00:08:55,279
used for drivers to communicate with

00:08:54,399 --> 00:08:59,360
high performance

00:08:55,279 --> 00:09:04,560
i o devices like network interfaces

00:08:59,360 --> 00:09:04,560
storage usb host controllers and so on

00:09:04,959 --> 00:09:08,080
so that allows for cueing and dequeuing

00:09:07,279 --> 00:09:12,320
operations

00:09:08,080 --> 00:09:15,680
with many fewer system calls than if

00:09:12,320 --> 00:09:19,200
you're doing those synchronously

00:09:15,680 --> 00:09:22,240
applications can regis register file

00:09:19,200 --> 00:09:24,000
and files and buffers to be used by

00:09:22,240 --> 00:09:26,800
multiple operations

00:09:24,000 --> 00:09:27,839
they can also register buffer groups

00:09:26,800 --> 00:09:30,880
which will be

00:09:27,839 --> 00:09:32,640
used as needed by whichever operation

00:09:30,880 --> 00:09:35,120
needs them first

00:09:32,640 --> 00:09:36,720
so for example if you're running a

00:09:35,120 --> 00:09:40,320
network server

00:09:36,720 --> 00:09:41,279
that wants to receive on multiple

00:09:40,320 --> 00:09:43,279
sockets

00:09:41,279 --> 00:09:44,959
you can start a receive you can queue up

00:09:43,279 --> 00:09:45,680
a receive message on all of those

00:09:44,959 --> 00:09:47,360
sockets

00:09:45,680 --> 00:09:49,200
without needing to dedicate a buffer to

00:09:47,360 --> 00:09:53,440
each one of them

00:09:49,200 --> 00:09:58,160
and then those will complete as

00:09:53,440 --> 00:10:00,560
using buffers as necessary

00:09:58,160 --> 00:10:02,640
you can also submit a chain of dependent

00:10:00,560 --> 00:10:04,720
operations

00:10:02,640 --> 00:10:06,399
so for example uh if you want to write

00:10:04,720 --> 00:10:09,519
to a file you then want to

00:10:06,399 --> 00:10:11,200
sync the file with fsync and finally you

00:10:09,519 --> 00:10:14,959
might close the file

00:10:11,200 --> 00:10:16,240
and you can queue up all of those

00:10:14,959 --> 00:10:19,200
saying that they're dependent on the

00:10:16,240 --> 00:10:20,640
previous one and

00:10:19,200 --> 00:10:22,800
they will be carried out in the correct

00:10:20,640 --> 00:10:23,360
sequence and it will stop if any

00:10:22,800 --> 00:10:25,760
operation

00:10:23,360 --> 00:10:25,760
fails

00:10:27,760 --> 00:10:32,800
most of the read and write like

00:10:30,640 --> 00:10:34,320
operations on files and sockets are

00:10:32,800 --> 00:10:37,680
supported

00:10:34,320 --> 00:10:40,000
uh even including things like splice

00:10:37,680 --> 00:10:41,600
some of the control operations like set

00:10:40,000 --> 00:10:44,240
suck opt and isctl

00:10:41,600 --> 00:10:47,839
are not supported i think it's not

00:10:44,240 --> 00:10:47,839
really practical to support those

00:10:47,920 --> 00:10:52,480
executing on kernel threads

00:10:50,959 --> 00:10:54,160
there's a user space library to make

00:10:52,480 --> 00:10:56,399
this easy to use which is already

00:10:54,160 --> 00:10:58,720
packaged for debian as libya ring

00:10:56,399 --> 00:11:00,000
but so far not many packages are using

00:10:58,720 --> 00:11:03,200
it i can only see

00:11:00,000 --> 00:11:05,440
qmu i believe postgres

00:11:03,200 --> 00:11:08,079
can use this but the debian package

00:11:05,440 --> 00:11:12,000
currently doesn't

00:11:08,079 --> 00:11:17,360
bpf is another old very old feature

00:11:12,000 --> 00:11:17,360
that's been progressively extended

00:11:18,320 --> 00:11:22,160
it's a way for user space to install

00:11:20,800 --> 00:11:26,959
programs that will run

00:11:22,160 --> 00:11:29,120
in kernel context on in certain events

00:11:26,959 --> 00:11:30,480
this was originally created not in linux

00:11:29,120 --> 00:11:33,040
but in bsd

00:11:30,480 --> 00:11:36,000
as the berkeley packet filter which is

00:11:33,040 --> 00:11:36,000
where the name comes from

00:11:38,320 --> 00:11:42,320
its purpose was to allow filtering

00:11:40,240 --> 00:11:44,240
packets in the kernel before they were

00:11:42,320 --> 00:11:47,600
copied to user space

00:11:44,240 --> 00:11:50,880
so for example tcp dump uses this

00:11:47,600 --> 00:11:51,680
if you tell it you want to give it as an

00:11:50,880 --> 00:11:54,880
expression

00:11:51,680 --> 00:11:58,480
for which packets you want to see

00:11:54,880 --> 00:12:02,320
that expression is compiled into ppf

00:11:58,480 --> 00:12:02,320
code and runs in the kernel

00:12:03,360 --> 00:12:06,560
so these programs run uh they're not

00:12:05,680 --> 00:12:09,279
late if code

00:12:06,560 --> 00:12:11,440
they run in a 32-bit virtual machine

00:12:09,279 --> 00:12:14,480
with a small number of registers

00:12:11,440 --> 00:12:16,000
read actors do some context which in the

00:12:14,480 --> 00:12:18,800
case of tcp damp

00:12:16,000 --> 00:12:20,399
that would be packet headers they don't

00:12:18,800 --> 00:12:23,279
have access to any other memory

00:12:20,399 --> 00:12:25,040
and they can't do looping they do have

00:12:23,279 --> 00:12:26,240
conditional branches but those branches

00:12:25,040 --> 00:12:28,000
are always forward

00:12:26,240 --> 00:12:30,000
so that ensures that the program will

00:12:28,000 --> 00:12:34,160
always complete

00:12:30,000 --> 00:12:37,200
in bounded time originally this

00:12:34,160 --> 00:12:38,000
vm code would be interpreted but some

00:12:37,200 --> 00:12:42,560
time now there's been

00:12:38,000 --> 00:12:44,959
the option to for the kernel to compile

00:12:42,560 --> 00:12:45,680
the programs to native code and that's

00:12:44,959 --> 00:12:48,240
implemented

00:12:45,680 --> 00:12:48,959
on i think all of debian's release

00:12:48,240 --> 00:12:53,120
architect

00:12:48,959 --> 00:12:56,880
architectures a few years ago linux

00:12:53,120 --> 00:12:59,920
added something called extended bpf

00:12:56,880 --> 00:13:02,720
which has 64-bit registers

00:12:59,920 --> 00:13:04,880
and has both 32-bit and 64-bit

00:13:02,720 --> 00:13:07,600
arithmetic operations

00:13:04,880 --> 00:13:08,320
introduces a stack for local variables

00:13:07,600 --> 00:13:11,440
it supports

00:13:08,320 --> 00:13:13,279
pointer arithmetic with appropriate

00:13:11,440 --> 00:13:15,120
bounce checking

00:13:13,279 --> 00:13:17,360
uh it allows the programs to work with

00:13:15,120 --> 00:13:19,279
data structures that are also visible to

00:13:17,360 --> 00:13:22,000
user space

00:13:19,279 --> 00:13:22,000
and this was

00:13:23,200 --> 00:13:26,399
this has found a lot of uses in

00:13:24,959 --> 00:13:30,639
networking and

00:13:26,399 --> 00:13:34,000
in tracing where it can help to inspect

00:13:30,639 --> 00:13:36,639
kernel structures and

00:13:34,000 --> 00:13:39,360
gather statistics about them in a very

00:13:36,639 --> 00:13:39,360
efficient way

00:13:39,440 --> 00:13:44,880
the ability availability of the stack

00:13:42,720 --> 00:13:48,240
and pointer arithmetic makes it possible

00:13:44,880 --> 00:13:50,880
to compile c programs to bpf

00:13:48,240 --> 00:13:53,199
that was initially supported using that

00:13:50,880 --> 00:13:55,519
was initially supported in clang

00:13:53,199 --> 00:13:56,880
but more recently gcc has gained support

00:13:55,519 --> 00:14:00,320
for that

00:13:56,880 --> 00:14:03,839
and that's now packaging debian as the

00:14:00,320 --> 00:14:03,839
gcc bpf package

00:14:04,160 --> 00:14:08,639
there's a need for a quite complex

00:14:06,800 --> 00:14:11,519
verify in the kernel

00:14:08,639 --> 00:14:14,000
to statically verify that these programs

00:14:11,519 --> 00:14:14,000
are safe

00:14:14,240 --> 00:14:17,839
and unfortunately that means that bugs

00:14:16,800 --> 00:14:20,320
in that

00:14:17,839 --> 00:14:21,040
and that verifier do occur and can have

00:14:20,320 --> 00:14:25,120
severe

00:14:21,040 --> 00:14:27,680
security uh implications

00:14:25,120 --> 00:14:28,560
and also because of the because it's

00:14:27,680 --> 00:14:29,839
very powerful

00:14:28,560 --> 00:14:31,760
many of those features are only

00:14:29,839 --> 00:14:34,000
available to privileged users

00:14:31,760 --> 00:14:37,440
it's not okay for unprivileged users to

00:14:34,000 --> 00:14:37,440
be able to look at all kernel memory

00:14:40,639 --> 00:14:44,880
so recent changes to bpf or at least

00:14:43,440 --> 00:14:47,360
changed in the last year

00:14:44,880 --> 00:14:47,360
include

00:14:47,920 --> 00:14:51,760
it's now possible to have loops in

00:14:49,839 --> 00:14:53,680
programs as long as

00:14:51,760 --> 00:14:55,600
it's possible to verify aesthetically

00:14:53,680 --> 00:14:59,279
that those will only run at most

00:14:55,600 --> 00:15:02,079
a constant number of times

00:14:59,279 --> 00:15:03,199
it's possible to install programs that

00:15:02,079 --> 00:15:05,600
will

00:15:03,199 --> 00:15:07,040
filter get sock opt and set suck up

00:15:05,600 --> 00:15:09,519
calls

00:15:07,040 --> 00:15:10,880
these are presumably useful in container

00:15:09,519 --> 00:15:14,480
managers

00:15:10,880 --> 00:15:17,680
to uh restrict certain options

00:15:14,480 --> 00:15:21,360
that could allow containers to use uh

00:15:17,680 --> 00:15:23,600
excessive resources uh there's a hook

00:15:21,360 --> 00:15:25,760
that can install that allows installing

00:15:23,600 --> 00:15:26,959
program on each socket to monitor the

00:15:25,760 --> 00:15:31,040
tcp round trip

00:15:26,959 --> 00:15:34,240
time really important

00:15:31,040 --> 00:15:35,920
innovation was the addition of bpf type

00:15:34,240 --> 00:15:39,199
format or btf

00:15:35,920 --> 00:15:42,399
it's a quite compact

00:15:39,199 --> 00:15:45,600
set of debugging information

00:15:42,399 --> 00:15:46,959
that describes kernel structures and

00:15:45,600 --> 00:15:49,040
types

00:15:46,959 --> 00:15:50,639
and that makes it possible to compile a

00:15:49,040 --> 00:15:53,839
ppf program

00:15:50,639 --> 00:15:54,880
that will be runnable on multiple kernel

00:15:53,839 --> 00:15:58,160
versions

00:15:54,880 --> 00:16:01,040
before this the bpf

00:15:58,160 --> 00:16:03,680
program that inspects kernel structures

00:16:01,040 --> 00:16:07,279
we need to install the kernel headers

00:16:03,680 --> 00:16:09,519
and it would

00:16:07,279 --> 00:16:12,240
only work on a particular version of the

00:16:09,519 --> 00:16:14,399
kernel that it was built for

00:16:12,240 --> 00:16:17,600
there's also support for what i call

00:16:14,399 --> 00:16:19,839
dynamic program extensions

00:16:17,600 --> 00:16:21,680
when the program isn't directly called

00:16:19,839 --> 00:16:23,199
by the kernel but it provides

00:16:21,680 --> 00:16:24,959
functions that can be called from other

00:16:23,199 --> 00:16:28,240
bpf programs

00:16:24,959 --> 00:16:29,519
so it's roughly like shared libraries in

00:16:28,240 --> 00:16:32,800
user space

00:16:29,519 --> 00:16:35,040
the kernel has for a long time supported

00:16:32,800 --> 00:16:36,959
tcp congestion control modules which

00:16:35,040 --> 00:16:40,240
allow you to change the behavior of

00:16:36,959 --> 00:16:43,040
tcp but those had to implement

00:16:40,240 --> 00:16:44,959
implemented as kernel modules it's now

00:16:43,040 --> 00:16:49,680
possible to implement them as

00:16:44,959 --> 00:16:53,440
bpf programs bpf programs

00:16:49,680 --> 00:16:56,959
could run in hard interrupt contexts

00:16:53,440 --> 00:16:58,000
which would substantially increase the

00:16:56,959 --> 00:17:02,160
latency

00:16:58,000 --> 00:17:04,000
of interrupt handling and preemption

00:17:02,160 --> 00:17:07,039
which was a problem for the real-time

00:17:04,000 --> 00:17:08,959
patch set or preempt rt

00:17:07,039 --> 00:17:10,880
uh however that's now been fixed so it

00:17:08,959 --> 00:17:14,079
should be safe to safe to use this

00:17:10,880 --> 00:17:15,120
on real-time kernels linux security

00:17:14,079 --> 00:17:16,880
modules

00:17:15,120 --> 00:17:18,559
set security policies for the whole

00:17:16,880 --> 00:17:20,559
system uh

00:17:18,559 --> 00:17:21,600
the most well known of these are sc

00:17:20,559 --> 00:17:24,559
linux and app

00:17:21,600 --> 00:17:25,199
are there's now a bpf linux security

00:17:24,559 --> 00:17:27,679
module

00:17:25,199 --> 00:17:28,640
that allows you to set their security

00:17:27,679 --> 00:17:33,840
policy

00:17:28,640 --> 00:17:33,840
entirely in bpf

00:17:34,000 --> 00:17:37,919
now at the moment there are lots of

00:17:35,919 --> 00:17:42,960
useful bpf programs for tracing

00:17:37,919 --> 00:17:46,000
in the bpf cc tools package

00:17:42,960 --> 00:17:48,880
but as far as i can see

00:17:46,000 --> 00:17:50,480
the all the other types of useful ppf

00:17:48,880 --> 00:17:55,440
program

00:17:50,480 --> 00:17:55,440
are not not yet packaged in devin

00:17:56,799 --> 00:18:04,480
there's ongoing work in the kernel to

00:18:01,280 --> 00:18:07,760
mitigate certain types of security flaws

00:18:04,480 --> 00:18:11,200
and also to enable user space

00:18:07,760 --> 00:18:13,679
to to be more secure

00:18:11,200 --> 00:18:14,640
one of those is the option in the heap

00:18:13,679 --> 00:18:17,840
allocator

00:18:14,640 --> 00:18:22,080
to clear memory

00:18:17,840 --> 00:18:25,600
when it's allocated and after it's freed

00:18:22,080 --> 00:18:25,600
there's actually two separate options

00:18:25,760 --> 00:18:29,840
clearing memory when it's freed

00:18:30,880 --> 00:18:36,400
makes it much harder for our attacker to

00:18:33,440 --> 00:18:39,840
take advantage of our use after free bug

00:18:36,400 --> 00:18:41,760
because whatever uses the

00:18:39,840 --> 00:18:43,520
memory after it's freed we'll always see

00:18:41,760 --> 00:18:44,559
a zero there rather than an attacker

00:18:43,520 --> 00:18:48,559
controlled for

00:18:44,559 --> 00:18:50,640
value unfortunately that has quite a

00:18:48,559 --> 00:18:54,160
high performance cost

00:18:50,640 --> 00:18:56,960
clearing allocation is apparently

00:18:54,160 --> 00:19:00,240
much cheaper in terms of performance and

00:18:56,960 --> 00:19:00,240
we'll enable that by default

00:19:00,559 --> 00:19:05,919
that means that if the kernel

00:19:03,760 --> 00:19:06,960
accidentally uses an uninitialized value

00:19:05,919 --> 00:19:10,000
it will always see

00:19:06,960 --> 00:19:13,360
zero now rather than potentially seeing

00:19:10,000 --> 00:19:13,360
an attacker controlled value

00:19:15,280 --> 00:19:20,720
now on most uh demon release

00:19:18,080 --> 00:19:20,720
architectures

00:19:20,880 --> 00:19:25,840
the kernel now ensures that

00:19:26,240 --> 00:19:30,640
its own memory is either writable or

00:19:28,799 --> 00:19:31,360
executable but never both at the same

00:19:30,640 --> 00:19:34,000
time

00:19:31,360 --> 00:19:34,640
and that means if an attacker finds a

00:19:34,000 --> 00:19:36,480
bug

00:19:34,640 --> 00:19:37,760
that allows them to write arbitrary

00:19:36,480 --> 00:19:39,520
memory in the kernel

00:19:37,760 --> 00:19:41,039
they still can't write their own code

00:19:39,520 --> 00:19:42,720
there

00:19:41,039 --> 00:19:45,280
so they have to resort to techniques

00:19:42,720 --> 00:19:48,799
like return oriented programming

00:19:45,280 --> 00:19:52,559
that means they will overwrite

00:19:48,799 --> 00:19:57,280
function return addresses on the stack

00:19:52,559 --> 00:20:00,559
to point to sections of kernel code

00:19:57,280 --> 00:20:03,280
that can be used to do whatever it is

00:20:00,559 --> 00:20:03,280
they want to do

00:20:04,559 --> 00:20:08,960
some of those useful functions that

00:20:06,480 --> 00:20:11,919
attackers used to use

00:20:08,960 --> 00:20:15,520
uh were those for updating the cr0 and

00:20:11,919 --> 00:20:17,760
cr4 control registers on x86 processors

00:20:15,520 --> 00:20:18,880
by writing to arbitrary values to those

00:20:17,760 --> 00:20:22,720
it was possible to

00:20:18,880 --> 00:20:24,799
disable various protections

00:20:22,720 --> 00:20:26,640
like supervisor mode execution

00:20:24,799 --> 00:20:30,159
protection

00:20:26,640 --> 00:20:32,320
um that would then make it a lot easier

00:20:30,159 --> 00:20:34,400
for the

00:20:32,320 --> 00:20:35,760
attacker to start running arbitrary code

00:20:34,400 --> 00:20:37,440
in the kernel

00:20:35,760 --> 00:20:39,440
so those functions have been changed

00:20:37,440 --> 00:20:42,240
they will never clear those security

00:20:39,440 --> 00:20:42,240
critical bits

00:20:44,480 --> 00:20:48,559
some years now the kernels had a

00:20:46,840 --> 00:20:51,840
dedicated

00:20:48,559 --> 00:20:51,840
reference counting type

00:20:53,039 --> 00:20:56,880
one of these security issues with

00:20:54,480 --> 00:20:59,600
reference counting is

00:20:56,880 --> 00:21:00,840
if a incremental decrement is missed

00:20:59,600 --> 00:21:03,679
that can result

00:21:00,840 --> 00:21:07,919
in in

00:21:03,679 --> 00:21:07,919
a structure being freed too early

00:21:08,720 --> 00:21:15,280
the rough county originally had optional

00:21:12,480 --> 00:21:16,400
checking forever or underflow that was

00:21:15,280 --> 00:21:18,640
because it's

00:21:16,400 --> 00:21:19,520
too slow to be enabled by default on all

00:21:18,640 --> 00:21:22,640
architectures

00:21:19,520 --> 00:21:24,720
although i think x86 had

00:21:22,640 --> 00:21:26,480
efficient checking and it was enabled by

00:21:24,720 --> 00:21:29,600
default

00:21:26,480 --> 00:21:32,720
now that's uh fairly efficient checking

00:21:29,600 --> 00:21:36,000
is implemented for all architectures

00:21:32,720 --> 00:21:36,000
and it's enabled by default

00:21:36,480 --> 00:21:39,919
now a feature that's useful for user

00:21:38,880 --> 00:21:44,480
space to

00:21:39,919 --> 00:21:46,799
is improve its security is

00:21:44,480 --> 00:21:47,600
uh let's open that too is the latest

00:21:46,799 --> 00:21:51,440
variant

00:21:47,600 --> 00:21:54,240
of the open system call and it adds

00:21:51,440 --> 00:21:54,880
uh some flags that allow you to restrict

00:21:54,240 --> 00:21:59,840
the way

00:21:54,880 --> 00:21:59,840
uh the given file name is looked up

00:22:01,280 --> 00:22:06,000
various types of servers have to work

00:22:04,240 --> 00:22:07,600
with untrusted file systems

00:22:06,000 --> 00:22:09,440
for example container managers look

00:22:07,600 --> 00:22:11,440
inside the container

00:22:09,440 --> 00:22:13,360
file servers and web servers that look

00:22:11,440 --> 00:22:18,240
at

00:22:13,360 --> 00:22:18,240
directories owned by untrusted users

00:22:19,760 --> 00:22:23,760
so there are flags that allow you to

00:22:22,080 --> 00:22:26,960
disable

00:22:23,760 --> 00:22:30,000
any resolution of sim links or of the

00:22:26,960 --> 00:22:32,000
magic sim links that are present in in

00:22:30,000 --> 00:22:35,919
the proc file system

00:22:32,000 --> 00:22:38,080
you can disable crossing mount points so

00:22:35,919 --> 00:22:39,600
you will only find the file successfully

00:22:38,080 --> 00:22:43,440
if it's on the same

00:22:39,600 --> 00:22:46,080
mount you can disable

00:22:43,440 --> 00:22:48,720
looking above this started starting

00:22:46,080 --> 00:22:48,720
directory

00:22:50,880 --> 00:22:54,000
and you can also tell the kernel to

00:22:53,200 --> 00:22:56,960
treat the starting

00:22:54,000 --> 00:22:58,240
directory as the roots so it's as if you

00:22:56,960 --> 00:23:01,280
did a charute

00:22:58,240 --> 00:23:02,960
for just the single open

00:23:01,280 --> 00:23:04,720
and that doesn't require any special

00:23:02,960 --> 00:23:08,640
privilege to

00:23:04,720 --> 00:23:11,200
to do that

00:23:08,640 --> 00:23:13,440
so applications that need to work with

00:23:11,200 --> 00:23:18,480
untrusted file systems

00:23:13,440 --> 00:23:22,720
uh currently often have quite complex

00:23:18,480 --> 00:23:25,679
code to do this kind of path look up

00:23:22,720 --> 00:23:26,400
safely and it's going to be quite slow

00:23:25,679 --> 00:23:31,520
because it uses

00:23:26,400 --> 00:23:31,520
many system calls and in some cases it

00:23:31,919 --> 00:23:38,000
still won't be completely safe so

00:23:35,600 --> 00:23:38,960
those kind of applications should start

00:23:38,000 --> 00:23:42,559
using open

00:23:38,960 --> 00:23:42,559
to where available

00:23:43,360 --> 00:23:46,880
there are some other mitigations return

00:23:45,360 --> 00:23:50,559
awaited programming

00:23:46,880 --> 00:23:52,880
uh specific to the m64 architecture

00:23:50,559 --> 00:23:55,600
first of those is shadow call stacks

00:23:52,880 --> 00:23:59,919
which means that the

00:23:55,600 --> 00:24:01,919
uh there's a one stack used for

00:23:59,919 --> 00:24:04,640
local variables and separate stack used

00:24:01,919 --> 00:24:07,760
or function return addresses

00:24:04,640 --> 00:24:09,120
that's can be done in software only

00:24:07,760 --> 00:24:11,200
unfortunately it's currently only

00:24:09,120 --> 00:24:14,480
available in clang whereas we build the

00:24:11,200 --> 00:24:14,480
command with gcc

00:24:16,159 --> 00:24:20,080
so this might be a reason to start using

00:24:18,080 --> 00:24:23,600
clang on some architectures

00:24:20,080 --> 00:24:26,880
but uh i haven't even started to discuss

00:24:23,600 --> 00:24:26,880
that within the kernel team yet

00:24:27,679 --> 00:24:32,640
there's a feature added in arm

00:24:29,440 --> 00:24:34,640
architecture version 8.3 called pointer

00:24:32,640 --> 00:24:39,360
authentication

00:24:34,640 --> 00:24:41,600
and that means that

00:24:39,360 --> 00:24:42,559
pointers in memory are given quite a

00:24:41,600 --> 00:24:46,799
weak

00:24:42,559 --> 00:24:50,960
hash that's stored in the upper

00:24:46,799 --> 00:24:50,960
bits of the if it's value

00:24:51,840 --> 00:24:58,000
and that makes it using

00:24:55,760 --> 00:24:59,679
authenticated pointers for return

00:24:58,000 --> 00:25:03,760
addresses

00:24:59,679 --> 00:25:06,880
makes it much harder for an attacker to

00:25:03,760 --> 00:25:08,720
overwrite those with addresses that will

00:25:06,880 --> 00:25:11,279
be

00:25:08,720 --> 00:25:11,279
accepted

00:25:12,559 --> 00:25:17,200
and use space can opt into that assuming

00:25:15,760 --> 00:25:18,640
that it's running on my suitable

00:25:17,200 --> 00:25:20,559
processor

00:25:18,640 --> 00:25:22,799
and the code can also take advantage of

00:25:20,559 --> 00:25:22,799
that

00:25:24,960 --> 00:25:30,640
finally arm architecture version 8.5

00:25:27,440 --> 00:25:32,720
added branch target identification

00:25:30,640 --> 00:25:35,120
studio operations that i think are no

00:25:32,720 --> 00:25:37,360
ops on older processors

00:25:35,120 --> 00:25:38,640
the compiler should generate those at

00:25:37,360 --> 00:25:43,039
the beginning of a function

00:25:38,640 --> 00:25:45,679
and anywhere in a function that

00:25:43,039 --> 00:25:47,600
it might legitimately branch to if an

00:25:45,679 --> 00:25:50,640
attacker writes a return address

00:25:47,600 --> 00:25:53,919
that points to somewhere that isn't

00:25:50,640 --> 00:25:55,520
marked as a branch target uh then the

00:25:53,919 --> 00:25:58,960
kernel will crash

00:25:55,520 --> 00:26:01,760
that limits the the options for return

00:25:58,960 --> 00:26:01,760
awaited programming

00:26:03,279 --> 00:26:07,840
finally uh the module loader will

00:26:06,640 --> 00:26:10,320
actually enforce

00:26:07,840 --> 00:26:11,200
that modules did not have sections that

00:26:10,320 --> 00:26:14,400
are both

00:26:11,200 --> 00:26:14,400
writable and executable

00:26:14,799 --> 00:26:20,400
this year as in previous years the

00:26:17,760 --> 00:26:23,039
kernel developers have had to deal with

00:26:20,400 --> 00:26:24,080
security issues caused by speculative

00:26:23,039 --> 00:26:26,799
execution

00:26:24,080 --> 00:26:27,919
in cpus that can allow information to

00:26:26,799 --> 00:26:31,039
leak between different

00:26:27,919 --> 00:26:34,480
security contexts the first of these

00:26:31,039 --> 00:26:38,240
was tsx asynchronous

00:26:34,480 --> 00:26:41,279
abort it affected certain intel

00:26:38,240 --> 00:26:43,039
cpus that support tsx

00:26:41,279 --> 00:26:46,400
and specifically a feature called

00:26:43,039 --> 00:26:50,559
restricted transactional memory

00:26:46,400 --> 00:26:53,039
transactional memory allows a program to

00:26:50,559 --> 00:26:54,559
carry out a series of uh reason rights

00:26:53,039 --> 00:26:57,760
in memory

00:26:54,559 --> 00:26:58,880
uh that are then either committed to

00:26:57,760 --> 00:27:01,760
memory as a whole

00:26:58,880 --> 00:27:03,200
if no other cpu carried out conflicting

00:27:01,760 --> 00:27:05,840
operation

00:27:03,200 --> 00:27:06,960
or rolled back so they're never seen by

00:27:05,840 --> 00:27:10,400
the cpus

00:27:06,960 --> 00:27:15,200
if there was a conflict this can be

00:27:10,400 --> 00:27:15,200
more efficient than conventional locking

00:27:19,039 --> 00:27:24,240
unfortunately uh after a conflict is

00:27:22,880 --> 00:27:27,360
detected

00:27:24,240 --> 00:27:28,480
that doesn't uh doesn't always cause the

00:27:27,360 --> 00:27:31,200
transaction to be

00:27:28,480 --> 00:27:33,600
bolted straight away uh but instead it

00:27:31,200 --> 00:27:36,240
can continue executing speculatively

00:27:33,600 --> 00:27:36,240
afterwards

00:27:37,200 --> 00:27:41,440
and that resulted in similar

00:27:39,440 --> 00:27:44,320
opportunities for leaking

00:27:41,440 --> 00:27:45,440
as with the mds vulnerabilities that

00:27:44,320 --> 00:27:49,440
were disclosed

00:27:45,440 --> 00:27:49,840
earlier the cpus that were vulnerable to

00:27:49,440 --> 00:27:53,840
both

00:27:49,840 --> 00:27:55,360
mds and daa the existing mitigation

00:27:53,840 --> 00:27:57,600
covered this

00:27:55,360 --> 00:27:58,799
for newer cpus that were only vulnerable

00:27:57,600 --> 00:28:02,960
to this

00:27:58,799 --> 00:28:07,440
daa vulnerability intel issued a micro

00:28:02,960 --> 00:28:07,440
update that allowed disabling tsx

00:28:07,520 --> 00:28:14,399
and linux now does that by default if

00:28:11,279 --> 00:28:14,399
it's possible to do so

00:28:15,440 --> 00:28:19,600
second vulnerability was also specific

00:28:17,600 --> 00:28:22,880
to intel cpus

00:28:19,600 --> 00:28:25,360
that was special register buffer data

00:28:22,880 --> 00:28:28,840
sampling

00:28:25,360 --> 00:28:30,559
the cpus have a hardware random num

00:28:28,840 --> 00:28:32,880
generator

00:28:30,559 --> 00:28:35,279
but that's shared between multiple cpu

00:28:32,880 --> 00:28:35,279
cores

00:28:36,559 --> 00:28:40,159
so it uses special registers as a buffer

00:28:39,440 --> 00:28:43,120
between this

00:28:40,159 --> 00:28:44,320
shared block and the cpu cores

00:28:43,120 --> 00:28:47,520
speculative

00:28:44,320 --> 00:28:49,360
execution could use stale data read from

00:28:47,520 --> 00:28:51,679
the special register

00:28:49,360 --> 00:28:53,440
so that could mean that random numbers

00:28:51,679 --> 00:28:54,159
which are often used for cryptographic

00:28:53,440 --> 00:28:58,000
purposes

00:28:54,159 --> 00:29:01,919
would leak from uh one use

00:28:58,000 --> 00:29:01,919
to a different security context

00:29:02,080 --> 00:29:05,919
this is entirely mitigated by a

00:29:04,000 --> 00:29:08,559
microcode update

00:29:05,919 --> 00:29:09,200
but that makes the uh roddy round and

00:29:08,559 --> 00:29:11,120
rdc

00:29:09,200 --> 00:29:13,679
instructions so access the hardware

00:29:11,120 --> 00:29:15,360
hardware random number generator a lot

00:29:13,679 --> 00:29:18,720
slower

00:29:15,360 --> 00:29:19,760
so the kernel uh was changed to make

00:29:18,720 --> 00:29:22,480
much less use

00:29:19,760 --> 00:29:24,840
of the only random instruction and also

00:29:22,480 --> 00:29:26,320
to add an option to disable this

00:29:24,840 --> 00:29:30,799
mitigation

00:29:26,320 --> 00:29:30,799
in case it's not needed

00:29:31,919 --> 00:29:36,480
finally there have been various

00:29:33,360 --> 00:29:39,919
packaging changes over the last year

00:29:36,480 --> 00:29:45,520
we used to carry the lockdown patch sets

00:29:39,919 --> 00:29:45,520
and the it's a predecessor secure level

00:29:45,840 --> 00:29:48,960
that has now gone upstream although in a

00:29:48,080 --> 00:29:51,200
slightly different

00:29:48,960 --> 00:29:51,200
form

00:29:52,559 --> 00:29:55,919
we still have to carry a few patches for

00:29:54,559 --> 00:29:58,080
example the

00:29:55,919 --> 00:30:00,159
upstream kernel doesn't automatically

00:29:58,080 --> 00:30:01,440
engage lockdown when secure boot is

00:30:00,159 --> 00:30:04,320
enabled

00:30:01,440 --> 00:30:05,840
uh we do because that's that's a

00:30:04,320 --> 00:30:09,840
requirement for getting

00:30:05,840 --> 00:30:09,840
microsoft signing

00:30:10,720 --> 00:30:13,919
we used to carry a patch that allowed

00:30:13,360 --> 00:30:16,799
you to

00:30:13,919 --> 00:30:18,320
disable lockdown by pressing ssrq key

00:30:16,799 --> 00:30:20,399
combination

00:30:18,320 --> 00:30:24,240
unfortunately it turned out that it's

00:30:20,399 --> 00:30:27,120
possible for programs to synthesize that

00:30:24,240 --> 00:30:27,760
for example by using usb ip to add a

00:30:27,120 --> 00:30:30,960
virtual

00:30:27,760 --> 00:30:30,960
usb keyboard

00:30:32,399 --> 00:30:36,640
it should only be possible to disable

00:30:34,320 --> 00:30:40,240
secure boot if you're physically present

00:30:36,640 --> 00:30:44,159
so a programmatic way to do that

00:30:40,240 --> 00:30:47,120
is is is a security flaw

00:30:44,159 --> 00:30:48,320
the original lockdown patch set disabled

00:30:47,120 --> 00:30:51,760
features would allow

00:30:48,320 --> 00:30:55,440
reading arbitrary kernel memory uh which

00:30:51,760 --> 00:30:59,200
disables tracing for example

00:30:55,440 --> 00:31:01,679
there's more recently been a consensus

00:30:59,200 --> 00:31:04,240
between distributions that's that's not

00:31:01,679 --> 00:31:07,279
required we only need to disable

00:31:04,240 --> 00:31:08,720
writing arbitrary kernel memory so by

00:31:07,279 --> 00:31:12,240
default once the cooper

00:31:08,720 --> 00:31:12,559
security is enabled we set lock down to

00:31:12,240 --> 00:31:15,679
the

00:31:12,559 --> 00:31:18,960
integrity level that

00:31:15,679 --> 00:31:19,679
disables for example loading unsigned

00:31:18,960 --> 00:31:22,880
modules

00:31:19,679 --> 00:31:22,880
but does allow tracing

00:31:25,039 --> 00:31:31,840
several of the nas devices that

00:31:28,559 --> 00:31:34,000
the rbl port runs on

00:31:31,840 --> 00:31:37,440
unfortunately have a very small

00:31:34,000 --> 00:31:39,200
partition used to store the kernel image

00:31:37,440 --> 00:31:41,760
and on some of this it's only two

00:31:39,200 --> 00:31:43,600
megabytes for several years we've been

00:31:41,760 --> 00:31:48,480
carefully

00:31:43,600 --> 00:31:50,960
trimming features for the uh

00:31:48,480 --> 00:31:52,320
kernel flavor that runs on these devices

00:31:50,960 --> 00:31:53,919
to stay within that limit but

00:31:52,320 --> 00:31:57,039
unfortunately

00:31:53,919 --> 00:31:58,960
uh we haven't been able to do that and

00:31:57,039 --> 00:32:01,840
we had to drop support for some of those

00:31:58,960 --> 00:32:01,840
devices

00:32:03,120 --> 00:32:08,080
the meta packages such as linux amd 64

00:32:06,640 --> 00:32:11,279
that depend on the current

00:32:08,080 --> 00:32:13,039
version package used to be built from a

00:32:11,279 --> 00:32:14,000
separate source package called linux

00:32:13,039 --> 00:32:15,919
latest

00:32:14,000 --> 00:32:18,399
that needed to be kept in sync with

00:32:15,919 --> 00:32:20,159
linux

00:32:18,399 --> 00:32:21,919
that was there for historical reasons

00:32:20,159 --> 00:32:24,320
which no longer exist

00:32:21,919 --> 00:32:25,919
so they've now been merged together this

00:32:24,320 --> 00:32:27,440
should be meta packages

00:32:25,919 --> 00:32:30,240
are always in sync with the packages

00:32:27,440 --> 00:32:30,240
they depend on

00:32:32,000 --> 00:32:39,600
the trace event library

00:32:35,679 --> 00:32:42,559
which is used by some external programs

00:32:39,600 --> 00:32:42,559
is part of the

00:32:43,360 --> 00:32:49,120
part of the linux source so we've added

00:32:46,640 --> 00:32:51,519
shared library and development packages

00:32:49,120 --> 00:32:51,519
for that

00:32:53,919 --> 00:33:02,000
we already had a cloud amd 64 flavor

00:32:58,240 --> 00:33:05,360
of the kernel for mg 64

00:33:02,000 --> 00:33:08,559
that was that is specifically meant

00:33:05,360 --> 00:33:11,440
for use in vms that run in various kinds

00:33:08,559 --> 00:33:14,000
of cloud service

00:33:11,440 --> 00:33:14,720
and that has various features disabled

00:33:14,000 --> 00:33:16,640
that are

00:33:14,720 --> 00:33:18,000
not likely to be used in cloud

00:33:16,640 --> 00:33:20,559
deployments

00:33:18,000 --> 00:33:21,760
so it uses less disk space there's now a

00:33:20,559 --> 00:33:25,440
corresponding

00:33:21,760 --> 00:33:29,200
cloud arm 64 flavor

00:33:25,440 --> 00:33:31,760
for use on arm 64 vms

00:33:29,200 --> 00:33:32,480
the lib bpf packages that used to be

00:33:31,760 --> 00:33:35,360
built

00:33:32,480 --> 00:33:36,640
from the kernel source are now been

00:33:35,360 --> 00:33:39,840
moved out to their own

00:33:36,640 --> 00:33:39,840
source package

00:33:43,200 --> 00:33:46,799
we were finally dragged clicking and

00:33:45,120 --> 00:33:48,960
screaming from

00:33:46,799 --> 00:33:51,120
the helper capacitive ability level nine

00:33:48,960 --> 00:33:54,240
which is now

00:33:51,120 --> 00:33:56,480
consider deprecated forward to

00:33:54,240 --> 00:33:58,880
12. that didn't make a whole lot of

00:33:56,480 --> 00:33:58,880
difference

00:33:59,519 --> 00:34:03,519
it did make some small improvements to

00:34:01,440 --> 00:34:07,840
the

00:34:03,519 --> 00:34:07,840
uh hyper-v support package

00:34:08,159 --> 00:34:13,760
finally we've added a package of bpf

00:34:11,520 --> 00:34:13,760
tool

00:34:14,480 --> 00:34:22,879
so that's it time for questions

00:34:20,079 --> 00:34:25,520
so i will start with the first one about

00:34:22,879 --> 00:34:27,280
the microcode update for cpu mitigations

00:34:25,520 --> 00:34:29,200
i get it is non-free

00:34:27,280 --> 00:34:32,839
is there some sort of trade-off between

00:34:29,200 --> 00:34:34,079
freely auditable code and security

00:34:32,839 --> 00:34:36,879
mitigation

00:34:34,079 --> 00:34:37,760
uh i don't think there is uh such a

00:34:36,879 --> 00:34:41,760
trade-off

00:34:37,760 --> 00:34:43,679
uh there

00:34:41,760 --> 00:34:45,599
i mean there used to be this idea that

00:34:43,679 --> 00:34:49,839
free software was not

00:34:45,599 --> 00:34:49,839
uh insecure

00:35:00,839 --> 00:35:06,079
i i think the connection may have

00:35:04,560 --> 00:35:08,880
dropped but i hopefully

00:35:06,079 --> 00:35:10,640
it'll hopefully be better the cpu

00:35:08,880 --> 00:35:13,040
implementation

00:35:10,640 --> 00:35:16,320
and in some cases it's even encrypted

00:35:13,040 --> 00:35:18,720
it's unfortunately not

00:35:16,320 --> 00:35:22,079
not practical to replace that with some

00:35:18,720 --> 00:35:22,079
sort of free implementation

00:35:23,119 --> 00:35:28,400
next question will we ever get live

00:35:24,960 --> 00:35:28,400
patching and no more reboots

00:35:28,640 --> 00:35:32,720
we might but i think that would require

00:35:31,119 --> 00:35:35,920
uh

00:35:32,720 --> 00:35:39,839
uh a lot more people working on

00:35:35,920 --> 00:35:43,520
uh available to work on security updates

00:35:39,839 --> 00:35:47,200
uh for the for the kernel package

00:35:43,520 --> 00:35:47,200
uh the

00:35:48,320 --> 00:35:52,800
um we'd effectively be doing two

00:35:51,119 --> 00:35:55,440
versions of every security

00:35:52,800 --> 00:35:56,839
security update uh at the moment we

00:35:55,440 --> 00:36:00,240
already have to do

00:35:56,839 --> 00:36:00,240
sometimes up to

00:36:00,640 --> 00:36:05,520
four or five different uh package

00:36:03,040 --> 00:36:05,520
updates

00:36:05,839 --> 00:36:10,240
um right next question there's a new

00:36:08,320 --> 00:36:12,160
config option that allows the kernel to

00:36:10,240 --> 00:36:14,960
have the headers in memory

00:36:12,160 --> 00:36:16,560
config underscore ik headers is this

00:36:14,960 --> 00:36:18,480
already enabled in the latest kernel

00:36:16,560 --> 00:36:20,079
packages if not will you consider adding

00:36:18,480 --> 00:36:22,000
it

00:36:20,079 --> 00:36:23,839
no it's not enabled and we won't add it

00:36:22,000 --> 00:36:26,720
it's a waste of memory

00:36:23,839 --> 00:36:27,280
it's very easy to find the corresponding

00:36:26,720 --> 00:36:30,000
package

00:36:27,280 --> 00:36:30,000
from the archive

00:36:31,200 --> 00:36:35,119
okay next one uh can we please have a

00:36:33,200 --> 00:36:36,079
generic meta package that works on any

00:36:35,119 --> 00:36:38,560
architecture

00:36:36,079 --> 00:36:39,839
eg linux image depending on the linux

00:36:38,560 --> 00:36:42,480
image package for the current

00:36:39,839 --> 00:36:42,480
architecture

00:36:44,000 --> 00:36:50,640
uh that doesn't i don't think there's a

00:36:48,000 --> 00:36:52,560
good way to do that because on some our

00:36:50,640 --> 00:36:54,400
pictures there isn't

00:36:52,560 --> 00:36:56,480
there isn't a single package that will

00:36:54,400 --> 00:37:00,000
work for every uh

00:36:56,480 --> 00:37:02,720
every machine uh

00:37:00,000 --> 00:37:05,359
next is there a way to get marvel nes

00:37:02,720 --> 00:37:05,359
support back

00:37:06,160 --> 00:37:10,240
uh well some of the marvel nas devices

00:37:08,720 --> 00:37:13,680
are still supported

00:37:10,240 --> 00:37:15,040
uh for the others people have talked

00:37:13,680 --> 00:37:17,760
about the possibility

00:37:15,040 --> 00:37:18,880
of writing a second stage bootloader to

00:37:17,760 --> 00:37:21,119
the kernel partition

00:37:18,880 --> 00:37:23,920
instead of a real kernel and that would

00:37:21,119 --> 00:37:27,599
load the kernel from the file system

00:37:23,920 --> 00:37:30,720
uh so far no one's

00:37:27,599 --> 00:37:33,119
actually done the work to implement that

00:37:30,720 --> 00:37:34,960
um but if that was done then presumably

00:37:33,119 --> 00:37:37,839
we could have that integrated into

00:37:34,960 --> 00:37:37,839
flash kernel

00:37:38,400 --> 00:37:43,760
um and actually just because i think

00:37:41,920 --> 00:37:46,320
there was a bit of a connection issue

00:37:43,760 --> 00:37:48,000
during the first question would you mind

00:37:46,320 --> 00:37:51,599
repeating the answer for that or

00:37:48,000 --> 00:37:54,240
in a in a summarized fashion which was

00:37:51,599 --> 00:37:56,800
the microcode question uh give me a

00:37:54,240 --> 00:37:56,800
moment

00:37:56,880 --> 00:38:05,040
i um just second

00:38:00,720 --> 00:38:07,760
uh yes yes please

00:38:05,040 --> 00:38:09,119
uh so firstly my first part of the

00:38:07,760 --> 00:38:10,640
answer was

00:38:09,119 --> 00:38:13,280
no there isn't a trade-off between

00:38:10,640 --> 00:38:16,720
auditable code and security

00:38:13,280 --> 00:38:19,839
and the second one's that practically

00:38:16,720 --> 00:38:19,839
it's not possible to

00:38:20,079 --> 00:38:23,599
replace microcode with a with a free

00:38:22,079 --> 00:38:26,480
implementation

00:38:23,599 --> 00:38:26,480
as things stand

00:38:28,160 --> 00:38:35,440
okay um are there any further questions

00:38:32,560 --> 00:38:37,200
um sorry just look at the ether pad it's

00:38:35,440 --> 00:38:40,480
probably a good idea

00:38:37,200 --> 00:38:44,160
um so that looks like

00:38:40,480 --> 00:38:46,400
all the questions have been answered

00:38:44,160 --> 00:38:48,000
thank you all very much for attending

00:38:46,400 --> 00:38:51,040
and

00:38:48,000 --> 00:38:51,839
um please do also attend the other talks

00:38:51,040 --> 00:39:01,760
the next one

00:38:51,839 --> 00:39:01,760

YouTube URL: https://www.youtube.com/watch?v=oe4ulnKpWJc


