Title: LAVA: full-system testing on real hardware
Publication date: 2017-11-29
Playlist: DebConf 13
Description: 
	by Antonio Terceiro

At: DebConf13
https://debconf13.debconf.org/
Room: Second talk room
Scheduled start: 2013-08-15 16:30:00
Captions: 
	00:00:00,030 --> 00:00:07,279
so yeah welcome to Antonio we'll talk

00:00:03,149 --> 00:00:07,279
about full system testing in Rio Carla

00:00:09,559 --> 00:00:19,289
so as you can see something really nice

00:00:14,009 --> 00:00:24,289
and it has missions to remove Linux and

00:00:19,289 --> 00:00:26,820
related technologies are then it needs

00:00:24,289 --> 00:00:29,880
always validate the output of the engine

00:00:26,820 --> 00:00:37,260
or text own by placing our engineers

00:00:29,880 --> 00:00:40,280
then we can fly which is a quarter of

00:00:37,260 --> 00:00:45,200
missile testing in hungry or Hannah so

00:00:40,280 --> 00:00:50,010
the goals of this presentation is first

00:00:45,200 --> 00:00:52,350
this was what logarithm Hogwarts I'll

00:00:50,010 --> 00:00:54,690
talk briefly about power is needed every

00:00:52,350 --> 00:00:58,230
now and then I hope we can discuss how

00:00:54,690 --> 00:01:02,850
we produce a lot to buy the test data on

00:00:58,230 --> 00:01:07,770
case we need to test not go happy not a

00:01:02,850 --> 00:01:10,619
bit emotional stuff right there so of

00:01:07,770 --> 00:01:15,630
Lana so lava stands for with our

00:01:10,619 --> 00:01:17,640
automated validation architecture then

00:01:15,630 --> 00:01:21,630
it's a platform that we see the

00:01:17,640 --> 00:01:24,930
observations if it's those jobs were

00:01:21,630 --> 00:01:28,130
available devices deploys an OS image

00:01:24,930 --> 00:01:32,430
there solely now right now deploys

00:01:28,130 --> 00:01:36,390
Debian Ubuntu Fedora open embedded in

00:01:32,430 --> 00:01:39,689
the Android to test the narrow builds

00:01:36,390 --> 00:01:43,110
and doing to do care of continuous

00:01:39,689 --> 00:01:44,909
integration and then allow reboot the

00:01:43,110 --> 00:01:46,560
device using that image that was

00:01:44,909 --> 00:01:48,570
deployed and then run tests on the

00:01:46,560 --> 00:01:50,729
device and then gets the test out of the

00:01:48,570 --> 00:01:55,950
device so that you can analyze the

00:01:50,729 --> 00:01:58,290
results in a dashboard and then

00:01:55,950 --> 00:02:00,270
basically test can do anything so if you

00:01:58,290 --> 00:02:03,509
were in the previous presentation in the

00:02:00,270 --> 00:02:05,579
other room by Holger where the test jobs

00:02:03,509 --> 00:02:07,320
in Jenkins are just shell scripts in

00:02:05,579 --> 00:02:11,849
lava it's the same thing so you can

00:02:07,320 --> 00:02:13,950
write any arbitrary command in story

00:02:11,849 --> 00:02:19,099
Tina FCM reports during habit

00:02:13,950 --> 00:02:22,410
run on the device on their tests so we

00:02:19,099 --> 00:02:24,750
support quite a lot of devices so we

00:02:22,410 --> 00:02:27,470
have development boards and all of those

00:02:24,750 --> 00:02:30,930
we have in the Leonardo lab in Cambridge

00:02:27,470 --> 00:02:34,099
we also support some consumer device so

00:02:30,930 --> 00:02:36,930
phones and tablets we are able to run

00:02:34,099 --> 00:02:39,900
arbitrate tests on those devices as well

00:02:36,930 --> 00:02:43,049
also we already have support for high

00:02:39,900 --> 00:02:46,380
bank service so how the Cox EDA high

00:02:43,049 --> 00:02:50,340
bank nodes which is a one of the first

00:02:46,380 --> 00:02:53,340
I'm served in the market we also bought

00:02:50,340 --> 00:02:56,880
a visual and emulated devices so we have

00:02:53,340 --> 00:03:01,680
support for the arm fest models which

00:02:56,880 --> 00:03:05,130
are the proprietary emulators for non

00:03:01,680 --> 00:03:10,110
release at HUD by arm then infest models

00:03:05,130 --> 00:03:11,940
is the most missed name and product name

00:03:10,110 --> 00:03:15,060
in the history because they are not fast

00:03:11,940 --> 00:03:18,810
at all and then you also support Q mu

00:03:15,060 --> 00:03:23,040
and q kv m so we can support both arm

00:03:18,810 --> 00:03:27,060
and q mu and x86 kv m which is useful

00:03:23,040 --> 00:03:28,829
for for instance doing colonel cio

00:03:27,060 --> 00:03:30,810
actually six and make sure that the arm

00:03:28,829 --> 00:03:33,269
work doesn't break actually six because

00:03:30,810 --> 00:03:37,200
that makes the up string can develop

00:03:33,269 --> 00:03:42,540
very angry so we don't want to the army

00:03:37,200 --> 00:03:46,130
work should break at 8:36 anyway so we

00:03:42,540 --> 00:03:52,590
have some requirement for devising lava

00:03:46,130 --> 00:03:54,239
for for being able to so in love we have

00:03:52,590 --> 00:03:56,340
the problem of you have to always be

00:03:54,239 --> 00:03:59,099
able to recover a device so even if you

00:03:56,340 --> 00:04:01,440
boot if you deploy a image that has a

00:03:59,099 --> 00:04:03,480
broken kernel I cannot let panic that

00:04:01,440 --> 00:04:05,519
doesn't boot or had a broken bootloader

00:04:03,480 --> 00:04:08,160
you need to always come back to a

00:04:05,519 --> 00:04:12,209
reasonable good state so for that you

00:04:08,160 --> 00:04:13,799
have to have at least two features what

00:04:12,209 --> 00:04:15,599
at least one of those two features so

00:04:13,799 --> 00:04:17,489
you have tried to have some out-of-band

00:04:15,599 --> 00:04:21,479
management that you can control the

00:04:17,489 --> 00:04:23,580
device from outside for instance of a

00:04:21,479 --> 00:04:25,349
bootloader the support fastboot protocol

00:04:23,580 --> 00:04:27,900
which they won't use it by most Android

00:04:25,349 --> 00:04:30,660
devices or IPMI or

00:04:27,900 --> 00:04:32,790
the other form of banishing the device

00:04:30,660 --> 00:04:35,580
from outside so you can switch the

00:04:32,790 --> 00:04:37,470
device to boot for another food source

00:04:35,580 --> 00:04:40,949
or boots from the network or stuff like

00:04:37,470 --> 00:04:43,770
that or in the worst case you also have

00:04:40,949 --> 00:04:46,610
each zero access so you can have access

00:04:43,770 --> 00:04:49,229
to early boot logs or in the case you

00:04:46,610 --> 00:04:51,300
you can't get out of bed management if

00:04:49,229 --> 00:04:57,780
you do have Co axes then you can work

00:04:51,300 --> 00:05:00,360
around bad cares and stuff like that the

00:04:57,780 --> 00:05:04,650
requirements for OS images are very low

00:05:00,360 --> 00:05:06,360
so it must put to a shell so it has it

00:05:04,650 --> 00:05:09,930
has to be an image that doesn't present

00:05:06,360 --> 00:05:14,190
a boot prompt because we didn't want to

00:05:09,930 --> 00:05:17,100
mess with challenging the who did a

00:05:14,190 --> 00:05:20,340
login prompt and it has to have a POSIX

00:05:17,100 --> 00:05:23,849
ish shell so it kind of works with the

00:05:20,340 --> 00:05:25,380
Android shell but if you have a POSIX

00:05:23,849 --> 00:05:28,740
like bash is way better

00:05:25,380 --> 00:05:30,539
so in currently you have we have been

00:05:28,740 --> 00:05:32,580
using images for Debian Ubuntu Fedora

00:05:30,539 --> 00:05:39,479
open and bedding and all read Android as

00:05:32,580 --> 00:05:43,289
I said and the workflow usually is like

00:05:39,479 --> 00:05:45,240
this so you have VCS season where you

00:05:43,289 --> 00:05:51,210
store both the season source in the

00:05:45,240 --> 00:05:53,039
tests and then you have some CI system

00:05:51,210 --> 00:05:56,580
the continuous integration system using

00:05:53,039 --> 00:05:58,320
the narrow use the drinking's just as we

00:05:56,580 --> 00:06:01,620
are started to do in Debian so the

00:05:58,320 --> 00:06:06,810
Jenkins jobs they drink is service will

00:06:01,620 --> 00:06:09,750
do the builds or in a periodic way like

00:06:06,810 --> 00:06:12,870
every 24 hours or using triggers to

00:06:09,750 --> 00:06:16,590
build every calm each drinks can do any

00:06:12,870 --> 00:06:18,419
of those and then it submits a job to

00:06:16,590 --> 00:06:22,680
lava so it gets the artifacts produced

00:06:18,419 --> 00:06:25,610
by the build generates a lava job

00:06:22,680 --> 00:06:28,680
dynamically then submits the lava will

00:06:25,610 --> 00:06:30,449
provide a provisional device run the

00:06:28,680 --> 00:06:38,130
test and then provide the results back

00:06:30,449 --> 00:06:41,450
to Jenkins so a lava job it contains

00:06:38,130 --> 00:06:41,450
quite some parts

00:06:41,590 --> 00:06:48,820
first is a JSON job definition where you

00:06:45,970 --> 00:06:51,940
you specify which device type you want

00:06:48,820 --> 00:06:58,199
so you you can say I want up on the

00:06:51,940 --> 00:07:01,870
board or I want a high bank device or

00:06:58,199 --> 00:07:03,610
RFS model KVM or anything you specify

00:07:01,870 --> 00:07:06,130
which OS image you want to deploy on

00:07:03,610 --> 00:07:09,759
that device and then you specify which

00:07:06,130 --> 00:07:13,180
test you want to run and then the test

00:07:09,759 --> 00:07:14,949
definition is reusable across different

00:07:13,180 --> 00:07:17,349
job so you can have jobs for different

00:07:14,949 --> 00:07:21,220
devices they run the same tests you can

00:07:17,349 --> 00:07:23,919
have one job that runs all the tests

00:07:21,220 --> 00:07:26,110
available and then that s definition you

00:07:23,919 --> 00:07:28,720
specify which are the shell commands

00:07:26,110 --> 00:07:30,610
that were actually want to run so both

00:07:28,720 --> 00:07:33,849
of thinking can be auto generated in

00:07:30,610 --> 00:07:35,740
fact we are working on the new comment

00:07:33,849 --> 00:07:37,750
line tool that will auto generate all

00:07:35,740 --> 00:07:42,820
this stuff for you so you only have to

00:07:37,750 --> 00:07:47,949
care about how to use the lava api to

00:07:42,820 --> 00:07:51,159
specify test case result so you can

00:07:47,949 --> 00:07:52,840
specify test case using either the lava

00:07:51,159 --> 00:07:54,460
api which are shell commands that are

00:07:52,840 --> 00:07:57,340
available in the device when you are

00:07:54,460 --> 00:07:58,990
running the test or using pattern

00:07:57,340 --> 00:08:00,639
matching on the output of the shell

00:07:58,990 --> 00:08:06,580
commands so I'm going to show examples

00:08:00,639 --> 00:08:09,400
of both ways so when your test is

00:08:06,580 --> 00:08:11,729
running on the device lava has put some

00:08:09,400 --> 00:08:16,389
binaries in the path that are available

00:08:11,729 --> 00:08:19,599
then you can just do stuff like this so

00:08:16,389 --> 00:08:21,970
lava test case the highlighted part of

00:08:19,599 --> 00:08:24,729
the name of the test and then after is

00:08:21,970 --> 00:08:26,949
what the test does so in this case you

00:08:24,729 --> 00:08:29,580
can run shell commands and then if that

00:08:26,949 --> 00:08:32,469
show comments exceeds the shell

00:08:29,580 --> 00:08:34,870
the test is considered passive if the

00:08:32,469 --> 00:08:39,039
test fails then the tests considered as

00:08:34,870 --> 00:08:41,229
failing you can off declare explicitly

00:08:39,039 --> 00:08:43,959
the result without running anything so

00:08:41,229 --> 00:08:46,060
if you have some comments before that

00:08:43,959 --> 00:08:48,940
you can test there's some condition then

00:08:46,060 --> 00:08:52,600
declared SS file or present you can also

00:08:48,940 --> 00:08:54,040
attach measurements so you can use these

00:08:52,600 --> 00:08:56,560
to store results of

00:08:54,040 --> 00:08:59,800
benchmarks and stuff like that and you

00:08:56,560 --> 00:09:07,600
can after visualize how your results

00:08:59,800 --> 00:09:10,120
evolve it as your run tests so the other

00:09:07,600 --> 00:09:12,339
way of doing it is if for instance if

00:09:10,120 --> 00:09:14,470
you are running some upswing test suite

00:09:12,339 --> 00:09:16,529
that already exists and you don't want

00:09:14,470 --> 00:09:19,029
to change it then you can specify

00:09:16,529 --> 00:09:24,399
regular expression to parse the output

00:09:19,029 --> 00:09:26,529
and then after the tech the test results

00:09:24,399 --> 00:09:28,889
from the output of the upswing test

00:09:26,529 --> 00:09:31,720
suite so if you do something like this

00:09:28,889 --> 00:09:35,319
is this is a Python angular expression

00:09:31,720 --> 00:09:41,440
then it will match lines in the output

00:09:35,319 --> 00:09:46,319
like test name equals result so you have

00:09:41,440 --> 00:09:49,149
you also have you have three possible

00:09:46,319 --> 00:09:52,899
reasons for a test I leave pass/fail or

00:09:49,149 --> 00:09:55,000
skip and then you can also specify if

00:09:52,899 --> 00:09:56,560
the upswing test which uses different

00:09:55,000 --> 00:09:59,800
names for path and failure you can

00:09:56,560 --> 00:10:06,519
specify a mapping from success to pass

00:09:59,800 --> 00:10:09,190
for instance so I have a quick demo here

00:10:06,519 --> 00:10:09,870
I hope it works and doesn't break

00:10:09,190 --> 00:10:14,980
anything

00:10:09,870 --> 00:10:21,010
so here it it's a JSON lavalava job

00:10:14,980 --> 00:10:25,029
definition so you have here which device

00:10:21,010 --> 00:10:28,449
you want to submit to here you specify a

00:10:25,029 --> 00:10:30,190
list of actions then you can design it

00:10:28,449 --> 00:10:32,649
any kind of tests you need so in this

00:10:30,190 --> 00:10:37,689
case this is the most simple test you

00:10:32,649 --> 00:10:44,860
just deploy an image you say where the

00:10:37,689 --> 00:10:46,930
image is a web server and then the next

00:10:44,860 --> 00:10:50,110
action is the lava test show action

00:10:46,930 --> 00:10:51,970
which is the action that enables write

00:10:50,110 --> 00:10:55,600
writing those arbitrary testing shell

00:10:51,970 --> 00:10:58,170
script here you say where you want to

00:10:55,600 --> 00:11:02,699
pull the test run in this case is a

00:10:58,170 --> 00:11:05,260
bizarre repository and then you specify

00:11:02,699 --> 00:11:08,050
where the reporter is the test

00:11:05,260 --> 00:11:11,170
definition so that there is a default

00:11:08,050 --> 00:11:14,880
value for that but this is the placing

00:11:11,170 --> 00:11:19,450
that we pose read the test definition is

00:11:14,880 --> 00:11:22,870
then there's the test definition now

00:11:19,450 --> 00:11:25,600
it's a llamar file has some metadata in

00:11:22,870 --> 00:11:28,209
the top you can specify the penises

00:11:25,600 --> 00:11:30,250
indeed that's been going to be handled

00:11:28,209 --> 00:11:32,410
by the underlying implementation

00:11:30,250 --> 00:11:35,320
depending on the distribution of the OS

00:11:32,410 --> 00:11:38,490
so it will auto detect if it's fedora of

00:11:35,320 --> 00:11:41,980
its debian and then do the right thing

00:11:38,490 --> 00:11:45,370
so you can specify either generic the

00:11:41,980 --> 00:11:52,089
penis names or district specifically

00:11:45,370 --> 00:11:53,680
aims here and then it will install in

00:11:52,089 --> 00:11:56,410
the way that distribution is supposed to

00:11:53,680 --> 00:11:59,380
install package and then in the run

00:11:56,410 --> 00:12:01,420
steps you just put the shell commands

00:11:59,380 --> 00:12:04,329
you want so you can either put all the

00:12:01,420 --> 00:12:06,250
shell commands in the ml file or you can

00:12:04,329 --> 00:12:07,810
just put a single command at scallions

00:12:06,250 --> 00:12:10,690
and external script in the same

00:12:07,810 --> 00:12:12,610
repository means that's going to be run

00:12:10,690 --> 00:12:15,399
in that script is also going to have

00:12:12,610 --> 00:12:20,890
access to the it differ to the API calls

00:12:15,399 --> 00:12:24,250
here so you can call those make those

00:12:20,890 --> 00:12:29,050
calls in an external script as well in

00:12:24,250 --> 00:12:32,649
you can also specify a a matching

00:12:29,050 --> 00:12:36,910
pattern to get results from the output

00:12:32,649 --> 00:12:38,950
so you can also reuse existing test

00:12:36,910 --> 00:12:43,589
reason effectively now we do that a lot

00:12:38,950 --> 00:12:43,589
so there are observing test Suites for

00:12:43,829 --> 00:12:50,560
performance tests or functional tests

00:12:46,270 --> 00:12:52,420
there is the Linux test product who has

00:12:50,560 --> 00:12:55,050
several test Suites and then you can

00:12:52,420 --> 00:12:59,410
just reuse those tests and then pyrite

00:12:55,050 --> 00:13:06,760
meshing matching pattern to extract the

00:12:59,410 --> 00:13:09,490
test results then we can also submit a

00:13:06,760 --> 00:13:12,970
test here so I can't get these days on

00:13:09,490 --> 00:13:16,480
fire so here is the the web interface

00:13:12,970 --> 00:13:20,279
for lava it has you can see we have

00:13:16,480 --> 00:13:20,279
quite some devices in the llanera lab

00:13:20,780 --> 00:13:26,810
so all right now there are some eight

00:13:23,120 --> 00:13:35,960
devices running tests and then you can

00:13:26,810 --> 00:13:38,990
submit jobs so when you submit a job you

00:13:35,960 --> 00:13:42,110
get a job ID and then you can follow the

00:13:38,990 --> 00:13:47,300
results and you can even watch the

00:13:42,110 --> 00:13:49,160
results live so here we have the test is

00:13:47,300 --> 00:13:53,810
already running its first downloaded the

00:13:49,160 --> 00:13:58,280
image to deploy to the device and in a

00:13:53,810 --> 00:14:01,100
few seconds you will be able to see then

00:13:58,280 --> 00:14:10,070
here you can watch the console output

00:14:01,100 --> 00:14:12,470
live so it's already boring so if we

00:14:10,070 --> 00:14:16,220
scroll down we can always watch what's

00:14:12,470 --> 00:14:19,360
happening now it's installing the

00:14:16,220 --> 00:14:19,360
dependencies of the test

00:14:33,150 --> 00:14:39,420
yeah so the test finishes successfully

00:14:36,480 --> 00:14:41,610
of course I mean I'm making an example

00:14:39,420 --> 00:14:46,200
here using KVM which is way faster than

00:14:41,610 --> 00:14:47,640
everything else so but with which a real

00:14:46,200 --> 00:14:50,550
device takes a little longer because you

00:14:47,640 --> 00:14:52,980
have to actually write to the SD card or

00:14:50,550 --> 00:14:58,620
some other type of storage that's in the

00:14:52,980 --> 00:15:00,720
device okay

00:14:58,620 --> 00:15:04,560
talked earlier about the architecture so

00:15:00,720 --> 00:15:06,570
you have three main components the first

00:15:04,560 --> 00:15:09,210
is the web UI that you saw where you

00:15:06,570 --> 00:15:10,710
have a dashboard where you can visualize

00:15:09,210 --> 00:15:15,930
the test results you can now submit

00:15:10,710 --> 00:15:17,580
tests and manage the devices you can put

00:15:15,930 --> 00:15:19,320
devices offline for maintenance for

00:15:17,580 --> 00:15:21,620
instance if you need to take a device

00:15:19,320 --> 00:15:24,089
out you can mark it offline and then the

00:15:21,620 --> 00:15:26,640
there is no job there will be no job

00:15:24,089 --> 00:15:29,790
submitted there then you have a

00:15:26,640 --> 00:15:31,740
relational database where the data store

00:15:29,790 --> 00:15:33,720
anywhere you have a scheduler daemon

00:15:31,740 --> 00:15:35,850
which is the component that keeps poly

00:15:33,720 --> 00:15:40,140
for jobs and then we'll choose which

00:15:35,850 --> 00:15:43,140
device you run any incoming jobs then

00:15:40,140 --> 00:15:45,630
that scheduler Jeevan will spawn a

00:15:43,140 --> 00:15:47,610
dispatcher process which is the backend

00:15:45,630 --> 00:15:52,050
implementation for talking to the device

00:15:47,610 --> 00:15:53,730
so in the dispatcher you have specific

00:15:52,050 --> 00:15:56,339
backends for each type of device or the

00:15:53,730 --> 00:15:58,500
opinion the device capabilities you need

00:15:56,339 --> 00:16:01,020
to talk to it in the different way so if

00:15:58,500 --> 00:16:04,110
the device has out of main management

00:16:01,020 --> 00:16:07,080
that code has that back-end has to talk

00:16:04,110 --> 00:16:12,150
to the to that mechanism it has a serial

00:16:07,080 --> 00:16:14,339
console and it uses a in each type of

00:16:12,150 --> 00:16:17,430
other other type of communication it's

00:16:14,339 --> 00:16:19,200
going to use that in also the fact that

00:16:17,430 --> 00:16:21,300
the dispatcher separated means that you

00:16:19,200 --> 00:16:24,570
also can run it directly without having

00:16:21,300 --> 00:16:26,820
the entire architecture so you can have

00:16:24,570 --> 00:16:28,790
just the dispatcher you can connect the

00:16:26,820 --> 00:16:32,550
device to the airport and then use that

00:16:28,790 --> 00:16:38,620
for development or for early testing of

00:16:32,550 --> 00:16:42,280
the test suite so

00:16:38,620 --> 00:16:44,950
talk a little about Lovett Lennar oh we

00:16:42,280 --> 00:16:46,810
have some user case they're not only

00:16:44,950 --> 00:16:49,900
those but those are the main ones so you

00:16:46,810 --> 00:16:54,160
do we do carry on CI for both arm and

00:16:49,900 --> 00:16:57,730
x86 hardware enablement testing for me

00:16:54,160 --> 00:16:58,840
by Harley so Leonardo members they some

00:16:57,730 --> 00:17:01,210
of them have their own lava

00:16:58,840 --> 00:17:02,200
installations if they had that's

00:17:01,210 --> 00:17:04,630
confidential

00:17:02,200 --> 00:17:09,310
some others put the hard during daily

00:17:04,630 --> 00:17:12,190
narrow lab and then we have enablement

00:17:09,310 --> 00:17:15,540
testing for those holiday which is Wi-Fi

00:17:12,190 --> 00:17:18,340
testing it was power management testing

00:17:15,540 --> 00:17:23,650
scheduling testing and all those kind of

00:17:18,340 --> 00:17:25,210
tests we asked our tests are the inner

00:17:23,650 --> 00:17:28,320
engineering us build so Leonardo

00:17:25,210 --> 00:17:31,990
produces both Android fedora

00:17:28,320 --> 00:17:35,860
openembedded and Ubuntu builds in those

00:17:31,990 --> 00:17:37,810
our testers on the lava we're also

00:17:35,860 --> 00:17:43,840
starting to use it to for boot loaders

00:17:37,810 --> 00:17:46,480
so for the new new class of boot loaders

00:17:43,840 --> 00:17:47,620
so we have tests for UEFI for instance

00:17:46,480 --> 00:17:51,790
so we are working on right now

00:17:47,620 --> 00:17:56,370
integrating the official UEFI tests for

00:17:51,790 --> 00:17:59,170
certifying the UEFI produces valine ro

00:17:56,370 --> 00:18:02,110
and in general testing software provided

00:17:59,170 --> 00:18:04,420
for arm so as I said Linares focus on is

00:18:02,110 --> 00:18:07,270
own arm but there is nothing stopping

00:18:04,420 --> 00:18:09,480
people using lava for any other kind of

00:18:07,270 --> 00:18:09,480
device

00:18:10,680 --> 00:18:16,630
now there's the here's the point where

00:18:14,260 --> 00:18:20,920
we can discuss how we could use this for

00:18:16,630 --> 00:18:26,170
for improving the a beam so first we

00:18:20,920 --> 00:18:28,180
have Debian packaging progress so we had

00:18:26,170 --> 00:18:31,120
some initial packaging done by the

00:18:28,180 --> 00:18:34,000
collabora guys they send us centers the

00:18:31,120 --> 00:18:36,990
packages and we are working on them then

00:18:34,000 --> 00:18:40,660
pretty sure pretty soon we should have

00:18:36,990 --> 00:18:43,030
those packages ready so you can just to

00:18:40,660 --> 00:18:45,550
get Stoll lava seven you are done and

00:18:43,030 --> 00:18:47,790
you just have to configure your devices

00:18:45,550 --> 00:18:53,460
and lava

00:18:47,790 --> 00:18:55,620
and then here's where we discuss how we

00:18:53,460 --> 00:18:57,480
could use this for Debian so I I don't

00:18:55,620 --> 00:19:01,350
think we should use it for everything I

00:18:57,480 --> 00:19:03,000
mean a lot of case for test cases react

00:19:01,350 --> 00:19:06,230
we can already do with Jenkins and the

00:19:03,000 --> 00:19:09,840
stuff the Holger is working on so I

00:19:06,230 --> 00:19:12,360
wanted to discuss what we could do that

00:19:09,840 --> 00:19:15,060
one that we could only do with lava and

00:19:12,360 --> 00:19:21,450
then integrate that some somehow into

00:19:15,060 --> 00:19:24,960
drink and that's it this is my last

00:19:21,450 --> 00:19:28,100
slide and I I would appreciate if you

00:19:24,960 --> 00:19:28,100
guys have some ideas on that

00:19:44,250 --> 00:19:53,110
anybody wants to microphone doesn't seem

00:19:51,100 --> 00:19:54,760
to be the case so I'm at least let's

00:19:53,110 --> 00:19:56,350
thank the speaker for presentation and

00:19:54,760 --> 00:19:59,290
maybe there comes up a discussion when

00:19:56,350 --> 00:20:00,790
we get out and sit in the Sun so great

00:19:59,290 --> 00:20:03,829
thank you

00:20:00,790 --> 00:20:03,829

YouTube URL: https://www.youtube.com/watch?v=j22ATGIN1Mw


