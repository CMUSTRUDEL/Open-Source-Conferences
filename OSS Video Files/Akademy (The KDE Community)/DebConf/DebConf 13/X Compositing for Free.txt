Title: X Compositing for Free
Publication date: 2017-11-29
Playlist: DebConf 13
Description: 
	by Keith Packard

At: DebConf13
https://debconf13.debconf.org/
Room: Main talk room
Scheduled start: 2013-08-13 17:30:00
Captions: 
	00:00:00,000 --> 00:00:08,269
today my name is Keith Packard my debian

00:00:02,580 --> 00:00:12,559
ID is Keith P I've been hacking on x4

00:00:08,269 --> 00:00:14,009
pepper yeah approximately 25 years

00:00:12,559 --> 00:00:16,260
something like that

00:00:14,009 --> 00:00:19,500
maybe a little longer I want to talk

00:00:16,260 --> 00:00:21,980
today about some recent work that I've

00:00:19,500 --> 00:00:25,170
been doing in X to improve application

00:00:21,980 --> 00:00:26,550
presentation make it look prettier I'm

00:00:25,170 --> 00:00:29,550
going to describe what the problems are

00:00:26,550 --> 00:00:31,619
I'll go over the the solution that I

00:00:29,550 --> 00:00:33,239
have and we'll talk about what I'm what

00:00:31,619 --> 00:00:36,360
you know of course there will be some

00:00:33,239 --> 00:00:38,219
demos there's always demos right so the

00:00:36,360 --> 00:00:41,850
big question is so I've the talk is

00:00:38,219 --> 00:00:47,129
about DRI 3000 so what is DRI 3000 DRI

00:00:41,850 --> 00:00:48,930
3000 is a way of hooking direct

00:00:47,129 --> 00:00:50,850
rendering clients to X yeah we want to

00:00:48,930 --> 00:00:52,410
do that that's what DRI 2 did that's

00:00:50,850 --> 00:00:54,510
what the original DRI did so you have a

00:00:52,410 --> 00:00:56,489
direct rendering application drawing

00:00:54,510 --> 00:00:58,410
talking directly to the GPU not through

00:00:56,489 --> 00:00:59,910
X and then you want to get the results

00:00:58,410 --> 00:01:02,640
of that rendering onto the screen well

00:00:59,910 --> 00:01:05,280
that's part of DRI 3000 another part of

00:01:02,640 --> 00:01:06,720
DRI thousand is synchronization one of

00:01:05,280 --> 00:01:08,250
the things that application developers

00:01:06,720 --> 00:01:10,439
do now that our computers are fast

00:01:08,250 --> 00:01:11,820
enough is they draw faster than the

00:01:10,439 --> 00:01:15,210
screen and they would desperately like

00:01:11,820 --> 00:01:17,130
the screen updates to be a whole screen

00:01:15,210 --> 00:01:19,170
and not two pieces of a screen with a

00:01:17,130 --> 00:01:21,509
big horizontal line how many of you have

00:01:19,170 --> 00:01:23,580
watched movies or played video games and

00:01:21,509 --> 00:01:26,790
had a big little horizontal line to your

00:01:23,580 --> 00:01:29,070
screen yeah that's called tearing we

00:01:26,790 --> 00:01:31,470
don't like that I'm gonna try to get rid

00:01:29,070 --> 00:01:33,810
of that the other thing that DRI 3000 is

00:01:31,470 --> 00:01:35,939
trying to address is how to be more

00:01:33,810 --> 00:01:37,770
aware of the fact that X Apple X

00:01:35,939 --> 00:01:40,020
environments are typically composited

00:01:37,770 --> 00:01:41,520
these days the compositing environment

00:01:40,020 --> 00:01:43,380
means where you have all of your

00:01:41,520 --> 00:01:44,850
applications drawing off-screen and you

00:01:43,380 --> 00:01:46,649
have a super application called the

00:01:44,850 --> 00:01:48,899
compositing manager that puts together

00:01:46,649 --> 00:01:51,360
pretty frames for you and adds all of

00:01:48,899 --> 00:01:52,829
your drop shadows this is not running

00:01:51,360 --> 00:01:55,049
compositing right now because the only

00:01:52,829 --> 00:01:57,810
way I could develop DRI 3000 and test it

00:01:55,049 --> 00:02:00,619
is to turn it off for now so I'm running

00:01:57,810 --> 00:02:03,119
Matassa T without without compositing oh

00:02:00,619 --> 00:02:05,189
so what are the goals of DRI thousand

00:02:03,119 --> 00:02:06,630
well the chief the primary goal for dear

00:02:05,189 --> 00:02:10,619
I think three thousand and the reason we

00:02:06,630 --> 00:02:12,660
started this about a year ago in year

00:02:10,619 --> 00:02:15,360
ago yeah about a year ago in

00:02:12,660 --> 00:02:17,610
Germany was to fix a bunch of known

00:02:15,360 --> 00:02:19,800
deficiencies in DRI to DRI two is

00:02:17,610 --> 00:02:21,360
current direct rendering interface it's

00:02:19,800 --> 00:02:23,940
got a bunch of problems I have two

00:02:21,360 --> 00:02:25,410
slides full I'll show you what those are

00:02:23,940 --> 00:02:25,950
I will talk about how we're going to fix

00:02:25,410 --> 00:02:28,290
those

00:02:25,950 --> 00:02:30,570
um the other thing that DRI 3000 wants

00:02:28,290 --> 00:02:32,490
to do is is improve the support for a

00:02:30,570 --> 00:02:34,260
bunch of presentation related GL

00:02:32,490 --> 00:02:37,020
extensions they're a bunch of Geo

00:02:34,260 --> 00:02:39,120
related extensions for media and V like

00:02:37,020 --> 00:02:42,870
synchronization and making games happier

00:02:39,120 --> 00:02:43,920
and DRI to can't support those and so

00:02:42,870 --> 00:02:45,870
we're to talk about how we're gonna fix

00:02:43,920 --> 00:02:47,880
them the other thing that I really

00:02:45,870 --> 00:02:50,210
wanted to do was to was to make it

00:02:47,880 --> 00:02:52,230
possible to get V blank synchronization

00:02:50,210 --> 00:02:54,960
which is to say getting rid of the

00:02:52,230 --> 00:02:57,660
tearing for not just G occasions using

00:02:54,960 --> 00:03:00,060
DRI but also regular old 2d applications

00:02:57,660 --> 00:03:03,480
there's no particular reason why DRI to

00:03:00,060 --> 00:03:05,370
restricts the the tearing fixes to GL

00:03:03,480 --> 00:03:07,980
applications but it's all it exposes you

00:03:05,370 --> 00:03:09,540
can't get at that functionality through

00:03:07,980 --> 00:03:12,450
the core X protocol which really sucks

00:03:09,540 --> 00:03:15,300
because most of my applications are not

00:03:12,450 --> 00:03:17,610
3d applications I run you know word

00:03:15,300 --> 00:03:18,900
processors and text editors and all

00:03:17,610 --> 00:03:20,910
kinds of stuff and I would really like

00:03:18,900 --> 00:03:23,760
to get the same pretty screen that I get

00:03:20,910 --> 00:03:27,390
with my with my PC board layout tools

00:03:23,760 --> 00:03:29,760
that I get in my text editor and of

00:03:27,390 --> 00:03:32,400
course one of the key things we always

00:03:29,760 --> 00:03:34,530
wanted we're talking about desktop and

00:03:32,400 --> 00:03:36,810
laptop computing these days is improving

00:03:34,530 --> 00:03:40,830
performance mostly so that we save a

00:03:36,810 --> 00:03:42,600
bunch of power DRI to right now for a GL

00:03:40,830 --> 00:03:45,300
application with a compositing manager

00:03:42,600 --> 00:03:47,790
involves three copies of every frame on

00:03:45,300 --> 00:03:50,520
its way to the screen three is probably

00:03:47,790 --> 00:03:54,030
more than you want we'd like to get to 1

00:03:50,520 --> 00:03:57,180
or 0 ok so what are the components of

00:03:54,030 --> 00:03:59,489
DRI 3000 well in DRI 2 was all one big

00:03:57,180 --> 00:04:02,459
monolithic extension which is why you

00:03:59,489 --> 00:04:04,800
couldn't use DRI 2 which which is why

00:04:02,459 --> 00:04:06,720
you couldn't get the that the secret the

00:04:04,800 --> 00:04:09,270
V blank synchronization for non DRI

00:04:06,720 --> 00:04:11,880
applications because that was all part

00:04:09,270 --> 00:04:13,140
of the DRI 2 extension well in DRI 3

00:04:11,880 --> 00:04:14,489
we're gonna split things up a little bit

00:04:13,140 --> 00:04:17,760
the first thing we're going to create is

00:04:14,489 --> 00:04:20,280
a DRI 3 extension the DRI 3 extension is

00:04:17,760 --> 00:04:21,810
the absolute bare minimum necessary to

00:04:20,280 --> 00:04:24,840
connect a direct rendering application

00:04:21,810 --> 00:04:26,220
to X I have a slide showing the entire

00:04:24,840 --> 00:04:28,470
extension on

00:04:26,220 --> 00:04:29,520
slide the second thing we're gonna do is

00:04:28,470 --> 00:04:31,950
we're gonna create a presentation

00:04:29,520 --> 00:04:34,050
extension called present if anybody has

00:04:31,950 --> 00:04:35,700
a better name for this extension I would

00:04:34,050 --> 00:04:38,640
love to have a better name which is not

00:04:35,700 --> 00:04:40,980
both a verb and a noun and an adverb or

00:04:38,640 --> 00:04:42,990
whatever this horrible word is yeah my

00:04:40,980 --> 00:04:44,910
English English language understanding

00:04:42,990 --> 00:04:47,250
is pretty minimal but present is clearly

00:04:44,910 --> 00:04:48,450
a terrible name for the extension but I

00:04:47,250 --> 00:04:53,070
haven't found a better one so if you

00:04:48,450 --> 00:04:54,450
have ideas please make suggestions the

00:04:53,070 --> 00:04:56,400
other the other pieces are some new

00:04:54,450 --> 00:05:00,390
kernel api's which are optional and

00:04:56,400 --> 00:05:03,330
we'll describe what these do the kernel

00:05:00,390 --> 00:05:05,760
API for cut-through flips well I have

00:05:03,330 --> 00:05:07,770
now I have two undefined terms in this

00:05:05,760 --> 00:05:09,840
slide I apologize for that a flip is

00:05:07,770 --> 00:05:11,970
where you have one frame buffer and

00:05:09,840 --> 00:05:13,530
another frame buffer and you just want

00:05:11,970 --> 00:05:15,420
to tell the video hardware hey I know

00:05:13,530 --> 00:05:16,350
you're HAP happy over here scanning out

00:05:15,420 --> 00:05:18,540
from this frame buffer

00:05:16,350 --> 00:05:20,910
please let me change a single 32-bit

00:05:18,540 --> 00:05:23,400
register value and chiyan scan out from

00:05:20,910 --> 00:05:25,380
this area instead you can imagine that's

00:05:23,400 --> 00:05:28,100
frightening ly efficient in though in

00:05:25,380 --> 00:05:30,120
that in terms of memory bandwidth and

00:05:28,100 --> 00:05:32,250
performance because all you have to do

00:05:30,120 --> 00:05:33,960
is update one 32-bit register value and

00:05:32,250 --> 00:05:35,160
now you're scanning out from a new frame

00:05:33,960 --> 00:05:37,770
so you draw you new frame and a new

00:05:35,160 --> 00:05:39,600
frame buffer a BAM the problem is is

00:05:37,770 --> 00:05:41,100
that most of the while the current

00:05:39,600 --> 00:05:43,500
implementation especially the Intel

00:05:41,100 --> 00:05:46,560
driver is when you ask for a flip the

00:05:43,500 --> 00:05:49,770
flip happens at the next vertical blank

00:05:46,560 --> 00:05:51,810
interval not within the current one and

00:05:49,770 --> 00:05:54,450
the problem there is that games are

00:05:51,810 --> 00:05:56,790
desperately trying to get get to barely

00:05:54,450 --> 00:05:58,650
60 frames per second and sometimes they

00:05:56,790 --> 00:06:00,540
go over a little bit by you know half a

00:05:58,650 --> 00:06:03,900
millisecond or so that's well within the

00:06:00,540 --> 00:06:05,640
vertical retrace interval but if you ask

00:06:03,900 --> 00:06:08,370
for a flip a half a millisecond too late

00:06:05,640 --> 00:06:10,380
sorry you get to wait and that's the

00:06:08,370 --> 00:06:12,419
other kind of video damage that we don't

00:06:10,380 --> 00:06:14,580
want called judder where your refresh

00:06:12,419 --> 00:06:16,320
rate is stuttering I don't know if you

00:06:14,580 --> 00:06:19,200
anybody know what judder is and see it

00:06:16,320 --> 00:06:21,090
on the screen all the time yeah not so

00:06:19,200 --> 00:06:23,729
many huh that's where things seem to

00:06:21,090 --> 00:06:25,979
jerk across the screen they're complete

00:06:23,729 --> 00:06:27,990
frames but things are jerky and that's

00:06:25,979 --> 00:06:29,220
that in my mind is just as bad as

00:06:27,990 --> 00:06:32,010
tearing and so we want to give it a

00:06:29,220 --> 00:06:34,380
plication x' the option to use to update

00:06:32,010 --> 00:06:35,970
this the which frame they're scanning

00:06:34,380 --> 00:06:38,120
out from in the middle of the frame

00:06:35,970 --> 00:06:39,960
usually within the top couple of

00:06:38,120 --> 00:06:42,210
half-dozen scan lines

00:06:39,960 --> 00:06:43,710
so so that they can get a little bit of

00:06:42,210 --> 00:06:45,900
tearing at the top of the screen instead

00:06:43,710 --> 00:06:47,819
of a jerky presentation it's a choice we

00:06:45,900 --> 00:06:49,500
want to implement this the other thing

00:06:47,819 --> 00:06:51,210
we want to do for the the other kernel

00:06:49,500 --> 00:06:53,009
API we're gonna do is something for

00:06:51,210 --> 00:06:56,190
something I'm calling page level

00:06:53,009 --> 00:06:58,830
switching or exchanging and I'll

00:06:56,190 --> 00:07:00,539
describe that going on these both of

00:06:58,830 --> 00:07:04,139
those kernel api's have been implemented

00:07:00,539 --> 00:07:05,910
and the codes available the final thing

00:07:04,139 --> 00:07:08,849
we need for dri 2000 it's a bunch of new

00:07:05,910 --> 00:07:11,789
xev extensions we need to be able to

00:07:08,849 --> 00:07:13,440
pass FDS because we're not gonna be I'll

00:07:11,789 --> 00:07:15,150
talk more about that with the Araya and

00:07:13,440 --> 00:07:18,330
they were passing we're creating these

00:07:15,150 --> 00:07:21,270
new special xge event queues so that the

00:07:18,330 --> 00:07:23,520
the GL at the GL library can capture

00:07:21,270 --> 00:07:25,259
events and not have them presented to

00:07:23,520 --> 00:07:26,970
application because that was actually

00:07:25,259 --> 00:07:29,580
turned out to be a big problem with DRI

00:07:26,970 --> 00:07:32,430
2 as we'll see in a minute I wanted to

00:07:29,580 --> 00:07:33,509
go over a short history of DRI one of

00:07:32,430 --> 00:07:36,690
the one of the important things about

00:07:33,509 --> 00:07:41,099
DRI the original DRI was that it was

00:07:36,690 --> 00:07:43,710
implemented back a long time ago I would

00:07:41,099 --> 00:07:44,340
love to make this work here for Mia can

00:07:43,710 --> 00:07:48,870
I just do that

00:07:44,340 --> 00:07:50,669
no I can't there we go

00:07:48,870 --> 00:07:54,870
ok I couldn't read it on the screen I

00:07:50,669 --> 00:07:56,250
apologize dear i1 was the original

00:07:54,870 --> 00:07:58,050
direct running infrastructure that was

00:07:56,250 --> 00:07:59,759
back when our video cards had enough

00:07:58,050 --> 00:08:02,669
memory to show you what was being

00:07:59,759 --> 00:08:04,710
scanned out now and to have one more

00:08:02,669 --> 00:08:07,349
buffer for the next frame and that was

00:08:04,710 --> 00:08:10,340
it so each application had to share this

00:08:07,349 --> 00:08:13,919
one big back buffer so DRI 1 was a

00:08:10,340 --> 00:08:15,930
horrible Cluj that shared this single

00:08:13,919 --> 00:08:18,990
back buffer among all applications and

00:08:15,930 --> 00:08:20,669
it it was awesome at the time that it

00:08:18,990 --> 00:08:22,949
worked at all it was like the dancing

00:08:20,669 --> 00:08:25,320
bear of direct rendering infrastructure

00:08:22,949 --> 00:08:29,310
which is to say it was amazing that the

00:08:25,320 --> 00:08:31,229
bear danced at all so the awesome part

00:08:29,310 --> 00:08:32,729
about DRI 1 is it when you ran a DRI one

00:08:31,229 --> 00:08:34,140
application you put a breakpoint in your

00:08:32,729 --> 00:08:35,820
application with gdb while you were

00:08:34,140 --> 00:08:38,729
debugging under the X server hi you hit

00:08:35,820 --> 00:08:40,289
a breakpoint and your DRI a plot to the

00:08:38,729 --> 00:08:43,560
X server cuz it's rendering right now

00:08:40,289 --> 00:08:45,810
I'm sorry you can't type at gdb it was

00:08:43,560 --> 00:08:48,100
kind of exciting

00:08:45,810 --> 00:08:49,360
another great part about deer I want is

00:08:48,100 --> 00:08:51,010
that it only allowed for temporary

00:08:49,360 --> 00:08:53,410
allocations and graphics memories so if

00:08:51,010 --> 00:08:55,660
you once you you would lock the GP you

00:08:53,410 --> 00:08:57,190
do a bunch of rendering including

00:08:55,660 --> 00:08:58,660
uploading stirrers blah blah blah

00:08:57,190 --> 00:09:00,670
putting stuff in temporary memory and

00:08:58,660 --> 00:09:03,310
then you unlock the GPU and all of your

00:09:00,670 --> 00:09:04,720
memory would go poof it all be gone so

00:09:03,310 --> 00:09:07,510
you have to upload your textures the

00:09:04,720 --> 00:09:09,370
next frame yay yeah they were

00:09:07,510 --> 00:09:11,680
performance issues that DRI to fixed a

00:09:09,370 --> 00:09:13,480
ton of stuff this is certainly knows

00:09:11,680 --> 00:09:15,460
that the fact that we need to do with

00:09:13,480 --> 00:09:18,160
this again is no slight at DRI to it

00:09:15,460 --> 00:09:22,410
made a huge amount of stuff possible got

00:09:18,160 --> 00:09:26,050
us from GL 1.4 2 GL 2.0 a huge advance

00:09:22,410 --> 00:09:28,870
it did it gave us per window instead of

00:09:26,050 --> 00:09:32,740
a global back buffer stencil buffer his

00:09:28,870 --> 00:09:34,210
depth buffers the problem with there the

00:09:32,740 --> 00:09:35,860
problem with the RI 2 was that we

00:09:34,210 --> 00:09:38,280
decided that we wanted to remain

00:09:35,860 --> 00:09:41,080
compatible with GL x and GL x has this

00:09:38,280 --> 00:09:43,930
horrible semantics that if multiple

00:09:41,080 --> 00:09:47,140
applications do GL to the same window

00:09:43,930 --> 00:09:50,080
they share all of their off-screen

00:09:47,140 --> 00:09:51,640
buffers so the back buffer is shared and

00:09:50,080 --> 00:09:55,540
the depth buffer is shared and the

00:09:51,640 --> 00:09:57,880
stencil buffer is shared but the GL x

00:09:55,540 --> 00:09:59,050
protocol doesn't define any semantics

00:09:57,880 --> 00:10:02,800
for how you're going to synchronize

00:09:59,050 --> 00:10:04,810
between these buffers and we did this in

00:10:02,800 --> 00:10:06,820
DRI 2 by having the X server allocate

00:10:04,810 --> 00:10:08,620
all these awesome buffers the problem

00:10:06,820 --> 00:10:10,390
with that is the X server didn't about

00:10:08,620 --> 00:10:12,520
these buffers stencil buffer the X

00:10:10,390 --> 00:10:14,200
service not using this so we invented

00:10:12,520 --> 00:10:15,790
these horrible naming scheme for these

00:10:14,200 --> 00:10:17,530
objects as we didn't want to create some

00:10:15,790 --> 00:10:19,930
weird X naming scheme for them when X

00:10:17,530 --> 00:10:21,520
couldn't use them and the other thing in

00:10:19,930 --> 00:10:23,380
DRI 2 was that objects were passed

00:10:21,520 --> 00:10:26,800
between the server and the client with

00:10:23,380 --> 00:10:29,110
these global unique integers called gem

00:10:26,800 --> 00:10:31,180
handles and these were actually global

00:10:29,110 --> 00:10:32,830
to the entire system so anybody on the

00:10:31,180 --> 00:10:34,870
computer who could open up your graphics

00:10:32,830 --> 00:10:36,430
device could find these fine little

00:10:34,870 --> 00:10:39,150
handles connect to these objects and

00:10:36,430 --> 00:10:42,010
suck your pictures off it was awesome

00:10:39,150 --> 00:10:44,230
kind of lacking a little security

00:10:42,010 --> 00:10:45,520
there's also lifetime issues because

00:10:44,230 --> 00:10:47,860
these were just handles he weren't

00:10:45,520 --> 00:10:50,200
references so if you took this number

00:10:47,860 --> 00:10:51,670
and gave it to your neighbor the only

00:10:50,200 --> 00:10:53,020
the only way that your neighbor would

00:10:51,670 --> 00:10:55,660
actually make sure that that object

00:10:53,020 --> 00:10:57,700
existed was to try to open it if that

00:10:55,660 --> 00:10:59,110
object had been freed and another one

00:10:57,700 --> 00:11:01,540
allocated in the meantime

00:10:59,110 --> 00:11:03,280
which would happen a lot your neighbor

00:11:01,540 --> 00:11:05,590
would get a different object maybe

00:11:03,280 --> 00:11:11,290
somebody else's object it was kind of

00:11:05,590 --> 00:11:13,600
exciting okay so in DRI 3 we're giving

00:11:11,290 --> 00:11:15,730
up on our GLX compatibility we could

00:11:13,600 --> 00:11:18,370
actually give it up on an incrementally

00:11:15,730 --> 00:11:20,980
during the life on a dri to as graphic

00:11:18,370 --> 00:11:22,990
cards changed it turned out oh I'm sorry

00:11:20,980 --> 00:11:24,580
we really can't do shared stencil

00:11:22,990 --> 00:11:27,610
buffers and share depth buffers because

00:11:24,580 --> 00:11:29,560
we have things like high Z Wan Heisey

00:11:27,610 --> 00:11:31,030
you have to do depth resolves if you've

00:11:29,560 --> 00:11:32,890
rendered to your depth buffer and you

00:11:31,030 --> 00:11:35,050
want to suck the bits out you have to do

00:11:32,890 --> 00:11:36,460
a depth resolve I'm sorry we have no way

00:11:35,050 --> 00:11:38,500
of communicating across multiple

00:11:36,460 --> 00:11:40,870
applications whether the depth buffer

00:11:38,500 --> 00:11:43,330
has been resolved or not so we gave up

00:11:40,870 --> 00:11:44,920
and the Intel driver had been allocated

00:11:43,330 --> 00:11:47,380
private buffers for everything except

00:11:44,920 --> 00:11:49,780
the back buffer for a long time so we

00:11:47,380 --> 00:11:52,630
didn't have the reality of GLX anyhow so

00:11:49,780 --> 00:11:55,800
with DRI 3 we said fine we give up no

00:11:52,630 --> 00:11:57,910
more no more shared buffers for you

00:11:55,800 --> 00:11:59,770
everything is allocated managed by the

00:11:57,910 --> 00:12:02,200
client now so that the server is not

00:11:59,770 --> 00:12:03,640
involved it means that the client owns

00:12:02,200 --> 00:12:05,500
their own destiny and they get to tell

00:12:03,640 --> 00:12:07,570
when when buffers get reused which is

00:12:05,500 --> 00:12:09,100
kind of nice and now instead of passing

00:12:07,570 --> 00:12:11,590
through these global handles we use the

00:12:09,100 --> 00:12:13,780
DMA buff the fact that DMA buff can wrap

00:12:11,590 --> 00:12:15,430
a gem object in a file descriptor and

00:12:13,780 --> 00:12:17,740
then we pass the file descriptor through

00:12:15,430 --> 00:12:19,030
the through the local socket and the

00:12:17,740 --> 00:12:20,680
other side picks up the file descriptor

00:12:19,030 --> 00:12:22,840
and opens the object it's awesome

00:12:20,680 --> 00:12:24,430
because hot that file descriptors

00:12:22,840 --> 00:12:26,080
actually a reference to a real object

00:12:24,430 --> 00:12:28,000
and when it pops out at the other side

00:12:26,080 --> 00:12:30,400
you know you have actually the same

00:12:28,000 --> 00:12:32,290
object you can also nicely close the

00:12:30,400 --> 00:12:33,880
object and the fan the socket care is

00:12:32,290 --> 00:12:36,160
the reference along and so you don't

00:12:33,880 --> 00:12:37,600
have any lifetime issues it's kind of ok

00:12:36,160 --> 00:12:39,820
so what are we trying to fix with dri to

00:12:37,600 --> 00:12:41,470
the bit one of the big problems we had

00:12:39,820 --> 00:12:43,180
with DRI 2 is what happens when the

00:12:41,470 --> 00:12:45,070
window is resized well when the window

00:12:43,180 --> 00:12:47,500
is resized these objects allocated by

00:12:45,070 --> 00:12:49,120
the X server also get resized of course

00:12:47,500 --> 00:12:51,460
right your back buffer has to be resized

00:12:49,120 --> 00:12:53,050
when you windows resized well how does

00:12:51,460 --> 00:12:53,410
the application find out that this has

00:12:53,050 --> 00:12:55,930
happened

00:12:53,410 --> 00:12:58,030
it's a lovely event and then event

00:12:55,930 --> 00:12:59,380
occurs happens arrived excuse me the

00:12:58,030 --> 00:13:01,150
event is delivered immediately but it

00:12:59,380 --> 00:13:03,880
arrives sometime afterwards and the

00:13:01,150 --> 00:13:05,950
application is done some rendering after

00:13:03,880 --> 00:13:07,630
the you know after the window was

00:13:05,950 --> 00:13:10,240
resized but before it received the

00:13:07,630 --> 00:13:11,980
resize event so there's some set some

00:13:10,240 --> 00:13:12,670
subset of the rendering location is done

00:13:11,980 --> 00:13:14,530
that's

00:13:12,670 --> 00:13:16,870
off to a buffer that will never be used

00:13:14,530 --> 00:13:20,890
and the application has no way of

00:13:16,870 --> 00:13:22,060
knowing what that rendering was the

00:13:20,890 --> 00:13:23,680
other the other thing of course he

00:13:22,060 --> 00:13:25,960
talked about already was that the the

00:13:23,680 --> 00:13:27,880
stencil buffers and depth buffers were a

00:13:25,960 --> 00:13:28,870
disaster for X and so we just didn't

00:13:27,880 --> 00:13:31,150
want to have them at all

00:13:28,870 --> 00:13:32,800
the other exciting thing was until we

00:13:31,150 --> 00:13:34,240
decided to stop sharing a stencil and

00:13:32,800 --> 00:13:36,640
death buffers we actually had to update

00:13:34,240 --> 00:13:39,250
the X server every time our every time

00:13:36,640 --> 00:13:40,990
our GL driver needed a new buffer type

00:13:39,250 --> 00:13:43,660
which was awesome because you have to

00:13:40,990 --> 00:13:45,880
deploy a new 2d driver a new DRI 2

00:13:43,660 --> 00:13:48,370
extension a new X server a new geo

00:13:45,880 --> 00:13:51,060
library and a new GL driver just to get

00:13:48,370 --> 00:13:54,460
some new GL feature probably not optimal

00:13:51,060 --> 00:13:56,320
more issues with DRI - there was no

00:13:54,460 --> 00:13:57,910
integration with a composite extension

00:13:56,320 --> 00:14:00,370
at all when your application asked to

00:13:57,910 --> 00:14:01,930
have stuff swapped to the screen if your

00:14:00,370 --> 00:14:03,610
window was redirected and that window

00:14:01,930 --> 00:14:06,610
was off screen then the swap would

00:14:03,610 --> 00:14:08,470
happen sometime the compositing manager

00:14:06,610 --> 00:14:10,090
would get told about that Oh sometime

00:14:08,470 --> 00:14:11,950
and the compositing manager would put it

00:14:10,090 --> 00:14:14,260
on the real screen sometime later and

00:14:11,950 --> 00:14:16,390
the application would have no idea when

00:14:14,260 --> 00:14:18,580
the presentation occurred on the screen

00:14:16,390 --> 00:14:20,320
and there was no synchronization between

00:14:18,580 --> 00:14:22,480
the the compositing manager and

00:14:20,320 --> 00:14:25,480
application updates it was a disaster

00:14:22,480 --> 00:14:27,340
and a lot of extra copies we couldn't

00:14:25,480 --> 00:14:29,730
create an XE be binding for DRI -

00:14:27,340 --> 00:14:32,080
because of the way the because of those

00:14:29,730 --> 00:14:34,180
remember those events for resizing the

00:14:32,080 --> 00:14:36,910
buffer well x cb had no method for

00:14:34,180 --> 00:14:39,010
handing those events from the bowels of

00:14:36,910 --> 00:14:40,540
the x cb library to the bowels of the

00:14:39,010 --> 00:14:42,400
Mason library without having it pass

00:14:40,540 --> 00:14:45,160
through the application which really

00:14:42,400 --> 00:14:46,630
couldn't understand them at all that's

00:14:45,160 --> 00:14:48,010
kind of a technical thing but it kind of

00:14:46,630 --> 00:14:49,810
it turned out to be a problem because a

00:14:48,010 --> 00:14:52,060
lot of people wanted to switch to x cb

00:14:49,810 --> 00:14:54,670
but you couldn't with mesa

00:14:52,060 --> 00:14:55,960
so our Mesa implementation was stuck of

00:14:54,670 --> 00:14:57,940
course I talked about the fact that I

00:14:55,960 --> 00:15:00,490
wanted to add synchronization video

00:14:57,940 --> 00:15:02,920
blank synchronized 2d applications

00:15:00,490 --> 00:15:04,960
support GL apps are the only things that

00:15:02,920 --> 00:15:06,310
got that with DRI - the other thing is

00:15:04,960 --> 00:15:09,670
we were missing a bunch of Explorer

00:15:06,310 --> 00:15:11,500
important extensions for for buffer

00:15:09,670 --> 00:15:14,200
management and synchronization that DRI

00:15:11,500 --> 00:15:16,930
too couldn't support I don't think I'm

00:15:14,200 --> 00:15:19,240
gonna describe those here okay so the

00:15:16,930 --> 00:15:21,490
DRI 3000 architectures I said consists

00:15:19,240 --> 00:15:24,760
of two extensions the DRI 3 extension it

00:15:21,490 --> 00:15:26,470
does three things it provides access to

00:15:24,760 --> 00:15:28,930
the DRM device right

00:15:26,470 --> 00:15:31,210
the only the only process in the system

00:15:28,930 --> 00:15:34,060
that can open the DRM device and prepare

00:15:31,210 --> 00:15:35,710
it for rendering is X server we're

00:15:34,060 --> 00:15:38,290
looking at fixing that in the kernel

00:15:35,710 --> 00:15:39,820
with the implementation of render nodes

00:15:38,290 --> 00:15:42,100
but right now the X server is the only

00:15:39,820 --> 00:15:43,780
person who knows which dri device you

00:15:42,100 --> 00:15:47,020
want to open and how to get it ready for

00:15:43,780 --> 00:15:50,380
rendering and so the DRI 3 extension ad

00:15:47,020 --> 00:15:52,600
includes that then there's also the the

00:15:50,380 --> 00:15:54,940
sharing of these DRM pixel buffers these

00:15:52,600 --> 00:15:56,200
these video driver allocated pixel

00:15:54,940 --> 00:15:59,110
buffers between your direct rendering

00:15:56,200 --> 00:16:00,700
client and the server and the other

00:15:59,110 --> 00:16:03,070
thing that I added and I'm not sure I

00:16:00,700 --> 00:16:04,630
need this but it was fun to implement

00:16:03,070 --> 00:16:05,860
and maybe it will be useful I'm

00:16:04,630 --> 00:16:07,930
certainly using it right now I don't

00:16:05,860 --> 00:16:10,510
know if it's the right semantics was to

00:16:07,930 --> 00:16:12,130
be able to share a few texts between the

00:16:10,510 --> 00:16:14,290
X server and the application so that

00:16:12,130 --> 00:16:16,150
when the X server was done using a

00:16:14,290 --> 00:16:18,550
buffer it gets seven signal a signal

00:16:16,150 --> 00:16:20,740
this foo text semaphore and the client

00:16:18,550 --> 00:16:22,210
can wait for that it turns out that I'm

00:16:20,740 --> 00:16:25,120
not sure I want to use that mechanism

00:16:22,210 --> 00:16:27,310
because the foo Texas are you get to

00:16:25,120 --> 00:16:30,400
wait for a single foo text you can't

00:16:27,310 --> 00:16:32,530
wait for any of n foo Texas to fire so

00:16:30,400 --> 00:16:35,200
if I have three buffers that I might use

00:16:32,530 --> 00:16:37,300
any of I really don't care which one is

00:16:35,200 --> 00:16:41,220
idle I just need one of them to be idle

00:16:37,300 --> 00:16:43,780
so right now the the the library is

00:16:41,220 --> 00:16:46,450
assuming that the oldest one will become

00:16:43,780 --> 00:16:48,010
idle will become idle first and so it

00:16:46,450 --> 00:16:50,770
says if there aren't any idle buffers

00:16:48,010 --> 00:16:53,770
let me wait on the oldest one it doesn't

00:16:50,770 --> 00:16:55,630
always work so I don't know what I'm

00:16:53,770 --> 00:16:57,640
gonna do about that yet the present

00:16:55,630 --> 00:17:00,640
extension is the other half it's gonna

00:16:57,640 --> 00:17:02,800
copy a chunk of memory from a pics map

00:17:00,640 --> 00:17:04,450
to the screen or maybe take a pics map

00:17:02,800 --> 00:17:07,090
and make it the new scan out buffer if

00:17:04,450 --> 00:17:09,280
it's the right size it'll synchronize

00:17:07,090 --> 00:17:11,230
that activity to V blank and then it

00:17:09,280 --> 00:17:14,290
delivers events when the presentation

00:17:11,230 --> 00:17:16,510
occurs here's the entire DRI 3 extension

00:17:14,290 --> 00:17:19,060
it's yeah it's probably a little bit too

00:17:16,510 --> 00:17:21,070
small if I apologize for that this for

00:17:19,060 --> 00:17:23,680
requests you could open the DRM device

00:17:21,070 --> 00:17:25,150
and the opens the DRM device prepares it

00:17:23,680 --> 00:17:26,470
for rendering and passes a file

00:17:25,150 --> 00:17:29,380
descriptor back to the client for that

00:17:26,470 --> 00:17:31,020
device this is in contrast to the DRI 2

00:17:29,380 --> 00:17:34,060
method where the well the application

00:17:31,020 --> 00:17:36,640
opened the DRM device passed a magic

00:17:34,060 --> 00:17:38,290
cookie to the X server the X server the

00:17:36,640 --> 00:17:39,700
X server blessed that fought that

00:17:38,290 --> 00:17:40,179
blessed that client to be able to do

00:17:39,700 --> 00:17:42,009
stuff with

00:17:40,179 --> 00:17:44,409
that that a magic cookie was passed back

00:17:42,009 --> 00:17:45,639
and then the client would pass a magic

00:17:44,409 --> 00:17:49,059
cookie into the card all I'd be able to

00:17:45,639 --> 00:17:50,289
use this file descriptor DRI to is that

00:17:49,059 --> 00:17:52,570
was before we had file descriptor

00:17:50,289 --> 00:17:54,610
passing it was the only way to do it

00:17:52,570 --> 00:17:57,730
pixmap from buffer that's where i have a

00:17:54,610 --> 00:17:59,590
gem buffer or any other kind of kernel

00:17:57,730 --> 00:18:01,539
buffer that I can the DMA buff handle

00:17:59,590 --> 00:18:04,389
and I passed the file descriptor over

00:18:01,539 --> 00:18:06,100
the over the X connection and a Pixum

00:18:04,389 --> 00:18:08,559
app is created in the X Server not can

00:18:06,100 --> 00:18:10,149
use the pics map however I like and then

00:18:08,559 --> 00:18:11,889
the converse operation where I have a

00:18:10,149 --> 00:18:13,929
pics map and I want a buffer handle the

00:18:11,889 --> 00:18:15,820
file descriptor comes back and I can

00:18:13,929 --> 00:18:17,649
talk to talk to it through the kernel

00:18:15,820 --> 00:18:20,019
and then the other thing I have is this

00:18:17,649 --> 00:18:22,419
ability to create a a fence object or a

00:18:20,019 --> 00:18:26,740
Foo Tech's from a file descriptor I

00:18:22,419 --> 00:18:29,710
created allocate a page in in shared

00:18:26,740 --> 00:18:31,240
memory filesystem I with a file

00:18:29,710 --> 00:18:32,649
descriptor I passed that file descriptor

00:18:31,240 --> 00:18:34,600
to the server now I have a shared page

00:18:32,649 --> 00:18:37,299
and I use a few texts and the first to

00:18:34,600 --> 00:18:40,389
that page I don't think that's what I

00:18:37,299 --> 00:18:42,159
want but that was what I implemented the

00:18:40,389 --> 00:18:44,529
presenting extension has a couple of

00:18:42,159 --> 00:18:46,779
more actually it has fewer requests it

00:18:44,529 --> 00:18:48,249
only has three requests are the top

00:18:46,779 --> 00:18:50,409
three of these things a request present

00:18:48,249 --> 00:18:53,440
region which takes an area of a pics map

00:18:50,409 --> 00:18:55,869
and puts it into a window the present

00:18:53,440 --> 00:18:58,179
notify media sink counter this is

00:18:55,869 --> 00:19:01,720
required for a GL extension that asks

00:18:58,179 --> 00:19:03,279
what the current time is a present

00:19:01,720 --> 00:19:04,840
select input present has a bunch of

00:19:03,279 --> 00:19:06,009
events you need to be able to select for

00:19:04,840 --> 00:19:07,419
which events you want and then it has a

00:19:06,009 --> 00:19:09,879
couple of events present complete

00:19:07,419 --> 00:19:11,799
configure notify and present complete

00:19:09,879 --> 00:19:13,659
notify so the configure event happens

00:19:11,799 --> 00:19:15,519
anytime your window is resized so you

00:19:13,659 --> 00:19:17,740
get this configure event you got an old

00:19:15,519 --> 00:19:18,789
buffer well now what you can do with the

00:19:17,740 --> 00:19:20,320
old buffer is when you get this

00:19:18,789 --> 00:19:22,029
configure event you can allocate a new

00:19:20,320 --> 00:19:23,740
buffer and you could copy the events

00:19:22,029 --> 00:19:25,779
from the old buffer to the new buffer so

00:19:23,740 --> 00:19:28,749
the client is responsible for managing

00:19:25,779 --> 00:19:30,789
his own buffer he can do it synchronize

00:19:28,749 --> 00:19:32,499
to his own GL operations that he can do

00:19:30,789 --> 00:19:34,389
at an appropriate time that way you

00:19:32,499 --> 00:19:36,190
don't lose any rendering now of course

00:19:34,389 --> 00:19:39,159
the application is almost certainly

00:19:36,190 --> 00:19:40,600
looking for regular X configure notify

00:19:39,159 --> 00:19:42,970
events to find out when his windows been

00:19:40,600 --> 00:19:44,649
resized the requirement here is that the

00:19:42,970 --> 00:19:47,259
present extension learn about the

00:19:44,649 --> 00:19:48,609
configure before the application so that

00:19:47,259 --> 00:19:52,210
if the application does drawing at the

00:19:48,609 --> 00:19:53,820
new size the prett the GL x the GL code

00:19:52,210 --> 00:19:56,309
already knows about the news

00:19:53,820 --> 00:19:57,629
and can allocate a new buffer the other

00:19:56,309 --> 00:20:00,450
thing with the other event that we have

00:19:57,629 --> 00:20:01,950
is a percent complete notify which is

00:20:00,450 --> 00:20:04,619
set when the present operation has

00:20:01,950 --> 00:20:06,570
completed which is to say it sent when

00:20:04,619 --> 00:20:08,279
the first pixel of the screen on which

00:20:06,570 --> 00:20:12,090
you're presenting is being scanned out

00:20:08,279 --> 00:20:14,970
by the monitor nominally of course it's

00:20:12,090 --> 00:20:16,440
all approximate these days present

00:20:14,970 --> 00:20:20,039
region operation takes a bunch of

00:20:16,440 --> 00:20:22,499
parameters sufficient to construe put

00:20:20,039 --> 00:20:24,359
stuff up onto the screen the client can

00:20:22,499 --> 00:20:26,099
see little serial number so the client

00:20:24,359 --> 00:20:27,720
can tell that occurs in the in the

00:20:26,099 --> 00:20:29,970
complete notify so the client can tell

00:20:27,720 --> 00:20:32,190
which complete notify corresponds to

00:20:29,970 --> 00:20:33,960
which present region operation the other

00:20:32,190 --> 00:20:35,729
thing is it has a couple of regions it

00:20:33,960 --> 00:20:38,249
has a valid region that says this area

00:20:35,729 --> 00:20:39,659
of my pics map yeah you could put any of

00:20:38,249 --> 00:20:39,960
that on the screen that'd be fine with

00:20:39,659 --> 00:20:42,509
me

00:20:39,960 --> 00:20:44,489
and it also has an update area that says

00:20:42,509 --> 00:20:46,559
this part of my pics map you have to get

00:20:44,489 --> 00:20:48,450
that on the screen at least that much on

00:20:46,559 --> 00:20:50,759
the screen so the valid area and the

00:20:48,450 --> 00:20:53,070
update area in between that the server

00:20:50,759 --> 00:20:54,929
is free to put as much as it once or as

00:20:53,070 --> 00:20:57,359
little as it was so if the application

00:20:54,929 --> 00:20:59,820
just has a tiny little pixel map and

00:20:57,359 --> 00:21:01,619
only paints a tiny little area you can

00:20:59,820 --> 00:21:03,779
set the valid region and the great area

00:21:01,619 --> 00:21:05,519
to be the same and then the X server

00:21:03,779 --> 00:21:07,139
will only copy that little region and

00:21:05,519 --> 00:21:08,369
yet if you're doing real double

00:21:07,139 --> 00:21:10,379
buffering and you have your full

00:21:08,369 --> 00:21:11,940
contents of your window available you

00:21:10,379 --> 00:21:13,710
can set the valid region to the full

00:21:11,940 --> 00:21:15,539
window but if you only draw a single

00:21:13,710 --> 00:21:17,429
character you set your update to the

00:21:15,539 --> 00:21:19,830
single character and then the X server

00:21:17,429 --> 00:21:22,289
is free to do a flip operation to that

00:21:19,830 --> 00:21:24,269
new buffer if it wants or it can blitt

00:21:22,289 --> 00:21:26,759
just the tiny little area and that's how

00:21:24,269 --> 00:21:28,349
I implemented this there's an XY upset

00:21:26,759 --> 00:21:29,820
within the window if you want to take a

00:21:28,349 --> 00:21:32,460
pics map and just put a little piece of

00:21:29,820 --> 00:21:33,960
it on the screen then there's an idle

00:21:32,460 --> 00:21:35,759
fence those one of those sync fences I

00:21:33,960 --> 00:21:37,739
talked about when the pics map is no

00:21:35,759 --> 00:21:40,830
longer in use the idle fans get signal

00:21:37,739 --> 00:21:43,739
to go then there's this three parameter

00:21:40,830 --> 00:21:45,509
disaster for the GL extension that lets

00:21:43,739 --> 00:21:47,940
you tell what frame to present stuff at

00:21:45,509 --> 00:21:49,919
and then I'm gonna have a set of boolean

00:21:47,940 --> 00:21:53,220
operations that say whether you want to

00:21:49,919 --> 00:21:54,629
have the the caring option or whether

00:21:53,220 --> 00:21:56,460
you want to have whether you want to

00:21:54,629 --> 00:21:59,849
force it to copy in case the application

00:21:56,460 --> 00:22:01,710
isn't ready to deal with flips I'm gonna

00:21:59,849 --> 00:22:03,119
support avi blank synchronized sub

00:22:01,710 --> 00:22:05,129
window updates which is kind of cool you

00:22:03,119 --> 00:22:07,020
can paint a single character and say

00:22:05,129 --> 00:22:08,610
present just this character

00:22:07,020 --> 00:22:10,580
and that character will get blit it @v

00:22:08,610 --> 00:22:13,200
blank time so you won't get any caring

00:22:10,580 --> 00:22:16,230
of course I talked about flips for small

00:22:13,200 --> 00:22:18,960
updates yeah here's a here's an

00:22:16,230 --> 00:22:21,570
operation an optimization that % offers

00:22:18,960 --> 00:22:25,050
multiple operations can be queued for

00:22:21,570 --> 00:22:27,090
the same frame so if you have a bunch of

00:22:25,050 --> 00:22:29,280
updates to a single pixmap or updates to

00:22:27,090 --> 00:22:31,110
a disparate set of pics Maps you can

00:22:29,280 --> 00:22:33,030
queue all those for the same frame if

00:22:31,110 --> 00:22:35,250
they come from the same pics map and

00:22:33,030 --> 00:22:37,350
they have the same valid region you just

00:22:35,250 --> 00:22:41,370
throw the old one away and Union the to

00:22:37,350 --> 00:22:42,900
the two updates together if they have

00:22:41,370 --> 00:22:44,580
different pics Maps then you can see if

00:22:42,900 --> 00:22:46,710
the new one completely replaces the old

00:22:44,580 --> 00:22:48,870
one in which case you can throw the old

00:22:46,710 --> 00:22:51,000
one away so here I can queue multiple

00:22:48,870 --> 00:22:52,530
operations and I automatic get an

00:22:51,000 --> 00:22:54,690
optimization in the server where I can

00:22:52,530 --> 00:22:56,790
throw away old operations and just use

00:22:54,690 --> 00:22:57,030
the new one of course I don't throw it

00:22:56,790 --> 00:22:59,790
away

00:22:57,030 --> 00:23:01,440
entirely I save enough of it around so

00:22:59,790 --> 00:23:03,179
that I can deliver both complete notify

00:23:01,440 --> 00:23:05,940
events so the application can't tell

00:23:03,179 --> 00:23:08,760
that I was that I did any optimizations

00:23:05,940 --> 00:23:11,010
this optimization is good for a

00:23:08,760 --> 00:23:13,860
significant performance boost in GLX

00:23:11,010 --> 00:23:17,130
gears it takes my GLX gears and a tiny

00:23:13,860 --> 00:23:20,820
little window from 3400 FPS 250 400 fps

00:23:17,130 --> 00:23:24,330
and we all know that GLX gears is thank

00:23:20,820 --> 00:23:27,200
you it does show that there that it's

00:23:24,330 --> 00:23:30,690
effective though so that's kind of nice

00:23:27,200 --> 00:23:32,400
okay so presenting composite the

00:23:30,690 --> 00:23:33,840
composite extent hits it off-screen

00:23:32,400 --> 00:23:35,160
picks map for your window contents

00:23:33,840 --> 00:23:36,960
that's how you get all the wizzy effects

00:23:35,160 --> 00:23:38,370
now you can it have application that

00:23:36,960 --> 00:23:40,950
takes all these off-screen stuff and

00:23:38,370 --> 00:23:42,240
does fun stuff to it like putting fire

00:23:40,950 --> 00:23:48,240
when the window goes away

00:23:42,240 --> 00:23:52,380
thank you comp is with the old with DRI

00:23:48,240 --> 00:23:53,880
2 or Core X all of the window contents

00:23:52,380 --> 00:23:55,679
end up in this window off-screen window

00:23:53,880 --> 00:23:57,960
pics map and then compositing manager

00:23:55,679 --> 00:23:59,370
deals only with that pics map that means

00:23:57,960 --> 00:24:01,530
when you're doing double buffering the

00:23:59,370 --> 00:24:04,350
application has to copy his data from

00:24:01,530 --> 00:24:06,030
the off-screen image e to this pics map

00:24:04,350 --> 00:24:07,710
and then the compositing manager has to

00:24:06,030 --> 00:24:10,080
take it from there and put it on the

00:24:07,710 --> 00:24:11,610
screen that's a lot of copies because

00:24:10,080 --> 00:24:13,650
the compositing manager typically takes

00:24:11,610 --> 00:24:15,929
it from there oh and puts it in the back

00:24:13,650 --> 00:24:18,090
buffer and then puts it in the front

00:24:15,929 --> 00:24:20,570
buffer so oftentimes you get as many as

00:24:18,090 --> 00:24:20,570
three copies

00:24:20,790 --> 00:24:24,990
the other problem with that is that the

00:24:22,620 --> 00:24:26,820
copy' happens at some random time and

00:24:24,990 --> 00:24:30,270
the application has no idea when the

00:24:26,820 --> 00:24:31,380
presentation is actually occurred so

00:24:30,270 --> 00:24:33,510
what we want to do is we want to

00:24:31,380 --> 00:24:36,600
associate that present region operation

00:24:33,510 --> 00:24:38,660
with the with the correct screen count

00:24:36,600 --> 00:24:41,790
when it actually occurs on the screen

00:24:38,660 --> 00:24:42,930
and the way that we that oh the other

00:24:41,790 --> 00:24:46,710
thing we want to do is we want to reduce

00:24:42,930 --> 00:24:49,410
copies so what I'm going to do here is

00:24:46,710 --> 00:24:51,150
I'm going to redirect the present

00:24:49,410 --> 00:24:52,950
operation to the compositor so the

00:24:51,150 --> 00:24:54,450
present operation come the present

00:24:52,950 --> 00:24:56,760
region operation comes into the server

00:24:54,450 --> 00:24:58,650
and the server says oh that windows been

00:24:56,760 --> 00:25:00,420
redirected let me go tell the guy who's

00:24:58,650 --> 00:25:02,520
managing that Windows presentation that

00:25:00,420 --> 00:25:04,260
present occurred so it hands that all

00:25:02,520 --> 00:25:06,030
the data from the present operation off

00:25:04,260 --> 00:25:07,950
to the compositing manager and now the

00:25:06,030 --> 00:25:10,080
compositing manager can do whatever it

00:25:07,950 --> 00:25:11,610
wants with that data doesn't have to put

00:25:10,080 --> 00:25:14,270
it in the window pixmap it can put it

00:25:11,610 --> 00:25:17,850
right on the screen that takes one copy

00:25:14,270 --> 00:25:20,070
the other thing is it does it I extend

00:25:17,850 --> 00:25:22,230
the present region operation with a

00:25:20,070 --> 00:25:24,240
window and sequence list so that now

00:25:22,230 --> 00:25:26,160
when that present operation is done by

00:25:24,240 --> 00:25:28,710
the compositing manager to put the

00:25:26,160 --> 00:25:30,510
contents on the screen it packs on the

00:25:28,710 --> 00:25:32,700
original window ID and sequence number

00:25:30,510 --> 00:25:34,110
so that when that present completes it

00:25:32,700 --> 00:25:36,450
sends a complete no to fly to the

00:25:34,110 --> 00:25:38,400
compositing manager and it sends a

00:25:36,450 --> 00:25:40,740
complete notify off to the application

00:25:38,400 --> 00:25:42,300
so both of them learn that the contents

00:25:40,740 --> 00:25:45,240
are on the screen so the application

00:25:42,300 --> 00:25:46,860
learns when his image gets not to his

00:25:45,240 --> 00:25:48,990
window buffer which he doesn't care

00:25:46,860 --> 00:25:50,670
about but when he gets to the screen so

00:25:48,990 --> 00:25:52,830
now the application can be synchronized

00:25:50,670 --> 00:25:56,310
to the screen and the application can

00:25:52,830 --> 00:25:58,050
get framerate information for

00:25:56,310 --> 00:25:59,730
compositing full screen applications we

00:25:58,050 --> 00:26:01,650
desperately don't want to do any copies

00:25:59,730 --> 00:26:03,420
so in this case we're gonna redirect

00:26:01,650 --> 00:26:05,190
that pixmap off to the compositing

00:26:03,420 --> 00:26:08,160
manager the compositing manager is gonna

00:26:05,190 --> 00:26:10,080
say oh this covers the whole screen let

00:26:08,160 --> 00:26:13,230
me present that to the to the screen and

00:26:10,080 --> 00:26:14,970
the X server is gonna say oh it covers

00:26:13,230 --> 00:26:17,010
the whole screen let me do a page flip

00:26:14,970 --> 00:26:18,690
for that it's gonna flip it's gonna do a

00:26:17,010 --> 00:26:20,520
page flip and you're gonna not going to

00:26:18,690 --> 00:26:22,230
do any copies at all so for full screen

00:26:20,520 --> 00:26:24,720
applications you're gonna take another

00:26:22,230 --> 00:26:26,760
round-trip another couple of contexts

00:26:24,720 --> 00:26:29,100
which is the compositing manager but you

00:26:26,760 --> 00:26:30,990
will not copy the data and of course

00:26:29,100 --> 00:26:33,750
this happens per frame context switches

00:26:30,990 --> 00:26:34,590
are bad but not that bad and so I'm

00:26:33,750 --> 00:26:36,390
hoping that at least

00:26:34,590 --> 00:26:41,640
we'll be much better than the current

00:26:36,390 --> 00:26:43,440
situation I have a couple of redirection

00:26:41,640 --> 00:26:44,970
plans and this is still what I'm working

00:26:43,440 --> 00:26:47,610
out the reductive redirection stuff has

00:26:44,970 --> 00:26:49,830
not done as you'll see the easy thing to

00:26:47,610 --> 00:26:51,659
do is to just take the composite the

00:26:49,830 --> 00:26:54,179
present region request and send it to

00:26:51,659 --> 00:26:57,450
the compositor and say that's all I'm

00:26:54,179 --> 00:26:59,220
gonna do the compositor is then

00:26:57,450 --> 00:27:01,440
responsible for keeping the window picks

00:26:59,220 --> 00:27:03,830
map contents up-to-date so for instance

00:27:01,440 --> 00:27:06,090
if it wants to do a zoom of your

00:27:03,830 --> 00:27:08,039
applicants or control applications and

00:27:06,090 --> 00:27:09,390
little tiny versions on the screen it

00:27:08,039 --> 00:27:11,640
needs to make sure that the window

00:27:09,390 --> 00:27:13,110
contents and the window border are in

00:27:11,640 --> 00:27:15,630
the same object so it's gonna have to

00:27:13,110 --> 00:27:17,520
take the present region operation that

00:27:15,630 --> 00:27:19,980
it occurred before take that pics map

00:27:17,520 --> 00:27:21,419
and copy into the window pics map and

00:27:19,980 --> 00:27:22,919
then use the window pics map to paint on

00:27:21,419 --> 00:27:26,279
the screens the compositor would have a

00:27:22,919 --> 00:27:28,980
bunch of extra work that might not be

00:27:26,279 --> 00:27:30,990
ideal the other option is to get the

00:27:28,980 --> 00:27:33,990
applications to draw into a larger

00:27:30,990 --> 00:27:35,700
buffer Ahmet so the normal to normal

00:27:33,990 --> 00:27:37,440
GL application is going to allocate a

00:27:35,700 --> 00:27:39,480
buffer that's just the size of its

00:27:37,440 --> 00:27:40,980
window well if you had the application

00:27:39,480 --> 00:27:42,899
allocate a buffer that was a little bit

00:27:40,980 --> 00:27:47,130
bigger you could paint window manager

00:27:42,899 --> 00:27:50,480
frame around that and the way that you

00:27:47,130 --> 00:27:55,620
paint around that is you'd have the

00:27:50,480 --> 00:27:57,600
server the server actually damnit track

00:27:55,620 --> 00:28:00,480
damage to the to the real window pics

00:27:57,600 --> 00:28:03,270
map and copy the border the window

00:28:00,480 --> 00:28:05,070
manager contents into whatever fix map

00:28:03,270 --> 00:28:07,500
was being presented to you so you always

00:28:05,070 --> 00:28:10,649
have that window border in that in that

00:28:07,500 --> 00:28:11,640
pics map this is pretty easy to do with

00:28:10,649 --> 00:28:14,340
the server a little bit of damage

00:28:11,640 --> 00:28:17,190
tracking a little bleeding the hard part

00:28:14,340 --> 00:28:18,779
here is actually getting GL to deal with

00:28:17,190 --> 00:28:20,760
drawing to larger buffers but I haven't

00:28:18,779 --> 00:28:22,320
even started this work and I'm gonna do

00:28:20,760 --> 00:28:24,179
the other stuff first is to see what the

00:28:22,320 --> 00:28:26,789
performance is like so the tricky part

00:28:24,179 --> 00:28:27,990
here remember remember in DRI 1 we

00:28:26,789 --> 00:28:29,520
talked about the fact that all the

00:28:27,990 --> 00:28:30,600
applications shared a single giant

00:28:29,520 --> 00:28:32,880
off-screen buffer

00:28:30,600 --> 00:28:35,370
well applications knew how to draw at

00:28:32,880 --> 00:28:37,770
arbitrary offsets in that buffer so the

00:28:35,370 --> 00:28:39,450
Mesa used to have this fine ability to

00:28:37,770 --> 00:28:42,000
draw with it and with it a larger buffer

00:28:39,450 --> 00:28:44,399
a smaller window they deleted all that

00:28:42,000 --> 00:28:46,350
code thanks guys I'm gonna have to go

00:28:44,399 --> 00:28:49,280
recreate it all if I want to do this I

00:28:46,350 --> 00:28:49,280
think I probably do

00:28:49,920 --> 00:28:53,640
the other thing I want to be able to do

00:28:51,300 --> 00:28:55,890
with this particular optimization is

00:28:53,640 --> 00:28:57,660
reduce cur windowed swaps so if you have

00:28:55,890 --> 00:29:00,150
an application that's in a little window

00:28:57,660 --> 00:29:01,320
and it does a swap well right now the

00:29:00,150 --> 00:29:02,580
usual thing you're going to do is you're

00:29:01,320 --> 00:29:05,370
going to take the contents of that

00:29:02,580 --> 00:29:07,590
window and copy them to the scan out

00:29:05,370 --> 00:29:09,000
buffer right because you have just a sub

00:29:07,590 --> 00:29:11,970
part of the scan out buffer that's being

00:29:09,000 --> 00:29:13,650
updated oh what if that window was

00:29:11,970 --> 00:29:16,470
trying to do a buffer that was big

00:29:13,650 --> 00:29:19,020
enough and aligned correctly so that the

00:29:16,470 --> 00:29:21,090
pages that make up that window we're

00:29:19,020 --> 00:29:22,650
exactly aligned with the pages that make

00:29:21,090 --> 00:29:24,540
up the scan out buffer that covered the

00:29:22,650 --> 00:29:26,340
pixels where it wants to go and then I

00:29:24,540 --> 00:29:28,620
had this fun kernel API that just takes

00:29:26,340 --> 00:29:32,340
these two rectangular regions of pages

00:29:28,620 --> 00:29:34,440
and swaps them so I'm going to update

00:29:32,340 --> 00:29:36,870
the page table entries of the scan out

00:29:34,440 --> 00:29:39,540
buffer so that it gets the pages that

00:29:36,870 --> 00:29:41,130
the application just provided now the

00:29:39,540 --> 00:29:43,380
trick there of course is I have to fill

00:29:41,130 --> 00:29:45,120
in a bunch of data around the outside of

00:29:43,380 --> 00:29:46,500
that window to where the whether your

00:29:45,120 --> 00:29:48,930
window was padded out to the appropriate

00:29:46,500 --> 00:29:50,460
page Lineman but the benefit is a

00:29:48,930 --> 00:29:53,910
tremendous improvement in performance

00:29:50,460 --> 00:29:55,680
and again what I have to have here is I

00:29:53,910 --> 00:29:57,720
have to have that application able to

00:29:55,680 --> 00:29:59,430
paint within a sub buffer within a sub

00:29:57,720 --> 00:30:03,530
part of its buffer offset from the upper

00:29:59,430 --> 00:30:07,170
left-hand corner I presented to LCA last

00:30:03,530 --> 00:30:09,690
January some performance data showing a

00:30:07,170 --> 00:30:12,570
hack that I did to try and that hack was

00:30:09,690 --> 00:30:15,270
showing that I was getting about you

00:30:12,570 --> 00:30:18,300
know two thirds or so of the benefits of

00:30:15,270 --> 00:30:20,670
doing a regular full screen flip by

00:30:18,300 --> 00:30:22,980
doing this hack so it's it's

00:30:20,670 --> 00:30:26,010
dramatically less dramatically faster

00:30:22,980 --> 00:30:29,640
than doing the the pixel copy which and

00:30:26,010 --> 00:30:33,270
but slightly slower than doing a full

00:30:29,640 --> 00:30:34,860
screen swap it was a little surprising

00:30:33,270 --> 00:30:39,150
because often times when you end up

00:30:34,860 --> 00:30:40,950
doing page Pte whacking the Pte whacking

00:30:39,150 --> 00:30:42,690
is expensive enough that you don't get

00:30:40,950 --> 00:30:46,710
any benefit but I'm not actually

00:30:42,690 --> 00:30:48,750
whacking page tables I'm whack GTT page

00:30:46,710 --> 00:30:50,880
table entries and there's no cache

00:30:48,750 --> 00:30:53,700
flushing necessary there because it's a

00:30:50,880 --> 00:30:55,950
scan out buffer which is uncashed so the

00:30:53,700 --> 00:31:00,660
cost of doing the page table updates is

00:30:55,950 --> 00:31:02,250
cheap which is kind of surprising ok I

00:31:00,660 --> 00:31:03,750
wanted to talk about static

00:31:02,250 --> 00:31:06,900
the current status the DRI three

00:31:03,750 --> 00:31:08,730
extension is complete and working this

00:31:06,900 --> 00:31:10,950
is all being done with the DRI three

00:31:08,730 --> 00:31:14,190
extension I'll show you some demos the

00:31:10,950 --> 00:31:18,090
kernel patches for the rectangular page

00:31:14,190 --> 00:31:20,970
swapping have been have been posted the

00:31:18,090 --> 00:31:24,179
kernel patches for the cut through

00:31:20,970 --> 00:31:26,820
flipping have been have been posted and

00:31:24,179 --> 00:31:28,170
people have looked at them a bunch but

00:31:26,820 --> 00:31:31,440
Eric and I were discussing today and I'm

00:31:28,170 --> 00:31:34,290
going to throw that out do it again yeah

00:31:31,440 --> 00:31:38,130
it was wrong the present extension all

00:31:34,290 --> 00:31:40,410
working so my I opened my GL stuff all

00:31:38,130 --> 00:31:43,710
runs with that today it doesn't do any

00:31:40,410 --> 00:31:46,590
redirection so obviously the first thing

00:31:43,710 --> 00:31:48,540
I'm going to do coming up is do some do

00:31:46,590 --> 00:31:50,220
the redirection stuff and get it do the

00:31:48,540 --> 00:31:51,990
obvious simple stuff and try to get that

00:31:50,220 --> 00:31:53,730
to work and see what it looks like and

00:31:51,990 --> 00:31:55,760
the next thing I want to do after that

00:31:53,730 --> 00:31:59,100
is figure out what to do with video

00:31:55,760 --> 00:32:02,309
because this the video wants exactly the

00:31:59,100 --> 00:32:04,710
same stuff that that RGB data once it's

00:32:02,309 --> 00:32:06,960
just in y UV format so I need to

00:32:04,710 --> 00:32:09,720
probably extend the present extension to

00:32:06,960 --> 00:32:11,640
take y UV buffers and put them on the

00:32:09,720 --> 00:32:13,710
screen and then of course the X Server

00:32:11,640 --> 00:32:16,710
if it does if it does a y UV buffer it's

00:32:13,710 --> 00:32:18,360
free to use overlays so coming up with

00:32:16,710 --> 00:32:20,100
API as they describe how the overlays

00:32:18,360 --> 00:32:22,440
work and making that'll happen that's

00:32:20,100 --> 00:32:25,220
all future work I wanted to do some

00:32:22,440 --> 00:32:27,059
demos now because demos are always fun

00:32:25,220 --> 00:32:31,740
who wants demos

00:32:27,059 --> 00:32:34,559
everybody wants demos okay so the first

00:32:31,740 --> 00:32:40,110
thing I wanted to run here was a really

00:32:34,559 --> 00:32:43,410
cool demo which is just I think it's the

00:32:40,110 --> 00:32:46,490
other one is right over here right come

00:32:43,410 --> 00:32:51,360
on I want to be able to drag this we go

00:32:46,490 --> 00:32:53,100
here is a application which is just

00:32:51,360 --> 00:32:55,740
drawing it's an X application draw a

00:32:53,100 --> 00:32:57,809
rectangle sideways on the screen and you

00:32:55,740 --> 00:33:02,669
notice that it is not tearing it's

00:32:57,809 --> 00:33:04,169
amazing well yeah if you move it of

00:33:02,669 --> 00:33:05,610
course if you move the window now the

00:33:04,169 --> 00:33:06,929
window matter is getting involved in the

00:33:05,610 --> 00:33:08,370
window manager splitting it and so you

00:33:06,929 --> 00:33:09,450
get tearing that's what the tearing

00:33:08,370 --> 00:33:11,220
looks like when the window method is

00:33:09,450 --> 00:33:14,260
moving it stopped moving the window

00:33:11,220 --> 00:33:15,610
minute stop staring

00:33:14,260 --> 00:33:17,260
that's a simple one that's that's just

00:33:15,610 --> 00:33:19,960
doing blitz of course and it's a regular

00:33:17,260 --> 00:33:21,549
X application the other one I wanted the

00:33:19,960 --> 00:33:28,020
other application I wanted to run was

00:33:21,549 --> 00:33:28,020
our favorite application oops

00:33:28,290 --> 00:33:38,620
now I wouldn't run this application this

00:33:35,710 --> 00:33:39,820
application oh I wanted to run it in the

00:33:38,620 --> 00:33:41,590
tearing mode to let me write in the

00:33:39,820 --> 00:33:44,169
tearing mode first so you can see what

00:33:41,590 --> 00:33:48,460
the difference is I actually added an

00:33:44,169 --> 00:33:51,010
option to this application to to leave

00:33:48,460 --> 00:33:59,679
it in the old mode and you can see what

00:33:51,010 --> 00:34:09,250
it does here anybody like that mode yeah

00:33:59,679 --> 00:34:11,649
lots of tearing it is 1993 isn't it yeah

00:34:09,250 --> 00:34:12,520
and now the new application that doesn't

00:34:11,649 --> 00:34:15,100
care anymore

00:34:12,520 --> 00:34:17,260
well by the way this also has I posted

00:34:15,100 --> 00:34:19,470
recently a hack about how to use X input

00:34:17,260 --> 00:34:23,500
to to track the mouse without polling

00:34:19,470 --> 00:34:30,550
yeah this uses that now of course this

00:34:23,500 --> 00:34:32,859
is like most awesome Excise ever now so

00:34:30,550 --> 00:34:36,010
the hardest part about getting this to

00:34:32,859 --> 00:34:38,250
work was figuring out how to get X input

00:34:36,010 --> 00:34:43,679
two events delivered through the xt

00:34:38,250 --> 00:34:48,129
library oh my god that was disgusting

00:34:43,679 --> 00:34:49,540
yeah okay that was fun okay and of

00:34:48,129 --> 00:34:52,179
course you have to you have to show the

00:34:49,540 --> 00:34:56,740
GL application that it actually works

00:34:52,179 --> 00:35:01,430
the GL application

00:34:56,740 --> 00:35:02,869
is there are there any others as you can

00:35:01,430 --> 00:35:03,770
see it's not tearing it looks all pretty

00:35:02,869 --> 00:35:07,339
it's lovely

00:35:03,770 --> 00:35:08,480
yeah and the final thing I wanted to do

00:35:07,339 --> 00:35:11,660
what else said I want to try

00:35:08,480 --> 00:35:13,430
I'd just this afternoon I was hacking up

00:35:11,660 --> 00:35:20,569
Matassa tea I can show you mint Asti

00:35:13,430 --> 00:35:22,460
what the heck what yeah so this is code

00:35:20,569 --> 00:35:35,029
that I started writing at 4:00 this

00:35:22,460 --> 00:35:40,099
afternoon so it's a little fresh okay

00:35:35,029 --> 00:35:41,359
here we go so now I have let me just get

00:35:40,099 --> 00:35:43,220
my extra window over here now I have

00:35:41,359 --> 00:35:49,160
Matassa tea oh I need to get the I need

00:35:43,220 --> 00:35:52,309
to get the compositing turned on daddy

00:35:49,160 --> 00:35:54,289
can't editor and I'll turn on the

00:35:52,309 --> 00:35:56,690
compositing manager and my suspicion is

00:35:54,289 --> 00:35:59,270
my screens gonna go dark or at least

00:35:56,690 --> 00:36:01,520
just the the pixmap in the back and I'll

00:35:59,270 --> 00:36:07,630
have to reset my restart my ex window my

00:36:01,520 --> 00:36:11,720
server ah indeed yeah not so much

00:36:07,630 --> 00:36:14,260
yeah okay well as you can see it's still

00:36:11,720 --> 00:36:14,260
a work in progress

00:36:15,069 --> 00:36:22,670
yeah I mean I'll have to kill Matassa

00:36:18,980 --> 00:36:25,779
tea now those working in one monitor

00:36:22,670 --> 00:36:25,779
doesn't work in two monitors

00:36:32,570 --> 00:36:38,400
whoo okay well yeah not so much what I

00:36:36,990 --> 00:36:40,260
could show you what I can show you right

00:36:38,400 --> 00:36:42,210
now is what Matassa tea looks like this

00:36:40,260 --> 00:36:44,100
is a simple X based compositing manager

00:36:42,210 --> 00:36:47,940
so I want to show you what G Alex gears

00:36:44,100 --> 00:36:50,850
looks like with this with compositing

00:36:47,940 --> 00:36:52,080
turned on in this environment here we

00:36:50,850 --> 00:36:56,990
have GLX gears running with a

00:36:52,080 --> 00:36:59,310
compositing manager and oh come on

00:36:56,990 --> 00:37:01,950
yeah well that's about how that's about

00:36:59,310 --> 00:37:05,640
how a compositing in DRI and compositing

00:37:01,950 --> 00:37:10,980
works before we have before we have a

00:37:05,640 --> 00:37:12,900
DRI 3 so broken demos it's the multi

00:37:10,980 --> 00:37:15,540
monitor situation of course multi

00:37:12,900 --> 00:37:17,670
monitor is always break ok we have about

00:37:15,540 --> 00:37:21,470
10 minutes for 8 minutes for questions

00:37:17,670 --> 00:37:21,470
and then it'll be time for dinner

00:37:32,660 --> 00:37:41,520
slices come to exist the 128 by 8 pixel

00:37:38,010 --> 00:37:43,050
slices do what how where they come from

00:37:41,520 --> 00:37:48,180
well this size Oh from where that's

00:37:43,050 --> 00:37:50,130
right complete lines yeah okay so to

00:37:48,180 --> 00:37:51,560
make graphics go fast we don't draw

00:37:50,130 --> 00:37:54,330
linearly in memory anymore

00:37:51,560 --> 00:37:56,400
we actually tile the screen so that when

00:37:54,330 --> 00:37:57,840
you draw vertically through a through a

00:37:56,400 --> 00:37:59,820
section of the screen you hit the same

00:37:57,840 --> 00:38:01,770
page so you don't you don't just

00:37:59,820 --> 00:38:04,350
completely destroy your your PT II cache

00:38:01,770 --> 00:38:07,920
can out buffer is literally arranged in

00:38:04,350 --> 00:38:09,540
these tiles let's see yep otherwise

00:38:07,920 --> 00:38:13,100
you'd be replacing whole scan lines and

00:38:09,540 --> 00:38:13,100
that would work too just less efficient

00:38:28,649 --> 00:38:39,309
if you've talked about compositing so I

00:38:34,539 --> 00:38:42,459
assume also if designed especially the

00:38:39,309 --> 00:38:45,789
present extension also with ex Wayland

00:38:42,459 --> 00:38:47,919
in mind have you done any proof of

00:38:45,789 --> 00:38:49,689
concept work for that no I'm not working

00:38:47,919 --> 00:38:50,829
on Waylon at the present time I think

00:38:49,689 --> 00:38:52,779
it'll probably work it'll probably help

00:38:50,829 --> 00:39:00,759
X whale in a bit but that's not my core

00:38:52,779 --> 00:39:02,229
interest right now okay any more

00:39:00,759 --> 00:39:04,919
questions this evening or a separate

00:39:02,229 --> 00:39:04,919
Joey has a question

00:39:05,729 --> 00:39:12,009
so I mean speaking of Weiland your unity

00:39:08,469 --> 00:39:14,649
or something like this how does this tie

00:39:12,009 --> 00:39:19,329
into that ecosystem or whatever you want

00:39:14,649 --> 00:39:20,799
to call it um because because mirror

00:39:19,329 --> 00:39:23,169
doesn't count because it's not an actual

00:39:20,799 --> 00:39:26,589
Window System yet but in the in the

00:39:23,169 --> 00:39:28,449
Whelan world in the Whelan world the

00:39:26,589 --> 00:39:30,759
present extension is gonna is would

00:39:28,449 --> 00:39:32,469
obviously the Whelan acts as an ex

00:39:30,759 --> 00:39:34,630
compositing manager so the fact that the

00:39:32,469 --> 00:39:36,519
compositing operations are redirected to

00:39:34,630 --> 00:39:38,409
that compositing manager what would

00:39:36,519 --> 00:39:40,479
presumably make them more efficient and

00:39:38,409 --> 00:39:42,219
a Whelan based compositing manager using

00:39:40,479 --> 00:39:44,079
the present redirection stuff could

00:39:42,219 --> 00:39:46,659
avoid a bunch of the copies that would

00:39:44,079 --> 00:39:48,459
otherwise have to do so X applications

00:39:46,659 --> 00:39:50,259
running under a Whelan environment with

00:39:48,459 --> 00:39:52,179
a Whelan compositing manager would

00:39:50,259 --> 00:39:55,630
presumably be as efficient as they are X

00:39:52,179 --> 00:39:57,549
with an X compositing manager I I don't

00:39:55,630 --> 00:40:00,249
that was that wasn't really my question

00:39:57,549 --> 00:40:02,380
my question was really do these things

00:40:00,249 --> 00:40:04,719
are these things necessary oh absolutely

00:40:02,380 --> 00:40:06,249
I mean if you're gonna run an X

00:40:04,719 --> 00:40:07,509
application you want them to what you

00:40:06,249 --> 00:40:09,219
want that you want it to run as

00:40:07,509 --> 00:40:11,109
efficiently as possible in a compositing

00:40:09,219 --> 00:40:14,079
environment these things being Wayland

00:40:11,109 --> 00:40:20,259
Oh wailing at all

00:40:14,079 --> 00:40:21,699
I don't know right the quest so wailing

00:40:20,259 --> 00:40:24,819
wailing offers some additional

00:40:21,699 --> 00:40:27,099
additional changes in the ecosystem it

00:40:24,819 --> 00:40:29,380
has it promised a simpler a simpler

00:40:27,099 --> 00:40:33,429
protocol and a smaller code base it

00:40:29,380 --> 00:40:35,380
promises more security and it promises

00:40:33,429 --> 00:40:38,019
the ability to do news

00:40:35,380 --> 00:40:39,579
with user interfaces and so the question

00:40:38,019 --> 00:40:41,619
is is it more efficient to do that

00:40:39,579 --> 00:40:44,019
transition or to continue using X and

00:40:41,619 --> 00:40:46,150
try to fix those problems and I think

00:40:44,019 --> 00:40:47,920
that's an open question certainly this

00:40:46,150 --> 00:40:50,259
is an attempt to try to fix some of the

00:40:47,920 --> 00:40:53,009
the big performance and usability gaps

00:40:50,259 --> 00:40:56,200
in X on the present on the output side

00:40:53,009 --> 00:40:58,450
we still have work to do with security

00:40:56,200 --> 00:41:00,910
in X in order to make applications not

00:40:58,450 --> 00:41:02,650
able to snoop each other's input

00:41:00,910 --> 00:41:04,329
I don't think Subang output is all that

00:41:02,650 --> 00:41:06,609
interesting applications that put stuff

00:41:04,329 --> 00:41:09,549
on the screen including passwords are

00:41:06,609 --> 00:41:10,990
probably just broken but in terms of

00:41:09,549 --> 00:41:12,849
having input snooping that's probably

00:41:10,990 --> 00:41:15,420
something we want to work on on fixing

00:41:12,849 --> 00:41:17,950
and I don't think that's very difficult

00:41:15,420 --> 00:41:19,210
in terms of in terms of running X

00:41:17,950 --> 00:41:21,880
applications um

00:41:19,210 --> 00:41:24,309
I don't see any of us not running X

00:41:21,880 --> 00:41:25,990
applications for a long time and so

00:41:24,309 --> 00:41:27,549
certainly any work that we do at X to

00:41:25,990 --> 00:41:29,349
make those applications more efficient

00:41:27,549 --> 00:41:30,910
is going to be good for now and the

00:41:29,349 --> 00:41:33,190
future independent of what underlying

00:41:30,910 --> 00:41:34,690
compositing manager you use because

00:41:33,190 --> 00:41:38,049
we're going to be running most of our

00:41:34,690 --> 00:41:41,740
core user interface through X for the

00:41:38,049 --> 00:41:43,980
foreseeable future so I'm trying to make

00:41:41,740 --> 00:41:43,980
it better

00:41:47,700 --> 00:41:51,339
other questions or comments I think it's

00:41:49,990 --> 00:41:53,109
about time for dinner and we can have

00:41:51,339 --> 00:41:54,490
about three more minutes thank you very

00:41:53,109 --> 00:41:55,540
much for coming and enjoy the rest of

00:41:54,490 --> 00:42:05,820
dead cops

00:41:55,540 --> 00:42:05,820

YouTube URL: https://www.youtube.com/watch?v=hjxXrRYNP60


