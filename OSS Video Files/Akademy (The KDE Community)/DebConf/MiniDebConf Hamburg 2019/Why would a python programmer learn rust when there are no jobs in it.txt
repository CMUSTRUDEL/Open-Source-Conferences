Title: Why would a python programmer learn rust when there are no jobs in it
Publication date: 2019-06-16
Playlist: MiniDebConf Hamburg 2019
Description: 
	by Owen Synge

At: MiniDebConf Hamburg 2019
https://wiki.debian.org/DebianEvents/de/2019/MiniDebConfHamburg
Room: main
Scheduled start: 2019-06-09 18:00:00
Captions: 
	00:00:04,819 --> 00:00:10,500
okay so this talk was originally a talk

00:00:08,790 --> 00:00:13,160
I gave for HEPA can die haven't updated

00:00:10,500 --> 00:00:16,440
the date and time

00:00:13,160 --> 00:00:19,320
that's scientific computing data center

00:00:16,440 --> 00:00:20,520
manager conference and I was telling

00:00:19,320 --> 00:00:23,130
them about rust which was my latest

00:00:20,520 --> 00:00:25,830
experiments and I've updated the talk a

00:00:23,130 --> 00:00:28,939
couple of times since but I obviously

00:00:25,830 --> 00:00:31,829
haven't updated the date so let's get on

00:00:28,939 --> 00:00:34,800
my general opinion about programming

00:00:31,829 --> 00:00:37,830
language is is I want them to work with

00:00:34,800 --> 00:00:40,440
other programming languages I really

00:00:37,830 --> 00:00:41,700
want them to interface with C I want

00:00:40,440 --> 00:00:43,320
them to have a really significant

00:00:41,700 --> 00:00:47,550
advantage before I'm willing to invest

00:00:43,320 --> 00:00:49,050
in them and um Python was a great leap

00:00:47,550 --> 00:00:52,730
forward for me in terms of productivity

00:00:49,050 --> 00:00:55,200
and that's why I fell in love with it I

00:00:52,730 --> 00:00:58,020
need to be able to do a certain series

00:00:55,200 --> 00:01:01,320
of tasks usually my jobs involve writing

00:00:58,020 --> 00:01:03,840
CLI applications with a database having

00:01:01,320 --> 00:01:07,619
logging processing Jason things like

00:01:03,840 --> 00:01:10,049
that and I've tested all of these use

00:01:07,619 --> 00:01:13,350
cases before I've presented anything

00:01:10,049 --> 00:01:14,420
about rust and rust is really passed

00:01:13,350 --> 00:01:17,850
with flying colors

00:01:14,420 --> 00:01:20,670
so let's jump back and say why do I like

00:01:17,850 --> 00:01:23,490
Python it's really fast to write it's

00:01:20,670 --> 00:01:25,229
really quick to debug and most

00:01:23,490 --> 00:01:29,280
applications don't need performance and

00:01:25,229 --> 00:01:31,679
so while it's 100 times slower than C

00:01:29,280 --> 00:01:34,259
roughly it's usually fast enough and

00:01:31,679 --> 00:01:37,530
duck typing is wonderful it was a

00:01:34,259 --> 00:01:40,049
revelation to me when I came to Python

00:01:37,530 --> 00:01:42,600
first where things are like the things

00:01:40,049 --> 00:01:46,139
that you expect them to be good enough

00:01:42,600 --> 00:01:48,659
error handling I really disliked C++ is

00:01:46,139 --> 00:01:50,399
our inheritance models and stuff like

00:01:48,659 --> 00:01:54,060
that and I thought pythons there was so

00:01:50,399 --> 00:01:55,350
much cleaner and my god the tooling has

00:01:54,060 --> 00:01:59,009
improved over the year so I've been

00:01:55,350 --> 00:02:02,880
using Python since 2006 with talks

00:01:59,009 --> 00:02:06,299
virtual end PI tests mock really is a

00:02:02,880 --> 00:02:09,660
pleasure to to debug things into PI it

00:02:06,299 --> 00:02:11,730
with Python and make things solid sadly

00:02:09,660 --> 00:02:14,099
there are little corners but anyway

00:02:11,730 --> 00:02:17,549
we'll jump forward but Python you have

00:02:14,099 --> 00:02:18,630
some real compromises and while pison is

00:02:17,549 --> 00:02:22,590
where I make my

00:02:18,630 --> 00:02:25,470
how I employ myself it doesn't solve

00:02:22,590 --> 00:02:27,510
every problem that I have one of the

00:02:25,470 --> 00:02:29,250
biggest compromises with Python is the

00:02:27,510 --> 00:02:30,720
global interpreter lock which means that

00:02:29,250 --> 00:02:31,770
when you do multi-threading you're doing

00:02:30,720 --> 00:02:33,930
multi-threading because you need to do

00:02:31,770 --> 00:02:35,640
multiple things concurrently you can't

00:02:33,930 --> 00:02:37,650
get a performance increase by doing

00:02:35,640 --> 00:02:41,100
multi-threading in Python so that is a

00:02:37,650 --> 00:02:43,080
major problem with Python and generally

00:02:41,100 --> 00:02:44,790
it's performance is slow can't really

00:02:43,080 --> 00:02:46,350
use Python in an embedded environment

00:02:44,790 --> 00:02:48,240
very easily although there are variants

00:02:46,350 --> 00:02:49,340
of Python for embedded environment but

00:02:48,240 --> 00:02:51,960
that's another story

00:02:49,340 --> 00:02:57,420
well please don't get confused by that

00:02:51,960 --> 00:02:58,740
one memory usage swig these things have

00:02:57,420 --> 00:03:00,210
all caused problems but we haven't got

00:02:58,740 --> 00:03:03,060
long to talk about all these slides so

00:03:00,210 --> 00:03:05,100
I'm not going to read everything so how

00:03:03,060 --> 00:03:07,320
do we work around pythons limitations if

00:03:05,100 --> 00:03:09,300
we're working in Python well you can

00:03:07,320 --> 00:03:11,550
rewrite everything there it can be very

00:03:09,300 --> 00:03:13,320
revolutionary or you can be incremental

00:03:11,550 --> 00:03:17,250
and make native C bindings for the

00:03:13,320 --> 00:03:20,130
performance critical areas ah yes and

00:03:17,250 --> 00:03:23,370
foreign function calls from Python can

00:03:20,130 --> 00:03:28,530
be done but it's kind of one of those

00:03:23,370 --> 00:03:31,530
problems so I said see what makes me

00:03:28,530 --> 00:03:33,960
avoid C well I find for me I know that

00:03:31,530 --> 00:03:35,970
there are gurus out there but I find

00:03:33,960 --> 00:03:37,230
development is really really slow

00:03:35,970 --> 00:03:41,490
compared to Python

00:03:37,230 --> 00:03:45,060
I find debugging really hard I've I got

00:03:41,490 --> 00:03:46,650
to write C reasonably at one point in my

00:03:45,060 --> 00:03:48,930
career a long time ago and I've

00:03:46,650 --> 00:03:52,110
forgotten it all okay not all of it but

00:03:48,930 --> 00:03:54,660
quite a lot of it and now I just find it

00:03:52,110 --> 00:03:57,030
really hard work with compiler errors

00:03:54,660 --> 00:03:59,100
don't have that many memory management

00:03:57,030 --> 00:04:02,610
issues but sometimes the libraries I

00:03:59,100 --> 00:04:04,920
worked with did and in terms of being

00:04:02,610 --> 00:04:06,360
efficient with memory well I never quite

00:04:04,920 --> 00:04:07,740
got the hang of that because I was more

00:04:06,360 --> 00:04:13,140
focused on making sure that didn't get

00:04:07,740 --> 00:04:16,620
leaks so swings and roundabouts and C++

00:04:13,140 --> 00:04:20,310
well people told me this was gonna be a

00:04:16,620 --> 00:04:22,560
great leap forward i pre date in my c++

00:04:20,310 --> 00:04:25,800
time all the big advanced things that

00:04:22,560 --> 00:04:27,840
happen in c++ 11 and c++ 17 that made it

00:04:25,800 --> 00:04:31,200
a much better language I'm told by my

00:04:27,840 --> 00:04:32,440
friends who were experts in C++ so my

00:04:31,200 --> 00:04:34,620
memories are

00:04:32,440 --> 00:04:37,000
and being slow debugging being hard

00:04:34,620 --> 00:04:39,790
multi-threading being hard compiler

00:04:37,000 --> 00:04:43,210
errors STL traces that go off the screen

00:04:39,790 --> 00:04:45,040
oh it was suffering and so I went back

00:04:43,210 --> 00:04:49,780
to see when I used to be a C++

00:04:45,040 --> 00:04:53,140
programmer under GCC so why did I try

00:04:49,780 --> 00:04:56,890
rust well I've been to the CCC

00:04:53,140 --> 00:04:59,410
conference in Hamburg last time it was

00:04:56,890 --> 00:05:01,300
here and I've been to false gem and

00:04:59,410 --> 00:05:05,340
there was quite a buzz around a lick sir

00:05:01,300 --> 00:05:09,190
and rust and elixir was derived from

00:05:05,340 --> 00:05:10,870
Lang and I'd already had a look at that

00:05:09,190 --> 00:05:12,910
and realized it was a great programming

00:05:10,870 --> 00:05:14,500
language but not really fitting all my

00:05:12,910 --> 00:05:18,850
use cases and I wanted something bit

00:05:14,500 --> 00:05:21,280
more Universal native and compiled with

00:05:18,850 --> 00:05:22,990
things I had a use cases for and I

00:05:21,280 --> 00:05:25,270
wanted to extend Python and I wanted

00:05:22,990 --> 00:05:28,750
something to be as fast as C and C++ but

00:05:25,270 --> 00:05:30,100
with need when needed and I didn't want

00:05:28,750 --> 00:05:31,540
garbage collection because I didn't want

00:05:30,100 --> 00:05:34,900
one garbage collector to fight with

00:05:31,540 --> 00:05:36,250
another freeing of resources in Python

00:05:34,900 --> 00:05:40,210
because I wanted it for embedding in

00:05:36,250 --> 00:05:41,800
other languages and I'd heard something

00:05:40,210 --> 00:05:45,040
about rust being may be useful for

00:05:41,800 --> 00:05:47,800
multi-threading and to be quite honest I

00:05:45,040 --> 00:05:49,330
wanted to pick up another language and I

00:05:47,800 --> 00:05:52,020
thought maybe something had happened in

00:05:49,330 --> 00:05:54,460
the ten years since Python was invented

00:05:52,020 --> 00:05:57,310
so there's some interesting design

00:05:54,460 --> 00:05:59,020
decisions probably most important factor

00:05:57,310 --> 00:06:02,230
to understand about rust as it was

00:05:59,020 --> 00:06:05,440
designed by Mozilla for very much a

00:06:02,230 --> 00:06:08,890
practical purpose how can we make our

00:06:05,440 --> 00:06:11,740
code more reliable and more safe and how

00:06:08,890 --> 00:06:14,710
can we incrementally improve the product

00:06:11,740 --> 00:06:16,570
that we have Firefox I'm not a Firefox

00:06:14,710 --> 00:06:19,650
developer but that was their use case

00:06:16,570 --> 00:06:22,120
and so that was really interesting

00:06:19,650 --> 00:06:25,210
incrementally changing to a new language

00:06:22,120 --> 00:06:26,260
that really stuck in my mind of

00:06:25,210 --> 00:06:28,570
something special

00:06:26,260 --> 00:06:31,900
now zero abstraction overhead philosophy

00:06:28,570 --> 00:06:34,560
just likes C++ what that means is it's

00:06:31,900 --> 00:06:36,640
gonna run as fast as we can yeah and

00:06:34,560 --> 00:06:38,380
it's your fault

00:06:36,640 --> 00:06:42,240
if it doesn't run fast rather than

00:06:38,380 --> 00:06:44,009
pythons fault or someone else's fault

00:06:42,240 --> 00:06:46,050
no big garbage collector but a borrow

00:06:44,009 --> 00:06:47,190
checker now the word borrowed check is

00:06:46,050 --> 00:06:49,710
going to come up a couple of times in

00:06:47,190 --> 00:06:52,650
this talk and I'm gonna try and not go

00:06:49,710 --> 00:06:53,849
into it for a few seconds but please at

00:06:52,650 --> 00:06:57,630
the end if I haven't explained enough

00:06:53,849 --> 00:06:59,970
let's get on to that multi-threaded

00:06:57,630 --> 00:07:02,280
support baked into the type system now

00:06:59,970 --> 00:07:05,970
that's linked the burro check of stuff

00:07:02,280 --> 00:07:07,440
but long and short of it is you can be

00:07:05,970 --> 00:07:09,270
pretty fearless about writing

00:07:07,440 --> 00:07:11,370
multi-threaded code because you get a

00:07:09,270 --> 00:07:13,590
type error and it won't compile if it's

00:07:11,370 --> 00:07:18,000
not thread safe now that's pretty

00:07:13,590 --> 00:07:20,729
awesome variables are immutable by

00:07:18,000 --> 00:07:22,860
default now I know one person here is an

00:07:20,729 --> 00:07:24,360
inter functional programming and this is

00:07:22,860 --> 00:07:28,560
just how he would like the world to be

00:07:24,360 --> 00:07:30,389
and once you sit there and work in a

00:07:28,560 --> 00:07:32,160
world where variables are immutable by

00:07:30,389 --> 00:07:35,190
default you think this is a major bug in

00:07:32,160 --> 00:07:36,599
C and a major bug in C++ and you realize

00:07:35,190 --> 00:07:39,800
that for backwards compatibility they

00:07:36,599 --> 00:07:42,479
can never fix it and it's kind of sad

00:07:39,800 --> 00:07:47,490
but life's like that we still use QWERTY

00:07:42,479 --> 00:07:50,550
keyboards enumerated types with

00:07:47,490 --> 00:07:52,680
parameters now this is all stolen from

00:07:50,550 --> 00:07:55,169
ml and it's absolutely wonderful and

00:07:52,680 --> 00:07:57,360
I'll show you an example later but it's

00:07:55,169 --> 00:08:01,440
a very long word for saying parameters

00:07:57,360 --> 00:08:04,380
can be put into enumerated types so my

00:08:01,440 --> 00:08:05,820
first experience about rust well a lot

00:08:04,380 --> 00:08:08,610
was unfamiliar to me they have a whole

00:08:05,820 --> 00:08:12,360
ecosystem around them rust up a tool

00:08:08,610 --> 00:08:14,729
chain updater that made me scream cargo

00:08:12,360 --> 00:08:17,610
which it's an entire behavior made me

00:08:14,729 --> 00:08:19,770
scream and I'll explain why very soon

00:08:17,610 --> 00:08:21,719
and then they flat there and threw away

00:08:19,770 --> 00:08:23,190
object orientation which made me

00:08:21,719 --> 00:08:25,590
initially go why the hell are you

00:08:23,190 --> 00:08:27,240
reinventing the wheel and then they said

00:08:25,590 --> 00:08:30,570
the getting rid of exception handling as

00:08:27,240 --> 00:08:32,760
well I wasn't unhappy with the idea of

00:08:30,570 --> 00:08:34,709
LLVM that initially my prejudice was

00:08:32,760 --> 00:08:36,899
okay with and then there's Baro checker

00:08:34,709 --> 00:08:40,800
stuff which pretty quickly I felt was

00:08:36,899 --> 00:08:42,390
revolutionary but other concerns came in

00:08:40,800 --> 00:08:45,660
just as I was getting aware of these

00:08:42,390 --> 00:08:47,760
things about maturity of the tools so

00:08:45,660 --> 00:08:50,360
let's get on to these things and see why

00:08:47,760 --> 00:08:52,730
they made me scream and why they

00:08:50,360 --> 00:08:55,769
continued to make me a little bit upset

00:08:52,730 --> 00:08:57,569
yeah so rust up is the

00:08:55,769 --> 00:09:00,689
default way to get a rough development

00:08:57,569 --> 00:09:03,149
environment and this goes completely

00:09:00,689 --> 00:09:05,610
against the Debian policy basically you

00:09:03,149 --> 00:09:07,499
don't download a script install it in

00:09:05,610 --> 00:09:10,139
the system or what slide am i on ok I'm

00:09:07,499 --> 00:09:14,100
going a bit too slowly and it downloads

00:09:10,139 --> 00:09:18,360
all of the build tools and plug them

00:09:14,100 --> 00:09:20,249
into your directory off the web I wasn't

00:09:18,360 --> 00:09:23,369
really happy for it it's got good

00:09:20,249 --> 00:09:25,470
reasons for it it can now be avoided for

00:09:23,369 --> 00:09:27,929
rusts stable on platforms like Debian

00:09:25,470 --> 00:09:31,230
you've now done a great job of packaging

00:09:27,929 --> 00:09:33,869
cargo packaging rafts they now exist but

00:09:31,230 --> 00:09:36,569
if you want to work with cross compiling

00:09:33,869 --> 00:09:38,040
if you want to work with rust nightly

00:09:36,569 --> 00:09:39,139
and there are occasional reasons why you

00:09:38,040 --> 00:09:42,149
might want to do both of those things

00:09:39,139 --> 00:09:45,449
then rust up is the appropriate way to

00:09:42,149 --> 00:09:46,769
do it at the moment as a rust developer

00:09:45,449 --> 00:09:48,559
I hope Debian has another solution

00:09:46,769 --> 00:09:52,619
sometime in the future

00:09:48,559 --> 00:09:54,299
cargo really scared me at first this you

00:09:52,619 --> 00:09:56,579
sit there and you make a nice tamil file

00:09:54,299 --> 00:09:59,089
which is a bit like a Windows any file

00:09:56,579 --> 00:10:02,279
and you describe your build dependencies

00:09:59,089 --> 00:10:04,829
and it downloads things from the web and

00:10:02,279 --> 00:10:07,319
that was a bit scary to me at first I

00:10:04,829 --> 00:10:09,269
was totally upset by this for

00:10:07,319 --> 00:10:12,839
reproducible builds having a new package

00:10:09,269 --> 00:10:14,730
is all of that the cargo team have

00:10:12,839 --> 00:10:16,769
changed things a lot since I've been

00:10:14,730 --> 00:10:18,660
using it now there's ven during which

00:10:16,769 --> 00:10:22,079
means that you can download all of these

00:10:18,660 --> 00:10:24,329
dependencies off the and store them on

00:10:22,079 --> 00:10:27,839
disk so even if you're not working with

00:10:24,329 --> 00:10:31,019
Debian's excellent packaging plans for

00:10:27,839 --> 00:10:35,399
rust you can still have a repeatable

00:10:31,019 --> 00:10:39,290
build it's very simple to use and

00:10:35,399 --> 00:10:41,189
there's a build RS thing which is a pre

00:10:39,290 --> 00:10:43,439
compete of rust code that you can

00:10:41,189 --> 00:10:45,809
compile before the rest is compiled for

00:10:43,439 --> 00:10:48,029
doing things like extending your

00:10:45,809 --> 00:10:51,389
applications automatically generating C

00:10:48,029 --> 00:10:53,040
bindings all the sort of things you

00:10:51,389 --> 00:10:56,879
might do with all the tools sorry I'm a

00:10:53,040 --> 00:11:00,899
bit out of date I don't know C make so

00:10:56,879 --> 00:11:04,799
the rust compiler is slow really really

00:11:00,899 --> 00:11:06,329
slow it makes C++ compiler seem fast

00:11:04,799 --> 00:11:09,480
this is

00:11:06,329 --> 00:11:11,910
this is not nice but the error message

00:11:09,480 --> 00:11:13,949
is on the other hand they blow away the

00:11:11,910 --> 00:11:16,319
C++ compiler and any compiler I have

00:11:13,949 --> 00:11:17,759
ever seen in my life I can't say I've

00:11:16,319 --> 00:11:21,089
seen house Kelvin things like that but

00:11:17,759 --> 00:11:23,129
I've seen a little bit and it sometimes

00:11:21,089 --> 00:11:24,540
even tells you the correct solution to

00:11:23,129 --> 00:11:28,709
the problem that you're trying to have

00:11:24,540 --> 00:11:32,220
and it's fussy it's so fussy the rough

00:11:28,709 --> 00:11:33,929
compiler the almost always when you

00:11:32,220 --> 00:11:36,660
actually manage to fight with the RUS

00:11:33,929 --> 00:11:39,029
compiler enough to make it compile it

00:11:36,660 --> 00:11:42,600
almost always does what you expect first

00:11:39,029 --> 00:11:44,279
time now that's kind of weird for me

00:11:42,600 --> 00:11:46,499
particularly after having used Python

00:11:44,279 --> 00:11:48,689
and the board checkers lovely so I'm

00:11:46,499 --> 00:11:51,179
going to carry on running fast now

00:11:48,689 --> 00:11:55,819
so rust error handling as I said no

00:11:51,179 --> 00:11:58,290
exceptions basically there is a panic

00:11:55,819 --> 00:12:00,360
unrecoverable thing and you can recover

00:11:58,290 --> 00:12:02,459
from it just like this kind of corner

00:12:00,360 --> 00:12:04,769
cases I said you it was unrecoverable

00:12:02,459 --> 00:12:08,519
but I know more than oh did when I first

00:12:04,769 --> 00:12:10,769
wrote these slides there are recoverable

00:12:08,519 --> 00:12:12,989
errors and these are done with

00:12:10,769 --> 00:12:14,850
parameterised enumerated types so you

00:12:12,989 --> 00:12:17,879
basically say that the output of a

00:12:14,850 --> 00:12:20,549
function has a result type and then you

00:12:17,879 --> 00:12:23,540
have the okay type and the error type

00:12:20,549 --> 00:12:26,669
and then you can use the error type and

00:12:23,540 --> 00:12:28,949
at first when I started programming in

00:12:26,669 --> 00:12:30,899
rust my code was growing because I was

00:12:28,949 --> 00:12:33,209
matching on which types am I getting

00:12:30,899 --> 00:12:35,249
back from my function and then handling

00:12:33,209 --> 00:12:37,499
the error but if you keep the error type

00:12:35,249 --> 00:12:39,389
consistent between the functions you can

00:12:37,499 --> 00:12:41,790
just pass it up like an exception would

00:12:39,389 --> 00:12:44,369
up the stack by using the question mark

00:12:41,790 --> 00:12:47,279
operator so that makes the language

00:12:44,369 --> 00:12:50,089
really quite succinctly breeze like

00:12:47,279 --> 00:12:55,739
error chain is starting to be deprecated

00:12:50,089 --> 00:12:58,980
so what oh why is rust not quite oo well

00:12:55,739 --> 00:13:01,919
it's almost oo it doesn't support

00:12:58,980 --> 00:13:06,569
inheritance they don't have methods

00:13:01,919 --> 00:13:09,410
directly applied to objects in the same

00:13:06,569 --> 00:13:11,459
sort of syntax goes very very similar

00:13:09,410 --> 00:13:14,100
and I'll show an example in the next

00:13:11,459 --> 00:13:17,100
slide and we have the concept of traits

00:13:14,100 --> 00:13:20,370
which are a bit like interfaces in Java

00:13:17,100 --> 00:13:23,190
or polymorphic behavior

00:13:20,370 --> 00:13:24,990
in arrow and I've yet to see no downside

00:13:23,190 --> 00:13:27,060
and I'll just show you an example of the

00:13:24,990 --> 00:13:30,270
code on the next page very very quickly

00:13:27,060 --> 00:13:35,390
so here we have a structure very much

00:13:30,270 --> 00:13:39,450
like a see structure here we have a oh

00:13:35,390 --> 00:13:43,230
sorry yes so and here we have a function

00:13:39,450 --> 00:13:46,410
that's converting point to string that

00:13:43,230 --> 00:13:50,040
said that exists and here is an

00:13:46,410 --> 00:13:53,279
implementation of points methods and

00:13:50,040 --> 00:13:55,080
there's a two string thing it's really

00:13:53,279 --> 00:14:00,720
you don't actually need the line on line

00:13:55,080 --> 00:14:04,350
seven so here's an example of a hash

00:14:00,720 --> 00:14:05,850
function being implemented for two

00:14:04,350 --> 00:14:08,339
different types and this shows the

00:14:05,850 --> 00:14:11,130
strength of using traits rather than

00:14:08,339 --> 00:14:14,760
arrow because here we are implementing

00:14:11,130 --> 00:14:16,860
hash for bool yes but we don't control

00:14:14,760 --> 00:14:21,290
the bull type so we can implement

00:14:16,860 --> 00:14:24,420
methods implement methods of traits

00:14:21,290 --> 00:14:25,980
implement traits for objects we don't

00:14:24,420 --> 00:14:27,150
control and that means you have some

00:14:25,980 --> 00:14:28,770
flexibility when you're working with

00:14:27,150 --> 00:14:32,940
external libraries that you couldn't get

00:14:28,770 --> 00:14:36,839
with oh oh I think it's rather nice and

00:14:32,940 --> 00:14:38,820
here's another example of just a really

00:14:36,839 --> 00:14:41,970
cool library using some macros to

00:14:38,820 --> 00:14:42,959
decorate a structure and that's all you

00:14:41,970 --> 00:14:45,270
need to do to make something

00:14:42,959 --> 00:14:47,130
serializable and be serializable in rust

00:14:45,270 --> 00:14:53,040
using the beautiful surgery library

00:14:47,130 --> 00:14:54,540
which goes very fast and is great

00:14:53,040 --> 00:14:56,520
because it gives you full type checking

00:14:54,540 --> 00:14:57,779
which you also get with rust okay I've

00:14:56,520 --> 00:14:59,459
really got hurry because I'm running out

00:14:57,779 --> 00:15:03,470
of time and I've got far too much

00:14:59,459 --> 00:15:05,970
content here the burrow check are

00:15:03,470 --> 00:15:07,680
basically the concept is only one thing

00:15:05,970 --> 00:15:10,260
to know in the own memory at any one

00:15:07,680 --> 00:15:12,420
time to change things and multiple

00:15:10,260 --> 00:15:15,839
readers can happen at the same time to

00:15:12,420 --> 00:15:18,209
get around this with multi-threading you

00:15:15,839 --> 00:15:20,970
then have a reference a reference count

00:15:18,209 --> 00:15:23,940
action and in here at that with a lock

00:15:20,970 --> 00:15:28,110
type so you can get a mutable access to

00:15:23,940 --> 00:15:30,270
the reference and when the lock goes out

00:15:28,110 --> 00:15:33,240
of scope it's automatically unlocked so

00:15:30,270 --> 00:15:34,980
it becomes very easy to share blocks of

00:15:33,240 --> 00:15:37,500
memory between

00:15:34,980 --> 00:15:40,670
different rust threads but you've still

00:15:37,500 --> 00:15:43,350
probably better off using the

00:15:40,670 --> 00:15:45,630
communication via messaging between

00:15:43,350 --> 00:15:47,759
threads for most things because it's

00:15:45,630 --> 00:15:50,430
safer and you're less likely to get into

00:15:47,759 --> 00:15:53,250
deadlocks but the whole consequence of

00:15:50,430 --> 00:15:55,889
this is that not only do we get out of

00:15:53,250 --> 00:15:59,370
the type system thread safety but we

00:15:55,889 --> 00:16:02,279
also get something like garbage

00:15:59,370 --> 00:16:03,990
collection but without the periodic

00:16:02,279 --> 00:16:07,050
stopping of garbage collection we get

00:16:03,990 --> 00:16:08,970
something quite real-time there so if

00:16:07,050 --> 00:16:11,130
that is really rather wonderful and

00:16:08,970 --> 00:16:12,389
Apple's going to steal the idea and put

00:16:11,130 --> 00:16:15,839
into Swift very soon

00:16:12,389 --> 00:16:18,839
I've heard ok this is just a random

00:16:15,839 --> 00:16:20,699
example of my original use case for why

00:16:18,839 --> 00:16:23,550
I wanted to sit there and play with a

00:16:20,699 --> 00:16:27,959
more low-level language like C or C++ or

00:16:23,550 --> 00:16:31,410
rust we can very easily embed rust into

00:16:27,959 --> 00:16:34,079
Python I've had I've got played with

00:16:31,410 --> 00:16:36,600
this quite some depth it's a little bit

00:16:34,079 --> 00:16:38,370
too naive for me to sit there sorry a

00:16:36,600 --> 00:16:41,010
bit too immature for me to sit there and

00:16:38,370 --> 00:16:44,100
say it's properly production you do need

00:16:41,010 --> 00:16:45,720
to work with rust nightly this is not

00:16:44,100 --> 00:16:47,160
readable on these slides I decided there

00:16:45,720 --> 00:16:48,480
was no point me even trying to make it

00:16:47,160 --> 00:16:50,519
readable but it gives you an idea of how

00:16:48,480 --> 00:16:54,199
little code is needed to make a word

00:16:50,519 --> 00:16:59,910
search in from the word search example

00:16:54,199 --> 00:17:02,760
on the main the main PI o 3 git

00:16:59,910 --> 00:17:05,280
repository it's really really trivial to

00:17:02,760 --> 00:17:06,929
import things I've extended this example

00:17:05,280 --> 00:17:09,390
and played around with Sergey for

00:17:06,929 --> 00:17:11,990
serializing and deserializing to make

00:17:09,390 --> 00:17:13,980
some benchmarks against Python and rust

00:17:11,990 --> 00:17:15,809
but I want to go a little bit further

00:17:13,980 --> 00:17:18,890
before I release the figures but I sit

00:17:15,809 --> 00:17:21,270
there and say the rust is so much faster

00:17:18,890 --> 00:17:22,439
so rust issues I've found this is

00:17:21,270 --> 00:17:24,569
probably the most valuable bit of the

00:17:22,439 --> 00:17:29,370
talk because people don't often tell you

00:17:24,569 --> 00:17:31,980
things that they don't like so it's only

00:17:29,370 --> 00:17:33,780
implemented with LLVM so it's not 100%

00:17:31,980 --> 00:17:35,970
self-supporting language I think that's

00:17:33,780 --> 00:17:38,130
a really important failing of rust

00:17:35,970 --> 00:17:39,540
actually but I can totally see why it's

00:17:38,130 --> 00:17:43,220
happened from an engineering pragmatic

00:17:39,540 --> 00:17:46,740
perspective there's no stables see ABI

00:17:43,220 --> 00:17:47,880
you can export C trivially by just

00:17:46,740 --> 00:17:50,520
decorating method

00:17:47,880 --> 00:17:53,820
and functions and types it's really easy

00:17:50,520 --> 00:17:57,600
but you can but then you're using the C

00:17:53,820 --> 00:17:59,310
API it's like C++ is not stable and rust

00:17:57,600 --> 00:18:02,760
is not easy to learn it's nowhere near

00:17:59,310 --> 00:18:06,570
as easy to learn as Python but if you're

00:18:02,760 --> 00:18:08,040
familiar with Cu C++ Pascal those sort

00:18:06,570 --> 00:18:09,630
of languages Delfy

00:18:08,040 --> 00:18:12,540
anything the way you've been using raw

00:18:09,630 --> 00:18:15,570
memory ax management yourself it won't

00:18:12,540 --> 00:18:19,080
seem that different from what you have

00:18:15,570 --> 00:18:21,360
learnt as best practice it kind of

00:18:19,080 --> 00:18:24,030
enforces best practice and that's what

00:18:21,360 --> 00:18:26,040
the burrow checker does and it sometimes

00:18:24,030 --> 00:18:27,930
hurts you in ways that you didn't

00:18:26,040 --> 00:18:30,560
realize and you go oh my god I've been

00:18:27,930 --> 00:18:32,820
making this mistake in C all my life

00:18:30,560 --> 00:18:35,250
well that's how I felt about the Burrow

00:18:32,820 --> 00:18:41,360
checker I think it's much harder if you

00:18:35,250 --> 00:18:43,770
grew up with JavaScript by default

00:18:41,360 --> 00:18:45,870
cargo downloads from the internet you

00:18:43,770 --> 00:18:52,290
have to work a little bit to stop it

00:18:45,870 --> 00:18:54,930
doing that and async IO is a weak point

00:18:52,290 --> 00:18:57,870
in rust it's only the past year that

00:18:54,930 --> 00:18:59,460
there's been a story for async IO so

00:18:57,870 --> 00:19:01,500
this is where we don't do blocking

00:18:59,460 --> 00:19:04,500
requests using the old traditional C API

00:19:01,500 --> 00:19:06,630
from the 70s we start modernizing

00:19:04,500 --> 00:19:10,440
ourselves and using the 1980s api's of

00:19:06,630 --> 00:19:14,160
the UNIX kernel and that's only

00:19:10,440 --> 00:19:16,170
happening now some things still require

00:19:14,160 --> 00:19:20,360
us nightly when I first started playing

00:19:16,170 --> 00:19:23,430
with rust it was nearly everything and

00:19:20,360 --> 00:19:24,870
incremental builds reach stable around

00:19:23,430 --> 00:19:29,340
about the time I gave first gave this

00:19:24,870 --> 00:19:31,380
talk meta programming tools and some of

00:19:29,340 --> 00:19:34,650
the features of macros haven't been

00:19:31,380 --> 00:19:38,220
fully standardized out by the rough

00:19:34,650 --> 00:19:41,730
standardization groups and so some of

00:19:38,220 --> 00:19:44,940
these things have been left in rust

00:19:41,730 --> 00:19:47,280
nightly for a quite a long time and I've

00:19:44,940 --> 00:19:49,410
found whenever I've wrapped C code I

00:19:47,280 --> 00:19:51,750
have to use the unsafe command and when

00:19:49,410 --> 00:19:53,880
ever I use the unsafe command you know I

00:19:51,750 --> 00:19:56,940
said the compiler was absolutely lovely

00:19:53,880 --> 00:19:59,120
soon as you put the unsafe keyword and

00:19:56,940 --> 00:20:01,530
you wrap the code suddenly all of the I

00:19:59,120 --> 00:20:03,990
think you actually meant to do this

00:20:01,530 --> 00:20:11,460
and it being right goes away it just

00:20:03,990 --> 00:20:13,200
says era yes you're wrong so it does

00:20:11,460 --> 00:20:16,500
encourage you not to use the unsafe

00:20:13,200 --> 00:20:19,650
keyword too much anyway

00:20:16,500 --> 00:20:20,700
so from Python person's perspective what

00:20:19,650 --> 00:20:25,710
hurt

00:20:20,700 --> 00:20:28,170
probably most was the semicolon thing so

00:20:25,710 --> 00:20:29,820
functions just returning because you

00:20:28,170 --> 00:20:32,940
didn't put a semicolon at the end and

00:20:29,820 --> 00:20:34,890
this then not matching the function

00:20:32,940 --> 00:20:38,190
signature and then we're getting an

00:20:34,890 --> 00:20:41,010
interesting type error and python

00:20:38,190 --> 00:20:43,890
mocking is so nice and it's just not as

00:20:41,010 --> 00:20:45,960
easy in rust you don't get the ability

00:20:43,890 --> 00:20:48,870
to monkey patch a function for the

00:20:45,960 --> 00:20:51,150
purpose of testing and I do miss heissen

00:20:48,870 --> 00:20:53,730
sometimes with rust and rust is a little

00:20:51,150 --> 00:20:57,540
bit more verbose anyway so long in

00:20:53,730 --> 00:20:59,550
summary rust is fast the code nearly

00:20:57,540 --> 00:21:01,440
always does exactly what you expected

00:20:59,550 --> 00:21:05,430
the first time you run it and you've

00:21:01,440 --> 00:21:07,140
successfully fought the compiler it has

00:21:05,430 --> 00:21:09,540
great libraries to get things done and

00:21:07,140 --> 00:21:12,270
the quality of code going into such an

00:21:09,540 --> 00:21:15,630
immature language is amazingly high arc

00:21:12,270 --> 00:21:19,190
pass is about the third evolution in

00:21:15,630 --> 00:21:22,350
Python and clap the command line

00:21:19,190 --> 00:21:25,470
processing library in rust is just way

00:21:22,350 --> 00:21:27,930
ahead and lots of things like that

00:21:25,470 --> 00:21:31,410
directly inspired from C++ and Python

00:21:27,930 --> 00:21:36,530
libraries all over the place it really

00:21:31,410 --> 00:21:38,730
fast executables you are I guess a

00:21:36,530 --> 00:21:40,800
parametrized enumerated types are

00:21:38,730 --> 00:21:43,500
probably my favorite thing about rust

00:21:40,800 --> 00:21:45,420
and that's totally stolen from ml the

00:21:43,500 --> 00:21:46,950
bourchek is a great compromise last

00:21:45,420 --> 00:21:53,700
things I met will sit there and say is

00:21:46,950 --> 00:21:56,250
rust is really new 2015 may the 15th was

00:21:53,700 --> 00:21:59,250
the 1.0 release but it's been very

00:21:56,250 --> 00:22:03,510
popular it's got a huge flow following

00:21:59,250 --> 00:22:07,140
on Stack Overflow and while I hear from

00:22:03,510 --> 00:22:11,100
C++ devs that C++ 17 has most of the

00:22:07,140 --> 00:22:12,750
features of rust pi I would say rust is

00:22:11,100 --> 00:22:14,119
much easier to get your head around and

00:22:12,750 --> 00:22:17,149
you don't have to learn all

00:22:14,119 --> 00:22:18,769
things that existed before C++ 17 to

00:22:17,149 --> 00:22:20,149
learn the language and it's really yet

00:22:18,769 --> 00:22:22,189
to disappoint me here are some

00:22:20,149 --> 00:22:24,049
references in the slide here are some

00:22:22,189 --> 00:22:25,309
big companies what they're doing I sat

00:22:24,049 --> 00:22:34,609
there and talked for too long and

00:22:25,309 --> 00:22:36,319
probably run over time so thanks do I

00:22:34,609 --> 00:22:38,739
have time for questions so one or two

00:22:36,319 --> 00:22:38,739
quick questions

00:22:39,099 --> 00:22:43,699
what I have a question so what's the

00:22:41,349 --> 00:22:45,559
time frame for the releases is that

00:22:43,699 --> 00:22:48,019
every three months is a whenever they're

00:22:45,559 --> 00:22:52,429
ready or every six weeks every six weeks

00:22:48,019 --> 00:22:58,509
okay yeah but that's really quite small

00:22:52,429 --> 00:22:58,509
incremental releases any other questions

00:23:00,340 --> 00:23:05,619

YouTube URL: https://www.youtube.com/watch?v=IYLf8lUqR40


