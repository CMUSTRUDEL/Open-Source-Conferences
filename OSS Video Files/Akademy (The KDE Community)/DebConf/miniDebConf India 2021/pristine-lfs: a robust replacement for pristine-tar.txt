Title: pristine-lfs: a robust replacement for pristine-tar
Publication date: 2021-03-20
Playlist: miniDebConf India 2021
Description: 
	by Andrej Shadura

At: MiniDebConf India 2021
https://in2021.mini.debconf.org/talks/4-pristine-lfs-a-robust-replacement-for-pristine-tar/

`pristine-tar` is a magical tool that can regenerate a pristine upstream tarball using only a small binary delta file and a revision control checkout of the upstream branch. Since its creation, itâ€™s become part of the Mercurial- and Git-based workflows of many individual maintainers and teams, as it provides a way to essentially produce Debian source packages using Git-based tooling only, without the need to be able to talk to the archive or a package mirror.

Despite its usefulness, `pristine-tar` suffers from [some inherent drawbacks](https://terceiro.xyz/2017/10/09/pristine-tar-updates/). It attempts to reconstruct output of unknown versions of compressors such as gzip, including all of their quirks and weirdness, generating byte-by-byte identical compressed files. This task is very difficult as compressors evolve and their output changes.

`pristine-lfs` attempts to be a replacement for `pristine-tar`, while attacking the problem in a different way. It utilises the Git LFS mechanism to store the tarballs next to the Git repository in the dedicated file storage. Git LFS is supported by GitLab (and hence by Salsa), GitHub and other online Git hosting providers.

Room: Buzz
Scheduled start: 2021-01-24 17:00:00
Captions: 
	00:00:05,920 --> 00:00:09,200
hello everybody

00:00:07,040 --> 00:00:11,679
welcome to this talk titled pristine

00:00:09,200 --> 00:00:12,160
alphas a robust replacement for pristine

00:00:11,679 --> 00:00:15,440
tar

00:00:12,160 --> 00:00:17,840
by andrew shadera andrew has been

00:00:15,440 --> 00:00:19,600
an active dd since 2013 and maintains

00:00:17,840 --> 00:00:20,240
around 250 packages in the debian

00:00:19,600 --> 00:00:22,400
archive

00:00:20,240 --> 00:00:24,720
he's active in the python java and rust

00:00:22,400 --> 00:00:26,800
teams besides he also likes to package

00:00:24,720 --> 00:00:31,840
some random but interesting things

00:00:26,800 --> 00:00:31,840
so let's hear him out

00:00:34,800 --> 00:00:37,840
hello and welcome uh my name is andre i

00:00:36,800 --> 00:00:39,360
work for collabora

00:00:37,840 --> 00:00:41,200
and in this talk i'm going to tell you

00:00:39,360 --> 00:00:43,440
about pristine lfs

00:00:41,200 --> 00:00:44,320
a replacement for pristine tower i've

00:00:43,440 --> 00:00:46,239
mentioned this

00:00:44,320 --> 00:00:48,160
a couple of times in our previous talks

00:00:46,239 --> 00:00:50,079
already but i've received some questions

00:00:48,160 --> 00:00:52,879
about this tool so i decided to dedicate

00:00:50,079 --> 00:00:54,559
a whole talk to it

00:00:52,879 --> 00:00:56,399
so i'd like to start with a little bit

00:00:54,559 --> 00:00:59,680
of history to

00:00:56,399 --> 00:01:01,280
explain why this tool is needed uh at

00:00:59,680 --> 00:01:01,920
calabrera we developed a debit

00:01:01,280 --> 00:01:04,159
derivative

00:01:01,920 --> 00:01:05,119
called apertus it's built for a minute

00:01:04,159 --> 00:01:07,920
usage

00:01:05,119 --> 00:01:09,360
it was originally based on ubuntu and

00:01:07,920 --> 00:01:12,640
bits and pieces of debian

00:01:09,360 --> 00:01:16,000
and now a custom software and frameworks

00:01:12,640 --> 00:01:19,119
in 2018 it had about

00:01:16,000 --> 00:01:22,960
2 000 packages source packages

00:01:19,119 --> 00:01:26,479
which we built in open build service

00:01:22,960 --> 00:01:30,880
for md64 md arm 64

00:01:26,479 --> 00:01:33,840
and mhf we originally only used

00:01:30,880 --> 00:01:34,799
kit or git based workflows for select

00:01:33,840 --> 00:01:37,360
packages only

00:01:34,799 --> 00:01:40,400
mostly packages we developed ourselves

00:01:37,360 --> 00:01:42,159
or packages like systemd and the kernel

00:01:40,400 --> 00:01:43,520
basically packages where we did some

00:01:42,159 --> 00:01:46,640
significant development

00:01:43,520 --> 00:01:50,079
and we wanted to keep

00:01:46,640 --> 00:01:51,600
changes tracked and get for the rest of

00:01:50,079 --> 00:01:53,920
the packages they were

00:01:51,600 --> 00:01:54,799
stored in open build service using its

00:01:53,920 --> 00:01:59,119
built-in

00:01:54,799 --> 00:02:01,360
version and system in 2019

00:01:59,119 --> 00:02:02,399
came with the big change we decided to

00:02:01,360 --> 00:02:04,560
move to debian

00:02:02,399 --> 00:02:06,240
to stop being a derivative of a

00:02:04,560 --> 00:02:09,280
derivative

00:02:06,240 --> 00:02:11,360
um this made the maintenance easier

00:02:09,280 --> 00:02:12,959
it also allowed us to review and reduce

00:02:11,360 --> 00:02:15,280
the delta we have to

00:02:12,959 --> 00:02:16,080
both ubuntu and debian because it was

00:02:15,280 --> 00:02:18,400
spread across

00:02:16,080 --> 00:02:19,360
all packages we had it was quite

00:02:18,400 --> 00:02:22,239
difficult to

00:02:19,360 --> 00:02:24,640
track it all down we also decided to

00:02:22,239 --> 00:02:27,040
import all packages into git

00:02:24,640 --> 00:02:28,080
and make it the primary source

00:02:27,040 --> 00:02:31,360
generating

00:02:28,080 --> 00:02:34,480
source packages directly from it we

00:02:31,360 --> 00:02:36,160
also moved away from sigit a very

00:02:34,480 --> 00:02:39,680
primitive web interface

00:02:36,160 --> 00:02:40,720
for git and fabricator which we use for

00:02:39,680 --> 00:02:43,760
code reviews

00:02:40,720 --> 00:02:46,400
to git lab this made it possible to

00:02:43,760 --> 00:02:47,599
enable ti for all packages for those who

00:02:46,400 --> 00:02:48,959
don't know what's is continuous

00:02:47,599 --> 00:02:50,640
integration

00:02:48,959 --> 00:02:52,239
so we were able to enable for all

00:02:50,640 --> 00:02:54,400
packages on a purchase

00:02:52,239 --> 00:02:57,200
before that we only used jenkins for

00:02:54,400 --> 00:02:59,280
those packages we already had in git

00:02:57,200 --> 00:03:01,280
and we also used lava which run

00:02:59,280 --> 00:03:04,080
integration tests on complete

00:03:01,280 --> 00:03:04,800
operating system images now with gitlab

00:03:04,080 --> 00:03:07,840
ci we

00:03:04,800 --> 00:03:09,440
we are able to enable ci on each and

00:03:07,840 --> 00:03:12,400
every package we have

00:03:09,440 --> 00:03:13,760
we mostly use it though for testing the

00:03:12,400 --> 00:03:16,800
packages actually can be

00:03:13,760 --> 00:03:20,959
built and also for

00:03:16,800 --> 00:03:20,959
license compliance purposes

00:03:21,440 --> 00:03:25,040
so um open build service which i

00:03:24,000 --> 00:03:27,360
mentioned previously

00:03:25,040 --> 00:03:29,120
it was originally developed by open

00:03:27,360 --> 00:03:30,720
source it was called open source build

00:03:29,120 --> 00:03:34,480
service

00:03:30,720 --> 00:03:36,159
uh it's a web service which combines

00:03:34,480 --> 00:03:38,400
package building infrastructure a bit

00:03:36,159 --> 00:03:42,159
like ad built in debian

00:03:38,400 --> 00:03:44,080
with a github sort of like web ui for

00:03:42,159 --> 00:03:48,480
project management

00:03:44,080 --> 00:03:50,480
and some review tools so users can fork

00:03:48,480 --> 00:03:52,319
packages change them whatever way they

00:03:50,480 --> 00:03:53,920
like build them without affecting the

00:03:52,319 --> 00:03:55,040
main distribution and then submit the

00:03:53,920 --> 00:03:57,200
changes

00:03:55,040 --> 00:03:59,120
to review where they can be merged or

00:03:57,200 --> 00:04:02,159
rejected if they are not

00:03:59,120 --> 00:04:05,920
of good quality enough

00:04:02,159 --> 00:04:07,280
however the uh review tools in obs that

00:04:05,920 --> 00:04:11,200
work best with

00:04:07,280 --> 00:04:14,239
rpms or rpm based workflows

00:04:11,200 --> 00:04:17,440
where the source package is composed or

00:04:14,239 --> 00:04:19,680
consists of a tower ball a text

00:04:17,440 --> 00:04:20,799
spec file and possibly a bunch of

00:04:19,680 --> 00:04:23,919
patches next to them

00:04:20,799 --> 00:04:24,880
all uncompressed in different source

00:04:23,919 --> 00:04:27,520
packages

00:04:24,880 --> 00:04:29,759
uh we have a tower ball in which there's

00:04:27,520 --> 00:04:32,560
the devin packaging

00:04:29,759 --> 00:04:33,520
and the upstream double or maybe many of

00:04:32,560 --> 00:04:36,800
them

00:04:33,520 --> 00:04:39,919
and obs cannot look inside

00:04:36,800 --> 00:04:42,720
of those deb and doubles sometimes it

00:04:39,919 --> 00:04:45,360
can but not always

00:04:42,720 --> 00:04:47,520
so during the reviews it basically

00:04:45,360 --> 00:04:49,840
ignores the content it shows

00:04:47,520 --> 00:04:50,639
that well this double was removed this

00:04:49,840 --> 00:04:53,919
was added

00:04:50,639 --> 00:04:55,520
and that's it mostly so it's not very

00:04:53,919 --> 00:04:59,360
useful for

00:04:55,520 --> 00:05:02,000
reviews or it's not

00:04:59,360 --> 00:05:03,199
the history tracking is not very good in

00:05:02,000 --> 00:05:06,240
it either

00:05:03,199 --> 00:05:07,360
so when something was changed in the

00:05:06,240 --> 00:05:09,840
past

00:05:07,360 --> 00:05:11,680
we probably are able to find the

00:05:09,840 --> 00:05:13,840
revision which introduced the change

00:05:11,680 --> 00:05:15,039
but it's difficult to tell what exactly

00:05:13,840 --> 00:05:18,479
the change was because

00:05:15,039 --> 00:05:21,600
it's mostly not shown um

00:05:18,479 --> 00:05:23,759
branches in obs

00:05:21,600 --> 00:05:25,759
i implemented in a way with like in

00:05:23,759 --> 00:05:28,639
subversion so

00:05:25,759 --> 00:05:30,080
when a user creates new branch it

00:05:28,639 --> 00:05:33,520
basically creates a

00:05:30,080 --> 00:05:35,680
new project linked into another project

00:05:33,520 --> 00:05:39,280
or a new package link into another

00:05:35,680 --> 00:05:42,479
package the original one and the first

00:05:39,280 --> 00:05:44,240
entry in the history is oh this package

00:05:42,479 --> 00:05:47,919
has been branched

00:05:44,240 --> 00:05:48,400
so if the original package or project

00:05:47,919 --> 00:05:50,720
was

00:05:48,400 --> 00:05:52,400
removed it's not possible to see in the

00:05:50,720 --> 00:05:56,160
past and

00:05:52,400 --> 00:06:00,800
see the history of the package anymore

00:05:56,160 --> 00:06:04,720
so on those screenshots you can see

00:06:00,800 --> 00:06:04,720
a typical example of a package which

00:06:04,800 --> 00:06:08,240
which has the history which begins with

00:06:06,639 --> 00:06:11,199
branching

00:06:08,240 --> 00:06:13,600
on the right the typical diff obs goes

00:06:11,199 --> 00:06:16,720
for packages in this case as you can see

00:06:13,600 --> 00:06:19,199
it was able to look inside of the uh

00:06:16,720 --> 00:06:22,000
debian packaging table but only because

00:06:19,199 --> 00:06:24,880
the version of the package didn't change

00:06:22,000 --> 00:06:26,960
so it was able to tell that this package

00:06:24,880 --> 00:06:30,000
indeed

00:06:26,960 --> 00:06:30,560
has some changes inside but if we change

00:06:30,000 --> 00:06:33,199
the

00:06:30,560 --> 00:06:34,639
revision the name of the table would

00:06:33,199 --> 00:06:36,560
change as well

00:06:34,639 --> 00:06:40,479
so obs would completely ignore it and

00:06:36,560 --> 00:06:43,120
just show that oh there's a new table

00:06:40,479 --> 00:06:43,919
so it's quite sub-optimal as you can see

00:06:43,120 --> 00:06:49,039
and

00:06:43,919 --> 00:06:52,319
moving to git was a huge benefit for us

00:06:49,039 --> 00:06:53,039
so we started doing initial tests of

00:06:52,319 --> 00:06:56,639
importing

00:06:53,039 --> 00:06:58,880
everything into git we decided to use

00:06:56,639 --> 00:06:59,680
the 14 branching scheme which was

00:06:58,880 --> 00:07:02,800
proposed by

00:06:59,680 --> 00:07:05,919
rafael herzeg um

00:07:02,800 --> 00:07:06,800
six years ago now it was revised twice

00:07:05,919 --> 00:07:10,160
since then

00:07:06,800 --> 00:07:11,280
it builds on basically git build package

00:07:10,160 --> 00:07:14,800
workflow

00:07:11,280 --> 00:07:15,440
adds in namespaces for multiple upstream

00:07:14,800 --> 00:07:20,080
releases

00:07:15,440 --> 00:07:20,080
debian releases derivatives and so on

00:07:21,039 --> 00:07:29,520
we decided initially to store tables

00:07:24,639 --> 00:07:33,919
using placenta why this is useful

00:07:29,520 --> 00:07:35,440
we want us some guarantees that the

00:07:33,919 --> 00:07:36,960
tower ball is actually

00:07:35,440 --> 00:07:39,440
coming from the upstream hasn't been

00:07:36,960 --> 00:07:41,560
modified in between

00:07:39,440 --> 00:07:42,960
so storing tower balls is good for

00:07:41,560 --> 00:07:46,240
reproducibility

00:07:42,960 --> 00:07:49,440
for a paper trail basically

00:07:46,240 --> 00:07:51,599
and it's also useful to tell that we

00:07:49,440 --> 00:07:54,639
do or don't have any changes compared to

00:07:51,599 --> 00:07:57,120
the same packages from debian

00:07:54,639 --> 00:07:58,720
so in this grand scheme obs would just

00:07:57,120 --> 00:07:59,360
build packages and everything else would

00:07:58,720 --> 00:08:03,680
be in

00:07:59,360 --> 00:08:06,319
git so this is how dev14 looks like

00:08:03,680 --> 00:08:08,160
more or less in debian there's the

00:08:06,319 --> 00:08:10,720
branch for upstream sources

00:08:08,160 --> 00:08:12,960
a branch for the upstream sources

00:08:10,720 --> 00:08:17,199
combined with debian packaging

00:08:12,960 --> 00:08:19,120
each upstream release gets its own tag

00:08:17,199 --> 00:08:21,440
the same goes for deb and package

00:08:19,120 --> 00:08:23,520
releases

00:08:21,440 --> 00:08:25,199
this is their purchase version of depth

00:08:23,520 --> 00:08:28,319
14.

00:08:25,199 --> 00:08:29,599
you get uh another branch for each

00:08:28,319 --> 00:08:33,680
release in this case

00:08:29,599 --> 00:08:36,800
it's a pre-release of 2019

00:08:33,680 --> 00:08:37,760
each uh package version inaudible gets

00:08:36,800 --> 00:08:41,120
its own

00:08:37,760 --> 00:08:44,159
tag with our own suffix

00:08:41,120 --> 00:08:46,720
added sometimes so when we don't have

00:08:44,159 --> 00:08:49,200
any changes we just reuse the debian

00:08:46,720 --> 00:08:51,360
uh package version if we have some local

00:08:49,200 --> 00:08:54,800
changes we need to apply we add

00:08:51,360 --> 00:08:58,959
another increment number

00:08:54,800 --> 00:09:01,120
so um we started hitting

00:08:58,959 --> 00:09:03,200
huge problems with presenter during the

00:09:01,120 --> 00:09:06,399
initial import

00:09:03,200 --> 00:09:09,519
uh sometimes our presenter would

00:09:06,399 --> 00:09:10,160
fail to import the upstream table as you

00:09:09,519 --> 00:09:12,160
can see

00:09:10,160 --> 00:09:14,240
in this case it's exactly tilt which is

00:09:12,160 --> 00:09:18,320
itself an exact

00:09:14,240 --> 00:09:20,959
double um in other cases it

00:09:18,320 --> 00:09:22,640
it would fail to reproduce the turbo or

00:09:20,959 --> 00:09:24,720
it will sometimes reproduce it with a

00:09:22,640 --> 00:09:28,000
different checksum

00:09:24,720 --> 00:09:28,720
in this case it fails all together as

00:09:28,000 --> 00:09:32,000
you can see

00:09:28,720 --> 00:09:32,800
it it would print lots of errors and

00:09:32,000 --> 00:09:36,320
fail

00:09:32,800 --> 00:09:37,200
ultimately so after fighting with this

00:09:36,320 --> 00:09:39,360
for

00:09:37,200 --> 00:09:40,480
quite some time we decided it's not a

00:09:39,360 --> 00:09:42,880
very

00:09:40,480 --> 00:09:45,600
good idea to continue and we need to

00:09:42,880 --> 00:09:48,880
somehow replace pristine tar

00:09:45,600 --> 00:09:52,480
so why those things happen first of all

00:09:48,880 --> 00:09:54,560
president needs to be able to

00:09:52,480 --> 00:09:56,399
reproduce the output of every star

00:09:54,560 --> 00:10:01,760
version ever used

00:09:56,399 --> 00:10:04,240
for tables for packages in debian

00:10:01,760 --> 00:10:05,519
these days there are not many forms of

00:10:04,240 --> 00:10:07,839
tar

00:10:05,519 --> 00:10:09,360
in the past there were different

00:10:07,839 --> 00:10:13,440
historical versions of

00:10:09,360 --> 00:10:14,000
the formers it's already not a very

00:10:13,440 --> 00:10:18,000
trivial

00:10:14,000 --> 00:10:21,519
uh task to support all this format

00:10:18,000 --> 00:10:25,279
but probably doable to some extent

00:10:21,519 --> 00:10:25,279
compressors are worse because

00:10:25,519 --> 00:10:30,480
unlike tar versions they changed its

00:10:28,399 --> 00:10:33,680
seams a bit more

00:10:30,480 --> 00:10:36,160
so it has to be able to reproduce the

00:10:33,680 --> 00:10:37,519
output of every compressor ever used for

00:10:36,160 --> 00:10:40,480
tower balls

00:10:37,519 --> 00:10:41,839
and this battle is never-ending uphill

00:10:40,480 --> 00:10:44,640
battle i'd say

00:10:41,839 --> 00:10:45,040
because compressors change all the time

00:10:44,640 --> 00:10:47,519
and

00:10:45,040 --> 00:10:49,440
sometimes they the output changes

00:10:47,519 --> 00:10:53,200
between versions and

00:10:49,440 --> 00:10:54,160
it's very difficult so how does pristina

00:10:53,200 --> 00:10:57,279
achieve this

00:10:54,160 --> 00:11:00,000
it ships a old suse version of

00:10:57,279 --> 00:11:01,839
zip2 it ships another different outdated

00:11:00,000 --> 00:11:04,880
version of the same compressor

00:11:01,839 --> 00:11:07,120
and it also ships a zedly based

00:11:04,880 --> 00:11:08,800
gzip which is heavily based on net

00:11:07,120 --> 00:11:11,440
business gt

00:11:08,800 --> 00:11:13,040
all of this is combined into something

00:11:11,440 --> 00:11:15,279
the upstream calls

00:11:13,040 --> 00:11:17,200
the frankenstein compressor it's not

00:11:15,279 --> 00:11:19,200
something you are supposed to use

00:11:17,200 --> 00:11:22,560
ever in your life probably unless you

00:11:19,200 --> 00:11:22,560
are a prostitute developer

00:11:22,959 --> 00:11:30,880
so pristinta

00:11:26,839 --> 00:11:34,079
is is a magical tool which

00:11:30,880 --> 00:11:37,519
i'm surprised works it's

00:11:34,079 --> 00:11:41,279
not 100 bulletproof and it can never be

00:11:37,519 --> 00:11:42,079
because because this is ultimately an

00:11:41,279 --> 00:11:44,079
unachievable

00:11:42,079 --> 00:11:45,440
goal it you can only achieve it to some

00:11:44,079 --> 00:11:47,440
degree but

00:11:45,440 --> 00:11:50,240
as things change you need to update

00:11:47,440 --> 00:11:54,240
prestinta all the time and not break

00:11:50,240 --> 00:11:57,519
what it previously done and except

00:11:54,240 --> 00:12:00,000
makes things only worse because um

00:11:57,519 --> 00:12:01,040
people complained about this quite a lot

00:12:00,000 --> 00:12:04,240
uh actually

00:12:01,040 --> 00:12:06,000
exact sometimes even the same

00:12:04,240 --> 00:12:07,440
build of eggs that can produce a

00:12:06,000 --> 00:12:10,639
different bit stream for

00:12:07,440 --> 00:12:14,639
a given input

00:12:10,639 --> 00:12:20,240
so we decided to use

00:12:14,639 --> 00:12:20,240
gtlfs instead of pristine power

00:12:21,279 --> 00:12:25,200
so it has the benefit that it stores

00:12:23,360 --> 00:12:26,959
binaries as is

00:12:25,200 --> 00:12:28,959
there's no need to fight with all the

00:12:26,959 --> 00:12:31,760
new compressors

00:12:28,959 --> 00:12:32,399
it supports it's it's supported by git

00:12:31,760 --> 00:12:34,560
lab

00:12:32,399 --> 00:12:35,519
which for example we use in debian for

00:12:34,560 --> 00:12:37,440
salsa

00:12:35,519 --> 00:12:38,720
and the protocol is quite simple and can

00:12:37,440 --> 00:12:42,000
be easily re-implemented

00:12:38,720 --> 00:12:45,200
if for some reason the implementation we

00:12:42,000 --> 00:12:49,040
have is not suitable

00:12:45,200 --> 00:12:52,079
uh so gitlab works by

00:12:49,040 --> 00:12:55,839
storing binaries in a separate binary

00:12:52,079 --> 00:12:58,639
storage next to a git repository

00:12:55,839 --> 00:12:59,920
both in on the server which is in the

00:12:58,639 --> 00:13:03,920
case of the gitlab

00:12:59,920 --> 00:13:03,920
and locally so it creates

00:13:04,560 --> 00:13:08,240
an object storage inside of the git

00:13:06,399 --> 00:13:10,560
repository where

00:13:08,240 --> 00:13:12,160
the files put and then they upload to

00:13:10,560 --> 00:13:16,800
the server

00:13:12,160 --> 00:13:18,839
so we decided to name tool pristine lfs

00:13:16,800 --> 00:13:20,560
to make it sound familiar to pristin

00:13:18,839 --> 00:13:22,880
thar

00:13:20,560 --> 00:13:26,079
instead of pearl it's written in python

00:13:22,880 --> 00:13:29,920
mostly because i knew python

00:13:26,079 --> 00:13:32,160
it uses the implementation of git lfs

00:13:29,920 --> 00:13:33,760
from guitar fest upstream so the go

00:13:32,160 --> 00:13:35,680
implementation

00:13:33,760 --> 00:13:37,680
it's mostly compatible in terms of

00:13:35,680 --> 00:13:40,240
options with pristine star so you can

00:13:37,680 --> 00:13:42,480
start using it very easily there are

00:13:40,240 --> 00:13:44,399
some differences but

00:13:42,480 --> 00:13:46,399
they are mostly relevant for most

00:13:44,399 --> 00:13:48,800
workflows

00:13:46,399 --> 00:13:51,680
and we've been testing it for two years

00:13:48,800 --> 00:13:51,680
in production

00:13:52,320 --> 00:14:00,480
so um how pristine lfs stores star wars

00:13:56,560 --> 00:14:04,480
so when you import a table

00:14:00,480 --> 00:14:06,399
it creates uh a special file

00:14:04,480 --> 00:14:07,920
gitlerfest basically creates a special

00:14:06,399 --> 00:14:11,279
file in your repository

00:14:07,920 --> 00:14:11,839
a text file mentioning the hash sum of

00:14:11,279 --> 00:14:15,040
your file

00:14:11,839 --> 00:14:17,440
the size and the version of the protocol

00:14:15,040 --> 00:14:18,639
get the first terminology it's called a

00:14:17,440 --> 00:14:21,600
pointer file

00:14:18,639 --> 00:14:23,120
so basically it tells uh git lfs that

00:14:21,600 --> 00:14:25,519
the actual file

00:14:23,120 --> 00:14:27,519
is stored elsewhere and this is the hash

00:14:25,519 --> 00:14:30,399
of it

00:14:27,519 --> 00:14:32,000
um as you can see there are git

00:14:30,399 --> 00:14:35,519
attributes in here

00:14:32,000 --> 00:14:37,279
so github is uses git attributes

00:14:35,519 --> 00:14:39,120
to make sure that the users don't have

00:14:37,279 --> 00:14:41,680
to do extra

00:14:39,120 --> 00:14:43,440
actions to actually work with files so

00:14:41,680 --> 00:14:48,320
it installs

00:14:43,440 --> 00:14:50,800
a special hook which on checkout

00:14:48,320 --> 00:14:51,920
um copies or hard links i'm not sure

00:14:50,800 --> 00:14:53,440
what exactly it is

00:14:51,920 --> 00:14:55,360
but it basically makes the file

00:14:53,440 --> 00:14:57,360
available in a working directory it

00:14:55,360 --> 00:14:59,360
replaces the pointer file

00:14:57,360 --> 00:15:00,639
which is actually stored in in your git

00:14:59,360 --> 00:15:02,480
history

00:15:00,639 --> 00:15:04,079
when you have edited the file for

00:15:02,480 --> 00:15:07,440
example it

00:15:04,079 --> 00:15:10,560
recrea and you committed it it recreates

00:15:07,440 --> 00:15:11,440
the binary object instead inside of the

00:15:10,560 --> 00:15:14,079
git

00:15:11,440 --> 00:15:15,519
lfs object storage inside of the git

00:15:14,079 --> 00:15:17,680
directory

00:15:15,519 --> 00:15:20,079
and when you push it talks to the server

00:15:17,680 --> 00:15:23,600
figures out that oh there's a new object

00:15:20,079 --> 00:15:26,639
and it sends it and the same way if

00:15:23,600 --> 00:15:26,959
you clone a new repository and you don't

00:15:26,639 --> 00:15:28,560
have

00:15:26,959 --> 00:15:30,480
all necessary objects you just have a

00:15:28,560 --> 00:15:34,000
plain git history

00:15:30,480 --> 00:15:35,839
and you want to check it out it realizes

00:15:34,000 --> 00:15:37,759
that this object is not locally

00:15:35,839 --> 00:15:39,519
available it talks to the server then

00:15:37,759 --> 00:15:40,880
loads the object and then proceeds as

00:15:39,519 --> 00:15:43,600
usual

00:15:40,880 --> 00:15:44,000
so this is more or less the mechanism of

00:15:43,600 --> 00:15:47,279
how

00:15:44,000 --> 00:15:48,160
git lfs works so pristine lfs uses this

00:15:47,279 --> 00:15:51,360
mechanism

00:15:48,160 --> 00:15:53,759
it creates the git attributes file just

00:15:51,360 --> 00:15:57,199
for tables

00:15:53,759 --> 00:16:00,000
it also allows storing signatures

00:15:57,199 --> 00:16:02,000
for tower balls they are not using the

00:16:00,000 --> 00:16:03,279
git lfs mechanism they are just stored

00:16:02,000 --> 00:16:06,000
in git

00:16:03,279 --> 00:16:07,279
uh as you can see there's the merge

00:16:06,000 --> 00:16:11,120
setting for binary

00:16:07,279 --> 00:16:14,320
so without this setting um

00:16:11,120 --> 00:16:17,440
git will try to diff binary signatures

00:16:14,320 --> 00:16:19,040
which is pointless and between

00:16:17,440 --> 00:16:21,600
inconvenience so

00:16:19,040 --> 00:16:24,240
this is a more sane default to avoid

00:16:21,600 --> 00:16:24,240
differing them

00:16:25,040 --> 00:16:32,480
pristine lfs doesn't use the ketella

00:16:28,800 --> 00:16:36,560
hooks by default in fact

00:16:32,480 --> 00:16:38,560
it does the necessary manipulations with

00:16:36,560 --> 00:16:41,440
the object itself so it

00:16:38,560 --> 00:16:42,880
commits to the pristine lfs branch

00:16:41,440 --> 00:16:46,000
manually

00:16:42,880 --> 00:16:48,560
um this is to avoid downloading

00:16:46,000 --> 00:16:50,560
extra tables which you don't need if you

00:16:48,560 --> 00:16:51,360
only need to import a table you don't

00:16:50,560 --> 00:16:54,079
need to download

00:16:51,360 --> 00:16:56,160
all of the tables you ever imported and

00:16:54,079 --> 00:16:57,519
this is exactly what gitlab will do by

00:16:56,160 --> 00:17:00,800
default

00:16:57,519 --> 00:17:04,079
so um

00:17:00,800 --> 00:17:06,319
the git hook would only work and

00:17:04,079 --> 00:17:09,120
download all doubles if you actually

00:17:06,319 --> 00:17:10,079
try to check out the pristine lfs branch

00:17:09,120 --> 00:17:13,839
which you don't

00:17:10,079 --> 00:17:17,039
normally need to so as i mentioned

00:17:13,839 --> 00:17:18,240
um precinta is mostly compatible with

00:17:17,039 --> 00:17:21,120
pristine lfs or

00:17:18,240 --> 00:17:22,720
actually the other way around so um

00:17:21,120 --> 00:17:25,919
pristina has some

00:17:22,720 --> 00:17:25,919
sub commands for

00:17:27,199 --> 00:17:31,200
taobao specifically stored in its delta

00:17:30,000 --> 00:17:34,400
protocol which

00:17:31,200 --> 00:17:36,880
we don't need so

00:17:34,400 --> 00:17:39,039
those commands are not included there's

00:17:36,880 --> 00:17:42,400
also there was also a verify step

00:17:39,039 --> 00:17:46,320
command which we also don't need because

00:17:42,400 --> 00:17:50,080
there is no double recreation um

00:17:46,320 --> 00:17:53,440
doubles are being addressed in guitar fs

00:17:50,080 --> 00:17:55,760
by the checksum so it's guaranteed that

00:17:53,440 --> 00:17:57,120
the checksum of the table will match the

00:17:55,760 --> 00:17:58,799
checksum of the tables stored on

00:17:57,120 --> 00:18:02,000
pristinafest branch so

00:17:58,799 --> 00:18:02,880
the verify command is not needed there's

00:18:02,000 --> 00:18:05,919
a new command

00:18:02,880 --> 00:18:09,200
uh import dsc which is

00:18:05,919 --> 00:18:11,679
just a convenience tool

00:18:09,200 --> 00:18:14,240
to automatically import all tables

00:18:11,679 --> 00:18:16,160
mentioned in a dsc file

00:18:14,240 --> 00:18:19,760
just to make the life easier to save

00:18:16,160 --> 00:18:19,760
your commands and all that

00:18:19,919 --> 00:18:24,480
so pristine

00:18:23,120 --> 00:18:26,840
is a little bit easier to use than

00:18:24,480 --> 00:18:29,840
pristina

00:18:26,840 --> 00:18:32,160
because uh we've added some options to

00:18:29,840 --> 00:18:33,760
simplify the usage for example the

00:18:32,160 --> 00:18:37,760
author option

00:18:33,760 --> 00:18:39,919
for checkout.subcommand automatically

00:18:37,760 --> 00:18:41,120
finds the version which you need to

00:18:39,919 --> 00:18:43,520
check out

00:18:41,120 --> 00:18:45,679
by inspecting the dev and change log

00:18:43,520 --> 00:18:48,640
available on the current branch

00:18:45,679 --> 00:18:49,919
so you don't actually need to list the

00:18:48,640 --> 00:18:53,600
tables

00:18:49,919 --> 00:18:56,000
and check out one specific table version

00:18:53,600 --> 00:18:58,000
you need so you just go on to the branch

00:18:56,000 --> 00:18:58,640
with your packaging in this case it's a

00:18:58,000 --> 00:19:01,679
purchase

00:18:58,640 --> 00:19:03,520
2020 dev one and you tell it to

00:19:01,679 --> 00:19:06,160
automatically check out the latest one

00:19:03,520 --> 00:19:06,160
which it does

00:19:06,720 --> 00:19:14,240
um so this is how import scene works

00:19:10,799 --> 00:19:16,799
you can just give it a dc file and it

00:19:14,240 --> 00:19:19,120
sees that there's the table and in it

00:19:16,799 --> 00:19:20,960
imports it automatically

00:19:19,120 --> 00:19:22,400
you can also import the whole source

00:19:20,960 --> 00:19:25,679
package if you want

00:19:22,400 --> 00:19:26,880
so if you pass the full option it also

00:19:25,679 --> 00:19:30,160
impose the

00:19:26,880 --> 00:19:31,440
debian packaging table and also the dsc

00:19:30,160 --> 00:19:34,880
file itself

00:19:31,440 --> 00:19:39,200
and probably any signatures if you

00:19:34,880 --> 00:19:42,720
have on it on the table i mean

00:19:39,200 --> 00:19:44,480
so this is useful uh for

00:19:42,720 --> 00:19:45,919
a specific workflow we have in a

00:19:44,480 --> 00:19:48,400
purchase

00:19:45,919 --> 00:19:49,600
we want source packages to be consistent

00:19:48,400 --> 00:19:52,880
across releases

00:19:49,600 --> 00:19:54,960
and by consistent i mean having

00:19:52,880 --> 00:19:58,160
identical checksums

00:19:54,960 --> 00:20:01,280
so we have a shared pool

00:19:58,160 --> 00:20:04,880
of packages between releases

00:20:01,280 --> 00:20:06,960
so we obviously want to reuse the tower

00:20:04,880 --> 00:20:09,600
balls between different releases

00:20:06,960 --> 00:20:11,120
we want them to all be the same have the

00:20:09,600 --> 00:20:15,280
same checksum

00:20:11,120 --> 00:20:18,400
we want to duplicate the pool obviously

00:20:15,280 --> 00:20:21,520
but if we rebuild

00:20:18,400 --> 00:20:24,720
whole packages from scratch each time

00:20:21,520 --> 00:20:26,799
the check sums of the uh

00:20:24,720 --> 00:20:28,880
towels may change the debian table most

00:20:26,799 --> 00:20:31,360
importantly

00:20:28,880 --> 00:20:32,720
uh while this doesn't happen often it

00:20:31,360 --> 00:20:35,840
sometimes does happen

00:20:32,720 --> 00:20:37,840
and then packages failed to

00:20:35,840 --> 00:20:41,679
propagate to repositories and we need to

00:20:37,840 --> 00:20:45,039
manually copy them from other releases

00:20:41,679 --> 00:20:47,440
so we've created

00:20:45,039 --> 00:20:48,080
a special machinery to prevent this from

00:20:47,440 --> 00:20:49,919
happening

00:20:48,080 --> 00:20:51,520
and to ensure that source packages are

00:20:49,919 --> 00:20:54,720
the same everywhere

00:20:51,520 --> 00:20:59,039
i'll explain how this works so this is

00:20:54,720 --> 00:21:01,679
uh how branches look in a typical

00:20:59,039 --> 00:21:02,320
alberta's package so the there are the

00:21:01,679 --> 00:21:04,080
standard

00:21:02,320 --> 00:21:06,720
therefore in branches we have for

00:21:04,080 --> 00:21:09,280
upstream packages or upstream source

00:21:06,720 --> 00:21:11,120
debian source and aperture source and

00:21:09,280 --> 00:21:12,159
there's also an extra branch for

00:21:11,120 --> 00:21:15,280
pristine lfs

00:21:12,159 --> 00:21:16,480
information which has the pointy files

00:21:15,280 --> 00:21:19,520
referring to

00:21:16,480 --> 00:21:20,480
the tables stored somewhere in the

00:21:19,520 --> 00:21:24,640
object storage

00:21:20,480 --> 00:21:27,840
of gitlab the

00:21:24,640 --> 00:21:33,039
ci machinery takes that

00:21:27,840 --> 00:21:33,039
source of the purchase branch

00:21:33,280 --> 00:21:40,080
downloads the tarball from

00:21:36,720 --> 00:21:42,320
the lfs storage using pristine lfs

00:21:40,080 --> 00:21:43,679
builds the source package and uploads it

00:21:42,320 --> 00:21:46,799
all to

00:21:43,679 --> 00:21:50,480
obs where it gets built for all

00:21:46,799 --> 00:21:53,679
architectures we support in a purchase

00:21:50,480 --> 00:21:57,360
when the upload has completed it takes

00:21:53,679 --> 00:22:00,640
the generated guitar balls

00:21:57,360 --> 00:22:01,039
and commits them all to a new pristinal

00:22:00,640 --> 00:22:03,550
first

00:22:01,039 --> 00:22:04,799
source branch in

00:22:03,550 --> 00:22:07,919
[Music]

00:22:04,799 --> 00:22:11,280
the repository for the package

00:22:07,919 --> 00:22:14,320
and push the branch uploading all the

00:22:11,280 --> 00:22:17,679
objects with it so the next time

00:22:14,320 --> 00:22:18,320
uh the package is uploaded to a

00:22:17,679 --> 00:22:21,039
different

00:22:18,320 --> 00:22:22,559
release of a purchase it's not

00:22:21,039 --> 00:22:23,679
completely revealed from scratch but

00:22:22,559 --> 00:22:25,600
instead the

00:22:23,679 --> 00:22:27,760
demon source package is checked out

00:22:25,600 --> 00:22:30,720
directly from the

00:22:27,760 --> 00:22:33,039
pristine lfs source branch and uploaded

00:22:30,720 --> 00:22:34,240
to obs

00:22:33,039 --> 00:22:36,480
we could have done it differently

00:22:34,240 --> 00:22:40,480
obviously we could have gone to

00:22:36,480 --> 00:22:42,159
obs and could have copied uh the package

00:22:40,480 --> 00:22:45,440
directly at the obvious level

00:22:42,159 --> 00:22:47,440
or we could probably store all

00:22:45,440 --> 00:22:48,799
packages we've ever generated somewhere

00:22:47,440 --> 00:22:51,760
else but

00:22:48,799 --> 00:22:52,320
this is the easiest way uh the simplest

00:22:51,760 --> 00:22:54,640
way we

00:22:52,320 --> 00:22:56,559
we came up with and it works and it's

00:22:54,640 --> 00:22:58,880
easy to support within pristine effect

00:22:56,559 --> 00:22:58,880
itself

00:22:59,200 --> 00:23:03,520
so i've been using pristine lfs in

00:23:01,520 --> 00:23:04,960
debian for some time already for my

00:23:03,520 --> 00:23:07,679
packages

00:23:04,960 --> 00:23:09,039
and i tried to also use it for some team

00:23:07,679 --> 00:23:10,480
maintained packages but

00:23:09,039 --> 00:23:12,799
there was a little bit of backlash

00:23:10,480 --> 00:23:16,159
because people aren't familiar with it

00:23:12,799 --> 00:23:19,679
and the pristine thar usually works but

00:23:16,159 --> 00:23:20,559
i um i would love to see priscilla fest

00:23:19,679 --> 00:23:23,600
used

00:23:20,559 --> 00:23:24,799
more widely in debian because it has

00:23:23,600 --> 00:23:26,720
certain benefits

00:23:24,799 --> 00:23:28,480
over prestinta it's more reliable more

00:23:26,720 --> 00:23:31,600
robust

00:23:28,480 --> 00:23:32,400
it does require server support for git

00:23:31,600 --> 00:23:35,120
lfs

00:23:32,400 --> 00:23:37,600
but since we use uh gitlab for salsa we

00:23:35,120 --> 00:23:39,600
get it for free

00:23:37,600 --> 00:23:41,440
it doesn't work fully offline like

00:23:39,600 --> 00:23:44,320
priscinta because it doesn't have all

00:23:41,440 --> 00:23:46,960
the information on git branches

00:23:44,320 --> 00:23:48,320
if you need to check out some table you

00:23:46,960 --> 00:23:50,559
need to download the

00:23:48,320 --> 00:23:51,679
corresponding binary object first into

00:23:50,559 --> 00:23:55,039
the

00:23:51,679 --> 00:23:55,600
local object storage so before going on

00:23:55,039 --> 00:23:58,799
the plane

00:23:55,600 --> 00:24:01,360
you need to synchronize

00:23:58,799 --> 00:24:03,279
the object storage and then you can work

00:24:01,360 --> 00:24:04,720
with the dowels

00:24:03,279 --> 00:24:06,559
you don't need to do that obviously with

00:24:04,720 --> 00:24:07,919
precinta you just need to have the

00:24:06,559 --> 00:24:10,159
necessary branches because it will

00:24:07,919 --> 00:24:13,840
recreate the tub all unless it doesn't

00:24:10,159 --> 00:24:16,720
and the checksum is different obviously

00:24:13,840 --> 00:24:17,200
at the moment there's still no git build

00:24:16,720 --> 00:24:20,880
package

00:24:17,200 --> 00:24:23,840
and integration yet um

00:24:20,880 --> 00:24:24,559
it is quite simple to create i guess

00:24:23,840 --> 00:24:28,000
because

00:24:24,559 --> 00:24:29,120
uh in any case pristine lfs is mostly

00:24:28,000 --> 00:24:32,080
option compatible

00:24:29,120 --> 00:24:33,520
with pristine tile so we can just copy

00:24:32,080 --> 00:24:36,480
paste necessary lines but

00:24:33,520 --> 00:24:36,799
there's an easier easier and better way

00:24:36,480 --> 00:24:39,279
uh

00:24:36,799 --> 00:24:42,000
priscilla faster written required and so

00:24:39,279 --> 00:24:43,799
its functions can be used directly from

00:24:42,000 --> 00:24:46,400
git build package which is also in

00:24:43,799 --> 00:24:50,240
python um so

00:24:46,400 --> 00:24:51,200
um feel free to install pristine left

00:24:50,240 --> 00:24:54,559
and play with it

00:24:51,200 --> 00:24:57,120
uh the code is up on salsa uh

00:24:54,559 --> 00:24:58,960
so you can hack on it if you like um i'm

00:24:57,120 --> 00:25:02,720
planning the release

00:24:58,960 --> 00:25:05,919
next week i guess with a couple of

00:25:02,720 --> 00:25:09,279
fixes and usability improvements

00:25:05,919 --> 00:25:13,039
and i'd love to hear your

00:25:09,279 --> 00:25:16,080
feedback so

00:25:13,039 --> 00:25:19,520
thank you very much for listening um

00:25:16,080 --> 00:25:22,320
i just like to know that we are hiring

00:25:19,520 --> 00:25:23,760
and we as you can see on this slide we

00:25:22,320 --> 00:25:25,600
love debian and we use it a lot in

00:25:23,760 --> 00:25:28,320
calabrera

00:25:25,600 --> 00:25:28,960
and that's it i'd love to answer your

00:25:28,320 --> 00:25:32,799
questions

00:25:28,960 --> 00:25:32,799
after the talk thank you

00:25:37,600 --> 00:25:39,919
okay

00:25:41,039 --> 00:25:44,880
thank you for the great talk andre this

00:25:43,200 --> 00:25:47,679
was really interesting

00:25:44,880 --> 00:25:49,279
and uh we have further questions from a

00:25:47,679 --> 00:25:51,440
couple of people

00:25:49,279 --> 00:25:53,120
um so i'll just read out the questions

00:25:51,440 --> 00:25:56,159
for you and you can answer them

00:25:53,120 --> 00:25:58,640
as we go so the first question is

00:25:56,159 --> 00:26:01,039
um how would you envision envision a

00:25:58,640 --> 00:26:02,720
mass migration to pristine lfs

00:26:01,039 --> 00:26:05,120
of a team that has been using pristine

00:26:02,720 --> 00:26:07,919
tower so far

00:26:05,120 --> 00:26:08,559
uh well um i'm not sure what exactly

00:26:07,919 --> 00:26:12,000
would be my

00:26:08,559 --> 00:26:16,000
migration uh i guess switch all packages

00:26:12,000 --> 00:26:17,679
uh from pristina to prison fest yeah

00:26:16,000 --> 00:26:19,360
let's say the ruby team is using uh

00:26:17,679 --> 00:26:21,440
pristine tar for like a bunch of

00:26:19,360 --> 00:26:22,400
packages like around 1400 bucks how

00:26:21,440 --> 00:26:24,720
would you use

00:26:22,400 --> 00:26:26,159
migration from using pristine star to

00:26:24,720 --> 00:26:29,039
pristine elephant

00:26:26,159 --> 00:26:30,640
so i initially i i wasn't thinking about

00:26:29,039 --> 00:26:33,760
a mass migration as such

00:26:30,640 --> 00:26:36,559
but more of uh so so

00:26:33,760 --> 00:26:38,320
my idea was that we don't switch all

00:26:36,559 --> 00:26:41,120
existing tower balls which

00:26:38,320 --> 00:26:42,960
work to pretend like that we just start

00:26:41,120 --> 00:26:44,480
with pretend lfs for new tower balls and

00:26:42,960 --> 00:26:47,279
we probably keep the old ones

00:26:44,480 --> 00:26:48,080
in precinct if we want to so there's

00:26:47,279 --> 00:26:51,360
technically

00:26:48,080 --> 00:26:54,799
so if the old towels can be checked out

00:26:51,360 --> 00:26:56,960
with presents are just fine

00:26:54,799 --> 00:26:58,559
as well as long as this works we

00:26:56,960 --> 00:26:59,360
probably can keep them but if we wanted

00:26:58,559 --> 00:27:01,520
to

00:26:59,360 --> 00:27:03,200
do a mass migration probably the easiest

00:27:01,520 --> 00:27:06,000
way would be to

00:27:03,200 --> 00:27:06,480
what check out all of doubles from check

00:27:06,000 --> 00:27:09,039
them in

00:27:06,480 --> 00:27:09,679
into christian love s i guess that's

00:27:09,039 --> 00:27:12,880
that would be

00:27:09,679 --> 00:27:16,400
uh more or less 10 lines long script

00:27:12,880 --> 00:27:19,840
or something um

00:27:16,400 --> 00:27:20,880
someone's writing oh yeah yeah obviously

00:27:19,840 --> 00:27:26,000
pulling towels from

00:27:20,880 --> 00:27:28,240
from from snapshots also would work

00:27:26,000 --> 00:27:28,240
um

00:27:30,000 --> 00:27:33,520
yeah yeah yeah that's where you using

00:27:32,240 --> 00:27:34,960
the ones they match

00:27:33,520 --> 00:27:37,919
once they were sent to the archive in

00:27:34,960 --> 00:27:39,600
the first place yeah

00:27:37,919 --> 00:27:41,440
that way we can yeah absolutely to show

00:27:39,600 --> 00:27:42,159
that they are actually those tables

00:27:41,440 --> 00:27:46,000
which

00:27:42,159 --> 00:27:48,799
which we want to use right

00:27:46,000 --> 00:27:50,000
okay so the next question is how can

00:27:48,799 --> 00:27:52,080
christine alphys

00:27:50,000 --> 00:27:53,200
be implemented in pre-existing debt

00:27:52,080 --> 00:27:56,640
packages that we have

00:27:53,200 --> 00:27:59,279
is the conversion handy i'm

00:27:56,640 --> 00:28:01,200
not quite sure oh yeah but probably the

00:27:59,279 --> 00:28:03,919
extension of the previous question

00:28:01,200 --> 00:28:04,320
at the moment there isn't uh any script

00:28:03,919 --> 00:28:07,360
to

00:28:04,320 --> 00:28:09,600
to the conversion if someone

00:28:07,360 --> 00:28:12,720
needs it obviously it can be written it

00:28:09,600 --> 00:28:16,320
should be very easy to do so

00:28:12,720 --> 00:28:17,440
documentation um well there's a mount

00:28:16,320 --> 00:28:21,279
page which is

00:28:17,440 --> 00:28:23,520
slightly uh i tried to make

00:28:21,279 --> 00:28:26,240
the one page for priscilla fest better

00:28:23,520 --> 00:28:28,960
than the one page for precinta and also

00:28:26,240 --> 00:28:29,679
the same goes for the common line help

00:28:28,960 --> 00:28:32,320
um

00:28:29,679 --> 00:28:34,640
i'm not sure i succeeded but i guess

00:28:32,320 --> 00:28:37,600
that's one page is something that can

00:28:34,640 --> 00:28:37,600
we can start from

00:28:37,919 --> 00:28:41,840
but there's no more documentation except

00:28:40,240 --> 00:28:43,279
the one page unfortunately and they talk

00:28:41,840 --> 00:28:46,320
i guess

00:28:43,279 --> 00:28:47,840
um sure i mean i'll just uh quickly link

00:28:46,320 --> 00:28:51,200
the main page here

00:28:47,840 --> 00:28:54,000
uh so okay so everybody can see the

00:28:51,200 --> 00:28:54,000
documentation

00:28:54,960 --> 00:28:58,399
okay so yeah i mean the next question

00:28:56,960 --> 00:29:00,399
was uh

00:28:58,399 --> 00:29:02,080
like exactly the extension to what you

00:29:00,399 --> 00:29:04,240
answered is there any documentation

00:29:02,080 --> 00:29:06,080
that we can refer to for using pristine

00:29:04,240 --> 00:29:07,200
rfs if you're building a package from

00:29:06,080 --> 00:29:09,279
scratch

00:29:07,200 --> 00:29:11,200
furthermore as an extension to the above

00:29:09,279 --> 00:29:13,039
questions is there any documentation

00:29:11,200 --> 00:29:15,440
or something that would help with the

00:29:13,039 --> 00:29:17,600
migration from pristina to pristine

00:29:15,440 --> 00:29:18,480
office so at the moment we have this man

00:29:17,600 --> 00:29:22,720
page

00:29:18,480 --> 00:29:24,159
but do we have anything more other than

00:29:22,720 --> 00:29:26,480
that

00:29:24,159 --> 00:29:27,840
uh i guess the git version of the man

00:29:26,480 --> 00:29:30,240
page is slightly better than

00:29:27,840 --> 00:29:32,320
the one you actually linked to but other

00:29:30,240 --> 00:29:35,760
than that not really

00:29:32,320 --> 00:29:38,799
oh not yet not yet

00:29:35,760 --> 00:29:40,799
all right so um we've got

00:29:38,799 --> 00:29:42,320
a bunch of more questions are there

00:29:40,799 --> 00:29:44,880
patches to add support

00:29:42,320 --> 00:29:46,640
for pristine lfs and get built package i

00:29:44,880 --> 00:29:51,679
suppose this would help the

00:29:46,640 --> 00:29:55,279
drive adoption yeah um

00:29:51,679 --> 00:29:56,320
so uh as in uh git build package support

00:29:55,279 --> 00:29:59,360
it's been a long

00:29:56,320 --> 00:30:01,120
uh uh so it's it's been something i

00:29:59,360 --> 00:30:02,799
wanted to do for a long time

00:30:01,120 --> 00:30:05,200
since basically pretend lfs was

00:30:02,799 --> 00:30:06,000
conceived unfortunately it's something i

00:30:05,200 --> 00:30:10,080
never found

00:30:06,000 --> 00:30:13,440
really time for because uh so

00:30:10,080 --> 00:30:14,799
basically i run into it each time when i

00:30:13,440 --> 00:30:16,799
want to use good build package with

00:30:14,799 --> 00:30:17,679
brazilian fs i have to run extra

00:30:16,799 --> 00:30:19,200
commands

00:30:17,679 --> 00:30:22,480
i was like okay i need to find time for

00:30:19,200 --> 00:30:25,760
this hey and so far it hasn't happened

00:30:22,480 --> 00:30:27,600
but i guess uh it shouldn't be difficult

00:30:25,760 --> 00:30:28,240
as i said it and i i should find time

00:30:27,600 --> 00:30:31,679
for this

00:30:28,240 --> 00:30:34,720
one one day um i didn't

00:30:31,679 --> 00:30:36,880
support into original gizet sounds

00:30:34,720 --> 00:30:38,320
interesting i haven't thought of that

00:30:36,880 --> 00:30:40,960
actually

00:30:38,320 --> 00:30:42,240
um but presenter versus personal fast

00:30:40,960 --> 00:30:44,640
actually is an interesting thing

00:30:42,240 --> 00:30:45,919
so i was actually thinking about this um

00:30:44,640 --> 00:30:48,399
so right at the moment

00:30:45,919 --> 00:30:49,440
there is a switch in get the build

00:30:48,399 --> 00:30:53,279
package for

00:30:49,440 --> 00:30:55,120
to enable presenta so my first idea was

00:30:53,279 --> 00:30:56,480
to add another switch for precisionlfs

00:30:55,120 --> 00:30:59,519
but then

00:30:56,480 --> 00:31:00,960
what gbp will do if they are both and

00:30:59,519 --> 00:31:04,080
both enabled

00:31:00,960 --> 00:31:05,279
or should maybe we have some universal

00:31:04,080 --> 00:31:08,399
switch which

00:31:05,279 --> 00:31:12,000
allows using percent of s if it exists

00:31:08,399 --> 00:31:14,320
and if not if it falls back to precenter

00:31:12,000 --> 00:31:16,480
i guess that's something to be something

00:31:14,320 --> 00:31:20,399
to think about and probably discuss with

00:31:16,480 --> 00:31:23,919
the gbp maintainer

00:31:20,399 --> 00:31:27,200
cool so um

00:31:23,919 --> 00:31:29,200
the next question is uh would it be

00:31:27,200 --> 00:31:30,159
possible to make pristine tar versus

00:31:29,200 --> 00:31:31,919
pristine alphas

00:31:30,159 --> 00:31:34,000
yeah that's what i was talking about

00:31:31,919 --> 00:31:37,279
right now okay okay

00:31:34,000 --> 00:31:38,320
cool uh also yeah i mean there's there's

00:31:37,279 --> 00:31:41,679
another point about

00:31:38,320 --> 00:31:43,279
um adding support for pristine alps into

00:31:41,679 --> 00:31:46,960
our guitars

00:31:43,279 --> 00:31:50,000
um so uh the next question we have

00:31:46,960 --> 00:31:53,679
from irc is um is pristine

00:31:50,000 --> 00:31:56,320
first back portable to buster

00:31:53,679 --> 00:31:56,880
uh i to be honest i thought it was in

00:31:56,320 --> 00:31:58,640
bastro

00:31:56,880 --> 00:32:00,320
already but i guess i might have may

00:31:58,640 --> 00:32:03,519
have missed it

00:32:00,320 --> 00:32:06,080
uh um for

00:32:03,519 --> 00:32:07,039
i thought it was in boston let me check

00:32:06,080 --> 00:32:08,960
uh it should be

00:32:07,039 --> 00:32:10,559
no no it wasn't it was released after

00:32:08,960 --> 00:32:13,760
that see yeah obviously it is

00:32:10,559 --> 00:32:15,039
back portable uh i think actually

00:32:13,760 --> 00:32:16,640
depends on python

00:32:15,039 --> 00:32:18,480
depends on the version of python we have

00:32:16,640 --> 00:32:22,080
in in

00:32:18,480 --> 00:32:24,799
uh buster so i think i

00:32:22,080 --> 00:32:26,320
i'm using some features of python 3.6

00:32:24,799 --> 00:32:29,840
yeah it's python 3.7

00:32:26,320 --> 00:32:33,360
in in boston so i guess it should work

00:32:29,840 --> 00:32:36,880
unless um yeah uh there was one

00:32:33,360 --> 00:32:38,799
issue in basta uh which we had to work

00:32:36,880 --> 00:32:41,279
around in apatis because apparatus is

00:32:38,799 --> 00:32:43,760
based on buster

00:32:41,279 --> 00:32:44,799
so we had to pull a new version of gitel

00:32:43,760 --> 00:32:47,760
of s because

00:32:44,799 --> 00:32:49,440
the one in buster was at that point

00:32:47,760 --> 00:32:52,559
buggy i'm not sure i may have

00:32:49,440 --> 00:32:53,600
reported it actually but it was doing

00:32:52,559 --> 00:32:57,200
this thing

00:32:53,600 --> 00:33:00,640
is that so when you were pushing

00:32:57,200 --> 00:33:03,600
a branch a guitar first branch

00:33:00,640 --> 00:33:05,840
a branch with git lfs objects uh uh to

00:33:03,600 --> 00:33:10,080
the server

00:33:05,840 --> 00:33:12,640
it would try to find all of the uh

00:33:10,080 --> 00:33:13,919
binary blobs mentioned on that branch

00:33:12,640 --> 00:33:16,320
and if

00:33:13,919 --> 00:33:18,240
one of them was missing it would fail

00:33:16,320 --> 00:33:20,640
which is a typical situation when you

00:33:18,240 --> 00:33:21,360
import a new table so you just you check

00:33:20,640 --> 00:33:24,080
out the guitar

00:33:21,360 --> 00:33:25,039
you call it a github poster you check in

00:33:24,080 --> 00:33:27,039
the new

00:33:25,039 --> 00:33:28,240
table so this is the only object in your

00:33:27,039 --> 00:33:30,559
local storage

00:33:28,240 --> 00:33:32,080
and you push just to submit it you don't

00:33:30,559 --> 00:33:32,880
want to download everything before

00:33:32,080 --> 00:33:34,240
pushing

00:33:32,880 --> 00:33:36,000
and getting the first would fail in that

00:33:34,240 --> 00:33:39,519
case because you say our

00:33:36,000 --> 00:33:41,840
objects are missing can't proceed uh

00:33:39,519 --> 00:33:42,559
so gitel of s needs to be backwarded to

00:33:41,840 --> 00:33:45,679
buster

00:33:42,559 --> 00:33:47,440
i guess unless they already did that i

00:33:45,679 --> 00:33:48,000
remember wanted to do that but maybe i

00:33:47,440 --> 00:33:51,120
stopped when

00:33:48,000 --> 00:33:54,559
it was in a purchase already so

00:33:51,120 --> 00:33:57,279
um so that's i guess the the answer

00:33:54,559 --> 00:33:57,919
oh okay so um the person who asked the

00:33:57,279 --> 00:34:01,279
question

00:33:57,919 --> 00:34:03,600
also mentioned that so i checked uh yeah

00:34:01,279 --> 00:34:04,640
and it's not there yeah yeah yeah i

00:34:03,600 --> 00:34:07,919
checked myself

00:34:04,640 --> 00:34:10,639
while talking about this so yeah yeah

00:34:07,919 --> 00:34:11,679
yeah also i think the uh version of

00:34:10,639 --> 00:34:14,560
python

00:34:11,679 --> 00:34:15,359
and buster is 3.7 yeah it should be fine

00:34:14,560 --> 00:34:19,359
i guess

00:34:15,359 --> 00:34:22,320
yeah yeah guitar fs

00:34:19,359 --> 00:34:22,960
is yeah git love s in stable back pause

00:34:22,320 --> 00:34:25,280
is

00:34:22,960 --> 00:34:26,079
more or less up to date it should work

00:34:25,280 --> 00:34:29,359
uh so

00:34:26,079 --> 00:34:32,480
yeah so it should be really

00:34:29,359 --> 00:34:34,800
relatively easy to walk forward

00:34:32,480 --> 00:34:36,000
okay so do you plan to work on

00:34:34,800 --> 00:34:41,119
backboarding this

00:34:36,000 --> 00:34:43,919
yeah why not sure sounds great

00:34:41,119 --> 00:34:45,119
okay i think we do not have any more

00:34:43,919 --> 00:34:48,000
questions at the moment

00:34:45,119 --> 00:34:49,760
um we can just wait for a minute in case

00:34:48,000 --> 00:34:53,440
anybody has a question

00:34:49,760 --> 00:34:53,440
and then we'll wrap up the stairs

00:34:54,240 --> 00:34:59,760
oh yeah he um he says that

00:34:57,440 --> 00:35:02,480
git lfs has been backboarded so it

00:34:59,760 --> 00:35:02,480

YouTube URL: https://www.youtube.com/watch?v=UdWXjK-4iQ8


