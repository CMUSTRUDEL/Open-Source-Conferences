Title: What's new in the Linux kernel (and what's missing in Debian)
Publication date: 2019-08-06
Playlist: DebConf 19
Description: 
	by Ben Hutchings

At: DebConf19
https://debconf19.debconf.org/talks/83-whats-new-in-the-linux-kernel-and-whats-missing-in-debian/

The Linux kernel has a very active development community, constantly adding not only new hardware support but new features. Some of these features can simply be enabled by the configuration in the Debian package, but some also require support from other user-space packages. This talk will cover some of the more interesting changes made in the past year, and any work that's still needed to support these in Debian.

Room: MiniauditÃ³rio
Scheduled start: 2019-07-22 11:00:00
Captions: 
	00:00:04,780 --> 00:00:11,110
hello the next speaker is me as you can

00:00:08,680 --> 00:00:12,970
see I am a softly spoken Englishman who

00:00:11,110 --> 00:00:17,439
knows things about the colonel in this

00:00:12,970 --> 00:00:19,810
talk I will as you can see the next

00:00:17,439 --> 00:00:21,310
speaker is not physically present we're

00:00:19,810 --> 00:00:23,289
going to try and do this remotely he's

00:00:21,310 --> 00:00:28,029
back in Manchester

00:00:23,289 --> 00:00:30,550
so video team is very pleased to try to

00:00:28,029 --> 00:00:32,110
present your casual acquaintance and

00:00:30,550 --> 00:00:36,420
mine then Hutchings

00:00:32,110 --> 00:00:36,420
doing the colonel talk I hope he's here

00:00:37,290 --> 00:00:40,680
one of these days

00:00:44,469 --> 00:00:54,650
there is hi good morning Curitiba

00:00:51,160 --> 00:00:54,650
[Applause]

00:01:02,140 --> 00:01:07,210
okay I'll briefly introduce myself

00:01:09,920 --> 00:01:17,259
av team I'm hearing myself echoing over

00:01:13,220 --> 00:01:17,259
jitsi so could you turn that down please

00:01:21,430 --> 00:01:27,560
so I've been working on the Linux kernel

00:01:24,890 --> 00:01:30,259
and various related packages for Debian

00:01:27,560 --> 00:01:33,380
and in my paid jobs for over ten years

00:01:30,259 --> 00:01:36,350
now I'm a member of the Debian Linux

00:01:33,380 --> 00:01:38,539
kernel team and the LTS team I'm doing

00:01:36,350 --> 00:01:43,789
about half of the kernel packaging work

00:01:38,539 --> 00:01:47,569
and all of the Linux making this work

00:01:43,789 --> 00:01:52,039
for LCS I also maintained a then it's

00:01:47,569 --> 00:01:58,250
3.16 stable update series on cog because

00:01:52,039 --> 00:01:59,929
that's used in Debian 8 Jessie as you

00:01:58,250 --> 00:02:02,840
may well know Linux

00:01:59,929 --> 00:02:07,250
releases pretty often it's about five

00:02:02,840 --> 00:02:12,980
times a year plus some stable updates

00:02:07,250 --> 00:02:14,870
every week or so to fix bugs some of

00:02:12,980 --> 00:02:17,030
these features aren't ready to use when

00:02:14,870 --> 00:02:19,340
they first appear in release because

00:02:17,030 --> 00:02:22,970
they require integration into

00:02:19,340 --> 00:02:25,900
distributions either with extra user

00:02:22,970 --> 00:02:27,890
space packages or some kind of

00:02:25,900 --> 00:02:32,030
configuration which might be done

00:02:27,890 --> 00:02:35,570
through system T or another existing

00:02:32,030 --> 00:02:39,890
package I'm going to talk about the new

00:02:35,570 --> 00:02:43,850
features in Linux 4.19 up to 5.2 the

00:02:39,890 --> 00:02:46,070
current stable release so we have lots

00:02:43,850 --> 00:02:49,549
of new kernel features some of which

00:02:46,070 --> 00:02:52,430
made it into bus says here in testing

00:02:49,549 --> 00:02:55,840
unstable we're actually liking a bit

00:02:52,430 --> 00:03:02,900
behind but hopefully 5.2 will be in

00:02:55,840 --> 00:03:05,480
unstable in the next few weeks so a

00:03:02,900 --> 00:03:10,720
recap of some features that I talked

00:03:05,480 --> 00:03:13,630
about in previous years the sketchy util

00:03:10,720 --> 00:03:18,280
CPU frequency governor it's supposed to

00:03:13,630 --> 00:03:22,900
make better decisions about CPU

00:03:18,280 --> 00:03:24,610
frequency on some hardware we possibly

00:03:22,900 --> 00:03:27,760
ought to make note that a fault we can't

00:03:24,610 --> 00:03:32,290
do that on Intel x86 processors I think

00:03:27,760 --> 00:03:36,160
because they use they don't support our

00:03:32,290 --> 00:03:38,710
tree for CPU frequency governance that's

00:03:36,160 --> 00:03:44,980
actually done by our management

00:03:38,710 --> 00:03:47,770
processor therefore other Hardware may

00:03:44,980 --> 00:03:53,440
be that is a good choice the sound

00:03:47,770 --> 00:03:58,510
recording is the new technique used on

00:03:53,440 --> 00:04:02,200
very high capacity hard drives that does

00:03:58,510 --> 00:04:04,720
not allow for random writes you need to

00:04:02,200 --> 00:04:06,370
DM sound driver for that which has been

00:04:04,720 --> 00:04:11,080
around for a while but you also need the

00:04:06,370 --> 00:04:13,720
DM zoned tools use a space package there

00:04:11,080 --> 00:04:15,820
is a package for that now that that's

00:04:13,720 --> 00:04:18,190
been done by someone who is not a DD

00:04:15,820 --> 00:04:20,920
need to sponsor if you're interested in

00:04:18,190 --> 00:04:24,640
that both number is eight eight two six

00:04:20,920 --> 00:04:28,390
four oh the block layer that's

00:04:24,640 --> 00:04:32,890
responsible for all disk i/o and disk

00:04:28,390 --> 00:04:35,470
like devices was given a major overhaul

00:04:32,890 --> 00:04:37,570
which required updating all the block

00:04:35,470 --> 00:04:40,150
drivers so that was quite a long process

00:04:37,570 --> 00:04:43,570
and both the old and new block players

00:04:40,150 --> 00:04:47,400
were in place for a while but that it's

00:04:43,570 --> 00:04:50,290
now completed with links five point not

00:04:47,400 --> 00:04:55,770
one of the benefits of that is that you

00:04:50,290 --> 00:04:59,460
can use some new and more sophisticated

00:04:55,770 --> 00:05:03,040
io schedulers for all block devices

00:04:59,460 --> 00:05:07,480
including bfq which is said to be quite

00:05:03,040 --> 00:05:12,280
good for low performance flash drives

00:05:07,480 --> 00:05:15,700
like you find on Singapore computers the

00:05:12,280 --> 00:05:17,800
risk 5 architecture now has enough

00:05:15,700 --> 00:05:19,520
hardware support upstream that we were

00:05:17,800 --> 00:05:24,530
able to start building

00:05:19,520 --> 00:05:28,129
kernel image for that with 4.19 and the

00:05:24,530 --> 00:05:30,889
situation with GPUs on arm-based soces

00:05:28,129 --> 00:05:33,940
has improved again because there are

00:05:30,889 --> 00:05:37,190
free drivers for the arms Mali GPUs

00:05:33,940 --> 00:05:38,629
starting with Linux 5.2 there's two

00:05:37,190 --> 00:05:48,620
different drivers for different

00:05:38,629 --> 00:05:52,069
generations of the of the GPU so new

00:05:48,620 --> 00:05:58,009
features security hardening is an

00:05:52,069 --> 00:06:01,669
ongoing process that's both hardening

00:05:58,009 --> 00:06:04,610
the kernel against security exploits

00:06:01,669 --> 00:06:07,639
from user space and also providing

00:06:04,610 --> 00:06:10,840
features so that user space can be

00:06:07,639 --> 00:06:18,530
processes can be better protected from

00:06:10,840 --> 00:06:22,159
exploits one of these that we enabled a

00:06:18,530 --> 00:06:25,250
few years back was protecting symlinks

00:06:22,159 --> 00:06:29,180
and hard links were created in sticky

00:06:25,250 --> 00:06:32,139
directories like slash temp what that

00:06:29,180 --> 00:06:35,599
means is they're writable by everyone

00:06:32,139 --> 00:06:37,819
but his aren't too late you just aren't

00:06:35,599 --> 00:06:41,389
allowed to delete an overwrite each

00:06:37,819 --> 00:06:46,520
other's files but it is possible to put

00:06:41,389 --> 00:06:50,900
traps in these directories this hard

00:06:46,520 --> 00:06:53,870
links and symlinks that's can be used to

00:06:50,900 --> 00:06:58,340
attack server programs that don't open

00:06:53,870 --> 00:07:01,250
files in a secure way so there are new

00:06:58,340 --> 00:07:04,659
optional protections for fie foes also

00:07:01,250 --> 00:07:08,539
those name pipes and for regular files

00:07:04,659 --> 00:07:10,159
those might might introduce some

00:07:08,539 --> 00:07:11,719
compatibility problems but I think we

00:07:10,159 --> 00:07:17,000
should consider enabling those by

00:07:11,719 --> 00:07:22,940
default maybe do that as an experiment

00:07:17,000 --> 00:07:26,599
and see see what breaks variable-length

00:07:22,940 --> 00:07:28,500
arrays our C language feature and they

00:07:26,599 --> 00:07:30,930
will see to use

00:07:28,500 --> 00:07:34,500
quite a lot of stack space potentially

00:07:30,930 --> 00:07:36,870
more than exists in the kernel most uses

00:07:34,500 --> 00:07:40,200
of variable length erasing the kernel

00:07:36,870 --> 00:07:41,550
are all worth bounded so that it

00:07:40,200 --> 00:07:43,710
wouldn't result in the stack overflow

00:07:41,550 --> 00:07:49,020
but there was always the risk that some

00:07:43,710 --> 00:07:52,320
would leave out the necessary check so

00:07:49,020 --> 00:07:54,720
those have been completely removed from

00:07:52,320 --> 00:07:57,660
the kernel I had to bust into fixed

00:07:54,720 --> 00:08:04,229
length arrays or heap allocations

00:07:57,660 --> 00:08:08,660
instead the kernel also has a enables

00:08:04,229 --> 00:08:12,090
GCC's no protector which case against

00:08:08,660 --> 00:08:15,000
overflowing individual state buffers in

00:08:12,090 --> 00:08:18,240
order for that to be really effective if

00:08:15,000 --> 00:08:21,690
you want to have a you have a secret

00:08:18,240 --> 00:08:23,490
Valley called a snake canary which ought

00:08:21,690 --> 00:08:27,300
to be different per task because it's

00:08:23,490 --> 00:08:31,729
the same for all tasks then I can manage

00:08:27,300 --> 00:08:31,729
to read it from one task they can take

00:08:32,360 --> 00:08:39,780
so six already had per test Canaries we

00:08:36,930 --> 00:08:43,110
now have that on PowerPC and potentially

00:08:39,780 --> 00:08:44,730
on thirsty bit and 60 64-bit part as

00:08:43,110 --> 00:08:51,960
well or they will need some compiler

00:08:44,730 --> 00:08:54,450
updates and then reference counts bugs

00:08:51,960 --> 00:08:58,200
in reference counts can reference

00:08:54,450 --> 00:09:03,870
counting can lead to freeing or objects

00:08:58,200 --> 00:09:06,240
that while they're still in use which is

00:09:03,870 --> 00:09:08,940
it's very bad that can be used

00:09:06,240 --> 00:09:13,500
eventually to achieve code execution in

00:09:08,940 --> 00:09:17,360
the kernel the riff County type is a

00:09:13,500 --> 00:09:21,600
checked reference counts type and

00:09:17,360 --> 00:09:25,430
various reference counts in the kernel

00:09:21,600 --> 00:09:25,430
have been capacity over to using that

00:09:29,650 --> 00:09:36,620
there's the worse and bugs in the kernel

00:09:34,010 --> 00:09:39,410
where pages are cast on the kernel heat

00:09:36,620 --> 00:09:43,660
within memory mapped into user space

00:09:39,410 --> 00:09:49,810
this would result in very bad things

00:09:43,660 --> 00:09:53,080
partly because Mary mappings and heap

00:09:49,810 --> 00:09:56,240
pages he punishments he used different

00:09:53,080 --> 00:09:59,480
have different uses for the same fields

00:09:56,240 --> 00:10:02,960
in the page metadata so this would

00:09:59,480 --> 00:10:06,440
conflict but even worse depending on

00:10:02,960 --> 00:10:07,940
which hip up a heap and I sure was using

00:10:06,440 --> 00:10:11,450
the kernel this could be used to corrupt

00:10:07,940 --> 00:10:16,390
free lists and achieve code execution in

00:10:11,450 --> 00:10:22,340
the kernel so that's that is explicitly

00:10:16,390 --> 00:10:25,790
blocked in the kernel now there's some

00:10:22,340 --> 00:10:28,040
support on 64-bit arm for user space to

00:10:25,790 --> 00:10:31,250
use pointer authentication codes and the

00:10:28,040 --> 00:10:40,910
memory tagging extension these are ways

00:10:31,250 --> 00:10:45,110
to to prevent type confusion in user

00:10:40,910 --> 00:10:50,300
space which could be used for eternal

00:10:45,110 --> 00:10:56,420
turn oriented programming and exploiting

00:10:50,300 --> 00:10:59,720
use after free bugs obviously to take a

00:10:56,420 --> 00:11:05,780
bunch of those will needs changes to

00:10:59,720 --> 00:11:07,730
compiler flags and those are only

00:11:05,780 --> 00:11:16,390
available on the very latest version of

00:11:07,730 --> 00:11:19,880
v8 architecture arm and x86 already had

00:11:16,390 --> 00:11:21,800
provision for preventing the kernel from

00:11:19,880 --> 00:11:25,910
accidentally excess ink user space

00:11:21,800 --> 00:11:31,310
memory and that's now available on pervy

00:11:25,910 --> 00:11:33,230
Steve's starting with the power 9 sorry

00:11:31,310 --> 00:11:36,430
I should I turn down the microphone

00:11:33,230 --> 00:11:36,430
level is that better for you

00:11:40,010 --> 00:11:45,860
person that's available on PowerPC

00:11:42,270 --> 00:11:45,860
starting with me power nine processes

00:11:46,850 --> 00:11:56,250
the user fault FD function that can be

00:11:51,840 --> 00:12:00,840
used for support life migration of

00:11:56,250 --> 00:12:03,000
processes between different systems so

00:12:00,840 --> 00:12:05,730
that's kind of useful for moving

00:12:03,000 --> 00:12:07,560
containers around even if you need to

00:12:05,730 --> 00:12:10,680
reboot the host you can keep the

00:12:07,560 --> 00:12:13,310
container running but it's a very

00:12:10,680 --> 00:12:16,920
powerful facility which can be used

00:12:13,310 --> 00:12:20,100
makes some security issues easy to

00:12:16,920 --> 00:12:21,690
exploit so you it's now possible to

00:12:20,100 --> 00:12:24,690
restrict that to privileged users

00:12:21,690 --> 00:12:28,220
essentially only to root and that might

00:12:24,690 --> 00:12:28,220
be something we should do by default

00:12:32,530 --> 00:12:38,560
Colonel address space layout

00:12:34,180 --> 00:12:43,990
randomization is another thing that

00:12:38,560 --> 00:12:45,820
makes it hard to exploit return-oriented

00:12:43,990 --> 00:12:48,310
programming and other things against the

00:12:45,820 --> 00:12:50,860
kernel that's been available on several

00:12:48,310 --> 00:12:53,220
architectures for a while now and

00:12:50,860 --> 00:12:57,900
finally was implemented for system said

00:12:53,220 --> 00:12:57,900
which in debian we call s 390x

00:13:08,089 --> 00:13:17,069
so I talked last year about the

00:13:12,870 --> 00:13:22,050
speculation leaks including meltdown

00:13:17,069 --> 00:13:25,160
inspector in the past year there are

00:13:22,050 --> 00:13:31,439
even more even more of these

00:13:25,160 --> 00:13:33,809
vulnerabilities have been announced the

00:13:31,439 --> 00:13:37,490
mitigations for Spectre have also been

00:13:33,809 --> 00:13:40,769
extended beta variant one is about

00:13:37,490 --> 00:13:42,959
bypassing bounced checks and

00:13:40,769 --> 00:13:45,769
unfortunately there isn't a single

00:13:42,959 --> 00:13:49,009
simple mitigation for that it requires

00:13:45,769 --> 00:13:54,240
protecting all the bounced checks that

00:13:49,009 --> 00:13:55,980
you take untrusted user input so more

00:13:54,240 --> 00:13:59,759
and more of those are being protected in

00:13:55,980 --> 00:14:04,740
the kernel Spectre variant 2 which is

00:13:59,759 --> 00:14:08,819
about mispredicted indirect branches

00:14:04,740 --> 00:14:14,490
already had a general mitigation in the

00:14:08,819 --> 00:14:15,959
kernel called bread puddings but system

00:14:14,490 --> 00:14:18,449
firmware also needs to be protected

00:14:15,959 --> 00:14:21,509
against this and generally isn't being

00:14:18,449 --> 00:14:26,189
updated by system firmware I mean a bios

00:14:21,509 --> 00:14:31,459
or EFI firmware so that's being

00:14:26,189 --> 00:14:36,240
protected on x86 and userspace

00:14:31,459 --> 00:14:39,529
can also be protected using various new

00:14:36,240 --> 00:14:44,279
microcredit features that's opted in and

00:14:39,529 --> 00:14:46,500
it's enabled for by the its neighbors

00:14:44,279 --> 00:14:49,769
automatically for user space that is

00:14:46,500 --> 00:14:53,910
sandbox using second it can also be

00:14:49,769 --> 00:15:00,750
explicitly enabled using a PR CTL system

00:14:53,910 --> 00:15:07,170
core so there are two major new issues

00:15:00,750 --> 00:15:10,079
as l1 tier 4 cents for shadow Intel x86

00:15:07,170 --> 00:15:13,499
CPUs which spectively speculatively load

00:15:10,079 --> 00:15:16,379
data from the first level cache using

00:15:13,499 --> 00:15:18,569
address bits in a page table entry which

00:15:16,379 --> 00:15:19,139
would not normally provide the physical

00:15:18,569 --> 00:15:24,059
address

00:15:19,139 --> 00:15:26,670
but it would do this in even in a entry

00:15:24,059 --> 00:15:28,109
that was marked not present which would

00:15:26,670 --> 00:15:31,170
be used for a patient's been swapped

00:15:28,109 --> 00:15:33,179
outs and for a few other reasons this

00:15:31,170 --> 00:15:34,980
has been mitigated for regular processes

00:15:33,179 --> 00:15:37,199
by inviting all those physical dressed

00:15:34,980 --> 00:15:40,829
bits you know page table interested in

00:15:37,199 --> 00:15:42,929
mock not present but at puts limits on

00:15:40,829 --> 00:15:44,699
the most amount of RAM and maximum

00:15:42,929 --> 00:15:47,220
thoughtful sights you can use because

00:15:44,699 --> 00:15:51,059
the physical address space would be used

00:15:47,220 --> 00:15:54,989
for a swap file offset in a non present

00:15:51,059 --> 00:16:02,129
entry professional machines the problem

00:15:54,989 --> 00:16:04,439
is worse on modern Intel CPUs hardware

00:16:02,129 --> 00:16:06,989
virtualization uses two levels of page

00:16:04,439 --> 00:16:11,549
table there's the page table installed

00:16:06,989 --> 00:16:13,769
by the guest VM which translates some

00:16:11,549 --> 00:16:15,869
virtual addresses to an intermediate

00:16:13,769 --> 00:16:18,269
physical address and then there's the

00:16:15,869 --> 00:16:22,319
extended page table which is provided by

00:16:18,269 --> 00:16:25,169
the hypervisor in this case KPM which

00:16:22,319 --> 00:16:30,059
translates that into a real host

00:16:25,169 --> 00:16:32,730
physical address now because the if the

00:16:30,059 --> 00:16:35,910
guest VM creates non present page table

00:16:32,730 --> 00:16:42,029
entries those will go through the first

00:16:35,910 --> 00:16:44,610
level of address translation and then

00:16:42,029 --> 00:16:49,559
the EPT won't be used so it's then able

00:16:44,610 --> 00:16:53,999
to speculatively access any physical

00:16:49,559 --> 00:16:57,569
address that the host used and put into

00:16:53,999 --> 00:17:01,679
the l1 cache so that's mitigated by l1

00:16:57,569 --> 00:17:05,490
flushes I think actually vm entry not vm

00:17:01,679 --> 00:17:07,529
exit full mitigation of this will

00:17:05,490 --> 00:17:09,899
require that you never run a virtual

00:17:07,529 --> 00:17:15,209
machine on the same core as another

00:17:09,899 --> 00:17:17,490
process using hyper threads unless of

00:17:15,209 --> 00:17:21,059
course you trust the virtual machines

00:17:17,490 --> 00:17:25,889
kernel if you do that's then there's no

00:17:21,059 --> 00:17:30,330
real problem here this did not get fixed

00:17:25,889 --> 00:17:31,170
in linux 3.16 or 4.4 so you should not

00:17:30,330 --> 00:17:37,430
be using those two

00:17:31,170 --> 00:17:40,800
untrusted guests and more recently the

00:17:37,430 --> 00:17:47,300
micro architectural data sampling or MTS

00:17:40,800 --> 00:17:51,120
issue which has a large number of other

00:17:47,300 --> 00:17:53,580
brand names that as a collection of four

00:17:51,120 --> 00:17:55,800
different issues here but they're all

00:17:53,580 --> 00:17:57,810
quite similar again

00:17:55,800 --> 00:18:00,270
Intel x86 CPUs only they will

00:17:57,810 --> 00:18:02,460
speculatively load stale data from

00:18:00,270 --> 00:18:04,500
various internal buffers and that's

00:18:02,460 --> 00:18:06,690
quite hard to exploit because that's how

00:18:04,500 --> 00:18:10,230
I can't easily control or project what's

00:18:06,690 --> 00:18:13,770
in those buffers the mitigation phase

00:18:10,230 --> 00:18:16,620
has been to flush those buffers whenever

00:18:13,770 --> 00:18:20,610
the kernel exits to use the space that

00:18:16,620 --> 00:18:24,630
required new microcode to at the buffer

00:18:20,610 --> 00:18:26,370
flushing functionality old CPUs did not

00:18:24,630 --> 00:18:29,370
get micro code updates and they remain

00:18:26,370 --> 00:18:33,900
vulnerable a full mitigation again would

00:18:29,370 --> 00:18:36,570
require that you never put two

00:18:33,900 --> 00:18:39,690
processors on the same core unless they

00:18:36,570 --> 00:18:41,910
should trust each other so running Tron

00:18:39,690 --> 00:18:44,870
trusted code on Intel CPUs with hyper

00:18:41,910 --> 00:18:48,180
threading enabled is kind of risky now

00:18:44,870 --> 00:18:50,870
but it is still enabled by the default

00:18:48,180 --> 00:18:54,510
because no one wanted to take that

00:18:50,870 --> 00:18:58,680
performance hit or to make everyone pray

00:18:54,510 --> 00:19:00,150
that performance hit there's now an

00:18:58,680 --> 00:19:02,400
architecture independent kernel

00:19:00,150 --> 00:19:05,270
parameter that controls mitigations for

00:19:02,400 --> 00:19:09,060
MDS and all the other speculate

00:19:05,270 --> 00:19:11,090
speculations issues specify medications

00:19:09,060 --> 00:19:14,820
he was Auto although that's the default

00:19:11,090 --> 00:19:17,160
you can use auto comma now SMT which

00:19:14,820 --> 00:19:19,800
means hyper threading or other system

00:19:17,160 --> 00:19:22,980
multi-threading will also be disabled if

00:19:19,800 --> 00:19:24,270
necessary for full mitigation and if you

00:19:22,980 --> 00:19:26,220
trust all the codes you're running and

00:19:24,270 --> 00:19:32,310
you don't need those medications then

00:19:26,220 --> 00:19:35,010
you can use mitigations equals off so

00:19:32,310 --> 00:19:39,510
yes you twenty year 2038

00:19:35,010 --> 00:19:42,240
is getting ever closer and that means

00:19:39,510 --> 00:19:43,389
that's anywhere he thought as I see it

00:19:42,240 --> 00:19:47,049
time value is

00:19:43,389 --> 00:19:48,849
used that's going to wrap around so we

00:19:47,049 --> 00:19:51,879
need to switch away from using 30 of its

00:19:48,849 --> 00:19:55,239
counsel seconds before that time the

00:19:51,879 --> 00:19:58,329
kernel is now internally using 64 bits

00:19:55,239 --> 00:20:02,709
counts of seconds or 64-bit counts of

00:19:58,329 --> 00:20:05,259
nanoseconds in K time T almost

00:20:02,709 --> 00:20:08,589
everywhere which avoids that this

00:20:05,259 --> 00:20:11,589
overflow most file systems are still

00:20:08,589 --> 00:20:16,899
storing those two accounts on disk only

00:20:11,589 --> 00:20:21,070
butter FS + x3 + x4 have been updated so

00:20:16,899 --> 00:20:24,669
far hopefully XFS nothing powerful

00:20:21,070 --> 00:20:28,989
systems which need to be supposed to in

00:20:24,669 --> 00:20:31,450
future will get updated new system calls

00:20:28,989 --> 00:20:34,659
that use 64-bit time value are enabled

00:20:31,450 --> 00:20:37,239
on all thirstiest architectures however

00:20:34,659 --> 00:20:41,589
the other big pot pay part of spotting

00:20:37,239 --> 00:20:44,469
64-bit time is chillip see that is able

00:20:41,589 --> 00:20:47,950
to provide both 32-bit and 64-bit time

00:20:44,469 --> 00:20:50,079
api's however it can only expose one of

00:20:47,950 --> 00:20:51,940
these through its headers it was

00:20:50,079 --> 00:20:55,119
originally expected that you would be

00:20:51,940 --> 00:21:00,940
able to define a previous as a macro

00:20:55,119 --> 00:21:07,379
time bits similarly as for the 64-bit

00:21:00,940 --> 00:21:10,719
file sizes on 32-bit systems however

00:21:07,379 --> 00:21:14,019
that choice is actually made at UMC

00:21:10,719 --> 00:21:17,349
build time which means that if we want

00:21:14,019 --> 00:21:19,539
to support 64-bit time on our hf or i3

00:21:17,349 --> 00:21:22,959
at 6 or any other 32-bit architecture

00:21:19,539 --> 00:21:25,089
which might last until 2030 8 or close

00:21:22,959 --> 00:21:27,159
to twenty thirty eight that's going to

00:21:25,089 --> 00:21:30,459
require a safe version bumps in every

00:21:27,159 --> 00:21:32,409
library that exposes time to thankfully

00:21:30,459 --> 00:21:35,200
there's discussion about this that was

00:21:32,409 --> 00:21:36,309
recently started on debian devil and if

00:21:35,200 --> 00:21:40,019
you're interested in this issue I

00:21:36,309 --> 00:21:44,289
encourage you to participate in that

00:21:40,019 --> 00:21:47,200
cake is not just an icing to it but also

00:21:44,289 --> 00:21:50,309
a new network scheduler network

00:21:47,200 --> 00:21:52,559
schedulers are responsible for

00:21:50,309 --> 00:21:56,549
prioritizing and

00:21:52,559 --> 00:21:59,509
Chane the software cues of going network

00:21:56,549 --> 00:22:02,570
packets in some cases incoming packets

00:21:59,509 --> 00:22:05,990
you can select the network scheduler for

00:22:02,570 --> 00:22:09,269
any network device using the TC command

00:22:05,990 --> 00:22:12,649
Kirkus based on the existing FQ cutoff

00:22:09,269 --> 00:22:15,779
which is designed to avoid buffer bloat

00:22:12,649 --> 00:22:18,690
in other words it tries to keep software

00:22:15,779 --> 00:22:22,470
queues quite small and thus reduce

00:22:18,690 --> 00:22:24,419
network latency the FQ part of that

00:22:22,470 --> 00:22:27,119
stands for fair queuing which means that

00:22:24,419 --> 00:22:29,549
it tries to provide fair shares of

00:22:27,119 --> 00:22:33,749
bandwidth between different concurrent

00:22:29,549 --> 00:22:40,710
flows cake also adds fairness between

00:22:33,749 --> 00:22:44,850
hosts so for example if you have so if

00:22:40,710 --> 00:22:47,460
cake is used in Rooter and one computer

00:22:44,850 --> 00:22:49,950
behind that Rita is downloading

00:22:47,460 --> 00:22:52,499
let's make one download another computer

00:22:49,950 --> 00:22:54,509
is making for downloads then the first

00:22:52,499 --> 00:22:57,059
computer gets about half the bandwidth

00:22:54,509 --> 00:22:58,499
for its one download and the second

00:22:57,059 --> 00:22:59,940
computer gets about one-eighth of the

00:22:58,499 --> 00:23:03,990
bandwidth for each of those four

00:22:59,940 --> 00:23:07,860
downloads take also add some traffic

00:23:03,990 --> 00:23:10,559
shaping which is useful for limiting

00:23:07,860 --> 00:23:14,129
buffer bloat and it has some priority

00:23:10,559 --> 00:23:17,639
support finally it adds coalescing of

00:23:14,129 --> 00:23:20,100
TCP ACK packets which is really

00:23:17,639 --> 00:23:22,080
important for connections that have a

00:23:20,100 --> 00:23:26,129
slow uplink compared to downlink

00:23:22,080 --> 00:23:29,399
in some cases the data transmits lots of

00:23:26,129 --> 00:23:33,779
act packets can limit the download speed

00:23:29,399 --> 00:23:35,749
and most home for all turns home

00:23:33,779 --> 00:23:39,389
broadband connections have this

00:23:35,749 --> 00:23:43,610
asymmetry so all in all cake should be

00:23:39,389 --> 00:23:43,610
quite a good choice for home brewers

00:23:54,059 --> 00:23:59,369
they said some administrators are

00:23:56,429 --> 00:24:02,309
generally familiar with the concept of

00:23:59,369 --> 00:24:05,820
system load six base through such proc

00:24:02,309 --> 00:24:08,849
/lo Davichi and through the uptime

00:24:05,820 --> 00:24:12,989
commands and usually gathered by your

00:24:08,849 --> 00:24:15,629
system monitoring software that is a

00:24:12,989 --> 00:24:18,269
weighted average number of tasks running

00:24:15,629 --> 00:24:20,369
all ready to run or waiting for block

00:24:18,269 --> 00:24:22,590
i/o when that's greater than the number

00:24:20,369 --> 00:24:25,349
of CPUs in the system it might indicate

00:24:22,590 --> 00:24:26,820
CPU contention but because it also

00:24:25,349 --> 00:24:30,239
includes tasks that are waiting for

00:24:26,820 --> 00:24:35,700
block io it might also indicate that you

00:24:30,239 --> 00:24:40,589
have IO contention so this this single

00:24:35,700 --> 00:24:42,690
number is not that helpful so precious

00:24:40,589 --> 00:24:45,269
tall information was I was in Linux for

00:24:42,690 --> 00:24:48,839
20 and that shows the average time that

00:24:45,269 --> 00:24:52,889
tasks have been spending waiting divided

00:24:48,839 --> 00:24:55,529
into three categories of CPU CPU

00:24:52,889 --> 00:24:57,839
attended tasks ready to run but waiting

00:24:55,529 --> 00:24:59,789
to be scheduled on the CPU memory

00:24:57,839 --> 00:25:02,219
contended tasks are those that are

00:24:59,789 --> 00:25:05,339
swapping in refolding

00:25:02,219 --> 00:25:08,639
memory mapped file or reclaiming memory

00:25:05,339 --> 00:25:11,009
and i/o attended tasks wedding for block

00:25:08,639 --> 00:25:12,659
earlier to complete this information

00:25:11,009 --> 00:25:15,299
will be exposed under slash process

00:25:12,659 --> 00:25:19,759
pressure and also for each c group

00:25:15,299 --> 00:25:25,669
through zookeeper FS user space can also

00:25:19,759 --> 00:25:28,139
monitor for specific levels of

00:25:25,669 --> 00:25:30,809
contention by writing an opening the

00:25:28,139 --> 00:25:33,379
file writing a threshold to it and then

00:25:30,809 --> 00:25:33,379
polling

00:25:40,570 --> 00:25:47,950
so many arm-based system-on-chip can

00:25:44,530 --> 00:25:50,110
have a mixture of fast cause that are

00:25:47,950 --> 00:25:52,450
not particularly power efficient and

00:25:50,110 --> 00:25:58,720
slower cause that are more powerful

00:25:52,450 --> 00:26:00,850
ficient has founded this big little this

00:25:58,720 --> 00:26:06,010
is these as I say it's been around for a

00:26:00,850 --> 00:26:08,320
while but until recently the Linux task

00:26:06,010 --> 00:26:12,130
scheduler didn't do a great job of

00:26:08,320 --> 00:26:15,040
scheduling on these the default task

00:26:12,130 --> 00:26:17,020
scheduler called CFS for completely fair

00:26:15,040 --> 00:26:19,600
scheduler was originally designed for

00:26:17,020 --> 00:26:24,340
systems where all the CPUs running Linux

00:26:19,600 --> 00:26:28,240
were the same so they were same

00:26:24,340 --> 00:26:31,390
frequency here and otherwise had the

00:26:28,240 --> 00:26:34,270
same capabilities a while ago it gained

00:26:31,390 --> 00:26:41,200
support for different CPU capacities

00:26:34,270 --> 00:26:46,480
meaning that they had they had fewer

00:26:41,200 --> 00:26:48,970
processing cycles available but it was

00:26:46,480 --> 00:26:54,280
only used to improve the accounting of

00:26:48,970 --> 00:26:57,250
how much CPU time was used so instead of

00:26:54,280 --> 00:26:59,080
just counting how long the task had been

00:26:57,250 --> 00:27:02,230
running on any CPU it would also take

00:26:59,080 --> 00:27:04,150
into account how fast that CPUs power

00:27:02,230 --> 00:27:09,190
runs in order to know how many cycles

00:27:04,150 --> 00:27:10,930
the task used energy of where scheduling

00:27:09,190 --> 00:27:11,850
which was added in the Linux five-point

00:27:10,930 --> 00:27:14,470
nodes

00:27:11,850 --> 00:27:17,320
attempts to schedule tasks in a way

00:27:14,470 --> 00:27:22,960
that's actually energy efficient it uses

00:27:17,320 --> 00:27:24,940
that record of the tasks CPU load to

00:27:22,960 --> 00:27:27,580
protect which CPUs will have enough

00:27:24,940 --> 00:27:30,370
spare cycles and then it also uses an

00:27:27,580 --> 00:27:33,220
energy model which is based on data in

00:27:30,370 --> 00:27:35,760
the device tree to protect the energy

00:27:33,220 --> 00:27:39,580
cost of running on each of the suitable

00:27:35,760 --> 00:27:43,420
CPUs and then it picks the one that's

00:27:39,580 --> 00:27:46,260
most energy efficient but on symmetric

00:27:43,420 --> 00:27:49,630
systems or when all of the CPUs are

00:27:46,260 --> 00:27:53,700
mostly busy it gets out of the way in

00:27:49,630 --> 00:27:53,700
the standard scheduler behavior as you

00:27:55,260 --> 00:28:04,510
finally packaging changes have been lots

00:28:00,010 --> 00:28:06,760
of little changes since last year code

00:28:04,510 --> 00:28:09,669
signing which was implemented to sports

00:28:06,760 --> 00:28:12,160
cue boots has been completed and is in

00:28:09,669 --> 00:28:15,580
production not just in unstable but also

00:28:12,160 --> 00:28:18,669
air in buster

00:28:15,580 --> 00:28:21,070
our bill flocks of those by defaults as

00:28:18,669 --> 00:28:24,760
now required by policy but we do support

00:28:21,070 --> 00:28:28,059
the build option to make them test which

00:28:24,760 --> 00:28:32,409
is the upstream default we finally got

00:28:28,059 --> 00:28:36,789
rid of our private patch system that was

00:28:32,409 --> 00:28:40,780
mostly removed in around Linux 3.1 in

00:28:36,789 --> 00:28:43,210
favor of using quills and version 3.0

00:28:40,780 --> 00:28:46,179
quilt source package we still used the

00:28:43,210 --> 00:28:47,740
private patch system to remove non free

00:28:46,179 --> 00:28:50,440
files that shouldn't be interesting

00:28:47,740 --> 00:28:55,140
there which Tarble we've now switched

00:28:50,440 --> 00:28:58,360
over to using the fast exploited file

00:28:55,140 --> 00:29:00,480
sorry the files excluded filled in

00:28:58,360 --> 00:29:03,549
debian / copyright which you scan

00:29:00,480 --> 00:29:09,490
understands and we also use that field

00:29:03,549 --> 00:29:11,320
when generating tuples from gear i went

00:29:09,490 --> 00:29:13,600
through and fixed almost all the

00:29:11,320 --> 00:29:17,260
warnings and errors from GCC and d

00:29:13,600 --> 00:29:20,950
package Lin Tian AI code style and PI

00:29:17,260 --> 00:29:27,640
flex you know a bunch of Python scripts

00:29:20,950 --> 00:29:32,500
in the sauce package as a live BPF used

00:29:27,640 --> 00:29:34,539
for dealing with the increasingly poorly

00:29:32,500 --> 00:29:36,909
named Berkeley Berkeley packet filter

00:29:34,539 --> 00:29:40,330
that's used for all kinds of purposes in

00:29:36,909 --> 00:29:43,929
the kernel now that's available on mr.

00:29:40,330 --> 00:29:46,450
demion architectures the changelog has

00:29:43,929 --> 00:29:48,970
been split so older entries that predate

00:29:46,450 --> 00:29:53,409
the last stable release will envy you in

00:29:48,970 --> 00:29:55,059
the-- sauce package this is important

00:29:53,409 --> 00:29:56,710
because some of our binary packages are

00:29:55,059 --> 00:30:00,820
actually quite small and the chain lock

00:29:56,710 --> 00:30:05,470
was making out and taking up most of the

00:30:00,820 --> 00:30:07,960
diskspace package occupied we have even

00:30:05,470 --> 00:30:12,429
more build profiles now that can be used

00:30:07,960 --> 00:30:14,470
to skip building some packages so

00:30:12,429 --> 00:30:17,799
packaged on Linux don't know colonel

00:30:14,470 --> 00:30:20,169
bills only only the user space packages

00:30:17,799 --> 00:30:23,109
and package top Linux don't they saw

00:30:20,169 --> 00:30:26,019
skips building the Linux - source

00:30:23,109 --> 00:30:31,509
package which is used for building

00:30:26,019 --> 00:30:34,539
custom kernel packages the UTEP's used

00:30:31,509 --> 00:30:36,220
in the Installer been reorganized and

00:30:34,539 --> 00:30:40,359
more consistent across the architectures

00:30:36,220 --> 00:30:43,629
for example why Wi-Fi drivers were not

00:30:40,359 --> 00:30:49,960
being shipped on PowerPC all most of

00:30:43,629 --> 00:30:51,940
them were not that's consistent and we

00:30:49,960 --> 00:30:54,970
also include hardware random number

00:30:51,940 --> 00:30:57,759
generator drivers to solve the lack of

00:30:54,970 --> 00:31:00,940
entry problem in the Installer and we're

00:30:57,759 --> 00:31:05,739
including more graphics drivers so

00:31:00,940 --> 00:31:16,869
that's the install will work in some

00:31:05,739 --> 00:31:18,129
virtual machines so that's its 4i all

00:31:16,869 --> 00:31:21,070
the changes that I thought were

00:31:18,129 --> 00:31:24,519
interesting enough to talk about I'm

00:31:21,070 --> 00:31:26,950
going to switch over to a different

00:31:24,519 --> 00:31:29,279
program now to do the questions and

00:31:26,950 --> 00:31:29,279
answers

00:31:34,760 --> 00:31:37,570
please wait

00:31:46,760 --> 00:31:50,590
so meanwhile anyone know any good jokes

00:31:59,290 --> 00:32:03,390
does anybody know any good questions

00:32:15,050 --> 00:32:22,620
there is um here's your question hi this

00:32:20,880 --> 00:32:26,610
is a file from canonical I have a

00:32:22,620 --> 00:32:30,060
question related to 32-bit kernel and as

00:32:26,610 --> 00:32:31,590
far as I know the it's not mitigations

00:32:30,060 --> 00:32:33,990
for our spectrum mouths down including

00:32:31,590 --> 00:32:37,260
mts are not enabled by default if you're

00:32:33,990 --> 00:32:39,030
not enabling more than four gigs or

00:32:37,260 --> 00:32:41,760
friends or using physical address

00:32:39,030 --> 00:32:45,720
extension so my question is related to

00:32:41,760 --> 00:32:47,970
this is there any plans regarding you

00:32:45,720 --> 00:32:53,040
know enabling those mitigations were

00:32:47,970 --> 00:32:56,280
32-bit if they are needed and also what

00:32:53,040 --> 00:32:58,590
about 32-bit support what's your view on

00:32:56,280 --> 00:33:00,120
that because some of this distributions

00:32:58,590 --> 00:33:02,910
are thinking I'm dropping this support

00:33:00,120 --> 00:33:09,530
and also I'm sorry but here in the

00:33:02,910 --> 00:33:09,530
question can you hear me now

00:33:13,170 --> 00:33:22,860
is there anybody in there link once for

00:33:19,860 --> 00:33:24,590
the blink once for no twice vs can you

00:33:22,860 --> 00:33:27,590
hear us

00:33:24,590 --> 00:33:27,590
nope

00:33:31,720 --> 00:33:43,059
he told you our number 17 in the queue I

00:33:39,570 --> 00:33:46,720
think maybe we should switch to relay

00:33:43,059 --> 00:33:48,340
through RC I can take questions from

00:33:46,720 --> 00:33:53,220
I'll save if that's better

00:33:48,340 --> 00:33:58,990
oh can you hear us

00:33:53,220 --> 00:34:02,879
no still can't hear us let's first start

00:33:58,990 --> 00:34:02,879
with the question from Walt I guess

00:34:22,480 --> 00:34:26,339
don't make me do anyway it's no good

00:34:33,280 --> 00:34:39,169
okay Delta asked easily checked ref

00:34:37,010 --> 00:34:40,700
counting a feature of GGC or is it

00:34:39,169 --> 00:34:42,260
something that is implemented in the

00:34:40,700 --> 00:34:44,210
kernel

00:34:42,260 --> 00:34:48,230
it's an Italian fermented in the kernel

00:34:44,210 --> 00:34:50,389
it's not a reference the checks hello

00:34:48,230 --> 00:34:53,389
reference count are in some cases done

00:34:50,389 --> 00:34:57,950
using inline assembly but generally this

00:34:53,389 --> 00:35:00,880
it's it's mostly C code and not a

00:34:57,950 --> 00:35:00,880
component of the church

00:35:39,960 --> 00:35:46,870
yes okay so for a fair lost about I six

00:35:43,690 --> 00:35:48,790
eight six support don't have mitigation

00:35:46,870 --> 00:35:53,710
Spectre and meltdown by default without

00:35:48,790 --> 00:35:55,180
PA he enables right we don't have a

00:35:53,710 --> 00:36:00,430
mitigation from the meltdown on there

00:35:55,180 --> 00:36:03,240
but we do for specter do we see isolated

00:36:00,430 --> 00:36:07,810
support continuing well I think that's a

00:36:03,240 --> 00:36:10,540
that's a the support for our three eight

00:36:07,810 --> 00:36:13,350
six which really means I 686 now is I

00:36:10,540 --> 00:36:16,090
think a decision for the for the

00:36:13,350 --> 00:36:20,880
distribution as a whole for the product

00:36:16,090 --> 00:36:23,710
of the whole to make or possibly for the

00:36:20,880 --> 00:36:29,170
release teeny to decide whether we

00:36:23,710 --> 00:36:31,540
release that anymore I think we might

00:36:29,170 --> 00:36:39,060
want to think about dropping support for

00:36:31,540 --> 00:36:39,060
the kernel 686 flavor and requiring PAA

00:36:39,840 --> 00:36:50,680
because Milltown and some other

00:36:43,240 --> 00:36:53,650
mitigations depend on that Lucas asked

00:36:50,680 --> 00:36:56,410
about the freshest all information and

00:36:53,650 --> 00:37:02,260
he shall skating it back ported to 4.19

00:36:56,410 --> 00:37:04,660
I don't see there happening I don't

00:37:02,260 --> 00:37:06,790
think that's it's it's a useful feature

00:37:04,660 --> 00:37:10,560
but that doesn't meet the requirements

00:37:06,790 --> 00:37:10,560
for a stable update

00:37:44,180 --> 00:37:50,910
Papillon asks would you consider

00:37:46,740 --> 00:37:56,610
consider allowing unprivileged user name

00:37:50,910 --> 00:37:59,520
space claim by default I think we would

00:37:56,610 --> 00:38:04,500
have to review recent security issues

00:37:59,520 --> 00:38:06,750
and see whether the the whether or not

00:38:04,500 --> 00:38:16,470
there are any issues that still

00:38:06,750 --> 00:38:19,470
mitigating if the the issues that that's

00:38:16,470 --> 00:38:23,090
is mitigating have stopped occurring

00:38:19,470 --> 00:38:23,090
then perhaps we could inhibit by default

00:38:51,900 --> 00:38:57,070
gusoff I don't know if I'm pronouncing

00:38:53,800 --> 00:38:58,990
that right asks how soon is Colonel

00:38:57,070 --> 00:39:01,750
flight ones who planned to make its way

00:38:58,990 --> 00:39:06,370
into Debian I would hope within the next

00:39:01,750 --> 00:39:09,220
week or two there hey a motor quest on

00:39:06,370 --> 00:39:19,900
self sir which I need to review which

00:39:09,220 --> 00:39:24,970
would update us too if I went to medical

00:39:19,900 --> 00:39:28,990
way asks when will Debian 10 have a

00:39:24,970 --> 00:39:31,240
backboard occur I would say probably a

00:39:28,990 --> 00:39:33,370
week or two after we have that's in

00:39:31,240 --> 00:39:37,960
unstable it's got to make its way into

00:39:33,370 --> 00:39:40,710
testing before it's uploaded to post

00:39:37,960 --> 00:39:40,710
about posts

00:39:48,490 --> 00:39:55,330
indigo blue ass is EAS a good feature

00:39:52,720 --> 00:39:59,080
for energyaware scheduling on hypervisor

00:39:55,330 --> 00:39:59,830
I would suspect not because the

00:39:59,080 --> 00:40:04,620
hypervisor

00:39:59,830 --> 00:40:08,410
can move virtual CPUs around between

00:40:04,620 --> 00:40:12,090
physical CPUs if the virtual machine is

00:40:08,410 --> 00:40:14,830
pinned to specific processes and

00:40:12,090 --> 00:40:17,770
hypervisor provides information about

00:40:14,830 --> 00:40:21,010
those who device trainee or some other

00:40:17,770 --> 00:40:24,970
mechanism then it might be possible but

00:40:21,010 --> 00:40:28,020
I don't think that's that's something

00:40:24,970 --> 00:40:28,020
that's being done yet

00:40:51,440 --> 00:40:54,279
more questions

00:41:12,650 --> 00:41:20,530
okay I guess they're all questions asked

00:41:16,220 --> 00:41:20,530
I guess last chance

00:41:42,850 --> 00:41:47,890
I guess that's everything thank you all

00:41:45,910 --> 00:41:50,230
very much for coming along on this sort

00:41:47,890 --> 00:41:53,530
of experimental maiden voyage thank you

00:41:50,230 --> 00:41:55,750
for letting us try this huge hand to the

00:41:53,530 --> 00:41:57,430
video team please for having worked

00:41:55,750 --> 00:42:05,710
their asses off to get this to get this

00:41:57,430 --> 00:42:08,820
working see you next time yes thanks

00:42:05,710 --> 00:42:08,820

YouTube URL: https://www.youtube.com/watch?v=7GBnPiHE71A


