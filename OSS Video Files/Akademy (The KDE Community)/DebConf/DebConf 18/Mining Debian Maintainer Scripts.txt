Title: Mining Debian Maintainer Scripts
Publication date: 2018-07-31
Playlist: DebConf 18
Description: 
	by Ralf Treinen
by Nicolas Jeannerod

At: DebConf18
https://debconf18.debconf.org/talks/90-mining-debian-maintainer-scripts/

Debian sid contains more than 31.000 maintainer scripts, the
vast majority of which are written in the POSIX shell language. We
have written, in the context of the CoLiS project, the tool shstats
which allows us to do a statistical analysis of a large corpus of
shell scripts. The tool operates on concrete syntax trees of shell
scripts constructed by the morbig shell parser. The morbig parser has
already been presented at a devroom at FOSDEM 2018, and at the
minidebconf 2018 in Hamburg. The shstats tool comes with a number of
analysis modules, and it is easy to extend it by adding new modules.

In this talk we will present both the design of the analyzer tool and
how it can be extended by new analysis modules, and some of the results
we have obtained so far on the corpus of sid maintainer scripts. Among
these are answers to questions like:

- are recursive functions used in maintainer scripts?
- how many variable assignments are in reality definition of constants?
- how many shell scripts don't do any variable assignments, besides
  definitions of constants?
- how often are shell constructs like while, for, if, etc. used?
- which UNIX commands are most commonly used in the corpus, and
  with which options?
- are there any syntax errors in the arguments of complex commands like test?

Room: Yushan (玉山)
Scheduled start: 2018-07-31 10:00:00
Captions: 
	00:00:04,900 --> 00:00:12,139
okay all right so good morning we are

00:00:10,190 --> 00:00:13,790
glad that there are some people here

00:00:12,139 --> 00:00:18,380
this morning after the cheese and wine

00:00:13,790 --> 00:00:21,710
party anyway so this is Nicola and wife

00:00:18,380 --> 00:00:25,040
and we are going to talk about in stereo

00:00:21,710 --> 00:00:27,950
in fact about about shell scripts shell

00:00:25,040 --> 00:00:33,230
scripts in general and Debian maintainer

00:00:27,950 --> 00:00:35,840
scripts in particular so let me first

00:00:33,230 --> 00:00:37,460
start by reminding you what this is -

00:00:35,840 --> 00:00:38,710
scripts in DB on most of you probably

00:00:37,460 --> 00:00:41,449
know this very well

00:00:38,710 --> 00:00:44,269
so this is a citation from our create

00:00:41,449 --> 00:00:47,480
policy and we will have quite quite some

00:00:44,269 --> 00:00:50,030
citations from the policy so a depth

00:00:47,480 --> 00:00:52,579
package contains two sets of files in

00:00:50,030 --> 00:00:54,289
general the first is a set of files to

00:00:52,579 --> 00:00:57,679
be installed on the system then the

00:00:54,289 --> 00:00:59,420
package is installed which we call the

00:00:57,679 --> 00:01:01,760
static static contents of the package

00:00:59,420 --> 00:01:03,739
and then you have a set of files that

00:01:01,760 --> 00:01:06,050
provide additional metadata about the

00:01:03,739 --> 00:01:08,480
package or which are executed when the

00:01:06,050 --> 00:01:09,920
package is installed or removed amongst

00:01:08,480 --> 00:01:12,470
those files are two package maintainer

00:01:09,920 --> 00:01:14,660
scripts so these are the scripts we are

00:01:12,470 --> 00:01:18,290
interested in and we are talking about

00:01:14,660 --> 00:01:20,600
today and these maintainer scripts you

00:01:18,290 --> 00:01:23,450
might have up to four of them in any

00:01:20,600 --> 00:01:27,200
single panel package these are the pre

00:01:23,450 --> 00:01:29,960
and post and PRM and poster m and the a

00:01:27,200 --> 00:01:32,570
function is very roughly where when you

00:01:29,960 --> 00:01:35,210
install a package then first you execute

00:01:32,570 --> 00:01:37,190
to pre ends script if it is present in

00:01:35,210 --> 00:01:39,800
the package then you are unpacked -

00:01:37,190 --> 00:01:41,960
static contents the tarball and then you

00:01:39,800 --> 00:01:44,330
execute the post and script and when you

00:01:41,960 --> 00:01:46,460
remove a package its to reverse the CRM

00:01:44,330 --> 00:01:50,060
scripts so first you execute

00:01:46,460 --> 00:01:51,740
PRM script then all the static contents

00:01:50,060 --> 00:01:54,350
of the packages we moved from your file

00:01:51,740 --> 00:01:56,960
system and finally you execute the post

00:01:54,350 --> 00:01:58,460
RM script and the situation is a little

00:01:56,960 --> 00:01:59,900
bit more complicated when you upgrade

00:01:58,460 --> 00:02:01,850
the package or when you download a

00:01:59,900 --> 00:02:03,740
package because then there's a mixture

00:02:01,850 --> 00:02:05,420
of these scripts of the old and the new

00:02:03,740 --> 00:02:07,700
version of the package which are

00:02:05,420 --> 00:02:09,619
executed with additional arguments

00:02:07,700 --> 00:02:11,750
passed through C scripts in order to

00:02:09,619 --> 00:02:14,120
indicate to them what precisely is

00:02:11,750 --> 00:02:16,730
happening okay so these are the things

00:02:14,120 --> 00:02:19,540
we would like to analyze formally to

00:02:16,730 --> 00:02:19,540
know better say Oh

00:02:19,720 --> 00:02:27,190
before looking more into what this means

00:02:24,040 --> 00:02:30,640
a breakdown of what we have currently

00:02:27,190 --> 00:02:32,560
about container scripts so this are

00:02:30,640 --> 00:02:36,400
numbers from which are more or less

00:02:32,560 --> 00:02:40,170
reason for May we had at that time about

00:02:36,400 --> 00:02:42,819
50,000 panwa packages and Ansett and

00:02:40,170 --> 00:02:45,700
Counting all the maintainer scripts we

00:02:42,819 --> 00:02:49,629
arrived at about 30,000 which means that

00:02:45,700 --> 00:02:51,879
not every package has them about these

00:02:49,629 --> 00:02:54,280
30,000 well you probably know that many

00:02:51,879 --> 00:02:56,379
of our large parts of these manuscripts

00:02:54,280 --> 00:03:00,040
are today automatically generated by

00:02:56,379 --> 00:03:03,190
developer the paper stuff but anyway we

00:03:00,040 --> 00:03:05,500
find among these 30,000 about 1/3 which

00:03:03,190 --> 00:03:07,510
contains at least a part of the script

00:03:05,500 --> 00:03:10,120
which has been written by hand so which

00:03:07,510 --> 00:03:12,459
has not been introduced inserted by some

00:03:10,120 --> 00:03:14,650
of the developer staff and by the way we

00:03:12,459 --> 00:03:18,190
did some similar stuff more basic

00:03:14,650 --> 00:03:20,739
analysis some 10 years ago in in the

00:03:18,190 --> 00:03:24,280
Mancusi project and we obtained similar

00:03:20,739 --> 00:03:25,900
figures about about the number about the

00:03:24,280 --> 00:03:28,060
portion of maintainer scripts which are

00:03:25,900 --> 00:03:30,220
partially written by hand so apparently

00:03:28,060 --> 00:03:32,769
this doesn't move too much over over

00:03:30,220 --> 00:03:35,200
time so about 10 script 10,000 scripts

00:03:32,769 --> 00:03:38,349
are at least partially written by hand

00:03:35,200 --> 00:03:40,870
which means they potentially contain box

00:03:38,349 --> 00:03:42,519
and contain Evers and this is something

00:03:40,870 --> 00:03:44,739
we should worry about because these

00:03:42,519 --> 00:03:47,049
manuscripts are executed as would when

00:03:44,739 --> 00:03:49,989
you install a package on any machine so

00:03:47,049 --> 00:03:52,720
we should be defensive in writing Z

00:03:49,989 --> 00:03:56,230
scripts and we should be sure that they

00:03:52,720 --> 00:04:00,190
are quite a break down by language so

00:03:56,230 --> 00:04:02,829
almost all of them are POSIX shell with

00:04:00,190 --> 00:04:07,720
a few exceptions so there are about 1000

00:04:02,829 --> 00:04:10,569
30 page scripts pin - pin bish SiC

00:04:07,720 --> 00:04:12,489
simple scripts there are five s key

00:04:10,569 --> 00:04:15,069
files these are the findings according

00:04:12,489 --> 00:04:17,199
to the find to the file utility and s

00:04:15,069 --> 00:04:20,919
key files means these are shell scripts

00:04:17,199 --> 00:04:23,380
which do not have the shipping and we

00:04:20,919 --> 00:04:26,590
will come back to this case a little bit

00:04:23,380 --> 00:04:28,870
later and even to elf executables and

00:04:26,590 --> 00:04:31,960
these are in fact for the packages of

00:04:28,870 --> 00:04:33,789
bash and of - and this is quite normal

00:04:31,960 --> 00:04:37,449
because obviously you cannot watch pre

00:04:33,789 --> 00:04:39,100
in strips as a shortcut because you

00:04:37,449 --> 00:04:44,560
don't have an interpreter when you

00:04:39,100 --> 00:04:46,750
install the stuff okay so what policy

00:04:44,560 --> 00:04:48,490
says about maintainer scripts is well

00:04:46,750 --> 00:04:50,229
they are not required to be shell

00:04:48,490 --> 00:04:53,650
scripts as we already have seen on a

00:04:50,229 --> 00:04:56,470
previous slide see shell and TC shell

00:04:53,650 --> 00:04:59,050
are discouraged for various reasons so

00:04:56,470 --> 00:05:01,060
there are several papers and documents

00:04:59,050 --> 00:05:04,150
available on the web which explain to

00:05:01,060 --> 00:05:07,599
you why why it is bad to program in any

00:05:04,150 --> 00:05:09,340
of these languages the policy says that

00:05:07,599 --> 00:05:12,490
they should start on a shebang and

00:05:09,340 --> 00:05:15,820
indicate the type of the language which

00:05:12,490 --> 00:05:19,570
is used in the script they should use

00:05:15,820 --> 00:05:22,030
set - ESET - e puts the shell into a

00:05:19,570 --> 00:05:24,750
mode which we call and D beyond the

00:05:22,030 --> 00:05:27,250
strict mode but this is not a POSIX

00:05:24,750 --> 00:05:29,889
terminology the strict mode means that

00:05:27,250 --> 00:05:32,139
when there is a command which fails then

00:05:29,889 --> 00:05:35,620
the content and the shell script itself

00:05:32,139 --> 00:05:38,470
will fail and it will not exit will not

00:05:35,620 --> 00:05:40,539
continue execution of the script this is

00:05:38,470 --> 00:05:42,220
what you usually would expect from a

00:05:40,539 --> 00:05:44,349
general scope because if something

00:05:42,220 --> 00:05:46,630
unexpected happens you want to fail it

00:05:44,349 --> 00:05:49,270
noisily so you see that something went

00:05:46,630 --> 00:05:51,340
wrong however the set man is in the

00:05:49,270 --> 00:05:53,440
strict mode one has to know that it is

00:05:51,340 --> 00:05:55,810
temporarily disabled in certain

00:05:53,440 --> 00:05:57,460
situations and it's venturing execution

00:05:55,810 --> 00:06:01,419
of a shell script and it will also come

00:05:57,460 --> 00:06:02,919
back to this so the POSIX standard for a

00:06:01,419 --> 00:06:05,349
long time in fact when we started our

00:06:02,919 --> 00:06:07,509
project the POSIX version of the POSIX

00:06:05,349 --> 00:06:10,810
standard which was mandated by policy

00:06:07,509 --> 00:06:13,570
was note version and quite recently this

00:06:10,810 --> 00:06:16,110
was updated so we know policy now talks

00:06:13,570 --> 00:06:18,400
about the version of POSIX standards of

00:06:16,110 --> 00:06:18,690
2017 which is great thanks a lot for

00:06:18,400 --> 00:06:21,430
that

00:06:18,690 --> 00:06:24,219
unfortunately POSIX recently updated to

00:06:21,430 --> 00:06:28,599
a 2018 version so we probably will have

00:06:24,219 --> 00:06:30,969
to try to update this again the policy

00:06:28,599 --> 00:06:35,080
also says that any shell interpreter

00:06:30,969 --> 00:06:36,909
should be should implement the POSIX

00:06:35,080 --> 00:06:39,699
standard with some POSIX standard with

00:06:36,909 --> 00:06:42,510
some additions with some Debian specific

00:06:39,699 --> 00:06:44,700
embellishments and this concerned

00:06:42,510 --> 00:06:47,190
built-in if it is implemented it should

00:06:44,700 --> 00:06:49,530
support the - and option the tests when

00:06:47,190 --> 00:06:51,750
it is in buildin it should support the -

00:06:49,530 --> 00:06:54,840
a and - o option we will also come back

00:06:51,750 --> 00:06:57,600
to this it should support local scopes

00:06:54,840 --> 00:07:00,120
and the local keyboard and we will also

00:06:57,600 --> 00:07:02,070
talk about this and also some stuff we

00:07:00,120 --> 00:07:04,650
don't care about in the context of our

00:07:02,070 --> 00:07:07,880
project because in our project we will

00:07:04,650 --> 00:07:10,890
ignore concurrent stuff and signal stuff

00:07:07,880 --> 00:07:12,720
okay so we will look at POSIX POSIX

00:07:10,890 --> 00:07:16,290
shirts with these deviant specific

00:07:12,720 --> 00:07:20,010
extensions now what we are trying to do

00:07:16,290 --> 00:07:22,650
in this project globally is to get a

00:07:20,010 --> 00:07:25,170
formal assertion of the correctness of

00:07:22,650 --> 00:07:26,730
these maintainer scripts that is an

00:07:25,170 --> 00:07:30,600
assertion that they are behaving

00:07:26,730 --> 00:07:32,100
correctly on a semantic level in fact to

00:07:30,600 --> 00:07:34,170
those of you who have been in Cape Town

00:07:32,100 --> 00:07:36,480
two years ago at eMCON forgave a talk at

00:07:34,170 --> 00:07:39,210
that occasion the representative project

00:07:36,480 --> 00:07:41,340
and I gave an example of one of my own

00:07:39,210 --> 00:07:44,130
maintainer scripts which was wrong and

00:07:41,340 --> 00:07:46,080
which did terrible stuff because it

00:07:44,130 --> 00:07:48,360
removed too many files when you are

00:07:46,080 --> 00:07:50,520
remove the package okay so these are the

00:07:48,360 --> 00:07:52,650
kinds of parks we would like to find at

00:07:50,520 --> 00:07:56,790
the end of our project I tell you why

00:07:52,650 --> 00:07:59,250
the way we are not there yet so we took

00:07:56,790 --> 00:08:01,350
along after a lot of time or by working

00:07:59,250 --> 00:08:03,450
on the front end of our tool chain and

00:08:01,350 --> 00:08:06,840
this is in fact what we are going to

00:08:03,450 --> 00:08:08,850
talk about today so this is about formal

00:08:06,840 --> 00:08:10,890
analysis formal analysis in the sense of

00:08:08,850 --> 00:08:13,710
program verification or formal program

00:08:10,890 --> 00:08:15,510
verification this is not testing so we

00:08:13,710 --> 00:08:17,700
would like to get by formal analysis

00:08:15,510 --> 00:08:20,190
really an assertion of the fact that our

00:08:17,700 --> 00:08:24,090
scripts behave correctly in any possible

00:08:20,190 --> 00:08:26,460
legal situation so it's much much

00:08:24,090 --> 00:08:28,950
stronger assertions and only only

00:08:26,460 --> 00:08:31,140
testing so possible outcomes where we

00:08:28,950 --> 00:08:34,590
would could probably get an assertion of

00:08:31,140 --> 00:08:37,200
correctness but Thea one should also be

00:08:34,590 --> 00:08:39,540
aware that all one can hope for is to

00:08:37,200 --> 00:08:43,260
obtain an assertion of correctness in

00:08:39,540 --> 00:08:45,420
some abstraction of a model of the model

00:08:43,260 --> 00:08:48,120
of the system since anyway what you have

00:08:45,420 --> 00:08:50,640
on a real unique system is quite complex

00:08:48,120 --> 00:08:53,250
quite complex thing and you cannot

00:08:50,640 --> 00:08:55,290
probably you won't be able to model all

00:08:53,250 --> 00:08:56,820
of this completely in some

00:08:55,290 --> 00:08:59,160
which can be handled by if I poke

00:08:56,820 --> 00:09:00,630
amplification and that's a possible

00:08:59,160 --> 00:09:02,430
outcome and this is probably something

00:09:00,630 --> 00:09:05,009
which will which will be much more

00:09:02,430 --> 00:09:07,500
useful for Ferdie beyond is bucks

00:09:05,009 --> 00:09:10,380
I find impossible packs in packages and

00:09:07,500 --> 00:09:13,319
we have already found quite of them for

00:09:10,380 --> 00:09:17,339
the moment on a quite trivial syntactic

00:09:13,319 --> 00:09:20,610
level okay and this is what we talked

00:09:17,339 --> 00:09:22,529
about today and the first step to obtain

00:09:20,610 --> 00:09:26,490
the tool chain which does all of this is

00:09:22,529 --> 00:09:28,889
to start this passing of shared scripts

00:09:26,490 --> 00:09:32,040
to obtain a syntax tree for shell

00:09:28,889 --> 00:09:36,509
scripts and this yeah it's what we did

00:09:32,040 --> 00:09:39,569
first thank you so that was already the

00:09:36,509 --> 00:09:42,779
topic of a talk that Ralph and yon

00:09:39,569 --> 00:09:47,490
another colleague had in MIDI debconf

00:09:42,779 --> 00:09:49,759
homework about why passing position is

00:09:47,490 --> 00:09:52,110
hard and how we did it in our project

00:09:49,759 --> 00:09:55,589
the problem with POSIX shell is that

00:09:52,110 --> 00:09:56,430
it's not designed to be too low passing

00:09:55,589 --> 00:09:59,819
of whole files

00:09:56,430 --> 00:10:02,730
it's designed to you you should pass

00:09:59,819 --> 00:10:04,079
first one complete command then execute

00:10:02,730 --> 00:10:07,380
it and yet then you can go back to

00:10:04,079 --> 00:10:10,199
passing which means that when you want

00:10:07,380 --> 00:10:16,800
to pass a whole script you can get into

00:10:10,199 --> 00:10:19,529
trouble also so also in order to have

00:10:16,800 --> 00:10:22,529
nice features like being able to write

00:10:19,529 --> 00:10:24,990
make it here for or things like that you

00:10:22,529 --> 00:10:28,350
have a parser that must be speculative

00:10:24,990 --> 00:10:31,110
and maybe promote keywords to keywords

00:10:28,350 --> 00:10:33,480
and try things and if that doesn't work

00:10:31,110 --> 00:10:43,139
try something else which is also hard to

00:10:33,480 --> 00:10:46,670
write yes and one specificity as part of

00:10:43,139 --> 00:10:49,470
POSIX shell is also these here documents

00:10:46,670 --> 00:10:52,319
and the difficulty about passing here

00:10:49,470 --> 00:10:55,050
documents is that there are not local

00:10:52,319 --> 00:10:57,480
things so first you pass your comment

00:10:55,050 --> 00:10:59,160
and when passing that comment you

00:10:57,480 --> 00:11:00,899
discover that there will be a certain

00:10:59,160 --> 00:11:04,680
number of here documents that you will

00:11:00,899 --> 00:11:06,180
have to pass afterwards and so you have

00:11:04,680 --> 00:11:07,360
to keep information about what you will

00:11:06,180 --> 00:11:11,200
need to do

00:11:07,360 --> 00:11:17,730
yeah after passing your comment an in

00:11:11,200 --> 00:11:21,160
fact in general passing statically one

00:11:17,730 --> 00:11:23,890
full script is undecidable because you

00:11:21,160 --> 00:11:26,950
can have aliases maybe in branching

00:11:23,890 --> 00:11:30,430
conditions which makes it hard even in a

00:11:26,950 --> 00:11:34,930
syntactic level to know that to pass the

00:11:30,430 --> 00:11:37,570
full file so we have a parser that's

00:11:34,930 --> 00:11:39,970
called mobic it's available in github if

00:11:37,570 --> 00:11:43,060
you want it's written in the language Oh

00:11:39,970 --> 00:11:45,100
camel and it use 1 parser generator

00:11:43,060 --> 00:11:47,350
mania so this is something we are proud

00:11:45,100 --> 00:11:51,130
of the fact that we use the parser

00:11:47,350 --> 00:11:54,540
generator the usual parsers for - and

00:11:51,130 --> 00:11:57,459
bash are in fact pieces of C code a

00:11:54,540 --> 00:12:00,010
handwritten working on a character level

00:11:57,459 --> 00:12:03,459
but basis and in our case we were able

00:12:00,010 --> 00:12:09,190
to use really like the grammar that was

00:12:03,459 --> 00:12:10,870
in the specification of POSIX the mania

00:12:09,190 --> 00:12:13,149
parser generator is a great tool that

00:12:10,870 --> 00:12:15,790
allowed us to not only write the grammar

00:12:13,149 --> 00:12:18,089
but write the exceptions in the grammar

00:12:15,790 --> 00:12:21,300
that are required in order to have these

00:12:18,089 --> 00:12:25,120
speculative parsing that shall requires

00:12:21,300 --> 00:12:28,990
it allows that by giving you the way to

00:12:25,120 --> 00:12:31,810
introspect the statues of the parser and

00:12:28,990 --> 00:12:33,850
to to maybe update it yourself if you

00:12:31,810 --> 00:12:36,550
want that is you can look at the passer

00:12:33,850 --> 00:12:39,220
say oh it's starting to pass I don't

00:12:36,550 --> 00:12:41,620
know a new comment so this is a place

00:12:39,220 --> 00:12:45,279
where if you read for this might be a

00:12:41,620 --> 00:12:47,410
keyword when you are somewhere else you

00:12:45,279 --> 00:12:49,930
say I already I have started passing my

00:12:47,410 --> 00:12:52,690
command I read for I will keep it as a

00:12:49,930 --> 00:12:54,820
simple word and work that way so this is

00:12:52,690 --> 00:12:59,620
something that is provided by these menu

00:12:54,820 --> 00:13:03,220
Pasadena not so generator this allows us

00:12:59,620 --> 00:13:05,110
to have mainly really high level codes

00:13:03,220 --> 00:13:07,540
that you can easily relate to the

00:13:05,110 --> 00:13:08,890
standard so you take the drama that is

00:13:07,540 --> 00:13:11,199
written in the standard you take the

00:13:08,890 --> 00:13:13,720
grammar that is written in our tool and

00:13:11,199 --> 00:13:17,970
you can see that they do the same thing

00:13:13,720 --> 00:13:20,080
and if you want to know more about only

00:13:17,970 --> 00:13:23,140
things that happen in the in

00:13:20,080 --> 00:13:25,360
this tool there is already so probably

00:13:23,140 --> 00:13:28,140
the mini debconf talk in humbug that has

00:13:25,360 --> 00:13:28,140
been recorded

00:13:28,260 --> 00:13:34,420
what modded morbid produces is what we

00:13:31,540 --> 00:13:37,360
call a concrete syntax tree this is a

00:13:34,420 --> 00:13:41,380
huge tree with in our case on more than

00:13:37,360 --> 00:13:43,330
50 recursive type definitions and in

00:13:41,380 --> 00:13:45,670
fact what this tree represents is all

00:13:43,330 --> 00:13:47,980
the grammar rules that have been used to

00:13:45,670 --> 00:13:50,230
pass the script so I don't know if

00:13:47,980 --> 00:13:53,920
that's readable on the slides but you

00:13:50,230 --> 00:13:56,920
have like one type type pair grammar

00:13:53,920 --> 00:14:01,600
rule so a complete common a c-list and

00:13:56,920 --> 00:14:04,680
or and then one one constructor of type

00:14:01,600 --> 00:14:07,270
pair sorry about that

00:14:04,680 --> 00:14:10,330
rule of the grammar that you applied in

00:14:07,270 --> 00:14:12,190
that case so this corresponds directly

00:14:10,330 --> 00:14:14,830
to the grammar of the project standard

00:14:12,190 --> 00:14:19,900
once again and so you can work on really

00:14:14,830 --> 00:14:23,080
what has been used in our case we will

00:14:19,900 --> 00:14:25,270
want to crawl through these trees to

00:14:23,080 --> 00:14:28,180
traverse them to look at certain places

00:14:25,270 --> 00:14:31,030
like what happens in resurrections in

00:14:28,180 --> 00:14:34,960
function definitions and so on since

00:14:31,030 --> 00:14:37,300
it's a huge tree we would have to code

00:14:34,960 --> 00:14:40,840
functions for all the cases of the tree

00:14:37,300 --> 00:14:44,920
say saying mostly just keep going down

00:14:40,840 --> 00:14:46,570
in the tree and traverse the tree so

00:14:44,920 --> 00:14:48,640
that that would be really painful

00:14:46,570 --> 00:14:52,570
hopefully we use something called the

00:14:48,640 --> 00:14:54,360
visitor design pattern so there are what

00:14:52,570 --> 00:14:56,770
we call the visitors and you have seven

00:14:54,360 --> 00:14:59,590
kinds of visitors that are generated

00:14:56,770 --> 00:15:02,280
automatically so we don't do that in the

00:14:59,590 --> 00:15:05,830
in the mobic parser and what they are

00:15:02,280 --> 00:15:09,490
there there are objects that just do

00:15:05,830 --> 00:15:13,870
nothing but travel the whole tree which

00:15:09,490 --> 00:15:15,790
means that you can later just inherit

00:15:13,870 --> 00:15:18,460
from these objects and override just the

00:15:15,790 --> 00:15:20,650
path that is of interest and it makes it

00:15:18,460 --> 00:15:23,290
really easy to write something that go

00:15:20,650 --> 00:15:25,450
look into only simple comments not

00:15:23,290 --> 00:15:27,900
touching the rest we'll have an example

00:15:25,450 --> 00:15:27,900
in a moment

00:15:29,790 --> 00:15:35,670
so once we we have this parser and these

00:15:32,370 --> 00:15:40,260
nice tools we have written a tool just

00:15:35,670 --> 00:15:42,449
that runs testicle analysis of shell

00:15:40,260 --> 00:15:45,560
scripts because we wanted to know what

00:15:42,449 --> 00:15:48,660
what was in this callous shell scripts

00:15:45,560 --> 00:15:53,639
because that would quite our intuitions

00:15:48,660 --> 00:15:54,990
and what we would do in the project so

00:15:53,639 --> 00:15:57,570
this is another tool that is also

00:15:54,990 --> 00:16:03,209
available in github with we call it

00:15:57,570 --> 00:16:04,860
assess stats we didn't have a fancy name

00:16:03,209 --> 00:16:07,139
for it

00:16:04,860 --> 00:16:12,029
it worked directly on the syntax tree

00:16:07,139 --> 00:16:15,269
that mobic outputs it has a pre post

00:16:12,029 --> 00:16:17,579
processing file phase for the shells for

00:16:15,269 --> 00:16:19,680
the scripts ray tries to expanse the

00:16:17,579 --> 00:16:22,110
parameters that you can know locally

00:16:19,680 --> 00:16:23,339
that is if you have a constant that is

00:16:22,110 --> 00:16:25,079
defined at the beginning of your

00:16:23,339 --> 00:16:26,660
document you are able to replace it

00:16:25,079 --> 00:16:29,720
everywhere in the document

00:16:26,660 --> 00:16:31,649
Ralph will talk about that later and

00:16:29,720 --> 00:16:35,850
because of the visitor design pattern

00:16:31,649 --> 00:16:38,399
it's easy to add an analyzer module and

00:16:35,850 --> 00:16:40,410
here is an example so it's quite a lot

00:16:38,399 --> 00:16:46,589
of stuff but let's break it down to

00:16:40,410 --> 00:16:48,870
pieces quite fast so analyzer you just

00:16:46,589 --> 00:16:51,600
have to give it a name and you give it a

00:16:48,870 --> 00:16:54,959
name and the of the common line options

00:16:51,600 --> 00:16:58,350
that it requires that's just for SH

00:16:54,959 --> 00:17:01,290
States to know who who this analyzer is

00:16:58,350 --> 00:17:03,600
and then you write a process script

00:17:01,290 --> 00:17:06,480
function that will just be the way SH

00:17:03,600 --> 00:17:10,079
States provide the script to the

00:17:06,480 --> 00:17:13,650
analyzer and in that case it's a simple

00:17:10,079 --> 00:17:16,220
analyzer that just tries to see if there

00:17:13,650 --> 00:17:20,429
are if you can find dollar that

00:17:16,220 --> 00:17:23,280
character dollar in the words and what

00:17:20,429 --> 00:17:24,870
you do is do you create an object so it

00:17:23,280 --> 00:17:27,059
starts here you create an object you

00:17:24,870 --> 00:17:30,320
inherit from one of these videos

00:17:27,059 --> 00:17:33,540
visitors and you just have to override

00:17:30,320 --> 00:17:35,309
one method and this is what is here you

00:17:33,540 --> 00:17:39,330
just have a write the method that visits

00:17:35,309 --> 00:17:40,919
the words so all the other functions

00:17:39,330 --> 00:17:42,590
will still be the same and we'll just

00:17:40,919 --> 00:17:47,340
crawl the

00:17:42,590 --> 00:17:49,590
the CST and this specific function will

00:17:47,340 --> 00:17:52,620
just test whether you have a dollar in

00:17:49,590 --> 00:17:54,540
the world right which makes it like in

00:17:52,620 --> 00:17:57,809
ten lines you've written something that

00:17:54,540 --> 00:18:00,270
goes down the whole tree and read at a

00:17:57,809 --> 00:18:05,030
certain place in the grammar if there

00:18:00,270 --> 00:18:09,679
are dollars all right

00:18:05,030 --> 00:18:12,330
and then what you do is you just ask

00:18:09,679 --> 00:18:14,669
this object to crawl the whole tree and

00:18:12,330 --> 00:18:18,090
if it returns that yes indeed I found a

00:18:14,669 --> 00:18:23,720
dollar you add the file name into a list

00:18:18,090 --> 00:18:23,720
of files that contain sternos I think

00:18:24,049 --> 00:18:31,530
and and then you have just to be able to

00:18:28,679 --> 00:18:34,230
output a report about what the analyzer

00:18:31,530 --> 00:18:35,910
did in that case you just right here is

00:18:34,230 --> 00:18:37,770
the number of scripts containing a

00:18:35,910 --> 00:18:40,049
dollar and then the list of scripts if

00:18:37,770 --> 00:18:45,410
you want to see why they're here and

00:18:40,049 --> 00:18:48,690
what kind of the Lord right in that case

00:18:45,410 --> 00:18:51,390
just counting dollars have been done in

00:18:48,690 --> 00:18:52,950
with grep and actually that's what I was

00:18:51,390 --> 00:18:56,610
doing in like two years ago a lot of

00:18:52,950 --> 00:18:58,500
great things except that then you you

00:18:56,610 --> 00:19:00,630
you see that you have detective dollars

00:18:58,500 --> 00:19:01,919
that were in comments so you have to

00:19:00,630 --> 00:19:04,049
remove the comments you can still do

00:19:01,919 --> 00:19:06,390
that we said maybe and then inside

00:19:04,049 --> 00:19:08,070
quotes and then there are here documents

00:19:06,390 --> 00:19:09,870
that are not expanded so you should

00:19:08,070 --> 00:19:14,160
count if you don't count the dollars in

00:19:09,870 --> 00:19:23,450
there and then so each time you you you

00:19:14,160 --> 00:19:23,450
you see that I can't hear you sir

00:19:26,350 --> 00:19:32,900
if please go to the mic okay so so so i

00:19:30,980 --> 00:19:34,460
think what-whatever then was saying if

00:19:32,900 --> 00:19:36,620
you do a quip you get only one

00:19:34,460 --> 00:19:37,910
occurrence per line which is counted but

00:19:36,620 --> 00:19:39,860
the things there are options to crap

00:19:37,910 --> 00:19:43,070
which you allow you to to count all

00:19:39,860 --> 00:19:46,100
other currencies on the line well the

00:19:43,070 --> 00:19:48,110
point is grep is limited because well

00:19:46,100 --> 00:19:50,320
limited it does what it is supposed to

00:19:48,110 --> 00:19:53,990
do but we need more than that here and

00:19:50,320 --> 00:19:56,059
in this case so first having really this

00:19:53,990 --> 00:19:58,280
parser and this tree traversal allows us

00:19:56,059 --> 00:20:01,160
to have this expansion phase that

00:19:58,280 --> 00:20:02,929
helpers like explaining variables we'll

00:20:01,160 --> 00:20:05,120
talk about that I think in the next

00:20:02,929 --> 00:20:07,520
slide and then you can do much more

00:20:05,120 --> 00:20:09,140
complicated things like if you count the

00:20:07,520 --> 00:20:11,900
dollars but you don't want to count two

00:20:09,140 --> 00:20:15,080
dollar that is a variable bind by a for

00:20:11,900 --> 00:20:17,000
loop for instance we can do that easily

00:20:15,080 --> 00:20:21,320
in our tool and grab from completely

00:20:17,000 --> 00:20:25,760
well it's not made for that and I'll

00:20:21,320 --> 00:20:26,809
leave okay to talk about so I would like

00:20:25,760 --> 00:20:29,179
to talk a little bit about this

00:20:26,809 --> 00:20:31,720
expansion which might seem trivial at

00:20:29,179 --> 00:20:34,160
first sight so what it what it does is I

00:20:31,720 --> 00:20:35,720
record you that we try to add to analyze

00:20:34,160 --> 00:20:37,070
the script statically that that is

00:20:35,720 --> 00:20:39,230
without executing it

00:20:37,070 --> 00:20:41,600
however there are some when you do that

00:20:39,230 --> 00:20:44,150
we are often when you add a short script

00:20:41,600 --> 00:20:46,550
you do definitions and bindings of

00:20:44,150 --> 00:20:49,220
variables which are in reality constants

00:20:46,550 --> 00:20:51,440
so you point them once and then you use

00:20:49,220 --> 00:20:53,540
all the same value for the same variable

00:20:51,440 --> 00:20:55,970
all the time and you would like to

00:20:53,540 --> 00:20:58,130
exploit this and our analysis so stuff

00:20:55,970 --> 00:21:00,110
like this so you define a variable X and

00:20:58,130 --> 00:21:02,960
then any point you define a variable Y

00:21:00,110 --> 00:21:06,050
so you would find in line for in fact

00:21:02,960 --> 00:21:09,470
statically even that X must be one and y

00:21:06,050 --> 00:21:12,500
must be two and on line seven you would

00:21:09,470 --> 00:21:14,090
find that X still must be one and now

00:21:12,500 --> 00:21:16,309
why must be sweetie because now you

00:21:14,090 --> 00:21:19,700
execute it yet sponsor notice and branch

00:21:16,309 --> 00:21:23,900
however if you drop out of three

00:21:19,700 --> 00:21:25,880
conditioner then you now stood that X as

00:21:23,900 --> 00:21:27,890
value one because you haven't changed it

00:21:25,880 --> 00:21:30,590
anyway during the conditioner

00:21:27,890 --> 00:21:33,410
however you don't know now what why what

00:21:30,590 --> 00:21:36,350
the value of y is it could be one of two

00:21:33,410 --> 00:21:38,620
or three but we are doing not this kind

00:21:36,350 --> 00:21:40,779
of set based analysis now we just

00:21:38,620 --> 00:21:43,720
would exploit the fact that we know that

00:21:40,779 --> 00:21:46,120
X has value 1 and y we know nothing

00:21:43,720 --> 00:21:50,350
about why okay so this looks quite easy

00:21:46,120 --> 00:21:55,419
however it is sure and shell is weird

00:21:50,350 --> 00:21:57,400
and well let's start to explain why I

00:21:55,419 --> 00:22:00,850
think that why we think that shell is

00:21:57,400 --> 00:22:02,890
weird let's do a little quiz so imagine

00:22:00,850 --> 00:22:04,000
you have a shell script and in the shell

00:22:02,890 --> 00:22:06,850
script you have these three lines

00:22:04,000 --> 00:22:09,549
written written on top of the slide so X

00:22:06,850 --> 00:22:12,250
is 1 then you have something like x

00:22:09,549 --> 00:22:15,039
equals 2 and a call to something food

00:22:12,250 --> 00:22:17,799
whatever and then you do AG equal to X

00:22:15,039 --> 00:22:20,740
so what should in your opinion P the

00:22:17,799 --> 00:22:22,360
value which is printed by this so

00:22:20,740 --> 00:22:28,960
possible choices I give you five choices

00:22:22,360 --> 00:22:34,659
the choices are 1 273 syntax error or it

00:22:28,960 --> 00:22:39,220
depends okay

00:22:34,659 --> 00:22:41,020
any other opinions when I could beat a 5

00:22:39,220 --> 00:22:54,850
ok five so two people are saying it

00:22:41,020 --> 00:22:57,610
depends very good it depends on what ok

00:22:54,850 --> 00:23:01,870
at x equals two that variable setting is

00:22:57,610 --> 00:23:04,000
scoped to the line so at first when

00:23:01,870 --> 00:23:06,279
you're just learning shell and learning

00:23:04,000 --> 00:23:09,130
it well you would say oh well because

00:23:06,279 --> 00:23:11,620
that variable assignment goes out of

00:23:09,130 --> 00:23:15,520
scope after the command is executed X

00:23:11,620 --> 00:23:17,169
must equal 1 however it's not that you

00:23:15,520 --> 00:23:18,669
can't be so sure because foo might be

00:23:17,169 --> 00:23:21,159
something that sets X and then re

00:23:18,669 --> 00:23:21,789
exports it to the environment that's

00:23:21,159 --> 00:23:26,470
true too

00:23:21,789 --> 00:23:28,960
ok so it depends okay thank you so it

00:23:26,470 --> 00:23:30,640
depends in fact on several things the

00:23:28,960 --> 00:23:33,340
first thing it depends on is whether foo

00:23:30,640 --> 00:23:35,919
is a function or a special version of

00:23:33,340 --> 00:23:38,220
the shell on the one hand or that our

00:23:35,919 --> 00:23:40,510
foo is an external command a command

00:23:38,220 --> 00:23:40,929
which will be spawned as an external

00:23:40,510 --> 00:23:44,020
process

00:23:40,929 --> 00:23:46,750
so if foo is something like bin whatever

00:23:44,020 --> 00:23:49,149
which spawns the process then in fact

00:23:46,750 --> 00:23:51,730
the assignment of x - 2 is local to this

00:23:49,149 --> 00:23:54,279
line so in this case you would see

00:23:51,730 --> 00:23:55,870
the value of one however if who is a

00:23:54,279 --> 00:23:59,230
special billion officer or it's a

00:23:55,870 --> 00:24:02,080
function then the assignment of X to the

00:23:59,230 --> 00:24:03,789
value of two will be global to the

00:24:02,080 --> 00:24:06,490
context of the shell and in this case

00:24:03,789 --> 00:24:08,649
you will see the value of two however if

00:24:06,490 --> 00:24:10,389
who is a function foo itself can also

00:24:08,649 --> 00:24:12,669
set a variable X as you correctly

00:24:10,389 --> 00:24:14,260
pointed out and then you could indeed

00:24:12,669 --> 00:24:17,950
obtain the value of seventy three in

00:24:14,260 --> 00:24:22,529
this case however the oldest shells

00:24:17,950 --> 00:24:26,110
didn't have functions so it must be one

00:24:22,529 --> 00:24:27,850
using an older shell well we are talking

00:24:26,110 --> 00:24:31,120
about cosec shots and pausing shells

00:24:27,850 --> 00:24:33,460
have posted shells have a master

00:24:31,120 --> 00:24:35,260
functions so this is definitely

00:24:33,460 --> 00:24:38,049
something in all the shells which are

00:24:35,260 --> 00:24:40,899
permitted by by policy something which

00:24:38,049 --> 00:24:43,059
is which is possible and in special

00:24:40,899 --> 00:24:44,620
abilities and special burdens okay so I

00:24:43,059 --> 00:24:47,529
think they have to hurry up a little bit

00:24:44,620 --> 00:24:51,010
so just to show you that this is a more

00:24:47,529 --> 00:24:53,559
complicated case so this is kind of

00:24:51,010 --> 00:24:55,720
surprising in case you don't know what

00:24:53,559 --> 00:24:57,370
it means so here you have a prefix then

00:24:55,720 --> 00:25:00,340
you have here something which which will

00:24:57,370 --> 00:25:02,889
spawn the process and then you a KO

00:25:00,340 --> 00:25:10,049
something and in fact what happens here

00:25:02,889 --> 00:25:15,880
is where I can can execute it - son and

00:25:10,049 --> 00:25:17,580
process what it does is it prints a so

00:25:15,880 --> 00:25:19,809
this is the first line this one's a

00:25:17,580 --> 00:25:21,669
which is kind of surprising because of

00:25:19,809 --> 00:25:24,460
the prefix you set that exit speed and

00:25:21,669 --> 00:25:26,889
why is something and also C gets an

00:25:24,460 --> 00:25:28,659
assignment by the parameter expansion

00:25:26,889 --> 00:25:31,690
here however this is not yet visible

00:25:28,659 --> 00:25:34,480
when you expand the suffix of the

00:25:31,690 --> 00:25:37,419
command which is kind of surprising okay

00:25:34,480 --> 00:25:39,549
then we have seen these bond process so

00:25:37,419 --> 00:25:41,740
all the assignments which have been done

00:25:39,549 --> 00:25:44,320
by the prefix should not be visible

00:25:41,740 --> 00:25:47,740
after execution of the process however

00:25:44,320 --> 00:25:50,470
what we see is - and it will be the same

00:25:47,740 --> 00:25:54,700
dispatch and when POSIX mode is we see a

00:25:50,470 --> 00:25:56,740
E and C which means that Y is the

00:25:54,700 --> 00:25:59,019
assignment of Y really it's not visible

00:25:56,740 --> 00:26:02,710
here however the assignment of C of

00:25:59,019 --> 00:26:04,690
offset is so it's kind of reactor so the

00:26:02,710 --> 00:26:05,320
semantics is Fiat and the syntax is Fiat

00:26:04,690 --> 00:26:07,179
and

00:26:05,320 --> 00:26:10,899
we are having a lot of fun of

00:26:07,179 --> 00:26:13,600
discovering various features features of

00:26:10,899 --> 00:26:17,139
the Shelly so it's not up not trivial at

00:26:13,600 --> 00:26:19,690
all so not now what we found effectively

00:26:17,139 --> 00:26:21,610
on analyzing the corpus of Martinez

00:26:19,690 --> 00:26:24,490
scripts first we found some really

00:26:21,610 --> 00:26:26,259
really trivial things which would not

00:26:24,490 --> 00:26:28,659
have required a part at all

00:26:26,259 --> 00:26:31,600
so this was really really easy the first

00:26:28,659 --> 00:26:34,960
thing is missing she banks in maintainer

00:26:31,600 --> 00:26:36,730
scripts in fact policy says they should

00:26:34,960 --> 00:26:40,360
be there and the maintainer scripts and

00:26:36,730 --> 00:26:42,820
we found about 40 packages which did not

00:26:40,360 --> 00:26:46,990
have some and then we did according to

00:26:42,820 --> 00:26:48,850
our regulation to our woods but what has

00:26:46,990 --> 00:26:50,830
to be done so we announced the mass spec

00:26:48,850 --> 00:26:52,779
filing there was some discussion about

00:26:50,830 --> 00:26:56,019
the severity which would be appropriate

00:26:52,779 --> 00:26:58,690
for this and we settled on important and

00:26:56,019 --> 00:27:00,669
almost all of them have have been fixed

00:26:58,690 --> 00:27:02,889
so far so things for that the only five

00:27:00,669 --> 00:27:05,529
remaining of them and these five are

00:27:02,889 --> 00:27:07,690
precisely 5sq scripts Eska files I

00:27:05,529 --> 00:27:09,429
talked about when I talked with an

00:27:07,690 --> 00:27:13,509
ability to break down according to

00:27:09,429 --> 00:27:16,120
language then set - he said - e is

00:27:13,509 --> 00:27:18,850
necessary to make shell scripts fail in

00:27:16,120 --> 00:27:22,120
case one of the commands in the shell

00:27:18,850 --> 00:27:24,279
script itself fails and they should it's

00:27:22,120 --> 00:27:25,929
written they should be say this should

00:27:24,279 --> 00:27:28,330
be done by any maintainer script either

00:27:25,929 --> 00:27:31,419
by setting set a - e this is the normal

00:27:28,330 --> 00:27:33,970
way to do it or by taking care of a how

00:27:31,419 --> 00:27:37,000
you Lance how you invoke external

00:27:33,970 --> 00:27:41,190
commands and make them fail if a person

00:27:37,000 --> 00:27:44,889
doesn't exit one in case something not

00:27:41,190 --> 00:27:47,169
expected so we found again some 50

00:27:44,889 --> 00:27:49,990
packages which do not follow this policy

00:27:47,169 --> 00:27:51,940
I looked at all of these cases to ensure

00:27:49,990 --> 00:27:54,850
that imitating I did not something else

00:27:51,940 --> 00:27:57,009
to make it fail as it should and it it's

00:27:54,850 --> 00:27:59,769
a mass spec filing again after

00:27:57,009 --> 00:28:03,009
discussion and about a quarter of them

00:27:59,769 --> 00:28:07,389
have been fixed so far then we have the

00:28:03,009 --> 00:28:09,250
case of local maybe we should skip over

00:28:07,389 --> 00:28:12,100
this because we are already a little bit

00:28:09,250 --> 00:28:13,600
short of time local is also strange and

00:28:12,100 --> 00:28:16,090
she'll everything is to ensure the

00:28:13,600 --> 00:28:18,070
reason why local is sure just very very

00:28:16,090 --> 00:28:21,790
quickly is

00:28:18,070 --> 00:28:24,309
local does not have an end as in Java

00:28:21,790 --> 00:28:25,660
but you have a bracket group and you

00:28:24,309 --> 00:28:27,970
have a local variable local to the

00:28:25,660 --> 00:28:30,700
bracket group local insurance justice

00:28:27,970 --> 00:28:32,860
from now on that variable is local okay

00:28:30,700 --> 00:28:36,070
and then you made stuff something like

00:28:32,860 --> 00:28:38,020
this which makes a variable X local

00:28:36,070 --> 00:28:40,270
dependent on something which happened

00:28:38,020 --> 00:28:42,760
before and this means that the pasar if

00:28:40,270 --> 00:28:44,950
you imagine that you would like to have

00:28:42,760 --> 00:28:46,720
to add a compiler for sure a parser

00:28:44,950 --> 00:28:49,360
cannot know whether a variable it's

00:28:46,720 --> 00:28:53,500
local or not and that's that's strange

00:28:49,360 --> 00:28:55,210
okay again and we found indeed that

00:28:53,500 --> 00:28:58,390
there are some cases it is just

00:28:55,210 --> 00:29:01,330
yesterday so this we didn't look it into

00:28:58,390 --> 00:29:04,120
this into it in detail but there are 280

00:29:01,330 --> 00:29:05,920
cases indeed versus a local inside a

00:29:04,120 --> 00:29:08,710
control structure of a while sometimes

00:29:05,920 --> 00:29:10,720
even and we have to look a more in

00:29:08,710 --> 00:29:15,309
detail into this to see whether this is

00:29:10,720 --> 00:29:18,910
a problem then we have more stuff I

00:29:15,309 --> 00:29:21,250
think we should skip also over this then

00:29:18,910 --> 00:29:23,380
we did an analysis of the commands and

00:29:21,250 --> 00:29:25,150
give back to Nicola of the commands and

00:29:23,380 --> 00:29:26,860
they did this in fact because we just

00:29:25,150 --> 00:29:29,080
wanted to know which commands are mostly

00:29:26,860 --> 00:29:33,070
used in the scripts in order to know how

00:29:29,080 --> 00:29:35,020
we should build up our AA model all

00:29:33,070 --> 00:29:36,820
right I was just checking with you you

00:29:35,020 --> 00:29:39,610
weren't seeing the results so in your

00:29:36,820 --> 00:29:41,410
opinion what would be the three most

00:29:39,610 --> 00:29:43,330
used so maybe we won't do that we don't

00:29:41,410 --> 00:29:46,030
have time but you can just imagine what

00:29:43,330 --> 00:29:47,440
would be the three most used do you

00:29:46,030 --> 00:29:49,510
really see that you can read it all

00:29:47,440 --> 00:29:52,090
right it's visible so the first one is

00:29:49,510 --> 00:29:56,260
test we took you in like half of the

00:29:52,090 --> 00:29:58,630
scripts but then more like in in average

00:29:56,260 --> 00:30:01,330
four times the script people seem to

00:29:58,630 --> 00:30:02,920
like tests that's good then you have set

00:30:01,330 --> 00:30:06,400
which is presently small scripts which

00:30:02,920 --> 00:30:09,580
is something we almost already said the

00:30:06,400 --> 00:30:11,679
third one is true actually in number of

00:30:09,580 --> 00:30:15,790
occurrences not files because people

00:30:11,679 --> 00:30:18,940
love to do all true just to forget about

00:30:15,790 --> 00:30:22,120
a mistake so there are not so many files

00:30:18,940 --> 00:30:25,840
using them but when they do they do use

00:30:22,120 --> 00:30:28,900
them a lot and then you have others so

00:30:25,840 --> 00:30:32,559
we have interesting maybe you have which

00:30:28,900 --> 00:30:34,750
that is not so here you have which which

00:30:32,559 --> 00:30:36,700
is present in like half of the file so

00:30:34,750 --> 00:30:38,890
if we if we were to our order than my

00:30:36,700 --> 00:30:42,789
files it would be set then test then

00:30:38,890 --> 00:30:44,890
which that and we see difficulty main

00:30:42,789 --> 00:30:49,330
script helper that's good to shade that

00:30:44,890 --> 00:30:52,779
or depth system the helper and maybe we

00:30:49,330 --> 00:30:54,700
won't pass so much time on this slide so

00:30:52,779 --> 00:30:57,159
we have an analyzer that gives us which

00:30:54,700 --> 00:30:59,650
command are used and in which way so for

00:30:57,159 --> 00:31:02,559
instance if you look at in which way set

00:30:59,650 --> 00:31:05,679
is used you see that in a huge amount of

00:31:02,559 --> 00:31:08,980
cases it's for the - 'flag which once

00:31:05,679 --> 00:31:11,169
again is not very surprising if we look

00:31:08,980 --> 00:31:14,440
at like potentially dangerous commands

00:31:11,169 --> 00:31:16,960
like remove you have that most of the

00:31:14,440 --> 00:31:21,669
time it's the force flag that is used

00:31:16,960 --> 00:31:25,570
and sometimes records even force which

00:31:21,669 --> 00:31:27,490
is like the frightening part and if you

00:31:25,570 --> 00:31:30,070
look at for instance dpkg you can see

00:31:27,490 --> 00:31:32,080
that most of four out of five cases of

00:31:30,070 --> 00:31:36,190
the key PKG are just there to list the

00:31:32,080 --> 00:31:42,070
files of the of the package probably to

00:31:36,190 --> 00:31:44,320
remove some of them maybe i'll just do

00:31:42,070 --> 00:31:45,490
it and yes when you look at that so the

00:31:44,320 --> 00:31:48,520
first thing you have to do is you look

00:31:45,490 --> 00:31:50,020
at what is used the less because it's

00:31:48,520 --> 00:31:53,470
sometimes where we are think that

00:31:50,020 --> 00:31:55,929
happens all right and for instance this

00:31:53,470 --> 00:31:58,600
is how you you can see that you discover

00:31:55,929 --> 00:32:00,460
mcdeere - f you say what is it you check

00:31:58,600 --> 00:32:02,950
that it doesn't exist and we find a few

00:32:00,460 --> 00:32:06,490
bugs like that in that case it was made

00:32:02,950 --> 00:32:07,990
year - P ok yeah ok

00:32:06,490 --> 00:32:13,240
then we looked a little bit more in

00:32:07,990 --> 00:32:15,429
detail on on tests we wrote a little

00:32:13,240 --> 00:32:18,370
parser for the test expression itself

00:32:15,429 --> 00:32:19,690
and so we have we have here some

00:32:18,370 --> 00:32:22,210
statistics about the different

00:32:19,690 --> 00:32:25,570
comparison operators and you know a file

00:32:22,210 --> 00:32:27,460
test operators I won't talk about this I

00:32:25,570 --> 00:32:30,190
would like to talk about something else

00:32:27,460 --> 00:32:32,620
which is more interesting in fact well

00:32:30,190 --> 00:32:35,320
maybe here you see these are the binary

00:32:32,620 --> 00:32:38,919
operators which are mostly used luckily

00:32:35,320 --> 00:32:40,770
for us sees the last ones are not POSIX

00:32:38,919 --> 00:32:45,540
they are supported by by

00:32:40,770 --> 00:32:48,480
like no contest and in fact MT is newest

00:32:45,540 --> 00:32:50,190
and comparing the timestamps and EF this

00:32:48,480 --> 00:32:52,650
would be troublesome for us for doing

00:32:50,190 --> 00:32:54,809
theoretical metallization or fired

00:32:52,650 --> 00:32:57,720
Sutton's of file systems because it

00:32:54,809 --> 00:33:01,260
means comparing whether two passes point

00:32:57,720 --> 00:33:03,059
to the same inode and if this were used

00:33:01,260 --> 00:33:05,460
a lot it would mean that you would have

00:33:03,059 --> 00:33:07,770
to model a file systems like like like

00:33:05,460 --> 00:33:09,480
like the X like graphs and the fact that

00:33:07,770 --> 00:33:11,550
this is not use means we can't just

00:33:09,480 --> 00:33:15,210
model same as trees and just ignore the

00:33:11,550 --> 00:33:19,130
cases where something like EF is used I

00:33:15,210 --> 00:33:22,860
would like to talk about - a and - oh

00:33:19,130 --> 00:33:26,820
why because they are mentioned in the

00:33:22,860 --> 00:33:28,770
policy so policy again says test if

00:33:26,820 --> 00:33:31,920
implemented has a built in mass support

00:33:28,770 --> 00:33:35,100
- a and - OH - a and - OH are for end

00:33:31,920 --> 00:33:37,950
and for all to combine complex tests

00:33:35,100 --> 00:33:40,559
however when you look at what was

00:33:37,950 --> 00:33:42,990
success for success well it's obsolete

00:33:40,559 --> 00:33:44,309
first of all it's an extension only it's

00:33:42,990 --> 00:33:46,800
not in the core of the POSIX standard

00:33:44,309 --> 00:33:49,320
and furthermore it's mentioned as being

00:33:46,800 --> 00:33:49,590
obsolete and it's recommended not to use

00:33:49,320 --> 00:33:52,440
it

00:33:49,590 --> 00:33:54,240
why in fact it new page so that's

00:33:52,440 --> 00:33:58,559
exactly the same thing and the reason

00:33:54,240 --> 00:34:00,240
why both recommend to not not use it any

00:33:58,559 --> 00:34:03,720
longer it's the same because it's

00:34:00,240 --> 00:34:06,570
ambiguous and why didn't because well

00:34:03,720 --> 00:34:09,060
this comes from the fact that test

00:34:06,570 --> 00:34:11,369
expressions contain also a special case

00:34:09,060 --> 00:34:14,129
which allows you to write a test without

00:34:11,369 --> 00:34:15,840
any operator if in fact if you write and

00:34:14,129 --> 00:34:18,600
the first expression only one single

00:34:15,840 --> 00:34:20,580
word it is already a valid test in fact

00:34:18,600 --> 00:34:24,119
it is a test whether that word is non

00:34:20,580 --> 00:34:26,460
empty or not so like writing - - and in

00:34:24,119 --> 00:34:28,440
front of it in this case you can trust

00:34:26,460 --> 00:34:31,139
to optimize SN and that makes the whole

00:34:28,440 --> 00:34:33,270
thing completely ambiguous for instance

00:34:31,139 --> 00:34:36,450
a valid test expression is something

00:34:33,270 --> 00:34:39,960
like this parentheses equals parentheses

00:34:36,450 --> 00:34:42,300
and there are two ways to witness and

00:34:39,960 --> 00:34:44,399
first of all it you might find strange

00:34:42,300 --> 00:34:46,950
that someone would write it but maybe

00:34:44,399 --> 00:34:48,899
someone didn't write it directly but he

00:34:46,950 --> 00:34:50,070
wrote one this is dollar 1 equals dollar

00:34:48,899 --> 00:34:52,920
2 parentheses

00:34:50,070 --> 00:34:55,170
and then T's to power per parameters are

00:34:52,920 --> 00:34:56,730
expanded to nothing and then you obtain

00:34:55,170 --> 00:34:59,550
what you have written here in fact you

00:34:56,730 --> 00:35:01,920
can read it ISA s left parenthesis is

00:34:59,550 --> 00:35:05,250
the same as Y parenthesis this would be

00:35:01,920 --> 00:35:08,130
fourths or you could read it as the

00:35:05,250 --> 00:35:10,560
string equal is non-empty and this test

00:35:08,130 --> 00:35:13,770
is written between parentheses and this

00:35:10,560 --> 00:35:16,080
would be true so it's ambiguous and it's

00:35:13,770 --> 00:35:18,000
a structure and in fact this can also

00:35:16,080 --> 00:35:20,310
lead to an ambiguity and the result

00:35:18,000 --> 00:35:21,870
which would be obtained and then you can

00:35:20,310 --> 00:35:24,180
do funny stuff like this this is in fact

00:35:21,870 --> 00:35:27,630
legal a legal test - a - M enzyme enzyme

00:35:24,180 --> 00:35:30,420
- a for me says only one possible

00:35:27,630 --> 00:35:33,330
reading but apparently there are other

00:35:30,420 --> 00:35:36,540
opinions because in fact - says that

00:35:33,330 --> 00:35:40,200
result of this is 0 and - even in POSIX

00:35:36,540 --> 00:35:42,840
mode says it's 1 so it's weird again and

00:35:40,200 --> 00:35:47,130
maybe this is a good reason why we

00:35:42,840 --> 00:35:49,440
should not really use this and in fact

00:35:47,130 --> 00:35:50,970
you can of course we place it just by

00:35:49,440 --> 00:35:54,650
the end and all operators of the shell

00:35:50,970 --> 00:35:57,270
which is a much safer way to do this ok

00:35:54,650 --> 00:35:59,430
another interesting thing is and this is

00:35:57,270 --> 00:36:05,040
again a design flaw of the of the show

00:35:59,430 --> 00:36:07,710
is that we found almost ten errors in

00:36:05,040 --> 00:36:10,260
the test expressions in fact syntactic

00:36:07,710 --> 00:36:14,400
errors and the test expressions in the

00:36:10,260 --> 00:36:16,320
meta scripts and now one has to

00:36:14,400 --> 00:36:18,510
understand why this hasn't been detected

00:36:16,320 --> 00:36:20,430
before one would expect that if someone

00:36:18,510 --> 00:36:22,320
doesn't say tactic error and the test

00:36:20,430 --> 00:36:24,900
expression then the first person who

00:36:22,320 --> 00:36:26,400
installed the package will find this

00:36:24,900 --> 00:36:29,490
error and complain and send it back

00:36:26,400 --> 00:36:33,780
report this hasn't happened why in fact

00:36:29,490 --> 00:36:36,330
shell confuses the boolean conditions to

00:36:33,780 --> 00:36:39,330
enforce this person's and absence of

00:36:36,330 --> 00:36:41,460
errors okay and this is the problem if

00:36:39,330 --> 00:36:43,530
you have a syntactic error in the test

00:36:41,460 --> 00:36:46,410
expression this will just make the test

00:36:43,530 --> 00:36:49,440
operator fail and the shell since sees

00:36:46,410 --> 00:36:51,360
it efforts you might get an error

00:36:49,440 --> 00:36:53,340
message a pointer to standard air but

00:36:51,360 --> 00:36:55,920
this is easily ignored if you install it

00:36:53,340 --> 00:36:57,750
a lot of stuff and the result is just

00:36:55,920 --> 00:37:00,750
that the test does not behave as you

00:36:57,750 --> 00:37:02,740
would expect it to do okay so I will

00:37:00,750 --> 00:37:04,630
show you some of these

00:37:02,740 --> 00:37:07,750
earth of these things we have found

00:37:04,630 --> 00:37:09,640
stuff like this this of course is false

00:37:07,750 --> 00:37:12,160
pass find could be a function in this

00:37:09,640 --> 00:37:14,830
case and here of course you would want

00:37:12,160 --> 00:37:16,210
to apply the function pass find to the

00:37:14,830 --> 00:37:19,960
argument sort it should be something

00:37:16,210 --> 00:37:22,630
like this this is something we found

00:37:19,960 --> 00:37:25,869
several times and and scripts here what

00:37:22,630 --> 00:37:28,200
is missing is just an operator between

00:37:25,869 --> 00:37:31,900
the second and a third sub expression

00:37:28,200 --> 00:37:37,089
why hasn't this been found before one

00:37:31,900 --> 00:37:40,750
might ask well the reason is that in

00:37:37,089 --> 00:37:43,720
fact this test will succeed

00:37:40,750 --> 00:37:46,480
in case that Allah one is remove and in

00:37:43,720 --> 00:37:49,180
all other cases including disappear and

00:37:46,480 --> 00:37:50,950
purge it will just fail so it does

00:37:49,180 --> 00:37:53,859
something but it does not what the

00:37:50,950 --> 00:37:56,410
Medina intended this is another one the

00:37:53,859 --> 00:37:58,770
classical one of course this is a token

00:37:56,410 --> 00:38:01,000
the problem with cutting with

00:37:58,770 --> 00:38:03,310
decomposing the input into tokens of

00:38:01,000 --> 00:38:04,599
what's missing here as a space before

00:38:03,310 --> 00:38:07,060
the packet everybody has done this

00:38:04,599 --> 00:38:11,680
mistake and then again the test just

00:38:07,060 --> 00:38:13,839
fails it's all this is false this one's

00:38:11,680 --> 00:38:16,690
also missing continuation line for the

00:38:13,839 --> 00:38:19,210
same reason this all also fails just

00:38:16,690 --> 00:38:23,080
miserably and we found something like

00:38:19,210 --> 00:38:27,070
this less simple it's not even a POSIX

00:38:23,080 --> 00:38:28,990
test the PAC's backslash is probably not

00:38:27,070 --> 00:38:32,260
necessary and anyway the person probably

00:38:28,990 --> 00:38:34,869
intended here to do a dpkg compare okay

00:38:32,260 --> 00:38:36,670
so stuff like this we found nine of

00:38:34,869 --> 00:38:40,150
summands i think and of course we fight

00:38:36,670 --> 00:38:45,400
bucks against all of them and then we

00:38:40,150 --> 00:38:49,060
have redirections yes that's we should

00:38:45,400 --> 00:38:50,920
maybe hurry because okay this is

00:38:49,060 --> 00:38:53,859
something we found recently by just

00:38:50,920 --> 00:38:57,550
saying our redirection used yes probably

00:38:53,859 --> 00:39:01,390
but what's in there and actually we you

00:38:57,550 --> 00:39:03,760
can see a lot of these where you so with

00:39:01,390 --> 00:39:06,369
this - redirected to one and then one

00:39:03,760 --> 00:39:10,420
redirected to death knell do you know

00:39:06,369 --> 00:39:14,380
what it does I assure to know what it

00:39:10,420 --> 00:39:17,710
does so what it does if first it takes

00:39:14,380 --> 00:39:20,350
whatever one was writing to and say to

00:39:17,710 --> 00:39:23,619
should write to the same thing right so

00:39:20,350 --> 00:39:25,359
if one was writing to standard output 2

00:39:23,619 --> 00:39:28,240
is now also writing to standard output

00:39:25,359 --> 00:39:31,030
and then tells you and now one should

00:39:28,240 --> 00:39:32,920
write to death knell but that means and

00:39:31,030 --> 00:39:34,840
this is probably not what is intended

00:39:32,920 --> 00:39:37,750
when writing something like that

00:39:34,840 --> 00:39:39,280
if this foo come on here logs something

00:39:37,750 --> 00:39:42,150
on the standard error this is not

00:39:39,280 --> 00:39:45,280
redirected to standard output instead of

00:39:42,150 --> 00:39:47,560
flashed away and you probably mean the

00:39:45,280 --> 00:39:49,630
reverse that is first you're a direct

00:39:47,560 --> 00:39:52,359
one to death knell and then two to the

00:39:49,630 --> 00:39:55,060
same thing as one right and actually

00:39:52,359 --> 00:40:00,220
they are like more than 100 occurrences

00:39:55,060 --> 00:40:01,990
of that possible problem and so we we

00:40:00,220 --> 00:40:06,400
should discuss probably at some point if

00:40:01,990 --> 00:40:08,619
we should do mass spec filing and also

00:40:06,400 --> 00:40:10,240
you discover like useless for directions

00:40:08,619 --> 00:40:13,150
like one should redirect to the same

00:40:10,240 --> 00:40:16,390
thing as one or one should redirect no

00:40:13,150 --> 00:40:17,920
yeah wait yes one should erase a red

00:40:16,390 --> 00:40:20,109
direct to the same thing as two and then

00:40:17,920 --> 00:40:22,780
one should rewrite direct to Daniel so

00:40:20,109 --> 00:40:28,660
we can detect a few so these are like

00:40:22,780 --> 00:40:30,670
non dangerous bugs but still maybe to

00:40:28,660 --> 00:40:32,980
conclude really fast in order to have a

00:40:30,670 --> 00:40:36,430
few questions maybe so we are in the

00:40:32,980 --> 00:40:39,010
Kali project a launch by half here and

00:40:36,430 --> 00:40:41,800
we aim at like checking the correctness

00:40:39,010 --> 00:40:44,890
of Linux scripts in general and in fact

00:40:41,800 --> 00:40:46,510
Debian packages in particular this is a

00:40:44,890 --> 00:40:49,630
project founded by the a transnational

00:40:46,510 --> 00:40:51,700
do share which which is just something

00:40:49,630 --> 00:40:55,290
found found founding research projects

00:40:51,700 --> 00:40:58,119
in France we still have two years to

00:40:55,290 --> 00:41:00,100
have fun with shell scripts you can

00:40:58,119 --> 00:41:02,859
check the main page and in the future we

00:41:00,100 --> 00:41:05,950
want to go further and not only on a

00:41:02,859 --> 00:41:07,840
syntactic level but look at things with

00:41:05,950 --> 00:41:10,510
funny names like tree transducers

00:41:07,840 --> 00:41:13,720
symbolic execution to check more

00:41:10,510 --> 00:41:15,850
interesting properties of scripts and I

00:41:13,720 --> 00:41:19,390
think we have like a short time for

00:41:15,850 --> 00:41:21,630
questions thank you for you for your

00:41:19,390 --> 00:41:21,630
attention

00:41:23,940 --> 00:41:30,910
hi there I haven't done any packaging in

00:41:28,000 --> 00:41:32,620
a while but we used to have dot config

00:41:30,910 --> 00:41:35,200
scripts which were also shell scripts

00:41:32,620 --> 00:41:37,960
and they interacted with debconf are

00:41:35,200 --> 00:41:41,230
they still around and if so shouldn't

00:41:37,960 --> 00:41:45,580
you expand the scope of your searching

00:41:41,230 --> 00:41:49,120
to gather those as well huh possibly

00:41:45,580 --> 00:41:52,360
what you have seen that in our project

00:41:49,120 --> 00:41:55,510
we are already late now and it's quite

00:41:52,360 --> 00:41:57,790
complicated so I think for the moment we

00:41:55,510 --> 00:42:02,290
prefer to focus on automated scripts

00:41:57,790 --> 00:42:05,170
says just all all all all doing similar

00:42:02,290 --> 00:42:06,490
stuff and that's okay big scripts of our

00:42:05,170 --> 00:42:09,220
maintainer scripts or at least they

00:42:06,490 --> 00:42:10,900
weren't six years ago 10 13 years ago

00:42:09,220 --> 00:42:13,780
it's 20 18 now yeah they belong to the

00:42:10,900 --> 00:42:17,820
package yeah they they so they go in

00:42:13,780 --> 00:42:20,890
devour live D package scripts oh my gosh

00:42:17,820 --> 00:42:22,870
I'm an old-timer I used to maintain next

00:42:20,890 --> 00:42:26,400
386 back when there's really such a

00:42:22,870 --> 00:42:29,200
thing are you putting I'm sorry what's

00:42:26,400 --> 00:42:31,450
what's good name Oh Brandon Robinson

00:42:29,200 --> 00:42:33,370
okay so I thought yeah I've got a lot of

00:42:31,450 --> 00:42:35,200
painful experience with shell scripts so

00:42:33,370 --> 00:42:38,620
okay could you I love what you're doing

00:42:35,200 --> 00:42:40,660
because this is excellent work okay no

00:42:38,620 --> 00:42:42,100
so in fact these config scripts are so

00:42:40,660 --> 00:42:43,870
they are just prison statically in the

00:42:42,100 --> 00:42:45,970
archive too and we can probably just

00:42:43,870 --> 00:42:47,560
copy their contents into like when you

00:42:45,970 --> 00:42:49,870
do the sources it's basically just

00:42:47,560 --> 00:42:52,600
copying the contents and then humbling

00:42:49,870 --> 00:42:55,690
them that's probably not so much a

00:42:52,600 --> 00:42:58,090
problem - yeah yeah they're just named

00:42:55,690 --> 00:43:04,060
package name dot config and mostly they

00:42:58,090 --> 00:43:07,360
just do config so yeah they're it's it's

00:43:04,060 --> 00:43:09,310
a Deb cough thing okay so yeah that was

00:43:07,360 --> 00:43:11,560
the last like maintainer script that was

00:43:09,310 --> 00:43:14,230
added and it's started happening about

00:43:11,560 --> 00:43:16,780
2000 yeah okay so so we still have a lot

00:43:14,230 --> 00:43:18,430
of doctor base fights there and of

00:43:16,780 --> 00:43:20,200
course we should should include them in

00:43:18,430 --> 00:43:22,060
the analysis your what because they are

00:43:20,200 --> 00:43:25,090
setting variables which are used and and

00:43:22,060 --> 00:43:31,730
in descriptive tough they don't call it

00:43:25,090 --> 00:43:35,450
a registry okay I saw you

00:43:31,730 --> 00:43:38,930
set - see excited apparently nobody's

00:43:35,450 --> 00:43:40,940
ever using the earliest the original

00:43:38,930 --> 00:43:42,920
idea of set set the positional

00:43:40,940 --> 00:43:43,700
parameters they're just setting the

00:43:42,920 --> 00:43:46,820
options

00:43:43,700 --> 00:43:49,490
nobody's setting Abe or 1 & 2 & 3

00:43:46,820 --> 00:43:52,690
positional Pam I do a long time but so

00:43:49,490 --> 00:43:57,620
we didn't see this in the script and

00:43:52,690 --> 00:44:02,300
well you have the results like if this

00:43:57,620 --> 00:44:04,910
is used this is like in less than 0.4%

00:44:02,300 --> 00:44:14,180
of the cases I've said so this is really

00:44:04,910 --> 00:44:15,710
not so much used indeed I think we are

00:44:14,180 --> 00:44:19,870
out of time anyway

00:44:15,710 --> 00:44:28,199
yes he agrees so thanks again okay

00:44:19,870 --> 00:44:28,199

YouTube URL: https://www.youtube.com/watch?v=jKCLYcsQ7Bg


