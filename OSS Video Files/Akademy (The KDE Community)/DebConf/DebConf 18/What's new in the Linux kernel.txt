Title: What's new in the Linux kernel
Publication date: 2018-08-01
Playlist: DebConf 18
Description: 
	by Ben Hutchings

At: DebConf18
https://debconf18.debconf.org/talks/91-whats-new-in-the-linux-kernel/

The Linux kernel is under rapid development. Stable releases are made around 5 times per year, each including many new features and support for new hardware. This talk will summarise the features that have been added and enabled in the last year.

There have been many changes to Linux between 4.14 and 4.18. Some of these will require new or updated userland applications to take advantage of them. I will attempt to summarise the most interesting changes and the state of integration in Debian.

Room: Yushan (玉山)
Scheduled start: 2018-07-31 15:00:00
Captions: 
	00:00:06,310 --> 00:00:11,990
good afternoon everybody welcome to the

00:00:10,129 --> 00:00:13,910
annual kernel talk back by popular

00:00:11,990 --> 00:00:15,680
demand after last year's hiatus and

00:00:13,910 --> 00:00:18,020
incredibly poor quality substitute

00:00:15,680 --> 00:00:27,200
please welcome Ben Hutchings with what's

00:00:18,020 --> 00:00:30,680
new in the Debian kernel first a little

00:00:27,200 --> 00:00:33,110
bit about myself I have been working on

00:00:30,680 --> 00:00:36,140
the Linux kernel and related related

00:00:33,110 --> 00:00:38,600
code like in it Rama fess and firmware

00:00:36,140 --> 00:00:41,810
packaging I've been doing this for

00:00:38,600 --> 00:00:45,290
Debian and in my paid jobs for over ten

00:00:41,810 --> 00:00:47,300
years now I'm a member of the Debian

00:00:45,290 --> 00:00:49,460
kernel team doing about half of the

00:00:47,300 --> 00:00:52,579
packaging work now counting by commits

00:00:49,460 --> 00:00:56,680
and I'm also on the long term support

00:00:52,579 --> 00:01:00,739
team doing mostly the kernel backports

00:00:56,680 --> 00:01:04,250
that's where the kernel updates for the

00:01:00,739 --> 00:01:08,450
long term support suite I also maintain

00:01:04,250 --> 00:01:11,600
the Linux 3.16 stable update series on

00:01:08,450 --> 00:01:15,560
kernel org and used to do the same for

00:01:11,600 --> 00:01:19,939
3.2 basically I look after the versions

00:01:15,560 --> 00:01:22,279
that we are using in older releases and

00:01:19,939 --> 00:01:24,350
I'm maintaining a stable branch based on

00:01:22,279 --> 00:01:29,840
Linux 4.4 for the civil infrastructure

00:01:24,350 --> 00:01:32,959
platform as you might know Linux

00:01:29,840 --> 00:01:35,959
releases early and often about five

00:01:32,959 --> 00:01:38,479
times a year in fact with stable updates

00:01:35,959 --> 00:01:40,119
with bug fixes even more often than that

00:01:38,479 --> 00:01:42,409
every week or so

00:01:40,119 --> 00:01:45,529
sometimes when features appear in the

00:01:42,409 --> 00:01:48,560
kernel they aren't quite ready there are

00:01:45,529 --> 00:01:51,319
bits missing which may become filled in

00:01:48,560 --> 00:01:53,419
in a later release sometimes they also

00:01:51,319 --> 00:01:56,299
require some support from user space

00:01:53,419 --> 00:01:59,479
packages and other changes in

00:01:56,299 --> 00:02:02,209
distributions so I did actually give

00:01:59,479 --> 00:02:05,869
this talk last year just not deaf can't

00:02:02,209 --> 00:02:09,739
fight also it's in Cambridge and that

00:02:05,869 --> 00:02:12,140
time I covered changes up to Linux 2014

00:02:09,739 --> 00:02:16,570
since then there have been another three

00:02:12,140 --> 00:02:18,920
releases and Linux 4.18 is I think

00:02:16,570 --> 00:02:21,319
likely to be

00:02:18,920 --> 00:02:23,450
next Sunday because I'm going to talk

00:02:21,319 --> 00:02:30,170
about those changes in those four

00:02:23,450 --> 00:02:33,260
releases so lots of new kernel features

00:02:30,170 --> 00:02:37,190
coming and some of them are going to

00:02:33,260 --> 00:02:38,630
need changes elsewhere in Debian and I'm

00:02:37,190 --> 00:02:41,269
not going to be the kernel team isn't

00:02:38,630 --> 00:02:44,720
going to be doing all of these things it

00:02:41,269 --> 00:02:46,989
needs some help for either developers a

00:02:44,720 --> 00:02:49,670
recap of the features I talked about

00:02:46,989 --> 00:02:52,459
last year and what's what's changed

00:02:49,670 --> 00:02:57,340
there I talked about that scared you

00:02:52,459 --> 00:03:00,440
till which is a CPU frequency governor

00:02:57,340 --> 00:03:06,099
this is responsible for part of the

00:03:00,440 --> 00:03:09,200
power management for your CPU and

00:03:06,099 --> 00:03:12,500
schedule unlike old governor's is

00:03:09,200 --> 00:03:15,560
integrated with the Linux task scheduler

00:03:12,500 --> 00:03:19,310
as which in principle has to make smart

00:03:15,560 --> 00:03:20,510
decisions I would hope that at some

00:03:19,310 --> 00:03:23,150
point we could make this the default

00:03:20,510 --> 00:03:27,440
governor but we're not we haven't done

00:03:23,150 --> 00:03:30,049
that yet so sadly no change I hope

00:03:27,440 --> 00:03:33,380
talked about zoned recording which is a

00:03:30,049 --> 00:03:35,750
necessary change for very high capacity

00:03:33,380 --> 00:03:41,239
hard drives using what's called shingled

00:03:35,750 --> 00:03:43,609
magnetic recording and as a utilities

00:03:41,239 --> 00:03:44,720
for controlling that called TM zoned

00:03:43,609 --> 00:03:47,079
tools

00:03:44,720 --> 00:03:49,940
I opened a request for package last

00:03:47,079 --> 00:03:53,600
request for package for that last year

00:03:49,940 --> 00:03:56,389
but I haven't seen anything any movement

00:03:53,600 --> 00:03:59,290
there so if anyone's interested in in

00:03:56,389 --> 00:04:04,970
those very high capacity SMR drives

00:03:59,290 --> 00:04:08,209
please work on that the I talked about

00:04:04,970 --> 00:04:12,459
the block layer being replaced the block

00:04:08,209 --> 00:04:17,599
layer is called part of kernel code that

00:04:12,459 --> 00:04:23,539
manages most access to mass storage hard

00:04:17,599 --> 00:04:29,150
drives SSDs USB storage devices memory

00:04:23,539 --> 00:04:31,670
cards and so on so there's a major

00:04:29,150 --> 00:04:34,040
overhaul in the

00:04:31,670 --> 00:04:36,440
face between the block layer and drivers

00:04:34,040 --> 00:04:42,080
which should allow for higher

00:04:36,440 --> 00:04:44,600
performance and other good changes the

00:04:42,080 --> 00:04:46,190
Train gopher has been gradual because

00:04:44,600 --> 00:04:51,640
it's simply not possible to convert all

00:04:46,190 --> 00:04:55,880
drivers at once so it's the scuzzy disk

00:04:51,640 --> 00:04:58,880
drivers supports both old and new modes

00:04:55,880 --> 00:05:05,330
of operation we changed over the default

00:04:58,880 --> 00:05:08,000
mode in Debian I think with either 4.16

00:05:05,330 --> 00:05:09,590
or 4.17 and it doesn't look like

00:05:08,000 --> 00:05:10,490
anyone's complained about that so that's

00:05:09,590 --> 00:05:17,290
that went well

00:05:10,490 --> 00:05:22,460
the MMC subsystem which is used for most

00:05:17,290 --> 00:05:24,260
embedded flash and for SD cards that has

00:05:22,460 --> 00:05:28,340
finally been switched over to the new

00:05:24,260 --> 00:05:31,760
block layer md raid i think is the last

00:05:28,340 --> 00:05:35,660
big kind of driver storage driver of

00:05:31,760 --> 00:05:37,880
that hasn't been switched over there was

00:05:35,660 --> 00:05:41,810
a little bit of movement on arm graphics

00:05:37,880 --> 00:05:43,190
drivers the Mali kernel driver in fact I

00:05:41,810 --> 00:05:44,930
think this had already happened by the

00:05:43,190 --> 00:05:48,350
time my last talk but I didn't didn't

00:05:44,930 --> 00:05:51,940
notice the the Mali kernel driver for

00:05:48,350 --> 00:05:55,070
armed Mali GPUs is available under GPL

00:05:51,940 --> 00:05:57,200
however they use a space support for

00:05:55,070 --> 00:06:00,650
this GPU is is proprietary

00:05:57,200 --> 00:06:02,450
as a result that drivers is is not has

00:06:00,650 --> 00:06:04,640
not been accepted into the Linux kernel

00:06:02,450 --> 00:06:09,830
itself and it's only perished in the

00:06:04,640 --> 00:06:15,050
contribs action the statics system call

00:06:09,830 --> 00:06:17,600
which is useful for some applications is

00:06:15,050 --> 00:06:20,480
now supported by the AC library since

00:06:17,600 --> 00:06:22,460
Julie proceed version to 20 point 28 and

00:06:20,480 --> 00:06:27,200
a few applications have started using

00:06:22,460 --> 00:06:32,350
this that's can improve performance for

00:06:27,200 --> 00:06:39,500
some applications so let's get on to the

00:06:32,350 --> 00:06:44,540
actual new features this is risk 5 is a

00:06:39,500 --> 00:06:45,390
new ish instruction set architecture the

00:06:44,540 --> 00:06:49,380
risk 5

00:06:45,390 --> 00:06:50,970
a project started in 2010 but it's only

00:06:49,380 --> 00:06:54,270
in the last few years that they

00:06:50,970 --> 00:06:57,600
finalized what the instruction set will

00:06:54,270 --> 00:07:00,630
look like it's maintained by an industry

00:06:57,600 --> 00:07:03,750
consortium and it's more or less open

00:07:00,630 --> 00:07:05,730
the documentation is all public and as I

00:07:03,750 --> 00:07:07,560
understand it there are no license fees

00:07:05,730 --> 00:07:11,910
there are no essential patents that you

00:07:07,560 --> 00:07:13,710
would need to implement it the actual

00:07:11,910 --> 00:07:15,720
implementations themselves may well be

00:07:13,710 --> 00:07:20,880
proprietary I think in fact I think most

00:07:15,720 --> 00:07:26,220
of them are it supports 32-bit and

00:07:20,880 --> 00:07:29,400
64-bit s-- modes and has room to extend

00:07:26,220 --> 00:07:31,830
to 128-bit at this point adding these

00:07:29,400 --> 00:07:35,070
32-bit architectures seems kind of silly

00:07:31,830 --> 00:07:41,940
so the in Debian we're only looking at

00:07:35,070 --> 00:07:44,400
the 64-bit version as risk 564 there are

00:07:41,940 --> 00:07:46,200
also lots of optional features to allow

00:07:44,400 --> 00:07:48,150
for that scalability however there's a

00:07:46,200 --> 00:07:52,380
common feature set which has been

00:07:48,150 --> 00:07:54,570
specified for all processes that are

00:07:52,380 --> 00:07:57,330
meant to be meant to run general purpose

00:07:54,570 --> 00:07:59,550
operating systems like Linux basic

00:07:57,330 --> 00:08:02,100
support for that was added in Linux 4.15

00:07:59,550 --> 00:08:06,620
there's been some more work then to add

00:08:02,100 --> 00:08:09,930
a consult driver so you can actually

00:08:06,620 --> 00:08:13,560
read output from the kernel and to

00:08:09,930 --> 00:08:20,370
supports performance performance

00:08:13,560 --> 00:08:23,580
monitoring and function tracing I've

00:08:20,370 --> 00:08:27,990
talked several times about security

00:08:23,580 --> 00:08:28,950
hardening features which are mmm not

00:08:27,990 --> 00:08:32,220
really

00:08:28,950 --> 00:08:34,680
user visible features but they help to

00:08:32,220 --> 00:08:39,420
defend the kernel and would reduce the

00:08:34,680 --> 00:08:44,970
impact of bugs that could have otherwise

00:08:39,420 --> 00:08:48,840
are very serious security impact so the

00:08:44,970 --> 00:08:52,320
timer list structure in the kernel is

00:08:48,840 --> 00:08:55,590
used to track timeouts what was been

00:08:52,320 --> 00:08:58,860
delayed work that's needed to be done

00:08:55,590 --> 00:08:59,370
regularly but the timing the exact

00:08:58,860 --> 00:09:03,240
timing

00:08:59,370 --> 00:09:05,970
isn't very important in fast this has

00:09:03,240 --> 00:09:09,540
been a very attractive target for buffer

00:09:05,970 --> 00:09:11,970
overflows because it allows you to to

00:09:09,540 --> 00:09:14,580
choose if you if an attacker can find

00:09:11,970 --> 00:09:16,650
any buffer overflow bug that lets them

00:09:14,580 --> 00:09:20,760
overwrite time a list then they can

00:09:16,650 --> 00:09:23,010
choose where the code flow is going to

00:09:20,760 --> 00:09:25,110
go by overriding the function pointer

00:09:23,010 --> 00:09:31,320
and they can also give an argument to

00:09:25,110 --> 00:09:33,660
that code the change has been to to

00:09:31,320 --> 00:09:35,690
always give the timeout function a

00:09:33,660 --> 00:09:39,030
points to the structure instead so that

00:09:35,690 --> 00:09:42,300
reduces its usefulness to attackers in

00:09:39,030 --> 00:09:44,670
future it's hoped that the kernel can

00:09:42,300 --> 00:09:47,070
make use of control flow integrity which

00:09:44,670 --> 00:09:49,320
would do a kind of runtime type checking

00:09:47,070 --> 00:09:53,820
so it would be impossible to replace the

00:09:49,320 --> 00:09:55,290
function point with appointed to

00:09:53,820 --> 00:09:57,420
anything that wasn't meant to be a

00:09:55,290 --> 00:09:58,770
timeout function or you could replace it

00:09:57,420 --> 00:10:00,960
but the result would only be at the

00:09:58,770 --> 00:10:04,470
kernel would crash rather than allowing

00:10:00,960 --> 00:10:10,440
you to take over and get a privileged

00:10:04,470 --> 00:10:14,970
escalation user copy is the is the code

00:10:10,440 --> 00:10:18,270
that's used to a copy data from user

00:10:14,970 --> 00:10:21,900
memory to kernel memory or back during a

00:10:18,270 --> 00:10:24,120
system call this obviously is very

00:10:21,900 --> 00:10:26,340
security sensitive we don't want it to

00:10:24,120 --> 00:10:31,050
possibly be possible to over write

00:10:26,340 --> 00:10:31,410
arbitrary bits of kernel memory so in I

00:10:31,050 --> 00:10:34,830
think

00:10:31,410 --> 00:10:37,950
Linux 3.7 some range checking was added

00:10:34,830 --> 00:10:39,270
to this so that would limit though that

00:10:37,950 --> 00:10:41,280
would prevent buffer overflows that

00:10:39,270 --> 00:10:45,840
would go beyond the scope of one stack

00:10:41,280 --> 00:10:49,110
frame or one heap allocation but there's

00:10:45,840 --> 00:10:52,100
a known limitation there if you had a

00:10:49,110 --> 00:10:59,700
structure that included an array that

00:10:52,100 --> 00:11:01,500
was that allowed if you had a stroke had

00:10:59,700 --> 00:11:03,330
a structure with an array in it and

00:11:01,500 --> 00:11:07,500
there were some system calls that would

00:11:03,330 --> 00:11:10,110
read and write from that array and there

00:11:07,500 --> 00:11:12,660
was also some sensitive data after that

00:11:10,110 --> 00:11:15,329
the range checking would not prevent

00:11:12,660 --> 00:11:19,829
buf overflow into the from the array to

00:11:15,329 --> 00:11:22,800
the following data in the structure now

00:11:19,829 --> 00:11:25,709
there's an option if you create a if

00:11:22,800 --> 00:11:27,600
current code creates a private heap for

00:11:25,709 --> 00:11:33,480
allocating particular type of structure

00:11:27,600 --> 00:11:36,329
it can define a whitelist as a sub part

00:11:33,480 --> 00:11:39,420
of that structure for which user coffee

00:11:36,329 --> 00:11:42,600
is allowed and the range checks would

00:11:39,420 --> 00:11:44,730
then be more would then prevent and I

00:11:42,600 --> 00:11:49,920
have a flow into other sensitive parts

00:11:44,730 --> 00:11:52,949
of the structure so now I'm going to

00:11:49,920 --> 00:11:55,019
take quite a long digression to talk

00:11:52,949 --> 00:11:58,500
about something that came out a

00:11:55,019 --> 00:11:59,879
beginning this year it's not really not

00:11:58,500 --> 00:12:05,730
really a kernel feature it's not even a

00:11:59,879 --> 00:12:10,560
kernel bug fix it's a common flaw in a

00:12:05,730 --> 00:12:13,740
lot of processes you've probably seen

00:12:10,560 --> 00:12:22,230
these logos and talk about meltdown and

00:12:13,740 --> 00:12:24,720
specter these are problems that have

00:12:22,230 --> 00:12:29,899
arisen from speculative execution in

00:12:24,720 --> 00:12:32,850
CPUs so speculative execution is a

00:12:29,899 --> 00:12:36,600
common implementation technique that

00:12:32,850 --> 00:12:42,300
allows processors to avoid waiting for

00:12:36,600 --> 00:12:45,439
slow operations at the moment processors

00:12:42,300 --> 00:12:47,730
can run hundreds of instructions in

00:12:45,439 --> 00:12:53,009
normally in the same time that it would

00:12:47,730 --> 00:12:56,610
take to read data from main memory so in

00:12:53,009 --> 00:12:59,819
the case that an instruction

00:12:56,610 --> 00:13:04,230
Nissa will read from main memory because

00:12:59,819 --> 00:13:06,059
the the data is not in a cache you

00:13:04,230 --> 00:13:08,220
really don't want all the instructions

00:13:06,059 --> 00:13:10,949
following that to have to wait so the

00:13:08,220 --> 00:13:15,870
idea of speculative execution is you

00:13:10,949 --> 00:13:17,069
predict some of the results and and then

00:13:15,870 --> 00:13:19,709
later when you will know the real

00:13:17,069 --> 00:13:21,089
results you can decide whether to keep

00:13:19,709 --> 00:13:23,850
the result of that speculative execution

00:13:21,089 --> 00:13:25,150
or discard it so the results are all

00:13:23,850 --> 00:13:30,040
buffered and if the

00:13:25,150 --> 00:13:31,600
prediction was wrong in theory no one is

00:13:30,040 --> 00:13:35,740
the wiser no one knows that that that

00:13:31,600 --> 00:13:37,720
prediction was wrong however that kind

00:13:35,740 --> 00:13:41,380
of Miss prediction can result in

00:13:37,720 --> 00:13:45,820
bypassing access control and it can

00:13:41,380 --> 00:13:48,100
result in an attacker being able to it

00:13:45,820 --> 00:13:50,530
may be that an attacker can control the

00:13:48,100 --> 00:13:54,220
way the speculative execution would

00:13:50,530 --> 00:13:55,990
would jump to different addresses and

00:13:54,220 --> 00:13:59,460
even though the results are discarded

00:13:55,990 --> 00:14:02,350
that can leave a trace in memory caches

00:13:59,460 --> 00:14:04,990
so after this mispredicted speculative

00:14:02,350 --> 00:14:07,300
execution an attacker may be able to

00:14:04,990 --> 00:14:09,190
time how long it takes to access a

00:14:07,300 --> 00:14:12,130
particular area of memory that may or

00:14:09,190 --> 00:14:14,080
may not have been accessed during the

00:14:12,130 --> 00:14:17,380
speck city of execution and they can

00:14:14,080 --> 00:14:19,540
tell what happened and they can find out

00:14:17,380 --> 00:14:23,460
information that they wouldn't otherwise

00:14:19,540 --> 00:14:26,500
have been able to access for example

00:14:23,460 --> 00:14:30,910
encryption keys that exist in the kernel

00:14:26,500 --> 00:14:32,440
or in and then in another process fixing

00:14:30,910 --> 00:14:36,040
this properly is going to require quite

00:14:32,440 --> 00:14:37,870
big changes to processes design from the

00:14:36,040 --> 00:14:40,570
moments the best we can do is to

00:14:37,870 --> 00:14:43,390
mitigate it with micro code updates and

00:14:40,570 --> 00:14:45,940
with updates to software here in

00:14:43,390 --> 00:14:47,920
particular the kernel the kernel is

00:14:45,940 --> 00:14:50,830
particularly important here because of

00:14:47,920 --> 00:14:52,300
course it's the most privileged code or

00:14:50,830 --> 00:14:54,190
some of the most privileged code running

00:14:52,300 --> 00:14:56,560
on the processor and therefore a target

00:14:54,190 --> 00:14:58,630
of attack and also it's the piece of

00:14:56,560 --> 00:15:04,140
code that's responsible for configuring

00:14:58,630 --> 00:15:08,980
the CPU so I'll just briefly go through

00:15:04,140 --> 00:15:10,810
the the issues that we've seen Specter

00:15:08,980 --> 00:15:15,610
variant one it was described as a

00:15:10,810 --> 00:15:20,920
bounced check bypass the what happens

00:15:15,610 --> 00:15:23,410
with what happens here is that a test

00:15:20,920 --> 00:15:25,990
for whether an array index is within the

00:15:23,410 --> 00:15:30,550
bounds of the array is predicted to be

00:15:25,990 --> 00:15:33,040
true because mmm index out of range is

00:15:30,550 --> 00:15:35,400
is in fact extremely rare and and that

00:15:33,040 --> 00:15:38,300
usually works out to be right however

00:15:35,400 --> 00:15:40,040
the execution can continue

00:15:38,300 --> 00:15:43,640
speculatively with the out of range

00:15:40,040 --> 00:15:47,510
index in some cases and that can result

00:15:43,640 --> 00:15:52,160
in getting information about data that's

00:15:47,510 --> 00:15:55,400
outside the bounds of the array this a

00:15:52,160 --> 00:15:56,690
general general solution for this could

00:15:55,400 --> 00:15:59,660
be done in the compiler but would have

00:15:56,690 --> 00:16:04,850
quite a high performance costs so what's

00:15:59,660 --> 00:16:08,210
being done in Linux is to to add a

00:16:04,850 --> 00:16:11,210
mitigation to specific array lookups

00:16:08,210 --> 00:16:14,530
that are thought to be sensitive so

00:16:11,210 --> 00:16:17,420
that's that's an ongoing effort

00:16:14,530 --> 00:16:19,970
respective variant to that's described

00:16:17,420 --> 00:16:25,190
as branch target injection the idea is

00:16:19,970 --> 00:16:28,160
there is that you can train the indirect

00:16:25,190 --> 00:16:29,900
branch predictor in the CPU that are

00:16:28,160 --> 00:16:32,300
brought from a particular address

00:16:29,900 --> 00:16:38,080
well will you go to another particular

00:16:32,300 --> 00:16:42,890
address and that sort of works because

00:16:38,080 --> 00:16:45,920
the the tests the the lookup based on

00:16:42,890 --> 00:16:48,820
the code address isn't precise so you

00:16:45,920 --> 00:16:51,230
can train it by performing jumps in

00:16:48,820 --> 00:16:54,560
userspace code and they will apply the

00:16:51,230 --> 00:16:57,170
same a little will apply what's been

00:16:54,560 --> 00:16:59,240
learned about that to another piece of

00:16:57,170 --> 00:17:06,620
code in the kernel at an address that

00:16:59,240 --> 00:17:08,840
has some of its bits the same motor CPUs

00:17:06,620 --> 00:17:11,740
on deputy release architectures were

00:17:08,840 --> 00:17:15,050
affected by this and the first variant

00:17:11,740 --> 00:17:20,090
we have mitigations on x86 power and

00:17:15,050 --> 00:17:24,170
system Z which involve disabling or

00:17:20,090 --> 00:17:25,880
defeating this branch predictor and

00:17:24,170 --> 00:17:30,350
that's done in the kernel only a

00:17:25,880 --> 00:17:32,300
presence possibly also ends then there

00:17:30,350 --> 00:17:35,420
are some additional mitigations to x86

00:17:32,300 --> 00:17:38,390
that you that rely on some new features

00:17:35,420 --> 00:17:40,550
added in microcode updates but those are

00:17:38,390 --> 00:17:45,200
only available if you enable the non

00:17:40,550 --> 00:17:47,870
free section of the archive or if you're

00:17:45,200 --> 00:17:49,170
lucky enough to get a a bias or or if I

00:17:47,870 --> 00:17:53,700
update from your

00:17:49,170 --> 00:17:58,080
Ravinder meltdown was probably most

00:17:53,700 --> 00:18:03,410
serious of these it affected a smaller

00:17:58,080 --> 00:18:07,620
set of CPUs Intel x86 some are some

00:18:03,410 --> 00:18:13,560
64-bit ARM chips and most of the recent

00:18:07,620 --> 00:18:16,350
IBM power CPUs on x86 64 or sorry on AMD

00:18:13,560 --> 00:18:21,000
64 and arm 64 it's been mitigated by

00:18:16,350 --> 00:18:25,470
page table isolation which means that

00:18:21,000 --> 00:18:31,470
the kernel memory is no longer even

00:18:25,470 --> 00:18:34,080
mapped into user space processors so

00:18:31,470 --> 00:18:38,460
there's a a switch in the virtual memory

00:18:34,080 --> 00:18:44,250
page tables whenever a system call or

00:18:38,460 --> 00:18:49,560
interrupt happens and on power the the

00:18:44,250 --> 00:18:53,400
mitigation is has been to flush the part

00:18:49,560 --> 00:18:55,170
of the CPU memory cache this really

00:18:53,400 --> 00:18:57,360
slows down system calls the interrupt

00:18:55,170 --> 00:18:59,370
handling is had quite significant

00:18:57,360 --> 00:19:04,620
performance impacts those for some

00:18:59,370 --> 00:19:08,430
applications and there isn't currently a

00:19:04,620 --> 00:19:09,930
mitigation for i386 and unfortunately

00:19:08,430 --> 00:19:11,540
there are some differences in the way

00:19:09,930 --> 00:19:14,850
interrupt handling is done between

00:19:11,540 --> 00:19:17,930
32-bit and 64-bit x86 processors which

00:19:14,850 --> 00:19:21,630
means the the mitigation on AMD 64

00:19:17,930 --> 00:19:26,060
doesn't doesn't transfer across and

00:19:21,630 --> 00:19:30,180
there are yet more yet more issues

00:19:26,060 --> 00:19:32,670
picture in G very variant for cool

00:19:30,180 --> 00:19:38,340
speculative thought up I pass fine

00:19:32,670 --> 00:19:40,560
turned out turns out to be partly an

00:19:38,340 --> 00:19:46,070
issue for the kernel but mostly an issue

00:19:40,560 --> 00:19:49,260
for sandboxing so the the issue here is

00:19:46,070 --> 00:19:52,560
if you have a if you have code that

00:19:49,260 --> 00:19:55,230
writes 200 to a particular address and

00:19:52,560 --> 00:19:56,700
then a few instructions later loads from

00:19:55,230 --> 00:20:00,600
the same address but the addresses are

00:19:56,700 --> 00:20:02,370
calculated in different ways the CPU

00:20:00,600 --> 00:20:02,700
might predict those are actually

00:20:02,370 --> 00:20:06,660
different

00:20:02,700 --> 00:20:10,950
addresses and therefore the the later

00:20:06,660 --> 00:20:15,350
read should use the will speculatively

00:20:10,950 --> 00:20:18,390
use the old value stored at that address

00:20:15,350 --> 00:20:20,490
and there and in some circumstances that

00:20:18,390 --> 00:20:25,530
results in early 'king sensitive

00:20:20,490 --> 00:20:27,450
information the mitigations that were

00:20:25,530 --> 00:20:31,520
already implemented for specter various

00:20:27,450 --> 00:20:34,500
one and two have mostly dealt with that

00:20:31,520 --> 00:20:36,360
but not completely there are some

00:20:34,500 --> 00:20:39,360
additional mitigations available on x86

00:20:36,360 --> 00:20:40,740
now but they rely on new micro code and

00:20:39,360 --> 00:20:45,840
they have quite a substantial

00:20:40,740 --> 00:20:48,930
performance impacts so currently those

00:20:45,840 --> 00:20:51,540
are those are applied by default in

00:20:48,930 --> 00:20:56,100
processors process says that I using

00:20:51,540 --> 00:20:58,050
sandboxing but there are there it has a

00:20:56,100 --> 00:21:03,510
command line kernel command line option

00:20:58,050 --> 00:21:06,120
to to adjust that there's a

00:21:03,510 --> 00:21:08,820
floating-point leak or floating-point

00:21:06,120 --> 00:21:11,940
and vector register contents which

00:21:08,820 --> 00:21:18,720
affected only Intel x86 CPUs as far as

00:21:11,940 --> 00:21:20,550
we know and that significant because it

00:21:18,720 --> 00:21:26,820
can leak encryption keys from one

00:21:20,550 --> 00:21:30,170
process to another thankfully it didn't

00:21:26,820 --> 00:21:33,030
affect the most recent Intel CPUs

00:21:30,170 --> 00:21:35,850
because they have a feature that's meant

00:21:33,030 --> 00:21:38,840
learning students didn't use the

00:21:35,850 --> 00:21:40,890
optimization that made this a problem

00:21:38,840 --> 00:21:42,660
mitigation for that is turn off the

00:21:40,890 --> 00:21:46,080
optimization that was a roughly easy

00:21:42,660 --> 00:21:50,490
mitigation and there are a couple of new

00:21:46,080 --> 00:21:52,670
variants of specter of that I won't go

00:21:50,490 --> 00:21:52,670
into

00:21:55,270 --> 00:22:02,980
so a year 2038 problem is something

00:21:59,300 --> 00:22:07,990
similar to the year 2000 problem if you

00:22:02,980 --> 00:22:11,660
if you're using a 32-bit Linux system

00:22:07,990 --> 00:22:14,480
then the time is represented using a

00:22:11,660 --> 00:22:18,050
32-bit signed number number of seconds

00:22:14,480 --> 00:22:20,060
since 1970 and that will reach its

00:22:18,050 --> 00:22:21,350
highest possible value in early twenty

00:22:20,060 --> 00:22:25,250
thirty eight and then it'll wrap around

00:22:21,350 --> 00:22:27,110
to a negative value and everything

00:22:25,250 --> 00:22:29,080
related to time will go horribly

00:22:27,110 --> 00:22:33,170
horribly wrong

00:22:29,080 --> 00:22:35,690
so hopefully most of us won't be using

00:22:33,170 --> 00:22:39,100
first two-bit systems in 2038 however

00:22:35,690 --> 00:22:43,360
there will be embedded systems being

00:22:39,100 --> 00:22:45,680
built in the very near future that will

00:22:43,360 --> 00:22:49,430
we'll need to carry on running past

00:22:45,680 --> 00:22:52,670
twenty thirty eight so we need some

00:22:49,430 --> 00:22:57,200
changes to the Linux kernel API s and

00:22:52,670 --> 00:22:59,510
the C library that will allow for 32-bit

00:22:57,200 --> 00:23:06,890
systems to use a 64-bit accounts off

00:22:59,510 --> 00:23:09,080
seconds all of the as far as I can see

00:23:06,890 --> 00:23:11,120
all or very nearly all of the kernel

00:23:09,080 --> 00:23:13,370
internal interfaces have been updated to

00:23:11,120 --> 00:23:17,540
use 64-bit time even on 32-bit

00:23:13,370 --> 00:23:20,450
architectures and most of the time later

00:23:17,540 --> 00:23:24,890
system calls the implementations of

00:23:20,450 --> 00:23:28,280
those can be built or in 3008

00:23:24,890 --> 00:23:32,030
configurations however so far no

00:23:28,280 --> 00:23:33,950
architecture has opted into building

00:23:32,030 --> 00:23:36,950
those system calls and assigning numbers

00:23:33,950 --> 00:23:38,720
to them so it's not quite an estate

00:23:36,950 --> 00:23:42,910
where where you can actually take

00:23:38,720 --> 00:23:50,570
advantage of this also the GNU C library

00:23:42,910 --> 00:23:51,740
still doesn't support this it will it

00:23:50,570 --> 00:23:53,210
will need to be backwards binary

00:23:51,740 --> 00:23:55,460
compatible with old applications that

00:23:53,210 --> 00:23:57,500
use those two at times so it will be

00:23:55,460 --> 00:23:59,980
necessary for it to support both 32 and

00:23:57,500 --> 00:24:02,720
64-bit time interfaces at the same time

00:23:59,980 --> 00:24:03,920
which needs quite a lot of intricate

00:24:02,720 --> 00:24:05,090
changes and

00:24:03,920 --> 00:24:08,000
the review of that is going rather

00:24:05,090 --> 00:24:10,610
slowly so that looks like at this point

00:24:08,000 --> 00:24:15,590
this is this is not going to be ready

00:24:10,610 --> 00:24:20,300
for Buster but maybe for book well now

00:24:15,590 --> 00:24:25,730
something that I've run into repeatedly

00:24:20,300 --> 00:24:29,690
is that those two-bit programs on on

00:24:25,730 --> 00:24:31,820
Debian are not being built with large

00:24:29,690 --> 00:24:35,240
file support this is a similar there was

00:24:31,820 --> 00:24:38,390
a similar issue where file access

00:24:35,240 --> 00:24:45,080
interfaces used those TVs offsets and

00:24:38,390 --> 00:24:46,760
sizes and that means and that means you

00:24:45,080 --> 00:24:48,530
could not access files larger than 2

00:24:46,760 --> 00:24:51,050
gigabytes which seems absolutely

00:24:48,530 --> 00:24:54,320
ridiculous today so something called the

00:24:51,050 --> 00:24:58,600
large file large file summits defines

00:24:54,320 --> 00:25:02,570
new 64-bit interfaces for file access

00:24:58,600 --> 00:25:05,750
but they're opt-in so there are still

00:25:02,570 --> 00:25:07,700
finders being built for a three at six

00:25:05,750 --> 00:25:11,420
and other 32-bit architectures in Debian

00:25:07,700 --> 00:25:14,930
that can't access files larger than 2

00:25:11,420 --> 00:25:17,950
gigabytes they also don't work on very

00:25:14,930 --> 00:25:24,800
large XFS file systems which can have

00:25:17,950 --> 00:25:26,600
inode numbers larger than 32 bits so I

00:25:24,800 --> 00:25:29,000
do wonder whether that should be enabled

00:25:26,600 --> 00:25:35,180
by default the connection to 64-bit time

00:25:29,000 --> 00:25:38,300
is that some interfaces like stats deal

00:25:35,180 --> 00:25:41,470
with both file sizes and times and the

00:25:38,300 --> 00:25:44,780
seed library interface C library

00:25:41,470 --> 00:25:46,610
developers do not want to influence for

00:25:44,780 --> 00:25:48,530
different versions of those therefore if

00:25:46,610 --> 00:25:53,000
you want 64-bit time you also needs to

00:25:48,530 --> 00:25:56,570
support 64 bits file sizes so I wonder

00:25:53,000 --> 00:25:58,970
whether it would make sense to change

00:25:56,570 --> 00:26:02,000
the default build flags in debuggers

00:25:58,970 --> 00:26:05,560
build flags to enable both large file

00:26:02,000 --> 00:26:09,740
supports and large time supports

00:26:05,560 --> 00:26:11,240
definitely something to do early in a

00:26:09,740 --> 00:26:14,650
release because that's probably going to

00:26:11,240 --> 00:26:14,650
shake out quite a few bugs

00:26:18,900 --> 00:26:27,100
now one of the important features that

00:26:23,980 --> 00:26:33,160
the kernel has for containerization is

00:26:27,100 --> 00:26:37,630
user name spaces user names with use

00:26:33,160 --> 00:26:40,450
name spaces by default any user can

00:26:37,630 --> 00:26:46,630
create their own namespace and they'll

00:26:40,450 --> 00:26:48,520
be the root user in that which means

00:26:46,630 --> 00:26:52,090
they can control everything in that user

00:26:48,520 --> 00:26:53,830
name space to a great degree but they

00:26:52,090 --> 00:26:56,290
still in principle don't gain any

00:26:53,830 --> 00:26:58,480
privileges in practice this has exposed

00:26:56,290 --> 00:27:00,400
a lot of security bugs so although the

00:26:58,480 --> 00:27:02,400
feature although user name spaces are

00:27:00,400 --> 00:27:05,830
available in Debian kernel builds

00:27:02,400 --> 00:27:08,590
they're just it's the ability of users

00:27:05,830 --> 00:27:17,350
to create their own is disabled by

00:27:08,590 --> 00:27:20,080
default most Linux file systems are not

00:27:17,350 --> 00:27:24,070
robust if you give them a disk image

00:27:20,080 --> 00:27:26,830
that is carefully constructed you can

00:27:24,070 --> 00:27:31,270
exploit bugs to cause buffer overflows

00:27:26,830 --> 00:27:34,180
and other other kinds of problems in the

00:27:31,270 --> 00:27:36,940
file system code and then you can do

00:27:34,180 --> 00:27:40,750
whatever you want in the kernel so for

00:27:36,940 --> 00:27:43,540
this reason the mounting of file systems

00:27:40,750 --> 00:27:46,780
East restricted in user name spaces you

00:27:43,540 --> 00:27:50,380
can't you can't you can only mount

00:27:46,780 --> 00:27:51,940
specific types of file system and up

00:27:50,380 --> 00:27:55,690
until now that's mostly been virtual

00:27:51,940 --> 00:28:00,930
file systems like the proc profile

00:27:55,690 --> 00:28:00,930
system sis file system and so on

00:28:01,200 --> 00:28:06,910
recently there has been some work to

00:28:03,430 --> 00:28:11,920
improve views the file system in user

00:28:06,910 --> 00:28:16,360
space code in the kernel the idea of

00:28:11,920 --> 00:28:18,490
fuse is that the there's a the main file

00:28:16,360 --> 00:28:22,210
system implantation runs as a user space

00:28:18,490 --> 00:28:26,470
server and the kernel then just takes

00:28:22,210 --> 00:28:30,029
care of packaging requests from other

00:28:26,470 --> 00:28:33,820
processes and sending them over to the

00:28:30,029 --> 00:28:35,950
file system server process so there's

00:28:33,820 --> 00:28:38,169
relatively little code running the

00:28:35,950 --> 00:28:44,649
kernel and in theory now that's quite

00:28:38,169 --> 00:28:46,960
robust so at this point the root user in

00:28:44,649 --> 00:28:52,990
a user name space is allowed to mount on

00:28:46,960 --> 00:28:54,970
a file systems using fuse in theory any

00:28:52,990 --> 00:28:58,029
file system you want could be

00:28:54,970 --> 00:29:01,059
implemented through fuse I had thought I

00:28:58,029 --> 00:29:03,279
read about a project to allow regular

00:29:01,059 --> 00:29:05,740
Linux kernel file systems to be rebuilt

00:29:03,279 --> 00:29:08,559
as few service but I can't find any

00:29:05,740 --> 00:29:12,399
trace of that anymore so I don't imagine

00:29:08,559 --> 00:29:14,200
it all that projects has failed I do

00:29:12,399 --> 00:29:16,450
wonder whether it would make sense to

00:29:14,200 --> 00:29:22,570
start packaging more fuse file systems

00:29:16,450 --> 00:29:26,740
though this might also be useful to make

00:29:22,570 --> 00:29:30,639
auto mounting safer if we could run the

00:29:26,740 --> 00:29:34,000
file system code for hot plugs devices

00:29:30,639 --> 00:29:37,029
in user space and we could take

00:29:34,000 --> 00:29:38,320
advantage off the various sandboxing

00:29:37,029 --> 00:29:40,990
features that are available in user

00:29:38,320 --> 00:29:45,070
space that I think would would reduce

00:29:40,990 --> 00:29:53,470
the the danger from hop logged untrusted

00:29:45,070 --> 00:29:56,799
devices another change back in Linux 415

00:29:53,470 --> 00:29:59,350
is to SATA link power management's SATA

00:29:56,799 --> 00:30:01,659
is the high-speed serial link that is

00:29:59,350 --> 00:30:08,190
used to connect most hard hard drives

00:30:01,659 --> 00:30:08,190
SSDs and optical disk drives a

00:30:08,370 --> 00:30:13,269
high-speed serial links tend to draw

00:30:10,510 --> 00:30:15,399
quite a bit of power as long as they're

00:30:13,269 --> 00:30:17,980
running even when there's no data to be

00:30:15,399 --> 00:30:20,350
transferred so generally it's important

00:30:17,980 --> 00:30:23,279
to have link power management which can

00:30:20,350 --> 00:30:25,720
switch them into a lower power mode when

00:30:23,279 --> 00:30:30,460
there hasn't been any data to transfer

00:30:25,720 --> 00:30:33,899
for a while that not only saves power on

00:30:30,460 --> 00:30:36,880
the SATA controller but can also save

00:30:33,899 --> 00:30:39,510
quite a bit of power on some Intel

00:30:36,880 --> 00:30:39,510
processors

00:30:40,070 --> 00:30:45,710
something that's been tried is

00:30:43,180 --> 00:30:49,420
aggressive link power management I'm not

00:30:45,710 --> 00:30:49,420
quite sure what makes it aggressive but

00:30:49,480 --> 00:30:57,410
that's that's can give much higher power

00:30:53,510 --> 00:30:59,420
savings but it turns out that some some

00:30:57,410 --> 00:31:01,670
drives simply don't implement this

00:30:59,420 --> 00:31:05,630
correctly and it can result in data loss

00:31:01,670 --> 00:31:12,040
so that has never been enabled in in

00:31:05,630 --> 00:31:17,030
mainline Linux what changed in 4.15 is

00:31:12,040 --> 00:31:20,150
the the generic SATA controller driver

00:31:17,030 --> 00:31:21,770
gained support for a mode wherein where

00:31:20,150 --> 00:31:27,910
it sets the link power management

00:31:21,770 --> 00:31:32,870
settings similar to what Windows users

00:31:27,910 --> 00:31:34,130
with Intel SATA controllers that can't

00:31:32,870 --> 00:31:36,800
save more power than the previous

00:31:34,130 --> 00:31:39,050
defaults and we believe is it's believed

00:31:36,800 --> 00:31:45,800
to be well tested because that's what

00:31:39,050 --> 00:31:48,890
Windows it uses on on most laptops so we

00:31:45,800 --> 00:31:54,170
enabled that power saving mode in the

00:31:48,890 --> 00:31:56,810
Debian kernel studying 4.17 it does look

00:31:54,170 --> 00:31:58,870
like there us have been some boot

00:31:56,810 --> 00:32:01,040
regressions related to that though so

00:31:58,870 --> 00:32:04,220
probably some more work needs are there

00:32:01,040 --> 00:32:09,430
to maybe blacklist try it some drives

00:32:04,220 --> 00:32:12,980
that don't work so well with that sorry

00:32:09,430 --> 00:32:16,040
so far as I'm aware there's no data loss

00:32:12,980 --> 00:32:21,770
here but but they were up having boot

00:32:16,040 --> 00:32:24,140
hangs finally there have been quite a

00:32:21,770 --> 00:32:28,820
few changes to the packaging of the

00:32:24,140 --> 00:32:33,380
kernel in Debian as you may have seen in

00:32:28,820 --> 00:32:37,160
the previous talk about secure boots we

00:32:33,380 --> 00:32:40,160
now build a template source package that

00:32:37,160 --> 00:32:43,040
will be used by the signing service to

00:32:40,160 --> 00:32:49,940
produce signs versions of the the kernel

00:32:43,040 --> 00:32:54,290
and its modules we have a more flexible

00:32:49,940 --> 00:32:55,940
way to select in the

00:32:54,290 --> 00:33:00,800
in the sauce package which binary

00:32:55,940 --> 00:33:03,260
packages it will build that's is

00:33:00,800 --> 00:33:05,780
something that's been requested for use

00:33:03,260 --> 00:33:12,320
in derivatives and I also found them

00:33:05,780 --> 00:33:16,130
useful for Bank porting backporting

00:33:12,320 --> 00:33:21,650
Linux 4.9 into Jesse for long term

00:33:16,130 --> 00:33:25,460
stable the kernel config files we

00:33:21,650 --> 00:33:28,850
provide copies of the the configuration

00:33:25,460 --> 00:33:30,440
we use for the binary packages to use as

00:33:28,850 --> 00:33:33,620
a starting point for building custom

00:33:30,440 --> 00:33:38,620
kernels those have been moved into new

00:33:33,620 --> 00:33:41,000
binary packages bickers the way we were

00:33:38,620 --> 00:33:44,210
previously we were including them in the

00:33:41,000 --> 00:33:46,400
Linux source - version package that

00:33:44,210 --> 00:33:51,290
turns out to him impossible now because

00:33:46,400 --> 00:33:54,640
the the kernel configuration system

00:33:51,290 --> 00:33:57,440
wants to run the compiler and probe the

00:33:54,640 --> 00:33:59,180
capabilities of the compiler so in order

00:33:57,440 --> 00:34:01,700
for that to work we have needed to

00:33:59,180 --> 00:34:05,420
install lots of cross compilers while

00:34:01,700 --> 00:34:12,760
building Linux sauce so I decided

00:34:05,420 --> 00:34:14,720
against that so that was the solution

00:34:12,760 --> 00:34:18,440
I've removed all the remaining

00:34:14,720 --> 00:34:20,030
dependencies on Python - all the Python

00:34:18,440 --> 00:34:23,870
scripts that we used to build were

00:34:20,030 --> 00:34:26,540
already switched over but I've now also

00:34:23,870 --> 00:34:32,270
changed the documentation build to use

00:34:26,540 --> 00:34:36,320
Python 3 the perf documentation build

00:34:32,270 --> 00:34:39,410
was using the it was using asciidoc

00:34:36,320 --> 00:34:40,940
which is implemented in Python 2 that's

00:34:39,410 --> 00:34:46,730
now switched over to ask you dr. which

00:34:40,940 --> 00:34:47,810
is in not Python 3 but Ruby and I think

00:34:46,730 --> 00:34:49,880
there are one or two other things but

00:34:47,810 --> 00:34:51,830
it's all you can build without python 2

00:34:49,880 --> 00:34:55,730
anymore so that's a step towards

00:34:51,830 --> 00:35:00,800
removing python 2 from the from the next

00:34:55,730 --> 00:35:04,340
release there has been a config change

00:35:00,800 --> 00:35:06,950
to add arm HF and I'm 64 packages that

00:35:04,340 --> 00:35:09,890
are built with real time supports

00:35:06,950 --> 00:35:11,690
that hasn't yet really taken effect

00:35:09,890 --> 00:35:15,530
because we don't have a real-time patch

00:35:11,690 --> 00:35:20,200
set for 4.18 yet but as soon as there is

00:35:15,530 --> 00:35:23,990
one those those packages will get built

00:35:20,200 --> 00:35:27,829
finally all of the packaging of Linux

00:35:23,990 --> 00:35:29,869
and other things that the kernel team

00:35:27,829 --> 00:35:35,180
takes care of all those deposits

00:35:29,869 --> 00:35:37,820
disappear moved to celsa and we're open

00:35:35,180 --> 00:35:40,609
to merge requests I very much prefer

00:35:37,820 --> 00:35:47,710
dealing with merge requests to patches

00:35:40,609 --> 00:35:51,250
attached to the bug drilling system so

00:35:47,710 --> 00:35:51,250
that's all I got

00:35:57,190 --> 00:36:05,430
any questions about these or other

00:36:00,190 --> 00:36:05,430
changes that have taken place since 4.14

00:36:15,369 --> 00:36:21,740
not that one okay

00:36:18,650 --> 00:36:23,750
I had a question about gee Lipsy you

00:36:21,740 --> 00:36:27,619
said things seem to be moving kind of

00:36:23,750 --> 00:36:29,510
slowly on the 64-bit time front but I

00:36:27,619 --> 00:36:33,049
remember you know when they first

00:36:29,510 --> 00:36:35,690
started implementing 64-bit file access

00:36:33,049 --> 00:36:39,710
freyal offset you know there was a whole

00:36:35,690 --> 00:36:43,040
slew of Lib C level calls that had to

00:36:39,710 --> 00:36:46,819
have 64 stuck on the end of them yep is

00:36:43,040 --> 00:36:49,790
there any particular reason I just now

00:36:46,819 --> 00:36:51,530
reviewed the number of earth all the GFC

00:36:49,790 --> 00:36:55,910
calls I could find in the info Docs real

00:36:51,530 --> 00:36:57,890
quick that take or return a time T and

00:36:55,910 --> 00:37:00,319
that it really doesn't seem like that

00:36:57,890 --> 00:37:11,420
big a job famous last words do you know

00:37:00,319 --> 00:37:16,400
what what the holdup is there there are

00:37:11,420 --> 00:37:19,010
quite a few it's not as the system calls

00:37:16,400 --> 00:37:25,880
but there's the library calls like MK

00:37:19,010 --> 00:37:29,799
time def time and there are the api

00:37:25,880 --> 00:37:33,230
compatibility constraints and there's

00:37:29,799 --> 00:37:35,630
name issue is with which things can be

00:37:33,230 --> 00:37:39,500
defined the names of things that can be

00:37:35,630 --> 00:37:47,000
defined without breaking backwards

00:37:39,500 --> 00:37:48,710
source compatibility so I mean it just

00:37:47,000 --> 00:37:50,390
seems like there is a template for doing

00:37:48,710 --> 00:37:54,079
this exactly this kind of transition

00:37:50,390 --> 00:37:57,680
before with 64-bit file offsets mm-hmm

00:37:54,079 --> 00:37:59,750
and you know here you're just you know

00:37:57,680 --> 00:38:01,930
if you want to support 64-bit time on

00:37:59,750 --> 00:38:08,510
32-bit systems well you can just call

00:38:01,930 --> 00:38:13,309
you know as x 64 well no the idea is in

00:38:08,510 --> 00:38:16,280
fact with also with LFS you've had you

00:38:13,309 --> 00:38:18,890
had the 64 suffixed functions but also

00:38:16,280 --> 00:38:21,000
you could define underscore file offset

00:38:18,890 --> 00:38:23,460
base it was 64 and then

00:38:21,000 --> 00:38:26,850
all the regular functions will get

00:38:23,460 --> 00:38:31,710
remapped by macros or whatever the same

00:38:26,850 --> 00:38:33,120
thing is going to be true with I think

00:38:31,710 --> 00:38:38,550
it's time offset bits but I can't

00:38:33,120 --> 00:38:39,840
exactly remember that you said that you

00:38:38,550 --> 00:38:41,610
said something about how they don't want

00:38:39,840 --> 00:38:43,050
to support four different configurations

00:38:41,610 --> 00:38:45,720
right it'll be three different

00:38:43,050 --> 00:38:53,130
configurations okay that's bad enough

00:38:45,720 --> 00:38:55,790
yeah okay all right thank you I guess

00:38:53,130 --> 00:38:55,790
that's it Oh

00:38:57,200 --> 00:39:01,590
you said there were packaging changes to

00:38:59,610 --> 00:39:03,660
do with selecting the different binary

00:39:01,590 --> 00:39:05,790
packages that were built with which

00:39:03,660 --> 00:39:12,950
which version did that did there's land

00:39:05,790 --> 00:39:15,690
in roughly think it was 4.17 okay thanks

00:39:12,950 --> 00:39:23,120
some of those I some of those are cherry

00:39:15,690 --> 00:39:23,120
picked back to do the Linux 4.19 Jessie

00:39:31,690 --> 00:39:34,840
anybody else

00:39:36,359 --> 00:39:41,999
that seems like an absence of hands

00:39:38,150 --> 00:39:44,520
thank you all very much and go get your

00:39:41,999 --> 00:39:52,219
coffee early Thanks

00:39:44,520 --> 00:39:52,219

YouTube URL: https://www.youtube.com/watch?v=jMIWdtMmSvo


