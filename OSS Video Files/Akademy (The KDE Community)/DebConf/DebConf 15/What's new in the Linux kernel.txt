Title: What's new in the Linux kernel
Publication date: 2017-12-03
Playlist: DebConf 15
Description: 
	by Ben Hutchings

At: DebConf15
https://summit.debconf.org/debconf15/meeting/221/whats-new-in-the-linux-kernel/
https://debconf15.debconf.org/

The Linux kernel is under rapid development. Stable releases are made around 5 times per year, each including many new features and support for new hardware. This talk will summarise the features that have been added and enabled in the last year.

There have been many changes to Linux between 3.16 and 4.1. Some of these will require new or updated userland applications to take advantage of them. I will attempt to summarise the most interesting changes and the state of integration in Debian.

Room: Berlin/London
Scheduled start: 2015-08-17 15:00:00
Captions: 
	00:00:00,000 --> 00:00:07,109
sorry copies now why am I talking up BSD

00:00:04,110 --> 00:00:11,820
well Linux has has the same had a

00:00:07,109 --> 00:00:15,000
compatible VM and you can use that for

00:00:11,820 --> 00:00:18,150
Thank You filtering as in hasn't BSD you

00:00:15,000 --> 00:00:23,220
can also use it together with the secure

00:00:18,150 --> 00:00:25,619
computing set comp for sandboxing

00:00:23,220 --> 00:00:27,300
programs and restricting what system

00:00:25,619 --> 00:00:30,840
course they can make so instead of

00:00:27,300 --> 00:00:33,270
looking at the looking at the headers of

00:00:30,840 --> 00:00:36,079
incoming network packets it'll look at

00:00:33,270 --> 00:00:41,129
the system call number and parameters

00:00:36,079 --> 00:00:46,079
and say yes or no or kill this program

00:00:41,129 --> 00:00:49,739
now it's bad and you can also use the

00:00:46,079 --> 00:00:52,289
you can also use be PDF filter code in

00:00:49,739 --> 00:01:00,539
your firewall with the XT PPF module and

00:00:52,289 --> 00:01:04,080
for network share dealing but as time

00:01:00,539 --> 00:01:06,600
has gone out all that's gone smoothly as

00:01:04,080 --> 00:01:13,080
time has gone on it's still all waiting

00:01:06,600 --> 00:01:15,180
a bit as time has gone on network packet

00:01:13,080 --> 00:01:18,780
rates are increased a lot and this use

00:01:15,180 --> 00:01:20,700
for system calls means you potentially

00:01:18,780 --> 00:01:22,530
have a much higher rate that the filter

00:01:20,700 --> 00:01:24,890
code is being run many more times per

00:01:22,530 --> 00:01:29,030
second and so the performance of the

00:01:24,890 --> 00:01:32,509
interpreter is kind of a problem so

00:01:29,030 --> 00:01:35,310
starting with Linux three point naughts

00:01:32,509 --> 00:01:38,820
the kernel has gained just-in-time

00:01:35,310 --> 00:01:40,799
compiler so that the filtering code is -

00:01:38,820 --> 00:01:43,829
is turned into native code inside the

00:01:40,799 --> 00:01:46,320
kernel and that's been implemented for

00:01:43,829 --> 00:01:49,320
several different architectures they

00:01:46,320 --> 00:01:50,759
start there however this feature is

00:01:49,320 --> 00:01:52,200
disabled by default there were still

00:01:50,759 --> 00:01:54,299
some concerns about whether the

00:01:52,200 --> 00:01:58,710
generated code is the native code is

00:01:54,299 --> 00:02:00,600
actually correct in all cases and there

00:01:58,710 --> 00:02:03,329
are some constant security concerns

00:02:00,600 --> 00:02:06,360
about do you really want promise to be

00:02:03,329 --> 00:02:08,640
able to generate native code in the curl

00:02:06,360 --> 00:02:11,370
even if it's based on a very restricted

00:02:08,640 --> 00:02:18,269
language which is supposedly safe there

00:02:11,370 --> 00:02:21,000
some there are some risks and the the

00:02:18,269 --> 00:02:23,489
Berkeley that the virtual machine used

00:02:21,000 --> 00:02:26,849
for PPF it's a 32-bit machine only has

00:02:23,489 --> 00:02:29,430
two registers which is the way it has a

00:02:26,849 --> 00:02:33,470
bit of a stack but it doesn't really

00:02:29,430 --> 00:02:37,890
match what important cpus work so yeah

00:02:33,470 --> 00:02:40,379
there's a limit to what you can do in

00:02:37,890 --> 00:02:42,739
terms of efficiency so extended BPF is

00:02:40,379 --> 00:02:45,690
this new feature

00:02:42,739 --> 00:02:48,150
it supports sensible conditional

00:02:45,690 --> 00:02:50,970
branches in BPF if you have a

00:02:48,150 --> 00:02:52,980
conditional branch it's it says if this

00:02:50,970 --> 00:02:55,260
condition is true branched here if it's

00:02:52,980 --> 00:02:57,030
full sponsor there and in real programs

00:02:55,260 --> 00:03:09,390
normally you and you want to branch in

00:02:57,030 --> 00:03:11,640
one case and that makes it they the CPU

00:03:09,390 --> 00:03:13,140
should be able to do symptoms predictor

00:03:11,640 --> 00:03:15,450
branches and I really can't if you have

00:03:13,140 --> 00:03:18,780
if you have this weird double double

00:03:15,450 --> 00:03:21,989
branching instruction so EBP F has

00:03:18,780 --> 00:03:24,419
single condition branches so it's simple

00:03:21,989 --> 00:03:27,660
branches has 64 registers and more of

00:03:24,419 --> 00:03:30,599
them has more memory to bite or the

00:03:27,660 --> 00:03:35,970
conversion arithmetic right shift into

00:03:30,599 --> 00:03:38,609
atomic adds and he can as well as so a

00:03:35,970 --> 00:03:41,370
standard BPF program just returns a

00:03:38,609 --> 00:03:46,410
single number and in fact that's usually

00:03:41,370 --> 00:03:48,690
it so it's a zero or one yes or no the

00:03:46,410 --> 00:03:50,609
extender BPF support associative arrays

00:03:48,690 --> 00:03:54,299
and those gonna be mapped both into the

00:03:50,609 --> 00:03:56,849
filter program and into and read only in

00:03:54,299 --> 00:03:59,519
to use the land and the set of field

00:03:56,849 --> 00:04:04,019
code can then update a histogram or

00:03:59,519 --> 00:04:10,410
other statistics we can even provide a

00:04:04,019 --> 00:04:13,500
kind of a log and a ring buffer so as

00:04:10,410 --> 00:04:17,370
yet this is not usable for set comp

00:04:13,500 --> 00:04:18,630
unfortunately it's is usable packet

00:04:17,370 --> 00:04:21,479
filtering is useful for network

00:04:18,630 --> 00:04:23,490
scheduling and you can use it on on

00:04:21,479 --> 00:04:25,080
trace points if you

00:04:23,490 --> 00:04:28,580
and so traced my since the kernel you

00:04:25,080 --> 00:04:30,600
can have a this filter code to control

00:04:28,580 --> 00:04:34,620
what's actually done when the trace

00:04:30,600 --> 00:04:36,210
point is hit and this

00:04:34,620 --> 00:04:38,130
so because it's a 64-bit machine

00:04:36,210 --> 00:04:41,280
unfortunately you're on like to see

00:04:38,130 --> 00:04:43,290
compilation for any 32-bit architectures

00:04:41,280 --> 00:04:46,410
but who cares about them anyway you have

00:04:43,290 --> 00:04:52,220
two compilation for armed 64 and AMD 64

00:04:46,410 --> 00:04:55,860
now it's still turned off by default but

00:04:52,220 --> 00:05:00,030
if you want if you think it's safe

00:04:55,860 --> 00:05:02,790
enough and in fact the BPF interpreter

00:05:00,030 --> 00:05:04,680
has been removed or BPF pronounce it

00:05:02,790 --> 00:05:06,150
give us into the extended BPF and

00:05:04,680 --> 00:05:09,060
interpreted like that and that turns out

00:05:06,150 --> 00:05:14,040
to be faster simply because this is

00:05:09,060 --> 00:05:19,740
better better suited to the wave modern

00:05:14,040 --> 00:05:25,050
CPU smoke and BPF is a both PPF and e b

00:05:19,740 --> 00:05:28,590
PF are their machine codes but there is

00:05:25,050 --> 00:05:32,510
work in progress to allow you to compile

00:05:28,590 --> 00:05:38,730
to EB fef from a restricted set of C

00:05:32,510 --> 00:05:41,490
using the planck compiler so next

00:05:38,730 --> 00:05:45,450
feature when holly did different notes

00:05:41,490 --> 00:05:49,770
is the overlay filesystem it's a union

00:05:45,450 --> 00:05:51,240
file system that lets you actually take

00:05:49,770 --> 00:05:53,780
a read-only

00:05:51,240 --> 00:05:58,380
base file system so that could be

00:05:53,780 --> 00:06:00,630
perhaps our network NFS server or well

00:05:58,380 --> 00:06:03,480
this case not interfere so but you have

00:06:00,630 --> 00:06:09,330
a read-only medium for example it's a

00:06:03,480 --> 00:06:14,940
live CD or or similar or a shared base

00:06:09,330 --> 00:06:16,860
file system for containers and and then

00:06:14,940 --> 00:06:19,200
on top of that you had a second file

00:06:16,860 --> 00:06:23,240
system that contains all the changes

00:06:19,200 --> 00:06:26,610
that have been made and the overlay FS

00:06:23,240 --> 00:06:33,140
presents a unified view of those two or

00:06:26,610 --> 00:06:33,140
more two or potentially more layers

00:06:34,200 --> 00:06:38,700
Debian has already had a union

00:06:36,390 --> 00:06:40,200
filesystem for quite a few quite a few

00:06:38,700 --> 00:06:43,170
years in order to support our Debian

00:06:40,200 --> 00:06:47,460
live projects and also derivatives such

00:06:43,170 --> 00:06:48,990
as tails and that's a ufs the EU FS is

00:06:47,460 --> 00:06:52,340
big and complicated and written is

00:06:48,990 --> 00:06:55,080
lightly on style so there's basically no

00:06:52,340 --> 00:07:01,350
no chance that that's going to go into

00:06:55,080 --> 00:07:05,490
Linux mainline and however overlay FS is

00:07:01,350 --> 00:07:09,630
a bit simpler and it has gone in and as

00:07:05,490 --> 00:07:11,220
of living swapping one we're not sorry

00:07:09,630 --> 00:07:13,680
it was a bit earlier than that but

00:07:11,220 --> 00:07:17,420
currently we're we're not including a

00:07:13,680 --> 00:07:17,420
OFS in the kernel packages anymore

00:07:17,550 --> 00:07:22,890
so limitations are over the FS it

00:07:20,850 --> 00:07:25,650
doesn't seem to work or doesn't doesn't

00:07:22,890 --> 00:07:27,840
work correctly on top of NFS file

00:07:25,650 --> 00:07:30,270
systems you can't use it to join local

00:07:27,840 --> 00:07:35,610
file systems at the moment you can't

00:07:30,270 --> 00:07:38,400
export an overlay FS over NFS deleting

00:07:35,610 --> 00:07:41,280
whenever you delete a file that was

00:07:38,400 --> 00:07:44,430
present on the read-only file system you

00:07:41,280 --> 00:07:46,020
need the upper layer that contains

00:07:44,430 --> 00:07:48,780
changes needs to contain a sort of a

00:07:46,020 --> 00:07:50,190
dummy file to say ignore the file on the

00:07:48,780 --> 00:07:52,830
read-only layer it's called a white

00:07:50,190 --> 00:07:56,460
house they're not implemented very

00:07:52,830 --> 00:07:59,100
efficiently on a over the FS whenever

00:07:56,460 --> 00:08:01,560
you modify a file that was on the that

00:07:59,100 --> 00:08:04,260
comes from the read-only lower layout

00:08:01,560 --> 00:08:09,000
layer there has to be copied up to the

00:08:04,260 --> 00:08:10,320
upper layer and overlay FS is a bit

00:08:09,000 --> 00:08:18,660
silly about copying you know Clarke

00:08:10,320 --> 00:08:20,790
sparse files and so a you a you FS has a

00:08:18,660 --> 00:08:22,800
intriguing feature where you can have

00:08:20,790 --> 00:08:24,720
more than one writable there not sure

00:08:22,800 --> 00:08:29,010
quite how that works over FS doesn't do

00:08:24,720 --> 00:08:30,930
it yes and link trees unfortunately if

00:08:29,010 --> 00:08:32,790
you create even creating a hard link to

00:08:30,930 --> 00:08:34,470
a file that's on the read-only layer

00:08:32,790 --> 00:08:35,520
requires that file we call it up

00:08:34,470 --> 00:08:38,610
currently you know

00:08:35,520 --> 00:08:41,670
JFS which is not necessary net not

00:08:38,610 --> 00:08:46,380
necessary new in a ufs hopefully some of

00:08:41,670 --> 00:08:52,860
these limitations are gonna get fixed

00:08:46,380 --> 00:08:58,770
enable AFS eventually so I'm moving on

00:08:52,860 --> 00:09:01,440
to networking features there's a new new

00:08:58,770 --> 00:09:03,330
way of managing switches as you probably

00:09:01,440 --> 00:09:05,460
know Linux is used on a whole bunch of

00:09:03,330 --> 00:09:09,920
network appliances wireless access

00:09:05,460 --> 00:09:09,920
points switches Reuters and

00:09:10,310 --> 00:09:16,110
yeah so you have a bunch of things where

00:09:13,620 --> 00:09:19,770
you have a hardware switch integrated

00:09:16,110 --> 00:09:21,720
into the into the system and generally

00:09:19,770 --> 00:09:26,270
those are configured using IP either

00:09:21,720 --> 00:09:26,270
specific to that vendors drunk driver

00:09:26,300 --> 00:09:34,020
you also see on PCI Express network

00:09:29,700 --> 00:09:37,260
cards a lot of have features to support

00:09:34,020 --> 00:09:41,700
virtualization and they can present

00:09:37,260 --> 00:09:45,180
multiple virtual ports towards the water

00:09:41,700 --> 00:09:47,930
host at the PCI bus and then so there's

00:09:45,180 --> 00:09:50,160
a switch on that card

00:09:47,930 --> 00:09:53,120
currently there are a couple of netlink

00:09:50,160 --> 00:09:57,150
api's that you used to configure the

00:09:53,120 --> 00:09:59,510
address you could use to configure

00:09:57,150 --> 00:10:03,230
switching your packets between those

00:09:59,510 --> 00:10:05,760
local ports and the the external ports

00:10:03,230 --> 00:10:07,850
and finally the has always had a

00:10:05,760 --> 00:10:11,100
software bridge driver for a long time

00:10:07,850 --> 00:10:15,390
and that would figure using the unique

00:10:11,100 --> 00:10:20,940
api which can have a bridge or be are

00:10:15,390 --> 00:10:23,000
Ketil commands so these are all switches

00:10:20,940 --> 00:10:25,380
but they all have different ways of

00:10:23,000 --> 00:10:29,160
configuring them which is not really

00:10:25,380 --> 00:10:34,260
ideal so the switch def concept has been

00:10:29,160 --> 00:10:40,170
introduced and it allows all the all

00:10:34,260 --> 00:10:41,970
every driver for a swish should

00:10:40,170 --> 00:10:45,060
implement the same set of option same

00:10:41,970 --> 00:10:48,210
set of operations some of which are

00:10:45,060 --> 00:10:51,790
optional and the kernel then

00:10:48,210 --> 00:10:53,680
present the same interface to use land

00:10:51,790 --> 00:10:57,990
so they can be configured in the same

00:10:53,680 --> 00:11:01,660
way where their software hardware and

00:10:57,990 --> 00:11:07,420
whether they switch hardware is smart or

00:11:01,660 --> 00:11:10,210
not so smart so currently it's not

00:11:07,420 --> 00:11:12,760
supported by all the drivers that you

00:11:10,210 --> 00:11:16,300
would want it to be it's theirs they in

00:11:12,760 --> 00:11:19,330
cell 10 and 40 gig Ethernet card support

00:11:16,300 --> 00:11:22,990
it's you logics of all sets this thing

00:11:19,330 --> 00:11:25,750
called rocker which is a a switch that's

00:11:22,990 --> 00:11:28,420
emulated in qmu which is not terribly

00:11:25,750 --> 00:11:32,110
useful except as a testbed for for this

00:11:28,420 --> 00:11:36,100
this new API and as the Mac VLAN which

00:11:32,110 --> 00:11:40,510
is the alternates kind of software

00:11:36,100 --> 00:11:43,510
bridge every port on a switch now gets

00:11:40,510 --> 00:11:45,640
its own net device and you can use

00:11:43,510 --> 00:11:48,160
either tool to configure the things like

00:11:45,640 --> 00:11:51,580
speed and autumn negotiation on this

00:11:48,160 --> 00:11:55,090
network ports and use the bridge

00:11:51,580 --> 00:11:59,670
commands will now work with the high

00:11:55,090 --> 00:12:03,640
bridges as well as software the hardware

00:11:59,670 --> 00:12:05,020
can do learning like you figured out

00:12:03,640 --> 00:12:07,800
which MAC addresses some ties to which

00:12:05,020 --> 00:12:11,170
point which port or it can let the

00:12:07,800 --> 00:12:15,900
software deal with that and it's even

00:12:11,170 --> 00:12:23,650
possible to offload layer 3 so IP level

00:12:15,900 --> 00:12:29,380
14 decisions to the hardware so

00:12:23,650 --> 00:12:31,450
something that's ongoing in graphics so

00:12:29,380 --> 00:12:33,520
not completed yet quite away from being

00:12:31,450 --> 00:12:35,740
completed something called time mode

00:12:33,520 --> 00:12:40,870
setting so you probably know about

00:12:35,740 --> 00:12:43,590
kernel mode setting this is making the

00:12:40,870 --> 00:12:46,150
kernel responsible for managing the

00:12:43,590 --> 00:12:49,200
setting up the your video display

00:12:46,150 --> 00:12:52,480
generators and managing memory on the

00:12:49,200 --> 00:12:54,970
for the graphics hardware and that

00:12:52,480 --> 00:12:57,400
removes the need for previously the X

00:12:54,970 --> 00:12:59,440
server or the X video drivers inside the

00:12:57,400 --> 00:13:03,160
server we're doing all this from

00:12:59,440 --> 00:13:08,290
his land which was really not great

00:13:03,160 --> 00:13:12,220
the so there's now as a kernel subsystem

00:13:08,290 --> 00:13:17,320
called DRM his direct rendering manager

00:13:12,220 --> 00:13:19,870
originally it was all about the 3d GPUs

00:13:17,320 --> 00:13:21,810
but it's now takes care of this motor

00:13:19,870 --> 00:13:24,700
setting and maariyah management as well

00:13:21,810 --> 00:13:27,430
so it models is your your display

00:13:24,700 --> 00:13:29,770
generator as having several pipelines

00:13:27,430 --> 00:13:33,160
the pipelines take input from frame

00:13:29,770 --> 00:13:38,170
buffers or also couple planes so you

00:13:33,160 --> 00:13:41,050
have one frame buffer for the the kind

00:13:38,170 --> 00:13:43,420
of a pretty much everything you see on

00:13:41,050 --> 00:13:46,960
screen in fact they run a plane which

00:13:43,420 --> 00:13:49,390
has the mouse cursor that's fair on top

00:13:46,960 --> 00:13:52,420
of that and you might have other planes

00:13:49,390 --> 00:13:57,160
for showing video on top of that because

00:13:52,420 --> 00:14:00,700
video is special and video plane can

00:13:57,160 --> 00:14:05,590
provide scaling and color space

00:14:00,700 --> 00:14:13,090
conversion hardware now if you are using

00:14:05,590 --> 00:14:16,690
a for using a graphics chip that has a

00:14:13,090 --> 00:14:20,500
3d GPU actually you probably don't have

00:14:16,690 --> 00:14:22,090
a video planes anymore because the GPU

00:14:20,500 --> 00:14:25,620
can handle all of that

00:14:22,090 --> 00:14:28,870
when compose composers together windows

00:14:25,620 --> 00:14:32,200
and you compose can compose in video and

00:14:28,870 --> 00:14:39,610
do the scaling in the same way as it can

00:14:32,200 --> 00:14:41,170
do any kind of 3d rendering and the

00:14:39,610 --> 00:14:45,280
output of a pipeline can be routed to

00:14:41,170 --> 00:14:47,950
one or more screens so a moment for

00:14:45,280 --> 00:14:50,620
example my laptop has a single pipeline

00:14:47,950 --> 00:14:55,450
I think which sends the same signal out

00:14:50,620 --> 00:14:58,030
to the internal internal display and out

00:14:55,450 --> 00:14:59,380
of the VGA port there's there are

00:14:58,030 --> 00:15:01,240
differences in the encoding there but

00:14:59,380 --> 00:15:04,440
it's effectively it's generally it's the

00:15:01,240 --> 00:15:04,440
same signal internally

00:15:06,069 --> 00:15:18,199
so when I plug and unplug the projector

00:15:14,629 --> 00:15:21,379
the these pipeline needs to be

00:15:18,199 --> 00:15:26,119
reconfigured to talk to to rather than

00:15:21,379 --> 00:15:29,569
one port to port Silent One and Camus

00:15:26,119 --> 00:15:33,519
supports doing that that's fine you

00:15:29,569 --> 00:15:38,779
change the refresh rate as necessary and

00:15:33,519 --> 00:15:40,220
you can add and remove planes for

00:15:38,779 --> 00:15:45,489
example when you close open and close

00:15:40,220 --> 00:15:49,069
your video player but these changes

00:15:45,489 --> 00:15:51,579
reconfiguring can result in flickering

00:15:49,069 --> 00:15:55,119
on the screen or tearing where you have

00:15:51,579 --> 00:15:57,920
one half of the screen generated with

00:15:55,119 --> 00:16:00,589
just on one update at the free screen

00:15:57,920 --> 00:16:02,329
you could have one and one half to

00:16:00,589 --> 00:16:04,459
generate it with the old configuration

00:16:02,329 --> 00:16:06,589
went off with the new and this is odd

00:16:04,459 --> 00:16:08,959
joining the middle only appears for a

00:16:06,589 --> 00:16:13,910
moment but it's slightly annoying and

00:16:08,959 --> 00:16:16,879
also because you the changes are broken

00:16:13,910 --> 00:16:18,949
up into multiple steps you could get a

00:16:16,879 --> 00:16:20,509
configuration halfway through that is

00:16:18,949 --> 00:16:25,970
invalid for example requires too much

00:16:20,509 --> 00:16:28,670
memory bandwidth so even though the X

00:16:25,970 --> 00:16:30,889
Server is is trying to complete

00:16:28,670 --> 00:16:33,110
configure to a stateless completely

00:16:30,889 --> 00:16:38,949
valid this intermediate step might not

00:16:33,110 --> 00:16:42,619
be and in that fails completely now I

00:16:38,949 --> 00:16:45,379
don't I don't plug an amp like the

00:16:42,619 --> 00:16:46,339
projector very often so why should I

00:16:45,379 --> 00:16:50,600
really care about

00:16:46,339 --> 00:16:53,329
whether there's flickering well it turns

00:16:50,600 --> 00:16:57,519
out that using the GPU to do all your

00:16:53,329 --> 00:17:00,649
composition uses of more power than

00:16:57,519 --> 00:17:08,240
combining multiple frames offers at they

00:17:00,649 --> 00:17:11,980
display generator so this is Android for

00:17:08,240 --> 00:17:11,980
example is making much more use of

00:17:12,370 --> 00:17:17,839
composition at the display generator

00:17:14,120 --> 00:17:19,600
instead of a GPU now Android has done

00:17:17,839 --> 00:17:23,110
its own thing it's not using KML

00:17:19,600 --> 00:17:27,280
it doesn't support multiple pipelines at

00:17:23,110 --> 00:17:29,640
all but you're gonna see hopefully

00:17:27,280 --> 00:17:32,380
you're gonna see mobile devices and

00:17:29,640 --> 00:17:33,940
hopefully you wants you're like you're

00:17:32,380 --> 00:17:39,070
gonna see hopefully mobile devices using

00:17:33,940 --> 00:17:41,559
a normal Linux stack graphics stack and

00:17:39,070 --> 00:17:44,039
also you probably want your your laptop

00:17:41,559 --> 00:17:46,690
so it run for longer using less power so

00:17:44,039 --> 00:17:54,480
it will be really nice to make more use

00:17:46,690 --> 00:17:57,190
of multiple layers in X or Wayland

00:17:54,480 --> 00:17:59,470
so yeah the Window System was going to

00:17:57,190 --> 00:18:00,640
need to reconfigure place more often and

00:17:59,470 --> 00:18:03,330
that means we really don't want to

00:18:00,640 --> 00:18:06,610
flicker so the atomic mode setting API

00:18:03,330 --> 00:18:09,070
makes the reconfiguration transactional

00:18:06,610 --> 00:18:11,590
either all the changes are applied or

00:18:09,070 --> 00:18:13,870
the driver takes that this isn't going

00:18:11,590 --> 00:18:17,169
to work and rejects the request from

00:18:13,870 --> 00:18:19,390
using lens and all those changes if

00:18:17,169 --> 00:18:20,980
they're applied that can be how can be

00:18:19,390 --> 00:18:25,390
carried out during the vertical Planck

00:18:20,980 --> 00:18:27,460
periods ie between not while a screen is

00:18:25,390 --> 00:18:29,620
actually being updated so you got one

00:18:27,460 --> 00:18:34,200
frame with the auger figuration the next

00:18:29,620 --> 00:18:37,539
frame with the new configuration so the

00:18:34,200 --> 00:18:39,789
the graphics drivers in kernel need to

00:18:37,539 --> 00:18:42,610
be updated so that's what this not may

00:18:39,789 --> 00:18:45,010
even have been I 915 for Intel hardware

00:18:42,610 --> 00:18:48,850
is I think supposed to be completely

00:18:45,010 --> 00:18:52,630
updated in Linux 4.2 MSM Integra which

00:18:48,850 --> 00:18:55,390
he used on some arm-based SSC's those

00:18:52,630 --> 00:19:00,370
have been updated and using them would

00:18:55,390 --> 00:19:02,320
also need to use this new interface so

00:19:00,370 --> 00:19:04,539
that's going to take a while hopefully

00:19:02,320 --> 00:19:10,450
hopefully we'll be ready and we'll have

00:19:04,539 --> 00:19:12,100
lower power graphics in stretch so life

00:19:10,450 --> 00:19:14,679
passing I've had a few questions about

00:19:12,100 --> 00:19:19,030
life passing and can we use it in Debian

00:19:14,679 --> 00:19:21,520
well maybe so if you don't know but

00:19:19,030 --> 00:19:26,950
don't know about life patching currently

00:19:21,520 --> 00:19:28,780
if you upgrade the kernel so you can't

00:19:26,950 --> 00:19:29,490
simply switch over to rain the new code

00:19:28,780 --> 00:19:34,140
you know

00:19:29,490 --> 00:19:36,900
a full reboot or possibly use kxn if

00:19:34,140 --> 00:19:39,929
your your applications are all

00:19:36,900 --> 00:19:43,050
containerized and you've embraced the

00:19:39,929 --> 00:19:45,120
cloud then no problem you can you can

00:19:43,050 --> 00:19:47,280
kill you reroute VM as anytime it's not

00:19:45,120 --> 00:19:51,630
going to be disruptive but if you have

00:19:47,280 --> 00:19:54,390
have a more conventional service then ya

00:19:51,630 --> 00:19:56,580
really have to schedule reboots and you

00:19:54,390 --> 00:19:58,410
don't have to do them too often but if

00:19:56,580 --> 00:20:01,170
there's an important security update you

00:19:58,410 --> 00:20:05,150
really want to apply that so live

00:20:01,170 --> 00:20:08,490
patching offers a way to fix some bugs

00:20:05,150 --> 00:20:11,550
by editing the kernel code without a

00:20:08,490 --> 00:20:13,650
reboot and that was implemented quite a

00:20:11,550 --> 00:20:15,600
while ago by a company called K splice

00:20:13,650 --> 00:20:20,850
with a product of the same name they

00:20:15,600 --> 00:20:23,550
system bought by Oracle their patches

00:20:20,850 --> 00:20:25,170
are free software but as far as I know

00:20:23,550 --> 00:20:26,880
the tools they used to develop them not

00:20:25,170 --> 00:20:29,000
they don't develop in the open and

00:20:26,880 --> 00:20:31,800
currently the release patches for

00:20:29,000 --> 00:20:36,990
Oracle's Linux and fedora and ability

00:20:31,800 --> 00:20:38,250
not Debian RedHat and SUSE each sort

00:20:36,990 --> 00:20:40,890
this is an important feature for their

00:20:38,250 --> 00:20:41,370
enterprise distributions relevance and

00:20:40,890 --> 00:20:43,650
Slayers

00:20:41,370 --> 00:20:46,320
and so they implemented life patching

00:20:43,650 --> 00:20:49,380
again and because they actually work

00:20:46,320 --> 00:20:51,780
within its community so you try to get

00:20:49,380 --> 00:20:54,030
these they try to get their

00:20:51,780 --> 00:20:58,530
implementations up upstream at around

00:20:54,030 --> 00:21:00,450
the same time and then they have to go

00:20:58,530 --> 00:21:05,429
through some discussion and compromise

00:21:00,450 --> 00:21:07,050
on some sort of on a yam implementation

00:21:05,429 --> 00:21:09,420
that would suit them both that's now

00:21:07,050 --> 00:21:11,460
happened you know it's all Point norm so

00:21:09,420 --> 00:21:14,550
yeah it would be really nice to use this

00:21:11,460 --> 00:21:18,240
feature and for Debian's kernel security

00:21:14,550 --> 00:21:20,460
upgrades but naturally it will require

00:21:18,240 --> 00:21:27,360
more work not everyone's going to use a

00:21:20,460 --> 00:21:30,000
live patching so so we're going to need

00:21:27,360 --> 00:21:33,510
to ship both the full colonel update and

00:21:30,000 --> 00:21:39,410
the life patch and building the live

00:21:33,510 --> 00:21:39,410
patch is it's extra work so

00:21:40,470 --> 00:21:48,750
there's five minutes for questions right

00:21:42,110 --> 00:21:50,490
yeah so if anyone wants to help the

00:21:48,750 --> 00:21:51,780
colonel team and work on this or not

00:21:50,490 --> 00:21:55,410
wants to pay a member of the colonel

00:21:51,780 --> 00:22:02,460
team to work on this would be interested

00:21:55,410 --> 00:22:05,930
to hear from you so storage we have some

00:22:02,460 --> 00:22:08,760
exciting new hardware non-volatile dims

00:22:05,930 --> 00:22:12,240
because flash storage or flash storage

00:22:08,760 --> 00:22:15,980
arrays get faster and faster mostly by

00:22:12,240 --> 00:22:18,060
putting more flash chips in parallel and

00:22:15,980 --> 00:22:19,950
there are several interesting

00:22:18,060 --> 00:22:22,830
non-volatile memory technologies that

00:22:19,950 --> 00:22:25,620
are in developments promise any time

00:22:22,830 --> 00:22:29,670
soon and supposedly they're going to be

00:22:25,620 --> 00:22:31,410
faster and more durable than flash so up

00:22:29,670 --> 00:22:33,150
till now non-volatile memory is usually

00:22:31,410 --> 00:22:38,510
been treated as a disk it's attached to

00:22:33,150 --> 00:22:42,210
a SATA interface or there's a newish

00:22:38,510 --> 00:22:44,760
interface called nvme which is based on

00:22:42,210 --> 00:22:48,090
PCI Express but maybe that's still not

00:22:44,760 --> 00:22:49,830
fast enough so envied Jim's like you

00:22:48,090 --> 00:22:53,100
attached a non-volatile memory to the

00:22:49,830 --> 00:22:58,370
memory bus same buses the dynamic Ram is

00:22:53,100 --> 00:23:01,740
attached you still have the problem that

00:22:58,370 --> 00:23:05,430
flash can't be rewritten that many times

00:23:01,740 --> 00:23:11,670
not as many as Ram before it it breaks

00:23:05,430 --> 00:23:13,590
it stops holding data so there are two

00:23:11,670 --> 00:23:16,500
different two different ways of of

00:23:13,590 --> 00:23:20,490
dealing with Henry James one of them is

00:23:16,500 --> 00:23:23,550
you map this whole block of memory block

00:23:20,490 --> 00:23:27,210
of flash memory into the ordinary

00:23:23,550 --> 00:23:29,580
physical memory space and then you can

00:23:27,210 --> 00:23:32,790
directly map and then you map that using

00:23:29,580 --> 00:23:37,560
the MMU into the processes that are

00:23:32,790 --> 00:23:38,940
accessing data on that in V Jim now

00:23:37,560 --> 00:23:42,330
that's that's called the persistent

00:23:38,940 --> 00:23:48,330
memory or pmm mode and then as the BLK

00:23:42,330 --> 00:23:51,120
of block mode where only the kernel

00:23:48,330 --> 00:23:52,490
accesses the memory directly and uses

00:23:51,120 --> 00:23:54,080
several

00:23:52,490 --> 00:23:58,220
it only actresses a small part of

00:23:54,080 --> 00:24:01,340
portions of time you can also compromise

00:23:58,220 --> 00:24:04,100
and and spit on it your every team's

00:24:01,340 --> 00:24:09,260
into two regions that are accessing by

00:24:04,100 --> 00:24:17,270
the mode that was gonna I've got there

00:24:09,260 --> 00:24:19,910
we go right so ii yeah so a persistent

00:24:17,270 --> 00:24:23,510
memory you have diet access form

00:24:19,910 --> 00:24:28,190
processes but if they cadre face those

00:24:23,510 --> 00:24:31,850
places us are gonna crash basically no

00:24:28,190 --> 00:24:33,260
way to recover from that and you also

00:24:31,850 --> 00:24:36,560
think the file system support don't

00:24:33,260 --> 00:24:39,910
access but x4 and XFS support it so

00:24:36,560 --> 00:24:42,860
that's probably good enough block mode

00:24:39,910 --> 00:24:44,960
is not as efficient but you can't put a

00:24:42,860 --> 00:24:48,800
red layer over multiple mb teams so it's

00:24:44,960 --> 00:24:54,410
more or an eyeball so i'm going

00:24:48,800 --> 00:24:58,790
backwards yeah we've got in the

00:24:54,410 --> 00:25:00,170
encryption layer in next for now we

00:24:58,790 --> 00:25:03,160
already have an encrypting file system

00:25:00,170 --> 00:25:06,170
call decrypt FS has been there for ages

00:25:03,160 --> 00:25:08,600
so you may wonder why would we need

00:25:06,170 --> 00:25:11,600
another implementation there are good

00:25:08,600 --> 00:25:14,660
reasons for this and in fact encryption

00:25:11,600 --> 00:25:17,980
in x4 is being implemented by one of the

00:25:14,660 --> 00:25:22,700
developers off equipped FS so you knows

00:25:17,980 --> 00:25:25,490
you know don't trade-offs are currently

00:25:22,700 --> 00:25:28,900
when you read through a equipped FS all

00:25:25,490 --> 00:25:33,110
that you read is cache twice in memory

00:25:28,900 --> 00:25:37,190
encrypted and decrypted so there's some

00:25:33,110 --> 00:25:38,870
wasted memory and equipped FS can't or

00:25:37,190 --> 00:25:41,240
seem very much about the underlying file

00:25:38,870 --> 00:25:46,970
system whether he sports extended

00:25:41,240 --> 00:25:49,640
attributes and so on and that means it

00:25:46,970 --> 00:25:51,590
has to deal with some as it can store

00:25:49,640 --> 00:25:52,880
metadata in extended attribute size has

00:25:51,590 --> 00:25:55,730
to use another approach so it's more

00:25:52,880 --> 00:25:57,170
complicated and less efficient

00:25:55,730 --> 00:26:01,370
putting this in the file system layer

00:25:57,170 --> 00:26:03,320
also means there's no need for users to

00:26:01,370 --> 00:26:04,899
be able to mount before before they can

00:26:03,320 --> 00:26:08,499
use encryption

00:26:04,899 --> 00:26:10,450
the implementation in a txt for allows

00:26:08,499 --> 00:26:12,609
it to be turned on per directory and we

00:26:10,450 --> 00:26:16,749
have different key for each different

00:26:12,609 --> 00:26:20,109
key for each directory ftfs is acting

00:26:16,749 --> 00:26:24,190
the same interface part of the reason

00:26:20,109 --> 00:26:26,590
for that is android wants this and some

00:26:24,190 --> 00:26:29,080
Sam Android or some Android devices

00:26:26,590 --> 00:26:33,399
device as you say OST for some of them

00:26:29,080 --> 00:26:35,679
use F 2 FS okay I got some more things

00:26:33,399 --> 00:26:37,600
to talk about but I live up to questions

00:26:35,679 --> 00:26:41,340
and then if there's time after the

00:26:37,600 --> 00:26:41,340
questions I can I can go through those

00:26:41,639 --> 00:27:05,850
yeah so for talking okay all right I

00:27:01,230 --> 00:27:05,850
thought it's 45 minutes 950 memory

00:27:06,690 --> 00:27:11,559
okay then I have 10 minutes of questions

00:27:09,210 --> 00:27:13,889
and if I run out of questions I can talk

00:27:11,559 --> 00:27:13,889
some more

00:27:17,970 --> 00:27:22,559
any questions

00:27:19,629 --> 00:27:22,559
restaurants

00:27:24,919 --> 00:27:30,059
the multi cue functionality which was

00:27:27,959 --> 00:27:33,659
added recently in the Linux kernel is it

00:27:30,059 --> 00:27:36,389
enabled by default for Debian or when do

00:27:33,659 --> 00:27:38,759
you plan on so which functional was in

00:27:36,389 --> 00:27:41,369
the block multi cue functionality that

00:27:38,759 --> 00:27:44,190
was added for the block and you have to

00:27:41,369 --> 00:27:47,309
there's a runtime control for it in the

00:27:44,190 --> 00:27:49,169
scuzzy driver yes I think it's a module

00:27:47,309 --> 00:27:51,419
parameter it's not turned on by default

00:27:49,169 --> 00:28:00,950
upstream it's not turned on by default

00:27:51,419 --> 00:28:00,950
in Debian you have to opt in questions

00:28:07,399 --> 00:28:15,999
to what extent can a X for encryption

00:28:11,599 --> 00:28:15,999
replace Luke's block device encryption

00:28:17,649 --> 00:28:21,469
for some users yes it can replace that

00:28:20,239 --> 00:28:25,460
but it's a different gives with a

00:28:21,469 --> 00:28:27,649
different frame model there's there's an

00:28:25,460 --> 00:28:29,899
article on lwn that goes into quite a

00:28:27,649 --> 00:28:31,820
bit of detail about what this is for and

00:28:29,899 --> 00:28:33,529
what it can and can't do and it'll think

00:28:31,820 --> 00:28:37,789
there's a link in the comments there to

00:28:33,529 --> 00:28:39,649
the public design document from Google

00:28:37,789 --> 00:28:42,289
about what what they needed from this

00:28:39,649 --> 00:28:43,969
like for instance if I encrypt the whole

00:28:42,289 --> 00:28:46,879
file system including from root to

00:28:43,969 --> 00:28:49,879
downwards can then the user encrypt

00:28:46,879 --> 00:28:51,710
their own files on top of that yes yes

00:28:49,879 --> 00:28:54,139
of course they could yes there's nothing

00:28:51,710 --> 00:28:55,549
that you can do encryption you can have

00:28:54,139 --> 00:29:07,210
as many layers of encryption as you want

00:28:55,549 --> 00:29:07,210
okay any more questions

00:29:15,020 --> 00:29:20,210
there are lots and lots of drivers

00:29:17,350 --> 00:29:21,710
upstream has the new process for

00:29:20,210 --> 00:29:23,650
upstream is they put lots and lots of

00:29:21,710 --> 00:29:27,230
drivers in the stretching staging tree

00:29:23,650 --> 00:29:31,460
and eventually based on how the

00:29:27,230 --> 00:29:33,530
individual device developers we maintain

00:29:31,460 --> 00:29:35,480
them and how the quality of the drivers

00:29:33,530 --> 00:29:38,990
are they invention you know progress

00:29:35,480 --> 00:29:42,170
them to the mainline tree and in the

00:29:38,990 --> 00:29:44,000
same kernel what does they been have a

00:29:42,170 --> 00:29:48,620
policy about the drivers which are in

00:29:44,000 --> 00:29:52,780
the staging gave you the current policy

00:29:48,620 --> 00:29:55,690
is that I may be enabled on request but

00:29:52,780 --> 00:30:01,130
drivers in other areas tend to be

00:29:55,690 --> 00:30:05,440
enabled as a matter of course if they're

00:30:01,130 --> 00:30:07,970
for something generic like that's

00:30:05,440 --> 00:30:09,410
something like a USB Drive device that

00:30:07,970 --> 00:30:11,570
you could plug into almost any system

00:30:09,410 --> 00:30:13,220
that if it's outside a staging area then

00:30:11,570 --> 00:30:16,100
we'll probably enable that driver

00:30:13,220 --> 00:30:16,940
without thinking but if it's in the

00:30:16,100 --> 00:30:20,990
staging area

00:30:16,940 --> 00:30:22,940
there is some risk associated with it

00:30:20,990 --> 00:30:25,040
you know my might eat your dress

00:30:22,940 --> 00:30:26,390
probably not any of them could eat your

00:30:25,040 --> 00:30:28,940
hardware but the staging is a bit

00:30:26,390 --> 00:30:30,920
because it's a bit more risky also some

00:30:28,940 --> 00:30:33,230
of that code is not very portable so

00:30:30,920 --> 00:30:35,000
generally we would enable it only for if

00:30:33,230 --> 00:30:37,570
it was requested we'd in able F for x86

00:30:35,000 --> 00:30:37,570
only

00:30:42,640 --> 00:30:52,520
in the title you mentioned missing

00:30:45,440 --> 00:30:56,030
features with what did you mean missing

00:30:52,520 --> 00:31:13,520
features in involved you mean that the

00:30:56,030 --> 00:31:23,960
right at the beginning yeah the bottom

00:31:13,520 --> 00:31:26,810
this one yes I'm missing Debbie yes this

00:31:23,960 --> 00:31:38,920
is about integration and and packaging

00:31:26,810 --> 00:31:38,920
things right so yeah

00:31:40,750 --> 00:31:46,750
therefore features I've talked about so

00:31:43,070 --> 00:31:48,800
far it's mostly going to be about

00:31:46,750 --> 00:31:58,610
applications taking advantage of these

00:31:48,800 --> 00:32:04,130
these things and then overlay FS that's

00:31:58,610 --> 00:32:06,380
going to need so debian live needs to be

00:32:04,130 --> 00:32:08,690
changed or possibly has been changed

00:32:06,380 --> 00:32:11,900
actually I'm not sure but any live

00:32:08,690 --> 00:32:13,610
distribution is going to have to they're

00:32:11,900 --> 00:32:17,440
gonna have to repackage a ufs all you

00:32:13,610 --> 00:32:17,440
never switched my EFS to a fellow FS

00:32:24,600 --> 00:32:39,289
so life passing you know as I said that

00:32:34,590 --> 00:32:43,470
needs a lot of work to actually use it

00:32:39,289 --> 00:32:45,570
the feature is I'm not sure whether I

00:32:43,470 --> 00:32:54,799
actually turn or it's actually turned on

00:32:45,570 --> 00:32:54,799
in the Debian kernels moment but it's

00:32:55,519 --> 00:33:00,090
yeah I mean it's not something you can

00:32:57,870 --> 00:33:12,149
use today in Debian you've ever features

00:33:00,090 --> 00:33:16,559
there in Linux so could you speak a

00:33:12,149 --> 00:33:20,210
little louder in the mouth in the sense

00:33:16,559 --> 00:33:23,639
that the kana team does not support

00:33:20,210 --> 00:33:27,000
updating stable cameras why our life

00:33:23,639 --> 00:33:33,169
patching yeah I could still use it from

00:33:27,000 --> 00:33:35,309
for my own purposes yes you would nature

00:33:33,169 --> 00:33:38,909
you would need to have the expertise and

00:33:35,309 --> 00:33:41,429
the time to construct these patches and

00:33:38,909 --> 00:33:56,759
if you do please join the kernel team to

00:33:41,429 --> 00:33:59,240
do that more questions something that is

00:33:56,759 --> 00:34:01,860
not yet in the kernel that is gr sec

00:33:59,240 --> 00:34:04,919
status progress somebody's working on

00:34:01,860 --> 00:34:08,159
that we have any chance to see sometimes

00:34:04,919 --> 00:34:11,129
in Debian if you look very closely you

00:34:08,159 --> 00:34:14,399
can see that I actually extract it one

00:34:11,129 --> 00:34:20,040
little feature from GL sake and put it

00:34:14,399 --> 00:34:23,190
into the in 4.1 but are we going to

00:34:20,040 --> 00:34:28,859
include it wholesales no it's a very big

00:34:23,190 --> 00:34:30,000
patch and you need a lot of changed well

00:34:28,859 --> 00:34:32,040
you're leaning a fair number of trainers

00:34:30,000 --> 00:34:34,500
to user lands as well

00:34:32,040 --> 00:34:36,829
it has performance cost it's not going

00:34:34,500 --> 00:34:36,829
to

00:34:37,360 --> 00:34:41,500
we can't assume that the GF security

00:34:40,150 --> 00:34:43,540
upstream would support it in fact they

00:34:41,500 --> 00:34:47,050
specifically said no I don't want to

00:34:43,540 --> 00:34:52,020
deal with combining geo security with

00:34:47,050 --> 00:34:54,850
other distribution patches so sorry

00:34:52,020 --> 00:34:58,030
there's nothing to stop you taking a

00:34:54,850 --> 00:35:01,360
support of GR security branch I'm down

00:34:58,030 --> 00:35:03,070
on top of the upstream kernel and and

00:35:01,360 --> 00:35:14,680
running that together with these Debian

00:35:03,070 --> 00:35:18,940
userland overlay FS and the as you said

00:35:14,680 --> 00:35:21,940
a you FS integration will began I'm in

00:35:18,940 --> 00:35:24,310
the packaging from Debian is the new one

00:35:21,940 --> 00:35:26,950
the replacement actually good enough for

00:35:24,310 --> 00:35:29,860
practical use or the things you were

00:35:26,950 --> 00:35:31,540
saying or showing showstoppers

00:35:29,860 --> 00:35:35,460
what are your feelings about this

00:35:31,540 --> 00:35:35,460
supposin are they are not showstoppers

00:35:37,980 --> 00:35:41,670
last question

00:35:52,150 --> 00:35:58,530
new questions then thank you very much

00:35:56,230 --> 00:36:06,959
for your talk and see you again

00:35:58,530 --> 00:36:06,959

YouTube URL: https://www.youtube.com/watch?v=rKFgzSydzPc


