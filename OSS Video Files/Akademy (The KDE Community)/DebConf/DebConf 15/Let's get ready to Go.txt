Title: Let's get ready to Go
Publication date: 2017-12-02
Playlist: DebConf 15
Description: 
	by Margarita Manterola

At: DebConf15
https://summit.debconf.org/debconf15/meeting/228/lets-get-ready-to-go/
https://debconf15.debconf.org/

This talk is an introduction to the Go language. It will go over what Go is and what it's not. A little bit of its history, the basics of the language and a few live demos. It will also cover the state of Go in the free software world in general and Debian in particular.

Room: Heidelberg
Scheduled start: 2015-08-15 10:30:00
Captions: 
	00:00:00,030 --> 00:00:06,720
okay so this talk is about the go

00:00:02,820 --> 00:00:08,940
language I gave this talk in Bucharest

00:00:06,720 --> 00:00:12,450
earlier this year and it was called an

00:00:08,940 --> 00:00:14,880
introduction to go and people told me it

00:00:12,450 --> 00:00:18,779
was like such a boring title that I

00:00:14,880 --> 00:00:21,359
should have more interesting funny title

00:00:18,779 --> 00:00:24,390
and they suggested let's get ready to go

00:00:21,359 --> 00:00:28,050
so I renamed it to let's get ready to go

00:00:24,390 --> 00:00:29,880
and yeah apparently some people were

00:00:28,050 --> 00:00:33,210
confused about this thinking that this

00:00:29,880 --> 00:00:37,410
was like some other kind of talk and not

00:00:33,210 --> 00:00:39,600
to talk about the go language anyway so

00:00:37,410 --> 00:00:43,590
a little bit about me I'm Vivian

00:00:39,600 --> 00:00:45,989
developers in 2005 I asked the Debian

00:00:43,590 --> 00:00:48,030
developer I first started maintaining

00:00:45,989 --> 00:00:53,219
some electronic packages because I'm an

00:00:48,030 --> 00:00:57,989
electronic engineer I then organized

00:00:53,219 --> 00:01:00,359
several that comes particularly I was

00:00:57,989 --> 00:01:03,449
the core organizer of Def Con fate in

00:01:00,359 --> 00:01:06,450
Argentina and this year I'm also part of

00:01:03,449 --> 00:01:09,049
the core organizers of the comme 15 in

00:01:06,450 --> 00:01:11,880
Germany because in between I moved from

00:01:09,049 --> 00:01:14,700
from Argentina to Germany

00:01:11,880 --> 00:01:18,630
I work as site reliability engineer at

00:01:14,700 --> 00:01:22,100
Google since 2012 and I've been mostly a

00:01:18,630 --> 00:01:25,170
Python programmer for more than 10 years

00:01:22,100 --> 00:01:29,119
but I've been writing go code since

00:01:25,170 --> 00:01:33,390
February so I'm not an expert but I'm

00:01:29,119 --> 00:01:36,720
the intention of this talk is to give an

00:01:33,390 --> 00:01:38,610
introduction and let people know what

00:01:36,720 --> 00:01:42,270
things they are going to encounter when

00:01:38,610 --> 00:01:44,310
they try to learn go of course it's a 45

00:01:42,270 --> 00:01:46,860
minute talk it's not like you are going

00:01:44,310 --> 00:01:48,990
to leave this room being a gold

00:01:46,860 --> 00:01:52,770
programmer right I hope nobody expects

00:01:48,990 --> 00:01:55,020
that it's just an introduction so that

00:01:52,770 --> 00:01:57,600
you have a basic idea of what the

00:01:55,020 --> 00:02:00,409
language looks like and the things that

00:01:57,600 --> 00:02:03,210
you can do with it

00:02:00,409 --> 00:02:08,369
seen mostly from the point of view of a

00:02:03,210 --> 00:02:12,150
Python programmer so a bit of history

00:02:08,369 --> 00:02:13,650
goal it's a very young language it's

00:02:12,150 --> 00:02:21,480
course created in two

00:02:13,650 --> 00:02:25,260
seven by some famous people robert

00:02:21,480 --> 00:02:27,060
Griesemer is less known but probably

00:02:25,260 --> 00:02:30,959
many of the people in this room know

00:02:27,060 --> 00:02:37,560
about Rob Pike and Ken Thompson they are

00:02:30,959 --> 00:02:39,359
like the oldies of unique see and many

00:02:37,560 --> 00:02:42,450
other things that are the foundation of

00:02:39,359 --> 00:02:45,120
what we are doing and the goal when they

00:02:42,450 --> 00:02:48,480
created the goal language was to create

00:02:45,120 --> 00:02:50,310
a language that was similar to see but

00:02:48,480 --> 00:02:57,769
that incorporated all the good things

00:02:50,310 --> 00:03:01,439
that had been discovered or developed

00:02:57,769 --> 00:03:04,139
since then so when when she came up it

00:03:01,439 --> 00:03:06,079
was a revolution right because before

00:03:04,139 --> 00:03:09,689
that people were writing assembler and

00:03:06,079 --> 00:03:11,220
and it's been it's been going on and

00:03:09,689 --> 00:03:14,310
being a great language for a long time

00:03:11,220 --> 00:03:16,439
but now it's time for something that's

00:03:14,310 --> 00:03:21,959
created this century and not last

00:03:16,439 --> 00:03:25,169
century so what go is not go it's not an

00:03:21,959 --> 00:03:28,049
interpreted language it's compiled it's

00:03:25,169 --> 00:03:30,299
not a replacement for Python like I say

00:03:28,049 --> 00:03:32,190
I come from Python and I have this

00:03:30,299 --> 00:03:35,010
feeling that before I used to do

00:03:32,190 --> 00:03:37,049
everything with Python and it's not like

00:03:35,010 --> 00:03:38,609
with you will do everything with go

00:03:37,049 --> 00:03:40,379
there are certain things that are better

00:03:38,609 --> 00:03:42,239
suited to do with go and there are

00:03:40,379 --> 00:03:46,489
certain things that are better suited to

00:03:42,239 --> 00:03:49,979
do whether a scripting language

00:03:46,489 --> 00:03:52,970
interpreter language that is faster when

00:03:49,979 --> 00:03:56,609
you need to just do a quick prototype

00:03:52,970 --> 00:04:00,599
you do not want to use the whole thing

00:03:56,609 --> 00:04:02,099
just for a quick prototype it's not the

00:04:00,599 --> 00:04:04,799
answer to every programming need and

00:04:02,099 --> 00:04:07,530
it's not very well named so this is kind

00:04:04,799 --> 00:04:09,659
of we are right it comes so well was

00:04:07,530 --> 00:04:14,750
developed that the people that develop

00:04:09,659 --> 00:04:16,799
go work for Google and I find it a bit

00:04:14,750 --> 00:04:19,349
surprising that they decided to make

00:04:16,799 --> 00:04:22,109
their language go which is something

00:04:19,349 --> 00:04:27,130
that you can google for right if you

00:04:22,109 --> 00:04:30,010
google go who knows what you will get

00:04:27,130 --> 00:04:34,180
the result so if you need to Google

00:04:30,010 --> 00:04:37,360
stuff for the go language what you use

00:04:34,180 --> 00:04:40,570
is use golang right the keyword let's

00:04:37,360 --> 00:04:43,900
not go it's going and that works fine so

00:04:40,570 --> 00:04:46,450
you can get like the documentation Stack

00:04:43,900 --> 00:04:49,420
Overflow answers blog posts everything

00:04:46,450 --> 00:04:50,760
includes a golden string because

00:04:49,420 --> 00:04:54,370
otherwise it doesn't work

00:04:50,760 --> 00:04:59,050
so what go is it's an open source

00:04:54,370 --> 00:05:01,390
compiled language it's this century see

00:04:59,050 --> 00:05:04,360
if that's what it's intended to be its

00:05:01,390 --> 00:05:08,260
intended to be the 21st centuries see

00:05:04,360 --> 00:05:10,300
and it's it's designed for concurrency

00:05:08,260 --> 00:05:13,390
it has garbage collection it has Unicode

00:05:10,300 --> 00:05:19,150
support it has some dynamic typing so

00:05:13,390 --> 00:05:21,550
it's well so it has all these new things

00:05:19,150 --> 00:05:26,800
while at the same time it tries to keep

00:05:21,550 --> 00:05:29,320
the philosophy of see some nice things

00:05:26,800 --> 00:05:32,950
about go the compiler touches a lot of

00:05:29,320 --> 00:05:35,710
errors this particularly compared to

00:05:32,950 --> 00:05:38,890
interpreted languages but also compared

00:05:35,710 --> 00:05:41,200
to like the C compiler the compiler I

00:05:38,890 --> 00:05:44,200
don't know if you declare a variable and

00:05:41,200 --> 00:05:45,820
don't use it the compiler tells you hey

00:05:44,200 --> 00:05:46,210
you declare a variable and you didn't

00:05:45,820 --> 00:05:49,350
use it

00:05:46,210 --> 00:05:50,970
maybe there's something wrong there and

00:05:49,350 --> 00:05:54,700
things like that

00:05:50,970 --> 00:05:58,900
usually the compiler is right when it

00:05:54,700 --> 00:06:00,760
catches errors sometimes you say okay I

00:05:58,900 --> 00:06:03,760
had this variable I will use it later

00:06:00,760 --> 00:06:08,050
why do you complain but yeah you can

00:06:03,760 --> 00:06:12,400
just comment out the line it comes with

00:06:08,050 --> 00:06:13,930
a very full set of libraries with lots

00:06:12,400 --> 00:06:17,260
of functionalities that are already

00:06:13,930 --> 00:06:17,860
there so you don't have to develop them

00:06:17,260 --> 00:06:20,710
yourself

00:06:17,860 --> 00:06:23,460
it has native concurrency support I will

00:06:20,710 --> 00:06:27,340
talk a little bit more about that and

00:06:23,460 --> 00:06:28,840
for people that like the e the quickness

00:06:27,340 --> 00:06:34,000
of an interpreted language

00:06:28,840 --> 00:06:35,740
there's the go playground which is like

00:06:34,000 --> 00:06:39,669
an interactive web page where you can

00:06:35,740 --> 00:06:41,530
write some code and execute it and see

00:06:39,669 --> 00:06:44,040
it executed there

00:06:41,530 --> 00:06:46,540
without needing to compile it yourself

00:06:44,040 --> 00:06:50,050
if you don't have the tools installed

00:06:46,540 --> 00:06:52,450
you can just go there and start playing

00:06:50,050 --> 00:06:58,630
around the beat without having to worry

00:06:52,450 --> 00:07:01,180
of having all the packages and also it's

00:06:58,630 --> 00:07:04,360
good when you are sending code back and

00:07:01,180 --> 00:07:07,090
forth if you like put stuff in the

00:07:04,360 --> 00:07:08,980
playground you can then create a

00:07:07,090 --> 00:07:11,200
shareable link so you send it to someone

00:07:08,980 --> 00:07:13,180
saying I have this code and I don't know

00:07:11,200 --> 00:07:14,830
why it doesn't work can you help me you

00:07:13,180 --> 00:07:17,020
send them the link and then that this

00:07:14,830 --> 00:07:19,660
person finds oh yeah you forgot to do

00:07:17,020 --> 00:07:22,600
this or that and they send you the link

00:07:19,660 --> 00:07:26,020
with the fix and so this is very good

00:07:22,600 --> 00:07:27,300
for exchanging code with people on the

00:07:26,020 --> 00:07:31,150
Internet

00:07:27,300 --> 00:07:34,210
so what does go look like this is a very

00:07:31,150 --> 00:07:39,540
simple go program for people that come

00:07:34,210 --> 00:07:39,540
from C that's going to look familiar

00:07:40,740 --> 00:07:48,280
every main package so package main means

00:07:46,120 --> 00:07:52,270
that this is where the main function is

00:07:48,280 --> 00:07:55,320
going to be then import FMT it's

00:07:52,270 --> 00:08:00,990
bringing in the package that will allow

00:07:55,320 --> 00:08:05,560
printing on the screen then this sound

00:08:00,990 --> 00:08:09,160
no I know how yeah some colon equals

00:08:05,560 --> 00:08:12,210
zero is the pseudo dynamic typing that

00:08:09,160 --> 00:08:17,490
go has so what's happening there is that

00:08:12,210 --> 00:08:22,420
go is seeing that zero is a number and

00:08:17,490 --> 00:08:24,640
assigning some this type so it's not

00:08:22,420 --> 00:08:27,610
only that we are assigning zero to the

00:08:24,640 --> 00:08:31,060
variable we are also assigning the type

00:08:27,610 --> 00:08:33,640
what will not happen is if we later on

00:08:31,060 --> 00:08:36,820
try to assign a string there it will

00:08:33,640 --> 00:08:42,270
fail because some is an integer so we

00:08:36,820 --> 00:08:45,580
are excused from declaring the type but

00:08:42,270 --> 00:08:49,590
the type will stay right we can't just

00:08:45,580 --> 00:08:53,510
change and say oh now I want some twe

00:08:49,590 --> 00:08:56,900
date no it can't so

00:08:53,510 --> 00:09:04,250
it does the type declaration for us but

00:08:56,900 --> 00:09:06,710
then the type stays the same for the the

00:09:04,250 --> 00:09:08,900
for loop the for loop is exactly the for

00:09:06,710 --> 00:09:13,700
loop from Z except without the

00:09:08,900 --> 00:09:18,740
parentheses and then at the end this

00:09:13,700 --> 00:09:21,290
just prints it on the screen so that

00:09:18,740 --> 00:09:24,980
that seemed like very similar to CN very

00:09:21,290 --> 00:09:27,170
nice and ok but there are some quick

00:09:24,980 --> 00:09:29,990
because I didn't have any types there

00:09:27,170 --> 00:09:32,150
and it didn't look weird but the types

00:09:29,990 --> 00:09:36,740
are declared exactly the other way

00:09:32,150 --> 00:09:40,370
around that they are declaring C so so

00:09:36,740 --> 00:09:43,970
instead of in star C which is a pointer

00:09:40,370 --> 00:09:46,850
to an integer it's first the variable

00:09:43,970 --> 00:09:50,300
name and then start int so the idea is

00:09:46,850 --> 00:09:54,350
that you read this outline aloud C is a

00:09:50,300 --> 00:10:00,230
pointer to an integer and that's how the

00:09:54,350 --> 00:10:02,540
order goes or the same for arrays which

00:10:00,230 --> 00:10:06,740
in go are called slices but you can

00:10:02,540 --> 00:10:12,250
think of them as arrays a it's an array

00:10:06,740 --> 00:10:12,250
of bytes so it goes the other way around

00:10:12,640 --> 00:10:18,680
then when you're dealing with visibility

00:10:15,980 --> 00:10:21,260
the case of the first letter of a

00:10:18,680 --> 00:10:25,130
function defines if a function is

00:10:21,260 --> 00:10:27,380
private or public there's no public or

00:10:25,130 --> 00:10:29,960
private keyword it's just the case of

00:10:27,380 --> 00:10:32,390
the first letter so if you if you

00:10:29,960 --> 00:10:34,130
suddenly change your mind and and want

00:10:32,390 --> 00:10:36,830
to export the function that you are not

00:10:34,130 --> 00:10:39,740
exporting you have to rename it to have

00:10:36,830 --> 00:10:42,140
the first letter be uppercase and change

00:10:39,740 --> 00:10:46,400
all your code so that whatever calls it

00:10:42,140 --> 00:10:50,420
now calls the uppercase version and it

00:10:46,400 --> 00:10:53,210
has error handling but it takes a while

00:10:50,420 --> 00:10:57,970
to get used to it because it's kind of

00:10:53,210 --> 00:10:57,970
strange I will show some code so

00:10:58,870 --> 00:11:06,290
interfaces go does not have objects in

00:11:03,320 --> 00:11:08,389
the Java sense but

00:11:06,290 --> 00:11:11,870
it does have something that it's almost

00:11:08,389 --> 00:11:14,870
like objects what you have is you have

00:11:11,870 --> 00:11:17,930
structs or types it doesn't need to be a

00:11:14,870 --> 00:11:22,310
struct it can be just a simple type and

00:11:17,930 --> 00:11:25,220
you associate methods to those struts or

00:11:22,310 --> 00:11:29,060
types you can even associate methods to

00:11:25,220 --> 00:11:31,310
like int you can associate methods to

00:11:29,060 --> 00:11:33,259
any type you want doesn't need to be a

00:11:31,310 --> 00:11:35,509
type you declared it can be any type you

00:11:33,259 --> 00:11:39,079
want you can associate methods to it and

00:11:35,509 --> 00:11:40,819
then polymorphism is done through this

00:11:39,079 --> 00:11:43,040
interface so you can declare an

00:11:40,819 --> 00:11:46,240
interface and it's done through these

00:11:43,040 --> 00:11:48,889
interfaces but you'd only clear the

00:11:46,240 --> 00:11:50,839
struct or a class or because there's no

00:11:48,889 --> 00:11:55,250
class you don't declare that these

00:11:50,839 --> 00:11:58,029
things are of that type if they follow

00:11:55,250 --> 00:12:00,199
the interface they just are of the type

00:11:58,029 --> 00:12:02,149
this is something that it's only

00:12:00,199 --> 00:12:03,769
possible because it's compiled right it

00:12:02,149 --> 00:12:05,959
wouldn't be possible in an interpreted

00:12:03,769 --> 00:12:08,540
language but being that it's compiled

00:12:05,959 --> 00:12:11,300
it's like if it has all the needed

00:12:08,540 --> 00:12:13,760
things to be part of the interface it

00:12:11,300 --> 00:12:16,519
just is you don't have to declare these

00:12:13,760 --> 00:12:20,329
follows this interface you just have to

00:12:16,519 --> 00:12:24,350
make it follow the interface okay so I

00:12:20,329 --> 00:12:27,620
have more snippet here and I readable

00:12:24,350 --> 00:12:38,089
from the back I think they are but yeah

00:12:27,620 --> 00:12:40,010
okay so maybe should I stand here so the

00:12:38,089 --> 00:12:46,790
first function because it starts with a

00:12:40,010 --> 00:12:49,459
lowercase it it's private right then

00:12:46,790 --> 00:12:53,329
it's a private function because it

00:12:49,459 --> 00:12:55,459
starts with lowercase H it receives a

00:12:53,329 --> 00:12:57,829
string and return scible so what comes

00:12:55,459 --> 00:13:00,610
after the parameters is what the

00:12:57,829 --> 00:13:00,610
function returns

00:13:00,910 --> 00:13:06,290
yeah the wrist is just showing some of

00:13:03,920 --> 00:13:09,560
the functions available in the strings

00:13:06,290 --> 00:13:12,889
package then the next function it's a

00:13:09,560 --> 00:13:17,839
function that it's associated to a type

00:13:12,889 --> 00:13:19,399
so the the parentheses that comes before

00:13:17,839 --> 00:13:19,820
the name of the function

00:13:19,399 --> 00:13:24,620
the

00:13:19,820 --> 00:13:27,950
KCK config parentheses is the type to

00:13:24,620 --> 00:13:31,490
which this function is associated so

00:13:27,950 --> 00:13:36,710
this is a method of the key config class

00:13:31,490 --> 00:13:41,260
right speaking in in java terms and kc

00:13:36,710 --> 00:13:46,280
is the name that you will use to access

00:13:41,260 --> 00:13:48,800
the instance right so what in in java is

00:13:46,280 --> 00:13:50,780
these and what in python it's usually

00:13:48,800 --> 00:13:54,710
self but you can rename to whatever you

00:13:50,780 --> 00:13:59,930
want it's this KC here and you can name

00:13:54,710 --> 00:14:02,150
it whatever you want and this one

00:13:59,930 --> 00:14:07,010
because it starts with a uppercase K

00:14:02,150 --> 00:14:08,780
it's it's an exported function and then

00:14:07,010 --> 00:14:10,880
in the last one we have the error

00:14:08,780 --> 00:14:16,010
handling that I mentioned it's weird

00:14:10,880 --> 00:14:17,630
so what's happening here is that the

00:14:16,010 --> 00:14:22,030
first function that it's found in the

00:14:17,630 --> 00:14:24,350
first line files that returns two things

00:14:22,030 --> 00:14:26,630
the first thing is the the file

00:14:24,350 --> 00:14:28,780
information that the function is wanting

00:14:26,630 --> 00:14:32,510
to use and the second thing is an error

00:14:28,780 --> 00:14:35,630
so what you do is you check if the error

00:14:32,510 --> 00:14:37,760
is nil or it's not need so if it's new

00:14:35,630 --> 00:14:40,460
it means everything went right and if

00:14:37,760 --> 00:14:45,920
it's not Neal it means something failed

00:14:40,460 --> 00:14:49,430
and you have to handle the error this

00:14:45,920 --> 00:14:52,970
function returns a boolean and an error

00:14:49,430 --> 00:14:57,380
so what you do is if whichever you

00:14:52,970 --> 00:15:01,130
called returned an error you also return

00:14:57,380 --> 00:15:03,440
an error usually you add more

00:15:01,130 --> 00:15:05,450
information but it depends so you can

00:15:03,440 --> 00:15:07,280
like have more information to that error

00:15:05,450 --> 00:15:09,110
that you are returning in this case it's

00:15:07,280 --> 00:15:12,110
not adding more information I picked a

00:15:09,110 --> 00:15:15,170
simple piece of code but it can go much

00:15:12,110 --> 00:15:17,660
more complicated the problem that I see

00:15:15,170 --> 00:15:19,820
on the with this that takes a while to

00:15:17,660 --> 00:15:24,200
get used to at the end you get used to

00:15:19,820 --> 00:15:26,150
it but it takes a while is that you for

00:15:24,200 --> 00:15:29,000
every call that might return an error

00:15:26,150 --> 00:15:31,970
you have to check the error like if you

00:15:29,000 --> 00:15:33,630
come from Java or Python you are used to

00:15:31,970 --> 00:15:35,250
just putting a try

00:15:33,630 --> 00:15:37,110
and doing all the stuff there that might

00:15:35,250 --> 00:15:39,540
fail and then afterwards catching

00:15:37,110 --> 00:15:42,810
whatever exceptions you might have to

00:15:39,540 --> 00:15:44,490
catch but in this case for every call

00:15:42,810 --> 00:15:46,140
you need to check the dis return an

00:15:44,490 --> 00:15:50,340
error did this return an error this

00:15:46,140 --> 00:15:52,020
general and yeah so it takes a while to

00:15:50,340 --> 00:15:54,810
get used to but in the end it's very

00:15:52,020 --> 00:15:57,740
simple so you you just check every error

00:15:54,810 --> 00:16:00,120
and sometimes it makes sense because

00:15:57,740 --> 00:16:02,370
depending on what is that they can be

00:16:00,120 --> 00:16:05,820
error you may want to do different

00:16:02,370 --> 00:16:07,350
things so it's not that it doesn't make

00:16:05,820 --> 00:16:09,800
sense it just takes some time to get

00:16:07,350 --> 00:16:09,800
used to it

00:16:12,320 --> 00:16:19,530
so concurrency this is one of the things

00:16:17,280 --> 00:16:22,920
that I said let go it's like it's

00:16:19,530 --> 00:16:25,530
designed for concurrency the main way of

00:16:22,920 --> 00:16:27,840
doing concurrency in go is using go

00:16:25,530 --> 00:16:33,180
routines which are like core routines

00:16:27,840 --> 00:16:36,030
but special and you can start any

00:16:33,180 --> 00:16:38,010
function that you have in your code you

00:16:36,030 --> 00:16:41,370
can just start it with the go keyword

00:16:38,010 --> 00:16:43,530
and it will become a go routine and what

00:16:41,370 --> 00:16:46,080
this means is that it will like run on

00:16:43,530 --> 00:16:48,930
its separate thread but it's a very

00:16:46,080 --> 00:16:52,050
lightweight thread it's not a full

00:16:48,930 --> 00:16:54,360
thread as we normally think of but very

00:16:52,050 --> 00:16:56,850
lightweight and very cheap so you can

00:16:54,360 --> 00:17:01,380
start many many go routines in parallel

00:16:56,850 --> 00:17:07,920
and it will not make your computer try

00:17:01,380 --> 00:17:10,380
and then there's channels to synchronize

00:17:07,920 --> 00:17:12,870
the go routines so you can send

00:17:10,380 --> 00:17:15,720
information to a routine and receive

00:17:12,870 --> 00:17:19,410
information from the routine using the

00:17:15,720 --> 00:17:24,420
channels and the basic idea behind this

00:17:19,410 --> 00:17:28,079
is you don't share the data by sharing

00:17:24,420 --> 00:17:29,970
memory between threads which is what

00:17:28,079 --> 00:17:34,080
gives so many headaches regarding

00:17:29,970 --> 00:17:36,630
concurrency but rather you share the

00:17:34,080 --> 00:17:39,420
data by sending it or receiving it so

00:17:36,630 --> 00:17:41,370
reading or writing from the routines but

00:17:39,420 --> 00:17:44,160
not sharing memory because sharing

00:17:41,370 --> 00:17:46,340
memory has been proven to be really hard

00:17:44,160 --> 00:17:48,169
to do right so this is very

00:17:46,340 --> 00:17:52,490
see you should send the data receive the

00:17:48,169 --> 00:17:55,520
date and it's very easy to get right so

00:17:52,490 --> 00:17:58,429
before where I go into that I wanted to

00:17:55,520 --> 00:18:01,970
do a small demo are there any questions

00:17:58,429 --> 00:18:07,850
up to now do we have someone with the

00:18:01,970 --> 00:18:10,159
mic if there are any questions okay

00:18:07,850 --> 00:18:14,409
apparently not so I will I will go to a

00:18:10,159 --> 00:18:14,409
small demo let's see how that goes

00:18:37,389 --> 00:18:44,049
let's start first with the usual thing

00:18:49,750 --> 00:18:59,649
instead of printing hello world this is

00:18:53,419 --> 00:18:59,649
DEFCON 15 the biggest debconf

00:19:01,210 --> 00:19:11,600
okay so this is like the basic gist of

00:19:06,639 --> 00:19:17,240
go programs to build it what did I call

00:19:11,600 --> 00:19:23,269
the directory the seeking hmm go so go

00:19:17,240 --> 00:19:25,850
build example.com this will build binary

00:19:23,269 --> 00:19:28,700
the goal compiler is really fast and

00:19:25,850 --> 00:19:32,450
this is like one of the features of the

00:19:28,700 --> 00:19:34,490
compiler that it's really fast I am NOT

00:19:32,450 --> 00:19:36,940
a particular fan of the compiler being

00:19:34,490 --> 00:19:39,289
fast because normally you compile a

00:19:36,940 --> 00:19:41,629
bunch of times and you execute

00:19:39,289 --> 00:19:43,309
many more times but whatever for the

00:19:41,629 --> 00:19:44,929
designers it was really important that

00:19:43,309 --> 00:19:49,250
the compiler was fast so it's really

00:19:44,929 --> 00:19:51,620
fast so there we have our hello world

00:19:49,250 --> 00:20:00,980
now let's do something a bit more

00:19:51,620 --> 00:20:03,429
interesting so first I will print a

00:20:00,980 --> 00:20:03,429
random number

00:20:15,870 --> 00:20:26,850
so there are two randoms there's my

00:20:24,779 --> 00:20:29,610
friend and there's crypt runt

00:20:26,850 --> 00:20:32,460
so for creep things you want to use the

00:20:29,610 --> 00:20:34,740
real random for just printing a random

00:20:32,460 --> 00:20:37,559
number on the screen you you don't need

00:20:34,740 --> 00:20:39,480
to do all the crypt things but like

00:20:37,559 --> 00:20:42,480
there I think it makes sense because the

00:20:39,480 --> 00:20:47,700
creep random is harder to use because

00:20:42,480 --> 00:20:50,059
like it's crypt so there let's see how

00:20:47,700 --> 00:20:50,059
that goes

00:20:50,720 --> 00:21:02,360
yeah what do you think will happen when

00:20:54,809 --> 00:21:02,360
I execute this again same random number

00:21:03,559 --> 00:21:08,600
y-yeah I need to see the pseudo-random

00:21:06,120 --> 00:21:12,720
generator otherwise it doesn't work

00:21:08,600 --> 00:21:14,399
so so here's where you say okay so how

00:21:12,720 --> 00:21:16,409
do I see the pseudo-random generator

00:21:14,399 --> 00:21:23,220
there's a lot of documentation this is a

00:21:16,409 --> 00:21:25,110
good thing so in golang.org - package

00:21:23,220 --> 00:21:30,299
you have all the packages that are

00:21:25,110 --> 00:21:37,200
included with the language and I'm

00:21:30,299 --> 00:21:44,880
importing mass sorry mass R and so let's

00:21:37,200 --> 00:21:48,529
open that and here it says that there's

00:21:44,880 --> 00:21:51,870
this seed function where is it seed here

00:21:48,529 --> 00:21:56,700
so we need to see it in order to get

00:21:51,870 --> 00:22:04,110
real random so seed so what will I set

00:21:56,700 --> 00:22:09,210
it with time so well okay let's let's go

00:22:04,110 --> 00:22:12,049
faster here okay if I if I do this let's

00:22:09,210 --> 00:22:12,049
let's just do it

00:22:24,169 --> 00:22:28,760
well so what's what's happening there

00:22:29,659 --> 00:22:35,400
the same second gets the same to the

00:22:32,610 --> 00:22:43,289
random generator so instead of Unix we

00:22:35,400 --> 00:22:45,480
want Unix nano I could have shown that

00:22:43,289 --> 00:22:48,059
the spec for time but I want to also

00:22:45,480 --> 00:22:49,039
show other things so yeah so now it's

00:22:48,059 --> 00:22:51,890
working

00:22:49,039 --> 00:22:55,320
yeah it's a random between ten numbers

00:22:51,890 --> 00:22:59,700
you won't expect to have more than that

00:22:55,320 --> 00:23:02,760
randomization okay so now I want to show

00:22:59,700 --> 00:23:04,919
some go routines it like because we have

00:23:02,760 --> 00:23:06,809
limited amount of time it will be a very

00:23:04,919 --> 00:23:10,409
simple girl routine it will not do

00:23:06,809 --> 00:23:14,330
anything useful but just to show how it

00:23:10,409 --> 00:23:14,330
works so

00:23:21,309 --> 00:23:27,490
it will first print that it's starting

00:23:37,050 --> 00:23:44,310
and then print that it's done and in

00:23:41,400 --> 00:23:51,600
between I'll make it sleep a random

00:23:44,310 --> 00:23:55,860
amount of time sleep takes a duration

00:23:51,600 --> 00:23:59,820
let's let's go look at the sleep so

00:23:55,860 --> 00:24:06,240
sleep takes a duration here is the the

00:23:59,820 --> 00:24:07,920
spec from sleep and here there's an

00:24:06,240 --> 00:24:10,050
example but it doesn't work with with a

00:24:07,920 --> 00:24:14,640
random number I will need to cast the

00:24:10,050 --> 00:24:21,380
random number so that it's a duration so

00:24:14,640 --> 00:24:21,380
I think it's time doc duration Rand

00:24:22,220 --> 00:24:34,610
hundred times time millisecond yeah

00:24:34,640 --> 00:24:40,200
possibly got it right there

00:24:37,560 --> 00:24:42,300
we will see when the compiler complaints

00:24:40,200 --> 00:24:45,810
and so now so I have this function that

00:24:42,300 --> 00:24:48,330
starts does something for some amount of

00:24:45,810 --> 00:24:49,950
time and then says I'm done right let's

00:24:48,330 --> 00:24:53,100
pretend this function actually does

00:24:49,950 --> 00:24:54,930
something useful like parts of file and

00:24:53,100 --> 00:25:02,450
and then store the result somewhere else

00:24:54,930 --> 00:25:10,160
or whatever and then I will do four four

00:25:02,450 --> 00:25:10,160
five times so that it fits on the screen

00:25:19,390 --> 00:25:21,990
okay

00:25:23,850 --> 00:25:29,570
is it clear what I'm doing what do you

00:25:27,059 --> 00:25:29,570
think will happen

00:25:36,590 --> 00:25:47,280
what did online shroom come back in

00:25:41,280 --> 00:25:51,240
random order yes what happened

00:25:47,280 --> 00:25:54,510
I didn't wait exactly because I didn't

00:25:51,240 --> 00:25:56,039
wait then like they were started and

00:25:54,510 --> 00:25:57,929
then the present finish and they didn't

00:25:56,039 --> 00:26:00,350
have time to do anything so let's wait a

00:25:57,929 --> 00:26:05,760
little bit more

00:26:00,350 --> 00:26:10,640
let's wait one second here we can use

00:26:05,760 --> 00:26:10,640
time second

00:26:15,789 --> 00:26:23,919
there so I I started them in order but

00:26:20,049 --> 00:26:25,659
they got done in a random order right

00:26:23,919 --> 00:26:28,679
because they took different amount of

00:26:25,659 --> 00:26:31,479
time well so as I said this is a very

00:26:28,679 --> 00:26:34,059
useless example but it just shows how

00:26:31,479 --> 00:26:36,369
easy it is it's like any function this

00:26:34,059 --> 00:26:38,499
this function the sleeper function

00:26:36,369 --> 00:26:40,659
didn't have anything saying this is a

00:26:38,499 --> 00:26:43,359
function that will be inside a thread or

00:26:40,659 --> 00:26:47,429
anything it's just any function that you

00:26:43,359 --> 00:26:50,289
can start as a go routine and then it's

00:26:47,429 --> 00:26:53,409
concurrent then you need to make sure

00:26:50,289 --> 00:26:55,659
that you wait for it but that depends on

00:26:53,409 --> 00:26:58,929
whatever you are doing you can also like

00:26:55,659 --> 00:27:04,749
send data and receive data shall we do

00:26:58,929 --> 00:27:09,009
that do we have time I don't know are

00:27:04,749 --> 00:27:10,629
there any questions I don't want to eat

00:27:09,009 --> 00:27:12,960
all the time with the demo if there are

00:27:10,629 --> 00:27:12,960
no questions

00:27:19,160 --> 00:27:36,030
wait wait wait wait for the mic please

00:27:23,270 --> 00:27:43,830
there my question is how do you do that

00:27:36,030 --> 00:27:47,280
with our normal function just world I'm

00:27:43,830 --> 00:27:54,120
sorry there's too much I don't know 1 2

00:27:47,280 --> 00:27:55,770
3 4 normal function it's just a normal

00:27:54,120 --> 00:27:56,190
function that's why I don't understand

00:27:55,770 --> 00:27:59,360
the question

00:27:56,190 --> 00:28:04,130
so I just created a function and then

00:27:59,360 --> 00:28:08,370
here I use the go keyword to make it

00:28:04,130 --> 00:28:12,630
threaded they go keyword is for the go

00:28:08,370 --> 00:28:15,720
keyword starts a go routine like if you

00:28:12,630 --> 00:28:18,270
add this keyword it becomes a go routine

00:28:15,720 --> 00:28:19,080
there is no other way to call the

00:28:18,270 --> 00:28:21,630
function

00:28:19,080 --> 00:28:29,610
yeah I I could just so if I call it

00:28:21,630 --> 00:28:32,120
without the go keyword it just like does

00:28:29,610 --> 00:28:32,120
it in order

00:28:33,919 --> 00:28:38,309
how do you do modeling of

00:28:36,480 --> 00:28:42,030
interdependencies between the different

00:28:38,309 --> 00:28:45,150
threads that you're fired up can you

00:28:42,030 --> 00:28:46,950
repeat the question how do you model in

00:28:45,150 --> 00:28:51,059
the dependencies between the different

00:28:46,950 --> 00:28:52,860
threats that are fired up I mean how do

00:28:51,059 --> 00:28:54,809
you communicate with each other was a

00:28:52,860 --> 00:28:59,820
channel right so that's what you're

00:28:54,809 --> 00:29:02,880
mentioning in the big yeah okay let me

00:28:59,820 --> 00:29:06,780
see I don't want to go it's a lot of

00:29:02,880 --> 00:29:08,220
code but so I will look for the example

00:29:06,780 --> 00:29:11,790
so that I don't have to type on the

00:29:08,220 --> 00:29:14,730
example but first I will introduce this

00:29:11,790 --> 00:29:18,030
play this site like tour dot golang.org

00:29:14,730 --> 00:29:19,679
is like a tutorial so if you after this

00:29:18,030 --> 00:29:21,419
talk you feel like you would like to

00:29:19,679 --> 00:29:25,559
learn how to code and go

00:29:21,419 --> 00:29:30,390
this tutorial is recommended and it has

00:29:25,559 --> 00:29:31,240
some part about concurrency so let's go

00:29:30,390 --> 00:29:33,220
look at the

00:29:31,240 --> 00:29:40,120
example there because otherwise it's a

00:29:33,220 --> 00:29:41,679
lot of typing so here can you can you

00:29:40,120 --> 00:29:45,610
read from there should I make the font

00:29:41,679 --> 00:29:49,140
that's large sure I don't know how to

00:29:45,610 --> 00:29:57,130
but I will try yeah

00:29:49,140 --> 00:30:00,820
and now there okay so this is a channel

00:29:57,130 --> 00:30:03,460
see is a Channel so this function

00:30:00,820 --> 00:30:06,970
receives the channel to which it has to

00:30:03,460 --> 00:30:10,750
write it's it's a channel to which it

00:30:06,970 --> 00:30:14,980
will write and it does the sum of a lot

00:30:10,750 --> 00:30:18,220
of integers and by the end it sends the

00:30:14,980 --> 00:30:21,309
Sun to the channel like this this arrow

00:30:18,220 --> 00:30:27,790
notation means that the Sun is sent to

00:30:21,309 --> 00:30:34,750
the channel and then in the main

00:30:27,790 --> 00:30:38,770
function so the channel is created with

00:30:34,750 --> 00:30:41,770
this make keyword and there are two go

00:30:38,770 --> 00:30:46,330
routines called summing half of the

00:30:41,770 --> 00:30:47,920
array and receiving the same channel so

00:30:46,330 --> 00:30:51,730
they both have to write to the same

00:30:47,920 --> 00:30:55,809
channel they are some and then this

00:30:51,730 --> 00:30:57,820
method receives using the so it just

00:30:55,809 --> 00:31:01,090
changes where the channel is right so

00:30:57,820 --> 00:31:03,460
it's the same arrow thing but on one

00:31:01,090 --> 00:31:05,020
side the channel is on the left and on

00:31:03,460 --> 00:31:08,230
the other side the channel is on right

00:31:05,020 --> 00:31:10,780
and so in this case you are receiving

00:31:08,230 --> 00:31:16,179
from the channel into these two

00:31:10,780 --> 00:31:18,600
variables yes and we can run it from

00:31:16,179 --> 00:31:18,600
here

00:31:22,150 --> 00:31:29,780
sorry and they are like it has the sum

00:31:26,960 --> 00:31:34,760
of both channels and the result of the

00:31:29,780 --> 00:31:37,910
sum in both numbers for this is also

00:31:34,760 --> 00:31:39,440
like not a very useful example it's just

00:31:37,910 --> 00:31:42,410
an example to understand channels but

00:31:39,440 --> 00:31:45,200
the idea is that if you have if you have

00:31:42,410 --> 00:31:47,419
workers that need to do something and at

00:31:45,200 --> 00:31:49,549
the end they have a result you just give

00:31:47,419 --> 00:31:53,210
them the channel and when they are done

00:31:49,549 --> 00:31:56,059
they send the data to the channel and on

00:31:53,210 --> 00:31:57,860
the other side you read from the channel

00:31:56,059 --> 00:32:01,150
and when you read from the channel you

00:31:57,860 --> 00:32:03,409
wait until there's information there so

00:32:01,150 --> 00:32:06,320
that's like the wait is done

00:32:03,409 --> 00:32:10,640
automatically by the operation of

00:32:06,320 --> 00:32:12,260
reading from the channel yes so they are

00:32:10,640 --> 00:32:20,710
you sure synchronize because you are

00:32:12,260 --> 00:32:20,710
reading other questions

00:32:27,200 --> 00:32:33,420
you're firing off to go routines at that

00:32:31,020 --> 00:32:36,360
point there's no guarantee which order

00:32:33,420 --> 00:32:38,940
that will complete in is there no so the

00:32:36,360 --> 00:32:41,400
X&Y could end up being unlikely but it

00:32:38,940 --> 00:32:43,020
could be minus 5 and 17 yes yeah they

00:32:41,400 --> 00:32:49,890
could be in this case it doesn't happen

00:32:43,020 --> 00:32:53,330
but yes yes there's no guarantee okay so

00:32:49,890 --> 00:33:02,040
let's go back to the presentation

00:32:53,330 --> 00:33:04,770
No okay so the state of go in Debian you

00:33:02,040 --> 00:33:06,480
can apt-get install go long and you have

00:33:04,770 --> 00:33:08,160
the whole developer in developing

00:33:06,480 --> 00:33:10,680
environment installed you will have this

00:33:08,160 --> 00:33:14,790
go build command that I've been using

00:33:10,680 --> 00:33:20,280
and all the libraries to build go

00:33:14,790 --> 00:33:23,220
packages there's th go long yeah so the

00:33:20,280 --> 00:33:25,020
I this state these stats is from me

00:33:23,220 --> 00:33:27,300
there are probably more reverse with

00:33:25,020 --> 00:33:30,590
dependencies right now but I I compiled

00:33:27,300 --> 00:33:33,330
the number in May and there were 53

00:33:30,590 --> 00:33:35,790
reverse feel dependencies from the H :

00:33:33,330 --> 00:33:37,230
so that there are 53 packages that are

00:33:35,790 --> 00:33:41,310
using BH :

00:33:37,230 --> 00:33:44,550
to build there's a guide if you want to

00:33:41,310 --> 00:33:48,300
package a go package there's the guys at

00:33:44,550 --> 00:33:54,000
alias from the team the package go team

00:33:48,300 --> 00:33:56,070
and package Co kit contains all the team

00:33:54,000 --> 00:33:59,970
and team packages which are most of the

00:33:56,070 --> 00:34:02,160
53 packages are maintained by the go

00:33:59,970 --> 00:34:04,950
team and if you want to package go

00:34:02,160 --> 00:34:07,950
packages I invite you to also be part of

00:34:04,950 --> 00:34:13,500
the team make sense to do it together

00:34:07,950 --> 00:34:20,130
and not separate yeah so basically the

00:34:13,500 --> 00:34:22,710
viennese ready to go and yeah that's

00:34:20,130 --> 00:34:25,100
basically it and please have more

00:34:22,710 --> 00:34:25,100
questions

00:34:29,119 --> 00:34:34,379
our algo binary is still statically

00:34:32,010 --> 00:34:35,790
linked yes is that not a problem for

00:34:34,379 --> 00:34:40,679
debian especially in the realm of

00:34:35,790 --> 00:34:42,240
security support it's I mean it's one of

00:34:40,679 --> 00:34:43,559
the main reasons I have not touched go

00:34:42,240 --> 00:34:46,319
as it does not seem ready for a

00:34:43,559 --> 00:34:48,690
deployment that is not Google style we

00:34:46,319 --> 00:34:50,220
build everything every time we ship it

00:34:48,690 --> 00:34:52,050
seems like goes not suitable for

00:34:50,220 --> 00:34:56,419
distributions at the present moment in

00:34:52,050 --> 00:34:56,419
time yes I agree

00:34:56,569 --> 00:35:04,859
III don't have a better answer I agree

00:34:59,550 --> 00:35:08,579
with you our latest question about

00:35:04,859 --> 00:35:12,109
versioning I mean all libraries are

00:35:08,579 --> 00:35:16,859
usually in version so we pick

00:35:12,109 --> 00:35:21,510
circulation at London on it stay as in

00:35:16,859 --> 00:35:25,410
the beyond I'm sorry I don't understand

00:35:21,510 --> 00:35:30,869
IIIi mean because in go

00:35:25,410 --> 00:35:33,869
you don't version you're like boys it's

00:35:30,869 --> 00:35:36,920
an so problem but again because we we

00:35:33,869 --> 00:35:40,140
put get a shine as a package person and

00:35:36,920 --> 00:35:42,780
it's difficult to know if the version is

00:35:40,140 --> 00:35:44,670
up-to-date if we pick a good version or

00:35:42,780 --> 00:35:47,910
not a good version and maybe there is a

00:35:44,670 --> 00:35:51,049
bug we don't already know is that

00:35:47,910 --> 00:35:55,200
something that will change in the future

00:35:51,049 --> 00:35:59,030
and then many many many projects are

00:35:55,200 --> 00:36:02,309
using bondo India because of that yes so

00:35:59,030 --> 00:36:04,890
maybe a better solution would be to say

00:36:02,309 --> 00:36:07,470
it was a bad idea to tell everybody that

00:36:04,890 --> 00:36:10,920
you don't need to put a version number

00:36:07,470 --> 00:36:17,700
on library please use version number

00:36:10,920 --> 00:36:20,030
instead well yes but you need to

00:36:17,700 --> 00:36:25,260
convince people to use a version number

00:36:20,030 --> 00:36:27,299
yeah yeah yeah but I mean like yeah I I

00:36:25,260 --> 00:36:28,829
agree it could be a good idea to have

00:36:27,299 --> 00:36:30,540
version number so go has a version

00:36:28,829 --> 00:36:32,670
number it's the libraries that don't

00:36:30,540 --> 00:36:35,670
have a version number or not all of them

00:36:32,670 --> 00:36:38,099
but some of them and and I agree it's

00:36:35,670 --> 00:36:39,750
not a good idea because it's hard to

00:36:38,099 --> 00:36:42,620
just go with the

00:36:39,750 --> 00:36:45,500
it date or commit version or whatever

00:36:42,620 --> 00:36:48,150
depending on whoever uses what

00:36:45,500 --> 00:36:52,290
but yes you need to convince people that

00:36:48,150 --> 00:36:55,790
it's a good idea to use persons and I

00:36:52,290 --> 00:36:55,790
don't think I have the power to do that

00:36:58,130 --> 00:37:10,140
other questions we have five more

00:37:03,120 --> 00:37:11,250
minutes for questions not actually a

00:37:10,140 --> 00:37:15,000
question just a comment

00:37:11,250 --> 00:37:17,640
the in go 1.5 they do have shared

00:37:15,000 --> 00:37:21,480
libraries now so the very latest version

00:37:17,640 --> 00:37:23,130
of go has shared libraries okay it's

00:37:21,480 --> 00:37:26,000
possible to you know just out if we

00:37:23,130 --> 00:37:26,000
compile everything anymore

00:37:33,940 --> 00:37:42,900
no more questions alright then I guess

00:37:37,720 --> 00:37:42,900

YouTube URL: https://www.youtube.com/watch?v=YNBYU7e8xOI


