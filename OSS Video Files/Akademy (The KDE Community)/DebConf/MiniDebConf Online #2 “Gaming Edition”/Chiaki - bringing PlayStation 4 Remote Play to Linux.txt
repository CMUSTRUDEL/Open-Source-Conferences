Title: Chiaki - bringing PlayStation 4 Remote Play to Linux
Publication date: 2020-11-24
Playlist: MiniDebConf Online #2 “Gaming Edition”
Description: 
	by Florian Märkl

At: MiniDebConf Online #2 "Gaming Edition"
https://mdco2.mini.debconf.org/talks/9-chiaki-bringing-playstation-4-remote-play-to-linux/

Chiaki is an open source implementation of Sony's PlayStation 4 Remote Play, which is a game streaming protocol that allows the PlayStation 4 to be played remotely over the network. The talk will contain a brief overview of the protocol and the reverse engineering process that was used to obtain all of this information, as well as a few short demos of Chiaki in action.
It is intended for anyone interested in the technical details of low-latency game streaming or reverse engineering closed source applications.

Room: Main
Scheduled start: 2020-11-22 15:00:00
Captions: 
	                              hello everybody and welcome to our next                               album                               shiaki bringing playstation                                        play to linux with                               florian merkel let me introduce himself                               quickly he's a rather too and                               future maintainer out of jackie and he's                               still in computer science at the                               technical university of munstern so                                please enjoy his talk                                so welcome to my talk about chiaki which                                is an open source                                playstation                                                             little bit about me                                my name is florian merkel and i study                                computer science at the technical                                university of munich                                and i'm also a maintainer of the radar                                  reverse engineering framework and its                                official gui called cutter                                this is also my twitter handle and my                                github account if you're interested                                so first let's talk about what                                remoteplay even is                                and instead of explaining it in detail                                i'm just going to show you how it works                                so here i have a virtual machine running                                windows                                and i can start the official playstation                                remote play client                                and i also have my playstation                                  right here which is only connected over                                the network to this pc so now i can                                connect to it and what this will allow                                me to do                                is to simply control and play with the                                playstation over the network                                just like normal i could also connect a                                controller here and then play my games                                unfortunately these official clients are                                only available for a few platforms                                which do not include linux                                and they are also quite buggy and                                unreliable                                so the goal of chiaki is to re-implement                                this whole protocol that they use                                to stream the game from scratch and then                                port it to many other platforms                                now in order to be able to implement                                this protocol at all                                we first have to know how it works and                                luckily since                                we have this official client and this                                official client obviously has to work                                it must also contain all the information                                that is required for this protocol                                so what i did is i reverse engineered                                this client                                so let's take a look at what files it                                comes with                                so we have the main executable this is                                just a dotnet gui around the actual code                                and the actual protocol is implemented                                in this one dll here                                so to extract some information from it                                we need some kind of reverse engineering                                tool                                and for that i'm going to use cutter                                so i'm just going to open this file and                                cutter now                                i'm going to use some custom analysis                                because i want a bit less                                than the default analysis because i want                                to show                                a few manual steps later                                okay so it's finished analyzing                                now here we can see it has identified                                many                                different functions                                but just from this we can take a look at                                them                                but it's quite hard to actually know                                what's                                even relevant for us here                                so what we need is some kind of entry                                point                                where we can start analyzing the binary                                that we know that we are interested in                                and from that we can then                                explore the code around it and see how                                this all comes together                                now there are many different ways to                                find such an interesting point                                and i'm going to show you one particular                                so this specific file is implemented in                                c                                plus and in c plus if you have a                                virtual method in a class which means a                                method that could be overwritten by                                 a subclass then you need some kind of                                 information at runtime to decide                                 to which address to actually jump to                                 when calling this method                                 and for this c plus can generate                                 so called b tables and these are just                                 tables that contain a list of the                                 function                                 addresses of a specific class and                                 these v tables are also present in this                                 binary                                 and we can search for them automatically                                 by doing some                                 heuristic search in cutter you can do                                 this by just typing                                 av into the console so we have found                                 quite a lot of v tables and each of                                 these b tables                                 usually will correspond to a class                                 now in addition to these v tables there                                 is also more information                                 because in z plus if you have if you use                                 the dynamic cost                                 then you need more information about the                                 class hierarchy                                 what the base classes of a certain class                                 are and so                                 on and this is called this is stored in                                 so-called rtdi structures                                 and these are located just before                                 each v table so if we go to this v table                                 here                                 then here starts the v table this is a                                 function address and this is a function                                 address and so on                                 and just before it we have a pointer                                 which                                 goes to the rtti information and this                                 if this is present this is quite nice                                 because it gives us a lot of information                                 about the class hierarchy which we can                                 use                                 to analyze the code so in qatar we can                                 use the avr a                                 command which again does this v table                                 search and then tries to find                                 rtti information at e                                        okay so it has found quite a lot                                 and we can see that                                 we even get these nice readable class                                 names so these are the class names that                                 were                                 originally used in the cbos bus code                                 and we can now use this information to                                 actually recreate a big part of the                                 class hierarchy                                 so here we have the classes widget which                                 is currently empty and we can type avrr                                 and this will again search for all this                                 rtti information                                 and then make a nice list of all the                                 classes and                                 the methods that it could find                                 okay so let's go through this list                                 here we can find an interesting class                                 that's called rpcryptas                                 so we can assume that this class might                                 have something to do with                                 encryption if we take a look at this                                 we can see it has formed the v table and                                 it has found                                 one virtual function now                                 not all functions uh not all the methods                                 have to be virtual so it only finds the                                 virtual ones                                 and there may be there may be many more                                 so now let's try to find some more                                 methods of this class                                 first of all i want to find the                                 constructor of the class                                 constructors of classes that have                                 virtual methods                                 usually need to take the v table and                                 store it inside the class object                                 so if we go to the v table right here                                 there's the v table located then we can                                 search for places in the code where this                                 address is used in some way so let's do                                 this                                 by using the xrefs widget and here are                                 three locations where this is used let's                                 take a look at the first one                                 okay this is a function and we can                                 already see                                 here is a move instruction which puts                                 this we table address                                 at some other location and then it calls                                 some other functions let's see what this                                 is                                 okay this is apparently allocating                                 something                                 in fact this is the new function of c                                 plus so it's allocating more stuff so                                 it's we can we can assume that this is                                 probably the                                 um constructor of the rp crypt aes class                                 so let's add this as a method here                                 i'm just calling it the same name as the                                 class                                 so it's the constructor and then i'm                                 going to also                                 rename this function here                                 like this                                 and now that we have this we can take a                                 look at                                 places in the code where this function                                 is called so where                                 objects of this type are created                                 so let's do this now there are quite a                                 lot                                 let's take a look at for example this                                 one                                 so here we are now in another function                                 that                                 uses this rpcrypt aes class let's take a                                 look at the graph here                                 okay so what we have to know is that                                 due to how it's defined in the calling                                 convention that is used here                                 when calling some kind of method                                 the ecx register is used to transmit                                 the so called this pointer so the                                 pointer that points to the                                 actual object that this method is called                                 on                                 so here it's ecx where the                                 constructor is called on and the                                 constructor also returns                                 the address of the object so                                 this is returning ex and in ebx we then                                 move this pointer so in ebay x we now                                 have our                                 rpcrypt aes object now let's take a look                                 at                                 what is then done with this so it goes                                 through here                                 and then we have                                 some mem set also due to the calling                                 convention                                 if we have a call and we have pushes                                 before it                                 these pushes to the stack show us the                                 arguments of the function in reverse                                 order so                                 yeah x here is the first argument zero                                 is the second argument and edi is the                                 third argument                                 so this is a mem set which sets                                 the address at eax in this case which is                                 esi plus                                    to                                                  this esi plus                                                            of buffer                                 and edi is the size of this buffer                                 okay next we have this function here                                 if we take a closer look at it it's                                 doing some kind of mem copy                                 and in fact this is simply just copy as                                 we could find this out if we just take a                                 look at this more closely                                 okay let's go back                                 and here we have a mem copy which goes                                 into                                 this buffer again and it also uses this                                 edi size here                                 and then further down we can see again                                 that our ebx                                 that we have identified before is                                 pointing to our crypt object                                 is then moved into ecx here                                 and then this function is called so this                                 function is probably                                 another method of the rpcrypt as                                 class and if we take a look at the other                                 parameters                                 we can see that the second parameter                                 is again this buffer that we have mem                                 copied and memsat before                                 and the next parameter is this ei which                                 is                                 again the size of this buffer so this                                 looks quite interesting we have a class                                 that                                 apparently judging from the name does                                 some encryption stuff                                 and we have a method of it that                                 takes some kind of buffer and a size                                 so now we want to find out what is                                 actually what this                                 method is actually called with at                                 runtime                                 and we want to see the contents of the                                 buffer before                                 and after this function call                                 so what we're going to do now is we're                                 going to use a tool called                                 frida which lets us inject our own                                 javascript scripts into a running                                 process                                 on some other machine and then we can                                 have callbacks                                 at any part in the code and we can read                                 and write memory                                 and print out things and do whatever we                                 want                                 so let's go over here and i want to                                 write a script that we're going to                                 inject                                 into the real remote play process                                 so make a new script here at first we                                 need to know where this remote play dll                                 is located in memory                                 for this we're going to get this address                                 from frida                                 like this and next we can attach some                                 callbacks                                 to this function that we're interested                                 in which is this one                                 so what we need is we need the address                                 of the function                                 so we can write interceptor                                 and we want to have this address on                                 this base so we use this base and we add                                 our address to it                                 but only the lower bits                                 and then we give it an object which is                                 going to contain our callbacks                                 so we have one callback which is on                                 enter                                 and this is a function that just gets                                 all the arguments                                 of the function and on leave                                 which gets the return value                                 okay so as we have identified before                                 we are interested in the second argument                                 and the third argument where the second                                 is the buffer and the third argument is                                 the size of the buffer                                 so first let's um save these two values                                 inside our object so we can also use it                                 in the on leaf callback                                 so we can just pull these arguments like                                 this                                 and for the second argument we convert                                 it to an integer this isn't really an                                 assigned integer in reality but in this                                 case it doesn't matter                                 and then we can read the contents of                                 this buffer                                 so we just do the buff george read                                 write array of                                 this buff size next we want to print it                                 so we just do console.log                                 for some output and console                                 with the contents                                 so this will be printed before the                                 function is executed                                 and then we also want to print it after                                 the function was executed                                 so we do the same here with after                                 and then we just add                                 another new line to separate this nicely                                 and at the very end we just want to add                                 some more                                 info so we can see that our script is                                 injected correctly so let's bring back                                 the virtual machine here                                 on this machine i can now start the                                 frida server which will                                 which will let me use freida remotely                                 from my host here so this can run in the                                 background                                 and i also want to have a wireshark                                 running so we can see the actual                                 network data that is transmitted from                                 the client                                 so i'll use this filter here and then i                                 can start                                 the remote play client again                                 okay now everything is set up so i can                                 use freedom                                 with the ip address of my vm here                                 and the name of the executable                                 and also the script that i want to                                 inject                                 okay we see the output here which we                                 have written here                                 so apparently it has injected itself                                 into the process                                 and now i'm just going to um                                 make a connection to the ps                                            me why this happens it's apparently a                                 bug of the                                 remote play client                                 okay we're already getting some stuff                                 i'm going to cancel this real quick here                                 we don't need this to run anymore                                 so let's take a look at what we get                                 so let's in particular                                 take a look at this packet here                                 this looks a lot like http http                                 and if we take a look at the contents                                 here we have some                                 stuff encoded in base                                   so let's check what this for example                                 means                                 so i'm just going to copy the value here                                 and then i'm going to convert this from                                 base                                             um as a hexa                                 and we get ae                                                  okay let's take a look if we can find                                 this                                 yep we have found it here so this is the                                 result that this                                 function that we just found in cutter                                 has produced                                 from this data and here it says                                 windows                                                            um really a function that encrypts data                                 and we can now print all the unencrypted                                 data                                 that is otherwise completely unreadable                                 in wireshark                                 so this is one example how you can                                 extract information from such a binary                                 there are many more techniques                                 to use usually you will do a combination                                 of                                 static analysis how we have seen it in                                 cutter                                 and dynamic analysis which can be done                                 as hooking like here in frida or using a                                 manual debugger                                 like x                                                                   see a little overview of                                 how the complete protocol works so when                                 a                                 remote playstation is started it first                                 makes a connection on tcp                                 port                                      and here it does some kind of handshake                                 and part of this handshake is the packet                                 we have just seen that looks like htp                                 and then going on on this channel we                                 have a few things                                 like a heartbeat and as soon as this                                 initial handshake on tcp is done another                                 connection starts                                 which runs on udp                                 and this one is the actual more                                 interesting one we have again                                 another handshake that is performed here                                 and on this channel we then have all the                                 interesting stuff like video audio the                                 input                                 and so on now what's really interesting                                 about these two different channels is                                 that they are also very differently                                 implemented                                 and the most likely explanation for that                                 is that                                 the actual streaming part was not                                 implemented by sony                                 but by another company called gaikai                                 which sony bought a few years back                                 and what sony then did is just take the                                 code here                                 and they built their own playstation                                   specific                                 stuff around it like entering the sleep                                 mode and so on                                 so in jiaki this tcp channel is called                                 control                                 and the real stream channel is called                                 tachyon                                 due to some strings that can be found in                                 the binary                                 so this takion protocol is actually a                                 very interesting one                                 if you take a look at how the packets                                 are laid out                                 you might find out that it looks very                                 similar to                                 another protocol which is openly                                 standardized                                 and it's called sctp this is a protocol                                 that runs on transport layer so it's                                 something that                                 you could run instead of tcp or udp                                 but what they did is they took a lot of                                 the                                 things that are present in this http                                 protocol                                 and put them on top of udp and added                                 some custom stuff to it                                 and one important property of both this                                 sctp and tarkin protocol                                 is that you can have both reliable and                                 unreliable transport                                 reliable means something like tcp where                                 packets that are sent                                 are also guaranteed to be received and                                 unreliable is something like udp                                 where you just send out packets and they                                 may or may not be received and they may                                 also be received in any order                                 for reliable transport you have these                                 data frames which also contain a                                 sequence number                                 and the sequence number is then used to                                 reorder the packets if necessary on the                                 client                                 and there's also these data                                 acknowledgement frames                                 so the server can know when a client has                                 received a frame                                 so it doesn't have to resend it anymore                                 and then there's also unreliable                                 transport which is used for                                 like the input video and audio frames                                 where not necessarily every single                                 package                                 needs to be received in order for the                                 stream to work so the entire protocol is                                 quite large and complex                                 but we're going to take a look at one                                 specific feature of it                                 that makes it special for game streaming                                 and that is how video is transmitted                                 so this line up here displays the                                 different frames that the console                                 renders                                 and it encodes them in h                                    and it does that by at the start of the                                 stream                                 creating one single keyframe and then                                 for every other frame                                 it only creates these delta frames which                                 only encode                                 the difference between this frame and                                 this frame                                 so let's see how such a frame would be                                 transmitted from the                                 console to the client so at first the                                 console has                                 this raw ht                                                            up into                                 a number of smaller packets                                 and in addition to these packets which                                 are just um                                 directly the h                                    it also generates more additional                                 packets                                 by applying a technique called fec or                                 forward error correction                                 and we will see in a minute what this is                                 exactly for                                 but for now it just uh sends each of                                 these packets                                 through the document protocol using an                                 unreliable transport so it might happen                                 that one or more of these packets just                                 get lost in the network                                 so here we have received four of these                                 packets and now the fse becomes                                 important                                 because now as soon as we have received                                 a certain number of these packets                                 in this case they are four we can                                 successfully                                 reconstruct the original h                                               it                                 and it does not matter which ones of                                 these frames we have received so it                                 could be                                 just the four original ones or a                                 combination any combination of these                                 now the other case of course is that we                                 don't receive enough packets to                                 reconstruct it                                 so here we have just three so because we                                 can't                                 reconstruct the original frame we would                                 get a glitch                                 in our video and the problem now is that                                 because the console will always only                                 send these delta frames                                 this glitch would then always propagate                                 forward and would never correct itself                                 anymore                                 so what the client does in this case is                                 it                                 sends the information that it has                                 received a corrupted frame                                 to the server and it does that not                                 through an unreliable channel                                 but through a reliable one so it ensures                                 that the server has received the                                 information that                                 we have a correct frame here and what                                 the server then can do                                 is it can generate another keyframe                                 which is transmitted                                 and as soon as the client has received                                 this the glitch will be corrected again                                 and this approach is one of the key                                 differences that differentiates this                                 protocol from something                                 that you would normally use to stream                                 from twitch or youtube for example                                 because there a few seconds of delay                                 aren't really a problem but you don't                                 want to have glitches in your video at                                 all                                 but here we need to have as low latency                                 as possible                                 otherwise we can't play at all and we                                 achieved this by having the compromise                                 that we might get                                 small glitches in our video from time to                                 time                                 so that was a lot of theory now let's                                 take a look at some demos with chiaki                                 so i'll start chiaki here and this is                                 the main window                                 it shows me the consoles that i've                                 manually registered and the ones that                                 are currently                                 available on my network which it                                 automatically detects                                 so i can double click it to connect and                                 this is the screen of my ps                                  let's go into a game and i have the                                 gamepad connected to the pc right now                                 and i can play it                                 just like on a real console you can also                                 go into full screen mode                                 and this is currently running at                                      with                                                                     you can also get                                                                       so here in this game i can pick up this                                 guitar                                 and i can select a chord                                 with left stick here                                 and if i have selected one i can use the                                 touchpad to pick the strings                                 and if you look on youtube you can find                                 videos of people who actually                                 played real songs with this which is                                 possible                                 but i personally am too lazy for that so                                 instead of doing that i use chiaki as a                                 c library                                 which you can do what you can do because                                 it exposes                                 everything for streaming and control and                                 so on                                 in a public see api and i wrote this                                 little program                                 so what this does is it creates a new                                 streaming session                                 with some connection settings which                                 contains like the                                 remote ip address and stuff it registers                                 some callbacks for getting back the                                 video and some events                                 and in parallel to the session running                                 it also runs a thread that will then                                 modify the controller state                                 automatically and send it to the console                                 so if we run this program now                                 we can see that she now plays the guitar                                 automatically                                 and this is all done just by controlling                                 the controller through the remote player                                 protocol and getting back the video here                                 [Music]                                 so that was a short introduction to                                 chiaki and its background                                 if you want to try it out yourself you                                 can just go to this url                                 the bot i've just shown is also                                 available on github if you want to play                                 around with it                                 and have fun diving now                                 okay so florian thanks a lot                                 this wonderful talk it was really                                 interesting                                 and now let's see if we have some                                 questions                                 okay so we'll check it likely walk on                                 playstation                                   too so um right now i can't make any                                 guarantees                                 but from what i can tell uh it seems                                 very                                 plausible so yes very likely                                 um but no eta                                 okay we have another one                                 have you thought about extending it more                                 to code bots                                 for games um                                 not for myself um basically i mean you                                 have seen how you can                                 use it to make a bot um so if you want                                 you can pick up the                                 the example there um i'm personally not                                 that much interested in writing bots                                 for games um so that's something that's                                 up to the community i would say                                 but it's definitely possible if you want                                 to make something like that                                 okay did you have any communication with                                 sony about the                                 work you are doing um                                 not directly they interestingly they did                                 send me a job offer                                 over linkedin that was specifically to                                 game streaming so i think they are aware                                 of what i'm doing                                 but it was kind of also kind of                                 generically formulated so                                 nothing came out of that                                 okay the next one                                 since when are you working on shacky are                                 you the only developer currently                                 um i've started reversing                                 this thing i think                                 around the end of                                                   about                                 one year of reversing on and off                                 and um i think                                 around september                                                        first version what                                 that worked                                 so i'm the uh only main developer i                                 would say                                 but there's a few people who also helped                                 me a lot                                 in reversing                                 shout out to florian and                                 sven at this point                                 and there are also a few people one who                                 made a nintendo switch port for example                                 and a few others who made some nice                                 pull requests                                 great is it possible to run a game while                                 another person is running another on the                                 actual                                 ps                                                      running one game while the ps                                  so basically running two games at the                                 same time on the ps                                       this is absolutely not possible                                 of course because you don't have enough                                 horsepower to run two games at the same                                 time also the                                 streaming it's really streaming exactly                                 what you see on the ps                                  so you just get one to one uh that is                                 what is output                                 on the on the display                                 but overall um the the remote play                                 protocol kind of works like a controller                                 attached to the                                 ps                                                                       example                                 some co-op game that will require two                                 controllers then in theory i think you                                 could                                 connect one controller to the ps                                  directly so one person will play on the                                 tv and the other person                                 could basically use remote play                                 somewhere else                                 but i think they already                                 have built in some feature like that                                 into the psn                                 where you can stream um with another                                 person on their ps                                  okay what was your motivation for                                 writing                                 quota was it specifically to reverse                                 engineer                                 this or was it a pre-existing project of                                 yours                                 i did not write qatar i'm just one of                                 the                                 main developers of it right now so                                 basically radar                                                   i don't know                                                             came to the project                                 around                                              um because i was starting out doing a                                 bit of robust engineering                                 and i was looking around for                                 disassemblers and there's of course the                                 infamous ida pro but that one costs as                                 much as a                                 car and i found out about                                 radar                                                                   what i wanted                                 and it's a very unix friendly system                                 but what was missing was a nice gui                                 which can sometimes                                 be beneficial depending on what your                                 workflow is                                 and then yaito as it was called                                 back then was released by hugo teso                                 and this in the end became qatar and i                                 basically                                 started um contributing to iaito                                 at the time that it was first released                                 and then i just got it off with the                                 project and                                 still continue to to work on it                                 can you talk about how you extend the                                 quality beyond the official app                                 do you introduce better with raid                                 settings beyond the official app                                 um yes i have this bitrate setting                                 in there but i'm not sure if it really                                 changes anything                                 so it's just a value that is sent to the                                 ps                                  and then the ps                                                        to send in the end                                 so you're limited of course in the sense                                 um to to what the ps                                                um i think the main benefit of                                 chiaki is simply that it's portable you                                 can use                                 um any controller that you like if you                                 just um                                 adjust the code over whatever uh                                 also there's a as already said the                                 switch version                                 a nice android version and um                                 there is there's also the issue with the                                 original app that if you want to                                 connect over the internet um then you                                 have to go                                 through the psn and for me this uh never                                 worked                                 uh not a single time so um with jackie                                 you can just um                                 set the manual ip that you have publicly                                 and connect directly                                 wonderful on which versions of db and                                 chatty works currently                                 um it should work in                                 theory pretty much everywhere maybe the                                 dependencies                                 aren't uh available or you have to                                 install a new                                 cmac version or something it's packaged                                 right now i think on uh                                 bullseye and sit                                 so there you can you can install it                                 directly otherwise you have to build                                 front source and                                 try to try to match the dependencies by                                 yourself                                 but there's no real thing that prevents                                 it from running anywhere                                 there is a variant package already for                                 bullseye                                 yes ah amazing                                 okay let's see if we have more                                 do you need to be on the last                                 playstation                                                 checking um no                                 i only have one ps                                                       on the latest firmware so                                 that is the only one that's really                                 guaranteed to be                                 supported um but i know that                                 some people are running it on something                                 like                                         something the protocol did change a bit                                 over time but i'm trying to keep it as                                 backwards compatible as possible if it                                 doesn't                                 any any major                                 issues on the project but of course it's                                 always a bit of an issue                                 if you don't have the hardware to test                                 it so it's not guaranteed to work but                                 yeah it should it should still work                                 great okay                                 let's see if we have more questions                                 well attempts these are all the                                 questions uh                                 would you like to add something else                                 before ending the talk                                 um nope not released                                 great thanks a lot florian for your nice                                 talk                                 yeah thanks for having me
YouTube URL: https://www.youtube.com/watch?v=4I9jHjjgkSA


