Title: Unikernel
Publication date: 2020-10-06
Playlist: DevConfUS 2020
Description: 
	Speaker: Ali Raza

Unikernels are small, lightweight, single address space operating systems with the kernel included as a library within the application. Because unikernels run a single application, there is no sharing or competition for resources among different applications, improving performance and security. Unikernels have thus far seen limited production deployment. This project aims to turn the Linux kernel into a unikernel with the following characteristics: 1) easily compiled for any application, 2) uses battle-tested, production Linux and glibc code, 3) allows the entire upstream Linux developer community to maintain and develop the code, and 4) provides applications normally running vanilla Linux to benefit from unikernel performance and security advantages. The paper Unikernels: The Next Stage of Linuxâ€™s Dominance was presented at HotOS XVII, The 17th Workshop on Hot Topics in Operating Systems, 2019.
Captions: 
	00:00:00,320 --> 00:00:04,880
hi all uh i'm ali raza and

00:00:03,120 --> 00:00:07,359
um you can also see tommy who's my

00:00:04,880 --> 00:00:09,360
co-presenter today

00:00:07,359 --> 00:00:11,920
so langdon you're here london why should

00:00:09,360 --> 00:00:11,920
we just start

00:00:12,400 --> 00:00:17,440
self-motivated okay yes so uh i am a phd

00:00:15,839 --> 00:00:19,199
student at boston university working

00:00:17,440 --> 00:00:21,119
with professor oran krieger and i am

00:00:19,199 --> 00:00:22,720
also a research intern at red hat

00:00:21,119 --> 00:00:26,400
working with some very smart people

00:00:22,720 --> 00:00:26,400
whose names you can see on the screen

00:00:26,560 --> 00:00:32,559
and i'm in the wrong window okay so

00:00:30,080 --> 00:00:34,160
so the structure of today's general

00:00:32,559 --> 00:00:35,840
purpose operating systems is not

00:00:34,160 --> 00:00:38,239
suitable for

00:00:35,840 --> 00:00:38,879
a number of today's key use cases in the

00:00:38,239 --> 00:00:40,559
cloud

00:00:38,879 --> 00:00:42,480
uh client workloads are typically run

00:00:40,559 --> 00:00:44,000
inside dedicated virtual machines

00:00:42,480 --> 00:00:45,680
a general purpose operating system

00:00:44,000 --> 00:00:47,440
designed to multiplex resources among

00:00:45,680 --> 00:00:49,280
many users and processes

00:00:47,440 --> 00:00:51,280
is instead being replicated across many

00:00:49,280 --> 00:00:51,840
single user often single process virtual

00:00:51,280 --> 00:00:53,600
machines

00:00:51,840 --> 00:00:54,879
so that's a general purpose operating

00:00:53,600 --> 00:00:56,000
system running a single application

00:00:54,879 --> 00:00:58,559
workload

00:00:56,000 --> 00:01:00,079
and if anybody has a question please uh

00:00:58,559 --> 00:01:02,160
ask me i'm not actually looking at the

00:01:00,079 --> 00:01:05,199
chat so tell me if you can do that

00:01:02,160 --> 00:01:05,760
sure well there also uh so uh to

00:01:05,199 --> 00:01:07,040
continue

00:01:05,760 --> 00:01:09,600
applications that require high

00:01:07,040 --> 00:01:10,640
performance i o use frameworks like dpdk

00:01:09,600 --> 00:01:12,560
and spdk

00:01:10,640 --> 00:01:14,400
to bypass the kernel and gain unimpeded

00:01:12,560 --> 00:01:16,159
access to hardware devices

00:01:14,400 --> 00:01:17,439
so the general purpose operating system

00:01:16,159 --> 00:01:19,200
is actually coming in the way of

00:01:17,439 --> 00:01:21,040
performance sensitive workloads

00:01:19,200 --> 00:01:22,720
clearly uh for some use cases the

00:01:21,040 --> 00:01:23,439
general purpose operating system is too

00:01:22,720 --> 00:01:24,880
general

00:01:23,439 --> 00:01:26,720
and there's a need for specialized

00:01:24,880 --> 00:01:28,799
operating system here which are

00:01:26,720 --> 00:01:30,479
optimized for each specific workload

00:01:28,799 --> 00:01:32,560
in response to these questions there has

00:01:30,479 --> 00:01:34,560
been a resurgence of research exploring

00:01:32,560 --> 00:01:38,400
the idea of library operating systems

00:01:34,560 --> 00:01:40,640
or unicodes in a unikernel

00:01:38,400 --> 00:01:42,399
an application is statically linked with

00:01:40,640 --> 00:01:43,759
a specialized kernel and deployed

00:01:42,399 --> 00:01:45,759
directly on hardware

00:01:43,759 --> 00:01:47,439
it can be virtual or physical the

00:01:45,759 --> 00:01:48,399
application runs in a single address

00:01:47,439 --> 00:01:50,799
space with the kernel

00:01:48,399 --> 00:01:53,439
and other user libraries there is no

00:01:50,799 --> 00:01:54,799
separation between the

00:01:53,439 --> 00:01:56,960
operating system and application

00:01:54,799 --> 00:01:57,280
privilege levels unicorns have shown to

00:01:56,960 --> 00:01:59,040
be

00:01:57,280 --> 00:02:00,479
uh small and lightweight as compared to

00:01:59,040 --> 00:02:02,000
normal kernels and

00:02:00,479 --> 00:02:04,240
they allow application specific

00:02:02,000 --> 00:02:06,479
optimizations and there are actually

00:02:04,240 --> 00:02:09,119
many unicorns already available for

00:02:06,479 --> 00:02:11,440
example rt include os mirage with

00:02:09,119 --> 00:02:12,720
os and many others when compared with

00:02:11,440 --> 00:02:14,480
linux these unit kernels have

00:02:12,720 --> 00:02:15,200
demonstrated significant advantages in

00:02:14,480 --> 00:02:18,080
both

00:02:15,200 --> 00:02:18,720
in in not both but in actually all of

00:02:18,080 --> 00:02:20,480
these

00:02:18,720 --> 00:02:22,879
for example boot time security resource

00:02:20,480 --> 00:02:25,280
utilization and i o performance

00:02:22,879 --> 00:02:26,400
for example with ebrt you get more than

00:02:25,280 --> 00:02:28,080
twice improved

00:02:26,400 --> 00:02:30,239
memcached throughput as compared to

00:02:28,080 --> 00:02:32,239
linux and link's entire website which

00:02:30,239 --> 00:02:36,959
runs on link

00:02:32,239 --> 00:02:38,640
unicorn takes only 25 mb of memory

00:02:36,959 --> 00:02:40,640
unfortunately despite all these

00:02:38,640 --> 00:02:42,560
tremendous advantages unicorns have not

00:02:40,640 --> 00:02:44,319
achieved widespread adoption

00:02:42,560 --> 00:02:46,000
one might find the reason for this in

00:02:44,319 --> 00:02:48,319
how these unit kernels are developed for

00:02:46,000 --> 00:02:49,840
example some are developed from scratch

00:02:48,319 --> 00:02:51,840
and some are developed by forking an

00:02:49,840 --> 00:02:53,680
already existing code base

00:02:51,840 --> 00:02:55,840
and stripping it down to create a small

00:02:53,680 --> 00:02:57,840
lightweight specialized kernel

00:02:55,840 --> 00:02:58,959
uh both of these approaches result in a

00:02:57,840 --> 00:03:01,360
separate code base

00:02:58,959 --> 00:03:02,080
and then that needs to be maintained

00:03:01,360 --> 00:03:04,239
this

00:03:02,080 --> 00:03:05,360
obviously this new code base is not as

00:03:04,239 --> 00:03:07,519
well tested

00:03:05,360 --> 00:03:08,800
as uh something like linux these

00:03:07,519 --> 00:03:10,640
unicoils don't have sufficient

00:03:08,800 --> 00:03:12,319
functionality to run a broad class of

00:03:10,640 --> 00:03:14,000
applications that are mostly limited to

00:03:12,319 --> 00:03:15,680
only virtualized environments

00:03:14,000 --> 00:03:17,440
they do not support accelerators for

00:03:15,680 --> 00:03:20,159
example gpus and fpgas

00:03:17,440 --> 00:03:21,599
that are fundamental for modern high

00:03:20,159 --> 00:03:24,000
performance applications

00:03:21,599 --> 00:03:25,040
and often only run a single processor

00:03:24,000 --> 00:03:27,599
core

00:03:25,040 --> 00:03:29,040
uh so you can say that uni kernels are

00:03:27,599 --> 00:03:30,720
just too niche

00:03:29,040 --> 00:03:33,280
and perhaps the most concerning reason

00:03:30,720 --> 00:03:35,280
is that no unicorn has attracted a large

00:03:33,280 --> 00:03:38,400
community of developers

00:03:35,280 --> 00:03:40,159
which makes it more difficult that

00:03:38,400 --> 00:03:42,959
and unlikely that these challenges will

00:03:40,159 --> 00:03:44,959
be addressed anytime soon

00:03:42,959 --> 00:03:46,879
so we asked ourselves a question can we

00:03:44,959 --> 00:03:48,239
do unit kernels differently

00:03:46,879 --> 00:03:50,640
would it be possible to create a

00:03:48,239 --> 00:03:52,560
unikernel out of linux which can then be

00:03:50,640 --> 00:03:54,400
upstreamed so that the whole community

00:03:52,560 --> 00:03:56,400
can work on it

00:03:54,400 --> 00:03:58,239
we were not sure if the changes required

00:03:56,400 --> 00:04:00,000
to turn linux into a unicode would be so

00:03:58,239 --> 00:04:03,360
extensive that it would be difficult

00:04:00,000 --> 00:04:06,239
to merge it upstream we were not sure

00:04:03,360 --> 00:04:07,920
that even if we were able to do that

00:04:06,239 --> 00:04:09,439
will the advantages that research unit

00:04:07,920 --> 00:04:10,239
kernels have demonstrated will we be

00:04:09,439 --> 00:04:13,680
able to get

00:04:10,239 --> 00:04:15,360
those those advantages

00:04:13,680 --> 00:04:16,959
and the biggest question of all the the

00:04:15,360 --> 00:04:18,320
most important question is it even

00:04:16,959 --> 00:04:18,799
possible we didn't know that so we

00:04:18,320 --> 00:04:22,400
started

00:04:18,799 --> 00:04:22,400
uh out on this research direction

00:04:22,479 --> 00:04:26,800
uh the main goal uh so i'll talk about

00:04:24,720 --> 00:04:27,520
uh uk and its different versions that

00:04:26,800 --> 00:04:29,600
have

00:04:27,520 --> 00:04:32,000
that we've created over the over the

00:04:29,600 --> 00:04:33,840
time we've been working on this

00:04:32,000 --> 00:04:35,680
uh the main goal of the first version

00:04:33,840 --> 00:04:36,960
was to get something running to see if

00:04:35,680 --> 00:04:38,800
the idea even worked

00:04:36,960 --> 00:04:40,320
we compiled the application code

00:04:38,800 --> 00:04:42,160
separately and then linked everything

00:04:40,320 --> 00:04:44,479
together in a kernel

00:04:42,160 --> 00:04:46,400
in the kernel linking stage so the final

00:04:44,479 --> 00:04:47,360
vm linux binary that we got was actually

00:04:46,400 --> 00:04:48,960
a unicorn

00:04:47,360 --> 00:04:50,880
we had to modify the kernel linker

00:04:48,960 --> 00:04:52,720
script to add sections which are not

00:04:50,880 --> 00:04:55,360
part of the linux

00:04:52,720 --> 00:04:56,000
code base traditionally but are

00:04:55,360 --> 00:04:57,680
important part

00:04:56,000 --> 00:04:59,919
of application binaries for example the

00:04:57,680 --> 00:05:01,520
thread local storage sections

00:04:59,919 --> 00:05:04,240
we also had to modify the boot up

00:05:01,520 --> 00:05:06,240
process a bit so that when the vm linux

00:05:04,240 --> 00:05:09,039
is loaded into memory those new sections

00:05:06,240 --> 00:05:09,039
are also loaded

00:05:09,280 --> 00:05:12,880
this might seem straightforward but it

00:05:11,440 --> 00:05:14,479
was anything but that

00:05:12,880 --> 00:05:16,000
mostly what you see on your screen was

00:05:14,479 --> 00:05:17,840
the state of the project

00:05:16,000 --> 00:05:19,680
uh we spent months trying to figure out

00:05:17,840 --> 00:05:21,600
these things investigating why things

00:05:19,680 --> 00:05:24,479
did not work and trying different

00:05:21,600 --> 00:05:25,840
fixes uh thankfully i had really good

00:05:24,479 --> 00:05:29,520
mentors and advisors

00:05:25,840 --> 00:05:32,560
and things just kept on rolling

00:05:29,520 --> 00:05:33,520
uh in order to get something functional

00:05:32,560 --> 00:05:35,440
we took the most

00:05:33,520 --> 00:05:36,880
straightforward approach we stopped the

00:05:35,440 --> 00:05:39,919
first executive

00:05:36,880 --> 00:05:41,360
call so user space was never created we

00:05:39,919 --> 00:05:42,479
called our application code directly

00:05:41,360 --> 00:05:44,320
here

00:05:42,479 --> 00:05:45,919
uh but we couldn't just run application

00:05:44,320 --> 00:05:48,320
code directly because we were still a k

00:05:45,919 --> 00:05:48,320
thread

00:05:48,479 --> 00:05:52,639
applications need glibc to do some

00:05:50,080 --> 00:05:54,560
initialization first for example

00:05:52,639 --> 00:05:56,400
the p thread struct should be placed

00:05:54,560 --> 00:05:59,440
right next to the thread local storage

00:05:56,400 --> 00:06:02,560
uh and the the threads

00:05:59,440 --> 00:06:05,199
fs register should be pointing at that

00:06:02,560 --> 00:06:06,560
all of these initializations like the

00:06:05,199 --> 00:06:08,080
one that i just described and many

00:06:06,560 --> 00:06:09,280
others can be found in the paper that

00:06:08,080 --> 00:06:11,360
you can see on your screen

00:06:09,280 --> 00:06:13,759
written by ulrich tripper who also wrote

00:06:11,360 --> 00:06:16,560
the nptel or the pthread library

00:06:13,759 --> 00:06:17,919
and is also a mentor on this project the

00:06:16,560 --> 00:06:18,960
funny thing about this project this

00:06:17,919 --> 00:06:21,280
paper is that

00:06:18,960 --> 00:06:22,400
i read it in order in in order to get

00:06:21,280 --> 00:06:23,919
these uh

00:06:22,400 --> 00:06:25,680
understand these initializations and get

00:06:23,919 --> 00:06:27,039
them to work i read this paper at least

00:06:25,680 --> 00:06:29,520
10 times

00:06:27,039 --> 00:06:30,960
uh and every time i learned something

00:06:29,520 --> 00:06:32,560
totally new which i had

00:06:30,960 --> 00:06:34,319
completely missed earlier so if so i

00:06:32,560 --> 00:06:37,840
suggest if you want to read this paper

00:06:34,319 --> 00:06:39,440
uh read it a few times uh

00:06:37,840 --> 00:06:41,280
before we could do glibc related

00:06:39,440 --> 00:06:42,880
initializations we had to modify the k

00:06:41,280 --> 00:06:43,440
thread to look more like an application

00:06:42,880 --> 00:06:45,759
thread

00:06:43,440 --> 00:06:46,800
this involved modifying the task struct

00:06:45,759 --> 00:06:48,880
uh the flags

00:06:46,800 --> 00:06:50,240
modifying the mm struct so that the

00:06:48,880 --> 00:06:52,720
thread could see the lower half of the

00:06:50,240 --> 00:06:55,759
address address space so that m map and

00:06:52,720 --> 00:06:55,759
break calls could work

00:06:58,720 --> 00:07:03,599
uh uh but sorry so on this

00:07:02,160 --> 00:07:05,840
very first thread we were still running

00:07:03,599 --> 00:07:06,400
on a kernel stack we realized this very

00:07:05,840 --> 00:07:08,160
early

00:07:06,400 --> 00:07:09,440
when we were starting when we started

00:07:08,160 --> 00:07:12,160
running out of stack

00:07:09,440 --> 00:07:13,599
uh so in order to not run out of stack

00:07:12,160 --> 00:07:15,599
on that first k thread

00:07:13,599 --> 00:07:17,199
we called p thread create very early so

00:07:15,599 --> 00:07:18,240
that we jumped onto a clean application

00:07:17,199 --> 00:07:20,240
stack and

00:07:18,240 --> 00:07:21,360
a clean new thread to run the

00:07:20,240 --> 00:07:23,919
application

00:07:21,360 --> 00:07:25,599
and it was it felt really good to see

00:07:23,919 --> 00:07:28,560
the first hello world on screen after

00:07:25,599 --> 00:07:31,199
almost a year of work

00:07:28,560 --> 00:07:32,639
in order to uh change the syscalls into

00:07:31,199 --> 00:07:33,360
function calls we took the simplest

00:07:32,639 --> 00:07:35,360
approach

00:07:33,360 --> 00:07:37,280
we created our own uk library which had

00:07:35,360 --> 00:07:38,880
stubs for all syscalls

00:07:37,280 --> 00:07:40,560
uh so instead of calling right the

00:07:38,880 --> 00:07:41,440
application would call ukl underscore

00:07:40,560 --> 00:07:44,319
right

00:07:41,440 --> 00:07:45,599
uh or actually glibc would call uk

00:07:44,319 --> 00:07:47,599
underscore right

00:07:45,599 --> 00:07:49,840
this stub would directly in then invoke

00:07:47,599 --> 00:07:51,520
the internal kernel functionality

00:07:49,840 --> 00:07:52,960
since we were missing all of the kernel

00:07:51,520 --> 00:07:56,000
entry and exit code

00:07:52,960 --> 00:07:57,840
uh but at that moment because

00:07:56,000 --> 00:07:59,680
this was still an idea and getting to a

00:07:57,840 --> 00:08:03,199
proof of concept was much more important

00:07:59,680 --> 00:08:03,199
we rolled with it

00:08:04,639 --> 00:08:08,560
we conducted experiments by running a

00:08:06,240 --> 00:08:10,240
simple tcp echo server as a unikernel

00:08:08,560 --> 00:08:12,000
to see how we were doing against normal

00:08:10,240 --> 00:08:14,080
linux and also

00:08:12,000 --> 00:08:15,759
got a vision paper accepted at hot os

00:08:14,080 --> 00:08:17,280
00:08:15,759 --> 00:08:19,120
as you can see on your screen the uk

00:08:17,280 --> 00:08:21,599
echo server had a better average and

00:08:19,120 --> 00:08:25,840
tail latency as compared to normal linux

00:08:21,599 --> 00:08:27,520
this uh this

00:08:25,840 --> 00:08:29,520
was not important because of the numbers

00:08:27,520 --> 00:08:30,000
that it showed it was important for us

00:08:29,520 --> 00:08:32,560
because

00:08:30,000 --> 00:08:33,360
a it showed that yes this is something

00:08:32,560 --> 00:08:35,039
that could be done

00:08:33,360 --> 00:08:36,959
and b yes there are some performance

00:08:35,039 --> 00:08:39,519
gains and we should keep exploring this

00:08:36,959 --> 00:08:42,399
idea further

00:08:39,519 --> 00:08:44,159
so that brings us to uh version two

00:08:42,399 --> 00:08:44,560
because now we knew that yes it could

00:08:44,159 --> 00:08:46,880
work

00:08:44,560 --> 00:08:48,320
so uh we started writing everything

00:08:46,880 --> 00:08:50,880
again uh and uh

00:08:48,320 --> 00:08:52,480
we started working on version two we

00:08:50,880 --> 00:08:55,040
needed the entire glibc and p

00:08:52,480 --> 00:08:56,320
threads library code to run if we wanted

00:08:55,040 --> 00:08:58,160
to learn anything more than the toy

00:08:56,320 --> 00:08:59,600
applications we had run earlier

00:08:58,160 --> 00:09:02,160
we went through the entire kernel entry

00:08:59,600 --> 00:09:04,000
and exit code and investigated

00:09:02,160 --> 00:09:05,760
what was necessary and needed to run in

00:09:04,000 --> 00:09:07,600
ukl we were still

00:09:05,760 --> 00:09:08,880
running the ukl stub library which i

00:09:07,600 --> 00:09:11,360
discussed earlier

00:09:08,880 --> 00:09:12,800
and so we added our own kernel entry and

00:09:11,360 --> 00:09:15,120
exit functions in each

00:09:12,800 --> 00:09:16,640
stub these functions called some parts

00:09:15,120 --> 00:09:19,920
of the actual kernel

00:09:16,640 --> 00:09:23,040
code for entry and exit but we could not

00:09:19,920 --> 00:09:25,600
just use the entire entrant exit code

00:09:23,040 --> 00:09:28,240
as it is because that could assume that

00:09:25,600 --> 00:09:30,080
the registers were already on the stack

00:09:28,240 --> 00:09:31,440
and we did not have that setup and in

00:09:30,080 --> 00:09:33,920
order to get that to work

00:09:31,440 --> 00:09:36,080
we would have to do major changes in the

00:09:33,920 --> 00:09:38,240
way that we were doing things

00:09:36,080 --> 00:09:40,399
and at that point we were changing glibc

00:09:38,240 --> 00:09:42,640
manually in every file wherever syscall

00:09:40,399 --> 00:09:44,959
was made we would go and change the code

00:09:42,640 --> 00:09:46,000
so that it called a ukl stub and in

00:09:44,959 --> 00:09:48,560
order to get that

00:09:46,000 --> 00:09:50,000
all the entry and exit code to work we

00:09:48,560 --> 00:09:51,519
would have to change all of that

00:09:50,000 --> 00:09:54,399
uh because we would have to then change

00:09:51,519 --> 00:09:56,880
the step library

00:09:54,399 --> 00:09:57,680
so uh for version 2 we got glibc fully

00:09:56,880 --> 00:10:01,200
functional

00:09:57,680 --> 00:10:04,079
uh which as you can imagine

00:10:01,200 --> 00:10:05,839
involved a lot of debugging we also got

00:10:04,079 --> 00:10:06,399
the nptel or the pthread library fully

00:10:05,839 --> 00:10:08,000
functional

00:10:06,399 --> 00:10:09,920
a great help with that was the unit

00:10:08,000 --> 00:10:12,000
tests written by ulrich ripper

00:10:09,920 --> 00:10:13,600
as part of the nptel library we ran all

00:10:12,000 --> 00:10:16,000
those and fixed problems as

00:10:13,600 --> 00:10:18,079
they came up we were still doing all the

00:10:16,000 --> 00:10:20,079
initializations ourselves

00:10:18,079 --> 00:10:21,680
uh that we did for version one we

00:10:20,079 --> 00:10:23,680
modified which you know

00:10:21,680 --> 00:10:25,600
as i discussed earlier that mod include

00:10:23,680 --> 00:10:27,519
involved modifying the task struct and

00:10:25,600 --> 00:10:29,839
mm struct just enough that glyphs

00:10:27,519 --> 00:10:31,519
initializations could work after glibc

00:10:29,839 --> 00:10:32,560
initializations we called b3 create to

00:10:31,519 --> 00:10:37,040
run the application

00:10:32,560 --> 00:10:38,720
on a proper user stack

00:10:37,040 --> 00:10:40,000
when we entered the kernel for any

00:10:38,720 --> 00:10:41,920
kernel functionality we were not

00:10:40,000 --> 00:10:44,000
switching stacks to a kernel stack

00:10:41,920 --> 00:10:45,600
because uh no ring transition ever

00:10:44,000 --> 00:10:48,000
happened so we

00:10:45,600 --> 00:10:50,399
we remained on the same user stack

00:10:48,000 --> 00:10:50,399
throughout

00:10:51,360 --> 00:10:54,800
we investigated and solved a whole a

00:10:53,200 --> 00:10:57,040
bunch of different problems in version 2

00:10:54,800 --> 00:10:59,279
and i will talk about a couple of them

00:10:57,040 --> 00:11:00,640
running multiple threads in uk we saw

00:10:59,279 --> 00:11:01,680
that application threads were never

00:11:00,640 --> 00:11:03,440
preempted

00:11:01,680 --> 00:11:05,120
and any other thread waiting to be

00:11:03,440 --> 00:11:07,279
scheduled in would never get the chance

00:11:05,120 --> 00:11:09,680
the problem uh fixed itself if we turned

00:11:07,279 --> 00:11:11,920
the kernel preemption config option on

00:11:09,680 --> 00:11:13,360
thankfully uh one of our mentors daniel

00:11:11,920 --> 00:11:15,519
who's also from red hat

00:11:13,360 --> 00:11:17,519
he jumped in to help the problem was

00:11:15,519 --> 00:11:19,200
that the kernel entry and exit code was

00:11:17,519 --> 00:11:20,000
not being executed on return from

00:11:19,200 --> 00:11:22,720
interrupts

00:11:20,000 --> 00:11:24,079
because we were always in ring zero uh

00:11:22,720 --> 00:11:25,120
due to this the scheduler was never

00:11:24,079 --> 00:11:27,279
called so daniel

00:11:25,120 --> 00:11:29,360
wrote a patch which handled this special

00:11:27,279 --> 00:11:31,200
case for us

00:11:29,360 --> 00:11:33,120
for application threads and made sure

00:11:31,200 --> 00:11:34,480
that the scheduler scheduler was called

00:11:33,120 --> 00:11:37,279
when we were on our way back to

00:11:34,480 --> 00:11:37,279
application code

00:11:38,399 --> 00:11:42,560
the other problem we fixed was that some

00:11:40,720 --> 00:11:43,120
of our page faults resulted in double

00:11:42,560 --> 00:11:44,720
faults

00:11:43,120 --> 00:11:46,880
normally when a page fault occurs as you

00:11:44,720 --> 00:11:47,600
all know you jump to a kernel stack to

00:11:46,880 --> 00:11:49,680
service that

00:11:47,600 --> 00:11:50,959
that fault the switch never occurred in

00:11:49,680 --> 00:11:54,639
uk because no

00:11:50,959 --> 00:11:56,399
ring transition ever happened so

00:11:54,639 --> 00:11:58,399
when a page fault occurred we never

00:11:56,399 --> 00:12:00,079
switched the stack and if we ever got a

00:11:58,399 --> 00:12:00,720
page fault because we ran out of user

00:12:00,079 --> 00:12:02,399
stack

00:12:00,720 --> 00:12:04,160
there would be no stack left to service

00:12:02,399 --> 00:12:05,600
that port and that would result in a

00:12:04,160 --> 00:12:08,160
double fault

00:12:05,600 --> 00:12:08,959
we fixed that by using ist or interrupt

00:12:08,160 --> 00:12:11,279
stack table

00:12:08,959 --> 00:12:13,279
as you all know it's yst we can have uh

00:12:11,279 --> 00:12:15,600
seven per cpu exception stacks that

00:12:13,279 --> 00:12:17,040
you can jump to irrespective of whether

00:12:15,600 --> 00:12:18,480
uh you

00:12:17,040 --> 00:12:20,560
whether there is a ring transition or

00:12:18,480 --> 00:12:22,959
not uh ists are

00:12:20,560 --> 00:12:25,519
already used in the kernel for uh debug

00:12:22,959 --> 00:12:27,360
purposes and nmis etc

00:12:25,519 --> 00:12:29,200
we created a new exception stack and

00:12:27,360 --> 00:12:32,079
added it to the interrupt stack table

00:12:29,200 --> 00:12:33,760
we changed the page fault entry in idt

00:12:32,079 --> 00:12:37,040
so that anytime a page fault occurred we

00:12:33,760 --> 00:12:38,720
would have a fresh stack to service it

00:12:37,040 --> 00:12:40,320
another interesting problem we found out

00:12:38,720 --> 00:12:41,680
after banging our heads against the wall

00:12:40,320 --> 00:12:44,880
was the red zone issue

00:12:41,680 --> 00:12:46,800
as you all know red zone is a 128 byte

00:12:44,880 --> 00:12:48,880
area beneath the stack pointer

00:12:46,800 --> 00:12:50,240
uh in in application stacks that the

00:12:48,880 --> 00:12:52,160
application can use

00:12:50,240 --> 00:12:53,360
to store data without moving the stack

00:12:52,160 --> 00:12:55,279
pointer and

00:12:53,360 --> 00:12:56,880
every time a syscall or interrupt

00:12:55,279 --> 00:12:58,480
happens you automatically switch to a

00:12:56,880 --> 00:13:00,240
kernel stack and this area remains

00:12:58,480 --> 00:13:02,079
unmodified

00:13:00,240 --> 00:13:04,000
in our case since the stack switch

00:13:02,079 --> 00:13:04,800
didn't happen when we entered the kernel

00:13:04,000 --> 00:13:06,480
the kernel code

00:13:04,800 --> 00:13:07,760
would trample all over the red zone and

00:13:06,480 --> 00:13:09,519
when it returned the application would

00:13:07,760 --> 00:13:11,440
have garbage values in the red zone

00:13:09,519 --> 00:13:12,959
so we fixed it by using the no red zone

00:13:11,440 --> 00:13:14,079
flag when compiling the user

00:13:12,959 --> 00:13:17,040
applications

00:13:14,079 --> 00:13:18,240
uh but finding the root cause of in this

00:13:17,040 --> 00:13:21,519
case was

00:13:18,240 --> 00:13:23,760
let's just say let's just say not easy

00:13:21,519 --> 00:13:24,720
uh so finally after fixing all of these

00:13:23,760 --> 00:13:27,519
issues and file

00:13:24,720 --> 00:13:29,360
fixing all of these different problems

00:13:27,519 --> 00:13:29,680
we were able to run complex applications

00:13:29,360 --> 00:13:32,079
like

00:13:29,680 --> 00:13:34,079
memcached we were excited to run

00:13:32,079 --> 00:13:35,839
experiments and collect numbers uh but

00:13:34,079 --> 00:13:37,600
we soon found out that we ran into

00:13:35,839 --> 00:13:39,120
problems as the load on the system

00:13:37,600 --> 00:13:40,639
increase for example if you created many

00:13:39,120 --> 00:13:42,000
threads or if you created if you did a

00:13:40,639 --> 00:13:44,480
lot of memory operations

00:13:42,000 --> 00:13:45,600
happen at once that would result in

00:13:44,480 --> 00:13:47,920
different

00:13:45,600 --> 00:13:48,720
failures and panics so larry woodman

00:13:47,920 --> 00:13:51,920
who's also

00:13:48,720 --> 00:13:55,199
our mentor who's also from red hat uh

00:13:51,920 --> 00:13:55,920
he is always a massive help he suggested

00:13:55,199 --> 00:13:57,839
that

00:13:55,920 --> 00:13:59,600
uh you know we should have a debug

00:13:57,839 --> 00:14:01,920
option where we

00:13:59,600 --> 00:14:03,279
we always change the stack when entering

00:14:01,920 --> 00:14:05,199
the kernel to see if

00:14:03,279 --> 00:14:07,199
uh not switching the stack was the case

00:14:05,199 --> 00:14:08,320
uh for all these new problems that we

00:14:07,199 --> 00:14:10,399
were facing

00:14:08,320 --> 00:14:11,920
uh since we had a separate stub for each

00:14:10,399 --> 00:14:13,120
syscall making this fix was not

00:14:11,920 --> 00:14:14,800
straightforward the kernel entry and

00:14:13,120 --> 00:14:16,240
exit code had become very complicated

00:14:14,800 --> 00:14:19,760
the way we were using it

00:14:16,240 --> 00:14:22,079
and clearly we needed a rewrite

00:14:19,760 --> 00:14:23,519
so we started working on uk version 3

00:14:22,079 --> 00:14:26,959
which is our current version

00:14:23,519 --> 00:14:29,680
we updated gellipsian kernel to latest

00:14:26,959 --> 00:14:31,360
versions and started from totally

00:14:29,680 --> 00:14:32,880
unmodified code bases

00:14:31,360 --> 00:14:34,399
instead of making changes in each and

00:14:32,880 --> 00:14:36,639
every file of glibc

00:14:34,399 --> 00:14:38,240
uh which wherever a sys call was made we

00:14:36,639 --> 00:14:40,000
change we made changes to the sys called

00:14:38,240 --> 00:14:42,000
macros

00:14:40,000 --> 00:14:43,680
and instead of in those macros instead

00:14:42,000 --> 00:14:44,480
of executing the syscall instruction we

00:14:43,680 --> 00:14:46,959
called

00:14:44,480 --> 00:14:48,800
entry syscall 64 which is the kernel

00:14:46,959 --> 00:14:51,120
entry point for syscalls

00:14:48,800 --> 00:14:53,040
and on returning from the kernel we did

00:14:51,120 --> 00:14:56,000
an irit instead of a cis red

00:14:53,040 --> 00:14:58,000
so stack uh the ring transition would

00:14:56,000 --> 00:15:00,240
not happen

00:14:58,000 --> 00:15:01,360
also we threw out the ukl's stub library

00:15:00,240 --> 00:15:03,279
and used the

00:15:01,360 --> 00:15:05,760
already existing kernel functionality of

00:15:03,279 --> 00:15:08,320
going through the syscall table

00:15:05,760 --> 00:15:09,519
since we were using all uh the existing

00:15:08,320 --> 00:15:11,120
uh kernel code

00:15:09,519 --> 00:15:12,959
we went through the kernel the full

00:15:11,120 --> 00:15:16,320
kernel entry and exit paths uh

00:15:12,959 --> 00:15:18,079
without any modification uh

00:15:16,320 --> 00:15:19,920
a lot of time was spent in the entry

00:15:18,079 --> 00:15:22,959
64.s file

00:15:19,920 --> 00:15:24,560
uh and we we modified slightly modified

00:15:22,959 --> 00:15:26,959
all the kernel entry points for

00:15:24,560 --> 00:15:28,800
for example for syscalls faults and

00:15:26,959 --> 00:15:30,639
errors and interrupts

00:15:28,800 --> 00:15:32,240
these changes were minimal these

00:15:30,639 --> 00:15:34,320
involved changing the

00:15:32,240 --> 00:15:35,680
cs value on the stack every time we came

00:15:34,320 --> 00:15:39,040
from application code to the

00:15:35,680 --> 00:15:42,079
to the to the kernel

00:15:39,040 --> 00:15:44,560
and every time we exited uh we could

00:15:42,079 --> 00:15:46,480
replace this cs value back to kernel cs

00:15:44,560 --> 00:15:47,680
value so and do an irit instead of

00:15:46,480 --> 00:15:49,680
system this

00:15:47,680 --> 00:15:51,440
uh changing that value on stack ensured

00:15:49,680 --> 00:15:55,040
that the entry and exit code

00:15:51,440 --> 00:15:56,959
was was executed without

00:15:55,040 --> 00:15:58,880
us having to change anything because

00:15:56,959 --> 00:16:00,720
that code looks for the cs value on

00:15:58,880 --> 00:16:03,600
stack

00:16:00,720 --> 00:16:05,120
uh we added back the changes to the page

00:16:03,600 --> 00:16:05,519
fault interrupt that we had in version

00:16:05,120 --> 00:16:07,839
two

00:16:05,519 --> 00:16:09,839
so that we use the ist we also added

00:16:07,839 --> 00:16:13,519
back the boot up and linker changes

00:16:09,839 --> 00:16:13,519
that we had discussed from version one

00:16:13,839 --> 00:16:17,440
uh but we were still doing a lot of our

00:16:16,160 --> 00:16:18,880
own custom

00:16:17,440 --> 00:16:21,440
initializations before executing

00:16:18,880 --> 00:16:23,680
application code tommy who you can

00:16:21,440 --> 00:16:25,440
see on the screen who's my co-presenter

00:16:23,680 --> 00:16:27,519
uh he wanted to run complex c

00:16:25,440 --> 00:16:29,600
c plus plus applications on ukl and that

00:16:27,519 --> 00:16:31,360
code requires the full set of glypc

00:16:29,600 --> 00:16:34,160
initializations to happen which in turn

00:16:31,360 --> 00:16:36,399
required a full set of

00:16:34,160 --> 00:16:38,720
initializations to be done in the exact

00:16:36,399 --> 00:16:40,079
ve so thanks to tommy he went through

00:16:38,720 --> 00:16:42,399
all this code and

00:16:40,079 --> 00:16:44,560
uh because of him we got rid of our

00:16:42,399 --> 00:16:46,880
handbook one initialization code

00:16:44,560 --> 00:16:48,720
so uh we modified the exec ve code a

00:16:46,880 --> 00:16:49,279
little so that it ran without actually

00:16:48,720 --> 00:16:51,839
requiring

00:16:49,279 --> 00:16:54,079
an elf file it went through full stack

00:16:51,839 --> 00:16:56,160
full initialization and setup

00:16:54,079 --> 00:16:57,199
of the address space mm struct task

00:16:56,160 --> 00:16:59,040
struct uh

00:16:57,199 --> 00:17:01,199
it also copied all of the extra kernel

00:16:59,040 --> 00:17:02,320
command lines our command line arguments

00:17:01,199 --> 00:17:03,680
to the user stack

00:17:02,320 --> 00:17:05,360
and jump to the user stack before

00:17:03,680 --> 00:17:08,160
running user code which i know

00:17:05,360 --> 00:17:08,799
uh uh you know made tommy really really

00:17:08,160 --> 00:17:10,720
happy

00:17:08,799 --> 00:17:12,319
because he was able to run all the cc

00:17:10,720 --> 00:17:14,880
plus plus applications

00:17:12,319 --> 00:17:16,959
uh we jumped into glyphs initializations

00:17:14,880 --> 00:17:19,039
after that and we were able to do also

00:17:16,959 --> 00:17:20,640
all uh the full set of glyphs

00:17:19,039 --> 00:17:21,919
initializations and everything worked

00:17:20,640 --> 00:17:24,240
like a charm

00:17:21,919 --> 00:17:25,280
um and so this is this is what we're

00:17:24,240 --> 00:17:27,919
doing in our

00:17:25,280 --> 00:17:28,720
uh in our version three we are not doing

00:17:27,919 --> 00:17:29,919
our own

00:17:28,720 --> 00:17:33,840
initializations we are following

00:17:29,919 --> 00:17:33,840
whatever is already there

00:17:35,440 --> 00:17:38,960
so kernel does not expect a stack page

00:17:38,400 --> 00:17:40,640
fault

00:17:38,960 --> 00:17:43,200
when running kernel code because it

00:17:40,640 --> 00:17:45,440
assumes that you are on a kernel stack

00:17:43,200 --> 00:17:47,200
so imagine we are in map code and have

00:17:45,440 --> 00:17:48,480
taken a right lock on the read write so

00:17:47,200 --> 00:17:49,280
this is this is the problem that we

00:17:48,480 --> 00:17:50,880
faced uh

00:17:49,280 --> 00:17:53,280
in version three that we fixed it was a

00:17:50,880 --> 00:17:56,640
deadlock problem so imagine if we are

00:17:53,280 --> 00:17:58,480
in an map code on on a user stack

00:17:56,640 --> 00:18:01,600
and we have taken a right lock on the

00:17:58,480 --> 00:18:04,160
read write semaphore uh of the mm struct

00:18:01,600 --> 00:18:05,760
uh if and and we are modifying the list

00:18:04,160 --> 00:18:07,840
of vmas

00:18:05,760 --> 00:18:10,240
if at this point we suffer a stack page

00:18:07,840 --> 00:18:12,720
fault we go to the fault handling code

00:18:10,240 --> 00:18:13,600
here we try to take the read lock on the

00:18:12,720 --> 00:18:16,640
mm instruction

00:18:13,600 --> 00:18:18,720
for without realizing uh that

00:18:16,640 --> 00:18:19,760
we already have a right lock on it so

00:18:18,720 --> 00:18:23,280
the read lock

00:18:19,760 --> 00:18:24,960
obviously fails uh at this point we are

00:18:23,280 --> 00:18:26,720
unable to take the read lock unable to

00:18:24,960 --> 00:18:28,320
proceed we mark ourselves as

00:18:26,720 --> 00:18:29,840
uninterruptible and wait for someone to

00:18:28,320 --> 00:18:30,640
give up that right lock so we can then

00:18:29,840 --> 00:18:32,400
be woken up

00:18:30,640 --> 00:18:35,440
but since we are the one holding the

00:18:32,400 --> 00:18:37,679
right lock that results in a deadlock

00:18:35,440 --> 00:18:39,200
uh this was solved by a brilliant idea

00:18:37,679 --> 00:18:41,440
from larry woodman

00:18:39,200 --> 00:18:42,880
in the page fault handling code we only

00:18:41,440 --> 00:18:44,480
want to take the read lock on the

00:18:42,880 --> 00:18:46,400
semaphore

00:18:44,480 --> 00:18:47,919
to walk the list of vms and find out the

00:18:46,400 --> 00:18:49,120
vma to which the faulting address

00:18:47,919 --> 00:18:51,120
belongs

00:18:49,120 --> 00:18:52,799
in our case deadlock is only caused by

00:18:51,120 --> 00:18:53,360
stack page faults so if we know the

00:18:52,799 --> 00:18:55,520
stack

00:18:53,360 --> 00:18:57,200
vma beforehand we don't need to take the

00:18:55,520 --> 00:18:59,120
read lock anymore

00:18:57,200 --> 00:19:02,080
so when the thread is created we save it

00:18:59,120 --> 00:19:04,000
stack vma in a per thread variable

00:19:02,080 --> 00:19:05,919
in case of a page fault we check if the

00:19:04,000 --> 00:19:08,320
faulting address belongs to that vma

00:19:05,919 --> 00:19:10,080
if yes then we don't take the lock we

00:19:08,320 --> 00:19:12,480
just read the vma

00:19:10,080 --> 00:19:14,160
from the value we've already saved and

00:19:12,480 --> 00:19:16,640
serviced the page fault normally

00:19:14,160 --> 00:19:17,360
uh and if it does not belong to that vma

00:19:16,640 --> 00:19:19,840
it's not a

00:19:17,360 --> 00:19:20,880
stack fault then we just follow the

00:19:19,840 --> 00:19:24,240
routine procedure

00:19:20,880 --> 00:19:27,280
so that allowed us to not to to fix this

00:19:24,240 --> 00:19:29,520
deadlock uh because

00:19:27,280 --> 00:19:31,200
we are now most we are now using mostly

00:19:29,520 --> 00:19:33,520
unchanged linux uh

00:19:31,200 --> 00:19:35,200
code uh with the entry exit code

00:19:33,520 --> 00:19:36,080
especially we can easily switch on and

00:19:35,200 --> 00:19:38,720
off the

00:19:36,080 --> 00:19:39,440
stack switching uh so when you go to the

00:19:38,720 --> 00:19:42,480
kernel

00:19:39,440 --> 00:19:44,240
a code we can easily

00:19:42,480 --> 00:19:45,679
change the stack and easily not change

00:19:44,240 --> 00:19:46,320
the stack so it's just a config option

00:19:45,679 --> 00:19:48,799
away

00:19:46,320 --> 00:19:50,799
we also made changes to uh the syscall

00:19:48,799 --> 00:19:53,760
define macro in linux

00:19:50,799 --> 00:19:55,039
to define a stub for each syscall so

00:19:53,760 --> 00:19:56,559
this way every syscall gets the

00:19:55,039 --> 00:19:58,720
corresponding you can stuck with it

00:19:56,559 --> 00:20:00,480
we use it to directly call kernel

00:19:58,720 --> 00:20:01,600
functionality without incurring economy

00:20:00,480 --> 00:20:03,039
and exit overhead so

00:20:01,600 --> 00:20:05,039
imagine if we don't want to go through

00:20:03,039 --> 00:20:05,840
that entry exit code we want to directly

00:20:05,039 --> 00:20:08,000
call uh

00:20:05,840 --> 00:20:10,080
the underlying kernel functionality we

00:20:08,000 --> 00:20:11,360
can we can bypass all that and call that

00:20:10,080 --> 00:20:13,919
stuff directly

00:20:11,360 --> 00:20:15,440
based on all that what we had learned

00:20:13,919 --> 00:20:16,960
about linux and glibc we created

00:20:15,440 --> 00:20:18,960
different flavors of uk

00:20:16,960 --> 00:20:20,799
the first one is the simplest case where

00:20:18,960 --> 00:20:23,120
we remain in ring zero

00:20:20,799 --> 00:20:24,559
and do a switch to kernel stack uh when

00:20:23,120 --> 00:20:26,559
executing kernel code

00:20:24,559 --> 00:20:28,720
uh be it says calls interrupts fault

00:20:26,559 --> 00:20:30,559
handling whatever

00:20:28,720 --> 00:20:32,400
this is the simplest case and we run all

00:20:30,559 --> 00:20:34,320
applications with this

00:20:32,400 --> 00:20:35,760
case first to see if there are any

00:20:34,320 --> 00:20:39,039
problems and then we move on to

00:20:35,760 --> 00:20:40,880
the next uh uh flavors

00:20:39,039 --> 00:20:42,880
the second flavor is where we remain in

00:20:40,880 --> 00:20:43,840
ring zero and also remain on user stack

00:20:42,880 --> 00:20:46,720
all the time we don't

00:20:43,840 --> 00:20:48,080
switch to a kernel stack the third one

00:20:46,720 --> 00:20:52,640
would you like to fill the question

00:20:48,080 --> 00:20:52,640
from richard would it work

00:20:53,200 --> 00:20:57,039
uh i'm sorry would it work too you know

00:20:55,039 --> 00:20:58,080
someone to create sp on the syscall

00:20:57,039 --> 00:21:02,000
entry path

00:20:58,080 --> 00:21:05,840
so uh in the stack switch case

00:21:02,000 --> 00:21:05,840
this is about uh red zone right

00:21:06,320 --> 00:21:10,480
yes so in the stack switch case when we

00:21:08,880 --> 00:21:11,520
switch the kernel stack yes that would

00:21:10,480 --> 00:21:13,840
solve that problem but

00:21:11,520 --> 00:21:16,559
if we are on the same user stack all the

00:21:13,840 --> 00:21:19,440
time we will still have to uh use that

00:21:16,559 --> 00:21:19,440
no red zone flag

00:21:19,760 --> 00:21:25,679
so uh uh uh

00:21:22,799 --> 00:21:26,640
yeah the the third flavor is where every

00:21:25,679 --> 00:21:29,200
thread can turn

00:21:26,640 --> 00:21:30,159
on or off a flag which allows it to

00:21:29,200 --> 00:21:32,480
bypass this call

00:21:30,159 --> 00:21:33,520
enter and exit overhead uh it can call

00:21:32,480 --> 00:21:35,280
the internal function

00:21:33,520 --> 00:21:36,559
kernel functionality directly this is

00:21:35,280 --> 00:21:38,240
helpful when application has some

00:21:36,559 --> 00:21:38,960
performance sensitive part of the code

00:21:38,240 --> 00:21:41,120
and it just

00:21:38,960 --> 00:21:42,799
wants to get done with it uh very

00:21:41,120 --> 00:21:45,840
quickly and not incur the

00:21:42,799 --> 00:21:45,840
entry exit overheads

00:21:46,240 --> 00:21:50,960
so the number of lines modified for each

00:21:49,120 --> 00:21:52,480
case is also small and this gives us

00:21:50,960 --> 00:21:54,720
hope that maybe

00:21:52,480 --> 00:21:56,880
such a small set of changes can

00:21:54,720 --> 00:21:58,559
potentially be accepted upstream

00:21:56,880 --> 00:22:01,120
hopefully we will see in the future when

00:21:58,559 --> 00:22:04,240
uh ukel is a little more mature

00:22:01,120 --> 00:22:07,760
but as you can see uh all

00:22:04,240 --> 00:22:09,520
380 to 500 lines uh changed in linux

00:22:07,760 --> 00:22:13,840
and all the changes in glypc now are

00:22:09,520 --> 00:22:13,840
also limited to a separate subdirectory

00:22:14,159 --> 00:22:18,080
so uh as our understanding of the linux

00:22:16,240 --> 00:22:20,320
kernel and glypc has grown the number of

00:22:18,080 --> 00:22:22,080
changes required has also gone down

00:22:20,320 --> 00:22:23,760
uh we are in a very nice place right now

00:22:22,080 --> 00:22:27,120
where uk can run complex

00:22:23,760 --> 00:22:30,159
applications and we're really excited to

00:22:27,120 --> 00:22:33,440
see what is next uh

00:22:30,159 --> 00:22:34,480
we ran a simple memcached experiment uh

00:22:33,440 --> 00:22:37,679
[Music]

00:22:34,480 --> 00:22:39,679
so it shows that the memcache d

00:22:37,679 --> 00:22:41,760
running normally on linux in the blue

00:22:39,679 --> 00:22:43,919
line and

00:22:41,760 --> 00:22:44,799
that totally unchanged memcache d

00:22:43,919 --> 00:22:47,039
compiled

00:22:44,799 --> 00:22:49,440
as different versions of ukl all

00:22:47,039 --> 00:22:51,200
instances are running inside qmuk vm on

00:22:49,440 --> 00:22:52,799
six cores while the client runs on a

00:22:51,200 --> 00:22:55,200
different physical node with

00:22:52,799 --> 00:22:56,240
lots of different uh a lot with large

00:22:55,200 --> 00:22:58,000
number of threads uh

00:22:56,240 --> 00:22:59,919
sending memcached requests to this

00:22:58,000 --> 00:23:02,960
server this graph shows

00:22:59,919 --> 00:23:05,360
uh the 99 percentile tail latency

00:23:02,960 --> 00:23:06,799
and also shows the 500 microsecond sla

00:23:05,360 --> 00:23:09,840
line in black

00:23:06,799 --> 00:23:13,039
so uh any line which

00:23:09,840 --> 00:23:15,039
remains under that 500 microsecond mark

00:23:13,039 --> 00:23:16,960
for the longest is actually performing

00:23:15,039 --> 00:23:18,720
the better so it can

00:23:16,960 --> 00:23:21,120
service more queries per second while

00:23:18,720 --> 00:23:23,919
staying under that sla

00:23:21,120 --> 00:23:26,080
uh this result again should only be

00:23:23,919 --> 00:23:28,000
interpreted as a proof of functionality

00:23:26,080 --> 00:23:29,600
uh it shows us promise but at this point

00:23:28,000 --> 00:23:32,000
we should not look at the numbers

00:23:29,600 --> 00:23:32,880
but look at it as potential gains

00:23:32,000 --> 00:23:34,720
because we need

00:23:32,880 --> 00:23:36,400
a better virtualized network to get

00:23:34,720 --> 00:23:38,880
repeatable numbers without noise

00:23:36,400 --> 00:23:39,600
uh when we we have a high performing

00:23:38,880 --> 00:23:42,880
network

00:23:39,600 --> 00:23:44,000
uh i hope that this uh difference in the

00:23:42,880 --> 00:23:47,039
different versions of

00:23:44,000 --> 00:23:50,000
ukl and linux will actually grow

00:23:47,039 --> 00:23:51,360
uh we need to run bare metal numbers to

00:23:50,000 --> 00:23:53,120
get proper numbers uh

00:23:51,360 --> 00:23:55,200
bare metal experiments to get proper

00:23:53,120 --> 00:23:57,039
numbers and but this at least shows that

00:23:55,200 --> 00:23:57,440
uk can run unmodified applications and

00:23:57,039 --> 00:24:00,240
there's

00:23:57,440 --> 00:24:01,360
performance benefits to be had so

00:24:00,240 --> 00:24:03,520
there's a lot of interesting

00:24:01,360 --> 00:24:04,960
research directions we can explore i

00:24:03,520 --> 00:24:05,840
would like to hand it over to tommy who

00:24:04,960 --> 00:24:07,440
is also exploring

00:24:05,840 --> 00:24:08,960
one such very interesting direction and

00:24:07,440 --> 00:24:10,960
then we'll come back to me

00:24:08,960 --> 00:24:13,360
and we'll see what's next for the uk

00:24:10,960 --> 00:24:13,360
project

00:24:14,960 --> 00:24:19,840
thanks a lot really that was awesome man

00:24:16,840 --> 00:24:19,840
um

00:24:20,159 --> 00:24:24,640
so yeah so my name is tom younger i'm a

00:24:23,760 --> 00:24:28,000
bu phd

00:24:24,640 --> 00:24:29,120
student and a red hat intern i work with

00:24:28,000 --> 00:24:32,320
jonathan apollo

00:24:29,120 --> 00:24:35,520
and iran krieger and the whole list of

00:24:32,320 --> 00:24:37,679
of everybody that we introduced um

00:24:35,520 --> 00:24:38,799
my main interest is in performance

00:24:37,679 --> 00:24:41,200
optimization

00:24:38,799 --> 00:24:43,520
at the operating system level in my work

00:24:41,200 --> 00:24:45,679
i find that's often been done by

00:24:43,520 --> 00:24:46,559
by blurring the line between what is

00:24:45,679 --> 00:24:49,440
application

00:24:46,559 --> 00:24:51,600
and os code so maybe maybe blurring that

00:24:49,440 --> 00:24:52,720
line maybe redrawing it maybe forgetting

00:24:51,600 --> 00:24:55,600
to draw it

00:24:52,720 --> 00:24:57,440
just somewhere in that space and uh so i

00:24:55,600 --> 00:24:58,320
got to spend some time this year hacking

00:24:57,440 --> 00:25:00,640
on ukl

00:24:58,320 --> 00:25:03,919
and i've come to see it as a really

00:25:00,640 --> 00:25:05,520
fruitful project and that

00:25:03,919 --> 00:25:08,080
kind of wherever you look it looks like

00:25:05,520 --> 00:25:09,679
there's there's space for a new idea as

00:25:08,080 --> 00:25:12,159
opposed to a dead end

00:25:09,679 --> 00:25:13,440
and uh so i wanted to to share with you

00:25:12,159 --> 00:25:15,760
some of the

00:25:13,440 --> 00:25:17,600
some of the future directions from the

00:25:15,760 --> 00:25:19,760
some of the places that i'd like to take

00:25:17,600 --> 00:25:21,600
this going forward

00:25:19,760 --> 00:25:23,360
uh so what i want to get across in this

00:25:21,600 --> 00:25:26,159
talk is really two ideas

00:25:23,360 --> 00:25:27,600
uh first to flesh out this apparent

00:25:26,159 --> 00:25:28,960
tension between

00:25:27,600 --> 00:25:30,960
the standard what i'm calling the

00:25:28,960 --> 00:25:33,120
standard process model what we all

00:25:30,960 --> 00:25:34,400
know and love processes running on

00:25:33,120 --> 00:25:36,400
monolithic linux

00:25:34,400 --> 00:25:38,159
and the uni kernel model that ellie's

00:25:36,400 --> 00:25:40,480
been talking about today

00:25:38,159 --> 00:25:43,919
uh so i'm claiming that there's there's

00:25:40,480 --> 00:25:45,840
a tension between those two models but

00:25:43,919 --> 00:25:48,159
it might not be as real as it as it

00:25:45,840 --> 00:25:49,200
looks and to do something constructive

00:25:48,159 --> 00:25:52,000
here

00:25:49,200 --> 00:25:53,279
i want to propose a resolution and

00:25:52,000 --> 00:25:55,120
that's going to come in the form of a

00:25:53,279 --> 00:25:56,640
unification of these models and i hope

00:25:55,120 --> 00:25:58,240
to spend the rest of this talk

00:25:56,640 --> 00:26:00,799
trying to make it clear what i mean by

00:25:58,240 --> 00:26:02,720
that so at a high level

00:26:00,799 --> 00:26:04,640
this resolution is going to show that

00:26:02,720 --> 00:26:05,600
the process model and the unikernel

00:26:04,640 --> 00:26:08,400
model

00:26:05,600 --> 00:26:09,760
exist as extreme points on a spectrum

00:26:08,400 --> 00:26:10,400
and that there's meaningful points in

00:26:09,760 --> 00:26:12,480
between

00:26:10,400 --> 00:26:15,440
and i can show a way that that you can

00:26:12,480 --> 00:26:18,080
interpolate between those two points

00:26:15,440 --> 00:26:20,000
uh so some background right our standard

00:26:18,080 --> 00:26:21,840
process model your

00:26:20,000 --> 00:26:24,000
you have two independent source bases

00:26:21,840 --> 00:26:25,279
right your kernel and your application

00:26:24,000 --> 00:26:27,440
and you're going to throw them through a

00:26:25,279 --> 00:26:29,600
compiler to build some independent

00:26:27,440 --> 00:26:32,080
executables

00:26:29,600 --> 00:26:34,559
uh so in this model right we can boot

00:26:32,080 --> 00:26:36,480
our os on hardware and a vm

00:26:34,559 --> 00:26:38,320
exec an application on top of it and

00:26:36,480 --> 00:26:40,320
we're cooking

00:26:38,320 --> 00:26:42,640
now the difference with the unikernel

00:26:40,320 --> 00:26:45,200
model right ukl wants you to take your

00:26:42,640 --> 00:26:47,279
unmodified source code right your cnc

00:26:45,200 --> 00:26:48,720
plus code send it through a single

00:26:47,279 --> 00:26:51,039
compilation step

00:26:48,720 --> 00:26:52,720
with a lightly modified linux kernel

00:26:51,039 --> 00:26:54,720
those were insane numbers right

00:26:52,720 --> 00:26:56,400
i think it was 300 to 500 lines of code

00:26:54,720 --> 00:26:57,440
that were getting modified

00:26:56,400 --> 00:27:00,080
and the goal here is that we're

00:26:57,440 --> 00:27:03,200
automatically producing an optimized

00:27:00,080 --> 00:27:06,159
unikernel executable right so the

00:27:03,200 --> 00:27:08,240
both sides of that divide are being

00:27:06,159 --> 00:27:11,279
compiler optimized as they move through

00:27:08,240 --> 00:27:11,279
this process together

00:27:11,840 --> 00:27:15,200
so here's part of the tension right how

00:27:14,480 --> 00:27:18,480
can this

00:27:15,200 --> 00:27:20,720
humble standard process model contain

00:27:18,480 --> 00:27:22,000
content with these brutally fast uni

00:27:20,720 --> 00:27:25,200
kernels right everett

00:27:22,000 --> 00:27:26,720
uh ellie just mentioned our tea result

00:27:25,200 --> 00:27:29,039
from our group a couple years ago

00:27:26,720 --> 00:27:30,799
doubling the throughput of that system

00:27:29,039 --> 00:27:32,640
the last system i worked on soos

00:27:30,799 --> 00:27:34,159
and we showed that in a function as a

00:27:32,640 --> 00:27:36,000
service context

00:27:34,159 --> 00:27:38,559
we could increase the cache density of

00:27:36,000 --> 00:27:40,480
functions by 50x right by using

00:27:38,559 --> 00:27:42,880
unikernel techniques together with

00:27:40,480 --> 00:27:44,640
optimizations that they enabled

00:27:42,880 --> 00:27:46,880
and there's a ton of other results out

00:27:44,640 --> 00:27:46,880
there

00:27:47,120 --> 00:27:50,720
and sorry here's here's from our uni

00:27:49,039 --> 00:27:52,799
kernel model an application

00:27:50,720 --> 00:27:54,000
placed together in a single address

00:27:52,799 --> 00:27:56,320
space with

00:27:54,000 --> 00:27:58,240
the operating system components running

00:27:56,320 --> 00:28:00,240
in ring zero

00:27:58,240 --> 00:28:02,000
um i think that the ucal approach here

00:28:00,240 --> 00:28:03,440
is uh i find it super

00:28:02,000 --> 00:28:05,200
motivating right that you can take your

00:28:03,440 --> 00:28:05,600
unmodified code send it through our

00:28:05,200 --> 00:28:07,760
build

00:28:05,600 --> 00:28:09,600
process and on the other side you're

00:28:07,760 --> 00:28:11,360
going to get out an executable that

00:28:09,600 --> 00:28:13,760
we claim is going to run faster than if

00:28:11,360 --> 00:28:16,080
you had run it as a process

00:28:13,760 --> 00:28:16,880
but let's take a minute to uh to

00:28:16,080 --> 00:28:19,200
consider

00:28:16,880 --> 00:28:20,399
how things look when we're multiplexing

00:28:19,200 --> 00:28:22,799
right some differences

00:28:20,399 --> 00:28:24,880
are really going to pop out here so

00:28:22,799 --> 00:28:26,799
multiplexing processes is as

00:28:24,880 --> 00:28:29,039
natural as breathing for linux right

00:28:26,799 --> 00:28:30,320
it's where the standard process model

00:28:29,039 --> 00:28:32,720
really shines

00:28:30,320 --> 00:28:34,080
right ease of programming so many

00:28:32,720 --> 00:28:37,039
different types of process

00:28:34,080 --> 00:28:38,480
interaction right sockets pipes rpcs

00:28:37,039 --> 00:28:41,120
shared memory

00:28:38,480 --> 00:28:41,520
file systems right what does it mean

00:28:41,120 --> 00:28:44,559
though

00:28:41,520 --> 00:28:46,080
to multiplex in the unikernel context

00:28:44,559 --> 00:28:48,480
right this thing is supposed to be given

00:28:46,080 --> 00:28:51,039
full dominion or a piece of hardware

00:28:48,480 --> 00:28:52,240
it's really just not clear how to go

00:28:51,039 --> 00:28:54,320
about that

00:28:52,240 --> 00:28:55,279
and i really ran into this this summer

00:28:54,320 --> 00:28:58,159
when i

00:28:55,279 --> 00:28:59,520
started getting interested in profiling

00:28:58,159 --> 00:29:02,880
an application

00:28:59,520 --> 00:29:05,200
right and the idea here was can we jam

00:29:02,880 --> 00:29:06,640
perf together with our application into

00:29:05,200 --> 00:29:08,880
the same unit kernel

00:29:06,640 --> 00:29:10,720
and use that to profile where the

00:29:08,880 --> 00:29:13,760
application is spending its time

00:29:10,720 --> 00:29:15,039
as it executes and uh even with some

00:29:13,760 --> 00:29:16,960
help from

00:29:15,039 --> 00:29:18,960
from some of the experts in red hat's

00:29:16,960 --> 00:29:21,600
perf department and this is a shout out

00:29:18,960 --> 00:29:25,360
to york also if he's in the audience

00:29:21,600 --> 00:29:29,360
this proved quite difficult um

00:29:25,360 --> 00:29:31,120
uh and even if you're successful at

00:29:29,360 --> 00:29:33,520
getting these to co-run maybe on

00:29:31,120 --> 00:29:35,120
different threads within this executable

00:29:33,520 --> 00:29:36,960
you still have to worry about probe

00:29:35,120 --> 00:29:38,399
effects right so

00:29:36,960 --> 00:29:41,200
you learned about how this thing

00:29:38,399 --> 00:29:44,080
executes with perf compiled into it

00:29:41,200 --> 00:29:45,679
what changes when perf is removed when

00:29:44,080 --> 00:29:47,120
you actually go to deploy this thing

00:29:45,679 --> 00:29:49,600
right

00:29:47,120 --> 00:29:50,720
so taking another step at multiplexing

00:29:49,600 --> 00:29:52,480
these uh

00:29:50,720 --> 00:29:54,240
you can certainly run each of them in

00:29:52,480 --> 00:29:56,480
their own virtual machine

00:29:54,240 --> 00:29:57,679
right but when it comes to uh to

00:29:56,480 --> 00:29:59,120
thinking about how these things are

00:29:57,679 --> 00:30:01,120
going to be interconnected

00:29:59,120 --> 00:30:02,720
now we're talking about vm exits just to

00:30:01,120 --> 00:30:04,720
get out of this domain

00:30:02,720 --> 00:30:06,480
and then maybe talking across network

00:30:04,720 --> 00:30:09,520
protocols

00:30:06,480 --> 00:30:11,120
to get data in between these two and

00:30:09,520 --> 00:30:13,440
maybe it's because i'm the department

00:30:11,120 --> 00:30:14,080
extrovert or maybe i've spent too much

00:30:13,440 --> 00:30:16,000
time

00:30:14,080 --> 00:30:17,440
working from my apartment but this just

00:30:16,000 --> 00:30:19,760
looks kind of lonely to me

00:30:17,440 --> 00:30:21,520
right like why shouldn't one uni kernel

00:30:19,760 --> 00:30:22,960
be able to leave a love note in the file

00:30:21,520 --> 00:30:25,600
system for another one

00:30:22,960 --> 00:30:27,120
right but but more seriously what if

00:30:25,600 --> 00:30:27,840
your application is comprised of

00:30:27,120 --> 00:30:30,000
multiple

00:30:27,840 --> 00:30:31,679
communicating processes right what if

00:30:30,000 --> 00:30:33,840
your application forks

00:30:31,679 --> 00:30:35,200
these rich means of interactions this is

00:30:33,840 --> 00:30:37,279
the baby that we shouldn't throw out

00:30:35,200 --> 00:30:39,200
with the bath water as we change

00:30:37,279 --> 00:30:41,360
as we change and consider new models

00:30:39,200 --> 00:30:43,200
here and to be explicit the question i'm

00:30:41,360 --> 00:30:43,840
asking is why can't we hook up one or

00:30:43,200 --> 00:30:46,960
more

00:30:43,840 --> 00:30:51,039
uni kernels directly into this model and

00:30:46,960 --> 00:30:53,520
interface them much like processes do

00:30:51,039 --> 00:30:55,120
and uh so to try to do something

00:30:53,520 --> 00:30:56,799
constructive here i'll uh

00:30:55,120 --> 00:30:58,640
i'll try to sketch out a system that

00:30:56,799 --> 00:31:00,320
might help us achieve this

00:30:58,640 --> 00:31:02,640
um i've been calling this thing

00:31:00,320 --> 00:31:03,200
symbiosis and the idea here is that

00:31:02,640 --> 00:31:08,080
we're gonna

00:31:03,200 --> 00:31:10,000
allow a a semi-permeable

00:31:08,080 --> 00:31:11,519
inner meshing of application and kernel

00:31:10,000 --> 00:31:14,320
code right so

00:31:11,519 --> 00:31:18,559
uh we're going to try to bring these two

00:31:14,320 --> 00:31:20,799
code paths into uh

00:31:18,559 --> 00:31:23,039
into each other's space in in a

00:31:20,799 --> 00:31:25,519
controlled way

00:31:23,039 --> 00:31:27,039
and so what i'm proposing here is to run

00:31:25,519 --> 00:31:30,080
performance optimized

00:31:27,039 --> 00:31:32,080
unicornalized processes in the context

00:31:30,080 --> 00:31:33,600
of a richly functioning general purpose

00:31:32,080 --> 00:31:37,679
operating system

00:31:33,600 --> 00:31:39,679
uh in the system i have two entities

00:31:37,679 --> 00:31:41,039
right the process which we're familiar

00:31:39,679 --> 00:31:43,679
with and

00:31:41,039 --> 00:31:45,360
symbiotes all right so so what i'm

00:31:43,679 --> 00:31:47,840
calling a symbiote is

00:31:45,360 --> 00:31:49,919
uh so certainly a uni kernel like what

00:31:47,840 --> 00:31:50,960
ukl is producing that's an example of a

00:31:49,919 --> 00:31:53,679
symbol

00:31:50,960 --> 00:31:54,480
but so is something that lands in the

00:31:53,679 --> 00:31:57,200
spectrum

00:31:54,480 --> 00:31:58,000
between a process and a unit kernel and

00:31:57,200 --> 00:31:59,600
i'll try to

00:31:58,000 --> 00:32:02,880
i'll try to flesh out what i mean by

00:31:59,600 --> 00:32:06,480
that what is that in between space

00:32:02,880 --> 00:32:09,600
so symbiosis allows for the co-running

00:32:06,480 --> 00:32:10,640
of symbiotes and processes right and

00:32:09,600 --> 00:32:14,159
it's providing

00:32:10,640 --> 00:32:16,320
this rich system called interface

00:32:14,159 --> 00:32:17,840
for for any of these entities uni

00:32:16,320 --> 00:32:21,120
kernels included right

00:32:17,840 --> 00:32:23,120
uh out to an outside running kernel

00:32:21,120 --> 00:32:24,799
right and so these first two points it's

00:32:23,120 --> 00:32:26,880
trying to resolve the shortcomings of

00:32:24,799 --> 00:32:29,360
the unikernel model right how can we run

00:32:26,880 --> 00:32:32,240
these in the context of other processes

00:32:29,360 --> 00:32:33,519
uh how can we provide that those rich

00:32:32,240 --> 00:32:36,159
means of interconnection and

00:32:33,519 --> 00:32:38,320
communication

00:32:36,159 --> 00:32:39,760
our last point here is allowing an

00:32:38,320 --> 00:32:43,519
iterative procedure

00:32:39,760 --> 00:32:45,760
for for taking a process

00:32:43,519 --> 00:32:48,080
and moving it down this spectrum

00:32:45,760 --> 00:32:51,200
applying progressively more and more

00:32:48,080 --> 00:32:53,840
unicorn optimizations along the way

00:32:51,200 --> 00:32:55,120
uh so how to realize this thing i've got

00:32:53,840 --> 00:32:58,399
three steps here right

00:32:55,120 --> 00:33:00,799
first we want to have this ability to

00:32:58,399 --> 00:33:03,600
escalate a normal process

00:33:00,799 --> 00:33:05,679
to to able to transition it to running

00:33:03,600 --> 00:33:08,559
in kernel mode and ring zero

00:33:05,679 --> 00:33:09,440
and the second piece is bit by bit we

00:33:08,559 --> 00:33:12,640
want to compile

00:33:09,440 --> 00:33:15,279
kernel source code directly into the app

00:33:12,640 --> 00:33:16,880
right into that symbiote address space

00:33:15,279 --> 00:33:19,039
and finally if you want to go

00:33:16,880 --> 00:33:20,399
the whole way you can then specialize

00:33:19,039 --> 00:33:23,440
those kernel paths

00:33:20,399 --> 00:33:24,159
to the application itself right so

00:33:23,440 --> 00:33:27,200
within

00:33:24,159 --> 00:33:28,080
symbiosis right your your building of

00:33:27,200 --> 00:33:30,000
processes

00:33:28,080 --> 00:33:31,919
is it looks pretty standard you take

00:33:30,000 --> 00:33:33,919
your app throw it through the compiler

00:33:31,919 --> 00:33:37,919
and you get out an executable

00:33:33,919 --> 00:33:38,640
um and uh similar to compiling linux

00:33:37,919 --> 00:33:40,080
because this

00:33:38,640 --> 00:33:42,240
is linux with some very small

00:33:40,080 --> 00:33:43,279
modifications we'll compile that kernel

00:33:42,240 --> 00:33:46,320
source code

00:33:43,279 --> 00:33:47,679
and and get out our symbiosis kernel on

00:33:46,320 --> 00:33:50,000
the other side

00:33:47,679 --> 00:33:50,000
um

00:33:51,440 --> 00:33:54,960
now if you're if you're doing a

00:33:53,519 --> 00:33:58,640
unikernel-like build

00:33:54,960 --> 00:34:00,320
right so we can take ukl and an app

00:33:58,640 --> 00:34:02,640
throw that through a compiler and get

00:34:00,320 --> 00:34:04,159
out a symbiote executable

00:34:02,640 --> 00:34:06,000
um but still we're doing the same thing

00:34:04,159 --> 00:34:08,159
on the other side we still just have our

00:34:06,000 --> 00:34:09,839
symbiote kernel that's going to support

00:34:08,159 --> 00:34:11,119
this thing just like it supports a

00:34:09,839 --> 00:34:12,800
process

00:34:11,119 --> 00:34:14,560
and now here let's deal with what's in

00:34:12,800 --> 00:34:15,919
between right so

00:34:14,560 --> 00:34:18,800
the idea here is that we're going to

00:34:15,919 --> 00:34:20,800
take application source code

00:34:18,800 --> 00:34:22,800
and we're going to try to turn this

00:34:20,800 --> 00:34:24,320
thing into a symbiote which is taking

00:34:22,800 --> 00:34:25,919
advantage of some of these unicorn

00:34:24,320 --> 00:34:27,679
optimizations

00:34:25,919 --> 00:34:29,760
and the idea here is that we can think

00:34:27,679 --> 00:34:30,960
of this kernel code as being comprised

00:34:29,760 --> 00:34:34,320
of a number of

00:34:30,960 --> 00:34:36,480
independent or a number of code paths

00:34:34,320 --> 00:34:37,440
and the idea is to replicate some of

00:34:36,480 --> 00:34:39,760
those code paths

00:34:37,440 --> 00:34:41,359
into that application source right so

00:34:39,760 --> 00:34:42,960
maybe you've identified a really hot

00:34:41,359 --> 00:34:44,240
path right this system call is just

00:34:42,960 --> 00:34:45,679
getting hammered

00:34:44,240 --> 00:34:47,599
and now the idea is we're going to bring

00:34:45,679 --> 00:34:49,679
it into the application domain

00:34:47,599 --> 00:34:50,720
and fuse it into the application code

00:34:49,679 --> 00:34:52,159
path right

00:34:50,720 --> 00:34:54,399
taking advantage of compile time

00:34:52,159 --> 00:34:58,000
optimizations and taking

00:34:54,399 --> 00:35:01,200
a step towards a full-blown uni kernel

00:34:58,000 --> 00:35:03,760
right and so

00:35:01,200 --> 00:35:05,359
that's system code running in the

00:35:03,760 --> 00:35:07,280
application space right this is going to

00:35:05,359 --> 00:35:08,640
run in ring zero we're not talking about

00:35:07,280 --> 00:35:10,720
a process

00:35:08,640 --> 00:35:12,880
but simultaneously every other system

00:35:10,720 --> 00:35:14,720
call that this application makes is

00:35:12,880 --> 00:35:18,000
gonna go through the normal gates

00:35:14,720 --> 00:35:20,400
right so this is not by any means a

00:35:18,000 --> 00:35:21,440
hermetically sealed unicorn either right

00:35:20,400 --> 00:35:22,800
and so in this sense

00:35:21,440 --> 00:35:25,280
it's it's living somewhere in this

00:35:22,800 --> 00:35:27,200
liminal space

00:35:25,280 --> 00:35:29,920
so now going through those three steps

00:35:27,200 --> 00:35:30,240
right escalating a process right so we

00:35:29,920 --> 00:35:32,400
can

00:35:30,240 --> 00:35:34,320
boot the symbiotic kernel on hardware

00:35:32,400 --> 00:35:35,359
this is essentially booting linux right

00:35:34,320 --> 00:35:37,440
we just have it

00:35:35,359 --> 00:35:38,480
we just have added to this thing the

00:35:37,440 --> 00:35:42,320
ability to

00:35:38,480 --> 00:35:45,839
elevate a process so we boot symbio

00:35:42,320 --> 00:35:47,760
uh symbiosis on some hardware and

00:35:45,839 --> 00:35:48,880
let's be clear here once that

00:35:47,760 --> 00:35:51,119
application calls

00:35:48,880 --> 00:35:52,240
escalate there's no longer any pretense

00:35:51,119 --> 00:35:54,079
of security right

00:35:52,240 --> 00:35:56,400
the symbiote is in full control of the

00:35:54,079 --> 00:35:58,000
system now it has the keys to the castle

00:35:56,400 --> 00:35:59,599
and we're assuming a non-it's not

00:35:58,000 --> 00:36:01,680
adversarial with respect to the other

00:35:59,599 --> 00:36:04,640
processes in the system

00:36:01,680 --> 00:36:06,079
and in this step we've taken we've moved

00:36:04,640 --> 00:36:08,640
out of the world of processes

00:36:06,079 --> 00:36:09,280
into the world of symbiotes where you

00:36:08,640 --> 00:36:10,839
can make

00:36:09,280 --> 00:36:12,560
direct calls to internal kernel

00:36:10,839 --> 00:36:14,320
interfaces

00:36:12,560 --> 00:36:16,640
we can eliminate those hardware

00:36:14,320 --> 00:36:18,960
privileged domain crossing expenses

00:36:16,640 --> 00:36:20,880
and but keep in mind that we can still

00:36:18,960 --> 00:36:23,040
exercise that system call interface you

00:36:20,880 --> 00:36:25,920
can still open a file read write

00:36:23,040 --> 00:36:26,640
send receive we're trying to preserve

00:36:25,920 --> 00:36:28,480
that

00:36:26,640 --> 00:36:29,839
um to keep those general purpose

00:36:28,480 --> 00:36:32,320
properties so

00:36:29,839 --> 00:36:33,200
with respect to the scope right so we

00:36:32,320 --> 00:36:36,640
started with

00:36:33,200 --> 00:36:38,240
running uni kernels as the sole

00:36:36,640 --> 00:36:40,240
controlling entities of either a

00:36:38,240 --> 00:36:41,599
hardware node or a virtual machine

00:36:40,240 --> 00:36:43,520
and we're just trying to broaden it out

00:36:41,599 --> 00:36:45,280
a little bit right you run your uni

00:36:43,520 --> 00:36:48,079
kernel and it's supporting

00:36:45,280 --> 00:36:49,200
cronies right uh it's not saying you

00:36:48,079 --> 00:36:51,200
should run a hundred

00:36:49,200 --> 00:36:52,800
applications simultaneously in this

00:36:51,200 --> 00:36:54,640
model but

00:36:52,800 --> 00:36:56,720
maybe you could take each of those

00:36:54,640 --> 00:36:57,760
applications where each app could be

00:36:56,720 --> 00:37:00,880
multiple processes

00:36:57,760 --> 00:37:03,200
run them in their own vms uh

00:37:00,880 --> 00:37:04,880
so so we're just expanding that scope a

00:37:03,200 --> 00:37:07,040
little bit

00:37:04,880 --> 00:37:08,079
so to this second piece right compiling

00:37:07,040 --> 00:37:11,599
system code

00:37:08,079 --> 00:37:14,240
into a symbiote right so this is the

00:37:11,599 --> 00:37:16,160
iterative procedure by which we can move

00:37:14,240 --> 00:37:17,920
ourselves along that spectrum from

00:37:16,160 --> 00:37:19,440
process to unikernel

00:37:17,920 --> 00:37:21,280
right so and you can start with a

00:37:19,440 --> 00:37:23,119
full-blown process

00:37:21,280 --> 00:37:24,720
profile it find out where your time is

00:37:23,119 --> 00:37:26,320
being spent in the system

00:37:24,720 --> 00:37:28,640
which system calls are taking the

00:37:26,320 --> 00:37:30,960
longest and then

00:37:28,640 --> 00:37:32,240
pull those out of the kernel and up into

00:37:30,960 --> 00:37:34,240
your application

00:37:32,240 --> 00:37:36,320
compiling them together right and the

00:37:34,240 --> 00:37:39,760
idea is through this process you can

00:37:36,320 --> 00:37:41,359
uh eliminate bottleneck after bottleneck

00:37:39,760 --> 00:37:42,960
moving yourself to it towards a more

00:37:41,359 --> 00:37:45,440
optimized point

00:37:42,960 --> 00:37:46,320
now i don't know if that sounded easy

00:37:45,440 --> 00:37:47,920
but i

00:37:46,320 --> 00:37:49,359
it's not at all right so there's a ton

00:37:47,920 --> 00:37:51,680
of challenges here right

00:37:49,359 --> 00:37:53,520
how do you or or how does your compiler

00:37:51,680 --> 00:37:55,839
know that you've grabbed that whole

00:37:53,520 --> 00:37:56,880
transitive closure that whole function

00:37:55,839 --> 00:37:59,359
call graph that's

00:37:56,880 --> 00:38:00,720
that's going to be hit as you traverse

00:37:59,359 --> 00:38:02,560
that system call right

00:38:00,720 --> 00:38:04,000
is there virtual dispatch is there just

00:38:02,560 --> 00:38:05,680
indirection how many

00:38:04,000 --> 00:38:07,920
times are you going to get burned as you

00:38:05,680 --> 00:38:10,560
try to grab that code path

00:38:07,920 --> 00:38:12,240
another observation is that if you just

00:38:10,560 --> 00:38:14,880
copy the exact code

00:38:12,240 --> 00:38:16,480
that's great it's it's going to work if

00:38:14,880 --> 00:38:18,880
it's if it's sharing the same

00:38:16,480 --> 00:38:20,800
underlying kernel data structures right

00:38:18,880 --> 00:38:23,599
so sharing locks

00:38:20,800 --> 00:38:25,040
uh synchronizing with respect to that

00:38:23,599 --> 00:38:26,960
outer running kernel

00:38:25,040 --> 00:38:28,160
um but what happens as you begin to

00:38:26,960 --> 00:38:30,240
optimize that

00:38:28,160 --> 00:38:31,359
right and especially as you begin to

00:38:30,240 --> 00:38:33,760
specialize it

00:38:31,359 --> 00:38:34,800
um are you going to get yourself in a

00:38:33,760 --> 00:38:37,359
lot of trouble

00:38:34,800 --> 00:38:38,560
now this would be really easy if linux

00:38:37,359 --> 00:38:41,200
were a modular

00:38:38,560 --> 00:38:42,640
library operating system but i think

00:38:41,200 --> 00:38:44,240
there's a cool property here there's a

00:38:42,640 --> 00:38:45,920
synergy with ukl where

00:38:44,240 --> 00:38:48,400
if we can find effective ways to

00:38:45,920 --> 00:38:49,839
modularize the components of linux

00:38:48,400 --> 00:38:51,599
that's going to be able to move it right

00:38:49,839 --> 00:38:53,119
back up to ukl because they're going to

00:38:51,599 --> 00:38:54,880
want to be only pulling in

00:38:53,119 --> 00:38:56,320
the components of the system that serve

00:38:54,880 --> 00:38:58,480
the app

00:38:56,320 --> 00:39:00,079
so wrapping up here right through this

00:38:58,480 --> 00:39:02,160
scheme the idea is that

00:39:00,079 --> 00:39:03,280
we wind up starting with a process and

00:39:02,160 --> 00:39:05,839
enumerating

00:39:03,280 --> 00:39:06,720
many of these points in between right as

00:39:05,839 --> 00:39:09,040
we

00:39:06,720 --> 00:39:10,560
march down to building a full unicredle

00:39:09,040 --> 00:39:12,000
right the idea being if you replace

00:39:10,560 --> 00:39:14,000
every system call

00:39:12,000 --> 00:39:16,720
you eventually just wind up with a

00:39:14,000 --> 00:39:19,760
full-blown uni kernel

00:39:16,720 --> 00:39:21,119
uh and so i'll conclude there my email

00:39:19,760 --> 00:39:23,599
address is on the slide

00:39:21,119 --> 00:39:24,720
uh if you know this is impossible if you

00:39:23,599 --> 00:39:27,760
have a different

00:39:24,720 --> 00:39:29,200
take on it if uh if you

00:39:27,760 --> 00:39:31,200
just have a better idea please share it

00:39:29,200 --> 00:39:33,760
with me i could help me save a lot of

00:39:31,200 --> 00:39:33,760
time thanks

00:39:38,400 --> 00:39:44,240
um ellie i think you might be muted

00:39:42,079 --> 00:39:45,760
true thanks a lot tommy that was really

00:39:44,240 --> 00:39:47,440
interesting and uh

00:39:45,760 --> 00:39:49,200
really excited to you know what's next

00:39:47,440 --> 00:39:51,119
i'll quickly in the

00:39:49,200 --> 00:39:52,720
couple of minutes i'll just wrap up what

00:39:51,119 --> 00:39:53,200
are other research directions that we

00:39:52,720 --> 00:39:55,520
can

00:39:53,200 --> 00:39:56,320
take on with uk there's still things to

00:39:55,520 --> 00:39:58,240
do we need to run

00:39:56,320 --> 00:39:59,920
uh micro benchmarks to test this call

00:39:58,240 --> 00:40:01,680
functionality we need to run

00:39:59,920 --> 00:40:03,440
uh better experiments with high speed

00:40:01,680 --> 00:40:07,040
virtual network we need to run

00:40:03,440 --> 00:40:09,200
experiments bare metal um i actually

00:40:07,040 --> 00:40:10,720
ran some uh uk bare metal numbers last

00:40:09,200 --> 00:40:12,160
night and we had some good numbers but

00:40:10,720 --> 00:40:13,440
we need to do some hardware debugging

00:40:12,160 --> 00:40:15,280
right now to iron

00:40:13,440 --> 00:40:17,200
out some of the corner cases on real

00:40:15,280 --> 00:40:17,920
hardware we need to get reproducible

00:40:17,200 --> 00:40:19,920
results

00:40:17,920 --> 00:40:21,920
and we need to have something like perf

00:40:19,920 --> 00:40:24,960
running which attributes performance

00:40:21,920 --> 00:40:27,359
differences uh to under like reasons

00:40:24,960 --> 00:40:29,520
uh we are now at a very interesting

00:40:27,359 --> 00:40:31,040
stage uk is fairly solid and reliable

00:40:29,520 --> 00:40:33,520
and we are ready to explore

00:40:31,040 --> 00:40:35,200
uh many directions uh do we expect

00:40:33,520 --> 00:40:38,800
ukelel to perform better than

00:40:35,200 --> 00:40:39,280
a normal linux uh or do we uh expect it

00:40:38,800 --> 00:40:42,640
to

00:40:39,280 --> 00:40:44,480
perform comparable to research in the

00:40:42,640 --> 00:40:45,520
kernels or not can we surpass linux in

00:40:44,480 --> 00:40:48,240
terms of performance

00:40:45,520 --> 00:40:48,560
boot time memory footprint etc so it's

00:40:48,240 --> 00:40:50,720
all

00:40:48,560 --> 00:40:52,880
uh very interesting and we're all we are

00:40:50,720 --> 00:40:53,440
at a point right now that we can explore

00:40:52,880 --> 00:40:56,800
these

00:40:53,440 --> 00:41:00,079
directions uh the

00:40:56,800 --> 00:41:00,800
interesting thing is that now uh we can

00:41:00,079 --> 00:41:02,400
look at

00:41:00,800 --> 00:41:03,839
optimization such as link time

00:41:02,400 --> 00:41:05,119
optimizations and profile driven

00:41:03,839 --> 00:41:06,560
optimizations

00:41:05,119 --> 00:41:09,200
this is especially interesting because

00:41:06,560 --> 00:41:11,599
now we have a chance to run all the code

00:41:09,200 --> 00:41:13,839
application code glibc code kernel code

00:41:11,599 --> 00:41:15,440
through a single compile and link stage

00:41:13,839 --> 00:41:16,960
what benefits can we get there can we

00:41:15,440 --> 00:41:18,720
shorten different code paths can we

00:41:16,960 --> 00:41:21,280
remove things like copy from user and

00:41:18,720 --> 00:41:22,640
copy to user so all of this is extremely

00:41:21,280 --> 00:41:24,240
interesting

00:41:22,640 --> 00:41:25,839
we also need to replicate some of the

00:41:24,240 --> 00:41:26,720
research done with other uni kernels and

00:41:25,839 --> 00:41:29,760
see if we can get

00:41:26,720 --> 00:41:31,520
similar results community help is always

00:41:29,760 --> 00:41:32,160
welcome we are experimenting breaking

00:41:31,520 --> 00:41:34,079
things

00:41:32,160 --> 00:41:36,400
and learning along the way please join

00:41:34,079 --> 00:41:37,760
us and help out if you are excited about

00:41:36,400 --> 00:41:39,599
ukl and

00:41:37,760 --> 00:41:41,040
our team has grown a lot since we

00:41:39,599 --> 00:41:42,880
started and new members are always

00:41:41,040 --> 00:41:46,720
welcome and new members have always

00:41:42,880 --> 00:41:49,119
uh made ukl uh better so we we are

00:41:46,720 --> 00:41:50,079
excited about that thank you i think

00:41:49,119 --> 00:41:54,640
we're just

00:41:50,079 --> 00:41:54,640
within time uh thanks a lot

00:41:56,079 --> 00:42:00,960
thank you both very much uh we

00:41:59,280 --> 00:42:07,839
appreciate your time and that was an

00:42:00,960 --> 00:42:07,839

YouTube URL: https://www.youtube.com/watch?v=_OV7o8yImYo


