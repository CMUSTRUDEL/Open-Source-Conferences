Title: Accelerating TCP in Userspace Virtual Switching
Publication date: 2020-10-06
Playlist: DevConfUS 2020
Description: 
	Speaker: Flavio Leitner

Open vSwitch (OVS) is the most common virtual switch. It is known to provide the most significant performance improvement handling medium-to-small network packets when accelerated with DPDK, if compared with Linux network stack.

However, networks nowadays have to deal with all sorts of packet sizes and this was the motivation to implement TCP Segmentation Offload (TSO) support in OVS-DPDK.

This talk will explain the feature's current status, implementation, performance comparisons, and future plans.
Captions: 
	00:00:00,640 --> 00:00:09,759
hello everyone uh welcome to devconf

00:00:04,080 --> 00:00:09,759
uh and we'll get flowers talk

00:00:10,080 --> 00:00:13,120
on accelerating tcp and user space

00:00:12,000 --> 00:00:16,000
social switching

00:00:13,120 --> 00:00:16,480
uh i i have shared the link and it's

00:00:16,000 --> 00:00:19,279
pinned

00:00:16,480 --> 00:00:20,320
so you guys if in case hop in breaks out

00:00:19,279 --> 00:00:22,400
you can go and watch

00:00:20,320 --> 00:00:23,600
the youtube video but be sure to have

00:00:22,400 --> 00:00:24,880
this tab open so that you can

00:00:23,600 --> 00:00:27,920
participate in the

00:00:24,880 --> 00:00:31,840
live q a so i'll be uh

00:00:27,920 --> 00:00:31,840
beginning with the video now

00:00:33,040 --> 00:00:37,440
hello thanks for attending this my

00:00:35,760 --> 00:00:40,480
name is vlad lightner

00:00:37,440 --> 00:00:40,480
i work for redhead

00:00:41,760 --> 00:00:45,120
with that said let's go over slide

00:00:43,840 --> 00:00:48,800
number three into

00:00:45,120 --> 00:00:48,800
the slide the agenda slide

00:00:48,960 --> 00:00:53,760
okay let me go over it again to give you

00:00:51,039 --> 00:00:56,239
an idea on how to stop group development

00:00:53,760 --> 00:00:58,079
so first i will talk about why using the

00:00:56,239 --> 00:01:00,559
user space telepath

00:00:58,079 --> 00:01:01,520
and then present to you two typical use

00:01:00,559 --> 00:01:04,320
cases

00:01:01,520 --> 00:01:05,119
that work the motivation for this work

00:01:04,320 --> 00:01:07,680
and then

00:01:05,119 --> 00:01:08,640
i will discuss the packet sizes and the

00:01:07,680 --> 00:01:12,400
shifted

00:01:08,640 --> 00:01:13,439
tcp packets after that i'm going to

00:01:12,400 --> 00:01:16,080
present to you

00:01:13,439 --> 00:01:18,000
the proposed solution which is the tcp

00:01:16,080 --> 00:01:20,720
segmentation upload

00:01:18,000 --> 00:01:23,040
followed by the some key implementation

00:01:20,720 --> 00:01:26,560
details i hope that

00:01:23,040 --> 00:01:29,920
these key uh implementation details

00:01:26,560 --> 00:01:31,759
helps you to understand the sources if

00:01:29,920 --> 00:01:33,520
you want to check out them

00:01:31,759 --> 00:01:35,040
and you know navigate through the

00:01:33,520 --> 00:01:37,439
sources

00:01:35,040 --> 00:01:39,280
and then of course i will provide some

00:01:37,439 --> 00:01:42,320
performance numbers comparing

00:01:39,280 --> 00:01:45,840
with and without tissue and wrap

00:01:42,320 --> 00:01:48,320
up talking about some limitations in

00:01:45,840 --> 00:01:50,079
future work

00:01:48,320 --> 00:01:52,159
with that side let's go to the next

00:01:50,079 --> 00:01:54,640
slide user space data path

00:01:52,159 --> 00:01:57,520
what is the user space database it

00:01:54,640 --> 00:01:59,680
allows networking package processing

00:01:57,520 --> 00:02:00,880
without using the kernel stack so

00:01:59,680 --> 00:02:03,920
basically

00:02:00,880 --> 00:02:06,079
uh thanks to dpdk we can receive

00:02:03,920 --> 00:02:07,280
packets from the network card directly

00:02:06,079 --> 00:02:09,599
in user space

00:02:07,280 --> 00:02:11,440
then obviously can process the packet

00:02:09,599 --> 00:02:13,520
completely in user space

00:02:11,440 --> 00:02:15,760
and then send out this packet either to

00:02:13,520 --> 00:02:17,040
a group machine or to another physical

00:02:15,760 --> 00:02:19,760
device

00:02:17,040 --> 00:02:22,879
and everything happens completely in

00:02:19,760 --> 00:02:26,000
user space by passing the kernel stack

00:02:22,879 --> 00:02:29,360
but why we want to do that well

00:02:26,000 --> 00:02:30,959
because processing is multimedia packet

00:02:29,360 --> 00:02:34,879
sizes and i'm talking

00:02:30,959 --> 00:02:38,400
about 64 bytes packets of

00:02:34,879 --> 00:02:40,879
128 bytes or 256 bytes

00:02:38,400 --> 00:02:42,560
and processing them in user space is

00:02:40,879 --> 00:02:45,599
faster

00:02:42,560 --> 00:02:48,959
but how how can we do this well using uh

00:02:45,599 --> 00:02:52,160
tpdks annotated open this switch

00:02:48,959 --> 00:02:54,959
also known as obvious dpdk uh

00:02:52,160 --> 00:02:55,840
dpdk provides you the drivers to have

00:02:54,959 --> 00:02:58,400
access to

00:02:55,840 --> 00:02:59,360
physical devices in completely user

00:02:58,400 --> 00:03:01,280
space

00:02:59,360 --> 00:03:04,159
and then the open switches they explain

00:03:01,280 --> 00:03:06,480
it can do all the processing

00:03:04,159 --> 00:03:07,280
completely in user space and then send

00:03:06,480 --> 00:03:09,440
out

00:03:07,280 --> 00:03:10,800
uh to a virtual machine or to another

00:03:09,440 --> 00:03:14,080
device

00:03:10,800 --> 00:03:17,599
all right and also where where

00:03:14,080 --> 00:03:20,959
can we do this the most common use case

00:03:17,599 --> 00:03:23,440
is inside of hypervisors to provide

00:03:20,959 --> 00:03:27,120
connectivity to virtual machines

00:03:23,440 --> 00:03:30,080
okay that said let's go to

00:03:27,120 --> 00:03:32,480
slide number five this is the first

00:03:30,080 --> 00:03:33,440
typical use case i want to present to

00:03:32,480 --> 00:03:36,959
you

00:03:33,440 --> 00:03:38,239
uh this is called physical to crypto to

00:03:36,959 --> 00:03:42,080
physical

00:03:38,239 --> 00:03:44,640
or pvp there are some

00:03:42,080 --> 00:03:46,000
documentations out there or some blogs

00:03:44,640 --> 00:03:49,200
out there referencing

00:03:46,000 --> 00:03:50,080
as pvp so that means physical to their

00:03:49,200 --> 00:03:53,040
goal to feel

00:03:50,080 --> 00:03:54,000
to physical and it's basically a

00:03:53,040 --> 00:03:56,290
hypervisor

00:03:54,000 --> 00:03:58,319
running of the sdpdk

00:03:56,290 --> 00:04:00,799
[Music]

00:03:58,319 --> 00:04:01,599
connected to a virtual machine and also

00:04:00,799 --> 00:04:04,640
to a

00:04:01,599 --> 00:04:06,159
network card so packets come in through

00:04:04,640 --> 00:04:09,200
the network card goes

00:04:06,159 --> 00:04:11,360
uh through the sdp in the case

00:04:09,200 --> 00:04:12,799
of the sdpdk and loops back in the

00:04:11,360 --> 00:04:17,280
virtual machine

00:04:12,799 --> 00:04:19,680
to the network so this network could be

00:04:17,280 --> 00:04:21,440
other hypervisors to build a cloud for

00:04:19,680 --> 00:04:23,840
instance you can have

00:04:21,440 --> 00:04:26,960
many hypervisors or you can have for

00:04:23,840 --> 00:04:29,680
instance a traffic generator

00:04:26,960 --> 00:04:32,080
pushing packets to measure throughput or

00:04:29,680 --> 00:04:35,120
to measure latency or jitter

00:04:32,080 --> 00:04:39,040
so this is an interesting scenario uh

00:04:35,120 --> 00:04:42,160
to measure the the the overall solution

00:04:39,040 --> 00:04:45,040
capacity okay

00:04:42,160 --> 00:04:45,840
so moving to the next slide is the

00:04:45,040 --> 00:04:48,639
second

00:04:45,840 --> 00:04:51,280
uh typical use case it's called vehicle

00:04:48,639 --> 00:04:54,880
to redo or v2v

00:04:51,280 --> 00:04:56,960
it's basically one hypervisor running uh

00:04:54,880 --> 00:04:58,960
two or more virtual machines and

00:04:56,960 --> 00:05:00,720
obviously decay

00:04:58,960 --> 00:05:02,400
and this obviously pdk again is

00:05:00,720 --> 00:05:05,759
completely in user space

00:05:02,400 --> 00:05:08,560
providing network connectivity to

00:05:05,759 --> 00:05:10,240
those virtual machines so one virtual

00:05:08,560 --> 00:05:11,360
machine sent packers it goes through

00:05:10,240 --> 00:05:14,240
obviously pdk

00:05:11,360 --> 00:05:16,560
and back and then to the other virtual

00:05:14,240 --> 00:05:20,639
machine

00:05:16,560 --> 00:05:26,080
okay the next slide

00:05:20,639 --> 00:05:26,080
is shifted to large payloads so

00:05:26,240 --> 00:05:32,720
when the user space uh

00:05:29,440 --> 00:05:36,080
database processing uh

00:05:32,720 --> 00:05:39,199
the obs dpdk actually

00:05:36,080 --> 00:05:41,520
in the beginning we focus a lot in this

00:05:39,199 --> 00:05:43,919
multimedia packets because

00:05:41,520 --> 00:05:45,919
for a few reasons uh one of them is that

00:05:43,919 --> 00:05:49,120
the 64 byte package is

00:05:45,919 --> 00:05:51,680
used for benchmark purposes so

00:05:49,120 --> 00:05:53,039
if you want to compare switches or

00:05:51,680 --> 00:05:56,400
routers

00:05:53,039 --> 00:06:00,800
usually it's done using the performance

00:05:56,400 --> 00:06:03,919
when using the six six four pipe packets

00:06:00,800 --> 00:06:04,720
and that's because uh this is the worst

00:06:03,919 --> 00:06:07,840
situation

00:06:04,720 --> 00:06:11,280
in the network right you have

00:06:07,840 --> 00:06:13,199
very little data per packet

00:06:11,280 --> 00:06:15,600
and you have headers so you have a lot

00:06:13,199 --> 00:06:18,800
of headers to process per second

00:06:15,600 --> 00:06:18,800
and not much data

00:06:18,880 --> 00:06:26,160
and also because one of the big pushers

00:06:22,880 --> 00:06:28,639
for gas tpdk or for fast packet

00:06:26,160 --> 00:06:32,000
processing is the tacos

00:06:28,639 --> 00:06:33,840
are the tables that telcos use they rely

00:06:32,000 --> 00:06:36,960
on this

00:06:33,840 --> 00:06:40,560
to meet your packet sizes

00:06:36,960 --> 00:06:42,960
but uh as we saw

00:06:40,560 --> 00:06:43,840
over the years the environments are not

00:06:42,960 --> 00:06:47,039
as specific

00:06:43,840 --> 00:06:49,360
so you might have a purple machine

00:06:47,039 --> 00:06:50,240
processing signaling for instance which

00:06:49,360 --> 00:06:53,120
uses

00:06:50,240 --> 00:06:53,680
small to medium packet sizes but there

00:06:53,120 --> 00:06:56,720
might be

00:06:53,680 --> 00:06:57,919
other vms requiring regular tcp

00:06:56,720 --> 00:07:01,440
connections so

00:06:57,919 --> 00:07:02,560
other sizes matter now and we want to

00:07:01,440 --> 00:07:05,280
expand

00:07:02,560 --> 00:07:06,400
the user-space telepath to other user

00:07:05,280 --> 00:07:08,639
cases as well

00:07:06,400 --> 00:07:10,479
so i'll give you one example here which

00:07:08,639 --> 00:07:13,520
is terrible slowly if you want to

00:07:10,479 --> 00:07:14,400
send packets from the virgo machine to a

00:07:13,520 --> 00:07:18,039
bridge

00:07:14,400 --> 00:07:21,199
to the bridge port it will be

00:07:18,039 --> 00:07:24,240
860 megabits per second so

00:07:21,199 --> 00:07:26,560
for today's standards um this is pretty

00:07:24,240 --> 00:07:26,560
slow

00:07:27,759 --> 00:07:32,720
uh so what's the solution the proposed

00:07:30,560 --> 00:07:36,319
solution is already known this old

00:07:32,720 --> 00:07:40,080
it's called tsu and

00:07:36,319 --> 00:07:41,440
tso basically means instead of the

00:07:40,080 --> 00:07:45,840
networking stack

00:07:41,440 --> 00:07:45,840
spend cpu time cpu resources

00:07:46,879 --> 00:07:54,400
splitting this big chunk of data

00:07:49,919 --> 00:07:58,319
let's say that an application route 32k

00:07:54,400 --> 00:07:59,440
of data to a buffer instead of spending

00:07:58,319 --> 00:08:02,639
cpu resources

00:07:59,440 --> 00:08:05,199
splitting this 32k into smaller pieces

00:08:02,639 --> 00:08:09,280
that fits into the network

00:08:05,199 --> 00:08:12,639
uh it will just send one single packet

00:08:09,280 --> 00:08:15,360
with 32 uh off data

00:08:12,639 --> 00:08:15,840
and add the hackers but if this is going

00:08:15,360 --> 00:08:18,479
through

00:08:15,840 --> 00:08:19,360
the place that's the physical network

00:08:18,479 --> 00:08:22,639
card

00:08:19,360 --> 00:08:26,000
so that saves a lot of

00:08:22,639 --> 00:08:29,680
cpu resources in the host and speeds up

00:08:26,000 --> 00:08:31,120
a lot because we don't have the cpu

00:08:29,680 --> 00:08:33,760
overhead to process

00:08:31,120 --> 00:08:36,640
each and every header we just have one

00:08:33,760 --> 00:08:40,159
header followed by a picture container

00:08:36,640 --> 00:08:41,760
so that's where uh jso improves the

00:08:40,159 --> 00:08:43,919
performance

00:08:41,760 --> 00:08:46,399
it's a low technique available in most

00:08:43,919 --> 00:08:48,560
of the commercial network cards nowadays

00:08:46,399 --> 00:08:52,320
even the one gigabit cards

00:08:48,560 --> 00:08:55,360
most of them uh support their tsu

00:08:52,320 --> 00:08:55,839
and this feature is already available in

00:08:55,360 --> 00:08:57,920
the

00:08:55,839 --> 00:09:00,480
in the current in a path with great

00:08:57,920 --> 00:09:02,880
episodes so we expect to have

00:09:00,480 --> 00:09:05,200
uh the same great episodes in the user

00:09:02,880 --> 00:09:05,200
space

00:09:05,600 --> 00:09:12,560
okay going to the next slide

00:09:09,360 --> 00:09:13,839
let's talk about the tts the tso support

00:09:12,560 --> 00:09:16,959
in the network card

00:09:13,839 --> 00:09:21,120
the physical card so basically

00:09:16,959 --> 00:09:24,480
obviously pdk relies on the dpdk

00:09:21,120 --> 00:09:27,600
to provide the drivers and that means we

00:09:24,480 --> 00:09:30,480
use the pull mode timers

00:09:27,600 --> 00:09:32,399
uh most of these puma drivers they call

00:09:30,480 --> 00:09:35,279
they are called pmds

00:09:32,399 --> 00:09:36,560
they already support isro so not only

00:09:35,279 --> 00:09:39,440
the

00:09:36,560 --> 00:09:41,279
the network card the hardware itself

00:09:39,440 --> 00:09:44,320
supports this tool but also the

00:09:41,279 --> 00:09:47,680
emps so but still

00:09:44,320 --> 00:09:51,839
we need to change obs to enable this

00:09:47,680 --> 00:09:51,839
feature and also to prepare

00:09:52,720 --> 00:09:55,779
[Music]

00:10:03,279 --> 00:10:10,800
discard uh basically

00:10:06,720 --> 00:10:14,079
we are setting the tcp tsu

00:10:10,800 --> 00:10:17,440
flag also dcb check sound flag

00:10:14,079 --> 00:10:20,480
and the ipv4 tracksum flap the

00:10:17,440 --> 00:10:21,839
checksums are required because when you

00:10:20,480 --> 00:10:24,240
segment

00:10:21,839 --> 00:10:25,040
the packets you will create a brand a

00:10:24,240 --> 00:10:27,600
brand new

00:10:25,040 --> 00:10:28,880
uh packet and then the tracksum needs to

00:10:27,600 --> 00:10:32,959
be updated

00:10:28,880 --> 00:10:35,120
so they are if you want to have the tsu

00:10:32,959 --> 00:10:36,959
enable you also need to have the check

00:10:35,120 --> 00:10:40,160
summing enabled

00:10:36,959 --> 00:10:41,279
so we've set these flags in the dx mode

00:10:40,160 --> 00:10:45,040
of load flags

00:10:41,279 --> 00:10:45,040
and then pass that to the device

00:10:45,519 --> 00:10:52,079
and then the pmd will automatically

00:10:48,720 --> 00:10:55,600
will understand tso packets

00:10:52,079 --> 00:10:57,440
from now on but in order to pass these

00:10:55,600 --> 00:11:00,000
packets we also need to

00:10:57,440 --> 00:11:01,680
prepare them so there is a new function

00:11:00,000 --> 00:11:04,720
called that fpdk

00:11:01,680 --> 00:11:08,160
prep how to offload packet

00:11:04,720 --> 00:11:11,360
which will send some offsets and

00:11:08,160 --> 00:11:13,600
some header offsets and the packet

00:11:11,360 --> 00:11:14,800
in order to allow the hardware to do its

00:11:13,600 --> 00:11:18,000
job

00:11:14,800 --> 00:11:19,200
so those were the two key changes in obs

00:11:18,000 --> 00:11:22,720
to allow tesla

00:11:19,200 --> 00:11:22,720
support in the network card

00:11:23,040 --> 00:11:26,839
let's talk about now the support for the

00:11:25,279 --> 00:11:28,970
host user

00:11:26,839 --> 00:11:30,800
so uh

00:11:28,970 --> 00:11:33,760
[Music]

00:11:30,800 --> 00:11:34,000
obvious connects virtual machine using

00:11:33,760 --> 00:11:36,920
the

00:11:34,000 --> 00:11:39,980
host user this is the uh

00:11:36,920 --> 00:11:39,980
[Music]

00:11:40,320 --> 00:11:46,640
it's a driver is it it's the interface

00:11:43,360 --> 00:11:50,560
that connects the virtual machine

00:11:46,640 --> 00:11:51,920
with ovsdpdk but different from the

00:11:50,560 --> 00:11:57,040
physical

00:11:51,920 --> 00:11:57,040
devices we don't use the pmd

00:11:57,120 --> 00:12:04,959
library directly and that's because

00:12:01,200 --> 00:12:06,160
in the past uh the devos usability

00:12:04,959 --> 00:12:09,680
wasn't available

00:12:06,160 --> 00:12:10,800
so we started using the host library

00:12:09,680 --> 00:12:13,279
directly

00:12:10,800 --> 00:12:14,720
and maybe this will change the feature

00:12:13,279 --> 00:12:18,240
but at this point

00:12:14,720 --> 00:12:19,920
the support uh is added on the using the

00:12:18,240 --> 00:12:24,000
host library directly

00:12:19,920 --> 00:12:26,560
okay but still with required changes in

00:12:24,000 --> 00:12:29,120
this people's library which is

00:12:26,560 --> 00:12:31,360
part of the dpdk project to work with

00:12:29,120 --> 00:12:34,639
external buffers

00:12:31,360 --> 00:12:36,720
so what's the external offers to support

00:12:34,639 --> 00:12:40,000
seo we have pretty much two options

00:12:36,720 --> 00:12:40,639
one of them is working with smaller

00:12:40,000 --> 00:12:43,839
buffers

00:12:40,639 --> 00:12:48,000
and then chain them one after another

00:12:43,839 --> 00:12:50,240
or work with a bigger a bigger buffer

00:12:48,000 --> 00:12:51,600
when we work with the big buffer the

00:12:50,240 --> 00:12:54,639
advantage is that

00:12:51,600 --> 00:12:57,839
we don't need to worry about

00:12:54,639 --> 00:13:00,639
when one buffer is ending and

00:12:57,839 --> 00:13:02,320
when the buffer is starting so let's say

00:13:00,639 --> 00:13:04,160
we want to shift

00:13:02,320 --> 00:13:07,200
uh we want to pre-paint if you love

00:13:04,160 --> 00:13:11,440
headers so we want to shift data

00:13:07,200 --> 00:13:13,519
a little uh or we want to parse highers

00:13:11,440 --> 00:13:15,519
we don't need to worry about if the

00:13:13,519 --> 00:13:18,639
buffer is ending or not

00:13:15,519 --> 00:13:21,120
so the solution adopted here is to using

00:13:18,639 --> 00:13:22,320
is using external buffers and then this

00:13:21,120 --> 00:13:26,480
buffer will be

00:13:22,320 --> 00:13:29,680
at the size uh required to hold

00:13:26,480 --> 00:13:34,079
the data off the packet

00:13:29,680 --> 00:13:36,480
okay and then uh what else

00:13:34,079 --> 00:13:38,639
requires changes in obs to negotiate the

00:13:36,480 --> 00:13:41,680
feature as well because

00:13:38,639 --> 00:13:42,720
the vehicles user has two sizes two

00:13:41,680 --> 00:13:46,320
sides

00:13:42,720 --> 00:13:48,000
one of them might be an older version

00:13:46,320 --> 00:13:50,720
for instance or a newer version

00:13:48,000 --> 00:13:52,399
so it needs to negotiate the features to

00:13:50,720 --> 00:13:54,800
establish and come on

00:13:52,399 --> 00:13:57,839
a couple set of features and then enable

00:13:54,800 --> 00:14:00,079
this enable the feature

00:13:57,839 --> 00:14:00,959
the interesting thing though is that if

00:14:00,079 --> 00:14:02,880
the

00:14:00,959 --> 00:14:04,639
once the feature is enabled and the

00:14:02,880 --> 00:14:07,519
cable is configured

00:14:04,639 --> 00:14:09,360
to allow that the feature is exposed

00:14:07,519 --> 00:14:12,079
inside of the virtual machine

00:14:09,360 --> 00:14:13,839
and enabled by default if you are using

00:14:12,079 --> 00:14:14,720
them so basically if you run on the

00:14:13,839 --> 00:14:18,000
hypervisor

00:14:14,720 --> 00:14:20,560
and ui computer the virtual machine and

00:14:18,000 --> 00:14:22,639
you allow the tsu to happen and you

00:14:20,560 --> 00:14:25,040
enable on the obs side then

00:14:22,639 --> 00:14:26,079
the linux running inside of the virtual

00:14:25,040 --> 00:14:28,399
machine doesn't need

00:14:26,079 --> 00:14:31,839
to be changed because teso gets

00:14:28,399 --> 00:14:31,839
automatically enabled

00:14:32,160 --> 00:14:37,760
that's very good for if you need to

00:14:35,760 --> 00:14:40,160
you don't need to worry what's going on

00:14:37,760 --> 00:14:42,880
inside of the virtual machine

00:14:40,160 --> 00:14:43,440
so here i give you another two key

00:14:42,880 --> 00:14:46,160
points

00:14:43,440 --> 00:14:47,760
one of them on the left side is the net

00:14:46,160 --> 00:14:51,040
fppk

00:14:47,760 --> 00:14:53,839
uh the host client reconfigured

00:14:51,040 --> 00:14:55,040
that's where we set one lock the flags

00:14:53,839 --> 00:14:58,399
required which is

00:14:55,040 --> 00:14:59,839
the linear buffer support and that

00:14:58,399 --> 00:15:03,440
pretty much says to

00:14:59,839 --> 00:15:06,320
the host library that we don't that obs

00:15:03,440 --> 00:15:06,800
does not support change buffers it's

00:15:06,320 --> 00:15:10,240
just

00:15:06,800 --> 00:15:14,240
one linear buffer and then if a

00:15:10,240 --> 00:15:18,560
user paste issue is enabled we will pass

00:15:14,240 --> 00:15:22,880
this flag called external buffer support

00:15:18,560 --> 00:15:26,079
that tells the the host library

00:15:22,880 --> 00:15:29,360
if it attaches another buffer

00:15:26,079 --> 00:15:32,480
a bigger buffer to detect than obs will

00:15:29,360 --> 00:15:35,920
know how to deal with it

00:15:32,480 --> 00:15:39,199
and in the continuation of this function

00:15:35,920 --> 00:15:40,880
if the user space is enabled then

00:15:39,199 --> 00:15:42,800
it's interesting here because the

00:15:40,880 --> 00:15:45,279
vehicles

00:15:42,800 --> 00:15:45,279
driver

00:15:46,160 --> 00:15:50,320
requires us to disable features that we

00:15:49,360 --> 00:15:52,720
don't support

00:15:50,320 --> 00:15:54,560
so instead of enable features that we

00:15:52,720 --> 00:15:56,720
want to support we need to disable

00:15:54,560 --> 00:15:59,120
features that we don't support

00:15:56,720 --> 00:16:00,240
so in this case if the user paste here

00:15:59,120 --> 00:16:03,440
so it's enabled then

00:16:00,240 --> 00:16:07,120
we just disable uh pcn

00:16:03,440 --> 00:16:10,720
and also ufo

00:16:07,120 --> 00:16:13,360
but if the sql is not enabled then

00:16:10,720 --> 00:16:14,399
it is able to check summing if you

00:16:13,360 --> 00:16:17,120
recall

00:16:14,399 --> 00:16:18,560
the one of the person's lives i

00:16:17,120 --> 00:16:22,160
mentioned that

00:16:18,560 --> 00:16:25,759
the checksumming is required for tsu and

00:16:22,160 --> 00:16:28,639
also for user space

00:16:25,759 --> 00:16:29,680
the udp fragmentation of load so

00:16:28,639 --> 00:16:32,079
disabling

00:16:29,680 --> 00:16:34,160
check summing pretty much disables

00:16:32,079 --> 00:16:38,240
disables all the other

00:16:34,160 --> 00:16:40,800
offloading features okay

00:16:38,240 --> 00:16:42,480
so it's not much complicated there just

00:16:40,800 --> 00:16:44,800
need to understand that

00:16:42,480 --> 00:16:46,720
uh there is a negotiation that's going

00:16:44,800 --> 00:16:50,959
to happen you need to enable the

00:16:46,720 --> 00:16:54,480
cable and also set the flags

00:16:50,959 --> 00:16:57,600
uh both flags also deflects to set

00:16:54,480 --> 00:17:00,720
to tell that we want external buffers

00:16:57,600 --> 00:17:04,240
and also enabling or not disabling

00:17:00,720 --> 00:17:07,600
the dso

00:17:04,240 --> 00:17:08,240
okay let's talk about obs dpdk support

00:17:07,600 --> 00:17:11,280
now

00:17:08,240 --> 00:17:14,160
so basically there are some changes

00:17:11,280 --> 00:17:15,760
uh one important change is that the

00:17:14,160 --> 00:17:18,959
packets are both games you

00:17:15,760 --> 00:17:21,439
are now allow it but only if the egress

00:17:18,959 --> 00:17:24,720
device has ts2 enabled

00:17:21,439 --> 00:17:26,480
so before we change if the package is

00:17:24,720 --> 00:17:28,720
bigger than the m2 which is

00:17:26,480 --> 00:17:28,720
a

00:17:29,760 --> 00:17:36,559
configuration on to the whole to be all

00:17:32,960 --> 00:17:36,559
the ports attached to a bridge

00:17:37,679 --> 00:17:42,799
this this packet will be just dropped

00:17:40,000 --> 00:17:46,880
right but now with the ds0

00:17:42,799 --> 00:17:49,039
if the egress device has the case to

00:17:46,880 --> 00:17:50,720
this package is allowed because then of

00:17:49,039 --> 00:17:53,120
course the network card

00:17:50,720 --> 00:17:55,600
go to the work or the e-class device

00:17:53,120 --> 00:17:57,280
will do the same petition work for us

00:17:55,600 --> 00:18:01,120
if you want to check that there is a

00:17:57,280 --> 00:18:01,120
generic point at net diameters

00:18:01,280 --> 00:18:05,520
prepared patch and this bookshelf since

00:18:04,400 --> 00:18:08,640
obviously pdk

00:18:05,520 --> 00:18:11,200
works with a batch of packets it will

00:18:08,640 --> 00:18:12,320
iterate over the batch jacket packet by

00:18:11,200 --> 00:18:16,000
packet

00:18:12,320 --> 00:18:18,880
uh if it fits uh

00:18:16,000 --> 00:18:21,039
into the network or if tesla is enabled

00:18:18,880 --> 00:18:25,200
otherwise it will drop the bank

00:18:21,039 --> 00:18:28,799
okay for non-dpdk devices

00:18:25,200 --> 00:18:31,360
uh it enables the virtual

00:18:28,799 --> 00:18:32,320
underscore net underscore header data

00:18:31,360 --> 00:18:34,559
structure

00:18:32,320 --> 00:18:35,919
so that allows us to exchange

00:18:34,559 --> 00:18:38,400
information

00:18:35,919 --> 00:18:39,679
check some information just your type

00:18:38,400 --> 00:18:41,919
with the kernel

00:18:39,679 --> 00:18:43,120
so that uh pretty much if you want to

00:18:41,919 --> 00:18:46,240
send packets to

00:18:43,120 --> 00:18:46,640
uh and pairs for instance we can

00:18:46,240 --> 00:18:50,640
use

00:18:46,640 --> 00:18:54,640
that interface to send the information

00:18:50,640 --> 00:18:55,120
to the kernel uh packets coming from the

00:18:54,640 --> 00:18:59,200
known

00:18:55,120 --> 00:19:03,039
dpdk device needs a special handling

00:18:59,200 --> 00:19:03,840
to copy so since now we support external

00:19:03,039 --> 00:19:07,600
buffers

00:19:03,840 --> 00:19:09,520
this pack has come from using

00:19:07,600 --> 00:19:11,200
only pdk memory we need to do some

00:19:09,520 --> 00:19:13,039
special handling now

00:19:11,200 --> 00:19:15,039
that if you want details you can go over

00:19:13,039 --> 00:19:18,080
there dpdk underscore do

00:19:15,039 --> 00:19:20,160
underscore dx copy

00:19:18,080 --> 00:19:21,919
okay and uh there is no software

00:19:20,160 --> 00:19:24,960
fallback

00:19:21,919 --> 00:19:29,280
what does that mean it means if

00:19:24,960 --> 00:19:31,520
the if the device does not support the

00:19:29,280 --> 00:19:35,120
seo

00:19:31,520 --> 00:19:36,160
it could have an option software to do

00:19:35,120 --> 00:19:38,720
that so

00:19:36,160 --> 00:19:40,320
let's say the vm sends are being packed

00:19:38,720 --> 00:19:42,240
on the s4 packet

00:19:40,320 --> 00:19:44,880
this packet goes through the open this

00:19:42,240 --> 00:19:47,280
switch and it's going to be sent out on

00:19:44,880 --> 00:19:50,160
another device a physical device that

00:19:47,280 --> 00:19:51,760
works just does not support this room

00:19:50,160 --> 00:19:53,760
and then instead of just dropping the

00:19:51,760 --> 00:19:54,960
packet we could do the segmentation in

00:19:53,760 --> 00:19:57,520
software

00:19:54,960 --> 00:19:58,480
and send out the supported packet to the

00:19:57,520 --> 00:20:01,440
egress device

00:19:58,480 --> 00:20:02,000
but that's not what happens today there

00:20:01,440 --> 00:20:06,960
is no

00:20:02,000 --> 00:20:09,679
software fallback uh on the other hand

00:20:06,960 --> 00:20:10,799
the good thing about using the external

00:20:09,679 --> 00:20:14,480
buffers and not

00:20:10,799 --> 00:20:16,320
uh changed buffers is that there was no

00:20:14,480 --> 00:20:20,159
changes to coral gas back at

00:20:16,320 --> 00:20:21,039
handling functions so uh functions like

00:20:20,159 --> 00:20:24,320
to shift

00:20:21,039 --> 00:20:26,159
uh bytes to include headers or to remove

00:20:24,320 --> 00:20:27,200
headers and things like that or to parse

00:20:26,159 --> 00:20:30,320
hackers

00:20:27,200 --> 00:20:33,520
uh those functions were not changed

00:20:30,320 --> 00:20:34,159
there is no extra overhead processing

00:20:33,520 --> 00:20:37,600
packets

00:20:34,159 --> 00:20:40,640
because of this so basically you have

00:20:37,600 --> 00:20:43,919
either a buffer of

00:20:40,640 --> 00:20:45,360
a stellar size which is pretty much mcq

00:20:43,919 --> 00:20:48,559
plus overhead

00:20:45,360 --> 00:20:52,320
or you have a bigger buffer

00:20:48,559 --> 00:20:52,320
using the external buffer feature

00:20:52,799 --> 00:20:56,080
okay that side let's go to the next

00:20:55,200 --> 00:20:58,960
slide

00:20:56,080 --> 00:20:59,520
tlc support overview so here it gives

00:20:58,960 --> 00:21:03,039
you

00:20:59,520 --> 00:21:03,039
build with these you

00:21:04,400 --> 00:21:06,720
all right

00:21:10,000 --> 00:21:16,320
this table shows you our performance

00:21:13,039 --> 00:21:16,960
sending tcp packets from the virtual

00:21:16,320 --> 00:21:19,200
machine

00:21:16,960 --> 00:21:20,000
to a local bridge for instance the

00:21:19,200 --> 00:21:23,919
second line

00:21:20,000 --> 00:21:26,960
is the vm sending to a local bridge

00:21:23,919 --> 00:21:28,559
default is without seo is the default

00:21:26,960 --> 00:21:31,679
configuration

00:21:28,559 --> 00:21:35,280
and so you can see i got

00:21:31,679 --> 00:21:36,880
uh three gigabits per second and we test

00:21:35,280 --> 00:21:39,919
you enable it jumps to

00:21:36,880 --> 00:21:41,600
23 gigabits per second

00:21:39,919 --> 00:21:44,000
uh if you do the ratio there it is

00:21:41,600 --> 00:21:46,480
pretty much seven times

00:21:44,000 --> 00:21:47,840
um in the next slide we can see the vm

00:21:46,480 --> 00:21:50,320
sending to a network

00:21:47,840 --> 00:21:51,039
name space using the virtuality net

00:21:50,320 --> 00:21:53,760
pairs

00:21:51,039 --> 00:21:55,280
so before i got three gigabits per

00:21:53,760 --> 00:21:58,640
second it jumped to

00:21:55,280 --> 00:22:02,080
22 gigabits per second which is also

00:21:58,640 --> 00:22:02,799
seven times faster uh the interesting

00:22:02,080 --> 00:22:06,000
case is

00:22:02,799 --> 00:22:10,080
vm in the same hole so it's vm to vm

00:22:06,000 --> 00:22:13,200
the v2v scenario jumped from 2.5 to

00:22:10,080 --> 00:22:16,480
24 gigabits per second so that's a nine

00:22:13,200 --> 00:22:20,720
times faster and uh

00:22:16,480 --> 00:22:23,600
and also the the pvp

00:22:20,720 --> 00:22:26,720
right the physical to virto to physical

00:22:23,600 --> 00:22:28,720
so communicating with external hosts

00:22:26,720 --> 00:22:31,440
in this case is the vm sending to the

00:22:28,720 --> 00:22:34,080
external hosts so the default

00:22:31,440 --> 00:22:36,960
performance is 10 gigabits with tsu

00:22:34,080 --> 00:22:39,840
enable it goes to 35 gigabits so it's

00:22:36,960 --> 00:22:41,200
three times faster with external hosts

00:22:39,840 --> 00:22:43,520
using encapsulation

00:22:41,200 --> 00:22:44,559
we cannot measure that because it's not

00:22:43,520 --> 00:22:46,480
supported

00:22:44,559 --> 00:22:48,080
okay i will talk more about this in the

00:22:46,480 --> 00:22:50,880
limitations

00:22:48,080 --> 00:22:50,880
uh slide

00:22:51,120 --> 00:22:55,039
all right here we have some performance

00:22:53,440 --> 00:22:57,520
numbers now using vlan

00:22:55,039 --> 00:22:58,880
so it's a vm sending to the local bridge

00:22:57,520 --> 00:23:02,159
over a vlan

00:22:58,880 --> 00:23:04,880
um you can see that the numbers are

00:23:02,159 --> 00:23:06,799
good as as good as the privacy slides so

00:23:04,880 --> 00:23:10,159
the local bridge is five times

00:23:06,799 --> 00:23:11,840
seven times faster send it to another

00:23:10,159 --> 00:23:12,960
virtual machine and the same host is

00:23:11,840 --> 00:23:15,760
eight times faster

00:23:12,960 --> 00:23:17,440
and to external host is five times

00:23:15,760 --> 00:23:20,400
faster

00:23:17,440 --> 00:23:24,320
okay moving to the next performance

00:23:20,400 --> 00:23:27,440
slide now using ipv6 instead of ipv4

00:23:24,320 --> 00:23:30,480
uh send into the network namespace

00:23:27,440 --> 00:23:32,240
which jumps uh eight times

00:23:30,480 --> 00:23:34,559
send it to another virtual machine and

00:23:32,240 --> 00:23:37,600
the same host is eight times faster

00:23:34,559 --> 00:23:39,760
and sending to an external host

00:23:37,600 --> 00:23:42,240
is four times faster just to highlight

00:23:39,760 --> 00:23:44,320
here that external host is using the

00:23:42,240 --> 00:23:48,840
physical

00:23:44,320 --> 00:23:52,320
network card and that was a 40 gigabit

00:23:48,840 --> 00:23:54,720
card and uh which means uh

00:23:52,320 --> 00:23:55,679
tsu will pretty much reach it pretty

00:23:54,720 --> 00:23:59,919
much

00:23:55,679 --> 00:24:02,720
uh rigid line hate speed okay so i'm

00:23:59,919 --> 00:24:05,200
uh the bottleneck here is the the

00:24:02,720 --> 00:24:08,000
physical device and not really

00:24:05,200 --> 00:24:08,960
the the softer switch most probably if i

00:24:08,000 --> 00:24:12,400
had a card

00:24:08,960 --> 00:24:15,120
a faster card uh i would get

00:24:12,400 --> 00:24:16,960
a better performance i could not see

00:24:15,120 --> 00:24:18,240
that i could not prove that because my

00:24:16,960 --> 00:24:22,480
card was limited to

00:24:18,240 --> 00:24:25,200
40 gigabits per second

00:24:22,480 --> 00:24:28,559
all right let's talk about some

00:24:25,200 --> 00:24:30,559
limitations in future work

00:24:28,559 --> 00:24:32,159
first and most important please check

00:24:30,559 --> 00:24:33,760
out the documentation

00:24:32,159 --> 00:24:36,080
there are details there on how to

00:24:33,760 --> 00:24:37,440
configure things how to set up the

00:24:36,080 --> 00:24:40,559
environment

00:24:37,440 --> 00:24:43,440
we try to keep it up to date and also

00:24:40,559 --> 00:24:44,240
it it contains the limitations so there

00:24:43,440 --> 00:24:47,679
is a link

00:24:44,240 --> 00:24:50,480
in this slide um you can either

00:24:47,679 --> 00:24:53,360
check the obvious sources or go through

00:24:50,480 --> 00:24:56,799
that link to read the latest

00:24:53,360 --> 00:24:59,440
uh one interesting thing is that it

00:24:56,799 --> 00:25:00,960
needs to be enabled at initialization

00:24:59,440 --> 00:25:04,320
it's a global

00:25:00,960 --> 00:25:07,279
configuration so it affects the whole uh

00:25:04,320 --> 00:25:07,919
ovs in user space and if you want to

00:25:07,279 --> 00:25:12,880
change that

00:25:07,919 --> 00:25:15,440
it requires a restart so i put that

00:25:12,880 --> 00:25:16,159
the reference comment uh for you to

00:25:15,440 --> 00:25:19,440
enable

00:25:16,159 --> 00:25:21,760
the feature uh you can change true to

00:25:19,440 --> 00:25:23,760
files in order to disable that

00:25:21,760 --> 00:25:25,120
um this command is also in the

00:25:23,760 --> 00:25:27,760
documentation

00:25:25,120 --> 00:25:29,600
but yeah this here just in case you want

00:25:27,760 --> 00:25:33,120
to play with it

00:25:29,600 --> 00:25:36,720
it's yeah

00:25:33,120 --> 00:25:38,240
so it supports uh flat and vlon networks

00:25:36,720 --> 00:25:41,279
as i showed to you the

00:25:38,240 --> 00:25:42,720
in the performance slides unfortunately

00:25:41,279 --> 00:25:44,320
there is no support for the

00:25:42,720 --> 00:25:47,120
encapsulation

00:25:44,320 --> 00:25:49,279
there are uh patches posted to the

00:25:47,120 --> 00:25:52,799
mainly list as we speak

00:25:49,279 --> 00:25:56,000
to add support for the for that

00:25:52,799 --> 00:25:58,640
uh it's under review so if you are could

00:25:56,000 --> 00:26:00,559
use or if you want to test those

00:25:58,640 --> 00:26:02,720
provide feedback or anything you are

00:26:00,559 --> 00:26:05,840
welcome to do this

00:26:02,720 --> 00:26:07,679
um yeah and one thing that i

00:26:05,840 --> 00:26:09,840
already mentioned that i want to

00:26:07,679 --> 00:26:12,000
emphasize here is that there is no

00:26:09,840 --> 00:26:14,720
software fallback at the moment

00:26:12,000 --> 00:26:15,679
so if the device does not support seo

00:26:14,720 --> 00:26:18,960
and

00:26:15,679 --> 00:26:21,360
and it receives or the

00:26:18,960 --> 00:26:22,640
switch is going to send the tsu packet

00:26:21,360 --> 00:26:24,799
to it then

00:26:22,640 --> 00:26:26,400
this packet will be dropping there will

00:26:24,799 --> 00:26:29,679
be a warning in the logs

00:26:26,400 --> 00:26:31,120
of course but still um yeah it will be

00:26:29,679 --> 00:26:31,679
interesting to have this software

00:26:31,120 --> 00:26:33,760
fallback

00:26:31,679 --> 00:26:35,200
there is also a proposal in the mailing

00:26:33,760 --> 00:26:37,200
list

00:26:35,200 --> 00:26:39,679
feel free to check out and again test

00:26:37,200 --> 00:26:42,240
and provide feedback

00:26:39,679 --> 00:26:43,600
and as future improvements as i said

00:26:42,240 --> 00:26:46,880
support encapsulation

00:26:43,600 --> 00:26:48,080
reacts lunge and f and gre those are

00:26:46,880 --> 00:26:50,799
also

00:26:48,080 --> 00:26:51,360
available in the most commercial cards

00:26:50,799 --> 00:26:53,279
out there

00:26:51,360 --> 00:26:54,720
so it should not be a problem to enable

00:26:53,279 --> 00:26:58,000
this in obvious

00:26:54,720 --> 00:26:58,960
also to have the support uh software

00:26:58,000 --> 00:27:01,440
fallback

00:26:58,960 --> 00:27:03,520
gso the generic segmentation offload

00:27:01,440 --> 00:27:06,640
available in obs

00:27:03,520 --> 00:27:09,919
and there is one interesting thing here

00:27:06,640 --> 00:27:13,760
is that the user the obvious user space

00:27:09,919 --> 00:27:14,960
is used with dpdk so we could try to

00:27:13,760 --> 00:27:18,320
leverage

00:27:14,960 --> 00:27:22,640
the dpdk jso infrastructure

00:27:18,320 --> 00:27:25,840
but obs is also used in bsd environments

00:27:22,640 --> 00:27:29,360
so and they don't need to use the pdk

00:27:25,840 --> 00:27:31,520
so it would be interesting if the jso

00:27:29,360 --> 00:27:35,039
solution would be generic enough

00:27:31,520 --> 00:27:37,919
to work with in the bsd

00:27:35,039 --> 00:27:39,120
with or without dpdk because then it

00:27:37,919 --> 00:27:42,159
allows

00:27:39,120 --> 00:27:47,520
user space to work independently of

00:27:42,159 --> 00:27:51,200
dpdk and also support tsu peer device

00:27:47,520 --> 00:27:54,240
not really a global key basically

00:27:51,200 --> 00:27:56,799
we would add a port for instance a

00:27:54,240 --> 00:28:00,640
physical device

00:27:56,799 --> 00:28:02,960
would come out with tsu enabled because

00:28:00,640 --> 00:28:03,919
it's interesting to have enabled all the

00:28:02,960 --> 00:28:06,640
time

00:28:03,919 --> 00:28:08,480
and um but if the car doesn't support

00:28:06,640 --> 00:28:11,200
that

00:28:08,480 --> 00:28:12,159
we will do the fallback in in this in

00:28:11,200 --> 00:28:15,039
software

00:28:12,159 --> 00:28:17,279
and it would be transparent to other

00:28:15,039 --> 00:28:20,480
ports attach it to the switch

00:28:17,279 --> 00:28:22,799
so we would not need this global key

00:28:20,480 --> 00:28:24,720
and we could have this option to you

00:28:22,799 --> 00:28:27,520
know

00:28:24,720 --> 00:28:29,679
if for some reason you don't want rts

00:28:27,520 --> 00:28:31,679
tsu enabled on a specific report you

00:28:29,679 --> 00:28:33,279
could just go and disable there

00:28:31,679 --> 00:28:34,960
this is something we can improve in the

00:28:33,279 --> 00:28:38,159
future

00:28:34,960 --> 00:28:40,159
well there are other tcp improvements

00:28:38,159 --> 00:28:41,520
related tcp improvements like for

00:28:40,159 --> 00:28:43,600
instance departure

00:28:41,520 --> 00:28:45,600
and the full hardware of loading

00:28:43,600 --> 00:28:47,360
departure hardware offloading works like

00:28:45,600 --> 00:28:51,200
this instead of

00:28:47,360 --> 00:28:53,679
leaving to the software

00:28:51,200 --> 00:28:54,960
the switch software to process the

00:28:53,679 --> 00:28:58,240
headers

00:28:54,960 --> 00:29:01,679
and then find the specific flow

00:28:58,240 --> 00:29:05,679
processing headers is an expensive uh

00:29:01,679 --> 00:29:07,520
and an expensive operation so we could

00:29:05,679 --> 00:29:09,679
what happens in departure hardware of

00:29:07,520 --> 00:29:10,320
loading is that the hardware provides to

00:29:09,679 --> 00:29:13,600
us

00:29:10,320 --> 00:29:16,159
a hash that is based

00:29:13,600 --> 00:29:17,360
on the network headers and the only

00:29:16,159 --> 00:29:19,520
thing that the software

00:29:17,360 --> 00:29:21,039
needs to do is to take that hash and

00:29:19,520 --> 00:29:24,320
match to a flow

00:29:21,039 --> 00:29:27,200
so it is it cuts part of the

00:29:24,320 --> 00:29:28,240
expensive operation for processing

00:29:27,200 --> 00:29:30,560
packets

00:29:28,240 --> 00:29:31,919
that gives you like uh

00:29:30,560 --> 00:29:34,080
[Music]

00:29:31,919 --> 00:29:35,120
some significant performance improvement

00:29:34,080 --> 00:29:38,320
i'm talking about

00:29:35,120 --> 00:29:40,240
30 it could be even more and

00:29:38,320 --> 00:29:42,399
departure hardware offloading is being

00:29:40,240 --> 00:29:45,120
expanded to also do

00:29:42,399 --> 00:29:46,480
to also execute some of the actions in

00:29:45,120 --> 00:29:50,000
the hardware

00:29:46,480 --> 00:29:52,559
so let's say that you want to do to do

00:29:50,000 --> 00:29:54,640
just some modifications in the packet

00:29:52,559 --> 00:29:56,880
and if the harder supports that then it

00:29:54,640 --> 00:29:59,440
could do this partial modifications and

00:29:56,880 --> 00:30:02,000
harder this is something that's been

00:29:59,440 --> 00:30:03,760
proposed in the mailing list and there

00:30:02,000 --> 00:30:04,320
is also the full hardware of loading

00:30:03,760 --> 00:30:06,640
where

00:30:04,320 --> 00:30:08,559
um the switch the the software

00:30:06,640 --> 00:30:12,159
configures the hardware

00:30:08,559 --> 00:30:14,320
to match on specific headers and then

00:30:12,159 --> 00:30:16,000
do some actions like for instance

00:30:14,320 --> 00:30:18,480
packets coming from

00:30:16,000 --> 00:30:19,600
a specific ip address going to another

00:30:18,480 --> 00:30:22,080
specific

00:30:19,600 --> 00:30:23,600
ip address needs to be sent out to a

00:30:22,080 --> 00:30:26,159
particular vm

00:30:23,600 --> 00:30:28,080
you'd uh the software can just um

00:30:26,159 --> 00:30:29,200
configure that in the hardware and the

00:30:28,080 --> 00:30:30,799
hardware will

00:30:29,200 --> 00:30:32,320
receive the pack and do everything

00:30:30,799 --> 00:30:34,399
needed and send out to the virtual

00:30:32,320 --> 00:30:35,039
machine without any intervention from

00:30:34,399 --> 00:30:38,080
the

00:30:35,039 --> 00:30:40,880
the hypervisor so it saves uh

00:30:38,080 --> 00:30:41,679
it's pretty much a hardware a direct

00:30:40,880 --> 00:30:44,799
hardware

00:30:41,679 --> 00:30:45,600
uh connection from the physical network

00:30:44,799 --> 00:30:48,640
card

00:30:45,600 --> 00:30:49,440
to the virtual machine and also there

00:30:48,640 --> 00:30:51,120
were some

00:30:49,440 --> 00:30:53,039
uh interesting improvements with

00:30:51,120 --> 00:30:56,640
batching uh specifically

00:30:53,039 --> 00:31:00,559
i'm talking about the

00:30:56,640 --> 00:31:04,559
the the interface to the non-dpdk

00:31:00,559 --> 00:31:08,880
uh devices like virtuality net pairs

00:31:04,559 --> 00:31:11,360
and tap devices things like using

00:31:08,880 --> 00:31:13,440
sys calls that allows multiple packets

00:31:11,360 --> 00:31:16,080
to be sent out

00:31:13,440 --> 00:31:17,279
versus call instead of doing one syscall

00:31:16,080 --> 00:31:20,559
per packet

00:31:17,279 --> 00:31:21,440
which is uh is low we match the packets

00:31:20,559 --> 00:31:24,960
and send all

00:31:21,440 --> 00:31:27,760
and send like up to a 32 packets

00:31:24,960 --> 00:31:30,799
in one scope that greatly improved the

00:31:27,760 --> 00:31:30,799
performance over time

00:31:30,840 --> 00:31:34,559
okay that's what i had to present for

00:31:33,519 --> 00:31:38,880
this talk

00:31:34,559 --> 00:31:38,880
thanks a lot thank you for

00:31:44,840 --> 00:31:47,840
attending

00:31:48,720 --> 00:31:52,399
thank you so much for the talk flavio um

00:31:50,960 --> 00:31:54,320
if there are any questions for

00:31:52,399 --> 00:31:57,440
flavio please put them in the chat and

00:31:54,320 --> 00:31:57,440
we will field it to him

00:31:57,840 --> 00:32:02,399
okay first question how can we debug

00:32:00,320 --> 00:32:04,799
network segmentation issues with t

00:32:02,399 --> 00:32:06,720
when tso is enabled or even see which

00:32:04,799 --> 00:32:08,080
devices are using tso

00:32:06,720 --> 00:32:11,840
are there any insights into the

00:32:08,080 --> 00:32:11,840
segmentation engine from the host side

00:32:12,240 --> 00:32:16,159
so there is uh the segmentation is

00:32:14,320 --> 00:32:18,480
happening at the network card so

00:32:16,159 --> 00:32:19,760
uh the when the packet comes in from the

00:32:18,480 --> 00:32:21,679
virto machine

00:32:19,760 --> 00:32:23,919
you will see the whole packet so if you

00:32:21,679 --> 00:32:26,559
use ovs tcp dump

00:32:23,919 --> 00:32:28,399
you will be able to see the whole packet

00:32:26,559 --> 00:32:30,799
and but the segmentation itself only

00:32:28,399 --> 00:32:32,880
happens in the in the hardware

00:32:30,799 --> 00:32:34,720
if you are sending this packet back to

00:32:32,880 --> 00:32:36,720
the kernel for instance then the

00:32:34,720 --> 00:32:38,080
there is no segmentation at all even if

00:32:36,720 --> 00:32:38,720
you are sending to another virtual

00:32:38,080 --> 00:32:40,640
machine

00:32:38,720 --> 00:32:41,760
there is no segmentation the the same

00:32:40,640 --> 00:32:45,840
packet that came in

00:32:41,760 --> 00:32:48,000
it will be sent out to the other device

00:32:45,840 --> 00:32:49,200
uh which devices are using this so

00:32:48,000 --> 00:32:52,080
basically today is

00:32:49,200 --> 00:32:53,039
all or all or nothing so if you enable

00:32:52,080 --> 00:32:56,159
the tsu

00:32:53,039 --> 00:32:57,360
you we assume that every device supports

00:32:56,159 --> 00:33:00,080
this hero

00:32:57,360 --> 00:33:01,519
but if in the case of a hardware or uh

00:33:00,080 --> 00:33:03,200
yeah in the case of a hardware that does

00:33:01,519 --> 00:33:04,480
not support seo then there will be a

00:33:03,200 --> 00:33:08,000
warning flag

00:33:04,480 --> 00:33:08,000
in the v-switch log

00:33:08,080 --> 00:33:11,519
and i guess the last question i already

00:33:10,159 --> 00:33:15,039
answered but uh

00:33:11,519 --> 00:33:15,039
yeah maybe said something

00:33:18,559 --> 00:33:25,840
any more questions

00:33:32,080 --> 00:33:37,120
all right so tsu is experimental yet

00:33:35,440 --> 00:33:39,600
as you can see there are many things to

00:33:37,120 --> 00:33:42,960
improve there uh it was added in

00:33:39,600 --> 00:33:43,919
ovs 2.13 the partial hardware upload is

00:33:42,960 --> 00:33:47,919
a little bit older

00:33:43,919 --> 00:33:50,399
it got added first in the ovs 2.10

00:33:47,919 --> 00:33:52,320
it's still experimental but yeah those

00:33:50,399 --> 00:33:54,880
are very interesting technologies if you

00:33:52,320 --> 00:33:55,919
if you want to uh report feedback's test

00:33:54,880 --> 00:33:59,600
or help us

00:33:55,919 --> 00:33:59,600
we will appreciate that for sure

00:34:02,000 --> 00:34:06,480
question does it work transparently for

00:34:04,840 --> 00:34:08,399
fact

00:34:06,480 --> 00:34:10,320
yes you should be able to see the packet

00:34:08,399 --> 00:34:21,839
as is as it is flowing

00:34:10,320 --> 00:34:21,839
in the ovs

00:34:22,960 --> 00:34:35,839
okay let's give it a few seconds in case

00:34:25,200 --> 00:34:35,839
people are typing other questions

00:34:46,159 --> 00:34:49,679
okay doesn't look like there is any more

00:34:48,000 --> 00:34:51,440
right now uh if you would like to

00:34:49,679 --> 00:34:53,119
continue the conversation with flavio

00:34:51,440 --> 00:34:53,599
feel free to directly message him on

00:34:53,119 --> 00:34:55,839
hoppin

00:34:53,599 --> 00:34:58,160
or we have breakout rooms under the expo

00:34:55,839 --> 00:34:59,119
tab for the system engineering track so

00:34:58,160 --> 00:35:01,040
you can hang out there

00:34:59,119 --> 00:35:04,320
share audio video and have discussions

00:35:01,040 --> 00:35:07,040
thank you so much once again flavio

00:35:04,320 --> 00:35:07,040

YouTube URL: https://www.youtube.com/watch?v=DQzIbo67mjE


