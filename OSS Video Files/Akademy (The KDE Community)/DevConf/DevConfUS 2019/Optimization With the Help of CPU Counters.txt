Title: Optimization With the Help of CPU Counters
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Ulrich Drepper

Just having the tools to profile an application available is not enough to improve the performance. There are too many of these counters and only a few can be measured at any one time. One has to interpret the various counters in context. This all calls for a methodological approach. In this talk we will look specifically use an Intel CPU and the top-down method Intel specified to match their CPU architecture.
Captions: 
	00:00:02,540 --> 00:00:14,030
oh no it's okay

00:00:12,019 --> 00:00:16,960
350 we have hunted for four we have a

00:00:14,030 --> 00:00:16,960
half an hour that's okay

00:00:20,640 --> 00:00:23,480
until the nation

00:00:24,259 --> 00:00:27,829
Paris laterally

00:00:35,609 --> 00:00:42,960
but if you're optimizing the number of

00:00:40,339 --> 00:00:43,840
instructions per cycle that ulaana

00:00:42,960 --> 00:00:47,120
gives

00:00:43,840 --> 00:00:48,320
introducing two instructions that could

00:00:47,120 --> 00:00:53,570
have been done in the work of what

00:00:48,320 --> 00:00:56,000
because you're telling it would be

00:00:53,570 --> 00:00:58,430
something like that perhaps if you're

00:00:56,000 --> 00:01:00,830
really looking only at this but you

00:00:58,430 --> 00:01:02,570
should not ever do this one of the

00:01:00,830 --> 00:01:04,759
things which you can always measure at

00:01:02,570 --> 00:01:08,450
any point in time it's time through time

00:01:04,759 --> 00:01:13,490
stamp powder and so on and if you see

00:01:08,450 --> 00:01:15,320
that moving then in the wrong direction

00:01:13,490 --> 00:01:19,700
then you don't do the optimization in

00:01:15,320 --> 00:01:22,490
general but there days there's quite a

00:01:19,700 --> 00:01:26,300
lot of overhead introduced in the Indus

00:01:22,490 --> 00:01:28,899
in the decoder of Exodus six that part

00:01:26,300 --> 00:01:31,610
of the sewer can actually consumes a

00:01:28,899 --> 00:01:35,780
substantial part of the entire energy so

00:01:31,610 --> 00:01:37,789
far risks processors are onerous five or

00:01:35,780 --> 00:01:42,050
something like this the decoders trivial

00:01:37,789 --> 00:01:43,100
as you have now seen but on Exodus six I

00:01:42,050 --> 00:01:44,929
think it takes something like between

00:01:43,100 --> 00:01:48,319
five and ten percent for entire energy

00:01:44,929 --> 00:01:50,450
spent on the decoder part so if you have

00:01:48,319 --> 00:01:53,899
fewer instructions it's actually really

00:01:50,450 --> 00:01:57,349
a positive thing because they might be

00:01:53,899 --> 00:02:00,679
code decoding by itself is approximately

00:01:57,349 --> 00:02:03,050
the same over at for each individual

00:02:00,679 --> 00:02:04,940
instructions so if you map in

00:02:03,050 --> 00:02:06,920
instruction to have a more complex

00:02:04,940 --> 00:02:08,810
instruction which Maps the module micro

00:02:06,920 --> 00:02:12,720
instruction that's actually probably

00:02:08,810 --> 00:02:15,910
better than have two simple instructions

00:02:12,720 --> 00:02:19,150
not in this one but you can Marin

00:02:15,910 --> 00:02:20,830
capture it in other ways so this is it's

00:02:19,150 --> 00:02:23,010
always dangerous to look exactly one

00:02:20,830 --> 00:02:23,010
value

00:03:21,310 --> 00:03:24,310
yeah

00:03:32,900 --> 00:03:40,430
she is

00:03:34,680 --> 00:03:40,430
[Music]

00:03:53,709 --> 00:04:02,030
sunshine

00:03:56,280 --> 00:04:02,030
I'm on the beach sort of shorts

00:04:11,130 --> 00:04:15,690
all right let's continue so we have

00:04:13,410 --> 00:04:19,470
definitely at least half an hour left

00:04:15,690 --> 00:04:33,060
and material so perhaps more all right

00:04:19,470 --> 00:04:43,800
so the face Joe all right so I'm

00:04:33,060 --> 00:04:45,450
skipping over that part okay so you can

00:04:43,800 --> 00:04:47,610
actually look at the counters which have

00:04:45,450 --> 00:04:49,170
available so part of the tool one of the

00:04:47,610 --> 00:04:52,710
tools which I'm going to talk about in

00:04:49,170 --> 00:04:54,480
this part is using a website which is

00:04:52,710 --> 00:04:57,150
owned by Intel at least paint a line

00:04:54,480 --> 00:05:01,230
please called zero one dot org on which

00:04:57,150 --> 00:05:03,210
you can find for the CPU versions

00:05:01,230 --> 00:05:04,830
various types of tables which you can

00:05:03,210 --> 00:05:06,810
download in which the tools actually are

00:05:04,830 --> 00:05:10,020
downloading so amongst them for instance

00:05:06,810 --> 00:05:13,140
for my whole machine business to the

00:05:10,020 --> 00:05:15,480
table skylake X core the leaves version

00:05:13,140 --> 00:05:17,910
and so on you can download this and you

00:05:15,480 --> 00:05:20,220
can look at the number of events just

00:05:17,910 --> 00:05:21,690
that core not the processor to process

00:05:20,220 --> 00:05:26,520
the alcohol part is what this is just

00:05:21,690 --> 00:05:29,850
the core has 445 events which I can

00:05:26,520 --> 00:05:33,480
measure so the next version so cascade

00:05:29,850 --> 00:05:35,850
lake has 2347

00:05:33,480 --> 00:05:38,640
events which you can measure so they are

00:05:35,850 --> 00:05:41,280
actively working heavily in this area

00:05:38,640 --> 00:05:43,740
that is all kinds of stuff but just

00:05:41,280 --> 00:05:45,930
imagine now so you have are in charge of

00:05:43,740 --> 00:05:49,380
analyzing your program which of these

00:05:45,930 --> 00:05:53,010
events do you actually use so it's

00:05:49,380 --> 00:05:56,490
somewhat okay using the terminology so

00:05:53,010 --> 00:05:58,710
that yeah things like CPI will always be

00:05:56,490 --> 00:06:01,740
there but that's just a subset of what

00:05:58,710 --> 00:06:03,540
you want to look at you might recall the

00:06:01,740 --> 00:06:07,620
complexity of the machine architecture

00:06:03,540 --> 00:06:10,980
but one thing can help us if we can try

00:06:07,620 --> 00:06:13,770
to find some uniform values which have

00:06:10,980 --> 00:06:14,330
general applicability regardless of the

00:06:13,770 --> 00:06:16,789
architect

00:06:14,330 --> 00:06:19,849
Jefferson and even hockey dependent

00:06:16,789 --> 00:06:26,000
independent of the CPU itself that can

00:06:19,849 --> 00:06:27,620
help so we need still awareness of the

00:06:26,000 --> 00:06:30,740
microarchitecture as we have seen before

00:06:27,620 --> 00:06:33,469
but we can abstract some of the details

00:06:30,740 --> 00:06:35,629
out as a helmet so this does not solve

00:06:33,469 --> 00:06:38,389
the issue completely and it also means

00:06:35,629 --> 00:06:40,789
that if you really want to optimize for

00:06:38,389 --> 00:06:42,680
the last any little bit of performance

00:06:40,789 --> 00:06:44,840
which is left you need to look at the

00:06:42,680 --> 00:06:48,680
individual events and all the

00:06:44,840 --> 00:06:52,219
definitions and so on but for general

00:06:48,680 --> 00:06:54,889
first level optimization it's okay to

00:06:52,219 --> 00:06:59,389
use some abstraction and to go about

00:06:54,889 --> 00:07:02,449
using some methodology to be able to

00:06:59,389 --> 00:07:03,860
analyze the programs so I'm going to

00:07:02,449 --> 00:07:07,460
talk about one of the methodologies

00:07:03,860 --> 00:07:08,990
right now so and just like with most of

00:07:07,460 --> 00:07:11,479
the stuff which I've experienced but

00:07:08,990 --> 00:07:13,789
this is based on exit Intel processors

00:07:11,479 --> 00:07:15,710
this is simply what what I've always

00:07:13,789 --> 00:07:18,259
been around with so it might change in

00:07:15,710 --> 00:07:20,289
future but so far it's mostly exit six

00:07:18,259 --> 00:07:23,629
processors and there's something

00:07:20,289 --> 00:07:26,629
internally introduced and it all is you

00:07:23,629 --> 00:07:29,120
can start out by thinking about the

00:07:26,629 --> 00:07:33,110
picture which I have seen now a couple

00:07:29,120 --> 00:07:35,389
of times that there are certain so the

00:07:33,110 --> 00:07:37,940
already mentioned that instructions are

00:07:35,389 --> 00:07:39,620
starting the life at the top in the in

00:07:37,940 --> 00:07:41,449
the instruction cache and the decoder

00:07:39,620 --> 00:07:43,729
etc and they're going to the bottom at

00:07:41,449 --> 00:07:46,210
which point they get retired so there

00:07:43,729 --> 00:07:48,919
are even in this picture certain

00:07:46,210 --> 00:07:51,979
boundaries which we can identify in the

00:07:48,919 --> 00:07:55,400
picture itself which are signaling

00:07:51,979 --> 00:07:58,669
certain steps in the lifetime of an

00:07:55,400 --> 00:08:03,349
instruction so I've painted them really

00:07:58,669 --> 00:08:05,779
nicely right here so for instance and

00:08:03,349 --> 00:08:08,360
this is not a 1% accurately picture but

00:08:05,779 --> 00:08:10,699
basically the first the top one is some

00:08:08,360 --> 00:08:12,979
isn't his associate with a couple of

00:08:10,699 --> 00:08:14,930
events is where the my crops have been

00:08:12,979 --> 00:08:16,600
issued so they have the instruction has

00:08:14,930 --> 00:08:20,140
been decoded and we have now still

00:08:16,600 --> 00:08:22,060
to microbes and if it doesn't make any

00:08:20,140 --> 00:08:24,030
progress than there are perhaps there

00:08:22,060 --> 00:08:26,560
are some resources which are missing

00:08:24,030 --> 00:08:30,420
then we have to align the second line

00:08:26,560 --> 00:08:32,890
where the microbes is going to be

00:08:30,420 --> 00:08:34,479
executed or it has been determined that

00:08:32,890 --> 00:08:36,610
the resources are available and we can

00:08:34,479 --> 00:08:39,700
do this so as an event called New York's

00:08:36,610 --> 00:08:41,349
executed so that's the one event which

00:08:39,700 --> 00:08:44,890
we can potentially think about being

00:08:41,349 --> 00:08:46,540
counted there and at the bottom there's

00:08:44,890 --> 00:08:49,990
another event which we can't count

00:08:46,540 --> 00:08:51,880
you're retired that's basically when it

00:08:49,990 --> 00:08:54,400
is done when almost the operations for

00:08:51,880 --> 00:08:56,110
the instruction have been done at that

00:08:54,400 --> 00:08:59,700
level we might be able to count

00:08:56,110 --> 00:09:02,080
something like that so that this is

00:08:59,700 --> 00:09:04,600
starting the starting point of a

00:09:02,080 --> 00:09:07,300
methodology so if we are thinking about

00:09:04,600 --> 00:09:09,700
it the all of the CPUs in a similar

00:09:07,300 --> 00:09:12,130
fashion and try to identify parts of the

00:09:09,700 --> 00:09:15,490
program which are counting high-level

00:09:12,130 --> 00:09:17,020
abstract but more abstract events than

00:09:15,490 --> 00:09:18,670
the individual events ease of use that

00:09:17,020 --> 00:09:21,790
providing list we can come up with

00:09:18,670 --> 00:09:26,380
something and Intel service specific in

00:09:21,790 --> 00:09:28,120
Mahara yet Intel Ahmed Yassin has has

00:09:26,380 --> 00:09:30,130
actually written the paper I'm not sure

00:09:28,120 --> 00:09:32,440
whether he actually was the one who

00:09:30,130 --> 00:09:34,720
developed this because I know about the

00:09:32,440 --> 00:09:38,050
terminology has been been used inside

00:09:34,720 --> 00:09:40,750
Intel for a very long time so I've seen

00:09:38,050 --> 00:09:43,150
people using it but when I asked about

00:09:40,750 --> 00:09:46,000
what I can have access to that they were

00:09:43,150 --> 00:09:48,720
just smiling so the publication of this

00:09:46,000 --> 00:09:55,000
paper was after the smiling incidences

00:09:48,720 --> 00:09:57,100
and say yes the reference reference to

00:09:55,000 --> 00:10:00,580
the publication which you can find out

00:09:57,100 --> 00:10:03,960
so it's in general called well top-down

00:10:00,580 --> 00:10:07,240
methods TM a.m. and is what they always

00:10:03,960 --> 00:10:12,630
oftentimes calling out and this is one

00:10:07,240 --> 00:10:14,290
of the figures out from this specific

00:10:12,630 --> 00:10:17,470
paper itself

00:10:14,290 --> 00:10:20,680
that's a nice summary so what this shows

00:10:17,470 --> 00:10:22,840
us for is that it's a top-down and that

00:10:20,680 --> 00:10:25,210
was is where we are looking at the

00:10:22,840 --> 00:10:27,149
question about the program execution and

00:10:25,210 --> 00:10:31,660
so on at the top and then

00:10:27,149 --> 00:10:33,250
we're successively asking as individual

00:10:31,660 --> 00:10:36,519
questions so for instance is it

00:10:33,250 --> 00:10:39,040
front-end found is the program ended by

00:10:36,519 --> 00:10:41,079
snaps big bad speculation is the

00:10:39,040 --> 00:10:43,569
instruction successfully running through

00:10:41,079 --> 00:10:46,509
is it being retired or is it a problem

00:10:43,569 --> 00:10:50,079
in the backend so that's the first level

00:10:46,509 --> 00:10:53,050
of questions we can see and depending on

00:10:50,079 --> 00:10:55,000
what the answer is for us then we can go

00:10:53,050 --> 00:10:56,889
down and say well for instance if it's

00:10:55,000 --> 00:11:00,370
front-end found well what is the problem

00:10:56,889 --> 00:11:02,319
with that is it a latency that the

00:11:00,370 --> 00:11:04,899
decoder for instance doesn't get enough

00:11:02,319 --> 00:11:06,759
instructions or is it the bandwidth so

00:11:04,899 --> 00:11:08,589
that we are far too few have had too

00:11:06,759 --> 00:11:11,740
many instructions so it's overwhelming

00:11:08,589 --> 00:11:14,500
us etcetera so these kind of things are

00:11:11,740 --> 00:11:17,069
going to be looked at successively you

00:11:14,500 --> 00:11:19,959
see here we have four levels of

00:11:17,069 --> 00:11:21,459
potentially four levels of different

00:11:19,959 --> 00:11:24,459
events which we are going to be looking

00:11:21,459 --> 00:11:27,190
at and that's this top-down method which

00:11:24,459 --> 00:11:28,870
is first of all being advertised

00:11:27,190 --> 00:11:31,839
betterment also we have tools now

00:11:28,870 --> 00:11:35,860
implementing them to some extent so each

00:11:31,839 --> 00:11:38,110
of these levels have a different ways of

00:11:35,860 --> 00:11:39,790
how we are actually getting to the

00:11:38,110 --> 00:11:42,130
answer for that so for instance for the

00:11:39,790 --> 00:11:44,620
first level the way the paper

00:11:42,130 --> 00:11:46,839
specifically is telling us we are

00:11:44,620 --> 00:11:50,829
computing this is well we are first

00:11:46,839 --> 00:11:52,990
measuring how many whether my crops were

00:11:50,829 --> 00:11:55,449
allocated or not depending on this

00:11:52,990 --> 00:11:57,430
answer we are in other whether they have

00:11:55,449 --> 00:11:59,709
been retired or not or whether there

00:11:57,430 --> 00:12:03,040
have been any betting sauce so with

00:11:59,709 --> 00:12:06,339
these different types of questions we

00:12:03,040 --> 00:12:08,500
can then categorize a specific event in

00:12:06,339 --> 00:12:10,660
one of these four classes and then

00:12:08,500 --> 00:12:12,579
increment account and overall game

00:12:10,660 --> 00:12:14,889
perhaps then statistics saying oh yeah

00:12:12,579 --> 00:12:15,370
in so on so many cases inside the

00:12:14,889 --> 00:12:17,260
program

00:12:15,370 --> 00:12:19,329
it was front-end found back and found

00:12:17,260 --> 00:12:21,790
etcetera so it's not that everything the

00:12:19,329 --> 00:12:23,529
entire program is just saying one for

00:12:21,790 --> 00:12:25,509
for this one event this is Cynthia

00:12:23,529 --> 00:12:30,220
counting thing it's a statistical thing

00:12:25,509 --> 00:12:33,399
by itself as well so this is one nice

00:12:30,220 --> 00:12:35,470
methodology we can basically be be

00:12:33,399 --> 00:12:37,939
applied to everyone if you're following

00:12:35,470 --> 00:12:39,619
this and you still get a

00:12:37,939 --> 00:12:40,999
the value of it even if the

00:12:39,619 --> 00:12:41,779
microarchitecture is changing

00:12:40,999 --> 00:12:44,209
dramatically

00:12:41,779 --> 00:12:46,099
whether you are than later on

00:12:44,209 --> 00:12:48,229
interpreting the numbers correctly and

00:12:46,099 --> 00:12:50,119
making the correct changes to your

00:12:48,229 --> 00:12:52,489
program that's a different question but

00:12:50,119 --> 00:12:57,409
at least you can analyze things so how

00:12:52,489 --> 00:12:58,759
what is looking like so for there there

00:12:57,409 --> 00:13:00,619
are various ways of doing this so

00:12:58,759 --> 00:13:03,649
perfect itself as you can see later on

00:13:00,619 --> 00:13:05,239
an example has some of that built in but

00:13:03,649 --> 00:13:08,449
there's another tool which I will show

00:13:05,239 --> 00:13:10,249
you later on which has has the much more

00:13:08,449 --> 00:13:12,169
complete implementation of the top-down

00:13:10,249 --> 00:13:14,389
model in in it which is using

00:13:12,169 --> 00:13:17,779
performance self but basically all of

00:13:14,389 --> 00:13:19,819
them have some form of coding of for

00:13:17,779 --> 00:13:23,239
instance what does it need for retiring

00:13:19,819 --> 00:13:25,279
so how do i compute this value if I have

00:13:23,239 --> 00:13:27,619
all these kind of performance counters

00:13:25,279 --> 00:13:29,689
which of them do I have to measure to

00:13:27,619 --> 00:13:32,329
actually get to the point that I can

00:13:29,689 --> 00:13:35,149
make and make a decision about how many

00:13:32,329 --> 00:13:38,419
times or what percentage of time was the

00:13:35,149 --> 00:13:40,669
problem in well what did the program

00:13:38,419 --> 00:13:41,659
really reasonably retire instructional

00:13:40,669 --> 00:13:45,039
therefore there was not really a

00:13:41,659 --> 00:13:48,229
performance issues and these values are

00:13:45,039 --> 00:13:50,149
computed using formulas but the

00:13:48,229 --> 00:13:51,919
important thing is they are varying

00:13:50,149 --> 00:13:54,079
potentially depending on the

00:13:51,919 --> 00:13:56,389
microarchitecture they will definitely

00:13:54,079 --> 00:13:58,909
vary across the CPU architectures as

00:13:56,389 --> 00:14:01,339
well but even in microarchitectures with

00:13:58,909 --> 00:14:03,649
the number of counters being added and

00:14:01,339 --> 00:14:06,109
changed etc so all of the counters which

00:14:03,649 --> 00:14:08,209
are not architected are not promised by

00:14:06,109 --> 00:14:10,669
their CPU manufacturers to exist in the

00:14:08,209 --> 00:14:13,159
next revision so all of them can change

00:14:10,669 --> 00:14:15,079
but therefore it's important to get to

00:14:13,159 --> 00:14:17,959
find that you have a formulation of what

00:14:15,079 --> 00:14:19,189
kind of counter value or more important

00:14:17,959 --> 00:14:21,619
in many cases like this

00:14:19,189 --> 00:14:23,359
what kind of ratio so again you look at

00:14:21,619 --> 00:14:27,379
the tongue retiring is actually a ratio

00:14:23,359 --> 00:14:32,529
how which ratio gets actually computed

00:14:27,379 --> 00:14:35,569
in which way so and the 0.01 dot or our

00:14:32,529 --> 00:14:37,369
site which I mentioned before has data

00:14:35,569 --> 00:14:39,739
files for many of these architectures

00:14:37,369 --> 00:14:42,319
and here again that's for my my skylake

00:14:39,739 --> 00:14:44,370
machine at home this would be the way

00:14:42,319 --> 00:14:46,710
how I compute with

00:14:44,370 --> 00:14:48,930
or the tools are computing the retiring

00:14:46,710 --> 00:14:51,089
value so it takes the time is the number

00:14:48,930 --> 00:14:53,580
of me ops which are retired to buy

00:14:51,089 --> 00:14:54,839
divided by the slots slots is pipe and

00:14:53,580 --> 00:14:57,630
width and score clocks

00:14:54,839 --> 00:14:59,820
 tops is depending on how I will do

00:14:57,630 --> 00:15:02,760
these sampling and Sun is computed in

00:14:59,820 --> 00:15:05,160
one of three ways and clocks is computed

00:15:02,760 --> 00:15:08,010
this way etcetera etcetera so this is

00:15:05,160 --> 00:15:11,339
written as a kind of code gets executed

00:15:08,010 --> 00:15:13,529
and based on the sampling values which

00:15:11,339 --> 00:15:16,860
are available I can compute this value

00:15:13,529 --> 00:15:19,290
and this is available for all kinds of

00:15:16,860 --> 00:15:21,750
different parts of this top-down model

00:15:19,290 --> 00:15:24,180
and more so there are actually many many

00:15:21,750 --> 00:15:25,680
more ratios defined in Intel manuals

00:15:24,180 --> 00:15:28,200
that I have within me in the end a

00:15:25,680 --> 00:15:30,720
little bit which we can use them utilize

00:15:28,200 --> 00:15:33,150
for program analysis but for the

00:15:30,720 --> 00:15:34,529
top-down analysis we just need a couple

00:15:33,150 --> 00:15:36,510
of these kind of things and they are

00:15:34,529 --> 00:15:38,850
defined depending on the CPU of

00:15:36,510 --> 00:15:41,400
architecture by these nice little files

00:15:38,850 --> 00:15:43,950
which we can automatically use so that's

00:15:41,400 --> 00:15:46,470
good news so we don't really have to do

00:15:43,950 --> 00:15:49,620
that much work so the tool which I've

00:15:46,470 --> 00:15:52,170
mentioned which has this is called TMU

00:15:49,620 --> 00:15:57,390
tool so what those are around in the

00:15:52,170 --> 00:15:59,279
Linux was no Andy clean and he has been

00:15:57,390 --> 00:16:02,070
working for Intel for quite a number of

00:15:59,279 --> 00:16:04,260
years now and he has published this as

00:16:02,070 --> 00:16:06,510
an implementation of the top-down paper

00:16:04,260 --> 00:16:08,660
it's a Python square for a set of 5

00:16:06,510 --> 00:16:12,779
encryption it's actually really nice and

00:16:08,660 --> 00:16:15,720
the tools itself is using the data which

00:16:12,779 --> 00:16:17,640
you can download yourself independently

00:16:15,720 --> 00:16:19,440
from the zero one dot off-site so the

00:16:17,640 --> 00:16:21,600
perfmon directory has all these kind of

00:16:19,440 --> 00:16:24,990
files for all kinds of pocket CPU

00:16:21,600 --> 00:16:27,209
architectures they're available so how

00:16:24,990 --> 00:16:29,520
do you use it in perfect self as I

00:16:27,209 --> 00:16:32,970
mentioned it has an initial version of

00:16:29,520 --> 00:16:35,850
the severity coded by inside but only

00:16:32,970 --> 00:16:38,550
the level one remember there were four

00:16:35,850 --> 00:16:41,279
levels level one is available in perfect

00:16:38,550 --> 00:16:44,160
self you specify the top-down argument

00:16:41,279 --> 00:16:47,339
but you also have to do global counting

00:16:44,160 --> 00:16:49,350
using they are limit that's not bad it's

00:16:47,339 --> 00:16:51,769
a it's kind of a bad thing because this

00:16:49,350 --> 00:16:53,769
means you cannot monitor an individual

00:16:51,769 --> 00:16:56,839
process you have to look at the entire

00:16:53,769 --> 00:16:59,209
entire running sister and if it's noisy

00:16:56,839 --> 00:17:01,699
many other things going on you have to

00:16:59,209 --> 00:17:03,980
be carefully interpreting the data but

00:17:01,699 --> 00:17:06,829
you can do something around this kind of

00:17:03,980 --> 00:17:08,600
thing for instance you can tie the the

00:17:06,829 --> 00:17:11,029
process which are looking at you it is

00:17:08,600 --> 00:17:14,299
individual core ones in this case tasks

00:17:11,029 --> 00:17:16,669
that - see zero means that the process

00:17:14,299 --> 00:17:18,319
will always be executed in color zero so

00:17:16,669 --> 00:17:20,029
you only have to look in the output at

00:17:18,319 --> 00:17:24,500
the at the line

00:17:20,029 --> 00:17:26,329
s0 soffit 0 cos 0 my counts will only be

00:17:24,500 --> 00:17:28,370
in this mind not in this line otherwise

00:17:26,329 --> 00:17:30,590
it might be confusing so why are these

00:17:28,370 --> 00:17:33,289
different numbers they don't apply to my

00:17:30,590 --> 00:17:34,940
code is it so you have to work around

00:17:33,289 --> 00:17:37,820
some of the limitations of curve

00:17:34,940 --> 00:17:42,260
so in general I I've never been really

00:17:37,820 --> 00:17:44,990
used that I've used the top left - which

00:17:42,260 --> 00:17:46,730
is part of this p.m. you to set so

00:17:44,990 --> 00:17:49,429
Finance where as the name suggests you

00:17:46,730 --> 00:17:51,559
run it and it you can give it parameter

00:17:49,429 --> 00:17:53,480
as for instance in this case I can tell

00:17:51,559 --> 00:17:55,659
it oh yeah this is single thread program

00:17:53,480 --> 00:17:57,919
so don't worry about setting up

00:17:55,659 --> 00:17:59,659
performance monitoring and all kinds of

00:17:57,919 --> 00:18:01,220
course only on the core I'm actually

00:17:59,659 --> 00:18:03,049
going to use and therefore it's much

00:18:01,220 --> 00:18:05,539
much simpler than what you normally

00:18:03,049 --> 00:18:09,740
can't and then so in this case here I

00:18:05,539 --> 00:18:11,990
just run level 1 analysis on the on the

00:18:09,740 --> 00:18:13,179
program and as you can see it here the

00:18:11,990 --> 00:18:16,000
numbers are actually pretty good

00:18:13,179 --> 00:18:20,020
corresponding so you see back end pound

00:18:16,000 --> 00:18:24,649
20.2% that's the red line and here this

00:18:20,020 --> 00:18:26,840
20.9 5% also this is the output it

00:18:24,649 --> 00:18:28,909
doesn't even bother pointing out that as

00:18:26,840 --> 00:18:30,620
front-end found and retiring them jean

00:18:28,909 --> 00:18:34,279
if you me they figured out that is a

00:18:30,620 --> 00:18:37,070
potential problem if there's any exactly

00:18:34,279 --> 00:18:39,020
what the red color here shows so they're

00:18:37,070 --> 00:18:41,630
basically a clue then their backpack

00:18:39,020 --> 00:18:44,240
book but p.m. you tools and specific top

00:18:41,630 --> 00:18:46,580
nav you can ask other levels so now i

00:18:44,240 --> 00:18:48,919
specify level two so it works a level

00:18:46,580 --> 00:18:50,389
one test until level two tests and here

00:18:48,919 --> 00:18:54,080
also told it oh yes

00:18:50,389 --> 00:18:56,330
don't you smugly practicing think back

00:18:54,080 --> 00:18:57,830
what do I mean by multiplexing I'm not

00:18:56,330 --> 00:18:59,470
repeating this because I'm out of time

00:18:57,830 --> 00:19:01,730
but you know there's now what this means

00:18:59,470 --> 00:19:03,909
this means that I have to run the

00:19:01,730 --> 00:19:07,119
program multiple times so now it says

00:19:03,909 --> 00:19:09,099
run one of six up to run six of six

00:19:07,119 --> 00:19:10,779
because it doesn't do multiple

00:19:09,099 --> 00:19:12,519
performance measurement counters at the

00:19:10,779 --> 00:19:15,069
same time it does them in different runs

00:19:12,519 --> 00:19:17,769
which is always a good thing for you to

00:19:15,069 --> 00:19:19,839
do if a the program is repeatable and

00:19:17,769 --> 00:19:21,940
beat it doesn't run for days before you

00:19:19,839 --> 00:19:23,259
could actually do something so if it

00:19:21,940 --> 00:19:25,509
runs in a reasonable amount of time

00:19:23,259 --> 00:19:28,539
always do this because the precision is

00:19:25,509 --> 00:19:29,889
so much higher so in this case so you do

00:19:28,539 --> 00:19:32,049
this and you get the second level

00:19:29,889 --> 00:19:34,779
analysis which is not only be e when

00:19:32,049 --> 00:19:35,889
it's back and pound but specifically B -

00:19:34,779 --> 00:19:38,019
encore

00:19:35,889 --> 00:19:41,049
what's nice core back in found its

00:19:38,019 --> 00:19:42,909
compound and you can go back to the

00:19:41,049 --> 00:19:44,409
picture itself and see what this

00:19:42,909 --> 00:19:45,249
actually means what the next level is

00:19:44,409 --> 00:19:47,259
you cetera cetera

00:19:45,249 --> 00:19:48,909
you can do this up to double for then

00:19:47,259 --> 00:19:51,339
gives this another mode where it does

00:19:48,909 --> 00:19:53,079
all kinds of other things as well so

00:19:51,339 --> 00:19:54,309
this kind of thing already exists you

00:19:53,079 --> 00:19:55,599
don't have to write anything you just

00:19:54,309 --> 00:19:58,959
have to interpret the numbers

00:19:55,599 --> 00:20:01,479
appropriately and that's not as easy as

00:19:58,959 --> 00:20:03,309
well because all they are doing is they

00:20:01,479 --> 00:20:06,039
are looking at the entire execution of

00:20:03,309 --> 00:20:08,579
your program and assigning a number to

00:20:06,039 --> 00:20:11,739
each of these different importance level

00:20:08,579 --> 00:20:13,690
results in this case but this doesn't

00:20:11,739 --> 00:20:15,429
give you any information about work what

00:20:13,690 --> 00:20:17,739
is happening where in the program

00:20:15,429 --> 00:20:19,899
nobody mentioned beginning and in the

00:20:17,739 --> 00:20:22,539
first part that yeah you need off the

00:20:19,899 --> 00:20:25,359
spatial resolution so that's not by a

00:20:22,539 --> 00:20:28,359
simple overview you need to do sampling

00:20:25,359 --> 00:20:30,279
and the good thing is that you even that

00:20:28,359 --> 00:20:33,309
you don't have to really think if using

00:20:30,279 --> 00:20:37,599
top left if you use either show sample

00:20:33,309 --> 00:20:40,719
what you run sample it will analyze

00:20:37,599 --> 00:20:42,519
accordingly top-down methods what your

00:20:40,719 --> 00:20:46,119
program might actually be suffering off

00:20:42,519 --> 00:20:49,449
and then issue inappropriately matching

00:20:46,119 --> 00:20:52,719
sampling command so similar what we have

00:20:49,449 --> 00:20:55,929
before perf record but the events which

00:20:52,719 --> 00:20:59,619
it records are chosen to match the found

00:20:55,929 --> 00:21:01,599
conditions in the program so the thing

00:20:59,619 --> 00:21:03,159
is that much of the knowledge which you

00:21:01,599 --> 00:21:05,440
would have to know about the

00:21:03,159 --> 00:21:07,029
microarchitecture oh yeah well if I

00:21:05,440 --> 00:21:08,199
observe this kind of behavior here so

00:21:07,029 --> 00:21:10,359
what who should have looked for in

00:21:08,199 --> 00:21:10,899
detail that's already encoded in the

00:21:10,359 --> 00:21:14,639
script

00:21:10,899 --> 00:21:17,409
so Andy has done all the work for you

00:21:14,639 --> 00:21:21,629
so if you do that then all of a sudden

00:21:17,409 --> 00:21:24,399
you don't get in information about the

00:21:21,629 --> 00:21:26,440
program anywhere in the in terms of

00:21:24,399 --> 00:21:29,139
these with different levels after

00:21:26,440 --> 00:21:31,450
top-down masa method and Sun you get no

00:21:29,139 --> 00:21:33,549
information in terms of events exactly

00:21:31,450 --> 00:21:36,009
what you need then it says oh yeah in

00:21:33,549 --> 00:21:38,109
this in this address based part are not

00:21:36,009 --> 00:21:40,419
so if you want it if you can use the

00:21:38,109 --> 00:21:43,119
NASA press trip to look at a temporal

00:21:40,419 --> 00:21:46,359
resolution you can see exactly where

00:21:43,119 --> 00:21:47,950
temporarily and look locally the most of

00:21:46,359 --> 00:21:52,479
the time most of the events have been

00:21:47,950 --> 00:21:55,179
occurring so that's easily doable in the

00:21:52,479 --> 00:21:57,309
sense so if you would then just one per

00:21:55,179 --> 00:22:01,749
Freeport and as I mentioned before it

00:21:57,309 --> 00:22:04,419
looks at the files this is the the level

00:22:01,749 --> 00:22:05,669
at the sort of a at the s70 code it

00:22:04,419 --> 00:22:08,950
would look something like that

00:22:05,669 --> 00:22:11,409
it would show where in the source code

00:22:08,950 --> 00:22:13,690
the various events popped up and he can

00:22:11,409 --> 00:22:16,149
look at them the important thing here is

00:22:13,690 --> 00:22:19,179
that I mentioned that we have this PPS

00:22:16,149 --> 00:22:21,909
this precise sampling available but not

00:22:19,179 --> 00:22:24,609
for all events so that's always a plus

00:22:21,909 --> 00:22:27,039
factor there so don't assume that

00:22:24,609 --> 00:22:28,869
because the number here says ten point

00:22:27,039 --> 00:22:31,029
five three percent where happening here

00:22:28,869 --> 00:22:35,289
that it's exactly at this location its

00:22:31,029 --> 00:22:37,719
sound wearing this proximity so there's

00:22:35,289 --> 00:22:40,029
always some form of housing which you

00:22:37,719 --> 00:22:44,919
have to do in your analysis but this

00:22:40,029 --> 00:22:47,499
gives us a lot of information there all

00:22:44,919 --> 00:22:51,070
right so good news is then I mentioned

00:22:47,499 --> 00:22:53,259
this also before is just knowing where

00:22:51,070 --> 00:22:55,960
the the events happen it doesn't tell us

00:22:53,259 --> 00:22:57,849
we knew how it happens to become a

00:22:55,960 --> 00:23:00,039
problem because for that you have to

00:22:57,849 --> 00:23:02,169
actually know from where for instance

00:23:00,039 --> 00:23:05,109
the program was called where the

00:23:02,169 --> 00:23:08,200
function was called not the program so

00:23:05,109 --> 00:23:10,979
for that we have now had facilities in

00:23:08,200 --> 00:23:13,749
the process as well the processor

00:23:10,979 --> 00:23:17,649
includes in its state the set of

00:23:13,749 --> 00:23:19,370
registers called LDR which depending on

00:23:17,649 --> 00:23:21,620
which processor Virginie

00:23:19,370 --> 00:23:23,090
we have four or eight sixteen on

00:23:21,620 --> 00:23:25,040
nowadays and the most recent where we

00:23:23,090 --> 00:23:27,770
are 32 slots in the spread rest there

00:23:25,040 --> 00:23:30,500
where every single time the processor

00:23:27,770 --> 00:23:33,410
executes instruction which is not the

00:23:30,500 --> 00:23:37,970
next instruction it adds a new racket in

00:23:33,410 --> 00:23:40,520
the lvr so with that and by having an

00:23:37,970 --> 00:23:42,890
interrupt and then dumping the original

00:23:40,520 --> 00:23:45,590
the hunting of the lvr we can actually

00:23:42,890 --> 00:23:48,650
trace back where the program team came

00:23:45,590 --> 00:23:50,690
from with a certain resolution if you

00:23:48,650 --> 00:23:53,180
have a tight loop well of course the 32

00:23:50,690 --> 00:23:54,620
records were soon be exhausted if you

00:23:53,180 --> 00:23:55,910
have a function called a function of

00:23:54,620 --> 00:23:58,580
course a function calls a function and

00:23:55,910 --> 00:23:59,290
Sun we can very easily reconstruct the

00:23:58,580 --> 00:24:02,360
call trace

00:23:59,290 --> 00:24:04,760
so that's easily doable nowadays and so

00:24:02,360 --> 00:24:06,530
on and more importantly for many

00:24:04,760 --> 00:24:10,400
situations and that's something which is

00:24:06,530 --> 00:24:12,890
somewhat being ax exploited in the tools

00:24:10,400 --> 00:24:16,010
today but not really fully this is where

00:24:12,890 --> 00:24:17,930
some of my work I'm saying my own tools

00:24:16,010 --> 00:24:20,030
is there's nothing there's another

00:24:17,930 --> 00:24:22,460
extension to the process of interest

00:24:20,030 --> 00:24:25,700
providing for tracing pts the technology

00:24:22,460 --> 00:24:28,970
would having where you have a very low

00:24:25,700 --> 00:24:31,040
bit rate recording of every single

00:24:28,970 --> 00:24:32,810
instruction you get executed so you can

00:24:31,040 --> 00:24:34,820
actually record the trace of the entire

00:24:32,810 --> 00:24:36,710
program without significantly slowing

00:24:34,820 --> 00:24:39,260
down your program if record this kind of

00:24:36,710 --> 00:24:41,450
thing along with the perf data with that

00:24:39,260 --> 00:24:44,360
we can actually trace the entire program

00:24:41,450 --> 00:24:46,460
execution and see by the association of

00:24:44,360 --> 00:24:47,810
the time event that sort of times time

00:24:46,460 --> 00:24:50,390
counters of the events which we are

00:24:47,810 --> 00:24:52,100
counting and the events for the PT

00:24:50,390 --> 00:24:54,320
records and so on we can actually

00:24:52,100 --> 00:24:56,870
associate them and find out exactly

00:24:54,320 --> 00:24:59,990
where when what happened in the program

00:24:56,870 --> 00:25:02,900
and reconstruct that it just is a lot of

00:24:59,990 --> 00:25:05,300
work but it's there it's all possible to

00:25:02,900 --> 00:25:07,760
do and the whole thing is that as a

00:25:05,300 --> 00:25:10,130
programmer now will through the PMU

00:25:07,760 --> 00:25:12,860
tools available tough life analysis you

00:25:10,130 --> 00:25:17,330
can start away with this very easily you

00:25:12,860 --> 00:25:20,630
let the scripts do the analysis and you

00:25:17,330 --> 00:25:22,580
get to the point but this gives you a

00:25:20,630 --> 00:25:25,820
global view of the path the program how

00:25:22,580 --> 00:25:26,800
it performs it's a one number summary

00:25:25,820 --> 00:25:29,380
for the program

00:25:26,800 --> 00:25:32,380
sound but as as I mentioned before there

00:25:29,380 --> 00:25:35,530
the program has different stages to be

00:25:32,380 --> 00:25:37,750
able to really useful you have to create

00:25:35,530 --> 00:25:40,540
basically micro benchmarks for different

00:25:37,750 --> 00:25:43,390
parts of the program and ideally you are

00:25:40,540 --> 00:25:46,260
able to isolate different parts of the

00:25:43,390 --> 00:25:48,790
program so sometimes you can do this by

00:25:46,260 --> 00:25:50,710
actually providing different binary

00:25:48,790 --> 00:25:52,360
which are just doing different parts of

00:25:50,710 --> 00:25:54,250
your program for instance in a compiler

00:25:52,360 --> 00:25:56,410
you are creating a different binary

00:25:54,250 --> 00:26:00,040
which just just does the scanning the

00:25:56,410 --> 00:26:01,390
other part does just the the tree the IR

00:26:00,040 --> 00:26:03,550
the intermediate representation

00:26:01,390 --> 00:26:05,200
representation the other one does only

00:26:03,550 --> 00:26:07,810
code generation than the individual

00:26:05,200 --> 00:26:09,340
optimization passes etcetera etcetera so

00:26:07,810 --> 00:26:12,550
if you can do these kind of things you

00:26:09,340 --> 00:26:14,500
can individually profile individual

00:26:12,550 --> 00:26:17,290
pieces which make up the program itself

00:26:14,500 --> 00:26:19,750
then you can analyze them if you would

00:26:17,290 --> 00:26:21,760
do this as a whole you would not

00:26:19,750 --> 00:26:23,800
necessarily know what you are looking at

00:26:21,760 --> 00:26:26,800
at any point in time it becomes so much

00:26:23,800 --> 00:26:29,560
more complicated so with that this is

00:26:26,800 --> 00:26:31,210
part which no 2 can help you with there

00:26:29,560 --> 00:26:32,980
is something which when you're writing

00:26:31,210 --> 00:26:37,470
codes you have to make sure that you can

00:26:32,980 --> 00:26:40,480
do something like this yourself ok I

00:26:37,470 --> 00:26:43,210
already mentioned that these are the

00:26:40,480 --> 00:26:44,860
top-down methods on is using all these

00:26:43,210 --> 00:26:46,810
kind of ratios et cetera but they are

00:26:44,860 --> 00:26:49,390
not all of them the Intel has been for

00:26:46,810 --> 00:26:53,140
the longest time but also AMD has a

00:26:49,390 --> 00:26:55,690
similar manual but they are not as good

00:26:53,140 --> 00:26:58,720
in keeping after date and and and

00:26:55,690 --> 00:27:00,190
completing it but in terrorism as what

00:26:58,720 --> 00:27:01,960
is what they're calling optimization

00:27:00,190 --> 00:27:03,730
manual there specifically there's a

00:27:01,960 --> 00:27:06,130
chapter or an appendix more correctly

00:27:03,730 --> 00:27:09,010
called using performance monitoring

00:27:06,130 --> 00:27:12,510
events and for that they are listing for

00:27:09,010 --> 00:27:15,820
different market architectures ratios

00:27:12,510 --> 00:27:17,710
dozens hundreds of ratios with

00:27:15,820 --> 00:27:20,740
explanations of what they're measuring

00:27:17,710 --> 00:27:22,450
plus the way you're actually using them

00:27:20,740 --> 00:27:25,420
or how do you know you're computing them

00:27:22,450 --> 00:27:28,060
that's incredibly useful this is an

00:27:25,420 --> 00:27:30,220
extension to that top-down method you

00:27:28,060 --> 00:27:32,500
would use the top-down method of course

00:27:30,220 --> 00:27:33,549
but then if you're really going into

00:27:32,500 --> 00:27:35,739
this you can measure

00:27:33,549 --> 00:27:37,989
even more thanks and all of these events

00:27:35,739 --> 00:27:43,899
you should be able to get through the

00:27:37,989 --> 00:27:47,320
perfect device so then after it changed

00:27:43,899 --> 00:27:49,239
so once you have analyzed things and you

00:27:47,320 --> 00:27:51,450
need to change your program how do you

00:27:49,239 --> 00:27:54,759
actually see whether you make progress

00:27:51,450 --> 00:27:58,509
yes you can do statistical analysis you

00:27:54,759 --> 00:28:01,090
can but oftentimes the changes which you

00:27:58,509 --> 00:28:04,110
are making will have the facts which are

00:28:01,090 --> 00:28:07,570
small how do you differentiate that

00:28:04,110 --> 00:28:10,389
positive or negative change from the

00:28:07,570 --> 00:28:12,429
noise so this is why you usually should

00:28:10,389 --> 00:28:14,109
use something else and I mentioned this

00:28:12,429 --> 00:28:17,559
in the first part as well this set of

00:28:14,109 --> 00:28:20,590
interface is called papi and with that

00:28:17,559 --> 00:28:23,169
you can easily read absolute values of

00:28:20,590 --> 00:28:26,830
certain counters in this and so here's

00:28:23,169 --> 00:28:28,690
the example so before my the work which

00:28:26,830 --> 00:28:31,239
I'm actually investigating I'm reading

00:28:28,690 --> 00:28:33,749
the counters after that I'm reading them

00:28:31,239 --> 00:28:39,059
again then just compute the difference

00:28:33,749 --> 00:28:42,820
the result is that I can count

00:28:39,059 --> 00:28:44,919
individual numbers of events from the

00:28:42,820 --> 00:28:46,929
inside the work which I've done this

00:28:44,919 --> 00:28:48,489
does not mean that there's no variance

00:28:46,929 --> 00:28:51,480
in the numbers if I repeat this because

00:28:48,489 --> 00:28:54,279
I mentioned it's a very beginning their

00:28:51,480 --> 00:28:55,899
CPUs are basically stochastic by

00:28:54,279 --> 00:28:58,570
themselves there's so many different

00:28:55,899 --> 00:29:00,759
independent events that there is never a

00:28:58,570 --> 00:29:03,309
one repetition it's exactly the same as

00:29:00,759 --> 00:29:05,830
the other one but you have absolute

00:29:03,309 --> 00:29:08,649
values and if you are measuring very

00:29:05,830 --> 00:29:11,289
short intervals of time to which normal

00:29:08,649 --> 00:29:13,720
statistics will not give you good enough

00:29:11,289 --> 00:29:15,669
result in this case you can actually get

00:29:13,720 --> 00:29:18,100
really really good results and you get

00:29:15,669 --> 00:29:20,230
some times for certain events you

00:29:18,100 --> 00:29:22,779
actually have variants which are counted

00:29:20,230 --> 00:29:24,669
by one or two so it's one or two percent

00:29:22,779 --> 00:29:28,330
the individual events you can actually

00:29:24,669 --> 00:29:29,690
count that's really a nice thing for you

00:29:28,330 --> 00:29:31,700
to do and if you

00:29:29,690 --> 00:29:34,190
changing some coach you also know

00:29:31,700 --> 00:29:36,350
exactly where the effect can be measured

00:29:34,190 --> 00:29:36,650
there just at this appropriate cards and

00:29:36,350 --> 00:29:39,650
so on

00:29:36,650 --> 00:29:41,510
and the nice thing is that in

00:29:39,650 --> 00:29:43,940
preparation for that so you have to set

00:29:41,510 --> 00:29:46,490
up this event set which is used in these

00:29:43,940 --> 00:29:48,050
cards and if you do it right and this is

00:29:46,490 --> 00:29:50,390
a sketch of how you do this are

00:29:48,050 --> 00:29:53,420
different coats arduous so I usually

00:29:50,390 --> 00:29:55,370
prepare my program so that if I set an

00:29:53,420 --> 00:29:57,290
environment variable with the names of

00:29:55,370 --> 00:29:59,840
the events which I want to measure I

00:29:57,290 --> 00:30:01,730
have to code like this to parse the

00:29:59,840 --> 00:30:04,610
environment variable and program the

00:30:01,730 --> 00:30:07,520
event set appropriately so that to count

00:30:04,610 --> 00:30:08,990
different sets in different runs of the

00:30:07,520 --> 00:30:11,990
program I only have to change an

00:30:08,990 --> 00:30:14,630
environment variable and run it again so

00:30:11,990 --> 00:30:16,580
this makes it really easy to to run

00:30:14,630 --> 00:30:23,300
through a lots and lots of experiments

00:30:16,580 --> 00:30:26,570
so for will mention remember that all

00:30:23,300 --> 00:30:29,020
right that was the quick part of this so

00:30:26,570 --> 00:30:36,520
I think I've run out of time

00:30:29,020 --> 00:30:36,520
any questions yes subir

00:30:39,580 --> 00:30:44,850
intel vtune is proprietary I don't touch

00:30:42,789 --> 00:30:44,850
it

00:30:46,830 --> 00:30:52,289
yes ask us Joe more about us he knows it

00:30:52,679 --> 00:31:02,549
yes he's fighting for the mic stand up a

00:30:59,340 --> 00:31:05,940
few years back we played with vtune and

00:31:02,549 --> 00:31:08,139
working with the developers of earth and

00:31:05,940 --> 00:31:10,239
everything in VIII tone you can do

00:31:08,139 --> 00:31:12,429
imperfect and a lot of what vtune does

00:31:10,239 --> 00:31:16,869
is exactly about two or three slides

00:31:12,429 --> 00:31:18,639
back where it talked about if you all

00:31:16,869 --> 00:31:22,749
the ratios if you want to look at a hot

00:31:18,639 --> 00:31:24,720
area here look at these events and in

00:31:22,749 --> 00:31:28,200
this ratio and here's what it means and

00:31:24,720 --> 00:31:31,299
vtune kind of makes it easy for you to

00:31:28,200 --> 00:31:35,049
look at that all that's available in

00:31:31,299 --> 00:31:38,799
Perth in fact Andy claims tools do a lot

00:31:35,049 --> 00:31:42,580
of what v2 does an open source so your

00:31:38,799 --> 00:31:50,789
envy tune is a 300-pound monster it's a

00:31:42,580 --> 00:31:52,210
it's very heavy weight so I so that's

00:31:50,789 --> 00:32:02,340
anything else

00:31:52,210 --> 00:32:04,889
so thanks Joe all right to do the the

00:32:02,340 --> 00:32:07,210
times when the events actually trigger I

00:32:04,889 --> 00:32:09,759
do they ever get correlated with the

00:32:07,210 --> 00:32:13,090
workflow or at the workload or can you

00:32:09,759 --> 00:32:15,399
assume that they're random no said he

00:32:13,090 --> 00:32:18,070
events you're counting certain events so

00:32:15,399 --> 00:32:19,539
things like let's say last level cache

00:32:18,070 --> 00:32:21,759
misses yeah yeah they are of course

00:32:19,539 --> 00:32:25,509
correlated with the with the work no I

00:32:21,759 --> 00:32:27,789
mean when you actually register them so

00:32:25,509 --> 00:32:30,220
but this is where the the tracing by the

00:32:27,789 --> 00:32:33,220
the association of the events to the

00:32:30,220 --> 00:32:36,070
timestamps and also to the instruction

00:32:33,220 --> 00:32:37,929
comes into play so in the earlier

00:32:36,070 --> 00:32:39,879
versions they were happy just to create

00:32:37,929 --> 00:32:44,109
the events of the hour

00:32:39,879 --> 00:32:45,999
of the CPUs later on Sanford PBS insan

00:32:44,109 --> 00:32:48,579
they actually are able to record exact

00:32:45,999 --> 00:32:50,799
instructions for that and so it's a

00:32:48,579 --> 00:32:52,449
quality of implementation off the CPU

00:32:50,799 --> 00:32:55,329
and how much you pay for this

00:32:52,449 --> 00:32:56,859
certificate or more clearly the when

00:32:55,329 --> 00:32:59,139
you're time sharing because you're

00:32:56,859 --> 00:33:01,139
you're young you should never timeshare

00:32:59,139 --> 00:33:05,289
so if you do time sharing all bets off

00:33:01,139 --> 00:33:07,179
literally so don't do it so the only

00:33:05,289 --> 00:33:09,549
time when you're doing time sharing is

00:33:07,179 --> 00:33:12,399
if you have a gigantic non ending

00:33:09,549 --> 00:33:14,440
process at which you cannot afford to

00:33:12,399 --> 00:33:16,949
repeat the measurements many many times

00:33:14,440 --> 00:33:19,779
and where you do the measurements over

00:33:16,949 --> 00:33:22,929
hours and so on so that the numbers

00:33:19,779 --> 00:33:26,519
actually mean something but not if

00:33:22,929 --> 00:33:26,519

YouTube URL: https://www.youtube.com/watch?v=93kk-avSGIM


