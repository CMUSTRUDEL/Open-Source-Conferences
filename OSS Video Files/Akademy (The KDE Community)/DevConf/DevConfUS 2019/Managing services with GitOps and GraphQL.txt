Title: Managing services with GitOps and GraphQL
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Jamie Melis

Our SRE team manages many business-critical applications that run on top of OpenShift clusters. We are responsible for the pipelines that ultimately deliver managed OpenShift clusters to customers.

We require automation in order to manage all the associated dependencies and supporting services, for example, creating container registries, managing OpenShift secrets, configuring the policies in Vault instances, etc.

To this end, we have created Qontract, an automation GitOps framework that enables self-service for developers, and relies on GraphQL to ensure language independence.

We will demonstrate how you can use this framework to create resilient pipelines that translate PRs into idempotent commands that configure any supporting services.

https://github.com/app-sre/qontract-server
Captions: 
	00:00:08,150 --> 00:00:17,510
okay so I'm talking about how we met

00:00:12,539 --> 00:00:17,510
services using drops and the graph QL

00:00:17,690 --> 00:00:25,410
this talk is still better a team with

00:00:21,480 --> 00:00:30,380
the office reading with in Red Hat the

00:00:25,410 --> 00:00:34,079
service in this team and talk about is

00:00:30,380 --> 00:00:36,780
our evolution revolution since last year

00:00:34,079 --> 00:00:42,840
into this year how we use the gear ops

00:00:36,780 --> 00:00:45,270
to to design the way to scale up so last

00:00:42,840 --> 00:00:48,149
year we running just one service we

00:00:45,270 --> 00:00:50,489
running basically just one and we

00:00:48,149 --> 00:00:53,910
decided that we basically were seeing

00:00:50,489 --> 00:00:56,640
that we weren't able to scale up so we

00:00:53,910 --> 00:00:59,180
try to implement the system based on get

00:00:56,640 --> 00:01:01,640
ops to allow us to deliver more services

00:00:59,180 --> 00:01:12,290
so now today

00:01:01,640 --> 00:01:14,509
managing 17 services solution and

00:01:12,290 --> 00:01:18,380
implementer we identified a few

00:01:14,509 --> 00:01:21,560
challenges and we build futures around

00:01:18,380 --> 00:01:26,360
these challenges to alleviate them talk

00:01:21,560 --> 00:01:28,610
about those especially these tools at

00:01:26,360 --> 00:01:31,130
the core of the idea that we used we

00:01:28,610 --> 00:01:33,049
borrowed the kubernetes programming

00:01:31,130 --> 00:01:35,479
model specifically the idea of the kind

00:01:33,049 --> 00:01:40,630
of controllers we tried to create

00:01:35,479 --> 00:01:48,920
controllers we call them integrations

00:01:40,630 --> 00:01:50,810
that essentially inside the state state

00:01:48,920 --> 00:01:56,509
to the side state with the current state

00:01:50,810 --> 00:01:57,890
just like I will talk about the

00:01:56,509 --> 00:02:02,090
integrations that we have and how we

00:01:57,890 --> 00:02:06,890
build them and how together and the last

00:02:02,090 --> 00:02:09,340
things we can prove in this platform and

00:02:06,890 --> 00:02:09,340
what is the

00:02:10,410 --> 00:02:17,130
so let's start by the team

00:02:13,740 --> 00:02:21,470
that is called a p3 it stands for

00:02:17,130 --> 00:02:24,990
application side and our goal is to run

00:02:21,470 --> 00:02:28,350
internal services and deploy them in

00:02:24,990 --> 00:02:31,020
open ship dedicated the key ideas that

00:02:28,350 --> 00:02:33,420
we are regular customers of APIs

00:02:31,020 --> 00:02:42,180
interrogated so we can see them in the

00:02:33,420 --> 00:02:45,540
exact same way that customers will it's

00:02:42,180 --> 00:02:48,110
just fully managed kubernetes awfully

00:02:45,540 --> 00:02:50,430
offering that method has and you can

00:02:48,110 --> 00:02:54,560
repair that you can buy it but it's a

00:02:50,430 --> 00:02:54,560
service you can buy a subscription and

00:02:56,090 --> 00:03:00,860
applications in these focus of clusters

00:03:01,910 --> 00:03:09,720
dedicated is fully managed and it has

00:03:07,940 --> 00:03:12,870
one thing that I think it's worth

00:03:09,720 --> 00:03:14,370
mentioning the you don't receive as a

00:03:12,870 --> 00:03:16,380
tenant there's a customer of this for

00:03:14,370 --> 00:03:19,170
that you don't have cluster admin

00:03:16,380 --> 00:03:21,350
because the cluster is being managed by

00:03:19,170 --> 00:03:25,500
other teams in ratata

00:03:21,350 --> 00:03:28,020
so what you get is another thing that we

00:03:25,500 --> 00:03:29,970
call it dedicated admin and will

00:03:28,020 --> 00:03:33,570
essentially allow you to be and become

00:03:29,970 --> 00:03:34,890
admin in all the namespaces this is just

00:03:33,570 --> 00:03:37,520
a minor detail but I think it's

00:03:34,890 --> 00:03:39,530
interesting because

00:03:37,520 --> 00:03:41,690
Letta builds operation dedicated and

00:03:39,530 --> 00:03:44,540
even though we are inside with our penis

00:03:41,690 --> 00:03:47,120
that we consume it as customers so we

00:03:44,540 --> 00:03:51,950
have to abide by the requirements and by

00:03:47,120 --> 00:03:54,170
the way by the way the service works so

00:03:51,950 --> 00:03:57,920
I said we run services and applications

00:03:54,170 --> 00:04:00,500
I guess I have to explain what kind of

00:03:57,920 --> 00:04:03,760
applications we run typically the

00:04:00,500 --> 00:04:07,070
applications are web applications for

00:04:03,760 --> 00:04:09,860
micro services that compose a bigger

00:04:07,070 --> 00:04:11,660
service in themselves I'm gonna talk

00:04:09,860 --> 00:04:15,650
about two examples of things that we run

00:04:11,660 --> 00:04:18,290
we run these for projects and parameters

00:04:15,650 --> 00:04:21,470
in seen at the ocm would start stands

00:04:18,290 --> 00:04:26,390
for opposite cluster management and hi

00:04:21,470 --> 00:04:29,530
and all these services in themselves

00:04:26,390 --> 00:04:33,230
they compose the opposite dedicated for

00:04:29,530 --> 00:04:35,360
provisioning platform so we go to cloud

00:04:33,230 --> 00:04:39,140
method becomes less openshift you will

00:04:35,360 --> 00:04:44,260
see a UI and if you this will allow you

00:04:39,140 --> 00:04:48,130
to deploy OSD clusters subscription and

00:04:44,260 --> 00:04:51,080
everything that passes and replace them

00:04:48,130 --> 00:04:54,470
those are services that we run and it's

00:04:51,080 --> 00:04:56,570
interesting make this a lot because we

00:04:54,470 --> 00:04:58,190
are running an open shape it's a chicken

00:04:56,570 --> 00:05:00,620
and egg situation you're running the

00:04:58,190 --> 00:05:02,330
service on openshift

00:05:00,620 --> 00:05:04,040
that allows you to produce an open

00:05:02,330 --> 00:05:08,039
service so I think it's interesting and

00:05:04,040 --> 00:05:10,830
I think it relates

00:05:08,039 --> 00:05:14,099
Xplosive a well the capabilities of a

00:05:10,830 --> 00:05:15,509
bishop dedicated because meaning this

00:05:14,099 --> 00:05:18,270
means that you are able to build things

00:05:15,509 --> 00:05:20,490
as complex as a platform you know that

00:05:18,270 --> 00:05:24,419
matter a fully managed platform just

00:05:20,490 --> 00:05:28,319
with dedicated another example is a clip

00:05:24,419 --> 00:05:30,930
chain Chopin shaved Ohio it's an online

00:05:28,319 --> 00:05:34,289
ID you can go there and can you said

00:05:30,930 --> 00:05:40,590
it's an online ID that has interesting

00:05:34,289 --> 00:05:42,870
features so the service how do we run a

00:05:40,590 --> 00:05:47,099
service well the theory is very simple

00:05:42,870 --> 00:05:51,319
right we just generally have two

00:05:47,099 --> 00:05:54,090
environments staging and production we

00:05:51,319 --> 00:05:56,159
the developers they give us these

00:05:54,090 --> 00:06:00,689
appointments and we just run them like

00:05:56,159 --> 00:06:02,969
OC apply OC or you can apply we have to

00:06:00,689 --> 00:06:05,550
provision other opposite resources like

00:06:02,969 --> 00:06:09,139
config map secrets and if they ask for

00:06:05,550 --> 00:06:12,509
databases with provisional areas etc

00:06:09,139 --> 00:06:14,099
that in order to be in order for it to

00:06:12,509 --> 00:06:16,680
be possible for us to offer this to the

00:06:14,099 --> 00:06:18,689
customers we have to manage the vanessi

00:06:16,680 --> 00:06:21,240
customers I mean internal developers

00:06:18,689 --> 00:06:22,740
that are the owners of this service we

00:06:21,240 --> 00:06:24,599
have to manage them we have to give them

00:06:22,740 --> 00:06:27,659
access to the clusters we have to

00:06:24,599 --> 00:06:32,009
municipal bindings Aspen for the user

00:06:27,659 --> 00:06:34,319
names set up the pipeline's so we are

00:06:32,009 --> 00:06:36,659
able to do actually you know promotion

00:06:34,319 --> 00:06:40,030
to staging promotions abroad so this is

00:06:36,659 --> 00:06:41,440
generally it is very simple but

00:06:40,030 --> 00:06:42,760
in the end it gets a bit coming to

00:06:41,440 --> 00:06:46,960
convolute ER because you have to manage

00:06:42,760 --> 00:06:49,030
a lot of things so let me introduce to

00:06:46,960 --> 00:06:54,130
you a few of the things that we had to

00:06:49,030 --> 00:06:55,720
deal with back in 2018 I wear a sari is

00:06:54,130 --> 00:07:00,370
right so we try to automate everything

00:06:55,720 --> 00:07:01,840
but like every interaction that we had

00:07:00,370 --> 00:07:03,790
to be the developers meant like a

00:07:01,840 --> 00:07:06,220
different thing that we had to do and we

00:07:03,790 --> 00:07:09,700
kept building stuff for instance in this

00:07:06,220 --> 00:07:12,070
case is a new developer that comes and

00:07:09,700 --> 00:07:15,040
says hey I want to deploy a service so

00:07:12,070 --> 00:07:17,290
what do we do we create a new namespace

00:07:15,040 --> 00:07:18,970
and provision the resources they want of

00:07:17,290 --> 00:07:24,880
course this is automated we had a script

00:07:18,970 --> 00:07:26,800
the best is this introduces two things a

00:07:24,880 --> 00:07:28,210
manual processes which the manual

00:07:26,800 --> 00:07:29,740
process is running a script that

00:07:28,210 --> 00:07:32,620
provisions all the things that are they

00:07:29,740 --> 00:07:34,980
required to be bootstrap and Jenkins

00:07:32,620 --> 00:07:36,970
pipelines so we were able you know to

00:07:34,980 --> 00:07:39,180
delivery the pipeline's that they will

00:07:36,970 --> 00:07:44,040
need to actually

00:07:39,180 --> 00:07:44,040
lifecycle these jobs this services

00:07:44,280 --> 00:07:50,169
another example is when they came to us

00:07:47,229 --> 00:07:52,120
asking hey we need the database and at

00:07:50,169 --> 00:07:54,070
first for a long time we were just

00:07:52,120 --> 00:07:57,130
provisioning the databases through the

00:07:54,070 --> 00:08:00,130
AWS console and that was a lot of

00:07:57,130 --> 00:08:02,260
clicking so we ended up using terraform

00:08:00,130 --> 00:08:04,990
so now we have another thing we have

00:08:02,260 --> 00:08:08,500
terraform and in order to send send them

00:08:04,990 --> 00:08:11,520
the passwords for database we had to ask

00:08:08,500 --> 00:08:11,520
them for DDD keys

00:08:12,270 --> 00:08:19,900
so so we could send them send them the

00:08:16,030 --> 00:08:22,810
password another example which cost a

00:08:19,900 --> 00:08:24,879
lot of this one was quite problematic is

00:08:22,810 --> 00:08:27,759
when I need them I need to remember it

00:08:24,879 --> 00:08:30,580
came we had to grant them access to the

00:08:27,759 --> 00:08:32,320
namespaces how do we know what

00:08:30,580 --> 00:08:34,180
namespaces do we need access to in what

00:08:32,320 --> 00:08:38,229
clusters what namespaces we had to keep

00:08:34,180 --> 00:08:40,120
a log of whether teams were approving

00:08:38,229 --> 00:08:42,909
the members of the teams what namespaces

00:08:40,120 --> 00:08:45,519
they owned and we had to you know we had

00:08:42,909 --> 00:08:53,170
a data repository in which we included

00:08:45,519 --> 00:08:55,870
all these data same story they had to

00:08:53,170 --> 00:08:59,140
give it to us encrypted so we had to

00:08:55,870 --> 00:09:01,300
exchange the PG keys and we have to send

00:08:59,140 --> 00:09:03,690
on the gbg key and we would also apply

00:09:01,300 --> 00:09:06,790
it and then we would save it locally in

00:09:03,690 --> 00:09:09,250
an encrypted gate that the developers

00:09:06,790 --> 00:09:10,899
didn't have access to so you know when

00:09:09,250 --> 00:09:14,200
I'm getting at this was a bit of a mess

00:09:10,899 --> 00:09:16,270
we got a lot of team interrupts people

00:09:14,200 --> 00:09:21,420
say developer saying hey we want to do

00:09:16,270 --> 00:09:23,800
this and we got stuck at this stage

00:09:21,420 --> 00:09:27,160
money and reconciliation was a problem

00:09:23,800 --> 00:09:29,709
if someone left the team we had to

00:09:27,160 --> 00:09:32,589
deprovision them from the clusters from

00:09:29,709 --> 00:09:35,110
github organization all these things and

00:09:32,589 --> 00:09:36,880
we have to keep track of those so we had

00:09:35,110 --> 00:09:38,980
another data repositories where we kept

00:09:36,880 --> 00:09:42,490
track of these things and separate

00:09:38,980 --> 00:09:44,920
scripts that dealt with this so the

00:09:42,490 --> 00:09:47,680
years summary was that was that we had a

00:09:44,920 --> 00:09:50,680
lot of processes we had a bunch of

00:09:47,680 --> 00:09:53,200
scripts written by different the series

00:09:50,680 --> 00:09:55,490
in our team something goals I mean

00:09:53,200 --> 00:09:57,470
pythons I'm embarrassed

00:09:55,490 --> 00:09:59,240
we deployed a lot of services they

00:09:57,470 --> 00:10:00,980
weren't interconnected each one well of

00:09:59,240 --> 00:10:02,930
course we automated stuff we were using

00:10:00,980 --> 00:10:05,570
ansible who were using Jenkins job

00:10:02,930 --> 00:10:08,510
supervision things were using small key

00:10:05,570 --> 00:10:10,310
types implementations so when you

00:10:08,510 --> 00:10:13,370
committed something to APO some repo

00:10:10,310 --> 00:10:17,270
something happened so in the end we were

00:10:13,370 --> 00:10:19,130
just 21 service and we had a bit of a

00:10:17,270 --> 00:10:21,320
mess and we really needed to get out of

00:10:19,130 --> 00:10:23,750
this because the idea for the ping was

00:10:21,320 --> 00:10:30,260
to be able to run a lot more services so

00:10:23,750 --> 00:10:32,360
fast forward one year the previous slide

00:10:30,260 --> 00:10:35,600
would finish about a year ago more or

00:10:32,360 --> 00:10:39,140
less 2018 around after summer

00:10:35,600 --> 00:10:41,390
Marlys September so and nowadays we're

00:10:39,140 --> 00:10:45,500
running this real ranks 17 services

00:10:41,390 --> 00:10:49,070
managing 250 developers lots of roles

00:10:45,500 --> 00:10:53,810
lots of permissions AWS accounts Cray

00:10:49,070 --> 00:10:56,720
oryx and we do this with same seven

00:10:53,810 --> 00:10:58,600
members that we were people have changed

00:10:56,720 --> 00:11:01,550
but the number has stayed the same and

00:10:58,600 --> 00:11:04,580
we are we think that we prepare to scale

00:11:01,550 --> 00:11:06,380
a lot more we are basically doing this

00:11:04,580 --> 00:11:10,940
using the solution that we built around

00:11:06,380 --> 00:11:14,450
guitars so let's go let's talk about the

00:11:10,940 --> 00:11:16,640
solutions this is a knife approach the

00:11:14,450 --> 00:11:19,070
initial approach this is the design that

00:11:16,640 --> 00:11:22,070
we had in our minds let's have a good

00:11:19,070 --> 00:11:24,589
repo with everything that we have just

00:11:22,070 --> 00:11:27,050
one single repo and the whole goal is

00:11:24,589 --> 00:11:28,970
that if someone was to do something they

00:11:27,050 --> 00:11:31,430
just send the PR and when we merge it

00:11:28,970 --> 00:11:33,620
something is going to happen that will

00:11:31,430 --> 00:11:36,260
you know configure this service the

00:11:33,620 --> 00:11:40,520
person one board someone of course

00:11:36,260 --> 00:11:41,670
someone etc so we thought that we wanted

00:11:40,520 --> 00:11:45,960
to

00:11:41,670 --> 00:11:48,450
do this using reconciliation loops in

00:11:45,960 --> 00:11:52,530
kubernetes style things you have

00:11:48,450 --> 00:11:56,370
different scripts than this this box

00:11:52,530 --> 00:11:59,130
here this box here oops

00:11:56,370 --> 00:12:01,050
represents several scripts and it script

00:11:59,130 --> 00:12:03,500
is like one controller one could rent

00:12:01,050 --> 00:12:06,540
this controller that that's one thing

00:12:03,500 --> 00:12:09,260
deploy a bunch of scripts manage github

00:12:06,540 --> 00:12:13,290
organizations manage crazy registries

00:12:09,260 --> 00:12:16,680
things like this and the idea was very

00:12:13,290 --> 00:12:18,600
pretty but we identified several things

00:12:16,680 --> 00:12:19,560
that we didn't like and I will get that

00:12:18,600 --> 00:12:21,510
in a minute

00:12:19,560 --> 00:12:23,280
so let me talk a little bit more about

00:12:21,510 --> 00:12:26,880
reconciliation loop for loops for

00:12:23,280 --> 00:12:28,680
kubernetes reconciliation loops there

00:12:26,880 --> 00:12:43,140
have been some talks today about these

00:12:28,680 --> 00:12:44,460
things controllers and the first thing

00:12:43,140 --> 00:12:46,650
for me personally was that we were

00:12:44,460 --> 00:12:48,990
changing for an imperative model to a

00:12:46,650 --> 00:12:51,000
declarative model instead of saying hey

00:12:48,990 --> 00:12:53,850
we want to do this we are running this

00:12:51,000 --> 00:12:56,940
script the idea was to describe your

00:12:53,850 --> 00:13:00,210
desired state it's declarative and then

00:12:56,940 --> 00:13:04,070
something will happen that will evolve

00:13:00,210 --> 00:13:07,140
the current state to your desired state

00:13:04,070 --> 00:13:09,810
in kubernetes same thing happens you

00:13:07,140 --> 00:13:11,760
have your user provided United States

00:13:09,810 --> 00:13:14,520
with resides in at CD

00:13:11,760 --> 00:13:16,040
a simple infinite loop that repeats

00:13:14,520 --> 00:13:19,680
again and again and again and

00:13:16,040 --> 00:13:22,590
controllers which in our github setup we

00:13:19,680 --> 00:13:25,920
called them integrations they what

00:13:22,590 --> 00:13:28,560
specific resource types like replicas

00:13:25,920 --> 00:13:31,770
sets and they deal with the differences

00:13:28,560 --> 00:13:34,200
the user wants replica set with seven

00:13:31,770 --> 00:13:36,090
parts that there are only six parts I

00:13:34,200 --> 00:13:39,030
have to deploy a new part so it

00:13:36,090 --> 00:13:40,560
reconciles this data so this is what we

00:13:39,030 --> 00:13:47,000
wanted to do and this is what we wanted

00:13:40,560 --> 00:13:49,890
to translate to the key tops world so we

00:13:47,000 --> 00:13:53,700
track single people reconciliation loop

00:13:49,890 --> 00:13:56,670
but we found four big problems the first

00:13:53,700 --> 00:14:00,240
thing is schema validation I will talk

00:13:56,670 --> 00:14:02,340
about this in the next slide and then we

00:14:00,240 --> 00:14:05,070
have three interconnected problems which

00:14:02,340 --> 00:14:06,870
are data redundancy repeated logic and

00:14:05,070 --> 00:14:09,240
language independence we found that if

00:14:06,870 --> 00:14:14,280
we did this the integrations repeated a

00:14:09,240 --> 00:14:17,610
lot of code where we had there was a lot

00:14:14,280 --> 00:14:19,260
of logic in integrations that was simply

00:14:17,610 --> 00:14:22,350
you know reading from the git repo

00:14:19,260 --> 00:14:27,020
loading files doing stuff that is really

00:14:22,350 --> 00:14:29,460
that wasn't didn't provide any value you

00:14:27,020 --> 00:14:32,100
could say well you could write a library

00:14:29,460 --> 00:14:34,650
to alleviate that but if we do that then

00:14:32,100 --> 00:14:37,950
we'll bounce to one we are tied to one

00:14:34,650 --> 00:14:40,380
language and we wanted something that

00:14:37,950 --> 00:14:43,329
would allow us to deploy you know one

00:14:40,380 --> 00:14:44,980
controller one integration in

00:14:43,329 --> 00:14:47,249
another one write it in Python another

00:14:44,980 --> 00:14:51,819
one in bash that was the whole idea

00:14:47,249 --> 00:14:53,499
so went back to schema validation let's

00:14:51,819 --> 00:14:56,199
say you have a script that will read

00:14:53,499 --> 00:14:57,699
from the git repo and it expects someone

00:14:56,199 --> 00:15:01,420
to be fine

00:14:57,699 --> 00:15:04,179
I usually this way a field called name a

00:15:01,420 --> 00:15:06,569
field called github username and a list

00:15:04,179 --> 00:15:10,199
of permissions where every permission is

00:15:06,569 --> 00:15:12,999
has those three items to say something

00:15:10,199 --> 00:15:14,470
what happens if someone in obviously the

00:15:12,999 --> 00:15:20,049
whole idea here is to be able to

00:15:14,470 --> 00:15:21,899
self-service this so developers will be

00:15:20,049 --> 00:15:26,470
sending PRS but if they make a mistake

00:15:21,899 --> 00:15:29,110
what if instead of typing it up username

00:15:26,470 --> 00:15:30,489
they type it up underscore a user and

00:15:29,110 --> 00:15:32,759
the script will fail because it's

00:15:30,489 --> 00:15:37,569
expecting it happy username

00:15:32,759 --> 00:15:39,220
what if they omit the org it's a

00:15:37,569 --> 00:15:43,629
required field an integration needs it

00:15:39,220 --> 00:15:47,069
so common schema validation problems

00:15:43,629 --> 00:15:49,569
then the most obvious ones are typos and

00:15:47,069 --> 00:15:51,100
missing required fields there are a lot

00:15:49,569 --> 00:15:53,470
more like if there is a field that

00:15:51,100 --> 00:15:55,089
represents an email address we want to

00:15:53,470 --> 00:15:56,799
apply a regular expression and show you

00:15:55,089 --> 00:15:59,470
that it's a male a male address over you

00:15:56,799 --> 00:16:02,079
have things like this so this is

00:15:59,470 --> 00:16:05,529
something that we wanted to fix in order

00:16:02,079 --> 00:16:07,720
to be able to set this up the fewer

00:16:05,529 --> 00:16:09,600
things did an application logic

00:16:07,720 --> 00:16:12,000
redundancy and and then

00:16:09,600 --> 00:16:14,250
to dependents this one is a bit harder

00:16:12,000 --> 00:16:17,130
to explain anything the idea is that

00:16:14,250 --> 00:16:20,519
let's say we have two to two men to

00:16:17,130 --> 00:16:21,959
developers families and Robert Johansen

00:16:20,519 --> 00:16:24,240
and they're both in the same team

00:16:21,959 --> 00:16:27,180
chances are they will have the same

00:16:24,240 --> 00:16:28,769
collection of permissions does this mean

00:16:27,180 --> 00:16:31,199
that we will need to write you know in

00:16:28,769 --> 00:16:33,839
the two different files the same the

00:16:31,199 --> 00:16:35,250
same list of permissions what happens if

00:16:33,839 --> 00:16:37,949
you want to add a permission we have to

00:16:35,250 --> 00:16:39,839
modify all the members of the team so

00:16:37,949 --> 00:16:41,550
it's obvious at this point that what we

00:16:39,839 --> 00:16:46,589
need to set database we need something

00:16:41,550 --> 00:16:51,089
that will allow us to provide some

00:16:46,589 --> 00:16:53,130
normalization to this so this would this

00:16:51,089 --> 00:16:54,870
would be the ideal solution instead of

00:16:53,130 --> 00:16:57,089
saying a list of permissions

00:16:54,870 --> 00:16:59,100
I just want to refer a reference of all

00:16:57,089 --> 00:17:02,160
I don't want this role to be defined in

00:16:59,100 --> 00:17:03,839
another file right so whenever I modify

00:17:02,160 --> 00:17:13,579
this file it affects all the people that

00:17:03,839 --> 00:17:15,900
are using this role so relationships

00:17:13,579 --> 00:17:18,289
relationships and foreign keys and

00:17:15,900 --> 00:17:20,880
things like this

00:17:18,289 --> 00:17:23,309
also we solve this problem somehow

00:17:20,880 --> 00:17:24,630
somehow we could expose this we will be

00:17:23,309 --> 00:17:25,829
solving the language independence

00:17:24,630 --> 00:17:27,030
problem as well because we will be

00:17:25,829 --> 00:17:29,130
consuming something that is probably

00:17:27,030 --> 00:17:33,690
able to solve all these problems that is

00:17:29,130 --> 00:17:35,490
exposing this information to us so let

00:17:33,690 --> 00:17:37,549
me introduce you that the two components

00:17:35,490 --> 00:17:39,870
that we built the two main components

00:17:37,549 --> 00:17:42,659
the first one is a schema validation

00:17:39,870 --> 00:17:45,150
this is just a pipe in reality is just a

00:17:42,659 --> 00:17:47,850
Python script that will check every file

00:17:45,150 --> 00:17:50,400
in the git repo against a schema and

00:17:47,850 --> 00:17:53,730
that's all it does it's super simple and

00:17:50,400 --> 00:17:56,430
it's very easy to write

00:17:53,730 --> 00:17:58,830
the other part one that is a bit more

00:17:56,430 --> 00:18:00,990
computer complex is that in between the

00:17:58,830 --> 00:18:03,930
give me poll and the integrations we

00:18:00,990 --> 00:18:06,240
deployed the contract server that's our

00:18:03,930 --> 00:18:08,460
name for a graph QL server that

00:18:06,240 --> 00:18:10,950
essentially knows how to read the data

00:18:08,460 --> 00:18:17,130
from the git repo and exposes it via

00:18:10,950 --> 00:18:19,140
graph QL with this in place we we

00:18:17,130 --> 00:18:20,460
believe that we're solving all the

00:18:19,140 --> 00:18:25,920
things that we had identified as

00:18:20,460 --> 00:18:29,370
problems so the contract validator let

00:18:25,920 --> 00:18:31,650
me explain you how it works it's

00:18:29,370 --> 00:18:34,380
extremely easy as I said that's the URL

00:18:31,650 --> 00:18:36,180
if you want to open it it's just a

00:18:34,380 --> 00:18:39,540
Python script which uses a Python

00:18:36,180 --> 00:18:45,360
package of JSON schema and it uses JSON

00:18:39,540 --> 00:18:50,250
schema to validate the documents so this

00:18:45,360 --> 00:18:56,460
is it's a shortened real example every

00:18:50,250 --> 00:18:59,550
every every document has a reference to

00:18:56,460 --> 00:19:01,860
a schema that will validate it and the

00:18:59,550 --> 00:19:04,650
schema is just a schema like they have

00:19:01,860 --> 00:19:08,040
defined them in the spec in JSON schema

00:19:04,650 --> 00:19:10,350
special RFC so you can say things okay

00:19:08,040 --> 00:19:13,650
so this has to be an object because it's

00:19:10,350 --> 00:19:16,620
it's it's a dictionary of fields we

00:19:13,650 --> 00:19:17,370
define only two fields name and github

00:19:16,620 --> 00:19:19,710
username

00:19:17,370 --> 00:19:23,070
we don't allow any additional properties

00:19:19,710 --> 00:19:24,570
and both of them are required if you try

00:19:23,070 --> 00:19:26,430
to do something that doesn't match this

00:19:24,570 --> 00:19:29,030
ID will fail and the PRI will get

00:19:26,430 --> 00:19:29,030
rejected

00:19:30,110 --> 00:19:37,010
this idea was super simple it really was

00:19:34,039 --> 00:19:41,360
was that contact server

00:19:37,010 --> 00:19:46,039
this is graphed well let me explain

00:19:41,360 --> 00:19:50,500
briefly what graph realized is my friend

00:19:46,039 --> 00:19:52,789
is a query language just like REST API

00:19:50,500 --> 00:19:55,000
when you implement a service and you

00:19:52,789 --> 00:19:56,809
want to expose an API instead of

00:19:55,000 --> 00:19:59,720
implementing a REST API you can

00:19:56,809 --> 00:20:02,149
implement a graphical API and then we'll

00:19:59,720 --> 00:20:03,620
demo this in a bit so you in case you

00:20:02,149 --> 00:20:08,269
have never played with really you will

00:20:03,620 --> 00:20:12,649
see how how the query language works it

00:20:08,269 --> 00:20:15,679
has provided provides every one time I'm

00:20:12,649 --> 00:20:17,330
tooling so it's very easy to build this

00:20:15,679 --> 00:20:20,149
team s that you didn't have a need for

00:20:17,330 --> 00:20:22,549
craft world in order to create this

00:20:20,149 --> 00:20:24,679
server it allows for queries and

00:20:22,549 --> 00:20:26,450
mutations you can mutate data in other

00:20:24,679 --> 00:20:28,340
case we are not missing mutations we can

00:20:26,450 --> 00:20:30,320
mutating the data directly in the give

00:20:28,340 --> 00:20:38,840
me for not be a graphic um because we

00:20:30,320 --> 00:20:40,250
want things to be PRS an interesting

00:20:38,840 --> 00:20:44,210
thing is that you only get the fields

00:20:40,250 --> 00:20:46,760
that you request and the box there is an

00:20:44,210 --> 00:20:49,279
example of a graph well schema this

00:20:46,760 --> 00:20:51,620
defines a character I'm type character

00:20:49,279 --> 00:20:53,960
and it has two fields name which is a

00:20:51,620 --> 00:20:56,990
string and it has an exclamation mark

00:20:53,960 --> 00:20:58,760
meaning that it's required and appears

00:20:56,990 --> 00:21:01,340
in is an array because it's square

00:20:58,760 --> 00:21:03,289
brackets of episodes and this is

00:21:01,340 --> 00:21:05,990
clinician mark meaning that it cannot be

00:21:03,289 --> 00:21:07,580
known it has to be there and also the

00:21:05,990 --> 00:21:09,620
array has to be there in itself it

00:21:07,580 --> 00:21:11,660
cannot be no it has to be at least an

00:21:09,620 --> 00:21:14,120
empty array

00:21:11,660 --> 00:21:15,860
as you can see this raked fits in very

00:21:14,120 --> 00:21:18,650
nicely with adjacent scheme now we're

00:21:15,860 --> 00:21:19,880
defining required fields whether or not

00:21:18,650 --> 00:21:23,150
they're strings whether or not the

00:21:19,880 --> 00:21:24,680
Airways so there was a very it was very

00:21:23,150 --> 00:21:29,930
clear to us that Westland was a good

00:21:24,680 --> 00:21:32,860
solution to mix with JSON schema so our

00:21:29,930 --> 00:21:41,570
implementation the contract server it's

00:21:32,860 --> 00:21:47,200
wrote it in node.js with we are not we

00:21:41,570 --> 00:21:49,070
are not we are not developers that we

00:21:47,200 --> 00:21:52,160
believed at the moment that the

00:21:49,070 --> 00:21:54,650
ecosystem for graph year was miles ahead

00:21:52,160 --> 00:21:56,570
in the JavaScript world so we went with

00:21:54,650 --> 00:21:59,030
that and I think we made a good choice

00:21:56,570 --> 00:22:00,470
we have didn't typescript quoting

00:21:59,030 --> 00:22:03,710
someone from the team it's the only way

00:22:00,470 --> 00:22:06,890
to write a signed same JavaScript and I

00:22:03,710 --> 00:22:08,480
think it's it's awesome and it's

00:22:06,890 --> 00:22:10,820
actually it explicitly could we put data

00:22:08,480 --> 00:22:14,660
and allows you to solve the references

00:22:10,820 --> 00:22:19,670
so you can remove the duplication of

00:22:14,660 --> 00:22:22,070
code so basically it's it's a relational

00:22:19,670 --> 00:22:24,140
relational database we have files that

00:22:22,070 --> 00:22:25,850
are users files that are roles file

00:22:24,140 --> 00:22:30,980
server permissions and we can establish

00:22:25,850 --> 00:22:32,840
relationships with them so yeah user you

00:22:30,980 --> 00:22:35,210
can say hey so what else does is you

00:22:32,840 --> 00:22:37,580
usually have because it's in the spec in

00:22:35,210 --> 00:22:40,660
the JSON schema we have that we have we

00:22:37,580 --> 00:22:44,330
are saying that the roles the user has

00:22:40,660 --> 00:22:46,660
primary which is roles that it points to

00:22:44,330 --> 00:22:46,660
a row

00:22:47,840 --> 00:22:55,320
yeah so this solves all other problems

00:22:50,220 --> 00:22:58,140
that that we that we had and this

00:22:55,320 --> 00:22:59,700
another there's another cool thing than

00:22:58,140 --> 00:23:02,070
contractor with us and I think it's the

00:22:59,700 --> 00:23:05,190
coolest thing that it does it allows you

00:23:02,070 --> 00:23:07,470
to do back references the idea is that

00:23:05,190 --> 00:23:09,360
in the schema we're not defining users

00:23:07,470 --> 00:23:12,210
user it's not there we're just defining

00:23:09,360 --> 00:23:14,130
I mean I mean the yellow box we are not

00:23:12,210 --> 00:23:16,620
defining the jello box that contract

00:23:14,130 --> 00:23:18,930
server is smart and if you query roads

00:23:16,620 --> 00:23:22,290
and say hey what are the users that are

00:23:18,930 --> 00:23:24,540
pointing to this role it will show us

00:23:22,290 --> 00:23:26,400
the users so we're able to just

00:23:24,540 --> 00:23:29,940
unloading this data in the contract

00:23:26,400 --> 00:23:32,010
server in the graphic observer able to

00:23:29,940 --> 00:23:34,260
navigate through the foreign keys

00:23:32,010 --> 00:23:41,460
relationships and that's what makes this

00:23:34,260 --> 00:23:43,110
powerful I think we've made a bunch of

00:23:41,460 --> 00:23:46,440
assumptions about what's in the get

00:23:43,110 --> 00:23:49,530
people and the give people has to have

00:23:46,440 --> 00:23:52,020
to satisfy the requirements contract

00:23:49,530 --> 00:23:54,150
server imposes it has to have a

00:23:52,020 --> 00:23:58,800
collection of data files and it's data

00:23:54,150 --> 00:24:01,620
file has to be llamo ordination it has

00:23:58,800 --> 00:24:03,900
to have P which is a schema which points

00:24:01,620 --> 00:24:05,790
to a file will validate which validated

00:24:03,900 --> 00:24:08,250
and if you want to reference another

00:24:05,790 --> 00:24:10,500
file you simply define key which is

00:24:08,250 --> 00:24:12,420
dollar F and the path to the other file

00:24:10,500 --> 00:24:15,090
the relative path to another file and

00:24:12,420 --> 00:24:16,680
that's it that's all you need to do you

00:24:15,090 --> 00:24:20,100
also need to provide the JSON schema

00:24:16,680 --> 00:24:23,570
validation files and say user one has

00:24:20,100 --> 00:24:26,220
these required fields etc and

00:24:23,570 --> 00:24:27,750
unfortunately we still have to provide

00:24:26,220 --> 00:24:29,070
the graphical schemas but this is

00:24:27,750 --> 00:24:31,050
something that will be going away soon

00:24:29,070 --> 00:24:32,880
because we want to be able to generate

00:24:31,050 --> 00:24:34,680
we can generate the graphical schemas

00:24:32,880 --> 00:24:36,490
from the adjacent schemas there are a

00:24:34,680 --> 00:24:39,220
couple of things we need to solve before

00:24:36,490 --> 00:24:41,200
but that's what we're going so only the

00:24:39,220 --> 00:24:46,240
two first things are there in the long

00:24:41,200 --> 00:24:48,640
run okay so I'm going to do a demo and

00:24:46,240 --> 00:24:53,550
in this demo I'm gonna show you a few

00:24:48,640 --> 00:24:57,490
data files and one of them in this repo

00:24:53,550 --> 00:25:01,510
I'm going to show you how the validation

00:24:57,490 --> 00:25:03,130
works I'm going to show you how the

00:25:01,510 --> 00:25:09,280
contractor with the graphical server

00:25:03,130 --> 00:25:11,010
also works and yeah have a quick review

00:25:09,280 --> 00:25:14,260
of the graph QL pre-language

00:25:11,010 --> 00:25:17,230
okay I'm going to try and do it here but

00:25:14,260 --> 00:25:20,940
I cannot mirror the laptop because I'm

00:25:17,230 --> 00:25:20,940
in Wayland so I don't know

00:25:39,650 --> 00:25:45,710
okay so this is the repo this is the app

00:25:42,980 --> 00:25:49,660
interface this is how a git repo we call

00:25:45,710 --> 00:25:53,600
it up interface inside the data folder

00:25:49,660 --> 00:25:56,420
we have the data files that we are going

00:25:53,600 --> 00:25:59,150
to be exposing you'll see we only have

00:25:56,420 --> 00:26:01,190
four here in this example I removed

00:25:59,150 --> 00:26:08,210
everything else so in order to keep it

00:26:01,190 --> 00:26:12,280
simple we have a couple of users a role

00:26:08,210 --> 00:26:12,280
and a permission so let's open

00:26:15,990 --> 00:26:22,710
let's open this user this user has a

00:26:20,549 --> 00:26:26,399
schema file which points to the schema

00:26:22,710 --> 00:26:28,289
file that we will take a look at now and

00:26:26,399 --> 00:26:30,779
it has you know the field it's a regular

00:26:28,289 --> 00:26:32,519
Yama file it could also be Jason and it

00:26:30,779 --> 00:26:36,389
has all the things that we need in

00:26:32,519 --> 00:26:37,799
reality I this is my user it has like 10

00:26:36,389 --> 00:26:39,059
volts or something like that I just

00:26:37,799 --> 00:26:40,799
removed all of them

00:26:39,059 --> 00:26:42,299
you have the GPG key and all these

00:26:40,799 --> 00:26:45,200
things so everything that we know what

00:26:42,299 --> 00:26:45,200
the service is here

00:26:53,300 --> 00:26:58,160
the roads it's just a collection of

00:26:56,300 --> 00:27:00,980
operations as you can see there's Bell

00:26:58,160 --> 00:27:03,170
RF which points to another file and this

00:27:00,980 --> 00:27:07,910
will this contract server understands

00:27:03,170 --> 00:27:12,320
understands this and I'm going to show

00:27:07,910 --> 00:27:15,280
you the schema for a user this is a real

00:27:12,320 --> 00:27:18,430
schema that we're using for users it has

00:27:15,280 --> 00:27:21,140
all the fields that we require if it's

00:27:18,430 --> 00:27:27,760
impossible it's actually quite simple

00:27:21,140 --> 00:27:27,760
it's just a regular JSON schema okay

00:28:05,310 --> 00:28:08,120
I'm sorry

00:28:18,309 --> 00:28:24,509
okay so this I can't see anything

00:28:27,110 --> 00:28:31,570
okay so let's start with users

00:28:34,520 --> 00:28:45,470
this is a graphical a regular graph toad

00:28:37,130 --> 00:28:46,490
server so we have actually I consider

00:28:45,470 --> 00:28:49,480
them like this I'm gonna connect

00:28:46,490 --> 00:28:49,480
together top top

00:29:06,870 --> 00:29:10,140
[Music]

00:29:42,600 --> 00:29:46,039
okay my Twitter

00:29:48,770 --> 00:29:56,870
okay so we are going to create the users

00:29:52,010 --> 00:30:00,200
and we simply need to define the fields

00:29:56,870 --> 00:30:02,090
that we want and this returns users from

00:30:00,200 --> 00:30:04,220
the contract server now the cool thing

00:30:02,090 --> 00:30:06,350
about graph QL is that I define the

00:30:04,220 --> 00:30:08,450
fields studied the fields that I want so

00:30:06,350 --> 00:30:11,510
you could do something like right at the

00:30:08,450 --> 00:30:15,410
user name and this will give you the web

00:30:11,510 --> 00:30:18,350
app user name but if you remember in the

00:30:15,410 --> 00:30:22,040
user file we had a road which roads

00:30:18,350 --> 00:30:25,270
right which pointed to other roads we me

00:30:22,040 --> 00:30:25,270
clarify this a bit

00:30:32,610 --> 00:30:36,769
if we list the rows that we want

00:30:38,520 --> 00:30:43,440
there you go the you know you have the

00:30:41,070 --> 00:30:47,300
Rose who we just went down to the red

00:30:43,440 --> 00:30:47,300
returning the data from other files now

00:30:50,080 --> 00:30:58,180
for the description we can visualize the

00:30:54,070 --> 00:31:10,750
path - right so I'm just telling the

00:30:58,180 --> 00:31:13,180
data that I want it to return if I click

00:31:10,750 --> 00:31:16,390
copy curl and I paste it somewhere I

00:31:13,180 --> 00:31:17,980
will see that it's just a regular role

00:31:16,390 --> 00:31:21,640
that it's the payload

00:31:17,980 --> 00:31:23,410
it's just that string it uses the string

00:31:21,640 --> 00:31:25,780
that I have on the left and it returns

00:31:23,410 --> 00:31:28,180
to Jason so this means I can do this in

00:31:25,780 --> 00:31:30,250
any language also another thing that

00:31:28,180 --> 00:31:32,980
it's super cool and fql is that it has

00:31:30,250 --> 00:31:35,440
introspection justice server itself

00:31:32,980 --> 00:31:37,060
allows you to return all the things that

00:31:35,440 --> 00:31:39,520
we can you can query so we can create

00:31:37,060 --> 00:31:46,060
users and the users have all these

00:31:39,520 --> 00:31:49,210
labels and we can go to roles and inside

00:31:46,060 --> 00:31:50,740
roles we have users again you know this

00:31:49,210 --> 00:31:53,080
is the whole relationship of the dead of

00:31:50,740 --> 00:31:55,780
the database that I was showing you and

00:31:53,080 --> 00:31:57,430
it's available here this is the official

00:31:55,780 --> 00:31:58,930
graph QL tooling I'm not doing anything

00:31:57,430 --> 00:32:01,150
I'm just starting a field server

00:31:58,930 --> 00:32:04,360
providing it with the schema and this is

00:32:01,150 --> 00:32:06,280
automatic so this is this is one of the

00:32:04,360 --> 00:32:10,000
reasons we went with nodejs to deploy

00:32:06,280 --> 00:32:12,310
this because all of this ecosystem was

00:32:10,000 --> 00:32:14,590
amazing to use and we're just

00:32:12,310 --> 00:32:16,420
implementing the logic that we solves

00:32:14,590 --> 00:32:19,650
this references so that's basically all

00:32:16,420 --> 00:32:19,650
we're doing

00:32:21,130 --> 00:32:38,720
and the back references is if we do

00:32:29,530 --> 00:32:41,120
rolls b1 now we can we can query the the

00:32:38,720 --> 00:32:46,070
users and this is not defined in the

00:32:41,120 --> 00:32:48,350
data files this is something that this

00:32:46,070 --> 00:32:49,820
is something that contract server knows

00:32:48,350 --> 00:32:51,680
how to do just because it looks at the

00:32:49,820 --> 00:32:53,360
schema relationship in the schema and it

00:32:51,680 --> 00:32:55,130
builds all the other direct

00:32:53,360 --> 00:32:59,180
relationships and the back references

00:32:55,130 --> 00:33:00,650
okay so this was the demo for the

00:32:59,180 --> 00:33:02,600
graphical so ever did does anyone have

00:33:00,650 --> 00:33:05,030
any question regarding the graph query

00:33:02,600 --> 00:33:07,280
language I find it super cool because

00:33:05,030 --> 00:33:09,760
just we tend obtain the data very want

00:33:07,280 --> 00:33:09,760
and that's it

00:33:41,450 --> 00:33:49,010
okay just a few more slides left so

00:33:47,180 --> 00:33:50,420
we've talked about the upper part of the

00:33:49,010 --> 00:33:52,400
stock and I want to talk about the

00:33:50,420 --> 00:33:53,750
integrations how do we write them and

00:33:52,400 --> 00:33:55,970
what are what are they

00:33:53,750 --> 00:33:59,900
so integrations are extremely simple to

00:33:55,970 --> 00:34:05,540
be written they just need to follow

00:33:59,900 --> 00:34:08,300
these small patterns they fetch to the

00:34:05,540 --> 00:34:11,780
side state by contacting the graph QL

00:34:08,300 --> 00:34:14,419
server they fetch the current state by

00:34:11,780 --> 00:34:16,700
using the API of server service were

00:34:14,419 --> 00:34:23,570
managing github vault

00:34:16,700 --> 00:34:25,340
Jenkins way whatever you have to do it

00:34:23,570 --> 00:34:27,669
in such a way that its ID important so

00:34:25,340 --> 00:34:30,140
if you run it again and again things

00:34:27,669 --> 00:34:32,480
won't break if you try to create

00:34:30,140 --> 00:34:34,280
something that already exists you cannot

00:34:32,480 --> 00:34:36,260
erase an error you have to say okay you

00:34:34,280 --> 00:34:38,600
silently failure say okay this was

00:34:36,260 --> 00:34:39,980
already created we can run them in any

00:34:38,600 --> 00:34:43,580
language we can write them in any

00:34:39,980 --> 00:34:45,230
language and in fact we do and a very

00:34:43,580 --> 00:34:47,690
important thing is that they all have to

00:34:45,230 --> 00:34:49,460
have a - - driver and flag so we are

00:34:47,690 --> 00:34:51,650
able to see me like what happens on

00:34:49,460 --> 00:34:55,700
every PR so the player comes in we will

00:34:51,650 --> 00:34:58,220
run all the lists of integrations I will

00:34:55,700 --> 00:35:03,470
see you know what is this this PR is

00:34:58,220 --> 00:35:05,930
going to do so let's look at one

00:35:03,470 --> 00:35:09,680
integration a simple one defining

00:35:05,930 --> 00:35:12,630
defining query registries the

00:35:09,680 --> 00:35:15,390
magic is what I just said beside state

00:35:12,630 --> 00:35:18,990
from graph 12 current state from the

00:35:15,390 --> 00:35:22,710
gravest apk REST API we iterate through

00:35:18,990 --> 00:35:25,050
the desired state if they are not in the

00:35:22,710 --> 00:35:27,480
current state we create them if they are

00:35:25,050 --> 00:35:30,930
different we modify them and then we

00:35:27,480 --> 00:35:32,430
iterate through the current state and if

00:35:30,930 --> 00:35:34,050
they are not in the desired state we

00:35:32,430 --> 00:35:36,150
move them it's just like a kubernetes

00:35:34,050 --> 00:35:38,280
controller that's that sticks I think

00:35:36,150 --> 00:35:40,380
exact thing you would do and we

00:35:38,280 --> 00:35:41,790
implement the implement dry run even

00:35:40,380 --> 00:35:43,200
them in driver and only print what you

00:35:41,790 --> 00:35:46,580
would do instead of doing it so it's

00:35:43,200 --> 00:35:46,580
pretty much trivial

00:35:50,770 --> 00:35:57,610
this is the query and that you would

00:35:52,390 --> 00:36:00,520
have on the left is developer defining

00:35:57,610 --> 00:36:03,700
the registry so they want they point to

00:36:00,520 --> 00:36:05,560
a query organization and the list of

00:36:03,700 --> 00:36:07,750
registries that I want for instance and

00:36:05,560 --> 00:36:12,010
in our integration we just request the

00:36:07,750 --> 00:36:14,440
data like this we create this query in

00:36:12,010 --> 00:36:16,930
graph you'll return the data and do all

00:36:14,440 --> 00:36:19,540
the logic based on the results here so

00:36:16,930 --> 00:36:20,830
it fits in very nicely and and the good

00:36:19,540 --> 00:36:23,050
thing is that because the data was

00:36:20,830 --> 00:36:27,690
already validated we know this is not

00:36:23,050 --> 00:36:32,620
going to we know this is not going to

00:36:27,690 --> 00:36:34,240
give us false information I said if name

00:36:32,620 --> 00:36:36,100
is supposed to be there it will be there

00:36:34,240 --> 00:36:40,350
and if it names supposed to not be a

00:36:36,100 --> 00:36:40,350
null value it won't be a null value

00:36:43,990 --> 00:36:50,380
so nowadays this this is the list of

00:36:47,260 --> 00:36:52,839
integrations that we have we write them

00:36:50,380 --> 00:36:55,060
super quickly so we have integrations

00:36:52,839 --> 00:36:55,810
that deploy resources to the out page of

00:36:55,060 --> 00:37:00,030
clusters

00:36:55,810 --> 00:37:00,030
Malick's query post for configurations

00:37:00,660 --> 00:37:07,300
AWS resources we have a lot of things

00:37:04,780 --> 00:37:08,859
and we have everything we treat

00:37:07,300 --> 00:37:10,450
everything from the single gig repo I

00:37:08,859 --> 00:37:13,890
will follow this pattern and we're and

00:37:10,450 --> 00:37:17,320
this is allowing us to scale a lot

00:37:13,890 --> 00:37:20,950
another interesting thing is what

00:37:17,320 --> 00:37:23,230
happens when developer centers a PR how

00:37:20,950 --> 00:37:26,020
do we how do we how do we decide whether

00:37:23,230 --> 00:37:30,940
or not to merge it well every time a PR

00:37:26,020 --> 00:37:32,800
is sent to this repo this all the

00:37:30,940 --> 00:37:35,710
integrations are run with the - - dry

00:37:32,800 --> 00:37:38,020
run and we get a report so if the

00:37:35,710 --> 00:37:39,339
developer has deleted all the users we

00:37:38,020 --> 00:37:43,060
would be able to see it and we would

00:37:39,339 --> 00:37:45,400
refuse to merge that PR if there are any

00:37:43,060 --> 00:37:47,710
problems there in any schema validation

00:37:45,400 --> 00:37:49,180
problems everything we will be able to

00:37:47,710 --> 00:37:51,099
look at it just by looking at this

00:37:49,180 --> 00:37:52,570
report and we have fun information that

00:37:51,099 --> 00:37:55,200
we need to know whether or not if we

00:37:52,570 --> 00:37:55,200
should merge it

00:37:57,710 --> 00:38:02,950
another tool that we build around this

00:37:59,869 --> 00:38:05,960
is we subcontract we subcontract is

00:38:02,950 --> 00:38:07,549
essentially the gripper that we have has

00:38:05,960 --> 00:38:09,619
a lot of references going from one

00:38:07,549 --> 00:38:11,599
document to another and navigating this

00:38:09,619 --> 00:38:13,309
is a human sometimes it's a bit

00:38:11,599 --> 00:38:16,190
confusing if you if you want to follow

00:38:13,309 --> 00:38:17,990
stuff you have to keep you know jumping

00:38:16,190 --> 00:38:20,990
from one file to another so the visual

00:38:17,990 --> 00:38:25,430
contract is a react app that displays

00:38:20,990 --> 00:38:28,010
this information so we have services

00:38:25,430 --> 00:38:30,799
Buster's many spaces users everything

00:38:28,010 --> 00:38:33,079
you know like that's what it's their

00:38:30,799 --> 00:38:34,520
link from the namespaces if you go to

00:38:33,079 --> 00:38:35,960
clusters you will see the namespaces and

00:38:34,520 --> 00:38:37,609
the name spaces you will see like

00:38:35,960 --> 00:38:40,490
everything is interconnected you can

00:38:37,609 --> 00:38:42,289
navigate from one to another this is

00:38:40,490 --> 00:38:43,760
just a screenshot of the repo that I

00:38:42,289 --> 00:38:46,700
currently have in which I only have two

00:38:43,760 --> 00:38:52,039
users normally I think we have 250 or so

00:38:46,700 --> 00:38:53,930
and if I click on one you will see

00:38:52,039 --> 00:38:55,970
something that it's quite interesting

00:38:53,930 --> 00:38:58,119
which is the edit button and the edit

00:38:55,970 --> 00:39:01,099
button only sends you back to the to the

00:38:58,119 --> 00:39:03,410
to the page in the in the git repo it's

00:39:01,099 --> 00:39:05,299
a repo so it sends you back to get lab

00:39:03,410 --> 00:39:07,160
saying if you want to modify it simply

00:39:05,299 --> 00:39:09,829
send a PR modify this file or that's it

00:39:07,160 --> 00:39:12,920
so it's just a link but at some point we

00:39:09,829 --> 00:39:14,980
will probably have a dynamic web form so

00:39:12,920 --> 00:39:17,960
based on the JSON schema you could

00:39:14,980 --> 00:39:20,270
generate a dynamic web form to modify

00:39:17,960 --> 00:39:23,859
these fields and send an automatic PR

00:39:20,270 --> 00:39:23,859
but we're not yet there yet

00:39:23,930 --> 00:39:28,090
future work

00:39:25,720 --> 00:39:29,760
as I said dynamically generated the

00:39:28,090 --> 00:39:32,850
graphical schema that is one of my

00:39:29,760 --> 00:39:35,470
things that I would like to to work on

00:39:32,850 --> 00:39:37,510
soon because it's a bit of a pain to

00:39:35,470 --> 00:39:39,130
have to maintain the validation and to

00:39:37,510 --> 00:39:42,220
maintain the schemas in two places in

00:39:39,130 --> 00:39:45,280
Jason Rafiel format it's a bit tricky

00:39:42,220 --> 00:39:50,650
but I think we were in a good place to

00:39:45,280 --> 00:39:53,620
solve this problem another weakness a

00:39:50,650 --> 00:39:55,750
problem that we have is that the

00:39:53,620 --> 00:39:58,180
documents are validated in the context

00:39:55,750 --> 00:40:00,340
of themselves we are able to see the

00:39:58,180 --> 00:40:04,680
refills are missing etc but we do know

00:40:00,340 --> 00:40:04,680
the validation will not look at other

00:40:04,890 --> 00:40:09,550
documents when it's validating this

00:40:07,390 --> 00:40:11,950
means that there are simple things like

00:40:09,550 --> 00:40:13,920
uniqueness that we are not enforcing

00:40:11,950 --> 00:40:17,350
someone could define twice the same

00:40:13,920 --> 00:40:20,050
wettable username and that is a problem

00:40:17,350 --> 00:40:21,790
and we think we have a good strategy to

00:40:20,050 --> 00:40:24,460
solve this which is essentially running

00:40:21,790 --> 00:40:27,730
rough - defining graphical queries that

00:40:24,460 --> 00:40:30,220
that need to pass in order for the PR to

00:40:27,730 --> 00:40:31,690
be merged and if we do if we set it up

00:40:30,220 --> 00:40:33,820
in such a way that they are easy to be

00:40:31,690 --> 00:40:35,530
fine then we will be able to you know

00:40:33,820 --> 00:40:37,510
say okay this PRI cannot go through

00:40:35,530 --> 00:40:40,560
because it's repeating a field that is

00:40:37,510 --> 00:40:43,560
already being used somewhere else

00:40:40,560 --> 00:40:43,560
privatized

00:40:44,040 --> 00:40:51,820
one of the obvious questions is can this

00:40:47,710 --> 00:40:56,830
be used and it can it can be used but

00:40:51,820 --> 00:40:59,050
it's a pain to set up the logic to run

00:40:56,830 --> 00:41:01,030
integrations we're currently doing an

00:40:59,050 --> 00:41:03,700
agenda in Jenkins using web hooks so

00:41:01,030 --> 00:41:05,440
when there's a peer when the PRS merge

00:41:03,700 --> 00:41:06,790
there's a web filter that when the

00:41:05,440 --> 00:41:10,270
player is submitted their Semantic Web

00:41:06,790 --> 00:41:12,580
that triggers the Jenkins job and runs

00:41:10,270 --> 00:41:14,440
the integrations and we really don't

00:41:12,580 --> 00:41:18,840
dislike this approach and we would like

00:41:14,440 --> 00:41:21,640
to do an operator kubernetes operator so

00:41:18,840 --> 00:41:23,770
you define basically in the cid the

00:41:21,640 --> 00:41:26,890
integrations i want to run and listens

00:41:23,770 --> 00:41:29,200
for this is things like this

00:41:26,890 --> 00:41:31,390
what does we have this I I think it

00:41:29,200 --> 00:41:33,100
would be easy to deploy this as of now

00:41:31,390 --> 00:41:34,840
the the biggest problem the biggest

00:41:33,100 --> 00:41:36,790
challenge that someone has if we try to

00:41:34,840 --> 00:41:40,750
apply this is setting up the whole logic

00:41:36,790 --> 00:41:44,020
to run the integrations and the last

00:41:40,750 --> 00:41:48,690
thing is the automatic PR merges all

00:41:44,020 --> 00:41:51,310
work right now a big part of our work is

00:41:48,690 --> 00:41:53,320
reviewing PRS and we want to automate

00:41:51,310 --> 00:41:57,490
that we want to be able to define some

00:41:53,320 --> 00:41:59,380
tests so for instance one thing that we

00:41:57,490 --> 00:42:03,130
want to enforce is if someone tries to

00:41:59,380 --> 00:42:07,360
modify a PR a service that they don't

00:42:03,130 --> 00:42:10,180
belong to yeah we can we should fail

00:42:07,360 --> 00:42:12,640
that PR and that now is a manual process

00:42:10,180 --> 00:42:15,160
we look at it and say this guy trying to

00:42:12,640 --> 00:42:16,840
modify this service but he doesn't he's

00:42:15,160 --> 00:42:19,240
in part of the service so we want to do

00:42:16,840 --> 00:42:21,640
something similar to github owners to

00:42:19,240 --> 00:42:23,950
the github owners file but using again

00:42:21,640 --> 00:42:28,210
graph will queries based on the output

00:42:23,950 --> 00:42:31,950
and things like this so the conclusion

00:42:28,210 --> 00:42:34,450
just to finish I think

00:42:31,950 --> 00:42:37,569
in this talk there are too many years I

00:42:34,450 --> 00:42:39,069
want to I want to convey which are the

00:42:37,569 --> 00:42:41,560
rectification group declarative

00:42:39,069 --> 00:42:44,560
declarative approach is amazing we found

00:42:41,560 --> 00:42:48,599
it to be useful in this use case I think

00:42:44,560 --> 00:42:51,280
I don't know I think it changes the way

00:42:48,599 --> 00:42:53,020
it improves a lot of things a lot of

00:42:51,280 --> 00:42:57,329
things and it can be used in many

00:42:53,020 --> 00:43:00,010
different scenarios or perhaps trying to

00:42:57,329 --> 00:43:02,440
may be useful to evaluate if you can

00:43:00,010 --> 00:43:06,579
borrow this declarative approach and

00:43:02,440 --> 00:43:09,339
applied elsewhere and the other thing a

00:43:06,579 --> 00:43:11,230
lesson learned from 2018 for us was that

00:43:09,339 --> 00:43:14,290
automation is necessary and we have to

00:43:11,230 --> 00:43:17,500
do automation but you have to do it with

00:43:14,290 --> 00:43:22,119
a plan and design if you start

00:43:17,500 --> 00:43:25,510
automating in the end it's in the end

00:43:22,119 --> 00:43:27,579
it's all its will end up being confusing

00:43:25,510 --> 00:43:31,300
complex and you won't be able to scale

00:43:27,579 --> 00:43:34,180
up sorry these are the links for the

00:43:31,300 --> 00:43:36,849
projects if you want to look at them and

00:43:34,180 --> 00:43:39,210
that's my email if anyone has any

00:43:36,849 --> 00:43:39,210
questions

00:43:44,470 --> 00:43:48,500
one of the reasons I could see is for

00:43:46,880 --> 00:43:51,560
the typescript think you mentioned for

00:43:48,500 --> 00:43:53,990
craft QL but outside that why fights and

00:43:51,560 --> 00:43:59,599
why not organized so say for instance we

00:43:53,990 --> 00:44:02,320
have an integration we have an

00:43:59,599 --> 00:44:02,320
integration which is

00:44:03,309 --> 00:44:11,019
it's this one oops vault configuration

00:44:08,429 --> 00:44:14,769
configuration the integration we wrote

00:44:11,019 --> 00:44:17,079
it in go because Hoshi called world is

00:44:14,769 --> 00:44:23,409
has the main API single and we're didn't

00:44:17,079 --> 00:44:26,079
go for instance the query pose makes

00:44:23,409 --> 00:44:29,229
sense write it in Python and not use not

00:44:26,079 --> 00:44:33,179
really used code so we really didn't

00:44:29,229 --> 00:44:36,069
want to be bound to a single to a single

00:44:33,179 --> 00:44:37,719
language and that's why we try to follow

00:44:36,069 --> 00:44:39,549
this approach to have something that

00:44:37,719 --> 00:44:41,259
will expose the data in such a way that

00:44:39,549 --> 00:44:43,599
it can you see me primarily language

00:44:41,259 --> 00:44:44,919
using just HTTP which is essentially

00:44:43,599 --> 00:44:48,509
where the graphical client is

00:44:44,919 --> 00:44:48,509
assassinated creepy client

00:44:54,570 --> 00:44:57,690
it was like you're reading my mind

00:44:55,710 --> 00:45:00,450
because I didn't have a question but I

00:44:57,690 --> 00:45:03,150
didn't raise my hand yet so my question

00:45:00,450 --> 00:45:04,950
is about get off so I am new to this

00:45:03,150 --> 00:45:08,190
concept of get-ups although everything

00:45:04,950 --> 00:45:10,620
behind it is very familiar it seems that

00:45:08,190 --> 00:45:12,360
one of the features of it is the idea of

00:45:10,620 --> 00:45:14,520
a pull request this is checking the

00:45:12,360 --> 00:45:17,400
difference between desired and current

00:45:14,520 --> 00:45:19,140
state and then that PR is really what

00:45:17,400 --> 00:45:20,850
makes this a get-ups process rather than

00:45:19,140 --> 00:45:23,130
you know just a continuous delivery

00:45:20,850 --> 00:45:25,620
process but you want to get rid of the

00:45:23,130 --> 00:45:26,700
PR part and automate that is that does

00:45:25,620 --> 00:45:31,080
that mean there's some sort of flaw with

00:45:26,700 --> 00:45:33,030
get-ups okay so I don't want to get rid

00:45:31,080 --> 00:45:36,800
of lave of the PIR check I want to

00:45:33,030 --> 00:45:40,080
automate the creation of PRS

00:45:36,800 --> 00:45:42,480
so the edit button this thing I said

00:45:40,080 --> 00:45:44,190
about creating dynamic forms will

00:45:42,480 --> 00:45:46,800
essentially allow the developer to send

00:45:44,190 --> 00:45:48,270
a PR not modify anything so the employer

00:45:46,800 --> 00:45:50,190
will still be there we will have

00:45:48,270 --> 00:45:53,070
traceability auditability who send this

00:45:50,190 --> 00:45:55,170
PR and we'll have a simulation of what

00:45:53,070 --> 00:45:59,100
would happen if we merge it so the PRA

00:45:55,170 --> 00:46:01,320
would be there but another thing which

00:45:59,100 --> 00:46:02,790
is that the PR sorry the essence of kid

00:46:01,320 --> 00:46:04,470
ops and they are indeed a very important

00:46:02,790 --> 00:46:09,930
part but I think the most important part

00:46:04,470 --> 00:46:12,690
is just having in gear ups a state that

00:46:09,930 --> 00:46:14,910
you want to see deployed so PRS are

00:46:12,690 --> 00:46:18,710
extremely useful this is a benefit that

00:46:14,910 --> 00:46:21,690
you get from get-ups but I think that

00:46:18,710 --> 00:46:24,500
the main thing is just being able to

00:46:21,690 --> 00:46:24,500
apply that state

00:46:25,910 --> 00:46:30,450
our question please

00:46:28,230 --> 00:46:33,210
what iswhat to the world integration you

00:46:30,450 --> 00:46:36,270
have so in that case the sequence for

00:46:33,210 --> 00:46:38,609
example are still not encrypted on xcd

00:46:36,270 --> 00:46:41,339
rather it's encrypted in a store

00:46:38,609 --> 00:46:44,099
something pulls the secret out decrypts

00:46:41,339 --> 00:46:46,559
it and puts it on that CD right exactly

00:46:44,099 --> 00:46:49,020
I think it's exactly what you said we

00:46:46,559 --> 00:46:52,829
the developer puts the secret involved

00:46:49,020 --> 00:46:56,040
and in t-tops they say hey I applied

00:46:52,829 --> 00:46:58,619
this vault document this broad secret

00:46:56,040 --> 00:47:00,799
applied in this namespace and the

00:46:58,619 --> 00:47:03,569
integration what it does it simply

00:47:00,799 --> 00:47:07,890
obtains the data from vault and creates

00:47:03,569 --> 00:47:10,740
an actual secret in communities and its

00:47:07,890 --> 00:47:13,829
version so they can control in the world

00:47:10,740 --> 00:47:18,480
bags and do the kind of things so right

00:47:13,829 --> 00:47:22,400
so Hoshi Corp has a new thing where it

00:47:18,480 --> 00:47:24,359
has an edit container which effectively

00:47:22,400 --> 00:47:27,030
ensures that you don't even have to

00:47:24,359 --> 00:47:29,069
write the secret unencrypted onto a CD

00:47:27,030 --> 00:47:30,270
is that something you've considered and

00:47:29,069 --> 00:47:33,569
found no not a good idea

00:47:30,270 --> 00:47:36,000
okay so we saw this a while ago I think

00:47:33,569 --> 00:47:37,440
and the problem was that we weren't sure

00:47:36,000 --> 00:47:39,630
if we could run this in opposite

00:47:37,440 --> 00:47:42,150
irrigate it because in order to install

00:47:39,630 --> 00:47:44,549
that we required cluster admin so we

00:47:42,150 --> 00:47:46,410
didn't have this but the big thing is

00:47:44,549 --> 00:47:48,210
that if you have this writing an

00:47:46,410 --> 00:47:51,859
integration that that's that is trivial

00:47:48,210 --> 00:47:51,859
right so this is

00:47:55,069 --> 00:48:04,890
okay one last question sorry I'm not too

00:48:00,390 --> 00:48:06,750
familiar with graph QL is that so that's

00:48:04,890 --> 00:48:10,020
taking the data from that's defining the

00:48:06,750 --> 00:48:13,619
gate repo and is this storing somewhere

00:48:10,020 --> 00:48:17,789
so it's just parsing that directly so

00:48:13,619 --> 00:48:21,569
graph QL is not doesn't have anything to

00:48:17,789 --> 00:48:25,440
do with it repos what weird when you

00:48:21,569 --> 00:48:27,000
create a graph QL service it's like when

00:48:25,440 --> 00:48:29,520
you create a REST API service you have

00:48:27,000 --> 00:48:34,280
to implement the logic right in our case

00:48:29,520 --> 00:48:34,280
the logic is go to the github repo and

00:48:34,579 --> 00:48:39,750
return this data but it's our logic that

00:48:37,740 --> 00:48:41,970
one that thinks the data from the from

00:48:39,750 --> 00:48:46,980
the Gateway po not graph QL after is

00:48:41,970 --> 00:48:50,809
simply a way to - it's just an API and

00:48:46,980 --> 00:48:50,809
API specification

00:48:52,330 --> 00:48:56,340

YouTube URL: https://www.youtube.com/watch?v=ygGlvqOJHYA


