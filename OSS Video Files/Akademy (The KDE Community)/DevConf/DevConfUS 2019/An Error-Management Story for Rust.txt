Title: An Error-Management Story for Rust
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Mulhern

Unlike C, which uses error codes, or Python, which uses exceptions, both of which require no effort on the programmer's part to ignore, Rust requires any function that may return an error to encode this in its return type. To cause their code to ignore an error, the programmer must take an action, visible in the resulting code. Consequently, the programmer inclines toward more conscientious error-handling.

However, no fully accepted error-management solution for Rust has emerged. This presents a painful obstacle to programmers wishing to supply useful debugging information for programmers and helpful error information for users. In this talk, I will present the current state of error-management in Rust, the reasons for the difficulties, and my efforts to arrive at a workable solution.
Captions: 
	00:00:02,590 --> 00:00:12,070
all right so I'm ready to begin and I'm

00:00:10,420 --> 00:00:13,990
talking about an error management story

00:00:12,070 --> 00:00:17,020
for rust and so I'm thinking that people

00:00:13,990 --> 00:00:18,730
want to be at this talk or people will

00:00:17,020 --> 00:00:20,890
be rust programmers who actually want an

00:00:18,730 --> 00:00:22,449
error management solution people who

00:00:20,890 --> 00:00:24,249
think about error management generally

00:00:22,449 --> 00:00:25,900
because I'm going to talk about error

00:00:24,249 --> 00:00:27,730
management somewhat in the large and

00:00:25,900 --> 00:00:29,380
people who just like languages because

00:00:27,730 --> 00:00:31,390
I'll talk about different languages and

00:00:29,380 --> 00:00:37,450
languages are interesting in all their

00:00:31,390 --> 00:00:38,340
manifestations ok so who am I talking

00:00:37,450 --> 00:00:40,420
about this

00:00:38,340 --> 00:00:43,600
well I've about three years of

00:00:40,420 --> 00:00:45,220
experience programming and rust many

00:00:43,600 --> 00:00:50,170
years of experience of programming and

00:00:45,220 --> 00:00:53,080
Python which I still do distant memories

00:00:50,170 --> 00:00:55,810
of programming and see and also I'm the

00:00:53,080 --> 00:00:57,100
Stratos team tech lead and even though I

00:00:55,810 --> 00:01:00,340
think I would be interested in error

00:00:57,100 --> 00:01:02,650
management anyway I have to be more

00:01:00,340 --> 00:01:06,729
interested in error management because

00:01:02,650 --> 00:01:10,929
of what Stratos does we're glue code in

00:01:06,729 --> 00:01:12,609
rust for the storage stack and we can

00:01:10,929 --> 00:01:14,530
encounter errors because at the bottom

00:01:12,609 --> 00:01:19,090
of the storage stack are storage devices

00:01:14,530 --> 00:01:22,090
and so we're very interested in

00:01:19,090 --> 00:01:23,859
producing useful errors for users that

00:01:22,090 --> 00:01:26,020
is the people are managing the storage

00:01:23,859 --> 00:01:31,569
so I have to be interested in it

00:01:26,020 --> 00:01:33,880
professionally ok so what should you

00:01:31,569 --> 00:01:36,520
expect well I'll talk about error

00:01:33,880 --> 00:01:38,469
management generally I'll talk about

00:01:36,520 --> 00:01:41,200
what's going on in rust to try to

00:01:38,469 --> 00:01:44,649
address error management I'll discuss

00:01:41,200 --> 00:01:46,329
what I've come up with so far and I am

00:01:44,649 --> 00:01:48,280
sorry to tell you this is not an

00:01:46,329 --> 00:01:50,319
announcement of an error management

00:01:48,280 --> 00:01:55,799
create in rust that will solve all your

00:01:50,319 --> 00:01:59,619
problems there is in progress on and off

00:01:55,799 --> 00:02:03,149
and in fact I actively invite any sort

00:01:59,619 --> 00:02:03,149
of thoughts or suggestions

00:02:04,270 --> 00:02:09,009
so what's the problem and the problem is

00:02:06,880 --> 00:02:11,500
rust has no established mechanism of

00:02:09,009 --> 00:02:13,209
policy for error management although it

00:02:11,500 --> 00:02:14,950
does have error handling primitives and

00:02:13,209 --> 00:02:22,150
I'm gonna expand on what I mean by that

00:02:14,950 --> 00:02:26,140
statement in the sequel okay so I really

00:02:22,150 --> 00:02:29,110
actually don't know of any language that

00:02:26,140 --> 00:02:30,340
has an established policy so we're not

00:02:29,110 --> 00:02:34,390
really saying anything special about

00:02:30,340 --> 00:02:36,970
rust um but I was talking about my talk

00:02:34,390 --> 00:02:38,739
with somebody who works at Red Hat and

00:02:36,970 --> 00:02:40,890
the imports of digital years ago and

00:02:38,739 --> 00:02:46,540
they said oh this was all solved in VMs

00:02:40,890 --> 00:02:48,640
okay so luckily most of you don't look

00:02:46,540 --> 00:02:53,739
old enough to remember so all this will

00:02:48,640 --> 00:02:56,080
be new okay so I'm gonna talk about

00:02:53,739 --> 00:02:58,299
Python and this is to expand on the idea

00:02:56,080 --> 00:03:00,760
of error handling versus error

00:02:58,299 --> 00:03:02,590
management and I like Python and Python

00:03:00,760 --> 00:03:06,160
has made me happy by new introductions

00:03:02,590 --> 00:03:07,810
in Python 3 first there's all of an old

00:03:06,160 --> 00:03:10,660
stuff that kind of works pretty well

00:03:07,810 --> 00:03:12,850
you have exception handling there's the

00:03:10,660 --> 00:03:15,269
try the except you can catch exceptions

00:03:12,850 --> 00:03:18,250
by their types you can identify them and

00:03:15,269 --> 00:03:20,290
newish is the thing that where you can

00:03:18,250 --> 00:03:23,260
as part of language you can just chain

00:03:20,290 --> 00:03:25,150
the exceptions and so what's going on

00:03:23,260 --> 00:03:26,890
here this is some chunk of code that I

00:03:25,150 --> 00:03:30,430
wrote at some point you see the happy

00:03:26,890 --> 00:03:33,370
from keyword and what we've done is

00:03:30,430 --> 00:03:36,430
we've caught some error and we've

00:03:33,370 --> 00:03:39,430
changed it with our new error in our

00:03:36,430 --> 00:03:41,350
library so now there's a success in of

00:03:39,430 --> 00:03:43,660
errors there's one error and it's child

00:03:41,350 --> 00:03:46,600
which was the original error and this is

00:03:43,660 --> 00:03:48,910
a library that is very fastidious and it

00:03:46,600 --> 00:03:50,500
knows that it can't get any other errors

00:03:48,910 --> 00:03:52,299
besides the ones that are checked

00:03:50,500 --> 00:03:55,530
so it's chaining it with the special

00:03:52,299 --> 00:03:55,530
error that says oops

00:03:59,690 --> 00:04:05,410
okay so Python has these this nice

00:04:02,600 --> 00:04:09,980
mechanism but it doesn't have any error

00:04:05,410 --> 00:04:13,730
management strategy or enforced anything

00:04:09,980 --> 00:04:16,549
or mechanism really and python has a big

00:04:13,730 --> 00:04:18,350
problem which is that if you're you have

00:04:16,549 --> 00:04:21,049
a python library of programming and

00:04:18,350 --> 00:04:24,410
you're calling into other libraries you

00:04:21,049 --> 00:04:26,270
can kind of expect any exception at any

00:04:24,410 --> 00:04:32,990
time to be raised for the code that you

00:04:26,270 --> 00:04:35,030
call anything and so there's a lot of

00:04:32,990 --> 00:04:38,540
Python code in the world obviously and

00:04:35,030 --> 00:04:39,980
that's because when Python developers

00:04:38,540 --> 00:04:41,600
develop code they sort of forget that

00:04:39,980 --> 00:04:44,420
this is a fact otherwise they would be

00:04:41,600 --> 00:04:46,880
too depressed to continue and they just

00:04:44,420 --> 00:04:48,350
go ahead and break code and then they

00:04:46,880 --> 00:04:50,180
catch the exceptions they know about and

00:04:48,350 --> 00:04:52,730
one more come flying through they add

00:04:50,180 --> 00:04:55,090
some more code and so forth and so it's

00:04:52,730 --> 00:04:55,090
very reactive

00:05:03,080 --> 00:05:07,490
okay and so I I'm pretty fanatical I'm

00:05:05,960 --> 00:05:10,220
in the lucky position of having written

00:05:07,490 --> 00:05:12,259
lots of little Python libraries and so I

00:05:10,220 --> 00:05:14,449
define a bug if any exception gets

00:05:12,259 --> 00:05:16,520
through my library from lower code

00:05:14,449 --> 00:05:18,590
that's a bug if I raise an exception

00:05:16,520 --> 00:05:21,229
that I haven't done find it's a bug and

00:05:18,590 --> 00:05:24,169
I always chain exceptions so that's my

00:05:21,229 --> 00:05:26,930
rules that I obey and they work well in

00:05:24,169 --> 00:05:29,690
my world but it's a little bit of work

00:05:26,930 --> 00:05:32,569
to think about that and design your

00:05:29,690 --> 00:05:34,580
exceptions and so forth and lots of

00:05:32,569 --> 00:05:36,050
people don't even agree that this is

00:05:34,580 --> 00:05:40,400
what you should do and think I'm a

00:05:36,050 --> 00:05:45,169
little weird for developing my libraries

00:05:40,400 --> 00:05:47,750
this way okay well there see this is a

00:05:45,169 --> 00:05:51,710
totally different language and it's sort

00:05:47,750 --> 00:05:56,479
of a good example of a very different

00:05:51,710 --> 00:05:58,250
and also bad situation so in C you have

00:05:56,479 --> 00:06:00,409
error codes you return the error code

00:05:58,250 --> 00:06:03,800
and the easiest thing in the world to do

00:06:00,409 --> 00:06:05,180
is if your developer is to ignore that

00:06:03,800 --> 00:06:09,680
error code there's nothing to prevent

00:06:05,180 --> 00:06:12,139
you from doing that and they don't they

00:06:09,680 --> 00:06:14,479
don't tell you much either and it also

00:06:12,139 --> 00:06:16,969
turns out that often there's no

00:06:14,479 --> 00:06:19,310
information about what they mean and so

00:06:16,969 --> 00:06:21,620
my former colleague got four years of

00:06:19,310 --> 00:06:25,490
fun papers in many of them in good

00:06:21,620 --> 00:06:27,849
conferences out of this fact so I left

00:06:25,490 --> 00:06:31,099
around here that's when I graduated but

00:06:27,849 --> 00:06:32,690
she took open-source C code which was

00:06:31,099 --> 00:06:33,740
available most of it was system code

00:06:32,690 --> 00:06:36,529
which is kind of this thing that

00:06:33,740 --> 00:06:38,900
standard Stratos has to work with she

00:06:36,529 --> 00:06:42,800
had a special love for file systems

00:06:38,900 --> 00:06:45,080
apparently and she got lots of she's

00:06:42,800 --> 00:06:47,569
static analysis to show all the many

00:06:45,080 --> 00:06:51,979
ways in which error codes are lost or

00:06:47,569 --> 00:06:53,930
confused or ignored in systems code and

00:06:51,979 --> 00:06:56,029
she did really well on that and you

00:06:53,930 --> 00:06:57,650
could argue well like there's some

00:06:56,029 --> 00:06:59,960
tricks she did here she's like there are

00:06:57,650 --> 00:07:03,529
a thousand locations and file system

00:06:59,960 --> 00:07:07,550
code where error codes are just ignored

00:07:03,529 --> 00:07:09,519
and the way to get an even better number

00:07:07,550 --> 00:07:12,619
is to an analyze it

00:07:09,519 --> 00:07:15,649
because hopefully a few more places so

00:07:12,619 --> 00:07:18,199
you can argue that she was some of her

00:07:15,649 --> 00:07:21,649
numbers are sort of more about her cool

00:07:18,199 --> 00:07:25,629
analysis but you can't say this isn't

00:07:21,649 --> 00:07:25,629
yet another way to say there's a problem

00:07:25,869 --> 00:07:32,749
okay so that was spy thon and see it's

00:07:30,079 --> 00:07:35,629
how compare of them and I'll say well

00:07:32,749 --> 00:07:38,599
see there's something to tell you that

00:07:35,629 --> 00:07:40,879
there are errors but there's not much

00:07:38,599 --> 00:07:42,409
else that you got going for Python it

00:07:40,879 --> 00:07:46,099
has this exception mechanism which is

00:07:42,409 --> 00:07:47,959
really nice but you can expect track

00:07:46,099 --> 00:07:50,719
stack traces all the time in our

00:07:47,959 --> 00:07:54,159
regularly regulated code with different

00:07:50,719 --> 00:07:54,159
types they just keep on coming

00:07:56,619 --> 00:08:03,069
okay and this is a total aside because

00:07:59,179 --> 00:08:03,069
it all for inform the rest of the talk

00:08:03,219 --> 00:08:09,979
I'm showing a simple two-way graph

00:08:07,299 --> 00:08:12,800
statically checked languages we see the

00:08:09,979 --> 00:08:19,309
column rust and C enter and that and

00:08:12,800 --> 00:08:23,419
then languages and so basically what I'm

00:08:19,309 --> 00:08:27,709
going to talk about is that rust is in

00:08:23,419 --> 00:08:28,389
this particular spot here and that's a

00:08:27,709 --> 00:08:30,979
good thing

00:08:28,389 --> 00:08:32,599
because we know types that we'll find

00:08:30,979 --> 00:08:35,889
out that we know types of errors that we

00:08:32,599 --> 00:08:39,349
have to deal with at compile time and

00:08:35,889 --> 00:08:42,589
that's a rough thing it makes things

00:08:39,349 --> 00:08:45,050
hard for us because we have to make the

00:08:42,589 --> 00:08:48,379
language acceptable to the type checker

00:08:45,050 --> 00:08:50,860
and that's harder to do for rust than

00:08:48,379 --> 00:08:50,860
for C and

00:08:54,750 --> 00:09:04,330
okay so rust took the other approach a

00:08:59,500 --> 00:09:06,340
third approach and this is kind of wordy

00:09:04,330 --> 00:09:08,500
I left out a lot of annotations because

00:09:06,340 --> 00:09:10,600
this is but left a few and this is a

00:09:08,500 --> 00:09:13,180
fundamental type in the rest standard

00:09:10,600 --> 00:09:16,270
library it's the result type and it's a

00:09:13,180 --> 00:09:18,670
typical parameterize type and so you can

00:09:16,270 --> 00:09:21,880
construct a result type in two ways

00:09:18,670 --> 00:09:24,250
either you can construct okay and that

00:09:21,880 --> 00:09:26,020
will be the value that your function is

00:09:24,250 --> 00:09:29,100
supposed to return or you can construct

00:09:26,020 --> 00:09:31,960
error and that will be some error type

00:09:29,100 --> 00:09:33,910
okay so another thing you should look

00:09:31,960 --> 00:09:36,940
notice is there's this little must use

00:09:33,910 --> 00:09:40,920
annotation which the compiler

00:09:36,940 --> 00:09:43,210
understands and will see it will enforce

00:09:40,920 --> 00:09:45,910
okay so here I am

00:09:43,210 --> 00:09:50,080
I've written a incredibly simple

00:09:45,910 --> 00:09:56,650
function up here and I called write all

00:09:50,080 --> 00:09:59,050
on file and write something and as we

00:09:56,650 --> 00:10:00,930
all know when you wait to file that may

00:09:59,050 --> 00:10:04,060
not work out there could be an error and

00:10:00,930 --> 00:10:07,570
the compiler that means that write all

00:10:04,060 --> 00:10:11,350
itself is a function that returns a

00:10:07,570 --> 00:10:13,000
result type now the compiler responds to

00:10:11,350 --> 00:10:16,030
this particular use of that function

00:10:13,000 --> 00:10:19,600
with a complete it says that you didn't

00:10:16,030 --> 00:10:23,740
look at the result of invoking this

00:10:19,600 --> 00:10:26,260
function here and there's a warning

00:10:23,740 --> 00:10:29,110
because you must use that so I look at

00:10:26,260 --> 00:10:31,390
it in this code here I ignored the

00:10:29,110 --> 00:10:35,680
possibility that it might fail the

00:10:31,390 --> 00:10:37,510
compiler itself is gonna reprimand me

00:10:35,680 --> 00:10:41,080
and of course this is only a compiler

00:10:37,510 --> 00:10:43,600
warning and we can turn off warnings and

00:10:41,080 --> 00:10:45,850
ignore them if you choose to but if

00:10:43,600 --> 00:10:48,360
people see us doing that they will just

00:10:45,850 --> 00:10:48,360
trust us

00:10:51,320 --> 00:10:55,650
okay so I can get around the compiler

00:10:54,000 --> 00:10:58,470
and if another pretty cheap way as well

00:10:55,650 --> 00:11:03,750
I can match the error and I can match

00:10:58,470 --> 00:11:06,120
the okay whatever and the compiler will

00:11:03,750 --> 00:11:10,460
be happy with that and so interestingly

00:11:06,120 --> 00:11:15,020
we'll the winter okay but if I do that

00:11:10,460 --> 00:11:18,240
that's a pretty flagrant behavior and

00:11:15,020 --> 00:11:21,420
again that will be noticed and it won't

00:11:18,240 --> 00:11:23,160
usually pass code of you and things like

00:11:21,420 --> 00:11:25,350
that so I'm pretending to be interested

00:11:23,160 --> 00:11:32,610
even though I'm not another thing I can

00:11:25,350 --> 00:11:36,450
do is I can say okay if there is an

00:11:32,610 --> 00:11:38,910
error terminate the program like that

00:11:36,450 --> 00:11:40,890
stop right there terminate it that's

00:11:38,910 --> 00:11:46,460
what this unwrap does in the same

00:11:40,890 --> 00:11:48,860
situation but again if you're writing

00:11:46,460 --> 00:11:52,620
production code that is supposed to

00:11:48,860 --> 00:11:56,090
operate in difficult situations people

00:11:52,620 --> 00:11:56,090
will notice this and object

00:12:00,080 --> 00:12:09,360
okay another thing I can do is I can

00:12:05,610 --> 00:12:12,780
assert that this will always succeed and

00:12:09,360 --> 00:12:15,270
you can all see that I'm lying here but

00:12:12,780 --> 00:12:16,800
if it's here if you didn't read the

00:12:15,270 --> 00:12:18,870
strain you might think I had good

00:12:16,800 --> 00:12:20,910
judgment and knew what I was doing and

00:12:18,870 --> 00:12:23,460
had somehow prove that this thing could

00:12:20,910 --> 00:12:28,320
succeed so that's another way I can get

00:12:23,460 --> 00:12:30,420
around the compiler but I could choose

00:12:28,320 --> 00:12:32,820
to do the right thing and here you she's

00:12:30,420 --> 00:12:37,980
need to do the right thing I know that

00:12:32,820 --> 00:12:40,260
right all returns an i/o error and so I

00:12:37,980 --> 00:12:42,780
say my whole function can return that

00:12:40,260 --> 00:12:45,030
exact same error and I use the little

00:12:42,780 --> 00:12:52,800
question mark to say if you encounter an

00:12:45,030 --> 00:12:56,700
error return it all good okay so that's

00:12:52,800 --> 00:13:03,930
my honest behavior but it turns out that

00:12:56,700 --> 00:13:05,850
immediately is a problem so the thing is

00:13:03,930 --> 00:13:08,610
when I write functions they might not

00:13:05,850 --> 00:13:11,130
all return results that have the same

00:13:08,610 --> 00:13:13,890
type of error so so I'm writing this

00:13:11,130 --> 00:13:15,690
function and here I did would get an i/o

00:13:13,890 --> 00:13:18,300
error potentially but down here maybe I

00:13:15,690 --> 00:13:22,080
get some other kind of error that can

00:13:18,300 --> 00:13:23,700
happen and the problem is well those are

00:13:22,080 --> 00:13:29,160
different errors different types of

00:13:23,700 --> 00:13:29,700
errors and rusts needs to type check

00:13:29,160 --> 00:13:35,790
stuff

00:13:29,700 --> 00:13:38,880
and it won't accept that and so what I

00:13:35,790 --> 00:13:43,050
haven't ultimately do is I define a

00:13:38,880 --> 00:13:46,350
super error and I can convert every

00:13:43,050 --> 00:13:48,990
other error into super error so for my

00:13:46,350 --> 00:13:51,840
whole library whatever I define this

00:13:48,990 --> 00:13:54,540
super error and any other error that I

00:13:51,840 --> 00:13:56,160
could encounter in the functions has an

00:13:54,540 --> 00:14:00,120
automatic way to be promoted to the

00:13:56,160 --> 00:14:04,240
super error which I call all error here

00:14:00,120 --> 00:14:05,800
and we have a game here because we had

00:14:04,240 --> 00:14:07,300
to write all this boilerplate to do it

00:14:05,800 --> 00:14:12,910
but at least we know every type a

00:14:07,300 --> 00:14:17,470
function of but there's another problem

00:14:12,910 --> 00:14:22,630
here which is very significant which is

00:14:17,470 --> 00:14:24,279
that what I've done is typically I have

00:14:22,630 --> 00:14:26,940
this little question mark here and I say

00:14:24,279 --> 00:14:30,730
okay if I encountered this problem just

00:14:26,940 --> 00:14:34,060
return that error and it'll be subsumed

00:14:30,730 --> 00:14:38,079
into all error and so what I potentially

00:14:34,060 --> 00:14:40,510
have is a stack just like any other

00:14:38,079 --> 00:14:44,200
stack and I have a lot of calls on the

00:14:40,510 --> 00:14:47,950
stack and in functions the first

00:14:44,200 --> 00:14:49,089
function returns an error function which

00:14:47,950 --> 00:14:51,370
is pretty similar with a question mark

00:14:49,089 --> 00:14:54,070
so it returns the error and the error

00:14:51,370 --> 00:14:55,480
just kept keeps being returned until you

00:14:54,070 --> 00:15:00,760
get to the bottom and then you have the

00:14:55,480 --> 00:15:02,940
error coming out and all you have is the

00:15:00,760 --> 00:15:02,940
error

00:15:08,550 --> 00:15:16,280
okay so how are we doing with rust

00:15:14,120 --> 00:15:18,990
some things are good some things are bad

00:15:16,280 --> 00:15:22,200
so long as everybody is writing stuff

00:15:18,990 --> 00:15:24,420
properly any function that can have an

00:15:22,200 --> 00:15:25,890
error must return the result type and

00:15:24,420 --> 00:15:31,500
you can see that and deal with that

00:15:25,890 --> 00:15:36,450
that's good and in rust the compiler

00:15:31,500 --> 00:15:40,380
forces you to do fairly obvious work to

00:15:36,450 --> 00:15:43,260
ignore the fact that a method could have

00:15:40,380 --> 00:15:45,120
an error so you have to do work which is

00:15:43,260 --> 00:15:49,440
the inverse of C where you have to do

00:15:45,120 --> 00:15:54,420
work to observe it okay but the

00:15:49,440 --> 00:15:55,890
situation is still really bad in rust so

00:15:54,420 --> 00:15:57,510
we have a good thing which is we know

00:15:55,890 --> 00:16:02,010
all the types of errors we can encounter

00:15:57,510 --> 00:16:06,240
and we can work with that but typically

00:16:02,010 --> 00:16:07,470
we just end up unrolling the stack just

00:16:06,240 --> 00:16:10,200
like we would if we raise an exception

00:16:07,470 --> 00:16:12,780
in Python but in the end we don't even

00:16:10,200 --> 00:16:16,530
get a stack trace because that error

00:16:12,780 --> 00:16:19,440
return is a normal return so at the

00:16:16,530 --> 00:16:20,910
bottom we have some error and the

00:16:19,440 --> 00:16:26,010
typical thing of course that you might

00:16:20,910 --> 00:16:28,050
encounter is that in the end you know

00:16:26,010 --> 00:16:33,740
that somewhere in your program there was

00:16:28,050 --> 00:16:33,740
an i/o error and that's not good at all

00:16:37,100 --> 00:16:44,210
okay so to summarize things aren't so

00:16:42,140 --> 00:16:47,030
great and C and I told you how I see

00:16:44,210 --> 00:16:48,650
that and things are kind of mixed in

00:16:47,030 --> 00:16:50,480
Python because the exception mechanism

00:16:48,650 --> 00:16:51,980
us okay but you get exceptions all the

00:16:50,480 --> 00:16:55,040
time and you're running code because you

00:16:51,980 --> 00:16:57,200
can't predict what exception types

00:16:55,040 --> 00:16:59,930
you'll have to deal with and when Russ

00:16:57,200 --> 00:17:05,000
the situation is more complicated you

00:16:59,930 --> 00:17:07,610
have a useful type to encode whether or

00:17:05,000 --> 00:17:10,100
not there was an error and you know in

00:17:07,610 --> 00:17:12,079
your function the compiler pays

00:17:10,100 --> 00:17:14,000
attention to that and forces you to deal

00:17:12,079 --> 00:17:18,380
with it or to get around it in some way

00:17:14,000 --> 00:17:21,650
and you know what types of errors you're

00:17:18,380 --> 00:17:24,709
encountering but usually the state of

00:17:21,650 --> 00:17:27,620
the matter is that in the end the error

00:17:24,709 --> 00:17:32,030
you get is just a bare error with no

00:17:27,620 --> 00:17:33,740
information about where it was generated

00:17:32,030 --> 00:17:36,190
or any of those useful things that come

00:17:33,740 --> 00:17:42,290
with the Python stacktrace

00:17:36,190 --> 00:17:43,670
okay so the rust community can really be

00:17:42,290 --> 00:17:48,050
commended for even thinking this is a

00:17:43,670 --> 00:17:53,150
problem okay so they've tried they tried

00:17:48,050 --> 00:17:55,640
to address it and error chain was a rust

00:17:53,150 --> 00:17:57,170
crate that came out in 2016 and I jumped

00:17:55,640 --> 00:17:59,930
right on that bandwagon

00:17:57,170 --> 00:18:02,600
I felt they'd solved the problem they

00:17:59,930 --> 00:18:04,850
certainly from error chain you can guess

00:18:02,600 --> 00:18:08,090
one of their major focuses was chaining

00:18:04,850 --> 00:18:12,340
errors and I'm all about that as I've

00:18:08,090 --> 00:18:15,920
already mentioned so that was great but

00:18:12,340 --> 00:18:17,330
the state it is in now is basically

00:18:15,920 --> 00:18:19,550
abandoned although there's been some

00:18:17,330 --> 00:18:21,320
efforts to sort of push it forward a bit

00:18:19,550 --> 00:18:22,790
or at least to heal it to the point

00:18:21,320 --> 00:18:26,390
where it's still usable by the people

00:18:22,790 --> 00:18:28,690
who started using it in 2016 basically

00:18:26,390 --> 00:18:30,920
there was another crate called failure

00:18:28,690 --> 00:18:35,330
which introduced the idea of error

00:18:30,920 --> 00:18:37,970
management but it's in a sort of

00:18:35,330 --> 00:18:40,600
wallowing state it's wallowing a bad at

00:18:37,970 --> 00:18:44,180
this point this is not a comparison of

00:18:40,600 --> 00:18:46,700
these different earlier tents so I won't

00:18:44,180 --> 00:18:47,740
get into this in detail but you can just

00:18:46,700 --> 00:18:50,110
look at there

00:18:47,740 --> 00:18:57,429
their github sites and see as they try

00:18:50,110 --> 00:18:59,380
to deal or whatever and in fact there

00:18:57,429 --> 00:19:03,390
are problems within the rough standard

00:18:59,380 --> 00:19:06,270
library so if you follow this link here

00:19:03,390 --> 00:19:08,770
this it's called something pretty

00:19:06,270 --> 00:19:12,250
straightforward like fix the error trade

00:19:08,770 --> 00:19:16,200
and now the air trade is a fundamental

00:19:12,250 --> 00:19:19,179
part of the RUS standard library and

00:19:16,200 --> 00:19:23,770
about a year ago they realized there it

00:19:19,179 --> 00:19:25,720
was established in such a way that it

00:19:23,770 --> 00:19:27,640
was it was very technical but it was

00:19:25,720 --> 00:19:31,270
unusable in certain ways they'd expected

00:19:27,640 --> 00:19:32,130
it to be usable and this issue was open

00:19:31,270 --> 00:19:35,500
while ago

00:19:32,130 --> 00:19:36,820
there are several little boxes for to

00:19:35,500 --> 00:19:38,679
put check marks in and there's a

00:19:36,820 --> 00:19:42,429
definitely check mark in one of those

00:19:38,679 --> 00:19:46,000
boxes okay but not at all this so the

00:19:42,429 --> 00:19:52,480
problem is that now we need something

00:19:46,000 --> 00:19:55,240
and it's not really there so I'm willing

00:19:52,480 --> 00:19:57,220
to step into the void in order to

00:19:55,240 --> 00:20:02,169
construct something at least for myself

00:19:57,220 --> 00:20:03,880
for my project and maybe subsequently

00:20:02,169 --> 00:20:08,020
it'll work out to be the thing that

00:20:03,880 --> 00:20:09,460
others can use okay so one of the things

00:20:08,020 --> 00:20:13,720
that we think we really ought to have is

00:20:09,460 --> 00:20:15,370
that batteries and and you can see why I

00:20:13,720 --> 00:20:18,010
don't think I even have to go into any

00:20:15,370 --> 00:20:19,960
detail about that that's obvious also

00:20:18,010 --> 00:20:23,620
the chaney of error is is to me very

00:20:19,960 --> 00:20:26,350
very important a slight difference that

00:20:23,620 --> 00:20:30,850
I have with other people is that I think

00:20:26,350 --> 00:20:32,980
that the the chain the essential whether

00:20:30,850 --> 00:20:35,740
it's a left or right link can be given

00:20:32,980 --> 00:20:37,720
some information we also want to be able

00:20:35,740 --> 00:20:40,929
to log these errors in an intelligent

00:20:37,720 --> 00:20:42,399
way and because we already have a big

00:20:40,929 --> 00:20:45,309
project we want to be able to add this

00:20:42,399 --> 00:20:48,249
in gradually and possibly even

00:20:45,309 --> 00:20:50,950
really a more difficult thing take it

00:20:48,249 --> 00:20:54,820
out if the community comes up with

00:20:50,950 --> 00:21:03,129
something full-strength at some later

00:20:54,820 --> 00:21:05,649
time okay so this is my era here and

00:21:03,129 --> 00:21:07,840
this is an actual struck not a trade and

00:21:05,649 --> 00:21:10,029
you can see that these things are

00:21:07,840 --> 00:21:12,879
showing up here's the back trace that I

00:21:10,029 --> 00:21:15,519
demand we have here we have those

00:21:12,879 --> 00:21:18,909
children that we chained with and here

00:21:15,519 --> 00:21:20,440
we have a thing to hold what actually

00:21:18,909 --> 00:21:28,210
characterizes the arrow what kind of

00:21:20,440 --> 00:21:34,110
error it actually was okay so just a

00:21:28,210 --> 00:21:37,149
brief aside but this is about stack and

00:21:34,110 --> 00:21:38,980
you well know that python is generally

00:21:37,149 --> 00:21:40,840
an interpreted language the Python

00:21:38,980 --> 00:21:44,259
interpreter comes along and it manages

00:21:40,840 --> 00:21:46,149
it on its own stack and so when the

00:21:44,259 --> 00:21:48,519
Python interpreter generates a stack

00:21:46,149 --> 00:21:50,679
that is not a problem for it so if it's

00:21:48,519 --> 00:21:52,480
generating a stack trays to show what

00:21:50,679 --> 00:21:54,700
was going on when an exception was

00:21:52,480 --> 00:21:56,110
raised there's no difficulty because it

00:21:54,700 --> 00:21:57,639
built the stack it knows everything

00:21:56,110 --> 00:22:01,470
about the stack so that's fine

00:21:57,639 --> 00:22:04,720
um rust of course is a compiled language

00:22:01,470 --> 00:22:07,779
or rather that's how we run it so we

00:22:04,720 --> 00:22:09,159
compile rust we get an executable and so

00:22:07,779 --> 00:22:10,899
this stack is not the friendly

00:22:09,159 --> 00:22:13,480
interpreter stack but this is just the

00:22:10,899 --> 00:22:18,639
machine stack okay

00:22:13,480 --> 00:22:20,409
and so as one would expect getting the

00:22:18,639 --> 00:22:24,179
machine getting information about the

00:22:20,409 --> 00:22:28,119
machine stack is a harder problem but

00:22:24,179 --> 00:22:31,629
you've all run if you have been in gdb

00:22:28,119 --> 00:22:35,470
and you types of BT you've got in a

00:22:31,629 --> 00:22:37,600
batteries same thing so we know that

00:22:35,470 --> 00:22:40,899
that is a problem that people have

00:22:37,600 --> 00:22:42,610
tackled and solved and although what you

00:22:40,899 --> 00:22:44,830
see is not as pretty as the Python

00:22:42,610 --> 00:22:47,919
interpreter would get you it's still the

00:22:44,830 --> 00:22:50,860
same general notion and has information

00:22:47,919 --> 00:22:52,450
modulo a lot of tricky stuff that I

00:22:50,860 --> 00:22:57,909
won't go into in this talk

00:22:52,450 --> 00:23:01,239
and the good news is that there is a

00:22:57,909 --> 00:23:02,889
healthy happy crate in rust that will

00:23:01,239 --> 00:23:06,399
get the batteries for you so not

00:23:02,889 --> 00:23:07,929
abandoned in any way it works it will

00:23:06,399 --> 00:23:12,460
obtain a back-trace through well

00:23:07,929 --> 00:23:15,220
understood methods okay so getting the

00:23:12,460 --> 00:23:19,299
back-trace is more or less modulo very

00:23:15,220 --> 00:23:22,690
much technical detail a salt problem so

00:23:19,299 --> 00:23:26,109
then what should be the policy what

00:23:22,690 --> 00:23:30,519
errors should have a back-trace and what

00:23:26,109 --> 00:23:36,009
I go with right now is every error and

00:23:30,519 --> 00:23:37,899
what argument there is that as an if an

00:23:36,009 --> 00:23:40,690
error is returned then an action might

00:23:37,899 --> 00:23:42,820
be taken because of that error which

00:23:40,690 --> 00:23:45,009
will result potentially in another error

00:23:42,820 --> 00:23:48,639
with a new back trace and the new back

00:23:45,009 --> 00:23:51,039
trace will not simply be a prefix of the

00:23:48,639 --> 00:23:53,200
previous back trace okay because new

00:23:51,039 --> 00:23:56,019
actions were taken and the stack was

00:23:53,200 --> 00:23:59,139
built somewhere else and then the error

00:23:56,019 --> 00:24:00,220
occurred but I'm so worried that this

00:23:59,139 --> 00:24:02,679
might be a bad idea

00:24:00,220 --> 00:24:06,970
that I make the access a function return

00:24:02,679 --> 00:24:08,889
an option type and it might be a bad

00:24:06,970 --> 00:24:12,100
idea for a few reasons

00:24:08,889 --> 00:24:14,559
it might it might affect performance in

00:24:12,100 --> 00:24:16,690
some way or we might find there was some

00:24:14,559 --> 00:24:18,460
in some circumstances in which it can't

00:24:16,690 --> 00:24:24,399
be obtained I can't think of that yet

00:24:18,460 --> 00:24:27,759
but nervous enough okay the other thing

00:24:24,399 --> 00:24:31,509
is the specifics about the error we want

00:24:27,759 --> 00:24:38,649
that to be detailed and useful so we put

00:24:31,509 --> 00:24:41,519
it in a separate spot and what we're

00:24:38,649 --> 00:24:46,359
doing now is we say that in every

00:24:41,519 --> 00:24:49,690
library or other isolated thing that

00:24:46,359 --> 00:24:51,369
we're building we make it just globally

00:24:49,690 --> 00:24:56,440
defined that is we don't try to segment

00:24:51,369 --> 00:25:00,869
it into different parts of the of the

00:24:56,440 --> 00:25:00,869
library or other thing

00:25:00,970 --> 00:25:04,549
isolate them from each other because

00:25:03,049 --> 00:25:05,029
that seems to be more overhead than it's

00:25:04,549 --> 00:25:08,659
worth

00:25:05,029 --> 00:25:12,429
we just naked library wide essentially

00:25:08,659 --> 00:25:12,429
lots and lots of things

00:25:17,809 --> 00:25:26,059
okay and then finally there's the child

00:25:20,710 --> 00:25:28,759
this is the thing you chain and I just

00:25:26,059 --> 00:25:30,669
thought about it and I've decided that

00:25:28,759 --> 00:25:34,369
there are two different and interesting

00:25:30,669 --> 00:25:36,590
relationships one is simply that the

00:25:34,369 --> 00:25:38,989
parent provides additional context for

00:25:36,590 --> 00:25:41,960
the child and you can imagine that and

00:25:38,989 --> 00:25:45,909
the usual sort of file not found you get

00:25:41,960 --> 00:25:48,559
that error back and some higher level

00:25:45,909 --> 00:25:50,389
function says adds additional

00:25:48,559 --> 00:25:54,679
information that says this is the file

00:25:50,389 --> 00:25:57,080
that we were looking for and then later

00:25:54,679 --> 00:25:59,299
it says okay we fail to do this action

00:25:57,080 --> 00:26:01,940
and so forth the other thing is that it

00:25:59,299 --> 00:26:03,349
just might happen after and that's more

00:26:01,940 --> 00:26:06,559
like the scenario or there's some

00:26:03,349 --> 00:26:08,389
reaction to the error and a new action

00:26:06,559 --> 00:26:10,669
is taken but that also results in a

00:26:08,389 --> 00:26:14,450
narrative and I think that these are

00:26:10,669 --> 00:26:16,580
distinct enough that we should use

00:26:14,450 --> 00:26:21,469
essentially the left and right arrows to

00:26:16,580 --> 00:26:23,509
distinguish okay and so you can think of

00:26:21,469 --> 00:26:30,440
it as being something like this so this

00:26:23,509 --> 00:26:34,070
is my example so I wanted to ride around

00:26:30,440 --> 00:26:35,779
on my horse my new people but there was

00:26:34,070 --> 00:26:37,759
this missing nail which led to the lost

00:26:35,779 --> 00:26:40,369
shoe which meant to the horse not

00:26:37,759 --> 00:26:43,070
working but this is sort of an updated

00:26:40,369 --> 00:26:46,549
poem so I ran to my Jeep but that didn't

00:26:43,070 --> 00:26:49,909
work either and so you see that this

00:26:46,549 --> 00:26:52,879
shows the previous link because this

00:26:49,909 --> 00:26:59,179
doesn't further explain this problem

00:26:52,879 --> 00:27:01,460
it's a new thing but ultimately it's

00:26:59,179 --> 00:27:05,979
also a good reminder about the

00:27:01,460 --> 00:27:10,519
importance of small things I guess okay

00:27:05,979 --> 00:27:12,139
and so in order to deal with gradually

00:27:10,519 --> 00:27:15,950
adding this into an already existing

00:27:12,139 --> 00:27:18,889
large program we use that same trick

00:27:15,950 --> 00:27:22,969
that I was saying can cause some

00:27:18,889 --> 00:27:26,179
problems earlier we make this a separate

00:27:22,969 --> 00:27:28,700
kind of error and we implicitly promote

00:27:26,179 --> 00:27:30,040
this to our super error like we promoted

00:27:28,700 --> 00:27:32,360
everything else

00:27:30,040 --> 00:27:36,970
every other error that we had to deal

00:27:32,360 --> 00:27:42,080
with program as we gradually add it in

00:27:36,970 --> 00:27:44,570
until it encompasses everything okay so

00:27:42,080 --> 00:27:46,220
this one I could list you all the things

00:27:44,570 --> 00:27:48,740
we worried about and thought about but

00:27:46,220 --> 00:27:58,910
that would be boring and so I'm just

00:27:48,740 --> 00:28:04,730
gonna say we're thinking about it okay

00:27:58,910 --> 00:28:06,140
so this is the end of my talk and rather

00:28:04,730 --> 00:28:09,050
than do this just asking for questions

00:28:06,140 --> 00:28:15,350
if you have any advice I'd actually

00:28:09,050 --> 00:28:17,420
welcome it we have this PR up I actually

00:28:15,350 --> 00:28:19,160
have a repo for this talk so if you have

00:28:17,420 --> 00:28:20,960
any comments you can actually attach

00:28:19,160 --> 00:28:26,870
them as issues because I update talks

00:28:20,960 --> 00:28:30,800
and then we have at one time designed PR

00:28:26,870 --> 00:28:34,580
but of course a design doc but of course

00:28:30,800 --> 00:28:42,830
that encountered reality so it's now

00:28:34,580 --> 00:28:45,160
lagging the pull a bit and yeah that is

00:28:42,830 --> 00:28:45,160
it

00:28:50,800 --> 00:28:56,120
so thank you for a very good talk

00:28:53,630 --> 00:29:02,840
I've also been working in rust for about

00:28:56,120 --> 00:29:04,550
a year and this is a perpetual pain just

00:29:02,840 --> 00:29:07,250
a couple other comments and then a

00:29:04,550 --> 00:29:11,480
question one of the things that's nice

00:29:07,250 --> 00:29:15,200
about the Python method is that errors

00:29:11,480 --> 00:29:17,960
don't end up as part of your API so you

00:29:15,200 --> 00:29:21,380
can you can add additional errors for

00:29:17,960 --> 00:29:23,420
example for additional cases and it it

00:29:21,380 --> 00:29:26,180
doesn't break every application that

00:29:23,420 --> 00:29:28,010
depends on you I'm not sure we can

00:29:26,180 --> 00:29:30,650
really do anything about that and rust

00:29:28,010 --> 00:29:33,950
because having them in the API is also

00:29:30,650 --> 00:29:38,390
nice but it does represent at least a

00:29:33,950 --> 00:29:42,260
pain point for for using errors my

00:29:38,390 --> 00:29:44,990
question was for your well I have

00:29:42,260 --> 00:29:47,570
several questions one is for your all

00:29:44,990 --> 00:29:54,320
error type are you then do you then have

00:29:47,570 --> 00:29:56,330
implicit parameter ization for the into

00:29:54,320 --> 00:29:58,610
type so that you can use the question

00:29:56,330 --> 00:30:08,270
mark operator to implicitly convert all

00:29:58,610 --> 00:30:09,980
errors into all errors so so I think the

00:30:08,270 --> 00:30:12,380
question is quite understandable so

00:30:09,980 --> 00:30:14,480
about the implicit conversion I missed

00:30:12,380 --> 00:30:15,920
so let me let me back up and explain for

00:30:14,480 --> 00:30:16,850
people who don't know there's a another

00:30:15,920 --> 00:30:19,580
trait called

00:30:16,850 --> 00:30:22,120
in tube in rust which allows you to

00:30:19,580 --> 00:30:24,830
convert from a type to a type and/or

00:30:22,120 --> 00:30:27,560
it's actually the front rate rate is the

00:30:24,830 --> 00:30:30,200
primary one but as long as you have this

00:30:27,560 --> 00:30:32,000
trait implemented for your type and you

00:30:30,200 --> 00:30:34,040
use the question mark error that rust

00:30:32,000 --> 00:30:35,690
will automatically convert it to

00:30:34,040 --> 00:30:40,340
whatever kind of error you're trying to

00:30:35,690 --> 00:30:43,100
go to and so my question is so you have

00:30:40,340 --> 00:30:46,700
like the sub error section right where

00:30:43,100 --> 00:30:49,480
you have like a parent and a what was

00:30:46,700 --> 00:30:53,180
the other term I forget concurrent

00:30:49,480 --> 00:30:55,070
constituent yes thank you so it would

00:30:53,180 --> 00:30:59,750
seem to me like you could have a fairly

00:30:55,070 --> 00:31:01,910
good automatic conversion

00:30:59,750 --> 00:31:05,120
using the question mark operator such

00:31:01,910 --> 00:31:07,640
that if an error occurs and your

00:31:05,120 --> 00:31:10,370
function is returning all error that

00:31:07,640 --> 00:31:15,020
into would convert whatever arrow type

00:31:10,370 --> 00:31:20,120
occurs into an all error listing the

00:31:15,020 --> 00:31:22,280
source as the the parents type and that

00:31:20,120 --> 00:31:27,500
would allow you to chain I think by just

00:31:22,280 --> 00:31:29,450
using the question mark operator you

00:31:27,500 --> 00:31:30,590
know this is I think we will have to

00:31:29,450 --> 00:31:32,960
write this down

00:31:30,590 --> 00:31:34,850
yeah no problem it's a very complex

00:31:32,960 --> 00:31:40,040
topic with a lot of subtle interactions

00:31:34,850 --> 00:31:41,750
yeah so um there's I can't basically I

00:31:40,040 --> 00:31:43,790
can't tell which direction you're

00:31:41,750 --> 00:31:45,380
converting into so I think it would be

00:31:43,790 --> 00:31:48,710
better if we took this one yeah we can

00:31:45,380 --> 00:31:51,170
do that are you my second question is

00:31:48,710 --> 00:31:56,590
are you actually proposing this for a

00:31:51,170 --> 00:32:00,110
crate or upstream not at this point so

00:31:56,590 --> 00:32:03,140
basically as Stratos tech lead we have

00:32:00,110 --> 00:32:05,780
to well I feel it's it's necessary we

00:32:03,140 --> 00:32:09,380
have a better situation that we have so

00:32:05,780 --> 00:32:13,370
this PR is not a separate crate but

00:32:09,380 --> 00:32:15,890
simply directly the idea would be to

00:32:13,370 --> 00:32:18,710
directly incorporate it into Stratos we

00:32:15,890 --> 00:32:21,320
need to we need to insure it before we

00:32:18,710 --> 00:32:24,890
can turn it into something that is a

00:32:21,320 --> 00:32:29,120
crate I think I honestly sort of think

00:32:24,890 --> 00:32:30,559
that these earlier efforts which are

00:32:29,120 --> 00:32:32,929
quite respectable error chain is very

00:32:30,559 --> 00:32:34,720
respectable I think that these earlier

00:32:32,929 --> 00:32:40,610
efforts might have been a little bit

00:32:34,720 --> 00:32:45,020
rushed into generalization and so time

00:32:40,610 --> 00:32:47,990
to work with it right exercise because

00:32:45,020 --> 00:32:51,350
how how widely are you using this in the

00:32:47,990 --> 00:32:55,250
Stratos code um so remember that's a PR

00:32:51,350 --> 00:33:01,340
we're experimenting it with shoving it

00:32:55,250 --> 00:33:03,290
into more places so we started working

00:33:01,340 --> 00:33:05,990
with things that were very much at Leeds

00:33:03,290 --> 00:33:07,450
as leaves of the whole Stratus project

00:33:05,990 --> 00:33:10,000
and the strat in Stratos

00:33:07,450 --> 00:33:12,669
d now we're trying to pick off other

00:33:10,000 --> 00:33:16,690
bits just interesting bits and shove it

00:33:12,669 --> 00:33:23,320
in again but I think why this process

00:33:16,690 --> 00:33:26,440
has to be so gradual is that that if you

00:33:23,320 --> 00:33:29,200
I didn't talk about the complexities

00:33:26,440 --> 00:33:32,470
here but if you want to chain the new

00:33:29,200 --> 00:33:36,940
error on to potentially a bunch of other

00:33:32,470 --> 00:33:40,269
errors you rewrite the method um the way

00:33:36,940 --> 00:33:41,620
I do it is to make a closure shove

00:33:40,269 --> 00:33:44,200
everything that was all in the old

00:33:41,620 --> 00:33:47,350
method into the closure and then chain

00:33:44,200 --> 00:33:55,350
the new error onto it but that's a

00:33:47,350 --> 00:34:00,220
rewrite and so it's it requires actual

00:33:55,350 --> 00:34:04,389
developer application one last question

00:34:00,220 --> 00:34:07,480
then I'll give up the mic so no standard

00:34:04,389 --> 00:34:09,820
is also a things on rust and I did

00:34:07,480 --> 00:34:13,179
notice you're using box there which

00:34:09,820 --> 00:34:14,649
would be fine on Alec but but if you

00:34:13,179 --> 00:34:17,460
don't have Alec that's going to be a

00:34:14,649 --> 00:34:19,899
particularly difficult situation for you

00:34:17,460 --> 00:34:24,220
so that's something to consider in your

00:34:19,899 --> 00:34:28,300
generalization efforts how things work

00:34:24,220 --> 00:34:30,510
on no standard and no Alec it's a good

00:34:28,300 --> 00:34:30,510
cat

00:34:35,830 --> 00:34:41,429
okay couple of comments this is a lot of

00:34:39,190 --> 00:34:41,429
day

00:35:11,950 --> 00:35:15,030

YouTube URL: https://www.youtube.com/watch?v=qWY2sUpt-Ek


