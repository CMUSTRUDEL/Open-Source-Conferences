Title: Effective Automated Testing of IoT Systems
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speakers: Miroslav Jaros and Stefan Bunciak

Lively development of the Internet of Things (IoT) applications is one of the hot topics in the current technology area. However, design, implementation and testing of these systems bring also many challenges and these challenges have to be responded by proper effective methods. In this talk, we will show you some of those problems in the Quality Assurance and testing area. Then, we will introduce you the PatrIoT framework, the cutting-edge project that aims to solve some of these challenges. The PatrIoT provides a possibility of easy to use integration testing of IoT applications, a flexible build of system testbed using simulation components or a set of special model-based testing methods to design effective test cases for an IoT system.
Captions: 
	00:00:02,550 --> 00:00:09,780
so hello everyone thank you for

00:00:04,770 --> 00:00:10,969
attending our call our our told my name

00:00:09,780 --> 00:00:14,629
is Stefan Bucher

00:00:10,969 --> 00:00:18,090
I'm a manager of quality engineering and

00:00:14,629 --> 00:00:20,420
department there is Marrakech

00:00:18,090 --> 00:00:23,190
senior Quality Engineer also in the

00:00:20,420 --> 00:00:28,110
department and we'll talk a little bit

00:00:23,190 --> 00:00:30,630
about testing IOT applications through

00:00:28,110 --> 00:00:34,289
some of the challenges we faced in our

00:00:30,630 --> 00:00:37,470
research project and I'll do some of the

00:00:34,289 --> 00:00:42,120
more boring stuff let's say more general

00:00:37,470 --> 00:00:45,270
general concepts and stuff and then talk

00:00:42,120 --> 00:00:50,610
about our our proud our open source

00:00:45,270 --> 00:00:53,850
project but come with Ron so let's get

00:00:50,610 --> 00:00:56,880
started when we talk about Internet of

00:00:53,850 --> 00:01:00,360
Things we generally think of something

00:00:56,880 --> 00:01:05,549
like this a lot of sensors bunch of

00:01:00,360 --> 00:01:07,829
actuators connected via a way sending

00:01:05,549 --> 00:01:09,530
sending data we had a gateway to some

00:01:07,829 --> 00:01:12,359
data centers for processing and

00:01:09,530 --> 00:01:17,909
analytics decision-making and stuff

00:01:12,359 --> 00:01:21,600
later but during our say research and

00:01:17,909 --> 00:01:23,630
our work we found out that things are a

00:01:21,600 --> 00:01:28,540
little bit more complicated than this

00:01:23,630 --> 00:01:31,840
and we sort of discovered

00:01:28,540 --> 00:01:35,200
more of the IOT let's say architectures

00:01:31,840 --> 00:01:38,050
and find great topologies of IOT

00:01:35,200 --> 00:01:40,960
applications and stuff like this so yeah

00:01:38,050 --> 00:01:45,550
you will see that in the following

00:01:40,960 --> 00:01:49,650
slides but even with this let's say a

00:01:45,550 --> 00:01:52,000
little bit simplified simplified

00:01:49,650 --> 00:01:55,620
topology of IOT application or the

00:01:52,000 --> 00:01:58,450
system you can you can already see that

00:01:55,620 --> 00:02:00,190
there can be a lot of a lot of

00:01:58,450 --> 00:02:05,680
challenges when you want to comprehend

00:02:00,190 --> 00:02:09,780
such distributed system right first of

00:02:05,680 --> 00:02:13,380
all there's the environment itself

00:02:09,780 --> 00:02:17,470
there's a lot of apologies a lot of

00:02:13,380 --> 00:02:19,330
protocols in place there's you need to

00:02:17,470 --> 00:02:21,730
take into account the network is

00:02:19,330 --> 00:02:23,890
sometimes limited in its bandwidth and

00:02:21,730 --> 00:02:25,830
stuff like that it's not like perfect

00:02:23,890 --> 00:02:28,990
conditions in your in your data center

00:02:25,830 --> 00:02:31,990
there is a lot of different technology

00:02:28,990 --> 00:02:35,200
stacks different devices and stuff like

00:02:31,990 --> 00:02:39,820
that then there is also the aspect of

00:02:35,200 --> 00:02:44,150
performance right when you have hundreds

00:02:39,820 --> 00:02:47,810
or thousands of sensors generating data

00:02:44,150 --> 00:02:51,560
it's a huge load for the IOT systems

00:02:47,810 --> 00:02:54,290
actually process and work with it so

00:02:51,560 --> 00:02:56,750
that's one important aspect or one

00:02:54,290 --> 00:02:59,650
important challenge letting you take

00:02:56,750 --> 00:03:02,269
into account then there's the thing of

00:02:59,650 --> 00:03:06,829
the integration itself right you have a

00:03:02,269 --> 00:03:10,159
big distributed system sometimes very

00:03:06,829 --> 00:03:13,040
very resource demanding to deploy or or

00:03:10,159 --> 00:03:15,349
it's actually some put together right

00:03:13,040 --> 00:03:17,359
you have the sensors you have the

00:03:15,349 --> 00:03:20,299
actuators of various types you have the

00:03:17,359 --> 00:03:22,099
gateways you have the business logic in

00:03:20,299 --> 00:03:23,569
there you have the analytics parts and

00:03:22,099 --> 00:03:25,579
you need to basically spinning up

00:03:23,569 --> 00:03:28,180
everything at once in order to

00:03:25,579 --> 00:03:30,379
comprehensively test it so it's not just

00:03:28,180 --> 00:03:32,170
testing the small parts coming in to

00:03:30,379 --> 00:03:36,230
take into account the whole picture so

00:03:32,170 --> 00:03:41,060
that the IOT system works as as designed

00:03:36,230 --> 00:03:45,879
as you want and one of the last things

00:03:41,060 --> 00:03:51,950
that we observed is that there's a huge

00:03:45,879 --> 00:03:53,080
let's say almost unlimited even and it's

00:03:51,950 --> 00:03:56,560
kind

00:03:53,080 --> 00:04:00,580
of the data and data includes the system

00:03:56,560 --> 00:04:03,270
list process and work right so coming

00:04:00,580 --> 00:04:07,720
from that come from the sensor so

00:04:03,270 --> 00:04:13,300
ideally you would somehow create only

00:04:07,720 --> 00:04:15,910
only a subset of this data put into the

00:04:13,300 --> 00:04:18,100
to put into the IOT application for

00:04:15,910 --> 00:04:19,269
testing so that it travels all the all

00:04:18,100 --> 00:04:23,440
the important aspects of the

00:04:19,269 --> 00:04:25,630
applications but not like test every

00:04:23,440 --> 00:04:28,900
single possible input because that would

00:04:25,630 --> 00:04:33,120
of course create a huge amount of test

00:04:28,900 --> 00:04:37,360
runs and test execution is required for

00:04:33,120 --> 00:04:44,170
comprehensive testing so with these

00:04:37,360 --> 00:04:54,100
challenges in mind we teamed up with our

00:04:44,170 --> 00:04:57,460
university partners from university to

00:04:54,100 --> 00:05:00,400
get a project proposal title quality

00:04:57,460 --> 00:05:03,610
assurance system for internal things and

00:05:00,400 --> 00:05:07,500
submitted to check agency of technology

00:05:03,610 --> 00:05:10,980
for for support our project got accepted

00:05:07,500 --> 00:05:20,350
and the work basically kicked off in

00:05:10,980 --> 00:05:22,460
2017 it consists of two two important

00:05:20,350 --> 00:05:25,910
aspects I mean

00:05:22,460 --> 00:05:29,850
methodologic part and the technical part

00:05:25,910 --> 00:05:31,860
as you as you can imagine the technical

00:05:29,850 --> 00:05:35,750
part is handled mostly by the rated

00:05:31,860 --> 00:05:38,490
engineers and the methodology part is

00:05:35,750 --> 00:05:48,870
taken care of by the by the university

00:05:38,490 --> 00:05:50,910
people so our journey began at very the

00:05:48,870 --> 00:05:53,670
very beginning of the project we

00:05:50,910 --> 00:05:56,190
basically had to define what the what

00:05:53,670 --> 00:05:58,280
the IOT sister IT application which

00:05:56,190 --> 00:06:00,870
place how does it look like what are the

00:05:58,280 --> 00:06:04,250
important approaches we need to have in

00:06:00,870 --> 00:06:06,240
mind what are the protocols what are the

00:06:04,250 --> 00:06:09,990
deployments use what are the technology

00:06:06,240 --> 00:06:12,630
stacks that are being used and in the

00:06:09,990 --> 00:06:16,230
industry how does it all work together

00:06:12,630 --> 00:06:18,480
you know how to even how to even test

00:06:16,230 --> 00:06:21,780
such such a distributed and

00:06:18,480 --> 00:06:24,090
heterogeneous environments so there were

00:06:21,780 --> 00:06:26,640
there were a lot of a lot of questions

00:06:24,090 --> 00:06:29,130
in the in the beginning let's say yeah

00:06:26,640 --> 00:06:31,380
one of them being also how to how to

00:06:29,130 --> 00:06:34,500
effectively effectively automate such

00:06:31,380 --> 00:06:36,780
testing arrives at the end if you are

00:06:34,500 --> 00:06:40,439
developing a distributed data system you

00:06:36,780 --> 00:06:43,409
want to be automated and

00:06:40,439 --> 00:06:44,869
run all the tests and ideally you know

00:06:43,409 --> 00:06:48,269
some sort of continuous integration

00:06:44,869 --> 00:06:50,699
environment right you don't wanna run

00:06:48,269 --> 00:06:53,939
the test in a manual fashion so there

00:06:50,699 --> 00:06:56,639
was a lot of a lot of questions we had

00:06:53,939 --> 00:07:00,149
we had to answer before some some real

00:06:56,639 --> 00:07:02,669
work should even begin so we basically

00:07:00,149 --> 00:07:05,129
started with with a question of how the

00:07:02,669 --> 00:07:10,559
typical IOT system arrived the

00:07:05,129 --> 00:07:13,499
application look like topologies and we

00:07:10,559 --> 00:07:20,159
basically came up came up with five of

00:07:13,499 --> 00:07:23,519
those very different ones and walk you

00:07:20,159 --> 00:07:31,110
walk you through a little bit more

00:07:23,519 --> 00:07:34,619
detail so it started as a question what

00:07:31,110 --> 00:07:37,679
is the int application so we went to the

00:07:34,619 --> 00:07:40,669
papers right we start digging digging

00:07:37,679 --> 00:07:44,219
and after hundreds of hours and

00:07:40,669 --> 00:07:46,499
searching from reading hundreds of

00:07:44,219 --> 00:07:51,360
papers we found out that we can

00:07:46,499 --> 00:07:53,009
categorize the vast majority of the

00:07:51,360 --> 00:07:55,949
architectures into five different

00:07:53,009 --> 00:07:57,779
categories so first of all and that is

00:07:55,949 --> 00:08:00,750
the most common one as you know it is

00:07:57,779 --> 00:08:04,110
the Gateway century

00:08:00,750 --> 00:08:07,260
or deployment that's even the deployment

00:08:04,110 --> 00:08:08,640
he probably you know from your house in

00:08:07,260 --> 00:08:24,690
a way that you have some gateway to

00:08:08,640 --> 00:08:27,330
point all right so that's this

00:08:24,690 --> 00:08:28,950
application you probably know the best

00:08:27,330 --> 00:08:32,340
because that's the kind of application

00:08:28,950 --> 00:08:35,460
you can have in your house you do have

00:08:32,340 --> 00:08:37,469
some single gateway where all the

00:08:35,460 --> 00:08:39,719
amenities all the things that you have

00:08:37,469 --> 00:08:43,380
in your house are connected to which

00:08:39,719 --> 00:08:46,020
collects the data and then you somehow

00:08:43,380 --> 00:08:48,750
interact with the Gateway in a way like

00:08:46,020 --> 00:08:50,610
okay when I want to open my window I

00:08:48,750 --> 00:08:54,060
will just click in my web application at

00:08:50,610 --> 00:08:57,330
home and do window will open something

00:08:54,060 --> 00:09:00,750
like that so pretty simple application

00:08:57,330 --> 00:09:03,860
very easy task even but then there are

00:09:00,750 --> 00:09:05,750
different like the distributed mesh

00:09:03,860 --> 00:09:08,270
there's a there's a kind of application

00:09:05,750 --> 00:09:10,370
that it's really similar to the micro

00:09:08,270 --> 00:09:13,070
service architecture as you know it now

00:09:10,370 --> 00:09:15,680
so a lot of different things that are

00:09:13,070 --> 00:09:18,110
sending data all over the place and

00:09:15,680 --> 00:09:20,510
communicating among themselves like one

00:09:18,110 --> 00:09:23,060
actuator knows that it has to listen to

00:09:20,510 --> 00:09:27,040
different sensor and when message

00:09:23,060 --> 00:09:27,040
emerges it will react somehow

00:09:30,940 --> 00:09:37,570
then there is a connected internet of

00:09:33,310 --> 00:09:40,530
things this is something more related to

00:09:37,570 --> 00:09:44,530
the industry why how the internet things

00:09:40,530 --> 00:09:48,970
works there like if you are in some I

00:09:44,530 --> 00:09:53,830
believe the correct abbreviation is a

00:09:48,970 --> 00:10:00,520
IOT industrial IOT please handle so you

00:09:53,830 --> 00:10:06,450
have different parts of your factory has

00:10:00,520 --> 00:10:08,980
a different separated networks that are

00:10:06,450 --> 00:10:12,280
mostly single purpose and then they

00:10:08,980 --> 00:10:18,220
communicate via some Gatorade together

00:10:12,280 --> 00:10:20,380
and they interact together

00:10:18,220 --> 00:10:21,760
and then there is the last part and

00:10:20,380 --> 00:10:24,790
there's a collaborative IOT application

00:10:21,760 --> 00:10:28,050
this is the architecture Isis

00:10:24,790 --> 00:10:33,970
architecture that is used mostly in the

00:10:28,050 --> 00:10:36,760
big larger scale deployments like like

00:10:33,970 --> 00:10:40,390
smart cities etc so you do have a

00:10:36,760 --> 00:10:43,030
separate parts per gate place these are

00:10:40,390 --> 00:10:44,950
somehow interconnected let's say one

00:10:43,030 --> 00:10:48,400
gateway is collecting data from I don't

00:10:44,950 --> 00:10:51,870
know the traffic control stuff

00:10:48,400 --> 00:11:00,610
another way is getting from I don't know

00:10:51,870 --> 00:11:03,250
the IC e and then they communicate

00:11:00,610 --> 00:11:05,680
somehow larger level like between the

00:11:03,250 --> 00:11:07,660
gateways and there's some user who tries

00:11:05,680 --> 00:11:11,050
to collect all the data together and

00:11:07,660 --> 00:11:12,790
combine them then mix like this then

00:11:11,050 --> 00:11:14,500
there is the last architecture and that

00:11:12,790 --> 00:11:19,480
would be the wireless sensor network

00:11:14,500 --> 00:11:21,610
which is somehow out of the scope but

00:11:19,480 --> 00:11:23,140
also in the scope because this is more

00:11:21,610 --> 00:11:25,750
related to the technology than to the

00:11:23,140 --> 00:11:29,710
architecture itself because you can see

00:11:25,750 --> 00:11:34,330
the wireless sensor as some part of just

00:11:29,710 --> 00:11:36,330
one network and or maybe as even as a

00:11:34,330 --> 00:11:38,880
single device

00:11:36,330 --> 00:11:40,500
if you if you look at it it's a single

00:11:38,880 --> 00:11:43,680
device it provides you data from the

00:11:40,500 --> 00:11:48,220
whole network but it has to be in mind

00:11:43,680 --> 00:11:53,280
as well for the design

00:11:48,220 --> 00:11:56,820
so so

00:11:53,280 --> 00:11:59,100
with these let's say first questions

00:11:56,820 --> 00:12:03,120
answered like what the IOT application

00:11:59,100 --> 00:12:05,610
or IOT architectures look like we wanted

00:12:03,120 --> 00:12:09,300
to address the challenges outlined in

00:12:05,610 --> 00:12:11,660
the previous slides so the first the

00:12:09,300 --> 00:12:15,330
first and most important is the

00:12:11,660 --> 00:12:18,110
heterogeneous environment so we we knew

00:12:15,330 --> 00:12:20,940
that we would need something that would

00:12:18,110 --> 00:12:22,860
simulate the networks simulate the

00:12:20,940 --> 00:12:25,350
various kinds of networks various

00:12:22,860 --> 00:12:28,440
topologies that we will also need

00:12:25,350 --> 00:12:32,430
something that would emulate the devices

00:12:28,440 --> 00:12:38,160
the actuators and simulators and let's

00:12:32,430 --> 00:12:40,170
say the same time it would support the

00:12:38,160 --> 00:12:43,080
emulated devices to be configured in a

00:12:40,170 --> 00:12:46,050
way that we wanted to behave like lights

00:12:43,080 --> 00:12:47,790
so we can actually tell them hey you're

00:12:46,050 --> 00:12:50,370
going to be a temperature sensor and you

00:12:47,790 --> 00:12:57,090
will behave like like number that normal

00:12:50,370 --> 00:12:59,779
day in muscat say but at some point we

00:12:57,090 --> 00:13:03,379
need to be able to tell him like hey

00:12:59,779 --> 00:13:05,839
I don't know an earthquake Rises so it

00:13:03,379 --> 00:13:07,610
needs to start behaving a bit

00:13:05,839 --> 00:13:15,680
differently for a short period of time

00:13:07,610 --> 00:13:18,980
so with these features in mind we need

00:13:15,680 --> 00:13:22,959
to start incrementing features like this

00:13:18,980 --> 00:13:26,199
then there's the matter of performance

00:13:22,959 --> 00:13:29,600
again the idea of thing would be to take

00:13:26,199 --> 00:13:32,889
an existing tool right and and integrate

00:13:29,600 --> 00:13:38,240
with it so we do not reinvent the wheel

00:13:32,889 --> 00:13:41,660
so we picked up the profit - because

00:13:38,240 --> 00:13:45,279
it's developed by our colleagues at red

00:13:41,660 --> 00:13:48,560
envelope so there was our obvious choice

00:13:45,279 --> 00:13:51,680
then there is the matter of integration

00:13:48,560 --> 00:13:55,970
and entrance scenarios let's say again

00:13:51,680 --> 00:14:00,009
we wanted to take a facto standard and

00:13:55,970 --> 00:14:04,040
in this case it was the JUnit framework

00:14:00,009 --> 00:14:06,740
so again we do not even when do we build

00:14:04,040 --> 00:14:09,110
build upon that's already in in the

00:14:06,740 --> 00:14:13,160
world out there and

00:14:09,110 --> 00:14:15,830
last challenge we outlined was the huge

00:14:13,160 --> 00:14:18,680
amount of data variants and

00:14:15,830 --> 00:14:21,920
configurations of the system that's

00:14:18,680 --> 00:14:28,089
something that our university partners

00:14:21,920 --> 00:14:31,220
has experience with so we basically

00:14:28,089 --> 00:14:35,829
built from their knowledge from their

00:14:31,220 --> 00:14:42,850
experience and expertise and our

00:14:35,829 --> 00:14:42,850
colleagues came up with a name oxygen

00:14:44,230 --> 00:14:49,640
let's say the research research guys the

00:14:47,029 --> 00:14:53,110
university put a lot of lot of thoughts

00:14:49,640 --> 00:14:55,250
and a lot of expertise in implementing

00:14:53,110 --> 00:14:58,610
mathematical knowledge and and stuff I

00:14:55,250 --> 00:15:05,029
the theory of testing stuff right and

00:14:58,610 --> 00:15:10,760
into implementation of this tool it's a

00:15:05,029 --> 00:15:12,620
model-based tool for generating test

00:15:10,760 --> 00:15:16,850
cases in an automated fashion where you

00:15:12,620 --> 00:15:19,670
basically very basically put into the

00:15:16,850 --> 00:15:25,670
tool the entities relations between

00:15:19,670 --> 00:15:28,070
entities and operations model it via UML

00:15:25,670 --> 00:15:32,149
activity are going to automatically

00:15:28,070 --> 00:15:34,249
generated test cases that would

00:15:32,149 --> 00:15:37,970
system comprised simply but I know most

00:15:34,249 --> 00:15:40,220
of Shui that you don't need to work with

00:15:37,970 --> 00:15:41,629
all the possible inputs but only with a

00:15:40,220 --> 00:15:44,420
subset of it

00:15:41,629 --> 00:15:47,149
in case you are more interested in it

00:15:44,420 --> 00:15:49,009
feel free to grab the baits and and

00:15:47,149 --> 00:15:52,910
contact the contact the University

00:15:49,009 --> 00:15:58,009
people because it's mostly being worked

00:15:52,910 --> 00:16:01,550
on on it by the University researchers

00:15:58,009 --> 00:16:03,860
and professors not really our our domain

00:16:01,550 --> 00:16:07,040
what is our domain though is the

00:16:03,860 --> 00:16:11,180
automated testing framework we are this

00:16:07,040 --> 00:16:17,689
one we won't address all the remaining

00:16:11,180 --> 00:16:20,089
challenges in Mt testing first of all we

00:16:17,689 --> 00:16:23,300
had to put in place some of the some of

00:16:20,089 --> 00:16:27,800
us a hard stop requirements first of all

00:16:23,300 --> 00:16:30,079
of course to be open source the second

00:16:27,800 --> 00:16:31,809
one is that we wanted to build as I

00:16:30,079 --> 00:16:34,459
mentioned on a de facto standard

00:16:31,809 --> 00:16:40,550
technologies that in our case was DG one

00:16:34,459 --> 00:16:43,309
is 5 then the most important features

00:16:40,550 --> 00:16:45,949
let's say which were simulators and

00:16:43,309 --> 00:16:50,170
generators and fork simulations and data

00:16:45,949 --> 00:16:52,910
generators so that we can automate

00:16:50,170 --> 00:16:55,970
network deployment automate data

00:16:52,910 --> 00:16:57,930
generation properly it says the IOT

00:16:55,970 --> 00:17:01,770
application

00:16:57,930 --> 00:17:05,010
and last one it was that it had to be a

00:17:01,770 --> 00:17:08,580
compliant so that we can get up to

00:17:05,010 --> 00:17:12,840
see I too like Jenkins or Travis Travis

00:17:08,580 --> 00:17:17,490
so with these additional requirements in

00:17:12,840 --> 00:17:22,110
mind we went on and I wanted to design

00:17:17,490 --> 00:17:24,900
the system as you can see we also put a

00:17:22,110 --> 00:17:29,520
lot of thought into it so it ended up

00:17:24,900 --> 00:17:32,040
like like this one not something you

00:17:29,520 --> 00:17:34,800
would call a simple diagram but as you

00:17:32,040 --> 00:17:40,020
will see later on fortunately it was

00:17:34,800 --> 00:17:42,450
sterile to be a bit more simple this was

00:17:40,020 --> 00:17:45,690
the first first design we came up with

00:17:42,450 --> 00:17:48,120
and delivered to the shake agency of

00:17:45,690 --> 00:17:55,350
Technology as part of our final report

00:17:48,120 --> 00:17:57,540
in the first year so yes like that the

00:17:55,350 --> 00:17:59,610
colors are there for reason because for

00:17:57,540 --> 00:18:03,250
every single component you can see there

00:17:59,610 --> 00:18:05,669
there was a different diagram that

00:18:03,250 --> 00:18:09,460
the defined interactions more

00:18:05,669 --> 00:18:16,630
comprehensively so this was a basically

00:18:09,460 --> 00:18:20,500
high-level nevertheless even with this

00:18:16,630 --> 00:18:23,530
system design in place we were very

00:18:20,500 --> 00:18:27,820
brave and went to the implementation

00:18:23,530 --> 00:18:28,809
phase and basically set up open source

00:18:27,820 --> 00:18:33,280
project called

00:18:28,809 --> 00:18:36,100
Patriot and Merrick will talk you to

00:18:33,280 --> 00:18:42,580
walk you through some of the some of the

00:18:36,100 --> 00:18:45,720
details of our project okay so about the

00:18:42,580 --> 00:18:48,820
picture so as we said we started with

00:18:45,720 --> 00:18:54,730
architecture it's a multi lecture and we

00:18:48,820 --> 00:18:58,210
have design you saw on the slide before

00:18:54,730 --> 00:19:02,230
so the goal of the picture is to give

00:18:58,210 --> 00:19:07,180
you some tools some framework that will

00:19:02,230 --> 00:19:11,560
allow you to build up a testing solution

00:19:07,180 --> 00:19:15,250
that will enable you to simulate somehow

00:19:11,560 --> 00:19:17,940
the network or the network topology that

00:19:15,250 --> 00:19:24,430
is going to be used by your application

00:19:17,940 --> 00:19:27,730
emulate behavior of different kinds of

00:19:24,430 --> 00:19:29,950
data providers like other sensors or to

00:19:27,730 --> 00:19:33,070
emulate the behavior of actuators that

00:19:29,950 --> 00:19:35,500
you are going to have deployed in the

00:19:33,070 --> 00:19:39,150
real application the reason why we are

00:19:35,500 --> 00:19:43,630
simulating this is simple to have this

00:19:39,150 --> 00:19:49,500
kind of test bag ready that's really

00:19:43,630 --> 00:19:52,480
expensive and the tests are hardly

00:19:49,500 --> 00:19:56,580
repeatable etc because basically you

00:19:52,480 --> 00:19:59,860
will end up with some technology some

00:19:56,580 --> 00:20:04,690
physical demonstration where you will

00:19:59,860 --> 00:20:06,910
have to look over it write down the

00:20:04,690 --> 00:20:09,490
results of the test cases and then you

00:20:06,910 --> 00:20:13,000
can measure them so that's why we and we

00:20:09,490 --> 00:20:16,780
started with simulations etc of course

00:20:13,000 --> 00:20:23,460
it is some disadvantages like you can't

00:20:16,780 --> 00:20:23,460
test this out integrations if you have

00:20:23,890 --> 00:20:26,400
um

00:20:27,200 --> 00:20:33,080
yeah so we ended up with five

00:20:29,780 --> 00:20:39,440
cornerstones the component for network

00:20:33,080 --> 00:20:42,350
simulation component for data

00:20:39,440 --> 00:20:44,810
emulation or data generation test runner

00:20:42,350 --> 00:20:48,350
for the integration testing which will

00:20:44,810 --> 00:20:52,190
allow you to do the integration testing

00:20:48,350 --> 00:20:54,380
itself in the most simple way some

00:20:52,190 --> 00:20:58,280
extensions for reporting and metrics

00:20:54,380 --> 00:21:01,990
because in these scenarios the basic

00:20:58,280 --> 00:21:04,130
ones like only plain X units etc are not

00:21:01,990 --> 00:21:07,880
sufficient for you because you are

00:21:04,130 --> 00:21:09,680
dealing with distributed environment and

00:21:07,880 --> 00:21:13,220
components for integration with some

00:21:09,680 --> 00:21:16,760
performance tool because we need to test

00:21:13,220 --> 00:21:19,210
that as well so as you can see we pretty

00:21:16,760 --> 00:21:19,210
narrow it down

00:21:19,270 --> 00:21:23,860
in a way how to design it so we ended up

00:21:21,610 --> 00:21:27,760
with three basic components of course

00:21:23,860 --> 00:21:29,860
that's work in progress right so in some

00:21:27,760 --> 00:21:32,260
next release it will grow but right now

00:21:29,860 --> 00:21:36,370
we are only three components and we are

00:21:32,260 --> 00:21:39,630
happy enough but all the interactions

00:21:36,370 --> 00:21:45,700
that were defined are there somehow

00:21:39,630 --> 00:21:47,380
right so we do have the free basic stuff

00:21:45,700 --> 00:21:49,480
of course there will be the performance

00:21:47,380 --> 00:21:53,140
in next release that will be somehow

00:21:49,480 --> 00:21:57,580
connected to it etc and also the

00:21:53,140 --> 00:22:00,539
simulator part will probably divide also

00:21:57,580 --> 00:22:01,860
two more providers then there are now

00:22:00,539 --> 00:22:05,080
exactly

00:22:01,860 --> 00:22:06,610
so the primer by the framework base we

00:22:05,080 --> 00:22:09,520
started with JUnit 5

00:22:06,610 --> 00:22:13,539
why do unit 5 Wow because for the

00:22:09,520 --> 00:22:17,500
testing you don't want to use lowland

00:22:13,539 --> 00:22:20,740
language in general because if you if we

00:22:17,500 --> 00:22:24,120
would start with something like C and we

00:22:20,740 --> 00:22:24,120
try to build a

00:22:24,759 --> 00:22:30,179
a comprehensive system for testing and

00:22:26,769 --> 00:22:30,179
you will end up with

00:22:30,510 --> 00:22:35,820
framework that will test your allocation

00:22:33,660 --> 00:22:39,210
but after you have written something

00:22:35,820 --> 00:22:43,470
like thousands of lines of code to write

00:22:39,210 --> 00:22:45,510
single testing methods right so and yyy

00:22:43,470 --> 00:22:48,690
Java and unified because unify this

00:22:45,510 --> 00:22:53,970
pretty new technology which is highly

00:22:48,690 --> 00:22:58,410
customizable and extensible and we know

00:22:53,970 --> 00:23:02,700
it the best second reason

00:22:58,410 --> 00:23:05,190
so the base defines the api's for

00:23:02,700 --> 00:23:10,350
interactions so it defines the API for

00:23:05,190 --> 00:23:13,040
the network simulation in case you will

00:23:10,350 --> 00:23:16,740
need to extend it for your specific

00:23:13,040 --> 00:23:18,660
model or something like that it defy it

00:23:16,740 --> 00:23:21,270
extends the basic properties of unit

00:23:18,660 --> 00:23:25,170
because you itself is still unit testing

00:23:21,270 --> 00:23:28,760
framework so there are stuff like random

00:23:25,170 --> 00:23:31,410
random orders etc but even the janitor

00:23:28,760 --> 00:23:34,290
developers are extending it so you can

00:23:31,410 --> 00:23:36,770
do some stuff with it and we are doing

00:23:34,290 --> 00:23:39,900
some stuff with it as well so we

00:23:36,770 --> 00:23:43,370
extended the properties to and some

00:23:39,900 --> 00:23:48,570
things like skipping the test execution

00:23:43,370 --> 00:23:52,970
when another test fail for instance you

00:23:48,570 --> 00:23:55,980
don't want to test your function for

00:23:52,970 --> 00:24:01,200
division if it failed on the single of

00:23:55,980 --> 00:24:03,960
the scenario right but you have to think

00:24:01,200 --> 00:24:07,340
of it in a more complex way in a bigger

00:24:03,960 --> 00:24:11,490
system so that's why we added this or

00:24:07,340 --> 00:24:14,100
breakpoints okay I I started this test

00:24:11,490 --> 00:24:18,120
but if this test file we don't need to

00:24:14,100 --> 00:24:20,940
continue so that kind of thing then

00:24:18,120 --> 00:24:23,070
there is single management bicycle food

00:24:20,940 --> 00:24:25,770
hub which contains all the things

00:24:23,070 --> 00:24:29,440
created by the framework to over to

00:24:25,770 --> 00:24:31,780
manage it so what say you want to

00:24:29,440 --> 00:24:34,150
in between the test you want to set up

00:24:31,780 --> 00:24:38,799
some environment change like okay right

00:24:34,150 --> 00:24:40,600
now or segment of network will fail it

00:24:38,799 --> 00:24:43,660
will be described it you can do it

00:24:40,600 --> 00:24:45,220
without it I like to itself you are miss

00:24:43,660 --> 00:24:47,200
connected and it will happen and then

00:24:45,220 --> 00:24:48,820
you can resume your testing and testing

00:24:47,200 --> 00:24:58,020
what is going to help in your

00:24:48,820 --> 00:25:00,340
environment and it is the framework so

00:24:58,020 --> 00:25:03,039
other parts of the framework will be

00:25:00,340 --> 00:25:07,240
basically I'm all probably useless to

00:25:03,039 --> 00:25:08,919
you without this piece okay so the

00:25:07,240 --> 00:25:11,200
network simulation I would say this is

00:25:08,919 --> 00:25:13,980
the biggest part of the virtual

00:25:11,200 --> 00:25:13,980
framework itself

00:25:17,230 --> 00:25:24,240
so it provides you too late to emulate

00:25:21,789 --> 00:25:27,490
and wear to our and deploy your

00:25:24,240 --> 00:25:30,370
application to define the topology of

00:25:27,490 --> 00:25:32,649
your network application like spooning

00:25:30,370 --> 00:25:35,260
of several networks and several network

00:25:32,649 --> 00:25:38,260
segments and then deploying specific

00:25:35,260 --> 00:25:43,480
applications or a specific part of

00:25:38,260 --> 00:25:46,720
application into it it does have full

00:25:43,480 --> 00:25:52,450
control over the network so at any point

00:25:46,720 --> 00:25:54,760
of the test run or you know before face

00:25:52,450 --> 00:25:56,320
after face anywhere you can say

00:25:54,760 --> 00:25:59,260
something like ok right now you are

00:25:56,320 --> 00:26:04,240
treating your IP address or you are

00:25:59,260 --> 00:26:07,059
going to behave maliciously somehow but

00:26:04,240 --> 00:26:11,679
ok right now we are going to send only

00:26:07,059 --> 00:26:18,130
50% of maggots that you can this is the

00:26:11,679 --> 00:26:20,919
thing right now it's completely it's

00:26:18,130 --> 00:26:22,590
using comma dr. wieder color because we

00:26:20,919 --> 00:26:25,960
need to be needed to have some

00:26:22,590 --> 00:26:29,350
easy-to-use environment for proof of

00:26:25,960 --> 00:26:32,830
concept and it applies how to even

00:26:29,350 --> 00:26:34,929
define API so what do we really need to

00:26:32,830 --> 00:26:39,290
have in common

00:26:34,929 --> 00:26:42,260
you get to work in state but currently

00:26:39,290 --> 00:26:44,420
we are sorry we are working on another I

00:26:42,260 --> 00:26:49,550
will get to it later but we are working

00:26:44,420 --> 00:26:53,230
another runtimes as well okay next slide

00:26:49,550 --> 00:26:55,640
please so this is this is somehow

00:26:53,230 --> 00:26:58,580
capture about network simulation

00:26:55,640 --> 00:26:59,660
operates so the test Runner itself or

00:26:58,580 --> 00:27:03,550
the strongarm

00:26:59,660 --> 00:27:05,690
all the automation around this run can

00:27:03,550 --> 00:27:08,080
create a simulated environment in

00:27:05,690 --> 00:27:11,420
whether it will create several networks

00:27:08,080 --> 00:27:14,480
in order it's pretty simple that's

00:27:11,420 --> 00:27:17,360
another reason why we use it and then it

00:27:14,480 --> 00:27:21,650
can deploy the applications in this case

00:27:17,360 --> 00:27:24,440
look at this square or rectangle I

00:27:21,650 --> 00:27:28,429
didn't put some label to it as a single

00:27:24,440 --> 00:27:30,110
container how we operate is to every

00:27:28,429 --> 00:27:32,540
single container that is running in the

00:27:30,110 --> 00:27:35,570
simulated environment we had a simple

00:27:32,540 --> 00:27:38,960
thin layer of abstraction to it that's

00:27:35,570 --> 00:27:41,870
our part this is our API which allows us

00:27:38,960 --> 00:27:45,290
to connect to it and somehow modify its

00:27:41,870 --> 00:27:47,450
behavior we can do it either while

00:27:45,290 --> 00:27:50,179
setting up the network in the debate

00:27:47,450 --> 00:27:52,400
from the interface itself or why are the

00:27:50,179 --> 00:27:53,840
IP tables which are their present as

00:27:52,400 --> 00:27:55,760
well

00:27:53,840 --> 00:27:59,060
and then there is a second part which is

00:27:55,760 --> 00:28:05,590
under the root itself you can imagine it

00:27:59,060 --> 00:28:05,590
as a normal every computer so it's a

00:28:06,790 --> 00:28:12,260
container that is connected to both

00:28:09,260 --> 00:28:14,690
networks and has a routing table that

00:28:12,260 --> 00:28:19,880
allows to forward packets from one to

00:28:14,690 --> 00:28:23,270
another via this wire this control

00:28:19,880 --> 00:28:25,910
interfaces you can then set things like

00:28:23,270 --> 00:28:27,950
okay I am completely disconnecting my

00:28:25,910 --> 00:28:31,130
application from the internet what is

00:28:27,950 --> 00:28:33,920
going to happen I am going to disconnect

00:28:31,130 --> 00:28:36,740
in single application or you can tell

00:28:33,920 --> 00:28:38,410
fewer okay you are not routing this

00:28:36,740 --> 00:28:42,310
application anymore

00:28:38,410 --> 00:28:47,450
in case you would test something like I

00:28:42,310 --> 00:28:50,170
don't know sending of the information

00:28:47,450 --> 00:28:50,170
why furniture

00:28:50,250 --> 00:28:55,530
so that's it how the network simulation

00:28:52,289 --> 00:28:57,840
of Rights and then there is a data

00:28:55,530 --> 00:29:02,299
simulator so for the data simulator our

00:28:57,840 --> 00:29:02,299
initial thought was to create some

00:29:03,200 --> 00:29:09,630
simple tool that would behave like a

00:29:06,150 --> 00:29:13,440
Lego if you know it I'm not sure if I

00:29:09,630 --> 00:29:22,980
can say Lego train bar but please don't

00:29:13,440 --> 00:29:28,110
tell on me so for our photos to create

00:29:22,980 --> 00:29:31,250
something that would easily enable you

00:29:28,110 --> 00:29:36,080
to build your solution as you were it

00:29:31,250 --> 00:29:38,850
the base of the network simulation is

00:29:36,080 --> 00:29:41,039
mathematical property of your device for

00:29:38,850 --> 00:29:44,880
instance when you would be simulating a

00:29:41,039 --> 00:29:47,120
thermometer there are mathematical

00:29:44,880 --> 00:29:51,429
functions that defines how the

00:29:47,120 --> 00:29:55,089
temperature behaves during the day

00:29:51,429 --> 00:29:57,580
our how are they assimilated and

00:29:55,089 --> 00:30:02,190
incorporates mathematical library that

00:29:57,580 --> 00:30:07,509
will allow you to in combination with

00:30:02,190 --> 00:30:09,309
with some random data generator combine

00:30:07,509 --> 00:30:11,409
it with your mathematical property and

00:30:09,309 --> 00:30:14,289
for instance by the distribution

00:30:11,409 --> 00:30:16,200
function define what data will be signed

00:30:14,289 --> 00:30:18,330
out

00:30:16,200 --> 00:30:21,239
so this is the first place how to get

00:30:18,330 --> 00:30:24,629
the blender how to get the data that's

00:30:21,239 --> 00:30:28,470
for seat for the data that will modify

00:30:24,629 --> 00:30:32,850
the behavior of the generator then there

00:30:28,470 --> 00:30:36,239
is a second part which which describes

00:30:32,850 --> 00:30:38,369
where you can describe how the data

00:30:36,239 --> 00:30:40,019
which are typically some number some

00:30:38,369 --> 00:30:45,090
double or something like that are

00:30:40,019 --> 00:30:49,700
transformed into some meaningful number

00:30:45,090 --> 00:30:49,700
like for instance if you would go with

00:30:49,879 --> 00:30:59,700
your mathematical function will only

00:30:52,499 --> 00:31:03,239
define the increments or decrements of

00:30:59,700 --> 00:31:05,909
the value itself but it will not set the

00:31:03,239 --> 00:31:08,850
zero so then you have one single

00:31:05,909 --> 00:31:11,100
transformation in the in the input is

00:31:08,850 --> 00:31:15,779
some table I want to transform it into

00:31:11,100 --> 00:31:17,509
the real the real temperature so then I

00:31:15,779 --> 00:31:21,450
have to apply some modification to it

00:31:17,509 --> 00:31:25,470
and then there is last part how to how

00:31:21,450 --> 00:31:27,389
to transform this data into something

00:31:25,470 --> 00:31:33,420
that is transferable over the internet

00:31:27,389 --> 00:31:36,240
so wrapping up solution into

00:31:33,420 --> 00:31:40,770
let's say MVP message and send it out

00:31:36,240 --> 00:31:42,950
pour into a rest or into a or something

00:31:40,770 --> 00:31:42,950
like that

00:31:46,800 --> 00:31:53,350
okay so those were the three

00:31:49,680 --> 00:32:00,640
cornerstones of the application what's

00:31:53,350 --> 00:32:03,370
next for the to doto release so as I

00:32:00,640 --> 00:32:07,060
said this would be up done right now is

00:32:03,370 --> 00:32:12,010
basically more of a POC than production

00:32:07,060 --> 00:32:15,930
very solution we are aiming to the TRO

00:32:12,010 --> 00:32:19,660
by the end of this month and we should

00:32:15,930 --> 00:32:21,820
throw out we will provide some better in

00:32:19,660 --> 00:32:24,250
parts of framework for integration

00:32:21,820 --> 00:32:29,320
testing what we have right now in mind

00:32:24,250 --> 00:32:32,980
is more support for execution in a way

00:32:29,320 --> 00:32:35,800
that you could describe the dependencies

00:32:32,980 --> 00:32:39,340
between the test classes and test cases

00:32:35,800 --> 00:32:44,070
as a tree for instance you for instance

00:32:39,340 --> 00:32:47,980
one thing we are going to implement is

00:32:44,070 --> 00:32:53,350
libel or adaptation after test after

00:32:47,980 --> 00:32:56,020
test after that will allow you to say to

00:32:53,350 --> 00:33:00,570
test class that it should be or s to be

00:32:56,020 --> 00:33:00,570
after a different test cause is

00:33:00,630 --> 00:33:03,440
and things like that

00:33:05,400 --> 00:33:09,720
second Maxine provide with the

00:33:07,440 --> 00:33:13,230
integration of the framework powerhouse

00:33:09,720 --> 00:33:16,800
framework parts right now it works

00:33:13,230 --> 00:33:21,390
together but we don't have any support

00:33:16,800 --> 00:33:24,720
for simple music so yeah you can use the

00:33:21,390 --> 00:33:28,380
network simulator and Jamie extensions

00:33:24,720 --> 00:33:30,570
and the data generator right now it

00:33:28,380 --> 00:33:32,430
doesn't basically know about the

00:33:30,570 --> 00:33:36,720
basically doesn't know about themselves

00:33:32,430 --> 00:33:42,050
we want to add some obstruction over it

00:33:36,720 --> 00:33:42,050
in order to make it work together

00:33:43,460 --> 00:33:52,350
next thing since the reporting and

00:33:47,640 --> 00:33:58,070
monitoring is really highlighted feature

00:33:52,350 --> 00:33:58,070
that is expected from us by other

00:33:58,309 --> 00:34:08,970
potential end users we are going to add

00:34:01,770 --> 00:34:11,010
some pre-configured shobana that would

00:34:08,970 --> 00:34:13,940
be connected to the elastic search for

00:34:11,010 --> 00:34:17,750
the collected metrics so you can see the

00:34:13,940 --> 00:34:17,750
metrics of

00:34:18,060 --> 00:34:24,330
execution itself and the last thing

00:34:21,570 --> 00:34:27,240
first cooperation between between the

00:34:24,330 --> 00:34:31,290
rest of framework and FEA this expected

00:34:27,240 --> 00:34:34,020
for it - okay

00:34:31,290 --> 00:34:36,990
and more plants live comprehensively mow

00:34:34,020 --> 00:34:38,060
which we do not have so you won't see it

00:34:36,990 --> 00:34:42,629
in action

00:34:38,060 --> 00:34:44,760
unfortunately we also want to extend the

00:34:42,629 --> 00:34:46,740
network simulation itself first of all

00:34:44,760 --> 00:34:49,409
to spend over more doper hosts right now

00:34:46,740 --> 00:34:52,040
we are able to operate only over one the

00:34:49,409 --> 00:34:53,220
per house we want to make it more like

00:34:52,040 --> 00:34:55,889
buster

00:34:53,220 --> 00:34:59,369
for testing also we want to add some

00:34:55,889 --> 00:35:03,060
things like cooperation with hypervisors

00:34:59,369 --> 00:35:06,440
for instance kvn in order to start and

00:35:03,060 --> 00:35:10,770
to manage virtual machines either as a

00:35:06,440 --> 00:35:14,730
single segment of the network or only as

00:35:10,770 --> 00:35:16,710
a one application and we want to

00:35:14,730 --> 00:35:20,210
introduce open open tracing into the

00:35:16,710 --> 00:35:26,880
framework in order to provide the data

00:35:20,210 --> 00:35:29,940
from the run itself so whenever for

00:35:26,880 --> 00:35:31,500
instance application itself isn't racing

00:35:29,940 --> 00:35:34,640
for system on test is over a coupon

00:35:31,500 --> 00:35:37,290
tracing we could add our data to it and

00:35:34,640 --> 00:35:38,330
then the debugging would be even more

00:35:37,290 --> 00:35:44,390
simple

00:35:38,330 --> 00:35:46,790
and last thing is description of SUV in

00:35:44,390 --> 00:35:48,800
come on file so away how we could

00:35:46,790 --> 00:35:52,880
describe what is going to be deployed

00:35:48,800 --> 00:35:57,470
and how because you're always cool right

00:35:52,880 --> 00:36:01,040
so yeah we do have the definition of

00:35:57,470 --> 00:36:03,080
data generators already we are right now

00:36:01,040 --> 00:36:07,460
working upon the definition of simulated

00:36:03,080 --> 00:36:08,870
environment but we want to weigh with

00:36:07,460 --> 00:36:11,740
the definition of this simulated

00:36:08,870 --> 00:36:14,270
environment to the another part of the

00:36:11,740 --> 00:36:21,380
of the framework why the connection to

00:36:14,270 --> 00:36:26,030
different providers etc yeah that was

00:36:21,380 --> 00:36:28,790
the page we got project itself but it

00:36:26,030 --> 00:36:32,840
plays a role and it's a bigger project

00:36:28,790 --> 00:36:38,300
they started in July 2017 and you should

00:36:32,840 --> 00:36:40,400
finish in the end by the end of 2020 we

00:36:38,300 --> 00:36:45,140
are currently in the in the face when we

00:36:40,400 --> 00:36:49,460
have a POC ready as Mike mentioned and

00:36:45,140 --> 00:36:53,900
still still in the process of completing

00:36:49,460 --> 00:36:56,510
the required features let's say we

00:36:53,900 --> 00:36:57,900
should be completed by the end of this

00:36:56,510 --> 00:37:00,570
year

00:36:57,900 --> 00:37:03,530
and we are already in discussions with

00:37:00,570 --> 00:37:06,690
potential users in in Czech Republic

00:37:03,530 --> 00:37:11,250
both from the methodological perspective

00:37:06,690 --> 00:37:15,530
and a tree or framework itself so

00:37:11,250 --> 00:37:22,370
there's something who aids us next year

00:37:15,530 --> 00:37:26,520
this pilot testing pilot usage in

00:37:22,370 --> 00:37:28,290
customer and real environments by fixing

00:37:26,520 --> 00:37:32,460
and stuff like that we will evaluate the

00:37:28,290 --> 00:37:35,460
project itself and in the 2020 hopefully

00:37:32,460 --> 00:37:39,810
it will be a successful one so that's

00:37:35,460 --> 00:37:42,750
that's from the project timeline in case

00:37:39,810 --> 00:37:46,470
you have any questions feel free to feel

00:37:42,750 --> 00:37:51,000
free to ask or you can reach out to us

00:37:46,470 --> 00:37:54,420
later via email or visit our own web

00:37:51,000 --> 00:37:58,020
page or for our github repo and for

00:37:54,420 --> 00:38:00,870
requests are very welcome in case you

00:37:58,020 --> 00:38:03,390
have interested in testing IOT

00:38:00,870 --> 00:38:05,370
application so thank you very much for

00:38:03,390 --> 00:38:06,960
your attention and if there are any

00:38:05,370 --> 00:38:09,620
questions

00:38:06,960 --> 00:38:09,620
No

00:38:14,120 --> 00:38:17,750

YouTube URL: https://www.youtube.com/watch?v=OeyIc9FL2Z0


